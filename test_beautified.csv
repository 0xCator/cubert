code,godclass,dataclass,longmethod,longparamlist
"private Map<String, String> tika_parse(InputStream sourceStream, String prefix, Integer maxAttribs, Integer maxAttribLen) throws IOException, TikaException, SAXException {
	 final Metadata metadata = new Metadata();
	 final TikaInputStream tikaInputStream = TikaInputStream.get(sourceStream);
	 try {
		 autoDetectParser.parse(tikaInputStream, new DefaultHandler(), metadata);
	 }
	 finally {
		 tikaInputStream.close();
	 }
	 final Map<String, String> results = new HashMap<>();
	 final Pattern metadataKeyFilter = metadataKeyFilterRef.get();
	 final StringBuilder dataBuilder = new StringBuilder();
	 for (final String key : metadata.names()) {
		 if (metadataKeyFilter != null && !metadataKeyFilter.matcher(key).matches()) {
			 continue;
		 }
		 dataBuilder.setLength(0);
		 if (metadata.isMultiValued(key)) {
			 for (String val : metadata.getValues(key)) {
				 if (dataBuilder.length() > 1) {
					 dataBuilder.append("", "");
				 }
				 if (dataBuilder.length() + val.length() < maxAttribLen) {
					 dataBuilder.append(val);
				 }
				 else {
					 dataBuilder.append(""..."");
					 break;
				 }
			 }
		 }
		 else {
			 dataBuilder.append(metadata.get(key));
		 }
		 if (prefix == null) {
			 results.put(key, dataBuilder.toString().trim());
		 }
		 else {
			 results.put(prefix + key, dataBuilder.toString().trim());
		 }
		 if (maxAttribs != null && results.size() >= maxAttribs) {
			 break;
		 }
	 }
	 return results;
 }",0,0,1,0
"public boolean equals(Object o) {
	 if (!(o instanceof IncludingExcludingBounds)) return false;
	 IncludingExcludingBounds<T> rhs = (IncludingExcludingBounds<T>)o;
	 return left.equals(rhs.left) && right.equals(rhs.right);
 }",0,0,0,0
"protected JvmField createField(Field field) {
	JvmField result;
	int modifiers = field.getModifiers();
	if (!field.isEnumConstant()) {
		result = TypesFactory.eINSTANCE.createJvmField();
	}
	 elseresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();
	String fieldName = field.getName();
	result.internalSetIdentifier(field.getDeclaringClass().getName() + ""."" + fieldName);
	result.setSimpleName(fieldName);
	result.setFinal(Modifier.isFinal(modifiers));
	result.setStatic(Modifier.isStatic(modifiers));
	result.setTransient(Modifier.isTransient(modifiers));
	result.setVolatile(Modifier.isVolatile(modifiers));
	setVisibility(result, modifiers);
	Type fieldType = null;
	try {
		fieldType = field.getGenericType();
	}
	 catch (GenericSignatureFormatError error) {
		logSignatureFormatError(field.getDeclaringClass());
		fieldType = field.getType();
	}
	 catch (MalformedParameterizedTypeException error) {
		logSignatureFormatError(field.getDeclaringClass());
		fieldType = field.getType();
	}
	result.setType(createTypeReference(fieldType));
	createAnnotationValues(field, result);
	return result;
}",0,0,1,0
"private static class OnClassConditionValueExtractor extends NamedValuesExtractor {
	OnClassConditionValueExtractor() {
		super(""value"", ""name"");
	}
	public List<Object> getValues(AnnotationMirror annotation) {
		List<Object> values = super.getValues(annotation);
		values.sort(this::compare);
		return values;
	}
	private int compare(Object o1, Object o2) {
		return Comparator.comparing(this::isSpringClass).thenComparing(String.CASE_INSENSITIVE_ORDER).compare(o1.toString(), o2.toString());
	}
	private boolean isSpringClass(String type) {
		return type.startsWith(""org.springframework"");
	}
}",0,0,0,0
"private FormulaShifter(int externSheetIndex, int firstMovedIndex, int lastMovedIndex, int amountToMove);",0,0,0,1
"public class BoundCompoundPropertyModel<T> extends CompoundPropertyModel<T>{
	private class Binding implements IClusterable{
		private static final long serialVersionUID = 1L;
		private final Component component;
		private final String propertyExpression;
		private Binding(final Component component, final String propertyExpression){
			this.component = component;
			this.propertyExpression = propertyExpression;
		}
		public String toString(){
			StringBuffer sb = new StringBuffer(""Binding("");
			sb.append("":component=["").append(component).append(""]"");
			sb.append("":expression=["").append(propertyExpression).append(""]"");
			sb.append("")"");
			return sb.toString();
		}
	}
	private static final long serialVersionUID = 1L;
	private final ArrayList<Binding> bindings = new ArrayList<Binding>(1);
	public BoundCompoundPropertyModel(final Object model){
		super(model);
	}
	public Component bind(final Component component){
		if (component == null){
			throw new IllegalArgumentException(""component must be not null"");
		}
		bindings.add(new Binding(component, component.getId()));
		return component;
	}
	public Component bind(final Component component, final String propertyExpression){
		if (component == null){
			throw new IllegalArgumentException(""component must be not null"");
		}
		if (propertyExpression == null){
			throw new IllegalArgumentException(""propertyExpression must be not null"");
		}
		bindings.add(new Binding(component, propertyExpression));
		return component;
	}
	public void detach(){
		super.detach();
		bindings.trimToSize();
	}
	public String toString(){
		StringBuffer sb = new StringBuffer(super.toString());
		sb.append("":bindings=["");
		for (int i = 0, size = bindings.size();
		 i < size;
		 i++){
			if (i > 0){
				sb.append("","");
			}
			sb.append(bindings.get(i));
		}
		sb.append(""]"");
		return sb.toString();
	}
	private Binding getBinding(final Component component){
		for (int i = 0;
		 i < bindings.size();
		 i++){
			final Binding binding = bindings.get(i);
			if (component == binding.component){
				return binding;
			}
		}
		return null;
	}
	protected String propertyExpression(final Component component){
		final Binding binding = getBinding(component);
		if (binding != null){
			return binding.propertyExpression;
		}
		else if (component != null){
			return component.getId();
		}
		return null;
	}
}",0,0,0,0
"public int getId() {
	 return id;
 }",0,0,0,0
"private void printClassNotFound(PrintWriter out, String classname, boolean optional, String dirListing) {
	 out.println(""Cause: the class "" + classname + "" was not found."");
	 if (optional) {
		 out.println("" This looks like one of Ant's optional components."");
		 out.println(""Action: Check that the appropriate optional JAR exists in"");
		 out.println(dirListing);
	 }
	 else {
		 out.println(""Action: Check that the component has been correctly declared"");
		 out.println("" and that the implementing JAR is in one of:"");
		 out.println(dirListing);
	 }
 }",0,0,0,0
"public class RdfFreemarkerCli implements Callable {
	 private final static Logger LOGGER = LoggerFactory.getLogger(RdfFreemarkerCli.class);
	 private String[] args;
	 private Config typesafe;
	 public static void main(String[] args) throws Exception {
		 RdfFreemarkerCli cli = new RdfFreemarkerCli(args);
		 try {
			 cli.call();
		 }
		 catch( Exception e ) {
			 LOGGER.error(""Error"", e);
			 System.exit(1);
		 }
		 System.exit(0);
	 }
	 public RdfFreemarkerCli(String[] args) {
		 ConfigFactory.invalidateCaches();
		 this.args = args;
		 this.typesafe = ConfigFactory.load();
	 }
	 public Boolean call() throws Exception {
		 String baseDir;
		 if (typesafe.hasPath(""baseDir"")) baseDir = typesafe.getString(""baseDir"");
		 else baseDir = args[0];
		 LOGGER.info(""baseDir: "" + baseDir);
		 Path baseDirPath = Paths.get(baseDir);
		 assert( Files.exists(baseDirPath) );
		 assert( Files.isDirectory(baseDirPath) );
		 String settingsFile;
		 if (typesafe.hasPath(""settingsFile"")) settingsFile = typesafe.getString(""settingsFile"");
		 else settingsFile = args[1];
		 LOGGER.info(""settingsFile: "" + settingsFile);
		 Path settingsFilePath = Paths.get(settingsFile);
		 assert( Files.exists(settingsFilePath) );
		 assert( !Files.isDirectory(settingsFilePath) );
		 String sourceRoot;
		 if (typesafe.hasPath(""sourceRoot"")) sourceRoot = typesafe.getString(""sourceRoot"");
		 else sourceRoot = args[2];
		 LOGGER.info(""sourceRoot: "" + sourceRoot);
		 Path sourceRootPath = Paths.get(sourceRoot);
		 assert( Files.exists(sourceRootPath) );
		 assert( Files.isDirectory(sourceRootPath) );
		 String dataRoot;
		 if (typesafe.hasPath(""dataRoot"")) dataRoot = typesafe.getString(""dataRoot"");
		 else dataRoot = args[3];
		 LOGGER.info(""dataRoot: "" + dataRoot);
		 Path dataRootPath = Paths.get(dataRoot);
		 assert( Files.exists(dataRootPath) );
		 assert( Files.isDirectory(dataRootPath) );
		 String outputRoot;
		 if (typesafe.hasPath(""outputRoot"")) outputRoot = typesafe.getString(""outputRoot"");
		 else outputRoot = args[4];
		 LOGGER.info(""outputRoot: "" + outputRoot);
		 Path outputRootPath = Paths.get(outputRoot);
		 assert( Files.exists(outputRootPath) );
		 assert( Files.isDirectory(outputRootPath) );
		 String namespace;
		 if (typesafe.hasPath(""namespace"")) namespace = typesafe.getString(""namespace"");
		 else namespace = args[5];
		 String id;
		 if (typesafe.hasPath(""id"")) id = typesafe.getString(""id"");
		 else id = args[6];
		 Settings settings = new Settings(baseDirPath.toFile());
		 settings.load(settingsFilePath.toFile());
		 settings.set(NAME_DATA_ROOT, dataRoot);
		 settings.set(NAME_SOURCE_ROOT, sourceRoot);
		 settings.set(NAME_OUTPUT_ROOT, outputRoot);
		 Map<String, String> vars = new HashMap<>();
		 vars.put(""dataRoot"", dataRoot);
		 vars.put(""id"", id);
		 vars.put(""namespace"", namespace);
		 settings.set(NAME_DATA, vars);
		 ConsoleProgressListener listener = new ConsoleProgressListener();
		 settings.addProgressListener(listener);
		 try {
			 settings.execute();
		 }
		 catch( Exception ex ) {
			 LOGGER.error(""settings.execute() Exception"", ex);
			 return false;
		 }
		 LOGGER.info(""settings.execute() Success"");
		 return true;
	 }
	 public String dropExtension(String path) {
		 return path.substring(0, path.lastIndexOf('.'));
	 }
}",0,0,0,0
"public class NativeRegExp extends IdScriptableObject implements Function{
	 static final long serialVersionUID = 4965263491464903264L;
	 private static final Object REGEXP_TAG = new Object();
	 public static final int JSREG_GLOB = 0x1;
	 public static final int JSREG_FOLD = 0x2;
	 public static final int JSREG_MULTILINE = 0x4;
	 public static final int TEST = 0;
	 public static final int MATCH = 1;
	 public static final int PREFIX = 2;
	 private static final boolean debug = false;
	 private static final byte REOP_EMPTY = 0;
	 private static final byte REOP_ALT = 1;
	 private static final byte REOP_BOL = 2;
	 private static final byte REOP_EOL = 3;
	 private static final byte REOP_WBDRY = 4;
	 private static final byte REOP_WNONBDRY = 5;
	 private static final byte REOP_QUANT = 6;
	 private static final byte REOP_STAR = 7;
	 private static final byte REOP_PLUS = 8;
	 private static final byte REOP_OPT = 9;
	 private static final byte REOP_LPAREN = 10;
	 private static final byte REOP_RPAREN = 11;
	 private static final byte REOP_DOT = 12;
	 private static final byte REOP_CCLASS = 13;
	 private static final byte REOP_DIGIT = 14;
	 private static final byte REOP_NONDIGIT = 15;
	 private static final byte REOP_ALNUM = 16;
	 private static final byte REOP_NONALNUM = 17;
	 private static final byte REOP_SPACE = 18;
	 private static final byte REOP_NONSPACE = 19;
	 private static final byte REOP_BACKREF = 20;
	 private static final byte REOP_FLAT = 21;
	 private static final byte REOP_FLAT1 = 22;
	 private static final byte REOP_JUMP = 23;
	 private static final byte REOP_DOTSTAR = 24;
	 private static final byte REOP_ANCHOR = 25;
	 private static final byte REOP_EOLONLY = 26;
	 private static final byte REOP_UCFLAT = 27;
	 private static final byte REOP_UCFLAT1 = 28;
	 private static final byte REOP_UCCLASS = 29;
	 private static final byte REOP_NUCCLASS = 30;
	 private static final byte REOP_BACKREFi = 31;
	 private static final byte REOP_FLATi = 32;
	 private static final byte REOP_FLAT1i = 33;
	 private static final byte REOP_UCFLATi = 34;
	 private static final byte REOP_UCFLAT1i = 35;
	 private static final byte REOP_ANCHOR1 = 36;
	 private static final byte REOP_NCCLASS = 37;
	 private static final byte REOP_DOTSTARMIN = 38;
	 private static final byte REOP_LPARENNON = 39;
	 private static final byte REOP_RPARENNON = 40;
	 private static final byte REOP_ASSERT = 41;
	 private static final byte REOP_ASSERT_NOT = 42;
	 private static final byte REOP_ASSERTTEST = 43;
	 private static final byte REOP_ASSERTNOTTEST = 44;
	 private static final byte REOP_MINIMALSTAR = 45;
	 private static final byte REOP_MINIMALPLUS = 46;
	 private static final byte REOP_MINIMALOPT = 47;
	 private static final byte REOP_MINIMALQUANT = 48;
	 private static final byte REOP_ENDCHILD = 49;
	 private static final byte REOP_CLASS = 50;
	 private static final byte REOP_REPEAT = 51;
	 private static final byte REOP_MINIMALREPEAT = 52;
	 private static final byte REOP_END = 53;
	 public static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeRegExp proto = new NativeRegExp();
		 proto.re = (RECompiled)compileRE("""", null, false);
		 proto.activatePrototypeMap(MAX_PROTOTYPE_ID);
		 proto.setParentScope(scope);
		 proto.setPrototype(getObjectPrototype(scope));
		 NativeRegExpCtor ctor = new NativeRegExpCtor();
		 proto.put(""constructor"", proto, ctor);
		 ScriptRuntime.setFunctionProtoAndParent(ctor, scope);
		 ctor.setImmunePrototypeProperty(proto);
		 if (sealed) {
			 proto.sealObject();
			 ctor.sealObject();
		 }
		 defineProperty(scope, ""RegExp"", ctor, ScriptableObject.DONTENUM);
	 }
	 NativeRegExp(Scriptable scope, Object regexpCompiled) {
		 this.re = (RECompiled)regexpCompiled;
		 this.lastIndex = 0;
		 ScriptRuntime.setObjectProtoAndParent(this, scope);
	 }
	 public String getClassName() {
		 return ""RegExp"";
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return execSub(cx, scope, args, MATCH);
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 return (Scriptable)execSub(cx, scope, args, MATCH);
	 }
	 Scriptable compile(Context cx, Scriptable scope, Object[] args) {
		 if (args.length > 0 && args[0] instanceof NativeRegExp) {
			 if (args.length > 1 && args[1] != Undefined.instance) {
				 throw ScriptRuntime.typeError0(""msg.bad.regexp.compile"");
			 }
			 NativeRegExp thatObj = (NativeRegExp) args[0];
			 this.re = thatObj.re;
			 this.lastIndex = thatObj.lastIndex;
			 return this;
		 }
		 String s = args.length == 0 ? """" : ScriptRuntime.toString(args[0]);
		 String global = args.length > 1 && args[1] != Undefined.instance ? ScriptRuntime.toString(args[1]) : null;
		 this.re = (RECompiled)compileRE(s, global, false);
		 this.lastIndex = 0;
		 return this;
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 buf.append('/');
		 if (re.source.length != 0) {
			 buf.append(re.source);
		 }
		 else {
			 buf.append(""(?:)"");
		 }
		 buf.append('/');
		 if ((re.flags & JSREG_GLOB) != 0) buf.append('g');
		 if ((re.flags & JSREG_FOLD) != 0) buf.append('i');
		 if ((re.flags & JSREG_MULTILINE) != 0) buf.append('m');
		 return buf.toString();
	 }
	 NativeRegExp() {
	 }
	 private static RegExpImpl getImpl(Context cx) {
		 return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);
	 }
	 private Object execSub(Context cx, Scriptable scopeObj, Object[] args, int matchType) {
		 RegExpImpl reImpl = getImpl(cx);
		 String str;
		 if (args.length == 0) {
			 str = reImpl.input;
			 if (str == null) {
				 reportError(""msg.no.re.input.for"", toString());
			 }
		 }
		 else {
			 str = ScriptRuntime.toString(args[0]);
		 }
		 double d = ((re.flags & JSREG_GLOB) != 0) ? lastIndex : 0;
		 Object rval;
		 if (d < 0 || str.length() < d) {
			 lastIndex = 0;
			 rval = null;
		 }
		 else {
			 int indexp[] = {
			 (int)d }
			;
			 rval = executeRegExp(cx, scopeObj, reImpl, str, indexp, matchType);
			 if ((re.flags & JSREG_GLOB) != 0) {
				 lastIndex = (rval == null || rval == Undefined.instance) ? 0 : indexp[0];
			 }
		 }
		 return rval;
	 }
	 static Object compileRE(String str, String global, boolean flat) {
		 RECompiled regexp = new RECompiled();
		 regexp.source = str.toCharArray();
		 int length = str.length();
		 int flags = 0;
		 if (global != null) {
			 for (int i = 0;
			 i < global.length();
			 i++) {
				 char c = global.charAt(i);
				 if (c == 'g') {
					 flags |= JSREG_GLOB;
				 }
				 else if (c == 'i') {
					 flags |= JSREG_FOLD;
				 }
				 else if (c == 'm') {
					 flags |= JSREG_MULTILINE;
				 }
				 else {
					 reportError(""msg.invalid.re.flag"", String.valueOf(c));
				 }
			 }
		 }
		 regexp.flags = flags;
		 CompilerState state = new CompilerState(regexp.source, length, flags);
		 if (flat && length > 0) {
			if (debug) {
				System.out.println(""flat = \"""" + str + ""\"""");
			}
			 state.result = new RENode(REOP_FLAT);
			 state.result.chr = state.cpbegin[0];
			 state.result.length = length;
			 state.result.flatIndex = 0;
			 state.progLength += 5;
		 }
		 else if (!parseDisjunction(state)) return null;
		 regexp.program = new byte[state.progLength + 1];
		 if (state.classCount != 0) {
			 regexp.classList = new RECharSet[state.classCount];
			 regexp.classCount = state.classCount;
		 }
		 int endPC = emitREBytecode(state, regexp, 0, state.result);
		 regexp.program[endPC++] = REOP_END;
		if (debug) {
			System.out.println(""Prog. length = "" + endPC);
			for (int i = 0;
			 i < endPC;
			 i++) {
				 System.out.print(regexp.program[i]);
				 if (i < (endPC - 1)) System.out.print("", "");
			}
			System.out.println();
		}
		 regexp.parenCount = state.parenCount;
		 switch (regexp.program[0]) {
			 case REOP_UCFLAT1: case REOP_UCFLAT1i: regexp.anchorCh = (char)getIndex(regexp.program, 1);
			 break;
			 case REOP_FLAT1: case REOP_FLAT1i: regexp.anchorCh = (char)(regexp.program[1] & 0xFF);
			 break;
			 case REOP_FLAT: case REOP_FLATi: int k = getIndex(regexp.program, 1);
			 regexp.anchorCh = regexp.source[k];
			 break;
		 }
		if (debug) {
			if (regexp.anchorCh >= 0) {
				 System.out.println(""Anchor ch = '"" + (char)regexp.anchorCh + ""'"");
			}
		}
		 return regexp;
	 }
	 static boolean isDigit(char c) {
		 return '0' <= c && c <= '9';
	 }
	 private static boolean isWord(char c) {
		 return Character.isLetter(c) || isDigit(c) || c == '_';
	 }
	 private static boolean isLineTerm(char c) {
		 return ScriptRuntime.isJSLineTerminator(c);
	 }
	 private static boolean isREWhiteSpace(int c) {
		 return (c == '\u0020' || c == '\u0009' || c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029 || c == '\u000C' || c == '\u000B' || c == '\u00A0' || Character.getType((char)c) == Character.SPACE_SEPARATOR);
	 }
	 private static char upcase(char ch) {
		 if (ch < 128) {
			 if ('a' <= ch && ch <= 'z') {
				 return (char)(ch + ('A' - 'a'));
			 }
			 return ch;
		 }
		 char cu = Character.toUpperCase(ch);
		 if ((ch >= 128) && (cu < 128)) return ch;
		 return cu;
	 }
	 private static char downcase(char ch) {
		 if (ch < 128) {
			 if ('A' <= ch && ch <= 'Z') {
				 return (char)(ch + ('a' - 'A'));
			 }
			 return ch;
		 }
		 char cl = Character.toLowerCase(ch);
		 if ((ch >= 128) && (cl < 128)) return ch;
		 return cl;
	 }
	 private static int toASCIIHexDigit(int c) {
		 if (c < '0') return -1;
		 if (c <= '9') {
			 return c - '0';
		 }
		 c |= 0x20;
		 if ('a' <= c && c <= 'f') {
			 return c - 'a' + 10;
		 }
		 return -1;
	 }
	 private static boolean parseDisjunction(CompilerState state) {
		 if (!parseAlternative(state)) return false;
		 char[] source = state.cpbegin;
		 int index = state.cp;
		 if (index != source.length && source[index] == '|') {
			 RENode altResult;
			 ++state.cp;
			 altResult = new RENode(REOP_ALT);
			 altResult.kid = state.result;
			 if (!parseDisjunction(state)) return false;
			 altResult.kid2 = state.result;
			 state.result = altResult;
			 state.progLength += 9;
		 }
		 return true;
	 }
	 private static boolean parseAlternative(CompilerState state) {
		 RENode headTerm = null;
		 RENode tailTerm = null;
		 char[] source = state.cpbegin;
		 while (true) {
			 if (state.cp == state.cpend || source[state.cp] == '|' || (state.parenNesting != 0 && source[state.cp] == ')')) {
				 if (headTerm == null) {
					 state.result = new RENode(REOP_EMPTY);
				 }
				 else state.result = headTerm;
				 return true;
			 }
			 if (!parseTerm(state)) return false;
			 if (headTerm == null) headTerm = state.result;
			 else {
				 if (tailTerm == null) {
					 headTerm.next = state.result;
					 tailTerm = state.result;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
				 else {
					 tailTerm.next = state.result;
					 tailTerm = tailTerm.next;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
			 }
		 }
	 }
	 private static boolean calculateBitmapSize(CompilerState state, RENode target, char[] src, int index, int end) {
		 char rangeStart = 0;
		 char c;
		 int n;
		 int digit;
		 int nDigits;
		 int i;
		 int max = 0;
		 boolean inRange = false;
		 target.bmsize = 0;
		 if (index == end) return true;
		 if (src[index] == '^') ++index;
		 while (index != end) {
			 int localMax = 0;
			 nDigits = 2;
			 switch (src[index]) {
				 case '\\': ++index;
				 c = src[index++];
				 switch (c) {
					 case 'b': localMax = 0x8;
					 break;
					 case 'f': localMax = 0xC;
					 break;
					 case 'n': localMax = 0xA;
					 break;
					 case 'r': localMax = 0xD;
					 break;
					 case 't': localMax = 0x9;
					 break;
					 case 'v': localMax = 0xB;
					 break;
					 case 'c': if (((index + 1) < end) && Character.isLetter(src[index + 1])) localMax = (char)(src[index++] & 0x1F);
					 else localMax = '\\';
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (index < end);
					 i++) {
						 c = src[index++];
						 n = Kit.xDigitToInt(c, n);
						 if (n < 0) {
							 index -= (i + 1);
							 n = '\\';
							 break;
						 }
					 }
					 localMax = n;
					 break;
					 case 'd': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 localMax = '9';
					 break;
					 case 'D': case 's': case 'S': case 'w': case 'W': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 target.bmsize = 65535;
					 return true;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = src[index];
					 if ('0' <= c && c <= '7') {
						 index++;
						 n = 8 * n + (c - '0');
						 c = src[index];
						 if ('0' <= c && c <= '7') {
							 index++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else index--;
						 }
					 }
					 localMax = n;
					 break;
					 default: localMax = c;
					 break;
				 }
				 break;
				 default: localMax = src[index++];
				 break;
			 }
			 if (inRange) {
				 if (rangeStart > localMax) {
					 reportError(""msg.bad.range"", """");
					 return false;
				 }
				 inRange = false;
			 }
			 else {
				 if (index < (end - 1)) {
					 if (src[index] == '-') {
						 ++index;
						 inRange = true;
						 rangeStart = (char)localMax;
						 continue;
					 }
				 }
			 }
			 if ((state.flags & JSREG_FOLD) != 0){
				 char cu = upcase((char)localMax);
				 char cd = downcase((char)localMax);
				 localMax = (cu >= cd) ? cu : cd;
			 }
			 if (localMax > max) max = localMax;
		 }
		 target.bmsize = max;
		 return true;
	 }
	 private static void doFlat(CompilerState state, char c) {
		 state.result = new RENode(REOP_FLAT);
		 state.result.chr = c;
		 state.result.length = 1;
		 state.result.flatIndex = -1;
		 state.progLength += 3;
	 }
	 private static int getDecimalValue(char c, CompilerState state, int maxValue, String overflowMessageId) {
		 boolean overflow = false;
		 int start = state.cp;
		 char[] src = state.cpbegin;
		 int value = c - '0';
		 for (;
		 state.cp != state.cpend;
		 ++state.cp) {
			 c = src[state.cp];
			 if (!isDigit(c)) {
				 break;
			 }
			 if (!overflow) {
				 int digit = c - '0';
				 if (value < (maxValue - digit) / 10) {
					 value = value * 10 + digit;
				 }
				 else {
					 overflow = true;
					 value = maxValue;
				 }
			 }
		 }
		 if (overflow) {
			 reportError(overflowMessageId, String.valueOf(src, start, state.cp - start));
		 }
		 return value;
	 }
	 private static boolean parseTerm(CompilerState state) {
		 char[] src = state.cpbegin;
		 char c = src[state.cp++];
		 int nDigits = 2;
		 int parenBaseCount = state.parenCount;
		 int num, tmp;
		 RENode term;
		 int termStart;
		 int ocp = state.cp;
		 switch (c) {
			 case '^': state.result = new RENode(REOP_BOL);
			 state.progLength++;
			 return true;
			 case '$': state.result = new RENode(REOP_EOL);
			 state.progLength++;
			 return true;
			 case '\\': if (state.cp < state.cpend) {
				 c = src[state.cp++];
				 switch (c) {
					 case 'b' : state.result = new RENode(REOP_WBDRY);
					 state.progLength++;
					 return true;
					 case 'B': state.result = new RENode(REOP_WNONBDRY);
					 state.progLength++;
					 return true;
					 case '0': num = 0;
					 while (state.cp < state.cpend) {
						 c = src[state.cp];
						 if ((c >= '0') && (c <= '7')) {
							 state.cp++;
							 tmp = 8 * num + (c - '0');
							 if (tmp > 0377) break;
							 num = tmp;
						 }
						 else break;
					 }
					 c = (char)(num);
					 doFlat(state, c);
					 break;
					 case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': termStart = state.cp - 1;
					 num = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.backref"");
					 if ((num > 9) && (num > state.parenCount)) {
						 state.cp = termStart;
						 num = 0;
						 while (state.cp < state.cpend) {
							 c = src[state.cp];
							 if ((c >= '0') && (c <= '7')) {
								 state.cp++;
								 tmp = 8 * num + (c - '0');
								 if (tmp > 0377) break;
								 num = tmp;
							 }
							 else break;
						 }
						 c = (char)(num);
						 doFlat(state, c);
						 break;
					 }
					 state.result = new RENode(REOP_BACKREF);
					 state.result.parenIndex = num - 1;
					 state.progLength += 3;
					 break;
					 case 'f': c = 0xC;
					 doFlat(state, c);
					 break;
					 case 'n': c = 0xA;
					 doFlat(state, c);
					 break;
					 case 'r': c = 0xD;
					 doFlat(state, c);
					 break;
					 case 't': c = 0x9;
					 doFlat(state, c);
					 break;
					 case 'v': c = 0xB;
					 doFlat(state, c);
					 break;
					 case 'c': if (((state.cp + 1) < state.cpend) && Character.isLetter(src[state.cp + 1])) c = (char)(src[state.cp++] & 0x1F);
					 else {
						 --state.cp;
						 c = '\\';
					 }
					 doFlat(state, c);
					 break;
					 case 'u': nDigits += 2;
					 case 'x': {
						 int n = 0;
						 int i;
						 for (i = 0;
						 (i < nDigits) && (state.cp < state.cpend);
						 i++) {
							 int digit;
							 c = src[state.cp++];
							 n = Kit.xDigitToInt(c, n);
							 if (n < 0) {
								 state.cp -= (i + 2);
								 n = src[state.cp++];
								 break;
							 }
						 }
						 c = (char)(n);
					 }
					 doFlat(state, c);
					 break;
					 case 'd': state.result = new RENode(REOP_DIGIT);
					 state.progLength++;
					 break;
					 case 'D': state.result = new RENode(REOP_NONDIGIT);
					 state.progLength++;
					 break;
					 case 's': state.result = new RENode(REOP_SPACE);
					 state.progLength++;
					 break;
					 case 'S': state.result = new RENode(REOP_NONSPACE);
					 state.progLength++;
					 break;
					 case 'w': state.result = new RENode(REOP_ALNUM);
					 state.progLength++;
					 break;
					 case 'W': state.result = new RENode(REOP_NONALNUM);
					 state.progLength++;
					 break;
					 default: state.result = new RENode(REOP_FLAT);
					 state.result.chr = c;
					 state.result.length = 1;
					 state.result.flatIndex = state.cp - 1;
					 state.progLength += 3;
					 break;
				 }
				 break;
			 }
			 else {
				 reportError(""msg.trail.backslash"", """");
				 return false;
			 }
			 case '(': {
				 RENode result = null;
				 termStart = state.cp;
				 if (state.cp + 1 < state.cpend && src[state.cp] == '?' && ((c = src[state.cp + 1]) == '=' || c == '!' || c == ':')) {
					 state.cp += 2;
					 if (c == '=') {
						 result = new RENode(REOP_ASSERT);
						 state.progLength += 4;
					 }
					 else if (c == '!') {
						 result = new RENode(REOP_ASSERT_NOT);
						 state.progLength += 4;
					 }
				 }
				 else {
					 result = new RENode(REOP_LPAREN);
					 state.progLength += 6;
					 result.parenIndex = state.parenCount++;
				 }
				 ++state.parenNesting;
				 if (!parseDisjunction(state)) return false;
				 if (state.cp == state.cpend || src[state.cp] != ')') {
					 reportError(""msg.unterm.paren"", """");
					 return false;
				 }
				 ++state.cp;
				 --state.parenNesting;
				 if (result != null) {
					 result.kid = state.result;
					 state.result = result;
				 }
				 break;
			 }
			 case ')': reportError(""msg.re.unmatched.right.paren"", """");
			 return false;
			 case '[': state.result = new RENode(REOP_CLASS);
			 termStart = state.cp;
			 state.result.startIndex = termStart;
			 while (true) {
				 if (state.cp == state.cpend) {
					 reportError(""msg.unterm.class"", """");
					 return false;
				 }
				 if (src[state.cp] == '\\') state.cp++;
				 else {
					 if (src[state.cp] == ']') {
						 state.result.kidlen = state.cp - termStart;
						 break;
					 }
				 }
				 state.cp++;
			 }
			 state.result.index = state.classCount++;
			 if (!calculateBitmapSize(state, state.result, src, termStart, state.cp++)) return false;
			 state.progLength += 3;
			 break;
			 case '.': state.result = new RENode(REOP_DOT);
			 state.progLength++;
			 break;
			 case '*': case '+': case '?': reportError(""msg.bad.quant"", String.valueOf(src[state.cp - 1]));
			 return false;
			 default: state.result = new RENode(REOP_FLAT);
			 state.result.chr = c;
			 state.result.length = 1;
			 state.result.flatIndex = state.cp - 1;
			 state.progLength += 3;
			 break;
		 }
		 term = state.result;
		 if (state.cp == state.cpend) {
			 return true;
		 }
		 boolean hasQ = false;
		 switch (src[state.cp]) {
			 case '+': state.result = new RENode(REOP_QUANT);
			 state.result.min = 1;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '*': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '?': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = 1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '{
				': {
					 int min = 0;
					 int max = -1;
					 int leftCurl = state.cp;
					 c = src[++state.cp];
					 if (isDigit(c)) {
						 ++state.cp;
						 min = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.min"");
						 c = src[state.cp];
						 if (c == ',') {
							 c = src[++state.cp];
							 if (isDigit(c)) {
								 ++state.cp;
								 max = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.max"");
								 c = src[state.cp];
								 if (min > max) {
									 reportError(""msg.max.lt.min"", String.valueOf(src[state.cp]));
									 return false;
								 }
							 }
						 }
						 else {
							 max = min;
						 }
					 if (c == '}
					') {
						 state.result = new RENode(REOP_QUANT);
						 state.result.min = min;
						 state.result.max = max;
						 state.progLength += 12;
						 hasQ = true;
					 }
				 }
				 if (!hasQ) {
					 state.cp = leftCurl;
				 }
				 break;
			 }
		 }
		 if (!hasQ) return true;
		 ++state.cp;
		 state.result.kid = term;
		 state.result.parenIndex = parenBaseCount;
		 state.result.parenCount = state.parenCount - parenBaseCount;
		 if ((state.cp < state.cpend) && (src[state.cp] == '?')) {
			 ++state.cp;
			 state.result.greedy = false;
		 }
		 else state.result.greedy = true;
		 return true;
	 }
	 private static void resolveForwardJump(byte[] array, int from, int pc) {
		 if (from > pc) throw Kit.codeBug();
		 addIndex(array, from, pc - from);
	 }
	 private static int getOffset(byte[] array, int pc) {
		 return getIndex(array, pc);
	 }
	 private static int addIndex(byte[] array, int pc, int index) {
		 if (index < 0) throw Kit.codeBug();
		 if (index > 0xFFFF) throw Context.reportRuntimeError(""Too complex regexp"");
		 array[pc] = (byte)(index >> 8);
		 array[pc + 1] = (byte)(index);
		 return pc + 2;
	 }
	 private static int getIndex(byte[] array, int pc) {
		 return ((array[pc] & 0xFF) << 8) | (array[pc + 1] & 0xFF);
	 }
	 private static final int OFFSET_LEN = 2;
	 private static final int INDEX_LEN = 2;
	 private static int emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t) {
		 RENode nextAlt;
		 int nextAltFixup, nextTermFixup;
		 byte[] program = re.program;
		 while (t != null) {
			 program[pc++] = t.op;
			 switch (t.op) {
				 case REOP_EMPTY: --pc;
				 break;
				 case REOP_ALT: nextAlt = t.kid2;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_JUMP;
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextAltFixup, pc);
				 pc = emitREBytecode(state, re, pc, nextAlt);
				 program[pc++] = REOP_JUMP;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextTermFixup, pc);
				 resolveForwardJump(program, nextAltFixup, pc);
				 break;
				 case REOP_FLAT: if (t.flatIndex != -1) {
					 while ((t.next != null) && (t.next.op == REOP_FLAT) && ((t.flatIndex + t.length) == t.next.flatIndex)) {
						 t.length += t.next.length;
						 t.next = t.next.next;
					 }
				 }
				 if ((t.flatIndex != -1) && (t.length > 1)) {
					 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLATi;
					 else program[pc - 1] = REOP_FLAT;
					 pc = addIndex(program, pc, t.flatIndex);
					 pc = addIndex(program, pc, t.length);
				 }
				 else {
					 if (t.chr < 256) {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLAT1i;
						 else program[pc - 1] = REOP_FLAT1;
						 program[pc++] = (byte)(t.chr);
					 }
					 else {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_UCFLAT1i;
						 else program[pc - 1] = REOP_UCFLAT1;
						 pc = addIndex(program, pc, t.chr);
					 }
				 }
				 break;
				 case REOP_LPAREN: pc = addIndex(program, pc, t.parenIndex);
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_RPAREN;
				 pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_BACKREF: pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_ASSERT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_ASSERT_NOT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTNOTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_QUANT: if ((t.min == 0) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
				 else if ((t.min == 0) && (t.max == 1)) program[pc - 1] = (t.greedy) ? REOP_OPT : REOP_MINIMALOPT;
				 else if ((t.min == 1) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
				 else {
					 if (!t.greedy) program[pc - 1] = REOP_MINIMALQUANT;
					 pc = addIndex(program, pc, t.min);
					 pc = addIndex(program, pc, t.max + 1);
				 }
				 pc = addIndex(program, pc, t.parenCount);
				 pc = addIndex(program, pc, t.parenIndex);
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ENDCHILD;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_CLASS: pc = addIndex(program, pc, t.index);
				 re.classList[t.index] = new RECharSet(t.bmsize, t.startIndex, t.kidlen);
				 break;
				 default: break;
			 }
			 t = t.next;
		 }
		 return pc;
	 }
	 private static void pushProgState(REGlobalData gData, int min, int max, REBackTrackData backTrackLastToSave, int continuation_pc, int continuation_op) {
		 gData.stateStackTop = new REProgState(gData.stateStackTop, min, max, gData.cp, backTrackLastToSave, continuation_pc, continuation_op);
	 }
	 private static REProgState popProgState(REGlobalData gData) {
		 REProgState state = gData.stateStackTop;
		 gData.stateStackTop = state.previous;
		 return state;
	 }
	 private static void pushBackTrackState(REGlobalData gData, byte op, int target) {
		 gData.backTrackStackTop = new REBackTrackData(gData, op, target);
	 }
	 private static boolean flatNMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (gData.regexp.source[matchChars + i] != chars[gData.cp + i]) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean flatNIMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (upcase(gData.regexp.source[matchChars + i]) != upcase(chars[gData.cp + i])) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean backrefMatcher(REGlobalData gData, int parenIndex, char[] chars, int end) {
		 int len;
		 int i;
		 int parenContent = gData.parens_index(parenIndex);
		 if (parenContent == -1) return true;
		 len = gData.parens_length(parenIndex);
		 if ((gData.cp + len) > end) return false;
		 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (upcase(chars[parenContent + i]) != upcase(chars[gData.cp + i])) return false;
			 }
		 }
		 else {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (chars[parenContent + i] != chars[gData.cp + i]) return false;
			 }
		 }
		 gData.cp += len;
		 return true;
	 }
	 private static void addCharacterToCharSet(RECharSet cs, char c) {
		 int byteIndex = (int)(c / 8);
		 if (c > cs.length) throw new RuntimeException();
		 cs.bits[byteIndex] |= 1 << (c & 0x7);
	 }
	 private static void addCharacterRangeToCharSet(RECharSet cs, char c1, char c2) {
		 int i;
		 int byteIndex1 = (int)(c1 / 8);
		 int byteIndex2 = (int)(c2 / 8);
		 if ((c2 > cs.length) || (c1 > c2)) throw new RuntimeException();
		 c1 &= 0x7;
		 c2 &= 0x7;
		 if (byteIndex1 == byteIndex2) {
			 cs.bits[byteIndex1] |= ((int)(0xFF) >> (7 - (c2 - c1))) << c1;
		 }
		 else {
			 cs.bits[byteIndex1] |= 0xFF << c1;
			 for (i = byteIndex1 + 1;
			 i < byteIndex2;
			 i++) cs.bits[i] = (byte)0xFF;
			 cs.bits[byteIndex2] |= (int)(0xFF) >> (7 - c2);
		 }
	 }
	 private static void processCharSet(REGlobalData gData, RECharSet charSet) {
		 synchronized (charSet) {
			 if (!charSet.converted) {
				 processCharSetImpl(gData, charSet);
				 charSet.converted = true;
			 }
		 }
	 }
	 private static void processCharSetImpl(REGlobalData gData, RECharSet charSet) {
		 int src = charSet.startIndex;
		 int end = src + charSet.strlength;
		 char rangeStart = 0, thisCh;
		 int byteLength;
		 char c;
		 int n;
		 int nDigits;
		 int i;
		 boolean inRange = false;
		 charSet.sense = true;
		 byteLength = (charSet.length / 8) + 1;
		 charSet.bits = new byte[byteLength];
		 if (src == end) return;
		 if (gData.regexp.source[src] == '^') {
			 charSet.sense = false;
			 ++src;
		 }
		 while (src != end) {
			 nDigits = 2;
			 switch (gData.regexp.source[src]) {
				 case '\\': ++src;
				 c = gData.regexp.source[src++];
				 switch (c) {
					 case 'b': thisCh = 0x8;
					 break;
					 case 'f': thisCh = 0xC;
					 break;
					 case 'n': thisCh = 0xA;
					 break;
					 case 'r': thisCh = 0xD;
					 break;
					 case 't': thisCh = 0x9;
					 break;
					 case 'v': thisCh = 0xB;
					 break;
					 case 'c': if (((src + 1) < end) && isWord(gData.regexp.source[src + 1])) thisCh = (char)(gData.regexp.source[src++] & 0x1F);
					 else {
						 --src;
						 thisCh = '\\';
					 }
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (src < end);
					 i++) {
						 c = gData.regexp.source[src++];
						 int digit = toASCIIHexDigit(c);
						 if (digit < 0) {
							 src -= (i + 1);
							 n = '\\';
							 break;
						 }
						 n = (n << 4) | digit;
					 }
					 thisCh = (char)(n);
					 break;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = gData.regexp.source[src];
					 if ('0' <= c && c <= '7') {
						 src++;
						 n = 8 * n + (c - '0');
						 c = gData.regexp.source[src];
						 if ('0' <= c && c <= '7') {
							 src++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else src--;
						 }
					 }
					 thisCh = (char)(n);
					 break;
					 case 'd': addCharacterRangeToCharSet(charSet, '0', '9');
					 continue;
					 case 'D': addCharacterRangeToCharSet(charSet, (char)0, (char)('0' - 1));
					 addCharacterRangeToCharSet(charSet, (char)('9' + 1), (char)(charSet.length));
					 continue;
					 case 's': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'S': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (!isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'w': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'W': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (!isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 default: thisCh = c;
					 break;
				 }
				 break;
				 default: thisCh = gData.regexp.source[src++];
				 break;
			 }
			 if (inRange) {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterRangeToCharSet(charSet, upcase(rangeStart), upcase(thisCh));
					 addCharacterRangeToCharSet(charSet, downcase(rangeStart), downcase(thisCh));
				 }
				 else {
					 addCharacterRangeToCharSet(charSet, rangeStart, thisCh);
				 }
				 inRange = false;
			 }
			 else {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterToCharSet(charSet, upcase(thisCh));
					 addCharacterToCharSet(charSet, downcase(thisCh));
				 }
				 else {
					 addCharacterToCharSet(charSet, thisCh);
				 }
				 if (src < (end - 1)) {
					 if (gData.regexp.source[src] == '-') {
						 ++src;
						 inRange = true;
						 rangeStart = thisCh;
					 }
				 }
			 }
		 }
	 }
	 private static boolean classMatcher(REGlobalData gData, RECharSet charSet, char ch) {
		 if (!charSet.converted) {
			 processCharSet(gData, charSet);
		 }
		 int byteIndex = ch / 8;
		 if (charSet.sense) {
			 if ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) )) return false;
		 }
		 else {
			 if (! ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) ))) return false;
		 }
		 return true;
	 }
	 private static boolean executeREBytecode(REGlobalData gData, char[] chars, int end) {
		 int pc = 0;
		 byte program[] = gData.regexp.program;
		 int currentContinuation_op;
		 int currentContinuation_pc;
		 boolean result = false;
		 currentContinuation_pc = 0;
		 currentContinuation_op = REOP_END;
		if (debug) {
			System.out.println(""Input = \"""" + new String(chars) + ""\"", start at "" + gData.cp);
		}
		 int op = program[pc++];
		 for (;
		;
		) {
			if (debug) {
				System.out.println(""Testing at "" + gData.cp + "", op = "" + op);
			}
			 switch (op) {
				 case REOP_EMPTY: result = true;
				 break;
				 case REOP_BOL: if (gData.cp != 0) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp - 1])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_EOL: if (gData.cp != end) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_WBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ !((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_WNONBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ ((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_DOT: result = (gData.cp != end && !isLineTerm(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_DIGIT: result = (gData.cp != end && isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONDIGIT: result = (gData.cp != end && !isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_SPACE: result = (gData.cp != end && isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONSPACE: result = (gData.cp != end && !isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_ALNUM: result = (gData.cp != end && isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONALNUM: result = (gData.cp != end && !isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_FLAT: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLATi: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNIMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLAT1: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_FLAT1i: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1i: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_ALT: {
					 int nextpc;
					 byte nextop;
					 pushProgState(gData, 0, 0, null, currentContinuation_pc, currentContinuation_op);
					 nextpc = pc + getOffset(program, pc);
					 nextop = program[nextpc++];
					 pushBackTrackState(gData, nextop, nextpc);
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_JUMP: {
					 int offset;
					 REProgState state = popProgState(gData);
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 offset = getOffset(program, pc);
					 pc += offset;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_LPAREN: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 gData.set_parens(parenIndex, gData.cp, 0);
					 op = program[pc++];
				 }
				 continue;
				 case REOP_RPAREN: {
					 int cap_index;
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 cap_index = gData.parens_index(parenIndex);
					 gData.set_parens(parenIndex, cap_index, gData.cp - cap_index);
					 if (parenIndex > gData.lastParen) gData.lastParen = parenIndex;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_BACKREF: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = backrefMatcher(gData, parenIndex, chars, end);
				 }
				 break;
				 case REOP_CLASS: {
					 int index = getIndex(program, pc);
					 pc += INDEX_LEN;
					 if (gData.cp != end) {
						 if (classMatcher(gData, gData.regexp.classList[index], chars[gData.cp])) {
							 gData.cp++;
							 result = true;
							 break;
						 }
					 }
					 result = false;
				 }
				 break;
				 case REOP_ASSERT: case REOP_ASSERT_NOT: {
					 byte testOp;
					 pushProgState(gData, 0, 0, gData.backTrackStackTop, currentContinuation_pc, currentContinuation_op);
					 if (op == REOP_ASSERT) {
						 testOp = REOP_ASSERTTEST;
					 }
					 else {
						 testOp = REOP_ASSERTNOTTEST;
					 }
					 pushBackTrackState(gData, testOp, pc + getOffset(program, pc));
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_ASSERTTEST: case REOP_ASSERTNOTTEST: {
					 REProgState state = popProgState(gData);
					 gData.cp = state.index;
					 gData.backTrackStackTop = state.backTrack;
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 if (result) {
						 if (op == REOP_ASSERTTEST) {
							 result = true;
						 }
						 else {
							 result = false;
						 }
					 }
					 else {
						 if (op == REOP_ASSERTTEST) {
						 }
						 else {
							 result = true;
						 }
					 }
				 }
				 break;
				 case REOP_STAR: case REOP_PLUS: case REOP_OPT: case REOP_QUANT: case REOP_MINIMALSTAR: case REOP_MINIMALPLUS: case REOP_MINIMALOPT: case REOP_MINIMALQUANT: {
					 int min, max;
					 boolean greedy = false;
					 switch (op) {
						 case REOP_STAR: greedy = true;
						 case REOP_MINIMALSTAR: min = 0;
						 max = -1;
						 break;
						 case REOP_PLUS: greedy = true;
						 case REOP_MINIMALPLUS: min = 1;
						 max = -1;
						 break;
						 case REOP_OPT: greedy = true;
						 case REOP_MINIMALOPT: min = 0;
						 max = 1;
						 break;
						 case REOP_QUANT: greedy = true;
						 case REOP_MINIMALQUANT: min = getOffset(program, pc);
						 pc += INDEX_LEN;
						 max = getOffset(program, pc) - 1;
						 pc += INDEX_LEN;
						 break;
						 default: throw Kit.codeBug();
					 }
					 pushProgState(gData, min, max, null, currentContinuation_pc, currentContinuation_op);
					 if (greedy) {
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 pc += 3 * INDEX_LEN;
						 op = program[pc++];
					 }
					 else {
						 if (min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 pc += 3 * INDEX_LEN;
							 op = program[pc++];
						 }
						 else {
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
					 }
				 }
				 continue;
				 case REOP_ENDCHILD: pc = currentContinuation_pc;
				 op = currentContinuation_op;
				 continue;
				 case REOP_REPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.min == 0) result = true;
						 currentContinuation_pc = state.continuation_pc;
						 currentContinuation_op = state.continuation_op;
						 pc += 2 * INDEX_LEN;
						 pc = pc + getOffset(program, pc);
						 break;
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 if (new_max == 0) {
							 result = true;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 int parenCount = getIndex(program, pc);
						 pc += INDEX_LEN;
						 int parenIndex = getIndex(program, pc);
						 pc += 2 * INDEX_LEN;
						 op = program[pc++];
						 for (int k = 0;
						 k < parenCount;
						 k++) {
							 gData.set_parens(parenIndex + k, -1, 0);
						 }
					 }
				 }
				 continue;
				 case REOP_MINIMALREPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.max == -1 || state.max > 0) {
							 pushProgState(gData, state.min, state.max, null, state.continuation_pc, state.continuation_op);
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
							 continue;
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 if (new_min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
						 continue;
					 }
				 }
				 case REOP_END: return true;
				 default: throw Kit.codeBug();
			 }
			 if (!result) {
				 REBackTrackData backTrackData = gData.backTrackStackTop;
				 if (backTrackData != null) {
					 gData.backTrackStackTop = backTrackData.previous;
					 gData.lastParen = backTrackData.lastParen;
					 if (backTrackData.parens != null) {
						 gData.parens = (long[])backTrackData.parens.clone();
					 }
					 gData.cp = backTrackData.cp;
					 gData.stateStackTop = backTrackData.stateStackTop;
					 currentContinuation_op = gData.stateStackTop.continuation_op;
					 currentContinuation_pc = gData.stateStackTop.continuation_pc;
					 pc = backTrackData.continuation_pc;
					 op = backTrackData.continuation_op;
					 continue;
				 }
				 else return false;
			 }
			 op = program[pc++];
		 }
	 }
	 private static boolean matchRegExp(REGlobalData gData, RECompiled re, char[] chars, int start, int end, boolean multiline) {
		 if (re.parenCount != 0) {
			 gData.parens = new long[re.parenCount];
		 }
		 else {
			 gData.parens = null;
		 }
		 gData.backTrackStackTop = null;
		 gData.stateStackTop = null;
		 gData.multiline = multiline;
		 gData.regexp = re;
		 gData.lastParen = 0;
		 int anchorCh = gData.regexp.anchorCh;
		 for (int i = start;
		 i <= end;
		 ++i) {
			 if (anchorCh >= 0) {
				 for (;
				;
				) {
					 if (i == end) {
						 return false;
					 }
					 char matchCh = chars[i];
					 if (matchCh == anchorCh || ((gData.regexp.flags & JSREG_FOLD) != 0 && upcase(matchCh) == upcase((char)anchorCh))) {
						 break;
					 }
					 ++i;
				 }
			 }
			 gData.cp = i;
			 for (int j = 0;
			 j < re.parenCount;
			 j++) {
				 gData.set_parens(j, -1, 0);
			 }
			 boolean result = executeREBytecode(gData, chars, end);
			 gData.backTrackStackTop = null;
			 gData.stateStackTop = null;
			 if (result) {
				 gData.skipped = i - start;
				 return true;
			 }
		 }
		 return false;
	 }
	 Object executeRegExp(Context cx, Scriptable scopeObj, RegExpImpl res, String str, int indexp[], int matchType) {
		 REGlobalData gData = new REGlobalData();
		 int start = indexp[0];
		 char[] charArray = str.toCharArray();
		 int end = charArray.length;
		 if (start > end) start = end;
		 boolean matches = matchRegExp(gData, re, charArray, start, end, res.multiline);
		 if (!matches) {
			 if (matchType != PREFIX) return null;
			 return Undefined.instance;
		 }
		 int index = gData.cp;
		 int i = index;
		 indexp[0] = i;
		 int matchlen = i - (start + gData.skipped);
		 int ep = index;
		 index -= matchlen;
		 Object result;
		 Scriptable obj;
		 if (matchType == TEST) {
			 result = Boolean.TRUE;
			 obj = null;
		 }
		 else {
			 Scriptable scope = getTopLevelScope(scopeObj);
			 result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
			 obj = (Scriptable) result;
			 String matchstr = new String(charArray, index, matchlen);
			 obj.put(0, obj, matchstr);
		 }
		 if (re.parenCount == 0) {
			 res.parens = null;
			 res.lastParen = SubString.emptySubString;
		 }
		 else {
			 SubString parsub = null;
			 int num;
			 res.parens = new SubString[re.parenCount];
			 for (num = 0;
			 num < re.parenCount;
			 num++) {
				 int cap_index = gData.parens_index(num);
				 String parstr;
				 if (cap_index != -1) {
					 int cap_length = gData.parens_length(num);
					 parsub = new SubString(charArray, cap_index, cap_length);
					 res.parens[num] = parsub;
					 if (matchType == TEST) continue;
					 parstr = parsub.toString();
					 obj.put(num+1, obj, parstr);
				 }
				 else {
					 if (matchType != TEST) obj.put(num+1, obj, Undefined.instance);
				 }
			 }
			 res.lastParen = parsub;
		 }
		 if (! (matchType == TEST)) {
			 obj.put(""index"", obj, new Integer(start + gData.skipped));
			 obj.put(""input"", obj, str);
		 }
		 if (res.lastMatch == null) {
			 res.lastMatch = new SubString();
			 res.leftContext = new SubString();
			 res.rightContext = new SubString();
		 }
		 res.lastMatch.charArray = charArray;
		 res.lastMatch.index = index;
		 res.lastMatch.length = matchlen;
		 res.leftContext.charArray = charArray;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 res.leftContext.index = start;
			 res.leftContext.length = gData.skipped;
		 }
		 else {
			 res.leftContext.index = 0;
			 res.leftContext.length = start + gData.skipped;
		 }
		 res.rightContext.charArray = charArray;
		 res.rightContext.index = ep;
		 res.rightContext.length = end - ep;
		 return result;
	 }
	 int getFlags() {
		 return re.flags;
	 }
	 private static void reportError(String messageId, String arg) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg);
		 throw ScriptRuntime.constructError(""SyntaxError"", msg);
	 }
	 private static final int Id_lastIndex = 1, Id_source = 2, Id_global = 3, Id_ignoreCase = 4, Id_multiline = 5, MAX_INSTANCE_ID = 5;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==6) {
				 c=s.charAt(0);
				 if (c=='g') {
					 X=""global"";
					id=Id_global;
				 }
				 else if (c=='s') {
					 X=""source"";
					id=Id_source;
				 }
			 }
			 else if (s_length==9) {
				 c=s.charAt(0);
				 if (c=='l') {
					 X=""lastIndex"";
					id=Id_lastIndex;
				 }
				 else if (c=='m') {
					 X=""multiline"";
					id=Id_multiline;
				 }
			 }
			 else if (s_length==10) {
				 X=""ignoreCase"";
				id=Id_ignoreCase;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 if (id == 0) return super.findInstanceIdInfo(s);
		 int attr;
		 switch (id) {
			 case Id_lastIndex: attr = PERMANENT | DONTENUM;
			 break;
			 case Id_source: case Id_global: case Id_ignoreCase: case Id_multiline: attr = PERMANENT | READONLY | DONTENUM;
			 break;
			 default: throw new IllegalStateException();
		 }
		 return instanceIdInfo(attr, id);
	 }
	 protected String getInstanceIdName(int id) {
		 switch (id) {
			 case Id_lastIndex: return ""lastIndex"";
			 case Id_source: return ""source"";
			 case Id_global: return ""global"";
			 case Id_ignoreCase: return ""ignoreCase"";
			 case Id_multiline: return ""multiline"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 switch (id) {
			 case Id_lastIndex: return ScriptRuntime.wrapNumber(lastIndex);
			 case Id_source: return new String(re.source);
			 case Id_global: return ScriptRuntime.wrapBoolean((re.flags & JSREG_GLOB) != 0);
			 case Id_ignoreCase: return ScriptRuntime.wrapBoolean((re.flags & JSREG_FOLD) != 0);
			 case Id_multiline: return ScriptRuntime.wrapBoolean((re.flags & JSREG_MULTILINE) != 0);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_lastIndex) {
			 lastIndex = ScriptRuntime.toNumber(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_compile: arity=1;
			 s=""compile"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_exec: arity=1;
			 s=""exec"";
			 break;
			 case Id_test: arity=1;
			 s=""test"";
			 break;
			 case Id_prefix: arity=1;
			 s=""prefix"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(REGEXP_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(REGEXP_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_compile: return realThis(thisObj, f).compile(cx, scope, args);
			 case Id_toString: case Id_toSource: return realThis(thisObj, f).toString();
			 case Id_exec: return realThis(thisObj, f).execSub(cx, scope, args, MATCH);
			 case Id_test: {
				 Object x = realThis(thisObj, f).execSub(cx, scope, args, TEST);
				 return Boolean.TRUE.equals(x) ? Boolean.TRUE : Boolean.FALSE;
			 }
			 case Id_prefix: return realThis(thisObj, f).execSub(cx, scope, args, PREFIX);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 private static NativeRegExp realThis(Scriptable thisObj, IdFunctionObject f) {
		 if (!(thisObj instanceof NativeRegExp)) throw incompatibleCallError(f);
		 return (NativeRegExp)thisObj;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 4: c=s.charAt(0);
				 if (c=='e') {
					 X=""exec"";
					id=Id_exec;
				 }
				 else if (c=='t') {
					 X=""test"";
					id=Id_test;
				 }
				 break L;
				 case 6: X=""prefix"";
				id=Id_prefix;
				 break L;
				 case 7: X=""compile"";
				id=Id_compile;
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_compile = 1, Id_toString = 2, Id_toSource = 3, Id_exec = 4, Id_test = 5, Id_prefix = 6, MAX_PROTOTYPE_ID = 6;
	 private RECompiled re;
	 double lastIndex;
 }
;
 class RECompiled implements Serializable{
	 static final long serialVersionUID = -6144956577595844213L;
	 char []source;
	 int parenCount;
	 int flags;
	 byte[] program;
	 int classCount;
	 RECharSet[] classList;
	 int anchorCh = -1;
 }
class RENode {
	 RENode(byte op) {
		 this.op = op;
	 }
	 byte op;
	 RENode next;
	 RENode kid;
	 RENode kid2;
	 int num;
	 int parenIndex;
	 int min;
	 int max;
	 int parenCount;
	 boolean greedy;
	 int startIndex;
	 int kidlen;
	 int bmsize;
	 int index;
	 char chr;
	 int length;
	 int flatIndex;
 }
class CompilerState {
	 CompilerState(char[] source, int length, int flags) {
		 this.cpbegin = source;
		 this.cp = 0;
		 this.cpend = length;
		 this.flags = flags;
		 this.parenCount = 0;
		 this.classCount = 0;
		 this.progLength = 0;
	 }
	 Context cx;
	 char cpbegin[];
	 int cpend;
	 int cp;
	 int flags;
	 int parenCount;
	 int parenNesting;
	 int classCount;
	 int progLength;
	 RENode result;
}
class REProgState{
	 REProgState(REProgState previous, int min, int max, int index, REBackTrackData backTrack, int continuation_pc, int continuation_op) {
		 this.previous = previous;
		 this.min = min;
		 this.max = max;
		 this.index = index;
		 this.continuation_op = continuation_op;
		 this.continuation_pc = continuation_pc;
		 this.backTrack = backTrack;
	 }
	 REProgState previous;
	 int min;
	 int max;
	 int index;
	 int continuation_op;
	 int continuation_pc;
	 REBackTrackData backTrack;
 }
class REBackTrackData {
	 REBackTrackData(REGlobalData gData, int op, int pc) {
		 previous = gData.backTrackStackTop;
		 continuation_op = op;
		 continuation_pc = pc;
		 lastParen = gData.lastParen;
		 if (gData.parens != null) {
			 parens = (long[])gData.parens.clone();
		 }
		 cp = gData.cp;
		 stateStackTop = gData.stateStackTop;
	 }
	 REBackTrackData previous;
	 int continuation_op;
	 int continuation_pc;
	 int lastParen;
	 long[] parens;
	 int cp;
	 REProgState stateStackTop;
 }
class REGlobalData {
	 boolean multiline;
	 RECompiled regexp;
	 int lastParen;
	 int skipped;
	 int cp;
	 long[] parens;
	 REProgState stateStackTop;
	 REBackTrackData backTrackStackTop;
	 int parens_index(int i) {
		 return (int)(parens[i]);
	 }
	 int parens_length(int i) {
		 return (int)(parens[i] >>> 32);
	 }
	 void set_parens(int i, int index, int length) {
		 parens[i] = ((long)index & 0xffffffffL) | ((long)length << 32);
	 }
}
final class RECharSet implements Serializable{
	 static final long serialVersionUID = 7931787979395898394L;
	 RECharSet(int length, int startIndex, int strlength) {
		 this.length = length;
		 this.startIndex = startIndex;
		 this.strlength = strlength;
	 }
	 int length;
	 int startIndex;
	 int strlength;
	 volatile transient boolean converted;
	 volatile transient boolean sense;
	 volatile transient byte[] bits;
}",1,0,0,0
"public class FormatParser{
	 public static final String[][] FORMAT_SUBSTITUTIONS = {
		 {
		 ""mov,mp4,m4a,3gp,3g2,mj2"", MediaFormat.QUICKTIME }
		, {
		 ""mpeg4aac"", MediaFormat.AAC }
		, {
		 ""mp4a / 0x6134706D"", MediaFormat.AAC }
		, {
		 ""mpegts"", MediaFormat.MPEG2_TS }
		, {
		 ""mpeg2video"", MediaFormat.MPEG2_VIDEO }
		, {
		 ""mpeg1video"", MediaFormat.MPEG1_VIDEO }
		, {
		 ""mpeg4"", MediaFormat.MPEG4_VIDEO }
		, {
		 ""wmav1"", MediaFormat.WMA7 }
		, {
		 ""wmav2"", MediaFormat.WMA8 }
		, {
		 ""0x0163"", MediaFormat.WMA9LOSSLESS }
		, {
		 ""c[1][0][0] / 0x0163"", MediaFormat.WMA9LOSSLESS }
		, {
		 ""WMV3 / 0x33564D57"", MediaFormat.WMV9 }
		, {
		 ""[0][0][0][0] / 0x0000"", ""0X0000"" }
		, {
		 ""wmv3"", MediaFormat.WMV9 }
		, {
		 ""wmv2"", MediaFormat.WMV8 }
		, {
		 ""wmv1"", MediaFormat.WMV7 }
		, {
		 ""flv"", MediaFormat.FLASH_VIDEO }
		, {
		 ""h264"", MediaFormat.H264 }
		, {
		 ""ogg"", MediaFormat.OGG }
		, {
		 ""vorbis"", MediaFormat.VORBIS }
		, {
		 ""0x0162"", MediaFormat.WMA_PRO }
		, {
		 ""libfaad"", MediaFormat.AAC }
		, {
		 ""truehd"", MediaFormat.DOLBY_HD }
		, {
		 ""ac3_truehd"", MediaFormat.DOLBY_HD }
		, {
		 ""dts_hd"", MediaFormat.DTS_HD }
		, {
		 ""dts_ma"", MediaFormat.DTS_MA }
		, {
		 ""ec-3 / 0x332D6365"", MediaFormat.EAC3 }
		, {
		 ""PCM_BLURAY"", ""PCM_BD"" }
		, {
		 ""OG[0][0] / 0X674F"", MediaFormat.VORBIS }
		, {
		 ""dtsh / 0x68737464"", MediaFormat.DTS_HD }
		, {
		 ""dtsl / 0x6c737464"", MediaFormat.DTS_MA }
		, {
		 ""dtsc / 0x63737464"", MediaFormat.DTS }
		, {
		 ""mlpa / 0x61706c6d"", MediaFormat.DOLBY_HD }
		, {
		 ""AC-3 / 0X332D6361"", MediaFormat.AC3 }
	, }
	;
	 private static final long MPEG_PARSER_SEARCH_LENGTH = 30*1024*1024;
	 private static boolean DISABLE_FORMAT_DETECTION = false;
	 private static boolean MINIMIZE_EXIF_MEM_USAGE = false;
	 public static final java.io.File FORMAT_DETECT_MOUNT_DIR = new java.io.File(""/tmp/formatmount"");
	 private static String substituteName(String s) {
		 if (s == null) return null;
		 for (int i = 0;
		 i < FORMAT_SUBSTITUTIONS.length;
		 i++) if (FORMAT_SUBSTITUTIONS[i][0].equalsIgnoreCase(s)) return FORMAT_SUBSTITUTIONS[i][1];
		 return s.toUpperCase();
	 }
	 public static ContainerFormat getFileFormat(java.io.File f) {
		 if (!f.isFile()) {
			 if (f.isDirectory() && (f.getName().equalsIgnoreCase(sage.Seeker.BLURAY_VOLUME_SECRET) || (new java.io.File(f, ""index.bdmv"").isFile() && new java.io.File(f, ""MovieObject.bdmv"").isFile()))) {
				 return parseBluRayFormat(f);
			 }
			 return null;
		 }
		 if (f.length() == 0 && (!sage.MMC.getInstance().isRecording(f) || sage.MMC.getInstance().getRecordedBytes(f) == 0)) {
			 if (sage.Sage.DBG) System.out.println(""Returning null format for zero-length file"");
			 return null;
		 }
		 try {
			 ContainerFormat format = new ContainerFormat();
			 String easyFormat = null;
			 boolean foundEasy = false;
			 ContainerFormat myFormat = null;
			 if (foundEasy = setContainerTypeEasy(f, format)) {
				 easyFormat = format.getFormatName();
				 if (easyFormat != null && (MediaFormat.BMP.equals(easyFormat) || MediaFormat.GIF.equals(easyFormat) || MediaFormat.JPEG.equals(easyFormat) || MediaFormat.PNG.equals(easyFormat) || MediaFormat.TIFF.equals(easyFormat) || MediaFormat.BMP.equals(easyFormat) || MediaFormat.SMIL.equals(easyFormat) || MediaFormat.SWF.equals(easyFormat))) {
					 addAdditionalMetadata(f, format);
					 return format;
				 }
			 }
			 ContainerFormat mp3Format = MP3Parser.parseMP3File(f);
			 if (mp3Format != null) {
				 addAdditionalMetadata(f, mp3Format);
				 if (sage.Sage.DBG) System.out.println(""File Format-MP3 parsed "" + f + ""="" + mp3Format);
				 return mp3Format;
			 }
			 if (DISABLE_FORMAT_DETECTION) return foundEasy ? format : null;
			 String lcfname = f.toString().toLowerCase();
			 if (lcfname.endsWith("".iso"")) {
				 synchronized (FORMAT_DETECT_MOUNT_DIR) {
					 java.io.File mountDir = sage.FSManager.getInstance().requestISOMount(f, (java.io.File)null);
					 if (mountDir != null) {
						 java.io.File bdDir = null;
						 boolean isBluRay = (bdDir = new java.io.File(mountDir, ""BDMV"")).isDirectory() || (bdDir = new java.io.File(mountDir, ""bdmv"")).isDirectory();
						 boolean isDVD = false;
						 ContainerFormat rv = null;
						 if (!isBluRay) {
							 if (new java.io.File(mountDir, ""VIDEO_TS"").isDirectory() || new java.io.File(mountDir, ""video_ts"").isDirectory()) {
								 isDVD = true;
								 format.setFormatName(""DVD"");
								 rv = format;
							 }
						 }
						 else {
							 rv = parseBluRayFormat(bdDir);
						 }
						 sage.FSManager.getInstance().releaseISOMount(mountDir);
						 return rv;
					 }
					 return null;
				 }
			 }
			 ContainerFormat internalParsedAudioOnlyFormat = null;
			 if (!lcfname.endsWith("".evo"") && !lcfname.endsWith("".tivo"") && (!foundEasy || (MediaFormat.MPEG2_PS.equals(easyFormat) || MediaFormat.MPEG2_TS.equals(easyFormat) || MediaFormat.MPEG1.equals(easyFormat) || MediaFormat.MPEG2_PES_VIDEO.equals(easyFormat) || MediaFormat.MPEG2_PES_VIDEO.equals(easyFormat))) && !sage.Sage.getBoolean(""skip_internal_format_parser"",False)) {
				 if (sage.Sage.DBG) System.out.println(""Using internal format detector first for: "" + f);
				 if ((myFormat = extractMyFormat(f)) != null) {
					 if (myFormat.getNumberOfStreams() > 0) {
						 if (sage.Sage.DBG) System.out.println(""File Format Parsed-2a "" + f + ""="" + myFormat);
						 addAdditionalMetadata(f, myFormat);
						 if (sage.Sage.DBG) System.out.println(""File Format Parsed-2b "" + f + ""="" + myFormat);
						 if (myFormat.hasAudioOnlyStream() && sage.Sage.getBoolean(""double_check_audioonly_tv_formats"", true)) {
							 internalParsedAudioOnlyFormat = myFormat;
							 myFormat = null;
							 if (sage.Sage.DBG) System.out.println(""Using external format detector because we only detected audio on the internal format..."");
						 }
						 else {
							 return myFormat;
						 }
					 }
					 else {
						 System.out.println(""Re-detecting file format due to bad MPEG detection, file="" + f + "" formatDetected="" + myFormat);
					 }
				 }
			 }
			 if (sage.Sage.DBG) System.out.println(""Now using external format detector for: "" + f);
			 String ffmpegInfo = getFFMPEGFormatInfo(f.toString());
			 if (""TRUE"".equals(sage.Sage.get(""debug_ffmpeg_format_info"", null))) System.out.println(""File:"" + f + "" len="" + f.length() + "" FFMPEG Info:"" + ffmpegInfo);
			 String formatName = extractContainerFromFFMPEGInfo(ffmpegInfo);
			 if (formatName == null) {
				 if (myFormat != null) {
					 addAdditionalMetadata(f, myFormat);
					 if (sage.Sage.DBG) System.out.println(""File Format Parsed-1 "" + f + ""="" + myFormat);
					 return myFormat;
				 }
				 if (!foundEasy) {
					 System.out.println(""FORMATERROR UNABLE TO PARSE FILE TYPE FOR FILE-1: ""+ f);
					 if (addAdditionalMetadata(f, format)) return format;
					 else return null;
				 }
				 else addAdditionalMetadata(f, format);
			 }
			 else {
				 format.setFormatName(substituteName(formatName));
				 if (foundEasy && !""Audio"".equals(easyFormat)) format.setFormatName(easyFormat);
				 format.setDuration(extractDurationFromFFMPEGInfo(ffmpegInfo));
				 format.setBitrate(extractContainerBitrateFromFFMPEGInfo(ffmpegInfo));
				 format.setStreamFormats(extractStreamFormatsFromFFMPEGInfo(ffmpegInfo));
				 format.setDRMProtection(extractDRMFromFFMPEGInfo(ffmpegInfo));
				 java.util.regex.Matcher metaMat = ffmpegMetadataPat.matcher(ffmpegInfo);
				 while (metaMat.find()) {
					 String rawProp = metaMat.group(2);
					 String utf8Conv = rawProp;
					 try {
						 byte[] rawChars = new byte[rawProp.length()];
						 for (int i = 0;
						 i < rawChars.length;
						 i++) rawChars[i] = (byte)((rawProp.charAt(i)) & 0xFF);
						 utf8Conv = new String(rawChars, ""UTF-8"");
						 for (int i = 0;
						 i < utf8Conv.length();
						 i++) {
							 if ((utf8Conv.charAt(i) & 0xFFFF) >= 0xFFFD) {
								 utf8Conv = rawProp;
								 break;
							 }
						 }
					 }
					 catch (java.io.UnsupportedEncodingException uee){
					}
					 format.addMetadata(metaMat.group(1), utf8Conv, ""WM/TrackNumber"".equalsIgnoreCase(metaMat.group(1)));
				 }
				 addAdditionalMetadata(f, format);
				 if (MediaFormat.MPEG2_PS.equals(format.getFormatName()) || MediaFormat.MPEG2_TS.equals(format.getFormatName())) {
					 if (sage.Sage.DBG) System.out.println(""WARNING: Native format detection failed for MPEG file "" + f + "" of format"" + format);
					 if ((sage.MMC.getInstance().isRecording(f) || sage.FileDownloader.isDownloading(f)) && (internalParsedAudioOnlyFormat == null || format.getNumVideoStreams() == 0) && !sage.Sage.getBoolean(""skip_internal_format_parser"",False)) {
						 if (internalParsedAudioOnlyFormat != null) {
							 if (sage.Sage.DBG) System.out.println(""Returning internally detected audio only format because FFMPEG also did not detect a video stream"");
							 return internalParsedAudioOnlyFormat;
						 }
						 if (sage.Sage.DBG) System.out.println(""Returning NULL format due to internal detection failure since redoing it will likely fix it..."");
						 return null;
					 }
					 if (MediaFormat.MPEG2_TS.equals(format.getFormatName())) {
						 java.io.InputStream inStream = null;
						 String fstr = f.toString();
						 try {
							 inStream = new java.io.FileInputStream(fstr);
							 byte[] readBuf = new byte[390];
							 inStream.read(readBuf);
							 if (readBuf[4] == 0x47 && readBuf[196] == 0x47 && readBuf[388] == 0x47) {
								 if (sage.Sage.DBG) System.out.println(""Detected 192 byte packet size in TS file"");
								 format.setPacketSize(192);
							 }
						 }
						 catch (java.io.IOException e) {
						}
						 finally {
							 if (inStream != null) {
								 try{
									inStream.close();
								 }
								catch(Exception exc){
								}
							 }
						 }
					 }
				 }
			 }
			 if (sage.Sage.DBG) System.out.println(""File Format Parsed "" + f + ""="" + format);
			 return format;
		 }
		 catch (Throwable t) {
			 if (sage.Sage.DBG) System.out.println(""ERROR parsing media file "" + f + "" of:"" + t);
			 t.printStackTrace(System.out);
			 return null;
		 }
	 }
	 private static boolean addAdditionalMetadata(java.io.File f, ContainerFormat format) {
		 boolean rv = false;
		 if (sage.media.format.MediaFormat.JPEG.equals(format.getFormatName())) {
			 try {
				 ReadMetadata exifParser = new ReadMetadata(f);
				 if (!DISABLE_FORMAT_DETECTION && !MINIMIZE_EXIF_MEM_USAGE) format.addMetadata(sage.media.format.MediaFormat.META_DESCRIPTION, exifParser.toString());
				 format.addMetadata(sage.media.format.MediaFormat.META_TRACK, Integer.toString(exifParser.getImageOrientationAsInt()));
				 try {
					 format.addMetadata(sage.media.format.MediaFormat.META_AIRING_TIME, Long.toString(exifParser.getImageDate().getTime()));
				 }
				 catch (Exception e2){
				}
				 if (exifParser.hasJpgThumbnail()) {
					 format.addMetadata(sage.media.format.MediaFormat.META_THUMBNAIL_OFFSET, Long.toString(exifParser.getThumbnailFileOffset()));
					 format.addMetadata(sage.media.format.MediaFormat.META_THUMBNAIL_SIZE, Long.toString(exifParser.getThumbnailSize()));
				 }
			 }
			 catch (Exception e) {
			 }
		 }
		 else {
			 java.util.Map id3Map = ID3Parser.extractID3MetaData(f);
			 if (id3Map != null) {
				 format.addMetadata(id3Map);
				 if (id3Map.size() > 0) rv = true;
			 }
		 }
		 if (MediaFormat.MPEG2_PS.equals(format.getFormatName()) || MediaFormat.MPEG2_TS.equals(format.getFormatName())) {
			 java.util.Map mpegMap = MpegMetadata.getFileMetadataAsMap(f, format);
			 if (mpegMap != null && mpegMap.size() > 0) {
				 format.addMetadata(mpegMap);
				 rv = true;
			 }
		 }
		 String parsePlugins = sage.Sage.get(""mediafile_metadata_parser_plugins"", """");
		 java.util.StringTokenizer toker = new java.util.StringTokenizer(parsePlugins, "",;
		"");
		 while (toker.hasMoreTokens()) {
			 try {
				 sage.MediaFileMetadataParser parsie = (sage.MediaFileMetadataParser) Class.forName(toker.nextToken(), true, sage.Sage.extClassLoader).newInstance();
				 Object parseRes = parsie.extractMetadata(f, """");
				 if (parseRes != null && parseRes instanceof java.util.Map) {
					 format.addMetadata((java.util.Map)parseRes);
					 if (((java.util.Map)parseRes).size() > 0) rv = true;
				 }
			 }
			 catch (Throwable e1) {
				 if (sage.Sage.DBG) System.out.println(""Error instantiating metadata parser plugin of:"" + e1);
			 }
		 }
		 java.io.File propMetaFile = new java.io.File(f.toString() + "".properties"");
		 if (propMetaFile.isFile()) {
			 java.util.Map metaProps = extractMetadataProperties(f, propMetaFile, false);
			 if (metaProps != null) format.addMetadata(metaProps);
		 }
		 return rv;
	 }
	 public static java.util.Map extractMetadataProperties(java.io.File mediaPath, java.io.File propFile, boolean invokePlugins) {
		 java.util.Map metaProps = null;
		 if (invokePlugins) {
			 String parsePlugins = sage.Sage.get(""mediafile_metadata_parser_plugins"", """");
			 java.util.StringTokenizer toker = new java.util.StringTokenizer(parsePlugins, "",;
			"");
			 while (toker.hasMoreTokens()) {
				 try {
					 sage.MediaFileMetadataParser parsie = (sage.MediaFileMetadataParser) Class.forName(toker.nextToken(), true, sage.Sage.extClassLoader).newInstance();
					 Object parseRes = parsie.extractMetadata(mediaPath, """");
					 if (parseRes != null && parseRes instanceof java.util.Map) {
						 if (metaProps == null) metaProps = new java.util.HashMap();
						 metaProps.putAll((java.util.Map) parseRes);
					 }
				 }
				 catch (Exception e1) {
					 if (sage.Sage.DBG) System.out.println(""Error instantiating metadata parser plugin of:"" + e1);
				 }
			 }
		 }
		 if (propFile != null && propFile.isFile()) {
			 java.io.InputStream propStream = null;
			 try {
				 propStream = new java.io.FileInputStream(propFile);
				 java.util.Properties fileProps = new java.util.Properties();
				 fileProps.load(propStream);
				 propStream.close();
				 propStream = null;
				 if (metaProps != null) {
					 metaProps.putAll(fileProps);
					 return metaProps;
				 }
				 else return fileProps;
			 }
			catch (Exception e) {
				 if (sage.Sage.DBG) System.out.println(""ERROR parsing properties metadata of:"" + e);
			 }
			 finally {
				 if (propStream != null) {
					 try {
						 propStream.close();
					 }
					 catch (Exception e){
					}
				 }
			 }
		 }
		 return metaProps;
	 }
	 public static long getFileDuration(java.io.File f) {
		 if (!f.isFile() || f.length() == 0) return 0;
		 try {
			 String ffmpegInfo = getFFMPEGFormatInfo(f.toString());
			 long rv = extractDurationFromFFMPEGInfo(ffmpegInfo);
			 if (rv > 0) return rv;
			 String myFormatData = MPEGParser.getMediaAVInf0(f.toString(), Math.min(f.length(), MPEG_PARSER_SEARCH_LENGTH), sage.MMC.getInstance().isRecording(f) || sage.FileDownloader.isDownloading(f), -1);
			 java.util.regex.Matcher mat = myRetPat.matcher(myFormatData);
			 if (mat.find()) {
				 try {
					 if ( 0 > Integer.parseInt(mat.group(1))) return 0;
				 }
				 catch (NumberFormatException e) {
					 System.out.println(""ERROR parsing Ret value:"" + e + "" str="" + myFormatData);
					 return 0;
				 }
			 }
			 else return 0;
			 mat = myDurationPat.matcher(myFormatData);
			 if (mat.find()) {
				 try {
					 return Long.parseLong(mat.group(1), 16)/10000;
				 }
				 catch (NumberFormatException e) {
					 System.out.println(""ERROR parsing Duration value:"" + e + "" str="" + myFormatData);
				 }
			 }
		 }
		 catch (Throwable t) {
			 System.out.println(""ERROR getting file duration of:"" + t);
			 t.printStackTrace();
		 }
		 return 0;
	 }
	 public static ContainerFormat getFFMPEGFileFormat(String f) {
		 try {
			 ContainerFormat format = new ContainerFormat();
			 String ffmpegInfo = getFFMPEGFormatInfo(f);
			 String formatName = extractContainerFromFFMPEGInfo(ffmpegInfo);
			 if (formatName == null) {
				 System.out.println(""FORMATERROR UNABLE TO PARSE FILE TYPE FOR FILE: ""+ f);
				 return null;
			 }
			 else {
				 format.setFormatName(substituteName(formatName));
				 format.setDuration(extractDurationFromFFMPEGInfo(ffmpegInfo));
				 format.setBitrate(extractContainerBitrateFromFFMPEGInfo(ffmpegInfo));
				 format.setStreamFormats(extractStreamFormatsFromFFMPEGInfo(ffmpegInfo));
				 format.setDRMProtection(extractDRMFromFFMPEGInfo(ffmpegInfo));
				 java.util.regex.Matcher metaMat = ffmpegMetadataPat.matcher(ffmpegInfo);
				 while (metaMat.find()) format.addMetadata(metaMat.group(1), metaMat.group(2));
			 }
			 if (sage.Sage.DBG) System.out.println(""File Format Parsed3 "" + f + ""="" + format);
			 return format;
		 }
		 catch (Throwable t) {
			 if (sage.Sage.DBG) System.out.println(""ERROR parsing media file "" + f + "" of:"" + t);
			 t.printStackTrace(System.out);
			 return null;
		 }
	 }
	 public static ContainerFormat extractMyFormat(java.io.File f) {
		 try {
			 String myFormatData = MPEGParser.getMediaAVInf0(f.toString(), Math.min(f.length(), MPEG_PARSER_SEARCH_LENGTH), sage.MMC.getInstance().isRecording(f) || sage.FileDownloader.isDownloading(f), -1);
			 return extractFormatFromMyString(myFormatData);
		 }
		 catch (Throwable thr) {
			 System.out.println(""ERROR with file parsing:"" + thr);
			 return null;
		 }
	 }
	 public static ContainerFormat extractFormatFromMyString(String myFormatData) {
		 return extractMyFormat(myFormatData, null);
	 }
	 private static ContainerFormat extractMyFormat(String myFormatData, java.io.File f) {
		 try {
			 java.util.regex.Matcher mat = myRetPat.matcher(myFormatData);
			 int first_channel = 0;
			 if (mat.find()) {
				 try {
					 first_channel = Integer.parseInt(mat.group(1));
					 if ( 0 > first_channel ) {
						 if (sage.Sage.DBG) System.out.println(""Not find a valid channel"" + myFormatData);
						 return null;
					 }
				 }
				 catch (NumberFormatException e) {
					 System.out.println(""ERROR parsing Ret value:"" + e + "" str="" + myFormatData);
					 return null;
				 }
			 }
			 else return null;
			 int numPrograms = 0;
			 mat = myProgramPat.matcher(myFormatData);
			 if (mat.find()) {
				 try {
					 numPrograms = Integer.parseInt(mat.group(1));
				 }
				 catch (NumberFormatException e) {
					 System.out.println(""ERROR parsing Program value:"" + e + "" str="" + myFormatData);
					 return null;
				 }
			 }
			 long duration = 0;
			 mat = myDurationPat.matcher(myFormatData);
			 if (mat.find()) {
				 try {
					 duration = Long.parseLong(mat.group(1), 16)/10000;
				 }
				 catch (NumberFormatException e) {
					 System.out.println(""ERROR parsing Duration value:"" + e + "" str="" + myFormatData);
					 return null;
				 }
			 }
			 mat = myFormatPat.matcher(myFormatData);
			 boolean matchedNow = mat.find();
			 if (matchedNow) {
				 String baseFormat = mat.group(1);
				 if (baseFormat == null || baseFormat.trim().length() == 0) return null;
				 ContainerFormat rv = ContainerFormat.buildFormatFromString(baseFormat);
				 if (rv != null) {
					 rv.setDuration(duration);
					 if (numPrograms > 1 && f != null) {
						 java.util.ArrayList streamFormats = new java.util.ArrayList();
						 if (rv.getNumberOfStreams() > 0) streamFormats.addAll(java.util.Arrays.asList(rv.getStreamFormats()));
						 int currProgram = first_channel+1;
						 for ( ;
						 currProgram < numPrograms;
						 currProgram++) {
							 myFormatData = MPEGParser.getMediaAVInf0(f.toString(), Math.min(f.length(), MPEG_PARSER_SEARCH_LENGTH), sage.MMC.getInstance().isRecording(f) || sage.FileDownloader.isDownloading(f), currProgram);
							 mat = myFormatPat.matcher(myFormatData);
							 if (mat.find()) {
								 ContainerFormat newFormat = ContainerFormat.buildFormatFromString(mat.group(1));
								 if (newFormat != null && newFormat.getNumberOfStreams() > 0) {
									 streamFormats.addAll(java.util.Arrays.asList(newFormat.getStreamFormats()));
								 }
							 }
						 }
						 rv.setStreamFormats((BitstreamFormat[]) streamFormats.toArray(new BitstreamFormat[0]));
					 }
					 return rv;
				 }
			 }
			 else if (myFormatData.indexOf(""Format:SCRAMBLED"") != -1) {
				 if (sage.Sage.DBG) System.out.println(""Scrambled file format detected;
				 tag it as a TS video file with unsupported DRM. format="" + myFormatData);
				 ContainerFormat rv = new ContainerFormat();
				 rv.setFormatName(MediaFormat.MPEG2_TS);
				 rv.setDRMProtection(""UNKNOWN-DRM"");
				 VideoFormat vf = new VideoFormat();
				 vf.setFormatName(MediaFormat.MPEG2_VIDEO);
				 rv.setStreamFormats(new BitstreamFormat[] {
				 vf }
				);
				 return rv;
			 }
		 }
		 catch (Throwable thr) {
			 System.out.println(""ERROR with file parsing:"" + thr);
		 }
		 return null;
	 }
	 public static String getFFMPEGFormatInfo(String f) {
		 try {
			 if (sage.Sage.WINDOWS_OS) {
				 return sage.IOUtils.exec(new String[] {
				 sage.FFMPEGTranscoder.getTranscoderPath(), ""-priority"", ""idle"", ""-dumpmetadata"", ""-v"", ""2"", ""-i"", sage.IOUtils.getLibAVFilenameString(f) }
				, true, true, true);
			 }
			 else return sage.IOUtils.exec(new String[] {
			 ""nice"", sage.FFMPEGTranscoder.getTranscoderPath(), ""-dumpmetadata"", ""-v"", ""2"", ""-i"", sage.IOUtils.getLibAVFilenameString(f) }
			, true, true, true);
		 }
		 catch (Exception e) {
			 System.out.println(""ERROR launching transcoder of:"" + e);
			 return """";
		 }
	 }
	 private static java.util.regex.Pattern ffmpegDurationPat = java.util.regex.Pattern.compile(""Duration\\: ([0-9]*)\\:([0-9]*)\\:([0-9]*)\\.([0-9]*)"");
	 private static java.util.regex.Pattern ffmpegStartTimePat = java.util.regex.Pattern.compile(""start\\: ([0-9\\.]*)"");
	 private static java.util.regex.Pattern ffmpegContainerPat = java.util.regex.Pattern.compile(""Input \\#0\\, (.*), from"");
	 private static java.util.regex.Pattern ffmpegContainerBitratePat = java.util.regex.Pattern.compile(""Duration\\: .* bitrate\\: ([0-9]*) kb\\/s"");
	 private static java.util.regex.Pattern ffmpegStreamPat = java.util.regex.Pattern.compile(""Stream \\#0\\.(\\d*).*"");
	 private static java.util.regex.Pattern ffmpegFrameRatePat = java.util.regex.Pattern.compile(""\\, (\\d*\\.?\\d*) fps"");
	 private static java.util.regex.Pattern ffmpegFrameRatePat2 = java.util.regex.Pattern.compile(""\\, (\\d*\\.?\\d*) tbr"");
	 private static java.util.regex.Pattern ffmpegDRMPat = java.util.regex.Pattern.compile(""META\\:ENCRYPTED\\[(.*?)\\]"");
	 private static java.util.regex.Pattern ffmpegNewDRMPat = java.util.regex.Pattern.compile(""META\\:ENCRYPTION=(.*)(\\r)*\\n"");
	 private static java.util.regex.Pattern ffmpegMetadataPat = java.util.regex.Pattern.compile(""META\\:(.*?)\\=(.*)(\\r)*\\n"");
	 private static java.util.regex.Pattern myRetPat = java.util.regex.Pattern.compile(""\\ARet\\:(\\-?\\d+) "");
	 private static java.util.regex.Pattern myProgramPat = java.util.regex.Pattern.compile("" Program\\:(\\d+) "");
	 private static java.util.regex.Pattern myDurationPat = java.util.regex.Pattern.compile("" Duration\\:([a-fA-F0-9]+) "");
	 private static java.util.regex.Pattern myFormatPat = java.util.regex.Pattern.compile("" Format\\:AV\\-INF\\|(.*)"");
	 public static long extractDurationFromFFMPEGInfo(String info) {
		 java.util.regex.Matcher mat = ffmpegDurationPat.matcher(info);
		 if (mat.find()) {
			 try {
				 int hours = Integer.parseInt(mat.group(1));
				 int mins = Integer.parseInt(mat.group(2));
				 int secs = Integer.parseInt(mat.group(3));
				 int hundreths = Integer.parseInt(mat.group(4));
				 return (((hours*60 + mins)*60 + secs)*1000 + hundreths*10);
			 }
			 catch (NumberFormatException e) {
				 System.out.println(""ERROR parsing duration string:"" + e + "" str="" + info);
			 }
		 }
		 return -1;
	 }
	 public static long extractStartTimeFromFFMPEGInfo(String info) {
		 java.util.regex.Matcher mat = ffmpegStartTimePat.matcher(info);
		 if (mat.find()) {
			 try {
				 return Math.round(Float.parseFloat(mat.group(1)) * 1000);
			 }
			 catch (NumberFormatException e) {
				 System.out.println(""ERROR parsing start time string:"" + e + "" str="" + info);
			 }
		 }
		 return 0;
	 }
	 public static String extractContainerFromFFMPEGInfo(String info) {
		 java.util.regex.Matcher mat = ffmpegContainerPat.matcher(info);
		 if (mat.find()) {
			 return mat.group(1);
		 }
		 else return null;
	 }
	 public static String extractDRMFromFFMPEGInfo(String info) {
		 java.util.regex.Matcher mat = ffmpegDRMPat.matcher(info);
		 if (mat.find()) {
			 return mat.group(1);
		 }
		 mat = ffmpegNewDRMPat.matcher(info);
		 if (mat.find()) return mat.group(1);
		 return null;
	 }
	 public static int extractContainerBitrateFromFFMPEGInfo(String info) {
		 java.util.regex.Matcher mat = ffmpegContainerBitratePat.matcher(info);
		 if (mat.find()) {
			 try {
				 return Integer.parseInt(mat.group(1)) * 1000;
			 }
			 catch (NumberFormatException e) {
				 System.out.println(""ERROR parsing bitrate string:"" + e + "" str="" + info);
			 }
		 }
		 return -1;
	 }
	 public static BitstreamFormat[] extractStreamFormatsFromFFMPEGInfo(String info) {
		 java.util.regex.Matcher mat = ffmpegStreamPat.matcher(info);
		 java.util.ArrayList rv = new java.util.ArrayList();
		 while (mat.find()) {
			 String currStreamInfo = mat.group(0);
			 int currStreamNum = Integer.parseInt(mat.group(1));
			 String language = null;
			 int commaIdx = currStreamInfo.indexOf(',');
			 if (commaIdx != -1) {
				 int parenIdx = currStreamInfo.indexOf('(');
				 if (parenIdx < commaIdx && parenIdx != -1) {
					 int paren2Idx = currStreamInfo.indexOf(')', parenIdx);
					 if (paren2Idx < commaIdx && paren2Idx != -1) {
						 language = currStreamInfo.substring(parenIdx + 1, paren2Idx);
						 int bidx = language.indexOf('[');
						 if (bidx != -1) {
							 int bidx2 = language.lastIndexOf(']');
							 if (bidx2 != -1) language = language.substring(bidx + 1, bidx2);
						 }
					 }
				 }
			 }
			 if (currStreamInfo.indexOf(""Video: "") != -1) {
				 VideoFormat newFormat = new VideoFormat();
				 newFormat.setOrderIndex(currStreamNum);
				 java.util.StringTokenizer toker = new java.util.StringTokenizer( currStreamInfo.substring(currStreamInfo.indexOf(""Video: "") + ""Video: "".length()), "","");
				 newFormat.setFormatName(substituteName(toker.nextToken().trim()));
				 String nextStr = toker.nextToken();
				 int[] myDims = null;
				 boolean pastPixFmt = false;
				 boolean foundAR = false;
				 while ((nextStr.indexOf("" fps"") == -1 && nextStr.indexOf("" tbr"") == -1)) {
					 nextStr = nextStr.trim();
					 if (""interlaced"".equals(nextStr)) {
						 pastPixFmt = true;
						 newFormat.setInterlaced(true);
					 }
					 else if (""progressive"".equals(nextStr)) {
						 pastPixFmt = true;
						 newFormat.setInterlaced(false);
					 }
					 else if (nextStr.startsWith(""AR:"")) {
						 pastPixFmt = true;
						 try {
							 int arWidth = Integer.parseInt(nextStr.substring(4, nextStr.lastIndexOf(':')));
							 int arHeight = Integer.parseInt(nextStr.substring(nextStr.lastIndexOf(':') + 1));
							 newFormat.setArDen(arHeight);
							 newFormat.setArNum(arWidth);
							 newFormat.setAspectRatio(((float)arWidth)/arHeight);
							 foundAR = true;
						 }
						 catch (NumberFormatException e) {
							 System.out.println(""BAD AR Format info:"" + e + "" str="" + nextStr);
						 }
					 }
					 else if (nextStr.startsWith(""PAR"") && !foundAR) {
						 pastPixFmt = true;
						 int darIdx = nextStr.indexOf(""DAR"");
						 if (darIdx != -1) {
							 String arString = nextStr.substring(darIdx + 3).trim();
							 try {
								 int arWidth = Integer.parseInt(arString.substring(0, arString.lastIndexOf(':')));
								 int arHeight = Integer.parseInt(arString.substring(arString.lastIndexOf(':') + 1));
								 newFormat.setArDen(arHeight);
								 newFormat.setArNum(arWidth);
								 newFormat.setAspectRatio(((float)arWidth)/arHeight);
							 }
							 catch (NumberFormatException e) {
								 System.out.println(""BAD AR Format info:"" + e + "" str="" + nextStr);
							 }
						 }
					 }
					 else if (nextStr.indexOf("" kb/s"") != -1) {
						 try {
							 int newRate = Integer.parseInt(nextStr.substring(0, nextStr.indexOf("" kb/s""))) * 1000;
							 if (newRate != 104857000) newFormat.setBitrate(newRate);
						 }
						 catch (NumberFormatException e) {
							 System.out.println(""Error parsing bitrate of:"" + e + "" str="" + nextStr);
						 }
					 }
					 else if ((myDims = parseSeparatedInts(nextStr, 'x')) != null) {
						 pastPixFmt = true;
						 newFormat.setWidth(myDims[0]);
						 newFormat.setHeight(myDims[1]);
					 }
					 else if ((myDims = parseSeparatedInts(nextStr, '/')) != null) {
						 pastPixFmt = true;
						 if (((float)myDims[1]) / myDims[0] < 200) {
							 newFormat.setFpsNum(myDims[1]);
							 newFormat.setFpsDen(myDims[0]);
							 if (myDims[0] != 0) newFormat.setFps(((float) myDims[1]) / myDims[0]);
						 }
					 }
					 else if (!pastPixFmt) {
						 newFormat.setColorspace(nextStr);
					 }
					 if (toker.hasMoreTokens()) nextStr = toker.nextToken().trim();
					 else break;
				 }
				 float betterFps = extractFpsFromFFMPEGStreamInfo(currStreamInfo, MediaFormat.MPEG2_VIDEO.equals(newFormat.getFormatName()) ? 2 : 1);
				 if ((betterFps == 0 || betterFps >= 100) && !MediaFormat.MPEG2_VIDEO.equals(newFormat.getFormatName())) betterFps = extractFpsFromFFMPEGStreamInfo(currStreamInfo, 2);
				 if (betterFps != 0) {
					 newFormat.setFps(betterFps);
					 newFormat.setFpsDen(0);
					 newFormat.setFpsNum(0);
				 }
				 String streamID = extractStreamPESIDFromFFMPEGStreamInfo(currStreamInfo);
				 if (streamID != null) newFormat.setId(streamID);
				 rv.add(newFormat);
			 }
			 else if (currStreamInfo.indexOf(""Audio: "") != -1) {
				 AudioFormat newFormat = new AudioFormat();
				 newFormat.setOrderIndex(currStreamNum);
				 java.util.StringTokenizer toker = new java.util.StringTokenizer( currStreamInfo.substring(currStreamInfo.indexOf(""Audio: "") + ""Audio: "".length()), "","");
				 newFormat.setFormatName(substituteName(toker.nextToken().trim()));
				 if (""aac_latm"".equalsIgnoreCase(newFormat.getFormatName())) {
					 newFormat.setFormatName(MediaFormat.AAC);
					 newFormat.setAudioTransport(""LATM"");
				 }
				 if (toker.hasMoreTokens()) {
					 String str = toker.nextToken().trim();
					 if (str.endsWith(""Hz"")) {
						 try {
							 newFormat.setSamplingRate(Integer.parseInt(str.substring(0, str.indexOf("" Hz""))));
						 }
						 catch (NumberFormatException e) {
							 System.out.println(""Error parsing sampling rate:"" + e + "" str="" + str);
						 }
						 str = toker.nextToken().trim();
						 if (""mono"".equals(str)) newFormat.setChannels(1);
						 else if (""stereo"".equals(str)) newFormat.setChannels(2);
						 else if (""5:1"".equals(str) || ""5.1"".equals(str)) newFormat.setChannels(6);
						 else if (""7:1"".equals(str) || ""7.1"".equals(str)) newFormat.setChannels(8);
						 else if (str.endsWith("" channels"")) {
							 try {
								 newFormat.setChannels(Integer.parseInt(str.substring(0, str.indexOf(' '))));
							 }
							 catch (NumberFormatException e) {
								 System.out.println(""Error parsing number of channels:"" + e + "" str="" + str);
							 }
						 }
						 if (toker.hasMoreTokens()) str = toker.nextToken().trim();
					 }
					 if(""s8"".equals(str) || ""u8"".equals(str) || ""s16"".equals(str) || ""u16"".equals(str) || ""s24"".equals(str) || ""u24"".equals(str) || ""s32"".equals(str) || ""u32"".equals(str) || ""s64"".equals(str) || ""u64"".equals(str) || ""flt"".equals(str) || ""dbl"".equals(str) ) {
						 if(toker.hasMoreTokens()) str = toker.nextToken().trim();
					 }
					 if (str.endsWith("" kb/s"")) {
						 try {
							 newFormat.setBitrate(Integer.parseInt(str.substring(0, str.indexOf("" kb/s""))) * 1000);
						 }
						 catch (NumberFormatException e) {
							 System.out.println(""Error parsing bitrate of:"" + e + "" str="" + str);
						 }
					 }
				 }
				 newFormat.setLanguage(language);
				 String streamID = extractStreamPESIDFromFFMPEGStreamInfo(currStreamInfo);
				 if (streamID != null) newFormat.setId(streamID);
				 rv.add(newFormat);
			 }
			 else if (currStreamInfo.indexOf(""Data: "") != -1) {
			 }
			 else if (currStreamInfo.indexOf(""Subtitle: "") != -1) {
				 SubpictureFormat newFormat = new SubpictureFormat();
				 newFormat.setOrderIndex(currStreamNum);
				 String subForm = currStreamInfo.substring(currStreamInfo.indexOf(""Subtitle: "") + ""Subtitle: "".length());
				 int commaIdx2 = subForm.indexOf(',');
				 if (commaIdx2 != -1) subForm = subForm.substring(0, commaIdx2).trim();
				 if (subForm.startsWith(""["")) {
					 int slashIdx = subForm.indexOf('/');
					 if (slashIdx != -1) subForm = subForm.substring(slashIdx + 1).trim();
				 }
				 newFormat.setFormatName(substituteName(subForm));
				 newFormat.setLanguage(language);
				 String streamID = extractStreamPESIDFromFFMPEGStreamInfo(currStreamInfo);
				 if (streamID != null) newFormat.setId(streamID);
				 rv.add(newFormat);
			 }
			 else {
			 }
		 }
		 return (BitstreamFormat[]) rv.toArray(new BitstreamFormat[0]);
	 }
	 public static float extractFpsFromFFMPEGStreamInfo(String streamInfo, int mode) {
		 java.util.regex.Matcher mat = (mode == 1 ? ffmpegFrameRatePat : ffmpegFrameRatePat2).matcher(streamInfo);
		 if (mat.find()) {
			 try {
				 return Float.parseFloat(mat.group(1));
			 }
			 catch (NumberFormatException e) {
				 System.out.println(""Error parsing frame rate of:"" + e + "" str="" + streamInfo);
			 }
		 }
		 return 0;
	 }
	 public static int[] parseSeparatedInts(String s, char separator) {
		 try {
			 s = s.trim();
			 int x = s.indexOf(separator);
			 return new int[] {
			 Integer.parseInt(s.substring(0, x)), Integer.parseInt(s.substring(x + 1)) }
			;
		 }
		 catch (Exception e) {
			 return null;
		 }
	 }
	 private static boolean setContainerTypeEasy(java.io.File f, ContainerFormat cf) {
		 java.io.InputStream inStream = null;
		 String fstr = f.toString();
		 try {
			 inStream = new java.io.FileInputStream(fstr);
			 byte[] readBuf = new byte[189];
			 inStream.read(readBuf);
			 if ((readBuf[0] == 0 && readBuf[1] == 0 && readBuf[2] == 1 && ((byte)(readBuf[3] & 0xFF)) == ((byte)0xBA) && ((readBuf[4] & 0xC0) == 0x40)) ) {
				 cf.setFormatName(MediaFormat.MPEG2_PS);
				 return true;
			 }
			 else if ((readBuf[0] == 0 && readBuf[1] == 0 && readBuf[2] == 1 && (((byte)(readBuf[3] & 0xF0)) == ((byte)0xE0))) ) {
				 cf.setFormatName(MediaFormat.MPEG2_PES_VIDEO);
				 return true;
			 }
			 else if ((readBuf[0] == 0 && readBuf[1] == 0 && readBuf[2] == 1 && (((byte)(readBuf[3] & 0xE0)) == ((byte)0xC0))) ) {
				 cf.setFormatName(MediaFormat.MPEG2_PES_AUDIO);
				 return true;
			 }
			 else if ((readBuf[0] == 0 && readBuf[1] == 0 && readBuf[2] == 1 && ((byte)(readBuf[3] & 0xFF)) == ((byte)0xBA) && ((readBuf[4] & 0xF0) == 0x20))) {
				 cf.setFormatName(MediaFormat.MPEG1);
				 return true;
			 }
			 else if (readBuf[0] == 0x47 && readBuf[188] == 0x47) {
				 cf.setFormatName(MediaFormat.MPEG2_TS);
				 return true;
			 }
			 else if (((readBuf[0] & 0xFF) == 0xFF) && ((readBuf[1] & 0xFF) == 0xD8) && ((readBuf[2] & 0xFF) == 0xFF)) {
				 cf.setFormatName(MediaFormat.JPEG);
				 return true;
			 }
			 else if ((readBuf[0] == 'G') && (readBuf[1] == 'I') && (readBuf[2] == 'F') && (readBuf[3] == '8')) {
				 cf.setFormatName(MediaFormat.GIF);
				 return true;
			 }
			 else if (((readBuf[0] & 0xFF) == 0x89) && ((readBuf[1] & 0xFF) == 0x50) && ((readBuf[2] & 0xFF) == 0x4E) && ((readBuf[3] & 0xFF) == 0x47) && ((readBuf[4] & 0xFF) == 0x0D) && ((readBuf[5] & 0xFF) == 0x0A) && ((readBuf[6] & 0xFF) == 0x1A) && ((readBuf[7] & 0xFF) == 0x0A)) {
				 cf.setFormatName(MediaFormat.PNG);
				 return true;
			 }
			 else if ((readBuf[0] == 'B') && (readBuf[1] == 'M')) {
				 cf.setFormatName(MediaFormat.BMP);
				 cf.addMetadata(MediaFormat.META_WIDTH, Integer.toString(((readBuf[21] & 0xFF) << 24) | ((readBuf[20] & 0xFF) << 16) | ((readBuf[19] & 0xFF) << 8) | (readBuf[18] & 0xFF)));
				 cf.addMetadata(MediaFormat.META_HEIGHT, Integer.toString(((readBuf[25] & 0xFF) << 24) | ((readBuf[24] & 0xFF) << 16) | ((readBuf[23] & 0xFF) << 8) | (readBuf[22] & 0xFF)));
				 return true;
			 }
			 else if ((readBuf[0] == 'I' && readBuf[1] == 'I' && readBuf[2] == 42 && readBuf[3] == 0) || (readBuf[0] == 'M' && readBuf[1] == 'M' && readBuf[2] == 0 && readBuf[3] == 42)) {
				 cf.setFormatName(MediaFormat.TIFF);
				 return true;
			 }
			 else if (readBuf[0] == 'R' && readBuf[1] == 'I' && readBuf[2] == 'F' && readBuf[3] == 'F' && readBuf[8] == 'A' && readBuf[9] == 'V' && readBuf[10] == 'I' && (readBuf[11] == ' ' || readBuf[11] == 0x19)) {
				 cf.setFormatName(MediaFormat.AVI);
				 return true;
			 }
			 else if (readBuf[0] == 'R' && readBuf[1] == 'I' && readBuf[2] == 'F' && readBuf[3] == 'F' && readBuf[8] == 'W' && readBuf[9] == 'A' && readBuf[10] == 'V' && readBuf[11] == 'E') {
				 cf.setFormatName(MediaFormat.WAV);
				 return true;
			 }
			 else if ((readBuf[0] == 'f' && readBuf[1] == 'L' && readBuf[2] == 'a' && readBuf[3] == 'C') || fstr.toLowerCase().endsWith("".flac"")) {
				 cf.setFormatName(MediaFormat.FLAC);
				 return true;
			 }
			 else if (readBuf[0] == 0x30 && readBuf[1] == 0x26 && (readBuf[2]&0xFF) == 0xB2 && readBuf[3] == 0x75 && (readBuf[4]&0xFF) == 0x8E && readBuf[5] == 0x66 && (readBuf[6]&0xFF) == 0xCF && readBuf[7] == 0x11 && (readBuf[8]&0xFF) == 0xA6 && (readBuf[9]&0xFF) == 0xD9 && readBuf[10] == 0 && (readBuf[11]&0xFF) == 0xAA && readBuf[12] == 0 && readBuf[13] == 0x62 && (readBuf[14]&0xFF) == 0xCE && readBuf[15] == 0x6C) {
				 cf.setFormatName(MediaFormat.ASF);
				 return true;
			 }
			 else if (readBuf[0] == 'O' && readBuf[1] == 'g' && readBuf[2] == 'g' && readBuf[3] == 'S' && readBuf[4] == 0 && readBuf[5] <= 0x7) {
				 cf.setFormatName(MediaFormat.OGG);
				 return true;
			 }
			 else if (readBuf[0] == 'I' && readBuf[1] == 'D' && readBuf[2] == '3') {
				 cf.setFormatName(""Audio"");
				 return true;
			 }
			 else if ((readBuf[4] == 'f' && readBuf[5] == 't' && readBuf[6] == 'y' && readBuf[7] == 'p') || (readBuf[4] == 'm' && readBuf[5] == 'o' && readBuf[6] == 'o' && readBuf[7] == 'v') || (readBuf[4] == 'm' && readBuf[5] == 'd' && readBuf[6] == 'a' && readBuf[7] == 't') || (readBuf[4] == 'f' && readBuf[5] == 'r' && readBuf[6] == 'e' && readBuf[7] == 'e') || (readBuf[4] == 's' && readBuf[5] == 'k' && readBuf[6] == 'i' && readBuf[7] == 'p') || (readBuf[4] == 'w' && readBuf[5] == 'i' && readBuf[6] == 'd' && readBuf[7] == 'e') || (readBuf[4] == 'p' && readBuf[5] == 'n' && readBuf[6] == 'o' && readBuf[7] == 't')) {
				 cf.setFormatName(MediaFormat.QUICKTIME);
				 return true;
			 }
			 else if ((readBuf[0] & 0xFF) == 0x1A && (readBuf[1] & 0xFF) == 0x45 && (readBuf[2] & 0xFF) == 0xDF && (readBuf[3] & 0xFF) == 0xA3 && ((readBuf[8] == 'm' && readBuf[9] == 'a' && readBuf[10] == 't' && readBuf[11] == 'r' && readBuf[12] == 'o' && readBuf[13] == 's' && readBuf[14] == 'k' && readBuf[15] == 'a') || (readBuf[24] == 'm' && readBuf[25] == 'a' && readBuf[26] == 't' && readBuf[27] == 'r' && readBuf[28] == 'o' && readBuf[29] == 's' && readBuf[30] == 'k' && readBuf[31] == 'a'))) {
				 cf.setFormatName(MediaFormat.MATROSKA);
				 return true;
			 }
			 else if ((readBuf[0] == 'C' || readBuf[0] == 'F') && readBuf[1] == 'W' && readBuf[2] == 'S') {
				 cf.setFormatName(MediaFormat.SWF);
				 return true;
			 }
			 else if (readBuf[0] == 'F' && readBuf[1] == 'L' && readBuf[2] == 'V') {
				 cf.setFormatName(MediaFormat.FLASH_VIDEO);
				 return true;
			 }
			 else if (((readBuf[0] & 0xFF) == 0x7F && (readBuf[1] & 0xFF) == 0xFE && (readBuf[2] & 0xFF) == 0x80 && (readBuf[3] & 0xFF) == 0x01) || ((readBuf[0] & 0xFF) == 0xFE && (readBuf[1] & 0xFF) == 0x7F && (readBuf[2] & 0xFF) == 0x01 && (readBuf[3] & 0xFF) == 0x80) || ((readBuf[0] & 0xFF) == 0x1F && (readBuf[1] & 0xFF) == 0xFF && (readBuf[2] & 0xFF) == 0xE8 && (readBuf[3] & 0xFF) == 0x00) || ((readBuf[0] & 0xFF) == 0xFF && (readBuf[1] & 0xFF) == 0x1F && (readBuf[2] & 0xFF) == 0x00 && (readBuf[3] & 0xFF) == 0xE8)) {
				 cf.setFormatName(MediaFormat.DTS);
				 return true;
			 }
			 else if (readBuf[0] == '<' && readBuf[1] == 's' && readBuf[2] == 'm' && readBuf[3] == 'i' && readBuf[4] == 'l') {
				 cf.setFormatName(MediaFormat.SMIL);
				 java.io.BufferedReader buffRead = new java.io.BufferedReader(new java.io.InputStreamReader(inStream));
				 String line = buffRead.readLine();
				 while (line != null) {
					 int durIdx = line.indexOf(""dur=\"""");
					 if (durIdx != -1) {
						 int durIdx2 = line.indexOf(""ms"", durIdx);
						 if (durIdx2 != -1) {
							 try {
								 long duration = Long.parseLong(line.substring(durIdx + 5, durIdx2));
								 cf.setDuration(duration);
								 break;
							 }
							 catch (NumberFormatException nfe) {
								 if (sage.Sage.DBG) System.out.println(""Error parsing SMIL duration of:"" + nfe);
							 }
						 }
					 }
					 line = buffRead.readLine();
				 }
				 return true;
			 }
			 if ((readBuf[0] & 0xFF) == 0x1A && (readBuf[1] & 0xFF) == 0x45 && (readBuf[2] & 0xFF) == 0xDF && (readBuf[3] & 0xFF) == 0xA3) {
				 for (int i = 4;
				 i < readBuf.length - 10;
				 i++) {
					 if ((readBuf[i] & 0xFF) == 0x42 && (readBuf[i + 1] & 0xFF) == 0x82) {
						 for (int j = i + 2;
						 j < i + 10 && j < readBuf.length - 7;
						 j++) {
							 if (readBuf[j] == 'm' && readBuf[j + 1] == 'a' && readBuf[j + 2] == 't' && readBuf[j + 3] == 'r' && readBuf[j + 4] == 'o' && readBuf[j + 5] == 's' && readBuf[j + 6] == 'k' && readBuf[j + 7] == 'a') {
								 cf.setFormatName(MediaFormat.MATROSKA);
								 return true;
							 }
						 }
					 }
				 }
			 }
		 }
		 catch (java.io.IOException e) {
		}
		 finally {
			 if (inStream != null) {
				 try{
					inStream.close();
				 }
				catch(Exception exc){
				}
			 }
		 }
		 String lcname = fstr.toLowerCase();
		 if (lcname.endsWith("".gif"")) {
			 cf.setFormatName(MediaFormat.GIF);
			 return true;
		 }
		 else if (lcname.endsWith("".bmp"")) {
			 cf.setFormatName(MediaFormat.BMP);
			 return true;
		 }
		 else if (lcname.endsWith("".jpg"") || lcname.endsWith("".jpeg"")) {
			 cf.setFormatName(MediaFormat.JPEG);
			 return true;
		 }
		 else if (lcname.endsWith("".png"")) {
			 cf.setFormatName(MediaFormat.PNG);
			 return true;
		 }
		 return false;
	 }
	 private static String extractStreamPESIDFromFFMPEGStreamInfo(String currStreamInfo) {
		 int commaIdx = currStreamInfo.indexOf(',');
		 if (commaIdx == -1) return null;
		 int brack1 = currStreamInfo.indexOf('[');
		 if (brack1 > commaIdx || brack1 == -1) return null;
		 int brack2 = currStreamInfo.indexOf(']');
		 if (brack2 > commaIdx || brack2 == -1 || brack2 < brack1) return null;
		 if (brack2 - brack1 == 5) return currStreamInfo.substring(brack2 - 2, brack2);
		 if (brack2 - brack1 == 6) return currStreamInfo.substring(brack2 - 3, brack2);
		 if (brack2 - brack1 == 7) return currStreamInfo.substring(brack2 - 4, brack2);
		 return null;
	 }
	 public static ContainerFormat parseBluRayFormat(java.io.File bdmvDir) {
		 try {
			 sage.media.bluray.BluRayParser bdp = new sage.media.bluray.BluRayParser(bdmvDir);
			 bdp.fullyAnalyze();
			 if (sage.Sage.DBG && sage.Sage.getBoolean(""dump_bluray_info"", false)) bdp.dumpInfo();
			 return bdp.getFileFormat();
		 }
		 catch (Exception e) {
			 System.out.println(""ERROR parsing BluRay structure of:"" + e);
			 e.printStackTrace();
		 }
		 return null;
	 }
	 public static boolean updateExternalSubs(java.io.File theFile, ContainerFormat cf) {
		 boolean rv = false;
		 if (cf == null || cf.getNumVideoStreams() == 0 || theFile == null) return rv;
		 rv |= cf.validateExternalSubtitles();
		 String fileprefix = theFile.getAbsolutePath();
		 int idx = fileprefix.lastIndexOf('.');
		 if (idx != -1) fileprefix = fileprefix.substring(0, idx + 1);
		 java.io.File testFile = new java.io.File(fileprefix + ""srt"");
		 if (testFile.isFile()) {
			 if (cf.formatHasSubtitlePath(testFile.toString())) return rv;
			 SubpictureFormat subpic = new SubpictureFormat();
			 subpic.setFormatName(MediaFormat.SRT);
			 subpic.setPath(testFile.toString());
			 cf.addStream(subpic);
			 return true;
		 }
		 testFile = new java.io.File(fileprefix + ""idx"");
		 if (testFile.isFile() && new java.io.File(fileprefix + ""sub"").isFile()) {
			 if (cf.formatHasSubtitlePath(testFile.toString())) return rv;
			 boolean invalidFile = false;
			 java.io.BufferedReader buffRead = null;
			 int defaultLang = -1;
			 try {
				 buffRead = sage.IOUtils.openReaderDetectCharset(testFile, sage.Sage.BYTE_CHARSET);
				 String line = buffRead.readLine();
				 if (line != null && line.indexOf(""VobSub index file"") == -1) invalidFile = true;
				 while (!invalidFile && line != null) {
					 if (line.startsWith(""langidx:"")) defaultLang = Integer.parseInt(line.substring(8).trim());
					 else if (line.startsWith(""id:"")) {
						 idx = line.indexOf(',');
						 if (idx != -1) {
							 String currLang = line.substring(3, idx).trim();
							 SubpictureFormat subpic = new SubpictureFormat();
							 subpic.setFormatName(MediaFormat.VOBSUB);
							 subpic.setLanguage(currLang);
							 subpic.setPath(testFile.toString());
							 cf.addStream(subpic);
							 idx = line.indexOf(""index:"");
							 if (idx != -1) {
								 try {
									 int currIndex = Integer.parseInt(line.substring(idx + 6).trim());
									 subpic.setOrderIndex(currIndex);
									 if (currIndex == defaultLang) subpic.setPrimary(true);
								 }
								 catch (NumberFormatException fe) {
									 System.out.println(""ERROR parsing subtitle index in "" + testFile + "" of "" + fe);
								 }
							 }
						 }
					 }
					 line = buffRead.readLine();
				 }
			 }
			 catch (Exception nfe) {
				 System.out.println(""ERROR parsing IDX subtitle file: "" + testFile + "" of :"" + nfe);
			 }
			 finally {
				 if (buffRead != null) {
					 try {
						 buffRead.close();
					 }
					 catch (Exception e){
					}
				 }
			 }
			 if (!invalidFile) return true;
		 }
		 testFile = new java.io.File(fileprefix + ""sub"");
		 if (testFile.isFile()) {
			 if (cf.formatHasSubtitlePath(testFile.toString())) return rv;
			 SubpictureFormat subpic = new SubpictureFormat();
			 subpic.setFormatName(MediaFormat.SUB);
			 subpic.setPath(testFile.toString());
			 cf.addStream(subpic);
			 return true;
		 }
		 testFile = new java.io.File(fileprefix + ""ssa"");
		 if (testFile.isFile() || (testFile = new java.io.File(fileprefix + ""ass"")).isFile()) {
			 if (cf.formatHasSubtitlePath(testFile.toString())) return rv;
			 SubpictureFormat subpic = new SubpictureFormat();
			 subpic.setFormatName(MediaFormat.SSA);
			 subpic.setPath(testFile.toString());
			 cf.addStream(subpic);
			 return true;
		 }
		 testFile = new java.io.File(fileprefix + ""smi"");
		 if (testFile.isFile() || (testFile = new java.io.File(fileprefix + ""sami"")).isFile()) {
			 if (cf.formatHasSubtitlePath(testFile.toString())) return rv;
			 java.io.BufferedReader buffRead = null;
			 StringBuffer styleText = new StringBuffer();
			 try {
				 buffRead = sage.IOUtils.openReaderDetectCharset(testFile, sage.Sage.BYTE_CHARSET);
				 String line = buffRead.readLine();
				 boolean inStyle = false;
				 while (line != null) {
					 if (!inStyle) {
						 idx = line.toLowerCase().indexOf(""<style "");
						 if (idx != -1) {
							 inStyle = true;
							 styleText.append(line.substring(idx));
							 styleText.append('\n');
						 }
					 }
					 else if (inStyle) {
						 idx = line.toLowerCase().indexOf(""</style>"");
						 if (idx != -1) {
							 styleText.append(line.substring(0, idx));
							 break;
						 }
						 styleText.append(line);
						 styleText.append('\n');
					 }
					 line = buffRead.readLine();
				 }
			 }
			 catch (Exception nfe) {
				 System.out.println(""ERROR parsing SAMI subtitle file: "" + testFile + "" of :"" + nfe);
			 }
			 finally {
				 if (buffRead != null) {
					 try {
						 buffRead.close();
					 }
					 catch (Exception e){
					}
				 }
			 }
			 String style = styleText.toString();
			 if (style.length() > 0) {
				 String[] langs = sage.media.sub.SAMISubtitleHandler.extractLanguagesFromStyleSection(style);
				 for (int m = 0;
				 m < langs.length;
				 m++) {
					 SubpictureFormat subpic = new SubpictureFormat();
					 subpic.setFormatName(MediaFormat.SAMI);
					 subpic.setLanguage(langs[m]);
					 subpic.setPath(testFile.toString());
					 cf.addStream(subpic);
				 }
				 return langs.length > 0 || rv;
			 }
			 return rv;
		 }
		 java.io.File parent = theFile.getParentFile();
		 if (parent != null && parent.isDirectory()) {
			 String name = theFile.getName();
			 int dotIdx = name.lastIndexOf('.');
			 name = name.substring(0, dotIdx + 1);
			 String[] fileList = parent.list();
			 for (int i = 0;
			 fileList != null && i < fileList.length;
			 i++) {
				 if (fileList[i].startsWith(name)) {
					 dotIdx = fileList[i].lastIndexOf('.');
					 String ext = fileList[i].substring(dotIdx + 1);
					 String subFormat = null;
					 if (""srt"".equalsIgnoreCase(ext)) subFormat = sage.media.format.MediaFormat.SRT;
					 else if (""sub"".equalsIgnoreCase(ext)) subFormat = sage.media.format.MediaFormat.SUB;
					 else if (""ssa"".equalsIgnoreCase(ext) || ""ass"".equalsIgnoreCase(ext)) subFormat = sage.media.format.MediaFormat.SSA;
					 if (subFormat != null && !cf.formatHasSubtitlePath((testFile = new java.io.File(parent, fileList[i])).toString())) {
						 String currLang = fileList[i].substring(name.length(), fileList[i].length() - 4);
						 SubpictureFormat subpic = new SubpictureFormat();
						 subpic.setFormatName(subFormat);
						 subpic.setLanguage(currLang);
						 subpic.setPath(testFile.toString());
						 cf.addStream(subpic);
						 rv = true;
					 }
				 }
			 }
		 }
		 return rv;
	 }
}",1,0,0,0
"public class CrunchMapper extends Mapper<Object, Object, Object, Object> {
	 private static final Logger LOG = LoggerFactory.getLogger(CrunchMapper.class);
	 private RTNode node;
	 private CrunchTaskContext ctxt;
	 private boolean debug;
	 protected void setup(Mapper<Object, Object, Object, Object>.Context context) {
		 if (ctxt == null) {
			 ctxt = new CrunchTaskContext(context, NodeContext.MAP);
			 this.debug = ctxt.isDebugRun();
		 }
		 List<RTNode> nodes = ctxt.getNodes();
		 if (nodes.size() == 1) {
			 this.node = nodes.get(0);
		 }
		 else {
			 CrunchInputSplit split = (CrunchInputSplit) context.getInputSplit();
			 this.node = nodes.get(split.getNodeIndex());
		 }
		 this.node.initialize(ctxt);
	 }
	 protected void map(Object k, Object v, Mapper<Object, Object, Object, Object>.Context context) {
		 if (debug) {
			 try {
				 node.process(k, v);
			 }
			 catch (Exception e) {
				 LOG.error(""Mapper exception"", e);
			 }
		 }
		 else {
			 node.process(k, v);
		 }
	 }
	 protected void cleanup(Mapper<Object, Object, Object, Object>.Context context) {
		 node.cleanup();
		 ctxt.cleanup();
	 }
}",0,0,0,0
"final public class ZStream{
	 static final private int MAX_WBITS=15;
	 static final private int DEF_WBITS=MAX_WBITS;
	 static final private int Z_NO_FLUSH=0;
	 static final private int Z_PARTIAL_FLUSH=1;
	 static final private int Z_SYNC_FLUSH=2;
	 static final private int Z_FULL_FLUSH=3;
	 static final private int Z_FINISH=4;
	 static final private int MAX_MEM_LEVEL=9;
	 static final private int Z_OK=0;
	 static final private int Z_STREAM_END=1;
	 static final private int Z_NEED_DICT=2;
	 static final private int Z_ERRNO=-1;
	 static final private int Z_STREAM_ERROR=-2;
	 static final private int Z_DATA_ERROR=-3;
	 static final private int Z_MEM_ERROR=-4;
	 static final private int Z_BUF_ERROR=-5;
	 static final private int Z_VERSION_ERROR=-6;
	 public byte[] next_in;
	 public int next_in_index;
	 public int avail_in;
	 public long total_in;
	 public byte[] next_out;
	 public int next_out_index;
	 public int avail_out;
	 public long total_out;
	 public String msg;
	 Deflate dstate;
	 Inflate istate;
	 int data_type;
	 public long adler;
	 Adler32 _adler=new Adler32();
	 public int inflateInit(){
		 return inflateInit(DEF_WBITS);
	 }
	 public int inflateInit(boolean nowrap){
		 return inflateInit(DEF_WBITS, nowrap);
	 }
	 public int inflateInit(int w){
		 return inflateInit(w, false);
	 }
	 public int inflateInit(int w, boolean nowrap){
		 istate=new Inflate();
		 return istate.inflateInit(this, nowrap?-w:w);
	 }
	 public int inflate(int f){
		 if(istate==null) return Z_STREAM_ERROR;
		 return istate.inflate(this, f);
	 }
	 public int inflateEnd(){
		 if(istate==null) return Z_STREAM_ERROR;
		 int ret=istate.inflateEnd(this);
		 istate = null;
		 return ret;
	 }
	 public int inflateSync(){
		 if(istate == null) return Z_STREAM_ERROR;
		 return istate.inflateSync(this);
	 }
	 public int inflateSetDictionary(byte[] dictionary, int dictLength){
		 if(istate == null) return Z_STREAM_ERROR;
		 return istate.inflateSetDictionary(this, dictionary, dictLength);
	 }
	 public int deflateInit(int level){
		 return deflateInit(level, MAX_WBITS);
	 }
	 public int deflateInit(int level, boolean nowrap){
		 return deflateInit(level, MAX_WBITS, nowrap);
	 }
	 public int deflateInit(int level, int bits){
		 return deflateInit(level, bits, false);
	 }
	 public int deflateInit(int level, int bits, boolean nowrap){
		 dstate=new Deflate();
		 return dstate.deflateInit(this, level, nowrap?-bits:bits);
	 }
	 public int deflate(int flush){
		 if(dstate==null){
			 return Z_STREAM_ERROR;
		 }
		 return dstate.deflate(this, flush);
	 }
	 public int deflateEnd(){
		 if(dstate==null) return Z_STREAM_ERROR;
		 int ret=dstate.deflateEnd();
		 dstate=null;
		 return ret;
	 }
	 public int deflateParams(int level, int strategy){
		 if(dstate==null) return Z_STREAM_ERROR;
		 return dstate.deflateParams(this, level, strategy);
	 }
	 public int deflateSetDictionary (byte[] dictionary, int dictLength){
		 if(dstate == null) return Z_STREAM_ERROR;
		 return dstate.deflateSetDictionary(this, dictionary, dictLength);
	 }
	 void flush_pending(){
		 int len=dstate.pending;
		 if(len>avail_out) len=avail_out;
		 if(len==0) return;
		 if(dstate.pending_buf.length<=dstate.pending_out || next_out.length<=next_out_index || dstate.pending_buf.length<(dstate.pending_out+len) || next_out.length<(next_out_index+len)){
			 System.out.println(dstate.pending_buf.length+"", ""+dstate.pending_out+ "", ""+next_out.length+"", ""+next_out_index+"", ""+len);
			 System.out.println(""avail_out=""+avail_out);
		 }
		 System.arraycopy(dstate.pending_buf, dstate.pending_out, next_out, next_out_index, len);
		 next_out_index+=len;
		 dstate.pending_out+=len;
		 total_out+=len;
		 avail_out-=len;
		 dstate.pending-=len;
		 if(dstate.pending==0){
			 dstate.pending_out=0;
		 }
	 }
	 int read_buf(byte[] buf, int start, int size) {
		 int len=avail_in;
		 if(len>size) len=size;
		 if(len==0) return 0;
		 avail_in-=len;
		 if(dstate.noheader==0) {
			 adler=_adler.adler32(adler, next_in, next_in_index, len);
		 }
		 System.arraycopy(next_in, next_in_index, buf, start, len);
		 next_in_index += len;
		 total_in += len;
		 return len;
	 }
	 public void free(){
		 next_in=null;
		 next_out=null;
		 msg=null;
		 _adler=null;
	 }
}",0,0,0,0
"public class DOMElementWriter {
	 private static final int HEX = 16;
	 private static final String NS = ""ns"";
	 private boolean xmlDeclaration = true;
	 private XmlNamespacePolicy namespacePolicy = XmlNamespacePolicy.IGNORE;
	 private HashMap nsPrefixMap = new HashMap();
	 private int nextPrefix = 0;
	 private HashMap nsURIByElement = new HashMap();
	 public static class XmlNamespacePolicy {
		 private boolean qualifyElements;
		 private boolean qualifyAttributes;
		 public static final XmlNamespacePolicy IGNORE = new XmlNamespacePolicy(false, false);
		 public static final XmlNamespacePolicy ONLY_QUALIFY_ELEMENTS = new XmlNamespacePolicy(true, false);
		 public static final XmlNamespacePolicy QUALIFY_ALL = new XmlNamespacePolicy(true, true);
		 public XmlNamespacePolicy(boolean qualifyElements, boolean qualifyAttributes) {
			 this.qualifyElements = qualifyElements;
			 this.qualifyAttributes = qualifyAttributes;
		 }
	 }
	 public DOMElementWriter() {
	 }
	 public DOMElementWriter(boolean xmlDeclaration) {
		 this(xmlDeclaration, XmlNamespacePolicy.IGNORE);
	 }
	 public DOMElementWriter(boolean xmlDeclaration, XmlNamespacePolicy namespacePolicy) {
		 this.xmlDeclaration = xmlDeclaration;
		 this.namespacePolicy = namespacePolicy;
	 }
	 private static String lSep = System.getProperty(""line.separator"");
	 protected String[] knownEntities = {
	""gt"", ""amp"", ""lt"", ""apos"", ""quot""}
	;
	 public void write(Element root, OutputStream out) throws IOException {
		 Writer wri = new OutputStreamWriter(out, ""UTF8"");
		 writeXMLDeclaration(wri);
		 write(root, wri, 0, "" "");
		 wri.flush();
	 }
	 public void writeXMLDeclaration(Writer wri) throws IOException {
		 if (xmlDeclaration) {
			 wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
		 }
	 }
	 public void write(Element element, Writer out, int indent, String indentWith) throws IOException {
		 NodeList children = element.getChildNodes();
		 boolean hasChildren = (children.getLength() > 0);
		 boolean hasChildElements = false;
		 openElement(element, out, indent, indentWith, hasChildren);
		 if (hasChildren) {
			 for (int i = 0;
			 i < children.getLength();
			 i++) {
				 Node child = children.item(i);
				 switch (child.getNodeType()) {
					 case Node.ELEMENT_NODE: hasChildElements = true;
					 if (i == 0) {
						 out.write(lSep);
					 }
					 write((Element) child, out, indent + 1, indentWith);
					 break;
					 case Node.TEXT_NODE: out.write(encode(child.getNodeValue()));
					 break;
					 case Node.COMMENT_NODE: out.write(""<!--"");
					 out.write(encode(child.getNodeValue()));
					 out.write(""-->"");
					 break;
					 case Node.CDATA_SECTION_NODE: out.write(""<![CDATA["");
					 out.write(encodedata(((Text) child).getData()));
					 out.write(""]]>"");
					 break;
					 case Node.ENTITY_REFERENCE_NODE: out.write('&');
					 out.write(child.getNodeName());
					 out.write(';
					');
					 break;
					 case Node.PROCESSING_INSTRUCTION_NODE: out.write(""<?"");
					 out.write(child.getNodeName());
					 String data = child.getNodeValue();
					 if (data != null && data.length() > 0) {
						 out.write(' ');
						 out.write(data);
					 }
					 out.write(""?>"");
					 break;
				 default: }
			 }
			 closeElement(element, out, indent, indentWith, hasChildElements);
		 }
	 }
	 public void openElement(Element element, Writer out, int indent, String indentWith) throws IOException {
		 openElement(element, out, indent, indentWith, true);
	 }
	 public void openElement(Element element, Writer out, int indent, String indentWith, boolean hasChildren) throws IOException {
		 for (int i = 0;
		 i < indent;
		 i++) {
			 out.write(indentWith);
		 }
		 out.write(""<"");
		 if (namespacePolicy.qualifyElements) {
			 String uri = getNamespaceURI(element);
			 String prefix = (String) nsPrefixMap.get(uri);
			 if (prefix == null) {
				 if (nsPrefixMap.isEmpty()) {
					 prefix = """";
				 }
				 else {
					 prefix = NS + (nextPrefix++);
				 }
				 nsPrefixMap.put(uri, prefix);
				 addNSDefinition(element, uri);
			 }
			 if (!"""".equals(prefix)) {
				 out.write(prefix);
				 out.write("":"");
			 }
		 }
		 out.write(element.getTagName());
		 NamedNodeMap attrs = element.getAttributes();
		 for (int i = 0;
		 i < attrs.getLength();
		 i++) {
			 Attr attr = (Attr) attrs.item(i);
			 out.write("" "");
			 if (namespacePolicy.qualifyAttributes) {
				 String uri = getNamespaceURI(attr);
				 String prefix = (String) nsPrefixMap.get(uri);
				 if (prefix == null) {
					 prefix = NS + (nextPrefix++);
					 nsPrefixMap.put(uri, prefix);
					 addNSDefinition(element, uri);
				 }
				 out.write(prefix);
				 out.write("":"");
			 }
			 out.write(attr.getName());
			 out.write(""=\"""");
			 out.write(encode(attr.getValue()));
			 out.write(""\"""");
		 }
		 ArrayList al = (ArrayList) nsURIByElement.get(element);
		 if (al != null) {
			 Iterator iter = al.iterator();
			 while (iter.hasNext()) {
				 String uri = (String) iter.next();
				 String prefix = (String) nsPrefixMap.get(uri);
				 out.write("" xmlns"");
				 if (!"""".equals(prefix)) {
					 out.write("":"");
					 out.write(prefix);
				 }
				 out.write(""=\"""");
				 out.write(uri);
				 out.write(""\"""");
			 }
		 }
		 if (hasChildren) {
			 out.write("">"");
		 }
		 else {
			 removeNSDefinitions(element);
			 out.write("" />"");
			 out.write(lSep);
			 out.flush();
		 }
	 }
	 public void closeElement(Element element, Writer out, int indent, String indentWith, boolean hasChildren) throws IOException {
		 if (hasChildren) {
			 for (int i = 0;
			 i < indent;
			 i++) {
				 out.write(indentWith);
			 }
		 }
		 out.write(""</"");
		 if (namespacePolicy.qualifyElements) {
			 String uri = getNamespaceURI(element);
			 String prefix = (String) nsPrefixMap.get(uri);
			 if (prefix != null && !"""".equals(prefix)) {
				 out.write(prefix);
				 out.write("":"");
			 }
			 removeNSDefinitions(element);
		 }
		 out.write(element.getTagName());
		 out.write("">"");
		 out.write(lSep);
		 out.flush();
	 }
	 public String encode(String value) {
		 StringBuffer sb = new StringBuffer();
		 int len = value.length();
		 for (int i = 0;
		 i < len;
		 i++) {
			 char c = value.charAt(i);
			 switch (c) {
				 case '<': sb.append(""&lt;
				"");
				 break;
				 case '>': sb.append(""&gt;
				"");
				 break;
				 case '\'': sb.append(""&apos;
				"");
				 break;
				 case '\""': sb.append(""&quot;
				"");
				 break;
				 case '&': int nextSemi = value.indexOf("";
				"", i);
				 if (nextSemi < 0 || !isReference(value.substring(i, nextSemi + 1))) {
					 sb.append(""&amp;
					"");
				 }
				 else {
					 sb.append('&');
				 }
				 break;
				 default: if (isLegalCharacter(c)) {
					 sb.append(c);
				 }
				 break;
			 }
		 }
		 return sb.substring(0);
	 }
	 public String encodedata(final String value) {
		 StringBuffer sb = new StringBuffer();
		 int len = value.length();
		 for (int i = 0;
		 i < len;
		 ++i) {
			 char c = value.charAt(i);
			 if (isLegalCharacter(c)) {
				 sb.append(c);
			 }
		 }
		 String result = sb.substring(0);
		 int cdEnd = result.indexOf(""]]>"");
		 while (cdEnd != -1) {
			 sb.setLength(cdEnd);
			 sb.append(""&#x5d;
			&#x5d;
			&gt;
			"") .append(result.substring(cdEnd + 3));
			 result = sb.substring(0);
			 cdEnd = result.indexOf(""]]>"");
		 }
		 return result;
	 }
	 public boolean isReference(String ent) {
		 if (!(ent.charAt(0) == '&') || !ent.endsWith("";
		"")) {
			 return false;
		 }
		 if (ent.charAt(1) == '#') {
			 if (ent.charAt(2) == 'x') {
				 try {
					 Integer.parseInt(ent.substring(3, ent.length() - 1), HEX);
					 return true;
				 }
				 catch (NumberFormatException nfe) {
					 return false;
				 }
			 }
			 else {
				 try {
					 Integer.parseInt(ent.substring(2, ent.length() - 1));
					 return true;
				 }
				 catch (NumberFormatException nfe) {
					 return false;
				 }
			 }
		 }
		 String name = ent.substring(1, ent.length() - 1);
		 for (int i = 0;
		 i < knownEntities.length;
		 i++) {
			 if (name.equals(knownEntities[i])) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public boolean isLegalCharacter(char c) {
		 if (c == 0x9 || c == 0xA || c == 0xD) {
			 return true;
		 }
		 else if (c < 0x20) {
			 return false;
		 }
		 else if (c <= 0xD7FF) {
			 return true;
		 }
		 else if (c < 0xE000) {
			 return false;
		 }
		 else if (c <= 0xFFFD) {
			 return true;
		 }
		 return false;
	 }
	 private void removeNSDefinitions(Element element) {
		 ArrayList al = (ArrayList) nsURIByElement.get(element);
		 if (al != null) {
			 Iterator iter = al.iterator();
			 while (iter.hasNext()) {
				 nsPrefixMap.remove(iter.next());
			 }
			 nsURIByElement.remove(element);
		 }
	 }
	 private void addNSDefinition(Element element, String uri) {
		 ArrayList al = (ArrayList) nsURIByElement.get(element);
		 if (al == null) {
			 al = new ArrayList();
			 nsURIByElement.put(element, al);
		 }
		 al.add(uri);
	 }
	 private static String getNamespaceURI(Node n) {
		 String uri = n.getNamespaceURI();
		 if (uri == null) {
			 uri = """";
		 }
		 return uri;
	 }
}",0,0,0,0
"protected ModelAndView handle(HttpServletRequest aReq, HttpServletResponse aResp, Object aCommand, BindException aErrors) throws Exception {
	LogReaderCommand cmd = (LogReaderCommand) aCommand;
	String messageText = """";
	int firstLine = 0;
	String[] lines = {
	"""", """"}
	;
	if(aErrors.hasErrors()){
		Iterator it = aErrors.getAllErrors().iterator();
		while(it.hasNext()){
			org.springframework.validation.ObjectError err = (org.springframework.validation.ObjectError)it.next();
			if(messageText.length()>0) messageText += "";
			 "";
			messageText += err.getDefaultMessage();
		}
	}
	else if(cmd.getTargetInstanceOid() != null){
		TargetInstance ti = targetInstanceManager.getTargetInstance(cmd.getTargetInstanceOid());
		cmd.setTargetName(ti.getTarget().getName());
		if ((cmd.getNumLines() == null || cmd.getNumLines().intValue() == -1)) {
			cmd.setNumLines(harvestCoordinator.countLogLines(ti, cmd.getLogFileName()));
		}
		if (cmd.getNoOfLines() == null || cmd.getNoOfLinesInt() == 0) {
			cmd.setNoOfLines(700);
		}
		try{
			if (LogReaderCommand.VALUE_TIMESTAMP.equals(cmd.getFilterType())) {
				if(cmd.getLongTimestamp() != -1){
					firstLine = harvestCoordinator.getFirstLogLineAfterTimeStamp(ti, cmd.getLogFileName(), cmd.getLongTimestamp());
					if(firstLine > -1){
						lines = harvestCoordinator.getLog(ti, cmd.getLogFileName(), firstLine, cmd.getNoOfLinesInt());
					}
					else{
						firstLine = -2;
						lines = harvestCoordinator.tailLog(ti, cmd.getLogFileName(), 0);
					}
				}
				else{
					firstLine = -2;
					messageText = cmd.getFilter()+ "" is not a valid date/time format"";
				}
			}
			else if(LogReaderCommand.VALUE_REGEX_CONTAIN.equals(cmd.getFilterType())){
				firstLine = harvestCoordinator.getFirstLogLineContaining(ti, cmd.getLogFileName(), cmd.getFilter());
				if(firstLine > -1){
					lines = harvestCoordinator.getLog(ti, cmd.getLogFileName(), firstLine, cmd.getNoOfLinesInt());
				}
				else{
					firstLine = -2;
					lines = harvestCoordinator.tailLog(ti, cmd.getLogFileName(), 0);
				}
			}
			else if(LogReaderCommand.VALUE_REGEX_INDENT.equals(cmd.getFilterType())){
				firstLine = -2;
				if(cmd.getFilter().startsWith(""^[ "") ||cmd.getFilter().startsWith(""^[\\t"")){
					messageText = cmd.getFilter()+ "" will only return indented lines. Please choose a Regular Expression that can return non indented lines."";
				}
				else{
					String regex = cmd.getFilter();
					if(!cmd.getFilter().startsWith(""^"")){
						regex = ""^[^ \\t].*""+cmd.getFilter();
					}
					lines = harvestCoordinator.getLogLinesByRegex(ti, cmd.getLogFileName(), cmd.getNoOfLinesInt(), regex, true);
					if(lines != null && lines.length == 2){
						StringBuilder sb = new StringBuilder();
						String[] subLines = lines[0].split(""\n"");
						for(int i = 0;
						 i < subLines.length;
						 i++){
							sb.append(getFollowingIndentedLines(ti, cmd, subLines[i], cmd.getShowLineNumbers()));
						}
						lines[0] = sb.toString();
					}
					else{
						firstLine = -2;
						lines = harvestCoordinator.tailLog(ti, cmd.getLogFileName(), 0);
					}
				}
			}
			else if(LogReaderCommand.VALUE_REGEX_MATCH.equals(cmd.getFilterType())){
				firstLine = -2;
				lines = harvestCoordinator.getLogLinesByRegex(ti, cmd.getLogFileName(), cmd.getNoOfLinesInt(), cmd.getFilter(), cmd.getShowLineNumbers());
			}
			else if(LogReaderCommand.VALUE_FROM_LINE.equals(cmd.getFilterType())) {
				firstLine = new Integer(cmd.getFilter()).intValue();
				lines = harvestCoordinator.getLog(ti, cmd.getLogFileName(), firstLine, cmd.getNoOfLinesInt());
			}
			else if(LogReaderCommand.VALUE_HEAD.equals(cmd.getFilterType())){
				firstLine = 1;
				lines = harvestCoordinator.headLog(ti, cmd.getLogFileName(), cmd.getNoOfLinesInt());
			}
			else{
				firstLine = -1;
				lines = harvestCoordinator.tailLog(ti, cmd.getLogFileName(), cmd.getNoOfLinesInt());
			}
		}
		catch(org.webcurator.core.exceptions.WCTRuntimeException e){
			if(e.getCause().getMessage().startsWith(""java.util.regex.PatternSyntaxException"")){
				firstLine = -2;
				lines[0] = e.getCause().getMessage().substring(e.getCause().getMessage().indexOf("":"")+2);
			}
			else{
				throw e;
			}
		}
	}
	else{
		messageText = ""Context has been lost. Please close the Log Viewer and re-open."";
		cmd = new LogReaderCommand();
	}
	ModelAndView mav = new ModelAndView();
	mav.setViewName(Constants.VIEW_LOG_READER);
	mav.addObject(Constants.GBL_CMD_DATA, cmd);
	mav.addObject(LogReaderCommand.MDL_FILTER_NAMES, this.filterNames);
	mav.addObject(LogReaderCommand.MDL_FILTER_TYPES, this.filterTypes);
	mav.addObject(LogReaderCommand.MDL_LINES, parseLines(lines, cmd.getShowLineNumbers(), firstLine, cmd.getNumLines()));
	mav.addObject(Constants.MESSAGE_TEXT, messageText);
	return mav;
}",0,0,1,0
"protected void afterEpoch() {
	 double absErrorChange = Math.abs(previousEpochError - errorFunction.getTotalError());
	 if (absErrorChange <= this.minErrorChange) {
		 minErrorChangeIterationsCount++;
	 }
	 else {
		 minErrorChangeIterationsCount = 0;
	 }
	 if (batchMode == true) {
		 doBatchWeightsUpdate();
	 }
 }",0,0,0,0
"int offerService() throws Exception {
	 long lastHeartbeat = 0;
	 this.fs = FileSystem.getNamed(jobClient.getFilesystemName(), this.fConf);
	 while (running && !shuttingDown) {
		 long now = System.currentTimeMillis();
		 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
		 if (waitTime > 0) {
			 try {
				 synchronized(finishedCount) {
					 if (finishedCount[0] == 0) {
						 finishedCount.wait(waitTime);
					 }
					 finishedCount[0] = 0;
				 }
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 lastHeartbeat = now;
		 Vector taskReports = new Vector();
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 TaskStatus status = tip.createStatus();
				 taskReports.add(status);
			 }
		 }
		 TaskTrackerStatus status = new TaskTrackerStatus(taskTrackerName, localHostname, httpPort, taskReports, failures);
		 int resultCode = jobClient.emitHeartbeat(status, justStarted);
		 synchronized (this) {
			 for (Iterator it = taskReports.iterator();
			 it.hasNext();
			 ) {
				 TaskStatus taskStatus = (TaskStatus) it.next();
				 if (taskStatus.getRunState() != TaskStatus.RUNNING) {
					 if (taskStatus.getIsMap()) {
						 mapTotal--;
					 }
					 else {
						 reduceTotal--;
					 }
					 myMetrics.completeTask();
					 runningTasks.remove(taskStatus.getTaskId());
				 }
			 }
		 }
		 justStarted = false;
		 if (resultCode == InterTrackerProtocol.UNKNOWN_TASKTRACKER) {
			 return STALE_STATE;
		 }
		 try {
			 if ((mapTotal < maxCurrentTasks || reduceTotal < maxCurrentTasks) && acceptNewTasks) {
				 checkLocalDirs(fConf.getLocalDirs());
				 if (enoughFreeSpace(minSpaceStart)) {
					 Task t = jobClient.pollForNewTask(taskTrackerName);
					 if (t != null) {
						 startNewTask(t);
					 }
				 }
			 }
		 }
		 catch (DiskErrorException de ) {
			 LOG.warn(""Exiting task tracker because ""+de.getMessage());
			 jobClient.reportTaskTrackerError(taskTrackerName, ""DiskErrorException"", de.getMessage());
			 return STALE_STATE;
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem launching task: "" + StringUtils.stringifyException(ie));
		 }
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 long timeSinceLastReport = System.currentTimeMillis() - tip.getLastProgressReport();
				 if ((tip.getRunState() == TaskStatus.RUNNING) && (timeSinceLastReport > this.taskTimeout) && !tip.wasKilled) {
					 String msg = ""Task failed to report status for "" + (timeSinceLastReport / 1000) + "" seconds. Killing."";
					 LOG.info(tip.getTask().getTaskId() + "": "" + msg);
					 getCallStacks();
					 tip.reportDiagnosticInfo(msg);
					 try {
						 tip.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 try {
			 String[] toCloseIds = jobClient.pollForTaskWithClosedJob(taskTrackerName);
			 if (toCloseIds != null) {
				 synchronized (this) {
					 for (int i = 0;
					 i < toCloseIds.length;
					 i++) {
						 Object tip = tasks.get(toCloseIds[i]);
						 if (tip != null) {
							 tasksToCleanup.put(tip);
						 }
						 else {
							 LOG.info(""Attempt to cleanup unknown tip "" + toCloseIds[i]);
						 }
					 }
				 }
			 }
		 }
		 catch (IOException ie) {
			 LOG.info(""Problem getting closed tasks: "" + StringUtils.stringifyException(ie));
		 }
		 if (!enoughFreeSpace(minSpaceKill)) {
			 acceptNewTasks=false;
			 synchronized (this) {
				 TaskInProgress killMe = null;
				 for (Iterator it = runningTasks.values().iterator();
				 it.hasNext();
				 ) {
					 TaskInProgress tip = (TaskInProgress) it.next();
					 if ((tip.getRunState() == TaskStatus.RUNNING) && !tip.wasKilled) {
						 if (killMe == null) {
							 killMe = tip;
						 }
						 else if (!tip.getTask().isMapTask()) {
							 if (killMe.getTask().isMapTask() || (tip.getTask().getProgress().get() < killMe.getTask().getProgress().get())) {
								 killMe = tip;
							 }
						 }
						 else if (killMe.getTask().isMapTask() && tip.getTask().getProgress().get() < killMe.getTask().getProgress().get()) {
							 killMe = tip;
						 }
					 }
				 }
				 if (killMe!=null) {
					 String msg = ""Tasktracker running out of space. Killing task."";
					 LOG.info(killMe.getTask().getTaskId() + "": "" + msg);
					 killMe.reportDiagnosticInfo(msg);
					 try {
						 killMe.killAndCleanup(true);
					 }
					 catch (IOException ie) {
						 LOG.info(""Problem cleaning task up: "" + StringUtils.stringifyException(ie));
					 }
				 }
			 }
		 }
		 if (!acceptNewTasks && tasks.isEmpty()) {
			 acceptNewTasks=true;
		 }
	 }
	 return 0;
 }",0,0,1,0
"public void read() throws IOException {
	FileChannel ch = m_pe.getChannel();
	ByteBuffer head = ByteBuffer.allocate(255);
	head.order(ByteOrder.LITTLE_ENDIAN);
	ch.position(m_baseoffset);
	ch.read(head);
	head.position(0);
	int pemagic = head.getInt();
	Machine = head.getShort();
	 NumberOfSections = head.getShort();
	 TimeDateStamp = head.getInt();
	 PointerToSymbolTable = head.getInt();
	 NumberOfSymbols = head.getInt();
	 SizeOfOptionalHeader = head.getShort();
	 Characteristics = head.getShort();
	 Magic = head.getShort();
	 MajorLinkerVersion = head.get();
	 MinorLinkerVersion = head.get();
	 SizeOfCode = head.getInt();
	 SizeOfInitializedData = head.getInt();
	 SizeOfUninitializedData = head.getInt();
	 AddressOfEntryPoint = head.getInt();
	 BaseOfCode = head.getInt();
	 BaseOfData = head.getInt();
	 ImageBase = head.getInt();
	 SectionAlignment = head.getInt();
	 FileAlignment = head.getInt();
	 MajorOperatingSystemVersion = head.getShort();
	 MinorOperatingSystemVersion = head.getShort();
	 MajorImageVersion = head.getShort();
	 MinorImageVersion = head.getShort();
	 MajorSubsystemVersion = head.getShort();
	 MinorSubsystemVersion = head.getShort();
	 Reserved1 = head.getInt();
	 SizeOfImage = head.getInt();
	 SizeOfHeaders = head.getInt();
	 CheckSum = head.getInt();
	 Subsystem = head.getShort();
	 DllCharacteristics = head.getShort();
	 SizeOfStackReserve = head.getInt();
	 SizeOfStackCommit = head.getInt();
	 SizeOfHeapReserve = head.getInt();
	 SizeOfHeapCommit = head.getInt();
	 LoaderFlags = head.getInt();
	 NumberOfRvaAndSizes = head.getInt();
	 ExportDirectory_VA = head.getInt();
	 ExportDirectory_Size = head.getInt();
	 ImportDirectory_VA = head.getInt();
	 ImportDirectory_Size = head.getInt();
	 ResourceDirectory_VA = head.getInt();
	 ResourceDirectory_Size = head.getInt();
	 ExceptionDirectory_VA = head.getInt();
	 ExceptionDirectory_Size = head.getInt();
	 SecurityDirectory_VA = head.getInt();
	 SecurityDirectory_Size = head.getInt();
	 BaseRelocationTable_VA = head.getInt();
	 BaseRelocationTable_Size = head.getInt();
	 DebugDirectory_VA = head.getInt();
	 DebugDirectory_Size = head.getInt();
	 ArchitectureSpecificData_VA = head.getInt();
	 ArchitectureSpecificData_Size = head.getInt();
	 RVAofGP_VA = head.getInt();
	 RVAofGP_Size = head.getInt();
	 TLSDirectory_VA = head.getInt();
	 TLSDirectory_Size = head.getInt();
	 LoadConfigurationDirectory_VA = head.getInt();
	 LoadConfigurationDirectory_Size = head.getInt();
	 BoundImportDirectoryinheaders_VA = head.getInt();
	 BoundImportDirectoryinheaders_Size = head.getInt();
	 ImportAddressTable_VA = head.getInt();
	 ImportAddressTable_Size = head.getInt();
	 DelayLoadImportDescriptors_VA = head.getInt();
	 DelayLoadImportDescriptors_Size = head.getInt();
	 COMRuntimedescriptor_VA = head.getInt();
	 COMRuntimedescriptor_Size = head.getInt();
 }",0,0,1,0
"public class TestGroupConstParallelTez extends TestGroupConstParallel {
	 public static void oneTimeSetup() throws Exception{
		 String execType = System.getProperty(""test.exec.type"");
		 Assume.assumeTrue(""This test suite should only run in tez mode"", execType.equalsIgnoreCase(""tez""));
		 TestGroupConstParallel.oneTimeSetup();
	 }
	 public void checkGroupAllWithParallelGraphResult(JobGraph jGraph) {
		 TezDAGStats ds = (TezDAGStats) jGraph.getJobList().get(0);
		 jGraph = (JobGraph)ds.getPlan();
		 TezVertexStats ts = (TezVertexStats)jGraph.getSinks().get(0);
		 assertEquals(ts.getParallelism(), 1);
	 }
	 public void checkGroupConstWithParallelResult(PhysicalPlan pp, PigContext pc) throws Exception {
		 TezOperPlan tezPlan = buildTezPlan(pp, pc);
		 LoaderProcessor loaderStorer = new LoaderProcessor(tezPlan, pc);
		 loaderStorer.visit();
		 ParallelismSetter parallelismSetter = new ParallelismSetter(tezPlan, pc);
		 parallelismSetter.visit();
		 DAG tezDag = getTezDAG(tezPlan, pc);
		 TezDagBuilder dagBuilder = new TezDagBuilder(pc, tezPlan, tezDag, new HashMap<String, LocalResource>());
		 dagBuilder.visit();
		 for (Vertex v : tezDag.getVertices()) {
			 if (!v.getInputVertices().isEmpty()) {
				 assertEquals(v.getParallelism(), 1);
			 }
		 }
	 }
	 public void checkGroupNonConstWithParallelResult(PhysicalPlan pp, PigContext pc) throws Exception {
		 TezOperPlan tezPlan = buildTezPlan(pp, pc);
		 LoaderProcessor loaderStorer = new LoaderProcessor(tezPlan, pc);
		 loaderStorer.visit();
		 ParallelismSetter parallelismSetter = new ParallelismSetter(tezPlan, pc);
		 parallelismSetter.visit();
		 DAG tezDag = getTezDAG(tezPlan, pc);
		 TezDagBuilder dagBuilder = new TezDagBuilder(pc, tezPlan, tezDag, new HashMap<String, LocalResource>());
		 dagBuilder.visit();
		 for (Vertex v : tezDag.getVertices()) {
			 if (!v.getInputVertices().isEmpty()) {
				 assertEquals(v.getParallelism(), 100);
			 }
		 }
	 }
	 private TezOperPlan buildTezPlan(PhysicalPlan pp, PigContext pc) throws Exception{
		 TezCompiler comp = new TezCompiler(pp, pc);
		 comp.compile();
		 return comp.getTezPlan();
	 }
	 private DAG getTezDAG(TezOperPlan tezPlan, PigContext pc) {
		 TezPlanContainerNode tezPlanNode = new TezPlanContainerNode(OperatorKey.genOpKey(""DAGName""), tezPlan);
		 TezScriptState scriptState = new TezScriptState(""test"");
		 ScriptState.start(scriptState);
		 scriptState.setDAGScriptInfo(tezPlanNode);
		 DAG tezDag = DAG.create(tezPlanNode.getOperatorKey().toString());
		 return tezDag;
	 }
}",1,0,0,0
"public class TokensFile {
	 public String getTokensFilePath() {
		 return System.getProperty(""user.home"") + ""/.cf/tokens.yml"";
	 }
	 public void removeToken(URI target) {
		 TargetInfos targetInfos = getTokensFromFile();
		 targetInfos.remove(target);
		 saveTokensToFile(targetInfos);
	 }
	 public OAuth2AccessToken retrieveToken(URI target) {
		 TargetInfos targetInfos = getTokensFromFile();
		 if (targetInfos == null) {
			 return null;
		 }
		 HashMap<String, String> targetInfo = targetInfos.get(target);
		 if (targetInfo == null) {
			 return null;
		 }
		 DefaultOAuth2RefreshToken refreshToken = targetInfos.getRefreshToken(targetInfo);
		 DefaultOAuth2AccessToken token = targetInfos.getToken(targetInfo);
		 token.setRefreshToken(refreshToken);
		 return token;
	 }
	 public void saveToken(URI target, OAuth2AccessToken token, CloudInfo cloudInfo, CloudSpace space) {
		 TargetInfos targetInfos = getTokensFromFile();
		 if (targetInfos == null) {
			 targetInfos = new TargetInfos();
		 }
		 HashMap<String, String> targetInfo = targetInfos.get(target);
		 if (targetInfo == null) {
			 targetInfo = new LinkedHashMap<String, String>();
		 }
		 targetInfos.putToken(targetInfo, token);
		 targetInfos.putRefreshToken(targetInfo, token.getRefreshToken());
		 targetInfos.putVersion(targetInfo, cloudInfo.getVersion());
		 targetInfos.putSpace(targetInfo, space.getMeta() .getGuid() .toString());
		 targetInfos.putOrganization(targetInfo, space.getOrganization() .getMeta() .getGuid() .toString());
		 targetInfos.put(target, targetInfo);
		 saveTokensToFile(targetInfos);
	 }
	 protected File getTokensFile() {
		 return new File(getTokensFilePath());
	 }
	 protected TargetInfos getTokensFromFile() {
		 final File tokensFile = getTokensFile();
		 try {
			 YamlReader reader = new YamlReader(new FileReader(tokensFile));
			 return reader.read(TargetInfos.class);
		 }
		 catch (FileNotFoundException fnfe) {
			 return new TargetInfos();
		 }
		 catch (IOException e) {
			 throw new RuntimeException(""An error occurred reading the tokens file at "" + tokensFile.getPath() + "":"" + e.getMessage(), e);
		 }
	 }
	 protected void saveTokensToFile(TargetInfos targetInfos) {
		 final File tokensFile = getTokensFile();
		 tokensFile.getParentFile() .mkdirs();
		 try {
			 FileWriter fileWriter = new FileWriter(tokensFile);
			 YamlConfig config = new YamlConfig();
			 config.writeConfig.setAlwaysWriteClassname(false);
			 config.writeConfig.setWriteRootElementTags(false);
			 config.writeConfig.setWriteRootTags(false);
			 config.writeConfig.setExplicitFirstDocument(true);
			 YamlWriter yamlWriter = new YamlWriter(fileWriter, config);
			 yamlWriter.write(targetInfos);
			 yamlWriter.close();
			 fileWriter.close();
		 }
		 catch (IOException e) {
			 throw new RuntimeException(""An error occurred writing the tokens file at "" + tokensFile.getPath() + "":"" + e.getMessage(), e);
		 }
	 }
}",1,0,0,0
"protected static class JFIFPieceSegment extends JFIFPiece {
	 public final int marker;
	 private final byte[] markerBytes;
	 private final byte[] segmentLengthBytes;
	 private final byte[] segmentData;
	 public JFIFPieceSegment(final int marker, final byte[] segmentData) {
		 this(marker, ByteConversions.toBytes((short) marker, JPEG_BYTE_ORDER), ByteConversions.toBytes((short) (segmentData.length + 2), JPEG_BYTE_ORDER), segmentData);
	 }
	 JFIFPieceSegment(final int marker, final byte[] markerBytes, final byte[] segmentLengthBytes, final byte[] segmentData) {
		 this.marker = marker;
		 this.markerBytes = markerBytes;
		 this.segmentLengthBytes = segmentLengthBytes;
		 this.segmentData = segmentData;
	 }
	 public String toString() {
		 return ""["" + this.getClass().getName() + "" (0x"" + Integer.toHexString(marker) + "")]"";
	 }
	 protected void write(final OutputStream os) throws IOException {
		 os.write(markerBytes);
		 os.write(segmentLengthBytes);
		 os.write(segmentData);
	 }
	 public boolean isApp1Segment() {
		 return marker == JpegConstants.JPEG_APP1_MARKER;
	 }
	 public boolean isAppSegment() {
		 return marker >= JpegConstants.JPEG_APP0_MARKER && marker <= JpegConstants.JPEG_APP15_MARKER;
	 }
	 public boolean isExifSegment() {
		 if (marker != JpegConstants.JPEG_APP1_MARKER) {
			 return false;
		 }
		 if (!startsWith(segmentData, JpegConstants.EXIF_IDENTIFIER_CODE)) {
			 return false;
		 }
		 return true;
	 }
	 public boolean isPhotoshopApp13Segment() {
		 if (marker != JpegConstants.JPEG_APP13_MARKER) {
			 return false;
		 }
		 if (!new IptcParser().isPhotoshopJpegSegment(segmentData)) {
			 return false;
		 }
		 return true;
	 }
	 public boolean isXmpSegment() {
		 if (marker != JpegConstants.JPEG_APP1_MARKER) {
			 return false;
		 }
		 if (!startsWith(segmentData, JpegConstants.XMP_IDENTIFIER)) {
			 return false;
		 }
		 return true;
	 }
	 public byte[] getSegmentData() {
		 return segmentData;
	 }
 }",0,0,0,0
"public void offerService() throws Exception {
	 dataXceiveServer.start();
	 long lastHeartbeat = 0, lastBlockReport = 0;
	 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
	 try {
		 while (shouldRun) {
			 long now = System.currentTimeMillis();
			 if (now - lastHeartbeat > HEARTBEAT_INTERVAL) {
				 BlockCommand cmd = namenode.sendHeartbeat(dnRegistration, data.getCapacity(), data.getRemaining(), xmitsInProgress);
				 lastHeartbeat = now;
				 if( cmd != null ) {
					 data.checkDataDir();
					 if (cmd.transferBlocks()) {
						 Block blocks[] = cmd.getBlocks();
						 DatanodeInfo xferTargets[][] = cmd.getTargets();
						 for (int i = 0;
						 i < blocks.length;
						 i++) {
							 if (!data.isValidBlock(blocks[i])) {
								 String errStr = ""Can't send invalid block "" + blocks[i];
								 LOG.info(errStr);
								 namenode.errorReport( dnRegistration, DatanodeProtocol.INVALID_BLOCK, errStr);
								 break;
							 }
							 else {
								 if (xferTargets[i].length > 0) {
									 LOG.info(""Starting thread to transfer block "" + blocks[i] + "" to "" + xferTargets[i]);
									 new Daemon(new DataTransfer(xferTargets[i], blocks[i])).start();
								 }
							 }
						 }
					 }
					 else if (cmd.invalidateBlocks()) {
						 data.invalidate(cmd.getBlocks());
					 }
					 else if( cmd.shutdownNode()) {
						 this.shutdown();
						 continue;
					 }
				 }
			 }
			 if (now - lastBlockReport > blockReportInterval) {
				 data.checkDataDir();
				 Block toDelete[] = namenode.blockReport(dnRegistration, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			 }
			 Block [] blockArray=null;
			 synchronized( receivedBlockList ) {
				 if (receivedBlockList.size() > 0) {
					 blockArray = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
					 receivedBlockList.removeAllElements();
				 }
			 }
			 if( blockArray != null ) {
				 namenode.blockReceived( dnRegistration, blockArray );
			 }
			 long waitTime = HEARTBEAT_INTERVAL - (System.currentTimeMillis() - lastHeartbeat);
			 synchronized( receivedBlockList ) {
				 if (waitTime > 0 && receivedBlockList.size() == 0) {
					 try {
						 receivedBlockList.wait(waitTime);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
	 }
	 catch(DiskErrorException e) {
		 handleDiskError(e.getMessage());
	 }
	 try {
		 this.dataXceiveServer.join();
	 }
	 catch (InterruptedException ie) {
	 }
 }",0,0,1,0
"public class CloudCliServiceLaunchConfigurationDelegate extends BootCliLaunchConfigurationDelegate {
	private static final VersionRange SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE = new VersionRange(""1.3.0"");
	public final static String TYPE_ID = ""org.springframework.ide.eclipse.boot.launch.cloud.cli.service"";
	public final static String ATTR_CLOUD_SERVICE_ID = ""local-cloud-service-id"";
	private final static String PREF_DONT_SHOW_PLATFORM_WARNING = ""org.springframework.ide.eclipse.boot.launch.cloud.cli.NotSupportedPlatform"";
	private final static String PREF_DONT_SHOW_JRE_WARNING = ""org.springframework.ide.eclipse.boot.launch.cloud.cli.JRE"";
	private final static String PREF_DONT_SHOW_JDK_WARNING = ""org.springframework.ide.eclipse.boot.launch.cloud.cli.JDK"";
	private List<String> getCloudCliServiceLifeCycleVmArguments(ILaunchConfiguration configuration, int jmxPort) {
		List<String> vmArgs = new ArrayList<>();
		EnumSet<JmxBeanSupport.Feature> enabled = BootLaunchConfigurationDelegate.getEnabledJmxFeatures(configuration);
		if (!enabled.isEmpty()) {
			String enableLiveBeanArgs = JmxBeanSupport.jmxBeanVmArgs(jmxPort, enabled);
			vmArgs.addAll(Arrays.asList(enableLiveBeanArgs.split(""\n"")));
		}
		return vmArgs;
	}
	protected String[] getProgramArgs(IBootInstall bootInstall, ILaunch launch, ILaunchConfiguration configuration) {
		try {
			CloudCliInstall cloudCliInstall = bootInstall.getExtension(CloudCliInstall.class);
			if (cloudCliInstall == null) {
				Log.error(""No Spring Cloud CLI installation found"");
			}
			 else {
				String serviceId = configuration.getAttribute(ATTR_CLOUD_SERVICE_ID, (String) null);
				Version cloudCliVersion = cloudCliInstall.getVersion();
				List<String> vmArgs = new ArrayList<>();
				List<String> args = new ArrayList<>();
				args.add(CloudCliInstall.COMMAND_PREFIX);
				args.add(serviceId);
				if (cloudCliVersion != null && SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion)) {
					args.add(""--deployer=thin"");
				}
				args.add(""--"");
				args.add(""--logging.level.org.springframework.cloud.launcher.deployer=DEBUG"");
				if (BootLaunchConfigurationDelegate.supportsAnsiConsoleOutput()) {
					vmArgs.add(""-Dspring.output.ansi.enabled=always"");
				}
				if (CloudCliServiceLaunchConfigurationDelegate.SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion)) {
					if (!vmArgs.isEmpty()) {
						args.add(""--spring.cloud.launcher.deployables."" + serviceId + "".properties.spring.cloud.deployer.local.javaOpts="" + String.join("","", vmArgs));
					}
				}
				 else if (CloudCliInstall.CLOUD_CLI_JAVA_OPTS_SUPPORTING_VERSIONS.includes(cloudCliVersion)) {
					int jmxPort = getJmxPort(configuration);
					launch.setAttribute(BootLaunchConfigurationDelegate.JMX_PORT, String.valueOf(jmxPort));
					vmArgs.addAll(getCloudCliServiceLifeCycleVmArguments(configuration, jmxPort));
					if (!vmArgs.isEmpty()) {
						args.add(""--spring.cloud.launcher.deployables."" + serviceId + "".properties.JAVA_OPTS="" + String.join("","", vmArgs));
					}
				}
				return args.toArray(new String[args.size()]);
			}
		}
		 catch (Exception e) {
			Log.log(e);
		}
		return new String[0];
	}
	private int getJmxPort(ILaunchConfiguration configuration) {
		int port = 0;
		try {
			port = Integer.parseInt(BootLaunchConfigurationDelegate.getJMXPort(configuration));
		}
		 catch (Exception e) {
		}
		if (port == 0) {
			try {
				port = PortFinder.findFreePort();
			}
			 catch (IOException e) {
				Log.log(e);
			}
		}
		return port;
	}
	public static boolean isLocalCloudServiceLaunch(ILaunchConfiguration conf) {
		try {
			if (conf!=null) {
				String type = conf.getType().getIdentifier();
				return TYPE_ID.equals(type);
			}
		}
		 catch (Exception e) {
			Log.log(e);
		}
		return false;
	}
	public static ILaunchConfigurationWorkingCopy createLaunchConfig(String serviceId) throws CoreException {
		ILaunchManager launchManager = DebugPlugin.getDefault().getLaunchManager();
		ILaunchConfigurationType type = launchManager.getLaunchConfigurationType(TYPE_ID);
		ILaunchConfigurationWorkingCopy config = type.newInstance(null, serviceId);
		BootLaunchConfigurationDelegate.setDefaults(config, null, null);
		config.setAttribute(ATTR_CLOUD_SERVICE_ID, serviceId);
		BootLaunchConfigurationDelegate.setProcessFactory(config, CloudCliProcessFactory.class);
		return config;
	}
	public static boolean canUseLifeCycle(ILaunch launch) {
		ILaunchConfiguration conf = launch.getLaunchConfiguration();
		return conf!=null && canUseLifeCycle(conf);
	}
	public static boolean isSingleProcessServiceConfig(ILaunchConfiguration conf) {
		try {
			if (isCloudCliService(conf)) {
				IBootInstall bootInstall = BootInstallManager.getInstance().getDefaultInstall();
				if (bootInstall != null) {
					Version cloudCliVersion = bootInstall.getExtension(CloudCliInstall.class) == null ? null : bootInstall.getExtension(CloudCliInstall.class).getVersion();
					return SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion);
				}
			}
		}
		 catch (Exception e) {
		}
		return false;
	}
	public static boolean isCloudCliService(ILaunchConfiguration conf) {
		try {
			return TYPE_ID.equals(conf.getType().getIdentifier());
		}
		 catch (CoreException e) {
		}
		return false;
	}
	public static boolean canUseLifeCycle(ILaunchConfiguration conf) {
		try {
			if (!isCloudCliService(conf)) {
				return false;
			}
			IBootInstall bootInstall = BootInstallManager.getInstance().getDefaultInstall();
			if (bootInstall == null) {
				return false;
			}
			Version cloudCliVersion = bootInstall.getExtension(CloudCliInstall.class) == null ? null : bootInstall.getExtension(CloudCliInstall.class).getVersion();
			if (!canUseLifeCycle(cloudCliVersion)) {
				return false;
			}
			return SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion) || BootLaunchConfigurationDelegate.getEnableLifeCycle(conf);
		}
		 catch (Exception e) {
		}
		return false;
	}
	private static boolean canUseLifeCycle(Version cloudCliVersion) {
		if (cloudCliVersion == null|| !CloudCliInstall.CLOUD_CLI_JAVA_OPTS_SUPPORTING_VERSIONS.includes(cloudCliVersion)|| SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion)) {
			return false;
		}
		return true;
	}
	public static class CloudCliProcessFactory extends BootProcessFactory {
		public IProcess newProcess(ILaunch launch, Process process, String label, Map<String, String> attributes) {
			try {
				IBootInstall bootInstall = BootInstallManager.getInstance().getDefaultInstall();
				if (bootInstall != null) {
					Version cloudCliVersion = bootInstall.getExtension(CloudCliInstall.class) == null ? null : bootInstall.getExtension(CloudCliInstall.class).getVersion();
					if (CloudCliServiceLaunchConfigurationDelegate.isSingleProcessServiceConfig(launch.getLaunchConfiguration())) {
						final IPreferenceStore store = BootActivator.getDefault().getPreferenceStore();
						long pid = -1;
						try {
							if (ProcessUtils.isLatestJdkForTools()) {
								pid = ProcessUtils.getProcessID(process);
							}
							 else {
								Log.warn(""Old JDK version. Need latest JDK to make JMX connection to process using its PID"");
								if (!store.getBoolean(PREF_DONT_SHOW_JDK_WARNING)) {
									PlatformUI.getWorkbench().getDisplay().asyncExec(() -> {
										MessageDialogWithToggle dialog = MessageDialogWithToggle.openWarning(Display.getCurrent().getActiveShell(), ""Cloud CLI Service Info Limitation"",""Cloud service process life-cycle data is limited and port data is unavailable because STS runnning on an old JDK version. Point STS to the latest JDK and restart it to have complete service process life-cycle and port data"",""Don't show this message again"",false, null, null);
										store.setValue(PREF_DONT_SHOW_JDK_WARNING, dialog.getToggleState());
									}
									);
								}
							}
						}
						 catch (NoClassDefFoundError e) {
							Log.warn(e);
							if (!store.getBoolean(PREF_DONT_SHOW_JRE_WARNING)) {
								PlatformUI.getWorkbench().getDisplay().asyncExec(() -> {
									MessageDialogWithToggle dialog = MessageDialogWithToggle.openWarning(Display.getCurrent().getActiveShell(), ""Cloud CLI Service Info Limitation"",""Cloud service process life-cycle data is limited and port data is unavailable because STS is running on a JRE. Point it to a JDK and restart STS for complete service process life-cycle and port data"",""Don't show this message again"",false, null, null);
									store.setValue(PREF_DONT_SHOW_JRE_WARNING, dialog.getToggleState());
								}
								);
							}
						}
						 catch (UnsupportedOperationException e) {
							Log.warn(e);
							if (!store.getBoolean(PREF_DONT_SHOW_PLATFORM_WARNING)) {
								PlatformUI.getWorkbench().getDisplay().asyncExec(() -> {
									MessageDialogWithToggle dialog = MessageDialogWithToggle.openWarning(Display.getCurrent().getActiveShell(), ""Cloud CLI Service Info Limitation"",""Cloud service process life-cycle data is limited and port data is unavailable on the current platform."",""Don't show this message again"",false, null, null);
									store.setValue(PREF_DONT_SHOW_PLATFORM_WARNING, dialog.getToggleState());
								}
								);
							}
						}
						launch.setAttribute(BootLaunchConfigurationDelegate.PROCESS_ID, String.valueOf(pid));
						return new RuntimeProcess(launch, process, label, attributes);
					}
					 else if (canUseLifeCycle(cloudCliVersion)) {
						return super.newProcess(launch, process, label, attributes);
					}
				}
			}
			 catch (Exception e) {
				Log.log(e);
			}
			return new RuntimeProcess(launch, process, label, attributes);
		}
	}
}",1,0,0,0
"public interface VolumeHostDao extends GenericDao<VolumeHostVO, Long>, StateDao<ObjectInDataStoreStateMachine.State, ObjectInDataStoreStateMachine.Event, DataObjectInStore> {
	 VolumeHostVO findByHostVolume(long hostId, long volumeId);
	 VolumeHostVO findByVolumeId(long volumeId);
	 List<VolumeHostVO> listBySecStorage(long sserverId);
	 List<VolumeHostVO> listDestroyed(long hostId);
	 VolumeHostVO findVolumeByZone(long zoneId, long volumeId);
}",0,0,0,0
"public ConnectionTable(Receiver r, InetAddress bind_addr, InetAddress external_addr, int srv_port, int max_port, long reaper_interval, long conn_expire_time) throws Exception;",0,0,0,1
"public class FolderImpl implements Folder {
	 private String id_ ;
	 private String accountId_ ;
	 private String name_ ;
	 private String label_ ;
	 private Date createdDate_ ;
	 private boolean removeable_ = true ;
	 public FolderImpl() {
	}
	 public FolderImpl(String name , String label, String accountId) {
		 name_ = name ;
		 label_ = label ;
		 accountId_ = accountId ;
	 }
	 public String getId() {
		 return id_ ;
	 }
	 public void setId(String value) {
		 id_ = value;
	 }
	 public String getAccountId() {
		 return accountId_ ;
	 }
	 public void setAccountId(String value) {
		 accountId_ = value ;
	 }
	 public String getName() {
		return name_;
	}
	 public void setName(String name) {
		 name_ = name;
	}
	 public String getLabel() {
		 return label_ ;
	 }
	 public void setLabel(String label) {
		 label_ = label ;
	}
	 public Date getCreatedDate() {
		 return createdDate_ ;
	 }
	 public void setCreatedDate(Date date) {
		 createdDate_ = date ;
	}
	 public boolean getRemoveable() {
		 return removeable_ ;
	 }
	 public void setRemoveable(boolean b) {
		 removeable_ = b ;
	}
}",0,1,0,0
"public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info);",0,0,0,1
"protected void onRender(Element parent, int index) {
	 super.onRender(parent, index);
	 setLayout(new FitLayout());
	 setBorders(false);
	 initToolBar();
	 initGrid();
	 ContentPanel devicesBundlesPanel = new ContentPanel();
	 devicesBundlesPanel.setBorders(false);
	 devicesBundlesPanel.setBodyBorder(true);
	 devicesBundlesPanel.setHeaderVisible(false);
	 devicesBundlesPanel.setLayout(new FitLayout());
	 devicesBundlesPanel.setScrollMode(Scroll.AUTO);
	 devicesBundlesPanel.setTopComponent(toolBar);
	 devicesBundlesPanel.add(grid);
	 add(devicesBundlesPanel);
	 initialized = true;
 }",0,0,1,0
"public final void addDataType(RuntimeConfigurable r) {
	 throw new BuildException(NO_CHILDREN_ALLOWED);
 }",0,0,0,0
"static final class SymbolComparator implements Comparator {
	public int compare(Object arg0, Object arg1) {
		long addr0=0;
		long addr1=0;
		if (arg0 instanceof Symbol) {
			Symbol S0 = (Symbol) arg0;
			Symbol S1 = (Symbol) arg1;
			addr0 = S0.symbolStart;
			addr1 = S1.symbolStart;
		}
		 else {
			addr0 = ((Long)arg0).longValue();
			addr1 = ((Long)arg1).longValue();
		}
		if (addr0 >= 0 && addr1 >=0) {
			if (addr0 == addr1) return 0;
			if (addr0 < addr1) return -1;
			return 1;
		}
		if (addr0 < 0 && addr1 < 0) {
			if (addr0 == addr1) return 0;
			if (addr0 < addr1) return 1;
			return -1;
		}
		if (addr0 < 0 && addr1 >=0) {
			return 1;
		}
		return -1;
	}
}",1,0,0,0
"public class JAXRSOutInterceptor extends AbstractOutDatabindingInterceptor {
	 private static final Logger LOG = LogUtils.getL7dLogger(JAXRSOutInterceptor.class);
	 private static final ResourceBundle BUNDLE = BundleUtils.getBundle(JAXRSOutInterceptor.class);
	 public JAXRSOutInterceptor() {
		 super(Phase.MARSHAL);
	 }
	 public void handleMessage(Message message) {
		 ServerProviderFactory providerFactory = ServerProviderFactory.getInstance(message);
		 try {
			 processResponse(providerFactory, message);
		 }
		 finally {
			 ServerProviderFactory.releaseRequestState(providerFactory, message);
		 }
	 }
	 private void processResponse(ServerProviderFactory providerFactory, Message message) {
		 if (isResponseAlreadyHandled(message)) {
			 return;
		 }
		 MessageContentsList objs = MessageContentsList.getContentsList(message);
		 if (objs == null || objs.isEmpty()) {
			 return;
		 }
		 Object responseObj = objs.get(0);
		 Response response = null;
		 if (responseObj instanceof Response) {
			 response = (Response)responseObj;
			 if (response.getStatus() == 500 && message.getExchange().get(JAXRSUtils.EXCEPTION_FROM_MAPPER) != null) {
				 message.put(Message.RESPONSE_CODE, 500);
				 return;
			 }
		 }
		 else {
			 int status = getStatus(message, responseObj != null ? 200 : 204);
			 response = JAXRSUtils.toResponseBuilder(status).entity(responseObj).build();
		 }
		 Exchange exchange = message.getExchange();
		 OperationResourceInfo ori = (OperationResourceInfo)exchange.get(OperationResourceInfo.class .getName());
		 serializeMessage(providerFactory, message, response, ori, true);
	 }
	 private int getStatus(Message message, int defaultValue) {
		 Object customStatus = message.getExchange().get(Message.RESPONSE_CODE);
		 return customStatus == null ? defaultValue : (Integer)customStatus;
	 }
	 private void serializeMessage(ServerProviderFactory providerFactory, Message message, Response theResponse, OperationResourceInfo ori, boolean firstTry) {
		 ResponseImpl response = (ResponseImpl)JAXRSUtils.copyResponseIfNeeded(theResponse);
		 final Exchange exchange = message.getExchange();
		 boolean headResponse = response.getStatus() == 200 && firstTry && ori != null && HttpMethod.HEAD.equals(ori.getHttpMethod());
		 Object entity = response.getActualEntity();
		 if (headResponse && entity != null) {
			 LOG.info(new org.apache.cxf.common.i18n.Message(""HEAD_WITHOUT_ENTITY"", BUNDLE).toString());
			 entity = null;
		 }
		 Method invoked = ori == null ? null : ori.getAnnotatedMethod() != null ? ori.getAnnotatedMethod() : ori.getMethodToInvoke();
		 Annotation[] annotations = null;
		 Annotation[] staticAnns = ori != null ? ori.getOutAnnotations() : new Annotation[]{
		}
		;
		 Annotation[] responseAnns = response.getEntityAnnotations();
		 if (responseAnns != null) {
			 annotations = new Annotation[staticAnns.length + responseAnns.length];
			 System.arraycopy(staticAnns, 0, annotations, 0, staticAnns.length);
			 System.arraycopy(responseAnns, 0, annotations, staticAnns.length, responseAnns.length);
		 }
		 else {
			 annotations = staticAnns;
		 }
		 response.setStatus(getActualStatus(response.getStatus(), entity));
		 response.setEntity(entity, annotations);
		 MultivaluedMap<String, Object> responseHeaders = prepareResponseHeaders(message, response, entity, firstTry);
		 try {
			 JAXRSUtils.runContainerResponseFilters(providerFactory, response, message, ori, invoked);
		 }
		 catch (Throwable ex) {
			 handleWriteException(providerFactory, message, ex, firstTry);
			 return;
		 }
		 entity = InjectionUtils.getEntity(response.getActualEntity());
		 setResponseStatus(message, getActualStatus(response.getStatus(), entity));
		 if (entity == null) {
			 if (!headResponse) {
				 responseHeaders.putSingle(HttpHeaders.CONTENT_LENGTH, ""0"");
				 if (MessageUtils.getContextualBoolean(message, ""remove.content.type.for.empty.response"", false)) {
					 responseHeaders.remove(HttpHeaders.CONTENT_TYPE);
					 message.remove(Message.CONTENT_TYPE);
				 }
			 }
			 HttpUtils.convertHeaderValuesToString(responseHeaders, true);
			 return;
		 }
		 Object ignoreWritersProp = exchange.get(JAXRSUtils.IGNORE_MESSAGE_WRITERS);
		 boolean ignoreWriters = ignoreWritersProp != null && Boolean.valueOf(ignoreWritersProp.toString());
		 if (ignoreWriters) {
			 writeResponseToStream(message.getContent(OutputStream.class), entity);
			 return;
		 }
		 MediaType responseMediaType = getResponseMediaType(responseHeaders.getFirst(HttpHeaders.CONTENT_TYPE));
		 Class<?> serviceCls = invoked != null ? ori.getClassResourceInfo().getServiceClass() : null;
		 Class<?> targetType = InjectionUtils.getRawResponseClass(entity);
		 Type genericType = InjectionUtils.getGenericResponseType(invoked, serviceCls, response.getActualEntity(), targetType, exchange);
		 targetType = InjectionUtils.updateParamClassToTypeIfNeeded(targetType, genericType);
		 annotations = response.getEntityAnnotations();
		 List<WriterInterceptor> writers = providerFactory .createMessageBodyWriterInterceptor(targetType, genericType, annotations, responseMediaType, message, ori == null ? null : ori.getNameBindings());
		 OutputStream outOriginal = message.getContent(OutputStream.class);
		 if (writers == null || writers.isEmpty()) {
			 writeResponseErrorMessage(message, outOriginal, ""NO_MSG_WRITER"", targetType, responseMediaType);
			 return;
		 }
		 try {
			 boolean checkWriters = false;
			 if (responseMediaType.isWildcardSubtype()) {
				 Produces pM = AnnotationUtils.getMethodAnnotation(ori == null ? null : ori.getAnnotatedMethod(), Produces.class);
				 Produces pC = AnnotationUtils.getClassAnnotation(serviceCls, Produces.class);
				 checkWriters = pM == null && pC == null;
			 }
			 responseMediaType = checkFinalContentType(responseMediaType, writers, checkWriters);
		 }
		 catch (Throwable ex) {
			 handleWriteException(providerFactory, message, ex, firstTry);
			 return;
		 }
		 String finalResponseContentType = JAXRSUtils.mediaTypeToString(responseMediaType);
		 if (LOG.isLoggable(Level.FINE)) {
			 LOG.fine(""Response content type is: "" + finalResponseContentType);
		 }
		 responseHeaders.putSingle(HttpHeaders.CONTENT_TYPE, finalResponseContentType);
		 message.put(Message.CONTENT_TYPE, finalResponseContentType);
		 boolean enabled = checkBufferingMode(message, writers, firstTry);
		 try {
			 try {
				 JAXRSUtils.writeMessageBody(writers, entity, targetType, genericType, annotations, responseMediaType, responseHeaders, message);
				 if (isResponseRedirected(message)) {
					 return;
				 }
				 checkCachedStream(message, outOriginal, enabled);
			 }
			 finally {
				 if (enabled) {
					 OutputStream os = message.getContent(OutputStream.class);
					 if (os != outOriginal && os instanceof CachedOutputStream) {
						 os.close();
					 }
					 message.setContent(OutputStream.class, outOriginal);
					 message.put(XMLStreamWriter.class.getName(), null);
				 }
			 }
		 }
		 catch (Throwable ex) {
			 logWriteError(firstTry, targetType, responseMediaType);
			 handleWriteException(providerFactory, message, ex, firstTry);
		 }
	 }
	 private MultivaluedMap<String, Object> prepareResponseHeaders(Message message, ResponseImpl response, Object entity, boolean firstTry) {
		 MultivaluedMap<String, Object> responseHeaders = response.getMetadata();
		 Map<String, List<Object>> userHeaders = (Map<String, List<Object>>)message.get(Message.PROTOCOL_HEADERS);
		 if (firstTry && userHeaders != null) {
			 responseHeaders.putAll(userHeaders);
		 }
		 if (entity != null) {
			 Object customContentType = responseHeaders.getFirst(HttpHeaders.CONTENT_TYPE);
			 if (customContentType == null) {
				 String initialResponseContentType = (String)message.get(Message.CONTENT_TYPE);
				 if (initialResponseContentType != null) {
					 responseHeaders.putSingle(HttpHeaders.CONTENT_TYPE, initialResponseContentType);
				 }
			 }
			 else {
				 message.put(Message.CONTENT_TYPE, customContentType.toString());
			 }
		 }
		 message.put(Message.PROTOCOL_HEADERS, responseHeaders);
		 setResponseDate(responseHeaders, firstTry);
		 return responseHeaders;
	 }
	 private MediaType getResponseMediaType(Object mediaTypeHeader) {
		 MediaType responseMediaType;
		 if (mediaTypeHeader instanceof MediaType) {
			 responseMediaType = (MediaType)mediaTypeHeader;
		 }
		 else {
			 responseMediaType = mediaTypeHeader == null ? MediaType.WILDCARD_TYPE : JAXRSUtils.toMediaType(mediaTypeHeader.toString());
		 }
		 return responseMediaType;
	 }
	 private int getActualStatus(int status, Object responseObj) {
		 if (status == -1) {
			 return responseObj == null ? 204 : 200;
		 }
		 return status;
	 }
	 private boolean checkBufferingMode(Message m, List<WriterInterceptor> writers, boolean firstTry) {
		 if (!firstTry) {
			 return false;
		 }
		 WriterInterceptor last = writers.get(writers.size() - 1);
		 MessageBodyWriter<Object> w = ((WriterInterceptorMBW)last).getMBW();
		 Object outBuf = m.getContextualProperty(OUT_BUFFERING);
		 boolean enabled = PropertyUtils.isTrue(outBuf);
		 boolean configurableProvider = w instanceof AbstractConfigurableProvider;
		 if (!enabled && outBuf == null && configurableProvider) {
			 enabled = ((AbstractConfigurableProvider)w).getEnableBuffering();
		 }
		 if (enabled) {
			 boolean streamingOn = configurableProvider && ((AbstractConfigurableProvider)w).getEnableStreaming();
			 if (streamingOn) {
				 m.setContent(XMLStreamWriter.class, new CachingXmlEventWriter());
			 }
			 else {
				 m.setContent(OutputStream.class, new CachedOutputStream());
			 }
		 }
		 return enabled;
	 }
	 private void checkCachedStream(Message m, OutputStream osOriginal, boolean enabled) throws Exception {
		 XMLStreamWriter writer = null;
		 if (enabled) {
			 writer = m.getContent(XMLStreamWriter.class);
		 }
		 else {
			 writer = (XMLStreamWriter)m.get(XMLStreamWriter.class.getName());
		 }
		 if (writer instanceof CachingXmlEventWriter) {
			 CachingXmlEventWriter cache = (CachingXmlEventWriter)writer;
			 if (cache.getEvents().size() != 0) {
				 XMLStreamWriter origWriter = null;
				 try {
					 origWriter = StaxUtils.createXMLStreamWriter(osOriginal);
					 for (XMLEvent event : cache.getEvents()) {
						 StaxUtils.writeEvent(event, origWriter);
					 }
				 }
				 finally {
					 StaxUtils.close(origWriter);
				 }
			 }
			 m.setContent(XMLStreamWriter.class, null);
			 return;
		 }
		 if (enabled) {
			 OutputStream os = m.getContent(OutputStream.class);
			 if (os != osOriginal && os instanceof CachedOutputStream) {
				 CachedOutputStream cos = (CachedOutputStream)os;
				 if (cos.size() != 0) {
					 cos.writeCacheTo(osOriginal);
				 }
			 }
		 }
	 }
	 private void logWriteError(boolean firstTry, Class<?> cls, MediaType ct) {
		 if (firstTry) {
			 JAXRSUtils.logMessageHandlerProblem(""MSG_WRITER_PROBLEM"", cls, ct);
		 }
	 }
	 private void handleWriteException(ServerProviderFactory pf, Message message, Throwable ex, boolean firstTry) {
		 Response excResponse = null;
		 if (firstTry) {
			 excResponse = JAXRSUtils.convertFaultToResponse(ex, message);
		 }
		 else {
			 message.getExchange().put(JAXRSUtils.SECOND_JAXRS_EXCEPTION, Boolean.TRUE);
		 }
		 if (excResponse == null) {
			 setResponseStatus(message, 500);
			 throw new Fault(ex);
		 }
		 serializeMessage(pf, message, excResponse, null, false);
	 }
	 private void writeResponseErrorMessage(Message message, OutputStream out, String name, Class<?> cls, MediaType ct) {
		 message.put(Message.CONTENT_TYPE, ""text/plain"");
		 message.put(Message.RESPONSE_CODE, 500);
		 try {
			 String errorMessage = JAXRSUtils.logMessageHandlerProblem(name, cls, ct);
			 if (out != null) {
				 out.write(errorMessage.getBytes(StandardCharsets.UTF_8));
			 }
		 }
		 catch (IOException another) {
		 }
	 }
	 private MediaType checkFinalContentType(MediaType mt, List<WriterInterceptor> writers, boolean checkWriters) {
		 if (checkWriters) {
			 int mbwIndex = writers.size() == 1 ? 0 : writers.size() - 1;
			 MessageBodyWriter<Object> writer = ((WriterInterceptorMBW)writers.get(mbwIndex)).getMBW();
			 Produces pm = writer.getClass().getAnnotation(Produces.class);
			 if (pm != null) {
				 List<MediaType> sorted = JAXRSUtils.sortMediaTypes(JAXRSUtils.getMediaTypes(pm.value()), JAXRSUtils.MEDIA_TYPE_QS_PARAM);
				 mt = JAXRSUtils.intersectMimeTypes(sorted, mt).get(0);
			 }
		 }
		 if (mt.isWildcardType() || mt.isWildcardSubtype()) {
			 if (""application"".equals(mt.getType()) || mt.isWildcardType()) {
				 mt = MediaType.APPLICATION_OCTET_STREAM_TYPE;
			 }
			 else {
				 throw ExceptionUtils.toNotAcceptableException(null, null);
			 }
		 }
		 return mt;
	 }
	 private void setResponseDate(MultivaluedMap<String, Object> headers, boolean firstTry) {
		 if (!firstTry || headers.containsKey(HttpHeaders.DATE)) {
			 return;
		 }
		 SimpleDateFormat format = HttpUtils.getHttpDateFormat();
		 headers.putSingle(HttpHeaders.DATE, format.format(new Date()));
	 }
	 private boolean isResponseAlreadyHandled(Message m) {
		 return isResponseAlreadyCommited(m) || isResponseRedirected(m);
	 }
	 private boolean isResponseAlreadyCommited(Message m) {
		 return Boolean.TRUE.equals(m.getExchange().get(AbstractHTTPDestination.RESPONSE_COMMITED));
	 }
	 private boolean isResponseRedirected(Message m) {
		 return Boolean.TRUE.equals(m.getExchange().get(AbstractHTTPDestination.REQUEST_REDIRECTED));
	 }
	 private void writeResponseToStream(OutputStream os, Object responseObj) {
		 try {
			 byte[] bytes = responseObj.toString().getBytes(StandardCharsets.UTF_8);
			 os.write(bytes, 0, bytes.length);
		 }
		 catch (Exception ex) {
			 LOG.severe(""Problem with writing the data to the output stream"");
			 ex.printStackTrace();
			 throw new RuntimeException(ex);
		 }
	 }
	 private void setResponseStatus(Message message, int status) {
		 message.put(Message.RESPONSE_CODE, status);
		 boolean responseHeadersCopied = isResponseHeadersCopied(message);
		 if (responseHeadersCopied) {
			 HttpServletResponse response = (HttpServletResponse)message.get(AbstractHTTPDestination.HTTP_RESPONSE);
			 response.setStatus(status);
		 }
	 }
	 private boolean isResponseHeadersCopied(Message message) {
		 return PropertyUtils.isTrue(message.get(AbstractHTTPDestination.RESPONSE_HEADERS_COPIED));
	 }
	 public void handleFault(Message message) {
	 }
}",1,0,0,0
"public void setPositiveItemLabelPosition(ItemLabelPosition position, boolean notify);",0,0,0,0
"public void drawItem(Graphics2D g2, XYItemRendererState state, Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot, ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset, int series, int item, CrosshairState crosshairState, int pass);",0,0,0,1
"public class PropertyHelperTask extends Task {
	 public final class DelegateElement {
		 private String refid;
		 private DelegateElement() {
		 }
		 public String getRefid() {
			 return refid;
		 }
		 public void setRefid(String refid) {
			 this.refid = refid;
		 }
		 private PropertyHelper.Delegate resolve() {
			 if (refid == null) {
				 throw new BuildException(""refid required for generic delegate"");
			 }
			 return (PropertyHelper.Delegate) getProject().getReference(refid);
		 }
	 }
	 private PropertyHelper propertyHelper;
	 private List delegates;
	 public synchronized void addConfigured(PropertyHelper propertyHelper) {
		 if (this.propertyHelper != null) {
			 throw new BuildException(""Only one PropertyHelper can be installed"");
		 }
		 this.propertyHelper = propertyHelper;
	 }
	 public synchronized void addConfigured(PropertyHelper.Delegate delegate) {
		 getAddDelegateList().add(delegate);
	 }
	 public DelegateElement createDelegate() {
		 DelegateElement result = new DelegateElement();
		 getAddDelegateList().add(result);
		 return result;
	 }
	 public void execute() throws BuildException {
		 if (getProject() == null) {
			 throw new BuildException(""Project instance not set"");
		 }
		 if (propertyHelper == null && delegates == null) {
			 throw new BuildException(""Either a new PropertyHelper"" + "" or one or more PropertyHelper delegates are required"");
		 }
		 PropertyHelper ph = propertyHelper;
		 if (ph == null) {
			 ph = PropertyHelper.getPropertyHelper(getProject());
		 }
		 else {
			 ph = propertyHelper;
		 }
		 synchronized (ph) {
			 if (delegates != null) {
				 for (Iterator iter = delegates.iterator();
				 iter.hasNext();
				) {
					 Object o = iter.next();
					 PropertyHelper.Delegate delegate = o instanceof DelegateElement ? ((DelegateElement) o).resolve() : (PropertyHelper.Delegate) o;
					 log(""Adding PropertyHelper delegate "" + delegate, Project.MSG_DEBUG);
					 ph.add(delegate);
				 }
			 }
		 }
		 if (propertyHelper != null) {
			 log(""Installing PropertyHelper "" + propertyHelper, Project.MSG_DEBUG);
			 getProject().addReference(MagicNames.REFID_PROPERTY_HELPER, propertyHelper);
		 }
	 }
	 private synchronized List getAddDelegateList() {
		 if (delegates == null) {
			 delegates = new ArrayList();
		 }
		 return delegates;
	 }
}",0,0,0,0
"public class FloatWritable implements WritableComparable {
	 private float value;
	 public FloatWritable() {
	}
	 public FloatWritable(float value) {
		 set(value);
	 }
	 public void set(float value) {
		 this.value = value;
	 }
	 public float get() {
		 return value;
	 }
	 public void readFields(DataInput in) throws IOException {
		 value = in.readFloat();
	 }
	 public void write(DataOutput out) throws IOException {
		 out.writeFloat(value);
	 }
	 public boolean equals(Object o) {
		 if (!(o instanceof FloatWritable)) return false;
		 FloatWritable other = (FloatWritable)o;
		 return this.value == other.value;
	 }
	 public int hashCode() {
		 return Float.floatToIntBits(value);
	 }
	 public int compareTo(Object o) {
		 float thisValue = this.value;
		 float thatValue = ((FloatWritable)o).value;
		 return (thisValue<thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
	 }
	 public String toString() {
		 return Float.toString(value);
	 }
	 public static class Comparator extends WritableComparator {
		 public Comparator() {
			 super(FloatWritable.class);
		 }
		 public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
			 float thisValue = readFloat(b1, s1);
			 float thatValue = readFloat(b2, s2);
			 return (thisValue<thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
		 }
	 }
	 static {
		 WritableComparator.define(FloatWritable.class, new Comparator());
	 }
}",0,0,0,0
"public BigDecimal compose(ByteBuffer bytes) {
	 return JdbcDecimal.instance.compose(bytes);
 }",0,0,0,0
"public class JdbcFieldInfo extends FieldInfo{
	 private int sqlType;
	 public JdbcFieldInfo() {
	 }
	 public JdbcFieldInfo(String columnName, String pojoFieldExpression, SupportType type, int sqlType) {
		 super(columnName, pojoFieldExpression, type);
		 this.sqlType = sqlType;
	 }
	 public int getSqlType() {
		 return sqlType;
	 }
	 public void setSqlType(int sqlType) {
		 this.sqlType = sqlType;
	 }
}",0,1,0,0
"public void clear() {
	 if (length > 0) {
		 items = new Object[items.length];
		 length = 0;
		 modificationCount++;
		 if (listListeners != null) {
			 listListeners.listCleared(this);
		 }
	 }
 }",0,0,0,0
"protected boolean matchPatterns(String patterns, String pName) {
	 if (patterns == null) {
		 return false;
	 }
	 StringTokenizer exStr = new StringTokenizer(patterns, "","");
	 while (exStr.hasMoreTokens()) {
		 if (DirectoryScanner.match(exStr.nextToken(), pName)) {
			 return true;
		 }
	 }
	 return false;
 }",0,0,0,0
"interface ExchangeCreatedEvent extends ExchangeEvent {
	 default Type getType() {
		 return Type.ExchangeCreated;
	 }
 }",0,0,0,0
"public class ModifiedSelector extends BaseExtendSelector implements BuildListener, ResourceSelector {
	 private static final String CACHE_PREFIX = ""cache."";
	 private static final String ALGORITHM_PREFIX = ""algorithm."";
	 private static final String COMPARATOR_PREFIX = ""comparator."";
	 private CacheName cacheName = null;
	 private String cacheClass;
	 private AlgorithmName algoName = null;
	 private String algorithmClass;
	 private ComparatorName compName = null;
	 private String comparatorClass;
	 private boolean update = true;
	 private boolean selectDirectories = true;
	 private boolean selectResourcesWithoutInputStream = true;
	 private boolean delayUpdate = true;
	 private Comparator comparator = null;
	 private Algorithm algorithm = null;
	 private Cache cache = null;
	 private int modified = 0;
	 private boolean isConfigured = false;
	 private Vector configParameter = new Vector();
	 private Vector specialParameter = new Vector();
	 private ClassLoader myClassLoader = null;
	 private Path classpath = null;
	 public ModifiedSelector() {
	 }
	 public void verifySettings() {
		 configure();
		 if (cache == null) {
			 setError(""Cache must be set."");
		 }
		 else if (algorithm == null) {
			 setError(""Algorithm must be set."");
		 }
		 else if (!cache.isValid()) {
			 setError(""Cache must be proper configured."");
		 }
		 else if (!algorithm.isValid()) {
			 setError(""Algorithm must be proper configured."");
		 }
	 }
	 public void configure() {
		 if (isConfigured) {
			 return;
		 }
		 isConfigured = true;
		 Project p = getProject();
		 String filename = ""cache.properties"";
		 File cachefile = null;
		 if (p != null) {
			 cachefile = new File(p.getBaseDir(), filename);
			 getProject().addBuildListener(this);
		 }
		 else {
			 cachefile = new File(filename);
			 setDelayUpdate(false);
		 }
		 Cache defaultCache = new PropertiesfileCache(cachefile);
		 Algorithm defaultAlgorithm = new DigestAlgorithm();
		 Comparator defaultComparator = new EqualComparator();
		 for (Iterator itConfig = configParameter.iterator();
		 itConfig.hasNext();
		) {
			 Parameter par = (Parameter) itConfig.next();
			 if (par.getName().indexOf(""."") > 0) {
				 specialParameter.add(par);
			 }
			 else {
				 useParameter(par);
			 }
		 }
		 configParameter = new Vector();
		 if (algoName != null) {
			 if (""hashvalue"".equals(algoName.getValue())) {
				 algorithm = new HashvalueAlgorithm();
			 }
			 else if (""digest"".equals(algoName.getValue())) {
				 algorithm = new DigestAlgorithm();
			 }
			 else if (""checksum"".equals(algoName.getValue())) {
				 algorithm = new ChecksumAlgorithm();
			 }
		 }
		 else {
			 if (algorithmClass != null) {
				 algorithm = (Algorithm) loadClass( algorithmClass, ""is not an Algorithm."", Algorithm.class);
			 }
			 else {
				 algorithm = defaultAlgorithm;
			 }
		 }
		 if (cacheName != null) {
			 if (""propertyfile"".equals(cacheName.getValue())) {
				 cache = new PropertiesfileCache();
			 }
		 }
		 else {
			 if (cacheClass != null) {
				 cache = (Cache) loadClass(cacheClass, ""is not a Cache."", Cache.class);
			 }
			 else {
				 cache = defaultCache;
			 }
		 }
		 if (compName != null) {
			 if (""equal"".equals(compName.getValue())) {
				 comparator = new EqualComparator();
			 }
			 else if (""rule"".equals(compName.getValue())) {
				 throw new BuildException(""RuleBasedCollator not yet supported."");
			 }
		 }
		 else {
			 if (comparatorClass != null) {
				 comparator = (Comparator) loadClass( comparatorClass, ""is not a Comparator."", Comparator.class);
			 }
			 else {
				 comparator = defaultComparator;
			 }
		 }
		 for (Iterator itSpecial = specialParameter.iterator();
		 itSpecial.hasNext();
		) {
			 Parameter par = (Parameter) itSpecial.next();
			 useParameter(par);
		 }
		 specialParameter = new Vector();
	 }
	 protected Object loadClass(String classname, String msg, Class type) {
		 try {
			 ClassLoader cl = getClassLoader();
			 Class clazz = null;
			 if (cl != null) {
				 clazz = cl.loadClass(classname);
			 }
			 else {
				 clazz = Class.forName(classname);
			 }
			 Object rv = clazz.newInstance();
			 if (!type.isInstance(rv)) {
				 throw new BuildException(""Specified class ("" + classname + "") "" + msg);
			 }
			 return rv;
		 }
		 catch (ClassNotFoundException e) {
			 throw new BuildException(""Specified class ("" + classname + "") not found."");
		 }
		 catch (Exception e) {
			 throw new BuildException(e);
		 }
	 }
	 public boolean isSelected(Resource resource) {
		 if (resource.isFilesystemOnly()) {
			 FileResource fileResource = (FileResource) resource;
			 File file = fileResource.getFile();
			 String filename = fileResource.getName();
			 File basedir = fileResource.getBaseDir();
			 return isSelected(basedir, filename, file);
		 }
		 else {
			 try {
				 FileUtils fu = FileUtils.getFileUtils();
				 File tmpFile = fu.createTempFile(""modified-"", "".tmp"", null, true, false);
				 Resource tmpResource = new FileResource(tmpFile);
				 ResourceUtils.copyResource(resource, tmpResource);
				 boolean isSelected = isSelected(tmpFile.getParentFile(), tmpFile.getName(), resource.toLongString());
				 tmpFile.delete();
				 return isSelected;
			 }
			 catch (UnsupportedOperationException uoe) {
				 log(""The resource '"" + resource.getName() + ""' does not provide an InputStream, so it is not checked. "" + ""Akkording to 'selres' attribute value it is "" + ((selectResourcesWithoutInputStream) ? """" : "" not"") + ""selected."", Project.MSG_INFO);
				 return selectResourcesWithoutInputStream;
			 }
			 catch (Exception e) {
				 throw new BuildException(e);
			 }
		 }
	 }
	 public boolean isSelected(File basedir, String filename, File file) {
		 return isSelected(basedir, filename, file.getAbsolutePath());
	 }
	 private boolean isSelected(File basedir, String filename, String cacheKey) {
		 validate();
		 File f = new File(basedir, filename);
		 if (f.isDirectory()) {
			 return selectDirectories;
		 }
		 String cachedValue = String.valueOf(cache.get(f.getAbsolutePath()));
		 String newValue = algorithm.getValue(f);
		 boolean rv = (comparator.compare(cachedValue, newValue) != 0);
		 if (update && rv) {
			 cache.put(f.getAbsolutePath(), newValue);
			 setModified(getModified() + 1);
			 if (!getDelayUpdate()) {
				 saveCache();
			 }
		 }
		 return rv;
	 }
	 protected void saveCache() {
		 if (getModified() > 0) {
			 cache.save();
			 setModified(0);
		 }
	 }
	 public void setAlgorithmClass(String classname) {
		 algorithmClass = classname;
	 }
	 public void setComparatorClass(String classname) {
		 comparatorClass = classname;
	 }
	 public void setCacheClass(String classname) {
		 cacheClass = classname;
	 }
	 public void setUpdate(boolean update) {
		 this.update = update;
	 }
	 public void setSeldirs(boolean seldirs) {
		 selectDirectories = seldirs;
	 }
	 public void setSelres(boolean newValue) {
		 this.selectResourcesWithoutInputStream = newValue;
	 }
	 public int getModified() {
		 return modified;
	 }
	 public void setModified(int modified) {
		 this.modified = modified;
	 }
	 public boolean getDelayUpdate() {
		 return delayUpdate;
	 }
	 public void setDelayUpdate(boolean delayUpdate) {
		 this.delayUpdate = delayUpdate;
	 }
	 public void addClasspath(Path path) {
		 if (classpath != null) {
			 throw new BuildException(""<classpath> can be set only once."");
		 }
		 classpath = path;
	 }
	 public ClassLoader getClassLoader() {
		 if (myClassLoader == null) {
			 myClassLoader = (classpath == null) ? getClass().getClassLoader() : getProject().createClassLoader(classpath);
		 }
		 return myClassLoader;
	 }
	 public void setClassLoader(ClassLoader loader) {
		 myClassLoader = loader;
	 }
	 public void addParam(String key, Object value) {
		 Parameter par = new Parameter();
		 par.setName(key);
		 par.setValue(String.valueOf(value));
		 configParameter.add(par);
	 }
	 public void addParam(Parameter parameter) {
		 configParameter.add(parameter);
	 }
	 public void setParameters(Parameter[] parameters) {
		 if (parameters != null) {
			 for (int i = 0;
			 i < parameters.length;
			 i++) {
				 configParameter.add(parameters[i]);
			 }
		 }
	 }
	 public void useParameter(Parameter parameter) {
		 String key = parameter.getName();
		 String value = parameter.getValue();
		 if (""cache"".equals(key)) {
			 CacheName cn = new CacheName();
			 cn.setValue(value);
			 setCache(cn);
		 }
		 else if (""algorithm"".equals(key)) {
			 AlgorithmName an = new AlgorithmName();
			 an.setValue(value);
			 setAlgorithm(an);
		 }
		 else if (""comparator"".equals(key)) {
			 ComparatorName cn = new ComparatorName();
			 cn.setValue(value);
			 setComparator(cn);
		 }
		 else if (""update"".equals(key)) {
			 boolean updateValue = (""true"".equalsIgnoreCase(value)) ? true : false;
			 setUpdate(updateValue);
		 }
		 else if (""delayupdate"".equals(key)) {
			 boolean updateValue = (""true"".equalsIgnoreCase(value)) ? true : false;
			 setDelayUpdate(updateValue);
		 }
		 else if (""seldirs"".equals(key)) {
			 boolean sdValue = (""true"".equalsIgnoreCase(value)) ? true : false;
			 setSeldirs(sdValue);
		 }
		 else if (key.startsWith(CACHE_PREFIX)) {
			 String name = key.substring(CACHE_PREFIX.length());
			 tryToSetAParameter(cache, name, value);
		 }
		 else if (key.startsWith(ALGORITHM_PREFIX)) {
			 String name = key.substring(ALGORITHM_PREFIX.length());
			 tryToSetAParameter(algorithm, name, value);
		 }
		 else if (key.startsWith(COMPARATOR_PREFIX)) {
			 String name = key.substring(COMPARATOR_PREFIX.length());
			 tryToSetAParameter(comparator, name, value);
		 }
		 else {
			 setError(""Invalid parameter "" + key);
		 }
	 }
	 protected void tryToSetAParameter(Object obj, String name, String value) {
		 Project prj = (getProject() != null) ? getProject() : new Project();
		 IntrospectionHelper iHelper = IntrospectionHelper.getHelper(prj, obj.getClass());
		 try {
			 iHelper.setAttribute(prj, obj, name, value);
		 }
		 catch (org.apache.tools.ant.BuildException e) {
		 }
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer(""{
			modifiedselector"");
			 buf.append("" update="").append(update);
			 buf.append("" seldirs="").append(selectDirectories);
			 buf.append("" cache="").append(cache);
			 buf.append("" algorithm="").append(algorithm);
			 buf.append("" comparator="").append(comparator);
		 buf.append(""}
		"");
		 return buf.toString();
	 }
	 public void buildFinished(BuildEvent event) {
		 if (getDelayUpdate()) {
			 saveCache();
		 }
	 }
	 public void targetFinished(BuildEvent event) {
		 if (getDelayUpdate()) {
			 saveCache();
		 }
	 }
	 public void taskFinished(BuildEvent event) {
		 if (getDelayUpdate()) {
			 saveCache();
		 }
	 }
	 public void buildStarted(BuildEvent event) {
	 }
	 public void targetStarted(BuildEvent event) {
	 }
	 public void taskStarted(BuildEvent event) {
	 }
	 public void messageLogged(BuildEvent event) {
	 }
	 public Cache getCache() {
		 return cache;
	 }
	 public void setCache(CacheName name) {
		 cacheName = name;
	 }
	 public static class CacheName extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""propertyfile"" }
			;
		 }
	 }
	 public Algorithm getAlgorithm() {
		 return algorithm;
	 }
	 public void setAlgorithm(AlgorithmName name) {
		 algoName = name;
	 }
	 public static class AlgorithmName extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""hashvalue"", ""digest"", ""checksum"" }
			;
		 }
	 }
	 public Comparator getComparator() {
		 return comparator;
	 }
	 public void setComparator(ComparatorName name) {
		 compName = name;
	 }
	 public static class ComparatorName extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""equal"", ""rule"" }
			;
		 }
	 }
}",0,0,0,0
"public final class PageId extends PageReference{
	private static final long serialVersionUID = 1L;
	PageId(String pageMapName, int number, int version){
		super(pageMapName, number, version);
	}
}",0,0,0,0
"Iterator<Entry<V>> newEntryIterator(){
	return new EntryIterator();
}",0,0,0,0
"public class RFC3339Utils {
	 private static final RFC3339Utils INSTANCE = new RFC3339Utils();
	 public static RFC3339Utils getInstance() {
		 return INSTANCE;
	 }
	 private static final String BASE = ""^[0-9]{
	4}
	\\-[0-9]{
	2}
	\\-[0-9]{
	2}
	T[0-9]{
	2}
	:[0-9]{
	2}
	:[0-9]{
	2}
	"";
	 private static final String TZ = ""[+-][0-9]{
	2}
	:?[0-9]{
	2}
	$"";
	 private static final String SUB_SECOND = ""\\.([0-9]*)"";
	 private static final String UTC = ""Z$"";
	 private static final Pattern MILLIS = Pattern.compile(""^[0-9]*$"");
	 private static final Pattern UTC_STANDARD = Pattern.compile(BASE + UTC);
	 private static final Pattern UTC_SUB_SECOND = Pattern.compile(BASE + SUB_SECOND + UTC);
	 private static final Pattern LOCAL_STANDARD = Pattern.compile(BASE + TZ);
	 private static final Pattern LOCAL_SUB_SECOND = Pattern.compile(BASE + SUB_SECOND + TZ);
	 private static final String BASE_FMT = ""yyyy-MM-dd'T'HH:mm:ss"";
	 public static final DateTimeFormatter UTC_STANDARD_FMT = DateTimeFormat.forPattern(BASE_FMT + ""'Z'"").withZoneUTC();
	 public static final DateTimeFormatter UTC_SUB_SECOND_FMT = DateTimeFormat.forPattern(BASE_FMT + "".SSS'Z'"").withZoneUTC();
	 public static final DateTimeFormatter LOCAL_STANDARD_FMT = DateTimeFormat.forPattern(BASE_FMT + ""Z"").withZoneUTC();
	 public static final DateTimeFormatter LOCAL_SUB_SECOND_FMT = DateTimeFormat.forPattern(BASE_FMT + "".SSSZ"").withZoneUTC();
	 private static final DateTimeFormatter DEFAULT_FORMATTER;
	 private static final DateTimeFormatter ALT_FORMATTER;
	 static {
		 DateTimeParser[] parsers = new DateTimeParser[]{
		 DateTimeFormat.forPattern(""EEE MMM dd HH:mm:ss Z yyyy"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""EEE, dd MMM yyyy HH:mm:ss Z"").getParser(), DateTimeFormat.forPattern(""dd MMMM yyyy HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyyMMdd"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd-MM-yyyy"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyy-MM-dd"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyy/MM/dd"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd MMM yyyy"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd MMMM yyyy"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyyMMddHHmm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyyMMdd HHmm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd-MM-yyyy HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyy-MM-dd HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyy/MM/dd HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd MMM yyyy HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd MMMM yyyy HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyyMMddHHmmss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyyMMdd HHmmss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd-MM-yyyy HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyy-MM-dd HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""yyyy/MM/dd HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd MMM yyyy HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""HH:mm:ss yyyy/MM/dd"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""HH:mm:ss MM/dd/yyyy"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""HH:mm:ss yyyy-MM-dd"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""HH:mm:ss MM-dd-yyyy"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd/MM/yyyy HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd/MM/yyyy HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""dd/MM/yyyy"").withZoneUTC().getParser(), UTC_STANDARD_FMT.getParser(), UTC_SUB_SECOND_FMT.getParser(), LOCAL_STANDARD_FMT.getParser(), LOCAL_SUB_SECOND_FMT.getParser() }
		;
		 DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
		 builder.append(null, parsers);
		 DEFAULT_FORMATTER = builder.toFormatter().withZoneUTC();
		 DateTimeParser[] altParsers = new DateTimeParser[] {
		 DateTimeFormat.forPattern(""MM-dd-yyyy HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""MM/dd/yyyy HH:mm:ss"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""MM/dd/yyyy HH:mm"").withZoneUTC().getParser(), DateTimeFormat.forPattern(""MM/dd/yyyy"").withZoneUTC().getParser(), }
		;
		 builder = new DateTimeFormatterBuilder();
		 builder.append(null, altParsers);
		 ALT_FORMATTER = builder.toFormatter().withZoneUTC();
	 }
	 private RFC3339Utils() {
	}
	 public static DateTime parseUTC(String toParse) {
		 if (MILLIS.matcher(toParse).matches()) {
			 return new DateTime(Long.valueOf(toParse), DateTimeZone.UTC);
		 }
		 if (UTC_STANDARD.matcher(toParse).matches()) {
			 return parseUTC(UTC_STANDARD_FMT, toParse);
		 }
		 Matcher utc = UTC_SUB_SECOND.matcher(toParse);
		 if (utc.matches()) {
			 return parseUTC(getSubSecondFormat(utc.group(1), ""'Z'""), toParse);
		 }
		 if (LOCAL_STANDARD.matcher(toParse).matches()) {
			 return parseUTC(LOCAL_STANDARD_FMT, toParse);
		 }
		 Matcher local = LOCAL_SUB_SECOND.matcher(toParse);
		 if (local.matches()) {
			 return parseUTC(getSubSecondFormat(local.group(1), ""Z""), toParse);
		 }
		 throw new IllegalArgumentException(String.format(""Failed to parse date %s. Ensure format is RFC3339 Compliant"", toParse));
	 }
	 private static DateTime parseUTC(DateTimeFormatter formatter, String toParse) {
		 return formatter.parseDateTime(toParse);
	 }
	 public static DateTime parseToUTC(String dateString) {
		 if (MILLIS.matcher(dateString).find()) {
			 return new DateTime(Long.parseLong(dateString));
		 }
		 try {
			 return DEFAULT_FORMATTER.parseDateTime(dateString);
		 }
		 catch (Exception ex) {
			 return ALT_FORMATTER.parseDateTime(dateString);
		 }
	 }
	 public static String format(String dateString) {
		 return format(parseToUTC(dateString));
	 }
	 public static String format(DateTime toFormat) {
		 return UTC_SUB_SECOND_FMT.print(toFormat.getMillis());
	 }
	 public static String format(DateTime toFormat, TimeZone tz) {
		 return LOCAL_SUB_SECOND_FMT.withZone(DateTimeZone.forTimeZone(tz)).print(toFormat.getMillis());
	 }
	 private static DateTimeFormatter getSubSecondFormat(String sub, String suffix) {
		 DateTimeFormatter result;
		 if (sub.length() == 3) {
			 result = suffix.equals(""Z"") ? LOCAL_SUB_SECOND_FMT : UTC_SUB_SECOND_FMT;
		 }
		 else {
			 StringBuilder pattern = new StringBuilder();
			 pattern.append(BASE_FMT);
			 pattern.append(""."");
			 for (int i = 0;
			 i < sub.length();
			 i++) {
				 pattern.append(""S"");
			 }
			 pattern.append(suffix);
			 result = DateTimeFormat.forPattern(pattern.toString()).withZoneUTC();
		 }
		 return result;
	 }
}",0,0,0,0
"private static final class BytecodeClassLoader extends ClassLoader {
	public BytecodeClassLoader(ClassLoader loader) {
		super(loader);
	}
	public Class<?> loadClass(String name, byte[] bytecode) {
		return defineClass(name, bytecode, 0, bytecode.length);
	}
}",0,0,0,0
"public class NotOccurVarInArrowTypeRule extends LambdaTypeSystemRule {
	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable> var_t1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable>(createEClassifierType(basicPackage.getTypeVariable()));
	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.ArrowType> var_t2 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.ArrowType>(createEClassifierType(basicPackage.getArrowType()));
	protected TypingJudgmentEnvironment env_G = new TypingJudgmentEnvironment();
	public NotOccurVarInArrowTypeRule() {
		this(""NotOccurVarInArrow"", ""|-"", ""!-"");
	}
	public NotOccurVarInArrowTypeRule(String ruleName,String typeJudgmentSymbol, String typeStatementRelation) {
		super(ruleName, typeJudgmentSymbol, typeStatementRelation);
	}
	public Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable> getLeft() {
		return var_t1;
	}
	public Variable<org.eclipse.xsemantics.example.lambda.lambda.ArrowType> getRight() {
		return var_t2;
	}
	public TypingJudgmentEnvironment getEnvironment() {
		return env_G;
	}
	public void setEnvironment(TypingJudgmentEnvironment environment) {
		if (environment != null)env_G = environment;
	}
	public RuntimeRule newInstance() {
		return new NotOccurVarInArrowTypeRule(""NotOccurVarInArrow"", ""|-"", ""!-"");
	}
	public void applyImpl() throws RuleFailedException {
		applyNotoccurRule(env_G, var_t1, var_t2.getValue().getLeft());
		applyNotoccurRule(env_G, var_t1, var_t2.getValue().getRight());
	}
	protected String ruleFailureMessage() {
		return ""type variable "" + stringRep(var_t1.getValue().getTypevarName())+ "" occurs in ("" + stringRep(var_t2.getValue().getLeft())+ "") -> ("" + stringRep(var_t2.getValue().getRight()) + "")"";
	}
}",0,0,0,0
"public class SharedResourceRequestTargetUrlCodingStrategy extendsAbstractRequestTargetUrlCodingStrategy{
	private final String resourceKey;
	public SharedResourceRequestTargetUrlCodingStrategy(final String mountPath,final String resourceKey){
		super(mountPath);
		this.resourceKey = resourceKey;
	}
	public IRequestTarget decode(RequestParameters requestParameters){
		final String parametersFragment = requestParameters.getPath().substring(getMountPath().length());
		final ValueMap parameters = decodeParameters(parametersFragment,requestParameters.getParameters());
		requestParameters.setParameters(parameters);
		requestParameters.setResourceKey(resourceKey);
		return new SharedResourceRequestTarget(requestParameters);
	}
	public CharSequence encode(IRequestTarget requestTarget){
		if (!(requestTarget instanceof ISharedResourceRequestTarget)){
			throw new IllegalArgumentException(""This encoder can only be used with "" +""instances of "" + ISharedResourceRequestTarget.class.getName());
		}
		final AppendingStringBuffer url = new AppendingStringBuffer(40);
		url.append(getMountPath());
		final ISharedResourceRequestTarget target = (ISharedResourceRequestTarget)requestTarget;
		RequestParameters requestParameters = target.getRequestParameters();
		appendParameters(url, requestParameters.getParameters());
		return url;
	}
	public boolean matches(IRequestTarget requestTarget){
		if (requestTarget instanceof ISharedResourceRequestTarget){
			ISharedResourceRequestTarget target = (ISharedResourceRequestTarget)requestTarget;
			return target.getRequestParameters().getResourceKey().equals(resourceKey);
		}
		else{
			return false;
		}
	}
	public String getResourceKey(){
		return resourceKey;
	}
	public String toString(){
		return ""SharedResourceEncoder[key="" + resourceKey + ""]"";
	}
}",0,0,0,0
"public class AuthzAuditEventDbObj implements Serializable {
	private static final Log LOG = LogFactory.getLog(AuthzAuditEventDbObj.class);
	private static final long serialVersionUID = 1L;
	static int MaxValueLengthAccessType = 255;
	static int MaxValueLengthAclEnforcer = 255;
	static int MaxValueLengthAgentId = 255;
	static int MaxValueLengthClientIp = 255;
	static int MaxValueLengthClientType = 255;
	static int MaxValueLengthRepoName = 255;
	static int MaxValueLengthResultReason = 255;
	static int MaxValueLengthSessionId = 255;
	static int MaxValueLengthRequestUser = 255;
	static int MaxValueLengthAction = 2000;
	static int MaxValueLengthRequestData = 4000;
	static int MaxValueLengthResourcePath = 4000;
	static int MaxValueLengthResourceType = 255;
	private long auditId;
	private int repositoryType;
	private String repositoryName;
	private String user;
	private Date timeStamp;
	private String accessType;
	private String resourcePath;
	private String resourceType;
	private String action;
	private int accessResult;
	private String agentId;
	private long policyId;
	private String resultReason;
	private String aclEnforcer;
	private String sessionId;
	private String clientType;
	private String clientIP;
	private String requestData;
	private long seqNum;
	private long eventCount;
	private long eventDurationMS;
	private String tags;
	public static void init(Properties props){
		LOG.info(""AuthzAuditEventDbObj.init()"");
		final String AUDIT_DB_MAX_COLUMN_VALUE = ""xasecure.audit.destination.db.max.column.length"";
		MaxValueLengthAccessType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""access_type"", MaxValueLengthAccessType);
		logMaxColumnValue(""access_type"", MaxValueLengthAccessType);
		MaxValueLengthAclEnforcer = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""acl_enforcer"", MaxValueLengthAclEnforcer);
		logMaxColumnValue(""acl_enforcer"", MaxValueLengthAclEnforcer);
		MaxValueLengthAction = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""action"", MaxValueLengthAction);
		logMaxColumnValue(""action"", MaxValueLengthAction);
		MaxValueLengthAgentId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""agent_id"", MaxValueLengthAgentId);
		logMaxColumnValue(""agent_id"", MaxValueLengthAgentId);
		MaxValueLengthClientIp = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""client_id"", MaxValueLengthClientIp);
		logMaxColumnValue(""client_id"", MaxValueLengthClientIp);
		MaxValueLengthClientType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""client_type"", MaxValueLengthClientType);
		logMaxColumnValue(""client_type"", MaxValueLengthClientType);
		MaxValueLengthRepoName = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""repo_name"", MaxValueLengthRepoName);
		logMaxColumnValue(""repo_name"", MaxValueLengthRepoName);
		MaxValueLengthResultReason = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""result_reason"", MaxValueLengthResultReason);
		logMaxColumnValue(""result_reason"", MaxValueLengthResultReason);
		MaxValueLengthSessionId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""session_id"", MaxValueLengthSessionId);
		logMaxColumnValue(""session_id"", MaxValueLengthSessionId);
		MaxValueLengthRequestUser = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""request_user"", MaxValueLengthRequestUser);
		logMaxColumnValue(""request_user"", MaxValueLengthRequestUser);
		MaxValueLengthRequestData = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""request_data"", MaxValueLengthRequestData);
		logMaxColumnValue(""request_data"", MaxValueLengthRequestData);
		MaxValueLengthResourcePath = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""resource_path"", MaxValueLengthResourcePath);
		logMaxColumnValue(""resource_path"", MaxValueLengthResourcePath);
		MaxValueLengthResourceType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""resource_type"", MaxValueLengthResourceType);
		logMaxColumnValue(""resource_type"", MaxValueLengthResourceType);
	}
	public static void logMaxColumnValue(String columnName, int configuredMaxValueLength) {
		LOG.info(""Setting max column value for column["" + columnName + ""] to ["" + configuredMaxValueLength + ""]."");
		if (configuredMaxValueLength == 0) {
			LOG.info(""Max length of column["" + columnName + ""] was 0! Column will NOT be emitted in the audit."");
		}
		 else if (configuredMaxValueLength < 0) {
			LOG.info(""Max length of column["" + columnName + ""] was less than 0! Column value will never be truncated."");
		}
	}
	public AuthzAuditEventDbObj() {
		super();
	}
	public AuthzAuditEventDbObj(AuthzAuditEvent event) {
		super();
		Date utcDate=null;
		if(event.getEventTime()!=null){
			utcDate=MiscUtil.getUTCDateForLocalDate(event.getEventTime());
		}
		else{
			utcDate=MiscUtil.getUTCDate();
		}
		this.repositoryType = event.getRepositoryType();
		this.repositoryName = event.getRepositoryName();
		this.user = event.getUser();
		this.timeStamp = utcDate;
		this.accessType = event.getAccessType();
		this.resourcePath = event.getResourcePath();
		this.resourceType = event.getResourceType();
		this.action = event.getAction();
		this.accessResult = event.getAccessResult();
		this.agentId = event.getAgentId();
		this.policyId = event.getPolicyId();
		this.resultReason = event.getResultReason();
		this.aclEnforcer = event.getAclEnforcer();
		this.sessionId = event.getSessionId();
		this.clientType = event.getClientType();
		this.clientIP = event.getClientIP();
		this.requestData = event.getRequestData();
		this.seqNum = event.getSeqNum();
		this.eventCount = event.getEventCount();
		this.eventDurationMS= event.getEventDurationMS();
		this.tags = StringUtils.join(event.getTags(), "", "");
	}
	public long getAuditId() {
		return this.auditId;
	}
	public void setAuditId(long auditId) {
		this.auditId = auditId;
	}
	public int getRepositoryType() {
		return this.repositoryType;
	}
	public void setRepositoryType(int repositoryType) {
		this.repositoryType = repositoryType;
	}
	public String getRepositoryName() {
		return truncate(this.repositoryName, MaxValueLengthRepoName, ""repo_name"");
	}
	public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	}
	public String getUser() {
		return truncate(this.user, MaxValueLengthRequestUser, ""request_user"");
	}
	public void setUser(String user) {
		this.user = user;
	}
	public Date getTimeStamp() {
		return this.timeStamp;
	}
	public void setTimeStamp(Date timeStamp) {
		this.timeStamp = timeStamp;
	}
	public String getAccessType() {
		return truncate(this.accessType, MaxValueLengthAccessType, ""access_type"");
	}
	public void setAccessType(String accessType) {
		this.accessType = accessType;
	}
	public String getResourcePath() {
		return truncate(this.resourcePath, MaxValueLengthResourcePath, ""resource_path"");
	}
	public void setResourcePath(String resourcePath) {
		this.resourcePath = resourcePath;
	}
	public String getResourceType() {
		return truncate(this.resourceType, MaxValueLengthResourceType, ""resource_type"");
	}
	public void setResourceType(String resourceType) {
		this.resourceType = resourceType;
	}
	public String getAction() {
		return truncate(this.action, MaxValueLengthAction, ""action"");
	}
	public void setAction(String action) {
		this.action = action;
	}
	public int getAccessResult() {
		return this.accessResult;
	}
	public void setAccessResult(int accessResult) {
		this.accessResult = accessResult;
	}
	public String getAgentId() {
		return truncate(this.agentId, MaxValueLengthAgentId, ""agent_id"");
	}
	public void setAgentId(String agentId) {
		this.agentId = agentId;
	}
	public long getPolicyId() {
		return this.policyId;
	}
	public void setPolicyId(long policyId) {
		this.policyId = policyId;
	}
	public String getResultReason() {
		return truncate(this.resultReason, MaxValueLengthResultReason, ""result_reason"");
	}
	public void setResultReason(String resultReason) {
		this.resultReason = resultReason;
	}
	public String getAclEnforcer() {
		return truncate(this.aclEnforcer, MaxValueLengthAclEnforcer, ""acl_enforcer"");
	}
	public void setAclEnforcer(String aclEnforcer) {
		this.aclEnforcer = aclEnforcer;
	}
	public String getSessionId() {
		return truncate(this.sessionId, MaxValueLengthSessionId, ""session_id"");
	}
	public void setSessionId(String sessionId) {
		this.sessionId = sessionId;
	}
	public String getClientType() {
		return truncate(this.clientType, MaxValueLengthClientType, ""client_type"");
	}
	public void setClientType(String clientType) {
		this.clientType = clientType;
	}
	public String getClientIP() {
		return truncate(this.clientIP, MaxValueLengthClientIp, ""client_ip"");
	}
	public void setClientIP(String clientIP) {
		this.clientIP = clientIP;
	}
	public String getRequestData() {
		return truncate(this.requestData, MaxValueLengthRequestData, ""request_data"");
	}
	public void setRequestData(String requestData) {
		this.requestData = requestData;
	}
	public long getSeqNum() {
		 return this.seqNum;
	 }
	public void setSeqNum(long seqNum) {
		 this.seqNum = seqNum;
	 }
	public long getEventCount() {
		 return this.eventCount;
	 }
	public void setEventCount(long eventCount) {
		 this.eventCount = eventCount;
	 }
	public long getEventDurationMS() {
		 return this.eventDurationMS;
	 }
	public void setEventDurationMS(long eventDurationMS) {
		 this.eventDurationMS = eventDurationMS;
	 }
	public String getTags() {
		return this.tags;
	}
	public void setTags(String tags) {
		this.tags = tags;
	}
	static final String TruncationMarker = ""..."";
	static final int TruncationMarkerLength = TruncationMarker.length();
	protected String truncate(String value, int limit, String columnName) {
		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format(""==> getTrunctedValue(%s, %d, %s)"", value, limit, columnName));
		}
		String result = value;
		if (value != null) {
			if (limit < 0) {
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format(""Truncation is suppressed for column[%s]: old value [%s], new value[%s]"", columnName, value, result));
				}
			}
			 else if (limit == 0) {
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format(""Column[%s] is to be excluded from audit: old value [%s], new value[%s]"", columnName, value, result));
				}
				result = null;
			}
			 else {
				if (value.length() > limit) {
					if (limit <= TruncationMarkerLength) {
						result = value.substring(0, limit);
					}
					 else {
						StringBuilder sb = new StringBuilder(value.substring(0, limit - TruncationMarkerLength));
						sb.append(TruncationMarker);
						result = sb.toString();
					}
					if (LOG.isDebugEnabled()) {
						LOG.debug(String.format(""Truncating value for column[%s] to [%d] characters: old value [%s], new value[%s]"", columnName, limit, value, result));
					}
				}
			}
		}
		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format(""<== getTrunctedValue(%s, %d, %s): %s"", value, limit, columnName, result));
		}
		return result;
	}
}",1,1,0,0
"public class Z extends Y {
	public int publicMethod() {
		return 3;
	}
	private void privateMethod() {
	}
	char defaultMethod() {
		return 'c';
	}
	protected long protectedMethod() {
		return 300;
	}
}",0,0,0,0
"protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint);",0,0,0,1
"public class WebMailSession implements HTTPSession {
	 private long last_access;
	 private String session_code;
	 private WebMailServer parent;
	 private XMLUserData user;
	 private XMLUserModel model;
	 private Hashtable connections;
	 private Hashtable stores;
	 private Session mailsession;
	 private InetAddress remote;
	 private Hashtable mime_parts_decoded;
	 private boolean sent;
	 private String remote_agent;
	 private String remote_accepts;
	 private int attachments_size=0;
	 private String last_login;
	 private String login_password;
	 private Object sess=null;
	 private Hashtable folders;
	 protected Vector need_expunge_folders;
	 protected boolean is_logged_out=false;
	 public WebMailSession(WebMailServer parent,Object parm,HTTPRequestHeader h) throws UserDataException, InvalidPasswordException, WebMailException {
		try {
			 Class srvltreq=Class.forName(""javax.servlet.http.HttpServletRequest"");
			 if(srvltreq.isInstance(parm)) {
				javax.servlet.http.HttpServletRequest req=(javax.servlet.http.HttpServletRequest)parm;
				this.sess=req.getSession(false);
				session_code=((javax.servlet.http.HttpSession)sess).getId();
				try {
					 remote=InetAddress.getByName(req.getRemoteHost());
				}
				 catch(UnknownHostException e) {
					 try {
						remote=InetAddress.getByName(req.getRemoteAddr());
					 }
					 catch(Exception ex) {
						try {
							 remote=InetAddress.getByName(""localhost"");
						}
						 catch(Exception ex2) {
						}
					 }
				}
			 }
			 else {
				throw new Exception(""Servlet class found but not running as servlet"");
			 }
		}
		 catch(Throwable t) {
			 this.remote=(InetAddress)parm;
			 session_code=Helper.calcSessionCode(remote,h);
		}
		doInit(parent,h);
	 }
	 protected void doInit(WebMailServer parent, HTTPRequestHeader h) throws UserDataException, InvalidPasswordException, WebMailException {
		setLastAccess();
		this.parent=parent;
		remote_agent=h.getHeader(""User-Agent"").replace('\n',' ');
		remote_accepts=h.getHeader(""Accept"").replace('\n',' ');
		parent.getStorage().log(Storage.LOG_INFO,""WebMail: New Session (""+session_code+"")"");
		user=WebMailServer.getStorage().getUserData(h.getContent(""login""),h.getContent(""vdom""),h.getContent(""password""),true);
		 last_login=user.getLastLogin();
		user.login();
		login_password=h.getContent(""password"");
		model=parent.getStorage().createXMLUserModel(user);
		connections=new Hashtable();
		stores=new Hashtable();
		folders=new Hashtable();
		mailsession=Session.getDefaultInstance(System.getProperties(),null);
		if(user.getLoginCount().equals(""1"")) {
			 Enumeration enum=user.mailHosts();
			 while(enum.hasMoreElements()) {
				String id=(String)enum.nextElement();
				if(user.getMailHost(id).getName().equals(""Default"")) {
					 try {
						setSubscribedAll(id,true);
					 }
					 catch(MessagingException ex) {
						ex.printStackTrace();
					 }
					 break;
				}
			 }
		}
		setEnv();
	 }
	 public XMLUserModel getUserModel() {
		return model;
	 }
	 public Document getModel() {
		return model.getRoot();
	 }
	 public String calcCode(InetAddress a, HTTPRequestHeader h) {
		if(sess==null) {
			 return Helper.calcSessionCode(a,h);
		}
		 else {
			 try {
				Class srvltreq=Class.forName(""javax.servlet.http.HttpSession"");
				if(srvltreq.isInstance(sess)) {
					 return ((javax.servlet.http.HttpSession)sess).getId();
				}
				 else {
					 return ""error"";
				}
			 }
			 catch(Throwable t) {
				return ""error"";
			 }
		}
	 }
	 public void login(HTTPRequestHeader h) throws InvalidPasswordException {
		login();
	 }
	 public void login() {
		setLastAccess();
		setEnv();
		connectAll();
	 }
	 public String getStringResource(String key) {
		return parent.getStorage().getStringResource(key,user.getPreferredLocale());
	 }
	 public void createMessageList(String folderhash,int list_part) throws NoSuchFolderException {
		long time_start=System.currentTimeMillis();
		TimeZone tz=TimeZone.getDefault();
		DateFormat df=DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.SHORT, user.getPreferredLocale());
		df.setTimeZone(tz);
		try {
			 Folder folder=getFolder(folderhash);
			 Element xml_folder=model.getFolder(folderhash);
			 Element xml_current=model.setCurrentFolder(folderhash);
			 Element xml_messagelist=model.getMessageList(xml_folder);
			 if(folder == null) {
				throw new NoSuchFolderException(folderhash);
			 }
			 long fetch_start=System.currentTimeMillis();
			 if(!folder.isOpen()) {
				folder.open(Folder.READ_ONLY);
			 }
			 else {
				folder.close(false);
				folder.open(Folder.READ_ONLY);
			 }
			 int total_messages=folder.getMessageCount();
			 int new_messages=folder.getNewMessageCount();
			 int show_msgs=user.getMaxShowMessages();
			 xml_messagelist.setAttribute(""total"",total_messages+"""");
			 xml_messagelist.setAttribute(""new"",new_messages+"""");
			 if(total_messages < show_msgs) {
				show_msgs = total_messages;
			 }
			 if(list_part < 1) {
				list_part=1;
			 }
			 for(int k=0;
			k<list_part;
			k++) {
				total_messages-=show_msgs;
			 }
			 if(total_messages<0) {
				total_messages=0;
			 }
			 int first=total_messages+1;
			 int last=total_messages+show_msgs;
			 setEnv();
			 xml_current.setAttribute(""first_msg"",first+"""");
			 xml_current.setAttribute(""last_msg"",last+"""");
			 xml_current.setAttribute(""list_part"",list_part+"""");
			 FetchProfile fp=new FetchProfile();
			 fp.add(FetchProfile.Item.ENVELOPE);
			 fp.add(FetchProfile.Item.FLAGS);
			 fp.add(FetchProfile.Item.CONTENT_INFO);
			 Message[] msgs=folder.getMessages(first,last);
			 folder.fetch(msgs,fp);
			 long fetch_stop=System.currentTimeMillis();
			 Hashtable header=new Hashtable(15);
			 Flags.Flag[] sf;
			 String from,to,cc,bcc,replyto,subject;
			 String messageid;
			 for(int i=msgs.length-1;
			 i>=0;
			 i--) {
				try {
					 StringTokenizer tok=new StringTokenizer(((MimeMessage)msgs[i]).getMessageID(),""<>"");
					 messageid=tok.nextToken();
				}
				 catch(NullPointerException ex) {
					 messageid=user.getLogin()+"".""+i+"".jwebmail@""+user.getDomain();
				}
				 XMLMessage xml_message=model.getMessage(xml_folder,msgs[i].getMessageNumber()+"""", messageid);
				from="""";
				replyto="""";
				to="""";
				cc="""";
				bcc="""";
				try {
					 from=MimeUtility.decodeText(Helper.joinAddress(msgs[i].getFrom()));
					 replyto=MimeUtility.decodeText(Helper.joinAddress(msgs[i].getReplyTo()));
					 to=MimeUtility.decodeText(Helper.joinAddress(msgs[i].getRecipients(Message.RecipientType.TO)));
					 cc=MimeUtility.decodeText(Helper.joinAddress(msgs[i].getRecipients(Message.RecipientType.CC)));
					 bcc=MimeUtility.decodeText(Helper.joinAddress(msgs[i].getRecipients(Message.RecipientType.BCC)));
				}
				 catch(UnsupportedEncodingException e) {
					 parent.getStorage().log(Storage.LOG_WARN,""Unsupported Encoding: ""+e.getMessage());
				}
				if(from=="""") from=getStringResource(""unknown sender"");
				if(to == """") to = getStringResource(""unknown recipient"");
				 sf = msgs[i].getFlags().getSystemFlags();
				String basepath=parent.getBasePath();
				for(int j=0;
				j<sf.length;
				j++) {
					 if(sf[j]==Flags.Flag.RECENT) xml_message.setAttribute(""recent"",""true"");
					 if(sf[j]==Flags.Flag.SEEN) xml_message.setAttribute(""seen"",""true"");
					 if(sf[j]==Flags.Flag.DELETED) xml_message.setAttribute(""deleted"",""true"");
					 if(sf[j]==Flags.Flag.ANSWERED) xml_message.setAttribute(""answered"",""true"");
					 if(sf[j]==Flags.Flag.DRAFT) xml_message.setAttribute(""draft"",""true"");
					 if(sf[j]==Flags.Flag.FLAGGED) xml_message.setAttribute(""flagged"",""true"");
					 if(sf[j]==Flags.Flag.USER) xml_message.setAttribute(""user"",""true"");
				}
				if(msgs[i] instanceof MimeMessage && ((MimeMessage) msgs[i]).getContentType().toUpperCase().startsWith(""MULTIPART/"")) {
					 xml_message.setAttribute(""attachment"",""true"");
				}
				if(msgs[i] instanceof MimeMessage) {
					 int size=((MimeMessage) msgs[i]).getSize();
					 size/=1024;
					 xml_message.setAttribute(""size"",(size>0?size+"""":""<1"")+"" kB"");
				}
				subject="""";
				if(msgs[i].getSubject() != null) {
					 try {
						subject=MimeUtility.decodeText(msgs[i].getSubject());
					 }
					 catch(UnsupportedEncodingException ex) {
						parent.getStorage().log(Storage.LOG_WARN,""Unsupported Encoding: ""+ex.getMessage());
					 }
				}
				if(subject == null || subject.equals("""")) {
					 subject=getStringResource(""no subject"");
				}
				xml_message.setHeader(""FROM"",from);
				try {
					 xml_message.setHeader(""SUBJECT"",MimeUtility.decodeText(subject));
				}
				 catch(UnsupportedEncodingException e) {
					 parent.getStorage().log(Storage.LOG_WARN, ""Unsupported Encoding: ""+e.getMessage());
				}
				xml_message.setHeader(""TO"",to);
				xml_message.setHeader(""CC"",cc);
				xml_message.setHeader(""BCC"",bcc);
				xml_message.setHeader(""REPLY-TO"",replyto);
				Date d=msgs[i].getSentDate();
				String ds="""";
				if(d!=null) {
					 ds=df.format(d);
				}
				xml_message.setHeader(""DATE"",ds);
			 }
			 long time_stop=System.currentTimeMillis();
			 parent.getStorage().log(Storage.LOG_DEBUG,""Construction of message list took ""+(time_stop-time_start)+"" ms. Time for IMAP transfer was ""+(fetch_stop-fetch_start)+"" ms."");
			 folder.close(false);
		}
		 catch(NullPointerException e) {
			 e.printStackTrace();
			 throw new NoSuchFolderException(folderhash);
		}
		 catch(MessagingException ex) {
			 ex.printStackTrace();
		}
	 }
	 public static final int GETMESSAGE_MODE_STANDARD=0;
	 public static final int GETMESSAGE_MODE_REPLY=1;
	 public static final int GETMESSAGE_MODE_FORWARD=2;
	 public void getMessage(String folderhash, int msgnum) throws NoSuchFolderException {
		getMessage(folderhash,msgnum,GETMESSAGE_MODE_STANDARD);
	 }
	 public void getMessage(String folderhash, int msgnum, int mode) throws NoSuchFolderException {
		try {
			 TimeZone tz=TimeZone.getDefault();
			 DateFormat df=DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.SHORT, user.getPreferredLocale());
			 df.setTimeZone(tz);
			 Folder folder=getFolder(folderhash);
			 Element xml_folder=model.getFolder(folderhash);
			 if(folder==null) {
				throw new NoSuchFolderException(""No such folder: ""+folderhash);
			 }
			 if(folder.isOpen() && folder.getMode()==Folder.READ_WRITE) {
				folder.close(false);
				folder.open(Folder.READ_ONLY);
			 }
			 else if(!folder.isOpen()) {
				folder.open(Folder.READ_ONLY);
			 }
			 MimeMessage m=(MimeMessage)folder.getMessage(msgnum);
			 String messageid;
			 try {
				StringTokenizer tok=new StringTokenizer(m.getMessageID(),""<>"");
				messageid=tok.nextToken();
			 }
			 catch(NullPointerException ex) {
				messageid=user.getLogin()+"".""+msgnum+"".jwebmail@""+user.getDomain();
			 }
			 Element xml_current=model.setCurrentMessage(messageid);
			 XMLMessage xml_message=model.getMessage(xml_folder,m.getMessageNumber()+"""", messageid);
			 boolean cached=xml_message.messageCompletelyCached();
			 if(!cached) {
				try {
					 String from=MimeUtility.decodeText(Helper.joinAddress(m.getFrom()));
					 String replyto=MimeUtility.decodeText(Helper.joinAddress(m.getReplyTo()));
					 String to=MimeUtility.decodeText(Helper.joinAddress(m.getRecipients(Message.RecipientType.TO)));
					 String cc=MimeUtility.decodeText(Helper.joinAddress(m.getRecipients(Message.RecipientType.CC)));
					 String bcc=MimeUtility.decodeText(Helper.joinAddress(m.getRecipients(Message.RecipientType.BCC)));
					 Date date_orig=m.getSentDate();
					 String date=getStringResource(""no date"");
					 if(date_orig!=null) {
						date=df.format(date_orig);
					 }
					 String subject="""";
					 if(m.getSubject() != null) {
						subject=MimeUtility.decodeText(m.getSubject());
					 }
					 if(subject == null || subject.equals("""")) {
						subject=getStringResource(""no subject"");
					 }
					 try {
						Flags.Flag[] sf = m.getFlags().getSystemFlags();
						for(int j=0;
						j<sf.length;
						j++) {
							 if(sf[j]==Flags.Flag.RECENT) xml_message.setAttribute(""recent"",""true"");
							 if(sf[j]==Flags.Flag.SEEN) xml_message.setAttribute(""seen"",""true"");
							 if(sf[j]==Flags.Flag.DELETED) xml_message.setAttribute(""deleted"",""true"");
							 if(sf[j]==Flags.Flag.ANSWERED) xml_message.setAttribute(""answered"",""true"");
							 if(sf[j]==Flags.Flag.DRAFT) xml_message.setAttribute(""draft"",""true"");
							 if(sf[j]==Flags.Flag.FLAGGED) xml_message.setAttribute(""flagged"",""true"");
							 if(sf[j]==Flags.Flag.USER) xml_message.setAttribute(""user"",""true"");
						}
					 }
					 catch(NullPointerException ex) {
					}
					 if(m.getContentType().toUpperCase().startsWith(""MULTIPART/"")) {
						xml_message.setAttribute(""attachment"",""true"");
					 }
					 int size=m.getSize();
					 size/=1024;
					 xml_message.setAttribute(""size"",(size>0?size+"""":""<1"")+"" kB"");
					 xml_message.setHeader(""FROM"",from);
					 xml_message.setHeader(""SUBJECT"",Fancyfier.apply(subject));
					 xml_message.setHeader(""TO"",to);
					 xml_message.setHeader(""CC"",cc);
					 xml_message.setHeader(""BCC"",bcc);
					 xml_message.setHeader(""REPLY-TO"",replyto);
					 xml_message.setHeader(""DATE"",date);
					 xml_message.removeAllParts();
					 parseMIMEContent(m,xml_message,messageid);
				}
				 catch(UnsupportedEncodingException e) {
					 parent.getStorage().log(Storage.LOG_WARN,""Unsupported Encoding in parseMIMEContent: ""+e.getMessage());
					 System.err.println(""Unsupported Encoding in parseMIMEContent: ""+e.getMessage());
				}
			 }
			 if(user.wantsSetFlags()) {
				if(folder.isOpen() && folder.getMode()==Folder.READ_ONLY) {
					 folder.close(false);
					 folder.open(Folder.READ_WRITE);
				}
				 else if(!folder.isOpen()) {
					 folder.open(Folder.READ_WRITE);
				}
				folder.setFlags(msgnum,msgnum,new Flags(Flags.Flag.SEEN),true);
				folder.setFlags(msgnum,msgnum,new Flags(Flags.Flag.RECENT), false);
				if((mode & GETMESSAGE_MODE_REPLY) == GETMESSAGE_MODE_REPLY) {
					 folder.setFlags(msgnum,msgnum,new Flags(Flags.Flag.ANSWERED),true);
				}
			 }
			 folder.close(false);
			 XMLMessage work=null;
			 if((mode & GETMESSAGE_MODE_REPLY) == GETMESSAGE_MODE_REPLY || (mode & GETMESSAGE_MODE_FORWARD) == GETMESSAGE_MODE_FORWARD) {
				work=model.setWorkMessage(xml_message);
				String newmsgid=WebMailServer.generateMessageID(user.getUserName());
				if(work != null && (mode & GETMESSAGE_MODE_REPLY) == GETMESSAGE_MODE_REPLY) {
					 String from=work.getHeader(""FROM"");
					 work.setHeader(""FROM"",user.getEmail());
					 work.setHeader(""TO"",from);
					 work.prepareReply(getStringResource(""reply subject prefix""), getStringResource(""reply subject postfix""), getStringResource(""reply message prefix""), getStringResource(""reply message postfix""));
				}
				 else if(work != null && (mode & GETMESSAGE_MODE_FORWARD) == GETMESSAGE_MODE_FORWARD) {
					 String from=work.getHeader(""FROM"");
					 work.setHeader(""FROM"",user.getEmail());
					 work.setHeader(""TO"","""");
					 work.setHeader(""CC"","""");
					 work.prepareForward(getStringResource(""forward subject prefix""), getStringResource(""forward subject postfix""),getStringResource(""forward message prefix""),getStringResource(""forward message postfix""));
					 Enumeration attids=getMimeParts(work.getAttribute(""msgid""));
					 while(attids.hasMoreElements()) {
						String key=(String)attids.nextElement();
						StringTokenizer tok2=new StringTokenizer(key,""/"");
						tok2.nextToken();
						String newkey=tok2.nextToken();
						mime_parts_decoded.put(newmsgid+""/""+newkey,mime_parts_decoded.get(key));
					 }
				}
				work.setAttribute(""msgnr"",""0"");
				work.setAttribute(""msgid"",newmsgid);
				prepareCompose();
			 }
		}
		 catch(MessagingException ex) {
			 ex.printStackTrace();
		}
	 }
	 protected void parseMIMEContent(Part p, XMLMessagePart parent_part, String msgid) throws MessagingException {
		StringBuffer content=new StringBuffer(1000);
		 XMLMessagePart xml_part;
		try {
			 if(p.getContentType().toUpperCase().startsWith(""TEXT/HTML"")) {
				xml_part=parent_part.createPart(""html"");
				org.cyberneko.html.parsers.DOMParser parser = new org.cyberneko.html.parsers.DOMParser();
				parser.parse(new InputSource(p.getInputStream()));
				Document htmldoc = parser.getDocument();
				new JavaScriptCleaner(htmldoc);
				xml_part.addContent(htmldoc);
			 }
			 else if(p.getContentType().toUpperCase().startsWith(""TEXT"") || p.getContentType().toUpperCase().startsWith(""MESSAGE"")) {
				xml_part=parent_part.createPart(""text"");
				System.err.println(""text hit"");
				BufferedReader in;
				if(p instanceof MimeBodyPart) {
					 int size=p.getSize();
					 MimeBodyPart mpb=(MimeBodyPart)p;
					 InputStream is=mpb.getInputStream();
					 is=new BufferedInputStream(is);
					 ByteStore ba=ByteStore.getBinaryFromIS(is,size);
					 in=new BufferedReader(new InputStreamReader(new ByteArrayInputStream(ba.getBytes())));
					 size=is.available();
				}
				 else {
					 in=new BufferedReader(new InputStreamReader(p.getInputStream()));
				}
				String token="""";
				int quote_level=0, old_quotelevel=0;
				boolean javascript_mode=false;
				while((token=in.readLine()) != null) {
					 String charset=""ISO-8859-1"";
					 StringTokenizer tok2=new StringTokenizer(p.getContentType(),"";
					="");
					 String blah=tok2.nextToken();
					 if(tok2.hasMoreTokens()) {
						blah=tok2.nextToken().trim();
						if(blah.toLowerCase().equals(""charset"") && tok2.hasMoreTokens()) {
							 charset=tok2.nextToken().trim();
						}
					 }
					 try {
						 token=new String(token.getBytes(),charset);
					 }
					 catch(UnsupportedEncodingException ex1) {
						 parent.getStorage().log(Storage.LOG_INFO,""Java Engine does not support charset ""+charset+"". Trying to convert from MIME ..."");
						 try {
							 charset=MimeUtility.javaCharset(charset);
							 token=new String(token.getBytes(),charset);
						 }
						 catch(UnsupportedEncodingException ex) {
							 parent.getStorage().log(Storage.LOG_WARN,""Converted charset (""+charset+"") does not work. Using default charset (ouput may contain errors)"");
							 token=new String(token.getBytes());
						 }
					 }
					 int current_quotelevel=Helper.getQuoteLevel(token);
					 if(current_quotelevel != old_quotelevel) {
						xml_part.addContent(content.toString(),old_quotelevel);
						old_quotelevel = current_quotelevel;
						content=new StringBuffer(1000);
					 }
					 if(user.wantsBreakLines()) {
						Enumeration enum=Helper.breakLine(token,user.getMaxLineLength(),current_quotelevel);
						while(enum.hasMoreElements()) {
							 String s=(String)enum.nextElement();
							 if(user.wantsShowFancy()) {
								content.append(Fancyfier.apply(s)).append(""\n"");
							 }
							 else {
								content.append(s).append(""\n"");
							 }
						}
					 }
					 else {
						if(user.wantsShowFancy()) {
							 content.append(Fancyfier.apply(token)).append(""\n"");
						}
						 else {
							 content.append(token).append(""\n"");
						}
					 }
				}
				xml_part.addContent(content.toString(),old_quotelevel);
				content=new StringBuffer(1000);
			 }
			 else if(p.getContentType().toUpperCase().startsWith(""MULTIPART/ALTERNATIVE"")) {
				MimeMultipart m=(MimeMultipart)p.getContent();
				String[] preferred={
				""TEXT/HTML"",""TEXT""}
				;
				boolean found=false;
				int alt=0;
				while (alt < preferred.length) {
					 for(int i=0;
					i<m.getCount();
					i++) {
						Part p2=m.getBodyPart(i);
						if(p2.getContentType().toUpperCase().startsWith(preferred[alt])) {
							 System.err.println(""Processing: "" + p2.getContentType());
							 parseMIMEContent(p2,parent_part,msgid);
							 found=true;
							 break;
						}
					 }
					 if (found && (alt == 1)) {
						Node textPartNode = parent_part.getPartElement().getLastChild();
						NamedNodeMap attributes = textPartNode.getAttributes();
						boolean hit = false;
						for (int i = 0;
						 i < attributes.getLength();
						 ++i) {
							 Node attr = attributes.item(i);
							 if (attr.getNodeName().toUpperCase().equals(""TYPE"") && attr.getNodeValue().toUpperCase().equals(""TEXT"")) {
								((Element)textPartNode).setAttribute(""hidden"", ""true"");
							 }
						}
					 }
					 alt++;
				}
				if(!found) {
					 parseMIMEContent(m.getBodyPart(0),parent_part,msgid);
				}
			 }
			 else if(p.getContentType().toUpperCase().startsWith(""MULTIPART/"")) {
				xml_part=parent_part.createPart(""multi"");
				MimeMultipart m=(MimeMultipart)p.getContent();
				for(int i=0;
				i<m.getCount();
				i++) {
					 parseMIMEContent(m.getBodyPart(i),xml_part,msgid);
				}
			 }
			 else {
				InputStream in=null;
				String type="""";
				if(p.getContentType().toUpperCase().startsWith(""IMAGE/JPG"") || p.getContentType().toUpperCase().startsWith(""IMAGE/JPEG"")) {
					 type=""jpg"";
					 xml_part=parent_part.createPart(""image"");
				}
				 else if(p.getContentType().toUpperCase().startsWith(""IMAGE/GIF"")) {
					 type=""gif"";
					 xml_part=parent_part.createPart(""image"");
				}
				 else if(p.getContentType().toUpperCase().startsWith(""IMAGE/PNG"")) {
					 type=""png"";
					 xml_part=parent_part.createPart(""image"");
				}
				 else {
					 xml_part=parent_part.createPart(""binary"");
				}
				int size=p.getSize();
				if(p instanceof MimeBodyPart) {
					 MimeBodyPart mpb=(MimeBodyPart)p;
					 System.err.println(""MIME Body part (image), Encoding: ""+mpb.getEncoding());
					 InputStream is=mpb.getInputStream();
					 in=new BufferedInputStream(is);
					 ByteStore ba=ByteStore.getBinaryFromIS(in,size);
					 in=new ByteArrayInputStream(ba.getBytes());
					 size=in.available();
				}
				 else {
					 System.err.println(""*** No MIME Body part!! ***"");
					 in=p.getInputStream();
				}
				ByteStore data=ByteStore.getBinaryFromIS(in,size);
				if(mime_parts_decoded==null) {
					 mime_parts_decoded=new Hashtable();
				}
				String name=p.getFileName();
				if(name == null || name.equals("""")) {
					 name=""unknown.""+type;
				}
				try {
					name = MimeUtility.decodeText(name);
				}
				 catch (Exception e) {
					System.err.println(e);
				}
				name=name.replace(' ','_');
				data.setContentType(p.getContentType());
				data.setContentEncoding(""BINARY"");
				mime_parts_decoded.put(msgid+""/""+name,data);
				data.setName(name);
				xml_part.setAttribute(""filename"",name);
				xml_part.setAttribute(""hrefFileName"", URLEncoder.encode(new String(name.getBytes(""UTF-8""), ""ISO8859_1"")));
				xml_part.setAttribute(""size"",size+"""");
				String description=p.getDescription()==null?"""":p.getDescription();
				xml_part.setAttribute(""description"",description);
				StringTokenizer tok=new StringTokenizer(p.getContentType(),"";
				"");
				xml_part.setAttribute(""content-type"",tok.nextToken().toLowerCase());
			 }
		}
		 catch(java.io.IOException ex) {
			 ex.printStackTrace();
		}
		 catch(MessagingException ex) {
			 throw ex;
		}
		 catch(Exception ex) {
			 ex.printStackTrace();
		}
	 }
	 public ByteStore getMIMEPart(String msgid,String name) {
		if(mime_parts_decoded != null) {
			 return (ByteStore)mime_parts_decoded.get(msgid+""/""+name);
		}
		 else {
			 return null;
		}
	 }
	 public Enumeration getMimeParts(String msgid) {
		if(mime_parts_decoded == null) {
			 mime_parts_decoded=new Hashtable();
		}
		Enumeration enum=mime_parts_decoded.keys();
		 Vector v=new Vector();
		while(enum.hasMoreElements()) {
			 String key=(String)enum.nextElement();
			 if(key.startsWith(msgid)) {
				v.addElement(key);
			 }
		}
		return v.elements();
	 }
	 public void clearWork() {
		clearAttachments();
		model.clearWork();
	 }
	 public void prepareCompose() {
		model.getWorkMessage().getFirstMessageTextPart().addContent(""\n--\n"",0);
		model.getWorkMessage().getFirstMessageTextPart().addContent(user.getSignature(),0);
	 }
	 public void clearAttachments() {
		attachments_size=0;
		XMLMessage xml_message=model.getWorkMessage();
		String msgid=xml_message.getAttribute(""msgid"");
		Enumeration enum=getMimeParts(msgid);
		attachments_size=0;
		while(enum.hasMoreElements()) {
			 mime_parts_decoded.remove((String)enum.nextElement());
		}
	 }
	 public Hashtable getAttachments() {
		Hashtable hash=new Hashtable();
		XMLMessage xml_message=model.getWorkMessage();
		String msgid=xml_message.getAttribute(""msgid"");
		Enumeration enum=getMimeParts(msgid);
		while(enum.hasMoreElements()) {
			 String key=(String)enum.nextElement();
			 String filename=key.substring(msgid.length()+1);
			 hash.put(filename,mime_parts_decoded.get(key));
		}
		return hash;
	 }
	 public ByteStore getAttachment(String key) {
		XMLMessage xml_message=model.getWorkMessage();
		String msgid=xml_message.getAttribute(""msgid"");
		return getMIMEPart(msgid,key);
	 }
	 public void addWorkAttachment(String name, ByteStore bs, String description) throws WebMailException {
		XMLMessage xml_message=model.getWorkMessage();
		XMLMessagePart xml_multipart=xml_message.getFirstMessageMultiPart();
		String msgid=xml_message.getAttribute(""msgid"");
		bs.setDescription(description);
		Enumeration enum=getMimeParts(msgid);
		attachments_size=0;
		while(enum.hasMoreElements()) {
			 ByteStore b=(ByteStore)mime_parts_decoded.get((String)enum.nextElement());
			 attachments_size+=b.getSize();
		}
		int max_size=0;
		try {
			 max_size=Integer.parseInt( parent.getStorage().getConfig(""MAX ATTACH SIZE""));
		}
		 catch(NumberFormatException e) {
			 parent.getStorage().log(Storage.LOG_WARN,""Invalid setting for parameter \""MAX ATTACH SIZE\"". Must be a number!"");
		}
		if(attachments_size+bs.getSize() > max_size) {
			 throw new WebMailException(""Attachments are too big. The sum of the sizes may not exceed ""+max_size+"" bytes."");
		}
		 else {
			 mime_parts_decoded.put(msgid+""/""+name,bs);
			 attachments_size+=bs.getSize();
			 XMLMessagePart xml_part=xml_multipart.createPart(""binary"");
			 xml_part.setAttribute(""filename"",name);
			 xml_part.setAttribute(""size"",bs.getSize()+"""");
			 xml_part.setAttribute(""description"",description);
			 xml_part.setAttribute(""content-type"",bs.getContentType().toLowerCase());
		}
		setEnv();
	 }
	 public void removeWorkAttachment(String name) {
		XMLMessage xml_message=model.getWorkMessage();
		XMLMessagePart xml_multipart=xml_message.getFirstMessageMultiPart();
		String msgid=xml_message.getAttribute(""msgid"");
		mime_parts_decoded.remove(msgid+""/""+name);
		Enumeration enum=getMimeParts(msgid);
		attachments_size=0;
		while(enum.hasMoreElements()) {
			 ByteStore b=(ByteStore)mime_parts_decoded.get((String)enum.nextElement());
			 attachments_size+=b.getSize();
		}
		enum=xml_multipart.getParts();
		XMLMessagePart oldpart=null;
		while(enum.hasMoreElements()) {
			 XMLMessagePart tmp=(XMLMessagePart)enum.nextElement();
			 if(tmp.getAttribute(""filename"") != null && tmp.getAttribute(""filename"").equals(name)) {
				oldpart=tmp;
				break;
			 }
		}
		if(oldpart != null) {
			 xml_multipart.removePart(oldpart);
		}
		setEnv();
	 }
	 public void storeMessage(HTTPRequestHeader head) {
		XMLMessage xml_message=model.getWorkMessage();
		XMLMessagePart xml_textpart=xml_message.getFirstMessageTextPart();
		if(head.isContentSet(""BODY"")) {
			 StringBuffer content=new StringBuffer();
			String bodyString;
			try {
				bodyString = new String(head.getContent(""BODY"").getBytes(""ISO8859_1""), ""UTF-8"");
			}
			 catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				bodyString = head.getContent(""BODY"");
			}
			 if(user.wantsBreakLines()) {
				StringTokenizer tok=new StringTokenizer(bodyString,""\n"");
				while(tok.hasMoreTokens()) {
					 String line=tok.nextToken();
					 Enumeration enum=Helper.breakLine(line,user.getMaxLineLength(), Helper.getQuoteLevel(line));
					 while(enum.hasMoreElements()) {
						 content.append((String)enum.nextElement()).append('\n');
					 }
				}
			 }
			 else {
				content.append(bodyString);
			 }
			 xml_textpart.removeAllContent();
			 xml_textpart.addContent(content.toString(),0);
		}
		if(head.isContentSet(""TO"")) {
			 try {
				xml_message.setHeader(""TO"", new String(head.getContent(""TO"").getBytes(""ISO8859_1""), ""UTF-8""));
			}
			 catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				xml_message.setHeader(""TO"",head.getContent(""TO""));
			}
		}
		if(head.isContentSet(""CC"")) {
			 try {
				xml_message.setHeader(""CC"", new String(head.getContent(""CC"").getBytes(""ISO8859_1""), ""UTF-8""));
			}
			 catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				xml_message.setHeader(""CC"",head.getContent(""CC""));
			}
		}
		if(head.isContentSet(""BCC"")) {
			 try {
				xml_message.setHeader(""BCC"", new String(head.getContent(""BCC"").getBytes(""ISO8859_1""), ""UTF-8""));
			}
			 catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				xml_message.setHeader(""BCC"",head.getContent(""BCC""));
			}
		}
		if(head.isContentSet(""REPLY-TO"")) {
			 try {
				xml_message.setHeader(""REPLY-TO"", new String(head.getContent(""REPLY-TO"").getBytes(""ISO8859_1""), ""UTF-8""));
			}
			 catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				xml_message.setHeader(""REPLY-TO"",head.getContent(""REPLY-TO""));
			}
		}
		if(head.isContentSet(""SUBJECT"")) {
			 try {
				xml_message.setHeader(""SUBJECT"", new String(head.getContent(""SUBJECT"").getBytes(""ISO8859_1""), ""UTF-8""));
			}
			 catch (UnsupportedEncodingException e) {
				e.printStackTrace();
				xml_message.setHeader(""SUBJECT"",head.getContent(""SUBJECT""));
			}
		}
		setEnv();
	 }
	 public void connectAll() {
		refreshFolderInformation();
	 }
	 public Folder getChildFolder(Folder root, String folderhash) {
		return getFolder(folderhash);
	 }
	 public Folder getFolder(String folderhash) {
		return (Folder)folders.get(folderhash);
	 }
	 protected String generateFolderHash(Folder folder) {
		String id=Integer.toHexString(folder.hashCode());
		try {
			 MD5 md5=new MD5(folder.getURLName());
			 id=md5.asHex();
		}
		 catch(MessagingException ex) {
		}
		return id;
	 }
	 protected int getFolderTree(Folder folder, Element xml_parent, boolean subscribed_only) {
		int depth=1;
		String id=generateFolderHash(folder);
		boolean holds_folders=false,holds_messages=false;
		Element xml_folder;
		try {
			 holds_folders=(folder.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS;
			 holds_messages=(folder.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;
			 xml_folder=model.createFolder(id,folder.getName(),holds_folders,holds_messages);
			 if(folder.isSubscribed()) {
				xml_folder.setAttribute(""subscribed"",""true"");
			 }
			 else {
				xml_folder.setAttribute(""subscribed"",""false"");
			 }
		}
		 catch(MessagingException ex) {
			 xml_folder=model.createFolder(id,folder.getName(),holds_folders,holds_messages);
			 xml_folder.setAttribute(""error"",ex.getMessage());
		}
		folders.put(id,folder);
		try {
			 if(holds_messages) {
				Element messagelist=model.createMessageList();
				int total_messages=folder.getMessageCount();
				int new_messages=folder.getNewMessageCount();
				if((total_messages == -1 || new_messages == -1) || !folder.isOpen()) {
					 folder.open(Folder.READ_ONLY);
					 total_messages=folder.getMessageCount();
					 new_messages=folder.getNewMessageCount();
				}
				folder.close(false);
				messagelist.setAttribute(""total"",total_messages+"""");
				messagelist.setAttribute(""new"",new_messages+"""");
				xml_folder.appendChild(messagelist);
			 }
		}
		 catch(MessagingException ex) {
			 xml_folder.setAttribute(""error"",ex.getMessage());
		}
		try {
			 if(holds_folders) {
				Folder[] subfolders;
				if(subscribed_only) {
					 try {
						subfolders=folder.listSubscribed();
					 }
					 catch(MessagingException ex) {
						System.err.println(""Subscribe not supported"");
						subfolders=folder.list();
					 }
				}
				 else {
					 subfolders=folder.list();
				}
				int max_tree_depth=0;
				for(int i=0;
				i<subfolders.length;
				i++) {
					 int tree_depth=getFolderTree(subfolders[i],xml_folder,subscribed_only);
					 if(tree_depth>max_tree_depth) {
						max_tree_depth=tree_depth;
					 }
				}
				depth+=max_tree_depth;
			 }
		}
		 catch(MessagingException ex) {
			 xml_folder.setAttribute(""error"",ex.getMessage());
		}
		xml_parent.appendChild(xml_folder);
		return depth;
	 }
	 public void refreshFolderInformation() {
		refreshFolderInformation(false);
	 }
	 public void refreshFolderInformation(boolean subscribed_only) {
		setEnv();
		if(folders==null) folders=new Hashtable();
		Folder cur_folder=null;
		String cur_mh_id="""";
		Enumeration mailhosts=user.mailHosts();
		int max_depth=0;
		while(mailhosts.hasMoreElements()) {
			 cur_mh_id=(String)mailhosts.nextElement();
			 MailHostData mhd=user.getMailHost(cur_mh_id);
			 URLName url=new URLName(mhd.getHostURL());
			 Element mailhost=model.createMailhost(mhd.getName(),mhd.getID(),url.toString());
			 int depth=0;
			 try {
				cur_folder=getRootFolder(cur_mh_id);
				try {
					 cur_folder.setSubscribed(true);
				}
				 catch(MessagingException ex) {
				}
				try {
					 if(cur_folder.getFolder(""~""+mhd.getLogin()+""/mail"").exists()) {
						depth=getFolderTree(cur_folder.getFolder(""INBOX""),mailhost, subscribed_only);
						if(depth>max_depth) {
							 max_depth=depth;
						}
						depth=getFolderTree(cur_folder.getFolder(""~""+mhd.getLogin()+""/mail""),mailhost, subscribed_only);
					 }
					 else if(cur_folder.getFolder(""INBOX"").exists()) {
						depth=getFolderTree(cur_folder.getFolder(""INBOX""),mailhost, subscribed_only);
					 }
				 }
				 catch(MessagingException ex) {
					 depth=getFolderTree(cur_folder.getFolder(""INBOX""),mailhost, subscribed_only);
				}
			 }
			 catch(MessagingException ex) {
				mailhost.setAttribute(""error"",ex.getMessage());
				parent.getStorage().log(Storage.LOG_WARN,""Error connecting to mailhost (""+url.toString()+""): ""+ex.getMessage());
			 }
			 if(depth>max_depth) {
				max_depth=depth;
			 }
			 model.addMailhost(mailhost);
		}
		model.setStateVar(""max folder depth"",(1+max_depth)+"""");
	 }
	 public void refreshFolderInformation(String folderhash) {
		Folder folder=getFolder(folderhash);
		Element xml_folder=model.getFolder(folderhash);
		if(xml_folder.getAttribute(""holds_messages"").toLowerCase().equals(""true"")) {
			 try {
				Element messagelist=model.createMessageList();
				int total_messages=folder.getMessageCount();
				int new_messages=folder.getNewMessageCount();
				if((total_messages == -1 || new_messages == -1) && !folder.isOpen()) {
					 folder.open(Folder.READ_ONLY);
					 total_messages=folder.getMessageCount();
					 new_messages=folder.getNewMessageCount();
				}
				if(folder.isOpen()) folder.close(false);
				messagelist.setAttribute(""total"",total_messages+"""");
				messagelist.setAttribute(""new"",new_messages+"""");
				model.removeMessageList(xml_folder);
				xml_folder.appendChild(messagelist);
			 }
			 catch(MessagingException ex) {
				xml_folder.setAttribute(""error"",ex.getMessage());
			 }
		}
	 }
	 public void subscribeFolder(String folderhash) {
		Folder folder=getFolder(folderhash);
		try {
			 folder.setSubscribed(true);
		}
		 catch(MessagingException ex) {
		}
	 }
	 public void unsubscribeFolder(String folderhash) {
		Folder folder=getFolder(folderhash);
		try {
			 folder.setSubscribed(false);
		}
		 catch(MessagingException ex) {
		}
	 }
	 public void setSubscribedAll(String id, boolean subscribed) throws MessagingException {
		Folder folder=getRootFolder(id);
		Queue q=new Queue();
		q.queue(folder);
		try {
			 while(!q.isEmpty()) {
				folder=(Folder)q.next();
				folder.setSubscribed(subscribed);
				Folder[] list=folder.list();
				for(int i=0;
				i<list.length;
				i++) {
					 q.queue(list[i]);
				}
			 }
		}
		 catch(MessagingException ex) {
		}
	 }
	 public void disconnectAll() {
		Enumeration e=user.mailHosts();
		while(e.hasMoreElements()) {
			 String name=(String)e.nextElement();
			 disconnect(name);
		}
		e=stores.keys();
		while(e.hasMoreElements()) {
			 String name=(String)e.nextElement();
			 Store st=(Store)stores.get(name);
			 try {
				st.close();
				parent.getStorage().log(Storage.LOG_INFO,""Mail: Connection to ""+st.toString()+"" closed."");
			 }
			 catch(Exception ex) {
				parent.getStorage().log(Storage.LOG_WARN,""Mail: Failed to close connection to ""+st.toString()+"". Reason: ""+ex.getMessage());
			 }
			 stores.remove(name);
		}
		folders=null;
	 }
	 public Folder getRootFolder(String name) throws MessagingException {
		if(connections != null && connections.containsKey(name)) {
			 return (Folder)connections.get(name);
		}
		 else {
			 return connect(name);
		}
	 }
	 protected Store connectStore(String host,String protocol,String login, String password) throws MessagingException {
		WebMailVirtualDomain vdom=parent.getStorage().getVirtualDomain(user.getDomain());
		if(!vdom.isAllowedHost(host)) {
			 throw new MessagingException(""You are not allowed to connect to this host"");
		}
		Store st=(Store)stores.get(host+""-""+protocol);
		if(st==null) {
			 st=mailsession.getStore(protocol);
			 stores.put(host+""-""+protocol,st);
		}
		if(!st.isConnected()) {
			 try {
				st.connect(host,login,password);
				parent.getStorage().log(Storage.LOG_INFO,""Mail: Connection to ""+st.toString()+""."");
			 }
			 catch(AuthenticationFailedException ex) {
				if(!login_password.equals(password) && parent.getStorage().getConfig(""FOLDER TRY LOGIN PASSWORD"").toUpperCase().equals(""YES"")) {
					 st.connect(host,login,login_password);
					 parent.getStorage().log(Storage.LOG_INFO,""Mail: Connection to ""+st.toString()+"", second attempt with login password succeeded."");
				}
				 else {
					 throw ex;
				}
			 }
		}
		return st;
	 }
	 public Folder connect(String name) throws MessagingException {
		MailHostData m=user.getMailHost(name);
		URLName url=new URLName(m.getHostURL());
		Store st=connectStore(url.getHost(),url.getProtocol(),m.getLogin(),m.getPassword());
		Folder f=st.getDefaultFolder();
		connections.put(name,f);
		parent.getStorage().log(Storage.LOG_INFO,""Mail: Folder ""+f.toString()+"" opened at store ""+st.toString()+""."");
		return f;
	 }
	 public void disconnect(String name) {
		try {
			 Folder f=(Folder)connections.get(name);
			 if(f != null && f.isOpen()) {
				f.close(true);
				Store st=((Folder)connections.get(name)).getStore();
				parent.getStorage().log(Storage.LOG_INFO,""Mail: Disconnected from folder ""+f.toString()+"" at store ""+st.toString()+""."");
			 }
			 else {
				parent.getStorage().log(Storage.LOG_WARN,""Mail: Folder ""+name+"" was null???."");
			 }
		}
		 catch(MessagingException ex) {
			 ex.printStackTrace();
		}
		 catch(NullPointerException ex) {
			 ex.printStackTrace();
		}
		 finally {
			 connections.remove(name);
		}
	 }
	 public void logout() {
		if(!is_logged_out) {
			 is_logged_out=true;
			 expungeFolders();
			 disconnectAll();
			 user.logout();
			 saveData();
			 parent.getStorage().log(Storage.LOG_INFO,""WebMail: Session ""+getSessionCode()+"" logout."");
			 if(sess != null) {
				try {
					 Class srvltreq=Class.forName(""javax.servlet.http.HttpSession"");
					 if(srvltreq.isInstance(sess)) {
						((javax.servlet.http.HttpSession)sess).invalidate();
					 }
				}
				 catch(Throwable t) {
				}
			 }
			 if(parent.getSession(getSessionCode()) != null) {
				parent.removeSession(this);
			 }
		}
		 else {
			 System.err.println(""WARNING: Session was already logged out. Ignoring logout request."");
		}
	 }
	 public boolean isLoggedOut() {
		return is_logged_out;
	 }
	 public String getSessionCode() {
		return session_code;
	 }
	 public long getLastAccess() {
		return last_access;
	 }
	 public void setLastAccess() {
		last_access=System.currentTimeMillis();
	 }
	 public void timeoutOccured() {
		parent.getStorage().log(Storage.LOG_WARN,""WebMail: Session ""+getSessionCode()+"" timeout."");
		logout();
	 }
	 public long getTimeout() {
		long i=600000;
		try {
			 i=Long.parseLong(parent.getStorage().getConfig(""session timeout""));
		}
		 catch(NumberFormatException ex) {
			 ex.printStackTrace();
		}
		return i;
	 }
	 public Locale getLocale() {
		return user.getPreferredLocale();
	 }
	 public void saveData() {
		parent.getStorage().saveUserData(user.getUserName(),user.getDomain());
	 }
	 protected static int[] getSelectedMessages(HTTPRequestHeader head, int max) {
		Enumeration e=head.getContent().keys();
		int _msgs[]=new int[max];
		int j=0;
		while(e.hasMoreElements()) {
			 String s=(String)e.nextElement();
			 if(s.startsWith(""CH"") && head.getContent(s).equals(""on"")) {
				try {
					 _msgs[j]=Integer.parseInt(s.substring(3));
					 j++;
				}
				 catch(NumberFormatException ex) {
					 ex.printStackTrace();
				}
			 }
		}
		int msgs[]=new int[j];
		for(int i=0;
		i<j;
		i++) {
			 msgs[i]=_msgs[i];
		}
		return msgs;
	 }
	 public void expungeFolders() {
		if(need_expunge_folders != null) {
			 Enumeration enum=need_expunge_folders.elements();
			 while(enum.hasMoreElements()) {
				String hash=(String)enum.nextElement();
				if(user.wantsSetFlags()) {
					 Folder f=getFolder(hash);
					 try {
						if(f.isOpen()) {
							 f.close(false);
						}
						f.open(Folder.READ_WRITE);
						try {
							 f.expunge();
						}
						 catch(MessagingException ex) {
						}
						f.close(true);
					 }
					 catch(MessagingException ex) {
						ex.printStackTrace();
					 }
				}
			 }
		}
	 }
	 public void setFlags(String folderhash, HTTPRequestHeader head) throws MessagingException {
		if(head.isContentSet(""copymovemsgs"") && head.getContent(""COPYMOVE"").equals(""COPY"")) {
			 copyMoveMessage(folderhash,head.getContent(""TO""),head,false);
		}
		 else if(head.isContentSet(""copymovemsgs"") && head.getContent(""COPYMOVE"").equals(""MOVE"")) {
			 copyMoveMessage(folderhash,head.getContent(""TO""),head,true);
		}
		 else if(head.isContentSet(""flagmsgs"")) {
			 System.err.println(""setting message flags"");
			 Folder folder=getFolder(folderhash);
			 int msgs[]=getSelectedMessages(head,folder.getMessageCount());
			 Flags fl=new Flags(Flags.Flag.USER);
			 if(head.getContent(""MESSAGE FLAG"").equals(""DELETED"")) {
				fl=new Flags(Flags.Flag.DELETED);
				if(need_expunge_folders == null) {
					 need_expunge_folders=new Vector();
				}
				need_expunge_folders.addElement(folderhash);
			 }
			 else if(head.getContent(""MESSAGE FLAG"").equals(""SEEN"")) {
				fl=new Flags(Flags.Flag.SEEN);
			 }
			 else if(head.getContent(""MESSAGE FLAG"").equals(""RECENT"")) {
				fl=new Flags(Flags.Flag.RECENT);
			 }
			 else if(head.getContent(""MESSAGE FLAG"").equals(""ANSWERED"")) {
				fl=new Flags(Flags.Flag.ANSWERED);
			 }
			 else if(head.getContent(""MESSAGE FLAG"").equals(""DRAFT"")) {
				fl=new Flags(Flags.Flag.DRAFT);
			 }
			 boolean value=true;
			 if(head.getContent(""MARK"").equals(""UNMARK"")) {
				value=false;
			 }
			 if(user.wantsSetFlags()) {
				if(folder.isOpen() && folder.getMode()==Folder.READ_ONLY) {
					 folder.close(false);
					 folder.open(Folder.READ_WRITE);
				}
				 else if(!folder.isOpen()) {
					 folder.open(Folder.READ_WRITE);
				}
				folder.setFlags(msgs,fl,value);
				if(user.getBoolVar(""autoexpunge"")) {
					 folder.close(true);
					 if(need_expunge_folders != null) {
						need_expunge_folders.removeElement(folderhash);
					 }
				}
				 else {
					 folder.close(false);
				}
			 }
			 refreshFolderInformation(folderhash);
		}
	 }
	 public void copyMoveMessage(String fromfolder, String tofolder, HTTPRequestHeader head, boolean move) throws MessagingException {
		Folder from=getFolder(fromfolder);
		Folder to=getFolder(tofolder);
		if(user.wantsSetFlags()) {
			 if(from.isOpen() && from.getMode() == Folder.READ_ONLY) {
				from.close(false);
				from.open(Folder.READ_WRITE);
			 }
			 else if(!from.isOpen()) {
				from.open(Folder.READ_WRITE);
			 }
			 if(to.isOpen() && to.getMode() == Folder.READ_ONLY) {
				to.close(false);
				to.open(Folder.READ_WRITE);
			 }
			 else if(!to.isOpen()) {
				to.open(Folder.READ_WRITE);
			 }
		}
		 else {
			 if(!from.isOpen()) {
				from.open(Folder.READ_ONLY);
			 }
			 if(to.isOpen() && to.getMode() == Folder.READ_ONLY) {
				to.close(false);
				to.open(Folder.READ_WRITE);
			 }
			 else if(!to.isOpen()) {
				to.open(Folder.READ_WRITE);
			 }
		}
		int m[]=getSelectedMessages(head,from.getMessageCount());
		Message msgs[]=from.getMessages(m);
		from.copyMessages(msgs,to);
		if(move && user.wantsSetFlags()) {
			 from.setFlags(m,new Flags(Flags.Flag.DELETED),true);
			 if(user.getBoolVar(""autoexpunge"")) {
				from.close(true);
				 to.close(true);
			 }
			 else {
				if(need_expunge_folders == null) {
					 need_expunge_folders=new Vector();
				}
				need_expunge_folders.addElement(fromfolder);
				from.close(false);
				to.close(false);
			 }
		}
		 else {
			 from.close(false);
			 if(user.getBoolVar(""autoexpunge"")) {
				to.close(true);
			 }
			 else {
				to.close(false);
			 }
		}
		refreshFolderInformation(fromfolder);
		refreshFolderInformation(tofolder);
	 }
	 public void changeSetup(HTTPRequestHeader head) throws WebMailException {
		Enumeration contentkeys=head.getContentKeys();
		user.resetBoolVars();
		while(contentkeys.hasMoreElements()) {
			 String key=((String)contentkeys.nextElement()).toLowerCase();
			 if(key.startsWith(""intvar"")) {
				try {
					 long value=Long.parseLong(head.getContent(key));
					 user.setIntVar(key.substring(7),value);
				}
				 catch(NumberFormatException ex) {
					 System.err.println(""Warning: Remote provided illegal intvar in request header: \n(""+key+"",""+head.getContent(key)+"")"");
				}
			 }
			 else if(key.startsWith(""boolvar"")) {
				boolean value=head.getContent(key).toUpperCase().equals(""ON"");
				user.setBoolVar(key.substring(8),value);
			 }
		}
		try {
			user.setSignature(new String(head.getContent(""SIGNATURE"").getBytes(""ISO8859_1""), ""UTF-8""));
			user.setFullName(new String(head.getContent(""FULLNAME"").getBytes(""ISO8859_1""), ""UTF-8""));
		}
		 catch (UnsupportedEncodingException e) {
			e.printStackTrace();
			user.setSignature(head.getContent(""SIGNATURE""));
			user.setFullName(head.getContent(""FULLNAME""));
		}
		user.setEmail(head.getContent(""EMAIL""));
		if(!head.getContent(""PASSWORD"").equals("""")) {
			 net.wastl.webmail.server.Authenticator auth=parent.getStorage().getAuthenticator();
			 if(auth.canChangePassword()) {
				auth.changePassword(user,head.getContent(""PASSWORD""),head.getContent(""VERIFY""));
			 }
			 else {
				throw new InvalidDataException(getStringResource(""EX NO CHANGE PASSWORD""));
			 }
		}
		user.setPreferredLocale(head.getContent(""LANGUAGE""));
		user.setTheme(head.getContent(""THEME""));
		if(head.isContentSet(""SENTFOLDER"")) {
			 System.err.println(""SENTFOLDER=""+head.getContent(""SENTFOLDER""));
			 user.setSentFolder(head.getContent(""SENTFOLDER""));
		}
		setEnv();
		model.update();
	 }
	 public void addMailbox(String name, String protocol, String host, String login, String password) throws MessagingException {
		disconnectAll();
		String host_url=protocol+"":user.addMailHost(name, host_url, login, password);
		Enumeration enum=user.mailHosts();
		while(enum.hasMoreElements()) {
			 String id=(String)enum.nextElement();
			 if(user.getMailHost(id).getName().equals(name)) {
				setSubscribedAll(id,true);
				break;
			 }
		}
		model.update();
	 }
	 public void removeMailbox(String name) {
		disconnectAll();
		user.removeMailHost(name);
		model.update();
	 }
	 public void setAddToFolder(String id) {
		model.setStateVar(""add to folder"",id);
	 }
	 public void addFolder(String toid, String name, boolean holds_messages, boolean holds_folders) throws MessagingException {
		Folder parent=getFolder(toid);
		Folder folder=parent.getFolder(name);
		if(!folder.exists()) {
			 int type=0;
			 if(holds_messages) {
				type+=Folder.HOLDS_MESSAGES;
			 }
			 if(holds_folders) {
				type+=Folder.HOLDS_FOLDERS;
			 }
			 folder.create(type);
		}
	 }
	 public void removeFolder(String id, boolean recurse) throws MessagingException {
		Folder folder=getFolder(id);
		folder.close(false);
		folder.delete(recurse);
	 }
	 public String getEnv(String key) {
		return """";
	 }
	 public void setEnv(String key, String value) {
	 }
	 public void setException(Exception ex) {
		model.setException(ex);
	 }
	 public void setEnv() {
		model.setStateVar(""base uri"",parent.getBasePath());
		model.setStateVar(""img base uri"",parent.getImageBasePath()+ ""/""+user.getPreferredLocale().getLanguage()+ ""/""+user.getTheme());
		model.setStateVar(""webmail version"",parent.getVersion());
		model.setStateVar(""operating system"",System.getProperty(""os.name"")+"" ""+ System.getProperty(""os.version"")+""/""+System.getProperty(""os.arch""));
		model.setStateVar(""java virtual machine"",System.getProperty(""java.vendor"")+"" ""+ System.getProperty(""java.vm.name"")+"" ""+System.getProperty(""java.version""));
		model.setStateVar(""last login"",user.getLastLogin());
		model.setStateVar(""first login"",user.getFirstLogin());
		model.setStateVar(""session id"",session_code);
		model.setStateVar(""date"",formatDate(System.currentTimeMillis()));
		model.setStateVar(""max attach size"",parent.getStorage().getConfig(""MAX ATTACH SIZE""));
		model.setStateVar(""current attach size"",""""+attachments_size);
		model.removeAllStateVars(""language"");
		String lang=parent.getConfig(""languages"");
		StringTokenizer tok=new StringTokenizer(lang,"" "");
		while(tok.hasMoreTokens()) {
			 String t=tok.nextToken();
			 model.addStateVar(""language"",t);
			 model.removeAllStateVars(""themes_""+t);
			 StringTokenizer tok2=new StringTokenizer(parent.getConfig(""THEMES_""+t.toUpperCase()),"" "");
			 while(tok2.hasMoreElements()) {
				model.addStateVar(""themes_""+t,(String)tok2.nextToken());
			 }
		}
		model.removeAllStateVars(""protocol"");
		Provider[] stores=parent.getStoreProviders();
		for(int i=0;
		 i<stores.length;
		 i++) {
			 model.addStateVar(""protocol"",stores[i].getProtocol());
		}
		model.setStateVar(""themeset"",""themes_""+user.getPreferredLocale().getLanguage().toLowerCase());
	 }
	 public UserData getUser() {
		return user;
	 }
	 public String getUserName() {
		return user.getLogin();
	 }
	 public InetAddress getRemoteAddress() {
		return remote;
	 }
	 public Hashtable getActiveConnections() {
		return connections;
	 }
	 public void setSent(boolean b) {
		sent=b;
	 }
	 public boolean isSent() {
		return sent;
	 }
	 private String formatDate(long date) {
		TimeZone tz=TimeZone.getDefault();
		DateFormat df=DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.DEFAULT, getLocale());
		df.setTimeZone(tz);
		String now=df.format(new Date(date));
		return now;
	 }
	 public void handleTransportException(SendFailedException e) {
		model.setStateVar(""send status"",e.getNextException().getMessage());
		model.setStateVar(""valid sent addresses"",Helper.joinAddress(e.getValidSentAddresses()));
		model.setStateVar(""valid unsent addresses"",Helper.joinAddress(e.getValidUnsentAddresses()));
		model.setStateVar(""invalid addresses"",Helper.joinAddress(e.getInvalidAddresses()));
		sent=true;
	 }
}",1,0,0,0
"public final class TestAutoFilterInfoRecord extends TestCase {
	 private final byte[] data = new byte[] {
	 0x05, 0x00 }
	;
	 public void testRead() {
		 AutoFilterInfoRecord record = new AutoFilterInfoRecord(TestcaseRecordInputStream.create(AutoFilterInfoRecord.sid, data));
		 assertEquals(AutoFilterInfoRecord.sid, record.getSid());
		 assertEquals(data.length, record.getDataSize());
		 assertEquals(5, record.getNumEntries());
		 record.setNumEntries((short)3);
		 assertEquals(3, record.getNumEntries());
	 }
	 public void testWrite() {
		 AutoFilterInfoRecord record = new AutoFilterInfoRecord();
		 record.setNumEntries((short)3);
		 byte [] ser = record.serialize();
		 assertEquals(ser.length - 4, data.length);
		 record = new AutoFilterInfoRecord(TestcaseRecordInputStream.create(ser));
		 assertEquals(3, record.getNumEntries());
	 }
	 public void testClone() {
		 AutoFilterInfoRecord record = new AutoFilterInfoRecord();
		 record.setNumEntries((short)3);
		 byte[] src = record.serialize();
		 AutoFilterInfoRecord cloned = record.clone();
		 assertEquals(3, record.getNumEntries());
		 byte[] cln = cloned.serialize();
		 assertEquals(record.getDataSize(), cloned.getDataSize());
		 assertArrayEquals(src, cln);
	 }
}",0,0,0,0
"public final class DeweyDecimal extends org.apache.tools.ant.util.DeweyDecimal {
	 public DeweyDecimal(final int[] components) {
		 super(components);
	 }
	 public DeweyDecimal(final String string) throws NumberFormatException {
		 super(string);
	 }
}",0,0,0,0
"public static PendingFileSerializer serializer() {
	 return serializer_;
 }",0,0,0,0
"public class HttpExchangeTracer {
	private final Set<Include> includes;
	public HttpExchangeTracer(Set<Include> includes) {
		this.includes = includes;
	}
	public final HttpTrace receivedRequest(TraceableRequest request) {
		return new HttpTrace(new FilteredTraceableRequest(request));
	}
	public final void sendingResponse(HttpTrace trace, TraceableResponse response,Supplier<Principal> principal, Supplier<String> sessionId) {
		setIfIncluded(Include.TIME_TAKEN,() -> System.currentTimeMillis() - trace.getTimestamp().toEpochMilli(),trace::setTimeTaken);
		setIfIncluded(Include.SESSION_ID, sessionId, trace::setSessionId);
		setIfIncluded(Include.PRINCIPAL, principal, trace::setPrincipal);
		trace.setResponse(new HttpTrace.Response(new FilteredTraceableResponse(response)));
	}
	protected void postProcessRequestHeaders(Map<String, List<String>> headers) {
	}
	private <T> T getIfIncluded(Include include, Supplier<T> valueSupplier) {
		return this.includes.contains(include) ? valueSupplier.get() : null;
	}
	private <T> void setIfIncluded(Include include, Supplier<T> supplier,Consumer<T> consumer) {
		if (this.includes.contains(include)) {
			consumer.accept(supplier.get());
		}
	}
	private Map<String, List<String>> getHeadersIfIncluded(Include include,Supplier<Map<String, List<String>>> headersSupplier,Predicate<String> headerPredicate) {
		if (!this.includes.contains(include)) {
			return new LinkedHashMap<>();
		}
		return headersSupplier.get().entrySet().stream().filter((entry) -> headerPredicate.test(entry.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
	}
	private final class FilteredTraceableRequest implements TraceableRequest {
		private final TraceableRequest delegate;
		private FilteredTraceableRequest(TraceableRequest delegate) {
			this.delegate = delegate;
		}
		public String getMethod() {
			return this.delegate.getMethod();
		}
		public URI getUri() {
			return this.delegate.getUri();
		}
		public Map<String, List<String>> getHeaders() {
			Map<String, List<String>> headers = getHeadersIfIncluded(Include.REQUEST_HEADERS, this.delegate::getHeaders,this::includedHeader);
			postProcessRequestHeaders(headers);
			return headers;
		}
		private boolean includedHeader(String name) {
			if (name.equalsIgnoreCase(HttpHeaders.COOKIE)) {
				return HttpExchangeTracer.this.includes.contains(Include.COOKIE_HEADERS);
			}
			if (name.equalsIgnoreCase(HttpHeaders.AUTHORIZATION)) {
				return HttpExchangeTracer.this.includes.contains(Include.AUTHORIZATION_HEADER);
			}
			return true;
		}
		public String getRemoteAddress() {
			return getIfIncluded(Include.REMOTE_ADDRESS, this.delegate::getRemoteAddress);
		}
	}
	private final class FilteredTraceableResponse implements TraceableResponse {
		private final TraceableResponse delegate;
		private FilteredTraceableResponse(TraceableResponse delegate) {
			this.delegate = delegate;
		}
		public int getStatus() {
			return this.delegate.getStatus();
		}
		public Map<String, List<String>> getHeaders() {
			return getHeadersIfIncluded(Include.RESPONSE_HEADERS,this.delegate::getHeaders, this::includedHeader);
		}
		private boolean includedHeader(String name) {
			if (name.equalsIgnoreCase(HttpHeaders.SET_COOKIE)) {
				return HttpExchangeTracer.this.includes.contains(Include.COOKIE_HEADERS);
			}
			return true;
		}
	}
}",1,0,0,0
"public class Compare extends DataType implements ResourceSelector {
	 private static final String ONE_CONTROL_MESSAGE = "" the <control> element should be specified exactly once."";
	 private DelegatedResourceComparator comp = new DelegatedResourceComparator();
	 private Quantifier against = Quantifier.ALL;
	 private Comparison when = Comparison.EQUAL;
	 private Union control;
	 public synchronized void add(ResourceComparator c) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 comp.add(c);
	 }
	 public synchronized void setAgainst(Quantifier against) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.against = against;
	 }
	 public synchronized void setWhen(Comparison when) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.when = when;
	 }
	 public synchronized ResourceCollection createControl() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (control != null) {
			 throw oneControl();
		 }
		 control = new Union();
		 return control;
	 }
	 public synchronized boolean isSelected(Resource r) {
		 if (isReference()) {
			 return ((ResourceSelector) getCheckedRef()).isSelected(r);
		 }
		 if (control == null) {
			 throw oneControl();
		 }
		 int t = 0, f = 0;
		 for (Iterator it = control.iterator();
		 it.hasNext();
		) {
			 if (when.evaluate(comp.compare(r, (Resource) it.next()))) {
				 t++;
			 }
			 else {
				 f++;
			 }
		 }
		 return against.evaluate(t, f);
	 }
	 protected synchronized void dieOnCircularReference(Stack stk, Project p) throws BuildException {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 if (control != null) {
				 DataType.invokeCircularReferenceCheck(control, stk, p);
			 }
			 DataType.invokeCircularReferenceCheck(comp, stk, p);
			 setChecked(true);
		 }
	 }
	 private BuildException oneControl() {
		 return new BuildException(super.toString() + ONE_CONTROL_MESSAGE);
	 }
}",0,0,0,0
"public class TimestampTracker implements AutoCloseable {
	 private static final Logger log = LoggerFactory.getLogger(TimestampTracker.class);
	 private volatile long zkTimestamp = -1;
	 private final Environment env;
	 private final SortedSet<Long> timestamps = new TreeSet<>();
	 private volatile PersistentNode node = null;
	 private final TransactorID tid;
	 private final Timer timer;
	 private boolean closed = false;
	 private int allocationsInProgress = 0;
	 private boolean updatingZk = false;
	 public TimestampTracker(Environment env, TransactorID tid, long updatePeriodMs) {
		 Objects.requireNonNull(env, ""environment cannot be null"");
		 Objects.requireNonNull(tid, ""tid cannot be null"");
		 Preconditions.checkArgument(updatePeriodMs > 0, ""update period must be positive"");
		 this.env = env;
		 this.tid = tid;
		 TimerTask tt = new TimerTask() {
			 private int sawZeroCount = 0;
			 public void run() {
				 try {
					 long ts = 0;
					 synchronized (TimestampTracker.this) {
						 if (closed) {
							 return;
						 }
						 if (allocationsInProgress > 0) {
							 sawZeroCount = 0;
							 if (!timestamps.isEmpty()) {
								 if (updatingZk) {
									 throw new IllegalStateException(""expected updatingZk to be false"");
								 }
								 ts = timestamps.first();
								 updatingZk = true;
							 }
						 }
						 else if (allocationsInProgress == 0) {
							 sawZeroCount++;
							 if (sawZeroCount >= 2) {
								 sawZeroCount = 0;
								 closeZkNode();
							 }
						 }
						 else {
							 throw new IllegalStateException(""allocationsInProgress = "" + allocationsInProgress);
						 }
					 }
					 if (updatingZk) {
						 try {
							 updateZkNode(ts);
						 }
						 finally {
							 synchronized (TimestampTracker.this) {
								 updatingZk = false;
							 }
						 }
					 }
				 }
				 catch (Exception e) {
					 log.error(""Exception occurred in Zookeeper update thread"", e);
				 }
			 }
		 }
		;
		 timer = new Timer(""TimestampTracker timer"", true);
		 timer.schedule(tt, updatePeriodMs, updatePeriodMs);
	 }
	 public TimestampTracker(Environment env, TransactorID tid) {
		 this(env, tid, env.getConfiguration().getLong(FluoConfigurationImpl.ZK_UPDATE_PERIOD_PROP, FluoConfigurationImpl.ZK_UPDATE_PERIOD_MS_DEFAULT));
	 }
	 public Stamp allocateTimestamp() {
		 synchronized (this) {
			 Preconditions.checkState(!closed, ""tracker closed "");
			 if (node == null) {
				 Preconditions.checkState(allocationsInProgress == 0, ""expected allocationsInProgress == 0 when node == null"");
				 Preconditions.checkState(!updatingZk, ""unexpected concurrent ZK update"");
				 createZkNode(getTimestamp().getTxTimestamp());
			 }
			 allocationsInProgress++;
		 }
		 try {
			 Stamp ts = getTimestamp();
			 synchronized (this) {
				 timestamps.add(ts.getTxTimestamp());
			 }
			 return ts;
		 }
		 catch (RuntimeException re) {
			 synchronized (this) {
				 allocationsInProgress--;
			 }
			 throw re;
		 }
	 }
	 public synchronized void removeTimestamp(long ts) throws NoSuchElementException {
		 Preconditions.checkState(!closed, ""tracker closed "");
		 Preconditions.checkState(allocationsInProgress > 0, ""allocationsInProgress should be > 0 "" + allocationsInProgress);
		 Objects.requireNonNull(node);
		 if (timestamps.remove(ts) == false) {
			 throw new NoSuchElementException( ""Timestamp "" + ts + "" was previously removed or does not exist"");
		 }
		 allocationsInProgress--;
	 }
	 private Stamp getTimestamp() {
		 return env.getSharedResources().getOracleClient().getStamp();
	 }
	 private void createZkNode(long ts) {
		 Preconditions.checkState(node == null, ""expected node to be null"");
		 node = new PersistentNode(env.getSharedResources().getCurator(), CreateMode.EPHEMERAL, false, getNodePath(), LongUtil.toByteArray(ts));
		 CuratorUtil.startAndWait(node, 10);
		 zkTimestamp = ts;
	 }
	 private void closeZkNode() {
		 try {
			 if (node != null) {
				 node.close();
				 node = null;
			 }
		 }
		 catch (IOException e) {
			 log.error(""Failed to close timestamp tracker ephemeral node"");
			 throw new IllegalStateException(e);
		 }
	 }
	 private void updateZkNode(long ts) {
		 if (ts != zkTimestamp) {
			 try {
				 node.setData(LongUtil.toByteArray(ts));
			 }
			 catch (Exception e) {
				 throw new IllegalStateException(e);
			 }
		 }
		 zkTimestamp = ts;
	 }
	 public synchronized void updateZkNode() {
		 Preconditions.checkState(!updatingZk, ""unexpected concurrent ZK update"");
		 if (allocationsInProgress > 0) {
			 if (!timestamps.isEmpty()) {
				 updateZkNode(timestamps.first());
			 }
		 }
		 else if (allocationsInProgress == 0) {
			 closeZkNode();
		 }
		 else {
			 throw new IllegalStateException(""allocationsInProgress = "" + allocationsInProgress);
		 }
	 }
	 public long getOldestActiveTimestamp() {
		 return timestamps.first();
	 }
	 public long getZookeeperTimestamp() {
		 return zkTimestamp;
	 }
	 public boolean isEmpty() {
		 return timestamps.isEmpty();
	 }
	 public String getNodePath() {
		 return ZookeeperPath.TRANSACTOR_TIMESTAMPS + ""/"" + tid;
	 }
	 public synchronized void close() {
		 Preconditions.checkState(!closed, ""tracker already closed"");
		 closed = true;
		 timer.cancel();
		 closeZkNode();
	 }
}",1,0,0,0
"public LongRect getSelectionBounds(ItemSelection selection, ChartContext context) {
	 XYItemSelection sel = (XYItemSelection)selection;
	 XYItem item = sel.getItem();
	 int selectedValueIndex = sel.getValueIndex();
	 if (selectedValueIndex == -1 || selectedValueIndex >= item.getValuesCount()) return new LongRect(0, 0, context.getViewportWidth(), context.getViewportHeight());
	 else return getViewBounds(item, selectedValueIndex, context);
 }",0,0,1,0
"public void genJavaCode() throws IOException {
	 String pkg = getJavaPackage();
	 String pkgpath = pkg.replaceAll(""\\."", ""/"");
	 File pkgdir = new File(pkgpath);
	 if (!pkgdir.exists()) {
		 boolean ret = pkgdir.mkdirs();
		 if (!ret) {
			 System.out.println(""Cannnot create directory: ""+pkgpath);
			 System.exit(1);
		 }
	 }
	 else if (!pkgdir.isDirectory()) {
		 System.out.println(pkgpath+"" is not a directory."");
		 System.exit(1);
	 }
	 File jfile = new File(pkgdir, getName()+"".java"");
	 FileWriter jj = new FileWriter(jfile);
	 jj.write("" jj.write(""package ""+getJavaPackage()+"";
	\n\n"");
	 jj.write(""public class ""+getName()+"" implements org.apache.hadoop.record.Record, org.apache.hadoop.io.WritableComparable {
		\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaDecl());
		 }
		 jj.write("" private java.util.BitSet bs_;
		\n"");
		 jj.write("" public ""+getName()+""() {
			\n"");
			 jj.write("" bs_ = new java.util.BitSet(""+(mFields.size()+1)+"");
			\n"");
			 jj.write("" bs_.set(""+mFields.size()+"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public ""+getName()+""(\n"");
		 int fIdx = 0;
		 int fLen = mFields.size();
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaConstructorParam(fIdx));
			 jj.write((fLen-1 == fIdx)?"""":"",\n"");
		 }
		 jj.write("") {
			\n"");
			 jj.write("" bs_ = new java.util.BitSet(""+(mFields.size()+1)+"");
			\n"");
			 jj.write("" bs_.set(""+mFields.size()+"");
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaConstructorSet(fIdx));
			 }
		 jj.write("" }
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaGetSet(fIdx));
		 }
		 jj.write("" public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
			\n"");
			 jj.write("" if (!validate()) throw new java.io.IOException(\""All fields not set:\"");
			\n"");
			 jj.write("" a_.startRecord(this,tag);
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaWriteMethodName());
				 jj.write("" bs_.clear(""+fIdx+"");
				\n"");
			 }
			 jj.write("" a_.endRecord(this,tag);
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
			\n"");
			 jj.write("" a_.startRecord(tag);
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaReadMethodName());
				 jj.write("" bs_.set(""+fIdx+"");
				\n"");
			 }
			 jj.write("" a_.endRecord(tag);
			\n"");
		 jj.write(""}
		\n"");
		 jj.write("" public String toString() {
			\n"");
			 jj.write("" try {
				\n"");
				 jj.write("" java.io.ByteArrayOutputStream s =\n"");
				 jj.write("" new java.io.ByteArrayOutputStream();
				\n"");
				 jj.write("" org.apache.hadoop.record.CsvOutputArchive a_ = \n"");
				 jj.write("" new org.apache.hadoop.record.CsvOutputArchive(s);
				\n"");
				 jj.write("" a_.startRecord(this,\""\"");
				\n"");
				 fIdx = 0;
				 for (Iterator i = mFields.iterator();
				 i.hasNext();
				 fIdx++) {
					 JField jf = (JField) i.next();
					 jj.write(jf.genJavaWriteMethodName());
				 }
				 jj.write("" a_.endRecord(this,\""\"");
				\n"");
				 jj.write("" return new String(s.toByteArray(), \""UTF-8\"");
				\n"");
			 jj.write("" }
			 catch (Throwable ex) {
				\n"");
				 jj.write("" ex.printStackTrace();
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" return \""ERROR\"";
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void write(java.io.DataOutput out) throws java.io.IOException {
			\n"");
			 jj.write("" org.apache.hadoop.record.BinaryOutputArchive archive = new org.apache.hadoop.record.BinaryOutputArchive(out);
			\n"");
			 jj.write("" serialize(archive, \""\"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void readFields(java.io.DataInput in) throws java.io.IOException {
			\n"");
			 jj.write("" org.apache.hadoop.record.BinaryInputArchive archive = new org.apache.hadoop.record.BinaryInputArchive(in);
			\n"");
			 jj.write("" deserialize(archive, \""\"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" private boolean validate() {
			\n"");
			 jj.write("" if (bs_.cardinality() != bs_.length()) return false;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 JType type = jf.getType();
				 if (type instanceof JRecord) {
					 jj.write("" if (!""+jf.getName()+"".validate()) return false;
					\n"");
				 }
			 }
			 jj.write("" return true;
			\n"");
		 jj.write(""}
		\n"");
		 jj.write("" public int compareTo (Object peer_) throws ClassCastException {
			\n"");
			 jj.write("" if (!(peer_ instanceof ""+getName()+"")) {
				\n"");
				 jj.write("" throw new ClassCastException(\""Comparing different types of records.\"");
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" ""+getName()+"" peer = (""+getName()+"") peer_;
			\n"");
			 jj.write("" int ret = 0;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaCompareTo());
				 jj.write("" if (ret != 0) return ret;
				\n"");
			 }
			 jj.write("" return ret;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public boolean equals(Object peer_) {
			\n"");
			 jj.write("" if (!(peer_ instanceof ""+getName()+"")) {
				\n"");
				 jj.write("" return false;
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" if (peer_ == this) {
				\n"");
				 jj.write("" return true;
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" ""+getName()+"" peer = (""+getName()+"") peer_;
			\n"");
			 jj.write("" boolean ret = false;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaEquals());
				 jj.write("" if (!ret) return ret;
				\n"");
			 }
			 jj.write("" return ret;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public int hashCode() {
			\n"");
			 jj.write("" int result = 17;
			\n"");
			 jj.write("" int ret;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaHashCode());
				 jj.write("" result = 37*result + ret;
				\n"");
			 }
			 jj.write("" return result;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public static String signature() {
			\n"");
			 jj.write("" return \""""+getSignature()+""\"";
			\n"");
		 jj.write("" }
		\n"");
	 jj.write(""}
	\n"");
	 jj.close();
 }",0,0,1,0
"public class XMLDTDProcessor implements XMLComponent, XMLDTDFilter, XMLDTDContentModelFilter {
	 private static final int TOP_LEVEL_SCOPE = -1;
	 protected static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
	 protected static final String NOTIFY_CHAR_REFS = Constants.XERCES_FEATURE_PREFIX + Constants.NOTIFY_CHAR_REFS_FEATURE;
	 protected static final String WARN_ON_DUPLICATE_ATTDEF = Constants.XERCES_FEATURE_PREFIX +Constants.WARN_ON_DUPLICATE_ATTDEF_FEATURE;
	 protected static final String WARN_ON_UNDECLARED_ELEMDEF = Constants.XERCES_FEATURE_PREFIX + Constants.WARN_ON_UNDECLARED_ELEMDEF_FEATURE;
	protected static final String PARSER_SETTINGS = Constants.XERCES_FEATURE_PREFIX + Constants.PARSER_SETTINGS;
	 protected static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
	 protected static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
	 protected static final String GRAMMAR_POOL = Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
	 protected static final String DTD_VALIDATOR = Constants.XERCES_PROPERTY_PREFIX + Constants.DTD_VALIDATOR_PROPERTY;
	 private static final String[] RECOGNIZED_FEATURES = {
	 VALIDATION, WARN_ON_DUPLICATE_ATTDEF, WARN_ON_UNDECLARED_ELEMDEF, NOTIFY_CHAR_REFS, }
	;
	 private static final Boolean[] FEATURE_DEFAULTS = {
	 null, Boolean.FALSE, Boolean.FALSE, null, }
	;
	 private static final String[] RECOGNIZED_PROPERTIES = {
	 SYMBOL_TABLE, ERROR_REPORTER, GRAMMAR_POOL, DTD_VALIDATOR, }
	;
	 private static final Object[] PROPERTY_DEFAULTS = {
	 null, null, null, null, }
	;
	 protected boolean fValidation;
	 protected boolean fDTDValidation;
	 protected boolean fWarnDuplicateAttdef;
	 protected boolean fWarnOnUndeclaredElemdef;
	 protected SymbolTable fSymbolTable;
	 protected XMLErrorReporter fErrorReporter;
	 protected DTDGrammarBucket fGrammarBucket;
	 protected XMLDTDValidator fValidator;
	 protected XMLGrammarPool fGrammarPool;
	 protected Locale fLocale;
	 protected XMLDTDHandler fDTDHandler;
	 protected XMLDTDSource fDTDSource;
	 protected XMLDTDContentModelHandler fDTDContentModelHandler;
	 protected XMLDTDContentModelSource fDTDContentModelSource;
	 protected DTDGrammar fDTDGrammar;
	 private boolean fPerformValidation;
	 protected boolean fInDTDIgnore;
	 private boolean fMixed;
	 private final XMLEntityDecl fEntityDecl = new XMLEntityDecl();
	 private final HashMap fNDataDeclNotations = new HashMap();
	 private String fDTDElementDeclName = null;
	 private final ArrayList fMixedElementTypes = new ArrayList();
	 private final ArrayList fDTDElementDecls = new ArrayList();
	 private HashMap fTableOfIDAttributeNames;
	 private HashMap fTableOfNOTATIONAttributeNames;
	 private HashMap fNotationEnumVals;
	 public XMLDTDProcessor() {
	 }
	 public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
		 boolean parser_settings;
		 try {
			 parser_settings = componentManager.getFeature(PARSER_SETTINGS);
		 }
		 catch (XMLConfigurationException e) {
			 parser_settings = true;
		 }
		 if (!parser_settings) {
			 reset();
			 return;
		 }
		 try {
			 fValidation = componentManager.getFeature(VALIDATION);
		 }
		 catch (XMLConfigurationException e) {
			 fValidation = false;
		 }
		 try {
			 fDTDValidation = !(componentManager .getFeature( Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE));
		 }
		 catch (XMLConfigurationException e) {
			 fDTDValidation = true;
		 }
		 try {
			 fWarnDuplicateAttdef = componentManager.getFeature(WARN_ON_DUPLICATE_ATTDEF);
		 }
		 catch (XMLConfigurationException e) {
			 fWarnDuplicateAttdef = false;
		 }
		 try {
			 fWarnOnUndeclaredElemdef = componentManager.getFeature(WARN_ON_UNDECLARED_ELEMDEF);
		 }
		 catch (XMLConfigurationException e) {
			 fWarnOnUndeclaredElemdef = false;
		 }
		 fErrorReporter = (XMLErrorReporter) componentManager.getProperty( Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY);
		 fSymbolTable = (SymbolTable) componentManager.getProperty( Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY);
		 try {
			 fGrammarPool = (XMLGrammarPool) componentManager.getProperty(GRAMMAR_POOL);
		 }
		 catch (XMLConfigurationException e) {
			 fGrammarPool = null;
		 }
		 try {
			 fValidator = (XMLDTDValidator) componentManager.getProperty(DTD_VALIDATOR);
		 }
		 catch (XMLConfigurationException e) {
			 fValidator = null;
		 }
		 catch (ClassCastException e) {
			 fValidator = null;
		 }
		 if (fValidator != null) {
			 fGrammarBucket = fValidator.getGrammarBucket();
		 }
		 else {
			 fGrammarBucket = null;
		 }
		 reset();
	 }
	 protected void reset() {
		 fDTDGrammar = null;
		 fInDTDIgnore = false;
		 fNDataDeclNotations.clear();
		 if (fValidation) {
			 if (fNotationEnumVals == null) {
				 fNotationEnumVals = new HashMap();
			 }
			 fNotationEnumVals.clear();
			 fTableOfIDAttributeNames = new HashMap();
			 fTableOfNOTATIONAttributeNames = new HashMap();
		 }
	 }
	 public String[] getRecognizedFeatures() {
		 return (String[])(RECOGNIZED_FEATURES.clone());
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
	 }
	 public String[] getRecognizedProperties() {
		 return (String[])(RECOGNIZED_PROPERTIES.clone());
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
	 }
	 public Boolean getFeatureDefault(String featureId) {
		 for (int i = 0;
		 i < RECOGNIZED_FEATURES.length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return FEATURE_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 for (int i = 0;
		 i < RECOGNIZED_PROPERTIES.length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return PROPERTY_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public void setDTDHandler(XMLDTDHandler dtdHandler) {
		 fDTDHandler = dtdHandler;
	 }
	 public XMLDTDHandler getDTDHandler() {
		 return fDTDHandler;
	 }
	 public void setDTDContentModelHandler(XMLDTDContentModelHandler dtdContentModelHandler) {
		 fDTDContentModelHandler = dtdContentModelHandler;
	 }
	 public XMLDTDContentModelHandler getDTDContentModelHandler() {
		 return fDTDContentModelHandler;
	 }
	 public void startExternalSubset(XMLResourceIdentifier identifier, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.startExternalSubset(identifier, augs);
		 if(fDTDHandler != null){
			 fDTDHandler.startExternalSubset(identifier, augs);
		 }
	 }
	 public void endExternalSubset(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.endExternalSubset(augs);
		 if(fDTDHandler != null){
			 fDTDHandler.endExternalSubset(augs);
		 }
	 }
	 protected static void checkStandaloneEntityRef(String name, DTDGrammar grammar, XMLEntityDecl tempEntityDecl, XMLErrorReporter errorReporter) throws XNIException {
		 int entIndex = grammar.getEntityDeclIndex(name);
		 if (entIndex > -1) {
			 grammar.getEntityDecl(entIndex, tempEntityDecl);
			 if (tempEntityDecl.inExternal) {
				 errorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, ""MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE"", new Object[]{
				name}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
		 }
	 }
	 public void comment(XMLString text, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.comment(text, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.comment(text, augs);
		 }
	 }
	 public void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.processingInstruction(target, data, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.processingInstruction(target, data, augs);
		 }
	 }
	 public void startDTD(XMLLocator locator, Augmentations augs) throws XNIException {
		 fNDataDeclNotations.clear();
		 fDTDElementDecls.clear();
		 if( !fGrammarBucket.getActiveGrammar().isImmutable()) {
			 fDTDGrammar = fGrammarBucket.getActiveGrammar();
		 }
		 if(fDTDGrammar != null ) fDTDGrammar.startDTD(locator, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.startDTD(locator, augs);
		 }
	 }
	 public void ignoredCharacters(XMLString text, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null ) fDTDGrammar.ignoredCharacters(text, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.ignoredCharacters(text, augs);
		 }
	 }
	 public void textDecl(String version, String encoding, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null ) fDTDGrammar.textDecl(version, encoding, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.textDecl(version, encoding, augs);
		 }
	 }
	 public void startParameterEntity(String name, XMLResourceIdentifier identifier, String encoding, Augmentations augs) throws XNIException {
		 if (fPerformValidation && fDTDGrammar != null && fGrammarBucket.getStandalone()) {
			 checkStandaloneEntityRef(name, fDTDGrammar, fEntityDecl, fErrorReporter);
		 }
		 if(fDTDGrammar != null ) fDTDGrammar.startParameterEntity(name, identifier, encoding, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.startParameterEntity(name, identifier, encoding, augs);
		 }
	 }
	 public void endParameterEntity(String name, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null ) fDTDGrammar.endParameterEntity(name, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.endParameterEntity(name, augs);
		 }
	 }
	 public void elementDecl(String name, String contentModel, Augmentations augs) throws XNIException {
		 if (fValidation) {
			 if (fDTDElementDecls.contains(name)) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_ELEMENT_ALREADY_DECLARED"", new Object[]{
				 name}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
			 else {
				 fDTDElementDecls.add(name);
			 }
		 }
		 if(fDTDGrammar != null ) fDTDGrammar.elementDecl(name, contentModel, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.elementDecl(name, contentModel, augs);
		 }
	 }
	 public void startAttlist(String elementName, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null ) fDTDGrammar.startAttlist(elementName, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.startAttlist(elementName, augs);
		 }
	 }
	 public void attributeDecl(String elementName, String attributeName, String type, String[] enumeration, String defaultType, XMLString defaultValue, XMLString nonNormalizedDefaultValue, Augmentations augs) throws XNIException {
		 if (type != XMLSymbols.fCDATASymbol && defaultValue != null) {
			 normalizeDefaultAttrValue(defaultValue);
		 }
		 if (fValidation) {
			 booleanduplicateAttributeDef = false ;
			 DTDGrammar grammar = (fDTDGrammar != null? fDTDGrammar:fGrammarBucket.getActiveGrammar());
			 int elementIndex = grammar.getElementDeclIndex( elementName);
			 if (grammar.getAttributeDeclIndex(elementIndex, attributeName) != -1) {
				 duplicateAttributeDef = true ;
				 if(fWarnDuplicateAttdef){
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_DUPLICATE_ATTRIBUTE_DEFINITION"", new Object[]{
					 elementName, attributeName }
					, XMLErrorReporter.SEVERITY_WARNING );
				 }
			 }
			 if (type == XMLSymbols.fIDSymbol) {
				 if (defaultValue != null && defaultValue.length != 0) {
					 if (defaultType == null || !(defaultType == XMLSymbols.fIMPLIEDSymbol || defaultType == XMLSymbols.fREQUIREDSymbol)) {
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""IDDefaultTypeInvalid"", new Object[]{
						 attributeName}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
				 if (!fTableOfIDAttributeNames.containsKey(elementName)) {
					 fTableOfIDAttributeNames.put(elementName, attributeName);
				 }
				 else {
					 if(!duplicateAttributeDef){
						 String previousIDAttributeName = (String)fTableOfIDAttributeNames.get( elementName );
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_MORE_THAN_ONE_ID_ATTRIBUTE"", new Object[]{
						 elementName, previousIDAttributeName, attributeName}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
			 }
			 if (type == XMLSymbols.fNOTATIONSymbol) {
				 for (int i=0;
				 i<enumeration.length;
				 i++) {
					 fNotationEnumVals.put(enumeration[i], attributeName);
				 }
				 if (fTableOfNOTATIONAttributeNames.containsKey( elementName ) == false) {
					 fTableOfNOTATIONAttributeNames.put( elementName, attributeName);
				 }
				 else {
					 if(!duplicateAttributeDef){
						 String previousNOTATIONAttributeName = (String) fTableOfNOTATIONAttributeNames.get( elementName );
						 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE"", new Object[]{
						 elementName, previousNOTATIONAttributeName, attributeName}
						, XMLErrorReporter.SEVERITY_ERROR);
					 }
				 }
			 }
			 if (type == XMLSymbols.fENUMERATIONSymbol || type == XMLSymbols.fNOTATIONSymbol) {
				 outer: for (int i = 0;
				 i < enumeration.length;
				 ++i) {
					 for (int j = i + 1;
					 j < enumeration.length;
					 ++j) {
						 if (enumeration[i].equals(enumeration[j])) {
							 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, type == XMLSymbols.fENUMERATIONSymbol ? ""MSG_DISTINCT_TOKENS_IN_ENUMERATION"" : ""MSG_DISTINCT_NOTATION_IN_ENUMERATION"", new Object[]{
							 elementName, enumeration[i], attributeName }
							, XMLErrorReporter.SEVERITY_ERROR);
							 break outer;
						 }
					 }
				 }
			 }
			 boolean ok = true;
			 if (defaultValue != null && (defaultType == null || (defaultType != null && defaultType == XMLSymbols.fFIXEDSymbol))) {
				 String value = defaultValue.toString();
				 if (type == XMLSymbols.fNMTOKENSSymbol || type == XMLSymbols.fENTITIESSymbol || type == XMLSymbols.fIDREFSSymbol) {
					 StringTokenizer tokenizer = new StringTokenizer(value,"" "");
					 if (tokenizer.hasMoreTokens()) {
						 while (true) {
							 String nmtoken = tokenizer.nextToken();
							 if (type == XMLSymbols.fNMTOKENSSymbol) {
								 if (!isValidNmtoken(nmtoken)) {
									 ok = false;
									 break;
								 }
							 }
							 else if (type == XMLSymbols.fENTITIESSymbol || type == XMLSymbols.fIDREFSSymbol) {
								 if (!isValidName(nmtoken)) {
									 ok = false;
									 break;
								 }
							 }
							 if (!tokenizer.hasMoreTokens()) {
								 break;
							 }
						 }
					 }
				 }
				 else {
					 if (type == XMLSymbols.fENTITYSymbol || type == XMLSymbols.fIDSymbol || type == XMLSymbols.fIDREFSymbol || type == XMLSymbols.fNOTATIONSymbol) {
						 if (!isValidName(value)) {
							 ok = false;
						 }
					 }
					 else if (type == XMLSymbols.fNMTOKENSymbol || type == XMLSymbols.fENUMERATIONSymbol) {
						 if (!isValidNmtoken(value)) {
							 ok = false;
						 }
					 }
					 if (type == XMLSymbols.fNOTATIONSymbol || type == XMLSymbols.fENUMERATIONSymbol) {
						 ok = false;
						 for (int i=0;
						 i<enumeration.length;
						 i++) {
							 if (defaultValue.equals(enumeration[i])) {
								 ok = true;
							 }
						 }
					 }
				 }
				 if (!ok) {
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_ATT_DEFAULT_INVALID"", new Object[]{
					attributeName, value}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
		 }
		 if(fDTDGrammar != null) fDTDGrammar.attributeDecl(elementName, attributeName, type, enumeration, defaultType, defaultValue, nonNormalizedDefaultValue, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.attributeDecl(elementName, attributeName, type, enumeration, defaultType, defaultValue, nonNormalizedDefaultValue, augs);
		 }
	 }
	 public void endAttlist(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.endAttlist(augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.endAttlist(augs);
		 }
	 }
	 public void internalEntityDecl(String name, XMLString text, XMLString nonNormalizedText, Augmentations augs) throws XNIException {
		 DTDGrammar grammar = (fDTDGrammar != null? fDTDGrammar: fGrammarBucket.getActiveGrammar());
		 int index = grammar.getEntityDeclIndex(name) ;
		 if(index == -1){
			 if(fDTDGrammar != null) fDTDGrammar.internalEntityDecl(name, text, nonNormalizedText, augs);
			 if (fDTDHandler != null) {
				 fDTDHandler.internalEntityDecl(name, text, nonNormalizedText, augs);
			 }
		 }
	 }
	 public void externalEntityDecl(String name, XMLResourceIdentifier identifier, Augmentations augs) throws XNIException {
		 DTDGrammar grammar = (fDTDGrammar != null? fDTDGrammar: fGrammarBucket.getActiveGrammar());
		 int index = grammar.getEntityDeclIndex(name) ;
		 if(index == -1){
			 if(fDTDGrammar != null) fDTDGrammar.externalEntityDecl(name, identifier, augs);
			 if (fDTDHandler != null) {
				 fDTDHandler.externalEntityDecl(name, identifier, augs);
			 }
		 }
	 }
	 public void unparsedEntityDecl(String name, XMLResourceIdentifier identifier, String notation, Augmentations augs) throws XNIException {
		 if (fValidation) {
			 fNDataDeclNotations.put(name, notation);
		 }
		 if(fDTDGrammar != null) fDTDGrammar.unparsedEntityDecl(name, identifier, notation, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.unparsedEntityDecl(name, identifier, notation, augs);
		 }
	 }
	 public void notationDecl(String name, XMLResourceIdentifier identifier, Augmentations augs) throws XNIException {
		 if (fValidation) {
			 DTDGrammar grammar = (fDTDGrammar != null ? fDTDGrammar : fGrammarBucket.getActiveGrammar());
			 if (grammar.getNotationDeclIndex(name) != -1) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""UniqueNotationName"", new Object[]{
				name}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
		 }
		 if(fDTDGrammar != null) fDTDGrammar.notationDecl(name, identifier, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.notationDecl(name, identifier, augs);
		 }
	 }
	 public void startConditional(short type, Augmentations augs) throws XNIException {
		 fInDTDIgnore = type == XMLDTDHandler.CONDITIONAL_IGNORE;
		 if(fDTDGrammar != null) fDTDGrammar.startConditional(type, augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.startConditional(type, augs);
		 }
	 }
	 public void endConditional(Augmentations augs) throws XNIException {
		 fInDTDIgnore = false;
		 if(fDTDGrammar != null) fDTDGrammar.endConditional(augs);
		 if (fDTDHandler != null) {
			 fDTDHandler.endConditional(augs);
		 }
	 }
	 public void endDTD(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) {
			 fDTDGrammar.endDTD(augs);
			 if(fGrammarPool != null) fGrammarPool.cacheGrammars(XMLGrammarDescription.XML_DTD, new Grammar[] {
			fDTDGrammar}
			);
		 }
		 if (fValidation) {
			 DTDGrammar grammar = (fDTDGrammar != null? fDTDGrammar: fGrammarBucket.getActiveGrammar());
			 Iterator entities = fNDataDeclNotations.entrySet().iterator();
			 while (entities.hasNext()) {
				 Map.Entry entry = (Map.Entry) entities.next();
				 String notation = (String) entry.getValue();
				 if (grammar.getNotationDeclIndex(notation) == -1) {
					 String entity = (String) entry.getKey();
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL"", new Object[]{
					entity, notation}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
			 Iterator notationVals = fNotationEnumVals.entrySet().iterator();
			 while (notationVals.hasNext()) {
				 Map.Entry entry = (Map.Entry) notationVals.next();
				 String notation = (String) entry.getKey();
				 if (grammar.getNotationDeclIndex(notation) == -1) {
					 String attributeName = (String) entry.getValue();
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE"", new Object[]{
					attributeName, notation}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
			 Iterator elementsWithNotations = fTableOfNOTATIONAttributeNames.entrySet().iterator();
			 while (elementsWithNotations.hasNext()) {
				 Map.Entry entry = (Map.Entry) elementsWithNotations.next();
				 String elementName = (String) entry.getKey();
				 int elementIndex = grammar.getElementDeclIndex(elementName);
				 if (grammar.getContentSpecType(elementIndex) == XMLElementDecl.TYPE_EMPTY) {
					 String attributeName = (String) entry.getValue();
					 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""NoNotationOnEmptyElement"", new Object[]{
					elementName, attributeName}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
			 }
			 fTableOfIDAttributeNames = null;
			 fTableOfNOTATIONAttributeNames = null;
			 if (fWarnOnUndeclaredElemdef) {
				 checkDeclaredElements(grammar);
			 }
		 }
		 if (fDTDHandler != null) {
			 fDTDHandler.endDTD(augs);
		 }
	 }
	 public void setDTDSource(XMLDTDSource source ) {
		 fDTDSource = source;
	 }
	 public XMLDTDSource getDTDSource() {
		 return fDTDSource;
	 }
	 public void setDTDContentModelSource(XMLDTDContentModelSource source ) {
		 fDTDContentModelSource = source;
	 }
	 public XMLDTDContentModelSource getDTDContentModelSource() {
		 return fDTDContentModelSource;
	 }
	 public void startContentModel(String elementName, Augmentations augs) throws XNIException {
		 if (fValidation) {
			 fDTDElementDeclName = elementName;
			 fMixedElementTypes.clear();
		 }
		 if(fDTDGrammar != null) fDTDGrammar.startContentModel(elementName, augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.startContentModel(elementName, augs);
		 }
	 }
	 public void any(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.any(augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.any(augs);
		 }
	 }
	 public void empty(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.empty(augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.empty(augs);
		 }
	 }
	 public void startGroup(Augmentations augs) throws XNIException {
		 fMixed = false;
		 if(fDTDGrammar != null) fDTDGrammar.startGroup(augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.startGroup(augs);
		 }
	 }
	 public void pcdata(Augmentations augs) {
		 fMixed = true;
		 if(fDTDGrammar != null) fDTDGrammar.pcdata(augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.pcdata(augs);
		 }
	 }
	 public void element(String elementName, Augmentations augs) throws XNIException {
		 if (fMixed && fValidation) {
			 if (fMixedElementTypes.contains(elementName)) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""DuplicateTypeInMixedContent"", new Object[]{
				fDTDElementDeclName, elementName}
				, XMLErrorReporter.SEVERITY_ERROR);
			 }
			 else {
				 fMixedElementTypes.add(elementName);
			 }
		 }
		 if(fDTDGrammar != null) fDTDGrammar.element(elementName, augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.element(elementName, augs);
		 }
	 }
	 public void separator(short separator, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.separator(separator, augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.separator(separator, augs);
		 }
	 }
	 public void occurrence(short occurrence, Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.occurrence(occurrence, augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.occurrence(occurrence, augs);
		 }
	 }
	 public void endGroup(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.endGroup(augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.endGroup(augs);
		 }
	 }
	 public void endContentModel(Augmentations augs) throws XNIException {
		 if(fDTDGrammar != null) fDTDGrammar.endContentModel(augs);
		 if (fDTDContentModelHandler != null) {
			 fDTDContentModelHandler.endContentModel(augs);
		 }
	 }
	 private boolean normalizeDefaultAttrValue(XMLString value) {
		 boolean skipSpace = true;
		 int current = value.offset;
		 int end = value.offset + value.length;
		 for (int i = value.offset;
		 i < end;
		 i++) {
			 if (value.ch[i] == ' ') {
				 if (!skipSpace) {
					 value.ch[current++] = ' ';
					 skipSpace = true;
				 }
				 else {
				 }
			 }
			 else {
				 if (current != i) {
					 value.ch[current] = value.ch[i];
				 }
				 current++;
				 skipSpace = false;
			 }
		 }
		 if (current != end) {
			 if (skipSpace) {
				 current--;
			 }
			 value.length = current - value.offset;
			 return true;
		 }
		 return false;
	 }
	 protected boolean isValidNmtoken(String nmtoken) {
		 return XMLChar.isValidNmtoken(nmtoken);
	 }
	 protected boolean isValidName(String name) {
		 return XMLChar.isValidName(name);
	 }
	 private void checkDeclaredElements(DTDGrammar grammar) {
		 int elementIndex = grammar.getFirstElementDeclIndex();
		 XMLContentSpec contentSpec = new XMLContentSpec();
		 while (elementIndex >= 0) {
			 int type = grammar.getContentSpecType(elementIndex);
			 if (type == XMLElementDecl.TYPE_CHILDREN || type == XMLElementDecl.TYPE_MIXED) {
				 checkDeclaredElements(grammar, elementIndex, grammar.getContentSpecIndex(elementIndex), contentSpec);
			 }
			 elementIndex = grammar.getNextElementDeclIndex(elementIndex);
		 }
	 }
	 private void checkDeclaredElements(DTDGrammar grammar, int elementIndex, int contentSpecIndex, XMLContentSpec contentSpec) {
		 grammar.getContentSpec(contentSpecIndex, contentSpec);
		 if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_LEAF) {
			 String value = (String) contentSpec.value;
			 if (value != null && grammar.getElementDeclIndex(value) == -1) {
				 fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, ""UndeclaredElementInContentSpec"", new Object[]{
				grammar.getElementDeclName(elementIndex).rawname, value}
				, XMLErrorReporter.SEVERITY_WARNING);
			 }
		 }
		 else if ((contentSpec.type == XMLContentSpec.CONTENTSPECNODE_CHOICE) || (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_SEQ)) {
			 final int leftNode = ((int[])contentSpec.value)[0];
			 final int rightNode = ((int[])contentSpec.otherValue)[0];
			 checkDeclaredElements(grammar, elementIndex, leftNode, contentSpec);
			 checkDeclaredElements(grammar, elementIndex, rightNode, contentSpec);
		 }
		 else if (contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE || contentSpec.type == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE) {
			 final int leftNode = ((int[])contentSpec.value)[0];
			 checkDeclaredElements(grammar, elementIndex, leftNode, contentSpec);
		 }
	 }
}",1,0,0,0
"public class TwitterPullRecordReader implements IRecordReader<char[]> {
	 private Query query;
	 private Twitter twitter;
	 private int requestInterval = 5;
	 private QueryResult result;
	 private int nextTweetIndex = 0;
	 private long lastTweetIdReceived = 0;
	 private CharArrayRecord record;
	 private boolean stopped = false;
	 public TwitterPullRecordReader(Twitter twitter, String keywords, int requestInterval) {
		 this.twitter = twitter;
		 this.requestInterval = requestInterval;
		 this.query = new Query(keywords);
		 this.query.setCount(100);
		 this.record = new CharArrayRecord();
	 }
	 public void close() throws IOException {
	 }
	 public boolean hasNext() throws Exception {
		 return !stopped;
	 }
	 public IRawRecord<char[]> next() throws IOException, InterruptedException {
		 if (result == null || nextTweetIndex >= result.getTweets().size()) {
			 Thread.sleep(1000 * requestInterval);
			 query.setSinceId(lastTweetIdReceived);
			 try {
				 result = twitter.search(query);
			 }
			 catch (TwitterException e) {
				 throw HyracksDataException.create(e);
			 }
			 nextTweetIndex = 0;
		 }
		 if (result != null && !result.getTweets().isEmpty()) {
			 List<Status> tw = result.getTweets();
			 Status tweet = tw.get(nextTweetIndex++);
			 if (lastTweetIdReceived < tweet.getId()) {
				 lastTweetIdReceived = tweet.getId();
			 }
			 String jsonTweet = TwitterObjectFactory.getRawJSON(tweet);
			 record.set(jsonTweet);
			 return record;
		 }
		 else {
			 return null;
		 }
	 }
	 public boolean stop() {
		 stopped = true;
		 return true;
	 }
	 public void setFeedLogManager(FeedLogManager feedLogManager) {
	 }
	 public void setController(AbstractFeedDataFlowController controller) {
	 }
	 public boolean handleException(Throwable th) {
		 return false;
	 }
}",1,1,0,0
"private void handleRemainder() {
	 final int remainingRecordCount = incoming.getRecordCount() - remainderIndex;
	 assert this.memoryManager.incomingBatch == incoming;
	 final int recordsToProcess = Math.min(remainingRecordCount, memoryManager.getOutputRowCount());
	 if (!doAlloc(recordsToProcess)) {
		 outOfMemory = true;
		 return;
	 }
	 logger.trace(""handleRemainder: remaining RC {
	}
	, toProcess {
	}
	, remainder index {
	}
	, incoming {
	}
	, Project {
	}
	"", remainingRecordCount, recordsToProcess, remainderIndex, incoming, this);
	 long projectStartTime = System.currentTimeMillis();
	 final int projRecords = projector.projectRecords(this.incoming, remainderIndex, recordsToProcess, 0);
	 long projectEndTime = System.currentTimeMillis();
	 logger.trace(""handleRemainder: projection: records {
	}
	, time {
	}
	 ms"", projRecords,(projectEndTime - projectStartTime));
	 if (projRecords < remainingRecordCount) {
		 setValueCount(projRecords);
		 this.recordCount = projRecords;
		 remainderIndex += projRecords;
	 }
	 else {
		 setValueCount(remainingRecordCount);
		 hasRemainder = false;
		 remainderIndex = 0;
		 for (final VectorWrapper<T> v : incoming) {
			 v.clear();
		 }
		 this.recordCount = remainingRecordCount;
	 }
	 if (complexWriters != null) {
		 container.buildSchema(SelectionVectorMode.NONE);
	 }
	 memoryManager.updateOutgoingStats(projRecords);
	 RecordBatchStats.logRecordBatchStats(RecordBatchIOType.OUTPUT, this, getRecordBatchStatsContext());
 }",0,0,1,0
"public class TestClassExpression extends OntTestBase{
	 static public TestSuite suite() {
		 return new TestClassExpression( ""TestClassExpression"" );
	 }
	 public TestClassExpression( String name ) {
		 super( name );
	 }
	 public OntTestCase[] getTests() {
		 return new OntTestCase[] {
			 new OntTestCase( ""OntClass.super-class"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 A.addSuperClass( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.SUB_CLASS_OF() ) );
					 assertEquals( ""A should have super-class B"", B, A.getSuperClass() );
					 A.addSuperClass( C );
					 assertEquals( ""Cardinality should be 2"", 2, A.getCardinality( prof.SUB_CLASS_OF() ) );
					 iteratorTest( A.listSuperClasses(), new Object[] {
					C, B}
					 );
					 A.setSuperClass( C );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.SUB_CLASS_OF() ) );
					 assertEquals( ""A shuold have super-class C"", C, A.getSuperClass() );
					 assertTrue( ""A shuold not have super-class B"", !A.hasSuperClass( B, false ) );
					 A.removeSuperClass( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.SUB_CLASS_OF() ) );
					 A.removeSuperClass( C );
					 assertEquals( ""Cardinality should be 0"", 0, A.getCardinality( prof.SUB_CLASS_OF() ) );
				 }
			 }
			, new OntTestCase( ""OntClass.sub-class"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 A.addSubClass( B );
					 assertEquals( ""Cardinality should be 1"", 1, B.getCardinality( prof.SUB_CLASS_OF() ) );
					 assertEquals( ""A should have sub-class B"", B, A.getSubClass() );
					 A.addSubClass( C );
					 assertEquals( ""Cardinality should be 2"", 2, B.getCardinality( prof.SUB_CLASS_OF() ) + C.getCardinality( prof.SUB_CLASS_OF() ) );
					 iteratorTest( A.listSubClasses(), new Object[] {
					C, B}
					 );
					 A.setSubClass( C );
					 assertEquals( ""Cardinality should be 1"", 1, B.getCardinality( prof.SUB_CLASS_OF() ) + C.getCardinality( prof.SUB_CLASS_OF() ) );
					 assertEquals( ""A shuold have sub-class C"", C, A.getSubClass() );
					 assertTrue( ""A shuold not have sub-class B"", !A.hasSubClass( B, false ) );
					 A.removeSubClass( B );
					 assertTrue( ""A should have sub-class C"", A.hasSubClass( C, false ) );
					 A.removeSubClass( C );
					 assertTrue( ""A should not have sub-class C"", !A.hasSubClass( C, false ) );
				 }
			 }
			, new OntTestCase( ""OntClass.equivalentClass"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 A.addEquivalentClass( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.EQUIVALENT_CLASS() ) );
					 assertEquals( ""A have equivalentClass B"", B, A.getEquivalentClass() );
					 A.addEquivalentClass( C );
					 assertEquals( ""Cardinality should be 2"", 2, A.getCardinality( prof.EQUIVALENT_CLASS() ) );
					 iteratorTest( A.listEquivalentClasses(), new Object[] {
					C, B}
					 );
					 A.setEquivalentClass( C );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.EQUIVALENT_CLASS() ) );
					 assertEquals( ""A should have equivalentClass C"", C, A.getEquivalentClass() );
					 assertTrue( ""A should not have equivalentClass B"", !A.hasEquivalentClass( B ) );
					 A.removeEquivalentClass( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.EQUIVALENT_CLASS() ) );
					 A.removeEquivalentClass( C );
					 assertEquals( ""Cardinality should be 0"", 0, A.getCardinality( prof.EQUIVALENT_CLASS() ) );
				 }
			 }
			, new OntTestCase( ""OntClass.disjointWith"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 A.addDisjointWith( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.DISJOINT_WITH() ) );
					 assertEquals( ""A have be disjoint with B"", B, A.getDisjointWith() );
					 A.addDisjointWith( C );
					 assertEquals( ""Cardinality should be 2"", 2, A.getCardinality( prof.DISJOINT_WITH() ) );
					 iteratorTest( A.listDisjointWith(), new Object[] {
					C,B}
					 );
					 A.setDisjointWith( C );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.DISJOINT_WITH() ) );
					 assertEquals( ""A should be disjoint with C"", C, A.getDisjointWith() );
					 assertTrue( ""A should not be disjoint with B"", !A.isDisjointWith( B ) );
					 A.removeDisjointWith( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.DISJOINT_WITH() ) );
					 A.removeDisjointWith( C );
					 assertEquals( ""Cardinality should be 0"", 0, A.getCardinality( prof.DISJOINT_WITH() ) );
				 }
			 }
			, new OntTestCase( ""EnumeratedClass.oneOf"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 EnumeratedClass A = m.createEnumeratedClass( NS + ""A"", null );
					 OntResource a = m.getResource( NS + ""a"" ).as( OntResource.class );
					 OntResource b = m.getResource( NS + ""b"" ).as( OntResource.class );
					 A.addOneOf( a );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.ONE_OF() ) );
					 assertEquals( ""Size should be 1"", 1, A.getOneOf().size() );
					 assertTrue( ""A should have a as enumerated member"", A.getOneOf().contains( a ) );
					 A.addOneOf( b );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.ONE_OF() ) );
					 assertEquals( ""Size should be 2"", 2, A.getOneOf().size() );
					 iteratorTest( A.listOneOf(), new Object[] {
					a,b}
					 );
					 A.setOneOf( m.createList( new RDFNode[] {
					b}
					 ) );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.ONE_OF() ) );
					 assertEquals( ""Size should be 1"", 1, A.getOneOf().size() );
					 assertTrue( ""A should have b in the enum"", A.hasOneOf( b ) );
					 assertTrue( ""A should not have a in the enum"", !A.hasOneOf( a ) );
					 A.removeOneOf( a );
					 assertTrue( ""Should have b as an enum value"", A.hasOneOf( b ) );
					 A.removeOneOf( b );
					 assertTrue( ""Should not have b as an enum value"", !A.hasOneOf( b ) );
				 }
			 }
			, new OntTestCase( ""IntersectionClass.intersectionOf"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 IntersectionClass A = m.createIntersectionClass( NS + ""A"", null );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 A.addOperand( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.INTERSECTION_OF() ) );
					 assertEquals( ""Size should be 1"", 1, A.getOperands().size() );
					 assertTrue( ""A should have a as intersection member"", A.getOperands().contains( B ) );
					 A.addOperand( C );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.INTERSECTION_OF() ) );
					 assertEquals( ""Size should be 2"", 2, A.getOperands().size() );
					 iteratorTest( A.listOperands(), new Object[] {
					B,C}
					 );
					 ClosableIterator<? extends Resource> i = A.listOperands();
					 assertTrue( ""Argument should be an OntClass"", i.next() instanceof OntClass );
					 i.close();
					 A.setOperands( m.createList( new RDFNode[] {
					C}
					 ) );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.INTERSECTION_OF() ) );
					 assertEquals( ""Size should be 1"", 1, A.getOperands().size() );
					 assertTrue( ""A should have C in the intersection"", A.hasOperand( C ) );
					 assertTrue( ""A should not have B in the intersection"", !A.hasOperand( B ) );
					 A.removeOperand( B );
					 assertTrue( ""Should have C as an operand"", A.hasOperand( C ) );
					 A.removeOperand( C );
					 assertTrue( ""Should not have C as an operand"", !A.hasOperand( C ) );
				 }
			 }
			, new OntTestCase( ""UnionClass.unionOf"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 UnionClass A = m.createUnionClass( NS + ""A"", null );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 A.addOperand( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.UNION_OF() ) );
					 assertEquals( ""Size should be 1"", 1, A.getOperands().size() );
					 assertTrue( ""A should have a as union member"", A.getOperands().contains( B ) );
					 A.addOperand( C );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.UNION_OF() ) );
					 assertEquals( ""Size should be 2"", 2, A.getOperands().size() );
					 iteratorTest( A.listOperands(), new Object[] {
					B,C}
					 );
					 ClosableIterator<? extends Resource> i = A.listOperands();
					 assertTrue( ""Argument should be an OntClass"", i.next() instanceof OntClass );
					 i.close();
					 A.setOperands( m.createList( new RDFNode[] {
					C}
					 ) );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.UNION_OF() ) );
					 assertEquals( ""Size should be 1"", 1, A.getOperands().size() );
					 assertTrue( ""A should have C in the union"", A.hasOperand( C ) );
					 assertTrue( ""A should not have B in the union"", !A.hasOperand( B ) );
					 A.removeOperand( B );
					 assertTrue( ""Should have C as an operand"", A.hasOperand( C ) );
					 A.removeOperand( C );
					 assertTrue( ""Should not have C as an operand"", !A.hasOperand( C ) );
				 }
			 }
			, new OntTestCase( ""ComplementClass.complementOf"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 ComplementClass A = m.createComplementClass( NS + ""A"", null );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 boolean ex = false;
					 try {
						 A.addOperand( B );
					 }
					 catch (UnsupportedOperationException e) {
						ex = true;
					}
					 assertTrue( ""Should fail to add to a complement"", ex );
					 ex = false;
					 try {
						 A.addOperands( new NullIterator<Resource>() );
					 }
					 catch (UnsupportedOperationException e) {
						ex = true;
					}
					 assertTrue( ""Should fail to add to a complement"", ex );
					 ex = false;
					 try {
						 A.setOperands( m.createList( new RDFNode[] {
						C}
						 ) );
					 }
					 catch (UnsupportedOperationException e) {
						ex = true;
					}
					 assertTrue( ""Should fail to set a list to a complement"", ex );
					 A.setOperand( B );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.COMPLEMENT_OF() ) );
					 assertEquals( ""Complement should be B"", B, A.getOperand() );
					 iteratorTest( A.listOperands(), new Object[] {
					B}
					 );
					 A.setOperand( C );
					 assertEquals( ""Cardinality should be 1"", 1, A.getCardinality( prof.COMPLEMENT_OF() ) );
					 assertTrue( ""A should have C in the complement"", A.hasOperand( C ) );
					 assertTrue( ""A should not have B in the complement"", !A.hasOperand( B ) );
					 A.removeOperand( B );
					 assertTrue( ""Should have C as an operand"", A.hasOperand( C ) );
					 A.removeOperand( C );
					 assertTrue( ""Should not have C as an operand"", !A.hasOperand( C ) );
				 }
			 }
			, new OntTestCase( ""Restriction.onProperty"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntProperty q = m.createObjectProperty( NS + ""q"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 Restriction A = m.createAllValuesFromRestriction( NS + ""A"", p, B );
					 assertEquals( ""Restriction should be on property p"", p, A.getOnProperty() );
					 assertTrue( ""Restriction should be on property p"", A.onProperty( p ) );
					 assertTrue( ""Restriction should not be on property q"", !A.onProperty( q ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ON_PROPERTY() ));
					 A.setOnProperty( q );
					 assertEquals( ""Restriction should be on property q"", q, A.getOnProperty() );
					 assertTrue( ""Restriction should not be on property p"", !A.onProperty( p ) );
					 assertTrue( ""Restriction should not on property q"", A.onProperty( q ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ON_PROPERTY() ));
					 A.removeOnProperty( p );
					 assertTrue( ""Should have q as on property"", A.onProperty( q ) );
					 A.removeOnProperty( q );
					 assertTrue( ""Should not have q as on property"", !A.onProperty( q ) );
				 }
			 }
			, new OntTestCase( ""AllValuesFromRestriction.allValuesFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 AllValuesFromRestriction A = m.createAllValuesFromRestriction( NS + ""A"", p, B );
					 assertEquals( ""Restriction should be all values from B"", B, A.getAllValuesFrom() );
					 assertTrue( ""Restriction should be all values from B"", A.hasAllValuesFrom( B ) );
					 assertTrue( ""Restriction should not be all values from C"", !A.hasAllValuesFrom( C ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ALL_VALUES_FROM() ));
					 A.setAllValuesFrom( C );
					 assertEquals( ""Restriction should be all values from C"", C, A.getAllValuesFrom() );
					 assertTrue( ""Restriction should not be all values from B"", !A.hasAllValuesFrom( B ) );
					 assertTrue( ""Restriction should be all values from C"", A.hasAllValuesFrom( C ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ALL_VALUES_FROM() ));
					 A.removeAllValuesFrom( C );
					 assertTrue( ""Restriction should not be some values from C"", !A.hasAllValuesFrom( C ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.ALL_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""AllValuesFromRestriction.allValuesFrom.datatype"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 AllValuesFromRestriction A = m.createAllValuesFromRestriction( NS + ""A"", p, XSD.gDay );
					 assertEquals( ""Restriction should be all values from gDay"", XSD.gDay, A.getAllValuesFrom() );
					 assertTrue( ""Restriction should be all values from gDay"", A.hasAllValuesFrom( XSD.gDay ) );
					 assertTrue( ""Restriction should not be all values from decimal"", !A.hasAllValuesFrom( XSD.decimal ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ALL_VALUES_FROM() ));
					 A.setAllValuesFrom( XSD.gMonth );
					 assertEquals( ""Restriction should be all values from gMonth"", XSD.gMonth, A.getAllValuesFrom() );
					 assertTrue( ""Restriction should not be all values from gDay"", !A.hasAllValuesFrom( XSD.gDay ) );
					 assertTrue( ""Restriction should be all values from gMonth"", A.hasAllValuesFrom( XSD.gMonth ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ALL_VALUES_FROM() ));
					 A.removeAllValuesFrom( XSD.gMonth );
					 assertTrue( ""Restriction should not be some values from gMonth"", !A.hasAllValuesFrom( XSD.gMonth ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.ALL_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""AllValuesFromRestriction.allValuesFrom.literal"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 AllValuesFromRestriction A = m.createAllValuesFromRestriction( NS + ""A"", p, RDFS.Literal );
					 assertEquals( ""Restriction should be all values from literal"", RDFS.Literal, A.getAllValuesFrom() );
					 assertTrue( ""Restriction should be all values from literal"", A.hasAllValuesFrom( RDFS.Literal ) );
					 assertTrue( ""Restriction should not be all values from decimal"", !A.hasAllValuesFrom( XSD.decimal ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ALL_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""AllValuesFromRestriction.allValuesFrom.datarange"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 Literal x = m.createTypedLiteral( 1 );
					 Literal y = m.createTypedLiteral( 2 );
					 DataRange dr = m.createDataRange( m.createList( new RDFNode[] {
					x, y}
					 ) );
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 AllValuesFromRestriction A = m.createAllValuesFromRestriction( NS + ""A"", p, dr );
					 assertEquals( ""Restriction should be all values from dr"", dr, A.getAllValuesFrom() );
					 assertTrue( ""value should be a datarange"", A.getAllValuesFrom() instanceof DataRange );
					 assertTrue( ""Restriction should be all values from dr"", A.hasAllValuesFrom( dr ) );
					 assertTrue( ""Restriction should not be all values from decimal"", !A.hasAllValuesFrom( XSD.decimal ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.ALL_VALUES_FROM() ));
					 A.removeAllValuesFrom( dr );
					 assertTrue( ""Restriction should not be some values from gMonth"", !A.hasAllValuesFrom( dr ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.ALL_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""HasValueRestriction.hasValue"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 Individual b = m.createIndividual( B );
					 OntClass C = m.createClass( NS + ""C"" );
					 Individual c = m.createIndividual( C );
					 HasValueRestriction A = m.createHasValueRestriction( NS + ""A"", p, b );
					 assertEquals( ""Restriction should be has value b"", b, A.getHasValue() );
					 assertTrue( A.getHasValue() instanceof Individual );
					 assertTrue( ""Restriction should be to have value b"", A.hasValue( b ) );
					 assertTrue( ""Restriction should not be have value c"", !A.hasValue( c ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.HAS_VALUE() ));
					 A.setHasValue( c );
					 assertEquals( ""Restriction should be has value c"", c, A.getHasValue() );
					 assertTrue( ""Restriction should not be to have value b"", !A.hasValue( b ) );
					 assertTrue( ""Restriction should not be have value c"", A.hasValue( c ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.HAS_VALUE() ));
					 A.removeHasValue( c );
					 assertTrue( ""Restriction should not be to have value b"", !A.hasValue( b ) );
					 assertTrue( ""Restriction should not be have value c"", !A.hasValue( c ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.HAS_VALUE() ));
				 }
			 }
			, new OntTestCase( ""SomeValuesFromRestriction.someValuesFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 SomeValuesFromRestriction A = m.createSomeValuesFromRestriction( NS + ""A"", p, B );
					 assertEquals( ""Restriction should be some values from B"", B, A.getSomeValuesFrom() );
					 assertTrue( ""Restriction should be some values from B"", A.hasSomeValuesFrom( B ) );
					 assertTrue( ""Restriction should not be some values from C"", !A.hasSomeValuesFrom( C ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.SOME_VALUES_FROM() ));
					 A.setSomeValuesFrom( C );
					 assertEquals( ""Restriction should be some values from C"", C, A.getSomeValuesFrom() );
					 assertTrue( ""Restriction should not be some values from B"", !A.hasSomeValuesFrom( B ) );
					 assertTrue( ""Restriction should be some values from C"", A.hasSomeValuesFrom( C ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.SOME_VALUES_FROM() ));
					 A.removeSomeValuesFrom( C );
					 assertTrue( ""Restriction should not be some values from C"", !A.hasSomeValuesFrom( C ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.SOME_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""SomeValuesFromRestriction.SomeValuesFrom.datatype"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 SomeValuesFromRestriction A = m.createSomeValuesFromRestriction( NS + ""A"", p, XSD.gDay );
					 assertEquals( ""Restriction should be some values from gDay"", XSD.gDay, A.getSomeValuesFrom() );
					 assertTrue( ""Restriction should be some values from gDay"", A.hasSomeValuesFrom( XSD.gDay ) );
					 assertTrue( ""Restriction should not be some values from decimal"", !A.hasSomeValuesFrom( XSD.decimal ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.SOME_VALUES_FROM() ));
					 A.setSomeValuesFrom( XSD.gMonth );
					 assertEquals( ""Restriction should be some values from gMonth"", XSD.gMonth, A.getSomeValuesFrom() );
					 assertTrue( ""Restriction should not be some values from gDay"", !A.hasSomeValuesFrom( XSD.gDay ) );
					 assertTrue( ""Restriction should be some values from gMonth"", A.hasSomeValuesFrom( XSD.gMonth ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.SOME_VALUES_FROM() ));
					 A.removeSomeValuesFrom( XSD.gMonth );
					 assertTrue( ""Restriction should not be some values from gMonth"", !A.hasSomeValuesFrom( XSD.gMonth ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.SOME_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""SomeValuesFromRestriction.SomeValuesFrom.literal"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 SomeValuesFromRestriction A = m.createSomeValuesFromRestriction( NS + ""A"", p, RDFS.Literal );
					 assertEquals( ""Restriction should be some values from literal"", RDFS.Literal, A.getSomeValuesFrom() );
					 assertTrue( ""Restriction should be some values from literal"", A.hasSomeValuesFrom( RDFS.Literal ) );
					 assertTrue( ""Restriction should not be some values from decimal"", !A.hasSomeValuesFrom( XSD.decimal ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.SOME_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""SomeValuesFromRestriction.SomeValuesFrom.datarange"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 Literal x = m.createTypedLiteral( 1 );
					 Literal y = m.createTypedLiteral( 2 );
					 DataRange dr = m.createDataRange( m.createList( new RDFNode[] {
					x, y}
					 ) );
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 SomeValuesFromRestriction A = m.createSomeValuesFromRestriction( NS + ""A"", p, dr );
					 assertEquals( ""Restriction should be some values from dr"", dr, A.getSomeValuesFrom() );
					 assertTrue( ""value should be a datarange"", A.getSomeValuesFrom() instanceof DataRange );
					 assertTrue( ""Restriction should be some values from dr"", A.hasSomeValuesFrom( dr ) );
					 assertTrue( ""Restriction should not be some values from decimal"", !A.hasSomeValuesFrom( XSD.decimal ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.SOME_VALUES_FROM() ));
					 A.removeSomeValuesFrom( dr );
					 assertTrue( ""Restriction should not be some values from gMonth"", !A.hasSomeValuesFrom( dr ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.SOME_VALUES_FROM() ));
				 }
			 }
			, new OntTestCase( ""CardinalityRestriction.cardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 CardinalityRestriction A = m.createCardinalityRestriction( NS + ""A"", p, 3 );
					 assertEquals( ""Restriction should be cardinality 3"", 3, A.getCardinality() );
					 assertTrue( ""Restriction should be cardinality 3"", A.hasCardinality( 3 ) );
					 assertTrue( ""Restriction should not be cardinality 2"", !A.hasCardinality( 2 ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.CARDINALITY() ));
					 A.setCardinality( 2 );
					 assertEquals( ""Restriction should be cardinality 2"", 2, A.getCardinality() );
					 assertTrue( ""Restriction should not be cardinality 3"", !A.hasCardinality( 3 ) );
					 assertTrue( ""Restriction should be cardinality 2"", A.hasCardinality( 2 ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.CARDINALITY() ));
					 A.removeCardinality( 2 );
					 assertTrue( ""Restriction should not be cardinality 3"", !A.hasCardinality( 3 ) );
					 assertTrue( ""Restriction should not be cardinality 2"", !A.hasCardinality( 2 ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.CARDINALITY() ));
				 }
			 }
			, new OntTestCase( ""MinCardinalityRestriction.minCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 MinCardinalityRestriction A = m.createMinCardinalityRestriction( NS + ""A"", p, 3 );
					 assertEquals( ""Restriction should be min cardinality 3"", 3, A.getMinCardinality() );
					 assertTrue( ""Restriction should be min cardinality 3"", A.hasMinCardinality( 3 ) );
					 assertTrue( ""Restriction should not be min cardinality 2"", !A.hasMinCardinality( 2 ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.MIN_CARDINALITY() ));
					 A.setMinCardinality( 2 );
					 assertEquals( ""Restriction should be min cardinality 2"", 2, A.getMinCardinality() );
					 assertTrue( ""Restriction should not be min cardinality 3"", !A.hasMinCardinality( 3 ) );
					 assertTrue( ""Restriction should be min cardinality 2"", A.hasMinCardinality( 2 ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.MIN_CARDINALITY() ));
					 A.removeMinCardinality( 2 );
					 assertTrue( ""Restriction should not be cardinality 3"", !A.hasMinCardinality( 3 ) );
					 assertTrue( ""Restriction should not be cardinality 2"", !A.hasMinCardinality( 2 ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.MIN_CARDINALITY() ));
				 }
			 }
			, new OntTestCase( ""MaxCardinalityRestriction.maxCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 Profile prof = m.getProfile();
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 MaxCardinalityRestriction A = m.createMaxCardinalityRestriction( NS + ""A"", p, 3 );
					 assertEquals( ""Restriction should be max cardinality 3"", 3, A.getMaxCardinality() );
					 assertTrue( ""Restriction should be max cardinality 3"", A.hasMaxCardinality( 3 ) );
					 assertTrue( ""Restriction should not be max cardinality 2"", !A.hasMaxCardinality( 2 ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.MAX_CARDINALITY() ));
					 A.setMaxCardinality( 2 );
					 assertEquals( ""Restriction should be max cardinality 2"", 2, A.getMaxCardinality() );
					 assertTrue( ""Restriction should not be max cardinality 3"", !A.hasMaxCardinality( 3 ) );
					 assertTrue( ""Restriction should be max cardinality 2"", A.hasMaxCardinality( 2 ) );
					 assertEquals( ""cardinality should be 1 "", 1, A.getCardinality( prof.MAX_CARDINALITY() ));
					 A.removeMaxCardinality( 2 );
					 assertTrue( ""Restriction should not be cardinality 3"", !A.hasMaxCardinality( 3 ) );
					 assertTrue( ""Restriction should not be cardinality 2"", !A.hasMaxCardinality( 2 ) );
					 assertEquals( ""cardinality should be 0 "", 0, A.getCardinality( prof.MAX_CARDINALITY() ));
				 }
			 }
			, new OntTestCase( ""QualifiedRestriction.hasClassQ"", false, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 OntClass d = m.createClass( NS + ""D"" );
					 String nameA = ""ABCBA"";
					 QualifiedRestriction A = m.createMaxCardinalityQRestriction( NS + nameA, p, 3, c );
					 assertEquals( ""Restriction should hasClassQ c"", c, A.getHasClassQ() );
					 assertTrue( ""Restriction should be hasClassQ c"", A.hasHasClassQ( c ) );
					 assertFalse( ""Restriction should not be hasClassQ d"", A.hasHasClassQ( d ) );
					 A.setHasClassQ( d );
					 assertEquals( ""Restriction should hasClassQ d"", d, A.getHasClassQ() );
					 assertTrue( ""Restriction should be hasClassQ d"", A.hasHasClassQ( d ) );
					 assertFalse( ""Restriction should not be hasClassQ c"", A.hasHasClassQ( c ) );
					 assertTrue( ""Should be a qualified restriction"", m.getResource( NS + nameA ).canAs( QualifiedRestriction.class ) );
					 A.removeHasClassQ( d );
					 assertFalse( ""Should not be a qualified restriction"", m.getResource( NS + nameA ).canAs( QualifiedRestriction.class ) );
				 }
			 }
			, new OntTestCase( ""CardinalityQRestriction.cardinality"", false, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 CardinalityQRestriction A = m.createCardinalityQRestriction( NS + ""A"", p, 3, c );
					 assertEquals( ""Restriction should cardinality 3"", 3, A.getCardinalityQ() );
					 assertTrue( ""Restriction should be cardinality 3"", A.hasCardinalityQ( 3 ) );
					 assertFalse( ""Restriction should not be cardinality 1"", A.hasCardinalityQ( 1 ) );
					 A.setCardinalityQ( 1 );
					 assertEquals( ""Restriction should cardinality 1"", 1, A.getCardinalityQ() );
					 assertFalse( ""Restriction should not be cardinality 3"", A.hasCardinalityQ( 3 ) );
					 assertTrue( ""Restriction should be cardinality 1"", A.hasCardinalityQ( 1 ) );
					 assertTrue( ""Should be a qualified cardinality restriction"", m.getResource( NS + ""A"" ).canAs( CardinalityQRestriction.class ) );
					 A.removeCardinalityQ( 1 );
					 assertFalse( ""Should not be a qualified cardinality restriction"", m.getResource( NS + ""A"" ).canAs( CardinalityQRestriction.class ) );
				 }
			 }
			, new OntTestCase( ""MinCardinalityQRestriction.minCardinality"", false, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 MinCardinalityQRestriction A = m.createMinCardinalityQRestriction( NS + ""A"", p, 3, c );
					 assertEquals( ""Restriction should min cardinality 3"", 3, A.getMinCardinalityQ() );
					 assertTrue( ""Restriction should be min cardinality 3"", A.hasMinCardinalityQ( 3 ) );
					 assertFalse( ""Restriction should not be min cardinality 1"", A.hasMinCardinalityQ( 1 ) );
					 A.setMinCardinalityQ( 1 );
					 assertEquals( ""Restriction should min cardinality 1"", 1, A.getMinCardinalityQ() );
					 assertFalse( ""Restriction should not be min cardinality 3"", A.hasMinCardinalityQ( 3 ) );
					 assertTrue( ""Restriction should be min cardinality 1"", A.hasMinCardinalityQ( 1 ) );
					 assertTrue( ""Should be a qualified min cardinality restriction"", m.getResource( NS + ""A"" ).canAs( MinCardinalityQRestriction.class ) );
					 A.removeMinCardinalityQ( 1 );
					 assertFalse( ""Should not be a qualified min cardinality restriction"", m.getResource( NS + ""A"" ).canAs( MinCardinalityQRestriction.class ) );
				 }
			 }
			, new OntTestCase( ""MaxCardinalityQRestriction.maxCardinality"", false, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntProperty p = m.createObjectProperty( NS + ""p"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 MaxCardinalityQRestriction A = m.createMaxCardinalityQRestriction( NS + ""A"", p, 3, c );
					 assertEquals( ""Restriction should max cardinality 3"", 3, A.getMaxCardinalityQ() );
					 assertTrue( ""Restriction should be max cardinality 3"", A.hasMaxCardinalityQ( 3 ) );
					 assertFalse( ""Restriction should not be max cardinality 1"", A.hasMaxCardinalityQ( 1 ) );
					 A.setMaxCardinalityQ( 1 );
					 assertEquals( ""Restriction should max cardinality 1"", 1, A.getMaxCardinalityQ() );
					 assertFalse( ""Restriction should not be max cardinality 3"", A.hasMaxCardinalityQ( 3 ) );
					 assertTrue( ""Restriction should be max cardinality 1"", A.hasMaxCardinalityQ( 1 ) );
					 assertTrue( ""Should be a qualified max cardinality restriction"", m.getResource( NS + ""A"" ).canAs( MaxCardinalityQRestriction.class ) );
					 A.removeMaxCardinalityQ( 1 );
					 assertFalse( ""Should not be a qualified max cardinality restriction"", m.getResource( NS + ""A"" ).canAs( MaxCardinalityQRestriction.class ) );
				 }
			 }
			, new OntTestCase( ""OntClass.subclass.fromFile"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 String lang = m_owlLang ? ""owl"" : ""rdfs"" ;
					 String fileName = ""file:testing/ontology/"" + lang + ""/ClassExpression/test.rdf"";
					 m.read( fileName );
					 OntClass A = m.createClass( NS + ""ClassA"" );
					 OntClass B = m.createClass( NS + ""ClassB"" );
					 iteratorTest( A.listSuperClasses(), new Object[] {
					B}
					 );
					 iteratorTest( B.listSubClasses(), new Object[] {
					A}
					 );
				 }
			 }
			, new OntTestCase( ""OntClass.equivalentClass.fromFile"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 String lang = m_owlLang ? ""owl"" : ""rdfs"" ;
					 String fileName = ""file:testing/ontology/"" + lang + ""/ClassExpression/test.rdf"";
					 m.read( fileName );
					 OntClass A = m.createClass( NS + ""ClassA"" );
					 OntClass C = m.createClass( NS + ""ClassC"" );
					 assertTrue( ""A should be equiv to C"", A.hasEquivalentClass( C ) );
				 }
			 }
			, new OntTestCase( ""OntClass.disjoint.fromFile"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 String lang = m_owlLang ? ""owl"" : ""rdfs"" ;
					 String fileName = ""file:testing/ontology/"" + lang + ""/ClassExpression/test.rdf"";
					 m.read( fileName );
					 OntClass A = m.createClass( NS + ""ClassA"" );
					 OntClass D = m.createClass( NS + ""ClassD"" );
					 assertTrue( ""A should be disjoint with D"", A.isDisjointWith( D ) );
				 }
			 }
			, new OntTestCase( ""OntClass.isEnumeratedClass"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 Individual x = m.createIndividual( NS + ""x"", b );
					 Individual y = m.createIndividual( NS + ""y"", b );
					 OntClass a = m.createEnumeratedClass( NS + ""A"", m.createList( new RDFNode[] {
					x, y}
					 ) );
					 assertTrue( ""enumerated class test not correct"", a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.isIntersectionClass"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 OntClass a = m.createIntersectionClass( NS + ""A"", m.createList( new RDFNode[] {
					b,c}
					 ) );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.isUnionClass"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 OntClass a = m.createUnionClass( NS + ""A"", m.createList( new RDFNode[] {
					b,c}
					 ) );
					 assertTrue( ""enumerated class test not correct"", !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.isComplementClass"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 OntClass a = m.createComplementClass( NS + ""A"", b );
					 assertTrue( ""enumerated class test not correct"", !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.isRestriction"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass a = m.createRestriction( null );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.toEnumeratedClass"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass a = m.createClass( NS + ""A"" );
					 assertTrue( ""enumerated class test not correct"", !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 Individual x = m.createIndividual( NS + ""x"", b );
					 Individual y = m.createIndividual( NS + ""y"", b );
					 a = a.convertToEnumeratedClass( m.createList( new RDFNode[] {
					x, y}
					 ) );
					 assertTrue( ""enumerated class test not correct"", a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.toIntersectionClass"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass a = m.createClass( NS + ""A"" );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 a = a.convertToIntersectionClass( m.createList( new RDFNode[] {
					b,c}
					 ) );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.toUnionClass"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass a = m.createClass( NS + ""A"" );
					 assertTrue( ""enumerated class test not correct"", !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 OntClass c = m.createClass( NS + ""C"" );
					 a = a.convertToUnionClass( m.createList( new RDFNode[] {
					b,c}
					 ) );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.toComplementClass"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass a = m.createClass( NS + ""A"" );
					 assertTrue( ""enumerated class test not correct"", !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 a = a.convertToComplementClass( b );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.toRestriction"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass a = m.createClass( NS + ""A"" );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", !a.isRestriction() );
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 a = a.convertToRestriction( p );
					 assertTrue( ""enumerated class test not correct"", m_owlLiteLang || !a.isEnumeratedClass() );
					 assertTrue( ""intersection class test not correct"", !a.isIntersectionClass() );
					 assertTrue( ""union class test not correct"", m_owlLiteLang || !a.isUnionClass() );
					 assertTrue( ""complement class test not correct"", m_owlLiteLang || !a.isComplementClass() );
					 assertTrue( ""restriction test not correct"", a.isRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.isAllValuesFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createAllValuesFromRestriction( null, p, b );
					 assertTrue( ""all values from test not correct"", a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.isSomeValuesFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createSomeValuesFromRestriction( null, p, b );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.isHasValue"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 OntClass b = m.createClass( NS + ""B"" );
					 Individual x = m.createIndividual( b );
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createHasValueRestriction( null, p, x );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.isCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createCardinalityRestriction( null, p, 3 );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.isMinCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createMinCardinalityRestriction( null, p, 1 );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.isMaxCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createMaxCardinalityRestriction( null, p, 5 );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.convertToAllValuesFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createRestriction( p );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 a = a.convertToAllValuesFromRestriction( b );
					 assertTrue( ""all values from test not correct"", a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.convertToSomeValuesFrom"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createRestriction( p );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 a = a.convertToSomeValuesFromRestriction( b );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.convertToHasValue"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createRestriction( p );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
					 OntClass b = m.createClass( NS + ""B"" );
					 Individual x = m.createIndividual( b );
					 a = a.convertToHasValueRestriction( x );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.convertCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createRestriction( p );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
					 a = a.convertToCardinalityRestriction( 3 );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.convertMinCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createRestriction( p );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
					 a = a.convertToMinCardinalityRestriction( 3 );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""Restriction.convertMaxCardinality"", true, true, false ) {
				 public void ontTest( OntModel m ) {
					 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
					 Restriction a = m.createRestriction( p );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", !a.isMaxCardinalityRestriction() );
					 a = a.convertToMaxCardinalityRestriction( 3 );
					 assertTrue( ""all values from test not correct"", !a.isAllValuesFromRestriction() );
					 assertTrue( ""some values from test not correct"", !a.isSomeValuesFromRestriction() );
					 assertTrue( ""has value test not correct"", m_owlLiteLang || !a.isHasValueRestriction() );
					 assertTrue( ""cardinality test not correct"", !a.isCardinalityRestriction() );
					 assertTrue( ""min cardinality test not correct"", !a.isMinCardinalityRestriction() );
					 assertTrue( ""max cardinality test not correct"", a.isMaxCardinalityRestriction() );
				 }
			 }
			, new OntTestCase( ""OntClass.listInstances"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass B = m.createClass( NS + ""B"" );
					 Individual a0 = m.createIndividual( A );
					 Individual a1 = m.createIndividual( NS + ""a1"", A );
					 Individual b0 = m.createIndividual( B );
					 m.createIndividual( NS + ""b1"", B );
					 b0.addRDFType( A );
					 iteratorTest( A.listInstances(), new Object[] {
					a0, a1, b0}
					 );
				 }
			 }
			, new OntTestCase( ""OntClass.listDefinedProperties"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 OntProperty p = m.createOntProperty( NS + ""p"" );
					 OntProperty q = m.createOntProperty( NS + ""q"" );
					 OntProperty r = m.createOntProperty( NS + ""r"" );
					 OntProperty s = m.createOntProperty( NS + ""s"" );
					 p.setDomain( A );
					 q.setDomain( A );
					 s.setDomain( C );
					 if (m_rdfsLang) {
						 iteratorTest( A.listDeclaredProperties(), new Object[] {
						p, q, r}
						 );
					 }
					 else {
						 Restriction r0 = m.createRestriction( r );
						 C.addSuperClass( r0 );
						 iteratorTest( A.listDeclaredProperties(), new Object[] {
						p, q, r}
						 );
						 iteratorTest( C.listDeclaredProperties(), new Object[] {
						s, r}
						 );
						 iteratorTest( r0.listDeclaredProperties(), new Object[] {
						r}
						 );
					 }
				 }
			 }
			, new OntTestCase( ""OntClass.listDefinedProperties.notAll"", true, true, true ) {
				 public void ontTest( OntModel m ) {
					 OntClass A = m.createClass( NS + ""A"" );
					 OntClass C = m.createClass( NS + ""C"" );
					 C.addSuperClass(A);
					 OntProperty p = m.createOntProperty( NS + ""p"" );
					 OntProperty q = m.createOntProperty( NS + ""q"" );
					 OntProperty s = m.createOntProperty( NS + ""s"" );
					 p.setDomain( A );
					 q.setDomain( A );
					 s.setDomain( C );
					 iteratorTest( C.listDeclaredProperties( false ), new Object[] {
					 p, q, s}
					 );
					 iteratorTest( C.listDeclaredProperties( true ), new Object[] {
					s}
					 );
					 assertNotNull( ""declared property should be an ont prop"", C.listDeclaredProperties( true ).next() );
					 assertNotNull( ""declared property should be an ont prop"", C.listDeclaredProperties( false ).next() );
				 }
			 }
			, new OntTestCase( ""DataRange.oneOf"", true, false, false ) {
				 public void ontTest( OntModel m ) {
					 Literal x = m.createTypedLiteral( 42 );
					 Literal y = m.createTypedLiteral( true );
					 Literal z = m.createTypedLiteral( ""life"" );
					 RDFList lits = m.createList( new RDFNode[] {
					x,y}
					 );
					 DataRange d0 = m.createDataRange( lits );
					 assertTrue( ""datarange should contain x"", d0.hasOneOf( x ) );
					 assertTrue( ""datarange should contain y"", d0.hasOneOf( y ) );
					 assertFalse( ""datarange should not contain z"", d0.hasOneOf( z ) );
					 d0.removeOneOf( z );
					 assertTrue( ""datarange should contain x"", d0.hasOneOf( x ) );
					 assertTrue( ""datarange should contain y"", d0.hasOneOf( y ) );
					 assertFalse( ""datarange should not contain z"", d0.hasOneOf( z ) );
					 d0.removeOneOf( x );
					 assertFalse( ""datarange should not contain x"", d0.hasOneOf( x ) );
					 assertTrue( ""datarange should contain y"", d0.hasOneOf( y ) );
					 assertFalse( ""datarange should not contain z"", d0.hasOneOf( z ) );
					 d0.addOneOf( z );
					 assertEquals( ""datarange should be size 2"", 2, d0.getOneOf().size() );
					 iteratorTest( d0.listOneOf(), new Object[] {
					y,z}
					 );
					 d0.setOneOf( m.createList( new RDFNode[] {
					x}
					 ) );
					 iteratorTest( d0.listOneOf(), new Object[] {
					x}
					 );
				 }
			 }
			, new OntTestCase( ""Remove intersection"", true, true, false ) {
				 protected void ontTest(OntModel m) {
					 String ns = ""http: OntClass a = m.createClass(ns + ""A"");
					 OntClass b = m.createClass(ns + ""B"");
					 long old = m.size();
					 RDFList members = m.createList(new RDFNode[] {
					 a, b }
					);
					 IntersectionClass intersectionClass = m.createIntersectionClass(null, members);
					 intersectionClass.remove();
					 assertEquals( old, m.size() );
				 }
			 }
			, new OntTestCase( ""Remove union"", true, false, false ) {
				 protected void ontTest(OntModel m) {
					 String ns = ""http: OntClass a = m.createClass(ns + ""A"");
					 OntClass b = m.createClass(ns + ""B"");
					 long old = m.size();
					 RDFList members = m.createList(new RDFNode[] {
					 a, b }
					);
					 UnionClass unionClass = m.createUnionClass(null, members);
					 unionClass.remove();
					 assertEquals( old, m.size() );
				 }
			 }
		 }
		;
	 }
}",1,0,0,0
"public class UserDao {
	 private static final String DEFAULT_USER_CREDENTIALS_PROPERTIES = ""users-credentials.properties"";
	 private static final Logger LOG = LoggerFactory.getLogger(UserDao.class);
	 private Properties userLogins;
	 public void init() {
		 loadFileLoginsDetails();
	 }
	 void loadFileLoginsDetails() {
		 InputStream inStr = null;
		 try {
			 Configuration configuration = ApplicationProperties.get();
			 inStr = ApplicationProperties.getFileAsInputStream(configuration, ""atlas.authentication.method.file.filename"", DEFAULT_USER_CREDENTIALS_PROPERTIES);
			 userLogins = new Properties();
			 userLogins.load(inStr);
		 }
		 catch (IOException | AtlasException e) {
			 LOG.error(""Error while reading user.properties file"", e);
			 throw new RuntimeException(e);
		 }
		 finally {
			 if(inStr != null) {
				 try {
					 inStr.close();
				 }
				 catch(Exception excp) {
				 }
			 }
		 }
	 }
	 public User loadUserByUsername(final String username) throws AuthenticationException {
		 String userdetailsStr = userLogins.getProperty(username);
		 if (userdetailsStr == null || userdetailsStr.isEmpty()) {
			 throw new UsernameNotFoundException(""Username not found."" + username);
		 }
		 String password = """";
		 String role = """";
		 String dataArr[] = userdetailsStr.split(""::"");
		 if (dataArr != null && dataArr.length == 2) {
			 role = dataArr[0];
			 password = dataArr[1];
		 }
		 else {
			 LOG.error(""User role credentials is not set properly for {
			}
			"", username);
			 throw new AtlasAuthenticationException(""User role credentials is not set properly for "" + username );
		 }
		 List<GrantedAuthority> grantedAuths = new ArrayList<>();
		 if (StringUtils.hasText(role)) {
			 grantedAuths.add(new SimpleGrantedAuthority(role));
		 }
		 else {
			 LOG.error(""User role credentials is not set properly for {
			}
			"", username);
			 throw new AtlasAuthenticationException(""User role credentials is not set properly for "" + username );
		 }
		 User userDetails = new User(username, password, grantedAuths);
		 return userDetails;
	 }
	 public void setUserLogins(Properties userLogins) {
		 this.userLogins = userLogins;
	 }
	 public static String getSha256Hash(String base) throws AtlasAuthenticationException {
		 try {
			 MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
			 byte[] hash = digest.digest(base.getBytes(""UTF-8""));
			 StringBuffer hexString = new StringBuffer();
			 for (byte aHash : hash) {
				 String hex = Integer.toHexString(0xff & aHash);
				 if (hex.length() == 1) hexString.append('0');
				 hexString.append(hex);
			 }
			 return hexString.toString();
		 }
		 catch (Exception ex) {
			 throw new AtlasAuthenticationException(""Exception while encoding password."", ex);
		 }
	 }
}",1,0,0,0
"public class GlobbingPathHelper {
	 public static String globPathAsRegex(String pathWithGlobs) {
		 if (pathWithGlobs == null) {
			 return null;
		 }
		 else if (!pathWithGlobs.contains(""*"")) {
			 return pathWithGlobs;
		 }
		 List<String> elements = Lists.newLinkedList(elements(pathWithGlobs));
		 StringBuffer sb = new StringBuffer();
		 sb.append(""\\Q"");
		 if (pathWithGlobs.startsWith(""/"")) {
			 sb.append(""/"");
		 }
		 if (elements.get(0).equals(""**"")) {
			 sb.append(""\\E[^/]*(/[^/]*)*\\Q"");
			 elements.remove(0);
		 }
		 int size = elements.size();
		 boolean endsWithStarStar = size == 0 ? false : elements.get(size - 1).equals(""**"");
		 if (endsWithStarStar) {
			 elements.remove(size - 1);
		 }
		 boolean addSlash = false;
		 for(int i=0;
		 i<elements.size();
		 i++) {
			 String pathElem = elements.get(i);
			 if (addSlash) {
				 sb.append(""/"");
			 }
			 if (pathElem.equals(""**"")) {
				 addSlash = false;
				 sb.append(""\\E([^/]*/)*\\Q"");
			 }
			 else {
				 sb.append(pathElem.replace(""*"", ""\\E[^/]*\\Q""));
				 addSlash = true;
			 }
		 }
		 if (endsWithStarStar) {
			 sb.append(""\\E(/[^/]*)*"");
		 }
		 else if (pathWithGlobs.endsWith(""/"")) {
			 sb.append(""/\\E"");
		 }
		 else {
			 sb.append(""\\E"");
		 }
		 return sb.toString();
	 }
}",1,0,0,0
"public class WicketTester extends BaseWicketTester{
	public static class DummyWebApplication extends WebApplication{
		public Class<? extends Page> getHomePage(){
			return DummyHomePage.class;
		}
		protected ISessionStore newSessionStore(){
			return new HttpSessionStore(this);
		}
		protected WebResponse newWebResponse(final HttpServletResponse servletResponse){
			return new WebResponse(servletResponse);
		}
		protected void outputDevelopmentModeWarning(){
		}
	}
	public static class NonPageCachingDummyWebApplication extends DummyWebApplication{
		protected ISessionStore newSessionStore(){
			return new SecondLevelCacheSessionStore(this, new IPageStore(){
				public void destroy(){
				}
				public Page getPage(String sessionId, String pagemap, int id, int versionNumber,int ajaxVersionNumber){
					return null;
				}
				public void pageAccessed(String sessionId, Page page){
				}
				public void removePage(String sessionId, String pagemap, int id){
				}
				public void storePage(String sessionId, Page page){
				}
				public void unbind(String sessionId){
				}
				public boolean containsPage(String sessionId, String pageMapName, int pageId,int pageVersion){
					return false;
				}
			}
			);
		}
	}
	private static final Logger log = LoggerFactory.getLogger(WicketTester.class);
	public WicketTester(){
		this(new DummyWebApplication());
	}
	public WicketTester(final Class<? extends Page> homePage){
		this(new WebApplication(){
			public Class<? extends Page> getHomePage(){
				return homePage;
			}
			protected ISessionStore newSessionStore(){
				return new HttpSessionStore(this);
			}
			protected WebResponse newWebResponse(final HttpServletResponse servletResponse){
				return new WebResponse(servletResponse);
			}
			protected void outputDevelopmentModeWarning(){
			}
		}
		);
	}
	public WicketTester(final WebApplication application){
		this(application, null);
	}
	public WicketTester(final WebApplication application, final String path){
		super(application, path);
	}
	public void assertAjaxLocation(){
		if (null != ((MockHttpServletResponse)getWicketResponse().getHttpServletResponse()).getRedirectLocation()){
			throw new AssertionFailedError(""Location header should *not* be present when using Ajax"");
		}
		String ajaxLocation = ((MockHttpServletResponse)getWicketResponse().getHttpServletResponse()).getHeader(""Ajax-Location"");
		if (null == ajaxLocation){
			throw new AssertionFailedError(""Ajax-Location header should be present when using Ajax"");
		}
		int statusCode = ((MockHttpServletResponse)getWicketResponse().getHttpServletResponse()).getStatus();
		if (statusCode != 200){
			throw new AssertionFailedError(""Expected HTTP status code to be 200 (OK)"");
		}
	}
	public void assertComponent(String path, Class<? extends Component> expectedComponentClass){
		assertResult(isComponent(path, expectedComponentClass));
	}
	public void assertComponentOnAjaxResponse(Component component){
		Result result = isComponentOnAjaxResponse(component);
		assertResult(result);
	}
	public void assertComponentOnAjaxResponse(String componentPath){
		assertComponentOnAjaxResponse(getComponentFromLastRenderedPage(componentPath));
	}
	public void assertContains(String pattern){
		assertResult(ifContains(pattern));
	}
	public void assertContainsNot(String pattern){
		assertResult(ifContainsNot(pattern));
	}
	public void assertErrorMessages(String[] expectedErrorMessages){
		List<Serializable> actualMessages = getMessages(FeedbackMessage.ERROR);
		List<Serializable> msgs = new ArrayList<Serializable>();
		for (Iterator<Serializable> iterator = actualMessages.iterator();
		 iterator.hasNext();
		){
			msgs.add(iterator.next().toString());
		}
		WicketTesterHelper.assertEquals(Arrays.asList(expectedErrorMessages), msgs);
	}
	public void assertInfoMessages(String[] expectedInfoMessages){
		List<Serializable> actualMessages = getMessages(FeedbackMessage.INFO);
		WicketTesterHelper.assertEquals(Arrays.asList(expectedInfoMessages), actualMessages);
	}
	public void assertFeedback(String path, String[] messages){
		final FeedbackPanel fbp = (FeedbackPanel)getComponentFromLastRenderedPage(path);
		final IModel<List<FeedbackMessage>> model = fbp.getFeedbackMessagesModel();
		final List<FeedbackMessage> renderedMessages = model.getObject();
		if (renderedMessages == null){
			fail(""feedback panel at path ["" + path + ""] returned null messages"");
		}
		if (messages.length != renderedMessages.size()){
			fail(""you expected "" + messages.length + "" messages for the feedback panel ["" + path +""], but there were actually "" + renderedMessages.size());
		}
		for (int i = 0;
		 i < messages.length && i < renderedMessages.size();
		 i++){
			final String expected = messages[i];
			final String actual = renderedMessages.get(i).getMessage().toString();
			assertResult(isEqual(expected, actual));
		}
	}
	public void assertInvisible(String path){
		assertResult(isInvisible(path));
	}
	public void assertLabel(String path, String expectedLabelText){
		Label label = (Label)getComponentFromLastRenderedPage(path);
		Assert.assertEquals(expectedLabelText, label.getDefaultModelObjectAsString());
	}
	public void assertModelValue(String path, Object expectedValue){
		Component component = getComponentFromLastRenderedPage(path);
		Assert.assertEquals(expectedValue, component.getDefaultModelObject());
	}
	public void assertListView(String path, List<?> expectedList){
		ListView<?> listView = (ListView<?>)getComponentFromLastRenderedPage(path);
		WicketTesterHelper.assertEquals(expectedList, listView.getList());
	}
	public void assertNoErrorMessage(){
		List<Serializable> messages = getMessages(FeedbackMessage.ERROR);
		Assert.assertTrue(""expect no error message, but contains\n"" + WicketTesterHelper.asLined(messages),messages.isEmpty());
	}
	public void assertNoInfoMessage(){
		List<Serializable> messages = getMessages(FeedbackMessage.INFO);
		Assert.assertTrue(""expect no info message, but contains\n"" + WicketTesterHelper.asLined(messages),messages.isEmpty());
	}
	public void assertPageLink(String path, Class<? extends Page> expectedPageClass){
		assertResult(isPageLink(path, expectedPageClass));
	}
	public void assertBookmarkablePageLink(final String id,final Class<? extends WebPage> pageClass, final String parameters){
		BookmarkablePageLink<?> pageLink = null;
		try{
			pageLink = (BookmarkablePageLink<?>)getComponentFromLastRenderedPage(id);
		}
		catch (ClassCastException e){
			throw new IllegalArgumentException(""Component with id:"" + id +"" is not a BookmarkablePageLink"");
		}
		Assert.assertEquals(""BookmarkablePageLink: "" + id + "" is pointing to the wrong page"",pageClass, pageLink.getPageClass());
		Assert.assertEquals(""One or more of the parameters associated with the BookmarkablePageLink: "" + id +"" do not match"", new PageParameters(parameters), pageLink.getPageParameters());
	}
	public void assertRenderedPage(Class<? extends Page> expectedRenderedPageClass){
		assertResult(isRenderedPage(expectedRenderedPageClass));
	}
	public void assertResultPage(final Class<?> clazz, final String filename) throws Exception{
		String document = getServletResponse().getDocument();
		DiffUtil.validatePage(document, clazz, filename, true);
	}
	public void assertResultPage(final String expectedDocument) throws Exception{
		String document = getServletResponse().getDocument();
		Assert.assertEquals(expectedDocument, document);
	}
	public void assertVisible(String path){
		assertResult(isVisible(path));
	}
	public void assertEnabled(String path){
		assertResult(isEnabled(path));
	}
	public void assertDisabled(String path){
		assertResult(isDisabled(path));
	}
	public void assertRequired(String path){
		assertResult(isRequired(path));
	}
	private void assertResult(Result result){
		if (result.wasFailed()){
			throw new AssertionFailedError(result.getMessage());
		}
	}
}",0,0,0,0
"static final class DemoControls extends CustomControls implements ActionListener, ChangeListener {
	 TransformAnim demo;
	 JSlider shapeSlider, stringSlider, imageSlider;
	 Font font = new Font(Font.SERIF, Font.BOLD, 10);
	 JToolBar toolbar;
	 ButtonBorder buttonBorder = new ButtonBorder();
	 public DemoControls(TransformAnim demo) {
		 super(demo.name);
		 this.demo = demo;
		 setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		 add(Box.createVerticalStrut(5));
		 JToolBar bar = new JToolBar(SwingConstants.VERTICAL);
		 bar.setFloatable(false);
		 shapeSlider = new JSlider(SwingConstants.HORIZONTAL,0,20,demo.numShapes);
		 shapeSlider.addChangeListener(this);
		 TitledBorder tb = new TitledBorder(new EtchedBorder());
		 tb.setTitleFont(font);
		 tb.setTitle(String.valueOf(demo.numShapes) + "" Shapes"");
		 shapeSlider.setBorder(tb);
		 shapeSlider.setOpaque(true);
		 shapeSlider.setPreferredSize(new Dimension(80,44));
		 bar.add(shapeSlider);
		 bar.addSeparator();
		 stringSlider = new JSlider(SwingConstants.HORIZONTAL,0,10,demo.numStrings);
		 stringSlider.addChangeListener(this);
		 tb = new TitledBorder(new EtchedBorder());
		 tb.setTitleFont(font);
		 tb.setTitle(String.valueOf(demo.numStrings) + "" Strings"");
		 stringSlider.setBorder(tb);
		 stringSlider.setOpaque(true);
		 stringSlider.setPreferredSize(new Dimension(80,44));
		 bar.add(stringSlider);
		 bar.addSeparator();
		 imageSlider = new JSlider(SwingConstants.HORIZONTAL,0,10,demo.numImages);
		 imageSlider.addChangeListener(this);
		 tb = new TitledBorder(new EtchedBorder());
		 tb.setTitleFont(font);
		 tb.setTitle(String.valueOf(demo.numImages) + "" Images"");
		 imageSlider.setBorder(tb);
		 imageSlider.setOpaque(true);
		 imageSlider.setPreferredSize(new Dimension(80,44));
		 bar.add(imageSlider);
		 bar.addSeparator();
		 add(bar);
		 toolbar = new JToolBar();
		 toolbar.setFloatable(false);
		 addButton(""T"", ""translate"", demo.doTranslate);
		 addButton(""R"", ""rotate"", demo.doRotate);
		 addButton(""SC"", ""scale"", demo.doScale);
		 addButton(""SH"", ""shear"", demo.doShear);
		 add(toolbar);
	 }
	 public void addButton(String s, String tt, boolean state) {
		 JToggleButton b = (JToggleButton) toolbar.add(new JToggleButton(s));
		 b.setFont(font);
		 b.setSelected(state);
		 b.setToolTipText(tt);
		 b.setFocusPainted(false);
		 b.setBorder(buttonBorder);
		 b.addActionListener(this);
	 }
	 public void actionPerformed(ActionEvent e) {
		 JToggleButton b = (JToggleButton) e.getSource();
		 if (b.getText().equals(""T"")) {
			 demo.doTranslate = b.isSelected();
		 }
		 else if (b.getText().equals(""R"")) {
			 demo.doRotate = b.isSelected();
		 }
		 else if (b.getText().equals(""SC"")) {
			 demo.doScale = b.isSelected();
		 }
		 else if (b.getText().equals(""SH"")) {
			 demo.doShear = b.isSelected();
		 }
		 if (!demo.animating.running()) {
			 demo.repaint();
		 }
	 }
	 public void stateChanged(ChangeEvent e) {
		 JSlider slider = (JSlider) e.getSource();
		 int value = slider.getValue();
		 TitledBorder tb = (TitledBorder) slider.getBorder();
		 if (slider.equals(shapeSlider)) {
			 tb.setTitle(String.valueOf(value) + "" Shapes"");
			 demo.setShapes(value);
		 }
		 else if (slider.equals(stringSlider)) {
			 tb.setTitle(String.valueOf(value) + "" Strings"");
			 demo.setStrings(value);
		 }
		 else if (slider.equals(imageSlider)) {
			 tb.setTitle(String.valueOf(value) + "" Images"");
			 demo.setImages(value);
		 }
		 if (!demo.animating.running()) {
			 demo.repaint();
		 }
		 slider.repaint();
	 }
	 public Dimension getPreferredSize() {
		 return new Dimension(80,38);
	 }
	 public void run() {
		 Thread me = Thread.currentThread();
		 while (thread == me) {
			 for (int i = 1;
			 i < toolbar.getComponentCount();
			 i++) {
				 try {
					 Thread.sleep(4444);
				 }
				 catch (InterruptedException e) {
					 return;
				 }
				 ((AbstractButton) toolbar.getComponentAtIndex(i)).doClick();
			 }
		 }
		 thread = null;
	 }
 }",1,0,0,0
"public Attribute_LineNumberTable(int attrLength, int line_number_table_length, LineNumber[] lineNumberTable);",0,0,0,0
"public void assign(HRegionInfo region, boolean setOfflineInZK) {
	 assign(region, setOfflineInZK, false);
 }",0,0,0,0
"private MimeType readMimeType(Element element) {
	 String name = null;
	 String description = null;
	 MimeType type = null;
	 NamedNodeMap attrs = element.getAttributes();
	 for (int i=0;
	 i<attrs.getLength();
	 i++) {
		 Attr attr = (Attr) attrs.item(i);
		 if (attr.getName().equals(""name"")) {
			 name = attr.getValue();
		 }
		 else if (attr.getName().equals(""description"")) {
			 description = attr.getValue();
		 }
	 }
	 if ((name == null) || (name.trim().equals(""""))) {
		 return null;
	 }
	 try {
		 type = new MimeType(name);
	 }
	 catch (MimeTypeException mte) {
		 if (logger.isLoggable(Level.INFO)) {
			 logger.log(Level.INFO, mte.toString() + "" ... Ignoring!"");
		 }
		 return null;
	 }
	 type.setDescription(description);
	 NodeList nodes = element.getChildNodes();
	 for (int i=0;
	 i<nodes.getLength();
	 i++) {
		 Node node = nodes.item(i);
		 if (node.getNodeType() == Node.ELEMENT_NODE) {
			 Element nodeElement = (Element) node;
			 if (nodeElement.getTagName().equals(""ext"")) {
				 readExt(nodeElement, type);
			 }
			 else if (nodeElement.getTagName().equals(""magic"")) {
				 readMagic(nodeElement, type);
			 }
		 }
	 }
	 return type;
 }",0,0,0,0
"private static class MultiPointList extends AbstractList<Point> {
	 private final MultiPoint mp;
	 public MultiPointList(MultiPoint mp) {
		 this.mp = mp;
	 }
	 public Point get(int index) {
		 return mp.getPoint(index);
	 }
	 public int size() {
		 return mp.getPointCount();
	 }
 }",1,1,0,0
"private void resolveLocalFileHeaderData(Map entriesWithoutUTF8Flag) throws IOException {
	 Enumeration e = Collections.enumeration(new HashSet(entries.keySet()));
	 while (e.hasMoreElements()) {
		 ZipEntry ze = (ZipEntry) e.nextElement();
		 OffsetEntry offsetEntry = (OffsetEntry) entries.get(ze);
		 long offset = offsetEntry.headerOffset;
		 archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);
		 byte[] b = new byte[SHORT];
		 archive.readFully(b);
		 int fileNameLen = ZipShort.getValue(b);
		 archive.readFully(b);
		 int extraFieldLen = ZipShort.getValue(b);
		 int lenToSkip = fileNameLen;
		 while (lenToSkip > 0) {
			 int skipped = archive.skipBytes(lenToSkip);
			 if (skipped <= 0) {
				 throw new RuntimeException(""failed to skip file name in"" + "" local file header"");
			 }
			 lenToSkip -= skipped;
		 }
		 byte[] localExtraData = new byte[extraFieldLen];
		 archive.readFully(localExtraData);
		 ze.setExtra(localExtraData);
		 offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT + fileNameLen + extraFieldLen;
		 if (entriesWithoutUTF8Flag.containsKey(ze)) {
			 entries.remove(ze);
			 setNameAndCommentFromExtraFields(ze, (NameAndComment) entriesWithoutUTF8Flag.get(ze));
			 entries.put(ze, offsetEntry);
		 }
	 }
 }",0,0,0,0
"public class Release {
	private final String id;
	private final ProjectKey projectKey;
	private final String name;
	private final String description;
	private final LocalDate date;
}",0,1,0,0
"public void doFTP() throws BuildException {
	 FTPClient ftp = null;
	 try {
		 task.log(""Opening FTP connection to "" + task.getServer(), Project.MSG_VERBOSE);
		 ftp = new FTPClient();
		 if (task.isConfigurationSet()) {
			 ftp = FTPConfigurator.configure(ftp, task);
		 }
		 ftp.setRemoteVerificationEnabled(task.getEnableRemoteVerification());
		 ftp.connect(task.getServer(), task.getPort());
		 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
			 throw new BuildException(""FTP connection failed: "" + ftp.getReplyString());
		 }
		 task.log(""connected"", Project.MSG_VERBOSE);
		 task.log(""logging in to FTP server"", Project.MSG_VERBOSE);
		 if ((task.getAccount() != null && !ftp.login(task.getUserid(), task.getPassword(), task.getAccount())) || (task.getAccount() == null && !ftp.login(task.getUserid(), task.getPassword()))) {
			 throw new BuildException(""Could not login to FTP server"");
		 }
		 task.log(""login succeeded"", Project.MSG_VERBOSE);
		 if (task.isBinary()) {
			 ftp.setFileType(org.apache.commons.net.ftp.FTP.BINARY_FILE_TYPE);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
			 }
		 }
		 else {
			 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
			 }
		 }
		 if (task.isPassive()) {
			 task.log(""entering passive mode"", Project.MSG_VERBOSE);
			 ftp.enterLocalPassiveMode();
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 throw new BuildException(""could not enter into passive "" + ""mode: "" + ftp.getReplyString());
			 }
		 }
		 if (task.getInitialSiteCommand() != null) {
			 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
			 final FTPClient lftp = ftp;
			 executeRetryable(h, new Retryable() {
				 public void execute() throws IOException {
					 doSiteCommand(lftp, task.getInitialSiteCommand());
				 }
			 }
			, ""initial site command: "" + task.getInitialSiteCommand());
		 }
		 if (task.getUmask() != null) {
			 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
			 final FTPClient lftp = ftp;
			 executeRetryable(h, new Retryable() {
				 public void execute() throws IOException {
					 doSiteCommand(lftp, ""umask "" + task.getUmask());
				 }
			 }
			, ""umask "" + task.getUmask());
		 }
		 if (task.getAction() == FTPTask.MK_DIR) {
			 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
			 final FTPClient lftp = ftp;
			 executeRetryable(h, new Retryable() {
				 public void execute() throws IOException {
					 makeRemoteDir(lftp, task.getRemotedir());
				 }
			 }
			, task.getRemotedir());
		 }
		 else if (task.getAction() == FTPTask.SITE_CMD) {
			 RetryHandler h = new RetryHandler(task.getRetriesAllowed(), task);
			 final FTPClient lftp = ftp;
			 executeRetryable(h, new Retryable() {
				 public void execute() throws IOException {
					 doSiteCommand(lftp, task.getSiteCommand());
				 }
			 }
			, ""Site Command: "" + task.getSiteCommand());
		 }
		 else {
			 if (task.getRemotedir() != null) {
				 task.log(""changing the remote directory"", Project.MSG_VERBOSE);
				 ftp.changeWorkingDirectory(task.getRemotedir());
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not change remote "" + ""directory: "" + ftp.getReplyString());
				 }
			 }
			 if (task.isNewer() && task.isTimeDiffAuto()) {
				 task.setTimeDiffMillis(getTimeDiff(ftp));
			 }
			 task.log(FTPTask.ACTION_STRS[task.getAction()] + "" "" + FTPTask.ACTION_TARGET_STRS[task.getAction()]);
			 transferFiles(ftp);
		 }
	 }
	 catch (IOException ex) {
		 throw new BuildException(""error during FTP transfer: "" + ex, ex);
	 }
	 finally {
		 if (ftp != null && ftp.isConnected()) {
			 try {
				 task.log(""disconnecting"", Project.MSG_VERBOSE);
				 ftp.logout();
				 ftp.disconnect();
			 }
			 catch (IOException ex) {
			 }
		 }
	 }
 }",0,0,1,0
"public abstract class PKWareExtraHeader implements ZipExtraField {
	 private final ZipShort headerId;
	 private byte[] localData;
	 private byte[] centralData;
	 protected PKWareExtraHeader(final ZipShort headerId) {
		 this.headerId = headerId;
	 }
	 public ZipShort getHeaderId() {
		 return headerId;
	 }
	 public void setLocalFileDataData(final byte[] data) {
		 localData = ZipUtil.copy(data);
	 }
	 public ZipShort getLocalFileDataLength() {
		 return new ZipShort(localData != null ? localData.length : 0);
	 }
	 public byte[] getLocalFileDataData() {
		 return ZipUtil.copy(localData);
	 }
	 public void setCentralDirectoryData(final byte[] data) {
		 centralData = ZipUtil.copy(data);
	 }
	 public ZipShort getCentralDirectoryLength() {
		 if (centralData != null) {
			 return new ZipShort(centralData.length);
		 }
		 return getLocalFileDataLength();
	 }
	 public byte[] getCentralDirectoryData() {
		 if (centralData != null) {
			 return ZipUtil.copy(centralData);
		 }
		 return getLocalFileDataData();
	 }
	 public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {
		 final byte[] tmp = new byte[length];
		 System.arraycopy(data, offset, tmp, 0, length);
		 setLocalFileDataData(tmp);
	 }
	 public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {
		 final byte[] tmp = new byte[length];
		 System.arraycopy(data, offset, tmp, 0, length);
		 setCentralDirectoryData(tmp);
		 if (localData == null) {
			 setLocalFileDataData(tmp);
		 }
	 }
	 public enum EncryptionAlgorithm {
		 DES(0x6601), RC2pre52(0x6602), TripleDES168(0x6603), TripleDES192(0x6609), AES128(0x660E), AES192(0x660F), AES256(0x6610), RC2(0x6702), RC4(0x6801), UNKNOWN(0xFFFF);
		 private final int code;
		 private static final Map<Integer, EncryptionAlgorithm> codeToEnum;
		 static {
			 final Map<Integer, EncryptionAlgorithm> cte = new HashMap<>();
			 for (final EncryptionAlgorithm method : values()) {
				 cte.put(method.getCode(), method);
			 }
			 codeToEnum = Collections.unmodifiableMap(cte);
		 }
		 EncryptionAlgorithm(final int code) {
			 this.code = code;
		 }
		 public int getCode() {
			 return code;
		 }
		 public static EncryptionAlgorithm getAlgorithmByCode(final int code) {
			 return codeToEnum.get(code);
		 }
	 }
	 public enum HashAlgorithm {
		 NONE(0), CRC32(1), MD5(0x8003), SHA1(0x8004), RIPEND160(0x8007), SHA256(0x800C), SHA384(0x800D), SHA512(0x800E);
		 private final int code;
		 private static final Map<Integer, HashAlgorithm> codeToEnum;
		 static {
			 final Map<Integer, HashAlgorithm> cte = new HashMap<>();
			 for (final HashAlgorithm method : values()) {
				 cte.put(method.getCode(), method);
			 }
			 codeToEnum = Collections.unmodifiableMap(cte);
		 }
		 HashAlgorithm(final int code) {
			 this.code = code;
		 }
		 public int getCode() {
			 return code;
		 }
		 public static HashAlgorithm getAlgorithmByCode(final int code) {
			 return codeToEnum.get(code);
		 }
	 }
}",0,1,0,0
"File getTmpFile(Block b) {
	 return new File(tmp, b.getBlockName());
 }",0,0,0,0
"public class SearchIndex extends AbstractQueryHandler {
	 public static final Collection<Name> VALID_SYSTEM_INDEX_NODE_TYPE_NAMES = Collections.unmodifiableCollection(Arrays.asList( NameConstants.NT_CHILDNODEDEFINITION, NameConstants.NT_FROZENNODE, NameConstants.NT_NODETYPE, NameConstants.NT_PROPERTYDEFINITION, NameConstants.NT_VERSION, NameConstants.NT_VERSIONEDCHILD, NameConstants.NT_VERSIONHISTORY, NameConstants.NT_VERSIONLABELS, NameConstants.REP_NODETYPES, NameConstants.REP_SYSTEM, NameConstants.REP_VERSIONSTORAGE, NameConstants.NT_BASE, NameConstants.MIX_REFERENCEABLE));
	 private static final DefaultQueryNodeFactory DEFAULT_QUERY_NODE_FACTORY = new DefaultQueryNodeFactory(VALID_SYSTEM_INDEX_NODE_TYPE_NAMES);
	 private static final Logger log = LoggerFactory.getLogger(SearchIndex.class);
	 private static final String NS_MAPPING_FILE = ""ns_mappings.properties"";
	 public static final int DEFAULT_MIN_MERGE_DOCS = 100;
	 public static final int DEFAULT_MAX_MERGE_DOCS = Integer.MAX_VALUE;
	 public static final int DEFAULT_MERGE_FACTOR = 10;
	 public static final int DEFAULT_MAX_FIELD_LENGTH = 10000;
	 public static final int DEFAULT_EXTRACTOR_POOL_SIZE = 0;
	 public static final int DEFAULT_EXTRACTOR_BACK_LOG = Integer.MAX_VALUE;
	 public static final long DEFAULT_EXTRACTOR_TIMEOUT = 100;
	 public static final int DEFAULT_TERM_INFOS_INDEX_DIVISOR = 1;
	 protected static final PathFactory PATH_FACTORY = PathFactoryImpl.getInstance();
	 protected static final Path ROOT_PATH;
	 protected static final Path JCR_SYSTEM_PATH;
	 static {
		 ROOT_PATH = PATH_FACTORY.create(NameConstants.ROOT);
		 try {
			 JCR_SYSTEM_PATH = PATH_FACTORY.create(ROOT_PATH, NameConstants.JCR_SYSTEM, false);
		 }
		 catch (RepositoryException e) {
			 throw new InternalError(e.getMessage());
		 }
	 }
	 protected MultiIndex index;
	 private final JackrabbitAnalyzer analyzer = new JackrabbitAnalyzer();
	 private String tikaConfigPath = null;
	 private String forkJavaCommand = null;
	 private Parser parser = null;
	 private NamespaceMappings nsMappings;
	 private String path;
	 private int minMergeDocs = DEFAULT_MIN_MERGE_DOCS;
	 private long maxVolatileIndexSize = 1024 * 1024;
	 private int volatileIdleTime = 3;
	 private long maxHistoryAge = 0;
	 private int maxMergeDocs = DEFAULT_MAX_MERGE_DOCS;
	 private int mergeFactor = DEFAULT_MERGE_FACTOR;
	 private int maxFieldLength = DEFAULT_MAX_FIELD_LENGTH;
	 private int maxExtractLength = -10;
	 private int extractorPoolSize = 2 * Runtime.getRuntime().availableProcessors();
	 private int extractorBackLog = DEFAULT_EXTRACTOR_BACK_LOG;
	 private long extractorTimeout = DEFAULT_EXTRACTOR_TIMEOUT;
	 private int bufferSize = 10;
	 private boolean useCompoundFile = true;
	 private boolean documentOrder = false;
	 private boolean forceConsistencyCheck = false;
	 private boolean consistencyCheckEnabled = false;
	 private boolean autoRepair = true;
	 private int cacheSize = 1000;
	 private int resultFetchSize = Integer.MAX_VALUE;
	 private boolean supportHighlighting = false;
	 private boolean sizeEstimate = false;
	 private Class<?> excerptProviderClass = DefaultHTMLExcerpt.class;
	 private String indexingConfigPath;
	 private Element indexingConfiguration;
	 private IndexingConfiguration indexingConfig;
	 private Class<?> indexingConfigurationClass = IndexingConfigurationImpl.class;
	 private Class<?> synonymProviderClass;
	 private SynonymProvider synProvider;
	 private String synonymProviderConfigPath;
	 private FileSystem synonymProviderConfigFs;
	 private IndexFormatVersion indexFormatVersion;
	 private Class<?> spellCheckerClass;
	 private SpellChecker spellChecker;
	 private Similarity similarity = Similarity.getDefault();
	 private String directoryManagerClass = FSDirectoryManager.class.getName();
	 private DirectoryManager directoryManager;
	 private boolean useSimpleFSDirectory = true;
	 private int termInfosIndexDivisor = DEFAULT_TERM_INFOS_INDEX_DIVISOR;
	 private SharedFieldComparatorSource scs;
	 private boolean initializeHierarchyCache = true;
	 private String redoLogFactoryClass = DefaultRedoLogFactory.class.getName();
	 private RedoLogFactory redoLogFactory;
	 private boolean closed = false;
	 protected void doInit() throws IOException {
		 QueryHandlerContext context = getContext();
		 if (path == null) {
			 throw new IOException(""SearchIndex requires 'path' parameter in configuration!"");
		 }
		 Set<NodeId> excludedIDs = new HashSet<NodeId>();
		 if (context.getExcludedNodeId() != null) {
			 excludedIDs.add(context.getExcludedNodeId());
		 }
		 synProvider = createSynonymProvider();
		 directoryManager = createDirectoryManager();
		 redoLogFactory = createRedoLogFactory();
		 if (context.getParentHandler() instanceof SearchIndex) {
			 SearchIndex sysIndex = (SearchIndex) context.getParentHandler();
			 nsMappings = sysIndex.getNamespaceMappings();
		 }
		 else {
			 File mapFile = new File(new File(path), NS_MAPPING_FILE);
			 if (mapFile.exists()) {
				 nsMappings = new FileBasedNamespaceMappings(mapFile);
			 }
			 else {
				 nsMappings = new NSRegistryBasedNamespaceMappings( context.getNamespaceRegistry());
			 }
		 }
		 scs = new SharedFieldComparatorSource( FieldNames.PROPERTIES, context.getItemStateManager(), context.getHierarchyManager(), nsMappings);
		 indexingConfig = createIndexingConfiguration(nsMappings);
		 analyzer.setIndexingConfig(indexingConfig);
		 parser = createParser();
		 index = new MultiIndex(this, excludedIDs);
		 if (index.numDocs() == 0) {
			 Path rootPath;
			 if (excludedIDs.isEmpty()) {
				 rootPath = JCR_SYSTEM_PATH;
			 }
			 else {
				 rootPath = ROOT_PATH;
			 }
			 index.createInitialIndex(context.getItemStateManager(), context.getRootId(), rootPath);
			 checkPendingJournalChanges(context);
		 }
		 if (consistencyCheckEnabled && (index.getRedoLogApplied() || forceConsistencyCheck)) {
			 log.info(""Running consistency check..."");
			 try {
				 ConsistencyCheck check = runConsistencyCheck();
				 if (autoRepair) {
					 check.repair(true);
				 }
				 else {
					 List<ConsistencyCheckError> errors = check.getErrors();
					 if (errors.size() == 0) {
						 log.info(""No errors detected."");
					 }
					 for (ConsistencyCheckError err : errors) {
						 log.info(err.toString());
					 }
				 }
			 }
			 catch (Exception e) {
				 log.warn(""Failed to run consistency check on index: "" + e);
			 }
		 }
		 spellChecker = createSpellChecker();
		 log.info(""Index initialized: {
		}
		 Version: {
		}
		"", new Object[]{
		path, index.getIndexFormatVersion()}
		);
		 if (!index.getIndexFormatVersion().equals(getIndexFormatVersion())) {
			 log.warn(""Using Version {
			}
			 for reading. Please re-index version "" + ""storage for optimal performance."", getIndexFormatVersion().getVersion());
		 }
	 }
	 public void addNode(NodeState node) throws RepositoryException, IOException {
		 throw new UnsupportedOperationException(""addNode"");
	 }
	 public void deleteNode(NodeId id) throws IOException {
		 throw new UnsupportedOperationException(""deleteNode"");
	 }
	 public void updateNodes(Iterator<NodeId> remove, Iterator<NodeState> add) throws RepositoryException, IOException {
		 checkOpen();
		 Map<NodeId, NodeState> aggregateRoots = new HashMap<NodeId, NodeState>();
		 Set<NodeId> removedIds = new HashSet<NodeId>();
		 Set<NodeId> addedIds = new HashSet<NodeId>();
		 long time = System.currentTimeMillis();
		 Collection<NodeId> removeCollection = new ArrayList<NodeId>();
		 while (remove.hasNext()) {
			 NodeId id = remove.next();
			 removeCollection.add(id);
			 removedIds.add(id);
		 }
		 Collection<Document> addCollection = new ArrayList<Document>();
		 while (add.hasNext()) {
			 NodeState state = add.next();
			 if (state != null) {
				 NodeId id = state.getNodeId();
				 addedIds.add(id);
				 retrieveAggregateRoot(state, aggregateRoots);
				 try {
					 addCollection.add(createDocument( state, getNamespaceMappings(), index.getIndexFormatVersion()));
				 }
				 catch (RepositoryException e) {
					 log.warn(""Exception while creating document for node: "" + state.getNodeId() + "": "" + e.toString());
				 }
			 }
		 }
		 time = System.currentTimeMillis() - time;
		 log.debug(""created the removeCollection {
		}
		 and addCollection {
		}
		 in {
		}
		ms"", new Object[] {
		removeCollection.size(), addCollection.size(), time}
		);
		 index.update(removeCollection, addCollection);
		 aggregateRoots.keySet().removeAll(addedIds);
		 retrieveAggregateRoot(removedIds, aggregateRoots);
		 if (!aggregateRoots.isEmpty()) {
			 Collection<Document> modified = new ArrayList<Document>(aggregateRoots.size());
			 for (NodeState state : aggregateRoots.values()) {
				 try {
					 modified.add(createDocument( state, getNamespaceMappings(), index.getIndexFormatVersion()));
				 }
				 catch (RepositoryException e) {
					 log.warn(""Exception while creating document for node: "" + state.getNodeId(), e);
				 }
			 }
			 index.update(aggregateRoots.keySet(), modified);
		 }
	 }
	 public ExecutableQuery createExecutableQuery( SessionContext sessionContext, String statement, String language) throws InvalidQueryException {
		 QueryImpl query = new QueryImpl( sessionContext, this, getContext().getPropertyTypeRegistry(), statement, language, getQueryNodeFactory());
		 query.setRespectDocumentOrder(documentOrder);
		 return query;
	 }
	 public Iterable<NodeId> getWeaklyReferringNodes(NodeId id) throws RepositoryException, IOException {
		 final List<Integer> docs = new ArrayList<Integer>();
		 final List<NodeId> ids = new ArrayList<NodeId>();
		 final IndexReader reader = getIndexReader();
		 try {
			 IndexSearcher searcher = new IndexSearcher(reader);
			 try {
				 Query q = new TermQuery(new Term( FieldNames.WEAK_REFS, id.toString()));
				 searcher.search(q, new AbstractHitCollector() {
					 public void collect(int doc, float score) {
						 docs.add(doc);
					 }
				 }
				);
			 }
			 finally {
				 searcher.close();
			 }
			 for (Integer doc : docs) {
				 Document d = reader.document(doc, FieldSelectors.UUID);
				 ids.add(new NodeId(d.get(FieldNames.UUID)));
			 }
		 }
		 finally {
			 Util.closeOrRelease(reader);
		 }
		 return ids;
	 }
	 List<Document> getNodeDocuments(NodeId id) throws RepositoryException, IOException {
		 final List<Integer> docIds = new ArrayList<Integer>(1);
		 final List<Document> docs = new ArrayList<Document>();
		 final IndexReader reader = getIndexReader();
		 try {
			 IndexSearcher searcher = new IndexSearcher(reader);
			 try {
				 Query q = new TermQuery(new Term(FieldNames.UUID, id.toString()));
				 searcher.search(q, new AbstractHitCollector() {
					 protected void collect(final int doc, final float score) {
						 docIds.add(doc);
					 }
				 }
				);
				 for (Integer docId : docIds) {
					 docs.add(reader.document(docId, FieldSelectors.UUID_AND_PARENT));
				 }
			 }
			 finally {
				 searcher.close();
			 }
		 }
		 finally {
			 Util.closeOrRelease(reader);
		 }
		 return docs;
	 }
	 protected DefaultQueryNodeFactory getQueryNodeFactory() {
		 return DEFAULT_QUERY_NODE_FACTORY;
	 }
	 public void flush() throws RepositoryException {
		 try {
			 index.waitUntilIndexingQueueIsEmpty();
			 index.safeFlush();
			 index.waitUntilIndexingQueueIsEmpty();
		 }
		 catch (IOException e) {
			 throw new RepositoryException(""Failed to flush the index"", e);
		 }
	 }
	 public void close() throws IOException {
		 if (synonymProviderConfigFs != null) {
			 try {
				 synonymProviderConfigFs.close();
			 }
			 catch (FileSystemException e) {
				 log.warn(""Exception while closing FileSystem"", e);
			 }
		 }
		 if (spellChecker != null) {
			 spellChecker.close();
		 }
		 index.close();
		 getContext().destroy();
		 super.close();
		 closed = true;
		 log.info(""Index closed: "" + path);
	 }
	 public MultiColumnQueryHits executeQuery(SessionImpl session, AbstractQueryImpl queryImpl, Query query, Path[] orderProps, boolean[] orderSpecs, String[] orderFuncs, long resultFetchHint) throws IOException {
		 checkOpen();
		 Sort sort = new Sort(createSortFields(orderProps, orderSpecs, orderFuncs));
		 final IndexReader reader = getIndexReader(queryImpl.needsSystemTree());
		 JackrabbitIndexSearcher searcher = new JackrabbitIndexSearcher( session, reader, getContext().getItemStateManager());
		 searcher.setSimilarity(getSimilarity());
		 return new FilterMultiColumnQueryHits( searcher.execute(query, sort, resultFetchHint, QueryImpl.DEFAULT_SELECTOR_NAME)) {
			 public void close() throws IOException {
				 try {
					 super.close();
				 }
				 finally {
					 Util.closeOrRelease(reader);
				 }
			 }
		 }
		;
	 }
	 public MultiColumnQueryHits executeQuery(SessionImpl session, MultiColumnQuery query, Ordering[] orderings, long resultFetchHint) throws IOException {
		 checkOpen();
		 final IndexReader reader = getIndexReader();
		 JackrabbitIndexSearcher searcher = new JackrabbitIndexSearcher( session, reader, getContext().getItemStateManager());
		 searcher.setSimilarity(getSimilarity());
		 return new FilterMultiColumnQueryHits( query.execute(searcher, orderings, resultFetchHint)) {
			 public void close() throws IOException {
				 try {
					 super.close();
				 }
				 finally {
					 Util.closeOrRelease(reader);
				 }
			 }
		 }
		;
	 }
	 public ExcerptProvider createExcerptProvider(Query query) throws IOException {
		 ExcerptProvider ep;
		 try {
			 ep = (ExcerptProvider) excerptProviderClass.newInstance();
		 }
		 catch (Exception e) {
			 throw Util.createIOException(e);
		 }
		 ep.init(query, this);
		 return ep;
	 }
	 public Analyzer getTextAnalyzer() {
		 return new LimitTokenCountAnalyzer(analyzer, getMaxFieldLength());
	 }
	 public String getTikaConfigPath() {
		 return tikaConfigPath;
	 }
	 public void setTikaConfigPath(String tikaConfigPath) {
		 this.tikaConfigPath = tikaConfigPath;
	 }
	 public String getForkJavaCommand() {
		 return forkJavaCommand;
	 }
	 public void setForkJavaCommand(String command) {
		 this.forkJavaCommand = command;
	 }
	 public Parser getParser() {
		 return parser;
	 }
	 private Parser createParser() {
		 URL url = null;
		 if (tikaConfigPath != null) {
			 File file = new File(tikaConfigPath);
			 if (file.exists()) {
				 try {
					 url = file.toURI().toURL();
				 }
				 catch (MalformedURLException e) {
					 log.warn(""Invalid Tika configuration path: "" + file, e);
				 }
			 }
			 else {
				 ClassLoader loader = SearchIndex.class.getClassLoader();
				 url = loader.getResource(tikaConfigPath);
			 }
		 }
		 if (url == null) {
			 url = SearchIndex.class.getResource(""tika-config.xml"");
		 }
		 TikaConfig config = null;
		 if (url != null) {
			 try {
				 config = new TikaConfig(url);
			 }
			 catch (Exception e) {
				 log.warn(""Tika configuration not available: "" + url, e);
			 }
		 }
		 if (config == null) {
			 config = TikaConfig.getDefaultConfig();
		 }
		 if (forkJavaCommand != null) {
			 ForkParser forkParser = new ForkParser( SearchIndex.class.getClassLoader(), new AutoDetectParser(config));
			 forkParser.setJavaCommand(forkJavaCommand);
			 forkParser.setPoolSize(extractorPoolSize);
			 return forkParser;
		 }
		 else {
			 return new AutoDetectParser(config);
		 }
	 }
	 public NamespaceMappings getNamespaceMappings() {
		 return nsMappings;
	 }
	 public IndexingConfiguration getIndexingConfig() {
		 return indexingConfig;
	 }
	 public SynonymProvider getSynonymProvider() {
		 if (synProvider != null) {
			 return synProvider;
		 }
		 else {
			 QueryHandler handler = getContext().getParentHandler();
			 if (handler instanceof SearchIndex) {
				 return ((SearchIndex) handler).getSynonymProvider();
			 }
			 else {
				 return null;
			 }
		 }
	 }
	 public SpellChecker getSpellChecker() {
		 return spellChecker;
	 }
	 public Similarity getSimilarity() {
		 return similarity;
	 }
	 public IndexReader getIndexReader() throws IOException {
		 return getIndexReader(true);
	 }
	 public IndexFormatVersion getIndexFormatVersion() {
		 if (indexFormatVersion == null) {
			 if (getContext().getParentHandler() instanceof SearchIndex) {
				 SearchIndex parent = (SearchIndex) getContext().getParentHandler();
				 if (parent.getIndexFormatVersion().getVersion() < index.getIndexFormatVersion().getVersion()) {
					 indexFormatVersion = parent.getIndexFormatVersion();
				 }
				 else {
					 indexFormatVersion = index.getIndexFormatVersion();
				 }
			 }
			 else {
				 indexFormatVersion = index.getIndexFormatVersion();
			 }
		 }
		 return indexFormatVersion;
	 }
	 public DirectoryManager getDirectoryManager() {
		 return directoryManager;
	 }
	 public RedoLogFactory getRedoLogFactory() {
		 return redoLogFactory;
	 }
	 public ConsistencyCheck runConsistencyCheck() throws IOException {
		 return index.runConsistencyCheck();
	 }
	 protected IndexReader getIndexReader(boolean includeSystemIndex) throws IOException {
		 QueryHandler parentHandler = getContext().getParentHandler();
		 CachingMultiIndexReader parentReader = null;
		 if (parentHandler instanceof SearchIndex && includeSystemIndex) {
			 parentReader = ((SearchIndex) parentHandler).index.getIndexReader();
		 }
		 IndexReader reader;
		 if (parentReader != null) {
			 CachingMultiIndexReader[] readers = {
			index.getIndexReader(), parentReader}
			;
			 reader = new CombinedIndexReader(readers);
		 }
		 else {
			 reader = index.getIndexReader();
		 }
		 return new JackrabbitIndexReader(reader);
	 }
	 protected SortField[] createSortFields(Path[] orderProps, boolean[] orderSpecs, String[] orderFuncs) {
		 List<SortField> sortFields = new ArrayList<SortField>();
		 for (int i = 0;
		 i < orderProps.length;
		 i++) {
			 if (orderProps[i].getLength() == 1 && NameConstants.JCR_SCORE.equals(orderProps[i].getName())) {
				 sortFields.add(new SortField(null, SortField.SCORE, orderSpecs[i]));
			 }
			 else {
				 if (""upper-case"".equals(orderFuncs[i])) {
					 sortFields.add(new SortField(orderProps[i].getString(), new UpperCaseSortComparator(scs), !orderSpecs[i]));
				 }
				 else if (""lower-case"".equals(orderFuncs[i])) {
					 sortFields.add(new SortField(orderProps[i].getString(), new LowerCaseSortComparator(scs), !orderSpecs[i]));
				 }
				 else if (""normalize"".equals(orderFuncs[i])) {
					 sortFields.add(new SortField(orderProps[i].getString(), new NormalizeSortComparator(scs), !orderSpecs[i]));
				 }
				 else {
					 sortFields.add(new SortField(orderProps[i].getString(), scs, !orderSpecs[i]));
				 }
			 }
		 }
		 return sortFields.toArray(new SortField[sortFields.size()]);
	 }
	 protected Ordering[] createOrderings(OrderingImpl[] orderings) throws RepositoryException {
		 Ordering[] ords = new Ordering[orderings.length];
		 for (int i = 0;
		 i < orderings.length;
		 i++) {
			 ords[i] = Ordering.fromQOM(orderings[i], scs, nsMappings);
		 }
		 return ords;
	 }
	 protected Document createDocument(NodeState node, NamespaceMappings nsMappings, IndexFormatVersion indexFormatVersion) throws RepositoryException {
		 NodeIndexer indexer = new NodeIndexer( node, getContext().getItemStateManager(), nsMappings, getContext().getExecutor(), parser);
		 indexer.setSupportHighlighting(supportHighlighting);
		 indexer.setIndexingConfiguration(indexingConfig);
		 indexer.setIndexFormatVersion(indexFormatVersion);
		 indexer.setMaxExtractLength(getMaxExtractLength());
		 Document doc = indexer.createDoc();
		 mergeAggregatedNodeIndexes(node, doc, indexFormatVersion);
		 return doc;
	 }
	 protected MultiIndex getIndex() {
		 return index;
	 }
	 protected SharedFieldComparatorSource getSortComparatorSource() {
		 return scs;
	 }
	 protected IndexingConfiguration createIndexingConfiguration(NamespaceMappings namespaceMappings) {
		 Element docElement = getIndexingConfigurationDOM();
		 if (docElement == null) {
			 return null;
		 }
		 try {
			 IndexingConfiguration idxCfg = (IndexingConfiguration) indexingConfigurationClass.newInstance();
			 idxCfg.init(docElement, getContext(), namespaceMappings);
			 return idxCfg;
		 }
		 catch (Exception e) {
			 log.warn(""Exception initializing indexing configuration from: "" + indexingConfigPath, e);
		 }
		 log.warn(indexingConfigPath + "" ignored."");
		 return null;
	 }
	 protected SynonymProvider createSynonymProvider() {
		 SynonymProvider sp = null;
		 if (synonymProviderClass != null) {
			 try {
				 sp = (SynonymProvider) synonymProviderClass.newInstance();
				 sp.initialize(createSynonymProviderConfigResource());
			 }
			 catch (Exception e) {
				 log.warn(""Exception initializing synonym provider: "" + synonymProviderClass, e);
				 sp = null;
			 }
		 }
		 return sp;
	 }
	 protected DirectoryManager createDirectoryManager() throws IOException {
		 try {
			 Class<?> clazz = Class.forName(directoryManagerClass);
			 if (!DirectoryManager.class.isAssignableFrom(clazz)) {
				 throw new IOException(directoryManagerClass + "" is not a DirectoryManager implementation"");
			 }
			 DirectoryManager df = (DirectoryManager) clazz.newInstance();
			 df.init(this);
			 return df;
		 }
		 catch (IOException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 IOException ex = new IOException();
			 ex.initCause(e);
			 throw ex;
		 }
	 }
	 protected RedoLogFactory createRedoLogFactory() throws IOException {
		 try {
			 Class<?> clazz = Class.forName(redoLogFactoryClass);
			 if (!RedoLogFactory.class.isAssignableFrom(clazz)) {
				 throw new IOException(redoLogFactoryClass + "" is not a RedoLogFactory implementation"");
			 }
			 return (RedoLogFactory) clazz.newInstance();
		 }
		 catch (Exception e) {
			 IOException ex = new IOException();
			 ex.initCause(e);
			 throw ex;
		 }
	 }
	 protected FileSystemResource createSynonymProviderConfigResource() throws FileSystemException, IOException {
		 if (synonymProviderConfigPath != null) {
			 FileSystemResource fsr;
			 if (synonymProviderConfigPath.endsWith(FileSystem.SEPARATOR)) {
				 throw new FileSystemException( ""Invalid synonymProviderConfigPath: "" + synonymProviderConfigPath);
			 }
			 if (fs == null) {
				 fs = new LocalFileSystem();
				 int lastSeparator = synonymProviderConfigPath.lastIndexOf( FileSystem.SEPARATOR_CHAR);
				 if (lastSeparator != -1) {
					 File root = new File(path, synonymProviderConfigPath.substring(0, lastSeparator));
					 ((LocalFileSystem) fs).setRoot(root.getCanonicalFile());
					 fs.init();
					 fsr = new FileSystemResource(fs, synonymProviderConfigPath.substring(lastSeparator + 1));
				 }
				 else {
					 ((LocalFileSystem) fs).setPath(path);
					 fs.init();
					 fsr = new FileSystemResource(fs, synonymProviderConfigPath);
				 }
				 synonymProviderConfigFs = fs;
			 }
			 else {
				 fsr = new FileSystemResource(fs, synonymProviderConfigPath);
			 }
			 return fsr;
		 }
		 else {
			 return null;
		 }
	 }
	 protected SpellChecker createSpellChecker() {
		 SpellChecker spCheck = null;
		 if (spellCheckerClass != null) {
			 try {
				 spCheck = (SpellChecker) spellCheckerClass.newInstance();
				 spCheck.init(this);
			 }
			 catch (Exception e) {
				 log.warn(""Exception initializing spell checker: "" + spellCheckerClass, e);
			 }
		 }
		 return spCheck;
	 }
	 protected Element getIndexingConfigurationDOM() {
		 if (indexingConfiguration != null) {
			 return indexingConfiguration;
		 }
		 if (indexingConfigPath == null) {
			 return null;
		 }
		 File config = new File(indexingConfigPath);
		 InputStream configStream = null;
		 if (!config.exists()) {
			 configStream = getClass().getResourceAsStream(indexingConfigPath);
			 if (configStream == null) {
				 log.warn(""File does not exist: "" + indexingConfigPath);
				 return null;
			 }
		 }
		 else if (!config.canRead()) {
			 log.warn(""Cannot read file: "" + indexingConfigPath);
			 return null;
		 }
		 try {
			 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			 DocumentBuilder builder = factory.newDocumentBuilder();
			 builder.setEntityResolver(new IndexingConfigurationEntityResolver());
			 if (configStream != null) {
				 indexingConfiguration = builder .parse(configStream).getDocumentElement();
			 }
			 else {
				 indexingConfiguration = builder .parse(config).getDocumentElement();
			 }
		 }
		 catch (ParserConfigurationException e) {
			 log.warn(""Unable to create XML parser"", e);
		 }
		 catch (IOException e) {
			 log.warn(""Exception parsing "" + indexingConfigPath, e);
		 }
		 catch (SAXException e) {
			 log.warn(""Exception parsing "" + indexingConfigPath, e);
		 }
		 finally {
			 if (configStream != null) {
				 try {
					 configStream.close();
				 }
				 catch (IOException e) {
				 }
			 }
		 }
		 return indexingConfiguration;
	 }
	 protected void mergeAggregatedNodeIndexes(NodeState state, Document doc, IndexFormatVersion ifv) {
		 if (indexingConfig != null) {
			 AggregateRule[] aggregateRules = indexingConfig.getAggregateRules();
			 if (aggregateRules == null) {
				 return;
			 }
			 try {
				 ItemStateManager ism = getContext().getItemStateManager();
				 for (AggregateRule aggregateRule : aggregateRules) {
					 boolean ruleMatched = false;
					 NodeState[] aggregates = aggregateRule.getAggregatedNodeStates(state);
					 if (aggregates != null) {
						 ruleMatched = true;
						 for (NodeState aggregate : aggregates) {
							 Document aDoc = createDocument(aggregate, getNamespaceMappings(), ifv);
							 Fieldable[] fulltextFields = aDoc.getFieldables(FieldNames.FULLTEXT);
							 if (fulltextFields != null) {
								 for (Fieldable fulltextField : fulltextFields) {
									 doc.add(fulltextField);
								 }
								 doc.add(new Field( FieldNames.AGGREGATED_NODE_UUID, false, aggregate.getNodeId().toString(), Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS, Field.TermVector.NO));
							 }
						 }
						 Fieldable[] fulltextFields = doc .getFieldables(FieldNames.FULLTEXT);
						 doc.removeFields(FieldNames.FULLTEXT);
						 Arrays.sort(fulltextFields, FIELDS_COMPARATOR_STORED);
						 for (Fieldable f : fulltextFields) {
							 doc.add(f);
						 }
					 }
					 PropertyState[] propStates = aggregateRule.getAggregatedPropertyStates(state);
					 if (propStates != null) {
						 ruleMatched = true;
						 for (PropertyState propState : propStates) {
							 String namePrefix = FieldNames.createNamedValue(getNamespaceMappings().translateName(propState.getName()), """");
							 NodeState parent = (NodeState) ism.getItemState(propState.getParentId());
							 Document aDoc = createDocument(parent, getNamespaceMappings(), ifv);
							 try {
								 Fieldable[] fields = aDoc.getFieldables(FieldNames.PROPERTIES);
								 for (Fieldable field : fields) {
									 TokenStream tokenStream = field.tokenStreamValue();
									 TermAttribute termAttribute = tokenStream.addAttribute(TermAttribute.class);
									 PayloadAttribute payloadAttribute = tokenStream.addAttribute(PayloadAttribute.class);
									 tokenStream.incrementToken();
									 tokenStream.end();
									 tokenStream.close();
									 String value = new String(termAttribute.termBuffer(), 0, termAttribute.termLength());
									 if (value.startsWith(namePrefix)) {
										 String rawValue = value.substring(namePrefix.length());
										 Path p = getRelativePath(state, propState);
										 String path = getNamespaceMappings().translatePath(p);
										 value = FieldNames.createNamedValue(path, rawValue);
										 termAttribute.setTermBuffer(value);
										 PropertyMetaData pdm = PropertyMetaData .fromByteArray(payloadAttribute .getPayload().getData());
										 doc.add(new Field(field.name(), new SingletonTokenStream(value, pdm.getPropertyType())));
										 doc.add(new Field( FieldNames.AGGREGATED_NODE_UUID, false, parent.getNodeId().toString(), Field.Store.NO, Field.Index.NOT_ANALYZED_NO_NORMS, Field.TermVector.NO));
										 if (pdm.getPropertyType() == PropertyType.STRING) {
											 Field ft = new Field( FieldNames.FULLTEXT, false, rawValue, Field.Store.YES, Field.Index.ANALYZED_NO_NORMS, Field.TermVector.NO);
											 doc.add(ft);
										 }
									 }
								 }
							 }
							 finally {
								 Util.disposeDocument(aDoc);
							 }
						 }
					 }
					 if (ruleMatched) {
						 break;
					 }
				 }
			 }
			 catch (NoSuchItemStateException e) {
				 log.info( ""Exception while building indexing aggregate for {
				}
				. Node is not available {
				}
				."", state.getNodeId(), e.getMessage());
			 }
			 catch (Exception e) {
				 log.warn(""Exception while building indexing aggregate for "" + state.getNodeId(), e);
			 }
		 }
	 }
	 private static final Comparator<Fieldable> FIELDS_COMPARATOR_STORED = new Comparator<Fieldable>() {
		 public int compare(Fieldable o1, Fieldable o2) {
			 return Boolean.valueOf(o2.isStored()).compareTo(o1.isStored());
		 }
	 }
	;
	 protected Path getRelativePath(NodeState nodeState, PropertyState propState) throws RepositoryException, ItemStateException {
		 HierarchyManager hmgr = getContext().getHierarchyManager();
		 Path nodePath = hmgr.getPath(nodeState.getId());
		 Path propPath = hmgr.getPath(propState.getId());
		 Path p = nodePath.computeRelativePath(propPath);
		 boolean clean = true;
		 Path.Element[] elements = p.getElements();
		 for (int i = 0;
		 i < elements.length;
		 i++) {
			 if (elements[i].getIndex() != 0) {
				 elements[i] = PATH_FACTORY.createElement(elements[i].getName());
				 clean = false;
			 }
		 }
		 if (!clean) {
			 p = PATH_FACTORY.create(elements);
		 }
		 return p.getNormalizedPath();
	 }
	 protected void retrieveAggregateRoot(NodeState state, Map<NodeId, NodeState> aggregates) {
		 retrieveAggregateRoot(state, aggregates, state.getNodeId().toString(), 0);
	 }
	 private void retrieveAggregateRoot(NodeState state, Map<NodeId, NodeState> aggregates, String originNodeId, long level) {
		 if (indexingConfig == null) {
			 return;
		 }
		 AggregateRule[] aggregateRules = indexingConfig.getAggregateRules();
		 if (aggregateRules == null) {
			 return;
		 }
		 for (AggregateRule aggregateRule : aggregateRules) {
			 NodeState root = null;
			 try {
				 root = aggregateRule.getAggregateRoot(state);
			 }
			 catch (Exception e) {
				 log.warn(""Unable to get aggregate root for "" + state.getNodeId(), e);
			 }
			 if (root == null) {
				 continue;
			 }
			 if (root.getNodeTypeName().equals(state.getNodeTypeName())) {
				 level++;
			 }
			 else {
				 level = 0;
			 }
			 if ((aggregateRule.getRecursiveAggregationLimit() == 0) || (aggregateRule.getRecursiveAggregationLimit() != 0 && level <= aggregateRule .getRecursiveAggregationLimit())) {
				 if (aggregates.put(root.getNodeId(), root) == null) {
					 retrieveAggregateRoot(root, aggregates, originNodeId, level);
				 }
			 }
			 else {
				 log.warn( ""Reached {
				}
				 levels of recursive aggregation for nodeId {
				}
				, type {
				}
				, will stop at nodeId {
				}
				. Are you sure this did not occur by mistake? Please check the indexing-configuration.xml."", new Object[] {
				 level, originNodeId, root.getNodeTypeName(), root.getNodeId() }
				);
			 }
		 }
	 }
	 protected void retrieveAggregateRoot( Set<NodeId> removedIds, Map<NodeId, NodeState> aggregates) {
		 if(removedIds.isEmpty() || indexingConfig == null){
			 return;
		 }
		 AggregateRule[] aggregateRules = indexingConfig.getAggregateRules();
		 if (aggregateRules == null) {
			 return;
		 }
		 int found = 0;
		 long time = System.currentTimeMillis();
		 try {
			 CachingMultiIndexReader reader = index.getIndexReader();
			 try {
				 Term aggregateIds = new Term(FieldNames.AGGREGATED_NODE_UUID, """");
				 TermDocs tDocs = reader.termDocs();
				 try {
					 ItemStateManager ism = getContext().getItemStateManager();
					 for (NodeId id : removedIds) {
						 aggregateIds = aggregateIds.createTerm(id.toString());
						 tDocs.seek(aggregateIds);
						 while (tDocs.next()) {
							 Document doc = reader.document( tDocs.doc(), FieldSelectors.UUID);
							 NodeId nId = new NodeId(doc.get(FieldNames.UUID));
							 NodeState nodeState = (NodeState) ism.getItemState(nId);
							 aggregates.put(nId, nodeState);
							 found++;
							 int sizeBefore = aggregates.size();
							 retrieveAggregateRoot(nodeState, aggregates);
							 found += aggregates.size() - sizeBefore;
						 }
					 }
				 }
				 finally {
					 tDocs.close();
				 }
			 }
			 finally {
				 reader.release();
			 }
		 }
		 catch (NoSuchItemStateException e) {
			 log.info( ""Exception while retrieving aggregate roots. Node is not available {
			}
			."", e.getMessage());
		 }
		 catch (Exception e) {
			 log.warn(""Exception while retrieving aggregate roots"", e);
		 }
		 time = System.currentTimeMillis() - time;
		 log.debug(""Retrieved {
		}
		 aggregate roots in {
		}
		 ms."", found, time);
	 }
	 protected static final class CombinedIndexReader extends MultiReader implements HierarchyResolver, MultiIndexReader {
		 private final CachingMultiIndexReader[] subReaders;
		 public CombinedIndexReader(CachingMultiIndexReader[] indexReaders) {
			 super(indexReaders);
			 this.subReaders = indexReaders;
		 }
		 public int[] getParents(int n, int[] docNumbers) throws IOException {
			 int i = readerIndex(n);
			 DocId id = subReaders[i].getParentDocId(n - starts[i]);
			 id = id.applyOffset(starts[i]);
			 return id.getDocumentNumbers(this, docNumbers);
		 }
		 public IndexReader[] getIndexReaders() {
			 IndexReader[] readers = new IndexReader[subReaders.length];
			 System.arraycopy(subReaders, 0, readers, 0, subReaders.length);
			 return readers;
		 }
		 public void release() throws IOException {
			 for (CachingMultiIndexReader subReader : subReaders) {
				 subReader.release();
			 }
		 }
		 public boolean equals(Object obj) {
			 if (obj instanceof CombinedIndexReader) {
				 CombinedIndexReader other = (CombinedIndexReader) obj;
				 return Arrays.equals(subReaders, other.subReaders);
			 }
			 return false;
		 }
		 public int hashCode() {
			 int hash = 0;
			 for (CachingMultiIndexReader subReader : subReaders) {
				 hash = 31 * hash + subReader.hashCode();
			 }
			 return hash;
		 }
		 public ForeignSegmentDocId createDocId(NodeId id) throws IOException {
			 for (CachingMultiIndexReader subReader : subReaders) {
				 ForeignSegmentDocId doc = subReader.createDocId(id);
				 if (doc != null) {
					 return doc;
				 }
			 }
			 return null;
		 }
		 public int getDocumentNumber(ForeignSegmentDocId docId) {
			 for (int i = 0;
			 i < subReaders.length;
			 i++) {
				 CachingMultiIndexReader subReader = subReaders[i];
				 int realDoc = subReader.getDocumentNumber(docId);
				 if (realDoc >= 0) {
					 return realDoc + starts[i];
				 }
			 }
			 return -1;
		 }
	 }
	 public void setAnalyzer(String analyzerClassName) {
		 analyzer.setDefaultAnalyzerClass(analyzerClassName);
	 }
	 public String getAnalyzer() {
		 return analyzer.getDefaultAnalyzerClass();
	 }
	 public void setPath(String path) {
		 this.path = path;
	 }
	 public String getPath() {
		 return path;
	 }
	 public void setUseCompoundFile(boolean b) {
		 useCompoundFile = b;
	 }
	 public boolean getUseCompoundFile() {
		 return useCompoundFile;
	 }
	 public void setMinMergeDocs(int minMergeDocs) {
		 this.minMergeDocs = minMergeDocs;
	 }
	 public int getMinMergeDocs() {
		 return minMergeDocs;
	 }
	 public void setVolatileIdleTime(int volatileIdleTime) {
		 this.volatileIdleTime = volatileIdleTime;
	 }
	 public int getVolatileIdleTime() {
		 return volatileIdleTime;
	 }
	 public void setMaxMergeDocs(int maxMergeDocs) {
		 this.maxMergeDocs = maxMergeDocs;
	 }
	 public int getMaxMergeDocs() {
		 return maxMergeDocs;
	 }
	 public void setMergeFactor(int mergeFactor) {
		 this.mergeFactor = mergeFactor;
	 }
	 public int getMergeFactor() {
		 return mergeFactor;
	 }
	 public void setBufferSize(int size) {
		 bufferSize = size;
	 }
	 public int getBufferSize() {
		 return bufferSize;
	 }
	 public void setRespectDocumentOrder(boolean docOrder) {
		 documentOrder = docOrder;
	 }
	 public boolean getRespectDocumentOrder() {
		 return documentOrder;
	 }
	 public void setForceConsistencyCheck(boolean b) {
		 forceConsistencyCheck = b;
	 }
	 public boolean getForceConsistencyCheck() {
		 return forceConsistencyCheck;
	 }
	 public void setAutoRepair(boolean b) {
		 autoRepair = b;
	 }
	 public boolean getAutoRepair() {
		 return autoRepair;
	 }
	 public void setCacheSize(int size) {
		 cacheSize = size;
	 }
	 public int getCacheSize() {
		 return cacheSize;
	 }
	 public void setMaxFieldLength(int length) {
		 maxFieldLength = length;
	 }
	 public int getMaxFieldLength() {
		 return maxFieldLength;
	 }
	 public void setMaxExtractLength(int length) {
		 maxExtractLength = length;
	 }
	 public int getMaxExtractLength() {
		 if (maxExtractLength < 0) {
			 return -maxExtractLength * maxFieldLength;
		 }
		 else {
			 return maxExtractLength;
		 }
	 }
	 public void setTextFilterClasses(String filterClasses) {
		 log.warn(""The textFilterClasses configuration parameter has"" + "" been deprecated, and the configured value will"" + "" be ignored: {
		}
		"", filterClasses);
	 }
	 public String getTextFilterClasses() {
		 return ""deprectated"";
	 }
	 public void setResultFetchSize(int size) {
		 resultFetchSize = size;
	 }
	 public int getResultFetchSize() {
		 return resultFetchSize;
	 }
	 public void setExtractorPoolSize(int numThreads) {
		 if (numThreads < 0) {
			 numThreads = 0;
		 }
		 extractorPoolSize = numThreads;
	 }
	 public int getExtractorPoolSize() {
		 return extractorPoolSize;
	 }
	 public void setExtractorBackLogSize(int backLog) {
		 extractorBackLog = backLog;
	 }
	 public int getExtractorBackLogSize() {
		 return extractorBackLog;
	 }
	 public void setExtractorTimeout(long timeout) {
		 extractorTimeout = timeout;
	 }
	 public long getExtractorTimeout() {
		 return extractorTimeout;
	 }
	 public void setSizeEstimate(boolean b) {
		 if (b) {
			 log.info(""Size estimation is enabled"");
		 }
		 this.sizeEstimate = b;
	 }
	 public boolean getSizeEstimate() {
		 return sizeEstimate;
	 }
	 public void setSupportHighlighting(boolean b) {
		 supportHighlighting = b;
	 }
	 public boolean getSupportHighlighting() {
		 return supportHighlighting;
	 }
	 public void setExcerptProviderClass(String className) {
		 try {
			 Class<?> clazz = Class.forName(className);
			 if (ExcerptProvider.class.isAssignableFrom(clazz)) {
				 excerptProviderClass = clazz;
			 }
			 else {
				 log.warn(""Invalid value for excerptProviderClass, {
				}
				 does "" + ""not implement ExcerptProvider interface."", className);
			 }
		 }
		 catch (ClassNotFoundException e) {
			 log.warn(""Invalid value for excerptProviderClass, class {
			}
			 not found."", className);
		 }
	 }
	 public String getExcerptProviderClass() {
		 return excerptProviderClass.getName();
	 }
	 public void setIndexingConfiguration(String path) {
		 indexingConfigPath = path;
	 }
	 public String getIndexingConfiguration() {
		 return indexingConfigPath;
	 }
	 public void setIndexingConfigurationClass(String className) {
		 try {
			 Class<?> clazz = Class.forName(className);
			 if (IndexingConfiguration.class.isAssignableFrom(clazz)) {
				 indexingConfigurationClass = clazz;
			 }
			 else {
				 log.warn(""Invalid value for indexingConfigurationClass, {
				}
				 "" + ""does not implement IndexingConfiguration interface."", className);
			 }
		 }
		 catch (ClassNotFoundException e) {
			 log.warn(""Invalid value for indexingConfigurationClass, class {
			}
			 not found."", className);
		 }
	 }
	 public String getIndexingConfigurationClass() {
		 return indexingConfigurationClass.getName();
	 }
	 public void setSynonymProviderClass(String className) {
		 try {
			 Class<?> clazz = Class.forName(className);
			 if (SynonymProvider.class.isAssignableFrom(clazz)) {
				 synonymProviderClass = clazz;
			 }
			 else {
				 log.warn(""Invalid value for synonymProviderClass, {
				}
				 "" + ""does not implement SynonymProvider interface."", className);
			 }
		 }
		 catch (ClassNotFoundException e) {
			 log.warn(""Invalid value for synonymProviderClass, class {
			}
			 not found."", className);
		 }
	 }
	 public String getSynonymProviderClass() {
		 if (synonymProviderClass != null) {
			 return synonymProviderClass.getName();
		 }
		 else {
			 return null;
		 }
	 }
	 public void setSpellCheckerClass(String className) {
		 try {
			 Class<?> clazz = Class.forName(className);
			 if (SpellChecker.class.isAssignableFrom(clazz)) {
				 spellCheckerClass = clazz;
			 }
			 else {
				 log.warn(""Invalid value for spellCheckerClass, {
				}
				 "" + ""does not implement SpellChecker interface."", className);
			 }
		 }
		 catch (ClassNotFoundException e) {
			 log.warn(""Invalid value for spellCheckerClass,"" + "" class {
			}
			 not found."", className);
		 }
	 }
	 public String getSpellCheckerClass() {
		 if (spellCheckerClass != null) {
			 return spellCheckerClass.getName();
		 }
		 else {
			 return null;
		 }
	 }
	 public void setEnableConsistencyCheck(boolean b) {
		 this.consistencyCheckEnabled = b;
	 }
	 public boolean getEnableConsistencyCheck() {
		 return consistencyCheckEnabled;
	 }
	 public void setSynonymProviderConfigPath(String path) {
		 synonymProviderConfigPath = path;
	 }
	 public String getSynonymProviderConfigPath() {
		 return synonymProviderConfigPath;
	 }
	 public void setSimilarityClass(String className) {
		 try {
			 Class<?> similarityClass = Class.forName(className);
			 similarity = (Similarity) similarityClass.newInstance();
		 }
		 catch (Exception e) {
			 log.warn(""Invalid Similarity class: "" + className, e);
		 }
	 }
	 public String getSimilarityClass() {
		 return similarity.getClass().getName();
	 }
	 public void setMaxVolatileIndexSize(long maxVolatileIndexSize) {
		 this.maxVolatileIndexSize = maxVolatileIndexSize;
	 }
	 public long getMaxVolatileIndexSize() {
		 return maxVolatileIndexSize;
	 }
	 public String getDirectoryManagerClass() {
		 return directoryManagerClass;
	 }
	 public void setDirectoryManagerClass(String className) {
		 this.directoryManagerClass = className;
	 }
	 public void setUseSimpleFSDirectory(boolean useSimpleFSDirectory) {
		 this.useSimpleFSDirectory = useSimpleFSDirectory;
	 }
	 public boolean isUseSimpleFSDirectory() {
		 return useSimpleFSDirectory;
	 }
	 public int getTermInfosIndexDivisor() {
		 return termInfosIndexDivisor;
	 }
	 public void setTermInfosIndexDivisor(int termInfosIndexDivisor) {
		 this.termInfosIndexDivisor = termInfosIndexDivisor;
	 }
	 public boolean isInitializeHierarchyCache() {
		 return initializeHierarchyCache;
	 }
	 public void setInitializeHierarchyCache(boolean initializeHierarchyCache) {
		 this.initializeHierarchyCache = initializeHierarchyCache;
	 }
	 public long getMaxHistoryAge() {
		 return maxHistoryAge;
	 }
	 public void setMaxHistoryAge(long maxHistoryAge) {
		 this.maxHistoryAge = maxHistoryAge;
	 }
	 public String getRedoLogFactoryClass() {
		 return redoLogFactoryClass;
	 }
	 public void setRedoLogFactoryClass(String className) {
		 this.redoLogFactoryClass = className;
	 }
	 private void checkPendingJournalChanges(QueryHandlerContext context) {
		 ClusterNode cn = context.getClusterNode();
		 if (cn == null) {
			 return;
		 }
		 List<NodeId> addedIds = new ArrayList<NodeId>();
		 long rev = cn.getRevision();
		 List<ChangeLogRecord> changes = getChangeLogRecords(rev, context.getWorkspace());
		 Iterator<ChangeLogRecord> iterator = changes.iterator();
		 while (iterator.hasNext()) {
			 ChangeLogRecord record = iterator.next();
			 for (ItemState state : record.getChanges().addedStates()) {
				 if (!state.isNode()) {
					 continue;
				 }
				 addedIds.add((NodeId) state.getId());
			 }
		 }
		 if (!addedIds.isEmpty()) {
			 Collection<NodeState> empty = Collections.emptyList();
			 try {
				 updateNodes(addedIds.iterator(), empty.iterator());
			 }
			 catch (Exception e) {
				 log.error(e.getMessage(), e);
			 }
		 }
	 }
	 protected void checkOpen() throws IOException {
		 if (closed) {
			 throw new IOException(""query handler closed and cannot be used anymore."");
		 }
	 }
	 private List<ChangeLogRecord> getChangeLogRecords(long revision, final String workspace) {
		 log.debug( ""Get changes from the Journal for revision {
		}
		 and workspace {
		}
		."", revision, workspace);
		 ClusterNode cn = getContext().getClusterNode();
		 if (cn == null) {
			 return Collections.emptyList();
		 }
		 Journal journal = cn.getJournal();
		 final List<ChangeLogRecord> events = new ArrayList<ChangeLogRecord>();
		 ClusterRecordDeserializer deserializer = new ClusterRecordDeserializer();
		 RecordIterator records = null;
		 try {
			 records = journal.getRecords(revision);
			 while (records.hasNext()) {
				 Record record = records.nextRecord();
				 if (!record.getProducerId().equals(cn.getId())) {
					 continue;
				 }
				 ClusterRecord r = null;
				 try {
					 r = deserializer.deserialize(record);
				 }
				 catch (JournalException e) {
					 log.error( ""Unable to read revision '"" + record.getRevision() + ""'."", e);
				 }
				 if (r == null) {
					 continue;
				 }
				 r.process(new ClusterRecordProcessor() {
					 public void process(ChangeLogRecord record) {
						 String eventW = record.getWorkspace();
						 if (eventW != null ? eventW.equals(workspace) : workspace == null) {
							 events.add(record);
						 }
					 }
					 public void process(LockRecord record) {
					 }
					 public void process(NamespaceRecord record) {
					 }
					 public void process(NodeTypeRecord record) {
					 }
					 public void process(PrivilegeRecord record) {
					 }
					 public void process(WorkspaceRecord record) {
					 }
				 }
				);
			 }
		 }
		 catch (JournalException e1) {
			 log.error(e1.getMessage(), e1);
		 }
		 finally {
			 if (records != null) {
				 records.close();
			 }
		 }
		 return events;
	 }
}",1,0,0,0
"public class PolicySecurityController extends SecurityController{
	 private static final byte[] secureCallerImplBytecode = loadBytecode();
	 private static final Map callers = new WeakHashMap();
	 private static class Loader extends SecureClassLoader implements GeneratedClassLoader {
		 private final CodeSource codeSource;
		 Loader(ClassLoader parent, CodeSource codeSource) {
			 super(parent);
			 this.codeSource = codeSource;
		 }
		 public Class defineClass(String name, byte[] data) {
			 return defineClass(name, data, 0, data.length, codeSource);
		 }
		 public void linkClass(Class cl) {
			 resolveClass(cl);
		 }
	 }
	 public GeneratedClassLoader createClassLoader(final ClassLoader parent, final Object securityDomain) {
		 return (Loader)AccessController.doPrivileged( new PrivilegedAction() {
			 public Object run() {
				 return new Loader(parent, (CodeSource)securityDomain);
			 }
		 }
		);
	 }
	 public Object getDynamicSecurityDomain(Object securityDomain) {
		 return securityDomain;
	 }
	 public Object callWithDomain(final Object securityDomain, final Context cx, Callable callable, Scriptable scope, Scriptable thisObj, Object[] args) {
		 final ClassLoader classLoader = (ClassLoader)AccessController.doPrivileged( new PrivilegedAction() {
			 public Object run() {
				 return cx.getApplicationClassLoader();
			 }
		 }
		);
		 final CodeSource codeSource = (CodeSource)securityDomain;
		 Map classLoaderMap;
		 synchronized(callers) {
			 classLoaderMap = (Map)callers.get(codeSource);
			 if(classLoaderMap == null) {
				 classLoaderMap = new WeakHashMap();
				 callers.put(codeSource, classLoaderMap);
			 }
		 }
		 SecureCaller caller;
		 synchronized(classLoaderMap) {
			 SoftReference ref = (SoftReference)classLoaderMap.get(classLoader);
			 if(ref != null) {
				 caller = (SecureCaller)ref.get();
			 }
			 else {
				 caller = null;
			 }
			 if(caller == null) {
				 try {
					 caller = (SecureCaller)AccessController.doPrivileged( new PrivilegedExceptionAction() {
						 public Object run() throws Exception {
							 Loader loader = new Loader(classLoader, codeSource);
							 Class c = loader.defineClass( SecureCaller.class.getName() + ""Impl"", secureCallerImplBytecode);
							 return c.newInstance();
						 }
					 }
					);
				 }
				 catch(PrivilegedActionException ex) {
					 throw new UndeclaredThrowableException(ex.getCause());
				 }
			 }
		 }
		 return caller.call(callable, cx, scope, thisObj, args);
	 }
	 public abstract static class SecureCaller {
		 public abstract Object call(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args);
	 }
	 private static byte[] loadBytecode() {
		 String secureCallerClassName = SecureCaller.class.getName();
		 ClassFileWriter cfw = new ClassFileWriter( secureCallerClassName + ""Impl"", secureCallerClassName, ""<generated>"");
		 cfw.startMethod(""<init>"", ""()V"", ClassFileWriter.ACC_PUBLIC);
		 cfw.addALoad(0);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, secureCallerClassName, ""<init>"", ""()V"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)1);
		 String callableCallSig = ""Lorg/mozilla/javascript/Context;
		"" + ""Lorg/mozilla/javascript/Scriptable;
		"" + ""Lorg/mozilla/javascript/Scriptable;
		"" + ""[Ljava/lang/Object;
		)Ljava/lang/Object;
		"";
		 cfw.startMethod(""call"", ""(Lorg/mozilla/javascript/Callable;
		"" + callableCallSig, (short)(ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_FINAL));
		 for(int i = 1;
		 i < 6;
		 ++i) {
			 cfw.addALoad(i);
		 }
		 cfw.addInvoke(ByteCode.INVOKEINTERFACE, ""org/mozilla/javascript/Callable"", ""call"", ""("" + callableCallSig);
		 cfw.add(ByteCode.ARETURN);
		 cfw.stopMethod((short)6);
		 return cfw.toByteArray();
	 }
}",0,0,0,0
"private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {
	 Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);
	 URLClassLoader cl = new URLClassLoader(new URL [] {
	dir.toURI().toURL()}
	, Main.class.getClassLoader());
	 String dirName = dir.getAbsolutePath();
	 DirTree dt = new DirTree(dir);
	 for (File f : dt.getFiles()) {
		 if (!f.getName().endsWith("".class"")) continue;
		 String className = f.getAbsolutePath().substring(dirName.length());
		 if (className.startsWith(File.separator)) className = className.substring(1);
		 className = className.substring(0, className.length() - "".class"".length());
		 className = className.replace(File.separator, ""."");
		 InputStream is = new FileInputStream(f);
		 byte[] b;
		 try {
			 ClassReader cr = new ClassReader(is);
			 ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);
			 TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);
			 cr.accept(cv, ClassReader.SKIP_FRAMES);
			 if (cv.isWoven()) {
				 b = cw.toByteArray();
			 }
			 else {
				 b = Streams.suck(new FileInputStream(f));
			 }
		 }
		 finally {
			 is.close();
		 }
		 OutputStream os = new FileOutputStream(f);
		 try {
			 os.write(b);
		 }
		 finally {
			 os.close();
		 }
	 }
	 if (bundleClassPath != null) {
		 for (String entry : bundleClassPath.split("","")) {
			 File jarFile = new File(dir, entry.trim());
			 if (jarFile.isFile()) {
				 weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);
			 }
		 }
	 }
 }",0,0,1,0
"public class ReleaseSettings {
	 private RetentionSettings retentionSettings;
	 public RetentionSettings getRetentionSettings() {
		 return retentionSettings;
	 }
	 public void setRetentionSettings(final RetentionSettings retentionSettings) {
		 this.retentionSettings = retentionSettings;
	 }
}",0,0,0,0
"public boolean next(Text key, BytesWritable value) throws IOException {
	 try {
		 long startRead = in.getPos();
		 byte[] magicBuffer = null;
		 while (true) {
			 if (startRead >= splitEnd) {
				 return false;
			 }
			 boolean foundStart = false;
			 while (!foundStart) {
				 startRead = in.getPos();
				 magicBuffer = new byte[1024];
				 int read = in.read(magicBuffer);
				 if (read < 0) {
					 break;
				 }
				 for (int i = 0;
				 i < read - 1;
				 i++) {
					 byte[] testMagic = new byte[2];
					 System.arraycopy(magicBuffer, i, testMagic, 0, 2);
					 if (isMagic(testMagic)) {
						 startRead += i;
						 foundStart = true;
						 break;
					 }
				 }
			 }
			 in.seek(startRead);
			 ByteArrayOutputStream baos = null;
			 int totalRead = 0;
			 try {
				 byte[] buffer = new byte[4096];
				 GZIPInputStream zin = new GZIPInputStream(in);
				 int gzipRead = -1;
				 baos = new ByteArrayOutputStream();
				 while ((gzipRead = zin.read(buffer, 0, buffer.length)) != -1) {
					 baos.write(buffer, 0, gzipRead);
					 totalRead += gzipRead;
				 }
			 }
			 catch (Exception e) {
				 System.out.println(""Ignoring position: "" + (startRead));
				 if (startRead + 1 < fileLen) {
					 in.seek(startRead + 1);
				 }
				 continue;
			 }
			 byte[] content = baos.toByteArray();
			 int eol = 0;
			 for (int i = 0;
			 i < content.length;
			 i++) {
				 if (i > 0 && content[i] == '\n') {
					 eol = i;
					 break;
				 }
			 }
			 String header = new String(content, 0, eol).trim();
			 byte[] raw = new byte[(content.length - eol) - 1];
			 System.arraycopy(content, eol + 1, raw, 0, raw.length);
			 Text keyText = (Text)key;
			 keyText.set(header);
			 BytesWritable valueBytes = (BytesWritable)value;
			 valueBytes.set(raw, 0, raw.length);
			 if (startRead + 1 < fileLen) {
				 in.seek(startRead + 1);
			 }
			 return true;
		 }
	 }
	 catch (Exception e) {
		 LOG.equals(StringUtils.stringifyException(e));
	 }
	 return false;
 }",0,0,1,0
"public class ChartReportItemHelper{
	private static ChartReportItemHelper instance = new ChartReportItemHelper( );
	protected ChartReportItemHelper( ){
	}
	public static void initInstance( ChartReportItemHelper newInstance ){
		instance = newInstance;
	}
	public static ChartReportItemHelper instance( ){
		return instance;
	}
	public CubeHandle getBindingCubeHandle( ReportItemHandle itemHandle ){
		return ChartCubeUtil.getBindingCube( itemHandle );
	}
	public DataSetHandle getBindingDataSetHandle(ReportItemHandle itemHandle ){
		return ChartCubeUtil.getBindingDataSet( itemHandle );
	}
	public boolean checkCubeBindings( ExtendedItemHandle handle, Iterator<ComputedColumnHandle> columnBindings ){
		return ChartCubeUtil.checkColumnbindingForCube( columnBindings );
	}
	public ChartExpressionUtil.ExpressionCodec createExpressionCodec(ExtendedItemHandle handle ){
		return ChartModelHelper.instance( ).createExpressionCodec( );
	}
	public boolean loadExpression( ExpressionCodec exprCodec,ComputedColumnHandle cch ){
		return ChartItemUtil.loadExpression( exprCodec, cch );
	}
	public ComputedColumnHandle findDimensionBinding(ExpressionCodec exprCodec, String dimName, String levelName,Collection<ComputedColumnHandle> bindings, ReportItemHandle itemHandle ){
		for ( ComputedColumnHandle cch : bindings ){
			ChartReportItemHelper.instance( ).loadExpression( exprCodec, cch );
			String[] levelNames = exprCodec.getLevelNames( );
			if ( levelNames != null&& levelNames[0].equals( dimName )&& levelNames[1].equals( levelName ) ){
				return cch;
			}
		}
		return null;
	}
	public Iterator<?> getAllUsedBindings( Chart cm, ReportItemHandle handle, List<String> validExtensionNames ){
		return handle.columnBindingsIterator( );
	}
	public Iterator<?> getAllUsedBindings( Chart cm, ReportItemHandle handle ){
		return handle.columnBindingsIterator( );
	}
	public String getMeasureExprIndicator( CubeHandle cubeHandle ){
		return ExpressionUtil.MEASURE_INDICATOR;
	}
	public List<String> getLevelBindingNamesOfCrosstab(CrosstabViewHandle viewHandle, ReportItemHandle chartHandle ){
		ArrayList<String> names = new ArrayList<String>( );
		for ( int i = 0;
		 i < viewHandle.getDimensionCount( );
		 i++ ){
			DimensionViewHandle dimensionHandle = viewHandle.getDimension( i );
			dimensionHandle.availableBindings( );
			for ( int k = 0;
			 k < dimensionHandle.getLevelCount( );
			 k++ ){
				names.add( dimensionHandle.getLevel( k ).getCubeLevel( ).getName( ) );
			}
		}
		return names;
	}
}",1,1,0,0
"public class AlreadyBeingCreatedException extends IOException {
	 public AlreadyBeingCreatedException(String msg) {
		 super(msg);
	 }
}",0,0,0,0
"public class S3FileMerger implements Operator, Operator.CheckpointNotificationListener{
	 private static final Logger LOG = LoggerFactory.getLogger(S3FileMerger.class);
	 private String bucketName;
	 private String accessKey;
	 private String secretAccessKey;
	 private String endPoint;
	 protected transient List<String> uploadedFiles = new ArrayList<>();
	 private WindowDataManager windowDataManager = new FSWindowDataManager();
	 private Map<String, List<PartETag>> uploadParts = new HashMap<>();
	 private Map<String, S3InitiateFileUploadOperator.UploadFileMetadata> fileMetadatas = new HashMap<>();
	 protected transient long currentWindowId;
	 protected transient AmazonS3 s3Client;
	 public final transient DefaultInputPort<S3BlockUploadOperator.UploadBlockMetadata> uploadMetadataInput = new DefaultInputPort<S3BlockUploadOperator.UploadBlockMetadata>() {
		 public void process(S3BlockUploadOperator.UploadBlockMetadata tuple) {
			 processUploadBlock(tuple);
		 }
	 }
	;
	 protected void processUploadBlock(S3BlockUploadOperator.UploadBlockMetadata tuple) {
		 List<PartETag> listOfUploads = uploadParts.get(tuple.getKeyName());
		 if (listOfUploads == null) {
			 listOfUploads = new ArrayList<>();
			 uploadParts.put(tuple.getKeyName(), listOfUploads);
		 }
		 listOfUploads.add(tuple.getPartETag());
		 if (fileMetadatas.get(tuple.getKeyName()) != null) {
			 verifyAndEmitFileMerge(tuple.getKeyName());
		 }
	 }
	 public final transient DefaultInputPort<S3InitiateFileUploadOperator.UploadFileMetadata> filesMetadataInput = new DefaultInputPort<S3InitiateFileUploadOperator.UploadFileMetadata>() {
		 public void process(S3InitiateFileUploadOperator.UploadFileMetadata tuple) {
			 processFileMetadata(tuple);
		 }
	 }
	;
	 protected void processFileMetadata(S3InitiateFileUploadOperator.UploadFileMetadata tuple) {
		 String keyName = tuple.getKeyName();
		 fileMetadatas.put(keyName, tuple);
		 if (uploadParts.get(keyName) != null) {
			 verifyAndEmitFileMerge(keyName);
		 }
	 }
	 public void setup(Context.OperatorContext context) {
		 windowDataManager.setup(context);
		 s3Client = createClient();
	 }
	 protected AmazonS3 createClient() {
		 AmazonS3 client = new AmazonS3Client(new BasicAWSCredentials(accessKey, secretAccessKey));
		 if (endPoint != null) {
			 client.setEndpoint(endPoint);
		 }
		 return client;
	 }
	 public void beginWindow(long windowId) {
		 currentWindowId = windowId;
	 }
	 public void endWindow() {
		 if (uploadedFiles.size() > 0) {
			 for (String keyName: uploadedFiles) {
				 uploadParts.remove(keyName);
				 fileMetadatas.remove(keyName);
			 }
			 uploadedFiles.clear();
		 }
		 if (currentWindowId > windowDataManager.getLargestCompletedWindow()) {
			 try {
				 windowDataManager.save(""Uploaded Files"", currentWindowId);
			 }
			 catch (IOException e) {
				 throw new RuntimeException(""Unable to save recovery"", e);
			 }
		 }
	 }
	 public void teardown() {
		 windowDataManager.teardown();
	 }
	 private void verifyAndEmitFileMerge(String keyName) {
		 if (currentWindowId <= windowDataManager.getLargestCompletedWindow()) {
			 return;
		 }
		 S3InitiateFileUploadOperator.UploadFileMetadata uploadFileMetadata = fileMetadatas.get(keyName);
		 List<PartETag> partETags = uploadParts.get(keyName);
		 if (partETags == null || uploadFileMetadata == null || uploadFileMetadata.getFileMetadata().getNumberOfBlocks() != partETags.size()) {
			 return;
		 }
		 if (partETags.size() <= 1) {
			 uploadedFiles.add(keyName);
			 LOG.debug(""Uploaded file {
			}
			 successfully"", keyName);
			 return;
		 }
		 CompleteMultipartUploadRequest compRequest = new CompleteMultipartUploadRequest(bucketName, keyName, uploadFileMetadata.getUploadId(), partETags);
		 CompleteMultipartUploadResult result = s3Client.completeMultipartUpload(compRequest);
		 if (result.getETag() != null) {
			 uploadedFiles.add(keyName);
			 LOG.debug(""Uploaded file {
			}
			 successfully"", keyName);
		 }
	 }
	 public void beforeCheckpoint(long windowId) {
	 }
	 public void checkpointed(long windowId) {
	 }
	 public void committed(long windowId) {
		 try {
			 windowDataManager.committed(windowId);
		 }
		 catch (IOException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public String getBucketName() {
		 return bucketName;
	 }
	 public void setBucketName( String bucketName) {
		 this.bucketName = Preconditions.checkNotNull(bucketName);
	 }
	 public String getAccessKey() {
		 return accessKey;
	 }
	 public void setAccessKey( String accessKey) {
		 this.accessKey = Preconditions.checkNotNull(accessKey);
	 }
	 public String getSecretAccessKey() {
		 return secretAccessKey;
	 }
	 public void setSecretAccessKey( String secretAccessKey) {
		 this.secretAccessKey = Preconditions.checkNotNull(secretAccessKey);
	 }
	 public String getEndPoint() {
		 return endPoint;
	 }
	 public void setEndPoint(String endPoint) {
		 this.endPoint = endPoint;
	 }
}",1,1,0,0
"public class ResourceBundleDescriptionImpl implements ResourceBundleDescription {
	 protected String id_ ;
	 protected String name_ ;
	 protected String language_ ;
	 protected String country_ ;
	 protected String variant_ ;
	 protected String resourceType_ ;
	 public ResourceBundleDescriptionImpl() {
	 }
	 public String getId() {
		 if (id_ == null) {
			 StringBuffer b = new StringBuffer() ;
			 b.append(name_) ;
			 if(language_ != null) b.append('_').append(language_);
			 id_ = b.toString() ;
		 }
		 return id_ ;
	 }
	 public void setId(String id) {
		 id_ = id ;
	 }
	 public String getName() {
		 return name_ ;
	 }
	 public void setName(String name) {
		 name_ = name ;
	 }
	 public String getLanguage() {
		 return language_ ;
	 }
	 public void setLanguage(String s) {
		 language_ = s ;
	 }
	 public String getCountry() {
		 return country_ ;
	 }
	 public void setCountry(String s) {
		 country_ = s ;
	 }
	 public String getVariant() {
		 return variant_ ;
	 }
	 public void setVariant(String s) {
		 variant_ = s ;
	 }
	 public String getResourceType() {
		 return resourceType_ ;
	 }
	 public void setResourceType(String s) {
		 resourceType_ = s ;
	 }
}",0,1,0,0
"public class BlueprintURLHandler extends AbstractURLStreamHandlerService {
	private final Logger logger = LoggerFactory.getLogger(BlueprintURLHandler.class);
	private static String SYNTAX = ""blueprint: bp-xml-uri"";
	public URLConnection openConnection(URL url) throws IOException {
		if (url.getPath() == null || url.getPath().trim().length() == 0) {
			throw new MalformedURLException (""Path cannot be null or empty. Syntax: "" + SYNTAX );
		}
		logger.debug(""Blueprint xml URL is: ["" + url.getPath() + ""]"");
		return new Connection(url);
	}
	 public class Connection extends URLConnection {
		 public Connection(URL url) {
			 super(url);
		 }
		 public void connect() throws IOException {
		 }
		 public InputStream getInputStream() throws IOException {
			 try {
				 ByteArrayOutputStream os = new ByteArrayOutputStream();
				 BlueprintTransformer.transform(new URL(url.getPath()), os);
				 os.close();
				 return new ByteArrayInputStream(os.toByteArray());
			 }
			 catch (Exception e) {
				 logger.error(""Error opening blueprint xml url"", e);
				 throw new IOException(""Error opening blueprint xml url"", e);
			 }
		 }
	 }
}",0,0,0,0
"public class IndexAVL implements Index {
	 private final long persistenceId;
	 protected final HsqlName name;
	 private final boolean[] colCheck;
	 final int[] colIndex;
	 private final int[] defaultColMap;
	 final Type[] colTypes;
	 private final boolean[] colDesc;
	 private final boolean[] nullsLast;
	 final boolean isSimpleOrder;
	 final boolean isSimple;
	 protected final boolean isPK;
	 protected final boolean isUnique;
	 protected final boolean isConstraint;
	 private final boolean isForward;
	 private int depth;
	 private static final IndexRowIterator emptyIterator = new IndexRowIterator(null, (PersistentStore) null, null, null, false, false);
	 protected TableBase table;
	 int position;
	 Object[] nullData;
	 ReadWriteLock lock = new ReentrantReadWriteLock();
	 Lock readLock = lock.readLock();
	 Lock writeLock = lock.writeLock();
	 public IndexAVL(HsqlName name, long id, TableBase table, int[] columns, boolean[] descending, boolean[] nullsLast, Type[] colTypes, boolean pk, boolean unique, boolean constraint, boolean forward) {
		 this.persistenceId = id;
		 this.name = name;
		 this.colIndex = columns;
		 this.colTypes = colTypes;
		 this.colDesc = descending == null ? new boolean[columns.length] : descending;
		 this.nullsLast = nullsLast == null ? new boolean[columns.length] : nullsLast;
		 this.isPK = pk;
		 this.isUnique = unique;
		 this.isConstraint = constraint;
		 this.isForward = forward;
		 this.table = table;
		 this.colCheck = table.getNewColumnCheckList();
		 ArrayUtil.intIndexesToBooleanArray(colIndex, colCheck);
		 this.defaultColMap = new int[columns.length];
		 ArrayUtil.fillSequence(defaultColMap);
		 boolean simpleOrder = colIndex.length > 0;
		 for (int i = 0;
		 i < colDesc.length;
		 i++) {
			 if (this.colDesc[i] || this.nullsLast[i]) {
				 simpleOrder = false;
			 }
		 }
		 isSimpleOrder = simpleOrder;
		 isSimple = isSimpleOrder && colIndex.length == 1;
		 nullData = new Object[colIndex.length];
	 }
	 public int getType() {
		 return SchemaObject.INDEX;
	 }
	 public HsqlName getName() {
		 return name;
	 }
	 public HsqlName getCatalogName() {
		 return name.schema.schema;
	 }
	 public HsqlName getSchemaName() {
		 return name.schema;
	 }
	 public Grantee getOwner() {
		 return name.schema.owner;
	 }
	 public OrderedHashSet getReferences() {
		 return new OrderedHashSet();
	 }
	 public OrderedHashSet getComponents() {
		 return null;
	 }
	 public void compile(Session session, SchemaObject parentObject) {
	}
	 public String getSQL() {
		 StringBuffer sb = new StringBuffer();
		 sb = new StringBuffer(64);
		 sb.append(Tokens.T_CREATE).append(' ');
		 if (isUnique()) {
			 sb.append(Tokens.T_UNIQUE).append(' ');
		 }
		 sb.append(Tokens.T_INDEX).append(' ');
		 sb.append(getName().statementName);
		 sb.append(' ').append(Tokens.T_ON).append(' ');
		 sb.append(((Table) table).getName().getSchemaQualifiedStatementName());
		 int[] col = getColumns();
		 int len = getVisibleColumns();
		 sb.append(((Table) table).getColumnListSQL(col, len));
		 return sb.toString();
	 }
	 public long getChangeTimestamp() {
		 return 0;
	 }
	 public RowIterator emptyIterator() {
		 return emptyIterator;
	 }
	 public int getPosition() {
		 return position;
	 }
	 public void setPosition(int position) {
		 this.position = position;
	 }
	 public long getPersistenceId() {
		 return persistenceId;
	 }
	 public int getVisibleColumns() {
		 return colIndex.length;
	 }
	 public int getColumnCount() {
		 return colIndex.length;
	 }
	 public boolean isUnique() {
		 return isUnique;
	 }
	 public boolean isConstraint() {
		 return isConstraint;
	 }
	 public int[] getColumns() {
		 return colIndex;
	 }
	 public Type[] getColumnTypes() {
		 return colTypes;
	 }
	 public boolean[] getColumnDesc() {
		 return colDesc;
	 }
	 public int[] getDefaultColumnMap() {
		 return this.defaultColMap;
	 }
	 public int getIndexOrderValue() {
		 if (isPK) {
			 return 0;
		 }
		 if (isConstraint) {
			 return isForward ? 4 : isUnique ? 0 : 1;
		 }
		 else {
			 return 2;
		 }
	 }
	 public boolean isForward() {
		 return isForward;
	 }
	 public void setTable(TableBase table) {
		 this.table = table;
	 }
	 public int size(Session session, PersistentStore store) {
		 readLock.lock();
		 try {
			 return store.elementCount(session);
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 public int sizeUnique(PersistentStore store) {
		 readLock.lock();
		 try {
			 return store.elementCountUnique(this);
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 public int getNodeCount(Session session, PersistentStore store) {
		 int count = 0;
		 readLock.lock();
		 try {
			 RowIterator it = firstRow(session, store);
			 while (it.hasNext()) {
				 it.getNextRow();
				 count++;
			 }
			 return count;
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 public int sizeEstimate(PersistentStore store) {
		 firstRow(null, store);
		 return (int) (1L << depth);
	 }
	 public boolean isEmpty(PersistentStore store) {
		 readLock.lock();
		 try {
			 return getAccessor(store) == null;
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 public void checkIndex(PersistentStore store) {
		 readLock.lock();
		 try {
			 NodeAVL p = getAccessor(store);
			 NodeAVL f = null;
			 while (p != null) {
				 f = p;
				 checkNodes(store, p);
				 p = p.getLeft(store);
			 }
			 p = f;
			 while (f != null) {
				 checkNodes(store, f);
				 f = next(store, f);
			 }
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 void checkNodes(PersistentStore store, NodeAVL p) {
		 NodeAVL l = p.getLeft(store);
		 NodeAVL r = p.getRight(store);
		 if (l != null && l.getBalance(store) == -2) {
			 System.out.print(""broken index - deleted"");
		 }
		 if (r != null && r.getBalance(store) == -2) {
			 System.out.print(""broken index -deleted"");
		 }
		 if (l != null && !p.equals(l.getParent(store))) {
			 System.out.print(""broken index - no parent"");
		 }
		 if (r != null && !p.equals(r.getParent(store))) {
			 System.out.print(""broken index - no parent"");
		 }
	 }
	 public int compareRowNonUnique(Session session, Object[] a, Object[] b, int[] rowColMap) {
		 int fieldcount = rowColMap.length;
		 for (int j = 0;
		 j < fieldcount;
		 j++) {
			 int i = colTypes[j].compare(session, a[colIndex[j]], b[rowColMap[j]]);
			 if (i != 0) {
				 return i;
			 }
		 }
		 return 0;
	 }
	 public int compareRowNonUnique(Session session, Object[] a, Object[] b, int[] rowColMap, int fieldCount) {
		 for (int j = 0;
		 j < fieldCount;
		 j++) {
			 int i = colTypes[j].compare(session, a[colIndex[j]], b[rowColMap[j]]);
			 if (i != 0) {
				 return i;
			 }
		 }
		 return 0;
	 }
	 public int compareRowNonUnique(Session session, Object[] a, Object[] b, int fieldCount) {
		 for (int j = 0;
		 j < fieldCount;
		 j++) {
			 int i = colTypes[j].compare(session, a[colIndex[j]], b[colIndex[j]]);
			 if (i != 0) {
				 return i;
			 }
		 }
		 return 0;
	 }
	 public int compareRow(Session session, Object[] a, Object[] b) {
		 for (int j = 0;
		 j < colIndex.length;
		 j++) {
			 int i = colTypes[j].compare(session, a[colIndex[j]], b[colIndex[j]]);
			 if (i != 0) {
				 if (isSimpleOrder) {
					 return i;
				 }
				 boolean nulls = a[colIndex[j]] == null || b[colIndex[j]] == null;
				 if (colDesc[j] && !nulls) {
					 i = -i;
				 }
				 if (nullsLast[j] && nulls) {
					 i = -i;
				 }
				 return i;
			 }
		 }
		 return 0;
	 }
	 int compareRowForInsertOrDelete(Session session, Row newRow, Row existingRow, boolean useRowId, int start) {
		 Object[] a = newRow.getData();
		 Object[] b = existingRow.getData();
		 for (int j = start;
		 j < colIndex.length;
		 j++) {
			 int i = colTypes[j].compare(session, a[colIndex[j]], b[colIndex[j]]);
			 if (i != 0) {
				 if (isSimpleOrder) {
					 return i;
				 }
				 boolean nulls = a[colIndex[j]] == null || b[colIndex[j]] == null;
				 if (colDesc[j] && !nulls) {
					 i = -i;
				 }
				 if (nullsLast[j] && nulls) {
					 i = -i;
				 }
				 return i;
			 }
		 }
		 if (useRowId) {
			 return newRow.getPos() - existingRow.getPos();
		 }
		 return 0;
	 }
	 int compareObject(Session session, Object[] a, Object[] b, int[] rowColMap, int position) {
		 return colTypes[position].compare(session, a[colIndex[position]], b[rowColMap[position]]);
	 }
	 boolean hasNulls(Object[] rowData) {
		 for (int j = 0;
		 j < colIndex.length;
		 j++) {
			 if (rowData[colIndex[j]] == null) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public void insert(Session session, PersistentStore store, Row row) {
		 NodeAVL n;
		 NodeAVL x;
		 boolean isleft = true;
		 int compare = -1;
		 boolean compareRowId = !isUnique || hasNulls(row.getData());
		 writeLock.lock();
		 store.lock();
		 try {
			 n = getAccessor(store);
			 x = n;
			 if (n == null) {
				 store.setAccessor(this, ((RowAVL) row).getNode(position));
				 store.setElementCount(this, 1, 1);
				 return;
			 }
			 while (true) {
				 Row currentRow = n.getRow(store);
				 compare = compareRowForInsertOrDelete(session, row, currentRow, compareRowId, 0);
				 if (compare == 0 && session != null && !compareRowId && session.database.txManager.isMVRows()) {
					 if (!isEqualReadable(session, store, n)) {
						 compareRowId = true;
						 compare = compareRowForInsertOrDelete(session, row, currentRow, compareRowId, colIndex.length);
					 }
				 }
				 if (compare == 0) {
					 Constraint c = null;
					 if (isConstraint) {
						 c = ((Table) table).getUniqueConstraintForIndex(this);
					 }
					 if (c == null) {
						 throw Error.error(ErrorCode.X_23505, name.statementName);
					 }
					 else {
						 throw c.getException(row.getData());
					 }
				 }
				 isleft = compare < 0;
				 x = n;
				 n = x.child(store, isleft);
				 if (n == null) {
					 break;
				 }
			 }
			 x = x.set(store, isleft, ((RowAVL) row).getNode(position));
			 balance(store, x, isleft);
			 store.updateElementCount(this, 1, 1);
		 }
		 finally {
			 store.unlock();
			 writeLock.unlock();
		 }
	 }
	 public void delete(Session session, PersistentStore store, Row row) {
		 if (!row.isInMemory()) {
			 row = (Row) store.get(row, false);
		 }
		 NodeAVL node = ((RowAVL) row).getNode(position);
		 if (node != null) {
			 delete(store, node);
			 store.updateElementCount(this, -1, -1);
		 }
	 }
	 void delete(PersistentStore store, NodeAVL x) {
		 if (x == null) {
			 return;
		 }
		 NodeAVL n;
		 writeLock.lock();
		 store.lock();
		 try {
			 if (x.getLeft(store) == null) {
				 n = x.getRight(store);
			 }
			 else if (x.getRight(store) == null) {
				 n = x.getLeft(store);
			 }
			 else {
				 NodeAVL d = x;
				 x = x.getLeft(store);
				 while (true) {
					 NodeAVL temp = x.getRight(store);
					 if (temp == null) {
						 break;
					 }
					 x = temp;
				 }
				 n = x.getLeft(store);
				 int b = x.getBalance(store);
				 x = x.setBalance(store, d.getBalance(store));
				 d = d.setBalance(store, b);
				 NodeAVL xp = x.getParent(store);
				 NodeAVL dp = d.getParent(store);
				 if (d.isRoot(store)) {
					 store.setAccessor(this, x);
				 }
				 x = x.setParent(store, dp);
				 if (dp != null) {
					 if (dp.isRight(d)) {
						 dp = dp.setRight(store, x);
					 }
					 else {
						 dp = dp.setLeft(store, x);
					 }
				 }
				 if (d.equals(xp)) {
					 d = d.setParent(store, x);
					 if (d.isLeft(x)) {
						 x = x.setLeft(store, d);
						 NodeAVL dr = d.getRight(store);
						 x = x.setRight(store, dr);
					 }
					 else {
						 x = x.setRight(store, d);
						 NodeAVL dl = d.getLeft(store);
						 x = x.setLeft(store, dl);
					 }
				 }
				 else {
					 d = d.setParent(store, xp);
					 xp = xp.setRight(store, d);
					 NodeAVL dl = d.getLeft(store);
					 NodeAVL dr = d.getRight(store);
					 x = x.setLeft(store, dl);
					 x = x.setRight(store, dr);
				 }
				 x.getRight(store).setParent(store, x);
				 x.getLeft(store).setParent(store, x);
				 d = d.setLeft(store, n);
				 if (n != null) {
					 n = n.setParent(store, d);
				 }
				 d = d.setRight(store, null);
				 x = d;
			 }
			 boolean isleft = x.isFromLeft(store);
			 x.replace(store, this, n);
			 n = x.getParent(store);
			 x.delete();
			 while (n != null) {
				 x = n;
				 int sign = isleft ? 1 : -1;
				 switch (x.getBalance(store) * sign) {
					 case -1 : x = x.setBalance(store, 0);
					 break;
					 case 0 : x = x.setBalance(store, sign);
					 return;
					 case 1 : NodeAVL r = x.child(store, !isleft);
					 int b = r.getBalance(store);
					 if (b * sign >= 0) {
						 x.replace(store, this, r);
						 NodeAVL child = r.child(store, isleft);
						 x = x.set(store, !isleft, child);
						 r = r.set(store, isleft, x);
						 if (b == 0) {
							 x = x.setBalance(store, sign);
							 r = r.setBalance(store, -sign);
							 return;
						 }
						 x = x.setBalance(store, 0);
						 r = r.setBalance(store, 0);
						 x = r;
					 }
					 else {
						 NodeAVL l = r.child(store, isleft);
						 x.replace(store, this, l);
						 b = l.getBalance(store);
						 r = r.set(store, isleft, l.child(store, !isleft));
						 l = l.set(store, !isleft, r);
						 x = x.set(store, !isleft, l.child(store, isleft));
						 l = l.set(store, isleft, x);
						 x = x.setBalance(store, (b == sign) ? -sign : 0);
						 r = r.setBalance(store, (b == -sign) ? sign : 0);
						 l = l.setBalance(store, 0);
						 x = l;
					 }
				 }
				 isleft = x.isFromLeft(store);
				 n = x.getParent(store);
			 }
		 }
		 finally {
			 store.unlock();
			 writeLock.unlock();
		 }
	 }
	 public boolean existsParent(Session session, PersistentStore store, Object[] rowdata, int[] rowColMap) {
		 NodeAVL node = findNode(session, store, rowdata, rowColMap, rowColMap.length, OpTypes.EQUAL, TransactionManager.ACTION_REF, false);
		 return node != null;
	 }
	 public RowIterator findFirstRow(Session session, PersistentStore store, Object[] rowdata, int matchCount, int compareType, boolean reversed, boolean[] map) {
		 if (compareType == OpTypes.MAX) {
			 return lastRow(session, store);
		 }
		 NodeAVL node = findNode(session, store, rowdata, defaultColMap, matchCount, compareType, TransactionManager.ACTION_READ, reversed);
		 return getIterator(session, store, node, false, reversed);
	 }
	 public RowIterator findFirstRow(Session session, PersistentStore store, Object[] rowdata) {
		 NodeAVL node = findNode(session, store, rowdata, colIndex, colIndex.length, OpTypes.EQUAL, TransactionManager.ACTION_READ, false);
		 return getIterator(session, store, node, false, false);
	 }
	 public RowIterator findFirstRow(Session session, PersistentStore store, Object[] rowdata, int[] rowColMap) {
		 NodeAVL node = findNode(session, store, rowdata, rowColMap, rowColMap.length, OpTypes.EQUAL, TransactionManager.ACTION_READ, false);
		 return getIterator(session, store, node, false, false);
	 }
	 public RowIterator findFirstRowNotNull(Session session, PersistentStore store) {
		 NodeAVL node = findNode(session, store, nullData, this.defaultColMap, 1, OpTypes.NOT, TransactionManager.ACTION_READ, false);
		 return getIterator(session, store, node, false, false);
	 }
	 public RowIterator firstRow(Session session, PersistentStore store) {
		 int tempDepth = 0;
		 readLock.lock();
		 try {
			 NodeAVL x = getAccessor(store);
			 NodeAVL l = x;
			 while (l != null) {
				 x = l;
				 l = x.getLeft(store);
				 tempDepth++;
			 }
			 while (session != null && x != null) {
				 Row row = x.getRow(store);
				 if (session.database.txManager.canRead( session, row, TransactionManager.ACTION_READ, null)) {
					 break;
				 }
				 x = next(store, x);
			 }
			 return getIterator(session, store, x, false, false);
		 }
		 finally {
			 depth = tempDepth;
			 readLock.unlock();
		 }
	 }
	 public RowIterator firstRow(PersistentStore store) {
		 int tempDepth = 0;
		 readLock.lock();
		 try {
			 NodeAVL x = getAccessor(store);
			 NodeAVL l = x;
			 while (l != null) {
				 x = l;
				 l = x.getLeft(store);
				 tempDepth++;
			 }
			 return getIterator(null, store, x, false, false);
		 }
		 finally {
			 depth = tempDepth;
			 readLock.unlock();
		 }
	 }
	 public RowIterator lastRow(Session session, PersistentStore store) {
		 readLock.lock();
		 try {
			 NodeAVL x = getAccessor(store);
			 NodeAVL l = x;
			 while (l != null) {
				 x = l;
				 l = x.getRight(store);
			 }
			 while (session != null && x != null) {
				 Row row = x.getRow(store);
				 if (session.database.txManager.canRead( session, row, TransactionManager.ACTION_READ, null)) {
					 break;
				 }
				 x = last(store, x);
			 }
			 return getIterator(null, store, x, false, true);
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 NodeAVL next(Session session, PersistentStore store, NodeAVL x) {
		 if (x == null) {
			 return null;
		 }
		 readLock.lock();
		 try {
			 while (true) {
				 x = next(store, x);
				 if (x == null) {
					 return x;
				 }
				 if (session == null) {
					 return x;
				 }
				 Row row = x.getRow(store);
				 if (session.database.txManager.canRead( session, row, TransactionManager.ACTION_READ, null)) {
					 return x;
				 }
			 }
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 NodeAVL last(Session session, PersistentStore store, NodeAVL x) {
		 if (x == null) {
			 return null;
		 }
		 readLock.lock();
		 try {
			 while (true) {
				 x = last(store, x);
				 if (x == null) {
					 return x;
				 }
				 if (session == null) {
					 return x;
				 }
				 Row row = x.getRow(store);
				 if (session.database.txManager.canRead( session, row, TransactionManager.ACTION_READ, null)) {
					 return x;
				 }
			 }
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 NodeAVL next(PersistentStore store, NodeAVL x) {
		 NodeAVL r = x.getRight(store);
		 if (r != null) {
			 x = r;
			 NodeAVL l = x.getLeft(store);
			 while (l != null) {
				 x = l;
				 l = x.getLeft(store);
			 }
			 return x;
		 }
		 NodeAVL ch = x;
		 x = x.getParent(store);
		 while (x != null && ch.equals(x.getRight(store))) {
			 ch = x;
			 x = x.getParent(store);
		 }
		 return x;
	 }
	 NodeAVL last(PersistentStore store, NodeAVL x) {
		 if (x == null) {
			 return null;
		 }
		 NodeAVL left = x.getLeft(store);
		 if (left != null) {
			 x = left;
			 NodeAVL right = x.getRight(store);
			 while (right != null) {
				 x = right;
				 right = x.getRight(store);
			 }
			 return x;
		 }
		 NodeAVL ch = x;
		 x = x.getParent(store);
		 while (x != null && ch.equals(x.getLeft(store))) {
			 ch = x;
			 x = x.getParent(store);
		 }
		 return x;
	 }
	 boolean isEqualReadable(Session session, PersistentStore store, NodeAVL node) {
		 NodeAVL c = node;
		 Object[] data;
		 Object[] nodeData;
		 if (session.database.txManager.canRead(session, node.getRow(store), TransactionManager.ACTION_DUP, null)) {
			 return true;
		 }
		 data = node.getData(store);
		 while (true) {
			 c = last(store, c);
			 if (c == null) {
				 break;
			 }
			 nodeData = c.getData(store);
			 if (compareRow(session, data, nodeData) == 0) {
				 Row row = c.getRow(store);
				 if (session.database.txManager.canRead( session, row, TransactionManager.ACTION_DUP, null)) {
					 return true;
				 }
				 continue;
			 }
			 break;
		 }
		 while (true) {
			 c = next(session, store, node);
			 if (c == null) {
				 break;
			 }
			 nodeData = c.getData(store);
			 if (compareRow(session, data, nodeData) == 0) {
				 Row row = c.getRow(store);
				 if (session.database.txManager.canRead( session, row, TransactionManager.ACTION_DUP, null)) {
					 return true;
				 }
				 continue;
			 }
			 break;
		 }
		 return false;
	 }
	 NodeAVL findNode(Session session, PersistentStore store, Object[] rowdata, int[] rowColMap, int fieldCount, int compareType, int readMode, boolean reversed) {
		 readLock.lock();
		 try {
			 NodeAVL x = getAccessor(store);
			 NodeAVL n = null;
			 NodeAVL result = null;
			 Row currentRow = null;
			 if (compareType != OpTypes.EQUAL && compareType != OpTypes.IS_NULL) {
				 fieldCount--;
			 }
			 while (x != null) {
				 currentRow = x.getRow(store);
				 int i = 0;
				 if (fieldCount > 0) {
					 i = compareRowNonUnique(session, currentRow.getData(), rowdata, rowColMap, fieldCount);
				 }
				 if (i == 0) {
					 switch (compareType) {
						 case OpTypes.IS_NULL : case OpTypes.EQUAL : {
							 result = x;
							 n = x.getLeft(store);
							 break;
						 }
						 case OpTypes.NOT : case OpTypes.GREATER : {
							 i = compareObject(session, currentRow.getData(), rowdata, rowColMap, fieldCount);
							 if (i <= 0) {
								 n = x.getRight(store);
							 }
							 else {
								 result = x;
								 n = x.getLeft(store);
							 }
							 break;
						 }
						 case OpTypes.GREATER_EQUAL : {
							 i = compareObject(session, currentRow.getData(), rowdata, rowColMap, fieldCount);
							 if (i < 0) {
								 n = x.getRight(store);
							 }
							 else {
								 result = x;
								 n = x.getLeft(store);
							 }
							 break;
						 }
						 case OpTypes.SMALLER : {
							 i = compareObject(session, currentRow.getData(), rowdata, rowColMap, fieldCount);
							 if (i < 0) {
								 result = x;
								 n = x.getRight(store);
							 }
							 else {
								 n = x.getLeft(store);
							 }
							 break;
						 }
						 case OpTypes.SMALLER_EQUAL : {
							 i = compareObject(session, currentRow.getData(), rowdata, rowColMap, fieldCount);
							 if (i <= 0) {
								 result = x;
								 n = x.getRight(store);
							 }
							 else {
								 n = x.getLeft(store);
							 }
							 break;
						 }
						 default : Error.runtimeError(ErrorCode.U_S0500, ""Index"");
					 }
				 }
				 else if (i < 0) {
					 n = x.getRight(store);
				 }
				 else if (i > 0) {
					 n = x.getLeft(store);
				 }
				 if (n == null) {
					 break;
				 }
				 x = n;
			 }
			 if (session == null) {
				 return result;
			 }
			 while (result != null) {
				 currentRow = result.getRow(store);
				 if (session.database.txManager.canRead(session, currentRow, readMode, colIndex)) {
					 break;
				 }
				 result = reversed ? last(store, result) : next(store, result);
				 if (result == null) {
					 break;
				 }
				 currentRow = result.getRow(store);
				 if (fieldCount > 0 && compareRowNonUnique( session, currentRow.getData(), rowdata, rowColMap, fieldCount) != 0) {
					 result = null;
					 break;
				 }
			 }
			 return result;
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 NodeAVL findNode(Session session, PersistentStore store, Object data, int compareType, int readMode) {
		 readLock.lock();
		 try {
			 NodeAVL x = getAccessor(store);
			 NodeAVL n = null;
			 NodeAVL result = null;
			 Row currentRow = null;
			 while (x != null) {
				 currentRow = x.getRow(store);
				 int i = colTypes[0].compare(session, data, currentRow.getData()[colIndex[0]]);
				 switch (compareType) {
					 case OpTypes.IS_NULL : case OpTypes.EQUAL : {
						 if (i == 0) {
							 result = x;
							 n = x.getLeft(store);
							 break;
						 }
						 else if (i > 0) {
							 n = x.getRight(store);
						 }
						 else if (i < 0) {
							 n = x.getLeft(store);
						 }
						 break;
					 }
					 case OpTypes.NOT : case OpTypes.GREATER : {
						 if (i >= 0) {
							 n = x.getRight(store);
						 }
						 else {
							 result = x;
							 n = x.getLeft(store);
						 }
						 break;
					 }
					 case OpTypes.GREATER_EQUAL : {
						 if (i > 0) {
							 n = x.getRight(store);
						 }
						 else {
							 result = x;
							 n = x.getLeft(store);
						 }
						 break;
					 }
					 default : Error.runtimeError(ErrorCode.U_S0500, ""Index"");
				 }
				 if (n == null) {
					 break;
				 }
				 x = n;
			 }
			 if (session == null) {
				 return result;
			 }
			 while (result != null) {
				 currentRow = result.getRow(store);
				 if (session.database.txManager.canRead(session, currentRow, readMode, colIndex)) {
					 break;
				 }
				 result = next(store, result);
				 if (compareType == OpTypes.EQUAL) {
					 if (colTypes[0].compare( session, data, currentRow.getData()[colIndex[0]]) != 0) {
						 result = null;
						 break;
					 }
				 }
			 }
			 return result;
		 }
		 finally {
			 readLock.unlock();
		 }
	 }
	 void balance(PersistentStore store, NodeAVL x, boolean isleft) {
		 while (true) {
			 int sign = isleft ? 1 : -1;
			 switch (x.getBalance(store) * sign) {
				 case 1 : x = x.setBalance(store, 0);
				 return;
				 case 0 : x = x.setBalance(store, -sign);
				 break;
				 case -1 : NodeAVL l = x.child(store, isleft);
				 if (l.getBalance(store) == -sign) {
					 x.replace(store, this, l);
					 x = x.set(store, isleft, l.child(store, !isleft));
					 l = l.set(store, !isleft, x);
					 x = x.setBalance(store, 0);
					 l = l.setBalance(store, 0);
				 }
				 else {
					 NodeAVL r = l.child(store, !isleft);
					 x.replace(store, this, r);
					 l = l.set(store, !isleft, r.child(store, isleft));
					 r = r.set(store, isleft, l);
					 x = x.set(store, isleft, r.child(store, !isleft));
					 r = r.set(store, !isleft, x);
					 int rb = r.getBalance(store);
					 x = x.setBalance(store, (rb == -sign) ? sign : 0);
					 l = l.setBalance(store, (rb == sign) ? -sign : 0);
					 r = r.setBalance(store, 0);
				 }
				 return;
			 }
			 if (x.isRoot(store)) {
				 return;
			 }
			 isleft = x.isFromLeft(store);
			 x = x.getParent(store);
		 }
	 }
	 NodeAVL getAccessor(PersistentStore store) {
		 NodeAVL node = (NodeAVL) store.getAccessor(this);
		 return node;
	 }
	 IndexRowIterator getIterator(Session session, PersistentStore store, NodeAVL x, boolean single, boolean reversed) {
		 if (x == null) {
			 return emptyIterator;
		 }
		 else {
			 IndexRowIterator it = new IndexRowIterator(session, store, this, x, single, reversed);
			 return it;
		 }
	 }
	 public static final class IndexRowIterator implements RowIterator {
		 final Session session;
		 final PersistentStore store;
		 final IndexAVL index;
		 NodeAVL nextnode;
		 Row lastrow;
		 boolean single;
		 boolean reversed;
		 IndexRowIterator last;
		 IndexRowIterator next;
		 IndexRowIterator lastInSession;
		 IndexRowIterator nextInSession;
		 public IndexRowIterator(Session session, PersistentStore store, IndexAVL index, NodeAVL node, boolean single, boolean reversed) {
			 this.session = session;
			 this.store = store;
			 this.index = index;
			 this.single = single;
			 this.reversed = reversed;
			 if (index == null) {
				 return;
			 }
			 nextnode = node;
		 }
		 public boolean hasNext() {
			 return nextnode != null;
		 }
		 public Row getNextRow() {
			 if (nextnode == null) {
				 release();
				 return null;
			 }
			 lastrow = nextnode.getRow(store);
			 if (single) {
				 nextnode = null;
			 }
			 else if (reversed) {
				 nextnode = index.last(session, store, nextnode);
			 }
			 else {
				 nextnode = index.next(session, store, nextnode);
			 }
			 return lastrow;
		 }
		 public Object[] getNext() {
			 Row row = getNextRow();
			 return row == null ? null : row.getData();
		 }
		 public void remove() {
			 store.delete(session, lastrow);
			 store.remove(lastrow.getPos());
		 }
		 public void release() {
		}
		 public boolean setRowColumns(boolean[] columns) {
			 return false;
		 }
		 public long getRowId() {
			 return nextnode.getPos();
		 }
	 }
}",1,0,0,0
"public class ResizePolicyTests {
	static class DimensionPart extends AbstractContentPart<Region> implements IResizableContentPart<Region> {
		private Dimension size = new Dimension(0, 0);
		protected Region doCreateVisual() {
			return new Region() {
				protected double computeMinHeight(double width) {
					return 35;
				}
				protected double computeMinWidth(double height) {
					return 45;
				}
			}
			;
		}
		protected SetMultimap<? extends Object, String> doGetContentAnchorages() {
			return HashMultimap.create();
		}
		protected List<? extends Object> doGetContentChildren() {
			return Collections.emptyList();
		}
		protected void doRefreshVisual(Region visual) {
			visual.resize(size.width, size.height);
		}
		public Dimension getContent() {
			return size;
		}
		public Dimension getContentSize() {
			return size.getCopy();
		}
		public void setContentSize(Dimension totalSize) {
			size.setSize(totalSize);
		}
	}
	static class ResizePolicyTestsContentPartFactory implements IContentPartFactory {
		private Injector injector;
		public IContentPart<? extends Node> createContentPart(Object content, Map<Object, Object> contextMap) {
			if (content instanceof Dimension) {
				return injector.getInstance(DimensionPart.class);
			}
			 else {
				throw new IllegalArgumentException(content.getClass().toString());
			}
		}
	}
	private ResizePolicy resizePolicy;
	private IDomain domain;
	public FXApplicationThreadRule fxApplicationThreadRule = new FXApplicationThreadRule();
	public ResizePolicy createResizePolicy() {
		Injector injector = Guice.createInjector(new MvcFxModule() {
			protected void bindAbstractContentPartAdapters(MapBinder<AdapterKey<?>, Object> adapterMapBinder) {
				super.bindAbstractContentPartAdapters(adapterMapBinder);
				adapterMapBinder.addBinding(AdapterKey.defaultRole()).to(ResizePolicy.class);
			}
			protected void bindIContentPartFactory() {
				binder().bind(IContentPartFactory.class).to(ResizePolicyTestsContentPartFactory.class);
			}
			protected void configure() {
				super.configure();
				bindIContentPartFactory();
			}
		}
		);
		injector.injectMembers(this);
		IViewer viewer = domain.getAdapter(AdapterKey.get(IViewer.class, IDomain.CONTENT_VIEWER_ROLE));
		Scene scene = new Scene(viewer.getCanvas(), 100, 100);
		JFXPanel panel = new JFXPanel();
		panel.setScene(scene);
		Dimension content = new Dimension(0, 0);
		viewer.getContents().setAll(Collections.singletonList(content));
		domain.activate();
		IContentPart<? extends Node> contentPart = viewer.getContentPartMap().get(content);
		return contentPart.getAdapter(ResizePolicy.class);
	}
	public void setUp() {
		resizePolicy = createResizePolicy();
		resizePolicy.init();
	}
	public void test_minimumSize_Region() {
		assertEquals(0d, resizePolicy.getDeltaWidth(), 0.01);
		assertEquals(0d, resizePolicy.getDeltaHeight(), 0.01);
		Region region = (Region) resizePolicy.getHost().getVisual();
		region.setMinSize(Region.USE_COMPUTED_SIZE, Region.USE_COMPUTED_SIZE);
		assertEquals(Region.USE_COMPUTED_SIZE, region.getMinWidth(), 0.01);
		assertEquals(Region.USE_COMPUTED_SIZE, region.getMinHeight(), 0.01);
		resizePolicy.resize(region.minWidth(-1) - 5, region.minHeight(-1) - 5);
		assertEquals(region.minWidth(-1), resizePolicy.getDeltaWidth(), 0.01);
		assertEquals(region.minHeight(-1), resizePolicy.getDeltaHeight(), 0.01);
	}
}",0,0,0,0
"public String getToken() {
	 return getLocalToken().toString();
 }",0,0,0,0
"private void resizeInstructions() {
	 byte[] b = code.data;
	 int u, v, label;
	 int i, j;
	 int[] allIndexes = new int[0];
	 int[] allSizes = new int[0];
	 boolean[] resize;
	 int newOffset;
	 resize = new boolean[code.length];
	 int state = 3;
	 do {
		 if (state == 3) {
			 state = 2;
		 }
		 u = 0;
		 while (u < b.length) {
			 int opcode = b[u] & 0xFF;
			 int insert = 0;
			 switch (ClassWriter.TYPE[opcode]) {
				 case ClassWriter.NOARG_INSN: case ClassWriter.IMPLVAR_INSN: u += 1;
				 break;
				 case ClassWriter.LABEL_INSN: if (opcode > 201) {
					 opcode = opcode < 218 ? opcode - 49 : opcode - 20;
					 label = u + readUnsignedShort(b, u + 1);
				 }
				 else {
					 label = u + readShort(b, u + 1);
				 }
				 newOffset = getNewOffset(allIndexes, allSizes, u, label);
				 if (newOffset < Short.MIN_VALUE || newOffset > Short.MAX_VALUE) {
					 if (!resize[u]) {
						 if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {
							 insert = 2;
						 }
						 else {
							 insert = 5;
						 }
						 resize[u] = true;
					 }
				 }
				 u += 3;
				 break;
				 case ClassWriter.LABELW_INSN: u += 5;
				 break;
				 case ClassWriter.TABL_INSN: if (state == 1) {
					 newOffset = getNewOffset(allIndexes, allSizes, 0, u);
					 insert = -(newOffset & 3);
				 }
				 else if (!resize[u]) {
					 insert = u & 3;
					 resize[u] = true;
				 }
				 u = u + 4 - (u & 3);
				 u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;
				 break;
				 case ClassWriter.LOOK_INSN: if (state == 1) {
					 newOffset = getNewOffset(allIndexes, allSizes, 0, u);
					 insert = -(newOffset & 3);
				 }
				 else if (!resize[u]) {
					 insert = u & 3;
					 resize[u] = true;
				 }
				 u = u + 4 - (u & 3);
				 u += 8 * readInt(b, u + 4) + 8;
				 break;
				 case ClassWriter.WIDE_INSN: opcode = b[u + 1] & 0xFF;
				 if (opcode == Opcodes.IINC) {
					 u += 6;
				 }
				 else {
					 u += 4;
				 }
				 break;
				 case ClassWriter.VAR_INSN: case ClassWriter.SBYTE_INSN: case ClassWriter.LDC_INSN: u += 2;
				 break;
				 case ClassWriter.SHORT_INSN: case ClassWriter.LDCW_INSN: case ClassWriter.FIELDORMETH_INSN: case ClassWriter.TYPE_INSN: case ClassWriter.IINC_INSN: u += 3;
				 break;
				 case ClassWriter.ITFMETH_INSN: case ClassWriter.INDYMETH_INSN: u += 5;
				 break;
				 default: u += 4;
				 break;
			 }
			 if (insert != 0) {
				 int[] newIndexes = new int[allIndexes.length + 1];
				 int[] newSizes = new int[allSizes.length + 1];
				 System.arraycopy(allIndexes, 0, newIndexes, 0, allIndexes.length);
				 System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);
				 newIndexes[allIndexes.length] = u;
				 newSizes[allSizes.length] = insert;
				 allIndexes = newIndexes;
				 allSizes = newSizes;
				 if (insert > 0) {
					 state = 3;
				 }
			 }
		 }
		 if (state < 3) {
			 --state;
		 }
	 }
	 while (state != 0);
	 ByteVector newCode = new ByteVector(code.length);
	 u = 0;
	 while (u < code.length) {
		 int opcode = b[u] & 0xFF;
		 switch (ClassWriter.TYPE[opcode]) {
			 case ClassWriter.NOARG_INSN: case ClassWriter.IMPLVAR_INSN: newCode.putByte(opcode);
			 u += 1;
			 break;
			 case ClassWriter.LABEL_INSN: if (opcode > 201) {
				 opcode = opcode < 218 ? opcode - 49 : opcode - 20;
				 label = u + readUnsignedShort(b, u + 1);
			 }
			 else {
				 label = u + readShort(b, u + 1);
			 }
			 newOffset = getNewOffset(allIndexes, allSizes, u, label);
			 if (resize[u]) {
				 if (opcode == Opcodes.GOTO) {
					 newCode.putByte(200);
				 }
				 else if (opcode == Opcodes.JSR) {
					 newCode.putByte(201);
				 }
				 else {
					 newCode.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);
					 newCode.putShort(8);
					 newCode.putByte(200);
					 newOffset -= 3;
				 }
				 newCode.putInt(newOffset);
			 }
			 else {
				 newCode.putByte(opcode);
				 newCode.putShort(newOffset);
			 }
			 u += 3;
			 break;
			 case ClassWriter.LABELW_INSN: label = u + readInt(b, u + 1);
			 newOffset = getNewOffset(allIndexes, allSizes, u, label);
			 newCode.putByte(opcode);
			 newCode.putInt(newOffset);
			 u += 5;
			 break;
			 case ClassWriter.TABL_INSN: v = u;
			 u = u + 4 - (v & 3);
			 newCode.putByte(Opcodes.TABLESWITCH);
			 newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);
			 label = v + readInt(b, u);
			 u += 4;
			 newOffset = getNewOffset(allIndexes, allSizes, v, label);
			 newCode.putInt(newOffset);
			 j = readInt(b, u);
			 u += 4;
			 newCode.putInt(j);
			 j = readInt(b, u) - j + 1;
			 u += 4;
			 newCode.putInt(readInt(b, u - 4));
			 for (;
			 j > 0;
			 --j) {
				 label = v + readInt(b, u);
				 u += 4;
				 newOffset = getNewOffset(allIndexes, allSizes, v, label);
				 newCode.putInt(newOffset);
			 }
			 break;
			 case ClassWriter.LOOK_INSN: v = u;
			 u = u + 4 - (v & 3);
			 newCode.putByte(Opcodes.LOOKUPSWITCH);
			 newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);
			 label = v + readInt(b, u);
			 u += 4;
			 newOffset = getNewOffset(allIndexes, allSizes, v, label);
			 newCode.putInt(newOffset);
			 j = readInt(b, u);
			 u += 4;
			 newCode.putInt(j);
			 for (;
			 j > 0;
			 --j) {
				 newCode.putInt(readInt(b, u));
				 u += 4;
				 label = v + readInt(b, u);
				 u += 4;
				 newOffset = getNewOffset(allIndexes, allSizes, v, label);
				 newCode.putInt(newOffset);
			 }
			 break;
			 case ClassWriter.WIDE_INSN: opcode = b[u + 1] & 0xFF;
			 if (opcode == Opcodes.IINC) {
				 newCode.putByteArray(b, u, 6);
				 u += 6;
			 }
			 else {
				 newCode.putByteArray(b, u, 4);
				 u += 4;
			 }
			 break;
			 case ClassWriter.VAR_INSN: case ClassWriter.SBYTE_INSN: case ClassWriter.LDC_INSN: newCode.putByteArray(b, u, 2);
			 u += 2;
			 break;
			 case ClassWriter.SHORT_INSN: case ClassWriter.LDCW_INSN: case ClassWriter.FIELDORMETH_INSN: case ClassWriter.TYPE_INSN: case ClassWriter.IINC_INSN: newCode.putByteArray(b, u, 3);
			 u += 3;
			 break;
			 case ClassWriter.ITFMETH_INSN: case ClassWriter.INDYMETH_INSN: newCode.putByteArray(b, u, 5);
			 u += 5;
			 break;
			 default: newCode.putByteArray(b, u, 4);
			 u += 4;
			 break;
		 }
	 }
	 if (frameCount > 0) {
		 if (compute == FRAMES) {
			 frameCount = 0;
			 stackMap = null;
			 previousFrame = null;
			 frame = null;
			 Frame f = new Frame();
			 f.owner = labels;
			 Type[] args = Type.getArgumentTypes(descriptor);
			 f.initInputFrame(cw, access, args, maxLocals);
			 visitFrame(f);
			 Label l = labels;
			 while (l != null) {
				 u = l.position - 3;
				 if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u])) {
					 getNewOffset(allIndexes, allSizes, l);
					 visitFrame(l.frame);
				 }
				 l = l.successor;
			 }
		 }
		 else {
			 cw.invalidFrames = true;
		 }
	 }
	 Handler h = firstHandler;
	 while (h != null) {
		 getNewOffset(allIndexes, allSizes, h.start);
		 getNewOffset(allIndexes, allSizes, h.end);
		 getNewOffset(allIndexes, allSizes, h.handler);
		 h = h.next;
	 }
	 for (i = 0;
	 i < 2;
	 ++i) {
		 ByteVector bv = i == 0 ? localVar : localVarType;
		 if (bv != null) {
			 b = bv.data;
			 u = 0;
			 while (u < bv.length) {
				 label = readUnsignedShort(b, u);
				 newOffset = getNewOffset(allIndexes, allSizes, 0, label);
				 writeShort(b, u, newOffset);
				 label += readUnsignedShort(b, u + 2);
				 newOffset = getNewOffset(allIndexes, allSizes, 0, label) - newOffset;
				 writeShort(b, u + 2, newOffset);
				 u += 10;
			 }
		 }
	 }
	 if (lineNumber != null) {
		 b = lineNumber.data;
		 u = 0;
		 while (u < lineNumber.length) {
			 writeShort( b, u, getNewOffset(allIndexes, allSizes, 0, readUnsignedShort(b, u)));
			 u += 4;
		 }
	 }
	 Attribute attr = cattrs;
	 while (attr != null) {
		 Label[] labels = attr.getLabels();
		 if (labels != null) {
			 for (i = labels.length - 1;
			 i >= 0;
			 --i) {
				 getNewOffset(allIndexes, allSizes, labels[i]);
			 }
		 }
		 attr = attr.next;
	 }
	 code = newCode;
 }",0,0,1,0
"public abstract class AbstractTree extends PanelimplementsITreeStateListener,TreeModelListener,AjaxRequestTarget.ITargetRespondListener{
	private static final long serialVersionUID = 1L;
	private static interface IItemCallback{
		void visitItem(TreeItem item);
	}
	private final class TreeItem extends WebMarkupContainer{
		private final static int FLAG_RENDER_CHILDREN = FLAG_RESERVED8;
		private static final long serialVersionUID = 1L;
		private List<TreeItem> children = null;
		private final int level;
		private final TreeItem parent;
		public TreeItem(TreeItem parent, String id, final Object node, int level){
			super(id, new Model<Serializable>((Serializable)node));
			this.parent = parent;
			nodeToItemMap.put(node, this);
			this.level = level;
			setOutputMarkupId(true);
			if (level != -1){
				populateTreeItem(this, level);
			}
		}
		public TreeItem getParentItem(){
			return parent;
		}
		public List<TreeItem> getChildren(){
			return children;
		}
		public int getLevel(){
			return level;
		}
		public String getMarkupId(){
			return AbstractTree.this.getMarkupId() + ""_"" + getId();
		}
		public void setChildren(List<TreeItem> children){
			this.children = children;
		}
		protected final boolean isRenderChildren(){
			return getFlag(FLAG_RENDER_CHILDREN);
		}
		public boolean hasChildTreeItems(){
			return children != null && !children.isEmpty();
		}
		protected void onRender(final MarkupStream markupStream){
			if (this == rootItem && isRootLess() == true){
				String tagName = ((ComponentTag)markupStream.get()).getName();
				getResponse().write(""<"" + tagName + "" style=\""display:none\"" id=\"""" + getMarkupId() + ""\""></"" +tagName + "">"");
				markupStream.skipComponent();
			}
			else{
				final int index = markupStream.getCurrentIndex();
				super.onRender(markupStream);
				if (isRenderChildren()){
					visitItemChildren(this, new IItemCallback(){
						public void visitItem(TreeItem item){
							markupStream.setCurrentIndex(index);
							item.onRender(markupStream);
							List<IBehavior> behaviors = item.getBehaviors();
							for (IBehavior behavior : behaviors){
								behavior.afterRender(item);
							}
						}
					}
					);
				}
			}
		}
		public Object getModelObject(){
			return getDefaultModelObject();
		}
		public void renderHead(final HtmlHeaderContainer container){
			super.renderHead(container);
			if (isRenderChildren()){
				visitItemChildren(this, new IItemCallback(){
					public void visitItem(TreeItem item){
						item.visitChildren(new Component.IVisitor<Component>(){
							public Object component(Component component){
								if (component.isVisible()){
									component.renderHead(container);
									return CONTINUE_TRAVERSAL;
								}
								else{
									return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
								}
							}
						}
						);
					}
				}
				);
			}
		}
		protected final void setRenderChildren(boolean value){
			setFlag(FLAG_RENDER_CHILDREN, value);
		}
		protected void onDetach(){
			super.onDetach();
			Object object = getModelObject();
			if (object instanceof IDetachable){
				((IDetachable)object).detach();
			}
			if (isRenderChildren()){
				visitItemChildren(this, new IItemCallback(){
					public void visitItem(TreeItem item){
						item.detach();
					}
				}
				);
			}
			setRenderChildren(false);
		}
		protected void onBeforeRender(){
			onBeforeRenderInternal();
			super.onBeforeRender();
			if (isRenderChildren()){
				visitItemChildren(this, new IItemCallback(){
					public void visitItem(TreeItem item){
						item.prepareForRender();
					}
				}
				);
			}
		}
		protected void onAfterRender(){
			super.onAfterRender();
			if (isRenderChildren()){
				visitItemChildren(this, new IItemCallback(){
					public void visitItem(TreeItem item){
						item.afterRender();
					}
				}
				);
			}
		}
		private boolean hasParentWithChildrenMarkedToRecreation(){
			return getParentItem() != null &&(getParentItem().getChildren() == null || getParentItem().hasParentWithChildrenMarkedToRecreation());
		}
	}
	private class TreeItemContainer extends WebMarkupContainer{
		private static final long serialVersionUID = 1L;
		public TreeItemContainer(String id){
			super(id);
		}
		public void remove(Component component){
			if (component instanceof TreeItem){
				nodeToItemMap.remove(((TreeItem)component).getModelObject());
			}
			super.remove(component);
		}
		protected void onRender(final MarkupStream markupStream){
			final int markupStart = markupStream.getCurrentIndex();
			final class Rendered{
				boolean rendered = false;
			}
			final Rendered rendered = new Rendered();
			if (rootItem != null){
				IItemCallback callback = new IItemCallback(){
					public void visitItem(TreeItem item){
						markupStream.setCurrentIndex(markupStart);
						item.render(markupStream);
						rendered.rendered = true;
					}
				}
				;
				visitItemAndChildren(rootItem, callback);
			}
			if (rendered.rendered == false){
				markupStream.skipComponent();
			}
		}
	}
	private boolean attached = false;
	private final AppendingStringBuffer deleteIds = new AppendingStringBuffer();
	private boolean dirtyAll = false;
	private final Set<TreeItem> dirtyItems = new HashSet<TreeItem>();
	private final Set<TreeItem> dirtyItemsCreateDOM = new HashSet<TreeItem>();
	private int idCounter = 0;
	private TreeItemContainer itemContainer;
	private final Map<Object, TreeItem> nodeToItemMap = new HashMap<Object, TreeItem>();
	private TreeModel previousModel = null;
	private TreeItem rootItem = null;
	private boolean rootLess = false;
	private ITreeState state;
	public AbstractTree(String id){
		super(id);
		init();
	}
	public AbstractTree(String id, IModel<TreeModel> model){
		super(id, model);
		init();
	}
	public final void allNodesCollapsed(){
		invalidateAll();
	}
	public final void allNodesExpanded(){
		invalidateAll();
	}
	public IModel<TreeModel> getModel(){
		return (IModel<TreeModel>)getDefaultModel();
	}
	public TreeModel getModelObject(){
		return (TreeModel)getDefaultModelObject();
	}
	public MarkupContainer setModel(IModel<TreeModel> model){
		setDefaultModel(model);
		return this;
	}
	public MarkupContainer setModelObject(TreeModel model){
		setDefaultModelObject(model);
		return this;
	}
	public ITreeState getTreeState(){
		if (state == null){
			state = newTreeState();
			state.addTreeStateListener(this);
		}
		return state;
	}
	protected void onBeforeAttach(){
	}
	private void onBeforeRenderInternal(){
		if (attached == false){
			onBeforeAttach();
			checkModel();
			if (dirtyAll && rootItem != null){
				clearAllItem();
			}
			else{
				rebuildDirty();
			}
			if (rootItem == null){
				Object rootNode = getModelObject().getRoot();
				if (rootNode != null){
					if (isRootLess()){
						rootItem = newTreeItem(null, rootNode, -1);
					}
					else{
						rootItem = newTreeItem(null, rootNode, 0);
					}
					itemContainer.add(rootItem);
					buildItemChildren(rootItem);
				}
			}
			attached = true;
		}
	}
	public void onBeforeRender(){
		onBeforeRenderInternal();
		super.onBeforeRender();
	}
	public void onDetach(){
		attached = false;
		super.onDetach();
		if (getTreeState() instanceof IDetachable){
			((IDetachable)getTreeState()).detach();
		}
	}
	public final void invalidateAll(){
		updated();
		dirtyAll = true;
	}
	public final boolean isRootLess(){
		return rootLess;
	}
	public final void nodeCollapsed(Object node){
		if (isNodeVisible(node) == true){
			invalidateNodeWithChildren(node);
		}
	}
	public final void nodeExpanded(Object node){
		if (isNodeVisible(node) == true){
			invalidateNodeWithChildren(node);
		}
	}
	public final void nodeSelected(Object node){
		if (isNodeVisible(node)){
			invalidateNode(node, isForceRebuildOnSelectionChange());
		}
	}
	public final void nodeUnselected(Object node){
		if (isNodeVisible(node)){
			invalidateNode(node, isForceRebuildOnSelectionChange());
		}
	}
	protected boolean isForceRebuildOnSelectionChange(){
		return true;
	}
	public void setRootLess(boolean rootLess){
		if (this.rootLess != rootLess){
			this.rootLess = rootLess;
			invalidateAll();
			if (rootLess == true && getModelObject() != null){
				getTreeState().expandNode(getModelObject().getRoot());
			}
		}
	}
	public final void treeNodesChanged(TreeModelEvent e){
		if (dirtyAll){
			return;
		}
		if (e.getChildren() == null){
			if (rootItem != null){
				invalidateNode(rootItem.getModelObject(), true);
			}
		}
		else{
			Object[] children = e.getChildren();
			if (children != null){
				for (Object node : children){
					if (isNodeVisible(node)){
						invalidateNode(node, true);
					}
				}
			}
		}
	}
	private void markTheLastButOneChildDirty(TreeItem parent, TreeItem child){
		if (parent.getChildren().indexOf(child) == parent.getChildren().size() - 1){
			for (int i = parent.getChildren().size() - 2;
			 i >= 0;
			 --i){
				TreeItem item = parent.getChildren().get(i);
				invalidateNodeWithChildren(item.getModelObject());
			}
		}
	}
	public final void treeNodesInserted(TreeModelEvent e){
		if (dirtyAll){
			return;
		}
		Object parentNode = e.getTreePath().getLastPathComponent();
		TreeItem parentItem = nodeToItemMap.get(parentNode);
		if (parentItem != null && isNodeVisible(parentNode)){
			List<?> eventChildren = Arrays.asList(e.getChildren());
			boolean wasLeaf = true;
			int nodeChildCount = getChildCount(parentNode);
			for (int i = 0;
			 wasLeaf && i < nodeChildCount;
			 i++){
				wasLeaf = eventChildren.contains(getChildAt(parentNode, i));
			}
			boolean addingToHiddedRoot = parentItem.getParentItem() == null && isRootLess();
			if (wasLeaf && !addingToHiddedRoot){
				Object grandparentNode = getParentNode(parentNode);
				boolean addingToHiddedRootSon = grandparentNode != null &&getParentNode(grandparentNode) == null && isRootLess();
				if (grandparentNode != null && !addingToHiddedRootSon){
					invalidateNodeWithChildren(grandparentNode);
				}
				else{
					invalidateNode(parentNode, true);
				}
				getTreeState().expandNode(parentNode);
			}
			else{
				if (isNodeExpanded(parentNode)){
					List<TreeItem> itemChildren = parentItem.getChildren();
					int childLevel = parentItem.getLevel() + 1;
					final int[] childIndices = e.getChildIndices();
					for (int i = 0;
					 i < eventChildren.size();
					 ++i){
						TreeItem item = newTreeItem(parentItem, eventChildren.get(i), childLevel);
						itemContainer.add(item);
						if (itemChildren != null){
							itemChildren.add(childIndices[i], item);
							markTheLastButOneChildDirty(parentItem, item);
						}
						if (!dirtyItems.contains(item)){
							dirtyItems.add(item);
						}
						if (!dirtyItemsCreateDOM.contains(item) &&!item.hasParentWithChildrenMarkedToRecreation()){
							dirtyItemsCreateDOM.add(item);
						}
					}
				}
			}
		}
	}
	public final void treeNodesRemoved(TreeModelEvent removalEvent){
		if (dirtyAll){
			return;
		}
		Object parentNode = removalEvent.getTreePath().getLastPathComponent();
		TreeItem parentItem = nodeToItemMap.get(parentNode);
		List<Object> selection = new ArrayList<Object>(getTreeState().getSelectedNodes());
		List<Object> removed = Arrays.asList(removalEvent.getChildren());
		for (Object selectedNode : selection){
			Object cursor = selectedNode;
			while (cursor != null){
				if (removed.contains(cursor)){
					getTreeState().selectNode(selectedNode, false);
				}
				if (cursor instanceof TreeNode){
					cursor = ((TreeNode)cursor).getParent();
				}
				else{
					cursor = null;
				}
			}
		}
		if (parentItem != null && isNodeVisible(parentNode)){
			if (isNodeExpanded(parentNode)){
				for (Object deletedNode : removalEvent.getChildren()){
					TreeItem itemToDelete = nodeToItemMap.get(deletedNode);
					if (itemToDelete != null){
						markTheLastButOneChildDirty(parentItem, itemToDelete);
						visitItemChildren(itemToDelete, new IItemCallback(){
							public void visitItem(TreeItem item){
								removeItem(item);
							}
						}
						);
						parentItem.getChildren().remove(itemToDelete);
						removeItem(itemToDelete);
					}
				}
			}
			if (!parentItem.hasChildTreeItems()){
				invalidateNode(parentNode, true);
			}
		}
	}
	public final void treeStructureChanged(TreeModelEvent e){
		if (dirtyAll){
			return;
		}
		Object node = e.getTreePath() != null ? e.getTreePath().getLastPathComponent() : null;
		if (node == null || e.getTreePath().getPathCount() == 1){
			invalidateAll();
		}
		else{
			invalidateNodeWithChildren(node);
		}
	}
	public final void updateTree(){
		IRequestTarget target = getRequestCycle().getRequestTarget();
		if (target instanceof AjaxRequestTarget){
			updateTree((AjaxRequestTarget)target);
		}
	}
	protected void addComponent(AjaxRequestTarget target, Component component){
		target.addComponent(component);
	}
	public void onTargetRespond(AjaxRequestTarget target){
		checkModel();
		if (dirtyAll){
			addComponent(target, this);
		}
		else{
			if (deleteIds.length() != 0){
				String js = getElementsDeleteJavascript();
				target.prependJavascript(js);
			}
			while (dirtyItemsCreateDOM.isEmpty() == false){
				for (Iterator<TreeItem> i = dirtyItemsCreateDOM.iterator();
				 i.hasNext();
				){
					TreeItem item = i.next();
					TreeItem parent = item.getParentItem();
					int index = parent.getChildren().indexOf(item);
					TreeItem previous;
					if (index == 0){
						previous = parent;
					}
					else{
						previous = parent.getChildren().get(index - 1);
						while (previous.getChildren() != null && previous.getChildren().size() > 0){
							previous = previous.getChildren().get(previous.getChildren().size() - 1);
						}
					}
					if (dirtyItemsCreateDOM.contains(previous) == false){
						target.prependJavascript(""Wicket.Tree.createElement(\"""" +item.getMarkupId() + ""\"","" + ""\"""" + previous.getMarkupId() + ""\"")"");
						i.remove();
					}
					else{
					}
				}
			}
			for (TreeItem item : dirtyItems){
				if (item.getChildren() == null){
					buildItemChildren(item);
					item.setRenderChildren(true);
				}
				addComponent(target, item);
			}
			updated();
		}
	}
	public final void updateTree(final AjaxRequestTarget target){
		if (target == null){
			return;
		}
		target.registerRespondListener(this);
	}
	protected final boolean isNodeExpanded(Object node){
		if (isRootLess() && rootItem != null && rootItem.getModelObject().equals(node)){
			return true;
		}
		return getTreeState().isNodeExpanded(node);
	}
	protected ITreeState newTreeState(){
		return new DefaultTreeState();
	}
	protected void onAfterRender(){
		super.onAfterRender();
		updated();
	}
	protected abstract void populateTreeItem(WebMarkupContainer item, int level);
	private void buildItemChildren(TreeItem item){
		List<TreeItem> items;
		if (isNodeExpanded(item.getModelObject())){
			items = buildTreeItems(item, nodeChildren(item.getModelObject()), item.getLevel() + 1);
		}
		else{
			items = new ArrayList<TreeItem>(0);
		}
		item.setChildren(items);
	}
	private List<TreeItem> buildTreeItems(TreeItem parent, Iterator<Object> nodes, int level){
		List<TreeItem> result = new ArrayList<TreeItem>();
		while (nodes.hasNext()){
			Object node = nodes.next();
			TreeItem item = newTreeItem(parent, node, level);
			itemContainer.add(item);
			buildItemChildren(item);
			result.add(item);
		}
		return result;
	}
	private void checkModel(){
		TreeModel model = getModelObject();
		if (model != previousModel){
			if (previousModel != null){
				previousModel.removeTreeModelListener(this);
			}
			previousModel = model;
			if (model != null){
				model.addTreeModelListener(this);
			}
			invalidateAll();
		}
	}
	private void clearAllItem(){
		visitItemAndChildren(rootItem, new IItemCallback(){
			public void visitItem(TreeItem item){
				item.remove();
			}
		}
		);
		rootItem = null;
	}
	private String getElementsDeleteJavascript(){
		final AppendingStringBuffer buffer = new AppendingStringBuffer(100);
		buffer.append(""Wicket.Tree.removeNodes(\"""");
		buffer.append(getMarkupId() + ""_\"",["");
		buffer.append(deleteIds);
		if (buffer.endsWith("","")){
			buffer.setLength(buffer.length() - 1);
		}
		buffer.append(""]);
		"");
		return buffer.toString();
	}
	private String getShortItemId(TreeItem item){
		final int skip = getMarkupId().length() + 1;
		 return item.getMarkupId().substring(skip);
	}
	private final static ResourceReference JAVASCRIPT = new JavascriptResourceReference(AbstractTree.class, ""res/tree.js"");
	private void init(){
		setVersioned(false);
		setOutputMarkupId(true);
		itemContainer = new TreeItemContainer(""i"");
		add(itemContainer);
		add(JavascriptPackageResource.getHeaderContribution(JAVASCRIPT));
		checkModel();
	}
	public final void markNodeDirty(Object node){
		invalidateNode(node, false);
	}
	public final void markNodeChildrenDirty(Object node){
		TreeItem item = nodeToItemMap.get(node);
		if (item != null){
			visitItemChildren(item, new IItemCallback(){
				public void visitItem(TreeItem item){
					invalidateNode(item.getModelObject(), false);
				}
			}
			);
		}
	}
	private void invalidateNode(Object node, boolean forceRebuild){
		if (dirtyAll == false){
			TreeItem item = nodeToItemMap.get(node);
			if (item != null){
				boolean createDOM = false;
				if (forceRebuild){
					int level = item.getLevel();
					List<TreeItem> children = item.getChildren();
					String id = item.getId();
					TreeItem parent = item.getParentItem();
					int index = parent != null ? parent.getChildren().indexOf(item) : -1;
					createDOM = dirtyItemsCreateDOM.contains(item);
					dirtyItems.remove(item);
					dirtyItemsCreateDOM.remove(item);
					item.remove();
					item = newTreeItem(parent, node, level, id);
					itemContainer.add(item);
					item.setChildren(children);
					if (parent == null){
						rootItem = item;
					}
					else{
						parent.getChildren().set(index, item);
					}
				}
				if (!dirtyItems.contains(item)){
					dirtyItems.add(item);
				}
				if (createDOM && !dirtyItemsCreateDOM.contains(item)){
					dirtyItemsCreateDOM.add(item);
				}
			}
		}
	}
	private void invalidateNodeWithChildren(Object node){
		if (dirtyAll == false){
			TreeItem item = nodeToItemMap.get(node);
			if (item != null){
				visitItemChildren(item, new IItemCallback(){
					public void visitItem(TreeItem item){
						removeItem(item);
					}
				}
				);
				item.setChildren(null);
				if (!dirtyItems.contains(item)){
					dirtyItems.add(item);
				}
			}
		}
	}
	private boolean isNodeVisible(Object node){
		if (node == null){
			return false;
		}
		Object parent = getParentNode(node);
		while (parent != null){
			if (isNodeExpanded(parent) == false){
				return false;
			}
			parent = getParentNode(parent);
		}
		return true;
	}
	public Object getParentNode(Object node){
		TreeItem item = nodeToItemMap.get(node);
		if (item == null){
			return null;
		}
		else{
			TreeItem parent = item.getParentItem();
			return parent == null ? null : parent.getModelObject();
		}
	}
	private TreeItem newTreeItem(TreeItem parent, Object node, int level){
		return new TreeItem(parent, """" + idCounter++, node, level);
	}
	private TreeItem newTreeItem(TreeItem parent, Object node, int level, String id){
		return new TreeItem(parent, id, node, level);
	}
	public final Iterator<Object> nodeChildren(Object node){
		TreeModel model = getTreeModel();
		int count = model.getChildCount(node);
		List<Object> nodes = new ArrayList<Object>(count);
		for (int i = 0;
		 i < count;
		 ++i){
			nodes.add(model.getChild(node, i));
		}
		return nodes.iterator();
	}
	public final Object getChildAt(Object parent, int index){
		return getTreeModel().getChild(parent, index);
	}
	public final boolean isLeaf(Object node){
		return getTreeModel().isLeaf(node);
	}
	public final int getChildCount(Object parent){
		return getTreeModel().getChildCount(parent);
	}
	private TreeModel getTreeModel(){
		return getModelObject();
	}
	private void rebuildDirty(){
		for (TreeItem item : dirtyItems){
			if (item.getChildren() == null){
				buildItemChildren(item);
			}
		}
	}
	private void removeItem(TreeItem item){
		dirtyItems.remove(item);
		if (dirtyItemsCreateDOM.contains(item)){
			dirtyItemsCreateDOM.remove(item);
		}
		else{
			deleteIds.append(getShortItemId(item));
			deleteIds.append("","");
		}
		if (item.getParent() != null){
			item.remove();
		}
	}
	private void updated(){
		dirtyAll = false;
		dirtyItems.clear();
		dirtyItemsCreateDOM.clear();
		deleteIds.clear();
	 }
	private void visitItemAndChildren(TreeItem item, IItemCallback callback){
		callback.visitItem(item);
		visitItemChildren(item, callback);
	}
	private void visitItemChildren(TreeItem item, IItemCallback callback){
		if (item.getChildren() != null){
			for (TreeItem child : item.getChildren()){
				visitItemAndChildren(child, callback);
			}
		}
	}
	public Component getNodeComponent(Object node){
		return nodeToItemMap.get(node);
	}
}",1,0,0,0
"private void saveAdvSettings() {
	Config config = Config.getInstance();
	config.setAutoShutdown(chkHaltAfterFinish.isSelected());
	config.setKeepAwake(chkKeepAwake.isSelected());
	config.setExecCmd(chkExecCmd.isSelected());
	config.setExecAntivir(chkExecAntivir.isSelected());
	if (chkAutoStart.isSelected()) {
		XDMUtils.addToStartup();
	}
	 else {
		XDMUtils.removeFromStartup();
	}
	String customCmd = txtCustomCmd.getText();
	config.setCustomCmd(customCmd);
	String antivirExec = txtAntivirCmd.getText();
	config.setAntivirExe(antivirExec);
	String antivirCmd = txtAntivirArgs.getText();
	config.setAntivirCmd(antivirCmd);
}",0,0,0,0
"public class SpamFilter extends BasicPageFilter{
	 private static final String ATTR_SPAMFILTER_SCORE = ""spamfilter.score"";
	 private static final String REASON_REGEXP = ""Regexp"";
	 private static final String REASON_IP_BANNED_TEMPORARILY = ""IPBannedTemporarily"";
	 private static final String REASON_BOT_TRAP = ""BotTrap"";
	 private static final String REASON_AKISMET = ""Akismet"";
	 private static final String REASON_TOO_MANY_URLS = ""TooManyUrls"";
	 private static final String REASON_SIMILAR_MODIFICATIONS = ""SimilarModifications"";
	 private static final String REASON_TOO_MANY_MODIFICATIONS = ""TooManyModifications"";
	 private static final String REASON_UTF8_TRAP = ""UTF8Trap"";
	 private static final String LISTVAR = ""spamwords"";
	 public static final String PROP_WORDLIST = ""wordlist"";
	 public static final String PROP_ERRORPAGE = ""errorpage"";
	 public static final String PROP_PAGECHANGES = ""pagechangesinminute"";
	 public static final String PROP_SIMILARCHANGES = ""similarchanges"";
	 public static final String PROP_BANTIME = ""bantime"";
	 public static final String PROP_BLACKLIST = ""blacklist"";
	 public static final String PROP_MAXURLS = ""maxurls"";
	 public static final String PROP_AKISMET_API_KEY = ""akismet-apikey"";
	 public static final String PROP_IGNORE_AUTHENTICATED = ""ignoreauthenticated"";
	 public static final String PROP_CAPTCHA = ""captcha"";
	 public static final String PROP_FILTERSTRATEGY = ""strategy"";
	 public static final String STRATEGY_EAGER = ""eager"";
	 public static final String STRATEGY_SCORE = ""score"";
	 private static final String URL_REGEXP = ""(http: private String m_forbiddenWordsPage = ""SpamFilterWordList"";
	 private String m_errorPage = ""RejectedMessage"";
	 private String m_blacklist = ""SpamFilterWordList/blacklist.txt"";
	 private PatternMatcher m_matcher = new Perl5Matcher();
	 private PatternCompiler m_compiler = new Perl5Compiler();
	 private Collection<Pattern> m_spamPatterns = null;
	 private Date m_lastRebuild = new Date( 0L );
	 private static Logger c_spamlog = Logger.getLogger( ""SpamLog"" );
	 private static Logger log = Logger.getLogger( SpamFilter.class );
	 private Vector<Host> m_temporaryBanList = new Vector<Host>();
	 private int m_banTime = 60;
	 private Vector<Host> m_lastModifications = new Vector<Host>();
	 private int m_limitSinglePageChanges = 5;
	 private int m_limitSimilarChanges = 2;
	 private int m_maxUrls = 10;
	 private Pattern m_urlPattern;
	 private Akismet m_akismet;
	 private String m_akismetAPIKey = null;
	 private boolean m_useCaptcha = false;
	 private int m_scoreLimit = 1;
	 private boolean m_ignoreAuthenticated = false;
	 private boolean m_stopAtFirstMatch = true;
	 private static String c_hashName;
	 private static long c_lastUpdate;
	 private static final long HASH_DELAY = 24;
	 public void initialize( WikiEngine engine, Properties properties ) {
		 m_forbiddenWordsPage = properties.getProperty( PROP_WORDLIST, m_forbiddenWordsPage );
		 m_errorPage = properties.getProperty( PROP_ERRORPAGE, m_errorPage );
		 m_limitSinglePageChanges = TextUtil.getIntegerProperty( properties, PROP_PAGECHANGES, m_limitSinglePageChanges );
		 m_limitSimilarChanges = TextUtil.getIntegerProperty( properties, PROP_SIMILARCHANGES, m_limitSimilarChanges );
		 m_maxUrls = TextUtil.getIntegerProperty( properties, PROP_MAXURLS, m_maxUrls );
		 m_banTime = TextUtil.getIntegerProperty( properties, PROP_BANTIME, m_banTime );
		 m_blacklist = properties.getProperty( PROP_BLACKLIST, m_blacklist );
		 m_ignoreAuthenticated = TextUtil.getBooleanProperty( properties, PROP_IGNORE_AUTHENTICATED, m_ignoreAuthenticated );
		 m_useCaptcha = properties.getProperty( PROP_CAPTCHA, """" ).equals(""asirra"");
		 try {
			 m_urlPattern = m_compiler.compile( URL_REGEXP );
		 }
		 catch( MalformedPatternException e ) {
			 log.fatal(""Internal error: Someone put in a faulty pattern."",e);
			 throw new InternalWikiException(""Faulty pattern."");
		 }
		 m_akismetAPIKey = TextUtil.getStringProperty( properties, PROP_AKISMET_API_KEY, m_akismetAPIKey );
		 m_stopAtFirstMatch = TextUtil.getStringProperty( properties, PROP_FILTERSTRATEGY, STRATEGY_EAGER ).equals(STRATEGY_EAGER);
		 log.info(""# Spam filter initialized. Temporary ban time ""+m_banTime+ "" mins, max page changes/minute: ""+m_limitSinglePageChanges );
	 }
	 private static final int REJECT = 0;
	 private static final int ACCEPT = 1;
	 private static final int NOTE = 2;
	 private static String log( WikiContext ctx, int type, String source, String message ) {
		 message = TextUtil.replaceString( message, ""\r\n"", ""\\r\\n"" );
		 message = TextUtil.replaceString( message, ""\"""", ""\\\"""" );
		 String uid = getUniqueID();
		 String page = ctx.getPage().getName();
		 String reason = ""UNKNOWN"";
		 String addr = ctx.getHttpRequest() != null ? ctx.getHttpRequest().getRemoteAddr() : ""-"";
		 switch( type ) {
			 case REJECT: reason = ""REJECTED"";
			 break;
			 case ACCEPT: reason = ""ACCEPTED"";
			 break;
			 case NOTE: reason = ""NOTE"";
			 break;
			 default: throw new InternalWikiException(""Illegal type ""+type);
		 }
		 c_spamlog.info( reason+"" ""+source+"" ""+uid+"" ""+addr+"" \""""+page+""\"" ""+message );
		 return uid;
	 }
	 public String preSave( WikiContext context, String content ) throws RedirectException {
		 cleanBanList();
		 refreshBlacklists(context);
		 Change change = getChange( context, content );
		 if(!ignoreThisUser(context)) {
			 checkBanList( context, change );
			 checkSinglePageChange( context, content, change );
			 checkPatternList(context, content, change);
		 }
		 if( !m_stopAtFirstMatch ) {
			 Integer score = (Integer)context.getVariable(ATTR_SPAMFILTER_SCORE);
			 if( score != null && score.intValue() >= m_scoreLimit ) {
				 throw new RedirectException( ""Herb says you got too many points"", getRedirectPage(context) );
			 }
		 }
		 log( context, ACCEPT, ""-"", change.toString() );
		 return content;
	 }
	 private void checkStrategy( WikiContext context, String error, String message ) throws RedirectException {
		 if( m_stopAtFirstMatch ) {
			 throw new RedirectException( message, getRedirectPage(context) );
		 }
		 Integer score = (Integer)context.getVariable( ATTR_SPAMFILTER_SCORE );
		 if( score != null ) score = score+1;
		 else score = 1;
		 context.setVariable( ATTR_SPAMFILTER_SCORE, score );
	 }
	 private Collection<Pattern> parseWordList( WikiPage source, String list ) {
		 ArrayList<Pattern> compiledpatterns = new ArrayList<Pattern>();
		 if( list != null ) {
			 StringTokenizer tok = new StringTokenizer( list, "" \t\n"" );
			 while( tok.hasMoreTokens() ) {
				 String pattern = tok.nextToken();
				 try {
					 compiledpatterns.add( m_compiler.compile( pattern ) );
				 }
				 catch( MalformedPatternException e ) {
					 log.debug( ""Malformed spam filter pattern ""+pattern );
					 source.setAttribute(""error"", ""Malformed spam filter pattern ""+pattern);
				 }
			 }
		 }
		 return compiledpatterns;
	 }
	 private Collection<Pattern> parseBlacklist( String list ) {
		 ArrayList<Pattern> compiledpatterns = new ArrayList<Pattern>();
		 if( list != null ) {
			 try {
				 BufferedReader in = new BufferedReader( new StringReader(list) );
				 String line;
				 while( (line = in.readLine()) != null ) {
					 line = line.trim();
					 if( line.length() == 0 ) continue;
					 if( line.startsWith(""#"") ) continue;
					 int ws = line.indexOf(' ');
					 if( ws == -1 ) ws = line.indexOf('\t');
					 if( ws != -1 ) line = line.substring(0,ws);
					 try {
						 compiledpatterns.add( m_compiler.compile( line ) );
					 }
					 catch( MalformedPatternException e ) {
						 log.debug( ""Malformed spam filter pattern ""+line );
					 }
				 }
			 }
			 catch( IOException e ) {
				 log.info(""Could not read patterns;
				 returning what I got"",e);
			 }
		 }
		 return compiledpatterns;
	 }
	 private synchronized void checkSinglePageChange( WikiContext context, String content, Change change ) throws RedirectException {
		 HttpServletRequest req = context.getHttpRequest();
		 if( req != null ) {
			 String addr = req.getRemoteAddr();
			 int hostCounter = 0;
			 int changeCounter = 0;
			 log.debug(""Change is ""+change.m_change);
			 long time = System.currentTimeMillis()-60*1000L;
			 for( Iterator i = m_lastModifications.iterator();
			 i.hasNext();
			 ) {
				 Host host = (Host)i.next();
				 if( host.getAddedTime() < time ) {
					 log.debug(""Removed host ""+host.getAddress()+"" from modification queue (expired)"");
					 i.remove();
					 continue;
				 }
				 if( host.getAddress().equals(addr) ) {
					 hostCounter++;
				 }
				 if( host.getChange() != null && host.getChange().equals(change) ) {
					 changeCounter++;
				 }
			 }
			 if( hostCounter >= m_limitSinglePageChanges ) {
				 Host host = new Host( addr, null );
				 m_temporaryBanList.add( host );
				 String uid = log( context, REJECT, REASON_TOO_MANY_MODIFICATIONS, change.m_change );
				 log.info( ""SPAM:TooManyModifications (""+uid+""). Added host ""+addr+"" to temporary ban list for doing too many modifications/minute"" );
				 checkStrategy( context, REASON_TOO_MANY_MODIFICATIONS, ""Herb says you look like a spammer, and I trust Herb! (Incident code ""+uid+"")"" );
			 }
			 if( changeCounter >= m_limitSimilarChanges ) {
				 Host host = new Host( addr, null );
				 m_temporaryBanList.add( host );
				 String uid = log( context, REJECT, REASON_SIMILAR_MODIFICATIONS, change.m_change );
				 log.info(""SPAM:SimilarModifications (""+uid+""). Added host ""+addr+"" to temporary ban list for doing too many similar modifications"" );
				 checkStrategy( context, REASON_SIMILAR_MODIFICATIONS, ""Herb says you look like a spammer, and I trust Herb! (Incident code ""+uid+"")"");
			 }
			 String tstChange = change.toString();
			 int urlCounter = 0;
			 while( m_matcher.contains(tstChange,m_urlPattern) ) {
				 MatchResult m = m_matcher.getMatch();
				 tstChange = tstChange.substring( m.endOffset(0) );
				 urlCounter++;
			 }
			 if( urlCounter > m_maxUrls ) {
				 Host host = new Host( addr, null );
				 m_temporaryBanList.add( host );
				 String uid = log( context, REJECT, REASON_TOO_MANY_URLS, change.toString() );
				 log.info(""SPAM:TooManyUrls (""+uid+""). Added host ""+addr+"" to temporary ban list for adding too many URLs"" );
				 checkStrategy( context, REASON_TOO_MANY_URLS, ""Herb says you look like a spammer, and I trust Herb! (Incident code ""+uid+"")"" );
			 }
			 checkBotTrap( context, change );
			 checkUTF8( context, change );
			 checkAkismet( context, change );
			 m_lastModifications.add( new Host( addr, change ) );
		 }
	 }
	 private void checkAkismet( WikiContext context, Change change ) throws RedirectException {
		 if( m_akismetAPIKey != null ) {
			 if( m_akismet == null ) {
				 log.info(""Initializing Akismet spam protection."");
				 m_akismet = new Akismet( m_akismetAPIKey, context.getEngine().getBaseURL() );
				 if( !m_akismet.verifyAPIKey() ) {
					 log.error(""Akismet API key cannot be verified. Please check your config."");
					 m_akismetAPIKey = null;
					 m_akismet = null;
				 }
			 }
			 HttpServletRequest req = context.getHttpRequest();
			 if( change.m_adds == 0 && change.m_removals > 0 ) {
				 return;
			 }
			 if( req != null && m_akismet != null ) {
				 log.debug(""Calling Akismet to check for spam..."");
				 StopWatch sw = new StopWatch();
				 sw.start();
				 String ipAddress = req.getRemoteAddr();
				 String userAgent = req.getHeader(""User-Agent"");
				 String referrer = req.getHeader( ""Referer"");
				 String permalink = context.getViewURL( context.getPage().getName() );
				 String commentType = context.getRequestContext().equals(WikiContext.COMMENT) ? ""comment"" : ""edit"";
				 String commentAuthor = context.getCurrentUser().getName();
				 String commentAuthorEmail = null;
				 String commentAuthorURL = null;
				 boolean isSpam = m_akismet.commentCheck( ipAddress, userAgent, referrer, permalink, commentType, commentAuthor, commentAuthorEmail, commentAuthorURL, change.toString(), null );
				 sw.stop();
				 log.debug(""Akismet request done in: ""+sw);
				 if( isSpam ) {
					 String uid = log( context, REJECT, REASON_AKISMET, change.toString() );
					 log.info(""SPAM:Akismet (""+uid+""). Akismet thinks this change is spam;
					 added host to temporary ban list."");
					 checkStrategy( context, REASON_AKISMET, ""Akismet tells Herb you're a spammer, Herb trusts Akismet, and I trust Herb! (Incident code ""+uid+"")"");
				 }
			 }
		 }
	 }
	 public static String getBotFieldName() {
		 return ""submit_auth"";
	 }
	 private void checkBotTrap( WikiContext context, Change change ) throws RedirectException {
		 HttpServletRequest request = context.getHttpRequest();
		 if( request != null ) {
			 String unspam = request.getParameter( getBotFieldName() );
			 if( unspam != null && unspam.length() > 0 ) {
				 String uid = log( context, REJECT, REASON_BOT_TRAP, change.toString() );
				 log.info(""SPAM:BotTrap (""+uid+""). Wildly behaving bot detected."");
				 checkStrategy( context, REASON_BOT_TRAP, ""Spamming attempt detected. (Incident code ""+uid+"")"");
			 }
		 }
	 }
	 private void checkUTF8( WikiContext context, Change change ) throws RedirectException {
		 HttpServletRequest request = context.getHttpRequest();
		 if( request != null ) {
			 String utf8field = request.getParameter( ""encodingcheck"" );
			 if( utf8field != null && !utf8field.equals(""\u3041"") ) {
				 String uid = log( context, REJECT, REASON_UTF8_TRAP, change.toString() );
				 log.info(""SPAM:UTF8Trap (""+uid+""). Wildly posting dumb bot detected."");
				 checkStrategy( context, REASON_UTF8_TRAP, ""Spamming attempt detected. (Incident code ""+uid+"")"");
			 }
		 }
	 }
	 private synchronized void cleanBanList() {
		 long now = System.currentTimeMillis();
		 for( Iterator i = m_temporaryBanList.iterator();
		 i.hasNext();
		 ) {
			 Host host = (Host)i.next();
			 if( host.getReleaseTime() < now ) {
				 log.debug(""Removed host ""+host.getAddress()+"" from temporary ban list (expired)"");
				 i.remove();
			 }
		 }
	 }
	 private void checkBanList( WikiContext context, Change change ) throws RedirectException {
		 HttpServletRequest req = context.getHttpRequest();
		 if( req != null ) {
			 String remote = req.getRemoteAddr();
			 long now = System.currentTimeMillis();
			 for( Iterator i = m_temporaryBanList.iterator();
			 i.hasNext();
			 ) {
				 Host host = (Host)i.next();
				 if( host.getAddress().equals(remote) ) {
					 long timeleft = (host.getReleaseTime() - now) / 1000L;
					 log( context, REJECT, REASON_IP_BANNED_TEMPORARILY, change.m_change );
					 checkStrategy( context, REASON_IP_BANNED_TEMPORARILY, ""You have been temporarily banned from modifying this wiki. (""+timeleft+"" seconds of ban left)"");
				 }
			 }
		 }
	 }
	 private void refreshBlacklists( WikiContext context ) {
		 try {
			 WikiPage source = context.getEngine().getPage( m_forbiddenWordsPage );
			 Attachment att = context.getEngine().getAttachmentManager().getAttachmentInfo( context, m_blacklist );
			 boolean rebuild = false;
			 if( source != null ) {
				 if( m_spamPatterns == null || m_spamPatterns.isEmpty() || source.getLastModified().after(m_lastRebuild) ) {
					 rebuild = true;
				 }
			 }
			 if( att != null ) {
				 if( m_spamPatterns == null || m_spamPatterns.isEmpty() || att.getLastModified().after(m_lastRebuild) ) {
					 rebuild = true;
				 }
			 }
			 if( rebuild ) {
				 m_lastRebuild = new Date();
				 m_spamPatterns = parseWordList( source, (source != null) ? (String)source.getAttribute( LISTVAR ) : null );
				 log.info(""Spam filter reloaded - recognizing ""+m_spamPatterns.size()+"" patterns from page ""+m_forbiddenWordsPage);
				 if( att != null ) {
					 InputStream in = context.getEngine().getAttachmentManager().getAttachmentStream(att);
					 StringWriter out = new StringWriter();
					 FileUtil.copyContents( new InputStreamReader(in,""UTF-8""), out );
					 Collection<Pattern> blackList = parseBlacklist( out.toString() );
					 log.info(""...recognizing additional ""+blackList.size()+"" patterns from blacklist ""+m_blacklist);
					 m_spamPatterns.addAll( blackList );
				 }
			 }
		 }
		 catch( IOException ex ) {
			 log.info(""Unable to read attachment data, continuing..."",ex);
		 }
		 catch( ProviderException ex ) {
			 log.info(""Failed to read spam filter attachment, continuing..."",ex);
		 }
	 }
	 private void checkPatternList(WikiContext context, String content, Change change) throws RedirectException {
		 if( m_spamPatterns == null || context.getPage().getName().equals( m_forbiddenWordsPage ) ) {
			 return;
		 }
		 String ch = change.toString();
		 if( context.getHttpRequest() != null ) ch += context.getHttpRequest().getRemoteAddr();
		 for( Pattern p : m_spamPatterns ) {
			 if( m_matcher.contains( ch, p ) ) {
				 String uid = log( context, REJECT, REASON_REGEXP+""(""+p.getPattern()+"")"", ch);
				 log.info(""SPAM:Regexp (""+uid+""). Content matches the spam filter '""+p.getPattern()+""'"");
				 checkStrategy( context, REASON_REGEXP, ""Herb says '""+p.getPattern()+""' is a bad spam word and I trust Herb! (Incident code ""+uid+"")"");
			 }
		 }
	 }
	 private void checkPatternList(WikiContext context, String content, String change ) throws RedirectException {
		 Change c = new Change();
		 c.m_change = change;
		 checkPatternList(context,content,c);
	 }
	 private static Change getChange( WikiContext context, String newText ) {
		 WikiPage page = context.getPage();
		 StringBuffer change = new StringBuffer();
		 WikiEngine engine = context.getEngine();
		 Change ch = new Change();
		 try {
			 String oldText = engine.getPureText(page.getName(), WikiProvider.LATEST_VERSION);
			 String[] first = Diff.stringToArray(oldText);
			 String[] second = Diff.stringToArray(newText);
			 Revision rev = Diff.diff(first, second, new MyersDiff());
			 if( rev == null || rev.size() == 0 ) {
				 return ch;
			 }
			 for( int i = 0;
			 i < rev.size();
			 i++ ) {
				 Delta d = rev.getDelta(i);
				 if( d instanceof AddDelta ) {
					 d.getRevised().toString( change, """", ""\r\n"" );
					 ch.m_adds++;
				 }
				 else if( d instanceof ChangeDelta ) {
					 d.getRevised().toString( change, """", ""\r\n"" );
					 ch.m_adds++;
				 }
				 else if( d instanceof DeleteDelta ) {
					 ch.m_removals++;
				 }
			 }
		 }
		 catch (DifferentiationFailedException e) {
			 log.error( ""Diff failed"", e );
		 }
		 String changeNote = (String)page.getAttribute(WikiPage.CHANGENOTE);
		 if( changeNote != null ) {
			 change.append(""\r\n"");
			 change.append(changeNote);
		 }
		 if( page.getAuthor() != null ) {
			 change.append(""\r\n""+page.getAuthor());
		 }
		 ch.m_change = change.toString();
		 return ch;
	 }
	 private boolean ignoreThisUser(WikiContext context) {
		 if( context.hasAdminPermissions() ) {
			 return true;
		 }
		 if( m_ignoreAuthenticated && context.getWikiSession().isAuthenticated() ) {
			 return true;
		 }
		 if( context.getVariable(""captcha"") != null ) {
			 return true;
		 }
		 return false;
	 }
	 private static String getUniqueID() {
		 StringBuffer sb = new StringBuffer();
		 Random rand = new Random();
		 for( int i = 0;
		 i < 6;
		 i++ ) {
			 char x = (char)('A'+rand.nextInt(26));
			 sb.append(x);
		 }
		 return sb.toString();
	 }
	 private String getRedirectPage( WikiContext ctx ) {
		 if( m_useCaptcha ) return ctx.getURL( WikiContext.NONE, ""Captcha.jsp"", ""page=""+ctx.getEngine().encodeName(ctx.getPage().getName()) );
		 return ctx.getURL( WikiContext.VIEW, m_errorPage );
	 }
	 public boolean isValidUserProfile( WikiContext context, UserProfile profile ) {
		 try {
			 checkPatternList( context, profile.getEmail(), profile.getEmail() );
			 checkPatternList( context, profile.getFullname(), profile.getFullname() );
			 checkPatternList( context, profile.getLoginName(), profile.getLoginName() );
		 }
		 catch( RedirectException e ) {
			 log.info(""Detected attempt to create a spammer user account (see above for rejection reason)"");
			 return false;
		 }
		 return true;
	 }
	 public static final String getSpamHash( WikiPage page, HttpServletRequest request ) {
		 long lastModified = 0;
		 if( page.getLastModified() != null ) lastModified = page.getLastModified().getTime();
		 long remote = request.getRemoteAddr().hashCode();
		 return Long.toString( lastModified ^ remote );
	 }
	 public static final String getHashFieldName( HttpServletRequest request ) {
		 String hash = null;
		 if( request.getSession() != null ) {
			 hash = (String)request.getSession().getAttribute(""_hash"");
			 if( hash == null ) {
				 hash = c_hashName;
				 request.getSession().setAttribute( ""_hash"", hash );
			 }
		 }
		 if( c_hashName == null || c_lastUpdate < (System.currentTimeMillis() - HASH_DELAY*60*60*1000) ) {
			 c_hashName = getUniqueID().toLowerCase();
			 c_lastUpdate = System.currentTimeMillis();
		 }
		 return hash != null ? hash : c_hashName;
	 }
	 public static final boolean checkHash( WikiContext context, PageContext pageContext ) throws IOException {
		 String hashName = getHashFieldName( (HttpServletRequest)pageContext.getRequest() );
		 if( pageContext.getRequest().getParameter(hashName) == null ) {
			 if( pageContext.getAttribute( hashName ) == null ) {
				 Change change = getChange( context, EditorManager.getEditedText( pageContext ) );
				 log( context, REJECT, ""MissingHash"", change.m_change );
				 String redirect = context.getURL(WikiContext.VIEW,""SessionExpired"");
				 ((HttpServletResponse)pageContext.getResponse()).sendRedirect( redirect );
				 return false;
			 }
		 }
		 return true;
	 }
	 public static final String insertInputFields( PageContext pageContext ) {
		 WikiContext ctx = WikiContext.findContext(pageContext);
		 WikiEngine engine = ctx.getEngine();
		 StringBuffer sb = new StringBuffer();
		 if (engine.getContentEncoding().equals(""UTF-8"")) {
			 sb.append(""<input name='encodingcheck' type='hidden' value='\u3041' />\n"");
		 }
		 return sb.toString();
	 }
	 private class Host {
		 private long m_addedTime = System.currentTimeMillis();
		 private long m_releaseTime;
		 private String m_address;
		 private Change m_change;
		 public String getAddress() {
			 return m_address;
		 }
		 public long getReleaseTime() {
			 return m_releaseTime;
		 }
		 public long getAddedTime() {
			 return m_addedTime;
		 }
		 public Change getChange() {
			 return m_change;
		 }
		 public Host( String ipaddress, Change change ) {
			 m_address = ipaddress;
			 m_change = change;
			 m_releaseTime = System.currentTimeMillis() + m_banTime * 60 * 1000L;
		 }
	 }
	 private static class Change {
		 public String m_change;
		 public int m_adds;
		 public int m_removals;
		 public String toString() {
			 return m_change;
		 }
		 public boolean equals(Object o) {
			 if( o instanceof Change ) return m_change.equals( ((Change)o).m_change);
			 return false;
		 }
		 public int hashCode() {
			 return m_change.hashCode()+17;
		 }
	 }
}",1,0,0,0
"public class SecuredRDFListImpl extends SecuredResourceImpl implements SecuredRDFList {
	 private SecuredRDFNode extractSecuredNode(final RDFList lst) {
		 return SecuredRDFNodeImpl.getInstance(getModel(), lst.getRequiredProperty(RDF.first).getObject());
	 }
	 private static Function<RDFList, RDFNode> valueMapper = new Function<RDFList, RDFNode>() {
		 public RDFNode apply(RDFList lst) {
			 return lst.getRequiredProperty(RDF.first).getObject();
		 }
	 }
	;
	 public static <T extends RDFList> SecuredRDFList getInstance(final SecuredModel securedModel, final T rdfList) {
		 if (securedModel == null) {
			 throw new IllegalArgumentException(""Secured securedModel may not be null"");
		 }
		 if (rdfList == null) {
			 throw new IllegalArgumentException(""RDFList may not be null"");
		 }
		 RDFList goodList = rdfList;
		 if (goodList.getModel() == null) {
			 goodList = securedModel.createList(rdfList.asJavaList().iterator());
		 }
		 final ItemHolder<RDFList, SecuredRDFList> holder = new ItemHolder<>(goodList);
		 final SecuredRDFListImpl checker = new SecuredRDFListImpl(securedModel, holder);
		 if (goodList instanceof SecuredRDFList) {
			 if (checker.isEquivalent((SecuredRDFList) goodList)) {
				 return (SecuredRDFList) goodList;
			 }
		 }
		 return holder.setSecuredItem(new SecuredItemInvoker(rdfList.getClass(), checker));
	 }
	 private final ItemHolder<RDFList, SecuredRDFList> holder;
	 protected SecuredRDFListImpl(final SecuredModel securedModel, final ItemHolder<RDFList, SecuredRDFList> holder) {
		 super(securedModel, holder);
		 this.holder = holder;
	 }
	 public void add(final RDFNode value) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreateNewList(value, RDF.nil);
		 holder.getBaseItem().add(value);
	 }
	 public RDFList append(final Iterator<? extends RDFNode> nodes) throws ReadDeniedException, AuthenticationRequiredException {
		 SecuredRDFList copy = copy();
		 if (nodes.hasNext()) {
			 if (((RDFList) copy.getBaseItem()).size() > 0) {
				 copy.concatenate(copy.getModel().createList(nodes));
			 }
			 else {
				 copy = (SecuredRDFList) copy.getModel().createList(nodes);
			 }
		 }
		 return copy;
	 }
	 public RDFList append(final RDFList list) throws ReadDeniedException, AuthenticationRequiredException {
		 return append(list.iterator());
	 }
	 public void apply(final ApplyFn fn) throws ReadDeniedException, AuthenticationRequiredException {
		 final ExtendedIterator<RDFNode> i = iterator();
		 try {
			 while (i.hasNext()) {
				 fn.apply(i.next());
			 }
		 }
		 finally {
			 i.close();
		 }
	 }
	 public void apply(final Set<Action> perms, final ApplyFn fn) throws ReadDeniedException, AuthenticationRequiredException {
		 final ExtendedIterator<RDFNode> i = iterator(perms);
		 try {
			 while (i.hasNext()) {
				 fn.apply(i.next());
			 }
		 }
		 finally {
			 i.close();
		 }
	 }
	 public List<RDFNode> asJavaList() throws ReadDeniedException, AuthenticationRequiredException {
		 return iterator().toList();
	 }
	 private RDFList baseRemove(final RDFList val) {
		 RDFList prev = null;
		 RDFList cell = holder.getBaseItem();
		 final boolean searching = true;
		 while (searching && !cell.isEmpty()) {
			 if (cell.equals(val)) {
				 final RDFList tail = cell.getTail();
				 if (prev != null) {
					 prev.setTail(tail);
				 }
				 cell.removeProperties();
				 return (prev == null) ? tail : this;
			 }
			 prev = cell;
			 cell = cell.getTail();
		 }
		 return this;
	 }
	 private void checkCreateNewList(final RDFNode value, final Resource tail) throws AddDeniedException, AuthenticationRequiredException {
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), value.asNode()));
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.rest.asNode(), tail.asNode()));
	 }
	 private Set<Statement> collectStatements(final Set<Action> actions) {
		 final Set<Statement> stmts = new HashSet<>();
		 final ExtendedIterator<RDFList> iter = WrappedIterator.create(new RDFListIterator(holder.getBaseItem())) .filterKeep(new RDFListSecFilter<>(this, actions));
		 try {
			 while (iter.hasNext()) {
				 stmts.addAll(iter.next().listProperties().toSet());
			 }
			 return stmts;
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public void concatenate(final Iterator<? extends RDFNode> nodes) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (holder.getBaseItem().isEmpty()) {
			 throw new EmptyListUpdateException(""Tried to concatenate onto the empty list"");
		 }
		 Triple t = Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), Node.ANY);
		 if (!canCreate(t)) {
			 final List<RDFNode> list = new ArrayList<>();
			 while (nodes.hasNext()) {
				 final RDFNode n = nodes.next();
				 t = Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), n.asNode());
				 checkCreate(t);
				 list.add(n);
			 }
			 holder.getBaseItem().concatenate(list.iterator());
		 }
		 else {
			 holder.getBaseItem().concatenate(nodes);
		 }
	 }
	 public void concatenate(final RDFList list) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (holder.getBaseItem().isEmpty()) {
			 throw new EmptyListUpdateException(""Tried to concatenate onto the empty list"");
		 }
		 Triple t = Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), Node.ANY);
		 if (!canCreate(t)) {
			 final ExtendedIterator<RDFNode> iter = list.iterator();
			 try {
				 while (iter.hasNext()) {
					 t = Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), iter.next().asNode());
					 checkCreate(t);
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 holder.getBaseItem().concatenate(list);
	 }
	 public SecuredRDFList cons(final RDFNode value) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreateNewList(value, holder.getBaseItem());
		 return SecuredRDFListImpl.getInstance(getModel(), holder.getBaseItem().cons(value));
	 }
	 public boolean contains(final RDFNode value) throws ReadDeniedException, AuthenticationRequiredException {
		 final ExtendedIterator<RDFNode> iter = iterator();
		 try {
			 while (iter.hasNext()) {
				 if (value.equals(iter.next())) {
					 return true;
				 }
			 }
			 return false;
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public SecuredRDFList copy() throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 SecuredRDFList retval = null;
		 if (checkSoftRead()) {
			 final ExtendedIterator<RDFNode> iter = getFilteredRDFListIterator(Action.Read).mapWith(valueMapper);
			 if (iter.hasNext()) {
				 retval = (SecuredRDFList) getModel().createList(iter);
			 }
			 else {
				 retval = (SecuredRDFList) getModel().createList();
			 }
		 }
		 else {
			 retval = (SecuredRDFList) getModel().createList();
		 }
		 return retval;
	 }
	 public RDFNode get(final int i) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 final ExtendedIterator<RDFList> iter = getFilteredRDFListIterator(Action.Read);
			 int idx = 0;
			 try {
				 while (iter.hasNext()) {
					 if (i == idx) {
						 return extractSecuredNode(iter.next());
					 }
					 idx++;
					 iter.next();
				 }
				 throw new ListIndexException();
			 }
			 finally {
				 iter.close();
			 }
		 }
		 throw new ListIndexException();
	 }
	 public RDFNode getHead() throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 Statement s = holder.getBaseItem().getRequiredProperty(RDF.first);
			 checkRead(s);
			 return SecuredRDFNodeImpl.getInstance(getModel(), s.getObject());
		 }
		 throw new ListIndexException();
	 }
	 private ExtendedIterator<RDFList> getFilteredRDFListIterator(final Action perm) {
		 return WrappedIterator.create(new RDFListIterator(holder.getBaseItem())) .filterKeep(new RDFListSecFilter<>(this, perm));
	 }
	 private ExtendedIterator<RDFList> getFilteredRDFListIterator(final Set<Action> perm) {
		 return WrappedIterator.create(new RDFListIterator(holder.getBaseItem())) .filterKeep(new RDFListSecFilter<>(this, perm));
	 }
	 public boolean getStrict() {
		 return holder.getBaseItem().getStrict();
	 }
	 public SecuredRDFList getTail() throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 Statement s = holder.getBaseItem().getRequiredProperty(RDF.rest);
			 checkRead(s);
			 return SecuredRDFListImpl.getInstance(getModel(), s.getObject().as(RDFList.class));
		 }
		 throw new ListIndexException();
	 }
	 public String getValidityErrorMessage() throws ReadDeniedException, AuthenticationRequiredException {
		 return checkSoftRead() ? holder.getBaseItem().getValidityErrorMessage() : null;
	 }
	 public int indexOf(final RDFNode value) throws ReadDeniedException, AuthenticationRequiredException {
		 return indexOf(value, 0);
	 }
	 public int indexOf(final RDFNode value, final int start) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 final ExtendedIterator<RDFList> iter = getFilteredRDFListIterator(Action.Read);
			 try {
				 int retval = 0;
				 while (iter.hasNext() && (retval < start)) {
					 iter.next();
					 retval++;
				 }
				 while (iter.hasNext()) {
					 if (value.equals(valueMapper.apply(iter.next()))) {
						 return retval;
					 }
					 retval++;
				 }
				 return -1;
			 }
			 finally {
				 iter.close();
			 }
		 }
		 return -1;
	 }
	 public boolean isEmpty() throws ReadDeniedException, AuthenticationRequiredException {
		 final ExtendedIterator<RDFNode> iter = iterator();
		 try {
			 return !iter.hasNext();
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public boolean isValid() throws ReadDeniedException, AuthenticationRequiredException {
		 checkRead();
		 return holder.getBaseItem().isValid();
	 }
	 public ExtendedIterator<RDFNode> iterator() throws ReadDeniedException, AuthenticationRequiredException {
		 return iterator(Set.of());
	 }
	 public ExtendedIterator<RDFNode> iterator(final Set<Action> constraints) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 final Set<Action> req = new HashSet<>(constraints);
			 req.add(Action.Read);
			 return getFilteredRDFListIterator(req).mapWith(valueMapper) .mapWith(r -> SecuredRDFNodeImpl.getInstance(getModel(), r));
		 }
		 return NiceIterator.emptyIterator();
	 }
	 public <T> ExtendedIterator<T> mapWith(final Function<RDFNode, T> fn) throws ReadDeniedException, AuthenticationRequiredException {
		 return iterator().mapWith(fn);
	 }
	 public Object reduce(final ReduceFn fn, final Object initial) throws ReadDeniedException, AuthenticationRequiredException {
		 Object acc = initial;
		 for (final Iterator<RDFNode> i = iterator();
		 i.hasNext();
		) {
			 acc = fn.reduce(i.next(), acc);
		 }
		 return acc;
	 }
	 public Object reduce(final Set<Action> requiredActions, final ReduceFn fn, final Object initial) throws EmptyListException, ListIndexException, InvalidListException, ReadDeniedException, AuthenticationRequiredException {
		 Object acc = initial;
		 final Set<Action> perms = new HashSet<>(requiredActions);
		 perms.add(Action.Read);
		 for (final Iterator<RDFNode> i = iterator(perms);
		 i.hasNext();
		) {
			 acc = fn.reduce(i.next(), acc);
		 }
		 return acc;
	 }
	 public RDFList remove(final RDFNode val) throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.create(Node.ANY, RDF.first.asNode(), val.asNode()))) {
			 RDFList cell = null;
			 final ExtendedIterator<RDFList> iter = getFilteredRDFListIterator(Action.Delete);
			 while (iter.hasNext()) {
				 cell = iter.next();
				 if (val.equals(valueMapper.apply(cell))) {
					 return SecuredRDFListImpl.getInstance(getModel(), baseRemove(cell));
				 }
			 }
			 throw new DeleteDeniedException(SecuredItem.Util.triplePermissionMsg(getModelNode()));
		 }
		 return SecuredRDFListImpl.getInstance(getModel(), holder.getBaseItem().remove(val));
	 }
	 public SecuredRDFList removeHead() throws UpdateDeniedException, DeleteDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 final ExtendedIterator<RDFList> iter = getFilteredRDFListIterator(Action.Read);
		 try {
			 if (!iter.hasNext()) {
				 throw new EmptyListException(""Attempted to delete the head of a nil list"");
			 }
			 final RDFList cell = iter.next();
			 final Statement s = cell.getRequiredProperty(RDF.first);
			 checkDelete(s);
			 return SecuredRDFListImpl.getInstance(getModel(), baseRemove(cell));
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public void removeList() throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 final Triple t = Triple.create(Node.ANY, RDF.first.asNode(), Node.ANY);
		 final Set<Action> perms = SecurityEvaluator.Util.asSet(new Action[] {
		 Action.Delete, Action.Read }
		);
		 if (getSecurityEvaluator().evaluate(getSecurityEvaluator().getPrincipal(), perms, this.getModelNode(), t)) {
			 holder.getBaseItem().removeList();
		 }
		 else {
			 for (final Statement s : collectStatements(perms)) {
				 if (canDelete(s)) {
					 s.remove();
				 }
			 }
		 }
	 }
	 public SecuredRDFNode replace(final int i, final RDFNode value) throws UpdateDeniedException, AuthenticationRequiredException, ListIndexException {
		 checkUpdate();
		 final ExtendedIterator<RDFList> iter = getFilteredRDFListIterator(Action.Read);
		 int idx = 0;
		 try {
			 while (iter.hasNext()) {
				 if (i == idx) {
					 final RDFList list = iter.next();
					 final RDFNode retval = list.getRequiredProperty(RDF.first).getObject();
					 final Triple t = Triple.create(list.asNode(), RDF.first.asNode(), retval.asNode());
					 final Triple t2 = Triple.create(list.asNode(), RDF.first.asNode(), value.asNode());
					 checkUpdate(t, t2);
					 list.getRequiredProperty(RDF.first).changeObject(value);
					 return SecuredRDFNodeImpl.getInstance(getModel(), retval);
				 }
				 idx++;
				 iter.next();
			 }
			 throw new ListIndexException();
		 }
		 finally {
			 iter.close();
		 }
	 }
	 public boolean sameListAs(final RDFList list) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 ExtendedIterator<RDFNode> thisIter = null;
			 ExtendedIterator<RDFNode> thatIter = null;
			 try {
				 thisIter = iterator();
				 thatIter = list.iterator();
				 while (thisIter.hasNext() && thatIter.hasNext()) {
					 final RDFNode thisN = thisIter.next();
					 final RDFNode thatN = thatIter.next();
					 if ((thisN == null) || !thisN.equals(thatN)) {
						 return false;
					 }
				 }
				 return !(thisIter.hasNext() || thatIter.hasNext());
			 }
			 finally {
				 if (thisIter != null) {
					 thisIter.close();
				 }
				 if (thatIter != null) {
					 thatIter.close();
				 }
			 }
		 }
		 return list.isEmpty();
	 }
	 public SecuredRDFNode setHead(final RDFNode value) throws EmptyListException, AuthenticationRequiredException {
		 try {
			 return replace(0, value);
		 }
		 catch (ListIndexException e) {
			 throw new EmptyListException(""Tried to set the head of an empty list"");
		 }
	 }
	 public void setStrict(final boolean strict) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 holder.getBaseItem().setStrict(strict);
	 }
	 public SecuredRDFList setTail(final RDFList tail) throws UpdateDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 final Statement rest = holder.getBaseItem().getRequiredProperty(RDF.rest);
		 final RDFNode retval = rest.getObject();
		 final Triple t = Triple.create(holder.getBaseItem().asNode(), RDF.rest.asNode(), retval.asNode());
		 final Triple t2 = Triple.create(holder.getBaseItem().asNode(), RDF.rest.asNode(), tail.asNode());
		 checkUpdate(t, t2);
		 rest.changeObject(tail);
		 return SecuredRDFListImpl.getInstance(getModel(), retval.as(RDFList.class));
	 }
	 public int size() throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead()) {
			 final Triple t = Triple.create(Node.ANY, RDF.first.asNode(), Node.ANY);
			 if (canRead(t)) {
				 return holder.getBaseItem().size();
			 }
			 final ExtendedIterator<RDFNode> iter = iterator();
			 int i = 0;
			 while (iter.hasNext()) {
				 i++;
				 iter.next();
			 }
			 return i;
		 }
		 return 0;
	 }
	 public SecuredRDFList with(final RDFNode value) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(SecurityEvaluator.FUTURE, RDF.first.asNode(), value.asNode()));
		 return SecuredRDFListImpl.getInstance(getModel(), holder.getBaseItem().with(value));
	 }
}",1,0,0,0
"protected String getThreadNamePrefix() {
	 return super.getThreadNamePrefix() + ""-startup"";
 }",0,0,0,0
"private static class FontDelegate {
	 private static int[] defaultMapping = {
	 CONTROL_TEXT_FONT, SYSTEM_TEXT_FONT, USER_TEXT_FONT, CONTROL_TEXT_FONT, CONTROL_TEXT_FONT, SUB_TEXT_FONT }
	;
	 FontUIResource[] fonts;
	 public FontDelegate() {
		 fonts = new FontUIResource[6];
	 }
	 public FontUIResource getFont(int type) {
		 int mappedType = defaultMapping[type];
		 if (fonts[type] == null) {
			 Font f = getPrivilegedFont(mappedType);
			 if (f == null) {
				 f = new Font(getDefaultFontName(type), getDefaultFontStyle(type), getDefaultFontSize(type));
			 }
			 fonts[type] = new FontUIResource(f);
		 }
		 return fonts[type];
	 }
	 protected Font getPrivilegedFont(final int key) {
		 return java.security.AccessController.doPrivileged( new java.security.PrivilegedAction<Font>() {
			 public Font run() {
				 return Font.getFont(getDefaultPropertyName(key));
			 }
		 }
		 );
	 }
 }",1,1,0,0
"public void copyFromLocalFile(Path src, Path dst) throws IOException {
	 FileUtil.copy(localFs, src, this, dst, false, getConf());
 }",0,0,0,0
"public class ClassMetaCache<T>{
	private volatile Map<ClassLoader, ConcurrentHashMap<String, T>> cache = Collections.emptyMap();
	public T put(Class<?> key, T value){
		ConcurrentHashMap<String, T> container = getClassLoaderCache(key.getClassLoader(), true);
		return container.put(key(key), value);
	}
	public T get(Class<?> key){
		ConcurrentHashMap<String, T> container = getClassLoaderCache(key.getClassLoader(), false);
		if (container == null){
			return null;
		}
		else{
			return container.get(key(key));
		}
	}
	private ConcurrentHashMap<String, T> getClassLoaderCache(ClassLoader classLoader, boolean create){
		ConcurrentHashMap<String, T> container = cache.get(classLoader);
		if (container == null){
			if (!create){
				return container;
			}
			synchronized (this){
				container = cache.get(classLoader);
				if (container == null){
					container = new ConcurrentHashMap<String, T>();
					Map<ClassLoader, ConcurrentHashMap<String, T>> newCache = new WeakHashMap<ClassLoader, ConcurrentHashMap<String, T>>(cache);
					newCache.put(classLoader, container);
					cache = Collections.unmodifiableMap(newCache);
				}
			}
		}
		return container;
	}
	private static String key(Class<?> clazz){
		return clazz.getName();
	}
}",0,0,0,0
"public static class getChildDataProducts<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, getChildDataProducts_args, List<org.apache.airavata.model.data.replica.DataProductModel>> {
	 public getChildDataProducts() {
		 super(""getChildDataProducts"");
	 }
	 public getChildDataProducts_args getEmptyArgsInstance() {
		 return new getChildDataProducts_args();
	 }
	 public AsyncMethodCallback<List<org.apache.airavata.model.data.replica.DataProductModel>> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
		 final org.apache.thrift.AsyncProcessFunction fcall = this;
		 return new AsyncMethodCallback<List<org.apache.airavata.model.data.replica.DataProductModel>>() {
			 public void onComplete(List<org.apache.airavata.model.data.replica.DataProductModel> o) {
				 getChildDataProducts_result result = new getChildDataProducts_result();
				 result.success = o;
				 try {
					 fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
					 return;
				 }
				 catch (Exception e) {
					 LOGGER.error(""Exception writing to internal frame buffer"", e);
				 }
				 fb.close();
			 }
			 public void onError(Exception e) {
				 byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
				 org.apache.thrift.TBase msg;
				 getChildDataProducts_result result = new getChildDataProducts_result();
				 if (e instanceof org.apache.airavata.model.error.InvalidRequestException) {
					 result.ire = (org.apache.airavata.model.error.InvalidRequestException) e;
					 result.setIreIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.airavata.model.error.AiravataClientException) {
					 result.ace = (org.apache.airavata.model.error.AiravataClientException) e;
					 result.setAceIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.airavata.model.error.AiravataSystemException) {
					 result.ase = (org.apache.airavata.model.error.AiravataSystemException) e;
					 result.setAseIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.airavata.model.error.AuthorizationException) {
					 result.ae = (org.apache.airavata.model.error.AuthorizationException) e;
					 result.setAeIsSet(true);
					 msg = result;
				 }
				 else {
					 msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
					 msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
				 }
				 try {
					 fcall.sendResponse(fb,msg,msgType,seqid);
					 return;
				 }
				 catch (Exception ex) {
					 LOGGER.error(""Exception writing to internal frame buffer"", ex);
				 }
				 fb.close();
			 }
		 }
		;
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public void start(I iface, getChildDataProducts_args args, org.apache.thrift.async.AsyncMethodCallback<List<org.apache.airavata.model.data.replica.DataProductModel>> resultHandler) throws TException {
		 iface.getChildDataProducts(args.authzToken, args.productUri,resultHandler);
	 }
 }",1,0,0,0
"public class BoltExecutorStats extends CommonStats {
	 MultiCountStatAndMetric executedStats;
	 MultiLatencyStatAndMetric processLatencyStats;
	 MultiLatencyStatAndMetric executeLatencyStats;
	 public BoltExecutorStats(int rate, int numStatBuckets) {
		 super(rate, numStatBuckets);
		 this.executedStats = new MultiCountStatAndMetric(numStatBuckets);
		 this.processLatencyStats = new MultiLatencyStatAndMetric(numStatBuckets);
		 this.executeLatencyStats = new MultiLatencyStatAndMetric(numStatBuckets);
	 }
	 public MultiCountStatAndMetric getExecuted() {
		 return executedStats;
	 }
	 public MultiLatencyStatAndMetric getProcessLatencies() {
		 return processLatencyStats;
	 }
	 public MultiLatencyStatAndMetric getExecuteLatencies() {
		 return executeLatencyStats;
	 }
	 public void cleanupStats() {
		 executedStats.close();
		 processLatencyStats.close();
		 executeLatencyStats.close();
		 super.cleanupStats();
	 }
	 public void boltExecuteTuple(String component, String stream, long latencyMs) {
		 List key = Lists.newArrayList(component, stream);
		 this.getExecuted().incBy(key, this.rate);
		 this.getExecuteLatencies().record(key, latencyMs);
	 }
	 public void boltAckedTuple(String component, String stream, long latencyMs, Counter ackedCounter) {
		 List key = Lists.newArrayList(component, stream);
		 this.getAcked().incBy(key, this.rate);
		 ackedCounter.inc(this.rate);
		 this.getProcessLatencies().record(key, latencyMs);
	 }
	 public void boltFailedTuple(String component, String stream, long latencyMs, Counter failedCounter) {
		 List key = Lists.newArrayList(component, stream);
		 this.getFailed().incBy(key, this.rate);
		 failedCounter.inc(this.rate);
	 }
	 public ExecutorStats renderStats() {
		 ExecutorStats ret = new ExecutorStats();
		 ret.set_emitted(valueStat(getEmitted()));
		 ret.set_transferred(valueStat(getTransferred()));
		 ret.set_rate(this.rate);
		 BoltStats boltStats = new BoltStats( ClientStatsUtil.windowSetConverter(valueStat(getAcked()), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY), ClientStatsUtil.windowSetConverter(valueStat(getFailed()), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY), ClientStatsUtil.windowSetConverter(valueStat(processLatencyStats), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY), ClientStatsUtil.windowSetConverter(valueStat(executedStats), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY), ClientStatsUtil.windowSetConverter(valueStat(executeLatencyStats), ClientStatsUtil.TO_GSID, ClientStatsUtil.IDENTITY));
		 ret.set_specific(ExecutorSpecificStats.bolt(boltStats));
		 return ret;
	 }
}",1,1,0,0
"public synchronized void setBaseURL(URL base) {
	 checkAttributesAllowed();
	 if (url != null) {
		 throw new BuildException(""can't define URL and baseURL attribute"");
	 }
	 baseURL = base;
 }",0,0,0,0
"public List<Row> scan(IndexClause clause, AbstractBounds range, IFilter dataFilter) {
	 IndexExpression primary = highestSelectivityPredicate(clause);
	 ColumnFamilyStore indexCFS = getIndexedColumnFamilyStore(primary.column_name);
	 if (logger.isDebugEnabled()) logger.debug(""Primary scan clause is "" + getComparator().getString(primary.column_name));
	 assert indexCFS != null;
	 DecoratedKey indexKey = indexCFS.partitioner.decorateKey(primary.value);
	 IFilter firstFilter = dataFilter;
	 if (dataFilter instanceof SliceQueryFilter) {
		 if (getMaxRowSize() < DatabaseDescriptor.getColumnIndexSize()) {
			 logger.debug(""Expanding slice filter to entire row to cover additional expressions"");
			 firstFilter = new SliceQueryFilter(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, ((SliceQueryFilter) dataFilter).reversed, Integer.MAX_VALUE);
		 }
	 }
	 else {
		 logger.debug(""adding columns to firstFilter to cover additional expressions"");
		 assert dataFilter instanceof NamesQueryFilter;
		 SortedSet<ByteBuffer> columns = new TreeSet<ByteBuffer>(getComparator());
		 for (IndexExpression expr : clause.expressions) {
			 columns.add(expr.column_name);
		 }
		 if (columns.size() > 0) {
			 columns.addAll(((NamesQueryFilter) dataFilter).columns);
			 firstFilter = new NamesQueryFilter(columns);
		 }
	 }
	 List<Row> rows = new ArrayList<Row>();
	 ByteBuffer startKey = clause.start_key;
	 QueryPath path = new QueryPath(columnFamily);
	 ByteBuffer lastDataKey = null;
	 outer: while (true) {
		 if (logger.isDebugEnabled()) logger.debug(String.format(""Scanning index %s starting with %s"", expressionString(primary), indexCFS.getComparator().getString(startKey)));
		 int count = Math.max(clause.count, 2);
		 QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey, new QueryPath(indexCFS.getColumnFamilyName()), startKey, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, count);
		 ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
		 logger.debug(""fetched {
		}
		"", indexRow);
		 if (indexRow == null) break;
		 ByteBuffer dataKey = null;
		 int n = 0;
		 for (IColumn column : indexRow.getSortedColumns()) {
			 if (column.isMarkedForDelete()) continue;
			 dataKey = column.name();
			 n++;
			 DecoratedKey dk = partitioner.decorateKey(dataKey);
			 if (!range.right.equals(partitioner.getMinimumToken()) && range.right.compareTo(dk.token) < 0) break outer;
			 if (!range.contains(dk.token) || dataKey.equals(lastDataKey)) continue;
			 ColumnFamily data = getColumnFamily(new QueryFilter(dk, path, firstFilter));
			 if (data == null) data = ColumnFamily.create(metadata);
			 logger.debug(""fetched data row {
			}
			"", data);
			 if (dataFilter instanceof SliceQueryFilter && !isIdentityFilter((SliceQueryFilter)dataFilter)) {
				 boolean needExtraFilter = false;
				 for (IndexExpression expr : clause.expressions) {
					 if (data.getColumn(expr.column_name) == null) {
						 logger.debug(""adding extraFilter to cover additional expressions"");
						 needExtraFilter = true;
						 break;
					 }
				 }
				 if (needExtraFilter) {
					 NamesQueryFilter extraFilter = getExtraFilter(clause);
					 for (IndexExpression expr : clause.expressions) {
						 if (data.getColumn(expr.column_name) != null) extraFilter.columns.remove(expr.column_name);
					 }
					 assert !extraFilter.columns.isEmpty();
					 ColumnFamily cf = getColumnFamily(new QueryFilter(dk, path, extraFilter));
					 if (cf != null) data.addAll(cf);
				 }
			 }
			 if (satisfies(data, clause, primary)) {
				 logger.debug(""row {
				}
				 satisfies all clauses"", data);
				 if (firstFilter != dataFilter) {
					 ColumnFamily expandedData = data;
					 data = expandedData.cloneMeShallow();
					 IColumnIterator iter = dataFilter.getMemtableColumnIterator(expandedData, dk, getComparator());
					 new QueryFilter(dk, path, dataFilter).collectCollatedColumns(data, iter, gcBefore());
				 }
				 rows.add(new Row(dk, data));
			 }
			 if (rows.size() == clause.count) break outer;
		 }
		 if (n < clause.count || startKey.equals(dataKey)) break;
		 lastDataKey = startKey = dataKey;
	 }
	 return rows;
 }",0,0,1,0
"private Component createSearchPane() {
	btnSort = new CustomButton(""Newest on top"");
	btnSort.setBackground(ColorResource.getActiveTabColor());
	btnSort.setBorderPainted(false);
	btnSort.setFocusPainted(false);
	btnSort.setContentAreaFilled(false);
	btnSort.setFont(FontResource.getNormalFont());
	txtSearch = new JTextField();
	txtSearch.setBackground(Color.WHITE);
	txtSearch.setForeground(Color.BLACK);
	txtSearch.setBorder(null);
	txtSearch.setName(""BTN_SEARCH"");
	txtSearch.addActionListener(this);
	final CustomButton btnSearch = new CustomButton();
	btnSearch.setName(""BTN_SEARCH"");
	btnSearch.setRolloverBackground(Color.WHITE);
	btnSearch.setPressedBackground(Color.WHITE);
	btnSearch.addActionListener(this);
	btnSearch.setPreferredSize(new Dimension(20, 20));
	btnSearch.setBackground(Color.WHITE);
	btnSearch.setIcon(ImageResource.get(""search16.png""));
	btnSearch.setBorderPainted(false);
	btnSearch.setFocusPainted(false);
	txtSearch.addActionListener(this);
	Box b = Box.createHorizontalBox();
	b.setOpaque(true);
	b.setBackground(Color.WHITE);
	b.setPreferredSize(new Dimension(130, 20));
	b.setMaximumSize(new Dimension(130, 20));
	txtSearch.setPreferredSize(new Dimension(70, 20));
	txtSearch.setMaximumSize(new Dimension(txtSearch.getMaximumSize().width, 20));
	b.add(txtSearch);
	b.add(btnSearch);
	b.setBorder(new LineBorder(Color.LIGHT_GRAY, 1));
	Box bp = Box.createHorizontalBox();
	bp.setOpaque(false);
	bp.setBorder(new EmptyBorder(3, 3, 3, 10));
	bp.add(Box.createHorizontalGlue());
	bp.add(btnSort);
	bp.add(Box.createHorizontalStrut(10));
	bp.add(b);
	bp.add(Box.createHorizontalStrut(10));
	sortItems = new JMenuItem[6];
	sortItems[0] = new JMenuItem(StringResource.get(""SORT_DATE""));
	sortItems[0].setName(""0"");
	sortItems[1] = new JMenuItem(StringResource.get(""SORT_SIZE""));
	sortItems[1].setName(""1"");
	sortItems[2] = new JMenuItem(StringResource.get(""SORT_NAME""));
	sortItems[2].setName(""2"");
	sortItems[3] = new JMenuItem(StringResource.get(""SORT_TYPE""));
	sortItems[3].setName(""3"");
	sortItems[4] = new JMenuItem(StringResource.get(""SORT_ASC""));
	sortItems[4].setName(""4"");
	sortItems[5] = new JMenuItem(StringResource.get(""SORT_DESC""));
	sortItems[5].setName(""5"");
	final JPopupMenu popSort = new JPopupMenu();
	for (int i = 0;
	 i < sortItems.length;
	 i++) {
		popSort.add(sortItems[i]);
		if (i > 3) {
			sortItems[i].putClientProperty(""bgColor"", ColorResource.getDarkBgColor());
		}
		sortItems[i].addActionListener(this);
	}
	updateSortMenu();
	popSort.setInvoker(btnSort);
	btnSort.addActionListener(new ActionListener() {
		public void actionPerformed(ActionEvent e) {
			popSort.show(btnSort, 0, btnSort.getHeight());
		}
	}
	);
	return bp;
}",0,0,1,0
"public void computeRound(int processId, File distDir) throws IOException {
	 File assignFile = new File(distDir, ASSIGN_FILE_PREFIX + ""."" + processId);
	 long startIndex = 0, extent = 0;
	 DataInputStream in = new DataInputStream(new BufferedInputStream(nfs.open(assignFile)));
	 try {
		 startIndex = in.readLong();
		 extent = in.readLong();
	 }
	 finally {
		 in.close();
	 }
	 LOG.info(""Start at: ""+ startIndex);
	 LOG.info(""Extent: ""+ extent);
	 File scoreEdits = new File(distDir, SCORE_EDITS_FILE_PREFIX + ""."" + processId);
	 SequenceFile.Writer scoreWriter = new SequenceFile.Writer(nfs, scoreEdits.getPath() + "".unsorted"", UTF8.class, ScoreValue.class);
	 try {
		 long curIndex = 0;
		 long linkCount = 0;
		 ScoreValue score = new ScoreValue();
		 IWebDBReader reader = new WebDBReader(nfs, dbDir);
		 MD5Hash lastHash = null;
		 try {
			 for (Enumeration e = reader.pagesByMD5();
			 e.hasMoreElements();
			 curIndex++) {
				 if (curIndex < startIndex) {
					 e.nextElement();
					 continue;
				 }
				 if (curIndex - startIndex > extent) {
					 break;
				 }
				 Page curPage = (Page) e.nextElement();
				 MD5Hash newHash = curPage.getMD5();
				 if (newHash.equals(lastHash)) {
					 continue;
				 }
				 lastHash = newHash;
				 Link outLinks[] = reader.getLinks(curPage.getMD5());
				 linkCount += outLinks.length;
				 if (outLinks.length > OUTLINK_LIMIT) {
					 LOG.info(""Suspicious outlink count = "" + outLinks.length + "" for ["" + curPage.getURL().toString() + ""]."");
				 }
				 int targetOutlinkers = 0;
				 for (int i = 0;
				 i < outLinks.length;
				 i++) {
					 if (outLinks[i].targetHasOutlink()) {
						 targetOutlinkers++;
					 }
				 }
				 float curNextScore = curPage.getNextScore();
				 if (outLinks.length > 0 && curNextScore == 0.0f) {
					 curNextScore = curPage.getScore();
				 }
				 float contributionForAll = (outLinks.length > 0) ? (curNextScore / outLinks.length) : 0.0f;
				 float contributionForOutlinkers = (targetOutlinkers > 0) ? (curNextScore / targetOutlinkers) : 0.0f;
				 for (int i = 0;
				 i < outLinks.length;
				 i++) {
					 score.setScore(contributionForAll);
					 score.setNextScore(outLinks[i].targetHasOutlink() ? contributionForOutlinkers : 0.0f);
					 scoreWriter.append(outLinks[i].getURL(), score);
				 }
				 if (((curIndex - startIndex) % 5000) == 0) {
					 LOG.info(""Pages consumed: "" + (curIndex - startIndex) + "" (at index "" + curIndex + ""). Links fetched: "" + linkCount + ""."");
				 }
			 }
		 }
		 finally {
			 reader.close();
		 }
	 }
	 finally {
		 scoreWriter.close();
	 }
	 SequenceFile.Sorter sorter = new SequenceFile.Sorter(nfs, new UTF8.Comparator(), ScoreValue.class);
	 sorter.sort(scoreEdits.getPath() + "".unsorted"", scoreEdits.getPath() + "".sorted"");
	 nfs.delete(new File(scoreEdits.getPath() + "".unsorted""));
 }",0,0,1,0
"public int addMethodref(String name, String className, String retType, String paras);",0,0,0,1
"public abstract class VMBridge{
	 static final VMBridge instance = makeInstance();
	 private static VMBridge makeInstance() {
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 String className;
			 if (i == 0) {
				 className = ""org.mozilla.javascript.VMBridge_custom"";
			 }
			 else if (i == 1) {
				 className = ""org.mozilla.javascript.jdk13.VMBridge_jdk13"";
			 }
			 else {
				 className = ""org.mozilla.javascript.jdk11.VMBridge_jdk11"";
			 }
			 Class cl = Kit.classOrNull(className);
			 if (cl != null) {
				 VMBridge bridge = (VMBridge)Kit.newInstanceOrNull(cl);
				 if (bridge != null) {
					 return bridge;
				 }
			 }
		 }
		 throw new IllegalStateException(""Failed to create VMBridge instance"");
	 }
	 protected abstract Object getThreadContextHelper();
	 protected abstract Context getContext(Object contextHelper);
	 protected abstract void setContext(Object contextHelper, Context cx);
	 protected abstract ClassLoader getCurrentThreadClassLoader();
	 protected abstract boolean tryToMakeAccessible(Object accessibleObject);
	 protected Object getInterfaceProxyHelper(ContextFactory cf, Class[] interfaces) {
		 throw Context.reportRuntimeError( ""VMBridge.getInterfaceProxyHelper is not supported"");
	 }
	 protected Object newInterfaceProxy(Object proxyHelper, ContextFactory cf, InterfaceAdapter adapter, Object target, Scriptable topScope) {
		 throw Context.reportRuntimeError( ""VMBridge.newInterfaceProxy is not supported"");
	 }
}",0,0,0,0
"abstract class NativePointerLibraries extends CommonPointerLibraries {
	 static boolean isNull(LLVMPointerImpl receiver) {
		 return receiver.isNull();
	 }
	 static class IsExecutable {
		 static boolean doNative(LLVMPointerImpl receiver, LLVMContext context) {
			 return context.getFunctionDescriptor(receiver) != null;
		 }
	 }
	 static class Execute {
	 == cachedAddress"", ""cachedDescriptor != null""}
	) static Object doNativeCached( LLVMPointerImpl value, Object[] args, "") long cachedAddress, "") ContextReference<LLVMContext> ctxRef, "") LLVMFunctionDescriptor cachedDescriptor, InteropLibrary interop) throws UnsupportedTypeException, ArityException, UnsupportedMessageException {
		 return interop.execute(cachedDescriptor, args);
	 }
	 static Object doNative(LLVMPointerImpl value, Object[] args, LLVMContext context, InteropLibrary interop) throws UnsupportedTypeException, ArityException, UnsupportedMessageException {
		 LLVMFunctionDescriptor descriptor = context.getFunctionDescriptor(value);
		 if (descriptor != null) {
			 return interop.execute(descriptor, args);
		 }
		 else {
			 throw UnsupportedMessageException.create();
		 }
	 }
	 static LLVMFunctionDescriptor getDescriptor(ContextReference<LLVMContext> ctxRef, LLVMNativePointer value) {
		 return ctxRef.get().getFunctionDescriptor(value);
	 }
 }
 static boolean isPointer(LLVMPointerImpl receiver) {
	 return true;
 }
 static long asPointer(LLVMPointerImpl receiver) {
	 return receiver.asNative();
 }
 static LLVMNativePointer toNativePointer(LLVMPointerImpl receiver) {
	 return receiver;
 }
}",0,0,0,0
public DOMImplementation getImplementation();,0,0,0,0
"protected static boolean typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod) {
	 if (isUsingUncheckedGenerics(receiver)) {
		 return true;
	 }
	 if (CLASS_Type.equals(receiver) && receiver.isUsingGenerics() && !candidateMethod.getDeclaringClass().equals(receiver) && !(candidateMethod instanceof ExtensionMethodNode)) {
		 return typeCheckMethodsWithGenerics(receiver.getGenericsTypes()[0].getType(), arguments, candidateMethod);
	 }
	 GenericsType[] genericsTypes = candidateMethod.getGenericsTypes();
	 boolean methodUsesGenerics = (genericsTypes != null && genericsTypes.length > 0);
	 boolean isExtensionMethod = candidateMethod instanceof ExtensionMethodNode;
	 if (isExtensionMethod && methodUsesGenerics) {
		 ClassNode[] dgmArgs = new ClassNode[arguments.length + 1];
		 dgmArgs[0] = receiver;
		 System.arraycopy(arguments, 0, dgmArgs, 1, arguments.length);
		 MethodNode extensionMethodNode = ((ExtensionMethodNode) candidateMethod).getExtensionMethodNode();
		 return typeCheckMethodsWithGenerics(extensionMethodNode.getDeclaringClass(), dgmArgs, extensionMethodNode, true);
	 }
	 else {
		 return typeCheckMethodsWithGenerics(receiver, arguments, candidateMethod, false);
	 }
 }",0,0,1,0
"public void close() throws IOException {
	 boolean success = false;
	 try {
		 if (meta != null) {
			 meta.writeInt(-1);
			 CodecUtil.writeFooter(meta);
		 }
		 if (data != null) {
			 CodecUtil.writeFooter(data);
		 }
		 success = true;
	 }
	 finally {
		 if (success) {
			 IOUtils.close(data, meta);
		 }
		 else {
			 IOUtils.closeWhileHandlingException(data, meta);
		 }
		 meta = data = null;
	 }
 }",0,0,1,0
"public class UpdateEntityResponse<V extends RecordTemplate> extends UpdateResponse{
	 private final V _entity;
	 public UpdateEntityResponse(final HttpStatus status, final V entity) {
		 super(status);
		 _entity = entity;
	 }
	 public boolean hasEntity() {
		 return _entity != null;
	 }
	 public V getEntity() {
		 return _entity;
	 }
}",0,1,0,0
"public int getNumLocked() {
	 return numLocked;
 }",0,0,0,0
"public interface UnknownTypeRef extends TypeRef {
	String getTypeRefAsString();
}",0,0,0,0
"public final class CSelectionCriteriumPanel extends JPanel {
	 private final CSelectionCriterium m_criterium;
	 private final JComboBox<SelectionState> selectionStateBox = new JComboBox<>();
	 private final InternalComboboxListener selectionStateBoxListener = new InternalComboboxListener();
	 public CSelectionCriteriumPanel(final CSelectionCriterium criterium) {
		 super(new BorderLayout());
		 m_criterium = criterium;
		 selectionStateBox.addActionListener(selectionStateBoxListener);
		 initPanel();
	 }
	 private void initPanel() {
		 final JPanel mainPanel = new JPanel(new BorderLayout());
		 mainPanel.setBorder(new TitledBorder(""Edit Selection Condition""));
		 final JPanel comboPanel = new JPanel(new BorderLayout());
		 comboPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
		 selectionStateBox.addItem(SelectionState.SELECTED);
		 selectionStateBox.addItem(SelectionState.UNSELECTED);
		 comboPanel.add(selectionStateBox, BorderLayout.CENTER);
		 mainPanel.add(comboPanel, BorderLayout.NORTH);
		 add(mainPanel, BorderLayout.CENTER);
	 }
	 public void dispose() {
		 selectionStateBox.removeActionListener(selectionStateBoxListener);
	 }
	 public SelectionState getSelectionState() {
		 return (SelectionState) selectionStateBox.getSelectedItem();
	 }
	 private class InternalComboboxListener implements ActionListener {
		 public void actionPerformed(final ActionEvent event) {
			 m_criterium.notifyListeners();
		 }
	 }
}",1,0,0,0
"private static class CountPageable implements Pageable {
	private Pageable delegate;
	public CountPageable(Pageable delegate) {
		this.delegate = delegate;
	}
	public int getPageNumber() {
		return delegate.getPageNumber();
	}
	public int getPageSize() {
		return delegate.getPageSize();
	}
	public long getOffset() {
		return delegate.getOffset();
	}
	public Sort getSort() {
		return Sort.unsorted();
	}
	public Pageable next() {
		return delegate.next();
	}
	public Pageable previousOrFirst() {
		return delegate.previousOrFirst();
	}
	public Pageable first() {
		return delegate.first();
	}
	public boolean hasPrevious() {
		return delegate.hasPrevious();
	}
}",0,1,0,0
public BusinessDayConvention getFixingBusinessDayConvention();,0,0,0,0
"long recoverDrf(OplogEntryIdSet deletedIds, boolean alreadyRecoveredOnce, boolean latestOplog) {
	 File drfFile = this.drf.f;
	 if (drfFile == null) {
		 this.haveRecoveredDrf = true;
		 return 0L;
	 }
	 lockCompactor();
	 try {
		 if (this.haveRecoveredDrf && !getHasDeletes()) return 0L;
		 if (!this.haveRecoveredDrf) {
			 this.haveRecoveredDrf = true;
		 }
		 logger.info(""Recovering {
		}
		 {
		}
		 for disk store {
		}
		."", new Object[] {
		toString(), drfFile.getAbsolutePath(), getParent().getName()}
		);
		 this.recoverDelEntryId = DiskStoreImpl.INVALID_ID;
		 boolean readLastRecord = true;
		 CountingDataInputStream dis = null;
		 try {
			 int recordCount = 0;
			 boolean foundDiskStoreRecord = false;
			 FileInputStream fis = null;
			 try {
				 fis = new FileInputStream(drfFile);
				 dis = new CountingDataInputStream(new BufferedInputStream(fis, 32 * 1024), drfFile.length());
				 boolean endOfLog = false;
				 while (!endOfLog) {
					 if (dis.atEndOfFile()) {
						 endOfLog = true;
						 break;
					 }
					 readLastRecord = false;
					 byte opCode = dis.readByte();
					 if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY_VERBOSE)) {
						 logger.trace(LogMarker.PERSIST_RECOVERY_VERBOSE, ""drf byte={
						}
						 location={
						}
						"", opCode, Long.toHexString(dis.getCount()));
					 }
					 switch (opCode) {
						 case OPLOG_EOF_ID: dis.decrementCount();
						 endOfLog = true;
						 break;
						 case OPLOG_DEL_ENTRY_1ID: case OPLOG_DEL_ENTRY_2ID: case OPLOG_DEL_ENTRY_3ID: case OPLOG_DEL_ENTRY_4ID: case OPLOG_DEL_ENTRY_5ID: case OPLOG_DEL_ENTRY_6ID: case OPLOG_DEL_ENTRY_7ID: case OPLOG_DEL_ENTRY_8ID: readDelEntry(dis, opCode, deletedIds, parent);
						 recordCount++;
						 break;
						 case OPLOG_DISK_STORE_ID: readDiskStoreRecord(dis, this.drf.f);
						 foundDiskStoreRecord = true;
						 recordCount++;
						 break;
						 case OPLOG_MAGIC_SEQ_ID: readOplogMagicSeqRecord(dis, this.drf.f, OPLOG_TYPE.DRF);
						 break;
						 case OPLOG_GEMFIRE_VERSION: readGemfireVersionRecord(dis, this.drf.f);
						 recordCount++;
						 break;
						 case OPLOG_RVV: long idx = dis.getCount();
						 readRVVRecord(dis, this.drf.f, true, latestOplog);
						 recordCount++;
						 break;
						 default: throw new DiskAccessException( String.format(""Unknown opCode %s found in disk operation log."", opCode), getParent());
					 }
					 readLastRecord = true;
				 }
			 }
			 finally {
				 if (dis != null) {
					 dis.close();
				 }
				 if (fis != null) {
					 fis.close();
				 }
			 }
			 if (!foundDiskStoreRecord && recordCount > 0) {
				 throw new DiskAccessException( ""The oplog file \"""" + this.drf.f + ""\"" does not belong to the init file \"""" + getParent().getInitFile() + ""\"". Drf did not contain a disk store id."", getParent());
			 }
		 }
		 catch (EOFException ignore) {
		 }
		 catch (IOException ex) {
			 getParent().getCancelCriterion().checkCancelInProgress(ex);
			 throw new DiskAccessException( String.format(""Failed to read file during recovery from %s"", drfFile.getPath()), ex, getParent());
		 }
		 catch (CancelException e) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(""Oplog::readOplog:Error in recovery as Cache was closed"", e);
			 }
		 }
		 catch (RegionDestroyedException e) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(""Oplog::readOplog:Error in recovery as Region was destroyed"", e);
			 }
		 }
		 long byteCount = 0;
		 if (!readLastRecord) {
			 this.crashed = true;
			 if (dis != null) {
				 byteCount = dis.getFileLength();
			 }
		 }
		 else {
			 if (dis != null) {
				 byteCount = dis.getCount();
			 }
		 }
		 if (!alreadyRecoveredOnce) {
			 setRecoveredDrfSize(byteCount);
			 this.dirHolder.incrementTotalOplogSize(byteCount);
		 }
		 return byteCount;
	 }
	 finally {
		 unlockCompactor();
	 }
 }",0,0,1,0
"protected static class SessionAttributeElement implements AccessLogElement {
	 private final String header;
	 public SessionAttributeElement(String header) {
		 this.header = header;
	 }
	 public void addElement(CharArrayWriter buf, Date date, Request request, Response response, long time) {
		 Object value = null;
		 if (null != request) {
			 HttpSession sess = request.getSession(false);
			 if (null != sess) {
				 value = sess.getAttribute(header);
			 }
		 }
		 else {
			 value = ""??"";
		 }
		 if (value != null) {
			 if (value instanceof String) {
				 buf.append((String) value);
			 }
			 else {
				 buf.append(value.toString());
			 }
		 }
		 else {
			 buf.append('-');
		 }
	 }
 }",0,0,0,0
"public class MqttDTO extends ProtocolDTO {
	 public Integer max_message_length;
	 public List<ProtocolFilterDTO> protocol_filters = new ArrayList<ProtocolFilterDTO>();
	 public String queue_prefix;
	 public String path_separator;
	 public String any_child_wildcard;
	 public String any_descendant_wildcard;
	 public String regex_wildcard_start;
	 public String regex_wildcard_end;
	 public String part_pattern;
	 public Long die_delay;
	 public boolean equals(Object o) {
		 if (this == o) return true;
		 if (o == null || getClass() != o.getClass()) return false;
		 if (!super.equals(o)) return false;
		 MqttDTO mqttDTO = (MqttDTO) o;
		 if (any_child_wildcard != null ? !any_child_wildcard.equals(mqttDTO.any_child_wildcard) : mqttDTO.any_child_wildcard != null) return false;
		 if (any_descendant_wildcard != null ? !any_descendant_wildcard.equals(mqttDTO.any_descendant_wildcard) : mqttDTO.any_descendant_wildcard != null) return false;
		 if (max_message_length != null ? !max_message_length.equals(mqttDTO.max_message_length) : mqttDTO.max_message_length != null) return false;
		 if (path_separator != null ? !path_separator.equals(mqttDTO.path_separator) : mqttDTO.path_separator != null) return false;
		 if (protocol_filters != null ? !protocol_filters.equals(mqttDTO.protocol_filters) : mqttDTO.protocol_filters != null) return false;
		 if (queue_prefix != null ? !queue_prefix.equals(mqttDTO.queue_prefix) : mqttDTO.queue_prefix != null) return false;
		 if (regex_wildcard_end != null ? !regex_wildcard_end.equals(mqttDTO.regex_wildcard_end) : mqttDTO.regex_wildcard_end != null) return false;
		 if (regex_wildcard_start != null ? !regex_wildcard_start.equals(mqttDTO.regex_wildcard_start) : mqttDTO.regex_wildcard_start != null) return false;
		 if (part_pattern != null ? !part_pattern.equals(mqttDTO.part_pattern) : mqttDTO.part_pattern != null) return false;
		 return true;
	 }
	 public int hashCode() {
		 int result = super.hashCode();
		 result = 31 * result + (max_message_length != null ? max_message_length.hashCode() : 0);
		 result = 31 * result + (protocol_filters != null ? protocol_filters.hashCode() : 0);
		 result = 31 * result + (queue_prefix != null ? queue_prefix.hashCode() : 0);
		 result = 31 * result + (part_pattern != null ? part_pattern.hashCode() : 0);
		 result = 31 * result + (path_separator != null ? path_separator.hashCode() : 0);
		 result = 31 * result + (any_child_wildcard != null ? any_child_wildcard.hashCode() : 0);
		 result = 31 * result + (any_descendant_wildcard != null ? any_descendant_wildcard.hashCode() : 0);
		 result = 31 * result + (regex_wildcard_start != null ? regex_wildcard_start.hashCode() : 0);
		 result = 31 * result + (regex_wildcard_end != null ? regex_wildcard_end.hashCode() : 0);
		 return result;
	 }
}",1,1,0,0
"class TaskRemoval implements WorkerHistoryItem {
	 private final String taskId;
	 public TaskRemoval( String taskId ) {
		 this.taskId = taskId;
	 }
	 public String getTaskId() {
		 return taskId;
	 }
	 public String toString() {
		 return ""TaskRemoval{
		"" + ""taskId='"" + taskId + '\'' + '}
		';
	 }
 }",0,1,0,0
"public class DataOutputBuffer extends DataOutputStream {
	 private static class Buffer extends ByteArrayOutputStream {
		 public byte[] getData() {
			 return buf;
		 }
		 public int getLength() {
			 return count;
		 }
		 public void reset() {
			 count = 0;
		 }
		 public void write(DataInput in, int len) throws IOException {
			 int newcount = count + len;
			 if (newcount > buf.length) {
				 byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
				 System.arraycopy(buf, 0, newbuf, 0, count);
				 buf = newbuf;
			 }
			 in.readFully(buf, count, len);
			 count = newcount;
		 }
	 }
	 private Buffer buffer;
	 public DataOutputBuffer() {
		 this(new Buffer());
	 }
	 private DataOutputBuffer(Buffer buffer) {
		 super(buffer);
		 this.buffer = buffer;
	 }
	 public byte[] getData() {
		 return buffer.getData();
	 }
	 public int getLength() {
		 return buffer.getLength();
	 }
	 public DataOutputBuffer reset() {
		 this.written = 0;
		 buffer.reset();
		 return this;
	 }
	 public void write(DataInput in, int length) throws IOException {
		 buffer.write(in, length);
	 }
}",0,0,0,0
"public boolean prepare() throws IOException {
	 this.mapOutputFile.removeAll(reduceTask.getTaskId());
	 final int numOutputs = reduceTask.getNumMaps();
	 List neededOutputs = new ArrayList(numOutputs);
	 List knownOutputs = new ArrayList(100);
	 int numInFlight = 0, numCopied = 0;
	 int lowThreshold = numCopiers*2;
	 long bytesTransferred = 0;
	 DecimalFormat mbpsFormat = new DecimalFormat(""0.00"");
	 Random backoff = new Random();
	 final Progress copyPhase = getTask().getProgress().phase();
	 MapCopyLeaseChecker leaseChecker = null;
	 for (int i = 0;
	 i < numOutputs;
	 i++) {
		 neededOutputs.add(new Integer(i));
		 copyPhase.addPhase();
	 }
	 InterTrackerProtocol jobClient = getTracker().getJobClient();
	 copiers = new MapOutputCopier[numCopiers];
	 for (int i=0;
	 i < copiers.length;
	 i++) {
		 copiers[i] = new MapOutputCopier();
		 copiers[i].start();
	 }
	 leaseChecker = new MapCopyLeaseChecker();
	 leaseChecker.start();
	 long startTime = System.currentTimeMillis();
	 long currentTime = startTime;
	 while (!killed && numCopied < numOutputs) {
		 LOG.info(reduceTask.getTaskId() + "" Need "" + (numOutputs-numCopied) + "" map output(s)"");
		 if (!neededOutputs.isEmpty()) {
			 LOG.info(reduceTask.getTaskId() + "" Need "" + neededOutputs.size() + "" map output location(s)"");
			 try {
				 MapOutputLocation[] locs = queryJobTracker(neededOutputs, jobClient);
				 for (int i=0;
				 i < locs.length;
				 i++) {
					 neededOutputs.remove(new Integer(locs[i].getMapId()));
					 knownOutputs.add(locs[i]);
				 }
				 LOG.info(reduceTask.getTaskId() + "" Got "" + (locs == null ? 0 : locs.length) + "" map outputs from jobtracker"");
			 }
			 catch (IOException ie) {
				 LOG.warn(reduceTask.getTaskId() + "" Problem locating map outputs: "" + StringUtils.stringifyException(ie));
			 }
		 }
		 int numKnown = knownOutputs.size(), numScheduled = 0;
		 int numSlow = 0, numDups = 0;
		 LOG.info(reduceTask.getTaskId() + "" Got "" + numKnown + "" known map output location(s);
		 scheduling..."");
		 synchronized (scheduledCopies) {
			 ListIterator locIt = knownOutputs.listIterator();
			 currentTime = System.currentTimeMillis();
			 while (locIt.hasNext()) {
				 MapOutputLocation loc = (MapOutputLocation)locIt.next();
				 Long penaltyEnd = (Long)penaltyBox.get(loc.getHost());
				 boolean penalized = false, duplicate = false;
				 if (penaltyEnd != null && currentTime < penaltyEnd.longValue()) {
					 penalized = true;
					 numSlow++;
				 }
				 if (uniqueHosts.contains(loc.getHost())) {
					 duplicate = true;
					 numDups++;
				 }
				 if (!penalized && !duplicate) {
					 uniqueHosts.add(loc.getHost());
					 scheduledCopies.add(loc);
					 locIt.remove();
					 numInFlight++;
					 numScheduled++;
				 }
			 }
			 scheduledCopies.notifyAll();
		 }
		 LOG.info(reduceTask.getTaskId() + "" Scheduled "" + numScheduled + "" of "" + numKnown + "" known outputs ("" + numSlow + "" slow hosts and "" + numDups + "" dup hosts)"");
		 try {
			 if (numInFlight == 0 && numScheduled == 0) {
				 Thread.sleep(5000);
			 }
		 }
		 catch (InterruptedException e) {
		 }
		 while (!killed && numInFlight > 0) {
			 CopyResult cr = getCopyResult();
			 if (cr != null) {
				 if (cr.getSuccess()) {
					 numCopied++;
					 bytesTransferred += cr.getSize();
					 long secsSinceStart = (System.currentTimeMillis()-startTime)/1000+1;
					 float mbs = ((float)bytesTransferred)/(1024*1024);
					 float transferRate = mbs/secsSinceStart;
					 copyPhase.startNextPhase();
					 copyPhase.setStatus(""copy ("" + numCopied + "" of "" + numOutputs + "" at "" + mbpsFormat.format(transferRate) + "" MB/s)"");
					 getTask().reportProgress(getTracker());
				 }
				 else {
					 neededOutputs.add(new Integer(cr.getMapId()));
					 currentTime = System.currentTimeMillis();
					 long nextContact = currentTime + 60 * 1000 + backoff.nextInt(maxBackoff*1000);
					 penaltyBox.put(cr.getHost(), new Long(nextContact));
					 LOG.warn(reduceTask.getTaskId() + "" adding host "" + cr.getHost() + "" to penalty box, next contact in "" + ((nextContact-currentTime)/1000) + "" seconds"");
				 }
				 uniqueHosts.remove(cr.getHost());
				 numInFlight--;
			 }
			 if (numInFlight < lowThreshold && (numOutputs-numCopied) > PROBE_SAMPLE_SIZE) {
				 break;
			 }
		 }
	 }
	 leaseChecker.interrupt();
	 synchronized (copiers) {
		 synchronized (scheduledCopies) {
			 for (int i=0;
			 i < copiers.length;
			 i++) {
				 copiers[i].interrupt();
				 copiers[i] = null;
			 }
		 }
	 }
	 return numCopied == numOutputs && !killed;
 }",0,0,1,0
"final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
 }",0,0,0,0
public void shutdownMapHook();,0,0,0,0
"public class P4Add extends P4Base {
	 private static final int DEFAULT_CMD_LENGTH = 450;
	 private int changelist;
	 private String addCmd = """";
	 private Vector filesets = new Vector();
	 private int cmdLength = DEFAULT_CMD_LENGTH;
	 public void setCommandlength(int len) throws BuildException {
		 if (len <= 0) {
			 throw new BuildException(""P4Add: Commandlength should be a positive number"");
		 }
		 this.cmdLength = len;
	 }
	 public void setChangelist(int changelist) throws BuildException {
		 if (changelist <= 0) {
			 throw new BuildException(""P4Add: Changelist# should be a positive number"");
		 }
		 this.changelist = changelist;
	 }
	 public void addFileset(FileSet set) {
		 filesets.addElement(set);
	 }
	 public void execute() throws BuildException {
		 if (P4View != null) {
			 addCmd = P4View;
		 }
		 P4CmdOpts = (changelist > 0) ? (""-c "" + changelist) : """";
		 StringBuffer filelist = new StringBuffer();
		 final int size = filesets.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 FileSet fs = (FileSet) filesets.elementAt(i);
			 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
			 String[] srcFiles = ds.getIncludedFiles();
			 if (srcFiles != null) {
				 for (int j = 0;
				 j < srcFiles.length;
				 j++) {
					 File f = new File(ds.getBasedir(), srcFiles[j]);
					 filelist.append("" "").append('""').append(f.getAbsolutePath()).append('""');
					 if (filelist.length() > cmdLength) {
						 execP4Add(filelist);
						 filelist = new StringBuffer();
					 }
				 }
				 if (filelist.length() > 0) {
					 execP4Add(filelist);
				 }
			 }
			 else {
				 log(""No files specified to add!"", Project.MSG_WARN);
			 }
		 }
	 }
	 private void execP4Add(StringBuffer list) {
		 log(""Execing add "" + P4CmdOpts + "" "" + addCmd + list, Project.MSG_INFO);
		 execP4Command(""-s add "" + P4CmdOpts + "" "" + addCmd + list, new SimpleP4OutputHandler(this));
	 }
}",0,0,0,0
"public class FailureDetector implements IFailureDetector, FailureDetectorMBean{
	 public static final IFailureDetector instance = new FailureDetector();
	 private static Logger logger_ = LoggerFactory.getLogger(FailureDetector.class);
	 private static final int sampleSize_ = 1000;
	 private static int phiConvictThreshold_;
	 private Map<InetAddress, ArrivalWindow> arrivalSamples_ = new Hashtable<InetAddress, ArrivalWindow>();
	 private List<IFailureDetectionEventListener> fdEvntListeners_ = new ArrayList<IFailureDetectionEventListener>();
	 public FailureDetector() {
		 phiConvictThreshold_ = DatabaseDescriptor.getPhiConvictThreshold();
		 try {
			 MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
			 mbs.registerMBean(this, new ObjectName(""org.apache.cassandra.net:type=FailureDetector""));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public String getAllEndpointStates() {
		 StringBuilder sb = new StringBuilder();
		 for (Map.Entry<InetAddress, EndpointState> entry : Gossiper.instance.endpointStateMap.entrySet()) {
			 sb.append(entry.getKey()).append(""\n"");
			 for (Map.Entry<ApplicationState, VersionedValue> state : entry.getValue().applicationState.entrySet()) sb.append("" "").append(state.getKey()).append("":"").append(state.getValue().value).append(""\n"");
		 }
		 return sb.toString();
	 }
	 public void dumpInterArrivalTimes() {
		 OutputStream os = null;
		 try {
			 File file = File.createTempFile(""failuredetector-"", "".dat"");
			 os = new BufferedOutputStream(new FileOutputStream(file, true));
			 os.write(toString().getBytes());
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 finally {
			 FileUtils.closeQuietly(os);
		 }
	 }
	 public void setPhiConvictThreshold(int phi) {
		 phiConvictThreshold_ = phi;
	 }
	 public int getPhiConvictThreshold() {
		 return phiConvictThreshold_;
	 }
	 public boolean isAlive(InetAddress ep) {
		 if (ep.equals(FBUtilities.getLocalAddress())) return true;
		 EndpointState epState = Gossiper.instance.getEndpointStateForEndpoint(ep);
		 if (epState == null) logger_.error(""unknown endpoint "" + ep);
		 return epState != null && epState.isAlive();
	 }
	 public void report(InetAddress ep) {
		 if (logger_.isTraceEnabled()) logger_.trace(""reporting {
		}
		"", ep);
		 long now = System.currentTimeMillis();
		 ArrivalWindow heartbeatWindow = arrivalSamples_.get(ep);
		 if ( heartbeatWindow == null ) {
			 heartbeatWindow = new ArrivalWindow(sampleSize_);
			 arrivalSamples_.put(ep, heartbeatWindow);
		 }
		 heartbeatWindow.add(now);
	 }
	 public void interpret(InetAddress ep) {
		 ArrivalWindow hbWnd = arrivalSamples_.get(ep);
		 if ( hbWnd == null ) {
			 return;
		 }
		 long now = System.currentTimeMillis();
		 double phi = hbWnd.phi(now);
		 if (logger_.isTraceEnabled()) logger_.trace(""PHI for "" + ep + "" : "" + phi);
		 if ( phi > phiConvictThreshold_ ) {
			 for ( IFailureDetectionEventListener listener : fdEvntListeners_ ) {
				 listener.convict(ep);
			 }
		 }
	 }
	 public void remove(InetAddress ep) {
		 arrivalSamples_.remove(ep);
	 }
	 public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) {
		 fdEvntListeners_.add(listener);
	 }
	 public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) {
		 fdEvntListeners_.remove(listener);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 Set<InetAddress> eps = arrivalSamples_.keySet();
		 sb.append(""-----------------------------------------------------------------------"");
		 for ( InetAddress ep : eps ) {
			 ArrivalWindow hWnd = arrivalSamples_.get(ep);
			 sb.append(ep + "" : "");
			 sb.append(hWnd.toString());
			 sb.append( System.getProperty(""line.separator"") );
		 }
		 sb.append(""-----------------------------------------------------------------------"");
		 return sb.toString();
	 }
	 public static void main(String[] args) throws Throwable {
	 }
}
class ArrivalWindow{
	 private static Logger logger_ = LoggerFactory.getLogger(ArrivalWindow.class);
	 private double tLast_ = 0L;
	 private BoundedStatsDeque arrivalIntervals_;
	 private final double PHI_FACTOR = 1.0 / Math.log(10.0);
	 ArrivalWindow(int size) {
		 arrivalIntervals_ = new BoundedStatsDeque(size);
	 }
	 synchronized void add(double value) {
		 double interArrivalTime;
		 if ( tLast_ > 0L ) {
			 interArrivalTime = (value - tLast_);
		 }
		 else {
			 interArrivalTime = Gossiper.intervalInMillis / 2;
		 }
		 tLast_ = value;
		 arrivalIntervals_.add(interArrivalTime);
	 }
	 synchronized double sum() {
		 return arrivalIntervals_.sum();
	 }
	 synchronized double sumOfDeviations() {
		 return arrivalIntervals_.sumOfDeviations();
	 }
	 synchronized double mean() {
		 return arrivalIntervals_.mean();
	 }
	 synchronized double variance() {
		 return arrivalIntervals_.variance();
	 }
	 double stdev() {
		 return arrivalIntervals_.stdev();
	 }
	 void clear() {
		 arrivalIntervals_.clear();
	 }
	 synchronized double phi(long tnow) {
		 int size = arrivalIntervals_.size();
		 double t = tnow - tLast_;
		 return (size > 0) ? PHI_FACTOR * t / mean() : 0.0;
	 }
	 public String toString() {
		 return StringUtils.join(arrivalIntervals_.iterator(), "" "");
	 }
}",0,0,0,0
"public class CBZip2OutputStream extends OutputStream implements BZip2Constants {
	 protected static final int SETMASK = (1 << 21);
	 protected static final int CLEARMASK = (~SETMASK);
	 protected static final int GREATER_ICOST = 15;
	 protected static final int LESSER_ICOST = 0;
	 protected static final int SMALL_THRESH = 20;
	 protected static final int DEPTH_THRESH = 10;
	 protected static final int QSORT_STACK_SIZE = 1000;
	 private static void panic() {
		 System.out.println(""panic"");
	 }
	 private void makeMaps() {
		 int i;
		 nInUse = 0;
		 for (i = 0;
		 i < 256;
		 i++) {
			 if (inUse[i]) {
				 seqToUnseq[nInUse] = (char) i;
				 unseqToSeq[i] = (char) nInUse;
				 nInUse++;
			 }
		 }
	 }
	 protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) {
		 int nNodes, nHeap, n1, n2, i, j, k;
		 boolean tooLong;
		 int[] heap = new int[MAX_ALPHA_SIZE + 2];
		 int[] weight = new int[MAX_ALPHA_SIZE * 2];
		 int[] parent = new int[MAX_ALPHA_SIZE * 2];
		 for (i = 0;
		 i < alphaSize;
		 i++) {
			 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
		 }
		 while (true) {
			 nNodes = alphaSize;
			 nHeap = 0;
			 heap[0] = 0;
			 weight[0] = 0;
			 parent[0] = -2;
			 for (i = 1;
			 i <= alphaSize;
			 i++) {
				 parent[i] = -1;
				 nHeap++;
				 heap[nHeap] = i;
				 {
					 int zz, tmp;
					 zz = nHeap;
					 tmp = heap[zz];
					 while (weight[tmp] < weight[heap[zz >> 1]]) {
						 heap[zz] = heap[zz >> 1];
						 zz >>= 1;
					 }
					 heap[zz] = tmp;
				 }
			 }
			 if (!(nHeap < (MAX_ALPHA_SIZE + 2))) {
				 panic();
			 }
			 while (nHeap > 1) {
				 n1 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 {
					 int zz = 0, yy = 0, tmp = 0;
					 zz = 1;
					 tmp = heap[zz];
					 while (true) {
						 yy = zz << 1;
						 if (yy > nHeap) {
							 break;
						 }
						 if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {
							 yy++;
						 }
						 if (weight[tmp] < weight[heap[yy]]) {
							 break;
						 }
						 heap[zz] = heap[yy];
						 zz = yy;
					 }
					 heap[zz] = tmp;
				 }
				 n2 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 {
					 int zz = 0, yy = 0, tmp = 0;
					 zz = 1;
					 tmp = heap[zz];
					 while (true) {
						 yy = zz << 1;
						 if (yy > nHeap) {
							 break;
						 }
						 if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {
							 yy++;
						 }
						 if (weight[tmp] < weight[heap[yy]]) {
							 break;
						 }
						 heap[zz] = heap[yy];
						 zz = yy;
					 }
					 heap[zz] = tmp;
				 }
				 nNodes++;
				 parent[n1] = parent[n2] = nNodes;
				 weight[nNodes] = ((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) | (1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));
				 parent[nNodes] = -1;
				 nHeap++;
				 heap[nHeap] = nNodes;
				 {
					 int zz = 0, tmp = 0;
					 zz = nHeap;
					 tmp = heap[zz];
					 while (weight[tmp] < weight[heap[zz >> 1]]) {
						 heap[zz] = heap[zz >> 1];
						 zz >>= 1;
					 }
					 heap[zz] = tmp;
				 }
			 }
			 if (!(nNodes < (MAX_ALPHA_SIZE * 2))) {
				 panic();
			 }
			 tooLong = false;
			 for (i = 1;
			 i <= alphaSize;
			 i++) {
				 j = 0;
				 k = i;
				 while (parent[k] >= 0) {
					 k = parent[k];
					 j++;
				 }
				 len[i - 1] = (char) j;
				 if (j > maxLen) {
					 tooLong = true;
				 }
			 }
			 if (!tooLong) {
				 break;
			 }
			 for (i = 1;
			 i < alphaSize;
			 i++) {
				 j = weight[i] >> 8;
				 j = 1 + (j / 2);
				 weight[i] = j << 8;
			 }
		 }
	 }
	 int last;
	 int origPtr;
	 int blockSize100k;
	 boolean blockRandomised;
	 int bytesOut;
	 int bsBuff;
	 int bsLive;
	 CRC mCrc = new CRC();
	 private boolean[] inUse = new boolean[256];
	 private int nInUse;
	 private char[] seqToUnseq = new char[256];
	 private char[] unseqToSeq = new char[256];
	 private char[] selector = new char[MAX_SELECTORS];
	 private char[] selectorMtf = new char[MAX_SELECTORS];
	 private char[] block;
	 private int[] quadrant;
	 private int[] zptr;
	 private short[] szptr;
	 private int[] ftab;
	 private int nMTF;
	 private int[] mtfFreq = new int[MAX_ALPHA_SIZE];
	 private int workFactor;
	 private int workDone;
	 private int workLimit;
	 private boolean firstAttempt;
	 private int nBlocksRandomised;
	 private int currentChar = -1;
	 private int runLength = 0;
	 public CBZip2OutputStream(OutputStream inStream) throws IOException {
		 this(inStream, 9);
	 }
	 public CBZip2OutputStream(OutputStream inStream, int inBlockSize) throws IOException {
		 block = null;
		 quadrant = null;
		 zptr = null;
		 ftab = null;
		 bsSetStream(inStream);
		 workFactor = 50;
		 if (inBlockSize > 9) {
			 inBlockSize = 9;
		 }
		 if (inBlockSize < 1) {
			 inBlockSize = 1;
		 }
		 blockSize100k = inBlockSize;
		 allocateCompressStructures();
		 initialize();
		 initBlock();
	 }
	 public void write(int bv) throws IOException {
		 int b = (256 + bv) % 256;
		 if (currentChar != -1) {
			 if (currentChar == b) {
				 runLength++;
				 if (runLength > 254) {
					 writeRun();
					 currentChar = -1;
					 runLength = 0;
				 }
			 }
			 else {
				 writeRun();
				 runLength = 1;
				 currentChar = b;
			 }
		 }
		 else {
			 currentChar = b;
			 runLength++;
		 }
	 }
	 private void writeRun() throws IOException {
		 if (last < allowableBlockSize) {
			 inUse[currentChar] = true;
			 for (int i = 0;
			 i < runLength;
			 i++) {
				 mCrc.updateCRC((char) currentChar);
			 }
			 switch (runLength) {
				 case 1: last++;
				 block[last + 1] = (char) currentChar;
				 break;
				 case 2: last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 break;
				 case 3: last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 break;
				 default: inUse[runLength - 4] = true;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) (runLength - 4);
				 break;
			 }
		 }
		 else {
			 endBlock();
			 initBlock();
			 writeRun();
		 }
	 }
	 boolean closed = false;
	 protected void finalize() throws Throwable {
		 close();
		 super.finalize();
	 }
	 public void close() throws IOException {
		 if (closed) {
			 return;
		 }
		 if (runLength > 0) {
			 writeRun();
		 }
		 currentChar = -1;
		 endBlock();
		 endCompression();
		 closed = true;
		 super.close();
		 bsStream.close();
	 }
	 public void flush() throws IOException {
		 super.flush();
		 bsStream.flush();
	 }
	 private int blockCRC, combinedCRC;
	 private void initialize() throws IOException {
		 bytesOut = 0;
		 nBlocksRandomised = 0;
		 bsPutUChar('h');
		 bsPutUChar('0' + blockSize100k);
		 combinedCRC = 0;
	 }
	 private int allowableBlockSize;
	 private void initBlock() {
		 mCrc.initialiseCRC();
		 last = -1;
		 for (int i = 0;
		 i < 256;
		 i++) {
			 inUse[i] = false;
		 }
		 allowableBlockSize = baseBlockSize * blockSize100k - 20;
	 }
	 private void endBlock() throws IOException {
		 blockCRC = mCrc.getFinalCRC();
		 combinedCRC = (combinedCRC << 1) | (combinedCRC >>> 31);
		 combinedCRC ^= blockCRC;
		 doReversibleTransformation();
		 bsPutUChar(0x31);
		 bsPutUChar(0x41);
		 bsPutUChar(0x59);
		 bsPutUChar(0x26);
		 bsPutUChar(0x53);
		 bsPutUChar(0x59);
		 bsPutint(blockCRC);
		 if (blockRandomised) {
			 bsW(1, 1);
			 nBlocksRandomised++;
		 }
		 else {
			 bsW(1, 0);
		 }
		 moveToFrontCodeAndSend();
	 }
	 private void endCompression() throws IOException {
		 bsPutUChar(0x17);
		 bsPutUChar(0x72);
		 bsPutUChar(0x45);
		 bsPutUChar(0x38);
		 bsPutUChar(0x50);
		 bsPutUChar(0x90);
		 bsPutint(combinedCRC);
		 bsFinishedWithStream();
	 }
	 private void hbAssignCodes (int[] code, char[] length, int minLen, int maxLen, int alphaSize) {
		 int n, vec, i;
		 vec = 0;
		 for (n = minLen;
		 n <= maxLen;
		 n++) {
			 for (i = 0;
			 i < alphaSize;
			 i++) {
				 if (length[i] == n) {
					 code[i] = vec;
					 vec++;
				 }
			 }
			;
			 vec <<= 1;
		 }
	 }
	 private void bsSetStream(OutputStream f) {
		 bsStream = f;
		 bsLive = 0;
		 bsBuff = 0;
		 bytesOut = 0;
	 }
	 private void bsFinishedWithStream() throws IOException {
		 while (bsLive > 0) {
			 int ch = (bsBuff >> 24);
			 try {
				 bsStream.write(ch);
			 }
			 catch (IOException e) {
				 throw e;
			 }
			 bsBuff <<= 8;
			 bsLive -= 8;
			 bytesOut++;
		 }
	 }
	 private void bsW(int n, int v) throws IOException {
		 while (bsLive >= 8) {
			 int ch = (bsBuff >> 24);
			 try {
				 bsStream.write(ch);
			 }
			 catch (IOException e) {
				 throw e;
			 }
			 bsBuff <<= 8;
			 bsLive -= 8;
			 bytesOut++;
		 }
		 bsBuff |= (v << (32 - bsLive - n));
		 bsLive += n;
	 }
	 private void bsPutUChar(int c) throws IOException {
		 bsW(8, c);
	 }
	 private void bsPutint(int u) throws IOException {
		 bsW(8, (u >> 24) & 0xff);
		 bsW(8, (u >> 16) & 0xff);
		 bsW(8, (u >> 8) & 0xff);
		 bsW(8, u & 0xff);
	 }
	 private void bsPutIntVS(int numBits, int c) throws IOException {
		 bsW(numBits, c);
	 }
	 private void sendMTFValues() throws IOException {
		 char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];
		 int v, t, i, j, gs, ge, totc, bt, bc, iter;
		 int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;
		 int nGroups, nBytes;
		 alphaSize = nInUse + 2;
		 for (t = 0;
		 t < N_GROUPS;
		 t++) {
			 for (v = 0;
			 v < alphaSize;
			 v++) {
				 len[t][v] = (char) GREATER_ICOST;
			 }
		 }
		 if (nMTF <= 0) {
			 panic();
		 }
		 if (nMTF < 200) {
			 nGroups = 2;
		 }
		 else if (nMTF < 600) {
			 nGroups = 3;
		 }
		 else if (nMTF < 1200) {
			 nGroups = 4;
		 }
		 else if (nMTF < 2400) {
			 nGroups = 5;
		 }
		 else {
			 nGroups = 6;
		 }
		 {
			 int nPart, remF, tFreq, aFreq;
			 nPart = nGroups;
			 remF = nMTF;
			 gs = 0;
			 while (nPart > 0) {
				 tFreq = remF / nPart;
				 ge = gs - 1;
				 aFreq = 0;
				 while (aFreq < tFreq && ge < alphaSize - 1) {
					 ge++;
					 aFreq += mtfFreq[ge];
				 }
				 if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {
					 aFreq -= mtfFreq[ge];
					 ge--;
				 }
				 for (v = 0;
				 v < alphaSize;
				 v++) {
					 if (v >= gs && v <= ge) {
						 len[nPart - 1][v] = (char) LESSER_ICOST;
					 }
					 else {
						 len[nPart - 1][v] = (char) GREATER_ICOST;
					 }
				 }
				 nPart--;
				 gs = ge + 1;
				 remF -= aFreq;
			 }
		 }
		 int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 int[] fave = new int[N_GROUPS];
		 short[] cost = new short[N_GROUPS];
		 for (iter = 0;
		 iter < N_ITERS;
		 iter++) {
			 for (t = 0;
			 t < nGroups;
			 t++) {
				 fave[t] = 0;
			 }
			 for (t = 0;
			 t < nGroups;
			 t++) {
				 for (v = 0;
				 v < alphaSize;
				 v++) {
					 rfreq[t][v] = 0;
				 }
			 }
			 nSelectors = 0;
			 totc = 0;
			 gs = 0;
			 while (true) {
				 if (gs >= nMTF) {
					 break;
				 }
				 ge = gs + G_SIZE - 1;
				 if (ge >= nMTF) {
					 ge = nMTF - 1;
				 }
				 for (t = 0;
				 t < nGroups;
				 t++) {
					 cost[t] = 0;
				 }
				 if (nGroups == 6) {
					 short cost0, cost1, cost2, cost3, cost4, cost5;
					 cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;
					 for (i = gs;
					 i <= ge;
					 i++) {
						 short icv = szptr[i];
						 cost0 += len[0][icv];
						 cost1 += len[1][icv];
						 cost2 += len[2][icv];
						 cost3 += len[3][icv];
						 cost4 += len[4][icv];
						 cost5 += len[5][icv];
					 }
					 cost[0] = cost0;
					 cost[1] = cost1;
					 cost[2] = cost2;
					 cost[3] = cost3;
					 cost[4] = cost4;
					 cost[5] = cost5;
				 }
				 else {
					 for (i = gs;
					 i <= ge;
					 i++) {
						 short icv = szptr[i];
						 for (t = 0;
						 t < nGroups;
						 t++) {
							 cost[t] += len[t][icv];
						 }
					 }
				 }
				 bc = 999999999;
				 bt = -1;
				 for (t = 0;
				 t < nGroups;
				 t++) {
					 if (cost[t] < bc) {
						 bc = cost[t];
						 bt = t;
					 }
				 }
				;
				 totc += bc;
				 fave[bt]++;
				 selector[nSelectors] = (char) bt;
				 nSelectors++;
				 for (i = gs;
				 i <= ge;
				 i++) {
					 rfreq[bt][szptr[i]]++;
				 }
				 gs = ge + 1;
			 }
			 for (t = 0;
			 t < nGroups;
			 t++) {
				 hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);
			 }
		 }
		 rfreq = null;
		 fave = null;
		 cost = null;
		 if (!(nGroups < 8)) {
			 panic();
		 }
		 if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {
			 panic();
		 }
		 {
			 char[] pos = new char[N_GROUPS];
			 char ll_i, tmp2, tmp;
			 for (i = 0;
			 i < nGroups;
			 i++) {
				 pos[i] = (char) i;
			 }
			 for (i = 0;
			 i < nSelectors;
			 i++) {
				 ll_i = selector[i];
				 j = 0;
				 tmp = pos[j];
				 while (ll_i != tmp) {
					 j++;
					 tmp2 = tmp;
					 tmp = pos[j];
					 pos[j] = tmp2;
				 }
				 pos[0] = tmp;
				 selectorMtf[i] = (char) j;
			 }
		 }
		 int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 for (t = 0;
		 t < nGroups;
		 t++) {
			 minLen = 32;
			 maxLen = 0;
			 for (i = 0;
			 i < alphaSize;
			 i++) {
				 if (len[t][i] > maxLen) {
					 maxLen = len[t][i];
				 }
				 if (len[t][i] < minLen) {
					 minLen = len[t][i];
				 }
			 }
			 if (maxLen > 20) {
				 panic();
			 }
			 if (minLen < 1) {
				 panic();
			 }
			 hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);
		 }
		 {
			 boolean[] inUse16 = new boolean[16];
			 for (i = 0;
			 i < 16;
			 i++) {
				 inUse16[i] = false;
				 for (j = 0;
				 j < 16;
				 j++) {
					 if (inUse[i * 16 + j]) {
						 inUse16[i] = true;
					 }
				 }
			 }
			 nBytes = bytesOut;
			 for (i = 0;
			 i < 16;
			 i++) {
				 if (inUse16[i]) {
					 bsW(1, 1);
				 }
				 else {
					 bsW(1, 0);
				 }
			 }
			 for (i = 0;
			 i < 16;
			 i++) {
				 if (inUse16[i]) {
					 for (j = 0;
					 j < 16;
					 j++) {
						 if (inUse[i * 16 + j]) {
							 bsW(1, 1);
						 }
						 else {
							 bsW(1, 0);
						 }
					 }
				 }
			 }
		 }
		 nBytes = bytesOut;
		 bsW (3, nGroups);
		 bsW (15, nSelectors);
		 for (i = 0;
		 i < nSelectors;
		 i++) {
			 for (j = 0;
			 j < selectorMtf[i];
			 j++) {
				 bsW(1, 1);
			 }
			 bsW(1, 0);
		 }
		 nBytes = bytesOut;
		 for (t = 0;
		 t < nGroups;
		 t++) {
			 int curr = len[t][0];
			 bsW(5, curr);
			 for (i = 0;
			 i < alphaSize;
			 i++) {
				 while (curr < len[t][i]) {
					 bsW(2, 2);
					 curr++;
				 }
				 while (curr > len[t][i]) {
					 bsW(2, 3);
					 curr--;
				 }
				 bsW (1, 0);
			 }
		 }
		 nBytes = bytesOut;
		 selCtr = 0;
		 gs = 0;
		 while (true) {
			 if (gs >= nMTF) {
				 break;
			 }
			 ge = gs + G_SIZE - 1;
			 if (ge >= nMTF) {
				 ge = nMTF - 1;
			 }
			 for (i = gs;
			 i <= ge;
			 i++) {
				 bsW(len[selector[selCtr]][szptr[i]], code[selector[selCtr]][szptr[i]]);
			 }
			 gs = ge + 1;
			 selCtr++;
		 }
		 if (!(selCtr == nSelectors)) {
			 panic();
		 }
	 }
	 private void moveToFrontCodeAndSend () throws IOException {
		 bsPutIntVS(24, origPtr);
		 generateMTFValues();
		 sendMTFValues();
	 }
	 private OutputStream bsStream;
	 private void simpleSort(int lo, int hi, int d) {
		 int i, j, h, bigN, hp;
		 int v;
		 bigN = hi - lo + 1;
		 if (bigN < 2) {
			 return;
		 }
		 hp = 0;
		 while (incs[hp] < bigN) {
			 hp++;
		 }
		 hp--;
		 for (;
		 hp >= 0;
		 hp--) {
			 h = incs[hp];
			 i = lo + h;
			 while (true) {
				 if (i > hi) {
					 break;
				 }
				 v = zptr[i];
				 j = i;
				 while (fullGtU(zptr[j - h] + d, v + d)) {
					 zptr[j] = zptr[j - h];
					 j = j - h;
					 if (j <= (lo + h - 1)) {
						 break;
					 }
				 }
				 zptr[j] = v;
				 i++;
				 if (i > hi) {
					 break;
				 }
				 v = zptr[i];
				 j = i;
				 while (fullGtU(zptr[j - h] + d, v + d)) {
					 zptr[j] = zptr[j - h];
					 j = j - h;
					 if (j <= (lo + h - 1)) {
						 break;
					 }
				 }
				 zptr[j] = v;
				 i++;
				 if (i > hi) {
					 break;
				 }
				 v = zptr[i];
				 j = i;
				 while (fullGtU(zptr[j - h] + d, v + d)) {
					 zptr[j] = zptr[j - h];
					 j = j - h;
					 if (j <= (lo + h - 1)) {
						 break;
					 }
				 }
				 zptr[j] = v;
				 i++;
				 if (workDone > workLimit && firstAttempt) {
					 return;
				 }
			 }
		 }
	 }
	 private void vswap(int p1, int p2, int n) {
		 int temp = 0;
		 while (n > 0) {
			 temp = zptr[p1];
			 zptr[p1] = zptr[p2];
			 zptr[p2] = temp;
			 p1++;
			 p2++;
			 n--;
		 }
	 }
	 private char med3(char a, char b, char c) {
		 char t;
		 if (a > b) {
			 t = a;
			 a = b;
			 b = t;
		 }
		 if (b > c) {
			 t = b;
			 b = c;
			 c = t;
		 }
		 if (a > b) {
			 b = a;
		 }
		 return b;
	 }
	 private static class StackElem {
		 int ll;
		 int hh;
		 int dd;
	 }
	 private void qSort3(int loSt, int hiSt, int dSt) {
		 int unLo, unHi, ltLo, gtHi, med, n, m;
		 int sp, lo, hi, d;
		 StackElem[] stack = new StackElem[QSORT_STACK_SIZE];
		 for (int count = 0;
		 count < QSORT_STACK_SIZE;
		 count++) {
			 stack[count] = new StackElem();
		 }
		 sp = 0;
		 stack[sp].ll = loSt;
		 stack[sp].hh = hiSt;
		 stack[sp].dd = dSt;
		 sp++;
		 while (sp > 0) {
			 if (sp >= QSORT_STACK_SIZE) {
				 panic();
			 }
			 sp--;
			 lo = stack[sp].ll;
			 hi = stack[sp].hh;
			 d = stack[sp].dd;
			 if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {
				 simpleSort(lo, hi, d);
				 if (workDone > workLimit && firstAttempt) {
					 return;
				 }
				 continue;
			 }
			 med = med3(block[zptr[lo] + d + 1], block[zptr[hi ] + d + 1], block[zptr[(lo + hi) >> 1] + d + 1]);
			 unLo = ltLo = lo;
			 unHi = gtHi = hi;
			 while (true) {
				 while (true) {
					 if (unLo > unHi) {
						 break;
					 }
					 n = ((int) block[zptr[unLo] + d + 1]) - med;
					 if (n == 0) {
						 int temp = 0;
						 temp = zptr[unLo];
						 zptr[unLo] = zptr[ltLo];
						 zptr[ltLo] = temp;
						 ltLo++;
						 unLo++;
						 continue;
					 }
					;
					 if (n > 0) {
						 break;
					 }
					 unLo++;
				 }
				 while (true) {
					 if (unLo > unHi) {
						 break;
					 }
					 n = ((int) block[zptr[unHi] + d + 1]) - med;
					 if (n == 0) {
						 int temp = 0;
						 temp = zptr[unHi];
						 zptr[unHi] = zptr[gtHi];
						 zptr[gtHi] = temp;
						 gtHi--;
						 unHi--;
						 continue;
					 }
					;
					 if (n < 0) {
						 break;
					 }
					 unHi--;
				 }
				 if (unLo > unHi) {
					 break;
				 }
				 int temp = 0;
				 temp = zptr[unLo];
				 zptr[unLo] = zptr[unHi];
				 zptr[unHi] = temp;
				 unLo++;
				 unHi--;
			 }
			 if (gtHi < ltLo) {
				 stack[sp].ll = lo;
				 stack[sp].hh = hi;
				 stack[sp].dd = d + 1;
				 sp++;
				 continue;
			 }
			 n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
			 vswap(lo, unLo - n, n);
			 m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
			 vswap(unLo, hi - m + 1, m);
			 n = lo + unLo - ltLo - 1;
			 m = hi - (gtHi - unHi) + 1;
			 stack[sp].ll = lo;
			 stack[sp].hh = n;
			 stack[sp].dd = d;
			 sp++;
			 stack[sp].ll = n + 1;
			 stack[sp].hh = m - 1;
			 stack[sp].dd = d + 1;
			 sp++;
			 stack[sp].ll = m;
			 stack[sp].hh = hi;
			 stack[sp].dd = d;
			 sp++;
		 }
	 }
	 private void mainSort() {
		 int i, j, ss, sb;
		 int[] runningOrder = new int[256];
		 int[] copy = new int[256];
		 boolean[] bigDone = new boolean[256];
		 int c1, c2;
		 int numQSorted;
		 for (i = 0;
		 i < NUM_OVERSHOOT_BYTES;
		 i++) {
			 block[last + i + 2] = block[(i % (last + 1)) + 1];
		 }
		 for (i = 0;
		 i <= last + NUM_OVERSHOOT_BYTES;
		 i++) {
			 quadrant[i] = 0;
		 }
		 block[0] = (char) (block[last + 1]);
		 if (last < 4000) {
			 for (i = 0;
			 i <= last;
			 i++) {
				 zptr[i] = i;
			 }
			 firstAttempt = false;
			 workDone = workLimit = 0;
			 simpleSort(0, last, 0);
		 }
		 else {
			 numQSorted = 0;
			 for (i = 0;
			 i <= 255;
			 i++) {
				 bigDone[i] = false;
			 }
			 for (i = 0;
			 i <= 65536;
			 i++) {
				 ftab[i] = 0;
			 }
			 c1 = block[0];
			 for (i = 0;
			 i <= last;
			 i++) {
				 c2 = block[i + 1];
				 ftab[(c1 << 8) + c2]++;
				 c1 = c2;
			 }
			 for (i = 1;
			 i <= 65536;
			 i++) {
				 ftab[i] += ftab[i - 1];
			 }
			 c1 = block[1];
			 for (i = 0;
			 i < last;
			 i++) {
				 c2 = block[i + 2];
				 j = (c1 << 8) + c2;
				 c1 = c2;
				 ftab[j]--;
				 zptr[ftab[j]] = i;
			 }
			 j = ((block[last + 1]) << 8) + (block[1]);
			 ftab[j]--;
			 zptr[ftab[j]] = last;
			 for (i = 0;
			 i <= 255;
			 i++) {
				 runningOrder[i] = i;
			 }
			 {
				 int vv;
				 int h = 1;
				 do {
					 h = 3 * h + 1;
				 }
				 while (h <= 256);
				 do {
					 h = h / 3;
					 for (i = h;
					 i <= 255;
					 i++) {
						 vv = runningOrder[i];
						 j = i;
						 while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {
							 runningOrder[j] = runningOrder[j - h];
							 j = j - h;
							 if (j <= (h - 1)) {
								 break;
							 }
						 }
						 runningOrder[j] = vv;
					 }
				 }
				 while (h != 1);
			 }
			 for (i = 0;
			 i <= 255;
			 i++) {
				 ss = runningOrder[i];
				 for (j = 0;
				 j <= 255;
				 j++) {
					 sb = (ss << 8) + j;
					 if (!((ftab[sb] & SETMASK) == SETMASK)) {
						 int lo = ftab[sb] & CLEARMASK;
						 int hi = (ftab[sb + 1] & CLEARMASK) - 1;
						 if (hi > lo) {
							 qSort3(lo, hi, 2);
							 numQSorted += (hi - lo + 1);
							 if (workDone > workLimit && firstAttempt) {
								 return;
							 }
						 }
						 ftab[sb] |= SETMASK;
					 }
				 }
				 bigDone[ss] = true;
				 if (i < 255) {
					 int bbStart = ftab[ss << 8] & CLEARMASK;
					 int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
					 int shifts = 0;
					 while ((bbSize >> shifts) > 65534) {
						 shifts++;
					 }
					 for (j = 0;
					 j < bbSize;
					 j++) {
						 int a2update = zptr[bbStart + j];
						 int qVal = (j >> shifts);
						 quadrant[a2update] = qVal;
						 if (a2update < NUM_OVERSHOOT_BYTES) {
							 quadrant[a2update + last + 1] = qVal;
						 }
					 }
					 if (!(((bbSize - 1) >> shifts) <= 65535)) {
						 panic();
					 }
				 }
				 for (j = 0;
				 j <= 255;
				 j++) {
					 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
				 }
				 for (j = ftab[ss << 8] & CLEARMASK;
				 j < (ftab[(ss + 1) << 8] & CLEARMASK);
				 j++) {
					 c1 = block[zptr[j]];
					 if (!bigDone[c1]) {
						 zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;
						 copy[c1]++;
					 }
				 }
				 for (j = 0;
				 j <= 255;
				 j++) {
					 ftab[(j << 8) + ss] |= SETMASK;
				 }
			 }
		 }
	 }
	 private void randomiseBlock() {
		 int i;
		 int rNToGo = 0;
		 int rTPos = 0;
		 for (i = 0;
		 i < 256;
		 i++) {
			 inUse[i] = false;
		 }
		 for (i = 0;
		 i <= last;
		 i++) {
			 if (rNToGo == 0) {
				 rNToGo = (char) rNums[rTPos];
				 rTPos++;
				 if (rTPos == 512) {
					 rTPos = 0;
				 }
			 }
			 rNToGo--;
			 block[i + 1] ^= ((rNToGo == 1) ? 1 : 0);
			 block[i + 1] &= 0xFF;
			 inUse[block[i + 1]] = true;
		 }
	 }
	 private void doReversibleTransformation() {
		 int i;
		 workLimit = workFactor * last;
		 workDone = 0;
		 blockRandomised = false;
		 firstAttempt = true;
		 mainSort();
		 if (workDone > workLimit && firstAttempt) {
			 randomiseBlock();
			 workLimit = workDone = 0;
			 blockRandomised = true;
			 firstAttempt = false;
			 mainSort();
		 }
		 origPtr = -1;
		 for (i = 0;
		 i <= last;
		 i++) {
			 if (zptr[i] == 0) {
				 origPtr = i;
				 break;
			 }
		 }
		;
		 if (origPtr == -1) {
			 panic();
		 }
	 }
	 private boolean fullGtU(int i1, int i2) {
		 int k;
		 char c1, c2;
		 int s1, s2;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 k = last + 1;
		 do {
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 if (i1 > last) {
				 i1 -= last;
				 i1--;
			 }
			;
			 if (i2 > last) {
				 i2 -= last;
				 i2--;
			 }
			;
			 k -= 4;
			 workDone++;
		 }
		 while (k >= 0);
		 return false;
	 }
	 private int[] incs = {
	1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484}
	;
	 private void allocateCompressStructures () {
		 int n = baseBlockSize * blockSize100k;
		 block = new char[(n + 1 + NUM_OVERSHOOT_BYTES)];
		 quadrant = new int[(n + NUM_OVERSHOOT_BYTES)];
		 zptr = new int[n];
		 ftab = new int[65537];
		 if (block == null || quadrant == null || zptr == null || ftab == null) {
		 }
		 szptr = new short[2 * n];
	 }
	 private void generateMTFValues() {
		 char[] yy = new char[256];
		 int i, j;
		 char tmp;
		 char tmp2;
		 int zPend;
		 int wr;
		 int EOB;
		 makeMaps();
		 EOB = nInUse + 1;
		 for (i = 0;
		 i <= EOB;
		 i++) {
			 mtfFreq[i] = 0;
		 }
		 wr = 0;
		 zPend = 0;
		 for (i = 0;
		 i < nInUse;
		 i++) {
			 yy[i] = (char) i;
		 }
		 for (i = 0;
		 i <= last;
		 i++) {
			 char ll_i;
			 ll_i = unseqToSeq[block[zptr[i]]];
			 j = 0;
			 tmp = yy[j];
			 while (ll_i != tmp) {
				 j++;
				 tmp2 = tmp;
				 tmp = yy[j];
				 yy[j] = tmp2;
			 }
			;
			 yy[0] = tmp;
			 if (j == 0) {
				 zPend++;
			 }
			 else {
				 if (zPend > 0) {
					 zPend--;
					 while (true) {
						 switch (zPend % 2) {
							 case 0: szptr[wr] = (short) RUNA;
							 wr++;
							 mtfFreq[RUNA]++;
							 break;
							 case 1: szptr[wr] = (short) RUNB;
							 wr++;
							 mtfFreq[RUNB]++;
							 break;
						 }
						;
						 if (zPend < 2) {
							 break;
						 }
						 zPend = (zPend - 2) / 2;
					 }
					;
					 zPend = 0;
				 }
				 szptr[wr] = (short) (j + 1);
				 wr++;
				 mtfFreq[j + 1]++;
			 }
		 }
		 if (zPend > 0) {
			 zPend--;
			 while (true) {
				 switch (zPend % 2) {
					 case 0: szptr[wr] = (short) RUNA;
					 wr++;
					 mtfFreq[RUNA]++;
					 break;
					 case 1: szptr[wr] = (short) RUNB;
					 wr++;
					 mtfFreq[RUNB]++;
					 break;
				 }
				 if (zPend < 2) {
					 break;
				 }
				 zPend = (zPend - 2) / 2;
			 }
		 }
		 szptr[wr] = (short) EOB;
		 wr++;
		 mtfFreq[EOB]++;
		 nMTF = wr;
	 }
}",1,0,0,0
"public static class Builder implements Interceptor.Builder {
	 private Pattern regex;
	 private boolean excludeEvents;
	 public void configure(Context context) {
		 String regexString = context.getString(REGEX, DEFAULT_REGEX);
		 regex = Pattern.compile(regexString);
		 excludeEvents = context.getBoolean(EXCLUDE_EVENTS, DEFAULT_EXCLUDE_EVENTS);
	 }
	 public Interceptor build() {
		 logger.info(String.format( ""Creating RegexFilteringInterceptor: regex=%s,excludeEvents=%s"", regex, excludeEvents));
		 return new RegexFilteringInterceptor(regex, excludeEvents);
	 }
 }",0,0,0,0
"public class BaseClassInfo {
	 protected String name;
	 protected String nameAndLoader;
	 protected int classLoaderId;
	 private int instrClassId;
	 public BaseClassInfo(String className, int classLoaderId) {
		 this.name = className.intern();
		 this.classLoaderId = classLoaderId;
		 nameAndLoader = (name + ""#"" + classLoaderId).intern();
		 instrClassId = -1;
	 }
	 public void setInstrClassId(int id) {
		 instrClassId = id;
	 }
	 public int getInstrClassId() {
		 return instrClassId;
	 }
	 public void setLoaderId(int loaderId) {
		 classLoaderId = loaderId;
	 }
	 public int getLoaderId() {
		 return classLoaderId;
	 }
	 public String getName() {
		 return name;
	 }
	 public String getNameAndLoader() {
		 return nameAndLoader;
	 }
	 public String toString() {
		 return name;
	 }
}",0,1,0,0
"public class DataGraphLayoutCache extends GraphLayoutCache implements GraphModelListener {
	public DataGraphLayoutCache() {
		this(new DefaultGraphModel(), new DefaultCellViewFactory());
	}
	public DataGraphLayoutCache(GraphModel model, CellViewFactory factory) {
		this(model, factory, false);
	}
	public DataGraphLayoutCache(GraphModel model, CellViewFactory factory,boolean partial) {
		this(model, factory, null, null, partial);
	}
	public DataGraphLayoutCache(GraphModel model, CellViewFactory factory,CellView[] cellViews, CellView[] hiddenCellViews, boolean partial) {
		super(model, factory, cellViews, hiddenCellViews, partial);
		if (this.graphModel != null) {
			graphModel.addGraphModelListener(this);
		}
	}
	public void graphChanged(GraphModelEvent e) {
		graphChanged(e.getChange());
	}
}",1,0,0,0
"public class Buffer extends JEditBuffer{
	public static final String BACKED_UP = ""Buffer__backedUp"";
	public static final String CARET = ""Buffer__caret"";
	public static final String SELECTION = ""Buffer__selection"";
	public static final String SCROLL_VERT = ""Buffer__scrollVert"";
	public static final String SCROLL_HORIZ = ""Buffer__scrollHoriz"";
	public static final String ENCODING_AUTODETECT = ""encodingAutodetect"";
	public static final String TRAILING_EOL = ""trailingEOL"";
	public static final String GZIPPED = ""gzipped"";
	public void reload(View view){
		if(isDirty()){
			String[] args = {
			 path }
			;
			int result = GUIUtilities.confirm(view,""changedreload"",args,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)return;
		}
		view.getEditPane().saveCaretInfo();
		load(view,true);
	}
	 public boolean load(final View view, final boolean reload){
		if(isPerformingIO()){
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);
		setLoading(true);
		if(!getFlag(TEMPORARY))EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));
		final boolean loadAutosave;
		if(reload || !getFlag(NEW_FILE)){
			if(file != null)modTime = file.lastModified();
			if(!reload && autosaveFile != null && autosaveFile.exists())loadAutosave = recoverAutosave(view);
			else{
				if(autosaveFile != null)autosaveFile.delete();
				loadAutosave = false;
			}
			if(!loadAutosave){
				VFS vfs = VFSManager.getVFSForPath(path);
				if(!checkFileForLoad(view,vfs,path)){
					setLoading(false);
					return false;
				}
				if(reload || !getFlag(NEW_FILE)){
					if(!vfs.load(view,this,path)){
						setLoading(false);
						return false;
					}
				}
			}
		}
		elseloadAutosave = false;
		Runnable runnable = new Runnable(){
			public void run(){
				String newPath = getStringProperty(BufferIORequest.NEW_PATH);
				Segment seg = (Segment)getProperty(BufferIORequest.LOAD_DATA);
				IntegerArray endOffsets = (IntegerArray)getProperty(BufferIORequest.END_OFFSETS);
				loadText(seg,endOffsets);
				unsetProperty(BufferIORequest.LOAD_DATA);
				unsetProperty(BufferIORequest.END_OFFSETS);
				unsetProperty(BufferIORequest.NEW_PATH);
				undoMgr.clear();
				undoMgr.setLimit(jEdit.getIntegerProperty(""buffer.undoCount"",100));
				if(!getFlag(TEMPORARY))finishLoading();
				setLoading(false);
				if(reload)setDirty(false);
				if(!loadAutosave && newPath != null)setPath(newPath);
				if(loadAutosave)Buffer.super.setDirty(true);
				if(!getFlag(TEMPORARY)){
					fireBufferLoaded();
					EditBus.send(new BufferUpdate(Buffer.this,view,BufferUpdate.LOADED));
				}
			}
		}
		;
		 if(getFlag(TEMPORARY))runnable.run();
		elseVFSManager.runInAWTThread(runnable);
		return true;
	}
	 public boolean insertFile(final View view, String path){
		if(isPerformingIO()){
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);
		path = MiscUtilities.constructPath(this.path,path);
		Buffer buffer = jEdit.getBuffer(path);
		if(buffer != null){
			view.getTextArea().setSelectedText(buffer.getText(0,buffer.getLength()));
			return true;
		}
		VFS vfs = VFSManager.getVFSForPath(path);
		return vfs.insert(view,this,path);
	}
	 public void autosave(){
		if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)|| !isDirty() || isPerformingIO())return;
		setFlag(AUTOSAVE_DIRTY,false);
		VFSManager.runInWorkThread(new BufferAutosaveRequest(null,this,null,VFSManager.getFileVFS(),autosaveFile.getPath()));
	}
	 public boolean saveAs(View view, boolean rename){
		String[] files = GUIUtilities.showVFSFileDialog(view,path,VFSBrowser.SAVE_DIALOG,false);
		if(files == null)return false;
		return save(view,files[0],rename);
	}
	 public boolean save(View view, String path){
		return save(view,path,true);
	}
	 public boolean save(final View view, String path, final boolean rename){
		if(isPerformingIO()){
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);
		if(path == null && getFlag(NEW_FILE))return saveAs(view,rename);
		if(path == null && file != null){
			long newModTime = file.lastModified();
			if(newModTime != modTime&& jEdit.getBooleanProperty(""view.checkModStatus"")){
				Object[] args = {
				 this.path }
				;
				int result = GUIUtilities.confirm(view,""filechanged-save"",args,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
				if(result != JOptionPane.YES_OPTION)return false;
			}
		}
		EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));
		setPerformingIO(true);
		final String oldPath = this.path;
		final String oldSymlinkPath = this.symlinkPath;
		final String newPath = (path == null ? this.path : path);
		VFS vfs = VFSManager.getVFSForPath(newPath);
		if(!checkFileForSave(view,vfs,newPath)){
			setPerformingIO(false);
			return false;
		}
		if(!vfs.save(view,this,newPath)){
			setPerformingIO(false);
			return false;
		}
		VFSManager.runInAWTThread(new Runnable(){
			public void run(){
				setPerformingIO(false);
				finishSaving(view,oldPath,oldSymlinkPath,newPath,rename,getBooleanProperty(BufferIORequest.ERROR_OCCURRED));
			}
		}
		);
		return true;
	}
	 public static final int FILE_NOT_CHANGED = 0;
	public static final int FILE_CHANGED = 1;
	public static final int FILE_DELETED = 2;
	public int checkFileStatus(View view){
		if(!isPerformingIO() && file != null && !getFlag(NEW_FILE)){
			boolean newReadOnly = (file.exists() && !file.canWrite());
			if(newReadOnly != isFileReadOnly()){
				setFileReadOnly(newReadOnly);
				EditBus.send(new BufferUpdate(this,null,BufferUpdate.DIRTY_CHANGED));
			}
			long oldModTime = modTime;
			long newModTime = file.lastModified();
			if(newModTime != oldModTime){
				modTime = newModTime;
				if(!file.exists()){
					setFlag(NEW_FILE,true);
					setDirty(true);
					return FILE_DELETED;
				}
				else{
					return FILE_CHANGED;
				}
			}
		}
		return FILE_NOT_CHANGED;
	}
	 public long getLastModified(){
		return modTime;
	}
	 public void setLastModified(long modTime){
		this.modTime = modTime;
	}
	 public VFS getVFS(){
		return VFSManager.getVFSForPath(path);
	}
	 public File getAutosaveFile(){
		return autosaveFile;
	}
	 public String getName(){
		return name;
	}
	 public String getPath(){
		return path;
	}
	 public String getSymlinkPath(){
		return symlinkPath;
	}
	 public String getDirectory(){
		return directory;
	}
	 public boolean isClosed(){
		return getFlag(CLOSED);
	}
	 public boolean isLoaded(){
		return !isLoading();
	}
	 public boolean isNewFile(){
		return getFlag(NEW_FILE);
	}
	 public void setNewFile(boolean newFile){
		setFlag(NEW_FILE,newFile);
		if(!newFile)setFlag(UNTITLED,false);
	}
	 public boolean isUntitled(){
		return getFlag(UNTITLED);
	}
	 public void setDirty(boolean d){
		boolean old_d = isDirty();
		super.setDirty(d);
		boolean editable = isEditable();
		if(d){
			if(editable)setFlag(AUTOSAVE_DIRTY,true);
		}
		else{
			setFlag(AUTOSAVE_DIRTY,false);
			if(autosaveFile != null)autosaveFile.delete();
		}
		if(d != old_d && editable){
			EditBus.send(new BufferUpdate(this,null,BufferUpdate.DIRTY_CHANGED));
		}
	}
	 public boolean isTemporary(){
		return getFlag(TEMPORARY);
	}
	 public Icon getIcon(){
		if(isDirty())return GUIUtilities.loadIcon(""dirty.gif"");
		else if(isReadOnly())return GUIUtilities.loadIcon(""readonly.gif"");
		else if(getFlag(NEW_FILE))return GUIUtilities.loadIcon(""new.gif"");
		elsereturn GUIUtilities.loadIcon(""normal.gif"");
	}
	 public void addBufferChangeListener(BufferChangeListener listener,int priority){
		addBufferListener(new BufferChangeListener.Adapter(listener),priority);
	}
	 public void addBufferChangeListener(BufferChangeListener listener){
		addBufferChangeListener(listener,NORMAL_PRIORITY);
	}
	 public void removeBufferChangeListener(BufferChangeListener listener){
		BufferListener[] listeners = getBufferListeners();
		for(int i = 0;
		 i < listeners.length;
		 i++){
			BufferListener l = listeners[i];
			if(l instanceof BufferChangeListener.Adapter){
				if(((BufferChangeListener.Adapter)l).getDelegate() == listener){
					removeBufferListener(l);
					return;
				}
			}
		}
	}
	 public void propertiesChanged(){
		String folding = getStringProperty(""folding"");
		FoldHandler handler = FoldHandler.getFoldHandler(folding);
		if(handler != null){
			setFoldHandler(handler);
		}
		else{
			if (folding != null)Log.log(Log.WARNING, this, path + "": invalid 'folding' property: "" + folding);
			setFoldHandler(new DummyFoldHandler());
		}
		initIndentRules();
		EditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));
	}
	 public Object getDefaultProperty(String name){
		Object retVal;
		if(mode != null){
			retVal = mode.getProperty((String)name);
			if(retVal == null)return null;
			setDefaultProperty(name,retVal);
			return retVal;
		}
		else{
			String value = jEdit.getProperty(""buffer."" + name);
			if(value == null)return null;
			try{
				retVal = new Integer(value);
			}
			catch(NumberFormatException nf){
				retVal = value;
			}
		}
		return retVal;
	}
	 public void toggleWordWrap(View view){
		String wrap = getStringProperty(""wrap"");
		if(wrap.equals(""none""))wrap = ""soft"";
		else if(wrap.equals(""soft""))wrap = ""hard"";
		else if(wrap.equals(""hard""))wrap = ""none"";
		view.getStatus().setMessageAndClear(jEdit.getProperty(""view.status.wrap-changed"",new String[] {
		wrap }
		));
		setProperty(""wrap"",wrap);
		propertiesChanged();
	}
	 public void toggleLineSeparator(View view){
		String status = null;
		String lineSep = getStringProperty(""lineSeparator"");
		if(""\n"".equals(lineSep)){
			status = ""windows"";
			lineSep = ""\r\n"";
		}
		else if(""\r\n"".equals(lineSep)){
			status = ""mac"";
			lineSep = ""\r"";
		}
		else if(""\r"".equals(lineSep)){
			status = ""unix"";
			lineSep = ""\n"";
		}
		view.getStatus().setMessageAndClear(jEdit.getProperty(""view.status.linesep-changed"",new String[] {
		jEdit.getProperty(""lineSep."" + status) }
		));
		setProperty(""lineSeparator"",lineSep);
		setDirty(true);
		propertiesChanged();
	}
	 public String getContextSensitiveProperty(int offset, String name){
		Object value = super.getContextSensitiveProperty(offset,name);
		if(value == null){
			ParserRuleSet rules = getRuleSetAtOffset(offset);
			value = jEdit.getMode(rules.getModeName()).getProperty(name);
			if(value == null)value = mode.getProperty(name);
		}
		if(value == null)return null;
		elsereturn String.valueOf(value);
	}
	 public Mode getMode(){
		return mode;
	}
	 public void setMode(String mode){
		setMode(jEdit.getMode(mode));
	}
	 public void setMode(Mode mode){
		if(mode == null)throw new NullPointerException(""Mode must be non-null"");
		this.mode = mode;
		textMode = ""text"".equals(mode.getName());
		setTokenMarker(mode.getTokenMarker());
		resetCachedProperties();
		propertiesChanged();
	}
	 public void setMode(){
		String userMode = getStringProperty(""mode"");
		if(userMode != null){
			Mode m = jEdit.getMode(userMode);
			if(m != null){
				setMode(m);
				return;
			}
		}
		String nogzName = name.substring(0,name.length() -(name.endsWith("".gz"") ? 3 : 0));
		Mode[] modes = jEdit.getModes();
		String firstLine = getLineText(0);
		for(int i = modes.length - 1;
		 i >= 0;
		 i--){
			if(modes[i].accept(nogzName,firstLine)){
				setMode(modes[i]);
				return;
			}
		}
		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);
	}
	 public void putProperty(Object name, Object value){
		if(!(name instanceof String))return;
		setProperty((String)name,value);
	}
	 public void putBooleanProperty(String name, boolean value){
		setBooleanProperty(name,value);
	}
	 public static class TokenList extends DefaultTokenHandler{
		public Token getFirstToken(){
			return getTokens();
		}
	}
	public TokenList markTokens(int lineIndex){
		TokenList list = new TokenList();
		markTokens(lineIndex,list);
		return list;
	}
	 public void insertString(int offset, String str, AttributeSet attr){
		insert(offset,str);
	}
	 public File getFile(){
		return file;
	}
	 public Vector getMarkers(){
		return markers;
	}
	 public String getMarkerStatusPrompt(String action){
		return jEdit.getProperty(""view.status."" + action,new String[] {
		 getMarkerNameString() }
		);
	}
	 public String getMarkerNameString(){
		StringBuffer buf = new StringBuffer();
		for(int i = 0;
		 i < markers.size();
		 i++){
			Marker marker = (Marker)markers.elementAt(i);
			if(marker.getShortcut() != '\0'){
				if(buf.length() != 0)buf.append(' ');
				buf.append(marker.getShortcut());
			}
		}
		if(buf.length() == 0)return jEdit.getProperty(""view.status.no-markers"");
		elsereturn buf.toString();
	}
	 public void addOrRemoveMarker(char shortcut, int pos){
		int line = getLineOfOffset(pos);
		if(getMarkerAtLine(line) != null)removeMarker(line);
		elseaddMarker(shortcut,pos);
	}
	 public void addMarker(char shortcut, int pos){
		Marker markerN = new Marker(this,shortcut,pos);
		boolean added = false;
		if(isLoaded()){
			if(jEdit.getBooleanProperty(""persistentMarkers""))setDirty(true);
			markerN.createPosition();
			for(int i = 0;
			 i < markers.size();
			 i++){
				Marker marker = (Marker)markers.elementAt(i);
				if(shortcut != '\0' && marker.getShortcut() == shortcut)marker.setShortcut('\0');
				if(marker.getPosition() == pos){
					markers.removeElementAt(i);
					i--;
				}
			}
			for(int i = 0;
			 i < markers.size();
			 i++){
				Marker marker = (Marker)markers.elementAt(i);
				if(marker.getPosition() > pos){
					markers.insertElementAt(markerN,i);
					added = true;
					break;
				}
			}
		}
		if(!added)markers.addElement(markerN);
		if(isLoaded() && !getFlag(TEMPORARY)){
			EditBus.send(new BufferUpdate(this,null,BufferUpdate.MARKERS_CHANGED));
		}
	}
	 public Marker getMarkerInRange(int start, int end){
		for(int i = 0;
		 i < markers.size();
		 i++){
			Marker marker = (Marker)markers.elementAt(i);
			int pos = marker.getPosition();
			if(pos >= start && pos < end)return marker;
		}
		return null;
	}
	 public Marker getMarkerAtLine(int line){
		for(int i = 0;
		 i < markers.size();
		 i++){
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)return marker;
		}
		return null;
	}
	 public void removeMarker(int line){
		for(int i = 0;
		 i < markers.size();
		 i++){
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line){
				if(jEdit.getBooleanProperty(""persistentMarkers""))setDirty(true);
				marker.removePosition();
				markers.removeElementAt(i);
				i--;
			}
		}
		EditBus.send(new BufferUpdate(this,null,BufferUpdate.MARKERS_CHANGED));
	}
	 public void removeAllMarkers(){
		if(jEdit.getBooleanProperty(""persistentMarkers""))setDirty(true);
		for(int i = 0;
		 i < markers.size();
		 i++)((Marker)markers.elementAt(i)).removePosition();
		markers.removeAllElements();
		if(isLoaded()){
			EditBus.send(new BufferUpdate(this,null,BufferUpdate.MARKERS_CHANGED));
		}
	}
	 public Marker getMarker(char shortcut){
		Enumeration e = markers.elements();
		while(e.hasMoreElements()){
			Marker marker = (Marker)e.nextElement();
			if(marker.getShortcut() == shortcut)return marker;
		}
		return null;
	}
	 public void setWaitSocket(Socket waitSocket){
		this.waitSocket = waitSocket;
	}
	 public Buffer getNext(){
		return next;
	}
	 public Buffer getPrev(){
		return prev;
	}
	 public int getIndex(){
		int count = 0;
		Buffer buffer = prev;
		for(;
		;
		){
			if(buffer == null)break;
			count++;
			buffer = buffer.prev;
		}
		return count;
	}
	 public String toString(){
		return name + "" ("" + directory + "")"";
	}
	 Buffer prev;
	Buffer next;
	Buffer(String path, boolean newFile, boolean temp, Hashtable props){
		super(props);
		markers = new Vector();
		setFlag(TEMPORARY,temp);
		setPath(path);
		setFlag(UNTITLED,newFile);
		setFlag(NEW_FILE,newFile);
	}
	 void commitTemporary(){
		setFlag(TEMPORARY,false);
		finishLoading();
	}
	 void close(){
		setFlag(CLOSED,true);
		if(autosaveFile != null)autosaveFile.delete();
		if(waitSocket != null){
			try{
				waitSocket.getOutputStream().write('\0');
				waitSocket.getOutputStream().flush();
				waitSocket.getInputStream().close();
				waitSocket.getOutputStream().close();
				waitSocket.close();
			}
			catch(IOException io){
			}
		}
	}
	 private void setFlag(int flag, boolean value){
		if(value)flags |= (1 << flag);
		elseflags &= ~(1 << flag);
	}
	 private boolean getFlag(int flag){
		int mask = (1 << flag);
		return (flags & mask) == mask;
	}
	 private static final int CLOSED = 0;
	private static final int NEW_FILE = 3;
	private static final int UNTITLED = 4;
	private static final int AUTOSAVE_DIRTY = 5;
	private static final int TEMPORARY = 10;
	private int flags;
	private String path;
	private String symlinkPath;
	private String name;
	private String directory;
	private File file;
	private File autosaveFile;
	private long modTime;
	private Mode mode;
	private Vector markers;
	private Socket waitSocket;
	private void setPath(String path){
		this.path = path;
		VFS vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)setFileReadOnly(true);
		this.name = vfs.getFileName(path);
		this.directory = vfs.getParentOfPath(path);
		if(vfs instanceof FileVFS){
			file = new File(path);
			symlinkPath = MiscUtilities.resolveSymlinks(path);
			if(autosaveFile != null)autosaveFile.delete();
			autosaveFile = new File(file.getParent(),'#' + name + '#');
		}
		else{
			file = null;
			autosaveFile = null;
			symlinkPath = path;
		}
	}
	 private boolean recoverAutosave(final View view){
		if(!autosaveFile.canRead())return false;
		GUIUtilities.hideSplashScreen();
		final Object[] args = {
		 autosaveFile.getPath() }
		;
		int result = GUIUtilities.confirm(view,""autosave-found"",args,JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
		if(result == JOptionPane.YES_OPTION){
			VFSManager.getFileVFS().load(view,this,autosaveFile.getPath());
			VFSManager.runInAWTThread(new Runnable(){
				public void run(){
					GUIUtilities.message(view,""autosave-loaded"",args);
				}
			}
			);
			return true;
		}
		elsereturn false;
	}
	 private boolean checkFileForLoad(View view, VFS vfs, String path){
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0){
			Object session = vfs.createVFSSession(path,view);
			if(session == null)return false;
			try{
				VFSFile file = vfs._getFile(session,path,view);
				if(file == null){
					setNewFile(true);
					return true;
				}
				if(!file.isReadable()){
					VFSManager.error(view,path,""ioerror.no-read"",null);
					setNewFile(false);
					return false;
				}
				setFileReadOnly(!file.isWriteable());
				if(file.getType() != VFSFile.FILE){
					VFSManager.error(view,path,""ioerror.open-directory"",null);
					setNewFile(false);
					return false;
				}
			}
			catch(IOException io){
				VFSManager.error(view,path,""ioerror"",new String[] {
				 io.toString() }
				);
				return false;
			}
			finally{
				try{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io){
					VFSManager.error(view,path,""ioerror"",new String[] {
					 io.toString() }
					);
					return false;
				}
			}
		}
		return true;
	}
	 private boolean checkFileForSave(View view, VFS vfs, String path){
		if((vfs.getCapabilities() & VFS.LOW_LATENCY_CAP) != 0){
			Object session = vfs.createVFSSession(path,view);
			if(session == null)return false;
			try{
				VFSFile file = vfs._getFile(session,path,view);
				if(file == null)return true;
				if(file.getType() != VFSFile.FILE){
					VFSManager.error(view,path,""ioerror.save-directory"",null);
					return false;
				}
			}
			catch(IOException io){
				VFSManager.error(view,path,""ioerror"",new String[] {
				 io.toString() }
				);
				return false;
			}
			finally{
				try{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io){
					VFSManager.error(view,path,""ioerror"",new String[] {
					 io.toString() }
					);
					return false;
				}
			}
		}
		return true;
	}
	 private void finishLoading(){
		parseBufferLocalProperties();
		FoldHandler oldFoldHandler = getFoldHandler();
		setMode();
		if(getFoldHandler() == oldFoldHandler){
			invalidateFoldLevels();
			fireFoldHandlerChanged();
		}
		for(int i = 0;
		 i < markers.size();
		 i++){
			Marker marker = (Marker)markers.elementAt(i);
			marker.removePosition();
			int pos = marker.getPosition();
			if(pos > getLength())marker.setPosition(getLength());
			else if(pos < 0)marker.setPosition(0);
			marker.createPosition();
		}
	}
	 private void finishSaving(View view, String oldPath,String oldSymlinkPath, String path,boolean rename, boolean error){
		if(!error && !path.equals(oldPath)){
			Buffer buffer = jEdit.getBuffer(path);
			if(rename){
				if(buffer != null && !buffer.getPath().equals(oldPath)){
					buffer.setDirty(false);
					jEdit.closeBuffer(view,buffer);
				}
				setPath(path);
			}
			else{
				if(buffer != null && !buffer.getPath().equals(oldPath)){
					buffer.load(view,true);
				}
			}
		}
		 if(rename){
			if(file != null)modTime = file.lastModified();
			if(!error){
				try{
					writeLock();
					if(autosaveFile != null)autosaveFile.delete();
					setFlag(AUTOSAVE_DIRTY,false);
					setFileReadOnly(false);
					setFlag(NEW_FILE,false);
					setFlag(UNTITLED,false);
					super.setDirty(false);
					undoMgr.bufferSaved();
				}
				finally{
					writeUnlock();
				}
				parseBufferLocalProperties();
				if(!getPath().equals(oldPath)){
					jEdit.updatePosition(oldSymlinkPath,this);
					setMode();
				}
				else{
					String newMode = getStringProperty(""mode"");
					if(newMode != null &&!newMode.equals(getMode().getName()))setMode();
					elsepropertiesChanged();
				}
				EditBus.send(new BufferUpdate(Buffer.this,view,BufferUpdate.DIRTY_CHANGED));
				EditBus.send(new BufferUpdate(Buffer.this,view,BufferUpdate.SAVED));
			}
		}
	 }
 }",1,0,0,0
"public class TableFrameControllerXmlBean{
	 private String schema;
	 private String catalog;
	 private String tablename;
	 private TableFrameXmlBean tableFrameXmlBean;
	 private ColumnInfoXmlBean[] columnIfoXmlBeans;
	 private String[] tablesExportedTo;
	 private ConstraintViewXmlBean[] constraintViewXmlBeans;
	 private int columOrder;
	 public String getSchema() {
		 return schema;
	 }
	 public void setSchema(String schema) {
		 this.schema = schema;
	 }
	 public String getCatalog() {
		 return catalog;
	 }
	 public void setCatalog(String catalog) {
		 this.catalog = catalog;
	 }
	 public String getTablename() {
		 return tablename;
	 }
	 public void setTablename(String tablename) {
		 this.tablename = tablename;
	 }
	 public TableFrameXmlBean getTableFrameXmlBean() {
		 return tableFrameXmlBean;
	 }
	 public void setTableFrameXmlBean(TableFrameXmlBean tableFrameXmlBean) {
		 this.tableFrameXmlBean = tableFrameXmlBean;
	 }
	 public ColumnInfoXmlBean[] getColumnIfoXmlBeans() {
		 return columnIfoXmlBeans;
	 }
	 public void setColumnIfoXmlBeans(ColumnInfoXmlBean[] columnIfoXmlBeans) {
		 this.columnIfoXmlBeans = columnIfoXmlBeans;
	 }
	 public String[] getTablesExportedTo() {
		 return tablesExportedTo;
	 }
	 public void setTablesExportedTo(String[] tablesExportedTo) {
		 this.tablesExportedTo = tablesExportedTo;
	 }
	 public ConstraintViewXmlBean[] getConstraintViewXmlBeans() {
		 return constraintViewXmlBeans;
	 }
	 public void setConstraintViewXmlBeans(ConstraintViewXmlBean[] constraintViewXmlBeans) {
		 this.constraintViewXmlBeans = constraintViewXmlBeans;
	 }
	 public int getColumOrder() {
		 return columOrder;
	 }
	 public void setColumOrder(int columOrder) {
		 this.columOrder = columOrder;
	 }
}",0,1,0,0
"private void log(Operation op, OperationProcessingContext context, String msg, Level logLevel) {
	 String hostId = context.host != null ? context.host.getId() : """";
	 String path = op.getUri() != null ? op.getUri().getPath() : """";
	 Filter filter = this.filters.get(context.currentFilterPosition);
	 String filterName = filter != null ? filter.getClass().getSimpleName() : """";
	 String logMsg = String.format(""(host: %s, op %d %s %s) filter %s: %s"", hostId, op.getId(), op.getAction(), path, filterName, msg);
	 Level level = logLevel != null ? logLevel : Level.INFO;
	 Utils.log(getClass(), op.getUri().getPath(), level, logMsg);
 }",0,0,1,0
"public class GroomServerStatus implements Writable {
	 public static final Log LOG = LogFactory.getLog(GroomServerStatus.class);
	 static {
		 WritableFactories.setFactory(GroomServerStatus.class, new WritableFactory() {
			 public Writable newInstance() {
				 return new GroomServerStatus();
			 }
		 }
		);
	 }
	 String groomName;
	 String rpcServer;
	 String hostName;
	 int failures;
	 List<TaskStatus> taskReports;
	 volatile long lastSeen;
	 private int maxTasks;
	 public GroomServerStatus() {
		 taskReports = new CopyOnWriteArrayList<TaskStatus>();
	 }
	 public GroomServerStatus(String groomName, List<TaskStatus> taskReports, int failures, int maxTasks) {
		 this(groomName, taskReports, failures, maxTasks, """", """");
	 }
	 public GroomServerStatus(String groomName, List<TaskStatus> taskReports, int failures, int maxTasks, String rpc, String hostName) {
		 this.groomName = groomName;
		 this.taskReports = new ArrayList<TaskStatus>(taskReports);
		 this.failures = failures;
		 this.maxTasks = maxTasks;
		 this.rpcServer = rpc;
		 this.hostName = hostName;
	 }
	 public String getGroomName() {
		 return groomName;
	 }
	 public String getGroomHostName() {
		 return hostName;
	 }
	 public String getRpcServer() {
		 return rpcServer;
	 }
	 public List<TaskStatus> getTaskReports() {
		 return taskReports;
	 }
	 public int getFailures() {
		 return failures;
	 }
	 public long getLastSeen() {
		 return lastSeen;
	 }
	 public void setLastSeen(long lastSeen) {
		 this.lastSeen = lastSeen;
	 }
	 public int getMaxTasks() {
		 return maxTasks;
	 }
	 public int countTasks() {
		 int taskCount = 0;
		 for (TaskStatus ts : taskReports) {
			 TaskStatus.State state = ts.getRunState();
			 if (state == TaskStatus.State.RUNNING || state == TaskStatus.State.UNASSIGNED) {
				 taskCount++;
			 }
		 }
		 return taskCount;
	 }
	 public int hashCode() {
		 int result = 17;
		 result = 37 * result + groomName.hashCode();
		 result = 37 * result + rpcServer.hashCode();
		 result = 37 * result + hostName.hashCode();
		 return result;
	 }
	 public boolean equals(Object o) {
		 if (o == this) return true;
		 if (null == o) return false;
		 if (getClass() != o.getClass()) return false;
		 GroomServerStatus s = (GroomServerStatus) o;
		 if (!s.groomName.equals(groomName)) return false;
		 if (!s.rpcServer.equals(rpcServer)) return false;
		 return true;
	 }
	 public void readFields(DataInput in) throws IOException {
		 this.groomName = Text.readString(in);
		 this.rpcServer = Text.readString(in);
		 this.hostName = Text.readString(in);
		 this.failures = in.readInt();
		 this.maxTasks = in.readInt();
		 taskReports.clear();
		 int numTasks = in.readInt();
		 TaskStatus status;
		 for (int i = 0;
		 i < numTasks;
		 i++) {
			 status = new TaskStatus();
			 status.readFields(in);
			 taskReports.add(status);
		 }
	 }
	 public void write(DataOutput out) throws IOException {
		 Text.writeString(out, groomName);
		 Text.writeString(out, rpcServer);
		 Text.writeString(out, hostName);
		 out.writeInt(failures);
		 out.writeInt(maxTasks);
		 out.writeInt(taskReports.size());
		 for (TaskStatus taskStatus : taskReports) {
			 taskStatus.write(out);
		 }
	 }
	 public Iterator<TaskStatus> taskReports() {
		 return taskReports.iterator();
	 }
}",1,1,0,0
"protected void handleFolderOrItem(CaldavRequest request) throws IOException {
	 String lastPath = StringUtil.xmlDecode(request.getLastPath());
	 if (request.isPropFind() && ""inbox"".equals(lastPath)) {
		 sendInbox(request);
	 }
	 else if (request.isPropFind() && ""outbox"".equals(lastPath)) {
		 sendOutbox(request);
	 }
	 else if (request.isPost() && ""outbox"".equals(lastPath)) {
		 if (request.isFreeBusy()) {
			 sendFreeBusy(request.getBody());
		 }
		 else {
			 int status = session.sendEvent(request.getBody());
			 sendHttpResponse(status);
		 }
	 }
	 else if (request.isPropFind()) {
		 sendFolderOrItem(request);
	 }
	 else if (request.isPropPatch()) {
		 patchCalendar(request);
	 }
	 else if (request.isReport()) {
		 reportItems(request);
	 }
	 else if (request.isPut()) {
		 String etag = request.getHeader(""if-match"");
		 String noneMatch = request.getHeader(""if-none-match"");
		 ExchangeSession.ItemResult itemResult = session.createOrUpdateItem(request.getFolderPath(), lastPath, request.getBody(), etag, noneMatch);
		 sendHttpResponse(itemResult.status, buildEtagHeader(itemResult.etag), null, """", true);
	 }
	 else if (request.isDelete()) {
		 if (request.getFolderPath().endsWith(""inbox"")) {
			 session.processItem(request.getFolderPath(), lastPath);
		 }
		 else {
			 session.deleteItem(request.getFolderPath(), lastPath);
		 }
		 sendHttpResponse(HttpStatus.SC_OK);
	 }
	 else if (request.isGet()) {
		 if (request.path.endsWith(""/"")) {
			 String folderPath = request.getFolderPath();
			 ExchangeSession.Folder folder = session.getFolder(folderPath);
			 if (folder.isContact()) {
				 List<ExchangeSession.Contact> contacts = session.getAllContacts(folderPath);
				 ChunkedResponse response = new ChunkedResponse(HttpStatus.SC_OK, ""text/vcard;
				charset=UTF-8"");
				 for (ExchangeSession.Contact contact : contacts) {
					 String contactBody = contact.getBody();
					 if (contactBody != null) {
						 response.append(contactBody);
						 response.append(""\n"");
					 }
				 }
				 response.close();
			 }
			 else if (folder.isCalendar() || folder.isTask()) {
				 List<ExchangeSession.Event> events = session.getAllEvents(folderPath);
				 ChunkedResponse response = new ChunkedResponse(HttpStatus.SC_OK, ""text/calendar;
				charset=UTF-8"");
				 response.append(""BEGIN:VCALENDAR\r\n"");
				 response.append(""VERSION:2.0\r\n"");
				 response.append(""PRODID:- response.append(""METHOD:PUBLISH\r\n"");
				 for (ExchangeSession.Event event : events) {
					 String icsContent = StringUtil.getToken(event.getBody(), ""BEGIN:VTIMEZONE"", ""END:VCALENDAR"");
					 if (icsContent != null) {
						 response.append(""BEGIN:VTIMEZONE"");
						 response.append(icsContent);
					 }
					 else {
						 icsContent = StringUtil.getToken(event.getBody(), ""BEGIN:VEVENT"", ""END:VCALENDAR"");
						 if (icsContent != null) {
							 response.append(""BEGIN:VEVENT"");
							 response.append(icsContent);
						 }
					 }
				 }
				 response.append(""END:VCALENDAR"");
				 response.close();
			 }
			 else {
				 sendHttpResponse(HttpStatus.SC_OK, buildEtagHeader(folder.etag), ""text/html"", (byte[]) null, true);
			 }
		 }
		 else {
			 ExchangeSession.Item item = session.getItem(request.getFolderPath(), lastPath);
			 sendHttpResponse(HttpStatus.SC_OK, buildEtagHeader(item.getEtag()), item.getContentType(), item.getBody(), true);
		 }
	 }
	 else if (request.isHead()) {
		 ExchangeSession.Item item = session.getItem(request.getFolderPath(), lastPath);
		 sendHttpResponse(HttpStatus.SC_OK, buildEtagHeader(item.getEtag()), item.getContentType(), (byte[]) null, true);
	 }
	 else if (request.isMkCalendar()) {
		 HashMap<String, String> properties = new HashMap<String, String>();
		 int status = session.createCalendarFolder(request.getFolderPath(), properties);
		 sendHttpResponse(status, null);
	 }
	 else if (request.isMove()) {
		 String destinationUrl = request.getHeader(""destination"");
		 session.moveItem(request.path, URIUtil.decode(new URL(destinationUrl).getPath()));
		 sendHttpResponse(HttpStatus.SC_CREATED, null);
	 }
	 else {
		 sendUnsupported(request);
	 }
 }",0,0,1,0
"public class N4JSNewProjectWizard extends XtextNewProjectWizard {
	private static final ImageDescriptor NEW_PROJECT_WIZBAN_DESC = ImageRef.NEW_PROJECT_WIZBAN.asImageDescriptor().orNull();
	private static final String DIALOG_SETTINGS_SECTION_KEY = ""org.eclipse.n4js.ui.wizard.project.N4JSNewProjectWizard.dialogSettings"";
	private static final String CREATE_GREETER_SETTINGS_KEY = ""createGreeterFile"";
	private static final String VENDOR_ID_SETTINGS_KEY = ""vendorId"";
	private final N4JSProjectInfo projectInfo;
	private IResourceDescriptions resourceDescriptions;
	private N4JSNewProjectWizardCreationPage newProjectWizardCreationPage;
	public N4JSNewProjectWizard(final IProjectCreator projectCreator) {
		super(projectCreator);
		setWindowTitle(""New N4JS Project"");
		setNeedsProgressMonitor(true);
		setDefaultPageImageDescriptor(NEW_PROJECT_WIZBAN_DESC);
		projectInfo = new N4JSProjectInfo();
		IDialogSettings workbenchDialogSettings = N4JSActivator.getInstance().getDialogSettings();
		IDialogSettings projectWizardSettings = workbenchDialogSettings.getSection(DIALOG_SETTINGS_SECTION_KEY);
		if (null == projectWizardSettings) {
			projectWizardSettings = workbenchDialogSettings.addNewSection(DIALOG_SETTINGS_SECTION_KEY);
		}
		setDialogSettings(projectWizardSettings);
	}
	public void createPageControls(Composite pageContainer) {
		super.createPageControls(pageContainer);
		IDialogSettings dialogSettings = this.getDialogSettings();
		if (null != dialogSettings.get(CREATE_GREETER_SETTINGS_KEY)) {
			projectInfo.setCreateGreeterFile(dialogSettings.getBoolean(CREATE_GREETER_SETTINGS_KEY));
		}
		if (null != dialogSettings.get(VENDOR_ID_SETTINGS_KEY)) {
			projectInfo.setVendorId(dialogSettings.get(VENDOR_ID_SETTINGS_KEY));
		}
	}
	public void addPages() {
		newProjectWizardCreationPage = new N4JSNewProjectWizardCreationPage(projectInfo);
		addPage(newProjectWizardCreationPage);
		addPage(new N4JSTestedProjectWizardPage(projectInfo, resourceDescriptions));
	}
	public boolean performFinish() {
		this.getDialogSettings().put(CREATE_GREETER_SETTINGS_KEY, projectInfo.getCreateGreeterFile());
		this.getDialogSettings().put(VENDOR_ID_SETTINGS_KEY, projectInfo.getVendorId());
		return super.performFinish();
	}
	public boolean canFinish() {
		return (!ProjectType.TEST.equals(projectInfo.getProjectType()) &&newProjectWizardCreationPage.isPageComplete()) || super.canFinish();
	}
	protected IProjectInfo getProjectInfo() {
		newProjectWizardCreationPage.updateSelectedWorkingSets();
		return projectInfo;
	}
}",1,0,0,0
"private void deliverHintsToEndpointInternal(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, InterruptedException {
	 ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
	 if (hintStore.isEmpty()) return;
	 logger_.debug(""Checking remote({
	}
	) schema before delivering hints"", endpoint);
	 try {
		 waitForSchemaAgreement(endpoint);
	 }
	 catch (TimeoutException e) {
		 return;
	 }
	 if (!FailureDetector.instance.isAlive(endpoint)) {
		 logger_.debug(""Endpoint {
		}
		 died before hint delivery, aborting"", endpoint);
		 return;
	 }
	 Token<T> token = StorageService.instance.getTokenMetadata().getToken(endpoint);
	 logger_.info(""Started hinted handoff for token: {
	}
	 with IP: {
	}
	"", token, endpoint);
	 ByteBuffer tokenBytes = StorageService.getPartitioner().getTokenFactory().toByteArray(token);
	 DecoratedKey<T> epkey = StorageService.getPartitioner().decorateKey(tokenBytes);
	 int rowsReplayed = 0;
	 ByteBuffer startColumn = ByteBufferUtil.EMPTY_BYTE_BUFFER;
	 int pageSize = PAGE_SIZE;
	 if (hintStore.getMeanColumns() > 0) {
		 int averageColumnSize = (int) (hintStore.getMeanRowSize() / hintStore.getMeanColumns());
		 pageSize = Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize);
		 pageSize = Math.max(2, pageSize);
		 logger_.debug(""average hinted-row column size is {
		}
		;
		 using pageSize of {
		}
		"", averageColumnSize, pageSize);
	 }
	 delivery: while (true) {
		 QueryFilter filter = QueryFilter.getSliceFilter(epkey, new QueryPath(HINTS_CF), startColumn, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, pageSize);
		 ColumnFamily hintsPage = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), (int)(System.currentTimeMillis() / 1000));
		 if (pagingFinished(hintsPage, startColumn)) break;
		 page: for (IColumn hint : hintsPage.getSortedColumns()) {
			 startColumn = hint.name();
			 for (IColumn subColumn : hint.getSubColumns()) {
				 if (ByteBufferUtil.string(subColumn.name()).contains(SEPARATOR_08)) {
					 logger_.debug(""0.8-style hint found. This should have been taken care of by purgeIncompatibleHints"");
					 deleteHint(tokenBytes, hint.name(), hint.maxTimestamp());
					 continue page;
				 }
			 }
			 IColumn versionColumn = hint.getSubColumn(ByteBufferUtil.bytes(""version""));
			 IColumn tableColumn = hint.getSubColumn(ByteBufferUtil.bytes(""table""));
			 IColumn keyColumn = hint.getSubColumn(ByteBufferUtil.bytes(""key""));
			 IColumn mutationColumn = hint.getSubColumn(ByteBufferUtil.bytes(""mutation""));
			 assert versionColumn != null;
			 assert tableColumn != null;
			 assert keyColumn != null;
			 assert mutationColumn != null;
			 DataInputStream in = new DataInputStream(ByteBufferUtil.inputStream(mutationColumn.value()));
			 RowMutation rm;
			 try {
				 rm = RowMutation.serializer().deserialize(in, ByteBufferUtil.toInt(versionColumn.value()));
			 }
			 catch (UnknownColumnFamilyException e) {
				 logger_.debug(""Skipping delivery of hint for deleted columnfamily"", e);
				 rm = null;
			 }
			 try {
				 if (rm != null) {
					 sendMutation(endpoint, rm);
					 rowsReplayed++;
				 }
				 deleteHint(tokenBytes, hint.name(), hint.maxTimestamp());
			 }
			 catch (TimeoutException e) {
				 logger_.info(String.format(""Timed out replaying hints to %s;
				 aborting further deliveries"", endpoint));
				 break delivery;
			 }
		 }
	 }
	 if (rowsReplayed > 0) {
		 try {
			 compact().get();
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 logger_.info(String.format(""Finished hinted handoff of %s rows to endpoint %s"", rowsReplayed, endpoint));
 }",0,0,1,0
"public class UnitLocation implements Serializable {
	 private static final long serialVersionUID = 3989732522854387850L;
	 private final int entityId;
	 private final Coords coords;
	 private final int facing;
	 private final int elevation;
	 public UnitLocation(int id, Coords coords, int facing, int elevation) {
		 this.entityId = id;
		 this.coords = coords;
		 this.facing = facing;
		 this.elevation = elevation;
	 }
	 public int getId() {
		 return entityId;
	 }
	 public Coords getCoords() {
		 return coords;
	 }
	 public int getFacing() {
		 return facing;
	 }
	 public int getElevation() {
		 return elevation;
	 }
}",0,1,0,0
"public class FastRTrace {
	 static final class Helper extends RBaseNode {
		 private GetFunctions.Get getNode;
		 private EnvFunctions.TopEnv topEnv;
		 private FrameFunctions.ParentFrame parentFrame;
		 protected Object getWhere(VirtualFrame frame) {
			 if (topEnv == null) {
				 CompilerDirectives.transferToInterpreterAndInvalidate();
				 topEnv = insert(TopEnvNodeGen.create());
			 }
			 if (parentFrame == null) {
				 CompilerDirectives.transferToInterpreterAndInvalidate();
				 parentFrame = insert(ParentFrameNodeGen.create());
			 }
			 return topEnv.execute(frame, parentFrame.execute(frame, 1), RNull.instance);
		 }
		 protected Object getFunction(VirtualFrame frame, Object what, Object where) {
			 if (getNode == null) {
				 CompilerDirectives.transferToInterpreterAndInvalidate();
				 getNode = insert(GetNodeGen.create());
			 }
			 return getNode.execute(frame, what, where, RType.Function.getName(), true);
		 }
		 protected void checkWhat(Object what) {
			 if (what == RMissing.instance) {
				 throw error(RError.Message.ARGUMENT_MISSING, ""what"");
			 }
		 }
		 protected RFunction checkFunction(Object what) {
			 if (what instanceof RFunction) {
				 RFunction func = (RFunction) what;
				 if (func.isBuiltin()) {
					 throw error(RError.Message.GENERIC, ""builtin functions cannot be traced"");
				 }
				 else {
					 return func;
				 }
			 }
			 else {
				 throw error(RError.Message.ARG_MUST_BE_CLOSURE);
			 }
		 }
	 }
	 public abstract static class Trace extends RBuiltinNode.Arg7 {
		 private TraceFunctions.PrimTrace primTrace;
		 private CastLogicalNode castLogical;
		 private SetVisibilityNode visibility = SetVisibilityNode.create();
		 private Helper helper = new Helper();
		 static {
			 Casts.noCasts(Trace.class);
		 }
		 protected Object trace(VirtualFrame frame, Object whatObj, Object tracer, Object exit, Object at, Object printObj, Object signature, Object whereObj) {
			 Object what = whatObj;
			 helper.checkWhat(what);
			 Object where = whereObj;
			 if (where == RMissing.instance) {
				 where = helper.getWhere(frame);
			 }
			 String funcName = RRuntime.asString(what);
			 if (funcName != null) {
				 what = helper.getFunction(frame, what, where);
			 }
			 RFunction func = helper.checkFunction(what);
			 if (tracer == RMissing.instance && exit == RMissing.instance && at == RMissing.instance && printObj == RMissing.instance && signature == RMissing.instance) {
				 if (primTrace == null) {
					 CompilerDirectives.transferToInterpreterAndInvalidate();
					 primTrace = insert(PrimTraceNodeGen.create());
				 }
				 Object result = primTrace.execute(frame, func);
				 visibility.execute(frame, false);
				 return result;
			 }
			 if (at != RMissing.instance) {
				 throw RError.nyi(this, ""'at'"");
			 }
			 boolean print = true;
			 if (printObj != RMissing.instance) {
				 if (castLogical == null) {
					 CompilerDirectives.transferToInterpreterAndInvalidate();
					 castLogical = insert(CastLogicalNodeGen.create(false, false, false));
				 }
				 print = RRuntime.fromLogical((byte) castLogical.doCast(printObj));
			 }
			 complexCase(func, tracer, exit, at, print, signature);
			 visibility.execute(frame, true);
			 return Utils.toString(func);
		 }
		 private void complexCase(RFunction func, Object tracerObj, Object exit, Object at, boolean print, Object signature) {
			 RPairList tracer;
			 if (tracerObj instanceof RFunction) {
				 Closure closure = Closure.createLanguageClosure(RASTUtils.createCall(tracerObj, false, ArgumentsSignature.empty(0)).asRNode());
				 tracer = RDataFactory.createLanguage(closure);
			 }
			 else if ((tracerObj instanceof RPairList && ((RPairList) tracerObj).isLanguage())) {
				 tracer = (RPairList) tracerObj;
			 }
			 else {
				 throw error(RError.Message.GENERIC, ""tracer is unexpected type"");
			 }
			 TraceHandling.enableStatementTrace(func, tracer, at, print);
		 }
	 }
	 public abstract static class Untrace extends RBuiltinNode.Arg3 {
		 private TraceFunctions.PrimUnTrace primUnTrace;
		 private Helper helper = new Helper();
		 static {
			 Casts.noCasts(Untrace.class);
		 }
		 protected Object untrace(VirtualFrame frame, Object whatObj, Object signature, Object whereObj) {
			 Object what = whatObj;
			 helper.checkWhat(what);
			 Object where = whereObj;
			 if (where == RMissing.instance) {
				 where = helper.getWhere(frame);
			 }
			 String funcName = RRuntime.asString(what);
			 if (funcName != null) {
				 what = helper.getFunction(frame, what, where);
			 }
			 RFunction func = helper.checkFunction(what);
			 if (signature == RMissing.instance) {
				 if (primUnTrace == null) {
					 CompilerDirectives.transferToInterpreterAndInvalidate();
					 primUnTrace = insert(PrimUnTraceNodeGen.create());
				 }
				 primUnTrace.execute(frame, func);
			 }
			 else {
				 throw RError.nyi(this, ""method tracing"");
			 }
			 return Utils.toString(func);
		 }
	 }
}",1,0,0,0
"private Object getApplicationToRun(String[] args) throws CoreException {
	 String configuredApplication = getConfiguredApplication(args);
	 if (configuredApplication == null) {
		 configuredApplication = DEFAULT_APP_3_0;
	 }
	 else {
		 System.out.println(""Launching application "" + configuredApplication + ""..."");
	 }
	 IExtension extension = Platform.getExtensionRegistry().getExtension(Platform.PI_RUNTIME, Platform.PT_APPLICATIONS, configuredApplication);
	 if (extension == null) {
		 return null;
	 }
	 IConfigurationElement[] elements = extension.getConfigurationElements();
	 if (elements.length > 0) {
		 IConfigurationElement[] runs = elements[0].getChildren(""run"");
		 if (runs.length > 0) {
			 return runs[0].createExecutableExtension(""class"");
		 }
	 }
	 return null;
 }",0,0,1,0
"private Outlink[] getOutlinksJakartaRegexpImpl(final String plainText) {
	 throw new UnsupportedOperationException( ""Implementation commented out. Please uncomment to use it."");
 }",0,0,0,0
"static class JobDefinitionLocator extends JobSpecificationVisitor<Object> {
	List<JobDefinition> jobDefinitions = new ArrayList<JobDefinition>();
	public List<JobDefinition> getJobDefinitions() {
		return jobDefinitions;
	}
	public Object walk(Object context, Flow sjs) {
		for (JobNode jobNode : sjs.getSeries()) {
			walk(context, jobNode);
		}
		return context;
	}
	public Object walk(Object context, JobDefinition jd) {
		jobDefinitions.add(jd);
		return context;
	}
	public Object walk(Object context, JobReference jr) {
		return context;
	}
	public Object walk(Object context, Split pjs) {
		for (JobNode jobNode : pjs.getSeries()) {
			walk(context, jobNode);
		}
		return context;
	}
}",0,1,0,0
"public int hashCode() {
	 final int prime = 31;
	 int result = 1;
	 result = prime * result + (this.alias == null ? 0 : this.alias.hashCode());
	 result = prime * result + (this.ciphers == null ? 0 : this.ciphers.hashCode());
	 result = prime * result + (this.hostnameVerification ? 1231 : 1237);
	 result = prime * result + (this.keyStore == null ? 0 : this.keyStore.hashCode());
	 result = prime * result + Arrays.hashCode(this.keyStorePassword);
	 result = prime * result + (this.protocol == null ? 0 : this.protocol.hashCode());
	 result = prime * result + (this.sslManagerOpts == null ? 0 : this.sslManagerOpts.hashCode());
	 result = prime * result + (this.trustStore == null ? 0 : this.trustStore.hashCode());
	 return result;
 }",0,0,1,0
"public class WizardUIInfoPage {
	private int order;
	private String description;
	public int getOrder() {
		return order;
	}
	public String getDescription() {
		return description;
	}
	public static WizardUIInfoPage getDefaultPage(int order) {
		WizardUIInfoPage page = new WizardUIInfoPage();
		page.order = order;
		page.description = """";
		return page;
	}
}",0,1,0,0
"public static Cassandra.Client getClientFromOutputAddressList(Configuration conf) throws IOException {
	 return getClientFromAddressList(conf, ConfigHelper.getOutputInitialAddress(conf).split("",""), ConfigHelper.getOutputRpcPort(conf));
 }",0,0,0,0
"public class Summary extends Fixture {
	 public static String countsKey = ""counts"";
	 public void doTable(Parse table) {
		 summary.put(countsKey, counts());
		 SortedSet keys = new TreeSet(summary.keySet());
		 table.parts.more = rows(keys.iterator());
	 }
	 protected Parse rows(Iterator keys) {
		 if (keys.hasNext()) {
			 Object key = keys.next();
			 Parse result = tr( td(key.toString(), td(summary.get(key).toString(), null)), rows(keys));
			 if (key.equals(countsKey)) {
				 mark (result);
			 }
			 return result;
		 }
		 else {
			 return null;
		 }
	 }
	 protected Parse tr(Parse parts, Parse more) {
		 return new Parse (""tr"", null, parts, more);
	 }
	 protected Parse td(String body, Parse more) {
		 return new Parse (""td"", info(body), null, more);
	 }
	 protected void mark(Parse row) {
		 Counts official = counts;
		 counts = new Counts();
		 Parse cell = row.parts.more;
		 if (official.wrong + official.exceptions > 0) {
			 wrong(cell);
		 }
		 else {
			 right(cell);
		 }
		 counts = official;
	 }
}",0,0,0,0
"public static List<Map<String, Object>> getFacilityContactMechValueMaps(Delegator delegator, String facilityId, boolean showOld, String contactMechTypeId) {
	 List<Map<String, Object>> facilityContactMechValueMaps = new LinkedList<Map<String,Object>>();
	 List<GenericValue> allFacilityContactMechs = null;
	 try {
		 List<GenericValue> tempCol = EntityQuery.use(delegator).from(""FacilityContactMech"").where(""facilityId"", facilityId).queryList();
		 if (contactMechTypeId != null) {
			 List<GenericValue> tempColTemp = new LinkedList<GenericValue>();
			 for (GenericValue partyContactMech: tempCol) {
				 GenericValue contactMech = delegator.getRelatedOne(""ContactMech"", partyContactMech, false);
				 if (contactMech != null && contactMechTypeId.equals(contactMech.getString(""contactMechTypeId""))) {
					 tempColTemp.add(partyContactMech);
				 }
			 }
			 tempCol = tempColTemp;
		 }
		 if (!showOld) tempCol = EntityUtil.filterByDate(tempCol, true);
		 allFacilityContactMechs = tempCol;
	 }
	 catch (GenericEntityException e) {
		 Debug.logWarning(e, module);
	 }
	 if (allFacilityContactMechs == null) return facilityContactMechValueMaps;
	 for (GenericValue facilityContactMech: allFacilityContactMechs) {
		 GenericValue contactMech = null;
		 try {
			 contactMech = facilityContactMech.getRelatedOne(""ContactMech"", false);
		 }
		 catch (GenericEntityException e) {
			 Debug.logWarning(e, module);
		 }
		 if (contactMech != null) {
			 Map<String, Object> facilityContactMechValueMap = new HashMap<String, Object>();
			 facilityContactMechValueMaps.add(facilityContactMechValueMap);
			 facilityContactMechValueMap.put(""contactMech"", contactMech);
			 facilityContactMechValueMap.put(""facilityContactMech"", facilityContactMech);
			 try {
				 facilityContactMechValueMap.put(""contactMechType"", contactMech.getRelatedOne(""ContactMechType"", true));
			 }
			 catch (GenericEntityException e) {
				 Debug.logWarning(e, module);
			 }
			 try {
				 List<GenericValue> facilityContactMechPurposes = facilityContactMech.getRelated(""FacilityContactMechPurpose"", null, null, false);
				 if (!showOld) facilityContactMechPurposes = EntityUtil.filterByDate(facilityContactMechPurposes, true);
				 facilityContactMechValueMap.put(""facilityContactMechPurposes"", facilityContactMechPurposes);
			 }
			 catch (GenericEntityException e) {
				 Debug.logWarning(e, module);
			 }
			 try {
				 if (""POSTAL_ADDRESS"".equals(contactMech.getString(""contactMechTypeId""))) {
					 facilityContactMechValueMap.put(""postalAddress"", contactMech.getRelatedOne(""PostalAddress"", false));
				 }
				 else if (""TELECOM_NUMBER"".equals(contactMech.getString(""contactMechTypeId""))) {
					 facilityContactMechValueMap.put(""telecomNumber"", contactMech.getRelatedOne(""TelecomNumber"", false));
				 }
			 }
			 catch (GenericEntityException e) {
				 Debug.logWarning(e, module);
			 }
		 }
	 }
	 return facilityContactMechValueMaps;
 }",0,0,1,0
"public class StmtRegistry extends QuiltRegistry {
	 private static StmtRegistry INSTANCE = null;
	 public static StmtRegistry getInstance () {
		 return INSTANCE;
	 }
	 private Map methodNames = new Hashtable();
	 private Map methodEnds = new Hashtable();
	 public StmtRegistry (QuiltClassLoader qcl) {
		 super(qcl);
		 INSTANCE = this;
		 ClassAction classAct = new ClassAction(this);
		 cxf = new ClassXformer[] {
		 classAct }
		;
		 mxf = new MethodXformer[] {
		 new MethodAction(this) }
		;
		 gxf = new GraphXformer[] {
		 new GraphAction(this, classAct) }
		;
		 setTransformers();
	 }
	 public void reset() {
	 }
	 public String getReport() {
		 StringBuffer sb = new StringBuffer() .append(""\n=========================\n"") .append( "" QUILT COVERAGE REPORT \n"");
		 if (isEmpty()) {
			 sb.append(""* the registry is empty *\n"");
		 }
		 else {
			 Set keys = keySet();
			 Iterator i = keys.iterator();
			 while (i.hasNext()) {
				 String[] name = (String[]) i.next();
				 int [] counts = (int[])get(name);
				 int count = counts.length;
				 String className = name[0];
				 sb.append(className + "": "" + count + "" counters, "" + getClassCoverage(className) + ""% coverage\n "");
				 String [] methods = (String[])methodNames.get(className);
				 if (methods == null) {
					 sb.append("" NULL\n"");
				 }
				 else {
					 for (int k = 0;
					 k < methods.length;
					 k++) {
						 sb.append("" "").append(methods[k]) .append("" "").append(getMethodCoverage(className,k)) .append(""% coverage\n"");
					 }
				 }
			 }
		 }
		 sb.append(""=========================\n"");
		 return sb.toString();
	 }
	 int getClassCoverage (String className) {
		 int nonZero = 0;
		 int[] hitCounts = (int[]) get(new String[] {
		className}
		);
		 if (hitCounts != null) {
			 for (int k = 0;
			 k < hitCounts.length;
			 k++) {
				 if (hitCounts[k] > 0) {
					 nonZero++;
				 }
			 }
			 nonZero = (nonZero*100)/hitCounts.length;
		 }
		 return nonZero;
	 }
	 int getMethodCoverage (String className, int n) {
		 int nonZero = 0;
		 int[] hitCounts = (int[]) get(new String[] {
		className}
		);
		 int[] ends = (int[]) methodEnds.get(className);
		 if ( n < 0 || n >= hitCounts.length ) {
			 throw new IllegalArgumentException(""index out of range"");
		 }
		 int counterCount = 0;
		 int lastCounter = ends[n] -1 ;
		 int firstCounter = n == 0 ? 0 : ends[n - 1];
		 if (hitCounts != null && ends != null) {
			 for (int k = firstCounter;
			 k <= lastCounter;
			 k++) {
				 counterCount++;
				 if (hitCounts[k] > 0) {
					 nonZero++;
				 }
			 }
			 if (counterCount > 0) {
				 nonZero = (nonZero*100)/counterCount;
			 }
		 }
		 return nonZero;
	 }
	 private static int nextClassID = 0;
	 public int getClassID (String className) {
		 int classID = -1;
		 try {
			 Field qField = Class.forName(className).getField(""q$$qID"");
			 classID = qField.getInt(qField);
		 }
		 catch (Exception e) {
			 System.out.println(""StmtRegistry.getClassID("" + className + "") failed - "" + e);
		 }
		 return classID;
	 }
	 public int [] getCounts (String className) {
		 int[] counts = null;
		 try {
			 counts = (int[])get ( new String[] {
			className}
			 );
		 }
		 catch (Exception e) {
			 System.out.println(""StmtRegistry.getCounts ("" + className + "") failed - "" + e);
		 }
		 return counts;
	 }
	 public int registerCounts (String className, int [] counts) {
		 int classID = -1;
		 try {
			 put ( new String[] {
			className}
			 , counts );
			 classID = nextClassID++;
		 }
		 catch (Exception e) {
			 System.out.println(""StmtRegistry.registerCounts for "" + className + "", q$$q) failed - "" + e);
		 }
		 return classID;
	 }
	 public void registerMethods (String className, String [] methods, int [] endCounts) {
		 if (className == null || methods == null || endCounts == null) {
			 throw new IllegalArgumentException(""null parameter"");
		 }
		 methodNames.put ( className, methods );
		 methodEnds.put ( className, endCounts );
	 }
	 public int getQuiltVersion (String className) {
		 int quiltVersion = -1;
		 try {
			 Field qField = Class.forName(className).getField(""q$$qVer"");
			 quiltVersion = qField.getInt(qField);
		 }
		 catch (Exception e) {
			 System.out.println(""StmtRegistry.getClassID("" + className + "") failed - "" + e);
		 }
		 return quiltVersion;
	 }
	 private Map ephemera = new Hashtable();
	 Ephemera getEphemera (String className) {
		 if (ephemera.containsKey(className)) {
			 return (Ephemera) ephemera.get(className);
		 }
		 else {
			 return null;
		 }
	 }
	 boolean putEphemera (String className, Ephemera eph) {
		 if (ephemera.containsKey(className)) {
			 return false;
		 }
		 ephemera.put(className, eph);
		 return true;
	 }
	 Ephemera removeEphemera (String className) {
		 return (Ephemera) ephemera.remove(className);
	 }
	 public int registerClass(String name, org.quilt.cover.stmt.QIC junk) {
		 System.out.println( ""**************************"" + ""\nQCL.registerClass "" + name + ""\n**************************"" );
		 return 52;
	 }
}",0,0,0,0
"public void execute() {
	 DOMElementWriter writer = new DOMElementWriter(!append, namespacePolicy.getPolicy());
	 OutputStream os = null;
	 try {
		 if (file != null) {
			 os = new FileOutputStream(file.getAbsolutePath(), append);
		 }
		 else {
			 os = new LogOutputStream(this, Project.MSG_INFO);
		 }
		 Node n = getFragment().getFirstChild();
		 if (n == null) {
			 throw new BuildException(ERROR_NO_XML);
		 }
		 writer.write((Element) n, os);
	 }
	 catch (BuildException e) {
		 throw e;
	 }
	 catch (Exception e) {
		 throw new BuildException(e);
	 }
	 finally {
		 FileUtils.close(os);
	 }
 }",0,0,0,0
"static class MergingCombineFn<K, AccumT> extends CombineFn<AccumT, List<AccumT>, AccumT> {
	 private final CombineFn<?, AccumT, ?> combineFn;
	 private final Coder<AccumT> accumCoder;
	 MergingCombineFn(CombineFn<?, AccumT, ?> combineFn, Coder<AccumT> accumCoder) {
		 this.combineFn = combineFn;
		 this.accumCoder = accumCoder;
	 }
	 public List<AccumT> createAccumulator() {
		 ArrayList<AccumT> result = new ArrayList<>();
		 result.add(this.combineFn.createAccumulator());
		 return result;
	 }
	 public List<AccumT> addInput(List<AccumT> accumulator, AccumT input) {
		 accumulator.add(input);
		 if (accumulator.size() < MAX_ACCUMULATOR_BUFFER_SIZE) {
			 return accumulator;
		 }
		 else {
			 return mergeToSingleton(accumulator);
		 }
	 }
	 public List<AccumT> mergeAccumulators(Iterable<List<AccumT>> accumulators) {
		 return mergeToSingleton(Iterables.concat(accumulators));
	 }
	 public List<AccumT> compact(List<AccumT> accumulator) {
		 return mergeToSingleton(accumulator);
	 }
	 public AccumT extractOutput(List<AccumT> accumulator) {
		 if (accumulator.isEmpty()) {
			 return combineFn.createAccumulator();
		 }
		 else {
			 return combineFn.mergeAccumulators(accumulator);
		 }
	 }
	 private List<AccumT> mergeToSingleton(Iterable<AccumT> accumulators) {
		 List<AccumT> singleton = new ArrayList<>();
		 singleton.add(combineFn.mergeAccumulators(accumulators));
		 return singleton;
	 }
	 public Coder<List<AccumT>> getAccumulatorCoder(CoderRegistry registry, Coder<AccumT> inputCoder) throws CannotProvideCoderException {
		 return ListCoder.of(accumCoder);
	 }
 }",0,0,0,0
"public final void setLogin(final String vssLogin) {
	 this.vssLogin = vssLogin;
 }",0,0,0,0
"public String toString(){
	final int second = second();
	return """" + hour() + "":"" + minute() + (second != 0 ? "":"" + second : """");
}",0,0,0,0
"classname=&quot;
org.apache.tools.ant.filters.EscapeUnicode&quot;
/&gt;
public class EscapeUnicode extends BaseParamFilterReader implements ChainableReader {
	 private StringBuffer unicodeBuf;
	 public EscapeUnicode() {
		 super();
		 unicodeBuf = new StringBuffer();
	 }
	 public EscapeUnicode(final Reader in) {
		 super(in);
		 unicodeBuf = new StringBuffer();
	 }
	 public final int read() throws IOException {
		 if (!getInitialized()) {
			 initialize();
			 setInitialized(true);
		 }
		 int ch = -1;
		 if (unicodeBuf.length() == 0) {
			 ch = in.read();
			 if (ch != -1) {
				 char achar = (char) ch;
				 if (achar >= '\u0080') {
					 unicodeBuf = new StringBuffer(""u0000"");
					 String s = Integer.toHexString(ch);
					 for (int i = 0;
					 i < s.length();
					 i++) {
						 unicodeBuf.setCharAt(unicodeBuf.length() - s.length() + i, s.charAt(i));
					 }
					 ch = '\\';
				 }
			 }
		 }
		 else {
			 ch = (int) unicodeBuf.charAt(0);
			 unicodeBuf.deleteCharAt(0);
		 }
		 return ch;
	 }
	 public final Reader chain(final Reader rdr) {
		 EscapeUnicode newFilter = new EscapeUnicode(rdr);
		 newFilter.setInitialized(true);
		 return newFilter;
	 }
	 private void initialize() {
	 }
}",0,0,0,0
"public abstract class AbstractActiveMQProducerResource extends AbstractActiveMQClientResource {
	 MessageProducer producer;
	 public AbstractActiveMQProducerResource(ActiveMQConnectionFactory connectionFactory) {
		 super(connectionFactory);
	 }
	 public AbstractActiveMQProducerResource(URI brokerURI) {
		 super(brokerURI);
	 }
	 public AbstractActiveMQProducerResource(EmbeddedActiveMQBroker embeddedActiveMQBroker) {
		 super(embeddedActiveMQBroker);
	 }
	 public AbstractActiveMQProducerResource(URI brokerURI, String userName, String password) {
		 super(brokerURI, userName, password);
	 }
	 public AbstractActiveMQProducerResource(String destinationName, ActiveMQConnectionFactory connectionFactory) {
		 super(destinationName, connectionFactory);
	 }
	 public AbstractActiveMQProducerResource(String destinationName, URI brokerURI) {
		 super(destinationName, brokerURI);
	 }
	 public AbstractActiveMQProducerResource(String destinationName, EmbeddedActiveMQBroker embeddedActiveMQBroker) {
		 super(destinationName, embeddedActiveMQBroker);
	 }
	 public AbstractActiveMQProducerResource(String destinationName, URI brokerURI, String userName, String password) {
		 super(destinationName, brokerURI, userName, password);
	 }
	 public String getDestinationName() {
		 try {
			 if (producer != null && producer.getDestination() != null) {
				 return producer.getDestination().toString();
			 }
		 }
		 catch (JMSException e) {
		 }
		 return null;
	 }
	 public void sendMessage(Message message) throws JMSException {
		 producer.send(message);
	 }
	 public BytesMessage sendMessage(byte[] body) throws JMSException {
		 BytesMessage message = this.createMessage(body);
		 sendMessage(message);
		 return message;
	 }
	 public TextMessage sendMessage(String body) throws JMSException {
		 TextMessage message = this.createMessage(body);
		 sendMessage(message);
		 return message;
	 }
	 public MapMessage sendMessage(Map<String, Object> body) throws JMSException {
		 MapMessage message = this.createMessage(body);
		 sendMessage(message);
		 return message;
	 }
	 public ObjectMessage sendMessage(Serializable body) throws JMSException {
		 ObjectMessage message = this.createMessage(body);
		 sendMessage(message);
		 return message;
	 }
	 public BytesMessage sendMessageWithProperties(byte[] body, Map<String, Object> properties) throws JMSException {
		 BytesMessage message = this.createMessage(body, properties);
		 sendMessage(message);
		 return message;
	 }
	 public TextMessage sendMessageWithProperties(String body, Map<String, Object> properties) throws JMSException {
		 TextMessage message = this.createMessage(body, properties);
		 sendMessage(message);
		 return message;
	 }
	 public MapMessage sendMessageWithProperties(Map<String, Object> body, Map<String, Object> properties) throws JMSException {
		 MapMessage message = this.createMessage(body, properties);
		 sendMessage(message);
		 return message;
	 }
	 public ObjectMessage sendMessageWithProperties(Serializable body, Map<String, Object> properties) throws JMSException {
		 ObjectMessage message = this.createMessage(body, properties);
		 sendMessage(message);
		 return message;
	 }
}",0,0,0,0
"public double probabilityOfAttributeValueGivenClass(double attVal, int classVal) {
	 DoubleVector obs = this.attValDistPerClass.get(classVal);
	 return obs != null ? (obs.getValue((int) attVal) + 1.0) / (obs.sumOfValues() + obs.numValues()) : 0.0;
 }",0,0,0,0
"public void startField() throws IOException {
	 if (!skipNullFields || this.reader.isSet()) {
		 if (fieldName.equals(Statistic.ROWCOUNT) || fieldName.equals(Statistic.NNROWCOUNT) || fieldName.equals(Statistic.NDV) || fieldName.equals(Statistic.SUM_DUPS)) {
			 nextField = fieldName;
		 }
	 }
 }",0,0,0,0
"public static class SignatureHashBuilder {
	private JvmDeclaredTypeSignatureHashProvider hashProvider;
	private AnnotationSignatureRelevanceUtil annotationRelevance;
	private MessageDigest digest;
	private StringBuilder builder;
	public SignatureHashBuilder() {
		digest = createDigest();
		if(digest == null)builder = new StringBuilder();
	}
	protected MessageDigest createDigest() {
		try {
			return MessageDigest.getInstance(""MD5"");
		}
		 catch (NoSuchAlgorithmException e) {
			LOG.error(""Error creating message digest"", e);
			return null;
		}
	}
	protected SignatureHashBuilder append(String s) {
		if(digest != null)try {
			digest.update(s.getBytes(""UTF8""));
		}
		 catch (UnsupportedEncodingException e) {
			LOG.error(""Error encoding String"", e);
		}
		if(builder != null)builder.append(s);
		return this;
	}
	public SignatureHashBuilder appendSignature(JvmDeclaredType type) {
		if (type.getVisibility() != JvmVisibility.PRIVATE) {
			appendAnnotationReferences(type);
			appendVisibility(type.getVisibility()).append("" "");
			if (type.isAbstract())append(""abstract "");
			if (type.isStatic())append(""static "");
			if (type.isFinal())append(""final "");
			append(""class "").append(type.getIdentifier());
			if (type instanceof JvmTypeParameterDeclarator)appendTypeParameters((JvmTypeParameterDeclarator) type);
			append(""\n"").appendSuperTypeSignatures(type).appendMemberSignatures(type, false);
		}
		return this;
	}
	protected SignatureHashBuilder appendMemberSignatures(JvmDeclaredType type, boolean innerTypesOnly) {
		Iterable<? extends JvmMember> members = type.getMembers();
		if(innerTypesOnly)members = filter(members, JvmDeclaredType.class);
		for (JvmMember member : members) {
			if (member.getSimpleName() != null) {
				appendAnnotationReferences(member);
				if (member instanceof JvmOperation) appendSignature((JvmOperation) member);
				else if (member instanceof JvmConstructor) appendSignature((JvmConstructor) member);
				else if (member instanceof JvmField) appendSignature((JvmField) member);
				else if (member instanceof JvmDeclaredType) {
					append(member.getQualifiedName());
					appendMemberSignatures((JvmDeclaredType) member, true);
				}
				append(""\n"");
			}
		}
		return this;
	}
	protected void appendAnnotationReferences(JvmAnnotationTarget target) {
		for(JvmAnnotationReference annotationReference: target.getAnnotations()) {
			if(annotationRelevance.isRelevant(annotationReference)) append(hashProvider.getHash(annotationReference.getAnnotation())).append("" "");
		}
	}
	protected SignatureHashBuilder appendSuperTypeSignatures(JvmDeclaredType type) {
		for(JvmTypeReference superType: type.getSuperTypes()) {
			append(""super "");
			append(superType.getIdentifier());
			append(""\n"");
		}
		return this;
	}
	protected SignatureHashBuilder appendSignature(JvmOperation operation) {
		appendVisibility(operation.getVisibility()).append("" "");
		if (operation.isAbstract())append(""abstract "");
		if (operation.isStatic())append(""static "");
		if (operation.isFinal())append(""final "");
		appendType(operation.getReturnType()).appendTypeParameters(operation).append("" "").append(operation.getSimpleName()).append(""("");
		for (JvmFormalParameter p : operation.getParameters()) {
			appendType(p.getParameterType());
			append("" "");
		}
		append("") "");
		for (JvmTypeReference ex : operation.getExceptions()) {
			appendType(ex).append("" "");
		}
		return this;
	}
	protected SignatureHashBuilder appendSignature(JvmField field) {
		appendVisibility(field.getVisibility()).append("" "");
		if (field.isStatic())append(""static "");
		if (field.isFinal())append(""final "");
		return appendType(field.getType()).append("" "").append(field.getSimpleName());
	}
	protected SignatureHashBuilder appendSignature(JvmConstructor operation) {
		appendVisibility(operation.getVisibility()).appendTypeParameters(operation).append(""("");
		for (JvmFormalParameter p : operation.getParameters()) {
			appendType(p.getParameterType()).append("" "");
		}
		append("") "");
		for (JvmTypeReference ex : operation.getExceptions()) {
			appendType(ex).append("" "");
		}
		return this;
	}
	protected SignatureHashBuilder appendTypeParameters(JvmTypeParameterDeclarator decl) {
		append(""<"");
		for (JvmTypeParameter tp : decl.getTypeParameters()) {
			appendTypeParameter(tp).append("","");
		}
		append("">"");
		return this;
	}
	protected SignatureHashBuilder appendType(JvmTypeReference ref) {
		if (ref != null && ref.getIdentifier() != null) {
			append(ref.getIdentifier());
		}
		 else {
			append(""*unresolved*"");
		}
		return this;
	}
	protected SignatureHashBuilder appendVisibility(JvmVisibility v) {
		append(v.getLiteral());
		return this;
	}
	protected SignatureHashBuilder appendTypeParameter(JvmTypeParameter p) {
		if (p != null && p.getIdentifier() != null) {
			append(p.getIdentifier());
		}
		 else {
			append(""*unresolved*"");
		}
		return this;
	}
	public String hash() {
		try {
			if(digest != null) {
				byte[] digestBytes = digest.digest();
				return new BigInteger(digestBytes).toString(16);
			}
			 else {
				return builder.toString();
			}
		}
		 catch (Exception e) {
			LOG.error(""Error hashing JvmDeclaredType signature"", e);
			return """";
		}
	}
}",1,0,0,0
"public class CliClient{
	 public enum Function {
		 BYTES (BytesType.instance), INTEGER (IntegerType.instance), LONG (LongType.instance), LEXICALUUID (LexicalUUIDType.instance), TIMEUUID (TimeUUIDType.instance), UTF8 (UTF8Type.instance), ASCII (AsciiType.instance), COUNTERCOLUMN (CounterColumnType.instance);
		 private AbstractType validator;
		 Function(AbstractType validator) {
			 this.validator = validator;
		 }
		 public AbstractType getValidator() {
			 return this.validator;
		 }
		 public static String getFunctionNames() {
			 Function[] functions = Function.values();
			 StringBuilder functionNames = new StringBuilder();
			 for (int i = 0;
			 i < functions.length;
			 i++) {
				 StringBuilder currentName = new StringBuilder(functions[i].name().toLowerCase());
				 functionNames.append(currentName.append(((i != functions.length-1) ? "", "" : ""."")));
			 }
			 return functionNames.toString();
		 }
	 }
	 private enum AddKeyspaceArgument {
	 PLACEMENT_STRATEGY, STRATEGY_OPTIONS, DURABLE_WRITES }
	 protected enum ColumnFamilyArgument {
	 COLUMN_TYPE, COMPARATOR, SUBCOMPARATOR, COMMENT, ROWS_CACHED, ROW_CACHE_SAVE_PERIOD, KEYS_CACHED, KEY_CACHE_SAVE_PERIOD, READ_REPAIR_CHANCE, GC_GRACE, COLUMN_METADATA, MEMTABLE_OPERATIONS, MEMTABLE_THROUGHPUT, MEMTABLE_FLUSH_AFTER, DEFAULT_VALIDATION_CLASS, MIN_COMPACTION_THRESHOLD, MAX_COMPACTION_THRESHOLD, REPLICATE_ON_WRITE, ROW_CACHE_PROVIDER, KEY_VALIDATION_CLASS }
	 private static final String DEFAULT_PLACEMENT_STRATEGY = ""org.apache.cassandra.locator.NetworkTopologyStrategy"";
	 private Cassandra.Client thriftClient = null;
	 private CliSessionState sessionState = null;
	 private String keySpace = null;
	 private String username = null;
	 private Map<String, KsDef> keyspacesMap = new HashMap<String, KsDef>();
	 private Map<String, AbstractType> cfKeysComparators;
	 private ConsistencyLevel consistencyLevel = ConsistencyLevel.ONE;
	 private CliUserHelp help;
	 public CliClient(CliSessionState cliSessionState, Cassandra.Client thriftClient) {
		 this.sessionState = cliSessionState;
		 this.thriftClient = thriftClient;
		 this.cfKeysComparators = new HashMap<String, AbstractType>();
		 help = getHelp();
	 }
	 private CliUserHelp getHelp() {
		 final InputStream is = CliClient.class.getClassLoader().getResourceAsStream(""org/apache/cassandra/cli/CliHelp.yaml"");
		 assert is != null;
		 try {
			 final Constructor constructor = new Constructor(CliUserHelp.class);
			 TypeDescription desc = new TypeDescription(CliUserHelp.class);
			 desc.putListPropertyType(""commands"", CliCommandHelp.class);
			 final Yaml yaml = new Yaml(new Loader(constructor));
			 return (CliUserHelp)yaml.load(is);
		 }
		 finally {
			 try {
				 is.close();
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
	 }
	 public void printBanner() {
		 sessionState.out.println(help.banner);
	 }
	 public void executeCLIStatement(String statement) {
		 Tree tree = CliCompiler.compileQuery(statement);
		 try {
			 switch (tree.getType()) {
				 case CliParser.NODE_EXIT: cleanupAndExit();
				 break;
				 case CliParser.NODE_THRIFT_GET: executeGet(tree);
				 break;
				 case CliParser.NODE_THRIFT_GET_WITH_CONDITIONS: executeGetWithConditions(tree);
				 break;
				 case CliParser.NODE_HELP: executeHelp(tree);
				 break;
				 case CliParser.NODE_THRIFT_SET: executeSet(tree);
				 break;
				 case CliParser.NODE_THRIFT_DEL: executeDelete(tree);
				 break;
				 case CliParser.NODE_THRIFT_COUNT: executeCount(tree);
				 break;
				 case CliParser.NODE_ADD_KEYSPACE: executeAddKeySpace(tree.getChild(0));
				 break;
				 case CliParser.NODE_ADD_COLUMN_FAMILY: executeAddColumnFamily(tree.getChild(0));
				 break;
				 case CliParser.NODE_UPDATE_KEYSPACE: executeUpdateKeySpace(tree.getChild(0));
				 break;
				 case CliParser.NODE_UPDATE_COLUMN_FAMILY: executeUpdateColumnFamily(tree.getChild(0));
				 break;
				 case CliParser.NODE_DEL_COLUMN_FAMILY: executeDelColumnFamily(tree);
				 break;
				 case CliParser.NODE_DEL_KEYSPACE: executeDelKeySpace(tree);
				 break;
				 case CliParser.NODE_SHOW_CLUSTER_NAME: executeShowClusterName();
				 break;
				 case CliParser.NODE_SHOW_VERSION: executeShowVersion();
				 break;
				 case CliParser.NODE_SHOW_KEYSPACES: executeShowKeySpaces();
				 break;
				 case CliParser.NODE_DESCRIBE_TABLE: executeDescribeKeySpace(tree);
				 break;
				 case CliParser.NODE_DESCRIBE_CLUSTER: executeDescribeCluster();
				 break;
				 case CliParser.NODE_USE_TABLE: executeUseKeySpace(tree);
				 break;
				 case CliParser.NODE_CONNECT: executeConnect(tree);
				 break;
				 case CliParser.NODE_LIST: executeList(tree);
				 break;
				 case CliParser.NODE_TRUNCATE: executeTruncate(tree.getChild(0).getText());
				 break;
				 case CliParser.NODE_ASSUME: executeAssumeStatement(tree);
				 break;
				 case CliParser.NODE_CONSISTENCY_LEVEL: executeConsistencyLevelStatement(tree);
				 break;
				 case CliParser.NODE_THRIFT_INCR: executeIncr(tree, 1L);
				 break;
				 case CliParser.NODE_THRIFT_DECR: executeIncr(tree, -1L);
				 break;
				 case CliParser.NODE_DROP_INDEX: executeDropIndex(tree);
				 break;
				 case CliParser.NODE_NO_OP: break;
				 default: sessionState.err.println(""Invalid Statement (Type: "" + tree.getType() + "")"");
				 if (sessionState.batch) System.exit(2);
				 break;
			 }
		 }
		 catch (InvalidRequestException e) {
			 RuntimeException rtEx = new RuntimeException(e.getWhy());
			 rtEx.initCause(e);
			 throw rtEx;
		 }
		 catch (SchemaDisagreementException e) {
			 RuntimeException rtEx = new RuntimeException(""schema does not match across nodes, (try again later)."");
			 rtEx.initCause(e);
			 throw new RuntimeException();
		 }
		 catch (Exception e) {
			 RuntimeException rtEx = new RuntimeException(e.getMessage());
			 rtEx.initCause(e);
			 throw rtEx;
		 }
	 }
	 private void cleanupAndExit() {
		 CliMain.disconnect();
		 System.exit(0);
	 }
	 public KsDef getKSMetaData(String keyspace) throws NotFoundException, InvalidRequestException, TException {
		 if (!(keyspacesMap.containsKey(keyspace))) keyspacesMap.put(keyspace, thriftClient.describe_keyspace(keyspace));
		 return keyspacesMap.get(keyspace);
	 }
	 private void executeHelp(Tree tree) {
		 if (tree.getChildCount() > 0) {
			 String token = tree.getChild(0).getText();
			 for (CliCommandHelp ch : help.commands) {
				 if (token.equals(ch.name)) {
					 sessionState.out.println(ch.help);
					 break;
				 }
			 }
		 }
		 else {
			 sessionState.out.println(help.help);
		 }
	 }
	 private void executeCount(Tree statement) throws TException, InvalidRequestException, UnavailableException, TimedOutException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 Tree columnFamilySpec = statement.getChild(0);
		 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
		 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
		 ColumnParent colParent = new ColumnParent(columnFamily).setSuper_column((ByteBuffer) null);
		 if (columnSpecCnt != 0) {
			 Tree columnTree = columnFamilySpec.getChild(2);
			 byte[] superColumn = (columnTree.getType() == CliParser.FUNCTION_CALL) ? convertValueByFunction(columnTree, null, null).array() : columnNameAsByteArray(CliCompiler.getColumn(columnFamilySpec, 0), columnFamily);
			 colParent = new ColumnParent(columnFamily).setSuper_column(superColumn);
		 }
		 SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, Integer.MAX_VALUE);
		 SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);
		 int count = thriftClient.get_count(getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1)), colParent, predicate, consistencyLevel);
		 sessionState.out.printf(""%d columns%n"", count);
	 }
	 private void executeDelete(Tree statement) throws TException, InvalidRequestException, UnavailableException, TimedOutException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 Tree columnFamilySpec = statement.getChild(0);
		 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
		 CfDef cfDef = getCfDef(columnFamily);
		 ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
		 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
		 byte[] superColumnName = null;
		 byte[] columnName = null;
		 boolean isSuper = cfDef.column_type.equals(""Super"");
		 if ((columnSpecCnt < 0) || (columnSpecCnt > 2)) {
			 sessionState.out.println(""Invalid row, super column, or column specification."");
			 return;
		 }
		 Tree columnTree = (columnSpecCnt >= 1) ? columnFamilySpec.getChild(2) : null;
		 Tree subColumnTree = (columnSpecCnt == 2) ? columnFamilySpec.getChild(3) : null;
		 if (columnSpecCnt == 1) {
			 assert columnTree != null;
			 byte[] columnNameBytes = (columnTree.getType() == CliParser.FUNCTION_CALL) ? convertValueByFunction(columnTree, null, null).array() : columnNameAsByteArray(CliCompiler.getColumn(columnFamilySpec, 0), cfDef);
			 if (isSuper) superColumnName = columnNameBytes;
			 else columnName = columnNameBytes;
		 }
		 else if (columnSpecCnt == 2) {
			 assert columnTree != null;
			 assert subColumnTree != null;
			 superColumnName = (columnTree.getType() == CliParser.FUNCTION_CALL) ? convertValueByFunction(columnTree, null, null).array() : columnNameAsByteArray(CliCompiler.getColumn(columnFamilySpec, 0), cfDef);
			 columnName = (subColumnTree.getType() == CliParser.FUNCTION_CALL) ? convertValueByFunction(subColumnTree, null, null).array() : subColumnNameAsByteArray(CliCompiler.getColumn(columnFamilySpec, 1), cfDef);
		 }
		 ColumnPath path = new ColumnPath(columnFamily);
		 if (superColumnName != null) path.setSuper_column(superColumnName);
		 if (columnName != null) path.setColumn(columnName);
		 if (isCounterCF(cfDef)) {
			 thriftClient.remove_counter(key, path, consistencyLevel);
		 }
		 else {
			 thriftClient.remove(key, path, FBUtilities.timestampMicros(), consistencyLevel);
		 }
		 sessionState.out.println(String.format(""%s removed."", (columnSpecCnt == 0) ? ""row"" : ""column""));
	 }
	 private void doSlice(String keyspace, ByteBuffer key, String columnFamily, byte[] superColumnName, int limit) throws InvalidRequestException, UnavailableException, TimedOutException, TException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException {
		 ColumnParent parent = new ColumnParent(columnFamily);
		 if(superColumnName != null) parent.setSuper_column(superColumnName);
		 SliceRange range = new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, limit);
		 SlicePredicate predicate = new SlicePredicate().setColumn_names(null).setSlice_range(range);
		 CfDef cfDef = getCfDef(columnFamily);
		 boolean isSuperCF = cfDef.column_type.equals(""Super"");
		 List<ColumnOrSuperColumn> columns = thriftClient.get_slice(key, parent, predicate, consistencyLevel);
		 AbstractType validator;
		 for (ColumnOrSuperColumn cosc : columns) {
			 if (cosc.isSetSuper_column()) {
				 SuperColumn superColumn = cosc.super_column;
				 sessionState.out.printf(""=> (super_column=%s,"", formatColumnName(keyspace, columnFamily, superColumn.name));
				 for (Column col : superColumn.getColumns()) {
					 validator = getValidatorForValue(cfDef, col.getName());
					 sessionState.out.printf(""%n (column=%s, value=%s, timestamp=%d%s)"", formatSubcolumnName(keyspace, columnFamily, col.name), validator.getString(col.value), col.timestamp, col.isSetTtl() ? String.format("", ttl=%d"", col.getTtl()) : """");
				 }
				 sessionState.out.println("")"");
			 }
			 else if (cosc.isSetColumn()) {
				 Column column = cosc.column;
				 validator = getValidatorForValue(cfDef, column.getName());
				 String formattedName = isSuperCF ? formatSubcolumnName(keyspace, columnFamily, column.name) : formatColumnName(keyspace, columnFamily, column.name);
				 sessionState.out.printf(""=> (column=%s, value=%s, timestamp=%d%s)%n"", formattedName, validator.getString(column.value), column.timestamp, column.isSetTtl() ? String.format("", ttl=%d"", column.getTtl()) : """");
			 }
			 else if (cosc.isSetCounter_super_column()) {
				 CounterSuperColumn superColumn = cosc.counter_super_column;
				 sessionState.out.printf(""=> (super_column=%s,"", formatColumnName(keyspace, columnFamily, superColumn.name));
				 for (CounterColumn col : superColumn.getColumns()) {
					 sessionState.out.printf(""%n (counter=%s, value=%s)"", formatSubcolumnName(keyspace, columnFamily, col.name), col.value);
				 }
				 sessionState.out.println("")"");
			 }
			 else {
				 CounterColumn column = cosc.counter_column;
				 String formattedName = isSuperCF ? formatSubcolumnName(keyspace, columnFamily, column.name) : formatColumnName(keyspace, columnFamily, column.name);
				 sessionState.out.printf(""=> (counter=%s, value=%s)%n"", formattedName, column.value);
			 }
		 }
		 sessionState.out.println(""Returned "" + columns.size() + "" results."");
	 }
	 private AbstractType getFormatType(String compareWith) {
		 Function function;
		 try {
			 function = Function.valueOf(compareWith.toUpperCase());
		 }
		 catch (IllegalArgumentException e) {
			 try {
				 return TypeParser.parse(compareWith);
			 }
			 catch (ConfigurationException ce) {
				 StringBuilder errorMessage = new StringBuilder(""Unknown comparator '"" + compareWith + ""'. "");
				 errorMessage.append(""Available functions: "");
				 throw new RuntimeException(errorMessage.append(Function.getFunctionNames()).toString());
			 }
		 }
		 return function.getValidator();
	 }
	 private void executeGet(Tree statement) throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 Tree columnFamilySpec = statement.getChild(0);
		 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
		 ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
		 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
		 CfDef cfDef = getCfDef(columnFamily);
		 boolean isSuper = cfDef.column_type.equals(""Super"");
		 byte[] superColumnName = null;
		 ByteBuffer columnName;
		 Tree typeTree = null;
		 Tree limitTree = null;
		 int limit = 1000000;
		 if (statement.getChildCount() >= 2) {
			 if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE) {
				 typeTree = statement.getChild(1).getChild(0);
				 if (statement.getChildCount() == 3) limitTree = statement.getChild(2).getChild(0);
			 }
			 else {
				 limitTree = statement.getChild(1).getChild(0);
			 }
		 }
		 if (limitTree != null) {
			 limit = Integer.parseInt(limitTree.getText());
			 if (limit == 0) {
				 throw new IllegalArgumentException(""LIMIT should be greater than zero."");
			 }
		 }
		 if (columnSpecCnt == 0) {
			 doSlice(keySpace, key, columnFamily, superColumnName, limit);
			 return;
		 }
		 else if (columnSpecCnt == 1) {
			 columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));
			 if (isSuper) {
				 superColumnName = columnName.array();
				 doSlice(keySpace, key, columnFamily, superColumnName, limit);
				 return;
			 }
		 }
		 else if (columnSpecCnt == 2) {
			 superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();
			 columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));
		 }
		 else {
			 sessionState.out.println(""Invalid row, super column, or column specification."");
			 return;
		 }
		 AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));
		 ColumnPath path = new ColumnPath(columnFamily);
		 if(superColumnName != null) path.setSuper_column(superColumnName);
		 path.setColumn(columnName);
		 if (isCounterCF(cfDef)) {
			 doGetCounter(key, path);
			 return;
		 }
		 Column column;
		 try {
			 column = thriftClient.get(key, path, consistencyLevel).column;
		 }
		 catch (NotFoundException e) {
			 sessionState.out.println(""Value was not found"");
			 return;
		 }
		 byte[] columnValue = column.getValue();
		 String valueAsString;
		 if (typeTree != null) {
			 String typeName = CliUtils.unescapeSQLString(typeTree.getText());
			 AbstractType valueValidator = getFormatType(typeName);
			 valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));
			 updateColumnMetaData(cfDef, columnName, valueValidator.toString());
		 }
		 else {
			 valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));
		 }
		 String formattedColumnName = isSuper ? formatSubcolumnName(keySpace, columnFamily, column.name) : formatColumnName(keySpace, columnFamily, column.name);
		 sessionState.out.printf(""=> (column=%s, value=%s, timestamp=%d%s)%n"", formattedColumnName, valueAsString, column.timestamp, column.isSetTtl() ? String.format("", ttl=%d"", column.getTtl()) : """");
	 }
	 private void doGetCounter(ByteBuffer key, ColumnPath path) throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException {
		 boolean isSuper = path.super_column != null;
		 CounterColumn column;
		 try {
			 column = thriftClient.get(key, path, consistencyLevel).counter_column;
		 }
		 catch (NotFoundException e) {
			 sessionState.out.println(""Value was not found"");
			 return;
		 }
		 String formattedColumnName = isSuper ? formatSubcolumnName(keySpace, path.column_family, column.name) : formatColumnName(keySpace, path.column_family, column.name);
		 sessionState.out.printf(""=> (counter=%s, value=%d)%n"", formattedColumnName, column.value);
	 }
	 private void executeGetWithConditions(Tree statement) {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 IndexClause clause = new IndexClause();
		 String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
		 Tree conditions = statement.getChild(1);
		 CfDef columnFamilyDef = getCfDef(columnFamily);
		 SlicePredicate predicate = new SlicePredicate();
		 SliceRange sliceRange = new SliceRange();
		 sliceRange.setStart(new byte[0]).setFinish(new byte[0]);
		 predicate.setSlice_range(sliceRange);
		 for (int i = 0;
		 i < conditions.getChildCount();
		 i++) {
			 Tree condition = conditions.getChild(i);
			 String operator = condition.getChild(0).getText();
			 String columnNameString = CliUtils.unescapeSQLString(condition.getChild(1).getText());
			 Tree valueTree = condition.getChild(2);
			 try {
				 ByteBuffer value;
				 ByteBuffer columnName = columnNameAsBytes(columnNameString, columnFamily);
				 if (valueTree.getType() == CliParser.FUNCTION_CALL) {
					 value = convertValueByFunction(valueTree, columnFamilyDef, columnName);
				 }
				 else {
					 String valueString = CliUtils.unescapeSQLString(valueTree.getText());
					 value = columnValueAsBytes(columnName, columnFamily, valueString);
				 }
				 IndexOperator idxOperator = CliUtils.getIndexOperator(operator);
				 clause.addToExpressions(new IndexExpression(columnName, idxOperator, value));
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e.getMessage());
			 }
		 }
		 List<KeySlice> slices;
		 clause.setStart_key(new byte[] {
		}
		);
		 if (statement.getChildCount() == 3) {
			 Tree limitNode = statement.getChild(2);
			 int limitValue = Integer.parseInt(limitNode.getChild(0).getText());
			 if (limitValue == 0) {
				 throw new IllegalArgumentException(""LIMIT should be greater than zero."");
			 }
			 clause.setCount(limitValue);
		 }
		 try {
			 ColumnParent parent = new ColumnParent(columnFamily);
			 slices = thriftClient.get_indexed_slices(parent, clause, predicate, consistencyLevel);
			 printSliceList(columnFamilyDef, slices);
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e.getWhy());
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage());
		 }
	 }
	 private void executeSet(Tree statement) throws TException, InvalidRequestException, UnavailableException, TimedOutException, NoSuchFieldException, InstantiationException, IllegalAccessException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 Tree columnFamilySpec = statement.getChild(0);
		 Tree keyTree = columnFamilySpec.getChild(1);
		 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
		 CfDef cfDef = getCfDef(columnFamily);
		 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
		 String value = CliUtils.unescapeSQLString(statement.getChild(1).getText());
		 Tree valueTree = statement.getChild(1);
		 byte[] superColumnName = null;
		 ByteBuffer columnName;
		 if (columnSpecCnt == 0) {
			 sessionState.err.println(""No column name specified, (type 'help;
			' or '?' for help on syntax)."");
			 return;
		 }
		 else if (columnSpecCnt == 1) {
			 if (cfDef.column_type.equals(""Super"")) {
				 sessionState.out.println(""Column family "" + columnFamily + "" may only contain SuperColumns"");
				 return;
			 }
			 columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));
		 }
		 else {
			 assert (columnSpecCnt == 2) : ""serious parsing error (this is a bug)."";
			 superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();
			 columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));
		 }
		 ByteBuffer columnValueInBytes;
		 switch (valueTree.getType()) {
			 case CliParser.FUNCTION_CALL: columnValueInBytes = convertValueByFunction(valueTree, cfDef, columnName, true);
			 break;
			 default: columnValueInBytes = columnValueAsBytes(columnName, columnFamily, value);
		 }
		 ColumnParent parent = new ColumnParent(columnFamily);
		 if(superColumnName != null) parent.setSuper_column(superColumnName);
		 Column columnToInsert = new Column(columnName).setValue(columnValueInBytes).setTimestamp(FBUtilities.timestampMicros());
		 if (statement.getChildCount() == 3) {
			 String ttl = statement.getChild(2).getText();
			 try {
				 columnToInsert.setTtl(Integer.parseInt(ttl));
			 }
			 catch (NumberFormatException e) {
				 sessionState.err.println(String.format(""TTL '%s' is invalid, should be a positive integer."", ttl));
				 return;
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e.getMessage());
			 }
		 }
		 thriftClient.insert(getKeyAsBytes(columnFamily, keyTree), parent, columnToInsert, consistencyLevel);
		 sessionState.out.println(""Value inserted."");
	 }
	 private void executeIncr(Tree statement, long multiplier) throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 Tree columnFamilySpec = statement.getChild(0);
		 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
		 ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
		 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
		 CfDef cfDef = getCfDef(columnFamily);
		 boolean isSuper = cfDef.column_type.equals(""Super"");
		 byte[] superColumnName = null;
		 ByteBuffer columnName;
		 if (columnSpecCnt == 1) {
			 columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));
		 }
		 else if (columnSpecCnt == 2) {
			 superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();
			 columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));
		 }
		 else {
			 sessionState.out.println(""Invalid row, super column, or column specification."");
			 return;
		 }
		 ColumnParent parent = new ColumnParent(columnFamily);
		 if(superColumnName != null) parent.setSuper_column(superColumnName);
		 long value = 1L;
		 if (statement.getChildCount() == 2) {
			 String byValue = statement.getChild(1).getText();
			 try {
				 value = Long.parseLong(byValue);
			 }
			 catch (NumberFormatException e) {
				 sessionState.err.println(String.format(""'%s' is an invalid value, should be an integer."", byValue));
				 return;
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e.getMessage());
			 }
		 }
		 CounterColumn columnToInsert = new CounterColumn(columnName, multiplier * value);
		 thriftClient.add(key, parent, columnToInsert, consistencyLevel);
		 sessionState.out.printf(""Value %s%n"", multiplier < 0 ? ""decremented."" : ""incremented."");
	 }
	 private void executeShowClusterName() throws TException {
		 if (!CliMain.isConnected()) return;
		 sessionState.out.println(thriftClient.describe_cluster_name());
	 }
	 private void executeAddKeySpace(Tree statement) {
		 if (!CliMain.isConnected()) return;
		 String keyspaceName = statement.getChild(0).getText();
		 KsDef ksDef = new KsDef(keyspaceName, DEFAULT_PLACEMENT_STRATEGY, new LinkedList<CfDef>());
		 try {
			 String mySchemaVersion = thriftClient.system_add_keyspace(updateKsDefAttributes(statement, ksDef));
			 sessionState.out.println(mySchemaVersion);
			 validateSchemaIsSettled(mySchemaVersion);
			 keyspacesMap.put(keyspaceName, thriftClient.describe_keyspace(keyspaceName));
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e.getWhy());
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage(), e);
		 }
	 }
	 private void executeAddColumnFamily(Tree statement) {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 CfDef cfDef = new CfDef(keySpace, statement.getChild(0).getText());
		 try {
			 String mySchemaVersion = thriftClient.system_add_column_family(updateCfDefAttributes(statement, cfDef));
			 sessionState.out.println(mySchemaVersion);
			 validateSchemaIsSettled(mySchemaVersion);
			 keyspacesMap.put(keySpace, thriftClient.describe_keyspace(keySpace));
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e.getWhy());
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage(), e);
		 }
	 }
	 private void executeUpdateKeySpace(Tree statement) {
		 if (!CliMain.isConnected()) return;
		 try {
			 String keyspaceName = CliCompiler.getKeySpace(statement, thriftClient.describe_keyspaces());
			 KsDef currentKsDef = getKSMetaData(keyspaceName);
			 KsDef updatedKsDef = updateKsDefAttributes(statement, currentKsDef);
			 String mySchemaVersion = thriftClient.system_update_keyspace(updatedKsDef);
			 sessionState.out.println(mySchemaVersion);
			 validateSchemaIsSettled(mySchemaVersion);
			 keyspacesMap.put(keyspaceName, thriftClient.describe_keyspace(keyspaceName));
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e.getWhy());
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage(), e);
		 }
	 }
	 private void executeUpdateColumnFamily(Tree statement) {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 String cfName = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
		 try {
			 CfDef cfDef = getCfDef(thriftClient.describe_keyspace(this.keySpace), cfName);
			 if (cfDef == null) throw new RuntimeException(""Column Family "" + cfName + "" was not found in the current keyspace."");
			 String mySchemaVersion = thriftClient.system_update_column_family(updateCfDefAttributes(statement, cfDef));
			 sessionState.out.println(mySchemaVersion);
			 validateSchemaIsSettled(mySchemaVersion);
			 keyspacesMap.put(keySpace, thriftClient.describe_keyspace(keySpace));
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e.getWhy());
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage(), e);
		 }
	 }
	 private KsDef updateKsDefAttributes(Tree statement, KsDef ksDefToUpdate) {
		 KsDef ksDef = new KsDef(ksDefToUpdate);
		 ksDef.unsetReplication_factor();
		 ksDef.setCf_defs(new LinkedList<CfDef>());
		 for(int i = 1;
		 i < statement.getChildCount();
		 i += 2) {
			 String currentStatement = statement.getChild(i).getText().toUpperCase();
			 AddKeyspaceArgument mArgument = AddKeyspaceArgument.valueOf(currentStatement);
			 String mValue = statement.getChild(i + 1).getText();
			 switch(mArgument) {
				 case PLACEMENT_STRATEGY: ksDef.setStrategy_class(CliUtils.unescapeSQLString(mValue));
				 break;
				 case STRATEGY_OPTIONS: ksDef.setStrategy_options(getStrategyOptionsFromTree(statement.getChild(i + 1)));
				 break;
				 case DURABLE_WRITES: ksDef.setDurable_writes(Boolean.parseBoolean(mValue));
				 break;
				 default: assert(false);
			 }
		 }
		 if (ksDef.getStrategy_class().contains("".NetworkTopologyStrategy"")) {
			 Map<String, String> currentStrategyOptions = ksDef.getStrategy_options();
			 if (currentStrategyOptions == null || currentStrategyOptions.isEmpty()) {
				 SimpleSnitch snitch = new SimpleSnitch();
				 Map<String, String> options = new HashMap<String, String>();
				 try {
					 options.put(snitch.getDatacenter(InetAddress.getLocalHost()), ""1"");
				 }
				 catch (UnknownHostException e) {
					 throw new RuntimeException(e.getMessage());
				 }
				 ksDef.setStrategy_options(options);
			 }
		 }
		 return ksDef;
	 }
	 private CfDef updateCfDefAttributes(Tree statement, CfDef cfDefToUpdate) {
		 CfDef cfDef = new CfDef(cfDefToUpdate);
		 for (int i = 1;
		 i < statement.getChildCount();
		 i += 2) {
			 String currentArgument = statement.getChild(i).getText().toUpperCase();
			 ColumnFamilyArgument mArgument = ColumnFamilyArgument.valueOf(currentArgument);
			 String mValue = statement.getChild(i + 1).getText();
			 switch(mArgument) {
				 case COLUMN_TYPE: cfDef.setColumn_type(CliUtils.unescapeSQLString(mValue));
				 break;
				 case COMPARATOR: cfDef.setComparator_type(CliUtils.unescapeSQLString(mValue));
				 break;
				 case SUBCOMPARATOR: cfDef.setSubcomparator_type(CliUtils.unescapeSQLString(mValue));
				 break;
				 case COMMENT: cfDef.setComment(CliUtils.unescapeSQLString(mValue));
				 break;
				 case ROWS_CACHED: cfDef.setRow_cache_size(Double.parseDouble(mValue));
				 break;
				 case KEYS_CACHED: cfDef.setKey_cache_size(Double.parseDouble(mValue));
				 break;
				 case READ_REPAIR_CHANCE: double chance = Double.parseDouble(mValue);
				 if (chance < 0 || chance > 1) throw new RuntimeException(""Error: read_repair_chance must be between 0 and 1."");
				 cfDef.setRead_repair_chance(chance);
				 break;
				 case GC_GRACE: cfDef.setGc_grace_seconds(Integer.parseInt(mValue));
				 break;
				 case COLUMN_METADATA: Tree arrayOfMetaAttributes = statement.getChild(i + 1);
				 if (!arrayOfMetaAttributes.getText().equals(""ARRAY"")) throw new RuntimeException(""'column_metadata' format - [{
				 k:v, k:v, ..}
				, {
				 ... }
				, ...]"");
				 cfDef.setColumn_metadata(getCFColumnMetaFromTree(cfDef, arrayOfMetaAttributes));
				 break;
				 case MEMTABLE_OPERATIONS: cfDef.setMemtable_operations_in_millions(Double.parseDouble(mValue));
				 break;
				 case MEMTABLE_FLUSH_AFTER: cfDef.setMemtable_flush_after_mins(Integer.parseInt(mValue));
				 break;
				 case MEMTABLE_THROUGHPUT: cfDef.setMemtable_throughput_in_mb(Integer.parseInt(mValue));
				 break;
				 case ROW_CACHE_SAVE_PERIOD: cfDef.setRow_cache_save_period_in_seconds(Integer.parseInt(mValue));
				 break;
				 case KEY_CACHE_SAVE_PERIOD: cfDef.setKey_cache_save_period_in_seconds(Integer.parseInt(mValue));
				 break;
				 case DEFAULT_VALIDATION_CLASS: cfDef.setDefault_validation_class(CliUtils.unescapeSQLString(mValue));
				 break;
				 case MIN_COMPACTION_THRESHOLD: cfDef.setMin_compaction_threshold(Integer.parseInt(mValue));
				 break;
				 case MAX_COMPACTION_THRESHOLD: cfDef.setMax_compaction_threshold(Integer.parseInt(mValue));
				 break;
				 case REPLICATE_ON_WRITE: cfDef.setReplicate_on_write(Boolean.parseBoolean(mValue));
				 break;
				 case ROW_CACHE_PROVIDER: cfDef.setRow_cache_provider(mValue);
				 break;
				 case KEY_VALIDATION_CLASS: cfDef.setKey_validation_class(CliUtils.unescapeSQLString(mValue));
				 break;
				 default: assert(false);
			 }
		 }
		 return cfDef;
	 }
	 private void executeDelKeySpace(Tree statement) throws TException, InvalidRequestException, NotFoundException, SchemaDisagreementException {
		 if (!CliMain.isConnected()) return;
		 String keyspaceName = CliCompiler.getKeySpace(statement, thriftClient.describe_keyspaces());
		 String version = thriftClient.system_drop_keyspace(keyspaceName);
		 sessionState.out.println(version);
		 validateSchemaIsSettled(version);
		 if (keyspaceName.equals(keySpace)) keySpace = null;
	 }
	 private void executeDelColumnFamily(Tree statement) throws TException, InvalidRequestException, NotFoundException, SchemaDisagreementException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 String cfName = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
		 String mySchemaVersion = thriftClient.system_drop_column_family(cfName);
		 sessionState.out.println(mySchemaVersion);
		 validateSchemaIsSettled(mySchemaVersion);
	 }
	 private void executeList(Tree statement) throws TException, InvalidRequestException, NotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException, UnavailableException, TimedOutException, CharacterCodingException {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
		 String rawStartKey = """";
		 String rawEndKey = """";
		 int limitCount = Integer.MAX_VALUE;
		 for (int i = 1;
		 i < statement.getChildCount();
		 i++) {
			 Tree child = statement.getChild(i);
			 if (child.getType() == CliParser.NODE_KEY_RANGE) {
				 if (child.getChildCount() > 0) {
					 rawStartKey = CliUtils.unescapeSQLString(child.getChild(0).getText());
					 if (child.getChildCount() > 1) rawEndKey = CliUtils.unescapeSQLString(child.getChild(1).getText());
				 }
			 }
			 else {
				 if (child.getChildCount() != 1) {
					 sessionState.out.println(""Invalid limit clause"");
					 return;
				 }
				 limitCount = Integer.parseInt(child.getChild(0).getText());
				 if (limitCount <= 0) {
					 sessionState.out.println(""Invalid limit "" + limitCount);
					 return;
				 }
			 }
		 }
		 if (limitCount == Integer.MAX_VALUE) {
			 limitCount = 100;
			 sessionState.out.println(""Using default limit of 100"");
		 }
		 CfDef columnFamilyDef = getCfDef(columnFamily);
		 SlicePredicate predicate = new SlicePredicate();
		 SliceRange sliceRange = new SliceRange();
		 sliceRange.setStart(new byte[0]).setFinish(new byte[0]);
		 sliceRange.setCount(Integer.MAX_VALUE);
		 predicate.setSlice_range(sliceRange);
		 KeyRange range = new KeyRange(limitCount);
		 AbstractType keyComparator = this.cfKeysComparators.get(columnFamily);
		 ByteBuffer startKey = rawStartKey.isEmpty() ? ByteBufferUtil.EMPTY_BYTE_BUFFER : getBytesAccordingToType(rawStartKey, keyComparator);
		 ByteBuffer endKey = rawEndKey.isEmpty() ? ByteBufferUtil.EMPTY_BYTE_BUFFER : getBytesAccordingToType(rawEndKey, keyComparator);
		 range.setStart_key(startKey).setEnd_key(endKey);
		 ColumnParent columnParent = new ColumnParent(columnFamily);
		 List<KeySlice> keySlices = thriftClient.get_range_slices(columnParent, predicate, range, consistencyLevel);
		 printSliceList(columnFamilyDef, keySlices);
	 }
	 private void executeDropIndex(Tree statement) {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
		 String rawColumName = statement.getChild(1).getText();
		 CfDef cfDef = getCfDef(columnFamily);
		 ByteBuffer columnName = columnNameAsBytes(rawColumName, cfDef);
		 boolean foundColumn = false;
		 for (ColumnDef column : cfDef.getColumn_metadata()) {
			 if (column.name.equals(columnName)) {
				 foundColumn = true;
				 if (column.getIndex_type() == null) throw new RuntimeException(String.format(""Column '%s' does not have an index."", rawColumName));
				 column.setIndex_name(null);
				 column.setIndex_type(null);
			 }
		 }
		 if (!foundColumn) throw new RuntimeException(String.format(""Column '%s' definition was not found in ColumnFamily '%s'."", rawColumName, columnFamily));
		 try {
			 String mySchemaVersion = thriftClient.system_update_column_family(cfDef);
			 sessionState.out.println(mySchemaVersion);
			 validateSchemaIsSettled(mySchemaVersion);
			 keyspacesMap.put(keySpace, thriftClient.describe_keyspace(keySpace));
		 }
		 catch (InvalidRequestException e) {
			 System.err.println(e.why);
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage(), e);
		 }
	 }
	 private void executeTruncate(String columnFamily) {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 CfDef cfDef = getCfDef(CliCompiler.getColumnFamily(columnFamily, keyspacesMap.get(keySpace).cf_defs));
		 try {
			 thriftClient.truncate(cfDef.getName());
			 sessionState.out.println(columnFamily + "" truncated."");
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e.getWhy());
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage());
		 }
	 }
	 private void executeConsistencyLevelStatement(Tree statement) {
		 if (!CliMain.isConnected()) return;
		 String userSuppliedLevel = statement.getChild(0).getText().toUpperCase();
		 try {
			 consistencyLevel = ConsistencyLevel.valueOf(userSuppliedLevel);
		 }
		 catch (IllegalArgumentException e) {
			 String elements = ""ONE, TWO, THREE, QUORUM, ALL, LOCAL_QUORUM, EACH_QUORUM, ANY"";
			 sessionState.out.println(String.format(""'%s' is invalid. Available: %s"", userSuppliedLevel, elements));
			 return;
		 }
		 sessionState.out.println(String.format(""Consistency level is set to '%s'."", consistencyLevel));
	 }
	 private void executeAssumeStatement(Tree statement) {
		 if (!CliMain.isConnected() || !hasKeySpace()) return;
		 String cfName = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
		 CfDef columnFamily = getCfDef(cfName);
		 String assumptionElement = statement.getChild(1).getText().toUpperCase();
		 AbstractType comparator;
		 String defaultType = statement.getChild(2).getText();
		 try {
			 comparator = Function.valueOf(defaultType.toUpperCase()).getValidator();
		 }
		 catch (Exception e) {
			 String functions = Function.getFunctionNames();
			 sessionState.out.println(""Type '"" + defaultType + ""' was not found. Available: "" + functions);
			 return;
		 }
		 defaultType = comparator.getClass().getName();
		 if (assumptionElement.equals(""COMPARATOR"")) {
			 columnFamily.setComparator_type(defaultType);
		 }
		 else if (assumptionElement.equals(""SUB_COMPARATOR"")) {
			 columnFamily.setSubcomparator_type(defaultType);
		 }
		 else if (assumptionElement.equals(""VALIDATOR"")) {
			 columnFamily.setDefault_validation_class(defaultType);
		 }
		 else if (assumptionElement.equals(""KEYS"")) {
			 this.cfKeysComparators.put(columnFamily.getName(), comparator);
		 }
		 else {
			 String elements = ""VALIDATOR, COMPARATOR, KEYS, SUB_COMPARATOR."";
			 sessionState.out.println(String.format(""'%s' is invalid. Available: %s"", assumptionElement, elements));
			 return;
		 }
		 sessionState.out.println(String.format(""Assumption for column family '%s' added successfully."", columnFamily.getName()));
	 }
	 private void executeShowVersion() throws TException {
		 if (!CliMain.isConnected()) return;
		 sessionState.out.println(thriftClient.describe_version());
	 }
	 private void executeShowKeySpaces() throws TException, InvalidRequestException {
		 if (!CliMain.isConnected()) return;
		 List<KsDef> keySpaces = thriftClient.describe_keyspaces();
		 Collections.sort(keySpaces, new KsDefNamesComparator());
		 for (KsDef keySpace : keySpaces) {
			 describeKeySpace(keySpace.name, keySpace);
		 }
	 }
	 private boolean hasKeySpace() {
		 if (keySpace == null) {
			 sessionState.out.println(""Not authenticated to a working keyspace."");
			 return false;
		 }
		 return true;
	 }
	 public String getKeySpace() {
		 return keySpace == null ? ""unknown"" : keySpace;
	 }
	 public void setKeySpace(String keySpace) throws NotFoundException, InvalidRequestException, TException {
		 this.keySpace = keySpace;
		 getKSMetaData(keySpace);
	 }
	 public String getUsername() {
		 return username == null ? ""default"" : username;
	 }
	 public void setUsername(String username) {
		 this.username = username;
	 }
	 private void executeUseKeySpace(Tree statement) throws TException {
		 if (!CliMain.isConnected()) return;
		 int childCount = statement.getChildCount();
		 String keySpaceName, username = null, password = null;
		 keySpaceName = statement.getChild(0).getText();
		 if (childCount == 3) {
			 username = statement.getChild(1).getText();
			 password = statement.getChild(2).getText();
		 }
		 if (keySpaceName == null) {
			 sessionState.out.println(""Keyspace argument required"");
			 return;
		 }
		 try {
			 AuthenticationRequest authRequest;
			 Map<String, String> credentials = new HashMap<String, String>();
			 keySpaceName = CliCompiler.getKeySpace(keySpaceName, thriftClient.describe_keyspaces());
			 thriftClient.set_keyspace(keySpaceName);
			 if (username != null && password != null) {
				 password = password.replace(""\'"", """");
				 credentials.put(SimpleAuthenticator.USERNAME_KEY, username);
				 credentials.put(SimpleAuthenticator.PASSWORD_KEY, password);
				 authRequest = new AuthenticationRequest(credentials);
				 thriftClient.login(authRequest);
			 }
			 keySpace = keySpaceName;
			 this.username = username != null ? username : ""default"";
			 CliMain.updateCompletor(CliUtils.getCfNamesByKeySpace(getKSMetaData(keySpace)));
			 sessionState.out.println(""Authenticated to keyspace: "" + keySpace);
		 }
		 catch (AuthenticationException e) {
			 sessionState.err.println(""Exception during authentication to the cassandra node: "" + ""verify keyspace exists, and you are using correct credentials."");
		 }
		 catch (AuthorizationException e) {
			 sessionState.err.println(""You are not authorized to use keyspace: "" + keySpaceName);
		 }
		 catch (InvalidRequestException e) {
			 sessionState.err.println(keySpaceName + "" does not exist."");
		 }
		 catch (NotFoundException e) {
			 sessionState.err.println(keySpaceName + "" does not exist."");
		 }
		 catch (TException e) {
			 if (sessionState.debug) e.printStackTrace();
			 sessionState.err.println(""Login failure. Did you specify 'keyspace', 'username' and 'password'?"");
		 }
	 }
	 private void describeKeySpace(String keySpaceName, KsDef metadata) throws TException {
		 NodeProbe probe = sessionState.getNodeProbe();
		 CompactionManagerMBean compactionManagerMBean = (probe == null) ? null : probe.getCompactionManagerProxy();
		 sessionState.out.println(""Keyspace: "" + keySpaceName + "":"");
		 try {
			 KsDef ks_def;
			 ks_def = metadata == null ? thriftClient.describe_keyspace(keySpaceName) : metadata;
			 sessionState.out.println("" Replication Strategy: "" + ks_def.strategy_class);
			 sessionState.out.println("" Durable Writes: "" + ks_def.durable_writes);
			 Map<String, String> options = ks_def.strategy_options;
			 sessionState.out.println("" Options: ["" + ((options == null) ? """" : FBUtilities.toString(options)) + ""]"");
			 sessionState.out.println("" Column Families:"");
			 boolean isSuper;
			 Collections.sort(ks_def.cf_defs, new CfDefNamesComparator());
			 for (CfDef cf_def : ks_def.cf_defs) {
				 ColumnFamilyStoreMBean cfMBean = (probe == null) ? null : probe.getCfsProxy(ks_def.getName(), cf_def.getName());
				 isSuper = cf_def.column_type.equals(""Super"");
				 sessionState.out.printf("" ColumnFamily: %s%s%n"", cf_def.name, isSuper ? "" (Super)"" : """");
				 if (cf_def.comment != null && !cf_def.comment.isEmpty()) {
					 sessionState.out.printf("" \""%s\""%n"", cf_def.comment);
				 }
				 if (cf_def.key_validation_class != null) sessionState.out.printf("" Key Validation Class: %s%n"", cf_def.key_validation_class);
				 if (cf_def.default_validation_class != null) sessionState.out.printf("" Default column value validator: %s%n"", cf_def.default_validation_class);
				 sessionState.out.printf("" Columns sorted by: %s%s%n"", cf_def.comparator_type, cf_def.column_type.equals(""Super"") ? ""/"" + cf_def.subcomparator_type : """");
				 sessionState.out.printf("" Row cache size / save period in seconds: %s/%s%n"", cf_def.row_cache_size, cf_def.row_cache_save_period_in_seconds);
				 sessionState.out.printf("" Key cache size / save period in seconds: %s/%s%n"", cf_def.key_cache_size, cf_def.key_cache_save_period_in_seconds);
				 sessionState.out.printf("" Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n"", cf_def.memtable_operations_in_millions, cf_def.memtable_flush_after_mins, cf_def.memtable_throughput_in_mb);
				 sessionState.out.printf("" GC grace seconds: %s%n"", cf_def.gc_grace_seconds);
				 sessionState.out.printf("" Compaction min/max thresholds: %s/%s%n"", cf_def.min_compaction_threshold, cf_def.max_compaction_threshold);
				 sessionState.out.printf("" Read repair chance: %s%n"", cf_def.read_repair_chance);
				 sessionState.out.printf("" Replicate on write: %s%n"", cf_def.replicate_on_write);
				 if (cfMBean != null) {
					 sessionState.out.printf("" Built indexes: %s%n"", cfMBean.getBuiltIndexes());
				 }
				 if (cf_def.getColumn_metadataSize() != 0) {
					 String leftSpace = "" "";
					 String columnLeftSpace = leftSpace + "" "";
					 String compareWith = isSuper ? cf_def.subcomparator_type : cf_def.comparator_type;
					 AbstractType columnNameValidator = getFormatType(compareWith);
					 sessionState.out.println(leftSpace + ""Column Metadata:"");
					 for (ColumnDef columnDef : cf_def.getColumn_metadata()) {
						 String columnName = columnNameValidator.getString(columnDef.name);
						 if (columnNameValidator instanceof BytesType) {
							 try {
								 String columnString = UTF8Type.instance.getString(columnDef.name);
								 columnName = columnString + "" ("" + columnName + "")"";
							 }
							 catch (MarshalException e) {
							 }
						 }
						 sessionState.out.println(leftSpace + "" Column Name: "" + columnName);
						 sessionState.out.println(columnLeftSpace + ""Validation Class: "" + columnDef.getValidation_class());
						 if (columnDef.isSetIndex_name()) {
							 sessionState.out.println(columnLeftSpace + ""Index Name: "" + columnDef.getIndex_name());
						 }
						 if (columnDef.isSetIndex_type()) {
							 sessionState.out.println(columnLeftSpace + ""Index Type: "" + columnDef.getIndex_type().name());
						 }
					 }
				 }
			 }
			 if (compactionManagerMBean != null) {
				 for (CompactionInfo info : compactionManagerMBean.getCompactions()) {
					 if (info.getTaskType() != CompactionType.INDEX_BUILD) continue;
					 sessionState.out.printf(""%nCurrently building index %s, completed %d of %d bytes.%n"", info.getColumnFamily(), info.getBytesComplete(), info.getTotalBytes());
				 }
			 }
			 if (probe != null) probe.close();
		 }
		 catch (InvalidRequestException e) {
			 sessionState.out.println(""Invalid request: "" + e);
		 }
		 catch (NotFoundException e) {
			 sessionState.out.println(""Keyspace "" + keySpaceName + "" could not be found."");
		 }
		 catch (IOException e) {
			 sessionState.out.println(""Error while closing JMX connection: "" + e.getMessage());
		 }
	 }
	 private void executeDescribeKeySpace(Tree statement) throws TException, InvalidRequestException {
		 if (!CliMain.isConnected()) return;
		 String keySpaceName;
		 if (statement.getChildCount() == 0) {
			 keySpaceName = keySpace;
		 }
		 else {
			 keySpaceName = CliCompiler.getKeySpace(statement, thriftClient.describe_keyspaces());
		 }
		 if (keySpaceName == null) {
			 sessionState.out.println(""Keyspace argument required if you are not authorized in any keyspace."");
			 return;
		 }
		 describeKeySpace(keySpaceName, null);
	 }
	 private void executeDescribeCluster() {
		 if (!CliMain.isConnected()) return;
		 sessionState.out.println(""Cluster Information:"");
		 try {
			 sessionState.out.println("" Snitch: "" + thriftClient.describe_snitch());
			 sessionState.out.println("" Partitioner: "" + thriftClient.describe_partitioner());
			 sessionState.out.println("" Schema versions: "");
			 Map<String,List<String>> versions = thriftClient.describe_schema_versions();
			 for (String version : versions.keySet()) {
				 sessionState.out.println(""\t"" + version + "": "" + versions.get(version));
			 }
		 }
		 catch (Exception e) {
			 String message = (e instanceof InvalidRequestException) ? ((InvalidRequestException) e).getWhy() : e.getMessage();
			 sessionState.err.println(""Error retrieving data: "" + message);
		 }
	 }
	 private void executeConnect(Tree statement) {
		 Tree idList = statement.getChild(0);
		 int portNumber = Integer.parseInt(statement.getChild(1).getText());
		 StringBuilder hostName = new StringBuilder();
		 int idCount = idList.getChildCount();
		 for (int idx = 0;
		 idx < idCount;
		 idx++) {
			 hostName.append(idList.getChild(idx).getText());
		 }
		 CliMain.disconnect();
		 sessionState.hostName = hostName.toString();
		 sessionState.thriftPort = portNumber;
		 if (statement.getChildCount() == 4) {
			 sessionState.username = statement.getChild(2).getText();
			 sessionState.password = CliUtils.unescapeSQLString(statement.getChild(3).getText());
		 }
		 CliMain.connect(sessionState.hostName, sessionState.thriftPort);
	 }
	 private CfDef getCfDef(String keySpaceName, String columnFamilyName) {
		 KsDef keySpaceDefinition = keyspacesMap.get(keySpaceName);
		 for (CfDef columnFamilyDef : keySpaceDefinition.cf_defs) {
			 if (columnFamilyDef.name.equals(columnFamilyName)) {
				 return columnFamilyDef;
			 }
		 }
		 throw new RuntimeException(""No such column family: "" + columnFamilyName);
	 }
	 private CfDef getCfDef(String columnFamilyName) {
		 return getCfDef(this.keySpace, columnFamilyName);
	 }
	 private CfDef getCfDef(KsDef keyspace, String columnFamilyName) {
		 for (CfDef cfDef : keyspace.cf_defs) {
			 if (cfDef.name.equals(columnFamilyName)) return cfDef;
		 }
		 return null;
	 }
	 private List<ColumnDef> getCFColumnMetaFromTree(CfDef cfDef, Tree meta) {
		 List<ColumnDef> columnDefinitions = new ArrayList<ColumnDef>();
		 for (int i = 0;
		 i < meta.getChildCount();
		 i++) {
			 Tree metaHash = meta.getChild(i);
			 ColumnDef columnDefinition = new ColumnDef();
			 for (int j = 0;
			 j < metaHash.getChildCount();
			 j++) {
				 Tree metaPair = metaHash.getChild(j);
				 String metaKey = CliUtils.unescapeSQLString(metaPair.getChild(0).getText());
				 String metaVal = CliUtils.unescapeSQLString(metaPair.getChild(1).getText());
				 if (metaKey.equals(""column_name"")) {
					 if (cfDef.column_type.equals(""Super"")) columnDefinition.setName(subColumnNameAsByteArray(metaVal, cfDef));
					 else columnDefinition.setName(columnNameAsByteArray(metaVal, cfDef));
				 }
				 else if (metaKey.equals(""validation_class"")) {
					 columnDefinition.setValidation_class(metaVal);
				 }
				 else if (metaKey.equals(""index_type"")) {
					 columnDefinition.setIndex_type(getIndexTypeFromString(metaVal));
				 }
				 else if (metaKey.equals(""index_name"")) {
					 columnDefinition.setIndex_name(metaVal);
				 }
			 }
			 try {
				 columnDefinition.validate();
			 }
			 catch (TException e) {
				 throw new RuntimeException(e.getMessage(), e);
			 }
			 columnDefinitions.add(columnDefinition);
		 }
		 return columnDefinitions;
	 }
	 private IndexType getIndexTypeFromString(String indexTypeAsString) {
		 IndexType indexType;
		 try {
			 indexType = IndexType.findByValue(new Integer(indexTypeAsString));
		 }
		 catch (NumberFormatException e) {
			 try {
				 indexType = IndexType.valueOf(indexTypeAsString);
			 }
			 catch (IllegalArgumentException ie) {
				 throw new RuntimeException(""IndexType '"" + indexTypeAsString + ""' is unsupported."");
			 }
		 }
		 if (indexType == null) {
			 throw new RuntimeException(""IndexType '"" + indexTypeAsString + ""' is unsupported."");
		 }
		 return indexType;
	 }
	 private ByteBuffer getBytesAccordingToType(String object, AbstractType comparator) {
		 if (comparator == null) comparator = BytesType.instance;
		 try {
			 return comparator.fromString(object);
		 }
		 catch (MarshalException e) {
			 throw new RuntimeException(e.toString());
		 }
	 }
	 private ByteBuffer columnNameAsBytes(String column, String columnFamily) {
		 CfDef columnFamilyDef = getCfDef(columnFamily);
		 return columnNameAsBytes(column, columnFamilyDef);
	 }
	 private ByteBuffer columnNameAsBytes(String column, CfDef columnFamilyDef) {
		 String comparatorClass = columnFamilyDef.comparator_type;
		 return getBytesAccordingToType(column, getFormatType(comparatorClass));
	 }
	 private byte[] columnNameAsByteArray(String column, String columnFamily) {
		 return TBaseHelper.byteBufferToByteArray(columnNameAsBytes(column, columnFamily));
	 }
	 private byte[] columnNameAsByteArray(String column, CfDef cfDef) {
		 return TBaseHelper.byteBufferToByteArray(columnNameAsBytes(column, cfDef));
	 }
	 private ByteBuffer subColumnNameAsBytes(String superColumn, String columnFamily) {
		 CfDef columnFamilyDef = getCfDef(columnFamily);
		 return subColumnNameAsBytes(superColumn, columnFamilyDef);
	 }
	 private ByteBuffer subColumnNameAsBytes(String superColumn, CfDef columnFamilyDef) {
		 String comparatorClass = columnFamilyDef.subcomparator_type;
		 if (comparatorClass == null) {
			 sessionState.out.println(String.format(""Notice: defaulting to BytesType subcomparator for '%s'"", columnFamilyDef.getName()));
			 comparatorClass = ""BytesType"";
		 }
		 return getBytesAccordingToType(superColumn, getFormatType(comparatorClass));
	 }
	 private byte[] subColumnNameAsByteArray(String superColumn, CfDef cfDef) {
		 return TBaseHelper.byteBufferToByteArray(subColumnNameAsBytes(superColumn, cfDef));
	 }
	 private ByteBuffer columnValueAsBytes(ByteBuffer columnName, String columnFamilyName, String columnValue) {
		 CfDef columnFamilyDef = getCfDef(columnFamilyName);
		 for (ColumnDef columnDefinition : columnFamilyDef.getColumn_metadata()) {
			 byte[] currentColumnName = columnDefinition.getName();
			 if (ByteBufferUtil.compare(currentColumnName, columnName) == 0) {
				 try {
					 String validationClass = columnDefinition.getValidation_class();
					 return getBytesAccordingToType(columnValue, getFormatType(validationClass));
				 }
				 catch (Exception e) {
					 throw new RuntimeException(e.getMessage(), e);
				 }
			 }
		 }
		 return ByteBufferUtil.bytes(columnValue);
	 }
	 private AbstractType getValidatorForValue(CfDef ColumnFamilyDef, byte[] columnNameInBytes) {
		 String defaultValidator = ColumnFamilyDef.default_validation_class;
		 for (ColumnDef columnDefinition : ColumnFamilyDef.getColumn_metadata()) {
			 byte[] nameInBytes = columnDefinition.getName();
			 if (Arrays.equals(nameInBytes, columnNameInBytes)) {
				 return getFormatType(columnDefinition.getValidation_class());
			 }
		 }
		 if (defaultValidator != null && !defaultValidator.isEmpty()) {
			 return getFormatType(defaultValidator);
		 }
		 return null;
	 }
	 private Map<String, String> getStrategyOptionsFromTree(Tree options) {
		 Map<String, String> strategyOptions = new HashMap<String, String>();
		 for (int i = 0;
		 i < options.getChildCount();
		 i++) {
			 Tree optionsHash = options.getChild(i);
			 for (int j = 0;
			 j < optionsHash.getChildCount();
			 j++) {
				 Tree optionPair = optionsHash.getChild(j);
				 String key = CliUtils.unescapeSQLString(optionPair.getChild(0).getText());
				 String val = CliUtils.unescapeSQLString(optionPair.getChild(1).getText());
				 strategyOptions.put(key, val);
			 }
		 }
		 return strategyOptions;
	 }
	 private ByteBuffer convertValueByFunction(Tree functionCall, CfDef columnFamily, ByteBuffer columnName) {
		 return convertValueByFunction(functionCall, columnFamily, columnName, false);
	 }
	 private ByteBuffer convertValueByFunction(Tree functionCall, CfDef columnFamily, ByteBuffer columnName, boolean withUpdate) {
		 String functionName = functionCall.getChild(0).getText();
		 Tree argumentTree = functionCall.getChild(1);
		 String functionArg = (argumentTree == null) ? """" : CliUtils.unescapeSQLString(argumentTree.getText());
		 AbstractType validator = getTypeByFunction(functionName);
		 try {
			 ByteBuffer value;
			 if (functionArg.isEmpty()) {
				 if (validator instanceof TimeUUIDType) {
					 value = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes());
				 }
				 else if (validator instanceof LexicalUUIDType) {
					 value = ByteBuffer.wrap(UUIDGen.decompose(UUID.randomUUID()));
				 }
				 else if (validator instanceof BytesType) {
					 value = ByteBuffer.wrap(new byte[0]);
				 }
				 else {
					 throw new RuntimeException(String.format(""Argument for '%s' could not be empty."", functionName));
				 }
			 }
			 else {
				 value = getBytesAccordingToType(functionArg, validator);
			 }
			 if (withUpdate) {
				 updateColumnMetaData(columnFamily, columnName, validator.toString());
			 }
			 return value;
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage());
		 }
	 }
	 public static AbstractType getTypeByFunction(String functionName) {
		 Function function;
		 try {
			 function = Function.valueOf(functionName.toUpperCase());
		 }
		 catch (IllegalArgumentException e) {
			 StringBuilder errorMessage = new StringBuilder(""Function '"" + functionName + ""' not found. "");
			 errorMessage.append(""Available functions: "");
			 throw new RuntimeException(errorMessage.append(Function.getFunctionNames()).toString());
		 }
		 return function.getValidator();
	 }
	 private void updateColumnMetaData(CfDef columnFamily, ByteBuffer columnName, String validationClass) {
		 List<ColumnDef> columnMetaData = columnFamily.getColumn_metadata();
		 ColumnDef column = getColumnDefByName(columnFamily, columnName);
		 if (column != null) {
			 if (column.getValidation_class().equals(validationClass)) return;
			 column.setValidation_class(validationClass);
		 }
		 else {
			 columnMetaData.add(new ColumnDef(columnName, validationClass));
		 }
	 }
	 private ColumnDef getColumnDefByName(CfDef columnFamily, ByteBuffer columnName) {
		 for (ColumnDef columnDef : columnFamily.getColumn_metadata()) {
			 byte[] currName = columnDef.getName();
			 if (ByteBufferUtil.compare(currName, columnName) == 0) {
				 return columnDef;
			 }
		 }
		 return null;
	 }
	 private void printSliceList(CfDef columnFamilyDef, List<KeySlice> slices) throws NotFoundException, TException, IllegalAccessException, InstantiationException, NoSuchFieldException, CharacterCodingException {
		 AbstractType validator;
		 String columnFamilyName = columnFamilyDef.getName();
		 AbstractType keyComparator = getKeyComparatorForCF(columnFamilyName);
		 for (KeySlice ks : slices) {
			 String keyName = (keyComparator == null) ? ByteBufferUtil.string(ks.key) : keyComparator.getString(ks.key);
			 sessionState.out.printf(""-------------------%n"");
			 sessionState.out.printf(""RowKey: %s%n"", keyName);
			 Iterator<ColumnOrSuperColumn> iterator = ks.getColumnsIterator();
			 while (iterator.hasNext()) {
				 ColumnOrSuperColumn columnOrSuperColumn = iterator.next();
				 if (columnOrSuperColumn.column != null) {
					 Column col = columnOrSuperColumn.column;
					 validator = getValidatorForValue(columnFamilyDef, col.getName());
					 sessionState.out.printf(""=> (column=%s, value=%s, timestamp=%d%s)%n"", formatColumnName(keySpace, columnFamilyName, col.name), validator.getString(col.value), col.timestamp, col.isSetTtl() ? String.format("", ttl=%d"", col.getTtl()) : """");
				 }
				 else if (columnOrSuperColumn.super_column != null) {
					 SuperColumn superCol = columnOrSuperColumn.super_column;
					 sessionState.out.printf(""=> (super_column=%s,"", formatColumnName(keySpace, columnFamilyName, superCol.name));
					 for (Column col : superCol.columns) {
						 validator = getValidatorForValue(columnFamilyDef, col.getName());
						 sessionState.out.printf(""%n (column=%s, value=%s, timestamp=%d%s)"", formatSubcolumnName(keySpace, columnFamilyName, col.name), validator.getString(col.value), col.timestamp, col.isSetTtl() ? String.format("", ttl=%d"", col.getTtl()) : """");
					 }
					 sessionState.out.println("")"");
				 }
				 else if (columnOrSuperColumn.counter_column != null) {
					 CounterColumn col = columnOrSuperColumn.counter_column;
					 sessionState.out.printf(""=> (counter=%s, value=%s)%n"", formatColumnName(keySpace, columnFamilyName, col.name), col.value);
				 }
				 else if (columnOrSuperColumn.counter_super_column != null) {
					 CounterSuperColumn superCol = columnOrSuperColumn.counter_super_column;
					 sessionState.out.printf(""=> (super_column=%s,"", formatColumnName(keySpace, columnFamilyName, superCol.name));
					 for (CounterColumn col : superCol.columns) {
						 sessionState.out.printf(""%n (counter=%s, value=%s)"", formatSubcolumnName(keySpace, columnFamilyName, col.name), col.value);
					 }
					 sessionState.out.println("")"");
				 }
			 }
		 }
		 sessionState.out.printf(""%n%d Row%s Returned.%n"", slices.size(), (slices.size() > 1 ? ""s"" : """"));
	 }
	 private String formatSubcolumnName(String keyspace, String columnFamily, ByteBuffer name) throws NotFoundException, TException, IllegalAccessException, InstantiationException, NoSuchFieldException {
		 return getFormatType(getCfDef(keyspace, columnFamily).subcomparator_type).getString(name);
	 }
	 private String formatColumnName(String keyspace, String columnFamily, ByteBuffer name) throws NotFoundException, TException, IllegalAccessException, InstantiationException, NoSuchFieldException {
		 return getFormatType(getCfDef(keyspace, columnFamily).comparator_type).getString(name);
	 }
	 private ByteBuffer getColumnName(String columnFamily, Tree columnTree) {
		 return (columnTree.getType() == CliParser.FUNCTION_CALL) ? convertValueByFunction(columnTree, null, null) : columnNameAsBytes(CliUtils.unescapeSQLString(columnTree.getText()), columnFamily);
	 }
	 private ByteBuffer getSubColumnName(String columnFamily, Tree columnTree) {
		 return (columnTree.getType() == CliParser.FUNCTION_CALL) ? convertValueByFunction(columnTree, null, null) : subColumnNameAsBytes(CliUtils.unescapeSQLString(columnTree.getText()), columnFamily);
	 }
	 public ByteBuffer getKeyAsBytes(String columnFamily, Tree keyTree) {
		 if (keyTree.getType() == CliParser.FUNCTION_CALL) return convertValueByFunction(keyTree, null, null);
		 String key = CliUtils.unescapeSQLString(keyTree.getText());
		 return getBytesAccordingToType(key, getKeyComparatorForCF(columnFamily));
	 }
	 private AbstractType getKeyComparatorForCF(String columnFamily) {
		 AbstractType keyComparator = cfKeysComparators.get(columnFamily);
		 if (keyComparator == null) {
			 String defaultValidationClass = getCfDef(columnFamily).getKey_validation_class();
			 assert defaultValidationClass != null;
			 keyComparator = getFormatType(defaultValidationClass);
		 }
		 return keyComparator;
	 }
	 private static class KsDefNamesComparator implements Comparator<KsDef> {
		 public int compare(KsDef a, KsDef b) {
			 return a.name.compareTo(b.name);
		 }
	 }
	 private void validateSchemaIsSettled(String currentVersionId) {
		 sessionState.out.println(""Waiting for schema agreement..."");
		 Map<String, List<String>> versions = null;
		 long limit = System.currentTimeMillis() + sessionState.schema_mwt;
		 boolean inAgreement = false;
		 outer: while (limit - System.currentTimeMillis() >= 0 && !inAgreement) {
			 try {
				 versions = thriftClient.describe_schema_versions();
			 }
			 catch (Exception e) {
				 sessionState.err.println((e instanceof InvalidRequestException) ? ((InvalidRequestException) e).getWhy() : e.getMessage());
				 continue;
			 }
			 for (String version : versions.keySet()) {
				 if (!version.equals(currentVersionId) && !version.equals(StorageProxy.UNREACHABLE)) continue outer;
			 }
			 inAgreement = true;
		 }
		 if (versions.containsKey(StorageProxy.UNREACHABLE)) sessionState.err.printf(""Warning: unreachable nodes %s"", Joiner.on("", "").join(versions.get(StorageProxy.UNREACHABLE)));
		 if (!inAgreement) {
			 sessionState.err.printf(""The schema has not settled in %d seconds;
			 further migrations are ill-advised until it does.%nVersions are %s%n"", sessionState.schema_mwt / 1000, FBUtilities.toString(versions));
			 System.exit(-1);
		 }
		 sessionState.out.println(""... schemas agree across the cluster"");
	 }
	 private static class CfDefNamesComparator implements Comparator<CfDef> {
		 public int compare(CfDef a, CfDef b) {
			 return a.name.compareTo(b.name);
		 }
	 }
	 private boolean isCounterCF(CfDef cfdef) {
		 String defaultValidator = cfdef.default_validation_class;
		 if (defaultValidator != null && !defaultValidator.isEmpty()) {
			 return (getFormatType(defaultValidator) instanceof CounterColumnType);
		 }
		 return false;
	 }
}",1,0,0,0
"private final class ExceptionXmlErrorListener extends AbstractCollection {
	 public boolean add(Object o) {
		 assert ValidatingXMLInputStream.this._exception == null;
		 ValidatingXMLInputStream.this._exception = new XMLStreamValidationException( (XmlError)o );
		 return false;
	 }
	 public Iterator iterator() {
		 return Collections.EMPTY_LIST.iterator();
	 }
	 public int size() {
		 return 0;
	 }
 }",0,0,0,0
"public void createBalancedTrainingSet(int count) {
	 DataSet balanced = new DataSet(54, 7);
	 int firstType = 0;
	 int secondType = 0;
	 int thirdType = 0;
	 int fourthType = 0;
	 int fifthType = 0;
	 int sixthType = 0;
	 int seventhType = 0;
	 DataSet trainingSet = DataSet.load(config.getTrainingFileName());
	 List<DataSetRow> rows = trainingSet.getRows();
	 System.out.println(""Test set size: "" + rows.size() + "" rows. "");
	 for (DataSetRow row : rows) {
		 double[] DesiredOutput = row.getDesiredOutput();
		 int index = -1;
		 for (int i = 0;
		 i < DesiredOutput.length;
		 i++) {
			 if (DesiredOutput[i] == 1.0) {
				 index = i;
				 break;
			 }
		 }
		 switch (index + 1) {
			 case 1: if (firstType < count) {
				 balanced.addRow(row);
				 firstType++;
			 }
			 break;
			 case 2: if (secondType < count) {
				 balanced.addRow(row);
				 secondType++;
			 }
			 break;
			 case 3: if (thirdType < count) {
				 balanced.addRow(row);
				 thirdType++;
			 }
			 break;
			 case 4: if (fourthType < count) {
				 balanced.addRow(row);
				 fourthType++;
			 }
			 break;
			 case 5: if (fifthType < count) {
				 balanced.addRow(row);
				 fifthType++;
			 }
			 break;
			 case 6: if (sixthType < count) {
				 balanced.addRow(row);
				 sixthType++;
			 }
			 break;
			 case 7: if (seventhType < count) {
				 balanced.addRow(row);
				 seventhType++;
			 }
			 break;
			 default: System.out.println(""Error with output vector size! "");
		 }
	 }
	 System.out.println(""Balanced test set size: "" + balanced.getRows().size() + "" rows. "");
	 System.out.println(""Samples per tree: "");
	 System.out.println(""First type: "" + firstType + "" samples. "");
	 System.out.println(""Second type: "" + secondType + "" samples. "");
	 System.out.println(""Third type: "" + thirdType + "" samples. "");
	 System.out.println(""Fourth type: "" + fourthType + "" samples. "");
	 System.out.println(""Fifth type: "" + fifthType + "" samples. "");
	 System.out.println(""Sixth type: "" + sixthType + "" samples. "");
	 System.out.println(""Seventh type: "" + seventhType + "" samples. "");
	 balanced.save(config.getBalancedFileName());
 }",0,0,1,0
"public abstract class BaseFilterReader extends FilterReader {
	 private static final int BUFFER_SIZE = 8192;
	 private boolean initialized = false;
	 private Project project = null;
	 public BaseFilterReader() {
		 super(new StringReader(""""));
		 FileUtils.close(this);
	 }
	 public BaseFilterReader(final Reader in) {
		 super(in);
	 }
	 public final int read(final char[] cbuf, final int off, final int len) throws IOException {
		 for (int i = 0;
		 i < len;
		 i++) {
			 final int ch = read();
			 if (ch == -1) {
				 if (i == 0) {
					 return -1;
				 }
				 else {
					 return i;
				 }
			 }
			 cbuf[off + i] = (char) ch;
		 }
		 return len;
	 }
	 public final long skip(final long n) throws IOException, IllegalArgumentException {
		 if (n < 0L) {
			 throw new IllegalArgumentException(""skip value is negative"");
		 }
		 for (long i = 0;
		 i < n;
		 i++) {
			 if (read() == -1) {
				 return i;
			 }
		 }
		 return n;
	 }
	 protected final void setInitialized(final boolean initialized) {
		 this.initialized = initialized;
	 }
	 protected final boolean getInitialized() {
		 return initialized;
	 }
	 public final void setProject(final Project project) {
		 this.project = project;
	 }
	 protected final Project getProject() {
		 return project;
	 }
	 protected final String readLine() throws IOException {
		 int ch = in.read();
		 if (ch == -1) {
			 return null;
		 }
		 StringBuffer line = new StringBuffer();
		 while (ch != -1) {
			 line.append ((char) ch);
			 if (ch == '\n') {
				 break;
			 }
			 ch = in.read();
		 }
		 return line.toString();
	 }
	 protected final String readFully() throws IOException {
		 return FileUtils.readFully(in, BUFFER_SIZE);
	 }
}",0,0,0,0
"public void execute() throws BuildException {
	 validate();
	 addCommandArgument(""rdiff"");
	 addCommandArgument(""-s"");
	 if (mystartTag != null) {
		 addCommandArgument(""-r"");
		 addCommandArgument(mystartTag);
	 }
	 else {
		 addCommandArgument(""-D"");
		 addCommandArgument(mystartDate);
	 }
	 if (myendTag != null) {
		 addCommandArgument(""-r"");
		 addCommandArgument(myendTag);
	 }
	 else {
		 addCommandArgument(""-D"");
		 addCommandArgument(myendDate);
	 }
	 StringTokenizer myTokenizer = new StringTokenizer(mypackage);
	 while (myTokenizer.hasMoreTokens()) {
		 addCommandArgument(myTokenizer.nextToken());
	 }
	 setCommand("""");
	 File tmpFile = null;
	 try {
		 tmpFile = FILE_UTILS.createTempFile(""cvstagdiff"", "".log"", null, true, true);
		 setOutput(tmpFile);
		 super.execute();
		 CvsTagEntry[] entries = parseRDiff(tmpFile);
		 writeTagDiff(entries);
	 }
	 finally {
		 if (tmpFile != null) {
			 tmpFile.delete();
		 }
	 }
 }",0,0,0,0
"public double calculateDaycountFraction(Calendar startCalendar,Calendar endCalendar) throws DaycountException;",0,0,0,0
"public static void main(String[] args) throws IOException {
	 try (XSSFWorkbook wb = new XSSFWorkbook()) {
		 XSSFSheet sheet = wb.createSheet(""linechart"");
		 final int NUM_OF_ROWS = 3;
		 final int NUM_OF_COLUMNS = 10;
		 Row row;
		 Cell cell;
		 for (int rowIndex = 0;
		 rowIndex < NUM_OF_ROWS;
		 rowIndex++) {
			 row = sheet.createRow((short) rowIndex);
			 for (int colIndex = 0;
			 colIndex < NUM_OF_COLUMNS;
			 colIndex++) {
				 cell = row.createCell((short) colIndex);
				 cell.setCellValue(colIndex * (rowIndex + 1.0));
			 }
		 }
		 XSSFDrawing drawing = sheet.createDrawingPatriarch();
		 XSSFClientAnchor anchor = drawing.createAnchor(0, 0, 0, 0, 0, 5, 10, 15);
		 XSSFChart chart = drawing.createChart(anchor);
		 XDDFChartLegend legend = chart.getOrAddLegend();
		 legend.setPosition(LegendPosition.TOP_RIGHT);
		 XDDFCategoryAxis bottomAxis = chart.createCategoryAxis(AxisPosition.BOTTOM);
		 bottomAxis.setTitle(""x"");
		 XDDFValueAxis leftAxis = chart.createValueAxis(AxisPosition.LEFT);
		 leftAxis.setTitle(""f(x)"");
		 leftAxis.setCrosses(AxisCrosses.AUTO_ZERO);
		 XDDFDataSource<Double> xs = XDDFDataSourcesFactory.fromNumericCellRange(sheet, new CellRangeAddress(0, 0, 0, NUM_OF_COLUMNS - 1));
		 XDDFNumericalDataSource<Double> ys1 = XDDFDataSourcesFactory.fromNumericCellRange(sheet, new CellRangeAddress(1, 1, 0, NUM_OF_COLUMNS - 1));
		 XDDFNumericalDataSource<Double> ys2 = XDDFDataSourcesFactory.fromNumericCellRange(sheet, new CellRangeAddress(2, 2, 0, NUM_OF_COLUMNS - 1));
		 XDDFLineChartData data = (XDDFLineChartData) chart.createData(ChartTypes.LINE, bottomAxis, leftAxis);
		 XDDFLineChartData.Series series1 = (XDDFLineChartData.Series) data.addSeries(xs, ys1);
		 series1.setTitle(""2x"", null);
		 series1.setSmooth(false);
		 series1.setMarkerStyle(MarkerStyle.STAR);
		 XDDFLineChartData.Series series2 = (XDDFLineChartData.Series) data.addSeries(xs, ys2);
		 series2.setTitle(""3x"", null);
		 series2.setSmooth(true);
		 series2.setMarkerSize((short) 6);
		 series2.setMarkerStyle(MarkerStyle.TRIANGLE);
		 chart.plot(data);
		 solidLineSeries(data, 0, PresetColor.CHARTREUSE);
		 solidLineSeries(data, 1, PresetColor.TURQUOISE);
		 try (FileOutputStream fileOut = new FileOutputStream(""ooxml-line-chart.xlsx"")) {
			 wb.write(fileOut);
		 }
	 }
 }",0,0,1,0
"public class FullAnalyzer extends AbstractAnalyzer {
	 public FullAnalyzer() {
		 try {
			 new ClassParser(""force"");
		 }
		 catch (Exception e) {
			 if (!(e instanceof IOException)) {
				 throw new BuildException(e);
			 }
		 }
	 }
	 protected void determineDependencies(Vector files, Vector classes) {
		 Hashtable dependencies = new Hashtable();
		 Hashtable containers = new Hashtable();
		 Hashtable toAnalyze = new Hashtable();
		 for (Enumeration e = getRootClasses();
		 e.hasMoreElements();
		) {
			 String classname = (String) e.nextElement();
			 toAnalyze.put(classname, classname);
		 }
		 int count = 0;
		 int maxCount = isClosureRequired() ? MAX_LOOPS : 2;
		 while (toAnalyze.size() != 0 && count++ < maxCount) {
			 DependencyVisitor dependencyVisitor = new DependencyVisitor();
			 for (Enumeration e = toAnalyze.keys();
			 e.hasMoreElements();
			) {
				 String classname = (String) e.nextElement();
				 dependencies.put(classname, classname);
				 try {
					 File container = getClassContainer(classname);
					 if (container == null) {
						 continue;
					 }
					 containers.put(container, container);
					 ClassParser parser = null;
					 if (container.getName().endsWith("".class"")) {
						 parser = new ClassParser(container.getPath());
					 }
					 else {
						 parser = new ClassParser(container.getPath(), classname.replace('.', '/') + "".class"");
					 }
					 JavaClass javaClass = parser.parse();
					 DescendingVisitor traverser = new DescendingVisitor(javaClass, dependencyVisitor);
					 traverser.visit();
				 }
				 catch (IOException ioe) {
				 }
			 }
			 toAnalyze.clear();
			 Enumeration depsEnum = dependencyVisitor.getDependencies();
			 while (depsEnum.hasMoreElements()) {
				 String className = (String) depsEnum.nextElement();
				 if (!dependencies.containsKey(className)) {
					 toAnalyze.put(className, className);
				 }
			 }
		 }
		 files.removeAllElements();
		 for (Enumeration e = containers.keys();
		 e.hasMoreElements();
		) {
			 files.addElement((File) e.nextElement());
		 }
		 classes.removeAllElements();
		 for (Enumeration e = dependencies.keys();
		 e.hasMoreElements();
		) {
			 classes.addElement((String) e.nextElement());
		 }
	 }
	 protected boolean supportsFileDependencies() {
		 return true;
	 }
}",0,0,0,0
"private void initComponents(){
	java.awt.GridBagConstraints gridBagConstraints;
	jScrollPane1 = new javax.swing.JScrollPane();
	m_itemList = new javax.swing.JList();
	m_buttonAdd = new javax.swing.JButton();
	m_buttonRemove = new javax.swing.JButton();
	m_buttonEdit = new javax.swing.JButton();
	jSeparator1 = new javax.swing.JSeparator();
	m_buttonUp = new javax.swing.JButton();
	m_buttonDown = new javax.swing.JButton();
	setLayout(new java.awt.GridBagLayout());
	jScrollPane1.setViewportView(m_itemList);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridx = 1;
	gridBagConstraints.gridwidth = 4;
	gridBagConstraints.gridheight = 8;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.weightx = 1.0;
	gridBagConstraints.weighty = 1.0;
	add(jScrollPane1, gridBagConstraints);
	m_buttonAdd.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_insert-element.png"")));
	m_buttonAdd.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			buttonAddActionPerformed(evt);
		}
	}
	);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	add(m_buttonAdd, gridBagConstraints);
	m_buttonRemove.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_remove-element.png"")));
	m_buttonRemove.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			buttonRemoveActionPerformed(evt);
		}
	}
	);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	add(m_buttonRemove, gridBagConstraints);
	m_buttonEdit.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_edit.png"")));
	m_buttonEdit.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			buttonEditActionPerformed(evt);
		}
	}
	);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	add(m_buttonEdit, gridBagConstraints);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.weighty = 1.0;
	gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
	add(jSeparator1, gridBagConstraints);
	m_buttonUp.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_up.png"")));
	m_buttonUp.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			buttonUpActionPerformed(evt);
		}
	}
	);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridy = 6;
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
	add(m_buttonUp, gridBagConstraints);
	m_buttonDown.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/stock_down.png"")));
	m_buttonDown.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			buttonDownActionPerformed(evt);
		}
	}
	);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridy = 7;
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
	add(m_buttonDown, gridBagConstraints);
}",0,0,1,0
"public class TemporaryFolderExtension implements ParameterResolver, BeforeEachCallback, AfterEachCallback {
	 private TemporaryFolder temporaryFolder;
	 public void beforeEach(ExtensionContext context) throws Exception {
		 temporaryFolder = new TemporaryFolder(Files.createTempDir());
	 }
	 public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
		 return (parameterContext.getParameter().getType() == TemporaryFolder.class);
	 }
	 public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
		 return temporaryFolder;
	 }
	 public void afterEach(ExtensionContext context) throws Exception {
		 FileUtils.deleteDirectory(temporaryFolder.getTempDir());
	 }
	 public TemporaryFolder getTemporaryFolder() {
		 return temporaryFolder;
	 }
	 public static class TemporaryFolder {
		 private final File tempDir;
		 private final String folderPath;
		 public TemporaryFolder(File tempDir) {
			 this.tempDir = tempDir;
			 this.folderPath = tempDir.getPath() + ""/"";
		 }
		 public File getTempDir() {
			 return tempDir;
		 }
		 public String getFolderPath() {
			 return folderPath;
		 }
	 }
}",0,1,0,0
"static private void loadPalettedImage(BinaryInputStream in, IconEntry entry, IconHeader header, BufferedImage image) throws Exception {
	int cols = (int)header.ColorsUsed;
	if (cols == 0) {
		if (entry.bColorCount != 0) cols = entry.bColorCount;
		else cols = 1 << header.BitsPerPixel;
	 }
	int[] redp = new int[cols];
	int[] greenp = new int[cols];
	int[] bluep = new int[cols];
	 for (int i=0;
	 i<cols;
	 i++) {
		bluep[i] = in.readUByte();
		greenp[i] = in.readUByte();
		redp[i] = in.readUByte();
		in.readUByte();
	 }
	int xorbytes = (((int)header.Height/2) * (int)header.Width);
	int readbytes = 0;
	for (int y=(int)(header.Height/2)-1;
	 y>=0;
	 y--) {
		for (int x=0;
		 x<header.Width;
		 x++) {
			switch(header.BitsPerPixel) {
				 case 4:{
					 int pix = in.readUByte();
					 readbytes++;
					 int col1 = (pix>>4) & 0x0F;
					 int col2 = pix & 0x0F;
					 image.setRGB(x, y, (0xFF<<24) | (redp[col1]<<16) | (greenp[col1]<<8) | bluep[col1]);
					 image.setRGB(++x, y, (0xFF<<24) | (redp[col2]<<16) | (greenp[col2]<<8) | bluep[col2]);
				}
				break;
				 case 8:{
					 int col1 = in.readUByte();
					 readbytes++;
					 image.setRGB(x, y, (0xFF<<24) | (redp[col1]<<16) | (greenp[col1]<<8) | bluep[col1]);
				}
				break;
			 }
		 }
	 }
	int height = (int)(header.Height/2);
	int rowsize = (int)header.Width / 8;
	if ((rowsize%4)>0) {
		rowsize += 4 - (rowsize%4);
	 }
	int[] andbytes = new int[rowsize * height ];
	for (int i=0;
	 i<andbytes.length;
	 i++) andbytes[i] = in.readUByte();
	for (int y=height-1;
	 y>=0;
	 y--) {
		for (int x=0;
		 x<header.Width;
		 x++) {
			int offset = ((height - (y+1))*rowsize) + (x/8);
			if ( (andbytes[offset] & (1<<(7-x%8))) != 0) {
				image.setRGB(x, y, 0);
			 }
		 }
	 }
 }",0,0,1,0
"public void startNext() throws IOException {
	 assert files.containsKey(currentFile);
	 files.get(currentFile).sstable.releaseReference();
	 files.remove(currentFile);
	 Iterator<PendingFile> iter = files.values().iterator();
	 if (iter.hasNext()) streamFile(iter.next());
 }",0,0,0,0
"public abstract class IMAPFolderCommand extends Command {
	protected IMAPRootFolder rootFolder;
	public IMAPFolderCommand(IMAPRootFolder rootFolder,DefaultCommandReference reference) {
		super(reference);
		this.rootFolder = rootFolder;
	}
	public IMAPRootFolder getIMAPRootFolder() {
		return rootFolder;
	}
}",1,0,0,0
"public abstract class TextTemplate extends AbstractStringResourceStream{
	private static final long serialVersionUID = 1L;
	public TextTemplate(){
	}
	public TextTemplate(String contentType){
		super(contentType);
	}
	public String asString(Map<String, Object> variables){
		if (variables != null){
			return new MapVariableInterpolator(getString(), variables).toString();
		}
		return getString();
	}
	public String asString(){
		return getString();
	}
	public abstract String getString();
	public abstract TextTemplate interpolate(Map<String, Object> variables);
}",0,0,0,0
"private class ExplorerTreeSelectionListener implements TreeSelectionListener {
	 public void valueChanged(TreeSelectionEvent e) {
		 Set<DataSource> selectedDataSources = getSelectedDataSources();
		 Set<ExplorerSelectionListener> listeners = new HashSet(selectionListeners);
		 for (ExplorerSelectionListener listener : listeners) listener.selectionChanged(selectedDataSources);
	 }
 }",0,0,0,0
"static final class Key {
	 final Object content;
	 final URI uri;
	 final URL url;
	 final String name;
	 final String mimeType;
	 final String language;
	 final String path;
	 final boolean internal;
	 final boolean interactive;
	 final boolean cached;
	 final boolean legacy;
	 Key(Object content, String mimeType, String languageId, URL url, URI uri, String name, String path, boolean internal, boolean interactive, boolean cached, boolean legacy) {
		 this.content = content;
		 this.mimeType = mimeType;
		 this.language = languageId;
		 this.name = name;
		 this.path = path;
		 this.internal = internal;
		 this.interactive = interactive;
		 this.cached = cached;
		 this.url = url;
		 this.uri = uri;
		 this.legacy = legacy;
	 }
	 public int hashCode() {
		 int result = 31 * 1 + ((content == null) ? 0 : content.hashCode());
		 result = 31 * result + (interactive ? 1231 : 1237);
		 result = 31 * result + (internal ? 1231 : 1237);
		 result = 31 * result + (cached ? 1231 : 1237);
		 result = 31 * result + ((language == null) ? 0 : language.hashCode());
		 result = 31 * result + ((mimeType == null) ? 0 : mimeType.hashCode());
		 result = 31 * result + ((name == null) ? 0 : name.hashCode());
		 result = 31 * result + ((path == null) ? 0 : path.hashCode());
		 result = 31 * result + ((uri == null) ? 0 : uri.hashCode());
		 result = 31 * result + ((url == null) ? 0 : url.hashCode());
		 return result;
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 else if (!(obj instanceof Key)) {
			 return false;
		 }
		 Key other = (Key) obj;
		 return Objects.equals(language, other.language) && Objects.equals(mimeType, other.mimeType) && Objects.equals(name, other.name) && Objects.equals(path, other.path) && Objects.equals(uri, other.uri) && Objects.equals(url, other.url) && interactive == other.interactive && internal == other.internal && cached == other.cached && compareContent(other);
	 }
	 private boolean compareContent(Key other) {
		 Object otherContent = other.content;
		 if (content == other.content) {
			 return true;
		 }
		 else if (content instanceof CharSequence && otherContent instanceof CharSequence) {
			 return compareCharacters((CharSequence) content, (CharSequence) otherContent);
		 }
		 else if (content instanceof ByteSequence && otherContent instanceof ByteSequence) {
			 return compareBytes((ByteSequence) content, (ByteSequence) otherContent);
		 }
		 else {
			 return false;
		 }
	 }
	 private static boolean compareBytes(ByteSequence bytes, ByteSequence other) {
		 if (bytes == null || bytes.length() != other.length()) {
			 return false;
		 }
		 else {
			 return bytes.equals(other);
		 }
	 }
	 private static boolean compareCharacters(CharSequence characters, CharSequence other) {
		 if (characters == null || characters.length() != other.length()) {
			 return false;
		 }
		 else {
			 return Objects.equals(characters.toString(), other.toString());
		 }
	 }
	 SourceImpl toSourceInterned() {
		 assert cached;
		 return new SourceImpl(this);
	 }
	 SourceImpl toSourceNotInterned() {
		 assert !cached;
		 return new SourceImpl(this, this);
	 }
 }",0,0,0,0
"static class NewTrackingRecordWriter<K,V> extends org.apache.hadoop.mapreduce.RecordWriter<K,V> {
	 private final org.apache.hadoop.mapreduce.RecordWriter<K,V> real;
	 private final org.apache.hadoop.mapreduce.Counter outputRecordCounter;
	 private final org.apache.hadoop.mapreduce.Counter fileOutputByteCounter;
	 private final List<Statistics> fsStats;
	 NewTrackingRecordWriter(ReduceTask reduce, org.apache.hadoop.mapreduce.TaskAttemptContext taskContext) throws InterruptedException, IOException {
		 this.outputRecordCounter = reduce.reduceOutputCounter;
		 this.fileOutputByteCounter = reduce.fileOutputByteCounter;
		 List<Statistics> matchedStats = null;
		 if (reduce.outputFormat instanceof org.apache.hadoop.mapreduce.lib.output.FileOutputFormat) {
			 matchedStats = getFsStatistics(org.apache.hadoop.mapreduce.lib.output.FileOutputFormat .getOutputPath(taskContext), taskContext.getConfiguration());
		 }
		 fsStats = matchedStats;
		 long bytesOutPrev = getOutputBytes(fsStats);
		 this.real = (org.apache.hadoop.mapreduce.RecordWriter<K, V>) reduce.outputFormat .getRecordWriter(taskContext);
		 long bytesOutCurr = getOutputBytes(fsStats);
		 fileOutputByteCounter.increment(bytesOutCurr - bytesOutPrev);
	 }
	 public void close(TaskAttemptContext context) throws IOException, InterruptedException {
		 long bytesOutPrev = getOutputBytes(fsStats);
		 real.close(context);
		 long bytesOutCurr = getOutputBytes(fsStats);
		 fileOutputByteCounter.increment(bytesOutCurr - bytesOutPrev);
	 }
	 public void write(K key, V value) throws IOException, InterruptedException {
		 long bytesOutPrev = getOutputBytes(fsStats);
		 real.write(key,value);
		 long bytesOutCurr = getOutputBytes(fsStats);
		 fileOutputByteCounter.increment(bytesOutCurr - bytesOutPrev);
		 outputRecordCounter.increment(1);
	 }
	 private long getOutputBytes(List<Statistics> stats) {
		 if (stats == null) return 0;
		 long bytesWritten = 0;
		 for (Statistics stat: stats) {
			 bytesWritten = bytesWritten + stat.getBytesWritten();
		 }
		 return bytesWritten;
	 }
 }",0,0,0,0
"public void reload() {
	 urlField.setText(Settings.getProperty(""davmail.url""));
	 popPortField.setText(Settings.getProperty(""davmail.popPort""));
	 popPortCheckBox.setSelected(Settings.getProperty(""davmail.popPort"") != null && Settings.getProperty(""davmail.popPort"").length() > 0);
	 popNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecurepop""));
	 imapPortField.setText(Settings.getProperty(""davmail.imapPort""));
	 imapPortCheckBox.setSelected(Settings.getProperty(""davmail.imapPort"") != null && Settings.getProperty(""davmail.imapPort"").length() > 0);
	 imapNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecureimap""));
	 smtpPortField.setText(Settings.getProperty(""davmail.smtpPort""));
	 smtpPortCheckBox.setSelected(Settings.getProperty(""davmail.smtpPort"") != null && Settings.getProperty(""davmail.smtpPort"").length() > 0);
	 smtpNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecuresmtp""));
	 caldavPortField.setText(Settings.getProperty(""davmail.caldavPort""));
	 caldavPortCheckBox.setSelected(Settings.getProperty(""davmail.caldavPort"") != null && Settings.getProperty(""davmail.caldavPort"").length() > 0);
	 caldavNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecurecaldav""));
	 ldapPortField.setText(Settings.getProperty(""davmail.ldapPort""));
	 ldapPortCheckBox.setSelected(Settings.getProperty(""davmail.ldapPort"") != null && Settings.getProperty(""davmail.ldapPort"").length() > 0);
	 ldapNoSSLCheckBox.setSelected(Settings.getBooleanProperty(""davmail.ssl.nosecureldap""));
	 keepDelayField.setText(Settings.getProperty(""davmail.keepDelay""));
	 sentKeepDelayField.setText(Settings.getProperty(""davmail.sentKeepDelay""));
	 caldavPastDelayField.setText(Settings.getProperty(""davmail.caldavPastDelay""));
	 imapIdleDelayField.setText(Settings.getProperty(""davmail.imapIdleDelay""));
	 boolean useSystemProxies = Settings.getBooleanProperty(""davmail.useSystemProxies"", Boolean.FALSE);
	 useSystemProxiesField.setSelected(useSystemProxies);
	 boolean enableProxy = Settings.getBooleanProperty(""davmail.enableProxy"");
	 enableProxyField.setSelected(enableProxy);
	 enableProxyField.setEnabled(!useSystemProxies);
	 httpProxyField.setEnabled(!useSystemProxies && enableProxy);
	 httpProxyPortField.setEnabled(!useSystemProxies && enableProxy);
	 httpProxyUserField.setEnabled(useSystemProxies || enableProxy);
	 httpProxyPasswordField.setEnabled(useSystemProxies || enableProxy);
	 noProxyForField.setEnabled(useSystemProxies || enableProxy);
	 httpProxyField.setText(Settings.getProperty(""davmail.proxyHost""));
	 httpProxyPortField.setText(Settings.getProperty(""davmail.proxyPort""));
	 httpProxyUserField.setText(Settings.getProperty(""davmail.proxyUser""));
	 httpProxyPasswordField.setText(Settings.getProperty(""davmail.proxyPassword""));
	 noProxyForField.setText(Settings.getProperty(""davmail.noProxyFor""));
	 bindAddressField.setText(Settings.getProperty(""davmail.bindAddress""));
	 allowRemoteField.setSelected(Settings.getBooleanProperty((""davmail.allowRemote"")));
	 certHashField.setText(Settings.getProperty(""davmail.server.certificate.hash""));
	 disableUpdateCheck.setSelected(Settings.getBooleanProperty((""davmail.disableUpdateCheck"")));
	 caldavEditNotificationsField.setSelected(Settings.getBooleanProperty(""davmail.caldavEditNotifications""));
	 clientSoTimeoutField.setText(Settings.getProperty(""davmail.clientSoTimeout""));
	 caldavAlarmSoundField.setText(Settings.getProperty(""davmail.caldavAlarmSound""));
	 forceActiveSyncUpdateCheckBox.setSelected(Settings.getBooleanProperty(""davmail.forceActiveSyncUpdate""));
	 defaultDomainField.setText(Settings.getProperty(""davmail.defaultDomain""));
	 showStartupBannerCheckBox.setSelected(Settings.getBooleanProperty(""davmail.showStartupBanner"", true));
	 disableGuiNotificationsCheckBox.setSelected(Settings.getBooleanProperty(""davmail.disableGuiNotifications"", false));
	 imapAutoExpungeCheckBox.setSelected(Settings.getBooleanProperty(""davmail.imapAutoExpunge"", true));
	 enableKeepAliveCheckBox.setSelected(Settings.getBooleanProperty(""davmail.enableKeepAlive"", false));
	 popMarkReadOnRetrCheckBox.setSelected(Settings.getBooleanProperty(""davmail.popMarkReadOnRetrCheckBox"", false));
	 setEwsModeSelectedItem(Settings.getProperty(""davmail.enableEws"", ""auto""));
	 smtpSaveInSentCheckBox.setSelected(Settings.getBooleanProperty(""davmail.smtpSaveInSent"", true));
	 enableKerberosCheckBox.setSelected(Settings.getBooleanProperty(""davmail.enableKerberos"", false));
	 folderSizeLimitField.setText(Settings.getProperty(""davmail.folderSizeLimit""));
	 keystoreTypeCombo.setSelectedItem(Settings.getProperty(""davmail.ssl.keystoreType""));
	 keystoreFileField.setText(Settings.getProperty(""davmail.ssl.keystoreFile""));
	 keystorePassField.setText(Settings.getProperty(""davmail.ssl.keystorePass""));
	 keyPassField.setText(Settings.getProperty(""davmail.ssl.keyPass""));
	 clientKeystoreTypeCombo.setSelectedItem(Settings.getProperty(""davmail.ssl.clientKeystoreType""));
	 pkcs11LibraryField.setText(Settings.getProperty(""davmail.ssl.pkcs11Library""));
	 pkcs11ConfigField.setText(Settings.getProperty(""davmail.ssl.pkcs11Config""));
	 rootLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""rootLogger""));
	 davmailLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""davmail""));
	 httpclientLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""org.apache.commons.httpclient""));
	 wireLoggingLevelField.setSelectedItem(Settings.getLoggingLevel(""httpclient.wire""));
	 logFilePathField.setText(Settings.getProperty(""davmail.logFilePath""));
	 logFileSizeField.setText(Settings.getProperty(""davmail.logFileSize""));
	 if (osxHideFromDockCheckBox != null) {
		 osxHideFromDockCheckBox.setSelected(OSXInfoPlist.isHideFromDock());
	 }
 }",0,0,1,0
"public class ClientMessageId{
	 public String msgid;
	 public ClientMessageId(String msgid) {
		 this.msgid = msgid;
	 }
}",0,0,0,0
"public synchronized OutputStream getErrorStream() {
	 return errorStream;
 }",0,0,0,0
"public abstract static class Builder {
	 public abstract Builder setCompileTimeConstant(boolean compileTimeConstant);
	 public abstract Builder setStatic(boolean isStatic);
	 public abstract Builder setFinal(boolean isFinal);
	 public abstract Builder setVariableCapture(boolean isVariableCapture);
	 public abstract Builder setEnclosingInstanceCapture(boolean isEnclosingInstanceCapture);
	 public abstract Builder setEnclosingTypeDescriptor( DeclaredTypeDescriptor enclosingTypeDescriptor);
	 public abstract Builder setName(String name);
	 public abstract Builder setEnumConstant(boolean isEnumConstant);
	 public abstract Builder setSynthetic(boolean isSynthetic);
	 public abstract Builder setTypeDescriptor(TypeDescriptor typeDescriptor);
	 public abstract Builder setVisibility(Visibility visibility);
	 public abstract Builder setJsInfo(JsInfo jsInfo);
	 public abstract Builder setUnusableByJsSuppressed(boolean isUnusableByJsSuppressed);
	 public abstract Builder setDeprecated(boolean isDeprecated);
	 public abstract Builder setOrigin(FieldOrigin fieldOrigin);
	 public Builder setDeclarationFieldDescriptor(FieldDescriptor declarationFieldDescriptor) {
		 return setDeclarationFieldDescriptorOrNullIfSelf(declarationFieldDescriptor);
	 }
	 abstract Builder setDeclarationFieldDescriptorOrNullIfSelf( FieldDescriptor declarationFieldDescriptor);
	 abstract Optional<String> getName();
	 abstract FieldDescriptor autoBuild();
	 public FieldDescriptor build() {
		 checkState(getName().isPresent());
		 FieldDescriptor fieldDescriptor = autoBuild();
		 checkState( !fieldDescriptor.isVariableCapture() || !fieldDescriptor.isEnclosingInstanceCapture());
		 return interner.intern(fieldDescriptor);
	 }
	 public static Builder from(FieldDescriptor fieldDescriptor) {
		 return fieldDescriptor.toBuilder();
	 }
	 private static final ThreadLocalInterner<FieldDescriptor> interner = new ThreadLocalInterner<>();
 }",1,1,0,0
"public List<FilteredImage> processImageTest(BufferedImage image){
	 List<FilteredImage> list = new ArrayList<FilteredImage>();
	 BufferedImage tempImage = image;
	 for (ImageFilter filter : filters) {
		 BufferedImage processedImage = filter.processImage(tempImage);
		 String filterName = filter.toString();
		 FilteredImage filteredImage = new FilteredImage(processedImage,filterName);
		 list.add(filteredImage);
		 tempImage = processedImage;
	 }
	 return list;
 }",0,0,0,0
"public RecordWriter<Text, Parse> getRecordWriter(FileSystem fs, JobConf job, String name, Progressable progress) throws IOException {
	 this.filters = new URLFilters(job);
	 this.normalizers = new URLNormalizers(job, URLNormalizers.SCOPE_OUTLINK);
	 this.scfilters = new ScoringFilters(job);
	 final int interval = job.getInt(""db.fetch.interval.default"", 2592000);
	 final boolean ignoreExternalLinks = job.getBoolean(""db.ignore.external.links"", false);
	 int maxOutlinksPerPage = job.getInt(""db.max.outlinks.per.page"", 100);
	 final int maxOutlinks = (maxOutlinksPerPage < 0) ? Integer.MAX_VALUE : maxOutlinksPerPage;
	 final CompressionType compType = SequenceFileOutputFormat.getOutputCompressionType(job);
	 Path out = FileOutputFormat.getOutputPath(job);
	 Path text = new Path(new Path(out, ParseText.DIR_NAME), name);
	 Path data = new Path(new Path(out, ParseData.DIR_NAME), name);
	 Path crawl = new Path(new Path(out, CrawlDatum.PARSE_DIR_NAME), name);
	 final String[] parseMDtoCrawlDB = job.get(""db.parsemeta.to.crawldb"","""").split("" *, *"");
	 final MapFile.Writer textOut = new MapFile.Writer(job, fs, text.toString(), Text.class, ParseText.class, CompressionType.RECORD, progress);
	 final MapFile.Writer dataOut = new MapFile.Writer(job, fs, data.toString(), Text.class, ParseData.class, compType, progress);
	 final SequenceFile.Writer crawlOut = SequenceFile.createWriter(fs, job, crawl, Text.class, CrawlDatum.class, compType, progress);
	 return new RecordWriter<Text, Parse>() {
		 public void write(Text key, Parse parse) throws IOException {
			 String fromUrl = key.toString();
			 String fromHost = null;
			 String toHost = null;
			 textOut.append(key, new ParseText(parse.getText()));
			 ParseData parseData = parse.getData();
			 String sig = parseData.getContentMeta().get(Nutch.SIGNATURE_KEY);
			 if (sig != null) {
				 byte[] signature = StringUtil.fromHexString(sig);
				 if (signature != null) {
					 CrawlDatum d = new CrawlDatum(CrawlDatum.STATUS_SIGNATURE, 0);
					 d.setSignature(signature);
					 crawlOut.append(key, d);
				 }
			 }
			 CrawlDatum parseMDCrawlDatum = null;
			 for (String mdname : parseMDtoCrawlDB) {
				 String mdvalue = parse.getData().getParseMeta().get(mdname);
				 if (mdvalue != null) {
					 if (parseMDCrawlDatum == null) parseMDCrawlDatum = new CrawlDatum( CrawlDatum.STATUS_PARSE_META, 0);
					 parseMDCrawlDatum.getMetaData().put(new Text(mdname), new Text(mdvalue));
				 }
			 }
			 if (parseMDCrawlDatum != null) crawlOut.append(key, parseMDCrawlDatum);
			 try {
				 ParseStatus pstatus = parseData.getStatus();
				 if (pstatus != null && pstatus.isSuccess() && pstatus.getMinorCode() == ParseStatus.SUCCESS_REDIRECT) {
					 String newUrl = pstatus.getMessage();
					 int refreshTime = Integer.valueOf(pstatus.getArgs()[1]);
					 try {
						 newUrl = normalizers.normalize(newUrl, URLNormalizers.SCOPE_FETCHER);
					 }
					 catch (MalformedURLException mfue) {
						 newUrl = null;
					 }
					 if (newUrl != null) newUrl = filters.filter(newUrl);
					 String url = key.toString();
					 if (newUrl != null && !newUrl.equals(url)) {
						 String reprUrl = URLUtil.chooseRepr(url, newUrl, refreshTime < Fetcher.PERM_REFRESH_TIME);
						 CrawlDatum newDatum = new CrawlDatum();
						 newDatum.setStatus(CrawlDatum.STATUS_LINKED);
						 if (reprUrl != null && !reprUrl.equals(newUrl)) {
							 newDatum.getMetaData().put(Nutch.WRITABLE_REPR_URL_KEY, new Text(reprUrl));
						 }
						 crawlOut.append(new Text(newUrl), newDatum);
					 }
				 }
			 }
			 catch (URLFilterException e) {
			 }
			 Outlink[] links = parseData.getOutlinks();
			 int outlinksToStore = Math.min(maxOutlinks, links.length);
			 if (ignoreExternalLinks) {
				 try {
					 fromHost = new URL(fromUrl).getHost().toLowerCase();
				 }
				 catch (MalformedURLException e) {
					 fromHost = null;
				 }
			 }
			 else {
				 fromHost = null;
			 }
			 int validCount = 0;
			 CrawlDatum adjust = null;
			 List<Entry<Text, CrawlDatum>> targets = new ArrayList<Entry<Text, CrawlDatum>>(outlinksToStore);
			 List<Outlink> outlinkList = new ArrayList<Outlink>(outlinksToStore);
			 for (int i = 0;
			 i < links.length && validCount < outlinksToStore;
			 i++) {
				 String toUrl = links[i].getToUrl();
				 if (fromUrl.equals(toUrl)) {
					 continue;
				 }
				 if (ignoreExternalLinks) {
					 try {
						 toHost = new URL(toUrl).getHost().toLowerCase();
					 }
					 catch (MalformedURLException e) {
						 toHost = null;
					 }
					 if (toHost == null || !toHost.equals(fromHost)) {
						 continue;
					 }
				 }
				 try {
					 toUrl = normalizers.normalize(toUrl, URLNormalizers.SCOPE_OUTLINK);
					 toUrl = filters.filter(toUrl);
					 if (toUrl == null) {
						 continue;
					 }
				 }
				 catch (Exception e) {
					 continue;
				 }
				 CrawlDatum target = new CrawlDatum(CrawlDatum.STATUS_LINKED, interval);
				 Text targetUrl = new Text(toUrl);
				 try {
					 scfilters.initialScore(targetUrl, target);
				 }
				 catch (ScoringFilterException e) {
					 LOG.warn(""Cannot filter init score for url "" + key + "", using default: "" + e.getMessage());
					 target.setScore(0.0f);
				 }
				 targets.add(new SimpleEntry(targetUrl, target));
				 outlinkList.add(links[i]);
				 validCount++;
			 }
			 try {
				 adjust = scfilters.distributeScoreToOutlinks((Text)key, parseData, targets, null, links.length);
			 }
			 catch (ScoringFilterException e) {
				 LOG.warn(""Cannot distribute score from "" + key + "": "" + e.getMessage());
			 }
			 for (Entry<Text, CrawlDatum> target : targets) {
				 crawlOut.append(target.getKey(), target.getValue());
			 }
			 if (adjust != null) crawlOut.append(key, adjust);
			 Outlink[] filteredLinks = outlinkList.toArray(new Outlink[outlinkList.size()]);
			 parseData = new ParseData(parseData.getStatus(), parseData.getTitle(), filteredLinks, parseData.getContentMeta(), parseData.getParseMeta());
			 dataOut.append(key, parseData);
			 if (!parse.isCanonical()) {
				 CrawlDatum datum = new CrawlDatum();
				 datum.setStatus(CrawlDatum.STATUS_FETCH_SUCCESS);
				 String timeString = parse.getData().getContentMeta().get(Nutch.FETCH_TIME_KEY);
				 try {
					 datum.setFetchTime(Long.parseLong(timeString));
				 }
				 catch (Exception e) {
					 LOG.warn(""Can't read fetch time for: "" + key);
					 datum.setFetchTime(System.currentTimeMillis());
				 }
				 crawlOut.append(key, datum);
			 }
		 }
		 public void close(Reporter reporter) throws IOException {
			 textOut.close();
			 dataOut.close();
			 crawlOut.close();
		 }
	 }
	;
 }",0,0,1,0
"class XPathFactoryFinder {
	 private static final String DEFAULT_PACKAGE = ""com.sun.org.apache.xpath.internal"";
	 private static boolean debug = false;
	 static {
		 try {
			 debug = SecuritySupport.getSystemProperty(""jaxp.debug"") != null;
		 }
		 catch (Exception unused) {
			 debug = false;
		 }
	 }
	 private static final Properties cacheProps = new Properties();
	 private volatile static boolean firstTime = true;
	 private static void debugPrintln(Supplier<String> msgGen) {
		 if (debug) {
			 System.err.println(""JAXP: "" + msgGen.get());
		 }
	 }
	 private final ClassLoader classLoader;
	 public XPathFactoryFinder(ClassLoader loader) {
		 this.classLoader = loader;
		 if( debug ) {
			 debugDisplayClassLoader();
		 }
	 }
	 private void debugDisplayClassLoader() {
		 try {
			 if( classLoader == SecuritySupport.getContextClassLoader() ) {
				 debugPrintln(() -> ""using thread context class loader (""+classLoader+"") for search"");
				 return;
			 }
		 }
		 catch( Throwable unused ) {
		 }
		 if( classLoader==ClassLoader.getSystemClassLoader() ) {
			 debugPrintln(() -> ""using system class loader (""+classLoader+"") for search"");
			 return;
		 }
		 debugPrintln(() -> ""using class loader (""+classLoader+"") for search"");
	 }
	 public XPathFactory newFactory(String uri) throws XPathFactoryConfigurationException {
		 if (uri == null) {
			 throw new NullPointerException();
		 }
		 XPathFactory f = _newFactory(uri);
		 if (f != null) {
			 debugPrintln(()->""factory '"" + f.getClass().getName() + ""' was found for "" + uri);
		 }
		 else {
			 debugPrintln(()->""unable to find a factory for "" + uri);
		 }
		 return f;
	 }
	 private XPathFactory _newFactory(String uri) throws XPathFactoryConfigurationException {
		 XPathFactory xpathFactory = null;
		 String propertyName = SERVICE_CLASS.getName() + "":"" + uri;
		 try {
			 debugPrintln(()->""Looking up system property '""+propertyName+""'"" );
			 String r = SecuritySupport.getSystemProperty(propertyName);
			 if(r!=null) {
				 debugPrintln(()->""The value is '""+r+""'"");
				 xpathFactory = createInstance(r);
				 if (xpathFactory != null) {
					 return xpathFactory;
				 }
			 }
			 else debugPrintln(()->""The property is undefined."");
		 }
		 catch( Throwable t ) {
			 if( debug ) {
				 debugPrintln(()->""failed to look up system property '""+propertyName+""'"" );
				 t.printStackTrace();
			 }
		 }
		 String javah = SecuritySupport.getSystemProperty( ""java.home"" );
		 String configFile = javah + File.separator + ""conf"" + File.separator + ""jaxp.properties"";
		 try {
			 if(firstTime){
				 synchronized(cacheProps){
					 if(firstTime){
						 File f=new File( configFile );
						 firstTime = false;
						 if(SecuritySupport.doesFileExist(f)){
							 debugPrintln(()->""Read properties file "" + f);
							 cacheProps.load(SecuritySupport.getFileInputStream(f));
						 }
					 }
				 }
			 }
			 final String factoryClassName = cacheProps.getProperty(propertyName);
			 debugPrintln(()->""found "" + factoryClassName + "" in $java.home/conf/jaxp.properties"");
			 if (factoryClassName != null) {
				 xpathFactory = createInstance(factoryClassName);
				 if(xpathFactory != null){
					 return xpathFactory;
				 }
			 }
		 }
		 catch (Exception ex) {
			 if (debug) {
				 ex.printStackTrace();
			 }
		 }
		 assert xpathFactory == null;
		 xpathFactory = findServiceProvider(uri);
		 if (xpathFactory != null) {
			 return xpathFactory;
		 }
		 if(uri.equals(XPathFactory.DEFAULT_OBJECT_MODEL_URI)) {
			 debugPrintln(()->""attempting to use the platform default W3C DOM XPath lib"");
			 return new XPathFactoryImpl();
		 }
		 debugPrintln(()->""all things were tried, but none was found. bailing out."");
		 return null;
	 }
	 private Class<?> createClass(String className) {
		 Class<?> clazz;
		 boolean internal = false;
		 if (System.getSecurityManager() != null) {
			 if (className != null && className.startsWith(DEFAULT_PACKAGE)) {
				 internal = true;
			 }
		 }
		 try {
			 if (classLoader != null && !internal) {
				 clazz = Class.forName(className, false, classLoader);
			 }
			 else {
				 clazz = Class.forName(className);
			 }
		 }
		 catch (Throwable t) {
			 if(debug) {
				 t.printStackTrace();
			 }
			 return null;
		 }
		 return clazz;
	 }
	 XPathFactory createInstance(String className) throws XPathFactoryConfigurationException {
		 XPathFactory xPathFactory = null;
		 debugPrintln(()->""createInstance("" + className + "")"");
		 Class<?> clazz = createClass(className);
		 if (clazz == null) {
			 debugPrintln(()->""failed to getClass("" + className + "")"");
			 return null;
		 }
		 debugPrintln(()->""loaded "" + className + "" from "" + which(clazz));
		 try {
			 xPathFactory = (XPathFactory) clazz.getConstructor().newInstance();
		 }
		 catch (ClassCastException | IllegalAccessException | IllegalArgumentException | InstantiationException | InvocationTargetException | NoSuchMethodException | SecurityException ex) {
			 debugPrintln(()->""could not instantiate "" + clazz.getName());
			 if (debug) {
				 ex.printStackTrace();
			 }
			 return null;
		 }
		 return xPathFactory;
	 }
	 private boolean isObjectModelSupportedBy(final XPathFactory factory, final String objectModel, AccessControlContext acc) {
		 return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
			 public Boolean run() {
				 return factory.isObjectModelSupported(objectModel);
			 }
		 }
		, acc);
	 }
	 private XPathFactory findServiceProvider(final String objectModel) throws XPathFactoryConfigurationException {
		 assert objectModel != null;
		 final AccessControlContext acc = AccessController.getContext();
		 try {
			 return AccessController.doPrivileged(new PrivilegedAction<XPathFactory>() {
				 public XPathFactory run() {
					 final ServiceLoader<XPathFactory> loader = ServiceLoader.load(SERVICE_CLASS);
					 for (XPathFactory factory : loader) {
						 if (isObjectModelSupportedBy(factory, objectModel, acc)) {
							 return factory;
						 }
					 }
					 return null;
				 }
			 }
			);
		 }
		 catch (ServiceConfigurationError error) {
			 throw new XPathFactoryConfigurationException(error);
		 }
	 }
	 private static final Class<XPathFactory> SERVICE_CLASS = XPathFactory.class;
	 private static String which( Class<?> clazz ) {
		 return SecuritySupport.getClassSource(clazz);
	 }
}",1,0,0,0
"public class SecuredResourceImpl extends SecuredRDFNodeImpl implements SecuredResource {
	 public static SecuredResource getInstance(final SecuredModel securedModel, final Resource resource) {
		 if (securedModel == null) {
			 throw new IllegalArgumentException(""Secured securedModel may not be null"");
		 }
		 if (resource == null) {
			 throw new IllegalArgumentException(""Resource may not be null"");
		 }
		 if (resource.isLiteral()) {
			 throw new IllegalArgumentException(""Resource may not be a literal"");
		 }
		 Resource goodResource = resource;
		 if (goodResource.getModel() == null) {
			 final Node n = resource.asNode();
			 if (resource.isAnon()) {
				 goodResource = securedModel.createResource(new AnonId(n.getBlankNodeId()));
			 }
			 else {
				 goodResource = securedModel.createResource(n.getURI());
			 }
		 }
		 final ItemHolder<Resource, SecuredResource> holder = new ItemHolder<>(goodResource);
		 final SecuredResourceImpl checker = new SecuredResourceImpl(securedModel, holder);
		 if (goodResource instanceof SecuredResource) {
			 if (checker.isEquivalent((SecuredResource) goodResource)) {
				 return (SecuredResource) goodResource;
			 }
		 }
		 return holder.setSecuredItem(new SecuredItemInvoker(resource.getClass(), checker));
	 }
	 private final ItemHolder<? extends Resource, ? extends SecuredResource> holder;
	 protected SecuredResourceImpl(final SecuredModel securedModel, final ItemHolder<? extends Resource, ? extends SecuredResource> holder) {
		 super(securedModel, holder);
		 this.holder = holder;
	 }
	 public SecuredResource abort() {
		 holder.getBaseItem().abort();
		 return holder.getSecuredItem();
	 }
	 public SecuredResource addLiteral(final Property p, final boolean o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredResource addLiteral(final Property p, final char o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredResource addLiteral(final Property value, final double d) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(value, ResourceFactory.createTypedLiteral(d));
	 }
	 public SecuredResource addLiteral(final Property value, final float d) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(value, ResourceFactory.createTypedLiteral(d));
	 }
	 public SecuredResource addLiteral(final Property p, final Literal o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(p, o);
	 }
	 public SecuredResource addLiteral(final Property p, final long o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredResource addLiteral(final Property p, final Object o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(p, ResourceFactory.createTypedLiteral(o));
	 }
	 public SecuredResource addProperty(final Property p, final RDFNode o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(holder.getBaseItem().asNode(), p.asNode(), o.asNode()));
		 holder.getBaseItem().addProperty(p, o);
		 return holder.getSecuredItem();
	 }
	 public SecuredResource addProperty(final Property p, final String o) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 return addProperty(p, o, """");
	 }
	 public SecuredResource addProperty(final Property p, final String lexicalForm, final RDFDatatype datatype) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 final Literal l = ResourceFactory.createTypedLiteral(lexicalForm, datatype);
		 checkCreate(Triple.create(holder.getBaseItem().asNode(), p.asNode(), l.asNode()));
		 holder.getBaseItem().addProperty(p, l);
		 return holder.getSecuredItem();
	 }
	 public SecuredResource addProperty(final Property p, final String o, final String l) throws UpdateDeniedException, AddDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 checkCreate(Triple.create(holder.getBaseItem().asNode(), p.asNode(), NodeFactory.createLiteral(o, l, false)));
		 holder.getBaseItem().addProperty(p, o, l);
		 return holder.getSecuredItem();
	 }
	 public Literal asLiteral() {
		 checkRead();
		 throw new LiteralRequiredException(asNode());
	 }
	 public SecuredResource asResource() {
		 return holder.getSecuredItem();
	 }
	 public SecuredResource begin() {
		 holder.getBaseItem().begin();
		 return holder.getSecuredItem();
	 }
	 public boolean canReadProperty(final Node p) throws AuthenticationRequiredException {
		 return canRead() && canRead(Triple.create(holder.getBaseItem().asNode(), p, Node.ANY));
	 }
	 protected void checkReadProperty(final Node p) throws ReadDeniedException, AuthenticationRequiredException {
		 if (!canReadProperty(p)) {
			 throw new ReadDeniedException(SecuredItem.Util.triplePermissionMsg(getModelNode()), Triple.create(holder.getBaseItem().asNode(), p, Node.ANY));
		 }
	 }
	 public SecuredResource commit() {
		 holder.getBaseItem().commit();
		 return holder.getSecuredItem();
	 }
	 public AnonId getId() throws ReadDeniedException, AuthenticationRequiredException {
		 checkRead();
		 return holder.getBaseItem().getId();
	 }
	 public String getLocalName() throws ReadDeniedException, AuthenticationRequiredException {
		 checkRead();
		 return holder.getBaseItem().getLocalName();
	 }
	 public String getNameSpace() throws ReadDeniedException, AuthenticationRequiredException {
		 checkRead();
		 return holder.getBaseItem().getNameSpace();
	 }
	 private SecuredStatement getProperty(Supplier<ExtendedIterator<Statement>> supplier) {
		 if (checkSoftRead()) {
			 final ExtendedIterator<Statement> iter = supplier.get() .filterKeep(new PermStatementFilter(Action.Read, this));
			 try {
				 if (iter.hasNext()) {
					 return SecuredStatementImpl.getInstance(getModel(), iter.next());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 return null;
	 }
	 public SecuredStatement getProperty(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return getProperty(() -> holder.getBaseItem().listProperties(p));
	 }
	 public SecuredStatement getProperty(Property p, String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 return getProperty(() -> holder.getBaseItem().listProperties(p, lang));
	 }
	 public SecuredResource getPropertyResourceValue(final Property p) throws AuthenticationRequiredException {
		 final SecuredStatementIterator iter = listProperties(p);
		 try {
			 while (iter.hasNext()) {
				 final Statement s = iter.next();
				 if (s.getObject().isResource()) {
					 return SecuredResourceImpl.getInstance(getModel(), s.getObject().asResource());
				 }
			 }
		 }
		 finally {
			 iter.close();
		 }
		 return null;
	 }
	 public SecuredStatement getRequiredProperty(final Property p) throws PropertyNotFoundException, ReadDeniedException, AuthenticationRequiredException {
		 SecuredStatement stmt = getProperty(() -> holder.getBaseItem().listProperties(p));
		 if (stmt == null) {
			 throw new PropertyNotFoundException(p);
		 }
		 return stmt;
	 }
	 public SecuredStatement getRequiredProperty(Property p, String lang) throws PropertyNotFoundException, ReadDeniedException, AuthenticationRequiredException {
		 SecuredStatement stmt = getProperty(() -> holder.getBaseItem().listProperties(p, lang));
		 if (stmt == null) {
			 throw new PropertyNotFoundException(p);
		 }
		 return stmt;
	 }
	 public String getURI() throws ReadDeniedException, AuthenticationRequiredException {
		 checkRead();
		 return holder.getBaseItem().getURI();
	 }
	 public Statement getStmtTerm() {
		 if (checkSoftRead()) {
			 Statement stmt = holder.getBaseItem().getStmtTerm();
			 if (stmt != null && canRead(stmt)) {
				 return SecuredStatementImpl.getInstance(getModel(), stmt);
			 }
		 }
		 return null;
	 }
	 public boolean hasLiteral(final Property p, final boolean o) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(Triple.create(holder.getBaseItem().asNode(), p.asNode(), ResourceFactory.createTypedLiteral(o).asNode()))) {
			 return holder.getBaseItem().hasLiteral(p, o);
		 }
		 return false;
	 }
	 public boolean hasLiteral(final Property p, final char o) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(Triple.create(holder.getBaseItem().asNode(), p.asNode(), ResourceFactory.createTypedLiteral(o).asNode()))) {
			 return holder.getBaseItem().hasLiteral(p, o);
		 }
		 return false;
	 }
	 public boolean hasLiteral(final Property p, final double o) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(Triple.create(holder.getBaseItem().asNode(), p.asNode(), ResourceFactory.createTypedLiteral(o).asNode()))) {
			 return holder.getBaseItem().hasLiteral(p, o);
		 }
		 return false;
	 }
	 public boolean hasLiteral(final Property p, final float o) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(Triple.create(holder.getBaseItem().asNode(), p.asNode(), ResourceFactory.createTypedLiteral(o).asNode()))) {
			 return holder.getBaseItem().hasLiteral(p, o);
		 }
		 return false;
	 }
	 public boolean hasLiteral(final Property p, final long o) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(Triple.create(holder.getBaseItem().asNode(), p.asNode(), ResourceFactory.createTypedLiteral(o).asNode()))) {
			 return holder.getBaseItem().hasLiteral(p, o);
		 }
		 return false;
	 }
	 public boolean hasLiteral(final Property p, final Object o) throws ReadDeniedException, AuthenticationRequiredException {
		 if (checkSoftRead() && checkRead(Triple.create(holder.getBaseItem().asNode(), p.asNode(), ResourceFactory.createTypedLiteral(o).asNode()))) {
			 return holder.getBaseItem().hasLiteral(p, o);
		 }
		 return false;
	 }
	 private boolean hasProperty(Supplier<ExtendedIterator<Statement>> supplier) {
		 if (checkSoftRead()) {
			 final ExtendedIterator<Statement> iter = supplier.get() .filterKeep(new PermStatementFilter(Action.Read, this));
			 try {
				 return iter.hasNext();
			 }
			 finally {
				 iter.close();
			 }
		 }
		 return false;
	 }
	 public boolean hasProperty(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return hasProperty(() -> holder.getBaseItem().listProperties(p));
	 }
	 public boolean hasProperty(final Property p, final RDFNode o) throws ReadDeniedException, AuthenticationRequiredException {
		 return hasProperty(() -> holder.getBaseItem().getModel().listStatements(this, p, o));
	 }
	 public boolean hasProperty(final Property p, final String o) throws ReadDeniedException, AuthenticationRequiredException {
		 return hasProperty(() -> holder.getBaseItem().getModel().listStatements(this, p, o));
	 }
	 public boolean hasProperty(final Property p, final String o, final String l) throws ReadDeniedException, AuthenticationRequiredException {
		 final Literal ll = holder.getBaseItem().getModel().createLiteral(o, l);
		 return hasProperty(() -> holder.getBaseItem().getModel().listStatements(this, p, ll));
	 }
	 public boolean hasURI(final String uri) throws ReadDeniedException, AuthenticationRequiredException {
		 checkRead();
		 return holder.getBaseItem().hasURI(uri);
	 }
	 public Resource inModel(final Model m) {
		 checkRead();
		 return holder.getBaseItem().inModel(m);
	 }
	 private SecuredStatementIterator listProperties(Supplier<StmtIterator> supplier) {
		 ExtendedIterator<Statement> iter = checkSoftRead() ? supplier.get() : NiceIterator.emptyIterator();
		 return new SecuredStatementIterator(getModel(), iter);
	 }
	 public SecuredStatementIterator listProperties() throws ReadDeniedException, AuthenticationRequiredException {
		 return listProperties(() -> holder.getBaseItem().listProperties());
	 }
	 public SecuredStatementIterator listProperties(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 return listProperties(() -> holder.getBaseItem().listProperties(p));
	 }
	 public SecuredStatementIterator listProperties(final Property p, final String lang) throws ReadDeniedException, AuthenticationRequiredException {
		 return listProperties(() -> holder.getBaseItem().listProperties(p, lang));
	 }
	 public SecuredResource removeAll(final Property p) throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.create(holder.getBaseItem().asNode(), p.asNode(), Node.ANY))) {
			 final StmtIterator iter = holder.getBaseItem().listProperties(p);
			 try {
				 if (!iter.hasNext()) {
					 return holder.getSecuredItem();
				 }
				 while (iter.hasNext()) {
					 checkDelete(iter.next().asTriple());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 holder.getBaseItem().removeAll(p);
		 return holder.getSecuredItem();
	 }
	 public SecuredResource removeProperties() throws ReadDeniedException, AuthenticationRequiredException {
		 checkUpdate();
		 if (!canDelete(Triple.create(holder.getBaseItem().asNode(), Node.ANY, Node.ANY))) {
			 final StmtIterator iter = holder.getBaseItem().listProperties();
			 try {
				 if (!iter.hasNext()) {
					 return holder.getSecuredItem();
				 }
				 while (iter.hasNext()) {
					 checkDelete(iter.next().asTriple());
				 }
			 }
			 finally {
				 iter.close();
			 }
		 }
		 holder.getBaseItem().removeProperties();
		 return holder.getSecuredItem();
	 }
	 public Object visitWith(final RDFVisitor rv) {
		 return isAnon() ? rv.visitBlank(this, getId()) : rv.visitURI(this, getURI());
	 }
}",1,0,0,0
"private void buildTree(float minx, float maxx, float miny, float maxy, float minz, float maxz, BuildTask task, int depth, IntArray tempTree, int offset, IntArray tempList, BuildStats stats) {
	 if (task.numObjects > maxPrims && depth < MAX_DEPTH) {
		 float dx = maxx - minx;
		 float dy = maxy - miny;
		 float dz = maxz - minz;
		 float bestCost = INTERSECT_COST * task.numObjects;
		 int bestAxis = -1;
		 int bestOffsetStart = -1;
		 int bestOffsetEnd = -1;
		 float bestSplit = 0;
		 boolean bestPlanarLeft = false;
		 int bnl = 0, bnr = 0;
		 float area = (dx * dy + dy * dz + dz * dx);
		 float ISECT_COST = INTERSECT_COST / area;
		 int[] nl = {
		 0, 0, 0 }
		;
		 int[] nr = {
		 task.numObjects, task.numObjects, task.numObjects }
		;
		 float[] dp = {
		 dy * dz, dz * dx, dx * dy }
		;
		 float[] ds = {
		 dy + dz, dz + dx, dx + dy }
		;
		 float[] nodeMin = {
		 minx, miny, minz }
		;
		 float[] nodeMax = {
		 maxx, maxy, maxz }
		;
		 int nSplits = task.n;
		 long[] splits = task.splits;
		 byte[] lrtable = task.leftRightTable;
		 for (int i = 0;
		 i < nSplits;
		) {
			 long ptr = splits[i];
			 float split = unpackSplit(ptr);
			 int axis = unpackAxis(ptr);
			 int currentOffset = i;
			 int pClosed = 0, pPlanar = 0, pOpened = 0;
			 long ptrMasked = ptr & (~TYPE_MASK & 0xFFFFFFFFF0000000L);
			 long ptrClosed = ptrMasked | CLOSED;
			 long ptrPlanar = ptrMasked | PLANAR;
			 long ptrOpened = ptrMasked | OPENED;
			 while (i < nSplits && (splits[i] & 0xFFFFFFFFF0000000L) == ptrClosed) {
				 int obj = unpackObject(splits[i]);
				 lrtable[obj >>> 2] = 0;
				 pClosed++;
				 i++;
			 }
			 while (i < nSplits && (splits[i] & 0xFFFFFFFFF0000000L) == ptrPlanar) {
				 int obj = unpackObject(splits[i]);
				 lrtable[obj >>> 2] = 0;
				 pPlanar++;
				 i++;
			 }
			 while (i < nSplits && (splits[i] & 0xFFFFFFFFF0000000L) == ptrOpened) {
				 int obj = unpackObject(splits[i]);
				 lrtable[obj >>> 2] = 0;
				 pOpened++;
				 i++;
			 }
			 nr[axis] -= pPlanar + pClosed;
			 if (split >= nodeMin[axis] && split <= nodeMax[axis]) {
				 float dl = split - nodeMin[axis];
				 float dr = nodeMax[axis] - split;
				 float lp = dp[axis] + dl * ds[axis];
				 float rp = dp[axis] + dr * ds[axis];
				 boolean planarLeft = dl < dr;
				 int numLeft = nl[axis] + (planarLeft ? pPlanar : 0);
				 int numRight = nr[axis] + (planarLeft ? 0 : pPlanar);
				 float eb = ((numLeft == 0 && dl > 0) || (numRight == 0 && dr > 0)) ? EMPTY_BONUS : 0;
				 float cost = TRAVERSAL_COST + ISECT_COST * (1 - eb) * (lp * numLeft + rp * numRight);
				 if (cost < bestCost) {
					 bestCost = cost;
					 bestAxis = axis;
					 bestSplit = split;
					 bestOffsetStart = currentOffset;
					 bestOffsetEnd = i;
					 bnl = numLeft;
					 bnr = numRight;
					 bestPlanarLeft = planarLeft;
				 }
			 }
			 nl[axis] += pOpened + pPlanar;
		 }
		 for (int axis = 0;
		 axis < 3;
		 axis++) {
			 int numLeft = nl[axis];
			 int numRight = nr[axis];
			 if (numLeft != task.numObjects || numRight != 0) UI.printError(Module.ACCEL, ""Didn't scan full range of objects =%d. Left overs for axis %d: [L: %d] [R: %d]"", depth, axis, numLeft, numRight);
		 }
		 if (bestAxis != -1) {
			 BuildTask taskL = new BuildTask(bnl, task);
			 BuildTask taskR = new BuildTask(bnr, task);
			 int lk = 0, rk = 0;
			 for (int i = 0;
			 i < bestOffsetStart;
			 i++) {
				 long ptr = splits[i];
				 if (unpackAxis(ptr) == bestAxis) {
					 if (unpackSplitType(ptr) != CLOSED) {
						 int obj = unpackObject(ptr);
						 lrtable[obj >>> 2] |= 1 << ((obj & 3) << 1);
						 lk++;
					 }
				 }
			 }
			 for (int i = bestOffsetStart;
			 i < bestOffsetEnd;
			 i++) {
				 long ptr = splits[i];
				 assert unpackAxis(ptr) == bestAxis;
				 if (unpackSplitType(ptr) == PLANAR) {
					 if (bestPlanarLeft) {
						 int obj = unpackObject(ptr);
						 lrtable[obj >>> 2] |= 1 << ((obj & 3) << 1);
						 lk++;
					 }
					 else {
						 int obj = unpackObject(ptr);
						 lrtable[obj >>> 2] |= 2 << ((obj & 3) << 1);
						 rk++;
					 }
				 }
			 }
			 for (int i = bestOffsetEnd;
			 i < nSplits;
			 i++) {
				 long ptr = splits[i];
				 if (unpackAxis(ptr) == bestAxis) {
					 if (unpackSplitType(ptr) != OPENED) {
						 int obj = unpackObject(ptr);
						 lrtable[obj >>> 2] |= 2 << ((obj & 3) << 1);
						 rk++;
					 }
				 }
			 }
			 long[] splitsL = taskL.splits;
			 long[] splitsR = taskR.splits;
			 int nsl = 0, nsr = 0;
			 for (int i = 0;
			 i < nSplits;
			 i++) {
				 long ptr = splits[i];
				 int obj = unpackObject(ptr);
				 int idx = obj >>> 2;
				 int mask = 1 << ((obj & 3) << 1);
				 if ((lrtable[idx] & mask) != 0) {
					 splitsL[nsl] = ptr;
					 nsl++;
				 }
				 if ((lrtable[idx] & (mask << 1)) != 0) {
					 splitsR[nsr] = ptr;
					 nsr++;
				 }
			 }
			 taskL.n = nsl;
			 taskR.n = nsr;
			 task.splits = splits = splitsL = splitsR = null;
			 task = null;
			 int nextOffset = tempTree.getSize();
			 tempTree.add(0);
			 tempTree.add(0);
			 tempTree.add(0);
			 tempTree.add(0);
			 tempTree.set(offset + 0, (bestAxis << 30) | nextOffset);
			 tempTree.set(offset + 1, Float.floatToRawIntBits(bestSplit));
			 stats.updateInner();
			 switch (bestAxis) {
				 case 0: buildTree(minx, bestSplit, miny, maxy, minz, maxz, taskL, depth + 1, tempTree, nextOffset, tempList, stats);
				 taskL = null;
				 buildTree(bestSplit, maxx, miny, maxy, minz, maxz, taskR, depth + 1, tempTree, nextOffset + 2, tempList, stats);
				 taskR = null;
				 return;
				 case 1: buildTree(minx, maxx, miny, bestSplit, minz, maxz, taskL, depth + 1, tempTree, nextOffset, tempList, stats);
				 taskL = null;
				 buildTree(minx, maxx, bestSplit, maxy, minz, maxz, taskR, depth + 1, tempTree, nextOffset + 2, tempList, stats);
				 taskR = null;
				 return;
				 case 2: buildTree(minx, maxx, miny, maxy, minz, bestSplit, taskL, depth + 1, tempTree, nextOffset, tempList, stats);
				 taskL = null;
				 buildTree(minx, maxx, miny, maxy, bestSplit, maxz, taskR, depth + 1, tempTree, nextOffset + 2, tempList, stats);
				 taskR = null;
				 return;
				 default: assert false;
			 }
		 }
	 }
	 int listOffset = tempList.getSize();
	 int n = 0;
	 for (int i = 0;
	 i < task.n;
	 i++) {
		 long ptr = task.splits[i];
		 if (unpackAxis(ptr) == 0 && unpackSplitType(ptr) != CLOSED) {
			 tempList.add(unpackObject(ptr));
			 n++;
		 }
	 }
	 stats.updateLeaf(depth, n);
	 if (n != task.numObjects) UI.printError(Module.ACCEL, ""Error creating leaf node - expecting %d found %d"", task.numObjects, n);
	 tempTree.set(offset + 0, (3 << 30) | listOffset);
	 tempTree.set(offset + 1, task.numObjects);
	 task.splits = null;
 }",0,0,1,0
"public int addFieldref(String name, String className, String type);",0,0,0,1
"public class WSS4JInInterceptorFactory {
	 private Properties properties;
	 public Properties getProperties() {
		 return properties;
	 }
	 public void setProperties(Properties properties) {
		 this.properties = properties;
	 }
	 public WSS4JInInterceptor create() {
		 final Map<String, Object> map = new HashMap<String, Object>();
		 for (Map.Entry<Object, Object> entry : properties.entrySet()) {
			 map.put(entry.getKey().toString(), entry.getValue());
		 }
		 properties.clear();
		 return new WSS4JInInterceptor(map);
	 }
}",1,1,0,0
"public class Graph extends GraphShapeElement {
	public enum Alignment {
	HORIZONTAL, VERTICAL}
	private List<GraphNode> nodes = new ArrayList<>();
	private Set<GraphEdge> edges = new HashSet<>();
	private Set<Graph> subgraphs = new HashSet<>();
	private Alignment alignment = Alignment.VERTICAL;
	public Graph(GraphController graphController) {
		super(graphController);
	}
	public void addEdge(GraphEdge edge) {
		edge.setParent(this);
		edges.add(edge);
	}
	public void addNode(GraphNode node) {
		node.setParent(this);
		nodes.add(node);
	}
	public void addSubgraph(Graph subgraph) {
		subgraph.setParent(this);
		subgraphs.add(subgraph);
	}
	public Alignment getAlignment() {
		return alignment;
	}
	public Set<GraphEdge> getEdges() {
		return Collections.unmodifiableSet(edges);
	}
	public List<GraphNode> getNodes() {
		return Collections.unmodifiableList(nodes);
	}
	public Set<Graph> getSubgraphs() {
		return Collections.unmodifiableSet(subgraphs);
	}
	public boolean removeEdge(GraphEdge edge) {
		return edges.remove(edge);
	}
	public boolean removeNode(GraphNode node) {
		return nodes.remove(node);
	}
	public boolean removeSubgraph(Graph subgraph) {
		return subgraphs.remove(subgraph);
	}
	public void setAlignment(Alignment alignment) {
		this.alignment = alignment;
	}
}",1,1,0,0
"public class RunningCount extends AggregateFunctionAdapter{
	public int getType( ){
		return RUNNING_AGGR;
	}
	public int getBIRTDataType( ){
		return DataType.INTEGER_TYPE;
	}
}",0,0,0,0
"abstract class AbstractTime extends AbstractTimeValue{
	private static final long serialVersionUID = 1L;
	static final Calendar localtime = Calendar.getInstance();
	static final SimpleDateFormat timeFormat = new SimpleDateFormat(""h.mma"");
	AbstractTime(final long milliseconds){
		super(milliseconds);
	}
	public final boolean after(final AbstractTimeValue that){
		return greaterThan(that);
	}
	public final boolean before(final AbstractTimeValue that){
		return lessThan(that);
	}
	public final String toTimeString(){
		return toTimeString(localtime);
	}
	public final String toTimeString(final Calendar calendar){
		synchronized (timeFormat){
			synchronized (calendar){
				timeFormat.setCalendar(calendar);
				return timeFormat.format(new Date(getMilliseconds())).toLowerCase();
			}
		}
	}
	public String toString(){
		return toTimeString();
	}
}",0,0,0,0
"public void clear() {
	 bitset.clear(0, bitset.size());
 }",0,0,0,0
"public class ShuffleWriteMetrics {
	 private long bytesWritten;
	 private long recordsWritten;
	 private long writeTime;
	 public long getBytesWritten () {
		 return bytesWritten;
	 }
	 public void setBytesWritten (long bytesWritten) {
		 this.bytesWritten = bytesWritten;
	 }
	 public long getRecordsWritten () {
		 return recordsWritten;
	 }
	 public void setRecordsWritten (long recordsWritten) {
		 this.recordsWritten = recordsWritten;
	 }
	 public long getWriteTime () {
		 return writeTime;
	 }
	 public void setWriteTime (long writeTime) {
		 this.writeTime = writeTime;
	 }
}",0,1,0,0
"public class SessionMap{
	 public static <T> T get(String objectName, Class<T> type) {
		 Map<String, Object> map = FacesContext.getCurrentInstance().getExternalContext().getSessionMap();
		 return (T) map.get(objectName);
	 }
	 public static <T> T get(Page page, String propertyName, Class<T> type) {
		 String objectName = page.getPageName() + ""."" + propertyName + ""."" + type.getSimpleName();
		 return get(objectName, type);
	 }
	 public static <T> void put(String objectName, Class<T> type, T object) {
		 Map<String, Object> map = FacesContext.getCurrentInstance().getExternalContext().getSessionMap();
		 if (object != null) map.put(objectName, object);
		 else map.remove(objectName);
	 }
	 public static <T> void remove(Page page, String propertyName, Class<T> type, T object) {
		 String objectName = page.getPageName() + ""."" + propertyName + ""."" + type.getSimpleName();
		 put(objectName, type, object);
	 }
	 public static <T> void remove(String objectName, Class<T> type) {
		 put(objectName, type, null);
	 }
	 public static <T> void remove(Page page, String propertyName, Class<T> type) {
		 remove(page, propertyName, type, null);
	 }
}",0,0,0,0
"public class ScriptRunnerHelper {
	 private ClasspathUtils.Delegate cpDelegate = null;
	 private File srcFile;
	 private String manager = ""auto"";
	 private String language;
	 private String text;
	 private boolean setBeans = true;
	 private ProjectComponent projectComponent;
	 private ClassLoader scriptLoader = null;
	 private Union resources = new Union();
	 public void setProjectComponent(ProjectComponent component) {
		 this.projectComponent = component;
	 }
	 public ScriptRunnerBase getScriptRunner() {
		 ScriptRunnerBase runner = getRunner();
		 if (srcFile != null) {
			 runner.setSrc(srcFile);
		 }
		 if (text != null) {
			 runner.addText(text);
		 }
		 if (resources != null) {
			 runner.loadResources(resources);
		 }
		 if (setBeans) {
			 runner.bindToComponent(projectComponent);
		 }
		 else {
			 runner.bindToComponentMinimum(projectComponent);
		 }
		 return runner;
	 }
	 public Path createClasspath() {
		 return getClassPathDelegate().createClasspath();
	 }
	 public void setClasspath(Path classpath) {
		 getClassPathDelegate().setClasspath(classpath);
	 }
	 public void setClasspathRef(Reference r) {
		 getClassPathDelegate().setClasspathref(r);
	 }
	 public void setSrc(File file) {
		 this.srcFile = file;
	 }
	 public void addText(String text) {
		 this.text = text;
	 }
	 public void setManager(String manager) {
		 this.manager = manager;
	 }
	 public void setLanguage(String language) {
		 this.language = language;
	 }
	 public String getLanguage() {
		 return language;
	 }
	 public void setSetBeans(boolean setBeans) {
		 this.setBeans = setBeans;
	 }
	 public void setClassLoader(ClassLoader loader) {
		 scriptLoader = loader;
	 }
	 private synchronized ClassLoader generateClassLoader() {
		 if (scriptLoader != null) {
			 return scriptLoader;
		 }
		 if (cpDelegate == null) {
			 scriptLoader = getClass().getClassLoader();
			 return scriptLoader;
		 }
		 scriptLoader = cpDelegate.getClassLoader();
		 return scriptLoader;
	 }
	 private ClasspathUtils.Delegate getClassPathDelegate() {
		 if (cpDelegate == null) {
			 cpDelegate = ClasspathUtils.getDelegate(projectComponent);
		 }
		 return cpDelegate;
	 }
	 private ScriptRunnerBase getRunner() {
		 return new ScriptRunnerCreator(projectComponent.getProject()).createRunner( manager, language, generateClassLoader());
	 }
	 public void add(ResourceCollection resource) {
		 resources.add(resource);
	 }
}",0,0,0,0
"public class JakartaRegexpMatcher implements RegexpMatcher {
	 private String pattern;
	 public void setPattern(String pattern) {
		 this.pattern = pattern;
	 }
	 public String getPattern() {
		 return pattern;
	 }
	 protected RE getCompiledPattern(int options) throws BuildException {
		 int cOptions = getCompilerOptions(options);
		 try {
			 RE reg = new RE(pattern);
			 reg.setMatchFlags(cOptions);
			 return reg;
		 }
		 catch (RESyntaxException e) {
			 throw new BuildException(e);
		 }
	 }
	 public boolean matches(String argument) throws BuildException {
		 return matches(argument, MATCH_DEFAULT);
	 }
	 public boolean matches(String input, int options) throws BuildException {
		 return matches(input, getCompiledPattern(options));
	 }
	 private boolean matches(String input, RE reg) {
		 return reg.match(input);
	 }
	 public Vector getGroups(String argument) throws BuildException {
		 return getGroups(argument, MATCH_DEFAULT);
	 }
	 public Vector getGroups(String input, int options) throws BuildException {
		 RE reg = getCompiledPattern(options);
		 if (!matches(input, reg)) {
			 return null;
		 }
		 Vector v = new Vector();
		 int cnt = reg.getParenCount();
		 for (int i = 0;
		 i < cnt;
		 i++) {
			 String match = reg.getParen(i);
			 if (match == null) {
				 match = """";
			 }
			 v.addElement(match);
		 }
		 return v;
	 }
	 protected int getCompilerOptions(int options) {
		 int cOptions = RE.MATCH_NORMAL;
		 if (RegexpUtil.hasFlag(options, MATCH_CASE_INSENSITIVE)) {
			 cOptions |= RE.MATCH_CASEINDEPENDENT;
		 }
		 if (RegexpUtil.hasFlag(options, MATCH_MULTILINE)) {
			 cOptions |= RE.MATCH_MULTILINE;
		 }
		 if (RegexpUtil.hasFlag(options, MATCH_SINGLELINE)) {
			 cOptions |= RE.MATCH_SINGLELINE;
		 }
		 return cOptions;
	 }
}",0,0,0,0
"public long getStart() {
	 return start;
 }",0,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 int width = image.getWidth();
	int height = image.getHeight();
	 while (width % N != 0) {
		 width--;
	 }
	 while (height % N != 0) {
		 height--;
	 }
	 originalImage = resize(image, width, height);
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 int numXpatches = width/N;
	 int numYpatches = height/N;
	 double treshold = 3*sigma;
	 double [][] T = createT();
	 double [][] Tinv = null;
	 if (N==16) {
		 Tinv = createTinv16X16();
	 }
	 if (N==8) {
		 Tinv = createTinv();
	 }
	 for (int i = 0;
	 i < numXpatches;
	 i++) {
		 for (int j = 0;
		 j < numYpatches;
		 j++) {
			 double [][] M = createM(i, j);
			 double[][] D = multiply(multiply(T, M), Tinv);
			 tresholdDmatrix(D, treshold);
			 int [][] Q = null;
			 if (N==16) {
				 Q = createQ16X16();
			 }
			 if (N==8){
				 Q = createQ50();
				 updateQ(Q);
			 }
			 int [][] C = createC(D, Q);
			 double [][] R = createR(Q, C);
			 int [][] Nmatrix = createN(Tinv, R, T);
			 fillFilteredImage(i, j, Nmatrix);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public class RowMutation implements IMutation, MessageProducer{
	 private static RowMutationSerializer serializer_ = new RowMutationSerializer();
	 public static final String FORWARD_HEADER = ""FORWARD"";
	 public static RowMutationSerializer serializer() {
		 return serializer_;
	 }
	 private String table_;
	 private ByteBuffer key_;
	 protected Map<Integer, ColumnFamily> modifications_ = new HashMap<Integer, ColumnFamily>();
	 private Map<Integer, byte[]> preserializedBuffers = new HashMap<Integer, byte[]>();
	 public RowMutation(String table, ByteBuffer key) {
		 table_ = table;
		 key_ = key;
	 }
	 public RowMutation(String table, Row row) {
		 table_ = table;
		 key_ = row.key.key;
		 add(row.cf);
	 }
	 protected RowMutation(String table, ByteBuffer key, Map<Integer, ColumnFamily> modifications) {
		 table_ = table;
		 key_ = key;
		 modifications_ = modifications;
	 }
	 public String getTable() {
		 return table_;
	 }
	 public Collection<Integer> getColumnFamilyIds() {
		 return modifications_.keySet();
	 }
	 public ByteBuffer key() {
		 return key_;
	 }
	 public Collection<ColumnFamily> getColumnFamilies() {
		 return modifications_.values();
	 }
	 public ColumnFamily getColumnFamily(Integer cfId) {
		 return modifications_.get(cfId);
	 }
	 public static RowMutation hintFor(RowMutation mutation, ByteBuffer token) throws IOException {
		 RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, token);
		 ByteBuffer hintId = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes());
		 int ttl = Integer.MAX_VALUE;
		 for (ColumnFamily cf : mutation.getColumnFamilies()) ttl = Math.min(ttl, cf.metadata().getGcGraceSeconds());
		 QueryPath path = new QueryPath(HintedHandOffManager.HINTS_CF, hintId, ByteBufferUtil.bytes(""mutation""));
		 rm.add(path, ByteBuffer.wrap(mutation.getSerializedBuffer(MessagingService.version_)), System.currentTimeMillis(), ttl);
		 path = new QueryPath(HintedHandOffManager.HINTS_CF, hintId, ByteBufferUtil.bytes(""version""));
		 rm.add(path, ByteBufferUtil.bytes(MessagingService.version_), System.currentTimeMillis(), ttl);
		 path = new QueryPath(HintedHandOffManager.HINTS_CF, hintId, ByteBufferUtil.bytes(""table""));
		 rm.add(path, ByteBufferUtil.bytes(mutation.getTable()), System.currentTimeMillis(), ttl);
		 path = new QueryPath(HintedHandOffManager.HINTS_CF, hintId, ByteBufferUtil.bytes(""key""));
		 rm.add(path, mutation.key(), System.currentTimeMillis(), ttl);
		 return rm;
	 }
	 public void add(ColumnFamily columnFamily) {
		 assert columnFamily != null;
		 ColumnFamily prev = modifications_.put(columnFamily.id(), columnFamily);
		 if (prev != null) throw new IllegalArgumentException(""ColumnFamily "" + columnFamily + "" already has modifications in this mutation: "" + prev);
	 }
	 public ColumnFamily addOrGet(String cfName) {
		 CFMetaData cfm = Schema.instance.getCFMetaData(table_, cfName);
		 ColumnFamily cf = modifications_.get(cfm.cfId);
		 if (cf == null) {
			 cf = ColumnFamily.create(cfm);
			 modifications_.put(cfm.cfId, cf);
		 }
		 return cf;
	 }
	 public boolean isEmpty() {
		 return modifications_.isEmpty();
	 }
	 public void add(QueryPath path, ByteBuffer value, long timestamp, int timeToLive) {
		 Integer id = Schema.instance.getId(table_, path.columnFamilyName);
		 ColumnFamily columnFamily = modifications_.get(id);
		 if (columnFamily == null) {
			 columnFamily = ColumnFamily.create(table_, path.columnFamilyName);
			 modifications_.put(id, columnFamily);
		 }
		 columnFamily.addColumn(path, value, timestamp, timeToLive);
	 }
	 public void addCounter(QueryPath path, long value) {
		 Integer id = Schema.instance.getId(table_, path.columnFamilyName);
		 ColumnFamily columnFamily = modifications_.get(id);
		 if (columnFamily == null) {
			 columnFamily = ColumnFamily.create(table_, path.columnFamilyName);
			 modifications_.put(id, columnFamily);
		 }
		 columnFamily.addCounter(path, value);
	 }
	 public void add(QueryPath path, ByteBuffer value, long timestamp) {
		 add(path, value, timestamp, 0);
	 }
	 public void delete(QueryPath path, long timestamp) {
		 Integer id = Schema.instance.getId(table_, path.columnFamilyName);
		 int localDeleteTime = (int) (System.currentTimeMillis() / 1000);
		 ColumnFamily columnFamily = modifications_.get(id);
		 if (columnFamily == null) {
			 columnFamily = ColumnFamily.create(table_, path.columnFamilyName);
			 modifications_.put(id, columnFamily);
		 }
		 if (path.superColumnName == null && path.columnName == null) {
			 columnFamily.delete(localDeleteTime, timestamp);
		 }
		 else if (path.columnName == null) {
			 SuperColumn sc = new SuperColumn(path.superColumnName, columnFamily.getSubComparator());
			 sc.delete(localDeleteTime, timestamp);
			 columnFamily.addColumn(sc);
		 }
		 else {
			 columnFamily.addTombstone(path, localDeleteTime, timestamp);
		 }
	 }
	 public void addAll(IMutation m) {
		 if (!(m instanceof RowMutation)) throw new IllegalArgumentException();
		 RowMutation rm = (RowMutation)m;
		 if (!table_.equals(rm.table_) || !key_.equals(rm.key_)) throw new IllegalArgumentException();
		 for (Map.Entry<Integer, ColumnFamily> entry : rm.modifications_.entrySet()) {
			 ColumnFamily cf = modifications_.put(entry.getKey(), entry.getValue());
			 if (cf != null) entry.getValue().resolve(cf);
		 }
	 }
	 public void apply() throws IOException {
		 KSMetaData ksm = Schema.instance.getTableDefinition(getTable());
		 Table.open(table_).apply(this, ksm.durableWrites);
	 }
	 public void applyUnsafe() throws IOException {
		 Table.open(table_).apply(this, false);
	 }
	 public Message getMessage(Integer version) throws IOException {
		 return getMessage(StorageService.Verb.MUTATION, version);
	 }
	 public Message getMessage(StorageService.Verb verb, int version) throws IOException {
		 return new Message(FBUtilities.getBroadcastAddress(), verb, getSerializedBuffer(version), version);
	 }
	 public synchronized byte[] getSerializedBuffer(int version) throws IOException {
		 byte[] bytes = preserializedBuffers.get(version);
		 if (bytes == null) {
			 bytes = FBUtilities.serialize(this, serializer(), version);
			 preserializedBuffers.put(version, bytes);
		 }
		 return bytes;
	 }
	 public String toString() {
		 return toString(false);
	 }
	 public String toString(boolean shallow) {
		 StringBuilder buff = new StringBuilder(""RowMutation("");
		 buff.append(""keyspace='"").append(table_).append('\'');
		 buff.append("", key='"").append(ByteBufferUtil.bytesToHex(key_)).append('\'');
		 buff.append("", modifications=["");
		 if (shallow) {
			 List<String> cfnames = new ArrayList<String>();
			 for (Integer cfid : modifications_.keySet()) {
				 CFMetaData cfm = Schema.instance.getCFMetaData(cfid);
				 cfnames.add(cfm == null ? ""-dropped-"" : cfm.cfName);
			 }
			 buff.append(StringUtils.join(cfnames, "", ""));
		 }
		 else buff.append(StringUtils.join(modifications_.values(), "", ""));
		 return buff.append(""])"").toString();
	 }
	 public void addColumnOrSuperColumn(String cfName, ColumnOrSuperColumn cosc) {
		 if (cosc.super_column != null) {
			 for (org.apache.cassandra.thrift.Column column : cosc.super_column.columns) {
				 add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, column.timestamp, column.ttl);
			 }
		 }
		 else if (cosc.column != null) {
			 add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, cosc.column.timestamp, cosc.column.ttl);
		 }
		 else if (cosc.counter_super_column != null) {
			 for (org.apache.cassandra.thrift.CounterColumn column : cosc.counter_super_column.columns) {
				 addCounter(new QueryPath(cfName, cosc.counter_super_column.name, column.name), column.value);
			 }
		 }
		 else {
			 addCounter(new QueryPath(cfName, null, cosc.counter_column.name), cosc.counter_column.value);
		 }
	 }
	 public void deleteColumnOrSuperColumn(String cfName, Deletion del) {
		 if (del.predicate != null && del.predicate.column_names != null) {
			 for(ByteBuffer c : del.predicate.column_names) {
				 if (del.super_column == null && Schema.instance.getColumnFamilyType(table_, cfName) == ColumnFamilyType.Super) delete(new QueryPath(cfName, c), del.timestamp);
				 else delete(new QueryPath(cfName, del.super_column, c), del.timestamp);
			 }
		 }
		 else {
			 delete(new QueryPath(cfName, del.super_column), del.timestamp);
		 }
	 }
	 public static RowMutation fromBytes(byte[] raw, int version) throws IOException {
		 RowMutation rm = serializer_.deserialize(new DataInputStream(new FastByteArrayInputStream(raw)), version);
		 boolean hasCounters = false;
		 for (Map.Entry<Integer, ColumnFamily> entry : rm.modifications_.entrySet()) {
			 if (entry.getValue().metadata().getDefaultValidator().isCommutative()) {
				 hasCounters = true;
				 break;
			 }
		 }
		 if (!hasCounters && version == MessagingService.version_) rm.preserializedBuffers.put(version, raw);
		 return rm;
	 }
	 public static class RowMutationSerializer implements IVersionedSerializer<RowMutation> {
		 public void serialize(RowMutation rm, DataOutput dos, int version) throws IOException {
			 dos.writeUTF(rm.getTable());
			 ByteBufferUtil.writeWithShortLength(rm.key(), dos);
			 int size = rm.modifications_.size();
			 dos.writeInt(size);
			 assert size >= 0;
			 for (Map.Entry<Integer,ColumnFamily> entry : rm.modifications_.entrySet()) {
				 dos.writeInt(entry.getKey());
				 ColumnFamily.serializer().serialize(entry.getValue(), dos);
			 }
		 }
		 public RowMutation deserialize(DataInput dis, int version, IColumnSerializer.Flag flag) throws IOException {
			 String table = dis.readUTF();
			 ByteBuffer key = ByteBufferUtil.readWithShortLength(dis);
			 Map<Integer, ColumnFamily> modifications = new HashMap<Integer, ColumnFamily>();
			 int size = dis.readInt();
			 for (int i = 0;
			 i < size;
			 ++i) {
				 Integer cfid = Integer.valueOf(dis.readInt());
				 ColumnFamily cf = ColumnFamily.serializer().deserialize(dis, flag, TreeMapBackedSortedColumns.factory());
				 modifications.put(cfid, cf);
			 }
			 return new RowMutation(table, key, modifications);
		 }
		 public RowMutation deserialize(DataInput dis, int version) throws IOException {
			 return deserialize(dis, version, IColumnSerializer.Flag.FROM_REMOTE);
		 }
		 public long serializedSize(RowMutation rm, int version) {
			 int size = DBConstants.shortSize + FBUtilities.encodedUTF8Length(rm.getTable());
			 size += DBConstants.shortSize + rm.key().remaining();
			 size += DBConstants.intSize;
			 for (Map.Entry<Integer,ColumnFamily> entry : rm.modifications_.entrySet()) {
				 size += DBConstants.intSize;
				 size += entry.getValue().serializedSize();
			 }
			 return size;
		 }
	 }
}",0,0,0,0
"interface Parameters {
	 Charset getEncoding();
	 File getData();
	 "") Boolean getSplitHyphenatedTokens();
	 String getLang();
 }",0,0,0,0
"private static class FileExtensionFilter implements FilenameFilter {
	 private String extension;
	 private FileExtensionFilter(String extension) {
		 this.extension = extension;
	 }
	 public boolean accept(File dir, String name) {
		 return name.endsWith(this.extension);
	 }
 }",0,0,0,0
"public abstract class MqttMessageDeliveryEvent extends MqttIntegrationEvent {
	private final int messageId;
	private final String clientId;
	private final int clientInstance;
	public MqttMessageDeliveryEvent(Object source, int messageId, String clientId, int clientInstance) {
		super(source);
		this.messageId = messageId;
		this.clientId = clientId;
		this.clientInstance = clientInstance;
	}
	public int getMessageId() {
		return this.messageId;
	}
	public String getClientId() {
		return this.clientId;
	}
	public int getClientInstance() {
		return this.clientInstance;
	}
}",0,1,0,0
"public String getId() {
	 return ""AddFreeItemToOrders"";
 }",0,0,0,0
"public void execute() throws BuildException {
	 if (splash != null) {
		 splash.setVisible(false);
		 getProject().removeBuildListener(splash);
		 splash.dispose();
		 splash = null;
	 }
	 log(""Creating new SplashScreen"", Project.MSG_VERBOSE);
	 InputStream in = null;
	 if (imgurl != null) {
		 try {
			 URLConnection conn = null;
			 SetProxy sp = new SetProxy();
			 sp.setProxyHost(proxy);
			 if (port != null) {
				 sp.setProxyPort(Integer.parseInt(port));
			 }
			 sp.setProxyUser(user);
			 sp.setProxyPassword(password);
			 sp.applyWebProxySettings();
			 if (useProxy && (proxy != null && proxy.length() > 0) && (port != null && port.length() > 0)) {
				 log(""Using proxied Connection"", Project.MSG_DEBUG);
				 System.getProperties().put(""http.proxySet"", ""true"");
				 URL url = new URL(imgurl);
				 conn = url.openConnection();
				 if (user != null && user.length() > 0) {
					 String encodedcreds = new Base64Converter().encode(user + "":"" + password);
					 conn.setRequestProperty(""Proxy-Authorization"", encodedcreds);
				 }
			 }
			 else {
				 System.getProperties().put(""http.proxySet"", ""false"");
				 log(""Using Direction HTTP Connection"", Project.MSG_DEBUG);
				 URL url = new URL(imgurl);
				 conn = url.openConnection();
			 }
			 conn.setDoInput(true);
			 conn.setDoOutput(false);
			 in = conn.getInputStream();
		 }
		 catch (Throwable ioe) {
			 log(""Unable to download image, trying default Ant Logo"", Project.MSG_DEBUG);
			 log(""(Exception was \"""" + ioe.getMessage() + ""\"""", Project.MSG_DEBUG);
		 }
	 }
	 if (in == null) {
		 ClassLoader cl = SplashTask.class.getClassLoader();
		 if (cl != null) {
			 in = cl.getResourceAsStream(""images/ant_logo_large.gif"");
		 }
		 else {
			 in = ClassLoader .getSystemResourceAsStream(""images/ant_logo_large.gif"");
		 }
	 }
	 boolean success = false;
	 if (in != null) {
		 DataInputStream din = new DataInputStream(in);
		 try {
			 ByteArrayOutputStream bout = new ByteArrayOutputStream();
			 int data;
			 while ((data = din.read()) != -1) {
				 bout.write((byte) data);
			 }
			 log(""Got ByteArray, creating splash"", Project.MSG_DEBUG);
			 try {
				 ImageIcon img = new ImageIcon(bout.toByteArray());
				 splash = new SplashScreen(img, progressRegExp, displayText);
				 success = true;
			 }
			 catch (Throwable e) {
				 logHeadless(e);
			 }
		 }
		 catch (Exception e) {
			 throw new BuildException(e);
		 }
		 finally {
			 try {
				 din.close();
			 }
			 catch (IOException ioe) {
				 if (success) {
					 throw new BuildException(ioe);
				 }
			 }
		 }
	 }
	 else {
		 try {
			 splash = new SplashScreen(""Image Unavailable."", progressRegExp, displayText);
			 success = true;
		 }
		 catch (Throwable e) {
			 logHeadless(e);
		 }
	 }
	 if (success) {
		 splash.setVisible(true);
		 splash.toFront();
		 getProject().addBuildListener(splash);
		 try {
			 Thread.sleep(showDuration);
		 }
		 catch (InterruptedException e) {
		 }
	 }
 }",0,0,1,0
"public class NsTestPrintStream extends PrintStream{
	 private boolean _chatty;
	 public NsTestPrintStream( PrintStream wrappedStream, boolean chatty ) {
		 super( wrappedStream );
		 _chatty = chatty;
	 }
	 public PrintStream append( char c ) {
		 if ( _chatty ) {
			 super.append( c );
		 }
		 return this;
	 }
	 public PrintStream append( CharSequence csq ) {
		 if ( _chatty ) {
			 super.append( csq );
		 }
		 return this;
	 }
	 public PrintStream append( CharSequence csq, int start, int end ) {
		 if ( _chatty ) {
			 super.append( csq, start, end );
		 }
		 return this;
	 }
	 public boolean checkError() {
		 return super.checkError();
	 }
	 protected void clearError() {
		 super.clearError();
	 }
	 public void close() {
		 super.close();
	 }
	 public void flush() {
		 super.flush();
	 }
	 public void print( boolean b ) {
		 if ( _chatty ) {
			 super.print( b );
		 }
	 }
	 public void print( char c ) {
		 if ( _chatty ) {
			 super.print( c );
		 }
	 }
	 public void print( int i ) {
		 if ( _chatty ) {
			 super.print( i );
		 }
	 }
	 public void print( long l ) {
		 if ( _chatty ) {
			 super.print( l );
		 }
	 }
	 public void print( float f ) {
		 if ( _chatty ) {
			 super.print( f );
		 }
	 }
	 public void print( double d ) {
		 if ( _chatty ) {
			 super.print( d );
		 }
	 }
	 public void print( char[] s ) {
		 if ( _chatty ) {
			 super.print( s );
		 }
	 }
	 public void print( String s ) {
		 if ( _chatty ) {
			 super.print( s );
		 }
	 }
	 public void print( Object obj ) {
		 if ( _chatty ) {
			 super.print( obj );
		 }
	 }
	 public void println() {
		 if ( _chatty ) {
			 super.println();
		 }
	 }
	 public void println( boolean x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( char x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( int x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( long x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( float x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( double x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( char[] x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( String x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public void println( Object x ) {
		 if ( _chatty ) {
			 super.println( x );
		 }
	 }
	 public PrintStream printf( String format, Object... args ) {
		 if ( _chatty ) {
			 super.printf( format, args );
		 }
		 return this;
	 }
	 public PrintStream printf( Locale l, String format, Object... args ) {
		 if ( _chatty ) {
			 super.printf( l, format, args );
		 }
		 return this;
	 }
	 public PrintStream format( String format, Object... args ) {
		 if ( _chatty ) {
			 super.format( format, args );
		 }
		 return this;
	 }
	 public PrintStream format( Locale l, String format, Object... args ) {
		 if ( _chatty ) {
			 super.format( l, format, args );
		 }
		 return this;
	 }
	 public void write( byte[] buf, int off, int len ) {
		 if ( _chatty ) {
			 super.write( buf, off, len );
		 }
	 }
	 public void write( int b ) {
		 if ( _chatty ) {
			 super.write( b );
		 }
	 }
}",1,0,0,0
"public interface Modification {
	 void accept(QueryExpressionVisitor v);
	 ModificationType getModificationType();
}",0,0,0,0
"public abstract class UPlaceholderExpression extends UExpression {
	 static UPlaceholderExpression create( PlaceholderMethod placeholder, Iterable<? extends UExpression> arguments) {
		 ImmutableList<UVariableDecl> placeholderParams = placeholder.parameters().asList();
		 ImmutableList<UExpression> argumentsList = ImmutableList.copyOf(arguments);
		 ImmutableMap.Builder<UVariableDecl, UExpression> builder = ImmutableMap.builder();
		 for (int i = 0;
		 i < placeholderParams.size();
		 i++) {
			 builder.put(placeholderParams.get(i), argumentsList.get(i));
		 }
		 return new AutoValue_UPlaceholderExpression(placeholder, builder.build());
	 }
	 abstract PlaceholderMethod placeholder();
	 abstract ImmutableMap<UVariableDecl, UExpression> arguments();
	 public static final class PlaceholderParamIdent extends JCIdent {
		 final UVariableDecl param;
		 PlaceholderParamIdent(UVariableDecl param, Context context) {
			 super(Names.instance(context).fromString(param.getName().contents()), null);
			 this.param = checkNotNull(param);
		 }
	 }
	 static class UncheckedCouldNotResolveImportException extends RuntimeException {
		 UncheckedCouldNotResolveImportException(CouldNotResolveImportException e) {
			 super(e);
		 }
		 public synchronized CouldNotResolveImportException getCause() {
			 return (CouldNotResolveImportException) super.getCause();
		 }
	 }
	 static TreeCopier<Inliner> copier( final Map<UVariableDecl, UExpression> arguments, Inliner inliner) {
		 return new TreeCopier<Inliner>(inliner.maker()) {
			 public <T extends JCTree> T copy(T tree, Inliner inliner) {
				 if (tree == null) {
					 return null;
				 }
				 T result = super.copy(tree, inliner);
				 if (result.toString().equals(tree.toString())) {
					 return tree;
				 }
				 else {
					 return result;
				 }
			 }
			 public JCTree visitIdentifier(IdentifierTree node, Inliner inliner) {
				 if (node instanceof PlaceholderParamIdent) {
					 try {
						 return arguments.get(((PlaceholderParamIdent) node).param).inline(inliner);
					 }
					 catch (CouldNotResolveImportException e) {
						 throw new UncheckedCouldNotResolveImportException(e);
					 }
				 }
				 else {
					 return super.visitIdentifier(node, inliner);
				 }
			 }
		 }
		;
	 }
	 public JCExpression inline(Inliner inliner) throws CouldNotResolveImportException {
		 try {
			 return copier(arguments(), inliner) .copy(inliner.getBinding(placeholder().exprKey()), inliner);
		 }
		 catch (UncheckedCouldNotResolveImportException e) {
			 throw e.getCause();
		 }
	 }
	 public Kind getKind() {
		 return Kind.OTHER;
	 }
	 public <R, D> R accept(TreeVisitor<R, D> visitor, D data) {
		 return visitor.visitOther(this, data);
	 }
	 public boolean reverify(Unifier unifier) {
		 return MoreObjects.firstNonNull( new PlaceholderVerificationVisitor( Collections2.transform( placeholder().requiredParameters(), Functions.forMap(arguments())), arguments().values()) .scan(unifier.getBinding(placeholder().exprKey()), unifier), true);
	 }
	 protected Choice<Unifier> defaultAction(Tree node, Unifier unifier) {
		 if (placeholder().returnType().equals(UPrimitiveType.VOID) || !(node instanceof JCExpression)) {
			 return Choice.none();
		 }
		 final JCExpression expr = (JCExpression) node;
		 PlaceholderVerificationVisitor verification = new PlaceholderVerificationVisitor( Collections2.transform( placeholder().requiredParameters(), Functions.forMap(arguments())), arguments().values());
		 if (!verification.scan(node, unifier) || !verification.allRequiredMatched()) {
			 return Choice.none();
		 }
		 Choice<? extends PlaceholderUnificationVisitor.State<? extends JCExpression>> states = PlaceholderUnificationVisitor.create(TreeMaker.instance(unifier.getContext()), arguments()) .unifyExpression( expr, PlaceholderUnificationVisitor.State.create( List.<UVariableDecl>nil(), unifier, null));
		 return states.thenOption( (PlaceholderUnificationVisitor.State<? extends JCExpression> state) -> {
			 if (ImmutableSet.copyOf(state.seenParameters()) .containsAll(placeholder().requiredParameters())) {
				 Unifier resultUnifier = state.unifier();
				 JCExpression prevBinding = resultUnifier.getBinding(placeholder().exprKey());
				 if (prevBinding != null) {
					 return prevBinding.toString().equals(state.result().toString()) ? Optional.of(resultUnifier) : Optional.<Unifier>absent();
				 }
				 JCExpression result = state.result();
				 if (!placeholder() .matcher() .matches(result, UMatches.makeVisitorState(expr, resultUnifier))) {
					 return Optional.absent();
				 }
				 result.type = expr.type;
				 resultUnifier.putBinding(placeholder().exprKey(), result);
				 return Optional.of(resultUnifier);
			 }
			 else {
				 return Optional.absent();
			 }
		 }
		);
	 }
}",1,0,0,0
"public java.util.concurrent.Future<GenerateAutonomousDatabaseWalletResponse> generateAutonomousDatabaseWallet( final GenerateAutonomousDatabaseWalletRequest request, final com.oracle.bmc.responses.AsyncHandler< GenerateAutonomousDatabaseWalletRequest, GenerateAutonomousDatabaseWalletResponse> handler) {
	 LOG.trace(""Called async generateAutonomousDatabaseWallet"");
	 final GenerateAutonomousDatabaseWalletRequest interceptedRequest = GenerateAutonomousDatabaseWalletConverter.interceptRequest(request);
	 final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib = GenerateAutonomousDatabaseWalletConverter.fromRequest(client, interceptedRequest);
	 final com.google.common.base.Function< javax.ws.rs.core.Response, GenerateAutonomousDatabaseWalletResponse> transformer = GenerateAutonomousDatabaseWalletConverter.fromResponse();
	 com.oracle.bmc.responses.AsyncHandler< GenerateAutonomousDatabaseWalletRequest, GenerateAutonomousDatabaseWalletResponse> handlerToUse = handler;
	 if (handler != null && this.authenticationDetailsProvider instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
		 handlerToUse = new com.oracle.bmc.util.internal.RefreshAuthTokenWrappingAsyncHandler< GenerateAutonomousDatabaseWalletRequest, GenerateAutonomousDatabaseWalletResponse>( (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) this.authenticationDetailsProvider, handler) {
			 public void retryCall() {
				 final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess = new com.oracle.bmc.http.internal.SuccessConsumer<>( this, transformer, interceptedRequest);
				 final com.oracle.bmc.util.internal.Consumer<Throwable> onError = new com.oracle.bmc.http.internal.ErrorConsumer<>( this, interceptedRequest);
				 client.post( ib, interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(), interceptedRequest, onSuccess, onError);
			 }
		 }
		;
	 }
	 final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess = (handler == null) ? null : new com.oracle.bmc.http.internal.SuccessConsumer<>( handlerToUse, transformer, interceptedRequest);
	 final com.oracle.bmc.util.internal.Consumer<Throwable> onError = (handler == null) ? null : new com.oracle.bmc.http.internal.ErrorConsumer<>( handlerToUse, interceptedRequest);
	 java.util.concurrent.Future<javax.ws.rs.core.Response> responseFuture = client.post( ib, interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(), interceptedRequest, onSuccess, onError);
	 if (this.authenticationDetailsProvider instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
		 return new com.oracle.bmc.util.internal.RefreshAuthTokenTransformingFuture< javax.ws.rs.core.Response, GenerateAutonomousDatabaseWalletResponse>( responseFuture, transformer, (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) this.authenticationDetailsProvider, new com.google.common.base.Supplier< java.util.concurrent.Future<javax.ws.rs.core.Response>>() {
			 public java.util.concurrent.Future<javax.ws.rs.core.Response> get() {
				 return client.post( ib, interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(), interceptedRequest, onSuccess, onError);
			 }
		 }
		);
	 }
	 else {
		 return new com.oracle.bmc.util.internal.TransformingFuture<>( responseFuture, transformer);
	 }
 }",0,0,1,0
"public class UFile {
	static {
		System.loadLibrary(""jtux"");
	}
	static public class s_iovec {
		public byte[] iov_base;
		public int iov_len;
	}
	static public class s_statvfs {
		public long f_bsize;
		public long f_frsize;
		public long f_blocks;
		public long f_bfree;
		public long f_bavail;
		public long f_files;
		public long f_ffree;
		public long f_favail;
		public long f_fsid;
		public long f_flag;
		public long f_namemax;
	}
	static public class s_stat {
		public long st_dev;
		public int st_ino;
		public int st_mode;
		public int st_nlink;
		public long st_uid;
		public long st_gid;
		public long st_rdev;
		public long st_size;
		public long st_atime;
		public long st_mtime;
		public long st_ctime;
		public int st_blksize;
		public long st_blocks;
	}
	static public class s_utimbuf {
		public long actime;
		public long modtime;
	}
	static public class fd_set {
		static {
			System.loadLibrary(""jtux"");
			System.out.println(""Loaded"");
		}
		public byte[] set = new byte[GetSize_fd_set()];
		native int GetSize_fd_set();
	}
	static public class s_pollfd {
		public int fd;
		public short events;
		public short revents;
	}
	public native static void access(String path, int what) throws UErrorException;
	public native static void chmod(String path, int mode) throws UErrorException;
	public native static void chown(String path, long uid, long gid) throws UErrorException;
	public native static void close(int fd) throws UErrorException;
	public static int creat(String path, int perms) throws UErrorException {
		return open(path, UConstant.O_WRONLY | UConstant.O_CREAT | UConstant.O_TRUNC, perms);
	}
	public native static int dup(int fd) throws UErrorException;
	public native static int dup2(int fd, int fd2) throws UErrorException;
	public native static void fchmod(int fd, int mode) throws UErrorException;
	public native static void fchown(int fd, long uid, long gid) throws UErrorException;
	public native static int fcntl(int fd, int op, int arg) throws UErrorException;
	public native static void FD_ZERO(fd_set set);
	public native static void FD_SET(int fd, fd_set set);
	public native static void FD_CLR(int fd, fd_set set);
	public native static boolean FD_ISSET(int fd, fd_set set);
	public native static void fdatasync(int fd) throws UErrorException;
	public native static void fstat(int fd, s_stat buf) throws UErrorException;
	public native static void fstatvfs(int fd, s_statvfs buf) throws UErrorException;
	public native static void fsync(int fd) throws UErrorException;
	public native static void ftruncate(int fd, long length) throws UErrorException;
	public native static void lchown(String path, long uid, long gid) throws UErrorException;
	public native static void link(String oldpath, String newpath) throws UErrorException;
	public native static void lockf(int fd, int op, long len) throws UErrorException;
	public native static long lseek(int fd, long pos, int whence) throws UErrorException;
	public native static void lstat(String path, s_stat buf) throws UErrorException;
	public native static void mkfifo(String path, int perms) throws UErrorException;
	public native static void mknod(String path, int mode, long dev) throws UErrorException;
	public native static int mkstemp(StringBuffer template) throws UErrorException;
	public native static int open(String path, int flags, int perms) throws UErrorException;
	public static int open(String path, int flags) throws UErrorException {
		return open(path, flags, 0);
	}
	public native static void pipe(int[] pfd) throws UErrorException;
	public native static int poll(s_pollfd[] fdinfo, int nfds, int timeout);
	public native static int pread(int fd, byte[] buf, int nbytes, long offset) throws UErrorException;
	public native static int pselect(int nfds, fd_set readset, fd_set writeset, fd_set errorset, UProcess.s_timespec timeout, UProcess.sigset_t sigmask) throws UErrorException;
	public native static int pwrite(int fd, byte[] buf, int nbytes, long position) throws UErrorException;
	public native static int read(int fd, byte[] buf, int nbytes) throws UErrorException;
	public native static int readlink(String path, byte[] buf, int bufsize) throws UErrorException;
	public native static int readv(int fd, s_iovec[] iov, int iovcnt) throws UErrorException;
	public native static void rename(String oldpath, String newpath) throws UErrorException;
	public native static boolean S_ISBLK(int mode);
	public native static boolean S_ISCHR(int mode);
	public native static boolean S_ISDIR(int mode);
	public native static boolean S_ISFIFO(int mode);
	public native static boolean S_ISLNK(int mode);
	public native static boolean S_ISREG(int mode);
	public native static boolean S_ISSOCK(int mode);
	public native static int select(int nfds, fd_set readset, fd_set writeset, fd_set errorset, UProcess.s_timeval timeout) throws UErrorException;
	public native static void stat(String path, s_stat buf) throws UErrorException;
	public native static void statvfs(String path, s_statvfs buf) throws UErrorException;
	public native static void symlink(String oldpath, String newpath) throws UErrorException;
	public native static void sync();
	public native static void truncate(String path, long length) throws UErrorException;
	public native static void unlink(String path) throws UErrorException;
	public native static void utime(String path, s_utimbuf timbuf) throws UErrorException;
	public native static int ioctl(int fd, int request, byte[] buf) throws UErrorException;
	public native static int ioctl2(int fd, int request, int arg) throws UErrorException;
	public native static int write(int fd, byte[] buf, int nbytes) throws UErrorException;
	public native static int writev(int fd, s_iovec[] iov, int iovcnt) throws UErrorException;
}",1,0,0,0
"public class JavadocFormatter {
	 private static final String CODE_RESET = ""\033[0m"";
	 private static final String CODE_HIGHLIGHT = ""\033[1m"";
	 private static final String CODE_UNDERLINE = ""\033[4m"";
	 private final int lineLimit;
	 private final boolean escapeSequencesSupported;
	 public JavadocFormatter(int lineLimit, boolean escapeSequencesSupported) {
		 this.lineLimit = lineLimit;
		 this.escapeSequencesSupported = escapeSequencesSupported;
	 }
	 private static final int MAX_LINE_LENGTH = 95;
	 private static final int SHORTEST_LINE = 30;
	 private static final int INDENT = 4;
	 public String formatJavadoc(String header, String javadoc) {
		 try {
			 StringBuilder result = new StringBuilder();
			 result.append(escape(CODE_HIGHLIGHT)).append(header).append(escape(CODE_RESET)).append(""\n"");
			 if (javadoc == null) {
				 return result.toString();
			 }
			 JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, null);
			 DocTrees trees = DocTrees.instance(task);
			 DocCommentTree docComment = trees.getDocCommentTree(new SimpleJavaFileObject(new URI(""mem: public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
				 return ""<body>"" + javadoc + ""</body>"";
			 }
		 }
		);
		 new FormatJavadocScanner(result, task).scan(docComment, null);
		 addNewLineIfNeeded(result);
		 return result.toString();
	 }
	 catch (URISyntaxException ex) {
		 throw new InternalError(""Unexpected exception"", ex);
	 }
 }
 private class FormatJavadocScanner extends DocTreeScanner<Object, Object> {
	 private final StringBuilder result;
	 private final JavacTask task;
	 private int reflownTo;
	 private int indent;
	 private int limit = Math.min(lineLimit, MAX_LINE_LENGTH);
	 private boolean pre;
	 private Map<StartElementTree, Integer> tableColumns;
	 public FormatJavadocScanner(StringBuilder result, JavacTask task) {
		 this.result = result;
		 this.task = task;
	 }
	 public Object visitDocComment(DocCommentTree node, Object p) {
		 tableColumns = countTableColumns(node);
		 reflownTo = result.length();
		 scan(node.getFirstSentence(), p);
		 scan(node.getBody(), p);
		 reflow(result, reflownTo, indent, limit);
		 for (Sections current : docSections.keySet()) {
			 boolean seenAny = false;
			 for (DocTree t : node.getBlockTags()) {
				 if (current.matches(t)) {
					 if (!seenAny) {
						 seenAny = true;
						 if (result.charAt(result.length() - 1) != '\n') result.append(""\n"");
						 result.append(""\n"");
						 result.append(escape(CODE_UNDERLINE)) .append(docSections.get(current)) .append(escape(CODE_RESET)) .append(""\n"");
					 }
					 scan(t, null);
				 }
			 }
		 }
		 return null;
	 }
	 public Object visitText(TextTree node, Object p) {
		 String text = node.getBody();
		 if (!pre) {
			 text = text.replaceAll(""[ \t\r\n]+"", "" "").trim();
			 if (text.isEmpty()) {
				 text = "" "";
			 }
		 }
		 else {
			 text = text.replaceAll(""\n"", ""\n"" + indentString(indent));
		 }
		 result.append(text);
		 return null;
	 }
	 public Object visitLink(LinkTree node, Object p) {
		 if (!node.getLabel().isEmpty()) {
			 scan(node.getLabel(), p);
		 }
		 else {
			 result.append(node.getReference().getSignature());
		 }
		 return null;
	 }
	 public Object visitParam(ParamTree node, Object p) {
		 return formatDef(node.getName().getName(), node.getDescription());
	 }
	 public Object visitThrows(ThrowsTree node, Object p) {
		 return formatDef(node.getExceptionName().getSignature(), node.getDescription());
	 }
	 public Object formatDef(CharSequence name, List<? extends DocTree> description) {
		 result.append(name);
		 result.append("" - "");
		 reflownTo = result.length();
		 indent = name.length() + 3;
		 if (limit - indent < SHORTEST_LINE) {
			 result.append(""\n"");
			 result.append(indentString(INDENT));
			 indent = INDENT;
			 reflownTo += INDENT;
		 }
		 try {
			 return scan(description, null);
		 }
		 finally {
			 reflow(result, reflownTo, indent, limit);
			 result.append(""\n"");
		 }
	 }
	 public Object visitLiteral(LiteralTree node, Object p) {
		 return scan(node.getBody(), p);
	 }
	 public Object visitReturn(ReturnTree node, Object p) {
		 reflownTo = result.length();
		 try {
			 return super.visitReturn(node, p);
		 }
		 finally {
			 reflow(result, reflownTo, 0, limit);
		 }
	 }
	 Stack<Integer> listStack = new Stack<>();
	 Stack<Integer> defStack = new Stack<>();
	 Stack<Integer> tableStack = new Stack<>();
	 Stack<List<Integer>> cellsStack = new Stack<>();
	 Stack<List<Boolean>> headerStack = new Stack<>();
	 public Object visitStartElement(StartElementTree node, Object p) {
		 switch (getHtmlTag(node.getName())) {
			 case P: if (lastNode!= null && lastNode.getKind() == DocTree.Kind.START_ELEMENT && HtmlTag.get(((StartElementTree) lastNode).getName()) == HtmlTag.LI) {
				 break;
			 }
			 reflowTillNow();
			 addNewLineIfNeeded(result);
			 result.append(indentString(indent));
			 reflownTo = result.length();
			 break;
			 case BLOCKQUOTE: reflowTillNow();
			 indent += INDENT;
			 break;
			 case PRE: reflowTillNow();
			 pre = true;
			 break;
			 case UL: reflowTillNow();
			 listStack.push(-1);
			 indent += INDENT;
			 break;
			 case OL: reflowTillNow();
			 listStack.push(1);
			 indent += INDENT;
			 break;
			 case DL: reflowTillNow();
			 defStack.push(indent);
			 break;
			 case LI: reflowTillNow();
			 if (!listStack.empty()) {
				 addNewLineIfNeeded(result);
				 int top = listStack.pop();
				 if (top == (-1)) {
					 result.append(indentString(indent - 2));
					 result.append(""* "");
				 }
				 else {
					 result.append(indentString(indent - 3));
					 result.append("""" + top++ + "". "");
				 }
				 listStack.push(top);
				 reflownTo = result.length();
			 }
			 break;
			 case DT: reflowTillNow();
			 if (!defStack.isEmpty()) {
				 addNewLineIfNeeded(result);
				 indent = defStack.peek();
				 result.append(escape(CODE_HIGHLIGHT));
			 }
			 break;
			 case DD: reflowTillNow();
			 if (!defStack.isEmpty()) {
				 if (indent == defStack.peek()) {
					 result.append(escape(CODE_RESET));
				 }
				 addNewLineIfNeeded(result);
				 indent = defStack.peek() + INDENT;
				 result.append(indentString(indent));
			 }
			 break;
			 case H1: case H2: case H3: case H4: case H5: case H6: reflowTillNow();
			 addNewLineIfNeeded(result);
			 result.append(""\n"") .append(escape(CODE_UNDERLINE));
			 reflownTo = result.length();
			 break;
			 case TABLE: int columns = tableColumns.get(node);
			 if (columns == 0) {
				 break;
			 }
			 reflowTillNow();
			 addNewLineIfNeeded(result);
			 reflownTo = result.length();
			 tableStack.push(limit);
			 limit = (limit - 1) / columns - 3;
			 for (int sep = 0;
			 sep < (limit + 3) * columns + 1;
			 sep++) {
				 result.append(""-"");
			 }
			 result.append(""\n"");
			 break;
			 case TR: if (cellsStack.size() >= tableStack.size()) {
				 handleEndElement(node.getName());
			 }
			 cellsStack.push(new ArrayList<>());
			 headerStack.push(new ArrayList<>());
			 break;
			 case TH: case TD: if (cellsStack.isEmpty()) {
				 break;
			 }
			 reflowTillNow();
			 result.append(""\n"");
			 reflownTo = result.length();
			 cellsStack.peek().add(result.length());
			 headerStack.peek().add(HtmlTag.get(node.getName()) == HtmlTag.TH);
			 break;
			 case IMG: for (DocTree attr : node.getAttributes()) {
				 if (attr.getKind() != DocTree.Kind.ATTRIBUTE) {
					 continue;
				 }
				 AttributeTree at = (AttributeTree) attr;
				 if (""alt"".equals(StringUtils.toLowerCase(at.getName().toString()))) {
					 addSpaceIfNeeded(result);
					 scan(at.getValue(), null);
					 addSpaceIfNeeded(result);
					 break;
				 }
			 }
			 break;
			 default: addSpaceIfNeeded(result);
			 break;
		 }
		 return null;
	 }
	 public Object visitEndElement(EndElementTree node, Object p) {
		 handleEndElement(node.getName());
		 return super.visitEndElement(node, p);
	 }
	 private void handleEndElement(Name name) {
		 switch (getHtmlTag(name)) {
			 case BLOCKQUOTE: indent -= INDENT;
			 break;
			 case PRE: pre = false;
			 addNewLineIfNeeded(result);
			 reflownTo = result.length();
			 break;
			 case UL: case OL: if (listStack.isEmpty()) {
				 break;
			 }
			 reflowTillNow();
			 listStack.pop();
			 indent -= INDENT;
			 addNewLineIfNeeded(result);
			 break;
			 case DL: if (defStack.isEmpty()) {
				 break;
			 }
			 reflowTillNow();
			 if (indent == defStack.peek()) {
				 result.append(escape(CODE_RESET));
			 }
			 indent = defStack.pop();
			 addNewLineIfNeeded(result);
			 break;
			 case H1: case H2: case H3: case H4: case H5: case H6: reflowTillNow();
			 result.append(escape(CODE_RESET)) .append(""\n"");
			 reflownTo = result.length();
			 break;
			 case TABLE: if (cellsStack.size() >= tableStack.size()) {
				 handleEndElement(task.getElements().getName(""tr""));
			 }
			 if (tableStack.isEmpty()) {
				 break;
			 }
			 limit = tableStack.pop();
			 break;
			 case TR: if (cellsStack.isEmpty()) {
				 break;
			 }
			 reflowTillNow();
			 List<Integer> cells = cellsStack.pop();
			 List<Boolean> headerFlags = headerStack.pop();
			 List<String[]> content = new ArrayList<>();
			 int maxLines = 0;
			 result.append(""\n"");
			 while (!cells.isEmpty()) {
				 int currentCell = cells.remove(cells.size() - 1);
				 String[] lines = result.substring(currentCell, result.length()).split(""\n"");
				 result.delete(currentCell - 1, result.length());
				 content.add(lines);
				 maxLines = Math.max(maxLines, lines.length);
			 }
			 Collections.reverse(content);
			 for (int line = 0;
			 line < maxLines;
			 line++) {
				 for (int column = 0;
				 column < content.size();
				 column++) {
					 String[] lines = content.get(column);
					 String currentLine = line < lines.length ? lines[line] : """";
					 result.append(""| "");
					 boolean header = headerFlags.get(column);
					 if (header) {
						 result.append(escape(CODE_HIGHLIGHT));
					 }
					 result.append(currentLine);
					 if (header) {
						 result.append(escape(CODE_RESET));
					 }
					 int padding = limit - currentLine.length();
					 if (padding > 0) result.append(indentString(padding));
					 result.append("" "");
				 }
				 result.append(""|\n"");
			 }
			 for (int sep = 0;
			 sep < (limit + 3) * content.size() + 1;
			 sep++) {
				 result.append(""-"");
			 }
			 result.append(""\n"");
			 reflownTo = result.length();
			 break;
			 case TD: case TH: break;
			 default: addSpaceIfNeeded(result);
			 break;
		 }
	 }
	 public Object visitEntity(EntityTree node, Object p) {
		 String name = node.getName().toString();
		 int code = -1;
		 if (name.startsWith(""#"")) {
			 try {
				 int v = StringUtils.toLowerCase(name).startsWith(""#x"") ? Integer.parseInt(name.substring(2), 16) : Integer.parseInt(name.substring(1), 10);
				 if (Entity.isValid(v)) {
					 code = v;
				 }
			 }
			 catch (NumberFormatException ex) {
			 }
		 }
		 else {
			 Entity entity = Entity.get(name);
			 if (entity != null) {
				 code = entity.code;
			 }
		 }
		 if (code != (-1)) {
			 result.appendCodePoint(code);
		 }
		 else {
			 result.append(node.toString());
		 }
		 return super.visitEntity(node, p);
	 }
	 private DocTree lastNode;
	 public Object scan(DocTree node, Object p) {
		 if (node instanceof InlineTagTree) {
			 addSpaceIfNeeded(result);
		 }
		 try {
			 return super.scan(node, p);
		 }
		 finally {
			 if (node instanceof InlineTagTree) {
				 addSpaceIfNeeded(result);
			 }
			 lastNode = node;
		 }
	 }
	 private void reflowTillNow() {
		 while (result.length() > 0 && result.charAt(result.length() - 1) == ' ') result.delete(result.length() - 1, result.length());
		 reflow(result, reflownTo, indent, limit);
		 reflownTo = result.length();
	 }
 }
;
 private String escape(String sequence) {
	 return this.escapeSequencesSupported ? sequence : """";
 }
 private static final Map<Sections, String> docSections = new LinkedHashMap<>();
 static {
	 ResourceBundle bundle = ResourceBundle.getBundle(""jdk.internal.shellsupport.doc.resources.javadocformatter"");
	 docSections.put(Sections.TYPE_PARAMS, bundle.getString(""CAP_TypeParameters""));
	 docSections.put(Sections.PARAMS, bundle.getString(""CAP_Parameters""));
	 docSections.put(Sections.RETURNS, bundle.getString(""CAP_Returns""));
	 docSections.put(Sections.THROWS, bundle.getString(""CAP_Thrown_Exceptions""));
 }
 private static String indentString(int indent) {
	 char[] content = new char[indent];
	 Arrays.fill(content, ' ');
	 return new String(content);
 }
 private static void reflow(StringBuilder text, int from, int indent, int limit) {
	 int lineStart = from;
	 while (lineStart > 0 && text.charAt(lineStart - 1) != '\n') {
		 lineStart--;
	 }
	 int lineChars = from - lineStart;
	 int pointer = from;
	 int lastSpace = -1;
	 while (pointer < text.length()) {
		 if (text.charAt(pointer) == ' ') lastSpace = pointer;
		 if (lineChars >= limit) {
			 if (lastSpace != (-1)) {
				 text.setCharAt(lastSpace, '\n');
				 text.insert(lastSpace + 1, indentString(indent));
				 lineChars = indent + pointer - lastSpace - 1;
				 pointer += indent;
				 lastSpace = -1;
			 }
		 }
		 lineChars++;
		 pointer++;
	 }
 }
 private static void addNewLineIfNeeded(StringBuilder text) {
	 if (text.length() > 0 && text.charAt(text.length() - 1) != '\n') {
		 text.append(""\n"");
	 }
 }
 private static void addSpaceIfNeeded(StringBuilder text) {
	 if (text.length() == 0) return ;
	 char last = text.charAt(text.length() - 1);
	 if (last != ' ' && last != '\n') {
		 text.append("" "");
	 }
 }
 private static HtmlTag getHtmlTag(Name name) {
	 HtmlTag tag = HtmlTag.get(name);
	 return tag != null ? tag : HtmlTag.HTML;
 }
 private static Map<StartElementTree, Integer> countTableColumns(DocCommentTree dct) {
	 Map<StartElementTree, Integer> result = new IdentityHashMap<>();
	 new DocTreeScanner<Void, Void>() {
		 private StartElementTree currentTable;
		 private int currentMaxColumns;
		 private int currentRowColumns;
		 public Void visitStartElement(StartElementTree node, Void p) {
			 switch (getHtmlTag(node.getName())) {
				 case TABLE: currentTable = node;
				 break;
				 case TR: currentMaxColumns = Math.max(currentMaxColumns, currentRowColumns);
				 currentRowColumns = 0;
				 break;
				 case TD: case TH: currentRowColumns++;
				 break;
			 }
			 return super.visitStartElement(node, p);
		 }
		 public Void visitEndElement(EndElementTree node, Void p) {
			 if (HtmlTag.get(node.getName()) == HtmlTag.TABLE) {
				 closeTable();
			 }
			 return super.visitEndElement(node, p);
		 }
		 public Void visitDocComment(DocCommentTree node, Void p) {
			 try {
				 return super.visitDocComment(node, p);
			 }
			 finally {
				 closeTable();
			 }
		 }
		 private void closeTable() {
			 if (currentTable != null) {
				 result.put(currentTable, Math.max(currentMaxColumns, currentRowColumns));
				 currentTable = null;
			 }
		 }
	 }
	.scan(dct, null);
	 return result;
 }
 private enum Sections {
	 TYPE_PARAMS {
		 public boolean matches(DocTree t) {
			 return t.getKind() == DocTree.Kind.PARAM && ((ParamTree) t).isTypeParameter();
		 }
	 }
	, PARAMS {
		 public boolean matches(DocTree t) {
			 return t.getKind() == DocTree.Kind.PARAM && !((ParamTree) t).isTypeParameter();
		 }
	 }
	, RETURNS {
		 public boolean matches(DocTree t) {
			 return t.getKind() == DocTree.Kind.RETURN;
		 }
	 }
	, THROWS {
		 public boolean matches(DocTree t) {
			 return t.getKind() == DocTree.Kind.THROWS;
		 }
	 }
	;
	 public abstract boolean matches(DocTree t);
 }
}",1,0,0,0
"public class QueryParser implements QueryParserConstants {
	 private static final int CONJ_NONE = 0;
	 private static final int CONJ_AND = 1;
	 private static final int CONJ_OR = 2;
	 private static final int MOD_NONE = 0;
	 private static final int MOD_NOT = 10;
	 private static final int MOD_REQ = 11;
	 public static final int DEFAULT_OPERATOR_OR = 0;
	 public static final int DEFAULT_OPERATOR_AND = 1;
	 private int operator = DEFAULT_OPERATOR_OR;
	 boolean lowercaseWildcardTerms = true;
	 Analyzer analyzer;
	 String field;
	 int phraseSlop = 0;
	 Locale locale = Locale.getDefault();
	 static public Query parse(String query, String field, Analyzer analyzer) throws ParseException {
		 QueryParser parser = new QueryParser(field, analyzer);
		 return parser.parse(query);
	 }
	 public QueryParser(String f, Analyzer a) {
		 this(new FastCharStream(new StringReader("""")));
		 analyzer = a;
		 field = f;
	 }
	 public Query parse(String query) throws ParseException {
		 ReInit(new FastCharStream(new StringReader(query)));
		 try {
			 return Query(field);
		 }
		 catch (TokenMgrError tme) {
			 throw new ParseException(tme.getMessage());
		 }
		 catch (BooleanQuery.TooManyClauses tmc) {
			 throw new ParseException(""Too many boolean clauses"");
		 }
	 }
	 public void setPhraseSlop(int phraseSlop) {
		 this.phraseSlop = phraseSlop;
	 }
	 public int getPhraseSlop() {
		 return phraseSlop;
	 }
	 public void setOperator(int operator) {
		 this.operator = operator;
	 }
	 public int getOperator() {
		 return operator;
	 }
	 public void setLowercaseWildcardTerms(boolean lowercaseWildcardTerms) {
		 this.lowercaseWildcardTerms = lowercaseWildcardTerms;
	 }
	 public boolean getLowercaseWildcardTerms() {
		 return lowercaseWildcardTerms;
	 }
	 public void setLocale(Locale locale) {
		 this.locale = locale;
	 }
	 public Locale getLocale() {
		 return locale;
	 }
	 protected void addClause(Vector clauses, int conj, int mods, Query q) {
		 boolean required, prohibited;
		 if (conj == CONJ_AND) {
			 BooleanClause c = (BooleanClause) clauses.elementAt(clauses.size()-1);
			 if (!c.prohibited) c.required = true;
		 }
		 if (operator == DEFAULT_OPERATOR_AND && conj == CONJ_OR) {
			 BooleanClause c = (BooleanClause) clauses.elementAt(clauses.size()-1);
			 if (!c.prohibited) c.required = false;
		 }
		 if (q == null) return;
		 if (operator == DEFAULT_OPERATOR_OR) {
			 prohibited = (mods == MOD_NOT);
			 required = (mods == MOD_REQ);
			 if (conj == CONJ_AND && !prohibited) {
				 required = true;
			 }
		 }
		 else {
			 prohibited = (mods == MOD_NOT);
			 required = (!prohibited && conj != CONJ_OR);
		 }
		 clauses.addElement(new BooleanClause(q, required, prohibited));
	 }
	 protected Query getFieldQuery(String field, Analyzer analyzer, String queryText) throws ParseException {
		 TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));
		 Vector v = new Vector();
		 org.apache.lucene.analysis.Token t;
		 while (true) {
			 try {
				 t = source.next();
			 }
			 catch (IOException e) {
				 t = null;
			 }
			 if (t == null) break;
			 v.addElement(t.termText());
		 }
		 try {
			 source.close();
		 }
		 catch (IOException e) {
		 }
		 if (v.size() == 0) return null;
		 else if (v.size() == 1) return new TermQuery(new Term(field, (String) v.elementAt(0)));
		 else {
			 PhraseQuery q = new PhraseQuery();
			 q.setSlop(phraseSlop);
			 for (int i=0;
			 i<v.size();
			 i++) {
				 q.add(new Term(field, (String) v.elementAt(i)));
			 }
			 return q;
		 }
	 }
	 protected Query getFieldQuery(String field, Analyzer analyzer, String queryText, int slop) throws ParseException {
		 Query query = getFieldQuery(field, analyzer, queryText);
		 if (query instanceof PhraseQuery) {
			 ((PhraseQuery) query).setSlop(slop);
		 }
		 return query;
	 }
	 protected Query getRangeQuery(String field, Analyzer analyzer, String part1, String part2, boolean inclusive) throws ParseException {
		 try {
			 DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, locale);
			 df.setLenient(true);
			 Date d1 = df.parse(part1);
			 Date d2 = df.parse(part2);
			 part1 = DateField.dateToString(d1);
			 part2 = DateField.dateToString(d2);
		 }
		 catch (Exception e) {
		 }
		 return new RangeQuery(new Term(field, part1), new Term(field, part2), inclusive);
	 }
	 protected Query getBooleanQuery(Vector clauses) throws ParseException {
		 BooleanQuery query = new BooleanQuery();
		 for (int i = 0;
		 i < clauses.size();
		 i++) {
			 query.add((BooleanClause)clauses.elementAt(i));
		 }
		 return query;
	 }
	 protected Query getWildcardQuery(String field, String termStr) throws ParseException {
		 if (lowercaseWildcardTerms) {
			 termStr = termStr.toLowerCase();
		 }
		 Term t = new Term(field, termStr);
		 return new WildcardQuery(t);
	 }
	 protected Query getPrefixQuery(String field, String termStr) throws ParseException {
		 if (lowercaseWildcardTerms) {
			 termStr = termStr.toLowerCase();
		 }
		 Term t = new Term(field, termStr);
		 return new PrefixQuery(t);
	 }
	 protected Query getFuzzyQuery(String field, String termStr) throws ParseException {
		 Term t = new Term(field, termStr);
		 return new FuzzyQuery(t);
	 }
	 private String discardEscapeChar(String input) {
		 char[] caSource = input.toCharArray();
		 char[] caDest = new char[caSource.length];
		 int j = 0;
		 for (int i = 0;
		 i < caSource.length;
		 i++) {
			 if ((caSource[i] != '\\') || (i > 0 && caSource[i-1] == '\\')) {
				 caDest[j++]=caSource[i];
			 }
		 }
		 return new String(caDest, 0, j);
	 }
	 public static void main(String[] args) throws Exception {
		 QueryParser qp = new QueryParser(""field"", new org.apache.lucene.analysis.SimpleAnalyzer());
		 Query q = qp.parse(args[0]);
		 System.out.println(q.toString(""field""));
	 }
	 final public int Conjunction() throws ParseException {
		 int ret = CONJ_NONE;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case AND: case OR: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AND: jj_consume_token(AND);
				 ret = CONJ_AND;
				 break;
				 case OR: jj_consume_token(OR);
				 ret = CONJ_OR;
				 break;
				 default: jj_la1[0] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 break;
			 default: jj_la1[1] = jj_gen;
			 ;
		 }
		 {
			if (true) return ret;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public int Modifiers() throws ParseException {
		 int ret = MOD_NONE;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case NOT: case PLUS: case MINUS: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PLUS: jj_consume_token(PLUS);
				 ret = MOD_REQ;
				 break;
				 case MINUS: jj_consume_token(MINUS);
				 ret = MOD_NOT;
				 break;
				 case NOT: jj_consume_token(NOT);
				 ret = MOD_NOT;
				 break;
				 default: jj_la1[2] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 break;
			 default: jj_la1[3] = jj_gen;
			 ;
		 }
		 {
			if (true) return ret;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Query Query(String field) throws ParseException {
		 Vector clauses = new Vector();
		 Query q, firstQuery=null;
		 int conj, mods;
		 mods = Modifiers();
		 q = Clause(field);
		 addClause(clauses, CONJ_NONE, mods, q);
		 if (mods == MOD_NONE) firstQuery=q;
		 label_1: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AND: case OR: case NOT: case PLUS: case MINUS: case LPAREN: case QUOTED: case TERM: case PREFIXTERM: case WILDTERM: case RANGEIN_START: case RANGEEX_START: case NUMBER: ;
				 break;
				 default: jj_la1[4] = jj_gen;
				 break label_1;
			 }
			 conj = Conjunction();
			 mods = Modifiers();
			 q = Clause(field);
			 addClause(clauses, conj, mods, q);
		 }
		 if (clauses.size() == 1 && firstQuery != null) {
			if (true) return firstQuery;
		}
		 else {
			 {
				if (true) return getBooleanQuery(clauses);
			}
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Query Clause(String field) throws ParseException {
		 Query q;
		 Token fieldToken=null, boost=null;
		 if (jj_2_1(2)) {
			 fieldToken = jj_consume_token(TERM);
			 jj_consume_token(COLON);
			 field=discardEscapeChar(fieldToken.image);
		 }
		 else {
			 ;
		 }
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case QUOTED: case TERM: case PREFIXTERM: case WILDTERM: case RANGEIN_START: case RANGEEX_START: case NUMBER: q = Term(field);
			 break;
			 case LPAREN: jj_consume_token(LPAREN);
			 q = Query(field);
			 jj_consume_token(RPAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CARAT: jj_consume_token(CARAT);
				 boost = jj_consume_token(NUMBER);
				 break;
				 default: jj_la1[5] = jj_gen;
				 ;
			 }
			 break;
			 default: jj_la1[6] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
		 if (boost != null) {
			 float f = (float)1.0;
			 try {
				 f = Float.valueOf(boost.image).floatValue();
				 q.setBoost(f);
			 }
			 catch (Exception ignored) {
			 }
		 }
		 {
			if (true) return q;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Query Term(String field) throws ParseException {
		 Token term, boost=null, slop=null, goop1, goop2;
		 boolean prefix = false;
		 boolean wildcard = false;
		 boolean fuzzy = false;
		 boolean rangein = false;
		 Query q;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case TERM: case PREFIXTERM: case WILDTERM: case NUMBER: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case TERM: term = jj_consume_token(TERM);
				 break;
				 case PREFIXTERM: term = jj_consume_token(PREFIXTERM);
				 prefix=true;
				 break;
				 case WILDTERM: term = jj_consume_token(WILDTERM);
				 wildcard=true;
				 break;
				 case NUMBER: term = jj_consume_token(NUMBER);
				 break;
				 default: jj_la1[7] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case FUZZY: jj_consume_token(FUZZY);
				 fuzzy=true;
				 break;
				 default: jj_la1[8] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CARAT: jj_consume_token(CARAT);
				 boost = jj_consume_token(NUMBER);
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case FUZZY: jj_consume_token(FUZZY);
					 fuzzy=true;
					 break;
					 default: jj_la1[9] = jj_gen;
					 ;
				 }
				 break;
				 default: jj_la1[10] = jj_gen;
				 ;
			 }
			 String termImage=discardEscapeChar(term.image);
			 if (wildcard) {
				 q = getWildcardQuery(field, termImage);
			 }
			 else if (prefix) {
				 q = getPrefixQuery(field, discardEscapeChar(term.image.substring (0, term.image.length()-1)));
			 }
			 else if (fuzzy) {
				 q = getFuzzyQuery(field, termImage);
			 }
			 else {
				 q = getFieldQuery(field, analyzer, termImage);
			 }
			 break;
			 case RANGEIN_START: jj_consume_token(RANGEIN_START);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case RANGEIN_GOOP: goop1 = jj_consume_token(RANGEIN_GOOP);
				 break;
				 case RANGEIN_QUOTED: goop1 = jj_consume_token(RANGEIN_QUOTED);
				 break;
				 default: jj_la1[11] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case RANGEIN_TO: jj_consume_token(RANGEIN_TO);
				 break;
				 default: jj_la1[12] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case RANGEIN_GOOP: goop2 = jj_consume_token(RANGEIN_GOOP);
				 break;
				 case RANGEIN_QUOTED: goop2 = jj_consume_token(RANGEIN_QUOTED);
				 break;
				 default: jj_la1[13] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(RANGEIN_END);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CARAT: jj_consume_token(CARAT);
				 boost = jj_consume_token(NUMBER);
				 break;
				 default: jj_la1[14] = jj_gen;
				 ;
			 }
			 if (goop1.kind == RANGEIN_QUOTED) {
				 goop1.image = goop1.image.substring(1, goop1.image.length()-1);
			 }
			 else {
				 goop1.image = discardEscapeChar(goop1.image);
			 }
			 if (goop2.kind == RANGEIN_QUOTED) {
				 goop2.image = goop2.image.substring(1, goop2.image.length()-1);
			 }
			 else {
				 goop2.image = discardEscapeChar(goop2.image);
			 }
			 q = getRangeQuery(field, analyzer, goop1.image, goop2.image, true);
			 break;
			 case RANGEEX_START: jj_consume_token(RANGEEX_START);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case RANGEEX_GOOP: goop1 = jj_consume_token(RANGEEX_GOOP);
				 break;
				 case RANGEEX_QUOTED: goop1 = jj_consume_token(RANGEEX_QUOTED);
				 break;
				 default: jj_la1[15] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case RANGEEX_TO: jj_consume_token(RANGEEX_TO);
				 break;
				 default: jj_la1[16] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case RANGEEX_GOOP: goop2 = jj_consume_token(RANGEEX_GOOP);
				 break;
				 case RANGEEX_QUOTED: goop2 = jj_consume_token(RANGEEX_QUOTED);
				 break;
				 default: jj_la1[17] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 jj_consume_token(RANGEEX_END);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CARAT: jj_consume_token(CARAT);
				 boost = jj_consume_token(NUMBER);
				 break;
				 default: jj_la1[18] = jj_gen;
				 ;
			 }
			 if (goop1.kind == RANGEEX_QUOTED) {
				 goop1.image = goop1.image.substring(1, goop1.image.length()-1);
			 }
			 else {
				 goop1.image = discardEscapeChar(goop1.image);
			 }
			 if (goop2.kind == RANGEEX_QUOTED) {
				 goop2.image = goop2.image.substring(1, goop2.image.length()-1);
			 }
			 else {
				 goop2.image = discardEscapeChar(goop2.image);
			 }
			 q = getRangeQuery(field, analyzer, goop1.image, goop2.image, false);
			 break;
			 case QUOTED: term = jj_consume_token(QUOTED);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case SLOP: slop = jj_consume_token(SLOP);
				 break;
				 default: jj_la1[19] = jj_gen;
				 ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CARAT: jj_consume_token(CARAT);
				 boost = jj_consume_token(NUMBER);
				 break;
				 default: jj_la1[20] = jj_gen;
				 ;
			 }
			 int s = phraseSlop;
			 if (slop != null) {
				 try {
					 s = Float.valueOf(slop.image.substring(1)).intValue();
				 }
				 catch (Exception ignored) {
				 }
			 }
			 q = getFieldQuery(field, analyzer, term.image.substring(1, term.image.length()-1), s);
			 break;
			 default: jj_la1[21] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
		 if (boost != null) {
			 float f = (float) 1.0;
			 try {
				 f = Float.valueOf(boost.image).floatValue();
			 }
			 catch (Exception ignored) {
			 }
			 if (q != null) {
				 q.setBoost(f);
			 }
		 }
		 {
			if (true) return q;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final private boolean jj_2_1(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_1();
		 }
		 catch(LookaheadSuccess ls) {
			 return true;
		 }
		 finally {
			 jj_save(0, xla);
		 }
	 }
	 final private boolean jj_3_1() {
		 if (jj_scan_token(TERM)) return true;
		 if (jj_scan_token(COLON)) return true;
		 return false;
	 }
	 public QueryParserTokenManager token_source;
	 public Token token, jj_nt;
	 private int jj_ntk;
	 private Token jj_scanpos, jj_lastpos;
	 private int jj_la;
	 public boolean lookingAhead = false;
	 private boolean jj_semLA;
	 private int jj_gen;
	 final private int[] jj_la1 = new int[22];
	 static private int[] jj_la1_0;
	 static private int[] jj_la1_1;
	 static {
		 jj_la1_0();
		 jj_la1_1();
	 }
	 private static void jj_la1_0() {
		 jj_la1_0 = new int[] {
		0x180,0x180,0xe00,0xe00,0x1f31f80,0x8000,0x1f31000,0x1320000,0x40000,0x40000,0x8000,0x18000000,0x2000000,0x18000000,0x8000,0x80000000,0x20000000,0x80000000,0x8000,0x80000,0x8000,0x1f30000,}
		;
	 }
	 private static void jj_la1_1() {
		 jj_la1_1 = new int[] {
		0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,}
		;
	 }
	 final private JJCalls[] jj_2_rtns = new JJCalls[1];
	 private boolean jj_rescan = false;
	 private int jj_gc = 0;
	 public QueryParser(CharStream stream) {
		 token_source = new QueryParserTokenManager(stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 22;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public void ReInit(CharStream stream) {
		 token_source.ReInit(stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 22;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public QueryParser(QueryParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 22;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public void ReInit(QueryParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 22;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 final private Token jj_consume_token(int kind) throws ParseException {
		 Token oldToken;
		 if ((oldToken = token).next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 if (token.kind == kind) {
			 jj_gen++;
			 if (++jj_gc > 100) {
				 jj_gc = 0;
				 for (int i = 0;
				 i < jj_2_rtns.length;
				 i++) {
					 JJCalls c = jj_2_rtns[i];
					 while (c != null) {
						 if (c.gen < jj_gen) c.first = null;
						 c = c.next;
					 }
				 }
			 }
			 return token;
		 }
		 token = oldToken;
		 jj_kind = kind;
		 throw generateParseException();
	 }
	 static private final class LookaheadSuccess extends java.lang.Error {
	 }
	 final private LookaheadSuccess jj_ls = new LookaheadSuccess();
	 final private boolean jj_scan_token(int kind) {
		 if (jj_scanpos == jj_lastpos) {
			 jj_la--;
			 if (jj_scanpos.next == null) {
				 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			 }
			 else {
				 jj_lastpos = jj_scanpos = jj_scanpos.next;
			 }
		 }
		 else {
			 jj_scanpos = jj_scanpos.next;
		 }
		 if (jj_rescan) {
			 int i = 0;
			 Token tok = token;
			 while (tok != null && tok != jj_scanpos) {
				 i++;
				 tok = tok.next;
			 }
			 if (tok != null) jj_add_error_token(kind, i);
		 }
		 if (jj_scanpos.kind != kind) return true;
		 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
		 return false;
	 }
	 final public Token getNextToken() {
		 if (token.next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 jj_gen++;
		 return token;
	 }
	 final public Token getToken(int index) {
		 Token t = lookingAhead ? jj_scanpos : token;
		 for (int i = 0;
		 i < index;
		 i++) {
			 if (t.next != null) t = t.next;
			 else t = t.next = token_source.getNextToken();
		 }
		 return t;
	 }
	 final private int jj_ntk() {
		 if ((jj_nt=token.next) == null) return (jj_ntk = (token.next=token_source.getNextToken()).kind);
		 else return (jj_ntk = jj_nt.kind);
	 }
	 private java.util.Vector jj_expentries = new java.util.Vector();
	 private int[] jj_expentry;
	 private int jj_kind = -1;
	 private int[] jj_lasttokens = new int[100];
	 private int jj_endpos;
	 private void jj_add_error_token(int kind, int pos) {
		 if (pos >= 100) return;
		 if (pos == jj_endpos + 1) {
			 jj_lasttokens[jj_endpos++] = kind;
		 }
		 else if (jj_endpos != 0) {
			 jj_expentry = new int[jj_endpos];
			 for (int i = 0;
			 i < jj_endpos;
			 i++) {
				 jj_expentry[i] = jj_lasttokens[i];
			 }
			 boolean exists = false;
			 for (java.util.Enumeration e = jj_expentries.elements();
			 e.hasMoreElements();
			) {
				 int[] oldentry = (int[])(e.nextElement());
				 if (oldentry.length == jj_expentry.length) {
					 exists = true;
					 for (int i = 0;
					 i < jj_expentry.length;
					 i++) {
						 if (oldentry[i] != jj_expentry[i]) {
							 exists = false;
							 break;
						 }
					 }
					 if (exists) break;
				 }
			 }
			 if (!exists) jj_expentries.addElement(jj_expentry);
			 if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		 }
	 }
	 public ParseException generateParseException() {
		 jj_expentries.removeAllElements();
		 boolean[] la1tokens = new boolean[33];
		 for (int i = 0;
		 i < 33;
		 i++) {
			 la1tokens[i] = false;
		 }
		 if (jj_kind >= 0) {
			 la1tokens[jj_kind] = true;
			 jj_kind = -1;
		 }
		 for (int i = 0;
		 i < 22;
		 i++) {
			 if (jj_la1[i] == jj_gen) {
				 for (int j = 0;
				 j < 32;
				 j++) {
					 if ((jj_la1_0[i] & (1<<j)) != 0) {
						 la1tokens[j] = true;
					 }
					 if ((jj_la1_1[i] & (1<<j)) != 0) {
						 la1tokens[32+j] = true;
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < 33;
		 i++) {
			 if (la1tokens[i]) {
				 jj_expentry = new int[1];
				 jj_expentry[0] = i;
				 jj_expentries.addElement(jj_expentry);
			 }
		 }
		 jj_endpos = 0;
		 jj_rescan_token();
		 jj_add_error_token(0, 0);
		 int[][] exptokseq = new int[jj_expentries.size()][];
		 for (int i = 0;
		 i < jj_expentries.size();
		 i++) {
			 exptokseq[i] = (int[])jj_expentries.elementAt(i);
		 }
		 return new ParseException(token, exptokseq, tokenImage);
	 }
	 final public void enable_tracing() {
	 }
	 final public void disable_tracing() {
	 }
	 final private void jj_rescan_token() {
		 jj_rescan = true;
		 for (int i = 0;
		 i < 1;
		 i++) {
			 JJCalls p = jj_2_rtns[i];
			 do {
				 if (p.gen > jj_gen) {
					 jj_la = p.arg;
					 jj_lastpos = jj_scanpos = p.first;
					 switch (i) {
						 case 0: jj_3_1();
						 break;
					 }
				 }
				 p = p.next;
			 }
			 while (p != null);
		 }
		 jj_rescan = false;
	 }
	 final private void jj_save(int index, int xla) {
		 JJCalls p = jj_2_rtns[index];
		 while (p.gen > jj_gen) {
			 if (p.next == null) {
				 p = p.next = new JJCalls();
				 break;
			 }
			 p = p.next;
		 }
		 p.gen = jj_gen + xla - jj_la;
		 p.first = token;
		 p.arg = xla;
	 }
	 static final class JJCalls {
		 int gen;
		 Token first;
		 int arg;
		 JJCalls next;
	 }
}",1,0,0,0
"private void verifyRepository(RepositoryRequest request) throws AmbariException {
	 URLStreamProvider usp = new URLStreamProvider(REPO_URL_CONNECT_TIMEOUT, REPO_URL_READ_TIMEOUT, null, null, null);
	 usp.setSetupTruststoreForHttps(false);
	 String repoName = request.getRepoName();
	 if (StringUtils.isEmpty(repoName)) {
		 throw new IllegalArgumentException(""repo_name is required to verify repository"");
	 }
	 String errorMessage = null;
	 Exception e = null;
	 String[] suffixes = configs.getRepoValidationSuffixes(request.getOsType());
	 for (String suffix : suffixes) {
		 String formatted_suffix = String.format(suffix, repoName);
		 String spec = request.getBaseUrl().trim();
		 if (spec.charAt(spec.length() - 1) != '/' && formatted_suffix.charAt(0) != '/') {
			 spec = spec + ""/"" + formatted_suffix;
		 }
		 else if (spec.charAt(spec.length() - 1) == '/' && formatted_suffix.charAt(0) == '/') {
			 spec = spec + formatted_suffix.substring(1);
		 }
		 else {
			 spec = spec + formatted_suffix;
		 }
		 final String FILE_SCHEME = ""file: if(spec.toLowerCase().startsWith(FILE_SCHEME)){
			 String filePath = spec.substring(FILE_SCHEME.length());
			 File f = new File(filePath);
			 if(!f.exists()){
				 errorMessage = ""Could not access base url . "" + spec + "" . "";
				 e = new FileNotFoundException(errorMessage);
				 break;
			 }
		 }
		else{
			 try {
				 IOUtils.readLines(usp.readFrom(spec));
			 }
			 catch (IOException ioe) {
				 e = ioe;
				 errorMessage = ""Could not access base url . "" + request.getBaseUrl() + "" . "";
				 if (LOG.isDebugEnabled()) {
					 errorMessage += ioe;
				 }
				 else {
					 errorMessage += ioe.getMessage();
				 }
				 break;
			 }
		 }
	 }
	 if (e != null) {
		 LOG.error(errorMessage);
		 throw new IllegalArgumentException(errorMessage, e);
	 }
 }",0,0,1,0
"public final class CConstantValueSupportImpl implements CConstantValueSupport {
	 private final NativeLibraries nativeLibraries;
	 private final MetaAccessProvider metaAccess;
	 public CConstantValueSupportImpl(NativeLibraries nativeLibraries, MetaAccessProvider metaAccess) {
		 this.nativeLibraries = nativeLibraries;
		 this.metaAccess = metaAccess;
	 }
	 public <T> T getCConstantValue(Class<?> declaringClass, String methodName, Class<T> returnType) {
		 ResolvedJavaMethod method;
		 try {
			 method = metaAccess.lookupJavaMethod(declaringClass.getMethod(methodName));
		 }
		 catch (NoSuchMethodException | SecurityException e) {
			 throw VMError.shouldNotReachHere(""Method not found: "" + declaringClass.getName() + ""."" + methodName);
		 }
		 if (method.getAnnotation(CConstant.class) == null) {
			 throw VMError.shouldNotReachHere(""Method "" + declaringClass.getName() + ""."" + methodName + "" is not annotated with @"" + CConstant.class.getSimpleName());
		 }
		 ConstantInfo constantInfo = (ConstantInfo) nativeLibraries.findElementInfo(method);
		 Object value = constantInfo.getValueInfo().getProperty();
		 switch (constantInfo.getKind()) {
			 case INTEGER: case POINTER: Long longValue = (Long) value;
			 if (returnType == Boolean.class) {
				 return returnType.cast(Boolean.valueOf(longValue.longValue() != 0));
			 }
			 else if (returnType == Integer.class) {
				 return returnType.cast(Integer.valueOf((int) longValue.longValue()));
			 }
			 else if (returnType == Long.class) {
				 return returnType.cast(value);
			 }
			 break;
			 case FLOAT: if (returnType == Double.class) {
				 return returnType.cast(value);
			 }
			 break;
			 case STRING: if (returnType == String.class) {
				 return returnType.cast(value);
			 }
			 break;
			 case BYTEARRAY: if (returnType == byte[].class) {
				 return returnType.cast(value);
			 }
			 break;
		 }
		 throw VMError.shouldNotReachHere(""Unexpected returnType: "" + returnType.getName());
	 }
}",1,0,0,0
"public void crawl(File dirRoot) {
	 LOG.info(String.format(""Start crawling dir: %s"", dirRoot));
	 ingestStatus.clear();
	 loadAndValidateActions();
	 setupIngester();
	 if (dirRoot == null || !dirRoot.exists()) {
		 throw new IllegalArgumentException(""dir root is null or non existant!"");
	 }
	 Stack<File> stack = new Stack<File>();
	 stack.push(dirRoot.isDirectory() ? dirRoot : dirRoot.getParentFile());
	 while (!stack.isEmpty()) {
		 File dir = (File) stack.pop();
		 LOG.log(Level.INFO, ""Crawling "" + dir);
		 File[] productFiles;
		 productFiles = isCrawlForDirs() ? dir.listFiles(DIR_FILTER) : dir.listFiles(FILE_FILTER);
		 if(productFiles!=null) {
			 for (File productFile : productFiles) {
				 ingestStatus.add(handleFile(productFile));
			 }
		 }
		 if (!isNoRecur()) {
			 File[] subdirs = dir.listFiles(DIR_FILTER);
			 if (subdirs != null) {
				 for (File subdir : subdirs) {
					 stack.push(subdir);
				 }
			 }
		 }
	 }
	 LOG.info(String.format(""Finished crawling dir: %s"", dirRoot));
 }",0,0,1,0
"public final EObject entryRuleXMultiplicativeExpression() throws RecognitionException {
	 EObject current = null;
	 EObject iv_ruleXMultiplicativeExpression = null;
	 try {
		 {
			 if ( state.backtracking==0 ) {
				 newCompositeNode(grammarAccess.getXMultiplicativeExpressionRule());
			 }
			 pushFollow(FOLLOW_1);
			 iv_ruleXMultiplicativeExpression=ruleXMultiplicativeExpression();
			 state._fsp--;
			 if (state.failed) return current;
			 if ( state.backtracking==0 ) {
				 current =iv_ruleXMultiplicativeExpression;
			 }
			 match(input,EOF,FOLLOW_2);
			 if (state.failed) return current;
		 }
	 }
	 catch (RecognitionException re) {
		 recover(input,re);
		 appendSkippedTokens();
	 }
	 finally {
	 }
	 return current;
 }",0,0,1,0
"public static class RowRange {
	 private Text startRow;
	 private Text endRow;
	 public RowRange(KeyExtent ke) {
		 this.startRow = ke.getPrevEndRow();
		 this.endRow = ke.getEndRow();
	 }
	 public RowRange(TRowRange trr) {
		 this.startRow = ByteBufferUtil.toText(trr.startRow);
		 this.endRow = ByteBufferUtil.toText(trr.endRow);
	 }
	 public RowRange(Text startRow, Text endRow) {
		 this.startRow = startRow;
		 this.endRow = endRow;
	 }
	 public Range toRange() {
		 return new Range(startRow, false, endRow, true);
	 }
	 public TRowRange toThrift() {
		 return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));
	 }
	 public Text getStartRow() {
		 return startRow;
	 }
	 public Text getEndRow() {
		 return endRow;
	 }
	 public String toString() {
		 return startRow + "" "" + endRow;
	 }
 }",0,1,0,0
"public abstract class BaseTest {
	 protected boolean haltOnError = false;
	 protected boolean haltOnFail = false;
	 protected boolean filtertrace = true;
	 protected boolean fork = false;
	 protected String ifProperty = null;
	 protected String unlessProperty = null;
	 protected Vector formatters = new Vector();
	 protected File destDir = null;
	 protected String failureProperty;
	 protected String errorProperty;
	 public void setFiltertrace(boolean value) {
		 filtertrace = value;
	 }
	 public boolean getFiltertrace() {
		 return filtertrace;
	 }
	 public void setFork(boolean value) {
		 fork = value;
	 }
	 public boolean getFork() {
		 return fork;
	 }
	 public void setHaltonerror(boolean value) {
		 haltOnError = value;
	 }
	 public void setHaltonfailure(boolean value) {
		 haltOnFail = value;
	 }
	 public boolean getHaltonerror() {
		 return haltOnError;
	 }
	 public boolean getHaltonfailure() {
		 return haltOnFail;
	 }
	 public void setIf(String propertyName) {
		 ifProperty = propertyName;
	 }
	 public void setUnless(String propertyName) {
		 unlessProperty = propertyName;
	 }
	 public void addFormatter(FormatterElement elem) {
		 formatters.addElement(elem);
	 }
	 public void setTodir(File destDir) {
		 this.destDir = destDir;
	 }
	 public String getTodir() {
		 if (destDir != null) {
			 return destDir.getAbsolutePath();
		 }
		 return null;
	 }
	 public String getFailureProperty() {
		 return failureProperty;
	 }
	 public void setFailureProperty(String failureProperty) {
		 this.failureProperty = failureProperty;
	 }
	 public String getErrorProperty() {
		 return errorProperty;
	 }
	 public void setErrorProperty(String errorProperty) {
		 this.errorProperty = errorProperty;
	 }
}",0,0,0,0
"protected ItemResult createOrUpdateContact(String folderPath, String itemName, String itemBody, String etag, String noneMatch) throws IOException {
	 Map<String, String> properties = new HashMap<String, String>();
	 properties.put(""outlookmessageclass"", ""IPM.Contact"");
	 VObject vcard = new VObject(new ICSBufferedReader(new StringReader(itemBody)));
	 for (VProperty property : vcard.getProperties()) {
		 if (""FN"".equals(property.getKey())) {
			 properties.put(""cn"", property.getValue());
			 properties.put(""subject"", property.getValue());
			 properties.put(""fileas"", property.getValue());
		 }
		 else if (""N"".equals(property.getKey())) {
			 convertContactProperties(properties, VCARD_N_PROPERTIES, property.getValues());
		 }
		 else if (""NICKNAME"".equals(property.getKey())) {
			 properties.put(""nickname"", property.getValue());
		 }
		 else if (""TEL"".equals(property.getKey())) {
			 if (property.hasParam(""TYPE"", ""cell"") || property.hasParam(""X-GROUP"", ""cell"")) {
				 properties.put(""mobile"", property.getValue());
			 }
			 else if (property.hasParam(""TYPE"", ""work"") || property.hasParam(""X-GROUP"", ""work"")) {
				 properties.put(""telephoneNumber"", property.getValue());
			 }
			 else if (property.hasParam(""TYPE"", ""home"") || property.hasParam(""X-GROUP"", ""home"")) {
				 properties.put(""homePhone"", property.getValue());
			 }
			 else if (property.hasParam(""TYPE"", ""fax"")) {
				 if (property.hasParam(""TYPE"", ""home"")) {
					 properties.put(""homefax"", property.getValue());
				 }
				 else {
					 properties.put(""facsimiletelephonenumber"", property.getValue());
				 }
			 }
			 else if (property.hasParam(""TYPE"", ""pager"")) {
				 properties.put(""pager"", property.getValue());
			 }
			 else if (property.hasParam(""TYPE"", ""car"")) {
				 properties.put(""othermobile"", property.getValue());
			 }
			 else {
				 properties.put(""otherTelephone"", property.getValue());
			 }
		 }
		 else if (""ADR"".equals(property.getKey())) {
			 if (property.hasParam(""TYPE"", ""home"")) {
				 convertContactProperties(properties, VCARD_ADR_HOME_PROPERTIES, property.getValues());
			 }
			 else if (property.hasParam(""TYPE"", ""work"")) {
				 convertContactProperties(properties, VCARD_ADR_WORK_PROPERTIES, property.getValues());
			 }
			 else {
				 convertContactProperties(properties, VCARD_ADR_OTHER_PROPERTIES, property.getValues());
			 }
		 }
		 else if (""EMAIL"".equals(property.getKey())) {
			 if (property.hasParam(""TYPE"", ""home"")) {
				 properties.put(""email2"", property.getValue());
				 properties.put(""smtpemail2"", property.getValue());
			 }
			 else if (property.hasParam(""TYPE"", ""other"")) {
				 properties.put(""email3"", property.getValue());
				 properties.put(""smtpemail3"", property.getValue());
			 }
			 else {
				 properties.put(""email1"", property.getValue());
				 properties.put(""smtpemail1"", property.getValue());
			 }
		 }
		 else if (""ORG"".equals(property.getKey())) {
			 convertContactProperties(properties, VCARD_ORG_PROPERTIES, property.getValues());
		 }
		 else if (""URL"".equals(property.getKey())) {
			 if (property.hasParam(""TYPE"", ""work"")) {
				 properties.put(""businesshomepage"", property.getValue());
			 }
			 else if (property.hasParam(""TYPE"", ""home"")) {
				 properties.put(""personalHomePage"", property.getValue());
			 }
			 else {
				 properties.put(""personalHomePage"", property.getValue());
			 }
		 }
		 else if (""TITLE"".equals(property.getKey())) {
			 properties.put(""title"", property.getValue());
		 }
		 else if (""NOTE"".equals(property.getKey())) {
			 properties.put(""description"", property.getValue());
		 }
		 else if (""CUSTOM1"".equals(property.getKey())) {
			 properties.put(""extensionattribute1"", property.getValue());
		 }
		 else if (""CUSTOM2"".equals(property.getKey())) {
			 properties.put(""extensionattribute2"", property.getValue());
		 }
		 else if (""CUSTOM3"".equals(property.getKey())) {
			 properties.put(""extensionattribute3"", property.getValue());
		 }
		 else if (""CUSTOM4"".equals(property.getKey())) {
			 properties.put(""extensionattribute4"", property.getValue());
		 }
		 else if (""ROLE"".equals(property.getKey())) {
			 properties.put(""profession"", property.getValue());
		 }
		 else if (""X-AIM"".equals(property.getKey())) {
			 properties.put(""im"", property.getValue());
		 }
		 else if (""BDAY"".equals(property.getKey())) {
			 properties.put(""bday"", convertBDayToZulu(property.getValue()));
		 }
		 else if (""ANNIVERSARY"".equals(property.getKey()) || ""X-ANNIVERSARY"".equals(property.getKey())) {
			 properties.put(""anniversary"", convertBDayToZulu(property.getValue()));
		 }
		 else if (""CATEGORIES"".equals(property.getKey())) {
			 properties.put(""keywords"", property.getValue());
		 }
		 else if (""CLASS"".equals(property.getKey())) {
			 if (""PUBLIC"".equals(property.getValue())) {
				 properties.put(""sensitivity"", ""0"");
				 properties.put(""private"", ""false"");
			 }
			 else {
				 properties.put(""sensitivity"", ""2"");
				 properties.put(""private"", ""true"");
			 }
		 }
		 else if (""SEX"".equals(property.getKey())) {
			 String propertyValue = property.getValue();
			 if (""1"".equals(propertyValue)) {
				 properties.put(""gender"", ""2"");
			 }
			 else if (""2"".equals(propertyValue)) {
				 properties.put(""gender"", ""1"");
			 }
		 }
		 else if (""FBURL"".equals(property.getKey())) {
			 properties.put(""fburl"", property.getValue());
		 }
		 else if (""X-ASSISTANT"".equals(property.getKey())) {
			 properties.put(""secretarycn"", property.getValue());
		 }
		 else if (""X-MANAGER"".equals(property.getKey())) {
			 properties.put(""manager"", property.getValue());
		 }
		 else if (""X-SPOUSE"".equals(property.getKey())) {
			 properties.put(""spousecn"", property.getValue());
		 }
		 else if (""PHOTO"".equals(property.getKey())) {
			 properties.put(""photo"", property.getValue());
			 properties.put(""haspicture"", ""true"");
		 }
	 }
	 LOGGER.debug(""Create or update contact "" + itemName + "": "" + properties);
	 for (String key : CONTACT_ATTRIBUTES) {
		 if (!""imapUid"".equals(key) && !""etag"".equals(key) && !""urlcompname"".equals(key) && !""lastmodified"".equals(key) && !""sensitivity"".equals(key) && !properties.containsKey(key)) {
			 properties.put(key, null);
		 }
	 }
	 return internalCreateOrUpdateContact(folderPath, itemName, properties, etag, noneMatch);
 }",0,0,1,0
"public class CreateWeblogBean {
	 private String handle;
	 private String name;
	 private String description;
	 private String emailAddress;
	 private String locale;
	 private String timeZone;
	 private String theme;
	 public String getDescription() {
		 return description;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getEmailAddress() {
		 return emailAddress;
	 }
	 public void setEmailAddress(String emailAddress) {
		 this.emailAddress = emailAddress;
	 }
	 public String getHandle() {
		 return handle;
	 }
	 public void setHandle(String handle) {
		 this.handle = handle;
	 }
	 public String getLocale() {
		 return locale;
	 }
	 public void setLocale(String locale) {
		 this.locale = locale;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getTheme() {
		 return theme;
	 }
	 public void setTheme(String theme) {
		 this.theme = theme;
	 }
	 public String getTimeZone() {
		 return timeZone;
	 }
	 public void setTimeZone(String timeZone) {
		 this.timeZone = timeZone;
	 }
}",0,1,0,0
"public synchronized Object[] pendingTransfers(DatanodeID srcNode, int xmitsInProgress) {
	 if( isInSafeMode() ) return null;
	 synchronized (neededReplications) {
		 Object results[] = null;
		 int scheduledXfers = 0;
		 if (neededReplications.size() > 0) {
			 Vector replicateBlocks = new Vector();
			 Vector replicateTargetSets = new Vector();
			 for (Iterator it = neededReplications.iterator();
			 it.hasNext();
			) {
				 if (scheduledXfers >= this.maxReplicationStreams - xmitsInProgress) {
					 break;
				 }
				 Block block = (Block) it.next();
				 long blockSize = block.getNumBytes();
				 FSDirectory.INode fileINode = dir.getFileByBlock(block);
				 if (fileINode == null) {
					 it.remove();
				 }
				 else {
					 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
					 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get( srcNode.getStorageID() );
					 if (containingNodes != null && containingNodes.contains(srcNode) && (excessBlocks == null || ! excessBlocks.contains(block))) {
						 DatanodeDescriptor targets[] = chooseTargets( Math.min( fileINode.getReplication() - containingNodes.size(), this.maxReplicationStreams - xmitsInProgress), containingNodes, null, blockSize);
						 if (targets.length > 0) {
							 replicateBlocks.add(block);
							 replicateTargetSets.add(targets);
							 scheduledXfers += targets.length;
						 }
					 }
				 }
			 }
			 if (replicateBlocks.size() > 0) {
				 int i = 0;
				 for (Iterator it = replicateBlocks.iterator();
				 it.hasNext();
				 i++) {
					 Block block = (Block) it.next();
					 DatanodeDescriptor targets[] = (DatanodeDescriptor[]) replicateTargetSets.elementAt(i);
					 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
					 if (containingNodes.size() + targets.length >= dir.getFileByBlock( block).getReplication() ) {
						 neededReplications.remove(block);
						 pendingReplications.add(block);
						 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.pendingTransfer: "" + block.getBlockName() + "" is removed from neededReplications to pendingReplications"");
					 }
					 if (NameNode.stateChangeLog.isInfoEnabled()) {
						 StringBuffer targetList = new StringBuffer(""datanode(s)"");
						 for (int k = 0;
						 k < targets.length;
						 k++) {
							 targetList.append(' ');
							 targetList.append(targets[k].getName());
						 }
						 NameNode.stateChangeLog.info( ""BLOCK* NameSystem.pendingTransfer: "" + ""ask "" + srcNode.getName() + "" to replicate "" + block.getBlockName() + "" to "" + targetList);
					 }
				 }
				 DatanodeDescriptor targetMatrix[][] = new DatanodeDescriptor[replicateTargetSets.size()][];
				 for (i = 0;
				 i < targetMatrix.length;
				 i++) {
					 targetMatrix[i] = (DatanodeDescriptor[]) replicateTargetSets.elementAt(i);
				 }
				 results = new Object[2];
				 results[0] = replicateBlocks.toArray(new Block[replicateBlocks.size()]);
				 results[1] = targetMatrix;
			 }
		 }
		 return results;
	 }
 }",0,0,1,0
"public interface IPageFactory{
	<C extends Page> Page newPage(final Class<C> pageClass);
	<C extends Page> Page newPage(final Class<C> pageClass, final PageParameters parameters);
}",0,0,0,0
"protected void runExec(Execute exe) throws BuildException {
	 int totalFiles = 0;
	 int totalDirs = 0;
	 boolean haveExecuted = false;
	 try {
		 Vector fileNames = new Vector();
		 Vector baseDirs = new Vector();
		 for (int i = 0;
		 i < filesets.size();
		 i++) {
			 String currentType = type;
			 AbstractFileSet fs = (AbstractFileSet) filesets.elementAt(i);
			 if (fs instanceof DirSet) {
				 if (!FileDirBoth.DIR.equals(type)) {
					 log(""Found a nested dirset but type is "" + type + "". "" + ""Temporarily switching to type=\""dir\"" on the"" + "" assumption that you really did mean"" + "" <dirset> not <fileset>."", Project.MSG_DEBUG);
					 currentType = FileDirBoth.DIR;
				 }
			 }
			 File base = fs.getDir(getProject());
			 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
			 if (!FileDirBoth.DIR.equals(currentType)) {
				 String[] s = getFiles(base, ds);
				 for (int j = 0;
				 j < s.length;
				 j++) {
					 totalFiles++;
					 fileNames.addElement(s[j]);
					 baseDirs.addElement(base);
				 }
			 }
			 if (!FileDirBoth.FILE.equals(currentType)) {
				 String[] s = getDirs(base, ds);
				 for (int j = 0;
				 j < s.length;
				 j++) {
					 totalDirs++;
					 fileNames.addElement(s[j]);
					 baseDirs.addElement(base);
				 }
			 }
			 if (fileNames.size() == 0 && skipEmpty) {
				 logSkippingFileset(currentType, ds, base);
				 continue;
			 }
			 if (!parallel) {
				 String[] s = new String[fileNames.size()];
				 fileNames.copyInto(s);
				 for (int j = 0;
				 j < s.length;
				 j++) {
					 String[] command = getCommandline(s[j], base);
					 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
					 exe.setCommandline(command);
					 if (redirectorElement != null) {
						 setupRedirector();
						 redirectorElement.configure(redirector, s[j]);
					 }
					 if (redirectorElement != null || haveExecuted) {
						 exe.setStreamHandler(redirector.createHandler());
					 }
					 runExecute(exe);
					 haveExecuted = true;
				 }
				 fileNames.removeAllElements();
				 baseDirs.removeAllElements();
			 }
		 }
		 if (resources != null) {
			 Iterator iter = resources.iterator();
			 while (iter.hasNext()) {
				 Resource res = (Resource) iter.next();
				 if (!res.isExists() && ignoreMissing) {
					 continue;
				 }
				 File base = null;
				 String name = res.getName();
				 if (res instanceof FileResource) {
					 FileResource fr = (FileResource) res;
					 base = fr.getBaseDir();
					 if (base == null) {
						 name = fr.getFile().getAbsolutePath();
					 }
				 }
				 if (restrict(new String[] {
				name}
				, base).length == 0) {
					 continue;
				 }
				 if ((!res.isDirectory() || !res.isExists()) && !FileDirBoth.DIR.equals(type)) {
					 totalFiles++;
				 }
				 else if (res.isDirectory() && !FileDirBoth.FILE.equals(type)) {
					 totalDirs++;
				 }
				 else {
					 continue;
				 }
				 baseDirs.add(base);
				 fileNames.add(name);
				 if (!parallel) {
					 String[] command = getCommandline(name, base);
					 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
					 exe.setCommandline(command);
					 if (redirectorElement != null) {
						 setupRedirector();
						 redirectorElement.configure(redirector, name);
					 }
					 if (redirectorElement != null || haveExecuted) {
						 exe.setStreamHandler(redirector.createHandler());
					 }
					 runExecute(exe);
					 haveExecuted = true;
					 fileNames.removeAllElements();
					 baseDirs.removeAllElements();
				 }
			 }
		 }
		 if (parallel && (fileNames.size() > 0 || !skipEmpty)) {
			 runParallel(exe, fileNames, baseDirs);
			 haveExecuted = true;
		 }
		 if (haveExecuted) {
			 log(""Applied "" + cmdl.getExecutable() + "" to "" + totalFiles + "" file"" + (totalFiles != 1 ? ""s"" : """") + "" and "" + totalDirs + "" director"" + (totalDirs != 1 ? ""ies"" : ""y"") + ""."", verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
		 }
	 }
	 catch (IOException e) {
		 throw new BuildException(""Execute failed: "" + e, e, getLocation());
	 }
	 finally {
		 logFlush();
		 redirector.setAppendProperties(false);
		 redirector.setProperties();
	 }
 }",0,0,1,0
"public class ResolvePropertyMap implements GetProperty {
	 private final Set seen = new HashSet();
	 private final ParseProperties parseProperties;
	 private final GetProperty master;
	 private Map map;
	 private String prefix;
	 private boolean prefixValues = false;
	 private boolean expandingLHS = true;
	 public ResolvePropertyMap(Project project, GetProperty master, Collection expanders) {
		 this.master = master;
		 this.parseProperties = new ParseProperties(project, expanders, this);
	 }
	 public Object getProperty(String name) {
		 if (seen.contains(name)) {
			 throw new BuildException( ""Property "" + name + "" was circularly "" + ""defined."");
		 }
		 try {
			 String fullKey = name;
			 if (prefix != null && (expandingLHS || prefixValues)) {
				 fullKey = prefix + name;
			 }
			 Object masterValue = master.getProperty(fullKey);
			 if (masterValue != null) {
				 return masterValue;
			 }
			 seen.add(name);
			 expandingLHS = false;
			 return parseProperties.parseProperties((String) map.get(name));
		 }
		 finally {
			 seen.remove(name);
		 }
	 }
	 public void resolveAllProperties(Map map) {
		 resolveAllProperties(map, null, false);
	 }
	 public void resolveAllProperties(Map map, String prefix) {
		 resolveAllProperties(map, null, false);
	 }
	 public void resolveAllProperties(Map map, String prefix, boolean prefixValues) {
		 this.map = map;
		 this.prefix = prefix;
		 this.prefixValues = prefixValues;
		 for (Iterator i = map.keySet().iterator();
		 i.hasNext();
		) {
			 expandingLHS = true;
			 String key = (String) i.next();
			 Object result = getProperty(key);
			 String value = result == null ? """" : result.toString();
			 map.put(key, value);
		 }
	 }
}",0,0,0,0
"public AboutFrame() {
	 setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
	 setTitle(BundleMessage.format(""UI_ABOUT_DAVMAIL""));
	 try {
		 setIconImage(DavGatewayTray.getFrameIcon());
	 }
	 catch (NoSuchMethodError error) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
	 }
	 try {
		 JLabel imageLabel = new JLabel();
		 ClassLoader classloader = this.getClass().getClassLoader();
		 URL imageUrl = classloader.getResource(""tray32.png"");
		 Image iconImage = ImageIO.read(imageUrl);
		 if (iconImage != null) {
			 ImageIcon icon = new ImageIcon(iconImage);
			 imageLabel.setIcon(icon);
		 }
		 JPanel imagePanel = new JPanel();
		 imagePanel.add(imageLabel);
		 add(BorderLayout.WEST, imagePanel);
	 }
	 catch (IOException e) {
		 DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_CREATE_ICON""), e);
	 }
	 jEditorPane = new JEditorPane();
	 HTMLEditorKit htmlEditorKit = new HTMLEditorKit();
	 StyleSheet stylesheet = htmlEditorKit.getStyleSheet();
	 Font font = jEditorPane.getFont();
	 stylesheet.addRule(""body {
		 font-size:small;
	font-family: "" + ((font==null)?""Arial"":font.getFamily()) + '}
	');
	 jEditorPane.setEditorKit(htmlEditorKit);
	 jEditorPane.setContentType(""text/html"");
	 jEditorPane.setText(getContent(null));
	 jEditorPane.setEditable(false);
	 jEditorPane.setOpaque(false);
	 jEditorPane.addHyperlinkListener(new HyperlinkListener() {
		 public void hyperlinkUpdate(HyperlinkEvent hle) {
			 if (HyperlinkEvent.EventType.ACTIVATED.equals(hle.getEventType())) {
				 try {
					 DesktopBrowser.browse(hle.getURL().toURI());
				 }
				 catch (URISyntaxException e) {
					 DavGatewayTray.error(new BundleMessage(""LOG_UNABLE_TO_OPEN_LINK""), e);
				 }
				 setVisible(false);
			 }
		 }
	 }
	);
	 JPanel mainPanel = new JPanel();
	 mainPanel.add(jEditorPane);
	 add(BorderLayout.CENTER, mainPanel);
	 JPanel buttonPanel = new JPanel();
	 JButton ok = new JButton(BundleMessage.format(""UI_BUTTON_OK""));
	 ActionListener close = new ActionListener() {
		 public void actionPerformed(ActionEvent evt) {
			 setVisible(false);
		 }
	 }
	;
	 ok.addActionListener(close);
	 buttonPanel.add(ok);
	 add(BorderLayout.SOUTH, buttonPanel);
	 pack();
	 setResizable(false);
	 setLocation(getToolkit().getScreenSize().width / 2 - getSize().width / 2, getToolkit().getScreenSize().height / 2 - getSize().height / 2);
 }",0,0,1,0
"public class PerforceScmProvider extends AbstractScmProvider{
	 private static final String[] PROTOCOLS = {
	 ""tcp"", ""tcp4"", ""tcp6"", ""tcp46"", ""tcp64"", ""ssl"", ""ssl4"", ""ssl6"", ""ssl46"", ""ssl64"" }
	;
	 public boolean requiresEditMode() {
		 return true;
	 }
	 public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter ) throws ScmRepositoryException {
		 String protocol = null;
		 String path;
		 int port = 0;
		 String host = null;
		 int i0 = scmSpecificUrl.indexOf( delimiter );
		 if ( i0 > 0 ) {
			 protocol = scmSpecificUrl.substring( 0, i0 );
			 HashSet<String> protocols = new HashSet<String>( Arrays.asList( PROTOCOLS ) );
			 if ( protocols.contains( protocol ) ) {
				 scmSpecificUrl = scmSpecificUrl.substring( i0 + 1 );
			 }
			 else {
				 protocol = null;
			 }
		 }
		 int i1 = scmSpecificUrl.indexOf( delimiter );
		 int i2 = scmSpecificUrl.indexOf( delimiter, i1 + 1 );
		 if ( i1 > 0 ) {
			 int lastDelimiter = scmSpecificUrl.lastIndexOf( delimiter );
			 path = scmSpecificUrl.substring( lastDelimiter + 1 );
			 host = scmSpecificUrl.substring( 0, i1 );
			 if ( i2 >= 0 ) {
				 try {
					 String tmp = scmSpecificUrl.substring( i1 + 1, lastDelimiter );
					 port = Integer.parseInt( tmp );
				 }
				 catch ( NumberFormatException ex ) {
					 throw new ScmRepositoryException( ""The port has to be a number."" );
				 }
			 }
		 }
		 else {
			 path = scmSpecificUrl;
		 }
		 String user = null;
		 String password = null;
		 if ( host != null && host.indexOf( '@' ) > 1 ) {
			 user = host.substring( 0, host.indexOf( '@' ) );
			 host = host.substring( host.indexOf( '@' ) + 1 );
		 }
		 if ( path.indexOf( '@' ) > 1 ) {
			 if ( host != null ) {
				 if ( getLogger().isWarnEnabled() ) {
					 getLogger().warn( ""Username as part of path is deprecated, the new format is "" + ""scm:perforce:[username@]host:port:path_to_repository"" );
				 }
			 }
			 user = path.substring( 0, path.indexOf( '@' ) );
			 path = path.substring( path.indexOf( '@' ) + 1 );
		 }
		 return new PerforceScmProviderRepository( protocol, host, port, path, user, password );
	 }
	 public String getScmType() {
		 return ""perforce"";
	 }
	 protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters ) throws ScmException {
		 PerforceChangeLogCommand command = new PerforceChangeLogCommand();
		 command.setLogger( getLogger() );
		 return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );
	 }
	 public AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceAddCommand command = new PerforceAddCommand();
		 command.setLogger( getLogger() );
		 return (AddScmResult) command.execute( repository, fileSet, params );
	 }
	 protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceRemoveCommand command = new PerforceRemoveCommand();
		 command.setLogger( getLogger() );
		 return (RemoveScmResult) command.execute( repository, fileSet, params );
	 }
	 protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceCheckInCommand command = new PerforceCheckInCommand();
		 command.setLogger( getLogger() );
		 return (CheckInScmResult) command.execute( repository, fileSet, params );
	 }
	 protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceCheckOutCommand command = new PerforceCheckOutCommand();
		 command.setLogger( getLogger() );
		 return (CheckOutScmResult) command.execute( repository, fileSet, params );
	 }
	 protected DiffScmResult diff( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceDiffCommand command = new PerforceDiffCommand();
		 command.setLogger( getLogger() );
		 return (DiffScmResult) command.execute( repository, fileSet, params );
	 }
	 protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceEditCommand command = new PerforceEditCommand();
		 command.setLogger( getLogger() );
		 return (EditScmResult) command.execute( repository, fileSet, params );
	 }
	 protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceLoginCommand command = new PerforceLoginCommand();
		 command.setLogger( getLogger() );
		 return (LoginScmResult) command.execute( repository, fileSet, params );
	 }
	 protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceStatusCommand command = new PerforceStatusCommand();
		 command.setLogger( getLogger() );
		 return (StatusScmResult) command.execute( repository, fileSet, params );
	 }
	 protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceTagCommand command = new PerforceTagCommand();
		 command.setLogger( getLogger() );
		 return (TagScmResult) command.execute( repository, fileSet, params );
	 }
	 protected UnEditScmResult unedit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceUnEditCommand command = new PerforceUnEditCommand();
		 command.setLogger( getLogger() );
		 return (UnEditScmResult) command.execute( repository, fileSet, params );
	 }
	 protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceUpdateCommand command = new PerforceUpdateCommand();
		 command.setLogger( getLogger() );
		 return (UpdateScmResult) command.execute( repository, fileSet, params );
	 }
	 protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params ) throws ScmException {
		 PerforceBlameCommand command = new PerforceBlameCommand();
		 command.setLogger( getLogger() );
		 return (BlameScmResult) command.execute( repository, fileSet, params );
	 }
	 public static Commandline createP4Command( PerforceScmProviderRepository repo, File workingDir ) {
		 Commandline command = new Commandline();
		 command.setExecutable( ""p4"" );
		 if ( workingDir != null ) {
			 command.createArg().setValue( ""-d"" );
			 command.createArg().setValue( workingDir.getAbsolutePath() );
		 }
		 if ( repo.getHost() != null ) {
			 command.createArg().setValue( ""-p"" );
			 String value = """";
			 if ( ! StringUtils.isBlank( repo.getProtocol() ) ) {
				 value += repo.getProtocol() + "":"";
			 }
			 value += repo.getHost();
			 if ( repo.getPort() != 0 ) {
				 value += "":"" + Integer.toString( repo.getPort() );
			 }
			 command.createArg().setValue( value );
		 }
		 if ( StringUtils.isNotEmpty( repo.getUser() ) ) {
			 command.createArg().setValue( ""-u"" );
			 command.createArg().setValue( repo.getUser() );
		 }
		 if ( StringUtils.isNotEmpty( repo.getPassword() ) ) {
			 command.createArg().setValue( ""-P"" );
			 command.createArg().setValue( repo.getPassword() );
		 }
		 return command;
	 }
	 public static String clean( String string ) {
		 if ( string.indexOf( "" -P "" ) == -1 ) {
			 return string;
		 }
		 int idx = string.indexOf( "" -P "" ) + 4;
		 int end = string.indexOf( ' ', idx );
		 return string.substring( 0, idx ) + StringUtils.repeat( ""*"", end - idx ) + string.substring( end );
	 }
	 public static String getCanonicalRepoPath( String repoPath ) {
		 if ( repoPath.endsWith( ""/..."" ) ) {
			 return repoPath;
		 }
		 else if ( repoPath.endsWith( ""/"" ) ) {
			 return repoPath + ""..."";
		 }
		 else {
			 return repoPath + ""/..."";
		 }
	 }
	 private static final String NEWLINE = ""\r\n"";
	 public static String createClientspec( ScmLogger logger, PerforceScmProviderRepository repo, File workDir, String repoPath ) {
		 String clientspecName = getClientspecName( logger, repo, workDir );
		 String userName = getUsername( logger, repo );
		 String rootDir;
		 try {
			 rootDir = workDir.getCanonicalPath();
		 }
		 catch ( IOException ex ) {
			 rootDir = workDir.getAbsolutePath();
		 }
		 StringBuilder buf = new StringBuilder();
		 buf.append( ""Client: "" ).append( clientspecName ).append( NEWLINE );
		 buf.append( ""Root: "" ).append( rootDir ).append( NEWLINE );
		 buf.append( ""Owner: "" ).append( userName ).append( NEWLINE );
		 buf.append( ""View:"" ).append( NEWLINE );
		 buf.append( ""\t"" ).append( PerforceScmProvider.getCanonicalRepoPath( repoPath ) );
		 buf.append( "" buf.append( ""Description:"" ).append( NEWLINE );
		 buf.append( ""\t"" ).append( ""Created by maven-scm-provider-perforce"" ).append( NEWLINE );
		 return buf.toString();
	 }
	 public static final String DEFAULT_CLIENTSPEC_PROPERTY = ""maven.scm.perforce.clientspec.name"";
	 public static String getClientspecName( ScmLogger logger, PerforceScmProviderRepository repo, File workDir ) {
		 String def = generateDefaultClientspecName( logger, repo, workDir );
		 String l = System.getProperty( DEFAULT_CLIENTSPEC_PROPERTY, def );
		 if ( l == null || """".equals( l.trim() ) ) {
			 return def;
		 }
		 return l;
	 }
	 private static String generateDefaultClientspecName( ScmLogger logger, PerforceScmProviderRepository repo, File workDir ) {
		 String username = getUsername( logger, repo );
		 String hostname;
		 String path;
		 try {
			 hostname = InetAddress.getLocalHost().getHostName();
			 path = workDir.getCanonicalPath().replaceAll( ""[/ ~]"", ""-"" );
		 }
		 catch ( UnknownHostException e ) {
			 throw new RuntimeException( e );
		 }
		 catch ( IOException e ) {
			 throw new RuntimeException( e );
		 }
		 return username + ""-"" + hostname + ""-MavenSCM-"" + path;
	 }
	 private static String getUsername( ScmLogger logger, PerforceScmProviderRepository repo ) {
		 String username = PerforceInfoCommand.getInfo( logger, repo ).getEntry( ""User name"" );
		 if ( username == null ) {
			 username = repo.getUser();
			 if ( username == null ) {
				 username = System.getProperty( ""user.name"", ""nouser"" );
			 }
		 }
		 return username;
	 }
	 public static String getRepoPath( ScmLogger log, PerforceScmProviderRepository repo, File basedir ) {
		 PerforceWhereCommand where = new PerforceWhereCommand( log, repo );
		 if ( basedir.toString().replace( '\\', '/' ).endsWith( ""/target/checkout"" ) ) {
			 String dir = basedir.toString();
			 basedir = new File( dir.substring( 0, dir.length() - ""/target/checkout"".length() ) );
			 log.debug( ""Fixing checkout URL: "" + basedir );
		 }
		 File pom = new File( basedir, ""pom.xml"" );
		 String loc = repo.getPath();
		 log.debug( ""SCM path in pom: "" + loc );
		 if ( pom.exists() ) {
			 loc = where.getDepotLocation( pom );
			 if ( loc == null ) {
				 loc = repo.getPath();
				 log.debug( ""cannot find depot => using "" + loc );
			 }
			 else if ( loc.endsWith( ""/pom.xml"" ) ) {
				 loc = loc.substring( 0, loc.length() - ""/pom.xml"".length() );
				 log.debug( ""Actual POM location: "" + loc );
				 if ( !repo.getPath().equals( loc ) ) {
					 log.info( ""The SCM location in your pom.xml ("" + repo.getPath() + "") is not equal to the depot location ("" + loc + ""). This happens frequently with branches. "" + ""Ignoring the SCM location."" );
				 }
			 }
		 }
		 return loc;
	 }
	 private static Boolean live = null;
	 public static boolean isLive() {
		 if ( live == null ) {
			 if ( !Boolean.getBoolean( ""maven.scm.testing"" ) ) {
				 live = Boolean.TRUE;
			 }
			 else {
				 try {
					 Commandline command = new Commandline();
					 command.setExecutable( ""p4"" );
					 Process proc = command.execute();
					 BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );
					 String line;
					 while ( ( line = br.readLine() ) != null ) {
					 }
					 int rc = proc.exitValue();
					 live = ( rc == 0 ? Boolean.TRUE : Boolean.FALSE );
				 }
				 catch ( Exception e ) {
					 e.printStackTrace();
					 live = Boolean.FALSE;
				 }
			 }
		 }
		 return live.booleanValue();
	 }
}",1,1,0,0
"public Future<T> monitorUntil(final ActiveAnnotationContext ctx, final CancelIndicator cancelIndicator, final Function0<? extends Boolean> isFinished) {
	 Future<T> _xblockexpression = null;
	 {
		 final Runnable _function = () -> {
			 try {
				 while ((!(isFinished.apply()).booleanValue())) {
					 {
						 boolean _isCanceled = cancelIndicator.isCanceled();
						 if (_isCanceled) {
							 CompilationUnitImpl _compilationUnit = ctx.getCompilationUnit();
							 _compilationUnit.setCanceled(true);
							 return;
						 }
						 Thread.sleep(100);
					 }
				 }
			 }
			 catch (Throwable _e) {
				 throw Exceptions.sneakyThrow(_e);
			 }
		 }
		;
		 final Runnable r = _function;
		 Future<T> _xtrycatchfinallyexpression = null;
		 try {
			 _xtrycatchfinallyexpression = this.pool.submit(r);
		 }
		 catch (final Throwable _t) {
			 if (_t instanceof RejectedExecutionException) {
				 final RejectedExecutionException e = (RejectedExecutionException)_t;
				 AnnotationProcessor.CancellationObserver.log.debug(e.getMessage(), e);
				 new Thread(r).start();
			 }
			 else {
				 throw Exceptions.sneakyThrow(_t);
			 }
		 }
		 _xblockexpression = _xtrycatchfinallyexpression;
	 }
	 return _xblockexpression;
 }",0,0,1,0
"public class Recorder extends Task implements SubBuildListener {
	 private String filename = null;
	 private Boolean append = null;
	 private Boolean start = null;
	 private int loglevel = -1;
	 private boolean emacsMode = false;
	 private static Hashtable recorderEntries = new Hashtable();
	 public void init() {
		 getProject().addBuildListener(this);
	 }
	 public void setName(String fname) {
		 filename = fname;
	 }
	 public void setAction(ActionChoices action) {
		 if (action.getValue().equalsIgnoreCase(""start"")) {
			 start = Boolean.TRUE;
		 }
		 else {
			 start = Boolean.FALSE;
		 }
	 }
	 public void setAppend(boolean append) {
		 this.append = (append ? Boolean.TRUE : Boolean.FALSE);
	 }
	 public void setEmacsMode(boolean emacsMode) {
		 this.emacsMode = emacsMode;
	 }
	 public void setLoglevel(VerbosityLevelChoices level) {
		 loglevel = level.getLevel();
	 }
	 public void execute() throws BuildException {
		 if (filename == null) {
			 throw new BuildException(""No filename specified"");
		 }
		 getProject().log(""setting a recorder for name "" + filename, Project.MSG_DEBUG);
		 RecorderEntry recorder = getRecorder(filename, getProject());
		 recorder.setMessageOutputLevel(loglevel);
		 recorder.setEmacsMode(emacsMode);
		 if (start != null) {
			 if (start.booleanValue()) {
				 recorder.reopenFile();
				 recorder.setRecordState(start);
			 }
			 else {
				 recorder.setRecordState(start);
				 recorder.closeFile();
			 }
		 }
	 }
	 public static class ActionChoices extends EnumeratedAttribute {
		 private static final String[] VALUES = {
		""start"", ""stop""}
		;
		 public String[] getValues() {
			 return VALUES;
		 }
	 }
	 public static class VerbosityLevelChoices extends LogLevel {
	 }
	 protected RecorderEntry getRecorder(String name, Project proj) throws BuildException {
		 Object o = recorderEntries.get(name);
		 RecorderEntry entry;
		 if (o == null) {
			 entry = new RecorderEntry(name);
			 if (append == null) {
				 entry.openFile(false);
			 }
			 else {
				 entry.openFile(append.booleanValue());
			 }
			 entry.setProject(proj);
			 recorderEntries.put(name, entry);
		 }
		 else {
			 entry = (RecorderEntry) o;
		 }
		 return entry;
	 }
	 public void buildStarted(BuildEvent event) {
	 }
	 public void subBuildStarted(BuildEvent event) {
	 }
	 public void targetStarted(BuildEvent event) {
	 }
	 public void targetFinished(BuildEvent event) {
	 }
	 public void taskStarted(BuildEvent event) {
	 }
	 public void taskFinished(BuildEvent event) {
	 }
	 public void messageLogged(BuildEvent event) {
	 }
	 public void buildFinished(BuildEvent event) {
		 cleanup();
	 }
	 public void subBuildFinished(BuildEvent event) {
		 if (event.getProject() == getProject()) {
			 cleanup();
		 }
	 }
	 private void cleanup() {
		 Hashtable entries = (Hashtable) recorderEntries.clone();
		 Iterator itEntries = entries.entrySet().iterator();
		 while (itEntries.hasNext()) {
			 Map.Entry entry = (Map.Entry) itEntries.next();
			 RecorderEntry re = (RecorderEntry) entry.getValue();
			 if (re.getProject() == getProject()) {
				 recorderEntries.remove(entry.getKey());
			 }
		 }
		 getProject().removeBuildListener(this);
	 }
}",0,0,0,0
"public class ExistingEnumElements extends AbstractEnumRuleElementFinder {
	private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.xtext.enumrules.EnumRulesTestLanguage.ExistingEnum"");
	private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
	private final EnumLiteralDeclaration cSameNameEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
	private final Keyword cSameNameSameNameKeyword_0_0 = (Keyword)cSameNameEnumLiteralDeclaration_0.eContents().get(0);
	private final EnumLiteralDeclaration cOverriddenLiteralEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
	private final Keyword cOverriddenLiteralOverriddenKeyword_1_0 = (Keyword)cOverriddenLiteralEnumLiteralDeclaration_1.eContents().get(0);
	private final EnumLiteralDeclaration cDifferentNameEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
	private final Keyword cDifferentNameDifferentLiteralKeyword_2_0 = (Keyword)cDifferentNameEnumLiteralDeclaration_2.eContents().get(0);
	public EnumRule getRule() {
		 return rule;
	 }
	public Alternatives getAlternatives() {
		 return cAlternatives;
	 }
	public EnumLiteralDeclaration getSameNameEnumLiteralDeclaration_0() {
		 return cSameNameEnumLiteralDeclaration_0;
	 }
	public Keyword getSameNameSameNameKeyword_0_0() {
		 return cSameNameSameNameKeyword_0_0;
	 }
	public EnumLiteralDeclaration getOverriddenLiteralEnumLiteralDeclaration_1() {
		 return cOverriddenLiteralEnumLiteralDeclaration_1;
	 }
	public Keyword getOverriddenLiteralOverriddenKeyword_1_0() {
		 return cOverriddenLiteralOverriddenKeyword_1_0;
	 }
	public EnumLiteralDeclaration getDifferentNameEnumLiteralDeclaration_2() {
		 return cDifferentNameEnumLiteralDeclaration_2;
	 }
	public Keyword getDifferentNameDifferentLiteralKeyword_2_0() {
		 return cDifferentNameDifferentLiteralKeyword_2_0;
	 }
}",0,1,0,0
"public class SocketSessionManagementService{
	 public final static SocketSessionManagementService instance = new SocketSessionManagementService();
	 public final static ThreadLocal<SocketAddress> remoteSocket = new ThreadLocal<SocketAddress>();
	 private Map<SocketAddress, ClientState> activeSocketSessions = new ConcurrentHashMap<SocketAddress, ClientState>();
	 public ClientState get(SocketAddress key) {
		 ClientState retval = null;
		 if (null != key) {
			 retval = activeSocketSessions.get(key);
		 }
		 return retval;
	 }
	 public void put(SocketAddress key, ClientState value) {
		 if (null != key && null != value) {
			 activeSocketSessions.put(key, value);
		 }
	 }
	 public boolean remove(SocketAddress key) {
		 assert null != key;
		 boolean retval = false;
		 if (null != activeSocketSessions.remove(key)) {
			 retval = true;
		 }
		 return retval;
	 }
	 public void clear() {
		 activeSocketSessions.clear();
	 }
}",0,0,0,0
"public boolean chunkComplete(String id) {
	if (finished) {
		return true;
	}
	if (stopFlag) {
		return true;
	}
	if (id.equals(manifestSegment.getId())) {
		if (initOrUpdateSegments()) {
			listener.downloadConfirmed(this.id);
		}
		 else {
			if (!stopFlag) {
				this.errorCode = XDMConstants.ERR_INVALID_RESP;
				listener.downloadFailed(this.id);
				return true;
			}
		}
	}
	 else {
		Segment s = getById(id);
		if (s.getLength() < 0) {
			s.setLength(s.getDownloaded());
		}
		if (allFinished()) {
			saveState();
			finished = true;
			updateStatus();
			try {
				assembleFinished = false;
				assemble();
				Logger.log(""********Download finished*********"");
				updateStatus();
				assembleFinished = true;
				listener.downloadFinished(this.id);
			}
			 catch (Exception e) {
				if (!stopFlag) {
					Logger.log(e);
					this.errorCode = XDMConstants.ERR_ASM_FAILED;
					listener.downloadFailed(this.id);
				}
			}
			listener = null;
			return true;
		}
	}
	processSegments();
	return true;
}",0,0,1,0
"public class DocumentParseFixture extends ColumnFixture {
	public String HTML;
	public String Note;
	 public String Output() throws ParseException {
		return GenerateOutput(new Parse(HTML));
	}
	public String Structure() throws ParseException {
		return dumpTables(new Parse(HTML));
	}
	private String GenerateOutput(Parse parse) {
		StringWriter result = new StringWriter();
		parse.print(new PrintWriter(result));
		return result.toString();
	}
	private String dumpTables(Parse table) {
		String result = """";
		String separator = """";
		while (table != null) {
			result += separator;
			result += dumpRows(table.parts);
			separator = ""\n----\n"";
			table = table.more;
		}
		return result;
	}
	private String dumpRows(Parse row) {
		String result = """";
		String separator = """";
		while (row != null) {
			result += separator;
			result += dumpCells(row.parts);
			separator = ""\n"";
			row = row.more;
		}
		return result;
	}
	private String dumpCells(Parse cell) {
		String result = """";
		String separator = """";
		while (cell != null) {
			result += separator;
			result += ""["" + cell.body + ""]"";
			separator = "" "";
			cell = cell.more;
		}
		return result;
	}
}",0,0,0,0
"public static String basePath(final String path, final String extension){
	if (extension != null){
		return path.substring(0, path.length() - extension.length() - 1);
	}
	return path;
}",0,0,0,0
"public interface Customer583Repository extends CrudRepository<Customer583, Long> {
	List<Customer583> findByLastName(String lastName);
}",0,1,0,0
"public Control createPageArea(Composite parent) {
	 Composite top = new Composite(parent, SWT.NONE);
	 top.setLayout(new GridLayout());
	 Group group = new Group(top, SWT.NONE);
	 group.setText(""Classpath"");
	 group.setLayout(new GridLayout());
	 GridData griddata = new GridData(GridData.FILL_HORIZONTAL);
	 group.setLayoutData(griddata);
	 group.setLayout(new GridLayout(2, false));
	 classpath = new List(group, SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL | SWT.MULTI);
	 griddata = new GridData(GridData.FILL_BOTH);
	 griddata.widthHint = 250;
	 griddata.heightHint = classpath.getItemHeight() * 10;
	 classpath.setLayoutData(griddata);
	 classpath.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
		 }
	 }
	);
	 Composite composite = new Composite(group, SWT.NONE);
	 composite.setLayoutData(new GridData(GridData.FILL_VERTICAL));
	 GridLayout layout = new GridLayout();
	 layout.marginHeight = 0;
	 layout.marginWidth = 2;
	 composite.setLayout(layout);
	 addjar = new Button(composite, SWT.NONE);
	 addjar.setText(""Add JAR File..."");
	 addjar.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
		 }
	 }
	);
	 griddata = new GridData(GridData.FILL_HORIZONTAL);
	 griddata.widthHint = 130;
	 addjar.setLayoutData(griddata);
	 addfolder = new Button(composite, SWT.NONE);
	 addfolder.setText(""Add Class Folder..."");
	 addfolder.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
		 }
	 }
	);
	 griddata = new GridData(GridData.FILL_HORIZONTAL);
	 griddata.widthHint = 130;
	 addfolder.setLayoutData(griddata);
	 remove = new Button(composite, SWT.NONE);
	 remove.setText(""Remove"");
	 remove.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
		 }
	 }
	);
	 griddata = new GridData(GridData.FILL_HORIZONTAL);
	 griddata.widthHint = 130;
	 remove.setLayoutData(griddata);
	 return top;
 }",0,0,1,0
"public static String filterStack(String stack) {
	 if (!filtertrace) {
		 return stack;
	 }
	 StringWriter sw = new StringWriter();
	 BufferedWriter pw = new BufferedWriter(sw);
	 StringReader sr = new StringReader(stack);
	 BufferedReader br = new BufferedReader(sr);
	 String line;
	 try {
		 boolean firstLine = true;
		 while ((line = br.readLine()) != null) {
			 if (firstLine || !filterLine(line)) {
				 pw.write(line);
				 pw.newLine();
			 }
			 firstLine = false;
		 }
	 }
	 catch (Exception e) {
		 return stack;
	 }
	 finally {
		 FileUtils.close(pw);
	 }
	 return sw.toString();
 }",0,0,0,0
"public final class FullyBufferedReader{
	private final String input;
	private int inputPosition;
	private int lineNumber = 1;
	private int columnNumber = 1;
	private int lastLineCountIndex;
	private int positionMarker;
	public FullyBufferedReader(final Reader reader) throws IOException{
		super();
		input = Streams.readString(reader);
	}
	public final CharSequence getSubstring(int toPos){
		if (toPos < 0){
			toPos = input.length();
		}
		else if (toPos < positionMarker){
			return """";
		}
		return input.subSequence(positionMarker, toPos);
	}
	public final CharSequence getSubstring(final int fromPos, final int toPos){
		return input.subSequence(fromPos, toPos);
	}
	public final int getPosition(){
		return inputPosition;
	}
	public final void setPositionMarker(final int pos){
		positionMarker = pos;
	}
	public String toString(){
		return input;
	}
	public final void countLinesTo(final int end){
		for (int i = lastLineCountIndex;
		 i < end;
		 i++){
			final char ch = input.charAt(i);
			if (ch == '\n'){
				columnNumber = 1;
				lineNumber++;
			}
			else if (ch != '\r'){
				columnNumber++;
			}
		}
		lastLineCountIndex = end;
	}
	public final int find(final char ch){
		return input.indexOf(ch, inputPosition);
	}
	public final int find(final char ch, final int startPos){
		return input.indexOf(ch, startPos);
	}
	public final int find(final String str){
		return input.indexOf(str, inputPosition);
	}
	public final int find(final String str, final int startPos){
		return input.indexOf(str, startPos);
	}
	public final void setPosition(final int pos){
		inputPosition = pos;
	}
	public final int getColumnNumber(){
		return columnNumber;
	}
	public final int getLineNumber(){
		return lineNumber;
	}
	public final int size(){
		return input.length();
	}
	public final char charAt(int pos){
		return input.charAt(pos);
	}
}",0,0,0,0
"public NodeSortRecordFactory(DOM dom, String className, Translet translet, String order[], String type[], String lang[], String caseOrder[]) throws TransletException;",0,0,0,1
"public class StartupConfiguration{
	 private static final String SUREFIRE_TEST_CLASSPATH = ""surefire.test.class.path"";
	 private final String providerClassName;
	 private final AbstractPathConfiguration classpathConfiguration;
	 private final ClassLoaderConfiguration classLoaderConfiguration;
	 private final boolean isForkRequested;
	 private final boolean isInForkedVm;
	 public StartupConfiguration( String providerClassName, AbstractPathConfiguration classpathConfiguration, ClassLoaderConfiguration classLoaderConfiguration, boolean isForkRequested, boolean inForkedVm ) {
		 this.classpathConfiguration = classpathConfiguration;
		 this.classLoaderConfiguration = classLoaderConfiguration;
		 this.isForkRequested = isForkRequested;
		 this.providerClassName = providerClassName;
		 isInForkedVm = inForkedVm;
	 }
	 public boolean isProviderMainClass() {
		 return providerClassName.endsWith( ""#main"" );
	 }
	 public static StartupConfiguration inForkedVm( String providerClassName, ClasspathConfiguration classpathConfiguration, ClassLoaderConfiguration classLoaderConfiguration ) {
		 return new StartupConfiguration( providerClassName, classpathConfiguration, classLoaderConfiguration, true, true );
	 }
	 public AbstractPathConfiguration getClasspathConfiguration() {
		 return classpathConfiguration;
	 }
	 public boolean useSystemClassLoader() {
		 return classLoaderConfiguration.isUseSystemClassLoader() && ( isInForkedVm || isForkRequested );
	 }
	 public boolean isManifestOnlyJarRequestedAndUsable() {
		 return classLoaderConfiguration.isManifestOnlyJarRequestedAndUsable();
	 }
	 public String getProviderClassName() {
		 return providerClassName;
	 }
	 public String getActualClassName() {
		 return isProviderMainClass() ? stripEnd( providerClassName, ""#main"" ) : providerClassName;
	 }
	 private static String stripEnd( String str, String strip ) {
		 if ( str == null ) {
			 return null;
		 }
		 int end = str.length();
		 if ( strip == null ) {
			 while ( ( end != 0 ) && Character.isWhitespace( str.charAt( end - 1 ) ) ) {
				 end--;
			 }
		 }
		 else {
			 while ( end != 0 && strip.indexOf( str.charAt( end - 1 ) ) != -1 ) {
				 end--;
			 }
		 }
		 return str.substring( 0, end );
	 }
	 public ClassLoaderConfiguration getClassLoaderConfiguration() {
		 return classLoaderConfiguration;
	 }
	 public boolean isShadefire() {
		 return providerClassName.startsWith( ""org.apache.maven.shadefire.surefire"" );
	 }
	 public void writeSurefireTestClasspathProperty() {
		 getClasspathConfiguration().getTestClasspath().writeToSystemProperty( SUREFIRE_TEST_CLASSPATH );
	 }
}",1,0,0,0
"public int getKeyCacheSize() {
	 return keyCache.size();
 }",0,0,0,0
"private Vector getDirectoryEntries(File directory) {
	 Vector files = new Vector();
	 String[] filesInDir = directory.list();
	 if (filesInDir != null) {
		 int length = filesInDir.length;
		 for (int i = 0;
		 i < length;
		 ++i) {
			 files.addElement(new File(directory, filesInDir[i]));
		 }
	 }
	 return files;
 }",0,0,0,0
"public class DataSourceIndex implements IDataSourceIndex<String, DataSourceId> {
	 private final Index index;
	 private final String dataset;
	 private final String dataverse;
	 private final MetadataProvider metadataProvider;
	 public DataSourceIndex(Index index, String dataverse, String dataset, MetadataProvider metadataProvider) {
		 this.index = index;
		 this.dataset = dataset;
		 this.dataverse = dataverse;
		 this.metadataProvider = metadataProvider;
	 }
	 public IDataSource<DataSourceId> getDataSource() {
		 try {
			 DataSourceId sourceId = new DataSourceId(dataverse, dataset);
			 return metadataProvider.lookupSourceInMetadata(sourceId);
		 }
		 catch (Exception me) {
			 return null;
		 }
	 }
	 public String getId() {
		 return index.getIndexName();
	 }
	 public Index getIndex() {
		 return index;
	 }
}",0,0,0,0
"public int fillFields(byte[] data, int offset, EscherRecordFactory recordFactory);",0,0,0,0
"private String mapElement(String elem) {
	 int size = prefixMap.size();
	 if (size != 0) {
		 for (int i = 0;
		 i < size;
		 i++) {
			 MapEntry entry = (MapEntry) prefixMap.elementAt(i);
			 String newElem = entry.apply(elem);
			 if (newElem != elem) {
				 elem = newElem;
				 break;
			 }
		 }
	 }
	 return elem;
 }",0,0,0,0
"public SocketServer(NetworkConfig config, SSLConfig sslConfig, MetricRegistry registry, ArrayList<Port> portList) {
	 this.host = config.hostName;
	 this.port = config.port;
	 this.numProcessorThreads = config.numIoThreads;
	 this.maxQueuedRequests = config.queuedMaxRequests;
	 this.sendBufferSize = config.socketSendBufferBytes;
	 this.recvBufferSize = config.socketReceiveBufferBytes;
	 this.maxRequestSize = config.socketRequestMaxBytes;
	 processors = new ArrayList<Processor>(numProcessorThreads);
	 requestResponseChannel = new SocketRequestResponseChannel(numProcessorThreads, maxQueuedRequests);
	 metrics = new ServerNetworkMetrics(requestResponseChannel, registry, processors);
	 this.acceptors = new ArrayList<Acceptor>();
	 this.ports = new HashMap<PortType, Port>();
	 this.validatePorts(portList);
	 this.initializeSSLFactory(sslConfig);
 }",0,0,1,0
"public final class CartClickActionEvent extends ScreenActionEvent implements Parcelable {
	 public static final String ACTION = CartClickActionEvent.class.getSimpleName();
	 public CartClickActionEvent() {
		 super(ACTION);
	 }
	 protected CartClickActionEvent(Parcel in) {
		 super(in);
	 }
	 public void writeToParcel(Parcel dest, int flags) {
		 super.writeToParcel(dest, flags);
	 }
	 public int describeContents() {
		 return 0;
	 }
	 public static final Creator<CartClickActionEvent> CREATOR = new Creator<CartClickActionEvent>() {
		 public CartClickActionEvent createFromParcel(Parcel in) {
			 return new CartClickActionEvent(in);
		 }
		 public CartClickActionEvent[] newArray(int size) {
			 return new CartClickActionEvent[size];
		 }
	 }
	;
}",0,0,0,0
"public class Parser {
	 public static GetOrderReferenceDetailsResponseData getOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {
		 final GetOrderReferenceDetailsResponse response = marshalXML(GetOrderReferenceDetailsResponse.class, rawResponse);
		 return new GetOrderReferenceDetailsResponseData(response, rawResponse);
	 }
	 public static SetOrderReferenceDetailsResponseData setOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {
		 final SetOrderReferenceDetailsResponse response = marshalXML(SetOrderReferenceDetailsResponse.class, rawResponse);
		 return new SetOrderReferenceDetailsResponseData(response, rawResponse);
	 }
	 public static AuthorizeResponseData getAuthorizeData(ResponseData rawResponse) throws AmazonServiceException {
		 final AuthorizeResponse response = marshalXML(AuthorizeResponse.class, rawResponse);
		 return new AuthorizeResponseData(response, rawResponse);
	 }
	 public static GetAuthorizationDetailsResponseData getAuthorizationDetailsData(ResponseData rawResponse) throws AmazonServiceException {
		 final GetAuthorizationDetailsResponse response = marshalXML(GetAuthorizationDetailsResponse.class, rawResponse);
		 return new GetAuthorizationDetailsResponseData(response, rawResponse);
	 }
	 public static CaptureResponseData getCapture(ResponseData rawResponse) throws AmazonServiceException {
		 final CaptureResponse response = marshalXML(CaptureResponse.class, rawResponse);
		 return new CaptureResponseData(response, rawResponse);
	 }
	 public static GetCaptureDetailsResponseData getCaptureDetailsData(ResponseData rawResponse) throws AmazonServiceException {
		 final GetCaptureDetailsResponse response = marshalXML(GetCaptureDetailsResponse.class, rawResponse);
		 return new GetCaptureDetailsResponseData(response, rawResponse);
	 }
	 public static ConfirmOrderReferenceResponseData confirmOrderReference(ResponseData rawResponse) throws AmazonServiceException {
		 final ConfirmOrderReferenceResponse response = marshalXML(ConfirmOrderReferenceResponse.class, rawResponse);
		 return new ConfirmOrderReferenceResponseData(response, rawResponse);
	 }
	 public static CloseAuthorizationResponseData closeAuthorizationResponse(ResponseData rawResponse) throws AmazonServiceException {
		 final CloseAuthorizationResponse response = marshalXML(CloseAuthorizationResponse.class, rawResponse);
		 return new CloseAuthorizationResponseData(response, rawResponse);
	 }
	 public static CancelOrderReferenceResponseData getCancelOrderReference(ResponseData rawResponse) throws AmazonServiceException {
		 final CancelOrderReferenceResponse response = marshalXML(CancelOrderReferenceResponse.class, rawResponse);
		 return new CancelOrderReferenceResponseData(response, rawResponse);
	 }
	 public static CloseOrderReferenceResponseData getCloseOrderReference(ResponseData rawResponse) throws AmazonServiceException {
		 final CloseOrderReferenceResponse response = marshalXML(CloseOrderReferenceResponse.class, rawResponse);
		 return new CloseOrderReferenceResponseData(response, rawResponse);
	 }
	 public static RefundResponseData getRefundData(ResponseData rawResponse) throws AmazonServiceException {
		 final RefundResponse response = marshalXML(RefundResponse.class, rawResponse);
		 return new RefundResponseData(response, rawResponse);
	 }
	 public static GetRefundDetailsResponseData getRefundDetailsData(ResponseData rawResponse) throws AmazonServiceException {
		 final GetRefundDetailsResponse response = marshalXML(GetRefundDetailsResponse.class, rawResponse);
		 return new GetRefundDetailsResponseData(response, rawResponse);
	 }
	 public static GetBillingAgreementDetailsResponseData getBillingAgreementDetailsData(ResponseData rawResponse) throws AmazonServiceException {
		 final GetBillingAgreementDetailsResponse response = marshalXML(GetBillingAgreementDetailsResponse.class, rawResponse);
		 return new GetBillingAgreementDetailsResponseData(response, rawResponse);
	 }
	 public static SetBillingAgreementDetailsResponseData getSetBillingAgreementDetailsResponse(ResponseData rawResponse) throws AmazonServiceException {
		 final SetBillingAgreementDetailsResponse response = marshalXML(SetBillingAgreementDetailsResponse.class, rawResponse);
		 return new SetBillingAgreementDetailsResponseData(response, rawResponse);
	 }
	 public static ValidateBillingAgreementResponseData getValidateBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
		 final ValidateBillingAgreementResponse response = marshalXML(ValidateBillingAgreementResponse.class, rawResponse);
		 return new ValidateBillingAgreementResponseData(response, rawResponse);
	 }
	 public static ConfirmBillingAgreementResponseData confirmBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
		 final ConfirmBillingAgreementResponse response = marshalXML(ConfirmBillingAgreementResponse.class, rawResponse);
		 return new ConfirmBillingAgreementResponseData(response, rawResponse);
	 }
	 public static AuthorizeOnBillingAgreementResponseData getAuthorizeOnBillingAgreement(ResponseData rawResponse) throws AmazonServiceException {
		 final AuthorizeOnBillingAgreementResponse response = marshalXML(AuthorizeOnBillingAgreementResponse.class, rawResponse);
		 return new AuthorizeOnBillingAgreementResponseData(response, rawResponse);
	 }
	 public static CloseBillingAgreementResponseData closeBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
		 final CloseBillingAgreementResponse response = marshalXML(CloseBillingAgreementResponse.class, rawResponse);
		 return new CloseBillingAgreementResponseData(response, rawResponse);
	 }
	 public static GetProviderCreditDetailsResponseData getGetProviderCreditDetails(ResponseData rawResponse) throws AmazonServiceException {
		 final GetProviderCreditDetailsResponse response = marshalXML(GetProviderCreditDetailsResponse.class, rawResponse);
		 return new GetProviderCreditDetailsResponseData(response, rawResponse);
	 }
	 public static GetProviderCreditReversalDetailsResponseData getProviderCreditReversalDetails(ResponseData rawResponse) throws AmazonServiceException {
		 final GetProviderCreditReversalDetailsResponse response = marshalXML(GetProviderCreditReversalDetailsResponse.class, rawResponse);
		 return new GetProviderCreditReversalDetailsResponseData(response, rawResponse);
	 }
	 public static ReverseProviderCreditResponseData getReverseProviderCreditResponseData(ResponseData rawResponse) throws AmazonServiceException {
		 final ReverseProviderCreditResponse response = marshalXML(ReverseProviderCreditResponse.class, rawResponse);
		 return new ReverseProviderCreditResponseData(response, rawResponse);
	 }
	 public static GetServiceStatusResponseData getServiceStatus( ResponseData rawResponse) throws AmazonServiceException {
		 final GetServiceStatusResponse response = marshalXML( GetServiceStatusResponse.class, rawResponse);
		 return new GetServiceStatusResponseData(response, rawResponse);
	 }
	 public static CreateOrderReferenceForIdResponseData createOrderReferenceForId( ResponseData rawResponse) throws AmazonServiceException {
		 final CreateOrderReferenceForIdResponse response = marshalXML( CreateOrderReferenceForIdResponse.class, rawResponse);
		 return new CreateOrderReferenceForIdResponseData(response, rawResponse);
	 }
	 public static ListOrderReferenceResponseData listOrderReference(ResponseData rawResponse) throws AmazonServiceException {
		 final ListOrderReferenceResponse response = marshalXML(ListOrderReferenceResponse.class, rawResponse);
		 return new ListOrderReferenceResponseData(response, rawResponse);
	 }
	 public static ListOrderReferenceByNextTokenResponseData listOrderReferenceByNextToken(ResponseData rawResponse) throws AmazonServiceException {
		 final ListOrderReferenceByNextTokenResponse response = marshalXML(ListOrderReferenceByNextTokenResponse.class, rawResponse);
		 return new ListOrderReferenceByNextTokenResponseData(response, rawResponse);
	 }
	 public static SetOrderAttributesResponseData setOrderAttributes(ResponseData rawResponse) throws AmazonServiceException {
		 final SetOrderAttributesResponse response = marshalXML(SetOrderAttributesResponse.class, rawResponse);
		 return new SetOrderAttributesResponseData(response, rawResponse);
	 }
	 public static GetMerchantAccountStatusResponseData getMerchantAccountStatus(ResponseData rawResponse) throws AmazonServiceException {
		 final GetMerchantAccountStatusResponse response = marshalXML(GetMerchantAccountStatusResponse.class, rawResponse);
		 return new GetMerchantAccountStatusResponseData(response, rawResponse);
	 }
	 public static <T> T marshalXML(Class<T> clazz, ResponseData rawResponse) throws AmazonServiceException {
		 try {
			 if (rawResponse.getStatusCode() == 200) {
				 T responseObject = null;
				 final JAXBContext context = JAXBContext.newInstance(clazz);
				 final String noNamespaceXML = rawResponse.toXML().replaceAll( ""xmlns(?:.*?)?=\""http: final StringReader reader = new StringReader(noNamespaceXML);
				 final Unmarshaller unmarshaller = context.createUnmarshaller();
				 final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
				 xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
				 xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
				 final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);
				 responseObject = (T) unmarshaller.unmarshal(xmlStreamReader);
				 return responseObject;
			 }
			 else {
				 generateErrorException(rawResponse);
			 }
		 }
		 catch (JAXBException e) {
			 throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
		 }
		 catch (XMLStreamException e) {
			 throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
		 }
		 return null;
	 }
	 public static void generateErrorException(ResponseData rawResponse) throws AmazonServiceException, JAXBException {
		 final JAXBContext context = JAXBContext.newInstance(ErrorResponse.class);
		 final String noNamespaceXML = rawResponse.toXML().replaceAll( ""xmlns(?:.*?)?=\""http: final StringReader reader = new StringReader(noNamespaceXML);
		 final Unmarshaller unmarshaller = context.createUnmarshaller();
		 final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
		 xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
		 xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
		 try {
			 final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);
			 final ErrorResponse result = (ErrorResponse) unmarshaller.unmarshal(xmlStreamReader);
			 throw new AmazonServiceException(result, rawResponse);
		 }
		 catch (XMLStreamException e) {
			 throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
		 }
	 }
}",1,0,0,0
"static void loadYaml() {
	 try {
		 URL url = getStorageConfigURL();
		 logger.info(""Loading settings from "" + url);
		 InputStream input = null;
		 try {
			 input = url.openStream();
		 }
		 catch (IOException e) {
			 throw new AssertionError(e);
		 }
		 org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);
		 TypeDescription seedDesc = new TypeDescription(SeedProviderDef.class);
		 seedDesc.putMapPropertyType(""parameters"", String.class, String.class);
		 constructor.addTypeDescription(seedDesc);
		 Yaml yaml = new Yaml(new Loader(constructor));
		 conf = (Config)yaml.load(input);
		 if (conf.commitlog_sync == null) {
			 throw new ConfigurationException(""Missing required directive CommitLogSync"");
		 }
		 if (conf.commitlog_sync == Config.CommitLogSync.batch) {
			 if (conf.commitlog_sync_batch_window_in_ms == null) {
				 throw new ConfigurationException(""Missing value for commitlog_sync_batch_window_in_ms: Double expected."");
			 }
			 else if (conf.commitlog_sync_period_in_ms != null) {
				 throw new ConfigurationException(""Batch sync specified, but commitlog_sync_period_in_ms found. Only specify commitlog_sync_batch_window_in_ms when using batch sync"");
			 }
			 logger.debug(""Syncing log with a batch window of "" + conf.commitlog_sync_batch_window_in_ms);
		 }
		 else {
			 if (conf.commitlog_sync_period_in_ms == null) {
				 throw new ConfigurationException(""Missing value for commitlog_sync_period_in_ms: Integer expected"");
			 }
			 else if (conf.commitlog_sync_batch_window_in_ms != null) {
				 throw new ConfigurationException(""commitlog_sync_period_in_ms specified, but commitlog_sync_batch_window_in_ms found. Only specify commitlog_sync_period_in_ms when using periodic sync."");
			 }
			 logger.debug(""Syncing log with a period of "" + conf.commitlog_sync_period_in_ms);
		 }
		 if (conf.disk_access_mode == Config.DiskAccessMode.auto) {
			 conf.disk_access_mode = System.getProperty(""os.arch"").contains(""64"") ? Config.DiskAccessMode.mmap : Config.DiskAccessMode.standard;
			 indexAccessMode = conf.disk_access_mode;
			 logger.info(""DiskAccessMode 'auto' determined to be "" + conf.disk_access_mode + "", indexAccessMode is "" + indexAccessMode );
		 }
		 else if (conf.disk_access_mode == Config.DiskAccessMode.mmap_index_only) {
			 conf.disk_access_mode = Config.DiskAccessMode.standard;
			 indexAccessMode = Config.DiskAccessMode.mmap;
			 logger.info(""DiskAccessMode is "" + conf.disk_access_mode + "", indexAccessMode is "" + indexAccessMode );
		 }
		 else {
			 indexAccessMode = conf.disk_access_mode;
			 logger.info(""DiskAccessMode is "" + conf.disk_access_mode + "", indexAccessMode is "" + indexAccessMode );
		 }
		 if (conf.disk_access_mode == Config.DiskAccessMode.mmap) MmappedSegmentedFile.initCleaner();
		 if (conf.authenticator != null) authenticator = FBUtilities.<IAuthenticator>construct(conf.authenticator, ""authenticator"");
		 if (conf.authority != null) authority = FBUtilities.<IAuthority>construct(conf.authority, ""authority"");
		 authenticator.validateConfiguration();
		 authority.validateConfiguration();
		 if (conf.partitioner == null) {
			 throw new ConfigurationException(""Missing directive: partitioner"");
		 }
		 try {
			 partitioner = FBUtilities.newPartitioner(System.getProperty(""cassandra.partitioner"", conf.partitioner));
		 }
		 catch (Exception e) {
			 throw new ConfigurationException(""Invalid partitioner class "" + conf.partitioner);
		 }
		 if (conf.phi_convict_threshold < 5 || conf.phi_convict_threshold > 16) {
			 throw new ConfigurationException(""phi_convict_threshold must be between 5 and 16"");
		 }
		 if (conf.concurrent_reads != null && conf.concurrent_reads < 2) {
			 throw new ConfigurationException(""concurrent_reads must be at least 2"");
		 }
		 if (conf.concurrent_writes != null && conf.concurrent_writes < 2) {
			 throw new ConfigurationException(""concurrent_writes must be at least 2"");
		 }
		 if (conf.concurrent_replicates != null && conf.concurrent_replicates < 2) {
			 throw new ConfigurationException(""concurrent_replicates must be at least 2"");
		 }
		 if (conf.memtable_total_space_in_mb == null) conf.memtable_total_space_in_mb = (int) (Runtime.getRuntime().maxMemory() / (3 * 1048576));
		 if (conf.memtable_total_space_in_mb <= 0) throw new ConfigurationException(""memtable_total_space_in_mb must be positive"");
		 logger.info(""Global memtable threshold is enabled at {
		}
		MB"", conf.memtable_total_space_in_mb);
		 if (conf.memtable_flush_writers != null && conf.memtable_flush_writers < 1) {
			 throw new ConfigurationException(""memtable_flush_writers must be at least 1"");
		 }
		 else if (conf.memtable_flush_writers == null) {
			 conf.memtable_flush_writers = conf.data_file_directories.length;
		 }
		 if (conf.listen_address != null) {
			 try {
				 listenAddress = InetAddress.getByName(conf.listen_address);
			 }
			 catch (UnknownHostException e) {
				 throw new ConfigurationException(""Unknown listen_address '"" + conf.listen_address + ""'"");
			 }
		 }
		 if (conf.broadcast_address != null) {
			 if (conf.broadcast_address.equals(""0.0.0.0"")) {
				 throw new ConfigurationException(""broadcast_address cannot be 0.0.0.0!"");
			 }
			 try {
				 broadcastAddress = InetAddress.getByName(conf.broadcast_address);
			 }
			 catch (UnknownHostException e) {
				 throw new ConfigurationException(""Unknown broadcast_address '"" + conf.broadcast_address + ""'"");
			 }
		 }
		 if (conf.rpc_address != null) {
			 try {
				 rpcAddress = InetAddress.getByName(conf.rpc_address);
			 }
			 catch (UnknownHostException e) {
				 throw new ConfigurationException(""Unknown host in rpc_address "" + conf.rpc_address);
			 }
		 }
		 else {
			 rpcAddress = FBUtilities.getLocalAddress();
		 }
		 if (conf.thrift_framed_transport_size_in_mb <= 0) throw new ConfigurationException(""thrift_framed_transport_size_in_mb must be positive"");
		 if (conf.thrift_framed_transport_size_in_mb > 0 && conf.thrift_max_message_length_in_mb < conf.thrift_framed_transport_size_in_mb) {
			 throw new ConfigurationException(""thrift_max_message_length_in_mb must be greater than thrift_framed_transport_size_in_mb when using TFramedTransport"");
		 }
		 if (conf.endpoint_snitch == null) {
			 throw new ConfigurationException(""Missing endpoint_snitch directive"");
		 }
		 snitch = createEndpointSnitch(conf.endpoint_snitch);
		 EndpointSnitchInfo.create();
		 requestSchedulerOptions = conf.request_scheduler_options;
		 if (conf.request_scheduler != null) {
			 try {
				 if (requestSchedulerOptions == null) {
					 requestSchedulerOptions = new RequestSchedulerOptions();
				 }
				 Class cls = Class.forName(conf.request_scheduler);
				 requestScheduler = (IRequestScheduler) cls.getConstructor(RequestSchedulerOptions.class).newInstance(requestSchedulerOptions);
			 }
			 catch (ClassNotFoundException e) {
				 throw new ConfigurationException(""Invalid Request Scheduler class "" + conf.request_scheduler);
			 }
			 catch (Exception e) {
				 throw new ConfigurationException(""Unable to instantiate request scheduler"", e);
			 }
		 }
		 else {
			 requestScheduler = new NoScheduler();
		 }
		 if (conf.request_scheduler_id == RequestSchedulerId.keyspace) {
			 requestSchedulerId = conf.request_scheduler_id;
		 }
		 else {
			 requestSchedulerId = RequestSchedulerId.keyspace;
		 }
		 if (logger.isDebugEnabled() && conf.auto_bootstrap != null) {
			 logger.debug(""setting auto_bootstrap to "" + conf.auto_bootstrap);
		 }
		 if (conf.in_memory_compaction_limit_in_mb != null && conf.in_memory_compaction_limit_in_mb <= 0) {
			 throw new ConfigurationException(""in_memory_compaction_limit_in_mb must be a positive integer"");
		 }
		 if (conf.concurrent_compactors == null) conf.concurrent_compactors = Runtime.getRuntime().availableProcessors();
		 if (conf.concurrent_compactors <= 0) throw new ConfigurationException(""concurrent_compactors should be strictly greater than 0"");
		 if (conf.compaction_throughput_mb_per_sec == null) conf.compaction_throughput_mb_per_sec = 16;
		 if (conf.stream_throughput_outbound_megabits_per_sec == null) conf.stream_throughput_outbound_megabits_per_sec = 400;
		 if (!CassandraDaemon.rpc_server_types.contains(conf.rpc_server_type.toLowerCase())) throw new ConfigurationException(""Unknown rpc_server_type: "" + conf.rpc_server_type);
		 if (conf.rpc_min_threads == null) conf.rpc_min_threads = conf.rpc_server_type.toLowerCase().equals(""hsha"") ? Runtime.getRuntime().availableProcessors() * 4 : 16;
		 if (conf.rpc_max_threads == null) conf.rpc_max_threads = conf.rpc_server_type.toLowerCase().equals(""hsha"") ? Runtime.getRuntime().availableProcessors() * 4 : Integer.MAX_VALUE;
		 if (conf.commitlog_directory != null && conf.data_file_directories != null && conf.saved_caches_directory != null) {
			 for (String datadir : conf.data_file_directories) {
				 if (datadir.equals(conf.commitlog_directory)) throw new ConfigurationException(""commitlog_directory must not be the same as any data_file_directories"");
				 if (datadir.equals(conf.saved_caches_directory)) throw new ConfigurationException(""saved_caches_directory must not be the same as any data_file_directories"");
			 }
			 if (conf.commitlog_directory.equals(conf.saved_caches_directory)) throw new ConfigurationException(""saved_caches_directory must not be the same as the commitlog_directory"");
		 }
		 else {
			 if (conf.commitlog_directory == null) throw new ConfigurationException(""commitlog_directory missing"");
			 if (conf.data_file_directories == null) throw new ConfigurationException(""data_file_directories missing;
			 at least one data directory must be specified"");
			 if (conf.saved_caches_directory == null) throw new ConfigurationException(""saved_caches_directory missing"");
		 }
		 if (conf.initial_token != null) partitioner.getTokenFactory().validate(conf.initial_token);
		 try {
			 keyCacheSizeInMB = (conf.key_cache_size_in_mb == null) ? Math.min((int) (Runtime.getRuntime().totalMemory() * 0.05 / 1024 / 1024), 100) : conf.key_cache_size_in_mb;
			 if (keyCacheSizeInMB < 0) throw new NumberFormatException();
		 }
		 catch (NumberFormatException e) {
			 throw new ConfigurationException(""key_cache_size_in_mb option was set incorrectly to '"" + conf.key_cache_size_in_mb + ""', supported values are <integer> >= 0."");
		 }
		 rowCacheProvider = FBUtilities.newCacheProvider(conf.row_cache_provider);
		 KSMetaData systemMeta = KSMetaData.systemKeyspace();
		 Schema.instance.load(CFMetaData.StatusCf);
		 Schema.instance.load(CFMetaData.HintsCf);
		 Schema.instance.load(CFMetaData.MigrationsCf);
		 Schema.instance.load(CFMetaData.SchemaCf);
		 Schema.instance.load(CFMetaData.IndexCf);
		 Schema.instance.load(CFMetaData.NodeIdCf);
		 Schema.instance.load(CFMetaData.VersionCf);
		 Schema.instance.load(CFMetaData.SchemaKeyspacesCf);
		 Schema.instance.load(CFMetaData.SchemaColumnFamiliesCf);
		 Schema.instance.load(CFMetaData.SchemaColumnsCf);
		 Schema.instance.addSystemTable(systemMeta);
		 if (conf.seed_provider == null) {
			 throw new ConfigurationException(""seeds configuration is missing;
			 a minimum of one seed is required."");
		 }
		 try {
			 Class seedProviderClass = Class.forName(conf.seed_provider.class_name);
			 seedProvider = (SeedProvider)seedProviderClass.getConstructor(Map.class).newInstance(conf.seed_provider.parameters);
		 }
		 catch (Exception e) {
			 logger.error(""Fatal configuration error"", e);
			 System.err.println(e.getMessage() + ""\nFatal configuration error;
			 unable to start server. See log for stacktrace."");
			 System.exit(1);
		 }
		 if (seedProvider.getSeeds().size() == 0) throw new ConfigurationException(""The seed provider lists no seeds."");
	 }
	 catch (ConfigurationException e) {
		 logger.error(""Fatal configuration error"", e);
		 System.err.println(e.getMessage() + ""\nFatal configuration error;
		 unable to start server. See log for stacktrace."");
		 System.exit(1);
	 }
	 catch (YAMLException e) {
		 logger.error(""Fatal configuration error error"", e);
		 System.err.println(e.getMessage() + ""\nInvalid yaml;
		 unable to start server. See log for stacktrace."");
		 System.exit(1);
	 }
 }",0,0,1,0
"public static void fullConnectMapLayers(FeatureMapsLayer fromLayer, FeatureMapsLayer toLayer) {
	 if (toLayer instanceof ConvolutionalLayer) {
		 for (int i = 0;
		 i < fromLayer.getNumberOfMaps();
		 i++) {
			 for (int j = 0;
			 j < toLayer.getNumberOfMaps();
			 j++) {
				 FeatureMapLayer fromMap = fromLayer.getFeatureMap(i);
				 FeatureMapLayer toMap = toLayer.getFeatureMap(j);
				 toLayer.connectMaps(fromMap, toMap);
			 }
		 }
	 }
	 else if (toLayer instanceof PoolingLayer) {
		 for (int i = 0;
		 i < toLayer.getNumberOfMaps();
		 i++) {
			 FeatureMapLayer fromMap = fromLayer.getFeatureMap(i);
			 FeatureMapLayer toMap = toLayer.getFeatureMap(i);
			 toLayer.connectMaps(fromMap, toMap);
		 }
	 }
 }",0,0,0,0
"private void parseQuotedValue(byte prev) throws IOException {
	 final byte newLine = this.newLine;
	 final byte delimiter = this.delimiter;
	 final TextOutput output = this.output;
	 final TextInput input = this.input;
	 final byte quote = this.quote;
	 ch = input.nextCharNoNewLineCheck();
	 while (!(prev == quote && (ch == delimiter || ch == newLine || isWhite(ch)))) {
		 if (ch != quote) {
			 if (prev == quote) {
				 if (parseUnescapedQuotes) {
					 output.append(quote);
					 output.append(ch);
					 parseQuotedValue(ch);
					 break;
				 }
				 else {
					 throw new TextParsingException( context, ""Unescaped quote character '"" + quote + ""' inside quoted value of CSV field. To allow unescaped quotes, set 'parseUnescapedQuotes' to 'true' in the CSV parser settings. Cannot parse CSV input."");
				 }
			 }
			 output.append(ch);
			 prev = ch;
		 }
		 else if (prev == quoteEscape) {
			 output.append(quote);
			 prev = NULL_BYTE;
		 }
		 else {
			 prev = ch;
		 }
		 ch = input.nextCharNoNewLineCheck();
	 }
	 if (ch != newLine && ch <= ' ' && ch != delimiter) {
		 final DrillBuf workBuf = this.workBuf;
		 workBuf.resetWriterIndex();
		 do {
			 workBuf.writeByte(ch);
			 ch = input.nextChar();
			 if (ch == newLine) {
				 return;
			 }
		 }
		 while (ch <= ' ' && ch != delimiter);
		 if (!(ch == delimiter || ch == newLine) && parseUnescapedQuotes) {
			 output.append(quote);
			 for(int i =0;
			 i < workBuf.writerIndex();
			 i++){
				 output.append(workBuf.getByte(i));
			 }
			 if (ch != quoteEscape) {
				 output.append(ch);
			 }
			 parseQuotedValue(ch);
		 }
	 }
	 if (!(ch == delimiter || ch == newLine)) {
		 throw new TextParsingException(context, ""Unexpected character '"" + ch + ""' following quoted value of CSV field. Expecting '"" + delimiter + ""'. Cannot parse CSV input."");
	 }
 }",0,0,1,0
"public final class StringList extends AbstractStringList{
	private static final long serialVersionUID = 1L;
	private final List<String> strings;
	private int totalLength;
	public static StringList repeat(final int count, final String string){
		final StringList list = new StringList(count);
		for (int i = 0;
		 i < count;
		 i++){
			list.add(string);
		}
		return list;
	}
	public static StringList tokenize(final String string){
		return tokenize(string, "", "");
	}
	public static StringList tokenize(final String string, final String delimiters){
		final StringTokenizer tokenizer = new StringTokenizer(string, delimiters);
		final StringList strings = new StringList();
		while (tokenizer.hasMoreTokens()){
			strings.add(tokenizer.nextToken());
		}
		return strings;
	}
	public static StringList valueOf(final Collection<?> collection){
		if (collection != null){
			final StringList strings = new StringList(collection.size());
			for (Object object : collection){
				strings.add(StringValue.valueOf(object));
			}
			return strings;
		}
		else{
			return new StringList();
		}
	}
	public static StringList valueOf(final Object[] objects){
		int length = (objects == null) ? 0 : objects.length;
		final StringList strings = new StringList(length);
		for (int i = 0;
		 i < length;
		 i++){
			strings.add(StringValue.valueOf(objects[i]));
		}
		return strings;
	}
	public static StringList valueOf(final String string){
		final StringList strings = new StringList();
		if (string != null){
			strings.add(string);
		}
		return strings;
	}
	public static StringList valueOf(final String[] array){
		int length = (array == null) ? 0 : array.length;
		final StringList strings = new StringList(length);
		for (int i = 0;
		 i < length;
		 i++){
			strings.add(array[i]);
		}
		return strings;
	}
	public StringList(){
		strings = new ArrayList<String>();
	}
	public StringList(final int size){
		strings = new ArrayList<String>(size);
	}
	public void add(final String string){
		add(size(), string);
	}
	public void add(final int pos, final String string){
		strings.add(pos, string == null ? """" : string);
		totalLength += string == null ? 0 : string.length();
	}
	public void add(final StringValue value){
		add(value.toString());
	}
	public boolean contains(final String string){
		return strings.contains(string);
	}
	public String get(final int index){
		return strings.get(index);
	}
	public List<String> getList(){
		return strings;
	}
	public IStringIterator iterator(){
		return new IStringIterator(){
			private final Iterator<String> iterator = strings.iterator();
			public boolean hasNext(){
				return iterator.hasNext();
			}
			public String next(){
				return iterator.next();
			}
		}
		;
	}
	public void prepend(final String string){
		add(0, string);
	}
	public void remove(final int index){
		String string = strings.remove(index);
		totalLength = totalLength - string.length();
	}
	public void removeLast(){
		remove(size() - 1);
	}
	public int size(){
		return strings.size();
	}
	public void sort(){
		Collections.sort(strings);
	}
	public String[] toArray(){
		return strings.toArray(new String[size()]);
	}
	public int totalLength(){
		return totalLength;
	}
}",0,0,0,0
"public class MailChimpServiceImpl implements MailChimpService {
	 private static Logger logger = LoggerFactory.getLogger(MailChimpServiceImpl.class);
	 private static final String ACCEPT = ""Accept"";
	 private static final String AUTHORIZATION = ""Authorization"";
	 private static final String LISTS = ""lists"";
	 private static final String ID = ""id"";
	 private static final String NAME = ""name"";
	 private static final String MERGE_FIELDS = ""merge_fields"";
	 private static final String EMAIL_TYPE = ""email_type"";
	 private static final String EMAIL_ADDRESS = ""email_address"";
	 private static final String EMAIL = ""email"";
	 private static final String ERRORS = ""errors"";
	 private static final String LIST_IDENTIFIER = ""listIdentifier"";
	 private static final String STATUS = ""status"";
	 private static final String SUBSCRIBED = ""subscribed"";
	 private static final String UNSUBSCRIBED = ""unsubscribed"";
	 private static final String TAG = ""tag"";
	 private static final String TYPE = ""type"";
	 private static final String UNOMI_ID = ""unomiId"";
	 private static final String MC_SUB_TAG_NAME = ""mcSubTagName"";
	 private static final String ADDR_1 = ""addr1"";
	 private static final String ADDR_2 = ""addr2"";
	 private static final String CITY = ""city"";
	 private static final String COUNTRY = ""country"";
	 private static final String STATE = ""state"";
	 private static final String ZIP = ""zip"";
	 private static final String ADDRESS = ""address"";
	 private static final String DATE_FORMAT = ""date_format"";
	 private static final String OPTIONS = ""options"";
	 private static final String DATE = ""date"";
	 private static final String MC_MM_DD_YYYY = ""MM/DD/YYYY"";
	 private static final String MM_DD_YYYY = ""MM/dd/yyyy"";
	 private static final String DD_MM_YYYY = ""dd/MM/yyyy"";
	 private static final String BIRTHDAY = ""birthday"";
	 private static final String MC_MM_DD = ""MM/DD"";
	 private static final String MM_DD = ""MM/dd"";
	 private static final String DD_MM = ""dd/MM"";
	 private static final String SEPARATOR_CHARS_PROPERTIES = "","";
	 private static final String SEPARATOR_CHARS_PROPERTY = ""<=>"";
	 private String apiKey;
	 private String urlSubDomain;
	 private Map<String, List<Map<String, String>>> listMergeFieldMapping;
	 private Boolean isMergeFieldsActivate;
	 private CloseableHttpClient httpClient;
	 public List<HashMap<String, String>> getAllLists() {
		 List<HashMap<String, String>> mcLists = new ArrayList<>();
		 if (isMailChimpConnectorConfigured()) {
			 JsonNode response = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + ""/lists"", getHeaders(), false);
			 if (response != null) {
				 if (response.has(LISTS) && response.get(LISTS).size() > 0) {
					 for (JsonNode list : response.get(LISTS)) {
						 if (list.has(ID) && list.has(NAME)) {
							 HashMap<String, String> mcListInfo = new HashMap<>();
							 mcListInfo.put(ID, list.get(ID).asText());
							 mcListInfo.put(NAME, list.get(NAME).asText());
							 mcLists.add(mcListInfo);
						 }
						 else {
							 logger.warn(""Missing mandatory information for list, {
							}
							"", list.asText());
						 }
					 }
				 }
				 else {
					 logger.debug(""No list to return, response was {
					}
					"", response.asText());
				 }
			 }
		 }
		 return mcLists;
	 }
	 public MailChimpResult addToMCList(Profile profile, Action action) {
		 if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {
			 logger.error(""The visitor does not have an email address"");
			 return MailChimpResult.ERROR;
		 }
		 String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);
		 JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);
		 JSONObject mergeFields = new JSONObject();
		 if (currentMember != null && currentMember.has(STATUS)) {
			 JSONObject body = new JSONObject();
			 if (currentMember.get(STATUS).asText().equals(UNSUBSCRIBED)) {
				 logger.debug(""The visitor is already in the MailChimp list, his status is unsubscribed"");
				 body.put(STATUS, SUBSCRIBED);
			 }
			 if (isMergeFieldsActivate && addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields) == MailChimpResult.SUCCESS) {
				 body.put(MERGE_FIELDS, mergeFields);
			 }
			 return updateSubscription(listIdentifier, body.toString(), currentMember, true);
		 }
		 JSONObject userData = new JSONObject();
		 userData.put(EMAIL_TYPE, ""html"");
		 userData.put(EMAIL_ADDRESS, profile.getProperty(EMAIL).toString());
		 userData.put(STATUS, SUBSCRIBED);
		 if (isMergeFieldsActivate) {
			 addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields);
		 }
		 userData.put(MERGE_FIELDS, mergeFields);
		 JsonNode response = HttpUtils.executePostRequest(httpClient, getBaseUrl() + ""/lists/"" + listIdentifier + ""/members"", getHeaders(), userData.toString());
		 if (response == null || (response.has(ERRORS) && response.get(ERRORS).size() > 0)) {
			 logger.error(""Error when adding user to MailChimp list, list identifier was {
			}
			 and response was {
			}
			"", listIdentifier, response);
			 return MailChimpResult.ERROR;
		 }
		 return MailChimpResult.UPDATED;
	 }
	 public MailChimpResult removeFromMCList(Profile profile, Action action) {
		 if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {
			 return MailChimpResult.ERROR;
		 }
		 String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);
		 if (StringUtils.isBlank(listIdentifier)) {
			 logger.warn(""Couldn't get the list identifier from Unomi"");
			 return MailChimpResult.ERROR;
		 }
		 JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);
		 if (currentMember == null) {
			 return MailChimpResult.NO_CHANGE;
		 }
		 JsonNode response = HttpUtils.executeDeleteRequest(httpClient, getBaseUrl() + ""/lists/"" + listIdentifier + ""/members/"" + currentMember.get(ID).asText(), getHeaders());
		 if (response == null || (response.has(ERRORS) && response.get(ERRORS).size() > 0)) {
			 logger.error(""Couldn't remove the visitor from the MailChimp list, list identifier was {
			}
			 and response was {
			}
			"", listIdentifier, response);
			 return MailChimpResult.ERROR;
		 }
		 return MailChimpResult.REMOVED;
	 }
	 public MailChimpResult unsubscribeFromMCList(Profile profile, Action action) {
		 if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {
			 return MailChimpResult.ERROR;
		 }
		 String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);
		 if (StringUtils.isBlank(listIdentifier)) {
			 logger.warn(""Couldn't get the list identifier from Unomi"");
			 return MailChimpResult.ERROR;
		 }
		 JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);
		 if (currentMember == null) {
			 return MailChimpResult.REMOVED;
		 }
		 if (currentMember.get(STATUS).asText().equals(UNSUBSCRIBED)) {
			 return MailChimpResult.NO_CHANGE;
		 }
		 JSONObject body = new JSONObject();
		 body.put(STATUS, UNSUBSCRIBED);
		 return updateSubscription(listIdentifier, body.toString(), currentMember, false);
	 }
	 public MailChimpResult updateMCProfileProperties(Profile profile, Action action) {
		 if (!isMailChimpConnectorConfigured() || profile.getProperty(EMAIL) == null) {
			 return MailChimpResult.ERROR;
		 }
		 String listIdentifier = (String) action.getParameterValues().get(LIST_IDENTIFIER);
		 if (StringUtils.isBlank(listIdentifier)) {
			 logger.warn(""MailChimp list identifier not found"");
			 return MailChimpResult.ERROR;
		 }
		 JsonNode currentMember = isMemberOfMailChimpList(profile, listIdentifier);
		 if (currentMember == null) {
			 logger.warn(""The visitor was not part of the list"");
			 return MailChimpResult.NO_CHANGE;
		 }
		 JSONObject mergeFields = new JSONObject();
		 MailChimpResult result = addProfilePropertiesToMergeFieldsObject(profile, listIdentifier, mergeFields);
		 if (result != MailChimpResult.SUCCESS) {
			 return result;
		 }
		 JSONObject body = new JSONObject();
		 body.put(MERGE_FIELDS, mergeFields);
		 JsonNode response = HttpUtils.executePatchRequest(httpClient, getBaseUrl() + ""/lists/"" + listIdentifier + ""/members/"" + currentMember.get(ID).asText(), getHeaders(), body.toString());
		 if (response == null || (response.has(ERRORS) && response.get(ERRORS).size() > 0)) {
			 logger.error(""Error when updating visitor properties to MailChimp list, list identifier was {
			}
			 and response was {
			}
			"", listIdentifier, response);
			 return MailChimpResult.ERROR;
		 }
		 return MailChimpResult.UPDATED;
	 }
	 private MailChimpResult addProfilePropertiesToMergeFieldsObject(Profile profile, String listIdentifier, JSONObject mergeFields) {
		 if (listMergeFieldMapping.isEmpty()) {
			 logger.error(""List of merge fields is not correctly configured"");
			 return MailChimpResult.ERROR;
		 }
		 JsonNode mergeFieldsDefinitions = getMCListProperties(listIdentifier);
		 if (mergeFieldsDefinitions == null) {
			 logger.error(""Could not get MailChimp list's merge fields"");
			 return MailChimpResult.ERROR;
		 }
		 for (JsonNode mergeFieldDefinition : mergeFieldsDefinitions.get(MERGE_FIELDS)) {
			 if (mergeFieldDefinition.has(TAG) && mergeFieldDefinition.has(TYPE)) {
				 String mcTagName = mergeFieldDefinition.get(TAG).asText();
				 if (listMergeFieldMapping.containsKey(mcTagName)) {
					 List<Map<String, String>> fields = listMergeFieldMapping.get(mcTagName);
					 for (Map<String, String> fieldInfo : fields) {
						 String unomiId = fieldInfo.get(UNOMI_ID);
						 if (profile.getProperty(unomiId) != null) {
							 switch (mergeFieldDefinition.get(TYPE).asText()) {
								 case ADDRESS: if (mergeFields.has(mcTagName)) {
									 mergeFields.getJSONObject(mcTagName).put(fieldInfo.get(MC_SUB_TAG_NAME), profile.getProperty(unomiId));
								 }
								 else {
									 JSONObject address = new JSONObject();
									 address.put(ADDR_1, """");
									 address.put(ADDR_2, """");
									 address.put(CITY, """");
									 address.put(COUNTRY, """");
									 address.put(STATE, """");
									 address.put(ZIP, """");
									 address.put(fieldInfo.get(MC_SUB_TAG_NAME), profile.getProperty(unomiId));
									 mergeFields.put(mcTagName, address);
								 }
								 break;
								 case DATE: if (mergeFieldDefinition.has(OPTIONS) && mergeFieldDefinition.get(OPTIONS).has(DATE_FORMAT)) {
									 mergeFields.put(mcTagName, formatDate(mergeFieldDefinition.get(OPTIONS).get(DATE_FORMAT).asText(), profile.getProperty(unomiId)));
								 }
								 break;
								 case BIRTHDAY: if (mergeFieldDefinition.has(OPTIONS) && mergeFieldDefinition.get(OPTIONS).has(DATE_FORMAT)) {
									 mergeFields.put(mcTagName, formatDate(mergeFieldDefinition.get(OPTIONS).get(DATE_FORMAT).asText(), profile.getProperty(unomiId)));
								 }
								 break;
								 default: mergeFields.put(mcTagName, profile.getProperty(unomiId));
								 break;
							 }
						 }
					 }
					 if (mergeFieldDefinition.get(TYPE).asText().equals(ADDRESS) && mergeFields.has(mcTagName) && (StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(ADDR_1).toString()) || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(ZIP).toString()) || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(CITY).toString()) || StringUtils.isBlank(mergeFields.getJSONObject(mcTagName).get(COUNTRY).toString()))) {
						 mergeFields.remove(mcTagName);
						 logger.debug(""Can't map the address property {
						}
						, one of the mandatory field is missing (addr1, zip, city, country)"", mcTagName);
					 }
				 }
				 else {
					 logger.debug(""Found property {
					}
					 in MC list, if you need this property please update mapping or add the property to your MC list"", mcTagName);
				 }
			 }
		 }
		 return MailChimpResult.SUCCESS;
	 }
	 private String formatDate(String mcDateFormat, Object date) {
		 DateTime dateTime = new DateTime(date);
		 if (StringUtils.contains(mcDateFormat, ""/YYYY"")) {
			 return DateTimeFormat.forPattern((mcDateFormat.equals(MC_MM_DD_YYYY) ? MM_DD_YYYY : DD_MM_YYYY)).print(dateTime);
		 }
		 else {
			 return DateTimeFormat.forPattern((mcDateFormat.equals(MC_MM_DD) ? MM_DD : DD_MM)).print(dateTime);
		 }
	 }
	 private JsonNode getMCListProperties(String listIdentifier) {
		 JsonNode currentMergeFields = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + ""/lists/"" + listIdentifier + ""/merge-fields"", getHeaders(), false);
		 if (currentMergeFields == null || !currentMergeFields.has(MERGE_FIELDS)) {
			 logger.error(""Can't find merge_fields from the response, the response was {
			}
			"", currentMergeFields);
			 return null;
		 }
		 return currentMergeFields;
	 }
	 private void initHttpClient() {
		 if (httpClient == null) {
			 httpClient = HttpUtils.initHttpClient();
		 }
	 }
	 private boolean isMailChimpConnectorConfigured() {
		 if (StringUtils.isNotBlank(apiKey) && StringUtils.isNotBlank(urlSubDomain)) {
			 initHttpClient();
			 return true;
		 }
		 logger.error(""MailChimp extension isn't correctly configured, please check cfg file."");
		 return false;
	 }
	 private JsonNode isMemberOfMailChimpList(Profile profile, String listIdentifier) {
		 String email = profile.getProperty(EMAIL).toString().toLowerCase();
		 String md5Hex = DigestUtils.md5Hex(email);
		 JsonNode response = HttpUtils.executeGetRequest(httpClient, getBaseUrl() + ""/lists/"" + listIdentifier + ""/members/"" + md5Hex, getHeaders(), true);
		 if (response != null) {
			 if (response.has(EMAIL_ADDRESS)) {
				 if (response.get(EMAIL_ADDRESS).asText().toLowerCase().equals(email)) {
					 return response;
				 }
			 }
		 }
		 return null;
	 }
	 private MailChimpResult updateSubscription(String listIdentifier, String jsonData, JsonNode member, boolean toSubscribe) {
		 JsonNode response = HttpUtils.executePatchRequest(httpClient, getBaseUrl() + ""/lists/"" + listIdentifier + ""/members/"" + member.get(ID).asText(), getHeaders(), jsonData);
		 if (response != null) {
			 if (response.has(STATUS)) {
				 String responseStatus = response.get(STATUS).asText();
				 if ((toSubscribe && responseStatus.equals(SUBSCRIBED)) || (!toSubscribe && responseStatus.equals(UNSUBSCRIBED))) {
					 return MailChimpResult.UPDATED;
				 }
				 else {
					 return MailChimpResult.NO_CHANGE;
				 }
			 }
		 }
		 logger.error(""Couldn't update the subscription of the visitor"");
		 return MailChimpResult.ERROR;
	 }
	 private String getBaseUrl() {
	 return ""https: }
	 private HashMap<String, String> getHeaders() {
		 HashMap<String, String> headers = new HashMap<>();
		 headers.put(ACCEPT, ""application/json"");
		 headers.put(AUTHORIZATION, ""apikey "" + apiKey);
		 return headers;
	 }
	 public void setApiKey(String apiKey) {
		 this.apiKey = apiKey;
	 }
	 public void setUrlSubDomain(String urlSubDomain) {
		 this.urlSubDomain = urlSubDomain;
	 }
	 public void setListMergeFieldMapping(String listMergeFields) {
		 this.listMergeFieldMapping = new HashMap<>();
		 if (StringUtils.isNotBlank(listMergeFields)) {
			 String mergeFields[] = StringUtils.split(listMergeFields, SEPARATOR_CHARS_PROPERTIES);
			 if (mergeFields.length > 0) {
				 for (String mergeField : mergeFields) {
					 if (StringUtils.isNotBlank(mergeField)) {
						 String mergeFieldInfo[] = StringUtils.split(mergeField, SEPARATOR_CHARS_PROPERTY);
						 if (mergeFieldInfo.length > 0) {
							 Map<String, String> fieldInfo = new HashMap<>();
							 fieldInfo.put(UNOMI_ID, mergeFieldInfo[0]);
							 if (mergeFieldInfo.length == 3) {
								 fieldInfo.put(MC_SUB_TAG_NAME, mergeFieldInfo[2]);
							 }
							 String mcTagName = mergeFieldInfo[1];
							 if (listMergeFieldMapping.containsKey(mcTagName)) {
								 listMergeFieldMapping.get(mcTagName).add(fieldInfo);
							 }
							 else {
								 List<Map<String, String>> fields = new ArrayList<>();
								 fields.add(fieldInfo);
								 listMergeFieldMapping.put(mcTagName, fields);
							 }
						 }
					 }
				 }
			 }
		 }
	 }
	 public void setIsMergeFieldsActivate(Boolean isMergeFieldsActivate) {
		 this.isMergeFieldsActivate = isMergeFieldsActivate;
	 }
}",1,1,0,0
"public class LazyOutputFormat <K,V> extends FilterOutputFormat<K, V> {
	 public static String OUTPUT_FORMAT = ""mapreduce.output.lazyoutputformat.outputformat"";
	 public static void setOutputFormatClass(Job job, Class<? extends OutputFormat> theClass) {
		 job.setOutputFormatClass(LazyOutputFormat.class);
		 job.getConfiguration().setClass(OUTPUT_FORMAT, theClass, OutputFormat.class);
	 }
	 private void getBaseOutputFormat(Configuration conf) throws IOException {
		 baseOut = ((OutputFormat<K, V>) ReflectionUtils.newInstance( conf.getClass(OUTPUT_FORMAT, null), conf));
		 if (baseOut == null) {
			 throw new IOException(""Output Format not set for LazyOutputFormat"");
		 }
	 }
	 public RecordWriter<K, V> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException {
		 if (baseOut == null) {
			 getBaseOutputFormat(context.getConfiguration());
		 }
		 return new LazyRecordWriter<K, V>(baseOut, context);
	 }
	 public void checkOutputSpecs(JobContext context) throws IOException, InterruptedException {
		 if (baseOut == null) {
			 getBaseOutputFormat(context.getConfiguration());
		 }
		 super.checkOutputSpecs(context);
	 }
	 public OutputCommitter getOutputCommitter(TaskAttemptContext context) throws IOException, InterruptedException {
		 if (baseOut == null) {
			 getBaseOutputFormat(context.getConfiguration());
		 }
		 return super.getOutputCommitter(context);
	 }
	 private static class LazyRecordWriter<K,V> extends FilterRecordWriter<K,V> {
		 final OutputFormat<K,V> outputFormat;
		 final TaskAttemptContext taskContext;
		 public LazyRecordWriter(OutputFormat<K,V> out, TaskAttemptContext taskContext) throws IOException, InterruptedException {
			 this.outputFormat = out;
			 this.taskContext = taskContext;
		 }
		 public void write(K key, V value) throws IOException, InterruptedException {
			 if (rawWriter == null) {
				 rawWriter = outputFormat.getRecordWriter(taskContext);
			 }
			 rawWriter.write(key, value);
		 }
		 public void close(TaskAttemptContext context) throws IOException, InterruptedException {
			 if (rawWriter != null) {
				 rawWriter.close(context);
			 }
		 }
	 }
}",0,0,0,0
"public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
	 XMLSecurityPropertyManager spm = (XMLSecurityPropertyManager)componentManager.getProperty(XML_SECURITY_PROPERTY_MANAGER);
	 if (spm == null) {
		 spm = new XMLSecurityPropertyManager();
		 setProperty(XML_SECURITY_PROPERTY_MANAGER, spm);
	 }
	 XMLSecurityManager sm = (XMLSecurityManager)componentManager.getProperty(SECURITY_MANAGER);
	 if (sm == null) setProperty(SECURITY_MANAGER,new XMLSecurityManager(true));
	 faccessExternalSchema = spm.getValue(XMLSecurityPropertyManager.Property.ACCESS_EXTERNAL_SCHEMA);
	 fGrammarBucket.reset();
	 fSubGroupHandler.reset();
	 boolean parser_settings = true;
	 if (componentManager != fLoaderConfig) {
		 parser_settings = componentManager.getFeature(PARSER_SETTINGS, true);
	 }
	 if (!parser_settings || !fSettingsChanged){
		 fJAXPProcessed = false;
		 initGrammarBucket();
		 if (fDeclPool != null) {
			 fDeclPool.reset();
		 }
		 return;
	 }
	 fNodeFactory.reset(componentManager);
	 fEntityManager = (XMLEntityManager)componentManager.getProperty(ENTITY_MANAGER);
	 fErrorReporter = (XMLErrorReporter)componentManager.getProperty(ERROR_REPORTER);
	 SchemaDVFactory dvFactory = null;
	 dvFactory = fSchemaHandler.getDVFactory();
	 if (dvFactory == null) {
		 dvFactory = SchemaDVFactory.getInstance();
		 fSchemaHandler.setDVFactory(dvFactory);
	 }
	 try {
		 fExternalSchemas = (String) componentManager.getProperty(SCHEMA_LOCATION);
		 fExternalNoNSSchema = (String) componentManager.getProperty(SCHEMA_NONS_LOCATION);
	 }
	 catch (XMLConfigurationException e) {
		 fExternalSchemas = null;
		 fExternalNoNSSchema = null;
	 }
	 fJAXPSource = componentManager.getProperty(JAXP_SCHEMA_SOURCE, null);
	 fJAXPProcessed = false;
	 fGrammarPool = (XMLGrammarPool) componentManager.getProperty(XMLGRAMMAR_POOL, null);
	 initGrammarBucket();
	 boolean psvi = componentManager.getFeature(AUGMENT_PSVI, false);
	 if (!psvi && fGrammarPool == null && false) {
		 if (fDeclPool != null) {
			 fDeclPool.reset();
		 }
		 else {
			 fDeclPool = new XSDeclarationPool();
		 }
		 fCMBuilder.setDeclPool(fDeclPool);
		 fSchemaHandler.setDeclPool(fDeclPool);
		 if (dvFactory instanceof SchemaDVFactoryImpl) {
			 fDeclPool.setDVFactory((SchemaDVFactoryImpl)dvFactory);
			 ((SchemaDVFactoryImpl)dvFactory).setDeclPool(fDeclPool);
		 }
	 }
	 else {
		 fCMBuilder.setDeclPool(null);
		 fSchemaHandler.setDeclPool(null);
		 if (dvFactory instanceof SchemaDVFactoryImpl) {
			 ((SchemaDVFactoryImpl)dvFactory).setDeclPool(null);
		 }
	 }
	 try {
		 boolean fatalError = componentManager.getFeature(CONTINUE_AFTER_FATAL_ERROR, false);
		 if (!fatalError) {
			 fErrorReporter.setFeature(CONTINUE_AFTER_FATAL_ERROR, fatalError);
		 }
	 }
	 catch (XMLConfigurationException e) {
	 }
	 fIsCheckedFully = componentManager.getFeature(SCHEMA_FULL_CHECKING, false);
	 fSchemaHandler.setGenerateSyntheticAnnotations(componentManager.getFeature(GENERATE_SYNTHETIC_ANNOTATIONS, false));
	 fSchemaHandler.reset(componentManager);
 }",0,0,1,0
"public final class JavaAdapter implements IdFunctionCall{
	 static class JavaAdapterSignature {
		 Class superClass;
		 Class[] interfaces;
		 ObjToIntMap names;
		 JavaAdapterSignature(Class superClass, Class[] interfaces, ObjToIntMap names) {
			 this.superClass = superClass;
			 this.interfaces = interfaces;
			 this.names = names;
			;
		 }
		 public boolean equals(Object obj) {
			 if (!(obj instanceof JavaAdapterSignature)) return false;
			 JavaAdapterSignature sig = (JavaAdapterSignature) obj;
			 if (superClass != sig.superClass) return false;
			 if (interfaces != sig.interfaces) {
				 if (interfaces.length != sig.interfaces.length) return false;
				 for (int i=0;
				 i < interfaces.length;
				 i++) if (interfaces[i] != sig.interfaces[i]) return false;
			 }
			 if (names.size() != sig.names.size()) return false;
			 ObjToIntMap.Iterator iter = new ObjToIntMap.Iterator(names);
			 for (iter.start();
			 !iter.done();
			 iter.next()) {
				 String name = (String)iter.getKey();
				 int arity = iter.getValue();
				 if (arity != names.get(name, arity + 1)) return false;
			 }
			 return true;
		 }
		 public int hashCode() {
			 return superClass.hashCode() | (0x9e3779b9 * (names.size() | (interfaces.length << 16)));
		 }
	 }
	 public static void init(Context cx, Scriptable scope, boolean sealed) {
		 JavaAdapter obj = new JavaAdapter();
		 IdFunctionObject ctor = new IdFunctionObject(obj, FTAG, Id_JavaAdapter, ""JavaAdapter"", 1, scope);
		 ctor.markAsConstructor(null);
		 if (sealed) {
			 ctor.sealObject();
		 }
		 ctor.exportAsScopeProperty();
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (f.hasTag(FTAG)) {
			 if (f.methodId() == Id_JavaAdapter) {
				 return js_createAdpter(cx, scope, args);
			 }
		 }
		 throw f.unknown();
	 }
	 public static Object convertResult(Object result, Class c) {
		 if (result == Undefined.instance && (c != ScriptRuntime.ObjectClass && c != ScriptRuntime.StringClass)) {
			 return null;
		 }
		 return Context.jsToJava(result, c);
	 }
	 public static Scriptable createAdapterWrapper(Scriptable obj, Object adapter) {
		 Scriptable scope = ScriptableObject.getTopLevelScope(obj);
		 NativeJavaObject res = new NativeJavaObject(scope, adapter, null);
		 res.setPrototype(obj);
		 return res;
	 }
	 public static Object getAdapterSelf(Class adapterClass, Object adapter) throws NoSuchFieldException, IllegalAccessException {
		 Field self = adapterClass.getDeclaredField(""self"");
		 return self.get(adapter);
	 }
	 static Object js_createAdpter(Context cx, Scriptable scope, Object[] args) {
		 int N = args.length;
		 if (N == 0) {
			 throw ScriptRuntime.typeError0(""msg.adapter.zero.args"");
		 }
		 Class superClass = null;
		 Class[] intfs = new Class[N - 1];
		 int interfaceCount = 0;
		 for (int i = 0;
		 i != N - 1;
		 ++i) {
			 Object arg = args[i];
			 if (!(arg instanceof NativeJavaClass)) {
				 throw ScriptRuntime.typeError2(""msg.not.java.class.arg"", String.valueOf(i), ScriptRuntime.toString(arg));
			 }
			 Class c = ((NativeJavaClass) arg).getClassObject();
			 if (!c.isInterface()) {
				 if (superClass != null) {
					 throw ScriptRuntime.typeError2(""msg.only.one.super"", superClass.getName(), c.getName());
				 }
				 superClass = c;
			 }
			 else {
				 intfs[interfaceCount++] = c;
			 }
		 }
		 if (superClass == null) superClass = ScriptRuntime.ObjectClass;
		 Class[] interfaces = new Class[interfaceCount];
		 System.arraycopy(intfs, 0, interfaces, 0, interfaceCount);
		 Scriptable obj = ScriptRuntime.toObject(cx, scope, args[N - 1]);
		 Class adapterClass = getAdapterClass(scope, superClass, interfaces, obj);
		 Class[] ctorParms = {
		 ScriptRuntime.ContextFactoryClass, ScriptRuntime.ScriptableClass }
		;
		 Object[] ctorArgs = {
		 cx.getFactory(), obj }
		;
		 try {
			 Object adapter = adapterClass.getConstructor(ctorParms). newInstance(ctorArgs);
			 return getAdapterSelf(adapterClass, adapter);
		 }
		 catch (Exception ex) {
			 throw Context.throwAsScriptRuntimeEx(ex);
		 }
	 }
	 public static void writeAdapterObject(Object javaObject, ObjectOutputStream out) throws IOException {
		 Class cl = javaObject.getClass();
		 out.writeObject(cl.getSuperclass().getName());
		 Class[] interfaces = cl.getInterfaces();
		 String[] interfaceNames = new String[interfaces.length];
		 for (int i=0;
		 i < interfaces.length;
		 i++) interfaceNames[i] = interfaces[i].getName();
		 out.writeObject(interfaceNames);
		 try {
			 Object delegee = cl.getField(""delegee"").get(javaObject);
			 out.writeObject(delegee);
			 return;
		 }
		 catch (IllegalAccessException e) {
		 }
		 catch (NoSuchFieldException e) {
		 }
		 throw new IOException();
	 }
	 public static Object readAdapterObject(Scriptable self, ObjectInputStream in) throws IOException, ClassNotFoundException {
		 ContextFactory factory;
		 Context cx = Context.getCurrentContext();
		 if (cx != null) {
			 factory = cx.getFactory();
		 }
		 else {
			 factory = null;
		 }
		 Class superClass = Class.forName((String)in.readObject());
		 String[] interfaceNames = (String[])in.readObject();
		 Class[] interfaces = new Class[interfaceNames.length];
		 for (int i=0;
		 i < interfaceNames.length;
		 i++) interfaces[i] = Class.forName(interfaceNames[i]);
		 Scriptable delegee = (Scriptable)in.readObject();
		 Class adapterClass = getAdapterClass(self, superClass, interfaces, delegee);
		 Class[] ctorParms = {
		 ScriptRuntime.ContextFactoryClass, ScriptRuntime.ScriptableClass, ScriptRuntime.ScriptableClass }
		;
		 Object[] ctorArgs = {
		 factory, delegee, self }
		;
		 try {
			 return adapterClass.getConstructor(ctorParms).newInstance(ctorArgs);
		 }
		 catch(InstantiationException e) {
		 }
		 catch(IllegalAccessException e) {
		 }
		 catch(InvocationTargetException e) {
		 }
		 catch(NoSuchMethodException e) {
		 }
		 throw new ClassNotFoundException(""adapter"");
	 }
	 private static ObjToIntMap getObjectFunctionNames(Scriptable obj) {
		 Object[] ids = ScriptableObject.getPropertyIds(obj);
		 ObjToIntMap map = new ObjToIntMap(ids.length);
		 for (int i = 0;
		 i != ids.length;
		 ++i) {
			 if (!(ids[i] instanceof String)) continue;
			 String id = (String) ids[i];
			 Object value = ScriptableObject.getProperty(obj, id);
			 if (value instanceof Function) {
				 Function f = (Function)value;
				 int length = ScriptRuntime.toInt32( ScriptableObject.getProperty(f, ""length""));
				 if (length < 0) {
					 length = 0;
				 }
				 map.put(id, length);
			 }
		 }
		 return map;
	 }
	 private static Class getAdapterClass(Scriptable scope, Class superClass, Class[] interfaces, Scriptable obj) {
		 ClassCache cache = ClassCache.get(scope);
		 Hashtable generated = cache.javaAdapterGeneratedClasses;
		 ObjToIntMap names = getObjectFunctionNames(obj);
		 JavaAdapterSignature sig;
		 sig = new JavaAdapterSignature(superClass, interfaces, names);
		 Class adapterClass = (Class) generated.get(sig);
		 if (adapterClass == null) {
			 String adapterName = ""adapter"" + cache.newClassSerialNumber();
			 byte[] code = createAdapterCode(names, adapterName, superClass, interfaces, null);
			 adapterClass = loadAdapterClass(adapterName, code);
			 if (cache.isCachingEnabled()) {
				 generated.put(sig, adapterClass);
			 }
		 }
		 return adapterClass;
	 }
	 public static byte[] createAdapterCode(ObjToIntMap functionNames, String adapterName, Class superClass, Class[] interfaces, String scriptClassName) {
		 ClassFileWriter cfw = new ClassFileWriter(adapterName, superClass.getName(), ""<adapter>"");
		 cfw.addField(""factory"", ""Lorg/mozilla/javascript/ContextFactory;
		"", (short) (ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_FINAL));
		 cfw.addField(""delegee"", ""Lorg/mozilla/javascript/Scriptable;
		"", (short) (ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_FINAL));
		 cfw.addField(""self"", ""Lorg/mozilla/javascript/Scriptable;
		"", (short) (ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_FINAL));
		 int interfacesCount = interfaces == null ? 0 : interfaces.length;
		 for (int i=0;
		 i < interfacesCount;
		 i++) {
			 if (interfaces[i] != null) cfw.addInterface(interfaces[i].getName());
		 }
		 String superName = superClass.getName().replace('.', '/');
		 generateCtor(cfw, adapterName, superName);
		 generateSerialCtor(cfw, adapterName, superName);
		 if (scriptClassName != null) generateEmptyCtor(cfw, adapterName, superName, scriptClassName);
		 ObjToIntMap generatedOverrides = new ObjToIntMap();
		 ObjToIntMap generatedMethods = new ObjToIntMap();
		 for (int i = 0;
		 i < interfacesCount;
		 i++) {
			 Method[] methods = interfaces[i].getMethods();
			 for (int j = 0;
			 j < methods.length;
			 j++) {
				 Method method = methods[j];
				 int mods = method.getModifiers();
				 if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) {
					 continue;
				 }
				 String methodName = method.getName();
				 Class[] argTypes = method.getParameterTypes();
				 if (!functionNames.has(methodName)) {
					 try {
						 superClass.getMethod(methodName, argTypes);
						 continue;
					 }
					 catch (NoSuchMethodException e) {
					 }
				 }
				 String methodSignature = getMethodSignature(method, argTypes);
				 String methodKey = methodName + methodSignature;
				 if (! generatedOverrides.has(methodKey)) {
					 generateMethod(cfw, adapterName, methodName, argTypes, method.getReturnType());
					 generatedOverrides.put(methodKey, 0);
					 generatedMethods.put(methodName, 0);
				 }
			 }
		 }
		 Method[] methods = superClass.getMethods();
		 for (int j = 0;
		 j < methods.length;
		 j++) {
			 Method method = methods[j];
			 int mods = method.getModifiers();
			 if (Modifier.isStatic(mods) || Modifier.isFinal(mods)) continue;
			 boolean isAbstractMethod = Modifier.isAbstract(mods);
			 String methodName = method.getName();
			 if (isAbstractMethod || functionNames.has(methodName)) {
				 Class[] argTypes = method.getParameterTypes();
				 String methodSignature = getMethodSignature(method, argTypes);
				 String methodKey = methodName + methodSignature;
				 if (! generatedOverrides.has(methodKey)) {
					 generateMethod(cfw, adapterName, methodName, argTypes, method.getReturnType());
					 generatedOverrides.put(methodKey, 0);
					 generatedMethods.put(methodName, 0);
				 }
				 if (!isAbstractMethod) {
					 generateSuper(cfw, adapterName, superName, methodName, methodSignature, argTypes, method.getReturnType());
				 }
			 }
		 }
		 ObjToIntMap.Iterator iter = new ObjToIntMap.Iterator(functionNames);
		 for (iter.start();
		 !iter.done();
		 iter.next()) {
			 String functionName = (String)iter.getKey();
			 if (generatedMethods.has(functionName)) continue;
			 int length = iter.getValue();
			 Class[] parms = new Class[length];
			 for (int k=0;
			 k < length;
			 k++) parms[k] = ScriptRuntime.ObjectClass;
			 generateMethod(cfw, adapterName, functionName, parms, ScriptRuntime.ObjectClass);
		 }
		 return cfw.toByteArray();
	 }
	 static Class loadAdapterClass(String className, byte[] classBytes) {
		 GeneratedClassLoader loader = SecurityController.createLoader(null, null);
		 Class result = loader.defineClass(className, classBytes);
		 loader.linkClass(result);
		 return result;
	 }
	 public static Function getFunction(Scriptable obj, String functionName) {
		 Object x = ScriptableObject.getProperty(obj, functionName);
		 if (x == Scriptable.NOT_FOUND) {
			 return null;
		 }
		 if (!(x instanceof Function)) throw ScriptRuntime.notFunctionError(x, functionName);
		 return (Function)x;
	 }
	 public static Object callMethod(ContextFactory factory, final Scriptable thisObj, final Function f, final Object[] args, final long argsToWrap) {
		 if (f == null) {
			 return Undefined.instance;
		 }
		 if (factory == null) {
			 factory = ContextFactory.getGlobal();
		 }
		 final Scriptable scope = f.getParentScope();
		 if (argsToWrap == 0) {
			 return Context.call(factory, f, scope, thisObj, args);
		 }
		 Context cx = Context.getCurrentContext();
		 if (cx != null) {
			 return doCall(cx, scope, thisObj, f, args, argsToWrap);
		 }
		 else {
			 return factory.call(new ContextAction() {
				 public Object run(Context cx) {
					 return doCall(cx, scope, thisObj, f, args, argsToWrap);
				 }
			 }
			);
		 }
	 }
	 private static Object doCall(Context cx, Scriptable scope, Scriptable thisObj, Function f, Object[] args, long argsToWrap) {
		 for (int i = 0;
		 i != args.length;
		 ++i) {
			 if (0 != (argsToWrap & (1 << i))) {
				 Object arg = args[i];
				 if (!(arg instanceof Scriptable)) {
					 args[i] = cx.getWrapFactory().wrap(cx, scope, arg, null);
				 }
			 }
		 }
		 return f.call(cx, scope, thisObj, args);
	 }
	 public static Scriptable runScript(final Script script) {
		 return (Scriptable)Context.call(new ContextAction() {
			 public Object run(Context cx) {
				 ScriptableObject global = ScriptRuntime.getGlobal(cx);
				 script.exec(cx, global);
				 return global;
			 }
		 }
		);
	 }
	 private static void generateCtor(ClassFileWriter cfw, String adapterName, String superName) {
		 cfw.startMethod(""<init>"", ""(Lorg/mozilla/javascript/ContextFactory;
		"" +""Lorg/mozilla/javascript/Scriptable;
		)V"", ClassFileWriter.ACC_PUBLIC);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, ""<init>"", ""()V"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_1);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""factory"", ""Lorg/mozilla/javascript/ContextFactory;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_2);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""delegee"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_2);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/JavaAdapter"", ""createAdapterWrapper"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/Object;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""self"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)3);
	 }
	 private static void generateSerialCtor(ClassFileWriter cfw, String adapterName, String superName) {
		 cfw.startMethod(""<init>"", ""(Lorg/mozilla/javascript/ContextFactory;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")V"", ClassFileWriter.ACC_PUBLIC);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, ""<init>"", ""()V"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_1);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""factory"", ""Lorg/mozilla/javascript/ContextFactory;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_2);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""delegee"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_3);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""self"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)4);
	 }
	 private static void generateEmptyCtor(ClassFileWriter cfw, String adapterName, String superName, String scriptClassName) {
		 cfw.startMethod(""<init>"", ""()V"", ClassFileWriter.ACC_PUBLIC);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, ""<init>"", ""()V"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ACONST_NULL);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""factory"", ""Lorg/mozilla/javascript/ContextFactory;
		"");
		 cfw.add(ByteCode.NEW, scriptClassName);
		 cfw.add(ByteCode.DUP);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, scriptClassName, ""<init>"", ""()V"");
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/JavaAdapter"", ""runScript"", ""(Lorg/mozilla/javascript/Script;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.ASTORE_1);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_1);
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""delegee"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.ALOAD_1);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/JavaAdapter"", ""createAdapterWrapper"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/Object;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.PUTFIELD, adapterName, ""self"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)2);
	 }
	 static void generatePushWrappedArgs(ClassFileWriter cfw, Class[] argTypes, int arrayLength) {
		 cfw.addPush(arrayLength);
		 cfw.add(ByteCode.ANEWARRAY, ""java/lang/Object"");
		 int paramOffset = 1;
		 for (int i = 0;
		 i != argTypes.length;
		 ++i) {
			 cfw.add(ByteCode.DUP);
			 cfw.addPush(i);
			 paramOffset += generateWrapArg(cfw, paramOffset, argTypes[i]);
			 cfw.add(ByteCode.AASTORE);
		 }
	 }
	 private static int generateWrapArg(ClassFileWriter cfw, int paramOffset, Class argType) {
		 int size = 1;
		 if (!argType.isPrimitive()) {
			 cfw.add(ByteCode.ALOAD, paramOffset);
		 }
		 else if (argType == Boolean.TYPE) {
			 cfw.add(ByteCode.NEW, ""java/lang/Boolean"");
			 cfw.add(ByteCode.DUP);
			 cfw.add(ByteCode.ILOAD, paramOffset);
			 cfw.addInvoke(ByteCode.INVOKESPECIAL, ""java/lang/Boolean"", ""<init>"", ""(Z)V"");
		 }
		 else if (argType == Character.TYPE) {
			 cfw.add(ByteCode.ILOAD, paramOffset);
			 cfw.addInvoke(ByteCode.INVOKESTATIC, ""java/lang/String"", ""valueOf"", ""(C)Ljava/lang/String;
			"");
		 }
		 else {
			 cfw.add(ByteCode.NEW, ""java/lang/Double"");
			 cfw.add(ByteCode.DUP);
			 String typeName = argType.getName();
			 switch (typeName.charAt(0)) {
				 case 'b': case 's': case 'i': cfw.add(ByteCode.ILOAD, paramOffset);
				 cfw.add(ByteCode.I2D);
				 break;
				 case 'l': cfw.add(ByteCode.LLOAD, paramOffset);
				 cfw.add(ByteCode.L2D);
				 size = 2;
				 break;
				 case 'f': cfw.add(ByteCode.FLOAD, paramOffset);
				 cfw.add(ByteCode.F2D);
				 break;
				 case 'd': cfw.add(ByteCode.DLOAD, paramOffset);
				 size = 2;
				 break;
			 }
			 cfw.addInvoke(ByteCode.INVOKESPECIAL, ""java/lang/Double"", ""<init>"", ""(D)V"");
		 }
		 return size;
	 }
	 static void generateReturnResult(ClassFileWriter cfw, Class retType, boolean callConvertResult) {
		 if (retType == Void.TYPE) {
			 cfw.add(ByteCode.POP);
			 cfw.add(ByteCode.RETURN);
		 }
		 else if (retType == Boolean.TYPE) {
			 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/Context"", ""toBoolean"", ""(Ljava/lang/Object;
			)Z"");
			 cfw.add(ByteCode.IRETURN);
		 }
		 else if (retType == Character.TYPE) {
			 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/Context"", ""toString"", ""(Ljava/lang/Object;
			)Ljava/lang/String;
			"");
			 cfw.add(ByteCode.ICONST_0);
			 cfw.addInvoke(ByteCode.INVOKEVIRTUAL, ""java/lang/String"", ""charAt"", ""(I)C"");
			 cfw.add(ByteCode.IRETURN);
		 }
		 else if (retType.isPrimitive()) {
			 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/Context"", ""toNumber"", ""(Ljava/lang/Object;
			)D"");
			 String typeName = retType.getName();
			 switch (typeName.charAt(0)) {
				 case 'b': case 's': case 'i': cfw.add(ByteCode.D2I);
				 cfw.add(ByteCode.IRETURN);
				 break;
				 case 'l': cfw.add(ByteCode.D2L);
				 cfw.add(ByteCode.LRETURN);
				 break;
				 case 'f': cfw.add(ByteCode.D2F);
				 cfw.add(ByteCode.FRETURN);
				 break;
				 case 'd': cfw.add(ByteCode.DRETURN);
				 break;
				 default: throw new RuntimeException(""Unexpected return type "" + retType.toString());
			 }
		 }
		 else {
			 String retTypeStr = retType.getName();
			 if (callConvertResult) {
				 cfw.addLoadConstant(retTypeStr);
				 cfw.addInvoke(ByteCode.INVOKESTATIC, ""java/lang/Class"", ""forName"", ""(Ljava/lang/String;
				)Ljava/lang/Class;
				"");
				 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/JavaAdapter"", ""convertResult"", ""(Ljava/lang/Object;
				"" +""Ljava/lang/Class;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 cfw.add(ByteCode.CHECKCAST, retTypeStr);
			 cfw.add(ByteCode.ARETURN);
		 }
	 }
	 private static void generateMethod(ClassFileWriter cfw, String genName, String methodName, Class[] parms, Class returnType) {
		 StringBuffer sb = new StringBuffer();
		 int paramsEnd = appendMethodSignature(parms, returnType, sb);
		 String methodSignature = sb.toString();
		 cfw.startMethod(methodName, methodSignature, ClassFileWriter.ACC_PUBLIC);
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.GETFIELD, genName, ""factory"", ""Lorg/mozilla/javascript/ContextFactory;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.GETFIELD, genName, ""self"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.add(ByteCode.GETFIELD, genName, ""delegee"", ""Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.addPush(methodName);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/JavaAdapter"", ""getFunction"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/String;
		"" +"")Lorg/mozilla/javascript/Function;
		"");
		 generatePushWrappedArgs(cfw, parms, parms.length);
		 if (parms.length > 64) {
			 throw Context.reportRuntimeError0( ""JavaAdapter can not subclass methods with more then"" +"" 64 arguments."");
		 }
		 long convertionMask = 0;
		 for (int i = 0;
		 i != parms.length;
		 ++i) {
			 if (!parms[i].isPrimitive()) {
				 convertionMask |= (1 << i);
			 }
		 }
		 cfw.addPush(convertionMask);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/JavaAdapter"", ""callMethod"", ""(Lorg/mozilla/javascript/ContextFactory;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Lorg/mozilla/javascript/Function;
		"" +""[Ljava/lang/Object;
		"" +""J"" +"")Ljava/lang/Object;
		"");
		 generateReturnResult(cfw, returnType, true);
		 cfw.stopMethod((short)paramsEnd);
	 }
	 private static int generatePushParam(ClassFileWriter cfw, int paramOffset, Class paramType) {
		 if (!paramType.isPrimitive()) {
			 cfw.addALoad(paramOffset);
			 return 1;
		 }
		 String typeName = paramType.getName();
		 switch (typeName.charAt(0)) {
			 case 'z': case 'b': case 'c': case 's': case 'i': cfw.addILoad(paramOffset);
			 return 1;
			 case 'l': cfw.addLLoad(paramOffset);
			 return 2;
			 case 'f': cfw.addFLoad(paramOffset);
			 return 1;
			 case 'd': cfw.addDLoad(paramOffset);
			 return 2;
		 }
		 throw Kit.codeBug();
	 }
	 private static void generatePopResult(ClassFileWriter cfw, Class retType) {
		 if (retType.isPrimitive()) {
			 String typeName = retType.getName();
			 switch (typeName.charAt(0)) {
				 case 'b': case 'c': case 's': case 'i': case 'z': cfw.add(ByteCode.IRETURN);
				 break;
				 case 'l': cfw.add(ByteCode.LRETURN);
				 break;
				 case 'f': cfw.add(ByteCode.FRETURN);
				 break;
				 case 'd': cfw.add(ByteCode.DRETURN);
				 break;
			 }
		 }
		 else {
			 cfw.add(ByteCode.ARETURN);
		 }
	 }
	 private static void generateSuper(ClassFileWriter cfw, String genName, String superName, String methodName, String methodSignature, Class[] parms, Class returnType) {
		 cfw.startMethod(""super$"" + methodName, methodSignature, ClassFileWriter.ACC_PUBLIC);
		 cfw.add(ByteCode.ALOAD, 0);
		 int paramOffset = 1;
		 for (int i = 0;
		 i < parms.length;
		 i++) {
			 paramOffset += generatePushParam(cfw, paramOffset, parms[i]);
		 }
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, superName, methodName, methodSignature);
		 Class retType = returnType;
		 if (!retType.equals(Void.TYPE)) {
			 generatePopResult(cfw, retType);
		 }
		 else {
			 cfw.add(ByteCode.RETURN);
		 }
		 cfw.stopMethod((short)(paramOffset + 1));
	 }
	 private static String getMethodSignature(Method method, Class[] argTypes) {
		 StringBuffer sb = new StringBuffer();
		 appendMethodSignature(argTypes, method.getReturnType(), sb);
		 return sb.toString();
	 }
	 static int appendMethodSignature(Class[] argTypes, Class returnType, StringBuffer sb) {
		 sb.append('(');
		 int firstLocal = 1 + argTypes.length;
		 for (int i = 0;
		 i < argTypes.length;
		 i++) {
			 Class type = argTypes[i];
			 appendTypeString(sb, type);
			 if (type == Long.TYPE || type == Double.TYPE) {
				 ++firstLocal;
			 }
		 }
		 sb.append(')');
		 appendTypeString(sb, returnType);
		 return firstLocal;
	 }
	 private static StringBuffer appendTypeString(StringBuffer sb, Class type) {
		 while (type.isArray()) {
			 sb.append('[');
			 type = type.getComponentType();
		 }
		 if (type.isPrimitive()) {
			 char typeLetter;
			 if (type == Boolean.TYPE) {
				 typeLetter = 'Z';
			 }
			 else if (type == Long.TYPE) {
				 typeLetter = 'J';
			 }
			 else {
				 String typeName = type.getName();
				 typeLetter = Character.toUpperCase(typeName.charAt(0));
			 }
			 sb.append(typeLetter);
		 }
		 else {
			 sb.append('L');
			 sb.append(type.getName().replace('.', '/'));
			 sb.append(';
			');
		 }
		 return sb;
	 }
	 static int[] getArgsToConvert(Class[] argTypes) {
		 int count = 0;
		 for (int i = 0;
		 i != argTypes.length;
		 ++i) {
			 if (!argTypes[i].isPrimitive()) ++count;
		 }
		 if (count == 0) return null;
		 int[] array = new int[count];
		 count = 0;
		 for (int i = 0;
		 i != argTypes.length;
		 ++i) {
			 if (!argTypes[i].isPrimitive()) array[count++] = i;
		 }
		 return array;
	 }
	 private static final Object FTAG = new Object();
	 private static final int Id_JavaAdapter = 1;
}",0,0,0,0
"public static class Builder {
	 private com.oracle.bmc.util.internal.Consumer<javax.ws.rs.client.Invocation.Builder> invocationCallback = null;
	 public Builder invocationCallback( com.oracle.bmc.util.internal.Consumer<javax.ws.rs.client.Invocation.Builder> invocationCallback) {
		 this.invocationCallback = invocationCallback;
		 return this;
	 }
	 public Builder copy(GetInstanceRequest o) {
		 instanceId(o.getInstanceId());
		 invocationCallback(o.getInvocationCallback());
		 return this;
	 }
	 public GetInstanceRequest build() {
		 GetInstanceRequest request = buildWithoutInvocationCallback();
		 request.setInvocationCallback(invocationCallback);
		 return request;
	 }
 }",0,0,0,0
"public class ServiceBinderImpl implements ServiceBinder, ServiceBindingOptions{
	 private final OneShotLock lock = new OneShotLock();
	 private final Method bindMethod;
	 private final ServiceDefAccumulator accumulator;
	 private PlasticProxyFactory proxyFactory;
	 private final Set<Class> defaultMarkers;
	 private final boolean moduleDefaultPreventDecoration;
	 public ServiceBinderImpl(ServiceDefAccumulator accumulator, Method bindMethod, PlasticProxyFactory proxyFactory, Set<Class> defaultMarkers, boolean moduleDefaultPreventDecoration) {
		 this.accumulator = accumulator;
		 this.bindMethod = bindMethod;
		 this.proxyFactory = proxyFactory;
		 this.defaultMarkers = defaultMarkers;
		 this.moduleDefaultPreventDecoration = moduleDefaultPreventDecoration;
		 clear();
	 }
	 private String serviceId;
	 private Class serviceInterface;
	 private Class serviceImplementation;
	 private final Set<Class> markers = CollectionFactory.newSet();
	 private ObjectCreatorSource source;
	 private boolean eagerLoad;
	 private String scope;
	 private boolean preventDecoration;
	 private boolean preventReloading;
	 public void finish() {
		 lock.lock();
		 flush();
	 }
	 protected void flush() {
		 if (serviceInterface == null) return;
		 if (source == null) source = createObjectCreatorSourceFromImplementationClass();
		 Set<Class> markers = CollectionFactory.newSet(defaultMarkers);
		 markers.addAll(this.markers);
		 ServiceDef serviceDef = new ServiceDefImpl(serviceInterface, serviceImplementation, serviceId, markers, scope, eagerLoad, preventDecoration, source);
		 accumulator.addServiceDef(serviceDef);
		 clear();
	 }
	 private void clear() {
		 serviceId = null;
		 serviceInterface = null;
		 serviceImplementation = null;
		 source = null;
		 this.markers.clear();
		 eagerLoad = false;
		 scope = null;
		 preventDecoration = moduleDefaultPreventDecoration;
		 preventReloading = false;
	 }
	 private ObjectCreatorSource createObjectCreatorSourceFromImplementationClass() {
		 if (InternalUtils.SERVICE_CLASS_RELOADING_ENABLED && !preventReloading && isProxiable() && reloadableScope() && InternalUtils.isLocalFile(serviceImplementation)) return createReloadableConstructorBasedObjectCreatorSource();
		 return createStandardConstructorBasedObjectCreatorSource();
	 }
	 private boolean isProxiable() {
		 return serviceInterface.isInterface();
	 }
	 private boolean reloadableScope() {
		 return scope.equalsIgnoreCase(ScopeConstants.DEFAULT);
	 }
	 private ObjectCreatorSource createStandardConstructorBasedObjectCreatorSource() {
		 if (Modifier.isAbstract(serviceImplementation.getModifiers())) throw new RuntimeException(IOCMessages.abstractServiceImplementation(serviceImplementation, serviceId));
		 final Constructor constructor = InternalUtils.findAutobuildConstructor(serviceImplementation);
		 if (constructor == null) throw new RuntimeException(IOCMessages.noConstructor(serviceImplementation, serviceId));
		 return new ObjectCreatorSource() {
			 public ObjectCreator constructCreator(ServiceBuilderResources resources) {
				 return new ConstructorServiceCreator(resources, getDescription(), constructor);
			 }
			 public String getDescription() {
				 return String.format(""%s via %s"", proxyFactory.getConstructorLocation(constructor), proxyFactory.getMethodLocation(bindMethod));
			 }
		 }
		;
	 }
	 private ObjectCreatorSource createReloadableConstructorBasedObjectCreatorSource() {
		 return new ReloadableObjectCreatorSource(proxyFactory, bindMethod, serviceInterface, serviceImplementation, eagerLoad);
	 }
	 public <T> ServiceBindingOptions bind(Class<T> serviceClass) {
		 if (serviceClass.isInterface()) {
			 try {
				 String expectedImplName = serviceClass.getName() + ""Impl"";
				 ClassLoader classLoader = proxyFactory.getClassLoader();
				 Class<T> implementationClass = (Class<T>) classLoader.loadClass(expectedImplName);
				 if (!implementationClass.isInterface() && serviceClass.isAssignableFrom(implementationClass)) {
					 return bind( serviceClass, implementationClass);
				 }
				 throw new RuntimeException(IOCMessages.noServiceMatchesType(serviceClass));
			 }
			 catch (ClassNotFoundException ex) {
				 throw new RuntimeException(String.format(""Could not find default implementation class %sImpl. Please provide this class, or bind the service interface to a specific implementation class."", serviceClass.getName()));
			 }
		 }
		 return bind(serviceClass, serviceClass);
	 }
	 public <T> ServiceBindingOptions bind(Class<T> serviceInterface, final ServiceBuilder<T> builder) {
		 assert serviceInterface != null;
		 assert builder != null;
		 lock.check();
		 flush();
		 this.serviceInterface = serviceInterface;
		 this.scope = ScopeConstants.DEFAULT;
		 serviceId = serviceInterface.getSimpleName();
		 this.source = new ObjectCreatorSource() {
			 public ObjectCreator constructCreator(final ServiceBuilderResources resources) {
				 return new ObjectCreator() {
					 public Object createObject() {
						 return builder.buildService(resources);
					 }
				 }
				;
			 }
			 public String getDescription() {
				 return proxyFactory.getMethodLocation(bindMethod).toString();
			 }
		 }
		;
		 return this;
	 }
	 public <T> ServiceBindingOptions bind(Class<T> serviceInterface, Class<? extends T> serviceImplementation) {
		 assert serviceInterface != null;
		 assert serviceImplementation != null;
		 lock.check();
		 flush();
		 this.serviceInterface = serviceInterface;
		 this.serviceImplementation = serviceImplementation;
		 eagerLoad = serviceImplementation.getAnnotation(EagerLoad.class) != null;
		 serviceId = InternalUtils.getServiceId(serviceImplementation);
		 if (serviceId == null) {
			 serviceId = serviceInterface.getSimpleName();
		 }
		 Scope scope = serviceImplementation.getAnnotation(Scope.class);
		 this.scope = scope != null ? scope.value() : ScopeConstants.DEFAULT;
		 Marker marker = serviceImplementation.getAnnotation(Marker.class);
		 if (marker != null) {
			 InternalUtils.validateMarkerAnnotations(marker.value());
			 markers.addAll(Arrays.asList(marker.value()));
		 }
		 preventDecoration |= serviceImplementation.getAnnotation(PreventServiceDecoration.class) != null;
		 return this;
	 }
	 public ServiceBindingOptions eagerLoad() {
		 lock.check();
		 eagerLoad = true;
		 return this;
	 }
	 public ServiceBindingOptions preventDecoration() {
		 lock.check();
		 preventDecoration = true;
		 return this;
	 }
	 public ServiceBindingOptions preventReloading() {
		 lock.check();
		 preventReloading = true;
		 return this;
	 }
	 public ServiceBindingOptions withId(String id) {
		 assert InternalUtils.isNonBlank(id);
		 lock.check();
		 serviceId = id;
		 return this;
	 }
	 public ServiceBindingOptions withSimpleId() {
		 if (serviceImplementation == null) {
			 throw new IllegalArgumentException(""No defined implementation class to generate simple id from."");
		 }
		 return withId(serviceImplementation.getSimpleName());
	 }
	 public ServiceBindingOptions scope(String scope) {
		 assert InternalUtils.isNonBlank(scope);
		 lock.check();
		 this.scope = scope;
		 return this;
	 }
	 public ServiceBindingOptions withMarker(Class<? extends Annotation>... marker) {
		 lock.check();
		 InternalUtils.validateMarkerAnnotations(marker);
		 markers.addAll(Arrays.asList(marker));
		 return this;
	 }
}",0,0,0,0
"public class WebappClassLoader extends URLClassLoader implements Lifecycle {
	 private static final org.apache.juli.logging.Log log= org.apache.juli.logging.LogFactory.getLog( WebappClassLoader.class );
	 private static final List<String> JVM_THREAD_GROUP_NAMES = new ArrayList<String>();
	 static {
		 JVM_THREAD_GROUP_NAMES.add(""system"");
		 JVM_THREAD_GROUP_NAMES.add(""RMI Runtime"");
	 }
	 protected class PrivilegedFindResourceByName implements PrivilegedAction<ResourceEntry> {
		 protected String name;
		 protected String path;
		 PrivilegedFindResourceByName(String name, String path) {
			 this.name = name;
			 this.path = path;
		 }
		 public ResourceEntry run() {
			 return findResourceInternal(name, path);
		 }
	 }
	 protected final class PrivilegedGetClassLoader implements PrivilegedAction<ClassLoader> {
		 public Class<?> clazz;
		 public PrivilegedGetClassLoader(Class<?> clazz){
			 this.clazz = clazz;
		 }
		 public ClassLoader run() {
			 return clazz.getClassLoader();
		 }
	 }
	 protected static final String[] triggers = {
	 ""javax.servlet.Servlet"" }
	;
	 protected static final String[] packageTriggers = {
	 }
	;
	 protected static final StringManager sm = StringManager.getManager(Constants.Package);
	 boolean antiJARLocking = false;
	 public WebappClassLoader() {
		 super(new URL[0]);
		 this.parent = getParent();
		 system = getSystemClassLoader();
		 securityManager = System.getSecurityManager();
		 if (securityManager != null) {
			 refreshPolicy();
		 }
	 }
	 public WebappClassLoader(ClassLoader parent) {
		 super(new URL[0], parent);
		 this.parent = getParent();
		 system = getSystemClassLoader();
		 securityManager = System.getSecurityManager();
		 if (securityManager != null) {
			 refreshPolicy();
		 }
	 }
	 protected DirContext resources = null;
	 protected HashMap<String, ResourceEntry> resourceEntries = new HashMap<String, ResourceEntry>();
	 protected HashMap<String, String> notFoundResources = new LinkedHashMap<String, String>() {
		 private static final long serialVersionUID = 1L;
		 protected boolean removeEldestEntry( Map.Entry<String, String> eldest) {
			 return size() > 1000;
		 }
	 }
	;
	 protected boolean delegate = false;
	 protected long lastJarAccessed = 0L;
	 protected String[] repositories = new String[0];
	 protected URL[] repositoryURLs = null;
	 protected File[] files = new File[0];
	 protected JarFile[] jarFiles = new JarFile[0];
	 protected File[] jarRealFiles = new File[0];
	 protected String jarPath = null;
	 protected String[] jarNames = new String[0];
	 protected long[] lastModifiedDates = new long[0];
	 protected String[] paths = new String[0];
	 protected ArrayList<Permission> permissionList = new ArrayList<Permission>();
	 protected File loaderDir = null;
	 protected String canonicalLoaderDir = null;
	 protected HashMap<String, PermissionCollection> loaderPC = new HashMap<String, PermissionCollection>();
	 protected SecurityManager securityManager = null;
	 protected ClassLoader parent = null;
	 protected ClassLoader system = null;
	 protected boolean started = false;
	 protected boolean hasExternalRepositories = false;
	 protected boolean searchExternalFirst = false;
	 protected boolean needConvert = false;
	 protected Permission allPermission = new java.security.AllPermission();
	 private boolean clearReferencesStatic = false;
	 private boolean clearReferencesStopThreads = false;
	 private boolean clearReferencesStopTimerThreads = false;
	 private boolean clearReferencesThreadLocals = false;
	 private boolean clearReferencesLogFactoryRelease = true;
	 private String contextName = ""unknown"";
	 public DirContext getResources() {
		 return this.resources;
	 }
	 public void setResources(DirContext resources) {
		 this.resources = resources;
		 if (resources instanceof ProxyDirContext) {
			 contextName = ((ProxyDirContext) resources).getContextName();
		 }
	 }
	 public String getContextName() {
		 return (this.contextName);
	 }
	 public boolean getDelegate() {
		 return (this.delegate);
	 }
	 public void setDelegate(boolean delegate) {
		 this.delegate = delegate;
	 }
	 public boolean getAntiJARLocking() {
		 return antiJARLocking;
	 }
	 public void setAntiJARLocking(boolean antiJARLocking) {
		 this.antiJARLocking = antiJARLocking;
	 }
	 public boolean getSearchExternalFirst() {
		 return searchExternalFirst;
	 }
	 public void setSearchExternalFirst(boolean searchExternalFirst) {
		 this.searchExternalFirst = searchExternalFirst;
	 }
	 public void addPermission(String path) {
		 if (path == null) {
			 return;
		 }
		 if (securityManager != null) {
			 Permission permission = null;
			 if( path.startsWith(""jndi:"") || path.startsWith(""jar:jndi:"") ) {
				 if (!path.endsWith(""/"")) {
					 path = path + ""/"";
				 }
				 permission = new JndiPermission(path + ""*"");
				 addPermission(permission);
			 }
			 else {
				 if (!path.endsWith(File.separator)) {
					 permission = new FilePermission(path, ""read"");
					 addPermission(permission);
					 path = path + File.separator;
				 }
				 permission = new FilePermission(path + ""-"", ""read"");
				 addPermission(permission);
			 }
		 }
	 }
	 public void addPermission(URL url) {
		 if (url != null) {
			 addPermission(url.toString());
		 }
	 }
	 public void addPermission(Permission permission) {
		 if ((securityManager != null) && (permission != null)) {
			 permissionList.add(permission);
		 }
	 }
	 public String getJarPath() {
		 return this.jarPath;
	 }
	 public void setJarPath(String jarPath) {
		 this.jarPath = jarPath;
	 }
	 public void setWorkDir(File workDir) {
		 this.loaderDir = new File(workDir, ""loader"");
		 if (loaderDir == null) {
			 canonicalLoaderDir = null;
		 }
		 else {
			 try {
				 canonicalLoaderDir = loaderDir.getCanonicalPath();
				 if (!canonicalLoaderDir.endsWith(File.separator)) {
					 canonicalLoaderDir += File.separator;
				 }
			 }
			 catch (IOException ioe) {
				 canonicalLoaderDir = null;
			 }
		 }
	 }
	 protected void setParentClassLoader(ClassLoader pcl) {
		 parent = pcl;
	 }
	 public boolean getClearReferencesStatic() {
		 return (this.clearReferencesStatic);
	 }
	 public void setClearReferencesStatic(boolean clearReferencesStatic) {
		 this.clearReferencesStatic = clearReferencesStatic;
	 }
	 public boolean getClearReferencesStopThreads() {
		 return (this.clearReferencesStopThreads);
	 }
	 public void setClearReferencesStopThreads( boolean clearReferencesStopThreads) {
		 this.clearReferencesStopThreads = clearReferencesStopThreads;
	 }
	 public boolean getClearReferencesStopTimerThreads() {
		 return (this.clearReferencesStopTimerThreads);
	 }
	 public void setClearReferencesStopTimerThreads( boolean clearReferencesStopTimerThreads) {
		 this.clearReferencesStopTimerThreads = clearReferencesStopTimerThreads;
	 }
	 public boolean getClearReferencesLogFactoryRelease() {
		 return (this.clearReferencesLogFactoryRelease);
	 }
	 public void setClearReferencesLogFactoryRelease( boolean clearReferencesLogFactoryRelease) {
		 this.clearReferencesLogFactoryRelease = clearReferencesLogFactoryRelease;
	 }
	 public boolean getClearReferencesThreadLocals() {
		 return (this.clearReferencesThreadLocals);
	 }
	 public void setClearReferencesThreadLocals( boolean clearReferencesThreadLocals) {
		 this.clearReferencesThreadLocals = clearReferencesThreadLocals;
	 }
	 public void addRepository(String repository) {
		 if (repository.startsWith(""/WEB-INF/lib"") || repository.startsWith(""/WEB-INF/classes"")) return;
		 try {
			 URL url = new URL(repository);
			 super.addURL(url);
			 hasExternalRepositories = true;
			 repositoryURLs = null;
		 }
		 catch (MalformedURLException e) {
			 IllegalArgumentException iae = new IllegalArgumentException (""Invalid repository: "" + repository);
			 iae.initCause(e);
			 throw iae;
		 }
	 }
	 synchronized void addRepository(String repository, File file) {
		 if (repository == null) return;
		 if (log.isDebugEnabled()) log.debug(""addRepository("" + repository + "")"");
		 int i;
		 String[] result = new String[repositories.length + 1];
		 for (i = 0;
		 i < repositories.length;
		 i++) {
			 result[i] = repositories[i];
		 }
		 result[repositories.length] = repository;
		 repositories = result;
		 File[] result2 = new File[files.length + 1];
		 for (i = 0;
		 i < files.length;
		 i++) {
			 result2[i] = files[i];
		 }
		 result2[files.length] = file;
		 files = result2;
	 }
	 synchronized void addJar(String jar, JarFile jarFile, File file) throws IOException {
		 if (jar == null) return;
		 if (jarFile == null) return;
		 if (file == null) return;
		 if (log.isDebugEnabled()) log.debug(""addJar("" + jar + "")"");
		 int i;
		 if ((jarPath != null) && (jar.startsWith(jarPath))) {
			 String jarName = jar.substring(jarPath.length());
			 while (jarName.startsWith(""/"")) jarName = jarName.substring(1);
			 String[] result = new String[jarNames.length + 1];
			 for (i = 0;
			 i < jarNames.length;
			 i++) {
				 result[i] = jarNames[i];
			 }
			 result[jarNames.length] = jarName;
			 jarNames = result;
		 }
		 try {
			 long lastModified = ((ResourceAttributes) resources.getAttributes(jar)) .getLastModified();
			 String[] result = new String[paths.length + 1];
			 for (i = 0;
			 i < paths.length;
			 i++) {
				 result[i] = paths[i];
			 }
			 result[paths.length] = jar;
			 paths = result;
			 long[] result3 = new long[lastModifiedDates.length + 1];
			 for (i = 0;
			 i < lastModifiedDates.length;
			 i++) {
				 result3[i] = lastModifiedDates[i];
			 }
			 result3[lastModifiedDates.length] = lastModified;
			 lastModifiedDates = result3;
		 }
		 catch (NamingException e) {
		 }
		 if (!validateJarFile(file)) return;
		 JarFile[] result2 = new JarFile[jarFiles.length + 1];
		 for (i = 0;
		 i < jarFiles.length;
		 i++) {
			 result2[i] = jarFiles[i];
		 }
		 result2[jarFiles.length] = jarFile;
		 jarFiles = result2;
		 File[] result4 = new File[jarRealFiles.length + 1];
		 for (i = 0;
		 i < jarRealFiles.length;
		 i++) {
			 result4[i] = jarRealFiles[i];
		 }
		 result4[jarRealFiles.length] = file;
		 jarRealFiles = result4;
	 }
	 public String[] findRepositories() {
		 return (repositories.clone());
	 }
	 public boolean modified() {
		 if (log.isDebugEnabled()) log.debug(""modified()"");
		 int length = paths.length;
		 int length2 = lastModifiedDates.length;
		 if (length > length2) length = length2;
		 for (int i = 0;
		 i < length;
		 i++) {
			 try {
				 long lastModified = ((ResourceAttributes) resources.getAttributes(paths[i])) .getLastModified();
				 if (lastModified != lastModifiedDates[i]) {
					 if( log.isDebugEnabled() ) log.debug("" Resource '"" + paths[i] + ""' was modified;
					 Date is now: "" + new java.util.Date(lastModified) + "" Was: "" + new java.util.Date(lastModifiedDates[i]));
					 return (true);
				 }
			 }
			 catch (NamingException e) {
				 log.error("" Resource '"" + paths[i] + ""' is missing"");
				 return (true);
			 }
		 }
		 length = jarNames.length;
		 if (getJarPath() != null) {
			 try {
				 NamingEnumeration<Binding> enumeration = resources.listBindings(getJarPath());
				 int i = 0;
				 while (enumeration.hasMoreElements() && (i < length)) {
					 NameClassPair ncPair = enumeration.nextElement();
					 String name = ncPair.getName();
					 if (!name.endsWith("".jar"")) continue;
					 if (!name.equals(jarNames[i])) {
						 log.info("" Additional JARs have been added : '"" + name + ""'"");
						 return (true);
					 }
					 i++;
				 }
				 if (enumeration.hasMoreElements()) {
					 while (enumeration.hasMoreElements()) {
						 NameClassPair ncPair = enumeration.nextElement();
						 String name = ncPair.getName();
						 if (name.endsWith("".jar"")) {
							 log.info("" Additional JARs have been added"");
							 return (true);
						 }
					 }
				 }
				 else if (i < jarNames.length) {
					 log.info("" Additional JARs have been added"");
					 return (true);
				 }
			 }
			 catch (NamingException e) {
				 if (log.isDebugEnabled()) log.debug("" Failed tracking modifications of '"" + getJarPath() + ""'"");
			 }
			 catch (ClassCastException e) {
				 log.error("" Failed tracking modifications of '"" + getJarPath() + ""' : "" + e.getMessage());
			 }
		 }
		 return (false);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder(""WebappClassLoader\r\n"");
		 sb.append("" context: "");
		 sb.append(contextName);
		 sb.append(""\r\n"");
		 sb.append("" delegate: "");
		 sb.append(delegate);
		 sb.append(""\r\n"");
		 sb.append("" repositories:\r\n"");
		 if (repositories != null) {
			 for (int i = 0;
			 i < repositories.length;
			 i++) {
				 sb.append("" "");
				 sb.append(repositories[i]);
				 sb.append(""\r\n"");
			 }
		 }
		 if (this.parent != null) {
			 sb.append(""----------> Parent Classloader:\r\n"");
			 sb.append(this.parent.toString());
			 sb.append(""\r\n"");
		 }
		 return (sb.toString());
	 }
	 protected void addURL(URL url) {
		 super.addURL(url);
		 hasExternalRepositories = true;
		 repositoryURLs = null;
	 }
	 public Class<?> findClass(String name) throws ClassNotFoundException {
		 if (log.isDebugEnabled()) log.debug("" findClass("" + name + "")"");
		 if (!started) {
			 throw new ClassNotFoundException(name);
		 }
		 if (securityManager != null) {
			 int i = name.lastIndexOf('.');
			 if (i >= 0) {
				 try {
					 if (log.isTraceEnabled()) log.trace("" securityManager.checkPackageDefinition"");
					 securityManager.checkPackageDefinition(name.substring(0,i));
				 }
				 catch (Exception se) {
					 if (log.isTraceEnabled()) log.trace("" -->Exception-->ClassNotFoundException"", se);
					 throw new ClassNotFoundException(name, se);
				 }
			 }
		 }
		 Class<?> clazz = null;
		 try {
			 if (log.isTraceEnabled()) log.trace("" findClassInternal("" + name + "")"");
			 if (hasExternalRepositories && searchExternalFirst) {
				 try {
					 clazz = super.findClass(name);
				 }
				 catch(ClassNotFoundException cnfe) {
				 }
				 catch(AccessControlException ace) {
					 log.warn(""WebappClassLoader.findClassInternal("" + name + "") security exception: "" + ace.getMessage(), ace);
					 throw new ClassNotFoundException(name, ace);
				 }
				 catch (RuntimeException e) {
					 if (log.isTraceEnabled()) log.trace("" -->RuntimeException Rethrown"", e);
					 throw e;
				 }
			 }
			 if ((clazz == null)) {
				 try {
					 clazz = findClassInternal(name);
				 }
				 catch(ClassNotFoundException cnfe) {
					 if (!hasExternalRepositories || searchExternalFirst) {
						 throw cnfe;
					 }
				 }
				 catch(AccessControlException ace) {
					 log.warn(""WebappClassLoader.findClassInternal("" + name + "") security exception: "" + ace.getMessage(), ace);
					 throw new ClassNotFoundException(name, ace);
				 }
				 catch (RuntimeException e) {
					 if (log.isTraceEnabled()) log.trace("" -->RuntimeException Rethrown"", e);
					 throw e;
				 }
			 }
			 if ((clazz == null) && hasExternalRepositories && !searchExternalFirst) {
				 try {
					 clazz = super.findClass(name);
				 }
				 catch(AccessControlException ace) {
					 log.warn(""WebappClassLoader.findClassInternal("" + name + "") security exception: "" + ace.getMessage(), ace);
					 throw new ClassNotFoundException(name, ace);
				 }
				 catch (RuntimeException e) {
					 if (log.isTraceEnabled()) log.trace("" -->RuntimeException Rethrown"", e);
					 throw e;
				 }
			 }
			 if (clazz == null) {
				 if (log.isDebugEnabled()) log.debug("" --> Returning ClassNotFoundException"");
				 throw new ClassNotFoundException(name);
			 }
		 }
		 catch (ClassNotFoundException e) {
			 if (log.isTraceEnabled()) log.trace("" --> Passing on ClassNotFoundException"");
			 throw e;
		 }
		 if (log.isTraceEnabled()) log.debug("" Returning class "" + clazz);
		 if (log.isTraceEnabled()) {
			 ClassLoader cl;
			 if (Globals.IS_SECURITY_ENABLED){
				 cl = AccessController.doPrivileged( new PrivilegedGetClassLoader(clazz));
			 }
			 else {
				 cl = clazz.getClassLoader();
			 }
			 log.debug("" Loaded by "" + cl.toString());
		 }
		 return (clazz);
	 }
	 public URL findResource(final String name) {
		 if (log.isDebugEnabled()) log.debug("" findResource("" + name + "")"");
		 URL url = null;
		 if (hasExternalRepositories && searchExternalFirst) url = super.findResource(name);
		 if (url == null) {
			 ResourceEntry entry = resourceEntries.get(name);
			 if (entry == null) {
				 if (securityManager != null) {
					 PrivilegedAction<ResourceEntry> dp = new PrivilegedFindResourceByName(name, name);
					 entry = AccessController.doPrivileged(dp);
				 }
				 else {
					 entry = findResourceInternal(name, name);
				 }
			 }
			 if (entry != null) {
				 url = entry.source;
			 }
		 }
		 if ((url == null) && hasExternalRepositories && !searchExternalFirst) url = super.findResource(name);
		 if (log.isDebugEnabled()) {
			 if (url != null) log.debug("" --> Returning '"" + url.toString() + ""'"");
			 else log.debug("" --> Resource not found, returning null"");
		 }
		 return (url);
	 }
	 public Enumeration<URL> findResources(String name) throws IOException {
		 if (log.isDebugEnabled()) log.debug("" findResources("" + name + "")"");
		 Vector<URL> result = new Vector<URL>();
		 int jarFilesLength = jarFiles.length;
		 int repositoriesLength = repositories.length;
		 int i;
		 if (hasExternalRepositories && searchExternalFirst) {
			 Enumeration<URL> otherResourcePaths = super.findResources(name);
			 while (otherResourcePaths.hasMoreElements()) {
				 result.addElement(otherResourcePaths.nextElement());
			 }
		 }
		 for (i = 0;
		 i < repositoriesLength;
		 i++) {
			 try {
				 String fullPath = repositories[i] + name;
				 resources.lookup(fullPath);
				 try {
					 result.addElement(getURI(new File(files[i], name)));
				 }
				 catch (MalformedURLException e) {
				 }
			 }
			 catch (NamingException e) {
			 }
		 }
		 synchronized (jarFiles) {
			 if (openJARs()) {
				 for (i = 0;
				 i < jarFilesLength;
				 i++) {
					 JarEntry jarEntry = jarFiles[i].getJarEntry(name);
					 if (jarEntry != null) {
						 try {
							 String jarFakeUrl = getURI(jarRealFiles[i]).toString();
							 jarFakeUrl = ""jar:"" + jarFakeUrl + ""!/"" + name;
							 result.addElement(new URL(jarFakeUrl));
						 }
						 catch (MalformedURLException e) {
						 }
					 }
				 }
			 }
		 }
		 if (hasExternalRepositories && !searchExternalFirst) {
			 Enumeration<URL> otherResourcePaths = super.findResources(name);
			 while (otherResourcePaths.hasMoreElements()) {
				 result.addElement(otherResourcePaths.nextElement());
			 }
		 }
		 return result.elements();
	 }
	 public URL getResource(String name) {
		 if (log.isDebugEnabled()) log.debug(""getResource("" + name + "")"");
		 URL url = null;
		 if (delegate) {
			 if (log.isDebugEnabled()) log.debug("" Delegating to parent classloader "" + parent);
			 ClassLoader loader = parent;
			 if (loader == null) loader = system;
			 url = loader.getResource(name);
			 if (url != null) {
				 if (log.isDebugEnabled()) log.debug("" --> Returning '"" + url.toString() + ""'"");
				 return (url);
			 }
		 }
		 url = findResource(name);
		 if (url != null) {
			 if (antiJARLocking) {
				 ResourceEntry entry = resourceEntries.get(name);
				 try {
					 String repository = entry.codeBase.toString();
					 if ((repository.endsWith("".jar"")) && (!(name.endsWith("".class"")))) {
						 File resourceFile = new File(loaderDir, name);
						 url = getURI(resourceFile);
					 }
				 }
				 catch (Exception e) {
				 }
			 }
			 if (log.isDebugEnabled()) log.debug("" --> Returning '"" + url.toString() + ""'"");
			 return (url);
		 }
		 if( !delegate ) {
			 ClassLoader loader = parent;
			 if (loader == null) loader = system;
			 url = loader.getResource(name);
			 if (url != null) {
				 if (log.isDebugEnabled()) log.debug("" --> Returning '"" + url.toString() + ""'"");
				 return (url);
			 }
		 }
		 if (log.isDebugEnabled()) log.debug("" --> Resource not found, returning null"");
		 return (null);
	 }
	 public InputStream getResourceAsStream(String name) {
		 if (log.isDebugEnabled()) log.debug(""getResourceAsStream("" + name + "")"");
		 InputStream stream = null;
		 stream = findLoadedResource(name);
		 if (stream != null) {
			 if (log.isDebugEnabled()) log.debug("" --> Returning stream from cache"");
			 return (stream);
		 }
		 if (delegate) {
			 if (log.isDebugEnabled()) log.debug("" Delegating to parent classloader "" + parent);
			 ClassLoader loader = parent;
			 if (loader == null) loader = system;
			 stream = loader.getResourceAsStream(name);
			 if (stream != null) {
				 if (log.isDebugEnabled()) log.debug("" --> Returning stream from parent"");
				 return (stream);
			 }
		 }
		 if (log.isDebugEnabled()) log.debug("" Searching local repositories"");
		 URL url = findResource(name);
		 if (url != null) {
			 if (log.isDebugEnabled()) log.debug("" --> Returning stream from local"");
			 stream = findLoadedResource(name);
			 try {
				 if (hasExternalRepositories && (stream == null)) stream = url.openStream();
			 }
			 catch (IOException e) {
			 }
			 if (stream != null) return (stream);
		 }
		 if (!delegate) {
			 if (log.isDebugEnabled()) log.debug("" Delegating to parent classloader unconditionally "" + parent);
			 ClassLoader loader = parent;
			 if (loader == null) loader = system;
			 stream = loader.getResourceAsStream(name);
			 if (stream != null) {
				 if (log.isDebugEnabled()) log.debug("" --> Returning stream from parent"");
				 return (stream);
			 }
		 }
		 if (log.isDebugEnabled()) log.debug("" --> Resource not found, returning null"");
		 return (null);
	 }
	 public Class<?> loadClass(String name) throws ClassNotFoundException {
		 return (loadClass(name, false));
	 }
	 public synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		 if (log.isDebugEnabled()) log.debug(""loadClass("" + name + "", "" + resolve + "")"");
		 Class<?> clazz = null;
		 if (!started) {
			 try {
				 throw new IllegalStateException();
			 }
			 catch (IllegalStateException e) {
				 log.info(sm.getString(""webappClassLoader.stopped"", name), e);
			 }
		 }
		 clazz = findLoadedClass0(name);
		 if (clazz != null) {
			 if (log.isDebugEnabled()) log.debug("" Returning class from cache"");
			 if (resolve) resolveClass(clazz);
			 return (clazz);
		 }
		 clazz = findLoadedClass(name);
		 if (clazz != null) {
			 if (log.isDebugEnabled()) log.debug("" Returning class from cache"");
			 if (resolve) resolveClass(clazz);
			 return (clazz);
		 }
		 try {
			 clazz = system.loadClass(name);
			 if (clazz != null) {
				 if (resolve) resolveClass(clazz);
				 return (clazz);
			 }
		 }
		 catch (ClassNotFoundException e) {
		 }
		 if (securityManager != null) {
			 int i = name.lastIndexOf('.');
			 if (i >= 0) {
				 try {
					 securityManager.checkPackageAccess(name.substring(0,i));
				 }
				 catch (SecurityException se) {
					 String error = ""Security Violation, attempt to use "" + ""Restricted Class: "" + name;
					 log.info(error, se);
					 throw new ClassNotFoundException(error, se);
				 }
			 }
		 }
		 boolean delegateLoad = delegate || filter(name);
		 if (delegateLoad) {
			 if (log.isDebugEnabled()) log.debug("" Delegating to parent classloader1 "" + parent);
			 ClassLoader loader = parent;
			 if (loader == null) loader = system;
			 try {
				 clazz = Class.forName(name, false, loader);
				 if (clazz != null) {
					 if (log.isDebugEnabled()) log.debug("" Loading class from parent"");
					 if (resolve) resolveClass(clazz);
					 return (clazz);
				 }
			 }
			 catch (ClassNotFoundException e) {
			 }
		 }
		 if (log.isDebugEnabled()) log.debug("" Searching local repositories"");
		 try {
			 clazz = findClass(name);
			 if (clazz != null) {
				 if (log.isDebugEnabled()) log.debug("" Loading class from local repository"");
				 if (resolve) resolveClass(clazz);
				 return (clazz);
			 }
		 }
		 catch (ClassNotFoundException e) {
		 }
		 if (!delegateLoad) {
			 if (log.isDebugEnabled()) log.debug("" Delegating to parent classloader at end: "" + parent);
			 ClassLoader loader = parent;
			 if (loader == null) loader = system;
			 try {
				 clazz = Class.forName(name, false, loader);
				 if (clazz != null) {
					 if (log.isDebugEnabled()) log.debug("" Loading class from parent"");
					 if (resolve) resolveClass(clazz);
					 return (clazz);
				 }
			 }
			 catch (ClassNotFoundException e) {
			 }
		 }
		 throw new ClassNotFoundException(name);
	 }
	 protected PermissionCollection getPermissions(CodeSource codeSource) {
		 String codeUrl = codeSource.getLocation().toString();
		 PermissionCollection pc;
		 if ((pc = loaderPC.get(codeUrl)) == null) {
			 pc = super.getPermissions(codeSource);
			 if (pc != null) {
				 Iterator<Permission> perms = permissionList.iterator();
				 while (perms.hasNext()) {
					 Permission p = perms.next();
					 pc.add(p);
				 }
				 loaderPC.put(codeUrl,pc);
			 }
		 }
		 return (pc);
	 }
	 public URL[] getURLs() {
		 if (repositoryURLs != null) {
			 return repositoryURLs;
		 }
		 URL[] external = super.getURLs();
		 int filesLength = files.length;
		 int jarFilesLength = jarRealFiles.length;
		 int externalsLength = external.length;
		 int off = 0;
		 int i;
		 try {
			 URL[] urls = new URL[filesLength + jarFilesLength + externalsLength];
			 if (searchExternalFirst) {
				 for (i = 0;
				 i < externalsLength;
				 i++) {
					 urls[i] = external[i];
				 }
				 off = externalsLength;
			 }
			 for (i = 0;
			 i < filesLength;
			 i++) {
				 urls[off + i] = getURL(files[i], true);
			 }
			 off += filesLength;
			 for (i = 0;
			 i < jarFilesLength;
			 i++) {
				 urls[off + i] = getURL(jarRealFiles[i], true);
			 }
			 off += jarFilesLength;
			 if (!searchExternalFirst) {
				 for (i = 0;
				 i < externalsLength;
				 i++) {
					 urls[off + i] = external[i];
				 }
			 }
			 repositoryURLs = urls;
		 }
		 catch (MalformedURLException e) {
			 repositoryURLs = new URL[0];
		 }
		 return repositoryURLs;
	 }
	 public void addLifecycleListener(LifecycleListener listener) {
	 }
	 public LifecycleListener[] findLifecycleListeners() {
		 return new LifecycleListener[0];
	 }
	 public void removeLifecycleListener(LifecycleListener listener) {
	 }
	 public LifecycleState getState() {
		 return LifecycleState.NEW;
	 }
	 public void init() {
	 }
	 public void start() throws LifecycleException {
		 started = true;
		 String encoding = null;
		 try {
			 encoding = System.getProperty(""file.encoding"");
		 }
		 catch (Exception e) {
			 return;
		 }
		 if (encoding.indexOf(""EBCDIC"")!=-1) {
			 needConvert = true;
		 }
	 }
	 public boolean isStarted() {
		 return started;
	 }
	 public void stop() throws LifecycleException {
		 clearReferences();
		 started = false;
		 int length = files.length;
		 for (int i = 0;
		 i < length;
		 i++) {
			 files[i] = null;
		 }
		 length = jarFiles.length;
		 for (int i = 0;
		 i < length;
		 i++) {
			 try {
				 if (jarFiles[i] != null) {
					 jarFiles[i].close();
				 }
			 }
			 catch (IOException e) {
			 }
			 jarFiles[i] = null;
		 }
		 notFoundResources.clear();
		 resourceEntries.clear();
		 resources = null;
		 repositories = null;
		 repositoryURLs = null;
		 files = null;
		 jarFiles = null;
		 jarRealFiles = null;
		 jarPath = null;
		 jarNames = null;
		 lastModifiedDates = null;
		 paths = null;
		 hasExternalRepositories = false;
		 parent = null;
		 permissionList.clear();
		 loaderPC.clear();
		 if (loaderDir != null) {
			 deleteDir(loaderDir);
		 }
	 }
	 public void destroy() {
	 }
	 public void closeJARs(boolean force) {
		 if (jarFiles.length > 0) {
			 synchronized (jarFiles) {
				 if (force || (System.currentTimeMillis() > (lastJarAccessed + 90000))) {
					 for (int i = 0;
					 i < jarFiles.length;
					 i++) {
						 try {
							 if (jarFiles[i] != null) {
								 jarFiles[i].close();
								 jarFiles[i] = null;
							 }
						 }
						 catch (IOException e) {
							 if (log.isDebugEnabled()) {
								 log.debug(""Failed to close JAR"", e);
							 }
						 }
					 }
				 }
			 }
		 }
	 }
	 protected void clearReferences() {
		 clearReferencesJdbc();
		 clearReferencesThreads();
		 clearReferencesThreadLocals();
		 clearReferencesRmiTargets();
		 if (clearReferencesStatic) {
			 clearReferencesStaticFinal();
		 }
		 IntrospectionUtils.clear();
		 if (clearReferencesLogFactoryRelease) {
			 org.apache.juli.logging.LogFactory.release(this);
		 }
		 clearReferencesResourceBundles();
		 java.beans.Introspector.flushCaches();
	 }
	 private final void clearReferencesJdbc() {
		 InputStream is = getResourceAsStream( ""org/apache/catalina/loader/JdbcLeakPrevention.class"");
		 byte[] classBytes = new byte[2048];
		 int offset = 0;
		 try {
			 int read = is.read(classBytes, offset, classBytes.length-offset);
			 while (read > -1) {
				 offset += read;
				 if (offset == classBytes.length) {
					 byte[] tmp = new byte[classBytes.length * 2];
					 System.arraycopy(classBytes, 0, tmp, 0, classBytes.length);
					 classBytes = tmp;
				 }
				 read = is.read(classBytes, offset, classBytes.length-offset);
			 }
			 Class<?> lpClass = defineClass(""org.apache.catalina.loader.JdbcLeakPrevention"", classBytes, 0, offset);
			 Object obj = lpClass.newInstance();
			 List<String> driverNames = (List<String>) obj.getClass().getMethod( ""clearJdbcDriverRegistrations"").invoke(obj);
			 for (String name : driverNames) {
				 log.error(sm.getString(""webappClassLoader.clearJbdc"", contextName, name));
			 }
		 }
		 catch (Exception e) {
			 log.warn(sm.getString( ""webappClassLoader.jdbcRemoveFailed"", contextName), e);
		 }
		 finally {
			 if (is != null) {
				 try {
					 is.close();
				 }
				 catch (IOException ioe) {
					 log.warn(sm.getString( ""webappClassLoader.jdbcRemoveStreamError"", contextName), ioe);
				 }
			 }
		 }
	 }
	 private final void clearReferencesStaticFinal() {
		 Collection<ResourceEntry> values = ((HashMap<String,ResourceEntry>) resourceEntries.clone()).values();
		 Iterator<ResourceEntry> loadedClasses = values.iterator();
		 while(loadedClasses.hasNext()) {
			 ResourceEntry entry = loadedClasses.next();
			 if (entry.loadedClass != null) {
				 Class<?> clazz = entry.loadedClass;
				 try {
					 Field[] fields = clazz.getDeclaredFields();
					 for (int i = 0;
					 i < fields.length;
					 i++) {
						 if(Modifier.isStatic(fields[i].getModifiers())) {
							 fields[i].get(null);
							 break;
						 }
					 }
				 }
				 catch(Throwable t) {
				 }
			 }
		 }
		 loadedClasses = values.iterator();
		 while (loadedClasses.hasNext()) {
			 ResourceEntry entry = loadedClasses.next();
			 if (entry.loadedClass != null) {
				 Class<?> clazz = entry.loadedClass;
				 try {
					 Field[] fields = clazz.getDeclaredFields();
					 for (int i = 0;
					 i < fields.length;
					 i++) {
						 Field field = fields[i];
						 int mods = field.getModifiers();
						 if (field.getType().isPrimitive() || (field.getName().indexOf(""$"") != -1)) {
							 continue;
						 }
						 if (Modifier.isStatic(mods)) {
							 try {
								 field.setAccessible(true);
								 if (Modifier.isFinal(mods)) {
									 if (!((field.getType().getName().startsWith(""java."")) || (field.getType().getName().startsWith(""javax."")))) {
										 nullInstance(field.get(null));
									 }
								 }
								 else {
									 field.set(null, null);
									 if (log.isDebugEnabled()) {
										 log.debug(""Set field "" + field.getName() + "" to null in class "" + clazz.getName());
									 }
								 }
							 }
							 catch (Throwable t) {
								 if (log.isDebugEnabled()) {
									 log.debug(""Could not set field "" + field.getName() + "" to null in class "" + clazz.getName(), t);
								 }
							 }
						 }
					 }
				 }
				 catch (Throwable t) {
					 if (log.isDebugEnabled()) {
						 log.debug(""Could not clean fields for class "" + clazz.getName(), t);
					 }
				 }
			 }
		 }
	 }
	 private void nullInstance(Object instance) {
		 if (instance == null) {
			 return;
		 }
		 Field[] fields = instance.getClass().getDeclaredFields();
		 for (int i = 0;
		 i < fields.length;
		 i++) {
			 Field field = fields[i];
			 int mods = field.getModifiers();
			 if (field.getType().isPrimitive() || (field.getName().indexOf(""$"") != -1)) {
				 continue;
			 }
			 try {
				 field.setAccessible(true);
				 if (Modifier.isStatic(mods) && Modifier.isFinal(mods)) {
					 continue;
				 }
				 Object value = field.get(instance);
				 if (null != value) {
					 Class<? extends Object> valueClass = value.getClass();
					 if (!loadedByThisOrChild(valueClass)) {
						 if (log.isDebugEnabled()) {
							 log.debug(""Not setting field "" + field.getName() + "" to null in object of class "" + instance.getClass().getName() + "" because the referenced object was of type "" + valueClass.getName() + "" which was not loaded by this WebappClassLoader."");
						 }
					 }
					 else {
						 field.set(instance, null);
						 if (log.isDebugEnabled()) {
							 log.debug(""Set field "" + field.getName() + "" to null in class "" + instance.getClass().getName());
						 }
					 }
				 }
			 }
			 catch (Throwable t) {
				 if (log.isDebugEnabled()) {
					 log.debug(""Could not set field "" + field.getName() + "" to null in object instance of class "" + instance.getClass().getName(), t);
				 }
			 }
		 }
	 }
	 private void clearReferencesThreads() {
		 Thread[] threads = getThreads();
		 for (Thread thread : threads) {
			 if (thread != null) {
				 ClassLoader ccl = thread.getContextClassLoader();
				 if (ccl != null && ccl == this) {
					 if (thread == Thread.currentThread()) {
						 continue;
					 }
					 if (!thread.isAlive()) {
						 continue;
					 }
					 ThreadGroup tg = thread.getThreadGroup();
					 if (tg != null && JVM_THREAD_GROUP_NAMES.contains(tg.getName())) {
						 continue;
					 }
					 if (thread.getClass().getName().equals( ""java.util.TimerThread"") && clearReferencesStopTimerThreads) {
						 clearReferencesStopTimerThread(thread);
						 continue;
					 }
					 if (isRequestThread(thread)) {
						 log.error(sm.getString(""webappClassLoader.warnRequestThread"", contextName, thread.getName()));
					 }
					 else {
						 log.error(sm.getString(""webappClassLoader.warnThread"", contextName, thread.getName()));
					 }
					 if (!clearReferencesStopThreads) {
						 continue;
					 }
					 try {
						 Field targetField = thread.getClass().getDeclaredField(""target"");
						 targetField.setAccessible(true);
						 Object target = targetField.get(thread);
						 if (target != null && target.getClass().getCanonicalName().equals( ""java.util.concurrent.ThreadPoolExecutor.Worker"")) {
							 Field executorField = target.getClass().getDeclaredField(""this$0"");
							 executorField.setAccessible(true);
							 Object executor = executorField.get(target);
							 if (executor instanceof ThreadPoolExecutor) {
								 ((ThreadPoolExecutor) executor).shutdownNow();
							 }
						 }
					 }
					 catch (SecurityException e) {
						 log.warn(sm.getString( ""webappClassLoader.stopThreadFail"", thread.getName(), contextName), e);
					 }
					 catch (NoSuchFieldException e) {
						 log.warn(sm.getString( ""webappClassLoader.stopThreadFail"", thread.getName(), contextName), e);
					 }
					 catch (IllegalArgumentException e) {
						 log.warn(sm.getString( ""webappClassLoader.stopThreadFail"", thread.getName(), contextName), e);
					 }
					 catch (IllegalAccessException e) {
						 log.warn(sm.getString( ""webappClassLoader.stopThreadFail"", thread.getName(), contextName), e);
					 }
					 thread.stop();
				 }
			 }
		 }
	 }
	 private boolean isRequestThread(Thread thread) {
		 StackTraceElement[] elements = thread.getStackTrace();
		 if (elements == null || elements.length == 0) {
			 return false;
		 }
		 for (int i = 0;
		 i < elements.length;
		 i++) {
			 StackTraceElement element = elements[elements.length - (i+1)];
			 if (""org.apache.catalina.connector.CoyoteAdapter"".equals( element.getClassName())) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private void clearReferencesStopTimerThread(Thread thread) {
		 try {
			 Field newTasksMayBeScheduledField = thread.getClass().getDeclaredField(""newTasksMayBeScheduled"");
			 newTasksMayBeScheduledField.setAccessible(true);
			 Field queueField = thread.getClass().getDeclaredField(""queue"");
			 queueField.setAccessible(true);
			 Object queue = queueField.get(thread);
			 Method clearMethod = queue.getClass().getDeclaredMethod(""clear"");
			 clearMethod.setAccessible(true);
			 synchronized(queue) {
				 newTasksMayBeScheduledField.setBoolean(thread, false);
				 clearMethod.invoke(queue);
				 queue.notify();
			 }
			 log.error(sm.getString(""webappClassLoader.warnTimerThread"", contextName, thread.getName()));
		 }
		 catch (NoSuchFieldException e) {
			 log.warn(sm.getString( ""webappClassLoader.stopTimerThreadFail"", thread.getName(), contextName), e);
		 }
		 catch (IllegalAccessException e) {
			 log.warn(sm.getString( ""webappClassLoader.stopTimerThreadFail"", thread.getName(), contextName), e);
		 }
		 catch (NoSuchMethodException e) {
			 log.warn(sm.getString( ""webappClassLoader.stopTimerThreadFail"", thread.getName(), contextName), e);
		 }
		 catch (InvocationTargetException e) {
			 log.warn(sm.getString( ""webappClassLoader.stopTimerThreadFail"", thread.getName(), contextName), e);
		 }
	 }
	 private void clearReferencesThreadLocals() {
		 Thread[] threads = getThreads();
		 try {
			 Field threadLocalsField = Thread.class.getDeclaredField(""threadLocals"");
			 threadLocalsField.setAccessible(true);
			 Field inheritableThreadLocalsField = Thread.class.getDeclaredField(""inheritableThreadLocals"");
			 inheritableThreadLocalsField.setAccessible(true);
			 Class<?> tlmClass = Class.forName(""java.lang.ThreadLocal$ThreadLocalMap"");
			 Field tableField = tlmClass.getDeclaredField(""table"");
			 tableField.setAccessible(true);
			 for (int i = 0;
			 i < threads.length;
			 i++) {
				 Object threadLocalMap;
				 if (threads[i] != null) {
					 threadLocalMap = threadLocalsField.get(threads[i]);
					 clearThreadLocalMap(threadLocalMap, tableField);
					 threadLocalMap = inheritableThreadLocalsField.get(threads[i]);
					 clearThreadLocalMap(threadLocalMap, tableField);
				 }
			 }
		 }
		 catch (SecurityException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
		 catch (NoSuchFieldException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
		 catch (ClassNotFoundException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
		 catch (IllegalArgumentException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
		 catch (IllegalAccessException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
		 catch (NoSuchMethodException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
		 catch (InvocationTargetException e) {
			 log.warn(sm.getString(""webappClassLoader.clearThreadLocalFail"", contextName), e);
		 }
	 }
	 private void clearThreadLocalMap(Object map, Field internalTableField) throws NoSuchMethodException, IllegalAccessException, NoSuchFieldException, InvocationTargetException {
		 if (map != null) {
			 Method mapRemove = map.getClass().getDeclaredMethod(""remove"", ThreadLocal.class);
			 mapRemove.setAccessible(true);
			 Object[] table = (Object[]) internalTableField.get(map);
			 int staleEntriesCount = 0;
			 if (table != null) {
				 for (int j =0;
				 j < table.length;
				 j++) {
					 if (table[j] != null) {
						 boolean remove = false;
						 Object key = ((Reference<?>) table[j]).get();
						 if (this.equals(key) || (key != null && this == key.getClass().getClassLoader())) {
							 remove = true;
						 }
						 Field valueField = table[j].getClass().getDeclaredField(""value"");
						 valueField.setAccessible(true);
						 Object value = valueField.get(table[j]);
						 if (this.equals(value) || (value != null && this == value.getClass().getClassLoader())) {
							 remove = true;
						 }
						 if (remove) {
							 Object[] args = new Object[5];
							 args[0] = contextName;
							 if (key != null) {
								 args[1] = key.getClass().getCanonicalName();
								 args[2] = key.toString();
							 }
							 if (value != null) {
								 args[3] = value.getClass().getCanonicalName();
								 args[4] = value.toString();
							 }
							 if (value == null) {
								 if (log.isDebugEnabled()) {
									 log.debug(sm.getString( ""webappClassLoader.clearThreadLocalDebug"", args));
									 if (clearReferencesThreadLocals) {
										 log.debug(sm.getString( ""webappClassLoader.clearThreadLocalDebugClear""));
									 }
								 }
							 }
							 else {
								 log.error(sm.getString( ""webappClassLoader.clearThreadLocal"", args));
								 if (clearReferencesThreadLocals) {
									 log.info(sm.getString( ""webappClassLoader.clearThreadLocalClear""));
								 }
							 }
							 if (clearReferencesThreadLocals) {
								 if (key == null) {
									 staleEntriesCount++;
								 }
								 else {
									 mapRemove.invoke(map, key);
								 }
							 }
						 }
					 }
				 }
			 }
			 if (staleEntriesCount > 0) {
				 Method mapRemoveStale = map.getClass().getDeclaredMethod(""expungeStaleEntries"");
				 mapRemoveStale.setAccessible(true);
				 mapRemoveStale.invoke(map);
			 }
		 }
	 }
	 private Thread[] getThreads() {
		 ThreadGroup tg = Thread.currentThread( ).getThreadGroup( );
		 while (tg.getParent() != null) {
			 tg = tg.getParent();
		 }
		 int threadCountGuess = tg.activeCount() + 50;
		 Thread[] threads = new Thread[threadCountGuess];
		 int threadCountActual = tg.enumerate(threads);
		 while (threadCountActual == threadCountGuess) {
			 threadCountGuess *=2;
			 threads = new Thread[threadCountGuess];
			 threadCountActual = tg.enumerate(threads);
		 }
		 return threads;
	 }
	 private void clearReferencesRmiTargets() {
		 try {
			 Class<?> objectTargetClass = Class.forName(""sun.rmi.transport.Target"");
			 Field cclField = objectTargetClass.getDeclaredField(""ccl"");
			 cclField.setAccessible(true);
			 Class<?> objectTableClass = Class.forName(""sun.rmi.transport.ObjectTable"");
			 Field objTableField = objectTableClass.getDeclaredField(""objTable"");
			 objTableField.setAccessible(true);
			 Object objTable = objTableField.get(null);
			 if (objTable == null) {
				 return;
			 }
			 if (objTable instanceof Map<?,?>) {
				 Iterator<?> iter = ((Map<?,?>) objTable).values().iterator();
				 while (iter.hasNext()) {
					 Object obj = iter.next();
					 Object cclObject = cclField.get(obj);
					 if (this == cclObject) {
						 iter.remove();
					 }
				 }
			 }
			 Field implTableField = objectTableClass.getDeclaredField(""implTable"");
			 implTableField.setAccessible(true);
			 Object implTable = implTableField.get(null);
			 if (implTable == null) {
				 return;
			 }
			 if (implTable instanceof Map<?,?>) {
				 Iterator<?> iter = ((Map<?,?>) implTable).values().iterator();
				 while (iter.hasNext()) {
					 Object obj = iter.next();
					 Object cclObject = cclField.get(obj);
					 if (this == cclObject) {
						 iter.remove();
					 }
				 }
			 }
		 }
		 catch (ClassNotFoundException e) {
			 log.info(sm.getString(""webappClassLoader.clearRmiInfo"", contextName), e);
		 }
		 catch (SecurityException e) {
			 log.warn(sm.getString(""webappClassLoader.clearRmiFail"", contextName), e);
		 }
		 catch (NoSuchFieldException e) {
			 log.warn(sm.getString(""webappClassLoader.clearRmiFail"", contextName), e);
		 }
		 catch (IllegalArgumentException e) {
			 log.warn(sm.getString(""webappClassLoader.clearRmiFail"", contextName), e);
		 }
		 catch (IllegalAccessException e) {
			 log.warn(sm.getString(""webappClassLoader.clearRmiFail"", contextName), e);
		 }
	 }
	 private void clearReferencesResourceBundles() {
		 try {
			 Field cacheListField = ResourceBundle.class.getDeclaredField(""cacheList"");
			 cacheListField.setAccessible(true);
			 Map<?,?> cacheList = (Map<?,?>) cacheListField.get(null);
			 Set<?> keys = cacheList.keySet();
			 Field loaderRefField = null;
			 Iterator<?> keysIter = keys.iterator();
			 int countRemoved = 0;
			 while (keysIter.hasNext()) {
				 Object key = keysIter.next();
				 if (loaderRefField == null) {
					 loaderRefField = key.getClass().getDeclaredField(""loaderRef"");
					 loaderRefField.setAccessible(true);
				 }
				 WeakReference<?> loaderRef = (WeakReference<?>) loaderRefField.get(key);
				 ClassLoader loader = (ClassLoader) loaderRef.get();
				 while (loader != null && loader != this) {
					 loader = loader.getParent();
				 }
				 if (loader != null) {
					 keysIter.remove();
					 countRemoved++;
				 }
			 }
			 if (countRemoved > 0 && log.isDebugEnabled()) {
				 log.debug(sm.getString( ""webappClassLoader.clearReferencesResourceBundlesCount"", Integer.valueOf(countRemoved), contextName));
			 }
		 }
		 catch (SecurityException e) {
			 log.error(sm.getString( ""webappClassLoader.clearReferencesResourceBundlesFail"", contextName), e);
		 }
		 catch (NoSuchFieldException e) {
			 if (System.getProperty(""java.vendor"").startsWith(""Sun"")) {
				 log.error(sm.getString( ""webappClassLoader.clearReferencesResourceBundlesFail"", contextName), e);
			 }
			 else {
				 log.debug(sm.getString( ""webappClassLoader.clearReferencesResourceBundlesFail"", contextName), e);
			 }
		 }
		 catch (IllegalArgumentException e) {
			 log.error(sm.getString( ""webappClassLoader.clearReferencesResourceBundlesFail"", contextName), e);
		 }
		 catch (IllegalAccessException e) {
			 log.error(sm.getString( ""webappClassLoader.clearReferencesResourceBundlesFail"", contextName), e);
		 }
	 }
	 protected boolean loadedByThisOrChild(Class<? extends Object> clazz) {
		 boolean result = false;
		 for (ClassLoader classLoader = clazz.getClassLoader();
		 null != classLoader;
		 classLoader = classLoader.getParent()) {
			 if (classLoader.equals(this)) {
				 result = true;
				 break;
			 }
		 }
		 return result;
	 }
	 protected boolean openJARs() {
		 if (started && (jarFiles.length > 0)) {
			 lastJarAccessed = System.currentTimeMillis();
			 if (jarFiles[0] == null) {
				 for (int i = 0;
				 i < jarFiles.length;
				 i++) {
					 try {
						 jarFiles[i] = new JarFile(jarRealFiles[i]);
					 }
					 catch (IOException e) {
						 if (log.isDebugEnabled()) {
							 log.debug(""Failed to open JAR"", e);
						 }
						 return false;
					 }
				 }
			 }
		 }
		 return true;
	 }
	 protected Class<?> findClassInternal(String name) throws ClassNotFoundException {
		 if (!validate(name)) throw new ClassNotFoundException(name);
		 String tempPath = name.replace('.', '/');
		 String classPath = tempPath + "".class"";
		 ResourceEntry entry = null;
		 if (securityManager != null) {
			 PrivilegedAction<ResourceEntry> dp = new PrivilegedFindResourceByName(name, classPath);
			 entry = AccessController.doPrivileged(dp);
		 }
		 else {
			 entry = findResourceInternal(name, classPath);
		 }
		 if (entry == null) throw new ClassNotFoundException(name);
		 Class<?> clazz = entry.loadedClass;
		 if (clazz != null) return clazz;
		 synchronized (this) {
			 clazz = entry.loadedClass;
			 if (clazz != null) return clazz;
			 if (entry.binaryContent == null) throw new ClassNotFoundException(name);
			 String packageName = null;
			 int pos = name.lastIndexOf('.');
			 if (pos != -1) packageName = name.substring(0, pos);
			 Package pkg = null;
			 if (packageName != null) {
				 pkg = getPackage(packageName);
				 if (pkg == null) {
					 try {
						 if (entry.manifest == null) {
							 definePackage(packageName, null, null, null, null, null, null, null);
						 }
						 else {
							 definePackage(packageName, entry.manifest, entry.codeBase);
						 }
					 }
					 catch (IllegalArgumentException e) {
					 }
					 pkg = getPackage(packageName);
				 }
			 }
			 if (securityManager != null) {
				 if (pkg != null) {
					 boolean sealCheck = true;
					 if (pkg.isSealed()) {
						 sealCheck = pkg.isSealed(entry.codeBase);
					 }
					 else {
						 sealCheck = (entry.manifest == null) || !isPackageSealed(packageName, entry.manifest);
					 }
					 if (!sealCheck) throw new SecurityException (""Sealing violation loading "" + name + "" : Package "" + packageName + "" is sealed."");
				 }
			 }
			 try {
				 clazz = defineClass(name, entry.binaryContent, 0, entry.binaryContent.length, new CodeSource(entry.codeBase, entry.certificates));
			 }
			 catch (UnsupportedClassVersionError ucve) {
				 throw new UnsupportedClassVersionError( ucve.getLocalizedMessage() + "" "" + sm.getString(""webappClassLoader.wrongVersion"", name));
			 }
			 entry.loadedClass = clazz;
			 entry.binaryContent = null;
			 entry.source = null;
			 entry.codeBase = null;
			 entry.manifest = null;
			 entry.certificates = null;
		 }
		 return clazz;
	 }
	 protected ResourceEntry findResourceInternal(File file, String path){
		 ResourceEntry entry = new ResourceEntry();
		 try {
			 entry.source = getURI(new File(file, path));
			 entry.codeBase = getURL(new File(file, path), false);
		 }
		 catch (MalformedURLException e) {
			 return null;
		 }
		 return entry;
	 }
	 protected ResourceEntry findResourceInternal(String name, String path) {
		 if (!started) {
			 log.info(sm.getString(""webappClassLoader.stopped"", name));
			 return null;
		 }
		 if ((name == null) || (path == null)) return null;
		 ResourceEntry entry = resourceEntries.get(name);
		 if (entry != null) return entry;
		 int contentLength = -1;
		 InputStream binaryStream = null;
		 int jarFilesLength = jarFiles.length;
		 int repositoriesLength = repositories.length;
		 int i;
		 Resource resource = null;
		 boolean fileNeedConvert = false;
		 for (i = 0;
		 (entry == null) && (i < repositoriesLength);
		 i++) {
			 try {
				 String fullPath = repositories[i] + path;
				 Object lookupResult = resources.lookup(fullPath);
				 if (lookupResult instanceof Resource) {
					 resource = (Resource) lookupResult;
				 }
				 entry = findResourceInternal(files[i], path);
				 ResourceAttributes attributes = (ResourceAttributes) resources.getAttributes(fullPath);
				 contentLength = (int) attributes.getContentLength();
				 entry.lastModified = attributes.getLastModified();
				 if (resource != null) {
					 try {
						 binaryStream = resource.streamContent();
					 }
					 catch (IOException e) {
						 return null;
					 }
					 if (needConvert) {
						 if (path.endsWith("".properties"")) {
							 fileNeedConvert = true;
						 }
					 }
					 synchronized (allPermission) {
						 int j;
						 long[] result2 = new long[lastModifiedDates.length + 1];
						 for (j = 0;
						 j < lastModifiedDates.length;
						 j++) {
							 result2[j] = lastModifiedDates[j];
						 }
						 result2[lastModifiedDates.length] = entry.lastModified;
						 lastModifiedDates = result2;
						 String[] result = new String[paths.length + 1];
						 for (j = 0;
						 j < paths.length;
						 j++) {
							 result[j] = paths[j];
						 }
						 result[paths.length] = fullPath;
						 paths = result;
					 }
				 }
			 }
			 catch (NamingException e) {
			 }
		 }
		 if ((entry == null) && (notFoundResources.containsKey(name))) return null;
		 JarEntry jarEntry = null;
		 synchronized (jarFiles) {
			 try {
				 if (!openJARs()) {
					 return null;
				 }
				 for (i = 0;
				 (entry == null) && (i < jarFilesLength);
				 i++) {
					 jarEntry = jarFiles[i].getJarEntry(path);
					 if (jarEntry != null) {
						 entry = new ResourceEntry();
						 try {
							 entry.codeBase = getURL(jarRealFiles[i], false);
							 String jarFakeUrl = getURI(jarRealFiles[i]).toString();
							 jarFakeUrl = ""jar:"" + jarFakeUrl + ""!/"" + path;
							 entry.source = new URL(jarFakeUrl);
							 entry.lastModified = jarRealFiles[i].lastModified();
						 }
						 catch (MalformedURLException e) {
							 return null;
						 }
						 contentLength = (int) jarEntry.getSize();
						 try {
							 entry.manifest = jarFiles[i].getManifest();
							 binaryStream = jarFiles[i].getInputStream(jarEntry);
						 }
						 catch (IOException e) {
							 return null;
						 }
						 if (antiJARLocking && !(path.endsWith("".class""))) {
							 byte[] buf = new byte[1024];
							 File resourceFile = new File (loaderDir, jarEntry.getName());
							 if (!resourceFile.exists()) {
								 Enumeration<JarEntry> entries = jarFiles[i].entries();
								 while (entries.hasMoreElements()) {
									 JarEntry jarEntry2 = entries.nextElement();
									 if (!(jarEntry2.isDirectory()) && (!jarEntry2.getName().endsWith ("".class""))) {
										 resourceFile = new File (loaderDir, jarEntry2.getName());
										 try {
											 if (!resourceFile.getCanonicalPath().startsWith( canonicalLoaderDir)) {
												 throw new IllegalArgumentException( sm.getString(""webappClassLoader.illegalJarPath"", jarEntry2.getName()));
											 }
										 }
										 catch (IOException ioe) {
											 throw new IllegalArgumentException( sm.getString(""webappClassLoader.validationErrorJarPath"", jarEntry2.getName()), ioe);
										 }
										 resourceFile.getParentFile().mkdirs();
										 FileOutputStream os = null;
										 InputStream is = null;
										 try {
											 is = jarFiles[i].getInputStream (jarEntry2);
											 os = new FileOutputStream (resourceFile);
											 while (true) {
												 int n = is.read(buf);
												 if (n <= 0) {
													 break;
												 }
												 os.write(buf, 0, n);
											 }
										 }
										 catch (IOException e) {
										 }
										 finally {
											 try {
												 if (is != null) {
													 is.close();
												 }
											 }
											 catch (IOException e) {
											 }
											 try {
												 if (os != null) {
													 os.close();
												 }
											 }
											 catch (IOException e) {
											 }
										 }
									 }
								 }
							 }
						 }
					 }
				 }
				 if (entry == null) {
					 synchronized (notFoundResources) {
						 notFoundResources.put(name, name);
					 }
					 return null;
				 }
				 if (binaryStream != null) {
					 byte[] binaryContent = new byte[contentLength];
					 int pos = 0;
					 try {
						 while (true) {
							 int n = binaryStream.read(binaryContent, pos, binaryContent.length - pos);
							 if (n <= 0) break;
							 pos += n;
						 }
					 }
					 catch (IOException e) {
						 log.error(sm.getString(""webappClassLoader.readError"", name), e);
						 return null;
					 }
					 if (fileNeedConvert) {
						 String str = new String(binaryContent,0,pos);
						 try {
							 binaryContent = str.getBytes(""UTF-8"");
						 }
						 catch (Exception e) {
							 return null;
						 }
					 }
					 entry.binaryContent = binaryContent;
					 if (jarEntry != null) {
						 entry.certificates = jarEntry.getCertificates();
					 }
				 }
			 }
			 finally {
				 if (binaryStream != null) {
					 try {
						 binaryStream.close();
					 }
					 catch (IOException e) {
					 }
				 }
			 }
		 }
		 synchronized (resourceEntries) {
			 ResourceEntry entry2 = resourceEntries.get(name);
			 if (entry2 == null) {
				 resourceEntries.put(name, entry);
			 }
			 else {
				 entry = entry2;
			 }
		 }
		 return entry;
	 }
	 protected boolean isPackageSealed(String name, Manifest man) {
		 String path = name.replace('.', '/') + '/';
		 Attributes attr = man.getAttributes(path);
		 String sealed = null;
		 if (attr != null) {
			 sealed = attr.getValue(Name.SEALED);
		 }
		 if (sealed == null) {
			 if ((attr = man.getMainAttributes()) != null) {
				 sealed = attr.getValue(Name.SEALED);
			 }
		 }
		 return ""true"".equalsIgnoreCase(sealed);
	 }
	 protected InputStream findLoadedResource(String name) {
		 ResourceEntry entry = resourceEntries.get(name);
		 if (entry != null) {
			 if (entry.binaryContent != null) return new ByteArrayInputStream(entry.binaryContent);
		 }
		 return (null);
	 }
	 protected Class<?> findLoadedClass0(String name) {
		 ResourceEntry entry = resourceEntries.get(name);
		 if (entry != null) {
			 return entry.loadedClass;
		 }
		 return (null);
	 }
	 protected void refreshPolicy() {
		 try {
			 Policy policy = Policy.getPolicy();
			 policy.refresh();
		 }
		 catch (AccessControlException e) {
		 }
	 }
	 protected boolean filter(String name) {
		 if (name == null) return false;
		 String packageName = null;
		 int pos = name.lastIndexOf('.');
		 if (pos != -1) packageName = name.substring(0, pos);
		 else return false;
		 for (int i = 0;
		 i < packageTriggers.length;
		 i++) {
			 if (packageName.startsWith(packageTriggers[i])) return true;
		 }
		 return false;
	 }
	 protected boolean validate(String name) {
		 if (name == null) return false;
		 if (name.startsWith(""java."")) return false;
		 return true;
	 }
	 protected boolean validateJarFile(File jarfile) throws IOException {
		 if (triggers == null) return (true);
		 JarFile jarFile = new JarFile(jarfile);
		 for (int i = 0;
		 i < triggers.length;
		 i++) {
			 Class<?> clazz = null;
			 try {
				 if (parent != null) {
					 clazz = parent.loadClass(triggers[i]);
				 }
				 else {
					 clazz = Class.forName(triggers[i]);
				 }
			 }
			 catch (Throwable t) {
				 clazz = null;
			 }
			 if (clazz == null) continue;
			 String name = triggers[i].replace('.', '/') + "".class"";
			 if (log.isDebugEnabled()) log.debug("" Checking for "" + name);
			 JarEntry jarEntry = jarFile.getJarEntry(name);
			 if (jarEntry != null) {
				 log.info(""validateJarFile("" + jarfile + "") - jar not loaded. See Servlet Spec 2.3, "" + ""section 9.7.2. Offending class: "" + name);
				 jarFile.close();
				 return (false);
			 }
		 }
		 jarFile.close();
		 return (true);
	 }
	 protected URL getURL(File file, boolean encoded) throws MalformedURLException {
		 File realFile = file;
		 try {
			 realFile = realFile.getCanonicalFile();
		 }
		 catch (IOException e) {
		 }
		 if(encoded) {
			 return getURI(realFile);
		 }
		 else {
			 return realFile.toURI().toURL();
		 }
	 }
	 protected URL getURI(File file) throws MalformedURLException {
		 File realFile = file;
		 try {
			 realFile = realFile.getCanonicalFile();
		 }
		 catch (IOException e) {
		 }
		 return realFile.toURI().toURL();
	 }
	 protected static void deleteDir(File dir) {
		 String files[] = dir.list();
		 if (files == null) {
			 files = new String[0];
		 }
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 File file = new File(dir, files[i]);
			 if (file.isDirectory()) {
				 deleteDir(file);
			 }
			 else {
				 file.delete();
			 }
		 }
		 dir.delete();
	 }
}",1,0,0,0
"public class PigTest {
	 private final String originalTextPigScript;
	 private final String[] args;
	 private final String[] argFiles;
	 private final Map<String, String> aliasOverrides;
	 private static ThreadLocal<PigServer> pig = new ThreadLocal<PigServer>();
	 private static ThreadLocal<Cluster> cluster = new ThreadLocal<Cluster>();
	 private static final Logger LOG = Logger.getLogger(PigTest.class);
	 private static final String EXEC_CLUSTER = ""pigunit.exectype"";
	 PigTest(String[] args, String[] argFiles, String pigTextScript) {
		 this.originalTextPigScript = pigTextScript;
		 this.args = args;
		 this.argFiles = argFiles;
		 this.aliasOverrides = new HashMap<String, String>() {
			{
				 put(""STORE"", """");
				 put(""DUMP"", """");
			 }
		}
		;
	 }
	 public PigTest(String scriptPath) throws IOException {
		 this(null, null, readFile(scriptPath));
	 }
	 public PigTest(String[] script) {
		 this(null, null, StringUtils.join(script, ""\n""));
	 }
	 public PigTest(String scriptPath, String[] args) throws IOException {
		 this(args, null, readFile(scriptPath));
	 }
	 public PigTest(String[] script, String[] args) {
		 this(args, null, StringUtils.join(script, ""\n""));
	 }
	 public PigTest(String[] script, String[] args, String[] argsFile) {
		 this(args, argsFile, StringUtils.join(script, ""\n""));
	 }
	 public PigTest(String scriptPath, String[] args, String[] argFiles) throws IOException {
		 this(args, argFiles, readFile(scriptPath));
	 }
	 public PigTest(String scriptPath, String[] args, PigServer pig, Cluster cluster) throws IOException {
		 this(args, null, readFile(scriptPath));
		 PigTest.pig.set(pig);
		 PigTest.cluster.set(cluster);
	 }
	 public static Cluster getCluster() throws ExecException {
		 try {
			 if (cluster.get() == null) {
				 ExecType execType = ExecType.LOCAL;
				 if (System.getProperties().containsKey(EXEC_CLUSTER)) {
					 if (System.getProperties().getProperty(EXEC_CLUSTER).equalsIgnoreCase(""mr"")) {
						 LOG.info(""Using mr cluster mode"");
						 execType = ExecType.MAPREDUCE;
					 }
					 else if (System.getProperties().getProperty(EXEC_CLUSTER).equalsIgnoreCase(""tez"")) {
						 LOG.info(""Using tez cluster mode"");
						 execType = ExecTypeProvider.fromString(""tez"");
					 }
					 else if (System.getProperties().getProperty(EXEC_CLUSTER).equalsIgnoreCase(""tez_local"")) {
						 LOG.info(""Using tez local mode"");
						 execType = ExecTypeProvider.fromString(""tez_local"");
					 }
					 else if (System.getProperties().getProperty(EXEC_CLUSTER).equalsIgnoreCase(""spark"")) {
						 LOG.info(""Using spark cluster mode"");
						 execType = ExecTypeProvider.fromString(""spark"");
					 }
					 else if (System.getProperties().getProperty(EXEC_CLUSTER).equalsIgnoreCase(""spark_local"")) {
						 LOG.info(""Using spark local cluster mode"");
						 execType = ExecTypeProvider.fromString(""spark_local"");
					 }
					 else {
						 LOG.info(""Using default local mode"");
					 }
				 }
				 else {
					 LOG.info(""Using default local mode"");
				 }
				 pig.set(new PigServer(execType));
				 cluster.set(new Cluster(pig.get().getPigContext()));
			 }
		 }
		 catch (PigException e) {
			 throw new ExecException(e);
		 }
		 return cluster.get();
	 }
	 public static PigServer getPigServer() {
		 return pig.get();
	 }
	 protected void registerScript() throws IOException, ParseException {
		 getCluster();
		 BufferedReader reader = new BufferedReader(new StringReader(this.originalTextPigScript));
		 PigContext context = getPigServer().getPigContext();
		 String substitutedPig = context.doParamSubstitution(reader, args == null ? null : Arrays.asList(args), argFiles == null ? null : Arrays.asList(argFiles));
		 LOG.info(substitutedPig);
		 File f = File.createTempFile(""tmp"", ""pigunit"");
		 PrintWriter pw = new PrintWriter(f);
		 pw.println(substitutedPig);
		 pw.close();
		 String pigSubstitutedFile = f.getCanonicalPath();
		 getPigServer().registerScript(pigSubstitutedFile, aliasOverrides);
	 }
	 public void runScript() throws IOException, ParseException {
		 registerScript();
	 }
	 public Iterator<Tuple> getAlias(String alias) throws IOException, ParseException {
		 registerScript();
		 return getPigServer().openIterator(alias);
	 }
	 private Iterator<Tuple> getAliasFromCache(String alias) throws IOException, ParseException {
		 return getPigServer().openIterator(alias);
	 }
	 public Iterator<Tuple> getAlias() throws IOException, ParseException {
		 registerScript();
		 String alias = aliasOverrides.get(""LAST_STORE_ALIAS"");
		 return getAliasFromCache(alias);
	 }
	 public void override(String alias, String query) {
		 aliasOverrides.put(alias, query);
	 }
	 public void unoverride(String alias) {
		 aliasOverrides.remove(alias);
	 }
	 public Map<String, String> getAliasToSchemaMap() throws FrontendException, IOException, ParseException {
		 HashMap<String, String> aliasSchemas = new HashMap<String, String>();
		 registerScript();
		 PigServer server = getPigServer();
		 Set<String> aliasKeySet = server.getAliasKeySet();
		 for (String alias: aliasKeySet) {
			 try {
				 StringBuilder tsb = new StringBuilder();
				 Schema.stringifySchema(tsb, server.dumpSchema(alias), DataType.TUPLE, Integer.MIN_VALUE);
				 aliasSchemas.put(alias, tsb.toString());
			 }
			 catch (FrontendException e) {
				 if (e.getErrorCode() == 1001) {
					 System.out.println(e.getMessage());
				 }
				 else {
					 throw e;
				 }
			 }
		 }
		 return aliasSchemas;
	 }
	 private String makeMockTempFile(String alias, String[] mockData) throws IOException {
		 String uniqueSuffix = alias + ""."" + System.currentTimeMillis() + ""."" + Thread.currentThread().getId();
		 if (getPigServer() == null) {
			 getCluster();
		 }
		 String path = FileLocalizer.getTemporaryPath(getPigServer().getPigContext(), uniqueSuffix).toString();
		 getCluster().copyFromLocalFile(mockData, path, true);
		 return path;
	 }
	 private String getActualResults(String alias, boolean ignoreOrder) throws IOException, ParseException {
		 Iterator<Tuple> iterator = getAliasFromCache(alias);
		 List<String> actualResults = new ArrayList<String>();
		 while (iterator.hasNext()) {
			 actualResults.add(iterator.next().toString());
		 }
		 if (ignoreOrder) {
			 Collections.sort(actualResults);
		 }
		 return StringUtils.join(actualResults, ""\n"");
	 }
	 public void mockAlias(String alias, String[] mockData, String aliasSchema) throws IOException {
		 mockAlias(alias, mockData, aliasSchema, ""\\t"");
	 }
	 public void mockAlias(String alias, String[] mockData, String aliasSchema, String delimiter) throws IOException {
		 String mockFile = makeMockTempFile(alias, mockData);
		 override(alias, String.format(""%s = LOAD '%s' USING PigStorage('%s') AS %s;
		"", alias, mockFile, delimiter, aliasSchema));
	 }
	 public void assertOutputAnyOrder(String[] expected) throws IOException, ParseException {
		 assertOutput(expected, true);
	 }
	 public void assertOutput(String[] expected) throws IOException, ParseException {
		 assertOutput(expected, false);
	 }
	 private void assertOutput(String[] expected, boolean ignoreOrder) throws IOException, ParseException {
		 registerScript();
		 String alias = aliasOverrides.get(""LAST_STORE_ALIAS"");
		 if (ignoreOrder) {
			 Arrays.sort(expected);
		 }
		 assertEquals(StringUtils.join(expected, ""\n""), getActualResults(alias, ignoreOrder));
	 }
	 public void assertOutputAnyOrder(String alias, String[] expected) throws IOException, ParseException {
		 assertOutput(alias, expected, true);
	 }
	 public void assertOutput(String alias, String[] expected) throws IOException, ParseException {
		 assertOutput(alias, expected, false);
	 }
	 private void assertOutput(String alias, String[] expected, boolean ignoreOrder) throws IOException, ParseException {
		 registerScript();
		 if (ignoreOrder) {
			 Arrays.sort(expected);
		 }
		 assertEquals(StringUtils.join(expected, ""\n""), getActualResults(alias, ignoreOrder));
	 }
	 public void assertOutput(File expected) throws IOException, ParseException {
		 assertOutput(readFile(expected).split(""(\\r\\n|\\n)""), false);
	 }
	 public void assertOutput(String alias, File expected) throws IOException, ParseException {
		 assertOutput(alias, readFile(expected).split(""(\\r\\n|\\n)""), false);
	 }
	 public void assertOutput(String aliasInput, String[] input, String alias, String[] expected) throws IOException, ParseException {
		 assertOutput(aliasInput, input, alias, expected, ""\\t"");
	 }
	 public void assertOutput(String aliasInput, String[] input, String alias, String[] expected, String delimiter) throws IOException, ParseException {
		 registerScript();
		 StringBuilder sb = new StringBuilder();
		 Schema.stringifySchema(sb, getPigServer().dumpSchema(aliasInput), DataType.TUPLE) ;
		 mockAlias(aliasInput, input, sb.toString(), delimiter);
		 assertOutput(alias, expected, false);
	 }
	 protected void assertEquals(String expected, String current) {
		 Assert.assertEquals(expected, current);
	 }
	 private static String readFile(String path) throws IOException {
		 return readFile(new File(path));
	 }
	 private static String readFile(File file) throws IOException {
		 FileInputStream stream = new FileInputStream(file);
		 try {
			 FileChannel fc = stream.getChannel();
			 MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());
			 return Charset.defaultCharset().decode(bb).toString();
		 }
		 finally {
			 stream.close();
		 }
	 }
}",1,0,0,0
"public final class PluginRegistryImpl implements PluginRegistry {
	 static final String PACKAGE_NAME = ""org.java.plugin.registry.xml"";
	 private static final char UNIQUE_SEPARATOR = '@';
	 private static final Log log = LogFactory.getLog(PluginRegistryImpl.class);
	 private final List registrationReport = new LinkedList();
	 private final Map registeredPlugins = new HashMap();
	 private final Map registeredFragments = new HashMap();
	 private final List listeners = Collections.synchronizedList(new LinkedList());
	 private ManifestParser manifestParser;
	 private boolean stopOnError = false;
	 public PluginRegistryImpl() {
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""registryStart"", null));
	 }
	 public void configure(final ExtendedProperties config) {
		 stopOnError = ""true"".equalsIgnoreCase( config.getProperty(""stopOnError"", ""false""));
		 boolean isValidating = !""false"".equalsIgnoreCase( config.getProperty(""isValidating"", ""true""));
		 manifestParser = new ManifestParser(isValidating);
		 log.info(""configured, stopOnError="" + stopOnError + "", isValidating="" + isValidating);
	 }
	 public ManifestInfo readManifestInfo(final URL url) throws ManifestProcessingException {
		 try {
			 return new ManifestInfoImpl(manifestParser.parseManifestInfo(url));
		 }
		 catch (Exception e) {
			 throw new ManifestProcessingException(PACKAGE_NAME, ""manifestParsingError"", url, e);
		 }
	 }
	 public Map register(final URL[] manifests) throws ManifestProcessingException {
		 List registeredPoints = new LinkedList();
		 Map registeredExtensions = new HashMap();
		 for (Iterator it = registeredPlugins.values().iterator();
		 it.hasNext();
		) {
			 for (Iterator it2 = ((PluginDescriptor) it.next()) .getExtensionPoints().iterator();
			 it2.hasNext();
			) {
				 ExtensionPoint point = (ExtensionPoint) it2.next();
				 registeredPoints.add(point);
				 for (Iterator it3 = point.getConnectedExtensions().iterator();
				 it3.hasNext();
				) {
					 Extension ext = (Extension) it3.next();
					 registeredExtensions.put(ext.getUniqueId(), ext);
				 }
			 }
		 }
		 Map result = new HashMap(manifests.length);
		 Map plugins = new HashMap();
		 Map fragments = new HashMap();
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""manifestsParsingStart"", null));
		 for (int i = 0;
		 i < manifests.length;
		 i++) {
			 URL url = manifests[i];
			 ModelPluginManifest model;
			 try {
				 model = manifestParser.parseManifest(url);
			 }
			 catch (Exception e) {
				 log.error(""can't parse manifest file "" + url, e);
				 if (stopOnError) {
					 throw new ManifestProcessingException(PACKAGE_NAME, ""manifestParsingError"", url, e);
				 }
				 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_ERROR, null, ReportItem.ERROR_MANIFEST_PROCESSING_FAILED, ""manifestParsingError"", new Object[] {
				url, e}
				));
				 continue;
			 }
			 if (model instanceof ModelPluginFragment) {
				 fragments.put(url, model);
				 continue;
			 }
			 if (!(model instanceof ModelPluginDescriptor)) {
				 log.warn(""URL "" + url + "" points to XML document of unknown type"");
				 continue;
			 }
			 plugins.put(url, model);
		 }
		 if (log.isDebugEnabled()) {
			 log.debug(""manifest files parsed, plugins.size="" + plugins.size() + "", fragments.size="" + fragments.size());
		 }
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""manifestsParsingFinish"", new Object[] {
		new Integer(plugins.size()), new Integer(fragments.size())}
		));
		 checkVersions(plugins);
		 if (log.isDebugEnabled()) {
			 log.debug(""plug-ins versions checked, plugins.size="" + plugins.size());
		 }
		 checkVersions(fragments);
		 if (log.isDebugEnabled()) {
			 log.debug(""plug-in fragments versions checked, fragments.size="" + fragments.size());
		 }
		 RegistryChangeDataImpl registryChangeData = new RegistryChangeDataImpl();
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""registeringPluginsStart"", null));
		 for (Iterator it = plugins.values().iterator();
		 it.hasNext();
		) {
			 PluginDescriptor descr = registerPlugin( (ModelPluginDescriptor) it.next(), registryChangeData);
			 if (descr != null) {
				 result.put(descr.getLocation(), descr);
			 }
		 }
		 plugins.clear();
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""registeringFragmentsStart"", null));
		 for (Iterator it = fragments.values().iterator();
		 it.hasNext();
		) {
			 PluginFragment fragment = registerFragment( (ModelPluginFragment) it.next(), registryChangeData);
			 if (fragment != null) {
				 result.put(fragment.getLocation(), fragment);
			 }
		 }
		 fragments.clear();
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""registeringPluginsFinish"", new Integer(registeredPlugins.size())));
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""registeringFragmentsFinish"", new Integer(registeredFragments.size())));
		 log.info(""plug-in and fragment descriptors registered - "" + result.size());
		 dump();
		 if (result.isEmpty()) {
			 return result;
		 }
		 for (Iterator it = registeredPoints.iterator();
		 it.hasNext();
		) {
			 ((ExtensionPointImpl) it.next()).registryChanged();
		 }
		 for (Iterator it = registeredExtensions.values().iterator();
		 it.hasNext();
		) {
			 ((ExtensionImpl) it.next()).registryChanged();
		 }
		 if (!listeners.isEmpty() || log.isDebugEnabled()) {
			 for (Iterator it = registeredPlugins.values().iterator();
			 it.hasNext();
			) {
				 for (Iterator it2 = ((PluginDescriptor) it.next()) .getExtensionPoints().iterator();
				 it2.hasNext();
				) {
					 for (Iterator it3 = ((ExtensionPoint) it2.next()) .getConnectedExtensions().iterator();
					 it3.hasNext();
					) {
						 Extension ext = (Extension) it3.next();
						 if (!registeredExtensions.containsKey( ext.getUniqueId())) {
							 registryChangeData.putAddedExtension( ext.getUniqueId(), makeUniqueId(ext.getExtendedPluginId(), ext.getExtendedPointId()));
						 }
						 else {
							 registeredExtensions.remove(ext.getUniqueId());
							 if (registryChangeData.modifiedPlugins().contains( ext.getDeclaringPluginDescriptor().getId()) || registryChangeData.modifiedPlugins() .contains(ext.getExtendedPluginId())) {
								 registryChangeData.putModifiedExtension( ext.getUniqueId(), makeUniqueId(ext.getExtendedPluginId(), ext.getExtendedPointId()));
							 }
						 }
					 }
				 }
			 }
			 for (Iterator it = registeredExtensions.values().iterator();
			 it.hasNext();
			) {
				 Extension ext = (Extension) it.next();
				 registryChangeData.putRemovedExtension(ext.getUniqueId(), makeUniqueId(ext.getExtendedPluginId(), ext.getExtendedPointId()));
			 }
			 fireEvent(registryChangeData);
		 }
		 return result;
	 }
	 private void checkVersions(final Map plugins) throws ManifestProcessingException {
		 Map versions = new HashMap();
		 Set toBeRemovedUrls = new HashSet();
		 for (Iterator it = plugins.entrySet().iterator();
		 it.hasNext();
		) {
			 Map.Entry entry = (Map.Entry) it.next();
			 URL url = (URL) entry.getKey();
			 ModelPluginManifest model = (ModelPluginManifest) entry.getValue();
			 if (registeredPlugins.containsKey(model.getId())) {
				 if (stopOnError) {
					 throw new ManifestProcessingException(PACKAGE_NAME, ""duplicatePlugin"", model.getId());
				 }
				 it.remove();
				 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_ERROR, null, ReportItem.ERROR_MANIFEST_PROCESSING_FAILED, ""duplicatedPluginId"", model.getId()));
				 continue;
			 }
			 if (registeredFragments.containsKey(model.getId())) {
				 if (stopOnError) {
					 throw new ManifestProcessingException(PACKAGE_NAME, ""duplicatePluginFragment"", model.getId());
				 }
				 it.remove();
				 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_ERROR, null, ReportItem.ERROR_MANIFEST_PROCESSING_FAILED, ""duplicatedFragmentId"", model.getId()));
				 continue;
			 }
			 Object[] version = (Object[]) versions.get(model.getId());
			 if (version == null) {
				 versions.put(model.getId(), new Object[] {
				model.getVersion(), url}
				);
				 continue;
			 }
			 if (((Version) version[0]).compareTo(model.getVersion()) < 0) {
				 toBeRemovedUrls.add(version[1]);
				 versions.put(model.getId(), new Object[] {
				model.getVersion(), url}
				);
			 }
			 else {
				 toBeRemovedUrls.add(url);
			 }
		 }
		 versions.clear();
		 for (Iterator it = toBeRemovedUrls.iterator();
		 it.hasNext();
		) {
			 URL url = (URL) it.next();
			 plugins.remove(url);
			 log.warn(""ignoring duplicated manifest "" + url);
		 }
		 toBeRemovedUrls.clear();
	 }
	 private PluginDescriptor registerPlugin(final ModelPluginDescriptor model, final RegistryChangeDataImpl registryChangeData) throws ManifestProcessingException {
		 if (log.isDebugEnabled()) {
			 log.debug(""registering plug-in, URL - "" + model.getLocation());
		 }
		 PluginDescriptorImpl result = null;
		 try {
			 result = new PluginDescriptorImpl(this, model);
			 registryChangeData.addedPlugins().add(result.getId());
			 for (Iterator it = registeredFragments.values().iterator();
			 it.hasNext();
			) {
				 PluginFragmentImpl fragment = (PluginFragmentImpl) it.next();
				 if (fragment.matches(result)) {
					 result.registerFragment(fragment);
				 }
			 }
			 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""pluginRegistered"", result.getUniqueId()));
		 }
		 catch (ManifestProcessingException mpe) {
			 log.error(""failed registering plug-in, URL - "" + model.getLocation(), mpe);
			 if (stopOnError) {
				 throw mpe;
			 }
			 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_ERROR, null, ReportItem.ERROR_MANIFEST_PROCESSING_FAILED, ""pluginRegistrationFailed"", new Object[] {
			model.getLocation(), mpe}
			));
			 return null;
		 }
		 registeredPlugins.put(result.getId(), result);
		 return result;
	 }
	 private PluginFragment registerFragment(final ModelPluginFragment model, final RegistryChangeDataImpl registryChangeData) throws ManifestProcessingException {
		 if (log.isDebugEnabled()) {
			 log.debug(""registering plug-in fragment descriptor, URL - "" + model.getLocation());
		 }
		 PluginFragmentImpl result = null;
		 try {
			 result = new PluginFragmentImpl(this, model);
			 boolean isRegistered = false;
			 PluginDescriptorImpl descr = (PluginDescriptorImpl) getPluginDescriptor( result.getPluginId());
			 if (result.matches(descr)) {
				 descr.registerFragment(result);
				 if (!registryChangeData.addedPlugins().contains( descr.getId())) {
					 registryChangeData.modifiedPlugins().add(descr.getId());
				 }
				 isRegistered = true;
			 }
			 if (!isRegistered) {
				 log.warn(""no matching plug-ins found for fragment "" + result.getUniqueId());
				 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_WARNING, null, ReportItem.ERROR_NO_ERROR, ""noMatchingPluginFound"", result.getUniqueId()));
			 }
			 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""fragmentRegistered"", result.getUniqueId()));
		 }
		 catch (ManifestProcessingException mpe) {
			 log.error(""failed registering plug-in fragment descriptor, URL - "" + model.getLocation(), mpe);
			 if (stopOnError) {
				 throw mpe;
			 }
			 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_ERROR, null, ReportItem.ERROR_MANIFEST_PROCESSING_FAILED, ""fragmentRegistrationFailed"", new Object[] {
			model.getLocation(), mpe}
			));
			 return null;
		 }
		 registeredFragments.put(result.getId(), result);
		 return result;
	 }
	 public Collection unregister(final String[] ids) {
		 List registeredPoints = new LinkedList();
		 Map registeredExtensions = new HashMap();
		 for (Iterator it = registeredPlugins.values().iterator();
		 it.hasNext();
		) {
			 for (Iterator it2 = ((PluginDescriptor) it.next()) .getExtensionPoints().iterator();
			 it2.hasNext();
			) {
				 ExtensionPoint point = (ExtensionPoint) it2.next();
				 registeredPoints.add(point);
				 for (Iterator it3 = point.getConnectedExtensions().iterator();
				 it3.hasNext();
				) {
					 Extension ext = (Extension) it3.next();
					 registeredExtensions.put(ext.getUniqueId(), ext);
				 }
			 }
		 }
		 Set result = new HashSet();
		 RegistryChangeDataImpl registryChangeData = new RegistryChangeDataImpl();
		 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""unregisteringPrepare"", null));
		 Map removingPlugins = new HashMap();
		 Map removingFragments = new HashMap();
		 for (int i = 0;
		 i < ids.length;
		 i++) {
			 PluginDescriptor descr = (PluginDescriptor) registeredPlugins.get(ids[i]);
			 if (descr != null) {
				 for (Iterator it = getDependingPlugins(descr).iterator();
				 it.hasNext();
				) {
					 PluginDescriptor depDescr = (PluginDescriptor) it.next();
					 removingPlugins.put(depDescr.getId(), depDescr);
					 registryChangeData.removedPlugins().add(depDescr.getId());
				 }
				 removingPlugins.put(descr.getId(), descr);
				 registryChangeData.removedPlugins().add(descr.getId());
				 continue;
			 }
			 PluginFragment fragment = (PluginFragment) registeredFragments.get(ids[i]);
			 if (fragment != null) {
				 removingFragments.put(fragment.getId(), fragment);
				 continue;
			 }
			 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_WARNING, null, ReportItem.ERROR_NO_ERROR, ""pluginToUngregisterNotFound"", ids[i]));
		 }
		 for (Iterator it = removingPlugins.values().iterator();
		 it.hasNext();
		) {
			 PluginDescriptor descr = (PluginDescriptor) it.next();
			 for (Iterator it2 = descr.getFragments().iterator();
			 it2.hasNext();
			) {
				 PluginFragment fragment = (PluginFragment) it2.next();
				 if (removingFragments.containsKey(fragment.getId())) {
					 continue;
				 }
				 removingFragments.put(fragment.getId(), fragment);
			 }
		 }
		 fireEvent(registryChangeData);
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""unregisteringFragmentsStart"", null));
		 for (Iterator it = removingFragments.values().iterator();
		 it.hasNext();
		) {
			 PluginFragmentImpl fragment = (PluginFragmentImpl) it.next();
			 unregisterFragment(fragment);
			 if (!removingPlugins.containsKey(fragment.getPluginId())) {
				 registryChangeData.modifiedPlugins().add( fragment.getPluginId());
			 }
			 result.add(fragment.getUniqueId());
		 }
		 removingFragments.clear();
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""unregisteringPluginsStart"", null));
		 for (Iterator it = removingPlugins.values().iterator();
		 it.hasNext();
		) {
			 PluginDescriptorImpl descr = (PluginDescriptorImpl) it.next();
			 unregisterPlugin(descr);
			 result.add(descr.getUniqueId());
		 }
		 removingPlugins.clear();
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""unregisteringPluginsFinish"", new Integer(registeredPlugins.size())));
		 registrationReport.add(new ReportItemImpl(ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""unregisteringFragmentsFinish"", new Integer(registeredFragments.size())));
		 log.info(""plug-in and fragment descriptors unregistered - "" + result.size());
		 dump();
		 if (result.isEmpty()) {
			 return result;
		 }
		 for (Iterator it = registeredPoints.iterator();
		 it.hasNext();
		) {
			 ((ExtensionPointImpl) it.next()).registryChanged();
		 }
		 for (Iterator it = registeredExtensions.values().iterator();
		 it.hasNext();
		) {
			 ((ExtensionImpl) it.next()).registryChanged();
		 }
		 if (!listeners.isEmpty() || log.isDebugEnabled()) {
			 for (Iterator it = registeredPlugins.values().iterator();
			 it.hasNext();
			) {
				 for (Iterator it2 = ((PluginDescriptor) it.next()) .getExtensionPoints().iterator();
				 it2.hasNext();
				) {
					 for (Iterator it3 = ((ExtensionPoint) it2.next()) .getConnectedExtensions().iterator();
					 it3.hasNext();
					) {
						 Extension ext = (Extension) it3.next();
						 if (!registeredExtensions.containsKey( ext.getUniqueId())) {
							 registryChangeData.putAddedExtension( ext.getUniqueId(), makeUniqueId(ext.getExtendedPluginId(), ext.getExtendedPointId()));
						 }
						 else {
							 registeredExtensions.remove(ext.getUniqueId());
							 if (registryChangeData.modifiedPlugins().contains( ext.getDeclaringPluginDescriptor().getId()) || registryChangeData.modifiedPlugins() .contains(ext.getExtendedPluginId())) {
								 registryChangeData.putModifiedExtension( ext.getUniqueId(), makeUniqueId(ext.getExtendedPluginId(), ext.getExtendedPointId()));
							 }
						 }
					 }
				 }
			 }
			 for (Iterator it = registeredExtensions.values().iterator();
			 it.hasNext();
			) {
				 Extension ext = (Extension) it.next();
				 registryChangeData.putRemovedExtension(ext.getUniqueId(), makeUniqueId(ext.getExtendedPluginId(), ext.getExtendedPointId()));
			 }
			 fireEvent(registryChangeData);
		 }
		 return result;
	 }
	 private void unregisterPlugin(final PluginDescriptorImpl descr) {
		 registeredPlugins.remove(descr.getId());
		 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""pluginUnregistered"", descr.getUniqueId()));
	 }
	 private void unregisterFragment(final PluginFragmentImpl fragment) {
		 PluginDescriptorImpl descr = (PluginDescriptorImpl) registeredPlugins.get( fragment.getPluginId());
		 if (descr != null) {
			 descr.unregisterFragment(fragment);
		 }
		 registeredFragments.remove(fragment.getId());
		 registrationReport.add(new ReportItemImpl( ReportItem.SEVERITY_INFO, null, ReportItem.ERROR_NO_ERROR, ""fragmentUnregistered"", fragment.getUniqueId()));
	 }
	 private void dump() {
		 if (!log.isDebugEnabled()) {
			 return;
		 }
		 StringBuffer buf = new StringBuffer();
		 buf.append(""PLUG-IN REGISTRY DUMP:\r\n"") .append(""-------------- DUMP BEGIN -----------------\r\n"") .append(""\tPlug-ins: "" + registeredPlugins.size() + ""\r\n"");
		 for (Iterator it = registeredPlugins.values().iterator();
		 it.hasNext();
		) {
			 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
		 }
		 buf.append(""\tFragments: "" + registeredFragments.size() + ""\r\n"");
		 for (Iterator it = registeredFragments.values().iterator();
		 it.hasNext();
		) {
			 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
		 }
		 buf.append(""Memory TOTAL/FREE/MAX: "") .append(Runtime.getRuntime().totalMemory()) .append(""/"") .append(Runtime.getRuntime().freeMemory()) .append(""/"") .append(Runtime.getRuntime().maxMemory()) .append(""\r\n"");
		 buf.append(""-------------- DUMP END -----------------\r\n"");
		 log.debug(buf.toString());
	 }
	 public ExtensionPoint getExtensionPoint(final String pluginId, final String pointId) {
		 PluginDescriptor descriptor = (PluginDescriptor) registeredPlugins.get(pluginId);
		 if (descriptor == null) {
			 throw new IllegalArgumentException(""unknown plug-in ID "" + pluginId + "" provided for extension point "" + pointId);
		 }
		 for (Iterator it = descriptor.getExtensionPoints().iterator();
		 it.hasNext();
		) {
			 ExtensionPoint point = (ExtensionPoint) it.next();
			 if (point.getId().equals(pointId)) {
				 if (point.isValid()) {
					 return point;
				 }
				 log.warn(""extension point "" + point.getUniqueId() + "" is invalid and ignored by registry"");
				 break;
			 }
		 }
		 throw new IllegalArgumentException(""unknown extension point ID - "" + makeUniqueId(pluginId, pointId));
	 }
	 public ExtensionPoint getExtensionPoint(final String uniqueId) {
		 return getExtensionPoint(extractPluginId(uniqueId), extractId(uniqueId));
	 }
	 public boolean isExtensionPointAvailable(final String pluginId, final String pointId) {
		 PluginDescriptor descriptor = (PluginDescriptor) registeredPlugins.get(pluginId);
		 if (descriptor == null) {
			 return false;
		 }
		 for (Iterator it = descriptor.getExtensionPoints().iterator();
		 it.hasNext();
		) {
			 ExtensionPoint point = (ExtensionPoint) it.next();
			 if (point.getId().equals(pointId)) {
				 return point.isValid();
			 }
		 }
		 return false;
	 }
	 public boolean isExtensionPointAvailable(final String uniqueId) {
		 return isExtensionPointAvailable(extractPluginId(uniqueId), extractId(uniqueId));
	 }
	 public PluginDescriptor getPluginDescriptor(final String pluginId) {
		 PluginDescriptor result = (PluginDescriptor) registeredPlugins.get(pluginId);
		 if (result == null) {
			 throw new IllegalArgumentException(""unknown plug-in ID - "" + pluginId);
		 }
		 return result;
	 }
	 public boolean isPluginDescriptorAvailable(final String pluginId) {
		 return registeredPlugins.containsKey(pluginId);
	 }
	 public Collection getPluginDescriptors() {
		 return registeredPlugins.isEmpty() ? Collections.EMPTY_LIST : Collections.unmodifiableCollection( registeredPlugins.values());
	 }
	 public Collection getPluginFragments() {
		 return registeredFragments.isEmpty() ? Collections.EMPTY_LIST : Collections.unmodifiableCollection( registeredFragments.values());
	 }
	 public Collection getDependingPlugins(final PluginDescriptor descr) {
		 Map result = new HashMap();
		 for (Iterator it = getPluginDescriptors().iterator();
		 it.hasNext();
		) {
			 PluginDescriptor dependedDescr = (PluginDescriptor) it.next();
			 if (dependedDescr.getId().equals(descr.getId())) {
				 continue;
			 }
			 for (Iterator it2 = dependedDescr.getPrerequisites().iterator();
			 it2.hasNext();
			) {
				 PluginPrerequisite pre = (PluginPrerequisite) it2.next();
				 if (!pre.getPluginId().equals(descr.getId()) || !pre.matches()) {
					 continue;
				 }
				 if (!result.containsKey(dependedDescr.getId())) {
					 result.put(dependedDescr.getId(), dependedDescr);
					 for (Iterator it3 = getDependingPlugins(dependedDescr).iterator();
					 it3.hasNext();
					) {
						 PluginDescriptor descriptor = (PluginDescriptor) it3.next();
						 if (!result.containsKey(descriptor.getId())) {
							 result.put(descriptor.getId(), descriptor);
						 }
					 }
				 }
				 break;
			 }
		 }
		 return result.values();
	 }
	 public IntegrityCheckReport checkIntegrity( final PathResolver pathResolver) {
		 return checkIntegrity(pathResolver, false);
	 }
	 public IntegrityCheckReport checkIntegrity(final PathResolver pathResolver, final boolean includeRegistrationReport) {
		 IntegrityChecker intergityCheckReport = new IntegrityChecker(this, includeRegistrationReport ? registrationReport : Collections.EMPTY_LIST);
		 intergityCheckReport.doCheck(pathResolver);
		 return intergityCheckReport;
	 }
	 public IntegrityCheckReport getRegistrationReport() {
		 return new IntegrityChecker(this, registrationReport);
	 }
	 public String makeUniqueId(final String pluginId, final String id) {
		 return pluginId + UNIQUE_SEPARATOR + id;
	 }
	 public String makeUniqueId(final String pluginId, final Version version) {
		 return pluginId + UNIQUE_SEPARATOR + version;
	 }
	 public String extractPluginId(final String uniqueId) {
		 int p = uniqueId.indexOf(UNIQUE_SEPARATOR);
		 if ((p <= 0) || (p >= (uniqueId.length() - 1))) {
			 throw new IllegalArgumentException(""invalid unique ID - "" + uniqueId);
		 }
		 return uniqueId.substring(0, p);
	 }
	 public String extractId(final String uniqueId) {
		 int p = uniqueId.indexOf(UNIQUE_SEPARATOR);
		 if ((p <= 0) || (p >= (uniqueId.length() - 1))) {
			 throw new IllegalArgumentException(""invalid unique ID - "" + uniqueId);
		 }
		 return uniqueId.substring(p + 1);
	 }
	 public Version extractVersion(final String uniqueId) {
		 int p = uniqueId.indexOf(UNIQUE_SEPARATOR);
		 if ((p <= 0) || (p >= (uniqueId.length() - 1))) {
			 throw new IllegalArgumentException(""invalid unique ID - "" + uniqueId);
		 }
		 return Version.parse(uniqueId.substring(p + 1));
	 }
	 public void registerListener(final RegistryChangeListener listener) {
		 if (listeners.contains(listener)) {
			 throw new IllegalArgumentException(""listener "" + listener + "" already registered"");
		 }
		 listeners.add(listener);
	 }
	 public void unregisterListener(final RegistryChangeListener listener) {
		 if (!listeners.remove(listener)) {
			 log.warn(""unknown listener "" + listener);
		 }
	 }
	 void fireEvent(final RegistryChangeDataImpl data) {
		 data.dump();
		 if (listeners.isEmpty()) {
			 return;
		 }
		 RegistryChangeListener[] arr = (RegistryChangeListener[]) listeners.toArray( new RegistryChangeListener[listeners.size()]);
		 data.beforeEventFire();
		 if (log.isDebugEnabled()) {
			 log.debug(""propagating registry change event"");
		 }
		 for (int i = 0;
		 i < arr.length;
		 i++) {
			 arr[i].registryChanged(data);
		 }
		 if (log.isDebugEnabled()) {
			 log.debug(""registry change event propagated"");
		 }
		 data.afterEventFire();
	 }
	 private static final class RegistryChangeDataImpl implements RegistryChangeData {
		 private Set addedPlugins;
		 private Set removedPlugins;
		 private Set modifiedPlugins;
		 private Map addedExtensions;
		 private Map removedExtensions;
		 private Map modifiedExtensions;
		 protected RegistryChangeDataImpl() {
			 reset();
		 }
		 private void reset() {
			 addedPlugins = new HashSet();
			 removedPlugins = new HashSet();
			 modifiedPlugins = new HashSet();
			 addedExtensions = new HashMap();
			 removedExtensions = new HashMap();
			 modifiedExtensions = new HashMap();
		 }
		 protected void beforeEventFire() {
			 addedPlugins = Collections.unmodifiableSet(addedPlugins);
			 removedPlugins = Collections.unmodifiableSet(removedPlugins);
			 modifiedPlugins = Collections.unmodifiableSet(modifiedPlugins);
			 addedExtensions = Collections.unmodifiableMap(addedExtensions);
			 removedExtensions = Collections.unmodifiableMap(removedExtensions);
			 modifiedExtensions = Collections.unmodifiableMap(modifiedExtensions);
		 }
		 protected void afterEventFire() {
			 reset();
		 }
		 protected void dump() {
			 Log logger = LogFactory.getLog(getClass());
			 if (!logger.isDebugEnabled()) {
				 return;
			 }
			 StringBuffer buf = new StringBuffer();
			 buf.append(""PLUG-IN REGISTRY CHANGES DUMP:\r\n"") .append(""-------------- DUMP BEGIN -----------------\r\n"") .append(""\tAdded plug-ins: "" + addedPlugins.size() + ""\r\n"");
			 for (Iterator it = addedPlugins.iterator();
			 it.hasNext();
			) {
				 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
			 }
			 buf.append(""\tRemoved plug-ins: "" + removedPlugins.size() + ""\r\n"");
			 for (Iterator it = removedPlugins.iterator();
			 it.hasNext();
			) {
				 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
			 }
			 buf.append(""\tModified plug-ins: "" + modifiedPlugins.size() + ""\r\n"");
			 for (Iterator it = modifiedPlugins.iterator();
			 it.hasNext();
			) {
				 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
			 }
			 buf.append(""\tAdded extensions: "" + addedExtensions.size() + ""\r\n"");
			 for (Iterator it = addedExtensions.entrySet().iterator();
			 it.hasNext();
			) {
				 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
			 }
			 buf.append(""\tRemoved extensions: "" + removedExtensions.size() + ""\r\n"");
			 for (Iterator it = removedExtensions.entrySet().iterator();
			 it.hasNext();
			) {
				 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
			 }
			 buf.append(""\tModified extensions: "" + modifiedExtensions.size() + ""\r\n"");
			 for (Iterator it = modifiedExtensions.entrySet().iterator();
			 it.hasNext();
			) {
				 buf.append(""\t\t"") .append(it.next()) .append(""\r\n"");
			 }
			 buf.append(""Memory TOTAL/FREE/MAX: "") .append(Runtime.getRuntime().totalMemory()) .append(""/"") .append(Runtime.getRuntime().freeMemory()) .append(""/"") .append(Runtime.getRuntime().maxMemory()) .append(""\r\n"");
			 buf.append(""-------------- DUMP END -----------------\r\n"");
			 logger.debug(buf.toString());
		 }
		 public Set addedPlugins() {
			 return addedPlugins;
		 }
		 public Set removedPlugins() {
			 return removedPlugins;
		 }
		 public Set modifiedPlugins() {
			 return modifiedPlugins;
		 }
		 void putAddedExtension(final String extensionUid, final String extensionPointUid) {
			 addedExtensions.put(extensionUid, extensionPointUid);
		 }
		 public Set addedExtensions() {
			 return addedExtensions.keySet();
		 }
		 public Set addedExtensions(final String extensionPointUid) {
			 Set result = new HashSet();
			 for (Iterator it = addedExtensions.entrySet().iterator();
			 it.hasNext();
			) {
				 Map.Entry entry = (Map.Entry) it.next();
				 if (entry.getValue().equals(extensionPointUid)) {
					 result.add(entry.getKey());
				 }
			 }
			 return Collections.unmodifiableSet(result);
		 }
		 void putRemovedExtension(final String extensionUid, final String extensionPointUid) {
			 removedExtensions.put(extensionUid, extensionPointUid);
		 }
		 public Set removedExtensions() {
			 return removedExtensions.keySet();
		 }
		 public Set removedExtensions(final String extensionPointUid) {
			 Set result = new HashSet();
			 for (Iterator it = removedExtensions.entrySet().iterator();
			 it.hasNext();
			) {
				 Map.Entry entry = (Map.Entry) it.next();
				 if (entry.getValue().equals(extensionPointUid)) {
					 result.add(entry.getKey());
				 }
			 }
			 return Collections.unmodifiableSet(result);
		 }
		 void putModifiedExtension(final String extensionUid, final String extensionPointUid) {
			 modifiedExtensions.put(extensionUid, extensionPointUid);
		 }
		 public Set modifiedExtensions() {
			 return modifiedExtensions.keySet();
		 }
		 public Set modifiedExtensions(final String extensionPointUid) {
			 Set result = new HashSet();
			 for (Iterator it = modifiedExtensions.entrySet().iterator();
			 it.hasNext();
			) {
				 Map.Entry entry = (Map.Entry) it.next();
				 if (entry.getValue().equals(extensionPointUid)) {
					 result.add(entry.getKey());
				 }
			 }
			 return Collections.unmodifiableSet(result);
		 }
	 }
	 private static final class ManifestInfoImpl implements ManifestInfo {
		 private final ModelManifestInfo model;
		 ManifestInfoImpl(final ModelManifestInfo aModel) {
			 model = aModel;
		 }
		 public String getId() {
			 return model.getId();
		 }
		 public Version getVersion() {
			 return model.getVersion();
		 }
		 public String getVendor() {
			 return model.getVendor();
		 }
		 public String getPluginId() {
			 return model.getPluginId();
		 }
		 public Version getPluginVersion() {
			 return model.getPluginVersion();
		 }
		 public String getMatchingRule() {
			 return model.getMatch();
		 }
	 }
}",1,0,0,0
"public class SessionImpl extends AbstractSession implements JackrabbitSession, SessionExtensions, NamespaceResolver, NamePathResolver, IdentifierResolver {
	 public static final String DISABLE_CLUSTER_SYNC_ON_REFRESH = ""org.apache.jackrabbit.disableClusterSyncOnRefresh"";
	 public static final String AUTO_FIX_CORRUPTIONS = ""org.apache.jackrabbit.autoFixCorruptions"";
	 private static Logger log = LoggerFactory.getLogger(SessionImpl.class);
	 private static final AtomicLong SESSION_COUNTER = new AtomicLong();
	 protected final SessionContext context;
	 protected final RepositoryContext repositoryContext;
	 protected AuthContext loginContext;
	 protected final Subject subject;
	 protected final String userId;
	 private final String sessionName;
	 protected final Map<String, Object> attributes = new HashMap<String, Object>();
	 protected NamePathResolver namePathResolver;
	 protected final InternalVersionManager versionMgr;
	 protected final Map<SessionListener, SessionListener> listeners = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);
	 private PrincipalManager principalManager;
	 private UserManager userManager;
	 private RetentionManager retentionManager;
	 private final Exception openStackTrace;
	 protected SessionImpl( RepositoryContext repositoryContext, AuthContext loginContext, WorkspaceConfig wspConfig) throws AccessDeniedException, RepositoryException {
		 this(repositoryContext, loginContext.getSubject(), wspConfig);
		 this.loginContext = loginContext;
	 }
	 protected SessionImpl( RepositoryContext repositoryContext, Subject subject, WorkspaceConfig wspConfig) throws AccessDeniedException, RepositoryException {
		 this.context = new SessionContext(repositoryContext, this, wspConfig);
		 this.repositoryContext = repositoryContext;
		 this.subject = subject;
		 this.userId = retrieveUserId(subject, wspConfig.getName());
		 long count = SESSION_COUNTER.incrementAndGet();
		 if (userId != null) {
			 String user = Text.escapeIllegalJcrChars(userId);
			 this.sessionName = ""session-"" + user + ""-"" + count;
		 }
		 else {
			 this.sessionName = ""session-"" + count;
		 }
		 this.namePathResolver = new DefaultNamePathResolver(this, this, true);
		 this.context.setItemStateManager(createSessionItemStateManager());
		 this.context.setItemManager(createItemManager());
		 this.context.setAccessManager(createAccessManager(subject));
		 this.context.setObservationManager(createObservationManager(wspConfig.getName()));
		 this.versionMgr = createVersionManager();
		 this.openStackTrace = log.isWarnEnabled() ? new Exception(""Stack Trace"") : null;
	 }
	 protected String retrieveUserId(Subject subject, String workspaceName) throws RepositoryException {
		 return repositoryContext.getSecurityManager().getUserID( subject, workspaceName);
	 }
	 protected SessionItemStateManager createSessionItemStateManager() {
		 SessionItemStateManager mgr = new SessionItemStateManager( context.getRootNodeId(), context.getWorkspace().getItemStateManager());
		 context.getWorkspace().getItemStateManager().addListener(mgr);
		 return mgr;
	 }
	 protected ItemManager createItemManager() {
		 ItemManager mgr = new ItemManager(context);
		 context.getItemStateManager().addListener(mgr);
		 return mgr;
	 }
	 protected ObservationManagerImpl createObservationManager(String wspName) throws RepositoryException {
		 try {
			 return new ObservationManagerImpl( context.getRepository().getObservationDispatcher(wspName), this, context.getRepositoryContext().getClusterNode());
		 }
		 catch (NoSuchWorkspaceException e) {
			 throw new RepositoryException( ""Internal error: failed to create observation manager"", e);
		 }
	 }
	 protected InternalVersionManager createVersionManager() throws RepositoryException {
		 return context.getRepositoryContext().getInternalVersionManager();
	 }
	 protected AccessManager createAccessManager(Subject subject) throws AccessDeniedException, RepositoryException {
		 String wspName = getWorkspace().getName();
		 AMContext ctx = new AMContext( new File(context.getRepository().getConfig().getHomeDir()), context.getRepositoryContext().getFileSystem(), this, subject, context.getHierarchyManager(), context.getPrivilegeManager(), this, wspName);
		 return repositoryContext.getSecurityManager().getAccessManager(this, ctx);
	 }
	 private <T> T perform(SessionOperation<T> operation) throws RepositoryException {
		 return context.getSessionState().perform(operation);
	 }
	 private void sanityCheck() throws RepositoryException {
		 context.getSessionState().checkAlive();
	 }
	 public Subject getSubject() {
		 Subject readOnly = new Subject(true, subject.getPrincipals(), subject.getPublicCredentials(), subject.getPrivateCredentials());
		 return readOnly;
	 }
	 public boolean isSystem() {
		 return (subject != null && !subject.getPrincipals(SystemPrincipal.class).isEmpty());
	 }
	 public boolean isAdmin() {
		 if (userManager != null) {
			 try {
				 Authorizable a = userManager.getAuthorizable(userId);
				 if (a != null && !a.isGroup()) {
					 return ((User) a).isAdmin();
				 }
			 }
			 catch (RepositoryException e) {
			 }
		 }
		 return (subject != null && !subject.getPrincipals(AdminPrincipal.class).isEmpty());
	 }
	 public Session createSession(String workspaceName) throws AccessDeniedException, NoSuchWorkspaceException, RepositoryException {
		 if (workspaceName == null) {
			 workspaceName = repositoryContext.getWorkspaceManager().getDefaultWorkspaceName();
		 }
		 Subject newSubject = new Subject(subject.isReadOnly(), subject.getPrincipals(), subject.getPublicCredentials(), subject.getPrivateCredentials());
		 return repositoryContext.getWorkspaceManager().createSession( newSubject, workspaceName);
	 }
	 public AccessManager getAccessManager() {
		 return context.getAccessManager();
	 }
	 public NodeTypeManagerImpl getNodeTypeManager() {
		 return context.getNodeTypeManager();
	 }
	 public ItemManager getItemManager() {
		 return context.getItemManager();
	 }
	 public HierarchyManager getHierarchyManager() {
		 return context.getHierarchyManager();
	 }
	 public InternalVersionManager getInternalVersionManager() {
		 return versionMgr;
	 }
	 protected RetentionRegistry getRetentionRegistry() throws RepositoryException {
		 return context.getWorkspace().getRetentionRegistry();
	 }
	 public void setAttribute(String name, Object value) {
		 if (value != null) {
			 attributes.put(name, value);
		 }
		 else {
			 attributes.remove(name);
		 }
	 }
	 public NodeImpl getNodeById(NodeId id) throws ItemNotFoundException, RepositoryException {
		 sanityCheck();
		 try {
			 return (NodeImpl) getItemManager().getItem(id);
		 }
		 catch (AccessDeniedException ade) {
			 throw new ItemNotFoundException(id.toString());
		 }
	 }
	 protected void notifyLoggingOut() {
		 List<SessionListener> copy = new ArrayList<SessionListener>(listeners.values());
		 for (SessionListener listener : copy) {
			 if (listener != null) {
				 listener.loggingOut(this);
			 }
		 }
	 }
	 protected void notifyLoggedOut() {
		 List<SessionListener> copy = new ArrayList<SessionListener>(listeners.values());
		 for (SessionListener listener : copy) {
			 if (listener != null) {
				 listener.loggedOut(this);
			 }
		 }
	 }
	 public void addListener(SessionListener listener) {
		 if (!listeners.containsKey(listener)) {
			 listeners.put(listener, listener);
		 }
	 }
	 public void removeListener(SessionListener listener) {
		 listeners.remove(listener);
	 }
	 public GarbageCollector createDataStoreGarbageCollector() throws RepositoryException {
		 final GarbageCollector gc = repositoryContext.getRepository().createDataStoreGarbageCollector();
		 addListener(new SessionListener() {
			 public void loggedOut(SessionImpl session) {
			 }
			 public void loggingOut(SessionImpl session) {
				 gc.close();
			 }
		 }
		);
		 return gc;
	 }
	 public String getPrefix(String uri) throws NamespaceException {
		 try {
			 return getNamespacePrefix(uri);
		 }
		 catch (NamespaceException e) {
			 throw e;
		 }
		 catch (RepositoryException e) {
			 throw new NamespaceException(""Namespace not found: "" + uri, e);
		 }
	 }
	 public String getURI(String prefix) throws NamespaceException {
		 try {
			 return getNamespaceURI(prefix);
		 }
		 catch (NamespaceException e) {
			 throw e;
		 }
		 catch (RepositoryException e) {
			 throw new NamespaceException(""Namespace not found: "" + prefix, e);
		 }
	 }
	 public String getJCRName(Name name) throws NamespaceException {
		 return namePathResolver.getJCRName(name);
	 }
	 public Name getQName(String name) throws IllegalNameException, NamespaceException {
		 return namePathResolver.getQName(name);
	 }
	 public String getJCRPath(Path path) throws NamespaceException {
		 return namePathResolver.getJCRPath(path);
	 }
	 public Path getQPath(String path) throws MalformedPathException, IllegalNameException, NamespaceException {
		 return namePathResolver.getQPath(path);
	 }
	 public Path getQPath(String path, boolean normalizeIdentifier) throws MalformedPathException, IllegalNameException, NamespaceException {
		 return namePathResolver.getQPath(path, normalizeIdentifier);
	 }
	 public Path getPath(String identifier) throws MalformedPathException {
		 try {
			 return context.getHierarchyManager().getPath(NodeId.valueOf(identifier));
		 }
		 catch (RepositoryException e) {
			 throw new MalformedPathException(""Identifier '"" + identifier + ""' cannot be resolved."");
		 }
	 }
	 public void checkFormat(String identifier) throws MalformedPathException {
		 try {
			 NodeId.valueOf(identifier);
		 }
		 catch (IllegalArgumentException e) {
			 throw new MalformedPathException(""Invalid identifier: "" + identifier);
		 }
	 }
	 public boolean hasPermission(String absPath, String... actions) throws RepositoryException {
		 return hasPermission(absPath, Text.implode(actions, "",""));
	 }
	 public PrincipalManager getPrincipalManager() throws RepositoryException, AccessDeniedException {
		 if (principalManager == null) {
			 principalManager = repositoryContext.getSecurityManager().getPrincipalManager(this);
		 }
		 return principalManager;
	 }
	 public UserManager getUserManager() throws AccessDeniedException, RepositoryException {
		 if (userManager == null) {
			 userManager = repositoryContext.getSecurityManager().getUserManager(this);
		 }
		 return userManager;
	 }
	 public Item getItemOrNull(String absPath) throws RepositoryException {
		 if (itemExists(absPath)) {
			 return getItem(absPath);
		 }
		 else {
			 return null;
		 }
	 }
	 public Property getPropertyOrNull(String absPath) throws RepositoryException {
		 if (propertyExists(absPath)) {
			 return getProperty(absPath);
		 }
		 else {
			 return null;
		 }
	 }
	 public Node getNodeOrNull(String absPath) throws RepositoryException {
		 if (nodeExists(absPath)) {
			 return getNode(absPath);
		 }
		 else {
			 return null;
		 }
	 }
	 public void checkPermission(String absPath, String actions) throws AccessControlException, RepositoryException {
		 if (!hasPermission(absPath, actions)) {
			 throw new AccessControlException(actions);
		 }
	 }
	 public Workspace getWorkspace() {
		 return context.getWorkspace();
	 }
	 public Session impersonate(Credentials otherCredentials) throws LoginException, RepositoryException {
		 sanityCheck();
		 if (!(otherCredentials instanceof SimpleCredentials)) {
			 String msg = ""impersonate failed: incompatible credentials, SimpleCredentials expected"";
			 log.debug(msg);
			 throw new RepositoryException(msg);
		 }
		 SimpleCredentials creds = (SimpleCredentials) otherCredentials;
		 creds.setAttribute(SecurityConstants.IMPERSONATOR_ATTRIBUTE, subject);
		 try {
			 return getRepository().login( otherCredentials, getWorkspace().getName());
		 }
		 catch (NoSuchWorkspaceException nswe) {
			 String msg = ""impersonate failed"";
			 log.error(msg, nswe);
			 throw new RepositoryException(msg, nswe);
		 }
		 finally {
			 creds.removeAttribute(SecurityConstants.IMPERSONATOR_ATTRIBUTE);
		 }
	 }
	 public Node getRootNode() throws RepositoryException {
		 sanityCheck();
		 return getItemManager().getRootNode();
	 }
	 public Node getNodeByUUID(String uuid) throws ItemNotFoundException, RepositoryException {
		 try {
			 NodeImpl node = getNodeById(new NodeId(uuid));
			 if (node.isNodeType(NameConstants.MIX_REFERENCEABLE)) {
				 return node;
			 }
			 else {
				 throw new ItemNotFoundException(uuid);
			 }
		 }
		 catch (IllegalArgumentException e) {
			 throw new RepositoryException(""Invalid UUID: "" + uuid, e);
		 }
	 }
	 public Item getItem(String absPath) throws RepositoryException {
		 return perform(SessionItemOperation.getItem(absPath));
	 }
	 public boolean itemExists(String absPath) throws RepositoryException {
		 if (absPath != null && absPath.startsWith(""["") && absPath.endsWith(""]"")) {
			 try {
				 NodeId id = NodeId.valueOf(absPath.substring(1, absPath.length() - 1));
				 return getItemManager().itemExists(id);
			 }
			 catch (IllegalArgumentException e) {
				 throw new MalformedPathException(absPath);
			 }
		 }
		 return perform(SessionItemOperation.itemExists(absPath));
	 }
	 public void save() throws RepositoryException {
		 if (context.getItemStateManager().hasAnyTransientItemStates()) {
			 perform(new SessionSaveOperation());
		 }
	 }
	 public void refresh(boolean keepChanges) throws RepositoryException {
		 perform(new SessionRefreshOperation( keepChanges, clusterSyncOnRefresh()));
	 }
	 protected boolean clusterSyncOnRefresh() {
		 return getAttribute(DISABLE_CLUSTER_SYNC_ON_REFRESH) == null;
	 }
	 protected boolean autoFixCorruptions() {
		 return getAttribute(AUTO_FIX_CORRUPTIONS) != null;
	 }
	 public boolean hasPendingChanges() throws RepositoryException {
		 sanityCheck();
		 return context.getItemStateManager().hasAnyTransientItemStates();
	 }
	 public void move(String srcAbsPath, String destAbsPath) throws RepositoryException {
		 perform(new SessionMoveOperation(this, srcAbsPath, destAbsPath));
	 }
	 public ContentHandler getImportContentHandler(String parentAbsPath, int uuidBehavior) throws PathNotFoundException, ConstraintViolationException, VersionException, LockException, RepositoryException {
		 sanityCheck();
		 NodeImpl parent;
		 try {
			 Path p = getQPath(parentAbsPath).getNormalizedPath();
			 if (!p.isAbsolute()) {
				 throw new RepositoryException(""not an absolute path: "" + parentAbsPath);
			 }
			 parent = getItemManager().getNode(p);
		 }
		 catch (NameException e) {
			 String msg = parentAbsPath + "": invalid path"";
			 log.debug(msg);
			 throw new RepositoryException(msg, e);
		 }
		 catch (AccessDeniedException ade) {
			 throw new PathNotFoundException(parentAbsPath);
		 }
		 int options = ItemValidator.CHECK_LOCK | ItemValidator.CHECK_CHECKED_OUT | ItemValidator.CHECK_CONSTRAINTS | ItemValidator.CHECK_HOLD | ItemValidator.CHECK_RETENTION;
		 context.getItemValidator().checkModify(parent, options, Permission.NONE);
		 SessionImporter importer = new SessionImporter( parent, this, uuidBehavior, context.getWorkspace().getConfig().getImportConfig());
		 return new ImportHandler(importer, this);
	 }
	 public boolean isLive() {
		 return context.getSessionState().isAlive();
	 }
	 private void removeRegisteredEventListeners() {
		 try {
			 ObservationManager manager = getWorkspace().getObservationManager();
			 Collection<EventListener> listeners = IteratorUtils.toList(manager.getRegisteredEventListeners());
			 for (EventListener listener : listeners) {
				 try {
					 manager.removeEventListener(listener);
				 }
				 catch (RepositoryException e) {
					 log.warn(""Error removing event listener: "" + listener, e);
				 }
			 }
		 }
		 catch (RepositoryException e) {
			 log.warn(""Error removing event listeners"", e);
		 }
	 }
	 public void logout() {
		 if (context.getSessionState().close()) {
			 removeRegisteredEventListeners();
			 context.getItemStateManager().disposeAllTransientItemStates();
			 notifyLoggingOut();
			 context.getPrivilegeManager().dispose();
			 context.getNodeTypeManager().dispose();
			 context.getItemStateManager().dispose();
			 context.getItemManager().dispose();
			 context.getWorkspace().dispose();
			 if (loginContext != null) {
				 try {
					 loginContext.logout();
				 }
				 catch (javax.security.auth.login.LoginException le) {
					 log.warn(""failed to logout current subject: "" + le.getMessage());
				 }
				 loginContext = null;
			 }
			 try {
				 context.getAccessManager().close();
			 }
			 catch (Exception e) {
				 log.warn(""error while closing AccessManager"", e);
			 }
			 notifyLoggedOut();
		 }
	 }
	 public Repository getRepository() {
		 return repositoryContext.getRepository();
	 }
	 public ValueFactory getValueFactory() {
		 return context.getValueFactory();
	 }
	 public String getUserID() {
		 return userId;
	 }
	 public Object getAttribute(String name) {
		 return attributes.get(name);
	 }
	 public String[] getAttributeNames() {
		 return attributes.keySet().toArray(new String[attributes.size()]);
	 }
	 public void setNamespacePrefix(String prefix, String uri) throws NamespaceException, RepositoryException {
		 super.setNamespacePrefix(prefix, uri);
		 namePathResolver = new DefaultNamePathResolver(this, true);
	 }
	 public void addLockToken(String lt) {
		 try {
			 getWorkspace().getLockManager().addLockToken(lt);
		 }
		 catch (RepositoryException e) {
			 log.debug(""Error while adding lock token."");
		 }
	 }
	 public String[] getLockTokens() {
		 try {
			 return getWorkspace().getLockManager().getLockTokens();
		 }
		 catch (RepositoryException e) {
			 log.debug(""Error while accessing lock tokens."");
			 return new String[0];
		 }
	 }
	 public void removeLockToken(String lt) {
		 try {
			 getWorkspace().getLockManager().removeLockToken(lt);
		 }
		 catch (RepositoryException e) {
			 log.debug(""Error while removing lock token."");
		 }
	 }
	 public Lock[] getLocks() {
		 if (!isLive()) {
			 log.error(""failed to retrieve locks: session has been closed"");
			 return new Lock[0];
		 }
		 try {
			 return context.getWorkspace().getInternalLockManager().getLocks(this);
		 }
		 catch (RepositoryException e) {
			 log.error(""Lock manager not available."", e);
			 return new Lock[0];
		 }
	 }
	 public Node getNodeByIdentifier(String id) throws ItemNotFoundException, RepositoryException {
		 NodeId nodeId;
		 try {
			 nodeId = NodeId.valueOf(id);
		 }
		 catch (IllegalArgumentException iae) {
			 throw new RepositoryException(""invalid identifier: "" + id,iae);
		 }
		 return getNodeById(nodeId);
	 }
	 public Node getNode(String absPath) throws RepositoryException {
		 return perform(SessionItemOperation.getNode(absPath));
	 }
	 public Property getProperty(String absPath) throws RepositoryException {
		 return perform(SessionItemOperation.getProperty(absPath));
	 }
	 public boolean nodeExists(String absPath) throws RepositoryException {
		 if (absPath != null && absPath.startsWith(""["") && absPath.endsWith(""]"")) {
			 try {
				 NodeId id = NodeId.valueOf(absPath.substring(1, absPath.length() - 1));
				 return getItemManager().itemExists(id);
			 }
			 catch (IllegalArgumentException e) {
				 throw new MalformedPathException(absPath);
			 }
		 }
		 return perform(SessionItemOperation.nodeExists(absPath));
	 }
	 public boolean propertyExists(String absPath) throws RepositoryException {
		 return perform(SessionItemOperation.propertyExists(absPath));
	 }
	 public void removeItem(String absPath) throws RepositoryException {
		 perform(SessionItemOperation.remove(absPath));
	 }
	 public boolean hasPermission(String absPath, String actions) throws RepositoryException {
		 sanityCheck();
		 Path path = getQPath(absPath).getNormalizedPath();
		 if (!path.isAbsolute()) {
			 throw new RepositoryException(""Absolute path expected. Was:"" + absPath);
		 }
		 Set<String> s = new HashSet<String>(Arrays.asList(actions.split("","")));
		 int permissions = 0;
		 if (s.remove(ACTION_READ)) {
			 permissions |= Permission.READ;
		 }
		 if (s.remove(ACTION_ADD_NODE)) {
			 permissions |= Permission.ADD_NODE;
		 }
		 if (s.remove(ACTION_SET_PROPERTY)) {
			 permissions |= Permission.SET_PROPERTY;
		 }
		 if (s.remove(ACTION_REMOVE)) {
			 if (nodeExists(absPath)) {
				 permissions |= (propertyExists(absPath)) ? (Permission.REMOVE_NODE | Permission.REMOVE_PROPERTY) : Permission.REMOVE_NODE;
			 }
			 else if (propertyExists(absPath)) {
				 permissions |= Permission.REMOVE_PROPERTY;
			 }
			 else {
				 permissions = Permission.REMOVE_NODE | Permission.REMOVE_PROPERTY;
			 }
		 }
		 if (!s.isEmpty()) {
			 throw new IllegalArgumentException(""Unknown actions: "" + s);
		 }
		 try {
			 return context.getAccessManager().isGranted(path, permissions);
		 }
		 catch (AccessDeniedException e) {
			 return false;
		 }
	 }
	 public boolean hasCapability(String methodName, Object target, Object[] arguments) throws RepositoryException {
		 ItemValidator validator = context.getItemValidator();
		 int options = CHECK_CHECKED_OUT | CHECK_LOCK | CHECK_CONSTRAINTS | CHECK_HOLD | CHECK_RETENTION;
		 if (target instanceof Node) {
			 if (methodName.equals(""addNode"") || methodName.equals(""addMixin"") || methodName.equals(""orderBefore"") || methodName.equals(""removeMixin"") || methodName.equals(""removeShare"") || methodName.equals(""removeSharedSet"") || methodName.equals(""setPrimaryType"") || methodName.equals(""setProperty"") || methodName.equals(""update"")) {
				 return validator.canModify((ItemImpl) target, options, Permission.NONE);
			 }
			 else if (methodName.equals(""remove"")) {
				 try {
					 validator.checkRemove((ItemImpl) target, options, Permission.NONE);
				 }
				 catch (RepositoryException e) {
					 return false;
				 }
			 }
		 }
		 else if (target instanceof Property) {
			 if (methodName.equals(""setValue"") || methodName.equals(""save"")) {
				 return validator.canModify((ItemImpl) target, options, Permission.NONE);
			 }
			 else if (methodName.equals(""remove"")) {
				 try {
					 validator.checkRemove((ItemImpl) target, options, Permission.NONE);
				 }
				 catch (RepositoryException e) {
					 return false;
				 }
			 }
		 }
		 return true;
	 }
	 public AccessControlManager getAccessControlManager() throws UnsupportedRepositoryOperationException, RepositoryException {
		 AccessManager accessMgr = context.getAccessManager();
		 if (accessMgr instanceof AccessControlManager) {
			 return (AccessControlManager) accessMgr;
		 }
		 else {
			 throw new UnsupportedRepositoryOperationException( ""Access control discovery is not supported."");
		 }
	 }
	 public RetentionManager getRetentionManager() throws UnsupportedRepositoryOperationException, RepositoryException {
		 sanityCheck();
		 if (retentionManager == null) {
			 getRetentionRegistry();
			 retentionManager = new RetentionManagerImpl(this);
		 }
		 return retentionManager;
	 }
	 public String toString() {
		 return sessionName;
	 }
	 public void finalize() {
		 if (isLive()) {
			 if (openStackTrace != null) {
				 log.warn(""Unclosed session detected. The session was opened here: "", openStackTrace);
			 }
			 logout();
		 }
	 }
}",1,0,0,0
"public void setBufferDebug(boolean debug) {
	 buffer.setDebug(debug);
 }",0,0,0,0
"public class AttributeUtils {
	public static Attribute[] readAttributes(DataInputStream dataInputstream, ConstantPool cpool) {
		try {
			int length = dataInputstream.readUnsignedShort();
			if (length == 0) {
				return Attribute.NoAttributes;
			}
			Attribute[] attrs = new Attribute[length];
			for (int i = 0;
			 i < length;
			 i++) {
				attrs[i] = Attribute.readAttribute(dataInputstream, cpool);
			}
			return attrs;
		}
		 catch (IOException e) {
			throw new ClassFormatException(""IOException whilst reading set of attributes: "" + e.toString());
		}
	}
	public static void writeAttributes(Attribute[] attributes, DataOutputStream file) throws IOException {
		if (attributes == null) {
			file.writeShort(0);
		}
		 else {
			file.writeShort(attributes.length);
			for (int i = 0;
			 i < attributes.length;
			 i++) {
				attributes[i].dump(file);
			}
		}
	}
	public static Signature getSignatureAttribute(Attribute[] attributes) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			if (attributes[i].tag == Constants.ATTR_SIGNATURE) {
				return (Signature) attributes[i];
			}
		}
		return null;
	}
	public static Code getCodeAttribute(Attribute[] attributes) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			if (attributes[i].tag == Constants.ATTR_CODE) {
				return (Code) attributes[i];
			}
		}
		return null;
	}
	public static ExceptionTable getExceptionTableAttribute(Attribute[] attributes) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			if (attributes[i].tag == Constants.ATTR_EXCEPTIONS) {
				return (ExceptionTable) attributes[i];
			}
		}
		return null;
	}
	public static ConstantValue getConstantValueAttribute(Attribute[] attributes) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			if (attributes[i].getTag() == Constants.ATTR_CONSTANT_VALUE) {
				return (ConstantValue) attributes[i];
			}
		}
		return null;
	}
	public static void accept(Attribute[] attributes, ClassVisitor visitor) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			attributes[i].accept(visitor);
		}
	}
	public static boolean hasSyntheticAttribute(Attribute[] attributes) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			if (attributes[i].tag == Constants.ATTR_SYNTHETIC) {
				return true;
			}
		}
		return false;
	}
	public static SourceFile getSourceFileAttribute(Attribute[] attributes) {
		for (int i = 0;
		 i < attributes.length;
		 i++) {
			if (attributes[i].tag == Constants.ATTR_SOURCE_FILE) {
				return (SourceFile) attributes[i];
			}
		}
		return null;
	}
}",1,0,0,0
"static class SimpleBinaryLoader implements Loader {
	 private static final Bytes ROW = Bytes.of(new byte[] {
	'r', '1', 13}
	);
	 public void load(TransactionBase tx, Context context) throws Exception {
		 TestUtil.increment(tx, ROW, new Column(Bytes.of(""a""), Bytes.of(new byte[] {
		0, 9}
		)), 1);
	 }
 }",0,0,0,0
"public interface PropertyPathPart extends EObject{
	 String getName();
	 void setName(String value);
}",0,1,0,0
"public class PatternValidator extends StringValidator{
	private static final long serialVersionUID = 1L;
	private final Pattern pattern;
	private boolean reverse = false;
	public PatternValidator(final String pattern){
		this(Pattern.compile(pattern));
	}
	public PatternValidator(final String pattern, final int flags){
		this(Pattern.compile(pattern, flags));
	}
	public PatternValidator(final Pattern pattern){
		this.pattern = pattern;
	}
	public PatternValidator(final MetaPattern pattern){
		this(pattern.pattern());
	}
	public final Pattern getPattern(){
		return pattern;
	}
	public PatternValidator setReverse(boolean reverse){
		this.reverse = reverse;
		return this;
	}
	protected Map<String, Object> variablesMap(IValidatable<String> validatable){
		final Map<String, Object> map = super.variablesMap(validatable);
		map.put(""pattern"", pattern.pattern());
		return map;
	}
	public String toString(){
		return ""[PatternValidator pattern = "" + pattern + ""]"";
	}
	protected void onValidate(IValidatable<String> validatable){
		if (pattern.matcher(validatable.getValue()).matches() == reverse){
			error(validatable);
		}
	}
}",0,0,0,0
"public class StorageService implements IEndpointStateChangeSubscriber, StorageServiceMBean{
	 private static Logger logger_ = LoggerFactory.getLogger(StorageService.class);
	 public static final int RING_DELAY = getRingDelay();
	 public enum Verb {
		 MUTATION, BINARY, READ_REPAIR, READ, REQUEST_RESPONSE, STREAM_INITIATE, STREAM_INITIATE_DONE, STREAM_REPLY, STREAM_REQUEST, RANGE_SLICE, BOOTSTRAP_TOKEN, TREE_REQUEST, TREE_RESPONSE, JOIN, GOSSIP_DIGEST_SYN, GOSSIP_DIGEST_ACK, GOSSIP_DIGEST_ACK2, DEFINITIONS_ANNOUNCE, DEFINITIONS_UPDATE, TRUNCATE, SCHEMA_CHECK, INDEX_SCAN, REPLICATION_FINISHED, INTERNAL_RESPONSE, COUNTER_MUTATION, STREAMING_REPAIR_REQUEST, STREAMING_REPAIR_RESPONSE, SNAPSHOT, MIGRATION_REQUEST, UNUSED_1, UNUSED_2, UNUSED_3, ;
	 }
	 public static final Verb[] VERBS = Verb.values();
	 public static final EnumMap<StorageService.Verb, Stage> verbStages = new EnumMap<StorageService.Verb, Stage>(StorageService.Verb.class) {
		{
			 put(Verb.MUTATION, Stage.MUTATION);
			 put(Verb.BINARY, Stage.MUTATION);
			 put(Verb.READ_REPAIR, Stage.MUTATION);
			 put(Verb.TRUNCATE, Stage.MUTATION);
			 put(Verb.READ, Stage.READ);
			 put(Verb.REQUEST_RESPONSE, Stage.REQUEST_RESPONSE);
			 put(Verb.STREAM_REPLY, Stage.MISC);
			 put(Verb.STREAM_REQUEST, Stage.STREAM);
			 put(Verb.RANGE_SLICE, Stage.READ);
			 put(Verb.BOOTSTRAP_TOKEN, Stage.MISC);
			 put(Verb.TREE_REQUEST, Stage.ANTI_ENTROPY);
			 put(Verb.TREE_RESPONSE, Stage.ANTI_ENTROPY);
			 put(Verb.STREAMING_REPAIR_REQUEST, Stage.ANTI_ENTROPY);
			 put(Verb.STREAMING_REPAIR_RESPONSE, Stage.ANTI_ENTROPY);
			 put(Verb.GOSSIP_DIGEST_ACK, Stage.GOSSIP);
			 put(Verb.GOSSIP_DIGEST_ACK2, Stage.GOSSIP);
			 put(Verb.GOSSIP_DIGEST_SYN, Stage.GOSSIP);
			 put(Verb.DEFINITIONS_UPDATE, Stage.MIGRATION);
			 put(Verb.SCHEMA_CHECK, Stage.MIGRATION);
			 put(Verb.MIGRATION_REQUEST, Stage.MIGRATION);
			 put(Verb.INDEX_SCAN, Stage.READ);
			 put(Verb.REPLICATION_FINISHED, Stage.MISC);
			 put(Verb.INTERNAL_RESPONSE, Stage.INTERNAL_RESPONSE);
			 put(Verb.COUNTER_MUTATION, Stage.MUTATION);
			 put(Verb.SNAPSHOT, Stage.MISC);
			 put(Verb.UNUSED_1, Stage.INTERNAL_RESPONSE);
			 put(Verb.UNUSED_2, Stage.INTERNAL_RESPONSE);
			 put(Verb.UNUSED_3, Stage.INTERNAL_RESPONSE);
		 }
	}
	;
	 private static int getRingDelay() {
		 String newdelay = System.getProperty(""cassandra.ring_delay_ms"");
		 if (newdelay != null) {
			 logger_.info(""Overriding RING_DELAY to {
			}
			ms"", newdelay);
			 return Integer.parseInt(newdelay);
		 }
		 else return 30 * 1000;
	 }
	 public static final DebuggableScheduledThreadPoolExecutor scheduledTasks = new DebuggableScheduledThreadPoolExecutor(""ScheduledTasks"");
	 public static final DebuggableScheduledThreadPoolExecutor tasks = new DebuggableScheduledThreadPoolExecutor(""NonPeriodicTasks"");
	 public static final DebuggableScheduledThreadPoolExecutor optionalTasks = new DebuggableScheduledThreadPoolExecutor(""OptionalTasks"");
	 static {
		 tasks.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
	 }
	 private TokenMetadata tokenMetadata_ = new TokenMetadata();
	 public VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(getPartitioner());
	 public static final StorageService instance = new StorageService();
	 public static IPartitioner getPartitioner() {
		 return DatabaseDescriptor.getPartitioner();
	 }
	 public Collection<Range<Token>> getLocalRanges(String table) {
		 return getRangesForEndpoint(table, FBUtilities.getBroadcastAddress());
	 }
	 public Range<Token> getLocalPrimaryRange() {
		 return getPrimaryRangeForEndpoint(FBUtilities.getBroadcastAddress());
	 }
	 private final Set<InetAddress> replicatingNodes = Collections.synchronizedSet(new HashSet<InetAddress>());
	 private CassandraDaemon daemon;
	 private InetAddress removingNode;
	 private boolean isBootstrapMode;
	 private boolean isSurveyMode= Boolean.parseBoolean(System.getProperty(""cassandra.write_survey"", ""false""));
	 private boolean isClientMode;
	 private boolean initialized;
	 private volatile boolean joined = false;
	 private static enum Mode {
	 NORMAL, CLIENT, JOINING, LEAVING, DECOMMISSIONED, MOVING, DRAINING, DRAINED }
	 private Mode operationMode;
	 private final MigrationManager migrationManager = new MigrationManager();
	 private volatile int totalCFs, remainingCFs;
	 private static final AtomicInteger nextRepairCommand = new AtomicInteger();
	 public void finishBootstrapping() {
		 isBootstrapMode = false;
	 }
	 public void setToken(Token token) {
		 if (logger_.isDebugEnabled()) logger_.debug(""Setting token to {
		}
		"", token);
		 SystemTable.updateToken(token);
		 tokenMetadata_.updateNormalToken(token, FBUtilities.getBroadcastAddress());
		 Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(getLocalToken()));
		 setMode(Mode.NORMAL, false);
	 }
	 public StorageService() {
		 MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
		 try {
			 mbs.registerMBean(this, new ObjectName(""org.apache.cassandra.db:type=StorageService""));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
		 MessagingService.instance().registerVerbHandlers(Verb.MUTATION, new RowMutationVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.READ_REPAIR, new ReadRepairVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.READ, new ReadVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.RANGE_SLICE, new RangeSliceVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.INDEX_SCAN, new IndexScanVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.COUNTER_MUTATION, new CounterMutationVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.TRUNCATE, new TruncateVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.BOOTSTRAP_TOKEN, new BootStrapper.BootstrapTokenVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.STREAM_REQUEST, new StreamRequestVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.STREAM_REPLY, new StreamReplyVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.REPLICATION_FINISHED, new ReplicationFinishedVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.REQUEST_RESPONSE, new ResponseVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.INTERNAL_RESPONSE, new ResponseVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.TREE_REQUEST, new TreeRequestVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.TREE_RESPONSE, new AntiEntropyService.TreeResponseVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.STREAMING_REPAIR_REQUEST, new StreamingRepairTask.StreamingRepairRequest());
		 MessagingService.instance().registerVerbHandlers(Verb.STREAMING_REPAIR_RESPONSE, new StreamingRepairTask.StreamingRepairResponse());
		 MessagingService.instance().registerVerbHandlers(Verb.GOSSIP_DIGEST_SYN, new GossipDigestSynVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.GOSSIP_DIGEST_ACK, new GossipDigestAckVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.GOSSIP_DIGEST_ACK2, new GossipDigestAck2VerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.DEFINITIONS_UPDATE, new DefinitionsUpdateVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.SCHEMA_CHECK, new SchemaCheckVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.MIGRATION_REQUEST, new MigrationRequestVerbHandler());
		 MessagingService.instance().registerVerbHandlers(Verb.SNAPSHOT, new SnapshotVerbHandler());
		 if (StreamingService.instance == null) throw new RuntimeException(""Streaming service is unavailable."");
	 }
	 public void registerDaemon(CassandraDaemon daemon) {
		 this.daemon = daemon;
	 }
	 public void stopGossiping() {
		 if (initialized) {
			 logger_.warn(""Stopping gossip by operator request"");
			 Gossiper.instance.stop();
			 initialized = false;
		 }
	 }
	 public void startGossiping() {
		 if (!initialized) {
			 logger_.warn(""Starting gossip by operator request"");
			 Gossiper.instance.start((int)(System.currentTimeMillis() / 1000));
			 initialized = true;
		 }
	 }
	 public void startRPCServer() {
		 if (daemon == null) {
			 throw new IllegalStateException(""No configured RPC daemon"");
		 }
		 daemon.startRPCServer();
	 }
	 public void stopRPCServer() {
		 if (daemon == null) {
			 throw new IllegalStateException(""No configured RPC daemon"");
		 }
		 daemon.stopRPCServer();
	 }
	 public boolean isRPCServerRunning() {
		 if (daemon == null) {
			 return false;
		 }
		 return daemon.isRPCServerRunning();
	 }
	 public void stopClient() {
		 Gossiper.instance.unregister(migrationManager);
		 Gossiper.instance.unregister(this);
		 Gossiper.instance.stop();
		 MessagingService.instance().shutdown();
		 try {
			 Thread.sleep(1000L);
		 }
		 catch (InterruptedException e) {
		}
		 StageManager.shutdownNow();
	 }
	 public boolean isInitialized() {
		 return initialized;
	 }
	 public synchronized void initClient() throws IOException, ConfigurationException {
		 initClient(RING_DELAY);
	 }
	 public synchronized void initClient(int delay) throws IOException, ConfigurationException {
		 if (initialized) {
			 if (!isClientMode) throw new UnsupportedOperationException(""StorageService does not support switching modes."");
			 return;
		 }
		 initialized = true;
		 isClientMode = true;
		 logger_.info(""Starting up client gossip"");
		 setMode(Mode.CLIENT, false);
		 Gossiper.instance.register(this);
		 Gossiper.instance.start((int)(System.currentTimeMillis() / 1000));
		 MessagingService.instance().listen(FBUtilities.getLocalAddress());
		 try {
			 Thread.sleep(delay);
		 }
		 catch (Exception ex) {
			 throw new IOError(ex);
		 }
		 Schema.instance.updateVersionAndAnnounce();
	 }
	 public synchronized void initServer() throws IOException, ConfigurationException {
		 initServer(RING_DELAY);
	 }
	 public synchronized void initServer(int delay) throws IOException, ConfigurationException {
		 logger_.info(""Cassandra version: "" + FBUtilities.getReleaseVersionString());
		 logger_.info(""Thrift API version: "" + Constants.VERSION);
		 logger_.info(""CQL supported versions: "" + StringUtils.join(ClientState.getCQLSupportedVersion(), "","") + "" (default: "" + ClientState.DEFAULT_CQL_VERSION + "")"");
		 if (initialized) {
			 if (isClientMode) throw new UnsupportedOperationException(""StorageService does not support switching modes."");
			 return;
		 }
		 initialized = true;
		 isClientMode = false;
		 try {
			 Class.forName(""org.apache.cassandra.service.StorageProxy"");
		 }
		 catch (ClassNotFoundException e) {
			 throw new AssertionError(e);
		 }
		 if (!isClientMode) {
			 new ClientRequestMetrics();
		 }
		 if (Boolean.parseBoolean(System.getProperty(""cassandra.load_ring_state"", ""true""))) {
			 logger_.info(""Loading persisted ring state"");
			 for (Map.Entry<Token, InetAddress> entry : SystemTable.loadTokens().entrySet()) {
				 if (entry.getValue() == FBUtilities.getLocalAddress()) {
					 SystemTable.removeToken(entry.getKey());
				 }
				 else {
					 tokenMetadata_.updateNormalToken(entry.getKey(), entry.getValue());
					 Gossiper.instance.addSavedEndpoint(entry.getValue());
				 }
			 }
		 }
		 if (Boolean.parseBoolean(System.getProperty(""cassandra.renew_counter_id"", ""false""))) {
			 logger_.info(""Renewing local node id (as requested)"");
			 NodeId.renewLocalId();
		 }
		 Thread drainOnShutdown = new Thread(new WrappedRunnable() {
			 public void runMayThrow() throws ExecutionException, InterruptedException, IOException {
				 ThreadPoolExecutor mutationStage = StageManager.getStage(Stage.MUTATION);
				 if (mutationStage.isShutdown()) return;
				 stopRPCServer();
				 optionalTasks.shutdown();
				 Gossiper.instance.stop();
				 MessagingService.instance().shutdown();
				 mutationStage.shutdown();
				 mutationStage.awaitTermination(3600, TimeUnit.SECONDS);
				 StorageProxy.instance.verifyNoHintsInProgress();
				 List<Future<?>> flushes = new ArrayList<Future<?>>();
				 for (Table table : Table.all()) {
					 KSMetaData ksm = Schema.instance.getKSMetaData(table.name);
					 if (!ksm.durableWrites) {
						 for (ColumnFamilyStore cfs : table.getColumnFamilyStores()) {
							 Future<?> future = cfs.forceFlush();
							 if (future != null) flushes.add(future);
						 }
					 }
				 }
				 FBUtilities.waitOnFutures(flushes);
				 CommitLog.instance.shutdownBlocking();
				 tasks.shutdown();
				 if (!tasks.awaitTermination(1, TimeUnit.MINUTES)) logger_.warn(""Miscellaneous task executor still busy after one minute;
				 proceeding with shutdown"");
			 }
		 }
		, ""StorageServiceShutdownHook"");
		 Runtime.getRuntime().addShutdownHook(drainOnShutdown);
		 if (Boolean.parseBoolean(System.getProperty(""cassandra.join_ring"", ""true""))) {
			 joinTokenRing(delay);
		 }
		 else {
			 logger_.info(""Not joining ring as requested. Use JMX (StorageService->joinRing()) to initiate ring joining"");
		 }
	 }
	 private void joinTokenRing(int delay) throws IOException, org.apache.cassandra.config.ConfigurationException {
		 logger_.info(""Starting up server gossip"");
		 joined = true;
		 Gossiper.instance.register(this);
		 Gossiper.instance.register(migrationManager);
		 Gossiper.instance.start(SystemTable.incrementAndGetGeneration());
		 Schema.instance.updateVersionAndAnnounce();
		 Gossiper.instance.addLocalApplicationState(ApplicationState.RPC_ADDRESS, valueFactory.rpcaddress(DatabaseDescriptor.getRpcAddress()));
		 if (null != DatabaseDescriptor.getReplaceToken()) Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.hibernate(true));
		 MessagingService.instance().listen(FBUtilities.getLocalAddress());
		 LoadBroadcaster.instance.startBroadcasting();
		 MigrationManager.passiveAnnounce(Schema.instance.getVersion());
		 Gossiper.instance.addLocalApplicationState(ApplicationState.RELEASE_VERSION, valueFactory.releaseVersion());
		 HintedHandOffManager.instance.start();
		 if (DatabaseDescriptor.isAutoBootstrap() && DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()) && !SystemTable.isBootstrapped()) logger_.info(""This node will not auto bootstrap because it is configured to be a seed node."");
		 InetAddress current = null;
		 Token<?> token;
		 if (DatabaseDescriptor.isAutoBootstrap() && !(SystemTable.isBootstrapped() || DatabaseDescriptor.getSeeds().contains(FBUtilities.getBroadcastAddress()) || !Schema.instance.getNonSystemTables().isEmpty())) {
			 setMode(Mode.JOINING, ""waiting for ring and schema information"", true);
			 try {
				 Thread.sleep(delay);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
			 while (!MigrationManager.isReadyForBootstrap()) {
				 setMode(Mode.JOINING, ""waiting for schema information to complete"", true);
				 try {
					 Thread.sleep(delay);
				 }
				 catch (InterruptedException e) {
					 throw new AssertionError(e);
				 }
			 }
			 setMode(Mode.JOINING, ""schema complete, ready to bootstrap"", true);
			 if (logger_.isDebugEnabled()) logger_.debug(""... got ring + schema info"");
			 if (DatabaseDescriptor.getReplaceToken() == null) {
				 if (tokenMetadata_.isMember(FBUtilities.getBroadcastAddress())) {
					 String s = ""This node is already a member of the token ring;
					 bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)"";
					 throw new UnsupportedOperationException(s);
				 }
				 setMode(Mode.JOINING, ""getting bootstrap token"", true);
				 token = BootStrapper.getBootstrapToken(tokenMetadata_, LoadBroadcaster.instance.getLoadInfo());
			 }
			 else {
				 try {
					 Thread.sleep(LoadBroadcaster.BROADCAST_INTERVAL);
				 }
				 catch (InterruptedException e) {
					 throw new AssertionError(e);
				 }
				 token = StorageService.getPartitioner().getTokenFactory().fromString(DatabaseDescriptor.getReplaceToken());
				 current = tokenMetadata_.getEndpoint(token);
				 if (null != current && Gossiper.instance.getEndpointStateForEndpoint(current).getUpdateTimestamp() > (System.currentTimeMillis() - delay)) throw new UnsupportedOperationException(""Cannnot replace a token for a Live node... "");
				 setMode(Mode.JOINING, ""Replacing a node with token: "" + token, true);
			 }
			 bootstrap(token);
			 assert !isBootstrapMode;
		 }
		 else {
			 token = SystemTable.getSavedToken();
			 if (token == null) {
				 String initialToken = DatabaseDescriptor.getInitialToken();
				 if (initialToken == null) {
					 token = getPartitioner().getRandomToken();
					 logger_.warn(""Generated random token "" + token + "". Random tokens will result in an unbalanced ring;
				 see http: }
				 else {
					 token = getPartitioner().getTokenFactory().fromString(initialToken);
					 logger_.info(""Saved token not found. Using "" + token + "" from configuration"");
				 }
			 }
			 else {
				 logger_.info(""Using saved token "" + token);
			 }
		 }
		 if (!isSurveyMode) {
			 SystemTable.setBootstrapped(true);
			 setToken(token);
			 if (current != null) Gossiper.instance.replacedEndpoint(current);
			 logger_.info(""Bootstrap/Replace/Move completed! Now serving reads."");
			 assert tokenMetadata_.sortedTokens().size() > 0;
		 }
		 else {
			 logger_.info(""Bootstrap complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService->joinRing()) to finalize ring joining."");
		 }
	 }
	 public synchronized void joinRing() throws IOException, org.apache.cassandra.config.ConfigurationException {
		 if (!joined) {
			 logger_.info(""Joining ring by operator request"");
			 joinTokenRing(0);
		 }
		 else if (isSurveyMode) {
			 setToken(SystemTable.getSavedToken());
			 SystemTable.setBootstrapped(true);
			 isSurveyMode = false;
			 logger_.info(""Leaving write survey mode and joining ring at operator request"");
			 assert tokenMetadata_.sortedTokens().size() > 0;
		 }
	 }
	 public boolean isJoined() {
		 return joined;
	 }
	 public void rebuild(String sourceDc) {
		 logger_.info(""rebuild from dc: {
		}
		"", sourceDc == null ? ""(any dc)"" : sourceDc);
		 RangeStreamer streamer = new RangeStreamer(tokenMetadata_, FBUtilities.getBroadcastAddress(), OperationType.REBUILD);
		 streamer.addSourceFilter(new RangeStreamer.FailureDetectorSourceFilter(FailureDetector.instance));
		 if (sourceDc != null) streamer.addSourceFilter(new RangeStreamer.SingleDatacenterFilter(DatabaseDescriptor.getEndpointSnitch(), sourceDc));
		 for (String table : Schema.instance.getNonSystemTables()) streamer.addRanges(table, getLocalRanges(table));
		 streamer.fetch();
	 }
	 public void setStreamThroughputMbPerSec(int value) {
		 DatabaseDescriptor.setStreamThroughputOutboundMegabitsPerSec(value);
		 logger_.info(""setstreamthroughput: throttle set to {
		}
		"", value);
	 }
	 public int getStreamThroughputMbPerSec() {
		 return DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec();
	 }
	 public int getCompactionThroughputMbPerSec() {
		 return DatabaseDescriptor.getCompactionThroughputMbPerSec();
	 }
	 public void setCompactionThroughputMbPerSec(int value) {
		 DatabaseDescriptor.setCompactionThroughputMbPerSec(value);
	 }
	 public boolean isIncrementalBackupsEnabled() {
		 return DatabaseDescriptor.isIncrementalBackupsEnabled();
	 }
	 public void setIncrementalBackupsEnabled(boolean value) {
		 DatabaseDescriptor.setIncrementalBackupsEnabled(value);
	 }
	 private void setMode(Mode m, boolean log) {
		 setMode(m, null, log);
	 }
	 private void setMode(Mode m, String msg, boolean log) {
		 operationMode = m;
		 String logMsg = msg == null ? m.toString() : String.format(""%s: %s"", m, msg);
		 if (log) logger_.info(logMsg);
		 else logger_.debug(logMsg);
	 }
	 private void bootstrap(Token token) throws IOException {
		 isBootstrapMode = true;
		 SystemTable.updateToken(token);
		 if (null == DatabaseDescriptor.getReplaceToken()) {
			 Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.bootstrapping(token));
			 setMode(Mode.JOINING, ""sleeping "" + RING_DELAY + "" ms for pending range setup"", true);
			 try {
				 Thread.sleep(RING_DELAY);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
		 }
		 else {
			 tokenMetadata_.updateNormalToken(token, FBUtilities.getBroadcastAddress());
		 }
		 setMode(Mode.JOINING, ""Starting to bootstrap..."", true);
		 new BootStrapper(FBUtilities.getBroadcastAddress(), token, tokenMetadata_).bootstrap();
	 }
	 public boolean isBootstrapMode() {
		 return isBootstrapMode;
	 }
	 public TokenMetadata getTokenMetadata() {
		 return tokenMetadata_;
	 }
	 public Map<List<String>, List<String>> getRangeToEndpointMap(String keyspace) {
		 Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();
		 for (Map.Entry<Range<Token>,List<InetAddress>> entry : getRangeToAddressMap(keyspace).entrySet()) {
			 map.put(entry.getKey().asList(), stringify(entry.getValue()));
		 }
		 return map;
	 }
	 public String getRpcaddress(InetAddress endpoint) {
		 if (endpoint.equals(FBUtilities.getBroadcastAddress())) return DatabaseDescriptor.getRpcAddress().getHostAddress();
		 else if (Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS) == null) return endpoint.getHostAddress();
		 else return Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS).value;
	 }
	 public Map<List<String>, List<String>> getRangeToRpcaddressMap(String keyspace) {
		 Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();
		 for (Map.Entry<Range<Token>, List<InetAddress>> entry : getRangeToAddressMap(keyspace).entrySet()) {
			 List<String> rpcaddrs = new ArrayList<String>();
			 for (InetAddress endpoint: entry.getValue()) {
				 rpcaddrs.add(getRpcaddress(endpoint));
			 }
			 map.put(entry.getKey().asList(), rpcaddrs);
		 }
		 return map;
	 }
	 public Map<List<String>, List<String>> getPendingRangeToEndpointMap(String keyspace) {
		 if (keyspace == null) keyspace = Schema.instance.getNonSystemTables().get(0);
		 Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();
		 for (Map.Entry<Range<Token>, Collection<InetAddress>> entry : tokenMetadata_.getPendingRanges(keyspace).entrySet()) {
			 List<InetAddress> l = new ArrayList<InetAddress>(entry.getValue());
			 map.put(entry.getKey().asList(), stringify(l));
		 }
		 return map;
	 }
	 public Map<Range<Token>, List<InetAddress>> getRangeToAddressMap(String keyspace) {
		 if (keyspace == null) keyspace = Schema.instance.getNonSystemTables().get(0);
		 List<Range<Token>> ranges = getAllRanges(tokenMetadata_.sortedTokens());
		 return constructRangeToEndpointMap(keyspace, ranges);
	 }
	 public List<String> describeRingJMX(String keyspace) throws InvalidRequestException {
		 List<String> result = new ArrayList<String>();
		 for (TokenRange tokenRange : describeRing(keyspace)) result.add(tokenRange.toString());
		 return result;
	 }
	 public List<TokenRange> describeRing(String keyspace) throws InvalidRequestException {
		 if (keyspace == null || !Schema.instance.getNonSystemTables().contains(keyspace)) throw new InvalidRequestException(""There is no ring for the keyspace: "" + keyspace);
		 List<TokenRange> ranges = new ArrayList<TokenRange>();
		 Token.TokenFactory tf = getPartitioner().getTokenFactory();
		 for (Map.Entry<Range<Token>, List<InetAddress>> entry : getRangeToAddressMap(keyspace).entrySet()) {
			 Range range = entry.getKey();
			 List<String> endpoints = new ArrayList<String>();
			 List<String> rpc_endpoints = new ArrayList<String>();
			 List<EndpointDetails> epDetails = new ArrayList<EndpointDetails>();
			 for (InetAddress endpoint : entry.getValue()) {
				 EndpointDetails details = new EndpointDetails();
				 details.host = endpoint.getHostAddress();
				 details.datacenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(endpoint);
				 details.rack = DatabaseDescriptor.getEndpointSnitch().getRack(endpoint);
				 endpoints.add(details.host);
				 rpc_endpoints.add(getRpcaddress(endpoint));
				 epDetails.add(details);
			 }
			 TokenRange tr = new TokenRange(tf.toString(range.left.getToken()), tf.toString(range.right.getToken()), endpoints) .setEndpoint_details(epDetails) .setRpc_endpoints(rpc_endpoints);
			 ranges.add(tr);
		 }
		 return ranges;
	 }
	 public Map<String, String> getTokenToEndpointMap() {
		 Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap();
		 Map<String, String> mapString = new LinkedHashMap<String, String>(mapInetAddress.size());
		 List<Token> tokens = new ArrayList<Token>(mapInetAddress.keySet());
		 Collections.sort(tokens);
		 for (Token token : tokens) {
			 mapString.put(token.toString(), mapInetAddress.get(token).getHostAddress());
		 }
		 return mapString;
	 }
	 private Map<Range<Token>, List<InetAddress>> constructRangeToEndpointMap(String keyspace, List<Range<Token>> ranges) {
		 Map<Range<Token>, List<InetAddress>> rangeToEndpointMap = new HashMap<Range<Token>, List<InetAddress>>();
		 for (Range<Token> range : ranges) {
			 rangeToEndpointMap.put(range, Table.open(keyspace).getReplicationStrategy().getNaturalEndpoints(range.right));
		 }
		 return rangeToEndpointMap;
	 }
	 private Map<InetAddress, Collection<Range<Token>>> constructEndpointToRangeMap(String keyspace) {
		 Multimap<InetAddress, Range<Token>> endpointToRangeMap = Multimaps.newListMultimap(new HashMap<InetAddress, Collection<Range<Token>>>(), new Supplier<List<Range<Token>>>() {
			 public List<Range<Token>> get() {
				 return Lists.newArrayList();
			 }
		 }
		);
		 List<Range<Token>> ranges = getAllRanges(tokenMetadata_.sortedTokens());
		 for (Range<Token> range : ranges) {
			 for (InetAddress endpoint : Table.open(keyspace).getReplicationStrategy().getNaturalEndpoints(range.left)) endpointToRangeMap.put(endpoint, range);
		 }
		 return endpointToRangeMap.asMap();
	 }
	 public void onChange(InetAddress endpoint, ApplicationState state, VersionedValue value) {
		 switch (state) {
			 case STATUS: String apStateValue = value.value;
			 String[] pieces = apStateValue.split(VersionedValue.DELIMITER_STR, -1);
			 assert (pieces.length > 0);
			 String moveName = pieces[0];
			 if (moveName.equals(VersionedValue.STATUS_BOOTSTRAPPING)) handleStateBootstrap(endpoint, pieces);
			 else if (moveName.equals(VersionedValue.STATUS_NORMAL)) handleStateNormal(endpoint, pieces);
			 else if (moveName.equals(VersionedValue.REMOVING_TOKEN) || moveName.equals(VersionedValue.REMOVED_TOKEN)) handleStateRemoving(endpoint, pieces);
			 else if (moveName.equals(VersionedValue.STATUS_LEAVING)) handleStateLeaving(endpoint, pieces);
			 else if (moveName.equals(VersionedValue.STATUS_LEFT)) handleStateLeft(endpoint, pieces);
			 else if (moveName.equals(VersionedValue.STATUS_MOVING)) handleStateMoving(endpoint, pieces);
		 }
	 }
	 private void handleStateBootstrap(InetAddress endpoint, String[] pieces) {
		 assert pieces.length >= 2;
		 Token token = getPartitioner().getTokenFactory().fromString(pieces[1]);
		 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" state bootstrapping, token "" + token);
		 if (tokenMetadata_.isMember(endpoint)) {
			 if (!tokenMetadata_.isLeaving(endpoint)) logger_.info(""Node "" + endpoint + "" state jump to bootstrap"");
			 tokenMetadata_.removeEndpoint(endpoint);
		 }
		 tokenMetadata_.addBootstrapToken(token, endpoint);
		 calculatePendingRanges();
	 }
	 private void handleStateNormal(InetAddress endpoint, String[] pieces) {
		 assert pieces.length >= 2;
		 Token token = getPartitioner().getTokenFactory().fromString(pieces[1]);
		 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" state normal, token "" + token);
		 if (tokenMetadata_.isMember(endpoint)) logger_.info(""Node "" + endpoint + "" state jump to normal"");
		 InetAddress currentOwner = tokenMetadata_.getEndpoint(token);
		 if (currentOwner == null) {
			 logger_.debug(""New node "" + endpoint + "" at token "" + token);
			 tokenMetadata_.updateNormalToken(token, endpoint);
			 if (!isClientMode) SystemTable.updateToken(endpoint, token);
		 }
		 else if (endpoint.equals(currentOwner)) {
			 tokenMetadata_.updateNormalToken(token, endpoint);
		 }
		 else if (Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) > 0) {
			 logger_.info(String.format(""Nodes %s and %s have the same token %s. %s is the new owner"", endpoint, currentOwner, token, endpoint));
			 tokenMetadata_.updateNormalToken(token, endpoint);
			 Gossiper.instance.removeEndpoint(currentOwner);
			 if (!isClientMode) SystemTable.updateToken(endpoint, token);
		 }
		 else {
			 logger_.info(String.format(""Nodes %s and %s have the same token %s. Ignoring %s"", endpoint, currentOwner, token, endpoint));
		 }
		 if (tokenMetadata_.isMoving(endpoint)) tokenMetadata_.removeFromMoving(endpoint);
		 calculatePendingRanges();
	 }
	 private void handleStateLeaving(InetAddress endpoint, String[] pieces) {
		 assert pieces.length >= 2;
		 String moveValue = pieces[1];
		 Token token = getPartitioner().getTokenFactory().fromString(moveValue);
		 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" state leaving, token "" + token);
		 if (!tokenMetadata_.isMember(endpoint)) {
			 logger_.info(""Node "" + endpoint + "" state jump to leaving"");
			 tokenMetadata_.updateNormalToken(token, endpoint);
		 }
		 else if (!tokenMetadata_.getToken(endpoint).equals(token)) {
			 logger_.warn(""Node "" + endpoint + "" 'leaving' token mismatch. Long network partition?"");
			 tokenMetadata_.updateNormalToken(token, endpoint);
		 }
		 tokenMetadata_.addLeavingEndpoint(endpoint);
		 calculatePendingRanges();
	 }
	 private void handleStateLeft(InetAddress endpoint, String[] pieces) {
		 assert pieces.length >= 2;
		 Token token = getPartitioner().getTokenFactory().fromString(pieces[1]);
		 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" state left, token "" + token);
		 excise(token, endpoint, extractExpireTime(pieces));
	 }
	 private void handleStateMoving(InetAddress endpoint, String[] pieces) {
		 assert pieces.length >= 2;
		 Token token = getPartitioner().getTokenFactory().fromString(pieces[1]);
		 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" state moving, new token "" + token);
		 tokenMetadata_.addMovingEndpoint(token, endpoint);
		 calculatePendingRanges();
	 }
	 private void handleStateRemoving(InetAddress endpoint, String[] pieces) {
		 assert (pieces.length > 0);
		 if (endpoint.equals(FBUtilities.getBroadcastAddress())) {
			 logger_.info(""Received removeToken gossip about myself. Is this node rejoining after an explicit removetoken?"");
			 try {
				 drain();
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
			 return;
		 }
		 if (tokenMetadata_.isMember(endpoint)) {
			 String state = pieces[0];
			 Token removeToken = tokenMetadata_.getToken(endpoint);
			 if (VersionedValue.REMOVED_TOKEN.equals(state)) {
				 excise(removeToken, endpoint, extractExpireTime(pieces));
			 }
			 else if (VersionedValue.REMOVING_TOKEN.equals(state)) {
				 if (logger_.isDebugEnabled()) logger_.debug(""Token "" + removeToken + "" removed manually (endpoint was "" + endpoint + "")"");
				 tokenMetadata_.addLeavingEndpoint(endpoint);
				 calculatePendingRanges();
				 String[] coordinator = Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.REMOVAL_COORDINATOR).value.split(VersionedValue.DELIMITER_STR, -1);
				 Token coordtoken = getPartitioner().getTokenFactory().fromString(coordinator[1]);
				 restoreReplicaCount(endpoint, tokenMetadata_.getEndpoint(coordtoken));
			 }
		 }
	 }
	 private void excise(Token token, InetAddress endpoint) {
		 HintedHandOffManager.instance.deleteHintsForEndpoint(endpoint);
		 Gossiper.instance.removeEndpoint(endpoint);
		 tokenMetadata_.removeEndpoint(endpoint);
		 tokenMetadata_.removeBootstrapToken(token);
		 calculatePendingRanges();
		 if (!isClientMode) {
			 logger_.info(""Removing token "" + token + "" for "" + endpoint);
			 SystemTable.removeToken(token);
		 }
	 }
	 private void excise(Token token, InetAddress endpoint, long expireTime) {
		 addExpireTimeIfFound(endpoint, expireTime);
		 excise(token, endpoint);
	 }
	 protected void addExpireTimeIfFound(InetAddress endpoint, long expireTime) {
		 if (expireTime != 0L) {
			 Gossiper.instance.addExpireTimeForEndpoint(endpoint, expireTime);
		 }
	 }
	 protected long extractExpireTime(String[] pieces) {
		 long expireTime = 0L;
		 if (pieces.length >= 3) {
			 expireTime = Long.parseLong(pieces[2]);
		 }
		 return expireTime;
	 }
	 private void calculatePendingRanges() {
		 for (String table : Schema.instance.getNonSystemTables()) calculatePendingRanges(Table.open(table).getReplicationStrategy(), table);
	 }
	 public static void calculatePendingRanges(AbstractReplicationStrategy strategy, String table) {
		 TokenMetadata tm = StorageService.instance.getTokenMetadata();
		 Multimap<Range<Token>, InetAddress> pendingRanges = HashMultimap.create();
		 Map<Token, InetAddress> bootstrapTokens = tm.getBootstrapTokens();
		 Set<InetAddress> leavingEndpoints = tm.getLeavingEndpoints();
		 if (bootstrapTokens.isEmpty() && leavingEndpoints.isEmpty() && tm.getMovingEndpoints().isEmpty()) {
			 if (logger_.isDebugEnabled()) logger_.debug(""No bootstrapping, leaving or moving nodes -> empty pending ranges for {
			}
			"", table);
			 tm.setPendingRanges(table, pendingRanges);
			 return;
		 }
		 Multimap<InetAddress, Range<Token>> addressRanges = strategy.getAddressRanges();
		 TokenMetadata allLeftMetadata = tm.cloneAfterAllLeft();
		 Set<Range<Token>> affectedRanges = new HashSet<Range<Token>>();
		 for (InetAddress endpoint : leavingEndpoints) affectedRanges.addAll(addressRanges.get(endpoint));
		 for (Range<Token> range : affectedRanges) {
			 Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, tm));
			 Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(range.right, allLeftMetadata));
			 pendingRanges.putAll(range, Sets.difference(newEndpoints, currentEndpoints));
		 }
		 synchronized (bootstrapTokens) {
			 for (Map.Entry<Token, InetAddress> entry : bootstrapTokens.entrySet()) {
				 InetAddress endpoint = entry.getValue();
				 allLeftMetadata.updateNormalToken(entry.getKey(), endpoint);
				 for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) pendingRanges.put(range, endpoint);
				 allLeftMetadata.removeEndpoint(endpoint);
			 }
		 }
		 for (Pair<Token, InetAddress> moving : tm.getMovingEndpoints()) {
			 InetAddress endpoint = moving.right;
			 allLeftMetadata.updateNormalToken(moving.left, endpoint);
			 for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint)) {
				 pendingRanges.put(range, endpoint);
			 }
			 allLeftMetadata.removeEndpoint(endpoint);
		 }
		 tm.setPendingRanges(table, pendingRanges);
		 if (logger_.isDebugEnabled()) logger_.debug(""Pending ranges:\n"" + (pendingRanges.isEmpty() ? ""<empty>"" : tm.printPendingRanges()));
	 }
	 private Multimap<InetAddress, Range<Token>> getNewSourceRanges(String table, Set<Range<Token>> ranges) {
		 InetAddress myAddress = FBUtilities.getBroadcastAddress();
		 Multimap<Range<Token>, InetAddress> rangeAddresses = Table.open(table).getReplicationStrategy().getRangeAddresses(tokenMetadata_);
		 Multimap<InetAddress, Range<Token>> sourceRanges = HashMultimap.create();
		 IFailureDetector failureDetector = FailureDetector.instance;
		 for (Range<Token> range : ranges) {
			 Collection<InetAddress> possibleRanges = rangeAddresses.get(range);
			 IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();
			 List<InetAddress> sources = snitch.getSortedListByProximity(myAddress, possibleRanges);
			 assert (!sources.contains(myAddress));
			 for (InetAddress source : sources) {
				 if (failureDetector.isAlive(source)) {
					 sourceRanges.put(source, range);
					 break;
				 }
			 }
		 }
		 return sourceRanges;
	 }
	 private void sendReplicationNotification(InetAddress local, InetAddress remote) {
		 Message msg = new Message(local, StorageService.Verb.REPLICATION_FINISHED, new byte[0], Gossiper.instance.getVersion(remote));
		 IFailureDetector failureDetector = FailureDetector.instance;
		 if (logger_.isDebugEnabled()) logger_.debug(""Notifying "" + remote.toString() + "" of replication completion\n"");
		 while (failureDetector.isAlive(remote)) {
			 IAsyncResult iar = MessagingService.instance().sendRR(msg, remote);
			 try {
				 iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
				 return;
			 }
			 catch(TimeoutException e) {
			 }
		 }
	 }
	 private void restoreReplicaCount(InetAddress endpoint, final InetAddress notifyEndpoint) {
		 final Multimap<InetAddress, String> fetchSources = HashMultimap.create();
		 Multimap<String, Map.Entry<InetAddress, Collection<Range<Token>>>> rangesToFetch = HashMultimap.create();
		 final InetAddress myAddress = FBUtilities.getBroadcastAddress();
		 for (String table : Schema.instance.getNonSystemTables()) {
			 Multimap<Range<Token>, InetAddress> changedRanges = getChangedRangesForLeaving(table, endpoint);
			 Set<Range<Token>> myNewRanges = new HashSet<Range<Token>>();
			 for (Map.Entry<Range<Token>, InetAddress> entry : changedRanges.entries()) {
				 if (entry.getValue().equals(myAddress)) myNewRanges.add(entry.getKey());
			 }
			 Multimap<InetAddress, Range<Token>> sourceRanges = getNewSourceRanges(table, myNewRanges);
			 for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : sourceRanges.asMap().entrySet()) {
				 fetchSources.put(entry.getKey(), table);
				 rangesToFetch.put(table, entry);
			 }
		 }
		 for (final String table : rangesToFetch.keySet()) {
			 for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : rangesToFetch.get(table)) {
				 final InetAddress source = entry.getKey();
				 Collection<Range<Token>> ranges = entry.getValue();
				 final IStreamCallback callback = new IStreamCallback() {
					 public void onSuccess() {
						 synchronized (fetchSources) {
							 fetchSources.remove(source, table);
							 if (fetchSources.isEmpty()) sendReplicationNotification(myAddress, notifyEndpoint);
						 }
					 }
					 public void onFailure() {
						 logger_.warn(""Streaming from "" + source + "" failed"");
						 onSuccess();
					 }
				 }
				;
				 if (logger_.isDebugEnabled()) logger_.debug(""Requesting from "" + source + "" ranges "" + StringUtils.join(ranges, "", ""));
				 StreamIn.requestRanges(source, table, ranges, callback, OperationType.RESTORE_REPLICA_COUNT);
			 }
		 }
	 }
	 private Multimap<Range<Token>, InetAddress> getChangedRangesForLeaving(String table, InetAddress endpoint) {
		 Collection<Range<Token>> ranges = getRangesForEndpoint(table, endpoint);
		 if (logger_.isDebugEnabled()) logger_.debug(""Node "" + endpoint + "" ranges ["" + StringUtils.join(ranges, "", "") + ""]"");
		 Map<Range<Token>, List<InetAddress>> currentReplicaEndpoints = new HashMap<Range<Token>, List<InetAddress>>();
		 for (Range<Token> range : ranges) currentReplicaEndpoints.put(range, Table.open(table).getReplicationStrategy().calculateNaturalEndpoints(range.right, tokenMetadata_));
		 TokenMetadata temp = tokenMetadata_.cloneAfterAllLeft();
		 if (temp.isMember(endpoint)) temp.removeEndpoint(endpoint);
		 Multimap<Range<Token>, InetAddress> changedRanges = HashMultimap.create();
		 for (Range<Token> range : ranges) {
			 Collection<InetAddress> newReplicaEndpoints = Table.open(table).getReplicationStrategy().calculateNaturalEndpoints(range.right, temp);
			 newReplicaEndpoints.removeAll(currentReplicaEndpoints.get(range));
			 if (logger_.isDebugEnabled()) if (newReplicaEndpoints.isEmpty()) logger_.debug(""Range "" + range + "" already in all replicas"");
			 else logger_.debug(""Range "" + range + "" will be responsibility of "" + StringUtils.join(newReplicaEndpoints, "", ""));
			 changedRanges.putAll(range, newReplicaEndpoints);
		 }
		 return changedRanges;
	 }
	 public void onJoin(InetAddress endpoint, EndpointState epState) {
		 for (Map.Entry<ApplicationState, VersionedValue> entry : epState.getApplicationStateMap().entrySet()) {
			 onChange(endpoint, entry.getKey(), entry.getValue());
		 }
	 }
	 public void onAlive(InetAddress endpoint, EndpointState state) {
		 if (!isClientMode && getTokenMetadata().isMember(endpoint)) HintedHandOffManager.instance.scheduleHintDelivery(endpoint);
	 }
	 public void onRemove(InetAddress endpoint) {
		 tokenMetadata_.removeEndpoint(endpoint);
		 calculatePendingRanges();
	 }
	 public void onDead(InetAddress endpoint, EndpointState state) {
		 MessagingService.instance().convict(endpoint);
	 }
	 public void onRestart(InetAddress endpoint, EndpointState state) {
		 if (state.isAlive()) onDead(endpoint, state);
	 }
	 public double getLoad() {
		 double bytes = 0;
		 for (String tableName : Schema.instance.getTables()) {
			 Table table = Table.open(tableName);
			 for (ColumnFamilyStore cfs : table.getColumnFamilyStores()) bytes += cfs.getLiveDiskSpaceUsed();
		 }
		 return bytes;
	 }
	 public String getLoadString() {
		 return FileUtils.stringifyFileSize(getLoad());
	 }
	 public Map<String, String> getLoadMap() {
		 Map<String, String> map = new HashMap<String, String>();
		 for (Map.Entry<InetAddress,Double> entry : LoadBroadcaster.instance.getLoadInfo().entrySet()) {
			 map.put(entry.getKey().getHostAddress(), FileUtils.stringifyFileSize(entry.getValue()));
		 }
		 map.put(FBUtilities.getBroadcastAddress().getHostAddress(), getLoadString());
		 return map;
	 }
	 public final void deliverHints(String host) throws UnknownHostException {
		 HintedHandOffManager.instance.scheduleHintDelivery(host);
	 }
	 public Token getLocalToken() {
		 Token token = SystemTable.getSavedToken();
		 assert token != null;
		 return token;
	 }
	 public String getToken() {
		 return getLocalToken().toString();
	 }
	 public String getReleaseVersion() {
		 return FBUtilities.getReleaseVersionString();
	 }
	 public String getSchemaVersion() {
		 return Schema.instance.getVersion().toString();
	 }
	 public List<String> getLeavingNodes() {
		 return stringify(tokenMetadata_.getLeavingEndpoints());
	 }
	 public List<String> getMovingNodes() {
		 List<String> endpoints = new ArrayList<String>();
		 for (Pair<Token, InetAddress> node : tokenMetadata_.getMovingEndpoints()) {
			 endpoints.add(node.right.getHostAddress());
		 }
		 return endpoints;
	 }
	 public List<String> getJoiningNodes() {
		 return stringify(tokenMetadata_.getBootstrapTokens().values());
	 }
	 public List<String> getLiveNodes() {
		 return stringify(Gossiper.instance.getLiveMembers());
	 }
	 public List<String> getUnreachableNodes() {
		 return stringify(Gossiper.instance.getUnreachableMembers());
	 }
	 private static String getCanonicalPath(String filename) {
		 try {
			 return new File(filename).getCanonicalPath();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public String[] getAllDataFileLocations() {
		 String[] locations = DatabaseDescriptor.getAllDataFileLocations();
		 for (int i = 0;
		 i < locations.length;
		 i++) locations[i] = getCanonicalPath(locations[i]);
		 return locations;
	 }
	 public String getCommitLogLocation() {
		 return getCanonicalPath(DatabaseDescriptor.getCommitLogLocation());
	 }
	 public String getSavedCachesLocation() {
		 return getCanonicalPath(DatabaseDescriptor.getSavedCachesLocation());
	 }
	 private List<String> stringify(Iterable<InetAddress> endpoints) {
		 List<String> stringEndpoints = new ArrayList<String>();
		 for (InetAddress ep : endpoints) {
			 stringEndpoints.add(ep.getHostAddress());
		 }
		 return stringEndpoints;
	 }
	 public int getCurrentGenerationNumber() {
		 return Gossiper.instance.getCurrentGenerationNumber(FBUtilities.getBroadcastAddress());
	 }
	 public void forceTableCleanup(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException {
		 if (tableName.equals(Table.SYSTEM_TABLE)) throw new RuntimeException(""Cleanup of the system table is neither necessary nor wise"");
		 NodeId.OneShotRenewer nodeIdRenewer = new NodeId.OneShotRenewer();
		 for (ColumnFamilyStore cfStore : getValidColumnFamilies(tableName, columnFamilies)) {
			 cfStore.forceCleanup(nodeIdRenewer);
		 }
	 }
	 public void scrub(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException {
		 for (ColumnFamilyStore cfStore : getValidColumnFamilies(tableName, columnFamilies)) cfStore.scrub();
	 }
	 public void upgradeSSTables(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException {
		 for (ColumnFamilyStore cfStore : getValidColumnFamilies(tableName, columnFamilies)) cfStore.sstablesRewrite();
	 }
	 public void forceTableCompaction(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException {
		 for (ColumnFamilyStore cfStore : getValidColumnFamilies(tableName, columnFamilies)) {
			 cfStore.forceMajorCompaction();
		 }
	 }
	 public void takeSnapshot(String tag, String... tableNames) throws IOException {
		 if (tag == null || tag.equals("""")) throw new IOException(""You must supply a snapshot name."");
		 Iterable<Table> tables;
		 if (tableNames.length == 0) {
			 tables = Table.all();
		 }
		 else {
			 ArrayList<Table> t = new ArrayList<Table>();
			 for (String table : tableNames) t.add(getValidTable(table));
			 tables = t;
		 }
		 for (Table table : tables) if (table.snapshotExists(tag)) throw new IOException(""Snapshot "" + tag + "" already exists."");
		 for (Table table : tables) table.snapshot(tag);
	 }
	 private Table getValidTable(String tableName) throws IOException {
		 if (!Schema.instance.getTables().contains(tableName)) {
			 throw new IOException(""Table "" + tableName + ""does not exist"");
		 }
		 return Table.open(tableName);
	 }
	 public void clearSnapshot(String tag, String... tableNames) throws IOException {
		 if(tag == null) tag = """";
		 Iterable<Table> tables;
		 if (tableNames.length == 0) {
			 tables = Table.all();
		 }
		 else {
			 ArrayList<Table> tempTables = new ArrayList<Table>();
			 for(String table : tableNames) tempTables.add(getValidTable(table));
			 tables = tempTables;
		 }
		 for (Table table : tables) table.clearSnapshot(tag);
		 if (logger_.isDebugEnabled()) logger_.debug(""Cleared out snapshot directories"");
	 }
	 public Iterable<ColumnFamilyStore> getValidColumnFamilies(String tableName, String... cfNames) throws IOException {
		 Table table = getValidTable(tableName);
		 if (cfNames.length == 0) return table.getColumnFamilyStores();
		 Set<ColumnFamilyStore> valid = new HashSet<ColumnFamilyStore>();
		 for (String cfName : cfNames) {
			 ColumnFamilyStore cfStore = table.getColumnFamilyStore(cfName);
			 if (cfStore == null) {
				 logger_.warn(String.format(""Invalid column family specified: %s. Proceeding with others."", cfName));
				 continue;
			 }
			 valid.add(cfStore);
		 }
		 return valid;
	 }
	 public void forceTableFlush(final String tableName, final String... columnFamilies) throws IOException, ExecutionException, InterruptedException {
		 for (ColumnFamilyStore cfStore : getValidColumnFamilies(tableName, columnFamilies)) {
			 logger_.debug(""Forcing flush on keyspace "" + tableName + "", CF "" + cfStore.getColumnFamilyName());
			 cfStore.forceBlockingFlush();
		 }
	 }
	 public void forceTableRepair(final String tableName, final String... columnFamilies) throws IOException {
		 if (Table.SYSTEM_TABLE.equals(tableName)) return;
		 Collection<Range<Token>> ranges = getLocalRanges(tableName);
		 int cmd = nextRepairCommand.incrementAndGet();
		 logger_.info(""Starting repair command #{
		}
		, repairing {
		}
		 ranges."", cmd, ranges.size());
		 List<AntiEntropyService.RepairFuture> futures = new ArrayList<AntiEntropyService.RepairFuture>(ranges.size());
		 for (Range<Token> range : ranges) {
			 AntiEntropyService.RepairFuture future = forceTableRepair(range, tableName, columnFamilies);
			 if (future == null) continue;
			 futures.add(future);
			 try {
				 future.session.differencingDone.await();
			 }
			 catch (InterruptedException e) {
				 logger_.error(""Interrupted while waiting for the differencing of repair session "" + future.session + "" to be done. Repair may be imprecise."", e);
			 }
		 }
		 boolean failedSession = false;
		 for (AntiEntropyService.RepairFuture future : futures) {
			 try {
				 future.get();
			 }
			 catch (Exception e) {
				 logger_.error(""Repair session "" + future.session.getName() + "" failed."", e);
				 failedSession = true;
			 }
		 }
		 if (failedSession) throw new IOException(""Repair command #"" + cmd + "": some repair session(s) failed (see log for details)."");
		 else logger_.info(""Repair command #{
		}
		 completed successfully"", cmd);
	 }
	 public void forceTableRepairPrimaryRange(final String tableName, final String... columnFamilies) throws IOException {
		 if (Table.SYSTEM_TABLE.equals(tableName)) return;
		 AntiEntropyService.RepairFuture future = forceTableRepair(getLocalPrimaryRange(), tableName, columnFamilies);
		 if (future == null) return;
		 try {
			 future.get();
		 }
		 catch (Exception e) {
			 logger_.error(""Repair session "" + future.session.getName() + "" failed."", e);
			 throw new IOException(""Some repair session(s) failed (see log for details)."");
		 }
	 }
	 public AntiEntropyService.RepairFuture forceTableRepair(final Range<Token> range, final String tableName, final String... columnFamilies) throws IOException {
		 ArrayList<String> names = new ArrayList<String>();
		 for (ColumnFamilyStore cfStore : getValidColumnFamilies(tableName, columnFamilies)) {
			 names.add(cfStore.getColumnFamilyName());
		 }
		 if (names.isEmpty()) {
			 logger_.info(""No column family to repair for keyspace "" + tableName);
			 return null;
		 }
		 return AntiEntropyService.instance.submitRepairSession(range, tableName, names.toArray(new String[names.size()]));
	 }
	 public void forceTerminateAllRepairSessions() {
		 AntiEntropyService.instance.terminateSessions();
	 }
	 InetAddress getPredecessor(InetAddress ep) {
		 Token token = tokenMetadata_.getToken(ep);
		 return tokenMetadata_.getEndpoint(tokenMetadata_.getPredecessor(token));
	 }
	 public InetAddress getSuccessor(InetAddress ep) {
		 Token token = tokenMetadata_.getToken(ep);
		 return tokenMetadata_.getEndpoint(tokenMetadata_.getSuccessor(token));
	 }
	 public Range<Token> getPrimaryRangeForEndpoint(InetAddress ep) {
		 return tokenMetadata_.getPrimaryRangeFor(tokenMetadata_.getToken(ep));
	 }
	 Collection<Range<Token>> getRangesForEndpoint(String table, InetAddress ep) {
		 return Table.open(table).getReplicationStrategy().getAddressRanges().get(ep);
	 }
	 public List<Range<Token>> getAllRanges(List<Token> sortedTokens) {
		 if (logger_.isDebugEnabled()) logger_.debug(""computing ranges for "" + StringUtils.join(sortedTokens, "", ""));
		 if (sortedTokens.isEmpty()) return Collections.emptyList();
		 List<Range<Token>> ranges = new ArrayList<Range<Token>>();
		 int size = sortedTokens.size();
		 for (int i = 1;
		 i < size;
		 ++i) {
			 Range<Token> range = new Range<Token>(sortedTokens.get(i - 1), sortedTokens.get(i));
			 ranges.add(range);
		 }
		 Range<Token> range = new Range<Token>(sortedTokens.get(size - 1), sortedTokens.get(0));
		 ranges.add(range);
		 return ranges;
	 }
	 public List<InetAddress> getNaturalEndpoints(String table, String cf, String key) {
		 CFMetaData cfMetaData = Schema.instance.getTableDefinition(table).cfMetaData().get(cf);
		 return getNaturalEndpoints(table, getPartitioner().getToken(cfMetaData.getKeyValidator().fromString(key)));
	 }
	 public List<InetAddress> getNaturalEndpoints(String table, ByteBuffer key) {
		 return getNaturalEndpoints(table, getPartitioner().getToken(key));
	 }
	 public List<InetAddress> getNaturalEndpoints(String table, RingPosition pos) {
		 return Table.open(table).getReplicationStrategy().getNaturalEndpoints(pos);
	 }
	 public List<InetAddress> getLiveNaturalEndpoints(String table, ByteBuffer key) {
		 return getLiveNaturalEndpoints(table, getPartitioner().decorateKey(key));
	 }
	 public List<InetAddress> getLiveNaturalEndpoints(String table, RingPosition pos) {
		 List<InetAddress> liveEps = new ArrayList<InetAddress>();
		 List<InetAddress> endpoints = Table.open(table).getReplicationStrategy().getNaturalEndpoints(pos);
		 for (InetAddress endpoint : endpoints) {
			 if (FailureDetector.instance.isAlive(endpoint)) liveEps.add(endpoint);
		 }
		 return liveEps;
	 }
	 public void setLog4jLevel(String classQualifier, String rawLevel) {
		 Level level = Level.toLevel(rawLevel);
		 org.apache.log4j.Logger.getLogger(classQualifier).setLevel(level);
		 logger_.info(""set log level to "" + level + "" for classes under '"" + classQualifier + ""' (if the level doesn't look like '"" + rawLevel + ""' then log4j couldn't parse '"" + rawLevel + ""')"");
	 }
	 public List<Token> getSplits(String table, String cfName, Range<Token> range, int keysPerSplit) {
		 List<Token> tokens = new ArrayList<Token>();
		 tokens.add(range.left);
		 Table t = Table.open(table);
		 ColumnFamilyStore cfs = t.getColumnFamilyStore(cfName);
		 List<DecoratedKey> keys = keySamples(Collections.singleton(cfs), range);
		 int splits = keys.size() * DatabaseDescriptor.getIndexInterval() / keysPerSplit;
		 if (keys.size() >= splits) {
			 for (int i = 1;
			 i < splits;
			 i++) {
				 int index = i * (keys.size() / splits);
				 tokens.add(keys.get(index).token);
			 }
		 }
		 tokens.add(range.right);
		 return tokens;
	 }
	 private List<DecoratedKey> keySamples(Iterable<ColumnFamilyStore> cfses, Range<Token> range) {
		 List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
		 for (ColumnFamilyStore cfs : cfses) Iterables.addAll(keys, cfs.keySamples(range));
		 FBUtilities.sortSampledKeys(keys, range);
		 return keys;
	 }
	 public Token getBootstrapToken() {
		 Range<Token> range = getLocalPrimaryRange();
		 List<DecoratedKey> keys = keySamples(ColumnFamilyStore.allUserDefined(), range);
		 Token token;
		 if (keys.size() < 3) {
			 token = getPartitioner().midpoint(range.left, range.right);
			 logger_.debug(""Used midpoint to assign token "" + token);
		 }
		 else {
			 token = keys.get(keys.size() / 2).token;
			 logger_.debug(""Used key sample of size "" + keys.size() + "" to assign token "" + token);
		 }
		 if (tokenMetadata_.getEndpoint(token) != null && tokenMetadata_.isMember(tokenMetadata_.getEndpoint(token))) throw new RuntimeException(""Chose token "" + token + "" which is already in use by "" + tokenMetadata_.getEndpoint(token) + "" -- specify one manually with initial_token"");
		 if (token instanceof StringToken) {
			 token = new StringToken(((String)token.token).replaceAll(VersionedValue.DELIMITER_STR, """"));
			 if (tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap().containsKey(token)) throw new RuntimeException(""Unable to compute unique token for new node -- specify one manually with initial_token"");
		 }
		 return token;
	 }
	 private void startLeaving() {
		 Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.leaving(getLocalToken()));
		 tokenMetadata_.addLeavingEndpoint(FBUtilities.getBroadcastAddress());
		 calculatePendingRanges();
	 }
	 public void decommission() throws InterruptedException {
		 if (!tokenMetadata_.isMember(FBUtilities.getBroadcastAddress())) throw new UnsupportedOperationException(""local node is not a member of the token ring yet"");
		 if (tokenMetadata_.cloneAfterAllLeft().sortedTokens().size() < 2) throw new UnsupportedOperationException(""no other normal nodes in the ring;
		 decommission would be pointless"");
		 for (String table : Schema.instance.getNonSystemTables()) {
			 if (tokenMetadata_.getPendingRanges(table, FBUtilities.getBroadcastAddress()).size() > 0) throw new UnsupportedOperationException(""data is currently moving to this node;
			 unable to leave the ring"");
		 }
		 if (logger_.isDebugEnabled()) logger_.debug(""DECOMMISSIONING"");
		 startLeaving();
		 setMode(Mode.LEAVING, ""sleeping "" + RING_DELAY + "" ms for pending range setup"", true);
		 Thread.sleep(RING_DELAY);
		 Runnable finishLeaving = new Runnable() {
			 public void run() {
				 stopRPCServer();
				 Gossiper.instance.stop();
				 MessagingService.instance().shutdown();
				 StageManager.shutdownNow();
				 setMode(Mode.DECOMMISSIONED, true);
			 }
		 }
		;
		 unbootstrap(finishLeaving);
	 }
	 private void leaveRing() {
		 SystemTable.setBootstrapped(false);
		 tokenMetadata_.removeEndpoint(FBUtilities.getBroadcastAddress());
		 calculatePendingRanges();
		 Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.left(getLocalToken(),Gossiper.computeExpireTime()));
		 logger_.info(""Announcing that I have left the ring for "" + RING_DELAY + ""ms"");
		 try {
			 Thread.sleep(RING_DELAY);
		 }
		 catch (InterruptedException e) {
			 throw new AssertionError(e);
		 }
	 }
	 private void unbootstrap(final Runnable onFinish) {
		 Map<String, Multimap<Range<Token>, InetAddress>> rangesToStream = new HashMap<String, Multimap<Range<Token>, InetAddress>>();
		 for (final String table : Schema.instance.getNonSystemTables()) {
			 Multimap<Range<Token>, InetAddress> rangesMM = getChangedRangesForLeaving(table, FBUtilities.getBroadcastAddress());
			 if (logger_.isDebugEnabled()) logger_.debug(""Ranges needing transfer are ["" + StringUtils.join(rangesMM.keySet(), "","") + ""]"");
			 rangesToStream.put(table, rangesMM);
		 }
		 setMode(Mode.LEAVING, ""streaming data to other nodes"", true);
		 CountDownLatch latch = streamRanges(rangesToStream);
		 logger_.debug(""waiting for stream aks."");
		 try {
			 latch.await();
		 }
		 catch (InterruptedException e) {
			 throw new RuntimeException(e);
		 }
		 logger_.debug(""stream acks all received."");
		 leaveRing();
		 onFinish.run();
	 }
	 public void move(String newToken) throws IOException, InterruptedException, ConfigurationException {
		 getPartitioner().getTokenFactory().validate(newToken);
		 move(getPartitioner().getTokenFactory().fromString(newToken));
	 }
	 private void move(Token newToken) throws IOException {
		 if (newToken == null) throw new IOException(""Can't move to the undefined (null) token."");
		 if (tokenMetadata_.sortedTokens().contains(newToken)) throw new IOException(""target token "" + newToken + "" is already owned by another node."");
		 InetAddress localAddress = FBUtilities.getBroadcastAddress();
		 List<String> tablesToProcess = Schema.instance.getNonSystemTables();
		 for (String table : tablesToProcess) {
			 if (tokenMetadata_.getPendingRanges(table, localAddress).size() > 0) throw new UnsupportedOperationException(""data is currently moving to this node;
			 unable to leave the ring"");
		 }
		 Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.moving(newToken));
		 logger_.info(String.format(""Moving %s from %s to %s."", localAddress, getLocalToken(), newToken));
		 IEndpointSnitch snitch = DatabaseDescriptor.getEndpointSnitch();
		 Map<String, Multimap<InetAddress, Range<Token>>> rangesToFetch = new HashMap<String, Multimap<InetAddress, Range<Token>>>();
		 Map<String, Multimap<Range<Token>, InetAddress>> rangesToStreamByTable = new HashMap<String, Multimap<Range<Token>, InetAddress>>();
		 TokenMetadata tokenMetaClone = tokenMetadata_.cloneAfterAllSettled();
		 for (String table : tablesToProcess) {
			 AbstractReplicationStrategy strategy = Table.open(table).getReplicationStrategy();
			 Collection<Range<Token>> currentRanges = getRangesForEndpoint(table, localAddress);
			 Collection<Range<Token>> updatedRanges = strategy.getPendingAddressRanges(tokenMetadata_, newToken, localAddress);
			 Multimap<Range<Token>, InetAddress> rangeAddresses = strategy.getRangeAddresses(tokenMetadata_);
			 Pair<Set<Range<Token>>, Set<Range<Token>>> rangesPerTable = calculateStreamAndFetchRanges(currentRanges, updatedRanges);
			 Multimap<Range<Token>, InetAddress> rangesToFetchWithPreferredEndpoints = ArrayListMultimap.create();
			 for (Range<Token> toFetch : rangesPerTable.right) {
				 for (Range<Token> range : rangeAddresses.keySet()) {
					 if (range.contains(toFetch)) {
						 List<InetAddress> endpoints = snitch.getSortedListByProximity(localAddress, rangeAddresses.get(range));
						 rangesToFetchWithPreferredEndpoints.putAll(toFetch, endpoints);
					 }
				 }
			 }
			 Multimap<Range<Token>, InetAddress> rangeWithEndpoints = HashMultimap.create();
			 for (Range<Token> toStream : rangesPerTable.left) {
				 Set<InetAddress> currentEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(toStream.right, tokenMetadata_));
				 Set<InetAddress> newEndpoints = ImmutableSet.copyOf(strategy.calculateNaturalEndpoints(toStream.right, tokenMetaClone));
				 rangeWithEndpoints.putAll(toStream, Sets.difference(newEndpoints, currentEndpoints));
			 }
			 rangesToStreamByTable.put(table, rangeWithEndpoints);
			 Multimap<InetAddress, Range<Token>> workMap = RangeStreamer.getWorkMap(rangesToFetchWithPreferredEndpoints);
			 rangesToFetch.put(table, workMap);
			 if (logger_.isDebugEnabled()) logger_.debug(""Table {
			}
			: work map {
			}
			."", table, workMap);
		 }
		 if (!rangesToStreamByTable.isEmpty() || !rangesToFetch.isEmpty()) {
			 logger_.info(""Sleeping {
			}
			 ms before start streaming/fetching ranges."", RING_DELAY);
			 try {
				 Thread.sleep(RING_DELAY);
			 }
			 catch (InterruptedException e) {
				 throw new RuntimeException(""Sleep interrupted "" + e.getMessage());
			 }
			 setMode(Mode.MOVING, ""fetching new ranges and streaming old ranges"", true);
			 if (logger_.isDebugEnabled()) logger_.debug(""[Move->STREAMING] Work Map: "" + rangesToStreamByTable);
			 CountDownLatch streamLatch = streamRanges(rangesToStreamByTable);
			 if (logger_.isDebugEnabled()) logger_.debug(""[Move->FETCHING] Work Map: "" + rangesToFetch);
			 CountDownLatch fetchLatch = requestRanges(rangesToFetch);
			 try {
				 streamLatch.await();
				 fetchLatch.await();
			 }
			 catch (InterruptedException e) {
				 throw new RuntimeException(""Interrupted latch while waiting for stream/fetch ranges to finish: "" + e.getMessage());
			 }
		 }
		 setToken(newToken);
		 if (logger_.isDebugEnabled()) logger_.debug(""Successfully moved to new token {
		}
		"", getLocalToken());
	 }
	 public String getRemovalStatus() {
		 if (removingNode == null) {
			 return ""No token removals in process."";
		 }
		 return String.format(""Removing token (%s). Waiting for replication confirmation from [%s]."", tokenMetadata_.getToken(removingNode), StringUtils.join(replicatingNodes, "",""));
	 }
	 public void forceRemoveCompletion() {
		 if (!replicatingNodes.isEmpty() || !tokenMetadata_.getLeavingEndpoints().isEmpty()) {
			 logger_.warn(""Removal not confirmed for for "" + StringUtils.join(this.replicatingNodes, "",""));
			 for (InetAddress endpoint : tokenMetadata_.getLeavingEndpoints()) {
				 Token token = tokenMetadata_.getToken(endpoint);
				 Gossiper.instance.advertiseTokenRemoved(endpoint, token);
				 excise(token, endpoint);
			 }
			 replicatingNodes.clear();
			 removingNode = null;
		 }
		 else {
			 throw new UnsupportedOperationException(""No tokens to force removal on, call 'removetoken' first"");
		 }
	 }
	 public void removeToken(String tokenString) {
		 InetAddress myAddress = FBUtilities.getBroadcastAddress();
		 Token localToken = tokenMetadata_.getToken(myAddress);
		 Token token = getPartitioner().getTokenFactory().fromString(tokenString);
		 InetAddress endpoint = tokenMetadata_.getEndpoint(token);
		 if (endpoint == null) throw new UnsupportedOperationException(""Token not found."");
		 if (endpoint.equals(myAddress)) throw new UnsupportedOperationException(""Cannot remove node's own token"");
		 if (Gossiper.instance.getLiveMembers().contains(endpoint)) throw new UnsupportedOperationException(""Node "" + endpoint + "" is alive and owns this token. Use decommission command to remove it from the ring"");
		 if (tokenMetadata_.isLeaving(endpoint)) logger_.warn(""Node "" + endpoint + "" is already being removed, continuing removal anyway"");
		 if (!replicatingNodes.isEmpty()) throw new UnsupportedOperationException(""This node is already processing a removal. Wait for it to complete, or use 'removetoken force' if this has failed."");
		 for (String table : Schema.instance.getNonSystemTables()) {
			 if (Table.open(table).getReplicationStrategy().getReplicationFactor() == 1) continue;
			 Multimap<Range<Token>, InetAddress> changedRanges = getChangedRangesForLeaving(table, endpoint);
			 IFailureDetector failureDetector = FailureDetector.instance;
			 for (InetAddress ep : changedRanges.values()) {
				 if (failureDetector.isAlive(ep)) replicatingNodes.add(ep);
				 else logger_.warn(""Endpoint "" + ep + "" is down and will not receive data for re-replication of "" + endpoint);
			 }
		 }
		 removingNode = endpoint;
		 tokenMetadata_.addLeavingEndpoint(endpoint);
		 calculatePendingRanges();
		 Gossiper.instance.advertiseRemoving(endpoint, token, localToken);
		 restoreReplicaCount(endpoint, myAddress);
		 while (!replicatingNodes.isEmpty()) {
			 try {
				 Thread.sleep(100);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
		 }
		 excise(token, endpoint);
		 Gossiper.instance.advertiseTokenRemoved(endpoint, token);
		 replicatingNodes.clear();
		 removingNode = null;
	 }
	 public void confirmReplication(InetAddress node) {
		 if (!replicatingNodes.isEmpty()) {
			 replicatingNodes.remove(node);
		 }
		 else {
			 logger_.info(""Received unexpected REPLICATION_FINISHED message from "" + node + "". Was this node recently a removal coordinator?"");
		 }
	 }
	 public boolean isClientMode() {
		 return isClientMode;
	 }
	 public synchronized void requestGC() {
		 if (hasUnreclaimedSpace()) {
			 logger_.info(""requesting GC to free disk space"");
			 System.gc();
			 try {
				 Thread.sleep(1000);
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
		 }
	 }
	 private boolean hasUnreclaimedSpace() {
		 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
			 if (cfs.hasUnreclaimedSpace()) return true;
		 }
		 return false;
	 }
	 public String getOperationMode() {
		 return operationMode.toString();
	 }
	 public String getDrainProgress() {
		 return String.format(""Drained %s/%s ColumnFamilies"", remainingCFs, totalCFs);
	 }
	 public synchronized void drain() throws IOException, InterruptedException, ExecutionException {
		 ExecutorService mutationStage = StageManager.getStage(Stage.MUTATION);
		 if (mutationStage.isTerminated()) {
			 logger_.warn(""Cannot drain node (did it already happen?)"");
			 return;
		 }
		 setMode(Mode.DRAINING, ""starting drain process"", true);
		 stopRPCServer();
		 optionalTasks.shutdown();
		 Gossiper.instance.stop();
		 setMode(Mode.DRAINING, ""shutting down MessageService"", false);
		 MessagingService.instance().shutdown();
		 setMode(Mode.DRAINING, ""waiting for streaming"", false);
		 MessagingService.instance().waitForStreaming();
		 setMode(Mode.DRAINING, ""clearing mutation stage"", false);
		 mutationStage.shutdown();
		 mutationStage.awaitTermination(3600, TimeUnit.SECONDS);
		 StorageProxy.instance.verifyNoHintsInProgress();
		 setMode(Mode.DRAINING, ""flushing column families"", false);
		 List<ColumnFamilyStore> cfses = new ArrayList<ColumnFamilyStore>();
		 for (String tableName : Schema.instance.getNonSystemTables()) {
			 Table table = Table.open(tableName);
			 cfses.addAll(table.getColumnFamilyStores());
		 }
		 totalCFs = remainingCFs = cfses.size();
		 for (ColumnFamilyStore cfs : cfses) {
			 cfs.forceBlockingFlush();
			 remainingCFs--;
		 }
		 ColumnFamilyStore.postFlushExecutor.shutdown();
		 ColumnFamilyStore.postFlushExecutor.awaitTermination(60, TimeUnit.SECONDS);
		 CommitLog.instance.shutdownBlocking();
		 tasks.shutdown();
		 if (!tasks.awaitTermination(1, TimeUnit.MINUTES)) logger_.warn(""Miscellaneous task executor still busy after one minute;
		 proceeding with shutdown"");
		 setMode(Mode.DRAINED, true);
	 }
	 IPartitioner setPartitionerUnsafe(IPartitioner newPartitioner) {
		 IPartitioner oldPartitioner = DatabaseDescriptor.getPartitioner();
		 DatabaseDescriptor.setPartitioner(newPartitioner);
		 valueFactory = new VersionedValue.VersionedValueFactory(getPartitioner());
		 return oldPartitioner;
	 }
	 TokenMetadata setTokenMetadataUnsafe(TokenMetadata tmd) {
		 TokenMetadata old = tokenMetadata_;
		 tokenMetadata_ = tmd;
		 return old;
	 }
	 public void truncate(String keyspace, String columnFamily) throws UnavailableException, TimeoutException, IOException {
		 StorageProxy.truncateBlocking(keyspace, columnFamily);
	 }
	 public Map<String, Float> getOwnership() {
		 List<Token> sortedTokens = new ArrayList<Token>(tokenMetadata_.getTokenToEndpointMapForReading().keySet());
		 Collections.sort(sortedTokens);
		 Map<Token, Float> token_map = getPartitioner().describeOwnership(sortedTokens);
		 Map<String, Float> string_map = new HashMap<String, Float>();
		 for(Map.Entry<Token, Float> entry : token_map.entrySet()) {
			 string_map.put(entry.getKey().toString(), entry.getValue());
		 }
		 return string_map;
	 }
	 public Map<String, Float> effectiveOwnership(String keyspace) throws ConfigurationException {
		 Map<String, Float> effective = Maps.newHashMap();
		 if (Schema.instance.getNonSystemTables().size() <= 0) throw new ConfigurationException(""Couldn't find any Non System Keyspaces to infer replication topology"");
		 if (keyspace == null && !hasSameReplication(Schema.instance.getNonSystemTables())) throw new ConfigurationException(""Non System keyspaces doesnt have the same topology"");
		 if (keyspace == null) keyspace = Schema.instance.getNonSystemTables().get(0);
		 List<Token> sortedTokens = new ArrayList<Token>(tokenMetadata_.getTokenToEndpointMapForReading().keySet());
		 Collections.sort(sortedTokens);
		 Map<Token, Float> ownership = getPartitioner().describeOwnership(sortedTokens);
		 for (Entry<InetAddress, Collection<Range<Token>>> ranges : constructEndpointToRangeMap(keyspace).entrySet()) {
			 Token token = tokenMetadata_.getToken(ranges.getKey());
			 for (Range<Token> range: ranges.getValue()) {
				 float value = effective.get(token.toString()) == null ? 0.0F : effective.get(token.toString());
				 effective.put(token.toString(), value + ownership.get(range.left));
			 }
		 }
		 return effective;
	 }
	 private boolean hasSameReplication(List<String> list) {
		 if (list.isEmpty()) return false;
		 for (int i = 0;
		 i < list.size() -1;
		 i++) {
			 KSMetaData ksm1 = Schema.instance.getKSMetaData(Schema.instance.getNonSystemTables().get(i));
			 KSMetaData ksm2 = Schema.instance.getKSMetaData(Schema.instance.getNonSystemTables().get(i + 1));
			 if (!ksm1.strategyClass.equals(ksm2.strategyClass) || !Iterators.elementsEqual(ksm1.strategyOptions.entrySet().iterator(), ksm2.strategyOptions.entrySet().iterator())) return false;
		 }
		 return true;
	 }
	 public List<String> getKeyspaces() {
		 List<String> tableslist = new ArrayList<String>(Schema.instance.getTables());
		 return Collections.unmodifiableList(tableslist);
	 }
	 public void updateSnitch(String epSnitchClassName, Boolean dynamic, Integer dynamicUpdateInterval, Integer dynamicResetInterval, Double dynamicBadnessThreshold) throws ConfigurationException {
		 IEndpointSnitch oldSnitch = DatabaseDescriptor.getEndpointSnitch();
		 IEndpointSnitch newSnitch = FBUtilities.construct(epSnitchClassName, ""snitch"");
		 if (dynamic) {
			 DatabaseDescriptor.setDynamicUpdateInterval(dynamicUpdateInterval);
			 DatabaseDescriptor.setDynamicResetInterval(dynamicResetInterval);
			 DatabaseDescriptor.setDynamicBadnessThreshold(dynamicBadnessThreshold);
			 newSnitch = new DynamicEndpointSnitch(newSnitch);
		 }
		 DatabaseDescriptor.setEndpointSnitch(newSnitch);
		 for (String ks : Schema.instance.getTables()) {
			 Table.open(ks).getReplicationStrategy().snitch = newSnitch;
		 }
		 if (oldSnitch instanceof DynamicEndpointSnitch) ((DynamicEndpointSnitch)oldSnitch).unregisterMBean();
	 }
	 public void flushLargestMemtables() {
		 ColumnFamilyStore largest = null;
		 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
			 long total = cfs.getTotalMemtableLiveSize();
			 if (total > 0 && (largest == null || total > largest.getTotalMemtableLiveSize())) {
				 logger_.debug(total + "" estimated memtable size for "" + cfs);
				 largest = cfs;
			 }
		 }
		 if (largest == null) {
			 logger_.info(""Unable to reduce heap usage since there are no dirty column families"");
			 return;
		 }
		 logger_.warn(""Flushing "" + largest + "" to relieve memory pressure"");
		 largest.forceFlush();
	 }
	 private CountDownLatch streamRanges(final Map<String, Multimap<Range<Token>, InetAddress>> rangesToStreamByTable) {
		 final CountDownLatch latch = new CountDownLatch(rangesToStreamByTable.keySet().size());
		 for (Map.Entry<String, Multimap<Range<Token>, InetAddress>> entry : rangesToStreamByTable.entrySet()) {
			 Multimap<Range<Token>, InetAddress> rangesWithEndpoints = entry.getValue();
			 if (rangesWithEndpoints.isEmpty()) {
				 latch.countDown();
				 continue;
			 }
			 final String table = entry.getKey();
			 final Set<Map.Entry<Range<Token>, InetAddress>> pending = new HashSet<Map.Entry<Range<Token>, InetAddress>>(rangesWithEndpoints.entries());
			 for (final Map.Entry<Range<Token>, InetAddress> endPointEntry : rangesWithEndpoints.entries()) {
				 final Range<Token> range = endPointEntry.getKey();
				 final InetAddress newEndpoint = endPointEntry.getValue();
				 final IStreamCallback callback = new IStreamCallback() {
					 public void onSuccess() {
						 synchronized (pending) {
							 pending.remove(endPointEntry);
							 if (pending.isEmpty()) latch.countDown();
						 }
					 }
					 public void onFailure() {
						 logger_.warn(""Streaming to "" + endPointEntry + "" failed"");
						 onSuccess();
					 }
				 }
				;
				 StageManager.getStage(Stage.STREAM).execute(new Runnable() {
					 public void run() {
						 StreamOut.transferRanges(newEndpoint, Table.open(table), Arrays.asList(range), callback, OperationType.UNBOOTSTRAP);
					 }
				 }
				);
			 }
		 }
		 return latch;
	 }
	 private CountDownLatch requestRanges(final Map<String, Multimap<InetAddress, Range<Token>>> ranges) {
		 final CountDownLatch latch = new CountDownLatch(ranges.keySet().size());
		 for (Map.Entry<String, Multimap<InetAddress, Range<Token>>> entry : ranges.entrySet()) {
			 Multimap<InetAddress, Range<Token>> endpointWithRanges = entry.getValue();
			 if (endpointWithRanges.isEmpty()) {
				 latch.countDown();
				 continue;
			 }
			 final String table = entry.getKey();
			 final Set<InetAddress> pending = new HashSet<InetAddress>(endpointWithRanges.keySet());
			 for (final InetAddress source: endpointWithRanges.keySet()) {
				 Collection<Range<Token>> toFetch = endpointWithRanges.get(source);
				 final IStreamCallback callback = new IStreamCallback() {
					 public void onSuccess() {
						 pending.remove(source);
						 if (pending.isEmpty()) latch.countDown();
					 }
					 public void onFailure() {
						 logger_.warn(""Streaming from "" + source + "" failed"");
						 onSuccess();
					 }
				 }
				;
				 if (logger_.isDebugEnabled()) logger_.debug(""Requesting from "" + source + "" ranges "" + StringUtils.join(toFetch, "", ""));
				 StreamIn.requestRanges(source, table, toFetch, callback, OperationType.BOOTSTRAP);
			 }
		 }
		 return latch;
	 }
	 public Pair<Set<Range<Token>>, Set<Range<Token>>> calculateStreamAndFetchRanges(Collection<Range<Token>> current, Collection<Range<Token>> updated) {
		 Set<Range<Token>> toStream = new HashSet<Range<Token>>();
		 Set<Range<Token>> toFetch = new HashSet<Range<Token>>();
		 for (Range r1 : current) {
			 boolean intersect = false;
			 for (Range r2 : updated) {
				 if (r1.intersects(r2)) {
					 toStream.addAll(r1.subtract(r2));
					 intersect = true;
					 break;
				 }
			 }
			 if (!intersect) {
				 toStream.add(r1);
			 }
		 }
		 for (Range r2 : updated) {
			 boolean intersect = false;
			 for (Range r1 : current) {
				 if (r2.intersects(r1)) {
					 toFetch.addAll(r2.subtract(r1));
					 intersect = true;
					 break;
				 }
			 }
			 if (!intersect) {
				 toFetch.add(r2);
			 }
		 }
		 return new Pair<Set<Range<Token>>, Set<Range<Token>>>(toStream, toFetch);
	 }
	 public void bulkLoad(String directory) {
		 File dir = new File(directory);
		 if (!dir.exists() || !dir.isDirectory()) throw new IllegalArgumentException(""Invalid directory "" + directory);
		 SSTableLoader.Client client = new SSTableLoader.Client() {
			 public void init(String keyspace) {
				 for (Map.Entry<Range<Token>, List<InetAddress>> entry : StorageService.instance.getRangeToAddressMap(keyspace).entrySet()) {
					 Range<Token> range = entry.getKey();
					 for (InetAddress endpoint : entry.getValue()) addRangeForEndpoint(range, endpoint);
				 }
			 }
			 public boolean validateColumnFamily(String keyspace, String cfName) {
				 return Schema.instance.getCFMetaData(keyspace, cfName) != null;
			 }
		 }
		;
		 SSTableLoader.OutputHandler oh = new SSTableLoader.OutputHandler() {
			 public void output(String msg) {
				 logger_.info(msg);
			 }
			 public void debug(String msg) {
				 logger_.debug(msg);
			 }
		 }
		;
		 SSTableLoader loader = new SSTableLoader(dir, client, oh);
		 try {
			 loader.stream().get();
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public int getExceptionCount() {
		 return AbstractCassandraDaemon.exceptions.get();
	 }
	 public void rescheduleFailedDeletions() {
		 SSTableDeletingTask.rescheduleFailedTasks();
	 }
	 public void loadNewSSTables(String ksName, String cfName) {
		 ColumnFamilyStore.loadNewSSTables(ksName, cfName);
	 }
	 public List<String> getRangeKeySample() {
		 List<DecoratedKey> keys = keySamples(ColumnFamilyStore.allUserDefined(), getLocalPrimaryRange());
		 List<String> sampledKeys = new ArrayList<String>();
		 for (DecoratedKey key : keys) sampledKeys.add(key.getToken().toString());
		 return sampledKeys;
	 }
	 public void rebuildSecondaryIndex(String ksName, String cfName, String... idxNames) {
		 ColumnFamilyStore.rebuildSecondaryIndex(ksName, cfName, idxNames);
	 }
	 public void resetLocalSchema() throws IOException {
		 MigrationManager.resetLocalSchema();
	 }
}",1,0,0,0
"public class DebuggableThreadPoolExecutor extends ThreadPoolExecutor{
	 protected static Logger logger = LoggerFactory.getLogger(DebuggableThreadPoolExecutor.class);
	 public static final RejectedExecutionHandler blockingExecutionHandler = new RejectedExecutionHandler() {
		 public void rejectedExecution(Runnable task, ThreadPoolExecutor executor) {
			 ((DebuggableThreadPoolExecutor) executor).onInitialRejection(task);
			 BlockingQueue<Runnable> queue = executor.getQueue();
			 while (true) {
				 if (executor.isShutdown()) {
					 ((DebuggableThreadPoolExecutor) executor).onFinalRejection(task);
					 throw new RejectedExecutionException(""ThreadPoolExecutor has shut down"");
				 }
				 try {
					 if (queue.offer(task, 1000, TimeUnit.MILLISECONDS)) {
						 ((DebuggableThreadPoolExecutor) executor).onFinalAccept(task);
						 break;
					 }
				 }
				 catch (InterruptedException e) {
					 throw new AssertionError(e);
				 }
			 }
		 }
	 }
	;
	 public DebuggableThreadPoolExecutor(String threadPoolName, int priority) {
		 this(1, Integer.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory(threadPoolName, priority));
	 }
	 public DebuggableThreadPoolExecutor(int corePoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> queue, ThreadFactory factory) {
		 this(corePoolSize, corePoolSize, keepAliveTime, unit, queue, factory);
	 }
	 public DebuggableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
		 super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
		 allowCoreThreadTimeOut(true);
		 this.setRejectedExecutionHandler(blockingExecutionHandler);
	 }
	 public static DebuggableThreadPoolExecutor createWithPoolSize(String threadPoolName, int size) {
		 return new DebuggableThreadPoolExecutor(size, Integer.MAX_VALUE, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory(threadPoolName));
	 }
	 protected void onInitialRejection(Runnable task) {
	}
	 protected void onFinalAccept(Runnable task) {
	}
	 protected void onFinalRejection(Runnable task) {
	}
	 protected void afterExecute(Runnable r, Throwable t) {
		 super.afterExecute(r,t);
		 logExceptionsAfterExecute(r, t);
	 }
	 public static void logExceptionsAfterExecute(Runnable r, Throwable t) {
		 Throwable hiddenThrowable = extractThrowable(r);
		 if (hiddenThrowable != null) handleOrLog(hiddenThrowable);
		 if (t != null && Thread.getDefaultUncaughtExceptionHandler() == null) handleOrLog(t);
	 }
	 public static void handleOrLog(Throwable t) {
		 if (Thread.getDefaultUncaughtExceptionHandler() == null) logger.error(""Error in ThreadPoolExecutor"", t);
		 else Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), t);
	 }
	 public static Throwable extractThrowable(Runnable runnable) {
		 if ((runnable instanceof Future<?>) && ((Future<?>) runnable).isDone()) {
			 try {
				 ((Future<?>) runnable).get();
			 }
			 catch (InterruptedException e) {
				 throw new AssertionError(e);
			 }
			 catch (CancellationException e) {
				 logger.debug(""Task cancelled"", e);
			 }
			 catch (ExecutionException e) {
				 return e.getCause();
			 }
		 }
		 return null;
	 }
}",0,0,0,0
"public <T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {
	 checkNotNull(callable);
	 checkNotNull(timeoutUnit);
	 try {
		 return callable.call();
	 }
	 catch (RuntimeException e) {
		 throw new UncheckedExecutionException(e);
	 }
	 catch (Exception e) {
		 throw new ExecutionException(e);
	 }
	 catch (Error e) {
		 throw new ExecutionError(e);
	 }
	 catch (Throwable e) {
		 throw new ExecutionException(e);
	 }
 }",0,0,1,0
"final class SearchFirstStringNode extends Node {
	 private static final int[] UNINTIALIZED_CACHED_INDICES = new int[0];
	 private final VectorLengthProfile targetLengthProfile = VectorLengthProfile.create();
	 private final VectorLengthProfile elementsLengthProfile = VectorLengthProfile.create();
	 private final ValueProfile targetClassProfile = ValueProfile.createClassProfile();
	 private final ValueProfile elementsClassProfile = ValueProfile.createClassProfile();
	 private StringEqualsNode stringEquals = CompareStringNode.createEquals();
	 private CompareStringNode stringStartsWith;
	 private StringEqualsNode equalsDuplicate;
	 private final NACheck elementsNACheck = NACheck.create();
	 private final NACheck targetNACheck = NACheck.create();
	 private final BranchProfile everFoundDuplicate = BranchProfile.create();
	 private final BranchProfile seenInvalid = BranchProfile.create();
	 private final boolean useNAForNotFound;
	 private final boolean exactMatch;
	 private int[] cachedIndices;
	 private SearchFirstStringNode(boolean exactMatch, boolean useNAForNotFound) {
		 this.exactMatch = exactMatch;
		 this.useNAForNotFound = useNAForNotFound;
		 if (!exactMatch) {
			 stringStartsWith = CompareStringNode.createStartsWith();
		 }
	 }
	 public RAbstractIntVector apply(RAbstractStringVector target, RAbstractStringVector elements, int notFoundStartIndex, RStringVector names) {
		 RAbstractStringVector targetProfiled = targetClassProfile.profile(target);
		 RAbstractStringVector elementsProfiled = elementsClassProfile.profile(elements);
		 int targetLength = targetLengthProfile.profile(targetProfiled.getLength());
		 int elementsLength = elementsLengthProfile.profile(elementsProfiled.getLength());
		 targetNACheck.enable(target);
		 elementsNACheck.enable(elements);
		 if (cachedIndices == UNINTIALIZED_CACHED_INDICES) {
			 CompilerDirectives.transferToInterpreterAndInvalidate();
			 cachedIndices = searchCached(targetProfiled, targetLength, elementsProfiled, elementsLength, names);
		 }
		 if (cachedIndices != null) {
			 if (!isCacheValid(targetProfiled, targetLength, elementsProfiled, elementsLength, cachedIndices)) {
				 CompilerDirectives.transferToInterpreterAndInvalidate();
				 cachedIndices = null;
			 }
			 else {
				 assert sameVector(searchCached(target, targetLength, elements, elementsLength, names), cachedIndices);
				 return RDataFactory.createIntVector(cachedIndices, true, names);
			 }
		 }
		 return searchGeneric(targetProfiled, targetLength, elementsProfiled, elementsLength, notFoundStartIndex, false, names);
	 }
	 public static SearchFirstStringNode createNode(boolean exactMatch, boolean useNAForNotFound) {
		 return new SearchFirstStringNode(exactMatch, useNAForNotFound);
	 }
	 private int[] searchCached(RAbstractStringVector target, int targetLength, RAbstractStringVector elements, int elementsLength, RStringVector names) {
		 if (exactMatch) {
			 RAbstractIntVector genericResult = searchGeneric(target, targetLength, elements, elementsLength, -1, true, names);
			 if (genericResult != null) {
				 return genericResult.materialize().getReadonlyData();
			 }
		 }
		 return null;
	 }
	 private boolean isCacheValid(RAbstractStringVector target, int targetLength, RAbstractStringVector elements, int elementsLength, int[] cached) {
		 int cachedLength = cached.length;
		 if (elementsLength != cachedLength) {
			 seenInvalid.enter();
			 return false;
		 }
		 for (int i = 0;
		 i < cachedLength;
		 i++) {
			 int cachedIndex = cached[i];
			 String cachedElement = elements.getDataAt(i);
			 int cachedElementHash = cachedElement.hashCode();
			 assert !elementsNACheck.check(cachedElement) && cachedElement.length() > 0;
			 int cachedTranslatedIndex = cachedIndex - 1;
			 for (int j = 0;
			 j < cachedTranslatedIndex;
			 j++) {
				 String targetString = target.getDataAt(j);
				 if (!targetNACheck.check(targetString) && stringEquals.executeCompare(cachedElement, cachedElementHash, targetString)) {
					 seenInvalid.enter();
					 return false;
				 }
			 }
			 if (cachedTranslatedIndex < targetLength) {
				 String targetString = target.getDataAt(cachedTranslatedIndex);
				 if (!targetNACheck.check(targetString) && !stringEquals.executeCompare(cachedElement, cachedElementHash, targetString)) {
					 seenInvalid.enter();
					 return false;
				 }
			 }
			 else {
				 seenInvalid.enter();
				 return false;
			 }
		 }
		 return true;
	 }
	 private static boolean sameVector(int[] a, int[] b) {
		 if (a == null) {
			 return false;
		 }
		 if (a.length != b.length) {
			 return false;
		 }
		 for (int i = 0;
		 i < a.length;
		 i++) {
			 if (a[i] != b[i]) {
				 return false;
			 }
		 }
		 return true;
	 }
	 private final BranchProfile notFoundProfile = BranchProfile.create();
	 private final ConditionProfile hashingProfile = ConditionProfile.createBinaryProfile();
	 private RAbstractIntVector searchGeneric(RAbstractStringVector target, int targetLength, RAbstractStringVector elements, int elementsLength, int notFoundStartIndex, boolean nullOnNotFound, RStringVector names) {
		 int[] indices = new int[elementsLength];
		 boolean resultComplete = true;
		 long hashingCost = targetLength * 10L + 10 ;
		 long lookupCost = elementsLength * 2L;
		 long nestedLoopCost = targetLength * (long) elementsLength;
		 NonRecursiveHashMapCharacter map;
		 if (hashingProfile.profile(nestedLoopCost > hashingCost + lookupCost)) {
			 map = new NonRecursiveHashMapCharacter(targetLength);
			 for (int i = 0;
			 i < targetLength;
			 i++) {
				 String name = target.getDataAt(i);
				 if (!targetNACheck.check(name)) {
					 map.put(name, i);
				 }
			 }
		 }
		 else {
			 map = null;
		 }
		 int notFoundIndex = notFoundStartIndex;
		 for (int i = 0;
		 i < elementsLength;
		 i++) {
			 String element = elements.getDataAt(i);
			 boolean isElementNA = elementsNACheck.check(element) || element.length() == 0;
			 if (!isElementNA) {
				 int index;
				 if (map != null) {
					 index = map.get(element);
					 if (!exactMatch && index < 0) {
						 index = findNonExactIndex(target, targetLength, element);
					 }
				 }
				 else {
					 index = findIndex(target, targetLength, element);
				 }
				 if (index >= 0) {
					 indices[i] = index + 1;
					 continue;
				 }
			 }
			 notFoundProfile.enter();
			 if (nullOnNotFound) {
				 return null;
			 }
			 else {
				 int prevDuplicateIndex = -1;
				 if (!isElementNA) {
					 prevDuplicateIndex = findFirstDuplicate(elements, element, i);
				 }
				 int nextIndex;
				 if (prevDuplicateIndex == -1) {
					 if (useNAForNotFound) {
						 resultComplete = false;
						 nextIndex = RRuntime.INT_NA;
					 }
					 else {
						 nextIndex = ++notFoundIndex;
					 }
				 }
				 else {
					 nextIndex = indices[prevDuplicateIndex];
				 }
				 indices[i] = nextIndex;
			 }
		 }
		 return RDataFactory.createIntVector(indices, resultComplete && elements.isComplete(), names);
	 }
	 private int findNonExactIndex(RAbstractStringVector target, int targetLength, String element) {
		 assert !exactMatch;
		 int nonExactIndex = -1;
		 for (int j = 0;
		 j < targetLength;
		 j++) {
			 String targetValue = target.getDataAt(j);
			 if (!targetNACheck.check(targetValue)) {
				 if (stringStartsWith.executeCompare(targetValue, element)) {
					 if (nonExactIndex == -1) {
						 nonExactIndex = j;
					 }
					 else {
						 return -1;
					 }
				 }
			 }
		 }
		 return nonExactIndex;
	 }
	 private int findIndex(RAbstractStringVector target, int targetLength, String element) {
		 int nonExactIndex = -1;
		 int elementHash = element.hashCode();
		 for (int j = 0;
		 j < targetLength;
		 j++) {
			 String targetValue = target.getDataAt(j);
			 if (!targetNACheck.check(targetValue)) {
				 if (stringEquals.executeCompare(element, elementHash, targetValue)) {
					 return j;
				 }
				 if (!exactMatch) {
					 if (stringStartsWith.executeCompare(targetValue, element)) {
						 if (nonExactIndex == -1) {
							 nonExactIndex = j;
						 }
						 else {
							 nonExactIndex = -2;
						 }
					 }
				 }
			 }
		 }
		 return nonExactIndex;
	 }
	 private int findFirstDuplicate(RAbstractStringVector elements, String element, int currentIndex) {
		 if (equalsDuplicate == null) {
			 CompilerDirectives.transferToInterpreterAndInvalidate();
			 equalsDuplicate = insert(CompareStringNode.createEquals());
		 }
		 int elementHash = element.hashCode();
		 for (int j = 0;
		 j < currentIndex;
		 j++) {
			 String otherElement = elements.getDataAt(j);
			 if (!targetNACheck.check(otherElement) && equalsDuplicate.executeCompare(element, elementHash, otherElement)) {
				 everFoundDuplicate.enter();
				 return j;
			 }
		 }
		 return -1;
	 }
	 abstract static class CompareStringNode extends Node {
		 public abstract boolean executeCompare(String a, String b);
		 public static StringEqualsNode createEquals() {
			 return new StringEqualsNode();
		 }
		 public static StringStartsWithNode createStartsWith() {
			 return new StringStartsWithNode();
		 }
		 public static class StringEqualsNode extends CompareStringNode {
			 private final ConditionProfile identityEquals = ConditionProfile.createBinaryProfile();
			 private final ConditionProfile hashEquals = ConditionProfile.createBinaryProfile();
			 public final boolean executeCompare(String a, String b) {
				 assert !RRuntime.isNA(a);
				 assert !RRuntime.isNA(b);
				 if (identityEquals.profile(Utils.fastPathIdentityEquals(a, b))) {
					 return true;
				 }
				 else {
					 if (hashEquals.profile(a.hashCode() != b.hashCode())) {
						 return false;
					 }
					 return a.equals(b);
				 }
			 }
			 public final boolean executeCompare(String a, int aHash, String b) {
				 assert !RRuntime.isNA(a);
				 assert !RRuntime.isNA(b);
				 if (identityEquals.profile(Utils.fastPathIdentityEquals(a, b))) {
					 return true;
				 }
				 else {
					 if (hashEquals.profile(aHash != b.hashCode())) {
						 return false;
					 }
					 return a.equals(b);
				 }
			 }
		 }
		 private static class StringStartsWithNode extends CompareStringNode {
			 private final ConditionProfile identityEquals = ConditionProfile.createBinaryProfile();
			 public final boolean executeCompare(String a, String b) {
				 assert !RRuntime.isNA(a);
				 assert !RRuntime.isNA(b);
				 if (identityEquals.profile(Utils.fastPathIdentityEquals(a, b))) {
					 return true;
				 }
				 else {
					 return a.startsWith(b);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class ClientState{
	 private static final int MAX_CACHE_PREPARED = 10000;
	 private static Logger logger = LoggerFactory.getLogger(ClientState.class);
	 public static final SemanticVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
	 private AuthenticatedUser user;
	 private String keyspace;
	 private final List<Object> resource = new ArrayList<Object>();
	 private SemanticVersion cqlVersion = DEFAULT_CQL_VERSION;
	 private Map<Integer, CQLStatement> prepared = new LinkedHashMap<Integer, CQLStatement>(16, 0.75f, true) {
		 protected boolean removeEldestEntry(Map.Entry<Integer, CQLStatement> eldest) {
			 return size() > MAX_CACHE_PREPARED;
		 }
	 }
	;
	 private Map<Integer, org.apache.cassandra.cql3.CQLStatement> cql3Prepared = new LinkedHashMap<Integer, org.apache.cassandra.cql3.CQLStatement>(16, 0.75f, true) {
		 protected boolean removeEldestEntry(Map.Entry<Integer, org.apache.cassandra.cql3.CQLStatement> eldest) {
			 return size() > MAX_CACHE_PREPARED;
		 }
	 }
	;
	 private long clock;
	 public ClientState() {
		 reset();
	 }
	 public Map<Integer, CQLStatement> getPrepared() {
		 return prepared;
	 }
	 public Map<Integer, org.apache.cassandra.cql3.CQLStatement> getCQL3Prepared() {
		 return cql3Prepared;
	 }
	 public String getRawKeyspace() {
		 return keyspace;
	 }
	 public String getKeyspace() throws InvalidRequestException {
		 if (keyspace == null) throw new InvalidRequestException(""no keyspace has been specified"");
		 return keyspace;
	 }
	 public void setKeyspace(String ks) throws InvalidRequestException {
		 if (Schema.instance.getKSMetaData(ks) == null) throw new InvalidRequestException(""Keyspace '"" + ks + ""' does not exist"");
		 keyspace = ks;
	 }
	 public String getSchedulingValue() {
		 switch(DatabaseDescriptor.getRequestSchedulerId()) {
			 case keyspace: return keyspace;
		 }
		 return ""default"";
	 }
	 public void login(Map<? extends CharSequence,? extends CharSequence> credentials) throws AuthenticationException {
		 AuthenticatedUser user = DatabaseDescriptor.getAuthenticator().authenticate(credentials);
		 if (logger.isDebugEnabled()) logger.debug(""logged in: {
		}
		"", user);
		 this.user = user;
	 }
	 public void logout() {
		 if (logger.isDebugEnabled()) logger.debug(""logged out: {
		}
		"", user);
		 reset();
	 }
	 private void resourceClear() {
		 resource.clear();
		 resource.add(Resources.ROOT);
		 resource.add(Resources.KEYSPACES);
	 }
	 public void reset() {
		 user = DatabaseDescriptor.getAuthenticator().defaultUser();
		 keyspace = null;
		 resourceClear();
		 prepared.clear();
		 cql3Prepared.clear();
	 }
	 public void hasKeyspaceSchemaAccess(Permission perm) throws InvalidRequestException {
		 validateLogin();
		 resourceClear();
		 Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
		 hasAccess(user, perms, perm, resource);
	 }
	 public void hasColumnFamilySchemaAccess(Permission perm) throws InvalidRequestException {
		 validateLogin();
		 validateKeyspace();
		 if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE) throw new InvalidRequestException(""system keyspace is not user-modifiable"");
		 resourceClear();
		 resource.add(keyspace);
		 Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
		 hasAccess(user, perms, perm, resource);
	 }
	 public void hasColumnFamilyAccess(String columnFamily, Permission perm) throws InvalidRequestException {
		 hasColumnFamilyAccess(keyspace, columnFamily, perm);
	 }
	 public void hasColumnFamilyAccess(String keyspace, String columnFamily, Permission perm) throws InvalidRequestException {
		 validateLogin();
		 validateKeyspace();
		 resourceClear();
		 resource.add(keyspace);
		 resource.add(columnFamily);
		 Set<Permission> perms = DatabaseDescriptor.getAuthority().authorize(user, resource);
		 hasAccess(user, perms, perm, resource);
	 }
	 private void validateLogin() throws InvalidRequestException {
		 if (user == null) throw new InvalidRequestException(""You have not logged in"");
	 }
	 private void validateKeyspace() throws InvalidRequestException {
		 if (keyspace == null) throw new InvalidRequestException(""You have not set a keyspace for this session"");
	 }
	 private static void hasAccess(AuthenticatedUser user, Set<Permission> perms, Permission perm, List<Object> resource) throws InvalidRequestException {
		 if (perms.contains(perm)) return;
		 throw new InvalidRequestException(String.format(""%s does not have permission %s for %s"", user, perm, Resources.toString(resource)));
	 }
	 public long getTimestamp() {
		 long current = System.currentTimeMillis() * 1000;
		 clock = clock >= current ? clock + 1 : current;
		 return clock;
	 }
	 public void setCQLVersion(String str) throws InvalidRequestException {
		 SemanticVersion version;
		 try {
			 version = new SemanticVersion(str);
		 }
		 catch (IllegalArgumentException e) {
			 throw new InvalidRequestException(e.getMessage());
		 }
		 SemanticVersion cql = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
		 SemanticVersion cql3 = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
		 if (version.isSupportedBy(cql)) cqlVersion = cql;
		 else if (version.isSupportedBy(cql3)) cqlVersion = cql3;
		 else throw new InvalidRequestException(String.format(""Provided version %s is not supported by this server (supported: %s)"", version, StringUtils.join(getCQLSupportedVersion(), "", "")));
	 }
	 public SemanticVersion getCQLVersion() {
		 return cqlVersion;
	 }
	 public static SemanticVersion[] getCQLSupportedVersion() {
		 SemanticVersion cql = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
		 SemanticVersion cql3 = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
		 return new SemanticVersion[]{
		 cql, cql3 }
		;
	 }
}",0,0,0,0
"public void reloadExpectedTimeAndConfig(SLACalcStatus slaCalc) throws JPAExecutorException {
	 SLARegistrationBean regBean = SLARegistrationQueryExecutor.getInstance().get( SLARegQuery.GET_SLA_EXPECTED_VALUE_CONFIG, slaCalc.getId());
	 if (regBean.getExpectedDuration() > 0) {
		 slaCalc.getSLARegistrationBean().setExpectedDuration(regBean.getExpectedDuration());
	 }
	 if (regBean.getExpectedEnd() != null) {
		 slaCalc.getSLARegistrationBean().setExpectedEnd(regBean.getExpectedEnd());
	 }
	 if (regBean.getExpectedStart() != null) {
		 slaCalc.getSLARegistrationBean().setExpectedStart(regBean.getExpectedStart());
	 }
	 if (regBean.getSLAConfigMap().containsKey(OozieClient.SLA_DISABLE_ALERT)) {
		 slaCalc.getSLARegistrationBean().addToSLAConfigMap(OozieClient.SLA_DISABLE_ALERT, regBean.getSLAConfigMap().get(OozieClient.SLA_DISABLE_ALERT));
	 }
	 if (regBean.getNominalTime() != null) {
		 slaCalc.getSLARegistrationBean().setNominalTime(regBean.getNominalTime());
	 }
 }",0,0,1,0
"private void assemble() throws IOException {
	InputStream in = null;
	OutputStream out = null;
	totalAssembled = 0L;
	assembling = true;
	assembleFinished = false;
	File outFile = new File(outputFormat == 0 ? getOutputFolder() : folder, getOutputFileName(true));
	try {
		if (stopFlag)return;
		Logger.log(""assembling... "");
		out = new FileOutputStream(outFile);
		out.write(flv_sig);
		for (Segment s : chunks) {
			File inFile = new File(folder, s.getId());
			in = new FileInputStream(inFile);
			long streamPos = 0, streamLen = inFile.length();
			while (streamPos < streamLen) {
				if (stopFlag) {
					return;
				}
				long boxsize = readInt32(in);
				streamPos += 4;
				String box_type = readStringBytes(in, 4);
				streamPos += 4;
				if (boxsize == 1) {
					boxsize = readInt64(in) - 16;
					streamPos += 8;
				}
				 else {
					boxsize -= 8;
				}
				if (box_type.equals(""mdat"")) {
					long boxsz = boxsize;
					while (boxsz > 0) {
						if (stopFlag)return;
						int c = (int) (boxsz > b.length ? b.length : boxsz);
						int x = in.read(b, 0, c);
						if (x == -1)throw new IOException(""Unexpected EOF"");
						out.write(b, 0, x);
						boxsz -= x;
						totalAssembled += x;
						long now = System.currentTimeMillis();
						if (now - lastUpdated > 1000) {
							updateStatus();
							lastUpdated = now;
						}
					}
				}
				 else {
					in.skip(boxsize);
				}
				streamPos += boxsize;
			}
			in.close();
		}
		Logger.log(""Output format: "" + outputFormat);
		assembleFinished = true;
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	 finally {
		try {
			out.close();
		}
		 catch (Exception e2) {
		}
		try {
			in.close();
		}
		 catch (Exception e2) {
		}
	}
}",0,0,1,0
"public void exportAccount(Session session, Account account, File file);",0,0,0,0
"public class NotTezEventHelper {
	 public static Signable createSignableNotTezEvent( InputDataInformationEvent event, String vertexName, String destInputName) {
		 final NotTezEvent.Builder builder = NotTezEvent.newBuilder().setInputEventProtoBytes( ProtoConverters.convertRootInputDataInformationEventToProto(event).toByteString()) .setVertexName(vertexName).setDestInputName(destInputName);
		 return new Signable() {
			 public void setSignInfo(int masterKeyId) {
				 builder.setKeyId(masterKeyId);
			 }
			 public byte[] serialize() throws IOException {
				 NotTezEvent nte = builder.build();
				 ByteArrayOutputStream baos = new ByteArrayOutputStream(nte.getSerializedSize());
				 nte.writeTo(baos);
				 return baos.toByteArray();
			 }
		 }
		;
	 }
	 public static TezEvent toTezEvent(NotTezEvent nte) throws InvalidProtocolBufferException {
		 EventMetaData sourceMetaData = new EventMetaData(EventMetaData.EventProducerConsumerType.INPUT, nte.getVertexName(), ""NULL_VERTEX"", null);
		 EventMetaData destMetaData = new EventMetaData(EventMetaData.EventProducerConsumerType.INPUT, nte.getVertexName(), nte.getDestInputName(), null);
		 InputDataInformationEvent event = ProtoConverters.convertRootInputDataInformationEventFromProto( RootInputDataInformationEventProto.parseFrom(nte.getInputEventProtoBytes()));
		 TezEvent tezEvent = new TezEvent(event, sourceMetaData, System.currentTimeMillis());
		 tezEvent.setDestinationInfo(destMetaData);
		 return tezEvent;
	 }
}",0,0,0,0
"public int convert() {
	try {
		Logger.log(""Outformat: "" + outformat + "" audio: "" + outformat.isAudioOnly());
		File ffFile = new File(Config.getInstance().getDataFolder(),System.getProperty(""os.name"").toLowerCase().contains(""windows"") ? ""ffmpeg.exe"" : ""ffmpeg"");
		if (!ffFile.exists()) {
			return FF_NOT_FOUND;
		}
		List<String> args = new ArrayList<String>();
		args.add(ffFile.getAbsolutePath());
		if (hls) {
			args.add(""-f"");
			args.add(""concat"");
			args.add(""-safe"");
			args.add(""0"");
		}
		for (int i = 0;
		 i < inputFiles.size();
		 i++) {
			args.add(""-i"");
			args.add(inputFiles.get(i));
		}
		if (outformat.isAudioOnly()) {
			if (outformat.getWidth() > 0) {
				args.add(""-b:a"");
				args.add(outformat.getWidth() + ""k"");
			}
			 else if (copy) {
				args.add(""-acodec"");
				args.add(""copy"");
			}
		}
		 else {
			if (outformat.getWidth() > 0) {
				args.add(""-vf"");
				args.add(""scale="" + outformat.getWidth() + "":"" + outformat.getHeight());
			}
			 else if (copy) {
				args.add(""-acodec"");
				args.add(""copy"");
				args.add(""-vcodec"");
				args.add(""copy"");
			}
		}
		args.add(outputFile);
		args.add(""-y"");
		for (String s : args) {
			Logger.log("": "" + s);
		}
		ProcessBuilder pb = new ProcessBuilder(args);
		pb.redirectErrorStream(true);
		proc = pb.start();
		BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream()), 1024);
		while (true) {
			String ln = br.readLine();
			if (ln == null) {
				break;
			}
			try {
				String text = ln.trim();
				processOutput(text);
			}
			 catch (Exception e) {
				Logger.log(e);
			}
		}
		ffExitCode = proc.waitFor();
		return ffExitCode == 0 ? FF_SUCCESS : FF_CONVERSION_FAILED;
	}
	 catch (Exception e) {
		return FF_LAUNCH_ERROR;
	}
}",0,0,1,0
"public static class Builder {
	 private String omServiceId;
	 private String omNodeId;
	 private InetSocketAddress rpcAddress;
	 private int rpcPort;
	 private int ratisPort;
	 public Builder setRpcAddress(InetSocketAddress rpcAddr) {
		 this.rpcAddress = rpcAddr;
		 this.rpcPort = rpcAddress.getPort();
		 return this;
	 }
	 public Builder setRatisPort(int port) {
		 this.ratisPort = port;
		 return this;
	 }
	 public Builder setOMServiceId(String serviceId) {
		 this.omServiceId = serviceId;
		 return this;
	 }
	 public Builder setOMNodeId(String nodeId) {
		 this.omNodeId = nodeId;
		 return this;
	 }
	 public OMNodeDetails build() {
		 return new OMNodeDetails(omServiceId, omNodeId, rpcAddress, rpcPort, ratisPort);
	 }
 }",0,1,0,0
"public class Logalyzer {
	 private static Configuration fsConfig = new Configuration();
	 public static class LogRegexMapper extends MapReduceBase implements Mapper {
		 private Pattern pattern;
		 public void configure(JobConf job) {
			 pattern = Pattern.compile(job.get(""mapred.mapper.regex""));
		 }
		 public void map(WritableComparable key, Writable value, OutputCollector output, Reporter reporter) throws IOException {
			 String text = ((Text)value).toString();
			 Matcher matcher = pattern.matcher(text);
			 while (matcher.find()) {
				 output.collect((Text)value, new LongWritable(1));
			 }
		 }
	 }
	 public static class LogComparator extends Text.Comparator implements Configurable {
		 private static Log LOG = LogFactory.getLog(""org.apache.hadoop.tools.Logalyzer"");
		 private JobConf conf = null;
		 private String[] sortSpec = null;
		 private String columnSeparator = null;
		 public void setConf(Configuration conf) {
			 if (conf instanceof JobConf) {
				 this.conf = (JobConf) conf;
			 }
			 else {
				 this.conf = new JobConf(conf);
			 }
			 String sortColumns = this.conf.get(""mapred.reducer.sort"", null);
			 if(sortColumns != null) {
				 sortSpec = sortColumns.split("","");
			 }
			 columnSeparator = this.conf.get(""mapred.reducer.separator"", """");
		 }
		 public Configuration getConf() {
			 return conf;
		 }
		 public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
			 if(sortSpec == null) {
				 return super.compare(b1, s1, l1, b2, s2, l2);
			 }
			 try {
				 Text logline1 = new Text();
				 logline1.readFields(new DataInputStream(new ByteArrayInputStream(b1, s1, l1)));
				 String line1 = logline1.toString();
				 String[] logColumns1 = line1.split(columnSeparator);
				 Text logline2 = new Text();
				 logline2.readFields(new DataInputStream(new ByteArrayInputStream(b2, s2, l2)));
				 String line2 = logline2.toString();
				 String[] logColumns2 = line2.split(columnSeparator);
				 if(logColumns1 == null || logColumns2 == null) {
					 return super.compare(b1, s1, l1, b2, s2, l2);
				 }
				 for(int i=0;
				 i < sortSpec.length;
				 ++i) {
					 int column = (Integer.valueOf(sortSpec[i]).intValue());
					 String c1 = logColumns1[column];
					 String c2 = logColumns2[column];
					 int comparision = super.compareBytes( c1.getBytes(), 0, c1.length(), c2.getBytes(), 0, c2.length() );
					 if(comparision != 0) {
						 return comparision;
					 }
				 }
			 }
			 catch (IOException ioe) {
				 LOG.fatal(""Caught "" + ioe);
				 return 0;
			 }
			 return 0;
		 }
		 static {
			 WritableComparator.define(Text.class, new LogComparator());
		 }
	 }
	 public void doArchive(String logListURI, String archiveDirectory) throws IOException {
		 String destURL = new String(""dfs: archiveDirectory);
		 CopyFiles.copy(fsConfig, logListURI, destURL, true, false);
	 }
	 public void doAnalyze(String inputFilesDirectory, String outputDirectory, String grepPattern, String sortColumns, String columnSeparator) throws IOException {
		 Path grepInput = new Path(inputFilesDirectory);
		 Path analysisOutput = null;
		 if(outputDirectory.equals("""")) {
			 analysisOutput = new Path(inputFilesDirectory, ""logalyzer_"" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));
		 }
		 else {
			 analysisOutput = new Path(outputDirectory);
		 }
		 JobConf grepJob = new JobConf(fsConfig);
		 grepJob.setJobName(""logalyzer-grep-sort"");
		 grepJob.setInputPath(grepInput);
		 grepJob.setInputFormat(TextInputFormat.class);
		 grepJob.setMapperClass(LogRegexMapper.class);
		 grepJob.set(""mapred.mapper.regex"", grepPattern);
		 grepJob.set(""mapred.reducer.sort"", sortColumns);
		 grepJob.set(""mapred.reducer.separator"", columnSeparator);
		 grepJob.setCombinerClass(LongSumReducer.class);
		 grepJob.setReducerClass(LongSumReducer.class);
		 grepJob.setOutputPath(analysisOutput);
		 grepJob.setOutputFormat(TextOutputFormat.class);
		 grepJob.setOutputKeyClass(Text.class);
		 grepJob.setOutputValueClass(LongWritable.class);
		 grepJob.setOutputKeyComparatorClass(LogComparator.class);
		 grepJob.setNumReduceTasks(1);
		 JobClient.runJob(grepJob);
	 }
	 public static void main(String[] args) {
		 Log LOG = LogFactory.getLog(""org.apache.hadoop.tools.Logalyzer"");
		 String version = ""Logalyzer.0.0.1"";
		 String usage = ""Usage: Logalyzer [-archive -logs <urlsFile>] "" + ""-archiveDir <archiveDirectory> "" + ""-grep <pattern> -sort <column1,column2,...> -separator <separator> "" + ""-analysis <outputDirectory>"";
		 System.out.println(version);
		 if (args.length == 0) {
			 System.err.println(usage);
			 System.exit(-1);
		 }
		 boolean archive = false;
		 boolean grep = false;
		 boolean sort = false;
		 String archiveDir = """";
		 String logListURI = """";
		 String grepPattern = "".*"";
		 String sortColumns = """";
		 String columnSeparator = "" "";
		 String outputDirectory = """";
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (args[i].equals(""-archive"")) {
				 archive = true;
			 }
			 else if (args[i].equals(""-archiveDir"")) {
				 archiveDir = args[++i];
			 }
			 else if (args[i].equals(""-grep"")) {
				 grep = true;
				 grepPattern = args[++i];
			 }
			 else if (args[i].equals(""-logs"")) {
				 logListURI = args[++i];
			 }
			 else if (args[i].equals(""-sort"")) {
				 sort = true;
				 sortColumns = args[++i];
			 }
			 else if (args[i].equals(""-separator"")) {
				 columnSeparator = args[++i];
			 }
			 else if (args[i].equals(""-analysis"")) {
				 outputDirectory = args[++i];
			 }
		 }
		 LOG.info(""analysisDir = "" + outputDirectory);
		 LOG.info(""archiveDir = "" + archiveDir);
		 LOG.info(""logListURI = "" + logListURI);
		 LOG.info(""grepPattern = "" + grepPattern);
		 LOG.info(""sortColumns = "" + sortColumns);
		 LOG.info(""separator = "" + columnSeparator);
		 try {
			 Logalyzer logalyzer = new Logalyzer();
			 if (archive) {
				 logalyzer.doArchive(logListURI, archiveDir);
			 }
			 if (grep || sort) {
				 logalyzer.doAnalyze(archiveDir, outputDirectory, grepPattern, sortColumns, columnSeparator);
			 }
		 }
		 catch (IOException ioe) {
			 ioe.printStackTrace();
			 System.exit(-1);
		 }
	 }
 }",0,0,0,0
"protected void handleRequest(byte[] inbuf, int offset) throws IOException {
	 BerDecoder reqBer = new BerDecoder(inbuf, 0, offset);
	 int currentMessageId = 0;
	 try {
		 reqBer.parseSeq(null);
		 currentMessageId = reqBer.parseInt();
		 int requestOperation = reqBer.peekByte();
		 if (requestOperation == LDAP_REQ_BIND) {
			 reqBer.parseSeq(null);
			 ldapVersion = reqBer.parseInt();
			 userName = reqBer.parseString(isLdapV3());
			 if (reqBer.peekByte() == (Ber.ASN_CONTEXT | Ber.ASN_CONSTRUCTOR | 3)) {
				 reqBer.parseSeq(null);
				 String mechanism = reqBer.parseString(isLdapV3());
				 byte[] serverResponse;
				 CallbackHandler callbackHandler = new CallbackHandler() {
					 public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
						 for (Callback callback : callbacks) {
							 if (callback instanceof NameCallback) {
								 userName = ((NameCallback) callback).getDefaultName();
								 password = ExchangeSessionFactory.getUserPassword(userName);
							 }
						 }
						 for (Callback callback : callbacks) {
							 if (callback instanceof AuthorizeCallback) {
								 ((AuthorizeCallback) callback).setAuthorized(true);
							 }
							 else if (callback instanceof PasswordCallback) {
								 if (password != null) {
									 ((PasswordCallback) callback).setPassword(password.toCharArray());
								 }
							 }
						 }
					 }
				 }
				;
				 int status;
				 if (reqBer.bytesLeft() > 0 && saslServer != null) {
					 byte[] clientResponse = reqBer.parseOctetString(Ber.ASN_OCTET_STR, null);
					 serverResponse = saslServer.evaluateResponse(clientResponse);
					 status = LDAP_SUCCESS;
					 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_USER"", currentMessageId, userName));
					 try {
						 session = ExchangeSessionFactory.getInstance(userName, password);
						 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_SUCCESS""));
					 }
					 catch (IOException e) {
						 serverResponse = EMPTY_BYTE_ARRAY;
						 status = LDAP_INVALID_CREDENTIALS;
						 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_INVALID_CREDENTIALS""));
					 }
				 }
				 else {
					 Map<String, String> properties = new HashMap<String, String>();
					 properties.put(""javax.security.sasl.qop"", ""auth,auth-int"");
					 saslServer = Sasl.createSaslServer(mechanism, ""ldap"", client.getLocalAddress().getHostAddress(), properties, callbackHandler);
					 if (saslServer == null) {
						 throw new IOException(""Unable to create SASL server for mechanism ""+mechanism);
					 }
					 serverResponse = saslServer.evaluateResponse(EMPTY_BYTE_ARRAY);
					 status = LDAP_SASL_BIND_IN_PROGRESS;
				 }
				 responseBer.beginSeq(Ber.ASN_SEQUENCE | Ber.ASN_CONSTRUCTOR);
				 responseBer.encodeInt(currentMessageId);
				 responseBer.beginSeq(LDAP_REP_BIND);
				 responseBer.encodeInt(status, LBER_ENUMERATED);
				 responseBer.encodeString("""", isLdapV3());
				 responseBer.encodeString("""", isLdapV3());
				 if (serverResponse != null) {
					 responseBer.encodeOctetString(serverResponse, 0x87);
				 }
				 responseBer.endSeq();
				 responseBer.endSeq();
				 sendResponse();
			 }
			 else {
				 password = reqBer.parseStringWithTag(Ber.ASN_CONTEXT, isLdapV3(), null);
				 if (userName.length() > 0 && password.length() > 0) {
					 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_USER"", currentMessageId, userName));
					 try {
						 session = ExchangeSessionFactory.getInstance(userName, password);
						 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_SUCCESS""));
						 sendClient(currentMessageId, LDAP_REP_BIND, LDAP_SUCCESS, """");
					 }
					 catch (IOException e) {
						 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_INVALID_CREDENTIALS""));
						 sendClient(currentMessageId, LDAP_REP_BIND, LDAP_INVALID_CREDENTIALS, """");
					 }
				 }
				 else {
					 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_BIND_ANONYMOUS"", currentMessageId));
					 sendClient(currentMessageId, LDAP_REP_BIND, LDAP_SUCCESS, """");
				 }
			 }
		 }
		 else if (requestOperation == LDAP_REQ_UNBIND) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_UNBIND"", currentMessageId));
			 if (session != null) {
				 session = null;
			 }
		 }
		 else if (requestOperation == LDAP_REQ_SEARCH) {
			 reqBer.parseSeq(null);
			 String dn = reqBer.parseString(isLdapV3());
			 int scope = reqBer.parseEnumeration();
			 reqBer.parseEnumeration();
			 int sizeLimit = reqBer.parseInt();
			 if (sizeLimit > 100 || sizeLimit == 0) {
				 sizeLimit = 100;
			 }
			 int timelimit = reqBer.parseInt();
			 reqBer.parseBoolean();
			 LdapFilter ldapFilter = parseFilter(reqBer);
			 Set<String> returningAttributes = parseReturningAttributes(reqBer);
			 SearchRunnable searchRunnable = new SearchRunnable(currentMessageId, dn, scope, sizeLimit, timelimit, ldapFilter, returningAttributes);
			 if (BASE_CONTEXT.equalsIgnoreCase(dn) || OD_USER_CONTEXT.equalsIgnoreCase(dn) || OD_USER_CONTEXT_LION.equalsIgnoreCase(dn)) {
				 synchronized (searchThreadMap) {
					 searchThreadMap.put(currentMessageId, searchRunnable);
				 }
				 Thread searchThread = new Thread(searchRunnable);
				 searchThread.setName(getName() + ""-Search-"" + currentMessageId);
				 searchThread.start();
			 }
			 else {
				 searchRunnable.run();
			 }
		 }
		 else if (requestOperation == LDAP_REQ_ABANDON) {
			 int abandonMessageId = 0;
			 try {
				 abandonMessageId = (Integer) PARSE_INT_WITH_TAG_METHOD.invoke(reqBer, LDAP_REQ_ABANDON);
				 synchronized (searchThreadMap) {
					 SearchRunnable searchRunnable = searchThreadMap.get(abandonMessageId);
					 if (searchRunnable != null) {
						 searchRunnable.abandon();
						 searchThreadMap.remove(currentMessageId);
					 }
				 }
			 }
			 catch (IllegalAccessException e) {
				 DavGatewayTray.error(e);
			 }
			 catch (InvocationTargetException e) {
				 DavGatewayTray.error(e);
			 }
			 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_REQ_ABANDON_SEARCH"", currentMessageId, abandonMessageId));
		 }
		 else {
			 DavGatewayTray.debug(new BundleMessage(""LOG_LDAP_UNSUPPORTED_OPERATION"", requestOperation));
			 sendClient(currentMessageId, LDAP_REP_RESULT, LDAP_OTHER, ""Unsupported operation"");
		 }
	 }
	 catch (IOException e) {
		 dumpBer(inbuf, offset);
		 try {
			 sendErr(currentMessageId, LDAP_REP_RESULT, e);
		 }
		 catch (IOException e2) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
		 }
		 throw e;
	 }
 }",0,0,1,0
"public abstract class AbstractChartIntSpinner extends Composite{
	public AbstractChartIntSpinner( Composite parent, int style ){
		super( parent, style );
	}
	abstract public void setValue( int value );
	abstract public int getValue( );
	abstract public void setIncrement( int increment );
	abstract public void setMaximum( int max );
	abstract public void setMinimum( int min );
	abstract public void addListener( Listener listener );
	abstract public boolean isSpinnerEnabled( );
}",0,0,0,0
"private class DocumentTrailerHandler extends AbstractElementHandler {
	 public void startElement(Attributes attributes) throws IFException {
		 documentHandler.startDocumentTrailer();
	 }
	 public void endElement() throws IFException {
		 documentHandler.endDocumentTrailer();
	 }
 }",0,0,0,0
"public void add(ResourceCollection rc) {
	 if (rc == null) {
		 return;
	 }
	 resources = resources == null ? new Union() : resources;
	 resources.add(rc);
 }",0,0,0,0
"public class XSDFACM implements XSCMValidator {
	 private static final boolean DEBUG = false;
	 private static final boolean DEBUG_VALIDATE_CONTENT = false;
	 private Object fElemMap[] = null;
	 private int fElemMapType[] = null;
	 private int fElemMapId[] = null;
	 private int fElemMapSize = 0;
	 private boolean fFinalStateFlags[] = null;
	 private CMStateSet fFollowList[] = null;
	 private CMNode fHeadNode = null;
	 private int fLeafCount = 0;
	 private XSCMLeaf fLeafList[] = null;
	 private int fLeafListType[] = null;
	 private int fTransTable[][] = null;
	 private Occurence [] fCountingStates = null;
	 static final class Occurence {
		 final int minOccurs;
		 final int maxOccurs;
		 final int elemIndex;
		 public Occurence (XSCMRepeatingLeaf leaf, int elemIndex) {
			 minOccurs = leaf.getMinOccurs();
			 maxOccurs = leaf.getMaxOccurs();
			 this.elemIndex = elemIndex;
		 }
		 public String toString() {
			 return ""minOccurs="" + minOccurs + "";
			maxOccurs="" + ((maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) ? Integer.toString(maxOccurs) : ""unbounded"");
		 }
	 }
	 private int fTransTableSize = 0;
	 private boolean fIsCompactedForUPA;
	 public XSDFACM(CMNode syntaxTree, int leafCount) {
		 fLeafCount = leafCount;
		 fIsCompactedForUPA = syntaxTree.isCompactedForUPA();
		 if(DEBUG_VALIDATE_CONTENT) {
			 XSDFACM.time -= System.currentTimeMillis();
		 }
		 buildDFA(syntaxTree);
		 if(DEBUG_VALIDATE_CONTENT) {
			 XSDFACM.time += System.currentTimeMillis();
			 System.out.println(""DFA build: "" + XSDFACM.time + ""ms"");
		 }
	 }
	 private static long time = 0;
	 public boolean isFinalState (int state) {
		 return (state < 0)? false : fFinalStateFlags[state];
	 }
	 public Object oneTransition(QName curElem, int[] state, SubstitutionGroupHandler subGroupHandler) {
		 int curState = state[0];
		 if(curState == XSCMValidator.FIRST_ERROR || curState == XSCMValidator.SUBSEQUENT_ERROR) {
			 if(curState == XSCMValidator.FIRST_ERROR) state[0] = XSCMValidator.SUBSEQUENT_ERROR;
			 return findMatchingDecl(curElem, subGroupHandler);
		 }
		 int nextState = 0;
		 int elemIndex = 0;
		 Object matchingDecl = null;
		 for (;
		 elemIndex < fElemMapSize;
		 elemIndex++) {
			 nextState = fTransTable[curState][elemIndex];
			 if (nextState == -1) continue;
			 int type = fElemMapType[elemIndex] ;
			 if (type == XSParticleDecl.PARTICLE_ELEMENT) {
				 matchingDecl = subGroupHandler.getMatchingElemDecl(curElem, (XSElementDecl)fElemMap[elemIndex]);
				 if (matchingDecl != null) {
					 break;
				 }
			 }
			 else if (type == XSParticleDecl.PARTICLE_WILDCARD) {
				 if (((XSWildcardDecl)fElemMap[elemIndex]).allowNamespace(curElem.uri)) {
					 matchingDecl = fElemMap[elemIndex];
					 break;
				 }
			 }
		 }
		 if (elemIndex == fElemMapSize) {
			 state[1] = state[0];
			 state[0] = XSCMValidator.FIRST_ERROR;
			 return findMatchingDecl(curElem, subGroupHandler);
		 }
		 if (fCountingStates != null) {
			 Occurence o = fCountingStates[curState];
			 if (o != null) {
				 if (curState == nextState) {
					 if (++state[2] > o.maxOccurs && o.maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
						 return findMatchingDecl(curElem, state, subGroupHandler, elemIndex);
					 }
				 }
				 else if (state[2] < o.minOccurs) {
					 state[1] = state[0];
					 state[0] = XSCMValidator.FIRST_ERROR;
					 return findMatchingDecl(curElem, subGroupHandler);
				 }
				 else {
					 o = fCountingStates[nextState];
					 if (o != null) {
						 state[2] = (elemIndex == o.elemIndex) ? 1 : 0;
					 }
				 }
			 }
			 else {
				 o = fCountingStates[nextState];
				 if (o != null) {
					 state[2] = (elemIndex == o.elemIndex) ? 1 : 0;
				 }
			 }
		 }
		 state[0] = nextState;
		 return matchingDecl;
	 }
	 Object findMatchingDecl(QName curElem, SubstitutionGroupHandler subGroupHandler) {
		 Object matchingDecl = null;
		 for (int elemIndex = 0;
		 elemIndex < fElemMapSize;
		 elemIndex++) {
			 int type = fElemMapType[elemIndex] ;
			 if (type == XSParticleDecl.PARTICLE_ELEMENT) {
				 matchingDecl = subGroupHandler.getMatchingElemDecl(curElem, (XSElementDecl)fElemMap[elemIndex]);
				 if (matchingDecl != null) {
					 return matchingDecl;
				 }
			 }
			 else if (type == XSParticleDecl.PARTICLE_WILDCARD) {
				 if(((XSWildcardDecl)fElemMap[elemIndex]).allowNamespace(curElem.uri)) return fElemMap[elemIndex];
			 }
		 }
		 return null;
	 }
	 Object findMatchingDecl(QName curElem, int[] state, SubstitutionGroupHandler subGroupHandler, int elemIndex) {
		 int curState = state[0];
		 int nextState = 0;
		 Object matchingDecl = null;
		 while (++elemIndex < fElemMapSize) {
			 nextState = fTransTable[curState][elemIndex];
			 if (nextState == -1) continue;
			 int type = fElemMapType[elemIndex] ;
			 if (type == XSParticleDecl.PARTICLE_ELEMENT) {
				 matchingDecl = subGroupHandler.getMatchingElemDecl(curElem, (XSElementDecl)fElemMap[elemIndex]);
				 if (matchingDecl != null) {
					 break;
				 }
			 }
			 else if (type == XSParticleDecl.PARTICLE_WILDCARD) {
				 if (((XSWildcardDecl)fElemMap[elemIndex]).allowNamespace(curElem.uri)) {
					 matchingDecl = fElemMap[elemIndex];
					 break;
				 }
			 }
		 }
		 if (elemIndex == fElemMapSize) {
			 state[1] = state[0];
			 state[0] = XSCMValidator.FIRST_ERROR;
			 return findMatchingDecl(curElem, subGroupHandler);
		 }
		 state[0] = nextState;
		 final Occurence o = fCountingStates[nextState];
		 if (o != null) {
			 state[2] = (elemIndex == o.elemIndex) ? 1 : 0;
		 }
		 return matchingDecl;
	 }
	 public int[] startContentModel() {
		 return new int [3];
	 }
	 public boolean endContentModel(int[] state) {
		 final int curState = state[0];
		 if (fFinalStateFlags[curState]) {
			 if (fCountingStates != null) {
				 Occurence o = fCountingStates[curState];
				 if (o != null && state[2] < o.minOccurs) {
					 return false;
				 }
			 }
			 return true;
		 }
		 return false;
	 }
	 private void buildDFA(CMNode syntaxTree) {
		 int EOCPos = fLeafCount;
		 XSCMLeaf nodeEOC = new XSCMLeaf(XSParticleDecl.PARTICLE_ELEMENT, null, -1, fLeafCount++);
		 fHeadNode = new XSCMBinOp( XSModelGroupImpl.MODELGROUP_SEQUENCE, syntaxTree, nodeEOC );
		 fLeafList = new XSCMLeaf[fLeafCount];
		 fLeafListType = new int[fLeafCount];
		 postTreeBuildInit(fHeadNode);
		 fFollowList = new CMStateSet[fLeafCount];
		 for (int index = 0;
		 index < fLeafCount;
		 index++) fFollowList[index] = new CMStateSet(fLeafCount);
		 calcFollowList(fHeadNode);
		 fElemMap = new Object[fLeafCount];
		 fElemMapType = new int[fLeafCount];
		 fElemMapId = new int[fLeafCount];
		 fElemMapSize = 0;
		 Occurence [] elemOccurenceMap = null;
		 for (int outIndex = 0;
		 outIndex < fLeafCount;
		 outIndex++) {
			 fElemMap[outIndex] = null;
			 int inIndex = 0;
			 final int id = fLeafList[outIndex].getParticleId();
			 for (;
			 inIndex < fElemMapSize;
			 inIndex++) {
				 if (id == fElemMapId[inIndex]) break;
			 }
			 if (inIndex == fElemMapSize) {
				 XSCMLeaf leaf = fLeafList[outIndex];
				 fElemMap[fElemMapSize] = leaf.getLeaf();
				 if (leaf instanceof XSCMRepeatingLeaf) {
					 if (elemOccurenceMap == null) {
						 elemOccurenceMap = new Occurence[fLeafCount];
					 }
					 elemOccurenceMap[fElemMapSize] = new Occurence((XSCMRepeatingLeaf) leaf, fElemMapSize);
				 }
				 fElemMapType[fElemMapSize] = fLeafListType[outIndex];
				 fElemMapId[fElemMapSize] = id;
				 fElemMapSize++;
			 }
		 }
		 if (DEBUG) {
			 if (fElemMapId[fElemMapSize-1] != -1) System.err.println(""interal error in DFA: last element is not EOC."");
		 }
		 fElemMapSize--;
		 int[] fLeafSorter = new int[fLeafCount + fElemMapSize];
		 int fSortCount = 0;
		 for (int elemIndex = 0;
		 elemIndex < fElemMapSize;
		 elemIndex++) {
			 final int id = fElemMapId[elemIndex];
			 for (int leafIndex = 0;
			 leafIndex < fLeafCount;
			 leafIndex++) {
				 if (id == fLeafList[leafIndex].getParticleId()) fLeafSorter[fSortCount++] = leafIndex;
			 }
			 fLeafSorter[fSortCount++] = -1;
		 }
		 int curArraySize = fLeafCount * 4;
		 CMStateSet[] statesToDo = new CMStateSet[curArraySize];
		 fFinalStateFlags = new boolean[curArraySize];
		 fTransTable = new int[curArraySize][];
		 CMStateSet setT = fHeadNode.firstPos();
		 int unmarkedState = 0;
		 int curState = 0;
		 fTransTable[curState] = makeDefStateList();
		 statesToDo[curState] = setT;
		 curState++;
		 HashMap stateTable = new HashMap();
		 while (unmarkedState < curState) {
			 setT = statesToDo[unmarkedState];
			 int[] transEntry = fTransTable[unmarkedState];
			 fFinalStateFlags[unmarkedState] = setT.getBit(EOCPos);
			 unmarkedState++;
			 CMStateSet newSet = null;
			 int sorterIndex = 0;
			 for (int elemIndex = 0;
			 elemIndex < fElemMapSize;
			 elemIndex++) {
				 if (newSet == null) newSet = new CMStateSet(fLeafCount);
				 else newSet.zeroBits();
				 int leafIndex = fLeafSorter[sorterIndex++];
				 while (leafIndex != -1) {
					 if (setT.getBit(leafIndex)) {
						 newSet.union(fFollowList[leafIndex]);
					 }
					 leafIndex = fLeafSorter[sorterIndex++];
				 }
				 if (!newSet.isEmpty()) {
					 Integer stateObj = (Integer)stateTable.get(newSet);
					 int stateIndex = (stateObj == null ? curState : stateObj.intValue());
					 if (stateIndex == curState) {
						 statesToDo[curState] = newSet;
						 fTransTable[curState] = makeDefStateList();
						 stateTable.put(newSet, new Integer(curState));
						 curState++;
						 newSet = null;
					 }
					 transEntry[elemIndex] = stateIndex;
					 if (curState == curArraySize) {
						 final int newSize = (int)(curArraySize * 1.5);
						 CMStateSet[] newToDo = new CMStateSet[newSize];
						 boolean[] newFinalFlags = new boolean[newSize];
						 int[][] newTransTable = new int[newSize][];
						 System.arraycopy(statesToDo, 0, newToDo, 0, curArraySize);
						 System.arraycopy(fFinalStateFlags, 0, newFinalFlags, 0, curArraySize);
						 System.arraycopy(fTransTable, 0, newTransTable, 0, curArraySize);
						 curArraySize = newSize;
						 statesToDo = newToDo;
						 fFinalStateFlags = newFinalFlags;
						 fTransTable = newTransTable;
					 }
				 }
			 }
		 }
		 if (elemOccurenceMap != null) {
			 fCountingStates = new Occurence[curState];
			 for (int i = 0;
			 i < curState;
			 ++i) {
				 int [] transitions = fTransTable[i];
				 for (int j = 0;
				 j < transitions.length;
				 ++j) {
					 if (i == transitions[j]) {
						 fCountingStates[i] = elemOccurenceMap[j];
						 break;
					 }
				 }
			 }
		 }
		 if (DEBUG_VALIDATE_CONTENT) dumpTree(fHeadNode, 0);
		 fHeadNode = null;
		 fLeafList = null;
		 fFollowList = null;
		 fLeafListType = null;
		 fElemMapId = null;
	 }
	 private void calcFollowList(CMNode nodeCur) {
		 if (nodeCur.type() == XSModelGroupImpl.MODELGROUP_CHOICE) {
			 calcFollowList(((XSCMBinOp)nodeCur).getLeft());
			 calcFollowList(((XSCMBinOp)nodeCur).getRight());
		 }
		 else if (nodeCur.type() == XSModelGroupImpl.MODELGROUP_SEQUENCE) {
			 calcFollowList(((XSCMBinOp)nodeCur).getLeft());
			 calcFollowList(((XSCMBinOp)nodeCur).getRight());
			 final CMStateSet last = ((XSCMBinOp)nodeCur).getLeft().lastPos();
			 final CMStateSet first = ((XSCMBinOp)nodeCur).getRight().firstPos();
			 for (int index = 0;
			 index < fLeafCount;
			 index++) {
				 if (last.getBit(index)) fFollowList[index].union(first);
			 }
		 }
		 else if (nodeCur.type() == XSParticleDecl.PARTICLE_ZERO_OR_MORE || nodeCur.type() == XSParticleDecl.PARTICLE_ONE_OR_MORE) {
			 calcFollowList(((XSCMUniOp)nodeCur).getChild());
			 final CMStateSet first = nodeCur.firstPos();
			 final CMStateSet last = nodeCur.lastPos();
			 for (int index = 0;
			 index < fLeafCount;
			 index++) {
				 if (last.getBit(index)) fFollowList[index].union(first);
			 }
		 }
		 else if (nodeCur.type() == XSParticleDecl.PARTICLE_ZERO_OR_ONE) {
			 calcFollowList(((XSCMUniOp)nodeCur).getChild());
		 }
	 }
	 private void dumpTree(CMNode nodeCur, int level) {
		 for (int index = 0;
		 index < level;
		 index++) System.out.print("" "");
		 int type = nodeCur.type();
		 switch(type ) {
			 case XSModelGroupImpl.MODELGROUP_CHOICE: case XSModelGroupImpl.MODELGROUP_SEQUENCE: {
				 if (type == XSModelGroupImpl.MODELGROUP_CHOICE) System.out.print(""Choice Node "");
				 else System.out.print(""Seq Node "");
				 if (nodeCur.isNullable()) System.out.print(""Nullable "");
				 System.out.print(""firstPos="");
				 System.out.print(nodeCur.firstPos().toString());
				 System.out.print("" lastPos="");
				 System.out.println(nodeCur.lastPos().toString());
				 dumpTree(((XSCMBinOp)nodeCur).getLeft(), level+1);
				 dumpTree(((XSCMBinOp)nodeCur).getRight(), level+1);
				 break;
			 }
			 case XSParticleDecl.PARTICLE_ZERO_OR_MORE: case XSParticleDecl.PARTICLE_ONE_OR_MORE: case XSParticleDecl.PARTICLE_ZERO_OR_ONE: {
				 System.out.print(""Rep Node "");
				 if (nodeCur.isNullable()) System.out.print(""Nullable "");
				 System.out.print(""firstPos="");
				 System.out.print(nodeCur.firstPos().toString());
				 System.out.print("" lastPos="");
				 System.out.println(nodeCur.lastPos().toString());
				 dumpTree(((XSCMUniOp)nodeCur).getChild(), level+1);
				 break;
			 }
			 case XSParticleDecl.PARTICLE_ELEMENT: {
				 System.out.print ( ""Leaf: (pos="" + ((XSCMLeaf)nodeCur).getPosition() + ""), "" + ""(elemIndex="" + ((XSCMLeaf)nodeCur).getLeaf() + "") "" );
				 if (nodeCur.isNullable()) System.out.print("" Nullable "");
				 System.out.print(""firstPos="");
				 System.out.print(nodeCur.firstPos().toString());
				 System.out.print("" lastPos="");
				 System.out.println(nodeCur.lastPos().toString());
				 break;
			 }
			 case XSParticleDecl.PARTICLE_WILDCARD: System.out.print(""Any Node: "");
			 System.out.print(""firstPos="");
			 System.out.print(nodeCur.firstPos().toString());
			 System.out.print("" lastPos="");
			 System.out.println(nodeCur.lastPos().toString());
			 break;
			 default: {
				 throw new RuntimeException(""ImplementationMessages.VAL_NIICM"");
			 }
		 }
	 }
	 private int[] makeDefStateList() {
		 int[] retArray = new int[fElemMapSize];
		 for (int index = 0;
		 index < fElemMapSize;
		 index++) retArray[index] = -1;
		 return retArray;
	 }
	 private void postTreeBuildInit(CMNode nodeCur) throws RuntimeException {
		 nodeCur.setMaxStates(fLeafCount);
		 XSCMLeaf leaf = null;
		 int pos = 0;
		 if (nodeCur.type() == XSParticleDecl.PARTICLE_WILDCARD) {
			 leaf = (XSCMLeaf)nodeCur;
			 pos = leaf.getPosition();
			 fLeafList[pos] = leaf;
			 fLeafListType[pos] = XSParticleDecl.PARTICLE_WILDCARD;
		 }
		 else if ((nodeCur.type() == XSModelGroupImpl.MODELGROUP_CHOICE) || (nodeCur.type() == XSModelGroupImpl.MODELGROUP_SEQUENCE)) {
			 postTreeBuildInit(((XSCMBinOp)nodeCur).getLeft());
			 postTreeBuildInit(((XSCMBinOp)nodeCur).getRight());
		 }
		 else if (nodeCur.type() == XSParticleDecl.PARTICLE_ZERO_OR_MORE || nodeCur.type() == XSParticleDecl.PARTICLE_ONE_OR_MORE || nodeCur.type() == XSParticleDecl.PARTICLE_ZERO_OR_ONE) {
			 postTreeBuildInit(((XSCMUniOp)nodeCur).getChild());
		 }
		 else if (nodeCur.type() == XSParticleDecl.PARTICLE_ELEMENT) {
			 leaf = (XSCMLeaf)nodeCur;
			 pos = leaf.getPosition();
			 fLeafList[pos] = leaf;
			 fLeafListType[pos] = XSParticleDecl.PARTICLE_ELEMENT;
		 }
		 else {
			 throw new RuntimeException(""ImplementationMessages.VAL_NIICM"");
		 }
	 }
	 public boolean checkUniqueParticleAttribution(SubstitutionGroupHandler subGroupHandler) throws XMLSchemaException {
		 byte conflictTable[][] = new byte[fElemMapSize][fElemMapSize];
		 for (int i = 0;
		 i < fTransTable.length && fTransTable[i] != null;
		 i++) {
			 for (int j = 0;
			 j < fElemMapSize;
			 j++) {
				 for (int k = j+1;
				 k < fElemMapSize;
				 k++) {
					 if (fTransTable[i][j] != -1 && fTransTable[i][k] != -1) {
						 if (conflictTable[j][k] == 0) {
							 if (XSConstraints.overlapUPA (fElemMap[j], fElemMap[k], subGroupHandler)) {
								 if (fCountingStates != null) {
									 Occurence o = fCountingStates[i];
									 if (o != null && fTransTable[i][j] == i ^ fTransTable[i][k] == i && o.minOccurs == o.maxOccurs) {
										 conflictTable[j][k] = (byte) -1;
										 continue;
									 }
								 }
								 conflictTable[j][k] = (byte) 1;
							 }
							 else {
								 conflictTable[j][k] = (byte) -1;
							 }
						 }
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < fElemMapSize;
		 i++) {
			 for (int j = 0;
			 j < fElemMapSize;
			 j++) {
				 if (conflictTable[i][j] == 1) {
					 throw new XMLSchemaException(""cos-nonambig"", new Object[]{
					fElemMap[i].toString(), fElemMap[j].toString()}
					);
				 }
			 }
		 }
		 for (int i = 0;
		 i < fElemMapSize;
		 i++) {
			 if (fElemMapType[i] == XSParticleDecl.PARTICLE_WILDCARD) {
				 XSWildcardDecl wildcard = (XSWildcardDecl)fElemMap[i];
				 if (wildcard.fType == XSWildcardDecl.NSCONSTRAINT_LIST || wildcard.fType == XSWildcardDecl.NSCONSTRAINT_NOT) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 public Vector whatCanGoHere(int[] state) {
		 int curState = state[0];
		 if (curState < 0) curState = state[1];
		 Occurence o = (fCountingStates != null) ? fCountingStates[curState] : null;
		 int count = state[2];
		 Vector ret = new Vector();
		 for (int elemIndex = 0;
		 elemIndex < fElemMapSize;
		 elemIndex++) {
			 int nextState = fTransTable[curState][elemIndex];
			 if (nextState != -1) {
				 if (o != null) {
					 if (curState == nextState) {
						 if (count >= o.maxOccurs && o.maxOccurs != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
							 continue;
						 }
					 }
					 else if (count < o.minOccurs) {
						 continue;
					 }
				 }
				 ret.addElement(fElemMap[elemIndex]);
			 }
		 }
		 return ret;
	 }
	 public int [] occurenceInfo(int[] state) {
		 if (fCountingStates != null) {
			 int curState = state[0];
			 if (curState < 0) {
				 curState = state[1];
			 }
			 Occurence o = fCountingStates[curState];
			 if (o != null) {
				 int [] occurenceInfo = new int[4];
				 occurenceInfo[0] = o.minOccurs;
				 occurenceInfo[1] = o.maxOccurs;
				 occurenceInfo[2] = state[2];
				 occurenceInfo[3] = o.elemIndex;
				 return occurenceInfo;
			 }
		 }
		 return null;
	 }
	 public String getTermName(int termId) {
		 Object term = fElemMap[termId];
		 return (term != null) ? term.toString() : null;
	 }
	 public boolean isCompactedForUPA() {
		 return fIsCompactedForUPA;
	 }
}",1,0,0,0
"class MqttReconnectActionListener implements IMqttActionListener {
	final String methodName;
	MqttReconnectActionListener(String methodName) {
		this.methodName = methodName;
	}
	public void onSuccess(IMqttToken asyncActionToken) {
		log.fine(CLASS_NAME, methodName, ""501"", new Object[] {
		 asyncActionToken.getClient().getClientId() }
		);
		comms.setRestingState(false);
		stopReconnectCycle();
	}
	public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
		log.fine(CLASS_NAME, methodName, ""502"", new Object[] {
		 asyncActionToken.getClient().getClientId() }
		);
		if (reconnectDelay < connOpts.getMaxReconnectDelay()) {
			reconnectDelay = reconnectDelay * 2;
		}
		rescheduleReconnectCycle(reconnectDelay);
	}
	private void rescheduleReconnectCycle(int delay) {
		String reschedulemethodName = methodName + "":rescheduleReconnectCycle"";
		log.fine(CLASS_NAME, reschedulemethodName, ""505"",new Object[] {
		 MqttAsyncClient.this.clientId, String.valueOf(reconnectDelay) }
		);
		synchronized (clientLock) {
			if (MqttAsyncClient.this.connOpts.isAutomaticReconnect()) {
				if (reconnectTimer != null) {
					reconnectTimer.schedule(new ReconnectTask(), delay);
				}
				 else {
					reconnectDelay = delay;
					startReconnectCycle();
				}
			}
		}
	}
}",0,0,0,0
"public void configure() {
	 if (isConfigured) {
		 return;
	 }
	 isConfigured = true;
	 Project p = getProject();
	 String filename = ""cache.properties"";
	 File cachefile = null;
	 if (p != null) {
		 cachefile = new File(p.getBaseDir(), filename);
		 getProject().addBuildListener(this);
	 }
	 else {
		 cachefile = new File(filename);
		 setDelayUpdate(false);
	 }
	 Cache defaultCache = new PropertiesfileCache(cachefile);
	 Algorithm defaultAlgorithm = new DigestAlgorithm();
	 Comparator defaultComparator = new EqualComparator();
	 for (Iterator itConfig = configParameter.iterator();
	 itConfig.hasNext();
	) {
		 Parameter par = (Parameter) itConfig.next();
		 if (par.getName().indexOf(""."") > 0) {
			 specialParameter.add(par);
		 }
		 else {
			 useParameter(par);
		 }
	 }
	 configParameter = new Vector();
	 if (algoName != null) {
		 if (""hashvalue"".equals(algoName.getValue())) {
			 algorithm = new HashvalueAlgorithm();
		 }
		 else if (""digest"".equals(algoName.getValue())) {
			 algorithm = new DigestAlgorithm();
		 }
		 else if (""checksum"".equals(algoName.getValue())) {
			 algorithm = new ChecksumAlgorithm();
		 }
	 }
	 else {
		 if (algorithmClass != null) {
			 algorithm = (Algorithm) loadClass( algorithmClass, ""is not an Algorithm."", Algorithm.class);
		 }
		 else {
			 algorithm = defaultAlgorithm;
		 }
	 }
	 if (cacheName != null) {
		 if (""propertyfile"".equals(cacheName.getValue())) {
			 cache = new PropertiesfileCache();
		 }
	 }
	 else {
		 if (cacheClass != null) {
			 cache = (Cache) loadClass(cacheClass, ""is not a Cache."", Cache.class);
		 }
		 else {
			 cache = defaultCache;
		 }
	 }
	 if (compName != null) {
		 if (""equal"".equals(compName.getValue())) {
			 comparator = new EqualComparator();
		 }
		 else if (""rule"".equals(compName.getValue())) {
			 throw new BuildException(""RuleBasedCollator not yet supported."");
		 }
	 }
	 else {
		 if (comparatorClass != null) {
			 comparator = (Comparator) loadClass( comparatorClass, ""is not a Comparator."", Comparator.class);
		 }
		 else {
			 comparator = defaultComparator;
		 }
	 }
	 for (Iterator itSpecial = specialParameter.iterator();
	 itSpecial.hasNext();
	) {
		 Parameter par = (Parameter) itSpecial.next();
		 useParameter(par);
	 }
	 specialParameter = new Vector();
 }",0,0,1,0
"final class AMD64IndirectCallOp extends IndirectCallOp {
	 public static final LIRInstructionClass<AMD64IndirectCallOp> TYPE = LIRInstructionClass.create(AMD64IndirectCallOp.class);
	 public static final Register METHOD = AMD64.rbx;
	 protected Value metaspaceMethod;
	 private final GraalHotSpotVMConfig config;
	 AMD64IndirectCallOp(ResolvedJavaMethod targetMethod, Value result, Value[] parameters, Value[] temps, Value metaspaceMethod, Value targetAddress, LIRFrameState state, GraalHotSpotVMConfig config) {
		 super(TYPE, targetMethod, result, parameters, temps, targetAddress, state);
		 this.metaspaceMethod = metaspaceMethod;
		 this.config = config;
	 }
	 public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
		 crb.recordMark(config.MARKID_INLINE_INVOKE);
		 Register callReg = asRegister(targetAddress);
		 assert !callReg.equals(METHOD);
		 int pcOffset = AMD64Call.indirectCall(crb, masm, callReg, callTarget, state);
		 crb.recordInlineInvokeCallOp(pcOffset, getPosition());
	 }
	 public void verify() {
		 super.verify();
		 assert asRegister(metaspaceMethod).equals(METHOD);
	 }
}",0,0,0,0
"public class PersonEntry extends BasePersonEntry<PersonEntry> {
	 public PersonEntry() {
		 super();
	 }
	 public PersonEntry(BaseEntry<?> sourceEntry) {
		 super(sourceEntry);
	 }
	 public String toString() {
		 return ""{
		PersonEntry "" + super.toString() + ""}
		"";
	 }
}",0,1,0,0
"public class SimpleCharStream{
	 public static final boolean staticFlag = false;
	 int bufsize;
	 int available;
	 int tokenBegin;
	 public int bufpos = -1;
	 protected int bufline[];
	 protected int bufcolumn[];
	 protected int column = 0;
	 protected int line = 1;
	 protected boolean prevCharIsCR = false;
	 protected boolean prevCharIsLF = false;
	 protected java.io.Reader inputStream;
	 protected char[] buffer;
	 protected int maxNextCharInd = 0;
	 protected int inBuf = 0;
	 protected int tabSize = 8;
	 protected void setTabSize(int i) {
		 tabSize = i;
	 }
	 protected int getTabSize(int i) {
		 return tabSize;
	 }
	 protected void ExpandBuff(boolean wrapAround) {
		 char[] newbuffer = new char[bufsize + 2048];
		 int newbufline[] = new int[bufsize + 2048];
		 int newbufcolumn[] = new int[bufsize + 2048];
		 try {
			 if (wrapAround) {
				 System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
				 System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
				 buffer = newbuffer;
				 System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
				 System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
				 bufline = newbufline;
				 System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
				 System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
				 bufcolumn = newbufcolumn;
				 maxNextCharInd = (bufpos += (bufsize - tokenBegin));
			 }
			 else {
				 System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
				 buffer = newbuffer;
				 System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
				 bufline = newbufline;
				 System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
				 bufcolumn = newbufcolumn;
				 maxNextCharInd = (bufpos -= tokenBegin);
			 }
		 }
		 catch (Throwable t) {
			 throw new Error(t.getMessage());
		 }
		 bufsize += 2048;
		 available = bufsize;
		 tokenBegin = 0;
	 }
	 protected void FillBuff() throws java.io.IOException {
		 if (maxNextCharInd == available) {
			 if (available == bufsize) {
				 if (tokenBegin > 2048) {
					 bufpos = maxNextCharInd = 0;
					 available = tokenBegin;
				 }
				 else if (tokenBegin < 0) bufpos = maxNextCharInd = 0;
				 else ExpandBuff(false);
			 }
			 else if (available > tokenBegin) available = bufsize;
			 else if ((tokenBegin - available) < 2048) ExpandBuff(true);
			 else available = tokenBegin;
		 }
		 int i;
		 try {
			 if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
				 inputStream.close();
				 throw new java.io.IOException();
			 }
			 else maxNextCharInd += i;
			 return;
		 }
		 catch(java.io.IOException e) {
			 --bufpos;
			 backup(0);
			 if (tokenBegin == -1) tokenBegin = bufpos;
			 throw e;
		 }
	 }
	 public char BeginToken() throws java.io.IOException {
		 tokenBegin = -1;
		 char c = readChar();
		 tokenBegin = bufpos;
		 return c;
	 }
	 protected void UpdateLineColumn(char c) {
		 column++;
		 if (prevCharIsLF) {
			 prevCharIsLF = false;
			 line += (column = 1);
		 }
		 else if (prevCharIsCR) {
			 prevCharIsCR = false;
			 if (c == '\n') {
				 prevCharIsLF = true;
			 }
			 else line += (column = 1);
		 }
		 switch (c) {
			 case '\r' : prevCharIsCR = true;
			 break;
			 case '\n' : prevCharIsLF = true;
			 break;
			 case '\t' : column--;
			 column += (tabSize - (column % tabSize));
			 break;
			 default : break;
		 }
		 bufline[bufpos] = line;
		 bufcolumn[bufpos] = column;
	 }
	 public char readChar() throws java.io.IOException {
		 if (inBuf > 0) {
			 --inBuf;
			 if (++bufpos == bufsize) bufpos = 0;
			 return buffer[bufpos];
		 }
		 if (++bufpos >= maxNextCharInd) FillBuff();
		 char c = buffer[bufpos];
		 UpdateLineColumn(c);
		 return (c);
	 }
	 public int getColumn() {
		 return bufcolumn[bufpos];
	 }
	 public int getLine() {
		 return bufline[bufpos];
	 }
	 public int getEndColumn() {
		 return bufcolumn[bufpos];
	 }
	 public int getEndLine() {
		 return bufline[bufpos];
	 }
	 public int getBeginColumn() {
		 return bufcolumn[tokenBegin];
	 }
	 public int getBeginLine() {
		 return bufline[tokenBegin];
	 }
	 public void backup(int amount) {
		 inBuf += amount;
		 if ((bufpos -= amount) < 0) bufpos += bufsize;
	 }
	 public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
		 inputStream = dstream;
		 line = startline;
		 column = startcolumn - 1;
		 available = bufsize = buffersize;
		 buffer = new char[buffersize];
		 bufline = new int[buffersize];
		 bufcolumn = new int[buffersize];
	 }
	 public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {
		 this(dstream, startline, startcolumn, 4096);
	 }
	 public SimpleCharStream(java.io.Reader dstream) {
		 this(dstream, 1, 1, 4096);
	 }
	 public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
		 inputStream = dstream;
		 line = startline;
		 column = startcolumn - 1;
		 if (buffer == null || buffersize != buffer.length) {
			 available = bufsize = buffersize;
			 buffer = new char[buffersize];
			 bufline = new int[buffersize];
			 bufcolumn = new int[buffersize];
		 }
		 prevCharIsLF = prevCharIsCR = false;
		 tokenBegin = inBuf = maxNextCharInd = 0;
		 bufpos = -1;
	 }
	 public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {
		 ReInit(dstream, startline, startcolumn, 4096);
	 }
	 public void ReInit(java.io.Reader dstream) {
		 ReInit(dstream, 1, 1, 4096);
	 }
	 public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
		 this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
	 }
	 public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
		 this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
	 }
	 public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
		 this(dstream, encoding, startline, startcolumn, 4096);
	 }
	 public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {
		 this(dstream, startline, startcolumn, 4096);
	 }
	 public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
		 this(dstream, encoding, 1, 1, 4096);
	 }
	 public SimpleCharStream(java.io.InputStream dstream) {
		 this(dstream, 1, 1, 4096);
	 }
	 public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
		 ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
	 }
	 public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
		 ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
	 }
	 public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
		 ReInit(dstream, encoding, 1, 1, 4096);
	 }
	 public void ReInit(java.io.InputStream dstream) {
		 ReInit(dstream, 1, 1, 4096);
	 }
	 public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
		 ReInit(dstream, encoding, startline, startcolumn, 4096);
	 }
	 public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {
		 ReInit(dstream, startline, startcolumn, 4096);
	 }
	 public String GetImage() {
		 if (bufpos >= tokenBegin) return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
		 else return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
	 }
	 public char[] GetSuffix(int len) {
		 char[] ret = new char[len];
		 if ((bufpos + 1) >= len) System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
		 else {
			 System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
			 System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
		 }
		 return ret;
	 }
	 public void Done() {
		 buffer = null;
		 bufline = null;
		 bufcolumn = null;
	 }
	 public void adjustBeginLineColumn(int newLine, int newCol) {
		 int start = tokenBegin;
		 int len;
		 if (bufpos >= tokenBegin) {
			 len = bufpos - tokenBegin + inBuf + 1;
		 }
		 else {
			 len = bufsize - tokenBegin + bufpos + 1 + inBuf;
		 }
		 int i = 0, j = 0, k = 0;
		 int nextColDiff = 0, columnDiff = 0;
		 while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {
			 bufline[j] = newLine;
			 nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
			 bufcolumn[j] = newCol + columnDiff;
			 columnDiff = nextColDiff;
			 i++;
		 }
		 if (i < len) {
			 bufline[j] = newLine++;
			 bufcolumn[j] = newCol + columnDiff;
			 while (i++ < len) {
				 if (bufline[j = start % bufsize] != bufline[++start % bufsize]) bufline[j] = newLine++;
				 else bufline[j] = newLine;
			 }
		 }
		 line = bufline[j];
		 column = bufcolumn[j];
	 }
}",0,0,0,0
"final class IRFactory{
	 IRFactory(Parser parser) {
		 this.parser = parser;
	 }
	 ScriptOrFnNode createScript() {
		 return new ScriptOrFnNode(Token.SCRIPT);
	 }
	 void initScript(ScriptOrFnNode scriptNode, Node body) {
		 Node children = body.getFirstChild();
		 if (children != null) {
			 scriptNode.addChildrenToBack(children);
		 }
	 }
	 Node createLeaf(int nodeType) {
		 return new Node(nodeType);
	 }
	 Node createLeaf(int nodeType, int nodeOp) {
		 return new Node(nodeType, nodeOp);
	 }
	 Node createSwitch(Node expr, int lineno) {
		 Node.Jump switchNode = new Node.Jump(Token.SWITCH, expr, lineno);
		 Node block = new Node(Token.BLOCK, switchNode);
		 return block;
	 }
	 void addSwitchCase(Node switchBlock, Node caseExpression, Node statements) {
		 if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();
		 Node.Jump switchNode = (Node.Jump)switchBlock.getFirstChild();
		 if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();
		 Node gotoTarget = Node.newTarget();
		 if (caseExpression != null) {
			 Node.Jump caseNode = new Node.Jump(Token.CASE, caseExpression);
			 caseNode.target = gotoTarget;
			 switchNode.addChildToBack(caseNode);
		 }
		 else {
			 switchNode.setDefault(gotoTarget);
		 }
		 switchBlock.addChildToBack(gotoTarget);
		 switchBlock.addChildToBack(statements);
	 }
	 void closeSwitch(Node switchBlock) {
		 if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();
		 Node.Jump switchNode = (Node.Jump)switchBlock.getFirstChild();
		 if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();
		 Node switchBreakTarget = Node.newTarget();
		 switchNode.target = switchBreakTarget;
		 Node defaultTarget = switchNode.getDefault();
		 if (defaultTarget == null) {
			 defaultTarget = switchBreakTarget;
		 }
		 switchBlock.addChildAfter(makeJump(Token.GOTO, defaultTarget), switchNode);
		 switchBlock.addChildToBack(switchBreakTarget);
	 }
	 Node createVariables(int lineno) {
		 return new Node(Token.VAR, lineno);
	 }
	 Node createExprStatement(Node expr, int lineno) {
		 int type;
		 if (parser.insideFunction()) {
			 type = Token.EXPR_VOID;
		 }
		 else {
			 type = Token.EXPR_RESULT;
		 }
		 return new Node(type, expr, lineno);
	 }
	 Node createExprStatementNoReturn(Node expr, int lineno) {
		 return new Node(Token.EXPR_VOID, expr, lineno);
	 }
	 Node createDefaultNamespace(Node expr, int lineno) {
		 setRequiresActivation();
		 Node n = createUnary(Token.DEFAULTNAMESPACE, expr);
		 Node result = createExprStatement(n, lineno);
		 return result;
	 }
	 Node createName(String name) {
		 checkActivationName(name, Token.NAME);
		 return Node.newString(Token.NAME, name);
	 }
	 Node createString(String string) {
		 return Node.newString(string);
	 }
	 Node createNumber(double number) {
		 return Node.newNumber(number);
	 }
	 Node createCatch(String varName, Node catchCond, Node stmts, int lineno) {
		 if (catchCond == null) {
			 catchCond = new Node(Token.EMPTY);
		 }
		 return new Node(Token.CATCH, createName(varName), catchCond, stmts, lineno);
	 }
	 Node createThrow(Node expr, int lineno) {
		 return new Node(Token.THROW, expr, lineno);
	 }
	 Node createReturn(Node expr, int lineno) {
		 return expr == null ? new Node(Token.RETURN, lineno) : new Node(Token.RETURN, expr, lineno);
	 }
	 Node createLabel(int lineno) {
		 return new Node.Jump(Token.LABEL, lineno);
	 }
	 Node getLabelLoop(Node label) {
		 return ((Node.Jump)label).getLoop();
	 }
	 Node createLabeledStatement(Node labelArg, Node statement) {
		 Node.Jump label = (Node.Jump)labelArg;
		 Node breakTarget = Node.newTarget();
		 Node block = new Node(Token.BLOCK, label, statement, breakTarget);
		 label.target = breakTarget;
		 return block;
	 }
	 Node createBreak(Node breakStatement, int lineno) {
		 Node.Jump n = new Node.Jump(Token.BREAK, lineno);
		 Node.Jump jumpStatement;
		 int t = breakStatement.getType();
		 if (t == Token.LOOP || t == Token.LABEL) {
			 jumpStatement = (Node.Jump)breakStatement;
		 }
		 else if (t == Token.BLOCK && breakStatement.getFirstChild().getType() == Token.SWITCH) {
			 jumpStatement = (Node.Jump)breakStatement.getFirstChild();
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 n.setJumpStatement(jumpStatement);
		 return n;
	 }
	 Node createContinue(Node loop, int lineno) {
		 if (loop.getType() != Token.LOOP) Kit.codeBug();
		 Node.Jump n = new Node.Jump(Token.CONTINUE, lineno);
		 n.setJumpStatement((Node.Jump)loop);
		 return n;
	 }
	 Node createBlock(int lineno) {
		 return new Node(Token.BLOCK, lineno);
	 }
	 FunctionNode createFunction(String name) {
		 return new FunctionNode(name);
	 }
	 Node initFunction(FunctionNode fnNode, int functionIndex, Node statements, int functionType) {
		 fnNode.itsFunctionType = functionType;
		 fnNode.addChildToBack(statements);
		 int functionCount = fnNode.getFunctionCount();
		 if (functionCount != 0) {
			 fnNode.itsNeedsActivation = true;
			 for (int i = 0;
			 i != functionCount;
			 ++i) {
				 FunctionNode fn = fnNode.getFunctionNode(i);
				 if (fn.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 String name = fn.getFunctionName();
					 if (name != null && name.length() != 0) {
						 fnNode.removeParamOrVar(name);
					 }
				 }
			 }
		 }
		 if (functionType == FunctionNode.FUNCTION_EXPRESSION) {
			 String name = fnNode.getFunctionName();
			 if (name != null && name.length() != 0 && !fnNode.hasParamOrVar(name)) {
				 fnNode.addVar(name);
				 Node setFn = new Node(Token.EXPR_VOID, new Node(Token.SETVAR, Node.newString(name), new Node(Token.THISFN)));
				 statements.addChildrenToFront(setFn);
			 }
		 }
		 Node lastStmt = statements.getLastChild();
		 if (lastStmt == null || lastStmt.getType() != Token.RETURN) {
			 statements.addChildToBack(new Node(Token.RETURN));
		 }
		 Node result = Node.newString(Token.FUNCTION, fnNode.getFunctionName());
		 result.putIntProp(Node.FUNCTION_PROP, functionIndex);
		 return result;
	 }
	 void addChildToBack(Node parent, Node child) {
		 parent.addChildToBack(child);
	 }
	 Node createLoopNode(Node loopLabel, int lineno) {
		 Node.Jump result = new Node.Jump(Token.LOOP, lineno);
		 if (loopLabel != null) {
			 ((Node.Jump)loopLabel).setLoop(result);
		 }
		 return result;
	 }
	 Node createWhile(Node loop, Node cond, Node body) {
		 return createLoop((Node.Jump)loop, LOOP_WHILE, body, cond, null, null);
	 }
	 Node createDoWhile(Node loop, Node body, Node cond) {
		 return createLoop((Node.Jump)loop, LOOP_DO_WHILE, body, cond, null, null);
	 }
	 Node createFor(Node loop, Node init, Node test, Node incr, Node body) {
		 return createLoop((Node.Jump)loop, LOOP_FOR, body, test, init, incr);
	 }
	 private Node createLoop(Node.Jump loop, int loopType, Node body, Node cond, Node init, Node incr) {
		 Node bodyTarget = Node.newTarget();
		 Node condTarget = Node.newTarget();
		 if (loopType == LOOP_FOR && cond.getType() == Token.EMPTY) {
			 cond = new Node(Token.TRUE);
		 }
		 Node.Jump IFEQ = new Node.Jump(Token.IFEQ, cond);
		 IFEQ.target = bodyTarget;
		 Node breakTarget = Node.newTarget();
		 loop.addChildToBack(bodyTarget);
		 loop.addChildrenToBack(body);
		 if (loopType == LOOP_WHILE || loopType == LOOP_FOR) {
			 loop.addChildrenToBack(new Node(Token.EMPTY, loop.getLineno()));
		 }
		 loop.addChildToBack(condTarget);
		 loop.addChildToBack(IFEQ);
		 loop.addChildToBack(breakTarget);
		 loop.target = breakTarget;
		 Node continueTarget = condTarget;
		 if (loopType == LOOP_WHILE || loopType == LOOP_FOR) {
			 loop.addChildToFront(makeJump(Token.GOTO, condTarget));
			 if (loopType == LOOP_FOR) {
				 if (init.getType() != Token.EMPTY) {
					 if (init.getType() != Token.VAR) {
						 init = new Node(Token.EXPR_VOID, init);
					 }
					 loop.addChildToFront(init);
				 }
				 Node incrTarget = Node.newTarget();
				 loop.addChildAfter(incrTarget, body);
				 if (incr.getType() != Token.EMPTY) {
					 incr = new Node(Token.EXPR_VOID, incr);
					 loop.addChildAfter(incr, incrTarget);
				 }
				 continueTarget = incrTarget;
			 }
		 }
		 loop.setContinue(continueTarget);
		 return loop;
	 }
	 Node createForIn(Node loop, Node lhs, Node obj, Node body, boolean isForEach) {
		 String name;
		 int type = lhs.getType();
		 Node lvalue;
		 if (type == Token.VAR) {
			 Node lastChild = lhs.getLastChild();
			 if (lhs.getFirstChild() != lastChild) {
				 parser.reportError(""msg.mult.index"");
			 }
			 lvalue = Node.newString(Token.NAME, lastChild.getString());
		 }
		 else {
			 lvalue = makeReference(lhs);
			 if (lvalue == null) {
				 parser.reportError(""msg.bad.for.in.lhs"");
				 return obj;
			 }
		 }
		 Node localBlock = new Node(Token.LOCAL_BLOCK);
		 int initType = (isForEach) ? Token.ENUM_INIT_VALUES : Token.ENUM_INIT_KEYS;
		 Node init = new Node(initType, obj);
		 init.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
		 Node cond = new Node(Token.ENUM_NEXT);
		 cond.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
		 Node id = new Node(Token.ENUM_ID);
		 id.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
		 Node newBody = new Node(Token.BLOCK);
		 Node assign = simpleAssignment(lvalue, id);
		 newBody.addChildToBack(new Node(Token.EXPR_VOID, assign));
		 newBody.addChildToBack(body);
		 loop = createWhile(loop, cond, newBody);
		 loop.addChildToFront(init);
		 if (type == Token.VAR) loop.addChildToFront(lhs);
		 localBlock.addChildToBack(loop);
		 return localBlock;
	 }
	 Node createTryCatchFinally(Node tryBlock, Node catchBlocks, Node finallyBlock, int lineno) {
		 boolean hasFinally = (finallyBlock != null) && (finallyBlock.getType() != Token.BLOCK || finallyBlock.hasChildren());
		 if (tryBlock.getType() == Token.BLOCK && !tryBlock.hasChildren() && !hasFinally) {
			 return tryBlock;
		 }
		 boolean hasCatch = catchBlocks.hasChildren();
		 if (!hasFinally && !hasCatch) {
			 return tryBlock;
		 }
		 Node handlerBlock = new Node(Token.LOCAL_BLOCK);
		 Node.Jump pn = new Node.Jump(Token.TRY, tryBlock, lineno);
		 pn.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);
		 if (hasCatch) {
			 Node endCatch = Node.newTarget();
			 pn.addChildToBack(makeJump(Token.GOTO, endCatch));
			 Node catchTarget = Node.newTarget();
			 pn.target = catchTarget;
			 pn.addChildToBack(catchTarget);
			 Node catchScopeBlock = new Node(Token.LOCAL_BLOCK);
			 Node cb = catchBlocks.getFirstChild();
			 boolean hasDefault = false;
			 int scopeIndex = 0;
			 while (cb != null) {
				 int catchLineNo = cb.getLineno();
				 Node name = cb.getFirstChild();
				 Node cond = name.getNext();
				 Node catchStatement = cond.getNext();
				 cb.removeChild(name);
				 cb.removeChild(cond);
				 cb.removeChild(catchStatement);
				 catchStatement.addChildToBack(new Node(Token.LEAVEWITH));
				 catchStatement.addChildToBack(makeJump(Token.GOTO, endCatch));
				 Node condStmt;
				 if (cond.getType() == Token.EMPTY) {
					 condStmt = catchStatement;
					 hasDefault = true;
				 }
				 else {
					 condStmt = createIf(cond, catchStatement, null, catchLineNo);
				 }
				 Node catchScope = new Node(Token.CATCH_SCOPE, name, createUseLocal(handlerBlock));
				 catchScope.putProp(Node.LOCAL_BLOCK_PROP, catchScopeBlock);
				 catchScope.putIntProp(Node.CATCH_SCOPE_PROP, scopeIndex);
				 catchScopeBlock.addChildToBack(catchScope);
				 catchScopeBlock.addChildToBack( createWith(createUseLocal(catchScopeBlock), condStmt, catchLineNo));
				 cb = cb.getNext();
				 ++scopeIndex;
			 }
			 pn.addChildToBack(catchScopeBlock);
			 if (!hasDefault) {
				 Node rethrow = new Node(Token.RETHROW);
				 rethrow.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);
				 pn.addChildToBack(rethrow);
			 }
			 pn.addChildToBack(endCatch);
		 }
		 if (hasFinally) {
			 Node finallyTarget = Node.newTarget();
			 pn.setFinally(finallyTarget);
			 pn.addChildToBack(makeJump(Token.JSR, finallyTarget));
			 Node finallyEnd = Node.newTarget();
			 pn.addChildToBack(makeJump(Token.GOTO, finallyEnd));
			 pn.addChildToBack(finallyTarget);
			 Node fBlock = new Node(Token.FINALLY, finallyBlock);
			 fBlock.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock);
			 pn.addChildToBack(fBlock);
			 pn.addChildToBack(finallyEnd);
		 }
		 handlerBlock.addChildToBack(pn);
		 return handlerBlock;
	 }
	 Node createWith(Node obj, Node body, int lineno) {
		 setRequiresActivation();
		 Node result = new Node(Token.BLOCK, lineno);
		 result.addChildToBack(new Node(Token.ENTERWITH, obj));
		 Node bodyNode = new Node(Token.WITH, body, lineno);
		 result.addChildrenToBack(bodyNode);
		 result.addChildToBack(new Node(Token.LEAVEWITH));
		 return result;
	 }
	 public Node createDotQuery (Node obj, Node body, int lineno) {
		 setRequiresActivation();
		 Node result = new Node(Token.DOTQUERY, obj, body, lineno);
		 return result;
	 }
	 Node createArrayLiteral(ObjArray elems, int skipCount) {
		 int length = elems.size();
		 int[] skipIndexes = null;
		 if (skipCount != 0) {
			 skipIndexes = new int[skipCount];
		 }
		 Node array = new Node(Token.ARRAYLIT);
		 for (int i = 0, j = 0;
		 i != length;
		 ++i) {
			 Node elem = (Node)elems.get(i);
			 if (elem != null) {
				 array.addChildToBack(elem);
			 }
			 else {
				 skipIndexes[j] = i;
				 ++j;
			 }
		 }
		 if (skipCount != 0) {
			 array.putProp(Node.SKIP_INDEXES_PROP, skipIndexes);
		 }
		 return array;
	 }
	 Node createObjectLiteral(ObjArray elems) {
		 int size = elems.size() / 2;
		 Node object = new Node(Token.OBJECTLIT);
		 Object[] properties;
		 if (size == 0) {
			 properties = ScriptRuntime.emptyArgs;
		 }
		 else {
			 properties = new Object[size];
			 for (int i = 0;
			 i != size;
			 ++i) {
				 properties[i] = elems.get(2 * i);
				 Node value = (Node)elems.get(2 * i + 1);
				 object.addChildToBack(value);
			 }
		 }
		 object.putProp(Node.OBJECT_IDS_PROP, properties);
		 return object;
	 }
	 Node createRegExp(int regexpIndex) {
		 Node n = new Node(Token.REGEXP);
		 n.putIntProp(Node.REGEXP_PROP, regexpIndex);
		 return n;
	 }
	 Node createIf(Node cond, Node ifTrue, Node ifFalse, int lineno) {
		 int condStatus = isAlwaysDefinedBoolean(cond);
		 if (condStatus == ALWAYS_TRUE_BOOLEAN) {
			 return ifTrue;
		 }
		 else if (condStatus == ALWAYS_FALSE_BOOLEAN) {
			 if (ifFalse != null) {
				 return ifFalse;
			 }
			 return new Node(Token.BLOCK, lineno);
		 }
		 Node result = new Node(Token.BLOCK, lineno);
		 Node ifNotTarget = Node.newTarget();
		 Node.Jump IFNE = new Node.Jump(Token.IFNE, cond);
		 IFNE.target = ifNotTarget;
		 result.addChildToBack(IFNE);
		 result.addChildrenToBack(ifTrue);
		 if (ifFalse != null) {
			 Node endTarget = Node.newTarget();
			 result.addChildToBack(makeJump(Token.GOTO, endTarget));
			 result.addChildToBack(ifNotTarget);
			 result.addChildrenToBack(ifFalse);
			 result.addChildToBack(endTarget);
		 }
		 else {
			 result.addChildToBack(ifNotTarget);
		 }
		 return result;
	 }
	 Node createCondExpr(Node cond, Node ifTrue, Node ifFalse) {
		 int condStatus = isAlwaysDefinedBoolean(cond);
		 if (condStatus == ALWAYS_TRUE_BOOLEAN) {
			 return ifTrue;
		 }
		 else if (condStatus == ALWAYS_FALSE_BOOLEAN) {
			 return ifFalse;
		 }
		 return new Node(Token.HOOK, cond, ifTrue, ifFalse);
	 }
	 Node createUnary(int nodeType, Node child) {
		 int childType = child.getType();
		 switch (nodeType) {
			 case Token.DELPROP: {
				 Node n;
				 if (childType == Token.NAME) {
					 child.setType(Token.BINDNAME);
					 Node left = child;
					 Node right = Node.newString(child.getString());
					 n = new Node(nodeType, left, right);
				 }
				 else if (childType == Token.GETPROP || childType == Token.GETELEM) {
					 Node left = child.getFirstChild();
					 Node right = child.getLastChild();
					 child.removeChild(left);
					 child.removeChild(right);
					 n = new Node(nodeType, left, right);
				 }
				 else if (childType == Token.GET_REF) {
					 Node ref = child.getFirstChild();
					 child.removeChild(ref);
					 n = new Node(Token.DEL_REF, ref);
				 }
				 else {
					 n = new Node(Token.TRUE);
				 }
				 return n;
			 }
			 case Token.TYPEOF: if (childType == Token.NAME) {
				 child.setType(Token.TYPEOFNAME);
				 return child;
			 }
			 break;
			 case Token.BITNOT: if (childType == Token.NUMBER) {
				 int value = ScriptRuntime.toInt32(child.getDouble());
				 child.setDouble(~value);
				 return child;
			 }
			 break;
			 case Token.NEG: if (childType == Token.NUMBER) {
				 child.setDouble(-child.getDouble());
				 return child;
			 }
			 break;
			 case Token.NOT: {
				 int status = isAlwaysDefinedBoolean(child);
				 if (status != 0) {
					 int type;
					 if (status == ALWAYS_TRUE_BOOLEAN) {
						 type = Token.FALSE;
					 }
					 else {
						 type = Token.TRUE;
					 }
					 if (childType == Token.TRUE || childType == Token.FALSE) {
						 child.setType(type);
						 return child;
					 }
					 return new Node(type);
				 }
				 break;
			 }
		 }
		 return new Node(nodeType, child);
	 }
	 Node createCallOrNew(int nodeType, Node child) {
		 int type = Node.NON_SPECIALCALL;
		 if (child.getType() == Token.NAME) {
			 String name = child.getString();
			 if (name.equals(""eval"")) {
				 type = Node.SPECIALCALL_EVAL;
			 }
			 else if (name.equals(""With"")) {
				 type = Node.SPECIALCALL_WITH;
			 }
		 }
		 else if (child.getType() == Token.GETPROP) {
			 String name = child.getLastChild().getString();
			 if (name.equals(""eval"")) {
				 type = Node.SPECIALCALL_EVAL;
			 }
		 }
		 Node node = new Node(nodeType, child);
		 if (type != Node.NON_SPECIALCALL) {
			 setRequiresActivation();
			 node.putIntProp(Node.SPECIALCALL_PROP, type);
		 }
		 return node;
	 }
	 Node createIncDec(int nodeType, boolean post, Node child) {
		 child = makeReference(child);
		 if (child == null) {
			 String msg;
			 if (nodeType == Token.DEC) {
				 msg = ""msg.bad.decr"";
			 }
			 else {
				 msg = ""msg.bad.incr"";
			 }
			 parser.reportError(msg);
			 return null;
		 }
		 int childType = child.getType();
		 switch (childType) {
			 case Token.NAME: case Token.GETPROP: case Token.GETELEM: case Token.GET_REF: {
				 Node n = new Node(nodeType, child);
				 int incrDecrMask = 0;
				 if (nodeType == Token.DEC) {
					 incrDecrMask |= Node.DECR_FLAG;
				 }
				 if (post) {
					 incrDecrMask |= Node.POST_FLAG;
				 }
				 n.putIntProp(Node.INCRDECR_PROP, incrDecrMask);
				 return n;
			 }
		 }
		 throw Kit.codeBug();
	 }
	 Node createPropertyGet(Node target, String namespace, String name, int memberTypeFlags) {
		 if (namespace == null && memberTypeFlags == 0) {
			 if (target == null) {
				 return createName(name);
			 }
			 checkActivationName(name, Token.GETPROP);
			 if (ScriptRuntime.isSpecialProperty(name)) {
				 Node ref = new Node(Token.REF_SPECIAL, target);
				 ref.putProp(Node.NAME_PROP, name);
				 return new Node(Token.GET_REF, ref);
			 }
			 return new Node(Token.GETPROP, target, createString(name));
		 }
		 Node elem = createString(name);
		 memberTypeFlags |= Node.PROPERTY_FLAG;
		 return createMemberRefGet(target, namespace, elem, memberTypeFlags);
	 }
	 Node createElementGet(Node target, String namespace, Node elem, int memberTypeFlags) {
		 if (namespace == null && memberTypeFlags == 0) {
			 if (target == null) throw Kit.codeBug();
			 return new Node(Token.GETELEM, target, elem);
		 }
		 return createMemberRefGet(target, namespace, elem, memberTypeFlags);
	 }
	 private Node createMemberRefGet(Node target, String namespace, Node elem, int memberTypeFlags) {
		 Node nsNode = null;
		 if (namespace != null) {
			 if (namespace.equals(""*"")) {
				 nsNode = new Node(Token.NULL);
			 }
			 else {
				 nsNode = createName(namespace);
			 }
		 }
		 Node ref;
		 if (target == null) {
			 if (namespace == null) {
				 ref = new Node(Token.REF_NAME, elem);
			 }
			 else {
				 ref = new Node(Token.REF_NS_NAME, nsNode, elem);
			 }
		 }
		 else {
			 if (namespace == null) {
				 ref = new Node(Token.REF_MEMBER, target, elem);
			 }
			 else {
				 ref = new Node(Token.REF_NS_MEMBER, target, nsNode, elem);
			 }
		 }
		 if (memberTypeFlags != 0) {
			 ref.putIntProp(Node.MEMBER_TYPE_PROP, memberTypeFlags);
		 }
		 return new Node(Token.GET_REF, ref);
	 }
	 Node createBinary(int nodeType, Node left, Node right) {
		 switch (nodeType) {
			 case Token.ADD: if (left.type == Token.STRING) {
				 String s2;
				 if (right.type == Token.STRING) {
					 s2 = right.getString();
				 }
				 else if (right.type == Token.NUMBER) {
					 s2 = ScriptRuntime.numberToString(right.getDouble(), 10);
				 }
				 else {
					 break;
				 }
				 String s1 = left.getString();
				 left.setString(s1.concat(s2));
				 return left;
			 }
			 else if (left.type == Token.NUMBER) {
				 if (right.type == Token.NUMBER) {
					 left.setDouble(left.getDouble() + right.getDouble());
					 return left;
				 }
				 else if (right.type == Token.STRING) {
					 String s1, s2;
					 s1 = ScriptRuntime.numberToString(left.getDouble(), 10);
					 s2 = right.getString();
					 right.setString(s1.concat(s2));
					 return right;
				 }
			 }
			 break;
			 case Token.SUB: if (left.type == Token.NUMBER) {
				 double ld = left.getDouble();
				 if (right.type == Token.NUMBER) {
					 left.setDouble(ld - right.getDouble());
					 return left;
				 }
				 else if (ld == 0.0) {
					 return new Node(Token.NEG, right);
				 }
			 }
			 else if (right.type == Token.NUMBER) {
				 if (right.getDouble() == 0.0) {
					 return new Node(Token.POS, left);
				 }
			 }
			 break;
			 case Token.MUL: if (left.type == Token.NUMBER) {
				 double ld = left.getDouble();
				 if (right.type == Token.NUMBER) {
					 left.setDouble(ld * right.getDouble());
					 return left;
				 }
				 else if (ld == 1.0) {
					 return new Node(Token.POS, right);
				 }
			 }
			 else if (right.type == Token.NUMBER) {
				 if (right.getDouble() == 1.0) {
					 return new Node(Token.POS, left);
				 }
			 }
			 break;
			 case Token.DIV: if (right.type == Token.NUMBER) {
				 double rd = right.getDouble();
				 if (left.type == Token.NUMBER) {
					 left.setDouble(left.getDouble() / rd);
					 return left;
				 }
				 else if (rd == 1.0) {
					 return new Node(Token.POS, left);
				 }
			 }
			 break;
			 case Token.AND: {
				 int leftStatus = isAlwaysDefinedBoolean(left);
				 if (leftStatus == ALWAYS_FALSE_BOOLEAN) {
					 return new Node(Token.FALSE);
				 }
				 else if (leftStatus == ALWAYS_TRUE_BOOLEAN) {
					 return right;
				 }
				 int rightStatus = isAlwaysDefinedBoolean(right);
				 if (rightStatus == ALWAYS_FALSE_BOOLEAN) {
					 if (!hasSideEffects(left)) {
						 return new Node(Token.FALSE);
					 }
				 }
				 else if (rightStatus == ALWAYS_TRUE_BOOLEAN) {
					 return left;
				 }
				 break;
			 }
			 case Token.OR: {
				 int leftStatus = isAlwaysDefinedBoolean(left);
				 if (leftStatus == ALWAYS_TRUE_BOOLEAN) {
					 return new Node(Token.TRUE);
				 }
				 else if (leftStatus == ALWAYS_FALSE_BOOLEAN) {
					 return right;
				 }
				 int rightStatus = isAlwaysDefinedBoolean(right);
				 if (rightStatus == ALWAYS_TRUE_BOOLEAN) {
					 if (!hasSideEffects(left)) {
						 return new Node(Token.TRUE);
					 }
				 }
				 else if (rightStatus == ALWAYS_FALSE_BOOLEAN) {
					 return left;
				 }
				 break;
			 }
		 }
		 return new Node(nodeType, left, right);
	 }
	 private Node simpleAssignment(Node left, Node right) {
		 int nodeType = left.getType();
		 switch (nodeType) {
			 case Token.NAME: left.setType(Token.BINDNAME);
			 return new Node(Token.SETNAME, left, right);
			 case Token.GETPROP: case Token.GETELEM: {
				 Node obj = left.getFirstChild();
				 Node id = left.getLastChild();
				 int type;
				 if (nodeType == Token.GETPROP) {
					 type = Token.SETPROP;
				 }
				 else {
					 type = Token.SETELEM;
				 }
				 return new Node(type, obj, id, right);
			 }
			 case Token.GET_REF: {
				 Node ref = left.getFirstChild();
				 return new Node(Token.SET_REF, ref, right);
			 }
		 }
		 throw Kit.codeBug();
	 }
	 Node createAssignment(int assignType, Node left, Node right) {
		 left = makeReference(left);
		 if (left == null) {
			 parser.reportError(""msg.bad.assign.left"");
			 return right;
		 }
		 int assignOp;
		 switch (assignType) {
			 case Token.ASSIGN: return simpleAssignment(left, right);
			 case Token.ASSIGN_BITOR: assignOp = Token.BITOR;
			 break;
			 case Token.ASSIGN_BITXOR: assignOp = Token.BITXOR;
			 break;
			 case Token.ASSIGN_BITAND: assignOp = Token.BITAND;
			 break;
			 case Token.ASSIGN_LSH: assignOp = Token.LSH;
			 break;
			 case Token.ASSIGN_RSH: assignOp = Token.RSH;
			 break;
			 case Token.ASSIGN_URSH: assignOp = Token.URSH;
			 break;
			 case Token.ASSIGN_ADD: assignOp = Token.ADD;
			 break;
			 case Token.ASSIGN_SUB: assignOp = Token.SUB;
			 break;
			 case Token.ASSIGN_MUL: assignOp = Token.MUL;
			 break;
			 case Token.ASSIGN_DIV: assignOp = Token.DIV;
			 break;
			 case Token.ASSIGN_MOD: assignOp = Token.MOD;
			 break;
			 default: throw Kit.codeBug();
		 }
		 int nodeType = left.getType();
		 switch (nodeType) {
			 case Token.NAME: {
				 String s = left.getString();
				 Node opLeft = Node.newString(Token.NAME, s);
				 Node op = new Node(assignOp, opLeft, right);
				 Node lvalueLeft = Node.newString(Token.BINDNAME, s);
				 return new Node(Token.SETNAME, lvalueLeft, op);
			 }
			 case Token.GETPROP: case Token.GETELEM: {
				 Node obj = left.getFirstChild();
				 Node id = left.getLastChild();
				 int type = nodeType == Token.GETPROP ? Token.SETPROP_OP : Token.SETELEM_OP;
				 Node opLeft = new Node(Token.USE_STACK);
				 Node op = new Node(assignOp, opLeft, right);
				 return new Node(type, obj, id, op);
			 }
			 case Token.GET_REF: {
				 Node ref = left.getFirstChild();
				 Node opLeft = new Node(Token.USE_STACK);
				 Node op = new Node(assignOp, opLeft, right);
				 return new Node(Token.SET_REF_OP, ref, op);
			 }
		 }
		 throw Kit.codeBug();
	 }
	 Node createUseLocal(Node localBlock) {
		 if (Token.LOCAL_BLOCK != localBlock.getType()) throw Kit.codeBug();
		 Node result = new Node(Token.LOCAL_LOAD);
		 result.putProp(Node.LOCAL_BLOCK_PROP, localBlock);
		 return result;
	 }
	 private Node.Jump makeJump(int type, Node target) {
		 Node.Jump n = new Node.Jump(type);
		 n.target = target;
		 return n;
	 }
	 private Node makeReference(Node node) {
		 int type = node.getType();
		 switch (type) {
			 case Token.NAME: case Token.GETPROP: case Token.GETELEM: case Token.GET_REF: return node;
			 case Token.CALL: node.setType(Token.REF_CALL);
			 return new Node(Token.GET_REF, node);
		 }
		 return null;
	 }
	 private static int isAlwaysDefinedBoolean(Node node) {
		 switch (node.getType()) {
			 case Token.FALSE: case Token.NULL: return ALWAYS_FALSE_BOOLEAN;
			 case Token.TRUE: return ALWAYS_TRUE_BOOLEAN;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 if (num == num && num != 0.0) {
					 return ALWAYS_TRUE_BOOLEAN;
				 }
				 else {
					 return ALWAYS_FALSE_BOOLEAN;
				 }
			 }
		 }
		 return 0;
	 }
	 private static boolean hasSideEffects(Node exprTree) {
		 switch (exprTree.getType()) {
			 case Token.INC: case Token.DEC: case Token.SETPROP: case Token.SETELEM: case Token.SETNAME: case Token.CALL: case Token.NEW: return true;
			 default: Node child = exprTree.getFirstChild();
			 while (child != null) {
				 if (hasSideEffects(child)) return true;
				 child = child.getNext();
			 }
			 break;
		 }
		 return false;
	 }
	 private void checkActivationName(String name, int token) {
		 if (parser.insideFunction()) {
			 boolean activation = false;
			 if (""arguments"".equals(name) || (parser.compilerEnv.activationNames != null && parser.compilerEnv.activationNames.containsKey(name))) {
				 activation = true;
			 }
			 else if (""length"".equals(name)) {
				 if (token == Token.GETPROP && parser.compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
					 activation = true;
				 }
			 }
			 if (activation) {
				 setRequiresActivation();
			 }
		 }
	 }
	 private void setRequiresActivation() {
		 if (parser.insideFunction()) {
			 ((FunctionNode)parser.currentScriptOrFn).itsNeedsActivation = true;
		 }
	 }
	 private Parser parser;
	 private static final int LOOP_DO_WHILE = 0;
	 private static final int LOOP_WHILE = 1;
	 private static final int LOOP_FOR = 2;
	 private static final int ALWAYS_TRUE_BOOLEAN = 1;
	 private static final int ALWAYS_FALSE_BOOLEAN = -1;
}",0,0,0,0
"public void reloadConfiguration() throws ConfigurationException {
	 HashMap<InetAddress, String[]> reloadedMap = new HashMap<InetAddress, String[]>();
	 Properties properties = new Properties();
	 InputStream stream = null;
	 try {
		 stream = getClass().getClassLoader().getResourceAsStream(RACK_PROPERTY_FILENAME);
		 properties.load(stream);
	 }
	 catch (IOException e) {
		 throw new ConfigurationException(""Unable to read "" + RACK_PROPERTY_FILENAME, e);
	 }
	 finally {
		 FileUtils.closeQuietly(stream);
	 }
	 for (Map.Entry<Object, Object> entry : properties.entrySet()) {
		 String key = (String) entry.getKey();
		 String value = (String) entry.getValue();
		 if (key.equals(""default"")) {
			 defaultDCRack = value.split("":"");
			 if (defaultDCRack.length < 2) defaultDCRack = new String[] {
			 ""default"", ""default"" }
			;
		 }
		 else {
			 InetAddress host;
			 String hostString = key.replace(""/"", """");
			 try {
				 host = InetAddress.getByName(hostString);
			 }
			 catch (UnknownHostException e) {
				 throw new ConfigurationException(""Unknown host "" + hostString, e);
			 }
			 String[] token = value.split("":"");
			 if (token.length < 2) token = new String[] {
			 ""default"", ""default"" }
			;
			 reloadedMap.put(host, token);
		 }
	 }
	 logger.debug(""loaded network topology {
	}
	"", FBUtilities.toString(reloadedMap));
	 endpointMap = reloadedMap;
	 StorageService.instance.getTokenMetadata().invalidateCaches();
 }",0,0,0,0
"private boolean isFirstChunk(Segment s) {
	int c = 0;
	for (Segment ss : chunks) {
		if (ss.getTag().equals(s.getTag())) {
			c++;
		}
	}
	return c == 1;
}",0,0,0,0
"private void mainSort() {
	 final Data dataShadow = this.data;
	 final int[] runningOrder = dataShadow.mainSort_runningOrder;
	 final int[] copy = dataShadow.mainSort_copy;
	 final boolean[] bigDone = dataShadow.mainSort_bigDone;
	 final int[] ftab = dataShadow.ftab;
	 final byte[] block = dataShadow.block;
	 final int[] fmap = dataShadow.fmap;
	 final char[] quadrant = dataShadow.quadrant;
	 final int lastShadow = this.last;
	 final int workLimitShadow = this.workLimit;
	 final boolean firstAttemptShadow = this.firstAttempt;
	 for (int i = 65537;
	 --i >= 0;
	) {
		 ftab[i] = 0;
	 }
	 for (int i = 0;
	 i < NUM_OVERSHOOT_BYTES;
	 i++) {
		 block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];
	 }
	 for (int i = lastShadow + NUM_OVERSHOOT_BYTES +1;
	 --i >= 0;
	) {
		 quadrant[i] = 0;
	 }
	 block[0] = block[lastShadow + 1];
	 int c1 = block[0] & 0xff;
	 for (int i = 0;
	 i <= lastShadow;
	 i++) {
		 final int c2 = block[i + 1] & 0xff;
		 ftab[(c1 << 8) + c2]++;
		 c1 = c2;
	 }
	 for (int i = 1;
	 i <= 65536;
	 i++) ftab[i] += ftab[i - 1];
	 c1 = block[1] & 0xff;
	 for (int i = 0;
	 i < lastShadow;
	 i++) {
		 final int c2 = block[i + 2] & 0xff;
		 fmap[--ftab[(c1 << 8) + c2]] = i;
		 c1 = c2;
	 }
	 fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;
	 for (int i = 256;
	 --i >= 0;
	) {
		 bigDone[i] = false;
		 runningOrder[i] = i;
	 }
	 for (int h = 364;
	 h != 1;
	) {
		 h /= 3;
		 for (int i = h;
		 i <= 255;
		 i++) {
			 final int vv = runningOrder[i];
			 final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
			 final int b = h - 1;
			 int j = i;
			 for (int ro = runningOrder[j - h];
			 (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a;
			 ro = runningOrder[j - h]) {
				 runningOrder[j] = ro;
				 j -= h;
				 if (j <= b) {
					 break;
				 }
			 }
			 runningOrder[j] = vv;
		 }
	 }
	 for (int i = 0;
	 i <= 255;
	 i++) {
		 final int ss = runningOrder[i];
		 for (int j = 0;
		 j <= 255;
		 j++) {
			 final int sb = (ss << 8) + j;
			 final int ftab_sb = ftab[sb];
			 if ((ftab_sb & SETMASK) != SETMASK) {
				 final int lo = ftab_sb & CLEARMASK;
				 final int hi = (ftab[sb + 1] & CLEARMASK) - 1;
				 if (hi > lo) {
					 mainQSort3(dataShadow, lo, hi, 2);
					 if (firstAttemptShadow && (this.workDone > workLimitShadow)) {
						 return;
					 }
				 }
				 ftab[sb] = ftab_sb | SETMASK;
			 }
		 }
		 for (int j = 0;
		 j <= 255;
		 j++) {
			 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
		 }
		 for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK);
		 j < hj;
		 j++) {
			 final int fmap_j = fmap[j];
			 c1 = block[fmap_j] & 0xff;
			 if (!bigDone[c1]) {
				 fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);
				 copy[c1]++;
			 }
		 }
		 for (int j = 256;
		 --j >= 0;
		) ftab[(j << 8) + ss] |= SETMASK;
		 bigDone[ss] = true;
		 if (i < 255) {
			 final int bbStart = ftab[ss << 8] & CLEARMASK;
			 final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
			 int shifts = 0;
			 while ((bbSize >> shifts) > 65534) {
				 shifts++;
			 }
			 for (int j = 0;
			 j < bbSize;
			 j++) {
				 final int a2update = fmap[bbStart + j];
				 final char qVal = (char) (j >> shifts);
				 quadrant[a2update] = qVal;
				 if (a2update < NUM_OVERSHOOT_BYTES) {
					 quadrant[a2update + lastShadow + 1] = qVal;
				 }
			 }
		 }
	 }
 }",0,0,1,0
"static void writeTemplate(JRTemplate template, OutputStream out, String encoding);",0,0,0,0
"public class User implements Serializable {
	 private static final long serialVersionUID = 4247427179764560935L;
	 private Integer id;
	 private String username;
	 private String name;
	 private String firstName;
	 private String lastName;
	 private String email;
	 private String url;
	 private String description;
	 private String link;
	 private String locale;
	 private String nickname;
	 private String slug;
	 private String registeredDate;
	 private List<String> roles;
	 private Map<String, String> capabilities;
	 private Map<String, String> extraCapabilities;
	 private Map<String, String> avatarUrls;
	 private List<Map<String, String>> meta;
	 public User() {
	 }
	 public Integer getId() {
		 return id;
	 }
	 public void setId(Integer id) {
		 this.id = id;
	 }
	 public String getUsername() {
		 return username;
	 }
	 public void setUsername(String username) {
		 this.username = username;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getFirstName() {
		 return firstName;
	 }
	 public void setFirstName(String firstName) {
		 this.firstName = firstName;
	 }
	 public String getLastName() {
		 return lastName;
	 }
	 public void setLastName(String lastName) {
		 this.lastName = lastName;
	 }
	 public String getEmail() {
		 return email;
	 }
	 public void setEmail(String email) {
		 this.email = email;
	 }
	 public String getUrl() {
		 return url;
	 }
	 public void setUrl(String url) {
		 this.url = url;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getLink() {
		 return link;
	 }
	 public void setLink(String link) {
		 this.link = link;
	 }
	 public String getLocale() {
		 return locale;
	 }
	 public void setLocale(String locale) {
		 this.locale = locale;
	 }
	 public String getNickname() {
		 return nickname;
	 }
	 public void setNickname(String nickname) {
		 this.nickname = nickname;
	 }
	 public String getSlug() {
		 return slug;
	 }
	 public void setSlug(String slug) {
		 this.slug = slug;
	 }
	 public String getRegisteredDate() {
		 return registeredDate;
	 }
	 public void setRegisteredDate(String registeredDate) {
		 this.registeredDate = registeredDate;
	 }
	 public List<String> getRoles() {
		 return roles;
	 }
	 public void setRoles(List<String> roles) {
		 this.roles = roles;
	 }
	 public Map<String, String> getCapabilities() {
		 return capabilities;
	 }
	 public void setCapabilities(Map<String, String> capabilities) {
		 this.capabilities = capabilities;
	 }
	 public Map<String, String> getExtraCapabilities() {
		 return extraCapabilities;
	 }
	 public void setExtraCapabilities(Map<String, String> extraCapabilities) {
		 this.extraCapabilities = extraCapabilities;
	 }
	 public Map<String, String> getAvatarUrls() {
		 return avatarUrls;
	 }
	 public void setAvatarUrls(Map<String, String> avatarUrls) {
		 this.avatarUrls = avatarUrls;
	 }
	 public List<Map<String, String>> getMeta() {
		 return meta;
	 }
	 public void setMeta(List<Map<String, String>> meta) {
		 this.meta = meta;
	 }
	 public String toString() {
		 return toStringHelper(this).addValue(this.id).addValue(this.username).addValue(this.email).addValue(this.name).toString();
	 }
}",1,1,0,0
final void start();,0,0,0,0
"public class RevokeCertificateCmd extends BaseAsyncCmd {
	 public static final String APINAME = ""revokeCertificate"";
	 private CAManager caManager;
	 private String serial;
	 private String cn;
	 private String provider;
	 public BigInteger getSerialBigInteger() {
		 if (Strings.isNullOrEmpty(serial)) {
			 throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""Certificate serial cannot be empty"");
		 }
		 return new BigInteger(serial, 16);
	 }
	 public String getCn() {
		 return cn;
	 }
	 public String getProvider() {
		 return provider;
	 }
	 public void execute() {
		 boolean result = caManager.revokeCertificate(getSerialBigInteger(), getCn(), getProvider());
		 SuccessResponse response = new SuccessResponse(getCommandName());
		 response.setSuccess(result);
		 setResponseObject(response);
	 }
	 public String getCommandName() {
		 return APINAME.toLowerCase() + BaseCmd.RESPONSE_SUFFIX;
	 }
	 public long getEntityOwnerId() {
		 return CallContext.current().getCallingAccount().getId();
	 }
	 public String getEventType() {
		 return EventTypes.EVENT_CA_CERTIFICATE_REVOKE;
	 }
	 public String getEventDescription() {
		 return ""revoking certificate with serial id="" + serial + "", cn="" + cn;
	 }
}",1,1,0,0
"public class NullContext extends AbstractMetricsContext {
	 public NullContext() {
	 }
	 public void startMonitoring() {
	 }
	 protected void emitRecord(String contextName, String recordName, OutputRecord outRec) {
	}
	 protected void update(MetricsRecordImpl record) {
	 }
	 protected void remove(MetricsRecordImpl record) {
	 }
}",0,0,0,0
"public class WrongWeakHashMap extends IteratingRule {
	 private class WHMRecord {
		 private Instance hm;
		 private Instance key;
		 private Instance value;
		 WHMRecord(Instance hm, Instance key, Instance value) {
			 this.hm = hm;
			 this.key = key;
			 this.value = value;
		 }
		 public String toString() {
			 return NbBundle.getMessage(WrongWeakHashMap.class, ""FMT_WWHM_Entry"", new Object[] {
			 Utils.printClass(getContext(), getContext().getRootIncommingString(hm)), Utils.printInstance(hm), Utils.printInstance(key), Utils.printInstance(value) }
			 );
		 }
	 }
	 private FieldAccess fldHMEKey;
	 private FieldAccess fldHMENext;
	 private FieldAccess fldHMEValue;
	 private FieldAccess fldHMTable;
	 private JavaClass clsHM;
	 private JavaClass clsHME;
	 private Set<WHMRecord> poorWHM = new HashSet<WHMRecord>();
	 public WrongWeakHashMap() {
		 super(NbBundle.getMessage(WrongWeakHashMap.class, ""LBL_WWHM_Name""), NbBundle.getMessage(WrongWeakHashMap.class, ""LBL_WWHM_Desc""), ""java.util.WeakHashMap"");
	 }
	 public String getHTMLDescription() {
		 return NbBundle.getMessage(WrongWeakHashMap.class, ""LBL_WWHM_LongDesc"");
	 }
	 protected void perform(Instance hm) {
		 scanWeakHashmap(hm);
	 }
	 protected void prepareRule(MemoryLint context) {
		 Heap heap = context.getHeap();
		 clsHM = heap.getJavaClassByName(""java.util.WeakHashMap"");
		 clsHME = heap.getJavaClassByName(""java.util.WeakHashMap$Entry"");
		 fldHMTable = new FieldAccess(clsHM, ""table"");
		 JavaClass ref = heap.getJavaClassByName(""java.lang.ref.Reference"");
		 fldHMEKey = new FieldAccess(ref, ""referent"");
		 fldHMEValue = new FieldAccess(clsHME, ""value"");
		 fldHMENext = new FieldAccess(clsHME, ""next"");
	 }
	 protected void summary() {
		 for (WHMRecord whm : poorWHM) {
			 getContext().appendResults(whm.toString());
		 }
	 }
	 private void scanWeakHashmap(Instance hm) {
		 ObjectArrayInstance table = (ObjectArrayInstance) fldHMTable.getRefValue(hm);
		 if (table == null) {
			 return;
		 }
		 List<Instance> tval = table.getValues();
		 for (Instance entry : tval) {
			 while (entry != null) {
				 Instance key = fldHMEKey.getRefValue(entry);
				 if (key != null) {
					 Instance value = fldHMEValue.getRefValue(entry);
					 if (Utils.isReachableFrom(value, key)) {
						 poorWHM.add(new WHMRecord(hm, key, value));
						 return;
					 }
				 }
				 entry = fldHMENext.getRefValue(entry);
			 }
		 }
		 return;
	 }
}",0,0,0,0
"public class ConstRateAdaptor extends AbstractAdaptor implements Runnable {
	 private int SLEEP_VARIANCE = 200;
	 private int MIN_SLEEP = 300;
	 private long offset;
	 private int bytesPerSec;
	 Random timeCoin;
	 long seed;
	 private volatile boolean stopping = false;
	 public String getCurrentStatus() {
		 return type.trim() + "" "" + bytesPerSec + "" "" + seed;
	 }
	 public void start(long offset) throws AdaptorException {
		 this.offset = offset;
		 Configuration conf = control.getConfiguration();
		 MIN_SLEEP = conf.getInt(""constAdaptor.minSleep"", MIN_SLEEP);
		 SLEEP_VARIANCE = conf.getInt(""constAdaptor.sleepVariance"", SLEEP_VARIANCE);
		 timeCoin = new Random(seed);
		 long o =0;
		 while(o < offset) o += (int) ((timeCoin.nextInt(SLEEP_VARIANCE) + MIN_SLEEP) * (long) bytesPerSec / 1000L) + 8;
		 new Thread(this).start();
	 }
	 public String parseArgs(String bytesPerSecParam) {
		 try {
			 Matcher m = Pattern.compile(""([0-9]+)(?:\\s+([0-9]+))?\\s*"").matcher(bytesPerSecParam);
			 if(!m.matches()) return null;
			 bytesPerSec = Integer.parseInt(m.group(1));
			 String rate = m.group(2);
			 if(rate != null) seed = Long.parseLong(m.group(2));
			 else seed = System.currentTimeMillis();
		 }
		 catch (NumberFormatException e) {
			 return null;
		 }
		 return bytesPerSecParam;
	 }
	 public void run() {
		 try {
			 while (!stopping) {
				 int MSToSleep = timeCoin.nextInt(SLEEP_VARIANCE) + MIN_SLEEP;
				 int arraySize = (int) (MSToSleep * (long) bytesPerSec / 1000L) + 8;
				 ChunkImpl evt = nextChunk(arraySize );
				 dest.add(evt);
				 Thread.sleep(MSToSleep);
			 }
		 }
		 catch (InterruptedException ie) {
		 }
	 }
	 public ChunkImpl nextChunk(int arraySize) {
		 byte[] data = new byte[arraySize];
		 Random dataPattern = new Random(offset ^ seed);
		 long s = this.seed;
		 offset += data.length;
		 dataPattern.nextBytes(data);
		 for(int i=0;
		 i < 8;
		 ++i) {
			 data[7-i] = (byte) (s & 0xFF);
			 s >>= 8;
		 }
		 ChunkImpl evt = new ChunkImpl(type, ""random (""+ this.seed+"")"", offset, data, this);
		 return evt;
	 }
	 public String toString() {
		 return ""const rate "" + type;
	 }
	 public long shutdown(AdaptorShutdownPolicy shutdownPolicy) {
		 stopping = true;
		 return offset;
	 }
	 public static boolean checkChunk(Chunk chunk) {
		 byte[] data = chunk.getData();
		 byte[] correctData = new byte[data.length];
		 long seed = 0;
		 for(int i=0;
		 i < 8;
		 ++i) seed = (seed << 8) | (0xFF & data[i] );
		 seed ^= (chunk.getSeqID() - data.length);
		 Random dataPattern = new Random(seed);
		 dataPattern.nextBytes(correctData);
		 for(int i=8;
		 i < data.length ;
		 ++i) if(data [i] != correctData[i]) return false;
		 return true;
	 }
	 void test_init(String type) {
		 this.type = type;
		 seed = System.currentTimeMillis();
	 }
}",1,0,0,0
"public class AntiEntropyService{
	 private static final Logger logger = LoggerFactory.getLogger(AntiEntropyService.class);
	 public static final AntiEntropyService instance = new AntiEntropyService();
	 public final static long REQUEST_TIMEOUT = 48*60*60*1000;
	 private final ExpiringMap<String, Map<TreeRequest, TreePair>> requests;
	 private final ConcurrentMap<String, RepairSession> sessions;
	 protected AntiEntropyService() {
		 requests = new ExpiringMap<String, Map<TreeRequest, TreePair>>(REQUEST_TIMEOUT);
		 sessions = new ConcurrentHashMap<String, RepairSession>();
	 }
	 public RepairSession getRepairSession(Range range, String tablename, String... cfnames) {
		 return new RepairSession(range, tablename, cfnames);
	 }
	 RepairSession getArtificialRepairSession(TreeRequest req, String tablename, String... cfnames) {
		 return new RepairSession(req, tablename, cfnames);
	 }
	 static Set<InetAddress> getNeighbors(String table, Range range) {
		 StorageService ss = StorageService.instance;
		 Map<Range, List<InetAddress>> replicaSets = ss.getRangeToAddressMap(table);
		 if (!replicaSets.containsKey(range)) return Collections.emptySet();
		 Set<InetAddress> neighbors = new HashSet<InetAddress>(replicaSets.get(range));
		 neighbors.remove(FBUtilities.getLocalAddress());
		 Iterator<InetAddress> iter = neighbors.iterator();
		 while (iter.hasNext()) {
			 InetAddress endpoint = iter.next();
			 if (Gossiper.instance.getVersion(endpoint) <= MessagingService.VERSION_07) {
				 logger.info(""Excluding "" + endpoint + "" from repair because it is on version 0.7 or sooner. You should consider updating this node before running repair again."");
				 iter.remove();
			 }
		 }
		 return neighbors;
	 }
	 private void rendezvous(TreeRequest request, MerkleTree tree) {
		 RepairSession session = sessions.get(request.sessionid);
		 assert session != null;
		 RepairSession.RepairJob job = session.jobs.peek();
		 assert job != null : ""A repair should have at least some jobs scheduled"";
		 if (job.addTree(request, tree) == 0) {
			 logger.debug(""All trees received for "" + session.getName() + ""/"" + request.cf.right);
			 job.submitDifferencers();
			 session.jobs.poll();
			 RepairSession.RepairJob nextJob = session.jobs.peek();
			 if (nextJob == null) session.differencingDone.signalAll();
			 else nextJob.sendTreeRequests();
		 }
	 }
	 TreeRequest request(String sessionid, InetAddress remote, Range range, String ksname, String cfname) {
		 TreeRequest request = new TreeRequest(sessionid, remote, range, new CFPair(ksname, cfname));
		 MessagingService.instance().sendOneWay(TreeRequestVerbHandler.makeVerb(request, Gossiper.instance.getVersion(remote)), remote);
		 return request;
	 }
	 void respond(Validator validator, InetAddress local) {
		 MessagingService ms = MessagingService.instance();
		 try {
			 Message message = TreeResponseVerbHandler.makeVerb(local, validator);
			 logger.info(""Sending AEService tree for "" + validator.request);
			 ms.sendOneWay(message, validator.request.endpoint);
		 }
		 catch (Exception e) {
			 logger.error(""Could not send valid tree for request "" + validator.request, e);
		 }
	 }
	 public static class Validator implements Runnable {
		 public final TreeRequest request;
		 public final MerkleTree tree;
		 private transient List<MerkleTree.RowHash> minrows;
		 private transient long validated;
		 private transient MerkleTree.TreeRange range;
		 private transient MerkleTree.TreeRangeIterator ranges;
		 private transient DecoratedKey lastKey;
		 public final static MerkleTree.RowHash EMPTY_ROW = new MerkleTree.RowHash(null, new byte[0]);
		 Validator(TreeRequest request) {
			 this(request, new MerkleTree(DatabaseDescriptor.getPartitioner(), request.range, MerkleTree.RECOMMENDED_DEPTH, (int)Math.pow(2, 15)));
		 }
		 Validator(TreeRequest request, MerkleTree tree) {
			 this.request = request;
			 this.tree = tree;
			 this.tree.fullRange = this.request.range;
			 minrows = new ArrayList<MerkleTree.RowHash>();
			 validated = 0;
			 range = null;
			 ranges = null;
		 }
		 public void prepare(ColumnFamilyStore cfs) {
			 if (tree.partitioner() instanceof RandomPartitioner) {
				 tree.init();
			 }
			 else {
				 List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
				 for (DecoratedKey sample : cfs.keySamples(request.range)) {
					 assert request.range.contains(sample.token);
					 keys.add(sample);
				 }
				 if (keys.isEmpty()) {
					 tree.init();
				 }
				 else {
					 int numkeys = keys.size();
					 Random random = new Random();
					 while (true) {
						 DecoratedKey dk = keys.get(random.nextInt(numkeys));
						 if (!tree.split(dk.token)) break;
					 }
				 }
			 }
			 logger.debug(""Prepared AEService tree of size "" + tree.size() + "" for "" + request);
			 ranges = tree.invalids();
		 }
		 public void add(AbstractCompactedRow row) {
			 assert request.range.contains(row.key.token) : row.key.token + "" is not contained in "" + request.range;
			 assert lastKey == null || lastKey.compareTo(row.key) < 0 : ""row "" + row.key + "" received out of order wrt "" + lastKey;
			 lastKey = row.key;
			 if (range == null) range = ranges.next();
			 while (!range.contains(row.key.token)) {
				 range.addHash(EMPTY_ROW);
				 range = ranges.next();
			 }
			 range.addHash(rowHash(row));
		 }
		 private MerkleTree.RowHash rowHash(AbstractCompactedRow row) {
			 validated++;
			 MessageDigest digest = FBUtilities.newMessageDigest(""SHA-256"");
			 row.update(digest);
			 return new MerkleTree.RowHash(row.key.token, digest.digest());
		 }
		 public void complete() {
			 completeTree();
			 StageManager.getStage(Stage.ANTI_ENTROPY).execute(this);
			 logger.debug(""Validated "" + validated + "" rows into AEService tree for "" + request);
		 }
		 void completeTree() {
			 assert ranges != null : ""Validator was not prepared()"";
			 if (range != null) range.addHash(EMPTY_ROW);
			 while (ranges.hasNext()) {
				 range = ranges.next();
				 range.addHash(EMPTY_ROW);
			 }
		 }
		 public void run() {
			 AntiEntropyService.instance.respond(this, FBUtilities.getLocalAddress());
		 }
	 }
	 public static class TreeRequestVerbHandler implements IVerbHandler, ICompactSerializer<TreeRequest> {
		 public static final TreeRequestVerbHandler SERIALIZER = new TreeRequestVerbHandler();
		 static Message makeVerb(TreeRequest request, int version) {
			 try {
				 ByteArrayOutputStream bos = new ByteArrayOutputStream();
				 DataOutputStream dos = new DataOutputStream(bos);
				 SERIALIZER.serialize(request, dos, version);
				 return new Message(FBUtilities.getLocalAddress(), StorageService.Verb.TREE_REQUEST, bos.toByteArray(), version);
			 }
			 catch(IOException e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public void serialize(TreeRequest request, DataOutputStream dos, int version) throws IOException {
			 dos.writeUTF(request.sessionid);
			 CompactEndpointSerializationHelper.serialize(request.endpoint, dos);
			 dos.writeUTF(request.cf.left);
			 dos.writeUTF(request.cf.right);
			 if (version > MessagingService.VERSION_07) AbstractBounds.serializer().serialize(request.range, dos);
		 }
		 public TreeRequest deserialize(DataInputStream dis, int version) throws IOException {
			 String sessId = dis.readUTF();
			 InetAddress endpoint = CompactEndpointSerializationHelper.deserialize(dis);
			 CFPair cfpair = new CFPair(dis.readUTF(), dis.readUTF());
			 Range range;
			 if (version > MessagingService.VERSION_07) range = (Range) AbstractBounds.serializer().deserialize(dis);
			 else range = new Range(StorageService.getPartitioner().getMinimumToken(), StorageService.getPartitioner().getMinimumToken());
			 return new TreeRequest(sessId, endpoint, range, cfpair);
		 }
		 public void doVerb(Message message, String id) {
			 byte[] bytes = message.getMessageBody();
			 DataInputStream buffer = new DataInputStream(new ByteArrayInputStream(bytes));
			 try {
				 TreeRequest remotereq = this.deserialize(buffer, message.getVersion());
				 TreeRequest request = new TreeRequest(remotereq.sessionid, message.getFrom(), remotereq.range, remotereq.cf);
				 ColumnFamilyStore store = Table.open(request.cf.left).getColumnFamilyStore(request.cf.right);
				 Validator validator = new Validator(request);
				 logger.debug(""Queueing validation compaction for "" + request);
				 CompactionManager.instance.submitValidation(store, validator);
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
	 }
	 public static class TreeResponseVerbHandler implements IVerbHandler, ICompactSerializer<Validator> {
		 public static final TreeResponseVerbHandler SERIALIZER = new TreeResponseVerbHandler();
		 static Message makeVerb(InetAddress local, Validator validator) {
			 try {
				 ByteArrayOutputStream bos = new ByteArrayOutputStream();
				 DataOutputStream dos = new DataOutputStream(bos);
				 SERIALIZER.serialize(validator, dos, Gossiper.instance.getVersion(validator.request.endpoint));
				 return new Message(local, StorageService.Verb.TREE_RESPONSE, bos.toByteArray(), Gossiper.instance.getVersion(validator.request.endpoint));
			 }
			 catch(IOException e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public void serialize(Validator v, DataOutputStream dos, int version) throws IOException {
			 TreeRequestVerbHandler.SERIALIZER.serialize(v.request, dos, version);
			 MerkleTree.serializer.serialize(v.tree, dos, version);
			 dos.flush();
		 }
		 public Validator deserialize(DataInputStream dis, int version) throws IOException {
			 final TreeRequest request = TreeRequestVerbHandler.SERIALIZER.deserialize(dis, version);
			 try {
				 return new Validator(request, MerkleTree.serializer.deserialize(dis, version));
			 }
			 catch(Exception e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public void doVerb(Message message, String id) {
			 byte[] bytes = message.getMessageBody();
			 DataInputStream buffer = new DataInputStream(new ByteArrayInputStream(bytes));
			 try {
				 Validator response = this.deserialize(buffer, message.getVersion());
				 TreeRequest request = new TreeRequest(response.request.sessionid, message.getFrom(), response.request.range, response.request.cf);
				 AntiEntropyService.instance.rendezvous(request, response.tree);
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
	 }
	 static class CFPair extends Pair<String,String> {
		 public CFPair(String table, String cf) {
			 super(table, cf);
			 assert table != null && cf != null;
		 }
	 }
	 static class TreePair extends Pair<MerkleTree,MerkleTree> {
		 public TreePair(MerkleTree local, MerkleTree remote) {
			 super(local, remote);
		 }
	 }
	 public static class TreeRequest {
		 public final String sessionid;
		 public final InetAddress endpoint;
		 public final Range range;
		 public final CFPair cf;
		 public TreeRequest(String sessionid, InetAddress endpoint, Range range, CFPair cf) {
			 this.sessionid = sessionid;
			 this.endpoint = endpoint;
			 this.cf = cf;
			 this.range = range;
		 }
		 public final int hashCode() {
			 return Objects.hashCode(sessionid, endpoint, cf, range);
		 }
		 public final boolean equals(Object o) {
			 if(!(o instanceof TreeRequest)) return false;
			 TreeRequest that = (TreeRequest)o;
			 return Objects.equal(sessionid, that.sessionid) && Objects.equal(endpoint, that.endpoint) && Objects.equal(cf, that.cf) && Objects.equal(range, that.range);
		 }
		 public String toString() {
			 return ""#<TreeRequest "" + sessionid + "", "" + endpoint + "", "" + cf + "", "" + range + "">"";
		 }
	 }
	 class RepairSession extends Thread {
		 private final String tablename;
		 private final String[] cfnames;
		 private final ConcurrentHashMap<TreeRequest,Object> requests = new ConcurrentHashMap<TreeRequest,Object>();
		 private final Range range;
		 private final Set<InetAddress> endpoints;
		 private CountDownLatch completedLatch;
		 final Queue<RepairJob> jobs = new ConcurrentLinkedQueue<RepairJob>();
		 public final Condition differencingDone = new SimpleCondition();
		 public RepairSession(TreeRequest req, String tablename, String... cfnames) {
			 this(req.sessionid, req.range, tablename, cfnames);
			 requests.put(req, this);
			 completedLatch = new CountDownLatch(cfnames.length);
			 AntiEntropyService.instance.sessions.put(getName(), this);
		 }
		 public RepairSession(Range range, String tablename, String... cfnames) {
			 this(""manual-repair-"" + UUID.randomUUID(), range, tablename, cfnames);
		 }
		 private RepairSession(String id, Range range, String tablename, String[] cfnames) {
			 super(id);
			 this.tablename = tablename;
			 this.cfnames = cfnames;
			 assert cfnames.length > 0 : ""Repairing no column families seems pointless, doesn't it"";
			 this.range = range;
			 this.endpoints = AntiEntropyService.getNeighbors(tablename, range);
		 }
		 public void run() {
			 if (endpoints.isEmpty()) {
				 differencingDone.signalAll();
				 logger.info(""No neighbors to repair with for "" + tablename + "" on "" + range + "": "" + getName() + "" completed."");
				 return;
			 }
			 for (InetAddress endpoint : endpoints) {
				 if (!FailureDetector.instance.isAlive(endpoint)) {
					 differencingDone.signalAll();
					 logger.info(""Could not proceed on repair because a neighbor ("" + endpoint + "") is dead: "" + getName() + "" failed."");
					 return;
				 }
			 }
			 AntiEntropyService.instance.sessions.put(getName(), this);
			 try {
				 for (String cfname : cfnames) jobs.offer(new RepairJob(cfname));
				 completedLatch = new CountDownLatch(endpoints.size() * cfnames.length);
				 jobs.peek().sendTreeRequests();
				 completedLatch.await();
			 }
			 catch (InterruptedException e) {
				 throw new RuntimeException(""Interrupted while waiting for repair: repair will continue in the background."");
			 }
			 finally {
				 AntiEntropyService.instance.sessions.remove(getName());
			 }
		 }
		 void completed(InetAddress remote, String cfname) {
			 logger.debug(""Repair completed for {
			}
			 on {
			}
			"", remote, cfname);
			 completedLatch.countDown();
		 }
		 class RepairJob {
			 private final String cfname;
			 private final AtomicInteger remaining;
			 private final Map<InetAddress, MerkleTree> trees;
			 public RepairJob(String cfname) {
				 this.cfname = cfname;
				 this.remaining = new AtomicInteger(endpoints.size() + 1);
				 this.trees = new ConcurrentHashMap<InetAddress, MerkleTree>();
			 }
			 public void sendTreeRequests() {
				 for (InetAddress endpoint : endpoints) requests.put(AntiEntropyService.instance.request(getName(), endpoint, range, tablename, cfname), RepairSession.this);
				 AntiEntropyService.instance.request(getName(), FBUtilities.getLocalAddress(), range, tablename, cfname);
			 }
			 public int addTree(TreeRequest request, MerkleTree tree) {
				 assert request.cf.right.equals(cfname);
				 trees.put(request.endpoint, tree);
				 return remaining.decrementAndGet();
			 }
			 public void submitDifferencers() {
				 assert remaining.get() == 0;
				 MerkleTree localTree = trees.get(FBUtilities.getLocalAddress());
				 assert localTree != null;
				 for (Map.Entry<InetAddress, MerkleTree> entry : trees.entrySet()) {
					 if (entry.getKey().equals(FBUtilities.getLocalAddress())) continue;
					 Differencer differencer = new Differencer(cfname, entry.getKey(), entry.getValue(), localTree);
					 logger.debug(""Queueing comparison "" + differencer);
					 StageManager.getStage(Stage.ANTI_ENTROPY).execute(differencer);
				 }
			 }
		 }
		 class Differencer implements Runnable {
			 public final String cfname;
			 public final InetAddress remote;
			 public final MerkleTree ltree;
			 public final MerkleTree rtree;
			 public List<Range> differences;
			 Differencer(String cfname, InetAddress remote, MerkleTree ltree, MerkleTree rtree) {
				 this.cfname = cfname;
				 this.remote = remote;
				 this.ltree = ltree;
				 this.rtree = rtree;
				 this.differences = new ArrayList<Range>();
			 }
			 public void run() {
				 InetAddress local = FBUtilities.getLocalAddress();
				 if (ltree.partitioner() == null) ltree.partitioner(StorageService.getPartitioner());
				 if (rtree.partitioner() == null) rtree.partitioner(StorageService.getPartitioner());
				 differences.addAll(MerkleTree.difference(ltree, rtree));
				 String format = ""Endpoints "" + local + "" and "" + remote + "" %s for "" + cfname + "" on "" + range;
				 if (differences.isEmpty()) {
					 logger.info(String.format(format, ""are consistent""));
					 completed(remote, cfname);
					 return;
				 }
				 logger.info(String.format(format, ""have "" + differences.size() + "" range(s) out of sync""));
				 try {
					 performStreamingRepair();
				 }
				 catch(IOException e) {
					 throw new RuntimeException(e);
				 }
			 }
			 void performStreamingRepair() throws IOException {
				 logger.info(""Performing streaming repair of "" + differences.size() + "" ranges with "" + remote + "" for "" + range);
				 ColumnFamilyStore cfstore = Table.open(tablename).getColumnFamilyStore(cfname);
				 try {
					 Collection<SSTableReader> sstables = cfstore.getSSTables();
					 Callback callback = new Callback();
					 StreamOutSession outsession = StreamOutSession.create(tablename, remote, callback);
					 StreamOut.transferSSTables(outsession, sstables, differences, OperationType.AES);
					 StreamIn.requestRanges(remote, tablename, differences, callback, OperationType.AES);
				 }
				 catch(Exception e) {
					 throw new IOException(""Streaming repair failed."", e);
				 }
			 }
			 public String toString() {
				 return ""#<Differencer "" + remote + ""/"" + range + "">"";
			 }
			 class Callback extends WrappedRunnable {
				 private final AtomicInteger outstanding = new AtomicInteger(2);
				 protected void runMayThrow() throws Exception {
					 if (outstanding.decrementAndGet() > 0) return;
					 completed(remote, cfname);
					 logger.info(String.format(""Finished streaming repair with %s for %s: %d oustanding to complete session"", remote, range, completedLatch.getCount()));
				 }
			 }
		 }
	 }
}",0,0,0,0
"public void tryStoreVectorizedKey(HiveKey key, boolean partColsIsNull, int batchIndex) throws HiveException, IOException {
	 int size = indexes.size();
	 int index = size < topN ? size : evicted;
	 keys[index] = Arrays.copyOf(key.getBytes(), key.getLength());
	 distKeyLengths[index] = key.getDistKeyLength();
	 hashes[index] = key.hashCode();
	 Integer collisionIndex = indexes.store(index);
	 if (null != collisionIndex) {
		 if ( indexes instanceof HashForGroup ) {
			 indexes.store(collisionIndex);
		 }
		 ++batchNumForwards;
		 batchIndexToResult[batchIndex] = MAY_FORWARD - collisionIndex;
		 return;
	 }
	 indexToBatchIndex[index] = batchIndex;
	 batchIndexToResult[batchIndex] = index;
	 if (size != topN) return;
	 evicted = indexes.removeBiggest();
	 if (index == evicted) {
		 excluded++;
		 batchIndexToResult[batchIndex] = EXCLUDE;
		 indexToBatchIndex[index] = -1;
		 return;
	 }
	 removed(evicted);
	 int evictedBatchIndex = indexToBatchIndex[evicted];
	 if (evictedBatchIndex >= 0) {
		 batchIndexToResult[evictedBatchIndex] = EXCLUDE;
		 indexToBatchIndex[evicted] = -1;
	 }
	 int evictedForward = (MAY_FORWARD - evicted);
	 for (int i = evictedBatchIndex + 1;
	 i < batchIndex && (batchNumForwards > 0);
	 ++i) {
		 if (batchIndexToResult[i] == evictedForward) {
			 batchIndexToResult[i] = EXCLUDE;
			 --batchNumForwards;
		 }
	 }
 }",0,0,1,0
"public abstract class AbstractUUIDType extends AbstractType<UUID>{
	 public Class<UUID> getType() {
		 return UUID.class;
	 }
	 public boolean isSigned() {
		 return false;
	 }
	 public boolean isCaseSensitive() {
		 return false;
	 }
	 public boolean isCurrency() {
		 return false;
	 }
	 public int getPrecision(UUID obj) {
		 return -1;
	 }
	 public int getScale(UUID obj) {
		 return -1;
	 }
	 public int getJdbcType() {
		 return Types.OTHER;
	 }
	 public boolean needsQuotes() {
		 return false;
	 }
}",0,0,0,0
"public final class ResolutionOptions {
	 public static class EncodingStrategy extends TypesafeEnum {
		 private EncodingStrategy(final int value) {
			 super(value);
		 }
		 public final static EncodingStrategy DEFAULT = new EncodingStrategy(0);
		 public final static EncodingStrategy OVERRIDE_EXPLICIT = new EncodingStrategy(1);
		 public final static EncodingStrategy CONVERT_EXPLICIT = new EncodingStrategy(2);
	 }
	 private EncodingStrategy encodingStrategy = EncodingStrategy.DEFAULT;
	 private FileEncoding explicitEncoding = FileEncoding.AUTOMATICALLY_DETECT;
	 private boolean useInternalEngine = true;
	 private FileEncoding acceptMergeEncoding = null;
	 private String newPath = null;
	 private boolean acceptMergeWithConflicts = false;
	 private PropertyValue[] acceptMergeProperties;
	 public ResolutionOptions() {
		 super();
	 }
	 public void setEncodingStrategy(final EncodingStrategy strategy, final FileEncoding explicitEncoding) {
		 Check.isTrue( (strategy == EncodingStrategy.DEFAULT && explicitEncoding == null || explicitEncoding != null), ""explicitEncoding must be null if strategy is EncodingStrategy.DEFAULT"");
		 encodingStrategy = strategy;
		 this.explicitEncoding = explicitEncoding;
	 }
	 public EncodingStrategy getEncodingStrategy() {
		 return encodingStrategy;
	 }
	 public FileEncoding getExplicitEncoding() {
		 return explicitEncoding;
	 }
	 public void setUseInternalEngine(final boolean useInternalEngine) {
		 this.useInternalEngine = useInternalEngine;
	 }
	 public boolean useInternalEngine() {
		 return useInternalEngine;
	 }
	 public void setAcceptMergeEncoding(final FileEncoding encoding) {
		 acceptMergeEncoding = encoding;
	 }
	 public FileEncoding getAcceptMergeEncoding() {
		 return acceptMergeEncoding;
	 }
	 public PropertyValue[] getAcceptMergeProperties() {
		 return acceptMergeProperties;
	 }
	 public void setAcceptMergeProperties(final PropertyValue[] acceptMergeProperties) {
		 this.acceptMergeProperties = acceptMergeProperties;
	 }
	 public void setNewPath(final String newPath) {
		 this.newPath = newPath;
	 }
	 public String getNewPath() {
		 return newPath;
	 }
	 public boolean isAcceptMergeWithConflicts() {
		 return acceptMergeWithConflicts;
	 }
	 public void setAcceptMergeWithConflicts(final boolean mergeWithConflicts) {
		 acceptMergeWithConflicts = mergeWithConflicts;
	 }
}",1,1,0,0
"public class CpmFrame extends JFrame implements ActionListener {
	 private static final long serialVersionUID = 756368351780483658L;
	 private CpmPanel cpmPanel;
	 private JMenuBar menuBar;
	 private JMenuItem exitMenuItem;
	 private JMenuItem aboutMenuItem;
	 private JMenuItem helpMenuItem;
	 private JDialog aboutDialog;
	 public CpmFrame() {
		 super(""Collection Processing Engine Configurator"");
		 try {
			 UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		 }
		 catch (Exception e) {
			 System.err.println(""Could not set look and feel: "" + e.getMessage());
		 }
		 FileChooserBugWorkarounds.fix();
		 try {
			 this.setIconImage(Images.getImage(Images.MICROSCOPE));
		 }
		 catch (IOException e) {
			 System.err.println(""Image could not be loaded: "" + e.getMessage());
		 }
		 this.getContentPane().setBackground(Color.WHITE);
		 this.getContentPane().setLayout(new BorderLayout());
		 JLabel banner = new JLabel(Images.getImageIcon(Images.BANNER));
		 this.getContentPane().add(banner, BorderLayout.NORTH);
		 cpmPanel = new CpmPanel();
		 this.getContentPane().add(cpmPanel, BorderLayout.CENTER);
		 setJMenuBar(createMenuBar());
		 aboutDialog = new AboutDialog(this, ""About Collection Processing Engine Configurator"");
		 this.setSize(800, 600);
		 this.pack();
	 }
	 private JMenuBar createMenuBar() {
		 menuBar = new JMenuBar();
		 JMenu fileMenu = new JMenu(""File"");
		 List fileMenuItems = cpmPanel.createFileMenuItems();
		 Iterator iter = fileMenuItems.iterator();
		 while (iter.hasNext()) {
			 fileMenu.add((JMenuItem) iter.next());
		 }
		 exitMenuItem = new JMenuItem(""Exit"");
		 exitMenuItem.addActionListener(this);
		 fileMenu.add(exitMenuItem);
		 JMenu viewMenu = new JMenu(""View"");
		 List viewMenuItems = cpmPanel.createViewMenuItems();
		 iter = viewMenuItems.iterator();
		 while (iter.hasNext()) {
			 viewMenu.add((JMenuItem) iter.next());
		 }
		 JMenu helpMenu = new JMenu(""Help"");
		 aboutMenuItem = new JMenuItem(""About"");
		 aboutMenuItem.addActionListener(this);
		 helpMenuItem = new JMenuItem(""Help"");
		 helpMenuItem.addActionListener(this);
		 helpMenu.add(aboutMenuItem);
		 helpMenu.add(helpMenuItem);
		 menuBar.add(fileMenu);
		 menuBar.add(viewMenu);
		 menuBar.add(helpMenu);
		 return menuBar;
	 }
	 public void actionPerformed(ActionEvent ev) {
		 Object source = ev.getSource();
		 if (source == aboutMenuItem) {
			 aboutDialog.setVisible(true);
		 }
		 else if (source == helpMenuItem) {
			 JOptionPane.showMessageDialog(CpmFrame.this, CpmPanel.HELP_MESSAGE, ""Collection Processing Engine Configurator Help"", JOptionPane.PLAIN_MESSAGE);
		 }
		 else if (source == exitMenuItem) {
			 this.processWindowEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
		 }
	 }
	 public Dimension getPreferredSize() {
		 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		 return new Dimension(screenSize.width, (screenSize.height - 65));
	 }
	 public static void main(String[] args) {
		 SwingUtilities.invokeLater(new Runnable() {
			 public void run() {
				 initGUI();
			 }
		 }
		);
	 }
	 private static void initGUI() {
		 try {
			 final CpmFrame frame = new CpmFrame();
			 frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
			 frame.addWindowListener(new WindowAdapter() {
				 public void windowClosing(WindowEvent e) {
					 if (frame.cpmPanel.confirmExit()) System.exit(0);
				 }
				 public void windowActivated(WindowEvent e) {
					 frame.cpmPanel.checkForOutOfSyncFiles();
				 }
			 }
			);
			 frame.pack();
			 frame.setVisible(true);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
}",0,0,0,0
"public static String humanReadableInt(long number) {
	 long absNumber = Math.abs(number);
	 double result = number;
	 String suffix = """";
	 if (absNumber < 1024) {
	 }
	 else if (absNumber < 1024 * 1024) {
		 result = number / 1024.0;
		 suffix = ""k"";
	 }
	 else if (absNumber < 1024 * 1024 * 1024) {
		 result = number / (1024.0 * 1024);
		 suffix = ""m"";
	 }
	 else {
		 result = number / (1024.0 * 1024 * 1024);
		 suffix = ""g"";
	 }
	 return oneDecimal.format(result) + suffix;
 }",0,0,0,0
"private void createMainMenu(Shell shell) {
	 mainmenu = new Menu(shell, SWT.BAR);
	 MenuItem topItem = new MenuItem(mainmenu, SWT.CASCADE);
	 topItem.setText(""File"");
	 Menu menu = new Menu(shell, SWT.DROP_DOWN);
	 topItem.setMenu(menu);
	 MenuItem item = new MenuItem(menu, SWT.NULL);
	 item.setText(""New"");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_NEW.run();
		 }
	 }
	);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Open..."");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_OPEN.run();
		 }
	 }
	);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Save"");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_SAVE.run();
		 }
	 }
	);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Save As..."");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_SAVE_AS.run();
		 }
	 }
	);
	 item = new MenuItem(menu, SWT.SEPARATOR);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Exit"");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_EXIT.run();
		 }
	 }
	);
	 topItem = new MenuItem(mainmenu, SWT.CASCADE);
	 topItem.setText(""Project"");
	 menu = new Menu(shell, SWT.DROP_DOWN);
	 topItem.setMenu(menu);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Compile"");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_COMPILE.run();
		 }
	 }
	);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Run .exe"");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_RUNEXE.run();
		 }
	 }
	);
	 topItem = new MenuItem(mainmenu, SWT.CASCADE);
	 topItem.setText(""Console"");
	 menu = new Menu(shell, SWT.DROP_DOWN);
	 topItem.setMenu(menu);
	 item = new MenuItem(menu, SWT.NULL);
	 item.setText(""Clear"");
	 item.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 ACTION_CONSOLE_CLEAR.run();
		 }
	 }
	);
	 shell.setMenuBar(mainmenu);
 }",0,0,1,0
"private void executeDropIndex(Tree statement) {
	 if (!CliMain.isConnected() || !hasKeySpace()) return;
	 String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
	 String rawColumName = statement.getChild(1).getText();
	 CfDef cfDef = getCfDef(columnFamily);
	 ByteBuffer columnName = columnNameAsBytes(rawColumName, cfDef);
	 boolean foundColumn = false;
	 for (ColumnDef column : cfDef.getColumn_metadata()) {
		 if (column.name.equals(columnName)) {
			 foundColumn = true;
			 if (column.getIndex_type() == null) throw new RuntimeException(String.format(""Column '%s' does not have an index."", rawColumName));
			 column.setIndex_name(null);
			 column.setIndex_type(null);
		 }
	 }
	 if (!foundColumn) throw new RuntimeException(String.format(""Column '%s' definition was not found in ColumnFamily '%s'."", rawColumName, columnFamily));
	 try {
		 String mySchemaVersion = thriftClient.system_update_column_family(cfDef);
		 sessionState.out.println(mySchemaVersion);
		 validateSchemaIsSettled(mySchemaVersion);
		 keyspacesMap.put(keySpace, thriftClient.describe_keyspace(keySpace));
	 }
	 catch (InvalidRequestException e) {
		 System.err.println(e.why);
	 }
	 catch (Exception e) {
		 throw new RuntimeException(e.getMessage(), e);
	 }
 }",0,0,0,0
"public class MainActivity extends Activity {
	 private static final String TAG = MainActivity.class.getSimpleName();
	 private static final int REQUEST_ENABLE_BT = 0;
	 private static final int REQUEST_LOCATION = 1;
	 private static final String NEARBY_BEACONS_FRAGMENT_TAG = ""NearbyBeaconsFragmentTag"";
	 private static final String SETTINGS_FRAGMENT_TAG = ""SettingsFragmentTag"";
	 private static final String BLOCKED_URLS_FRAGMENT_TAG = ""BlockedUrlsFragmentTag"";
	 private static final String ABOUT_FRAGMENT_TAG = ""AboutFragmentTag"";
	 private static final String DEMOS_FRAGMENT_TAG = ""DemosFragmentTag"";
	 protected void onCreate(Bundle savedInstanceState) {
		 super.onCreate(savedInstanceState);
		 setContentView(R.layout.activity_main);
		 Utils.setSharedPreferencesDefaultValues(this);
		 PermissionCheck.getInstance().setCheckingPermissions(false);
	 }
	 public boolean onCreateOptionsMenu(Menu menu) {
		 getMenuInflater().inflate(R.menu.main, menu);
		 return true;
	 }
	 public boolean onOptionsItemSelected(MenuItem item) {
		 switch (item.getItemId()) {
			 case R.id.action_about: showAboutFragment();
			 return true;
			 case R.id.action_settings: showSettingsFragment();
			 return true;
			 case R.id.block_settings: showBlockedFragment();
			 return true;
			 case R.id.action_demos: showDemosFragment();
			 return true;
			 case android.R.id.home: getFragmentManager().popBackStack();
			 getActionBar().setDisplayHomeAsUpEnabled(false);
		 }
		 return super.onOptionsItemSelected(item);
	 }
	 private void checkPermissions(BluetoothAdapter bluetoothAdapter) {
		 PermissionCheck.getInstance().setCheckingPermissions(true);
		 if (!bluetoothAdapter.isEnabled()) {
			 Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
			 startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
			 return;
		 }
		 ensureLocationPermissionIsEnabled();
	 }
	 protected void onActivityResult (int requestCode, int resultCode, Intent data) {
		 Log.d(TAG, ""onActivityResult"");
		 if (requestCode == REQUEST_ENABLE_BT && resultCode == -1) {
			 ensureLocationPermissionIsEnabled();
			 return;
		 }
		 Toast.makeText(this, getString(R.string.bt_on), Toast.LENGTH_LONG).show();
		 finish();
	 }
	 private void ensureLocationPermissionIsEnabled() {
		 if (Build.VERSION.SDK_INT >= 23 && ContextCompat.checkSelfPermission(this, android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
			 ActivityCompat.requestPermissions(this, new String[]{
			 android.Manifest.permission.ACCESS_COARSE_LOCATION}
			, REQUEST_LOCATION);
			 return;
		 }
		 PermissionCheck.getInstance().setCheckingPermissions(false);
		 finishLoad();
	 }
	 public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {
		 switch (requestCode) {
			 case REQUEST_LOCATION: {
				 if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
					 PermissionCheck.getInstance().setCheckingPermissions(false);
				 }
				 else {
					 Toast.makeText(getApplicationContext(), getString(R.string.loc_permission), Toast.LENGTH_LONG).show();
					 finish();
				 }
				 break;
			 }
		 default: }
	 }
	 protected void onResume() {
		 super.onResume();
		 if (!PermissionCheck.getInstance().isCheckingPermissions()) {
			 Log.d(TAG, ""resumed MainActivity"");
			 BluetoothManager btManager = (BluetoothManager) getSystemService(BLUETOOTH_SERVICE);
			 BluetoothAdapter btAdapter = btManager != null ? btManager.getAdapter() : null;
			 if (btAdapter == null) {
				 Toast.makeText(getApplicationContext(), R.string.error_bluetooth_support, Toast.LENGTH_LONG).show();
				 finish();
				 return;
			 }
			 if (Utils.checkIfUserHasOptedIn(this)) {
				 Log.d(TAG, ""checkingPermissions"");
				 checkPermissions(btAdapter);
			 }
			 else {
				 Intent intent = new Intent(this, OobActivity.class);
				 startActivity(intent);
			 }
		 }
	 }
	 private void finishLoad() {
		 Intent intent = new Intent(this, ScreenListenerService.class);
		 startService(intent);
		 NearbyBeaconsFragment nearbyBeaconsFragment = (NearbyBeaconsFragment) getFragmentManager().findFragmentByTag(NEARBY_BEACONS_FRAGMENT_TAG);
		 if (nearbyBeaconsFragment != null) {
			 nearbyBeaconsFragment.restartScan();
		 }
		 else {
			 showFragment(new NearbyBeaconsFragment(), NEARBY_BEACONS_FRAGMENT_TAG, false);
		 }
	 }
	 private void showSettingsFragment() {
		 showFragment(new SettingsFragment(), SETTINGS_FRAGMENT_TAG, true);
	 }
	 private void showAboutFragment() {
		 showFragment(new AboutFragment(), ABOUT_FRAGMENT_TAG, true);
	 }
	 private void showBlockedFragment() {
		 showFragment(new BlockedFragment(), BLOCKED_URLS_FRAGMENT_TAG, true);
	 }
	 private void showDemosFragment() {
		 showFragment(new DemosFragment(), DEMOS_FRAGMENT_TAG, true);
	 }
	 private void showFragment(Fragment newFragment, String fragmentTag, boolean addToBackStack) {
		 FragmentTransaction transaction = getFragmentManager().beginTransaction() .setCustomAnimations( R.animator.fade_in_and_slide_up_fragment, R.animator.fade_out_fragment, R.animator.fade_in_activity, R.animator.fade_out_fragment) .replace(R.id.main_activity_container, newFragment, fragmentTag);
		 if (addToBackStack) {
			 transaction.addToBackStack(null);
		 }
		 transaction.commit();
	 }
}",1,0,0,0
"public void dataChanged() {
	if (m_model.getSkeletonName() == null) {
		m_currentSkelName = null;
		rebuildProperties();
	 }
	if ((m_model != null) && (m_model.getSkeletonName() != null) && (!m_model.getSkeletonName().equalsIgnoreCase(m_currentSkelName))) {
		m_currentSkelName = m_model.getSkeletonName();
		rebuildProperties();
	 }
	JSmoothModelBean.Property[] jsprop = m_model.getSkeletonProperties();
	if (jsprop != null) {
		for (Enumeration e=m_editors.elements();
		 e.hasMoreElements();
		 ) {
			SkelPropEditor spe = (SkelPropEditor)e.nextElement();
			JSmoothModelBean.Property p = getPropertyInstance(spe.getIdName());
			if (p != null) spe.valueChanged(p.getValue());
		 }
	 }
	else {
		 SkeletonBean skel = Main.SKELETONS.getSkeleton( m_model.getSkeletonName() );
		SkeletonProperty[] sprops = null;
		if (skel != null) sprops = skel.getSkeletonProperties();
		if (sprops != null) {
			for (Enumeration e=m_editors.elements();
			 e.hasMoreElements();
			 ) {
				SkelPropEditor spe = (SkelPropEditor)e.nextElement();
				for (int i=0;
				 i<sprops.length;
				 i++) {
					if (sprops[i].getIdName().equals(spe.getIdName())) spe.valueChanged(sprops[i].getValue());
				 }
			 }
		 }
	 }
 }",0,0,1,0
"public class GatewayDeltaCreateEvent extends AbstractGatewayDeltaEvent {
	 private byte[] gatewayDelta;
	 public GatewayDeltaCreateEvent() {
	}
	 public GatewayDeltaCreateEvent(String regionName, String key, byte[] gatewayDelta) {
		 super(regionName, key);
		 this.gatewayDelta = gatewayDelta;
	 }
	 public byte[] getGatewayDelta() {
		 return this.gatewayDelta;
	 }
	 public void apply(Cache cache) {
		 Region<String, CachedDeserializable> region = getRegion(cache);
		 region.put(this.key, CachedDeserializableFactory.create(this.gatewayDelta, (InternalCache) cache), true);
		 if (cache.getLogger().fineEnabled()) {
			 StringBuilder builder = new StringBuilder();
			 builder.append(""Applied "").append(this);
			 cache.getLogger().fine(builder.toString());
		 }
	 }
	 public void fromData(DataInput in) throws IOException, ClassNotFoundException {
		 super.fromData(in);
		 this.gatewayDelta = DataSerializer.readByteArray(in);
	 }
	 public void toData(DataOutput out) throws IOException {
		 super.toData(out);
		 DataSerializer.writeByteArray(this.gatewayDelta, out);
	 }
	 public String toString() {
		 return new StringBuilder().append(""GatewayDeltaCreateEvent["").append(""regionName="") .append(this.regionName).append("";
		 key="").append(this.key).append("";
		 gatewayDelta="") .append(Arrays.toString(this.gatewayDelta)).append(""]"").toString();
	 }
}",0,0,0,0
"public class EnumerableProjectToCalcRule extends RelOptRule {
	 public EnumerableProjectToCalcRule(RelBuilderFactory relBuilderFactory) {
		 super(operand(EnumerableProject.class, any()), relBuilderFactory, null);
	 }
	 public void onMatch(RelOptRuleCall call) {
		 final EnumerableProject project = call.rel(0);
		 final RelNode input = project.getInput();
		 final RexProgram program = RexProgram.create(input.getRowType(), project.getProjects(), null, project.getRowType(), project.getCluster().getRexBuilder());
		 final EnumerableCalc calc = EnumerableCalc.create(input, program);
		 call.transformTo(calc);
	 }
}",0,0,0,0
"public class ObjectInFolderListImpl extends AbstractExtensionData implements ObjectInFolderList {
	 private static final long serialVersionUID = 1L;
	 private List<ObjectInFolderData> objects;
	 private Boolean hasMoreItems = Boolean.FALSE;
	 private BigInteger numItems;
	 public List<ObjectInFolderData> getObjects() {
		 if (objects == null) {
			 objects = new ArrayList<ObjectInFolderData>(0);
		 }
		 return objects;
	 }
	 public void setObjects(List<ObjectInFolderData> objects) {
		 this.objects = objects;
	 }
	 public Boolean hasMoreItems() {
		 return hasMoreItems;
	 }
	 public void setHasMoreItems(Boolean hasMoreItems) {
		 this.hasMoreItems = hasMoreItems;
	 }
	 public BigInteger getNumItems() {
		 return numItems;
	 }
	 public void setNumItems(BigInteger numItems) {
		 this.numItems = numItems;
	 }
	 public String toString() {
		 return ""ObjectInFolder List [objects="" + objects + "", has more items="" + hasMoreItems + "", num items="" + numItems + ""]"" + super.toString();
	 }
}",0,1,0,0
"final class WebsocketFinalizer extends HttpClient implements HttpClient.WebsocketSender {
	final TcpClient cachedConfiguration;
	WebsocketFinalizer(TcpClient parent) {
		this.cachedConfiguration = parent;
	}
	public WebsocketSender uri(String uri) {
		return new WebsocketFinalizer(cachedConfiguration.bootstrap(b -> HttpClientConfiguration.uri(b, uri)));
	}
	public WebsocketSender uri(Mono<String> uri) {
		return new WebsocketFinalizer(cachedConfiguration.bootstrap(b -> HttpClientConfiguration.deferredConf(b, conf -> uri.map(conf::uri))));
	}
	public WebsocketFinalizer send(Function<? super HttpClientRequest, ? extends Publisher<Void>> sender) {
		Objects.requireNonNull(sender, ""requestBody"");
		return new WebsocketFinalizer(cachedConfiguration.bootstrap(b -> HttpClientConfiguration.body(b, (req, out) -> sender.apply(req))));
	}
	public Mono<WebsocketClientOperations> connect() {
		return (Mono<WebsocketClientOperations>)cachedConfiguration.connect();
	}
	public ByteBufFlux receive() {
		return HttpClientFinalizer.content(cachedConfiguration, HttpClientFinalizer.contentReceiver);
	}
	public <V> Flux<V> handle(BiFunction<? super WebsocketInbound, ? super WebsocketOutbound, ? extends Publisher<V>> receiver) {
		return connect().flatMapMany(c -> Flux.from(receiver.apply(c, c)) .doFinally(s -> HttpClientFinalizer.discard(c)));
	}
}",0,0,0,0
"final ElemContext push( final String uri, final String localName, final String qName);",0,0,0,1
"public ResIcon(Image img) throws Exception {
	int width = img.getWidth(null);
	int height = img.getHeight(null);
	if ((width % 8) != 0) width += (7-(width%8));
	if ((height % 8) != 0) height += (7-(height%8));
	if (img instanceof BufferedImage) {
		BufferedImage result = (BufferedImage)img;
		for (int y=0;
		 y<result.getHeight();
		 y++) {
			for (int x=0;
			 x<result.getWidth();
			 x++) {
				int rgb = result.getRGB(x, y);
				if (((rgb>>24)&0xFF)>0) {
				 }
			 }
		 }
	 }
	int[] pixelbuffer = new int[width*height];
	PixelGrabber grabber = new PixelGrabber(img, 0, 0, width, height, pixelbuffer, 0, width);
	try {
		grabber.grabPixels();
	 }
	 catch (InterruptedException e){
		 System.err.println(""interrupted waiting for pixels!"");
		 throw new Exception(""Can't load the image provided"",e);
	}
	Hashtable colors = calculateColorCount(pixelbuffer);
	this.BitsPerPixel = 8;
	Palette = new ResIcon.PaletteElement[1 << BitsPerPixel];
	for (Enumeration e=colors.keys();
	 e.hasMoreElements();
	 ) {
		Integer pixi = (Integer)e.nextElement();
		int pix = pixi.intValue();
		int index = ((Integer)colors.get(pixi)).intValue();
		Palette[index] = new ResIcon.PaletteElement();
		Palette[index].Blue = pix & 0xFF;
		Palette[index].Green = (pix >> 8) & 0xff;
		Palette[index].Red = (pix >> 16) & 0xff;
	 }
	for (int i=0;
	 i<Palette.length;
	 i++) {
		if (Palette[i] == null) Palette[i] = new ResIcon.PaletteElement();
	 }
	this.Size = 40;
	this.Width = width;
	this.Height = height* 2;
	this.Planes = 1;
	this.Compression = 0;
	this.SizeOfBitmap = 0;
	this.HorzResolution = 0;
	this.VertResolution = 0;
	this.ColorsUsed = 0;
	this.ColorsImportant = 0;
	int rowsize = width / 8;
	if ((rowsize%4)>0) {
		rowsize += 4 - (rowsize%4);
	 }
	BitmapXOR = new short[(((int)Height/2) * (int)Width * (int)BitsPerPixel) / 8];
	BitmapAND = new short[((int)Height/2) * rowsize];
	int bxl = BitmapXOR.length-1;
	int bal = BitmapAND.length-1;
	for (int i=0;
	 i<pixelbuffer.length;
	 i++) {
		int col = i%width;
		int line = i/width;
		bxl = (width * height) - (((i/width)+1)*width) + (i%width);
		bal = (rowsize * height) - ((line+1)*(rowsize)) + (col/8);
		if ( (((pixelbuffer[i]>>24)& 0xFF) == 0)) {
			BitmapAND[ bal ] |= 1 << (7-(i%8));
			BitmapXOR[bxl] = 0xFF;
		 }
		else {
			int pixel = pixelbuffer[i] & 0x00FFFFFF;
			Integer icol = (Integer)colors.get(new Integer(pixel));
			if (icol != null) {
				int palindex = icol.intValue();
				BitmapXOR[bxl] = (short)palindex;
			 }
		 }
	 }
 }",0,0,1,0
"public Token.TokenFactory<byte[]> getTokenFactory() {
	 return tokenFactory;
 }",0,0,0,0
"public final class MetricsFactory {
	 private static final UtilCache<String, Metrics> METRICS_CACHE = UtilCache.createUtilCache(""base.metrics"", 0, 0);
	 public static final Metrics NULL_METRICS = new NullMetrics();
	 public static Metrics getInstance(Element element) {
		 Assert.notNull(""element"", element);
		 String name = element.getAttribute(""name"");
		 Assert.notEmpty(""name attribute"", name);
		 Metrics result = METRICS_CACHE.get(name);
		 if (result == null) {
			 int estimationSize = UtilProperties.getPropertyAsInteger(""serverstats"", ""metrics.estimation.size"", 100);
			 String attributeValue = element.getAttribute(""estimation-size"");
			 if (!attributeValue.isEmpty()) {
				 estimationSize = Integer.parseInt(attributeValue);
			 }
			 long estimationTime = UtilProperties.getPropertyAsLong(""serverstats"", ""metrics.estimation.time"", 1000);
			 attributeValue = element.getAttribute(""estimation-time"");
			 if (!attributeValue.isEmpty()) {
				 estimationTime = Long.parseLong(attributeValue);
			 }
			 double smoothing = UtilProperties.getPropertyNumber(""serverstats"", ""metrics.smoothing.factor"", 0.7);
			 attributeValue = element.getAttribute(""smoothing"");
			 if (!attributeValue.isEmpty()) {
				 smoothing = Double.parseDouble(attributeValue);
			 }
			 double threshold = 0.0;
			 attributeValue = element.getAttribute(""threshold"");
			 if (!attributeValue.isEmpty()) {
				 threshold = Double.parseDouble(attributeValue);
			 }
			 result = new MetricsImpl(name, estimationSize, estimationTime, smoothing, threshold);
			 METRICS_CACHE.putIfAbsent(name, result);
			 result = METRICS_CACHE.get(name);
		 }
		 return result;
	 }
	 public static Metrics getInstance(String name, int estimationSize, long estimationTime, double smoothing, double threshold) {
		 Assert.notNull(""name"", name);
		 Metrics result = METRICS_CACHE.get(name);
		 if (result == null) {
			 result = new MetricsImpl(name, estimationSize, estimationTime, smoothing, threshold);
			 METRICS_CACHE.putIfAbsent(name, result);
			 result = METRICS_CACHE.get(name);
		 }
		 return result;
	 }
	 public static Metrics getMetric(String name) {
		 Assert.notNull(""name"", name);
		 return METRICS_CACHE.get(name);
	 }
	 public static Collection<Metrics> getMetrics() {
		 return new TreeSet<Metrics>(METRICS_CACHE.values());
	 }
	 private static final class MetricsImpl implements Metrics, Comparable<Metrics> {
		 private int count = 0;
		 private long lastTime = System.currentTimeMillis();
		 private double serviceRate = 0.0;
		 private long totalServiceTime = 0;
		 private long totalEvents = 0;
		 private long cumulativeEvents = 0;
		 private final String name;
		 private final int estimationSize;
		 private final long estimationTime;
		 private final double smoothing;
		 private final double threshold;
		 private MetricsImpl(String name, int estimationSize, long estimationTime, double smoothing, double threshold) {
			 this.name = name;
			 this.estimationSize = estimationSize;
			 this.estimationTime = estimationTime;
			 this.smoothing = smoothing;
			 this.threshold = threshold;
		 }
		 public int compareTo(Metrics other) {
			 return this.name.compareTo(other.getName());
		 }
		 public boolean equals(Object obj) {
			 if (obj == this) {
				 return true;
			 }
			 try {
				 MetricsImpl that = (MetricsImpl) obj;
				 return this.name.equals(that.name);
			 }
			 catch (Exception e) {
			}
			 return false;
		 }
		 public String getName() {
			 return name;
		 }
		 public synchronized double getServiceRate() {
			 return serviceRate;
		 }
		 public double getThreshold() {
			 return threshold;
		 }
		 public synchronized long getTotalEvents() {
			 return cumulativeEvents;
		 }
		 public int hashCode() {
			 return name.hashCode();
		 }
		 public synchronized void recordServiceRate(int numEvents, long time) {
			 totalEvents += numEvents;
			 cumulativeEvents += numEvents;
			 totalServiceTime += time;
			 count++;
			 long curTime = System.currentTimeMillis();
			 if ((count == estimationSize) || (curTime - lastTime >= estimationTime)) {
				 if (totalEvents == 0) {
					 totalEvents = 1;
				 }
				 double rate = totalServiceTime / totalEvents;
				 serviceRate = (rate * smoothing) + (serviceRate * (1.0 - smoothing));
				 count = 0;
				 lastTime = curTime;
				 totalEvents = totalServiceTime = 0;
			 }
		 }
		 public synchronized void reset() {
			 serviceRate = 0.0;
			 count = 0;
			 lastTime = System.currentTimeMillis();
			 totalEvents = totalServiceTime = cumulativeEvents = 0;
		 }
		 public String toString() {
			 return name;
		 }
	 }
	 private static final class NullMetrics implements Metrics {
		 public String getName() {
			 return ""NULL"";
		 }
		 public double getServiceRate() {
			 return 0;
		 }
		 public double getThreshold() {
			 return 0.0;
		 }
		 public long getTotalEvents() {
			 return 0;
		 }
		 public void recordServiceRate(int numEvents, long time) {
		 }
		 public void reset() {
		 }
	 }
	 private MetricsFactory() {
	}
}",1,1,0,0
"public class ByteBufferUtil{
	 public static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.wrap(ArrayUtils.EMPTY_BYTE_ARRAY);
	 public static int compareUnsigned(ByteBuffer o1, ByteBuffer o2) {
		 assert o1 != null;
		 assert o2 != null;
		 if (o1 == o2) return 0;
		 if (o1.hasArray() && o2.hasArray()) {
			 return FBUtilities.compareUnsigned(o1.array(), o2.array(), o1.position() + o1.arrayOffset(), o2.position() + o2.arrayOffset(), o1.remaining(), o2.remaining());
		 }
		 int end1 = o1.position() + o1.remaining();
		 int end2 = o2.position() + o2.remaining();
		 for (int i = o1.position(), j = o2.position();
		 i < end1 && j < end2;
		 i++, j++) {
			 int a = (o1.get(i) & 0xff);
			 int b = (o2.get(j) & 0xff);
			 if (a != b) return a - b;
		 }
		 return o1.remaining() - o2.remaining();
	 }
	 public static int compare(byte[] o1, ByteBuffer o2) {
		 return compareUnsigned(ByteBuffer.wrap(o1), o2);
	 }
	 public static int compare(ByteBuffer o1, byte[] o2) {
		 return compareUnsigned(o1, ByteBuffer.wrap(o2));
	 }
	 public static String string(ByteBuffer buffer) throws CharacterCodingException {
		 return string(buffer, UTF_8);
	 }
	 public static String string(ByteBuffer buffer, int position, int length) throws CharacterCodingException {
		 return string(buffer, position, length, UTF_8);
	 }
	 public static String string(ByteBuffer buffer, int position, int length, Charset charset) throws CharacterCodingException {
		 ByteBuffer copy = buffer.duplicate();
		 copy.position(position);
		 copy.limit(copy.position() + length);
		 return string(copy, charset);
	 }
	 public static String string(ByteBuffer buffer, Charset charset) throws CharacterCodingException {
		 return charset.newDecoder().decode(buffer.duplicate()).toString();
	 }
	 public static byte[] getArray(ByteBuffer buffer) {
		 int length = buffer.remaining();
		 if (buffer.hasArray()) {
			 int boff = buffer.arrayOffset() + buffer.position();
			 if (boff == 0 && length == buffer.array().length) return buffer.array();
			 else return Arrays.copyOfRange(buffer.array(), boff, boff + length);
		 }
		 byte[] bytes = new byte[length];
		 buffer.duplicate().get(bytes);
		 return bytes;
	 }
	 public static int lastIndexOf(ByteBuffer buffer, byte valueToFind, int startIndex) {
		 assert buffer != null;
		 if (startIndex < buffer.position()) {
			 return -1;
		 }
		 else if (startIndex >= buffer.limit()) {
			 startIndex = buffer.limit() - 1;
		 }
		 for (int i = startIndex;
		 i >= buffer.position();
		 i--) {
			 if (valueToFind == buffer.get(i)) return i;
		 }
		 return -1;
	 }
	 public static ByteBuffer bytes(String s) {
		 return ByteBuffer.wrap(s.getBytes(UTF_8));
	 }
	 public static ByteBuffer bytes(String s, Charset charset) {
		 return ByteBuffer.wrap(s.getBytes(charset));
	 }
	 public static ByteBuffer clone(ByteBuffer buffer) {
		 assert buffer != null;
		 if (buffer.remaining() == 0) return EMPTY_BYTE_BUFFER;
		 ByteBuffer clone = ByteBuffer.allocate(buffer.remaining());
		 if (buffer.hasArray()) {
			 System.arraycopy(buffer.array(), buffer.arrayOffset() + buffer.position(), clone.array(), 0, buffer.remaining());
		 }
		 else {
			 clone.put(buffer.duplicate());
			 clone.flip();
		 }
		 return clone;
	 }
	 public static void arrayCopy(ByteBuffer buffer, int position, byte[] bytes, int offset, int length) {
		 if (buffer.hasArray()) System.arraycopy(buffer.array(), buffer.arrayOffset() + position, bytes, offset, length);
		 else ((ByteBuffer) buffer.duplicate().position(position)).get(bytes, offset, length);
	 }
	 public static void arrayCopy(ByteBuffer src, int srcPos, ByteBuffer dst, int dstPos, int length) {
		 if (src.hasArray() && dst.hasArray()) {
			 System.arraycopy(src.array(), src.arrayOffset() + srcPos, dst.array(), dst.arrayOffset() + dstPos, length);
		 }
		 else {
			 if (src.limit() - srcPos < length || dst.limit() - dstPos < length) throw new IndexOutOfBoundsException();
			 for (int i = 0;
			 i < length;
			 i++) dst.put(dstPos++, src.get(srcPos++));
		 }
	 }
	 public static void writeWithLength(ByteBuffer bytes, DataOutput out) throws IOException {
		 out.writeInt(bytes.remaining());
		 write(bytes, out);
	 }
	 public static void write(ByteBuffer buffer, DataOutput out) throws IOException {
		 if (buffer.hasArray()) {
			 out.write(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());
		 }
		 else {
			 for (int i = buffer.position();
			 i < buffer.limit();
			 i++) {
				 out.writeByte(buffer.get(i));
			 }
		 }
	 }
	 public static void writeWithShortLength(ByteBuffer buffer, DataOutput out) {
		 int length = buffer.remaining();
		 assert 0 <= length && length <= FBUtilities.MAX_UNSIGNED_SHORT : length;
		 try {
			 out.writeByte((length >> 8) & 0xFF);
			 out.writeByte(length & 0xFF);
			 write(buffer, out);
		 }
		 catch (IOException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public static ByteBuffer readWithLength(DataInput in) throws IOException {
		 int length = in.readInt();
		 if (length < 0) {
			 throw new IOException(""Corrupt (negative) value length encountered"");
		 }
		 return ByteBufferUtil.read(in, length);
	 }
	 public static int readShortLength(DataInput in) throws IOException {
		 int length = (in.readByte() & 0xFF) << 8;
		 return length | (in.readByte() & 0xFF);
	 }
	 public static ByteBuffer readWithShortLength(DataInput in) throws IOException {
		 return ByteBufferUtil.read(in, readShortLength(in));
	 }
	 public static ByteBuffer skipShortLength(DataInput in) throws IOException {
		 int skip = readShortLength(in);
		 FileUtils.skipBytesFully(in, skip);
		 return null;
	 }
	 public static ByteBuffer read(DataInput in, int length) throws IOException {
		 if (in instanceof FileDataInput) return ((FileDataInput) in).readBytes(length);
		 byte[] buff = new byte[length];
		 in.readFully(buff);
		 return ByteBuffer.wrap(buff);
	 }
	 public static int toInt(ByteBuffer bytes) {
		 return bytes.getInt(bytes.position());
	 }
	 public static long toLong(ByteBuffer bytes) {
		 return bytes.getLong(bytes.position());
	 }
	 public static float toFloat(ByteBuffer bytes) {
		 return bytes.getFloat(bytes.position());
	 }
	 public static double toDouble(ByteBuffer bytes) {
		 return bytes.getDouble(bytes.position());
	 }
	 public static ByteBuffer bytes(int i) {
		 return ByteBuffer.allocate(4).putInt(0, i);
	 }
	 public static ByteBuffer bytes(long n) {
		 return ByteBuffer.allocate(8).putLong(0, n);
	 }
	 public static ByteBuffer bytes(float f) {
		 return ByteBuffer.allocate(4).putFloat(0, f);
	 }
	 public static ByteBuffer bytes(double d) {
		 return ByteBuffer.allocate(8).putDouble(0, d);
	 }
	 public static InputStream inputStream(ByteBuffer bytes) {
		 final ByteBuffer copy = bytes.duplicate();
		 return new InputStream() {
			 public int read() throws IOException {
				 if (!copy.hasRemaining()) return -1;
				 return copy.get() & 0xFF;
			 }
			 public int read(byte[] bytes, int off, int len) throws IOException {
				 if (!copy.hasRemaining()) return -1;
				 len = Math.min(len, copy.remaining());
				 copy.get(bytes, off, len);
				 return len;
			 }
			 public int available() throws IOException {
				 return copy.remaining();
			 }
		 }
		;
	 }
	 public static String bytesToHex(ByteBuffer bytes) {
		 final int offset = bytes.position();
		 final int size = bytes.remaining();
		 final char[] c = new char[size * 2];
		 for (int i = 0;
		 i < size;
		 i++) {
			 final int bint = bytes.get(i+offset);
			 c[i * 2] = Hex.byteToChar[(bint & 0xf0) >> 4];
			 c[1 + i * 2] = Hex.byteToChar[bint & 0x0f];
		 }
		 return Hex.wrapCharArray(c);
	 }
	 public static ByteBuffer hexToBytes(String str) {
		 return ByteBuffer.wrap(Hex.hexToBytes(str));
	 }
	 public static int compareSubArrays(ByteBuffer bytes1, int offset1, ByteBuffer bytes2, int offset2, int length) {
		 if ( null == bytes1 ) {
			 if ( null == bytes2) return 0;
			 else return -1;
		 }
		 if (null == bytes2 ) return 1;
		 assert bytes1.limit() >= offset1 + length : ""The first byte array isn't long enough for the specified offset and length."";
		 assert bytes2.limit() >= offset2 + length : ""The second byte array isn't long enough for the specified offset and length."";
		 for ( int i = 0;
		 i < length;
		 i++ ) {
			 byte byte1 = bytes1.get(offset1 + i);
			 byte byte2 = bytes2.get(offset2 + i);
			 if ( byte1 == byte2 ) continue;
			 return (byte1 & 0xFF) < (byte2 & 0xFF) ? -1 : 1;
		 }
		 return 0;
	 }
}",0,0,0,0
"public final class ShortSerializer extends TypeSerializerSingleton<Short> {
	private static final long serialVersionUID = 1L;
	public static final ShortSerializer INSTANCE = new ShortSerializer();
	private static final Short ZERO = (short) 0;
	public boolean isImmutableType() {
		return true;
	}
	public Short createInstance() {
		return ZERO;
	}
	public Short copy(Short from) {
		return from;
	}
	public Short copy(Short from, Short reuse) {
		return from;
	}
	public int getLength() {
		return 2;
	}
	public void serialize(Short record, DataOutputView target) throws IOException {
		target.writeShort(record);
	}
	public Short deserialize(DataInputView source) throws IOException {
		return source.readShort();
	}
	public Short deserialize(Short reuse, DataInputView source) throws IOException {
		return deserialize(source);
	}
	public void copy(DataInputView source, DataOutputView target) throws IOException {
		target.writeShort(source.readShort());
	}
	public TypeSerializerSnapshot<Short> snapshotConfiguration() {
		return new ShortSerializerSnapshot();
	}
	public static final class ShortSerializerSnapshot extends SimpleTypeSerializerSnapshot<Short> {
		public ShortSerializerSnapshot() {
			super(() -> INSTANCE);
		}
	}
}",0,1,0,0
"public static boolean isIndexBuilt(String table, String indexName) {
	 ColumnFamilyStore cfs = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(INDEX_CF);
	 QueryFilter filter = QueryFilter.getNamesFilter(decorate(ByteBufferUtil.bytes(table)), new QueryPath(INDEX_CF), ByteBufferUtil.bytes(indexName));
	 return ColumnFamilyStore.removeDeleted(cfs.getColumnFamily(filter), Integer.MAX_VALUE) != null;
 }",0,0,0,0
"public class TupleImpl extends IndifferentAccessMap implements Seqable, Indexed, IMeta, Tuple {
	 private List<Object> values;
	 private int taskId;
	 private String streamId;
	 private GeneralTopologyContext context;
	 private MessageId id;
	 private IPersistentMap _meta = null;
	 Long _processSampleStartTime = null;
	 Long _executeSampleStartTime = null;
	 long _outAckVal = 0;
	 public TupleImpl() {
	 }
	 public TupleImpl(GeneralTopologyContext context, List<Object> values, int taskId, String streamId, MessageId id) {
		 this.values = values;
		 this.taskId = taskId;
		 this.streamId = streamId;
		 this.id = id;
		 this.context = context;
	 }
	 public TupleImpl(GeneralTopologyContext context, List<Object> values, int taskId, String streamId) {
		 this(context, values, taskId, streamId, MessageId.makeUnanchored());
	 }
	 public void setProcessSampleStartTime(long ms) {
		 _processSampleStartTime = ms;
	 }
	 public Long getProcessSampleStartTime() {
		 return _processSampleStartTime;
	 }
	 public void setExecuteSampleStartTime(long ms) {
		 _executeSampleStartTime = ms;
	 }
	 public Long getExecuteSampleStartTime() {
		 return _executeSampleStartTime;
	 }
	 public void updateAckVal(long val) {
		 _outAckVal = _outAckVal ^ val;
	 }
	 public long getAckVal() {
		 return _outAckVal;
	 }
	 public int size() {
		 return values.size();
	 }
	 public int fieldIndex(String field) {
		 return getFields().fieldIndex(field);
	 }
	 public boolean contains(String field) {
		 return getFields().contains(field);
	 }
	 public Object getValue(int i) {
		 return values.get(i);
	 }
	 public String getString(int i) {
		 return (String) values.get(i);
	 }
	 public Integer getInteger(int i) {
		 return (Integer) values.get(i);
	 }
	 public Long getLong(int i) {
		 return (Long) values.get(i);
	 }
	 public Boolean getBoolean(int i) {
		 return (Boolean) values.get(i);
	 }
	 public Short getShort(int i) {
		 return (Short) values.get(i);
	 }
	 public Byte getByte(int i) {
		 return (Byte) values.get(i);
	 }
	 public Double getDouble(int i) {
		 return (Double) values.get(i);
	 }
	 public Float getFloat(int i) {
		 return (Float) values.get(i);
	 }
	 public byte[] getBinary(int i) {
		 return (byte[]) values.get(i);
	 }
	 public Object getValueByField(String field) {
		 return values.get(fieldIndex(field));
	 }
	 public String getStringByField(String field) {
		 return (String) values.get(fieldIndex(field));
	 }
	 public Integer getIntegerByField(String field) {
		 return (Integer) values.get(fieldIndex(field));
	 }
	 public Long getLongByField(String field) {
		 return (Long) values.get(fieldIndex(field));
	 }
	 public Boolean getBooleanByField(String field) {
		 return (Boolean) values.get(fieldIndex(field));
	 }
	 public Short getShortByField(String field) {
		 return (Short) values.get(fieldIndex(field));
	 }
	 public Byte getByteByField(String field) {
		 return (Byte) values.get(fieldIndex(field));
	 }
	 public Double getDoubleByField(String field) {
		 return (Double) values.get(fieldIndex(field));
	 }
	 public Float getFloatByField(String field) {
		 return (Float) values.get(fieldIndex(field));
	 }
	 public byte[] getBinaryByField(String field) {
		 return (byte[]) values.get(fieldIndex(field));
	 }
	 public List<Object> getValues() {
		 return values;
	 }
	 public Fields getFields() {
		 return context.getComponentOutputFields(getSourceComponent(), getSourceStreamId());
	 }
	 public List<Object> select(Fields selector) {
		 return getFields().select(selector, values);
	 }
	 public GlobalStreamId getSourceGlobalStreamid() {
		 return new GlobalStreamId(getSourceComponent(), streamId);
	 }
	 public String getSourceComponent() {
		 return context.getComponentId(taskId);
	 }
	 public int getSourceTask() {
		 return taskId;
	 }
	 public String getSourceStreamId() {
		 return streamId;
	 }
	 public MessageId getMessageId() {
		 return id;
	 }
	 public String toString() {
		 return ""source: "" + getSourceComponent() + "":"" + taskId + "", stream: "" + streamId + "", id: "" + id.toString() + "", "" + values.toString();
	 }
	 public boolean equals(Object other) {
		 return this == other;
	 }
	 public int hashCode() {
		 return System.identityHashCode(this);
	 }
	 private Keyword makeKeyword(String name) {
		 return Keyword.intern(Symbol.create(name));
	 }
	 public Object valAt(Object o) {
		 try {
			 if (o instanceof Keyword) {
				 return getValueByField(((Keyword) o).getName());
			 }
			 else if (o instanceof String) {
				 return getValueByField((String) o);
			 }
		 }
		 catch (IllegalArgumentException ignored) {
		 }
		 return null;
	 }
	 public ISeq seq() {
		 if (values.size() > 0) {
			 return new Seq(getFields().toList(), values, 0);
		 }
		 return null;
	 }
	 static class Seq extends ASeq implements Counted {
		 final List<String> fields;
		 final List<Object> values;
		 final int i;
		 Seq(List<String> fields, List<Object> values, int i) {
			 this.fields = fields;
			 this.values = values;
			 assert i >= 0;
			 this.i = i;
		 }
		 public Seq(IPersistentMap meta, List<String> fields, List<Object> values, int i) {
			 super(meta);
			 this.fields = fields;
			 this.values = values;
			 assert i >= 0;
			 this.i = i;
		 }
		 public Object first() {
			 return new MapEntry(fields.get(i), values.get(i));
		 }
		 public ISeq next() {
			 if (i + 1 < fields.size()) {
				 return new Seq(fields, values, i + 1);
			 }
			 return null;
		 }
		 public int count() {
			 assert fields.size() - i >= 0 : ""index out of bounds"";
			 return fields.size() - i;
		 }
		 public Obj withMeta(IPersistentMap meta) {
			 return new Seq(meta, fields, values, i);
		 }
	 }
	 public Object nth(int i) {
		 if (i < values.size()) {
			 return values.get(i);
		 }
		 else {
			 return null;
		 }
	 }
	 public Object nth(int i, Object notfound) {
		 Object ret = nth(i);
		 if (ret == null) ret = notfound;
		 return ret;
	 }
	 public int count() {
		 return values.size();
	 }
	 public IPersistentMap meta() {
		 if (_meta == null) {
			 _meta = new PersistentArrayMap(new Object[]{
			makeKeyword(""stream""), getSourceStreamId(), makeKeyword(""component""), getSourceComponent(), makeKeyword(""task""), getSourceTask()}
			);
		 }
		 return _meta;
	 }
	 private PersistentArrayMap toMap() {
		 Object array[] = new Object[values.size() * 2];
		 List<String> fields = getFields().toList();
		 for (int i = 0;
		 i < values.size();
		 i++) {
			 array[i * 2] = fields.get(i);
			 array[(i * 2) + 1] = values.get(i);
		 }
		 return new PersistentArrayMap(array);
	 }
	 public IPersistentMap getMap() {
		 if (_map == null) {
			 setMap(toMap());
		 }
		 return _map;
	 }
	 public void setTopologyContext(GeneralTopologyContext context) {
		 this.context = context;
	 }
	 public GeneralTopologyContext getTopologyContext() {
		 return context;
	 }
}",1,1,0,0
"public class CreditBureauData {
	private final long creditBureauId;
	private final String creditBureauName;
	private final String country;
	private final String productName;
	private final String creditBureauSummary;
	private final long implementationKey;
	private CreditBureauData(final long creditBureauId, final String creditBureauName, final String country,final String productName, final String creditBureauSummary, final long implementationKey) {
		this.creditBureauId = creditBureauId;
		this.creditBureauName = creditBureauName;
		this.country = country;
		this.productName = productName;
		this.creditBureauSummary = creditBureauSummary;
		this.implementationKey = implementationKey;
	}
	public static CreditBureauData instance(final long creditBureauId, final String creditBureauName,final String country, final String productName, final String creditBureauSummary, final long implementationKey) {
		return new CreditBureauData(creditBureauId, creditBureauName, country, productName, creditBureauSummary,implementationKey);
	}
	public String getCreditBureauSummary() {
		return this.creditBureauSummary;
	}
	public long getCreditBureauId() {
		return this.creditBureauId;
	}
	public String getCreditBureauName() {
		return this.creditBureauName;
	}
	public String getCountry() {
		return this.country;
	}
	public String getProductName() {
		return this.productName;
	}
	public long getImplementationKey() {
		return this.implementationKey;
	}
}",0,1,0,0
"public class Scale extends TransformOperation implements DrawOperation {
	 private static final int HUNDRED = 100;
	 private String widthStr = ""100%"";
	 private String heightStr = ""100%"";
	 private boolean xPercent = true;
	 private boolean yPercent = true;
	 private String proportions = ""ignore"";
	 public static class ProportionsAttribute extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""ignore"", ""width"", ""height"", ""cover"", ""fit""}
			;
		 }
	 }
	 public void setProportions(ProportionsAttribute pa) {
		 proportions = pa.getValue();
	 }
	 public void setWidth(String width) {
		 widthStr = width;
	 }
	 public void setHeight(String height) {
		 heightStr = height;
	 }
	 public float getWidth() {
		 float width = 0.0F;
		 int percIndex = widthStr.indexOf('%');
		 if (percIndex > 0) {
			 width = Float.parseFloat(widthStr.substring(0, percIndex));
			 xPercent = true;
			 return width / HUNDRED;
		 }
		 else {
			 xPercent = false;
			 return Float.parseFloat(widthStr);
		 }
	 }
	 public float getHeight() {
		 int percIndex = heightStr.indexOf('%');
		 if (percIndex > 0) {
			 float height = Float.parseFloat(heightStr.substring(0, percIndex));
			 yPercent = true;
			 return height / HUNDRED;
		 }
		 else {
			 yPercent = false;
			 return Float.parseFloat(heightStr);
		 }
	 }
	 public PlanarImage performScale(PlanarImage image) {
		 ParameterBlock pb = new ParameterBlock();
		 pb.addSource(image);
		 float xFl = getWidth();
		 float yFl = getHeight();
		 if (!xPercent) {
			 xFl = (xFl / image.getWidth());
		 }
		 if (!yPercent) {
			 yFl = (yFl / image.getHeight());
		 }
		 if (""width"".equals(proportions)) {
			 yFl = xFl;
		 }
		 else if (""height"".equals(proportions)) {
			 xFl = yFl;
		 }
		 else if (""fit"".equals(proportions)) {
			 yFl = Math.min(xFl, yFl);
			 xFl = yFl;
		 }
		 else if (""cover"".equals(proportions)) {
			 yFl = Math.max(xFl, yFl);
			 xFl = yFl;
		 }
		 pb.add(new Float(xFl));
		 pb.add(new Float(yFl));
		 log(""\tScaling to "" + (xFl * HUNDRED) + ""% x "" + (yFl * HUNDRED) + ""%"");
		 return JAI.create(""scale"", pb);
	 }
	 public PlanarImage executeTransformOperation(PlanarImage image) {
		 BufferedImage bi = null;
		 final int size = instructions.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
			 if (instr instanceof DrawOperation) {
				 return performScale(image);
			 }
			 else if (instr instanceof TransformOperation) {
				 bi = image.getAsBufferedImage();
				 image = ((TransformOperation) instr) .executeTransformOperation(PlanarImage.wrapRenderedImage(bi));
				 bi = image.getAsBufferedImage();
			 }
		 }
		 return performScale(image);
	 }
	 public PlanarImage executeDrawOperation() {
		 final int size = instructions.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
			 if (instr instanceof DrawOperation) {
				 PlanarImage image = null;
				 performScale(image);
				 return image;
			 }
		 }
		 return null;
	 }
}",0,0,0,0
"public class OffHeapPollingCache<K, V> implements PollingCache<K, V>{
	 private static final DB DB = DBMaker.newMemoryDirectDB().transactionDisable().closeOnJvmShutdown().make();
	 private final HTreeMap<K, V> mapCache;
	 private final HTreeMap<V, List<K>> reverseCache;
	 private final AtomicBoolean started = new AtomicBoolean(false);
	 private final String cacheName;
	 private final String reverseCacheName;
	 public OffHeapPollingCache(final Iterable<Map.Entry<K, V>> entries) {
		 synchronized (started) {
			 this.cacheName = StringUtils.format(""cache-%s"", UUID.randomUUID());
			 this.reverseCacheName = StringUtils.format(""reverseCache-%s"", UUID.randomUUID());
			 mapCache = DB.createHashMap(cacheName).make();
			 reverseCache = DB.createHashMap(reverseCacheName).make();
			 ImmutableSet.Builder<V> setOfValuesBuilder = ImmutableSet.builder();
			 for (Map.Entry<K, V> entry : entries) {
				 mapCache.put(entry.getKey(), entry.getValue());
				 setOfValuesBuilder.add(entry.getValue());
			 }
			 final Set<V> setOfValues = setOfValuesBuilder.build();
			 reverseCache.putAll(Maps.asMap( setOfValues, new Function<V, List<K>>() {
				 public List<K> apply(final V input) {
					 return Lists.newArrayList(Maps.filterKeys(mapCache, new Predicate<K>() {
						 public boolean apply(K key) {
							 V retVal = mapCache.get(key);
							 if (retVal == null) {
								 return false;
							 }
							 return retVal.equals(input);
						 }
					 }
					).keySet());
				 }
			 }
			 ));
			 started.getAndSet(true);
		 }
	 }
	 public V get(K key) {
		 return mapCache.get(key);
	 }
	 public List<K> getKeys(V value) {
		 final List<K> listOfKey = reverseCache.get(value);
		 if (listOfKey == null) {
			 return Collections.emptyList();
		 }
		 return listOfKey;
	 }
	 public void close() {
		 synchronized (started) {
			 if (started.getAndSet(false)) {
				 DB.delete(cacheName);
				 DB.delete(reverseCacheName);
			 }
		 }
	 }
	 public static class OffHeapPollingCacheProvider<K, V> implements PollingCacheFactory<K, V> {
		 public PollingCache<K, V> makeOf(Iterable<Map.Entry<K, V>> entries) {
			 return new OffHeapPollingCache<>(entries);
		 }
	 }
}",0,0,0,0
"public class CheckBox extends FormComponent<Boolean> implements IOnChangeListener{
	private static final long serialVersionUID = 1L;
	public CheckBox(final String id){
		this(id, null);
	}
	public CheckBox(final String id, IModel<Boolean> model){
		super(id, model);
		setType(Boolean.class);
	}
	public void onSelectionChanged(){
		convertInput();
		updateModel();
		onSelectionChanged(getDefaultModelObject());
	}
	protected void onSelectionChanged(Object newSelection){
	}
	protected boolean wantOnSelectionChangedNotifications(){
		return false;
	}
	protected boolean getStatelessHint(){
		if (wantOnSelectionChangedNotifications()){
			return false;
		}
		return super.getStatelessHint();
	}
	protected void onComponentTag(final ComponentTag tag){
		checkComponentTag(tag, ""input"");
		checkComponentTagAttribute(tag, ""type"", ""checkbox"");
		final String value = getValue();
		final IConverter converter = getConverter(Boolean.class);
		final Boolean checked = (Boolean)converter.convertToObject(value, getLocale());
		if (Boolean.TRUE.equals(checked)){
			tag.put(""checked"", ""checked"");
		}
		else{
			tag.remove(""checked"");
		}
		tag.remove(""value"");
		if (wantOnSelectionChangedNotifications()){
			CharSequence url = urlFor(IOnChangeListener.INTERFACE);
			Form<?> form = findParent(Form.class);
			if (form != null){
				RequestContext rc = RequestContext.get();
				if (rc.isPortletRequest()){
					url = ((PortletRequestContext)rc).getLastEncodedPath();
				}
				tag.put(""onclick"", form.getJsForInterfaceUrl(url));
			}
			else{
				tag.put(""onclick"", ""window.location.href='"" + url +(url.toString().indexOf('?') > -1 ? ""&amp;
				"" : ""?"") + getInputName() +""=' + this.checked;
				"");
			}
		}
		super.onComponentTag(tag);
	}
	protected final boolean supportsPersistence(){
		return true;
	}
	public final IConverter getConverter(Class<?> type){
		if (Boolean.class.equals(type)){
			return CheckBoxConverter.INSTANCE;
		}
		else{
			return super.getConverter(type);
		}
	}
	private static class CheckBoxConverter implements IConverter{
		private static final long serialVersionUID = 1L;
		private static final IConverter INSTANCE = new CheckBoxConverter();
		private CheckBoxConverter(){
		}
		public Object convertToObject(String value, Locale locale){
			if (""on"".equals(value) || ""true"".equals(value)){
				return Boolean.TRUE;
			}
			else{
				return Boolean.FALSE;
			}
		}
		public String convertToString(Object value, Locale locale){
			return ((Boolean)value).toString();
		}
	}
}",0,0,0,0
"public class MemberMBeanBridge {
	 private static final Logger logger = LogService.getLogger();
	 public static final MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
	 private static final long MBFactor = 1024 * 1024;
	 private static final TimeUnit nanoSeconds = TimeUnit.NANOSECONDS;
	 private InternalCache cache;
	 private DistributionConfig config;
	 private GemFireProperties gemFirePropertyData;
	 private InternalDistributedSystem system;
	 private DistributionManager dm;
	 private OnlineCommandProcessor commandProcessor;
	 private String commandServiceInitError;
	 private MemoryMXBean memoryMXBean;
	 private ThreadMXBean threadMXBean;
	 private RuntimeMXBean runtimeMXBean;
	 private OperatingSystemMXBean osBean;
	 private String hostname;
	 private int processId;
	 private ObjectName osObjectName;
	 private long lastSystemTime = 0;
	 private long lastProcessCpuTime = 0;
	 private MBeanStatsMonitor monitor;
	 private volatile boolean lockStatsAdded = false;
	 private SystemManagementService service;
	 private MemberLevelDiskMonitor diskMonitor;
	 private AggregateRegionStatsMonitor regionMonitor;
	 private StatsRate createsRate;
	 private StatsRate bytesReceivedRate;
	 private StatsRate bytesSentRate;
	 private StatsRate destroysRate;
	 private StatsRate functionExecutionRate;
	 private StatsRate getsRate;
	 private StatsRate putAllRate;
	 private StatsRate putsRate;
	 private StatsRate transactionCommitsRate;
	 private StatsRate diskReadsRate;
	 private StatsRate diskWritesRate;
	 private StatsAverageLatency listenerCallsAvgLatency;
	 private StatsAverageLatency writerCallsAvgLatency;
	 private StatsAverageLatency putsAvgLatency;
	 private StatsAverageLatency getsAvgLatency;
	 private StatsAverageLatency putAllAvgLatency;
	 private StatsAverageLatency loadsAverageLatency;
	 private StatsAverageLatency netLoadsAverageLatency;
	 private StatsAverageLatency netSearchAverageLatency;
	 private StatsAverageLatency transactionCommitsAvgLatency;
	 private StatsAverageLatency diskFlushAvgLatency;
	 private StatsAverageLatency deserializationAvgLatency;
	 private StatsLatency deserializationLatency;
	 private StatsRate deserializationRate;
	 private StatsAverageLatency serializationAvgLatency;
	 private StatsLatency serializationLatency;
	 private StatsRate serializationRate;
	 private StatsAverageLatency pdxDeserializationAvgLatency;
	 private StatsRate pdxDeserializationRate;
	 private StatsRate lruDestroyRate;
	 private StatsRate lruEvictionRate;
	 private String gemFireVersion;
	 private String classPath;
	 private String name;
	 private String id;
	 private String osName = System.getProperty(""os.name"", ""unknown"");
	 private GCStatsMonitor gcMonitor;
	 private VMStatsMonitor vmStatsMonitor;
	 private MBeanStatsMonitor systemStatsMonitor;
	 private float instCreatesRate = 0;
	 private float instGetsRate = 0;
	 private float instPutsRate = 0;
	 private float instPutAllRate = 0;
	 private GemFireStatSampler sampler;
	 private Statistics systemStat;
	 private static final String MEMBER_LEVEL_DISK_MONITOR = ""MemberLevelDiskMonitor"";
	 private static final String MEMBER_LEVEL_REGION_MONITOR = ""MemberLevelRegionMonitor"";
	 private boolean cacheServer = false;
	 private String redundancyZone = """";
	 private ResourceManagerStats resourceManagerStats;
	 public MemberMBeanBridge(InternalCache cache, SystemManagementService service) {
		 this.cache = cache;
		 this.service = service;
		 this.system = (InternalDistributedSystem) cache.getDistributedSystem();
		 this.dm = system.getDistributionManager();
		 if (dm instanceof ClusterDistributionManager) {
			 ClusterDistributionManager distManager = (ClusterDistributionManager) system.getDistributionManager();
			 this.redundancyZone = distManager .getRedundancyZone(cache.getInternalDistributedSystem().getDistributedMember());
		 }
		 this.sampler = system.getStatSampler();
		 this.config = system.getConfig();
		 try {
			 this.commandProcessor = new OnlineCommandProcessor(system.getProperties(), cache.getSecurityService(), cache);
		 }
		 catch (Exception e) {
			 commandServiceInitError = e.getMessage();
			 logger.info(LogMarker.CONFIG_MARKER, ""Command processor could not be initialized. {
			}
			"", e.getMessage());
		 }
		 intitGemfireProperties();
		 try {
			 InetAddress addr = SocketCreator.getLocalHost();
			 this.hostname = addr.getHostName();
		 }
		 catch (UnknownHostException ignore) {
			 this.hostname = ManagementConstants.DEFAULT_HOST_NAME;
		 }
		 try {
			 this.osObjectName = new ObjectName(""java.lang:type=OperatingSystem"");
		 }
		 catch (MalformedObjectNameException ex) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(ex.getMessage(), ex);
			 }
		 }
		 catch (NullPointerException ex) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(ex.getMessage(), ex);
			 }
		 }
		 this.memoryMXBean = ManagementFactory.getMemoryMXBean();
		 this.threadMXBean = ManagementFactory.getThreadMXBean();
		 this.runtimeMXBean = ManagementFactory.getRuntimeMXBean();
		 this.osBean = ManagementFactory.getOperatingSystemMXBean();
		 this.monitor = new MBeanStatsMonitor(""MemberMXBeanMonitor"");
		 this.diskMonitor = new MemberLevelDiskMonitor(MEMBER_LEVEL_DISK_MONITOR);
		 this.regionMonitor = new AggregateRegionStatsMonitor(MEMBER_LEVEL_REGION_MONITOR);
		 this.gcMonitor = new GCStatsMonitor(""GCStatsMonitor"");
		 this.vmStatsMonitor = new VMStatsMonitor(""VMStatsMonitor"");
		 this.systemStatsMonitor = new MBeanStatsMonitor(""SystemStatsManager"");
		 this.gemFireVersion = GemFireVersion.asString();
		 this.classPath = runtimeMXBean.getClassPath();
		 this.name = cache.getDistributedSystem().getDistributedMember().getName();
		 this.id = cache.getDistributedSystem().getDistributedMember().getId();
		 try {
			 this.processId = ProcessUtils.identifyPid();
		 }
		 catch (PidUnavailableException ex) {
			 if (logger.isDebugEnabled()) {
				 logger.debug(ex.getMessage(), ex);
			 }
		 }
		 QueryDataFunction qDataFunction = new QueryDataFunction();
		 FunctionService.registerFunction(qDataFunction);
		 this.resourceManagerStats = cache.getInternalResourceManager().getStats();
	 }
	 public MemberMBeanBridge() {
		 this.monitor = new MBeanStatsMonitor(""MemberMXBeanMonitor"");
		 this.diskMonitor = new MemberLevelDiskMonitor(MEMBER_LEVEL_DISK_MONITOR);
		 this.regionMonitor = new AggregateRegionStatsMonitor(MEMBER_LEVEL_REGION_MONITOR);
		 this.gcMonitor = new GCStatsMonitor(""GCStatsMonitor"");
		 this.vmStatsMonitor = new VMStatsMonitor(""VMStatsMonitor"");
		 this.systemStatsMonitor = new MBeanStatsMonitor(""SystemStatsManager"");
		 this.system = InternalDistributedSystem.getConnectedInstance();
		 initializeStats();
	 }
	 public MemberMBeanBridge init() {
		 CachePerfStats cachePerfStats = this.cache.getCachePerfStats();
		 addCacheStats(cachePerfStats);
		 addFunctionStats(system.getFunctionServiceStats());
		 if (system.getDistributionManager().getStats() instanceof DistributionStats) {
			 DistributionStats distributionStats = (DistributionStats) system.getDistributionManager().getStats();
			 addDistributionStats(distributionStats);
		 }
		 if (PureJavaMode.osStatsAreAvailable()) {
			 Statistics[] systemStats = null;
			 if (HostStatHelper.isSolaris()) {
				 systemStats = system.findStatisticsByType(SolarisSystemStats.getType());
			 }
			 else if (HostStatHelper.isLinux()) {
				 systemStats = system.findStatisticsByType(LinuxSystemStats.getType());
			 }
			 else if (HostStatHelper.isOSX()) {
				 systemStats = null;
			 }
			 else if (HostStatHelper.isWindows()) {
				 systemStats = system.findStatisticsByType(WindowsSystemStats.getType());
			 }
			 if (systemStats != null) {
				 systemStat = systemStats[0];
			 }
		 }
		 MemoryAllocator allocator = this.cache.getOffHeapStore();
		 if ((null != allocator)) {
			 OffHeapMemoryStats offHeapStats = allocator.getStats();
			 if (null != offHeapStats) {
				 addOffHeapStats(offHeapStats);
			 }
		 }
		 addSystemStats();
		 addVMStats();
		 initializeStats();
		 return this;
	 }
	 public void addOffHeapStats(OffHeapMemoryStats offHeapStats) {
		 Statistics offHeapMemoryStatistics = offHeapStats.getStats();
		 monitor.addStatisticsToMonitor(offHeapMemoryStatistics);
	 }
	 public void addCacheStats(CachePerfStats cachePerfStats) {
		 Statistics cachePerfStatistics = cachePerfStats.getStats();
		 monitor.addStatisticsToMonitor(cachePerfStatistics);
	 }
	 public void addFunctionStats(FunctionServiceStats functionServiceStats) {
		 Statistics functionStatistics = functionServiceStats.getStats();
		 monitor.addStatisticsToMonitor(functionStatistics);
	 }
	 public void addDistributionStats(DistributionStats distributionStats) {
		 Statistics dsStats = distributionStats.getStats();
		 monitor.addStatisticsToMonitor(dsStats);
	 }
	 public void addDiskStore(DiskStore dsi) {
		 DiskStoreImpl impl = (DiskStoreImpl) dsi;
		 addDiskStoreStats(impl.getStats());
	 }
	 public void addDiskStoreStats(DiskStoreStats stats) {
		 diskMonitor.addStatisticsToMonitor(stats.getStats());
	 }
	 public void removeDiskStore(DiskStore dsi) {
		 DiskStoreImpl impl = (DiskStoreImpl) dsi;
		 removeDiskStoreStats(impl.getStats());
	 }
	 public void removeDiskStoreStats(DiskStoreStats stats) {
		 diskMonitor.removeStatisticsFromMonitor(stats.getStats());
	 }
	 public void addRegion(Region region) {
		 if (region.getAttributes().getPartitionAttributes() != null) {
			 addPartionRegionStats(((PartitionedRegion) region).getPrStats());
		 }
		 InternalRegion internalRegion = (InternalRegion) region;
		 addLRUStats(internalRegion.getEvictionStatistics());
		 DiskRegion dr = internalRegion.getDiskRegion();
		 if (dr != null) {
			 for (DirectoryHolder dh : dr.getDirectories()) {
				 addDirectoryStats(dh.getDiskDirectoryStats());
			 }
		 }
	 }
	 public void addPartionRegionStats(PartitionedRegionStats parStats) {
		 regionMonitor.addStatisticsToMonitor(parStats.getStats());
	 }
	 public void addLRUStats(Statistics lruStats) {
		 if (lruStats != null) {
			 regionMonitor.addStatisticsToMonitor(lruStats);
		 }
	 }
	 public void addDirectoryStats(DiskDirectoryStats diskDirStats) {
		 regionMonitor.addStatisticsToMonitor(diskDirStats.getStats());
	 }
	 public void removeRegion(Region region) {
		 if (region.getAttributes().getPartitionAttributes() != null) {
			 removePartionRegionStats(((PartitionedRegion) region).getPrStats());
		 }
		 LocalRegion l = (LocalRegion) region;
		 removeLRUStats(l.getEvictionStatistics());
		 DiskRegion dr = l.getDiskRegion();
		 if (dr != null) {
			 for (DirectoryHolder dh : dr.getDirectories()) {
				 removeDirectoryStats(dh.getDiskDirectoryStats());
			 }
		 }
	 }
	 public void removePartionRegionStats(PartitionedRegionStats parStats) {
		 regionMonitor.removePartitionStatistics(parStats.getStats());
	 }
	 public void removeLRUStats(Statistics statistics) {
		 if (statistics != null) {
			 regionMonitor.removeLRUStatistics(statistics);
		 }
	 }
	 public void removeDirectoryStats(DiskDirectoryStats diskDirStats) {
		 regionMonitor.removeDirectoryStatistics(diskDirStats.getStats());
	 }
	 public void addLockServiceStats(DLockService lock) {
		 if (!lockStatsAdded) {
			 DLockStats stats = (DLockStats) lock.getStats();
			 addLockServiceStats(stats);
			 lockStatsAdded = true;
		 }
	 }
	 public void addLockServiceStats(DLockStats stats) {
		 monitor.addStatisticsToMonitor(stats.getStats());
	 }
	 public void addSystemStats() {
		 GemFireStatSampler sampler = system.getStatSampler();
		 ProcessStats processStats = sampler.getProcessStats();
		 StatSamplerStats samplerStats = sampler.getStatSamplerStats();
		 if (processStats != null) {
			 systemStatsMonitor.addStatisticsToMonitor(processStats.getStatistics());
		 }
		 if (samplerStats != null) {
			 systemStatsMonitor.addStatisticsToMonitor(samplerStats.getStats());
		 }
	 }
	 public void addVMStats() {
		 VMStatsContract vmStatsContract = system.getStatSampler().getVMStats();
		 if (vmStatsContract != null && vmStatsContract instanceof VMStats50) {
			 VMStats50 vmStats50 = (VMStats50) vmStatsContract;
			 Statistics vmStats = vmStats50.getVMStats();
			 if (vmStats != null) {
				 vmStatsMonitor.addStatisticsToMonitor(vmStats);
			 }
			 Statistics vmHeapStats = vmStats50.getVMHeapStats();
			 if (vmHeapStats != null) {
				 vmStatsMonitor.addStatisticsToMonitor(vmHeapStats);
			 }
			 StatisticsType gcType = VMStats50.getGCType();
			 if (gcType != null) {
				 Statistics[] gcStats = system.findStatisticsByType(gcType);
				 if (gcStats != null && gcStats.length > 0) {
					 for (Statistics gcStat : gcStats) {
						 if (gcStat != null) {
							 gcMonitor.addStatisticsToMonitor(gcStat);
						 }
					 }
				 }
			 }
		 }
	 }
	 public Number getMemberLevelStatistic(String statName) {
		 return monitor.getStatistic(statName);
	 }
	 public Number getVMStatistic(String statName) {
		 return vmStatsMonitor.getStatistic(statName);
	 }
	 public Number getGCStatistic(String statName) {
		 return gcMonitor.getStatistic(statName);
	 }
	 public Number getSystemStatistic(String statName) {
		 return systemStatsMonitor.getStatistic(statName);
	 }
	 public void stopMonitor() {
		 monitor.stopListener();
		 regionMonitor.stopListener();
		 gcMonitor.stopListener();
		 systemStatsMonitor.stopListener();
		 vmStatsMonitor.stopListener();
	 }
	 private void initializeStats() {
		 createsRate = new StatsRate(StatsKey.CREATES, StatType.INT_TYPE, monitor);
		 bytesReceivedRate = new StatsRate(StatsKey.RECEIVED_BYTES, StatType.LONG_TYPE, monitor);
		 bytesSentRate = new StatsRate(StatsKey.SENT_BYTES, StatType.LONG_TYPE, monitor);
		 destroysRate = new StatsRate(StatsKey.DESTROYS, StatType.INT_TYPE, monitor);
		 functionExecutionRate = new StatsRate(StatsKey.FUNCTION_EXECUTIONS_COMPLETED, StatType.INT_TYPE, monitor);
		 getsRate = new StatsRate(StatsKey.GETS, StatType.INT_TYPE, monitor);
		 putAllRate = new StatsRate(StatsKey.PUT_ALLS, StatType.INT_TYPE, monitor);
		 putsRate = new StatsRate(StatsKey.PUTS, StatType.INT_TYPE, monitor);
		 transactionCommitsRate = new StatsRate(StatsKey.TRANSACTION_COMMITS, StatType.INT_TYPE, monitor);
		 diskReadsRate = new StatsRate(StatsKey.DISK_READ_BYTES, StatType.LONG_TYPE, diskMonitor);
		 diskWritesRate = new StatsRate(StatsKey.DISK_WRITEN_BYTES, StatType.LONG_TYPE, diskMonitor);
		 listenerCallsAvgLatency = new StatsAverageLatency(StatsKey.CACHE_LISTENER_CALLS_COMPLETED, StatType.INT_TYPE, StatsKey.CACHE_LISTENR_CALL_TIME, monitor);
		 writerCallsAvgLatency = new StatsAverageLatency(StatsKey.CACHE_WRITER_CALLS_COMPLETED, StatType.INT_TYPE, StatsKey.CACHE_WRITER_CALL_TIME, monitor);
		 getsAvgLatency = new StatsAverageLatency(StatsKey.GETS, StatType.INT_TYPE, StatsKey.GET_TIME, monitor);
		 putAllAvgLatency = new StatsAverageLatency(StatsKey.PUT_ALLS, StatType.INT_TYPE, StatsKey.PUT_ALL_TIME, monitor);
		 putsAvgLatency = new StatsAverageLatency(StatsKey.PUTS, StatType.INT_TYPE, StatsKey.PUT_TIME, monitor);
		 loadsAverageLatency = new StatsAverageLatency(StatsKey.LOADS_COMPLETED, StatType.INT_TYPE, StatsKey.LOADS_TIME, monitor);
		 netLoadsAverageLatency = new StatsAverageLatency(StatsKey.NET_LOADS_COMPLETED, StatType.INT_TYPE, StatsKey.NET_LOADS_TIME, monitor);
		 netSearchAverageLatency = new StatsAverageLatency(StatsKey.NET_SEARCH_COMPLETED, StatType.INT_TYPE, StatsKey.NET_SEARCH_TIME, monitor);
		 transactionCommitsAvgLatency = new StatsAverageLatency(StatsKey.TRANSACTION_COMMITS, StatType.INT_TYPE, StatsKey.TRANSACTION_COMMIT_TIME, monitor);
		 diskFlushAvgLatency = new StatsAverageLatency(StatsKey.NUM_FLUSHES, StatType.INT_TYPE, StatsKey.TOTAL_FLUSH_TIME, diskMonitor);
		 deserializationAvgLatency = new StatsAverageLatency(StatsKey.DESERIALIZATIONS, StatType.INT_TYPE, StatsKey.DESERIALIZATION_TIME, monitor);
		 deserializationLatency = new StatsLatency(StatsKey.DESERIALIZATIONS, StatType.INT_TYPE, StatsKey.DESERIALIZATION_TIME, monitor);
		 deserializationRate = new StatsRate(StatsKey.DESERIALIZATIONS, StatType.INT_TYPE, monitor);
		 serializationAvgLatency = new StatsAverageLatency(StatsKey.SERIALIZATIONS, StatType.INT_TYPE, StatsKey.SERIALIZATION_TIME, monitor);
		 serializationLatency = new StatsLatency(StatsKey.SERIALIZATIONS, StatType.INT_TYPE, StatsKey.SERIALIZATION_TIME, monitor);
		 serializationRate = new StatsRate(StatsKey.SERIALIZATIONS, StatType.INT_TYPE, monitor);
		 pdxDeserializationAvgLatency = new StatsAverageLatency(StatsKey.PDX_INSTANCE_DESERIALIZATIONS, StatType.INT_TYPE, StatsKey.PDX_INSTANCE_DESERIALIZATION_TIME, monitor);
		 pdxDeserializationRate = new StatsRate(StatsKey.PDX_INSTANCE_DESERIALIZATIONS, StatType.INT_TYPE, monitor);
		 lruDestroyRate = new StatsRate(StatsKey.LRU_DESTROYS, StatType.LONG_TYPE, regionMonitor);
		 lruEvictionRate = new StatsRate(StatsKey.LRU_EVICTIONS, StatType.LONG_TYPE, regionMonitor);
	 }
	 private void intitGemfireProperties() {
		 if (gemFirePropertyData == null) {
			 this.gemFirePropertyData = BeanUtilFuncs.initGemfireProperties(config);
		 }
	 }
	 public JVMMetrics fetchJVMMetrics() {
		 long gcCount = getGCStatistic(StatsKey.VM_GC_STATS_COLLECTIONS).longValue();
		 long gcTimeMillis = getGCStatistic(StatsKey.VM_GC_STATS_COLLECTION_TIME).longValue();
		 long initMemory = memoryMXBean.getHeapMemoryUsage().getInit();
		 long committedMemory = memoryMXBean.getHeapMemoryUsage().getCommitted();
		 long usedMemory = getVMStatistic(StatsKey.VM_USED_MEMORY).longValue();
		 long maxMemory = memoryMXBean.getHeapMemoryUsage().getMax();
		 int totalThreads = getVMStatistic(StatsKey.VM_STATS_NUM_THREADS).intValue();
		 return new JVMMetrics(gcCount, gcTimeMillis, initMemory, committedMemory, usedMemory, maxMemory, totalThreads);
	 }
	 public OSMetrics fetchOSMetrics() {
		 OSMetrics metrics = null;
		 try {
			 long maxFileDescriptorCount = 0;
			 long openFileDescriptorCount = 0;
			 long processCpuTime = 0;
			 long committedVirtualMemorySize = 0;
			 long totalPhysicalMemorySize = 0;
			 long freePhysicalMemorySize = 0;
			 long totalSwapSpaceSize = 0;
			 long freeSwapSpaceSize = 0;
			 String name = osBean.getName();
			 String version = osBean.getVersion();
			 String arch = osBean.getArch();
			 int availableProcessors = osBean.getAvailableProcessors();
			 double systemLoadAverage = osBean.getSystemLoadAverage();
			 openFileDescriptorCount = getVMStatistic(StatsKey.VM_STATS_OPEN_FDS).longValue();
			 processCpuTime = getVMStatistic(StatsKey.VM_PROCESS_CPU_TIME).longValue();
			 try {
				 maxFileDescriptorCount = (Long) mbeanServer.getAttribute(osObjectName, ""MaxFileDescriptorCount"");
			 }
			 catch (Exception ignore) {
				 maxFileDescriptorCount = -1;
			 }
			 try {
				 committedVirtualMemorySize = (Long) mbeanServer.getAttribute(osObjectName, ""CommittedVirtualMemorySize"");
			 }
			 catch (Exception ignore) {
				 committedVirtualMemorySize = -1;
			 }
			 if (PureJavaMode.osStatsAreAvailable() && HostStatHelper.isLinux() && systemStat != null) {
				 try {
					 totalPhysicalMemorySize = systemStat.get(StatsKey.LINUX_SYSTEM_PHYSICAL_MEMORY).longValue();
				 }
				 catch (Exception ignore) {
					 totalPhysicalMemorySize = -1;
				 }
				 try {
					 freePhysicalMemorySize = systemStat.get(StatsKey.LINUX_SYSTEM_FREE_MEMORY).longValue();
				 }
				 catch (Exception ignore) {
					 freePhysicalMemorySize = -1;
				 }
				 try {
					 totalSwapSpaceSize = systemStat.get(StatsKey.LINUX_SYSTEM_TOTAL_SWAP_SIZE).longValue();
				 }
				 catch (Exception ignore) {
					 totalSwapSpaceSize = -1;
				 }
				 try {
					 freeSwapSpaceSize = systemStat.get(StatsKey.LINUX_SYSTEM_FREE_SWAP_SIZE).longValue();
				 }
				 catch (Exception ignore) {
					 freeSwapSpaceSize = -1;
				 }
			 }
			 else {
				 totalPhysicalMemorySize = -1;
				 freePhysicalMemorySize = -1;
				 totalSwapSpaceSize = -1;
				 freeSwapSpaceSize = -1;
			 }
			 metrics = new OSMetrics(maxFileDescriptorCount, openFileDescriptorCount, processCpuTime, committedVirtualMemorySize, totalPhysicalMemorySize, freePhysicalMemorySize, totalSwapSpaceSize, freeSwapSpaceSize, name, version, arch, availableProcessors, systemLoadAverage);
		 }
		 catch (Exception ex) {
			 if (logger.isTraceEnabled()) {
				 logger.trace(ex.getMessage(), ex);
			 }
		 }
		 return metrics;
	 }
	 public GemFireProperties getGemFireProperty() {
		 return gemFirePropertyData;
	 }
	 public boolean createManager() {
		 if (service.isManager()) {
			 return false;
		 }
		 return service.createManager();
	 }
	 public String[] compactAllDiskStores() {
		 List<String> compactedStores = new ArrayList<String>();
		 if (cache != null && !cache.isClosed()) {
			 for (DiskStore store : this.cache.listDiskStoresIncludingRegionOwned()) {
				 if (store.forceCompaction()) {
					 compactedStores.add(((DiskStoreImpl) store).getPersistentID().getDirectory());
				 }
			 }
		 }
		 String[] compactedStoresAr = new String[compactedStores.size()];
		 return compactedStores.toArray(compactedStoresAr);
	 }
	 public String[] listDiskStores(boolean includeRegionOwned) {
		 String[] retStr = null;
		 Collection<DiskStore> diskCollection = null;
		 if (includeRegionOwned) {
			 diskCollection = this.cache.listDiskStoresIncludingRegionOwned();
		 }
		 else {
			 diskCollection = this.cache.listDiskStores();
		 }
		 if (diskCollection != null && diskCollection.size() > 0) {
			 retStr = new String[diskCollection.size()];
			 Iterator<DiskStore> it = diskCollection.iterator();
			 int i = 0;
			 while (it.hasNext()) {
				 retStr[i] = it.next().getName();
				 i++;
			 }
		 }
		 return retStr;
	 }
	 public String[] getDiskStores() {
		 return listDiskStores(true);
	 }
	 public String fetchLog(int numLines) {
		 if (numLines > ManagementConstants.MAX_SHOW_LOG_LINES) {
			 numLines = ManagementConstants.MAX_SHOW_LOG_LINES;
		 }
		 if (numLines == 0 || numLines < 0) {
			 numLines = ManagementConstants.DEFAULT_SHOW_LOG_LINES;
		 }
		 String childTail = null;
		 String mainTail = null;
		 try {
			 InternalDistributedSystem sys = system;
			 if (sys.getLogFile().isPresent()) {
				 LogFile logFile = sys.getLogFile().get();
				 childTail = BeanUtilFuncs.tailSystemLog(logFile.getChildLogFile(), numLines);
				 mainTail = BeanUtilFuncs.tailSystemLog(sys.getConfig(), numLines);
				 if (mainTail == null) {
					 mainTail = ""No log file was specified in the configuration, messages will be directed to stdout."";
				 }
			 }
			 else {
				 throw new IllegalStateException( ""TailLogRequest/Response processed in application vm with shared logging. This would occur if there is no 'log-file' defined."");
			 }
		 }
		 catch (IOException e) {
			 logger.warn(""Error occurred while reading system log:"", e);
			 mainTail = """";
		 }
		 if (childTail == null && mainTail == null) {
			 return ""No log file configured, log messages will be directed to stdout."";
		 }
		 else {
			 StringBuilder result = new StringBuilder();
			 if (mainTail != null) {
				 result.append(mainTail);
			 }
			 if (childTail != null) {
				 result.append(getLineSeparator()) .append(""-------------------- tail of child log --------------------"") .append(getLineSeparator());
				 result.append(childTail);
			 }
			 return result.toString();
		 }
	 }
	 public void shutDownMember() {
		 final InternalDistributedSystem ids = dm.getSystem();
		 if (ids.isConnected()) {
			 Thread t = new LoggingThread(""Shutdown member"", false, () -> {
				 try {
					 Thread.sleep(1000);
				 }
				 catch (InterruptedException ignore) {
				 }
				 ConnectionTable.threadWantsSharedResources();
				 if (ids.isConnected()) {
					 ids.disconnect();
				 }
			 }
			);
			 t.start();
		 }
	 }
	 public String getName() {
		 return name;
	 }
	 public String getId() {
		 return id;
	 }
	 public String getMember() {
		 if (name != null && !name.isEmpty()) {
			 return name;
		 }
		 return id;
	 }
	 public String[] getGroups() {
		 List<String> groups = cache.getDistributedSystem().getDistributedMember().getGroups();
		 String[] groupsArray = new String[groups.size()];
		 groupsArray = groups.toArray(groupsArray);
		 return groupsArray;
	 }
	 public String getClassPath() {
		 return classPath;
	 }
	 public String[] listConnectedGatewayReceivers() {
		 if ((cache != null && cache.getGatewayReceivers().size() > 0)) {
			 Set<GatewayReceiver> receivers = cache.getGatewayReceivers();
			 String[] arr = new String[receivers.size()];
			 int j = 0;
			 for (GatewayReceiver recv : receivers) {
				 arr[j] = recv.getBindAddress();
				 j++;
			 }
			 return arr;
		 }
		 return ManagementConstants.NO_DATA_STRING;
	 }
	 public String[] listConnectedGatewaySenders() {
		 if ((cache != null && cache.getGatewaySenders().size() > 0)) {
			 Set<GatewaySender> senders = cache.getGatewaySenders();
			 String[] arr = new String[senders.size()];
			 int j = 0;
			 for (GatewaySender sender : senders) {
				 arr[j] = sender.getId();
				 j++;
			 }
			 return arr;
		 }
		 return ManagementConstants.NO_DATA_STRING;
	 }
	 public float getCpuUsage() {
		 return vmStatsMonitor.getCpuUsage();
	 }
	 public long getCurrentTime() {
		 return System.currentTimeMillis();
	 }
	 public String getHost() {
		 return hostname;
	 }
	 public int getProcessId() {
		 return processId;
	 }
	 public String status() {
		 if (LocatorLauncher.getInstance() != null) {
			 return LocatorLauncher.getLocatorState().toJson();
		 }
		 else if (ServerLauncher.getInstance() != null) {
			 return ServerLauncher.getServerState().toJson();
		 }
		 return null;
	 }
	 public long getTotalBytesInUse() {
		 MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();
		 return memHeap.getUsed();
	 }
	 public int getAvailableCpus() {
		 Runtime runtime = Runtime.getRuntime();
		 return runtime.availableProcessors();
	 }
	 public String[] fetchJvmThreads() {
		 long threadIds[] = threadMXBean.getAllThreadIds();
		 ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadIds, 0);
		 if (threadInfos == null || threadInfos.length < 1) {
			 return ManagementConstants.NO_DATA_STRING;
		 }
		 ArrayList<String> thrdStr = new ArrayList<String>(threadInfos.length);
		 for (ThreadInfo thInfo : threadInfos) {
			 if (thInfo != null) {
				 thrdStr.add(thInfo.getThreadName());
			 }
		 }
		 String[] result = new String[thrdStr.size()];
		 return thrdStr.toArray(result);
	 }
	 public String[] getListOfRegions() {
		 Set<InternalRegion> listOfAppRegions = cache.getApplicationRegions();
		 if (listOfAppRegions != null && listOfAppRegions.size() > 0) {
			 String[] regionStr = new String[listOfAppRegions.size()];
			 int j = 0;
			 for (InternalRegion rg : listOfAppRegions) {
				 regionStr[j] = rg.getFullPath();
				 j++;
			 }
			 return regionStr;
		 }
		 return ManagementConstants.NO_DATA_STRING;
	 }
	 public long getLockLease() {
		 return cache.getLockLease();
	 }
	 public long getLockTimeout() {
		 return cache.getLockTimeout();
	 }
	 public long getMemberUpTime() {
		 return cache.getUpTime();
	 }
	 public String[] getRootRegionNames() {
		 Set<Region<?, ?>> listOfRootRegions = cache.rootRegions();
		 if (listOfRootRegions != null && listOfRootRegions.size() > 0) {
			 String[] regionNames = new String[listOfRootRegions.size()];
			 int j = 0;
			 for (Region region : listOfRootRegions) {
				 regionNames[j] = region.getFullPath();
				 j++;
			 }
			 return regionNames;
		 }
		 return ManagementConstants.NO_DATA_STRING;
	 }
	 public String getVersion() {
		 return gemFireVersion;
	 }
	 public boolean hasGatewayReceiver() {
		 return (cache != null && cache.getGatewayReceivers().size() > 0);
	 }
	 public boolean hasGatewaySender() {
		 return (cache != null && cache.getAllGatewaySenders().size() > 0);
	 }
	 public boolean isLocator() {
		 return Locator.hasLocator();
	 }
	 public boolean isManager() {
		 if (this.cache == null || this.cache.isClosed()) {
			 return false;
		 }
		 try {
			 return service.isManager();
		 }
		 catch (Exception ignore) {
			 return false;
		 }
	 }
	 public boolean isManagerCreated() {
		 if (this.cache == null || this.cache.isClosed()) {
			 return false;
		 }
		 try {
			 return service.isManagerCreated();
		 }
		 catch (Exception ignore) {
			 return false;
		 }
	 }
	 public boolean isServer() {
		 return cache.isServer();
	 }
	 public int getInitialImageKeysReceived() {
		 return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGE_KEYS_RECEIVED).intValue();
	 }
	 public long getInitialImageTime() {
		 return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGE_TIME).longValue();
	 }
	 public int getInitialImagesInProgress() {
		 return getMemberLevelStatistic(StatsKey.GET_INITIAL_IMAGES_INPROGRESS).intValue();
	 }
	 public long getTotalIndexMaintenanceTime() {
		 return getMemberLevelStatistic(StatsKey.TOTAL_INDEX_UPDATE_TIME).longValue();
	 }
	 public float getBytesReceivedRate() {
		 return bytesReceivedRate.getRate();
	 }
	 public float getBytesSentRate() {
		 return bytesSentRate.getRate();
	 }
	 public long getCacheListenerCallsAvgLatency() {
		 return listenerCallsAvgLatency.getAverageLatency();
	 }
	 public long getCacheWriterCallsAvgLatency() {
		 return writerCallsAvgLatency.getAverageLatency();
	 }
	 public float getCreatesRate() {
		 this.instCreatesRate = createsRate.getRate();
		 return instCreatesRate;
	 }
	 public float getDestroysRate() {
		 return destroysRate.getRate();
	 }
	 public float getDiskReadsRate() {
		 return diskReadsRate.getRate();
	 }
	 public float getDiskWritesRate() {
		 return diskWritesRate.getRate();
	 }
	 public int getTotalBackupInProgress() {
		 return diskMonitor.getBackupsInProgress();
	 }
	 public int getTotalBackupCompleted() {
		 return diskMonitor.getBackupsCompleted();
	 }
	 public long getDiskFlushAvgLatency() {
		 return diskFlushAvgLatency.getAverageLatency();
	 }
	 public float getFunctionExecutionRate() {
		 return functionExecutionRate.getRate();
	 }
	 public long getGetsAvgLatency() {
		 return getsAvgLatency.getAverageLatency();
	 }
	 public float getGetsRate() {
		 this.instGetsRate = getsRate.getRate();
		 return instGetsRate;
	 }
	 public int getLockWaitsInProgress() {
		 return getMemberLevelStatistic(StatsKey.LOCK_WAITS_IN_PROGRESS).intValue();
	 }
	 public int getNumRunningFunctions() {
		 return getMemberLevelStatistic(StatsKey.FUNCTION_EXECUTIONS_RUNNING).intValue();
	 }
	 public int getNumRunningFunctionsHavingResults() {
		 return getMemberLevelStatistic(StatsKey.FUNCTION_EXECUTIONS_HASRESULT_RUNNING).intValue();
	 }
	 public long getPutAllAvgLatency() {
		 return putAllAvgLatency.getAverageLatency();
	 }
	 public float getPutAllRate() {
		 this.instPutAllRate = putAllRate.getRate();
		 return instPutAllRate;
	 }
	 public long getPutsAvgLatency() {
		 return putsAvgLatency.getAverageLatency();
	 }
	 public float getPutsRate() {
		 this.instPutsRate = putsRate.getRate();
		 return instPutsRate;
	 }
	 public int getLockRequestQueues() {
		 return getMemberLevelStatistic(StatsKey.LOCK_REQUEST_QUEUE).intValue();
	 }
	 public int getPartitionRegionCount() {
		 return getMemberLevelStatistic(StatsKey.PARTITIONED_REGIONS).intValue();
	 }
	 public int getTotalPrimaryBucketCount() {
		 return regionMonitor.getTotalPrimaryBucketCount();
	 }
	 public int getTotalBucketCount() {
		 return regionMonitor.getTotalBucketCount();
	 }
	 public int getTotalBucketSize() {
		 return regionMonitor.getTotalBucketSize();
	 }
	 public int getTotalHitCount() {
		 return getMemberLevelStatistic(StatsKey.GETS).intValue() - getTotalMissCount();
	 }
	 public float getLruDestroyRate() {
		 return lruDestroyRate.getRate();
	 }
	 public float getLruEvictionRate() {
		 return lruEvictionRate.getRate();
	 }
	 public int getTotalLoadsCompleted() {
		 return getMemberLevelStatistic(StatsKey.LOADS_COMPLETED).intValue();
	 }
	 public long getLoadsAverageLatency() {
		 return loadsAverageLatency.getAverageLatency();
	 }
	 public int getTotalNetLoadsCompleted() {
		 return getMemberLevelStatistic(StatsKey.NET_LOADS_COMPLETED).intValue();
	 }
	 public long getNetLoadsAverageLatency() {
		 return netLoadsAverageLatency.getAverageLatency();
	 }
	 public int getTotalNetSearchCompleted() {
		 return getMemberLevelStatistic(StatsKey.NET_SEARCH_COMPLETED).intValue();
	 }
	 public long getNetSearchAverageLatency() {
		 return netSearchAverageLatency.getAverageLatency();
	 }
	 public long getTotalLockWaitTime() {
		 return getMemberLevelStatistic(StatsKey.LOCK_WAIT_TIME).intValue();
	 }
	 public int getTotalMissCount() {
		 return getMemberLevelStatistic(StatsKey.MISSES).intValue();
	 }
	 public int getTotalNumberOfLockService() {
		 return getMemberLevelStatistic(StatsKey.LOCK_SERVICES).intValue();
	 }
	 public int getTotalNumberOfGrantors() {
		 return getMemberLevelStatistic(StatsKey.LOCK_GRANTORS).intValue();
	 }
	 public int getTotalDiskTasksWaiting() {
		 return getMemberLevelStatistic(StatsKey.TOTAL_DISK_TASK_WAITING).intValue();
	 }
	 public int getTotalRegionCount() {
		 return getMemberLevelStatistic(StatsKey.REGIONS).intValue();
	 }
	 public int getTotalRegionEntryCount() {
		 return getMemberLevelStatistic(StatsKey.ENTRIES).intValue();
	 }
	 public int getTotalTransactionsCount() {
		 return getMemberLevelStatistic(StatsKey.TRANSACTION_COMMITS).intValue() + getMemberLevelStatistic(StatsKey.TRANSACTION_ROLLBACKS).intValue();
	 }
	 public long getTransactionCommitsAvgLatency() {
		 return transactionCommitsAvgLatency.getAverageLatency();
	 }
	 public float getTransactionCommitsRate() {
		 return transactionCommitsRate.getRate();
	 }
	 public int getTransactionCommittedTotalCount() {
		 return getMemberLevelStatistic(StatsKey.TRANSACTION_COMMITS).intValue();
	 }
	 public int getTransactionRolledBackTotalCount() {
		 return getMemberLevelStatistic(StatsKey.TRANSACTION_ROLLBACKS).intValue();
	 }
	 public long getDeserializationAvgLatency() {
		 return deserializationAvgLatency.getAverageLatency();
	 }
	 public long getDeserializationLatency() {
		 return deserializationLatency.getLatency();
	 }
	 public float getDeserializationRate() {
		 return deserializationRate.getRate();
	 }
	 public long getSerializationAvgLatency() {
		 return serializationAvgLatency.getAverageLatency();
	 }
	 public long getSerializationLatency() {
		 return serializationLatency.getLatency();
	 }
	 public float getSerializationRate() {
		 return serializationRate.getRate();
	 }
	 public long getPDXDeserializationAvgLatency() {
		 return pdxDeserializationAvgLatency.getAverageLatency();
	 }
	 public float getPDXDeserializationRate() {
		 return pdxDeserializationRate.getRate();
	 }
	 public String processCommand(String commandString, Map<String, String> env, List<String> stagedFilePaths) {
		 if (commandProcessor == null) {
			 throw new JMRuntimeException( ""Command can not be processed as Command Service did not get initialized. Reason: "" + commandServiceInitError);
		 }
		 Object result = commandProcessor.executeCommand(commandString, env, stagedFilePaths);
		 if (result instanceof CommandResult) {
			 return CommandResponseBuilder.createCommandResponseJson(getMember(), (CommandResult) result);
		 }
		 else {
			 return CommandResponseBuilder.createCommandResponseJson(getMember(), (ResultModel) result);
		 }
	 }
	 public long getTotalDiskUsage() {
		 return regionMonitor.getDiskSpace();
	 }
	 public float getAverageReads() {
		 return instGetsRate;
	 }
	 public float getAverageWrites() {
		 return instCreatesRate + instPutsRate + instPutAllRate;
	 }
	 public long getGarbageCollectionTime() {
		 return getGCStatistic(StatsKey.VM_GC_STATS_COLLECTION_TIME).longValue();
	 }
	 public long getGarbageCollectionCount() {
		 return getGCStatistic(StatsKey.VM_GC_STATS_COLLECTIONS).longValue();
	 }
	 public long getJVMPauses() {
		 return getSystemStatistic(StatsKey.JVM_PAUSES).intValue();
	 }
	 public double getLoadAverage() {
		 return osBean.getSystemLoadAverage();
	 }
	 public int getNumThreads() {
		 return getVMStatistic(StatsKey.VM_STATS_NUM_THREADS).intValue();
	 }
	 public long getFileDescriptorLimit() {
		 if (!osName.startsWith(ManagementConstants.LINUX_SYSTEM)) {
			 return -1;
		 }
		 long maxFileDescriptorCount = 0;
		 try {
			 maxFileDescriptorCount = (Long) mbeanServer.getAttribute(osObjectName, ""MaxFileDescriptorCount"");
		 }
		 catch (Exception ignore) {
			 maxFileDescriptorCount = -1;
		 }
		 return maxFileDescriptorCount;
	 }
	 public long getTotalFileDescriptorOpen() {
		 if (!osName.startsWith(ManagementConstants.LINUX_SYSTEM)) {
			 return -1;
		 }
		 return getVMStatistic(StatsKey.VM_STATS_OPEN_FDS).longValue();
	 }
	 public int getOffHeapObjects() {
		 int objects = 0;
		 OffHeapMemoryStats stats = getOffHeapStats();
		 if (null != stats) {
			 objects = stats.getObjects();
		 }
		 return objects;
	 }
	 public long getOffHeapFreeSize() {
		 return getOffHeapFreeMemory();
	 }
	 public long getOffHeapUsedSize() {
		 return getOffHeapUsedMemory();
	 }
	 public long getOffHeapMaxMemory() {
		 long usedSize = 0;
		 OffHeapMemoryStats stats = getOffHeapStats();
		 if (null != stats) {
			 usedSize = stats.getMaxMemory();
		 }
		 return usedSize;
	 }
	 public long getOffHeapFreeMemory() {
		 long freeSize = 0;
		 OffHeapMemoryStats stats = getOffHeapStats();
		 if (null != stats) {
			 freeSize = stats.getFreeMemory();
		 }
		 return freeSize;
	 }
	 public long getOffHeapUsedMemory() {
		 long usedSize = 0;
		 OffHeapMemoryStats stats = getOffHeapStats();
		 if (null != stats) {
			 usedSize = stats.getUsedMemory();
		 }
		 return usedSize;
	 }
	 public int getOffHeapFragmentation() {
		 int fragmentation = 0;
		 OffHeapMemoryStats stats = getOffHeapStats();
		 if (null != stats) {
			 fragmentation = stats.getFragmentation();
		 }
		 return fragmentation;
	 }
	 public long getOffHeapCompactionTime() {
		 long compactionTime = 0;
		 OffHeapMemoryStats stats = getOffHeapStats();
		 if (null != stats) {
			 compactionTime = stats.getDefragmentationTime();
		 }
		 return compactionTime;
	 }
	 private OffHeapMemoryStats getOffHeapStats() {
		 OffHeapMemoryStats stats = null;
		 MemoryAllocator offHeap = this.cache.getOffHeapStore();
		 if (null != offHeap) {
			 stats = offHeap.getStats();
		 }
		 return stats;
	 }
	 public int getHostCpuUsage() {
		 if (systemStat != null) {
			 return systemStat.get(StatsKey.SYSTEM_CPU_ACTIVE).intValue();
		 }
		 else {
			 return ManagementConstants.NOT_AVAILABLE_INT;
		 }
	 }
	 public boolean isCacheServer() {
		 return cacheServer;
	 }
	 public void setCacheServer(boolean cacheServer) {
		 this.cacheServer = cacheServer;
	 }
	 public String getRedundancyZone() {
		 return redundancyZone;
	 }
	 public int getRebalancesInProgress() {
		 return resourceManagerStats.getRebalancesInProgress();
	 }
	 public int getReplyWaitsInProgress() {
		 return getMemberLevelStatistic(StatsKey.REPLY_WAITS_IN_PROGRESS).intValue();
	 }
	 public int getReplyWaitsCompleted() {
		 return getMemberLevelStatistic(StatsKey.REPLY_WAITS_COMPLETED).intValue();
	 }
	 public int getVisibleNodes() {
		 return getMemberLevelStatistic(StatsKey.NODES).intValue();
	 }
	 public long getMaxMemory() {
		 Runtime rt = Runtime.getRuntime();
		 return rt.maxMemory() / MBFactor;
	 }
	 public long getFreeMemory() {
		 Runtime rt = Runtime.getRuntime();
		 return rt.freeMemory() / MBFactor;
	 }
	 public long getUsedMemory() {
		 return getVMStatistic(StatsKey.VM_USED_MEMORY).longValue() / MBFactor;
	 }
	 public String getReleaseVersion() {
		 return GemFireVersion.getGemFireVersion();
	 }
}",1,1,0,0
"private SimpleDateFormat createFormat(DateResolution dateResolution) {
	 switch (dateResolution) {
		 case Year: return new SimpleDateFormat(""yyyy"");
		 case Month: return new SimpleDateFormat(""yyyyMM"");
		 case Day: return new SimpleDateFormat(""yyyyMMdd"");
		 case Hour: return new SimpleDateFormat(""yyyyMMddhh"");
		 case Minute: return new SimpleDateFormat(""yyyyMMddhhmm"");
		 case Second: return new SimpleDateFormat(""yyyyMMddhhmmss"");
		 default: return new SimpleDateFormat(""yyyyMMddhhmmssSSS"");
	 }
 }",0,0,1,0
"public class TestPruneColumn {
	 private PigServer pigServer;
	 File tmpFile1;
	 File tmpFile2;
	 File tmpFile3;
	 File tmpFile4;
	 File tmpFile5;
	 File tmpFile6;
	 File tmpFile7;
	 File tmpFile8;
	 File tmpFile9;
	 File tmpFile10;
	 File tmpFile11;
	 File tmpFile12;
	 File tmpFile13;
	 File logFile;
	 private static final String simpleEchoStreamingCommand;
	 static {
		 String quote = ""'"";
		 if (Util.WINDOWS) {
			 quote = ""\"""";
		 }
		 simpleEchoStreamingCommand = ""perl -ne "" + quote + ""print $_"" + quote;
	 }
	 static public class MyFilterFunc extends FilterFunc {
		 public Boolean exec(Tuple input) {
			 return true;
		 }
	 }
	 public void setUp() throws Exception{
		 Logger logger = Logger.getLogger(ColumnPruneVisitor.class);
		 logger.removeAllAppenders();
		 logger.setLevel(Level.INFO);
		 PatternLayout layout = new PatternLayout();
		 logFile = File.createTempFile(""log"", """");
		 FileAppender appender = new FileAppender(layout, logFile.toString(), false, false, 0);
		 logger.addAppender(appender);
		 pigServer = new PigServer(Util.getLocalTestMode());
		 tmpFile1 = File.createTempFile(""prune"", ""txt"");
		 PrintStream ps = new PrintStream(new FileOutputStream(tmpFile1));
		 ps.println(""1\t2\t3"");
		 ps.println(""2\t5\t2"");
		 ps.close();
		 tmpFile2 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile2));
		 ps.println(""1\t1"");
		 ps.println(""2\t2"");
		 ps.close();
		 tmpFile3 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile3));
		 ps.println(""1\t[key1#1,key2#2]"");
		 ps.println(""2\t[key1#2,key2#4]"");
		 ps.close();
		 tmpFile4 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile4));
		 ps.println(""1\t2\t3"");
		 ps.println(""1\t2\t3"");
		 ps.close();
		 tmpFile5 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile5));
		 ps.println(""1\t2\t3\t4"");
		 ps.println(""2\t3\t4\t5"");
		 ps.close();
		 tmpFile6 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile6));
		 ps.println(""\t2\t3"");
		 ps.println(""2\t3\t4"");
		 ps.close();
		 tmpFile7 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile7));
		 ps.println(""1\t1\t1"");
		 ps.println(""2\t2\t2"");
		 ps.close();
		 tmpFile8 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile8));
		 ps.println(""1\t2\t3\t4"");
		 ps.println(""2\t5\t2\t3"");
		 ps.close();
		 tmpFile9 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile9));
		 ps.println(""1\t[key1#1,key2#2]\t[key3#8,key4#9]"");
		 ps.println(""2\t[key1#2,key2#4]\t[key3#8,key4#9]"");
		 ps.close();
		 tmpFile10 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile10));
		 ps.println(""1\t[1#1,2#1]\t2"");
		 ps.close();
		 tmpFile11 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile11));
		 ps.println(""1\t2\t3"");
		 ps.println(""1\t3\t2"");
		 ps.println(""2\t5\t2"");
		 ps.close();
		 tmpFile12 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile12));
		 ps.println(""[key1#1,key2#2,cond#1]"");
		 ps.println(""[key1#2,key2#3,cond#1]"");
		 ps.close();
		 tmpFile13 = File.createTempFile(""prune"", ""txt"");
		 ps = new PrintStream(new FileOutputStream(tmpFile13));
		 ps.println(""3\ti"");
		 ps.println(""3\ti"");
		 ps.println(""1\ti"");
		 ps.println(""2\ti"");
		 ps.println(""2\ti"");
		 ps.println(""3\ti"");
		 ps.close();
	 }
	 public void tearDown() throws Exception{
		 tmpFile1.delete();
		 tmpFile2.delete();
		 tmpFile3.delete();
		 tmpFile4.delete();
		 tmpFile5.delete();
		 tmpFile6.delete();
		 tmpFile7.delete();
		 tmpFile8.delete();
		 tmpFile9.delete();
		 tmpFile10.delete();
		 tmpFile11.delete();
		 tmpFile12.delete();
		 logFile.delete();
	 }
	 public boolean checkLogFileMessage(String[] messages) {
		 BufferedReader reader = null;
		 try {
			 reader = new BufferedReader(new FileReader(logFile));
			 List<String> logMessages=new ArrayList<String>();
			 String line;
			 while ((line=reader.readLine())!=null) {
				 logMessages.add(line);
			 }
			 if (logMessages.size() > 0) {
				 logMessages = TestHelper.sortSubFields(logMessages);
			 }
			 for (int i=0;
			i<messages.length;
			i++) {
				 boolean found = false;
				 for (int j=0;
				j<logMessages.size();
				j++) if (logMessages.get(j).contains(messages[i])) {
					 found = true;
					 break;
				 }
				 if (!found) return false;
			 }
			 for (int i=0;
			i<logMessages.size();
			i++) {
				 boolean found = false;
				 for (int j=0;
				j<messages.length;
				j++) {
					 if (logMessages.get(i).contains(messages[j])) {
						 found = true;
						 break;
					 }
				 }
				 if (!found) {
					 if (logMessages.get(i).contains(""Columns pruned for"")|| logMessages.get(i).contains(""Map key required for"")) {
						 return false;
					 }
				 }
			 }
			 return true;
		 }
		 catch (IOException e) {
			 return false;
		 }
	 }
	 public boolean emptyLogFileMessage() {
		 if (!logFile.exists()) return true;
		 BufferedReader reader = null;
		 String line;
		 try {
			 reader = new BufferedReader(new FileReader(logFile));
			 while ((line=reader.readLine())!=null) {
				 if (line!=null && !line.equals("""")) return false;
			 }
			 return true;
		 }
		 catch (IOException e) {
			 return false;
		 }
	 }
	 public void testLoadForEach1() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = foreach A generate a1, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(3, t.get(1));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(5, t.get(0));
		 assertEquals(2, t.get(1));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0""}
		));
	 }
	 public void testLoadForEach2() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(1, t.get(0));
		 assertEquals(3, t.get(1));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(2, t.get(1));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testLoadForEach3() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(1, t.get(0));
		 assertEquals(2, t.get(1));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(5, t.get(1));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $2""}
		));
	 }
	 public void testJoin1() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' as (b0:int, b1:int);
		"");
		 pigServer.registerQuery(""C = join A by a1, B by b1;
		"");
		 pigServer.registerQuery(""D = foreach C generate a1, a2, b0, b1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(4, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(3, t.get(1));
		 assertEquals(2, t.get(2));
		 assertEquals(2, t.get(3));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0""}
		));
	 }
	 public void testJoin2() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' as (b0:int, b1:int);
		"");
		 pigServer.registerQuery(""C = join A by a1, B by b1;
		"");
		 pigServer.registerQuery(""D = foreach C generate a1, a2, b1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(3, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(3, t.get(1));
		 assertEquals(2, t.get(2));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0"", ""Columns pruned for B: $0""}
		));
	 }
	 public void testForEachFilter() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = filter A by a2==3;
		"");
		 pigServer.registerQuery(""C = foreach B generate a0, a1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(1, t.get(0));
		 assertEquals(2, t.get(1));
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testForEach1() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1+a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(1, t.get(0));
		 assertEquals(5, t.get(1));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(7, t.get(1));
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testForEach2() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0 as b0, *;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(4, t.size());
		 assertEquals(1, t.get(0));
		 assertEquals(1, t.get(1));
		 assertEquals(2, t.get(2));
		 assertEquals(3, t.get(3));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(4, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(2, t.get(1));
		 assertEquals(5, t.get(2));
		 assertEquals(2, t.get(3));
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testSplit1() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""split A into B if $0<=1, C if $0>1;
		"");
		 pigServer.registerQuery(""D = foreach B generate $1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $2""}
		));
	 }
	 public void testSplit2() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""split A into B if $0<=1, C if $0>1;
		"");
		 pigServer.registerQuery(""D = foreach B generate $1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $2""}
		));
	 }
	 public void testForeachNoSchema1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""';
		"");
		 pigServer.registerQuery(""B = foreach A generate $1, $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""3"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""5"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testForeachNoSchema2() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""';
		"");
		 pigServer.registerQuery(""B = foreach A generate $1, 'aoeuaoeu';
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""aoeuaoeu"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""5"", t.get(0).toString());
		 assertEquals(""aoeuaoeu"", t.get(1).toString());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCoGroup1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:int, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1:int);
		"");
		 pigServer.registerQuery(""C = cogroup A by $1, B by $1;
		"");
		 pigServer.registerQuery(""D = foreach C generate AVG($1.$1);
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 String[] expectedRes = new String[]{
		""()"",""(2.0)"",""(5.0)""}
		;
		 Schema s = pigServer.dumpSchema(""D"");
		 Util.checkQueryOutputsAfterSortRecursive(iter,expectedRes,org.apache.pig.newplan.logical.Util.translateSchema(s));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for B: $0""}
		));
	 }
	 public void testCoGroup2() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:int, a2);
		"");
		 pigServer.registerQuery(""B = group A all;
		"");
		 pigServer.registerQuery(""C = foreach B generate $1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 String[] expected = new String[] {
			 ""({
			(1,2,3),(2,5,2)}
		)"" }
		;
		 assertTrue(iter.hasNext());
		 Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""C"")));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCoGroup3() throws Exception {
		 pigServer.registerQuery(""A = load '"" + Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:int, a2);
		"");
		 pigServer.registerQuery(""B = group A by $1;
		"");
		 pigServer.registerQuery(""C = foreach B generate $1, '1';
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
			 ""({
			(1,2,3)}
			,1)"", ""({
			(2,5,2)}
		,1)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""C"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCoGroup4() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:int, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1:int);
		"");
		 pigServer.registerQuery(""C = cogroup A by ($1), B by ($1);
		"");
		 pigServer.registerQuery(""D = foreach C generate $1.$1, $2.$1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
			 ""({
			}
			,{
			(1)}
			)"", ""({
			(2)}
			,{
			(2)}
			)"", ""({
			(5)}
			,{
			}
		)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""D"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCoGroup5() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = group A by (a0, a1);
		"");
		 pigServer.registerQuery(""C = foreach B generate flatten(group);
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""5"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $2""}
		));
	 }
	 public void testDistinct1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile4.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = distinct A;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testStream1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = stream A through `"" + simpleEchoStreamingCommand + ""`;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testBinCond1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile5.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2, a3);
		"");
		 pigServer.registerQuery(""B = foreach A generate ($1 == '2'? $2 : $3);
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""3"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""5"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0""}
		));
	 }
	 public void testCoGroup6() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1);
		"");
		 pigServer.registerQuery(""C = cogroup A by ($1), B by ($1);
		"");
		 pigServer.registerQuery(""D = foreach C generate A, flatten(B.($0, $1));
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
			 ""({
			}
			,1,1)"", ""({
			(1,2,3)}
		,2,2)"" }
		;
		 Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""D"")));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCoGroup7() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1);
		"");
		 pigServer.registerQuery(""C = cogroup A by ($1), B by ($1);
		"");
		 pigServer.registerQuery(""D = foreach C {
			B = order B by $0;
			generate FLATTEN(A), B.($1);
		}
		;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
			 ""(1,2,3,{
			(2)}
			)"", ""(2,5,2,{
			}
		)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""D"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCross1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1);
		"");
		 pigServer.registerQuery(""C = cross A, B;
		"");
		 pigServer.registerQuery(""D = foreach C generate $0, $3;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(1,1)"");
		 results.add(""(2,1)"");
		 results.add(""(1,2)"");
		 results.add(""(2,2)"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2"", ""Columns pruned for B: $1""}
		));
	 }
	 public void testUnion1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile4.toString(), pigServer.getPigContext()) + ""' AS (b0, b1, b2);
		"");
		 pigServer.registerQuery(""C = union A, B;
		"");
		 pigServer.registerQuery(""D = foreach C generate $0, $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(1,3)"");
		 results.add(""(2,2)"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 results.contains(t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 results.contains(t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 results.contains(t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 results.contains(t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1"", ""Columns pruned for B: $1""}
		));
	 }
	 public void testFRJoin1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1);
		"");
		 pigServer.registerQuery(""C = join A by $0, B by $0 using 'replicated';
		"");
		 pigServer.registerQuery(""D = foreach C generate $0, $3;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
		 ""(1,1)"", ""(2,2)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""D"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2"", ""Columns pruned for B: $1""}
		));
	 }
	 public void testFilter1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = order A by a1;
		"");
		 pigServer.registerQuery(""C = limit B 10;
		"");
		 pigServer.registerQuery(""D = foreach C generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $2""}
		));
	 }
	 public void testFilter2() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = filter A by a0+a2 == 4;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testOrderBy1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = order A by $0;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2""}
		));
	 }
	 public void testOrderBy2() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = order A by *;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testCogroup8() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = group A by *;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
		 ""((1,2,3))"", ""((2,5,2))"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""C"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testJoin3() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile4.toString(), pigServer.getPigContext()) + ""' AS (b0, b1, b2);
		"");
		 pigServer.registerQuery(""C = join A by *, B by * using 'replicated';
		"");
		 pigServer.registerQuery(""D = foreach C generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testLoadForEach4() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate *;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2""}
		));
	 }
	 public void testForEachUDF() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0:chararray, a1:chararray, a2:chararray);
		"");
		 pigServer.registerQuery(""B = foreach A generate StringSize(*);
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testOutJoin1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile6.toString(), pigServer.getPigContext()) + ""' AS (a0:chararray, a1:chararray, a2:chararray);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (a0:chararray, a1:chararray, a2:chararray);
		"");
		 pigServer.registerQuery(""C = join A by $0 left, B by $0;
		"");
		 pigServer.registerQuery(""D = foreach C generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(2)"");
		 results.add(""()"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2"", ""Columns pruned for B: $1, $2""}
		));
	 }
	 public void testFilter3() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = filter A by "" + MyFilterFunc.class.getName() + ""(*) ;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testMapKey1() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:map[]);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1#'key1';
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(1, t.get(0));
		 assertEquals(""1"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(2, t.get(0));
		 assertEquals(""2"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Map key required for A: $1->[key1]""}
		));
	 }
	 public void testMapKey2() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:map[]);
		"");
		 pigServer.registerQuery(""B = foreach A generate a1, a1#'key1';
		"");
		 pigServer.registerQuery(""C = foreach B generate $0#'key2', $1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""1"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""4"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0"", ""Map key required for A: $1->[key1, key2]""}
		));
	 }
	 public void testMapKey3() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:map[]);
		"");
		 pigServer.registerQuery(""B = foreach A generate a1, a1#'key1';
		"");
		 pigServer.registerQuery(""C = group B all;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 String[] expected = new String[] {
			 ""(all,{
			([key2#2,key1#1],1),([key2#4,key1#2],2)}
		)"" }
		;
		 Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""C"")));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0""}
		));
	 }
	 public void testMapKey4() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:map[]);
		"");
		 pigServer.registerQuery(""B = limit A 10;
		"");
		 pigServer.registerQuery(""C = foreach B generate $0, $1#'key1';
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""1"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Map key required for A: $1->[key1]""}
		));
	 }
	 public void testMapKey5() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:map[]);
		"");
		 pigServer.registerQuery(""B = foreach A generate $0, $1#'key1';
		"");
		 pigServer.registerQuery(""C = stream B through `"" + simpleEchoStreamingCommand + ""`;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""1"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Map key required for A: $1->[key1]""}
		));
	 }
	 public void testMapKeyInSplit1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile12.toString(), pigServer.getPigContext()) + ""' as (m:map[]);
		"");
		 pigServer.registerQuery(""B = foreach A generate m#'key1' as key1;
		"");
		 pigServer.registerQuery(""C = foreach A generate m#'key2' as key2;
		"");
		 pigServer.registerQuery(""D = join B by key1, C by key2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Map key required for A: $0->[key1, key2]""}
		));
	 }
	 public void testMapKeyInSplit2() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile12.toString(), pigServer.getPigContext()) + ""' as (m:map[]);
		"");
		 pigServer.registerQuery(""B = filter A by m#'cond'==1;
		"");
		 pigServer.registerQuery(""C = filter B by m#'key1'==1;
		"");
		 pigServer.registerQuery(""D = filter B by m#'key2'==2;
		"");
		 pigServer.registerQuery(""E = join C by m#'key1', D by m#'key1';
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""E"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", ((Map)t.get(0)).get(""key1"").toString());
		 assertEquals(""2"", ((Map)t.get(0)).get(""key2"").toString());
		 assertEquals(""1"", ((Map)t.get(0)).get(""cond"").toString());
		 assertEquals(""1"", ((Map)t.get(1)).get(""key1"").toString());
		 assertEquals(""2"", ((Map)t.get(1)).get(""key2"").toString());
		 assertEquals(""1"", ((Map)t.get(1)).get(""cond"").toString());
		 assertFalse(iter.hasNext());
		 assertTrue(this.emptyLogFileMessage());
	 }
	 public void testConstantPlan() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate 1, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""3"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0, $1""}
		));
	 }
	 public void testPlainPlan() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = order A by $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(3, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""2"", t.get(1).toString());
		 assertEquals(""3"", t.get(2).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(3, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""5"", t.get(1).toString());
		 assertEquals(""2"", t.get(2).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testBinStorage1() throws Exception {
		 File intermediateFile = File.createTempFile(""intemediate"", ""txt"");
		 intermediateFile.delete();
		 String clusterPath = Util.removeColon(intermediateFile.getAbsolutePath());
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.store(""A"", clusterPath, ""BinStorage()"");
		 pigServer.registerQuery(""A = load '""+ Util.encodeEscape(clusterPath) + ""' using BinStorage() as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2""}
		));
	 }
	 public void testBinStorage2() throws Exception {
		 File intermediateFile = File.createTempFile(""intemediate"", ""txt"");
		 intermediateFile.delete();
		 String clusterPath = Util.removeColon(intermediateFile.getAbsolutePath());
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.store(""A"", clusterPath, ""BinStorage()"");
		 pigServer.registerQuery(""A = load '""+ Util.encodeEscape(clusterPath) + ""' using BinStorage() as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a2, a0, a1;
		"");
		 pigServer.registerQuery(""C = foreach B generate a0, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertEquals(""3"", t.get(1).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testProjectCastKeyLookup() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0, a1);
		"");
		 pigServer.registerQuery(""B = foreach A generate a1#'key1';
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0"", ""Map key required for A: $1->[key1]""}
		));
	 }
	 public void testFlattenMapCantPruneKeys() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile3.toString(), pigServer.getPigContext()) + ""' as (a0, a1:map[int]);
		"");
		 pigServer.registerQuery(""B = foreach A generate flatten(a1);
		"");
		 pigServer.registerQuery(""B1 = filter B by a1::key == 'key1';
		"");
		 pigServer.registerQuery(""C = foreach B1 generate a1::value;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""1"", t.get(0).toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""2"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0""}
		));
	 }
	 public void testCrossAtLeastOneColumnOneInput() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' as (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' as (b0:int, b1:int);
		"");
		 pigServer.registerQuery(""C = cross A, B;
		"");
		 pigServer.registerQuery(""D = foreach C generate $0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(1)"");
		 results.add(""(2)"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1, $2"", ""Columns pruned for B: $1""}
		));
	 }
	 public void testComplex1() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile7.toString(), pigServer.getPigContext()) + ""' as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile8.toString(), pigServer.getPigContext()) + ""' as (b0, b1, b2, b3);
		"");
		 pigServer.registerQuery(""B1 = foreach B generate b2, b0+b3;
		"");
		 pigServer.registerQuery(""C = join A by $0, B1 by $0;
		"");
		 pigServer.registerQuery(""D = order C by $4;
		"");
		 pigServer.registerQuery(""E = foreach D generate $0, $2;
		"");
		 pigServer.registerQuery(""F = filter E by $1<10;
		"");
		 pigServer.registerQuery(""G = group F by $0;
		"");
		 pigServer.registerQuery(""H = foreach G generate $1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""H"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""{
		(2,2)}
		"", t.get(0).toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1"", ""Columns pruned for B: $1""}
		));
	 }
	 public void testComplex2() throws Exception {
		 HashSet<String> optimizerRules = new HashSet<String>();
		 optimizerRules.add(""PushUpFilter"");
		 pigServer.getPigContext().getProperties().setProperty( PigImplConstants.PIG_OPTIMIZER_RULES_KEY, ObjectSerializer.serialize(optimizerRules));
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile13.toString(), pigServer.getPigContext()) + ""' as (a:int, b:chararray);
		"");
		 pigServer.registerQuery(""B = FOREACH A generate a;
		"");
		 pigServer.registerQuery(""C = GROUP B by a;
		"");
		 pigServer.registerQuery(""D = filter C by group > 0 and group < 100;
		"");
		 pigServer.registerQuery(""E = FOREACH D {
			F = LIMIT B 1 ;
			GENERATE B.a as mya, FLATTEN(F.a) as setting;
		}
		"");
		 pigServer.registerQuery(""G = FOREACH E GENERATE mya, setting as setting;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""G"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
			 ""({
			(1)}
			,1)"", ""({
			(2),(2)}
			,2)"", ""({
			(3),(3),(3)}
		,3)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""G"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
		 pigServer.getPigContext().getProperties().remove(PigImplConstants.PIG_OPTIMIZER_RULES_KEY);
	 }
	 public void testCoGroup8() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:int, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1:int);
		"");
		 pigServer.registerQuery(""C = cogroup A by ($1), B by ($1);
		"");
		 pigServer.registerQuery(""D = foreach C generate $0, $1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
			 ""(1,{
			}
			)"", ""(2,{
			(1,2,3)}
			)"", ""(5,{
			(2,5,2)}
		)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""D"")) , Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for B: $0""}
		));
	 }
	 public void testUserDefinedSchema() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS ( c1 : chararray, c2 : int);
		"");
		 pigServer.registerQuery(""B = foreach A generate c1 as c1 : chararray, c2 as c2 : int, 'CA' as state : chararray;
		"");
		 pigServer.registerQuery(""C = foreach B generate c1 as c1 : chararray;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""(1)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(""(2)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testSharedSchemaObject() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile10.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:map[], a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a1;
		"");
		 pigServer.registerQuery(""C = limit B 10;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""([1#1, 2#1])"", TestHelper.sortString(""\\[(.*)\\]"", t.toString(), "",""));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0, $2""}
		));
	 }
	 public void testJoin4() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (b0, b1, b2);
		"");
		 pigServer.registerQuery(""C = join A by a2, B by b2;
		"");
		 pigServer.registerQuery(""D = foreach C generate $0, $1, $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(1,2,3)"");
		 results.add(""(2,5,2)"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertTrue(results.contains(t.toString()));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for B: $0, $1""}
		));
	 }
	 public void testFilter4() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2:int);
		"");
		 pigServer.registerQuery(""B = filter A by a2==3;
		"");
		 pigServer.registerQuery(""C = foreach B generate $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""(3)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0, $1""}
		));
	 }
	 public void testSplit3() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2:int);
		"");
		 pigServer.registerQuery(""split A into B if a2==3, C if a2<3;
		"");
		 pigServer.registerQuery(""C = foreach B generate $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""(3)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0, $1""}
		));
	 }
	 public void testOrderBy3() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = order A by a2;
		"");
		 pigServer.registerQuery(""C = foreach B generate a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""(2)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertEquals(""(3)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0, $1""}
		));
	 }
	 public void testCogroup9() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (b0, b1, b2);
		"");
		 pigServer.registerQuery(""C = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (c0, c1, c2);
		"");
		 pigServer.registerQuery(""D = cogroup A by a2, B by b2, C by c2;
		"");
		 pigServer.registerQuery(""E = foreach D generate $1, $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""E"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""({
		(2,5,2)}
		,{
		(2,5,2)}
		)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""({
		(1,2,3)}
		,{
		(1,2,3)}
		)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for C: $0, $1""}
		));
	 }
	 public void testOrderbyWrongSignature() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b1);
		"");
		 pigServer.registerQuery(""C = order A by a1;
		"");
		 pigServer.registerQuery(""D = join C by a1, B by b0;
		"");
		 pigServer.registerQuery(""E = foreach D generate a1, b0, b1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""E"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(3, t.size());
		 assertEquals(""(2,2,2)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $0, $2""}
		));
	 }
	 public void testUnionMixedPruning() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:chararray, a2);
		"");
		 pigServer.registerQuery(""B = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (b0, b2);
		"");
		 pigServer.registerQuery(""C = foreach B generate b0, 'hello', b2;
		"");
		 pigServer.registerQuery(""D = union A, C;
		"");
		 pigServer.registerQuery(""E = foreach D generate $0, $2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""E"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(1,3)"");
		 results.add(""(2,2)"");
		 results.add(""(1,1)"");
		 results.add(""(2,2)"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(2, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testUnionMixedSchemaPruning() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0;
		;
		"");
		 pigServer.registerQuery(""C = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""';
		"");
		 pigServer.registerQuery(""D = foreach C generate $0;
		"");
		 pigServer.registerQuery(""E = union B, D;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""E"");
		 Collection<String> results = new HashSet<String>();
		 results.add(""(1)"");
		 results.add(""(2)"");
		 results.add(""(1)"");
		 results.add(""(2)"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(1, t.size());
		 assertTrue(results.contains(t.toString()));
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testForEachFlatten() throws Exception {
		 File inputFile = Util.createInputFile(""table_testForEachFlatten"", """", new String[]{
			""oiue\tM\t{
			(3),(4)}
			\t{
			(toronto),(montreal)}
		""}
		);
		 pigServer.registerQuery(""A = load '""+Util.encodeEscape(inputFile.toString())+""' as (a0:chararray, a1:chararray, a2:bag{
		t:tuple(id:chararray)}
		, a3:bag{
		t:tuple(loc:chararray)}
		);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1, flatten(a2), flatten(a3), 10;
		"");
		 pigServer.registerQuery(""C = foreach B generate a0, $4;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""(oiue,10)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(""(oiue,10)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(""(oiue,10)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(""(oiue,10)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testFieldsToReadDuplicatedEntry() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0+a0, a1, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""(2.0,2,3)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(""(4.0,5,2)"", t.toString());
		 assertFalse(iter.hasNext());
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testSplit4() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0;
		"");
		 pigServer.registerQuery(""C = join A by a0, B by a0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 String[] expected = new String[] {
		 ""(1,2,3,1)"", ""(2,5,2,2)"" }
		;
		 Util.checkQueryOutputs(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""C"")), Util.isSparkExecType(Util.getLocalTestMode()));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testSplit5() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile11.toString(), pigServer.getPigContext()) + ""' AS (a0:int, a1:int, a2:int);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1;
		"");
		 pigServer.registerQuery(""C = join A by a0, B by a0;
		"");
		 pigServer.registerQuery(""D = filter C by A::a1>=B::a1;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""D"");
		 String [] expected = new String[] {
		 ""(1,2,3,1,2)"", ""(1,3,2,1,2)"", ""(1,3,2,1,3)"", ""(2,5,2,2,5)"" }
		;
		 Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""D"")));
		 assertTrue(emptyLogFileMessage());
	 }
	 public void testInconsistentPruning() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' AS (a0:chararray, a1:chararray, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate CONCAT(a0,a1) as b0, a0, a2;
		"");
		 pigServer.registerQuery(""C = foreach B generate a0, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""C"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(""(1,3)"", t.toString());
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertEquals(""(2,2)"", t.toString());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testSplitOutputWithForEach() throws Exception {
		 Path output1 = FileLocalizer.getTemporaryPath(pigServer.getPigContext());
		 Path output2 = FileLocalizer.getTemporaryPath(pigServer.getPigContext());
		 pigServer.setBatchOn();
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile5.toString(), pigServer.getPigContext()) + ""' AS (a0, a1, a2, a3);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1, a2;
		"");
		 pigServer.registerQuery(""store B into '"" + Util.generateURI(output1.toString(), pigServer.getPigContext()) + ""';
		"");
		 pigServer.registerQuery(""C = order B by a2;
		"");
		 pigServer.registerQuery(""D = foreach C generate a2;
		"");
		 pigServer.registerQuery(""store D into '"" + Util.generateURI(output2.toString(), pigServer.getPigContext()) + ""';
		"");
		 pigServer.executeBatch();
		 BufferedReader reader1 = new BufferedReader(new InputStreamReader(FileLocalizer.openDFSFile(output1.toString(), pigServer.getPigContext().getProperties())));
		 String line = reader1.readLine();
		 assertEquals(""1\t2\t3"", line);
		 line = reader1.readLine();
		 assertEquals(""2\t3\t4"", line);
		 assertNull(reader1.readLine());
		 BufferedReader reader2 = new BufferedReader(new InputStreamReader(FileLocalizer.openDFSFile(output2.toString(), pigServer.getPigContext().getProperties())));
		 line = reader2.readLine();
		 assertEquals(""3"", line);
		 line = reader2.readLine();
		 assertEquals(""4"", line);
		 assertNull(reader2.readLine());
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $3""}
		));
		 reader1.close();
		 reader2.close();
	 }
	 static public class PruneColumnEvalFunc extends LoadFunc implements LoadPushDown {
		 String[] aliases;
		 String signature;
		 public PruneColumnEvalFunc() {
		}
		 public RequiredFieldResponse pushProjection(RequiredFieldList requiredFieldList) throws FrontendException {
			 aliases = new String[requiredFieldList.getFields().size()];
			 for (int i=0;
			 i<requiredFieldList.getFields().size();
			 i++) {
				 RequiredField fs = requiredFieldList.getFields().get(i);
				 aliases[i] = fs.getAlias();
			 }
			 try {
				 UDFContext.getUDFContext().getUDFProperties(this.getClass()).setProperty(signature, ObjectSerializer.serialize(aliases));
			 }
			 catch (IOException e) {
				 throw new FrontendException(e);
			 }
			 return new RequiredFieldResponse(true);
		 }
		 public List<OperatorSet> getFeatures() {
			 return Arrays.asList(LoadPushDown.OperatorSet.PROJECTION);
		 }
		 public void setLocation(String location, Job job) throws IOException {
			 FileInputFormat.setInputPaths(job, location);
		 }
		 public InputFormat getInputFormat() throws IOException {
			 return new PigTextInputFormat();
		 }
		 public void prepareToRead(RecordReader reader, PigSplit split) throws IOException {
		 }
		 public void setUDFContextSignature(String signature) {
			 this.signature = signature;
		 }
		 public Tuple getNext() throws IOException {
			 if (aliases==null) {
				 aliases = (String[])ObjectSerializer.deserialize(UDFContext.getUDFContext().getUDFProperties(this.getClass()).getProperty(signature));
				 Tuple t = TupleFactory.getInstance().newTuple();
				 for (String s : aliases) t.append(s);
				 return t;
			 }
			 return null;
		 }
	 }
	 public void testAliasInRequiredFieldList() throws Exception{
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + ""' using "" + PruneColumnEvalFunc.class.getName() +""() as (a0, a1, a2);
		"");
		 pigServer.registerQuery(""B = foreach A generate a1, a2;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""B"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertEquals(2, t.size());
		 assertEquals(""a1"", t.get(0));
		 assertEquals(""a2"", t.get(1));
		 assertFalse(iter.hasNext());
	 }
	 public void testCogroup10() throws Exception {
		 pigServer.registerQuery(""A = load '""+ Util.generateURI(tmpFile2.toString(), pigServer.getPigContext()) + ""' AS (a0, a1:double);
		"");
		 pigServer.registerQuery(""B = foreach A generate a0, a1, 0 as joinField;
		"");
		 pigServer.registerQuery(""C = group B all;
		"");
		 pigServer.registerQuery(""D = foreach C generate 0 as joinField, SUM(B.a1) as total;
		"");
		 pigServer.registerQuery(""E = join B by joinField, D by joinField;
		"");
		 pigServer.registerQuery(""F = foreach E generate a0;
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""F"");
		 String[] expected = new String[] {
		""(1)"", ""(2)""}
		;
		 Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""F"")));
		 assertTrue(checkLogFileMessage(new String[]{
		""Columns pruned for A: $1""}
		));
	 }
	 public void testStream2() throws Exception {
		 File input1 = File.createTempFile(""tmp"", """");
		 input1.delete();
		 File input2 = File.createTempFile(""tmp"", """");
		 input2.delete();
		 Util.createLocalInputFile(input1.getAbsolutePath(), new String[] {
		""[key1#0,key2#5,key3#val3,key4#val4,key5#val5]""}
		);
		 Util.createLocalInputFile(input2.getAbsolutePath(), new String[] {
		""[key1#0,key2#5,key3#val3,key4#val4,key5#val5]""}
		);
		 pigServer.registerQuery(""event_serve = LOAD '"" + Util.encodeEscape(input1.getAbsolutePath()) + ""' AS (s, m, l);
		"");
		 pigServer.registerQuery(""cm_data_raw = LOAD '"" + Util.encodeEscape(input2.getAbsolutePath()) + ""' AS (s, m, l);
		"");
		 pigServer.registerQuery(""cm_serve = FOREACH cm_data_raw GENERATE s#'key3' AS f1, s#'key4' AS f2, s#'key5' AS f3 ;
		"");
		 pigServer.registerQuery(""cm_serve_lowercase = stream cm_serve through `tr '[:upper:]' '[:lower:]'`;
		"");
		 pigServer.registerQuery(""cm_serve_final = FOREACH cm_serve_lowercase GENERATE $0 AS cm_event_guid, $1 AS cm_receive_time, $2 AS cm_ctx_url;
		"");
		 pigServer.registerQuery(""event_serve_project = FOREACH event_serve GENERATE s#'key3' AS event_guid, s#'key4' AS receive_time;
		"");
		 pigServer.registerQuery(""event_serve_join = join cm_serve_final by (cm_event_guid), event_serve_project by (event_guid);
		"");
		 Iterator<Tuple> iter = pigServer.openIterator(""event_serve_join"");
		 String[] expected = new String[] {
		""(val3,val4,val5,val3,val4)""}
		;
		 Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema(""event_serve_join"")));
		 assertTrue(checkLogFileMessage(new String[]{
		""Map key required for event_serve: $0->[key3, key4]"", ""Map key required for cm_data_raw: $0->[key3, key4, key5]""}
		));
	 }
	 public void testStream3() throws Exception {
		 pigServer.registerQuery(""event_serve = LOAD 'input1' AS (s, m, l);
		"");
		 pigServer.registerQuery(""raw = LOAD 'input2' AS (s, m, l);
		"");
		 pigServer.registerQuery(""SPLIT raw INTO "" + ""serve_raw IF (( (chararray) (s#'type') == '0') AND ( (chararray) (s#'source') == '5')),"" + ""cm_click_raw IF (( (chararray) (s#'type') == '1') AND ( (chararray) (s#'source') == '5'));
		"");
		 pigServer.registerQuery(""cm_serve = FOREACH serve_raw GENERATE s#'cm_serve_id' AS cm_event_guid, s#'cm_serve_timestamp_ms' AS cm_receive_time, s#'p_url' AS ctx ;
		"");
		 pigServer.registerQuery(""cm_serve_lowercase = stream cm_serve through `tr '[:upper:]' '[:lower:]'`;
		"");
		 pigServer.registerQuery(""cm_serve_final = FOREACH cm_serve_lowercase GENERATE $0 AS cm_event_guid, $1 AS cm_receive_time, $2 AS ctx;
		"");
		 pigServer.registerQuery(""filtered = FILTER event_serve BY (chararray) (s#'filter_key') neq 'xxxx' AND (chararray) (s#'filter_key') neq 'yyyy';
		"");
		 pigServer.registerQuery(""event_serve_project = FOREACH filtered GENERATE s#'event_guid' AS event_guid, s#'receive_time' AS receive_time;
		"");
		 pigServer.registerQuery(""event_serve_join = join cm_serve_final by (cm_event_guid), event_serve_project by (event_guid);
		"");
		 pigServer.explain(""event_serve_join"", System.out);
		 assertTrue(checkLogFileMessage(new String[]{
		""Map key required for event_serve: $0->[event_guid, filter_key, receive_time]"", ""Map key required for raw: $0->[cm_serve_id, cm_serve_timestamp_ms, p_url, source, type]""}
		));
	 }
}",1,0,0,0
"public class Car2 {
	 private String numberPlate;
	 private String colour;
	 private int engineSize;
	 private int numberOfSeats;
	 public String getNumberPlate() {
		 return numberPlate;
	 }
	 public void setNumberPlate(String numberPlate) {
		 this.numberPlate = numberPlate;
	 }
	 public String getColour() {
		 return colour;
	 }
	 public void setColour(String colour) {
		 this.colour = colour;
	 }
	 public int getEngineSize() {
		 return engineSize;
	 }
	 public void setEngineSize(int engineSize) {
		 this.engineSize = engineSize;
	 }
	 public int getNumberOfSeats() {
		 return numberOfSeats;
	 }
	 public void setNumberOfSeats(int numberOfSeats) {
		 this.numberOfSeats = numberOfSeats;
	 }
}",0,1,0,0
"public void registerProjectsToFileBasedWorkspace(Iterable<URI> projectURIs, FileBasedWorkspace workspace)throws N4JSCompileException {
	Map<String, URI> registeredProjects = new HashMap<>();
	workspace.getAllProjectLocationsIterator().forEachRemaining(uri -> {
		String projectName = workspace.getProjectDescription(uri).getProjectName();
		registeredProjects.put(projectName, URIUtils.normalize(uri));
	}
	);
	for (URI uri : projectURIs) {
		URI projectURI = URIUtils.normalize(uri);
		final ProjectDescription projectDescription = projectDescriptionLoader.loadProjectDescriptionAtLocation(projectURI);
		if (projectDescription == null) {
			throw new N4JSCompileException(""Cannot load project description for project at "" + projectURI.toFileString()+ "". Make sure the project contains a valid package.json file."");
		}
		final String projectName = projectDescription.getProjectName();
		if (skipRegistering(projectName, projectURI, registeredProjects)) {
			if (logger != null && logger.isCreateDebugOutput()) {
				logger.debug(""Skipping already registered project '"" + projectURI + ""'"");
			}
			continue;
		}
		try {
			if (logger != null && logger.isCreateDebugOutput()) {
				logger.debug(""Registering project '"" + projectURI + ""'"");
			}
			workspace.registerProject(projectURI);
			registeredProjects.put(projectName, projectURI);
		}
		 catch (N4JSBrokenProjectException e) {
			throw new N4JSCompileException(""Unable to register project '"" + projectURI + ""'"", e);
		}
	}
}",0,0,1,0
"public abstract class AbstractEndpointSnitch implements IEndpointSnitch{
	 private static final Logger logger = LoggerFactory.getLogger(AbstractEndpointSnitch.class);
	 public abstract List<InetAddress> getSortedListByProximity(InetAddress address, Collection<InetAddress> unsortedAddress);
	 public abstract void sortByProximity(InetAddress address, List<InetAddress> addresses);
	 public int compareEndpoints(InetAddress target, InetAddress a1, InetAddress a2) {
		 return a1.getHostAddress().compareTo(a2.getHostAddress());
	 }
	 public void gossiperStarting() {
	 }
}",0,0,0,0
"protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) {
	 boolean rebuild = false;
	 JarFile genericJar = null;
	 JarFile wasJar = null;
	 File newwasJarFile = null;
	 JarOutputStream newJarStream = null;
	 ClassLoader genericLoader = null;
	 try {
		 log(""Checking if websphere Jar needs to be rebuilt for jar "" + websphereJarFile.getName(), Project.MSG_VERBOSE);
		 if (genericJarFile.exists() && genericJarFile.isFile() && websphereJarFile.exists() && websphereJarFile.isFile()) {
			 genericJar = new JarFile(genericJarFile);
			 wasJar = new JarFile(websphereJarFile);
			 Hashtable genericEntries = new Hashtable();
			 Hashtable wasEntries = new Hashtable();
			 Hashtable replaceEntries = new Hashtable();
			 for (Enumeration e = genericJar.entries();
			 e.hasMoreElements();
			) {
				 JarEntry je = (JarEntry) e.nextElement();
				 genericEntries.put(je.getName().replace('\\', '/'), je);
			 }
			 for (Enumeration e = wasJar.entries();
			 e.hasMoreElements();
			) {
				 JarEntry je = (JarEntry) e.nextElement();
				 wasEntries.put(je.getName(), je);
			 }
			 genericLoader = getClassLoaderFromJar(genericJarFile);
			 for (Enumeration e = genericEntries.keys();
			 e.hasMoreElements();
			) {
				 String filepath = (String) e.nextElement();
				 if (wasEntries.containsKey(filepath)) {
					 JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
					 JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);
					 if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {
						 if (genericEntry.getName().endsWith("".class"")) {
							 String classname = genericEntry.getName().replace(File.separatorChar, '.');
							 classname = classname.substring(0, classname.lastIndexOf("".class""));
							 Class genclass = genericLoader.loadClass(classname);
							 if (genclass.isInterface()) {
								 log(""Interface "" + genclass.getName() + "" has changed"", Project.MSG_VERBOSE);
								 rebuild = true;
								 break;
							 }
							 else {
								 replaceEntries.put(filepath, genericEntry);
							 }
						 }
						 else {
							 if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
								 log(""Non class file "" + genericEntry.getName() + "" has changed"", Project.MSG_VERBOSE);
								 rebuild = true;
							 }
							 break;
						 }
					 }
				 }
				 else {
					 log(""File "" + filepath + "" not present in websphere jar"", Project.MSG_VERBOSE);
					 rebuild = true;
					 break;
				 }
			 }
			 if (!rebuild) {
				 log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
				 newwasJarFile = new File(websphereJarFile.getAbsolutePath() + "".temp"");
				 if (newwasJarFile.exists()) {
					 newwasJarFile.delete();
				 }
				 newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));
				 newJarStream.setLevel(0);
				 for (Enumeration e = wasEntries.elements();
				 e.hasMoreElements();
				) {
					 byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
					 int bytesRead;
					 InputStream is;
					 JarEntry je = (JarEntry) e.nextElement();
					 if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) {
						 newJarStream.setLevel(0);
					 }
					 else {
						 newJarStream.setLevel(JAR_COMPRESS_LEVEL);
					 }
					 if (replaceEntries.containsKey(je.getName())) {
						 log(""Updating Bean class from generic Jar "" + je.getName(), Project.MSG_VERBOSE);
						 je = (JarEntry) replaceEntries.get(je.getName());
						 is = genericJar.getInputStream(je);
					 }
					 else {
						 is = wasJar.getInputStream(je);
					 }
					 newJarStream.putNextEntry(new JarEntry(je.getName()));
					 while ((bytesRead = is.read(buffer)) != -1) {
						 newJarStream.write(buffer, 0, bytesRead);
					 }
					 is.close();
				 }
			 }
			 else {
				 log(""websphere Jar rebuild needed due to changed "" + ""interface or XML"", Project.MSG_VERBOSE);
			 }
		 }
		 else {
			 rebuild = true;
		 }
	 }
	 catch (ClassNotFoundException cnfe) {
		 String cnfmsg = ""ClassNotFoundException while processing ejb-jar file"" + "". Details: "" + cnfe.getMessage();
		 throw new BuildException(cnfmsg, cnfe);
	 }
	 catch (IOException ioe) {
		 String msg = ""IOException while processing ejb-jar file "" + "". Details: "" + ioe.getMessage();
		 throw new BuildException(msg, ioe);
	 }
	 finally {
		 if (genericJar != null) {
			 try {
				 genericJar.close();
			 }
			 catch (IOException closeException) {
			 }
		 }
		 if (wasJar != null) {
			 try {
				 wasJar.close();
			 }
			 catch (IOException closeException) {
			 }
		 }
		 if (newJarStream != null) {
			 try {
				 newJarStream.close();
			 }
			 catch (IOException closeException) {
			 }
			 try {
				 FILE_UTILS.rename(newwasJarFile, websphereJarFile);
			 }
			 catch (IOException renameException) {
				 log(renameException.getMessage(), Project.MSG_WARN);
				 rebuild = true;
			 }
		 }
		 if (genericLoader != null && genericLoader instanceof AntClassLoader) {
			 AntClassLoader loader = (AntClassLoader) genericLoader;
			 loader.cleanup();
		 }
	 }
	 return rebuild;
 }",0,0,1,0
"public class DateType extends AbstractType<Date>{
	 public static final DateType instance = new DateType();
	 static final String DEFAULT_FORMAT = iso8601Patterns[3];
	 static final SimpleDateFormat FORMATTER = new SimpleDateFormat(DEFAULT_FORMAT);
	 DateType() {
	}
	 public Date compose(ByteBuffer bytes) {
		 return new Date(ByteBufferUtil.toLong(bytes));
	 }
	 public ByteBuffer decompose(Date value) {
		 return (value==null) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : ByteBufferUtil.bytes(value.getTime());
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 if (o1.remaining() == 0) {
			 return o2.remaining() == 0 ? 0 : -1;
		 }
		 if (o2.remaining() == 0) {
			 return 1;
		 }
		 return ByteBufferUtil.compareUnsigned(o1, o2);
	 }
	 public String getString(ByteBuffer bytes) {
		 if (bytes.remaining() == 0) {
			 return """";
		 }
		 if (bytes.remaining() != 8) {
			 throw new MarshalException(""A date is exactly 8 bytes (stored as a long): ""+bytes.remaining());
		 }
		 return FORMATTER.format(new Date(bytes.getLong(bytes.position())));
	 }
	 public String toString(Date d) {
		 return FORMATTER.format(d);
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
		 long millis;
		 ByteBuffer idBytes = null;
		 if (source.toLowerCase().equals(""now"")) {
			 millis = System.currentTimeMillis();
			 idBytes = ByteBufferUtil.bytes(millis);
		 }
		 else if (source.matches(""^\\d+$"")) {
			 try {
				 idBytes = ByteBufferUtil.bytes(Long.parseLong(source));
			 }
			 catch (NumberFormatException e) {
				 throw new MarshalException(String.format(""unable to make long (for date) from: '%s'"", source), e);
			 }
		 }
		 else {
			 try {
				 millis = DateUtils.parseDate(source, iso8601Patterns).getTime();
				 idBytes = ByteBufferUtil.bytes(millis);
			 }
			 catch (ParseException e1) {
				 throw new MarshalException(String.format(""unable to coerce '%s' to a formatted date (long)"", source), e1);
			 }
		 }
		 return idBytes;
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 if (bytes.remaining() != 8 && bytes.remaining() != 0) throw new MarshalException(String.format(""Expected 8 or 0 byte long for date (%d)"", bytes.remaining()));
	 }
	 public Class<Date> getType() {
		 return Date.class;
	 }
	 public boolean isSigned() {
		 return false;
	 }
	 public boolean isCaseSensitive() {
		 return false;
	 }
	 public boolean isCurrency() {
		 return false;
	 }
	 public int getPrecision(Date obj) {
		 return -1;
	 }
	 public int getScale(Date obj) {
		 return -1;
	 }
	 public int getJdbcType() {
		 return Types.DATE;
	 }
	 public boolean needsQuotes() {
		 return false;
	 }
}",0,0,0,0
"public Control createPageArea(Composite parent) {
	 Composite top = new Composite(parent, SWT.NONE);
	 top.setLayout(new GridLayout(3, false));
	 Label label = new Label(top, SWT.NONE);
	 label.setText(""Executable name:"");
	 GridData grid = new GridData(GridData.FILL);
	 label.setLayoutData(grid);
	 exe = new Text(top, SWT.BORDER);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 250;
	 exe.setLayoutData(grid);
	 exe.addModifyListener(new ModifyListener() {
		 public void modifyText(ModifyEvent e) {
			 setModelExename(exe.getText());
		 }
	 }
	);
	 Button button = new Button(top, SWT.NONE);
	 button.setText(""Browse..."");
	 button.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 FileDialog dialog = new FileDialog(getShell(), SWT.SAVE);
			 dialog.setText(""Executable Name"");
			 String file = dialog.open();
			 if (file != null) ExecutablePage.this.exe.setText(file);
		 }
	 }
	);
	 grid = new GridData(GridData.FILL);
	 grid.widthHint = 100;
	 button.setLayoutData(grid);
	 label = new Label(top, SWT.NONE);
	 label.setText(""Current directory:"");
	 grid = new GridData(GridData.FILL);
	 label.setLayoutData(grid);
	 dir = new Text(top, SWT.BORDER);
	 grid = new GridData(GridData.FILL_HORIZONTAL);
	 grid.widthHint = 250;
	 dir.setLayoutData(grid);
	 dir.addModifyListener(new ModifyListener() {
		 public void modifyText(ModifyEvent e) {
			 setModelCurrentdir(dir.getText());
		 }
	 }
	);
	 button = new Button(top, SWT.NONE);
	 button.setText(""Browse..."");
	 button.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 DirectoryDialog dialog = new DirectoryDialog(getShell(), SWT.SAVE);
			 dialog.setText(""Current Directory"");
			 String dir = dialog.open();
			 if (dir != null) ExecutablePage.this.dir.setText(dir);
		 }
	 }
	);
	 grid = new GridData(GridData.FILL);
	 grid.widthHint = 100;
	 button.setLayoutData(grid);
	 Group group = new Group(top, SWT.NONE);
	 GridLayout layout = new GridLayout();
	 group.setLayout(layout);
	 grid = new GridData(GridData.FILL | GridData.HORIZONTAL_ALIGN_CENTER);
	 grid.horizontalSpan = 3;
	 group.setLayoutData(grid);
	 group.setText(""Executable icon"");
	 icon = new Label(group, SWT.BORDER | SWT.FLAT);
	 grid = new GridData(GridData.FILL | GridData.HORIZONTAL_ALIGN_CENTER);
	 grid.widthHint = 48;
	 grid.heightHint = 48;
	 icon.setLayoutData(grid);
	 button = new Button(group, SWT.NONE);
	 button.setText(""Browse..."");
	 button.addSelectionListener(new SelectionAdapter() {
		 public void widgetSelected(SelectionEvent e) {
			 FileDialog dialog = new FileDialog(getShell(), SWT.OPEN);
			 dialog.setText(""Icon File"");
			 String file = dialog.open();
			 if (file == null) return;
			 setModelIcon(setIcon(file) ? file : null);
		 }
	 }
	);
	 grid = new GridData(GridData.FILL);
	 grid.widthHint = 100;
	 button.setLayoutData(grid);
	 return top;
 }",0,0,1,0
"abstract class AbstractJudgment {
	protected N4JSTypeSystem ts;
	protected TypeSystemHelper typeSystemHelper;
	protected ContainerTypesHelper containerTypesHelper;
	protected N4IDLVersionResolver n4idlVersionResolver;
	protected static UnknownTypeRef unknown() {
		return TypeRefsFactory.eINSTANCE.createUnknownTypeRef();
	}
}",0,0,0,0
"public Serializable getRoutingObject(EntryOperation opDetails) {
	 Date date = (Date) opDetails.getKey();
	 Calendar cal = Calendar.getInstance();
	 cal.setTime(date);
	 int month = cal.get(Calendar.MONTH);
	 switch (month) {
		 case 0: return ""January"";
		 case 1: return ""February"";
		 case 2: return ""March"";
		 case 3: return ""April"";
		 case 4: return ""May"";
		 case 5: return ""June"";
		 case 6: return ""July"";
		 case 7: return ""August"";
		 case 8: return ""September"";
		 case 9: return ""October"";
		 case 10: return ""November"";
		 case 11: return ""December"";
		 default: return null;
	 }
 }",0,0,1,0
"public static class Builder {
	 public Builder copy(ListBootVolumeAttachmentsResponse o) {
		 opcNextPage(o.getOpcNextPage());
		 opcRequestId(o.getOpcRequestId());
		 items(o.getItems());
		 return this;
	 }
 }",1,1,0,0
"public class BuildNumber extends Task {
	 private static final String DEFAULT_PROPERTY_NAME = ""build.number"";
	 private static final String DEFAULT_FILENAME = DEFAULT_PROPERTY_NAME;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private File myFile;
	 public void setFile(final File file) {
		 myFile = file;
	 }
	 public void execute() throws BuildException {
		 File savedFile = myFile;
		 validate();
		 final Properties properties = loadProperties();
		 final int buildNumber = getBuildNumber(properties);
		 properties.put(DEFAULT_PROPERTY_NAME, String.valueOf(buildNumber + 1));
		 FileOutputStream output = null;
		 try {
			 output = new FileOutputStream(myFile);
			 final String header = ""Build Number for ANT. Do not edit!"";
			 properties.store(output, header);
		 }
		 catch (final IOException ioe) {
			 final String message = ""Error while writing "" + myFile;
			 throw new BuildException(message, ioe);
		 }
		 finally {
			 if (null != output) {
				 try {
					 output.close();
				 }
				 catch (final IOException ioe) {
					 log(""error closing output stream "" + ioe, Project.MSG_ERR);
				 }
			 }
			 myFile = savedFile;
		 }
		 getProject().setNewProperty(DEFAULT_PROPERTY_NAME, String.valueOf(buildNumber));
	 }
	 private int getBuildNumber(final Properties properties) throws BuildException {
		 final String buildNumber = properties.getProperty(DEFAULT_PROPERTY_NAME, ""0"").trim();
		 try {
			 return Integer.parseInt(buildNumber);
		 }
		 catch (final NumberFormatException nfe) {
			 final String message = myFile + "" contains a non integer build number: "" + buildNumber;
			 throw new BuildException(message, nfe);
		 }
	 }
	 private Properties loadProperties() throws BuildException {
		 FileInputStream input = null;
		 try {
			 final Properties properties = new Properties();
			 input = new FileInputStream(myFile);
			 properties.load(input);
			 return properties;
		 }
		 catch (final IOException ioe) {
			 throw new BuildException(ioe);
		 }
		 finally {
			 if (null != input) {
				 try {
					 input.close();
				 }
				 catch (final IOException ioe) {
					 log(""error closing input stream "" + ioe, Project.MSG_ERR);
				 }
			 }
		 }
	 }
	 private void validate() throws BuildException {
		 if (null == myFile) {
			 myFile = FILE_UTILS.resolveFile(getProject().getBaseDir(), DEFAULT_FILENAME);
		 }
		 if (!myFile.exists()) {
			 try {
				 FILE_UTILS.createNewFile(myFile);
			 }
			 catch (final IOException ioe) {
				 final String message = myFile + "" doesn't exist and new file can't be created."";
				 throw new BuildException(message, ioe);
			 }
		 }
		 if (!myFile.canRead()) {
			 final String message = ""Unable to read from "" + myFile + ""."";
			 throw new BuildException(message);
		 }
		 if (!myFile.canWrite()) {
			 final String message = ""Unable to write to "" + myFile + ""."";
			 throw new BuildException(message);
		 }
	 }
}",0,0,0,0
"static ClassLoader findClassLoader() throws ConfigurationError {
	 ClassLoader context = SecuritySupport.getContextClassLoader();
	 ClassLoader system = SecuritySupport.getSystemClassLoader();
	 ClassLoader chain = system;
	 while (true) {
		 if (context == chain) {
			 ClassLoader current = ObjectFactory.class.getClassLoader();
			 chain = system;
			 while (true) {
				 if (current == chain) {
					 return system;
				 }
				 if (chain == null) {
					 break;
				 }
				 chain = SecuritySupport.getParentClassLoader(chain);
			 }
			 return current;
		 }
		 if (chain == null) {
			 break;
		 }
		 chain = SecuritySupport.getParentClassLoader(chain);
	 }
	;
	 return context;
 }",0,0,1,0
"public class MainFrame extends JFrame implements Constants {
	 AboutDialog aboutDialog = new AboutDialog(this);
	 PreferencesDialog optionsDialog = new PreferencesDialog(this);
	 WaitDialog waitDialog = new WaitDialog(this);
	 AccountChooser accountChooser = new AccountChooser(this);
	 CategoryPanel categoryPanel = new CategoryPanel();
	 AccountPanel accountPanel = new AccountPanel();
	 AccountBalancesReportPanel accountBalancesReportPanel = new AccountBalancesReportPanel();
	 IncomeExpenseReportPanel incomeExpenseReportPanel = new IncomeExpenseReportPanel();
	 JFileChooser fileChooser = new JFileChooser();
	 JFileChooser qifFileChooser = new JFileChooser();
	 JFileChooser mt940FileChooser = new JFileChooser();
	 FileFormat qif = new QIF(this, accountChooser);
	 FileFormat mt940 = new MT940(this, accountChooser);
	 MenuBar menuBar = new MenuBar();
	 ToolBar toolBar = new ToolBar();
	 JTree navigationTree = new JTree();
	 JTabbedPane jTabbedPane1 = new JTabbedPane();
	 JPanel emptyPanel = new JPanel();
	 JSplitPane splitPane = new JSplitPane();
	 JScrollPane navigationScrollPane = new JScrollPane();
	 JPopupMenu navigationPopup = new JPopupMenu();
	 JMenuItem newAccountItem = new JMenuItem();
	 JMenuItem deleteAccountItem = new JMenuItem();
	 PropertyChangeListener accountNameListener = new PropertyChangeListener() {
		 public void propertyChange(PropertyChangeEvent evt) {
			 if (evt.getSource() instanceof Account && evt.getPropertyName().equals(""name"")) accountNameChanged();
		 }
	 }
	;
	 String title = ""JMoney "" + GENERAL.getString(""Version"");
	 JMoneyFileFilter jmoneyFileFilter = new JMoneyFileFilter();
	 FileFilter qifFileFilter = qif.fileFilter();
	 FileFilter mt940FileFilter = mt940.fileFilter();
	 Properties properties = new Properties();
	 UserProperties userProperties = new UserProperties();
	 File propertiesFile;
	 String dateFormat;
	 EditableMetalTheme theme;
	 Session session;
	 NavigationTreeModel navigator;
	 File sessionFile;
	 public MainFrame() {
		 try {
			 jbInit();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 public void initProperties() throws Exception {
		 File homeDir = FileSystemView.getFileSystemView().getDefaultDirectory();
		 File jMoneyDir = new File(homeDir, "".jmoney"");
		 if (!jMoneyDir.exists()) {
			 jMoneyDir.mkdir();
		 }
		 if (jMoneyDir.isDirectory()) {
			 propertiesFile = new File(jMoneyDir, ""preferences.txt"");
			 if (!propertiesFile.exists()) {
				 propertiesFile.createNewFile();
			 }
		 }
		 InputStream in = new FileInputStream(propertiesFile);
		 properties.load(in);
		 userProperties.setProperties(properties);
		 accountPanel .getEntriesPanel() .getEntryListItemLabels() .setUserProperties( userProperties);
		 accountPanel.getEntriesPanel().setDateFormat( userProperties.getDateFormat());
		 accountPanel.getEntriesPanel().setEntryStyle( userProperties.getEntryStyle());
		 accountPanel.getEntriesPanel().setEntryOrder( userProperties.getEntryOrderField(), userProperties.getEntryOrder());
		 Account.setDefaultCurrencyCode(userProperties.getDefaultCurrency());
		 userProperties.addPropertyChangeListener(new PropertyChangeListener() {
			 public void propertyChange(PropertyChangeEvent event) {
				 if (event.getPropertyName().equals(""lookAndFeel"")) {
					 initLookAndFeel();
				 }
				 else if (event.getPropertyName().equals(""dateFormat"")) {
					 accountPanel.getEntriesPanel().setDateFormat( userProperties.getDateFormat());
				 }
				 else if (event.getPropertyName().equals(""defaultCurrency"")) {
					 Account.setDefaultCurrencyCode( userProperties.getDefaultCurrency());
					 updateUIs();
				 }
				 else if (event.getPropertyName().equals(""entryStyle"")) {
					 accountPanel.getEntriesPanel().setEntryStyle( userProperties.getEntryStyle());
				 }
				 else if (event.getPropertyName().equals(""entryOrder"")) {
					 accountPanel.getEntriesPanel().setEntryOrder( userProperties.getEntryOrderField(), userProperties.getEntryOrder());
				 }
			 }
		 }
		);
		 int x = 0, y = 0, w = 800, h = 600;
		 try {
			 x = Integer.parseInt(properties.getProperty(""locationX""));
			 y = Integer.parseInt(properties.getProperty(""locationY""));
			 w = Integer.parseInt(properties.getProperty(""width""));
			 h = Integer.parseInt(properties.getProperty(""height""));
		 }
		 catch (NumberFormatException ex) {
		}
		 this.setLocation(x, y);
		 this.setSize(w, h);
		 initLookAndFeel();
		 String filename = properties.getProperty(""currentFile"");
		 if (filename == null || filename.equals("""")) return;
		 setSessionFile(new File(filename));
		 readSession();
	 }
	 public void fileReadError(File file) {
		 JOptionPane.showMessageDialog( this, LANGUAGE.getString(""MainFrame.CouldNotReadFile"") + "" "" + file.getPath(), LANGUAGE.getString(""MainFrame.FileError""), JOptionPane.ERROR_MESSAGE);
	 }
	 public void fileWriteError(File file) {
		 JOptionPane.showMessageDialog( this, LANGUAGE.getString(""MainFrame.CouldNotWriteFile"") + "" "" + file.getPath(), LANGUAGE.getString(""MainFrame.FileError""), JOptionPane.ERROR_MESSAGE);
	 }
	 protected void processWindowEvent(WindowEvent e) {
		 if (e.getID() == WindowEvent.WINDOW_CLOSING) {
			 exit();
		 }
	 }
	 protected void updateUIs() {
		 SwingUtilities.updateComponentTreeUI(this);
		 SwingUtilities.updateComponentTreeUI(accountPanel);
		 SwingUtilities.updateComponentTreeUI(categoryPanel);
		 SwingUtilities.updateComponentTreeUI(aboutDialog);
		 SwingUtilities.updateComponentTreeUI(optionsDialog);
		 SwingUtilities.updateComponentTreeUI(waitDialog);
		 SwingUtilities.updateComponentTreeUI(accountChooser);
		 SwingUtilities.updateComponentTreeUI(fileChooser);
		 SwingUtilities.updateComponentTreeUI(qifFileChooser);
		 SwingUtilities.updateComponentTreeUI(mt940FileChooser);
		 SwingUtilities.updateComponentTreeUI(accountBalancesReportPanel);
		 SwingUtilities.updateComponentTreeUI(incomeExpenseReportPanel);
		 navigationTree.setCellRenderer(new NavigationTreeCellRenderer());
	 }
	 private boolean dontOverwrite(File file) {
		 if (file.exists()) {
			 int answer = JOptionPane.showConfirmDialog( this, LANGUAGE.getString(""MainFrame.OverwriteExistingFile"") + "" "" + file.getPath() + ""?"", LANGUAGE.getString(""MainFrame.FileExists""), JOptionPane.YES_NO_OPTION);
			 return answer != JOptionPane.YES_OPTION;
		 }
		 else return false;
	 }
	 private void storeProperties() {
		 try {
			 OutputStream out = new FileOutputStream(propertiesFile);
			 properties.setProperty( ""currentFile"", sessionFile == null ? """" : sessionFile.getPath());
			 properties.setProperty(""locationX"", Integer.toString(getX()));
			 properties.setProperty(""locationY"", Integer.toString(getY()));
			 properties.setProperty(""width"", Integer.toString(getWidth()));
			 properties.setProperty(""height"", Integer.toString(getHeight()));
			 properties.store(out, ""User Specific Properties"");
			 out.close();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 private void initLookAndFeel() {
		 try {
			 UIManager.setLookAndFeel(userProperties.getLookAndFeel());
		 }
		 catch (Exception ex) {
			 System.err.println( ""Invalid/missing Look&Feel: "" + userProperties.getLookAndFeel());
		 }
		 updateUIs();
	 }
	 private void jbInit() throws Exception {
		 setIconImage(ACCOUNTS_ICON.getImage());
		 navigationTree.setRootVisible(false);
		 navigationTree.setCellRenderer(new NavigationTreeCellRenderer());
		 newAccountItem.setText(LANGUAGE.getString(""MainFrame.newAccount""));
		 newAccountItem.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 newAccount();
			 }
		 }
		);
		 deleteAccountItem.setEnabled(false);
		 deleteAccountItem.setText( LANGUAGE.getString(""MainFrame.deleteAccount""));
		 deleteAccountItem.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 deleteAccount();
			 }
		 }
		);
		 navigationTree.getSelectionModel().setSelectionMode( TreeSelectionModel.SINGLE_TREE_SELECTION);
		 navigationTree.setModel(null);
		 navigationTree.addTreeSelectionListener(new TreeSelectionListener() {
			 public void valueChanged(TreeSelectionEvent e) {
				 navigationTreeSelection( (DefaultMutableTreeNode) e .getPath() .getLastPathComponent());
			 }
		 }
		);
		 this.getContentPane().add(splitPane, BorderLayout.CENTER);
		 splitPane.add(navigationScrollPane, JSplitPane.LEFT);
		 splitPane.add(emptyPanel, JSplitPane.RIGHT);
		 this.getContentPane().add(toolBar, BorderLayout.NORTH);
		 navigationScrollPane.getViewport().add(navigationTree, null);
		 navigationPopup.add(newAccountItem);
		 navigationPopup.add(deleteAccountItem);
		 setTitle(title);
		 setJMenuBar(menuBar);
		 fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		 fileChooser.setMultiSelectionEnabled(false);
		 fileChooser.setAcceptAllFileFilterUsed(true);
		 qifFileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		 qifFileChooser.setMultiSelectionEnabled(false);
		 qifFileChooser.setAcceptAllFileFilterUsed(true);
		 mt940FileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		 mt940FileChooser.setMultiSelectionEnabled(false);
		 mt940FileChooser.setAcceptAllFileFilterUsed(true);
		 splitPane.setDividerLocation(150);
		 navigationTree.addMouseListener(new MouseAdapter() {
			 public void mousePressed(MouseEvent e) {
				 maybeShowPopup(e);
			 }
			 public void mouseReleased(MouseEvent e) {
				 maybeShowPopup(e);
			 }
			 private void maybeShowPopup(MouseEvent e) {
				 if (e.isPopupTrigger()) {
					 if (navigationTree.getSelectionCount() > 0) {
						 DefaultMutableTreeNode node = (DefaultMutableTreeNode) navigationTree .getSelectionPath() .getLastPathComponent();
						 deleteAccountItem.setEnabled( node.getUserObject() instanceof Account);
					 }
					 navigationPopup.show(e.getComponent(), e.getX(), e.getY());
				 }
			 }
		 }
		);
	 }
	 private void navigationTreeSelection(DefaultMutableTreeNode node) {
		 if (node == null) {
			 splitPane.add(emptyPanel, JSplitPane.RIGHT);
		 }
		 else if (node.getParent() == navigator.getAccountNode()) {
			 accountPanel.setModel((Account) node.getUserObject());
			 splitPane.add(accountPanel, JSplitPane.RIGHT);
		 }
		 else if (node == navigator.getCategoryNode()) {
			 splitPane.add(categoryPanel, JSplitPane.RIGHT);
		 }
		 else if (node == navigator.getBalancesReportNode()) {
			 splitPane.add(accountBalancesReportPanel, JSplitPane.RIGHT);
			 accountBalancesReportPanel.setSession(session);
			 accountBalancesReportPanel.setDateFormat( userProperties.getDateFormat());
		 }
		 else if (node == navigator.getIncomeExpenseReportNode()) {
			 splitPane.add(incomeExpenseReportPanel, JSplitPane.RIGHT);
			 incomeExpenseReportPanel.setSession(session);
			 incomeExpenseReportPanel.setDateFormat( userProperties.getDateFormat());
		 }
		 else {
			 splitPane.add(emptyPanel, JSplitPane.RIGHT);
		 }
		 splitPane.setDividerLocation(splitPane.getDividerLocation());
	 }
	 private void newSession() {
		 if (saveOldSession()) {
			 setSessionFile(null);
			 setSession(new Session(0));
		 }
	 }
	 private void readSession() {
		 try {
			 waitDialog.show( LANGUAGE.getString(""MainFrame.OpeningFile"") + "" "" + sessionFile);
			 FileInputStream fin = new FileInputStream(sessionFile);
			 GZIPInputStream gin = new GZIPInputStream(fin);
			 BufferedInputStream bin = new BufferedInputStream(gin);
			 XMLDecoder dec = new XMLDecoder(bin);
			 Session newSession = (Session) dec.readObject();
			 dec.close();
			 setSession(newSession);
			 waitDialog.stop();
		 }
		 catch (IOException ex) {
			 waitDialog.stop();
			 fileReadError(sessionFile);
			 setSessionFile(null);
		 }
	 }
	 private void writeSession() {
		 boolean modified = session.isModified();
		 try {
			 waitDialog.show( LANGUAGE.getString(""MainFrame.SavingFile"") + "" "" + sessionFile);
			 FileOutputStream fout = new FileOutputStream(sessionFile);
			 GZIPOutputStream gout = new GZIPOutputStream(fout);
			 BufferedOutputStream bout = new BufferedOutputStream(gout);
			 XMLEncoder enc = new XMLEncoder(bout);
			 session.setModified(false);
			 enc.writeObject(session);
			 enc.close();
			 waitDialog.stop();
		 }
		 catch (IOException ex) {
			 session.setModified(modified);
			 waitDialog.stop();
			 fileWriteError(sessionFile);
		 }
	 }
	 private void openSession() {
		 if (saveOldSession()) {
			 fileChooser.setFileFilter(jmoneyFileFilter);
			 int result = fileChooser.showOpenDialog(this);
			 if (result == JFileChooser.APPROVE_OPTION) {
				 File oldFile = sessionFile;
				 setSessionFile(fileChooser.getSelectedFile());
				 readSession();
				 if (sessionFile == null) setSessionFile(oldFile);
			 }
		 }
	 }
	 private void closeSession() {
		 if (saveOldSession()) {
			 removeAccountNameListener();
			 menuBar.setSessionOpened(false);
			 toolBar.setSessionOpened(false);
			 navigationTree.setModel(null);
			 splitPane.add(emptyPanel, JSplitPane.RIGHT);
			 splitPane.setDividerLocation(splitPane.getDividerLocation());
			 setSessionFile(null);
			 session = null;
			 navigator = null;
		 }
	 }
	 private void saveSession() {
		 if (sessionFile == null) saveSessionAs();
		 else writeSession();
	 }
	 private void saveSessionAs() {
		 fileChooser.setFileFilter(jmoneyFileFilter);
		 int result = fileChooser.showSaveDialog(this);
		 if (result == JFileChooser.APPROVE_OPTION) {
			 File file = fileChooser.getSelectedFile();
			 if (dontOverwrite(file)) return;
			 setSessionFile(file);
			 writeSession();
		 }
	 }
	 private void importQIF() {
		 qifFileChooser.setDialogTitle( LANGUAGE.getString(""MainFrame.import""));
		 qifFileChooser.setFileFilter(qifFileFilter);
		 int result = qifFileChooser.showOpenDialog(this);
		 if (result == JFileChooser.APPROVE_OPTION) {
			 navigationTree.clearSelection();
			 navigationTreeSelection(null);
			 qif.importFile(session, qifFileChooser.getSelectedFile());
			 initAccountNode();
			 updateNavigationTree();
		 }
	 }
	 private void importMT940() {
		 mt940FileChooser.setDialogTitle( LANGUAGE.getString(""MainFrame.import""));
		 mt940FileChooser.setFileFilter(mt940FileFilter);
		 int result = mt940FileChooser.showOpenDialog(this);
		 if (result == JFileChooser.APPROVE_OPTION) {
			 navigationTree.clearSelection();
			 navigationTreeSelection(null);
			 mt940.importFile(session, mt940FileChooser.getSelectedFile());
			 initAccountNode();
			 updateNavigationTree();
		 }
	 }
	 private void exportQIF() {
		 qifFileChooser.setDialogTitle( LANGUAGE.getString(""MainFrame.qifExportTitle""));
		 qifFileChooser.setFileFilter(qifFileFilter);
		 int result = qifFileChooser.showOpenDialog(this);
		 if (result == JFileChooser.APPROVE_OPTION) {
			 File qifFile = qifFileChooser.getSelectedFile();
			 if (dontOverwrite(qifFile)) return;
			 result = accountChooser.showDialog( session.getAccounts(), LANGUAGE.getString(""MainFrame.chooseAccountToExport""));
			 if (result == OK) qif.exportAccount( session, accountChooser.getSelectedAccount(), qifFileChooser.getSelectedFile());
		 }
	 }
	 private void exit() {
		 if (saveOldSession()) {
			 storeProperties();
			 System.exit(0);
		 }
	 }
	 private void newAccount() {
		 Account account = session.getNewAccount(LANGUAGE.getString(""Account.newAccount""));
		 Collections.sort(session.getAccounts());
		 CategoryNode node = new CategoryNode(account);
		 account.addPropertyChangeListener(accountNameListener);
		 navigator.insertNodeInto(node, navigator.getAccountNode(), 0);
		 Object path[] = navigator.getPathToRoot(node);
		 navigationTree.setSelectionPath(new TreePath(path));
		 accountPanel.tabbedPane.setSelectedComponent( accountPanel.propertiesPanel);
	 }
	 private void deleteAccount() {
		 CategoryNode node = (CategoryNode) navigationTree .getSelectionPath() .getLastPathComponent();
		 Account account = (Account) node.getUserObject();
		 session.getCategories().removeNodeFromParent(account.getCategoryNode());
		 session.getAccounts().removeElement(account);
		 navigator.removeNodeFromParent(node);
		 session.modified();
	 }
	 private void about() {
		 aboutDialog.showDialog();
	 }
	 private void setEntryOrder() {
	 }
	 private boolean saveOldSession() {
		 if (session != null && session.isModified()) {
			 String title = LANGUAGE.getString(""MainFrame.saveOldSessionTitle"");
			 String question = LANGUAGE.getString(""MainFrame.saveOldSessionQuestion"");
			 int answer = JOptionPane.showConfirmDialog( this, question, title, JOptionPane.YES_NO_CANCEL_OPTION);
			 if (answer == JOptionPane.YES_OPTION) saveSession();
			 return answer != JOptionPane.CANCEL_OPTION;
		 }
		 return true;
	 }
	 private void setSession(Session newSession) {
		 session = newSession;
		 Collections.sort(session.getAccounts());
		 navigator = new NavigationTreeModel();
		 initAccountNode();
		 navigationTree.setModel(navigator);
		 Object[] path = navigator.getPathToRoot(navigator.getAccountNode());
		 navigationTree.expandPath(new TreePath(path));
		 path = navigator.getPathToRoot(navigator.getReportNode());
		 navigationTree.expandPath(new TreePath(path));
		 accountPanel.setSession(session);
		 categoryPanel.setSession(session);
		 menuBar.setSessionOpened(true);
		 toolBar.setSessionOpened(true);
	 }
	 private void removeAccountNameListener() {
		 for (Enumeration e = navigator.getAccountNode().children();
		 e.hasMoreElements();
		 ) {
			 Account a = (Account) ((CategoryNode) e.nextElement()).getUserObject();
			 a.removePropertyChangeListener(accountNameListener);
		 }
	 }
	 private void initAccountNode() {
		 DefaultMutableTreeNode accountNode = navigator.getAccountNode();
		 removeAccountNameListener();
		 accountNode.removeAllChildren();
		 Vector accounts = session.getAccounts();
		 for (int i = 0;
		 i < accounts.size();
		 i++) {
			 Account a = (Account) accounts.elementAt(i);
			 accountNode.add(new CategoryNode(a));
			 a.addPropertyChangeListener(accountNameListener);
		 }
	 }
	 private void updateNavigationTree() {
		 TreePath tp = navigationTree.getSelectionPath();
		 navigationTree.clearSelection();
		 navigationTree.updateUI();
		 navigationTree.setSelectionPath(tp);
	 }
	 private void accountNameChanged() {
		 Collections.sort(session.getAccounts());
		 TreePath tp = navigationTree.getSelectionPath();
		 navigator.sortChildren(navigator.getAccountNode());
		 navigationTree.setSelectionPath(tp);
	 }
	 private void setSessionFile(File file) {
		 sessionFile = file;
		 setTitle( sessionFile == null ? title : title + "" - "" + sessionFile.getName());
	 }
	 class MenuBar extends JMenuBar {
		 JMenu fileMenu = new JMenu();
		 JMenu editMenu = new JMenu();
		 JMenu helpMenu = new JMenu();
		 JMenu optionsMenu = new JMenu();
		 JMenuItem newFileItem = new JMenuItem();
		 JMenuItem openFileItem = new JMenuItem();
		 JMenuItem closeFileItem = new JMenuItem();
		 JMenuItem saveFileItem = new JMenuItem();
		 JMenuItem saveAsFileItem = new JMenuItem();
		 JMenuItem undoItem = new JMenuItem();
		 JMenuItem redoItem = new JMenuItem();
		 JMenuItem cutItem = new JMenuItem();
		 JMenuItem copyItem = new JMenuItem();
		 JMenuItem pasteItem = new JMenuItem();
		 JMenuItem findItem = new JMenuItem();
		 JMenuItem findAgainItem = new JMenuItem();
		 JMenuItem preferencesItem = new JMenuItem();
		 JMenuItem exitFileItem = new JMenuItem();
		 JMenuItem aboutItem = new JMenuItem();
		 JMenu importMenu = new JMenu();
		 JMenuItem qifImportItem = new JMenuItem();
		 JMenuItem mt940ImportItem = new JMenuItem();
		 JMenuItem exportFileItem = new JMenuItem();
		 JMenuItem printItem = new JMenuItem();
		 public MenuBar() {
			 try {
				 jbInit();
			 }
			 catch (Exception e) {
				 e.printStackTrace();
			 }
		 }
		 private void setSessionOpened(boolean state) {
			 closeFileItem.setEnabled(state);
			 saveFileItem.setEnabled(state);
			 saveAsFileItem.setEnabled(state);
			 qifImportItem.setEnabled(state);
			 mt940ImportItem.setEnabled(state);
			 exportFileItem.setEnabled(state);
		 }
		 private void jbInit() throws Exception {
			 setSessionOpened(false);
			 newFileItem.setIcon(NEW_ICON);
			 newFileItem.setText(LANGUAGE.getString(""MainFrame.new""));
			 newFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.new.mnemonic"").charAt(0));
			 newFileItem.setAccelerator( KeyStroke.getKeyStroke('N', KeyEvent.CTRL_MASK));
			 newFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 newSession();
				 }
			 }
			);
			 openFileItem.setIcon(OPEN_ICON);
			 openFileItem.setText(LANGUAGE.getString(""MainFrame.open""));
			 openFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.open.mnemonic"").charAt(0));
			 openFileItem.setAccelerator( KeyStroke.getKeyStroke('O', KeyEvent.CTRL_MASK));
			 openFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 openSession();
				 }
			 }
			);
			 closeFileItem.setText(LANGUAGE.getString(""MainFrame.close""));
			 closeFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.close.mnemonic"").charAt(0));
			 closeFileItem.setAccelerator( KeyStroke.getKeyStroke('W', KeyEvent.CTRL_MASK));
			 closeFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 closeSession();
				 }
			 }
			);
			 saveFileItem.setIcon(SAVE_ICON);
			 saveFileItem.setText(LANGUAGE.getString(""MainFrame.save""));
			 saveFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.save.mnemonic"").charAt(0));
			 saveFileItem.setAccelerator( KeyStroke.getKeyStroke('S', KeyEvent.CTRL_MASK));
			 saveFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 saveSession();
				 }
			 }
			);
			 saveAsFileItem.setIcon(SAVE_AS_ICON);
			 saveAsFileItem.setText(LANGUAGE.getString(""MainFrame.saveAs""));
			 saveAsFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.saveAs.mnemonic"").charAt(0));
			 saveAsFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 saveSessionAs();
				 }
			 }
			);
			 printItem.setEnabled(false);
			 printItem.setIcon(PRINT_ICON);
			 printItem.setText(LANGUAGE.getString(""MainFrame.print""));
			 printItem.setMnemonic( LANGUAGE.getString(""MainFrame.print.mnemonic"").charAt(0));
			 printItem.setAccelerator( KeyStroke.getKeyStroke('P', KeyEvent.CTRL_MASK));
			 importMenu.setIcon(IMPORT_ICON);
			 importMenu.setText(LANGUAGE.getString(""MainFrame.import""));
			 qifImportItem.setIcon(IMPORT_ICON);
			 qifImportItem.setText(""QIF..."");
			 qifImportItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 importQIF();
				 }
			 }
			);
			 mt940ImportItem.setIcon(IMPORT_ICON);
			 mt940ImportItem.setText(""MT940..."");
			 mt940ImportItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 importMT940();
				 }
			 }
			);
			 exportFileItem.setIcon(EXPORT_ICON);
			 exportFileItem.setText(LANGUAGE.getString(""MainFrame.export""));
			 exportFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.export.mnemonic"").charAt(0));
			 exportFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 exportQIF();
				 }
			 }
			);
			 exitFileItem.setText(LANGUAGE.getString(""MainFrame.exit""));
			 exitFileItem.setMnemonic( LANGUAGE.getString(""MainFrame.exit.mnemonic"").charAt(0));
			 exitFileItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 exit();
				 }
			 }
			);
			 fileMenu.add(newFileItem);
			 fileMenu.add(openFileItem);
			 fileMenu.add(closeFileItem);
			 fileMenu.addSeparator();
			 fileMenu.add(saveFileItem);
			 fileMenu.add(saveAsFileItem);
			 fileMenu.addSeparator();
			 fileMenu.add(printItem);
			 fileMenu.addSeparator();
			 fileMenu.add(importMenu);
			 importMenu.add(qifImportItem);
			 importMenu.add(mt940ImportItem);
			 fileMenu.add(exportFileItem);
			 fileMenu.addSeparator();
			 fileMenu.add(exitFileItem);
			 undoItem.setEnabled(false);
			 undoItem.setIcon(UNDO_ICON);
			 undoItem.setText(LANGUAGE.getString(""MainFrame.undo""));
			 undoItem.setMnemonic( LANGUAGE.getString(""MainFrame.undo.mnemonic"").charAt(0));
			 undoItem.setAccelerator( KeyStroke.getKeyStroke('Z', KeyEvent.CTRL_MASK));
			 redoItem.setEnabled(false);
			 redoItem.setIcon(REDO_ICON);
			 redoItem.setText(LANGUAGE.getString(""MainFrame.redo""));
			 redoItem.setMnemonic( LANGUAGE.getString(""MainFrame.redo.mnemonic"").charAt(0));
			 redoItem.setAccelerator( KeyStroke.getKeyStroke('Y', KeyEvent.CTRL_MASK));
			 cutItem.setEnabled(false);
			 cutItem.setIcon(CUT_ICON);
			 cutItem.setText(LANGUAGE.getString(""MainFrame.cut""));
			 cutItem.setMnemonic( LANGUAGE.getString(""MainFrame.cut.mnemonic"").charAt(0));
			 cutItem.setAccelerator( KeyStroke.getKeyStroke('X', KeyEvent.CTRL_MASK));
			 copyItem.setEnabled(false);
			 copyItem.setIcon(COPY_ICON);
			 copyItem.setText(LANGUAGE.getString(""MainFrame.copy""));
			 copyItem.setMnemonic( LANGUAGE.getString(""MainFrame.copy.mnemonic"").charAt(0));
			 copyItem.setAccelerator( KeyStroke.getKeyStroke('C', KeyEvent.CTRL_MASK));
			 pasteItem.setEnabled(false);
			 pasteItem.setIcon(PASTE_ICON);
			 pasteItem.setText(LANGUAGE.getString(""MainFrame.paste""));
			 pasteItem.setMnemonic( LANGUAGE.getString(""MainFrame.paste.mnemonic"").charAt(0));
			 pasteItem.setAccelerator( KeyStroke.getKeyStroke('V', KeyEvent.CTRL_MASK));
			 findItem.setEnabled(false);
			 findItem.setIcon(FIND_ICON);
			 findItem.setText(LANGUAGE.getString(""MainFrame.find""));
			 findItem.setMnemonic( LANGUAGE.getString(""MainFrame.find.mnemonic"").charAt(0));
			 findItem.setAccelerator( KeyStroke.getKeyStroke('F', KeyEvent.CTRL_MASK));
			 findAgainItem.setEnabled(false);
			 findAgainItem.setIcon(FIND_AGAIN_ICON);
			 findAgainItem.setText(LANGUAGE.getString(""MainFrame.findAgain""));
			 findAgainItem.setMnemonic( LANGUAGE.getString(""MainFrame.findAgain.mnemonic"").charAt(0));
			 findAgainItem.setAccelerator( KeyStroke.getKeyStroke('G', KeyEvent.CTRL_MASK));
			 editMenu.add(undoItem);
			 editMenu.add(redoItem);
			 editMenu.addSeparator();
			 editMenu.add(cutItem);
			 editMenu.add(copyItem);
			 editMenu.add(pasteItem);
			 editMenu.addSeparator();
			 editMenu.add(findItem);
			 editMenu.add(findAgainItem);
			 preferencesItem.setIcon(PREFERENCES_ICON);
			 preferencesItem.setText( LANGUAGE.getString(""MainFrame.preferences""));
			 preferencesItem.setMnemonic( LANGUAGE.getString(""MainFrame.preferences.mnemonic"").charAt(0));
			 preferencesItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 optionsDialog.showDialog(userProperties);
				 }
			 }
			);
			 optionsMenu.add(preferencesItem);
			 aboutItem.setIcon(ABOUT_ICON);
			 aboutItem.setText(LANGUAGE.getString(""MainFrame.about""));
			 aboutItem.setMnemonic( LANGUAGE.getString(""MainFrame.about.mnemonic"").charAt(0));
			 aboutItem.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 about();
				 }
			 }
			);
			 helpMenu.add(aboutItem);
			 fileMenu.setText(LANGUAGE.getString(""MainFrame.file""));
			 fileMenu.setMnemonic( LANGUAGE.getString(""MainFrame.file.mnemonic"").charAt(0));
			 editMenu.setText(LANGUAGE.getString(""MainFrame.edit""));
			 editMenu.setMnemonic( LANGUAGE.getString(""MainFrame.edit.mnemonic"").charAt(0));
			 optionsMenu.setText(LANGUAGE.getString(""MainFrame.options""));
			 optionsMenu.setMnemonic( LANGUAGE.getString(""MainFrame.options.mnemonic"").charAt(0));
			 helpMenu.setText(LANGUAGE.getString(""MainFrame.help""));
			 helpMenu.setMnemonic( LANGUAGE.getString(""MainFrame.help.mnemonic"").charAt(0));
			 add(fileMenu);
			 add(editMenu);
			 add(optionsMenu);
			 add(helpMenu);
		 }
	 }
	 class ToolBar extends JToolBar {
		 private JButton newFile = new JButton();
		 private JButton open = new JButton();
		 private JButton save = new JButton();
		 private JButton saveAs = new JButton();
		 private JButton print = new JButton();
		 private JButton cut = new JButton();
		 private JButton copy = new JButton();
		 private JButton paste = new JButton();
		 private Insets insets = new Insets(0, 0, 0, 0);
		 public ToolBar() {
			 try {
				 jbInit();
			 }
			 catch (Exception e) {
				 e.printStackTrace();
			 }
		 }
		 private void setSessionOpened(boolean state) {
			 save.setEnabled(state);
			 saveAs.setEnabled(state);
		 }
		 private void jbInit() throws Exception {
			 setFloatable(false);
			 setRollover(true);
			 setSessionOpened(false);
			 newFile.setIcon(NEW_ICON);
			 newFile.setMargin(insets);
			 newFile.setToolTipText(LANGUAGE.getString(""MainFrame.new""));
			 newFile.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 newSession();
				 }
			 }
			);
			 open.setIcon(OPEN_ICON);
			 open.setMargin(insets);
			 open.setToolTipText(LANGUAGE.getString(""MainFrame.open""));
			 open.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 openSession();
				 }
			 }
			);
			 save.setIcon(SAVE_ICON);
			 save.setMargin(insets);
			 save.setToolTipText(LANGUAGE.getString(""MainFrame.save""));
			 save.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 saveSession();
				 }
			 }
			);
			 saveAs.setIcon(SAVE_AS_ICON);
			 saveAs.setMargin(insets);
			 saveAs.setToolTipText(LANGUAGE.getString(""MainFrame.saveAs""));
			 saveAs.addActionListener(new ActionListener() {
				 public void actionPerformed(ActionEvent e) {
					 saveSessionAs();
				 }
			 }
			);
			 print.setEnabled(false);
			 print.setIcon(PRINT_ICON);
			 print.setMargin(insets);
			 print.setToolTipText(LANGUAGE.getString(""MainFrame.print""));
			 cut.setEnabled(false);
			 cut.setIcon(CUT_ICON);
			 cut.setMargin(insets);
			 cut.setToolTipText(LANGUAGE.getString(""MainFrame.cut""));
			 copy.setEnabled(false);
			 copy.setIcon(COPY_ICON);
			 copy.setMargin(insets);
			 copy.setToolTipText(LANGUAGE.getString(""MainFrame.copy""));
			 paste.setEnabled(false);
			 paste.setIcon(PASTE_ICON);
			 paste.setMargin(insets);
			 paste.setToolTipText(LANGUAGE.getString(""MainFrame.paste""));
			 add(newFile);
			 add(open);
			 add(save);
			 add(saveAs);
			 add(print);
			 addSeparator();
			 add(cut);
			 add(copy);
			 add(paste);
		 }
	 }
	 public class JMoneyFileFilter extends FileFilter {
		 public boolean accept(File f) {
			 if (f.isDirectory()) return true;
			 return f.getName().toLowerCase().endsWith(FILE_EXTENSION);
		 }
		 public String getDescription() {
			 return Constants.FILE_FILTER_NAME;
		 }
	 }
}",1,0,0,0
"public class TestOntModel extends ModelTestBase{
	 public static final String BASE = ""http: public static final String NS = BASE + ""#"";
	 public static final String DOC = ""<rdf:RDF"" + "" xmlns:rdf=\""http: "" xmlns:owl=\""http: "" xmlns:rdfs=\""http: "" <owl:Class rdf:about=\""http: "" <rdfs:subClassOf>"" + "" <owl:Class rdf:about=\""http: "" </rdfs:subClassOf>"" + "" </owl:Class>"" + "" <owl:Class rdf:about=\""http: "" <rdfs:subClassOf rdf:resource=\""http: "" rdf:type=\""http: "" </owl:Class>"" + "" <owl:Class rdf:about=\""http: "" <rdfs:subClassOf rdf:resource=\""http: "" </owl:Class>"" + "" <owl:ObjectProperty rdf:about=\""http: "" <rdfs:domain rdf:resource=\""http: "" <rdfs:range rdf:resource=\""http: "" <rdfs:range rdf:resource=\""http: "" </owl:ObjectProperty>"" + ""</rdf:RDF>"";
	 public TestOntModel( String name ) {
		 super( name );
	 }
	 public void setUp() {
		 OntDocumentManager.getInstance().reset( true );
	 }
	 public void testWriteOutputStream() {
		 OntModel m = ModelFactory.createOntologyModel();
		 OntClass A = m.createClass( NS + ""A"" );
		 OntClass B = m.createClass( NS + ""B"" );
		 OntClass C = m.createClass( NS + ""C"" );
		 OntClass D = m.createClass( NS + ""D"" );
		 A.addSubClass( B );
		 B.addSubClass( C );
		 B.addSubClass( D );
		 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
		 p.addDomain( A );
		 p.addRange( B );
		 p.addRange( C );
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 m.write( out );
		 String s = out.toString();
		 ByteArrayInputStream in = new ByteArrayInputStream( s.getBytes() );
		 Model mIn1 = ModelFactory.createDefaultModel();
		 mIn1.read( in, BASE );
		 Model mIn2 = ModelFactory.createDefaultModel();
		 mIn2.read( new ByteArrayInputStream( DOC.getBytes() ), BASE );
		 assertTrue( ""InputStream write/read cycle failed (1)"", mIn1.isIsomorphicWith( m.getBaseModel() ) );
		 assertTrue( ""InputStream write/read cycle failed (2)"", mIn2.isIsomorphicWith( m.getBaseModel() ) );
	 }
	 public void testGetBaseModelPrefixes() {
		 OntModel om = ModelFactory.createOntologyModel();
		 om.setNsPrefix( ""bill"", ""http: om.setNsPrefix( ""grue"", ""ftp: assertEquals( om.getNsPrefixMap(), om.getBaseModel().getNsPrefixMap() );
	 }
	 public void testPolyadicPrefixMapping() {
		 final String IMPORTED_NAMESPACE = ""http: final String LOCAL_NAMESPACE = ""http: Model importedModel = ModelFactory.createDefaultModel();
		 importedModel.setNsPrefix( """", IMPORTED_NAMESPACE );
		 OntModel ontModel = ModelFactory.createOntologyModel();
		 ontModel.setNsPrefix( """", LOCAL_NAMESPACE );
		 ontModel.addSubModel( importedModel );
		 assertNull( ontModel.getNsURIPrefix( IMPORTED_NAMESPACE ) );
	 }
	 public void testWritesPrefixes() {
		 OntModel om = ModelFactory.createOntologyModel();
		 om.setNsPrefix( ""spoo"", ""http: om.add( statement( om, ""ping http: om.add( statement( om, ""gg "" + OWL.getURI() + ""hh ii"" ) );
		 StringWriter sw = new StringWriter();
		 om.write( sw );
		 String s = sw.getBuffer().toString();
		 assertTrue( s.indexOf( ""xmlns:spoo=\""http: assertTrue( s.indexOf( ""xmlns:owl=\"""" + OWL.getURI() + ""\"""" ) > 0 );
	 }
	 public void testWriteWriter() {
		 OntModel m = ModelFactory.createOntologyModel();
		 OntClass A = m.createClass( NS + ""A"" );
		 OntClass B = m.createClass( NS + ""B"" );
		 OntClass C = m.createClass( NS + ""C"" );
		 OntClass D = m.createClass( NS + ""D"" );
		 A.addSubClass( B );
		 B.addSubClass( C );
		 B.addSubClass( D );
		 ObjectProperty p = m.createObjectProperty( NS + ""p"" );
		 p.addDomain( A );
		 p.addRange( B );
		 p.addRange( C );
		 StringWriter out = new StringWriter();
		 m.write( out );
		 String s = out.toString();
		 Model mIn1 = ModelFactory.createDefaultModel();
		 mIn1.read( new StringReader( s ), BASE );
		 Model mIn2 = ModelFactory.createDefaultModel();
		 mIn2.read( new StringReader( DOC ), BASE );
		 assertTrue( ""Writer write/read cycle failed (1)"", mIn1.isIsomorphicWith( m.getBaseModel() ) );
		 assertTrue( ""Writer write/read cycle failed (2)"", mIn2.isIsomorphicWith( m.getBaseModel() ) );
	 }
	 public void testGetOntology() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createOntology( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getOntology( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getOntology( NS+""q"") );
		 assertNull( ""result of get r"", m.getOntology( NS+""r""));
	 }
	 public void testGetIndividual() {
		 OntModel m = ModelFactory.createOntologyModel();
		 OntClass c = m.createClass( NS +""c"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createIndividual( NS + ""s"", c );
		 assertEquals( ""Result of get s"", s, m.getIndividual( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getIndividual( NS+""q"") );
	 }
	 public void testCreateIndividual() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 Resource i0 = m.createIndividual( OWL.Thing );
		 Resource i1 = m.createIndividual( null );
		 Resource i2 = m.createIndividual( NS + ""i2"", OWL.Thing );
		 Resource i3 = m.createIndividual( NS + ""i3"", null );
		 Resource i4 = m.createIndividual( null, OWL.Thing );
		 Resource i5 = m.createIndividual( null, null );
		 assertNotNull( i0 );
		 assertNotNull( i1 );
		 assertNotNull( i2 );
		 assertNotNull( i3 );
		 assertNotNull( i4 );
		 assertNotNull( i5 );
	 }
	 public void testGetOntProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createOntProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getOntProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getOntProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getOntProperty( NS+""r""));
	 }
	 public void testGetObjectProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createObjectProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getObjectProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getObjectProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getObjectProperty( NS+""r""));
	 }
	 public void testGetTransitiveProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createTransitiveProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getTransitiveProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getTransitiveProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getTransitiveProperty( NS+""r""));
	 }
	 public void testGetSymmetricProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createSymmetricProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getSymmetricProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getSymmetricProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getSymmetricProperty( NS+""r""));
	 }
	 public void testGetInverseFunctionalProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createInverseFunctionalProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getInverseFunctionalProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getInverseFunctionalProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getInverseFunctionalProperty( NS+""r""));
	 }
	 public void testGetDatatypeProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createDatatypeProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getDatatypeProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getDatatypeProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getDatatypeProperty( NS+""r""));
	 }
	 public void testGetAnnotationProperty() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createAnnotationProperty( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getAnnotationProperty( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getAnnotationProperty( NS+""q"") );
		 assertNull( ""result of get r"", m.getAnnotationProperty( NS+""r""));
	 }
	 public void testGetOntResource() {
		 OntModel m = ModelFactory.createOntologyModel();
		 OntResource r0 = m.getOntResource( NS + ""a"" );
		 assertNull( r0 );
		 OntResource r1 = m.createOntResource( NS + ""aaa"" );
		 assertInstanceOf( OntResource.class, r1 );
		 Resource r2a = m.getResource( NS + ""a"" );
		 Resource r2b = m.getResource( NS + ""b"" );
		 Property p = m.getProperty( NS + ""p"" );
		 m.add( r2a, p, r2b );
		 r0 = m.getOntResource( NS + ""a"" );
		 assertInstanceOf( OntResource.class, r0 );
		 OntResource r3 = m.getOntResource( r2b );
		 assertInstanceOf( OntResource.class, r3 );
	 }
	 public void testGetOntClass() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Resource r = m.getResource( NS + ""r"" );
		 Resource r0 = m.getResource( NS + ""r0"" );
		 m.add( r, RDF.type, r0 );
		 Resource s = m.createClass( NS + ""s"" );
		 assertEquals( ""Result of get s"", s, m.getOntClass( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getOntClass( NS+""q"") );
		 assertNull( ""result of get r"", m.getOntClass( NS+""r""));
	 }
	 public void testGetComplementClass() {
		 OntModel m = ModelFactory.createOntologyModel();
		 OntClass c = m.createClass( NS +""c"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createComplementClass( NS + ""s"", c );
		 assertEquals( ""Result of get s"", s, m.getComplementClass( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getComplementClass( NS+""q"") );
		 assertNull( ""result of get r"", m.getComplementClass( NS+""r""));
	 }
	 public void testGetEnumeratedClass() {
		 OntModel m = ModelFactory.createOntologyModel();
		 RDFList l = m.createList();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createEnumeratedClass( NS + ""s"", l );
		 assertEquals( ""Result of get s"", s, m.getEnumeratedClass( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getEnumeratedClass( NS+""q"") );
		 assertNull( ""result of get r"", m.getEnumeratedClass( NS+""r""));
	 }
	 public void testGetUnionClass() {
		 OntModel m = ModelFactory.createOntologyModel();
		 RDFList l = m.createList();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createUnionClass( NS + ""s"", l );
		 assertEquals( ""Result of get s"", s, m.getUnionClass( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getUnionClass( NS+""q"") );
		 assertNull( ""result of get r"", m.getUnionClass( NS+""r""));
	 }
	 public void testGetIntersectionClass() {
		 OntModel m = ModelFactory.createOntologyModel();
		 RDFList l = m.createList();
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createIntersectionClass( NS + ""s"", l );
		 assertEquals( ""Result of get s"", s, m.getIntersectionClass( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getIntersectionClass( NS+""q"") );
		 assertNull( ""result of get r"", m.getIntersectionClass( NS+""r""));
	 }
	 public void testGetRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createRestriction( NS + ""s"", p );
		 assertEquals( ""Result of get s"", s, m.getRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getRestriction( NS+""r""));
	 }
	 public void testGetHasValueRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 OntClass c = m.createClass( NS + ""c"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createHasValueRestriction( NS + ""s"", p, c );
		 assertEquals( ""Result of get s"", s, m.getHasValueRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getHasValueRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getHasValueRestriction( NS+""r""));
	 }
	 public void testGetSomeValuesFromRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 OntClass c = m.createClass( NS + ""c"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createSomeValuesFromRestriction( NS + ""s"", p, c );
		 assertEquals( ""Result of get s"", s, m.getSomeValuesFromRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getSomeValuesFromRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getSomeValuesFromRestriction( NS+""r""));
	 }
	 public void testGetAllValuesFromRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 OntClass c = m.createClass( NS + ""c"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createAllValuesFromRestriction( NS + ""s"", p, c );
		 assertEquals( ""Result of get s"", s, m.getAllValuesFromRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getAllValuesFromRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getAllValuesFromRestriction( NS+""r""));
	 }
	 public void testGetCardinalityRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createCardinalityRestriction( NS + ""s"", p, 1 );
		 assertEquals( ""Result of get s"", s, m.getCardinalityRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getCardinalityRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getCardinalityRestriction( NS+""r""));
	 }
	 public void testGetMinCardinalityRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createMinCardinalityRestriction( NS + ""s"", p, 1 );
		 assertEquals( ""Result of get s"", s, m.getMinCardinalityRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getMinCardinalityRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getMinCardinalityRestriction( NS+""r""));
	 }
	 public void testGetMaxCardinalityRestriction() {
		 OntModel m = ModelFactory.createOntologyModel();
		 Property p = m.createProperty( NS + ""p"" );
		 Resource r = m.getResource( NS + ""r"" );
		 m.add( r, RDF.type, r );
		 Resource s = m.createMaxCardinalityRestriction( NS + ""s"", p, 1 );
		 assertEquals( ""Result of get s"", s, m.getMaxCardinalityRestriction( NS + ""s"" ) );
		 assertNull( ""result of get q"", m.getMaxCardinalityRestriction( NS+""q"") );
		 assertNull( ""result of get r"", m.getMaxCardinalityRestriction( NS+""r""));
	 }
	 public void testGetSubgraphs() {
		 OntModel m = ModelFactory.createOntologyModel();
		 m.read( ""file:testing/ontology/testImport6/a.owl"" );
		 assertEquals( ""Marker count not correct"", 4, TestOntDocumentManager.countMarkers( m ) );
		 List<Graph> subs = m.getSubGraphs();
		 assertEquals( ""n subgraphs should be "", 3, subs.size() );
	 }
	 private static boolean hasImport(Collection<String> c, String x) {
		 String x2 = x.substring(""file:"".length());
		 return c.stream().anyMatch(elt->elt.endsWith(x2));
	 }
	 public void testListImportURIs() {
		 OntModel m = ModelFactory.createOntologyModel();
		 m.read( ""file:testing/ontology/testImport6/a.owl"" );
		 Collection<String> c = m.listImportedOntologyURIs();
		 assertEquals( ""Should be two non-closed import URI's"", 2, c.size() );
		 assertTrue( ""b should be imported "", hasImport(c, ""file:testing/ontology/testImport6/b.owl""));
		 assertFalse( ""c should not be imported "", hasImport(c, ""file:testing/ontology/testImport6/c.owl""));
		 assertTrue( ""d should be imported "", hasImport(c, ""file:testing/ontology/testImport6/d.owl""));
		 c = m.listImportedOntologyURIs( true );
		 assertEquals( ""Should be two non-closed import URI's"", 3, c.size() );
		 assertTrue( ""b should be imported "", hasImport(c, ""file:testing/ontology/testImport6/b.owl"" ));
		 assertTrue( ""c should be imported "", hasImport(c, ""file:testing/ontology/testImport6/c.owl"" ));
		 assertTrue( ""d should be imported "", hasImport(c, ""file:testing/ontology/testImport6/d.owl"" ));
	 }
	 public void testListOntProperties0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertFalse( iteratorContains( m.listOntProperties(), op ) );
		 assertFalse( iteratorContains( m.listOntProperties(), dp ) );
		 assertFalse( iteratorContains( m.listOntProperties(), ap ) );
		 assertTrue( iteratorContains( m.listOntProperties(), ontp ) );
		 assertTrue( iteratorContains( m.listOntProperties(), rdfp ) );
	 }
	 public void testListOntProperties1() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_MICRO_RULE_INF);
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertTrue( iteratorContains( m.listOntProperties(), op ) );
		 assertTrue( iteratorContains( m.listOntProperties(), dp ) );
		 assertTrue( iteratorContains( m.listOntProperties(), ap ) );
		 assertTrue( iteratorContains( m.listOntProperties(), ontp ) );
		 assertTrue( iteratorContains( m.listOntProperties(), rdfp ) );
	 }
	 public void testListOntProperties2() {
		 OntModelSpec owlDLReasoner = new OntModelSpec( OntModelSpec.OWL_DL_MEM );
		 owlDLReasoner.setReasoner( OntModelSpec.OWL_MEM_MICRO_RULE_INF.getReasoner() );
		 OntModel m = ModelFactory.createOntologyModel( owlDLReasoner );
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertTrue( iteratorContains( m.listOntProperties(), op ) );
		 assertTrue( iteratorContains( m.listOntProperties(), dp ) );
		 assertFalse( iteratorContains( m.listOntProperties(), ap ) );
		 assertTrue( iteratorContains( m.listOntProperties(), ontp ) );
		 assertTrue( iteratorContains( m.listOntProperties(), rdfp ) );
	 }
	 public void testListAllOntProperties0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertTrue( iteratorContains( m.listAllOntProperties(), op ) );
		 assertTrue( iteratorContains( m.listAllOntProperties(), dp ) );
		 assertTrue( iteratorContains( m.listAllOntProperties(), ap ) );
		 assertTrue( iteratorContains( m.listAllOntProperties(), ontp ) );
		 assertTrue( iteratorContains( m.listAllOntProperties(), rdfp ) );
	 }
	 public void testListObjectProperties0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertTrue( iteratorContains( m.listObjectProperties(), op ) );
		 assertFalse( iteratorContains( m.listObjectProperties(), dp ) );
		 assertFalse( iteratorContains( m.listObjectProperties(), ap ) );
		 assertFalse( iteratorContains( m.listObjectProperties(), ontp ) );
		 assertFalse( iteratorContains( m.listObjectProperties(), rdfp ) );
	 }
	 public void testListDatatypeProperties0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertFalse( iteratorContains( m.listDatatypeProperties(), op ) );
		 assertTrue( iteratorContains( m.listDatatypeProperties(), dp ) );
		 assertFalse( iteratorContains( m.listDatatypeProperties(), ap ) );
		 assertFalse( iteratorContains( m.listDatatypeProperties(), ontp ) );
		 assertFalse( iteratorContains( m.listDatatypeProperties(), rdfp ) );
	 }
	 public void testListAnnotationProperties0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 ObjectProperty op = m.createObjectProperty( NS + ""op"" );
		 DatatypeProperty dp = m.createDatatypeProperty( NS + ""dp"" );
		 AnnotationProperty ap = m.createAnnotationProperty( NS + ""ap"" );
		 OntProperty ontp = m.createOntProperty( NS + ""ontp"" );
		 Property rdfp = m.createProperty( NS + ""rdfp"" );
		 rdfp.addProperty( RDF.type, RDF.Property );
		 assertFalse( iteratorContains( m.listAnnotationProperties(), op ) );
		 assertFalse( iteratorContains( m.listAnnotationProperties(), dp ) );
		 assertTrue( iteratorContains( m.listAnnotationProperties(), ap ) );
		 assertFalse( iteratorContains( m.listAnnotationProperties(), ontp ) );
		 assertFalse( iteratorContains( m.listAnnotationProperties(), rdfp ) );
	 }
	 public void testListSubModels0() {
		 OntModel m = ModelFactory.createOntologyModel();
		 m.read( ""file:testing/ontology/testImport6/a.owl"" );
		 assertEquals( ""Marker count not correct"", 4, TestOntDocumentManager.countMarkers( m ) );
		 List<OntModel> importModels = new ArrayList<>();
		 for (Iterator<OntModel> j = m.listSubModels();
		 j.hasNext();
		 ) {
			 importModels.add( j.next() );
		 }
		 assertEquals( ""n import models should be "", 3, importModels.size() );
		 int nImports = 0;
		 for ( OntModel x : importModels ) {
			 nImports += x.countSubModels();
		 }
		 assertEquals( ""Wrong number of sub-model imports"", 0, nImports );
	 }
	 public void testListSubModels1() {
		 OntModel m = ModelFactory.createOntologyModel();
		 m.read( ""file:testing/ontology/testImport6/a.owl"" );
		 assertEquals( ""Marker count not correct"", 4, TestOntDocumentManager.countMarkers( m ) );
		 List<OntModel> importModels = new ArrayList<>();
		 for (Iterator<OntModel> j = m.listSubModels( true );
		 j.hasNext();
		 ) {
			 importModels.add( j.next() );
		 }
		 assertEquals( ""n import models should be "", 3, importModels.size() );
		 int nImports = 0;
		 for ( OntModel x : importModels ) {
			 nImports += x.countSubModels();
		 }
		 assertEquals( ""Wrong number of sub-model imports"", 2, nImports );
	 }
	 public void testGetImportedModel() {
		 OntModel m = ModelFactory.createOntologyModel();
		 m.read( ""file:testing/ontology/testImport6/a.owl"" );
		 OntModel m0 = m.getImportedModel( ""file:testing/ontology/testImport6/b.owl"" );
		 OntModel m1 = m.getImportedModel( ""file:testing/ontology/testImport6/c.owl"" );
		 OntModel m2 = m.getImportedModel( ""file:testing/ontology/testImport6/d.owl"" );
		 OntModel m3 = m.getImportedModel( ""file:testing/ontology/testImport6/b.owl"" ) .getImportedModel( ""file:testing/ontology/testImport6/c.owl"" );
		 OntModel m4 = m.getImportedModel( ""file:testing/ontology/testImport6/a.owl"" );
		 assertNotNull( ""Import model b should not be null"", m0 );
		 assertNotNull( ""Import model c should not be null"", m1 );
		 assertNotNull( ""Import model d should not be null"", m2 );
		 assertNotNull( ""Import model b-c should not be null"", m3 );
		 assertNull( ""Import model a should be null"", m4 );
	 }
	 public void testProfiles() {
		 List<Class<?>> notInDL = Arrays.asList( new Class<?>[] {
		}
		 );
		 List<Class<?>> notInLite = Arrays.asList( new Class<?>[] {
		DataRange.class, HasValueRestriction.class}
		 );
		 Map<Class<?>, SupportsCheck> fullProfileMap = new OWLProfileExt().getSupportsMap();
		 Map<Class<?>, SupportsCheck> dlProfileMap = new OWLDLProfileExt().getSupportsMap();
		 Map<Class<?>, SupportsCheck> liteProfileMap = new OWLLiteProfileExt().getSupportsMap();
		 for ( Map.Entry<Class<?>, SupportsCheck> entry : fullProfileMap.entrySet() ) {
			 Class<?> c = entry.getKey();
			 assertTrue( ""Key in OWL DL profile: "" + c.getName(), dlProfileMap.containsKey( c ) || notInDL.contains( c ) );
			 assertTrue( ""Key in OWL lite profile: "" + c.getName(), liteProfileMap.containsKey( c ) || notInLite.contains( c ) );
		 }
	 }
	 public void testBulkAddWorks() {
		 OntModel om1= ModelFactory.createOntologyModel();
		 OntModel om2 = ModelFactory.createOntologyModel();
		 om1.add( om2 );
	 }
	 public void testRead() {
		 String base0 = ""http: String ns0 = base0 + ""#"";
		 String base1 = ""http: String ns1 = base1 + ""#"";
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 m.getDocumentManager().reset();
		 m.getDocumentManager().addAltEntry( base0, ""file:testing/ontology/relativenames.rdf"" );
		 m.read( base0, ""RDF/XML"" );
		 assertNotNull( ""Should be a class ns0:A"", m.getOntClass( ns0 + ""A"" ) );
		 assertNull( ""Should not be a class ns1:A"", m.getOntClass( ns1 + ""A"" ) );
		 m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 m.getDocumentManager().reset();
		 m.getDocumentManager().addAltEntry( base0, ""file:testing/ontology/relativenames.rdf"" );
		 m.read( base0, base1, ""RDF/XML"" );
		 assertNull( ""Should not be a class ns0:A"", m.getOntClass( ns0 + ""A"" ) );
		 assertNotNull( ""Should be a class ns1:A"", m.getOntClass( ns1 + ""A"" ) );
	 }
	 public void testListDataRange() {
		 String base = ""http: String doc = ""<?xml version='1.0'?>"" + ""<!DOCTYPE owl ["" + "" <!ENTITY rdf 'http: + "" <!ENTITY rdfs 'http: + "" <!ENTITY xsd 'http: + "" <!ENTITY owl 'http: + "" <!ENTITY dc 'http: + "" <!ENTITY base 'http: + "" ]>"" + ""<rdf:RDF"" + "" xmlns:rdf='http: + "" xmlns:owl='http: + "" <owl:DataRange>"" + "" <owl:oneOf>"" + "" <rdf:List>"" + "" <rdf:first rdf:datatype='&xsd;
		integer'>0</rdf:first>"" + "" <rdf:rest rdf:resource='&rdf;
		nil' />"" + "" </rdf:List>"" + "" </owl:oneOf>"" + "" </owl:DataRange>"" + ""</rdf:RDF>"";
		 OntModel m = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM, null);
		 m.read(new StringReader(doc), base);
		 Iterator<DataRange> i = m.listDataRanges();
		 assertTrue( ""Should be at least one DataRange"", i.hasNext() );
		 Object dr = i.next();
		 assertInstanceOf( DataRange.class, dr );
		 assertFalse( ""Should no more DataRange"", i.hasNext() );
	 }
	 public void testListHierarchyRoots0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 assertFalse( m.listHierarchyRootClasses().hasNext() );
		 m = ModelFactory.createOntologyModel( OntModelSpec.RDFS_MEM );
		 assertFalse( m.listHierarchyRootClasses().hasNext() );
	 }
	 public void testListHierarchyRoots1() {
		 String doc = "" rdf: <http: + "" rdfs: <http: + "" xsd: <http: + "" owl: <http: + "" : <"" + NS + "">. "" + "":A a owl:Class. "" ;
		 OntModel m = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM, null);
		 m.read( new StringReader(doc), NS, ""N3"" );
		 OntClass a = m.getOntClass(NS+""A"");
		 TestUtil.assertIteratorValues( this, m.listHierarchyRootClasses(), new Object[] {
		a}
		 );
	 }
	 public void testListHierarchyRoots2() {
		 String doc = "" rdf: <http: + "" rdfs: <http: + "" xsd: <http: + "" owl: <http: + "" : <"" + NS + "">. "" + "":A a owl:Class. "" ;
		 OntModel m = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM_RULE_INF, null);
		 m.read( new StringReader(doc), NS, ""N3"" );
		 OntClass a = m.getOntClass(NS+""A"");
		 TestUtil.assertIteratorValues( this, m.listHierarchyRootClasses(), new Object[] {
		a}
		 );
	 }
	 public void testListHierarchyRoots3() {
		 String doc = "" rdf: <http: + "" rdfs: <http: + "" xsd: <http: + "" owl: <http: + "" : <"" + NS + "">. "" + "":A a owl:Class. "" + "":B a owl:Class ;
		 rdfs:subClassOf :A . "" ;
		 OntModel m = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM_MINI_RULE_INF, null);
		 m.read( new StringReader(doc), NS, ""N3"" );
		 OntClass a = m.getOntClass(NS+""A"");
		 TestUtil.assertIteratorValues( this, m.listHierarchyRootClasses(), new Object[] {
		a}
		 );
	 }
	 public void testListHierarchyRoots4() {
		 String doc = "" rdf: <http: + "" rdfs: <http: + "" xsd: <http: + "" owl: <http: + "" : <"" + NS + "">. "" + "":A a rdfs:Class. "" + "":C a rdfs:Class. "" + "":B a rdfs:Class ;
		 rdfs:subClassOf :A . "" ;
		 OntModel m = ModelFactory.createOntologyModel(OntModelSpec.RDFS_MEM_RDFS_INF, null);
		 m.read( new StringReader(doc), NS, ""N3"" );
		 OntClass a = m.getOntClass(NS+""A"");
		 OntClass c = m.getOntClass(NS+""C"");
		 TestUtil.assertIteratorValues( this, m.listHierarchyRootClasses(), new Object[] {
		a,c}
		 );
	 }
	 public void testLoadImports0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 Resource a = m.getResource( ""file:testing/ontology/testImport3/a.owl"" );
		 Resource b = m.getResource( ""file:testing/ontology/testImport3/b.owl"" );
		 m.add( a, m.getProfile().IMPORTS(), b );
		 assertEquals( ""Marker count not correct"", 0, TestOntDocumentManager.countMarkers( m ) );
		 assertFalse( ""c should not be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/c.owl"" ) );
		 assertFalse( ""b should not be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/b.owl"" ) );
		 m.loadImports();
		 assertEquals( ""Marker count not correct"", 2, TestOntDocumentManager.countMarkers( m ) );
		 assertTrue( ""c should be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/c.owl"" ) );
		 assertTrue( ""b should be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/b.owl"" ) );
	 }
	 public void testLoadImports1() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 Resource a = m.getResource( ""file:testing/ontology/testImport3/a.owl"" );
		 Resource b = m.getResource( ""file:testing/ontology/testImport3/b.owl"" );
		 m.setDynamicImports( true );
		 m.add( a, m.getProfile().IMPORTS(), b );
		 assertEquals( ""Marker count not correct"", 2, TestOntDocumentManager.countMarkers( m ) );
		 assertTrue( ""c should be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/c.owl"" ) );
		 assertTrue( ""b should be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/b.owl"" ) );
		 m.loadImports();
		 assertEquals( ""Marker count not correct"", 2, TestOntDocumentManager.countMarkers( m ) );
		 assertTrue( ""c should be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/c.owl"" ) );
		 assertTrue( ""b should be imported"", m.hasLoadedImport( ""file:testing/ontology/testImport3/b.owl"" ) );
	 }
	 public void testLoadImports2() {
		 OntModel ontModel = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM, null);
		 ontModel.read(""file:testing/ontology/testImport8/a.owl"");
		 String NSa = ""http: String NSb = ""http: OntClass A = ontModel.getOntClass(NSa + ""A"");
		 assertTrue( ontModel.isInBaseModel(A));
		 OntClass B = ontModel.getOntClass(NSb + ""B"");
		 assertFalse( ontModel.isInBaseModel(B));
		 assertTrue( ontModel.isInBaseModel(ontModel.createStatement(A, RDF.type, OWL.Class)));
		 assertFalse( ontModel.isInBaseModel(ontModel.createStatement(B, RDF.type, OWL.Class)));
	 }
	 public void testAddImports0() {
		 OntModel base = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 base.createClass( NS + ""A"" );
		 base.createClass( NS + ""B"" );
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_MICRO_RULE_INF, base );
		 OntClass a = m.getOntClass( NS + ""A"" );
		 OntClass b = m.getOntClass( NS + ""B"" );
		 assertFalse( a.hasSubClass( b ) );
		 OntModel imp = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 imp.add( b, RDFS.subClassOf, a );
		 m.addSubModel( imp, true );
		 assertTrue( a.hasSubClass( b ) );
	 }
	 public void testAddImports1() {
		 String ns = ""http: OntModel base = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 OntDocumentManager odm = OntDocumentManager.getInstance();
		 odm.addAltEntry( ns + ""#a"", ""file:testing/ontology/testImport7/a.owl"" );
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_MICRO_RULE_INF, base );
		 Ontology oo = base.createOntology( ns );
		 oo.addImport( base.createResource( ns + ""#a"") );
		 Resource a = m.getResource( ns + ""#A"" );
		 Resource c = m.getResource( ns + ""#C"" );
		 assertFalse( m.contains( c, RDFS.subClassOf, a ) );
		 m.getDocumentManager().loadImports( m );
		 assertTrue( m.contains( c, RDFS.subClassOf, a ) );
	 }
	 public void testaddSubModel0() {
		 OntModel m0 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 OntModel m1 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 OntClass c = m1.createClass( NS + ""c"" );
		 assertFalse( m0.containsResource( c ) );
		 m0.addSubModel( m1 );
		 assertTrue( m0.containsResource( c ) );
		 m0.removeSubModel( m1 );
		 assertFalse( m0.containsResource( c ) );
	 }
	 public void testaddSubModel1() {
		 OntDocumentManager.getInstance().setProcessImports( false );
		 OntDocumentManager.getInstance().addAltEntry( ""http: ""file:testing/ontology/owl/Wine/wine.owl"" );
		 OntModel m0 = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM_MICRO_RULE_INF);
		 OntModel m1 = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM);
		 String namespace = ""http: String classURI = namespace + ""#Wine"";
		 m1.read(namespace);
		 OntClass c = m1.getOntClass(classURI);
		 assertFalse(m0.containsResource(c));
		 m0.addSubModel(m1);
		 assertTrue(m0.containsResource(c));
		 m0.removeSubModel(m1);
		 assertFalse(m0.containsResource(c));
	 }
	 public void testaddSubModel3() {
		 OntModel m0 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 OntModel m1 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_RDFS_INF );
		 OntClass c = m1.createClass( NS + ""c"" );
		 assertFalse( m0.containsResource( c ) );
		 m0.addSubModel( m1 );
		 assertTrue( m0.containsResource( c ) );
		 m0.removeSubModel( m1 );
		 assertFalse( m0.containsResource( c ) );
	 }
	 public void testaddSubModel4() {
		 OntModel m0 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_RDFS_INF );
		 OntModel m1 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_RDFS_INF );
		 OntClass c = m1.createClass( NS + ""c"" );
		 assertFalse( m0.containsResource( c ) );
		 m0.addSubModel( m1 );
		 assertTrue( m0.containsResource( c ) );
		 m0.removeSubModel( m1 );
		 assertFalse( m0.containsResource( c ) );
	 }
	 public void testremoveSubModel0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM, null );
		 m.read( ""file:testing/ontology/testImport3/a.owl"" );
		 assertEquals( 2, m.getSubGraphs().size() );
		 for (Iterator<OntModel> it = m.listSubModels();
		 it.hasNext();
		) {
			 m.removeSubModel( it.next() );
		 }
		 assertEquals( 0, m.getSubGraphs().size() );
	 }
	 public void xxtestGetDeductionsModel0() {
		 OntModel m = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM_MICRO_RULE_INF );
		 OntClass a = m.createClass( NS + ""A"" );
		 OntClass b = m.createClass( NS + ""B"" );
		 OntClass c = m.createClass( NS + ""C"" );
		 b.addSubClass( c );
		 Model dm = m.getDeductionsModel();
		 assertTrue( dm.contains( OWL.Nothing, RDFS.subClassOf, a ) );
		 assertTrue( dm.contains( OWL.Nothing, RDFS.subClassOf, c ) );
		 a.addSubClass( b );
		 assertTrue( a.hasSubClass( c ));
		 dm = m.getDeductionsModel();
		 assertFalse( dm.contains( OWL.Nothing, RDFS.subClassOf, a ) );
		 assertTrue( dm.contains( OWL.Nothing, RDFS.subClassOf, c ) );
	 }
	 public void testImportClosedModel() {
		 String SOURCEA= ""<rdf:RDF"" + "" xmlns:rdf ='http: "" xmlns:owl ='http: "" xml:base ='http: "">"" + "" <owl:Ontology>"" + "" <owl:imports rdf:resource='http: "" </owl:Ontology>"" + ""</rdf:RDF>"";
		 OntDocumentManager.getInstance().addAltEntry( ""http: OntModel a0 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 a0.read( new StringReader( SOURCEA ), null );
		 long a0count = a0.size();
		 OntDocumentManager.getInstance().getModel( ""http: OntModel a1 = ModelFactory.createOntologyModel( OntModelSpec.OWL_MEM );
		 a1.read( new StringReader( SOURCEA ), null );
		 assertEquals( ""Models should be same size"", a0count, a1.size() );
	 }
	 public void testReadConneg0() {
		 final boolean[] acceptHeaderSet = new boolean[] {
		false}
		;
		 OntModel m = new OntModelImpl(OntModelSpec.OWL_MEM) {
			 protected Model readDelegate( String url ) {
				 acceptHeaderSet[0] = true;
				 return super.readDelegate( url );
			 }
			 public boolean ignoreFileURI( String url ) {
				 return false;
			 }
		 }
		;
		 assertFalse( acceptHeaderSet[0] );
		 m.read( ""file:testing/ontology/owl/Property/test.rdf"" );
		 assertTrue( acceptHeaderSet[0] );
	 }
	 public void testReadConneg1() {
		 final boolean[] acceptHeaderSet = new boolean[] {
		false}
		;
		 OntModel m = new OntModelImpl(OntModelSpec.OWL_MEM) {
			 protected Model readDelegate( String url ) {
				 acceptHeaderSet[0] = true;
				 return super.readDelegate( url );
			 }
		 }
		;
		 assertFalse( acceptHeaderSet[0] );
		 m.read( ""file:testing/ontology/owl/Property/test.rdf"" );
		 assertFalse( acceptHeaderSet[0] );
	 }
	 public void testReadConneg2() {
		 final boolean[] acceptHeaderSet = new boolean[] {
		false}
		;
		 OntModel m = new OntModelImpl(OntModelSpec.OWL_MEM) {
			 protected Model readDelegate( String url, String lang ) {
				 acceptHeaderSet[0] = true;
				 return super.readDelegate( url, lang );
			 }
			 public boolean ignoreFileURI( String url ) {
				 return false;
			 }
		 }
		;
		 assertFalse( acceptHeaderSet[0] );
		 m.read( ""file:testing/ontology/owl/Property/test.rdf"", ""RDF/XML"" );
		 assertTrue( acceptHeaderSet[0] );
	 }
	 public void testReadConneg3() {
		 final boolean[] acceptHeaderSet = new boolean[] {
		false}
		;
		 OntModel m = new OntModelImpl(OntModelSpec.OWL_MEM) {
			 protected Model readDelegate( String url, String lang ) {
				 acceptHeaderSet[0] = true;
				 return super.readDelegate( url, lang );
			 }
			 public boolean ignoreFileURI( String url ) {
				 return false;
			 }
		 }
		;
		 assertFalse( acceptHeaderSet[0] );
		 m.read( ""file:testing/ontology/owl/Property/test.rdf"", ""http: assertFalse( acceptHeaderSet[0] );
	 }
	 private boolean iteratorContains( Iterator<?> i, Object x ) {
		 boolean found = false;
		 while (i.hasNext()) {
			 found = i.next().equals( x ) || found;
		 }
		 return found;
	 }
	 protected class OWLProfileExt extends OWLProfile {
		 public Map<Class<?>, SupportsCheck> getSupportsMap() {
			 return getCheckTable();
		 }
	 }
	 protected class OWLDLProfileExt extends OWLDLProfile {
		 public Map<Class<?>, SupportsCheck> getSupportsMap() {
			 return getCheckTable();
		 }
	 }
	 protected class OWLLiteProfileExt extends OWLLiteProfile {
		 public Map<Class<?>, SupportsCheck> getSupportsMap() {
			 return getCheckTable();
		 }
	 }
}",1,0,0,0
"public class ClickHouseScrollableResultSet extends ClickHouseResultSet {
	 private List<ByteFragment[]> lines;
	 public ClickHouseScrollableResultSet(InputStream is, int bufferSize, String db, String table, boolean usesWithTotals, ClickHouseStatement statement, TimeZone timezone, ClickHouseProperties properties) throws IOException {
		 super(is, bufferSize, db, table, usesWithTotals, statement, timezone, properties);
		 lines = new ArrayList<ByteFragment[]>();
	 }
	 public boolean hasNext() throws SQLException {
		 if(rowNumber < lines.size()) {
			 return true;
		 }
		 return super.hasNext();
	 }
	 public boolean next() throws SQLException {
		 if(rowNumber < lines.size()) {
			 values = lines.get(rowNumber);
			 nextLine = null;
			 rowNumber += 1;
			 return true;
		 }
		 if (hasNext()) {
			 super.next();
			 lines.add(values);
			 return true;
		 }
		 else {
			 rowNumber += 1;
			 values = null;
			 nextLine = null;
			 return false;
		 }
	 }
	 public int getType() throws SQLException {
		 return TYPE_SCROLL_INSENSITIVE;
	 }
	 public int getRow() throws SQLException {
		 return rowNumber;
	 }
	public boolean isBeforeFirst() throws SQLException {
		return getRow() == 0;
	}
	public boolean isAfterLast() throws SQLException {
		return getRow() > lines.size();
	}
	public boolean isFirst() throws SQLException {
		return getRow() == 1;
	}
	public void beforeFirst() throws SQLException {
		absolute(0);
	}
	public void afterLast() throws SQLException {
		absolute(-1);
		next();
	}
	public boolean first() throws SQLException {
		return absolute(1);
	}
	public boolean last() throws SQLException {
		return absolute(-1);
	}
	public boolean absolute(int row) throws SQLException {
		if(row == 0) {
			rowNumber = 0;
			values = null;
			return false;
		}
		 else if(row > 0) {
			if(row <= lines.size()) {
				rowNumber = row;
				values = lines.get(row-1);
				return true;
			}
			absolute(lines.size());
			while(getRow() < row && hasNext()) {
				next();
			}
			if(row == getRow()) {
				return true;
			}
			 else {
				next();
				return false;
			}
		}
		 else {
			while(hasNext()) {
				next();
			}
			if(-row > lines.size()) {
				return absolute(0);
			}
			return absolute(lines.size()+1+row);
		}
	}
	public boolean relative(int rows) throws SQLException {
		int r = getRow()+rows;
		if(r < 0) {
			r = 0;
		}
		return absolute(r);
	}
	public boolean previous() throws SQLException {
		return relative(-1);
	}
}",1,1,0,0
"private static class UserHeaderClickListener implements View.OnClickListener {
	 private final Fragment fragment;
	 public UserHeaderClickListener(Fragment fragment) {
		 this.fragment = fragment;
	 }
	 public void onClick(View view) {
		 UserCompactView user = (UserCompactView) view.getTag(R.id.es_keyUser);
		 EventBus.post(new OpenUserProfileEvent(fragment, user));
	 }
 }",0,0,0,0
"public final class DirectRabbitListenerContainerFactoryConfigurer extendsAbstractRabbitListenerContainerFactoryConfigurer<DirectRabbitListenerContainerFactory> {
	public void configure(DirectRabbitListenerContainerFactory factory,ConnectionFactory connectionFactory) {
		PropertyMapper map = PropertyMapper.get();
		RabbitProperties.DirectContainer config = getRabbitProperties().getListener().getDirect();
		configure(factory, connectionFactory, config);
		map.from(config::getConsumersPerQueue).whenNonNull().to(factory::setConsumersPerQueue);
	}
}",0,0,0,0
"public String getServer() {
	 return server;
 }",0,0,0,0
"public void init() {
	if (!init) {
		Logger.log(""Context initialized"");
		System.setProperty(""http.auth.preference"", ""ntlm"");
		try {
			try {
				sslContext = SSLContext.getInstance(""TLS"");
			}
			 catch (Exception e) {
				e.printStackTrace();
				sslContext = SSLContext.getInstance(""SSL"");
			}
			TrustManager[] trustAllCerts = new TrustManager[] {
				 new X509ExtendedTrustManager() {
					public void checkClientTrusted(X509Certificate[] chain, String authType)throws CertificateException {
					}
					public void checkServerTrusted(X509Certificate[] chain, String authType)throws CertificateException {
					}
					public X509Certificate[] getAcceptedIssuers() {
						return null;
					}
					public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)throws CertificateException {
					}
					public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)throws CertificateException {
					}
					public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)throws CertificateException {
					}
					public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)throws CertificateException {
					}
				}
			 }
			;
			sslContext.init(null, trustAllCerts, new SecureRandom());
			HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
		}
		 catch (Exception e) {
			Logger.log(e);
		}
		Authenticator.setDefault(new Authenticator() {
			protected PasswordAuthentication getPasswordAuthentication() {
				System.out.println(""Called on "" + getRequestorType() + "" scheme: "" + getRequestingScheme()+ "" host: "" + getRequestingHost() + "" url: "" + getRequestingURL() + "" prompt: ""+ getRequestingPrompt());
				if (getRequestorType() == RequestorType.SERVER) {
					PasswordAuthentication pauth = CredentialManager.getInstance().getCredentialForHost(getRequestingHost());
					return pauth;
				}
				 else {
					return CredentialManager.getInstance().getCredentialForProxy();
				}
			 }
		}
		);
		init = true;
	}
}",0,0,1,0
"public void clear() {
	 this.path = null;
 }",0,0,0,0
"static DTMAxisIterator document(String uri, String base, AbstractTranslet translet, DOM dom, boolean cacheDOM) throws Exception;",0,0,0,1
"public interface EditPartListener {
	public class Stub implements EditPartListener {
		public void childAdded(EditPart child, int index) {
		}
		public void partActivated(EditPart editpart) {
		}
		public void partDeactivated(EditPart editpart) {
		}
		public void removingChild(EditPart child, int index) {
		}
		public void selectedStateChanged(EditPart part) {
		}
	}
	;
	void childAdded(EditPart child, int index);
	void partActivated(EditPart editpart);
	void partDeactivated(EditPart editpart);
	void removingChild(EditPart child, int index);
	void selectedStateChanged(EditPart editpart);
}",0,0,0,0
"private void determineDependencies() throws IOException {
	 affectedClassMap = new Hashtable();
	 classFileInfoMap = new Hashtable();
	 boolean cacheDirty = false;
	 Hashtable dependencyMap = new Hashtable();
	 File cacheFile = null;
	 boolean cacheFileExists = true;
	 long cacheLastModified = Long.MAX_VALUE;
	 if (cache != null) {
		 cacheFile = new File(cache, CACHE_FILE_NAME);
		 cacheFileExists = cacheFile.exists();
		 cacheLastModified = cacheFile.lastModified();
		 if (cacheFileExists) {
			 dependencyMap = readCachedDependencies(cacheFile);
		 }
	 }
	 Enumeration classfileEnum = getClassFiles(destPath).elements();
	 while (classfileEnum.hasMoreElements()) {
		 ClassFileInfo info = (ClassFileInfo) classfileEnum.nextElement();
		 log(""Adding class info for "" + info.className, Project.MSG_DEBUG);
		 classFileInfoMap.put(info.className, info);
		 Vector dependencyList = null;
		 if (cache != null) {
			 if (cacheFileExists && cacheLastModified > info.absoluteFile.lastModified()) {
				 dependencyList = (Vector) dependencyMap.get(info.className);
			 }
		 }
		 if (dependencyList == null) {
			 DependencyAnalyzer analyzer = new AntAnalyzer();
			 analyzer.addRootClass(info.className);
			 analyzer.addClassPath(destPath);
			 analyzer.setClosure(false);
			 dependencyList = new Vector();
			 Enumeration depEnum = analyzer.getClassDependencies();
			 while (depEnum.hasMoreElements()) {
				 dependencyList.addElement(depEnum.nextElement());
			 }
			 cacheDirty = true;
			 dependencyMap.put(info.className, dependencyList);
		 }
		 Enumeration depEnum = dependencyList.elements();
		 while (depEnum.hasMoreElements()) {
			 String dependentClass = (String) depEnum.nextElement();
			 Hashtable affectedClasses = (Hashtable) affectedClassMap.get(dependentClass);
			 if (affectedClasses == null) {
				 affectedClasses = new Hashtable();
				 affectedClassMap.put(dependentClass, affectedClasses);
			 }
			 affectedClasses.put(info.className, info);
		 }
	 }
	 classpathDependencies = null;
	 Path checkPath = getCheckClassPath();
	 if (checkPath != null) {
		 classpathDependencies = new Hashtable();
		 AntClassLoader loader = getProject().createClassLoader(checkPath);
		 Hashtable classpathFileCache = new Hashtable();
		 Object nullFileMarker = new Object();
		 for (Enumeration e = dependencyMap.keys();
		 e.hasMoreElements();
		) {
			 String className = (String) e.nextElement();
			 Vector dependencyList = (Vector) dependencyMap.get(className);
			 Hashtable dependencies = new Hashtable();
			 classpathDependencies.put(className, dependencies);
			 Enumeration e2 = dependencyList.elements();
			 while (e2.hasMoreElements()) {
				 String dependency = (String) e2.nextElement();
				 Object classpathFileObject = classpathFileCache.get(dependency);
				 if (classpathFileObject == null) {
					 classpathFileObject = nullFileMarker;
					 if (!dependency.startsWith(""java."") && !dependency.startsWith(""javax."")) {
						 URL classURL = loader.getResource(dependency.replace('.', '/') + "".class"");
						 if (classURL != null) {
							 if (classURL.getProtocol().equals(""jar"")) {
								 String jarFilePath = classURL.getFile();
								 int classMarker = jarFilePath.indexOf('!');
								 jarFilePath = jarFilePath.substring(0, classMarker);
								 if (jarFilePath.startsWith(""file:"")) {
									 classpathFileObject = new File( FileUtils.getFileUtils().fromURI(jarFilePath));
								 }
								 else {
									 throw new IOException( ""Bizarre nested path in jar: protocol: "" + jarFilePath);
								 }
							 }
							 else if (classURL.getProtocol().equals(""file"")) {
								 classpathFileObject = new File( FileUtils.getFileUtils() .fromURI(classURL.toExternalForm()));
							 }
							 log(""Class "" + className + "" depends on "" + classpathFileObject + "" due to "" + dependency, Project.MSG_DEBUG);
						 }
					 }
					 classpathFileCache.put(dependency, classpathFileObject);
				 }
				 if (classpathFileObject != nullFileMarker) {
					 File jarFile = (File) classpathFileObject;
					 dependencies.put(jarFile, jarFile);
				 }
			 }
		 }
	 }
	 if (cache != null && cacheDirty) {
		 writeCachedDependencies(dependencyMap);
	 }
 }",0,0,1,0
"private String macroSubs(String s, Map macroMapping) {
	 if (s == null) {
		 return null;
	 }
	 StringBuffer ret = new StringBuffer();
	 StringBuffer macroName = null;
	 int state = STATE_NORMAL;
	 for (int i = 0;
	 i < s.length();
	 ++i) {
		 char ch = s.charAt(i);
		 switch (state) {
			 case STATE_NORMAL: if (ch == '@') {
				 state = STATE_EXPECT_BRACKET;
			 }
			 else {
				 ret.append(ch);
			 }
			 break;
			 case STATE_EXPECT_BRACKET: if (ch == '{
				') {
					 state = STATE_EXPECT_NAME;
					 macroName = new StringBuffer();
				 }
				 else if (ch == '@') {
					 state = STATE_NORMAL;
					 ret.append('@');
				 }
				 else {
					 state = STATE_NORMAL;
					 ret.append('@');
					 ret.append(ch);
				 }
				 break;
			 case STATE_EXPECT_NAME: if (ch == '}
			') {
				 state = STATE_NORMAL;
				 String name = macroName.toString().toLowerCase(Locale.ENGLISH);
				 String value = (String) macroMapping.get(name);
				 if (value == null) {
					 ret.append(""@{
						"");
						 ret.append(name);
					 ret.append(""}
					"");
				 }
				 else {
					 ret.append(value);
				 }
				 macroName = null;
			 }
			 else {
				 macroName.append(ch);
			 }
			 break;
			 default: break;
		 }
	 }
	 switch (state) {
		 case STATE_NORMAL: break;
		 case STATE_EXPECT_BRACKET: ret.append('@');
		 break;
		 case STATE_EXPECT_NAME: ret.append(""@{
			"");
			 ret.append(macroName.toString());
			 break;
			 default: break;
		 }
		 return ret.toString();
	 }
	 public void addText(String text) {
		 this.text = text;
	 }
	 private UnknownElement copy(UnknownElement ue, boolean nested) {
		 UnknownElement ret = new UnknownElement(ue.getTag());
		 ret.setNamespace(ue.getNamespace());
		 ret.setProject(getProject());
		 ret.setQName(ue.getQName());
		 ret.setTaskType(ue.getTaskType());
		 ret.setTaskName(ue.getTaskName());
		 ret.setLocation( macroDef.getBackTrace() ? ue.getLocation() : getLocation());
		 if (getOwningTarget() == null) {
			 Target t = new Target();
			 t.setProject(getProject());
			 ret.setOwningTarget(t);
		 }
		 else {
			 ret.setOwningTarget(getOwningTarget());
		 }
		 RuntimeConfigurable rc = new RuntimeConfigurable( ret, ue.getTaskName());
		 rc.setPolyType(ue.getWrapper().getPolyType());
		 Map m = ue.getWrapper().getAttributeMap();
		 for (Iterator i = m.entrySet().iterator();
		 i.hasNext();
		) {
			 Map.Entry entry = (Map.Entry) i.next();
			 rc.setAttribute( (String) entry.getKey(), macroSubs((String) entry.getValue(), localAttributes));
		 }
		 rc.addText(macroSubs(ue.getWrapper().getText().toString(), localAttributes));
		 Enumeration e = ue.getWrapper().getChildren();
		 while (e.hasMoreElements()) {
			 RuntimeConfigurable r = (RuntimeConfigurable) e.nextElement();
			 UnknownElement unknownElement = (UnknownElement) r.getProxy();
			 String tag = unknownElement.getTaskType();
			 if (tag != null) {
				 tag = tag.toLowerCase(Locale.ENGLISH);
			 }
			 MacroDef.TemplateElement templateElement = (MacroDef.TemplateElement) getNsElements().get(tag);
			 if (templateElement == null || nested) {
				 UnknownElement child = copy(unknownElement, nested);
				 rc.addChild(child.getWrapper());
				 ret.addChild(child);
			 }
			 else if (templateElement.isImplicit()) {
				 if (unknownElements.size() == 0 && !templateElement.isOptional()) {
					 throw new BuildException( ""Missing nested elements for implicit element "" + templateElement.getName());
				 }
				 for (Iterator i = unknownElements.iterator();
				 i.hasNext();
				) {
					 UnknownElement child = copy((UnknownElement) i.next(), true);
					 rc.addChild(child.getWrapper());
					 ret.addChild(child);
				 }
			 }
			 else {
				 UnknownElement presentElement = (UnknownElement) presentElements.get(tag);
				 if (presentElement == null) {
					 if (!templateElement.isOptional()) {
						 throw new BuildException( ""Required nested element "" + templateElement.getName() + "" missing"");
					 }
					 continue;
				 }
				 String presentText = presentElement.getWrapper().getText().toString();
				 if (!"""".equals(presentText)) {
					 rc.addText(macroSubs(presentText, localAttributes));
				 }
				 List list = presentElement.getChildren();
				 if (list != null) {
					 for (Iterator i = list.iterator();
					 i.hasNext();
					) {
						 UnknownElement child = copy((UnknownElement) i.next(), true);
						 rc.addChild(child.getWrapper());
						 ret.addChild(child);
					 }
				 }
			 }
		 }
		 return ret;
	 }
	 public void execute() {
		 presentElements = new HashMap();
		 getNsElements();
		 processTasks();
		 localAttributes = new Hashtable();
		 Set copyKeys = new HashSet(map.keySet());
		 for (Iterator i = macroDef.getAttributes().iterator();
		 i.hasNext();
		) {
			 MacroDef.Attribute attribute = (MacroDef.Attribute) i.next();
			 String value = (String) map.get(attribute.getName());
			 if (value == null && ""description"".equals(attribute.getName())) {
				 value = getDescription();
			 }
			 if (value == null) {
				 value = attribute.getDefault();
				 value = macroSubs(value, localAttributes);
			 }
			 if (value == null) {
				 throw new BuildException( ""required attribute "" + attribute.getName() + "" not set"");
			 }
			 localAttributes.put(attribute.getName(), value);
			 copyKeys.remove(attribute.getName());
		 }
		 if (copyKeys.contains(""id"")) {
			 copyKeys.remove(""id"");
		 }
		 if (macroDef.getText() != null) {
			 if (text == null) {
				 String defaultText = macroDef.getText().getDefault();
				 if (!macroDef.getText().getOptional() && defaultText == null) {
					 throw new BuildException( ""required text missing"");
				 }
				 text = defaultText == null ? """" : defaultText;
			 }
			 if (macroDef.getText().getTrim()) {
				 text = text.trim();
			 }
			 localAttributes.put(macroDef.getText().getName(), text);
		 }
		 else {
			 if (text != null && !text.trim().equals("""")) {
				 throw new BuildException( ""The \"""" + getTaskName() + ""\"" macro does not support"" + "" nested text data."");
			 }
		 }
		 if (copyKeys.size() != 0) {
			 throw new BuildException( ""Unknown attribute"" + (copyKeys.size() > 1 ? ""s "" : "" "") + copyKeys);
		 }
		 UnknownElement c = copy(macroDef.getNestedTask(), false);
		 c.init();
		 LocalProperties localProperties = LocalProperties.get(getProject());
		 localProperties.enterScope();
		 try {
			 c.perform();
		 }
		 catch (BuildException ex) {
			 if (macroDef.getBackTrace()) {
				 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
			 }
			 else {
				 ex.setLocation(getLocation());
				 throw ex;
			 }
		 }
		 finally {
			 presentElements = null;
			 localAttributes = null;
			 localProperties.exitScope();
		 }
	 }
}",0,0,0,0
"public abstract class RefreshUserToGroupsMappingsRequest {
	 public static RefreshUserToGroupsMappingsRequest newInstance() {
		 RefreshUserToGroupsMappingsRequest request = Records.newRecord(RefreshUserToGroupsMappingsRequest.class);
		 return request;
	 }
}",0,0,0,0
"private void route(Address dest, String group, byte[] msg);",0,0,0,0
"public void run() {
	 try {
		 if (image==null){
			 image = ImageIO.read(new File(textImageFile));
		 }
		 image = BinaryOps.binary(textImageFile);
		 File cropFile = crop(image);
		 File outputDirectory = new File(charOutputFile);
		 List<BufferedImage> lista = new ArrayList<BufferedImage>();
		 for (int i = 0;
		 i <= 7;
		 i++) {
			 File f = new File(""data/char_"" + i + "".png"");
			 BufferedImage bi = ImageIO.read(f);
			 lista.add(bi);
		 }
		 if (nnet==null){
			 NeuralNetwork nnet = NeuralNetwork.createFromFile(neuralNetworkFile);
		 }
		 nnet.addPlugin(new OcrPlugin(new Dimension(10, 10), ColorMode.BLACK_AND_WHITE));
		 OcrPlugin ocrPlugin = (OcrPlugin) nnet.getPlugin(OcrPlugin.class);
		 for (int i = 0;
		 i < lista.size();
		 i++) {
			 recognizedCharacters+=ocrPlugin.recognizeCharacter(new ImageJ2SE(lista.get(i))) + "" "";
			 System.out.print(ocrPlugin.recognizeCharacter(new ImageJ2SE(lista.get(i))) + "" "");
		 }
		 recognizedCharacters.trim();
	 }
	 catch (IOException e) {
		 System.out.println(""Error reading dir: "" + e.getMessage());
	 }
 }",0,0,1,0
"public void setMatchKeyList(ArrayList<String> matchKeyList) {
	 this.matchKeyList = matchKeyList;
 }",0,0,0,0
"public void setProprietaryIECssExpressionsSupported(boolean proprietaryIECssExpressionsSupported){
	this.proprietaryIECssExpressionsSupported = proprietaryIECssExpressionsSupported;
}",0,0,0,0
"public class PropertyResource extends Resource {
	 private static final int PROPERTY_MAGIC = Resource.getMagicNumber(""PropertyResource"".getBytes());
	 private static final InputStream UNSET = new InputStream() {
		 public int read() {
			 return -1;
		 }
	 }
	;
	 public PropertyResource() {
	 }
	 public PropertyResource(Project p, String n) {
		 super(n);
		 setProject(p);
	 }
	 public String getValue() {
		 if (isReference()) {
			 return ((PropertyResource) getCheckedRef()).getValue();
		 }
		 Project p = getProject();
		 return p == null ? null : p.getProperty(getName());
	 }
	 public Object getObjectValue() {
		 if (isReference()) {
			 return ((PropertyResource) getCheckedRef()).getObjectValue();
		 }
		 Project p = getProject();
		 return p == null ? null : PropertyHelper.getProperty(p, getName());
	 }
	 public boolean isExists() {
		 if (isReferenceOrProxy()) {
			 return getReferencedOrProxied().isExists();
		 }
		 return getObjectValue() != null;
	 }
	 public long getSize() {
		 if (isReferenceOrProxy()) {
			 return getReferencedOrProxied().getSize();
		 }
		 Object o = getObjectValue();
		 return o == null ? 0L : (long) String.valueOf(o).length();
	 }
	 public boolean equals(Object o) {
		 if (super.equals(o)) {
			 return true;
		 }
		 return isReferenceOrProxy() && getReferencedOrProxied().equals(o);
	 }
	 public int hashCode() {
		 if (isReferenceOrProxy()) {
			 return getReferencedOrProxied().hashCode();
		 }
		 return super.hashCode() * PROPERTY_MAGIC;
	 }
	 public String toString() {
		 if (isReferenceOrProxy()) {
			 return getReferencedOrProxied().toString();
		 }
		 return getValue();
	 }
	 public InputStream getInputStream() throws IOException {
		 if (isReferenceOrProxy()) {
			 return getReferencedOrProxied().getInputStream();
		 }
		 Object o = getObjectValue();
		 return o == null ? UNSET : new ByteArrayInputStream(String.valueOf(o).getBytes());
	 }
	 public OutputStream getOutputStream() throws IOException {
		 if (isReferenceOrProxy()) {
			 return getReferencedOrProxied().getOutputStream();
		 }
		 if (isExists()) {
			 throw new ImmutableResourceException();
		 }
		 return new PropertyOutputStream(getProject(), getName());
	 }
	 protected boolean isReferenceOrProxy() {
		 return isReference() || getObjectValue() instanceof Resource;
	 }
	 protected Resource getReferencedOrProxied() {
		 if (isReference()) {
			 return (Resource) getCheckedRef(Resource.class, ""resource"");
		 }
		 Object o = getObjectValue();
		 if (o instanceof Resource) {
			 return (Resource) o;
		 }
		 throw new IllegalStateException( ""This PropertyResource does not reference or proxy another Resource"");
	 }
}",0,0,0,0
"private void createResizeGrip() {
	GripMouseAdapter gma = new GripMouseAdapter();
	lblRightGrip = new JLabel();
	lblRightGrip.setMaximumSize(new Dimension(2, lblRightGrip.getMaximumSize().height));
	lblRightGrip.setPreferredSize(new Dimension(2, lblRightGrip.getPreferredSize().height));
	lblRightGrip.setBackground(Color.BLACK);
	lblRightGrip.setOpaque(true);
	contentPane.add(lblRightGrip, BorderLayout.EAST);
	lblBottomGrip = new JLabel();
	lblBottomGrip.setMaximumSize(new Dimension(lblBottomGrip.getPreferredSize().width, 2));
	lblBottomGrip.setPreferredSize(new Dimension(lblBottomGrip.getPreferredSize().width, 2));
	lblBottomGrip.setBackground(Color.BLACK);
	lblBottomGrip.setOpaque(true);
	contentPane.add(lblBottomGrip, BorderLayout.SOUTH);
	lblLeftGrip = new JLabel();
	lblLeftGrip.setMaximumSize(new Dimension(2, lblLeftGrip.getPreferredSize().height));
	lblLeftGrip.setPreferredSize(new Dimension(2, lblLeftGrip.getPreferredSize().height));
	lblLeftGrip.setBackground(Color.BLACK);
	lblLeftGrip.setOpaque(true);
	contentPane.add(lblLeftGrip, BorderLayout.WEST);
	lblTopGrip = new JLabel();
	lblTopGrip.setMaximumSize(new Dimension(lblTopGrip.getPreferredSize().width, 2));
	lblTopGrip.setPreferredSize(new Dimension(lblTopGrip.getPreferredSize().width, 2));
	lblTopGrip.setBackground(Color.BLACK);
	lblTopGrip.setOpaque(true);
	contentPane.add(lblTopGrip, BorderLayout.NORTH);
	if (isResizable()) {
		lblTopGrip.addMouseListener(gma);
		lblTopGrip.addMouseMotionListener(new MouseMotionAdapter() {
			public void mouseDragged(MouseEvent me) {
				int y = me.getYOnScreen();
				int diff = XDMFrame.this.getLocationOnScreen().y - y;
				XDMFrame.this.setLocation(XDMFrame.this.getLocation().x, me.getLocationOnScreen().y);
				XDMFrame.this.setSize(XDMFrame.this.getWidth(), XDMFrame.this.getHeight() + diff);
			}
		}
		);
		lblRightGrip.addMouseListener(gma);
		lblRightGrip.addMouseMotionListener(new MouseMotionAdapter() {
			public void mouseDragged(MouseEvent me) {
				int x = me.getXOnScreen();
				int diff = x - XDMFrame.this.getLocationOnScreen().x;
				XDMFrame.this.setSize(diff, XDMFrame.this.getHeight());
			}
		}
		);
		lblLeftGrip.addMouseListener(gma);
		lblLeftGrip.addMouseMotionListener(new MouseMotionAdapter() {
			public void mouseDragged(MouseEvent me) {
				int x = me.getXOnScreen();
				int diff = XDMFrame.this.getLocationOnScreen().x - x;
				XDMFrame.this.setLocation(me.getLocationOnScreen().x, XDMFrame.this.getLocation().y);
				XDMFrame.this.setSize(diff + XDMFrame.this.getWidth(), XDMFrame.this.getHeight());
			}
		}
		);
		lblBottomGrip.addMouseListener(gma);
		lblBottomGrip.addMouseMotionListener(new MouseMotionAdapter() {
			public void mouseDragged(MouseEvent me) {
				int y = me.getYOnScreen();
				int diff = y - XDMFrame.this.getLocationOnScreen().y;
				XDMFrame.this.setSize(XDMFrame.this.getWidth(), diff);
			}
		}
		);
	}
}",0,0,1,0
"public class TestFinanceLib extends AbstractNumericTestCase {
	 public void testFv() {
		 double f, r, y, p, x;
		 int n;
		 boolean t = false;
		 r = 0;
		 n = 3;
		 y = 2;
		 p = 7;
		 t = true;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = -13;
		 assertEquals(""fv "", x, f);
		 r = 1;
		 n = 10;
		 y = 100;
		 p = 10000;
		 t = false;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = -10342300;
		 assertEquals(""fv "", x, f);
		 r = 1;
		 n = 10;
		 y = 100;
		 p = 10000;
		 t = true;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = -10444600;
		 assertEquals(""fv "", x, f);
		 r = 2;
		 n = 12;
		 y = 120;
		 p = 12000;
		 t = false;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = -6409178400d;
		 assertEquals(""fv "", x, f);
		 r = 2;
		 n = 12;
		 y = 120;
		 p = 12000;
		 t = true;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = -6472951200d;
		 assertEquals(""fv "", x, f);
		 r = 2.95;
		 n = 13;
		 y = 13000;
		 p = -4406.78544294496;
		 t = false;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = 333891.230010986;
		 assertEquals(""fv "", x, f);
		 r = 2.95;
		 n = 13;
		 y = 13000;
		 p = -17406.7852148156;
		 t = true;
		 f = FinanceLib.fv(r, n, y, p, t);
		 x = 333891.230102539;
		 assertEquals(""fv "", x, f);
	 }
	 public void testNpv() {
		 double r;
		 double[] v;
		 double npv;
		 double x;
		 r = 1;
		 v = new double[]{
		100, 200, 300, 400}
		;
		 npv = FinanceLib.npv(r, v);
		 x = 162.5;
		 assertEquals(""npv "", x, npv);
		 r = 2.5;
		 v = new double[]{
		1000, 666.66666, 333.33, 12.2768416}
		;
		 npv = FinanceLib.npv(r, v);
		 x = 347.99232604144827;
		 assertEquals(""npv "", x, npv);
		 r = 12.33333;
		 v = new double[]{
		1000, 0, -900, -7777.5765}
		;
		 npv = FinanceLib.npv(r, v);
		 x = 74.3742433377061;
		 assertEquals(""npv "", x, npv);
		 r = 0.05;
		 v = new double[]{
		200000, 300000.55, 400000, 1000000, 6000000, 7000000, -300000}
		;
		 npv = FinanceLib.npv(r, v);
		 x = 11342283.4233124;
		 assertEquals(""npv "", x, npv);
	 }
	 public void testPmt() {
		 double f, r, y, p, x;
		 int n;
		 boolean t = false;
		 r = 0;
		 n = 3;
		 p = 2;
		 f = 7;
		 t = true;
		 y = FinanceLib.pmt(r, n, p, f, t);
		 x = -3;
		 assertEquals(""pmt "", x, y);
		 r = 1;
		 n = 10;
		 p = -109.66796875;
		 f = 10000;
		 t = false;
		 y = FinanceLib.pmt(r, n, p, f, t);
		 x = 100;
		 assertEquals(""pmt "", x, y);
		 r = 1;
		 n = 10;
		 p = -209.5703125;
		 f = 10000;
		 t = true;
		 y = FinanceLib.pmt(r, n, p, f, t);
		 x = 100;
		 assertEquals(""pmt "", x, y);
		 r = 2;
		 n = 12;
		 f = -6409178400d;
		 p = 12000;
		 t = false;
		 y = FinanceLib.pmt(r, n, p, f, t);
		 x = 120;
		 assertEquals(""pmt "", x, y);
		 r = 2;
		 n = 12;
		 f = -6472951200d;
		 p = 12000;
		 t = true;
		 y = FinanceLib.pmt(r, n, p, f, t);
		 x = 120;
		 assertEquals(""pmt "", x, y);
	 }
	 public void testPv() {
		 double f, r, y, p, x;
		 int n;
		 boolean t = false;
		 r = 0;
		 n = 3;
		 y = 2;
		 f = 7;
		 t = true;
		 f = FinanceLib.pv(r, n, y, f, t);
		 x = -13;
		 assertEquals(""pv "", x, f);
		 r = 1;
		 n = 10;
		 y = 100;
		 f = 10000;
		 t = false;
		 p = FinanceLib.pv(r, n, y, f, t);
		 x = -109.66796875;
		 assertEquals(""pv "", x, p);
		 r = 1;
		 n = 10;
		 y = 100;
		 f = 10000;
		 t = true;
		 p = FinanceLib.pv(r, n, y, f, t);
		 x = -209.5703125;
		 assertEquals(""pv "", x, p);
		 r = 2.95;
		 n = 13;
		 y = 13000;
		 f = 333891.23;
		 t = false;
		 p = FinanceLib.pv(r, n, y, f, t);
		 x = -4406.78544294496;
		 assertEquals(""pv "", x, p);
		 r = 2.95;
		 n = 13;
		 y = 13000;
		 f = 333891.23;
		 t = true;
		 p = FinanceLib.pv(r, n, y, f, t);
		 x = -17406.7852148156;
		 assertEquals(""pv "", x, p);
		 r = 2;
		 n = 12;
		 y = 120;
		 f = -6409178400d;
		 t = false;
		 p = FinanceLib.pv(r, n, y, f, t);
		 x = 12000;
		 assertEquals(""pv "", x, p);
		 r = 2;
		 n = 12;
		 y = 120;
		 f = -6472951200d;
		 t = true;
		 p = FinanceLib.pv(r, n, y, f, t);
		 x = 12000;
		 assertEquals(""pv "", x, p);
	 }
	 public void testNper() {
		 double f, r, y, p, x, n;
		 boolean t = false;
		 r = 0;
		 y = 7;
		 p = 2;
		 f = 3;
		 t = false;
		 n = FinanceLib.nper(r, y, p, f, t);
		 x = -0.71428571429;
		 assertEquals(""nper "", x, n);
		 r = 1;
		 y = 100;
		 p = -109.66796875;
		 f = 10000;
		 t = false;
		 n = FinanceLib.nper(r, y, p, f, t);
		 x = 10;
		 assertEquals(""nper "", x, n);
		 r = 1;
		 y = 100;
		 p = -209.5703125;
		 f = 10000;
		 t = true;
		 n = FinanceLib.nper(r, y, p, f, t);
		 x = 10;
		 assertEquals(""nper "", x, n);
		 r = 2;
		 y = 120;
		 f = -6409178400d;
		 p = 12000;
		 t = false;
		 n = FinanceLib.nper(r, y, p, f, t);
		 x = 12;
		 assertEquals(""nper "", x, n);
		 r = 2;
		 y = 120;
		 f = -6472951200d;
		 p = 12000;
		 t = true;
		 n = FinanceLib.nper(r, y, p, f, t);
		 x = 12;
		 assertEquals(""nper "", x, n);
	 }
}",0,0,0,0
"public class Resources extends DataType implements ResourceCollection {
	 public static final ResourceCollection NONE = new ResourceCollection() {
		 public boolean isFilesystemOnly() {
			 return true;
		 }
		 public Iterator iterator() {
			 return EMPTY_ITERATOR;
		 }
		 public int size() {
			 return 0;
		 }
	 }
	;
	 public static final Iterator EMPTY_ITERATOR = new Iterator() {
		 public Object next() {
			 throw new NoSuchElementException();
		 }
		 public boolean hasNext() {
			 return false;
		 }
		 public void remove() {
			 throw new UnsupportedOperationException();
		 }
	 }
	;
	 private class MyCollection extends AbstractCollection {
		 private Collection cached;
		 MyCollection() {
		 }
		 public int size() {
			 return getCache().size();
		 }
		 public Iterator iterator() {
			 return getCache().iterator();
		 }
		 private synchronized Collection getCache() {
			 Collection coll = cached;
			 if (coll == null) {
				 coll = CollectionUtils.asCollection(new MyIterator());
				 if (cache) {
					 cached = coll;
				 }
			 }
			 return coll;
		 }
		 private class MyIterator implements Iterator {
			 private Iterator rci = getNested().iterator();
			 private Iterator ri = null;
			 public boolean hasNext() {
				 boolean result = ri != null && ri.hasNext();
				 while (!result && rci.hasNext()) {
					 ri = ((ResourceCollection) rci.next()).iterator();
					 result = ri.hasNext();
				 }
				 return result;
			 }
			 public Object next() {
				 if (!hasNext()) {
					 throw new NoSuchElementException();
				 }
				 return ri.next();
			 }
			 public void remove() {
				 throw new UnsupportedOperationException();
			 }
		 }
	 }
	 private Vector rc;
	 private Collection coll;
	 private boolean cache = false;
	 public Resources() {
	 }
	 public Resources(Project project) {
		 setProject(project);
	 }
	 public synchronized void setCache(boolean b) {
		 cache = b;
	 }
	 public synchronized void add(ResourceCollection c) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (c == null) {
			 return;
		 }
		 if (rc == null) {
			 rc = new Vector();
		 }
		 rc.add(c);
		 invalidateExistingIterators();
		 coll = null;
		 setChecked(false);
	 }
	 public synchronized Iterator iterator() {
		 if (isReference()) {
			 return getRef().iterator();
		 }
		 validate();
		 return new FailFast(this, coll.iterator());
	 }
	 public synchronized int size() {
		 if (isReference()) {
			 return getRef().size();
		 }
		 validate();
		 return coll.size();
	 }
	 public boolean isFilesystemOnly() {
		 if (isReference()) {
			 return getRef().isFilesystemOnly();
		 }
		 validate();
		 for (Iterator i = getNested().iterator();
		 i.hasNext();
		) {
			 if ((!((ResourceCollection) i.next()).isFilesystemOnly())) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public synchronized String toString() {
		 if (isReference()) {
			 return getCheckedRef().toString();
		 }
		 validate();
		 if (coll == null || coll.isEmpty()) {
			 return """";
		 }
		 StringBuffer sb = new StringBuffer();
		 for (Iterator i = coll.iterator();
		 i.hasNext();
		) {
			 if (sb.length() > 0) {
				 sb.append(File.pathSeparatorChar);
			 }
			 sb.append(i.next());
		 }
		 return sb.toString();
	 }
	 protected void dieOnCircularReference(Stack stk, Project p) throws BuildException {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 for (Iterator i = getNested().iterator();
			 i.hasNext();
			) {
				 Object o = i.next();
				 if (o instanceof DataType) {
					 pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
				 }
			 }
			 setChecked(true);
		 }
	 }
	 protected void invalidateExistingIterators() {
		 FailFast.invalidate(this);
	 }
	 private ResourceCollection getRef() {
		 return (ResourceCollection) getCheckedRef( ResourceCollection.class, ""ResourceCollection"");
	 }
	 private synchronized void validate() {
		 dieOnCircularReference();
		 coll = (coll == null) ? new MyCollection() : coll;
	 }
	 private synchronized List getNested() {
		 return rc == null ? Collections.EMPTY_LIST : rc;
	 }
}",0,0,0,0
"private void initialize(Graphics2D initGrx,int initX,int initY,int initWidth,int initHeight,int initTopPadding,int initLeftPadding,int initBottomPadding,int initRightPadding,float initTextHeight,HorizontalAlignEnum initHorizontalAlignment,VerticalAlignEnum initVerticalAlignment,float initLineSpacingFactor,float initLeadingOffset,int initFontSize,boolean isStyledText);",0,0,0,1
"public abstract class JenaStatement implements Statement {
	 private static final Logger LOGGER = LoggerFactory.getLogger(JenaStatement.class);
	 protected static final int DEFAULT_HOLDABILITY = ResultSet.CLOSE_CURSORS_AT_COMMIT;
	 protected static final int DEFAULT_FETCH_DIRECTION = ResultSet.FETCH_FORWARD;
	 protected static final int DEFAULT_FETCH_SIZE = 0;
	 protected static final boolean DEFAULT_AUTO_COMMIT = JenaConnection.DEFAULT_AUTO_COMMIT;
	 protected static final int DEFAULT_TRANSACTION_LEVEL = JenaConnection.DEFAULT_ISOLATION_LEVEL;
	 protected static final int NO_LIMIT = 0;
	 protected static final int DEFAULT_TYPE = ResultSet.TYPE_FORWARD_ONLY;
	 protected static final int USE_CONNECTION_COMPATIBILITY = Integer.MIN_VALUE;
	 protected static final int UNKNOWN_UPDATE_COUNT = 0;
	 protected static final int NOT_AN_UPDATE = -1;
	 private List<String> commands = new ArrayList<>();
	 private SQLWarning warnings = null;
	 private JenaConnection connection;
	 private ResultSet currResults = null;
	 private Queue<ResultSet> results = new LinkedList<>();
	 private List<ResultSet> openResults = new ArrayList<>();
	 private boolean closed = false;
	 private int type = DEFAULT_TYPE;
	 private int fetchDirection = DEFAULT_FETCH_DIRECTION;
	 private int fetchSize = DEFAULT_FETCH_SIZE;
	 private int holdability = DEFAULT_HOLDABILITY;
	 private int updateCount = NOT_AN_UPDATE;
	 private boolean autoCommit = DEFAULT_AUTO_COMMIT;
	 private int transactionLevel = DEFAULT_TRANSACTION_LEVEL;
	 private int maxRows = NO_LIMIT;
	 private boolean escapeProcessing = false;
	 private int timeout = NO_LIMIT;
	 private int compatibilityLevel = USE_CONNECTION_COMPATIBILITY;
	 public JenaStatement(JenaConnection connection) throws SQLException {
		 this(connection, DEFAULT_TYPE, DEFAULT_FETCH_DIRECTION, DEFAULT_FETCH_SIZE, DEFAULT_HOLDABILITY, DEFAULT_AUTO_COMMIT, DEFAULT_TRANSACTION_LEVEL);
	 }
	 public JenaStatement(JenaConnection connection, int type, int fetchDir, int fetchSize, int holdability, boolean autoCommit, int transactionLevel) throws SQLException {
		 if (connection == null) throw new SQLException(""Cannot create a Statement with a null connection"");
		 this.connection = connection;
		 this.checkFetchDirection(fetchDir);
		 this.type = type;
		 this.fetchDirection = fetchDir;
		 this.fetchSize = fetchSize;
		 this.checkHoldability(holdability);
		 this.holdability = holdability;
		 this.autoCommit = autoCommit;
		 this.transactionLevel = transactionLevel;
	 }
	 public JenaConnection getJenaConnection() {
		 return this.connection;
	 }
	 public int getJdbcCompatibilityLevel() {
		 if (this.compatibilityLevel == USE_CONNECTION_COMPATIBILITY) return this.connection.getJdbcCompatibilityLevel();
		 return this.compatibilityLevel;
	 }
	 public void setJdbcCompatibilityLevel(int level) {
		 if (level == USE_CONNECTION_COMPATIBILITY) {
			 this.compatibilityLevel = USE_CONNECTION_COMPATIBILITY;
		 }
		 else {
			 this.compatibilityLevel = JdbcCompatibility.normalizeLevel(level);
		 }
	 }
	 public boolean isWrapperFor(Class<?> iface) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T unwrap(Class<T> iface) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void addBatch(String sql) {
		 this.commands.add(sql);
	 }
	 public void cancel() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void clearBatch() {
		 this.commands.clear();
	 }
	 public void clearWarnings() {
		 this.warnings = null;
	 }
	 public void close() throws SQLException {
		 if (this.closed) return;
		 LOGGER.info(""Closing statement"");
		 this.closed = true;
		 if (this.currResults != null) {
			 this.currResults.close();
			 this.currResults = null;
		 }
		 if (this.results.size() > 0 || this.openResults.size() > 0) {
			 LOGGER.info(""Closing "" + (this.results.size() + this.openResults.size()) + "" open result sets"");
			 while (!this.results.isEmpty()) {
				 try(ResultSet rset = this.results.poll()) {
				}
			 }
			 for (ResultSet rset : this.openResults) {
				 rset.close();
			 }
			 this.openResults.clear();
			 LOGGER.info(""All open result sets were closed"");
		 }
		 LOGGER.info(""Statement was closed"");
	 }
	 public final boolean execute(String sql) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 LOGGER.info(""Received input command text:\n {
		}
		"", sql);
		 sql = this.connection.applyPreProcessors(sql);
		 LOGGER.info(""Command text after pre-processing:\n {
		}
		"", sql);
		 Query q = null;
		 UpdateRequest u = null;
		 try {
			 q = QueryFactory.create(sql);
		 }
		 catch (Exception e) {
			 try {
				 u = UpdateFactory.create(sql);
			 }
			 catch (Exception e2) {
				 LOGGER.error(""Command text was not a valid SPARQL query/update"", e2);
				 throw new SQLException(""Not a valid SPARQL query/update"", e);
			 }
		 }
		 if (q != null) {
			 LOGGER.info(""Treating command text as a query"");
			 return this.executeQuery(q);
		 }
		 else if (u != null) {
			 LOGGER.info(""Treating command text as an update"");
			 this.executeUpdate(u);
			 return false;
		 }
		 else {
			 throw new SQLException(""Unable to create a SPARQL query/update"");
		 }
	 }
	 private boolean executeQuery(Query q) throws SQLException {
		 updateCount = NOT_AN_UPDATE;
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 boolean needsBegin = (!this.autoCommit && this.transactionLevel != Connection.TRANSACTION_NONE && !this .hasActiveTransaction());
		 boolean needsCommit = (this.autoCommit && this.transactionLevel != Connection.TRANSACTION_NONE);
		 try {
			 if (needsCommit) {
				 LOGGER.info(""Running query in auto-commit mode"");
				 this.beginTransaction(ReadWrite.READ);
			 }
			 else if (needsBegin) {
				 LOGGER.info(""Starting a new transaction to run query, transaction will not be auto-committed"");
				 this.beginTransaction(ReadWrite.WRITE);
			 }
		 }
		 catch (Exception e) {
			 LOGGER.error(""Starting the new transaction failed"", e);
			 throw new SQLException(""Failed to start a new query transaction"", e);
		 }
		 try {
			 q = this.connection.applyPreProcessors(q);
			 if (this.maxRows > NO_LIMIT) {
				 if (!q.hasLimit() || q.getLimit() > this.maxRows) {
					 LOGGER.info(""Enforced max rows on results by applying LIMIT {
					}
					 to the query"", this.maxRows);
					 q.setLimit(this.maxRows);
				 }
			 }
			 QueryExecution qe = this.createQueryExecution(q);
			 if (this.timeout > NO_LIMIT) {
				 qe.setTimeout(this.timeout, TimeUnit.SECONDS, this.timeout, TimeUnit.SECONDS);
			 }
			 if (q.isSelectType()) {
				 switch (this.type) {
					 case ResultSet.TYPE_SCROLL_INSENSITIVE: this.currResults = new MaterializedSelectResults(this, qe, ResultSetFactory.makeRewindable(this.connection .applyPostProcessors(qe.execSelect())), false);
					 break;
					 case ResultSet.TYPE_FORWARD_ONLY: default: this.currResults = new SelectResults(this, qe, this.connection.applyPostProcessors(qe.execSelect()), needsCommit);
					 break;
				 }
			 }
			 else if (q.isAskType()) {
				 boolean askRes = qe.execAsk();
				 qe.close();
				 this.currResults = new AskResults(this, this.connection.applyPostProcessors(askRes), needsCommit);
			 }
			 else if (q.isDescribeType()) {
				 switch (this.type) {
					 case ResultSet.TYPE_SCROLL_INSENSITIVE: this.currResults = new TripleListResults(this, qe, Iter.toList(this.connection.applyPostProcessors(qe .execDescribeTriples())), false);
					 break;
					 case ResultSet.TYPE_FORWARD_ONLY: default: this.currResults = new TripleIteratorResults(this, qe, this.connection.applyPostProcessors(qe .execDescribeTriples()), needsCommit);
					 break;
				 }
			 }
			 else if (q.isConstructType()) {
				 switch (this.type) {
					 case ResultSet.TYPE_SCROLL_INSENSITIVE: this.currResults = new TripleListResults(this, qe, Iter.toList(this.connection.applyPostProcessors(qe .execConstructTriples())), false);
					 break;
					 case ResultSet.TYPE_FORWARD_ONLY: default: this.currResults = new TripleIteratorResults(this, qe, this.connection.applyPostProcessors(qe .execConstructTriples()), needsCommit);
					 break;
				 }
			 }
			 else {
				 throw new SQLException(""Unknown SPARQL Query type"");
			 }
			 if (this.type == ResultSet.TYPE_SCROLL_INSENSITIVE && needsCommit) {
				 LOGGER.info(""Auto-committing query transaction since results have been materialized"");
				 this.commitTransaction();
			 }
			 return true;
		 }
		 catch (SQLException e) {
			 if (needsCommit) {
				 LOGGER.warn(""Rolling back failed query transaction"", e);
				 this.rollbackTransaction();
			 }
			 throw e;
		 }
		 catch (Throwable e) {
			 LOGGER.error(""SPARQL Query evaluation failed"", e);
			 if (needsCommit) {
				 LOGGER.warn(""Rolling back failed query transaction"");
				 this.rollbackTransaction();
			 }
			 throw new SQLException(""Error occurred during SPARQL query evaluation"", e);
		 }
	 }
	 protected abstract QueryExecution createQueryExecution(Query q) throws SQLException;
	 private int executeUpdate(UpdateRequest u) throws SQLException {
		 updateCount = UNKNOWN_UPDATE_COUNT;
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 if (this.connection.isReadOnly()) throw new SQLException(""The JDBC connection is currently in read-only mode, updates are not permitted"");
		 boolean needsBegin = (!this.autoCommit && this.transactionLevel != Connection.TRANSACTION_NONE && !this .hasActiveTransaction());
		 boolean needsCommit = (this.autoCommit && this.transactionLevel != Connection.TRANSACTION_NONE);
		 try {
			 if (needsCommit || needsBegin) {
				 if (this.autoCommit) {
					 LOGGER.info(""Running update in auto-commit mode"");
				 }
				 else {
					 LOGGER.info(""Starting a new transaction to run update, transaction will not be auto-committed"");
				 }
				 this.beginTransaction(ReadWrite.WRITE);
			 }
		 }
		 catch (Exception e) {
			 LOGGER.error(""Starting the new transaction failed"", e);
			 throw new SQLException(""Failed to start a new query transaction"", e);
		 }
		 try {
			 u = this.connection.applyPreProcessors(u);
			 UpdateProcessor processor = this.createUpdateProcessor(u);
			 processor.execute();
			 if (needsCommit) {
				 LOGGER.info(""Auto-committing update transaction"");
				 this.commitTransaction();
			 }
			 return 0;
		 }
		 catch (SQLException e) {
			 if (needsCommit) {
				 LOGGER.warn(""Rolling back failed update transaction"", e);
				 this.rollbackTransaction();
			 }
			 throw e;
		 }
		 catch (Exception e) {
			 LOGGER.error(""SPARQL Update evaluation failed"", e);
			 if (needsCommit) {
				 LOGGER.warn(""Rolling back failed update transaction"");
				 this.rollbackTransaction();
			 }
			 throw new SQLException(""Error occurred during SPARQL update evaluation"", e);
		 }
	 }
	 protected abstract UpdateProcessor createUpdateProcessor(UpdateRequest u) throws SQLException;
	 protected abstract boolean hasActiveTransaction() throws SQLException;
	 protected abstract void beginTransaction(ReadWrite type) throws SQLException;
	 protected abstract void commitTransaction() throws SQLException;
	 protected abstract void rollbackTransaction() throws SQLException;
	 public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		 return this.execute(sql);
	 }
	 public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		 return this.execute(sql);
	 }
	 public boolean execute(String sql, String[] columnNames) throws SQLException {
		 return this.execute(sql);
	 }
	 public final int[] executeBatch() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 if (this.commands.size() > 1 && this.autoCommit && this.holdability == ResultSet.CLOSE_CURSORS_AT_COMMIT) {
			 this.setWarning(""Executing this batch of commands may lead to unexpectedly closed result sets because auto-commit is enabled and commit behaviour is set to close cursors at commit"");
		 }
		 int[] rets = new int[this.commands.size()];
		 ResultSet curr = this.currResults;
		 for (int i = 0;
		 i < this.commands.size();
		 i++) {
			 if (this.execute(this.commands.get(i))) {
				 this.results.add(this.getResultSet());
				 this.currResults = null;
				 rets[i] = SUCCESS_NO_INFO;
			 }
			 else {
				 this.results.add(null);
				 rets[i] = this.getUpdateCount();
			 }
		 }
		 this.currResults = curr;
		 if (this.currResults == null && !this.results.isEmpty()) {
			 this.currResults = this.results.poll();
		 }
		 return rets;
	 }
	 public final ResultSet executeQuery(String sql) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 LOGGER.info(""Received input command text:\n {
		}
		"", sql);
		 sql = this.connection.applyPreProcessors(sql);
		 LOGGER.info(""Command text after pre-processing:\n {
		}
		"", sql);
		 Query q = null;
		 try {
			 q = QueryFactory.create(sql);
		 }
		 catch (Exception e) {
			 LOGGER.error(""Invalid SPARQL query"", e);
			 throw new SQLException(""Not a valid SPARQL query"", e);
		 }
		 if (q == null) throw new SQLException(""Unable to create a SPARQL Query"");
		 if (this.executeQuery(q)) {
			 return this.currResults;
		 }
		 else {
			 throw new SQLException(""Query did not produce a result set"");
		 }
	 }
	 public final int executeUpdate(String sql) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 if (this.connection.isReadOnly()) throw new SQLException(""The JDBC connection is currently in read-only mode, updates are not permitted"");
		 LOGGER.info(""Received input command text:\n {
		}
		"", sql);
		 sql = this.connection.applyPreProcessors(sql);
		 LOGGER.info(""Command text after pre-processing:\n {
		}
		"", sql);
		 UpdateRequest u = null;
		 try {
			 u = UpdateFactory.create(sql);
		 }
		 catch (Exception e) {
			 LOGGER.error(""Invalid SPARQL update"", e);
			 throw new SQLException(""Not a valid SPARQL Update"", e);
		 }
		 if (u == null) throw new SQLException(""Unable to create a SPARQL Update Request"");
		 return this.executeUpdate(u);
	 }
	 public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		 return this.executeUpdate(sql);
	 }
	 public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		 return this.executeUpdate(sql);
	 }
	 public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		 return this.executeUpdate(sql);
	 }
	 public final Connection getConnection() {
		 return this.connection;
	 }
	 public int getFetchDirection() {
		 return this.fetchDirection;
	 }
	 public int getFetchSize() {
		 return this.fetchSize;
	 }
	 public ResultSet getGeneratedKeys() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public int getMaxFieldSize() {
		 return NO_LIMIT;
	 }
	 public int getMaxRows() {
		 return maxRows;
	 }
	 public boolean getMoreResults() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 if (this.currResults != null) {
			 this.currResults.close();
			 this.currResults = null;
		 }
		 if (!this.results.isEmpty()) {
			 this.currResults = this.results.poll();
			 this.updateCount = this.currResults == null ? UNKNOWN_UPDATE_COUNT : NOT_AN_UPDATE;
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public boolean getMoreResults(int current) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 switch (current) {
			 case Statement.CLOSE_CURRENT_RESULT: return this.getMoreResults();
			 case Statement.CLOSE_ALL_RESULTS: for (ResultSet rset : this.openResults) {
				 rset.close();
			 }
			 this.openResults.clear();
			 return this.getMoreResults();
			 case Statement.KEEP_CURRENT_RESULT: if (this.currResults != null) {
				 this.openResults.add(this.currResults);
				 this.currResults = null;
			 }
			 return this.getMoreResults();
			 default: throw new SQLFeatureNotSupportedException( ""Unsupported mode for dealing with current results, only Statement.CLOSE_CURRENT_RESULT, Statement.CLOSE_ALL_RESULTS and Statement.KEEP_CURRENT_RESULT are supported"");
		 }
	 }
	 public int getQueryTimeout() {
		 return this.timeout;
	 }
	 public final ResultSet getResultSet() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""The Statement is closed"");
		 return this.currResults;
	 }
	 protected void setCurrentResults(ResultSet results) throws SQLException {
		 if (this.currResults != null) {
			 this.currResults.close();
		 }
		 this.currResults = results;
	 }
	 public final int getResultSetConcurrency() {
		 return ResultSet.CONCUR_READ_ONLY;
	 }
	 public int getResultSetHoldability() {
		 return this.holdability;
	 }
	 protected void checkHoldability(int h) throws SQLException {
		 switch (h) {
			 case ResultSet.CLOSE_CURSORS_AT_COMMIT: case ResultSet.HOLD_CURSORS_OVER_COMMIT: return;
			 default: throw new SQLException(String.format(""Holdability %d is supported for Jena JDBC statements"", h));
		 }
	 }
	 public final int getResultSetType() {
		 return this.type;
	 }
	 public int getUpdateCount() {
		 return this.updateCount;
	 }
	 protected void setUpdateCount(int count) {
		 this.updateCount = count;
	 }
	 public SQLWarning getWarnings() {
		 return this.warnings;
	 }
	 protected void setWarning(SQLWarning warning) {
		 LOGGER.warn(""SQL Warning was issued"", warning);
		 if (this.warnings == null) {
			 this.warnings = warning;
		 }
		 else {
			 warning.setNextWarning(this.warnings);
			 this.warnings = warning;
		 }
	 }
	 protected void setWarning(String warning) {
		 this.setWarning(new SQLWarning(warning));
	 }
	 protected void setWarning(String warning, Throwable cause) {
		 this.setWarning(new SQLWarning(warning, cause));
	 }
	 public final boolean isClosed() {
		 return this.closed;
	 }
	 public final boolean isPoolable() {
		 return true;
	 }
	 public void setCursorName(String name) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void setEscapeProcessing(boolean enable) {
		 this.escapeProcessing = enable;
	 }
	 public void setFetchDirection(int direction) throws SQLException {
		 this.checkFetchDirection(direction);
		 this.fetchDirection = direction;
	 }
	 protected void checkFetchDirection(int dir) throws SQLException {
		 switch (dir) {
			 case ResultSet.FETCH_FORWARD: return;
			 default: throw new SQLFeatureNotSupportedException(""Only ResultSet.FETCH_FORWARD is supported as a fetch direction"");
		 }
	 }
	 public void setFetchSize(int rows) {
		 this.fetchSize = rows;
	 }
	 public void setMaxFieldSize(int max) {
		 this.setWarning(""setMaxFieldSize() was called but there is no field size limit for Jena JDBC connections"");
	 }
	 public void setMaxRows(int max) {
		 if (max <= NO_LIMIT) {
			 this.maxRows = NO_LIMIT;
		 }
		 else {
			 this.maxRows = max;
		 }
	 }
	 public void setPoolable(boolean poolable) {
		 this.setWarning(""setPoolable() was called but Jena JDBC statements are always considered poolable"");
	 }
	 public void setQueryTimeout(int seconds) {
		 if (seconds <= NO_LIMIT) {
			 this.timeout = NO_LIMIT;
		 }
		 else {
			 this.timeout = seconds;
		 }
	 }
	 public boolean isCloseOnCompletion() {
		 return false;
	 }
	 public void closeOnCompletion() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
}",1,0,0,0
"class PushCommand extends KeyCommand {
	private List<ByteBuffer> values;
	private boolean upsert;
	private Direction direction;
	private PushCommand( ByteBuffer key, List<ByteBuffer> values, Direction direction, boolean upsert) {
		super(key);
		this.values = values;
		this.upsert = upsert;
		this.direction = direction;
	}
	public static PushCommand right() {
		return new PushCommand(null, Collections.emptyList(), Direction.RIGHT, true);
	}
	public static PushCommand left() {
		return new PushCommand(null, Collections.emptyList(), Direction.LEFT, true);
	}
	public PushCommand value(ByteBuffer value) {
		Assert.notNull(value, ""Value must not be null!"");
		return new PushCommand(null, Collections.singletonList(value), direction, upsert);
	}
	public PushCommand values(List<ByteBuffer> values) {
		Assert.notNull(values, ""Values must not be null!"");
		return new PushCommand(null, new ArrayList<>(values), direction, upsert);
	}
	public PushCommand to(ByteBuffer key) {
		Assert.notNull(key, ""Key must not be null!"");
		return new PushCommand(key, values, direction, upsert);
	}
	public PushCommand ifExists() {
		return new PushCommand(getKey(), values, direction, false);
	}
	public List<ByteBuffer> getValues() {
		return values;
	}
	public boolean getUpsert() {
		return upsert;
	}
	public Direction getDirection() {
		return direction;
	}
}",0,1,0,0
"public class Available extends Task implements Condition {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String property;
	 private String classname;
	 private String filename;
	 private File file;
	 private Path filepath;
	 private String resource;
	 private FileDir type;
	 private Path classpath;
	 private AntClassLoader loader;
	 private String value = ""true"";
	 private boolean isTask = false;
	 private boolean ignoreSystemclasses = false;
	 private boolean searchParents = false;
	 public void setSearchParents(boolean searchParents) {
		 this.searchParents = searchParents;
	 }
	 public void setClasspath(Path classpath) {
		 createClasspath().append(classpath);
	 }
	 public Path createClasspath() {
		 if (this.classpath == null) {
			 this.classpath = new Path(getProject());
		 }
		 return this.classpath.createPath();
	 }
	 public void setClasspathRef(Reference r) {
		 createClasspath().setRefid(r);
	 }
	 public void setFilepath(Path filepath) {
		 createFilepath().append(filepath);
	 }
	 public Path createFilepath() {
		 if (this.filepath == null) {
			 this.filepath = new Path(getProject());
		 }
		 return this.filepath.createPath();
	 }
	 public void setProperty(String property) {
		 this.property = property;
	 }
	 public void setValue(String value) {
		 this.value = value;
	 }
	 public void setClassname(String classname) {
		 if (!"""".equals(classname)) {
			 this.classname = classname;
		 }
	 }
	 public void setFile(File file) {
		 this.file = file;
		 this.filename = FILE_UTILS.removeLeadingPath(getProject().getBaseDir(), file);
	 }
	 public void setResource(String resource) {
		 this.resource = resource;
	 }
	 public void setType(String type) {
		 log(""DEPRECATED - The setType(String) method has been deprecated."" + "" Use setType(Available.FileDir) instead."", Project.MSG_WARN);
		 this.type = new FileDir();
		 this.type.setValue(type);
	 }
	 public void setType(FileDir type) {
		 this.type = type;
	 }
	 public void setIgnoresystemclasses(boolean ignore) {
		 this.ignoreSystemclasses = ignore;
	 }
	 public void execute() throws BuildException {
		 if (property == null) {
			 throw new BuildException(""property attribute is required"", getLocation());
		 }
		 isTask = true;
		 try {
			 if (eval()) {
				 String oldvalue = getProject().getProperty(property);
				 if (null != oldvalue && !oldvalue.equals(value)) {
					 log(""DEPRECATED - <available> used to override an existing"" + "" property."" + StringUtils.LINE_SEP + "" Build file should not reuse the same property"" + "" name for different values."", Project.MSG_WARN);
				 }
				 getProject().setProperty(property, value);
			 }
		 }
		 finally {
			 isTask = false;
		 }
	 }
	 public boolean eval() throws BuildException {
		 try {
			 if (classname == null && file == null && resource == null) {
				 throw new BuildException(""At least one of (classname|file|"" + ""resource) is required"", getLocation());
			 }
			 if (type != null) {
				 if (file == null) {
					 throw new BuildException(""The type attribute is only valid "" + ""when specifying the file "" + ""attribute."", getLocation());
				 }
			 }
			 if (classpath != null) {
				 classpath.setProject(getProject());
				 this.loader = getProject().createClassLoader(classpath);
			 }
			 String appendix = """";
			 if (isTask) {
				 appendix = "" to set property "" + property;
			 }
			 else {
				 setTaskName(""available"");
			 }
			 if ((classname != null) && !checkClass(classname)) {
				 log(""Unable to load class "" + classname + appendix, Project.MSG_VERBOSE);
				 return false;
			 }
			 if ((file != null) && !checkFile()) {
				 StringBuffer buf = new StringBuffer(""Unable to find "");
				 if (type != null) {
					 buf.append(type).append(' ');
				 }
				 buf.append(filename).append(appendix);
				 log(buf.toString(), Project.MSG_VERBOSE);
				 return false;
			 }
			 if ((resource != null) && !checkResource(resource)) {
				 log(""Unable to load resource "" + resource + appendix, Project.MSG_VERBOSE);
				 return false;
			 }
		 }
		 finally {
			 if (loader != null) {
				 loader.cleanup();
				 loader = null;
			 }
			 if (!isTask) {
				 setTaskName(null);
			 }
		 }
		 return true;
	 }
	 private boolean checkFile() {
		 if (filepath == null) {
			 return checkFile(file, filename);
		 }
		 else {
			 String[] paths = filepath.list();
			 for (int i = 0;
			 i < paths.length;
			 ++i) {
				 log(""Searching "" + paths[i], Project.MSG_VERBOSE);
				 File path = new File(paths[i]);
				 if (path.exists() && (filename.equals(paths[i]) || filename.equals(path.getName()))) {
					 if (type == null) {
						 log(""Found: "" + path, Project.MSG_VERBOSE);
						 return true;
					 }
					 else if (type.isDir() && path.isDirectory()) {
						 log(""Found directory: "" + path, Project.MSG_VERBOSE);
						 return true;
					 }
					 else if (type.isFile() && path.isFile()) {
						 log(""Found file: "" + path, Project.MSG_VERBOSE);
						 return true;
					 }
					 return false;
				 }
				 File parent = path.getParentFile();
				 if (parent != null && parent.exists() && filename.equals(parent.getAbsolutePath())) {
					 if (type == null) {
						 log(""Found: "" + parent, Project.MSG_VERBOSE);
						 return true;
					 }
					 else if (type.isDir()) {
						 log(""Found directory: "" + parent, Project.MSG_VERBOSE);
						 return true;
					 }
					 return false;
				 }
				 if (path.exists() && path.isDirectory()) {
					 if (checkFile(new File(path, filename), filename + "" in "" + path)) {
						 return true;
					 }
				 }
				 while (searchParents && parent != null && parent.exists()) {
					 if (checkFile(new File(parent, filename), filename + "" in "" + parent)) {
						 return true;
					 }
					 parent = parent.getParentFile();
				 }
			 }
		 }
		 return false;
	 }
	 private boolean checkFile(File f, String text) {
		 if (type != null) {
			 if (type.isDir()) {
				 if (f.isDirectory()) {
					 log(""Found directory: "" + text, Project.MSG_VERBOSE);
				 }
				 return f.isDirectory();
			 }
			 else if (type.isFile()) {
				 if (f.isFile()) {
					 log(""Found file: "" + text, Project.MSG_VERBOSE);
				 }
				 return f.isFile();
			 }
		 }
		 if (f.exists()) {
			 log(""Found: "" + text, Project.MSG_VERBOSE);
		 }
		 return f.exists();
	 }
	 private boolean checkResource(String resource) {
		 if (loader != null) {
			 return (loader.getResourceAsStream(resource) != null);
		 }
		 else {
			 ClassLoader cL = this.getClass().getClassLoader();
			 if (cL != null) {
				 return (cL.getResourceAsStream(resource) != null);
			 }
			 else {
				 return (ClassLoader.getSystemResourceAsStream(resource) != null);
			 }
		 }
	 }
	 private boolean checkClass(String classname) {
		 try {
			 if (ignoreSystemclasses) {
				 loader = getProject().createClassLoader(classpath);
				 loader.setParentFirst(false);
				 loader.addJavaLibraries();
				 if (loader != null) {
					 try {
						 loader.findClass(classname);
					 }
					 catch (SecurityException se) {
						 return true;
					 }
				 }
				 else {
					 return false;
				 }
			 }
			 else if (loader != null) {
				 loader.loadClass(classname);
			 }
			 else {
				 ClassLoader l = this.getClass().getClassLoader();
				 if (l != null) {
					 Class.forName(classname, true, l);
				 }
				 else {
					 Class.forName(classname);
				 }
			 }
			 return true;
		 }
		 catch (ClassNotFoundException e) {
			 log(""class \"""" + classname + ""\"" was not found"", Project.MSG_DEBUG);
			 return false;
		 }
		 catch (NoClassDefFoundError e) {
			 log(""Could not load dependent class \"""" + e.getMessage() + ""\"" for class \"""" + classname + ""\"""", Project.MSG_DEBUG);
			 return false;
		 }
	 }
	 public static class FileDir extends EnumeratedAttribute {
		 private static final String[] VALUES = {
		""file"", ""dir""}
		;
		 public String[] getValues() {
			 return VALUES;
		 }
		 public boolean isDir() {
			 return ""dir"".equalsIgnoreCase(getValue());
		 }
		 public boolean isFile() {
			 return ""file"".equalsIgnoreCase(getValue());
		 }
	 }
}",0,0,0,0
void updateMinBalance();,0,0,0,0
"public class Uses {
	private final int typeNameIndex;
	public Uses(int typeNameIndex) {
		this.typeNameIndex = typeNameIndex;
	}
	public String getTypeName() {
		return cpool.getConstantString_CONSTANTClass(typeNameIndex);
	}
	public int getTypeNameIndex() {
		return typeNameIndex;
	}
	public String toString() {
		StringBuilder s =new StringBuilder();
		s.append(""uses "").append(getTypeName().replace('/', '.'));
		return s.toString().trim();
	}
}",0,1,0,0
"public class JAXBContextResolver implements ContextResolver<JAXBContext> {
	 private JAXBContext context;
	 private final Set<Class> types;
	 private final Class[] cTypes = {
	 AppInfo.class, AppAttemptInfo.class, AppAttemptsInfo.class, ClusterInfo.class, CapacitySchedulerQueueInfo.class, FifoSchedulerInfo.class, SchedulerTypeInfo.class, NodeInfo.class, UserMetricsInfo.class, CapacitySchedulerInfo.class, ClusterMetricsInfo.class, SchedulerInfo.class, AppsInfo.class, NodesInfo.class, RemoteExceptionData.class, CapacitySchedulerQueueInfoList.class, ResourceInfo.class, UsersInfo.class, UserInfo.class, ApplicationStatisticsInfo.class, StatisticsItemInfo.class}
	;
	 public JAXBContextResolver() throws Exception {
		 this.types = new HashSet<Class>(Arrays.asList(cTypes));
		 this.context = new JSONJAXBContext(JSONConfiguration.natural() .rootUnwrapping(false).build(), cTypes);
	 }
	 public JAXBContext getContext(Class<?> objectType) {
		 return (types.contains(objectType)) ? context : null;
	 }
}",0,0,0,0
"private static class getJobSummary_resultStandardScheme extends StandardScheme<getJobSummary_result> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, getJobSummary_result struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 0: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.success = new Response();
					 struct.success.read(iprot);
					 struct.setSuccessIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, getJobSummary_result struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.success != null) {
			 oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
			 struct.success.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
"public final void entryRuleXBasicForLoopExpression() throws RecognitionException {
	 try {
		 {
			 if ( state.backtracking==0 ) {
				 before(grammarAccess.getXBasicForLoopExpressionRule());
			 }
			 pushFollow(FOLLOW_1);
			 ruleXBasicForLoopExpression();
			 state._fsp--;
			 if (state.failed) return ;
			 if ( state.backtracking==0 ) {
				 after(grammarAccess.getXBasicForLoopExpressionRule());
			 }
			 match(input,EOF,FOLLOW_2);
			 if (state.failed) return ;
		 }
	 }
	 catch (RecognitionException re) {
		 reportError(re);
		 recover(input,re);
	 }
	 finally {
	 }
	 return ;
 }",0,0,1,0
"public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
	 if (delegate != null) {
		 delegateStack.push(qName);
		 delegate.startElement(uri, localName, qName, attributes);
	 }
	 else if (domImplementation != null) {
		 TransformerHandler handler;
		 try {
			 handler = tFactory.newTransformerHandler();
		 }
		 catch (TransformerConfigurationException e) {
			 throw new SAXException(""Error creating a new TransformerHandler"", e);
		 }
		 Document doc = domImplementation.createDocument(uri, qName, null);
		 doc.removeChild(doc.getDocumentElement());
		 handler.setResult(new DOMResult(doc));
		 Area parent = (Area)areaStack.peek();
		 ((ForeignObject)parent).setDocument(doc);
		 domImplementation = null;
		 this.delegate = handler;
		 delegateStack.push(qName);
		 delegate.startDocument();
		 delegate.startElement(uri, localName, qName, attributes);
	 }
	 else {
		 boolean handled = true;
		 if ("""".equals(uri)) {
			 if (localName.equals(""structureTree"")) {
				 delegate = new DefaultHandler();
				 delegateStack.push(qName);
				 delegate.startDocument();
				 delegate.startElement(uri, localName, qName, attributes);
			 }
			 else {
				 handled = startAreaTreeElement(localName, attributes);
			 }
		 }
		 else {
			 ContentHandlerFactoryRegistry registry = userAgent.getContentHandlerFactoryRegistry();
			 ContentHandlerFactory factory = registry.getFactory(uri);
			 if (factory != null) {
				 delegate = factory.createContentHandler();
				 delegateStack.push(qName);
				 delegate.startDocument();
				 delegate.startElement(uri, localName, qName, attributes);
			 }
			 else {
				 handled = false;
			 }
		 }
		 if (!handled) {
			 if (uri == null || uri.length() == 0) {
				 throw new SAXException(""Unhandled element "" + localName + "" in namespace: "" + uri);
			 }
			 else {
				 log.warn(""Unhandled element "" + localName + "" in namespace: "" + uri);
			 }
		 }
	 }
 }",0,0,1,0
"public class SessionImpl extends AbstractSession implements NamespaceResolver, ManagerProvider {
	 private static Logger log = LoggerFactory.getLogger(SessionImpl.class);
	 private static final SAXParserFactory SAX_PARSER_FACTORY;
	 static {
		 SAX_PARSER_FACTORY = SAXParserFactory.newInstance();
		 SAX_PARSER_FACTORY.setNamespaceAware(true);
	 }
	 private boolean alive;
	 private final Map<SessionListener, SessionListener> listeners = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);
	 private final Repository repository;
	 private final RepositoryConfig config;
	 private final WorkspaceImpl workspace;
	 private final SessionInfo sessionInfo;
	 private NamePathResolver npResolver;
	 private final NodeTypeManagerImpl ntManager;
	 private final ValueFactory valueFactory;
	 private final SessionItemStateManager itemStateManager;
	 private final ItemManager itemManager;
	 private final ItemStateValidator validator;
	 SessionImpl(SessionInfo sessionInfo, Repository repository, RepositoryConfig config) throws RepositoryException {
		 alive = true;
		 this.repository = repository;
		 this.config = config;
		 this.sessionInfo = sessionInfo;
		 workspace = createWorkspaceInstance(config, sessionInfo);
		 IdentifierResolver idResolver = new IdResolver();
		 npResolver = new DefaultNamePathResolver(this, idResolver, true);
		 valueFactory = new ValueFactoryQImpl(config.getRepositoryService().getQValueFactory(), npResolver);
		 ntManager = new NodeTypeManagerImpl(workspace.getNodeTypeRegistry(), this);
		 validator = new ItemStateValidator(this, getPathFactory());
		 itemStateManager = createSessionItemStateManager(workspace.getUpdatableItemStateManager(), workspace.getItemStateFactory());
		 HierarchyManager hMgr = getHierarchyManager();
		 itemManager = createItemManager(hMgr);
		 if (hMgr instanceof HierarchyManagerImpl) {
			 ((HierarchyManagerImpl) hMgr).setResolver(npResolver);
		 }
	 }
	 public Repository getRepository() {
		 return repository;
	 }
	 public String getUserID() {
		 return sessionInfo.getUserID();
	 }
	 public Object getAttribute(String name) {
		 return null;
	 }
	 public String[] getAttributeNames() {
		 return new String[0];
	 }
	 public Workspace getWorkspace() {
		 return workspace;
	 }
	 public Session impersonate(Credentials credentials) throws LoginException, RepositoryException {
		 checkIsAlive();
		 SessionInfo info = config.getRepositoryService().impersonate(sessionInfo, credentials);
		 try {
			 if (info instanceof XASessionInfo) {
				 return new XASessionImpl((XASessionInfo) info, repository, config);
			 }
			 else {
				 return new SessionImpl(info, repository, config);
			 }
		 }
		 catch (RepositoryException ex) {
			 config.getRepositoryService().dispose(info);
			 throw ex;
		 }
	 }
	 public Node getRootNode() throws RepositoryException {
		 checkIsAlive();
		 NodeEntry re = getHierarchyManager().getRootEntry();
		 return (Node) itemManager.getItem(re);
	 }
	 public Node getNodeByUUID(String uuid) throws ItemNotFoundException, RepositoryException {
		 Node node = getNodeById(getIdFactory().createNodeId(uuid));
		 if (node instanceof NodeImpl && ((NodeImpl)node).isNodeType(NameConstants.MIX_REFERENCEABLE)) {
			 return node;
		 }
		 else {
			 String mixReferenceable = getNameResolver().getJCRName(NameConstants.MIX_REFERENCEABLE);
			 if (node.isNodeType(mixReferenceable)) {
				 return node;
			 }
			 throw new ItemNotFoundException(uuid);
		 }
	 }
	 private Node getNodeById(NodeId id) throws ItemNotFoundException, RepositoryException {
		 checkIsAlive();
		 try {
			 NodeEntry nodeEntry = getHierarchyManager().getNodeEntry(id);
			 Item item = getItemManager().getItem(nodeEntry);
			 if (item.isNode()) {
				 return (Node) item;
			 }
			 else {
				 log.error(""NodeId '"" + id + "" does not point to a Node"");
				 throw new ItemNotFoundException(LogUtil.saveGetIdString(id, getPathResolver()));
			 }
		 }
		 catch (AccessDeniedException e) {
			 throw new ItemNotFoundException(LogUtil.saveGetIdString(id, getPathResolver()));
		 }
	 }
	 public Item getItem(String absPath) throws PathNotFoundException, RepositoryException {
		 checkIsAlive();
		 try {
			 Path qPath = getQPath(absPath).getNormalizedPath();
			 ItemManager itemMgr = getItemManager();
			 if (itemMgr.nodeExists(qPath)) {
				 return itemMgr.getNode(qPath);
			 }
			 else {
				 return itemMgr.getProperty(qPath);
			 }
		 }
		 catch (AccessDeniedException ade) {
			 throw new PathNotFoundException(absPath);
		 }
	 }
	 public boolean itemExists(String absPath) throws RepositoryException {
		 checkIsAlive();
		 Path qPath = getQPath(absPath).getNormalizedPath();
		 ItemManager itemMgr = getItemManager();
		 return itemMgr.nodeExists(qPath) || itemMgr.propertyExists(qPath);
	 }
	 public void move(String srcAbsPath, String destAbsPath) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {
		 checkSupportedOption(Repository.LEVEL_2_SUPPORTED);
		 checkIsAlive();
		 Path srcPath = getQPath(srcAbsPath);
		 Path destPath = getQPath(destAbsPath);
		 Operation op = Move.create(srcPath, destPath, getHierarchyManager(), getPathResolver(), true);
		 itemStateManager.execute(op);
	 }
	 public void save() throws AccessDeniedException, ConstraintViolationException, InvalidItemStateException, VersionException, LockException, RepositoryException {
		 checkSupportedOption(Repository.LEVEL_2_SUPPORTED);
		 getRootNode().save();
	 }
	 public void refresh(boolean keepChanges) throws RepositoryException {
		 getRootNode().refresh(keepChanges);
	 }
	 public boolean hasPendingChanges() throws RepositoryException {
		 checkIsAlive();
		 return itemStateManager.hasPendingChanges();
	 }
	 public ValueFactory getValueFactory() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkSupportedOption(Repository.LEVEL_2_SUPPORTED);
		 return getJcrValueFactory();
	 }
	 public void checkPermission(String absPath, String actions) throws AccessControlException, RepositoryException {
		 if (!hasPermission(absPath, actions)) {
			 throw new AccessControlException(""Access control violation: path = "" + absPath + "", actions = "" + actions);
		 }
	 }
	 public ContentHandler getImportContentHandler(String parentAbsPath, int uuidBehavior) throws PathNotFoundException, ConstraintViolationException, VersionException, LockException, RepositoryException {
		 checkSupportedOption(Repository.LEVEL_2_SUPPORTED);
		 checkIsAlive();
		 Path parentPath = getQPath(parentAbsPath);
		 Importer importer = new SessionImporter(parentPath, this, itemStateManager, uuidBehavior);
		 return new ImportHandler(importer, getNamespaceResolver(), workspace.getNamespaceRegistry(), getNameFactory(), getPathFactory());
	 }
	 public void importXML(String parentAbsPath, InputStream in, int uuidBehavior) throws IOException, PathNotFoundException, ItemExistsException, ConstraintViolationException, VersionException, InvalidSerializedDataException, LockException, RepositoryException {
		 ImportHandler handler = (ImportHandler) getImportContentHandler(parentAbsPath, uuidBehavior);
		 try {
			 SAX_PARSER_FACTORY.setFeature( ""http: SAXParser parser = SAX_PARSER_FACTORY.newSAXParser();
			 parser.parse(new InputSource(in), handler);
		 }
		 catch (SAXException se) {
			 Exception e = se.getException();
			 if (e != null && e instanceof RepositoryException) {
				 throw (RepositoryException) e;
			 }
			 else {
				 String msg = ""failed to parse XML stream"";
				 log.debug(msg);
				 throw new InvalidSerializedDataException(msg, se);
			 }
		 }
		 catch (ParserConfigurationException e) {
			 throw new RepositoryException(""SAX parser configuration error"", e);
		 }
		 finally {
			 in.close();
		 }
	 }
	 public void setNamespacePrefix(String prefix, String uri) throws RepositoryException {
		 super.setNamespacePrefix(prefix, uri);
		 npResolver = new DefaultNamePathResolver(this, true);
	 }
	 public void logout() {
		 if (!alive) {
			 return;
		 }
		 notifyLoggingOut();
		 itemStateManager.dispose();
		 itemManager.dispose();
		 workspace.dispose();
		 alive = false;
		 notifyLoggedOut();
	 }
	 public boolean isLive() {
		 return alive;
	 }
	 public void addLockToken(String lt) {
		 try {
			 getLockStateManager().addLockToken(lt);
		 }
		 catch (RepositoryException e) {
			 log.warn(""Unable to add lock token '"" +lt+ ""' to this session."", e);
		 }
	 }
	 public String[] getLockTokens() {
		 try {
			 return getLockStateManager().getLockTokens();
		 }
		 catch (RepositoryException e) {
			 log.warn(""Unable to retrieve lock tokens for this session. ("" + e.getMessage() + "")"");
			 return new String[0];
		 }
	 }
	 public void removeLockToken(String lt) {
		 try {
			 getLockStateManager().removeLockToken(lt);
		 }
		 catch (RepositoryException e) {
			 log.warn(""Unable to remove lock token '"" +lt+ ""' from this session. ("" + e.getMessage() + "")"");
		 }
	 }
	 public AccessControlManager getAccessControlManager() throws RepositoryException {
		 checkSupportedOption(Repository.OPTION_ACCESS_CONTROL_SUPPORTED);
		 return getAccessControlProvider().createAccessControlManager(sessionInfo, itemStateManager, itemManager, getItemDefinitionProvider(), getHierarchyManager(), npResolver);
	 }
	 public Node getNode(String absPath) throws RepositoryException {
		 checkIsAlive();
		 try {
			 Path qPath = getQPath(absPath).getNormalizedPath();
			 ItemManager itemMgr = getItemManager();
			 return itemMgr.getNode(qPath);
		 }
		 catch (AccessDeniedException ade) {
			 throw new PathNotFoundException(absPath);
		 }
	 }
	 public Node getNodeByIdentifier(String id) throws RepositoryException {
		 return getNodeById(getIdFactory().fromJcrIdentifier(id));
	 }
	 public Property getProperty(String absPath) throws RepositoryException {
		 checkIsAlive();
		 try {
			 Path qPath = getQPath(absPath).getNormalizedPath();
			 ItemManager itemMgr = getItemManager();
			 return itemMgr.getProperty(qPath);
		 }
		 catch (AccessDeniedException ade) {
			 throw new PathNotFoundException(absPath);
		 }
	 }
	 public RetentionManager getRetentionManager() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkSupportedOption(Repository.OPTION_RETENTION_SUPPORTED);
		 throw new UnsupportedRepositoryOperationException(""JCR-1104"");
	 }
	 public boolean hasCapability(String methodName, Object target, Object[] arguments) throws RepositoryException {
		 return true;
	 }
	 public boolean hasPermission(String absPath, String actions) throws RepositoryException {
		 checkIsAlive();
		 String[] actionsArr = actions.split("","");
		 Path targetPath = getQPath(absPath);
		 boolean isGranted;
		 if (itemManager.nodeExists(targetPath)) {
			 NodeState nState = getHierarchyManager().getNodeState(targetPath);
			 isGranted = getAccessManager().isGranted(nState, actionsArr);
		 }
		 else if (itemManager.propertyExists(targetPath)) {
			 PropertyState pState = getHierarchyManager().getPropertyState(targetPath);
			 isGranted = getAccessManager().isGranted(pState, actionsArr);
		 }
		 else {
			 NodeState parentState = null;
			 Path parentPath = targetPath;
			 while (parentState == null) {
				 parentPath = parentPath.getAncestor(1);
				 if (itemManager.nodeExists(parentPath)) {
					 parentState = getHierarchyManager().getNodeState(parentPath);
				 }
			 }
			 Path relPath = parentPath.computeRelativePath(targetPath);
			 isGranted = getAccessManager().isGranted(parentState, relPath, actionsArr);
		 }
		 return isGranted;
	 }
	 public boolean nodeExists(String absPath) throws RepositoryException {
		 checkIsAlive();
		 Path qPath = getQPath(absPath).getNormalizedPath();
		 ItemManager itemMgr = getItemManager();
		 return itemMgr.nodeExists(qPath);
	 }
	 public boolean propertyExists(String absPath) throws RepositoryException {
		 checkIsAlive();
		 Path qPath = getQPath(absPath).getNormalizedPath();
		 ItemManager itemMgr = getItemManager();
		 return itemMgr.propertyExists(qPath);
	 }
	 public void removeItem(String absPath) throws RepositoryException {
		 Item item = getItem(absPath);
		 item.remove();
	 }
	 public String getPrefix(String uri) throws NamespaceException {
		 try {
			 return getNamespacePrefix(uri);
		 }
		 catch (NamespaceException e) {
			 throw e;
		 }
		 catch (RepositoryException e) {
			 throw new NamespaceException(""Namespace not found: "" + uri, e);
		 }
	 }
	 public String getURI(String prefix) throws NamespaceException {
		 try {
			 return getNamespaceURI(prefix);
		 }
		 catch (NamespaceException e) {
			 throw e;
		 }
		 catch (RepositoryException e) {
			 throw new NamespaceException(""Namespace not found: "" + prefix, e);
		 }
	 }
	 public void addListener(SessionListener listener) {
		 if (!listeners.containsKey(listener)) {
			 listeners.put(listener, listener);
		 }
	 }
	 public void removeListener(SessionListener listener) {
		 listeners.remove(listener);
	 }
	 private void notifyLoggingOut() {
		 SessionListener[] la = listeners.values().toArray(new SessionListener[listeners.size()]);
		 for (SessionListener sl : la) {
			 if (sl != null) {
				 sl.loggingOut(this);
			 }
		 }
	 }
	 private void notifyLoggedOut() {
		 SessionListener[] la = listeners.values().toArray(new SessionListener[listeners.size()]);
		 for (SessionListener sl : la) {
			 if (sl != null) {
				 sl.loggedOut(this);
			 }
		 }
	 }
	 protected WorkspaceImpl createWorkspaceInstance(RepositoryConfig config, SessionInfo sessionInfo) throws RepositoryException {
		 return new WorkspaceImpl(sessionInfo.getWorkspaceName(), this, config, sessionInfo);
	 }
	 protected SessionItemStateManager createSessionItemStateManager(UpdatableItemStateManager workspaceStateManager, ItemStateFactory isf) throws RepositoryException {
		 return new SessionItemStateManager(workspaceStateManager, getValidator(), getQValueFactory(), isf, this);
	 }
	 protected ItemManager createItemManager(HierarchyManager hierarchyManager) {
		 ItemCache cache = new ItemCacheImpl(config.getItemCacheSize());
		 ItemManagerImpl imgr = new ItemManagerImpl(hierarchyManager, this, cache);
		 return imgr;
	 }
	 public NamePathResolver getNamePathResolver() {
		 return npResolver;
	 }
	 public NameResolver getNameResolver() {
		 return npResolver;
	 }
	 public PathResolver getPathResolver() {
		 return npResolver;
	 }
	 public NamespaceResolver getNamespaceResolver() {
		 return this;
	 }
	 public HierarchyManager getHierarchyManager() {
		 return workspace.getHierarchyManager();
	 }
	 public LockStateManager getLockStateManager() {
		 return workspace.getLockStateManager();
	 }
	 public AccessManager getAccessManager() {
		 return workspace.getAccessManager();
	 }
	 public VersionManager getVersionStateManager() {
		 return workspace.getVersionStateManager();
	 }
	 public ItemDefinitionProvider getItemDefinitionProvider() {
		 return workspace.getItemDefinitionProvider();
	 }
	 public NodeTypeDefinitionProvider getNodeTypeDefinitionProvider() {
		 return ntManager;
	 }
	 public EffectiveNodeTypeProvider getEffectiveNodeTypeProvider() {
		 return workspace.getEffectiveNodeTypeProvider();
	 }
	 public QValueFactory getQValueFactory() throws RepositoryException {
		 return config.getRepositoryService().getQValueFactory();
	 }
	 public AccessControlProvider getAccessControlProvider() throws RepositoryException {
		 return workspace.getAccessControlProvider();
	 }
	 public ValueFactory getJcrValueFactory() throws RepositoryException {
		 return valueFactory;
	 }
	 ItemManager getItemManager() {
		 return itemManager;
	 }
	 public ItemStateValidator getValidator() {
		 return validator;
	 }
	 public IdFactory getIdFactory() throws RepositoryException {
		 return workspace.getIdFactory();
	 }
	 public NameFactory getNameFactory() throws RepositoryException {
		 return workspace.getNameFactory();
	 }
	 PathFactory getPathFactory() throws RepositoryException {
		 return workspace.getPathFactory();
	 }
	 SessionItemStateManager getSessionItemStateManager() {
		 return itemStateManager;
	 }
	 NodeTypeManagerImpl getNodeTypeManager() {
		 return ntManager;
	 }
	 CacheBehaviour getCacheBehaviour() {
		 return config.getCacheBehaviour();
	 }
	 SessionImpl switchWorkspace(String workspaceName) throws AccessDeniedException, NoSuchWorkspaceException, RepositoryException {
		 checkAccessibleWorkspace(workspaceName);
		 SessionInfo info = config.getRepositoryService().obtain(sessionInfo, workspaceName);
		 if (info instanceof XASessionInfo) {
			 return new XASessionImpl((XASessionInfo) info, repository, config);
		 }
		 else {
			 return new SessionImpl(info, repository, config);
		 }
	 }
	 Path getQPath(String absPath) throws RepositoryException {
		 try {
			 Path p = getPathResolver().getQPath(absPath);
			 if (!p.isAbsolute()) {
				 throw new RepositoryException(""Not an absolute path: "" + absPath);
			 }
			 return p;
		 }
		 catch (NameException mpe) {
			 String msg = ""Invalid path: "" + absPath;
			 log.debug(msg);
			 throw new RepositoryException(msg, mpe);
		 }
	 }
	 NodeState getVersionState(Version version) throws RepositoryException {
		 NodeState nodeState;
		 if (version.getSession() == this) {
			 nodeState = (NodeState) ((NodeImpl) version).getItemState();
		 }
		 else {
			 Path p = getQPath(version.getPath());
			 Path parentPath = p.getAncestor(1);
			 HierarchyEntry parentEntry = getHierarchyManager().lookup(parentPath);
			 if (parentEntry != null) {
				 parentEntry.invalidate(false);
			 }
			 nodeState = getHierarchyManager().getNodeState(p);
		 }
		 return nodeState;
	 }
	 void checkIsAlive() throws RepositoryException {
		 if (!alive) {
			 throw new RepositoryException(""This session has been closed."");
		 }
	 }
	 boolean isSupportedOption(String option) {
		 String desc = repository.getDescriptor(option);
		 return (desc == null) ? true : Boolean.valueOf(desc);
	 }
	 void checkSupportedOption(String option) throws UnsupportedRepositoryOperationException, RepositoryException {
		 if (!isSupportedOption(option)) {
			 throw new UnsupportedRepositoryOperationException(option + "" is not supported by this repository."");
		 }
	 }
	 void checkHasPendingChanges() throws RepositoryException {
		 if (hasPendingChanges()) {
			 String msg = ""Unable to perform operation. Session has pending changes."";
			 log.debug(msg);
			 throw new InvalidItemStateException(msg);
		 }
	 }
	 void checkAccessibleWorkspace(String workspaceName) throws NoSuchWorkspaceException, RepositoryException {
		 String[] wsps = workspace.getAccessibleWorkspaceNames();
		 boolean accessible = false;
		 for (int i = 0;
		 i < wsps.length && !accessible;
		 i++) {
			 accessible = wsps[i].equals(workspaceName);
		 }
		 if (!accessible) {
			 throw new NoSuchWorkspaceException(""Unknown workspace: '"" + workspaceName + ""'."");
		 }
	 }
	 private final class IdResolver implements IdentifierResolver {
		 public Path getPath(String identifier) throws MalformedPathException {
			 try {
				 NodeId id = getIdFactory().fromJcrIdentifier(identifier);
				 return getHierarchyManager().getNodeEntry(id).getPath();
			 }
			 catch (RepositoryException e) {
				 throw new MalformedPathException(""Invalid identifier '"" + identifier + ""'."");
			 }
		 }
		 public void checkFormat(String identifier) throws MalformedPathException {
			 try {
				 getIdFactory().fromJcrIdentifier(identifier);
			 }
			 catch (Exception e) {
				 throw new MalformedPathException(""Invalid identifier '"" + identifier + ""'."");
			 }
		 }
	 }
}",1,0,0,0
"final class AffineMatrix implements ExtendedPrecisionMatrix, Serializable, Cloneable {
	 private static final long serialVersionUID = 1605578645060388327L;
	 private static final int SIZE = 3;
	 private static final int LENGTH = SIZE * SIZE;
	 private static final int LENGTH_STORED = (SIZE - 1) * SIZE;
	 private static final int LENGTH_EXTENDED = 2 * LENGTH;
	 private final AffineTransform transform;
	 private final double[] errors;
	 AffineMatrix(final AffineTransform transform, final double[] elements) {
		 this.transform = transform;
		 if (elements != null) {
			 assert elements.length == LENGTH || elements.length == LENGTH_EXTENDED;
			 if (elements.length == LENGTH_EXTENDED) {
				 errors = Arrays.copyOfRange(elements, LENGTH, LENGTH + LENGTH_STORED);
				 return;
			 }
		 }
		 errors = null;
	 }
	 public int getNumRow() {
		 return SIZE;
	 }
	 public int getNumCol() {
		 return SIZE;
	 }
	 public boolean isIdentity() {
		 return transform.isIdentity();
	 }
	 public double[] getExtendedElements() {
		 final double[] elements = new double[errors != null ? LENGTH_EXTENDED : LENGTH];
		 if (errors != null) {
			 System.arraycopy(errors, 0, elements, LENGTH, LENGTH_STORED);
		 }
		 elements[0] = transform.getScaleX();
		 elements[1] = transform.getShearX();
		 elements[2] = transform.getTranslateX();
		 elements[3] = transform.getShearY();
		 elements[4] = transform.getScaleY();
		 elements[5] = transform.getTranslateY();
		 elements[8] = 1;
		 return elements;
	 }
	 public final double getElement(final int row, final int column) {
		 ArgumentChecks.ensureBetween(""row"", 0, SIZE, row);
		 ArgumentChecks.ensureBetween(""column"", 0, SIZE, column);
		 switch (row * SIZE + column) {
			 case 0: return transform.getScaleX();
			 case 1: return transform.getShearX();
			 case 2: return transform.getTranslateX();
			 case 3: return transform.getShearY();
			 case 4: return transform.getScaleY();
			 case 5: return transform.getTranslateY();
			 case 6: case 7: return 0;
			 case 8: return 1;
			 default: throw new AssertionError();
		 }
	 }
	 public final void setElement(final int row, final int column, final double value) {
		 throw new UnsupportedOperationException(Resources.format(Resources.Keys.UnmodifiableAffineTransform));
	 }
	 public final Matrix clone() {
		 return Matrices.copy(this);
	 }
	 public boolean equals(final Object obj) {
		 if (obj instanceof AffineMatrix) {
			 final AffineMatrix other = (AffineMatrix) obj;
			 return transform.equals(other.transform) && Arrays.equals(errors, other.errors);
		 }
		 return false;
	 }
	 public int hashCode() {
		 return (transform.hashCode() * 31 + Arrays.hashCode(errors)) ^ (int) serialVersionUID;
	 }
	 public String toString() {
		 return Matrices.toString(this);
	 }
}",1,0,0,0
"public File getBaseDir() {
	 if (isReference()) {
		 return ((FileResource) getCheckedRef()).getBaseDir();
	 }
	 dieOnCircularReference();
	 return baseDir;
 }",0,0,0,0
"public class XmlTag extends MarkupElement{
	private static final Logger log = LoggerFactory.getLogger(XmlTag.class);
	public static final Type CLOSE = new Type(""CLOSE"");
	public static final Type OPEN = new Type(""OPEN"");
	public static final Type OPEN_CLOSE = new Type(""OPEN_CLOSE"");
	private IValueMap attributes;
	int columnNumber;
	int length;
	int lineNumber;
	String name;
	String namespace;
	int pos;
	CharSequence text;
	Type type;
	private XmlTag closes;
	private XmlTag copyOf = this;
	private boolean isMutable = true;
	private boolean nameChanged = false;
	public static final class Type extends EnumeratedType{
		private static final long serialVersionUID = 1L;
		Type(final String name){
			super(name);
		}
	}
	public XmlTag(){
		super();
	}
	public final boolean closes(final XmlTag open){
		return (closes == open) || (closes == open.copyOf);
	}
	public final boolean equalTo(final MarkupElement element){
		if (element instanceof XmlTag){
			final XmlTag that = (XmlTag)element;
			if (!Objects.equal(getNamespace(), that.getNamespace())){
				return false;
			}
			if (!getName().equals(that.getName())){
				return false;
			}
			if (!getAttributes().equals(that.getAttributes())){
				return false;
			}
			return true;
		}
		return false;
	}
	public IValueMap getAttributes(){
		if (attributes == null){
			if ((copyOf == this) || (copyOf == null) || (copyOf.attributes == null)){
				attributes = new TagAttributes();
			}
			else{
				attributes = new TagAttributes(copyOf.attributes);
			}
		}
		return attributes;
	}
	public boolean hasAttributes(){
		return attributes != null && attributes.size() > 0;
	}
	public int getColumnNumber(){
		return columnNumber;
	}
	public int getLength(){
		return length;
	}
	public int getLineNumber(){
		return lineNumber;
	}
	public String getName(){
		return name;
	}
	public boolean getNameChanged(){
		return nameChanged;
	}
	public String getNamespace(){
		return namespace;
	}
	public final XmlTag getOpenTag(){
		return closes;
	}
	public int getPos(){
		return pos;
	}
	public CharSequence getString(final String key){
		return getAttributes().getCharSequence(key);
	}
	public Type getType(){
		return type;
	}
	public boolean isClose(){
		return type == CLOSE;
	}
	public final boolean isMutable(){
		return isMutable;
	}
	public boolean isOpen(){
		return type == OPEN;
	}
	public boolean isOpenClose(){
		return type == OPEN_CLOSE;
	}
	public boolean hasEqualTagName(final XmlTag tag){
		if (!getName().equalsIgnoreCase(tag.getName())){
			return false;
		}
		if ((getNamespace() == null) && (tag.getNamespace() == null)){
			return true;
		}
		if ((getNamespace() != null) && (tag.getNamespace() != null)){
			return getNamespace().equalsIgnoreCase(tag.getNamespace());
		}
		return false;
	}
	public void makeImmutable(){
		if (isMutable){
			isMutable = false;
			if (attributes != null){
				attributes.makeImmutable();
				text = null;
			}
		}
	}
	public XmlTag mutable(){
		if (isMutable){
			return this;
		}
		else{
			final XmlTag tag = new XmlTag();
			copyPropertiesTo(tag);
			return tag;
		}
	}
	void copyPropertiesTo(XmlTag dest){
		dest.namespace = namespace;
		dest.name = name;
		dest.pos = pos;
		dest.length = length;
		dest.text = text;
		dest.type = type;
		dest.isMutable = true;
		dest.closes = closes;
		dest.copyOf = copyOf;
		if (attributes != null){
			dest.attributes = new ValueMap(attributes);
		}
	}
	public Object put(final String key, final boolean value){
		return put(key, Boolean.toString(value));
	}
	public Object put(final String key, final int value){
		return put(key, Integer.toString(value));
	}
	public Object put(final String key, final CharSequence value){
		return getAttributes().put(key, value);
	}
	public Object put(final String key, final StringValue value){
		return getAttributes().put(key, (value != null) ? value.toString() : null);
	}
	public void putAll(final Map<String, Object> map){
		for (final Iterator<Map.Entry<String, Object>> iterator = map.entrySet().iterator();
		 iterator.hasNext();
		){
			final Map.Entry<String, Object> entry = iterator.next();
			Object value = entry.getValue();
			put(entry.getKey(), (value != null) ? value.toString() : null);
		}
	}
	public void remove(final String key){
		getAttributes().remove(key);
	}
	public void setName(final String name){
		if (isMutable){
			this.name = name;
			nameChanged = true;
		}
		else{
			throw new UnsupportedOperationException(""Attempt to set name of immutable tag"");
		}
	}
	public void setNamespace(final String namespace){
		if (isMutable){
			this.namespace = namespace;
			nameChanged = true;
		}
		else{
			throw new UnsupportedOperationException(""Attempt to set namespace of immutable tag"");
		}
	}
	public void setOpenTag(final XmlTag tag){
		closes = tag;
	}
	public void setType(final Type type){
		if (isMutable){
			this.type = type;
		}
		else{
			throw new UnsupportedOperationException(""Attempt to set type of immutable tag"");
		}
	}
	public String toDebugString(){
		return ""[Tag name = "" + name + "", pos = "" + pos + "", line = "" + lineNumber + "", length = "" +length + "", attributes = ["" + getAttributes() + ""], type = "" + type + ""]"";
	}
	public String toString(){
		return toCharSequence().toString();
	}
	public CharSequence toCharSequence(){
		if (!isMutable && (text != null)){
			return text;
		}
		return toXmlString(null);
	}
	public String toUserDebugString(){
		return ""'"" + toString() + ""' (line "" + lineNumber + "", column "" + columnNumber + "")"";
	}
	public CharSequence toXmlString(final String attributeToBeIgnored){
		final AppendingStringBuffer buffer = new AppendingStringBuffer();
		buffer.append('<');
		if (type == CLOSE){
			buffer.append('/');
		}
		if (namespace != null){
			buffer.append(namespace);
			buffer.append(':');
		}
		buffer.append(name);
		final IValueMap attributes = getAttributes();
		if (attributes.size() > 0){
			final Iterator<String> iterator = attributes.keySet().iterator();
			for (;
			 iterator.hasNext();
			){
				final String key = iterator.next();
				if ((key != null) &&((attributeToBeIgnored == null) || !key.equalsIgnoreCase(attributeToBeIgnored))){
					buffer.append("" "");
					buffer.append(key);
					CharSequence value = getString(key);
					if (value != null){
						buffer.append(""=\"""");
						value = Strings.replaceAll(value, ""\"""", ""\\\"""");
						buffer.append(value);
						buffer.append(""\"""");
					}
				}
			}
		}
		if (type == OPEN_CLOSE){
			buffer.append('/');
		}
		buffer.append('>');
		return buffer;
	}
}",0,0,0,0
"public CurrentLiveVersion(ReloadableType reloadableType, String versionstamp, byte[] newbytedata) {
	if (GlobalConfiguration.logging && log.isLoggable(Level.FINER)) {
		log.entering(""CurrentLiveVersion"", ""<init>"", "" new version of "" + reloadableType.getName()+ "" loaded, version stamp '""+ versionstamp + ""'"");
	}
	this.reloadableType = reloadableType;
	this.typeDescriptor = reloadableType.getTypeRegistry().getExtractor().extract(newbytedata, true);
	this.versionstamp = versionstamp;
	if (GlobalConfiguration.assertsMode) {
		if (!this.typeDescriptor.getName().equals(reloadableType.typedescriptor.getName())) {
			throw new IllegalStateException(""New version has wrong name. Expected ""+ reloadableType.typedescriptor.getName()+ "" but was "" + typeDescriptor.getName());
		}
	}
	newbytedata = GlobalConfiguration.callsideRewritingOn ? MethodInvokerRewriter.rewrite(reloadableType.typeRegistry,newbytedata) : newbytedata;
	this.incrementalTypeDescriptor = new IncrementalTypeDescriptor(reloadableType.typedescriptor);
	this.incrementalTypeDescriptor.setLatestTypeDescriptor(this.typeDescriptor);
	this.executor = reloadableType.getTypeRegistry().executorBuilder.createFor(reloadableType, versionstamp,typeDescriptor,newbytedata);
	if (GlobalConfiguration.classesToDump != null&& GlobalConfiguration.classesToDump.contains(reloadableType.getSlashedName())) {
		Utils.dump(Utils.getExecutorName(reloadableType.getName(), versionstamp).replace('.', '/'), this.executor);
	}
	if (!typeDescriptor.isInterface()) {
		this.dispatcherName = Utils.getDispatcherName(reloadableType.getName(), versionstamp);
		this.executorName = Utils.getExecutorName(reloadableType.getName(), versionstamp);
		this.dispatcher = DispatcherBuilder.createFor(reloadableType, incrementalTypeDescriptor, versionstamp);
	}
	reloadableType.typeRegistry.checkChildClassLoader(reloadableType);
	define();
}",0,0,1,0
"public interface Float2ObjFunction<T> extends Serializable {
	 T apply(float input);
}",0,0,0,0
"public boolean addAddressInfo(AddressInfo addressInfo) throws Exception {
	 boolean added = reloadAddressInfo(addressInfo);
	 if (added && storageManager != null) {
		 long txID = storageManager.generateID();
		 try {
			 storageManager.addAddressBinding(txID, addressInfo);
			 storageManager.commitBindings(txID);
		 }
		 catch (Exception e) {
			 try {
				 storageManager.rollbackBindings(txID);
			 }
			 catch (Exception ignored) {
			 }
			 throw e;
		 }
	 }
	 return added;
 }",0,0,0,0
"public final class ConstantInteger extends Constant implements ConstantObject {
	 private int bytes;
	 public ConstantInteger(final int bytes) {
		 super(Const.CONSTANT_Integer);
		 this.bytes = bytes;
	 }
	 public ConstantInteger(final ConstantInteger c) {
		 this(c.getBytes());
	 }
	 ConstantInteger(final DataInput file) throws IOException {
		 this(file.readInt());
	 }
	 public void accept( final Visitor v ) {
		 v.visitConstantInteger(this);
	 }
	 public final void dump( final DataOutputStream file ) throws IOException {
		 file.writeByte(super.getTag());
		 file.writeInt(bytes);
	 }
	 public final int getBytes() {
		 return bytes;
	 }
	 public final void setBytes( final int bytes ) {
		 this.bytes = bytes;
	 }
	 public final String toString() {
		 return super.toString() + ""(bytes = "" + bytes + "")"";
	 }
	 public Object getConstantValue( final ConstantPool cp ) {
		 return Integer.valueOf(bytes);
	 }
}",0,0,0,0
"public class WordMedian extends Configured implements Tool {
	 private double median = 0;
	 private final static IntWritable ONE = new IntWritable(1);
	 public static class WordMedianMapper extends Mapper<Object, Text, IntWritable, IntWritable> {
		 private IntWritable length = new IntWritable();
		 public void map(Object key, Text value, Context context) throws IOException, InterruptedException {
			 StringTokenizer itr = new StringTokenizer(value.toString());
			 while (itr.hasMoreTokens()) {
				 String string = itr.nextToken();
				 length.set(string.length());
				 context.write(length, ONE);
			 }
		 }
	 }
	 public static class WordMedianReducer extends Reducer<IntWritable, IntWritable, IntWritable, IntWritable> {
		 private IntWritable val = new IntWritable();
		 public void reduce(IntWritable key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException {
			 int sum = 0;
			 for (IntWritable value : values) {
				 sum += value.get();
			 }
			 val.set(sum);
			 context.write(key, val);
		 }
	 }
	 private double readAndFindMedian(String path, int medianIndex1, int medianIndex2, Configuration conf) throws IOException {
		 FileSystem fs = FileSystem.get(conf);
		 Path file = new Path(path, ""part-r-00000"");
		 if (!fs.exists(file)) throw new IOException(""Output not found!"");
		 BufferedReader br = null;
		 try {
			 br = new BufferedReader(new InputStreamReader(fs.open(file), Charsets.UTF_8));
			 int num = 0;
			 String line;
			 while ((line = br.readLine()) != null) {
				 StringTokenizer st = new StringTokenizer(line);
				 String currLen = st.nextToken();
				 String lengthFreq = st.nextToken();
				 int prevNum = num;
				 num += Integer.parseInt(lengthFreq);
				 if (medianIndex2 >= prevNum && medianIndex1 <= num) {
					 System.out.println(""The median is: "" + currLen);
					 br.close();
					 return Double.parseDouble(currLen);
				 }
				 else if (medianIndex2 >= prevNum && medianIndex1 < num) {
					 String nextCurrLen = st.nextToken();
					 double theMedian = (Integer.parseInt(currLen) + Integer .parseInt(nextCurrLen)) / 2.0;
					 System.out.println(""The median is: "" + theMedian);
					 br.close();
					 return theMedian;
				 }
			 }
		 }
		 finally {
			 if (br != null) {
				 br.close();
			 }
		 }
		 return -1;
	 }
	 public static void main(String[] args) throws Exception {
		 ToolRunner.run(new Configuration(), new WordMedian(), args);
	 }
	 public int run(String[] args) throws Exception {
		 if (args.length != 2) {
			 System.err.println(""Usage: wordmedian <in> <out>"");
			 return 0;
		 }
		 setConf(new Configuration());
		 Configuration conf = getConf();
		 Job job = new Job(conf, ""word median"");
		 job.setJarByClass(WordMedian.class);
		 job.setMapperClass(WordMedianMapper.class);
		 job.setCombinerClass(WordMedianReducer.class);
		 job.setReducerClass(WordMedianReducer.class);
		 job.setOutputKeyClass(IntWritable.class);
		 job.setOutputValueClass(IntWritable.class);
		 FileInputFormat.addInputPath(job, new Path(args[0]));
		 FileOutputFormat.setOutputPath(job, new Path(args[1]));
		 boolean result = job.waitForCompletion(true);
		 long totalWords = job.getCounters() .getGroup(TaskCounter.class.getCanonicalName()) .findCounter(""MAP_OUTPUT_RECORDS"", ""Map output records"").getValue();
		 int medianIndex1 = (int) Math.ceil((totalWords / 2.0));
		 int medianIndex2 = (int) Math.floor((totalWords / 2.0));
		 median = readAndFindMedian(args[1], medianIndex1, medianIndex2, conf);
		 return (result ? 0 : 1);
	 }
	 public double getMedian() {
		 return median;
	 }
}",1,0,0,0
"private void removeAndReconnect(MapReduceOper mr, MapReduceOper newMR) throws VisitorException {
	 List<MapReduceOper> mapperSuccs = getPlan().getSuccessors(mr);
	 List<MapReduceOper> mapperPreds = getPlan().getPredecessors(mr);
	 ArrayList<MapReduceOper> succsCopy = null;
	 ArrayList<MapReduceOper> predsCopy = null;
	 if (mapperSuccs != null) {
		 succsCopy = new ArrayList<MapReduceOper>(mapperSuccs);
	 }
	 if (mapperPreds != null) {
		 predsCopy = new ArrayList<MapReduceOper>(mapperPreds);
	 }
	 getPlan().remove(mr);
	 if (succsCopy != null) {
		 for (MapReduceOper succ : succsCopy) {
			 try {
				 getPlan().connect(newMR, succ);
			 }
			 catch (PlanException e) {
				 int errCode = 2133;
				 String msg = ""Internal Error. Unable to connect map plan with successors for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
		 }
	 }
	 if (predsCopy != null) {
		 for (MapReduceOper pred : predsCopy) {
			 if (newMR.getOperatorKey().equals(pred.getOperatorKey())) {
				 continue;
			 }
			 try {
				 getPlan().connect(pred, newMR);
			 }
			 catch (PlanException e) {
				 int errCode = 2134;
				 String msg = ""Internal Error. Unable to connect map plan with predecessors for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
		 }
	 }
	 mergeMROperProperties(mr, newMR);
 }",0,0,1,0
"class FilterStaxUnmarshaller implements Unmarshaller<Filter, StaxUnmarshallerContext> {
	 private static FilterStaxUnmarshaller instance = new FilterStaxUnmarshaller();
	 public static FilterStaxUnmarshaller getInstance() {
		 return instance;
	 }
	 private FilterStaxUnmarshaller() {
	 }
	 public Filter unmarshall(StaxUnmarshallerContext context) throws Exception {
		 int originalDepth = context.getCurrentDepth();
		 int targetDepth = originalDepth + 1;
		 if (context.isStartOfDocument()) {
			 targetDepth += 1;
		 }
		 Filter filter = new Filter();
		 while (true) {
			 XMLEvent xmlEvent = context.nextEvent();
			 if (xmlEvent.isEndDocument()) {
				 return filter;
			 }
			 if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
				 if (context.testExpression(""S3Key"", targetDepth)) {
					 filter.withS3KeyFilter(S3KeyFilterStaxUnmarshaller.getInstance().unmarshall(context));
				 }
			 }
			 else if (xmlEvent.isEndElement()) {
				 if (context.getCurrentDepth() < originalDepth) {
					 return filter;
				 }
			 }
		 }
	 }
}",0,0,0,0
"public class StaticTemplate implements Template, Serializable {
	 private String id = null;
	 private String name = null;
	 private String description = null;
	 private String contents = null;
	 private String link = null;
	 private Date lastModified = new Date();
	 private String templateLanguage = null;
	 private boolean hidden = false;
	 private boolean navbar = false;
	 public StaticTemplate() {
	}
	 public StaticTemplate(String id, String contents, String lang) {
		 this.id = id;
		 this.name = id;
		 this.description = id;
		 this.contents = contents;
		 this.link = id;
		 this.templateLanguage = lang;
	 }
	 public Template getDecorator() {
		 return null;
	 }
	 public String getId() {
		 return id;
	 }
	 public void setId(String id) {
		 this.id = id;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getContents() {
		 return contents;
	 }
	 public void setContents(String contents) {
		 this.contents = contents;
	 }
	 public String getLink() {
		 return link;
	 }
	 public void setLink(String link) {
		 this.link = link;
	 }
	 public Date getLastModified() {
		 return lastModified;
	 }
	 public void setLastModified(Date lastModified) {
		 this.lastModified = lastModified;
	 }
	 public String getTemplateLanguage() {
		 return templateLanguage;
	 }
	 public void setTemplateLanguage(String templateLanguage) {
		 this.templateLanguage = templateLanguage;
	 }
	 public boolean isHidden() {
		 return hidden;
	 }
	 public void setHidden(boolean hidden) {
		 this.hidden = hidden;
	 }
	 public void setNavbar(boolean navbar) {
		 this.navbar = navbar;
	 }
	 public boolean isNavbar() {
		 return navbar;
	 }
}",0,1,0,0
"public static abstract class AbstractFixture implements Fixture {
	 private ZipFixture parent;
	 protected AbstractFixture(ZipFixture parent) {
		 this.parent = parent;
	 }
	 public ZipFixture end() {
		 return (parent == null) ? (ZipFixture) this : parent;
	 }
 }",0,0,0,0
"public class TestProjectRange {
	 protected final Log log = LogFactory.getLog(getClass());
	 private static MiniGenericCluster cluster = MiniGenericCluster.buildCluster();
	 protected static PigServer pigServer;
	 private static final String INP_FILE_5FIELDS = ""TestProjectRange_5fields"";
	 public static void oneTimeSetUp() throws Exception {
		 String[] input = {
		""10\t20\t30\t40\t50"", ""11\t21\t31\t41\t51""}
		;
		 Util.createInputFile(cluster, INP_FILE_5FIELDS, input);
	 }
	 public void setup() throws ExecException {
		 pigServer = new PigServer(cluster.getExecType(), cluster.getProperties());
	 }
	 public void tearDown() throws Exception {
		 pigServer.shutdown();
	 }
	 public static void oneTimeTearDown() throws Exception {
		 new File(INP_FILE_5FIELDS).delete();
		 if(cluster != null) cluster.shutDown();
	 }
	 public void testFullRangeForeachWSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate a .. c as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : float, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate $0 .. $2 as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : float, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate $0 .. c as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : float, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate b .. d as (bb, cc, dd);
		"" ;
		 compileAndCompareSchema(""bb : float, cc : int, dd : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate b .. b as (bb), $2 .. $2;
		"" ;
		 compileAndCompareSchema(""bb : float, c : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : int, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate a .. c, d .. e ;
		"" ;
		 compileAndCompareSchema(""a : int, b : int, c : int, d : int, e : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : int, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate a .. c ;
		"" ;
		 compileAndCompareSchema(""a : int, b : int, c : int"", query, ""f"");
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(10,20,30)"", ""(11,21,31)"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 private void compileAndCompareSchema(String expectedSchStr, String query, String alias) throws IOException, ParserException {
		 Schema expectedSch = null;
		 if(expectedSchStr != null) expectedSch = Utils.getSchemaFromString(expectedSchStr);
		 compileAndCompareSchema(expectedSch, query, alias);
	 }
	 private void compileAndCompareSchema(Schema expectedSch, String query, String alias) throws IOException {
		 Util.registerMultiLineQuery(pigServer, query);
		 Schema sch = pigServer.dumpSchema(alias);
		 assertEquals(""Checking expected schema"", expectedSch, sch);
	 }
	 public void testEndRangeForeachWSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate .. c as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : float, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate .. $2 as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : float, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate .. $0 as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate .. c as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : float, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : int, c : int, d : long, e : int);
		"" + ""f = foreach l1 generate .. $3 ;
		"" ;
		 compileAndCompareSchema(""a : int, b : int, c : int, d : long"", query, ""f"");
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(10,20,30,40L)"", ""(11,21,31,41L)"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 public void testStartRangeForeachWSchema() throws IOException, ParserException {
		 String query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' "" + ""as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate c .. as (aa, bb, cc);
		"" ;
		 compileAndCompareSchema(""aa : int, bb : int, cc : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' "" + ""as (a : int, b : int, c : int, d : long, e : int);
		"" + ""f = foreach l1 generate $1 .. ;
		"" ;
		 compileAndCompareSchema(""b : int, c : int, d : long, e : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' "" + ""as (a : int, b : int, c : int, d : long, e : int);
		"" + ""f = foreach l1 generate e .. ;
		"" ;
		 compileAndCompareSchema(""e : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' "" + ""as (a : int, b : long, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate c .. as (aa, bb, cc), b .. ;
		"" ;
		 compileAndCompareSchema( ""aa : int, bb : int, cc : int, b : long, c : int, d : int, e : int"", query, ""f"" );
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(30,40,50,20L,30,40,50)"", ""(31,41,51,21L,31,41,51)"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 public void testMixRangeForeachWSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate .. b, c .. d, d .. as (aa, bb);
		"" ;
		 compileAndCompareSchema(""a : int, b : float, c : int, d : int, aa : int, bb : int"", query, ""f"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : int, c : int, d : long, e : int);
		"" + ""f = foreach l1 generate ..$0 as (first), e.. as (last), d .., .. b ;
		"" ;
		 compileAndCompareSchema(""first : int, last : int, d : long, e : int, a : int, b : int"", query, ""f"");
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(10,50,40L,50,10,20)"", ""(11,51,41L,51,11,21)"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 public void testNegativeForeachWSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate $3 .. $1;
		"" ;
		 Util.checkExceptionMessage(query, ""f"", ""start column appears after end column in range projection"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : float, c : int, d : int, e : int);
		"" + ""f = foreach l1 generate c .. b;
		"" ;
		 Util.checkExceptionMessage(query, ""f"", ""start column appears after end column in range projection"");
	 }
	 public void testNegativeForeachNOSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + ""f = foreach l1 generate $3 .. $1;
		"" ;
		 Util.checkExceptionMessage(query, ""f"", ""start column appears after end column in range projection"");
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' ;
		"" + ""f = foreach l1 generate a .. b;
		"" ;
		 Util.checkExceptionMessage(query, ""f"", ""Invalid field projection. Projected field [a] does not exist."");
	 }
	 public void testNegativeForeachFollowedByRange() throws IOException, ParserException {
		 String query = ""A = load '"" + INP_FILE_5FIELDS + ""' as (a0,a1,a2,a3,a4);
		"" + ""B = FOREACH A GENERATE a0, b1, a2, a3, a4;
		"" + ""C = FOREACH B GENERATE a0..a2;
		"";
		 LogicalPlan lp = generateLogicalPlan(query);
		 boolean exceptionCaught = false;
		 try {
			 lp.validate(pigServer.getPigContext(), ""test"", false);
		 }
		 catch (PlanValidationException ex) {
			 Util.checkMessageInException(ex, ""Projected field [b1] does not exist in schema: a0:bytearray,a1:bytearray,a2:bytearray,a3:bytearray,a4:bytearray"");
			 exceptionCaught = true;
		 }
		 assertTrue(""No exception was thrown from an invalid script"", exceptionCaught);
	 }
	 public void testStartRangeForeachNOSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + ""f = foreach l1 generate ..$3 as (a,b,c,d);
		"" ;
		 compileAndCompareSchema(""a : bytearray,b : bytearray,c : bytearray,d : bytearray"", query, ""f"");
		 Util.registerMultiLineQuery(pigServer, query);
		 pigServer.explain(""f"", System.err);
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStringAsByteArray( new String[] {
		 ""('10','20','30','40')"", ""('11','21','31','41')"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 public void testMixRangeForeachNOSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + ""f = foreach l1 generate ..$0 as (first), $4.. as (last), $3 .., .. $1 ;
		"" ;
		 compileAndCompareSchema((Schema)null, query, ""f"");
		 Util.registerMultiLineQuery(pigServer, query);
		 pigServer.explain(""f"", System.err);
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStringAsByteArray( new String[] {
		 ""('10','50','40','50','10','20')"", ""('11','51','41','51','11','21')"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 public void testRangeForeachWFilterNOSchema() throws IOException, ParserException {
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + ""f = foreach l1 generate ..$0 as (first), $4.. as (last), $3 .., .. $1 ;
		"" + "" fil = filter f by $0 > 10;
		"" ;
		 Util.registerMultiLineQuery(pigServer, query);
		 pigServer.explain(""fil"", System.err);
		 Iterator<Tuple> it = pigServer.openIterator(""fil"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStringAsByteArray( new String[] {
		 ""('11','51','41','51','11','21')"", }
		);
		 Util.checkQueryOutputsAfterSort(it, expectedRes);
	 }
	 public void testRangeOrderByWSchema() throws IOException, ParserException{
		 String query;
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" o = order l1 by .. $2 DESC ;
			"" ;
			 compileAndCompareSchema(""a : int, b : long, c : int, d : int, e : int"", query, ""o"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			false,false,false}
			;
			 checkNumExpressionPlansForSort(lp, 3, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" o = order l1 by $3 .. ;
			"" ;
			 compileAndCompareSchema(""a : int, b : long, c : int, d : int, e : int"", query, ""o"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			true, true}
			;
			 checkNumExpressionPlansForSort(lp, 2, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" o = order l1 by d .. DESC ;
			"" ;
			 compileAndCompareSchema(""a : int, b : long, c : int, d : int, e : int"", query, ""o"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			false, false}
			;
			 checkNumExpressionPlansForSort(lp, 2, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" f = foreach l1 generate *;
			"" + "" o = order f by $0 .. c ASC ;
			"" + "" lim = limit o 10;
			 ;
			"" ;
			 compileAndCompareSchema(""a : int, b : long, c : int, d : int, e : int"", query, ""lim"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			true, true, true}
			;
			 checkNumExpressionPlansForSort(lp, 3, isAsc);
		 }
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" o = order l1 by $0 .. $4 ;
		"" ;
		 compileAndCompareSchema(""a : int, b : long, c : int, d : int, e : int"", query, ""o"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 boolean[] isAsc = {
		true,true,true,true,true}
		;
		 checkNumExpressionPlansForSort(lp, 5, isAsc);
		 Util.registerMultiLineQuery(pigServer, query);
		 Iterator<Tuple> it = pigServer.openIterator(""o"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(10,20L,30,40,50)"", ""(11,21L,31,41,51)"", }
		);
		 Util.checkQueryOutputs(it, expectedRes);
	 }
	 public void testRangeOrderByNestedWSchema() throws IOException, ParserException{
		 String query;
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" g = group l1 by a;
			"" + "" f = foreach g {
				 o = order l1 by .. $2 DESC;
				 generate group, o;
			}
			"" ;
			 String expectedSchStr = ""g : int,o: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""f"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			false,false,false}
			;
			 checkNumExpressionPlansForSort(lp, 3, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" g = group l1 by a;
			"" + "" f = foreach g {
				 o = order l1 by d .. ;
				 generate group, o;
			}
			"" ;
			 String expectedSchStr = ""g : int,o: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""f"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			true,true}
			;
			 checkNumExpressionPlansForSort(lp, 2, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" g = group l1 by a;
			"" + "" f = foreach g {
				 o = order l1 by $2 .. $3 ASC, $1..c DESC;
				 generate group, o;
			}
			"" ;
			 String expectedSchStr = ""g : int,o: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""f"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			true,true,false,false}
			;
			 checkNumExpressionPlansForSort(lp, 4, isAsc);
		 }
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" g = group l1 by a;
		"" + "" f = foreach g {
			 o = order l1 by $2 .. $3 DESC, $1 ASC;
			 generate group, o;
		}
		"" ;
		 String expectedSchStr = ""g : int,o: {
		t : (a: int,b: long,c: int,d: int,e: int)}
		"";
		 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
		 compileAndCompareSchema(expectedSch, query, ""f"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 boolean[] isAsc = {
		false,false,true}
		;
		 checkNumExpressionPlansForSort(lp, 3, isAsc);
		 Util.registerMultiLineQuery(pigServer, query);
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 String[] expectedRes = new String[] {
			 ""(10,{
			(10,20,30,40,50)}
			)"", ""(11,{
			(11,21,31,41,51)}
		)"", }
		;
		 Schema s = pigServer.dumpSchema(""f"");
		 Util.checkQueryOutputs(it, expectedRes,org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 public void testRangeOrderByNestedNOSchema() throws IOException, ParserException{
		 String query;
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
			"" + "" g = group l1 by $0;
			"" + "" f = foreach g {
				 o = order l1 by .. $2 DESC;
				 generate group, o;
			}
			"" ;
			 String expectedSchStr = ""g : bytearray, o: {
			t : ()}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""f"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			false,false,false}
			;
			 checkNumExpressionPlansForSort(lp, 3, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
			"" + "" g = group l1 by $0;
			"" + "" f = foreach g {
				 o = order l1 by $3 .. ;
				 generate group, o;
			}
			"" ;
			 String expectedSchStr = ""g : bytearray, o: {
			t : ()}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""f"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			true}
			;
			 checkNumExpressionPlansForSort(lp, 1, isAsc);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
			"" + "" g = group l1 by $1;
			"" + "" f = foreach g {
				 o = order l1 by $2 .. $3 ASC, $1 .. $2 DESC;
				 generate group, o;
			}
			"" ;
			 String expectedSchStr = ""g : bytearray, o: {
			t : ()}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""f"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 boolean[] isAsc = {
			true,true,false,false}
			;
			 checkNumExpressionPlansForSort(lp, 4, isAsc);
		 }
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" g = group l1 by 1;
		"" + "" f = foreach g {
			 o = order l1 by $2 .. $3 desc;
			 generate group, o;
		}
		"" ;
		 String expectedSchStr = ""g : int, o: {
		t : ()}
		"";
		 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
		 compileAndCompareSchema(expectedSch, query, ""f"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 boolean[] isAsc = {
		false,false}
		;
		 checkNumExpressionPlansForSort(lp, 2, isAsc);
		 Util.registerMultiLineQuery(pigServer, query);
		 Iterator<Tuple> it = pigServer.openIterator(""f"");
		 String[] expectedRes = new String[] {
			 ""(1,{
			(11,21,31,41,51),(10,20,30,40,50)}
		)"", }
		;
		 Schema s = pigServer.dumpSchema(""f"");
		 Util.checkQueryOutputs(it, expectedRes,org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 private LOSort checkNumExpressionPlansForSort(LogicalPlan lp, int numPlans, boolean[] isAsc) {
		 Class<?> sortClass = org.apache.pig.newplan.logical.relational.LOSort.class;
		 LOSort sort = (LOSort) NewLogicalPlanUtil.getRelOpFromPlan(lp, sortClass);
		 assertEquals(""number of sort col plans"", numPlans, sort.getSortColPlans().size());
		 List<Boolean> ascCols = sort.getAscendingCols();
		 for(int i = 0;
		 i < ascCols.size();
		 i++){
			 assertEquals(""ascending order"", isAsc[i], ascCols.get(i));
		 }
		 return sort;
	 }
	 private LogicalPlan createAndProcessLPlan(String query) throws FrontendException {
		 LogicalPlan lp = generateLogicalPlan(query);
		 lp.validate(pigServer.getPigContext(), ""test"", false);
		 return lp;
	 }
	 private LogicalPlan generateLogicalPlan(String query) {
		 try {
			 return ParserTestingUtils.generateLogicalPlan( query );
		 }
		 catch(Exception ex) {
			 ex.printStackTrace();
			 Assert.fail( ""Failed to generate logical plan for query ["" + query + ""] due to exception: "" + ex );
		 }
		 return null;
	 }
	 public void testRangeOrderByMixWSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" o = order l1 by b .. c, d .. DESC, a DESC;
		"" ;
		 compileAndCompareSchema(""a : int, b : long, c : int, d : int, e : int"", query, ""o"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 boolean[] isAsc = {
		true,true,false,false,false}
		;
		 checkNumExpressionPlansForSort(lp, 5, isAsc);
		 Util.registerMultiLineQuery(pigServer, query);
		 Iterator<Tuple> it = pigServer.openIterator(""o"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStrings( new String[] {
		 ""(10,20L,30,40,50)"", ""(11,21L,31,41,51)"", }
		);
		 Util.checkQueryOutputs(it, expectedRes);
	 }
	 public void testRangeOrderByMixNOSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" o = order l1 by $1 .. $2 DESC, $0 , $4 .. DESC;
		"" ;
		 compileAndCompareSchema((Schema)null, query, ""o"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 boolean[] isAsc = {
		false, false,true,false}
		;
		 checkNumExpressionPlansForSort(lp, 4, isAsc);
		 Util.registerMultiLineQuery(pigServer, query);
		 pigServer.explain(""o"", System.err);
		 Iterator<Tuple> it = pigServer.openIterator(""o"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStringAsByteArray( new String[] {
		 ""('11','21','31','41','51')"", ""('10','20','30','40','50')"", }
		);
		 Util.checkQueryOutputs(it, expectedRes);
	 }
	 public void testRangeOrderByStartNOSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" o = order l1 by $3 .. DESC;
		"" ;
		 compileAndCompareSchema((Schema)null, query, ""o"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 boolean[] isAsc = {
		false}
		;
		 checkNumExpressionPlansForSort(lp, 1, isAsc);
		 Util.registerMultiLineQuery(pigServer, query);
		 pigServer.explain(""o"", System.err);
		 Iterator<Tuple> it = pigServer.openIterator(""o"");
		 List<Tuple> expectedRes = Util.getTuplesFromConstantTupleStringAsByteArray( new String[] {
		 ""('11','21','31','41','51')"", ""('10','20','30','40','50')"", }
		);
		 Util.checkQueryOutputs(it, expectedRes);
	 }
	 public void testRangeOrderByStartNegNOSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" o = order l1 by $3 .. DESC, $1;
		"" ;
		 Util.checkExceptionMessage(query, ""o"",""Project-range to end (eg. x..)"" + "" is supported in order-by only as last sort column"");
	 }
	 public void testRangeGroupWSchema() throws IOException, ParserException{
		 String query;
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" g = group l1 by d .., l2 by d ..;
			"" ;
			 String expectedSchStr = ""grp: (d: int,e : int),"" + ""l1: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			,"" + ""l2: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""g"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 checkNumExpressionPlansForGroup(lp, 2);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" g = group l1 by c .. $3, l2 by $3..$4;
			"" ;
			 String expectedSchStr = ""grp: (c: int,d : int),"" + ""l1: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			,"" + ""l2: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""g"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 checkNumExpressionPlansForGroup(lp, 2);
		 }
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" g = group l1 by .. c, l2 by .. c;
		"" ;
		 String expectedSchStr = ""grp: (a: int,b: long,c: int),"" + ""l1: {
		t : (a: int,b: long,c: int,d: int,e: int)}
		,"" + ""l2: {
		t : (a: int,b: long,c: int,d: int,e: int)}
		"";
		 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
		 compileAndCompareSchema(expectedSch, query, ""g"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 checkNumExpressionPlansForGroup(lp, 3);
		 Util.registerMultiLineQuery(pigServer, query);
		 String[] expectedRes = new String[] {
			 ""((10,20,30),{
			(10,20,30,40,50)}
			,{
			(10,20,30,40,50)}
			)"", ""((11,21,31),{
			(11,21,31,41,51)}
			,{
			(11,21,31,41,51)}
		)"", }
		;
		 Iterator<Tuple> it = pigServer.openIterator(""g"");
		 Schema s = pigServer.dumpSchema(""g"");
		 Util.checkQueryOutputs(it, expectedRes,org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 private Schema getCleanedGroupSchema(String expectedSchStr) throws ParserException, FrontendException {
		 Schema expectedSch = Utils.getSchemaFromString(expectedSchStr);
		 expectedSch.getField(0).alias = ""group"";
		 if(expectedSch.size() > 1) expectedSch.getField(1).schema.getField(0).alias = null;
		 if(expectedSch.size() > 2) expectedSch.getField(2).schema.getField(0).alias = null;
		 expectedSch = org.apache.pig.newplan.logical.Util.fixSchemaAddTupleInBag(expectedSch);
		 return expectedSch;
	 }
	 private LOCogroup checkNumExpressionPlansForGroup(LogicalPlan lp, int numPlans) {
		 Class<?> groupClass = org.apache.pig.newplan.logical.relational.LOCogroup.class;
		 LOCogroup grp = (LOCogroup) NewLogicalPlanUtil.getRelOpFromPlan(lp, groupClass);
		 for( int inp : grp.getExpressionPlans().keySet()){
			 List<LogicalExpressionPlan> plans = grp.getExpressionPlans().get(inp);
			 assertEquals(""number of group-by plans"", numPlans, plans.size());
		 }
		 return grp;
	 }
	 public void testRangeCoGroupMixWSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" g = group l1 by (a + b, c .. d, e.. ), l2 by ($0 + $1, c..d, $4..);
		"" ;
		 String expectedSchStr = ""grp: (x : long, c :int , d :int, e : int),"" + ""l1: {
		t : (a: int,b: long,c: int,d: int,e: int)}
		,"" + ""l2: {
		t : (a: int,b: long,c: int,d: int,e: int)}
		"";
		 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
		 expectedSch.getField(0).schema.getField(0).alias = null;
		 compileAndCompareSchema(expectedSch, query, ""g"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 checkNumExpressionPlansForGroup(lp, 4);
		 Util.registerMultiLineQuery(pigServer, query);
		 String[] expectedRes = new String[] {
			 ""((30,30,40,50),{
			(10,20,30,40,50)}
			,{
			(10,20,30,40,50)}
			)"", ""((32,31,41,51),{
			(11,21,31,41,51)}
			,{
			(11,21,31,41,51)}
		)"", }
		;
		 Iterator<Tuple> it = pigServer.openIterator(""g"");
		 Schema s = pigServer.dumpSchema(""g"");
		 Util.checkQueryOutputs(it,expectedRes, org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 public void testRangeGroupMixWSchema() throws IOException, ParserException{
		 String query;
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
			"" + "" g = group l1 by b .. c;
			"" ;
			 String expectedSchStr = ""grp: (b : long, c :int),"" + ""l1: {
			t : (a: int,b: long,c: int,d: int,e: int)}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""g"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 checkNumExpressionPlansForGroup(lp, 2);
		 }
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" g = group l1 by $2 .. ;
		"" + "" lim = limit g 2;
		"" ;
		 String expectedSchStr = ""grp: (c :int , d :int, e : int),"" + ""l1: {
		t : (a: int,b: long,c: int,d: int,e: int)}
		"";
		 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
		 compileAndCompareSchema(expectedSch, query, ""lim"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 checkNumExpressionPlansForGroup(lp, 3);
		 Util.registerMultiLineQuery(pigServer, query);
		 String[] expectedRes = new String[] {
			 ""((30,40,50),{
			(10,20L,30,40,50)}
			)"", ""((31,41,51),{
			(11,21L,31,41,51)}
		)"", }
		;
		 Iterator<Tuple> it = pigServer.openIterator(""lim"");
		 Schema s = pigServer.dumpSchema(""lim"");
		 Util.checkQueryOutputs(it, expectedRes,org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 public void testRangeGroupMixNOSchema() throws IOException, ParserException{
		 String query;
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
			"" + "" g = group l1 by .. $2;
			"" ;
			 String expectedSchStr = ""g : (duma, dumb, dumc), l1: {
			t : ()}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 setAliasesToNull(expectedSch.getField(0).schema);
			 compileAndCompareSchema(expectedSch, query, ""g"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 checkNumExpressionPlansForGroup(lp, 3);
		 }
		 {
			 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
			"" + "" g = group l1 by $3 .. $3;
			"" ;
			 String expectedSchStr = ""g : bytearray, l1: {
			t : ()}
			"";
			 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
			 compileAndCompareSchema(expectedSch, query, ""g"");
			 LogicalPlan lp = createAndProcessLPlan(query);
			 checkNumExpressionPlansForGroup(lp, 1);
		 }
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" g = group l1 by $2 .. ;
		"" ;
		 String expectedSchStr = ""grp: (), l1: {
		t : ()}
		"";
		 Schema expectedSch = getCleanedGroupSchema(expectedSchStr);
		 compileAndCompareSchema(expectedSch, query, ""g"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 checkNumExpressionPlansForGroup(lp, 1);
		 Util.registerMultiLineQuery(pigServer, query);
		 String[] expectedRes = new String[] {
			 ""((30,40,50),{
			(10,20,30,40,50)}
			)"", ""((31,41,51),{
			(11,21,31,41,51)}
		)"", }
		;
		 Iterator<Tuple> it = pigServer.openIterator(""g"");
		 Schema s = pigServer.dumpSchema(""g"");
		 Util.checkQueryOutputs(it, expectedRes, org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 private void setAliasesToNull(Schema schema) {
		 for(FieldSchema fs : schema.getFields()){
			 fs.alias = null;
		 }
	 }
	 public void testRangeJoinMixWSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""' as (a : int, b : long, c : int, d : int, e : int);
		"" + "" j = join l1 by (a + b, c .. d, e.. ), l2 by ($0 + $1, c..d, $4..);
		"" ;
		 String expectedSchStr = ""l1::a: int, l1::b: long, l1::c: int, l1::d: int, l1::e: int,"" + ""l2::a: int, l2::b: long, l2::c: int, l2::d: int, l2::e: int"";
		 compileAndCompareSchema(expectedSchStr, query, ""j"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 checkNumExpressionPlansForJoin(lp, 4);
		 Util.registerMultiLineQuery(pigServer, query);
		 String[] expectedRes = new String[] {
		 ""(10,20,30,40,50,10,20,30,40,50)"", ""(11,21,31,41,51,11,21,31,41,51)"", }
		;
		 Iterator<Tuple> it = pigServer.openIterator(""j"");
		 Schema s = pigServer.dumpSchema(""j"");
		 Util.checkQueryOutputs(it, expectedRes, org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 public void testRangeJoinMixNOSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" j = join l1 by $0 .. $3, l2 by $0 .. $3;
		"" ;
		 compileAndCompareSchema((Schema)null, query, ""j"");
		 LogicalPlan lp = createAndProcessLPlan(query);
		 checkNumExpressionPlansForJoin(lp, 4);
		 Util.registerMultiLineQuery(pigServer, query);
		 String[] expectedRes = new String[] {
		 ""(10,20,30,40,50,10,20,30,40,50)"", ""(11,21,31,41,51,11,21,31,41,51)"", }
		;
		 Iterator<Tuple> it = pigServer.openIterator(""j"");
		 Schema s = pigServer.dumpSchema(""j"");
		 Util.checkQueryOutputs(it, expectedRes, org.apache.pig.newplan.logical.Util.translateSchema(s), Util.isSparkExecType(cluster.getExecType()));
	 }
	 public void testRangeCoGroupNegNoSchema() throws IOException, ParserException{
		 String query;
		 query = "" l1 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" l2 = load '"" + INP_FILE_5FIELDS + ""';
		"" + "" g = cogroup l1 by ($0 .. ), l2 by ($0 .. );
		"";
		 Util.checkExceptionMessage(query, ""g"", ""Cogroup/Group by '*' or 'x..' "" + ""(range of columns to the end) "" + ""is only allowed if the input has a schema"");
	 }
	 private LOJoin checkNumExpressionPlansForJoin(LogicalPlan lp, int numPlans) {
		 Class<?> joinClass = org.apache.pig.newplan.logical.relational.LOJoin.class;
		 LOJoin join = (LOJoin) NewLogicalPlanUtil.getRelOpFromPlan(lp, joinClass);
		 for( int inp : join.getExpressionPlans().keySet()){
			 List<LogicalExpressionPlan> plans = join.getExpressionPlans().get(inp);
			 assertEquals(""number of join exp plans"", numPlans, plans.size());
		 }
		 return join;
	 }
}",1,0,0,0
"public final class ProgressDialog {
	 private ProgressDialog() {
	 }
	 public static Exception show( final Window parent, final String title, final IProgressThread thread) {
		 Preconditions.checkNotNull(thread, ""Error: Thread argument can't be null"");
		 final EndlessHelperWrapper helperThread = new EndlessHelperWrapper(thread);
		 CProgressDialog.showEndless(parent, title, helperThread);
		 return helperThread.getException();
	 }
	 private static class EndlessHelperWrapper extends CEndlessHelperThread {
		 private final IProgressThread m_thread;
		 private EndlessHelperWrapper(final IProgressThread thread) {
			 m_thread = thread;
		 }
		 protected void runExpensiveCommand() throws Exception {
			 m_thread.run();
		 }
		 public void closeRequested() {
			 if (m_thread.close()) {
				 finish();
			 }
		 }
	 }
}",0,0,0,0
"public class Progress {
	 private String status = """";
	 private float progress;
	 private int currentPhase;
	 private ArrayList phases = new ArrayList();
	 private Progress parent;
	 private float progressPerPhase;
	 public Progress() {
	}
	 public Progress addPhase(String status) {
		 Progress phase = addPhase();
		 phase.setStatus(status);
		 return phase;
	 }
	 public Progress addPhase() {
		 Progress phase = new Progress();
		 phases.add(phase);
		 phase.parent = this;
		 progressPerPhase = 1.0f / (float)phases.size();
		 return phase;
	 }
	 public void startNextPhase() {
		 currentPhase++;
	 }
	 public Progress phase() {
		 return (Progress)phases.get(currentPhase);
	 }
	 public void complete() {
		 progress = 1.0f;
		 if (parent != null) {
			 parent.startNextPhase();
		 }
	 }
	 public void set(float progress) {
		 this.progress = progress;
	 }
	 public float get() {
		 Progress node = this;
		 while (node.parent != null) {
			 node = parent;
		 }
		 return node.getInternal();
	 }
	 private float getInternal() {
		 int phaseCount = phases.size();
		 if (phaseCount != 0) {
			 float subProgress = currentPhase < phaseCount ? phase().getInternal() : 0.0f;
			 return progressPerPhase*(currentPhase + subProgress);
		 }
		 else {
			 return progress;
		 }
	 }
	 public void setStatus(String status) {
		 this.status = status;
	 }
	 public String toString() {
		 StringBuffer result = new StringBuffer();
		 toString(result);
		 return result.toString();
	 }
	 private void toString(StringBuffer buffer) {
		 buffer.append(status);
		 if (phases.size() != 0 && currentPhase < phases.size()) {
			 buffer.append("" > "");
			 phase().toString(buffer);
		 }
	 }
}",0,0,0,0
"public void setAlwaysLog(boolean alwaysLog) {
	 synchronized (outMutex) {
		 alwaysLogOut = alwaysLog;
	 }
	 synchronized (errMutex) {
		 alwaysLogErr = alwaysLog;
	 }
 }",0,0,0,0
"public boolean getIdl() {
	 return idl;
 }",0,0,0,0
void close(DatagramSocket sock);,0,0,0,0
"public class RDFListImpl extends ResourceImpl implements RDFList{
	 public static Implementation factory = new Implementation() {
		 public EnhNode wrap( Node n, EnhGraph eg ) {
			 if (canWrap( n, eg )) {
				 RDFListImpl impl = new RDFListImpl( n, eg );
				 if (eg instanceof OntModel) {
					 Profile prof = ((OntModel) eg).getProfile();
					 impl.m_listFirst = prof.FIRST();
					 impl.m_listRest = prof.REST();
					 impl.m_listNil = prof.NIL();
					 impl.m_listType = prof.LIST();
				 }
				 return impl;
			 }
			 else {
				 throw new JenaException( ""Cannot convert node "" + n + "" to RDFList"");
			 }
		 }
		 public boolean canWrap( Node node, EnhGraph eg ) {
			 Graph g = eg.asGraph();
			 Resource first = RDF.first;
			 Resource rest = RDF.rest;
			 Resource nil = RDF.nil;
			 if (eg instanceof OntModel) {
				 Profile prof = ((OntModel) eg).getProfile();
				 first = prof.FIRST();
				 rest = prof.REST();
				 nil = prof.NIL();
			 }
			 return node.equals( nil.asNode() ) || g.contains( node, first.asNode(), Node.ANY ) || g.contains( node, rest.asNode(), Node.ANY ) || g.contains( node, RDF.type.asNode(), RDF.List.asNode() );
		 }
	 }
	;
	 protected static boolean s_checkValid = false;
	 private static final Logger log = LoggerFactory.getLogger( RDFListImpl.class );
	 protected String m_errorMsg = null;
	 protected RDFList m_tail = null;
	 protected Property m_listFirst = RDF.first;
	 protected Property m_listRest = RDF.rest;
	 protected Resource m_listNil = RDF.nil;
	 protected Resource m_listType = RDF.List;
	 public RDFListImpl( Node n, EnhGraph g ) {
		 super( n, g );
	 }
	 public Resource listType() {
		 return m_listType;
	 }
	 public Resource listNil() {
		 return m_listNil;
	 }
	 public Property listFirst() {
		 return m_listFirst;
	 }
	 public Property listRest() {
		 return m_listRest;
	 }
	 public Class<? extends RDFList> listAbstractionClass() {
		 return RDFList.class;
	 }
	 public int size() {
		 if (s_checkValid) {
			 checkValid();
		 }
		 int size = 0;
		 for (Iterator<RDFNode> i = iterator();
		 i.hasNext();
		 i.next()) {
			 size++;
		 }
		 return size;
	 }
	 public RDFNode getHead() {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Tried to get the head of an empty list"" );
		 return getRequiredProperty( listFirst() ).getObject();
	 }
	 public RDFNode setHead( RDFNode value ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Tried to set the head of an empty list"" );
		 Statement current = getRequiredProperty( listFirst() );
		 RDFNode n = current.getObject();
		 current.remove();
		 addProperty( listFirst(), value );
		 return n;
	 }
	 public RDFList getTail() {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Tried to get the tail of an empty list"" );
		 Resource tail = getRequiredProperty( listRest() ).getResource();
		 return tail.as( listAbstractionClass() );
	 }
	 public RDFList setTail( RDFList tail ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Tried to set the tail of an empty list"" );
		 return (setTailAux( this, tail, listRest() )).as( listAbstractionClass() );
	 }
	 public boolean isEmpty() {
		 if (s_checkValid) {
			 checkValid();
		 }
		 return equals( listNil() );
	 }
	 public RDFList cons( RDFNode value ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 return (newListCell( value, this )).as( listAbstractionClass() );
	 }
	 public void add( RDFNode value ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 if (isEmpty()) {
			 throw new EmptyListUpdateException( ""Attempt to add() to the empty list (rdf:nil)"" );
		 }
		 RDFList tail = findElement( true, 0 );
		 setTailAux( tail, newListCell( value, listNil() ), listRest() );
	 }
	 public RDFList with( RDFNode value ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 if (isEmpty()) {
			 return cons( value );
		 }
		 RDFList tail = findElement( true, 0 );
		 setTailAux( tail, newListCell( value, listNil() ), listRest() );
		 return this;
	 }
	 public RDFNode get( int i ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Tried to get an element from the empty list"" );
		 return findElement( false, i ).getHead();
	 }
	 public RDFNode replace( int i, RDFNode value ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Tried to replace a value in the empty list"" );
		 return findElement( false, i ).setHead( value );
	 }
	 public boolean contains( RDFNode value ) {
		 return indexOf( value, 0 ) >= 0;
	 }
	 public int indexOf( RDFNode value ) {
		 return indexOf( value, 0 );
	 }
	 public int indexOf( RDFNode value, int start ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 Resource l = findElement( false, start );
		 int index = start;
		 Property head = listFirst();
		 Property tail = listRest();
		 Resource nil = listNil();
		 boolean found = l.hasProperty( head, value );
		 while (!found && !l.equals( nil )) {
			 l = l.getRequiredProperty( tail ).getResource();
			 index++;
			 found = l.hasProperty( head, value );
		 }
		 return found ? index : -1;
	 }
	 public RDFList append( Iterator<? extends RDFNode> nodes ) {
		 return append( copy( nodes) );
	 }
	 public RDFList append( RDFList list ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 if (isEmpty()) {
			 return list;
		 }
		 else {
			 RDFList copy = copy( iterator() );
			 copy.concatenate( list );
			 return copy;
		 }
	 }
	 public void concatenate( RDFList list ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 if (isEmpty()) {
			 throw new EmptyListUpdateException( ""Tried to concatenate onto the empty list"" );
		 }
		 else {
			 findElement( true, 0 ).setTail( list );
		 }
	 }
	 public void concatenate( Iterator<? extends RDFNode> nodes ) {
		 concatenate( copy( nodes ) );
	 }
	 public RDFList copy() {
		 if (s_checkValid) {
			 checkValid();
		 }
		 return copy( iterator() );
	 }
	 public void apply( ApplyFn fn ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 for (Iterator<RDFNode> i = iterator();
		 i.hasNext();
		 ) {
			 fn.apply( i.next() );
		 }
	 }
	 public Object reduce( ReduceFn fn, Object initial ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 Object acc = initial;
		 for (Iterator<RDFNode> i = iterator();
		 i.hasNext();
		 ) {
			 acc = fn.reduce( i.next(), acc );
		 }
		 return acc;
	 }
	 public <T> ExtendedIterator<T> mapWith( Function<RDFNode, T> fn ) {
		 return iterator().mapWith( fn );
	 }
	 public RDFList removeHead() {
		 if (s_checkValid) {
			 checkValid();
		 }
		 checkNotNil( ""Attempted to delete the head of a nil list"" );
		 RDFList tail = getTail();
		 removeProperties();
		 return tail;
	 }
	 public RDFList remove( RDFNode val ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 RDFList prev = null;
		 RDFList cell = this;
		 boolean searching = true;
		 while (searching && !cell.isEmpty()) {
			 if (cell.getHead().equals( val )) {
				 RDFList tail = cell.getTail();
				 if (prev != null) {
					 prev.setTail( tail );
				 }
				 cell.removeProperties();
				 return (prev == null) ? tail : this;
			 }
			 else {
				 prev = cell;
				 cell = cell.getTail();
			 }
		 }
		 return this;
	 }
	 public void removeList() {
		 for ( Statement statement : collectStatements() ) {
			 statement.remove();
		 }
	 }
	 public Set<Statement> collectStatements() {
		 Set<Statement> stmts = new HashSet<>();
		 RDFList l = this;
		 do {
			 for (Iterator<Statement> i = l.listProperties();
			 i.hasNext();
			 ) {
				 stmts.add( i.next() );
			 }
			 l = l.getTail();
		 }
		 while (!l.isEmpty());
		 return stmts;
	 }
	 public ExtendedIterator<RDFNode> iterator() {
		 return new RDFListIterator( this );
	 }
	 public List<RDFNode> asJavaList() {
		 List<RDFNode> l = new ArrayList<>();
		 for (Iterator<RDFNode> i = iterator();
		 i.hasNext();
		 ) {
			 l.add( i.next() );
		 }
		 return l;
	 }
	 public boolean sameListAs( RDFList list ) {
		 if (s_checkValid) {
			 checkValid();
		 }
		 Resource r0 = this;
		 Resource r1 = list;
		 Property head = listFirst();
		 Property tail = listRest();
		 Resource nil = listNil();
		 while (!(r0.equals( nil ) || r1.equals( nil ))) {
			 RDFNode n0 = r0.getRequiredProperty( head ).getObject();
			 RDFNode n1 = r1.getRequiredProperty( head ).getObject();
			 if (n0 == null || !n0.equals( n1 )) {
				 return false;
			 }
			 else {
				 r0 = r0.getRequiredProperty( tail ).getResource();
				 r1 = r1.getRequiredProperty( tail ).getResource();
			 }
		 }
		 return r0.equals( nil ) && r1.equals( nil );
	 }
	 public boolean getStrict() {
		 return s_checkValid;
	 }
	 public void setStrict( boolean strict ) {
		 s_checkValid = strict;
	 }
	 public boolean isValid() {
		 m_errorMsg = null;
		 try {
			 checkValid();
		 }
		 catch (InvalidListException e) {
			 m_errorMsg = e.getMessage();
		 }
		 return (m_errorMsg == null);
	 }
	 public String getValidityErrorMessage() {
		 return m_errorMsg;
	 }
	 public Resource newListCell( RDFNode value, Resource tail ) {
		 Resource cell = getModel().createResource();
		 cell.addProperty( listFirst(), value );
		 cell.addProperty( listRest(), tail );
		 return cell;
	 }
	 protected void checkValid() {
		 if (!equals( listNil() )) {
			 checkValidProperty( listFirst(), null );
			 checkValidProperty( listRest(), null );
		 }
	 }
	 private void checkValidProperty( Property p, RDFNode expected ) {
		 int count = 0;
		 for (StmtIterator j = getModel().listStatements( this, p, expected );
		 j.hasNext();
		 j.next()) {
			 count++;
		 }
		 if (count == 0) {
			 if (log.isDebugEnabled()) {
				 log.debug( ""Failed validity check on "" + toString() );
				 for (StmtIterator i = listProperties();
				 i.hasNext();
				 ) {
					 log.debug( "" this => "" + i.next() );
				 }
				 for (StmtIterator i = getModel().listStatements( null, null, this );
				 i.hasNext();
				 ) {
					 log.debug( "" => this "" + i.next() );
				 }
			 }
			 throw new InvalidListException( ""List node "" + toString() + "" is not valid: it should have property "" + p.toString() + (expected == null ? """" : ( "" with value "" + expected )) );
		 }
		 else if (count > 1) {
			 throw new InvalidListException( ""List node "" + toString() + "" is not valid: it has more than one value for "" + p.toString() );
		 }
	 }
	 protected void checkNotNil( String msg ) {
		 if (isEmpty()) {
			 throw new EmptyListException( msg );
		 }
	 }
	 protected RDFList findElement( boolean last, int index ) {
		 Property tail = listRest();
		 Resource nil = listNil();
		 Resource l = this;
		 int i = index;
		 boolean found = (last && l.hasProperty( tail, nil )) || (!last && (i == 0));
		 while (!found && !l.equals( nil )) {
			 l = l.getRequiredProperty( tail ).getResource();
			 found = (last && l.hasProperty( tail, nil )) || (!last && (--i == 0));
		 }
		 if (!found) {
			 if (!last) {
				 throw new ListIndexException( ""Tried to access element "" + index + "" that is beyond the length of the list"" );
			 }
			 else {
				 throw new InvalidListException( ""Could not find last element of list (suggests list is not valid)"" );
			 }
		 }
		 else {
			 return l.as( listAbstractionClass() );
		 }
	 }
	 protected RDFList copy( Iterator<? extends RDFNode> i ) {
		 Resource list = null;
		 Resource start = null;
		 Property head = listFirst();
		 Property tail = listRest();
		 Resource cellType = listType();
		 if (i.hasNext()) {
			 while (i.hasNext()){
				 Resource cell = getModel().createResource( cellType );
				 cell.addProperty( head, i.next() );
				 if (list != null) {
					 list.addProperty( tail, cell );
				 }
				 else {
					 start = cell;
				 }
				 list = cell;
			 }
			 list.addProperty( tail, listNil() );
		 }
		 else {
			 start = getModel().createList();
		 }
		 return start.as( listAbstractionClass() );
	 }
	 protected static Resource setTailAux( Resource root, Resource tail, Property pTail ) {
		 Statement current = root.getRequiredProperty( pTail );
		 Resource oldTail = current.getResource();
		 current.remove();
		 root.addProperty( pTail, tail );
		 return oldTail;
	 }
	 protected class RDFListIterator extends NiceIterator<RDFNode> {
		 protected RDFList m_head;
		 protected RDFList m_seen = null;
		 protected RDFListIterator( RDFList head ) {
			 m_head = head;
		 }
		 public boolean hasNext() {
			 return !m_head.isEmpty();
		 }
		 public RDFNode next() {
			 m_seen = m_head;
			 m_head = m_head.getTail();
			 return m_seen.getHead();
		 }
		 public void remove() {
			 if (m_seen == null) {
				 throw new IllegalStateException( ""Illegal remove from list operator"" );
			 }
			 ((Resource) m_seen).removeProperties();
			 m_seen = null;
		 }
	 }
}",1,0,0,0
"public void log(final int level, final Object obj1, final Object obj2, final Object obj3, final Object obj4, final Object obj5, final Object obj6, final Object obj7, final Object obj8, final Throwable exception);",0,0,0,1
"public void setTab(AddAsisRemove attr) {
	 filter.setTab(FixCrLfFilter.AddAsisRemove.newInstance(attr.getValue()));
 }",0,0,0,0
"public abstract class ScriptableObject implements Scriptable, Serializable, DebuggableObject{
	 public static final int EMPTY = 0x00;
	 public static final int READONLY = 0x01;
	 public static final int DONTENUM = 0x02;
	 public static final int PERMANENT = 0x04;
	 static void checkValidAttributes(int attributes) {
		 final int mask = READONLY | DONTENUM | PERMANENT;
		 if ((attributes & ~mask) != 0) {
			 throw new IllegalArgumentException(String.valueOf(attributes));
		 }
	 }
	 public ScriptableObject() {
	 }
	 public ScriptableObject(Scriptable scope, Scriptable prototype) {
		 if (scope == null) throw new IllegalArgumentException();
		 parentScopeObject = scope;
		 prototypeObject = prototype;
	 }
	 public abstract String getClassName();
	 public boolean has(String name, Scriptable start) {
		 return null != getNamedSlot(name);
	 }
	 public boolean has(int index, Scriptable start) {
		 return null != getSlot(null, index);
	 }
	 public Object get(String name, Scriptable start) {
		 Slot slot = getNamedSlot(name);
		 if (slot == null) {
			 return Scriptable.NOT_FOUND;
		 }
		 if (slot instanceof GetterSlot) {
			 GetterSlot gslot = (GetterSlot)slot;
			 if (gslot.getter != null) {
				 return getByGetter(gslot, start);
			 }
		 }
		 return slot.value;
	 }
	 public Object get(int index, Scriptable start) {
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 return Scriptable.NOT_FOUND;
		 }
		 return slot.value;
	 }
	 public void put(String name, Scriptable start, Object value) {
		 Slot slot = lastAccess;
		 if (name != slot.stringKey || slot.wasDeleted != 0) {
			 int hash = name.hashCode();
			 slot = getSlot(name, hash);
			 if (slot == null) {
				 if (start != this) {
					 start.put(name, start, value);
					 return;
				 }
				 slot = addSlot(name, hash, null);
			 }
		 }
		 if (start == this && isSealed()) {
			 throw Context.reportRuntimeError1(""msg.modify.sealed"", name);
		 }
		 if ((slot.attributes & ScriptableObject.READONLY) != 0) {
			 return;
		 }
		 if (slot instanceof GetterSlot) {
			 GetterSlot gslot = (GetterSlot)slot;
			 if (gslot.setter != null) {
				 setBySetter(gslot, start, value);
			 }
			 return;
		 }
		 if (this == start) {
			 slot.value = value;
		 }
		 else {
			 start.put(name, start, value);
		 }
	 }
	 public void put(int index, Scriptable start, Object value) {
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 if (start != this) {
				 start.put(index, start, value);
				 return;
			 }
			 slot = addSlot(null, index, null);
		 }
		 if (start == this && isSealed()) {
			 throw Context.reportRuntimeError1(""msg.modify.sealed"", Integer.toString(index));
		 }
		 if ((slot.attributes & ScriptableObject.READONLY) != 0) {
			 return;
		 }
		 if (this == start) {
			 slot.value = value;
		 }
		 else {
			 start.put(index, start, value);
		 }
	 }
	 public void delete(String name) {
		 removeSlot(name, name.hashCode());
	 }
	 public void delete(int index) {
		 removeSlot(null, index);
	 }
	 public final int getAttributes(String name, Scriptable start) {
		 return getAttributes(name);
	 }
	 public final int getAttributes(int index, Scriptable start) {
		 return getAttributes(index);
	 }
	 public final void setAttributes(String name, Scriptable start, int attributes) {
		 setAttributes(name, attributes);
	 }
	 public void setAttributes(int index, Scriptable start, int attributes) {
		 setAttributes(index, attributes);
	 }
	 public int getAttributes(String name) {
		 Slot slot = getNamedSlot(name);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", name);
		 }
		 return slot.attributes;
	 }
	 public int getAttributes(int index) {
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", String.valueOf(index));
		 }
		 return slot.attributes;
	 }
	 public void setAttributes(String name, int attributes) {
		 checkValidAttributes(attributes);
		 Slot slot = getNamedSlot(name);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", name);
		 }
		 slot.attributes = (short) attributes;
	 }
	 public void setAttributes(int index, int attributes) {
		 checkValidAttributes(attributes);
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", String.valueOf(index));
		 }
		 slot.attributes = (short) attributes;
	 }
	 public Scriptable getPrototype() {
		 return prototypeObject;
	 }
	 public void setPrototype(Scriptable m) {
		 prototypeObject = m;
	 }
	 public Scriptable getParentScope() {
		 return parentScopeObject;
	 }
	 public void setParentScope(Scriptable m) {
		 parentScopeObject = m;
	 }
	 public Object[] getIds() {
		 return getIds(false);
	 }
	 public Object[] getAllIds() {
		 return getIds(true);
	 }
	 public Object getDefaultValue(Class typeHint) {
		 Context cx = null;
		 for (int i=0;
		 i < 2;
		 i++) {
			 boolean tryToString;
			 if (typeHint == ScriptRuntime.StringClass) {
				 tryToString = (i == 0);
			 }
			 else {
				 tryToString = (i == 1);
			 }
			 String methodName;
			 Object[] args;
			 if (tryToString) {
				 methodName = ""toString"";
				 args = ScriptRuntime.emptyArgs;
			 }
			 else {
				 methodName = ""valueOf"";
				 args = new Object[1];
				 String hint;
				 if (typeHint == null) {
					 hint = ""undefined"";
				 }
				 else if (typeHint == ScriptRuntime.StringClass) {
					 hint = ""string"";
				 }
				 else if (typeHint == ScriptRuntime.ScriptableClass) {
					 hint = ""object"";
				 }
				 else if (typeHint == ScriptRuntime.FunctionClass) {
					 hint = ""function"";
				 }
				 else if (typeHint == ScriptRuntime.BooleanClass || typeHint == Boolean.TYPE) {
					 hint = ""boolean"";
				 }
				 else if (typeHint == ScriptRuntime.NumberClass || typeHint == ScriptRuntime.ByteClass || typeHint == Byte.TYPE || typeHint == ScriptRuntime.ShortClass || typeHint == Short.TYPE || typeHint == ScriptRuntime.IntegerClass || typeHint == Integer.TYPE || typeHint == ScriptRuntime.FloatClass || typeHint == Float.TYPE || typeHint == ScriptRuntime.DoubleClass || typeHint == Double.TYPE) {
					 hint = ""number"";
				 }
				 else {
					 throw Context.reportRuntimeError1( ""msg.invalid.type"", typeHint.toString());
				 }
				 args[0] = hint;
			 }
			 Object v = getProperty(this, methodName);
			 if (!(v instanceof Function)) continue;
			 Function fun = (Function) v;
			 if (cx == null) cx = Context.getContext();
			 v = fun.call(cx, fun.getParentScope(), this, args);
			 if (v != null) {
				 if (!(v instanceof Scriptable)) {
					 return v;
				 }
				 if (typeHint == ScriptRuntime.ScriptableClass || typeHint == ScriptRuntime.FunctionClass) {
					 return v;
				 }
				 if (tryToString && v instanceof Wrapper) {
					 Object u = ((Wrapper)v).unwrap();
					 if (u instanceof String) return u;
				 }
			 }
		 }
		 String arg = (typeHint == null) ? ""undefined"" : typeHint.getName();
		 throw ScriptRuntime.typeError1(""msg.default.value"", arg);
	 }
	 public boolean hasInstance(Scriptable instance) {
		 return ScriptRuntime.jsDelegatesTo(instance, this);
	 }
	 protected Object equivalentValues(Object value) {
		 return (this == value) ? Boolean.TRUE : Scriptable.NOT_FOUND;
	 }
	 public static void defineClass(Scriptable scope, Class clazz) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 defineClass(scope, clazz, false, false);
	 }
	 public static void defineClass(Scriptable scope, Class clazz, boolean sealed) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 defineClass(scope, clazz, sealed, false);
	 }
	 public static String defineClass(Scriptable scope, Class clazz, boolean sealed, boolean mapInheritance) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 for (int i=0;
		 i < methods.length;
		 i++) {
			 Method method = methods[i];
			 if (!method.getName().equals(""init"")) continue;
			 Class[] parmTypes = method.getParameterTypes();
			 if (parmTypes.length == 3 && parmTypes[0] == ScriptRuntime.ContextClass && parmTypes[1] == ScriptRuntime.ScriptableClass && parmTypes[2] == Boolean.TYPE && Modifier.isStatic(method.getModifiers())) {
				 Object args[] = {
				 Context.getContext(), scope, sealed ? Boolean.TRUE : Boolean.FALSE }
				;
				 method.invoke(null, args);
				 return null;
			 }
			 if (parmTypes.length == 1 && parmTypes[0] == ScriptRuntime.ScriptableClass && Modifier.isStatic(method.getModifiers())) {
				 Object args[] = {
				 scope }
				;
				 method.invoke(null, args);
				 return null;
			 }
		 }
		 Constructor[] ctors = clazz.getConstructors();
		 Constructor protoCtor = null;
		 for (int i=0;
		 i < ctors.length;
		 i++) {
			 if (ctors[i].getParameterTypes().length == 0) {
				 protoCtor = ctors[i];
				 break;
			 }
		 }
		 if (protoCtor == null) {
			 throw Context.reportRuntimeError1( ""msg.zero.arg.ctor"", clazz.getName());
		 }
		 Scriptable proto = (Scriptable) protoCtor.newInstance(ScriptRuntime.emptyArgs);
		 String className = proto.getClassName();
		 Scriptable superProto = null;
		 if (mapInheritance) {
			 Class superClass = clazz.getSuperclass();
			 if (ScriptRuntime.ScriptableClass.isAssignableFrom(superClass)) {
				 String name = ScriptableObject.defineClass(scope, superClass, sealed, mapInheritance);
				 if (name != null) {
					 superProto = ScriptableObject.getClassPrototype(scope, name);
				 }
			 }
		 }
		 if (superProto == null) {
			 superProto = ScriptableObject.getObjectPrototype(scope);
		 }
		 proto.setPrototype(superProto);
		 final String functionPrefix = ""jsFunction_"";
		 final String staticFunctionPrefix = ""jsStaticFunction_"";
		 final String getterPrefix = ""jsGet_"";
		 final String setterPrefix = ""jsSet_"";
		 final String ctorName = ""jsConstructor"";
		 Member ctorMember = FunctionObject.findSingleMethod(methods, ctorName);
		 if (ctorMember == null) {
			 if (ctors.length == 1) {
				 ctorMember = ctors[0];
			 }
			 else if (ctors.length == 2) {
				 if (ctors[0].getParameterTypes().length == 0) ctorMember = ctors[1];
				 else if (ctors[1].getParameterTypes().length == 0) ctorMember = ctors[0];
			 }
			 if (ctorMember == null) {
				 throw Context.reportRuntimeError1( ""msg.ctor.multiple.parms"", clazz.getName());
			 }
		 }
		 FunctionObject ctor = new FunctionObject(className, ctorMember, scope);
		 if (ctor.isVarArgsMethod()) {
			 throw Context.reportRuntimeError1 (""msg.varargs.ctor"", ctorMember.getName());
		 }
		 ctor.addAsConstructor(scope, proto);
		 Method finishInit = null;
		 for (int i=0;
		 i < methods.length;
		 i++) {
			 if (methods[i] == ctorMember) {
				 continue;
			 }
			 String name = methods[i].getName();
			 if (name.equals(""finishInit"")) {
				 Class[] parmTypes = methods[i].getParameterTypes();
				 if (parmTypes.length == 3 && parmTypes[0] == ScriptRuntime.ScriptableClass && parmTypes[1] == FunctionObject.class && parmTypes[2] == ScriptRuntime.ScriptableClass && Modifier.isStatic(methods[i].getModifiers())) {
					 finishInit = methods[i];
					 continue;
				 }
			 }
			 if (name.indexOf('$') != -1) continue;
			 if (name.equals(ctorName)) continue;
			 String prefix = null;
			 if (name.startsWith(functionPrefix)) {
				 prefix = functionPrefix;
			 }
			 else if (name.startsWith(staticFunctionPrefix)) {
				 prefix = staticFunctionPrefix;
				 if (!Modifier.isStatic(methods[i].getModifiers())) {
					 throw Context.reportRuntimeError( ""jsStaticFunction must be used with static method."");
				 }
			 }
			 else if (name.startsWith(getterPrefix)) {
				 prefix = getterPrefix;
			 }
			 else if (name.startsWith(setterPrefix)) {
				 prefix = setterPrefix;
			 }
			 else {
				 continue;
			 }
			 name = name.substring(prefix.length());
			 if (prefix == setterPrefix) continue;
			 if (prefix == getterPrefix) {
				 if (!(proto instanceof ScriptableObject)) {
					 throw Context.reportRuntimeError2( ""msg.extend.scriptable"", proto.getClass().toString(), name);
				 }
				 Method setter = FunctionObject.findSingleMethod( methods, setterPrefix + name);
				 int attr = ScriptableObject.PERMANENT | ScriptableObject.DONTENUM | (setter != null ? 0 : ScriptableObject.READONLY);
				 ((ScriptableObject) proto).defineProperty(name, null, methods[i], setter, attr);
				 continue;
			 }
			 FunctionObject f = new FunctionObject(name, methods[i], proto);
			 if (f.isVarArgsConstructor()) {
				 throw Context.reportRuntimeError1 (""msg.varargs.fun"", ctorMember.getName());
			 }
			 Scriptable dest = prefix == staticFunctionPrefix ? ctor : proto;
			 defineProperty(dest, name, f, DONTENUM);
			 if (sealed) {
				 f.sealObject();
			 }
		 }
		 if (finishInit != null) {
			 Object[] finishArgs = {
			 scope, ctor, proto }
			;
			 finishInit.invoke(null, finishArgs);
		 }
		 if (sealed) {
			 ctor.sealObject();
			 if (proto instanceof ScriptableObject) {
				 ((ScriptableObject) proto).sealObject();
			 }
		 }
		 return className;
	 }
	 public void defineProperty(String propertyName, Object value, int attributes) {
		 put(propertyName, this, value);
		 setAttributes(propertyName, attributes);
	 }
	 public static void defineProperty(Scriptable destination, String propertyName, Object value, int attributes) {
		 if (!(destination instanceof ScriptableObject)) {
			 destination.put(propertyName, destination, value);
			 return;
		 }
		 ScriptableObject so = (ScriptableObject)destination;
		 so.defineProperty(propertyName, value, attributes);
	 }
	 public void defineProperty(String propertyName, Class clazz, int attributes) {
		 int length = propertyName.length();
		 if (length == 0) throw new IllegalArgumentException();
		 char[] buf = new char[3 + length];
		 propertyName.getChars(0, length, buf, 3);
		 buf[3] = Character.toUpperCase(buf[3]);
		 buf[0] = 'g';
		 buf[1] = 'e';
		 buf[2] = 't';
		 String getterName = new String(buf);
		 buf[0] = 's';
		 String setterName = new String(buf);
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 Method getter = FunctionObject.findSingleMethod(methods, getterName);
		 Method setter = FunctionObject.findSingleMethod(methods, setterName);
		 if (setter == null) attributes |= ScriptableObject.READONLY;
		 defineProperty(propertyName, null, getter, setter == null ? null : setter, attributes);
	 }
	 public void defineProperty(String propertyName, Object delegateTo, Method getter, Method setter, int attributes) {
		 if (delegateTo == null && (Modifier.isStatic(getter.getModifiers()))) delegateTo = HAS_STATIC_ACCESSORS;
		 Class[] parmTypes = getter.getParameterTypes();
		 if (parmTypes.length != 0) {
			 if (parmTypes.length != 1 || parmTypes[0] != ScriptRuntime.ScriptableObjectClass) {
				 throw Context.reportRuntimeError1( ""msg.bad.getter.parms"", getter.toString());
			 }
		 }
		 else if (delegateTo != null) {
			 throw Context.reportRuntimeError1( ""msg.obj.getter.parms"", getter.toString());
		 }
		 if (setter != null) {
			 if ((delegateTo == HAS_STATIC_ACCESSORS) != (Modifier.isStatic(setter.getModifiers()))) {
				 throw Context.reportRuntimeError0(""msg.getter.static"");
			 }
			 parmTypes = setter.getParameterTypes();
			 if (parmTypes.length == 2) {
				 if (parmTypes[0] != ScriptRuntime.ScriptableObjectClass) {
					 throw Context.reportRuntimeError0(""msg.setter2.parms"");
				 }
				 if (delegateTo == null) {
					 throw Context.reportRuntimeError1( ""msg.setter1.parms"", setter.toString());
				 }
			 }
			 else if (parmTypes.length == 1) {
				 if (delegateTo != null) {
					 throw Context.reportRuntimeError1( ""msg.setter2.expected"", setter.toString());
				 }
			 }
			 else {
				 throw Context.reportRuntimeError0(""msg.setter.parms"");
			 }
			 Class setterType = parmTypes[parmTypes.length - 1];
			 int setterTypeTag = FunctionObject.getTypeTag(setterType);
			 if (setterTypeTag == FunctionObject.JAVA_UNSUPPORTED_TYPE) {
				 throw Context.reportRuntimeError2( ""msg.setter2.expected"", setterType.getName(), setter.toString());
			 }
		 }
		 GetterSlot gslot = new GetterSlot();
		 gslot.delegateTo = delegateTo;
		 gslot.getter = new MemberBox(getter);
		 if (setter != null) {
			 gslot.setter = new MemberBox(setter);
		 }
		 gslot.attributes = (short) attributes;
		 Slot inserted = addSlot(propertyName, propertyName.hashCode(), gslot);
		 if (inserted != gslot) {
			 throw new RuntimeException(""Property already exists"");
		 }
	 }
	 public void defineFunctionProperties(String[] names, Class clazz, int attributes) {
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 for (int i=0;
		 i < names.length;
		 i++) {
			 String name = names[i];
			 Method m = FunctionObject.findSingleMethod(methods, name);
			 if (m == null) {
				 throw Context.reportRuntimeError2( ""msg.method.not.found"", name, clazz.getName());
			 }
			 FunctionObject f = new FunctionObject(name, m, this);
			 defineProperty(name, f, attributes);
		 }
	 }
	 public static Scriptable getObjectPrototype(Scriptable scope) {
		 return getClassPrototype(scope, ""Object"");
	 }
	 public static Scriptable getFunctionPrototype(Scriptable scope) {
		 return getClassPrototype(scope, ""Function"");
	 }
	 public static Scriptable getClassPrototype(Scriptable scope, String className) {
		 scope = getTopLevelScope(scope);
		 Object ctor = getProperty(scope, className);
		 Object proto;
		 if (ctor instanceof BaseFunction) {
			 proto = ((BaseFunction)ctor).getPrototypeProperty();
		 }
		 else if (ctor instanceof Scriptable) {
			 Scriptable ctorObj = (Scriptable)ctor;
			 proto = ctorObj.get(""prototype"", ctorObj);
		 }
		 else {
			 return null;
		 }
		 if (proto instanceof Scriptable) {
			 return (Scriptable)proto;
		 }
		 return null;
	 }
	 public static Scriptable getTopLevelScope(Scriptable obj) {
		 for (;
		;
		) {
			 Scriptable parent = obj.getParentScope();
			 if (parent == null) {
				 return obj;
			 }
			 obj = parent;
		 }
	 }
	 public synchronized void sealObject() {
		 if (count >= 0) {
			 count = -1 - count;
		 }
	 }
	 public final boolean isSealed() {
		 return count < 0;
	 }
	 public static Object getProperty(Scriptable obj, String name) {
		 Scriptable start = obj;
		 Object result;
		 do {
			 result = obj.get(name, start);
			 if (result != Scriptable.NOT_FOUND) break;
			 obj = obj.getPrototype();
		 }
		 while (obj != null);
		 return result;
	 }
	 public static Object getProperty(Scriptable obj, int index) {
		 Scriptable start = obj;
		 Object result;
		 do {
			 result = obj.get(index, start);
			 if (result != Scriptable.NOT_FOUND) break;
			 obj = obj.getPrototype();
		 }
		 while (obj != null);
		 return result;
	 }
	 public static boolean hasProperty(Scriptable obj, String name) {
		 return null != getBase(obj, name);
	 }
	 public static boolean hasProperty(Scriptable obj, int index) {
		 return null != getBase(obj, index);
	 }
	 public static void putProperty(Scriptable obj, String name, Object value) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) base = obj;
		 base.put(name, obj, value);
	 }
	 public static void putProperty(Scriptable obj, int index, Object value) {
		 Scriptable base = getBase(obj, index);
		 if (base == null) base = obj;
		 base.put(index, obj, value);
	 }
	 public static boolean deleteProperty(Scriptable obj, String name) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) return true;
		 base.delete(name);
		 return !base.has(name, obj);
	 }
	 public static boolean deleteProperty(Scriptable obj, int index) {
		 Scriptable base = getBase(obj, index);
		 if (base == null) return true;
		 base.delete(index);
		 return !base.has(index, obj);
	 }
	 public static Object[] getPropertyIds(Scriptable obj) {
		 if (obj == null) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] result = obj.getIds();
		 ObjToIntMap map = null;
		 for (;
		;
		) {
			 obj = obj.getPrototype();
			 if (obj == null) {
				 break;
			 }
			 Object[] ids = obj.getIds();
			 if (ids.length == 0) {
				 continue;
			 }
			 if (map == null) {
				 if (result.length == 0) {
					 result = ids;
					 continue;
				 }
				 map = new ObjToIntMap(result.length + ids.length);
				 for (int i = 0;
				 i != result.length;
				 ++i) {
					 map.intern(result[i]);
				 }
				 result = null;
			 }
			 for (int i = 0;
			 i != ids.length;
			 ++i) {
				 map.intern(ids[i]);
			 }
		 }
		 if (map != null) {
			 result = map.getKeys();
		 }
		 return result;
	 }
	 public static Object callMethod(Scriptable obj, String methodName, Object[] args) {
		 return callMethod(null, obj, methodName, args);
	 }
	 public static Object callMethod(Context cx, Scriptable obj, String methodName, Object[] args) {
		 Object funObj = getProperty(obj, methodName);
		 if (!(funObj instanceof Function)) {
			 throw ScriptRuntime.notFunctionError(obj, methodName);
		 }
		 Function fun = (Function)funObj;
		 Scriptable scope = ScriptableObject.getTopLevelScope(obj);
		 if (cx != null) {
			 return fun.call(cx, scope, obj, args);
		 }
		 else {
			 return Context.call(null, fun, scope, obj, args);
		 }
	 }
	 private static Scriptable getBase(Scriptable obj, String name) {
		 do {
			 if (obj.has(name, obj)) break;
			 obj = obj.getPrototype();
		 }
		 while(obj != null);
		 return obj;
	 }
	 private static Scriptable getBase(Scriptable obj, int index) {
		 do {
			 if (obj.has(index, obj)) break;
			 obj = obj.getPrototype();
		 }
		 while(obj != null);
		 return obj;
	 }
	 public final Object getAssociatedValue(Object key) {
		 Hashtable h = associatedValues;
		 if (h == null) return null;
		 return h.get(key);
	 }
	 public static Object getTopScopeValue(Scriptable scope, Object key) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 for (;
		;
		) {
			 if (scope instanceof ScriptableObject) {
				 ScriptableObject so = (ScriptableObject)scope;
				 Object value = so.getAssociatedValue(key);
				 if (value != null) {
					 return value;
				 }
			 }
			 scope = scope.getPrototype();
			 if (scope == null) {
				 return null;
			 }
		 }
	 }
	 public final Object associateValue(Object key, Object value) {
		 if (value == null) throw new IllegalArgumentException();
		 Hashtable h = associatedValues;
		 if (h == null) {
			 synchronized (this) {
				 h = associatedValues;
				 if (h == null) {
					 h = new Hashtable();
					 associatedValues = h;
				 }
			 }
		 }
		 return Kit.initHash(h, key, value);
	 }
	 private Object getByGetter(GetterSlot slot, Scriptable start) {
		 Object getterThis;
		 Object[] args;
		 if (slot.delegateTo == null) {
			 if (start != this) {
				 Class clazz = slot.getter.getDeclaringClass();
				 while (!clazz.isInstance(start)) {
					 start = start.getPrototype();
					 if (start == this) {
						 break;
					 }
					 if (start == null) {
						 start = this;
						 break;
					 }
				 }
			 }
			 getterThis = start;
			 args = ScriptRuntime.emptyArgs;
		 }
		 else {
			 getterThis = slot.delegateTo;
			 args = new Object[] {
			 this }
			;
		 }
		 return slot.getter.invoke(getterThis, args);
	 }
	 private void setBySetter(GetterSlot slot, Scriptable start, Object value) {
		 if (start != this) {
			 if (slot.delegateTo != null || !slot.setter.getDeclaringClass().isInstance(start)) {
				 start.put(slot.stringKey, start, value);
				 return;
			 }
		 }
		 Object setterThis;
		 Object[] args;
		 Object setterResult;
		 Context cx = Context.getContext();
		 Class pTypes[] = slot.setter.argTypes;
		 Class desired = pTypes[pTypes.length - 1];
		 int tag = FunctionObject.getTypeTag(desired);
		 Object actualArg = FunctionObject.convertArg(cx, start, value, tag);
		 if (slot.delegateTo == null) {
			 setterThis = start;
			 args = new Object[] {
			 actualArg }
			;
		 }
		 else {
			 if (start != this) Kit.codeBug();
			 setterThis = slot.delegateTo;
			 args = new Object[] {
			 this, actualArg }
			;
		 }
		 if (((ScriptableObject)start).isSealed()) {
			 throw Context.reportRuntimeError1(""msg.modify.sealed"", slot.stringKey);
		 }
		 setterResult = slot.setter.invoke(setterThis, args);
		 if (slot.setter.method().getReturnType() != Void.TYPE) {
			 Slot replacement = new Slot();
			 replacement.intKey = slot.intKey;
			 replacement.stringKey = slot.stringKey;
			 replacement.attributes = slot.attributes;
			 replacement.value = setterResult;
			 synchronized (this) {
				 int i = getSlotPosition(slots, slot.stringKey, slot.intKey);
				 if (i >= 0 && slots[i] == slot) {
					 slots[i] = replacement;
					 lastAccess = replacement;
				 }
			 }
		 }
	 }
	 private Slot getNamedSlot(String name) {
		 Slot slot = lastAccess;
		 if (name == slot.stringKey && slot.wasDeleted == 0) {
			 return slot;
		 }
		 int hash = name.hashCode();
		 Slot[] slots = this.slots;
		 int i = getSlotPosition(slots, name, hash);
		 if (i < 0) {
			 return null;
		 }
		 slot = slots[i];
		 slot.stringKey = name;
		 lastAccess = slot;
		 return slot;
	 }
	 private Slot getSlot(String id, int index) {
		 Slot[] slots = this.slots;
		 int i = getSlotPosition(slots, id, index);
		 return (i < 0) ? null : slots[i];
	 }
	 private static int getSlotPosition(Slot[] slots, String id, int index) {
		 if (slots != null) {
			 int start = (index & 0x7fffffff) % slots.length;
			 int i = start;
			 do {
				 Slot slot = slots[i];
				 if (slot == null) break;
				 if (slot != REMOVED && slot.intKey == index && (slot.stringKey == id || (id != null && id.equals(slot.stringKey)))) {
					 return i;
				 }
				 if (++i == slots.length) i = 0;
			 }
			 while (i != start);
		 }
		 return -1;
	 }
	 private synchronized Slot addSlot(String id, int index, Slot newSlot) {
		 if (isSealed()) {
			 String str = (id != null) ? id : Integer.toString(index);
			 throw Context.reportRuntimeError1(""msg.add.sealed"", str);
		 }
		 if (slots == null) {
			 slots = new Slot[5];
		 }
		 return addSlotImpl(id, index, newSlot);
	 }
	 private Slot addSlotImpl(String id, int index, Slot newSlot) {
		 int start = (index & 0x7fffffff) % slots.length;
		 int i = start;
		 for (;
		;
		) {
			 Slot slot = slots[i];
			 if (slot == null || slot == REMOVED) {
				 if ((4 * (count + 1)) > (3 * slots.length)) {
					 grow();
					 return addSlotImpl(id, index, newSlot);
				 }
				 slot = (newSlot == null) ? new Slot() : newSlot;
				 slot.stringKey = id;
				 slot.intKey = index;
				 slots[i] = slot;
				 count++;
				 return slot;
			 }
			 if (slot.intKey == index && (slot.stringKey == id || (id != null && id.equals(slot.stringKey)))) {
				 return slot;
			 }
			 if (++i == slots.length) i = 0;
			 if (i == start) {
				 throw new IllegalStateException();
			 }
		 }
	 }
	 private synchronized void removeSlot(String name, int index) {
		 if (isSealed()) {
			 String str = (name != null) ? name : Integer.toString(index);
			 throw Context.reportRuntimeError1(""msg.remove.sealed"", str);
		 }
		 int i = getSlotPosition(slots, name, index);
		 if (i >= 0) {
			 Slot slot = slots[i];
			 if ((slot.attributes & PERMANENT) == 0) {
				 slot.wasDeleted = (byte)1;
				 if (slot == lastAccess) {
					 lastAccess = REMOVED;
				 }
				 count--;
				 if (count != 0) {
					 slots[i] = REMOVED;
				 }
				 else {
					 slots[i] = null;
				 }
			 }
		 }
	 }
	 private void grow() {
		 Slot[] newSlots = new Slot[slots.length*2 + 1];
		 for (int j=slots.length-1;
		 j >= 0 ;
		 j--) {
			 Slot slot = slots[j];
			 if (slot == null || slot == REMOVED) continue;
			 int k = (slot.intKey & 0x7fffffff) % newSlots.length;
			 while (newSlots[k] != null) if (++k == newSlots.length) k = 0;
			 newSlots[k] = slot;
		 }
		 slots = newSlots;
	 }
	 Object[] getIds(boolean getAll) {
		 Slot[] s = slots;
		 Object[] a = ScriptRuntime.emptyArgs;
		 if (s == null) return a;
		 int c = 0;
		 for (int i=0;
		 i < s.length;
		 i++) {
			 Slot slot = s[i];
			 if (slot == null || slot == REMOVED) continue;
			 if (getAll || (slot.attributes & DONTENUM) == 0) {
				 if (c == 0) a = new Object[s.length - i];
				 a[c++] = slot.stringKey != null ? (Object) slot.stringKey : new Integer(slot.intKey);
			 }
		 }
		 if (c == a.length) return a;
		 Object[] result = new Object[c];
		 System.arraycopy(a, 0, result, 0, c);
		 return result;
	 }
	 private synchronized void writeObject(ObjectOutputStream out) throws IOException {
		 out.defaultWriteObject();
		 int N = count;
		 if (N < 0) {
			 N = -1 - count;
		 }
		 Slot[] s = slots;
		 if (s == null) {
			 if (N != 0) Kit.codeBug();
			 out.writeInt(0);
		 }
		 else {
			 out.writeInt(s.length);
			 for (int i = 0;
			 N != 0;
			 ++i) {
				 Slot slot = s[i];
				 if (slot != null && slot != REMOVED) {
					 --N;
					 out.writeObject(slot);
				 }
			 }
		 }
	 }
	 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		 in.defaultReadObject();
		 lastAccess = REMOVED;
		 int capacity = in.readInt();
		 if (capacity != 0) {
			 slots = new Slot[capacity];
			 int N = count;
			 boolean wasSealed = false;
			 if (N < 0) {
				 N = -1 - N;
				 wasSealed = true;
			 }
			 count = 0;
			 for (int i = 0;
			 i != N;
			 ++i) {
				 Slot s = (Slot)in.readObject();
				 addSlotImpl(s.stringKey, s.intKey, s);
			 }
			 if (wasSealed) {
				 count = - 1 - count;
			 }
		 }
	 }
	 private Scriptable prototypeObject;
	 private Scriptable parentScopeObject;
	 private static final Object HAS_STATIC_ACCESSORS = Void.TYPE;
	 private static final Slot REMOVED = new Slot();
	 private transient Slot[] slots;
	 private int count;
	 private transient Slot lastAccess = REMOVED;
	 private transient volatile Hashtable associatedValues;
	 private static class Slot implements Serializable {
		 static final long serialVersionUID = -3539051633409902634L;
		 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
			 in.defaultReadObject();
			 if (stringKey != null) {
				 intKey = stringKey.hashCode();
			 }
		 }
		 int intKey;
		 String stringKey;
		 Object value;
		 short attributes;
		 transient byte wasDeleted;
	 }
	 private static final class GetterSlot extends Slot {
		 static final long serialVersionUID = -4900574849788797588L;
		 Object delegateTo;
		 MemberBox getter;
		 MemberBox setter;
	 }
}",1,0,0,0
"public synchronized void shutdown() throws IOException {
	 shuttingDown = true;
	 close();
	 if (this.server != null) {
		 try {
			 LOG.info(""Shutting down StatusHttpServer"");
			 this.server.stop();
		 }
		 catch (InterruptedException ex) {
			 ex.printStackTrace();
		 }
	 }
 }",0,0,0,0
"public class CrossOriginFilter implements Filter{
	 private static final Logger LOG = Log.getLogger(CrossOriginFilter.class);
	 private static final String ORIGIN_HEADER = ""Origin"";
	 public static final String ACCESS_CONTROL_REQUEST_METHOD_HEADER = ""Access-Control-Request-Method"";
	 public static final String ACCESS_CONTROL_REQUEST_HEADERS_HEADER = ""Access-Control-Request-Headers"";
	 public static final String ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = ""Access-Control-Allow-Origin"";
	 public static final String ACCESS_CONTROL_ALLOW_METHODS_HEADER = ""Access-Control-Allow-Methods"";
	 public static final String ACCESS_CONTROL_ALLOW_HEADERS_HEADER = ""Access-Control-Allow-Headers"";
	 public static final String ACCESS_CONTROL_MAX_AGE_HEADER = ""Access-Control-Max-Age"";
	 public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS_HEADER = ""Access-Control-Allow-Credentials"";
	 public static final String ACCESS_CONTROL_EXPOSE_HEADERS_HEADER = ""Access-Control-Expose-Headers"";
	 public static final String TIMING_ALLOW_ORIGIN_HEADER = ""Timing-Allow-Origin"";
	 public static final String ALLOWED_ORIGINS_PARAM = ""allowedOrigins"";
	 public static final String ALLOWED_TIMING_ORIGINS_PARAM = ""allowedTimingOrigins"";
	 public static final String ALLOWED_METHODS_PARAM = ""allowedMethods"";
	 public static final String ALLOWED_HEADERS_PARAM = ""allowedHeaders"";
	 public static final String PREFLIGHT_MAX_AGE_PARAM = ""preflightMaxAge"";
	 public static final String ALLOW_CREDENTIALS_PARAM = ""allowCredentials"";
	 public static final String EXPOSED_HEADERS_PARAM = ""exposedHeaders"";
	 public static final String OLD_CHAIN_PREFLIGHT_PARAM = ""forwardPreflight"";
	 public static final String CHAIN_PREFLIGHT_PARAM = ""chainPreflight"";
	 private static final String ANY_ORIGIN = ""*"";
	 private static final String DEFAULT_ALLOWED_ORIGINS = ""*"";
	 private static final String DEFAULT_ALLOWED_TIMING_ORIGINS = """";
	 private static final List<String> SIMPLE_HTTP_METHODS = Arrays.asList(""GET"", ""POST"", ""HEAD"");
	 private static final List<String> DEFAULT_ALLOWED_METHODS = Arrays.asList(""GET"", ""POST"", ""HEAD"");
	 private static final List<String> DEFAULT_ALLOWED_HEADERS = Arrays.asList(""X-Requested-With"", ""Content-Type"", ""Accept"", ""Origin"");
	 private boolean anyOriginAllowed;
	 private boolean anyTimingOriginAllowed;
	 private boolean anyHeadersAllowed;
	 private List<String> allowedOrigins = new ArrayList<String>();
	 private List<String> allowedTimingOrigins = new ArrayList<String>();
	 private List<String> allowedMethods = new ArrayList<String>();
	 private List<String> allowedHeaders = new ArrayList<String>();
	 private List<String> exposedHeaders = new ArrayList<String>();
	 private int preflightMaxAge;
	 private boolean allowCredentials;
	 private boolean chainPreflight;
	 public void init(FilterConfig config) throws ServletException {
		 String allowedOriginsConfig = config.getInitParameter(ALLOWED_ORIGINS_PARAM);
		 String allowedTimingOriginsConfig = config.getInitParameter(ALLOWED_TIMING_ORIGINS_PARAM);
		 anyOriginAllowed = generateAllowedOrigins(allowedOrigins, allowedOriginsConfig, DEFAULT_ALLOWED_ORIGINS);
		 anyTimingOriginAllowed = generateAllowedOrigins(allowedTimingOrigins, allowedTimingOriginsConfig, DEFAULT_ALLOWED_TIMING_ORIGINS);
		 String allowedMethodsConfig = config.getInitParameter(ALLOWED_METHODS_PARAM);
		 if (allowedMethodsConfig == null) allowedMethods.addAll(DEFAULT_ALLOWED_METHODS);
		 else allowedMethods.addAll(Arrays.asList(StringUtil.csvSplit(allowedMethodsConfig)));
		 String allowedHeadersConfig = config.getInitParameter(ALLOWED_HEADERS_PARAM);
		 if (allowedHeadersConfig == null) allowedHeaders.addAll(DEFAULT_ALLOWED_HEADERS);
		 else if (""*"".equals(allowedHeadersConfig)) anyHeadersAllowed = true;
		 else allowedHeaders.addAll(Arrays.asList(StringUtil.csvSplit(allowedHeadersConfig)));
		 String preflightMaxAgeConfig = config.getInitParameter(PREFLIGHT_MAX_AGE_PARAM);
		 if (preflightMaxAgeConfig == null) preflightMaxAgeConfig = ""1800"";
		 try {
			 preflightMaxAge = Integer.parseInt(preflightMaxAgeConfig);
		 }
		 catch (NumberFormatException x) {
			 LOG.info(""Cross-origin filter, could not parse '{
			}
			' parameter as integer: {
			}
			"", PREFLIGHT_MAX_AGE_PARAM, preflightMaxAgeConfig);
		 }
		 String allowedCredentialsConfig = config.getInitParameter(ALLOW_CREDENTIALS_PARAM);
		 if (allowedCredentialsConfig == null) allowedCredentialsConfig = ""true"";
		 allowCredentials = Boolean.parseBoolean(allowedCredentialsConfig);
		 String exposedHeadersConfig = config.getInitParameter(EXPOSED_HEADERS_PARAM);
		 if (exposedHeadersConfig == null) exposedHeadersConfig = """";
		 exposedHeaders.addAll(Arrays.asList(StringUtil.csvSplit(exposedHeadersConfig)));
		 String chainPreflightConfig = config.getInitParameter(OLD_CHAIN_PREFLIGHT_PARAM);
		 if (chainPreflightConfig != null) LOG.warn(""DEPRECATED CONFIGURATION: Use "" + CHAIN_PREFLIGHT_PARAM + "" instead of "" + OLD_CHAIN_PREFLIGHT_PARAM);
		 else chainPreflightConfig = config.getInitParameter(CHAIN_PREFLIGHT_PARAM);
		 if (chainPreflightConfig == null) chainPreflightConfig = ""true"";
		 chainPreflight = Boolean.parseBoolean(chainPreflightConfig);
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Cross-origin filter configuration: "" + ALLOWED_ORIGINS_PARAM + "" = "" + allowedOriginsConfig + "", "" + ALLOWED_TIMING_ORIGINS_PARAM + "" = "" + allowedTimingOriginsConfig + "", "" + ALLOWED_METHODS_PARAM + "" = "" + allowedMethodsConfig + "", "" + ALLOWED_HEADERS_PARAM + "" = "" + allowedHeadersConfig + "", "" + PREFLIGHT_MAX_AGE_PARAM + "" = "" + preflightMaxAgeConfig + "", "" + ALLOW_CREDENTIALS_PARAM + "" = "" + allowedCredentialsConfig + "","" + EXPOSED_HEADERS_PARAM + "" = "" + exposedHeadersConfig + "","" + CHAIN_PREFLIGHT_PARAM + "" = "" + chainPreflightConfig );
		 }
	 }
	 private boolean generateAllowedOrigins(List<String> allowedOriginStore, String allowedOriginsConfig, String defaultOrigin) {
		 if (allowedOriginsConfig == null) allowedOriginsConfig = defaultOrigin;
		 String[] allowedOrigins = StringUtil.csvSplit(allowedOriginsConfig);
		 for (String allowedOrigin : allowedOrigins) {
			 if (allowedOrigin.length() > 0) {
				 if (ANY_ORIGIN.equals(allowedOrigin)) {
					 allowedOriginStore.clear();
					 return true;
				 }
				 else {
					 allowedOriginStore.add(allowedOrigin);
				 }
			 }
		 }
		 return false;
	 }
	 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
		 handle((HttpServletRequest)request, (HttpServletResponse)response, chain);
	 }
	 private void handle(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
		 String origin = request.getHeader(ORIGIN_HEADER);
		 if (origin != null && isEnabled(request)) {
			 if (anyOriginAllowed || originMatches(allowedOrigins, origin)) {
				 if (isSimpleRequest(request)) {
					 LOG.debug(""Cross-origin request to {
					}
					 is a simple cross-origin request"", request.getRequestURI());
					 handleSimpleResponse(request, response, origin);
				 }
				 else if (isPreflightRequest(request)) {
					 LOG.debug(""Cross-origin request to {
					}
					 is a preflight cross-origin request"", request.getRequestURI());
					 handlePreflightResponse(request, response, origin);
					 if (chainPreflight) LOG.debug(""Preflight cross-origin request to {
					}
					 forwarded to application"", request.getRequestURI());
					 else return;
				 }
				 else {
					 LOG.debug(""Cross-origin request to {
					}
					 is a non-simple cross-origin request"", request.getRequestURI());
					 handleSimpleResponse(request, response, origin);
				 }
				 if (anyTimingOriginAllowed || originMatches(allowedTimingOrigins, origin)) {
					 response.setHeader(TIMING_ALLOW_ORIGIN_HEADER, origin);
				 }
				 else {
					 LOG.debug(""Cross-origin request to "" + request.getRequestURI() + "" with origin "" + origin + "" does not match allowed timing origins "" + allowedTimingOrigins);
				 }
			 }
			 else {
				 LOG.debug(""Cross-origin request to "" + request.getRequestURI() + "" with origin "" + origin + "" does not match allowed origins "" + allowedOrigins);
			 }
		 }
		 chain.doFilter(request, response);
	 }
	 protected boolean isEnabled(HttpServletRequest request) {
		 for (Enumeration<String> connections = request.getHeaders(""Connection"");
		 connections.hasMoreElements();
		) {
			 String connection = (String)connections.nextElement();
			 if (""Upgrade"".equalsIgnoreCase(connection)) {
				 for (Enumeration<String> upgrades = request.getHeaders(""Upgrade"");
				 upgrades.hasMoreElements();
				) {
					 String upgrade = (String)upgrades.nextElement();
					 if (""WebSocket"".equalsIgnoreCase(upgrade)) return false;
				 }
			 }
		 }
		 return true;
	 }
	 private boolean originMatches(List<String> allowedOrigins, String originList) {
		 if (originList.trim().length() == 0) return false;
		 String[] origins = originList.split("" "");
		 for (String origin : origins) {
			 if (origin.trim().length() == 0) continue;
			 for (String allowedOrigin : allowedOrigins) {
				 if (allowedOrigin.contains(""*"")) {
					 Matcher matcher = createMatcher(origin, allowedOrigin);
					 if (matcher.matches()) return true;
				 }
				 else if (allowedOrigin.equals(origin)) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 private Matcher createMatcher(String origin, String allowedOrigin) {
		 String regex = parseAllowedWildcardOriginToRegex(allowedOrigin);
		 Pattern pattern = Pattern.compile(regex);
		 return pattern.matcher(origin);
	 }
	 private String parseAllowedWildcardOriginToRegex(String allowedOrigin) {
		 String regex = allowedOrigin.replace(""."", ""\\."");
		 return regex.replace(""*"", "".*"");
	 }
	 private boolean isSimpleRequest(HttpServletRequest request) {
		 String method = request.getMethod();
		 if (SIMPLE_HTTP_METHODS.contains(method)) {
			 return request.getHeader(ACCESS_CONTROL_REQUEST_METHOD_HEADER) == null;
		 }
		 return false;
	 }
	 private boolean isPreflightRequest(HttpServletRequest request) {
		 String method = request.getMethod();
		 if (!""OPTIONS"".equalsIgnoreCase(method)) return false;
		 if (request.getHeader(ACCESS_CONTROL_REQUEST_METHOD_HEADER) == null) return false;
		 return true;
	 }
	 private void handleSimpleResponse(HttpServletRequest request, HttpServletResponse response, String origin) {
		 response.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, origin);
		 response.addHeader(""Vary"", ORIGIN_HEADER);
		 if (allowCredentials) response.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS_HEADER, ""true"");
		 if (!exposedHeaders.isEmpty()) response.setHeader(ACCESS_CONTROL_EXPOSE_HEADERS_HEADER, commify(exposedHeaders));
	 }
	 private void handlePreflightResponse(HttpServletRequest request, HttpServletResponse response, String origin) {
		 boolean methodAllowed = isMethodAllowed(request);
		 if (!methodAllowed) return;
		 List<String> headersRequested = getAccessControlRequestHeaders(request);
		 boolean headersAllowed = areHeadersAllowed(headersRequested);
		 if (!headersAllowed) return;
		 response.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, origin);
		 if (!anyOriginAllowed) response.addHeader(""Vary"", ORIGIN_HEADER);
		 if (allowCredentials) response.setHeader(ACCESS_CONTROL_ALLOW_CREDENTIALS_HEADER, ""true"");
		 if (preflightMaxAge > 0) response.setHeader(ACCESS_CONTROL_MAX_AGE_HEADER, String.valueOf(preflightMaxAge));
		 response.setHeader(ACCESS_CONTROL_ALLOW_METHODS_HEADER, commify(allowedMethods));
		 if (anyHeadersAllowed) response.setHeader(ACCESS_CONTROL_ALLOW_HEADERS_HEADER, commify(headersRequested));
		 else response.setHeader(ACCESS_CONTROL_ALLOW_HEADERS_HEADER, commify(allowedHeaders));
	 }
	 private boolean isMethodAllowed(HttpServletRequest request) {
		 String accessControlRequestMethod = request.getHeader(ACCESS_CONTROL_REQUEST_METHOD_HEADER);
		 LOG.debug(""{
		}
		 is {
		}
		"", ACCESS_CONTROL_REQUEST_METHOD_HEADER, accessControlRequestMethod);
		 boolean result = false;
		 if (accessControlRequestMethod != null) result = allowedMethods.contains(accessControlRequestMethod);
		 LOG.debug(""Method {
		}
		 is"" + (result ? """" : "" not"") + "" among allowed methods {
		}
		"", accessControlRequestMethod, allowedMethods);
		 return result;
	 }
	 private List<String> getAccessControlRequestHeaders(HttpServletRequest request) {
		 String accessControlRequestHeaders = request.getHeader(ACCESS_CONTROL_REQUEST_HEADERS_HEADER);
		 LOG.debug(""{
		}
		 is {
		}
		"", ACCESS_CONTROL_REQUEST_HEADERS_HEADER, accessControlRequestHeaders);
		 if (accessControlRequestHeaders == null) return Collections.emptyList();
		 List<String> requestedHeaders = new ArrayList<String>();
		 String[] headers = StringUtil.csvSplit(accessControlRequestHeaders);
		 for (String header : headers) {
			 String h = header.trim();
			 if (h.length() > 0) requestedHeaders.add(h);
		 }
		 return requestedHeaders;
	 }
	 private boolean areHeadersAllowed(List<String> requestedHeaders) {
		 if (anyHeadersAllowed) {
			 LOG.debug(""Any header is allowed"");
			 return true;
		 }
		 boolean result = true;
		 for (String requestedHeader : requestedHeaders) {
			 boolean headerAllowed = false;
			 for (String allowedHeader : allowedHeaders) {
				 if (requestedHeader.equalsIgnoreCase(allowedHeader.trim())) {
					 headerAllowed = true;
					 break;
				 }
			 }
			 if (!headerAllowed) {
				 result = false;
				 break;
			 }
		 }
		 LOG.debug(""Headers [{
		}
		] are"" + (result ? """" : "" not"") + "" among allowed headers {
		}
		"", requestedHeaders, allowedHeaders);
		 return result;
	 }
	 private String commify(List<String> strings) {
		 StringBuilder builder = new StringBuilder();
		 for (int i = 0;
		 i < strings.size();
		 ++i) {
			 if (i > 0) builder.append("","");
			 String string = strings.get(i);
			 builder.append(string);
		 }
		 return builder.toString();
	 }
	 public void destroy() {
		 anyOriginAllowed = false;
		 allowedOrigins.clear();
		 allowedMethods.clear();
		 allowedHeaders.clear();
		 preflightMaxAge = 0;
		 allowCredentials = false;
	 }
}",0,0,0,0
"public class LogTransformer extends Transformer {
	 private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
	 public Object transformRow(Map<String, Object> row, Context ctx) {
		 String expr = ctx.getEntityAttribute(LOG_TEMPLATE);
		 String level = ctx.replaceTokens(ctx.getEntityAttribute(LOG_LEVEL));
		 if (expr == null || level == null) return row;
		 if (""info"".equals(level)) {
			 if (log.isInfoEnabled()) log.info(ctx.replaceTokens(expr));
		 }
		 else if (""trace"".equals(level)) {
			 if (log.isTraceEnabled()) log.trace(ctx.replaceTokens(expr));
		 }
		 else if (""warn"".equals(level)) {
			 if (log.isWarnEnabled()) log.warn(ctx.replaceTokens(expr));
		 }
		 else if (""error"".equals(level)) {
			 if (log.isErrorEnabled()) log.error(ctx.replaceTokens(expr));
		 }
		 else if (""debug"".equals(level)) {
			 if (log.isDebugEnabled()) log.debug(ctx.replaceTokens(expr));
		 }
		 return row;
	 }
	 public static final String LOG_TEMPLATE = ""logTemplate"";
	 public static final String LOG_LEVEL = ""logLevel"";
}",1,0,0,0
"BundleArchiveRevision(String location, File revisionDir, File file) throws IOException{
	 this.revisionDir = revisionDir;
	 this.location = location;
	 if (!this.revisionDir.exists()) {
		 this.revisionDir.mkdirs();
	 }
	 if(revisionDir.getAbsolutePath().startsWith(RuntimeVariables.androidApplication.getFilesDir().getAbsolutePath())){
		 externalStorage = false;
	 }
	else{
		 externalStorage = true;
	 }
	 if(shouldCopyInstallFile(file)){
		 if (isSameDriver(revisionDir, file)) {
			 this.revisionLocation = FILE_PROTOCOL;
			 this.bundleFile = new File(revisionDir, BUNDLE_FILE_NAME);
			 boolean result = file.renameTo(bundleFile);
			 if(!result){
				 ApkUtils.copyInputStreamToFile(new FileInputStream(file), bundleFile);
			 }
		 }
		 else {
			 this.revisionLocation = FILE_PROTOCOL;
			 this.bundleFile = new File(revisionDir, BUNDLE_FILE_NAME);
			 ApkUtils.copyInputStreamToFile(new FileInputStream(file), bundleFile);
		 }
		 installSoLib(bundleFile);
	 }
	else{
		 this.revisionLocation = REFERENCE_PROTOCOL + file.getAbsolutePath();
		 this.bundleFile = file;
		 installSoLib(file);
	 }
	 updateMetadata();
 }",0,0,1,0
"public final class CGraphPanelExtender {
	 private CGraphPanelExtender() {
	 }
	 public static void extend() {
		 CAbstractGraphPanelExtensionFactory.register(new CVariablesExtensionCreator());
		 CAbstractGraphPanelExtensionFactory.register(new CCrossReferenceExtensionCreator());
		 CAbstractGraphPanelExtensionFactory.register(new CRegisterTrackingExtensionCreator());
		 CAbstractGraphPanelExtensionFactory.register(new CInstructionHighlighterExtensionCreator());
		 CAbstractGraphPanelExtensionFactory.register(new CCodeBookmarkExtensionCreator());
	 }
}",0,0,0,0
"public void setOutput(OutputStream out) {
}",0,0,0,0
"public class LogBrokerMonitor {
	 public static final String DETAILED_VIEW = ""Detailed"";
	 protected JFrame _logMonitorFrame;
	 protected int _logMonitorFrameWidth = 550;
	 protected int _logMonitorFrameHeight = 500;
	 protected LogTable _table;
	 protected CategoryExplorerTree _categoryExplorerTree;
	 protected String _searchText;
	 protected String _NDCTextFilter = """";
	 protected LogLevel _leastSevereDisplayedLogLevel = LogLevel.DEBUG;
	 protected JScrollPane _logTableScrollPane;
	 protected JLabel _statusLabel;
	 protected Object _lock = new Object();
	 protected JComboBox _fontSizeCombo;
	 protected int _fontSize = 10;
	 protected String _fontName = ""Dialog"";
	 protected String _currentView = DETAILED_VIEW;
	 protected boolean _loadSystemFonts = false;
	 protected boolean _trackTableScrollPane = true;
	 protected Dimension _lastTableViewportSize;
	 protected boolean _callSystemExitOnClose = false;
	 protected List _displayedLogBrokerProperties = new Vector();
	 protected Map _logLevelMenuItems = new HashMap();
	 protected Map _logTableColumnMenuItems = new HashMap();
	 protected List _levels = null;
	 protected List _columns = null;
	 protected boolean _isDisposed = false;
	 protected ConfigurationManager _configurationManager = null;
	 protected MRUFileManager _mruFileManager = null;
	 protected File _fileLocation = null;
	 public LogBrokerMonitor(List logLevels) {
		 _levels = logLevels;
		 _columns = LogTableColumn.getLogTableColumns();
		 String callSystemExitOnClose = System.getProperty(""monitor.exit"");
		 if (callSystemExitOnClose == null) {
			 callSystemExitOnClose = ""false"";
		 }
		 callSystemExitOnClose = callSystemExitOnClose.trim().toLowerCase();
		 if (callSystemExitOnClose.equals(""true"")) {
			 _callSystemExitOnClose = true;
		 }
		 initComponents();
		 _logMonitorFrame.addWindowListener( new LogBrokerMonitorWindowAdaptor(this));
	 }
	 public void show(final int delay) {
		 if (_logMonitorFrame.isVisible()) {
			 return;
		 }
		 SwingUtilities.invokeLater(new Runnable() {
			 public void run() {
				 Thread.yield();
				 pause(delay);
				 _logMonitorFrame.setVisible(true);
			 }
		 }
		);
	 }
	 public void show() {
		 show(0);
	 }
	 public void dispose() {
		 _logMonitorFrame.dispose();
		 _isDisposed = true;
		 if (_callSystemExitOnClose == true) {
			 System.exit(0);
		 }
	 }
	 public void hide() {
		 _logMonitorFrame.setVisible(false);
	 }
	 public DateFormatManager getDateFormatManager() {
		 return _table.getDateFormatManager();
	 }
	 public void setDateFormatManager(DateFormatManager dfm) {
		 _table.setDateFormatManager(dfm);
	 }
	 public boolean getCallSystemExitOnClose() {
		 return _callSystemExitOnClose;
	 }
	 public void setCallSystemExitOnClose(boolean callSystemExitOnClose) {
		 _callSystemExitOnClose = callSystemExitOnClose;
	 }
	 public void addMessage(final LogRecord lr) {
		 if (_isDisposed == true) {
			 return;
		 }
		 SwingUtilities.invokeLater(new Runnable() {
			 public void run() {
				 _categoryExplorerTree.getExplorerModel().addLogRecord(lr);
				 _table.getFilteredLogTableModel().addLogRecord(lr);
				 updateStatusLabel();
			 }
		 }
		);
	 }
	 public void setMaxNumberOfLogRecords(int maxNumberOfLogRecords) {
		 _table.getFilteredLogTableModel().setMaxNumberOfLogRecords(maxNumberOfLogRecords);
	 }
	 public JFrame getBaseFrame() {
		 return _logMonitorFrame;
	 }
	 public void setTitle(String title) {
		 _logMonitorFrame.setTitle(title + "" - LogFactor5"");
	 }
	 public void setFrameSize(int width, int height) {
		 Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
		 if (0 < width && width < screen.width) {
			 _logMonitorFrameWidth = width;
		 }
		 if (0 < height && height < screen.height) {
			 _logMonitorFrameHeight = height;
		 }
		 updateFrameSize();
	 }
	 public void setFontSize(int fontSize) {
		 changeFontSizeCombo(_fontSizeCombo, fontSize);
	 }
	 public void addDisplayedProperty(Object messageLine) {
		 _displayedLogBrokerProperties.add(messageLine);
	 }
	 public Map getLogLevelMenuItems() {
		 return _logLevelMenuItems;
	 }
	 public Map getLogTableColumnMenuItems() {
		 return _logTableColumnMenuItems;
	 }
	 public JCheckBoxMenuItem getTableColumnMenuItem(LogTableColumn column) {
		 return getLogTableColumnMenuItem(column);
	 }
	 public CategoryExplorerTree getCategoryExplorerTree() {
		 return _categoryExplorerTree;
	 }
	 public String getNDCTextFilter() {
		 return _NDCTextFilter;
	 }
	 public void setNDCLogRecordFilter(String textFilter) {
		 _table.getFilteredLogTableModel(). setLogRecordFilter(createNDCLogRecordFilter(textFilter));
	 }
	 protected void setSearchText(String text) {
		 _searchText = text;
	 }
	 protected void setNDCTextFilter(String text) {
		 if (text == null) {
			 _NDCTextFilter = """";
		 }
		 else {
			 _NDCTextFilter = text;
		 }
	 }
	 protected void sortByNDC() {
		 String text = _NDCTextFilter;
		 if (text == null || text.length() == 0) {
			 return;
		 }
		 _table.getFilteredLogTableModel(). setLogRecordFilter(createNDCLogRecordFilter(text));
	 }
	 protected void findSearchText() {
		 String text = _searchText;
		 if (text == null || text.length() == 0) {
			 return;
		 }
		 int startRow = getFirstSelectedRow();
		 int foundRow = findRecord( startRow, text, _table.getFilteredLogTableModel().getFilteredRecords() );
		 selectRow(foundRow);
	 }
	 protected int getFirstSelectedRow() {
		 return _table.getSelectionModel().getMinSelectionIndex();
	 }
	 protected void selectRow(int foundRow) {
		 if (foundRow == -1) {
			 String message = _searchText + "" not found."";
			 JOptionPane.showMessageDialog( _logMonitorFrame, message, ""Text not found"", JOptionPane.INFORMATION_MESSAGE );
			 return;
		 }
		 LF5SwingUtils.selectRow(foundRow, _table, _logTableScrollPane);
	 }
	 protected int findRecord( int startRow, String searchText, List records ) {
		 if (startRow < 0) {
			 startRow = 0;
		 }
		 else {
			 startRow++;
		 }
		 int len = records.size();
		 for (int i = startRow;
		 i < len;
		 i++) {
			 if (matches((LogRecord) records.get(i), searchText)) {
				 return i;
			 }
		 }
		 len = startRow;
		 for (int i = 0;
		 i < len;
		 i++) {
			 if (matches((LogRecord) records.get(i), searchText)) {
				 return i;
			 }
		 }
		 return -1;
	 }
	 protected boolean matches(LogRecord record, String text) {
		 String message = record.getMessage();
		 String NDC = record.getNDC();
		 if (message == null && NDC == null || text == null) {
			 return false;
		 }
		 if (message.toLowerCase().indexOf(text.toLowerCase()) == -1 && NDC.toLowerCase().indexOf(text.toLowerCase()) == -1) {
			 return false;
		 }
		 return true;
	 }
	 protected void refresh(JTextArea textArea) {
		 String text = textArea.getText();
		 textArea.setText("""");
		 textArea.setText(text);
	 }
	 protected void refreshDetailTextArea() {
		 refresh(_table._detailTextArea);
	 }
	 protected void clearDetailTextArea() {
		 _table._detailTextArea.setText("""");
	 }
	 protected int changeFontSizeCombo(JComboBox box, int requestedSize) {
		 int len = box.getItemCount();
		 int currentValue;
		 Object currentObject;
		 Object selectedObject = box.getItemAt(0);
		 int selectedValue = Integer.parseInt(String.valueOf(selectedObject));
		 for (int i = 0;
		 i < len;
		 i++) {
			 currentObject = box.getItemAt(i);
			 currentValue = Integer.parseInt(String.valueOf(currentObject));
			 if (selectedValue < currentValue && currentValue <= requestedSize) {
				 selectedValue = currentValue;
				 selectedObject = currentObject;
			 }
		 }
		 box.setSelectedItem(selectedObject);
		 return selectedValue;
	 }
	 protected void setFontSizeSilently(int fontSize) {
		 _fontSize = fontSize;
		 setFontSize(_table._detailTextArea, fontSize);
		 selectRow(0);
		 setFontSize(_table, fontSize);
	 }
	 protected void setFontSize(Component component, int fontSize) {
		 Font oldFont = component.getFont();
		 Font newFont = new Font(oldFont.getFontName(), oldFont.getStyle(), fontSize);
		 component.setFont(newFont);
	 }
	 protected void updateFrameSize() {
		 _logMonitorFrame.setSize(_logMonitorFrameWidth, _logMonitorFrameHeight);
		 centerFrame(_logMonitorFrame);
	 }
	 protected void pause(int millis) {
		 try {
			 Thread.sleep(millis);
		 }
		 catch (InterruptedException e) {
		 }
	 }
	 protected void initComponents() {
		 _logMonitorFrame = new JFrame(""LogFactor5"");
		 _logMonitorFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
		 String resource = ""/org/apache/log4j/lf5/viewer/images/lf5_small_icon.gif"";
		 URL lf5IconURL = getClass().getResource(resource);
		 if (lf5IconURL != null) {
			 _logMonitorFrame.setIconImage(new ImageIcon(lf5IconURL).getImage());
		 }
		 updateFrameSize();
		 JTextArea detailTA = createDetailTextArea();
		 JScrollPane detailTAScrollPane = new JScrollPane(detailTA);
		 _table = new LogTable(detailTA);
		 setView(_currentView, _table);
		 _table.setFont(new Font(_fontName, Font.PLAIN, _fontSize));
		 _logTableScrollPane = new JScrollPane(_table);
		 if (_trackTableScrollPane) {
			 _logTableScrollPane.getVerticalScrollBar().addAdjustmentListener( new TrackingAdjustmentListener() );
		 }
		 JSplitPane tableViewerSplitPane = new JSplitPane();
		 tableViewerSplitPane.setOneTouchExpandable(true);
		 tableViewerSplitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
		 tableViewerSplitPane.setLeftComponent(_logTableScrollPane);
		 tableViewerSplitPane.setRightComponent(detailTAScrollPane);
		 tableViewerSplitPane.setDividerLocation(350);
		 _categoryExplorerTree = new CategoryExplorerTree();
		 _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());
		 JScrollPane categoryExplorerTreeScrollPane = new JScrollPane(_categoryExplorerTree);
		 categoryExplorerTreeScrollPane.setPreferredSize(new Dimension(130, 400));
		 _mruFileManager = new MRUFileManager();
		 JSplitPane splitPane = new JSplitPane();
		 splitPane.setOneTouchExpandable(true);
		 splitPane.setRightComponent(tableViewerSplitPane);
		 splitPane.setLeftComponent(categoryExplorerTreeScrollPane);
		 splitPane.setDividerLocation(130);
		 _logMonitorFrame.getRootPane().setJMenuBar(createMenuBar());
		 _logMonitorFrame.getContentPane().add(splitPane, BorderLayout.CENTER);
		 _logMonitorFrame.getContentPane().add(createToolBar(), BorderLayout.NORTH);
		 _logMonitorFrame.getContentPane().add(createStatusArea(), BorderLayout.SOUTH);
		 makeLogTableListenToCategoryExplorer();
		 addTableModelProperties();
		 _configurationManager = new ConfigurationManager(this, _table);
	 }
	 protected LogRecordFilter createLogRecordFilter() {
		 LogRecordFilter result = new LogRecordFilter() {
			 public boolean passes(LogRecord record) {
				 CategoryPath path = new CategoryPath(record.getCategory());
				 return getMenuItem(record.getLevel()).isSelected() && _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);
			 }
		 }
		;
		 return result;
	 }
	 protected LogRecordFilter createNDCLogRecordFilter(String text) {
		 _NDCTextFilter = text;
		 LogRecordFilter result = new LogRecordFilter() {
			 public boolean passes(LogRecord record) {
				 String NDC = record.getNDC();
				 CategoryPath path = new CategoryPath(record.getCategory());
				 if (NDC == null || _NDCTextFilter == null) {
					 return false;
				 }
				 else if (NDC.toLowerCase().indexOf(_NDCTextFilter.toLowerCase()) == -1) {
					 return false;
				 }
				 else {
					 return getMenuItem(record.getLevel()).isSelected() && _categoryExplorerTree.getExplorerModel().isCategoryPathActive(path);
				 }
			 }
		 }
		;
		 return result;
	 }
	 protected void updateStatusLabel() {
		 _statusLabel.setText(getRecordsDisplayedMessage());
	 }
	 protected String getRecordsDisplayedMessage() {
		 FilteredLogTableModel model = _table.getFilteredLogTableModel();
		 return getStatusText(model.getRowCount(), model.getTotalRowCount());
	 }
	 protected void addTableModelProperties() {
		 final FilteredLogTableModel model = _table.getFilteredLogTableModel();
		 addDisplayedProperty(new Object() {
			 public String toString() {
				 return getRecordsDisplayedMessage();
			 }
		 }
		);
		 addDisplayedProperty(new Object() {
			 public String toString() {
				 return ""Maximum number of displayed LogRecords: "" + model._maxNumberOfLogRecords;
			 }
		 }
		);
	 }
	 protected String getStatusText(int displayedRows, int totalRows) {
		 StringBuffer result = new StringBuffer();
		 result.append(""Displaying: "");
		 result.append(displayedRows);
		 result.append("" records out of a total of: "");
		 result.append(totalRows);
		 result.append("" records."");
		 return result.toString();
	 }
	 protected void makeLogTableListenToCategoryExplorer() {
		 ActionListener listener = new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _table.getFilteredLogTableModel().refresh();
				 updateStatusLabel();
			 }
		 }
		;
		 _categoryExplorerTree.getExplorerModel().addActionListener(listener);
	 }
	 protected JPanel createStatusArea() {
		 JPanel statusArea = new JPanel();
		 JLabel status = new JLabel(""No log records to display."");
		 _statusLabel = status;
		 status.setHorizontalAlignment(JLabel.LEFT);
		 statusArea.setBorder(BorderFactory.createEtchedBorder());
		 statusArea.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
		 statusArea.add(status);
		 return (statusArea);
	 }
	 protected JTextArea createDetailTextArea() {
		 JTextArea detailTA = new JTextArea();
		 detailTA.setFont(new Font(""Monospaced"", Font.PLAIN, 14));
		 detailTA.setTabSize(3);
		 detailTA.setLineWrap(true);
		 detailTA.setWrapStyleWord(false);
		 return (detailTA);
	 }
	 protected JMenuBar createMenuBar() {
		 JMenuBar menuBar = new JMenuBar();
		 menuBar.add(createFileMenu());
		 menuBar.add(createEditMenu());
		 menuBar.add(createLogLevelMenu());
		 menuBar.add(createViewMenu());
		 menuBar.add(createConfigureMenu());
		 menuBar.add(createHelpMenu());
		 return (menuBar);
	 }
	 protected JMenu createLogLevelMenu() {
		 JMenu result = new JMenu(""Log Level"");
		 result.setMnemonic('l');
		 Iterator levels = getLogLevels();
		 while (levels.hasNext()) {
			 result.add(getMenuItem((LogLevel) levels.next()));
		 }
		 result.addSeparator();
		 result.add(createAllLogLevelsMenuItem());
		 result.add(createNoLogLevelsMenuItem());
		 result.addSeparator();
		 result.add(createLogLevelColorMenu());
		 result.add(createResetLogLevelColorMenuItem());
		 return result;
	 }
	 protected JMenuItem createAllLogLevelsMenuItem() {
		 JMenuItem result = new JMenuItem(""Show all LogLevels"");
		 result.setMnemonic('s');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 selectAllLogLevels(true);
				 _table.getFilteredLogTableModel().refresh();
				 updateStatusLabel();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenuItem createNoLogLevelsMenuItem() {
		 JMenuItem result = new JMenuItem(""Hide all LogLevels"");
		 result.setMnemonic('h');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 selectAllLogLevels(false);
				 _table.getFilteredLogTableModel().refresh();
				 updateStatusLabel();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenu createLogLevelColorMenu() {
		 JMenu colorMenu = new JMenu(""Configure LogLevel Colors"");
		 colorMenu.setMnemonic('c');
		 Iterator levels = getLogLevels();
		 while (levels.hasNext()) {
			 colorMenu.add(createSubMenuItem((LogLevel) levels.next()));
		 }
		 return colorMenu;
	 }
	 protected JMenuItem createResetLogLevelColorMenuItem() {
		 JMenuItem result = new JMenuItem(""Reset LogLevel Colors"");
		 result.setMnemonic('r');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 LogLevel.resetLogLevelColorMap();
				 _table.getFilteredLogTableModel().refresh();
			 }
		 }
		);
		 return result;
	 }
	 protected void selectAllLogLevels(boolean selected) {
		 Iterator levels = getLogLevels();
		 while (levels.hasNext()) {
			 getMenuItem((LogLevel) levels.next()).setSelected(selected);
		 }
	 }
	 protected JCheckBoxMenuItem getMenuItem(LogLevel level) {
		 JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logLevelMenuItems.get(level));
		 if (result == null) {
			 result = createMenuItem(level);
			 _logLevelMenuItems.put(level, result);
		 }
		 return result;
	 }
	 protected JMenuItem createSubMenuItem(LogLevel level) {
		 final JMenuItem result = new JMenuItem(level.toString());
		 final LogLevel logLevel = level;
		 result.setMnemonic(level.toString().charAt(0));
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 showLogLevelColorChangeDialog(result, logLevel);
			 }
		 }
		);
		 return result;
	 }
	 protected void showLogLevelColorChangeDialog(JMenuItem result, LogLevel level) {
		 JMenuItem menuItem = result;
		 Color newColor = JColorChooser.showDialog( _logMonitorFrame, ""Choose LogLevel Color"", result.getForeground());
		 if (newColor != null) {
			 level.setLogLevelColorMap(level, newColor);
			 _table.getFilteredLogTableModel().refresh();
		 }
	 }
	 protected JCheckBoxMenuItem createMenuItem(LogLevel level) {
		 JCheckBoxMenuItem result = new JCheckBoxMenuItem(level.toString());
		 result.setSelected(true);
		 result.setMnemonic(level.toString().charAt(0));
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _table.getFilteredLogTableModel().refresh();
				 updateStatusLabel();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenu createViewMenu() {
		 JMenu result = new JMenu(""View"");
		 result.setMnemonic('v');
		 Iterator columns = getLogTableColumns();
		 while (columns.hasNext()) {
			 result.add(getLogTableColumnMenuItem((LogTableColumn) columns.next()));
		 }
		 result.addSeparator();
		 result.add(createAllLogTableColumnsMenuItem());
		 result.add(createNoLogTableColumnsMenuItem());
		 return result;
	 }
	 protected JCheckBoxMenuItem getLogTableColumnMenuItem(LogTableColumn column) {
		 JCheckBoxMenuItem result = (JCheckBoxMenuItem) (_logTableColumnMenuItems.get(column));
		 if (result == null) {
			 result = createLogTableColumnMenuItem(column);
			 _logTableColumnMenuItems.put(column, result);
		 }
		 return result;
	 }
	 protected JCheckBoxMenuItem createLogTableColumnMenuItem(LogTableColumn column) {
		 JCheckBoxMenuItem result = new JCheckBoxMenuItem(column.toString());
		 result.setSelected(true);
		 result.setMnemonic(column.toString().charAt(0));
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 List selectedColumns = updateView();
				 _table.setView(selectedColumns);
			 }
		 }
		);
		 return result;
	 }
	 protected List updateView() {
		 ArrayList updatedList = new ArrayList();
		 Iterator columnIterator = _columns.iterator();
		 while (columnIterator.hasNext()) {
			 LogTableColumn column = (LogTableColumn) columnIterator.next();
			 JCheckBoxMenuItem result = getLogTableColumnMenuItem(column);
			 if (result.isSelected()) {
				 updatedList.add(column);
			 }
		 }
		 return updatedList;
	 }
	 protected JMenuItem createAllLogTableColumnsMenuItem() {
		 JMenuItem result = new JMenuItem(""Show all Columns"");
		 result.setMnemonic('s');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 selectAllLogTableColumns(true);
				 List selectedColumns = updateView();
				 _table.setView(selectedColumns);
			 }
		 }
		);
		 return result;
	 }
	 protected JMenuItem createNoLogTableColumnsMenuItem() {
		 JMenuItem result = new JMenuItem(""Hide all Columns"");
		 result.setMnemonic('h');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 selectAllLogTableColumns(false);
				 List selectedColumns = updateView();
				 _table.setView(selectedColumns);
			 }
		 }
		);
		 return result;
	 }
	 protected void selectAllLogTableColumns(boolean selected) {
		 Iterator columns = getLogTableColumns();
		 while (columns.hasNext()) {
			 getLogTableColumnMenuItem((LogTableColumn) columns.next()).setSelected(selected);
		 }
	 }
	 protected JMenu createFileMenu() {
		 JMenu fileMenu = new JMenu(""File"");
		 fileMenu.setMnemonic('f');
		 JMenuItem exitMI;
		 fileMenu.add(createOpenMI());
		 fileMenu.add(createOpenURLMI());
		 fileMenu.addSeparator();
		 fileMenu.add(createCloseMI());
		 createMRUFileListMI(fileMenu);
		 fileMenu.addSeparator();
		 fileMenu.add(createExitMI());
		 return fileMenu;
	 }
	 protected JMenuItem createOpenMI() {
		 JMenuItem result = new JMenuItem(""Open..."");
		 result.setMnemonic('o');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 requestOpen();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenuItem createOpenURLMI() {
		 JMenuItem result = new JMenuItem(""Open URL..."");
		 result.setMnemonic('u');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 requestOpenURL();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenuItem createCloseMI() {
		 JMenuItem result = new JMenuItem(""Close"");
		 result.setMnemonic('c');
		 result.setAccelerator(KeyStroke.getKeyStroke(""control Q""));
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 requestClose();
			 }
		 }
		);
		 return result;
	 }
	 protected void createMRUFileListMI(JMenu menu) {
		 String[] files = _mruFileManager.getMRUFileList();
		 if (files != null) {
			 menu.addSeparator();
			 for (int i = 0;
			 i < files.length;
			 i++) {
				 JMenuItem result = new JMenuItem((i + 1) + "" "" + files[i]);
				 result.setMnemonic(i + 1);
				 result.addActionListener(new ActionListener() {
					 public void actionPerformed(ActionEvent e) {
						 requestOpenMRU(e);
					 }
				 }
				);
				 menu.add(result);
			 }
		 }
	 }
	 protected JMenuItem createExitMI() {
		 JMenuItem result = new JMenuItem(""Exit"");
		 result.setMnemonic('x');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 requestExit();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenu createConfigureMenu() {
		 JMenu configureMenu = new JMenu(""Configure"");
		 configureMenu.setMnemonic('c');
		 configureMenu.add(createConfigureSave());
		 configureMenu.add(createConfigureReset());
		 configureMenu.add(createConfigureMaxRecords());
		 return configureMenu;
	 }
	 protected JMenuItem createConfigureSave() {
		 JMenuItem result = new JMenuItem(""Save"");
		 result.setMnemonic('s');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 saveConfiguration();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenuItem createConfigureReset() {
		 JMenuItem result = new JMenuItem(""Reset"");
		 result.setMnemonic('r');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 resetConfiguration();
			 }
		 }
		);
		 return result;
	 }
	 protected JMenuItem createConfigureMaxRecords() {
		 JMenuItem result = new JMenuItem(""Set Max Number of Records"");
		 result.setMnemonic('m');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 setMaxRecordConfiguration();
			 }
		 }
		);
		 return result;
	 }
	 protected void saveConfiguration() {
		 _configurationManager.save();
	 }
	 protected void resetConfiguration() {
		 _configurationManager.reset();
	 }
	 protected void setMaxRecordConfiguration() {
		 LogFactor5InputDialog inputDialog = new LogFactor5InputDialog( getBaseFrame(), ""Set Max Number of Records"", """", 10);
		 String temp = inputDialog.getText();
		 if (temp != null) {
			 try {
				 setMaxNumberOfLogRecords(Integer.parseInt(temp));
			 }
			 catch (NumberFormatException e) {
				 LogFactor5ErrorDialog error = new LogFactor5ErrorDialog( getBaseFrame(), ""'"" + temp + ""' is an invalid parameter.\nPlease try again."");
				 setMaxRecordConfiguration();
			 }
		 }
	 }
	 protected JMenu createHelpMenu() {
		 JMenu helpMenu = new JMenu(""Help"");
		 helpMenu.setMnemonic('h');
		 helpMenu.add(createHelpProperties());
		 return helpMenu;
	 }
	 protected JMenuItem createHelpProperties() {
		 final String title = ""LogFactor5 Properties"";
		 final JMenuItem result = new JMenuItem(title);
		 result.setMnemonic('l');
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 showPropertiesDialog(title);
			 }
		 }
		);
		 return result;
	 }
	 protected void showPropertiesDialog(String title) {
		 JOptionPane.showMessageDialog( _logMonitorFrame, _displayedLogBrokerProperties.toArray(), title, JOptionPane.PLAIN_MESSAGE );
	 }
	 protected JMenu createEditMenu() {
		 JMenu editMenu = new JMenu(""Edit"");
		 editMenu.setMnemonic('e');
		 editMenu.add(createEditFindMI());
		 editMenu.add(createEditFindNextMI());
		 editMenu.addSeparator();
		 editMenu.add(createEditSortNDCMI());
		 editMenu.add(createEditRestoreAllNDCMI());
		 return editMenu;
	 }
	 protected JMenuItem createEditFindNextMI() {
		 JMenuItem editFindNextMI = new JMenuItem(""Find Next"");
		 editFindNextMI.setMnemonic('n');
		 editFindNextMI.setAccelerator(KeyStroke.getKeyStroke(""F3""));
		 editFindNextMI.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 findSearchText();
			 }
		 }
		);
		 return editFindNextMI;
	 }
	 protected JMenuItem createEditFindMI() {
		 JMenuItem editFindMI = new JMenuItem(""Find"");
		 editFindMI.setMnemonic('f');
		 editFindMI.setAccelerator(KeyStroke.getKeyStroke(""control F""));
		 editFindMI.addActionListener( new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 String inputValue = JOptionPane.showInputDialog( _logMonitorFrame, ""Find text: "", ""Search Record Messages"", JOptionPane.QUESTION_MESSAGE );
				 setSearchText(inputValue);
				 findSearchText();
			 }
		 }
		 );
		 return editFindMI;
	 }
	 protected JMenuItem createEditSortNDCMI() {
		 JMenuItem editSortNDCMI = new JMenuItem(""Sort by NDC"");
		 editSortNDCMI.setMnemonic('s');
		 editSortNDCMI.addActionListener( new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 String inputValue = JOptionPane.showInputDialog( _logMonitorFrame, ""Sort by this NDC: "", ""Sort Log Records by NDC"", JOptionPane.QUESTION_MESSAGE );
				 setNDCTextFilter(inputValue);
				 sortByNDC();
				 _table.getFilteredLogTableModel().refresh();
				 updateStatusLabel();
			 }
		 }
		 );
		 return editSortNDCMI;
	 }
	 protected JMenuItem createEditRestoreAllNDCMI() {
		 JMenuItem editRestoreAllNDCMI = new JMenuItem(""Restore all NDCs"");
		 editRestoreAllNDCMI.setMnemonic('r');
		 editRestoreAllNDCMI.addActionListener( new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _table.getFilteredLogTableModel().setLogRecordFilter(createLogRecordFilter());
				 setNDCTextFilter("""");
				 _table.getFilteredLogTableModel().refresh();
				 updateStatusLabel();
			 }
		 }
		 );
		 return editRestoreAllNDCMI;
	 }
	 protected JToolBar createToolBar() {
		 JToolBar tb = new JToolBar();
		 tb.putClientProperty(""JToolBar.isRollover"", Boolean.TRUE);
		 JComboBox fontCombo = new JComboBox();
		 JComboBox fontSizeCombo = new JComboBox();
		 _fontSizeCombo = fontSizeCombo;
		 ClassLoader cl = this.getClass().getClassLoader();
		 if(cl == null) {
			 cl = ClassLoader.getSystemClassLoader();
		 }
		 URL newIconURL = cl.getResource(""org/apache/log4j/lf5/viewer/"" + ""images/channelexplorer_new.gif"");
		 ImageIcon newIcon = null;
		 if (newIconURL != null) {
			 newIcon = new ImageIcon(newIconURL);
		 }
		 JButton newButton = new JButton(""Clear Log Table"");
		 if (newIcon != null) {
			 newButton.setIcon(newIcon);
		 }
		 newButton.setToolTipText(""Clear Log Table."");
		 newButton.addActionListener( new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 _table.clearLogRecords();
				 _categoryExplorerTree.getExplorerModel().resetAllNodeCounts();
				 updateStatusLabel();
				 clearDetailTextArea();
				 LogRecord.resetSequenceNumber();
			 }
		 }
		 );
		 Toolkit tk = Toolkit.getDefaultToolkit();
		 String[] fonts;
		 if (_loadSystemFonts) {
			 fonts = GraphicsEnvironment. getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
		 }
		 else {
			 fonts = tk.getFontList();
		 }
		 for (int j = 0;
		 j < fonts.length;
		 j++) {
			 fontCombo.addItem(fonts[j]);
		 }
		 fontCombo.setSelectedItem(_fontName);
		 fontCombo.addActionListener( new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 JComboBox box = (JComboBox) e.getSource();
				 String font = (String) box.getSelectedItem();
				 _table.setFont(new Font(font, Font.PLAIN, _fontSize));
				 _fontName = font;
			 }
		 }
		 );
		 fontSizeCombo.addItem(""8"");
		 fontSizeCombo.addItem(""9"");
		 fontSizeCombo.addItem(""10"");
		 fontSizeCombo.addItem(""12"");
		 fontSizeCombo.addItem(""14"");
		 fontSizeCombo.addItem(""16"");
		 fontSizeCombo.addItem(""18"");
		 fontSizeCombo.addItem(""24"");
		 fontSizeCombo.setSelectedItem(String.valueOf(_fontSize));
		 fontSizeCombo.addActionListener( new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 JComboBox box = (JComboBox) e.getSource();
				 String size = (String) box.getSelectedItem();
				 int s = Integer.valueOf(size).intValue();
				 setFontSizeSilently(s);
				 refreshDetailTextArea();
				 _fontSize = s;
			 }
		 }
		 );
		 tb.add(new JLabel("" Font: ""));
		 tb.add(fontCombo);
		 tb.add(fontSizeCombo);
		 tb.addSeparator();
		 tb.addSeparator();
		 tb.add(newButton);
		 newButton.setAlignmentY(0.5f);
		 newButton.setAlignmentX(0.5f);
		 fontCombo.setMaximumSize(fontCombo.getPreferredSize());
		 fontSizeCombo.setMaximumSize( fontSizeCombo.getPreferredSize());
		 return (tb);
	 }
	 protected void setView(String viewString, LogTable table) {
		 if (DETAILED_VIEW.equals(viewString)) {
			 table.setDetailedView();
		 }
		 else {
			 String message = viewString + ""does not match a supported view."";
			 throw new IllegalArgumentException(message);
		 }
		 _currentView = viewString;
	 }
	 protected JComboBox createLogLevelCombo() {
		 JComboBox result = new JComboBox();
		 Iterator levels = getLogLevels();
		 while (levels.hasNext()) {
			 result.addItem(levels.next());
		 }
		 result.setSelectedItem(_leastSevereDisplayedLogLevel);
		 result.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 JComboBox box = (JComboBox) e.getSource();
				 LogLevel level = (LogLevel) box.getSelectedItem();
				 setLeastSevereDisplayedLogLevel(level);
			 }
		 }
		);
		 result.setMaximumSize(result.getPreferredSize());
		 return result;
	 }
	 protected void setLeastSevereDisplayedLogLevel(LogLevel level) {
		 if (level == null || _leastSevereDisplayedLogLevel == level) {
			 return;
		 }
		 _leastSevereDisplayedLogLevel = level;
		 _table.getFilteredLogTableModel().refresh();
		 updateStatusLabel();
	 }
	 protected void trackTableScrollPane() {
	 }
	 protected void centerFrame(JFrame frame) {
		 Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
		 Dimension comp = frame.getSize();
		 frame.setLocation(((screen.width - comp.width) / 2), ((screen.height - comp.height) / 2));
	 }
	 protected void requestOpen() {
		 JFileChooser chooser;
		 if (_fileLocation == null) {
			 chooser = new JFileChooser();
		 }
		 else {
			 chooser = new JFileChooser(_fileLocation);
		 }
		 int returnVal = chooser.showOpenDialog(_logMonitorFrame);
		 if (returnVal == JFileChooser.APPROVE_OPTION) {
			 File f = chooser.getSelectedFile();
			 if (loadLogFile(f)) {
				 _fileLocation = chooser.getSelectedFile();
				 _mruFileManager.set(f);
				 updateMRUList();
			 }
		 }
	 }
	 protected void requestOpenURL() {
		 LogFactor5InputDialog inputDialog = new LogFactor5InputDialog( getBaseFrame(), ""Open URL"", ""URL:"");
		 String temp = inputDialog.getText();
		 if (temp != null) {
		 if (temp.indexOf("": temp = ""http: }
		 try {
			 URL url = new URL(temp);
			 if (loadLogFile(url)) {
				 _mruFileManager.set(url);
				 updateMRUList();
			 }
		 }
		 catch (MalformedURLException e) {
			 LogFactor5ErrorDialog error = new LogFactor5ErrorDialog( getBaseFrame(), ""Error reading URL."");
		 }
	 }
 }
 protected void updateMRUList() {
	 JMenu menu = _logMonitorFrame.getJMenuBar().getMenu(0);
	 menu.removeAll();
	 menu.add(createOpenMI());
	 menu.add(createOpenURLMI());
	 menu.addSeparator();
	 menu.add(createCloseMI());
	 createMRUFileListMI(menu);
	 menu.addSeparator();
	 menu.add(createExitMI());
 }
 protected void requestClose() {
	 setCallSystemExitOnClose(false);
	 closeAfterConfirm();
 }
 protected void requestOpenMRU(ActionEvent e) {
	 String file = e.getActionCommand();
	 StringTokenizer st = new StringTokenizer(file);
	 String num = st.nextToken().trim();
	 file = st.nextToken(""\n"");
	 try {
		 int index = Integer.parseInt(num) - 1;
		 InputStream in = _mruFileManager.getInputStream(index);
		 LogFileParser lfp = new LogFileParser(in);
		 lfp.parse(this);
		 _mruFileManager.moveToTop(index);
		 updateMRUList();
	 }
	 catch (Exception me) {
		 LogFactor5ErrorDialog error = new LogFactor5ErrorDialog( getBaseFrame(), ""Unable to load file "" + file);
	 }
 }
 protected void requestExit() {
	 _mruFileManager.save();
	 setCallSystemExitOnClose(true);
	 closeAfterConfirm();
 }
 protected void closeAfterConfirm() {
	 StringBuffer message = new StringBuffer();
	 if (_callSystemExitOnClose == false) {
		 message.append(""Are you sure you want to close the logging "");
		 message.append(""console?\n"");
		 message.append(""(Note: This will not shut down the Virtual Machine,\n"");
		 message.append(""or the Swing event thread.)"");
	 }
	 else {
		 message.append(""Are you sure you want to exit?\n"");
		 message.append(""This will shut down the Virtual Machine.\n"");
	 }
	 String title = ""Are you sure you want to dispose of the Logging Console?"";
	 if (_callSystemExitOnClose == true) {
		 title = ""Are you sure you want to exit?"";
	 }
	 int value = JOptionPane.showConfirmDialog( _logMonitorFrame, message.toString(), title, JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null );
	 if (value == JOptionPane.OK_OPTION) {
		 dispose();
	 }
 }
 protected Iterator getLogLevels() {
	 return _levels.iterator();
 }
 protected Iterator getLogTableColumns() {
	 return _columns.iterator();
 }
 protected boolean loadLogFile(File file) {
	 boolean ok = false;
	 try {
		 LogFileParser lfp = new LogFileParser(file);
		 lfp.parse(this);
		 ok = true;
	 }
	 catch (IOException e) {
		 LogFactor5ErrorDialog error = new LogFactor5ErrorDialog( getBaseFrame(), ""Error reading "" + file.getName());
	 }
	 return ok;
 }
 protected boolean loadLogFile(URL url) {
	 boolean ok = false;
	 try {
		 LogFileParser lfp = new LogFileParser(url.openStream());
		 lfp.parse(this);
		 ok = true;
	 }
	 catch (IOException e) {
		 LogFactor5ErrorDialog error = new LogFactor5ErrorDialog( getBaseFrame(), ""Error reading URL:"" + url.getFile());
	 }
	 return ok;
 }
 class LogBrokerMonitorWindowAdaptor extends WindowAdapter {
	 protected LogBrokerMonitor _monitor;
	 public LogBrokerMonitorWindowAdaptor(LogBrokerMonitor monitor) {
		 _monitor = monitor;
	 }
	 public void windowClosing(WindowEvent ev) {
		 _monitor.requestClose();
	 }
 }
}",1,0,0,0
"class DFSClient implements FSConstants {
	 public static final Logger LOG = LogFormatter.getLogger(""org.apache.hadoop.fs.DFSClient"");
	 static int MAX_BLOCK_ACQUIRE_FAILURES = 3;
	 ClientProtocol namenode;
	 String localName;
	 boolean running = true;
	 Random r = new Random();
	 String clientName;
	 Daemon leaseChecker;
	 private Configuration conf;
	 static {
		 new DFSFileInfo();
	 }
	 private TreeMap pendingCreates = new TreeMap();
	 private static class ClientFinalizer extends Thread {
		 private List clients = new ArrayList();
		 public synchronized void addClient(DFSClient client) {
			 clients.add(client);
		 }
		 public synchronized void run() {
			 Iterator itr = clients.iterator();
			 while (itr.hasNext()) {
				 DFSClient client = (DFSClient) itr.next();
				 if (client.running) {
					 try {
						 client.close();
					 }
					 catch (IOException ie) {
						 System.err.println(""Error closing client"");
						 ie.printStackTrace();
					 }
				 }
			 }
		 }
	 }
	 private static ClientFinalizer clientFinalizer = new ClientFinalizer();
	 static {
		 Runtime.getRuntime().addShutdownHook(clientFinalizer);
	 }
	 public DFSClient(InetSocketAddress nameNodeAddr, Configuration conf) {
		 this.conf = conf;
		 this.namenode = (ClientProtocol) RPC.getProxy(ClientProtocol.class, nameNodeAddr, conf);
		 try {
			 this.localName = InetAddress.getLocalHost().getHostName();
		 }
		 catch (UnknownHostException uhe) {
			 this.localName = """";
		 }
		 String taskId = conf.get(""mapred.task.id"");
		 if (taskId != null) {
			 this.clientName = ""DFSClient_"" + taskId;
		 }
		 else {
			 this.clientName = ""DFSClient_"" + r.nextInt();
		 }
		 this.leaseChecker = new Daemon(new LeaseChecker());
		 this.leaseChecker.start();
	 }
	 private void checkOpen() throws IOException {
		 if (!running) {
			 IOException result = new IOException(""Filesystem closed"");
			 throw result;
		 }
	 }
	 public void close() throws IOException {
		 synchronized (this) {
			 checkOpen();
			 synchronized (pendingCreates) {
				 Iterator file_itr = pendingCreates.keySet().iterator();
				 while (file_itr.hasNext()) {
					 String name = (String) file_itr.next();
					 try {
						 namenode.abandonFileInProgress(name, clientName);
					 }
					 catch (IOException ie) {
						 System.err.println(""Exception abandoning create lock on "" + name);
						 ie.printStackTrace();
					 }
				 }
				 pendingCreates.clear();
			 }
			 this.running = false;
			 try {
				 leaseChecker.join();
			 }
			 catch (InterruptedException ie) {
			 }
		 }
	 }
	 public String[][] getHints(UTF8 src, long start, long len) throws IOException {
		 return namenode.getHints(src.toString(), start, len);
	 }
	 public FSInputStream open(UTF8 src) throws IOException {
		 checkOpen();
		 return new DFSInputStream(src.toString());
	 }
	 public FSOutputStream create( UTF8 src, boolean overwrite ) throws IOException {
		 return create( src, overwrite, (short)conf.getInt(""dfs.replication"", 3));
	 }
	 public FSOutputStream create( UTF8 src, boolean overwrite, short replication ) throws IOException {
		 checkOpen();
		 FSOutputStream result = new DFSOutputStream(src, overwrite, replication);
		 synchronized (pendingCreates) {
			 pendingCreates.put(src.toString(), result);
		 }
		 return result;
	 }
	 public boolean setReplication(UTF8 src, short replication ) throws IOException {
		 return namenode.setReplication(src.toString(), replication);
	 }
	 public boolean rename(UTF8 src, UTF8 dst) throws IOException {
		 checkOpen();
		 return namenode.rename(src.toString(), dst.toString());
	 }
	 public boolean delete(UTF8 src) throws IOException {
		 checkOpen();
		 return namenode.delete(src.toString());
	 }
	 public boolean exists(UTF8 src) throws IOException {
		 checkOpen();
		 return namenode.exists(src.toString());
	 }
	 public boolean isDirectory(UTF8 src) throws IOException {
		 checkOpen();
		 return namenode.isDir(src.toString());
	 }
	 public DFSFileInfo[] listPaths(UTF8 src) throws IOException {
		 checkOpen();
		 return namenode.getListing(src.toString());
	 }
	 public long totalRawCapacity() throws IOException {
		 long rawNums[] = namenode.getStats();
		 return rawNums[0];
	 }
	 public long totalRawUsed() throws IOException {
		 long rawNums[] = namenode.getStats();
		 return rawNums[1];
	 }
	 public DatanodeInfo[] datanodeReport() throws IOException {
		 return namenode.getDatanodeReport();
	 }
	 public boolean mkdirs(UTF8 src) throws IOException {
		 checkOpen();
		 return namenode.mkdirs(src.toString());
	 }
	 public void lock(UTF8 src, boolean exclusive) throws IOException {
		 long start = System.currentTimeMillis();
		 boolean hasLock = false;
		 while (! hasLock) {
			 hasLock = namenode.obtainLock(src.toString(), clientName, exclusive);
			 if (! hasLock) {
				 try {
					 Thread.sleep(400);
					 if (System.currentTimeMillis() - start > 5000) {
						 LOG.info(""Waiting to retry lock for "" + (System.currentTimeMillis() - start) + "" ms."");
						 Thread.sleep(2000);
					 }
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 public void release(UTF8 src) throws IOException {
		 boolean hasReleased = false;
		 while (! hasReleased) {
			 hasReleased = namenode.releaseLock(src.toString(), clientName);
			 if (! hasReleased) {
				 LOG.info(""Could not release. Retrying..."");
				 try {
					 Thread.sleep(2000);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 private DatanodeInfo bestNode(DatanodeInfo nodes[], TreeSet deadNodes) throws IOException {
		 if ((nodes == null) || (nodes.length - deadNodes.size() < 1)) {
			 throw new IOException(""No live nodes contain current block"");
		 }
		 DatanodeInfo chosenNode = null;
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (deadNodes.contains(nodes[i])) {
				 continue;
			 }
			 String nodename = nodes[i].getName().toString();
			 int colon = nodename.indexOf(':');
			 if (colon >= 0) {
				 nodename = nodename.substring(0, colon);
			 }
			 if (localName.equals(nodename)) {
				 chosenNode = nodes[i];
				 break;
			 }
		 }
		 if (chosenNode == null) {
			 do {
				 chosenNode = nodes[Math.abs(r.nextInt()) % nodes.length];
			 }
			 while (deadNodes.contains(chosenNode));
		 }
		 return chosenNode;
	 }
	 class LeaseChecker implements Runnable {
		 public void run() {
			 long lastRenewed = 0;
			 while (running) {
				 if (System.currentTimeMillis() - lastRenewed > (LEASE_PERIOD / 2)) {
					 try {
						 namenode.renewLease(clientName);
						 lastRenewed = System.currentTimeMillis();
					 }
					 catch (IOException ie) {
						 String err = StringUtils.stringifyException(ie);
						 LOG.warning(""Problem renewing lease for "" + clientName + "": "" + err);
					 }
				 }
				 try {
					 Thread.sleep(1000);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 class DFSInputStream extends FSInputStream {
		 private Socket s = null;
		 boolean closed = false;
		 private String src;
		 private DataInputStream blockStream;
		 private Block blocks[] = null;
		 private DatanodeInfo nodes[][] = null;
		 private long pos = 0;
		 private long filelen = 0;
		 private long blockEnd = -1;
		 public DFSInputStream(String src) throws IOException {
			 this.src = src;
			 openInfo();
			 this.blockStream = null;
			 for (int i = 0;
			 i < blocks.length;
			 i++) {
				 this.filelen += blocks[i].getNumBytes();
			 }
		 }
		 void openInfo() throws IOException {
			 Block oldBlocks[] = this.blocks;
			 LocatedBlock results[] = namenode.open(src);
			 Vector blockV = new Vector();
			 Vector nodeV = new Vector();
			 for (int i = 0;
			 i < results.length;
			 i++) {
				 blockV.add(results[i].getBlock());
				 nodeV.add(results[i].getLocations());
			 }
			 Block newBlocks[] = (Block[]) blockV.toArray(new Block[blockV.size()]);
			 if (oldBlocks != null) {
				 for (int i = 0;
				 i < oldBlocks.length;
				 i++) {
					 if (! oldBlocks[i].equals(newBlocks[i])) {
						 throw new IOException(""Blocklist for "" + src + "" has changed!"");
					 }
				 }
				 if (oldBlocks.length != newBlocks.length) {
					 throw new IOException(""Blocklist for "" + src + "" now has different length"");
				 }
			 }
			 this.blocks = newBlocks;
			 this.nodes = (DatanodeInfo[][]) nodeV.toArray(new DatanodeInfo[nodeV.size()][]);
		 }
		 private synchronized void blockSeekTo(long target) throws IOException {
			 if (target >= filelen) {
				 throw new IOException(""Attempted to read past end of file"");
			 }
			 if (s != null) {
				 s.close();
				 s = null;
			 }
			 int targetBlock = -1;
			 long targetBlockStart = 0;
			 long targetBlockEnd = 0;
			 for (int i = 0;
			 i < blocks.length;
			 i++) {
				 long blocklen = blocks[i].getNumBytes();
				 targetBlockEnd = targetBlockStart + blocklen - 1;
				 if (target >= targetBlockStart && target <= targetBlockEnd) {
					 targetBlock = i;
					 break;
				 }
				 else {
					 targetBlockStart = targetBlockEnd + 1;
				 }
			 }
			 if (targetBlock < 0) {
				 throw new IOException(""Impossible situation: could not find target position "" + target);
			 }
			 long offsetIntoBlock = target - targetBlockStart;
			 int failures = 0;
			 InetSocketAddress targetAddr = null;
			 TreeSet deadNodes = new TreeSet();
			 while (s == null) {
				 DatanodeInfo chosenNode;
				 try {
					 chosenNode = bestNode(nodes[targetBlock], deadNodes);
					 targetAddr = DataNode.createSocketAddr(chosenNode.getName().toString());
				 }
				 catch (IOException ie) {
					 String blockInfo = blocks[targetBlock]+"" file=""+src+"" offset=""+target;
					 if (failures >= MAX_BLOCK_ACQUIRE_FAILURES) {
						 throw new IOException(""Could not obtain block: "" + blockInfo);
					 }
					 if (nodes[targetBlock] == null || nodes[targetBlock].length == 0) {
						 LOG.info(""No node available for block: "" + blockInfo);
					 }
					 LOG.info(""Could not obtain block from any node: "" + ie);
					 try {
						 Thread.sleep(3000);
					 }
					 catch (InterruptedException iex) {
					 }
					 deadNodes.clear();
					 openInfo();
					 failures++;
					 continue;
				 }
				 try {
					 s = new Socket();
					 s.connect(targetAddr, READ_TIMEOUT);
					 s.setSoTimeout(READ_TIMEOUT);
					 DataOutputStream out = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
					 out.write(OP_READSKIP_BLOCK);
					 blocks[targetBlock].write(out);
					 out.writeLong(offsetIntoBlock);
					 out.flush();
					 DataInputStream in = new DataInputStream(new BufferedInputStream(s.getInputStream()));
					 long curBlockSize = in.readLong();
					 long amtSkipped = in.readLong();
					 if (curBlockSize != blocks[targetBlock].len) {
						 throw new IOException(""Recorded block size is "" + blocks[targetBlock].len + "", but datanode reports size of "" + curBlockSize);
					 }
					 if (amtSkipped != offsetIntoBlock) {
						 throw new IOException(""Asked for offset of "" + offsetIntoBlock + "", but only received offset of "" + amtSkipped);
					 }
					 this.pos = target;
					 this.blockEnd = targetBlockEnd;
					 this.blockStream = in;
				 }
				 catch (IOException ex) {
					 LOG.info(""Failed to connect to "" + targetAddr + "":"" + ex);
					 deadNodes.add(chosenNode);
					 if (s != null) {
						 try {
							 s.close();
						 }
						 catch (IOException iex) {
						 }
					 }
					 s = null;
				 }
			 }
		 }
		 public synchronized void close() throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 if (s != null) {
				 blockStream.close();
				 s.close();
				 s = null;
			 }
			 super.close();
			 closed = true;
		 }
		 public synchronized int read() throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 int result = -1;
			 if (pos < filelen) {
				 if (pos > blockEnd) {
					 blockSeekTo(pos);
				 }
				 result = blockStream.read();
				 if (result >= 0) {
					 pos++;
				 }
			 }
			 return result;
		 }
		 public synchronized int read(byte buf[], int off, int len) throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 if (pos < filelen) {
				 if (pos > blockEnd) {
					 blockSeekTo(pos);
				 }
				 int result = blockStream.read(buf, off, Math.min(len, (int) (blockEnd - pos + 1)));
				 if (result >= 0) {
					 pos += result;
				 }
				 return result;
			 }
			 return -1;
		 }
		 public synchronized void seek(long targetPos) throws IOException {
			 if (targetPos >= filelen) {
				 throw new IOException(""Cannot seek after EOF"");
			 }
			 pos = targetPos;
			 blockEnd = -1;
		 }
		 public synchronized long getPos() throws IOException {
			 return pos;
		 }
		 public synchronized int available() throws IOException {
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 return (int) (filelen - pos);
		 }
		 public boolean markSupported() {
			 return false;
		 }
		 public void mark(int readLimit) {
		 }
		 public void reset() throws IOException {
			 throw new IOException(""Mark not supported"");
		 }
	 }
	 class DFSOutputStream extends FSOutputStream {
		 private Socket s;
		 boolean closed = false;
		 private byte outBuf[] = new byte[BUFFER_SIZE];
		 private int pos = 0;
		 private UTF8 src;
		 private boolean overwrite;
		 private short replication;
		 private boolean firstTime = true;
		 private DataOutputStream blockStream;
		 private DataInputStream blockReplyStream;
		 private File backupFile;
		 private OutputStream backupStream;
		 private Block block;
		 private long filePos = 0;
		 private int bytesWrittenToBlock = 0;
		 private String datanodeName;
		 public DFSOutputStream(UTF8 src, boolean overwrite, short replication) throws IOException {
			 this.src = src;
			 this.overwrite = overwrite;
			 this.replication = replication;
			 this.backupFile = newBackupFile();
			 this.backupStream = new FileOutputStream(backupFile);
		 }
		 private File newBackupFile() throws IOException {
			 File result = conf.getFile(""dfs.data.dir"", ""tmp""+File.separator+ ""client-""+Math.abs(r.nextLong()));
			 result.deleteOnExit();
			 return result;
		 }
		 private synchronized void nextBlockOutputStream() throws IOException {
			 boolean retry = false;
			 long startTime = System.currentTimeMillis();
			 do {
				 retry = false;
				 LocatedBlock lb;
				 if (firstTime) {
					 lb = locateNewBlock();
				 }
				 else {
					 lb = locateFollowingBlock(startTime);
				 }
				 block = lb.getBlock();
				 DatanodeInfo nodes[] = lb.getLocations();
				 InetSocketAddress target = DataNode.createSocketAddr(nodes[0].getName().toString());
				 try {
					 s = new Socket();
					 s.connect(target, READ_TIMEOUT);
					 s.setSoTimeout(replication * READ_TIMEOUT);
					 datanodeName = nodes[0].getName().toString();
				 }
				 catch (IOException ie) {
					 try {
						 if (System.currentTimeMillis() - startTime > 5000) {
							 LOG.info(""Waiting to find target node: "" + target);
						 }
						 Thread.sleep(6000);
					 }
					 catch (InterruptedException iex) {
					 }
					 if (firstTime) {
						 namenode.abandonFileInProgress(src.toString(), clientName);
					 }
					 else {
						 namenode.abandonBlock(block, src.toString());
					 }
					 retry = true;
					 continue;
				 }
				 DataOutputStream out = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
				 out.write(OP_WRITE_BLOCK);
				 out.writeBoolean(false);
				 block.write(out);
				 out.writeInt(nodes.length);
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 nodes[i].write(out);
				 }
				 out.write(CHUNKED_ENCODING);
				 bytesWrittenToBlock = 0;
				 blockStream = out;
				 blockReplyStream = new DataInputStream(new BufferedInputStream(s.getInputStream()));
			 }
			 while (retry);
			 firstTime = false;
		 }
		 private LocatedBlock locateNewBlock() throws IOException {
			 int retries = 3;
			 while (true) {
				 while (true) {
					 try {
						 return namenode.create(src.toString(), clientName.toString(), localName, overwrite, replication);
					 }
					 catch (RemoteException e) {
						 if (--retries == 0 || ""org.apache.hadoop.dfs.NameNode.AlreadyBeingCreatedException"". equals(e.getClassName())) {
							 throw e;
						 }
						 else {
							 LOG.info(StringUtils.stringifyException(e));
							 try {
								 Thread.sleep(LEASE_PERIOD);
							 }
							 catch (InterruptedException ie) {
							 }
						 }
					 }
				 }
			 }
		 }
		 private LocatedBlock locateFollowingBlock(long start ) throws IOException {
			 int retries = 5;
			 while (true) {
				 long localstart = System.currentTimeMillis();
				 while (true) {
					 try {
						 return namenode.addBlock(src.toString(), clientName.toString());
					 }
					 catch (RemoteException e) {
						 if (--retries == 0 || ""org.apache.hadoop.dfs.NameNode.NotReplicatedYetException"". equals(e.getClassName())) {
							 throw e;
						 }
						 else {
							 LOG.info(StringUtils.stringifyException(e));
							 if (System.currentTimeMillis() - localstart > 5000) {
								 LOG.info(""Waiting for replication for "" + (System.currentTimeMillis() - localstart)/1000 + "" seconds"");
							 }
							 try {
								 Thread.sleep(400);
							 }
							 catch (InterruptedException ie) {
							 }
						 }
					 }
				 }
			 }
		 }
		 public synchronized long getPos() throws IOException {
			 return filePos;
		 }
		 public synchronized void write(int b) throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 if ((bytesWrittenToBlock + pos == BLOCK_SIZE) || (pos >= BUFFER_SIZE)) {
				 flush();
			 }
			 outBuf[pos++] = (byte) b;
			 filePos++;
		 }
		 public synchronized void write(byte b[], int off, int len) throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 while (len > 0) {
				 int remaining = BUFFER_SIZE - pos;
				 int toWrite = Math.min(remaining, len);
				 System.arraycopy(b, off, outBuf, pos, toWrite);
				 pos += toWrite;
				 off += toWrite;
				 len -= toWrite;
				 filePos += toWrite;
				 if ((bytesWrittenToBlock + pos >= BLOCK_SIZE) || (pos == BUFFER_SIZE)) {
					 flush();
				 }
			 }
		 }
		 public synchronized void flush() throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 if (bytesWrittenToBlock + pos >= BLOCK_SIZE) {
				 flushData(BLOCK_SIZE - bytesWrittenToBlock);
			 }
			 if (bytesWrittenToBlock == BLOCK_SIZE) {
				 endBlock();
			 }
			 flushData(pos);
		 }
		 private synchronized void flushData(int maxPos) throws IOException {
			 int workingPos = Math.min(pos, maxPos);
			 if (workingPos > 0) {
				 backupStream.write(outBuf, 0, workingPos);
				 bytesWrittenToBlock += workingPos;
				 System.arraycopy(outBuf, workingPos, outBuf, 0, pos - workingPos);
				 pos -= workingPos;
			 }
		 }
		 private synchronized void endBlock() throws IOException {
			 backupStream.close();
			 boolean sentOk = false;
			 int remainingAttempts = conf.getInt(""dfs.client.block.write.retries"", 3);
			 while (!sentOk) {
				 nextBlockOutputStream();
				 InputStream in = new FileInputStream(backupFile);
				 try {
					 byte buf[] = new byte[BUFFER_SIZE];
					 int bytesRead = in.read(buf);
					 while (bytesRead > 0) {
						 blockStream.writeLong((long) bytesRead);
						 blockStream.write(buf, 0, bytesRead);
						 bytesRead = in.read(buf);
					 }
					 internalClose();
					 sentOk = true;
				 }
				 catch (IOException ie) {
					 handleSocketException(ie);
					 remainingAttempts -= 1;
					 if (remainingAttempts == 0) {
						 throw ie;
					 }
				 }
				 finally {
					 in.close();
				 }
			 }
			 backupFile.delete();
			 backupFile = newBackupFile();
			 backupStream = new FileOutputStream(backupFile);
			 bytesWrittenToBlock = 0;
		 }
		 private synchronized void internalClose() throws IOException {
			 try {
				 blockStream.writeLong(0);
				 blockStream.flush();
				 long complete = blockReplyStream.readLong();
				 if (complete != WRITE_COMPLETE) {
					 LOG.info(""Did not receive WRITE_COMPLETE flag: "" + complete);
					 throw new IOException(""Did not receive WRITE_COMPLETE_FLAG: "" + complete);
				 }
			 }
			 catch (IOException ie) {
				 throw (IOException) new IOException(""failure closing block of file "" + src.toString() + "" to node "" + (datanodeName == null ? ""?"" : datanodeName) ).initCause(ie);
			 }
			 LocatedBlock lb = new LocatedBlock();
			 lb.readFields(blockReplyStream);
			 namenode.reportWrittenBlock(lb);
			 s.close();
			 s = null;
		 }
		 private void handleSocketException(IOException ie) throws IOException {
			 LOG.log(Level.WARNING, ""Error while writing."", ie);
			 try {
				 if (s != null) {
					 s.close();
					 s = null;
				 }
			 }
			 catch (IOException ie2) {
				 LOG.log(Level.WARNING, ""Error closing socket."", ie2);
			 }
			 namenode.abandonBlock(block, src.toString());
		 }
		 public synchronized void close() throws IOException {
			 checkOpen();
			 if (closed) {
				 throw new IOException(""Stream closed"");
			 }
			 try {
				 flush();
				 if (filePos == 0 || bytesWrittenToBlock != 0) {
					 try {
						 endBlock();
					 }
					 catch (IOException e) {
						 namenode.abandonFileInProgress(src.toString(), clientName);
						 throw e;
					 }
				 }
				 backupStream.close();
				 backupFile.delete();
				 if (s != null) {
					 s.close();
					 s = null;
				 }
				 super.close();
				 long localstart = System.currentTimeMillis();
				 boolean fileComplete = false;
				 while (! fileComplete) {
					 fileComplete = namenode.complete(src.toString(), clientName.toString());
					 if (!fileComplete) {
						 try {
							 Thread.sleep(400);
							 if (System.currentTimeMillis() - localstart > 5000) {
								 LOG.info(""Could not complete file, retrying..."");
							 }
						 }
						 catch (InterruptedException ie) {
						 }
					 }
				 }
				 closed = true;
			 }
			 finally {
				 synchronized (pendingCreates) {
					 pendingCreates.remove(src.toString());
				 }
			 }
		 }
	 }
}",1,0,0,0
"private static void doSubdivide(TriangleMesh mesh, Vertex vertex[], Edge edge[], Face face[], boolean split[], Vertex newvert[], Edge newedge[], Face newface[], double oldParamValue[][][], double newParamValue[][][], int paramType[]) {
	 Edge tempEdge;
	 Face tempFace;
	 int i, j, k, n, v1, v2, v3, e1, e2, e3, newEdgeIndex[] = new int [edge.length];
	 j = edge.length;
	 k = vertex.length;
	 for (i = 0;
	 i < edge.length;
	 i++) {
		 tempEdge = edge[i];
		 v1 = tempEdge.v1;
		 v2 = tempEdge.v2;
		 if (!split[i]) {
			 newedge[i] = mesh.new Edge(v1, v2, -1);
			 newedge[i].smoothness = tempEdge.smoothness;
			 if (vertex[v1].firstEdge == i) newvert[v1].firstEdge = i;
			 if (vertex[v2].firstEdge == i) newvert[v2].firstEdge = i;
			 newEdgeIndex[i] = i;
			 continue;
		 }
		 newedge[i] = mesh.new Edge(v1, k, -1);
		 newedge[j] = mesh.new Edge(v2, k, -1);
		 newedge[i].smoothness = newedge[j].smoothness = tempEdge.smoothness;
		 if (vertex[v1].firstEdge == i) newvert[v1].firstEdge = i;
		 if (vertex[v2].firstEdge == i) newvert[v2].firstEdge = j;
		 newvert[k].firstEdge = i;
		 newEdgeIndex[i] = j++;
		 k++;
	 }
	 int addedFace[] = new int [4];
	 k = face.length;
	 for (i = 0;
	 i < face.length;
	 i++) {
		 tempFace = face[i];
		 if (split[tempFace.e1]) {
			 if (split[tempFace.e2]) {
				 if (split[tempFace.e3]) {
					 n = 3;
					 v1 = tempFace.v1;
					 v2 = tempFace.v2;
					 v3 = tempFace.v3;
					 e1 = tempFace.e1;
					 e2 = tempFace.e2;
					 e3 = tempFace.e3;
				 }
				 else {
					 n = 2;
					 v1 = tempFace.v1;
					 v2 = tempFace.v2;
					 v3 = tempFace.v3;
					 e1 = tempFace.e1;
					 e2 = tempFace.e2;
					 e3 = tempFace.e3;
				 }
			 }
			 else {
				 if (split[tempFace.e3]) {
					 n = 2;
					 v1 = tempFace.v3;
					 v2 = tempFace.v1;
					 v3 = tempFace.v2;
					 e1 = tempFace.e3;
					 e2 = tempFace.e1;
					 e3 = tempFace.e2;
				 }
				 else {
					 n = 1;
					 v1 = tempFace.v1;
					 v2 = tempFace.v2;
					 v3 = tempFace.v3;
					 e1 = tempFace.e1;
					 e2 = tempFace.e2;
					 e3 = tempFace.e3;
				 }
			 }
		 }
		 else {
			 if (split[tempFace.e2]) {
				 if (split[tempFace.e3]) {
					 n = 2;
					 v1 = tempFace.v2;
					 v2 = tempFace.v3;
					 v3 = tempFace.v1;
					 e1 = tempFace.e2;
					 e2 = tempFace.e3;
					 e3 = tempFace.e1;
				 }
				 else {
					 n = 1;
					 v1 = tempFace.v2;
					 v2 = tempFace.v3;
					 v3 = tempFace.v1;
					 e1 = tempFace.e2;
					 e2 = tempFace.e3;
					 e3 = tempFace.e1;
				 }
			 }
			 else {
				 if (split[tempFace.e3]) {
					 n = 1;
					 v1 = tempFace.v3;
					 v2 = tempFace.v1;
					 v3 = tempFace.v2;
					 e1 = tempFace.e3;
					 e2 = tempFace.e1;
					 e3 = tempFace.e2;
				 }
				 else {
					 n = 0;
					 v1 = tempFace.v1;
					 v2 = tempFace.v2;
					 v3 = tempFace.v3;
					 e1 = tempFace.e1;
					 e2 = tempFace.e2;
					 e3 = tempFace.e3;
				 }
			 }
		 }
		 switch (n) {
			 case 0: newface[i] = mesh.new Face(v1, v2, v3, e1, e2, e3);
			 break;
			 case 1: newedge[j] = mesh.new Edge(v3, newedge[e1].v2, -1);
			 if (edge[e1].v1 == v1) {
				 newface[i] = mesh.new Face(v1, newedge[e1].v2, v3, e1, j, e3);
				 newface[k] = mesh.new Face(v3, newedge[e1].v2, v2, j, newEdgeIndex[e1], e2);
			 }
			 else {
				 newface[i] = mesh.new Face(v1, newedge[e1].v2, v3, newEdgeIndex[e1], j, e3);
				 newface[k] = mesh.new Face(v3, newedge[e1].v2, v2, j, e1, e2);
			 }
			 break;
			 case 2: newedge[j] = mesh.new Edge(newedge[e1].v2, newedge[e2].v2, -1);
			 newedge[j+1] = mesh.new Edge(v3, newedge[e1].v2, -1);
			 if (edge[e1].v1 == v1) {
				 if (edge[e2].v1 == v2) {
					 newface[i] = mesh.new Face(v1, newedge[e1].v2, v3, e1, j+1, e3);
					 newface[k] = mesh.new Face(v3, newedge[e1].v2, newedge[e2].v2, j+1, j, newEdgeIndex[e2]);
					 newface[k+1] = mesh.new Face(newedge[e2].v2, newedge[e1].v2, v2, j, newEdgeIndex[e1], e2);
				 }
				 else {
					 newface[i] = mesh.new Face(v1, newedge[e1].v2, v3, e1, j+1, e3);
					 newface[k] = mesh.new Face(v3, newedge[e1].v2, newedge[e2].v2, j+1, j, e2);
					 newface[k+1] = mesh.new Face(newedge[e2].v2, newedge[e1].v2, v2, j, newEdgeIndex[e1], newEdgeIndex[e2]);
				 }
			 }
			 else {
				 if (edge[e2].v1 == v2) {
					 newface[i] = mesh.new Face(v1, newedge[e1].v2, v3, newEdgeIndex[e1], j+1, e3);
					 newface[k] = mesh.new Face(v3, newedge[e1].v2, newedge[e2].v2, j+1, j, newEdgeIndex[e2]);
					 newface[k+1] = mesh.new Face(newedge[e2].v2, newedge[e1].v2, v2, j, e1, e2);
				 }
				 else {
					 newface[i] = mesh.new Face(v1, newedge[e1].v2, v3, newEdgeIndex[e1], j+1, e3);
					 newface[k] = mesh.new Face(v3, newedge[e1].v2, newedge[e2].v2, j+1, j, e2);
					 newface[k+1] = mesh.new Face(newedge[e2].v2, newedge[e1].v2, v2, j, e1, newEdgeIndex[e2]);
				 }
			 }
			 break;
			 case 3: newedge[j] = mesh.new Edge(newedge[e1].v2, newedge[e2].v2, -1);
			 newedge[j+1] = mesh.new Edge(newedge[e2].v2, newedge[e3].v2, -1);
			 newedge[j+2] = mesh.new Edge(newedge[e3].v2, newedge[e1].v2, -1);
			 if (edge[e1].v1 == v1) {
				 if (edge[e2].v1 == v2) {
					 if (edge[e3].v1 == v3) {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, e1, j+2, newEdgeIndex[e3]);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, e2, j, newEdgeIndex[e1]);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, e3, j+1, newEdgeIndex[e2]);
					 }
					 else {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, e1, j+2, e3);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, e2, j, newEdgeIndex[e1]);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, newEdgeIndex[e3], j+1, newEdgeIndex[e2]);
					 }
				 }
				 else {
					 if (edge[e3].v1 == v3) {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, e1, j+2, newEdgeIndex[e3]);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, newEdgeIndex[e2], j, newEdgeIndex[e1]);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, e3, j+1, e2);
					 }
					 else {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, e1, j+2, e3);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, newEdgeIndex[e2], j, newEdgeIndex[e1]);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, newEdgeIndex[e3], j+1, e2);
					 }
				 }
			 }
			 else {
				 if (edge[e2].v1 == v2) {
					 if (edge[e3].v1 == v3) {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, newEdgeIndex[e1], j+2, newEdgeIndex[e3]);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, e2, j, e1);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, e3, j+1, newEdgeIndex[e2]);
					 }
					 else {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, newEdgeIndex[e1], j+2, e3);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, e2, j, e1);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, newEdgeIndex[e3], j+1, newEdgeIndex[e2]);
					 }
				 }
				 else {
					 if (edge[e3].v1 == v3) {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, newEdgeIndex[e1], j+2, newEdgeIndex[e3]);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, newEdgeIndex[e2], j, e1);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, e3, j+1, e2);
					 }
					 else {
						 newface[i] = mesh.new Face(v1, newedge[e1].v2, newedge[e3].v2, newEdgeIndex[e1], j+2, e3);
						 newface[k] = mesh.new Face(v2, newedge[e2].v2, newedge[e1].v2, newEdgeIndex[e2], j, e1);
						 newface[k+1] = mesh.new Face(v3, newedge[e3].v2, newedge[e2].v2, newEdgeIndex[e3], j+1, e2);
					 }
				 }
			 }
			 newface[k+2] = mesh.new Face(newedge[e1].v2, newedge[e2].v2, newedge[e3].v2, j, j+1, j+2);
		 }
		 int numAddedFaces = n+1;
		 addedFace[0] = i;
		 for (int m = 0;
		 m < n;
		 m++) addedFace[m+1] = k+m;
		 for (int p = 0;
		 p < paramType.length;
		 p++) {
			 if (paramType[p] == PER_FACE) for (int m = 0;
			 m < numAddedFaces;
			 m++) newParamValue[p][0][addedFace[m]] = oldParamValue[p][0][i];
			 else if (paramType[p] == PER_FACE_VERTEX) {
				 int vertInd[] = new int [] {
				v1, v2, v3, -1, -1, -1}
				;
				 if (n > 0) vertInd[3] = newedge[e1].v2;
				 if (n > 1) vertInd[4] = newedge[e2].v2;
				 if (n > 2) vertInd[5] = newedge[e3].v2;
				 double vertVal[];
				 if (v1 == tempFace.v1) vertVal = new double [] {
				oldParamValue[p][0][i], oldParamValue[p][1][i], oldParamValue[p][2][i], 0.5*(oldParamValue[p][0][i]+oldParamValue[p][1][i]), 0.5*(oldParamValue[p][1][i]+oldParamValue[p][2][i]), 0.5*(oldParamValue[p][2][i]+oldParamValue[p][0][i])}
				;
				 else if (v1 == tempFace.v2) vertVal = new double [] {
				oldParamValue[p][1][i], oldParamValue[p][2][i], oldParamValue[p][0][i], 0.5*(oldParamValue[p][1][i]+oldParamValue[p][2][i]), 0.5*(oldParamValue[p][2][i]+oldParamValue[p][0][i]), 0.5*(oldParamValue[p][0][i]+oldParamValue[p][1][i])}
				;
				 else vertVal = new double [] {
				oldParamValue[p][2][i], oldParamValue[p][0][i], oldParamValue[p][1][i], 0.5*(oldParamValue[p][2][i]+oldParamValue[p][0][i]), 0.5*(oldParamValue[p][0][i]+oldParamValue[p][1][i]), 0.5*(oldParamValue[p][1][i]+oldParamValue[p][2][i])}
				;
				 for (int m = 0;
				 m < numAddedFaces;
				 m++) {
					 Face fc = newface[addedFace[m]];
					 for (int q = 0;
					 q < 6;
					 q++) {
						 if (fc.v1 == vertInd[q]) newParamValue[p][0][addedFace[m]] = vertVal[q];
						 else if (fc.v2 == vertInd[q]) newParamValue[p][1][addedFace[m]] = vertVal[q];
						 else if (fc.v3 == vertInd[q]) newParamValue[p][2][addedFace[m]] = vertVal[q];
					 }
				 }
			 }
		 }
		 j += n;
		 k += n;
	 }
	 for (i = 0;
	 i < newface.length;
	 i++) {
		 tempFace = newface[i];
		 if (newedge[tempFace.e1].f1 == -1) newedge[tempFace.e1].f1 = i;
		 else newedge[tempFace.e1].f2 = i;
		 if (newedge[tempFace.e2].f1 == -1) newedge[tempFace.e2].f1 = i;
		 else newedge[tempFace.e2].f2 = i;
		 if (newedge[tempFace.e3].f1 == -1) newedge[tempFace.e3].f1 = i;
		 else newedge[tempFace.e3].f2 = i;
	 }
	 for (i = 0;
	 i < newvert.length;
	 i++) newvert[i].edges = 0;
	 for (i = 0;
	 i < newedge.length;
	 i++) {
		 newvert[newedge[i].v1].edges++;
		 newvert[newedge[i].v2].edges++;
	 }
 }",0,0,1,0
"public class TeamContext {
	 private String project;
	 private UUID projectId;
	 private String team;
	 private UUID teamId;
	 public String getProject() {
		 return project;
	 }
	 public void setProject(final String project) {
		 this.project = project;
	 }
	 public UUID getProjectId() {
		 return projectId;
	 }
	 public void setProjectId(final UUID projectId) {
		 this.projectId = projectId;
	 }
	 public String getTeam() {
		 return team;
	 }
	 public void setTeam(final String team) {
		 this.team = team;
	 }
	 public UUID getTeamId() {
		 return teamId;
	 }
	 public void setTeamId(final UUID teamId) {
		 this.teamId = teamId;
	 }
}",0,1,0,0
"private void init() {
	try {
		setUndecorated(true);
		setSize(250, 40);
		setIconImage(ImageResource.get(""icon.png"").getImage());
		setFocusableWindowState(false);
		setType(Type.UTILITY);
		setAlwaysOnTop(true);
		try {
			if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
				setOpacity(0.85f);
			}
		}
		 catch (Exception e) {
			Logger.log(e);
		}
		panel = new JPanel(new BorderLayout());
		panel.setBackground(ColorResource.getDarkestBgColor());
		add(panel);
		bottomPanel = new TitlePanel(new BorderLayout(), this);
		bottomPanel.setBorder(new EmptyBorder(0, 20, 0, 0));
		bottomPanel.setOpaque(true);
		bottomPanel.setBackground(ColorResource.getDarkerBgColor());
		panel.add(bottomPanel);
		JButton closeBtn = new CustomButton();
		closeBtn.setPreferredSize(new Dimension(30, 40));
		closeBtn.setMinimumSize(new Dimension(30, 40));
		closeBtn.setBackground(ColorResource.getDarkerBgColor());
		closeBtn.setBorderPainted(false);
		closeBtn.setFocusPainted(false);
		closeBtn.setName(""CLOSE"");
		closeBtn.setIcon(ImageResource.get(""close_btn.png""));
		closeBtn.setMargin(new Insets(0, 0, 0, 0));
		closeBtn.addActionListener(this);
		bottomPanel.add(closeBtn, BorderLayout.EAST);
		JButton popupBtn = new CustomButton();
		popupBtn.setBackground(ColorResource.getDarkerBgColor());
		popupBtn.setFont(FontResource.getItemFont());
		popupBtn.setPreferredSize(new Dimension(200, 40));
		popupBtn.setMinimumSize(new Dimension(200, 40));
		popupBtn.setBorderPainted(false);
		popupBtn.setForeground(Color.WHITE);
		popupBtn.setText(""DOWNLOAD VIDEO"");
		popupBtn.setFocusPainted(false);
		popupBtn.setName(""EXPAND"");
		popupBtn.addActionListener(this);
		bottomPanel.add(popupBtn);
		itemPanel = new JPanel(new BorderLayout());
		itemPanel.setOpaque(false);
		itemListBox = new JList<VideoPopupItem>(videoItems);
		itemListBox.setOpaque(false);
		itemListBox.setCellRenderer(new SimpleListRenderer());
		itemListBox.addMouseMotionListener(new MouseAdapter() {
			public void mouseMoved(MouseEvent me) {
				Point p = new Point(me.getX(), me.getY());
				int index = itemListBox.locationToIndex(p);
				if (index != mHoveredJListIndex) {
					mHoveredJListIndex = index;
					if (mHoveredJListIndex != -1) {
						itemListBox.setSelectedIndex(mHoveredJListIndex);
					}
					 else {
						itemListBox.clearSelection();
					}
				}
			}
			public void mouseExited(MouseEvent e) {
				itemListBox.clearSelection();
				itemListBox.repaint();
			}
		}
		);
		JScrollPane jsp = new JScrollPane();
		jsp.setOpaque(false);
		jsp.setBorder(null);
		jsp.getViewport().setOpaque(false);
		DarkScrollBar scrollBar = new DarkScrollBar(JScrollBar.VERTICAL);
		jsp.setVerticalScrollBar(scrollBar);
		jsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		jsp.getVerticalScrollBar().setUnitIncrement(10);
		jsp.getVerticalScrollBar().setBlockIncrement(25);
		menuBox = Box.createVerticalBox();
		menuBox.add(Box.createVerticalGlue());
		jsp.setViewportView(menuBox);
		itemPanel.add(jsp);
		closePopupBtn = new CustomButton();
		closePopupBtn.setBackground(ColorResource.getDarkerBgColor());
		closePopupBtn.setBorderPainted(false);
		closePopupBtn.setFocusPainted(false);
		closePopupBtn.setName(""COLAPSE"");
		closePopupBtn.addActionListener(this);
	}
	 catch (Exception e) {
		e.printStackTrace();
	}
}",0,0,1,0
"public class TurtleReaderFactory extends AbstractTriplesOnlyReaderFactory {
	 public TurtleReaderFactory() {
		 super(Lang.TURTLE, Lang.TTL, Lang.N3);
	 }
	 public RecordReader<LongWritable, TripleWritable> createTripleReader() {
		 return new TurtleReader();
	 }
}",0,0,0,0
"public void setCacheCapacities(String tableName, String cfName, int keyCacheCapacity, int rowCacheCapacity) {
	 try {
		 String keyCachePath = ""org.apache.cassandra.db:type=Caches,keyspace="" + tableName + "",cache="" + cfName + ""KeyCache"";
		 InstrumentingCacheMBean keyCacheMBean = JMX.newMBeanProxy(mbeanServerConn, new ObjectName(keyCachePath), InstrumentingCacheMBean.class);
		 keyCacheMBean.setCapacity(keyCacheCapacity);
		 String rowCachePath = ""org.apache.cassandra.db:type=Caches,keyspace="" + tableName + "",cache="" + cfName + ""RowCache"";
		 InstrumentingCacheMBean rowCacheMBean = null;
		 rowCacheMBean = JMX.newMBeanProxy(mbeanServerConn, new ObjectName(rowCachePath), InstrumentingCacheMBean.class);
		 rowCacheMBean.setCapacity(rowCacheCapacity);
	 }
	 catch (MalformedObjectNameException e) {
		 throw new RuntimeException(e);
	 }
 }",0,0,0,0
"public class Scanner {
	 private final List<Node> tokens;
	 private int currentPosition = 0;
	 public Scanner(final List<Node> tokens) {
		 this.tokens = tokens;
	 }
	 public NodeSelect scan() {
		 return scanSelect();
	 }
	 public void checkTail() {
		 final int num1 = currentPosition;
		 final NodeItem item1 = nextToken();
		 if ((item1 != null) && (item1.getNodeType() != NodeType.OPERATION || item1.getValue().length() != 0)) {
			 currentPosition = num1;
			 throwSyntaxError(SyntaxError.EXPECTING_END_OF_STRING);
		 }
	 }
	 private NodeSelect scanSelect() {
		 final Node node1 = ensureToken(NodeType.NAME, ""select"", SyntaxError.EXPECTING_SELECT);
		 final NodeSelect select1 = new NodeSelect();
		 if (scanToken(NodeType.OPERATION, ""*"") != null) {
			 select1.setFields(null);
		 }
		 else {
			 select1.setFields(scanFieldNameList(false, NodeType.FIELD_LIST));
		 }
		 while (true) {
			 if (scanToken(NodeType.NAME, ""from"") != null) {
				 if (select1.getFrom() != null) {
					 --currentPosition;
					 throwSyntaxError(SyntaxError.DUPLICATE_FROM);
				 }
				 select1.setFrom(scanTableName());
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""where"") != null) {
				 if (select1.getWhere() != null) {
					 --currentPosition;
					 throwSyntaxError(SyntaxError.DUPLICATE_WHERE);
				 }
				 select1.setWhere(scanWhere(select1.getFrom()));
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""group"") != null) {
				 ensureToken(NodeType.NAME, ""by"", SyntaxError.EXPECTING_BY);
				 if (select1.getGroupBy() != null) {
					 --currentPosition;
					 throwSyntaxError(SyntaxError.DUPLICATE_GROUP_BY);
				 }
				 select1.setGroupBy(scanFieldNameList(false, NodeType.GROUP_FIELD_LIST));
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""order"") != null) {
				 ensureToken(NodeType.NAME, ""by"", SyntaxError.EXPECTING_BY);
				 if (select1.getOrderBy() != null) {
					 --currentPosition;
					 throwSyntaxError(SyntaxError.DUPLICATE_ORDER_BY);
				 }
				 select1.setOrderBy(scanFieldNameList(true, NodeType.ORDER_FIELD_LIST));
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""asof"") != null) {
				 if (select1.getAsOf() != null) {
					 --currentPosition;
					 throwSyntaxError(SyntaxError.DUPLICATE_AS_OF);
				 }
				 select1.setAsOf(scanValue(select1.getFrom()));
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""mode"") != null) {
				 if (select1.getMode() != null) {
					 currentPosition--;
					 throwSyntaxError(SyntaxError.DUPLICATE_MODE);
				 }
				 select1.setMode(ScanMode());
				 continue;
			 }
			 select1.setStartOffset(node1.getStartOffset());
			 select1.setEndOffset(((NodeItem) tokens.get(tokens.size() - 1)).getEndOffset());
			 return select1;
		 }
	 }
	 private Node scanWhere(final NodeTableName table) {
		 return scanCondition4(table);
	 }
	 private Node scanCondition4(final NodeTableName table) {
		 Node node1 = scanCondition3(table);
		 NodeOrOperator operator1 = null;
		 while (true) {
			 Node node2 = scanToken(NodeType.NAME, ""or"");
			 if (node2 == null) {
				 node2 = scanToken(NodeType.OPERATION, ""||"");
			 }
			 if (node2 == null) {
				 break;
			 }
			 if (operator1 == null) {
				 operator1 = new NodeOrOperator();
				 operator1.add(node1);
			 }
			 operator1.add(scanCondition3(table));
		 }
		 if (operator1 != null) {
			 operator1.setStartOffset(operator1.getItem(0).getStartOffset());
			 operator1.setEndOffset(operator1.getItem(operator1.getCount() - 1).getEndOffset());
			 node1 = operator1;
		 }
		 return node1;
	 }
	 private Node scanCondition3(final NodeTableName table) {
		 Node node1 = scanCondition2(table);
		 NodeAndOperator operator1 = null;
		 while (true) {
			 Node node2 = scanToken(NodeType.NAME, ""and"");
			 if (node2 == null) {
				 node2 = scanToken(NodeType.OPERATION, ""&&"");
			 }
			 if (node2 == null) {
				 break;
			 }
			 if (operator1 == null) {
				 operator1 = new NodeAndOperator();
				 operator1.add(node1);
			 }
			 operator1.add(scanCondition2(table));
		 }
		 if (operator1 != null) {
			 operator1.setStartOffset(operator1.getItem(0).getStartOffset());
			 operator1.setEndOffset(operator1.getItem(operator1.getCount() - 1).getEndOffset());
			 node1 = operator1;
		 }
		 return node1;
	 }
	 private Node scanCondition2(final NodeTableName table) {
		 Node node1 = scanToken(NodeType.NAME, ""not"");
		 if (node1 == null) {
			 node1 = scanToken(NodeType.OPERATION, ""!"");
		 }
		 if (node1 != null) {
			 final Node node2 = scanCondition2(table);
			 final Node node3 = new NodeNotOperator(node2);
			 node3.setStartOffset(node1.getStartOffset());
			 node3.setEndOffset(node2.getEndOffset());
			 return node3;
		 }
		 node1 = scanToken(NodeType.NAME, ""ever"");
		 if (node1 != null) {
			 final Node node4 = scanCondition2(table);
			 final Node node5 = new NodeEverOperator(node4);
			 node5.setStartOffset(node1.getStartOffset());
			 node5.setEndOffset(node4.getEndOffset());
			 return node5;
		 }
		 node1 = scanToken(NodeType.NAME, ""never"");
		 if (node1 != null) {
			 final Node node6 = scanCondition2(table);
			 final Node node7 = new NodeNotOperator(new NodeEverOperator(node6));
			 node7.setStartOffset(node1.getStartOffset());
			 node7.setEndOffset(node6.getEndOffset());
			 return node7;
		 }
		 return scanCondition1(table);
	 }
	 private Node scanCondition1(final NodeTableName table) {
		 final Node node1 = scanToken(NodeType.OPERATION, ""("");
		 if (node1 != null) {
			 final Node node2 = scanWhere(table);
			 final Node node3 = ensureToken(NodeType.OPERATION, "")"", SyntaxError.EXPECTING_LEFT_BRACKET);
			 node2.setStartOffset(node1.getStartOffset());
			 node2.setEndOffset(node3.getEndOffset());
			 node2.setHasParantheses(true);
			 return node2;
		 }
		 final NodeCondition condition1 = new NodeCondition();
		 Node node4 = condition1;
		 condition1.setLeft(scanFieldName(table));
		 final Stack<NodeType> stack1 = new Stack<NodeType>();
		 while (true) {
			 if (scanToken(NodeType.NAME, ""not"") != null) {
				 stack1.push(NodeType.NOT);
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""ever"") != null) {
				 stack1.push(NodeType.EVER);
				 continue;
			 }
			 if (scanToken(NodeType.NAME, ""never"") != null) {
				 stack1.push(NodeType.NOT);
				 stack1.push(NodeType.EVER);
				 continue;
			 }
			 break;
		 }
		 while (true) {
			 if (stack1.size() <= 0) {
				 condition1.setCondition(scanConditionOperator(node4 != condition1));
				 if (condition1.getCondition() == Condition.NONE) {
					 throwSyntaxError(SyntaxError.EXPECTING_COMPARISON_OPERATOR);
				 }
				 if (condition1.getCondition() == Condition.GROUP) {
					 condition1.setRight(scanValue(table));
				 }
				 else if (condition1.getCondition() == Condition.IN) {
					 final Node node5 = ensureToken(NodeType.OPERATION, ""("", SyntaxError.EXPECTING_LEFT_BRACKET);
					 final Node node6 = scanValueList(table);
					 final Node node7 = ensureToken(NodeType.OPERATION, "")"", SyntaxError.EXPECTING_RIGHT_BRACKET);
					 node6.setStartOffset(node5.getStartOffset());
					 node6.setEndOffset(node7.getEndOffset());
					 condition1.setRight(node6);
				 }
				 else if (condition1.getCondition() == Condition.UNDER) {
					 condition1.setRight(scanValue(table));
				 }
				 else {
					 Node node8 = TryScanFieldName();
					 if (node8 == null) {
						 node8 = TryScanExpression();
					 }
					 if (node8 != null) {
						 condition1.setRight(node8);
					 }
					 else {
						 throwSyntaxError(SyntaxError.EXPECTING_FIELD_OR_EXPRESSION);
					 }
				 }
				 node4.setStartOffset(condition1.getLeft().getStartOffset());
				 node4.setEndOffset(condition1.getRight().getEndOffset());
				 return node4;
			 }
			 final NodeType nodeType = stack1.pop();
			 if (nodeType == NodeType.NOT) {
				 node4 = new NodeNotOperator(node4);
			 }
			 else if (nodeType == NodeType.EVER) {
				 node4 = new NodeEverOperator(node4);
			 }
		 }
	 }
	 private Node scanValueList(final NodeTableName table) {
		 final NodeValueList list1 = new NodeValueList();
		 do {
			 list1.add(scanExpression(table));
		 }
		 while (scanToken(NodeType.OPERATION, "","") != null);
		 list1.setStartOffset(list1.getItem(0).getStartOffset());
		 list1.setEndOffset(list1.getItem(list1.getCount() - 1).getEndOffset());
		 return list1;
	 }
	 private Node scanValue(final NodeTableName table) {
		 final Node node = TryScanSingleValue();
		 if (node == null) {
			 throwSyntaxError(SyntaxError.EXPECTING_VALUE);
		 }
		 return node;
	 }
	 private Node scanExpression(final NodeTableName nodeTable) {
		 final Node node = TryScanExpression();
		 if (node == null) {
			 throwSyntaxError(SyntaxError.EXPECTING_VALUE);
			 return null;
		 }
		 return node;
	 }
	 private Condition scanConditionOperator(final boolean afterNotOrEver) {
		 final int num1 = currentPosition;
		 final NodeItem item1 = nextToken();
		 if ((item1 != null) && ((item1.getNodeType() == NodeType.NAME) || ((item1.getNodeType() == NodeType.OPERATION) && !afterNotOrEver))) {
			 Condition condition1 = ConditionalOperators.find(item1.getValue());
			 if (condition1 == Condition.IN && scanToken(NodeType.NAME, ""group"") != null) {
				 condition1 = Condition.GROUP;
			 }
			 else if (condition1 == Condition.CONTAINS && scanToken(NodeType.NAME, ""words"") != null) {
				 condition1 = Condition.CONTAINS_WORDS;
			 }
			 if (condition1 != Condition.NONE) {
				 return condition1;
			 }
		 }
		 currentPosition = num1;
		 if (!afterNotOrEver) {
			 return Condition.NONE;
		 }
		 return Condition.EQUALS;
	 }
	 private NodeTableName scanTableName() {
		 final int savedCurrentPosition = currentPosition;
		 final NodeItem tokenNode = nextToken();
		 if (tokenNode != null && tokenNode.getNodeType() == NodeType.NAME) {
			 return new NodeTableName((NodeName) tokenNode);
		 }
		 currentPosition = savedCurrentPosition;
		 throwSyntaxError(SyntaxError.EXPECTING_TABLE_NAME);
		 return null;
	 }
	 private NodeFieldList scanFieldNameList(final boolean direction, final NodeType nodeType) {
		 final NodeFieldList fieldListNode = new NodeFieldList(nodeType);
		 while (true) {
			 final NodeFieldName fieldNameNode = scanFieldName(null);
			 if (direction) {
				 if (scanToken(NodeType.NAME, ""asc"") != null) {
					 fieldNameNode.setDirection(Direction.ASCENDING);
				 }
				 else if (scanToken(NodeType.NAME, ""desc"") != null) {
					 fieldNameNode.setDirection(Direction.DESCENDING);
				 }
			 }
			 fieldListNode.add(fieldNameNode);
			 if (scanToken(NodeType.OPERATION, "","") == null) {
				 if (fieldListNode.getCount() != 0) {
					 fieldListNode.setStartOffset(fieldListNode.getItem(0).getStartOffset());
					 fieldListNode.setEndOffset(fieldListNode.getItem(fieldListNode.getCount() - 1).getEndOffset());
				 }
				 return fieldListNode;
			 }
		 }
	 }
	 private NodeFieldName scanFieldName(final NodeTableName table) {
		 final Node node = TryScanFieldName();
		 if (node != null) {
			 return (NodeFieldName) node;
		 }
		 throwSyntaxError(SyntaxError.EXPECTING_FIELD_NAME);
		 return null;
	 }
	 private NodeMode ScanMode() {
		 ensureToken(NodeType.OPERATION, ""("", SyntaxError.EXPECTING_LEFT_BRACKET);
		 final NodeMode mode = new NodeMode();
		 do {
			 final int pos = currentPosition;
			 final NodeItem item = nextToken();
			 if ((item == null) || !(item.getNodeType().equals(NodeType.NAME))) {
				 currentPosition = pos;
				 throwSyntaxError(SyntaxError.EXPECTING_MODE);
				 return null;
			 }
			 mode.add(item);
		 }
		 while (scanToken(NodeType.OPERATION, "","") != null);
		 ensureToken(NodeType.OPERATION, "")"", SyntaxError.EXPECTING_RIGHT_BRACKET);
		 mode.setStartOffset(mode.getItem(0).getStartOffset());
		 mode.setEndOffset(mode.getItem(mode.getCount() - 1).getEndOffset());
		 return mode;
	 }
	 private NodeItem ensureToken(final NodeType type, final String str, final SyntaxError syntaxError) {
		 final NodeItem tokenNode = scanToken(type, str);
		 if (tokenNode == null) {
			 throwSyntaxError(syntaxError);
		 }
		 return tokenNode;
	 }
	 private void throwSyntaxError(final SyntaxError error) {
		 NodeItem causeNode = null;
		 if (currentPosition < tokens.size()) {
			 causeNode = (NodeItem) tokens.get(currentPosition);
		 }
		 throw new SyntaxException(causeNode, error);
	 }
	 private NodeItem scanToken(final NodeType type, final String str) {
		 final int savedCurrentPosition = currentPosition;
		 final NodeItem tokenNode = nextToken();
		 if (tokenNode != null && tokenNode.getNodeType() == type && str.equalsIgnoreCase(tokenNode.getValue())) {
			 return tokenNode;
		 }
		 currentPosition = savedCurrentPosition;
		 return null;
	 }
	 private NodeItem nextToken() {
		 if (currentPosition < tokens.size()) {
			 return (NodeItem) tokens.get(currentPosition++);
		 }
		 return null;
	 }
	 private Node TryScanExpression() {
		 int num;
		 Node node = TryScanSingleValue();
		 if (node == null) {
			 return null;
		 }
		 while (true) {
			 num = currentPosition;
			 final NodeItem item = nextToken();
			 if (item != null) {
				 Arithmetic none = Arithmetic.NONE;
				 Node node2 = null;
				 if (item.getNodeType() == NodeType.NUMBER) {
					 none = ArithmeticalOperators.find(item.getValue().substring(0, 1));
					 if (none != Arithmetic.NONE) {
						 item.setValue(item.getValue().substring(1));
						 node2 = item;
					 }
				 }
				 else if (item.getNodeType() == NodeType.OPERATION) {
					 none = ArithmeticalOperators.find(item.getValue());
					 if (none != Arithmetic.NONE) {
						 node2 = TryScanSingleValue();
					 }
				 }
				 if ((none != Arithmetic.NONE) && (node2 != null)) {
					 final NodeArithmetic arithmetic2 = new NodeArithmetic();
					 arithmetic2.setArithmetic(none);
					 arithmetic2.setLeft(node);
					 arithmetic2.setRight(node2);
					 arithmetic2.setStartOffset(arithmetic2.getLeft().getStartOffset());
					 arithmetic2.setEndOffset(arithmetic2.getRight().getEndOffset());
					 node = arithmetic2;
					 continue;
				 }
			 }
			 currentPosition = num;
			 return node;
		 }
	 }
	 private Node TryScanFieldName() {
		 Node node = null;
		 final int pos = currentPosition;
		 final Node node2 = nextToken();
		 if ((node2 != null) && (node2.getNodeType() == NodeType.NAME)) {
			 final NodeItem item = scanToken(NodeType.OPERATION, ""."");
			 Node node3 = null;
			 if (item != null) {
				 node3 = nextToken();
				 if ((node3 != null) && (node3.getNodeType() == NodeType.NAME)) {
					 node = new NodeFieldName((NodeName) node2, (NodeName) node3);
				 }
			 }
			 else {
				 node = new NodeFieldName((NodeName) node2);
			 }
		 }
		 if (node == null) {
			 currentPosition = pos;
			 return null;
		 }
		 return node;
	 }
	 private Node TryScanSingleValue() {
		 final int pos = currentPosition;
		 final Node node2 = nextToken();
		 if ((node2 != null) && (((node2.getNodeType() == NodeType.NUMBER) || (node2.getNodeType() == NodeType.STRING)) || ((node2.getNodeType() == NodeType.VARIABLE) || (node2.getNodeType() == NodeType.BOOL_VALUE)))) {
			 return node2;
		 }
		 currentPosition = pos;
		 return null;
	 }
}",1,0,0,0
"private class DelayedSelectionUpdater implements Runnable {
	 DelayedSelectionUpdater() {
		 SwingUtilities.invokeLater(this);
	 }
	 public void run() {
		 updateFileNameCompletion();
	 }
 }",0,0,0,0
"public interface PutOrBuilder extends com.google.protobuf.MessageOrBuilder {
	 boolean hasEvent();
	 org.apache.flume.channel.file.proto.ProtosFactory.FlumeEvent getEvent();
	 org.apache.flume.channel.file.proto.ProtosFactory.FlumeEventOrBuilder getEventOrBuilder();
	 boolean hasChecksum();
	 long getChecksum();
 }",0,0,0,0
"public final class ShardingSchema extends LogicSchema {
	 private ShardingRule shardingRule;
	 private final ShardingMetaData metaData;
	 public ShardingSchema(final String name, final Map<String, YamlDataSourceParameter> dataSources, final ShardingRuleConfiguration shardingRuleConfig, final boolean isUsingRegistry) {
		 super(name, dataSources);
		 shardingRule = createShardingRule(shardingRuleConfig, dataSources.keySet(), isUsingRegistry);
		 metaData = createShardingMetaData();
	 }
	 private ShardingRule createShardingRule(final ShardingRuleConfiguration shardingRuleConfig, final Collection<String> dataSourceNames, final boolean isUsingRegistry) {
		 return isUsingRegistry ? new OrchestrationShardingRule(shardingRuleConfig, dataSourceNames) : new ShardingRule(shardingRuleConfig, dataSourceNames);
	 }
	 private ShardingMetaData createShardingMetaData() {
		 ShardingDataSourceMetaData shardingDataSourceMetaData = new ShardingDataSourceMetaData(getDataSourceURLs(getDataSources()), shardingRule, LogicSchemas.getInstance().getDatabaseType());
		 ShardingTableMetaData shardingTableMetaData = new ShardingTableMetaData(getTableMetaDataInitializer(shardingDataSourceMetaData).load(shardingRule));
		 return new ShardingMetaData(shardingDataSourceMetaData, shardingTableMetaData);
	 }
	 public synchronized void renew(final ShardingRuleChangedEvent shardingRuleChangedEvent) {
		 if (getName().equals(shardingRuleChangedEvent.getShardingSchemaName())) {
			 shardingRule = new OrchestrationShardingRule(shardingRuleChangedEvent.getShardingRuleConfiguration(), getDataSources().keySet());
		 }
	 }
	 public synchronized void renew(final DisabledStateChangedEvent disabledStateChangedEvent) {
		 OrchestrationShardingSchema shardingSchema = disabledStateChangedEvent.getShardingSchema();
		 if (getName().equals(shardingSchema.getSchemaName())) {
			 for (MasterSlaveRule each : shardingRule.getMasterSlaveRules()) {
				 ((OrchestrationMasterSlaveRule) each).updateDisabledDataSourceNames(shardingSchema.getDataSourceName(), disabledStateChangedEvent.isDisabled());
			 }
		 }
	 }
	 public void refreshTableMetaData(final SQLStatement sqlStatement) {
		 if (sqlStatement instanceof CreateTableStatement) {
			 refreshTableMetaData((CreateTableStatement) sqlStatement);
		 }
		 else if (sqlStatement instanceof AlterTableStatement) {
			 refreshTableMetaData((AlterTableStatement) sqlStatement);
		 }
		 else if (sqlStatement instanceof DropTableStatement) {
			 refreshTableMetaData((DropTableStatement) sqlStatement);
		 }
	 }
	 private void refreshTableMetaData(final CreateTableStatement createTableStatement) {
		 String tableName = createTableStatement.getTables().getSingleTableName();
		 getMetaData().getTable().put(tableName, getTableMetaDataInitializer(metaData.getDataSource()).load(tableName, shardingRule));
	 }
	 private void refreshTableMetaData(final AlterTableStatement alterTableStatement) {
		 String tableName = alterTableStatement.getTables().getSingleTableName();
		 getMetaData().getTable().put(tableName, getTableMetaDataInitializer(metaData.getDataSource()).load(tableName, shardingRule));
	 }
	 private void refreshTableMetaData(final DropTableStatement dropTableStatement) {
		 for (String each : dropTableStatement.getTables().getTableNames()) {
			 getMetaData().getTable().remove(each);
		 }
	 }
}",0,0,0,0
"public final class FloatLiteralAST extends ExpressionAST {
	 public FloatLiteralAST(final Token token) {
		super(token);
	 }
	 public void parseComplete() {
		final String tokenString = (context.negative) ? ""-"" + getText() : getText();
		final int length = tokenString.length();
		final char lastChar = tokenString.charAt(length - 1);
		final boolean floatLiteral = lastChar == 'f' || lastChar == 'F';
		type = floatLiteral ? Type.floatType : Type.doubleType;
		value = floatLiteral ? (Object)Float.valueOf(tokenString.substring(0, length - 1)) : (Object)Double.valueOf(tokenString);
	 }
	 protected Type computeType() {
		 return type;
	 }
	 protected Type[] computeExceptions() {
		return noTypes;
	 }
	 protected Object computeValue() {
		return value;
	 }
	 public VarList getVarList() {
		return new VarList();
	 }
}",0,0,0,0
"public class DirectoryScanner implements FileScanner, SelectorScanner, ResourceFactory {
	 private static final boolean ON_VMS = Os.isFamily(""openvms"");
	 protected static final String[] DEFAULTEXCLUDES = {
		 SelectorUtils.DEEP_TREE_MATCH + "" public static final int MAX_LEVELS_OF_SYMLINKS = 5;
		 public static final String DOES_NOT_EXIST_POSTFIX = "" does not exist."";
		 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
		 private static final SymbolicLinkUtils SYMLINK_UTILS = SymbolicLinkUtils.getSymbolicLinkUtils();
		 private static final Set defaultExcludes = new HashSet();
		 static {
			 resetDefaultExcludes();
		 }
		 protected File basedir;
		 protected String[] includes;
		 protected String[] excludes;
		 protected FileSelector[] selectors = null;
		 protected Vector filesIncluded;
		 protected Vector filesNotIncluded;
		 protected Vector filesExcluded;
		 protected Vector dirsIncluded;
		 protected Vector dirsNotIncluded;
		 protected Vector dirsExcluded;
		 protected Vector filesDeselected;
		 protected Vector dirsDeselected;
		 protected boolean haveSlowResults = false;
		 protected boolean isCaseSensitive = true;
		 protected boolean errorOnMissingDir = true;
		 private boolean followSymlinks = true;
		 protected boolean everythingIncluded = true;
		 private Set scannedDirs = new HashSet();
		 private Map includeNonPatterns = new HashMap();
		 private Map excludeNonPatterns = new HashMap();
		 private TokenizedPattern[] includePatterns;
		 private TokenizedPattern[] excludePatterns;
		 private boolean areNonPatternSetsReady = false;
		 private boolean scanning = false;
		 private Object scanLock = new Object();
		 private boolean slowScanning = false;
		 private Object slowScanLock = new Object();
		 private IllegalStateException illegal = null;
		 private int maxLevelsOfSymlinks = MAX_LEVELS_OF_SYMLINKS;
		 private Set notFollowedSymlinks = new HashSet();
		 public DirectoryScanner() {
		 }
		 protected static boolean matchPatternStart(String pattern, String str) {
			 return SelectorUtils.matchPatternStart(pattern, str);
		 }
		 protected static boolean matchPatternStart(String pattern, String str, boolean isCaseSensitive) {
			 return SelectorUtils.matchPatternStart(pattern, str, isCaseSensitive);
		 }
		 protected static boolean matchPath(String pattern, String str) {
			 return SelectorUtils.matchPath(pattern, str);
		 }
		 protected static boolean matchPath(String pattern, String str, boolean isCaseSensitive) {
			 return SelectorUtils.matchPath(pattern, str, isCaseSensitive);
		 }
		 public static boolean match(String pattern, String str) {
			 return SelectorUtils.match(pattern, str);
		 }
		 protected static boolean match(String pattern, String str, boolean isCaseSensitive) {
			 return SelectorUtils.match(pattern, str, isCaseSensitive);
		 }
		 public static String[] getDefaultExcludes() {
			 synchronized (defaultExcludes) {
				 return (String[]) defaultExcludes.toArray(new String[defaultExcludes .size()]);
			 }
		 }
		 public static boolean addDefaultExclude(String s) {
			 synchronized (defaultExcludes) {
				 return defaultExcludes.add(s);
			 }
		 }
		 public static boolean removeDefaultExclude(String s) {
			 synchronized (defaultExcludes) {
				 return defaultExcludes.remove(s);
			 }
		 }
		 public static void resetDefaultExcludes() {
			 synchronized (defaultExcludes) {
				 defaultExcludes.clear();
				 for (int i = 0;
				 i < DEFAULTEXCLUDES.length;
				 i++) {
					 defaultExcludes.add(DEFAULTEXCLUDES[i]);
				 }
			 }
		 }
		 public void setBasedir(String basedir) {
			 setBasedir(basedir == null ? (File) null : new File(basedir.replace('/', File.separatorChar).replace( '\\', File.separatorChar)));
		 }
		 public synchronized void setBasedir(File basedir) {
			 this.basedir = basedir;
		 }
		 public synchronized File getBasedir() {
			 return basedir;
		 }
		 public synchronized boolean isCaseSensitive() {
			 return isCaseSensitive;
		 }
		 public synchronized void setCaseSensitive(boolean isCaseSensitive) {
			 this.isCaseSensitive = isCaseSensitive;
		 }
		 public void setErrorOnMissingDir(boolean errorOnMissingDir) {
			 this.errorOnMissingDir = errorOnMissingDir;
		 }
		 public synchronized boolean isFollowSymlinks() {
			 return followSymlinks;
		 }
		 public synchronized void setFollowSymlinks(boolean followSymlinks) {
			 this.followSymlinks = followSymlinks;
		 }
		 public void setMaxLevelsOfSymlinks(int max) {
			 maxLevelsOfSymlinks = max;
		 }
		 public synchronized void setIncludes(String[] includes) {
			 if (includes == null) {
				 this.includes = null;
			 }
			 else {
				 this.includes = new String[includes.length];
				 for (int i = 0;
				 i < includes.length;
				 i++) {
					 this.includes[i] = normalizePattern(includes[i]);
				 }
			 }
		 }
		 public synchronized void setExcludes(String[] excludes) {
			 if (excludes == null) {
				 this.excludes = null;
			 }
			 else {
				 this.excludes = new String[excludes.length];
				 for (int i = 0;
				 i < excludes.length;
				 i++) {
					 this.excludes[i] = normalizePattern(excludes[i]);
				 }
			 }
		 }
		 public synchronized void addExcludes(String[] excludes) {
			 if (excludes != null && excludes.length > 0) {
				 if (this.excludes != null && this.excludes.length > 0) {
					 String[] tmp = new String[excludes.length + this.excludes.length];
					 System.arraycopy(this.excludes, 0, tmp, 0, this.excludes.length);
					 for (int i = 0;
					 i < excludes.length;
					 i++) {
						 tmp[this.excludes.length + i] = normalizePattern(excludes[i]);
					 }
					 this.excludes = tmp;
				 }
				 else {
					 setExcludes(excludes);
				 }
			 }
		 }
		 private static String normalizePattern(String p) {
			 String pattern = p.replace('/', File.separatorChar) .replace('\\', File.separatorChar);
			 if (pattern.endsWith(File.separator)) {
				 pattern += SelectorUtils.DEEP_TREE_MATCH;
			 }
			 return pattern;
		 }
		 public synchronized void setSelectors(FileSelector[] selectors) {
			 this.selectors = selectors;
		 }
		 public synchronized boolean isEverythingIncluded() {
			 return everythingIncluded;
		 }
		 public void scan() throws IllegalStateException {
			 synchronized (scanLock) {
				 if (scanning) {
					 while (scanning) {
						 try {
							 scanLock.wait();
						 }
						 catch (InterruptedException e) {
							 continue;
						 }
					 }
					 if (illegal != null) {
						 throw illegal;
					 }
					 return;
				 }
				 scanning = true;
			 }
			 File savedBase = basedir;
			 try {
				 synchronized (this) {
					 illegal = null;
					 clearResults();
					 boolean nullIncludes = (includes == null);
					 includes = nullIncludes ? new String[] {
					SelectorUtils.DEEP_TREE_MATCH}
					 : includes;
					 boolean nullExcludes = (excludes == null);
					 excludes = nullExcludes ? new String[0] : excludes;
					 if (basedir != null && !followSymlinks && SYMLINK_UTILS.isSymbolicLink(basedir)) {
						 notFollowedSymlinks.add(basedir.getAbsolutePath());
						 basedir = null;
					 }
					 if (basedir == null) {
						 if (nullIncludes) {
							 return;
						 }
					 }
					 else {
						 if (!basedir.exists()) {
							 if (errorOnMissingDir) {
								 illegal = new IllegalStateException(""basedir "" + basedir + DOES_NOT_EXIST_POSTFIX);
							 }
							 else {
								 return;
							 }
						 }
						 else if (!basedir.isDirectory()) {
							 illegal = new IllegalStateException(""basedir "" + basedir + "" is not a"" + "" directory."");
						 }
						 if (illegal != null) {
							 throw illegal;
						 }
					 }
					 if (isIncluded(TokenizedPath.EMPTY_PATH)) {
						 if (!isExcluded(TokenizedPath.EMPTY_PATH)) {
							 if (isSelected("""", basedir)) {
								 dirsIncluded.addElement("""");
							 }
							 else {
								 dirsDeselected.addElement("""");
							 }
						 }
						 else {
							 dirsExcluded.addElement("""");
						 }
					 }
					 else {
						 dirsNotIncluded.addElement("""");
					 }
					 checkIncludePatterns();
					 clearCaches();
					 includes = nullIncludes ? null : includes;
					 excludes = nullExcludes ? null : excludes;
				 }
			 }
			 catch (IOException ex) {
				 throw new BuildException(ex);
			 }
			 finally {
				 basedir = savedBase;
				 synchronized (scanLock) {
					 scanning = false;
					 scanLock.notifyAll();
				 }
			 }
		 }
		 private void checkIncludePatterns() {
			 ensureNonPatternSetsReady();
			 Map newroots = new HashMap();
			 for (int i = 0;
			 i < includePatterns.length;
			 i++) {
				 String pattern = includePatterns[i].toString();
				 if (!shouldSkipPattern(pattern)) {
					 newroots.put(includePatterns[i].rtrimWildcardTokens(), pattern);
				 }
			 }
			 for (Iterator iter = includeNonPatterns.entrySet().iterator();
			 iter.hasNext();
			 ) {
				 Map.Entry entry = (Map.Entry) iter.next();
				 String pattern = (String) entry.getKey();
				 if (!shouldSkipPattern(pattern)) {
					 newroots.put((TokenizedPath) entry.getValue(), pattern);
				 }
			 }
			 if (newroots.containsKey(TokenizedPath.EMPTY_PATH) && basedir != null) {
				 scandir(basedir, """", true);
			 }
			 else {
				 Iterator it = newroots.entrySet().iterator();
				 File canonBase = null;
				 if (basedir != null) {
					 try {
						 canonBase = basedir.getCanonicalFile();
					 }
					 catch (IOException ex) {
						 throw new BuildException(ex);
					 }
				 }
				 while (it.hasNext()) {
					 Map.Entry entry = (Map.Entry) it.next();
					 TokenizedPath currentPath = (TokenizedPath) entry.getKey();
					 String currentelement = currentPath.toString();
					 if (basedir == null && !FileUtils.isAbsolutePath(currentelement)) {
						 continue;
					 }
					 File myfile = new File(basedir, currentelement);
					 if (myfile.exists()) {
						 try {
							 String path = (basedir == null) ? myfile.getCanonicalPath() : FILE_UTILS.removeLeadingPath(canonBase, myfile.getCanonicalFile());
							 if (!path.equals(currentelement) || ON_VMS) {
								 myfile = currentPath.findFile(basedir, true);
								 if (myfile != null && basedir != null) {
									 currentelement = FILE_UTILS.removeLeadingPath( basedir, myfile);
									 if (!currentPath.toString() .equals(currentelement)) {
										 currentPath = new TokenizedPath(currentelement);
									 }
								 }
							 }
						 }
						 catch (IOException ex) {
							 throw new BuildException(ex);
						 }
					 }
					 if ((myfile == null || !myfile.exists()) && !isCaseSensitive()) {
						 File f = currentPath.findFile(basedir, false);
						 if (f != null && f.exists()) {
							 currentelement = (basedir == null) ? f.getAbsolutePath() : FILE_UTILS.removeLeadingPath(basedir, f);
							 myfile = f;
							 currentPath = new TokenizedPath(currentelement);
						 }
					 }
					 if (myfile != null && myfile.exists()) {
						 if (!followSymlinks && currentPath.isSymlink(basedir)) {
							 if (!isExcluded(currentPath)) {
								 notFollowedSymlinks.add(myfile.getAbsolutePath());
							 }
							 continue;
						 }
						 if (myfile.isDirectory()) {
							 if (isIncluded(currentPath) && currentelement.length() > 0) {
								 accountForIncludedDir(currentPath, myfile, true);
							 }
							 else {
								 scandir(myfile, currentPath, true);
							 }
						 }
						 else {
							 String originalpattern = (String) entry.getValue();
							 boolean included = isCaseSensitive() ? originalpattern.equals(currentelement) : originalpattern.equalsIgnoreCase(currentelement);
							 if (included) {
								 accountForIncludedFile(currentPath, myfile);
							 }
						 }
					 }
				 }
			 }
		 }
		 private boolean shouldSkipPattern(String pattern) {
			 if (FileUtils.isAbsolutePath(pattern)) {
				 if (basedir != null && !SelectorUtils.matchPatternStart(pattern, basedir.getAbsolutePath(), isCaseSensitive())) {
					 return true;
				 }
			 }
			 else if (basedir == null) {
				 return true;
			 }
			 return false;
		 }
		 protected synchronized void clearResults() {
			 filesIncluded = new VectorSet();
			 filesNotIncluded = new VectorSet();
			 filesExcluded = new VectorSet();
			 filesDeselected = new VectorSet();
			 dirsIncluded = new VectorSet();
			 dirsNotIncluded = new VectorSet();
			 dirsExcluded = new VectorSet();
			 dirsDeselected = new VectorSet();
			 everythingIncluded = (basedir != null);
			 scannedDirs.clear();
			 notFollowedSymlinks.clear();
		 }
		 protected void slowScan() {
			 synchronized (slowScanLock) {
				 if (haveSlowResults) {
					 return;
				 }
				 if (slowScanning) {
					 while (slowScanning) {
						 try {
							 slowScanLock.wait();
						 }
						 catch (InterruptedException e) {
						 }
					 }
					 return;
				 }
				 slowScanning = true;
			 }
			 try {
				 synchronized (this) {
					 boolean nullIncludes = (includes == null);
					 includes = nullIncludes ? new String[] {
					SelectorUtils.DEEP_TREE_MATCH}
					 : includes;
					 boolean nullExcludes = (excludes == null);
					 excludes = nullExcludes ? new String[0] : excludes;
					 String[] excl = new String[dirsExcluded.size()];
					 dirsExcluded.copyInto(excl);
					 String[] notIncl = new String[dirsNotIncluded.size()];
					 dirsNotIncluded.copyInto(notIncl);
					 ensureNonPatternSetsReady();
					 processSlowScan(excl);
					 processSlowScan(notIncl);
					 clearCaches();
					 includes = nullIncludes ? null : includes;
					 excludes = nullExcludes ? null : excludes;
				 }
			 }
			 finally {
				 synchronized (slowScanLock) {
					 haveSlowResults = true;
					 slowScanning = false;
					 slowScanLock.notifyAll();
				 }
			 }
		 }
		 private void processSlowScan(String[] arr) {
			 for (int i = 0;
			 i < arr.length;
			 i++) {
				 TokenizedPath path = new TokenizedPath(arr[i]);
				 if (!couldHoldIncluded(path) || contentsExcluded(path)) {
					 scandir(new File(basedir, arr[i]), path, false);
				 }
			 }
		 }
		 protected void scandir(File dir, String vpath, boolean fast) {
			 scandir(dir, new TokenizedPath(vpath), fast);
		 }
		 private void scandir(File dir, TokenizedPath path, boolean fast) {
			 if (dir == null) {
				 throw new BuildException(""dir must not be null."");
			 }
			 String[] newfiles = dir.list();
			 if (newfiles == null) {
				 if (!dir.exists()) {
					 throw new BuildException(dir + DOES_NOT_EXIST_POSTFIX);
				 }
				 else if (!dir.isDirectory()) {
					 throw new BuildException(dir + "" is not a directory."");
				 }
				 else {
					 throw new BuildException(""IO error scanning directory '"" + dir.getAbsolutePath() + ""'"");
				 }
			 }
			 scandir(dir, path, fast, newfiles, new LinkedList());
		 }
		 private void scandir(File dir, TokenizedPath path, boolean fast, String[] newfiles, LinkedList directoryNamesFollowed) {
			 String vpath = path.toString();
			 if (vpath.length() > 0 && !vpath.endsWith(File.separator)) {
				 vpath += File.separator;
			 }
			 if (fast && hasBeenScanned(vpath)) {
				 return;
			 }
			 if (!followSymlinks) {
				 ArrayList noLinks = new ArrayList();
				 for (int i = 0;
				 i < newfiles.length;
				 i++) {
					 try {
						 if (SYMLINK_UTILS.isSymbolicLink(dir, newfiles[i])) {
							 String name = vpath + newfiles[i];
							 File file = new File(dir, newfiles[i]);
							 (file.isDirectory() ? dirsExcluded : filesExcluded).addElement(name);
							 if (!isExcluded(name)) {
								 notFollowedSymlinks.add(file.getAbsolutePath());
							 }
						 }
						 else {
							 noLinks.add(newfiles[i]);
						 }
					 }
					 catch (IOException ioe) {
						 String msg = ""IOException caught while checking "" + ""for links, couldn't get canonical path!"";
						 System.err.println(msg);
						 noLinks.add(newfiles[i]);
					 }
				 }
				 newfiles = (String[]) (noLinks.toArray(new String[noLinks.size()]));
			 }
			 else {
				 directoryNamesFollowed.addFirst(dir.getName());
			 }
			 for (int i = 0;
			 i < newfiles.length;
			 i++) {
				 String name = vpath + newfiles[i];
				 TokenizedPath newPath = new TokenizedPath(path, newfiles[i]);
				 File file = new File(dir, newfiles[i]);
				 String[] children = file.list();
				 if (children == null || (children.length == 0 && file.isFile())) {
					 if (isIncluded(newPath)) {
						 accountForIncludedFile(newPath, file);
					 }
					 else {
						 everythingIncluded = false;
						 filesNotIncluded.addElement(name);
					 }
				 }
				 else {
					 if (followSymlinks && causesIllegalSymlinkLoop(newfiles[i], dir, directoryNamesFollowed)) {
						 System.err.println(""skipping symbolic link "" + file.getAbsolutePath() + "" -- too many levels of symbolic"" + "" links."");
						 notFollowedSymlinks.add(file.getAbsolutePath());
						 continue;
					 }
					 if (isIncluded(newPath)) {
						 accountForIncludedDir(newPath, file, fast, children, directoryNamesFollowed);
					 }
					 else {
						 everythingIncluded = false;
						 dirsNotIncluded.addElement(name);
						 if (fast && couldHoldIncluded(newPath) && !contentsExcluded(newPath)) {
							 scandir(file, newPath, fast, children, directoryNamesFollowed);
						 }
					 }
					 if (!fast) {
						 scandir(file, newPath, fast, children, directoryNamesFollowed);
					 }
				 }
			 }
			 if (followSymlinks) {
				 directoryNamesFollowed.removeFirst();
			 }
		 }
		 private void accountForIncludedFile(TokenizedPath name, File file) {
			 processIncluded(name, file, filesIncluded, filesExcluded, filesDeselected);
		 }
		 private void accountForIncludedDir(TokenizedPath name, File file, boolean fast) {
			 processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);
			 if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {
				 scandir(file, name, fast);
			 }
		 }
		 private void accountForIncludedDir(TokenizedPath name, File file, boolean fast, String[] children, LinkedList directoryNamesFollowed) {
			 processIncluded(name, file, dirsIncluded, dirsExcluded, dirsDeselected);
			 if (fast && couldHoldIncluded(name) && !contentsExcluded(name)) {
				 scandir(file, name, fast, children, directoryNamesFollowed);
			 }
		 }
		 private void processIncluded(TokenizedPath path, File file, Vector inc, Vector exc, Vector des) {
			 String name = path.toString();
			 if (inc.contains(name) || exc.contains(name) || des.contains(name)) {
				 return;
			 }
			 boolean included = false;
			 if (isExcluded(path)) {
				 exc.add(name);
			 }
			 else if (isSelected(name, file)) {
				 included = true;
				 inc.add(name);
			 }
			 else {
				 des.add(name);
			 }
			 everythingIncluded &= included;
		 }
		 protected boolean isIncluded(String name) {
			 return isIncluded(new TokenizedPath(name));
		 }
		 private boolean isIncluded(TokenizedPath path) {
			 ensureNonPatternSetsReady();
			 if (isCaseSensitive() ? includeNonPatterns.containsKey(path.toString()) : includeNonPatterns.containsKey(path.toString().toUpperCase())) {
				 return true;
			 }
			 for (int i = 0;
			 i < includePatterns.length;
			 i++) {
				 if (includePatterns[i].matchPath(path, isCaseSensitive())) {
					 return true;
				 }
			 }
			 return false;
		 }
		 protected boolean couldHoldIncluded(String name) {
			 return couldHoldIncluded(new TokenizedPath(name));
		 }
		 private boolean couldHoldIncluded(TokenizedPath tokenizedName) {
			 for (int i = 0;
			 i < includePatterns.length;
			 i++) {
				 if (couldHoldIncluded(tokenizedName, includePatterns[i])) {
					 return true;
				 }
			 }
			 for (Iterator iter = includeNonPatterns.values().iterator();
			 iter.hasNext();
			 ) {
				 if (couldHoldIncluded(tokenizedName, ((TokenizedPath) iter.next()).toPattern())) {
					 return true;
				 }
			 }
			 return false;
		 }
		 private boolean couldHoldIncluded(TokenizedPath tokenizedName, TokenizedPattern tokenizedInclude) {
			 return tokenizedInclude.matchStartOf(tokenizedName, isCaseSensitive()) && isMorePowerfulThanExcludes(tokenizedName.toString()) && isDeeper(tokenizedInclude, tokenizedName);
		 }
		 private boolean isDeeper(TokenizedPattern pattern, TokenizedPath name) {
			 return pattern.containsPattern(SelectorUtils.DEEP_TREE_MATCH) || pattern.depth() > name.depth();
		 }
		 private boolean isMorePowerfulThanExcludes(String name) {
			 final String soughtexclude = name + File.separatorChar + SelectorUtils.DEEP_TREE_MATCH;
			 for (int counter = 0;
			 counter < excludePatterns.length;
			 counter++) {
				 if (excludePatterns[counter].toString().equals(soughtexclude)) {
					 return false;
				 }
			 }
			 return true;
		 }
		 boolean contentsExcluded(TokenizedPath path) {
			 for (int i = 0;
			 i < excludePatterns.length;
			 i++) {
				 if (excludePatterns[i].endsWith(SelectorUtils.DEEP_TREE_MATCH) && excludePatterns[i].withoutLastToken() .matchPath(path, isCaseSensitive())) {
					 return true;
				 }
			 }
			 return false;
		 }
		 protected boolean isExcluded(String name) {
			 return isExcluded(new TokenizedPath(name));
		 }
		 private boolean isExcluded(TokenizedPath name) {
			 ensureNonPatternSetsReady();
			 if (isCaseSensitive() ? excludeNonPatterns.containsKey(name.toString()) : excludeNonPatterns.containsKey(name.toString().toUpperCase())) {
				 return true;
			 }
			 for (int i = 0;
			 i < excludePatterns.length;
			 i++) {
				 if (excludePatterns[i].matchPath(name, isCaseSensitive())) {
					 return true;
				 }
			 }
			 return false;
		 }
		 protected boolean isSelected(String name, File file) {
			 if (selectors != null) {
				 for (int i = 0;
				 i < selectors.length;
				 i++) {
					 if (!selectors[i].isSelected(basedir, name, file)) {
						 return false;
					 }
				 }
			 }
			 return true;
		 }
		 public String[] getIncludedFiles() {
			 String[] files;
			 synchronized (this) {
				 if (filesIncluded == null) {
					 throw new IllegalStateException(""Must call scan() first"");
				 }
				 files = new String[filesIncluded.size()];
				 filesIncluded.copyInto(files);
			 }
			 Arrays.sort(files);
			 return files;
		 }
		 public synchronized int getIncludedFilesCount() {
			 if (filesIncluded == null) {
				 throw new IllegalStateException(""Must call scan() first"");
			 }
			 return filesIncluded.size();
		 }
		 public synchronized String[] getNotIncludedFiles() {
			 slowScan();
			 String[] files = new String[filesNotIncluded.size()];
			 filesNotIncluded.copyInto(files);
			 return files;
		 }
		 public synchronized String[] getExcludedFiles() {
			 slowScan();
			 String[] files = new String[filesExcluded.size()];
			 filesExcluded.copyInto(files);
			 return files;
		 }
		 public synchronized String[] getDeselectedFiles() {
			 slowScan();
			 String[] files = new String[filesDeselected.size()];
			 filesDeselected.copyInto(files);
			 return files;
		 }
		 public String[] getIncludedDirectories() {
			 String[] directories;
			 synchronized (this) {
				 if (dirsIncluded == null) {
					 throw new IllegalStateException(""Must call scan() first"");
				 }
				 directories = new String[dirsIncluded.size()];
				 dirsIncluded.copyInto(directories);
			 }
			 Arrays.sort(directories);
			 return directories;
		 }
		 public synchronized int getIncludedDirsCount() {
			 if (dirsIncluded == null) {
				 throw new IllegalStateException(""Must call scan() first"");
			 }
			 return dirsIncluded.size();
		 }
		 public synchronized String[] getNotIncludedDirectories() {
			 slowScan();
			 String[] directories = new String[dirsNotIncluded.size()];
			 dirsNotIncluded.copyInto(directories);
			 return directories;
		 }
		 public synchronized String[] getExcludedDirectories() {
			 slowScan();
			 String[] directories = new String[dirsExcluded.size()];
			 dirsExcluded.copyInto(directories);
			 return directories;
		 }
		 public synchronized String[] getDeselectedDirectories() {
			 slowScan();
			 String[] directories = new String[dirsDeselected.size()];
			 dirsDeselected.copyInto(directories);
			 return directories;
		 }
		 public synchronized String[] getNotFollowedSymlinks() {
			 String[] links;
			 synchronized (this) {
				 links = (String[]) notFollowedSymlinks .toArray(new String[notFollowedSymlinks.size()]);
			 }
			 Arrays.sort(links);
			 return links;
		 }
		 public synchronized void addDefaultExcludes() {
			 int excludesLength = excludes == null ? 0 : excludes.length;
			 String[] newExcludes;
			 String[] defaultExcludesTemp = getDefaultExcludes();
			 newExcludes = new String[excludesLength + defaultExcludesTemp.length];
			 if (excludesLength > 0) {
				 System.arraycopy(excludes, 0, newExcludes, 0, excludesLength);
			 }
			 for (int i = 0;
			 i < defaultExcludesTemp.length;
			 i++) {
				 newExcludes[i + excludesLength] = defaultExcludesTemp[i].replace('/', File.separatorChar) .replace('\\', File.separatorChar);
			 }
			 excludes = newExcludes;
		 }
		 public synchronized Resource getResource(String name) {
			 return new FileResource(basedir, name);
		 }
		 private boolean hasBeenScanned(String vpath) {
			 return !scannedDirs.add(vpath);
		 }
		 Set getScannedDirs() {
			 return scannedDirs;
		 }
		 private synchronized void clearCaches() {
			 includeNonPatterns.clear();
			 excludeNonPatterns.clear();
			 includePatterns = null;
			 excludePatterns = null;
			 areNonPatternSetsReady = false;
		 }
		 synchronized void ensureNonPatternSetsReady() {
			 if (!areNonPatternSetsReady) {
				 includePatterns = fillNonPatternSet(includeNonPatterns, includes);
				 excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes);
				 areNonPatternSetsReady = true;
			 }
		 }
		 private TokenizedPattern[] fillNonPatternSet(Map map, String[] patterns) {
			 ArrayList al = new ArrayList(patterns.length);
			 for (int i = 0;
			 i < patterns.length;
			 i++) {
				 if (!SelectorUtils.hasWildcards(patterns[i])) {
					 String s = isCaseSensitive() ? patterns[i] : patterns[i].toUpperCase();
					 map.put(s, new TokenizedPath(s));
				 }
				 else {
					 al.add(new TokenizedPattern(patterns[i]));
				 }
			 }
			 return (TokenizedPattern[]) al.toArray(new TokenizedPattern[al.size()]);
		 }
		 private boolean causesIllegalSymlinkLoop(String dirName, File parent, LinkedList directoryNamesFollowed) {
			 try {
				 if (directoryNamesFollowed.size() >= maxLevelsOfSymlinks && CollectionUtils.frequency(directoryNamesFollowed, dirName) >= maxLevelsOfSymlinks && SYMLINK_UTILS.isSymbolicLink(parent, dirName)) {
					 ArrayList files = new ArrayList();
					 File f = FILE_UTILS.resolveFile(parent, dirName);
					 String target = f.getCanonicalPath();
					 files.add(target);
					 String relPath = """";
					 for (Iterator i = directoryNamesFollowed.iterator();
					 i.hasNext();
					 ) {
						 relPath += ""../"";
						 String dir = (String) i.next();
						 if (dirName.equals(dir)) {
							 f = FILE_UTILS.resolveFile(parent, relPath + dir);
							 files.add(f.getCanonicalPath());
							 if (files.size() > maxLevelsOfSymlinks && CollectionUtils.frequency(files, target) > maxLevelsOfSymlinks) {
								 return true;
							 }
						 }
					 }
				 }
				 return false;
			 }
			 catch (IOException ex) {
				 throw new BuildException(""Caught error while checking for"" + "" symbolic links"", ex);
			 }
		 }
	}",1,0,0,0
"public class URLResource extends Resource implements URLProvider {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private static final int NULL_URL = Resource.getMagicNumber(""null URL"".getBytes());
	 private URL url;
	 private URLConnection conn;
	 private URL baseURL;
	 private String relPath;
	 public URLResource() {
	 }
	 public URLResource(URL u) {
		 setURL(u);
	 }
	 public URLResource(URLProvider u) {
		 setURL(u.getURL());
	 }
	 public URLResource(File f) {
		 setFile(f);
	 }
	 public URLResource(String u) {
		 this(newURL(u));
	 }
	 public synchronized void setURL(URL u) {
		 checkAttributesAllowed();
		 url = u;
	 }
	 public synchronized void setFile(File f) {
		 try {
			 setURL(FILE_UTILS.getFileURL(f));
		 }
		 catch (MalformedURLException e) {
			 throw new BuildException(e);
		 }
	 }
	 public synchronized void setBaseURL(URL base) {
		 checkAttributesAllowed();
		 if (url != null) {
			 throw new BuildException(""can't define URL and baseURL attribute"");
		 }
		 baseURL = base;
	 }
	 public synchronized void setRelativePath(String r) {
		 checkAttributesAllowed();
		 if (url != null) {
			 throw new BuildException(""can't define URL and relativePath"" + "" attribute"");
		 }
		 relPath = r;
	 }
	 public synchronized URL getURL() {
		 if (isReference()) {
			 return ((URLResource) getCheckedRef()).getURL();
		 }
		 if (url == null) {
			 if (baseURL != null) {
				 if (relPath == null) {
					 throw new BuildException(""must provide relativePath"" + "" attribute when using baseURL."");
				 }
				 try {
					 url = new URL(baseURL, relPath);
				 }
				 catch (MalformedURLException e) {
					 throw new BuildException(e);
				 }
			 }
		 }
		 return url;
	 }
	 public synchronized void setRefid(Reference r) {
		 if (url != null || baseURL != null || relPath != null) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 public synchronized String getName() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getName();
		 }
		 String name = getURL().getFile();
		 return """".equals(name) ? name : name.substring(1);
	 }
	 public synchronized String toString() {
		 return isReference() ? getCheckedRef().toString() : String.valueOf(getURL());
	 }
	 public synchronized boolean isExists() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).isExists();
		 }
		 return isExists(false);
	 }
	 private synchronized boolean isExists(boolean closeConnection) {
		 if (getURL() == null) {
			 return false;
		 }
		 try {
			 connect(Project.MSG_VERBOSE);
			 return true;
		 }
		 catch (IOException e) {
			 return false;
		 }
		 finally {
			 if (closeConnection) {
				 close();
			 }
		 }
	 }
	 public synchronized long getLastModified() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getLastModified();
		 }
		 if (!isExists(false)) {
			 return 0L;
		 }
		 return conn.getLastModified();
	 }
	 public synchronized boolean isDirectory() {
		 return isReference() ? ((Resource) getCheckedRef()).isDirectory() : getName().endsWith(""/"");
	 }
	 public synchronized long getSize() {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getSize();
		 }
		 if (!isExists(false)) {
			 return 0L;
		 }
		 try {
			 connect();
			 long contentlength = conn.getContentLength();
			 close();
			 return contentlength;
		 }
		 catch (IOException e) {
			 return UNKNOWN_SIZE;
		 }
	 }
	 public synchronized boolean equals(Object another) {
		 if (this == another) {
			 return true;
		 }
		 if (isReference()) {
			 return getCheckedRef().equals(another);
		 }
		 if (!(another.getClass().equals(getClass()))) {
			 return false;
		 }
		 URLResource otheru = (URLResource) another;
		 return getURL() == null ? otheru.getURL() == null : getURL().equals(otheru.getURL());
	 }
	 public synchronized int hashCode() {
		 if (isReference()) {
			 return getCheckedRef().hashCode();
		 }
		 return MAGIC * ((getURL() == null) ? NULL_URL : getURL().hashCode());
	 }
	 public synchronized InputStream getInputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getInputStream();
		 }
		 connect();
		 try {
			 return conn.getInputStream();
		 }
		 finally {
			 conn = null;
		 }
	 }
	 public synchronized OutputStream getOutputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getOutputStream();
		 }
		 connect();
		 try {
			 return conn.getOutputStream();
		 }
		 finally {
			 conn = null;
		 }
	 }
	 protected void connect() throws IOException {
		 connect(Project.MSG_ERR);
	 }
	 protected synchronized void connect(int logLevel) throws IOException {
		 URL u = getURL();
		 if (u == null) {
			 throw new BuildException(""URL not set"");
		 }
		 if (conn == null) {
			 try {
				 conn = u.openConnection();
				 conn.connect();
			 }
			 catch (IOException e) {
				 log(e.toString(), logLevel);
				 conn = null;
				 throw e;
			 }
		 }
	 }
	 private synchronized void close() {
		 try {
			 FileUtils.close(conn);
		 }
		 finally {
			 conn = null;
		 }
	 }
	 private static URL newURL(String u) {
		 try {
			 return new URL(u);
		 }
		 catch (MalformedURLException e) {
			 throw new BuildException(e);
		 }
	 }
}",0,0,0,0
"public void setWin32Res(File fileName) {
	 win32res = fileName;
 }",0,0,0,0
"public VProperty(String line) {
	 if (line != null && !""END:VCARD"".equals(line)) {
		 State state = State.KEY;
		 String paramName = null;
		 List<String> paramValues = null;
		 int startIndex = 0;
		 for (int i = 0;
		 i < line.length();
		 i++) {
			 char currentChar = line.charAt(i);
			 if (state == State.KEY) {
				 if (currentChar == ':') {
					 setKey(line.substring(startIndex, i));
					 state = State.VALUE;
					 startIndex = i + 1;
				 }
				 else if (currentChar == ';
				') {
					 setKey(line.substring(startIndex, i));
					 state = State.PARAM_NAME;
					 startIndex = i + 1;
				 }
			 }
			 else if (state == State.PARAM_NAME) {
				 if (currentChar == '=') {
					 paramName = line.substring(startIndex, i).toUpperCase();
					 state = State.PARAM_VALUE;
					 paramValues = new ArrayList<String>();
					 startIndex = i + 1;
				 }
				 else if (currentChar == ';
				') {
					 paramName = line.substring(startIndex, i).toUpperCase();
					 addParam(paramName);
					 state = State.PARAM_NAME;
					 startIndex = i + 1;
				 }
				 else if (currentChar == ':') {
					 paramName = line.substring(startIndex, i).toUpperCase();
					 addParam(paramName);
					 state = State.VALUE;
					 startIndex = i + 1;
				 }
			 }
			 else if (state == State.PARAM_VALUE) {
				 if (currentChar == '""') {
					 state = State.QUOTED_PARAM_VALUE;
					 startIndex = i + 1;
				 }
				 else if (currentChar == ':') {
					 if (startIndex < i) {
						 paramValues = addParamValue(paramValues, line.substring(startIndex, i));
					 }
					 addParam(paramName, paramValues);
					 state = State.VALUE;
					 startIndex = i + 1;
				 }
				 else if (currentChar == ';
				') {
					 if (startIndex < i) {
						 paramValues = addParamValue(paramValues, line.substring(startIndex, i));
					 }
					 addParam(paramName, paramValues);
					 state = State.PARAM_NAME;
					 startIndex = i + 1;
				 }
				 else if (currentChar == ',') {
					 if (startIndex < i) {
						 paramValues = addParamValue(paramValues, line.substring(startIndex, i));
					 }
					 startIndex = i + 1;
				 }
			 }
			 else if (state == State.QUOTED_PARAM_VALUE) {
				 if (currentChar == '""') {
					 state = State.PARAM_VALUE;
					 paramValues = addParamValue(paramValues, line.substring(startIndex, i));
					 startIndex = i + 1;
				 }
			 }
			 else if (state == State.VALUE) {
				 if (currentChar == '\\') {
					 state = State.BACKSLASH;
				 }
				 else if (currentChar == ';
				' || (MULTIVALUED_PROPERTIES.contains(key) && currentChar == ',')) {
					 addValue(line.substring(startIndex, i));
					 startIndex = i + 1;
				 }
			 }
			 else if (state == State.BACKSLASH) {
				 state = State.VALUE;
			 }
		 }
		 if (state == State.VALUE) {
			 addValue(line.substring(startIndex));
		 }
		 else {
			 throw new IllegalArgumentException(""Invalid property line: "" + line);
		 }
	 }
 }",0,0,1,0
"public Calendar advance(Calendar calendar, int offsetAmount,int offsetUnit, BusinessDayConvention businessDayConvention);",0,0,0,0
"public static Collection<KSMetaData> readTablesFromYaml() throws ConfigurationException {
	 List<KSMetaData> defs = new ArrayList<KSMetaData>();
	 for (RawKeyspace keyspace : conf.keyspaces) {
		 if (keyspace.name == null) {
			 throw new ConfigurationException(""Keyspace name attribute is required"");
		 }
		 if (keyspace.name.equalsIgnoreCase(Table.SYSTEM_TABLE)) {
			 throw new ConfigurationException(""'system' is a reserved table name for Cassandra internals"");
		 }
		 if (keyspace.replica_placement_strategy == null) {
			 throw new ConfigurationException(""Missing replica_placement_strategy directive for "" + keyspace.name);
		 }
		 String strategyClassName = KSMetaData.convertOldStrategyName(keyspace.replica_placement_strategy);
		 Class<AbstractReplicationStrategy> strategyClass = FBUtilities.classForName(strategyClassName, ""replication-strategy"");
		 if (keyspace.replication_factor == null) {
			 throw new ConfigurationException(""Missing replication_factor directory for keyspace "" + keyspace.name);
		 }
		 int size2 = keyspace.column_families.length;
		 CFMetaData[] cfDefs = new CFMetaData[size2];
		 int j = 0;
		 for (RawColumnFamily cf : keyspace.column_families) {
			 if (cf.name == null) {
				 throw new ConfigurationException(""ColumnFamily name attribute is required"");
			 }
			 if (!cf.name.matches(Migration.NAME_VALIDATOR_REGEX)) {
				 throw new ConfigurationException(""ColumnFamily name contains invalid characters."");
			 }
			 AbstractType comparator = getComparator(cf.compare_with);
			 AbstractType subcolumnComparator = null;
			 AbstractType default_validator = getComparator(cf.default_validation_class);
			 ColumnFamilyType cfType = cf.column_type == null ? ColumnFamilyType.Standard : cf.column_type;
			 if (cfType == ColumnFamilyType.Super) {
				 subcolumnComparator = getComparator(cf.compare_subcolumns_with);
			 }
			 else if (cf.compare_subcolumns_with != null) {
				 throw new ConfigurationException(""compare_subcolumns_with is only a valid attribute on super columnfamilies (not regular columnfamily "" + cf.name + "")"");
			 }
			 if (cf.read_repair_chance < 0.0 || cf.read_repair_chance > 1.0) {
				 throw new ConfigurationException(""read_repair_chance must be between 0.0 and 1.0 (0% and 100%)"");
			 }
			 if (conf.dynamic_snitch_badness_threshold < 0.0 || conf.dynamic_snitch_badness_threshold > 1.0) {
				 throw new ConfigurationException(""dynamic_snitch_badness_threshold must be between 0.0 and 1.0 (0% and 100%)"");
			 }
			 if (cf.min_compaction_threshold < 0 || cf.max_compaction_threshold < 0) {
				 throw new ConfigurationException(""min/max_compaction_thresholds must be positive integers."");
			 }
			 if ((cf.min_compaction_threshold > cf.max_compaction_threshold) && cf.max_compaction_threshold != 0) {
				 throw new ConfigurationException(""min_compaction_threshold must be smaller than max_compaction_threshold, or either must be 0 (disabled)"");
			 }
			 if (cf.memtable_throughput_in_mb == null) {
				 cf.memtable_throughput_in_mb = CFMetaData.sizeMemtableThroughput();
				 logger.info(""memtable_throughput_in_mb not configured for "" + cf.name + "", using "" + cf.memtable_throughput_in_mb);
			 }
			 if (cf.memtable_operations_in_millions == null) {
				 cf.memtable_operations_in_millions = CFMetaData.sizeMemtableOperations(cf.memtable_throughput_in_mb);
				 logger.info(""memtable_operations_in_millions not configured for "" + cf.name + "", using "" + cf.memtable_operations_in_millions);
			 }
			 if (cf.memtable_operations_in_millions != null && cf.memtable_operations_in_millions <= 0) {
				 throw new ConfigurationException(""memtable_operations_in_millions must be a positive double"");
			 }
			 Map<ByteBuffer, ColumnDefinition> metadata = new TreeMap<ByteBuffer, ColumnDefinition>();
			 for (RawColumnDefinition rcd : cf.column_metadata) {
				 if (rcd.name == null) {
					 throw new ConfigurationException(""name is required for column definitions."");
				 }
				 if (rcd.validator_class == null) {
					 throw new ConfigurationException(""validator is required for column definitions"");
				 }
				 if ((rcd.index_type == null) && (rcd.index_name != null)) {
					 throw new ConfigurationException(""index_name cannot be set if index_type is not also set"");
				 }
				 ByteBuffer columnName = ByteBuffer.wrap(rcd.name.getBytes(Charsets.UTF_8));
				 metadata.put(columnName, new ColumnDefinition(columnName, rcd.validator_class, rcd.index_type, rcd.index_name));
			 }
			 cfDefs[j++] = new CFMetaData(keyspace.name, cf.name, cfType, comparator, subcolumnComparator, cf.comment, cf.rows_cached, cf.keys_cached, cf.read_repair_chance, cf.gc_grace_seconds, default_validator, cf.min_compaction_threshold, cf.max_compaction_threshold, cf.row_cache_save_period_in_seconds, cf.key_cache_save_period_in_seconds, cf.memtable_flush_after_mins, cf.memtable_throughput_in_mb, cf.memtable_operations_in_millions, metadata);
		 }
		 defs.add(new KSMetaData(keyspace.name, strategyClass, keyspace.strategy_options, keyspace.replication_factor, cfDefs));
	 }
	 return defs;
 }",0,0,1,0
"public class AugmentReference extends Task implements TypeAdapter {
	 private String id;
	 public void checkProxyClass(Class proxyClass) {
	 }
	 public synchronized Object getProxy() {
		 if (getProject() == null) {
			 throw new IllegalStateException(getTaskName() + ""Project owner unset"");
		 }
		 hijackId();
		 if (getProject().hasReference(id)) {
			 Object result = getProject().getReference(id);
			 log(""project reference "" + id + ""="" + String.valueOf(result), Project.MSG_DEBUG);
			 return result;
		 }
		 throw new IllegalStateException(""Unknown reference \"""" + id + ""\"""");
	 }
	 public void setProxy(Object o) {
		 throw new UnsupportedOperationException();
	 }
	 private synchronized void hijackId() {
		 if (id == null) {
			 RuntimeConfigurable wrapper = getWrapper();
			 id = wrapper.getId();
			 if (id == null) {
				 throw new IllegalStateException(getTaskName() + "" attribute 'id' unset"");
			 }
			 wrapper.setAttribute(""id"", null);
			 wrapper.removeAttribute(""id"");
			 wrapper.setElementTag(""augmented reference \"""" + id + ""\"""");
		 }
	 }
	 public void execute() {
		 restoreWrapperId();
	 }
	 private synchronized void restoreWrapperId() {
		 if (id != null) {
			 log(""restoring augment wrapper "" + id, Project.MSG_DEBUG);
			 RuntimeConfigurable wrapper = getWrapper();
			 wrapper.setAttribute(""id"", id);
			 wrapper.setElementTag(getTaskName());
			 id = null;
		 }
	 }
}",0,0,0,0
"public void clearScript() {
	 this.script = """";
 }",0,0,0,0
"protected void setup(Commandline cmd, Native2Ascii args) throws BuildException {
	 if (args.getEncoding() != null) {
		 cmd.createArgument().setValue(""-encoding"");
		 cmd.createArgument().setValue(args.getEncoding());
	 }
	 cmd.addArguments(args.getCurrentArgs());
 }",0,0,0,0
"public void setPrefix(final String prefix) {
	 this.prefix = prefix;
 }",0,0,0,0
"static class LogStream implements org.apache.aurora.scheduler.log.Log.Stream {
	 static final class OpStats {
		 private final String opName;
		 private final SlidingStats timing;
		 private final AtomicLong timeouts;
		 private final AtomicLong failures;
		 OpStats(String opName) {
			 this.opName = MorePreconditions.checkNotBlank(opName);
			 timing = new SlidingStats(""scheduler_log_native_"" + opName, ""nanos"");
			 timeouts = exportLongStat(""scheduler_log_native_%s_timeouts"", opName);
			 failures = exportLongStat(""scheduler_log_native_%s_failures"", opName);
		 }
		 private static AtomicLong exportLongStat(String template, Object... args) {
			 return Stats.exportLong(String.format(template, args));
		 }
	 }
	 private static final Function<Log.Entry, LogEntry> MESOS_ENTRY_TO_ENTRY = LogEntry::new;
	 private final OpStats readStats = new OpStats(""read"");
	 private final OpStats appendStats = new OpStats(""append"");
	 private final OpStats truncateStats = new OpStats(""truncate"");
	 private final AtomicLong entriesSkipped = Stats.exportLong(""scheduler_log_native_native_entries_skipped"");
	 private final LogInterface log;
	 private final ReaderInterface reader;
	 private final long readTimeout;
	 private final TimeUnit readTimeUnit;
	 private final Provider<WriterInterface> writerFactory;
	 private final long writeTimeout;
	 private final TimeUnit writeTimeUnit;
	 private final byte[] noopEntry;
	 private final Lifecycle lifecycle;
	 private Optional<WriterInterface> writer = Optional.empty();
	 LogStream( LogInterface log, ReaderInterface reader, Amount<Long, Time> readTimeout, Provider<WriterInterface> writerFactory, Amount<Long, Time> writeTimeout, byte[] noopEntry, Lifecycle lifecycle) {
		 this.log = log;
		 this.reader = reader;
		 this.readTimeout = readTimeout.getValue();
		 this.readTimeUnit = readTimeout.getUnit().getTimeUnit();
		 this.writerFactory = writerFactory;
		 this.writeTimeout = writeTimeout.getValue();
		 this.writeTimeUnit = writeTimeout.getUnit().getTimeUnit();
		 this.noopEntry = noopEntry;
		 this.lifecycle = lifecycle;
	 }
	 public Iterator<Entry> readAll() throws StreamAccessException {
		 try {
			 append(noopEntry);
		 }
		 catch (StreamAccessException e) {
			 throw new StreamAccessException(""Error writing noop prior to a read"", e);
		 }
		 final Log.Position from = reader.beginning();
		 final Log.Position to = end().unwrap();
		 return new UnmodifiableIterator<Entry>() {
			 private long position = Longs.fromByteArray(from.identity());
			 private final long endPosition = Longs.fromByteArray(to.identity());
			 private Entry entry = null;
			 public boolean hasNext() {
				 if (entry != null) {
					 return true;
				 }
				 while (position <= endPosition) {
					 long start = System.nanoTime();
					 try {
						 Log.Position p = log.position(Longs.toByteArray(position));
						 LOG.debug(""Reading position {
						}
						 from the log"", position);
						 List<Log.Entry> entries = reader.read(p, p, readTimeout, readTimeUnit);
						 position++;
						 if (entries.isEmpty()) {
							 entriesSkipped.getAndIncrement();
						 }
						 else {
							 entry = MESOS_ENTRY_TO_ENTRY.apply(Iterables.getOnlyElement(entries));
							 return true;
						 }
					 }
					 catch (TimeoutException e) {
						 readStats.timeouts.getAndIncrement();
						 throw new StreamAccessException(""Timeout reading from log."", e);
					 }
					 catch (Log.OperationFailedException e) {
						 readStats.failures.getAndIncrement();
						 throw new StreamAccessException(""Problem reading from log"", e);
					 }
					 finally {
						 readStats.timing.accumulate(System.nanoTime() - start);
					 }
				 }
				 return false;
			 }
			 public Entry next() {
				 if (entry == null && !hasNext()) {
					 throw new NoSuchElementException();
				 }
				 Entry result = requireNonNull(entry);
				 entry = null;
				 return result;
			 }
		 }
		;
	 }
	 public LogPosition append(final byte[] contents) throws StreamAccessException {
		 requireNonNull(contents);
		 Log.Position position = mutate( appendStats, logWriter -> logWriter.append(contents, writeTimeout, writeTimeUnit));
		 return LogPosition.wrap(position);
	 }
	 public void truncateBefore(org.apache.aurora.scheduler.log.Log.Position position) throws StreamAccessException {
		 Preconditions.checkArgument(position instanceof LogPosition);
		 final Log.Position before = ((LogPosition) position).unwrap();
		 mutate(truncateStats, logWriter -> {
			 logWriter.truncate(before, writeTimeout, writeTimeUnit);
			 return null;
		 }
		);
	 }
	 private interface Mutation<T> {
		 T apply(WriterInterface writer) throws TimeoutException, Log.WriterFailedException;
	 }
	 private StreamAccessException disableLog(AtomicLong stat, String message, Throwable cause) {
		 stat.incrementAndGet();
		 writer = null;
		 lifecycle.shutdown();
		 throw new StreamAccessException(message, cause);
	 }
	 private synchronized <T> T mutate(OpStats stats, Mutation<T> mutation) {
		 if (writer == null) {
			 throw new IllegalStateException(""The log has encountered an error and cannot be used."");
		 }
		 long start = System.nanoTime();
		 if (!writer.isPresent()) {
			 writer = Optional.of(writerFactory.get());
		 }
		 try {
			 return mutation.apply(writer.get());
		 }
		 catch (TimeoutException e) {
			 throw disableLog(stats.timeouts, ""Timeout performing log "" + stats.opName, e);
		 }
		 catch (Log.WriterFailedException e) {
			 throw disableLog(stats.failures, ""Problem performing log"" + stats.opName, e);
		 }
		 finally {
			 stats.timing.accumulate(System.nanoTime() - start);
		 }
	 }
	 private LogPosition end() {
		 return LogPosition.wrap(reader.ending());
	 }
	 static class LogPosition implements org.apache.aurora.scheduler.log.Log.Position {
		 private final Log.Position underlying;
		 LogPosition(Log.Position underlying) {
			 this.underlying = underlying;
		 }
		 static LogPosition wrap(Log.Position position) {
			 return new LogPosition(position);
		 }
		 Log.Position unwrap() {
			 return underlying;
		 }
	 }
	 private static class LogEntry implements org.apache.aurora.scheduler.log.Log.Entry {
		 private final Log.Entry underlying;
		 LogEntry(Log.Entry entry) {
			 this.underlying = entry;
		 }
		 public byte[] contents() {
			 return underlying.data;
		 }
	 }
 }",1,1,0,0
"public class FlowFileUnpackagerV1 implements FlowFileUnpackager {
	 private int flowFilesRead = 0;
	 public Map<String, String> unpackageFlowFile(final InputStream in, final OutputStream out) throws IOException {
		 flowFilesRead++;
		 final TarArchiveInputStream tarIn = new TarArchiveInputStream(in);
		 final TarArchiveEntry attribEntry = tarIn.getNextTarEntry();
		 if (attribEntry == null) {
			 return null;
		 }
		 final Map<String, String> attributes;
		 if (attribEntry.getName().equals(FlowFilePackagerV1.FILENAME_ATTRIBUTES)) {
			 attributes = getAttributes(tarIn);
		 }
		 else {
			 throw new IOException(""Expected two tar entries: "" + FlowFilePackagerV1.FILENAME_CONTENT + "" and "" + FlowFilePackagerV1.FILENAME_ATTRIBUTES);
		 }
		 final TarArchiveEntry contentEntry = tarIn.getNextTarEntry();
		 if (contentEntry != null && contentEntry.getName().equals(FlowFilePackagerV1.FILENAME_CONTENT)) {
			 final byte[] buffer = new byte[512 << 10];
			 int bytesRead = 0;
			 while ((bytesRead = tarIn.read(buffer)) != -1) {
				 if (bytesRead > 0) {
					 out.write(buffer, 0, bytesRead);
				 }
			 }
			 out.flush();
		 }
		 else {
			 throw new IOException(""Expected two tar entries: "" + FlowFilePackagerV1.FILENAME_CONTENT + "" and "" + FlowFilePackagerV1.FILENAME_ATTRIBUTES);
		 }
		 return attributes;
	 }
	 protected Map<String, String> getAttributes(final TarArchiveInputStream stream) throws IOException {
		 final Properties props = new Properties();
		 props.loadFromXML(new NonCloseableInputStream(stream));
		 final Map<String, String> result = new HashMap<>();
		 for (final Entry<Object, Object> entry : props.entrySet()) {
			 final Object keyObject = entry.getKey();
			 final Object valueObject = entry.getValue();
			 if (!(keyObject instanceof String)) {
				 throw new IOException(""Flow file attributes object contains key of type "" + keyObject.getClass().getCanonicalName() + "" but expected java.lang.String"");
			 }
			 else if (!(keyObject instanceof String)) {
				 throw new IOException(""Flow file attributes object contains value of type "" + keyObject.getClass().getCanonicalName() + "" but expected java.lang.String"");
			 }
			 final String key = (String) keyObject;
			 final String value = (String) valueObject;
			 result.put(key, value);
		 }
		 return result;
	 }
	 public boolean hasMoreData() throws IOException {
		 return flowFilesRead == 0;
	 }
	 public static final class NonCloseableInputStream extends InputStream {
		 final InputStream stream;
		 public NonCloseableInputStream(final InputStream stream) {
			 this.stream = stream;
		 }
		 public void close() {
		 }
		 public int read() throws IOException {
			 return stream.read();
		 }
		 public int available() throws IOException {
			 return stream.available();
		 }
		 public synchronized void mark(int readlimit) {
			 stream.mark(readlimit);
		 }
		 public synchronized void reset() throws IOException {
			 stream.reset();
		 }
		 public boolean markSupported() {
			 return stream.markSupported();
		 }
		 public long skip(long n) throws IOException {
			 return stream.skip(n);
		 }
		 public int read(byte b[], int off, int len) throws IOException {
			 return stream.read(b, off, len);
		 }
		 public int read(byte b[]) throws IOException {
			 return stream.read(b);
		 }
	 }
}",1,0,0,0
"private static class JCARepositoryFactory implements RepositoryFactory, Serializable {
	private static final long serialVersionUID = 5364039431121341634L;
	private final JCAManagedConnectionFactory mcf;
	 public JCARepositoryFactory(JCAManagedConnectionFactory mcf) {
		 this.mcf = mcf;
	 }
	 public Repository getRepository() throws RepositoryException {
		 return mcf.getRepository();
	 }
 }",0,0,0,0
"public class BinaryInputArchive implements InputArchive {
	 private DataInput in;
	 static BinaryInputArchive getArchive(InputStream strm) {
		 return new BinaryInputArchive(new DataInputStream(strm));
	 }
	 static private class BinaryIndex implements Index {
		 private int nelems;
		 BinaryIndex(int nelems) {
			 this.nelems = nelems;
		 }
		 public boolean done() {
			 return (nelems <= 0);
		 }
		 public void incr() {
			 nelems--;
		 }
	 }
	 public BinaryInputArchive(DataInput in) {
		 this.in = in;
	 }
	 public byte readByte(String tag) throws IOException {
		 return in.readByte();
	 }
	 public boolean readBool(String tag) throws IOException {
		 return in.readBoolean();
	 }
	 public int readInt(String tag) throws IOException {
		 return WritableUtils.readVInt(in);
	 }
	 public long readLong(String tag) throws IOException {
		 return WritableUtils.readVLong(in);
	 }
	 public float readFloat(String tag) throws IOException {
		 return in.readFloat();
	 }
	 public double readDouble(String tag) throws IOException {
		 return in.readDouble();
	 }
	 public Text readString(String tag) throws IOException {
		 Text text = new Text();
		 text.readFields(in);
		 return text;
	 }
	 public ByteArrayOutputStream readBuffer(String tag) throws IOException {
		 int len = readInt(tag);
		 ByteArrayOutputStream buf = new ByteArrayOutputStream(len);
		 byte[] arr = new byte[len];
		 in.readFully(arr);
		 buf.write(arr, 0, len);
		 return buf;
	 }
	 public void readRecord(Record r, String tag) throws IOException {
		 r.deserialize(this, tag);
	 }
	 public void startRecord(String tag) throws IOException {
	}
	 public void endRecord(String tag) throws IOException {
	}
	 public Index startVector(String tag) throws IOException {
		 return new BinaryIndex(readInt(tag));
	 }
	 public void endVector(String tag) throws IOException {
	}
	 public Index startMap(String tag) throws IOException {
		 return new BinaryIndex(readInt(tag));
	 }
	 public void endMap(String tag) throws IOException {
	}
}",0,0,0,0
"public class Rpm extends Task {
	 private static final String PATH1 = ""PATH="";
	 private static final String PATH2 = ""Path="";
	 private static final String PATH3 = ""path="";
	 private static final int PATH_LEN = PATH1.length();
	 private String specFile;
	 private File topDir;
	 private String command = ""-bb"";
	 private String rpmBuildCommand = null;
	 private boolean cleanBuildDir = false;
	 private boolean removeSpec = false;
	 private boolean removeSource = false;
	 private File output;
	 private File error;
	 private boolean failOnError = false;
	 private boolean quiet = false;
	 public void execute() throws BuildException {
		 Commandline toExecute = new Commandline();
		 toExecute.setExecutable(rpmBuildCommand == null ? guessRpmBuildCommand() : rpmBuildCommand);
		 if (topDir != null) {
			 toExecute.createArgument().setValue(""--define"");
			 toExecute.createArgument().setValue(""_topdir"" + topDir);
		 }
		 toExecute.createArgument().setLine(command);
		 if (cleanBuildDir) {
			 toExecute.createArgument().setValue(""--clean"");
		 }
		 if (removeSpec) {
			 toExecute.createArgument().setValue(""--rmspec"");
		 }
		 if (removeSource) {
			 toExecute.createArgument().setValue(""--rmsource"");
		 }
		 toExecute.createArgument().setValue(""SPECS/"" + specFile);
		 ExecuteStreamHandler streamhandler = null;
		 OutputStream outputstream = null;
		 OutputStream errorstream = null;
		 if (error == null && output == null) {
			 if (!quiet) {
				 streamhandler = new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN);
			 }
			 else {
				 streamhandler = new LogStreamHandler(this, Project.MSG_DEBUG, Project.MSG_DEBUG);
			 }
		 }
		 else {
			 if (output != null) {
				 try {
					 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(output));
					 outputstream = new PrintStream(bos);
				 }
				 catch (IOException e) {
					 throw new BuildException(e, getLocation());
				 }
			 }
			 else if (!quiet) {
				 outputstream = new LogOutputStream(this, Project.MSG_INFO);
			 }
			 else {
				 outputstream = new LogOutputStream(this, Project.MSG_DEBUG);
			 }
			 if (error != null) {
				 try {
					 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(error));
					 errorstream = new PrintStream(bos);
				 }
				 catch (IOException e) {
					 throw new BuildException(e, getLocation());
				 }
			 }
			 else if (!quiet) {
				 errorstream = new LogOutputStream(this, Project.MSG_WARN);
			 }
			 else {
				 errorstream = new LogOutputStream(this, Project.MSG_DEBUG);
			 }
			 streamhandler = new PumpStreamHandler(outputstream, errorstream);
		 }
		 Execute exe = getExecute(toExecute, streamhandler);
		 try {
			 log(""Building the RPM based on the "" + specFile + "" file"");
			 int returncode = exe.execute();
			 if (Execute.isFailure(returncode)) {
				 String msg = ""'"" + toExecute.getExecutable() + ""' failed with exit code "" + returncode;
				 if (failOnError) {
					 throw new BuildException(msg);
				 }
				 else {
					 log(msg, Project.MSG_ERR);
				 }
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(e, getLocation());
		 }
		 finally {
			 FileUtils.close(outputstream);
			 FileUtils.close(errorstream);
		 }
	 }
	 public void setTopDir(File td) {
		 this.topDir = td;
	 }
	 public void setCommand(String c) {
		 this.command = c;
	 }
	 public void setSpecFile(String sf) {
		 if ((sf == null) || (sf.trim().length() == 0)) {
			 throw new BuildException(""You must specify a spec file"", getLocation());
		 }
		 this.specFile = sf;
	 }
	 public void setCleanBuildDir(boolean cbd) {
		 cleanBuildDir = cbd;
	 }
	 public void setRemoveSpec(boolean rs) {
		 removeSpec = rs;
	 }
	 public void setRemoveSource(boolean rs) {
		 removeSource = rs;
	 }
	 public void setOutput(File output) {
		 this.output = output;
	 }
	 public void setError(File error) {
		 this.error = error;
	 }
	 public void setRpmBuildCommand(String c) {
		 this.rpmBuildCommand = c;
	 }
	 public void setFailOnError(boolean value) {
		 failOnError = value;
	 }
	 public void setQuiet(boolean value) {
		 quiet = value;
	 }
	 protected String guessRpmBuildCommand() {
		 Vector env = Execute.getProcEnvironment();
		 String path = null;
		 for (Enumeration e = env.elements();
		 e.hasMoreElements();
		) {
			 String var = (String) e.nextElement();
			 if (var.startsWith(PATH1) || var.startsWith(PATH2) || var.startsWith(PATH3)) {
				 path = var.substring(PATH_LEN);
				 break;
			 }
		 }
		 if (path != null) {
			 Path p = new Path(getProject(), path);
			 String[] pElements = p.list();
			 for (int i = 0;
			 i < pElements.length;
			 i++) {
				 File f = new File(pElements[i], ""rpmbuild"" + (Os.isFamily(""dos"") ? "".exe"" : """"));
				 if (f.canRead()) {
					 return f.getAbsolutePath();
				 }
			 }
		 }
		 return ""rpm"";
	 }
	 protected Execute getExecute(Commandline toExecute, ExecuteStreamHandler streamhandler) {
		 Execute exe = new Execute(streamhandler, null);
		 exe.setAntRun(getProject());
		 if (topDir == null) {
			 topDir = getProject().getBaseDir();
		 }
		 exe.setWorkingDirectory(topDir);
		 exe.setCommandline(toExecute.getCommandline());
		 return exe;
	 }
}",0,0,0,0
"public class FeeRenewResponseExtensionV06 extends FeeTransformResponseExtension {
	 public ImmutableList<Credit> getCredits() {
		 return super.getCredits();
	 }
}",0,0,0,0
"public class MapFile {
	 public static final String INDEX_FILE_NAME = ""index"";
	 public static final String DATA_FILE_NAME = ""data"";
	 protected MapFile() {
	}
	 public static class Writer {
		 private SequenceFile.Writer data;
		 private SequenceFile.Writer index;
		 private int indexInterval = 128;
		 private long size;
		 private LongWritable position = new LongWritable();
		 private WritableComparator comparator;
		 private DataInputBuffer inBuf = new DataInputBuffer();
		 private DataOutputBuffer outBuf = new DataOutputBuffer();
		 private WritableComparable lastKey;
		 public Writer(FileSystem fs, String dirName, Class keyClass, Class valClass) throws IOException {
			 this(fs, dirName, WritableComparator.get(keyClass), valClass, false);
		 }
		 public Writer(FileSystem fs, String dirName, Class keyClass, Class valClass, boolean compress) throws IOException {
			 this(fs, dirName, WritableComparator.get(keyClass), valClass, compress);
		 }
		 public Writer(FileSystem fs, String dirName, WritableComparator comparator, Class valClass) throws IOException {
			 this(fs, dirName, comparator, valClass, false);
		 }
		 public Writer(FileSystem fs, String dirName, WritableComparator comparator, Class valClass, boolean compress) throws IOException {
			 this.comparator = comparator;
			 this.lastKey = comparator.newKey();
			 Path dir = new Path(dirName);
			 fs.mkdirs(dir);
			 Path dataFile = new Path(dir, DATA_FILE_NAME);
			 Path indexFile = new Path(dir, INDEX_FILE_NAME);
			 Class keyClass = comparator.getKeyClass();
			 this.data = new SequenceFile.Writer(fs, dataFile, keyClass, valClass, compress);
			 this.index = new SequenceFile.Writer(fs, indexFile, keyClass, LongWritable.class);
		 }
		 public int getIndexInterval() {
			 return indexInterval;
		 }
		 public void setIndexInterval(int interval) {
			 indexInterval = interval;
		 }
		 public synchronized void close() throws IOException {
			 data.close();
			 index.close();
		 }
		 public synchronized void append(WritableComparable key, Writable val) throws IOException {
			 checkKey(key);
			 if (size % indexInterval == 0) {
				 position.set(data.getLength());
				 index.append(key, position);
			 }
			 data.append(key, val);
			 size++;
		 }
		 private void checkKey(WritableComparable key) throws IOException {
			 if (size != 0 && comparator.compare(lastKey, key) > 0) throw new IOException(""key out of order: ""+key+"" after ""+lastKey);
			 outBuf.reset();
			 key.write(outBuf);
			 inBuf.reset(outBuf.getData(), outBuf.getLength());
			 lastKey.readFields(inBuf);
		 }
	 }
	 public static class Reader {
		 private int INDEX_SKIP = 0;
		 private WritableComparator comparator;
		 private DataOutputBuffer keyBuf = new DataOutputBuffer();
		 private DataOutputBuffer nextBuf = new DataOutputBuffer();
		 private int nextKeyLen = -1;
		 private long seekPosition = -1;
		 private int seekIndex = -1;
		 private long firstPosition;
		 private WritableComparable getKey;
		 private SequenceFile.Reader data;
		 private SequenceFile.Reader index;
		 private boolean indexClosed = false;
		 private int count = -1;
		 private WritableComparable[] keys;
		 private long[] positions;
		 public Class getKeyClass() {
			 return data.getKeyClass();
		 }
		 public Class getValueClass() {
			 return data.getValueClass();
		 }
		 public Reader(FileSystem fs, String dirName, Configuration conf) throws IOException {
			 this(fs, dirName, null, conf);
			 INDEX_SKIP = conf.getInt(""io.map.index.skip"", 0);
		 }
		 public Reader(FileSystem fs, String dirName, WritableComparator comparator, Configuration conf) throws IOException {
			 Path dir = new Path(dirName);
			 Path dataFile = new Path(dir, DATA_FILE_NAME);
			 Path indexFile = new Path(dir, INDEX_FILE_NAME);
			 this.data = new SequenceFile.Reader(fs, dataFile, conf);
			 this.firstPosition = data.getPosition();
			 if (comparator == null) this.comparator = WritableComparator.get(data.getKeyClass());
			 else this.comparator = comparator;
			 this.getKey = this.comparator.newKey();
			 this.index = new SequenceFile.Reader(fs, indexFile, conf);
		 }
		 private void readIndex() throws IOException {
			 if (this.keys != null) return;
			 this.count = 0;
			 this.keys = new WritableComparable[1024];
			 this.positions = new long[1024];
			 try {
				 int skip = INDEX_SKIP;
				 LongWritable position = new LongWritable();
				 WritableComparable lastKey = null;
				 while (true) {
					 WritableComparable k = comparator.newKey();
					 if (!index.next(k, position)) break;
					 if (lastKey != null && comparator.compare(lastKey, k) > 0) throw new IOException(""key out of order: ""+k+"" after ""+lastKey);
					 lastKey = k;
					 if (skip > 0) {
						 skip--;
						 continue;
					 }
					 else {
						 skip = INDEX_SKIP;
					 }
					 if (count == keys.length) {
						 int newLength = (keys.length*3)/2;
						 WritableComparable[] newKeys = new WritableComparable[newLength];
						 long[] newPositions = new long[newLength];
						 System.arraycopy(keys, 0, newKeys, 0, count);
						 System.arraycopy(positions, 0, newPositions, 0, count);
						 keys = newKeys;
						 positions = newPositions;
					 }
					 keys[count] = k;
					 positions[count] = position.get();
					 count++;
				 }
			 }
			 catch (EOFException e) {
				 SequenceFile.LOG.warn(""Unexpected EOF reading "" + index + "" at entry #"" + count + "". Ignoring."");
			 }
			 finally {
				indexClosed = true;
				 index.close();
			 }
		 }
		 public synchronized void reset() throws IOException {
			 data.seek(firstPosition);
		 }
		 public synchronized void finalKey(WritableComparable key) throws IOException {
			 long originalPosition = data.getPosition();
			 try {
				 readIndex();
				 if (count > 0) {
					 data.seek(positions[count-1]);
				 }
				 else {
					 reset();
				 }
				 while (data.next(key)) {
				}
			 }
			 finally {
				 data.seek(originalPosition);
			 }
		 }
		 public synchronized boolean seek(WritableComparable key) throws IOException {
			 readIndex();
			 keyBuf.reset();
			 key.write(keyBuf);
			 if (seekIndex != -1 && seekIndex+1 < count && comparator.compare(key,keys[seekIndex+1])<0 && comparator.compare(keyBuf.getData(), 0, keyBuf.getLength(), nextBuf.getData(), 0, nextKeyLen) >= 0) {
			 }
			 else {
				 seekIndex = binarySearch(key);
				 if (seekIndex < 0) seekIndex = -seekIndex-2;
				 if (seekIndex == -1) seekPosition = firstPosition;
				 else seekPosition = positions[seekIndex];
			 }
			 data.seek(seekPosition);
			 while ((nextKeyLen = data.next(nextBuf.reset())) != -1) {
				 int c = comparator.compare(keyBuf.getData(), 0, keyBuf.getLength(), nextBuf.getData(), 0, nextKeyLen);
				 if (c <= 0) {
					 data.seek(seekPosition);
					 return c == 0;
				 }
				 seekPosition = data.getPosition();
			 }
			 return false;
		 }
		 private int binarySearch(WritableComparable key) {
			 int low = 0;
			 int high = count-1;
			 while (low <= high) {
				 int mid = (low + high) >> 1;
				 WritableComparable midVal = keys[mid];
				 int cmp = comparator.compare(midVal, key);
				 if (cmp < 0) low = mid + 1;
				 else if (cmp > 0) high = mid - 1;
				 else return mid;
			 }
			 return -(low + 1);
		 }
		 public synchronized boolean next(WritableComparable key, Writable val) throws IOException {
			 return data.next(key, val);
		 }
		 public synchronized Writable get(WritableComparable key, Writable val) throws IOException {
			 if (seek(key)) {
				 next(getKey, val);
				 return val;
			 }
			 else return null;
		 }
		 public synchronized void close() throws IOException {
			 if (! indexClosed) {
				index.close();
			 }
			 data.close();
		 }
	 }
	 public static void rename(FileSystem fs, String oldName, String newName) throws IOException {
		 Path oldDir = new Path(oldName);
		 Path newDir = new Path(newName);
		 if (!fs.rename(oldDir, newDir)) {
			 throw new IOException(""Could not rename "" + oldDir + "" to "" + newDir);
		 }
	 }
	 public static void delete(FileSystem fs, String name) throws IOException {
		 Path dir = new Path(name);
		 Path data = new Path(dir, DATA_FILE_NAME);
		 Path index = new Path(dir, INDEX_FILE_NAME);
		 fs.delete(data);
		 fs.delete(index);
		 fs.delete(dir);
	 }
	 public static long fix(FileSystem fs, Path dir, Class keyClass, Class valueClass, boolean dryrun, Configuration conf) throws Exception {
		 String dr = (dryrun ? ""[DRY RUN ] "" : """");
		 Path data = new Path(dir, DATA_FILE_NAME);
		 Path index = new Path(dir, INDEX_FILE_NAME);
		 int indexInterval = 128;
		 if (!fs.exists(data)) {
			 throw new Exception(dr + ""Missing data file in "" + dir + "", impossible to fix this."");
		 }
		 if (fs.exists(index)) {
			 return -1;
		 }
		 SequenceFile.Reader dataReader = new SequenceFile.Reader(fs, data, conf);
		 if (!dataReader.getKeyClass().equals(keyClass)) {
			 throw new Exception(dr + ""Wrong key class in "" + dir + "", expected"" + keyClass.getName() + "", got "" + dataReader.getKeyClass().getName());
		 }
		 if (!dataReader.getValueClass().equals(valueClass)) {
			 throw new Exception(dr + ""Wrong value class in "" + dir + "", expected"" + valueClass.getName() + "", got "" + dataReader.getValueClass().getName());
		 }
		 long cnt = 0L;
		 Writable key = (Writable)keyClass.getConstructor(new Class[0]).newInstance(new Object[0]);
		 Writable value = (Writable)valueClass.getConstructor(new Class[0]).newInstance(new Object[0]);
		 SequenceFile.Writer indexWriter = null;
		 if (!dryrun) indexWriter = new SequenceFile.Writer(fs, index, keyClass, LongWritable.class);
		 try {
			 long pos = 0L;
			 LongWritable position = new LongWritable();
			 while(dataReader.next(key, value)) {
				 cnt++;
				 if (cnt % indexInterval == 0) {
					 position.set(pos);
					 if (!dryrun) indexWriter.append(key, position);
				 }
				 pos = dataReader.getPosition();
			 }
		 }
		 catch(Throwable t) {
		 }
		 dataReader.close();
		 if (!dryrun) indexWriter.close();
		 return cnt;
	 }
	 public static void main(String[] args) throws Exception {
		 String usage = ""Usage: MapFile inFile outFile"";
		 if (args.length != 2) {
			 System.err.println(usage);
			 System.exit(-1);
		 }
		 String in = args[0];
		 String out = args[1];
		 Configuration conf = new Configuration();
		 int ioFileBufferSize = conf.getInt(""io.file.buffer.size"", 4096);
		 FileSystem fs = new LocalFileSystem(conf);
		 MapFile.Reader reader = new MapFile.Reader(fs, in, conf);
		 MapFile.Writer writer = new MapFile.Writer(fs, out, reader.getKeyClass(), reader.getValueClass());
		 WritableComparable key = (WritableComparable)reader.getKeyClass().newInstance();
		 Writable value = (Writable)reader.getValueClass().newInstance();
		 while (reader.next(key, value)) writer.append(key, value);
		 writer.close();
	 }
}",0,0,0,0
"public abstract class Page extends MarkupContainer implements IRedirectListener, IPageMapEntry{
	public static interface IPageSerializer{
		public void deserializePage(int id, String name, Page page, ObjectInputStream stream)throws IOException, ClassNotFoundException;
		public void serializePage(Page page, ObjectOutputStream stream) throws IOException;
		public Object getPageReplacementObject(Page serializedPage);
	}
	public static final int LATEST_VERSION = -1;
	public static final ThreadLocal<IPageSerializer> serializer = new ThreadLocal<IPageSerializer>();
	private static final short FLAG_NEW_VERSION = FLAG_RESERVED3;
	private static final int FLAG_STATELESS_HINT = FLAG_RESERVED5;
	private static final short FLAG_TRACK_CHANGES = FLAG_RESERVED4;
	private static final Logger log = LoggerFactory.getLogger(Page.class);
	private static final ConcurrentHashMap<String, Boolean> pageClassToBookmarkableCache = new ConcurrentHashMap<String, Boolean>();
	private static final long serialVersionUID = 1L;
	private short autoIndex;
	private int autoIndex2;
	private int numericId;
	private transient IPageMap pageMap;
	private String pageMapName;
	private transient Set<Component> renderedComponents;
	private transient Boolean stateless = null;
	private IPageVersionManager versionManager;
	private PageParameters parameters;
	protected Page(){
		super(null);
		init();
	}
	protected Page(final IModel<?> model){
		super(null, model);
		init();
	}
	protected Page(final IPageMap pageMap){
		super(null);
		init(pageMap);
	}
	protected Page(final IPageMap pageMap, final IModel<?> model){
		super(null, model);
		init(pageMap);
	}
	protected Page(final PageParameters parameters){
		super(null);
		this.parameters = parameters;
		init();
	}
	protected Page(final IPageMap pageMap, final PageParameters parameters){
		super(null);
		this.parameters = parameters;
		init(pageMap);
	}
	public PageParameters getPageParameters(){
		return parameters;
	}
	public void afterCallComponent(final Component component,final RequestListenerInterface listener){
	}
	public void beforeCallComponent(final Component component,final RequestListenerInterface listener){
	}
	public final void componentRendered(final Component component){
		if (Application.get().getDebugSettings().getComponentUseCheck()){
			if (renderedComponents == null){
				renderedComponents = new HashSet<Component>();
			}
			if (renderedComponents.add(component) == false){
				throw new MarkupException(""The component "" + component +"" has the same wicket:id as another component already added at the same level"");
			}
			if (log.isDebugEnabled()){
				log.debug(""Rendered "" + component);
			}
		}
	}
	public void detachModels(){
		super.detachModels();
	}
	public final void dirty(){
		Session.get().dirtyPage(this);
	}
	public final void endComponentRender(Component component){
		if (component instanceof MarkupContainer){
			checkRendering((MarkupContainer)component);
		}
		else{
			renderedComponents = null;
		}
	}
	public final void expireOldestVersion(){
		if (versionManager != null){
			versionManager.expireOldestVersion();
		}
	}
	public final int getAjaxVersionNumber(){
		return versionManager == null ? 0 : versionManager.getAjaxVersionNumber();
	}
	public final short getAutoIndex(){
		return autoIndex++;
	}
	public final int getAutoIndex2(){
		return autoIndex2++;
	}
	public final int getCurrentVersionNumber(){
		return versionManager == null ? 0 : versionManager.getCurrentVersionNumber();
	}
	public final String getId(){
		return Integer.toString(numericId);
	}
	public int getNumericId(){
		return numericId;
	}
	public final Class<? extends Page> getPageClass(){
		return getClass();
	}
	public final IPageMap getPageMap(){
		if (pageMap == null){
			pageMap = PageMap.forName(pageMapName);
		}
		return pageMap;
	}
	public IPageMapEntry getPageMapEntry(){
		return this;
	}
	public final String getPageMapName(){
		return pageMapName;
	}
	public final long getSizeInBytes(){
		pageMap = null;
		return Objects.sizeof(this);
	}
	public final boolean getStatelessHint(){
		return getFlag(FLAG_STATELESS_HINT);
	}
	public Page getVersion(final int versionNumber){
		if (versionManager == null){
			if (versionNumber == 0 || versionNumber == LATEST_VERSION){
				return this;
			}
			else{
				log.info(""No version manager available to retrieve requested versionNumber "" +versionNumber);
				return null;
			}
		}
		else{
			final boolean originalTrackChanges = getFlag(FLAG_TRACK_CHANGES);
			try{
				setFlag(FLAG_TRACK_CHANGES, false);
				final Page page;
				if (versionNumber != LATEST_VERSION){
					page = versionManager.getVersion(versionNumber);
				}
				else{
					page = versionManager.getVersion(getCurrentVersionNumber());
				}
				if (page != null && page.getCurrentVersionNumber() == 0 &&page.getAjaxVersionNumber() == 0){
					page.versionManager = null;
				}
				return page;
			}
			finally{
				setFlag(FLAG_TRACK_CHANGES, originalTrackChanges);
			}
		}
	}
	public final int getVersions(){
		return versionManager == null ? 1 : versionManager.getVersions() + 1;
	}
	public final String hierarchyAsString(){
		final StringBuffer buffer = new StringBuffer();
		buffer.append(""Page "" + getId() + "" (version "" + getCurrentVersionNumber() + "")"");
		visitChildren(new IVisitor<Component>(){
			public Object component(Component component){
				int levels = 0;
				for (Component current = component;
				 current != null;
				 current = current.getParent()){
					levels++;
				}
				buffer.append(StringValue.repeat(levels, """") + component.getPageRelativePath() +"":"" + Classes.simpleName(component.getClass()));
				return null;
			}
		}
		);
		return buffer.toString();
	}
	public final void ignoreVersionMerge(){
		if (getRequest().mergeVersion()){
			mayTrackChangesFor(this, null);
			if (versionManager != null){
				versionManager.ignoreVersionMerge();
			}
		}
	}
	public boolean isBookmarkable(){
		Boolean bookmarkable = pageClassToBookmarkableCache.get(getClass().getName());
		if (bookmarkable == null){
			try{
				if (getClass().getConstructor(new Class[] {
				 }
				) != null){
					bookmarkable = Boolean.TRUE;
				}
			}
			catch (Exception ignore){
				try{
					if (getClass().getConstructor(new Class[] {
					 PageParameters.class }
					) != null){
						bookmarkable = Boolean.TRUE;
					}
				}
				catch (Exception ignore2){
				}
			}
			if (bookmarkable == null){
				bookmarkable = Boolean.FALSE;
			}
			pageClassToBookmarkableCache.put(getClass().getName(), bookmarkable);
		}
		return bookmarkable.booleanValue();
	}
	public boolean isErrorPage(){
		return false;
	}
	private boolean peekPageStateless(){
		Boolean old = stateless;
		Boolean res = isPageStateless();
		stateless = old;
		return res;
	}
	public final boolean isPageStateless(){
		if (isBookmarkable() == false){
			stateless = Boolean.FALSE;
			if (getStatelessHint()){
				log.warn(""Page '"" + this + ""' is not stateless because it is not bookmarkable, "" +""but the stateless hint is set to true!"");
			}
		}
		if (getStatelessHint() == false){
			return false;
		}
		if (stateless == null){
			if (isStateless() == false){
				stateless = Boolean.FALSE;
			}
		}
		if (stateless == null){
			final Object[] returnArray = new Object[1];
			Object returnValue = visitChildren(Component.class, new IVisitor<Component>(){
				public Object component(Component component){
					if (!component.isStateless()){
						returnArray[0] = component;
						return Boolean.FALSE;
					}
					return CONTINUE_TRAVERSAL;
				}
			}
			);
			if (returnValue == null){
				stateless = Boolean.TRUE;
			}
			else if (returnValue instanceof Boolean){
				stateless = (Boolean)returnValue;
			}
		}
		return stateless.booleanValue();
	}
	public final void onRedirect(){
	}
	public final <C extends Form<?>> void removePersistedFormData(final Class<C> formClass,final boolean disablePersistence){
		if (!Form.class.isAssignableFrom(formClass)){
			throw new WicketRuntimeException(""Form class "" + formClass.getName() +"" is not a subclass of Form"");
		}
		visitChildren(formClass, new IVisitor<Component>(){
			public Object component(final Component component){
				if (component instanceof Form){
					((Form<?>)component).removePersistentFormComponentValues(disablePersistence);
				}
				return CONTINUE_TRAVERSAL;
			}
		}
		);
	}
	public final void renderPage(){
		if (!isActionAuthorized(RENDER)){
			if (log.isDebugEnabled()){
				log.debug(""Page not allowed to render: "" + this);
			}
			throw new UnauthorizedActionException(this, Component.RENDER);
		}
		renderedComponents = null;
		if (Boolean.TRUE.equals(stateless)){
			stateless = null;
		}
		setFormComponentValuesFromCookies();
		try{
			prepareForRender();
		}
		catch (RuntimeException e){
			try{
				afterRender();
			}
			catch (RuntimeException e2){
			}
			throw e;
		}
		try{
			render(null);
		}
		finally{
			afterRender();
		}
		checkRendering(this);
		if (Application.get().getDebugSettings().getComponentUseCheck()){
			visitChildren(new IVisitor<Component>(){
				public Object component(Component component){
					component.setMetaData(Component.CONSTRUCTED_AT_KEY, null);
					component.setMetaData(Component.ADDED_AT_KEY, null);
					return CONTINUE_TRAVERSAL;
				}
			}
			);
		}
		if (!isPageStateless()){
			Session.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);
			getSession().touch(this);
		}
		if (getApplication().getDebugSettings().isOutputMarkupContainerClassName()){
			Class<?> klass = getClass();
			while (klass.isAnonymousClass()){
				klass = klass.getSuperclass();
			}
			getResponse().write(""<!-- Page Class "");
			getResponse().write(klass.getName());
			getResponse().write("" -->\n"");
		}
	}
	public final Page rollbackPage(int numberOfVersions){
		Page page = this;
		if (versionManager != null){
			page = versionManager.rollbackPage(numberOfVersions);
		}
		getSession().touch(page);
		return page;
	}
	public final void setNumericId(final int id){
		numericId = id;
	}
	public final void setStatelessHint(boolean value){
		if (value && !isBookmarkable()){
			throw new WicketRuntimeException(""Can't set stateless hint to true on a page when the page is not bookmarkable, page: "" +this);
		}
		setFlag(FLAG_STATELESS_HINT, value);
	}
	public final void startComponentRender(Component component){
		renderedComponents = null;
	}
	public String toString(){
		if (versionManager != null){
			return ""[Page class = "" + getClass().getName() + "", id = "" + getId() + "", version = "" +versionManager.getCurrentVersionNumber() + "", ajax = "" +versionManager.getAjaxVersionNumber() + ""]"";
		}
		else{
			return ""[Page class = "" + getClass().getName() + "", id = "" + getId() + "", version = "" +0 + ""]"";
		}
	}
	private final void checkRendering(final MarkupContainer renderedContainer){
		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.getComponentUseCheck() && !getResponse().isRedirect()){
			final List<Component> unrenderedComponents = new ArrayList<Component>();
			final StringBuffer buffer = new StringBuffer();
			renderedContainer.visitChildren(new IVisitor<Component>(){
				public Object component(final Component component){
					if (renderedComponents == null || !renderedComponents.contains(component)){
						if (!component.isAuto() && component.isVisibleInHierarchy()){
							unrenderedComponents.add(component);
							buffer.append(Integer.toString(unrenderedComponents.size()) + "". "" +component + ""\n"");
							String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);
							if (metadata != null){
								buffer.append(metadata);
							}
							metadata = component.getMetaData(Component.ADDED_AT_KEY);
							if (metadata != null){
								buffer.append(metadata);
							}
						}
						else{
							return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
						}
					}
					return CONTINUE_TRAVERSAL;
				}
			}
			);
			if (unrenderedComponents.size() > 0){
				renderedComponents = null;
				List<Component> transparentContainerChildren = new ArrayList<Component>();
				Iterator<Component> iterator = unrenderedComponents.iterator();
				outerWhile : while (iterator.hasNext()){
					Component component = iterator.next();
					for (Component transparentContainerChild : transparentContainerChildren){
						MarkupContainer parent = component.getParent();
						while (parent != null){
							if (parent == transparentContainerChild){
								iterator.remove();
								continue outerWhile;
							}
							parent = parent.getParent();
						}
					}
					Iterator<? extends Component> iterator2 = component.getParent().iterator();
					while (iterator2.hasNext()){
						Component sibling = iterator2.next();
						if (!sibling.isVisible()){
							boolean isTransparentMarkupContainer = sibling instanceof MarkupContainer &&((MarkupContainer)sibling).isTransparentResolver();
							boolean isComponentResolver = sibling instanceof IComponentResolver;
							if (isTransparentMarkupContainer || isComponentResolver){
								log.debug(""Component {
								}
								 wasn't rendered but most likely it has a transparent parent: {
								}
								"",component, sibling);
								transparentContainerChildren.add(component);
								iterator.remove();
								continue outerWhile;
							}
						}
					}
					Border border = component.findParent(Border.class);
					if (border != null && !border.getBodyContainer().isVisibleInHierarchy()){
						iterator.remove();
					}
				}
				if (unrenderedComponents.size() > 0){
					throw new WicketRuntimeException(""The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\n\n"" +buffer.toString());
				}
			}
		}
		renderedComponents = null;
	}
	private final void endVersion(){
		setFlag(FLAG_TRACK_CHANGES, true);
		if (getFlag(FLAG_NEW_VERSION)){
			setFlag(FLAG_NEW_VERSION, false);
			if (versionManager != null){
				versionManager.endVersion(getRequest().mergeVersion());
			}
			getApplication().getSessionSettings().getPageMapEvictionStrategy().evict(getPageMap());
		}
	}
	private final void init(){
		final RequestCycle cycle = getRequestCycle();
		String pageMapName = null;
		if (cycle != null){
			RequestParameters parameters = getRequest().getRequestParameters();
			pageMapName = parameters.getPageMapName();
		}
		final IPageMap pageMap = PageMap.forName(pageMapName);
		init(pageMap);
	}
	private final void init(final IPageMap pageMap){
		if (isBookmarkable()){
			setStatelessHint(true);
		}
		if (pageMap != null){
			setPageMap(pageMap);
		}
		else{
			throw new IllegalStateException(""PageMap cannot be null"");
		}
		setNextAvailableId();
		setVersioned(Application.get().getPageSettings().getVersionPagesByDefault());
		dirty();
	}
	private void setNextAvailableId(){
		if (getApplication().getSessionSettings().isPageIdUniquePerSession()){
			setNumericId(getSession().nextPageId());
		}
		else{
			setNumericId(getPageMap().nextId());
		}
	}
	private final boolean mayTrackChangesFor(final Component component, MarkupContainer parent){
		componentChanged(component, parent);
		if (component.isAuto() || (parent == null && !component.isVersioned()) ||(parent != null && !parent.isVersioned())){
			return false;
		}
		else{
			if (getFlag(FLAG_TRACK_CHANGES)){
				if (!getFlag(FLAG_NEW_VERSION)){
					if (versionManager == null){
						versionManager = getSession().getSessionStore().newVersionManager(this);
					}
					versionManager.beginVersion(getRequest().mergeVersion());
					setFlag(FLAG_NEW_VERSION, true);
				}
				return true;
			}
			return false;
		}
	}
	protected void componentChanged(Component component, MarkupContainer parent){
	}
	void readPageObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException{
		int id = s.readShort();
		String name = (String)s.readObject();
		IPageSerializer ps = serializer.get();
		if (ps != null){
			ps.deserializePage(id, name, this, s);
		}
		else{
			s.defaultReadObject();
		}
	}
	protected Object writeReplace() throws ObjectStreamException{
		IPageSerializer ps = serializer.get();
		if (ps != null){
			return ps.getPageReplacementObject(this);
		}
		else{
			return this;
		}
	}
	void writePageObject(java.io.ObjectOutputStream s) throws IOException{
		s.writeShort(numericId);
		s.writeObject(pageMapName);
		IPageSerializer ps = serializer.get();
		if (ps != null){
			ps.serializePage(this, s);
		}
		else{
			s.defaultWriteObject();
		}
	}
	protected void configureResponse(){
		final RequestCycle cycle = getRequestCycle();
		final Application application = cycle.getApplication();
		final Response response = cycle.getResponse();
		final String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();
		response.setContentType(""text/"" + getMarkupType() + "";
		 charset="" + encoding);
		final MarkupStream markupStream = findMarkupStream();
		if ((markupStream != null) && (markupStream.getXmlDeclaration() != null) &&(application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false)){
			final String quoteChar = (markupStream.getXmlDeclaration().indexOf('\""') == -1) ? ""'"": ""\"""";
			response.write(""<?xml version="");
			response.write(quoteChar);
			response.write(""1.0"");
			response.write(quoteChar);
			response.write("" encoding="");
			response.write(quoteChar);
			response.write(encoding);
			response.write(quoteChar);
			response.write(""?>"");
		}
		response.setLocale(getSession().getLocale());
	}
	protected final void internalOnModelChanged(){
		visitChildren(new Component.IVisitor<Component>(){
			public Object component(final Component component){
				if (component.sameInnermostModel(Page.this)){
					component.modelChanged();
				}
				return IVisitor.CONTINUE_TRAVERSAL;
			}
		}
		);
	}
	protected final void moveToPageMap(IPageMap map){
		setPageMap(map);
		setNextAvailableId();
	}
	protected final IPageVersionManager newVersionManager(){
		return null;
	}
	public void prepareForRender(boolean setRenderingFlag){
		if (!getFlag(FLAG_INITIALIZED)){
			initialize();
		}
		super.prepareForRender(setRenderingFlag);
	}
	protected void onBeforeRender(){
		super.onBeforeRender();
		if (getSession().isTemporary() && !peekPageStateless()){
			getSession().bind();
		}
	}
	protected void onDetach(){
		if (log.isDebugEnabled()){
			log.debug(""ending request for page "" + this + "", request "" + getRequest());
		}
		endVersion();
		dirty();
		super.onDetach();
	}
	protected void onRender(final MarkupStream markupStream){
		final MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);
		setMarkupStream(associatedMarkupStream);
		configureResponse();
		renderAll(associatedMarkupStream);
	}
	final void componentAdded(final Component component){
		if (!getFlag(Component.FLAG_INITIALIZED)){
			initialize();
		}
		dirty();
		if (mayTrackChangesFor(component, component.getParent())){
			versionManager.componentAdded(component);
		}
	}
	final void componentModelChanging(final Component component){
		dirty();
		if (mayTrackChangesFor(component, null)){
			if (!component.getFlag(FLAG_INHERITABLE_MODEL)){
				versionManager.componentModelChanging(component);
			}
		}
	}
	final void componentRemoved(final Component component){
		dirty();
		if (mayTrackChangesFor(component, component.getParent())){
			versionManager.componentRemoved(component);
		}
	}
	final void componentStateChanging(final Component component, Change change){
		dirty();
		if (mayTrackChangesFor(component, null)){
			versionManager.componentStateChanging(change);
		}
	}
	final void setFormComponentValuesFromCookies(){
		visitChildren(Form.class, new Component.IVisitor<Component>(){
			public Object component(final Component component){
				((Form<?>)component).loadPersistentFormComponentValues();
				return CONTINUE_TRAVERSAL;
			}
		}
		);
	}
	final void setPageMap(final IPageMap pageMap){
		this.pageMap = pageMap;
		pageMapName = pageMap.getName();
	}
	void setPageStateless(Boolean stateless){
		this.stateless = stateless;
	}
	public void onPageAttached(){
	}
	public String getMarkupType(){
		throw new UnsupportedOperationException(""Page does not support markup. This error can happen if you have extended Page directly, instead extend WebPage"");
	}
	public PageId getPageId(){
		setStatelessHint(false);
		return new PageId(pageMapName, numericId, getCurrentVersionNumber());
	}
	public PageReference getPageReference(){
		setStatelessHint(false);
		return new PageReference(pageMapName, numericId, getCurrentVersionNumber());
	}
}",1,0,0,0
"public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 CrawlDatum fetch = null;
	 CrawlDatum old = null;
	 byte[] signature = null;
	 linked.clear();
	 while (values.hasNext()) {
		 CrawlDatum datum = (CrawlDatum)values.next();
		 if (CrawlDatum.hasDbStatus(datum)) {
			 if (old == null) {
				 old = datum;
			 }
			 else {
				 if (old.getFetchTime() < datum.getFetchTime()) old = datum;
			 }
			 continue;
		 }
		 if (CrawlDatum.hasFetchStatus(datum)) {
			 if (fetch == null) {
				 fetch = datum;
			 }
			 else {
				 if (fetch.getFetchTime() < datum.getFetchTime()) fetch = datum;
			 }
			 continue;
		 }
		 switch (datum.getStatus()) {
			 case CrawlDatum.STATUS_LINKED: linked.add(datum);
			 break;
			 case CrawlDatum.STATUS_SIGNATURE: signature = datum.getSignature();
			 break;
			 default: LOG.warn(""Unknown status, key: "" + key + "", datum: "" + datum);
		 }
	 }
	 if (old == null && !additionsAllowed) return;
	 if (fetch == null && linked.size() > 0) {
		 fetch = (CrawlDatum)linked.get(0);
	 }
	 if (fetch == null) {
		 if (old != null) output.collect(key, old);
		 else LOG.warn(""Missing fetch and old value, signature="" + signature);
		 return;
	 }
	 result.set(fetch);
	 if (old != null) {
		 if (old.getMetaData().size() > 0) {
			 result.getMetaData().putAll(old.getMetaData());
			 if (fetch.getMetaData().size() > 0) result.getMetaData().putAll(fetch.getMetaData());
		 }
		 if (old.getModifiedTime() > 0 && fetch.getModifiedTime() == 0) {
			 result.setModifiedTime(old.getModifiedTime());
		 }
	 }
	 switch (fetch.getStatus()) {
		 case CrawlDatum.STATUS_LINKED: if (old != null) {
			 result.set(old);
		 }
		 else {
			 result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);
			 try {
				 scfilters.initialScore((Text)key, result);
			 }
			 catch (ScoringFilterException e) {
				 if (LOG.isWarnEnabled()) {
					 LOG.warn(""Cannot filter init score for url "" + key + "", using default: "" + e.getMessage());
				 }
				 result.setScore(0.0f);
			 }
		 }
		 break;
		 case CrawlDatum.STATUS_FETCH_SUCCESS: if (fetch.getSignature() == null) result.setSignature(signature);
		 result.setStatus(CrawlDatum.STATUS_DB_FETCHED);
		 result.setNextFetchTime();
		 break;
		 case CrawlDatum.STATUS_FETCH_REDIR_TEMP: if (fetch.getSignature() == null) result.setSignature(signature);
		 result.setStatus(CrawlDatum.STATUS_DB_REDIR_TEMP);
		 result.setNextFetchTime();
		 break;
		 case CrawlDatum.STATUS_FETCH_REDIR_PERM: if (fetch.getSignature() == null) result.setSignature(signature);
		 result.setStatus(CrawlDatum.STATUS_DB_REDIR_PERM);
		 result.setNextFetchTime();
		 break;
		 case CrawlDatum.STATUS_SIGNATURE: if (LOG.isWarnEnabled()) {
			 LOG.warn(""Lone CrawlDatum.STATUS_SIGNATURE: "" + key);
		 }
		 return;
		 case CrawlDatum.STATUS_FETCH_RETRY: if (old != null) result.setSignature(old.getSignature());
		 if (fetch.getRetriesSinceFetch() < retryMax) {
			 result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);
		 }
		 else {
			 result.setStatus(CrawlDatum.STATUS_DB_GONE);
		 }
		 break;
		 case CrawlDatum.STATUS_FETCH_GONE: if (old != null) result.setSignature(old.getSignature());
		 result.setStatus(CrawlDatum.STATUS_DB_GONE);
		 break;
		 default: throw new RuntimeException(""Unknown status: "" + fetch.getStatus() + "" "" + key);
	 }
	 try {
		 scfilters.updateDbScore((Text)key, old, result, linked);
	 }
	 catch (Exception e) {
		 if (LOG.isWarnEnabled()) {
			 LOG.warn(""Couldn't update score, key="" + key + "": "" + e);
		 }
	 }
	 result.getMetaData().remove(Nutch.WRITABLE_GENERATE_TIME_KEY);
	 output.collect(key, result);
 }",0,0,1,0
"protected boolean traceLightRay(Ray r, Light lt, int treeDepth, OctreeNode node, OctreeNode endNode, double distToLight, double totalDist, MaterialMapping currentMaterial, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans) {
	 RGBColor lightColor = r.rt.color[treeDepth], transColor = r.rt.surfSpec[treeDepth].transparent;
	 Vec3 intersectionPoint = r.rt.pos[maxRayDepth], trueNorm = r.rt.trueNormal[maxRayDepth];
	 MaterialIntersection matChange[] = r.rt.matChange;
	 int i, j, matCount = 0;
	 do {
		 RTObject obj[] = node.getObjects();
		 for (i = obj.length-1;
		 i >= 0;
		 i--) {
			 SurfaceIntersection intersection = r.findIntersection(obj[i]);
			 if (intersection != SurfaceIntersection.NO_INTERSECTION) for (j = 0;
			 ;
			 j++) {
				 intersection.intersectionPoint(j, intersectionPoint);
				 if (node.contains(intersectionPoint)) {
					 double dist = intersection.intersectionDist(j);
					 if (dist < distToLight) {
						 intersection.trueNormal(trueNorm);
						 double angle = -trueNorm.dot(r.getDirection());
						 intersection.intersectionTransparency(j, transColor, angle, (totalDist+dist)*smoothScale, time);
						 lightColor.multiply(transColor);
						 if (lightColor.getRed() < minRayIntensity && lightColor.getGreen() < minRayIntensity && lightColor.getBlue() < minRayIntensity) return false;
						 MaterialMapping mat = obj[i].getMaterialMapping();
						 if (mat != null && mat.castsShadows()) {
							 if (matCount == matChange.length) {
								 r.rt.increaseMaterialChangeLength();
								 matChange = r.rt.matChange;
							 }
							 matChange[matCount].mat = mat;
							 matChange[matCount].toLocal = obj[i].toLocal();
							 matChange[matCount].dist = dist;
							 matChange[matCount].node = node;
							 matChange[matCount].entered = (angle > 0.0)^(j%2==1);
							 matCount++;
						 }
					 }
				 }
				 if (j >= intersection.numIntersections()-1) break;
			 }
		 }
		 if (node == endNode) break;
		 node = node.findNextNode(r);
	 }
	 while (node != null);
	 if (currentMaterial == null && matCount == 0) return true;
	 sortMaterialList(matChange, matCount);
	 if (matCount == matChange.length) {
		 r.rt.increaseMaterialChangeLength();
		 matChange = r.rt.matChange;
	 }
	 matChange[matCount++].dist = distToLight;
	 double dist = 0.0;
	 for (i = 0;
	 ;
	 i++) {
		 if (currentMaterial != null && currentMaterial.castsShadows()) {
			 propagateLightRay(r, node, dist, matChange[i].dist, currentMaterial, lightColor, currentMatTrans, totalDist);
			 if (lightColor.getRed() < minRayIntensity && lightColor.getGreen() < minRayIntensity && lightColor.getBlue() < minRayIntensity) return false;
		 }
		 if (i == matCount-1) break;
		 double n1 = (currentMaterial == null ? 1.0 : currentMaterial.indexOfRefraction());
		 if (matChange[i].entered) {
			 if (matChange[i].mat != currentMaterial) {
				 prevMaterial = currentMaterial;
				 prevMatTrans = currentMatTrans;
				 currentMaterial = matChange[i].mat;
				 currentMatTrans = matChange[i].toLocal;
			 }
		 }
		 else if (matChange[i].mat == currentMaterial) {
			 currentMaterial = prevMaterial;
			 currentMatTrans = prevMatTrans;
			 prevMaterial = null;
		 }
		 else if (matChange[i].mat == prevMaterial) prevMaterial = null;
		 if (caustics) {
			 double n2 = (currentMaterial == null ? 1.0 : currentMaterial.indexOfRefraction());
			 if (n1 != n2) return false;
		 }
		 node = matChange[i].node;
		 dist = matChange[i].dist;
	 }
	 return true;
 }",0,0,1,0
"public class AbstractTargetScheduleView {
	public static final String QRY_GET_ALL_BY_USER_BY_AGENCY_BY_TYPE = ""org.webcurator.domain.model.report.AbstractTargetScheduleView.getAllByUserByAgencyByType"";
	public static final String QRY_GET_SUMMARY_STATS_BY_AGENCY = ""org.webcurator.domain.model.report.AbstractTargetScheduleView.getSummaryStatsByAgency"";
	private String theKey;
	 private String objectTypeDesc;
	 private String name;
	 private int state;
	 private String ownerName;
	 private String agencyName;
	private Long scheduleOid;
	private Date scheduleStartDate;
	private Date scheduleEndDate;
	 private int scheduleType;
	 private String scheduleCronPattern;
	protected AbstractTargetScheduleView() {
	 }
	public String getTheKey() {
		 return theKey;
	 }
	public void setTheKey(String aKey) {
		theKey = aKey;
	 }
	public String getObjectTypeDesc() {
		return objectTypeDesc;
	}
	private void setObjectTypeDesc(String aObjectTypeDesc) {
		objectTypeDesc = aObjectTypeDesc;
	}
	 public String getName() {
		 return name;
	 }
	 public void setName(String aName) {
		 name = aName;
	 }
	 public int getState() {
		return state;
	}
	private void setState(int aState) {
		state = aState;
	}
	 public String getOwnerName() {
		 return ownerName;
	 }
	 public void setOwnerName(String aOwnerName) {
		 ownerName = aOwnerName;
	 }
	 public String getAgencyName() {
		 return agencyName;
	 }
	 public void setAgencyName(String aName) {
		 agencyName = aName;
	 }
	 public Long getScheduleOid() {
		return scheduleOid;
	}
	private void setScheduleOid(Long aScheduleOid) {
		scheduleOid = aScheduleOid;
	}
	 public Date getScheduleStartDate() {
		 return scheduleStartDate;
	 }
	 public void setScheduleStartDate(Date aStartDate) {
		 this.scheduleStartDate = aStartDate;
	 }
	public Date getScheduleEndDate() {
		return scheduleEndDate;
	}
	public void setScheduleEndDate(Date endDate) {
		this.scheduleEndDate = endDate;
	}
	public int getScheduleType() {
		return scheduleType;
	}
	private void setScheduleType(int aScheduleType) {
		scheduleType = aScheduleType;
	}
	public String getScheduleCronPattern() {
		return scheduleCronPattern;
	}
	private void setScheduleCronPattern(String aScheduleCronPattern) {
		scheduleCronPattern = aScheduleCronPattern;
	}
}",0,1,0,0
"public String getError() {
	 return errmsg;
 }",0,0,0,0
"private void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {
	for (SourceClass ifc : sourceClass.getInterfaces()) {
		Set<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc);
		for (MethodMetadata methodMetadata : beanMethods) {
			if (!methodMetadata.isAbstract()) {
				configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));
			}
		}
		processInterfaces(configClass, ifc);
	}
}",0,0,0,0
"static List<Period> generateSchedule(Calendar startDate,String maturityString, Frequency frequency, StubType stubType, Period prototype);",0,0,0,1
"public class TCustomNonblockingServerSocket extends TNonblockingServerSocket{
	 private static final Logger logger = LoggerFactory.getLogger(TCustomNonblockingServerSocket.class);
	 private final boolean keepAlive;
	 private final Integer sendBufferSize;
	 private final Integer recvBufferSize;
	 public TCustomNonblockingServerSocket(InetSocketAddress bindAddr, boolean keepAlive, Integer sendBufferSize, Integer recvBufferSize) throws TTransportException {
		 super(bindAddr);
		 this.keepAlive = keepAlive;
		 this.sendBufferSize = sendBufferSize;
		 this.recvBufferSize = recvBufferSize;
	 }
	 protected TNonblockingSocket acceptImpl() throws TTransportException {
		 TNonblockingSocket tsocket = super.acceptImpl();
		 if (tsocket == null || tsocket.getSocketChannel() == null) return tsocket;
		 Socket socket = tsocket.getSocketChannel().socket();
		 SocketSessionManagementService.instance.remove(socket.getRemoteSocketAddress());
		 try {
			 socket.setKeepAlive(this.keepAlive);
		 }
		 catch (SocketException se) {
			 logger.warn(""Failed to set keep-alive on Thrift socket."", se);
		 }
		 if (this.sendBufferSize != null) {
			 try {
				 socket.setSendBufferSize(this.sendBufferSize.intValue());
			 }
			 catch (SocketException se) {
				 logger.warn(""Failed to set send buffer size on Thrift socket."", se);
			 }
		 }
		 if (this.recvBufferSize != null) {
			 try {
				 socket.setReceiveBufferSize(this.recvBufferSize.intValue());
			 }
			 catch (SocketException se) {
				 logger.warn(""Failed to set receive buffer size on Thrift socket."", se);
			 }
		 }
		 return tsocket;
	 }
}",0,0,0,0
"public class FXGMatrix{
	public double a;
	 public double b;
	 public double c;
	 public double d;
	 public double tx;
	 public double ty;
	 public FXGMatrix(double a, double b, double c, double d, double tx, double ty) {
		 this.a = a;
		 this.b = b;
		 this.c = c;
		 this.d = d;
		 this.tx = tx;
		 this.ty = ty;
	 }
	 public FXGMatrix() {
		 this.identity();
	 }
	 public FXGMatrix(MatrixNode m) {
		 this.a = m.a;
		 this.b = m.b;
		 this.c = m.c;
		 this.d = m.d;
		 this.tx = m.tx;
		 this.ty = m.ty;
	 }
	 public void identity() {
		 this.a = 1;
		 this.b = 0;
		 this.c = 0;
		 this.d = 1;
		 this.tx = 0;
		 this.ty = 0;
	 }
	 public void concat(FXGMatrix m) {
		 double new_a = a * m.a + b * m.c;
		 double new_b = a * m.b + b * m.d;
		 double new_c = c * m.a + d * m.c;
		 double new_d = c * m.b + d * m.d;
		 double new_tx = tx * m.a + ty * m.c + m.tx;
		 double new_ty = tx * m.b + ty * m.d + m.ty;
		 a = new_a;
		 b = new_b;
		 c = new_c;
		 d = new_d;
		 tx = new_tx;
		 ty = new_ty;
	 }
	 public void rotate(double angle) {
		 double cos = Math.cos(angle*Math.PI/180.0);
		 double sin = Math.sin(angle*Math.PI/180.0);
		 FXGMatrix newM = new FXGMatrix(cos, sin, -sin, cos, 0, 0);
		 this.concat (newM);
	 }
	 public void scale(double scaleX, double scaleY) {
		 FXGMatrix newM = new FXGMatrix(scaleX, 0, 0, scaleY, 0, 0);
		 this.concat (newM);
	 }
	 public void translate(double dx, double dy) {
		 tx += dx;
		 ty += dy;
	 }
	 public static FXGMatrix convertToMatrix(double scaleX, double scaleY, double rotation, double tx, double ty) {
		 FXGMatrix m = new FXGMatrix();
		 m.scale (scaleX, scaleY);
		 m.rotate (rotation);
		 m.translate(tx, ty);
		 return m;
	 }
	 public Matrix toSWFMatrix() {
		 Matrix sm = new Matrix();
		 if (b != 0 || c != 0) sm.setRotate(b, c);
		 if (a != 0 || d != 0) sm.setScale(a, d);
		 sm.setTranslate((int)(tx*ISWFConstants.TWIPS_PER_PIXEL), (int)(ty*ISWFConstants.TWIPS_PER_PIXEL));
		 return sm;
	 }
	 public void setMatrixNodeValue(MatrixNode node) {
		 node.a = this.a;
		 node.b = this.b;
		 node.c = this.c;
		 node.d = this.d;
		 node.tx = this.tx;
		 node.ty = this.ty;
	 }
}",0,0,0,0
"class MultiQueryOptimizer extends MROpPlanVisitor {
	 private Log log = LogFactory.getLog(getClass());
	 private NodeIdGenerator nig;
	 private String scope;
	 private boolean inIllustrator = false;
	 MultiQueryOptimizer(MROperPlan plan, boolean inIllustrator) {
		 super(plan, new ReverseDependencyOrderWalker<MapReduceOper, MROperPlan>(plan));
		 nig = NodeIdGenerator.getGenerator();
		 List<MapReduceOper> roots = plan.getRoots();
		 scope = roots.get(0).getOperatorKey().getScope();
		 this.inIllustrator = inIllustrator;
		 log.info(""MR plan size before optimization: "" + plan.size());
	 }
	 public void visit() throws VisitorException {
		 super.visit();
		 log.info(""MR plan size after optimization: "" + mPlan.size());
	 }
	 public void visitMROp(MapReduceOper mr) throws VisitorException {
		 if (!mr.isSplitter()) {
			 return;
		 }
		 List<MapReduceOper> mappers = new ArrayList<MapReduceOper>();
		 List<MapReduceOper> multiLoadMROpers = new ArrayList<MapReduceOper>();
		 List<MapReduceOper> mapReducers = new ArrayList<MapReduceOper>();
		 List<MapReduceOper> successors = getPlan().getSuccessors(mr);
		 for (MapReduceOper successor : successors) {
			 if (successor.getUseSecondaryKey()) {
				 log.debug(""Splittee "" + successor.getOperatorKey().getId() + "" uses secondary key, do not merge it"");
				 continue;
			 }
			 if (successor.getCustomPartitioner() != null) {
				 log.debug(""Splittee "" + successor.getOperatorKey().getId() + "" uses customPartitioner, do not merge it"");
				 continue;
			 }
			 if (successor.isCounterOperation()) {
				 log.debug(""Splittee "" + successor.getOperatorKey().getId() + "" has POCounter, do not merge it"");
				 continue;
			 }
			 if (isMapOnly(successor)) {
				 if (isSingleLoadMapperPlan(successor.mapPlan) && isSinglePredecessor(successor)) {
					 mappers.add(successor);
				 }
				 else {
					 multiLoadMROpers.add(successor);
				 }
			 }
			 else {
				 if (isSingleLoadMapperPlan(successor.mapPlan) && isSinglePredecessor(successor)) {
					 mapReducers.add(successor);
				 }
				 else {
					 multiLoadMROpers.add(successor);
				 }
			 }
		 }
		 int numSplittees = successors.size();
		 if (mappers.size() == 1 && numSplittees == 1) {
			 mergeOnlyMapperSplittee(mappers.get(0), mr);
			 log.info(""Merged the only map-only splittee."");
			 return;
		 }
		 if (isMapOnly(mr) && mapReducers.size() == 1 && numSplittees == 1) {
			 mergeOnlyMapReduceSplittee(mapReducers.get(0), mr);
			 log.info(""Merged the only map-reduce splittee."");
			 return;
		 }
		 int numMerges = 0;
		 PhysicalPlan splitterPl = isMapOnly(mr) ? mr.mapPlan : mr.reducePlan;
		 POStore storeOp = (POStore)splitterPl.getLeaves().get(0);
		 POSplit splitOp = null;
		 if (mappers.size() > 0) {
			 splitOp = getSplit();
			 int n = mergeAllMapOnlySplittees(mappers, mr, splitOp);
			 log.info(""Merged "" + n + "" map-only splittees."");
			 numMerges += n;
		 }
		 if (mapReducers.size() > 0) {
			 boolean isMapOnly = isMapOnly(mr);
			 int merged = 0;
			 if (isMapOnly) {
				 PhysicalOperator leaf = splitterPl.getLeaves().get(0);
				 splitOp = (leaf instanceof POStore) ? getSplit() : (POSplit)leaf;
				 merged = mergeMapReduceSplittees(mapReducers, mr, splitOp);
			 }
			 else {
				 merged = mergeMapReduceSplittees(mapReducers, mr);
			 }
			 log.info(""Merged "" + merged + "" map-reduce splittees."");
			 numMerges += merged;
		 }
		 if (splitOp != null && (numMerges < numSplittees)) {
			 PhysicalPlan storePlan = new PhysicalPlan();
			 try {
				 storePlan.addAsLeaf(storeOp);
				 splitOp.addPlan(storePlan);
			 }
			 catch (PlanException e) {
				 int errCode = 2129;
				 String msg = ""Internal Error. Unable to add store to the split plan for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
		 }
		 if (numMerges == 0 && isDiamondMROper(mr)) {
			 int merged = mergeDiamondMROper(mr, getPlan().getSuccessors(mr));
			 log.info(""Merged "" + merged + "" diamond splitter."");
			 numMerges += merged;
		 }
		 log.info(""Merged "" + numMerges + "" out of total "" + (numSplittees +1) + "" MR operators."");
	 }
	 private boolean isDiamondMROper(MapReduceOper mr) {
		 boolean rtn = false;
		 if (isMapOnly(mr)) {
			 PhysicalPlan pl = mr.mapPlan;
			 if (pl.size() == 2 || pl.size() == 3) {
				 PhysicalOperator root = pl.getRoots().get(0);
				 PhysicalOperator leaf = pl.getLeaves().get(0);
				 if (root instanceof POLoad && leaf instanceof POStore) {
					 if (pl.size() == 3) {
						 PhysicalOperator mid = pl.getSuccessors(root).get(0);
						 if (mid instanceof POForEach) {
							 rtn = true;
						 }
					 }
					 else {
						 rtn = true;
					 }
				 }
			 }
		 }
		 return rtn;
	 }
	 private int mergeDiamondMROper(MapReduceOper mr, List<MapReduceOper> succs) throws VisitorException {
		 for (MapReduceOper succ : succs) {
			 List<MapReduceOper> preds = getPlan().getPredecessors(succ);
			 if (preds.size() != 1) {
				 return 0;
			 }
		 }
		 PhysicalPlan pl = mr.mapPlan;
		 PhysicalOperator leaf = mr.mapPlan.getLeaves().get(0);
		 pl.remove(leaf);
		 POStore store = (POStore)leaf;
		 String ofile = store.getSFile().getFileName();
		 for (MapReduceOper succ : succs) {
			 List<PhysicalOperator> roots = succ.mapPlan.getRoots();
			 ArrayList<PhysicalOperator> rootsCopy = new ArrayList<PhysicalOperator>(roots);
			 for (PhysicalOperator op : rootsCopy) {
				 POLoad load = (POLoad)op;
				 String ifile = load.getLFile().getFileName();
				 if (ofile.compareTo(ifile) != 0) {
					 continue;
				 }
				 PhysicalOperator opSucc = succ.mapPlan.getSuccessors(op).get(0);
				 PhysicalPlan clone = null;
				 try {
					 if (inIllustrator) pl.setOpMap(succ.phyToMRMap);
					 clone = pl.clone();
					 if (inIllustrator) pl.resetOpMap();
				 }
				 catch (CloneNotSupportedException e) {
					 int errCode = 2127;
					 String msg = ""Internal Error: Cloning of plan failed for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG, e);
				 }
				 succ.mapPlan.remove(op);
				 if (inIllustrator) {
					 for (Iterator<PhysicalOperator> it = pl.iterator();
					 it.hasNext();
					 ) {
						 PhysicalOperator po = it.next();
						 if (po instanceof POLoad) succ.phyToMRMap.removeKey(po);
					 }
				 }
				 while (!clone.isEmpty()) {
					 PhysicalOperator oper = clone.getLeaves().get(0);
					 clone.remove(oper);
					 succ.mapPlan.add(oper);
					 try {
						 succ.mapPlan.connect(oper, opSucc);
						 opSucc = oper;
					 }
					 catch (PlanException e) {
						 int errCode = 2131;
						 String msg = ""Internal Error. Unable to connect split plan for optimization."";
						 throw new OptimizerException(msg, errCode, PigException.BUG, e);
					 }
				 }
			 }
			 if (!mr.UDFs.isEmpty()) {
				 succ.UDFs.addAll(mr.UDFs);
			 }
		 }
		 List<MapReduceOper> mrPreds = getPlan().getPredecessors(mr);
		 if (mrPreds != null) {
			 for (MapReduceOper pred : mrPreds) {
				 for (MapReduceOper succ : succs) {
					 try {
						 getPlan().connect(pred, succ);
					 }
					 catch (PlanException e) {
						 int errCode = 2131;
						 String msg = ""Internal Error. Unable to connect split plan for optimization."";
						 throw new OptimizerException(msg, errCode, PigException.BUG, e);
					 }
				 }
			 }
		 }
		 getPlan().remove(mr);
		 return 1;
	 }
	 private void mergeOneMapPart(MapReduceOper mapper, MapReduceOper splitter) throws VisitorException {
		 PhysicalPlan splitterPl = isMapOnly(splitter) ? splitter.mapPlan : splitter.reducePlan;
		 POStore storeOp = (POStore)splitterPl.getLeaves().get(0);
		 List<PhysicalOperator> storePreds = splitterPl.getPredecessors(storeOp);
		 PhysicalPlan pl = mapper.mapPlan;
		 PhysicalOperator load = pl.getRoots().get(0);
		 pl.remove(load);
		 List<PhysicalOperator> predsCopy = new ArrayList<PhysicalOperator>(storePreds);
		 splitterPl.remove(storeOp);
		 try {
			 splitterPl.merge(pl);
		 }
		 catch (PlanException e) {
			 int errCode = 2130;
			 String msg = ""Internal Error. Unable to merge split plans for optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG, e);
		 }
		 List<PhysicalOperator> roots = pl.getRoots();
		 for (PhysicalOperator pred : predsCopy) {
			 for (PhysicalOperator root : roots) {
				 try {
					 splitterPl.connect(pred, root);
				 }
				 catch (PlanException e) {
					 int errCode = 2131;
					 String msg = ""Internal Error. Unable to connect split plan for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG, e);
				 }
			 }
		 }
	 }
	 private void mergeOnlyMapperSplittee(MapReduceOper mapper, MapReduceOper splitter) throws VisitorException {
		 mergeOneMapPart(mapper, splitter);
		 removeAndReconnect(mapper, splitter);
	 }
	 private void mergeOnlyMapReduceSplittee(MapReduceOper mapReducer, MapReduceOper splitter) throws VisitorException {
		 mergeOneMapPart(mapReducer, splitter);
		 splitter.setMapDone(true);
		 splitter.reducePlan = mapReducer.reducePlan;
		 splitter.setReduceDone(true);
		 removeAndReconnect(mapReducer, splitter);
	 }
	 private int mergeAllMapOnlySplittees(List<MapReduceOper> mappers, MapReduceOper splitter, POSplit splitOp) throws VisitorException {
		 PhysicalPlan splitterPl = isMapOnly(splitter) ? splitter.mapPlan : splitter.reducePlan;
		 PhysicalOperator storeOp = splitterPl.getLeaves().get(0);
		 List<PhysicalOperator> storePreds = splitterPl.getPredecessors(storeOp);
		 for (MapReduceOper mapper : mappers) {
			 PhysicalPlan pl = mapper.mapPlan;
			 PhysicalOperator load = pl.getRoots().get(0);
			 pl.remove(load);
			 splitOp.addPlan(pl);
		 }
		 splitOp.setInputs(storePreds);
		 try {
			 splitterPl.replace(storeOp, splitOp);
			;
		 }
		 catch (PlanException e) {
			 int errCode = 2132;
			 String msg = ""Internal Error. Unable to replace store with split operator for optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG, e);
		 }
		 for (MapReduceOper mapper : mappers) {
			 removeAndReconnect(mapper, splitter);
		 }
		 return mappers.size();
	 }
	 private boolean isSplitteeMergeable(MapReduceOper splittee) {
		 if (splittee.isGlobalSort() || splittee.isLimitAfterSort()) {
			 log.info(""Cannot merge this splittee: "" + ""it is global sort or limit after sort"");
			 return false;
		 }
		 PhysicalOperator leaf = splittee.mapPlan.getLeaves().get(0);
		 if (!(leaf instanceof POLocalRearrange) && ! (leaf instanceof POSplit)) {
			 log.info(""Cannot merge this splittee: "" + ""its map plan doesn't end with LR or Split operator: "" + leaf.getClass().getName());
			 return false;
		 }
		 if (splittee.needsDistinctCombiner()) {
			 log.info(""Cannot merge this splittee: "" + ""it has distinct combiner."");
			 return false;
		 }
		 return true;
	 }
	 private List<MapReduceOper> getMergeList(MapReduceOper splitter, List<MapReduceOper> mapReducers) {
		 List<MapReduceOper> mergeNoCmbList = new ArrayList<MapReduceOper>();
		 List<MapReduceOper> mergeCmbList = new ArrayList<MapReduceOper>();
		 List<MapReduceOper> mergeDistList = new ArrayList<MapReduceOper>();
		 for (MapReduceOper mrOp : mapReducers) {
			 if (isSplitteeMergeable(mrOp)) {
				 if (mrOp.combinePlan.isEmpty()) {
					 mergeNoCmbList.add(mrOp);
				 }
				 else {
					 mergeCmbList.add(mrOp);
				 }
			 }
			 else if (splitter.reducePlan.isEmpty() || splitter.needsDistinctCombiner()) {
				 if (mrOp.needsDistinctCombiner()) {
					 mergeDistList.add(mrOp);
				 }
			 }
		 }
		 int max = Math.max(mergeNoCmbList.size(), mergeCmbList.size());
		 max = Math.max(max, mergeDistList.size());
		 if (max == mergeDistList.size()) return mergeDistList;
		 else if (max == mergeNoCmbList.size()) return mergeNoCmbList;
		 else return mergeCmbList;
	 }
	 private int mergeMapReduceSplittees(List<MapReduceOper> mapReducers, MapReduceOper splitter, POSplit splitOp) throws VisitorException {
		 List<MapReduceOper> mergeList = getMergeList(splitter, mapReducers);
		 if (mergeList.size() <= 1) {
			 MapReduceOper mapReducer = mapReducers.get(0);
			 for (MapReduceOper mro : mapReducers) {
				 if (!mro.combinePlan.isEmpty()) {
					 mapReducer = mro;
					 break;
				 }
			 }
			 mergeList.clear();
			 mergeList.add(mapReducer);
		 }
		 if (mergeList.size() == 1) {
			 mergeSingleMapReduceSplittee(mergeList.get(0), splitter, splitOp);
		 }
		 else {
			 mergeAllMapReduceSplittees(mergeList, splitter, splitOp);
		 }
		 return mergeList.size();
	 }
	 private int mergeMapReduceSplittees(List<MapReduceOper> mapReducers, MapReduceOper splitter) throws VisitorException {
		 List<MapReduceOper> mergeList = getMergeList(splitter, mapReducers);
		 if (mergeList.size() <= 1) {
			 return 0;
		 }
		 MapReduceOper mrOper = getMROper();
		 MapReduceOper splittee = mergeList.get(0);
		 PhysicalPlan pl = splittee.mapPlan;
		 POLoad load = (POLoad)pl.getRoots().get(0);
		 mrOper.mapPlan.add(load);
		 try {
			 mrOper.mapPlan.addAsLeaf(getStore());
		 }
		 catch (PlanException e) {
			 int errCode = 2137;
			 String msg = ""Internal Error. Unable to add store to the plan as leaf for optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG, e);
		 }
		 try {
			 getPlan().add(mrOper);
			 getPlan().connect(splitter, mrOper);
		 }
		 catch (PlanException e) {
			 int errCode = 2133;
			 String msg = ""Internal Error. Unable to connect splitter with successors for optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG, e);
		 }
		 mergeAllMapReduceSplittees(mergeList, mrOper, getSplit());
		 return (mergeList.size() - 1);
	 }
	 private boolean hasSameMapKeyType(List<MapReduceOper> splittees) {
		 Set<Byte> keyTypes = new HashSet<Byte>();
		 for (MapReduceOper splittee : splittees) {
			 keyTypes.add(splittee.mapKeyType);
			 if (splittee.mapKeyTypeOfSplittees != null) {
				 for (int i = 0;
				 i < splittee.mapKeyTypeOfSplittees.length;
				 i++) {
					 keyTypes.add(splittee.mapKeyTypeOfSplittees[i]);
				 }
			 }
		 }
		 return keyTypes.size() == 1;
	 }
	 private int setIndexOnLRInSplit(int initial, POSplit splitOp, boolean sameKeyType) throws VisitorException {
		 int index = initial;
		 List<PhysicalPlan> pls = splitOp.getPlans();
		 for (PhysicalPlan pl : pls) {
			 PhysicalOperator leaf = pl.getLeaves().get(0);
			 if (leaf instanceof POLocalRearrange) {
				 POLocalRearrange lr = (POLocalRearrange)leaf;
				 try {
					 lr.setMultiQueryIndex(index++);
				 }
				 catch (ExecException e) {
					 int errCode = 2136;
					 String msg = ""Internal Error. Unable to set multi-query index for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG, e);
				 }
				 if (!sameKeyType) {
					 lr.setKeyType(DataType.TUPLE);
				 }
			 }
			 else if (leaf instanceof POSplit) {
				 POSplit spl = (POSplit)leaf;
				 index = setIndexOnLRInSplit(index, spl, sameKeyType);
			 }
		 }
		 return index;
	 }
	 private int mergeOneMapPlanWithIndex(PhysicalPlan pl, POSplit splitOp, int index, boolean sameKeyType) throws VisitorException {
		 PhysicalOperator load = pl.getRoots().get(0);
		 pl.remove(load);
		 int curIndex = index;
		 PhysicalOperator leaf = pl.getLeaves().get(0);
		 if (leaf instanceof POLocalRearrange) {
			 POLocalRearrange lr = (POLocalRearrange)leaf;
			 try {
				 lr.setMultiQueryIndex(curIndex++);
			 }
			 catch (ExecException e) {
				 int errCode = 2136;
				 String msg = ""Internal Error. Unable to set multi-query index for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
			 if (!sameKeyType) {
				 lr.setKeyType(DataType.TUPLE);
			 }
		 }
		 else if (leaf instanceof POSplit) {
			 POSplit spl = (POSplit)leaf;
			 curIndex = setIndexOnLRInSplit(index, spl, sameKeyType);
		 }
		 splitOp.addPlan(pl);
		 return curIndex;
	 }
	 private void mergeOneReducePlanWithIndex(PhysicalPlan from, PhysicalPlan to, int initial, int current, byte mapKeyType) throws VisitorException {
		 POPackage pk = (POPackage)from.getRoots().get(0);
		 from.remove(pk);
		 Packager fromPkgr = pk.getPkgr();
		 if (!(fromPkgr instanceof MultiQueryPackager)) {
			 addShiftedKeyInfoIndex(initial, fromPkgr);
		 }
		 int total = current - initial;
		 MultiQueryPackager toPkgr = (MultiQueryPackager) ((POPackage) to .getRoots().get(0)).getPkgr();
		 int pkCount = 0;
		 if (fromPkgr instanceof MultiQueryPackager) {
			 List<Packager> pkgs = ((MultiQueryPackager) fromPkgr) .getPackagers();
			 for (Packager p : pkgs) {
				 ((MultiQueryPackager) toPkgr).addPackager(p);
				 pkCount++;
			 }
			 toPkgr.addIsKeyWrappedList(((MultiQueryPackager) fromPkgr) .getIsKeyWrappedList());
			 addShiftedKeyInfoIndex(initial, current, (MultiQueryPackager) fromPkgr);
		 }
		 else {
			 toPkgr.addPackager(fromPkgr, mapKeyType);
			 pkCount = 1;
		 }
		 if (pkCount != total) {
			 int errCode = 2146;
			 String msg = ""Internal Error. Inconsistency in key index found during optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG);
		 }
		 PODemux demux = (PODemux)to.getLeaves().get(0);
		 int plCount = 0;
		 PhysicalOperator root = from.getRoots().get(0);
		 if (root instanceof PODemux) {
			 List<PhysicalPlan> pls = ((PODemux)root).getPlans();
			 for (PhysicalPlan pl : pls) {
				 demux.addPlan(pl);
				 plCount++;
			 }
		 }
		 else {
			 demux.addPlan(from);
			 plCount = 1;
		 }
		 if (plCount != total) {
			 int errCode = 2146;
			 String msg = ""Internal Error. Inconsistency in key index found during optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG);
		 }
		 if (toPkgr.isSameMapKeyType()) {
			 toPkgr.setKeyType(fromPkgr.getKeyType());
		 }
		 else {
			 toPkgr.setKeyType(DataType.TUPLE);
		 }
	 }
	 private void addShiftedKeyInfoIndex(int index, Packager pkg) throws OptimizerException {
		 Map<Integer, Pair<Boolean, Map<Integer, Integer>>> keyInfo = pkg .getKeyInfo();
		 byte newIndex = (byte)(index | PigNullableWritable.mqFlag);
		 Set<Integer> existingIndices = keyInfo.keySet();
		 if(existingIndices.size() != 1) {
			 int errCode = 2146;
			 String msg = ""Internal Error. Inconsistency in key index found during optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG);
		 }
		 int existingIndex = existingIndices.iterator().next();
		 keyInfo.put(Integer.valueOf(newIndex), keyInfo.get(existingIndex));
		 if(newIndex != existingIndex) {
			 keyInfo.remove(existingIndex);
		 }
	 }
	 private int addShiftedKeyInfoIndex(int initialIndex, int onePastEndIndex, MultiQueryPackager mpkgr) throws OptimizerException {
		 List<Packager> pkgs = mpkgr.getPackagers();
		 int numIndices = (onePastEndIndex - initialIndex);
		 int end = numIndices;
		 if(numIndices > pkgs.size()) {
			 end = pkgs.size();
		 }
		 else if (numIndices < pkgs.size()) {
			 int errCode = 2146;
			 String msg = ""Internal Error. Inconsistency in key index found during optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG);
		 }
		 int i = 0;
		 int curIndex = initialIndex;
		 while (i < end) {
			 Packager pkg = pkgs.get(i);
			 addShiftedKeyInfoIndex(curIndex, pkg);
			 curIndex++;
			 i++;
		 }
		 return curIndex;
	 }
	 private void mergeOneCombinePlanWithIndex(PhysicalPlan from, PhysicalPlan to, int initial, int current, byte mapKeyType) throws VisitorException {
		 POPackage cpk = (POPackage)from.getRoots().get(0);
		 from.remove(cpk);
		 Packager cpkgr = cpk.getPkgr();
		 PODemux demux = (PODemux)to.getLeaves().get(0);
		 MultiQueryPackager toPkgr = (MultiQueryPackager) ((POPackage) to .getRoots().get(0)).getPkgr();
		 boolean isSameKeyType = toPkgr.isSameMapKeyType();
		 int total = current - initial;
		 int pkCount = 0;
		 if (cpkgr instanceof MultiQueryPackager) {
			 List<Packager> pkgrs = ((MultiQueryPackager) cpkgr).getPackagers();
			 for (Packager p : pkgrs) {
				 toPkgr.addPackager(p);
				 if (!isSameKeyType) {
					 p.setKeyType(DataType.TUPLE);
				 }
				 pkCount++;
			 }
		 }
		 else {
			 toPkgr.addPackager(cpkgr);
			 pkCount = 1;
		 }
		 toPkgr.setSameMapKeyType(isSameKeyType);
		 if (pkCount != total) {
			 int errCode = 2146;
			 String msg = ""Internal Error. Inconsistency in key index found during optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG);
		 }
		 if (!isSameKeyType) {
			 cpk.getPkgr().setKeyType(DataType.TUPLE);
		 }
		 toPkgr.setKeyType(cpk.getPkgr().getKeyType());
		 int plCount = 0;
		 PhysicalOperator leaf = from.getLeaves().get(0);
		 if (leaf instanceof PODemux) {
			 List<PhysicalPlan> pls = ((PODemux)leaf).getPlans();
			 for (PhysicalPlan pl : pls) {
				 demux.addPlan(pl);
				 POLocalRearrange lr = (POLocalRearrange)pl.getLeaves().get(0);
				 try {
					 lr.setMultiQueryIndex(initial + plCount++);
				 }
				 catch (ExecException e) {
					 int errCode = 2136;
					 String msg = ""Internal Error. Unable to set multi-query index for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG, e);
				 }
				 if (!isSameKeyType) {
					 lr.setKeyType(DataType.TUPLE);
				 }
			 }
		 }
		 else {
			 demux.addPlan(from);
			 POLocalRearrange lr = (POLocalRearrange)from.getLeaves().get(0);
			 try {
				 lr.setMultiQueryIndex(initial + plCount++);
			 }
			 catch (ExecException e) {
				 int errCode = 2136;
				 String msg = ""Internal Error. Unable to set multi-query index for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
			 if (!isSameKeyType) {
				 lr.setKeyType(DataType.TUPLE);
			 }
		 }
		 if (plCount != total) {
			 int errCode = 2146;
			 String msg = ""Internal Error. Inconsistency in key index found during optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG);
		 }
	 }
	 private boolean needCombiner(List<MapReduceOper> mapReducers) {
		 boolean needCombiner = false;
		 for (MapReduceOper mrOp : mapReducers) {
			 if (!mrOp.combinePlan.isEmpty()) {
				 needCombiner = true;
				 break;
			 }
		 }
		 return needCombiner;
	 }
	 private PhysicalPlan createDemuxPlan(boolean sameKeyType, boolean isCombiner) throws VisitorException {
		 PODemux demux = getDemux(isCombiner);
		 POPackage pkg = getMultiQueryPackage(sameKeyType, isCombiner);
		 PhysicalPlan pl = new PhysicalPlan();
		 pl.add(pkg);
		 try {
			 pl.addAsLeaf(demux);
		 }
		 catch (PlanException e) {
			 int errCode = 2137;
			 String msg = ""Internal Error. Unable to add demux to the plan as leaf for optimization."";
			 throw new OptimizerException(msg, errCode, PigException.BUG, e);
		 }
		 return pl;
	 }
	 private void mergeAllMapReduceSplittees(List<MapReduceOper> mergeList, MapReduceOper splitter, POSplit splitOp) throws VisitorException {
		 boolean sameKeyType = hasSameMapKeyType(mergeList);
		 log.debug(""Splittees have the same key type: "" + sameKeyType);
		 PhysicalPlan redPl = createDemuxPlan(sameKeyType, false);
		 PhysicalPlan comPl = needCombiner(mergeList) ? createDemuxPlan(sameKeyType, true) : null;
		 log.debug(""Splittees have combiner: "" + (comPl != null));
		 int index = 0;
		 for (MapReduceOper mrOp : mergeList) {
			 int incIndex = mergeOneMapPlanWithIndex( mrOp.mapPlan, splitOp, index, sameKeyType);
			 if (comPl != null) {
				 if (!mrOp.combinePlan.isEmpty()) {
					 mergeOneCombinePlanWithIndex( mrOp.combinePlan, comPl, index, incIndex, mrOp.mapKeyType);
				 }
				 else {
					 int errCode = 2141;
					 String msg = ""Internal Error. Cannot merge non-combiner with combiners for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG);
				 }
			 }
			 mergeOneReducePlanWithIndex( mrOp.reducePlan, redPl, index, incIndex, mrOp.mapKeyType);
			 index = incIndex;
			 log.info(""Merged MR job "" + mrOp.getOperatorKey().getId() + "" into MR job "" + splitter.getOperatorKey().getId());
		 }
		 PhysicalPlan splitterPl = splitter.mapPlan;
		 PhysicalOperator leaf = splitterPl.getLeaves().get(0);
		 PhysicalOperator storeOp = splitterPl.getLeaves().get(0);
		 List<PhysicalOperator> storePreds = splitterPl.getPredecessors(storeOp);
		 if (leaf instanceof POStore) {
			 splitOp.setInputs(storePreds);
			 try {
				 splitterPl.replace(storeOp, splitOp);
				;
			 }
			 catch (PlanException e) {
				 int errCode = 2132;
				 String msg = ""Internal Error. Unable to replace store with split operator for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
		 }
		 splitter.setMapDone(true);
		 splitter.reducePlan = redPl;
		 splitter.setReduceDone(true);
		 if (comPl != null) {
			 splitter.combinePlan = comPl;
		 }
		 for (MapReduceOper mrOp : mergeList) {
			 removeAndReconnect(mrOp, splitter);
		 }
		 splitter.mapKeyType = sameKeyType ? mergeList.get(0).mapKeyType : DataType.TUPLE;
		 setMapKeyTypeForSplitter(splitter,mergeList);
		 log.info(""Requested parallelism of splitter: "" + splitter.getRequestedParallelism());
	 }
	 private void setMapKeyTypeForSplitter(MapReduceOper splitter, List<MapReduceOper> mergeList) {
		 splitter.mapKeyTypeOfSplittees = new byte[mergeList.size()];
		 for (int i = 0;
		 i < mergeList.size();
		 i++) {
			 splitter.mapKeyTypeOfSplittees[i] = mergeList.get(i).mapKeyType;
		 }
	 }
	 private void mergeSingleMapReduceSplittee(MapReduceOper mapReduce, MapReduceOper splitter, POSplit splitOp) throws VisitorException {
		 PhysicalPlan splitterPl = splitter.mapPlan;
		 PhysicalOperator leaf = splitterPl.getLeaves().get(0);
		 PhysicalOperator storeOp = splitterPl.getLeaves().get(0);
		 List<PhysicalOperator> storePreds = splitterPl.getPredecessors(storeOp);
		 PhysicalPlan pl = mapReduce.mapPlan;
		 PhysicalOperator load = pl.getRoots().get(0);
		 pl.remove(load);
		 splitOp.addPlan(pl);
		 splitter.setMapDone(true);
		 splitter.reducePlan = mapReduce.reducePlan;
		 splitter.setReduceDone(true);
		 splitter.combinePlan = mapReduce.combinePlan;
		 splitter.customPartitioner = mapReduce.customPartitioner;
		 if (leaf instanceof POStore) {
			 splitOp.setInputs(storePreds);
			 try {
				 splitterPl.replace(storeOp, splitOp);
				;
			 }
			 catch (PlanException e) {
				 int errCode = 2132;
				 String msg = ""Internal Error. Unable to replace store with split operator for optimization."";
				 throw new OptimizerException(msg, errCode, PigException.BUG, e);
			 }
		 }
		 removeAndReconnect(mapReduce, splitter);
	 }
	 private void removeAndReconnect(MapReduceOper mr, MapReduceOper newMR) throws VisitorException {
		 List<MapReduceOper> mapperSuccs = getPlan().getSuccessors(mr);
		 List<MapReduceOper> mapperPreds = getPlan().getPredecessors(mr);
		 ArrayList<MapReduceOper> succsCopy = null;
		 ArrayList<MapReduceOper> predsCopy = null;
		 if (mapperSuccs != null) {
			 succsCopy = new ArrayList<MapReduceOper>(mapperSuccs);
		 }
		 if (mapperPreds != null) {
			 predsCopy = new ArrayList<MapReduceOper>(mapperPreds);
		 }
		 getPlan().remove(mr);
		 if (succsCopy != null) {
			 for (MapReduceOper succ : succsCopy) {
				 try {
					 getPlan().connect(newMR, succ);
				 }
				 catch (PlanException e) {
					 int errCode = 2133;
					 String msg = ""Internal Error. Unable to connect map plan with successors for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG, e);
				 }
			 }
		 }
		 if (predsCopy != null) {
			 for (MapReduceOper pred : predsCopy) {
				 if (newMR.getOperatorKey().equals(pred.getOperatorKey())) {
					 continue;
				 }
				 try {
					 getPlan().connect(pred, newMR);
				 }
				 catch (PlanException e) {
					 int errCode = 2134;
					 String msg = ""Internal Error. Unable to connect map plan with predecessors for optimization."";
					 throw new OptimizerException(msg, errCode, PigException.BUG, e);
				 }
			 }
		 }
		 mergeMROperProperties(mr, newMR);
	 }
	 private void mergeMROperProperties(MapReduceOper from, MapReduceOper to) {
		 if (from.isEndOfAllInputSetInMap()) {
			 to.setEndOfAllInputInMap(true);
		 }
		 if (from.isEndOfAllInputSetInReduce()) {
			 to.setEndOfAllInputInReduce(true);
		 }
		 if (from.getRequestedParallelism() > to.getRequestedParallelism()) {
			 to.requestedParallelism = from.requestedParallelism;
		 }
		 if (!from.UDFs.isEmpty()) {
			 to.UDFs.addAll(from.UDFs);
		 }
		 if (from.needsDistinctCombiner()) {
			 to.setNeedsDistinctCombiner(true);
		 }
		 if (to.mapKeyType == DataType.UNKNOWN) {
			 to.mapKeyType = from.mapKeyType;
		 }
	 }
	 private boolean isMapOnly(MapReduceOper mr) {
		 return mr.reducePlan.isEmpty();
	 }
	 private boolean isSingleLoadMapperPlan(PhysicalPlan pl) {
		 return (pl.getRoots().size() == 1);
	 }
	 private boolean isSinglePredecessor(MapReduceOper mr) {
		 return (getPlan().getPredecessors(mr).size() == 1);
	 }
	 private POSplit getSplit(){
		 return new POSplit(new OperatorKey(scope, nig.getNextNodeId(scope)));
	 }
	 private MapReduceOper getMROper(){
		 return new MapReduceOper(new OperatorKey(scope, nig.getNextNodeId(scope)));
	 }
	 private POStore getStore(){
		 return new POStore(new OperatorKey(scope, nig.getNextNodeId(scope)));
	 }
	 private PODemux getDemux(boolean inCombiner){
		 PODemux demux = new PODemux(new OperatorKey(scope, nig.getNextNodeId(scope)));
		 demux.setInCombiner(inCombiner);
		 return demux;
	 }
	 private POPackage getMultiQueryPackage(boolean sameMapKeyType, boolean inCombiner) {
		 POPackage pkg = new POPackage(new OperatorKey(scope, nig.getNextNodeId(scope)));
		 MultiQueryPackager pkgr = new MultiQueryPackager();
		 pkgr.setInCombiner(inCombiner);
		 pkgr.setSameMapKeyType(sameMapKeyType);
		 pkg.setPkgr(pkgr);
		 return pkg;
	 }
}",1,0,0,0
"public java.lang.String toString() {
	 java.lang.StringBuilder sb = new java.lang.StringBuilder(""SupervisorInfo("");
	 boolean first = true;
	 sb.append(""time_secs:"");
	 sb.append(this.time_secs);
	 first = false;
	 if (!first) sb.append("", "");
	 sb.append(""hostname:"");
	 if (this.hostname == null) {
		 sb.append(""null"");
	 }
	 else {
		 sb.append(this.hostname);
	 }
	 first = false;
	 if (is_set_assignment_id()) {
		 if (!first) sb.append("", "");
		 sb.append(""assignment_id:"");
		 if (this.assignment_id == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.assignment_id);
		 }
		 first = false;
	 }
	 if (is_set_used_ports()) {
		 if (!first) sb.append("", "");
		 sb.append(""used_ports:"");
		 if (this.used_ports == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.used_ports);
		 }
		 first = false;
	 }
	 if (is_set_meta()) {
		 if (!first) sb.append("", "");
		 sb.append(""meta:"");
		 if (this.meta == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.meta);
		 }
		 first = false;
	 }
	 if (is_set_scheduler_meta()) {
		 if (!first) sb.append("", "");
		 sb.append(""scheduler_meta:"");
		 if (this.scheduler_meta == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.scheduler_meta);
		 }
		 first = false;
	 }
	 if (is_set_uptime_secs()) {
		 if (!first) sb.append("", "");
		 sb.append(""uptime_secs:"");
		 sb.append(this.uptime_secs);
		 first = false;
	 }
	 if (is_set_version()) {
		 if (!first) sb.append("", "");
		 sb.append(""version:"");
		 if (this.version == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.version);
		 }
		 first = false;
	 }
	 if (is_set_resources_map()) {
		 if (!first) sb.append("", "");
		 sb.append(""resources_map:"");
		 if (this.resources_map == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.resources_map);
		 }
		 first = false;
	 }
	 if (is_set_server_port()) {
		 if (!first) sb.append("", "");
		 sb.append(""server_port:"");
		 sb.append(this.server_port);
		 first = false;
	 }
	 sb.append("")"");
	 return sb.toString();
 }",0,0,1,0
"public static void copyDirectory(final File srcDir, final File destDir) throws IOException {
	 if (srcDir == null) {
		 throw new NullPointerException(""Source must not be null"");
	 }
	 if (destDir == null) {
		 throw new NullPointerException(""Destination must not be null"");
	 }
	 if (!srcDir.exists()) {
		 throw new FileNotFoundException(""Source '"" + srcDir + ""' does not exist"");
	 }
	 if (!srcDir.isDirectory()) {
		 throw new IOException(""Source '"" + srcDir + ""' exists but is not a directory"");
	 }
	 if (srcDir.getCanonicalPath().equals(destDir.getCanonicalPath())) {
		 throw new IOException(""Source '"" + srcDir + ""' and destination '"" + destDir + ""' are the same"");
	 }
	 List<String> exclusionList = null;
	 if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath())) {
		 final File[] srcFiles = srcDir.listFiles();
		 if (srcFiles != null && srcFiles.length > 0) {
			 exclusionList = new ArrayList<>(srcFiles.length);
			 for (final File srcFile : srcFiles) {
				 final File copiedFile = new File(destDir, srcFile.getName());
				 exclusionList.add(copiedFile.getCanonicalPath());
			 }
		 }
	 }
	 doCopyDirectory(srcDir, destDir, exclusionList);
 }",0,0,1,0
"private void loadNextBuffer() {
	 try {
		 String line = """";
		 this.clear();
		 rowsLoaded = 0;
		 while (rowsLoaded < bufferSize) {
			 line = bufferedReader.readLine();
			 if (line == null) {
				 break;
			 }
			 rowsLoaded++;
			 double[] inputs = new double[getInputSize()];
			 double[] outputs = new double[getOutputSize()];
			 String[] values = line.split(delimiter);
			 if (values[0].equals("""")) {
				 continue;
			 }
			 for (int i = 0;
			 i < getInputSize();
			 i++) {
				 inputs[i] = Double.parseDouble(values[i]);
			 }
			 for (int i = 0;
			 i < getOutputSize();
			 i++) {
				 outputs[i] = Double.parseDouble(values[getInputSize() + i]);
			 }
			 if (getOutputSize() > 0) {
				 this.addRow(new DataSetRow(inputs, outputs));
			 }
			 else {
				 this.addRow(new DataSetRow(inputs));
			 }
		 }
		 bufferedRows = this.getRows();
		 bufferIterator = bufferedRows.iterator();
	 }
	 catch (FileNotFoundException ex) {
		 ex.printStackTrace();
	 }
	 catch (IOException ex) {
		 if (fileReader != null) {
			 try {
				 fileReader.close();
			 }
			 catch (IOException ex1) {
			 }
		 }
		 ex.printStackTrace();
	 }
	 catch (NumberFormatException ex) {
		 if (fileReader != null) {
			 try {
				 fileReader.close();
			 }
			 catch (IOException ex1) {
			 }
		 }
		 ex.printStackTrace();
		 throw ex;
	 }
 }",0,0,1,0
"public JRExporterGridCell(ElementWrapper wrapper, int width, int height,int colSpan, int rowSpan);",0,0,0,1
"public synchronized Task pollForNewTask(String taskTracker) {
	 int avgMaps = 0;
	 int avgReduces = 0;
	 int numTaskTrackers;
	 TaskTrackerStatus tts;
	 synchronized (taskTrackers) {
		 numTaskTrackers = taskTrackers.size();
		 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
	 }
	 if (numTaskTrackers > 0) {
		 avgMaps = totalMaps / numTaskTrackers;
		 avgReduces = totalReduces / numTaskTrackers;
	 }
	 int totalCapacity = numTaskTrackers * maxCurrentTasks;
	 if (tts == null) {
		 LOG.warning(""Unknown task tracker polling;
		 ignoring: "" + taskTracker);
		 return null;
	 }
	 int numMaps = tts.countMapTasks();
	 int numReduces = tts.countReduceTasks();
	 synchronized (jobsByArrival) {
		 if ((numMaps < maxCurrentTasks) && (numMaps <= (avgMaps + TASK_ALLOC_EPSILON))) {
			 int totalNeededMaps = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewMapTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 return t;
				 }
				 totalNeededMaps += job.desiredMaps();
				 double padding = 0;
				 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, totalNeededMaps * PAD_FRACTION);
				 }
				 if (totalNeededMaps + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
		 if ((numReduces < maxCurrentTasks) && (numReduces <= (avgReduces + TASK_ALLOC_EPSILON))) {
			 int totalNeededReduces = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewReduceTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 return t;
				 }
				 totalNeededReduces += job.desiredReduces();
				 double padding = 0;
				 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, totalNeededReduces * PAD_FRACTION);
				 }
				 if (totalNeededReduces + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public class ReflectionModule extends LazyModule {
	 private ReflectionModuleManager modelManager;
	 private boolean packagesLoaded = false;
	 public ReflectionModule(ReflectionModuleManager reflectionModuleManager) {
		 this.modelManager = reflectionModuleManager;
	 }
	 protected AbstractModelLoader getModelLoader() {
		 return modelManager.getModelLoader();
	 }
	 public List<Package> getPackages() {
		 final AbstractModelLoader modelLoader = getModelLoader();
		 if(!packagesLoaded){
			 modelLoader.synchronizedRun(new Runnable() {
				 public void run() {
					 if(!packagesLoaded){
						 String name = getNameAsString();
						 for(String pkg : getJarPackages()){
							 if(!name.equals(AbstractModelLoader.CEYLON_LANGUAGE) || pkg.startsWith(AbstractModelLoader.CEYLON_LANGUAGE)) modelLoader.findOrCreatePackage(ReflectionModule.this, pkg);
						 }
						 packagesLoaded = true;
					 }
				 }
			 }
			);
		 }
		 return super.getPackages();
	 }
}",0,0,0,0
"abstract static class RequestParamsBuilder<T> {
	 T body;
	 public RequestParamsBuilder(T body) {
		 this.body = body;
	 }
	 abstract RequestParams buildRequestParams();
	 void setBody(T body) {
		 this.body = body;
	 }
 }",0,1,0,0
"private void addOutputContainerData() {
	 final VarCharVector fragmentIdVector = (VarCharVector) container.getValueAccessorById( VarCharVector.class, container.getValueVectorId(SchemaPath.getSimplePath(""Fragment"")).getFieldIds()) .getValueVector();
	 AllocationHelper.allocate(fragmentIdVector, 1, 50);
	 final BigIntVector summaryVector = (BigIntVector) container.getValueAccessorById(BigIntVector.class, container.getValueVectorId(SchemaPath.getSimplePath(""Number of records written"")).getFieldIds()) .getValueVector();
	 AllocationHelper.allocate(summaryVector, 1, 8);
	 fragmentIdVector.getMutator().setSafe(0, fragmentUniqueId.getBytes());
	 fragmentIdVector.getMutator().setValueCount(1);
	 summaryVector.getMutator().setSafe(0, counter);
	 summaryVector.getMutator().setValueCount(1);
	 container.setRecordCount(1);
 }",0,0,1,0
"private class ClientSelectDeleteMutationPlan implements MutationPlan {
	 private final StatementContext context;
	 private final TableRef targetTableRef;
	 private final QueryPlan dataPlan;
	 private final QueryPlan bestPlan;
	 private final boolean hasPreOrPostProcessing;
	 private final DeletingParallelIteratorFactory parallelIteratorFactory;
	 private final List<TableRef> otherTableRefs;
	 private final TableRef projectedTableRef;
	 private final int maxSize;
	 private final int maxSizeBytes;
	 private final PhoenixConnection connection;
	 public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan, boolean hasPreOrPostProcessing, DeletingParallelIteratorFactory parallelIteratorFactory, List<TableRef> otherTableRefs, TableRef projectedTableRef, int maxSize, int maxSizeBytes, PhoenixConnection connection) {
		 this.context = bestPlan.getContext();
		 this.targetTableRef = targetTableRef;
		 this.dataPlan = dataPlan;
		 this.bestPlan = bestPlan;
		 this.hasPreOrPostProcessing = hasPreOrPostProcessing;
		 this.parallelIteratorFactory = parallelIteratorFactory;
		 this.otherTableRefs = otherTableRefs;
		 this.projectedTableRef = projectedTableRef;
		 this.maxSize = maxSize;
		 this.maxSizeBytes = maxSizeBytes;
		 this.connection = connection;
	 }
	 public ParameterMetaData getParameterMetaData() {
		 return context.getBindManager().getParameterMetaData();
	 }
	 public StatementContext getContext() {
		 return context;
	 }
	 public TableRef getTargetRef() {
		 return targetTableRef;
	 }
	 public Set<TableRef> getSourceRefs() {
		 return dataPlan.getSourceRefs();
	 }
	 public Operation getOperation() {
		 return operation;
	 }
	 public MutationState execute() throws SQLException {
		 ResultIterator iterator = bestPlan.iterator();
		 try {
			 if (!hasPreOrPostProcessing) {
				 Tuple tuple;
				 long totalRowCount = 0;
				 if (parallelIteratorFactory != null) {
					 parallelIteratorFactory.setQueryPlan(bestPlan);
					 parallelIteratorFactory.setOtherTableRefs(otherTableRefs);
					 parallelIteratorFactory.setProjectedTableRef(projectedTableRef);
				 }
				 while ((tuple=iterator.next()) != null) {
					 Cell kv = tuple.getValue(0);
					 totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());
				 }
				 int totalTablesUpdateClientSide = 1;
				 PTable bestTable = bestPlan.getTableRef().getTable();
				 if (bestPlan != dataPlan && isMaintainedOnClient(bestTable)) {
					 totalTablesUpdateClientSide++;
				 }
				 for (TableRef otherTableRef : otherTableRefs) {
					 PTable otherTable = otherTableRef.getTable();
					 if (projectedTableRef != otherTableRef && isMaintainedOnClient(otherTable)) {
						 totalTablesUpdateClientSide++;
					 }
				 }
				 MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);
				 state.setReadMetricQueue(context.getReadMetricsQueue());
				 return state;
			 }
			 else {
				 return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);
			 }
		 }
		 finally {
			 iterator.close();
		 }
	 }
	 public ExplainPlan getExplainPlan() throws SQLException {
		 List<String> queryPlanSteps = bestPlan.getExplainPlan().getPlanSteps();
		 List<String> planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);
		 planSteps.add(""DELETE ROWS"");
		 planSteps.addAll(queryPlanSteps);
		 return new ExplainPlan(planSteps);
	 }
	 public Long getEstimatedRowsToScan() throws SQLException {
		 return bestPlan.getEstimatedRowsToScan();
	 }
	 public Long getEstimatedBytesToScan() throws SQLException {
		 return bestPlan.getEstimatedBytesToScan();
	 }
	 public Long getEstimateInfoTimestamp() throws SQLException {
		 return bestPlan.getEstimateInfoTimestamp();
	 }
	 public QueryPlan getQueryPlan() {
		 return bestPlan;
	 }
 }",1,1,0,0
"private void renderFlatTriangle(Vec2 pos1, double zf1, Vec2 pos2, double zf2, Vec2 pos3, double zf3, int width, int height, double clip, int mode, RGBColor color) {
	 int x1, y1, z1, x2, y2, z2, x3, y3, z3;
	 int dx1, dx2, dy1, dy2, dz1, dz2, mx1, mx2, mz1, mz2;
	 int xstart, xend, yend, zstart, zend, y, z, dz, left, right, i, index;
	 int clipDist = (int) (clip*65535.0), r, g, b, red, green, blue, col;
	 if (mode == MODE_COPY) {
		 col = color.getARGB();
		 red = green = blue = 0;
	 }
	 else {
		 col = 0;
		 red = (int) (color.getRed()*255.0f);
		 green = (int) (color.getGreen()*255.0f);
		 blue = (int) (color.getBlue()*255.0f);
	 }
	 if (pos1.y <= pos2.y && pos1.y <= pos3.y) {
		 x1 = ((int) pos1.x) << 16;
		 y1 = ((int) pos1.y);
		 z1 = (int) (zf1*65535.0);
		 if (pos2.y < pos3.y) {
			 x2 = ((int) pos2.x) << 16;
			 y2 = ((int) pos2.y);
			 z2 = (int) (zf2*65535.0);
			 x3 = ((int) pos3.x) << 16;
			 y3 = ((int) pos3.y);
			 z3 = (int) (zf3*65535.0);
		 }
		 else {
			 x2 = ((int) pos3.x) << 16;
			 y2 = ((int) pos3.y);
			 z2 = (int) (zf3*65535.0);
			 x3 = ((int) pos2.x) << 16;
			 y3 = ((int) pos2.y);
			 z3 = (int) (zf2*65535.0);
		 }
	 }
	 else if (pos2.y <= pos1.y && pos2.y <= pos3.y) {
		 x1 = ((int) pos2.x) << 16;
		 y1 = ((int) pos2.y);
		 z1 = (int) (zf2*65535.0);
		 if (pos1.y < pos3.y) {
			 x2 = ((int) pos1.x) << 16;
			 y2 = ((int) pos1.y);
			 z2 = (int) (zf1*65535.0);
			 x3 = ((int) pos3.x) << 16;
			 y3 = ((int) pos3.y);
			 z3 = (int) (zf3*65535.0);
		 }
		 else {
			 x2 = ((int) pos3.x) << 16;
			 y2 = ((int) pos3.y);
			 z2 = (int) (zf3*65535.0);
			 x3 = ((int) pos1.x) << 16;
			 y3 = ((int) pos1.y);
			 z3 = (int) (zf1*65535.0);
		 }
	 }
	 else {
		 x1 = ((int) pos3.x) << 16;
		 y1 = ((int) pos3.y);
		 z1 = (int) (zf3*65535.0);
		 if (pos1.y < pos2.y) {
			 x2 = ((int) pos1.x) << 16;
			 y2 = ((int) pos1.y);
			 z2 = (int) (zf1*65535.0);
			 x3 = ((int) pos2.x) << 16;
			 y3 = ((int) pos2.y);
			 z3 = (int) (zf2*65535.0);
		 }
		 else {
			 x2 = ((int) pos2.x) << 16;
			 y2 = ((int) pos2.y);
			 z2 = (int) (zf2*65535.0);
			 x3 = ((int) pos1.x) << 16;
			 y3 = ((int) pos1.y);
			 z3 = (int) (zf1*65535.0);
		 }
	 }
	 dx1 = x3-x1;
	 dy1 = y3-y1;
	 dz1 = z3-z1;
	 if (dy1 == 0) return;
	 dx2 = x2-x1;
	 dy2 = y2-y1;
	 dz2 = z2-z1;
	 mx1 = dx1/dy1;
	 mz1 = dz1/dy1;
	 xstart = xend = x1;
	 zstart = zend = z1;
	 y = y1;
	 if (dy2 != 0) {
		 mx2 = dx2/dy2;
		 mz2 = dz2/dy2;
		 if (y2 < 0) {
			 xstart += mx1*dy2;
			 xend += mx2*dy2;
			 zstart += mz1*dy2;
			 zend += mz2*dy2;
			 y = y2;
		 }
		 else if (y < 0) {
			 xstart -= mx1*y;
			 xend -= mx2*y;
			 zstart -= mz1*y;
			 zend -= mz2*y;
			 y = 0;
		 }
		 yend = (y2 < height ? y2 : height);
		 index = y*width;
		 while (y < yend) {
			 if (xstart < xend) {
				 left = xstart >> 16;
				 right = xend >> 16;
				 z = zstart;
				 dz = zend-zstart;
			 }
			 else {
				 left = xend >> 16;
				 right = xstart >> 16;
				 z = zend;
				 dz = zstart-zend;
			 }
			 if (left != right) {
				 dz /= (right-left);
				 if (left < 0) {
					 z -= left*dz;
					 left = 0;
				 }
				 if (right > width) right = width;
				 if (mode == MODE_COPY) {
					 for (i = left;
					 i < right;
					 i++) {
						 if (z < zbuffer[index+i] && z > clipDist) {
							 pixel[index+i] = col;
							 zbuffer[index+i] = z;
						 }
						 z += dz;
					 }
				 }
				 else if (mode == MODE_ADD) {
					 for (i = left;
					 i < right;
					 i++) {
						 if (z > clipDist) {
							 r = ((pixel[index+i] & 0xFF0000) >> 16) + red;
							 g = ((pixel[index+i] & 0xFF00) >> 8) + green;
							 b = (pixel[index+i] & 0xFF) + blue;
							 if (r > 255) r = 255;
							 if (g > 255) g = 255;
							 if (b > 255) b = 255;
							 pixel[index+i] = 0xFF000000 + (r<<16) + (g<<8) + b;
						 }
						 z += dz;
					 }
				 }
				 else {
					 for (i = left;
					 i < right;
					 i++) {
						 if (z > clipDist) {
							 r = ((pixel[index+i] & 0xFF0000) >> 16) - red;
							 g = ((pixel[index+i] & 0xFF00) >> 8) - green;
							 b = (pixel[index+i] & 0xFF) - blue;
							 if (r < 0) r = 0;
							 if (g < 0) g = 0;
							 if (b < 0) b = 0;
							 pixel[index+i] = 0xFF000000 + (r<<16) + (g<<8) + b;
						 }
						 z += dz;
					 }
				 }
			 }
			 xstart += mx1;
			 zstart += mz1;
			 xend += mx2;
			 zend += mz2;
			 index += width;
			 y++;
		 }
	 }
	 dx2 = x3-x2;
	 dy2 = y3-y2;
	 dz2 = z3-z2;
	 if (dy2 != 0) {
		 mx2 = dx2/dy2;
		 mz2 = dz2/dy2;
		 xend = x2;
		 zend = z2;
		 if (y < 0) {
			 xstart -= mx1*y;
			 xend -= mx2*y;
			 zstart -= mz1*y;
			 zend -= mz2*y;
			 y = 0;
		 }
		 yend = (y3 < height ? y3 : height);
		 index = y*width;
		 while (y < yend) {
			 if (xstart < xend) {
				 left = xstart >> 16;
				 right = xend >> 16;
				 z = zstart;
				 dz = zend-zstart;
			 }
			 else {
				 left = xend >> 16;
				 right = xstart >> 16;
				 z = zend;
				 dz = zstart-zend;
			 }
			 if (left != right) {
				 dz /= (right-left);
				 if (left < 0) {
					 z -= left*dz;
					 left = 0;
				 }
				 if (right > width) right = width;
				 if (mode == MODE_COPY) {
					 for (i = left;
					 i < right;
					 i++) {
						 if (z < zbuffer[index+i] && z > clipDist) {
							 pixel[index+i] = col;
							 zbuffer[index+i] = z;
						 }
						 z += dz;
					 }
				 }
				 else if (mode == MODE_ADD) {
					 for (i = left;
					 i < right;
					 i++) {
						 if (z > clipDist) {
							 r = ((pixel[index+i] & 0xFF0000) >> 16) + red;
							 g = ((pixel[index+i] & 0xFF00) >> 8) + green;
							 b = (pixel[index+i] & 0xFF) + blue;
							 if (r > 255) r = 255;
							 if (g > 255) g = 255;
							 if (b > 255) b = 255;
							 pixel[index+i] = 0xFF000000 + (r<<16) + (g<<8) + b;
						 }
						 z += dz;
					 }
				 }
				 else {
					 for (i = left;
					 i < right;
					 i++) {
						 if (z > clipDist) {
							 r = ((pixel[index+i] & 0xFF0000) >> 16) - red;
							 g = ((pixel[index+i] & 0xFF00) >> 8) - green;
							 b = (pixel[index+i] & 0xFF) - blue;
							 if (r < 0) r = 0;
							 if (g < 0) g = 0;
							 if (b < 0) b = 0;
							 pixel[index+i] = 0xFF000000 + (r<<16) + (g<<8) + b;
						 }
						 z += dz;
					 }
				 }
			 }
			 xstart += mx1;
			 zstart += mz1;
			 xend += mx2;
			 zend += mz2;
			 index += width;
			 y++;
		 }
	 }
 }",0,0,1,0
"public class Manifest {
	 public static final String ATTRIBUTE_MANIFEST_VERSION = ""Manifest-Version"";
	 public static final String ATTRIBUTE_SIGNATURE_VERSION = ""Signature-Version"";
	 public static final String ATTRIBUTE_NAME = ""Name"";
	 public static final String ATTRIBUTE_FROM = ""From"";
	 public static final String ATTRIBUTE_CLASSPATH = ""Class-Path"";
	 public static final String DEFAULT_MANIFEST_VERSION = ""1.0"";
	 public static final int MAX_LINE_LENGTH = 72;
	 public static final int MAX_SECTION_LENGTH = MAX_LINE_LENGTH - 2;
	 public static final String EOL = ""\r\n"";
	 public static final String ERROR_FROM_FORBIDDEN = ""Manifest attributes should not start "" + ""with \"""" + ATTRIBUTE_FROM + ""\"" in \"""";
	 public static final String JAR_ENCODING = ""UTF-8"";
	 public static class Attribute {
		 private static final int MAX_NAME_VALUE_LENGTH = 68;
		 private static final int MAX_NAME_LENGTH = 70;
		 private String name = null;
		 private Vector values = new Vector();
		 private int currentIndex = 0;
		 public Attribute() {
		 }
		 public Attribute(String line) throws ManifestException {
			 parse(line);
		 }
		 public Attribute(String name, String value) {
			 this.name = name;
			 setValue(value);
		 }
		 public int hashCode() {
			 int hashCode = 0;
			 if (name != null) {
				 hashCode += getKey().hashCode();
			 }
			 hashCode += values.hashCode();
			 return hashCode;
		 }
		 public boolean equals(Object rhs) {
			 if (rhs == null || rhs.getClass() != getClass()) {
				 return false;
			 }
			 if (rhs == this) {
				 return true;
			 }
			 Attribute rhsAttribute = (Attribute) rhs;
			 String lhsKey = getKey();
			 String rhsKey = rhsAttribute.getKey();
			 if ((lhsKey == null && rhsKey != null) || (lhsKey != null && !lhsKey.equals(rhsKey))) {
				 return false;
			 }
			 return values.equals(rhsAttribute.values);
		 }
		 public void parse(String line) throws ManifestException {
			 int index = line.indexOf("": "");
			 if (index == -1) {
				 throw new ManifestException(""Manifest line \"""" + line + ""\"" is not valid as it does not "" + ""contain a name and a value separated by ': ' "");
			 }
			 name = line.substring(0, index);
			 setValue(line.substring(index + 2));
		 }
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public String getKey() {
			 if (name == null) {
				 return null;
			 }
			 return name.toLowerCase();
		 }
		 public void setValue(String value) {
			 if (currentIndex >= values.size()) {
				 values.addElement(value);
				 currentIndex = values.size() - 1;
			 }
			 else {
				 values.setElementAt(value, currentIndex);
			 }
		 }
		 public String getValue() {
			 if (values.size() == 0) {
				 return null;
			 }
			 String fullValue = """";
			 for (Enumeration e = getValues();
			 e.hasMoreElements();
			) {
				 String value = (String) e.nextElement();
				 fullValue += value + "" "";
			 }
			 return fullValue.trim();
		 }
		 public void addValue(String value) {
			 currentIndex++;
			 setValue(value);
		 }
		 public Enumeration getValues() {
			 return values.elements();
		 }
		 public void addContinuation(String line) {
			 String currentValue = (String) values.elementAt(currentIndex);
			 setValue(currentValue + line.substring(1));
		 }
		 public void write(PrintWriter writer) throws IOException {
			 for (Enumeration e = getValues();
			 e.hasMoreElements();
			) {
				 writeValue(writer, (String) e.nextElement());
			 }
		 }
		 private void writeValue(PrintWriter writer, String value) throws IOException {
			 String line = null;
			 int nameLength = name.getBytes(JAR_ENCODING).length;
			 if (nameLength > MAX_NAME_VALUE_LENGTH) {
				 if (nameLength > MAX_NAME_LENGTH) {
					 throw new IOException(""Unable to write manifest line "" + name + "": "" + value);
				 }
				 writer.print(name + "": "" + EOL);
				 line = "" "" + value;
			 }
			 else {
				 line = name + "": "" + value;
			 }
			 while (line.getBytes(JAR_ENCODING).length > MAX_SECTION_LENGTH) {
				 int breakIndex = MAX_SECTION_LENGTH;
				 if (breakIndex >= line.length()) {
					 breakIndex = line.length() - 1;
				 }
				 String section = line.substring(0, breakIndex);
				 while (section.getBytes(JAR_ENCODING).length > MAX_SECTION_LENGTH && breakIndex > 0) {
					 breakIndex--;
					 section = line.substring(0, breakIndex);
				 }
				 if (breakIndex == 0) {
					 throw new IOException(""Unable to write manifest line "" + name + "": "" + value);
				 }
				 writer.print(section + EOL);
				 line = "" "" + line.substring(breakIndex);
			 }
			 writer.print(line + EOL);
		 }
	 }
	 public static class Section {
		 private Vector warnings = new Vector();
		 private String name = null;
		 private Hashtable attributes = new Hashtable();
		 private Vector attributeIndex = new Vector();
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public String read(BufferedReader reader) throws ManifestException, IOException {
			 Attribute attribute = null;
			 while (true) {
				 String line = reader.readLine();
				 if (line == null || line.length() == 0) {
					 return null;
				 }
				 if (line.charAt(0) == ' ') {
					 if (attribute == null) {
						 if (name != null) {
							 name += line.substring(1);
						 }
						 else {
							 throw new ManifestException(""Can't start an "" + ""attribute with a continuation line "" + line);
						 }
					 }
					 else {
						 attribute.addContinuation(line);
					 }
				 }
				 else {
					 attribute = new Attribute(line);
					 String nameReadAhead = addAttributeAndCheck(attribute);
					 attribute = getAttribute(attribute.getKey());
					 if (nameReadAhead != null) {
						 return nameReadAhead;
					 }
				 }
			 }
		 }
		 public void merge(Section section) throws ManifestException {
			 if (name == null && section.getName() != null || name != null && !(name.equalsIgnoreCase(section.getName()))) {
				 throw new ManifestException(""Unable to merge sections "" + ""with different names"");
			 }
			 Enumeration e = section.getAttributeKeys();
			 Attribute classpathAttribute = null;
			 while (e.hasMoreElements()) {
				 String attributeName = (String) e.nextElement();
				 Attribute attribute = section.getAttribute(attributeName);
				 if (attributeName.equalsIgnoreCase(ATTRIBUTE_CLASSPATH)) {
					 if (classpathAttribute == null) {
						 classpathAttribute = new Attribute();
						 classpathAttribute.setName(ATTRIBUTE_CLASSPATH);
					 }
					 Enumeration cpe = attribute.getValues();
					 while (cpe.hasMoreElements()) {
						 String value = (String) cpe.nextElement();
						 classpathAttribute.addValue(value);
					 }
				 }
				 else {
					 storeAttribute(attribute);
				 }
			 }
			 if (classpathAttribute != null) {
				 storeAttribute(classpathAttribute);
			 }
			 Enumeration warnEnum = section.warnings.elements();
			 while (warnEnum.hasMoreElements()) {
				 warnings.addElement(warnEnum.nextElement());
			 }
		 }
		 public void write(PrintWriter writer) throws IOException {
			 if (name != null) {
				 Attribute nameAttr = new Attribute(ATTRIBUTE_NAME, name);
				 nameAttr.write(writer);
			 }
			 Enumeration e = getAttributeKeys();
			 while (e.hasMoreElements()) {
				 String key = (String) e.nextElement();
				 Attribute attribute = getAttribute(key);
				 attribute.write(writer);
			 }
			 writer.print(EOL);
		 }
		 public Attribute getAttribute(String attributeName) {
			 return (Attribute) attributes.get(attributeName.toLowerCase());
		 }
		 public Enumeration getAttributeKeys() {
			 return attributeIndex.elements();
		 }
		 public String getAttributeValue(String attributeName) {
			 Attribute attribute = getAttribute(attributeName.toLowerCase());
			 if (attribute == null) {
				 return null;
			 }
			 return attribute.getValue();
		 }
		 public void removeAttribute(String attributeName) {
			 String key = attributeName.toLowerCase();
			 attributes.remove(key);
			 attributeIndex.removeElement(key);
		 }
		 public void addConfiguredAttribute(Attribute attribute) throws ManifestException {
			 String check = addAttributeAndCheck(attribute);
			 if (check != null) {
				 throw new BuildException(""Specify the section name using "" + ""the \""name\"" attribute of the <section> element rather "" + ""than using a \""Name\"" manifest attribute"");
			 }
		 }
		 public String addAttributeAndCheck(Attribute attribute) throws ManifestException {
			 if (attribute.getName() == null || attribute.getValue() == null) {
				 throw new BuildException(""Attributes must have name and value"");
			 }
			 if (attribute.getKey().equalsIgnoreCase(ATTRIBUTE_NAME)) {
				 warnings.addElement(""\"""" + ATTRIBUTE_NAME + ""\"" attributes "" + ""should not occur in the main section and must be the "" + ""first element in all other sections: \"""" + attribute.getName() + "": "" + attribute.getValue() + ""\"""");
				 return attribute.getValue();
			 }
			 if (attribute.getKey().startsWith(ATTRIBUTE_FROM.toLowerCase())) {
				 warnings.addElement(ERROR_FROM_FORBIDDEN + attribute.getName() + "": "" + attribute.getValue() + ""\"""");
			 }
			 else {
				 String attributeKey = attribute.getKey();
				 if (attributeKey.equalsIgnoreCase(ATTRIBUTE_CLASSPATH)) {
					 Attribute classpathAttribute = (Attribute) attributes.get(attributeKey);
					 if (classpathAttribute == null) {
						 storeAttribute(attribute);
					 }
					 else {
						 warnings.addElement(""Multiple Class-Path attributes "" + ""are supported but violate the Jar "" + ""specification and may not be correctly "" + ""processed in all environments"");
						 Enumeration e = attribute.getValues();
						 while (e.hasMoreElements()) {
							 String value = (String) e.nextElement();
							 classpathAttribute.addValue(value);
						 }
					 }
				 }
				 else if (attributes.containsKey(attributeKey)) {
					 throw new ManifestException(""The attribute \"""" + attribute.getName() + ""\"" may not occur more "" + ""than once in the same section"");
				 }
				 else {
					 storeAttribute(attribute);
				 }
			 }
			 return null;
		 }
		 public Object clone() {
			 Section cloned = new Section();
			 cloned.setName(name);
			 Enumeration e = getAttributeKeys();
			 while (e.hasMoreElements()) {
				 String key = (String) e.nextElement();
				 Attribute attribute = getAttribute(key);
				 cloned.storeAttribute(new Attribute(attribute.getName(), attribute.getValue()));
			 }
			 return cloned;
		 }
		 private void storeAttribute(Attribute attribute) {
			 if (attribute == null) {
				 return;
			 }
			 String attributeKey = attribute.getKey();
			 attributes.put(attributeKey, attribute);
			 if (!attributeIndex.contains(attributeKey)) {
				 attributeIndex.addElement(attributeKey);
			 }
		 }
		 public Enumeration getWarnings() {
			 return warnings.elements();
		 }
		 public int hashCode() {
			 return attributes.hashCode();
		 }
		 public boolean equals(Object rhs) {
			 if (rhs == null || rhs.getClass() != getClass()) {
				 return false;
			 }
			 if (rhs == this) {
				 return true;
			 }
			 Section rhsSection = (Section) rhs;
			 return attributes.equals(rhsSection.attributes);
		 }
	 }
	 private String manifestVersion = DEFAULT_MANIFEST_VERSION;
	 private Section mainSection = new Section();
	 private Hashtable sections = new Hashtable();
	 private Vector sectionIndex = new Vector();
	 public static Manifest getDefaultManifest() throws BuildException {
		 InputStream in = null;
		 InputStreamReader insr = null;
		 try {
			 String defManifest = ""/org/apache/tools/ant/defaultManifest.mf"";
			 in = Manifest.class.getResourceAsStream(defManifest);
			 if (in == null) {
				 throw new BuildException(""Could not find default manifest: "" + defManifest);
			 }
			 try {
				 insr = new InputStreamReader(in, ""UTF-8"");
				 Manifest defaultManifest = new Manifest(insr);
				 Attribute createdBy = new Attribute(""Created-By"", System.getProperty(""java.vm.version"") + "" ("" + System.getProperty(""java.vm.vendor"") + "")"");
				 defaultManifest.getMainSection().storeAttribute(createdBy);
				 return defaultManifest;
			 }
			 catch (UnsupportedEncodingException e) {
				 insr = new InputStreamReader(in);
				 return new Manifest(insr);
			 }
		 }
		 catch (ManifestException e) {
			 throw new BuildException(""Default manifest is invalid !!"", e);
		 }
		 catch (IOException e) {
			 throw new BuildException(""Unable to read default manifest"", e);
		 }
		 finally {
			 FileUtils.close(insr);
			 FileUtils.close(in);
		 }
	 }
	 public Manifest() {
		 manifestVersion = null;
	 }
	 public Manifest(Reader r) throws ManifestException, IOException {
		 BufferedReader reader = new BufferedReader(r);
		 String nextSectionName = mainSection.read(reader);
		 String readManifestVersion = mainSection.getAttributeValue(ATTRIBUTE_MANIFEST_VERSION);
		 if (readManifestVersion != null) {
			 manifestVersion = readManifestVersion;
			 mainSection.removeAttribute(ATTRIBUTE_MANIFEST_VERSION);
		 }
		 String line = null;
		 while ((line = reader.readLine()) != null) {
			 if (line.length() == 0) {
				 continue;
			 }
			 Section section = new Section();
			 if (nextSectionName == null) {
				 Attribute sectionName = new Attribute(line);
				 if (!sectionName.getName().equalsIgnoreCase(ATTRIBUTE_NAME)) {
					 throw new ManifestException(""Manifest sections should "" + ""start with a \"""" + ATTRIBUTE_NAME + ""\"" attribute and not \"""" + sectionName.getName() + ""\"""");
				 }
				 nextSectionName = sectionName.getValue();
			 }
			 else {
				 Attribute firstAttribute = new Attribute(line);
				 section.addAttributeAndCheck(firstAttribute);
			 }
			 section.setName(nextSectionName);
			 nextSectionName = section.read(reader);
			 addConfiguredSection(section);
		 }
	 }
	 public void addConfiguredSection(Section section) throws ManifestException {
		 String sectionName = section.getName();
		 if (sectionName == null) {
			 throw new BuildException(""Sections must have a name"");
		 }
		 sections.put(sectionName, section);
		 if (!sectionIndex.contains(sectionName)) {
			 sectionIndex.addElement(sectionName);
		 }
	 }
	 public void addConfiguredAttribute(Attribute attribute) throws ManifestException {
		 if (attribute.getKey() == null || attribute.getValue() == null) {
			 throw new BuildException(""Attributes must have name and value"");
		 }
		 if (attribute.getKey().equalsIgnoreCase(ATTRIBUTE_MANIFEST_VERSION)) {
			 manifestVersion = attribute.getValue();
		 }
		 else {
			 mainSection.addConfiguredAttribute(attribute);
		 }
	 }
	 public void merge(Manifest other) throws ManifestException {
		 merge(other, false);
	 }
	 public void merge(Manifest other, boolean overwriteMain) throws ManifestException {
		 if (other != null) {
			 if (overwriteMain) {
				 mainSection = (Section) other.mainSection.clone();
			 }
			 else {
				 mainSection.merge(other.mainSection);
			 }
			 if (other.manifestVersion != null) {
				 manifestVersion = other.manifestVersion;
			 }
			 Enumeration e = other.getSectionNames();
			 while (e.hasMoreElements()) {
				 String sectionName = (String) e.nextElement();
				 Section ourSection = (Section) sections.get(sectionName);
				 Section otherSection = (Section) other.sections.get(sectionName);
				 if (ourSection == null) {
					 if (otherSection != null) {
						 addConfiguredSection((Section) otherSection.clone());
					 }
				 }
				 else {
					 ourSection.merge(otherSection);
				 }
			 }
		 }
	 }
	 public void write(PrintWriter writer) throws IOException {
		 writer.print(ATTRIBUTE_MANIFEST_VERSION + "": "" + manifestVersion + EOL);
		 String signatureVersion = mainSection.getAttributeValue(ATTRIBUTE_SIGNATURE_VERSION);
		 if (signatureVersion != null) {
			 writer.print(ATTRIBUTE_SIGNATURE_VERSION + "": "" + signatureVersion + EOL);
			 mainSection.removeAttribute(ATTRIBUTE_SIGNATURE_VERSION);
		 }
		 mainSection.write(writer);
		 if (signatureVersion != null) {
			 try {
				 Attribute svAttr = new Attribute(ATTRIBUTE_SIGNATURE_VERSION, signatureVersion);
				 mainSection.addConfiguredAttribute(svAttr);
			 }
			 catch (ManifestException e) {
			 }
		 }
		 Enumeration e = sectionIndex.elements();
		 while (e.hasMoreElements()) {
			 String sectionName = (String) e.nextElement();
			 Section section = getSection(sectionName);
			 section.write(writer);
		 }
	 }
	 public String toString() {
		 StringWriter sw = new StringWriter();
		 try {
			 write(new PrintWriter(sw));
		 }
		 catch (IOException e) {
			 return null;
		 }
		 return sw.toString();
	 }
	 public Enumeration getWarnings() {
		 Vector warnings = new Vector();
		 Enumeration warnEnum = mainSection.getWarnings();
		 while (warnEnum.hasMoreElements()) {
			 warnings.addElement(warnEnum.nextElement());
		 }
		 Enumeration e = sections.elements();
		 while (e.hasMoreElements()) {
			 Section section = (Section) e.nextElement();
			 Enumeration e2 = section.getWarnings();
			 while (e2.hasMoreElements()) {
				 warnings.addElement(e2.nextElement());
			 }
		 }
		 return warnings.elements();
	 }
	 public int hashCode() {
		 int hashCode = 0;
		 if (manifestVersion != null) {
			 hashCode += manifestVersion.hashCode();
		 }
		 hashCode += mainSection.hashCode();
		 hashCode += sections.hashCode();
		 return hashCode;
	 }
	 public boolean equals(Object rhs) {
		 if (rhs == null || rhs.getClass() != getClass()) {
			 return false;
		 }
		 if (rhs == this) {
			 return true;
		 }
		 Manifest rhsManifest = (Manifest) rhs;
		 if (manifestVersion == null) {
			 if (rhsManifest.manifestVersion != null) {
				 return false;
			 }
		 }
		 else if (!manifestVersion.equals(rhsManifest.manifestVersion)) {
			 return false;
		 }
		 if (!mainSection.equals(rhsManifest.mainSection)) {
			 return false;
		 }
		 return sections.equals(rhsManifest.sections);
	 }
	 public String getManifestVersion() {
		 return manifestVersion;
	 }
	 public Section getMainSection() {
		 return mainSection;
	 }
	 public Section getSection(String name) {
		 return (Section) sections.get(name);
	 }
	 public Enumeration getSectionNames() {
		 return sectionIndex.elements();
	 }
}",0,0,0,0
"private static final class XdrInputFormat extends PInputStream {
	 private static final int READ_BUFFER_SIZE = 32 * 1024;
	 private final class Buffer {
		 private final byte[] buf;
		 private int size;
		 private int offset;
		 Buffer(byte[] buf) {
			 this.buf = buf;
		 }
		 int readInt() {
			 return ((buf[offset++] & 0xff) << 24 | (buf[offset++] & 0xff) << 16 | (buf[offset++] & 0xff) << 8 | (buf[offset++] & 0xff));
		 }
		 double readDouble() {
			 long val = ((long) (buf[offset++] & 0xff) << 56 | (long) (buf[offset++] & 0xff) << 48 | (long) (buf[offset++] & 0xff) << 40 | (long) (buf[offset++] & 0xff) << 32 | (long) (buf[offset++] & 0xff) << 24 | (long) (buf[offset++] & 0xff) << 16 | (long) (buf[offset++] & 0xff) << 8 | buf[offset++] & 0xff);
			 return Double.longBitsToDouble(val);
		 }
		 String readString(int len) {
			 boolean fastEncode = true;
			 for (int i = 0;
			 i < len;
			 i++) {
				 byte b = buf[offset + i];
				 if (b < 0) {
					 fastEncode = false;
					 break;
				 }
			 }
			 String result;
			 if (fastEncode) {
				 result = new String(buf, 0, offset, len);
			 }
			 else {
				 result = new String(buf, offset, len, StandardCharsets.UTF_8);
			 }
			 offset += len;
			 WeakReference<String> entry;
			 if ((entry = strings.get(result)) != null) {
				 String string = entry.get();
				 if (string != null) {
					 return string;
				 }
			 }
			 strings.put(result, new WeakReference<>(result));
			 return result;
		 }
		 void readRaw(byte[] data) {
			 System.arraycopy(buf, offset, data, 0, data.length);
			 offset += data.length;
		 }
		 void readData(int n) throws IOException {
			 if (offset + n > size) {
				 if (offset != size) {
					 System.arraycopy(buf, offset, buf, 0, size - offset);
				 }
				 size -= offset;
				 offset = 0;
				 while (size < n) {
					 int nread = is.read(buf, size, buf.length - size);
					 if (nread <= 0) {
						 throw RInternalError.unimplemented(""handle unexpected eof"");
					 }
					 size += nread;
				 }
			 }
		 }
	 }
	 private final Buffer defaultBuffer;
	 private final WeakHashMap<String, WeakReference<String>> strings = RContext.getInstance().stringMap;
	 XdrInputFormat(InputStream is) {
		 super(is);
		 if (is instanceof PByteArrayInputStream) {
			 PByteArrayInputStream pbis = (PByteArrayInputStream) is;
			 defaultBuffer = new Buffer(pbis.getData());
			 defaultBuffer.size = pbis.getData().length;
			 defaultBuffer.offset = pbis.pos();
		 }
		 else {
			 defaultBuffer = new Buffer(new byte[READ_BUFFER_SIZE]);
			 defaultBuffer.size = 0;
			 defaultBuffer.offset = 0;
		 }
	 }
	 int readInt() throws IOException {
		 return ensureData(4).readInt();
	 }
	 double readDouble() throws IOException {
		 return ensureData(8).readDouble();
	 }
	 String readString(int len) throws IOException {
		 return ensureData(len).readString(len);
	 }
	 void readRaw(byte[] data) throws IOException {
		 ensureData(data.length).readRaw(data);
	 }
	 private Buffer ensureData(int n) throws IOException {
		 Buffer usedBuffer;
		 if (n > defaultBuffer.buf.length) {
			 if (is instanceof PByteArrayInputStream) {
				 throw new IOException(""Premature EOF"");
			 }
			 byte[] enlargedBuf = new byte[n];
			 System.arraycopy(defaultBuffer.buf, defaultBuffer.offset, enlargedBuf, defaultBuffer.offset, defaultBuffer.size - defaultBuffer.offset);
			 usedBuffer = new Buffer(enlargedBuf);
			 usedBuffer.offset = defaultBuffer.offset;
			 usedBuffer.size = defaultBuffer.size;
			 defaultBuffer.offset = defaultBuffer.size = 0;
			 usedBuffer.readData(n);
			 assert usedBuffer.size == n;
		 }
		 else {
			 usedBuffer = defaultBuffer;
			 usedBuffer.readData(n);
		 }
		 return usedBuffer;
	 }
 }",1,0,0,0
"public class RestLiServiceException extends RuntimeException{
	 private static final long serialVersionUID = 1L;
	 private final HttpStatus _status;
	 private Integer _serviceErrorCode;
	 private DataMap _errorDetails;
	 private ErrorResponseFormat _errorResponseFormat;
	 public RestLiServiceException(final HttpStatus status) {
		 this(status, null, null);
	 }
	 public RestLiServiceException(final HttpStatus status, final String message) {
		 this(status, message, null);
	 }
	 public RestLiServiceException(final HttpStatus status, final Throwable cause) {
		 super(cause);
		 _status = status;
	 }
	 public RestLiServiceException(final HttpStatus status, final String message, final Throwable cause) {
		 super(message, cause);
		 _status = status;
	 }
	 public RestLiServiceException(final HttpStatus status, final String message, final Throwable cause, boolean writableStackTrace) {
		 super(message, cause, true, writableStackTrace);
		 _status = status;
	 }
	 public HttpStatus getStatus() {
		 return _status;
	 }
	 public RestLiServiceException setServiceErrorCode(final Integer serviceErrorCode) {
		 _serviceErrorCode = serviceErrorCode;
		 return this;
	 }
	 public boolean hasServiceErrorCode() {
		 return _serviceErrorCode != null;
	 }
	 public Integer getServiceErrorCode() {
		 return _serviceErrorCode;
	 }
	 public DataMap getErrorDetails() {
		 return _errorDetails;
	 }
	 public boolean hasErrorDetails() {
		 return _errorDetails != null;
	 }
	 public RestLiServiceException setErrorDetails(final DataMap errorDetails) {
		 _errorDetails = errorDetails;
		 return this;
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 sb.append(getClass().getName());
		 sb.append("" [HTTP Status:"").append(_status.getCode());
		 if (_serviceErrorCode != null) {
			 sb.append("", serviceErrorCode:"").append(_serviceErrorCode);
		 }
		 sb.append(""]"");
		 String message = getLocalizedMessage();
		 if (message != null) {
			 sb.append("": "").append(message);
		 }
		 return sb.toString();
	 }
	 public void setOverridingFormat(ErrorResponseFormat errorResponseFormat) {
		 _errorResponseFormat = errorResponseFormat;
	 }
	 public boolean hasOverridingErrorResponseFormat() {
		 return _errorResponseFormat != null;
	 }
	 public ErrorResponseFormat getOverridingFormat() {
		 return _errorResponseFormat;
	 }
	 public static RestLiServiceException fromThrowable(Throwable throwable) {
		 RestLiServiceException restLiServiceException;
		 if (throwable instanceof RestLiServiceException) {
			 restLiServiceException = (RestLiServiceException) throwable;
		 }
		 else if (throwable instanceof RoutingException) {
			 RoutingException routingException = (RoutingException) throwable;
			 restLiServiceException = new RestLiServiceException(HttpStatus.fromCode(routingException.getStatus()), routingException.getMessage(), routingException);
		 }
		 else {
			 restLiServiceException = new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, throwable.getMessage(), throwable);
		 }
		 return restLiServiceException;
	 }
}",0,0,0,0
"class DefaultErrorReporter implements ErrorReporter{
	 static final DefaultErrorReporter instance = new DefaultErrorReporter();
	 private boolean forEval;
	 private ErrorReporter chainedReporter;
	 private DefaultErrorReporter() {
	 }
	 static ErrorReporter forEval(ErrorReporter reporter) {
		 DefaultErrorReporter r = new DefaultErrorReporter();
		 r.forEval = true;
		 r.chainedReporter = reporter;
		 return r;
	 }
	 public void warning(String message, String sourceURI, int line, String lineText, int lineOffset) {
		 if (chainedReporter != null) {
			 chainedReporter.warning( message, sourceURI, line, lineText, lineOffset);
		 }
		 else {
		 }
	 }
	 public void error(String message, String sourceURI, int line, String lineText, int lineOffset) {
		 if (forEval) {
			 throw ScriptRuntime.constructError( ""SyntaxError"", message, sourceURI, line, lineText, lineOffset);
		 }
		 if (chainedReporter != null) {
			 chainedReporter.error( message, sourceURI, line, lineText, lineOffset);
		 }
		 else {
			 throw runtimeError( message, sourceURI, line, lineText, lineOffset);
		 }
	 }
	 public EvaluatorException runtimeError(String message, String sourceURI, int line, String lineText, int lineOffset) {
		 if (chainedReporter != null) {
			 return chainedReporter.runtimeError( message, sourceURI, line, lineText, lineOffset);
		 }
		 else {
			 return new EvaluatorException( message, sourceURI, line, lineText, lineOffset);
		 }
	 }
}",0,0,0,0
"public abstract class AbstractDeadLetterStrategy implements DeadLetterStrategy {
	 private static final Logger LOG = LoggerFactory.getLogger(AbstractDeadLetterStrategy.class);
	 private boolean processNonPersistent = false;
	 private boolean processExpired = true;
	 private boolean enableAudit = true;
	 private final ActiveMQMessageAudit messageAudit = new ActiveMQMessageAudit();
	 private long expiration;
	 public void rollback(Message message) {
		 if (message != null && this.enableAudit) {
			 messageAudit.rollback(message);
		 }
	 }
	 public boolean isSendToDeadLetterQueue(Message message) {
		 boolean result = false;
		 if (message != null) {
			 result = true;
			 if (enableAudit && messageAudit.isDuplicate(message)) {
				 result = false;
				 LOG.debug(""Not adding duplicate to DLQ: {
				}
				, dest: {
				}
				"", message.getMessageId(), message.getDestination());
			 }
			 if (!message.isPersistent() && !processNonPersistent) {
				 result = false;
			 }
			 if (message.isExpired() && !processExpired) {
				 result = false;
			 }
		 }
		 return result;
	 }
	 public boolean isProcessExpired() {
		 return this.processExpired;
	 }
	 public void setProcessExpired(boolean processExpired) {
		 this.processExpired = processExpired;
	 }
	 public boolean isProcessNonPersistent() {
		 return this.processNonPersistent;
	 }
	 public void setProcessNonPersistent(boolean processNonPersistent) {
		 this.processNonPersistent = processNonPersistent;
	 }
	 public boolean isEnableAudit() {
		 return enableAudit;
	 }
	 public void setEnableAudit(boolean enableAudit) {
		 this.enableAudit = enableAudit;
	 }
	 public long getExpiration() {
		 return expiration;
	 }
	 public void setExpiration(long expiration) {
		 this.expiration = expiration;
	 }
	 public int getMaxProducersToAudit() {
		 return messageAudit.getMaximumNumberOfProducersToTrack();
	 }
	 public void setMaxProducersToAudit(int maxProducersToAudit) {
		 messageAudit.setMaximumNumberOfProducersToTrack(maxProducersToAudit);
	 }
	 public void setMaxAuditDepth(int maxAuditDepth) {
		 messageAudit.setAuditDepth(maxAuditDepth);
	 }
	 public int getMaxAuditDepth() {
		 return messageAudit.getAuditDepth();
	 }
}",0,1,0,0
"public int hashCode() {
	 int hash = 37;
	 if ( baseDn != null ) {
		 hash = hash * 17 + baseDn.hashCode();
	 }
	 hash = hash * 17 + aliasDerefMode.hashCode();
	 hash = hash * 17 + scope.hashCode();
	 hash = hash * 17 + Long.valueOf( sizeLimit ).hashCode();
	 hash = hash * 17 + timeLimit;
	 hash = hash * 17 + ( typesOnly ? 0 : 1 );
	 if ( attributes != null ) {
		 hash = hash * 17 + attributes.size();
		 for ( String attr : attributes ) {
			 if ( attr != null ) {
				 hash = hash + attr.hashCode();
			 }
		 }
	 }
	 BranchNormalizedVisitor visitor = new BranchNormalizedVisitor();
	 filterNode.accept( visitor );
	 hash = hash * 17 + filterNode.toString().hashCode();
	 hash = hash * 17 + super.hashCode();
	 return hash;
 }",0,0,1,0
"public class SSTableScanner implements CloseableIterator<IColumnIterator>{
	 private static Logger logger = LoggerFactory.getLogger(SSTableScanner.class);
	 protected final RandomAccessReader file;
	 public final SSTableReader sstable;
	 private IColumnIterator row;
	 protected boolean exhausted = false;
	 protected Iterator<IColumnIterator> iterator;
	 private QueryFilter filter;
	 SSTableScanner(SSTableReader sstable, boolean skipCache) {
		 try {
			 this.file = sstable.openDataReader(skipCache);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 this.sstable = sstable;
	 }
	 SSTableScanner(SSTableReader sstable, QueryFilter filter) {
		 try {
			 this.file = sstable.openDataReader(false);
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 this.sstable = sstable;
		 this.filter = filter;
	 }
	 public void close() throws IOException {
		 file.close();
	 }
	 public void seekTo(RowPosition seekKey) {
		 try {
			 long position = sstable.getPosition(seekKey, SSTableReader.Operator.GE);
			 if (position < 0) {
				 exhausted = true;
				 return;
			 }
			 file.seek(position);
			 row = null;
		 }
		 catch (IOException e) {
			 throw new RuntimeException(""corrupt sstable"", e);
		 }
	 }
	 public long getFileLength() {
		 try {
			 return file.length();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
	 }
	 public long getFilePointer() {
		 return file.getFilePointer();
	 }
	 public boolean hasNext() {
		 if (iterator == null) iterator = exhausted ? Arrays.asList(new IColumnIterator[0]).iterator() : new KeyScanningIterator();
		 return iterator.hasNext();
	 }
	 public IColumnIterator next() {
		 if (iterator == null) iterator = exhausted ? Arrays.asList(new IColumnIterator[0]).iterator() : new KeyScanningIterator();
		 return iterator.next();
	 }
	 public void remove() {
		 throw new UnsupportedOperationException();
	 }
	 protected class KeyScanningIterator implements Iterator<IColumnIterator> {
		 protected long finishedAt;
		 public boolean hasNext() {
			 try {
				 if (row == null) return !file.isEOF();
				 return finishedAt < file.length();
			 }
			 catch (IOException e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public IColumnIterator next() {
			 try {
				 if (row != null) file.seek(finishedAt);
				 assert !file.isEOF();
				 DecoratedKey<?> key = SSTableReader.decodeKey(sstable.partitioner, sstable.descriptor, ByteBufferUtil.readWithShortLength(file));
				 long dataSize = SSTableReader.readRowSize(file, sstable.descriptor);
				 long dataStart = file.getFilePointer();
				 finishedAt = dataStart + dataSize;
				 if (filter == null) {
					 row = new SSTableIdentityIterator(sstable, file, key, dataStart, dataSize);
					 return row;
				 }
				 else {
					 return row = filter.getSSTableColumnIterator(sstable, file, key);
				 }
			 }
			 catch (IOException e) {
				 throw new RuntimeException(SSTableScanner.this + "" failed to provide next columns from "" + this, e);
			 }
		 }
		 public void remove() {
			 throw new UnsupportedOperationException();
		 }
		 public String toString() {
			 return getClass().getSimpleName() + ""("" + ""finishedAt:"" + finishedAt + "")"";
		 }
	}
	 public String toString() {
		 return getClass().getSimpleName() + ""("" + ""file="" + file + "" sstable="" + sstable + "" exhausted="" + exhausted + "")"";
	 }
}",0,0,0,0
"public AuthenticationKey(int keyId, long expirationDate, SecretKey key) {
	 this.id = keyId;
	 this.expirationDate = expirationDate;
	 this.secret = key;
 }",0,0,0,0
"public class RedirectorElement extends DataType {
	 private boolean usingInput = false;
	 private boolean usingOutput = false;
	 private boolean usingError = false;
	 private Boolean logError;
	 private String outputProperty;
	 private String errorProperty;
	 private String inputString;
	 private Boolean append;
	 private Boolean alwaysLog;
	 private Boolean createEmptyFiles;
	 private Mapper inputMapper;
	 private Mapper outputMapper;
	 private Mapper errorMapper;
	 private Vector inputFilterChains = new Vector();
	 private Vector outputFilterChains = new Vector();
	 private Vector errorFilterChains = new Vector();
	 private String outputEncoding;
	 private String errorEncoding;
	 private String inputEncoding;
	 private Boolean logInputString;
	 public void addConfiguredInputMapper(Mapper inputMapper) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (this.inputMapper != null) {
			 if (usingInput) {
				 throw new BuildException(""attribute \""input\"""" + "" cannot coexist with a nested <inputmapper>"");
			 }
			 else {
				 throw new BuildException(""Cannot have > 1 <inputmapper>"");
			 }
		 }
		 this.inputMapper = inputMapper;
	 }
	 public void addConfiguredOutputMapper(Mapper outputMapper) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (this.outputMapper != null) {
			 if (usingOutput) {
				 throw new BuildException(""attribute \""output\"""" + "" cannot coexist with a nested <outputmapper>"");
			 }
			 else {
				 throw new BuildException(""Cannot have > 1 <outputmapper>"");
			 }
		 }
		 this.outputMapper = outputMapper;
	 }
	 public void addConfiguredErrorMapper(Mapper errorMapper) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 if (this.errorMapper != null) {
			 if (usingError) {
				 throw new BuildException(""attribute \""error\"""" + "" cannot coexist with a nested <errormapper>"");
			 }
			 else {
				 throw new BuildException(""Cannot have > 1 <errormapper>"");
			 }
		 }
		 this.errorMapper = errorMapper;
	 }
	 public void setRefid(Reference r) throws BuildException {
		 if (usingInput || usingOutput || usingError || inputString != null || logError != null || append != null || createEmptyFiles != null || inputEncoding != null || outputEncoding != null || errorEncoding != null || outputProperty != null || errorProperty != null || logInputString != null) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 public void setInput(File input) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (inputString != null) {
			 throw new BuildException(""The \""input\"" and \""inputstring\"" "" + ""attributes cannot both be specified"");
		 }
		 usingInput = true;
		 inputMapper = createMergeMapper(input);
	 }
	 public void setInputString(String inputString) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (usingInput) {
			 throw new BuildException(""The \""input\"" and \""inputstring\"" "" + ""attributes cannot both be specified"");
		 }
		 this.inputString = inputString;
	 }
	 public void setLogInputString(boolean logInputString) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.logInputString = logInputString ? Boolean.TRUE : Boolean.FALSE;
	 }
	 public void setOutput(File out) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (out == null) {
			 throw new IllegalArgumentException(""output file specified as null"");
		 }
		 usingOutput = true;
		 outputMapper = createMergeMapper(out);
	 }
	 public void setOutputEncoding(String outputEncoding) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.outputEncoding = outputEncoding;
	 }
	 public void setErrorEncoding(String errorEncoding) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.errorEncoding = errorEncoding;
	 }
	 public void setInputEncoding(String inputEncoding) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.inputEncoding = inputEncoding;
	 }
	 public void setLogError(boolean logError) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.logError = ((logError) ? Boolean.TRUE : Boolean.FALSE);
	 }
	 public void setError(File error) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (error == null) {
			 throw new IllegalArgumentException(""error file specified as null"");
		 }
		 usingError = true;
		 errorMapper = createMergeMapper(error);
	 }
	 public void setOutputProperty(String outputProperty) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.outputProperty = outputProperty;
	 }
	 public void setAppend(boolean append) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.append = ((append) ? Boolean.TRUE : Boolean.FALSE);
	 }
	 public void setAlwaysLog(boolean alwaysLog) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.alwaysLog = ((alwaysLog) ? Boolean.TRUE : Boolean.FALSE);
	 }
	 public void setCreateEmptyFiles(boolean createEmptyFiles) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.createEmptyFiles = ((createEmptyFiles) ? Boolean.TRUE : Boolean.FALSE);
	 }
	 public void setErrorProperty(String errorProperty) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.errorProperty = errorProperty;
	 }
	 public FilterChain createInputFilterChain() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 FilterChain result = new FilterChain();
		 result.setProject(getProject());
		 inputFilterChains.add(result);
		 return result;
	 }
	 public FilterChain createOutputFilterChain() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 FilterChain result = new FilterChain();
		 result.setProject(getProject());
		 outputFilterChains.add(result);
		 return result;
	 }
	 public FilterChain createErrorFilterChain() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 FilterChain result = new FilterChain();
		 result.setProject(getProject());
		 errorFilterChains.add(result);
		 return result;
	 }
	 public void configure(Redirector redirector) {
		 configure(redirector, null);
	 }
	 public void configure(Redirector redirector, String sourcefile) {
		 if (isReference()) {
			 getRef().configure(redirector, sourcefile);
			 return;
		 }
		 if (alwaysLog != null) {
			 redirector.setAlwaysLog(alwaysLog.booleanValue());
		 }
		 if (logError != null) {
			 redirector.setLogError(logError.booleanValue());
		 }
		 if (append != null) {
			 redirector.setAppend(append.booleanValue());
		 }
		 if (createEmptyFiles != null) {
			 redirector.setCreateEmptyFiles(createEmptyFiles.booleanValue());
		 }
		 if (outputProperty != null) {
			 redirector.setOutputProperty(outputProperty);
		 }
		 if (errorProperty != null) {
			 redirector.setErrorProperty(errorProperty);
		 }
		 if (inputString != null) {
			 redirector.setInputString(inputString);
		 }
		 if (logInputString != null) {
			 redirector.setLogInputString(logInputString.booleanValue());
		 }
		 if (inputMapper != null) {
			 String[] inputTargets = null;
			 try {
				 inputTargets = inputMapper.getImplementation().mapFileName(sourcefile);
			 }
			 catch (NullPointerException enPeaEx) {
				 if (sourcefile != null) {
					 throw enPeaEx;
				 }
			 }
			 if (inputTargets != null && inputTargets.length > 0) {
				 redirector.setInput(toFileArray(inputTargets));
			 }
		 }
		 if (outputMapper != null) {
			 String[] outputTargets = null;
			 try {
				 outputTargets = outputMapper.getImplementation().mapFileName(sourcefile);
			 }
			 catch (NullPointerException enPeaEx) {
				 if (sourcefile != null) {
					 throw enPeaEx;
				 }
			 }
			 if (outputTargets != null && outputTargets.length > 0) {
				 redirector.setOutput(toFileArray(outputTargets));
			 }
		 }
		 if (errorMapper != null) {
			 String[] errorTargets = null;
			 try {
				 errorTargets = errorMapper.getImplementation().mapFileName(sourcefile);
			 }
			 catch (NullPointerException enPeaEx) {
				 if (sourcefile != null) {
					 throw enPeaEx;
				 }
			 }
			 if (errorTargets != null && errorTargets.length > 0) {
				 redirector.setError(toFileArray(errorTargets));
			 }
		 }
		 if (inputFilterChains.size() > 0) {
			 redirector.setInputFilterChains(inputFilterChains);
		 }
		 if (outputFilterChains.size() > 0) {
			 redirector.setOutputFilterChains(outputFilterChains);
		 }
		 if (errorFilterChains.size() > 0) {
			 redirector.setErrorFilterChains(errorFilterChains);
		 }
		 if (inputEncoding != null) {
			 redirector.setInputEncoding(inputEncoding);
		 }
		 if (outputEncoding != null) {
			 redirector.setOutputEncoding(outputEncoding);
		 }
		 if (errorEncoding != null) {
			 redirector.setErrorEncoding(errorEncoding);
		 }
	 }
	 protected Mapper createMergeMapper(File destfile) {
		 Mapper result = new Mapper(getProject());
		 result.setClassname( org.apache.tools.ant.util.MergingMapper.class.getName());
		 result.setTo(destfile.getAbsolutePath());
		 return result;
	 }
	 protected File[] toFileArray(String[] name) {
		 if (name == null) {
			 return null;
		 }
		 ArrayList list = new ArrayList(name.length);
		 for (int i = 0;
		 i < name.length;
		 i++) {
			 if (name[i] != null) {
				 list.add(getProject().resolveFile(name[i]));
			 }
		 }
		 return (File[]) (list.toArray(new File[list.size()]));
	 }
	 protected void dieOnCircularReference(Stack stk, Project p) throws BuildException {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 Mapper[] m = new Mapper[] {
			inputMapper, outputMapper, errorMapper}
			;
			 for (int i = 0;
			 i < m.length;
			 i++) {
				 if (m[i] != null) {
					 stk.push(m[i]);
					 m[i].dieOnCircularReference(stk, p);
					 stk.pop();
				 }
			 }
			 Vector[] v = new Vector[] {
			inputFilterChains, outputFilterChains, errorFilterChains}
			;
			 for (int i = 0;
			 i < v.length;
			 i++) {
				 if (v[i] != null) {
					 for (Iterator fci = v[i].iterator();
					 fci.hasNext();
					) {
						 FilterChain fc = (FilterChain) fci.next();
						 stk.push(fc);
						 fc.dieOnCircularReference(stk, p);
						 stk.pop();
					 }
				 }
			 }
			 setChecked(true);
		 }
	 }
	 private RedirectorElement getRef() {
		 return (RedirectorElement) getCheckedRef();
	 }
}",0,0,0,0
"protected byte[] generateRequestContent() {
	 try {
		 int currentChar = 'e';
		 final Map<String, Integer> nameSpaceMap = new HashMap<String, Integer>();
		 final Set<PropertyValue> setPropertyValues = new HashSet<PropertyValue>();
		 final Set<PropertyValue> deletePropertyValues = new HashSet<PropertyValue>();
		 for (PropertyValue propertyValue : propertyValues) {
			 if (!nameSpaceMap.containsKey(TYPE_NAMESPACE) && propertyValue.getTypeString() != null) {
				 nameSpaceMap.put(TYPE_NAMESPACE, currentChar++);
			 }
			 String namespaceUri = propertyValue.getNamespaceUri();
			 if (!nameSpaceMap.containsKey(namespaceUri)) {
				 nameSpaceMap.put(namespaceUri, currentChar++);
			 }
			 if (propertyValue.getXmlEncodedValue() == null) {
				 deletePropertyValues.add(propertyValue);
			 }
			 else {
				 setPropertyValues.add(propertyValue);
			 }
		 }
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 OutputStreamWriter writer = new OutputStreamWriter(baos, ""UTF-8"");
		 writer.write(""<D:propertyupdate xmlns:D=\""DAV:\"""");
		 for (Map.Entry<String, Integer> mapEntry : nameSpaceMap.entrySet()) {
			 writer.write("" xmlns:"");
			 writer.write((char) mapEntry.getValue().intValue());
			 writer.write(""=\"""");
			 writer.write(mapEntry.getKey());
			 writer.write(""\"""");
		 }
		 writer.write("">"");
		 if (!setPropertyValues.isEmpty()) {
			 writer.write(""<D:set><D:prop>"");
			 for (PropertyValue propertyValue : setPropertyValues) {
				 String typeString = propertyValue.getTypeString();
				 char nameSpaceChar = (char) nameSpaceMap.get(propertyValue.getNamespaceUri()).intValue();
				 writer.write('<');
				 writer.write(nameSpaceChar);
				 writer.write(':');
				 writer.write(propertyValue.getName());
				 if (typeString != null) {
					 writer.write(' ');
					 writer.write(nameSpaceMap.get(TYPE_NAMESPACE));
					 writer.write("":dt=\"""");
					 writer.write(typeString);
					 writer.write(""\"""");
				 }
				 writer.write('>');
				 writer.write(propertyValue.getXmlEncodedValue());
				 writer.write(""</"");
				 writer.write(nameSpaceChar);
				 writer.write(':');
				 writer.write(propertyValue.getName());
				 writer.write('>');
			 }
			 writer.write(""</D:prop></D:set>"");
		 }
		 if (!deletePropertyValues.isEmpty()) {
			 writer.write(""<D:remove><D:prop>"");
			 for (PropertyValue propertyValue : deletePropertyValues) {
				 char nameSpaceChar = (char) nameSpaceMap.get(propertyValue.getNamespaceUri()).intValue();
				 writer.write('<');
				 writer.write(nameSpaceChar);
				 writer.write(':');
				 writer.write(propertyValue.getName());
				 writer.write(""/>"");
			 }
			 writer.write(""</D:prop></D:remove>"");
		 }
		 writer.write(""</D:propertyupdate>"");
		 writer.close();
		 return baos.toByteArray();
	 }
	 catch (IOException e) {
		 throw new RuntimeException(e);
	 }
 }",0,0,1,0
"public void setProxyPassword(String proxyPassword) {
	 this.proxyPassword = proxyPassword;
 }",0,0,0,0
"Type asTuple() {
	 final Type result;
	 if (types.size() == 0) {
		 result = unit.getEmptyType();
	 }
	 else {
		 final Type sequentialType;
		 if (variadic) {
			 Part part = new Part(""Sequence"", Collections.singletonList(getLast()));
			 sequentialType = loadType(""ceylon.language"", atLeastOne ? ""ceylon.language.Sequence"" : ""ceylon.language.Sequential"", part, null);
		 }
		 else {
			 sequentialType = unit.getEmptyType();
		 }
		 if (variadic && types.size() == 1) {
			 result = sequentialType;
		 }
		 else {
			 Part part = new Part();
			 Type union = variadic ? getLast() : null;
			 Type tupleType = sequentialType;
			 int makeDefaulted = defaulted;
			 for (int ii = types.size()-(variadic? 2 : 1);
			 ii >= 0;
			 ii--) {
				 Type t = types.get(ii);
				 if(union != null) union = ModelUtil.unionType(union, t, unit);
				 else union = t;
				 part.parameters = Arrays.asList(union, t, tupleType);
				 part.name = ""Tuple"";
				 tupleType = loadType(""ceylon.language"", ""ceylon.language.Tuple"", part, null);
				 if(makeDefaulted > 0){
					 makeDefaulted--;
					 tupleType = union(Arrays.asList(unit.getEmptyType(), tupleType), unit);
				 }
			 }
			 result = tupleType;
		 }
	 }
	 return result;
 }",0,0,1,0
"private void getSuggestions(final String query) {
	if (query == null || query.isEmpty()) {
		return;
	}
	locatorParams(SUGGEST_PLACE);
	mLocator.addDoneLoadingListener(new Runnable() {
		 public void run() {
			if (mLocator.getLoadStatus().name() != LoadStatus.LOADED.name()){
			}
			 else if (!mLocator.getLocatorInfo().isSupportsSuggestions()){
				return;
			}
			final ListenableFuture<List<SuggestResult>> suggestionsFuture = mLocator.suggestAsync(query, suggestParams);
			suggestionsFuture.addDoneListener(new Runnable() {
				public void run() {
					try {
						mSuggestionsList = suggestionsFuture.get();
						showSuggestedPlaceNames(mSuggestionsList);
					}
					 catch (Exception e) {
						Log.e(TAG, ""Error on getting suggestions "" + e.getMessage());
					}
				}
			}
			);
		}
	}
	);
	mLocator.loadAsync();
}",0,0,1,0
"public static void purge(CFMetaData cfm) {
	 cfIdMap.remove(new Pair<String, String>(cfm.tableName, cfm.cfName));
 }",0,0,0,0
"private int createEndH() {
	 int color;
	 int black = 0;
	 int endH = 0;
	 loop: for (int i = height - 1;
	 i >= 0;
	 i--) {
		 for (int j = width - 1;
		 j >= 0;
		 j--) {
			 color = new Color(originalImage.getRGB(j, i)).getRed();
			 if (color == black) {
				 endH = i;
				 break loop;
			 }
		 }
	 }
	 return endH;
 }",0,0,0,0
"public final class OptionalMetaPattern extends MetaPattern{
	private static final long serialVersionUID = 1L;
	public OptionalMetaPattern(final String pattern){
		super(pattern);
	}
	public OptionalMetaPattern(final MetaPattern pattern){
		super(pattern);
	}
	public OptionalMetaPattern(final List<MetaPattern> patterns){
		super(patterns);
	}
	public OptionalMetaPattern(final MetaPattern[] patterns){
		super(patterns);
	}
	public String toString(){
		return ""(?:"" + super.toString() + "")?"";
	}
}",0,0,0,0
"public class ReadableSelector implements FileSelector, ResourceSelector {
	 public boolean isSelected(File basedir, String filename, File file) {
		 return file != null && file.canRead();
	 }
	 public boolean isSelected(Resource r) {
		 FileProvider fp = (FileProvider) r.as(FileProvider.class);
		 if (fp != null) {
			 return isSelected(null, null, fp.getFile());
		 }
		 return false;
	 }
}",0,0,0,0
"public class GoIntoAction extends ProjectAction {
	 private final ProjectExplorerPresenter projectExplorer;
	 private final CoreLocalizationConstant localizationConstant;
	 public GoIntoAction( ProjectExplorerPresenter projectExplorer, CoreLocalizationConstant localizationConstant) {
		 super(localizationConstant.goIntoActionText());
		 this.projectExplorer = projectExplorer;
		 this.localizationConstant = localizationConstant;
	 }
	 protected void updateProjectAction(ActionEvent e) {
		 if (projectExplorer.isGoIntoActivated()) {
			 e.getPresentation().setText(localizationConstant.goBackActionText());
			 e.getPresentation().setEnabledAndVisible(true);
			 return;
		 }
		 e.getPresentation().setText(localizationConstant.goIntoActionText());
		 List<?> selection = projectExplorer.getSelection().getAllElements();
		 e.getPresentation() .setEnabledAndVisible( !projectExplorer.isGoIntoActivated() && selection.size() == 1 && isNodeSupportGoInto(selection.get(0)));
	 }
	 public void actionPerformed(ActionEvent e) {
		 if (projectExplorer.isGoIntoActivated()) {
			 projectExplorer.goBack();
			 return;
		 }
		 List<?> selection = projectExplorer.getSelection().getAllElements();
		 if (selection.isEmpty() || selection.size() > 1) {
			 throw new IllegalArgumentException(""Node isn't selected"");
		 }
		 Object node = selection.get(0);
		 if (isNodeSupportGoInto(node)) {
			 projectExplorer.goInto((Node) node);
		 }
	 }
	 private boolean isNodeSupportGoInto(Object node) {
		 return node instanceof Node && ((Node) node).supportGoInto();
	 }
}",1,0,0,0
"public class FSDataOutputStream extends DataOutputStream {
	 public static final byte[] CHECKSUM_VERSION = new byte[] {
	'c', 'r', 'c', 0}
	;
	 private static class Summer extends FilterOutputStream {
		 private FSDataOutputStream sums;
		 private Checksum sum = new CRC32();
		 private int inSum;
		 private int bytesPerSum;
		 public Summer(FileSystem fs, Path file, boolean overwrite, short replication, Configuration conf) throws IOException {
			 super(fs.createRaw(file, overwrite, replication));
			 this.bytesPerSum = conf.getInt(""io.bytes.per.checksum"", 512);
			 this.sums = new FSDataOutputStream( fs.createRaw(FileSystem.getChecksumFile(file), true, replication), conf);
			 sums.write(CHECKSUM_VERSION, 0, CHECKSUM_VERSION.length);
			 sums.writeInt(this.bytesPerSum);
		 }
		 public void write(byte b[], int off, int len) throws IOException {
			 int summed = 0;
			 while (summed < len) {
				 int goal = this.bytesPerSum - inSum;
				 int inBuf = len - summed;
				 int toSum = inBuf <= goal ? inBuf : goal;
				 sum.update(b, off+summed, toSum);
				 summed += toSum;
				 inSum += toSum;
				 if (inSum == this.bytesPerSum) {
					 writeSum();
				 }
			 }
			 out.write(b, off, len);
		 }
		 private void writeSum() throws IOException {
			 if (inSum != 0) {
				 sums.writeInt((int)sum.getValue());
				 sum.reset();
				 inSum = 0;
			 }
		 }
		 public void close() throws IOException {
			 writeSum();
			 sums.close();
			 super.close();
		 }
	 }
	 private static class PositionCache extends FilterOutputStream {
		 long position;
		 public PositionCache(OutputStream out) throws IOException {
			 super(out);
		 }
		 public void write(byte b[], int off, int len) throws IOException {
			 out.write(b, off, len);
			 position += len;
		 }
		 public long getPos() throws IOException {
			 return position;
		 }
	 }
	 private static class Buffer extends BufferedOutputStream {
		 public Buffer(OutputStream out, int bufferSize) throws IOException {
			 super(out, bufferSize);
		 }
		 public long getPos() throws IOException {
			 return ((PositionCache)out).getPos() + this.count;
		 }
		 public void write(int b) throws IOException {
			 if (count >= buf.length) {
				 super.write(b);
			 }
			 else {
				 buf[count++] = (byte)b;
			 }
		 }
	 }
	 public FSDataOutputStream(FileSystem fs, Path file, boolean overwrite, Configuration conf, int bufferSize, short replication ) throws IOException {
		 super(new Buffer( new PositionCache( new Summer(fs, file, overwrite, replication, conf)), bufferSize));
	 }
	 private FSDataOutputStream(FSOutputStream out, Configuration conf) throws IOException {
		 this(out, conf.getInt(""io.file.buffer.size"", 4096));
	 }
	 private FSDataOutputStream(FSOutputStream out, int bufferSize) throws IOException {
		 super(new Buffer(new PositionCache(out), bufferSize));
	 }
	 public long getPos() throws IOException {
		 return ((Buffer)out).getPos();
	 }
}",0,0,0,0
"public interface BundleListener extends EventListener {
	public abstract void bundleChanged(final BundleEvent event);
}",0,0,0,0
"private void createImagesWithLetters() {
	 int cropWidth = letterInformation.getCropWidth();
	 int cropHeight = letterInformation.getCropHeight();
	 int tmpWidth = 3 * cropWidth;
	 int tmpHeight = 3 * cropHeight;
	 int trashSize = letterInformation.getTrashSize();
	 OCRExtractLetter extractionLetter = new OCRExtractLetter(tmpWidth, tmpHeight, trashSize);
	 int letterSize = letterInformation.getLetterSize();
	 int imageHeight = image.getHeight();
	 int imageWidth = image.getWidth();
	 boolean[][] visited = new boolean[imageHeight][imageWidth];
	 Color white = Color.WHITE;
	 Color color;
	 int seqNum = 0;
	 for (int line = 0;
	 line < textInformation.numberOfRows();
	 line++) {
		 for (int j = 0;
		 j < imageWidth;
		 j++) {
			 for (int k = -(letterSize / 4);
			 k < (letterSize / 4);
			 k++) {
				 int rowPixel = textInformation.getRowAt(line);
				 int i = rowPixel + k;
				 if (i < 0 || i >= imageHeight) {
					 continue;
				 }
				 color = new Color(image.getRGB(j, i));
				 if (color.equals(white)) {
					 visited[i][j] = true;
				 }
				 else if (visited[i][j] == false) {
					 BufferedImage letter = extractionLetter.extraxtLetter(image, visited, i, j);
					 if (letter != null) {
						 OCRCropLetter crop = new OCRCropLetter(letter, cropWidth, cropHeight);
						 BufferedImage croped = crop.processImage();
						 String character = trainingText.charAt(seqNum) + """";
						 String name = character + ""_"" + seqNum;
						 OCRUtilities.saveToFile(croped, folderPath, name, imageExtension);
						 seqNum++;
					 }
				 }
			 }
		 }
	 }
 }",0,0,1,0
"public class Interpreter{
	 private static final int Icode_DUP = -1, Icode_DUP2 = -2, Icode_SWAP = -3, Icode_POP = -4, Icode_POP_RESULT = -5, Icode_IFEQ_POP = -6, Icode_VAR_INC_DEC = -7, Icode_NAME_INC_DEC = -8, Icode_PROP_INC_DEC = -9, Icode_ELEM_INC_DEC = -10, Icode_REF_INC_DEC = -11, Icode_SCOPE_LOAD = -12, Icode_SCOPE_SAVE = -13, Icode_TYPEOFNAME = -14, Icode_NAME_AND_THIS = -15, Icode_PROP_AND_THIS = -16, Icode_ELEM_AND_THIS = -17, Icode_VALUE_AND_THIS = -18, Icode_CLOSURE_EXPR = -19, Icode_CLOSURE_STMT = -20, Icode_CALLSPECIAL = -21, Icode_RETUNDEF = -22, Icode_GOSUB = -23, Icode_STARTSUB = -24, Icode_RETSUB = -25, Icode_LINE = -26, Icode_SHORTNUMBER = -27, Icode_INTNUMBER = -28, Icode_LITERAL_NEW = -29, Icode_LITERAL_SET = -30, Icode_SPARE_ARRAYLIT = -31, Icode_REG_IND_C0 = -32, Icode_REG_IND_C1 = -33, Icode_REG_IND_C2 = -34, Icode_REG_IND_C3 = -35, Icode_REG_IND_C4 = -36, Icode_REG_IND_C5 = -37, Icode_REG_IND1 = -38, Icode_REG_IND2 = -39, Icode_REG_IND4 = -40, Icode_REG_STR_C0 = -41, Icode_REG_STR_C1 = -42, Icode_REG_STR_C2 = -43, Icode_REG_STR_C3 = -44, Icode_REG_STR1 = -45, Icode_REG_STR2 = -46, Icode_REG_STR4 = -47, Icode_GETVAR1 = -48, Icode_SETVAR1 = -49, Icode_UNDEF = -50, Icode_ZERO = -51, Icode_ONE = -52, Icode_ENTERDQ = -53, Icode_LEAVEDQ = -54, Icode_TAIL_CALL = -55, Icode_LOCAL_CLEAR = -56, MIN_ICODE = -56;
	 private CompilerEnvirons compilerEnv;
	 private boolean itsInFunctionFlag;
	 private InterpreterData itsData;
	 private ScriptOrFnNode scriptOrFn;
	 private int itsICodeTop;
	 private int itsStackDepth;
	 private int itsLineNumber;
	 private int itsDoubleTableTop;
	 private ObjToIntMap itsStrings = new ObjToIntMap(20);
	 private int itsLocalTop;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsLiteralIds = new ObjArray();
	 private int itsExceptionTableTop;
	 private static final int EXCEPTION_TRY_START_SLOT = 0;
	 private static final int EXCEPTION_TRY_END_SLOT = 1;
	 private static final int EXCEPTION_HANDLER_SLOT = 2;
	 private static final int EXCEPTION_TYPE_SLOT = 3;
	 private static final int EXCEPTION_LOCAL_SLOT = 4;
	 private static final int EXCEPTION_SCOPE_SLOT = 5;
	 private static final int EXCEPTION_SLOT_SIZE = 6;
	 private static final int ECF_TAIL = 1 << 0;
	 private static class CallFrame implements Cloneable, Serializable {
		 static final long serialVersionUID = -2843792508994958978L;
		 CallFrame parentFrame;
		 int frameIndex;
		 boolean frozen;
		 InterpretedFunction fnOrScript;
		 InterpreterData idata;
		 Object[] stack;
		 double[] sDbl;
		 CallFrame varSource;
		 int localShift;
		 int emptyStackTop;
		 DebugFrame debuggerFrame;
		 boolean useActivation;
		 Scriptable thisObj;
		 Scriptable[] scriptRegExps;
		 Object result;
		 double resultDbl;
		 int pc;
		 int pcPrevBranch;
		 int pcSourceLineStart;
		 Scriptable scope;
		 int savedStackTop;
		 int savedCallOp;
		 CallFrame cloneFrozen() {
			 if (!frozen) Kit.codeBug();
			 CallFrame copy;
			 try {
				 copy = (CallFrame)clone();
			 }
			 catch (CloneNotSupportedException ex) {
				 throw new IllegalStateException();
			 }
			 copy.stack = (Object[])stack.clone();
			 copy.sDbl = (double[])sDbl.clone();
			 copy.frozen = false;
			 return copy;
		 }
	 }
	 private static final class ContinuationJump implements Serializable {
		 static final long serialVersionUID = 7687739156004308247L;
		 CallFrame capturedFrame;
		 CallFrame branchFrame;
		 Object result;
		 double resultDbl;
		 ContinuationJump(Continuation c, CallFrame current) {
			 this.capturedFrame = (CallFrame)c.getImplementation();
			 if (this.capturedFrame == null || current == null) {
				 this.branchFrame = null;
			 }
			 else {
				 CallFrame chain1 = this.capturedFrame;
				 CallFrame chain2 = current;
				 int diff = chain1.frameIndex - chain2.frameIndex;
				 if (diff != 0) {
					 if (diff < 0) {
						 chain1 = current;
						 chain2 = this.capturedFrame;
						 diff = -diff;
					 }
					 do {
						 chain1 = chain1.parentFrame;
					 }
					 while (--diff != 0);
					 if (chain1.frameIndex != chain2.frameIndex) Kit.codeBug();
				 }
				 while (chain1 != chain2 && chain1 != null) {
					 chain1 = chain1.parentFrame;
					 chain2 = chain2.parentFrame;
				 }
				 this.branchFrame = chain1;
				 if (this.branchFrame != null && !this.branchFrame.frozen) Kit.codeBug();
			 }
		 }
	 }
	 static {
		 if (Token.LAST_BYTECODE_TOKEN > 127) {
			 String str = ""Violation of Token.LAST_BYTECODE_TOKEN <= 127"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
		 if (MIN_ICODE < -128) {
			 String str = ""Violation of Interpreter.MIN_ICODE >= -128"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
	 }
	 private static String bytecodeName(int bytecode) {
		 if (!validBytecode(bytecode)) {
			 throw new IllegalArgumentException(String.valueOf(bytecode));
		 }
		 if (!Token.printICode) {
			 return String.valueOf(bytecode);
		 }
		 if (validTokenCode(bytecode)) {
			 return Token.name(bytecode);
		 }
		 switch (bytecode) {
			 case Icode_DUP: return ""DUP"";
			 case Icode_DUP2: return ""DUP2"";
			 case Icode_SWAP: return ""SWAP"";
			 case Icode_POP: return ""POP"";
			 case Icode_POP_RESULT: return ""POP_RESULT"";
			 case Icode_IFEQ_POP: return ""IFEQ_POP"";
			 case Icode_VAR_INC_DEC: return ""VAR_INC_DEC"";
			 case Icode_NAME_INC_DEC: return ""NAME_INC_DEC"";
			 case Icode_PROP_INC_DEC: return ""PROP_INC_DEC"";
			 case Icode_ELEM_INC_DEC: return ""ELEM_INC_DEC"";
			 case Icode_REF_INC_DEC: return ""REF_INC_DEC"";
			 case Icode_SCOPE_LOAD: return ""SCOPE_LOAD"";
			 case Icode_SCOPE_SAVE: return ""SCOPE_SAVE"";
			 case Icode_TYPEOFNAME: return ""TYPEOFNAME"";
			 case Icode_NAME_AND_THIS: return ""NAME_AND_THIS"";
			 case Icode_PROP_AND_THIS: return ""PROP_AND_THIS"";
			 case Icode_ELEM_AND_THIS: return ""ELEM_AND_THIS"";
			 case Icode_VALUE_AND_THIS: return ""VALUE_AND_THIS"";
			 case Icode_CLOSURE_EXPR: return ""CLOSURE_EXPR"";
			 case Icode_CLOSURE_STMT: return ""CLOSURE_STMT"";
			 case Icode_CALLSPECIAL: return ""CALLSPECIAL"";
			 case Icode_RETUNDEF: return ""RETUNDEF"";
			 case Icode_GOSUB: return ""GOSUB"";
			 case Icode_STARTSUB: return ""STARTSUB"";
			 case Icode_RETSUB: return ""RETSUB"";
			 case Icode_LINE: return ""LINE"";
			 case Icode_SHORTNUMBER: return ""SHORTNUMBER"";
			 case Icode_INTNUMBER: return ""INTNUMBER"";
			 case Icode_LITERAL_NEW: return ""LITERAL_NEW"";
			 case Icode_LITERAL_SET: return ""LITERAL_SET"";
			 case Icode_SPARE_ARRAYLIT: return ""SPARE_ARRAYLIT"";
			 case Icode_REG_IND_C0: return ""REG_IND_C0"";
			 case Icode_REG_IND_C1: return ""REG_IND_C1"";
			 case Icode_REG_IND_C2: return ""REG_IND_C2"";
			 case Icode_REG_IND_C3: return ""REG_IND_C3"";
			 case Icode_REG_IND_C4: return ""REG_IND_C4"";
			 case Icode_REG_IND_C5: return ""REG_IND_C5"";
			 case Icode_REG_IND1: return ""LOAD_IND1"";
			 case Icode_REG_IND2: return ""LOAD_IND2"";
			 case Icode_REG_IND4: return ""LOAD_IND4"";
			 case Icode_REG_STR_C0: return ""REG_STR_C0"";
			 case Icode_REG_STR_C1: return ""REG_STR_C1"";
			 case Icode_REG_STR_C2: return ""REG_STR_C2"";
			 case Icode_REG_STR_C3: return ""REG_STR_C3"";
			 case Icode_REG_STR1: return ""LOAD_STR1"";
			 case Icode_REG_STR2: return ""LOAD_STR2"";
			 case Icode_REG_STR4: return ""LOAD_STR4"";
			 case Icode_GETVAR1: return ""GETVAR1"";
			 case Icode_SETVAR1: return ""SETVAR1"";
			 case Icode_UNDEF: return ""UNDEF"";
			 case Icode_ZERO: return ""ZERO"";
			 case Icode_ONE: return ""ONE"";
			 case Icode_ENTERDQ: return ""ENTERDQ"";
			 case Icode_LEAVEDQ: return ""LEAVEDQ"";
			 case Icode_TAIL_CALL: return ""TAIL_CALL"";
			 case Icode_LOCAL_CLEAR: return ""LOCAL_CLEAR"";
		 }
		 throw new IllegalStateException(String.valueOf(bytecode));
	 }
	 private static boolean validIcode(int icode) {
		 return MIN_ICODE <= icode && icode <= -1;
	 }
	 private static boolean validTokenCode(int token) {
		 return Token.FIRST_BYTECODE_TOKEN <= token && token <= Token.LAST_BYTECODE_TOKEN;
	 }
	 private static boolean validBytecode(int bytecode) {
		 return validIcode(bytecode) || validTokenCode(bytecode);
	 }
	 public Object compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, String encodedSource, boolean returnFunction) {
		 this.compilerEnv = compilerEnv;
		 new NodeTransformer().transform(tree);
		 if (Token.printTrees) {
			 System.out.println(tree.toStringTree(tree));
		 }
		 if (returnFunction) {
			 tree = tree.getFunctionNode(0);
		 }
		 scriptOrFn = tree;
		 itsData = new InterpreterData(compilerEnv.getLanguageVersion(), scriptOrFn.getSourceName(), encodedSource);
		 itsData.topLevel = true;
		 if (returnFunction) {
			 generateFunctionICode();
		 }
		 else {
			 generateICodeFromTree(scriptOrFn);
		 }
		 return itsData;
	 }
	 public Script createScriptObject(Object bytecode, Object staticSecurityDomain) {
		 InterpreterData idata = (InterpreterData)bytecode;
		 return InterpretedFunction.createScript(itsData, staticSecurityDomain);
	 }
	 public Function createFunctionObject(Context cx, Scriptable scope, Object bytecode, Object staticSecurityDomain) {
		 InterpreterData idata = (InterpreterData)bytecode;
		 return InterpretedFunction.createFunction(cx, scope, itsData, staticSecurityDomain);
	 }
	 private void generateFunctionICode() {
		 itsInFunctionFlag = true;
		 FunctionNode theFunction = (FunctionNode)scriptOrFn;
		 itsData.itsFunctionType = theFunction.getFunctionType();
		 itsData.itsNeedsActivation = theFunction.requiresActivation();
		 itsData.itsName = theFunction.getFunctionName();
		 if (!theFunction.getIgnoreDynamicScope()) {
			 if (compilerEnv.isUseDynamicScope()) {
				 itsData.useDynamicScope = true;
			 }
		 }
		 generateICodeFromTree(theFunction.getLastChild());
	 }
	 private void generateICodeFromTree(Node tree) {
		 generateNestedFunctions();
		 generateRegExpLiterals();
		 visitStatement(tree);
		 fixLabelGotos();
		 if (itsData.itsFunctionType == 0) {
			 addToken(Token.RETURN_RESULT);
		 }
		 if (itsData.itsICode.length != itsICodeTop) {
			 byte[] tmp = new byte[itsICodeTop];
			 System.arraycopy(itsData.itsICode, 0, tmp, 0, itsICodeTop);
			 itsData.itsICode = tmp;
		 }
		 if (itsStrings.size() == 0) {
			 itsData.itsStringTable = null;
		 }
		 else {
			 itsData.itsStringTable = new String[itsStrings.size()];
			 ObjToIntMap.Iterator iter = itsStrings.newIterator();
			 for (iter.start();
			 !iter.done();
			 iter.next()) {
				 String str = (String)iter.getKey();
				 int index = iter.getValue();
				 if (itsData.itsStringTable[index] != null) Kit.codeBug();
				 itsData.itsStringTable[index] = str;
			 }
		 }
		 if (itsDoubleTableTop == 0) {
			 itsData.itsDoubleTable = null;
		 }
		 else if (itsData.itsDoubleTable.length != itsDoubleTableTop) {
			 double[] tmp = new double[itsDoubleTableTop];
			 System.arraycopy(itsData.itsDoubleTable, 0, tmp, 0, itsDoubleTableTop);
			 itsData.itsDoubleTable = tmp;
		 }
		 if (itsExceptionTableTop != 0 && itsData.itsExceptionTable.length != itsExceptionTableTop) {
			 int[] tmp = new int[itsExceptionTableTop];
			 System.arraycopy(itsData.itsExceptionTable, 0, tmp, 0, itsExceptionTableTop);
			 itsData.itsExceptionTable = tmp;
		 }
		 itsData.itsMaxVars = scriptOrFn.getParamAndVarCount();
		 itsData.itsMaxFrameArray = itsData.itsMaxVars + itsData.itsMaxLocals + itsData.itsMaxStack;
		 itsData.argNames = scriptOrFn.getParamAndVarNames();
		 itsData.argCount = scriptOrFn.getParamCount();
		 itsData.encodedSourceStart = scriptOrFn.getEncodedSourceStart();
		 itsData.encodedSourceEnd = scriptOrFn.getEncodedSourceEnd();
		 if (itsLiteralIds.size() != 0) {
			 itsData.literalIds = itsLiteralIds.toArray();
		 }
		 if (Token.printICode) dumpICode(itsData);
	 }
	 private void generateNestedFunctions() {
		 int functionCount = scriptOrFn.getFunctionCount();
		 if (functionCount == 0) return;
		 InterpreterData[] array = new InterpreterData[functionCount];
		 for (int i = 0;
		 i != functionCount;
		 i++) {
			 FunctionNode def = scriptOrFn.getFunctionNode(i);
			 Interpreter jsi = new Interpreter();
			 jsi.compilerEnv = compilerEnv;
			 jsi.scriptOrFn = def;
			 jsi.itsData = new InterpreterData(itsData);
			 jsi.generateFunctionICode();
			 array[i] = jsi.itsData;
		 }
		 itsData.itsNestedFunctions = array;
	 }
	 private void generateRegExpLiterals() {
		 int N = scriptOrFn.getRegexpCount();
		 if (N == 0) return;
		 Context cx = Context.getContext();
		 RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);
		 Object[] array = new Object[N];
		 for (int i = 0;
		 i != N;
		 i++) {
			 String string = scriptOrFn.getRegexpString(i);
			 String flags = scriptOrFn.getRegexpFlags(i);
			 array[i] = rep.compileRegExp(cx, string, flags);
		 }
		 itsData.itsRegExpLiterals = array;
	 }
	 private void updateLineNumber(Node node) {
		 int lineno = node.getLineno();
		 if (lineno != itsLineNumber && lineno >= 0) {
			 if (itsData.firstLinePC < 0) {
				 itsData.firstLinePC = lineno;
			 }
			 itsLineNumber = lineno;
			 addIcode(Icode_LINE);
			 addUint16(lineno & 0xFFFF);
		 }
	 }
	 private RuntimeException badTree(Node node) {
		 throw new RuntimeException(node.toString());
	 }
	 private void visitStatement(Node node) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 int fnType = scriptOrFn.getFunctionNode(fnIndex). getFunctionType();
				 if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 addIndexOp(Icode_CLOSURE_STMT, fnIndex);
				 }
				 else {
					 if (fnType != FunctionNode.FUNCTION_STATEMENT) {
						 throw Kit.codeBug();
					 }
				 }
			 }
			 break;
			 case Token.SCRIPT: case Token.LABEL: case Token.LOOP: case Token.BLOCK: case Token.EMPTY: case Token.WITH: updateLineNumber(node);
			 while (child != null) {
				 visitStatement(child);
				 child = child.getNext();
			 }
			 break;
			 case Token.ENTERWITH: visitExpression(child, 0);
			 addToken(Token.ENTERWITH);
			 stackChange(-1);
			 break;
			 case Token.LEAVEWITH: addToken(Token.LEAVEWITH);
			 break;
			 case Token.LOCAL_BLOCK: {
				 int local = allocLocal();
				 node.putIntProp(Node.LOCAL_PROP, local);
				 updateLineNumber(node);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, local);
				 releaseLocal(local);
			 }
			 break;
			 case Token.SWITCH: updateLineNumber(node);
			 {
				 Node switchNode = (Node.Jump)node;
				 visitExpression(child, 0);
				 for (Node.Jump caseNode = (Node.Jump)child.getNext();
				 caseNode != null;
				 caseNode = (Node.Jump)caseNode.getNext()) {
					 if (caseNode.getType() != Token.CASE) throw badTree(caseNode);
					 Node test = caseNode.getFirstChild();
					 addIcode(Icode_DUP);
					 stackChange(1);
					 visitExpression(test, 0);
					 addToken(Token.SHEQ);
					 stackChange(-1);
					 addGoto(caseNode.target, Icode_IFEQ_POP);
					 stackChange(-1);
				 }
				 addIcode(Icode_POP);
				 stackChange(-1);
			 }
			 break;
			 case Token.TARGET: markTargetLabel(node);
			 break;
			 case Token.IFEQ : case Token.IFNE : {
				 Node target = ((Node.Jump)node).target;
				 visitExpression(child, 0);
				 addGoto(target, type);
				 stackChange(-1);
			 }
			 break;
			 case Token.GOTO: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, type);
			 }
			 break;
			 case Token.JSR: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, Icode_GOSUB);
			 }
			 break;
			 case Token.FINALLY: {
				 stackChange(1);
				 int finallyRegister = getLocalBlockRef(node);
				 addIndexOp(Icode_STARTSUB, finallyRegister);
				 stackChange(-1);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_RETSUB, finallyRegister);
			 }
			 break;
			 case Token.EXPR_VOID: case Token.EXPR_RESULT: updateLineNumber(node);
			 visitExpression(child, 0);
			 addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);
			 stackChange(-1);
			 break;
			 case Token.TRY: {
				 Node.Jump tryNode = (Node.Jump)node;
				 int exceptionObjectLocal = getLocalBlockRef(tryNode);
				 int scopeLocal = allocLocal();
				 addIndexOp(Icode_SCOPE_SAVE, scopeLocal);
				 int tryStart = itsICodeTop;
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 Node catchTarget = tryNode.target;
				 if (catchTarget != null) {
					 int catchStartPC = itsLabelTable[getTargetLabel(catchTarget)];
					 addExceptionHandler( tryStart, catchStartPC, catchStartPC, false, exceptionObjectLocal, scopeLocal);
				 }
				 Node finallyTarget = tryNode.getFinally();
				 if (finallyTarget != null) {
					 int finallyStartPC = itsLabelTable[getTargetLabel(finallyTarget)];
					 addExceptionHandler( tryStart, finallyStartPC, finallyStartPC, true, exceptionObjectLocal, scopeLocal);
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);
				 releaseLocal(scopeLocal);
			 }
			 break;
			 case Token.CATCH_SCOPE: {
				 int localIndex = getLocalBlockRef(node);
				 int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringPrefix(name);
				 addIndexPrefix(localIndex);
				 addToken(Token.CATCH_SCOPE);
				 addUint8(scopeIndex != 0 ? 1 : 0);
				 stackChange(-1);
			 }
			 break;
			 case Token.THROW: updateLineNumber(node);
			 visitExpression(child, 0);
			 addToken(Token.THROW);
			 addUint16(itsLineNumber & 0xFFFF);
			 stackChange(-1);
			 break;
			 case Token.RETHROW: updateLineNumber(node);
			 addIndexOp(Token.RETHROW, getLocalBlockRef(node));
			 break;
			 case Token.RETURN: updateLineNumber(node);
			 if (child != null) {
				 visitExpression(child, ECF_TAIL);
				 addToken(Token.RETURN);
				 stackChange(-1);
			 }
			 else {
				 addIcode(Icode_RETUNDEF);
			 }
			 break;
			 case Token.RETURN_RESULT: updateLineNumber(node);
			 addToken(Token.RETURN_RESULT);
			 break;
			 case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES : visitExpression(child, 0);
			 addIndexOp(type, getLocalBlockRef(node));
			 stackChange(-1);
			 break;
			 default: throw badTree(node);
		 }
		 if (itsStackDepth != 0) {
			 throw Kit.codeBug();
		 }
	 }
	 private void visitExpression(Node node, int contextFlags) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 int savedStackDepth = itsStackDepth;
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);
				 if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {
					 throw Kit.codeBug();
				 }
				 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.LOCAL_LOAD: {
				 int localIndex = getLocalBlockRef(node);
				 addIndexOp(Token.LOCAL_LOAD, localIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.COMMA: {
				 Node lastChild = node.getLastChild();
				 while (child != lastChild) {
					 visitExpression(child, 0);
					 addIcode(Icode_POP);
					 stackChange(-1);
					 child = child.getNext();
				 }
				 visitExpression(child, contextFlags & ECF_TAIL);
			 }
			 break;
			 case Token.USE_STACK: stackChange(1);
			 break;
			 case Token.REF_CALL: case Token.CALL: case Token.NEW: {
				 if (type == Token.NEW) {
					 visitExpression(child, 0);
				 }
				 else {
					 generateCallFunAndThis(child);
				 }
				 int argCount = 0;
				 while ((child = child.getNext()) != null) {
					 visitExpression(child, 0);
					 ++argCount;
				 }
				 int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL);
				 if (callType != Node.NON_SPECIALCALL) {
					 addIndexOp(Icode_CALLSPECIAL, argCount);
					 addUint8(callType);
					 addUint8(type == Token.NEW ? 1 : 0);
					 addUint16(itsLineNumber & 0xFFFF);
				 }
				 else {
					 if (type == Token.CALL) {
						 if ((contextFlags & ECF_TAIL) != 0) {
							 type = Icode_TAIL_CALL;
						 }
					 }
					 addIndexOp(type, argCount);
				 }
				 if (type == Token.NEW) {
					 stackChange(-argCount);
				 }
				 else {
					 stackChange(-1 - argCount);
				 }
				 if (argCount > itsData.itsMaxCalleeArgs) {
					 itsData.itsMaxCalleeArgs = argCount;
				 }
			 }
			 break;
			 case Token.AND: case Token.OR: {
				 visitExpression(child, 0);
				 addIcode(Icode_DUP);
				 stackChange(1);
				 int afterSecondJumpStart = itsICodeTop;
				 int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;
				 addForwardGoto(jump);
				 stackChange(-1);
				 addIcode(Icode_POP);
				 stackChange(-1);
				 child = child.getNext();
				 visitExpression(child, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterSecondJumpStart);
			 }
			 break;
			 case Token.HOOK: {
				 Node ifThen = child.getNext();
				 Node ifElse = ifThen.getNext();
				 visitExpression(child, 0);
				 int elseJumpStart = itsICodeTop;
				 addForwardGoto(Token.IFNE);
				 stackChange(-1);
				 visitExpression(ifThen, contextFlags & ECF_TAIL);
				 int afterElseJumpStart = itsICodeTop;
				 addForwardGoto(Token.GOTO);
				 resolveForwardGoto(elseJumpStart);
				 itsStackDepth = savedStackDepth;
				 visitExpression(ifElse, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterElseJumpStart);
			 }
			 break;
			 case Token.GETPROP: visitExpression(child, 0);
			 child = child.getNext();
			 addStringOp(Token.GETPROP, child.getString());
			 break;
			 case Token.GETELEM: case Token.DELPROP: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 addToken(type);
			 stackChange(-1);
			 break;
			 case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0);
			 if (type == Token.VOID) {
				 addIcode(Icode_POP);
				 addIcode(Icode_UNDEF);
			 }
			 else {
				 addToken(type);
			 }
			 break;
			 case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0);
			 addToken(type);
			 break;
			 case Token.SETPROP: case Token.SETPROP_OP: {
				 visitExpression(child, 0);
				 child = child.getNext();
				 String property = child.getString();
				 child = child.getNext();
				 if (type == Token.SETPROP_OP) {
					 addIcode(Icode_DUP);
					 stackChange(1);
					 addStringOp(Token.GETPROP, property);
					 stackChange(-1);
				 }
				 visitExpression(child, 0);
				 addStringOp(Token.SETPROP, property);
				 stackChange(-1);
			 }
			 break;
			 case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SETELEM_OP) {
				 addIcode(Icode_DUP2);
				 stackChange(2);
				 addToken(Token.GETELEM);
				 stackChange(-1);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SETELEM);
			 stackChange(-2);
			 break;
			 case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SET_REF_OP) {
				 addIcode(Icode_DUP);
				 stackChange(1);
				 addToken(Token.GET_REF);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SET_REF);
			 stackChange(-1);
			 break;
			 case Token.SETNAME: {
				 String name = child.getString();
				 visitExpression(child, 0);
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringOp(Token.SETNAME, name);
				 stackChange(-1);
			 }
			 break;
			 case Token.TYPEOFNAME: {
				 String name = node.getString();
				 int index = -1;
				 if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getParamOrVarIndex(name);
				 if (index == -1) {
					 addStringOp(Icode_TYPEOFNAME, name);
					 stackChange(1);
				 }
				 else {
					 addVarOp(Token.GETVAR, index);
					 stackChange(1);
					 addToken(Token.TYPEOF);
				 }
			 }
			 break;
			 case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString());
			 stackChange(1);
			 break;
			 case Token.INC: case Token.DEC: visitIncDec(node, child);
			 break;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 int inum = (int)num;
				 if (inum == num) {
					 if (inum == 0) {
						 addIcode(Icode_ZERO);
						 if (1.0 / num < 0.0) {
							 addToken(Token.NEG);
						 }
					 }
					 else if (inum == 1) {
						 addIcode(Icode_ONE);
					 }
					 else if ((short)inum == inum) {
						 addIcode(Icode_SHORTNUMBER);
						 addUint16(inum & 0xFFFF);
					 }
					 else {
						 addIcode(Icode_INTNUMBER);
						 addInt(inum);
					 }
				 }
				 else {
					 int index = getDoubleIndex(num);
					 addIndexOp(Token.NUMBER, index);
				 }
				 stackChange(1);
			 }
			 break;
			 case Token.GETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = node.getString();
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.GETVAR, index);
				 stackChange(1);
			 }
			 break;
			 case Token.SETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.SETVAR, index);
			 }
			 break;
			 case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type);
			 stackChange(1);
			 break;
			 case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node));
			 stackChange(1);
			 break;
			 case Token.REGEXP: {
				 int index = node.getExistingIntProp(Node.REGEXP_PROP);
				 addIndexOp(Token.REGEXP, index);
				 stackChange(1);
			 }
			 break;
			 case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child);
			 break;
			 case Token.REF_SPECIAL: visitExpression(child, 0);
			 addStringOp(type, (String)node.getProp(Node.NAME_PROP));
			 break;
			 case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: {
				 int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);
				 int childCount = 0;
				 do {
					 visitExpression(child, 0);
					 ++childCount;
					 child = child.getNext();
				 }
				 while (child != null);
				 addIndexOp(type, memberTypeFlags);
				 stackChange(1 - childCount);
			 }
			 break;
			 case Token.DOTQUERY: {
				 int queryPC;
				 updateLineNumber(node);
				 visitExpression(child, 0);
				 addIcode(Icode_ENTERDQ);
				 stackChange(-1);
				 queryPC = itsICodeTop;
				 visitExpression(child.getNext(), 0);
				 addBackwardGoto(Icode_LEAVEDQ, queryPC);
			 }
			 break;
			 case Token.DEFAULTNAMESPACE : case Token.ESCXMLATTR : case Token.ESCXMLTEXT : visitExpression(child, 0);
			 addToken(type);
			 break;
			 default: throw badTree(node);
		 }
		 if (savedStackDepth + 1 != itsStackDepth) {
			 Kit.codeBug();
		 }
	 }
	 private void generateCallFunAndThis(Node left) {
		 int type = left.getType();
		 switch (type) {
			 case Token.NAME: {
				 String name = left.getString();
				 addStringOp(Icode_NAME_AND_THIS, name);
				 stackChange(2);
				 break;
			 }
			 case Token.GETPROP: case Token.GETELEM: {
				 Node target = left.getFirstChild();
				 visitExpression(target, 0);
				 Node id = target.getNext();
				 if (type == Token.GETPROP) {
					 String property = id.getString();
					 addStringOp(Icode_PROP_AND_THIS, property);
					 stackChange(1);
				 }
				 else {
					 visitExpression(id, 0);
					 addIcode(Icode_ELEM_AND_THIS);
				 }
				 break;
			 }
			 default: visitExpression(left, 0);
			 addIcode(Icode_VALUE_AND_THIS);
			 stackChange(1);
			 break;
		 }
	 }
	 private void visitIncDec(Node node, Node child) {
		 int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);
		 int childType = child.getType();
		 switch (childType) {
			 case Token.GETVAR : {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 int i = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Icode_VAR_INC_DEC, i);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.NAME : {
				 String name = child.getString();
				 addStringOp(Icode_NAME_INC_DEC, name);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.GETPROP : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 String property = object.getNext().getString();
				 addStringOp(Icode_PROP_INC_DEC, property);
				 addUint8(incrDecrMask);
				 break;
			 }
			 case Token.GETELEM : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 Node index = object.getNext();
				 visitExpression(index, 0);
				 addIcode(Icode_ELEM_INC_DEC);
				 addUint8(incrDecrMask);
				 stackChange(-1);
				 break;
			 }
			 case Token.GET_REF : {
				 Node ref = child.getFirstChild();
				 visitExpression(ref, 0);
				 addIcode(Icode_REF_INC_DEC);
				 addUint8(incrDecrMask);
				 break;
			 }
			 default : {
				 throw badTree(node);
			 }
		 }
	 }
	 private void visitLiteral(Node node, Node child) {
		 int type = node.getType();
		 int count;
		 Object[] propertyIds = null;
		 if (type == Token.ARRAYLIT) {
			 count = 0;
			 for (Node n = child;
			 n != null;
			 n = n.getNext()) {
				 ++count;
			 }
		 }
		 else if (type == Token.OBJECTLIT) {
			 propertyIds = (Object[])node.getProp(Node.OBJECT_IDS_PROP);
			 count = propertyIds.length;
		 }
		 else {
			 throw badTree(node);
		 }
		 addIndexOp(Icode_LITERAL_NEW, count);
		 stackChange(1);
		 while (child != null) {
			 visitExpression(child, 0);
			 addIcode(Icode_LITERAL_SET);
			 stackChange(-1);
			 child = child.getNext();
		 }
		 if (type == Token.ARRAYLIT) {
			 int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);
			 if (skipIndexes == null) {
				 addToken(Token.ARRAYLIT);
			 }
			 else {
				 int index = itsLiteralIds.size();
				 itsLiteralIds.add(skipIndexes);
				 addIndexOp(Icode_SPARE_ARRAYLIT, index);
			 }
		 }
		 else {
			 int index = itsLiteralIds.size();
			 itsLiteralIds.add(propertyIds);
			 addIndexOp(Token.OBJECTLIT, index);
		 }
	 }
	 private int getLocalBlockRef(Node node) {
		 Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
		 return localBlock.getExistingIntProp(Node.LOCAL_PROP);
	 }
	 private int getTargetLabel(Node target) {
		 int label = target.labelId();
		 if (label != -1) {
			 return label;
		 }
		 label = itsLabelTableTop;
		 if (itsLabelTable == null || label == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, label);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = label + 1;
		 itsLabelTable[label] = -1;
		 target.labelId(label);
		 return label;
	 }
	 private void markTargetLabel(Node target) {
		 int label = getTargetLabel(target);
		 if (itsLabelTable[label] != -1) {
			 Kit.codeBug();
		 }
		 itsLabelTable[label] = itsICodeTop;
	 }
	 private void addGoto(Node target, int gotoOp) {
		 int label = getTargetLabel(target);
		 if (!(label < itsLabelTableTop)) Kit.codeBug();
		 int targetPC = itsLabelTable[label];
		 int gotoPC = itsICodeTop;
		 if (validIcode(gotoOp)) {
			 addIcode(gotoOp);
		 }
		 else {
			 addToken(gotoOp);
		 }
		 if (targetPC != -1) {
			 recordJump(gotoPC, targetPC);
			 itsICodeTop += 2;
		 }
		 else {
			 addUint16(0);
			 int top = itsFixupTableTop;
			 if (itsFixupTable == null || top == itsFixupTable.length) {
				 if (itsFixupTable == null) {
					 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
				 }
				 else {
					 long[] tmp = new long[itsFixupTable.length * 2];
					 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
					 itsFixupTable = tmp;
				 }
			 }
			 itsFixupTableTop = top + 1;
			 itsFixupTable[top] = ((long)label << 32) | gotoPC;
		 }
	 }
	 private void fixLabelGotos() {
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int jumpSource = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw Kit.codeBug();
			 }
			 recordJump(jumpSource, pc);
		 }
		 itsFixupTableTop = 0;
	 }
	 private void addBackwardGoto(int gotoOp, int jumpPC) {
		 if (jumpPC >= itsICodeTop) throw Kit.codeBug();
		 int fromPC = itsICodeTop;
		 addIcode(gotoOp);
		 recordJump(fromPC, jumpPC);
		 itsICodeTop += 2;
	 }
	 private void addForwardGoto(int gotoOp) {
		 addToken(gotoOp);
		 addUint16(0);
	 }
	 private void resolveForwardGoto(int fromPC) {
		 if (fromPC + 3 > itsICodeTop) throw Kit.codeBug();
		 recordJump(fromPC, itsICodeTop);
	 }
	 private void recordJump(int jumpSource, int jumpDestination) {
		 if (jumpSource == jumpDestination) throw Kit.codeBug();
		 int offsetSite = jumpSource + 1;
		 int offset = jumpDestination - jumpSource;
		 if (offset != (short)offset) {
			 if (itsData.longJumps == null) {
				 itsData.longJumps = new UintMap();
			 }
			 itsData.longJumps.put(offsetSite, jumpDestination);
			 offset = 0;
		 }
		 int deltaCapacity = offsetSite + 2 - itsData.itsICode.length;
		 if (deltaCapacity > 0) {
			 increaseICodeCapasity(deltaCapacity);
		 }
		 itsData.itsICode[offsetSite] = (byte)(offset >> 8);
		 itsData.itsICode[offsetSite + 1] = (byte)offset;
	 }
	 private void addToken(int token) {
		 if (!validTokenCode(token)) throw Kit.codeBug();
		 addUint8(token);
	 }
	 private void addIcode(int icode) {
		 if (!validIcode(icode)) throw Kit.codeBug();
		 addUint8(icode & 0xFF);
	 }
	 private void addUint8(int value) {
		 if ((value & ~0xFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top == array.length) {
			 array = increaseICodeCapasity(1);
		 }
		 array[top] = (byte)value;
		 itsICodeTop = top + 1;
	 }
	 private void addUint16(int value) {
		 if ((value & ~0xFFFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 2 > array.length) {
			 array = increaseICodeCapasity(2);
		 }
		 array[top] = (byte)(value >>> 8);
		 array[top + 1] = (byte)value;
		 itsICodeTop = top + 2;
	 }
	 private void addInt(int i) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 4 > array.length) {
			 array = increaseICodeCapasity(4);
		 }
		 array[top] = (byte)(i >>> 24);
		 array[top + 1] = (byte)(i >>> 16);
		 array[top + 2] = (byte)(i >>> 8);
		 array[top + 3] = (byte)i;
		 itsICodeTop = top + 4;
	 }
	 private int getDoubleIndex(double num) {
		 int index = itsDoubleTableTop;
		 if (index == 0) {
			 itsData.itsDoubleTable = new double[64];
		 }
		 else if (itsData.itsDoubleTable.length == index) {
			 double[] na = new double[index * 2];
			 System.arraycopy(itsData.itsDoubleTable, 0, na, 0, index);
			 itsData.itsDoubleTable = na;
		 }
		 itsData.itsDoubleTable[index] = num;
		 itsDoubleTableTop = index + 1;
		 return index;
	 }
	 private void addVarOp(int op, int varIndex) {
		 switch (op) {
			 case Token.GETVAR: case Token.SETVAR: if (varIndex < 128) {
				 addIcode(op == Token.GETVAR ? Icode_GETVAR1 : Icode_SETVAR1);
				 addUint8(varIndex);
				 return;
			 }
			 case Icode_VAR_INC_DEC: addIndexOp(op, varIndex);
			 return;
		 }
		 throw Kit.codeBug();
	 }
	 private void addStringOp(int op, String str) {
		 addStringPrefix(str);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addIndexOp(int op, int index) {
		 addIndexPrefix(index);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addStringPrefix(String str) {
		 int index = itsStrings.get(str, -1);
		 if (index == -1) {
			 index = itsStrings.size();
			 itsStrings.put(str, index);
		 }
		 if (index < 4) {
			 addIcode(Icode_REG_STR_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_STR1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_STR2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_STR4);
			 addInt(index);
		 }
	 }
	 private void addIndexPrefix(int index) {
		 if (index < 0) Kit.codeBug();
		 if (index < 6) {
			 addIcode(Icode_REG_IND_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_IND1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_IND2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_IND4);
			 addInt(index);
		 }
	 }
	 private void addExceptionHandler(int icodeStart, int icodeEnd, int handlerStart, boolean isFinally, int exceptionObjectLocal, int scopeLocal) {
		 int top = itsExceptionTableTop;
		 int[] table = itsData.itsExceptionTable;
		 if (table == null) {
			 if (top != 0) Kit.codeBug();
			 table = new int[EXCEPTION_SLOT_SIZE * 2];
			 itsData.itsExceptionTable = table;
		 }
		 else if (table.length == top) {
			 table = new int[table.length * 2];
			 System.arraycopy(itsData.itsExceptionTable, 0, table, 0, top);
			 itsData.itsExceptionTable = table;
		 }
		 table[top + EXCEPTION_TRY_START_SLOT] = icodeStart;
		 table[top + EXCEPTION_TRY_END_SLOT] = icodeEnd;
		 table[top + EXCEPTION_HANDLER_SLOT] = handlerStart;
		 table[top + EXCEPTION_TYPE_SLOT] = isFinally ? 1 : 0;
		 table[top + EXCEPTION_LOCAL_SLOT] = exceptionObjectLocal;
		 table[top + EXCEPTION_SCOPE_SLOT] = scopeLocal;
		 itsExceptionTableTop = top + EXCEPTION_SLOT_SIZE;
	 }
	 private byte[] increaseICodeCapasity(int extraSize) {
		 int capacity = itsData.itsICode.length;
		 int top = itsICodeTop;
		 if (top + extraSize <= capacity) throw Kit.codeBug();
		 capacity *= 2;
		 if (top + extraSize > capacity) {
			 capacity = top + extraSize;
		 }
		 byte[] array = new byte[capacity];
		 System.arraycopy(itsData.itsICode, 0, array, 0, top);
		 itsData.itsICode = array;
		 return array;
	 }
	 private void stackChange(int change) {
		 if (change <= 0) {
			 itsStackDepth += change;
		 }
		 else {
			 int newDepth = itsStackDepth + change;
			 if (newDepth > itsData.itsMaxStack) {
				 itsData.itsMaxStack = newDepth;
			 }
			 itsStackDepth = newDepth;
		 }
	 }
	 private int allocLocal() {
		 int localSlot = itsLocalTop;
		 ++itsLocalTop;
		 if (itsLocalTop > itsData.itsMaxLocals) {
			 itsData.itsMaxLocals = itsLocalTop;
		 }
		 return localSlot;
	 }
	 private void releaseLocal(int localSlot) {
		 --itsLocalTop;
		 if (localSlot != itsLocalTop) Kit.codeBug();
	 }
	 private static int getShort(byte[] iCode, int pc) {
		 return (iCode[pc] << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getIndex(byte[] iCode, int pc) {
		 return ((iCode[pc] & 0xFF) << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getInt(byte[] iCode, int pc) {
		 return (iCode[pc] << 24) | ((iCode[pc + 1] & 0xFF) << 16) | ((iCode[pc + 2] & 0xFF) << 8) | (iCode[pc + 3] & 0xFF);
	 }
	 private static int getExceptionHandler(CallFrame frame, boolean onlyFinally) {
		 int[] exceptionTable = frame.idata.itsExceptionTable;
		 if (exceptionTable == null) {
			 return -1;
		 }
		 int pc = frame.pc - 1;
		 int best = -1, bestStart = 0, bestEnd = 0;
		 for (int i = 0;
		 i != exceptionTable.length;
		 i += EXCEPTION_SLOT_SIZE) {
			 int start = exceptionTable[i + EXCEPTION_TRY_START_SLOT];
			 int end = exceptionTable[i + EXCEPTION_TRY_END_SLOT];
			 if (!(start <= pc && pc < end)) {
				 continue;
			 }
			 if (onlyFinally && exceptionTable[i + EXCEPTION_TYPE_SLOT] != 1) {
				 continue;
			 }
			 if (best >= 0) {
				 if (bestEnd < end) {
					 continue;
				 }
				 if (bestStart > start) Kit.codeBug();
				 if (bestEnd == end) Kit.codeBug();
			 }
			 best = i;
			 bestStart = start;
			 bestEnd = end;
		 }
		 return best;
	 }
	 private static void dumpICode(InterpreterData idata) {
		 if (!Token.printICode) {
			 return;
		 }
		 byte iCode[] = idata.itsICode;
		 int iCodeLength = iCode.length;
		 String[] strings = idata.itsStringTable;
		 PrintStream out = System.out;
		 out.println(""ICode dump, for "" + idata.itsName + "", length = "" + iCodeLength);
		 out.println(""MaxStack = "" + idata.itsMaxStack);
		 int indexReg = 0;
		 for (int pc = 0;
		 pc < iCodeLength;
		 ) {
			 out.flush();
			 out.print("" ["" + pc + ""] "");
			 int token = iCode[pc];
			 int icodeLength = bytecodeSpan(token);
			 String tname = bytecodeName(token);
			 int old_pc = pc;
			 ++pc;
			 switch (token) {
				 default: if (icodeLength != 1) Kit.codeBug();
				 out.println(tname);
				 break;
				 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : {
					 int newPC = pc + getShort(iCode, pc) - 1;
					 out.println(tname + "" "" + newPC);
					 pc += 2;
					 break;
				 }
				 case Icode_VAR_INC_DEC : case Icode_NAME_INC_DEC : case Icode_PROP_INC_DEC : case Icode_ELEM_INC_DEC : case Icode_REF_INC_DEC: {
					 int incrDecrType = iCode[pc];
					 out.println(tname + "" "" + incrDecrType);
					 ++pc;
					 break;
				 }
				 case Icode_CALLSPECIAL : {
					 int callType = iCode[pc] & 0xFF;
					 boolean isNew = (iCode[pc + 1] != 0);
					 int line = getIndex(iCode, pc+2);
					 out.println(tname+"" ""+callType+"" ""+isNew+"" ""+indexReg+"" ""+line);
					 pc += 4;
					 break;
				 }
				 case Token.CATCH_SCOPE: {
					 boolean afterFisrtFlag = (iCode[pc] != 0);
					 out.println(tname+"" ""+afterFisrtFlag);
					 ++pc;
				 }
				 break;
				 case Token.REGEXP : out.println(tname+"" ""+idata.itsRegExpLiterals[indexReg]);
				 break;
				 case Token.OBJECTLIT : case Icode_SPARE_ARRAYLIT : out.println(tname+"" ""+idata.literalIds[indexReg]);
				 break;
				 case Icode_CLOSURE_EXPR : case Icode_CLOSURE_STMT : out.println(tname+"" ""+idata.itsNestedFunctions[indexReg]);
				 break;
				 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : case Token.NEW : out.println(tname+' '+indexReg);
				 break;
				 case Token.THROW : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_SHORTNUMBER : {
					 int value = getShort(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_INTNUMBER : {
					 int value = getInt(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 4;
					 break;
				 }
				 case Token.NUMBER : {
					 double value = idata.itsDoubleTable[indexReg];
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_LINE : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR1: {
					 String str = strings[0xFF & iCode[pc]];
					 out.println(tname + "" \"""" + str + '""');
					 ++pc;
					 break;
				 }
				 case Icode_REG_STR2: {
					 String str = strings[getIndex(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR4: {
					 String str = strings[getInt(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 4;
					 break;
				 }
				 case Icode_REG_IND1: {
					 indexReg = 0xFF & iCode[pc];
					 out.println(tname+"" ""+indexReg);
					 ++pc;
					 break;
				 }
				 case Icode_REG_IND2: {
					 indexReg = getIndex(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_IND4: {
					 indexReg = getInt(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 4;
					 break;
				 }
				 case Icode_GETVAR1: case Icode_SETVAR1: indexReg = iCode[pc];
				 out.println(tname+"" ""+indexReg);
				 ++pc;
				 break;
			 }
			 if (old_pc + icodeLength != pc) Kit.codeBug();
		 }
		 int[] table = idata.itsExceptionTable;
		 if (table != null) {
			 out.println(""Exception handlers: "" +table.length / EXCEPTION_SLOT_SIZE);
			 for (int i = 0;
			 i != table.length;
			 i += EXCEPTION_SLOT_SIZE) {
				 int tryStart = table[i + EXCEPTION_TRY_START_SLOT];
				 int tryEnd = table[i + EXCEPTION_TRY_END_SLOT];
				 int handlerStart = table[i + EXCEPTION_HANDLER_SLOT];
				 int type = table[i + EXCEPTION_TYPE_SLOT];
				 int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];
				 int scopeLocal = table[i + EXCEPTION_SCOPE_SLOT];
				 out.println("" tryStart=""+tryStart+"" tryEnd=""+tryEnd +"" handlerStart=""+handlerStart +"" type=""+(type == 0 ? ""catch"" : ""finally"") +"" exceptionLocal=""+exceptionLocal);
			 }
		 }
		 out.flush();
	 }
	 private static int bytecodeSpan(int bytecode) {
		 switch (bytecode) {
			 case Token.THROW : return 1 + 2;
			 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : return 1 + 2;
			 case Icode_CALLSPECIAL : return 1 + 1 + 1 + 2;
			 case Token.CATCH_SCOPE: return 1 + 1;
			 case Icode_VAR_INC_DEC: case Icode_NAME_INC_DEC: case Icode_PROP_INC_DEC: case Icode_ELEM_INC_DEC: case Icode_REF_INC_DEC: return 1 + 1;
			 case Icode_SHORTNUMBER : return 1 + 2;
			 case Icode_INTNUMBER : return 1 + 4;
			 case Icode_REG_IND1: return 1 + 1;
			 case Icode_REG_IND2: return 1 + 2;
			 case Icode_REG_IND4: return 1 + 4;
			 case Icode_REG_STR1: return 1 + 1;
			 case Icode_REG_STR2: return 1 + 2;
			 case Icode_REG_STR4: return 1 + 4;
			 case Icode_GETVAR1: case Icode_SETVAR1: return 1 + 1;
			 case Icode_LINE : return 1 + 2;
		 }
		 if (!validBytecode(bytecode)) throw Kit.codeBug();
		 return 1;
	 }
	 static int[] getLineNumbers(InterpreterData data) {
		 UintMap presentLines = new UintMap();
		 byte[] iCode = data.itsICode;
		 int iCodeLength = iCode.length;
		 for (int pc = 0;
		 pc != iCodeLength;
		) {
			 int bytecode = iCode[pc];
			 int span = bytecodeSpan(bytecode);
			 if (bytecode == Icode_LINE) {
				 if (span != 3) Kit.codeBug();
				 int line = getIndex(iCode, pc + 1);
				 presentLines.put(line, 0);
			 }
			 pc += span;
		 }
		 return presentLines.getKeys();
	 }
	 static void captureInterpreterStackInfo(RhinoException ex) {
		 Context cx = Context.getCurrentContext();
		 if (cx == null || cx.lastInterpreterFrame == null) {
			 ex.interpreterStackInfo = null;
			 ex.interpreterLineData = null;
			 return;
		 }
		 CallFrame[] array;
		 if (cx.previousInterpreterInvocations == null || cx.previousInterpreterInvocations.size() == 0) {
			 array = new CallFrame[1];
		 }
		 else {
			 int previousCount = cx.previousInterpreterInvocations.size();
			 if (cx.previousInterpreterInvocations.peek() == cx.lastInterpreterFrame) {
				 --previousCount;
			 }
			 array = new CallFrame[previousCount + 1];
			 cx.previousInterpreterInvocations.toArray(array);
		 }
		 array[array.length - 1] = (CallFrame)cx.lastInterpreterFrame;
		 int interpreterFrameCount = 0;
		 for (int i = 0;
		 i != array.length;
		 ++i) {
			 interpreterFrameCount += 1 + array[i].frameIndex;
		 }
		 int[] linePC = new int[interpreterFrameCount];
		 int linePCIndex = interpreterFrameCount;
		 for (int i = array.length;
		 i != 0;
		) {
			 --i;
			 CallFrame frame = array[i];
			 while (frame != null) {
				 --linePCIndex;
				 linePC[linePCIndex] = frame.pcSourceLineStart;
				 frame = frame.parentFrame;
			 }
		 }
		 if (linePCIndex != 0) Kit.codeBug();
		 ex.interpreterStackInfo = array;
		 ex.interpreterLineData = linePC;
	 }
	 static String getSourcePositionFromStack(Context cx, int[] linep) {
		 CallFrame frame = (CallFrame)cx.lastInterpreterFrame;
		 InterpreterData idata = frame.idata;
		 if (frame.pcSourceLineStart >= 0) {
			 linep[0] = getIndex(idata.itsICode, frame.pcSourceLineStart);
		 }
		 else {
			 linep[0] = 0;
		 }
		 return idata.itsSourceFile;
	 }
	 static String getPatchedStack(RhinoException ex, String nativeStackTrace) {
		 String tag = ""org.mozilla.javascript.Interpreter.interpretLoop"";
		 StringBuffer sb = new StringBuffer(nativeStackTrace.length() + 1000);
		 String lineSeparator = System.getProperty(""line.separator"");
		 CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;
		 int[] linePC = ex.interpreterLineData;
		 int arrayIndex = array.length;
		 int linePCIndex = linePC.length;
		 int offset = 0;
		 while (arrayIndex != 0) {
			 --arrayIndex;
			 int pos = nativeStackTrace.indexOf(tag, offset);
			 if (pos < 0) {
				 break;
			 }
			 pos += tag.length();
			 for (;
			 pos != nativeStackTrace.length();
			 ++pos) {
				 char c = nativeStackTrace.charAt(pos);
				 if (c == '\n' || c == '\r') {
					 break;
				 }
			 }
			 sb.append(nativeStackTrace.substring(offset, pos));
			 offset = pos;
			 CallFrame frame = array[arrayIndex];
			 while (frame != null) {
				 if (linePCIndex == 0) Kit.codeBug();
				 --linePCIndex;
				 InterpreterData idata = frame.idata;
				 sb.append(lineSeparator);
				 sb.append(""\tat script"");
				 if (idata.itsName != null && idata.itsName.length() != 0) {
					 sb.append('.');
					 sb.append(idata.itsName);
				 }
				 sb.append('(');
				 sb.append(idata.itsSourceFile);
				 int pc = linePC[linePCIndex];
				 if (pc >= 0) {
					 sb.append(':');
					 sb.append(getIndex(idata.itsICode, pc));
				 }
				 sb.append(')');
				 frame = frame.parentFrame;
			 }
		 }
		 sb.append(nativeStackTrace.substring(offset));
		 return sb.toString();
	 }
	 static String getEncodedSource(InterpreterData idata) {
		 if (idata.encodedSource == null) {
			 return null;
		 }
		 return idata.encodedSource.substring(idata.encodedSourceStart, idata.encodedSourceEnd);
	 }
	 private static void initFunction(Context cx, Scriptable scope, InterpretedFunction parent, int index) {
		 InterpretedFunction fn;
		 fn = InterpretedFunction.createFunction(cx, scope, parent, index);
		 ScriptRuntime.initFunction(cx, scope, fn, fn.idata.itsFunctionType, parent.idata.evalScriptFlag);
	 }
	 static Object interpret(InterpretedFunction ifun, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) Kit.codeBug();
		 if (cx.interpreterSecurityDomain != ifun.securityDomain) {
			 Object savedDomain = cx.interpreterSecurityDomain;
			 cx.interpreterSecurityDomain = ifun.securityDomain;
			 try {
				 return ifun.securityController.callWithDomain( ifun.securityDomain, cx, ifun, scope, thisObj, args);
			 }
			 finally {
				 cx.interpreterSecurityDomain = savedDomain;
			 }
		 }
		 CallFrame frame = new CallFrame();
		 initFrame(cx, scope, thisObj, args, null, 0, args.length, ifun, null, frame);
		 return interpretLoop(cx, frame, null);
	 }
	 public static Object restartContinuation(Continuation c, Context cx, Scriptable scope, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) {
			 return ScriptRuntime.doTopCall(c, cx, scope, null, args);
		 }
		 Object arg;
		 if (args.length == 0) {
			 arg = Undefined.instance;
		 }
		 else {
			 arg = args[0];
		 }
		 CallFrame capturedFrame = (CallFrame)c.getImplementation();
		 if (capturedFrame == null) {
			 return arg;
		 }
		 ContinuationJump cjump = new ContinuationJump(c, null);
		 cjump.result = arg;
		 return interpretLoop(cx, null, cjump);
	 }
	 private static Object interpretLoop(Context cx, CallFrame frame, Object throwable) {
		 final Object DBL_MRK = UniqueTag.DOUBLE_MARK;
		 final Object undefined = Undefined.instance;
		 final boolean instructionCounting = (cx.instructionThreshold != 0);
		 final int INVOCATION_COST = 100;
		 final int EXCEPTION_COST = 100;
		 String stringReg = null;
		 int indexReg = -1;
		 if (cx.lastInterpreterFrame != null) {
			 if (cx.previousInterpreterInvocations == null) {
				 cx.previousInterpreterInvocations = new ObjArray();
			 }
			 cx.previousInterpreterInvocations.push(cx.lastInterpreterFrame);
		 }
		 if (throwable != null) {
			 if (!(throwable instanceof ContinuationJump)) {
				 Kit.codeBug();
			 }
		 }
		 Object interpreterResult = null;
		 double interpreterResultDbl = 0.0;
		 StateLoop: for (;
		;
		) {
			 withoutExceptions: try {
				 if (throwable != null) {
					 if (indexReg >= 0) {
						 if (frame.frozen) {
							 frame = frame.cloneFrozen();
						 }
						 int[] table = frame.idata.itsExceptionTable;
						 frame.pc = table[indexReg + EXCEPTION_HANDLER_SLOT];
						 if (instructionCounting) {
							 frame.pcPrevBranch = frame.pc;
						 }
						 frame.savedStackTop = frame.emptyStackTop;
						 int scopeLocal = frame.localShift + table[indexReg + EXCEPTION_SCOPE_SLOT];
						 int exLocal = frame.localShift + table[indexReg + EXCEPTION_LOCAL_SLOT];
						 frame.scope = (Scriptable)frame.stack[scopeLocal];
						 frame.stack[exLocal] = throwable;
						 throwable = null;
					 }
					 else {
						 ContinuationJump cjump = (ContinuationJump)throwable;
						 throwable = null;
						 if (cjump.branchFrame != frame) Kit.codeBug();
						 if (cjump.capturedFrame == null) Kit.codeBug();
						 int rewindCount = cjump.capturedFrame.frameIndex + 1;
						 if (cjump.branchFrame != null) {
							 rewindCount -= cjump.branchFrame.frameIndex;
						 }
						 int enterCount = 0;
						 CallFrame[] enterFrames = null;
						 CallFrame x = cjump.capturedFrame;
						 for (int i = 0;
						 i != rewindCount;
						 ++i) {
							 if (!x.frozen) Kit.codeBug();
							 if (isFrameEnterExitRequired(x)) {
								 if (enterFrames == null) {
									 enterFrames = new CallFrame[rewindCount - i];
								 }
								 enterFrames[enterCount] = x;
								 ++enterCount;
							 }
							 x = x.parentFrame;
						 }
						 while (enterCount != 0) {
							 --enterCount;
							 x = enterFrames[enterCount];
							 enterFrame(cx, x, ScriptRuntime.emptyArgs);
						 }
						 frame = cjump.capturedFrame.cloneFrozen();
						 setCallResult(frame, cjump.result, cjump.resultDbl);
					 }
					 if (throwable != null) Kit.codeBug();
				 }
				 else {
					 if (frame.frozen) Kit.codeBug();
				 }
				 Object[] stack = frame.stack;
				 double[] sDbl = frame.sDbl;
				 Object[] vars = frame.varSource.stack;
				 double[] varDbls = frame.varSource.sDbl;
				 byte[] iCode = frame.idata.itsICode;
				 String[] strings = frame.idata.itsStringTable;
				 int stackTop = frame.savedStackTop;
				 cx.lastInterpreterFrame = frame;
				 Loop: for (;
				;
				) {
					 int op = iCode[frame.pc++];
					 jumplessRun: {
						switch (op) {
							 case Token.THROW: {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int sourceLine = getIndex(iCode, frame.pc);
								 throwable = new JavaScriptException(value, frame.idata.itsSourceFile, sourceLine);
								 break withoutExceptions;
							 }
							 case Token.RETHROW: {
								 indexReg += frame.localShift;
								 throwable = stack[indexReg];
								 break withoutExceptions;
							 }
							 case Token.GE : case Token.LE : case Token.GT : case Token.LT : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 object_compare: {
									 number_compare: {
										 double rDbl, lDbl;
										 if (rhs == DBL_MRK) {
											 rDbl = sDbl[stackTop + 1];
											 lDbl = stack_double(frame, stackTop);
										 }
										 else if (lhs == DBL_MRK) {
											 rDbl = ScriptRuntime.toNumber(rhs);
											 lDbl = sDbl[stackTop];
										 }
										 else {
											 break number_compare;
										 }
										 switch (op) {
											 case Token.GE: valBln = (lDbl >= rDbl);
											 break object_compare;
											 case Token.LE: valBln = (lDbl <= rDbl);
											 break object_compare;
											 case Token.GT: valBln = (lDbl > rDbl);
											 break object_compare;
											 case Token.LT: valBln = (lDbl < rDbl);
											 break object_compare;
											 default: throw Kit.codeBug();
										 }
									 }
									 switch (op) {
										 case Token.GE: valBln = ScriptRuntime.cmp_LE(rhs, lhs);
										 break;
										 case Token.LE: valBln = ScriptRuntime.cmp_LE(lhs, rhs);
										 break;
										 case Token.GT: valBln = ScriptRuntime.cmp_LT(rhs, lhs);
										 break;
										 case Token.LT: valBln = ScriptRuntime.cmp_LT(lhs, rhs);
										 break;
										 default: throw Kit.codeBug();
									 }
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IN : case Token.INSTANCEOF : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 boolean valBln;
								 if (op == Token.IN) {
									 valBln = ScriptRuntime.in(lhs, rhs, cx);
								 }
								 else {
									 valBln = ScriptRuntime.instanceOf(lhs, rhs, cx);
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.EQ : case Token.NE : {
								 --stackTop;
								 boolean valBln;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 if (rhs == DBL_MRK) {
									 if (lhs == DBL_MRK) {
										 valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
									 }
									 else {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
									 }
								 }
								 else {
									 if (lhs == DBL_MRK) {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
									 }
									 else {
										 valBln = ScriptRuntime.eq(lhs, rhs);
									 }
								 }
								 valBln ^= (op == Token.NE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.SHEQ : case Token.SHNE : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 shallow_compare: {
									 double rdbl, ldbl;
									 if (rhs == DBL_MRK) {
										 rdbl = sDbl[stackTop + 1];
										 if (lhs == DBL_MRK) {
											 ldbl = sDbl[stackTop];
										 }
										 else if (lhs instanceof Number) {
											 ldbl = ((Number)lhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else if (lhs == DBL_MRK) {
										 ldbl = sDbl[stackTop];
										 if (rhs == DBL_MRK) {
											 rdbl = sDbl[stackTop + 1];
										 }
										 else if (rhs instanceof Number) {
											 rdbl = ((Number)rhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else {
										 valBln = ScriptRuntime.shallowEq(lhs, rhs);
										 break shallow_compare;
									 }
									 valBln = (ldbl == rdbl);
								 }
								 valBln ^= (op == Token.SHNE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IFNE : if (stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Token.IFEQ : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Icode_IFEQ_POP : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 stack[stackTop--] = null;
							 break jumplessRun;
							 case Token.GOTO : break jumplessRun;
							 case Icode_GOSUB : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.pc + 2;
							 break jumplessRun;
							 case Icode_STARTSUB : if (stackTop == frame.emptyStackTop + 1) {
								 indexReg += frame.localShift;
								 stack[indexReg] = stack[stackTop];
								 sDbl[indexReg] = sDbl[stackTop];
								 --stackTop;
							 }
							 else {
								 if (stackTop != frame.emptyStackTop) Kit.codeBug();
							 }
							 continue Loop;
							 case Icode_RETSUB : {
								 if (instructionCounting) {
									 addInstructionCount(cx, frame, 0);
								 }
								 indexReg += frame.localShift;
								 Object value = stack[indexReg];
								 if (value != DBL_MRK) {
									 throwable = value;
									 break withoutExceptions;
								 }
								 frame.pc = (int)sDbl[indexReg];
								 if (instructionCounting) {
									 frame.pcPrevBranch = frame.pc;
								 }
								 continue Loop;
							 }
							 case Icode_POP : stack[stackTop] = null;
							 stackTop--;
							 continue Loop;
							 case Icode_POP_RESULT : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 stack[stackTop] = null;
							 --stackTop;
							 continue Loop;
							 case Icode_DUP : stack[stackTop + 1] = stack[stackTop];
							 sDbl[stackTop + 1] = sDbl[stackTop];
							 stackTop++;
							 continue Loop;
							 case Icode_DUP2 : stack[stackTop + 1] = stack[stackTop - 1];
							 sDbl[stackTop + 1] = sDbl[stackTop - 1];
							 stack[stackTop + 2] = stack[stackTop];
							 sDbl[stackTop + 2] = sDbl[stackTop];
							 stackTop += 2;
							 continue Loop;
							 case Icode_SWAP : {
								 Object o = stack[stackTop];
								 stack[stackTop] = stack[stackTop - 1];
								 stack[stackTop - 1] = o;
								 double d = sDbl[stackTop];
								 sDbl[stackTop] = sDbl[stackTop - 1];
								 sDbl[stackTop - 1] = d;
								 continue Loop;
							 }
							 case Token.RETURN : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 --stackTop;
							 break Loop;
							 case Token.RETURN_RESULT : break Loop;
							 case Icode_RETUNDEF : frame.result = undefined;
							 break Loop;
							 case Token.BITNOT : {
								 int rIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ~rIntValue;
								 continue Loop;
							 }
							 case Token.BITAND : case Token.BITOR : case Token.BITXOR : case Token.LSH : case Token.RSH : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.BITAND: lIntValue &= rIntValue;
									 break;
									 case Token.BITOR: lIntValue |= rIntValue;
									 break;
									 case Token.BITXOR: lIntValue ^= rIntValue;
									 break;
									 case Token.LSH: lIntValue <<= rIntValue;
									 break;
									 case Token.RSH: lIntValue >>= rIntValue;
									 break;
								 }
								 sDbl[stackTop] = lIntValue;
								 continue Loop;
							 }
							 case Token.URSH : {
								 int rIntValue = stack_int32(frame, stackTop) & 0x1F;
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;
								 continue Loop;
							 }
							 case Token.NEG : case Token.POS : {
								 double rDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 if (op == Token.NEG) {
									 rDbl = -rDbl;
								 }
								 sDbl[stackTop] = rDbl;
								 continue Loop;
							 }
							 case Token.ADD : --stackTop;
							 do_add(stack, sDbl, stackTop, cx);
							 continue Loop;
							 case Token.SUB : case Token.MUL : case Token.DIV : case Token.MOD : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.SUB: lDbl -= rDbl;
									 break;
									 case Token.MUL: lDbl *= rDbl;
									 break;
									 case Token.DIV: lDbl /= rDbl;
									 break;
									 case Token.MOD: lDbl %= rDbl;
									 break;
								 }
								 sDbl[stackTop] = lDbl;
								 continue Loop;
							 }
							 case Token.NOT : stack[stackTop] = ScriptRuntime.wrapBoolean( !stack_boolean(frame, stackTop));
							 continue Loop;
							 case Token.BINDNAME : stack[++stackTop] = ScriptRuntime.bind(cx, frame.scope, stringReg);
							 continue Loop;
							 case Token.SETNAME : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable lhs = (Scriptable)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx, frame.scope, stringReg);
								 continue Loop;
							 }
							 case Token.DELPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.delete(lhs, rhs, cx);
								 continue Loop;
							 }
							 case Token.GETPROP : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getObjectProp(lhs, stringReg, cx);
								 continue Loop;
							 }
							 case Token.SETPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setObjectProp(lhs, stringReg, rhs, cx);
								 continue Loop;
							 }
							 case Icode_PROP_INC_DEC : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.propIncrDecr(lhs, stringReg, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GETELEM : {
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.getObjectElem(lhs, id, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.getObjectIndex(lhs, d, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Token.SETELEM : {
								 stackTop -= 2;
								 Object rhs = stack[stackTop + 2];
								 if (rhs == DBL_MRK) {
									 rhs = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);
								 }
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.setObjectElem(lhs, id, rhs, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.setObjectIndex(lhs, d, rhs, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Icode_ELEM_INC_DEC: {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.elemIncrDecr(lhs, rhs, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GET_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refGet(ref, cx);
								 continue Loop;
							 }
							 case Token.SET_REF : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refSet(ref, value, cx);
								 continue Loop;
							 }
							 case Token.DEL_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refDel(ref, cx);
								 continue Loop;
							 }
							 case Icode_REF_INC_DEC : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refIncrDecr(ref, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.LOCAL_LOAD : ++stackTop;
							 indexReg += frame.localShift;
							 stack[stackTop] = stack[indexReg];
							 sDbl[stackTop] = sDbl[indexReg];
							 continue Loop;
							 case Icode_LOCAL_CLEAR : indexReg += frame.localShift;
							 stack[indexReg] = null;
							 continue Loop;
							 case Icode_NAME_AND_THIS : ++stackTop;
							 stack[stackTop] = ScriptRuntime.getNameFunctionAndThis(stringReg, cx, frame.scope);
							 ++stackTop;
							 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
							 continue Loop;
							 case Icode_PROP_AND_THIS: {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getPropFunctionAndThis(obj, stringReg, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_ELEM_AND_THIS: {
								 Object obj = stack[stackTop - 1];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop - 1]);
								 Object id = stack[stackTop];
								 if (id == DBL_MRK) id = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop - 1] = ScriptRuntime.getElemFunctionAndThis(obj, id, cx);
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_VALUE_AND_THIS : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getValueFunctionAndThis(value, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_CALLSPECIAL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 int callType = iCode[frame.pc] & 0xFF;
								 boolean isNew = (iCode[frame.pc + 1] != 0);
								 int sourceLine = getIndex(iCode, frame.pc + 2);
								 if (isNew) {
									 stackTop -= indexReg;
									 Object function = stack[stackTop];
									 if (function == DBL_MRK) function = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 1, indexReg);
									 stack[stackTop] = ScriptRuntime.newSpecial( cx, function, outArgs, frame.scope, callType);
								 }
								 else {
									 stackTop -= 1 + indexReg;
									 Scriptable functionThis = (Scriptable)stack[stackTop + 1];
									 Callable function = (Callable)stack[stackTop];
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callSpecial( cx, function, functionThis, outArgs, frame.scope, frame.thisObj, callType, frame.idata.itsSourceFile, sourceLine);
								 }
								 frame.pc += 4;
								 continue Loop;
							 }
							 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= 1 + indexReg;
								 Callable fun = (Callable)stack[stackTop];
								 Scriptable funThisObj = (Scriptable)stack[stackTop + 1];
								 if (op == Token.REF_CALL) {
									 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callRef(fun, funThisObj, outArgs, cx);
									 continue Loop;
								 }
								 Scriptable calleeScope = frame.scope;
								 if (frame.useActivation) {
									 calleeScope = ScriptableObject.getTopLevelScope(frame.scope);
								 }
								 if (fun instanceof InterpretedFunction) {
									 InterpretedFunction ifun = (InterpretedFunction)fun;
									 if (frame.fnOrScript.securityDomain == ifun.securityDomain) {
										 CallFrame callParentFrame = frame;
										 CallFrame calleeFrame = new CallFrame();
										 if (op == Icode_TAIL_CALL) {
											 callParentFrame = frame.parentFrame;
										 }
										 initFrame(cx, calleeScope, funThisObj, stack, sDbl, stackTop + 2, indexReg, ifun, callParentFrame, calleeFrame);
										 if (op == Icode_TAIL_CALL) {
											 exitFrame(cx, frame, null);
										 }
										 else {
											 frame.savedStackTop = stackTop;
											 frame.savedCallOp = op;
										 }
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (fun instanceof Continuation) {
									 ContinuationJump cjump;
									 cjump = new ContinuationJump((Continuation)fun, frame);
									 if (indexReg == 0) {
										 cjump.result = undefined;
									 }
									 else {
										 cjump.result = stack[stackTop + 2];
										 cjump.resultDbl = sDbl[stackTop + 2];
									 }
									 throwable = cjump;
									 break withoutExceptions;
								 }
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
								 stack[stackTop] = fun.call(cx, calleeScope, funThisObj, outArgs);
								 continue Loop;
							 }
							 case Token.NEW : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= indexReg;
								 Object lhs = stack[stackTop];
								 if (lhs instanceof InterpretedFunction) {
									 InterpretedFunction f = (InterpretedFunction)lhs;
									 if (frame.fnOrScript.securityDomain == f.securityDomain) {
										 Scriptable newInstance = f.createObject(cx, frame.scope);
										 CallFrame calleeFrame = new CallFrame();
										 initFrame(cx, frame.scope, newInstance, stack, sDbl, stackTop + 1, indexReg, f, frame, calleeFrame);
										 stack[stackTop] = newInstance;
										 frame.savedStackTop = stackTop;
										 frame.savedCallOp = op;
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (!(lhs instanceof Function)) {
									 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 throw ScriptRuntime.notFunctionError(lhs);
								 }
								 Function fun = (Function)lhs;
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 1, indexReg);
								 stack[stackTop] = fun.construct(cx, frame.scope, outArgs);
								 continue Loop;
							 }
							 case Token.TYPEOF : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.typeof(lhs);
								 continue Loop;
							 }
							 case Icode_TYPEOFNAME : stack[++stackTop] = ScriptRuntime.typeofName(frame.scope, stringReg);
							 continue Loop;
							 case Token.STRING : stack[++stackTop] = stringReg;
							 continue Loop;
							 case Icode_SHORTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getShort(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_INTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Token.NUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.idata.itsDoubleTable[indexReg];
							 continue Loop;
							 case Token.NAME : stack[++stackTop] = ScriptRuntime.name(cx, frame.scope, stringReg);
							 continue Loop;
							 case Icode_NAME_INC_DEC : stack[++stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, stringReg, iCode[frame.pc]);
							 ++frame.pc;
							 continue Loop;
							 case Icode_SETVAR1: indexReg = iCode[frame.pc++];
							 case Token.SETVAR : if (!frame.useActivation) {
								 vars[indexReg] = stack[stackTop];
								 varDbls[indexReg] = sDbl[stackTop];
							 }
							 else {
								 Object val = stack[stackTop];
								 if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stringReg = frame.idata.argNames[indexReg];
								 frame.scope.put(stringReg, frame.scope, val);
							 }
							 continue Loop;
							 case Icode_GETVAR1: indexReg = iCode[frame.pc++];
							 case Token.GETVAR : ++stackTop;
							 if (!frame.useActivation) {
								 stack[stackTop] = vars[indexReg];
								 sDbl[stackTop] = varDbls[indexReg];
							 }
							 else {
								 stringReg = frame.idata.argNames[indexReg];
								 stack[stackTop] = frame.scope.get(stringReg, frame.scope);
							 }
							 continue Loop;
							 case Icode_VAR_INC_DEC : {
								 ++stackTop;
								 int incrDecrMask = iCode[frame.pc];
								 if (!frame.useActivation) {
									 stack[stackTop] = DBL_MRK;
									 Object varValue = vars[indexReg];
									 double d;
									 if (varValue == DBL_MRK) {
										 d = varDbls[indexReg];
									 }
									 else {
										 d = ScriptRuntime.toNumber(varValue);
										 vars[indexReg] = DBL_MRK;
									 }
									 double d2 = ((incrDecrMask & Node.DECR_FLAG) == 0) ? d + 1.0 : d - 1.0;
									 varDbls[indexReg] = d2;
									 sDbl[stackTop] = ((incrDecrMask & Node.POST_FLAG) == 0) ? d2 : d;
								 }
								 else {
									 String varName = frame.idata.argNames[indexReg];
									 stack[stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, varName, incrDecrMask);
								 }
								 ++frame.pc;
								 continue Loop;
							 }
							 case Icode_ZERO : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_ONE : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 1;
							 continue Loop;
							 case Token.NULL : stack[++stackTop] = null;
							 continue Loop;
							 case Token.THIS : stack[++stackTop] = frame.thisObj;
							 continue Loop;
							 case Token.THISFN : stack[++stackTop] = frame.fnOrScript;
							 continue Loop;
							 case Token.FALSE : stack[++stackTop] = Boolean.FALSE;
							 continue Loop;
							 case Token.TRUE : stack[++stackTop] = Boolean.TRUE;
							 continue Loop;
							 case Icode_UNDEF : stack[++stackTop] = undefined;
							 continue Loop;
							 case Token.ENTERWITH : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterWith(lhs, cx, frame.scope);
								 continue Loop;
							 }
							 case Token.LEAVEWITH : frame.scope = ScriptRuntime.leaveWith(frame.scope);
							 continue Loop;
							 case Token.CATCH_SCOPE : {
								 --stackTop;
								 indexReg += frame.localShift;
								 boolean afterFirstScope = (frame.idata.itsICode[frame.pc] != 0);
								 Throwable caughtException = (Throwable)stack[stackTop + 1];
								 Scriptable lastCatchScope;
								 if (!afterFirstScope) {
									 lastCatchScope = null;
								 }
								 else {
									 lastCatchScope = (Scriptable)stack[indexReg];
								 }
								 stack[indexReg] = ScriptRuntime.newCatchScope(caughtException, lastCatchScope, stringReg, cx, frame.scope);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.ENUM_INIT_KEYS : case Token.ENUM_INIT_VALUES : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 indexReg += frame.localShift;
								 stack[indexReg] = ScriptRuntime.enumInit( lhs, cx, (op == Token.ENUM_INIT_VALUES));
								 continue Loop;
							 }
							 case Token.ENUM_NEXT : case Token.ENUM_ID : {
								 indexReg += frame.localShift;
								 Object val = stack[indexReg];
								 ++stackTop;
								 stack[stackTop] = (op == Token.ENUM_NEXT) ? (Object)ScriptRuntime.enumNext(val) : (Object)ScriptRuntime.enumId(val, cx);
								 continue Loop;
							 }
							 case Token.REF_SPECIAL : {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.specialRef(obj, stringReg, cx);
								 continue Loop;
							 }
							 case Token.REF_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, ns, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(ns, name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Icode_SCOPE_LOAD : indexReg += frame.localShift;
							 frame.scope = (Scriptable)stack[indexReg];
							 continue Loop;
							 case Icode_SCOPE_SAVE : indexReg += frame.localShift;
							 stack[indexReg] = frame.scope;
							 continue Loop;
							 case Icode_CLOSURE_EXPR : stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Icode_CLOSURE_STMT : initFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Token.REGEXP : stack[++stackTop] = frame.scriptRegExps[indexReg];
							 continue Loop;
							 case Icode_LITERAL_NEW : ++stackTop;
							 stack[stackTop] = new Object[indexReg];
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_LITERAL_SET : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Token.ARRAYLIT : case Icode_SPARE_ARRAYLIT : case Token.OBJECTLIT : {
								 Object[] data = (Object[])stack[stackTop];
								 Object val;
								 if (op == Token.OBJECTLIT) {
									 Object[] ids = (Object[])frame.idata.literalIds[indexReg];
									 val = ScriptRuntime.newObjectLiteral(ids, data, cx, frame.scope);
								 }
								 else {
									 int[] skipIndexces = null;
									 if (op == Icode_SPARE_ARRAYLIT) {
										 skipIndexces = (int[])frame.idata.literalIds[indexReg];
									 }
									 val = ScriptRuntime.newArrayLiteral(data, skipIndexces, cx, frame.scope);
								 }
								 stack[stackTop] = val;
								 continue Loop;
							 }
							 case Icode_ENTERDQ : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterDotQuery(lhs, frame.scope);
								 continue Loop;
							 }
							 case Icode_LEAVEDQ : {
								 boolean valBln = stack_boolean(frame, stackTop);
								 Object x = ScriptRuntime.updateDotQuery(valBln, frame.scope);
								 if (x != null) {
									 stack[stackTop] = x;
									 frame.scope = ScriptRuntime.leaveDotQuery(frame.scope);
									 frame.pc += 2;
									 continue Loop;
								 }
								 --stackTop;
								 break jumplessRun;
							 }
							 case Token.DEFAULTNAMESPACE : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setDefaultNamespace(value, cx);
								 continue Loop;
							 }
							 case Token.ESCXMLATTR : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeAttributeValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Token.ESCXMLTEXT : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeTextValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Icode_LINE : frame.pcSourceLineStart = frame.pc;
							 if (frame.debuggerFrame != null) {
								 int line = getIndex(iCode, frame.pc);
								 frame.debuggerFrame.onLineChange(cx, line);
							 }
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND_C0: indexReg = 0;
							 continue Loop;
							 case Icode_REG_IND_C1: indexReg = 1;
							 continue Loop;
							 case Icode_REG_IND_C2: indexReg = 2;
							 continue Loop;
							 case Icode_REG_IND_C3: indexReg = 3;
							 continue Loop;
							 case Icode_REG_IND_C4: indexReg = 4;
							 continue Loop;
							 case Icode_REG_IND_C5: indexReg = 5;
							 continue Loop;
							 case Icode_REG_IND1: indexReg = 0xFF & iCode[frame.pc];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_IND2: indexReg = getIndex(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND4: indexReg = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Icode_REG_STR_C0: stringReg = strings[0];
							 continue Loop;
							 case Icode_REG_STR_C1: stringReg = strings[1];
							 continue Loop;
							 case Icode_REG_STR_C2: stringReg = strings[2];
							 continue Loop;
							 case Icode_REG_STR_C3: stringReg = strings[3];
							 continue Loop;
							 case Icode_REG_STR1: stringReg = strings[0xFF & iCode[frame.pc]];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_STR2: stringReg = strings[getIndex(iCode, frame.pc)];
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_STR4: stringReg = strings[getInt(iCode, frame.pc)];
							 frame.pc += 4;
							 continue Loop;
							 default : dumpICode(frame.idata);
							 throw new RuntimeException( ""Unknown icode : ""+op+"" @ pc : ""+(frame.pc-1));
						}
					 }
					 if (instructionCounting) {
						 addInstructionCount(cx, frame, 2);
					 }
					 int offset = getShort(iCode, frame.pc);
					 if (offset != 0) {
						 frame.pc += offset - 1;
					 }
					 else {
						 frame.pc = frame.idata.longJumps. getExistingInt(frame.pc);
					 }
					 if (instructionCounting) {
						 frame.pcPrevBranch = frame.pc;
					 }
					 continue Loop;
				 }
				 exitFrame(cx, frame, null);
				 interpreterResult = frame.result;
				 interpreterResultDbl = frame.resultDbl;
				 if (frame.parentFrame != null) {
					 frame = frame.parentFrame;
					 if (frame.frozen) {
						 frame = frame.cloneFrozen();
					 }
					 setCallResult( frame, interpreterResult, interpreterResultDbl);
					 interpreterResult = null;
					 continue StateLoop;
				 }
				 break StateLoop;
			 }
			 catch (Throwable ex) {
				 if (throwable != null) {
					 ex.printStackTrace(System.err);
					 throw new IllegalStateException();
				 }
				 throwable = ex;
			 }
			 if (throwable == null) Kit.codeBug();
			 final int EX_CATCH_STATE = 2;
			 final int EX_FINALLY_STATE = 1;
			 final int EX_NO_JS_STATE = 0;
			 int exState;
			 ContinuationJump cjump = null;
			 if (throwable instanceof JavaScriptException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EcmaError) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EvaluatorException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof RuntimeException) {
				 exState = EX_FINALLY_STATE;
			 }
			 else if (throwable instanceof Error) {
				 exState = EX_NO_JS_STATE;
			 }
			 else {
				 exState = EX_FINALLY_STATE;
				 cjump = (ContinuationJump)throwable;
			 }
			 if (instructionCounting) {
				 try {
					 addInstructionCount(cx, frame, EXCEPTION_COST);
				 }
				 catch (RuntimeException ex) {
					 throwable = ex;
					 exState = EX_FINALLY_STATE;
				 }
				 catch (Error ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 if (frame.debuggerFrame != null && throwable instanceof RuntimeException) {
				 RuntimeException rex = (RuntimeException)throwable;
				 try {
					 frame.debuggerFrame.onExceptionThrown(cx, rex);
				 }
				 catch (Throwable ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 for (;
			;
			) {
				 if (exState != EX_NO_JS_STATE) {
					 boolean onlyFinally = (exState != EX_CATCH_STATE);
					 indexReg = getExceptionHandler(frame, onlyFinally);
					 if (indexReg >= 0) {
						 continue StateLoop;
					 }
				 }
				 exitFrame(cx, frame, throwable);
				 frame = frame.parentFrame;
				 if (frame == null) {
					 break;
				 }
				 if (cjump != null && cjump.branchFrame == frame) {
					 indexReg = -1;
					 continue StateLoop;
				 }
			 }
			 if (cjump != null) {
				 if (cjump.branchFrame != null) {
					 Kit.codeBug();
				 }
				 if (cjump.capturedFrame != null) {
					 indexReg = -1;
					 continue StateLoop;
				 }
				 interpreterResult = cjump.result;
				 interpreterResultDbl = cjump.resultDbl;
				 throwable = null;
			 }
			 break StateLoop;
		 }
		 if (cx.previousInterpreterInvocations != null && cx.previousInterpreterInvocations.size() != 0) {
			 cx.lastInterpreterFrame = cx.previousInterpreterInvocations.pop();
		 }
		 else {
			 cx.lastInterpreterFrame = null;
			 cx.previousInterpreterInvocations = null;
		 }
		 if (throwable != null) {
			 if (throwable instanceof RuntimeException) {
				 throw (RuntimeException)throwable;
			 }
			 else {
				 throw (Error)throwable;
			 }
		 }
		 return (interpreterResult != DBL_MRK) ? interpreterResult : ScriptRuntime.wrapNumber(interpreterResultDbl);
	 }
	 private static void initFrame(Context cx, Scriptable callerScope, Scriptable thisObj, Object[] args, double[] argsDbl, int argShift, int argCount, InterpretedFunction fnOrScript, CallFrame parentFrame, CallFrame frame) {
		 InterpreterData idata = fnOrScript.idata;
		 boolean useActivation = idata.itsNeedsActivation;
		 DebugFrame debuggerFrame = null;
		 if (cx.debugger != null) {
			 debuggerFrame = cx.debugger.getFrame(cx, idata);
			 if (debuggerFrame != null) {
				 useActivation = true;
			 }
		 }
		 if (useActivation) {
			 if (argsDbl != null) {
				 args = getArgsArray(args, argsDbl, argShift, argCount);
			 }
			 argShift = 0;
			 argsDbl = null;
		 }
		 Scriptable scope;
		 if (idata.itsFunctionType != 0) {
			 if (!idata.useDynamicScope) {
				 scope = fnOrScript.getParentScope();
			 }
			 else {
				 scope = callerScope;
			 }
			 if (useActivation) {
				 scope = ScriptRuntime.createFunctionActivation( fnOrScript, scope, args);
			 }
		 }
		 else {
			 scope = callerScope;
			 ScriptRuntime.initScript(fnOrScript, thisObj, cx, scope, fnOrScript.idata.evalScriptFlag);
		 }
		 if (idata.itsNestedFunctions != null) {
			 if (idata.itsFunctionType != 0 && !idata.itsNeedsActivation) Kit.codeBug();
			 for (int i = 0;
			 i < idata.itsNestedFunctions.length;
			 i++) {
				 InterpreterData fdata = idata.itsNestedFunctions[i];
				 if (fdata.itsFunctionType == FunctionNode.FUNCTION_STATEMENT) {
					 initFunction(cx, scope, fnOrScript, i);
				 }
			 }
		 }
		 Scriptable[] scriptRegExps = null;
		 if (idata.itsRegExpLiterals != null) {
			 if (idata.itsFunctionType != 0) {
				 scriptRegExps = fnOrScript.functionRegExps;
			 }
			 else {
				 scriptRegExps = fnOrScript.createRegExpWraps(cx, scope);
			 }
		 }
		 int emptyStackTop = idata.itsMaxVars + idata.itsMaxLocals - 1;
		 int maxFrameArray = idata.itsMaxFrameArray;
		 if (maxFrameArray != emptyStackTop + idata.itsMaxStack + 1) Kit.codeBug();
		 Object[] stack;
		 double[] sDbl;
		 boolean stackReuse;
		 if (frame.stack != null && maxFrameArray <= frame.stack.length) {
			 stackReuse = true;
			 stack = frame.stack;
			 sDbl = frame.sDbl;
		 }
		 else {
			 stackReuse = false;
			 stack = new Object[maxFrameArray];
			 sDbl = new double[maxFrameArray];
		 }
		 int definedArgs = idata.argCount;
		 if (definedArgs > argCount) {
			 definedArgs = argCount;
		 }
		 frame.parentFrame = parentFrame;
		 frame.frameIndex = (parentFrame == null) ? 0 : parentFrame.frameIndex + 1;
		 frame.frozen = false;
		 frame.fnOrScript = fnOrScript;
		 frame.idata = idata;
		 frame.stack = stack;
		 frame.sDbl = sDbl;
		 frame.varSource = frame;
		 frame.localShift = idata.itsMaxVars;
		 frame.emptyStackTop = emptyStackTop;
		 frame.debuggerFrame = debuggerFrame;
		 frame.useActivation = useActivation;
		 frame.thisObj = thisObj;
		 frame.scriptRegExps = scriptRegExps;
		 frame.result = Undefined.instance;
		 frame.pc = 0;
		 frame.pcPrevBranch = 0;
		 frame.pcSourceLineStart = idata.firstLinePC;
		 frame.scope = scope;
		 frame.savedStackTop = emptyStackTop;
		 frame.savedCallOp = 0;
		 System.arraycopy(args, argShift, stack, 0, definedArgs);
		 if (argsDbl != null) {
			 System.arraycopy(argsDbl, argShift, sDbl, 0, definedArgs);
		 }
		 for (int i = definedArgs;
		 i != idata.itsMaxVars;
		 ++i) {
			 stack[i] = Undefined.instance;
		 }
		 if (stackReuse) {
			 for (int i = emptyStackTop + 1;
			 i != stack.length;
			 ++i) {
				 stack[i] = null;
			 }
		 }
		 enterFrame(cx, frame, args);
	 }
	 private static boolean isFrameEnterExitRequired(CallFrame frame) {
		 return frame.debuggerFrame != null || frame.idata.itsNeedsActivation;
	 }
	 private static void enterFrame(Context cx, CallFrame frame, Object[] args) {
		 if (frame.debuggerFrame != null) {
			 frame.debuggerFrame.onEnter(cx, frame.scope, frame.thisObj, args);
		 }
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.enterActivationFunction(cx, frame.scope);
		 }
	 }
	 private static void exitFrame(Context cx, CallFrame frame, Object throwable) {
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.exitActivationFunction(cx);
		 }
		 if (frame.debuggerFrame != null) {
			 try {
				 if (throwable instanceof Throwable) {
					 frame.debuggerFrame.onExit(cx, true, throwable);
				 }
				 else {
					 Object result;
					 ContinuationJump cjump = (ContinuationJump)throwable;
					 if (cjump == null) {
						 result = frame.result;
					 }
					 else {
						 result = cjump.result;
					 }
					 if (result == UniqueTag.DOUBLE_MARK) {
						 double resultDbl;
						 if (cjump == null) {
							 resultDbl = frame.resultDbl;
						 }
						 else {
							 resultDbl = cjump.resultDbl;
						 }
						 result = ScriptRuntime.wrapNumber(resultDbl);
					 }
					 frame.debuggerFrame.onExit(cx, false, result);
				 }
			 }
			 catch (Throwable ex) {
				 System.err.println(""RHINO USAGE WARNING: onExit terminated with exception"");
				 ex.printStackTrace(System.err);
			 }
		 }
	 }
	 private static void setCallResult(CallFrame frame, Object callResult, double callResultDbl) {
		 if (frame.savedCallOp == Token.CALL) {
			 frame.stack[frame.savedStackTop] = callResult;
			 frame.sDbl[frame.savedStackTop] = callResultDbl;
		 }
		 else if (frame.savedCallOp == Token.NEW) {
			 if (callResult instanceof Scriptable) {
				 frame.stack[frame.savedStackTop] = callResult;
			 }
		 }
		 else {
			 Kit.codeBug();
		 }
		 frame.savedCallOp = 0;
	 }
	 private static void captureContinuation(Context cx, CallFrame frame, int stackTop) {
		 Continuation c = new Continuation();
		 ScriptRuntime.setObjectProtoAndParent( c, ScriptRuntime.getTopCallScope(cx));
		 CallFrame x = frame.parentFrame;
		 while (x != null && !x.frozen) {
			 x.frozen = true;
			 for (int i = x.savedStackTop + 1;
			 i != x.stack.length;
			 ++i) {
				 x.stack[i] = null;
			 }
			 if (x.savedCallOp == Token.CALL) {
				 x.stack[x.savedStackTop] = null;
			 }
			 else {
				 if (x.savedCallOp != Token.NEW) Kit.codeBug();
			 }
			 x = x.parentFrame;
		 }
		 c.initImplementation(frame.parentFrame);
		 frame.stack[stackTop] = c;
	 }
	 private static int stack_int32(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 double value;
		 if (x == UniqueTag.DOUBLE_MARK) {
			 value = frame.sDbl[i];
		 }
		 else {
			 value = ScriptRuntime.toNumber(x);
		 }
		 return ScriptRuntime.toInt32(value);
	 }
	 private static double stack_double(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x != UniqueTag.DOUBLE_MARK) {
			 return ScriptRuntime.toNumber(x);
		 }
		 else {
			 return frame.sDbl[i];
		 }
	 }
	 private static boolean stack_boolean(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x == Boolean.TRUE) {
			 return true;
		 }
		 else if (x == Boolean.FALSE) {
			 return false;
		 }
		 else if (x == UniqueTag.DOUBLE_MARK) {
			 double d = frame.sDbl[i];
			 return d == d && d != 0.0;
		 }
		 else if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 double d = ((Number)x).doubleValue();
			 return (d == d && d != 0.0);
		 }
		 else if (x instanceof Boolean) {
			 return ((Boolean)x).booleanValue();
		 }
		 else {
			 return ScriptRuntime.toBoolean(x);
		 }
	 }
	 private static void do_add(Object[] stack, double[] sDbl, int stackTop, Context cx) {
		 Object rhs = stack[stackTop + 1];
		 Object lhs = stack[stackTop];
		 double d;
		 boolean leftRightOrder;
		 if (rhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop + 1];
			 if (lhs == UniqueTag.DOUBLE_MARK) {
				 sDbl[stackTop] += d;
				 return;
			 }
			 leftRightOrder = true;
		 }
		 else if (lhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop];
			 lhs = rhs;
			 leftRightOrder = false;
		 }
		 else {
			 if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
				 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
			 }
			 else if (lhs instanceof String) {
				 String lstr = (String)lhs;
				 String rstr = ScriptRuntime.toString(rhs);
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else if (rhs instanceof String) {
				 String lstr = ScriptRuntime.toString(lhs);
				 String rstr = (String)rhs;
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
				 double rDbl = (rhs instanceof Number) ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
				 stack[stackTop] = UniqueTag.DOUBLE_MARK;
				 sDbl[stackTop] = lDbl + rDbl;
			 }
			 return;
		 }
		 if (lhs instanceof Scriptable) {
			 rhs = ScriptRuntime.wrapNumber(d);
			 if (!leftRightOrder) {
				 Object tmp = lhs;
				 lhs = rhs;
				 rhs = tmp;
			 }
			 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
		 }
		 else if (lhs instanceof String) {
			 String lstr = (String)lhs;
			 String rstr = ScriptRuntime.toString(d);
			 if (leftRightOrder) {
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 stack[stackTop] = rstr.concat(lstr);
			 }
		 }
		 else {
			 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
			 stack[stackTop] = UniqueTag.DOUBLE_MARK;
			 sDbl[stackTop] = lDbl + d;
		 }
	 }
	 private static Object[] getArgsArray(Object[] stack, double[] sDbl, int shift, int count) {
		 if (count == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] args = new Object[count];
		 for (int i = 0;
		 i != count;
		 ++i, ++shift) {
			 Object val = stack[shift];
			 if (val == UniqueTag.DOUBLE_MARK) {
				 val = ScriptRuntime.wrapNumber(sDbl[shift]);
			 }
			 args[i] = val;
		 }
		 return args;
	 }
	 private static void addInstructionCount(Context cx, CallFrame frame, int extra) {
		 cx.instructionCount += frame.pc - frame.pcPrevBranch + extra;
		 if (cx.instructionCount > cx.instructionThreshold) {
			 cx.observeInstructionCount(cx.instructionCount);
			 cx.instructionCount = 0;
		 }
	 }
}",1,0,0,0
"public class Generics{
	private Generics(){
	}
	public static <T> Iterator<T> iterator(Iterator<?> delegate){
		return (Iterator<T>)delegate;
	}
	public static <T> IModel<T> model(IModel<?> model){
		return (IModel<T>)model;
	}
	public static <K, V> HashMap<K, V> newHashMap(){
		return new HashMap<K, V>();
	}
	public static <K, V> HashMap<K, V> newHashMap(int capacity){
		return new HashMap<K, V>(capacity);
	}
	public static <T> ArrayList<T> newArrayList(int capacity){
		return new ArrayList<T>(capacity);
	}
	public static <T> ArrayList<T> newArrayList(){
		return new ArrayList<T>();
	}
	public static <K, V> ConcurrentHashMap<K, V> newConcurrentHashMap(){
		return new ConcurrentHashMap<K, V>();
	}
	public static <K, V> ConcurrentHashMap<K, V> newConcurrentHashMap(int initialCapacity){
		return new ConcurrentHashMap<K, V>(initialCapacity);
	}
}",0,0,0,0
"public interface MetricsIndexerSource extends BaseSource {
	 String METRICS_NAME = ""PhoenixIndexer"";
	 String METRICS_CONTEXT = ""phoenix"";
	 String METRICS_DESCRIPTION = ""Metrics about the Phoenix Indexer"";
	 String METRICS_JMX_CONTEXT = ""RegionServer,sub="" + METRICS_NAME;
	 String INDEX_PREPARE_TIME = ""indexPrepareTime"";
	 String INDEX_PREPARE_TIME_DESC = ""Histogram for the time in milliseconds for preparing an index write"";
	 String SLOW_INDEX_PREPARE = ""slowIndexPrepareCalls"";
	 String SLOW_INDEX_PREPARE_DESC = ""The number of index preparations slower than the configured threshold"";
	 String INDEX_WRITE_TIME = ""indexWriteTime"";
	 String INDEX_WRITE_TIME_DESC = ""Histogram for the time in milliseconds for writing an index update"";
	 String SLOW_INDEX_WRITE = ""slowIndexWriteCalls"";
	 String SLOW_INDEX_WRITE_DESC = ""The number of index writes slower than the configured threshold"";
	 String DUPLICATE_KEY_TIME = ""duplicateKeyCheckTime"";
	 String DUPLICATE_KEY_TIME_DESC = ""Histogram for the time in milliseconds to handle ON DUPLICATE keywords"";
	 String SLOW_DUPLICATE_KEY = ""slowDuplicateKeyCheckCalls"";
	 String SLOW_DUPLICATE_KEY_DESC = ""The number of on duplicate key checks slower than the configured threshold"";
	 String PRE_WAL_RESTORE_TIME = ""preWALRestoreTime"";
	 String PRE_WAL_RESTORE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's preWALRestore"";
	 String SLOW_PRE_WAL_RESTORE = ""slowPreWALRestoreCalls"";
	 String SLOW_PRE_WAL_RESTORE_DESC = ""The number of preWALRestore calls slower than the configured threshold"";
	 String POST_PUT_TIME = ""postPutTime"";
	 String POST_PUT_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postPut"";
	 String SLOW_POST_PUT = ""slowPostPutCalls"";
	 String SLOW_POST_PUT_DESC = ""The number of postPut calls slower than the configured threshold"";
	 String POST_DELETE_TIME = ""postDeleteTime"";
	 String POST_DELETE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postDelete"";
	 String SLOW_POST_DELETE = ""slowPostDeleteCalls"";
	 String SLOW_POST_DELETE_DESC = ""The number of postDelete calls slower than the configured threshold"";
	 String POST_OPEN_TIME = ""postOpenTime"";
	 String POST_OPEN_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postOpen"";
	 String SLOW_POST_OPEN = ""slowPostOpenCalls"";
	 String SLOW_POST_OPEN_DESC = ""The number of postOpen calls slower than the configured threshold"";
	 void updateIndexPrepareTime(long t);
	 void incrementNumSlowIndexPrepareCalls();
	 void updateIndexWriteTime(long t);
	 void incrementNumSlowIndexWriteCalls();
	 void updatePreWALRestoreTime(long t);
	 void incrementNumSlowPreWALRestoreCalls();
	 void updatePostPutTime(long t);
	 void incrementNumSlowPostPutCalls();
	 void updatePostDeleteTime(long t);
	 void incrementNumSlowPostDeleteCalls();
	 void updatePostOpenTime(long t);
	 void incrementNumSlowPostOpenCalls();
	 void updateDuplicateKeyCheckTime(long t);
	 void incrementSlowDuplicateKeyCheckCalls();
}",1,1,0,0
"public class FileResourceIterator implements Iterator {
	 private Project project;
	 private File basedir;
	 private String[] files;
	 private int pos = 0;
	 public FileResourceIterator() {
	 }
	 public FileResourceIterator(Project project) {
		 this.project = project;
	 }
	 public FileResourceIterator(File basedir) {
		 this(null, basedir);
	 }
	 public FileResourceIterator(Project project, File basedir) {
		 this(project);
		 this.basedir = basedir;
	 }
	 public FileResourceIterator(File basedir, String[] filenames) {
		 this(null, basedir, filenames);
	 }
	 public FileResourceIterator(Project project, File basedir, String[] filenames) {
		 this(project, basedir);
		 addFiles(filenames);
	 }
	 public void addFiles(String[] s) {
		 int start = (files == null) ? 0 : files.length;
		 String[] newfiles = new String[start + s.length];
		 if (start > 0) {
			 System.arraycopy(files, 0, newfiles, 0, start);
		 }
		 files = newfiles;
		 System.arraycopy(s, 0, files, start, s.length);
	 }
	 public boolean hasNext() {
		 return pos < files.length;
	 }
	 public Object next() {
		 return nextResource();
	 }
	 public void remove() {
		 throw new UnsupportedOperationException();
	 }
	 public FileResource nextResource() {
		 if (!hasNext()) {
			 throw new NoSuchElementException();
		 }
		 FileResource result = new FileResource(basedir, files[pos++]);
		 result.setProject(project);
		 return result;
	 }
}",0,0,0,0
"public class JobTracker implements MRConstants, InterTrackerProtocol, JobSubmissionProtocol {
	 static long RETIRE_JOB_INTERVAL;
	 static long RETIRE_JOB_CHECK_INTERVAL;
	 static float TASK_ALLOC_EPSILON;
	 static float PAD_FRACTION;
	 static final int MIN_CLUSTER_SIZE_FOR_PADDING = 3;
	 private static NumberFormat idFormat = NumberFormat.getInstance();
	 static {
		 idFormat.setMinimumIntegerDigits(4);
		 idFormat.setGroupingUsed(false);
	 }
	 private int nextJobId = 1;
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.mapred.JobTracker"");
	 private static JobTracker tracker = null;
	 private static boolean runTracker = true;
	 public static void startTracker(Configuration conf) throws IOException {
		 if (tracker != null) throw new IOException(""JobTracker already running."");
		 runTracker = true;
		 while (runTracker) {
			 try {
				 tracker = new JobTracker(conf);
				 break;
			 }
			 catch (IOException e) {
				 LOG.warn(""Error starting tracker: "" + StringUtils.stringifyException(e));
			 }
			 try {
				 Thread.sleep(1000);
			 }
			 catch (InterruptedException e) {
			 }
		 }
		 if (runTracker) {
			 tracker.offerService();
		 }
	 }
	 public static JobTracker getTracker() {
		 return tracker;
	 }
	 public static void stopTracker() throws IOException {
		 runTracker = false;
		 if (tracker != null) {
			 tracker.close();
			 tracker = null;
		 }
	 }
	 public long getProtocolVersion(String protocol, long clientVersion) {
		 if (protocol.equals(InterTrackerProtocol.class.getName())) {
			 return InterTrackerProtocol.versionID;
		 }
		 else {
			 return JobSubmissionProtocol.versionID;
		 }
	 }
	 private class ExpireLaunchingTasks implements Runnable {
		 private volatile boolean shouldRun = true;
		 private Map launchingTasks = new LinkedHashMap();
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL/3);
					 long now = System.currentTimeMillis();
					 LOG.debug(""Starting launching task sweep"");
					 synchronized (JobTracker.this) {
						 synchronized (launchingTasks) {
							 Iterator itr = launchingTasks.entrySet().iterator();
							 while (itr.hasNext()) {
								 Map.Entry pair = (Map.Entry) itr.next();
								 String taskId = (String) pair.getKey();
								 long age = now - ((Long) pair.getValue()).longValue();
								 LOG.info(taskId + "" is "" + age + "" ms debug."");
								 if (age > TASKTRACKER_EXPIRY_INTERVAL) {
									 LOG.info(""Launching task "" + taskId + "" timed out."");
									 TaskInProgress tip = null;
									 tip = (TaskInProgress) taskidToTIPMap.get(taskId);
									 if (tip != null) {
										 JobInProgress job = tip.getJob();
										 String trackerName = getAssignedTracker(taskId);
										 TaskTrackerStatus trackerStatus = getTaskTracker(trackerName);
										 job.failedTask(tip, taskId, ""Error launching task"", tip.isMapTask()? TaskStatus.Phase.MAP: TaskStatus.Phase.STARTING, trackerStatus.getHost(), trackerName, myMetrics);
									 }
									 itr.remove();
								 }
								 else {
									 break;
								 }
							 }
						 }
					 }
				 }
				 catch (InterruptedException ie) {
					 return;
				 }
				 catch (Exception e) {
					 LOG.error(""Expire Launching Task Thread got exception: "" + StringUtils.stringifyException(e));
				 }
			 }
		 }
		 public void addNewTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.put(taskName, new Long(System.currentTimeMillis()));
			 }
		 }
		 public void removeTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.remove(taskName);
			 }
		 }
		 public void stop() {
			 shouldRun = false;
		 }
	 }
	 class ExpireTrackers implements Runnable {
		 boolean shouldRun = true;
		 public ExpireTrackers() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL / 3);
					 synchronized (taskTrackers) {
						 synchronized (trackerExpiryQueue) {
							 long now = System.currentTimeMillis();
							 TaskTrackerStatus leastRecent = null;
							 while ((trackerExpiryQueue.size() > 0) && ((leastRecent = (TaskTrackerStatus) trackerExpiryQueue.first()) != null) && (now - leastRecent.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL)) {
								 trackerExpiryQueue.remove(leastRecent);
								 String trackerName = leastRecent.getTrackerName();
								 TaskTrackerStatus newProfile = (TaskTrackerStatus) taskTrackers.get(leastRecent.getTrackerName());
								 if (newProfile != null) {
									 if (now - newProfile.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL) {
										 updateTaskTrackerStatus(trackerName, null);
										 lostTaskTracker(leastRecent.getTrackerName(), leastRecent.getHost());
									 }
									 else {
										 trackerExpiryQueue.add(newProfile);
									 }
								 }
							 }
						 }
					 }
				 }
				 catch (Exception t) {
					 LOG.error(""Tracker Expiry Thread got exception: "" + StringUtils.stringifyException(t));
				 }
			 }
		 }
		 public void stopTracker() {
			 shouldRun = false;
		 }
	 }
	 class RetireJobs implements Runnable {
		 boolean shouldRun = true;
		 public RetireJobs() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(RETIRE_JOB_CHECK_INTERVAL);
					 synchronized (jobs) {
						 synchronized (jobsByArrival) {
							 synchronized (jobInitQueue) {
								 for (Iterator it = jobs.keySet().iterator();
								 it.hasNext();
								 ) {
									 String jobid = (String) it.next();
									 JobInProgress job = (JobInProgress) jobs.get(jobid);
									 if (job.getStatus().getRunState() != JobStatus.RUNNING && job.getStatus().getRunState() != JobStatus.PREP && (job.getFinishTime() + RETIRE_JOB_INTERVAL < System.currentTimeMillis())) {
										 it.remove();
										 jobInitQueue.remove(job);
										 jobsByArrival.remove(job);
									 }
								 }
							 }
						 }
					 }
				 }
				 catch (InterruptedException t) {
					 shouldRun = false;
				 }
				 catch (Throwable t) {
					 LOG.error(""Error in retiring job:\n"" + StringUtils.stringifyException(t));
				 }
			 }
		 }
	 }
	 class JobInitThread implements Runnable {
		 boolean shouldRun = true;
		 public JobInitThread() {
		 }
		 public void run() {
			 JobInProgress job;
			 while (shouldRun) {
				 job = null;
				 try {
					 synchronized (jobInitQueue) {
						 while (jobInitQueue.isEmpty()) {
							 jobInitQueue.wait();
						 }
						 job = jobInitQueue.remove(0);
					 }
					 job.initTasks();
				 }
				 catch (InterruptedException t) {
					 shouldRun = false;
				 }
				 catch (Throwable t) {
					 LOG.error(""Job initialization failed:\n"" + StringUtils.stringifyException(t));
					 if (job != null) {
						 job.kill();
					 }
				 }
			 }
		 }
	 }
	 static class JobTrackerMetrics {
		 private MetricsRecord metricsRecord = null;
		 private long numMapTasksLaunched = 0L;
		 private long numMapTasksCompleted = 0L;
		 private long numReduceTasksLaunched = 0L;
		 private long numReduceTasksCompleted = 0L;
		 private long numJobsSubmitted = 0L;
		 private long numJobsCompleted = 0L;
		 JobTrackerMetrics() {
			 metricsRecord = Metrics.createRecord(""mapred"", ""jobtracker"");
		 }
		 synchronized void launchMap() {
			 Metrics.report(metricsRecord, ""maps-launched"", ++numMapTasksLaunched);
		 }
		 synchronized void completeMap() {
			 Metrics.report(metricsRecord, ""maps-completed"", ++numMapTasksCompleted);
		 }
		 synchronized void launchReduce() {
			 Metrics.report(metricsRecord, ""reduces-launched"", ++numReduceTasksLaunched);
		 }
		 synchronized void completeReduce() {
			 Metrics.report(metricsRecord, ""reduces-completed"", ++numReduceTasksCompleted);
		 }
		 synchronized void submitJob() {
			 Metrics.report(metricsRecord, ""jobs-submitted"", ++numJobsSubmitted);
		 }
		 synchronized void completeJob() {
			 Metrics.report(metricsRecord, ""jobs-completed"", ++numJobsCompleted);
		 }
	 }
	 private JobTrackerMetrics myMetrics = null;
	 int port;
	 String localMachine;
	 long startTime;
	 int totalSubmissions = 0;
	 Random r = new Random();
	 private int maxCurrentTasks;
	 TreeMap jobs = new TreeMap();
	 Vector jobsByArrival = new Vector();
	 Map<String, TaskInProgress> taskidToTIPMap = new TreeMap();
	 TreeMap taskidToTrackerMap = new TreeMap();
	 TreeMap trackerToTaskMap = new TreeMap();
	 int totalMaps = 0;
	 int totalReduces = 0;
	 private TreeMap taskTrackers = new TreeMap();
	 List<JobInProgress> jobInitQueue = new ArrayList();
	 ExpireTrackers expireTrackers = new ExpireTrackers();
	 Thread expireTrackersThread = null;
	 RetireJobs retireJobs = new RetireJobs();
	 Thread retireJobsThread = null;
	 JobInitThread initJobs = new JobInitThread();
	 Thread initJobsThread = null;
	 ExpireLaunchingTasks expireLaunchingTasks = new ExpireLaunchingTasks();
	 Thread expireLaunchingTaskThread = new Thread(expireLaunchingTasks, ""expireLaunchingTasks"");
	 TreeSet trackerExpiryQueue = new TreeSet(new Comparator() {
		 public int compare(Object o1, Object o2) {
			 TaskTrackerStatus p1 = (TaskTrackerStatus) o1;
			 TaskTrackerStatus p2 = (TaskTrackerStatus) o2;
			 if (p1.getLastSeen() < p2.getLastSeen()) {
				 return -1;
			 }
			 else if (p1.getLastSeen() > p2.getLastSeen()) {
				 return 1;
			 }
			 else {
				 return (p1.getTrackerName().compareTo(p2.getTrackerName()));
			 }
		 }
	 }
	);
	 StatusHttpServer infoServer;
	 String infoBindAddress;
	 int infoPort;
	 Server interTrackerServer;
	 static final String SUBDIR = ""jobTracker"";
	 FileSystem fs;
	 Path systemDir;
	 private Configuration conf;
	 JobTracker(Configuration conf) throws IOException {
		 maxCurrentTasks = conf.getInt(""mapred.tasktracker.tasks.maximum"", 2);
		 RETIRE_JOB_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.interval"", 24 * 60 * 60 * 1000);
		 RETIRE_JOB_CHECK_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.check"", 60 * 1000);
		 TASK_ALLOC_EPSILON = conf.getFloat(""mapred.jobtracker.taskalloc.loadbalance.epsilon"", 0.2f);
		 PAD_FRACTION = conf.getFloat(""mapred.jobtracker.taskalloc.capacitypad"", 0.01f);
		 this.conf = conf;
		 JobConf jobConf = new JobConf(conf);
		 this.systemDir = jobConf.getSystemDir();
		 this.fs = FileSystem.get(conf);
		 fs.delete(systemDir);
		 if (!fs.mkdirs(systemDir)) {
			 throw new IOException(""Mkdirs failed to create "" + systemDir.toString());
		 }
		 jobConf.deleteLocalFiles(SUBDIR);
		 InetSocketAddress addr = getAddress(conf);
		 this.localMachine = addr.getHostName();
		 this.port = addr.getPort();
		 this.interTrackerServer = RPC.getServer(this,addr.getHostName(), addr.getPort(), 10, false, conf);
		 this.interTrackerServer.start();
		 Properties p = System.getProperties();
		 for (Iterator it = p.keySet().iterator();
		 it.hasNext();
		 ) {
			 String key = (String) it.next();
			 String val = (String) p.getProperty(key);
			 LOG.info(""Property '"" + key + ""' is "" + val);
		 }
		 this.infoPort = conf.getInt(""mapred.job.tracker.info.port"", 50030);
		 this.infoBindAddress = conf.get(""mapred.job.tracker.info.bindAddress"",""0.0.0.0"");
		 this.infoServer = new StatusHttpServer(""job"", infoBindAddress, infoPort, false);
		 this.infoServer.start();
		 this.startTime = System.currentTimeMillis();
		 myMetrics = new JobTrackerMetrics();
		 this.expireTrackersThread = new Thread(this.expireTrackers, ""expireTrackers"");
		 this.expireTrackersThread.start();
		 this.retireJobsThread = new Thread(this.retireJobs, ""retireJobs"");
		 this.retireJobsThread.start();
		 this.initJobsThread = new Thread(this.initJobs, ""initJobs"");
		 this.initJobsThread.start();
		 expireLaunchingTaskThread.start();
	 }
	 public static InetSocketAddress getAddress(Configuration conf) {
		 String jobTrackerStr = conf.get(""mapred.job.tracker"", ""localhost:8012"");
		 int colon = jobTrackerStr.indexOf("":"");
		 if (colon < 0) {
			 throw new RuntimeException(""Bad mapred.job.tracker: ""+jobTrackerStr);
		 }
		 String jobTrackerName = jobTrackerStr.substring(0, colon);
		 int jobTrackerPort = Integer.parseInt(jobTrackerStr.substring(colon+1));
		 return new InetSocketAddress(jobTrackerName, jobTrackerPort);
	 }
	 public void offerService() {
		 try {
			 this.interTrackerServer.join();
		 }
		 catch (InterruptedException ie) {
		 }
		 LOG.info(""Stopped interTrackerServer"");
	 }
	 void close() throws IOException {
		 if (this.infoServer != null) {
			 LOG.info(""Stopping infoServer"");
			 try {
				 this.infoServer.stop();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.interTrackerServer != null) {
			 LOG.info(""Stopping interTrackerServer"");
			 this.interTrackerServer.stop();
		 }
		 if (this.expireTrackers != null) {
			 LOG.info(""Stopping expireTrackers"");
			 this.expireTrackers.stopTracker();
			 try {
				 this.expireTrackersThread.interrupt();
				 this.expireTrackersThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.retireJobs != null) {
			 LOG.info(""Stopping retirer"");
			 this.retireJobsThread.interrupt();
			 try {
				 this.retireJobsThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.initJobs != null) {
			 LOG.info(""Stopping initer"");
			 this.initJobsThread.interrupt();
			 try {
				 this.initJobsThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.expireLaunchingTaskThread != null) {
			 LOG.info(""Stopping expireLaunchingTasks"");
			 this.expireLaunchingTasks.stop();
			 try {
				 this.expireLaunchingTaskThread.interrupt();
				 this.expireLaunchingTaskThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 LOG.info(""stopped all jobtracker services"");
		 return;
	 }
	 void createTaskEntry(String taskid, String taskTracker, TaskInProgress tip) {
		 LOG.info(""Adding task '"" + taskid + ""' to tip "" + tip.getTIPId() + "", for tracker '"" + taskTracker + ""'"");
		 taskidToTrackerMap.put(taskid, taskTracker);
		 TreeSet taskset = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskset == null) {
			 taskset = new TreeSet();
			 trackerToTaskMap.put(taskTracker, taskset);
		 }
		 taskset.add(taskid);
		 taskidToTIPMap.put(taskid, tip);
	 }
	 void removeTaskEntry(String taskid) {
		 String tracker = (String) taskidToTrackerMap.remove(taskid);
		 TreeSet trackerSet = (TreeSet) trackerToTaskMap.get(tracker);
		 if (trackerSet != null) {
			 trackerSet.remove(taskid);
		 }
		 taskidToTIPMap.remove(taskid);
	 }
	 public int getTotalSubmissions() {
		 return totalSubmissions;
	 }
	 public String getJobTrackerMachine() {
		 return localMachine;
	 }
	 public int getTrackerPort() {
		 return port;
	 }
	 public int getInfoPort() {
		 return infoPort;
	 }
	 public long getStartTime() {
		 return startTime;
	 }
	 public Vector runningJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector failedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.FAILED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector completedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.SUCCEEDED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Collection taskTrackers() {
		 synchronized (taskTrackers) {
			 return taskTrackers.values();
		 }
	 }
	 public TaskTrackerStatus getTaskTracker(String trackerID) {
		 synchronized (taskTrackers) {
			 return (TaskTrackerStatus) taskTrackers.get(trackerID);
		 }
	 }
	 private boolean updateTaskTrackerStatus(String trackerName, TaskTrackerStatus status) {
		 TaskTrackerStatus oldStatus = (TaskTrackerStatus) taskTrackers.get(trackerName);
		 if (oldStatus != null) {
			 totalMaps -= oldStatus.countMapTasks();
			 totalReduces -= oldStatus.countReduceTasks();
			 if (status == null) {
				 taskTrackers.remove(trackerName);
			 }
		 }
		 if (status != null) {
			 totalMaps += status.countMapTasks();
			 totalReduces += status.countReduceTasks();
			 taskTrackers.put(trackerName, status);
		 }
		 return oldStatus != null;
	 }
	 public synchronized int emitHeartbeat(TaskTrackerStatus trackerStatus, boolean initialContact) {
		 String trackerName = trackerStatus.getTrackerName();
		 trackerStatus.setLastSeen(System.currentTimeMillis());
		 synchronized (taskTrackers) {
			 synchronized (trackerExpiryQueue) {
				 boolean seenBefore = updateTaskTrackerStatus(trackerName, trackerStatus);
				 if (initialContact) {
					 if (seenBefore) {
						 lostTaskTracker(trackerName, trackerStatus.getHost());
					 }
				 }
				 else {
					 if (!seenBefore) {
						 LOG.warn(""Status from unknown Tracker : "" + trackerName);
						 taskTrackers.remove(trackerName);
						 return InterTrackerProtocol.UNKNOWN_TASKTRACKER;
					 }
				 }
				 if (initialContact) {
					 trackerExpiryQueue.add(trackerStatus);
				 }
			 }
		 }
		 updateTaskStatuses(trackerStatus);
		 return InterTrackerProtocol.TRACKERS_OK;
	 }
	 public synchronized Task pollForNewTask(String taskTracker) {
		 int remainingReduceLoad = 0;
		 int remainingMapLoad = 0;
		 int numTaskTrackers;
		 TaskTrackerStatus tts;
		 synchronized (taskTrackers) {
			 numTaskTrackers = taskTrackers.size();
			 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
		 }
		 if (tts == null) {
			 LOG.warn(""Unknown task tracker polling;
			 ignoring: "" + taskTracker);
			 return null;
		 }
		 int totalCapacity = numTaskTrackers * maxCurrentTasks;
		 synchronized(jobsByArrival){
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
					 int totalMapTasks = job.desiredMaps();
					 int totalReduceTasks = job.desiredReduces();
					 remainingMapLoad += (totalMapTasks - job.finishedMaps());
					 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
				 }
			 }
		 }
		 int maxMapLoad = 0;
		 int maxReduceLoad = 0;
		 if (numTaskTrackers > 0) {
			 maxMapLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingMapLoad / numTaskTrackers));
			 maxReduceLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingReduceLoad / numTaskTrackers));
		 }
		 int numMaps = tts.countMapTasks();
		 int numReduces = tts.countReduceTasks();
		 synchronized (jobsByArrival) {
			 if (numMaps < maxMapLoad) {
				 int totalNeededMaps = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
						 continue;
					 }
					 Task t = job.obtainNewMapTask(tts, numTaskTrackers);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 myMetrics.launchMap();
						 return t;
					 }
					 totalNeededMaps += job.desiredMaps();
					 int padding = 0;
					 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, (int)(totalNeededMaps * PAD_FRACTION));
					 }
					 if (totalMaps + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
			 if (numReduces < maxReduceLoad) {
				 int totalNeededReduces = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING || job.numReduceTasks == 0) {
						 continue;
					 }
					 Task t = job.obtainNewReduceTask(tts, numTaskTrackers);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 myMetrics.launchReduce();
						 return t;
					 }
					 totalNeededReduces += job.desiredReduces();
					 int padding = 0;
					 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, (int) (totalNeededReduces * PAD_FRACTION));
					 }
					 if (totalReduces + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 public synchronized String[] pollForTaskWithClosedJob(String taskTracker) {
		 TreeSet taskIds = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskIds != null) {
			 ArrayList list = new ArrayList();
			 for (Iterator it = taskIds.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.shouldCloseForClosedJob(taskId)) {
					 list.add(taskId);
				 }
			 }
			 return (String[]) list.toArray(new String[list.size()]);
		 }
		 return null;
	 }
	 public synchronized MapOutputLocation[] locateMapOutputs(String jobId, int[] mapTasksNeeded, int reduce) {
		 ArrayList result = new ArrayList(mapTasksNeeded.length);
		 JobInProgress job = getJob(jobId);
		 for (int i = 0;
		 i < mapTasksNeeded.length;
		 i++) {
			 TaskStatus status = job.findFinishedMap(mapTasksNeeded[i]);
			 if (status != null) {
				 String trackerId = (String) taskidToTrackerMap.get(status.getTaskId());
				 TaskTrackerStatus tracker;
				 synchronized (taskTrackers) {
					 tracker = (TaskTrackerStatus) taskTrackers.get(trackerId);
				 }
				 result.add(new MapOutputLocation(status.getTaskId(), mapTasksNeeded[i], tracker.getHost(), tracker.getHttpPort()));
			 }
		 }
		 return (MapOutputLocation[]) result.toArray(new MapOutputLocation[result.size()]);
	 }
	 public synchronized String getFilesystemName() throws IOException {
		 return fs.getName();
	 }
	 public void reportTaskTrackerError(String taskTracker, String errorClass, String errorMessage) throws IOException {
		 LOG.warn(""Report from "" + taskTracker + "": "" + errorMessage);
	 }
	 public synchronized JobStatus submitJob(String jobFile) throws IOException {
		 totalSubmissions++;
		 JobInProgress job = new JobInProgress(jobFile, this, this.conf);
		 synchronized (jobs) {
			 synchronized (jobsByArrival) {
				 synchronized (jobInitQueue) {
					 jobs.put(job.getProfile().getJobId(), job);
					 jobsByArrival.add(job);
					 jobInitQueue.add(job);
					 jobInitQueue.notifyAll();
				 }
			 }
		 }
		 myMetrics.submitJob();
		 return job.getStatus();
	 }
	 public synchronized ClusterStatus getClusterStatus() {
		 synchronized (taskTrackers) {
			 return new ClusterStatus(taskTrackers.size(), totalMaps, totalReduces, maxCurrentTasks);
		 }
	 }
	 public synchronized void killJob(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 job.kill();
	 }
	 public synchronized JobProfile getJobProfile(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getProfile();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized JobStatus getJobStatus(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getStatus();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized TaskReport[] getMapTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeMapTasks = job.reportTasksInProgress(true, true);
			 for (Iterator it = completeMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteMapTasks = job.reportTasksInProgress(true, false);
			 for (Iterator it = incompleteMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 public synchronized TaskReport[] getReduceTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeReduceTasks = job.reportTasksInProgress(false, true);
			 for (Iterator it = completeReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteReduceTasks = job.reportTasksInProgress(false, false);
			 for (Iterator it = incompleteReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 public synchronized List<String> getTaskDiagnostics(String jobId, String tipId, String taskId) {
		 JobInProgress job = (JobInProgress) jobs.get(jobId);
		 if (job == null) {
			 throw new IllegalArgumentException(""Job "" + jobId + "" not found."");
		 }
		 TaskInProgress tip = job.getTaskInProgress(tipId);
		 if (tip == null) {
			 throw new IllegalArgumentException(""TIP "" + tipId + "" not found."");
		 }
		 return tip.getDiagnosticInfo(taskId);
	 }
	 TaskStatus[] getTaskStatuses(String jobid, String tipid){
		JobInProgress job = (JobInProgress) jobs.get(jobid);
		if (job == null){
			 return new TaskStatus[0];
		}
		TaskInProgress tip = (TaskInProgress) job.getTaskInProgress(tipid);
		if (tip == null){
			 return new TaskStatus[0];
		}
		return tip.getTaskStatuses();
	 }
	 public synchronized String getAssignedTracker(String taskId) {
		 return (String) taskidToTrackerMap.get(taskId);
	 }
	 public JobStatus[] jobsToComplete() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING || status.getRunState() == JobStatus.PREP) {
				status.setStartTime(jip.getStartTime());
				 status.setUsername(jip.getProfile().getUser());
				 v.add(status);
			 }
		 }
		 return (JobStatus[]) v.toArray(new JobStatus[v.size()]);
	 }
	 public JobInProgress getJob(String jobid) {
		 return (JobInProgress) jobs.get(jobid);
	 }
	 String createUniqueId() {
		 return idFormat.format(nextJobId++);
	 }
	 void updateTaskStatuses(TaskTrackerStatus status) {
		 for (Iterator it = status.taskReports();
		 it.hasNext();
		 ) {
			 TaskStatus report = (TaskStatus) it.next();
			 report.setTaskTracker(status.getTrackerName());
			 String taskId = report.getTaskId();
			 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
			 if (tip == null) {
				 LOG.info(""Serious problem. While updating status, cannot find taskid "" + report.getTaskId());
			 }
			 else {
				 expireLaunchingTasks.removeTask(taskId);
				 tip.getJob().updateTaskStatus(tip, report, myMetrics);
			 }
		 }
	 }
	 void lostTaskTracker(String trackerName, String hostname) {
		 LOG.info(""Lost tracker '"" + trackerName + ""'"");
		 TreeSet lostTasks = (TreeSet) trackerToTaskMap.get(trackerName);
		 trackerToTaskMap.remove(trackerName);
		 if (lostTasks != null) {
			 for (Iterator it = lostTasks.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.isMapTask() || !tip.isComplete()) {
					 JobInProgress job = tip.getJob();
					 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
						 job.failedTask(tip, taskId, ""Lost task tracker"", TaskStatus.Phase.MAP, hostname, trackerName, myMetrics);
					 }
				 }
			 }
		 }
	 }
	 public static void main(String argv[]) throws IOException, InterruptedException {
		 if (argv.length != 0) {
			 System.out.println(""usage: JobTracker"");
			 System.exit(-1);
		 }
		 try {
			 Configuration conf=new Configuration();
			 startTracker(conf);
		 }
		 catch ( Throwable e ) {
			 LOG.error( StringUtils.stringifyException( e ) );
			 System.exit(-1);
		 }
	 }
}",0,0,0,0
"public class ParserDDL extends ParserRoutine {
	 final static int[] schemaCommands = new int[] {
	 Tokens.CREATE, Tokens.GRANT }
	;
	 final static short[] startStatementTokens = new short[] {
	 Tokens.CREATE, Tokens.GRANT, Tokens.ALTER, Tokens.DROP }
	;
	 final static short[] startStatementTokensSchema = new short[] {
	 Tokens.CREATE, Tokens.GRANT, }
	;
	 ParserDDL(Session session, Scanner scanner) {
		 super(session, scanner);
	 }
	 void reset(String sql) {
		 super.reset(sql);
	 }
	 StatementSchema compileCreate() {
		 int tableType = TableBase.MEMORY_TABLE;
		 boolean isTable = false;
		 read();
		 switch (token.tokenType) {
			 case Tokens.GLOBAL : read();
			 readThis(Tokens.TEMPORARY);
			 readIfThis(Tokens.MEMORY);
			 readThis(Tokens.TABLE);
			 isTable = true;
			 tableType = TableBase.TEMP_TABLE;
			 break;
			 case Tokens.TEMP : read();
			 readThis(Tokens.TABLE);
			 isTable = true;
			 tableType = TableBase.TEMP_TABLE;
			 break;
			 case Tokens.TEMPORARY : read();
			 readThis(Tokens.TABLE);
			 isTable = true;
			 tableType = TableBase.TEMP_TABLE;
			 break;
			 case Tokens.MEMORY : read();
			 readThis(Tokens.TABLE);
			 isTable = true;
			 break;
			 case Tokens.CACHED : read();
			 readThis(Tokens.TABLE);
			 isTable = true;
			 tableType = TableBase.CACHED_TABLE;
			 break;
			 case Tokens.TEXT : read();
			 readThis(Tokens.TABLE);
			 isTable = true;
			 tableType = TableBase.TEXT_TABLE;
			 break;
			 case Tokens.TABLE : read();
			 isTable = true;
			 tableType = database.schemaManager.getDefaultTableType();
			 break;
		 default : }
		 if (isTable) {
			 return compileCreateTable(tableType);
		 }
		 switch (token.tokenType) {
			 case Tokens.ALIAS : return compileCreateAlias();
			 case Tokens.SEQUENCE : return compileCreateSequence();
			 case Tokens.SCHEMA : return compileCreateSchema();
			 case Tokens.TRIGGER : return compileCreateTrigger();
			 case Tokens.USER : return compileCreateUser();
			 case Tokens.ROLE : return compileCreateRole();
			 case Tokens.VIEW : return compileCreateView(false);
			 case Tokens.DOMAIN : return compileCreateDomain();
			 case Tokens.TYPE : return compileCreateType();
			 case Tokens.CHARACTER : return compileCreateCharacterSet();
			 case Tokens.UNIQUE : read();
			 checkIsThis(Tokens.INDEX);
			 return compileCreateIndex(true);
			 case Tokens.INDEX : return compileCreateIndex(false);
			 case Tokens.AGGREGATE : case Tokens.FUNCTION : case Tokens.PROCEDURE : return compileCreateProcedureOrFunction();
			 default : {
				 throw unexpectedToken();
			 }
		 }
	 }
	 void processAlter() {
		 session.setScripting(true);
		 readThis(Tokens.ALTER);
		 switch (token.tokenType) {
			 case Tokens.TABLE : {
				 read();
				 processAlterTable();
				 break;
			 }
			 case Tokens.DOMAIN : {
				 read();
				 processAlterDomain();
				 break;
			 }
			 default : {
				 throw unexpectedToken();
			 }
		 }
	 }
	 Statement compileAlter() {
		 read();
		 switch (token.tokenType) {
			 case Tokens.INDEX : {
				 read();
				 HsqlName name = readNewSchemaObjectName(SchemaObject.INDEX, true);
				 readThis(Tokens.RENAME);
				 readThis(Tokens.TO);
				 return compileRenameObject(name, SchemaObject.INDEX);
			 }
			 case Tokens.SCHEMA : {
				 read();
				 HsqlName name = readSchemaName();
				 readThis(Tokens.RENAME);
				 readThis(Tokens.TO);
				 return compileRenameObject(name, SchemaObject.SCHEMA);
			 }
			 case Tokens.CATALOG : {
				 read();
				 checkIsSimpleName();
				 String name = token.tokenString;
				 checkValidCatalogName(name);
				 read();
				 readThis(Tokens.RENAME);
				 readThis(Tokens.TO);
				 return compileRenameObject(database.getCatalogName(), SchemaObject.CATALOG);
			 }
			 case Tokens.SEQUENCE : {
				 return compileAlterSequence();
			 }
			 case Tokens.TABLE : {
				 return compileAlterTable();
			 }
			 case Tokens.USER : {
				 return compileAlterUser();
			 }
			 case Tokens.DOMAIN : {
				 return compileAlterDomain();
			 }
			 case Tokens.VIEW : {
				 return compileCreateView(true);
			 }
			 default : {
				 throw unexpectedToken();
			 }
		 }
	 }
	 Statement compileDrop() {
		 int objectTokenType;
		 int objectType;
		 int statementType;
		 boolean canCascade = false;
		 boolean cascade = false;
		 boolean useIfExists = false;
		 boolean ifExists = false;
		 HsqlName writeName = null;
		 HsqlName catalogName = database.getCatalogName();
		 read();
		 objectTokenType = this.token.tokenType;
		 switch (objectTokenType) {
			 case Tokens.INDEX : {
				 read();
				 statementType = StatementTypes.DROP_INDEX;
				 objectType = SchemaObject.INDEX;
				 useIfExists = true;
				 writeName = catalogName;
				 break;
			 }
			 case Tokens.ASSERTION : {
				 read();
				 statementType = StatementTypes.DROP_ASSERTION;
				 objectType = SchemaObject.ASSERTION;
				 canCascade = true;
				 break;
			 }
			 case Tokens.SPECIFIC : {
				 read();
				 switch (token.tokenType) {
					 case Tokens.ROUTINE : case Tokens.PROCEDURE : case Tokens.FUNCTION : read();
					 break;
					 default : throw unexpectedToken();
				 }
				 statementType = StatementTypes.DROP_ROUTINE;
				 objectType = SchemaObject.SPECIFIC_ROUTINE;
				 writeName = catalogName;
				 canCascade = true;
				 useIfExists = true;
				 break;
			 }
			 case Tokens.PROCEDURE : {
				 read();
				 statementType = StatementTypes.DROP_ROUTINE;
				 objectType = SchemaObject.PROCEDURE;
				 writeName = catalogName;
				 canCascade = true;
				 useIfExists = true;
				 break;
			 }
			 case Tokens.FUNCTION : {
				 read();
				 statementType = StatementTypes.DROP_ROUTINE;
				 objectType = SchemaObject.FUNCTION;
				 writeName = catalogName;
				 canCascade = true;
				 useIfExists = true;
				 break;
			 }
			 case Tokens.SCHEMA : {
				 read();
				 statementType = StatementTypes.DROP_SCHEMA;
				 objectType = SchemaObject.SCHEMA;
				 writeName = catalogName;
				 canCascade = true;
				 useIfExists = true;
				 break;
			 }
			 case Tokens.SEQUENCE : {
				 read();
				 statementType = StatementTypes.DROP_SEQUENCE;
				 objectType = SchemaObject.SEQUENCE;
				 writeName = catalogName;
				 canCascade = true;
				 useIfExists = true;
				 break;
			 }
			 case Tokens.TRIGGER : {
				 read();
				 statementType = StatementTypes.DROP_TRIGGER;
				 objectType = SchemaObject.TRIGGER;
				 writeName = catalogName;
				 canCascade = false;
				 useIfExists = true;
				 break;
			 }
			 case Tokens.USER : {
				 read();
				 statementType = StatementTypes.DROP_USER;
				 objectType = SchemaObject.GRANTEE;
				 writeName = catalogName;
				 canCascade = true;
				 break;
			 }
			 case Tokens.ROLE : {
				 read();
				 statementType = StatementTypes.DROP_ROLE;
				 objectType = SchemaObject.GRANTEE;
				 writeName = catalogName;
				 canCascade = true;
				 break;
			 }
			 case Tokens.DOMAIN : read();
			 statementType = StatementTypes.DROP_DOMAIN;
			 objectType = SchemaObject.DOMAIN;
			 writeName = catalogName;
			 canCascade = true;
			 useIfExists = true;
			 break;
			 case Tokens.TYPE : read();
			 statementType = StatementTypes.DROP_TYPE;
			 objectType = SchemaObject.TYPE;
			 writeName = catalogName;
			 canCascade = true;
			 useIfExists = true;
			 break;
			 case Tokens.CHARACTER : read();
			 readThis(Tokens.SET);
			 statementType = StatementTypes.DROP_CHARACTER_SET;
			 objectType = SchemaObject.CHARSET;
			 writeName = catalogName;
			 canCascade = false;
			 useIfExists = true;
			 break;
			 case Tokens.VIEW : read();
			 statementType = StatementTypes.DROP_VIEW;
			 objectType = SchemaObject.VIEW;
			 writeName = catalogName;
			 canCascade = true;
			 useIfExists = true;
			 break;
			 case Tokens.TABLE : read();
			 statementType = StatementTypes.DROP_TABLE;
			 objectType = SchemaObject.TABLE;
			 writeName = catalogName;
			 canCascade = true;
			 useIfExists = true;
			 break;
			 default : throw unexpectedToken();
		 }
		 if (useIfExists && token.tokenType == Tokens.IF) {
			 int position = getPosition();
			 read();
			 if (token.tokenType == Tokens.EXISTS) {
				 read();
				 ifExists = true;
			 }
			 else {
				 rewind(position);
			 }
		 }
		 checkIsIdentifier();
		 HsqlName name = null;
		 switch (objectTokenType) {
			 case Tokens.USER : {
				 checkIsSimpleName();
				 checkDatabaseUpdateAuthorisation();
				 Grantee grantee = database.getUserManager().get(token.tokenString);
				 name = grantee.getName();
				 read();
				 break;
			 }
			 case Tokens.ROLE : {
				 checkIsSimpleName();
				 checkDatabaseUpdateAuthorisation();
				 Grantee role = database.getGranteeManager().getRole(token.tokenString);
				 name = role.getName();
				 read();
				 break;
			 }
			 case Tokens.SCHEMA : {
				 name = readNewSchemaName();
				 writeName = catalogName;
				 break;
			 }
			 case Tokens.TABLE : {
				 boolean isModule = token.namePrePrefix == null && Tokens.T_MODULE.equals(token.namePrefix);
				 name = readNewSchemaObjectName(objectType, false);
				 if (isModule) {
					 Object[] args = new Object[] {
					 name, Boolean.valueOf(ifExists) }
					;
					 return new StatementSession(StatementTypes.DROP_TABLE, args);
				 }
				 break;
			 }
			 default : name = readNewSchemaObjectName(objectType, false);
		 }
		 if (!ifExists && useIfExists && token.tokenType == Tokens.IF) {
			 read();
			 readThis(Tokens.EXISTS);
			 ifExists = true;
		 }
		 if (canCascade) {
			 if (token.tokenType == Tokens.CASCADE) {
				 cascade = true;
				 read();
			 }
			 else if (token.tokenType == Tokens.RESTRICT) {
				 read();
			 }
		 }
		 Object[] args = new Object[] {
		 name, new Integer(objectType), Boolean.valueOf(cascade), Boolean.valueOf(ifExists) }
		;
		 String sql = getLastPart();
		 Statement cs = new StatementSchema(sql, statementType, args, null, writeName);
		 return cs;
	 }
	 private void processAlterTable() {
		 String tableName = token.tokenString;
		 HsqlName schema = session.getSchemaHsqlName(token.namePrefix);
		 checkSchemaUpdateAuthorisation(schema);
		 Table t = database.schemaManager.getUserTable(session, tableName, schema.name);
		 if (t.isView()) {
			 throw Error.error(ErrorCode.X_42501, tableName);
		 }
		 read();
		 switch (token.tokenType) {
			 case Tokens.RENAME : {
				 read();
				 readThis(Tokens.TO);
				 processAlterTableRename(t);
				 return;
			 }
			 case Tokens.ADD : {
				 read();
				 HsqlName cname = null;
				 if (token.tokenType == Tokens.CONSTRAINT) {
					 read();
					 cname = readNewDependentSchemaObjectName(t.getName(), SchemaObject.CONSTRAINT);
					 database.schemaManager.checkSchemaObjectNotExists(cname);
				 }
				 switch (token.tokenType) {
					 case Tokens.FOREIGN : read();
					 readThis(Tokens.KEY);
					 processAlterTableAddForeignKeyConstraint(t, cname);
					 return;
					 case Tokens.UNIQUE : read();
					 processAlterTableAddUniqueConstraint(t, cname);
					 return;
					 case Tokens.CHECK : read();
					 processAlterTableAddCheckConstraint(t, cname);
					 return;
					 case Tokens.PRIMARY : read();
					 readThis(Tokens.KEY);
					 processAlterTableAddPrimaryKey(t, cname);
					 return;
					 case Tokens.COLUMN : if (cname != null) {
						 throw unexpectedToken();
					 }
					 read();
					 checkIsSimpleName();
					 processAlterTableAddColumn(t);
					 return;
					 default : if (cname != null) {
						 throw unexpectedToken();
					 }
					 checkIsSimpleName();
					 processAlterTableAddColumn(t);
					 return;
				 }
			 }
			 case Tokens.DROP : {
				 read();
				 switch (token.tokenType) {
					 case Tokens.PRIMARY : {
						 boolean cascade = false;
						 read();
						 readThis(Tokens.KEY);
						 if (token.tokenType == Tokens.CASCADE) {
							 read();
							 cascade = true;
						 }
						 if (t.hasPrimaryKey()) {
							 processAlterTableDropConstraint( t, t.getPrimaryConstraint().getName().name, cascade);
						 }
						 else {
							 throw Error.error(ErrorCode.X_42501);
						 }
						 return;
					 }
					 case Tokens.CONSTRAINT : {
						 boolean cascade = false;
						 read();
						 SchemaObject object = readSchemaObjectName(t.getName(), SchemaObject.CONSTRAINT);
						 if (token.tokenType == Tokens.RESTRICT) {
							 read();
						 }
						 else if (token.tokenType == Tokens.CASCADE) {
							 read();
							 cascade = true;
						 }
						 processAlterTableDropConstraint( t, object.getName().name, cascade);
						 return;
					 }
					 case Tokens.COLUMN : read();
					 default : {
						 checkIsSimpleName();
						 String name = token.tokenString;
						 boolean cascade = false;
						 read();
						 if (token.tokenType == Tokens.RESTRICT) {
							 read();
						 }
						 else if (token.tokenType == Tokens.CASCADE) {
							 read();
							 cascade = true;
						 }
						 processAlterTableDropColumn(t, name, cascade);
						 return;
					 }
				 }
			 }
			 case Tokens.ALTER : {
				 read();
				 if (token.tokenType == Tokens.COLUMN) {
					 read();
				 }
				 int columnIndex = t.getColumnIndex(token.tokenString);
				 ColumnSchema column = t.getColumn(columnIndex);
				 read();
				 processAlterColumn(t, column, columnIndex);
				 return;
			 }
			 default : {
				 throw unexpectedToken();
			 }
		 }
	 }
	 Statement compileAlterTable() {
		 read();
		 String tableName = token.tokenString;
		 HsqlName schema = session.getSchemaHsqlName(token.namePrefix);
		 Table t = database.schemaManager.getUserTable(session, tableName, schema.name);
		 read();
		 switch (token.tokenType) {
			 case Tokens.RENAME : {
				 read();
				 readThis(Tokens.TO);
				 return compileRenameObject(t.getName(), SchemaObject.TABLE);
			 }
			 case Tokens.ADD : {
				 read();
				 HsqlName cname = null;
				 if (token.tokenType == Tokens.CONSTRAINT) {
					 read();
					 cname = readNewDependentSchemaObjectName(t.getName(), SchemaObject.CONSTRAINT);
				 }
				 switch (token.tokenType) {
					 case Tokens.FOREIGN : read();
					 readThis(Tokens.KEY);
					 return compileAlterTableAddForeignKeyConstraint(t, cname);
					 case Tokens.UNIQUE : read();
					 return compileAlterTableAddUniqueConstraint(t, cname);
					 case Tokens.CHECK : read();
					 return compileAlterTableAddCheckConstraint(t, cname);
					 case Tokens.PRIMARY : read();
					 readThis(Tokens.KEY);
					 return compileAlterTableAddPrimaryKey(t, cname);
					 case Tokens.COLUMN : if (cname != null) {
						 throw unexpectedToken();
					 }
					 read();
					 checkIsSimpleName();
					 return compileAlterTableAddColumn(t);
					 default : if (cname != null) {
						 throw unexpectedToken();
					 }
					 checkIsSimpleName();
					 return compileAlterTableAddColumn(t);
				 }
			 }
			 case Tokens.DROP : {
				 read();
				 switch (token.tokenType) {
					 case Tokens.PRIMARY : {
						 boolean cascade = false;
						 read();
						 readThis(Tokens.KEY);
						 return compileAlterTableDropPrimaryKey(t);
					 }
					 case Tokens.CONSTRAINT : {
						 read();
						 return compileAlterTableDropConstraint(t);
					 }
					 case Tokens.COLUMN : read();
					 default : {
						 checkIsSimpleName();
						 String name = token.tokenString;
						 boolean cascade = false;
						 read();
						 if (token.tokenType == Tokens.RESTRICT) {
							 read();
						 }
						 else if (token.tokenType == Tokens.CASCADE) {
							 read();
							 cascade = true;
						 }
						 return compileAlterTableDropColumn(t, name, cascade);
					 }
				 }
			 }
			 case Tokens.ALTER : {
				 read();
				 if (token.tokenType == Tokens.COLUMN) {
					 read();
				 }
				 int columnIndex = t.getColumnIndex(token.tokenString);
				 ColumnSchema column = t.getColumn(columnIndex);
				 read();
				 return compileAlterColumn(t, column, columnIndex);
			 }
			 default : {
				 throw unexpectedToken();
			 }
		 }
	 }
	 private Statement compileAlterTableDropConstraint(Table t) {
		 boolean cascade = false;
		 SchemaObject object = readSchemaObjectName(t.getSchemaName(), SchemaObject.CONSTRAINT);
		 if (token.tokenType == Tokens.RESTRICT) {
			 read();
		 }
		 else if (token.tokenType == Tokens.CASCADE) {
			 read();
			 cascade = true;
		 }
		 Object[] args = new Object[] {
		 object.getName(), ValuePool.getInt(SchemaObject.CONSTRAINT), Boolean.valueOf(cascade), Boolean.valueOf(false) }
		;
		 String sql = getLastPart();
		 Statement cs = new StatementSchema(sql, StatementTypes.DROP_CONSTRAINT, args);
		 cs.writeTableNames = getReferenceArray(t.getName(), cascade);
		 return cs;
	 }
	 private Statement compileAlterTableDropPrimaryKey(Table t) {
		 boolean cascade = false;
		 if (token.tokenType == Tokens.RESTRICT) {
			 read();
		 }
		 else if (token.tokenType == Tokens.CASCADE) {
			 read();
			 cascade = true;
		 }
		 if (!t.hasPrimaryKey()) {
			 throw Error.error(ErrorCode.X_42501);
		 }
		 SchemaObject object = t.getPrimaryConstraint();
		 Object[] args = new Object[] {
		 object.getName(), ValuePool.getInt(SchemaObject.CONSTRAINT), Boolean.valueOf(cascade), Boolean.valueOf(false) }
		;
		 String sql = getLastPart();
		 Statement cs = new StatementSchema(sql, StatementTypes.DROP_CONSTRAINT, args);
		 cs.writeTableNames = getReferenceArray(t.getName(), cascade);
		 return cs;
	 }
	 HsqlName[] getReferenceArray(HsqlName objectName, boolean cascade) {
		 if (cascade) {
			 OrderedHashSet names = new OrderedHashSet();
			 database.schemaManager.getCascadingReferencingObjectNames( objectName, names);
			 Iterator it = names.iterator();
			 while (it.hasNext()) {
				 HsqlName name = (HsqlName) it.next();
				 if (name.type != SchemaObject.TABLE) {
					 it.remove();
				 }
			 }
			 names.add(objectName);
			 HsqlName[] array = new HsqlName[names.size()];
			 names.toArray(array);
			 return array;
		 }
		 else {
			 return new HsqlName[]{
			 objectName }
			;
		 }
	 }
	 StatementSession compileDeclareLocalTableOrNull() {
		 int position = super.getPosition();
		 try {
			 readThis(Tokens.DECLARE);
			 readThis(Tokens.LOCAL);
			 readThis(Tokens.TEMPORARY);
			 readThis(Tokens.TABLE);
		 }
		 catch (Exception e) {
			 rewind(position);
			 return null;
		 }
		 if (token.namePrePrefix != null) {
			 throw unexpectedToken();
		 }
		 if (token.namePrePrefix == null && (token.namePrefix == null || Tokens.T_MODULE.equals(token.namePrefix))) {
		 }
		 else {
			 throw unexpectedToken();
		 }
		 HsqlName name = readNewSchemaObjectName(SchemaObject.TABLE, false);
		 name.schema = SqlInvariants.MODULE_HSQLNAME;
		 Table table = TableUtil.newTable(database, TableBase.TEMP_TABLE, name);
		 StatementSchema cs = compileCreateTableBody(table);
		 HsqlArrayList constraints = (HsqlArrayList) cs.arguments[1];
		 for (int i = 0;
		 i < constraints.size();
		 i++) {
			 Constraint c = (Constraint) constraints.get(i);
			 if (c.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY) {
				 throw unexpectedToken(Tokens.T_FOREIGN);
			 }
		 }
		 StatementSession ss = new StatementSession(StatementTypes.DECLARE_SESSION_TABLE, cs.arguments);
		 return ss;
	 }
	 StatementSchema compileCreateTable(int type) {
		 HsqlName name = readNewSchemaObjectName(SchemaObject.TABLE, false);
		 name.setSchemaIfNull(session.getCurrentSchemaHsqlName());
		 Table table = TableUtil.newTable(database, type, name);
		 return compileCreateTableBody(table);
	 }
	 StatementSchema compileCreateTableBody(Table table) {
		 HsqlArrayList tempConstraints = new HsqlArrayList();
		 if (token.tokenType == Tokens.AS) {
			 return readTableAsSubqueryDefinition(table);
		 }
		 int position = getPosition();
		 readThis(Tokens.OPENBRACKET);
		 {
			 Constraint c = new Constraint(null, null, SchemaObject.ConstraintTypes.TEMP);
			 tempConstraints.add(c);
		 }
		 boolean start = true;
		 boolean startPart = true;
		 boolean end = false;
		 while (!end) {
			 switch (token.tokenType) {
				 case Tokens.LIKE : {
					 ColumnSchema[] likeColumns = readLikeTable(table);
					 for (int i = 0;
					 i < likeColumns.length;
					 i++) {
						 table.addColumn(likeColumns[i]);
					 }
					 start = false;
					 startPart = false;
					 break;
				 }
				 case Tokens.CONSTRAINT : case Tokens.PRIMARY : case Tokens.FOREIGN : case Tokens.UNIQUE : case Tokens.CHECK : if (!startPart) {
					 throw unexpectedToken();
				 }
				 readConstraint(table, tempConstraints);
				 start = false;
				 startPart = false;
				 break;
				 case Tokens.COMMA : if (startPart) {
					 throw unexpectedToken();
				 }
				 read();
				 startPart = true;
				 break;
				 case Tokens.CLOSEBRACKET : read();
				 end = true;
				 break;
				 default : if (!startPart) {
					 throw unexpectedToken();
				 }
				 checkIsSchemaObjectName();
				 HsqlName hsqlName = database.nameManager.newColumnHsqlName(table.getName(), token.tokenString, isDelimitedIdentifier());
				 read();
				 ColumnSchema newcolumn = readColumnDefinitionOrNull(table, hsqlName, tempConstraints);
				 if (newcolumn == null) {
					 if (start) {
						 rewind(position);
						 return readTableAsSubqueryDefinition(table);
					 }
					 else {
						 throw Error.error(ErrorCode.X_42000);
					 }
				 }
				 table.addColumn(newcolumn);
				 start = false;
				 startPart = false;
			 }
		 }
		 if (token.tokenType == Tokens.ON) {
			 if (!table.isTemp()) {
				 throw unexpectedToken();
			 }
			 read();
			 readThis(Tokens.COMMIT);
			 if (token.tokenType == Tokens.DELETE) {
			}
			 else if (token.tokenType == Tokens.PRESERVE) {
				 table.persistenceScope = TableBase.SCOPE_SESSION;
			 }
			 read();
			 readThis(Tokens.ROWS);
		 }
		 Object[] args = new Object[] {
		 table, tempConstraints, null }
		;
		 String sql = getLastPart();
		 return new StatementSchema(sql, StatementTypes.CREATE_TABLE, args);
	 }
	 private ColumnSchema[] readLikeTable(Table table) {
		 read();
		 boolean generated = false;
		 boolean identity = false;
		 boolean defaults = false;
		 Table likeTable = readTableName();
		 OrderedIntHashSet set = new OrderedIntHashSet();
		 while (true) {
			 boolean including = token.tokenType == Tokens.INCLUDING;
			 if (!including && token.tokenType != Tokens.EXCLUDING) {
				 break;
			 }
			 read();
			 switch (token.tokenType) {
				 case Tokens.GENERATED : if (!set.add(token.tokenType)) {
					 throw unexpectedToken();
				 }
				 generated = including;
				 break;
				 case Tokens.IDENTITY : if (!set.add(token.tokenType)) {
					 throw unexpectedToken();
				 }
				 identity = including;
				 break;
				 case Tokens.DEFAULTS : if (!set.add(token.tokenType)) {
					 throw unexpectedToken();
				 }
				 defaults = including;
				 break;
				 default : throw unexpectedToken();
			 }
			 read();
		 }
		 ColumnSchema[] columnList = new ColumnSchema[likeTable.getColumnCount()];
		 for (int i = 0;
		 i < columnList.length;
		 i++) {
			 ColumnSchema column = likeTable.getColumn(i).duplicate();
			 HsqlName name = database.nameManager.newColumnSchemaHsqlName(table.getName(), column.getName());
			 column.setName(name);
			 column.setNullable(true);
			 column.setPrimaryKey(false);
			 if (identity) {
				 if (column.isIdentity()) {
					 column.setIdentity( column.getIdentitySequence().duplicate());
				 }
			 }
			 else {
				 column.setIdentity(null);
			 }
			 if (!defaults) {
				 column.setDefaultExpression(null);
			 }
			 if (!generated) {
				 column.setGeneratingExpression(null);
			 }
			 columnList[i] = column;
		 }
		 return columnList;
	 }
	 StatementSchema readTableAsSubqueryDefinition(Table table) {
		 HsqlName readName = null;
		 boolean withData = true;
		 HsqlName[] columnNames = null;
		 Statement statement = null;
		 if (token.tokenType == Tokens.OPENBRACKET) {
			 columnNames = readColumnNames(table.getName());
		 }
		 readThis(Tokens.AS);
		 readThis(Tokens.OPENBRACKET);
		 QueryExpression queryExpression = XreadQueryExpression();
		 queryExpression.setReturningResult();
		 queryExpression.resolve(session);
		 readThis(Tokens.CLOSEBRACKET);
		 readThis(Tokens.WITH);
		 if (token.tokenType == Tokens.NO) {
			 read();
			 withData = false;
		 }
		 else if (table.getTableType() == TableBase.TEXT_TABLE) {
			 throw unexpectedTokenRequire(Tokens.T_NO);
		 }
		 readThis(Tokens.DATA);
		 if (token.tokenType == Tokens.ON) {
			 if (!table.isTemp()) {
				 throw unexpectedToken();
			 }
			 read();
			 readThis(Tokens.COMMIT);
			 if (token.tokenType == Tokens.DELETE) {
			}
			 else if (token.tokenType == Tokens.PRESERVE) {
				 table.persistenceScope = TableBase.SCOPE_SESSION;
			 }
			 read();
			 readThis(Tokens.ROWS);
		 }
		 if (columnNames == null) {
			 columnNames = queryExpression.getResultColumnNames();
		 }
		 else {
			 if (columnNames.length != queryExpression.getColumnCount()) {
				 throw Error.error(ErrorCode.X_42593);
			 }
		 }
		 TableUtil.setColumnsInSchemaTable(table, columnNames, queryExpression.getColumnTypes());
		 table.createPrimaryKey();
		 if (withData) {
			 statement = new StatementQuery(session, queryExpression, compileContext);
			 readName = statement.getTableNamesForRead()[0];
		 }
		 Object[] args = new Object[] {
		 table, null, statement }
		;
		 String sql = getLastPart();
		 StatementSchema st = new StatementSchema(sql, StatementTypes.CREATE_TABLE, args, readName, null);
		 return st;
	 }
	 static Table addTableConstraintDefinitions(Session session, Table table, HsqlArrayList tempConstraints, HsqlArrayList constraintList, boolean addToSchema) {
		 Constraint c = (Constraint) tempConstraints.get(0);
		 String namePart = c.getName() == null ? null : c.getName().name;
		 HsqlName indexName = session.database.nameManager.newAutoName(""IDX"", namePart, table.getSchemaName(), table.getName(), SchemaObject.INDEX);
		 c.setColumnsIndexes(table);
		 table.createPrimaryKey(indexName, c.core.mainCols, true);
		 if (c.core.mainCols != null) {
			 Constraint newconstraint = new Constraint(c.getName(), table, table.getPrimaryIndex(), SchemaObject.ConstraintTypes.PRIMARY_KEY);
			 table.addConstraint(newconstraint);
			 if (addToSchema) {
				 session.database.schemaManager.addSchemaObject(newconstraint);
			 }
		 }
		 for (int i = 1;
		 i < tempConstraints.size();
		 i++) {
			 c = (Constraint) tempConstraints.get(i);
			 switch (c.constType) {
				 case SchemaObject.ConstraintTypes.UNIQUE : {
					 c.setColumnsIndexes(table);
					 if (table.getUniqueConstraintForColumns(c.core.mainCols) != null) {
						 throw Error.error(ErrorCode.X_42522);
					 }
					 indexName = session.database.nameManager.newAutoName(""IDX"", c.getName().name, table.getSchemaName(), table.getName(), SchemaObject.INDEX);
					 Index index = table.createAndAddIndexStructure(session, indexName, c.core.mainCols, null, null, true, true, false);
					 Constraint newconstraint = new Constraint(c.getName(), table, index, SchemaObject.ConstraintTypes.UNIQUE);
					 table.addConstraint(newconstraint);
					 if (addToSchema) {
						 session.database.schemaManager.addSchemaObject( newconstraint);
					 }
					 break;
				 }
				 case SchemaObject.ConstraintTypes.FOREIGN_KEY : {
					 addForeignKey(session, table, c, constraintList);
					 break;
				 }
				 case SchemaObject.ConstraintTypes.CHECK : {
					 try {
						 c.prepareCheckConstraint(session, table, false);
					 }
					 catch (HsqlException e) {
						 if (session.isProcessingScript()) {
							 break;
						 }
						 throw e;
					 }
					 table.addConstraint(c);
					 if (c.isNotNull()) {
						 ColumnSchema column = table.getColumn(c.notNullColumnIndex);
						 column.setNullable(false);
						 table.setColumnTypeVars(c.notNullColumnIndex);
					 }
					 if (addToSchema) {
						 session.database.schemaManager.addSchemaObject(c);
					 }
					 break;
				 }
			 }
		 }
		 return table;
	 }
	 static void addForeignKey(Session session, Table table, Constraint c, HsqlArrayList constraintList) {
		 HsqlName mainTableName = c.getMainTableName();
		 if (mainTableName == table.getName()) {
			 c.core.mainTable = table;
		 }
		 else {
			 Table mainTable = session.database.schemaManager.findUserTable(session, mainTableName.name, mainTableName.schema.name);
			 if (mainTable == null) {
				 if (constraintList == null) {
					 throw Error.error(ErrorCode.X_42501, mainTableName.name);
				 }
				 constraintList.add(c);
				 return;
			 }
			 c.core.mainTable = mainTable;
		 }
		 c.setColumnsIndexes(table);
		 Constraint uniqueConstraint = c.core.mainTable.getUniqueConstraintForColumns(c.core.mainCols, c.core.refCols);
		 if (uniqueConstraint == null) {
			 throw Error.error(ErrorCode.X_42523);
		 }
		 Index mainIndex = uniqueConstraint.getMainIndex();
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.checkCreateForeignKey(c);
		 boolean isForward = c.core.mainTable.getSchemaName() != table.getSchemaName();
		 int offset = session.database.schemaManager.getTableIndex(table);
		 if (offset != -1 && offset < session.database.schemaManager.getTableIndex( c.core.mainTable)) {
			 isForward = true;
		 }
		 HsqlName refIndexName = session.database.nameManager.newAutoName(""IDX"", table.getSchemaName(), table.getName(), SchemaObject.INDEX);
		 Index index = table.createAndAddIndexStructure(session, refIndexName, c.core.refCols, null, null, false, true, isForward);
		 HsqlName mainName = session.database.nameManager.newAutoName(""REF"", c.getName().name, table.getSchemaName(), table.getName(), SchemaObject.INDEX);
		 c.core.uniqueName = uniqueConstraint.getName();
		 c.core.mainName = mainName;
		 c.core.mainIndex = mainIndex;
		 c.core.refTable = table;
		 c.core.refName = c.getName();
		 c.core.refIndex = index;
		 c.isForward = isForward;
		 table.addConstraint(c);
		 c.core.mainTable.addConstraint(new Constraint(mainName, c));
		 session.database.schemaManager.addSchemaObject(c);
	 }
	 private Constraint readFKReferences(Table refTable, HsqlName constraintName, OrderedHashSet refColSet) {
		 HsqlName mainTableName;
		 OrderedHashSet mainColSet = null;
		 readThis(Tokens.REFERENCES);
		 HsqlName schema;
		 if (token.namePrefix == null) {
			 schema = refTable.getSchemaName();
		 }
		 else {
			 schema = database.schemaManager.getSchemaHsqlName(token.namePrefix);
		 }
		 if (refTable.getSchemaName() == schema && refTable.getName().name.equals(token.tokenString)) {
			 mainTableName = refTable.getName();
			 read();
		 }
		 else {
			 mainTableName = readFKTableName(schema);
		 }
		 if (token.tokenType == Tokens.OPENBRACKET) {
			 mainColSet = readColumnNames(false);
		 }
		 else {
			 if (mainTableName == refTable.getName()) {
			 }
			 else {
			 }
		 }
		 int matchType = OpTypes.MATCH_SIMPLE;
		 if (token.tokenType == Tokens.MATCH) {
			 read();
			 switch (token.tokenType) {
				 case Tokens.SIMPLE : read();
				 break;
				 case Tokens.PARTIAL : throw super.unsupportedFeature();
				 case Tokens.FULL : read();
				 matchType = OpTypes.MATCH_FULL;
				 break;
				 default : throw unexpectedToken();
			 }
		 }
		 int deleteAction = SchemaObject.ReferentialAction.NO_ACTION;
		 int updateAction = SchemaObject.ReferentialAction.NO_ACTION;
		 OrderedIntHashSet set = new OrderedIntHashSet();
		 while (token.tokenType == Tokens.ON) {
			 read();
			 if (!set.add(token.tokenType)) {
				 throw unexpectedToken();
			 }
			 if (token.tokenType == Tokens.DELETE) {
				 read();
				 if (token.tokenType == Tokens.SET) {
					 read();
					 switch (token.tokenType) {
						 case Tokens.DEFAULT : {
							 read();
							 deleteAction = SchemaObject.ReferentialAction.SET_DEFAULT;
							 break;
						 }
						 case Tokens.NULL : read();
						 deleteAction = SchemaObject.ReferentialAction.SET_NULL;
						 break;
						 default : throw unexpectedToken();
					 }
				 }
				 else if (token.tokenType == Tokens.CASCADE) {
					 read();
					 deleteAction = SchemaObject.ReferentialAction.CASCADE;
				 }
				 else if (token.tokenType == Tokens.RESTRICT) {
					 read();
				 }
				 else {
					 readThis(Tokens.NO);
					 readThis(Tokens.ACTION);
				 }
			 }
			 else if (token.tokenType == Tokens.UPDATE) {
				 read();
				 if (token.tokenType == Tokens.SET) {
					 read();
					 switch (token.tokenType) {
						 case Tokens.DEFAULT : {
							 read();
							 deleteAction = SchemaObject.ReferentialAction.SET_DEFAULT;
							 break;
						 }
						 case Tokens.NULL : read();
						 deleteAction = SchemaObject.ReferentialAction.SET_NULL;
						 break;
						 default : throw unexpectedToken();
					 }
				 }
				 else if (token.tokenType == Tokens.CASCADE) {
					 read();
					 updateAction = SchemaObject.ReferentialAction.CASCADE;
				 }
				 else if (token.tokenType == Tokens.RESTRICT) {
					 read();
				 }
				 else {
					 readThis(Tokens.NO);
					 readThis(Tokens.ACTION);
				 }
			 }
			 else {
				 throw unexpectedToken();
			 }
		 }
		 if (constraintName == null) {
			 constraintName = database.nameManager.newAutoName(""FK"", refTable.getSchemaName(), refTable.getName(), SchemaObject.CONSTRAINT);
		 }
		 return new Constraint(constraintName, refTable.getName(), refColSet, mainTableName, mainColSet, SchemaObject.ConstraintTypes.FOREIGN_KEY, deleteAction, updateAction, matchType);
	 }
	 private HsqlName readFKTableName(HsqlName schema) {
		 HsqlName name;
		 checkIsSchemaObjectName();
		 Table table = database.schemaManager.findUserTable(session, token.tokenString, schema.name);
		 if (table == null) {
			 name = database.nameManager.newHsqlName(schema, token.tokenString, isDelimitedIdentifier(), SchemaObject.TABLE);
		 }
		 else {
			 name = table.getName();
		 }
		 read();
		 return name;
	 }
	 StatementSchema compileCreateView(boolean alter) {
		 read();
		 HsqlName name = readNewSchemaObjectName(SchemaObject.VIEW, true);
		 name.setSchemaIfNull(session.getCurrentSchemaHsqlName());
		 checkSchemaUpdateAuthorisation(name.schema);
		 HsqlName[] colList = null;
		 if (token.tokenType == Tokens.OPENBRACKET) {
			 colList = readColumnNames(name);
		 }
		 readThis(Tokens.AS);
		 startRecording();
		 int position = getPosition();
		 QueryExpression queryExpression;
		 try {
			 queryExpression = XreadQueryExpression();
		 }
		 catch (HsqlException e) {
			 queryExpression = XreadJoinedTable();
		 }
		 Token[] tokenisedStatement = getRecordedStatement();
		 int check = SchemaObject.ViewCheckModes.CHECK_NONE;
		 if (token.tokenType == Tokens.WITH) {
			 read();
			 check = SchemaObject.ViewCheckModes.CHECK_CASCADE;
			 if (readIfThis(Tokens.LOCAL)) {
				 check = SchemaObject.ViewCheckModes.CHECK_LOCAL;
			 }
			 else {
				 readIfThis(Tokens.CASCADED);
			 }
			 readThis(Tokens.CHECK);
			 readThis(Tokens.OPTION);
		 }
		 View view = new View(database, name, colList, check);
		 queryExpression.setView(view);
		 queryExpression.resolve(session);
		 view.setStatement(Token.getSQL(tokenisedStatement));
		 String fullSQL = getLastPart();
		 Object[] args = new Object[]{
		 view }
		;
		 int type = alter ? StatementTypes.ALTER_VIEW : StatementTypes.CREATE_VIEW;
		 StatementSchema cs = new StatementSchema(fullSQL, type, args);
		 StatementQuery s = new StatementQuery(session, queryExpression, compileContext);
		 cs.readTableNames = s.readTableNames;
		 return cs;
	 }
	 StatementSchema compileCreateSequence() {
		 read();
		 HsqlName name = readNewSchemaObjectName(SchemaObject.SEQUENCE, false);
		 NumberSequence sequence = new NumberSequence(name, Type.SQL_INTEGER);
		 readSequenceOptions(sequence, true, false);
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 sequence }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_SEQUENCE, args);
	 }
	 StatementSchema compileCreateDomain() {
		 UserTypeModifier userTypeModifier = null;
		 HsqlName name;
		 read();
		 name = readNewSchemaObjectName(SchemaObject.DOMAIN, false);
		 readIfThis(Tokens.AS);
		 Type type = readTypeDefinition(false).duplicate();
		 Expression defaultClause = null;
		 if (readIfThis(Tokens.DEFAULT)) {
			 defaultClause = readDefaultClause(type);
		 }
		 userTypeModifier = new UserTypeModifier(name, SchemaObject.DOMAIN, type);
		 userTypeModifier.setDefaultClause(defaultClause);
		 type.userTypeModifier = userTypeModifier;
		 HsqlArrayList tempConstraints = new HsqlArrayList();
		 compileContext.currentDomain = type;
		 while (true) {
			 boolean end = false;
			 switch (token.tokenType) {
				 case Tokens.CONSTRAINT : case Tokens.CHECK : readConstraint(type, tempConstraints);
				 break;
				 default : end = true;
				 break;
			 }
			 if (end) {
				 break;
			 }
		 }
		 compileContext.currentDomain = null;
		 for (int i = 0;
		 i < tempConstraints.size();
		 i++) {
			 Constraint c = (Constraint) tempConstraints.get(i);
			 c.prepareCheckConstraint(session, null, false);
			 userTypeModifier.addConstraint(c);
		 }
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 type }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_DOMAIN, args);
	 }
	 StatementSchema compileCreateType() {
		 read();
		 HsqlName name = readNewSchemaObjectName(SchemaObject.TYPE, false);
		 readThis(Tokens.AS);
		 Type type = readTypeDefinition(false).duplicate();
		 readIfThis(Tokens.FINAL);
		 UserTypeModifier userTypeModifier = new UserTypeModifier(name, SchemaObject.TYPE, type);
		 type.userTypeModifier = userTypeModifier;
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 type }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_TYPE, args);
	 }
	 StatementSchema compileCreateCharacterSet() {
		 read();
		 readThis(Tokens.SET);
		 HsqlName name = readNewSchemaObjectName(SchemaObject.CHARSET, false);
		 readIfThis(Tokens.AS);
		 readThis(Tokens.GET);
		 String schema = session.getSchemaName(token.namePrefix);
		 Charset source = (Charset) database.schemaManager.getSchemaObject(token.tokenString, schema, SchemaObject.CHARSET);
		 read();
		 if (token.tokenType == Tokens.COLLATION) {
			 read();
			 readThis(Tokens.FROM);
			 readThis(Tokens.DEFAULT);
		 }
		 Charset charset = new Charset(name);
		 charset.base = source.getName();
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 charset }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_CHARACTER_SET, args);
	 }
	 StatementSchema compileCreateAlias() {
		 HsqlName name = null;
		 Routine[] routines = null;
		 String alias;
		 String methodFQN = null;
		 if (!session.isProcessingScript()) {
			 throw super.unsupportedFeature();
		 }
		 read();
		 try {
			 alias = token.tokenString;
			 read();
			 readThis(Tokens.FOR);
			 methodFQN = token.tokenString;
			 read();
		 }
		 catch (HsqlException e) {
			 alias = null;
		 }
		 if (alias != null) {
			 HsqlName schema = database.schemaManager.getDefaultSchemaHsqlName();
			 name = database.nameManager.newHsqlName(schema, alias, SchemaObject.FUNCTION);
			 Method[] methods = Routine.getMethods(methodFQN);
			 routines = Routine.newRoutines(session, methods);
		 }
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 name, routines }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_ALIAS, args);
	 }
	 StatementSchema compileCreateTrigger() {
		 Table table;
		 Boolean isForEachRow = null;
		 boolean isNowait = false;
		 boolean hasQueueSize = false;
		 int queueSize = 0;
		 int beforeOrAfterType;
		 int operationType;
		 String className;
		 TriggerDef td;
		 HsqlName name;
		 HsqlName otherName = null;
		 OrderedHashSet columns = null;
		 int[] updateColumnIndexes = null;
		 read();
		 name = readNewSchemaObjectName(SchemaObject.TRIGGER, true);
		 switch (token.tokenType) {
			 case Tokens.INSTEAD : beforeOrAfterType = TriggerDef.getTiming(Tokens.INSTEAD);
			 read();
			 readThis(Tokens.OF);
			 break;
			 case Tokens.BEFORE : case Tokens.AFTER : beforeOrAfterType = TriggerDef.getTiming(token.tokenType);
			 read();
			 break;
			 default : throw unexpectedToken();
		 }
		 switch (token.tokenType) {
			 case Tokens.INSERT : case Tokens.DELETE : operationType = TriggerDef.getOperationType(token.tokenType);
			 read();
			 break;
			 case Tokens.UPDATE : operationType = TriggerDef.getOperationType(token.tokenType);
			 read();
			 if (token.tokenType == Tokens.OF && beforeOrAfterType != TriggerDef.INSTEAD) {
				 read();
				 columns = new OrderedHashSet();
				 readColumnNameList(columns, null, false);
			 }
			 break;
			 default : throw unexpectedToken();
		 }
		 readThis(Tokens.ON);
		 table = readTableName();
		 if (token.tokenType == Tokens.BEFORE) {
			 read();
			 checkIsSimpleName();
			 otherName = readNewSchemaObjectName(SchemaObject.TRIGGER, true);
		 }
		 name.setSchemaIfNull(table.getSchemaName());
		 checkSchemaUpdateAuthorisation(name.schema);
		 if (beforeOrAfterType == TriggerDef.INSTEAD) {
			 if (!table.isView() || ((View) table).getCheckOption() == SchemaObject.ViewCheckModes.CHECK_CASCADE) {
				 throw Error.error(ErrorCode.X_42538, name.schema.name);
			 }
		 }
		 else {
			 if (table.isView()) {
				 throw Error.error(ErrorCode.X_42538, name.schema.name);
			 }
		 }
		 if (name.schema != table.getSchemaName()) {
			 throw Error.error(ErrorCode.X_42505, name.schema.name);
		 }
		 name.parent = table.getName();
		 database.schemaManager.checkSchemaObjectNotExists(name);
		 if (columns != null) {
			 updateColumnIndexes = table.getColumnIndexes(columns);
			 for (int i = 0;
			 i < updateColumnIndexes.length;
			 i++) {
				 if (updateColumnIndexes[i] == -1) {
					 throw Error.error(ErrorCode.X_42544, (String) columns.get(i));
				 }
			 }
		 }
		 Expression condition = null;
		 String oldTableName = null;
		 String newTableName = null;
		 String oldRowName = null;
		 String newRowName = null;
		 Table[] transitions = new Table[4];
		 RangeVariable[] rangeVars = new RangeVariable[4];
		 String conditionSQL = null;
		 if (token.tokenType == Tokens.REFERENCING) {
			 read();
			 if (token.tokenType != Tokens.OLD && token.tokenType != Tokens.NEW) {
				 throw unexpectedToken();
			 }
			 while (true) {
				 if (token.tokenType == Tokens.OLD) {
					 if (operationType == StatementTypes.INSERT) {
						 throw unexpectedToken();
					 }
					 read();
					 if (token.tokenType == Tokens.TABLE) {
						 if (Boolean.TRUE.equals(isForEachRow) || oldTableName != null || beforeOrAfterType == TriggerDef.BEFORE) {
							 throw unexpectedToken();
						 }
						 read();
						 readIfThis(Tokens.AS);
						 checkIsSimpleName();
						 read();
						 oldTableName = token.tokenString;
						 String n = oldTableName;
						 if (n.equals(newTableName) || n.equals(oldRowName) || n.equals(newRowName)) {
							 throw unexpectedToken();
						 }
						 isForEachRow = Boolean.FALSE;
						 HsqlName hsqlName = database.nameManager.newHsqlName( table.getSchemaName(), n, isDelimitedIdentifier(), SchemaObject.TRANSITION);
						 Table transition = new Table(table, hsqlName);
						 RangeVariable range = new RangeVariable(transition, null, null, null, compileContext);
						 transitions[TriggerDef.OLD_TABLE] = transition;
						 rangeVars[TriggerDef.OLD_TABLE] = range;
					 }
					 else {
						 if (Boolean.FALSE.equals(isForEachRow) || oldRowName != null) {
							 throw unexpectedToken();
						 }
						 readIfThis(Tokens.ROW);
						 readIfThis(Tokens.AS);
						 checkIsSimpleName();
						 oldRowName = token.tokenString;
						 read();
						 String n = oldRowName;
						 if (n.equals(newTableName) || n.equals(oldTableName) || n.equals(newRowName)) {
							 throw unexpectedToken();
						 }
						 isForEachRow = Boolean.TRUE;
						 HsqlName hsqlName = database.nameManager.newHsqlName( table.getSchemaName(), n, isDelimitedIdentifier(), SchemaObject.TRANSITION);
						 Table transition = new Table(table, hsqlName);
						 RangeVariable range = new RangeVariable(transition, null, null, null, compileContext);
						 transitions[TriggerDef.OLD_ROW] = transition;
						 rangeVars[TriggerDef.OLD_ROW] = range;
					 }
				 }
				 else if (token.tokenType == Tokens.NEW) {
					 if (operationType == StatementTypes.DELETE_WHERE) {
						 throw unexpectedToken();
					 }
					 read();
					 if (token.tokenType == Tokens.TABLE) {
						 if (Boolean.TRUE.equals(isForEachRow) || newTableName != null || beforeOrAfterType == TriggerDef.BEFORE) {
							 throw unexpectedToken();
						 }
						 read();
						 readIfThis(Tokens.AS);
						 checkIsSimpleName();
						 newTableName = token.tokenString;
						 read();
						 isForEachRow = Boolean.FALSE;
						 String n = newTableName;
						 if (n.equals(oldTableName) || n.equals(oldRowName) || n.equals(newRowName)) {
							 throw unexpectedToken();
						 }
						 HsqlName hsqlName = database.nameManager.newHsqlName( table.getSchemaName(), n, isDelimitedIdentifier(), SchemaObject.TRANSITION);
						 Table transition = new Table(table, hsqlName);
						 RangeVariable range = new RangeVariable(transition, null, null, null, compileContext);
						 transitions[TriggerDef.NEW_TABLE] = transition;
						 rangeVars[TriggerDef.NEW_TABLE] = range;
					 }
					 else {
						 if (Boolean.FALSE.equals(isForEachRow) || newRowName != null) {
							 throw unexpectedToken();
						 }
						 readIfThis(Tokens.ROW);
						 readIfThis(Tokens.AS);
						 checkIsSimpleName();
						 newRowName = token.tokenString;
						 read();
						 isForEachRow = Boolean.TRUE;
						 String n = newRowName;
						 if (n.equals(oldTableName) || n.equals(newTableName) || n.equals(oldRowName)) {
							 throw unexpectedToken();
						 }
						 HsqlName hsqlName = database.nameManager.newHsqlName( table.getSchemaName(), n, isDelimitedIdentifier(), SchemaObject.TRANSITION);
						 Table transition = new Table(table, hsqlName);
						 RangeVariable range = new RangeVariable(transition, null, null, null, compileContext);
						 transitions[TriggerDef.NEW_ROW] = transition;
						 rangeVars[TriggerDef.NEW_ROW] = range;
					 }
				 }
				 else {
					 break;
				 }
			 }
		 }
		 if (Boolean.TRUE.equals(isForEachRow) && token.tokenType != Tokens.FOR) {
			 throw unexpectedTokenRequire(Tokens.T_FOR);
		 }
		 if (token.tokenType == Tokens.FOR) {
			 read();
			 readThis(Tokens.EACH);
			 if (token.tokenType == Tokens.ROW) {
				 if (Boolean.FALSE.equals(isForEachRow)) {
					 throw unexpectedToken();
				 }
				 isForEachRow = Boolean.TRUE;
			 }
			 else if (token.tokenType == Tokens.STATEMENT) {
				 if (Boolean.TRUE.equals(isForEachRow) || beforeOrAfterType == TriggerDef.BEFORE) {
					 throw unexpectedToken();
				 }
				 isForEachRow = Boolean.FALSE;
			 }
			 else {
				 throw unexpectedToken();
			 }
			 read();
		 }
		 if (rangeVars[TriggerDef.OLD_TABLE] != null) {
		}
		 if (rangeVars[TriggerDef.NEW_TABLE] != null) {
		}
		 if (Tokens.T_QUEUE.equals(token.tokenString)) {
			 read();
			 queueSize = readInteger();
			 hasQueueSize = true;
		 }
		 if (Tokens.T_NOWAIT.equals(token.tokenString)) {
			 read();
			 isNowait = true;
		 }
		 if (token.tokenType == Tokens.WHEN && beforeOrAfterType != TriggerDef.INSTEAD) {
			 read();
			 readThis(Tokens.OPENBRACKET);
			 int position = getPosition();
			 isCheckOrTriggerCondition = true;
			 condition = XreadBooleanValueExpression();
			 conditionSQL = getLastPart(position);
			 isCheckOrTriggerCondition = false;
			 readThis(Tokens.CLOSEBRACKET);
			 HsqlList unresolved = condition.resolveColumnReferences(rangeVars, null);
			 ExpressionColumn.checkColumnsResolved(unresolved);
			 condition.resolveTypes(session, null);
			 if (condition.getDataType() != Type.SQL_BOOLEAN) {
				 throw Error.error(ErrorCode.X_42568);
			 }
		 }
		 if (isForEachRow == null) {
			 isForEachRow = Boolean.FALSE;
		 }
		 if (token.tokenType == Tokens.CALL) {
			 int position = getPosition();
			 try {
				 read();
				 checkIsSimpleName();
				 checkIsDelimitedIdentifier();
				 className = token.tokenString;
				 read();
				 td = new TriggerDef(name, beforeOrAfterType, operationType, isForEachRow.booleanValue(), table, transitions, rangeVars, condition, conditionSQL, updateColumnIndexes, className, isNowait, queueSize);
				 String sql = getLastPart();
				 Object[] args = new Object[] {
				 td, otherName }
				;
				 return new StatementSchema(sql, StatementTypes.CREATE_TRIGGER, args, null, table.getName());
			 }
			 catch (HsqlException e) {
				 rewind(position);
			 }
		 }
		 if (hasQueueSize) {
			 throw unexpectedToken(Tokens.T_QUEUE);
		 }
		 if (isNowait) {
			 throw unexpectedToken(Tokens.T_NOWAIT);
		 }
		 Routine routine = compileTriggerRoutine(table, rangeVars, beforeOrAfterType, operationType);
		 td = new TriggerDefSQL(name, beforeOrAfterType, operationType, isForEachRow.booleanValue(), table, transitions, rangeVars, condition, conditionSQL, updateColumnIndexes, routine);
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 td, otherName }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_TRIGGER, args, null, table.getName());
	 }
	 Routine compileTriggerRoutine(Table table, RangeVariable[] ranges, int beforeOrAfter, int operation) {
		 int impact = (beforeOrAfter == TriggerDef.BEFORE) ? Routine.READS_SQL : Routine .MODIFIES_SQL;
		 Routine routine = new Routine(table, ranges, impact, beforeOrAfter, operation);
		 startRecording();
		 Statement statement = compileSQLProcedureStatementOrNull(routine, null);
		 if (statement == null) {
			 throw unexpectedToken();
		 }
		 Token[] tokenisedStatement = getRecordedStatement();
		 String sql = Token.getSQL(tokenisedStatement);
		 statement.setSQL(sql);
		 routine.setProcedure(statement);
		 routine.resolve(session);
		 return routine;
	 }
	 ColumnSchema readColumnDefinitionOrNull(Table table, HsqlName hsqlName, HsqlArrayList constraintList) {
		 boolean isGenerated = false;
		 boolean isIdentity = false;
		 boolean isPKIdentity = false;
		 boolean generatedAlways = false;
		 Expression generateExpr = null;
		 boolean isNullable = true;
		 Expression defaultExpr = null;
		 Type typeObject = null;
		 NumberSequence sequence = null;
		 if (token.tokenType == Tokens.GENERATED) {
			 read();
			 readThis(Tokens.ALWAYS);
			 isGenerated = true;
			 generatedAlways = true;
			 throw unexpectedToken(Tokens.T_GENERATED);
		 }
		 else if (token.tokenType == Tokens.IDENTITY) {
			 read();
			 isIdentity = true;
			 isPKIdentity = true;
			 typeObject = Type.SQL_INTEGER;
			 sequence = new NumberSequence(null, 0, 1, typeObject);
		 }
		 else if (token.tokenType == Tokens.COMMA) {
			 return null;
		 }
		 else if (token.tokenType == Tokens.CLOSEBRACKET) {
			 return null;
		 }
		 else {
			 typeObject = readTypeDefinition(true);
		 }
		 if (isGenerated || isIdentity) {
		}
		 else if (token.tokenType == Tokens.DEFAULT) {
			 read();
			 defaultExpr = readDefaultClause(typeObject);
		 }
		 else if (token.tokenType == Tokens.GENERATED && !isIdentity) {
			 read();
			 if (token.tokenType == Tokens.BY) {
				 read();
				 readThis(Tokens.DEFAULT);
			 }
			 else {
				 readThis(Tokens.ALWAYS);
				 generatedAlways = true;
			 }
			 readThis(Tokens.AS);
			 if (token.tokenType == Tokens.IDENTITY) {
				 read();
				 sequence = new NumberSequence(null, typeObject);
				 sequence.setAlways(generatedAlways);
				 if (token.tokenType == Tokens.OPENBRACKET) {
					 read();
					 readSequenceOptions(sequence, false, false);
					 readThis(Tokens.CLOSEBRACKET);
				 }
				 isIdentity = true;
			 }
			 else if (token.tokenType == Tokens.OPENBRACKET) {
				 if (!generatedAlways) {
					 throw super.unexpectedTokenRequire(Tokens.T_ALWAYS);
				 }
				 isGenerated = true;
			 }
		 }
		 else if (token.tokenType == Tokens.IDENTITY && !isIdentity) {
			 read();
			 isIdentity = true;
			 isPKIdentity = true;
			 sequence = new NumberSequence(null, 0, 1, typeObject);
		 }
		 if (isGenerated) {
			 readThis(Tokens.OPENBRACKET);
			 generateExpr = XreadValueExpression();
			 readThis(Tokens.CLOSEBRACKET);
		 }
		 ColumnSchema column = new ColumnSchema(hsqlName, typeObject, isNullable, false, defaultExpr);
		 column.setGeneratingExpression(generateExpr);
		 readColumnConstraints(table, column, constraintList);
		 if (token.tokenType == Tokens.IDENTITY && !isIdentity) {
			 read();
			 isIdentity = true;
			 isPKIdentity = true;
			 sequence = new NumberSequence(null, 0, 1, typeObject);
		 }
		 if (isIdentity) {
			 column.setIdentity(sequence);
		 }
		 if (isPKIdentity && !column.isPrimaryKey()) {
			 OrderedHashSet set = new OrderedHashSet();
			 set.add(column.getName().name);
			 HsqlName constName = database.nameManager.newAutoName(""PK"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
			 Constraint c = new Constraint(constName, set, SchemaObject.ConstraintTypes.PRIMARY_KEY);
			 constraintList.set(0, c);
			 column.setPrimaryKey(true);
		 }
		 return column;
	 }
	 private void readSequenceOptions(NumberSequence sequence, boolean withType, boolean isAlter) {
		 OrderedIntHashSet set = new OrderedIntHashSet();
		 while (true) {
			 boolean end = false;
			 if (set.contains(token.tokenType)) {
				 throw unexpectedToken();
			 }
			 switch (token.tokenType) {
				 case Tokens.AS : {
					 if (withType) {
						 read();
						 Type type = readTypeDefinition(true);
						 sequence.setDefaults(sequence.getName(), type);
						 break;
					 }
					 throw unexpectedToken();
				 }
				 case Tokens.START : {
					 set.add(token.tokenType);
					 read();
					 readThis(Tokens.WITH);
					 long value = readBigint();
					 sequence.setStartValueNoCheck(value);
					 break;
				 }
				 case Tokens.RESTART : {
					 if (!isAlter) {
						 end = true;
						 break;
					 }
					 set.add(token.tokenType);
					 read();
					 if (readIfThis(Tokens.WITH)) {
						 long value = readBigint();
						 sequence.setCurrentValueNoCheck(value);
					 }
					 else {
						 sequence.setStartValueDefault();
					 }
					 break;
				 }
				 case Tokens.INCREMENT : {
					 set.add(token.tokenType);
					 read();
					 readThis(Tokens.BY);
					 long value = readBigint();
					 sequence.setIncrement(value);
					 break;
				 }
				 case Tokens.NO : read();
				 if (token.tokenType == Tokens.MAXVALUE) {
					 sequence.setDefaultMaxValue();
				 }
				 else if (token.tokenType == Tokens.MINVALUE) {
					 sequence.setDefaultMinValue();
				 }
				 else if (token.tokenType == Tokens.CYCLE) {
					 sequence.setCycle(false);
				 }
				 else {
					 throw unexpectedToken();
				 }
				 set.add(token.tokenType);
				 read();
				 break;
				 case Tokens.MAXVALUE : {
					 set.add(token.tokenType);
					 read();
					 long value = readBigint();
					 sequence.setMaxValueNoCheck(value);
					 break;
				 }
				 case Tokens.MINVALUE : {
					 set.add(token.tokenType);
					 read();
					 long value = readBigint();
					 sequence.setMinValueNoCheck(value);
					 break;
				 }
				 case Tokens.CYCLE : set.add(token.tokenType);
				 read();
				 sequence.setCycle(true);
				 break;
				 default : end = true;
				 break;
			 }
			 if (end) {
				 break;
			 }
		 }
		 sequence.checkValues();
	 }
	 private void readConstraint(SchemaObject schemaObject, HsqlArrayList constraintList) {
		 HsqlName constName = null;
		 if (token.tokenType == Tokens.CONSTRAINT) {
			 read();
			 constName = readNewDependentSchemaObjectName(schemaObject.getName(), SchemaObject.CONSTRAINT);
		 }
		 switch (token.tokenType) {
			 case Tokens.PRIMARY : {
				 if (schemaObject.getName().type != SchemaObject.TABLE) {
					 throw this.unexpectedTokenRequire(Tokens.T_CHECK);
				 }
				 read();
				 readThis(Tokens.KEY);
				 Constraint mainConst;
				 mainConst = (Constraint) constraintList.get(0);
				 if (mainConst.constType == SchemaObject.ConstraintTypes.PRIMARY_KEY) {
					 throw Error.error(ErrorCode.X_42532);
				 }
				 if (constName == null) {
					 constName = database.nameManager.newAutoName(""PK"", schemaObject.getSchemaName(), schemaObject.getName(), SchemaObject.CONSTRAINT);
				 }
				 OrderedHashSet set = readColumnNames(false);
				 Constraint c = new Constraint(constName, set, SchemaObject.ConstraintTypes.PRIMARY_KEY);
				 constraintList.set(0, c);
				 break;
			 }
			 case Tokens.UNIQUE : {
				 if (schemaObject.getName().type != SchemaObject.TABLE) {
					 throw this.unexpectedTokenRequire(Tokens.T_CHECK);
				 }
				 read();
				 OrderedHashSet set = readColumnNames(false);
				 if (constName == null) {
					 constName = database.nameManager.newAutoName(""CT"", schemaObject.getSchemaName(), schemaObject.getName(), SchemaObject.CONSTRAINT);
				 }
				 Constraint c = new Constraint(constName, set, SchemaObject.ConstraintTypes.UNIQUE);
				 constraintList.add(c);
				 break;
			 }
			 case Tokens.FOREIGN : {
				 if (schemaObject.getName().type != SchemaObject.TABLE) {
					 throw this.unexpectedTokenRequire(Tokens.T_CHECK);
				 }
				 read();
				 readThis(Tokens.KEY);
				 OrderedHashSet set = readColumnNames(false);
				 Constraint c = readFKReferences((Table) schemaObject, constName, set);
				 constraintList.add(c);
				 break;
			 }
			 case Tokens.CHECK : {
				 read();
				 if (constName == null) {
					 constName = database.nameManager.newAutoName(""CT"", schemaObject.getSchemaName(), schemaObject.getName(), SchemaObject.CONSTRAINT);
				 }
				 Constraint c = new Constraint(constName, null, SchemaObject.ConstraintTypes.CHECK);
				 readCheckConstraintCondition(c);
				 constraintList.add(c);
				 break;
			 }
			 default : {
				 if (constName != null) {
					 throw super.unexpectedToken();
				 }
			 }
		 }
	 }
	 void readColumnConstraints(Table table, ColumnSchema column, HsqlArrayList constraintList) {
		 boolean end = false;
		 boolean hasNotNullConstraint = false;
		 boolean hasNullNoiseWord = false;
		 boolean hasPrimaryKey = false;
		 while (true) {
			 HsqlName constName = null;
			 if (token.tokenType == Tokens.CONSTRAINT) {
				 read();
				 constName = readNewDependentSchemaObjectName(table.getName(), SchemaObject.CONSTRAINT);
			 }
			 switch (token.tokenType) {
				 case Tokens.PRIMARY : {
					 if (hasNullNoiseWord || hasPrimaryKey) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.KEY);
					 Constraint existingConst = (Constraint) constraintList.get(0);
					 if (existingConst.constType == SchemaObject.ConstraintTypes.PRIMARY_KEY) {
						 throw Error.error(ErrorCode.X_42532);
					 }
					 OrderedHashSet set = new OrderedHashSet();
					 set.add(column.getName().name);
					 if (constName == null) {
						 constName = database.nameManager.newAutoName(""PK"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
					 }
					 Constraint c = new Constraint( constName, set, SchemaObject.ConstraintTypes.PRIMARY_KEY);
					 constraintList.set(0, c);
					 column.setPrimaryKey(true);
					 hasPrimaryKey = true;
					 break;
				 }
				 case Tokens.UNIQUE : {
					 read();
					 OrderedHashSet set = new OrderedHashSet();
					 set.add(column.getName().name);
					 if (constName == null) {
						 constName = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
					 }
					 Constraint c = new Constraint(constName, set, SchemaObject.ConstraintTypes.UNIQUE);
					 constraintList.add(c);
					 break;
				 }
				 case Tokens.FOREIGN : {
					 read();
					 readThis(Tokens.KEY);
				 }
				 case Tokens.REFERENCES : {
					 OrderedHashSet set = new OrderedHashSet();
					 set.add(column.getName().name);
					 Constraint c = readFKReferences(table, constName, set);
					 constraintList.add(c);
					 break;
				 }
				 case Tokens.CHECK : {
					 read();
					 if (constName == null) {
						 constName = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
					 }
					 Constraint c = new Constraint(constName, null, SchemaObject.ConstraintTypes.CHECK);
					 readCheckConstraintCondition(c);
					 OrderedHashSet set = c.getCheckColumnExpressions();
					 for (int i = 0;
					 i < set.size();
					 i++) {
						 ExpressionColumn e = (ExpressionColumn) set.get(i);
						 if (column.getName().name.equals(e.getColumnName())) {
							 if (e.getSchemaName() != null && e.getSchemaName() != table.getSchemaName().name) {
								 throw Error.error(ErrorCode.X_42505);
							 }
						 }
						 else {
							 throw Error.error(ErrorCode.X_42501);
						 }
					 }
					 constraintList.add(c);
					 break;
				 }
				 case Tokens.NOT : {
					 if (hasNotNullConstraint || hasNullNoiseWord) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.NULL);
					 if (constName == null) {
						 constName = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
					 }
					 Constraint c = new Constraint(constName, null, SchemaObject.ConstraintTypes.CHECK);
					 c.check = new ExpressionLogical(column);
					 constraintList.add(c);
					 hasNotNullConstraint = true;
					 break;
				 }
				 case Tokens.NULL : {
					 if (hasNotNullConstraint || hasNullNoiseWord || hasPrimaryKey) {
						 throw unexpectedToken();
					 }
					 if (constName != null) {
						 throw unexpectedToken();
					 }
					 read();
					 hasNullNoiseWord = true;
					 break;
				 }
				 default : end = true;
				 break;
			 }
			 if (end) {
				 break;
			 }
		 }
	 }
	 void readCheckConstraintCondition(Constraint c) {
		 readThis(Tokens.OPENBRACKET);
		 startRecording();
		 isCheckOrTriggerCondition = true;
		 Expression condition = XreadBooleanValueExpression();
		 isCheckOrTriggerCondition = false;
		 Token[] tokens = getRecordedStatement();
		 readThis(Tokens.CLOSEBRACKET);
		 c.check = condition;
	 }
	 private int[] readColumnList(Table table, boolean ascOrDesc) {
		 OrderedHashSet set = readColumnNames(ascOrDesc);
		 return table.getColumnIndexes(set);
	 }
	 StatementSchema compileCreateIndex(boolean unique) {
		 Table table;
		 HsqlName indexHsqlName;
		 read();
		 indexHsqlName = readNewSchemaObjectName(SchemaObject.INDEX, true);
		 readThis(Tokens.ON);
		 table = readTableName();
		 HsqlName tableSchema = table.getSchemaName();
		 indexHsqlName.setSchemaIfNull(tableSchema);
		 indexHsqlName.parent = table.getName();
		 if (indexHsqlName.schema != tableSchema) {
			 throw Error.error(ErrorCode.X_42505);
		 }
		 indexHsqlName.schema = table.getSchemaName();
		 int[] indexColumns = readColumnList(table, true);
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 table, indexColumns, indexHsqlName, Boolean.valueOf(unique) }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_INDEX, args, null, table.getName());
	 }
	 StatementSchema compileCreateSchema() {
		 HsqlName schemaName = null;
		 String authorisation = null;
		 read();
		 if (token.tokenType != Tokens.AUTHORIZATION) {
			 schemaName = readNewSchemaName();
		 }
		 if (token.tokenType == Tokens.AUTHORIZATION) {
			 read();
			 checkIsSimpleName();
			 authorisation = token.tokenString;
			 read();
			 if (schemaName == null) {
				 Grantee owner = database.getGranteeManager().get(authorisation);
				 if (owner == null) {
					 throw Error.error(ErrorCode.X_28501, authorisation);
				 }
				 schemaName = database.nameManager.newHsqlName(owner.getName().name, isDelimitedIdentifier(), SchemaObject.SCHEMA);
				 SqlInvariants.checkSchemaNameNotSystem(token.tokenString);
			 }
		 }
		 if (SqlInvariants.PUBLIC_ROLE_NAME.equals(authorisation)) {
			 throw Error.error(ErrorCode.X_28502, authorisation);
		 }
		 Grantee owner = authorisation == null ? session.getGrantee() : database.getGranteeManager() .get(authorisation);
		 if (owner == null) {
			 throw Error.error(ErrorCode.X_28501, authorisation);
		 }
		 if (!session.getGrantee().isSchemaCreator()) {
			 throw Error.error(ErrorCode.X_0L000, session.getGrantee().getNameString());
		 }
		 if (database.schemaManager.schemaExists(schemaName.name)) {
			 throw Error.error(ErrorCode.X_42504, schemaName.name);
		 }
		 if (schemaName.name.equals(SqlInvariants.LOBS_SCHEMA)) {
			 schemaName = SqlInvariants.LOBS_SCHEMA_HSQLNAME;
			 owner = schemaName.owner;
		 }
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 schemaName, owner }
		;
		 HsqlArrayList list = new HsqlArrayList();
		 StatementSchema cs = new StatementSchema(sql, StatementTypes.CREATE_SCHEMA, args, null, null);
		 cs.setSchemaHsqlName(schemaName);
		 list.add(cs);
		 getCompiledStatementBody(list);
		 StatementSchema[] array = new StatementSchema[list.size()];
		 list.toArray(array);
		 boolean swapped;
		 do {
			 swapped = false;
			 for (int i = 0;
			 i < array.length - 1;
			 i++) {
				 if (array[i].order > array[i + 1].order) {
					 StatementSchema temp = array[i + 1];
					 array[i + 1] = array[i];
					 array[i] = temp;
					 swapped = true;
				 }
			 }
		 }
		 while (swapped);
		 return new StatementSchemaDefinition(array);
	 }
	 void getCompiledStatementBody(HsqlList list) {
		 int position;
		 String sql;
		 int statementType;
		 for (boolean end = false;
		 !end;
		 ) {
			 StatementSchema cs = null;
			 position = getPosition();
			 switch (token.tokenType) {
				 case Tokens.CREATE : read();
				 switch (token.tokenType) {
					 case Tokens.SCHEMA : case Tokens.USER : case Tokens.UNIQUE : throw unexpectedToken();
					 case Tokens.INDEX : statementType = StatementTypes.CREATE_INDEX;
					 sql = getStatement(position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 case Tokens.SEQUENCE : cs = compileCreateSequence();
					 cs.sql = getLastPart(position);
					 break;
					 case Tokens.ROLE : cs = compileCreateRole();
					 cs.sql = getLastPart(position);
					 break;
					 case Tokens.DOMAIN : statementType = StatementTypes.CREATE_DOMAIN;
					 sql = getStatement(position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 case Tokens.TYPE : cs = compileCreateType();
					 cs.sql = getLastPart(position);
					 break;
					 case Tokens.CHARACTER : cs = compileCreateCharacterSet();
					 cs.sql = getLastPart(position);
					 break;
					 case Tokens.ASSERTION : throw unexpectedToken();
					 case Tokens.TABLE : case Tokens.MEMORY : case Tokens.CACHED : case Tokens.TEMP : case Tokens.GLOBAL : case Tokens.TEMPORARY : case Tokens.TEXT : statementType = StatementTypes.CREATE_TABLE;
					 sql = getStatement(position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 case Tokens.TRIGGER : statementType = StatementTypes.CREATE_TRIGGER;
					 sql = getStatement(position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 case Tokens.VIEW : statementType = StatementTypes.CREATE_VIEW;
					 sql = getStatement(position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 case Tokens.FUNCTION : statementType = StatementTypes.CREATE_ROUTINE;
					 sql = getStatementForRoutine( position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 case Tokens.PROCEDURE : statementType = StatementTypes.CREATE_ROUTINE;
					 sql = getStatementForRoutine( position, startStatementTokensSchema);
					 cs = new StatementSchema(sql, statementType, null);
					 break;
					 default : throw unexpectedToken();
				 }
				 break;
				 case Tokens.GRANT : cs = compileGrantOrRevoke();
				 cs.sql = getLastPart(position);
				 break;
				 case Tokens.SEMICOLON : read();
				 end = true;
				 break;
				 case Tokens.X_ENDPARSE : end = true;
				 break;
				 default : throw unexpectedToken();
			 }
			 if (cs != null) {
				 cs.isSchemaDefinition = true;
				 list.add(cs);
			 }
		 }
	 }
	 StatementSchema compileCreateRole() {
		 read();
		 HsqlName name = readNewUserIdentifier();
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 name }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_ROLE, args);
	 }
	 StatementSchema compileCreateUser() {
		 HsqlName name;
		 String password;
		 boolean admin = false;
		 Grantee grantor = session.getGrantee();
		 read();
		 name = readNewUserIdentifier();
		 readThis(Tokens.PASSWORD);
		 password = readPassword();
		 if (token.tokenType == Tokens.ADMIN) {
			 read();
			 admin = true;
		 }
		 checkDatabaseUpdateAuthorisation();
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 name, password, grantor, Boolean.valueOf(admin) }
		;
		 return new StatementSchema(sql, StatementTypes.CREATE_USER, args);
	 }
	 HsqlName readNewUserIdentifier() {
		 checkIsSimpleName();
		 String tokenS = token.tokenString;
		 boolean isQuoted = isDelimitedIdentifier();
		 if (tokenS.equalsIgnoreCase(""SA"")) {
			 tokenS = ""SA"";
			 isQuoted = false;
		 }
		 HsqlName name = database.nameManager.newHsqlName(tokenS, isQuoted, SchemaObject.GRANTEE);
		 read();
		 return name;
	 }
	 String readPassword() {
		 String tokenS = token.tokenString;
		 read();
		 return tokenS;
	 }
	 Statement compileRenameObject(HsqlName name, int objectType) {
		 HsqlName newName = readNewSchemaObjectName(objectType, true);
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 name, newName }
		;
		 return new StatementSchema(sql, StatementTypes.RENAME_OBJECT, args);
	 }
	 void processAlterTableRename(Table table) {
		 HsqlName name = readNewSchemaObjectName(SchemaObject.TABLE, true);
		 name.setSchemaIfNull(table.getSchemaName());
		 if (table.getSchemaName() != name.schema) {
			 throw Error.error(ErrorCode.X_42505);
		 }
		 database.schemaManager.renameSchemaObject(table.getName(), name);
	 }
	 void processAlterTableAddUniqueConstraint(Table table, HsqlName name) {
		 if (name == null) {
			 name = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 int[] cols = this.readColumnList(table, false);
		 session.commit(false);
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.addUniqueConstraint(cols, name);
	 }
	 Statement compileAlterTableAddUniqueConstraint(Table table, HsqlName name) {
		 if (name == null) {
			 name = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 int[] cols = this.readColumnList(table, false);
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 cols, name }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, args, null, table.getName());
	 }
	 void processAlterTableAddForeignKeyConstraint(Table table, HsqlName name) {
		 if (name == null) {
			 name = database.nameManager.newAutoName(""FK"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 OrderedHashSet set = readColumnNames(false);
		 Constraint c = readFKReferences(table, name, set);
		 HsqlName mainTableName = c.getMainTableName();
		 c.core.mainTable = database.schemaManager.getTable(session, mainTableName.name, mainTableName.schema.name);
		 c.setColumnsIndexes(table);
		 session.commit(false);
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.addForeignKey(c);
	 }
	 Statement compileAlterTableAddForeignKeyConstraint(Table table, HsqlName name) {
		 if (name == null) {
			 name = database.nameManager.newAutoName(""FK"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 OrderedHashSet set = readColumnNames(false);
		 Constraint c = readFKReferences(table, name, set);
		 HsqlName mainTableName = c.getMainTableName();
		 c.core.mainTable = database.schemaManager.getTable(session, mainTableName.name, mainTableName.schema.name);
		 c.setColumnsIndexes(table);
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 c }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, args, c.core.mainTableName, table.getName());
	 }
	 void processAlterTableAddCheckConstraint(Table table, HsqlName name) {
		 Constraint check;
		 if (name == null) {
			 name = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 check = new Constraint(name, null, SchemaObject.ConstraintTypes.CHECK);
		 readCheckConstraintCondition(check);
		 session.commit(false);
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.addCheckConstraint(check);
	 }
	 Statement compileAlterTableAddCheckConstraint(Table table, HsqlName name) {
		 Constraint check;
		 if (name == null) {
			 name = database.nameManager.newAutoName(""CT"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 check = new Constraint(name, null, SchemaObject.ConstraintTypes.CHECK);
		 readCheckConstraintCondition(check);
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 check }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, args, null, table.getName());
	 }
	 void processAlterTableAddColumn(Table table) {
		 int colIndex = table.getColumnCount();
		 HsqlArrayList list = new HsqlArrayList();
		 Constraint constraint = new Constraint(null, null, SchemaObject.ConstraintTypes.TEMP);
		 list.add(constraint);
		 checkIsSchemaObjectName();
		 HsqlName hsqlName = database.nameManager.newColumnHsqlName(table.getName(), token.tokenString, isDelimitedIdentifier());
		 read();
		 ColumnSchema column = readColumnDefinitionOrNull(table, hsqlName, list);
		 if (column == null) {
			 throw Error.error(ErrorCode.X_42000);
		 }
		 if (token.tokenType == Tokens.BEFORE) {
			 read();
			 colIndex = table.getColumnIndex(token.tokenString);
			 read();
		 }
		 TableWorks tableWorks = new TableWorks(session, table);
		 session.commit(false);
		 tableWorks.addColumn(column, colIndex, list);
		 return;
	 }
	 Statement compileAlterTableAddColumn(Table table) {
		 int colIndex = table.getColumnCount();
		 HsqlArrayList list = new HsqlArrayList();
		 Constraint constraint = new Constraint(null, null, SchemaObject.ConstraintTypes.TEMP);
		 list.add(constraint);
		 checkIsSchemaObjectName();
		 HsqlName hsqlName = database.nameManager.newColumnHsqlName(table.getName(), token.tokenString, isDelimitedIdentifier());
		 read();
		 ColumnSchema column = readColumnDefinitionOrNull(table, hsqlName, list);
		 if (column == null) {
			 throw Error.error(ErrorCode.X_42000);
		 }
		 if (token.tokenType == Tokens.BEFORE) {
			 read();
			 colIndex = table.getColumnIndex(token.tokenString);
			 read();
		 }
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 column, new Integer(colIndex), list }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, args, null, table.getName());
	 }
	 void processAlterTableAddPrimaryKey(Table table, HsqlName name) {
		 if (name == null) {
			 name = session.database.nameManager.newAutoName(""PK"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 OrderedHashSet set = readColumnNames(false);
		 Constraint constraint = new Constraint(name, set, SchemaObject.ConstraintTypes.PRIMARY_KEY);
		 constraint.setColumnsIndexes(table);
		 session.commit(false);
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.addPrimaryKey(constraint, name);
	 }
	 Statement compileAlterTableAddPrimaryKey(Table table, HsqlName name) {
		 if (name == null) {
			 name = session.database.nameManager.newAutoName(""PK"", table.getSchemaName(), table.getName(), SchemaObject.CONSTRAINT);
		 }
		 OrderedHashSet set = readColumnNames(false);
		 Constraint constraint = new Constraint(name, set, SchemaObject.ConstraintTypes.PRIMARY_KEY);
		 constraint.setColumnsIndexes(table);
		 String sql = getLastPart();
		 Object[] args = new Object[]{
		 constraint }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, args, null, table.getName());
	 }
	 void processAlterTableDropColumn(Table table, String colName, boolean cascade) {
		 int colindex = table.getColumnIndex(colName);
		 if (table.getColumnCount() == 1) {
			 throw Error.error(ErrorCode.X_42591);
		 }
		 session.commit(false);
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.dropColumn(colindex, cascade);
	 }
	 Statement compileAlterTableDropColumn(Table table, String colName, boolean cascade) {
		 HsqlName writeName = null;
		 int colindex = table.getColumnIndex(colName);
		 if (table.getColumnCount() == 1) {
			 throw Error.error(ErrorCode.X_42591);
		 }
		 Object[] args = new Object[] {
		 table.getColumn(colindex).getName(), ValuePool.getInt(SchemaObject.CONSTRAINT), Boolean.valueOf(cascade), Boolean.valueOf(false) }
		;
		 if (!table.isTemp()) {
			 writeName = table.getName();
		 }
		 return new StatementSchema(null, StatementTypes.DROP_COLUMN, args, null, writeName);
	 }
	 void processAlterTableDropConstraint(Table table, String name, boolean cascade) {
		 session.commit(false);
		 TableWorks tableWorks = new TableWorks(session, table);
		 tableWorks.dropConstraint(name, cascade);
		 return;
	 }
	 void processAlterColumn(Table table, ColumnSchema column, int columnIndex) {
		 int position = getPosition();
		 switch (token.tokenType) {
			 case Tokens.RENAME : {
				 read();
				 readThis(Tokens.TO);
				 processAlterColumnRename(table, column);
				 return;
			 }
			 case Tokens.DROP : {
				 read();
				 if (token.tokenType == Tokens.DEFAULT) {
					 read();
					 TableWorks tw = new TableWorks(session, table);
					 tw.setColDefaultExpression(columnIndex, null);
					 return;
				 }
				 else if (token.tokenType == Tokens.GENERATED) {
					 read();
					 column.setIdentity(null);
					 table.setColumnTypeVars(columnIndex);
					 return;
				 }
				 else {
					 throw unexpectedToken();
				 }
			 }
			 case Tokens.SET : {
				 read();
				 switch (token.tokenType) {
					 case Tokens.DATA : {
						 read();
						 readThis(Tokens.TYPE);
						 processAlterColumnDataType(table, column);
						 return;
					 }
					 case Tokens.DEFAULT : {
						 read();
						 TableWorks tw = new TableWorks(session, table);
						 Type type = column.getDataType();
						 Expression expr = this.readDefaultClause(type);
						 tw.setColDefaultExpression(columnIndex, expr);
						 return;
					 }
					 case Tokens.NOT : {
						 read();
						 readThis(Tokens.NULL);
						 session.commit(false);
						 TableWorks tw = new TableWorks(session, table);
						 tw.setColNullability(column, false);
						 return;
					 }
					 case Tokens.NULL : {
						 read();
						 session.commit(false);
						 TableWorks tw = new TableWorks(session, table);
						 tw.setColNullability(column, true);
						 return;
					 }
					 default : rewind(position);
					 read();
					 break;
				 }
			 }
		 default : }
		 if (token.tokenType == Tokens.SET || token.tokenType == Tokens.RESTART) {
			 if (!column.isIdentity()) {
				 throw Error.error(ErrorCode.X_42535);
			 }
			 processAlterColumnSequenceOptions(column);
			 return;
		 }
		 else {
			 processAlterColumnType(table, column, true);
			 return;
		 }
	 }
	 Statement compileAlterColumn(Table table, ColumnSchema column, int columnIndex) {
		 int position = getPosition();
		 switch (token.tokenType) {
			 case Tokens.RENAME : {
				 read();
				 readThis(Tokens.TO);
				 return compileAlterColumnRename(table, column);
			 }
			 case Tokens.DROP : {
				 read();
				 if (token.tokenType == Tokens.DEFAULT) {
					 read();
					 return compileAlterColumnDropDefault(table, column, columnIndex);
				 }
				 else if (token.tokenType == Tokens.GENERATED) {
					 read();
					 return compileAlterColumnDropGenerated(table, column, columnIndex);
				 }
				 else {
					 throw unexpectedToken();
				 }
			 }
			 case Tokens.SET : {
				 read();
				 switch (token.tokenType) {
					 case Tokens.DATA : {
						 read();
						 readThis(Tokens.TYPE);
						 return compileAlterColumnDataType(table, column);
					 }
					 case Tokens.DEFAULT : {
						 read();
						 Type type = column.getDataType();
						 Expression expr = this.readDefaultClause(type);
						 return compileAlterColumnSetDefault(table, column, expr);
					 }
					 case Tokens.NOT : {
						 read();
						 readThis(Tokens.NULL);
						 return compileAlterColumnSetNullability(table, column, false);
					 }
					 case Tokens.NULL : {
						 read();
						 return compileAlterColumnSetNullability(table, column, true);
					 }
					 default : rewind(position);
					 read();
					 break;
				 }
			 }
		 default : }
		 if (token.tokenType == Tokens.SET || token.tokenType == Tokens.RESTART) {
			 if (!column.isIdentity()) {
				 throw Error.error(ErrorCode.X_42535);
			 }
			 return compileAlterColumnSequenceOptions(table, column);
		 }
		 else {
			 return compileAlterColumnType(table, column);
		 }
	 }
	 private Statement compileAlterColumnDataType(Table table, ColumnSchema column) {
		 HsqlName writeName = null;
		 Type typeObject = readTypeDefinition(false);
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 table, column, typeObject }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, null, table.getName());
	 }
	 private Statement compileAlterColumnType(Table table, ColumnSchema column) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, table.getName());
	 }
	 private Statement compileAlterColumnSequenceOptions(Table table, ColumnSchema column) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, table.getName());
	 }
	 private Statement compileAlterColumnSetNullability(Table table, ColumnSchema column, boolean b) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, table.getName());
	 }
	 private Statement compileAlterColumnSetDefault(Table table, ColumnSchema column, Expression expr) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, table.getName());
	 }
	 private Statement compileAlterColumnDropGenerated(Table table, ColumnSchema column, int columnIndex) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, table.getName());
	 }
	 private Statement compileAlterColumnDropDefault(Table table, ColumnSchema column, int columnIndex) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_TABLE, null, table.getName());
	 }
	 Statement compileAlterSequence() {
		 read();
		 HsqlName schema = session.getSchemaHsqlName(token.namePrefix);
		 NumberSequence sequence = database.schemaManager.getSequence(token.tokenString, schema.name, true);
		 read();
		 if (token.tokenType == Tokens.RENAME) {
			 read();
			 readThis(Tokens.TO);
			 return compileRenameObject(sequence.getName(), SchemaObject.SEQUENCE);
		 }
		 NumberSequence copy = sequence.duplicate();
		 readSequenceOptions(copy, false, true);
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 sequence, copy }
		;
		 return new StatementSchema(sql, StatementTypes.ALTER_SEQUENCE, args);
	 }
	 void processAlterColumnSequenceOptions(ColumnSchema column) {
		 OrderedIntHashSet set = new OrderedIntHashSet();
		 NumberSequence sequence = column.getIdentitySequence().duplicate();
		 while (true) {
			 boolean end = false;
			 switch (token.tokenType) {
				 case Tokens.RESTART : {
					 if (!set.add(token.tokenType)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.WITH);
					 long value = readBigint();
					 sequence.setStartValue(value);
					 break;
				 }
				 case Tokens.SET : read();
				 switch (token.tokenType) {
					 case Tokens.INCREMENT : {
						 if (!set.add(token.tokenType)) {
							 throw unexpectedToken();
						 }
						 read();
						 readThis(Tokens.BY);
						 long value = readBigint();
						 sequence.setIncrement(value);
						 break;
					 }
					 case Tokens.NO : read();
					 if (token.tokenType == Tokens.MAXVALUE) {
						 sequence.setDefaultMaxValue();
					 }
					 else if (token.tokenType == Tokens.MINVALUE) {
						 sequence.setDefaultMinValue();
					 }
					 else if (token.tokenType == Tokens.CYCLE) {
						 sequence.setCycle(false);
					 }
					 else {
						 throw unexpectedToken();
					 }
					 if (!set.add(token.tokenType)) {
						 throw unexpectedToken();
					 }
					 read();
					 break;
					 case Tokens.MAXVALUE : {
						 if (!set.add(token.tokenType)) {
							 throw unexpectedToken();
						 }
						 read();
						 long value = readBigint();
						 sequence.setMaxValueNoCheck(value);
						 break;
					 }
					 case Tokens.MINVALUE : {
						 if (!set.add(token.tokenType)) {
							 throw unexpectedToken();
						 }
						 read();
						 long value = readBigint();
						 sequence.setMinValueNoCheck(value);
						 break;
					 }
					 case Tokens.CYCLE : if (!set.add(token.tokenType)) {
						 throw unexpectedToken();
					 }
					 read();
					 sequence.setCycle(true);
					 break;
					 default : throw super.unexpectedToken();
				 }
				 break;
				 default : end = true;
				 break;
			 }
			 if (end) {
				 break;
			 }
		 }
		 sequence.checkValues();
		 column.getIdentitySequence().reset(sequence);
	 }
	 private void processAlterColumnDataType(Table table, ColumnSchema oldCol) {
		 processAlterColumnType(table, oldCol, false);
	 }
	 private void processAlterColumnType(Table table, ColumnSchema oldCol, boolean fullDefinition) {
		 ColumnSchema newCol;
		 if (oldCol.isGenerated()) {
			 throw Error.error(ErrorCode.X_42561);
		 }
		 if (fullDefinition) {
			 HsqlArrayList list = new HsqlArrayList();
			 Constraint c = table.getPrimaryConstraint();
			 if (c == null) {
				 c = new Constraint(null, null, SchemaObject.ConstraintTypes.TEMP);
			 }
			 list.add(c);
			 newCol = readColumnDefinitionOrNull(table, oldCol.getName(), list);
			 if (newCol == null) {
				 throw Error.error(ErrorCode.X_42000);
			 }
			 if (oldCol.isIdentity() && newCol.isIdentity()) {
				 throw Error.error(ErrorCode.X_42525);
			 }
			 if (list.size() > 1) {
				 throw Error.error(ErrorCode.X_42524);
			 }
		 }
		 else {
			 Type type = readTypeDefinition(true);
			 if (oldCol.isIdentity()) {
				 if (!type.isIntegralType()) {
					 throw Error.error(ErrorCode.X_42561);
				 }
			 }
			 newCol = oldCol.duplicate();
			 newCol.setType(type);
		 }
		 TableWorks tw = new TableWorks(session, table);
		 tw.retypeColumn(oldCol, newCol);
	 }
	 private void processAlterColumnRename(Table table, ColumnSchema column) {
		 checkIsSimpleName();
		 if (table.findColumn(token.tokenString) > -1) {
			 throw Error.error(ErrorCode.X_42504, token.tokenString);
		 }
		 database.schemaManager.checkColumnIsReferenced(table.getName(), column.getName());
		 session.commit(false);
		 table.renameColumn(column, token.tokenString, isDelimitedIdentifier());
		 read();
	 }
	 private Statement compileAlterColumnRename(Table table, ColumnSchema column) {
		 checkIsSimpleName();
		 HsqlName name = readNewSchemaObjectName(SchemaObject.COLUMN, true);
		 if (table.findColumn(name.name) > -1) {
			 throw Error.error(ErrorCode.X_42504, name.name);
		 }
		 database.schemaManager.checkColumnIsReferenced(table.getName(), column.getName());
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 column.getName(), name }
		;
		 return new StatementSchema(sql, StatementTypes.RENAME_OBJECT, args);
	 }
	 Statement compileAlterSchemaRename() {
		 HsqlName name = readSchemaName();
		 checkSchemaUpdateAuthorisation(name);
		 readThis(Tokens.RENAME);
		 readThis(Tokens.TO);
		 HsqlName newName = readNewSchemaName();
		 String sql = getLastPart();
		 Object[] args = new Object[] {
		 name, newName }
		;
		 return new StatementSchema(sql, StatementTypes.RENAME_OBJECT, args);
	 }
	 Statement compileAlterUser() {
		 read();
		 String password;
		 User userObject;
		 HsqlName userName = readNewUserIdentifier();
		 userObject = database.getUserManager().get(userName.name);
		 if (userName.name.equals(Tokens.T_PUBLIC)) {
			 throw Error.error(ErrorCode.X_42503);
		 }
		 readThis(Tokens.SET);
		 if (token.tokenType == Tokens.PASSWORD) {
			 read();
			 password = readPassword();
			 Object[] args = new Object[] {
			 userObject, password }
			;
			 return new StatementCommand(StatementTypes.SET_USER_PASSWORD, args);
		 }
		 else if (token.tokenType == Tokens.INITIAL) {
			 read();
			 readThis(Tokens.SCHEMA);
			 HsqlName schemaName;
			 if (token.tokenType == Tokens.DEFAULT) {
				 schemaName = null;
			 }
			 else {
				 schemaName = database.schemaManager.getSchemaHsqlName( token.tokenString);
			 }
			 read();
			 Object[] args = new Object[] {
			 userObject, schemaName }
			;
			 return new StatementCommand(StatementTypes.SET_USER_INITIAL_SCHEMA, args);
		 }
		 else {
			 throw unexpectedToken();
		 }
	 }
	 void processAlterDomain() {
		 HsqlName schema = session.getSchemaHsqlName(token.namePrefix);
		 checkSchemaUpdateAuthorisation(schema);
		 Type domain = database.schemaManager.getDomain(token.tokenString, schema.name, true);
		 read();
		 switch (token.tokenType) {
			 case Tokens.RENAME : {
				 read();
				 readThis(Tokens.TO);
				 HsqlName newName = readNewSchemaObjectName(SchemaObject.DOMAIN, true);
				 newName.setSchemaIfNull(schema);
				 if (domain.getSchemaName() != newName.schema) {
					 throw Error.error(ErrorCode.X_42505, newName.schema.name);
				 }
				 checkSchemaUpdateAuthorisation(schema);
				 database.schemaManager.renameSchemaObject(domain.getName(), newName);
				 return;
			 }
			 case Tokens.DROP : {
				 read();
				 if (token.tokenType == Tokens.DEFAULT) {
					 read();
					 domain.userTypeModifier.removeDefaultClause();
					 return;
				 }
				 else if (token.tokenType == Tokens.CONSTRAINT) {
					 read();
					 checkIsSchemaObjectName();
					 HsqlName name = database.schemaManager.getSchemaObjectName( domain.getSchemaName(), token.tokenString, SchemaObject.CONSTRAINT, true);
					 read();
					 database.schemaManager.removeSchemaObject(name);
					 return;
				 }
				 else {
					 throw unexpectedToken();
				 }
			 }
			 case Tokens.SET : {
				 read();
				 readThis(Tokens.DEFAULT);
				 Expression e = readDefaultClause(domain);
				 domain.userTypeModifier.setDefaultClause(e);
				 return;
			 }
			 case Tokens.ADD : {
				 read();
				 if (token.tokenType == Tokens.CONSTRAINT || token.tokenType == Tokens.CHECK) {
					 HsqlArrayList tempConstraints = new HsqlArrayList();
					 readConstraint(domain, tempConstraints);
					 Constraint c = (Constraint) tempConstraints.get(0);
					 domain.userTypeModifier.addConstraint(c);
					 database.schemaManager.addSchemaObject(c);
					 return;
				 }
			 }
		 }
		 throw unexpectedToken();
	 }
	 Statement compileAlterDomain() {
		 read();
		 HsqlName schema = session.getSchemaHsqlName(token.namePrefix);
		 Type domain = database.schemaManager.getDomain(token.tokenString, schema.name, true);
		 read();
		 switch (token.tokenType) {
			 case Tokens.RENAME : {
				 read();
				 readThis(Tokens.TO);
				 return compileRenameObject(domain.getName(), SchemaObject.DOMAIN);
			 }
			 case Tokens.DROP : {
				 read();
				 if (token.tokenType == Tokens.DEFAULT) {
					 read();
					 return compileAlterDomainDropDefault(domain);
				 }
				 else if (token.tokenType == Tokens.CONSTRAINT) {
					 read();
					 checkIsSchemaObjectName();
					 HsqlName name = database.schemaManager.getSchemaObjectName( domain.getSchemaName(), token.tokenString, SchemaObject.CONSTRAINT, true);
					 read();
					 return compileAlterDomainDropConstraint(domain, name);
				 }
				 else {
					 throw unexpectedToken();
				 }
			 }
			 case Tokens.SET : {
				 read();
				 readThis(Tokens.DEFAULT);
				 Expression e = readDefaultClause(domain);
				 return compileAlterDomainSetDefault(domain, e);
			 }
			 case Tokens.ADD : {
				 read();
				 if (token.tokenType == Tokens.CONSTRAINT || token.tokenType == Tokens.CHECK) {
					 HsqlArrayList tempConstraints = new HsqlArrayList();
					 readConstraint(domain, tempConstraints);
					 Constraint c = (Constraint) tempConstraints.get(0);
					 return compileAlterDomainAddConstraint(domain, c);
				 }
			 }
		 }
		 throw unexpectedToken();
	 }
	 private Statement compileAlterDomainAddConstraint(Type domain, Constraint c) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_DOMAIN, null, null);
	 }
	 private Statement compileAlterDomainSetDefault(Type domain, Expression e) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_DOMAIN, null, null);
	 }
	 private Statement compileAlterDomainDropConstraint(Type domain, HsqlName name) {
		 String sql = super.getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_DOMAIN, null, null);
	 }
	 private Statement compileAlterDomainDropDefault(Type domain) {
		 String sql = getStatement(getParsePosition(), startStatementTokens);
		 return new StatementSchema(sql, StatementTypes.ALTER_DOMAIN, null, null);
	 }
	 private boolean isGrantToken() {
		 switch (token.tokenType) {
			 case Tokens.ALL : case Tokens.INSERT : case Tokens.UPDATE : case Tokens.SELECT : case Tokens.DELETE : case Tokens.USAGE : case Tokens.EXECUTE : case Tokens.REFERENCES : return true;
			 default : return false;
		 }
	 }
	 StatementSchema compileGrantOrRevoke() {
		 boolean grant = token.tokenType == Tokens.GRANT;
		 read();
		 if (isGrantToken() || (!grant && (token.tokenType == Tokens.GRANT || token.tokenType == Tokens.HIERARCHY))) {
			 return compileRightGrantOrRevoke(grant);
		 }
		 else {
			 return compileRoleGrantOrRevoke(grant);
		 }
	 }
	 private StatementSchema compileRightGrantOrRevoke(boolean grant) {
		 OrderedHashSet granteeList = new OrderedHashSet();
		 Grantee grantor = null;
		 Right right = null;
		 HsqlName objectName = null;
		 boolean isTable = false;
		 boolean isUsage = false;
		 boolean isExec = false;
		 boolean isAll = false;
		 boolean isGrantOption = false;
		 boolean cascade = false;
		 if (!grant) {
			 if (token.tokenType == Tokens.GRANT) {
				 read();
				 readThis(Tokens.OPTION);
				 readThis(Tokens.FOR);
				 isGrantOption = true;
			 }
			 else if (token.tokenType == Tokens.HIERARCHY) {
				 throw unsupportedFeature();
			 }
		 }
		 if (token.tokenType == Tokens.ALL) {
			 read();
			 if (token.tokenType == Tokens.PRIVILEGES) {
				 read();
			 }
			 right = Right.fullRights;
			 isAll = true;
		 }
		 else {
			 right = new Right();
			 boolean loop = true;
			 while (loop) {
				 checkIsNotQuoted();
				 int rightType = GranteeManager.getCheckSingleRight(token.tokenString);
				 int grantType = token.tokenType;
				 OrderedHashSet columnSet = null;
				 read();
				 switch (grantType) {
					 case Tokens.REFERENCES : case Tokens.SELECT : case Tokens.INSERT : case Tokens.UPDATE : if (token.tokenType == Tokens.OPENBRACKET) {
						 columnSet = readColumnNames(false);
					 }
					 case Tokens.DELETE : case Tokens.TRIGGER : if (right == null) {
						 right = new Right();
					 }
					 right.set(rightType, columnSet);
					 isTable = true;
					 break;
					 case Tokens.USAGE : if (isTable) {
						 throw unexpectedToken();
					 }
					 right = Right.fullRights;
					 isUsage = true;
					 loop = false;
					 continue;
					 case Tokens.EXECUTE : if (isTable) {
						 throw unexpectedToken();
					 }
					 right = Right.fullRights;
					 isExec = true;
					 loop = false;
					 continue;
				 }
				 if (token.tokenType == Tokens.COMMA) {
					 read();
					 continue;
				 }
				 break;
			 }
		 }
		 readThis(Tokens.ON);
		 int objectType = 0;
		 switch (token.tokenType) {
			 case Tokens.CLASS : if (!isExec && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 if (!isSimpleName() || !isDelimitedIdentifier()) {
				 throw Error.error(ErrorCode.X_42569);
			 }
			 objectType = SchemaObject.FUNCTION;
			 objectName = readNewSchemaObjectName(SchemaObject.FUNCTION, false);
			 break;
			 case Tokens.SPECIFIC : {
				 if (!isExec && !isAll) {
					 throw unexpectedToken();
				 }
				 read();
				 switch (token.tokenType) {
					 case Tokens.ROUTINE : case Tokens.PROCEDURE : case Tokens.FUNCTION : read();
					 break;
					 default : throw unexpectedToken();
				 }
				 objectType = SchemaObject.SPECIFIC_ROUTINE;
				 break;
			 }
			 case Tokens.FUNCTION : if (!isExec && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 objectType = SchemaObject.FUNCTION;
			 break;
			 case Tokens.PROCEDURE : if (!isExec && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 objectType = SchemaObject.PROCEDURE;
			 break;
			 case Tokens.ROUTINE : if (!isExec && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 objectType = SchemaObject.ROUTINE;
			 break;
			 case Tokens.TYPE : if (!isUsage && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 objectType = SchemaObject.TYPE;
			 break;
			 case Tokens.DOMAIN : if (!isUsage && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 objectType = SchemaObject.DOMAIN;
			 break;
			 case Tokens.SEQUENCE : if (!isUsage && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 objectType = SchemaObject.SEQUENCE;
			 break;
			 case Tokens.CHARACTER : if (!isUsage && !isAll) {
				 throw unexpectedToken();
			 }
			 read();
			 readThis(Tokens.SET);
			 objectType = SchemaObject.CHARSET;
			 break;
			 case Tokens.TABLE : default : if (!isTable && !isAll) {
				 throw unexpectedToken();
			 }
			 readIfThis(Tokens.TABLE);
			 objectType = SchemaObject.TABLE;
		 }
		 objectName = readNewSchemaObjectName(objectType, false);
		 if (grant) {
			 readThis(Tokens.TO);
		 }
		 else {
			 readThis(Tokens.FROM);
		 }
		 while (true) {
			 checkIsSimpleName();
			 granteeList.add(token.tokenString);
			 read();
			 if (token.tokenType == Tokens.COMMA) {
				 read();
			 }
			 else {
				 break;
			 }
		 }
		 if (grant) {
			 if (token.tokenType == Tokens.WITH) {
				 read();
				 readThis(Tokens.GRANT);
				 readThis(Tokens.OPTION);
				 isGrantOption = true;
			 }
			 if (token.tokenType == Tokens.GRANTED) {
				 read();
				 readThis(Tokens.BY);
				 if (token.tokenType == Tokens.CURRENT_USER) {
					 read();
				 }
				 else {
					 readThis(Tokens.CURRENT_ROLE);
					 if (session.getRole() == null) {
						 throw Error.error(ErrorCode.X_0P000);
					 }
					 grantor = session.getRole();
				 }
			 }
		 }
		 else {
			 if (token.tokenType == Tokens.CASCADE) {
				 cascade = true;
				 read();
			 }
			 else {
				 readThis(Tokens.RESTRICT);
			 }
		 }
		 int typee = grant ? StatementTypes.GRANT : StatementTypes.REVOKE;
		 Object[] args = new Object[] {
		 granteeList, objectName, right, grantor, Boolean.valueOf(cascade), Boolean.valueOf(isGrantOption) }
		;
		 String sql = getLastPart();
		 StatementSchema cs = new StatementSchema(sql, typee, args);
		 return cs;
	 }
	 private StatementSchema compileRoleGrantOrRevoke(boolean grant) {
		 Grantee grantor = session.getGrantee();
		 OrderedHashSet roleList = new OrderedHashSet();
		 OrderedHashSet granteeList = new OrderedHashSet();
		 boolean cascade = false;
		 if (!grant && token.tokenType == Tokens.ADMIN) {
			 throw unsupportedFeature();
		 }
		 while (true) {
			 checkIsSimpleName();
			 roleList.add(token.tokenString);
			 read();
			 if (token.tokenType == Tokens.COMMA) {
				 read();
				 continue;
			 }
			 break;
		 }
		 if (grant) {
			 readThis(Tokens.TO);
		 }
		 else {
			 readThis(Tokens.FROM);
		 }
		 while (true) {
			 checkIsSimpleName();
			 granteeList.add(token.tokenString);
			 read();
			 if (token.tokenType == Tokens.COMMA) {
				 read();
			 }
			 else {
				 break;
			 }
		 }
		 if (grant) {
			 if (token.tokenType == Tokens.WITH) {
				 throw unsupportedFeature();
			 }
		 }
		 if (token.tokenType == Tokens.GRANTED) {
			 read();
			 readThis(Tokens.BY);
			 if (token.tokenType == Tokens.CURRENT_USER) {
				 read();
			 }
			 else {
				 readThis(Tokens.CURRENT_ROLE);
				 if (session.getRole() == null) {
					 throw Error.error(ErrorCode.X_0P000);
				 }
				 grantor = session.getRole();
			 }
		 }
		 if (!grant) {
			 if (token.tokenType == Tokens.CASCADE) {
				 cascade = true;
				 read();
			 }
			 else {
				 readThis(Tokens.RESTRICT);
			 }
		 }
		 int type = grant ? StatementTypes.GRANT_ROLE : StatementTypes.REVOKE_ROLE;
		 Object[] args = new Object[] {
		 granteeList, roleList, grantor, Boolean.valueOf(cascade) }
		;
		 String sql = getLastPart();
		 StatementSchema cs = new StatementSchema(sql, type, args);
		 return cs;
	 }
	 void checkSchemaUpdateAuthorisation(HsqlName schema) {
		 if (session.isProcessingLog) {
			 return;
		 }
		 SqlInvariants.checkSchemaNameNotSystem(schema.name);
		 if (isSchemaDefinition) {
			 if (schema != session.getCurrentSchemaHsqlName()) {
				 throw Error.error(ErrorCode.X_42505);
			 }
		 }
		 else {
			 session.getGrantee().checkSchemaUpdateOrGrantRights(schema.name);
		 }
		 session.checkDDLWrite();
	 }
	 void checkDatabaseUpdateAuthorisation() {
		 session.checkAdmin();
		 session.checkDDLWrite();
	 }
	 StatementSchema compileComment() {
		 HsqlName name;
		 int type;
		 readThis(Tokens.COMMENT);
		 readThis(Tokens.ON);
		 switch (token.tokenType) {
			 case Tokens.ROUTINE : case Tokens.TABLE : {
				 type = token.tokenType == Tokens.ROUTINE ? SchemaObject.ROUTINE : SchemaObject.TABLE;
				 read();
				 checkIsSchemaObjectName();
				 name = database.nameManager.newHsqlName(token.tokenString, token.isDelimitedIdentifier, type);
				 if (token.namePrefix == null) {
					 name.schema = session.getCurrentSchemaHsqlName();
				 }
				 else {
					 name.schema = database.nameManager.newHsqlName( token.namePrefix, token.isDelimitedPrefix, SchemaObject.SCHEMA);
				 }
				 read();
				 break;
			 }
			 case Tokens.COLUMN : {
				 read();
				 checkIsSchemaObjectName();
				 name = database.nameManager.newHsqlName(token.tokenString, token.isDelimitedIdentifier, SchemaObject.COLUMN);
				 if (token.namePrefix == null) {
					 throw Error.error(ErrorCode.X_42501);
				 }
				 name.parent = database.nameManager.newHsqlName(token.namePrefix, token.isDelimitedPrefix, SchemaObject.TABLE);
				 if (token.namePrePrefix == null) {
					 name.parent.schema = session.getCurrentSchemaHsqlName();
				 }
				 else {
					 name.parent.schema = database.nameManager.newHsqlName( token.namePrePrefix, token.isDelimitedPrePrefix, SchemaObject.TABLE);
				 }
				 read();
				 break;
			 }
			 default : throw unexpectedToken();
		 }
		 readThis(Tokens.IS);
		 String comment = readQuotedString();
		 Object[] arguments = new Object[] {
		 name, comment }
		;
		 return new StatementSchema(null, StatementTypes.COMMENT, arguments);
	 }
}",1,0,0,0
"private void setOptionalAttribute(BeanDefinitionBuilder builder,Map<String, Object> providedProperties,String propertyPrefix,String attributeValue,String attributeName) {
	String propertyKey;
	if (""username"".equals(attributeName)) {
		String userKey = (propertyPrefix != null ?propertyPrefix + ""user"" :""user"");
		if (providedProperties.containsKey(userKey)) {
			propertyKey = userKey;
		}
		else {
			propertyKey = (propertyPrefix != null ?propertyPrefix + attributeName :attributeName);
		}
	}
	else {
		propertyKey = (propertyPrefix != null ?propertyPrefix + attributeToPropertyMap.get(attributeName) :attributeToPropertyMap.get(attributeName));
	}
	if (StringUtils.hasText(attributeValue)) {
		if (logger.isDebugEnabled()) {
			if (""password"".equals(attributeName)) {
				logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +"" with attribute value ******"");
			}
			else {
				logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +"" with attribute value "" + attributeValue);
			}
		}
		builder.addPropertyValue(attributeToPropertyMap.get(attributeName), attributeValue);
	}
	else if (providedProperties.containsKey(propertyKey)) {
		if (logger.isDebugEnabled()) {
			logger.debug(""Registering optional attribute "" + attributeToPropertyMap.get(attributeName) +"" with property value "" +(""password"".equals(attributeName) ? ""******"" : providedProperties.get(propertyKey)));
		}
		builder.addPropertyValue(attributeToPropertyMap.get(attributeName), providedProperties.get(propertyKey));
	}
	removeProvidedProperty(providedProperties, propertyKey);
}",0,0,1,0
"public class CovarianceMatricesAggregator implements Serializable {
	 private static final long serialVersionUID = 4163253784526780812L;
	 private final Vector mean;
	 private Matrix weightedSum;
	 private int rowCount;
	 CovarianceMatricesAggregator(Vector mean) {
		 this.mean = mean;
	 }
	 CovarianceMatricesAggregator(Vector mean, Matrix weightedSum, int rowCount) {
		 this.mean = mean;
		 this.weightedSum = weightedSum;
		 this.rowCount = rowCount;
	 }
	 static List<Matrix> computeCovariances(Dataset<EmptyContext, GmmPartitionData> dataset, Vector clusterProbs, Vector[] means) {
		 List<CovarianceMatricesAggregator> aggregators = dataset.compute( data -> map(data, means), CovarianceMatricesAggregator::reduce );
		 if (aggregators == null) return Collections.emptyList();
		 List<Matrix> res = new ArrayList<>();
		 for (int i = 0;
		 i < aggregators.size();
		 i++) res.add(aggregators.get(i).covariance(clusterProbs.get(i)));
		 return res;
	 }
	 void add(Vector x, double pcxi) {
		 Matrix deltaCol = x.minus(mean).toMatrix(false);
		 Matrix weightedCovComponent = deltaCol.times(deltaCol.transpose()).times(pcxi);
		 if (weightedSum == null) weightedSum = weightedCovComponent;
		 else weightedSum = weightedSum.plus(weightedCovComponent);
		 rowCount += 1;
	 }
	 CovarianceMatricesAggregator plus(CovarianceMatricesAggregator other) {
		 A.ensure(this.mean.equals(other.mean), ""this.mean == other.mean"");
		 return new CovarianceMatricesAggregator( mean, this.weightedSum.plus(other.weightedSum), this.rowCount + other.rowCount );
	 }
	 static List<CovarianceMatricesAggregator> map(GmmPartitionData data, Vector[] means) {
		 int countOfComponents = means.length;
		 List<CovarianceMatricesAggregator> aggregators = new ArrayList<>();
		 for (int i = 0;
		 i < countOfComponents;
		 i++) aggregators.add(new CovarianceMatricesAggregator(means[i]));
		 for (int i = 0;
		 i < data.size();
		 i++) {
			 for (int c = 0;
			 c < countOfComponents;
			 c++) aggregators.get(c).add(data.getX(i), data.pcxi(c, i));
		 }
		 return aggregators;
	 }
	 private Matrix covariance(double clusterProb) {
		 return weightedSum.divide(rowCount * clusterProb);
	 }
	 static List<CovarianceMatricesAggregator> reduce(List<CovarianceMatricesAggregator> l, List<CovarianceMatricesAggregator> r) {
		 A.ensure(l != null || r != null, ""Both partitions cannot equal to null"");
		 if (l == null || l.isEmpty()) return r;
		 if (r == null || r.isEmpty()) return l;
		 A.ensure(l.size() == r.size(), ""l.size() == r.size()"");
		 List<CovarianceMatricesAggregator> res = new ArrayList<>();
		 for (int i = 0;
		 i < l.size();
		 i++) res.add(l.get(i).plus(r.get(i)));
		 return res;
	 }
	 Vector mean() {
		 return mean.copy();
	 }
	 Matrix weightedSum() {
		 return weightedSum.copy();
	 }
	 public int rowCount() {
		 return rowCount;
	 }
}",1,1,0,0
"public class StatusHttpServer {
	 private static final boolean isWindows = System.getProperty(""os.name"").startsWith(""Windows"");
	 private org.mortbay.jetty.Server webServer;
	 private SocketListener listener;
	 private boolean findPort;
	 private WebApplicationContext webAppContext;
	 public StatusHttpServer(String name, String bindAddress, int port, boolean findPort) throws IOException {
		 webServer = new org.mortbay.jetty.Server();
		 this.findPort = findPort;
		 listener = new SocketListener();
		 listener.setPort(port);
		 listener.setHost(bindAddress);
		 webServer.addListener(listener);
		 HttpContext logContext = new HttpContext();
		 logContext.setContextPath(""/logs public void setAttribute(String name, Object value) {
			 webAppContext.setAttribute(name,value);
		 }
		 public <T extends HttpServlet> void addServlet(String name, String pathSpec, Class<T> servletClass) {
			 WebApplicationContext context = webAppContext;
			 try {
				 if (name == null) {
					 context.addServlet(pathSpec, servletClass.getName());
				 }
				 else {
					 context.addServlet(name, pathSpec, servletClass.getName());
				 }
			 }
			 catch (ClassNotFoundException ex) {
				 throw makeRuntimeException(""Problem instantiating class"", ex);
			 }
			 catch (InstantiationException ex) {
				 throw makeRuntimeException(""Problem instantiating class"", ex);
			 }
			 catch (IllegalAccessException ex) {
				 throw makeRuntimeException(""Problem instantiating class"", ex);
			 }
		 }
		 private static RuntimeException makeRuntimeException(String msg, Throwable cause) {
			 RuntimeException result = new RuntimeException(msg);
			 if (cause != null) {
				 result.initCause(cause);
			 }
			 return result;
		 }
		 public Object getAttribute(String name) {
			 return webAppContext.getAttribute(name);
		 }
		 private static String getWebAppsPath() throws IOException {
			 URL url = StatusHttpServer.class.getClassLoader().getResource(""webapps"");
			 String path = url.getPath();
			 if (isWindows && path.startsWith(""/"")) {
				 path = path.substring(1);
				 try {
					 path = URLDecoder.decode(path, ""UTF-8"");
				 }
				 catch (UnsupportedEncodingException e) {
				 }
			 }
			 return new File(path).getCanonicalPath();
		 }
		 public int getPort() {
			 return listener.getPort();
		 }
		 public void setThreads(int min, int max) {
			 listener.setMinThreads(min);
			 listener.setMaxThreads(max);
		 }
		 public void start() throws IOException {
			 try {
				 while (true) {
					 try {
						 webServer.start();
						 break;
					 }
					 catch (org.mortbay.util.MultiException ex) {
						 boolean needNewPort = false;
						 for(int i=0;
						 i < ex.size();
						 ++i) {
							 Exception sub = ex.getException(i);
							 if (sub instanceof java.net.BindException) {
								 needNewPort = true;
								 break;
							 }
						 }
						 if (!findPort || !needNewPort) {
							 throw ex;
						 }
						 else {
							 listener.setPort(listener.getPort() + 1);
						 }
					 }
				 }
			 }
			 catch (IOException ie) {
				 throw ie;
			 }
			 catch (Exception e) {
				 IOException ie = new IOException(""Problem starting http server"");
				 ie.initCause(e);
				 throw ie;
			 }
		 }
		 public void stop() throws InterruptedException {
			 webServer.stop();
		 }
	}",0,0,0,0
"String genJavaHashCode(String fname) {
	 return "" ret = (int)""+fname+"";
	\n"";
 }",0,0,0,0
"public Point getMainViewOutPoint(NodeView view, NodeView targetView, Point destinationPoint);",0,0,0,0
"DatanodeDescriptor chooseTarget(Collection<DatanodeDescriptor> forbidden1, Collection<DatanodeDescriptor> forbidden2, UTF8 clientMachine, long blockSize) {
	 int totalMachines = heartbeats.size();
	 if (totalMachines == 0) {
		 LOG.warn(""While choosing target, totalMachines is "" + totalMachines);
		 return null;
	 }
	 Collection<String> forbiddenMachines = new TreeSet<String>();
	 if (forbidden1 != null) {
		 for (Iterator<DatanodeDescriptor> it = forbidden1.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor cur = it.next();
			 forbiddenMachines.add(cur.getHost());
		 }
	 }
	 if (forbidden2 != null) {
		 for (Iterator<DatanodeDescriptor> it = forbidden2.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor cur = it.next();
			 forbiddenMachines.add(cur.getHost());
		 }
	 }
	 double avgLoad = 0.0;
	 List<DatanodeDescriptor> targetList = new ArrayList<DatanodeDescriptor>();
	 for (Iterator<DatanodeDescriptor> it = heartbeats.iterator();
	 it.hasNext();
	 ) {
		 DatanodeDescriptor node = it.next();
		 if (! forbiddenMachines.contains(node.getHost())) {
			 targetList.add(node);
			 avgLoad += node.getXceiverCount();
		 }
	 }
	 if (targetList.size() > 0) {
		 avgLoad = avgLoad/targetList.size();
	 }
	 Collections.shuffle(targetList);
	 if (targetList.size() > 0) {
		 if (clientMachine != null && clientMachine.getLength() > 0) {
			 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor node = it.next();
				 if (clientMachine.toString().equals(node.getHost())) {
					 if ((node.getRemaining() >= blockSize * MIN_BLOCKS_FOR_WRITE) && (node.getXceiverCount() <= (2.0 * avgLoad))) {
						 return node;
					 }
				 }
			 }
		 }
		 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor node = it.next();
			 if ((node.getRemaining() >= blockSize * MIN_BLOCKS_FOR_WRITE) && (node.getXceiverCount() <= (2.0 * avgLoad))) {
				 return node;
			 }
		 }
		 if (clientMachine != null && clientMachine.getLength() > 0) {
			 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor node = it.next();
				 if (clientMachine.toString().equals(node.getHost()) && node.getRemaining() >= blockSize) {
					 return node;
				 }
			 }
		 }
		 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor node = it.next();
			 if (node.getRemaining() >= blockSize) {
				 return node;
			 }
		 }
		 LOG.warn(""Could not find any nodes with sufficient capacity"");
		 return null;
	 }
	 else {
		 LOG.warn(""Zero targets found, forbidden1.size="" + ( forbidden1 != null ? forbidden1.size() : 0 ) + "" forbidden2.size()="" + ( forbidden2 != null ? forbidden2.size() : 0 ));
		 return null;
	 }
 }",0,0,1,0
"public class NTriple implements ARPErrorNumbers {
	private static StringBuffer line = new StringBuffer();
	private static ARP arp;
	private static String xmlBase = null;
	private static boolean numbers = false;
	static public void main(String args[]) {
		mainEh(args, null, null);
	}
	static StatementHandler andMeToo = null;
	 static public void mainEh(String args[], ErrorHandler eh, ARPEventHandler ap) {
		boolean doneOne = false;
		startMem = -1;
		andMeToo = ap;
		int i;
		arp = new ARP();
		ARPHandlers handlers = arp.getHandlers();
		handlers.setStatementHandler(getSH(true));
		if (ap != null) {
			handlers.setNamespaceHandler(ap);
			handlers.setExtendedHandler(ap);
		}
		if (eh != null)handlers.setErrorHandler(eh);
		for (i = 0;
		 i < args.length - 1;
		 i++) {
			if (args[i].startsWith(""-"")) {
				i += processOpts(args[i].substring(1), args[i + 1]);
			}
			 else {
				doneOne = true;
				process(args[i]);
			}
		}
		if (args.length > 0) {
			if (args[i].startsWith(""-"")) {
				if (doneOne || processOpts(args[i].substring(1), ""100"") == 1)usage();
			}
			 else {
				doneOne = true;
				process(args[i]);
			}
		}
		if (!doneOne) {
		process(System.in, ""http:}
		if ( startMem != -1) {
			rt.gc();
			System.out.println(rt.totalMemory()-rt.freeMemory()-startMem);
			rt.gc();
			System.out.println(rt.totalMemory()-rt.freeMemory()-startMem);
			rt.gc();
			System.out.println(rt.totalMemory()-rt.freeMemory()-startMem);
			rt.gc();
			System.out.println(rt.totalMemory()-rt.freeMemory()-startMem);
		}
	}
	private static StatementHandler getSH(boolean b) {
		StatementHandler rslt = b?(StatementHandler)new SH(System.out):new NoSH();
		if (andMeToo!=null) rslt = new TwoSH(rslt,andMeToo);
		return rslt;
	}
	static private void lineNumber() {
		if (numbers) {
			Locator locator = arp.getLocator();
			if (locator != null)print(""# ""+ locator.getSystemId()+ "":""+ locator.getLineNumber()+ ""(""+ locator.getColumnNumber()+ "")\n"");
		}
	}
	static void usage() {
		System.err.println(""java <class-path> ""+ NTriple.class.getName()+ "" ( [ -[xstfurR]][ -b xmlBase -[eiw] NNN[,NNN...] ] [ file ] [ url ] )... "");
		System.err.println("" All options, files and URLs can be intemingled in any order."");
		System.err.println("" They are processed from left-to-right."");
		System.err.println("" file Converts RDF/XML file into N-triples"");
		System.err.println("" url Converts RDF/XML from URL into N-triples"");
		System.err.println("" -b uri Sets XML Base to the absolute URI."");
		System.err.println("" -r Content is RDF (default, no embedding, rdf:RDF tag may be omitted)."");
		 System.err.println( "" -R RDF embedded in XML document, search for obligatory rdf:RDF start element."");
		 System.err.println("" -t No n-triple output, error checking only."");
		System.err.println("" -x Lax mode - warnings are suppressed."");
		System.err.println("" -s Strict mode - most warnings are errors."");
		System.err.println("" -n Show line and column numbers."");
		System.err.println("" -u Allow unqualified attributes (defaults to warning)."");
		System.err.println("" -f All errors are.error - report first one only."");
		System.err.println("" -b url Sets XML Base to the absolute url."");
		System.err.println("" -e NNN[,NNN...]"");
		System.err.println("" Treats numbered warning conditions as errrors."");
		System.err.println("" -w NNN[,NNN...]"");
		System.err.println("" Treats numbered error conditions as warnings."");
		System.err.println("" -i NNN[,NNN...]"");
		System.err.println("" Ignores numbered error/warning conditions."");
		System.exit(1);
	}
	static final private Runtime rt = Runtime.getRuntime();
	 static private int startMem = -1;
	static private int processOpts(String opts, String nextArg) {
		boolean usedNext = false;
		ARPOptions options = arp.getOptions();
		for (int i = 0;
		 i < opts.length();
		 i++) {
			char opt = opts.charAt(i);
			if (""beiwD"".indexOf(opt) != -1) {
				if (usedNext)usage();
				usedNext = true;
			}
			switch (opt) {
				case 'D':final int nStatements = Integer.parseInt(nextArg);
				 rt.gc();
				 rt.gc();
				 startMem = (int)(rt.totalMemory()-rt.freeMemory());
				arp.getHandlers().setStatementHandler(new StatementHandler(){
					int debugC = 0;
					 public void statement(AResource subj, AResource pred, AResource obj) {
						statement(null,null,(ALiteral)null);
					}
					 public void statement(AResource subj, AResource pred, ALiteral lit) {
						if (++debugC%100 == 0) {
							System.out.println(""T: "" + debugC);
							rt.gc();
							System.out.println(""M1: ""+ (rt.totalMemory()-rt.freeMemory()-startMem));
							 rt.gc();
							System.out.println(""M2: "" + (rt.totalMemory()-rt.freeMemory()-startMem));
						}
						if ( debugC == 1 ){
							rt.gc();
							 rt.gc();
							startMem = (int)(rt.totalMemory()-rt.freeMemory());
						}
						if (debugC == nStatements) {
							 rt.gc();
							 System.err.println(""Kill me now."");
							 try {
								 Thread.sleep(200000);
							 }
							 catch (Exception e){
							 }
						}
					}
				}
				);
				 break;
				case 'x' :options.setLaxErrorMode();
				break;
				case 's' :options.setStrictErrorMode();
				break;
				case 't' :arp.getHandlers().setStatementHandler(getSH(false));
				break;
				case 'r' :options.setEmbedding(false);
				break;
				 case 'R' : options.setEmbedding(true);
				 break;
				case 'n' :numbers = true;
				break;
				 case 'E': arp.getHandlers().setErrorHandler(new ErrorHandler(){
					 public void warning(SAXParseException exception) {
					 }
					 public void error(SAXParseException exception) {
					 }
					 public void fatalError(SAXParseException exception) {
					 }
				 }
				);
				 arp.setBadStatementHandler(new SH(System.err));
				 break;
				case 'b' :xmlBase = nextArg;
				break;
				case 'e' :setErrorMode(nextArg, EM_ERROR);
				break;
				case 'i' :setErrorMode(nextArg, EM_IGNORE);
				break;
				case 'w' :setErrorMode(nextArg, EM_WARNING);
				break;
				case 'f' :for (int j = 0;
				 j < 400;
				 j++) {
					if (options.setErrorMode(j, -1) == EM_ERROR)options.setErrorMode(j, EM_FATAL);
				}
				break;
				case 'u' :options.setErrorMode(WARN_UNQUALIFIED_ATTRIBUTE, EM_IGNORE);
				options.setErrorMode(WARN_UNQUALIFIED_RDF_ATTRIBUTE, EM_IGNORE);
				break;
				default :usage();
			}
		}
		return usedNext ? 1 : 0;
	}
	static private void setErrorMode(String numbers, int mode) {
		int n[] = new int[3];
		int j = 0;
		numbers += "","";
		for (int i = 0;
		 i < numbers.length();
		 i++) {
			char c = numbers.charAt(i);
			switch (c) {
				case '0' :case '1' :case '2' :case '3' :case '4' :case '5' :case '6' :case '7' :case '8' :case '9' :if (j == 3)usage();
				n[j++] = c - '0';
				break;
				case ' ' :case ';
				' :case ',' :if (i == 0)usage();
				switch (j) {
					case 0 :break;
					case 3 :arp.getOptions().setErrorMode(n[0] * 100 + n[1] * 10 + n[2],mode);
					j = 0;
					break;
					default :usage();
				}
				break;
				default :usage();
			}
		}
	}
	 static private void process(String surl) {
		InputStream in = null ;
		URL url;
		String baseURL;
		try {
			File ff = new File(surl);
			in = new FileInputStream(ff);
			url = ff.toURI().toURL() ;
			baseURL = url.toExternalForm();
		if (baseURL.startsWith(""file:/"")&& !baseURL.startsWith(""file:baseURL = ""file:}
	}
	 catch (Exception ignore) {
		try {
			url = new URL(surl);
			in = url.openStream();
			baseURL = url.toExternalForm();
		}
		 catch (Exception e) {
			System.err.println(""ARP: Failed to open: "" + surl);
			System.err.println("" "" + ParseException.formatMessage(ignore));
			System.err.println("" "" + ParseException.formatMessage(e));
			return;
		}
	}
	process(in, baseURL, surl);
	try {
		 in.close() ;
	 }
	 catch (IOException ex) {
	}
}
static private void process(InputStream in, String xmlBasex, String surl) {
	String xmlBasey = xmlBase == null ? xmlBasex : xmlBase;
	try {
		arp.load(in, xmlBasey);
	}
	 catch (IOException e) {
		System.err.println(""Error: "" + surl + "": "" + ParseException.formatMessage(e));
	}
	 catch (SAXParseException e) {
	}
	 catch (SAXException sax) {
		System.err.println(""Error: "" + surl + "": "" + ParseException.formatMessage(sax));
	}
}
private static class TwoSH implements StatementHandler {
	final StatementHandler a, b;
	 public void statement(AResource subj, AResource pred, AResource obj) {
		a.statement(subj, pred, obj);
		b.statement(subj, pred, obj);
	}
	 public void statement(AResource subj, AResource pred, ALiteral lit) {
		a.statement(subj, pred, lit);
		b.statement(subj, pred, lit);
	}
	TwoSH(StatementHandler A, StatementHandler B) {
		a = A;
		b = B;
	}
}
private static class NoSH implements StatementHandler {
	 public void statement(AResource subj, AResource pred, AResource obj) {
	}
	 public void statement(AResource subj, AResource pred, ALiteral lit) {
	 }
}
private static class SH implements StatementHandler {
	 PrintStream out;
	 SH(PrintStream out){
		 this.out = out;
	 }
	 public void statement(AResource subj, AResource pred, AResource obj) {
		lineNumber();
		resource(subj);
		resource(pred);
		resource(obj);
		line.append('.');
		out.println(line);
		line.setLength(0);
	}
	 public void statement(AResource subj, AResource pred, ALiteral lit) {
		lineNumber();
		resource(subj);
		resource(pred);
		literal(lit);
		line.append('.');
		out.println(line);
		line.setLength(0);
	}
}
static private void print(String s) {
	line.append(s);
}
static private void resource(AResource r) {
	if (r.isAnonymous()) {
		print(""_:j"");
		print(escapeNTriple(r.getAnonymousID()));
		print("" "");
	}
	 else {
		print(""<"");
		escapeURI(r.getURI());
		print(""> "");
	}
}
static private Pattern ntripleBnode=Pattern.compile(""[a-zA-Y0-9]*"");
public static String escapeNTriple(String anonymousID) {
	Matcher matcher = ntripleBnode.matcher(anonymousID);
	if (matcher.matches())return anonymousID;
	matcher.reset();
	StringBuilder rslt = new StringBuilder();
	int lastNotMatched = 0;
	while (matcher.find()) {
		String unmatched = anonymousID.substring(lastNotMatched, matcher.start());
		rslt.append(escapeUTF8(unmatched));
		lastNotMatched = matcher.end();
		rslt.append(matcher.group());
	}
	rslt.append(escapeUTF8(anonymousID.substring(lastNotMatched)));
	return rslt.toString();
}
private static StringBuffer escapeUTF8(String str) {
	StringBuffer rslt = new StringBuffer();
	try {
		for (byte b : str.getBytes(""utf-8"")) {
			rslt.append(""Z"");
			if ((0xff&b)<16) {
				rslt.append(""0"");
			}
			rslt.append(Integer.toHexString(0xff&b));
		}
	}
	 catch (UnsupportedEncodingException e) {
		throw new Error(e);
	}
	return rslt;
}
static private void escape(String s) {
	int lg = s.length();
	for (int i = 0;
	 i < lg;
	 i++) {
		char ch = s.charAt(i);
		switch (ch) {
			case '\\' :print(""\\\\"");
			break;
			case '""' :print(""\\\"""");
			break;
			case '\n' :print(""\\n"");
			break;
			case '\r' :print(""\\r"");
			break;
			case '\t' :print(""\\t"");
			break;
			default :if (ch >= 32 && ch <= 126)line.append(ch);
			else {
				print(""\\u"");
				String hexstr = Integer.toHexString(ch).toUpperCase(Locale.ENGLISH);
				int pad = 4 - hexstr.length();
				for (;
				 pad > 0;
				 pad--)print(""0"");
				print(hexstr);
			}
		}
	}
}
static private boolean okURIChars[] = new boolean[128];
static {
	for (int i = 32;
	 i < 127;
	 i++)okURIChars[i] = true;
	okURIChars['<'] = false;
	okURIChars['>'] = false;
	okURIChars['\\'] = false;
}
static private void escapeURI(String s) {
	int lg = s.length();
	for (int i = 0;
	 i < lg;
	 i++) {
		char ch = s.charAt(i);
		if (ch < okURIChars.length && okURIChars[ch]) {
			line.append(ch);
		}
		 else {
			print(""\\u"");
			String hexstr = Integer.toHexString(ch).toUpperCase();
			int pad = 4 - hexstr.length();
			for (;
			 pad > 0;
			 pad--)print(""0"");
			print(hexstr);
		}
	}
}
static private void literal(ALiteral l) {
	line.append('""');
	escape(l.toString());
	line.append('""');
	String lang = l.getLang();
	if (lang != null && !lang.equals("""")) {
		line.append('@');
		print(lang);
	}
	String dt = l.getDatatypeURI();
	if (dt != null && !dt.equals("""")) {
		print(""^^<"");
		escapeURI(dt);
		line.append('>');
	}
	line.append(' ');
}
}",1,0,0,0
"public class CachePolicyConfOther {
	 protected List<Object> content;
	 public List<Object> getContent() {
		 if (content == null) {
			 content = new ArrayList<Object>();
		 }
		 return this.content;
	 }
}",0,1,0,0
"public static final class FloatFunctionChain<T1, T2> implements FloatFunction<T1> {
	 private static final long serialVersionUID = 1L;
	 private final Function<T1, T2> function1;
	 private final FloatFunction<? super T2> function2;
	 private FloatFunctionChain(Function<T1, T2> function1, FloatFunction<? super T2> function2) {
		 this.function1 = function1;
		 this.function2 = function2;
	 }
	 public float floatValueOf(T1 object) {
		 return this.function2.floatValueOf(this.function1.valueOf(object));
	 }
 }",0,0,0,0
"public class UDFContextTestLoaderWithSignature extends PigStorage {
	 private String val;
	 public UDFContextTestLoaderWithSignature(String v1) {
		 val = v1;
	 }
	 public void setLocation(String location, Job job) throws IOException {
		 super.setLocation(location, job);
		 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass());
		 if (p.get(signature)==null) {
			 p.put(""test_"" + signature, val);
		 }
	 }
	 public Tuple getNext() throws IOException {
		 Tuple t = super.getNext();
		 if (t!=null) {
			 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass());
			 t.append(p.get(""test_"" + signature));
		 }
		 return t;
	 }
}",1,0,0,0
"public ByteBuffer constructStreamHeader(StreamHeader streamHeader, boolean compress) {
	 int header = 0;
	 header |= serializerType_.ordinal();
	 if ( compress ) header |= 4;
	 header |= 8;
	 header |= (version_ << 8);
	 byte[] bytes;
	 try {
		 DataOutputBuffer buffer = new DataOutputBuffer();
		 StreamHeader.serializer().serialize(streamHeader, buffer);
		 bytes = buffer.getData();
	 }
	 catch (IOException e) {
		 throw new RuntimeException(e);
	 }
	 assert bytes.length > 0;
	 ByteBuffer buffer = ByteBuffer.allocate(4 + 4 + 4 + bytes.length);
	 buffer.putInt(PROTOCOL_MAGIC);
	 buffer.putInt(header);
	 buffer.putInt(bytes.length);
	 buffer.put(bytes);
	 buffer.flip();
	 return buffer;
 }",0,0,0,0
"private void parseBootstrapBox(byte[] bootstrapInfo, int pos) {
	System.out.println(""parsing abst"");
	live = false;
	isMetadata = true;
	int version = readByte(bootstrapInfo, pos);
	int flags = (int) readInt24(bootstrapInfo, pos + 1);
	int bootstrapVersion = (int) readInt32(bootstrapInfo, pos + 4);
	int b = readByte(bootstrapInfo, pos + 8);
	int profile = (b & 0xC0) >> 6;
	int update = (b & 0x10) >> 4;
	if (((b & 0x20) >> 5) > 0) {
		live = true;
		isMetadata = false;
	}
	if (update == 0) {
		segTable.clear();
		fragTable.clear();
	}
	int timescale = (int) readInt32(bootstrapInfo, pos + 9);
	long currentMediaTime = readInt64(bootstrapInfo, 13);
	long smpteTimeCodeOffset = readInt64(bootstrapInfo, 21);
	pos += 29;
	BufferPointer bPtr = new BufferPointer();
	bPtr.setBuf(bootstrapInfo);
	bPtr.setPos(pos);
	String movieIdentifier = readString(bPtr);
	Logger.log(""[F4M Parser- movieIdentifier: "" + movieIdentifier);
	pos = bPtr.getPos();
	int serverEntryCount = readByte(bootstrapInfo, pos++);
	bPtr.setPos(pos);
	for (int i = 0;
	 i < serverEntryCount;
	 i++)readString(bPtr);
	int qualityEntryCount = readByte(bootstrapInfo, pos++);
	bPtr.setPos(pos);
	for (int i = 0;
	 i < qualityEntryCount;
	 i++)readString(bPtr);
	String drmData = readString(bPtr);
	String smetadata = readString(bPtr);
	pos = bPtr.getPos();
	int segRunTableCount = readByte(bootstrapInfo, pos++);
	long boxSize = 0;
	BufferPointer ptr = new BufferPointer();
	ptr.setBuf(bootstrapInfo);
	for (int i = 0;
	 i < segRunTableCount;
	 i++) {
		ptr.setPos(pos);
		String boxType = """";
		BoxInfo boxInfo = readBoxHeader(ptr);
		boxSize = boxInfo.getBoxSize();
		boxType = boxInfo.getBoxType();
		pos = ptr.getPos();
		if (boxType.equals(""asrt""))parseAsrtBox(bootstrapInfo, pos);
		pos += boxSize;
	}
	int fragRunTableCount = readByte(bootstrapInfo, pos++);
	for (int i = 0;
	 i < fragRunTableCount;
	 i++) {
		ptr.setPos(pos);
		BoxInfo boxInfo = readBoxHeader(ptr);
		pos = ptr.getPos();
		boxSize = boxInfo.getBoxSize();
		String boxType = boxInfo.getBoxType();
		Logger.log(""555 "" + boxType + "" "" + boxSize);
		if (boxType.equals(""afrt""))parseAfrtBox(bootstrapInfo, pos);
		pos += (int) boxSize;
	}
	parseSegAndFragTable();
}",0,0,1,0
"public Set<Map.Entry<ByteBuffer, IColumn>> entrySet() {
	 return new ColumnSet(serializer, dis, length);
 }",0,0,0,0
"public class ElementImpl extends MinimalEObjectImpl.Container implements Element{
	 protected static final boolean A_EDEFAULT = false;
	 protected boolean a = A_EDEFAULT;
	 protected static final String NAME_EDEFAULT = null;
	 protected String name = NAME_EDEFAULT;
	 protected EList<Element> elements;
	 protected ElementImpl() {
		 super();
	 }
	 protected EClass eStaticClass() {
		 return Bug305397Package.Literals.ELEMENT;
	 }
	 public boolean isA() {
		 return a;
	 }
	 public void setA(boolean newA) {
		 boolean oldA = a;
		 a = newA;
		 if (eNotificationRequired()) eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__A, oldA, a));
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String newName) {
		 String oldName = name;
		 name = newName;
		 if (eNotificationRequired()) eNotify(new ENotificationImpl(this, Notification.SET, Bug305397Package.ELEMENT__NAME, oldName, name));
	 }
	 public EList<Element> getElements() {
		 if (elements == null) {
			 elements = new EObjectContainmentEList<Element>(Element.class, this, Bug305397Package.ELEMENT__ELEMENTS);
		 }
		 return elements;
	 }
	 public NotificationChain eInverseRemove(InternalEObject otherEnd, int featureID, NotificationChain msgs) {
		 switch (featureID) {
			 case Bug305397Package.ELEMENT__ELEMENTS: return ((InternalEList<?>)getElements()).basicRemove(otherEnd, msgs);
		 }
		 return super.eInverseRemove(otherEnd, featureID, msgs);
	 }
	 public Object eGet(int featureID, boolean resolve, boolean coreType) {
		 switch (featureID) {
			 case Bug305397Package.ELEMENT__A: return isA();
			 case Bug305397Package.ELEMENT__NAME: return getName();
			 case Bug305397Package.ELEMENT__ELEMENTS: return getElements();
		 }
		 return super.eGet(featureID, resolve, coreType);
	 }
	 public void eSet(int featureID, Object newValue) {
		 switch (featureID) {
			 case Bug305397Package.ELEMENT__A: setA((Boolean)newValue);
			 return;
			 case Bug305397Package.ELEMENT__NAME: setName((String)newValue);
			 return;
			 case Bug305397Package.ELEMENT__ELEMENTS: getElements().clear();
			 getElements().addAll((Collection<? extends Element>)newValue);
			 return;
		 }
		 super.eSet(featureID, newValue);
	 }
	 public void eUnset(int featureID) {
		 switch (featureID) {
			 case Bug305397Package.ELEMENT__A: setA(A_EDEFAULT);
			 return;
			 case Bug305397Package.ELEMENT__NAME: setName(NAME_EDEFAULT);
			 return;
			 case Bug305397Package.ELEMENT__ELEMENTS: getElements().clear();
			 return;
		 }
		 super.eUnset(featureID);
	 }
	 public boolean eIsSet(int featureID) {
		 switch (featureID) {
			 case Bug305397Package.ELEMENT__A: return a != A_EDEFAULT;
			 case Bug305397Package.ELEMENT__NAME: return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
			 case Bug305397Package.ELEMENT__ELEMENTS: return elements != null && !elements.isEmpty();
		 }
		 return super.eIsSet(featureID);
	 }
	 public String toString() {
		 if (eIsProxy()) return super.toString();
		 StringBuffer result = new StringBuffer(super.toString());
		 result.append("" (a: "");
		 result.append(a);
		 result.append("", name: "");
		 result.append(name);
		 result.append(')');
		 return result.toString();
	 }
}",1,1,0,0
"public class VersionMismatchException extends IOException {
	 private byte expectedVersion;
	 private byte foundVersion;
	 public VersionMismatchException(byte expectedVersionIn, byte foundVersionIn){
		 expectedVersion = expectedVersionIn;
		 foundVersion = foundVersionIn;
	 }
	 public String toString(){
		 return ""A record version mismatch occured. Expecting v"" + expectedVersion + "", found v"" + foundVersion;
	 }
}",0,0,0,0
public void setPlotOutlinePaint(Paint paint);,0,0,0,0
"public class _AdministrationWebServiceSoap_QueryBuildAgentsByUri implements ElementSerializable{
	 protected String[] agentUris;
	 public _AdministrationWebServiceSoap_QueryBuildAgentsByUri() {
		 super();
	 }
	 public _AdministrationWebServiceSoap_QueryBuildAgentsByUri(final String[] agentUris) {
		 setAgentUris(agentUris);
	 }
	 public String[] getAgentUris() {
		 return this.agentUris;
	 }
	 public void setAgentUris(String[] value) {
		 this.agentUris = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 if (this.agentUris != null) {
			 writer.writeStartElement(""agentUris"");
			 for (int iterator0 = 0;
			 iterator0 < this.agentUris.length;
			 iterator0++) {
				 XMLStreamWriterHelper.writeElement( writer, ""string"", this.agentUris[iterator0]);
			 }
			 writer.writeEndElement();
		 }
		 writer.writeEndElement();
	 }
}",0,1,0,0
"public final class RussianAnalyzer extends Analyzer{
	 private static char A = 0;
	 private static char B = 1;
	 private static char V = 2;
	 private static char G = 3;
	 private static char D = 4;
	 private static char E = 5;
	 private static char ZH = 6;
	 private static char Z = 7;
	 private static char I = 8;
	 private static char I_ = 9;
	 private static char K = 10;
	 private static char L = 11;
	 private static char M = 12;
	 private static char N = 13;
	 private static char O = 14;
	 private static char P = 15;
	 private static char R = 16;
	 private static char S = 17;
	 private static char T = 18;
	 private static char U = 19;
	 private static char F = 20;
	 private static char X = 21;
	 private static char TS = 22;
	 private static char CH = 23;
	 private static char SH = 24;
	 private static char SHCH = 25;
	 private static char HARD = 26;
	 private static char Y = 27;
	 private static char SOFT = 28;
	 private static char AE = 29;
	 private static char IU = 30;
	 private static char IA = 31;
	 private static char[][] RUSSIAN_STOP_WORDS = {
		 {
		A}
		, {
		B, E, Z}
		, {
		B, O, L, E, E}
		, {
		B, Y}
		, {
		B, Y, L}
		, {
		B, Y, L, A}
		, {
		B, Y, L, I}
		, {
		B, Y, L, O}
		, {
		B, Y, T, SOFT}
		, {
		V}
		, {
		V, A, M}
		, {
		V, A, S}
		, {
		V, E, S, SOFT}
		, {
		V, O}
		, {
		V, O, T}
		, {
		V, S, E}
		, {
		V, S, E, G, O}
		, {
		V, S, E, X}
		, {
		V, Y}
		, {
		G, D, E}
		, {
		D, A}
		, {
		D, A, ZH, E}
		, {
		D, L, IA}
		, {
		D, O}
		, {
		E, G, O}
		, {
		E, E}
		, {
		E, I_,}
		, {
		E, IU}
		, {
		E, S, L, I}
		, {
		E, S, T, SOFT}
		, {
		E, SHCH, E}
		, {
		ZH, E}
		, {
		Z, A}
		, {
		Z, D, E, S, SOFT}
		, {
		I}
		, {
		I, Z}
		, {
		I, L, I}
		, {
		I, M}
		, {
		I, X}
		, {
		K}
		, {
		K, A, K}
		, {
		K, O}
		, {
		K, O, G, D, A}
		, {
		K, T, O}
		, {
		L, I}
		, {
		L, I, B, O}
		, {
		M, N, E}
		, {
		M, O, ZH, E, T}
		, {
		M, Y}
		, {
		N, A}
		, {
		N, A, D, O}
		, {
		N, A, SH}
		, {
		N, E}
		, {
		N, E, G, O}
		, {
		N, E, E}
		, {
		N, E, T}
		, {
		N, I}
		, {
		N, I, X}
		, {
		N, O}
		, {
		N, U}
		, {
		O}
		, {
		O, B}
		, {
		O, D, N, A, K, O}
		, {
		O, N}
		, {
		O, N, A}
		, {
		O, N, I}
		, {
		O, N, O}
		, {
		O, T}
		, {
		O, CH, E, N, SOFT}
		, {
		P, O}
		, {
		P, O, D}
		, {
		P, R, I}
		, {
		S}
		, {
		S, O}
		, {
		T, A, K}
		, {
		T, A, K, ZH, E}
		, {
		T, A, K, O, I_}
		, {
		T, A, M}
		, {
		T, E}
		, {
		T, E, M}
		, {
		T, O}
		, {
		T, O, G, O}
		, {
		T, O, ZH, E}
		, {
		T, O, I_}
		, {
		T, O, L, SOFT, K, O}
		, {
		T, O, M}
		, {
		T, Y}
		, {
		U}
		, {
		U, ZH, E}
		, {
		X, O, T, IA}
		, {
		CH, E, G, O}
		, {
		CH, E, I_}
		, {
		CH, E, M}
		, {
		CH, T, O}
		, {
		CH, T, O, B, Y}
		, {
		CH, SOFT, E}
		, {
		CH, SOFT, IA}
		, {
		AE, T, A}
		, {
		AE, T, I}
		, {
		AE, T, O}
		, {
		IA}
	 }
	;
	 private Set stopSet = new HashSet();
	 private char[] charset;
	 public RussianAnalyzer() {
		 charset = RussianCharsets.UnicodeRussian;
		 stopSet = StopFilter.makeStopSet( makeStopWords(RussianCharsets.UnicodeRussian));
	 }
	 public RussianAnalyzer(char[] charset) {
		 this.charset = charset;
		 stopSet = StopFilter.makeStopSet(makeStopWords(charset));
	 }
	 public RussianAnalyzer(char[] charset, String[] stopwords) {
		 this.charset = charset;
		 stopSet = StopFilter.makeStopSet(stopwords);
	 }
	 private static String[] makeStopWords(char[] charset) {
		 String[] res = new String[RUSSIAN_STOP_WORDS.length];
		 for (int i = 0;
		 i < res.length;
		 i++) {
			 char[] theStopWord = RUSSIAN_STOP_WORDS[i];
			 StringBuffer theWord = new StringBuffer();
			 for (int j = 0;
			 j < theStopWord.length;
			 j++) {
				 theWord.append(charset[theStopWord[j]]);
			 }
			 res[i] = theWord.toString();
		 }
		 return res;
	 }
	 public RussianAnalyzer(char[] charset, Hashtable stopwords) {
		 this.charset = charset;
		 stopSet = new HashSet(stopwords.keySet());
	 }
	 public TokenStream tokenStream(String fieldName, Reader reader) {
		 TokenStream result = new RussianLetterTokenizer(reader, charset);
		 result = new RussianLowerCaseFilter(result, charset);
		 result = new StopFilter(result, stopSet);
		 result = new RussianStemFilter(result, charset);
		 return result;
	 }
}",1,0,0,0
"public class Cluster {
	 public static enum JobTrackerStatus {
	INITIALIZING, RUNNING}
	;
	 private ClientProtocolProvider clientProtocolProvider;
	 private ClientProtocol client;
	 private UserGroupInformation ugi;
	 private Configuration conf;
	 private FileSystem fs = null;
	 private Path sysDir = null;
	 private Path stagingAreaDir = null;
	 private Path jobHistoryDir = null;
	 private static final Log LOG = LogFactory.getLog(Cluster.class);
	 private static ServiceLoader<ClientProtocolProvider> frameworkLoader = ServiceLoader.load(ClientProtocolProvider.class);
	 static {
		 ConfigUtil.loadResources();
	 }
	 public Cluster(Configuration conf) throws IOException {
		 this(null, conf);
	 }
	 public Cluster(InetSocketAddress jobTrackAddr, Configuration conf) throws IOException {
		 this.conf = conf;
		 this.ugi = UserGroupInformation.getCurrentUser();
		 initialize(jobTrackAddr, conf);
	 }
	 private void initialize(InetSocketAddress jobTrackAddr, Configuration conf) throws IOException {
		 synchronized (frameworkLoader) {
			 for (ClientProtocolProvider provider : frameworkLoader) {
				 LOG.debug(""Trying ClientProtocolProvider : "" + provider.getClass().getName());
				 ClientProtocol clientProtocol = null;
				 try {
					 if (jobTrackAddr == null) {
						 clientProtocol = provider.create(conf);
					 }
					 else {
						 clientProtocol = provider.create(jobTrackAddr, conf);
					 }
					 if (clientProtocol != null) {
						 clientProtocolProvider = provider;
						 client = clientProtocol;
						 LOG.debug(""Picked "" + provider.getClass().getName() + "" as the ClientProtocolProvider"");
						 break;
					 }
					 else {
						 LOG.debug(""Cannot pick "" + provider.getClass().getName() + "" as the ClientProtocolProvider - returned null protocol"");
					 }
				 }
				 catch (Exception e) {
					 LOG.info(""Failed to use "" + provider.getClass().getName() + "" due to error: "" + e.getMessage());
				 }
			 }
		 }
		 if (null == clientProtocolProvider || null == client) {
			 throw new IOException( ""Cannot initialize Cluster. Please check your configuration for "" + MRConfig.FRAMEWORK_NAME + "" and the correspond server addresses."");
		 }
	 }
	 ClientProtocol getClient() {
		 return client;
	 }
	 Configuration getConf() {
		 return conf;
	 }
	 public synchronized void close() throws IOException {
		 clientProtocolProvider.close(client);
	 }
	 private Job[] getJobs(JobStatus[] stats) throws IOException {
		 List<Job> jobs = new ArrayList<Job>();
		 for (JobStatus stat : stats) {
			 jobs.add(Job.getInstance(this, stat, new JobConf(stat.getJobFile())));
		 }
		 return jobs.toArray(new Job[0]);
	 }
	 public synchronized FileSystem getFileSystem() throws IOException, InterruptedException {
		 if (this.fs == null) {
			 try {
				 this.fs = ugi.doAs(new PrivilegedExceptionAction<FileSystem>() {
					 public FileSystem run() throws IOException, InterruptedException {
						 final Path sysDir = new Path(client.getSystemDir());
						 return sysDir.getFileSystem(getConf());
					 }
				 }
				);
			 }
			 catch (InterruptedException e) {
				 throw new RuntimeException(e);
			 }
		 }
		 return fs;
	 }
	 public Job getJob(JobID jobId) throws IOException, InterruptedException {
		 JobStatus status = client.getJobStatus(jobId);
		 if (status != null) {
			 JobConf conf;
			 try {
				 conf = new JobConf(status.getJobFile());
			 }
			 catch (RuntimeException ex) {
				 if (ex.getCause() instanceof FileNotFoundException) {
					 return null;
				 }
				 else {
					 throw ex;
				 }
			 }
			 return Job.getInstance(this, status, conf);
		 }
		 return null;
	 }
	 public QueueInfo[] getQueues() throws IOException, InterruptedException {
		 return client.getQueues();
	 }
	 public QueueInfo getQueue(String name) throws IOException, InterruptedException {
		 return client.getQueue(name);
	 }
	 public LogParams getLogParams(JobID jobID, TaskAttemptID taskAttemptID) throws IOException, InterruptedException {
		 return client.getLogFileParams(jobID, taskAttemptID);
	 }
	 public ClusterMetrics getClusterStatus() throws IOException, InterruptedException {
		 return client.getClusterMetrics();
	 }
	 public TaskTrackerInfo[] getActiveTaskTrackers() throws IOException, InterruptedException {
		 return client.getActiveTrackers();
	 }
	 public TaskTrackerInfo[] getBlackListedTaskTrackers() throws IOException, InterruptedException {
		 return client.getBlacklistedTrackers();
	 }
	 public Job[] getAllJobs() throws IOException, InterruptedException {
		 return getJobs(client.getAllJobs());
	 }
	 public JobStatus[] getAllJobStatuses() throws IOException, InterruptedException {
		 return client.getAllJobs();
	 }
	 public Path getSystemDir() throws IOException, InterruptedException {
		 if (sysDir == null) {
			 sysDir = new Path(client.getSystemDir());
		 }
		 return sysDir;
	 }
	 public Path getStagingAreaDir() throws IOException, InterruptedException {
		 if (stagingAreaDir == null) {
			 stagingAreaDir = new Path(client.getStagingAreaDir());
		 }
		 return stagingAreaDir;
	 }
	 public String getJobHistoryUrl(JobID jobId) throws IOException, InterruptedException {
		 if (jobHistoryDir == null) {
			 jobHistoryDir = new Path(client.getJobHistoryDir());
		 }
		 return new Path(jobHistoryDir, jobId.toString() + ""_"" + ugi.getShortUserName()).toString();
	 }
	 public QueueAclsInfo[] getQueueAclsForCurrentUser() throws IOException, InterruptedException {
		 return client.getQueueAclsForCurrentUser();
	 }
	 public QueueInfo[] getRootQueues() throws IOException, InterruptedException {
		 return client.getRootQueues();
	 }
	 public QueueInfo[] getChildQueues(String queueName) throws IOException, InterruptedException {
		 return client.getChildQueues(queueName);
	 }
	 public JobTrackerStatus getJobTrackerStatus() throws IOException, InterruptedException {
		 return client.getJobTrackerStatus();
	 }
	 public long getTaskTrackerExpiryInterval() throws IOException, InterruptedException {
		 return client.getTaskTrackerExpiryInterval();
	 }
	 public Token<DelegationTokenIdentifier> getDelegationToken(Text renewer) throws IOException, InterruptedException{
		 return client.getDelegationToken(renewer);
	 }
	 public long renewDelegationToken(Token<DelegationTokenIdentifier> token ) throws InvalidToken, IOException, InterruptedException {
		 return token.renew(getConf());
	 }
	 public void cancelDelegationToken(Token<DelegationTokenIdentifier> token ) throws IOException, InterruptedException {
		 token.cancel(getConf());
	 }
}",1,1,0,0
"public class SVGInputFormat implements InputFormat {
	 private static final boolean DEBUG = false;
	 private SVGFigureFactory factory;
	 private URL url;
	 private HashMap<String, IXMLElement> identifiedElements;
	 private HashMap<IXMLElement, Object> elementObjects;
	 private StreamPosTokenizer toPathTokenizer;
	 private FontFormatter fontFormatter = new FontFormatter();
	 private static class Viewport {
		 public double width = 640d;
		 public double height = 480d;
		 public Rectangle2D.Double viewBox = new Rectangle2D.Double(0d, 0d, 640d, 480d);
		 public double widthPercentFactor = 640d / 100d;
		 public double heightPercentFactor = 480d / 100d;
		 public double numberFactor;
		 public boolean isPreserveAspectRatio = true;
		 private HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>();
		 public String toString() {
			 return ""widthPercentFactor:"" + widthPercentFactor + "";
			"" + ""heightPercentFactor:"" + heightPercentFactor + "";
			"" + ""numberFactor:"" + numberFactor + "";
			"" + attributes;
		 }
	 }
	 private Stack<Viewport> viewportStack;
	 private StyleManager styleManager;
	 private LinkedList<Figure> figures;
	 private IXMLElement document;
	 public SVGInputFormat() {
		 this(new DefaultSVGFigureFactory());
	 }
	 public SVGInputFormat(SVGFigureFactory factory) {
		 this.factory = factory;
	 }
	 public void read(URI uri, Drawing drawing) throws IOException {
		 read(new File(uri), drawing);
	 }
	 public void read(URI uri, Drawing drawing, boolean replace) throws IOException {
		 read(new File(uri), drawing, replace);
	 }
	 public void read(File file, Drawing drawing) throws IOException {
		 read(file, drawing, true);
	 }
	 public void read(File file, Drawing drawing, boolean replace) throws IOException {
		 this.url = file.toURI().toURL();
		 BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));
		 try {
			 read(in, drawing, replace);
		 }
		 finally {
			 in.close();
		 }
		 this.url = null;
	 }
	 public void read(URL url, Drawing drawing, boolean replace) throws IOException {
		 this.url = url;
		 InputStream in = url.openStream();
		 try {
			 read(in, drawing, replace);
		 }
		 finally {
			 in.close();
		 }
		 this.url = null;
	 }
	 public void read(InputStream in, Drawing drawing, boolean replace) throws IOException {
		 long start = System.currentTimeMillis();
		 this.figures = new LinkedList<Figure>();
		 IXMLParser parser;
		 try {
			 parser = XMLParserFactory.createDefaultXMLParser();
		 }
		 catch (Exception ex) {
			 InternalError e = new InternalError(""Unable to instantiate NanoXML Parser"");
			 e.initCause(ex);
			 throw e;
		 }
		 System.out.println(""SVGInputFormat parser created "" + (System.currentTimeMillis() - start));
		 IXMLReader reader = new StdXMLReader(in);
		 parser.setReader(reader);
		 System.out.println(""SVGInputFormat reader created "" + (System.currentTimeMillis() - start));
		 try {
			 document = (IXMLElement) parser.parse();
		 }
		 catch (XMLException ex) {
			 IOException e = new IOException(ex.getMessage());
			 e.initCause(ex);
			 throw e;
		 }
		 System.out.println(""SVGInputFormat document created "" + (System.currentTimeMillis() - start));
		 IXMLElement svg = document;
		 Stack<Iterator<IXMLElement>> stack = new Stack<Iterator<IXMLElement>>();
		 LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();
		 ll.add(document);
		 stack.push(ll.iterator());
		 while (!stack.empty() && stack.peek().hasNext()) {
			 Iterator<IXMLElement> iter = stack.peek();
			 IXMLElement node = iter.next();
			 Iterator<IXMLElement> children = (node.getChildren() == null) ? null : node.getChildren().iterator();
			 if (!iter.hasNext()) {
				 stack.pop();
			 }
			 if (children != null && children.hasNext()) {
				 stack.push(children);
			 }
			 if (node.getName() != null && node.getName().equals(""svg"") && (node.getNamespace() == null || node.getNamespace().equals(SVG_NAMESPACE))) {
				 svg = node;
				 break;
			 }
		 }
		 if (svg.getName() == null || !svg.getName().equals(""svg"") || (svg.getNamespace() != null && !svg.getNamespace().equals(SVG_NAMESPACE))) {
			 throw new IOException(""'svg' element expected: "" + svg.getName());
		 }
		 initStorageContext(document);
		 flattenStyles(svg);
		 readElement(svg);
		 long end = System.currentTimeMillis();
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat elapsed:"" + (end - start));
		 }
		 if (replace) {
			 drawing.removeAllChildren();
		 }
		 drawing.addAll(figures);
		 if (replace) {
			 Viewport viewport = viewportStack.firstElement();
			 drawing.set(VIEWPORT_FILL, VIEWPORT_FILL.get(viewport.attributes));
			 drawing.set(VIEWPORT_FILL_OPACITY, VIEWPORT_FILL_OPACITY.get(viewport.attributes));
			 drawing.set(VIEWPORT_HEIGHT, VIEWPORT_HEIGHT.get(viewport.attributes));
			 drawing.set(VIEWPORT_WIDTH, VIEWPORT_WIDTH.get(viewport.attributes));
		 }
		 document.dispose();
		 identifiedElements.clear();
		 elementObjects.clear();
		 viewportStack.clear();
		 styleManager.clear();
		 document = null;
		 identifiedElements = null;
		 elementObjects = null;
		 viewportStack = null;
		 styleManager = null;
	 }
	 private void initStorageContext(IXMLElement root) {
		 identifiedElements = new HashMap<String, IXMLElement>();
		 identifyElements(root);
		 elementObjects = new HashMap<IXMLElement, Object>();
		 viewportStack = new Stack<Viewport>();
		 viewportStack.push(new Viewport());
		 styleManager = new StyleManager();
	 }
	 private void flattenStyles(IXMLElement elem) throws IOException {
		 if (elem.getName() != null && elem.getName().equals(""style"") && readAttribute(elem, ""type"", """").equals(""text/css"") && elem.getContent() != null) {
			 CSSParser cssParser = new CSSParser();
			 cssParser.parse(elem.getContent(), styleManager);
		 }
		 else {
			 if (elem.getNamespace() == null || elem.getNamespace().equals(SVG_NAMESPACE)) {
				 String style = readAttribute(elem, ""style"", null);
				 if (style != null) {
					 for (String styleProperty : style.split("";
					"")) {
						 String[] stylePropertyElements = styleProperty.split("":"");
						 if (stylePropertyElements.length == 2 && !elem.hasAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE)) {
							 elem.setAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE, stylePropertyElements[1].trim());
						 }
					 }
				 }
				 styleManager.applyStylesTo(elem);
				 for (IXMLElement node : elem.getChildren()) {
					 if (node instanceof IXMLElement) {
						 IXMLElement child = (IXMLElement) node;
						 flattenStyles(child);
					 }
				 }
			 }
		 }
	 }
	 private Figure readElement(IXMLElement elem) throws IOException {
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat.readElement "" + elem.getName() + "" line:"" + elem.getLineNr());
		 }
		 Figure f = null;
		 if (elem.getNamespace() == null || elem.getNamespace().equals(SVG_NAMESPACE)) {
			 String name = elem.getName();
			 if (name == null) {
				 if (DEBUG) {
					 System.err.println(""SVGInputFormat warning: skipping nameless element at line "" + elem.getLineNr());
				 }
			 }
			 else if (name.equals(""a"")) {
				 f = readAElement(elem);
			 }
			 else if (name.equals(""circle"")) {
				 f = readCircleElement(elem);
			 }
			 else if (name.equals(""defs"")) {
				 readDefsElement(elem);
				 f = null;
			 }
			 else if (name.equals(""ellipse"")) {
				 f = readEllipseElement(elem);
			 }
			 else if (name.equals(""g"")) {
				 f = readGElement(elem);
			 }
			 else if (name.equals(""image"")) {
				 f = readImageElement(elem);
			 }
			 else if (name.equals(""line"")) {
				 f = readLineElement(elem);
			 }
			 else if (name.equals(""linearGradient"")) {
				 readLinearGradientElement(elem);
				 f = null;
			 }
			 else if (name.equals(""path"")) {
				 f = readPathElement(elem);
			 }
			 else if (name.equals(""polygon"")) {
				 f = readPolygonElement(elem);
			 }
			 else if (name.equals(""polyline"")) {
				 f = readPolylineElement(elem);
			 }
			 else if (name.equals(""radialGradient"")) {
				 readRadialGradientElement(elem);
				 f = null;
			 }
			 else if (name.equals(""rect"")) {
				 f = readRectElement(elem);
			 }
			 else if (name.equals(""solidColor"")) {
				 readSolidColorElement(elem);
				 f = null;
			 }
			 else if (name.equals(""svg"")) {
				 f = readSVGElement(elem);
			 }
			 else if (name.equals(""switch"")) {
				 f = readSwitchElement(elem);
			 }
			 else if (name.equals(""text"")) {
				 f = readTextElement(elem);
			 }
			 else if (name.equals(""textArea"")) {
				 f = readTextAreaElement(elem);
			 }
			 else if (name.equals(""title"")) {
			 }
			 else if (name.equals(""use"")) {
				 f = readUseElement(elem);
			 }
			 else if (name.equals(""style"")) {
			 }
			 else {
				 if (DEBUG) {
					 System.out.println(""SVGInputFormat not implemented for <"" + name + "">"");
				 }
			 }
		 }
		 if (f instanceof SVGFigure) {
			 if (((SVGFigure) f).isEmpty()) {
				 return null;
			 }
		 }
		 else if (f != null) {
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat warning: not an SVGFigure "" + f);
			 }
		 }
		 return f;
	 }
	 private void readDefsElement(IXMLElement elem) throws IOException {
		 for (IXMLElement node : elem.getChildren()) {
			 if (node instanceof IXMLElement) {
				 IXMLElement child = (IXMLElement) node;
				 Figure childFigure = readElement(child);
			 }
		 }
	 }
	 private Figure readGElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readOpacityAttribute(elem, a);
		 CompositeFigure g = factory.createG(a);
		 for (IXMLElement node : elem.getChildren()) {
			 if (node instanceof IXMLElement) {
				 IXMLElement child = (IXMLElement) node;
				 Figure childFigure = readElement(child);
				 if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") && !readAttribute(child, ""display"", ""inline"").equals(""none"")) {
					 if (childFigure != null) {
						 g.basicAdd(childFigure);
					 }
				 }
			 }
		 }
		 readTransformAttribute(elem, a);
		 if (TRANSFORM.get(a) != null) {
			 g.transform(TRANSFORM.get(a));
		 }
		 return g;
	 }
	 private Figure readAElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 CompositeFigure g = factory.createG(a);
		 String href = readAttribute(elem, ""xlink:href"", null);
		 if (href == null) {
			 href = readAttribute(elem, ""href"", null);
		 }
		 String target = readAttribute(elem, ""target"", null);
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat.readAElement href="" + href);
		 }
		 for (IXMLElement node : elem.getChildren()) {
			 if (node instanceof IXMLElement) {
				 IXMLElement child = (IXMLElement) node;
				 Figure childFigure = readElement(child);
				 if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") && !readAttribute(child, ""display"", ""inline"").equals(""none"")) {
					 if (childFigure != null) {
						 g.basicAdd(childFigure);
					 }
				 }
				 if (childFigure != null) {
					 childFigure.set(LINK, href);
					 childFigure.set(LINK_TARGET, target);
				 }
				 else {
					 if (DEBUG) {
						 System.out.println(""SVGInputFormat <a> has no child figure"");
					 }
				 }
			 }
		 }
		 return (g.getChildCount() == 1) ? g.getChild(0) : g;
	 }
	 private Figure readSVGElement(IXMLElement elem) throws IOException {
		 Viewport viewport = new Viewport();
		 String widthValue = readAttribute(elem, ""width"", ""100%"");
		 String heightValue = readAttribute(elem, ""height"", ""100%"");
		 viewport.width = toWidth(elem, widthValue);
		 viewport.height = toHeight(elem, heightValue);
		 if (readAttribute(elem, ""viewBox"", ""none"").equals(""none"")) {
			 viewport.viewBox.width = viewport.width;
			 viewport.viewBox.height = viewport.height;
		 }
		 else {
			 String[] viewBoxValues = toWSOrCommaSeparatedArray(readAttribute(elem, ""viewBox"", ""none""));
			 viewport.viewBox.x = toNumber(elem, viewBoxValues[0]);
			 viewport.viewBox.y = toNumber(elem, viewBoxValues[1]);
			 viewport.viewBox.width = toNumber(elem, viewBoxValues[2]);
			 viewport.viewBox.height = toNumber(elem, viewBoxValues[3]);
			 if (widthValue.indexOf('%') > 0) {
				 viewport.width = viewport.viewBox.width;
			 }
			 if (heightValue.indexOf('%') > 0) {
				 viewport.height = viewport.viewBox.height;
			 }
		 }
		 if (viewportStack.size() == 1) {
			 viewport.isPreserveAspectRatio = true;
		 }
		 else {
			 viewport.isPreserveAspectRatio = !readAttribute(elem, ""preserveAspectRatio"", ""none"").equals(""none"");
		 }
		 viewport.widthPercentFactor = viewport.viewBox.width / 100d;
		 viewport.heightPercentFactor = viewport.viewBox.height / 100d;
		 viewport.numberFactor = Math.min( viewport.width / viewport.viewBox.width, viewport.height / viewport.viewBox.height);
		 AffineTransform viewBoxTransform = new AffineTransform();
		 viewBoxTransform.translate( -viewport.viewBox.x * viewport.width / viewport.viewBox.width, -viewport.viewBox.y * viewport.height / viewport.viewBox.height);
		 if (viewport.isPreserveAspectRatio) {
			 double factor = Math.min( viewport.width / viewport.viewBox.width, viewport.height / viewport.viewBox.height);
			 viewBoxTransform.scale(factor, factor);
		 }
		 else {
			 viewBoxTransform.scale( viewport.width / viewport.viewBox.width, viewport.height / viewport.viewBox.height);
		 }
		 viewportStack.push(viewport);
		 readViewportAttributes(elem, viewportStack.firstElement().attributes);
		 for (IXMLElement node : elem.getChildren()) {
			 if (node instanceof IXMLElement) {
				 IXMLElement child = (IXMLElement) node;
				 Figure childFigure = readElement(child);
				 if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") && !readAttribute(child, ""display"", ""inline"").equals(""none"")) {
					 if (childFigure != null) {
						 childFigure.transform(viewBoxTransform);
						 figures.add(childFigure);
					 }
				 }
			 }
		 }
		 viewportStack.pop();
		 return null;
	 }
	 private Figure readRectElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));
		 double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));
		 double w = toWidth(elem, readAttribute(elem, ""width"", ""0""));
		 double h = toHeight(elem, readAttribute(elem, ""height"", ""0""));
		 String rxValue = readAttribute(elem, ""rx"", ""none"");
		 String ryValue = readAttribute(elem, ""ry"", ""none"");
		 if (rxValue.equals(""none"")) {
			 rxValue = ryValue;
		 }
		 if (ryValue.equals(""none"")) {
			 ryValue = rxValue;
		 }
		 double rx = toNumber(elem, rxValue.equals(""none"") ? ""0"" : rxValue);
		 double ry = toNumber(elem, ryValue.equals(""none"") ? ""0"" : ryValue);
		 Figure figure = factory.createRect(x, y, w, h, rx, ry, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readCircleElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 double cx = toWidth(elem, readAttribute(elem, ""cx"", ""0""));
		 double cy = toHeight(elem, readAttribute(elem, ""cy"", ""0""));
		 double r = toWidth(elem, readAttribute(elem, ""r"", ""0""));
		 Figure figure = factory.createCircle(cx, cy, r, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readEllipseElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 double cx = toWidth(elem, readAttribute(elem, ""cx"", ""0""));
		 double cy = toHeight(elem, readAttribute(elem, ""cy"", ""0""));
		 double rx = toWidth(elem, readAttribute(elem, ""rx"", ""0""));
		 double ry = toHeight(elem, readAttribute(elem, ""ry"", ""0""));
		 Figure figure = factory.createEllipse(cx, cy, rx, ry, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readImageElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));
		 double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));
		 double w = toWidth(elem, readAttribute(elem, ""width"", ""0""));
		 double h = toHeight(elem, readAttribute(elem, ""height"", ""0""));
		 String href = readAttribute(elem, ""xlink:href"", null);
		 if (href == null) {
			 href = readAttribute(elem, ""href"", null);
		 }
		 byte[] imageData = null;
		 if (href != null) {
			 if (href.startsWith(""data:"")) {
				 int semicolonPos = href.indexOf(';
				');
				 if (semicolonPos != -1) {
					 if (href.indexOf("";
					base64,"") == semicolonPos) {
						 imageData = Base64.decode(href.substring(semicolonPos + 8));
					 }
					 else {
						 throw new IOException(""Unsupported encoding in data href in image element:"" + href);
					 }
				 }
				 else {
					 throw new IOException(""Unsupported data href in image element:"" + href);
				 }
			 }
			 else {
				 URL imageUrl = new URL(url, href);
				 if (imageUrl.getFile().endsWith(""svg"")) {
					 SVGInputFormat svgImage = new SVGInputFormat(factory);
					 Drawing svgDrawing = new DefaultDrawing();
					 svgImage.read(imageUrl, svgDrawing, true);
					 CompositeFigure svgImageGroup = factory.createG(a);
					 for (Figure f : svgDrawing.getChildren()) {
						 svgImageGroup.add(f);
					 }
					 svgImageGroup.setBounds(new Point2D.Double(x, y), new Point2D.Double(x + w, y + h));
					 return svgImageGroup;
				 }
				 ByteArrayOutputStream bout = new ByteArrayOutputStream();
				 byte[] buf = new byte[512];
				 int len = 0;
				 try {
					 InputStream in = imageUrl.openStream();
					 try {
						 while ((len = in.read(buf)) > 0) {
							 bout.write(buf, 0, len);
						 }
						 imageData = bout.toByteArray();
					 }
					 finally {
						 in.close();
					 }
				 }
				 catch (FileNotFoundException e) {
				 }
			 }
		 }
		 BufferedImage bufferedImage = null;
		 if (imageData != null) {
			 try {
				 bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
			 }
			 catch (IIOException e) {
				 System.err.println(""SVGInputFormat warning: skipped unsupported image format."");
				 e.printStackTrace();
			 }
		 }
		 if (bufferedImage == null) {
			 imageData = null;
		 }
		 Figure figure = factory.createImage(x, y, w, h, imageData, bufferedImage, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readLineElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readLineAttributes(elem, a);
		 if (FILL_COLOR.get(a) != null && STROKE_COLOR.get(a) == null) {
			 STROKE_COLOR.put(a, FILL_COLOR.get(a));
		 }
		 if (FILL_GRADIENT.get(a) != null && STROKE_GRADIENT.get(a) == null) {
			 STROKE_GRADIENT.put(a, FILL_GRADIENT.get(a));
		 }
		 FILL_COLOR.put(a, null);
		 FILL_GRADIENT.put(a, null);
		 double x1 = toNumber(elem, readAttribute(elem, ""x1"", ""0""));
		 double y1 = toNumber(elem, readAttribute(elem, ""y1"", ""0""));
		 double x2 = toNumber(elem, readAttribute(elem, ""x2"", ""0""));
		 double y2 = toNumber(elem, readAttribute(elem, ""y2"", ""0""));
		 Figure figure = factory.createLine(x1, y1, x2, y2, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readPolylineElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readLineAttributes(elem, a);
		 Point2D.Double[] points = toPoints(elem, readAttribute(elem, ""points"", """"));
		 Figure figure = factory.createPolyline(points, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readPolygonElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 Point2D.Double[] points = toPoints(elem, readAttribute(elem, ""points"", """"));
		 Figure figure = factory.createPolygon(points, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readPathElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 BezierPath[] beziers = toPath(elem, readAttribute(elem, ""d"", """"));
		 Figure figure = factory.createPath(beziers, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readTextElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 readFontAttributes(elem, a);
		 readTextAttributes(elem, a);
		 String[] xStr = toCommaSeparatedArray(readAttribute(elem, ""x"", ""0""));
		 String[] yStr = toCommaSeparatedArray(readAttribute(elem, ""y"", ""0""));
		 Point2D.Double[] coordinates = new Point2D.Double[Math.max(xStr.length, yStr.length)];
		 double lastX = 0;
		 double lastY = 0;
		 for (int i = 0;
		 i < coordinates.length;
		 i++) {
			 if (xStr.length > i) {
				 try {
					 lastX = toNumber(elem, xStr[i]);
				 }
				 catch (NumberFormatException ex) {
				 }
			 }
			 if (yStr.length > i) {
				 try {
					 lastY = toNumber(elem, yStr[i]);
				 }
				 catch (NumberFormatException ex) {
				 }
			 }
			 coordinates[i] = new Point2D.Double(lastX, lastY);
		 }
		 String[] rotateStr = toCommaSeparatedArray(readAttribute(elem, ""rotate"", """"));
		 double[] rotate = new double[rotateStr.length];
		 for (int i = 0;
		 i < rotateStr.length;
		 i++) {
			 try {
				 rotate[i] = toDouble(elem, rotateStr[i]);
			 }
			 catch (NumberFormatException ex) {
				 rotate[i] = 0;
			 }
		 }
		 DefaultStyledDocument doc = new DefaultStyledDocument();
		 try {
			 if (elem.getContent() != null) {
				 doc.insertString(0, toText(elem, elem.getContent()), null);
			 }
			 else {
				 for (IXMLElement node : elem.getChildren()) {
					 if (node.getName() == null) {
						 doc.insertString(0, toText(elem, node.getContent()), null);
					 }
					 else if (node.getName().equals(""tspan"")) {
						 readTSpanElement((IXMLElement) node, doc);
					 }
					 else {
						 if (DEBUG) {
							 System.out.println(""SVGInputFormat unsupported text node <"" + node.getName() + "">"");
						 }
					 }
				 }
			 }
		 }
		 catch (BadLocationException e) {
			 InternalError ex = new InternalError(e.getMessage());
			 ex.initCause(e);
			 throw ex;
		 }
		 Figure figure = factory.createText(coordinates, rotate, doc, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private Figure readTextAreaElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a);
		 readShapeAttributes(elem, a);
		 readFontAttributes(elem, a);
		 readTextAttributes(elem, a);
		 readTextFlowAttributes(elem, a);
		 double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));
		 double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));
		 double w = toWidth(elem, readAttribute(elem, ""width"", ""0""));
		 double h = toHeight(elem, readAttribute(elem, ""height"", ""0""));
		 DefaultStyledDocument doc = new DefaultStyledDocument();
		 try {
			 if (elem.getContent() != null) {
				 doc.insertString(0, toText(elem, elem.getContent()), null);
			 }
			 else {
				 for (IXMLElement node : elem.getChildren()) {
					 if (node.getName() == null) {
						 doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);
					 }
					 else if (node.getName().equals(""tbreak"")) {
						 doc.insertString(doc.getLength(), ""\n"", null);
					 }
					 else if (node.getName().equals(""tspan"")) {
						 readTSpanElement((IXMLElement) node, doc);
					 }
					 else {
						 if (DEBUG) {
							 System.out.println(""SVGInputFormat unknown text node "" + node.getName());
						 }
					 }
				 }
			 }
		 }
		 catch (BadLocationException e) {
			 InternalError ex = new InternalError(e.getMessage());
			 ex.initCause(e);
			 throw ex;
		 }
		 Figure figure = factory.createTextArea(x, y, w, h, doc, a);
		 elementObjects.put(elem, figure);
		 return figure;
	 }
	 private void readTSpanElement(IXMLElement elem, DefaultStyledDocument doc) throws IOException {
		 try {
			 if (elem.getContent() != null) {
				 doc.insertString(doc.getLength(), toText(elem, elem.getContent()), null);
			 }
			 else {
				 for (IXMLElement node : elem.getChildren()) {
					 if (node instanceof IXMLElement) {
						 IXMLElement child = (IXMLElement) node;
						 if (node.getName() != null && node.getName().equals(""tspan"")) {
							 readTSpanElement((IXMLElement) node, doc);
						 }
						 else {
							 if (DEBUG) {
								 System.out.println(""SVGInputFormat unknown text node "" + node.getName());
							 }
						 }
					 }
					 else {
						 if (node.getName() == null) {
							 doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);
						 }
					 }
				 }
			 }
		 }
		 catch (BadLocationException e) {
			 InternalError ex = new InternalError(e.getMessage());
			 ex.initCause(e);
			 throw ex;
		 }
	 }
	 private final static HashSet<String> supportedFeatures = new HashSet<String>( Arrays.asList(new String[]{
	 ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: ""http: }
	));
	 private Figure readSwitchElement(IXMLElement elem) throws IOException {
		 for (IXMLElement node : elem.getChildren()) {
			 if (node instanceof IXMLElement) {
				 IXMLElement child = (IXMLElement) node;
				 String[] requiredFeatures = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredFeatures"", """"));
				 String[] requiredExtensions = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredExtensions"", """"));
				 String[] systemLanguage = toWSOrCommaSeparatedArray(readAttribute(child, ""systemLanguage"", """"));
				 String[] requiredFormats = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredFormats"", """"));
				 String[] requiredFonts = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredFonts"", """"));
				 boolean isMatch;
				 isMatch = supportedFeatures.containsAll(Arrays.asList(requiredFeatures)) && requiredExtensions.length == 0 && requiredFormats.length == 0 && requiredFonts.length == 0;
				 if (isMatch && systemLanguage.length > 0) {
					 isMatch = false;
					 Locale locale = LocaleUtil.getDefault();
					 for (String lng : systemLanguage) {
						 int p = lng.indexOf('-');
						 if (p == -1) {
							 if (locale.getLanguage().equals(lng)) {
								 isMatch = true;
								 break;
							 }
						 }
						 else {
							 if (locale.getLanguage().equals(lng.substring(0, p)) && locale.getCountry().toLowerCase().equals(lng.substring(p + 1))) {
								 isMatch = true;
								 break;
							 }
						 }
					 }
				 }
				 if (isMatch) {
					 Figure figure = readElement(child);
					 if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") && !readAttribute(child, ""display"", ""inline"").equals(""none"")) {
						 return figure;
					 }
					 else {
						 return null;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 private Figure readUseElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 HashMap<AttributeKey, Object> a2 = new HashMap<AttributeKey, Object>();
		 readTransformAttribute(elem, a);
		 readOpacityAttribute(elem, a2);
		 readUseShapeAttributes(elem, a2);
		 readFontAttributes(elem, a2);
		 String href = readAttribute(elem, ""xlink:href"", null);
		 if (href != null && href.startsWith(""#"")) {
			 IXMLElement refElem = identifiedElements.get(href.substring(1));
			 if (refElem == null) {
				 if (DEBUG) {
					 System.out.println(""SVGInputFormat couldn't find href for <use> element:"" + href);
				 }
			 }
			 else {
				 Object obj = readElement(refElem);
				 if (obj instanceof Figure) {
					 Figure figure = (Figure) ((Figure) obj).clone();
					 for (Map.Entry<AttributeKey, Object> entry : a2.entrySet()) {
						 figure.set(entry.getKey(), entry.getValue());
					 }
					 AffineTransform tx = (TRANSFORM.get(a) == null) ? new AffineTransform() : TRANSFORM.get(a);
					 double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));
					 double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));
					 tx.translate(x, y);
					 figure.transform(tx);
					 return figure;
				 }
			 }
		 }
		 return null;
	 }
	 private String readInheritAttribute(IXMLElement elem, String attributeName, String defaultValue) {
		 if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
			 String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
			 if (value.equals(""inherit"")) {
				 return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
			 }
			 else {
				 return value;
			 }
		 }
		 else if (elem.hasAttribute(attributeName)) {
			 String value = elem.getAttribute(attributeName, """");
			 if (value.equals(""inherit"")) {
				 return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
			 }
			 else {
				 return value;
			 }
		 }
		 else if (elem.getParent() != null && (elem.getParent().getNamespace() == null || elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
			 return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
		 }
		 else {
			 return defaultValue;
		 }
	 }
	 private String readInheritColorAttribute(IXMLElement elem, String attributeName, String defaultValue) {
		 String value = null;
		 if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
			 value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
			 if (value.equals(""inherit"")) {
				 return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
			 }
		 }
		 else if (elem.hasAttribute(attributeName)) {
			 value = elem.getAttribute(attributeName, """");
			 if (value.equals(""inherit"")) {
				 return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
			 }
		 }
		 else if (elem.getParent() != null && (elem.getParent().getNamespace() == null || elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
			 value = readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
		 }
		 else {
			 value = defaultValue;
		 }
		 if (value != null && value.toLowerCase().equals(""currentcolor"") && !attributeName.equals(""color"")) {
			 value = readInheritColorAttribute(elem, ""color"", ""defaultValue"");
		 }
		 return value;
	 }
	 private double readInheritFontSizeAttribute(IXMLElement elem, String attributeName, String defaultValue) throws IOException {
		 String value = null;
		 if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
			 value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
		 }
		 else if (elem.hasAttribute(attributeName)) {
			 value = elem.getAttribute(attributeName, null);
		 }
		 else if (elem.getParent() != null && (elem.getParent().getNamespace() == null || elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
			 return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
		 }
		 else {
			 value = defaultValue;
		 }
		 if (value.equals(""inherit"")) {
			 return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
		 }
		 else if (SVG_ABSOLUTE_FONT_SIZES.containsKey(value)) {
			 return SVG_ABSOLUTE_FONT_SIZES.get(value);
		 }
		 else if (SVG_RELATIVE_FONT_SIZES.containsKey(value)) {
			 return SVG_RELATIVE_FONT_SIZES.get(value) * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
		 }
		 else if (value.endsWith(""%"")) {
			 double factor = Double.valueOf(value.substring(0, value.length() - 1));
			 return factor * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
		 }
		 else {
			 return toNumber(elem, value);
		 }
	 }
	 private String readAttribute(IXMLElement elem, String attributeName, String defaultValue) {
		 if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
			 String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
			 if (value.equals(""inherit"")) {
				 return readAttribute(elem.getParent(), attributeName, defaultValue);
			 }
			 else {
				 return value;
			 }
		 }
		 else if (elem.hasAttribute(attributeName)) {
			 String value = elem.getAttribute(attributeName, null);
			 if (value.equals(""inherit"")) {
				 return readAttribute(elem.getParent(), attributeName, defaultValue);
			 }
			 else {
				 return value;
			 }
		 }
		 else {
			 return defaultValue;
		 }
	 }
	 private double toWidth(IXMLElement elem, String str) throws IOException {
		 return toLength(elem, str, viewportStack.peek().widthPercentFactor);
	 }
	 private double toHeight(IXMLElement elem, String str) throws IOException {
		 return toLength(elem, str, viewportStack.peek().heightPercentFactor);
	 }
	 private double toNumber(IXMLElement elem, String str) throws IOException {
		 return toLength(elem, str, viewportStack.peek().numberFactor);
	 }
	 private double toLength(IXMLElement elem, String str, double percentFactor) throws IOException {
		 double scaleFactor = 1d;
		 if (str == null || str.length() == 0 || str.equals(""none"")) {
			 return 0d;
		 }
		 if (str.endsWith(""%"")) {
			 str = str.substring(0, str.length() - 1);
			 scaleFactor = percentFactor;
		 }
		 else if (str.endsWith(""px"")) {
			 str = str.substring(0, str.length() - 2);
		 }
		 else if (str.endsWith(""pt"")) {
			 str = str.substring(0, str.length() - 2);
			 scaleFactor = 1.25;
		 }
		 else if (str.endsWith(""pc"")) {
			 str = str.substring(0, str.length() - 2);
			 scaleFactor = 15;
		 }
		 else if (str.endsWith(""mm"")) {
			 str = str.substring(0, str.length() - 2);
			 scaleFactor = 3.543307;
		 }
		 else if (str.endsWith(""cm"")) {
			 str = str.substring(0, str.length() - 2);
			 scaleFactor = 35.43307;
		 }
		 else if (str.endsWith(""in"")) {
			 str = str.substring(0, str.length() - 2);
			 scaleFactor = 90;
		 }
		 else if (str.endsWith(""em"")) {
			 str = str.substring(0, str.length() - 2);
			 scaleFactor = toLength(elem, readAttribute(elem, ""font-size"", ""0""), percentFactor);
		 }
		 else {
			 scaleFactor = 1d;
		 }
		 return Double.parseDouble(str) * scaleFactor;
	 }
	 public static String[] toCommaSeparatedArray(String str) throws IOException {
		 return str.split(""\\s*,\\s*"");
	 }
	 public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {
		 String[] result = str.split(""(\\s*,\\s*|\\s+)"");
		 if (result.length == 1 && result[0].equals("""")) {
			 return new String[0];
		 }
		 else {
			 return result;
		 }
	 }
	 public static String[] toQuotedAndCommaSeparatedArray(String str) throws IOException {
		 LinkedList<String> values = new LinkedList<String>();
		 StreamTokenizer tt = new StreamTokenizer(new StringReader(str));
		 tt.wordChars('a', 'z');
		 tt.wordChars('A', 'Z');
		 tt.wordChars(128 + 32, 255);
		 tt.whitespaceChars(0, ' ');
		 tt.quoteChar('""');
		 tt.quoteChar('\'');
		 while (tt.nextToken() != StreamTokenizer.TT_EOF) {
			 switch (tt.ttype) {
				 case StreamTokenizer.TT_WORD: case '""': case '\'': values.add(tt.sval);
				 break;
			 }
		 }
		 return values.toArray(new String[values.size()]);
	 }
	 private Point2D.Double[] toPoints(IXMLElement elem, String str) throws IOException {
		 StringTokenizer tt = new StringTokenizer(str, "" ,"");
		 Point2D.Double[] points = new Point2D.Double[tt.countTokens() / 2];
		 for (int i = 0;
		 i < points.length;
		 i++) {
			 points[i] = new Point2D.Double( toNumber(elem, tt.nextToken()), toNumber(elem, tt.nextToken()));
		 }
		 return points;
	 }
	 private BezierPath[] toPath(IXMLElement elem, String str) throws IOException {
		 LinkedList<BezierPath> paths = new LinkedList<BezierPath>();
		 BezierPath path = null;
		 Point2D.Double p = new Point2D.Double();
		 Point2D.Double c1 = new Point2D.Double();
		 Point2D.Double c2 = new Point2D.Double();
		 StreamPosTokenizer tt;
		 if (toPathTokenizer == null) {
			 tt = new StreamPosTokenizer(new StringReader(str));
			 tt.resetSyntax();
			 tt.parseNumbers();
			 tt.parseExponents();
			 tt.parsePlusAsNumber();
			 tt.whitespaceChars(0, ' ');
			 tt.whitespaceChars(',', ',');
			 toPathTokenizer = tt;
		 }
		 else {
			 tt = toPathTokenizer;
			 tt.setReader(new StringReader(str));
		 }
		 char nextCommand = 'M';
		 char command = 'M';
		 Commands: while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
			 if (tt.ttype > 0) {
				 command = (char) tt.ttype;
			 }
			 else {
				 command = nextCommand;
				 tt.pushBack();
			 }
			 BezierPath.Node node;
			 switch (command) {
				 case 'M': if (path != null) {
					 paths.add(path);
				 }
				 path = new BezierPath();
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'M' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'M' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.moveTo(p.x, p.y);
				 nextCommand = 'L';
				 break;
				 case 'm': if (path != null) {
					 paths.add(path);
				 }
				 path = new BezierPath();
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 'm' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 'm' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.moveTo(p.x, p.y);
				 nextCommand = 'l';
				 break;
				 case 'Z': case 'z': p.x = path.get(0).x[0];
				 p.y = path.get(0).y[0];
				 if (path.size() > 1) {
					 BezierPath.Node first = path.get(0);
					 BezierPath.Node last = path.get(path.size() - 1);
					 if (first.x[0] == last.x[0] && first.y[0] == last.y[0]) {
						 if ((last.mask & BezierPath.C1_MASK) != 0) {
							 first.mask |= BezierPath.C1_MASK;
							 first.x[1] = last.x[1];
							 first.y[1] = last.y[1];
						 }
						 path.remove(path.size() - 1);
					 }
				 }
				 path.setClosed(true);
				 break;
				 case 'L': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'L' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'L' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.lineTo(p.x, p.y);
				 nextCommand = 'L';
				 break;
				 case 'l': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 'l' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 'l' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.lineTo(p.x, p.y);
				 nextCommand = 'l';
				 break;
				 case 'H': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'H' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 path.lineTo(p.x, p.y);
				 nextCommand = 'H';
				 break;
				 case 'h': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 'h' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 path.lineTo(p.x, p.y);
				 nextCommand = 'h';
				 break;
				 case 'V': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'V' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.lineTo(p.x, p.y);
				 nextCommand = 'V';
				 break;
				 case 'v': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 'v' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.lineTo(p.x, p.y);
				 nextCommand = 'v';
				 break;
				 case 'C': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x1 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y1 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.y = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x2 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y2 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.y = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
				 nextCommand = 'C';
				 break;
				 case 'c': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx1 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.x = p.x + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy1 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.y = p.y + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx2 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.x = p.x + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy2 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.y = p.y + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
				 nextCommand = 'c';
				 break;
				 case 'S': node = path.get(path.size() - 1);
				 c1.x = node.x[0] * 2d - node.x[1];
				 c1.y = node.y[0] * 2d - node.y[1];
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x2 coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y2 coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.y = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
				 nextCommand = 'S';
				 break;
				 case 's': node = path.get(path.size() - 1);
				 c1.x = node.x[0] * 2d - node.x[1];
				 c1.y = node.y[0] * 2d - node.y[1];
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx2 coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.x = p.x + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy2 coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c2.y = p.y + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
				 nextCommand = 's';
				 break;
				 case 'Q': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x1 coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y1 coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.y = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.quadTo(c1.x, c1.y, p.x, p.y);
				 nextCommand = 'Q';
				 break;
				 case 'q': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx1 coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.x = p.x + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy1 coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 c1.y = p.y + tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.quadTo(c1.x, c1.y, p.x, p.y);
				 nextCommand = 'q';
				 break;
				 case 'T': node = path.get(path.size() - 1);
				 c1.x = node.x[0] * 2d - node.x[1];
				 c1.y = node.y[0] * 2d - node.y[1];
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'T' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'T' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.quadTo(c1.x, c1.y, p.x, p.y);
				 nextCommand = 'T';
				 break;
				 case 't': node = path.get(path.size() - 1);
				 c1.x = node.x[0] * 2d - node.x[1];
				 c1.y = node.y[0] * 2d - node.y[1];
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dx coordinate missing for 't' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""dy coordinate missing for 't' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.quadTo(c1.x, c1.y, p.x, p.y);
				 nextCommand = 's';
				 break;
				 case 'A': {
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""rx coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 double rx = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""ry coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 double ry = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""x-axis-rotation missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 double xAxisRotation = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""large-arc-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 boolean largeArcFlag = tt.nval != 0;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""sweep-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 boolean sweepFlag = tt.nval != 0;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""x coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 p.x = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""y coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 p.y = tt.nval;
					 path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
					 nextCommand = 'A';
					 break;
				 }
				 case 'a': {
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""rx coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 double rx = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""ry coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 double ry = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""x-axis-rotation missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 double xAxisRotation = tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""large-arc-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 boolean largeArcFlag = tt.nval != 0;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""sweep-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 boolean sweepFlag = tt.nval != 0;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""x coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 p.x += tt.nval;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""y coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
					 }
					 p.y += tt.nval;
					 path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
					 nextCommand = 'a';
					 break;
				 }
				 default: if (DEBUG) {
					 System.out.println(""SVGInputFormat.toPath aborting after illegal path command: "" + command + "" found in path "" + str);
				 }
				 break Commands;
			 }
		 }
		 if (path != null) {
			 paths.add(path);
		 }
		 return paths.toArray(new BezierPath[paths.size()]);
	 }
	 private void readCoreAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
	 }
	 private void identifyElements(IXMLElement elem) {
		 identifiedElements.put(elem.getAttribute(""id"", """"), elem);
		 identifiedElements.put(elem.getAttribute(""xml:id"", """"), elem);
		 for (IXMLElement child : elem.getChildren()) {
			 identifyElements(child);
		 }
	 }
	 private void readOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> a) throws IOException {
		 double value = toDouble(elem, readAttribute(elem, ""opacity"", ""1""), 1, 0, 1);
		 OPACITY.put(a, value);
	 }
	 private void readTextAttributes(IXMLElement elem, Map<AttributeKey, Object> a) throws IOException {
		 Object value;
		 value = readInheritAttribute(elem, ""text-anchor"", ""start"");
		 if (SVG_TEXT_ANCHORS.get(value) != null) {
			 TEXT_ANCHOR.put(a, SVG_TEXT_ANCHORS.get(value));
		 }
		 value = readInheritAttribute(elem, ""display-align"", ""auto"");
		 if (!value.equals(""auto"")) {
			 if (value.equals(""center"")) {
				 TEXT_ANCHOR.put(a, TextAnchor.MIDDLE);
			 }
			 else if (value.equals(""before"")) {
				 TEXT_ANCHOR.put(a, TextAnchor.END);
			 }
		 }
		 value = readInheritAttribute(elem, ""text-align"", ""start"");
		 if (!value.equals(""start"")) {
			 TEXT_ALIGN.put(a, SVG_TEXT_ALIGNS.get(value));
		 }
	 }
	 private void readTextFlowAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
		 Object value;
		 value = readInheritAttribute(elem, ""line-increment"", ""auto"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented line-increment="" + value);
		 }
	 }
	 private void readTransformAttribute(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
		 String value;
		 value = readAttribute(elem, ""transform"", ""none"");
		 if (!value.equals(""none"")) {
			 TRANSFORM.put(a, toTransform(elem, value));
		 }
	 }
	 private void readSolidColorElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 Color color = toColor(elem, readAttribute(elem, ""solid-color"", ""black""));
		 double opacity = toDouble(elem, readAttribute(elem, ""solid-opacity"", ""1""), 1, 0, 1);
		 if (opacity != 1) {
			 color = new Color(((int) (255 * opacity) << 24) | (0xffffff & color.getRGB()), true);
		 }
		 elementObjects.put(elem, color);
	 }
	 private void readShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
		 Object objectValue;
		 String value;
		 double doubleValue;
		 objectValue = toPaint(elem, readInheritColorAttribute(elem, ""fill"", ""black""));
		 if (objectValue instanceof Color) {
			 FILL_COLOR.put(a, (Color) objectValue);
		 }
		 else if (objectValue instanceof Gradient) {
			 FILL_GRADIENT.putClone(a, (Gradient) objectValue);
		 }
		 else if (objectValue == null) {
			 FILL_COLOR.put(a, null);
		 }
		 else {
			 FILL_COLOR.put(a, null);
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat not implemented fill="" + objectValue);
			 }
		 }
		 objectValue = readInheritAttribute(elem, ""fill-opacity"", ""1"");
		 FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
		 value = readInheritAttribute(elem, ""fill-rule"", ""nonzero"");
		 WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
		 objectValue = toPaint(elem, readInheritColorAttribute(elem, ""stroke"", ""none""));
		 if (objectValue instanceof Color) {
			 STROKE_COLOR.put(a, (Color) objectValue);
		 }
		 else if (objectValue instanceof Gradient) {
			 STROKE_GRADIENT.putClone(a, (Gradient) objectValue);
		 }
		 else if (objectValue == null) {
			 STROKE_COLOR.put(a, null);
		 }
		 else {
			 STROKE_COLOR.put(a, null);
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat not implemented stroke="" + objectValue);
			 }
		 }
		 value = readInheritAttribute(elem, ""stroke-dasharray"", ""none"");
		 if (!value.equals(""none"")) {
			 String[] values = toWSOrCommaSeparatedArray(value);
			 double[] dashes = new double[values.length];
			 for (int i = 0;
			 i < values.length;
			 i++) {
				 dashes[i] = toNumber(elem, values[i]);
			 }
			 STROKE_DASHES.put(a, dashes);
		 }
		 doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-dashoffset"", ""0""));
		 STROKE_DASH_PHASE.put(a, doubleValue);
		 IS_STROKE_DASH_FACTOR.put(a, false);
		 value = readInheritAttribute(elem, ""stroke-linecap"", ""butt"");
		 STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));
		 value = readInheritAttribute(elem, ""stroke-linejoin"", ""miter"");
		 STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
		 doubleValue = toDouble(elem, readInheritAttribute(elem, ""stroke-miterlimit"", ""4""), 4d, 1d, Double.MAX_VALUE);
		 STROKE_MITER_LIMIT.put(a, doubleValue);
		 IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
		 objectValue = readInheritAttribute(elem, ""stroke-opacity"", ""1"");
		 STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
		 doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-width"", ""1""));
		 STROKE_WIDTH.put(a, doubleValue);
	 }
	 private void readUseShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
		 Object objectValue;
		 String value;
		 double doubleValue;
		 objectValue = readInheritColorAttribute(elem, ""fill"", null);
		 if (objectValue != null) {
			 objectValue = toPaint(elem, (String) objectValue);
			 if (objectValue instanceof Color) {
				 FILL_COLOR.put(a, (Color) objectValue);
			 }
			 else if (objectValue instanceof Gradient) {
				 FILL_GRADIENT.put(a, (Gradient) objectValue);
			 }
			 else if (objectValue == null) {
				 FILL_COLOR.put(a, null);
			 }
			 else {
				 FILL_COLOR.put(a, null);
				 if (DEBUG) {
					 System.out.println(""SVGInputFormat not implemented fill="" + objectValue);
				 }
			 }
		 }
		 objectValue = readInheritAttribute(elem, ""fill-opacity"", null);
		 if (objectValue != null) {
			 FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
		 }
		 value = readInheritAttribute(elem, ""fill-rule"", null);
		 if (value != null) {
			 WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
		 }
		 objectValue = toPaint(elem, readInheritColorAttribute(elem, ""stroke"", null));
		 if (objectValue != null) {
			 if (objectValue instanceof Color) {
				 STROKE_COLOR.put(a, (Color) objectValue);
			 }
			 else if (objectValue instanceof Gradient) {
				 STROKE_GRADIENT.put(a, (Gradient) objectValue);
			 }
		 }
		 value = readInheritAttribute(elem, ""stroke-dasharray"", null);
		 if (value != null && !value.equals(""none"")) {
			 String[] values = toCommaSeparatedArray(value);
			 double[] dashes = new double[values.length];
			 for (int i = 0;
			 i < values.length;
			 i++) {
				 dashes[i] = toNumber(elem, values[i]);
			 }
			 STROKE_DASHES.put(a, dashes);
		 }
		 objectValue = readInheritAttribute(elem, ""stroke-dashoffset"", null);
		 if (objectValue != null) {
			 doubleValue = toNumber(elem, (String) objectValue);
			 STROKE_DASH_PHASE.put(a, doubleValue);
			 IS_STROKE_DASH_FACTOR.put(a, false);
		 }
		 value = readInheritAttribute(elem, ""stroke-linecap"", null);
		 if (value != null) {
			 STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));
		 }
		 value = readInheritAttribute(elem, ""stroke-linejoin"", null);
		 if (value != null) {
			 STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
		 }
		 objectValue = readInheritAttribute(elem, ""stroke-miterlimit"", null);
		 if (objectValue != null) {
			 doubleValue = toDouble(elem, (String) objectValue, 4d, 1d, Double.MAX_VALUE);
			 STROKE_MITER_LIMIT.put(a, doubleValue);
			 IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
		 }
		 objectValue = readInheritAttribute(elem, ""stroke-opacity"", null);
		 if (objectValue != null) {
			 STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
		 }
		 objectValue = readInheritAttribute(elem, ""stroke-width"", null);
		 if (objectValue != null) {
			 doubleValue = toNumber(elem, (String) objectValue);
			 STROKE_WIDTH.put(a, doubleValue);
		 }
	 }
	 private void readLineAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
		 Object objectValue;
		 String value;
		 double doubleValue;
		 objectValue = toPaint(elem, readInheritColorAttribute(elem, ""fill"", ""none""));
		 if (objectValue instanceof Color) {
			 FILL_COLOR.put(a, (Color) objectValue);
		 }
		 else if (objectValue instanceof Gradient) {
			 FILL_GRADIENT.putClone(a, (Gradient) objectValue);
		 }
		 else if (objectValue == null) {
			 FILL_COLOR.put(a, null);
		 }
		 else {
			 FILL_COLOR.put(a, null);
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat not implemented fill="" + objectValue);
			 }
		 }
		 objectValue = readInheritAttribute(elem, ""fill-opacity"", ""1"");
		 FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
		 value = readInheritAttribute(elem, ""fill-rule"", ""nonzero"");
		 WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
		 objectValue = toPaint(elem, readInheritColorAttribute(elem, ""stroke"", ""black""));
		 if (objectValue instanceof Color) {
			 STROKE_COLOR.put(a, (Color) objectValue);
		 }
		 else if (objectValue instanceof Gradient) {
			 STROKE_GRADIENT.putClone(a, (Gradient) objectValue);
		 }
		 else if (objectValue == null) {
			 STROKE_COLOR.put(a, null);
		 }
		 else {
			 STROKE_COLOR.put(a, null);
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat not implemented stroke="" + objectValue);
			 }
		 }
		 value = readInheritAttribute(elem, ""stroke-dasharray"", ""none"");
		 if (!value.equals(""none"")) {
			 String[] values = toWSOrCommaSeparatedArray(value);
			 double[] dashes = new double[values.length];
			 for (int i = 0;
			 i < values.length;
			 i++) {
				 dashes[i] = toNumber(elem, values[i]);
			 }
			 STROKE_DASHES.put(a, dashes);
		 }
		 doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-dashoffset"", ""0""));
		 STROKE_DASH_PHASE.put(a, doubleValue);
		 IS_STROKE_DASH_FACTOR.put(a, false);
		 value = readInheritAttribute(elem, ""stroke-linecap"", ""butt"");
		 STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));
		 value = readInheritAttribute(elem, ""stroke-linejoin"", ""miter"");
		 STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
		 doubleValue = toDouble(elem, readInheritAttribute(elem, ""stroke-miterlimit"", ""4""), 4d, 1d, Double.MAX_VALUE);
		 STROKE_MITER_LIMIT.put(a, doubleValue);
		 IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
		 objectValue = readInheritAttribute(elem, ""stroke-opacity"", ""1"");
		 STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
		 doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-width"", ""1""));
		 STROKE_WIDTH.put(a, doubleValue);
	 }
	 private void readViewportAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
		 Object value;
		 Double doubleValue;
		 value = readAttribute(elem, ""width"", null);
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat READ viewport w/h factors:"" + viewportStack.peek().widthPercentFactor + "","" + viewportStack.peek().heightPercentFactor);
		 }
		 if (value != null) {
			 doubleValue = toLength(elem, (String) value, viewportStack.peek().widthPercentFactor);
			 VIEWPORT_WIDTH.put(a, doubleValue);
		 }
		 value = readAttribute(elem, ""height"", null);
		 if (value != null) {
			 doubleValue = toLength(elem, (String) value, viewportStack.peek().heightPercentFactor);
			 VIEWPORT_HEIGHT.put(a, doubleValue);
		 }
		 value = toPaint(elem, readInheritColorAttribute(elem, ""viewport-fill"", ""none""));
		 if (value == null || (value instanceof Color)) {
			 VIEWPORT_FILL.put(a, (Color) value);
		 }
		 doubleValue = toDouble(elem, readAttribute(elem, ""viewport-fill-opacity"", ""1.0""));
		 VIEWPORT_FILL_OPACITY.put(a, doubleValue);
	 }
	 private void readGraphicsAttributes(IXMLElement elem, Figure f) throws IOException {
		 Object value;
		 value = readAttribute(elem, ""display"", ""inline"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented display="" + value);
		 }
		 value = readInheritAttribute(elem, ""image-rendering"", ""auto"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented image-rendering="" + value);
		 }
		 value = readInheritAttribute(elem, ""pointer-events"", ""visiblePainted"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented pointer-events="" + value);
		 }
		 value = readInheritAttribute(elem, ""shape-rendering"", ""auto"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented shape-rendering="" + value);
		 }
		 value = readInheritAttribute(elem, ""text-rendering"", ""auto"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented text-rendering="" + value);
		 }
		 value = readAttribute(elem, ""vector-effect"", ""none"");
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented vector-effect="" + value);
		 }
		 value = readInheritAttribute(elem, ""visibility"", null);
		 if (DEBUG) {
			 System.out.println(""SVGInputFormat not implemented visibility="" + value);
		 }
	 }
	 private void readLinearGradientElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 double x1 = toLength(elem, readAttribute(elem, ""x1"", ""0""), 0.01);
		 double y1 = toLength(elem, readAttribute(elem, ""y1"", ""0""), 0.01);
		 double x2 = toLength(elem, readAttribute(elem, ""x2"", ""1""), 0.01);
		 double y2 = toLength(elem, readAttribute(elem, ""y2"", ""0""), 0.01);
		 boolean isRelativeToFigureBounds = readAttribute(elem, ""gradientUnits"", ""objectBoundingBox"").equals(""objectBoundingBox"");
		 ArrayList<IXMLElement> stops = elem.getChildrenNamed(""stop"", SVG_NAMESPACE);
		 if (stops.size() == 0) {
			 stops = elem.getChildrenNamed(""stop"");
		 }
		 if (stops.size() == 0) {
			 String xlink = readAttribute(elem, ""xlink:href"", """");
			 if (xlink.startsWith(""#"") && identifiedElements.get(xlink.substring(1)) != null) {
				 stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"", SVG_NAMESPACE);
				 if (stops.size() == 0) {
					 stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"");
				 }
			 }
		 }
		 if (stops.size() == 0) {
			 if (DEBUG) {
				 System.out.println(""SVGInpuFormat: Warning no stops in linearGradient "" + elem);
			 }
		 }
		 double[] stopOffsets = new double[stops.size()];
		 Color[] stopColors = new Color[stops.size()];
		 double[] stopOpacities = new double[stops.size()];
		 for (int i = 0;
		 i < stops.size();
		 i++) {
			 IXMLElement stopElem = stops.get(i);
			 String offsetStr = readAttribute(stopElem, ""offset"", ""0"");
			 if (offsetStr.endsWith(""%"")) {
				 stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;
			 }
			 else {
				 stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);
			 }
			 stopColors[i] = toColor(stopElem, readAttribute(stopElem, ""stop-color"", ""black""));
			 if (stopColors[i] == null) {
				 stopColors[i] = new Color(0x0, true);
			 }
			 stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, ""stop-opacity"", ""1""), 1, 0, 1);
		 }
		 AffineTransform tx = toTransform(elem, readAttribute(elem, ""gradientTransform"", ""none""));
		 Gradient gradient = factory.createLinearGradient( x1, y1, x2, y2, stopOffsets, stopColors, stopOpacities, isRelativeToFigureBounds, tx);
		 elementObjects.put(elem, gradient);
	 }
	 private void readRadialGradientElement(IXMLElement elem) throws IOException {
		 HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
		 readCoreAttributes(elem, a);
		 double cx = toLength(elem, readAttribute(elem, ""cx"", ""0.5""), 0.01);
		 double cy = toLength(elem, readAttribute(elem, ""cy"", ""0.5""), 0.01);
		 double fx = toLength(elem, readAttribute(elem, ""fx"", readAttribute(elem, ""cx"", ""0.5"")), 0.01);
		 double fy = toLength(elem, readAttribute(elem, ""fy"", readAttribute(elem, ""cy"", ""0.5"")), 0.01);
		 double r = toLength(elem, readAttribute(elem, ""r"", ""0.5""), 0.01);
		 boolean isRelativeToFigureBounds = readAttribute(elem, ""gradientUnits"", ""objectBoundingBox"").equals(""objectBoundingBox"");
		 ArrayList<IXMLElement> stops = elem.getChildrenNamed(""stop"", SVG_NAMESPACE);
		 if (stops.size() == 0) {
			 stops = elem.getChildrenNamed(""stop"");
		 }
		 if (stops.size() == 0) {
			 String xlink = readAttribute(elem, ""xlink:href"", """");
			 if (xlink.startsWith(""#"") && identifiedElements.get(xlink.substring(1)) != null) {
				 stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"", SVG_NAMESPACE);
				 if (stops.size() == 0) {
					 stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"");
				 }
			 }
		 }
		 double[] stopOffsets = new double[stops.size()];
		 Color[] stopColors = new Color[stops.size()];
		 double[] stopOpacities = new double[stops.size()];
		 for (int i = 0;
		 i < stops.size();
		 i++) {
			 IXMLElement stopElem = stops.get(i);
			 String offsetStr = readAttribute(stopElem, ""offset"", ""0"");
			 if (offsetStr.endsWith(""%"")) {
				 stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;
			 }
			 else {
				 stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);
			 }
			 stopColors[i] = toColor(stopElem, readAttribute(stopElem, ""stop-color"", ""black""));
			 if (stopColors[i] == null) {
				 stopColors[i] = new Color(0x0, true);
			 }
			 stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, ""stop-opacity"", ""1""), 1, 0, 1);
		 }
		 AffineTransform tx = toTransform(elem, readAttribute(elem, ""gradientTransform"", ""none""));
		 Gradient gradient = factory.createRadialGradient( cx, cy, fx, fy, r, stopOffsets, stopColors, stopOpacities, isRelativeToFigureBounds, tx);
		 elementObjects.put(elem, gradient);
	 }
	 private void readFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a) throws IOException {
		 String value;
		 double doubleValue;
		 value = readInheritAttribute(elem, ""font-family"", ""Dialog"");
		 String[] familyNames = toQuotedAndCommaSeparatedArray(value);
		 Font font = null;
		 for (int i = 0;
		 i < familyNames.length;
		 i++) {
			 try {
				 font = (Font) fontFormatter.stringToValue(familyNames[i]);
				 break;
			 }
			 catch (ParseException e) {
			 }
		 }
		 if (font == null) {
			 if (familyNames.length > 0) {
				 fontFormatter.setAllowsUnknownFont(true);
				 try {
					 font = (Font) fontFormatter.stringToValue(familyNames[0]);
				 }
				 catch (ParseException e) {
				 }
				 fontFormatter.setAllowsUnknownFont(false);
			 }
		 }
		 if (font == null) {
			 font = new Font(""Dialog"", Font.PLAIN, 12);
		 }
		 FONT_FACE.put(a, font);
		 doubleValue = readInheritFontSizeAttribute(elem, ""font-size"", ""medium"");
		 FONT_SIZE.put(a, doubleValue);
		 value = readInheritAttribute(elem, ""font-style"", ""normal"");
		 FONT_ITALIC.put(a, value.equals(""italic""));
		 value = readInheritAttribute(elem, ""font-variant"", ""normal"");
		 value = readInheritAttribute(elem, ""font-weight"", ""normal"");
		 FONT_BOLD.put(a, value.equals(""bold"") || value.equals(""bolder"") || value.equals(""400"") || value.equals(""500"") || value.equals(""600"") || value.equals(""700"") || value.equals(""800"") || value.equals(""900""));
		 value = readAttribute(elem, ""text-decoration"", ""none"");
		 FONT_UNDERLINE.put(a, value.equals(""underline""));
	 }
	 private Object toPaint(IXMLElement elem, String value) throws IOException {
		 String str = value;
		 if (str == null) {
			 return null;
		 }
		 str = str.trim().toLowerCase();
		 if (str.equals(""none"")) {
			 return null;
		 }
		 else if (str.equals(""currentcolor"")) {
			 String currentColor = readInheritAttribute(elem, ""color"", ""black"");
			 if (currentColor == null || currentColor.trim().toLowerCase().equals(""currentColor"")) {
				 return null;
			 }
			 else {
				 return toPaint(elem, currentColor);
			 }
		 }
		 else if (SVG_COLORS.containsKey(str)) {
			 return SVG_COLORS.get(str);
		 }
		 else if (str.startsWith(""#"") && str.length() == 7) {
			 return new Color(Integer.decode(str));
		 }
		 else if (str.startsWith(""#"") && str.length() == 4) {
			 int th = Integer.decode(str);
			 return new Color( (th & 0xf) | ((th & 0xf) << 4) | ((th & 0xf0) << 4) | ((th & 0xf0) << 8) | ((th & 0xf00) << 8) | ((th & 0xf00) << 12));
		 }
		 else if (str.startsWith(""rgb"")) {
			 try {
				 StringTokenizer tt = new StringTokenizer(str, ""() ,"");
				 tt.nextToken();
				 String r = tt.nextToken();
				 String g = tt.nextToken();
				 String b = tt.nextToken();
				 Color c = new Color( r.endsWith(""%"") ? (int) (Double.parseDouble(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r), g.endsWith(""%"") ? (int) (Double.parseDouble(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g), b.endsWith(""%"") ? (int) (Double.parseDouble(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));
				 return c;
			 }
			 catch (Exception e) {
				 System.out.println(""SVGInputFormat.toPaint illegal RGB value "" + str);
				 e.printStackTrace();
				 return null;
			 }
		 }
		 else if (str.startsWith(""url("")) {
			 String href = value.substring(4, value.length() - 1);
			 if (identifiedElements.containsKey(href.substring(1)) && elementObjects.containsKey(identifiedElements.get(href.substring(1)))) {
				 Object obj = elementObjects.get(identifiedElements.get(href.substring(1)));
				 return obj;
			 }
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat.toPaint not implemented for "" + href);
			 }
			 return null;
		 }
		 else {
			 return null;
		 }
	 }
	 private Color toColor(IXMLElement elem, String value) throws IOException {
		 String str = value;
		 if (str == null) {
			 return null;
		 }
		 str = str.trim().toLowerCase();
		 if (str.equals(""currentcolor"")) {
			 String currentColor = readInheritAttribute(elem, ""color"", ""black"");
			 if (currentColor == null || currentColor.trim().toLowerCase().equals(""currentColor"")) {
				 return null;
			 }
			 else {
				 return toColor(elem, currentColor);
			 }
		 }
		 else if (SVG_COLORS.containsKey(str)) {
			 return SVG_COLORS.get(str);
		 }
		 else if (str.startsWith(""#"") && str.length() == 7) {
			 return new Color(Integer.decode(str));
		 }
		 else if (str.startsWith(""#"") && str.length() == 4) {
			 int th = Integer.decode(str);
			 return new Color( (th & 0xf) | ((th & 0xf) << 4) | ((th & 0xf0) << 4) | ((th & 0xf0) << 8) | ((th & 0xf00) << 8) | ((th & 0xf00) << 12));
		 }
		 else if (str.startsWith(""rgb"")) {
			 try {
				 StringTokenizer tt = new StringTokenizer(str, ""() ,"");
				 tt.nextToken();
				 String r = tt.nextToken();
				 String g = tt.nextToken();
				 String b = tt.nextToken();
				 Color c = new Color( r.endsWith(""%"") ? (int) (Integer.decode(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r), g.endsWith(""%"") ? (int) (Integer.decode(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g), b.endsWith(""%"") ? (int) (Integer.decode(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));
				 return c;
			 }
			 catch (Exception e) {
				 if (DEBUG) {
					 System.out.println(""SVGInputFormat.toColor illegal RGB value "" + str);
				 }
				 return null;
			 }
		 }
		 else if (str.startsWith(""url"")) {
			 if (DEBUG) {
				 System.out.println(""SVGInputFormat.toColor not implemented for "" + str);
			 }
			 return null;
		 }
		 else {
			 return null;
		 }
	 }
	 private double toDouble(IXMLElement elem, String value) throws IOException {
		 return toDouble(elem, value, 0, Double.MIN_VALUE, Double.MAX_VALUE);
	 }
	 private double toDouble(IXMLElement elem, String value, double defaultValue, double min, double max) throws IOException {
		 try {
			 double d = Double.valueOf(value);
			 return Math.max(Math.min(d, max), min);
		 }
		 catch (NumberFormatException e) {
			 return defaultValue;
		 }
	 }
	 private String toText(IXMLElement elem, String value) throws IOException {
		 String space = readInheritAttribute(elem, ""xml:space"", ""default"");
		 if (space.equals(""default"")) {
			 return value.trim().replaceAll(""\\s++"", "" "");
		 }
		 else {
			 return value;
		 }
	 }
	 public static AffineTransform toTransform(IXMLElement elem, String str) throws IOException {
		 AffineTransform t = new AffineTransform();
		 if (str != null && !str.equals(""none"")) {
			 StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
			 tt.resetSyntax();
			 tt.wordChars('a', 'z');
			 tt.wordChars('A', 'Z');
			 tt.wordChars(128 + 32, 255);
			 tt.whitespaceChars(0, ' ');
			 tt.whitespaceChars(',', ',');
			 tt.parseNumbers();
			 tt.parseExponents();
			 while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
				 if (tt.ttype != StreamPosTokenizer.TT_WORD) {
					 throw new IOException(""Illegal transform "" + str);
				 }
				 String type = tt.sval;
				 if (tt.nextToken() != '(') {
					 throw new IOException(""'(' not found in transform "" + str);
				 }
				 if (type.equals(""matrix"")) {
					 double[] m = new double[6];
					 for (int i = 0;
					 i < 6;
					 i++) {
						 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
							 throw new IOException(""Matrix value "" + i + "" not found in transform "" + str + "" token:"" + tt.ttype + "" "" + tt.sval);
						 }
						 m[i] = tt.nval;
					 }
					 t.concatenate(new AffineTransform(m));
				 }
				 else if (type.equals(""translate"")) {
					 double tx, ty;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""X-translation value not found in transform "" + str);
					 }
					 tx = tt.nval;
					 if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
						 ty = tt.nval;
					 }
					 else {
						 tt.pushBack();
						 ty = 0;
					 }
					 t.translate(tx, ty);
				 }
				 else if (type.equals(""scale"")) {
					 double sx, sy;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""X-scale value not found in transform "" + str);
					 }
					 sx = tt.nval;
					 if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
						 sy = tt.nval;
					 }
					 else {
						 tt.pushBack();
						 sy = sx;
					 }
					 t.scale(sx, sy);
				 }
				 else if (type.equals(""rotate"")) {
					 double angle, cx, cy;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""Angle value not found in transform "" + str);
					 }
					 angle = tt.nval;
					 if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
						 cx = tt.nval;
						 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
							 throw new IOException(""Y-center value not found in transform "" + str);
						 }
						 cy = tt.nval;
					 }
					 else {
						 tt.pushBack();
						 cx = cy = 0;
					 }
					 t.rotate(angle * Math.PI / 180d, cx, cy);
				 }
				 else if (type.equals(""skewX"")) {
					 double angle;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""Skew angle not found in transform "" + str);
					 }
					 angle = tt.nval;
					 t.concatenate(new AffineTransform( 1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));
				 }
				 else if (type.equals(""skewY"")) {
					 double angle;
					 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
						 throw new IOException(""Skew angle not found in transform "" + str);
					 }
					 angle = tt.nval;
					 t.concatenate(new AffineTransform( 1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));
				 }
				 else if (type.equals(""ref"")) {
					 System.err.println(""SVGInputFormat warning: ignored ref(...) transform attribute in element "" + elem);
					 while (tt.nextToken() != ')' && tt.ttype != StreamPosTokenizer.TT_EOF) {
					 }
					 tt.pushBack();
				 }
				 else {
					 throw new IOException(""Unknown transform "" + type + "" in "" + str + "" in element "" + elem);
				 }
				 if (tt.nextToken() != ')') {
					 throw new IOException(""')' not found in transform "" + str);
				 }
			 }
		 }
		 return t;
	 }
	 public javax.swing.filechooser.FileFilter getFileFilter() {
		 return new ExtensionFileFilter(""Scalable Vector Graphics (SVG)"", ""svg"");
	 }
	 public JComponent getInputFormatAccessory() {
		 return null;
	 }
	 public boolean isDataFlavorSupported(DataFlavor flavor) {
		 return flavor.getPrimaryType().equals(""image"") && flavor.getSubType().equals(""svg+xml"");
	 }
	 public void read(Transferable t, Drawing drawing, boolean replace) throws UnsupportedFlavorException, IOException {
		 InputStream in = (InputStream) t.getTransferData(new DataFlavor(""image/svg+xml"", ""Image SVG""));
		 try {
			 read(in, drawing, false);
		 }
		 finally {
			 in.close();
		 }
	 }
}",1,0,0,0
"public class NativeRegExp extends IdScriptableObject implements Function{
	 static final long serialVersionUID = 4965263491464903264L;
	 private static final Object REGEXP_TAG = new Object();
	 public static final int JSREG_GLOB = 0x1;
	 public static final int JSREG_FOLD = 0x2;
	 public static final int JSREG_MULTILINE = 0x4;
	 public static final int TEST = 0;
	 public static final int MATCH = 1;
	 public static final int PREFIX = 2;
	 private static final boolean debug = false;
	 private static final byte REOP_EMPTY = 0;
	 private static final byte REOP_ALT = 1;
	 private static final byte REOP_BOL = 2;
	 private static final byte REOP_EOL = 3;
	 private static final byte REOP_WBDRY = 4;
	 private static final byte REOP_WNONBDRY = 5;
	 private static final byte REOP_QUANT = 6;
	 private static final byte REOP_STAR = 7;
	 private static final byte REOP_PLUS = 8;
	 private static final byte REOP_OPT = 9;
	 private static final byte REOP_LPAREN = 10;
	 private static final byte REOP_RPAREN = 11;
	 private static final byte REOP_DOT = 12;
	 private static final byte REOP_CCLASS = 13;
	 private static final byte REOP_DIGIT = 14;
	 private static final byte REOP_NONDIGIT = 15;
	 private static final byte REOP_ALNUM = 16;
	 private static final byte REOP_NONALNUM = 17;
	 private static final byte REOP_SPACE = 18;
	 private static final byte REOP_NONSPACE = 19;
	 private static final byte REOP_BACKREF = 20;
	 private static final byte REOP_FLAT = 21;
	 private static final byte REOP_FLAT1 = 22;
	 private static final byte REOP_JUMP = 23;
	 private static final byte REOP_DOTSTAR = 24;
	 private static final byte REOP_ANCHOR = 25;
	 private static final byte REOP_EOLONLY = 26;
	 private static final byte REOP_UCFLAT = 27;
	 private static final byte REOP_UCFLAT1 = 28;
	 private static final byte REOP_UCCLASS = 29;
	 private static final byte REOP_NUCCLASS = 30;
	 private static final byte REOP_BACKREFi = 31;
	 private static final byte REOP_FLATi = 32;
	 private static final byte REOP_FLAT1i = 33;
	 private static final byte REOP_UCFLATi = 34;
	 private static final byte REOP_UCFLAT1i = 35;
	 private static final byte REOP_ANCHOR1 = 36;
	 private static final byte REOP_NCCLASS = 37;
	 private static final byte REOP_DOTSTARMIN = 38;
	 private static final byte REOP_LPARENNON = 39;
	 private static final byte REOP_RPARENNON = 40;
	 private static final byte REOP_ASSERT = 41;
	 private static final byte REOP_ASSERT_NOT = 42;
	 private static final byte REOP_ASSERTTEST = 43;
	 private static final byte REOP_ASSERTNOTTEST = 44;
	 private static final byte REOP_MINIMALSTAR = 45;
	 private static final byte REOP_MINIMALPLUS = 46;
	 private static final byte REOP_MINIMALOPT = 47;
	 private static final byte REOP_MINIMALQUANT = 48;
	 private static final byte REOP_ENDCHILD = 49;
	 private static final byte REOP_CLASS = 50;
	 private static final byte REOP_REPEAT = 51;
	 private static final byte REOP_MINIMALREPEAT = 52;
	 private static final byte REOP_END = 53;
	 public static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeRegExp proto = new NativeRegExp();
		 proto.re = (RECompiled)compileRE("""", null, false);
		 proto.activatePrototypeMap(MAX_PROTOTYPE_ID);
		 proto.setParentScope(scope);
		 proto.setPrototype(getObjectPrototype(scope));
		 NativeRegExpCtor ctor = new NativeRegExpCtor();
		 ScriptRuntime.setFunctionProtoAndParent(ctor, scope);
		 ctor.setImmunePrototypeProperty(proto);
		 if (sealed) {
			 proto.sealObject();
			 ctor.sealObject();
		 }
		 defineProperty(scope, ""RegExp"", ctor, ScriptableObject.DONTENUM);
	 }
	 NativeRegExp(Scriptable scope, Object regexpCompiled) {
		 this.re = (RECompiled)regexpCompiled;
		 this.lastIndex = 0;
		 ScriptRuntime.setObjectProtoAndParent(this, scope);
	 }
	 public String getClassName() {
		 return ""RegExp"";
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return execSub(cx, scope, args, MATCH);
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 return (Scriptable)execSub(cx, scope, args, MATCH);
	 }
	 Scriptable compile(Context cx, Scriptable scope, Object[] args) {
		 if (args.length > 0 && args[0] instanceof NativeRegExp) {
			 if (args.length > 1 && args[1] != Undefined.instance) {
				 throw ScriptRuntime.typeError0(""msg.bad.regexp.compile"");
			 }
			 NativeRegExp thatObj = (NativeRegExp) args[0];
			 this.re = thatObj.re;
			 this.lastIndex = thatObj.lastIndex;
			 return this;
		 }
		 String s = args.length == 0 ? """" : ScriptRuntime.toString(args[0]);
		 String global = args.length > 1 && args[1] != Undefined.instance ? ScriptRuntime.toString(args[1]) : null;
		 this.re = (RECompiled)compileRE(s, global, false);
		 this.lastIndex = 0;
		 return this;
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 buf.append('/');
		 if (re.source.length != 0) {
			 buf.append(re.source);
		 }
		 else {
			 buf.append(""(?:)"");
		 }
		 buf.append('/');
		 if ((re.flags & JSREG_GLOB) != 0) buf.append('g');
		 if ((re.flags & JSREG_FOLD) != 0) buf.append('i');
		 if ((re.flags & JSREG_MULTILINE) != 0) buf.append('m');
		 return buf.toString();
	 }
	 NativeRegExp() {
	 }
	 private static RegExpImpl getImpl(Context cx) {
		 return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);
	 }
	 private Object execSub(Context cx, Scriptable scopeObj, Object[] args, int matchType) {
		 RegExpImpl reImpl = getImpl(cx);
		 String str;
		 if (args.length == 0) {
			 str = reImpl.input;
			 if (str == null) {
				 reportError(""msg.no.re.input.for"", toString());
			 }
		 }
		 else {
			 str = ScriptRuntime.toString(args[0]);
		 }
		 double d = ((re.flags & JSREG_GLOB) != 0) ? lastIndex : 0;
		 Object rval;
		 if (d < 0 || str.length() < d) {
			 lastIndex = 0;
			 rval = null;
		 }
		 else {
			 int indexp[] = {
			 (int)d }
			;
			 rval = executeRegExp(cx, scopeObj, reImpl, str, indexp, matchType);
			 if ((re.flags & JSREG_GLOB) != 0) {
				 lastIndex = (rval == null || rval == Undefined.instance) ? 0 : indexp[0];
			 }
		 }
		 return rval;
	 }
	 static Object compileRE(String str, String global, boolean flat) {
		 RECompiled regexp = new RECompiled();
		 regexp.source = str.toCharArray();
		 int length = str.length();
		 int flags = 0;
		 if (global != null) {
			 for (int i = 0;
			 i < global.length();
			 i++) {
				 char c = global.charAt(i);
				 if (c == 'g') {
					 flags |= JSREG_GLOB;
				 }
				 else if (c == 'i') {
					 flags |= JSREG_FOLD;
				 }
				 else if (c == 'm') {
					 flags |= JSREG_MULTILINE;
				 }
				 else {
					 reportError(""msg.invalid.re.flag"", String.valueOf(c));
				 }
			 }
		 }
		 regexp.flags = flags;
		 CompilerState state = new CompilerState(regexp.source, length, flags);
		 if (flat && length > 0) {
			if (debug) {
				System.out.println(""flat = \"""" + str + ""\"""");
			}
			 state.result = new RENode(REOP_FLAT);
			 state.result.chr = state.cpbegin[0];
			 state.result.length = length;
			 state.result.flatIndex = 0;
			 state.progLength += 5;
		 }
		 else if (!parseDisjunction(state)) return null;
		 regexp.program = new byte[state.progLength + 1];
		 if (state.classCount != 0) {
			 regexp.classList = new RECharSet[state.classCount];
			 regexp.classCount = state.classCount;
		 }
		 int endPC = emitREBytecode(state, regexp, 0, state.result);
		 regexp.program[endPC++] = REOP_END;
		if (debug) {
			System.out.println(""Prog. length = "" + endPC);
			for (int i = 0;
			 i < endPC;
			 i++) {
				 System.out.print(regexp.program[i]);
				 if (i < (endPC - 1)) System.out.print("", "");
			}
			System.out.println();
		}
		 regexp.parenCount = state.parenCount;
		 switch (regexp.program[0]) {
			 case REOP_UCFLAT1: case REOP_UCFLAT1i: regexp.anchorCh = (char)getIndex(regexp.program, 1);
			 break;
			 case REOP_FLAT1: case REOP_FLAT1i: regexp.anchorCh = (char)(regexp.program[1] & 0xFF);
			 break;
			 case REOP_FLAT: case REOP_FLATi: int k = getIndex(regexp.program, 1);
			 regexp.anchorCh = regexp.source[k];
			 break;
		 }
		if (debug) {
			if (regexp.anchorCh >= 0) {
				 System.out.println(""Anchor ch = '"" + (char)regexp.anchorCh + ""'"");
			}
		}
		 return regexp;
	 }
	 static boolean isDigit(char c) {
		 return '0' <= c && c <= '9';
	 }
	 private static boolean isWord(char c) {
		 return Character.isLetter(c) || isDigit(c) || c == '_';
	 }
	 private static boolean isLineTerm(char c) {
		 return ScriptRuntime.isJSLineTerminator(c);
	 }
	 private static boolean isREWhiteSpace(int c) {
		 return (c == '\u0020' || c == '\u0009' || c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029 || c == '\u000C' || c == '\u000B' || c == '\u00A0' || Character.getType((char)c) == Character.SPACE_SEPARATOR);
	 }
	 private static char upcase(char ch) {
		 if (ch < 128) {
			 if ('a' <= ch && ch <= 'z') {
				 return (char)(ch + ('A' - 'a'));
			 }
			 return ch;
		 }
		 char cu = Character.toUpperCase(ch);
		 if ((ch >= 128) && (cu < 128)) return ch;
		 return cu;
	 }
	 private static char downcase(char ch) {
		 if (ch < 128) {
			 if ('A' <= ch && ch <= 'Z') {
				 return (char)(ch + ('a' - 'A'));
			 }
			 return ch;
		 }
		 char cl = Character.toLowerCase(ch);
		 if ((ch >= 128) && (cl < 128)) return ch;
		 return cl;
	 }
	 private static int toASCIIHexDigit(int c) {
		 if (c < '0') return -1;
		 if (c <= '9') {
			 return c - '0';
		 }
		 c |= 0x20;
		 if ('a' <= c && c <= 'f') {
			 return c - 'a' + 10;
		 }
		 return -1;
	 }
	 private static boolean parseDisjunction(CompilerState state) {
		 if (!parseAlternative(state)) return false;
		 char[] source = state.cpbegin;
		 int index = state.cp;
		 if (index != source.length && source[index] == '|') {
			 RENode altResult;
			 ++state.cp;
			 altResult = new RENode(REOP_ALT);
			 altResult.kid = state.result;
			 if (!parseDisjunction(state)) return false;
			 altResult.kid2 = state.result;
			 state.result = altResult;
			 state.progLength += 9;
		 }
		 return true;
	 }
	 private static boolean parseAlternative(CompilerState state) {
		 RENode headTerm = null;
		 RENode tailTerm = null;
		 char[] source = state.cpbegin;
		 while (true) {
			 if (state.cp == state.cpend || source[state.cp] == '|' || (state.parenNesting != 0 && source[state.cp] == ')')) {
				 if (headTerm == null) {
					 state.result = new RENode(REOP_EMPTY);
				 }
				 else state.result = headTerm;
				 return true;
			 }
			 if (!parseTerm(state)) return false;
			 if (headTerm == null) headTerm = state.result;
			 else {
				 if (tailTerm == null) {
					 headTerm.next = state.result;
					 tailTerm = state.result;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
				 else {
					 tailTerm.next = state.result;
					 tailTerm = tailTerm.next;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
			 }
		 }
	 }
	 private static boolean calculateBitmapSize(CompilerState state, RENode target, char[] src, int index, int end) {
		 char rangeStart = 0;
		 char c;
		 int n;
		 int digit;
		 int nDigits;
		 int i;
		 int max = 0;
		 boolean inRange = false;
		 target.bmsize = 0;
		 if (index == end) return true;
		 if (src[index] == '^') ++index;
		 while (index != end) {
			 int localMax = 0;
			 nDigits = 2;
			 switch (src[index]) {
				 case '\\': ++index;
				 c = src[index++];
				 switch (c) {
					 case 'b': localMax = 0x8;
					 break;
					 case 'f': localMax = 0xC;
					 break;
					 case 'n': localMax = 0xA;
					 break;
					 case 'r': localMax = 0xD;
					 break;
					 case 't': localMax = 0x9;
					 break;
					 case 'v': localMax = 0xB;
					 break;
					 case 'c': if (((index + 1) < end) && Character.isLetter(src[index + 1])) localMax = (char)(src[index++] & 0x1F);
					 else localMax = '\\';
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (index < end);
					 i++) {
						 c = src[index++];
						 n = Kit.xDigitToInt(c, n);
						 if (n < 0) {
							 index -= (i + 1);
							 n = '\\';
							 break;
						 }
					 }
					 localMax = n;
					 break;
					 case 'd': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 localMax = '9';
					 break;
					 case 'D': case 's': case 'S': case 'w': case 'W': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 target.bmsize = 65535;
					 return true;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = src[index];
					 if ('0' <= c && c <= '7') {
						 index++;
						 n = 8 * n + (c - '0');
						 c = src[index];
						 if ('0' <= c && c <= '7') {
							 index++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else index--;
						 }
					 }
					 localMax = n;
					 break;
					 default: localMax = c;
					 break;
				 }
				 break;
				 default: localMax = src[index++];
				 break;
			 }
			 if (inRange) {
				 if (rangeStart > localMax) {
					 reportError(""msg.bad.range"", """");
					 return false;
				 }
				 inRange = false;
			 }
			 else {
				 if (index < (end - 1)) {
					 if (src[index] == '-') {
						 ++index;
						 inRange = true;
						 rangeStart = (char)localMax;
						 continue;
					 }
				 }
			 }
			 if ((state.flags & JSREG_FOLD) != 0){
				 char cu = upcase((char)localMax);
				 char cd = downcase((char)localMax);
				 localMax = (cu >= cd) ? cu : cd;
			 }
			 if (localMax > max) max = localMax;
		 }
		 target.bmsize = max;
		 return true;
	 }
	 private static void doFlat(CompilerState state, char c) {
		 state.result = new RENode(REOP_FLAT);
		 state.result.chr = c;
		 state.result.length = 1;
		 state.result.flatIndex = -1;
		 state.progLength += 3;
	 }
	 private static int getDecimalValue(char c, CompilerState state, int maxValue, String overflowMessageId) {
		 boolean overflow = false;
		 int start = state.cp;
		 char[] src = state.cpbegin;
		 int value = c - '0';
		 for (;
		 state.cp != state.cpend;
		 ++state.cp) {
			 c = src[state.cp];
			 if (!isDigit(c)) {
				 break;
			 }
			 if (!overflow) {
				 int digit = c - '0';
				 if (value < (maxValue - digit) / 10) {
					 value = value * 10 + digit;
				 }
				 else {
					 overflow = true;
					 value = maxValue;
				 }
			 }
		 }
		 if (overflow) {
			 reportError(overflowMessageId, String.valueOf(src, start, state.cp - start));
		 }
		 return value;
	 }
	 private static boolean parseTerm(CompilerState state) {
		 char[] src = state.cpbegin;
		 char c = src[state.cp++];
		 int nDigits = 2;
		 int parenBaseCount = state.parenCount;
		 int num, tmp;
		 RENode term;
		 int termStart;
		 int ocp = state.cp;
		 switch (c) {
			 case '^': state.result = new RENode(REOP_BOL);
			 state.progLength++;
			 return true;
			 case '$': state.result = new RENode(REOP_EOL);
			 state.progLength++;
			 return true;
			 case '\\': if (state.cp < state.cpend) {
				 c = src[state.cp++];
				 switch (c) {
					 case 'b' : state.result = new RENode(REOP_WBDRY);
					 state.progLength++;
					 return true;
					 case 'B': state.result = new RENode(REOP_WNONBDRY);
					 state.progLength++;
					 return true;
					 case '0': num = 0;
					 while (state.cp < state.cpend) {
						 c = src[state.cp];
						 if ((c >= '0') && (c <= '7')) {
							 state.cp++;
							 tmp = 8 * num + (c - '0');
							 if (tmp > 0377) break;
							 num = tmp;
						 }
						 else break;
					 }
					 c = (char)(num);
					 doFlat(state, c);
					 break;
					 case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': termStart = state.cp - 1;
					 num = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.backref"");
					 if ((num > 9) && (num > state.parenCount)) {
						 state.cp = termStart;
						 num = 0;
						 while (state.cp < state.cpend) {
							 c = src[state.cp];
							 if ((c >= '0') && (c <= '7')) {
								 state.cp++;
								 tmp = 8 * num + (c - '0');
								 if (tmp > 0377) break;
								 num = tmp;
							 }
							 else break;
						 }
						 c = (char)(num);
						 doFlat(state, c);
						 break;
					 }
					 state.result = new RENode(REOP_BACKREF);
					 state.result.parenIndex = num - 1;
					 state.progLength += 3;
					 break;
					 case 'f': c = 0xC;
					 doFlat(state, c);
					 break;
					 case 'n': c = 0xA;
					 doFlat(state, c);
					 break;
					 case 'r': c = 0xD;
					 doFlat(state, c);
					 break;
					 case 't': c = 0x9;
					 doFlat(state, c);
					 break;
					 case 'v': c = 0xB;
					 doFlat(state, c);
					 break;
					 case 'c': if (((state.cp + 1) < state.cpend) && Character.isLetter(src[state.cp + 1])) c = (char)(src[state.cp++] & 0x1F);
					 else {
						 --state.cp;
						 c = '\\';
					 }
					 doFlat(state, c);
					 break;
					 case 'u': nDigits += 2;
					 case 'x': {
						 int n = 0;
						 int i;
						 for (i = 0;
						 (i < nDigits) && (state.cp < state.cpend);
						 i++) {
							 int digit;
							 c = src[state.cp++];
							 n = Kit.xDigitToInt(c, n);
							 if (n < 0) {
								 state.cp -= (i + 2);
								 n = src[state.cp++];
								 break;
							 }
						 }
						 c = (char)(n);
					 }
					 doFlat(state, c);
					 break;
					 case 'd': state.result = new RENode(REOP_DIGIT);
					 state.progLength++;
					 break;
					 case 'D': state.result = new RENode(REOP_NONDIGIT);
					 state.progLength++;
					 break;
					 case 's': state.result = new RENode(REOP_SPACE);
					 state.progLength++;
					 break;
					 case 'S': state.result = new RENode(REOP_NONSPACE);
					 state.progLength++;
					 break;
					 case 'w': state.result = new RENode(REOP_ALNUM);
					 state.progLength++;
					 break;
					 case 'W': state.result = new RENode(REOP_NONALNUM);
					 state.progLength++;
					 break;
					 default: state.result = new RENode(REOP_FLAT);
					 state.result.chr = c;
					 state.result.length = 1;
					 state.result.flatIndex = state.cp - 1;
					 state.progLength += 3;
					 break;
				 }
				 break;
			 }
			 else {
				 reportError(""msg.trail.backslash"", """");
				 return false;
			 }
			 case '(': {
				 RENode result = null;
				 termStart = state.cp;
				 if (state.cp + 1 < state.cpend && src[state.cp] == '?' && ((c = src[state.cp + 1]) == '=' || c == '!' || c == ':')) {
					 state.cp += 2;
					 if (c == '=') {
						 result = new RENode(REOP_ASSERT);
						 state.progLength += 4;
					 }
					 else if (c == '!') {
						 result = new RENode(REOP_ASSERT_NOT);
						 state.progLength += 4;
					 }
				 }
				 else {
					 result = new RENode(REOP_LPAREN);
					 state.progLength += 6;
					 result.parenIndex = state.parenCount++;
				 }
				 ++state.parenNesting;
				 if (!parseDisjunction(state)) return false;
				 if (state.cp == state.cpend || src[state.cp] != ')') {
					 reportError(""msg.unterm.paren"", """");
					 return false;
				 }
				 ++state.cp;
				 --state.parenNesting;
				 if (result != null) {
					 result.kid = state.result;
					 state.result = result;
				 }
				 break;
			 }
			 case ')': reportError(""msg.re.unmatched.right.paren"", """");
			 return false;
			 case '[': state.result = new RENode(REOP_CLASS);
			 termStart = state.cp;
			 state.result.startIndex = termStart;
			 while (true) {
				 if (state.cp == state.cpend) {
					 reportError(""msg.unterm.class"", """");
					 return false;
				 }
				 if (src[state.cp] == '\\') state.cp++;
				 else {
					 if (src[state.cp] == ']') {
						 state.result.kidlen = state.cp - termStart;
						 break;
					 }
				 }
				 state.cp++;
			 }
			 state.result.index = state.classCount++;
			 if (!calculateBitmapSize(state, state.result, src, termStart, state.cp++)) return false;
			 state.progLength += 3;
			 break;
			 case '.': state.result = new RENode(REOP_DOT);
			 state.progLength++;
			 break;
			 case '*': case '+': case '?': reportError(""msg.bad.quant"", String.valueOf(src[state.cp - 1]));
			 return false;
			 default: state.result = new RENode(REOP_FLAT);
			 state.result.chr = c;
			 state.result.length = 1;
			 state.result.flatIndex = state.cp - 1;
			 state.progLength += 3;
			 break;
		 }
		 term = state.result;
		 if (state.cp == state.cpend) {
			 return true;
		 }
		 boolean hasQ = false;
		 switch (src[state.cp]) {
			 case '+': state.result = new RENode(REOP_QUANT);
			 state.result.min = 1;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '*': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '?': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = 1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '{
				': {
					 int min = 0;
					 int max = -1;
					 int leftCurl = state.cp;
					 c = src[++state.cp];
					 if (isDigit(c)) {
						 ++state.cp;
						 min = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.min"");
						 c = src[state.cp];
						 if (c == ',') {
							 c = src[++state.cp];
							 if (isDigit(c)) {
								 ++state.cp;
								 max = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.max"");
								 c = src[state.cp];
								 if (min > max) {
									 reportError(""msg.max.lt.min"", String.valueOf(src[state.cp]));
									 return false;
								 }
							 }
						 }
						 else {
							 max = min;
						 }
					 if (c == '}
					') {
						 state.result = new RENode(REOP_QUANT);
						 state.result.min = min;
						 state.result.max = max;
						 state.progLength += 12;
						 hasQ = true;
					 }
				 }
				 if (!hasQ) {
					 state.cp = leftCurl;
				 }
				 break;
			 }
		 }
		 if (!hasQ) return true;
		 ++state.cp;
		 state.result.kid = term;
		 state.result.parenIndex = parenBaseCount;
		 state.result.parenCount = state.parenCount - parenBaseCount;
		 if ((state.cp < state.cpend) && (src[state.cp] == '?')) {
			 ++state.cp;
			 state.result.greedy = false;
		 }
		 else state.result.greedy = true;
		 return true;
	 }
	 private static void resolveForwardJump(byte[] array, int from, int pc) {
		 if (from > pc) throw Kit.codeBug();
		 addIndex(array, from, pc - from);
	 }
	 private static int getOffset(byte[] array, int pc) {
		 return getIndex(array, pc);
	 }
	 private static int addIndex(byte[] array, int pc, int index) {
		 if (index < 0) throw Kit.codeBug();
		 if (index > 0xFFFF) throw Context.reportRuntimeError(""Too complex regexp"");
		 array[pc] = (byte)(index >> 8);
		 array[pc + 1] = (byte)(index);
		 return pc + 2;
	 }
	 private static int getIndex(byte[] array, int pc) {
		 return ((array[pc] & 0xFF) << 8) | (array[pc + 1] & 0xFF);
	 }
	 private static final int OFFSET_LEN = 2;
	 private static final int INDEX_LEN = 2;
	 private static int emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t) {
		 RENode nextAlt;
		 int nextAltFixup, nextTermFixup;
		 byte[] program = re.program;
		 while (t != null) {
			 program[pc++] = t.op;
			 switch (t.op) {
				 case REOP_EMPTY: --pc;
				 break;
				 case REOP_ALT: nextAlt = t.kid2;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_JUMP;
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextAltFixup, pc);
				 pc = emitREBytecode(state, re, pc, nextAlt);
				 program[pc++] = REOP_JUMP;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextTermFixup, pc);
				 resolveForwardJump(program, nextAltFixup, pc);
				 break;
				 case REOP_FLAT: if (t.flatIndex != -1) {
					 while ((t.next != null) && (t.next.op == REOP_FLAT) && ((t.flatIndex + t.length) == t.next.flatIndex)) {
						 t.length += t.next.length;
						 t.next = t.next.next;
					 }
				 }
				 if ((t.flatIndex != -1) && (t.length > 1)) {
					 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLATi;
					 else program[pc - 1] = REOP_FLAT;
					 pc = addIndex(program, pc, t.flatIndex);
					 pc = addIndex(program, pc, t.length);
				 }
				 else {
					 if (t.chr < 256) {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLAT1i;
						 else program[pc - 1] = REOP_FLAT1;
						 program[pc++] = (byte)(t.chr);
					 }
					 else {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_UCFLAT1i;
						 else program[pc - 1] = REOP_UCFLAT1;
						 pc = addIndex(program, pc, t.chr);
					 }
				 }
				 break;
				 case REOP_LPAREN: pc = addIndex(program, pc, t.parenIndex);
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_RPAREN;
				 pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_BACKREF: pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_ASSERT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_ASSERT_NOT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTNOTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_QUANT: if ((t.min == 0) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
				 else if ((t.min == 0) && (t.max == 1)) program[pc - 1] = (t.greedy) ? REOP_OPT : REOP_MINIMALOPT;
				 else if ((t.min == 1) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
				 else {
					 if (!t.greedy) program[pc - 1] = REOP_MINIMALQUANT;
					 pc = addIndex(program, pc, t.min);
					 pc = addIndex(program, pc, t.max + 1);
				 }
				 pc = addIndex(program, pc, t.parenCount);
				 pc = addIndex(program, pc, t.parenIndex);
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ENDCHILD;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_CLASS: pc = addIndex(program, pc, t.index);
				 re.classList[t.index] = new RECharSet(t.bmsize, t.startIndex, t.kidlen);
				 break;
				 default: break;
			 }
			 t = t.next;
		 }
		 return pc;
	 }
	 private static void pushProgState(REGlobalData gData, int min, int max, REBackTrackData backTrackLastToSave, int continuation_pc, int continuation_op) {
		 gData.stateStackTop = new REProgState(gData.stateStackTop, min, max, gData.cp, backTrackLastToSave, continuation_pc, continuation_op);
	 }
	 private static REProgState popProgState(REGlobalData gData) {
		 REProgState state = gData.stateStackTop;
		 gData.stateStackTop = state.previous;
		 return state;
	 }
	 private static void pushBackTrackState(REGlobalData gData, byte op, int target) {
		 gData.backTrackStackTop = new REBackTrackData(gData, op, target);
	 }
	 private static boolean flatNMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (gData.regexp.source[matchChars + i] != chars[gData.cp + i]) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean flatNIMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (upcase(gData.regexp.source[matchChars + i]) != upcase(chars[gData.cp + i])) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean backrefMatcher(REGlobalData gData, int parenIndex, char[] chars, int end) {
		 int len;
		 int i;
		 int parenContent = gData.parens_index(parenIndex);
		 if (parenContent == -1) return true;
		 len = gData.parens_length(parenIndex);
		 if ((gData.cp + len) > end) return false;
		 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (upcase(chars[parenContent + i]) != upcase(chars[gData.cp + i])) return false;
			 }
		 }
		 else {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (chars[parenContent + i] != chars[gData.cp + i]) return false;
			 }
		 }
		 gData.cp += len;
		 return true;
	 }
	 private static void addCharacterToCharSet(RECharSet cs, char c) {
		 int byteIndex = (int)(c / 8);
		 if (c > cs.length) throw new RuntimeException();
		 cs.bits[byteIndex] |= 1 << (c & 0x7);
	 }
	 private static void addCharacterRangeToCharSet(RECharSet cs, char c1, char c2) {
		 int i;
		 int byteIndex1 = (int)(c1 / 8);
		 int byteIndex2 = (int)(c2 / 8);
		 if ((c2 > cs.length) || (c1 > c2)) throw new RuntimeException();
		 c1 &= 0x7;
		 c2 &= 0x7;
		 if (byteIndex1 == byteIndex2) {
			 cs.bits[byteIndex1] |= ((int)(0xFF) >> (7 - (c2 - c1))) << c1;
		 }
		 else {
			 cs.bits[byteIndex1] |= 0xFF << c1;
			 for (i = byteIndex1 + 1;
			 i < byteIndex2;
			 i++) cs.bits[i] = (byte)0xFF;
			 cs.bits[byteIndex2] |= (int)(0xFF) >> (7 - c2);
		 }
	 }
	 private static void processCharSet(REGlobalData gData, RECharSet charSet) {
		 synchronized (charSet) {
			 if (!charSet.converted) {
				 processCharSetImpl(gData, charSet);
				 charSet.converted = true;
			 }
		 }
	 }
	 private static void processCharSetImpl(REGlobalData gData, RECharSet charSet) {
		 int src = charSet.startIndex;
		 int end = src + charSet.strlength;
		 char rangeStart = 0, thisCh;
		 int byteLength;
		 char c;
		 int n;
		 int nDigits;
		 int i;
		 boolean inRange = false;
		 charSet.sense = true;
		 byteLength = (charSet.length / 8) + 1;
		 charSet.bits = new byte[byteLength];
		 if (src == end) return;
		 if (gData.regexp.source[src] == '^') {
			 charSet.sense = false;
			 ++src;
		 }
		 while (src != end) {
			 nDigits = 2;
			 switch (gData.regexp.source[src]) {
				 case '\\': ++src;
				 c = gData.regexp.source[src++];
				 switch (c) {
					 case 'b': thisCh = 0x8;
					 break;
					 case 'f': thisCh = 0xC;
					 break;
					 case 'n': thisCh = 0xA;
					 break;
					 case 'r': thisCh = 0xD;
					 break;
					 case 't': thisCh = 0x9;
					 break;
					 case 'v': thisCh = 0xB;
					 break;
					 case 'c': if (((src + 1) < end) && isWord(gData.regexp.source[src + 1])) thisCh = (char)(gData.regexp.source[src++] & 0x1F);
					 else {
						 --src;
						 thisCh = '\\';
					 }
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (src < end);
					 i++) {
						 c = gData.regexp.source[src++];
						 int digit = toASCIIHexDigit(c);
						 if (digit < 0) {
							 src -= (i + 1);
							 n = '\\';
							 break;
						 }
						 n = (n << 4) | digit;
					 }
					 thisCh = (char)(n);
					 break;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = gData.regexp.source[src];
					 if ('0' <= c && c <= '7') {
						 src++;
						 n = 8 * n + (c - '0');
						 c = gData.regexp.source[src];
						 if ('0' <= c && c <= '7') {
							 src++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else src--;
						 }
					 }
					 thisCh = (char)(n);
					 break;
					 case 'd': addCharacterRangeToCharSet(charSet, '0', '9');
					 continue;
					 case 'D': addCharacterRangeToCharSet(charSet, (char)0, (char)('0' - 1));
					 addCharacterRangeToCharSet(charSet, (char)('9' + 1), (char)(charSet.length));
					 continue;
					 case 's': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'S': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (!isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'w': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'W': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (!isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 default: thisCh = c;
					 break;
				 }
				 break;
				 default: thisCh = gData.regexp.source[src++];
				 break;
			 }
			 if (inRange) {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterRangeToCharSet(charSet, upcase(rangeStart), upcase(thisCh));
					 addCharacterRangeToCharSet(charSet, downcase(rangeStart), downcase(thisCh));
				 }
				 else {
					 addCharacterRangeToCharSet(charSet, rangeStart, thisCh);
				 }
				 inRange = false;
			 }
			 else {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterToCharSet(charSet, upcase(thisCh));
					 addCharacterToCharSet(charSet, downcase(thisCh));
				 }
				 else {
					 addCharacterToCharSet(charSet, thisCh);
				 }
				 if (src < (end - 1)) {
					 if (gData.regexp.source[src] == '-') {
						 ++src;
						 inRange = true;
						 rangeStart = thisCh;
					 }
				 }
			 }
		 }
	 }
	 private static boolean classMatcher(REGlobalData gData, RECharSet charSet, char ch) {
		 if (!charSet.converted) {
			 processCharSet(gData, charSet);
		 }
		 int byteIndex = ch / 8;
		 if (charSet.sense) {
			 if ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) )) return false;
		 }
		 else {
			 if (! ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) ))) return false;
		 }
		 return true;
	 }
	 private static boolean executeREBytecode(REGlobalData gData, char[] chars, int end) {
		 int pc = 0;
		 byte program[] = gData.regexp.program;
		 int currentContinuation_op;
		 int currentContinuation_pc;
		 boolean result = false;
		 currentContinuation_pc = 0;
		 currentContinuation_op = REOP_END;
		if (debug) {
			System.out.println(""Input = \"""" + new String(chars) + ""\"", start at "" + gData.cp);
		}
		 int op = program[pc++];
		 for (;
		;
		) {
			if (debug) {
				System.out.println(""Testing at "" + gData.cp + "", op = "" + op);
			}
			 switch (op) {
				 case REOP_EMPTY: result = true;
				 break;
				 case REOP_BOL: if (gData.cp != 0) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp - 1])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_EOL: if (gData.cp != end) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_WBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ !((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_WNONBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ ((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_DOT: result = (gData.cp != end && !isLineTerm(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_DIGIT: result = (gData.cp != end && isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONDIGIT: result = (gData.cp != end && !isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_SPACE: result = (gData.cp != end && isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONSPACE: result = (gData.cp != end && !isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_ALNUM: result = (gData.cp != end && isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONALNUM: result = (gData.cp != end && !isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_FLAT: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLATi: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNIMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLAT1: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_FLAT1i: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1i: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_ALT: {
					 int nextpc;
					 byte nextop;
					 pushProgState(gData, 0, 0, null, currentContinuation_pc, currentContinuation_op);
					 nextpc = pc + getOffset(program, pc);
					 nextop = program[nextpc++];
					 pushBackTrackState(gData, nextop, nextpc);
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_JUMP: {
					 int offset;
					 REProgState state = popProgState(gData);
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 offset = getOffset(program, pc);
					 pc += offset;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_LPAREN: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 gData.set_parens(parenIndex, gData.cp, 0);
					 op = program[pc++];
				 }
				 continue;
				 case REOP_RPAREN: {
					 int cap_index;
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 cap_index = gData.parens_index(parenIndex);
					 gData.set_parens(parenIndex, cap_index, gData.cp - cap_index);
					 if (parenIndex > gData.lastParen) gData.lastParen = parenIndex;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_BACKREF: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = backrefMatcher(gData, parenIndex, chars, end);
				 }
				 break;
				 case REOP_CLASS: {
					 int index = getIndex(program, pc);
					 pc += INDEX_LEN;
					 if (gData.cp != end) {
						 if (classMatcher(gData, gData.regexp.classList[index], chars[gData.cp])) {
							 gData.cp++;
							 result = true;
							 break;
						 }
					 }
					 result = false;
				 }
				 break;
				 case REOP_ASSERT: case REOP_ASSERT_NOT: {
					 byte testOp;
					 pushProgState(gData, 0, 0, gData.backTrackStackTop, currentContinuation_pc, currentContinuation_op);
					 if (op == REOP_ASSERT) {
						 testOp = REOP_ASSERTTEST;
					 }
					 else {
						 testOp = REOP_ASSERTNOTTEST;
					 }
					 pushBackTrackState(gData, testOp, pc + getOffset(program, pc));
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_ASSERTTEST: case REOP_ASSERTNOTTEST: {
					 REProgState state = popProgState(gData);
					 gData.cp = state.index;
					 gData.backTrackStackTop = state.backTrack;
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 if (result) {
						 if (op == REOP_ASSERTTEST) {
							 result = true;
						 }
						 else {
							 result = false;
						 }
					 }
					 else {
						 if (op == REOP_ASSERTTEST) {
						 }
						 else {
							 result = true;
						 }
					 }
				 }
				 break;
				 case REOP_STAR: case REOP_PLUS: case REOP_OPT: case REOP_QUANT: case REOP_MINIMALSTAR: case REOP_MINIMALPLUS: case REOP_MINIMALOPT: case REOP_MINIMALQUANT: {
					 int min, max;
					 boolean greedy = false;
					 switch (op) {
						 case REOP_STAR: greedy = true;
						 case REOP_MINIMALSTAR: min = 0;
						 max = -1;
						 break;
						 case REOP_PLUS: greedy = true;
						 case REOP_MINIMALPLUS: min = 1;
						 max = -1;
						 break;
						 case REOP_OPT: greedy = true;
						 case REOP_MINIMALOPT: min = 0;
						 max = 1;
						 break;
						 case REOP_QUANT: greedy = true;
						 case REOP_MINIMALQUANT: min = getOffset(program, pc);
						 pc += INDEX_LEN;
						 max = getOffset(program, pc) - 1;
						 pc += INDEX_LEN;
						 break;
						 default: throw Kit.codeBug();
					 }
					 pushProgState(gData, min, max, null, currentContinuation_pc, currentContinuation_op);
					 if (greedy) {
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 pc += 3 * INDEX_LEN;
						 op = program[pc++];
					 }
					 else {
						 if (min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 pc += 3 * INDEX_LEN;
							 op = program[pc++];
						 }
						 else {
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
					 }
				 }
				 continue;
				 case REOP_ENDCHILD: pc = currentContinuation_pc;
				 op = currentContinuation_op;
				 continue;
				 case REOP_REPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.min == 0) result = true;
						 currentContinuation_pc = state.continuation_pc;
						 currentContinuation_op = state.continuation_op;
						 pc += 2 * INDEX_LEN;
						 pc = pc + getOffset(program, pc);
						 break;
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 if (new_max == 0) {
							 result = true;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 int parenCount = getIndex(program, pc);
						 pc += INDEX_LEN;
						 int parenIndex = getIndex(program, pc);
						 pc += 2 * INDEX_LEN;
						 op = program[pc++];
						 for (int k = 0;
						 k < parenCount;
						 k++) {
							 gData.set_parens(parenIndex + k, -1, 0);
						 }
					 }
				 }
				 continue;
				 case REOP_MINIMALREPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.max == -1 || state.max > 0) {
							 pushProgState(gData, state.min, state.max, null, state.continuation_pc, state.continuation_op);
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
							 continue;
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 if (new_min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
						 continue;
					 }
				 }
				 case REOP_END: return true;
				 default: throw Kit.codeBug();
			 }
			 if (!result) {
				 REBackTrackData backTrackData = gData.backTrackStackTop;
				 if (backTrackData != null) {
					 gData.backTrackStackTop = backTrackData.previous;
					 gData.lastParen = backTrackData.lastParen;
					 if (backTrackData.parens != null) {
						 gData.parens = (long[])backTrackData.parens.clone();
					 }
					 gData.cp = backTrackData.cp;
					 gData.stateStackTop = backTrackData.stateStackTop;
					 currentContinuation_op = gData.stateStackTop.continuation_op;
					 currentContinuation_pc = gData.stateStackTop.continuation_pc;
					 pc = backTrackData.continuation_pc;
					 op = backTrackData.continuation_op;
					 continue;
				 }
				 else return false;
			 }
			 op = program[pc++];
		 }
	 }
	 private static boolean matchRegExp(REGlobalData gData, RECompiled re, char[] chars, int start, int end, boolean multiline) {
		 if (re.parenCount != 0) {
			 gData.parens = new long[re.parenCount];
		 }
		 else {
			 gData.parens = null;
		 }
		 gData.backTrackStackTop = null;
		 gData.stateStackTop = null;
		 gData.multiline = multiline;
		 gData.regexp = re;
		 gData.lastParen = 0;
		 int anchorCh = gData.regexp.anchorCh;
		 for (int i = start;
		 i <= end;
		 ++i) {
			 if (anchorCh >= 0) {
				 for (;
				;
				) {
					 if (i == end) {
						 return false;
					 }
					 char matchCh = chars[i];
					 if (matchCh == anchorCh || ((gData.regexp.flags & JSREG_FOLD) != 0 && upcase(matchCh) == upcase((char)anchorCh))) {
						 break;
					 }
					 ++i;
				 }
			 }
			 gData.cp = i;
			 for (int j = 0;
			 j < re.parenCount;
			 j++) {
				 gData.set_parens(j, -1, 0);
			 }
			 boolean result = executeREBytecode(gData, chars, end);
			 gData.backTrackStackTop = null;
			 gData.stateStackTop = null;
			 if (result) {
				 gData.skipped = i - start;
				 return true;
			 }
		 }
		 return false;
	 }
	 Object executeRegExp(Context cx, Scriptable scopeObj, RegExpImpl res, String str, int indexp[], int matchType) {
		 REGlobalData gData = new REGlobalData();
		 int start = indexp[0];
		 char[] charArray = str.toCharArray();
		 int end = charArray.length;
		 if (start > end) start = end;
		 boolean matches = matchRegExp(gData, re, charArray, start, end, res.multiline);
		 if (!matches) {
			 if (matchType != PREFIX) return null;
			 return Undefined.instance;
		 }
		 int index = gData.cp;
		 int i = index;
		 indexp[0] = i;
		 int matchlen = i - (start + gData.skipped);
		 int ep = index;
		 index -= matchlen;
		 Object result;
		 Scriptable obj;
		 if (matchType == TEST) {
			 result = Boolean.TRUE;
			 obj = null;
		 }
		 else {
			 Scriptable scope = getTopLevelScope(scopeObj);
			 result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
			 obj = (Scriptable) result;
			 String matchstr = new String(charArray, index, matchlen);
			 obj.put(0, obj, matchstr);
		 }
		 if (re.parenCount == 0) {
			 res.parens = null;
			 res.lastParen = SubString.emptySubString;
		 }
		 else {
			 SubString parsub = null;
			 int num;
			 res.parens = new SubString[re.parenCount];
			 for (num = 0;
			 num < re.parenCount;
			 num++) {
				 int cap_index = gData.parens_index(num);
				 String parstr;
				 if (cap_index != -1) {
					 int cap_length = gData.parens_length(num);
					 parsub = new SubString(charArray, cap_index, cap_length);
					 res.parens[num] = parsub;
					 if (matchType == TEST) continue;
					 parstr = parsub.toString();
					 obj.put(num+1, obj, parstr);
				 }
				 else {
					 if (matchType != TEST) obj.put(num+1, obj, Undefined.instance);
				 }
			 }
			 res.lastParen = parsub;
		 }
		 if (! (matchType == TEST)) {
			 obj.put(""index"", obj, new Integer(start + gData.skipped));
			 obj.put(""input"", obj, str);
		 }
		 if (res.lastMatch == null) {
			 res.lastMatch = new SubString();
			 res.leftContext = new SubString();
			 res.rightContext = new SubString();
		 }
		 res.lastMatch.charArray = charArray;
		 res.lastMatch.index = index;
		 res.lastMatch.length = matchlen;
		 res.leftContext.charArray = charArray;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 res.leftContext.index = start;
			 res.leftContext.length = gData.skipped;
		 }
		 else {
			 res.leftContext.index = 0;
			 res.leftContext.length = start + gData.skipped;
		 }
		 res.rightContext.charArray = charArray;
		 res.rightContext.index = ep;
		 res.rightContext.length = end - ep;
		 return result;
	 }
	 int getFlags() {
		 return re.flags;
	 }
	 private static void reportError(String messageId, String arg) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg);
		 throw ScriptRuntime.constructError(""SyntaxError"", msg);
	 }
	 private static final int Id_lastIndex = 1, Id_source = 2, Id_global = 3, Id_ignoreCase = 4, Id_multiline = 5, MAX_INSTANCE_ID = 5;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==6) {
				 c=s.charAt(0);
				 if (c=='g') {
					 X=""global"";
					id=Id_global;
				 }
				 else if (c=='s') {
					 X=""source"";
					id=Id_source;
				 }
			 }
			 else if (s_length==9) {
				 c=s.charAt(0);
				 if (c=='l') {
					 X=""lastIndex"";
					id=Id_lastIndex;
				 }
				 else if (c=='m') {
					 X=""multiline"";
					id=Id_multiline;
				 }
			 }
			 else if (s_length==10) {
				 X=""ignoreCase"";
				id=Id_ignoreCase;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 if (id == 0) return super.findInstanceIdInfo(s);
		 int attr;
		 switch (id) {
			 case Id_lastIndex: attr = PERMANENT | DONTENUM;
			 break;
			 case Id_source: case Id_global: case Id_ignoreCase: case Id_multiline: attr = PERMANENT | READONLY | DONTENUM;
			 break;
			 default: throw new IllegalStateException();
		 }
		 return instanceIdInfo(attr, id);
	 }
	 protected String getInstanceIdName(int id) {
		 switch (id) {
			 case Id_lastIndex: return ""lastIndex"";
			 case Id_source: return ""source"";
			 case Id_global: return ""global"";
			 case Id_ignoreCase: return ""ignoreCase"";
			 case Id_multiline: return ""multiline"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 switch (id) {
			 case Id_lastIndex: return ScriptRuntime.wrapNumber(lastIndex);
			 case Id_source: return new String(re.source);
			 case Id_global: return ScriptRuntime.wrapBoolean((re.flags & JSREG_GLOB) != 0);
			 case Id_ignoreCase: return ScriptRuntime.wrapBoolean((re.flags & JSREG_FOLD) != 0);
			 case Id_multiline: return ScriptRuntime.wrapBoolean((re.flags & JSREG_MULTILINE) != 0);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_lastIndex) {
			 lastIndex = ScriptRuntime.toNumber(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_compile: arity=1;
			 s=""compile"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_exec: arity=1;
			 s=""exec"";
			 break;
			 case Id_test: arity=1;
			 s=""test"";
			 break;
			 case Id_prefix: arity=1;
			 s=""prefix"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(REGEXP_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(REGEXP_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_compile: return realThis(thisObj, f).compile(cx, scope, args);
			 case Id_toString: case Id_toSource: return realThis(thisObj, f).toString();
			 case Id_exec: return realThis(thisObj, f).execSub(cx, scope, args, MATCH);
			 case Id_test: {
				 Object x = realThis(thisObj, f).execSub(cx, scope, args, TEST);
				 return Boolean.TRUE.equals(x) ? Boolean.TRUE : Boolean.FALSE;
			 }
			 case Id_prefix: return realThis(thisObj, f).execSub(cx, scope, args, PREFIX);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 private static NativeRegExp realThis(Scriptable thisObj, IdFunctionObject f) {
		 if (!(thisObj instanceof NativeRegExp)) throw incompatibleCallError(f);
		 return (NativeRegExp)thisObj;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 4: c=s.charAt(0);
				 if (c=='e') {
					 X=""exec"";
					id=Id_exec;
				 }
				 else if (c=='t') {
					 X=""test"";
					id=Id_test;
				 }
				 break L;
				 case 6: X=""prefix"";
				id=Id_prefix;
				 break L;
				 case 7: X=""compile"";
				id=Id_compile;
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_compile = 1, Id_toString = 2, Id_toSource = 3, Id_exec = 4, Id_test = 5, Id_prefix = 6, MAX_PROTOTYPE_ID = 6;
	 private RECompiled re;
	 double lastIndex;
 }
;
 class RECompiled implements Serializable{
	 static final long serialVersionUID = -6144956577595844213L;
	 char []source;
	 int parenCount;
	 int flags;
	 byte[] program;
	 int classCount;
	 RECharSet[] classList;
	 int anchorCh = -1;
 }
class RENode {
	 RENode(byte op) {
		 this.op = op;
	 }
	 byte op;
	 RENode next;
	 RENode kid;
	 RENode kid2;
	 int num;
	 int parenIndex;
	 int min;
	 int max;
	 int parenCount;
	 boolean greedy;
	 int startIndex;
	 int kidlen;
	 int bmsize;
	 int index;
	 char chr;
	 int length;
	 int flatIndex;
 }
class CompilerState {
	 CompilerState(char[] source, int length, int flags) {
		 this.cpbegin = source;
		 this.cp = 0;
		 this.cpend = length;
		 this.flags = flags;
		 this.parenCount = 0;
		 this.classCount = 0;
		 this.progLength = 0;
	 }
	 Context cx;
	 char cpbegin[];
	 int cpend;
	 int cp;
	 int flags;
	 int parenCount;
	 int parenNesting;
	 int classCount;
	 int progLength;
	 RENode result;
}
class REProgState{
	 REProgState(REProgState previous, int min, int max, int index, REBackTrackData backTrack, int continuation_pc, int continuation_op) {
		 this.previous = previous;
		 this.min = min;
		 this.max = max;
		 this.index = index;
		 this.continuation_op = continuation_op;
		 this.continuation_pc = continuation_pc;
		 this.backTrack = backTrack;
	 }
	 REProgState previous;
	 int min;
	 int max;
	 int index;
	 int continuation_op;
	 int continuation_pc;
	 REBackTrackData backTrack;
 }
class REBackTrackData {
	 REBackTrackData(REGlobalData gData, int op, int pc) {
		 previous = gData.backTrackStackTop;
		 continuation_op = op;
		 continuation_pc = pc;
		 lastParen = gData.lastParen;
		 if (gData.parens != null) {
			 parens = (long[])gData.parens.clone();
		 }
		 cp = gData.cp;
		 stateStackTop = gData.stateStackTop;
	 }
	 REBackTrackData previous;
	 int continuation_op;
	 int continuation_pc;
	 int lastParen;
	 long[] parens;
	 int cp;
	 REProgState stateStackTop;
 }
class REGlobalData {
	 boolean multiline;
	 RECompiled regexp;
	 int lastParen;
	 int skipped;
	 int cp;
	 long[] parens;
	 REProgState stateStackTop;
	 REBackTrackData backTrackStackTop;
	 int parens_index(int i) {
		 return (int)(parens[i]);
	 }
	 int parens_length(int i) {
		 return (int)(parens[i] >>> 32);
	 }
	 void set_parens(int i, int index, int length) {
		 parens[i] = ((long)index & 0xffffffffL) | ((long)length << 32);
	 }
}
final class RECharSet implements Serializable{
	 static final long serialVersionUID = 7931787979395898394L;
	 RECharSet(int length, int startIndex, int strlength) {
		 this.length = length;
		 this.startIndex = startIndex;
		 this.strlength = strlength;
	 }
	 int length;
	 int startIndex;
	 int strlength;
	 volatile transient boolean converted;
	 volatile transient boolean sense;
	 volatile transient byte[] bits;
}",1,0,0,0
"private static class put_argsStandardScheme extends org.apache.thrift.scheme.StandardScheme<put_args> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, put_args struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
					 struct.table = iprot.readBinary();
					 struct.setTableIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.tput = new TPut();
					 struct.tput.read(iprot);
					 struct.setTputIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, put_args struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.table != null) {
			 oprot.writeFieldBegin(TABLE_FIELD_DESC);
			 oprot.writeBinary(struct.table);
			 oprot.writeFieldEnd();
		 }
		 if (struct.tput != null) {
			 oprot.writeFieldBegin(TPUT_FIELD_DESC);
			 struct.tput.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
"private static void emitStackMove(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, Value input) {
	 try (ScratchRegister r1 = masm.getScratchRegister()) {
		 try (ScratchRegister r2 = masm.getScratchRegister()) {
			 Register rscratch1 = r1.getRegister();
			 Register rscratch2 = r2.getRegister();
			 PlatformKind kind = input.getPlatformKind();
			 final int size = kind.getSizeInBytes() * Byte.SIZE;
			 crb.blockComment(""[stack -> stack copy]"");
			 AArch64Address src = loadStackSlotAddress(crb, masm, asStackSlot(input), rscratch2);
			 masm.ldr(size, rscratch1, src);
			 AArch64Address dst = loadStackSlotAddress(crb, masm, asStackSlot(result), rscratch2);
			 masm.str(size, rscratch1, dst);
		 }
	 }
 }",0,0,1,0
"protected ExecuteWatchdog createWatchdog() throws BuildException {
	 if (getTimeout() == null) {
		 return null;
	 }
	 return new ExecuteWatchdog(getTimeout().longValue());
 }",0,0,0,0
"public class FTP extends Task {
	 protected static final int SEND_FILES = 0;
	 protected static final int GET_FILES = 1;
	 protected static final int DEL_FILES = 2;
	 protected static final int LIST_FILES = 3;
	 protected static final int MK_DIR = 4;
	 protected static final int CHMOD = 5;
	 protected static final int RM_DIR = 6;
	 private static final int CODE_521 = 521;
	 public static final int DEFAULT_FTP_PORT = 21;
	 private String remotedir;
	 private String server;
	 private String userid;
	 private String password;
	 private File listing;
	 private boolean binary = true;
	 private boolean passive = false;
	 private boolean verbose = false;
	 private boolean newerOnly = false;
	 private long timeDiffMillis = 0;
	 private boolean timeDiffAuto = false;
	 private int action = SEND_FILES;
	 private Vector filesets = new Vector();
	 private Vector dirCache = new Vector();
	 private int transferred = 0;
	 private String remoteFileSep = ""/"";
	 private int port = DEFAULT_FTP_PORT;
	 private boolean skipFailedTransfers = false;
	 private int skipped = 0;
	 private boolean ignoreNoncriticalErrors = false;
	 private boolean preserveLastModified = false;
	 private String chmod = null;
	 private String umask = null;
	 private FileUtils fileUtils = FileUtils.newFileUtils();
	 protected static final String[] ACTION_STRS = {
	 ""sending"", ""getting"", ""deleting"", ""listing"", ""making directory"", ""chmod"", ""removing"" }
	;
	 protected static final String[] COMPLETED_ACTION_STRS = {
	 ""sent"", ""retrieved"", ""deleted"", ""listed"", ""created directory"", ""mode changed"", ""removed"" }
	;
	 protected static final String[] ACTION_TARGET_STRS = {
	 ""files"", ""files"", ""files"", ""files"", ""directory"", ""files"", ""directories"" }
	;
	 protected class FTPDirectoryScanner extends DirectoryScanner {
		 protected FTPClient ftp = null;
		 private String rootPath = null;
		 private boolean remoteSystemCaseSensitive = false;
		 private boolean remoteSensitivityChecked = false;
		 public FTPDirectoryScanner(FTPClient ftp) {
			 super();
			 this.ftp = ftp;
			 this.setFollowSymlinks(false);
		 }
		 public void scan() {
			 if (includes == null) {
				 includes = new String[1];
				 includes[0] = ""**"";
			 }
			 if (excludes == null) {
				 excludes = new String[0];
			 }
			 filesIncluded = new Vector();
			 filesNotIncluded = new Vector();
			 filesExcluded = new Vector();
			 dirsIncluded = new Vector();
			 dirsNotIncluded = new Vector();
			 dirsExcluded = new Vector();
			 try {
				 String cwd = ftp.printWorkingDirectory();
				 checkIncludePatterns();
				 clearCaches();
				 ftp.changeWorkingDirectory(cwd);
			 }
			 catch (IOException e) {
				 throw new BuildException(""Unable to scan FTP server: "", e);
			 }
		 }
		 private void checkIncludePatterns() {
			 Hashtable newroots = new Hashtable();
			 for (int icounter = 0;
			 icounter < includes.length;
			 icounter++) {
				 String newpattern = SelectorUtils.rtrimWildcardTokens(includes[icounter]);
				 newroots.put(newpattern, includes[icounter]);
			 }
			 if (remotedir == null) {
				 try {
					 remotedir = ftp.printWorkingDirectory();
				 }
				 catch (IOException e) {
					 throw new BuildException(""could not read current ftp directory"", getLocation());
				 }
			 }
			 AntFTPFile baseFTPFile = new AntFTPRootFile(ftp, remotedir);
			 rootPath = baseFTPFile.getAbsolutePath();
			 if (newroots.containsKey("""")) {
				 scandir(rootPath, """", true);
			 }
			 else {
				 Enumeration enum2 = newroots.keys();
				 while (enum2.hasMoreElements()) {
					 String currentelement = (String) enum2.nextElement();
					 String originalpattern = (String) newroots.get(currentelement);
					 AntFTPFile myfile = new AntFTPFile(baseFTPFile, currentelement);
					 boolean isOK = true;
					 boolean traversesSymlinks = false;
					 String path = null;
					 if (myfile.exists()) {
						 if (remoteSensitivityChecked && remoteSystemCaseSensitive && isFollowSymlinks()) {
							 path = myfile.getFastRelativePath();
						 }
						 else {
							 try {
								 path = myfile.getRelativePath();
								 traversesSymlinks = myfile.isTraverseSymlinks();
							 }
							 catch (IOException be) {
								 throw new BuildException(be, getLocation());
							 }
							 catch (BuildException be) {
								 isOK = false;
							 }
						 }
					 }
					 else {
						 isOK = false;
					 }
					 if (isOK) {
						 currentelement = path.replace(remoteFileSep.charAt(0), File.separatorChar);
						 if (!isFollowSymlinks() && traversesSymlinks) {
							 continue;
						 }
						 if (myfile.isDirectory()) {
							 if (isIncluded(currentelement) && currentelement.length() > 0) {
								 accountForIncludedDir(currentelement, myfile, true);
							 }
							 else {
								 if (currentelement.length() > 0) {
									 if (currentelement.charAt(currentelement .length() - 1) != File.separatorChar) {
										 currentelement = currentelement + File.separatorChar;
									 }
								 }
								 scandir(myfile.getAbsolutePath(), currentelement, true);
							 }
						 }
						 else {
							 if (isCaseSensitive && originalpattern.equals(currentelement)) {
								 accountForIncludedFile(currentelement);
							 }
							 else if (!isCaseSensitive && originalpattern .equalsIgnoreCase(currentelement)) {
								 accountForIncludedFile(currentelement);
							 }
						 }
					 }
				 }
			 }
		 }
		 protected void scandir(String dir, String vpath, boolean fast) {
			 if (fast && hasBeenScanned(vpath)) {
				 return;
			 }
			 try {
				 if (!ftp.changeWorkingDirectory(dir)) {
					 return;
				 }
				 String completePath = null;
				 if (!vpath.equals("""")) {
					 completePath = rootPath + remoteFileSep + vpath.replace(File.separatorChar, remoteFileSep.charAt(0));
				 }
				 else {
					 completePath = rootPath;
				 }
				 FTPFile[] newfiles = listFiles(completePath, false);
				 if (newfiles == null) {
					 ftp.changeToParentDirectory();
					 return;
				 }
				 for (int i = 0;
				 i < newfiles.length;
				 i++) {
					 FTPFile file = newfiles[i];
					 if (!file.getName().equals(""."") && !file.getName().equals("".."")) {
						 if (isFunctioningAsDirectory(ftp, dir, file)) {
							 String name = vpath + file.getName();
							 boolean slowScanAllowed = true;
							 if (!isFollowSymlinks() && file.isSymbolicLink()) {
								 dirsExcluded.addElement(name);
								 slowScanAllowed = false;
							 }
							 else if (isIncluded(name)) {
								 accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath) , fast);
							 }
							 else {
								 dirsNotIncluded.addElement(name);
								 if (fast && couldHoldIncluded(name)) {
									 scandir(file.getName(), name + File.separator, fast);
								 }
							 }
							 if (!fast && slowScanAllowed) {
								 scandir(file.getName(), name + File.separator, fast);
							 }
						 }
						 else {
							 String name = vpath + file.getName();
							 if (!isFollowSymlinks() && file.isSymbolicLink()) {
								 filesExcluded.addElement(name);
							 }
							 else if (isFunctioningAsFile(ftp, dir, file)) {
								 accountForIncludedFile(name);
							 }
						 }
					 }
				 }
				 ftp.changeToParentDirectory();
			 }
			 catch (IOException e) {
				 throw new BuildException(""Error while communicating with FTP "" + ""server: "", e);
			 }
		 }
		 private void accountForIncludedFile(String name) {
			 if (!filesIncluded.contains(name) && !filesExcluded.contains(name)) {
				 if (isIncluded(name)) {
					 if (!isExcluded(name)) {
						 filesIncluded.addElement(name);
					 }
					 else {
						 filesExcluded.addElement(name);
					 }
				 }
				 else {
					 filesNotIncluded.addElement(name);
				 }
			 }
		 }
		 private void accountForIncludedDir(String name, AntFTPFile file, boolean fast) {
			 if (!dirsIncluded.contains(name) && !dirsExcluded.contains(name)) {
				 if (!isExcluded(name)) {
					 if (fast) {
						 if (file.isSymbolicLink()) {
							 try {
								 file.getClient().changeWorkingDirectory(file.curpwd);
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""could not change directory to curpwd"");
							 }
							 scandir(file.getLink(), name + File.separator, fast);
						 }
						 else {
							 try {
								 file.getClient().changeWorkingDirectory(file.curpwd);
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""could not change directory to curpwd"");
							 }
							 scandir(file.getName(), name + File.separator, fast);
						 }
					 }
					 dirsIncluded.addElement(name);
				 }
				 else {
					 dirsExcluded.addElement(name);
					 if (fast && couldHoldIncluded(name)) {
						 try {
							 file.getClient().changeWorkingDirectory(file.curpwd);
						 }
						 catch (IOException ioe) {
							 throw new BuildException(""could not change directory to curpwd"");
						 }
						 scandir(file.getName(), name + File.separator, fast);
					 }
				 }
			 }
		 }
		 private Map fileListMap = new HashMap();
		 private Set scannedDirs = new HashSet();
		 private boolean hasBeenScanned(String vpath) {
			 return !scannedDirs.add(vpath);
		 }
		 private void clearCaches() {
			 fileListMap.clear();
			 scannedDirs.clear();
		 }
		 public FTPFile[] listFiles(String directory, boolean changedir) {
			 String currentPath = directory;
			 if (changedir) {
				 try {
					 boolean result = ftp.changeWorkingDirectory(directory);
					 if (!result) {
						 return null;
					 }
					 currentPath = ftp.printWorkingDirectory();
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, getLocation());
				 }
			 }
			 if (fileListMap.containsKey(currentPath)) {
				 getProject().log(""filelist map used in listing files"", Project.MSG_DEBUG);
				 return ((FTPFile[]) fileListMap.get(currentPath));
			 }
			 FTPFile[] result = null;
			 try {
				 result = ftp.listFiles();
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, getLocation());
			 }
			 fileListMap.put(currentPath, result);
			 if (!remoteSensitivityChecked) {
				 checkRemoteSensitivity(result, directory);
			 }
			 return result;
		 }
		 public FTPFile[] listFiles(String directory) {
			 return listFiles(directory, true);
		 }
		 private void checkRemoteSensitivity(FTPFile[] array, String directory) {
			 if (array == null) {
				 return;
			 }
			 boolean candidateFound = false;
			 String target = null;
			 for (int icounter = 0;
			 icounter < array.length;
			 icounter++) {
				 if (array[icounter].isDirectory()) {
					 if (!array[icounter].getName().equals(""."") && !array[icounter].getName().equals("".."")) {
						 candidateFound = true;
						 target = fiddleName(array[icounter].getName());
						 getProject().log(""will try to cd to "" + target + "" where a directory called "" + array[icounter].getName() + "" exists"", Project.MSG_DEBUG);
						 for (int pcounter = 0;
						 pcounter < array.length;
						 pcounter++) {
							 if (array[pcounter].getName().equals(target) && pcounter != icounter) {
								 candidateFound = false;
							 }
						 }
						 if (candidateFound) {
							 break;
						 }
					 }
				 }
			 }
			 if (candidateFound) {
				 try {
					 getProject().log(""testing case sensitivity, attempting to cd to "" + target, Project.MSG_DEBUG);
					 remoteSystemCaseSensitive = !ftp.changeWorkingDirectory(target);
				 }
				 catch (IOException ioe) {
					 remoteSystemCaseSensitive = true;
				 }
				 finally {
					 try {
						 ftp.changeWorkingDirectory(directory);
					 }
					 catch (IOException ioe) {
						 throw new BuildException(ioe, getLocation());
					 }
				 }
				 getProject().log(""remote system is case sensitive : "" + remoteSystemCaseSensitive, Project.MSG_VERBOSE);
				 remoteSensitivityChecked = true;
			 }
		 }
		 private String fiddleName(String origin) {
			 StringBuffer result = new StringBuffer();
			 for (int icounter = 0;
			 icounter < origin.length();
			 icounter++) {
				 if (Character.isLowerCase(origin.charAt(icounter))) {
					 result.append(Character.toUpperCase(origin.charAt(icounter)));
				 }
				 else if (Character.isUpperCase(origin.charAt(icounter))) {
					 result.append(Character.toLowerCase(origin.charAt(icounter)));
				 }
				 else {
					 result.append(origin.charAt(icounter));
				 }
			 }
			 return result.toString();
		 }
		 protected class AntFTPFile {
			 private FTPClient client;
			 private String curpwd;
			 private FTPFile ftpFile;
			 private AntFTPFile parent = null;
			 private boolean relativePathCalculated = false;
			 private boolean traversesSymlinks = false;
			 private String relativePath = """";
			 public AntFTPFile(FTPClient client, FTPFile ftpFile, String curpwd) {
				 this.client = client;
				 this.ftpFile = ftpFile;
				 this.curpwd = curpwd;
			 }
			 public AntFTPFile(AntFTPFile parent, String path) {
				 this.parent = parent;
				 this.client = parent.client;
				 Vector pathElements = SelectorUtils.tokenizePath(path);
				 try {
					 boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());
					 if (!result) {
						 return;
					 }
					 this.curpwd = parent.getAbsolutePath();
				 }
				 catch (IOException ioe) {
					 throw new BuildException(""could not change working dir to "" + parent.curpwd);
				 }
				 for (int fcount = 0;
				 fcount < pathElements.size() - 1;
				 fcount++) {
					 String currentPathElement = (String) pathElements.elementAt(fcount);
					 try {
						 boolean result = this.client.changeWorkingDirectory(currentPathElement);
						 if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) {
							 currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement);
							 if (currentPathElement == null) {
								 return;
							 }
						 }
						 else if (!result) {
							 return;
						 }
						 this.curpwd = this.curpwd + remoteFileSep + currentPathElement;
					 }
					 catch (IOException ioe) {
						 throw new BuildException(""could not change working dir to "" + (String) pathElements.elementAt(fcount) + "" from "" + this.curpwd);
					 }
				 }
				 String lastpathelement = (String) pathElements.elementAt(pathElements.size() - 1);
				 FTPFile [] theFiles = listFiles(this.curpwd);
				 this.ftpFile = getFile(theFiles, lastpathelement);
			 }
			 private String findPathElementCaseUnsensitive(String parentPath, String soughtPathElement) {
				 FTPFile[] theFiles = listFiles(parentPath, false);
				 if (theFiles == null) {
					 return null;
				 }
				 for (int icounter = 0;
				 icounter < theFiles.length;
				 icounter++) {
					 if (theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) {
						 return theFiles[icounter].getName();
					 }
				 }
				 return null;
			 }
			 public boolean exists() {
				 return (ftpFile != null);
			 }
			 public String getLink() {
				 return ftpFile.getLink();
			 }
			 public String getName() {
				 return ftpFile.getName();
			 }
			 public String getAbsolutePath() {
				 return curpwd + remoteFileSep + ftpFile.getName();
			 }
			 public String getFastRelativePath() {
				 String absPath = getAbsolutePath();
				 if (absPath.indexOf(rootPath + remoteFileSep) == 0) {
					 return absPath.substring(rootPath.length() + remoteFileSep.length());
				 }
				 return null;
			 }
			 public String getRelativePath() throws IOException, BuildException {
				 if (!relativePathCalculated) {
					 if (parent != null) {
						 traversesSymlinks = parent.isTraverseSymlinks();
						 relativePath = getRelativePath(parent.getAbsolutePath(), parent.getRelativePath());
					 }
					 else {
						 relativePath = getRelativePath(rootPath, """");
						 relativePathCalculated = true;
					 }
				 }
				 return relativePath;
			 }
			 private String getRelativePath(String currentPath, String currentRelativePath) {
				 Vector pathElements = SelectorUtils.tokenizePath(getAbsolutePath(), remoteFileSep);
				 Vector pathElements2 = SelectorUtils.tokenizePath(currentPath, remoteFileSep);
				 String relPath = currentRelativePath;
				 for (int pcount = pathElements2.size();
				 pcount < pathElements.size();
				 pcount++) {
					 String currentElement = (String) pathElements.elementAt(pcount);
					 FTPFile[] theFiles = listFiles(currentPath);
					 FTPFile theFile = null;
					 if (theFiles != null) {
						 theFile = getFile(theFiles, currentElement);
					 }
					 if (theFile == null) {
						 throw new BuildException(""could not find "" + currentElement + "" from "" + currentPath);
					 }
					 else {
						 traversesSymlinks = traversesSymlinks || theFile.isSymbolicLink();
						 if (!relPath.equals("""")) {
							 relPath = relPath + remoteFileSep;
						 }
						 relPath = relPath + theFile.getName();
						 currentPath = currentPath + remoteFileSep + theFile.getName();
					 }
				 }
				 return relPath;
			 }
			 public FTPFile getFile(FTPFile[] theFiles, String lastpathelement) {
				 if (theFiles == null) {
					 return null;
				 }
				 for (int fcount = 0;
				 fcount < theFiles.length;
				 fcount++) {
					 if (theFiles[fcount].getName().equals(lastpathelement)) {
						 return theFiles[fcount];
					 }
					 else if (!isCaseSensitive() && theFiles[fcount].getName().equalsIgnoreCase(lastpathelement)) {
						 return theFiles[fcount];
					 }
				 }
				 return null;
			 }
			 public boolean isDirectory() {
				 return ftpFile.isDirectory();
			 }
			 public boolean isSymbolicLink() {
				 return ftpFile.isSymbolicLink();
			 }
			 protected FTPClient getClient() {
				 return client;
			 }
			 protected void setCurpwd(String curpwd) {
				 this.curpwd = curpwd;
			 }
			 public String getCurpwd() {
				 return curpwd;
			 }
			 public boolean isTraverseSymlinks() throws IOException, BuildException {
				 if (!relativePathCalculated) {
					 String relpath = getRelativePath();
				 }
				 return traversesSymlinks;
			 }
		 }
		 protected class AntFTPRootFile extends AntFTPFile {
			 private String remotedir;
			 public AntFTPRootFile(FTPClient aclient, String remotedir) {
				 super(aclient, null, remotedir);
				 this.remotedir = remotedir;
				 try {
					 this.getClient().changeWorkingDirectory(this.remotedir);
					 this.setCurpwd(this.getClient().printWorkingDirectory());
				 }
				 catch (IOException ioe) {
					 throw new BuildException(ioe, getLocation());
				 }
			 }
			 public String getAbsolutePath() {
				 return this.getCurpwd();
			 }
			 public String getRelativePath() throws BuildException, IOException {
				 return """";
			 }
		 }
	 }
	 private boolean isFunctioningAsDirectory(FTPClient ftp, String dir, FTPFile file) {
		 boolean result = false;
		 String currentWorkingDir = null;
		 if (file.isDirectory()) {
			 return true;
		 }
		 else if (file.isFile()) {
			 return false;
		 }
		 try {
			 currentWorkingDir = ftp.printWorkingDirectory();
		 }
		 catch (IOException ioe) {
			 getProject().log(""could not find current working directory "" + dir + "" while checking a symlink"", Project.MSG_DEBUG);
		 }
		 if (currentWorkingDir != null) {
			 try {
				 result = ftp.changeWorkingDirectory(file.getLink());
			 }
			 catch (IOException ioe) {
				 getProject().log(""could not cd to "" + file.getLink() + "" while checking a symlink"", Project.MSG_DEBUG);
			 }
			 if (result) {
				 boolean comeback = false;
				 try {
					 comeback = ftp.changeWorkingDirectory(currentWorkingDir);
				 }
				 catch (IOException ioe) {
					 getProject().log(""could not cd back to "" + dir + "" while checking a symlink"", Project.MSG_ERR);
				 }
				 finally {
					 if (!comeback) {
						 throw new BuildException(""could not cd back to "" + dir + "" while checking a symlink"");
					 }
				 }
			 }
		 }
		 return result;
	 }
	 private boolean isFunctioningAsFile(FTPClient ftp, String dir, FTPFile file) {
		 if (file.isDirectory()) {
			 return false;
		 }
		 else if (file.isFile()) {
			 return true;
		 }
		 return !isFunctioningAsDirectory(ftp, dir, file);
	 }
	 public void setRemotedir(String dir) {
		 this.remotedir = dir;
	 }
	 public void setServer(String server) {
		 this.server = server;
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public void setUserid(String userid) {
		 this.userid = userid;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public void setBinary(boolean binary) {
		 this.binary = binary;
	 }
	 public void setPassive(boolean passive) {
		 this.passive = passive;
	 }
	 public void setVerbose(boolean verbose) {
		 this.verbose = verbose;
	 }
	 public void setNewer(boolean newer) {
		 this.newerOnly = newer;
	 }
	 public void setTimeDiffMillis(long timeDiffMillis) {
		 this.timeDiffMillis = timeDiffMillis;
	 }
	 public void setTimeDiffAuto(boolean timeDiffAuto) {
		 this.timeDiffAuto = timeDiffAuto;
	 }
	 public void setPreserveLastModified(boolean preserveLastModified) {
		 this.preserveLastModified = preserveLastModified;
	 }
	 public void setDepends(boolean depends) {
		 this.newerOnly = depends;
	 }
	 public void setSeparator(String separator) {
		 remoteFileSep = separator;
	 }
	 public void setChmod(String theMode) {
		 this.chmod = theMode;
	 }
	 public void setUmask(String theUmask) {
		 this.umask = theUmask;
	 }
	 public void addFileset(FileSet set) {
		 filesets.addElement(set);
	 }
	 public void setAction(String action) throws BuildException {
		 log(""DEPRECATED - The setAction(String) method has been deprecated."" + "" Use setAction(FTP.Action) instead."");
		 Action a = new Action();
		 a.setValue(action);
		 this.action = a.getAction();
	 }
	 public void setAction(Action action) throws BuildException {
		 this.action = action.getAction();
	 }
	 public void setListing(File listing) {
		 this.listing = listing;
	 }
	 public void setSkipFailedTransfers(boolean skipFailedTransfers) {
		 this.skipFailedTransfers = skipFailedTransfers;
	 }
	 public void setIgnoreNoncriticalErrors(boolean ignoreNoncriticalErrors) {
		 this.ignoreNoncriticalErrors = ignoreNoncriticalErrors;
	 }
	 protected void checkConfiguration() throws BuildException {
		 if (server == null) {
			 throw new BuildException(""server attribute must be set!"");
		 }
		 if (userid == null) {
			 throw new BuildException(""userid attribute must be set!"");
		 }
		 if (password == null) {
			 throw new BuildException(""password attribute must be set!"");
		 }
		 if ((action == LIST_FILES) && (listing == null)) {
			 throw new BuildException(""listing attribute must be set for list "" + ""action!"");
		 }
		 if (action == MK_DIR && remotedir == null) {
			 throw new BuildException(""remotedir attribute must be set for "" + ""mkdir action!"");
		 }
		 if (action == CHMOD && chmod == null) {
			 throw new BuildException(""chmod attribute must be set for chmod "" + ""action!"");
		 }
	 }
	 protected int transferFiles(FTPClient ftp, FileSet fs) throws IOException, BuildException {
		 DirectoryScanner ds;
		 if (action == SEND_FILES) {
			 ds = fs.getDirectoryScanner(getProject());
		 }
		 else {
			 if (fs.getSelectors(getProject()).length != 0) {
				 getProject().log(""selectors are not supported in remote filesets"", Project.MSG_WARN);
			 }
			 ds = new FTPDirectoryScanner(ftp);
			 fs.setupDirectoryScanner(ds, getProject());
			 ds.setFollowSymlinks(fs.isFollowSymlinks());
			 ds.scan();
		 }
		 String[] dsfiles = null;
		 if (action == RM_DIR) {
			 dsfiles = ds.getIncludedDirectories();
		 }
		 else {
			 dsfiles = ds.getIncludedFiles();
		 }
		 String dir = null;
		 if ((ds.getBasedir() == null) && ((action == SEND_FILES) || (action == GET_FILES))) {
			 throw new BuildException(""the dir attribute must be set for send "" + ""and get actions"");
		 }
		 else {
			 if ((action == SEND_FILES) || (action == GET_FILES)) {
				 dir = ds.getBasedir().getAbsolutePath();
			 }
		 }
		 BufferedWriter bw = null;
		 try {
			 if (action == LIST_FILES) {
				 File pd = fileUtils.getParentFile(listing);
				 if (!pd.exists()) {
					 pd.mkdirs();
				 }
				 bw = new BufferedWriter(new FileWriter(listing));
			 }
			 if (action == RM_DIR) {
				 for (int i = dsfiles.length - 1;
				 i >= 0;
				 i--) {
					 rmDir(ftp, dsfiles[i]);
				 }
			 }
			 else {
				 for (int i = 0;
				 i < dsfiles.length;
				 i++) {
					 switch (action) {
						 case SEND_FILES: sendFile(ftp, dir, dsfiles[i]);
						 break;
						 case GET_FILES: getFile(ftp, dir, dsfiles[i]);
						 break;
						 case DEL_FILES: delFile(ftp, dsfiles[i]);
						 break;
						 case LIST_FILES: listFile(ftp, bw, dsfiles[i]);
						 break;
						 case CHMOD: doSiteCommand(ftp, ""chmod "" + chmod + "" "" + resolveFile(dsfiles[i]));
						 transferred++;
						 break;
						 default: throw new BuildException(""unknown ftp action "" + action);
					 }
				 }
			 }
		 }
		 finally {
			 if (bw != null) {
				 bw.close();
			 }
		 }
		 return dsfiles.length;
	 }
	 protected void transferFiles(FTPClient ftp) throws IOException, BuildException {
		 transferred = 0;
		 skipped = 0;
		 if (filesets.size() == 0) {
			 throw new BuildException(""at least one fileset must be specified."");
		 }
		 else {
			 for (int i = 0;
			 i < filesets.size();
			 i++) {
				 FileSet fs = (FileSet) filesets.elementAt(i);
				 if (fs != null) {
					 transferFiles(ftp, fs);
				 }
			 }
		 }
		 log(transferred + "" "" + ACTION_TARGET_STRS[action] + "" "" + COMPLETED_ACTION_STRS[action]);
		 if (skipped != 0) {
			 log(skipped + "" "" + ACTION_TARGET_STRS[action] + "" were not successfully "" + COMPLETED_ACTION_STRS[action]);
		 }
	 }
	 protected String resolveFile(String file) {
		 return file.replace(System.getProperty(""file.separator"").charAt(0), remoteFileSep.charAt(0));
	 }
	 protected void createParents(FTPClient ftp, String filename) throws IOException, BuildException {
		 File dir = new File(filename);
		 if (dirCache.contains(dir)) {
			 return;
		 }
		 Vector parents = new Vector();
		 String dirname;
		 while ((dirname = dir.getParent()) != null) {
			 File checkDir = new File(dirname);
			 if (dirCache.contains(checkDir)) {
				 break;
			 }
			 dir = checkDir;
			 parents.addElement(dir);
		 }
		 int i = parents.size() - 1;
		 if (i >= 0) {
			 String cwd = ftp.printWorkingDirectory();
			 String parent = dir.getParent();
			 if (parent != null) {
				 if (!ftp.changeWorkingDirectory(resolveFile(parent))) {
					 throw new BuildException(""could not change to "" + ""directory: "" + ftp.getReplyString());
				 }
			 }
			 while (i >= 0) {
				 dir = (File) parents.elementAt(i--);
				 if (!ftp.changeWorkingDirectory(dir.getName())) {
					 log(""creating remote directory "" + resolveFile(dir.getPath()), Project.MSG_VERBOSE);
					 if (!ftp.makeDirectory(dir.getName())) {
						 handleMkDirFailure(ftp);
					 }
					 if (!ftp.changeWorkingDirectory(dir.getName())) {
						 throw new BuildException(""could not change to "" + ""directory: "" + ftp.getReplyString());
					 }
				 }
				 dirCache.addElement(dir);
			 }
			 ftp.changeWorkingDirectory(cwd);
		 }
	 }
	 private long getTimeDiff(FTPClient ftp) {
		 long returnValue = 0;
		 File tempFile = findFileName(ftp);
		 try {
			 fileUtils.createNewFile(tempFile);
			 long localTimeStamp = tempFile.lastModified();
			 BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile));
			 ftp.storeFile(tempFile.getName(), instream);
			 instream.close();
			 boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
			 if (success) {
				 FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());
				 if (ftpFiles.length == 1) {
					 long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime();
					 returnValue = remoteTimeStamp - localTimeStamp;
				 }
				 ftp.deleteFile(ftpFiles[0].getName());
			 }
			 Delete mydelete = (Delete) getProject().createTask(""delete"");
			 mydelete.setFile(tempFile.getCanonicalFile());
			 mydelete.execute();
		 }
		 catch (Exception e) {
			 throw new BuildException(e, getLocation());
		 }
		 return returnValue;
	 }
	 private File findFileName(FTPClient ftp) {
		 FTPFile [] theFiles = null;
		 final int maxIterations = 1000;
		 for (int counter = 1;
		 counter < maxIterations;
		 counter++) {
			 File localFile = fileUtils.createTempFile(""ant"" + Integer.toString(counter), "".tmp"", null);
			 String fileName = localFile.getName();
			 boolean found = false;
			 try {
				 if (counter == 1) {
					 theFiles = ftp.listFiles();
				 }
				 for (int counter2 = 0;
				 counter2 < theFiles.length;
				 counter2++) {
					 if (theFiles[counter2].getName().equals(fileName)) {
						 found = true;
						 break;
					 }
				 }
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe, getLocation());
			 }
			 if (!found) {
				 localFile.deleteOnExit();
				 return localFile;
			 }
		 }
		 return null;
	 }
	 protected boolean isUpToDate(FTPClient ftp, File localFile, String remoteFile) throws IOException, BuildException {
		 log(""checking date for "" + remoteFile, Project.MSG_VERBOSE);
		 FTPFile[] files = ftp.listFiles(remoteFile);
		 if (files == null || files.length == 0) {
			 if (action == SEND_FILES) {
				 log(""Could not date test remote file: "" + remoteFile + ""assuming out of date."", Project.MSG_VERBOSE);
				 return false;
			 }
			 else {
				 throw new BuildException(""could not date test remote file: "" + ftp.getReplyString());
			 }
		 }
		 long remoteTimestamp = files[0].getTimestamp().getTime().getTime();
		 long localTimestamp = localFile.lastModified();
		 if (this.action == SEND_FILES) {
			 return remoteTimestamp + timeDiffMillis > localTimestamp;
		 }
		 else {
			 return localTimestamp > remoteTimestamp + timeDiffMillis;
		 }
	 }
	 protected void doSiteCommand(FTPClient ftp, String theCMD) throws IOException, BuildException {
		 boolean rc;
		 String[] myReply = null;
		 log(""Doing Site Command: "" + theCMD, Project.MSG_VERBOSE);
		 rc = ftp.sendSiteCommand(theCMD);
		 if (!rc) {
			 log(""Failed to issue Site Command: "" + theCMD, Project.MSG_WARN);
		 }
		 else {
			 myReply = ftp.getReplyStrings();
			 for (int x = 0;
			 x < myReply.length;
			 x++) {
				 if (myReply[x].indexOf(""200"") == -1) {
					 log(myReply[x], Project.MSG_WARN);
				 }
			 }
		 }
	 }
	 protected void sendFile(FTPClient ftp, String dir, String filename) throws IOException, BuildException {
		 InputStream instream = null;
		 try {
			 File file = getProject().resolveFile(new File(dir, filename).getPath());
			 if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
				 return;
			 }
			 if (verbose) {
				 log(""transferring "" + file.getAbsolutePath());
			 }
			 instream = new BufferedInputStream(new FileInputStream(file));
			 createParents(ftp, filename);
			 ftp.storeFile(resolveFile(filename), instream);
			 boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode());
			 if (!success) {
				 String s = ""could not put file: "" + ftp.getReplyString();
				 if (skipFailedTransfers) {
					 log(s, Project.MSG_WARN);
					 skipped++;
				 }
				 else {
					 throw new BuildException(s);
				 }
			 }
			 else {
				 if (chmod != null) {
					 doSiteCommand(ftp, ""chmod "" + chmod + "" "" + resolveFile(filename));
				 }
				 log(""File "" + file.getAbsolutePath() + "" copied to "" + server, Project.MSG_VERBOSE);
				 transferred++;
			 }
		 }
		 finally {
			 if (instream != null) {
				 try {
					 instream.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 protected void delFile(FTPClient ftp, String filename) throws IOException, BuildException {
		 if (verbose) {
			 log(""deleting "" + filename);
		 }
		 if (!ftp.deleteFile(resolveFile(filename))) {
			 String s = ""could not delete file: "" + ftp.getReplyString();
			 if (skipFailedTransfers) {
				 log(s, Project.MSG_WARN);
				 skipped++;
			 }
			 else {
				 throw new BuildException(s);
			 }
		 }
		 else {
			 log(""File "" + filename + "" deleted from "" + server, Project.MSG_VERBOSE);
			 transferred++;
		 }
	 }
	 protected void rmDir(FTPClient ftp, String dirname) throws IOException, BuildException {
		 if (verbose) {
			 log(""removing "" + dirname);
		 }
		 if (!ftp.removeDirectory(resolveFile(dirname))) {
			 String s = ""could not remove directory: "" + ftp.getReplyString();
			 if (skipFailedTransfers) {
				 log(s, Project.MSG_WARN);
				 skipped++;
			 }
			 else {
				 throw new BuildException(s);
			 }
		 }
		 else {
			 log(""Directory "" + dirname + "" removed from "" + server, Project.MSG_VERBOSE);
			 transferred++;
		 }
	 }
	 protected void getFile(FTPClient ftp, String dir, String filename) throws IOException, BuildException {
		 OutputStream outstream = null;
		 try {
			 File file = getProject().resolveFile(new File(dir, filename).getPath());
			 if (newerOnly && isUpToDate(ftp, file, resolveFile(filename))) {
				 return;
			 }
			 if (verbose) {
				 log(""transferring "" + filename + "" to "" + file.getAbsolutePath());
			 }
			 File pdir = fileUtils.getParentFile(file);
			 if (!pdir.exists()) {
				 pdir.mkdirs();
			 }
			 outstream = new BufferedOutputStream(new FileOutputStream(file));
			 ftp.retrieveFile(resolveFile(filename), outstream);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 String s = ""could not get file: "" + ftp.getReplyString();
				 if (skipFailedTransfers) {
					 log(s, Project.MSG_WARN);
					 skipped++;
				 }
				 else {
					 throw new BuildException(s);
				 }
			 }
			 else {
				 log(""File "" + file.getAbsolutePath() + "" copied from "" + server, Project.MSG_VERBOSE);
				 transferred++;
				 if (preserveLastModified) {
					 outstream.close();
					 outstream = null;
					 FTPFile[] remote = ftp.listFiles(resolveFile(filename));
					 if (remote.length > 0) {
						 fileUtils.setFileLastModified(file, remote[0].getTimestamp() .getTime().getTime());
					 }
				 }
			 }
		 }
		 finally {
			 if (outstream != null) {
				 try {
					 outstream.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 protected void listFile(FTPClient ftp, BufferedWriter bw, String filename) throws IOException, BuildException {
		 if (verbose) {
			 log(""listing "" + filename);
		 }
		 FTPFile ftpfile = ftp.listFiles(resolveFile(filename))[0];
		 bw.write(ftpfile.toString());
		 bw.newLine();
		 transferred++;
	 }
	 protected void makeRemoteDir(FTPClient ftp, String dir) throws IOException, BuildException {
		 String workingDirectory = ftp.printWorkingDirectory();
		 if (verbose) {
			 log(""Creating directory: "" + dir);
		 }
		 if (dir.indexOf(""/"") == 0) {
			 ftp.changeWorkingDirectory(""/"");
		 }
		 String subdir = new String();
		 StringTokenizer st = new StringTokenizer(dir, ""/"");
		 while (st.hasMoreTokens()) {
			 subdir = st.nextToken();
			 log(""Checking "" + subdir, Project.MSG_DEBUG);
			 if (!ftp.changeWorkingDirectory(subdir)) {
				 if (!ftp.makeDirectory(subdir)) {
					 int rc = ftp.getReplyCode();
					 if (!(ignoreNoncriticalErrors && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553 || rc == CODE_521))) {
						 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
					 }
					 if (verbose) {
						 log(""Directory already exists"");
					 }
				 }
				 else {
					 if (verbose) {
						 log(""Directory created OK"");
					 }
					 ftp.changeWorkingDirectory(subdir);
				 }
			 }
		 }
		 if (workingDirectory != null) {
			 ftp.changeWorkingDirectory(workingDirectory);
		 }
	 }
	 private void handleMkDirFailure(FTPClient ftp) throws BuildException {
		 int rc = ftp.getReplyCode();
		 if (!(ignoreNoncriticalErrors && (rc == FTPReply.CODE_550 || rc == FTPReply.CODE_553 || rc == CODE_521))) {
			 throw new BuildException(""could not create directory: "" + ftp.getReplyString());
		 }
	 }
	 public void execute() throws BuildException {
		 checkConfiguration();
		 FTPClient ftp = null;
		 try {
			 log(""Opening FTP connection to "" + server, Project.MSG_VERBOSE);
			 ftp = new FTPClient();
			 ftp.connect(server, port);
			 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
				 throw new BuildException(""FTP connection failed: "" + ftp.getReplyString());
			 }
			 log(""connected"", Project.MSG_VERBOSE);
			 log(""logging in to FTP server"", Project.MSG_VERBOSE);
			 if (!ftp.login(userid, password)) {
				 throw new BuildException(""Could not login to FTP server"");
			 }
			 log(""login succeeded"", Project.MSG_VERBOSE);
			 if (binary) {
				 ftp.setFileType(org.apache.commons.net.ftp.FTP.IMAGE_FILE_TYPE);
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
				 }
			 }
			 else {
				 ftp.setFileType(org.apache.commons.net.ftp.FTP.ASCII_FILE_TYPE);
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not set transfer type: "" + ftp.getReplyString());
				 }
			 }
			 if (passive) {
				 log(""entering passive mode"", Project.MSG_VERBOSE);
				 ftp.enterLocalPassiveMode();
				 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
					 throw new BuildException(""could not enter into passive "" + ""mode: "" + ftp.getReplyString());
				 }
			 }
			 if (umask != null) {
				 doSiteCommand(ftp, ""umask "" + umask);
			 }
			 if (action == MK_DIR) {
				 makeRemoteDir(ftp, remotedir);
			 }
			 else {
				 if (remotedir != null) {
					 log(""changing the remote directory"", Project.MSG_VERBOSE);
					 ftp.changeWorkingDirectory(remotedir);
					 if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {
						 throw new BuildException(""could not change remote "" + ""directory: "" + ftp.getReplyString());
					 }
				 }
				 if (newerOnly && timeDiffAuto) {
					 timeDiffMillis = getTimeDiff(ftp);
				 }
				 log(ACTION_STRS[action] + "" "" + ACTION_TARGET_STRS[action]);
				 transferFiles(ftp);
			 }
		 }
		 catch (IOException ex) {
			 throw new BuildException(""error during FTP transfer: "" + ex);
		 }
		 finally {
			 if (ftp != null && ftp.isConnected()) {
				 try {
					 log(""disconnecting"", Project.MSG_VERBOSE);
					 ftp.logout();
					 ftp.disconnect();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 public static class Action extends EnumeratedAttribute {
		 private static final String[] VALID_ACTIONS = {
		 ""send"", ""put"", ""recv"", ""get"", ""del"", ""delete"", ""list"", ""mkdir"", ""chmod"", ""rmdir"" }
		;
		 public String[] getValues() {
			 return VALID_ACTIONS;
		 }
		 public int getAction() {
			 String actionL = getValue().toLowerCase(Locale.US);
			 if (actionL.equals(""send"") || actionL.equals(""put"")) {
				 return SEND_FILES;
			 }
			 else if (actionL.equals(""recv"") || actionL.equals(""get"")) {
				 return GET_FILES;
			 }
			 else if (actionL.equals(""del"") || actionL.equals(""delete"")) {
				 return DEL_FILES;
			 }
			 else if (actionL.equals(""list"")) {
				 return LIST_FILES;
			 }
			 else if (actionL.equals(""chmod"")) {
				 return CHMOD;
			 }
			 else if (actionL.equals(""mkdir"")) {
				 return MK_DIR;
			 }
			 else if (actionL.equals(""rmdir"")) {
				 return RM_DIR;
			 }
			 return SEND_FILES;
		 }
	 }
}",1,0,0,0
"public void setBasejarname(String inValue) {
	 config.baseJarName = inValue;
	 if (config.namingScheme == null) {
		 config.namingScheme = new NamingScheme();
		 config.namingScheme.setValue(NamingScheme.BASEJARNAME);
	 }
	 else if (!config.namingScheme.getValue().equals(NamingScheme.BASEJARNAME)) {
		 throw new BuildException(""The basejarname attribute is not "" + ""compatible with the "" + config.namingScheme.getValue() + "" naming scheme"");
	 }
 }",0,0,0,0
"private static Class<T> loadClass2(String className, Class<T> callingClass) throws ClassNotFoundException {
	 try {
		 return Class.forName(className);
	 }
	 catch (ClassNotFoundException ex) {
		 try {
			 if (ClassLoaderUtils.class.getClassLoader() != null) {
				 return ClassLoaderUtils.class.getClassLoader().loadClass(className);
			 }
		 }
		 catch (ClassNotFoundException exc) {
			 if (callingClass != null && callingClass.getClassLoader() != null) {
				 return callingClass.getClassLoader().loadClass(className);
			 }
		 }
		 LOG.debug(ex.getMessage(), ex);
		 throw ex;
	 }
 }",0,0,1,0
"public abstract class StaticMethodMatcherPointcutAdvisor extends StaticMethodMatcherPointcutimplements PointcutAdvisor, Ordered, Serializable {
	private Advice advice = EMPTY_ADVICE;
	private int order = Ordered.LOWEST_PRECEDENCE;
	public StaticMethodMatcherPointcutAdvisor() {
	}
	public StaticMethodMatcherPointcutAdvisor(Advice advice) {
		Assert.notNull(advice, ""Advice must not be null"");
		this.advice = advice;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	public int getOrder() {
		return this.order;
	}
	public void setAdvice(Advice advice) {
		this.advice = advice;
	}
	public Advice getAdvice() {
		return this.advice;
	}
	public boolean isPerInstance() {
		return true;
	}
	public Pointcut getPointcut() {
		return this;
	}
}",0,1,0,0
"protected void onCreate(Bundle savedInstanceState) {
	 super.onCreate(savedInstanceState);
	 setContentView(R.layout.activity_main);
	 mPointSymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.Style.SQUARE, 0xFFFF0000, 20);
	 mLineSymbol = new SimpleLineSymbol(SimpleLineSymbol.Style.SOLID, 0xFFFF8800, 4);
	 mFillSymbol = new SimpleFillSymbol(SimpleFillSymbol.Style.CROSS, 0x40FFA9A9, mLineSymbol);
	 mMapView = findViewById(R.id.mapView);
	 ArcGISMap map = new ArcGISMap(Basemap.Type.LIGHT_GRAY_CANVAS, 34.056295, -117.195800, 16);
	 mMapView.setMap(map);
	 mGraphicsOverlay = new GraphicsOverlay();
	 mMapView.getGraphicsOverlays().add(mGraphicsOverlay);
	 mSketchEditor = new SketchEditor();
	 mMapView.setSketchEditor(mSketchEditor);
	 mPointButton = findViewById(R.id.pointButton);
	 mMultiPointButton = findViewById(R.id.pointsButton);
	 mPolylineButton = findViewById(R.id.polylineButton);
	 mPolygonButton = findViewById(R.id.polygonButton);
	 mFreehandLineButton = findViewById(R.id.freehandLineButton);
	 mFreehandPolygonButton = findViewById(R.id.freehandPolygonButton);
	 mPointButton.setOnClickListener(view -> createModePoint());
	 mMultiPointButton.setOnClickListener(view -> createModeMultipoint());
	 mPolylineButton.setOnClickListener(view -> createModePolyline());
	 mPolygonButton.setOnClickListener(view -> createModePolygon());
	 mFreehandLineButton.setOnClickListener(view -> createModeFreehandLine());
	 mFreehandPolygonButton.setOnClickListener(view -> createModeFreehandPolygon());
 }",0,0,1,0
"private SplittedEntry extractSplittedCategory( Session session, Accounts accounts, Account account, Entry entry, String line) throws CanceledException;",0,0,0,1
"public class ActionNamesAction extends ActionSupport {
	 private static final long serialVersionUID = -5389385242431387840L;
	 private Set<String> actionNames;
	 private String namespace = """";
	 private Set<String> namespaces;
	 private String extension;
	 protected ConfigurationHelper configHelper;
	 public void setConfigurationHelper(ConfigurationHelper cfg) {
		 this.configHelper = cfg;
	 }
	 public Set<String> getActionNames() {
		 return actionNames;
	 }
	 public String getNamespace() {
		 return StringEscapeUtils.escapeHtml4(namespace);
	 }
	 public void setNamespace(String namespace) {
		 this.namespace = namespace;
	 }
	 public void setExtension(String ext) {
		 this.extension = ext;
	 }
	 public ActionConfig getConfig(String actionName) {
		 return configHelper.getActionConfig(namespace, actionName);
	 }
	 public Set<String> getNamespaces() {
		 return namespaces;
	 }
	 public String getExtension() {
		 if (extension == null) {
			 return ""action"";
		 }
		 if (extension.contains("","")) {
			 return extension.substring(0, extension.indexOf("",""));
		 }
		 return extension;
	 }
	 public String execute() throws Exception {
		 namespaces = configHelper.getNamespaces();
		 if (namespaces.size() == 0) {
			 addActionError(""There are no namespaces in this configuration"");
			 return ERROR;
		 }
		 if (namespace == null) {
			 namespace = """";
		 }
		 actionNames = new TreeSet<String>(configHelper.getActionNames(namespace));
		 return SUCCESS;
	 }
	 public String index() throws Exception {
		 return execute();
	 }
	 public String redirect() {
		 return SUCCESS;
	 }
}",0,1,0,0
"private void initUI() {
	setUndecorated(true);
	try {
		if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			setOpacity(0.85f);
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	setIconImage(ImageResource.get(""icon.png"").getImage());
	setSize(400, 210);
	setLocationRelativeTo(null);
	setAlwaysOnTop(true);
	getContentPane().setLayout(null);
	getContentPane().setBackground(ColorResource.getDarkestBgColor());
	JPanel titlePanel = new TitlePanel(null, this);
	titlePanel.setOpaque(false);
	titlePanel.setBounds(0, 0, 400, 50);
	JButton closeBtn = new CustomButton();
	closeBtn.setBounds(365, 5, 30, 30);
	closeBtn.setBackground(ColorResource.getDarkestBgColor());
	closeBtn.setBorderPainted(false);
	closeBtn.setFocusPainted(false);
	closeBtn.setName(""CLOSE"");
	closeBtn.setIcon(ImageResource.get(""close_btn.png""));
	closeBtn.addActionListener(this);
	titlePanel.add(closeBtn);
	JLabel titleLbl = new JLabel(StringResource.get(""ND_TITLE""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(25, 15, 200, 30);
	titlePanel.add(titleLbl);
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, 55, 400, 1);
	lineLbl.setOpaque(true);
	add(lineLbl);
	txtURL = new JTextField();
	PopupAdapter.registerTxtPopup(txtURL);
	txtURL.getDocument().addDocumentListener(this);
	txtURL.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	txtURL.setBackground(ColorResource.getDarkestBgColor());
	txtURL.setForeground(Color.WHITE);
	txtURL.setBounds(77, 79, 291, 20);
	txtURL.setCaretColor(ColorResource.getSelectionColor());
	add(txtURL);
	txtFile = new JTextField();
	PopupAdapter.registerTxtPopup(txtFile);
	txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	txtFile.setBackground(ColorResource.getDarkestBgColor());
	txtFile.setForeground(Color.WHITE);
	txtFile.setBounds(77, 111, 241, 20);
	txtFile.setCaretColor(ColorResource.getSelectionColor());
	add(txtFile);
	JButton browse = new CustomButton(""..."");
	browse.setName(""BROWSE_FOLDER"");
	browse.setMargin(new Insets(0, 0, 0, 0));
	browse.setBounds(325, 111, 40, 20);
	browse.setFocusPainted(false);
	browse.setBackground(ColorResource.getDarkestBgColor());
	browse.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	browse.setForeground(Color.WHITE);
	browse.addActionListener(this);
	browse.setFont(FontResource.getItemFont());
	add(browse);
	add(titlePanel);
	JLabel lblURL = new JLabel(StringResource.get(""ND_ADDRESS""), JLabel.RIGHT);
	lblURL.setFont(FontResource.getNormalFont());
	lblURL.setForeground(Color.WHITE);
	lblURL.setBounds(10, 78, 61, 23);
	add(lblURL);
	JLabel lblFile = new JLabel(StringResource.get(""ND_FILE""), JLabel.RIGHT);
	lblFile.setFont(FontResource.getNormalFont());
	lblFile.setForeground(Color.WHITE);
	lblFile.setBounds(10, 108, 61, 23);
	add(lblFile);
	JPanel panel = new JPanel(null);
	panel.setBounds(0, 155, 400, 55);
	panel.setBackground(Color.DARK_GRAY);
	add(panel);
	btnMore = new CustomButton(StringResource.get(""ND_MORE""));
	btnDN = new CustomButton(StringResource.get(""ND_DOWNLOAD_NOW""));
	btnCN = new CustomButton(StringResource.get(""ND_CANCEL""));
	btnMore.setBounds(0, 1, 120, 55);
	btnMore.setName(""BTN_MORE"");
	styleButton(btnMore);
	panel.add(btnMore);
	btnDN.setBounds(121, 1, 160, 55);
	btnDN.setName(""DOWNLOAD_NOW"");
	styleButton(btnDN);
	panel.add(btnDN);
	btnCN.setBounds(282, 1, 120, 55);
	btnCN.setName(""CLOSE"");
	styleButton(btnCN);
	panel.add(btnCN);
}",0,0,1,0
"public void onChange(){
	log.info(""Class file "" + finalClzFile + "" has changed, reloading"");
	try{
		listener.onChange();
	}
	catch (Exception e){
		log.error(""Could not notify listener"", e);
		watcher.remove(finalClzFile);
	}
}",0,0,0,0
"public class StringBufferResourceStream extends AbstractStringResourceStream{
	private static final long serialVersionUID = 1L;
	private final AppendingStringBuffer buffer = new AppendingStringBuffer(128);
	public StringBufferResourceStream(){
	}
	public StringBufferResourceStream(final String contentType){
		super(contentType);
	}
	public StringBufferResourceStream append(final CharSequence s){
		buffer.append(s);
		setLastModified(Time.now());
		return this;
	}
	public StringBufferResourceStream prepend(final CharSequence s){
		buffer.insert(0, s);
		setLastModified(Time.now());
		return this;
	}
	public StringBufferResourceStream clear(){
		buffer.delete(0, buffer.length());
		return this;
	}
	protected String getString(){
		return buffer.toString();
	}
}",0,0,0,0
"public interface IContentEmitter{
	String getOutputFormat( );
	void initialize( IEmitterServices service ) throws BirtException;
	void start( IReportContent report ) throws BirtException;
	void end( IReportContent report ) throws BirtException;
	void startPage( IPageContent page ) throws BirtException;
	void endPage( IPageContent page ) throws BirtException;
	void startTable( ITableContent table ) throws BirtException;
	void endTable( ITableContent table ) throws BirtException;
	void startTableBand( ITableBandContent band ) throws BirtException;
	void endTableBand( ITableBandContent band ) throws BirtException;
	void startRow( IRowContent row ) throws BirtException;
	void endRow( IRowContent row ) throws BirtException;
	void startCell( ICellContent cell ) throws BirtException;
	void endCell( ICellContent cell ) throws BirtException;
	void startList( IListContent list ) throws BirtException;
	void endList( IListContent list ) throws BirtException;
	void startListBand( IListBandContent listBand ) throws BirtException;
	void endListBand( IListBandContent listBand ) throws BirtException;
	void startContainer( IContainerContent container ) throws BirtException;
	void endContainer( IContainerContent container ) throws BirtException;
	void startText( ITextContent text ) throws BirtException;
	void startData( IDataContent data ) throws BirtException;
	void startLabel( ILabelContent label ) throws BirtException;
	void startAutoText ( IAutoTextContent autoText ) throws BirtException;
	void startForeign( IForeignContent foreign ) throws BirtException;
	void startImage( IImageContent image ) throws BirtException;
	void startContent( IContent content ) throws BirtException;
	void endContent( IContent content) throws BirtException;
	void startGroup( IGroupContent group ) throws BirtException;
	void endGroup( IGroupContent group ) throws BirtException;
	void startTableGroup( ITableGroupContent group ) throws BirtException;
	void endTableGroup( ITableGroupContent group ) throws BirtException;
	void startListGroup( IListGroupContent group ) throws BirtException;
	void endListGroup( IListGroupContent group ) throws BirtException;
}",1,1,0,0
"public class Plc4XEtherNetIpProtocol extends MessageToMessageCodec<EnipPacket, PlcRequestContainer<InternalPlcRequest, InternalPlcResponse>> {
	 private static final Logger LOGGER = LoggerFactory.getLogger(Plc4XEtherNetIpProtocol.class);
	 private static final int SERVICE_COMMUNICATIONS_TYPE_CODE = 0x0100;
	 private long sessionHandle = 0;
	 private static final AtomicLong messageId = new AtomicLong();
	 private CipIdentityItem identityItem;
	 private boolean supportsCipEncapsulation = false;
	 private boolean supportsClass0Or1UdpConnections = false;
	 private Map<String, Integer> nonCipInterfaces = null;
	 private Map<PlcField, Long> fieldConnectionMap = new ConcurrentHashMap<>();
	 private final Map<Long, PlcRequestContainer<InternalPlcRequest, InternalPlcResponse>> requestsMap = new ConcurrentHashMap<>();
	 public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
		 if (evt instanceof ConnectEvent) {
			 LOGGER.debug(""EtherNet/IP Protocol Sending Connection Request"");
			 EnipPacket packet = new EnipPacket(CommandCode.RegisterSession, 0, EnipStatus.EIP_SUCCESS, messageId.getAndIncrement(), new RegisterSession());
			 ctx.channel().writeAndFlush(packet);
		 }
		 else {
			 super.userEventTriggered(ctx, evt);
		 }
	 }
	 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
		 LOGGER.trace(""(-->ERR): {
		}
		"", ctx, cause);
		 super.exceptionCaught(ctx, cause);
	 }
	 protected void encode(ChannelHandlerContext ctx, PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> msg, List<Object> out) {
		 LOGGER.trace(""(<--OUT): {
		}
		, {
		}
		, {
		}
		"", ctx, msg, out);
		 messageId.compareAndSet(Short.MAX_VALUE + 1L, 0);
		 PlcRequest request = msg.getRequest();
		 if (request instanceof PlcReadRequest) {
			 encodeReadRequest(msg, out);
		 }
		 else if (request instanceof PlcWriteRequest) {
			 encodeWriteRequest(msg, out);
		 }
	 }
	 private void encodeWriteRequest(PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> msg, List<Object> out) {
		 if (!supportsCipEncapsulation) {
			 LOGGER.warn(""CIP Encapsulation not supported by remote, payload encapsulation must be handled by target and originator"");
		 }
	 }
	 private void encodeReadRequest(PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> msg, List<Object> out) {
		 if (!supportsCipEncapsulation) {
			 LOGGER.warn(""CIP Encapsulation not supported by remote, payload encapsulation must be handled by target and originator"");
		 }
		 InternalPlcReadRequest request = (InternalPlcReadRequest) msg.getRequest();
		 for (String fieldName : request.getFieldNames()) {
			 PlcField field = request.getField(fieldName);
			 EtherNetIpField enipField = (EtherNetIpField) field;
			 EPath.PaddedEPath path = new EPath.PaddedEPath(new LogicalSegment.ClassId(enipField.getObjectNumber()), new LogicalSegment.InstanceId(enipField.getInstanceNumber()), new LogicalSegment.AttributeId(enipField.getAttributeNumber()));
			 GetAttributeSingleService service = new GetAttributeSingleService(path);
			 EnipPacket packet = new EnipPacket(CommandCode.SendRRData, sessionHandle, EnipStatus.EIP_SUCCESS, messageId.getAndIncrement(), new SendRRData(new CpfPacket( new NullAddressItem(), new UnconnectedDataItemRequest(service::encodeRequest) )));
			 requestsMap.put(packet.getSenderContext(), msg);
			 out.add(packet);
		 }
	 }
	 protected void decode(ChannelHandlerContext ctx, EnipPacket msg, List<Object> out) {
		 LOGGER.trace(""(-->IN): {
		}
		, {
		}
		, {
		}
		"", ctx, msg, out);
		 LOGGER.debug(""{
		}
		: session handle: {
		}
		, sender context: {
		}
		, EtherNetIPPacket:{
		}
		"", msg, msg.getSessionHandle(), msg.getSenderContext(), msg);
		 EnipPacket packet = null;
		 switch (msg.getCommandCode()) {
			 case RegisterSession: handleRegisterSession(ctx, msg);
			 packet = new EnipPacket(CommandCode.ListIdentity, sessionHandle, EnipStatus.EIP_SUCCESS, messageId.getAndIncrement(), new ListIdentity());
			 break;
			 case UnRegisterSession: handleUnregisterSession(ctx, msg);
			 ctx.channel().disconnect();
			 break;
			 case ListIdentity: handleListIdentity(ctx, msg);
			 packet = new EnipPacket(CommandCode.ListServices, sessionHandle, EnipStatus.EIP_SUCCESS, messageId.getAndIncrement(), new ListServices());
			 break;
			 case ListInterfaces: handleListInterfaces(ctx, msg);
			 ctx.channel().pipeline().fireUserEventTriggered(new ConnectedEvent());
			 break;
			 case ListServices: handleListServices(ctx, msg);
			 packet = new EnipPacket(CommandCode.ListInterfaces, sessionHandle, EnipStatus.EIP_SUCCESS, messageId.getAndIncrement(), new ListInterfaces());
			 break;
			 case Nop: handleNop(ctx, msg);
			 break;
			 case SendRRData: handleSendRRDataResponse(ctx, msg);
			 break;
			 case SendUnitData: break;
		 }
		 if (packet != null) {
			 ctx.channel().writeAndFlush(packet);
		 }
	 }
	 private void handleRegisterSession(ChannelHandlerContext ctx, EnipPacket msg) {
		 if (msg.getStatus() == EnipStatus.EIP_SUCCESS) {
			 sessionHandle = msg.getSessionHandle();
			 LOGGER.info(""EtherNet/IP session registered session-handle {
			}
			"", sessionHandle);
		 }
		 else {
			 ctx.channel().pipeline().fireExceptionCaught(new PlcProtocolException(""Got a non-success response.""));
		 }
	 }
	 private void handleUnregisterSession(ChannelHandlerContext ctx, EnipPacket msg) {
		 if (msg.getStatus() == EnipStatus.EIP_SUCCESS) {
			 identityItem = null;
			 supportsCipEncapsulation = false;
			 supportsClass0Or1UdpConnections = false;
			 nonCipInterfaces = null;
			 fieldConnectionMap = null;
		 }
		 else {
			 ctx.channel().pipeline().fireExceptionCaught(new PlcProtocolException(""Got a non-success response.""));
		 }
	 }
	 private void handleListIdentity(ChannelHandlerContext ctx, EnipPacket msg) {
		 if (msg.getStatus() == EnipStatus.EIP_SUCCESS) {
			 ListIdentity listIdentityResponse = (ListIdentity) msg.getCommand();
			 if (listIdentityResponse != null) {
				 identityItem = listIdentityResponse.getIdentity().orElse(null);
				 if (identityItem != null) {
					 LOGGER.info(""Connected to: \n - product name: {
					}
					 \n - serial number: {
					}
					 "", identityItem.getProductName().trim(), identityItem.getSerialNumber());
				 }
			 }
			 else {
				 identityItem = null;
			 }
		 }
		 else {
			 ctx.channel().pipeline().fireExceptionCaught(new PlcProtocolException(""Got a non-success response.""));
		 }
	 }
	 private void handleListInterfaces(ChannelHandlerContext ctx, EnipPacket msg) {
		 if (msg.getStatus() == EnipStatus.EIP_SUCCESS) {
			 ListInterfaces listInterfaces = (ListInterfaces) msg.getCommand();
			 if (listInterfaces != null) {
				 if (listInterfaces.getInterfaces().length > 0) {
					 nonCipInterfaces = new HashMap<>();
					 for (ListInterfaces.InterfaceInformation interfaceInformation : listInterfaces.getInterfaces()) {
						 String interfaceName = new String( interfaceInformation.getData(), Charset.forName(""US-ASCII"")).trim();
						 nonCipInterfaces.put(interfaceName, interfaceInformation.hashCode());
					 }
				 }
				 else {
					 nonCipInterfaces = null;
				 }
			 }
		 }
		 else {
			 ctx.channel().pipeline().fireExceptionCaught(new PlcProtocolException(""Got a non-success response.""));
		 }
	 }
	 private void handleListServices(ChannelHandlerContext ctx, EnipPacket msg) {
		 if (msg.getStatus() == EnipStatus.EIP_SUCCESS) {
			 ListServices listServices = (ListServices) msg.getCommand();
			 if (listServices != null) {
				 for (ListServices.ServiceInformation service : listServices.getServices()) {
					 if (service.getTypeCode() == SERVICE_COMMUNICATIONS_TYPE_CODE) {
						 supportsCipEncapsulation = (service.getCapabilityFlags() & 32) != 0;
						 supportsClass0Or1UdpConnections = (service.getCapabilityFlags() & 256) != 0;
					 }
				 }
			 }
			 else {
				 supportsCipEncapsulation = false;
				 supportsClass0Or1UdpConnections = false;
			 }
		 }
		 else {
			 ctx.channel().pipeline().fireExceptionCaught(new PlcProtocolException(""Got a non-success response.""));
		 }
	 }
	 private void handleNop(ChannelHandlerContext ctx, EnipPacket msg) {
		 if (msg.getStatus() == EnipStatus.EIP_SUCCESS) {
		 }
		 else {
			 ctx.channel().pipeline().fireExceptionCaught( new PlcProtocolException(""Got a non-success flagged request.""));
		 }
	 }
	 private void handleSendRRDataResponse(ChannelHandlerContext ctx, EnipPacket msg) {
		 long senderContext = msg.getSenderContext();
		 PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> plcRequestContainer = requestsMap.get(senderContext);
		 if (plcRequestContainer == null) {
			 ctx.channel().pipeline().fireExceptionCaught( new PlcProtocolException(""Unrelated payload received for message "" + msg));
			 return;
		 }
		 if (!(plcRequestContainer.getRequest() instanceof PlcReadRequest)) {
			 ctx.fireExceptionCaught(new PlcProtocolException(""Expecting a PlcReadRequest here.""));
			 return;
		 }
		 InternalPlcReadRequest request = (InternalPlcReadRequest) plcRequestContainer.getRequest();
		 PlcResponseCode responseCode;
		 if (msg.getStatus() != EnipStatus.EIP_SUCCESS) {
			 responseCode = PlcResponseCode.NOT_FOUND;
		 }
		 else {
			 responseCode = PlcResponseCode.OK;
		 }
		 SendRRData sendRRDataCommand = (SendRRData) msg.getCommand();
		 if (sendRRDataCommand == null) {
			 ctx.fireExceptionCaught(new PlcProtocolException(""Expecting a SendRRData command here.""));
			 return;
		 }
		 CpfItem[] items = sendRRDataCommand.getPacket().getItems();
		 if (items.length != 2) {
			 ctx.fireExceptionCaught(new PlcProtocolException(""Expecting 2 items here.""));
			 return;
		 }
		 CpfItem payload = items[1];
		 if (!(payload instanceof UnconnectedDataItemResponse)) {
			 ctx.fireExceptionCaught(new PlcProtocolException(""Item[1] should be of type UnconnectedDataItemResponse""));
			 return;
		 }
		 UnconnectedDataItemResponse enipResponse = (UnconnectedDataItemResponse) payload;
		 ByteBuf data = enipResponse.getData();
		 if (data.readableBytes() > 0) {
			 Map<String, Pair<PlcResponseCode, BaseDefaultFieldItem>> values = new HashMap<>();
			 for (String fieldName : request.getFieldNames()) {
				 MessageRouterResponse cipResponse = MessageRouterResponse.decode(data);
				 short value;
				 if (cipResponse.getData().readableBytes() >= 2) {
					 value = cipResponse.getData().readShort();
				 }
				 else {
					 value = -1;
				 }
				 DefaultLongFieldItem fieldItem = new DefaultLongFieldItem((long) value);
				 values.put(fieldName, new ImmutablePair<>(responseCode, fieldItem));
			 }
			 InternalPlcReadResponse response = new DefaultPlcReadResponse(request, values);
			 plcRequestContainer.getResponseFuture().complete(response);
		 }
	 }
}",1,0,0,0
"public JsonSchemaSerializerBuilder set(Map<String,Object> properties) {
	super.set(properties);
	return this;
}",0,0,0,0
"public class ParserRoutine extends ParserDML {
	 ParserRoutine(Session session, Scanner t) {
		 super(session, t);
	 }
	 Expression readDefaultClause(Type dataType) {
		 Expression e = null;
		 boolean minus = false;
		 if (token.tokenType == Tokens.NULL) {
			 read();
			 return new ExpressionValue(null, dataType);
		 }
		 if (dataType.isDateTimeType() || dataType.isIntervalType()) {
			 switch (token.tokenType) {
				 case Tokens.DATE : case Tokens.TIME : case Tokens.TIMESTAMP : case Tokens.INTERVAL : {
					 e = readDateTimeIntervalLiteral();
					 if (e.dataType.typeCode != dataType.typeCode) {
						 throw unexpectedToken();
					 }
					 Object defaultValue = e.getValue(session, dataType);
					 return new ExpressionValue(defaultValue, dataType);
				 }
				 case Tokens.X_VALUE : break;
				 default : e = XreadDateTimeValueFunctionOrNull();
				 break;
			 }
		 }
		 else if (dataType.isNumberType()) {
			 if (token.tokenType == Tokens.MINUS) {
				 read();
				 minus = true;
			 }
		 }
		 else if (dataType.isCharacterType()) {
			 switch (token.tokenType) {
				 case Tokens.USER : case Tokens.CURRENT_USER : case Tokens.CURRENT_ROLE : case Tokens.SESSION_USER : case Tokens.SYSTEM_USER : case Tokens.CURRENT_CATALOG : case Tokens.CURRENT_SCHEMA : case Tokens.CURRENT_PATH : FunctionSQL function = FunctionSQL.newSQLFunction(token.tokenString, compileContext);
				 e = readSQLFunction(function);
				 break;
			 default : }
		 }
		 else if (dataType.isBooleanType()) {
			 switch (token.tokenType) {
				 case Tokens.TRUE : read();
				 return Expression.EXPR_TRUE;
				 case Tokens.FALSE : read();
				 return Expression.EXPR_FALSE;
			 }
		 }
		 else if (dataType.isArrayType()) {
			 e = readCollection(OpTypes.ARRAY);
			 if (e.nodes.length > 0) {
				 throw Error.error(ErrorCode.X_42562);
			 }
			 resolveOuterReferencesAndTypes(RangeVariable.emptyArray, e);
			 return e;
		 }
		 if (e != null) {
			 e.resolveTypes(session, null);
			 if (dataType.typeComparisonGroup != e.getDataType().typeComparisonGroup) {
				 throw Error.error(ErrorCode.X_42562);
			 }
			 return e;
		 }
		 if (token.tokenType == Tokens.X_VALUE) {
			 Object value = dataType.convertToType(session, token.tokenValue, token.dataType);
			 read();
			 if (minus) {
				 value = dataType.negate(value);
			 }
			 return new ExpressionValue(value, dataType);
		 }
		 else {
			 throw unexpectedToken();
		 }
	 }
	 Statement compileSelectSingleRowStatement(RangeVariable[] rangeVars) {
		 OrderedHashSet variableNames = new OrderedHashSet();
		 QuerySpecification select = XreadSelect();
		 Type[] targetTypes;
		 LongDeque colIndexList = new LongDeque();
		 readThis(Tokens.INTO);
		 readTargetSpecificationList(variableNames, rangeVars, colIndexList);
		 XreadTableExpression(select);
		 select.setReturningResult();
		 int[] columnMap = new int[colIndexList.size()];
		 colIndexList.toArray(columnMap);
		 Expression[] variables = new Expression[variableNames.size()];
		 variableNames.toArray(variables);
		 targetTypes = new Type[variables.length];
		 for (int i = 0;
		 i < variables.length;
		 i++) {
			 if (variables[i].getColumn().getParameterMode() == SchemaObject.ParameterModes.PARAM_IN) {
				 throw Error.error(ErrorCode.X_0U000);
			 }
			 targetTypes[i] = variables[i].getDataType();
		 }
		 select.resolve(session, rangeVars, targetTypes);
		 if (select.getColumnCount() != variables.length) {
			 throw Error.error(ErrorCode.X_42564, Tokens.T_INTO);
		 }
		 Statement statement = new StatementSet(session, variables, select, columnMap, compileContext);
		 return statement;
	 }
	 Statement compileSetStatement(RangeVariable rangeVars[]) {
		 read();
		 OrderedHashSet targetSet = new OrderedHashSet();
		 HsqlArrayList exprList = new HsqlArrayList();
		 LongDeque colIndexList = new LongDeque();
		 readSetClauseList(rangeVars, targetSet, colIndexList, exprList);
		 if (exprList.size() > 1) {
			 throw Error.error(ErrorCode.X_42602);
		 }
		 Expression expression = (Expression) exprList.get(0);
		 if (expression.getDegree() != targetSet.size()) {
			 throw Error.error(ErrorCode.X_42546, Tokens.T_SET);
		 }
		 int[] columnMap = new int[colIndexList.size()];
		 colIndexList.toArray(columnMap);
		 Expression[] targets = new Expression[targetSet.size()];
		 targetSet.toArray(targets);
		 for (int i = 0;
		 i < targets.length;
		 i++) {
			 this.resolveOuterReferencesAndTypes(rangeVars, targets[i]);
		 }
		 resolveOuterReferencesAndTypes(rangeVars, expression);
		 for (int i = 0;
		 i < targets.length;
		 i++) {
			 if (targets[i].getColumn().getParameterMode() == SchemaObject.ParameterModes.PARAM_IN) {
				 throw Error.error(ErrorCode.X_0U000);
			 }
			 if (!targets[i].getDataType().canBeAssignedFrom( expression.getNodeDataType(i))) {
				 throw Error.error(ErrorCode.X_42561);
			 }
		 }
		 StatementSet cs = new StatementSet(session, targets, expression, columnMap, compileContext);
		 return cs;
	 }
	 StatementDMQL compileTriggerSetStatement(Table table, RangeVariable[] rangeVars) {
		 read();
		 Expression[] updateExpressions;
		 int[] columnMap;
		 OrderedHashSet targetSet = new OrderedHashSet();
		 HsqlArrayList exprList = new HsqlArrayList();
		 RangeVariable[] targetRangeVars = new RangeVariable[]{
		 rangeVars[TriggerDef.NEW_ROW] }
		;
		 LongDeque colIndexList = new LongDeque();
		 readSetClauseList(targetRangeVars, targetSet, colIndexList, exprList);
		 columnMap = new int[colIndexList.size()];
		 colIndexList.toArray(columnMap);
		 Expression[] targets = new Expression[targetSet.size()];
		 targetSet.toArray(targets);
		 for (int i = 0;
		 i < targets.length;
		 i++) {
			 this.resolveOuterReferencesAndTypes(RangeVariable.emptyArray, targets[i]);
		 }
		 updateExpressions = new Expression[exprList.size()];
		 exprList.toArray(updateExpressions);
		 resolveUpdateExpressions(table, rangeVars, columnMap, updateExpressions, RangeVariable.emptyArray);
		 StatementDMQL cs = new StatementSet(session, targets, table, rangeVars, columnMap, updateExpressions, compileContext);
		 return cs;
	 }
	 StatementSchema compileCreateProcedureOrFunction() {
		 int routineType;
		 boolean isAggregate = false;
		 if (token.tokenType == Tokens.AGGREGATE) {
			 isAggregate = true;
			 read();
			 if (token.tokenType == Tokens.PROCEDURE) {
				 throw super.unexpectedToken();
			 }
		 }
		 routineType = token.tokenType == Tokens.PROCEDURE ? SchemaObject.PROCEDURE : SchemaObject.FUNCTION;
		 HsqlName name;
		 read();
		 name = readNewSchemaObjectName(routineType, false);
		 Routine routine = new Routine(routineType);
		 routine.setName(name);
		 routine.setAggregate(isAggregate);
		 readThis(Tokens.OPENBRACKET);
		 if (token.tokenType == Tokens.CLOSEBRACKET) {
			 read();
		 }
		 else {
			 while (true) {
				 ColumnSchema newcolumn = readRoutineParameter(routine, true);
				 routine.addParameter(newcolumn);
				 if (token.tokenType == Tokens.COMMA) {
					 read();
				 }
				 else {
					 readThis(Tokens.CLOSEBRACKET);
					 break;
				 }
			 }
		 }
		 if (routineType != SchemaObject.PROCEDURE) {
			 readThis(Tokens.RETURNS);
			 if (token.tokenType == Tokens.TABLE) {
				 read();
				 TableDerived table = new TableDerived(database, name, TableBase.FUNCTION_TABLE);
				 readThis(Tokens.OPENBRACKET);
				 for (int i = 0;
				 ;
				 i++) {
					 ColumnSchema newcolumn = readRoutineParameter(routine, false);
					 if (newcolumn.getName() == null) {
						 throw super.unexpectedToken();
					 }
					 table.addColumn(newcolumn);
					 if (token.tokenType == Tokens.COMMA) {
						 read();
					 }
					 else {
						 readThis(Tokens.CLOSEBRACKET);
						 break;
					 }
				 }
				 table.createPrimaryKey();
				 routine.setReturnTable(table);
			 }
			 else {
				 Type type = readTypeDefinition(true);
				 routine.setReturnType(type);
			 }
		 }
		 readRoutineCharacteristics(routine);
		 if (token.tokenType == Tokens.EXTERNAL) {
			 if (routine.getLanguage() != Routine.LANGUAGE_JAVA) {
				 throw unexpectedToken();
			 }
			 read();
			 readThis(Tokens.NAME);
			 checkIsValue(Types.SQL_CHAR);
			 routine.setMethodURL((String) token.tokenValue);
			 read();
			 if (token.tokenType == Tokens.PARAMETER) {
				 read();
				 readThis(Tokens.STYLE);
				 readThis(Tokens.JAVA);
			 }
		 }
		 else {
			 startRecording();
			 Statement statement = compileSQLProcedureStatementOrNull(routine, null);
			 if (statement == null) {
				 throw unexpectedToken();
			 }
			 Token[] tokenisedStatement = getRecordedStatement();
			 String sql = Token.getSQL(tokenisedStatement);
			 statement.setSQL(sql);
			 routine.setProcedure(statement);
		 }
		 Object[] args = new Object[]{
		 routine }
		;
		 String sql = getLastPart();
		 StatementSchema cs = new StatementSchema(sql, StatementTypes.CREATE_ROUTINE, args);
		 return cs;
	 }
	 private void readRoutineCharacteristics(Routine routine) {
		 OrderedIntHashSet set = new OrderedIntHashSet();
		 boolean end = false;
		 while (!end) {
			 switch (token.tokenType) {
				 case Tokens.LANGUAGE : {
					 if (!set.add(Tokens.LANGUAGE)) {
						 throw unexpectedToken();
					 }
					 read();
					 if (token.tokenType == Tokens.JAVA) {
						 read();
						 routine.setLanguage(Routine.LANGUAGE_JAVA);
					 }
					 else if (token.tokenType == Tokens.SQL) {
						 read();
						 routine.setLanguage(Routine.LANGUAGE_SQL);
					 }
					 else {
						 throw unexpectedToken();
					 }
					 break;
				 }
				 case Tokens.PARAMETER : {
					 if (!set.add(Tokens.PARAMETER)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.STYLE);
					 if (token.tokenType == Tokens.JAVA) {
						 read();
						 routine.setParameterStyle(Routine.PARAM_STYLE_JAVA);
					 }
					 else {
						 readThis(Tokens.SQL);
						 routine.setParameterStyle(Routine.PARAM_STYLE_SQL);
					 }
					 break;
				 }
				 case Tokens.SPECIFIC : {
					 if (!set.add(Tokens.SPECIFIC)) {
						 throw unexpectedToken();
					 }
					 read();
					 HsqlName name = readNewSchemaObjectName(SchemaObject.SPECIFIC_ROUTINE, false);
					 routine.setSpecificName(name);
					 break;
				 }
				 case Tokens.DETERMINISTIC : {
					 if (!set.add(Tokens.DETERMINISTIC)) {
						 throw unexpectedToken();
					 }
					 read();
					 routine.setDeterministic(true);
					 break;
				 }
				 case Tokens.NOT : {
					 if (!set.add(Tokens.DETERMINISTIC)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.DETERMINISTIC);
					 routine.setDeterministic(false);
					 break;
				 }
				 case Tokens.MODIFIES : {
					 if (!set.add(Tokens.SQL)) {
						 throw unexpectedToken();
					 }
					 if (routine.getType() == SchemaObject.FUNCTION) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.SQL);
					 readThis(Tokens.DATA);
					 routine.setDataImpact(Routine.MODIFIES_SQL);
					 break;
				 }
				 case Tokens.NO : {
					 if (!set.add(Tokens.SQL)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.SQL);
					 routine.setDataImpact(Routine.NO_SQL);
					 break;
				 }
				 case Tokens.READS : {
					 if (!set.add(Tokens.SQL)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.SQL);
					 readThis(Tokens.DATA);
					 routine.setDataImpact(Routine.READS_SQL);
					 break;
				 }
				 case Tokens.CONTAINS : {
					 if (!set.add(Tokens.SQL)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.SQL);
					 routine.setDataImpact(Routine.CONTAINS_SQL);
					 break;
				 }
				 case Tokens.RETURNS : {
					 if (!set.add(Tokens.NULL) || routine.isProcedure()) {
						 throw unexpectedToken();
					 }
					 if (routine.isAggregate()) {
						 throw Error.error(ErrorCode.X_42604, token.tokenString);
					 }
					 read();
					 readThis(Tokens.NULL);
					 readThis(Tokens.ON);
					 readThis(Tokens.NULL);
					 readThis(Tokens.INPUT);
					 routine.setNullInputOutput(true);
					 break;
				 }
				 case Tokens.CALLED : {
					 if (!set.add(Tokens.NULL) || routine.isProcedure()) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.ON);
					 readThis(Tokens.NULL);
					 readThis(Tokens.INPUT);
					 routine.setNullInputOutput(false);
					 break;
				 }
				 case Tokens.DYNAMIC : {
					 if (!set.add(Tokens.RESULT) || routine.isFunction()) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.RESULT);
					 readThis(Tokens.SETS);
					 readBigint();
					 break;
				 }
				 case Tokens.NEW : {
					 if (routine.getType() == SchemaObject.FUNCTION || !set.add(Tokens.SAVEPOINT)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.SAVEPOINT);
					 readThis(Tokens.LEVEL);
					 routine.setNewSavepointLevel(true);
					 break;
				 }
				 case Tokens.OLD : {
					 if (routine.getType() == SchemaObject.FUNCTION || !set.add(Tokens.SAVEPOINT)) {
						 throw unexpectedToken();
					 }
					 read();
					 readThis(Tokens.SAVEPOINT);
					 readThis(Tokens.LEVEL);
					 routine.setNewSavepointLevel(false);
					 throw super.unsupportedFeature(Tokens.T_OLD);
				 }
				 default : end = true;
				 break;
			 }
		 }
	 }
	 private Object[] readLocalDeclarationList(Routine routine, StatementCompound context) {
		 HsqlArrayList list = new HsqlArrayList();
		 while (token.tokenType == Tokens.DECLARE) {
			 Object var = readLocalVariableDeclarationOrNull();
			 if (var == null) {
				 var = compileLocalHandlerDeclarationOrNull(routine, context);
			 }
			 if (var instanceof ColumnSchema[]) {
				 list.addAll((Object[]) var);
			 }
			 else {
				 list.add(var);
			 }
		 }
		 Object[] declarations = new Object[list.size()];
		 list.toArray(declarations);
		 return declarations;
	 }
	 ColumnSchema[] readLocalVariableDeclarationOrNull() {
		 int position = super.getPosition();
		 Type type;
		 HsqlName[] names = HsqlName.emptyArray;
		 try {
			 readThis(Tokens.DECLARE);
			 if (isReservedKey()) {
				 rewind(position);
				 return null;
			 }
			 while (true) {
				 names = (HsqlName[]) ArrayUtil.resizeArray(names, names.length + 1);
				 names[names.length - 1] = super.readNewSchemaObjectName(SchemaObject.VARIABLE, false);
				 if (token.tokenType == Tokens.COMMA) {
					 read();
				 }
				 else {
					 break;
				 }
			 }
			 type = readTypeDefinition(true);
		 }
		 catch (Exception e) {
			 rewind(position);
			 return null;
		 }
		 Expression def = null;
		 if (token.tokenType == Tokens.DEFAULT) {
			 read();
			 def = readDefaultClause(type);
		 }
		 ColumnSchema[] variable = new ColumnSchema[names.length];
		 for (int i = 0;
		 i < names.length;
		 i++) {
			 variable[i] = new ColumnSchema(names[i], type, true, false, def);
			 variable[i].setParameterMode( SchemaObject.ParameterModes.PARAM_INOUT);
		 }
		 readThis(Tokens.SEMICOLON);
		 return variable;
	 }
	 private StatementHandler compileLocalHandlerDeclarationOrNull( Routine routine, StatementCompound context) {
		 int handlerType;
		 readThis(Tokens.DECLARE);
		 switch (token.tokenType) {
			 case Tokens.CONTINUE : read();
			 handlerType = StatementHandler.CONTINUE;
			 break;
			 case Tokens.EXIT : read();
			 handlerType = StatementHandler.EXIT;
			 break;
			 case Tokens.UNDO : read();
			 handlerType = StatementHandler.UNDO;
			 break;
			 default : throw unexpectedToken();
		 }
		 readThis(Tokens.HANDLER);
		 readThis(Tokens.FOR);
		 StatementHandler handler = new StatementHandler(handlerType);
		 boolean end = false;
		 boolean start = true;
		 while (!end) {
			 int conditionType = StatementHandler.NONE;
			 switch (token.tokenType) {
				 case Tokens.COMMA : if (start) {
					 throw unexpectedToken();
				 }
				 read();
				 start = true;
				 break;
				 case Tokens.SQLSTATE : conditionType = StatementHandler.SQL_STATE;
				 case Tokens.SQLEXCEPTION : if (conditionType == StatementHandler.NONE) {
					 conditionType = StatementHandler.SQL_EXCEPTION;
				 }
				 case Tokens.SQLWARNING : if (conditionType == StatementHandler.NONE) {
					 conditionType = StatementHandler.SQL_WARNING;
				 }
				 case Tokens.NOT : if (conditionType == StatementHandler.NONE) {
					 conditionType = StatementHandler.SQL_NOT_FOUND;
				 }
				 if (!start) {
					 throw unexpectedToken();
				 }
				 start = false;
				 read();
				 if (conditionType == StatementHandler.SQL_NOT_FOUND) {
					 readThis(Tokens.FOUND);
				 }
				 else if (conditionType == StatementHandler.SQL_STATE) {
					 String sqlState = parseSQLStateValue();
					 handler.addConditionState(sqlState);
					 break;
				 }
				 handler.addConditionType(conditionType);
				 break;
				 default : if (start) {
					 throw unexpectedToken();
				 }
				 end = true;
				 break;
			 }
		 }
		 if (token.tokenType == Tokens.SEMICOLON) {
			 read();
		 }
		 else {
			 Statement e = compileSQLProcedureStatementOrNull(routine, context);
			 if (e == null) {
				 throw unexpectedToken();
			 }
			 readThis(Tokens.SEMICOLON);
			 handler.addStatement(e);
		 }
		 return handler;
	 }
	 String parseSQLStateValue() {
		 readIfThis(Tokens.VALUE);
		 checkIsValue(Types.SQL_CHAR);
		 String sqlState = token.tokenString;
		 if (token.tokenString.length() != 5) {
			 throw Error.error(ErrorCode.X_42607);
		 }
		 read();
		 return sqlState;
	 }
	 private Statement compileCompoundStatement(Routine routine, StatementCompound context, HsqlName label) {
		 final boolean atomic = true;
		 readThis(Tokens.BEGIN);
		 readThis(Tokens.ATOMIC);
		 StatementCompound statement = new StatementCompound(StatementTypes.BEGIN_END, label);
		 statement.setAtomic(atomic);
		 statement.setRoot(routine);
		 statement.setParent(context);
		 Object[] declarations = readLocalDeclarationList(routine, context);
		 statement.setLocalDeclarations(declarations);
		 Statement[] statements = compileSQLProcedureStatementList(routine, statement);
		 statement.setStatements(statements);
		 readThis(Tokens.END);
		 if (isSimpleName() && !isReservedKey()) {
			 if (label == null) {
				 throw unexpectedToken();
			 }
			 if (!label.name.equals(token.tokenString)) {
				 throw Error.error(ErrorCode.X_42508, token.tokenString);
			 }
			 read();
		 }
		 return statement;
	 }
	 private Statement[] compileSQLProcedureStatementList(Routine routine, StatementCompound context) {
		 Statement e;
		 HsqlArrayList list = new HsqlArrayList();
		 while (true) {
			 e = compileSQLProcedureStatementOrNull(routine, context);
			 if (e == null) {
				 break;
			 }
			 readThis(Tokens.SEMICOLON);
			 list.add(e);
		 }
		 if (list.size() == 0) {
			 throw unexpectedToken();
		 }
		 Statement[] statements = new Statement[list.size()];
		 list.toArray(statements);
		 return statements;
	 }
	 Statement compileSQLProcedureStatementOrNull(Routine routine, StatementCompound context) {
		 Statement cs = null;
		 HsqlName label = null;
		 RangeVariable[] rangeVariables = context == null ? routine.getParameterRangeVariables() : context.getRangeVariables();
		 if (!routine.isTrigger() && isSimpleName() && !isReservedKey()) {
			 label = readNewSchemaObjectName(SchemaObject.LABEL, false);
			 readThis(Tokens.COLON);
		 }
		 compileContext.reset();
		 switch (token.tokenType) {
			 case Tokens.SELECT : {
				 if (routine.dataImpact == Routine.CONTAINS_SQL) {
					 throw Error.error(ErrorCode.X_42608, routine.getDataImpactString());
				 }
				 if (label != null) {
					 throw unexpectedToken();
				 }
				 cs = compileSelectSingleRowStatement(rangeVariables);
				 break;
			 }
			 case Tokens.INSERT : if (routine.dataImpact != Routine.MODIFIES_SQL) {
				 throw Error.error(ErrorCode.X_42608, routine.getDataImpactString());
			 }
			 if (label != null) {
				 throw unexpectedToken();
			 }
			 cs = compileInsertStatement(rangeVariables);
			 break;
			 case Tokens.UPDATE : if (routine.dataImpact != Routine.MODIFIES_SQL) {
				 throw Error.error(ErrorCode.X_42608, routine.getDataImpactString());
			 }
			 if (label != null) {
				 throw unexpectedToken();
			 }
			 cs = compileUpdateStatement(rangeVariables);
			 break;
			 case Tokens.DELETE : case Tokens.TRUNCATE : if (routine.dataImpact != Routine.MODIFIES_SQL) {
				 throw Error.error(ErrorCode.X_42608, routine.getDataImpactString());
			 }
			 if (label != null) {
				 throw unexpectedToken();
			 }
			 cs = compileDeleteStatement(rangeVariables);
			 break;
			 case Tokens.MERGE : if (routine.dataImpact != Routine.MODIFIES_SQL) {
				 throw Error.error(ErrorCode.X_42608, routine.getDataImpactString());
			 }
			 if (label != null) {
				 throw unexpectedToken();
			 }
			 cs = compileMergeStatement(rangeVariables);
			 break;
			 case Tokens.SET : if (label != null) {
				 throw unexpectedToken();
			 }
			 if (routine.isTrigger()) {
				 if (routine.triggerOperation == StatementTypes.DELETE_WHERE) {
					 throw unexpectedToken();
				 }
				 if (routine.triggerType != TriggerDef.BEFORE) {
					 throw unexpectedToken();
				 }
				 cs = compileTriggerSetStatement(routine.triggerTable, rangeVariables);
			 }
			 else {
				 cs = compileSetStatement(rangeVariables);
			 }
			 break;
			 case Tokens.CALL : {
				 if (label != null) {
					 throw unexpectedToken();
				 }
				 cs = compileCallStatement(rangeVariables, true);
				 Routine proc = ((StatementProcedure) cs).procedure;
				 if (proc != null) {
					 switch (routine.dataImpact) {
						 case Routine.CONTAINS_SQL : {
							 if (proc.dataImpact == Routine.READS_SQL || proc.dataImpact == Routine.MODIFIES_SQL) {
								 throw Error.error( ErrorCode.X_42608, routine.getDataImpactString());
							 }
						 }
						 case Routine.READS_SQL : {
							 if (routine.dataImpact == Routine.MODIFIES_SQL) {
								 throw Error.error( ErrorCode.X_42608, routine.getDataImpactString());
							 }
						 }
					 }
				 }
				 break;
			 }
			 case Tokens.RETURN : {
				 if (routine.isTrigger() || label != null) {
					 throw unexpectedToken();
				 }
				 read();
				 cs = compileReturnValue(routine, context);
				 break;
			 }
			 case Tokens.BEGIN : {
				 cs = compileCompoundStatement(routine, context, label);
				 break;
			 }
			 case Tokens.WHILE : {
				 if (routine.isTrigger()) {
					 throw unexpectedToken();
				 }
				 cs = compileWhile(routine, context, label);
				 break;
			 }
			 case Tokens.REPEAT : {
				 if (routine.isTrigger()) {
					 throw unexpectedToken();
				 }
				 cs = compileRepeat(routine, context, label);
				 break;
			 }
			 case Tokens.LOOP : {
				 if (routine.isTrigger()) {
					 throw unexpectedToken();
				 }
				 cs = compileLoop(routine, context, label);
				 break;
			 }
			 case Tokens.FOR : {
				 if (routine.isTrigger()) {
					 throw unexpectedToken();
				 }
				 cs = compileFor(routine, context, label);
				 break;
			 }
			 case Tokens.ITERATE : {
				 if (routine.isTrigger() || label != null) {
					 throw unexpectedToken();
				 }
				 cs = compileIterate();
				 break;
			 }
			 case Tokens.LEAVE : {
				 if (routine.isTrigger() || label != null) {
					 throw unexpectedToken();
				 }
				 cs = compileLeave(routine, context);
				 break;
			 }
			 case Tokens.IF : {
				 cs = compileIf(routine, context);
				 break;
			 }
			 case Tokens.CASE : {
				 cs = compileCase(routine, context);
				 break;
			 }
			 case Tokens.SIGNAL : {
				 if (routine.isTrigger() || label != null) {
					 throw unexpectedToken();
				 }
				 cs = compileSignal(routine, context, label);
				 break;
			 }
			 case Tokens.RESIGNAL : {
				 if (routine.isTrigger() || label != null) {
					 throw unexpectedToken();
				 }
				 cs = compileResignal(routine, context, label);
				 break;
			 }
			 default : return null;
		 }
		 cs.setRoot(routine);
		 cs.setParent(context);
		 return cs;
	 }
	 private Statement compileReturnValue(Routine routine, StatementCompound context) {
		 Expression e = XreadValueExpressionOrNull();
		 if (e == null) {
			 checkIsValue();
			 if (token.tokenValue == null) {
				 e = new ExpressionValue(null, null);
			 }
		 }
		 resolveOuterReferencesAndTypes(routine, context, e);
		 if (routine.isProcedure()) {
			 throw Error.error(ErrorCode.X_42602);
		 }
		 return new StatementExpression(session, compileContext, StatementTypes.RETURN, e);
	 }
	 private Statement compileIterate() {
		 readThis(Tokens.ITERATE);
		 HsqlName label = readNewSchemaObjectName(SchemaObject.LABEL, false);
		 return new StatementSimple(StatementTypes.ITERATE, label);
	 }
	 private Statement compileLeave(Routine routine, StatementCompound context) {
		 readThis(Tokens.LEAVE);
		 HsqlName label = readNewSchemaObjectName(SchemaObject.LABEL, false);
		 return new StatementSimple(StatementTypes.LEAVE, label);
	 }
	 private Statement compileWhile(Routine routine, StatementCompound context, HsqlName label) {
		 readThis(Tokens.WHILE);
		 Expression e = XreadBooleanValueExpression();
		 resolveOuterReferencesAndTypes(routine, context, e);
		 StatementExpression condition = new StatementExpression(session, compileContext, StatementTypes.CONDITION, e);
		 readThis(Tokens.DO);
		 Statement[] statements = compileSQLProcedureStatementList(routine, context);
		 readThis(Tokens.END);
		 readThis(Tokens.WHILE);
		 if (isSimpleName() && !isReservedKey()) {
			 if (label == null) {
				 throw unexpectedToken();
			 }
			 if (!label.name.equals(token.tokenString)) {
				 throw Error.error(ErrorCode.X_42508, token.tokenString);
			 }
			 read();
		 }
		 StatementCompound statement = new StatementCompound(StatementTypes.WHILE, label);
		 statement.setStatements(statements);
		 statement.setCondition(condition);
		 return statement;
	 }
	 private Statement compileRepeat(Routine routine, StatementCompound context, HsqlName label) {
		 readThis(Tokens.REPEAT);
		 Statement[] statements = compileSQLProcedureStatementList(routine, context);
		 readThis(Tokens.UNTIL);
		 Expression e = XreadBooleanValueExpression();
		 resolveOuterReferencesAndTypes(routine, context, e);
		 StatementExpression condition = new StatementExpression(session, compileContext, StatementTypes.CONDITION, e);
		 readThis(Tokens.END);
		 readThis(Tokens.REPEAT);
		 if (isSimpleName() && !isReservedKey()) {
			 if (label == null) {
				 throw unexpectedToken();
			 }
			 if (!label.name.equals(token.tokenString)) {
				 throw Error.error(ErrorCode.X_42508, token.tokenString);
			 }
			 read();
		 }
		 StatementCompound statement = new StatementCompound(StatementTypes.REPEAT, label);
		 statement.setStatements(statements);
		 statement.setCondition(condition);
		 return statement;
	 }
	 private Statement compileLoop(Routine routine, StatementCompound context, HsqlName label) {
		 readThis(Tokens.LOOP);
		 Statement[] statements = compileSQLProcedureStatementList(routine, context);
		 readThis(Tokens.END);
		 readThis(Tokens.LOOP);
		 if (isSimpleName() && !isReservedKey()) {
			 if (label == null) {
				 throw unexpectedToken();
			 }
			 if (!label.name.equals(token.tokenString)) {
				 throw Error.error(ErrorCode.X_42508, token.tokenString);
			 }
			 read();
		 }
		 StatementCompound result = new StatementCompound(StatementTypes.LOOP, label);
		 result.setStatements(statements);
		 return result;
	 }
	 private Statement compileFor(Routine routine, StatementCompound context, HsqlName label) {
		 readThis(Tokens.FOR);
		 Statement cursorStatement = compileCursorSpecification(ResultProperties.defaultPropsValue);
		 readThis(Tokens.DO);
		 Statement[] statements = compileSQLProcedureStatementList(routine, context);
		 readThis(Tokens.END);
		 readThis(Tokens.FOR);
		 if (isSimpleName() && !isReservedKey()) {
			 if (label == null) {
				 throw unexpectedToken();
			 }
			 if (!label.name.equals(token.tokenString)) {
				 throw Error.error(ErrorCode.X_42508, token.tokenString);
			 }
			 read();
		 }
		 StatementCompound result = new StatementCompound(StatementTypes.FOR, label);
		 result.setLoopStatement(cursorStatement);
		 result.setStatements(statements);
		 return result;
	 }
	 private Statement compileIf(Routine routine, StatementCompound context) {
		 HsqlArrayList list = new HsqlArrayList();
		 readThis(Tokens.IF);
		 Expression e = XreadBooleanValueExpression();
		 resolveOuterReferencesAndTypes(routine, context, e);
		 Statement statement = new StatementExpression(session, compileContext, StatementTypes.CONDITION, e);
		 list.add(statement);
		 readThis(Tokens.THEN);
		 Statement[] statements = compileSQLProcedureStatementList(routine, context);
		 for (int i = 0;
		 i < statements.length;
		 i++) {
			 list.add(statements[i]);
		 }
		 while (token.tokenType == Tokens.ELSEIF) {
			 read();
			 e = XreadBooleanValueExpression();
			 resolveOuterReferencesAndTypes(routine, context, e);
			 statement = new StatementExpression(session, compileContext, StatementTypes.CONDITION, e);
			 list.add(statement);
			 readThis(Tokens.THEN);
			 statements = compileSQLProcedureStatementList(routine, context);
			 for (int i = 0;
			 i < statements.length;
			 i++) {
				 list.add(statements[i]);
			 }
		 }
		 if (token.tokenType == Tokens.ELSE) {
			 read();
			 e = Expression.EXPR_TRUE;
			 statement = new StatementExpression(session, compileContext, StatementTypes.CONDITION, e);
			 list.add(statement);
			 statements = compileSQLProcedureStatementList(routine, context);
			 for (int i = 0;
			 i < statements.length;
			 i++) {
				 list.add(statements[i]);
			 }
		 }
		 readThis(Tokens.END);
		 readThis(Tokens.IF);
		 statements = new Statement[list.size()];
		 list.toArray(statements);
		 StatementCompound result = new StatementCompound(StatementTypes.IF, null);
		 result.setStatements(statements);
		 return result;
	 }
	 private Statement compileCase(Routine routine, StatementCompound context) {
		 HsqlArrayList list = new HsqlArrayList();
		 Expression condition = null;
		 Statement statement;
		 Statement[] statements;
		 readThis(Tokens.CASE);
		 if (token.tokenType == Tokens.WHEN) {
			 list = readCaseWhen(routine, context);
		 }
		 else {
			 list = readSimpleCaseWhen(routine, context);
		 }
		 if (token.tokenType == Tokens.ELSE) {
			 read();
			 condition = Expression.EXPR_TRUE;
			 statement = new StatementExpression(session, compileContext, StatementTypes.CONDITION, condition);
			 list.add(statement);
			 statements = compileSQLProcedureStatementList(routine, context);
			 for (int i = 0;
			 i < statements.length;
			 i++) {
				 list.add(statements[i]);
			 }
		 }
		 readThis(Tokens.END);
		 readThis(Tokens.CASE);
		 statements = new Statement[list.size()];
		 list.toArray(statements);
		 StatementCompound result = new StatementCompound(StatementTypes.IF, null);
		 result.setStatements(statements);
		 return result;
	 }
	 private HsqlArrayList readSimpleCaseWhen(Routine routine, StatementCompound context) {
		 HsqlArrayList list = new HsqlArrayList();
		 Expression condition = null;
		 Statement statement;
		 Statement[] statements;
		 Expression predicand = XreadRowValuePredicand();
		 do {
			 readThis(Tokens.WHEN);
			 do {
				 Expression newCondition = XreadPredicateRightPart(predicand);
				 if (predicand == newCondition) {
					 newCondition = new ExpressionLogical(predicand, XreadRowValuePredicand());
				 }
				 resolveOuterReferencesAndTypes(routine, context, newCondition);
				 if (condition == null) {
					 condition = newCondition;
				 }
				 else {
					 condition = new ExpressionLogical(OpTypes.OR, condition, newCondition);
				 }
				 if (token.tokenType == Tokens.COMMA) {
					 read();
				 }
				 else {
					 break;
				 }
			 }
			 while (true);
			 statement = new StatementExpression(session, compileContext, StatementTypes.CONDITION, condition);
			 list.add(statement);
			 readThis(Tokens.THEN);
			 statements = compileSQLProcedureStatementList(routine, context);
			 for (int i = 0;
			 i < statements.length;
			 i++) {
				 list.add(statements[i]);
			 }
			 if (token.tokenType != Tokens.WHEN) {
				 break;
			 }
		 }
		 while (true);
		 return list;
	 }
	 private HsqlArrayList readCaseWhen(Routine routine, StatementCompound context) {
		 HsqlArrayList list = new HsqlArrayList();
		 Expression condition = null;
		 Statement statement;
		 Statement[] statements;
		 do {
			 readThis(Tokens.WHEN);
			 condition = XreadBooleanValueExpression();
			 resolveOuterReferencesAndTypes(routine, context, condition);
			 statement = new StatementExpression(session, compileContext, StatementTypes.CONDITION, condition);
			 list.add(statement);
			 readThis(Tokens.THEN);
			 statements = compileSQLProcedureStatementList(routine, context);
			 for (int i = 0;
			 i < statements.length;
			 i++) {
				 list.add(statements[i]);
			 }
			 if (token.tokenType != Tokens.WHEN) {
				 break;
			 }
		 }
		 while (true);
		 return list;
	 }
	 private Statement compileSignal(Routine routine, StatementCompound context, HsqlName label) {
		 readThis(Tokens.SIGNAL);
		 readThis(Tokens.SQLSTATE);
		 String sqlState = parseSQLStateValue();
		 StatementSimple cs = new StatementSimple(StatementTypes.SIGNAL, sqlState);
		 return cs;
	 }
	 private Statement compileResignal(Routine routine, StatementCompound context, HsqlName label) {
		 String sqlState = null;
		 readThis(Tokens.RESIGNAL);
		 if (readIfThis(Tokens.SQLSTATE)) {
			 sqlState = parseSQLStateValue();
		 }
		 StatementSimple cs = new StatementSimple(StatementTypes.RESIGNAL, sqlState);
		 return cs;
	 }
	 private ColumnSchema readRoutineParameter(Routine routine, boolean isParam) {
		 HsqlName hsqlName = null;
		 byte parameterMode = SchemaObject.ParameterModes.PARAM_IN;
		 if (isParam) {
			 switch (token.tokenType) {
				 case Tokens.IN : read();
				 break;
				 case Tokens.OUT : if (routine.getType() != SchemaObject.PROCEDURE) {
					 throw unexpectedToken();
				 }
				 read();
				 parameterMode = SchemaObject.ParameterModes.PARAM_OUT;
				 break;
				 case Tokens.INOUT : if (routine.getType() != SchemaObject.PROCEDURE) {
					 if (!routine.isAggregate()) {
						 throw unexpectedToken();
					 }
				 }
				 read();
				 parameterMode = SchemaObject.ParameterModes.PARAM_INOUT;
				 break;
			 default : }
		 }
		 if (!isReservedKey()) {
			 hsqlName = readNewDependentSchemaObjectName(routine.getName(), SchemaObject.PARAMETER);
		 }
		 Type typeObject = readTypeDefinition(true);
		 ColumnSchema column = new ColumnSchema(hsqlName, typeObject, true, false, null);
		 if (isParam) {
			 column.setParameterMode(parameterMode);
		 }
		 return column;
	 }
	 void resolveOuterReferencesAndTypes(Routine routine, StatementCompound context, Expression e) {
		 RangeVariable[] rangeVars = routine.getParameterRangeVariables();
		 if (context != null) {
			 rangeVars = context.getRangeVariables();
		 }
		 resolveOuterReferencesAndTypes(rangeVars, e);
	 }
}",1,0,0,0
"static void printUsageAndExit() {
	 System.err.println(""Usage: fsck [opts] "");
	 System.err.println("" where [opts] are:"");
	 System.err.println("" -details Display full report of all regions."");
	 System.err.println("" -timelag {
	timeInSeconds}
	 Process only regions that "" + "" have not experienced any metadata updates in the last "" + "" {
		{
		timeInSeconds}
		 seconds."");
		 System.err.println("" -fix Try to fix some of the errors."");
		 System.err.println("" -sleepBeforeRerun {
		timeInSeconds}
		 Sleep this many seconds"" + "" before checking if the fix worked if run with -fix"");
		 System.err.println("" -summary Print only summary of the tables and status."");
		 Runtime.getRuntime().exit(-2);
	 }
	 public static void main(String [] args) throws Exception {
		 Configuration conf = HBaseConfiguration.create();
		 conf.set(""fs.defaultFS"", conf.get(""hbase.rootdir""));
		 HBaseFsck fsck = new HBaseFsck(conf);
		 long sleepBeforeRerun = DEFAULT_SLEEP_BEFORE_RERUN;
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 String cmd = args[i];
			 if (cmd.equals(""-details"")) {
				 fsck.displayFullReport();
			 }
			 else if (cmd.equals(""-timelag"")) {
				 if (i == args.length - 1) {
					 System.err.println(""HBaseFsck: -timelag needs a value."");
					 printUsageAndExit();
				 }
				 try {
					 long timelag = Long.parseLong(args[i+1]);
					 fsck.setTimeLag(timelag);
				 }
				 catch (NumberFormatException e) {
					 System.err.println(""-timelag needs a numeric value."");
					 printUsageAndExit();
				 }
				 i++;
			 }
			 else if (cmd.equals(""-sleepBeforeRerun"")) {
				 if (i == args.length - 1) {
					 System.err.println(""HBaseFsck: -sleepBeforeRerun needs a value."");
					 printUsageAndExit();
				 }
				 try {
					 sleepBeforeRerun = Long.parseLong(args[i+1]);
				 }
				 catch (NumberFormatException e) {
					 System.err.println(""-sleepBeforeRerun needs a numeric value."");
					 printUsageAndExit();
				 }
				 i++;
			 }
			 else if (cmd.equals(""-fix"")) {
				 fsck.setFixErrors(true);
			 }
			 else if (cmd.equals(""-summary"")) {
				 fsck.setSummary();
			 }
			 else {
				 String str = ""Unknown command line option : "" + cmd;
				 LOG.info(str);
				 System.out.println(str);
				 printUsageAndExit();
			 }
		 }
		 int code = fsck.doWork();
		 if (fsck.shouldRerun()) {
			 try {
				 LOG.info(""Sleeping "" + sleepBeforeRerun + ""ms before re-checking after fix..."");
				 Thread.sleep(sleepBeforeRerun);
			 }
			 catch (InterruptedException ie) {
				 Runtime.getRuntime().exit(code);
			 }
			 fsck.setFixErrors(false);
			 code = fsck.doWork();
		 }
		 Runtime.getRuntime().exit(code);
	 }
}",0,0,1,0
"public class HttpSPMFileSystem extends SPMFileSystem{
	 boolean unknownHost;
	 private URL repository;
	 private HttpStatusDialog statusDialog;
	 private boolean isDownloading;
	 private Vector callbacks;
	 private Document pluginsDoc, objectsDoc, startupDoc, toolsDoc;
	 private File file;
	 private static final String[] EMPTY_STRING_ARRAY = new String[0];
	 public HttpSPMFileSystem( URL rep ) {
		 super();
		 unknownHost = false;
		 repository = rep;
		 pluginsDoc = null;
		 objectsDoc = null;
		 startupDoc = null;
		 toolsDoc = null;
	 }
	 public void setRepository( URL rep ) {
		 pluginsInfo = new Vector();
		 toolInfo = new Vector();
		 objectInfo = new Vector();
		 startupInfo = new Vector();
		 initialized = false;
		 unknownHost = false;
		 repository = rep;
		 pluginsDoc = null;
		 objectsDoc = null;
		 startupDoc = null;
		 toolsDoc = null;
	 }
	 public void getRemoteInfo( Runnable cb ) {
		 if ( !initialized ) {
			 super.initialize();
			 unknownHost = false;
			 if ( !isDownloading ) {
				 callbacks = new Vector();
				 callbacks.add( cb );
				 isDownloading = true;
				 statusDialog = new HttpStatusDialog();
				 ( new Thread() {
					 public void run() {
						 scanPlugins();
						 if ( !unknownHost ) scanToolScripts();
						 if ( !unknownHost ) scanObjectScripts();
						 if ( !unknownHost ) scanStartupScripts();
						 isDownloading = false;
						 initialized = true;
						 for ( int i = 0;
						 i < callbacks.size();
						 ++i ) ( (Runnable) callbacks.elementAt( i ) ).run();
						 statusDialog.dispose();
						 statusDialog = null;
					 }
				 }
				 ).start();
			 }
			 else callbacks.add( cb );
		 }
		 else cb.run();
	 }
	 public void initialize() {
		 super.initialize();
		 statusDialog = null;
		 scanPlugins();
		 if ( !unknownHost ) scanToolScripts();
		 if ( !unknownHost ) scanObjectScripts();
		 if ( !unknownHost ) scanStartupScripts();
		 initialized = true;
	 }
	 private void scanPlugins() {
		 if (! SPManagerFrame.getParameters().getUseCache() ) SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningPluginsFrom"", new String[]{
		repository.toString()}
		 ), 5000 );
		 else {
			 String s = repository.toString();
			 s = s.substring(0, s.lastIndexOf('/'));
			 s = s + ""/cgi-bin/scripts.cgi?Plugins%20"" + SPManagerPlugin.AOI_VERSION;
			 SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningPluginsFrom"", new String[]{
			s}
			 ), 5000 );
		 }
		 if ( statusDialog != null ) statusDialog.setText( SPMTranslate.text( ""scanningPlugins"" ) );
		 pluginsInfo = new Vector();
		 if ( SPManagerFrame.getParameters().getUseCache() ) {
			 scanFiles( ""Plugins"", pluginsInfo );
		 }
		 else {
			 try {
				 URL pluginsURL = new URL( repository, ""Plugins/"" );
				 scanFiles( pluginsURL, pluginsInfo, "".jar"" );
			 }
			 catch ( MalformedURLException e ) {
				 e.printStackTrace();
			 }
		 }
	 }
	 private void scanToolScripts() {
		 if ( ! SPManagerFrame.getParameters().getUseCache() ) SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningToolScriptsFrom"", new String[]{
		repository.toString()}
		 ), 5000 );
		 else {
			 String s = repository.toString();
			 s = s.substring(0, s.lastIndexOf('/'));
			 s = s + ""/cgi-bin/scripts.cgi?Scripts/Tools%20"" + SPManagerPlugin.AOI_VERSION;
			 SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningToolScriptsFrom"", new String[]{
			s}
			 ), 5000 );
		 }
		 if ( statusDialog != null ) statusDialog.setText( SPMTranslate.text( ""scanningToolScripts"" ) );
		 toolInfo = new Vector();
		 if ( SPManagerFrame.getParameters().getUseCache() ) {
			 scanFiles( ""Scripts/Tools"", toolInfo );
		 }
		 else {
			 try {
				 URL toolScriptURL = new URL( repository, ""Scripts/Tools/"" );
				 scanFiles( toolScriptURL, toolInfo, "".bsh"" );
			 }
			 catch ( MalformedURLException e ) {
				 e.printStackTrace();
			 }
		 }
	 }
	 private void scanObjectScripts() {
		 if ( ! SPManagerFrame.getParameters().getUseCache() ) SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningObjectScriptsFrom"", new String[]{
		repository.toString()}
		 ), 5000 );
		 else {
			 String s = repository.toString();
			 s = s.substring(0, s.lastIndexOf('/'));
			 s = s + ""/cgi-bin/scripts.cgi?Scripts/Objects%20"" + SPManagerPlugin.AOI_VERSION;
			 SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningObjectScriptsFrom"", new String[]{
			s}
			 ), 5000 );
		 }
		 if ( statusDialog != null ) statusDialog.setText( SPMTranslate.text( ""scanningObjectScripts"" ) );
		 objectInfo = new Vector();
		 if ( SPManagerFrame.getParameters().getUseCache() ) {
			 scanFiles( ""Scripts/Objects"", objectInfo );
		 }
		 else {
			 try {
				 URL objectScriptURL = new URL( repository, ""Scripts/Objects/"" );
				 scanFiles( objectScriptURL, objectInfo, "".bsh"" );
			 }
			 catch ( MalformedURLException e ) {
				 e.printStackTrace();
			 }
		 }
	 }
	 private void scanStartupScripts() {
		 if ( ! SPManagerFrame.getParameters().getUseCache() ) SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningStartupScriptsFrom"", new String[]{
		repository.toString()}
		 ), 5000 );
		 else {
			 String s = repository.toString();
			 s = s.substring(0, s.lastIndexOf('/'));
			 s = s + ""/cgi-bin/scripts.cgi?Scripts/Startup%20"" + SPManagerPlugin.AOI_VERSION;
			 SPManagerFrame.getInstance().setRemoteStatusText( SPMTranslate.text( ""scanningStartupScriptsFrom"", new String[]{
			s}
			 ), 5000 );
		 }
		 if ( statusDialog != null ) statusDialog.setText( SPMTranslate.text( ""scanningStartupScripts"" ) );
		 startupInfo = new Vector();
		 if ( SPManagerFrame.getParameters().getUseCache() ) {
			 scanFiles( ""Scripts/Startup"", startupInfo );
		 }
		 else {
			 try {
				 URL startupScriptURL = new URL( repository, ""Scripts/Startup/"" );
				 scanFiles( startupScriptURL, startupInfo, "".bsh"" );
			 }
			 catch ( MalformedURLException e ) {
				 e.printStackTrace();
			 }
		 }
	 }
	 private void scanFiles( URL from, Vector addTo, String suffix ) {
		 SPMObjectInfo info;
		 boolean eligible;
		 Vector v = null;
		 try {
			 Object obj = from.getContent();
			 if ( obj instanceof InputStream ) {
				 v = htmlFindFilesVersioning( (InputStream) ( obj ), from );
			 }
			 ( (InputStream) obj ).close();
		 }
		 catch ( IOException e ) {
			 if ( e instanceof UnknownHostException ) {
				 JOptionPane.showMessageDialog( null, from.toString() + "": "" + SPMTranslate.text( ""unknownHost"" ), SPMTranslate.text( ""error"" ), JOptionPane.ERROR_MESSAGE );
				 unknownHost = true;
			 }
			 else if ( e instanceof FileNotFoundException ) {
				 JOptionPane.showMessageDialog( null, from.toString() + "": "" + SPMTranslate.text( ""fileNotFound"" ), SPMTranslate.text( ""error"" ), JOptionPane.ERROR_MESSAGE );
				 unknownHost = true;
			 }
			 else e.printStackTrace();
		 }
		 if ( v != null ) {
			 String[] sarray = (String[]) v.toArray(EMPTY_STRING_ARRAY);
			 Arrays.sort(sarray);
			 for ( int i = 0;
			 i < sarray.length;
			 i++ ) {
				 String s = sarray[i];
				 System.out.println(s);
				 if ( s.endsWith( suffix ) ) {
					 eligible = true;
					 String name = s.substring( 0, s.length() - 4 );
					 if ( suffix.equals( "".jar"" ) ) {
						 eligible = true;
						 String sxml;
						sxml = s.substring(0, s.lastIndexOf('/')) + ""extensions.xml"";
						 URL xmlURL = null;
						try {
							 xmlURL = new URL(from, sxml);
						}
						 catch (MalformedURLException e) {
							 e.printStackTrace();
						}
						 try {
							 HttpURLConnection.setFollowRedirects( false );
							 HttpURLConnection conn =(HttpURLConnection) xmlURL.openConnection();
							 if (conn.getResponseCode()!= HttpURLConnection.HTTP_OK) {
								eligible = false;
							 }
							 else {
								sxml = s.substring(0, s.lastIndexOf('.')) + "".xml"";
								xmlURL = new URL(from, sxml);
								conn = (HttpURLConnection)xmlURL.openConnection();
								if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
									 eligible = false;
								}
							 }
							 if (eligible) {
								InputStreamReader in = new InputStreamReader(conn.getInputStream());
								in.close();
							 }
						}
						 catch ( IOException e ) {
							 eligible = false;
						 }
					 }
					 info = null;
					 if ( eligible ) {
						System.out.println(""adding: "" + s);
						 try {
							 info = new SPMObjectInfo( new URL( from, s ) );
						 }
						 catch ( Exception e ) {
							 e.printStackTrace();
						 }
					 }
					 if ( info != null ) addTo.add( info );
				 }
			 }
		 }
	 }
	 private void scanFiles( String dir, Vector addTo ) {
		 URL cgiUrl = null;
		 try {
			 String s = repository.toString();
			 String err = """";
			 s = s.substring(0, s.lastIndexOf('/'));
			 cgiUrl = new URL( s + ""/cgi-bin/scripts.cgi?"" + dir + ""%20"" + SPManagerPlugin.AOI_VERSION );
			 String content = null;
			 boolean received = false;
			 int attempts = 0;
			 System.out.println( cgiUrl );
			 while (!received && attempts++ < 5 ) {
				HttpURLConnection conn = (HttpURLConnection) cgiUrl.openConnection();
				conn.setRequestProperty(""Accept-Encoding"", ""deflate"");
				conn.setRequestProperty(""X-AOI-Version"", SPManagerPlugin.AOI_VERSION);
				conn.setRequestProperty(""X-AOI-Dir"", dir);
				if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
					 err = conn.getResponseMessage();
					 Thread.sleep(250);
					 continue;
				}
				InputStream is= conn.getInputStream();
				 BufferedInputStream bis = new BufferedInputStream( is );
				 Document doc = SPManagerUtils.builder.parse( bis );
				 NodeList tst = doc.getElementsByTagName( ""scriptcollection"" );
				 if (tst.getLength() > 0) {
					 received = true;
					 NodeList nl = doc.getElementsByTagName( ""scriptreference"" );
					 Node script;
					 String location = """";
					 long length = 0;
					 for (int i = 0;
					 i < nl.getLength();
					 i++) {
						 Node n = nl.item(i);
						 NodeList nnl = n.getChildNodes();
						 script = null;
						 location = null;
						 for (int j = 0;
						 j < nnl.getLength();
						 j++) {
							 if ( ""scriptlocation"".equals( nnl.item(j).getNodeName() ) ) {
								 location = repository.toString() + ""/"" + dir +""/"" + nnl.item(j).getChildNodes().item(0).getNodeValue();
							 }
							 else if ( ""scriptlength"".equals( nnl.item(j).getNodeName() ) ) {
								 length = Long.parseLong( nnl.item(j).getChildNodes().item(0).getNodeValue() );
							 }
							 else if (""extension"".equals(nnl.item(j).getNodeName()))script = nnl.item(j);
							 else if (""script"".equals( nnl.item(j).getNodeName() )) script = nnl.item(j);
						 }
						 if ( script != null && location != null ) {
							 addTo.add( new SPMObjectInfo( script, new URL(location) , length) );
						 }
					 }
				 }
				 bis.close();
			 }
			 if (!received) {
				 JOptionPane.showMessageDialog( null, cgiUrl.toString() + "": "" + SPMTranslate.text( ""scriptServerFailed"" ), SPMTranslate.text( ""error"" ) + "" "" + err, JOptionPane.ERROR_MESSAGE );
				 return;
			 }
		 }
		 catch ( Exception e ) {
			 if ( e instanceof UnknownHostException ) {
				 JOptionPane.showMessageDialog( null, cgiUrl.toString() + "": "" + SPMTranslate.text( ""unknownHost"" ), SPMTranslate.text( ""error"" ), JOptionPane.ERROR_MESSAGE );
				 unknownHost = true;
			 }
			 else if ( e instanceof FileNotFoundException ) {
				 JOptionPane.showMessageDialog( null, cgiUrl.toString() + "": "" + SPMTranslate.text( ""fileNotFound"" ), SPMTranslate.text( ""error"" ), JOptionPane.ERROR_MESSAGE );
				 unknownHost = true;
			 }
			 else {
				 JOptionPane.showMessageDialog( null, cgiUrl.toString() + "": "" + SPMTranslate.text( ""httpError"" ), SPMTranslate.text( ""error"" ) + "": "" + e.getMessage(), JOptionPane.ERROR_MESSAGE );
				 e.printStackTrace();
			 }
		 }
		 SPMObjectInfo left, right;
		 int i, j;
		 for (i = addTo.size()-1;
		 i > 0;
		 i--) {
			 j = i;
			 right = (SPMObjectInfo) addTo.get(i);
			 while (j > 0) {
				 left = (SPMObjectInfo) addTo.get(j-1);
				 if (right.getName().compareTo(left.getName()) >= 0) break;
				 j--;
			 }
			 if (j < i) {
				 addTo.remove(i);
				 addTo.add(j, right);
			 }
		 }
	 }
	 public static long downloadRemoteTextFile( URL from, String fileName, long size, StatusDialog status, long totalDownload, long downloadedLength, ArrayList errors ) {
		 BufferedReader in = null;
		 BufferedWriter file = null;
		 long initialValue = downloadedLength;
		 try {
			 HttpURLConnection conn = (HttpURLConnection) from.openConnection();
			 conn.setRequestProperty(""Cache-Control"", ""no-cache"");
			 if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
				new BStandardDialog(""SPManager"", new String[] {
				SPMTranslate.text(""httpError""),conn.getResponseMessage() +"" ("" + conn.getResponseCode() + "")"", }
				, BStandardDialog.ERROR) .showMessageDialog(SPManagerFrame.getInstance());
				return 0;
			 }
			 in = new BufferedReader( new InputStreamReader( conn.getInputStream() ) );
			 file = new BufferedWriter( new FileWriter(fileName) );
			 double a;
			 double b = totalDownload;
			 int value;
			 int newValue;
			 value = status.getBarValue();
			 int i = in.read();
			 while ( i != -1 ) {
				 file.write( i );
				 i = in.read();
				 if ( status != null ) {
					 ++downloadedLength;
					 a = downloadedLength;
					 newValue = (int) Math.round( ( a * 100.0 ) / b );
					 if ( newValue > value ) {
						 status.setBarValue( newValue );
						 status.setProgressText( newValue + ""%"" );
						 value = newValue;
					 }
				 }
			 }
			 file.flush();
			 file.close();
			 long received = downloadedLength - initialValue;
			 if (received != size)throw new IOException(""SPManager: file incomplete."" + "" Only received "" + received + "" bytes of "" + size);
		 }
		 catch ( Exception e) {
			 errors.add(SPMTranslate.text(""error"") + ""("" + fileName + "")"" + e);
		 }
		 finally {
			 try {
				 if ( in != null ) in.close();
				 if ( file != null ) file.close();
			 }
			 catch ( IOException e ) {
				System.out.println(""SPManager: error closing "" + fileName + "": "" + e);
			 }
		 }
		 return downloadedLength - initialValue;
	 }
	 public static long downloadRemoteBinaryFile( URL from, String fileName, long size, StatusDialog status, long totalDownload, long downloadedLength, ArrayList errors ) {
		System.out.println(""download: size="" + size + "";
		 total="" + totalDownload + "";
		 downloaded="" + downloadedLength);
		File update = new File(fileName);
		Thread thread = Thread.currentThread();
		 BufferedInputStream in = null;
		 BufferedOutputStream file = null;
		 long initialValue = downloadedLength;
		 try {
			 HttpURLConnection conn = (HttpURLConnection) from.openConnection();
			 conn.setRequestProperty(""Cache-Control"", ""no-cache"");
			 if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
				new BStandardDialog(""SPManager"", new String[] {
				SPMTranslate.text(""httpError""),conn.getResponseMessage() +"" ("" + conn.getResponseCode() + "")"", }
				, BStandardDialog.ERROR) .showMessageDialog(SPManagerFrame.getInstance());
				return 0;
			 }
			 in = new BufferedInputStream( conn.getInputStream() );
			 file = new BufferedOutputStream(new FileOutputStream(update));
			 double a;
			 double b = totalDownload;
			 int value;
			 int newValue;
			 value = status.getBarValue();
			 String mod="""", newMod;
			 if (b <= 0) status.setIdle(true);
			 int result = 0;
			 while ( ( result = in.read() ) != -1 ) {
				if (thread.interrupted()) {
					 thread.interrupt();
					 if (!update.delete()) {
						RandomAccessFile raf = new RandomAccessFile(update, ""rw"");
						raf.setLength(0);
						raf.close();
					 }
					 throw new InterruptedException(""download cancelled: "" + fileName);
				}
				 file.write( (byte) result );
				 ++downloadedLength;
				 a = downloadedLength;
				if (b > a) {
					 newValue = (int) Math.round( a * 100.0 / b );
					 if ( newValue > value ) {
						status.setBarValue( newValue );
						status.setProgressText( newValue + ""%"" );
						value = newValue;
					 }
				}
				else {
					 newMod = (a > 1000000 ? ((int) (a/100000.0)) + "" MB"" : a > 1000 ? ((int) (a/1000.0)) + "" kB"" : a + "" bytes"");
					 if (!newMod.equals(mod)) status.setProgressText(newMod);
				}
			 }
			 file.flush();
			 file.close();
			 if (size > 0) {
				long received = downloadedLength - initialValue;
				if (received != size) throw new IOException(""SPManager: file incomplete."" + "" Only received "" + received + "" bytes of "" + size);
			 }
			 if (fileName.endsWith("".jar"") || fileName.endsWith("".zip"")) {
				new ZipFile(update);
				System.out.println(""SPManager: ZipFile ok"");
			 }
		 }
		 catch ( Exception e) {
			 errors.add(SPMTranslate.text(""error"") + ""("" + fileName + "")"" + e);
		 }
		 finally {
			 try {
				 if ( in != null ) in.close();
				 if ( file != null ) file.close();
			 }
			 catch ( IOException e ) {
				System.out.println(""SPManager: error closing "" + fileName + "": "" + e);
			 }
		 }
		 return downloadedLength - initialValue;
	 }
	 private Vector htmlFindFiles( InputStream is ) {
		 Vector v = new Vector();
		 HtmlParserCallback callback = new HtmlParserCallback( v );
		 BufferedReader bufferedReader = new BufferedReader( new InputStreamReader( is ) );
		 try {
			 new ParserDelegator().parse( bufferedReader, callback, false );
			 is.close();
		 }
		 catch ( IOException e ) {
			 e.printStackTrace();
		 }
		 return v;
	 }
	 private Vector htmlFindFilesVersioning( InputStream is, URL from ) {
		 Vector v = new Vector();
		 HtmlVersioningParserCallback callback = new HtmlVersioningParserCallback( v, from );
		 BufferedReader bufferedReader = new BufferedReader( new InputStreamReader( is ) );
		 try {
			 new ParserDelegator().parse( bufferedReader, callback, false );
		 }
		 catch ( IOException e ) {
			 e.printStackTrace();
		 }
		 return v;
	 }
	 private class HtmlParserCallback extends HTMLEditorKit.ParserCallback {
		 private Vector v;
		 public HtmlParserCallback( Vector v ) {
			 this.v = v;
		 }
		 public void handleText( char[] data, int pos ) {
		 }
		 public void handleStartTag( HTML.Tag t, MutableAttributeSet a, int pos ) {
			 if ( t == HTML.Tag.A ) {
				 String s = (String) a.getAttribute( HTML.Attribute.HREF );
				 v.add( s );
			 }
		 }
		 public void handleEndTag( HTML.Tag t, MutableAttributeSet a, int pos ) {
		 }
	 }
	 private class HtmlVersioningParserCallback extends HTMLEditorKit.ParserCallback {
		 private Vector v;
		 private URL from;
		 public HtmlVersioningParserCallback( Vector v, URL from ) {
			 this.v = v;
			 this.from = from;
		 }
		 public void handleText( char[] data, int pos ) {
		 }
		 private String findCorrectVersion( String AoIversion, String[] versions ) {
			 int maj;
			 int min;
			 String[] tmps = AoIversion.split( ""[^0-9]"" );
			 maj = Integer.parseInt( tmps[0] );
			 min = Integer.parseInt( tmps[1] );
			 String result = null;
			 while ( result == null && ( maj >= 0 ) ) {
				 for ( int i = 0;
				 i < versions.length;
				 ++i ) {
					 String[] versionsplit = versions[i].split( "" "" );
					 tmps = versionsplit[0].split( ""[^0-9]"" );
					 if ( ( maj == Integer.parseInt( tmps[0] ) ) && ( min == Integer.parseInt( tmps[1] ) ) ) result = versionsplit[2];
				 }
				 if ( result == null ) {
					 --min;
					 if ( min < 0 ) {
						 min = 9;
						 --maj;
					 }
				 }
			 }
			 if ( result == null ) {
				 return """";
			 }
			 if ( result.equals( ""-"" ) ) {
				 return """";
			 }
			 return result;
		 }
		 public void handleStartTag( HTML.Tag t, MutableAttributeSet a, int pos ) {
			 if ( t == HTML.Tag.A ) {
				 String s = (String) a.getAttribute( HTML.Attribute.HREF );
				 if ( s.endsWith( ""/"" ) ) {
					 String[] ss = s.split( ""/"" );
					 s = ss[ss.length - 1];
					 String txt = s + ""/"" + s + "".txt"";
					 try {
						 URL fileURL = new URL( from, txt );
						 HttpURLConnection.setFollowRedirects( false );
						 HttpURLConnection connection = (HttpURLConnection) fileURL.openConnection();
						 String header = connection.getHeaderField( 0 );
						 InputStreamReader in = new InputStreamReader( connection.getInputStream() );
						 int status = 0;
						 String content = """";
						 while ( status != -1 ) {
							 try {
								 status = in.read();
								 if ( status != -1 ) content += (char) status;
							 }
							 catch ( IOException e ) {
								 e.printStackTrace();
							 }
						 }
						 in.close();
						 String[] versions = content.split( ""\n"" );
						 String name = findCorrectVersion( SPManagerPlugin.AOI_VERSION, versions );
						 if ( !name.equals( """" ) ) v.add( s + ""/"" + name );
					 }
					 catch ( IOException e ) {
						 return;
					 }
				 }
			 }
		 }
		 public void handleEndTag( HTML.Tag t, MutableAttributeSet a, int pos ) {
		 }
	 }
	 private class HttpStatusDialog extends BDialog {
		 private BLabel label;
		 private BProgressBar progressBar;
		 public HttpStatusDialog() {
			 super( SPManagerPlugin.getFrame(), SPMTranslate.text( ""remoteStatus"" ), false );
			 ColumnContainer cc = new ColumnContainer();
			 LayoutInfo layout = new LayoutInfo( LayoutInfo.CENTER, LayoutInfo.NONE, new Insets( 10, 10, 10, 10 ), new Dimension( 0, 0 ) );
			 cc.add( label = SPMTranslate.bLabel( ""status"" ), layout );
			 label.setText( SPMTranslate.text( ""scanningPlugins"" ) );
			 layout = new LayoutInfo( LayoutInfo.CENTER, LayoutInfo.HORIZONTAL, new Insets( 10, 10, 10, 10 ), new Dimension( 0, 0 ) );
			 cc.add( progressBar = new BProgressBar(), layout );
			 progressBar.setIndeterminate( true );
			 setContent( cc );
			 pack();
			 centerAndSizeWindow();
			 setVisible( true );
			 layoutChildren();
			 addEventLink( WindowClosingEvent.class, this, ""doClose"" );
		 }
		 public void setText( String text ) {
			 label.setText( text );
			 layoutChildren();
		 }
		 private void centerAndSizeWindow() {
			 UIUtilities.centerDialog(this, (WindowWidget) getParent());
		 }
		 private void doClose() {
			 setVisible( false );
		 }
	 }
}",1,0,0,0
"private void executeGet(Tree statement) throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException {
	 if (!CliMain.isConnected() || !hasKeySpace()) return;
	 long startTime = System.currentTimeMillis();
	 Tree columnFamilySpec = statement.getChild(0);
	 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
	 ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
	 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
	 CfDef cfDef = getCfDef(columnFamily);
	 boolean isSuper = cfDef.column_type.equals(""Super"");
	 byte[] superColumnName = null;
	 ByteBuffer columnName;
	 Tree typeTree = null;
	 Tree limitTree = null;
	 int limit = 1000000;
	 if (statement.getChildCount() >= 2) {
		 if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE) {
			 typeTree = statement.getChild(1).getChild(0);
			 if (statement.getChildCount() == 3) limitTree = statement.getChild(2).getChild(0);
		 }
		 else {
			 limitTree = statement.getChild(1).getChild(0);
		 }
	 }
	 if (limitTree != null) {
		 limit = Integer.parseInt(limitTree.getText());
		 if (limit == 0) {
			 throw new IllegalArgumentException(""LIMIT should be greater than zero."");
		 }
	 }
	 if (columnSpecCnt == 0) {
		 doSlice(keySpace, key, columnFamily, superColumnName, limit);
		 return;
	 }
	 else if (columnSpecCnt == 1) {
		 columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));
		 if (isSuper) {
			 superColumnName = columnName.array();
			 doSlice(keySpace, key, columnFamily, superColumnName, limit);
			 return;
		 }
	 }
	 else if (columnSpecCnt == 2) {
		 superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();
		 columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));
	 }
	 else {
		 sessionState.out.println(""Invalid row, super column, or column specification."");
		 return;
	 }
	 AbstractType<T> validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));
	 ColumnPath path = new ColumnPath(columnFamily);
	 if(superColumnName != null) path.setSuper_column(superColumnName);
	 path.setColumn(columnName);
	 if (isCounterCF(cfDef)) {
		 doGetCounter(key, path);
		 elapsedTime(startTime);
		 return;
	 }
	 Column column;
	 try {
		 column = thriftClient.get(key, path, consistencyLevel).column;
	 }
	 catch (NotFoundException e) {
		 sessionState.out.println(""Value was not found"");
		 elapsedTime(startTime);
		 return;
	 }
	 byte[] columnValue = column.getValue();
	 String valueAsString;
	 if (typeTree != null) {
		 String typeName = CliUtils.unescapeSQLString(typeTree.getText());
		 AbstractType<T> valueValidator = getFormatType(typeName);
		 valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));
		 updateColumnMetaData(cfDef, columnName, valueValidator.toString());
	 }
	 else {
		 valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));
	 }
	 String formattedColumnName = isSuper ? formatSubcolumnName(keySpace, columnFamily, column.name) : formatColumnName(keySpace, columnFamily, column.name);
	 sessionState.out.printf(""=> (column=%s, value=%s, timestamp=%d%s)%n"", formattedColumnName, valueAsString, column.timestamp, column.isSetTtl() ? String.format("", ttl=%d"", column.getTtl()) : """");
	 elapsedTime(startTime);
 }",0,0,1,0
"public class TtyFilterOutputStream extends FilterOutputStream {
	 public static final Set<PtyMode> OUTPUT_OPTIONS = Collections.unmodifiableSet(EnumSet.of(PtyMode.ECHO, PtyMode.INLCR, PtyMode.ICRNL, PtyMode.IGNCR));
	 private final Set<PtyMode> ttyOptions;
	 private final TtyFilterInputStream echo;
	 public TtyFilterOutputStream(OutputStream out, TtyFilterInputStream echo, Map<PtyMode, ?> modes) {
		 this(out, echo, PtyMode.resolveEnabledOptions(modes, OUTPUT_OPTIONS));
	 }
	 public TtyFilterOutputStream(OutputStream out, TtyFilterInputStream echo, Collection<PtyMode> ttyOptions) {
		 super(out);
		 this.ttyOptions = GenericUtils.of(ttyOptions);
		 this.echo = this.ttyOptions.contains(PtyMode.ECHO) ? Objects.requireNonNull(echo, ""No echo stream"") : echo;
	 }
	 public void write(int c) throws IOException {
		 if (c == '\r') {
			 handleCR();
		 }
		 else if (c == '\n') {
			 handleLF();
		 }
		 else {
			 writeRawOutput(c);
		 }
	 }
	 protected void handleCR() throws IOException {
		 if (ttyOptions.contains(PtyMode.ICRNL)) {
			 writeRawOutput('\n');
		 }
		 else if (ttyOptions.contains(PtyMode.IGNCR)) {
			 return;
		 }
		 else {
			 writeRawOutput('\r');
		 }
	 }
	 protected void handleLF() throws IOException {
		 if (ttyOptions.contains(PtyMode.INLCR)) {
			 writeRawOutput('\r');
		 }
		 else {
			 writeRawOutput('\n');
		 }
	 }
	 protected void writeRawOutput(int c) throws IOException {
		 this.out.write(c);
		 if (ttyOptions.contains(PtyMode.ECHO)) {
			 echo.write(c);
		 }
	 }
	 public void write(byte[] b, int off, int len) throws IOException {
		 if (len == 1) {
			 write(b[off] & 0xFF);
			 return;
		 }
		 int lastPos = 0;
		 int maxPos = off + len;
		 for (int curPos = off;
		 curPos < maxPos;
		 curPos++) {
			 int c = b[curPos] & 0xFF;
			 if ((c == '\r') || (c == '\n')) {
				 if (lastPos < curPos) {
					 writeRawOutput(b, lastPos, curPos - lastPos);
				 }
				 lastPos = curPos + 1;
				 write(c);
			 }
		 }
		 if (lastPos < maxPos) {
			 writeRawOutput(b, lastPos, maxPos - lastPos);
		 }
	 }
	 protected void writeRawOutput(byte[] b, int off, int len) throws IOException {
		 this.out.write(b, off, len);
		 if (ttyOptions.contains(PtyMode.ECHO)) {
			 echo.write(b, off, len);
		 }
	 }
}",0,0,0,0
"public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 IndexDoc latest = null;
	 while (values.hasNext()) {
		 IndexDoc value = (IndexDoc)values.next();
		 if (latest == null) {
			 latest = value;
			 continue;
		 }
		 if (value.time > latest.time) {
			 latest.keep = false;
			 LOG.debug(""-discard "" + latest + "", keep "" + value);
			 output.collect(latest.hash, latest);
			 latest = value;
		 }
		 else {
			 value.keep = false;
			 LOG.debug(""-discard "" + value + "", keep "" + latest);
			 output.collect(value.hash, value);
		 }
	 }
	 latest.keep = true;
	 output.collect(latest.hash, latest);
 }
 public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 IndexDoc highest = null;
	 while (values.hasNext()) {
		 IndexDoc value = (IndexDoc)values.next();
		 if (!value.keep) {
			 LOG.debug(""-discard "" + value + "" (already marked)"");
			 output.collect(value.url, value);
			 continue;
		 }
		 if (highest == null) {
			 highest = value;
			 continue;
		 }
		 IndexDoc toDelete = null, toKeep = null;
		 boolean metric = byScore ? (value.score > highest.score) : (value.urlLen < highest.urlLen);
		 if (metric) {
			 toDelete = highest;
			 toKeep = value;
		 }
		 else {
			 toDelete = value;
			 toKeep = highest;
		 }
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""-discard "" + toDelete + "", keep "" + toKeep);
		 }
		 toDelete.keep = false;
		 output.collect(toDelete.url, toDelete);
		 highest = toKeep;
	 }
	 LOG.debug(""-keep "" + highest);
 }
 public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 Path index = new Path(key.toString());
	 IndexReader reader = IndexReader.open(new FsDirectory(fs, index, false, getConf()));
	 try {
		 while (values.hasNext()) {
			 IntWritable value = (IntWritable)values.next();
			 LOG.debug(""-delete "" + index + "" doc="" + value);
			 reader.deleteDocument(value.get());
		 }
	 }
	 finally {
		 reader.close();
	 }
 }",0,0,0,0
"public static final class CompositeBitSpec extends BitSpec {
	 private final BitSpec left;
	 private final int leftWidth;
	 private final BitSpec right;
	 private final int rightWidth;
	 private final int width;
	 public CompositeBitSpec(BitSpec left, BitSpec right) {
		 super(left.isSignExtend());
		 assert !right.isSignExtend() : String.format(""Right field %s must not be sign extended"", right);
		 this.left = left;
		 this.leftWidth = left.getWidth();
		 this.right = right;
		 this.rightWidth = right.getWidth();
		 this.width = leftWidth + rightWidth;
	 }
	 public int getBits(int word) {
		 int l = left.getBits(word);
		 int r = right.getBits(word);
		 return (l << rightWidth) | r;
	 }
	 public int setBits(int word, int value) {
		 int l = leftBits(value);
		 int r = rightBits(value);
		 return left.setBits(right.setBits(word, r), l);
	 }
	 private int leftBits(int value) {
		 return getBits(value, width - 1, rightWidth, signExtend);
	 }
	 private int rightBits(int value) {
		 return getBits(value, rightWidth - 1, 0, false);
	 }
	 public int getWidth() {
		 return width;
	 }
	 public String toString() {
		 return String.format(""CompositeBitSpec[%s, %s]"", left, right);
	 }
	 public boolean valueFits(int value) {
		 int l = leftBits(value);
		 int r = rightBits(value);
		 return left.valueFits(l) && right.valueFits(r);
	 }
	 private static int getBits(int inst, int hiBit, int lowBit, boolean signExtended) {
		 int shifted = inst >> lowBit;
		 if (signExtended) {
			 return shifted;
		 }
		 else {
			 return shifted & ((1 << (hiBit - lowBit + 1)) - 1);
		 }
	 }
 }",0,0,0,0
"private boolean mainSimpleSort(final Data dataShadow, final int lo, final int hi, final int d) {
	 final int bigN = hi - lo + 1;
	 if (bigN < 2) {
		 return this.firstAttempt && (this.workDone > this.workLimit);
	 }
	 int hp = 0;
	 while (INCS[hp] < bigN) {
		 hp++;
	 }
	 final int[] fmap = dataShadow.fmap;
	 final char[] quadrant = dataShadow.quadrant;
	 final byte[] block = dataShadow.block;
	 final int lastShadow = this.last;
	 final int lastPlus1 = lastShadow + 1;
	 final boolean firstAttemptShadow = this.firstAttempt;
	 final int workLimitShadow = this.workLimit;
	 int workDoneShadow = this.workDone;
	 HP: while (--hp >= 0) {
		 final int h = INCS[hp];
		 final int mj = lo + h - 1;
		 for (int i = lo + h;
		 i <= hi;
		) {
			 for (int k = 3;
			 (i <= hi) && (--k >= 0);
			 i++) {
				 final int v = fmap[i];
				 final int vd = v + d;
				 int j = i;
				 boolean onceRunned = false;
				 int a = 0;
				 HAMMER: while (true) {
					 if (onceRunned) {
						 fmap[j] = a;
						 if ((j -= h) <= mj) {
							 break HAMMER;
						 }
					 }
					 else {
						 onceRunned = true;
					 }
					 a = fmap[j - h];
					 int i1 = a + d;
					 int i2 = vd;
					 if (block[i1 + 1] == block[i2 + 1]) {
						 if (block[i1 + 2] == block[i2 + 2]) {
							 if (block[i1 + 3] == block[i2 + 3]) {
								 if (block[i1 + 4] == block[i2 + 4]) {
									 if (block[i1 + 5] == block[i2 + 5]) {
										 if (block[(i1 += 6)] == block[(i2 += 6)]) {
											 int x = lastShadow;
											 X: while (x > 0) {
												 x -= 4;
												 if (block[i1 + 1] == block[i2 + 1]) {
													 if (quadrant[i1] == quadrant[i2]) {
														 if (block[i1 + 2] == block[i2 + 2]) {
															 if (quadrant[i1 + 1] == quadrant[i2 + 1]) {
																 if (block[i1 + 3] == block[i2 + 3]) {
																	 if (quadrant[i1 + 2] == quadrant[i2 + 2]) {
																		 if (block[i1 + 4] == block[i2 + 4]) {
																			 if (quadrant[i1 + 3] == quadrant[i2 + 3]) {
																				 if ((i1 += 4) >= lastPlus1) {
																					 i1 -= lastPlus1;
																				 }
																				 if ((i2 += 4) >= lastPlus1) {
																					 i2 -= lastPlus1;
																				 }
																				 workDoneShadow++;
																				 continue X;
																			 }
																			 else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {
																				 continue HAMMER;
																			 }
																			 else {
																				 break HAMMER;
																			 }
																		 }
																		 else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
																			 continue HAMMER;
																		 }
																		 else {
																			 break HAMMER;
																		 }
																	 }
																	 else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {
																		 continue HAMMER;
																	 }
																	 else {
																		 break HAMMER;
																	 }
																 }
																 else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
																	 continue HAMMER;
																 }
																 else {
																	 break HAMMER;
																 }
															 }
															 else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {
																 continue HAMMER;
															 }
															 else {
																 break HAMMER;
															 }
														 }
														 else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
															 continue HAMMER;
														 }
														 else {
															 break HAMMER;
														 }
													 }
													 else if ((quadrant[i1] > quadrant[i2])) {
														 continue HAMMER;
													 }
													 else {
														 break HAMMER;
													 }
												 }
												 else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
													 continue HAMMER;
												 }
												 else {
													 break HAMMER;
												 }
											 }
											 break HAMMER;
										 }
										 else {
											 if ((block[i1] & 0xff) > (block[i2] & 0xff)) {
												 continue HAMMER;
											 }
											 else {
												 break HAMMER;
											 }
										 }
									 }
									 else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {
										 continue HAMMER;
									 }
									 else {
										 break HAMMER;
									 }
								 }
								 else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
									 continue HAMMER;
								 }
								 else {
									 break HAMMER;
								 }
							 }
							 else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
								 continue HAMMER;
							 }
							 else {
								 break HAMMER;
							 }
						 }
						 else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
							 continue HAMMER;
						 }
						 else {
							 break HAMMER;
						 }
					 }
					 else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
						 continue HAMMER;
					 }
					 else {
						 break HAMMER;
					 }
				 }
				 fmap[j] = v;
			 }
			 if (firstAttemptShadow && (i <= hi) && (workDoneShadow > workLimitShadow)) {
				 break HP;
			 }
		 }
	 }
	 this.workDone = workDoneShadow;
	 return firstAttemptShadow && (workDoneShadow > workLimitShadow);
 }",0,0,1,0
"public static class APIRequestGet extends APIRequest<PageInsightsAsyncExportRun> {
	 PageInsightsAsyncExportRun lastResponse = null;
	 public PageInsightsAsyncExportRun getLastResponse() {
		 return lastResponse;
	 }
	 public static final String[] PARAMS = {
	 }
	;
	 public static final String[] FIELDS = {
	 ""data_level"", ""filters"", ""format"", ""gen_report_date"", ""id"", ""report_end_date"", ""report_start_date"", ""sorters"", ""status"", }
	;
	 public PageInsightsAsyncExportRun parseResponse(String response, String header) throws APIException {
		 return PageInsightsAsyncExportRun.parseResponse(response, getContext(), this, header).head();
	 }
	 public PageInsightsAsyncExportRun execute() throws APIException {
		 return execute(new HashMap<String, Object>());
	 }
	 public PageInsightsAsyncExportRun execute(Map<String, Object> extraParams) throws APIException {
		 ResponseWrapper rw = executeInternal(extraParams);
		 lastResponse = parseResponse(rw.getBody(), rw.getHeader());
		 return lastResponse;
	 }
	 public ListenableFuture<PageInsightsAsyncExportRun> executeAsync() throws APIException {
		 return executeAsync(new HashMap<String, Object>());
	 }
	;
	 public ListenableFuture<PageInsightsAsyncExportRun> executeAsync(Map<String, Object> extraParams) throws APIException {
		 return Futures.transform( executeAsyncInternal(extraParams), new Function<ResponseWrapper, PageInsightsAsyncExportRun>() {
			 public PageInsightsAsyncExportRun apply(ResponseWrapper result) {
				 try {
					 return APIRequestGet.this.parseResponse(result.getBody(), result.getHeader());
				 }
				 catch (Exception e) {
					 throw new RuntimeException(e);
				 }
			 }
		 }
		 );
	 }
	;
	 public APIRequestGet(String nodeId, APIContext context) {
		 super(context, nodeId, ""/"", ""GET"", Arrays.asList(PARAMS));
	 }
	 public APIRequestGet setParam(String param, Object value) {
		 setParamInternal(param, value);
		 return this;
	 }
	 public APIRequestGet setParams(Map<String, Object> params) {
		 setParamsInternal(params);
		 return this;
	 }
	 public APIRequestGet requestAllFields () {
		 return this.requestAllFields(true);
	 }
	 public APIRequestGet requestAllFields (boolean value) {
		 for (String field : FIELDS) {
			 this.requestField(field, value);
		 }
		 return this;
	 }
	 public APIRequestGet requestFields (List<String> fields) {
		 return this.requestFields(fields, true);
	 }
	 public APIRequestGet requestFields (List<String> fields, boolean value) {
		 for (String field : fields) {
			 this.requestField(field, value);
		 }
		 return this;
	 }
	 public APIRequestGet requestField (String field) {
		 this.requestField(field, true);
		 return this;
	 }
	 public APIRequestGet requestField (String field, boolean value) {
		 this.requestFieldInternal(field, value);
		 return this;
	 }
	 public APIRequestGet requestDataLevelField () {
		 return this.requestDataLevelField(true);
	 }
	 public APIRequestGet requestDataLevelField (boolean value) {
		 this.requestField(""data_level"", value);
		 return this;
	 }
	 public APIRequestGet requestFiltersField () {
		 return this.requestFiltersField(true);
	 }
	 public APIRequestGet requestFiltersField (boolean value) {
		 this.requestField(""filters"", value);
		 return this;
	 }
	 public APIRequestGet requestFormatField () {
		 return this.requestFormatField(true);
	 }
	 public APIRequestGet requestFormatField (boolean value) {
		 this.requestField(""format"", value);
		 return this;
	 }
	 public APIRequestGet requestGenReportDateField () {
		 return this.requestGenReportDateField(true);
	 }
	 public APIRequestGet requestGenReportDateField (boolean value) {
		 this.requestField(""gen_report_date"", value);
		 return this;
	 }
	 public APIRequestGet requestIdField () {
		 return this.requestIdField(true);
	 }
	 public APIRequestGet requestIdField (boolean value) {
		 this.requestField(""id"", value);
		 return this;
	 }
	 public APIRequestGet requestReportEndDateField () {
		 return this.requestReportEndDateField(true);
	 }
	 public APIRequestGet requestReportEndDateField (boolean value) {
		 this.requestField(""report_end_date"", value);
		 return this;
	 }
	 public APIRequestGet requestReportStartDateField () {
		 return this.requestReportStartDateField(true);
	 }
	 public APIRequestGet requestReportStartDateField (boolean value) {
		 this.requestField(""report_start_date"", value);
		 return this;
	 }
	 public APIRequestGet requestSortersField () {
		 return this.requestSortersField(true);
	 }
	 public APIRequestGet requestSortersField (boolean value) {
		 this.requestField(""sorters"", value);
		 return this;
	 }
	 public APIRequestGet requestStatusField () {
		 return this.requestStatusField(true);
	 }
	 public APIRequestGet requestStatusField (boolean value) {
		 this.requestField(""status"", value);
		 return this;
	 }
 }",0,0,0,0
"public class FunctionNode extends ScriptOrFnNode {
	 public FunctionNode(String name) {
		 super(Token.FUNCTION);
		 functionName = name;
	 }
	 public String getFunctionName() {
		 return functionName;
	 }
	 public boolean requiresActivation() {
		 return itsNeedsActivation;
	 }
	 public boolean getIgnoreDynamicScope() {
		 return itsIgnoreDynamicScope;
	 }
	 public static final int FUNCTION_STATEMENT = 1;
	 public static final int FUNCTION_EXPRESSION = 2;
	 public static final int FUNCTION_EXPRESSION_STATEMENT = 3;
	 public int getFunctionType() {
		 return itsFunctionType;
	 }
	 String functionName;
	 boolean itsNeedsActivation;
	 int itsFunctionType;
	 boolean itsIgnoreDynamicScope;
}",0,0,0,0
"public synchronized Task pollForNewTask(String taskTracker) {
	 int remainingReduceLoad = 0;
	 int remainingMapLoad = 0;
	 int numTaskTrackers;
	 TaskTrackerStatus tts;
	 int avgMapLoad = 0;
	 int avgReduceLoad = 0;
	 synchronized (taskTrackers) {
		 numTaskTrackers = taskTrackers.size();
		 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
	 }
	 synchronized(jobsByArrival){
		 for (Iterator it = jobsByArrival.iterator();
		 it.hasNext();
		 ) {
			 JobInProgress job = (JobInProgress) it.next();
			 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
				 int totalMapTasks = job.desiredMaps();
				 int totalReduceTasks = job.desiredReduces();
				 remainingMapLoad += (totalMapTasks - job.finishedMaps());
				 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
			 }
		 }
	 }
	 if (numTaskTrackers > 0) {
		 avgMapLoad = remainingMapLoad / numTaskTrackers;
		 avgReduceLoad = remainingReduceLoad / numTaskTrackers;
	 }
	 int totalCapacity = numTaskTrackers * maxCurrentTasks;
	 if (tts == null) {
		 LOG.warn(""Unknown task tracker polling;
		 ignoring: "" + taskTracker);
		 return null;
	 }
	 int numMaps = tts.countMapTasks();
	 int numReduces = tts.countReduceTasks();
	 synchronized (jobsByArrival) {
		 if ((numMaps < maxCurrentTasks) && (numMaps <= avgMapLoad + 1 + TASK_ALLOC_EPSILON)) {
			 int totalNeededMaps = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewMapTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 return t;
				 }
				 totalNeededMaps += job.desiredMaps();
				 int padding = 0;
				 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, (int)(totalNeededMaps * PAD_FRACTION));
				 }
				 if (totalMaps + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
		 if ((numReduces < maxCurrentTasks) && (numReduces <= avgReduceLoad + 1 + TASK_ALLOC_EPSILON)) {
			 int totalNeededReduces = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewReduceTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 return t;
				 }
				 totalNeededReduces += job.desiredReduces();
				 int padding = 0;
				 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, (int) (totalNeededReduces * PAD_FRACTION));
				 }
				 if (totalReduces + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public static Class getOutputCompressorClass(JobConf conf, Class defaultValue) {
	 String name = conf.get(""mapred.output.compression.codec"");
	 if (name == null) {
		 return defaultValue;
	 }
	 else {
		 try {
			 return conf.getClassByName(name);
		 }
		 catch (ClassNotFoundException e) {
			 throw new IllegalArgumentException(""Compression codec "" + name + "" was not found."", e);
		 }
	 }
 }",0,0,0,0
"private void buildNode79() throws Exception {
	 UaVariableNode node = new DataTypeDescriptionNode(this.context, NodeId.parse(""ns=0;
	i=8567""), new QualifiedName(0, ""ContentFilter""), new LocalizedText(""en"", ""ContentFilter""), LocalizedText.NULL_VALUE, UInteger.valueOf(0L), UInteger.valueOf(0L), new DataValue(Variant.NULL_VALUE), NodeId.parse(""ns=0;
	i=12""), -1, new UInteger[]{
	}
	, UByte.valueOf(1), UByte.valueOf(1), 0.0D, false);
	 node.addReference(new Reference(NodeId.parse(""ns=0;
	i=8567""), NodeId.parse(""ns=0;
	i=39""), ExpandedNodeId.parse(""svr=0;
	i=587""), NodeClass.Object, false));
	 node.addReference(new Reference(NodeId.parse(""ns=0;
	i=8567""), NodeId.parse(""ns=0;
	i=47""), ExpandedNodeId.parse(""svr=0;
	i=8252""), NodeClass.Variable, false));
	 node.addReference(new Reference(NodeId.parse(""ns=0;
	i=8567""), NodeId.parse(""ns=0;
	i=40""), ExpandedNodeId.parse(""svr=0;
	i=69""), NodeClass.VariableType, true));
	 node.addReference(new Reference(NodeId.parse(""ns=0;
	i=8567""), NodeId.parse(""ns=0;
	i=47""), ExpandedNodeId.parse(""svr=0;
	i=8252""), NodeClass.Variable, false));
	 String valueXml;
	 OpcUaXmlStreamDecoder decoder = new OpcUaXmlStreamDecoder(new StringReader(new String(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" standalone=\""yes\""?><ns2:String xmlns=\""http: Object valueObject = decoder.readVariantValue();
	 DataValue value = new DataValue(new Variant(valueObject));
	 node.setValue(value);
	 this.nodeManager.addNode(node);
 }",0,0,1,0
"protected void appendBodyStructure(StringBuilder buffer, MimePart bodyPart) throws IOException, MessagingException {
	 String contentType = MimeUtility.unfold(bodyPart.getContentType());
	 int slashIndex = contentType.indexOf('/');
	 if (slashIndex < 0) {
		 throw new DavMailException(""EXCEPTION_INVALID_CONTENT_TYPE"", contentType);
	 }
	 String type = contentType.substring(0, slashIndex).toUpperCase();
	 buffer.append(""(\"""").append(type).append(""\"" \"""");
	 int semiColonIndex = contentType.indexOf(';
	');
	 if (semiColonIndex < 0) {
		 buffer.append(contentType.substring(slashIndex + 1).toUpperCase()).append(""\"" NIL"");
	 }
	 else {
		 buffer.append(contentType.substring(slashIndex + 1, semiColonIndex).trim().toUpperCase()).append('\""');
		 int charsetindex = contentType.indexOf(""charset="");
		 int nameindex = contentType.indexOf(""name="");
		 if (charsetindex >= 0 || nameindex >= 0) {
			 buffer.append("" ("");
			 if (charsetindex >= 0) {
				 buffer.append(""\""CHARSET\"" "");
				 int charsetSemiColonIndex = contentType.indexOf(';
				', charsetindex);
				 int charsetEndIndex;
				 if (charsetSemiColonIndex > 0) {
					 charsetEndIndex = charsetSemiColonIndex;
				 }
				 else {
					 charsetEndIndex = contentType.length();
				 }
				 String charSet = contentType.substring(charsetindex + ""charset="".length(), charsetEndIndex);
				 if (!charSet.startsWith(""\"""")) {
					 buffer.append('""');
				 }
				 buffer.append(charSet.trim().toUpperCase());
				 if (!charSet.endsWith(""\"""")) {
					 buffer.append('""');
				 }
			 }
			 if (nameindex >= 0) {
				 if (charsetindex >= 0) {
					 buffer.append(' ');
				 }
				 buffer.append(""\""NAME\"" "");
				 int nameSemiColonIndex = contentType.indexOf(';
				', nameindex);
				 int nameEndIndex;
				 if (nameSemiColonIndex > 0) {
					 nameEndIndex = nameSemiColonIndex;
				 }
				 else {
					 nameEndIndex = contentType.length();
				 }
				 String name = contentType.substring(nameindex + ""name="".length(), nameEndIndex).trim();
				 if (!name.startsWith(""\"""")) {
					 buffer.append('""');
				 }
				 buffer.append(name.trim());
				 if (!name.endsWith(""\"""")) {
					 buffer.append('""');
				 }
			 }
			 buffer.append(')');
		 }
		 else {
			 buffer.append("" NIL"");
		 }
	 }
	 appendBodyStructureValue(buffer, bodyPart.getContentID());
	 appendBodyStructureValue(buffer, bodyPart.getDescription());
	 appendBodyStructureValue(buffer, bodyPart.getEncoding());
	 appendBodyStructureValue(buffer, bodyPart.getSize());
	 if (""MESSAGE"".equals(type) || ""TEXT"".equals(type)) {
		 appendBodyStructureValue(buffer, bodyPart.getSize() / 80);
	 }
	 else {
		 appendBodyStructureValue(buffer, -1);
	 }
	 buffer.append(')');
 }",0,0,1,0
"static String getJobCacheSubdir() {
	 return TaskTracker.SUBDIR + Path.SEPARATOR + TaskTracker.JOBCACHE;
 }",0,0,0,0
"private void restoreReplicaCount(InetAddress endpoint, final InetAddress notifyEndpoint) {
	 final Multimap<InetAddress, String> fetchSources = HashMultimap.create();
	 Multimap<String, Map.Entry<InetAddress, Collection<Range<Token>>>> rangesToFetch = HashMultimap.create();
	 final InetAddress myAddress = FBUtilities.getBroadcastAddress();
	 for (String table : Schema.instance.getNonSystemTables()) {
		 Multimap<Range<Token>, InetAddress> changedRanges = getChangedRangesForLeaving(table, endpoint);
		 Set<Range<Token>> myNewRanges = new HashSet<Range<Token>>();
		 for (Map.Entry<Range<Token>, InetAddress> entry : changedRanges.entries()) {
			 if (entry.getValue().equals(myAddress)) myNewRanges.add(entry.getKey());
		 }
		 Multimap<InetAddress, Range<Token>> sourceRanges = getNewSourceRanges(table, myNewRanges);
		 for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : sourceRanges.asMap().entrySet()) {
			 fetchSources.put(entry.getKey(), table);
			 rangesToFetch.put(table, entry);
		 }
	 }
	 for (final String table : rangesToFetch.keySet()) {
		 for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : rangesToFetch.get(table)) {
			 final InetAddress source = entry.getKey();
			 Collection<Range<Token>> ranges = entry.getValue();
			 final IStreamCallback callback = new IStreamCallback() {
				 public void onSuccess() {
					 synchronized (fetchSources) {
						 fetchSources.remove(source, table);
						 if (fetchSources.isEmpty()) sendReplicationNotification(myAddress, notifyEndpoint);
					 }
				 }
				 public void onFailure() {
					 logger_.warn(""Streaming from "" + source + "" failed"");
					 onSuccess();
				 }
			 }
			;
			 if (logger_.isDebugEnabled()) logger_.debug(""Requesting from "" + source + "" ranges "" + StringUtils.join(ranges, "", ""));
			 StreamIn.requestRanges(source, table, ranges, callback, OperationType.RESTORE_REPLICA_COUNT);
		 }
	 }
 }",0,0,0,0
"private static void doReportUserHomeLibraries(PrintStream out) {
	 String home = System.getProperty(Launcher.USER_HOMEDIR);
	 out.println(""user.home: "" + home);
	 File libDir = new File(home, Launcher.USER_LIBDIR);
	 File[] libs = listJarFiles(libDir);
	 printLibraries(libs, out);
 }",0,0,0,0
"public ByteBuffer merge(ByteBuffer left, ByteBuffer right, Allocator allocator) {
	 ContextState leftState = new ContextState(left, headerLength(left));
	 ContextState rightState = new ContextState(right, headerLength(right));
	 int mergedHeaderLength = HEADER_SIZE_LENGTH;
	 int mergedBodyLength = 0;
	 while (leftState.hasRemaining() && rightState.hasRemaining()) {
		 int cmp = leftState.compareIdTo(rightState);
		 if (cmp == 0) {
			 mergedBodyLength += STEP_LENGTH;
			 if (leftState.isDelta() || rightState.isDelta()) mergedHeaderLength += HEADER_ELT_LENGTH;
			 leftState.moveToNext();
			 rightState.moveToNext();
		 }
		 else if (cmp > 0) {
			 mergedBodyLength += STEP_LENGTH;
			 if (rightState.isDelta()) mergedHeaderLength += HEADER_ELT_LENGTH;
			 rightState.moveToNext();
		 }
		 else {
			 mergedBodyLength += STEP_LENGTH;
			 if (leftState.isDelta()) mergedHeaderLength += HEADER_ELT_LENGTH;
			 leftState.moveToNext();
		 }
	 }
	 mergedHeaderLength += leftState.remainingHeaderLength() + rightState.remainingHeaderLength();
	 mergedBodyLength += leftState.remainingBodyLength() + rightState.remainingBodyLength();
	 ByteBuffer merged = allocator.allocate(mergedHeaderLength + mergedBodyLength);
	 merged.putShort(merged.position(), (short) ((mergedHeaderLength - HEADER_SIZE_LENGTH) / HEADER_ELT_LENGTH));
	 ContextState mergedState = new ContextState(merged, mergedHeaderLength);
	 leftState.reset();
	 rightState.reset();
	 while (leftState.hasRemaining() && rightState.hasRemaining()) {
		 int cmp = leftState.compareIdTo(rightState);
		 if (cmp == 0) {
			 if (leftState.isDelta() || rightState.isDelta()) {
				 if (leftState.isDelta() && rightState.isDelta()) {
					 long clock = leftState.getClock() + rightState.getClock();
					 long count = leftState.getCount() + rightState.getCount();
					 mergedState.writeElement(leftState.getNodeId(), clock, count, true);
				 }
				 else {
					 (leftState.isDelta() ? leftState : rightState).copyTo(mergedState);
				 }
			 }
			 else {
				 long leftClock = leftState.getClock();
				 long rightClock = rightState.getClock();
				 if (leftClock == rightClock) {
					 long leftCount = leftState.getCount();
					 long rightCount = rightState.getCount();
					 if (leftCount != rightCount) {
						 logger.error(""invalid counter shard detected;
						 ({
						}
						, {
						}
						, {
						}
						) and ({
						}
						, {
						}
						, {
						}
						) differ only in "" + ""count;
						 will pick highest to self-heal;
						 this indicates a bug or corruption generated a bad counter shard"", new Object[] {
						 leftState.getNodeId(), leftClock, leftCount, rightState.getNodeId(), rightClock, rightCount, }
						);
					 }
					 if (leftCount > rightCount) {
						 leftState.copyTo(mergedState);
					 }
					 else {
						 rightState.copyTo(mergedState);
					 }
				 }
				 else {
					 if ((leftClock >= 0 && rightClock > 0 && leftClock >= rightClock) || (leftClock < 0 && (rightClock > 0 || leftClock < rightClock))) leftState.copyTo(mergedState);
					 else rightState.copyTo(mergedState);
				 }
			 }
			 rightState.moveToNext();
			 leftState.moveToNext();
		 }
		 else if (cmp > 0) {
			 rightState.copyTo(mergedState);
			 rightState.moveToNext();
		 }
		 else {
			 leftState.copyTo(mergedState);
			 leftState.moveToNext();
		 }
	 }
	 while (leftState.hasRemaining()) {
		 leftState.copyTo(mergedState);
		 leftState.moveToNext();
	 }
	 while (rightState.hasRemaining()) {
		 rightState.copyTo(mergedState);
		 rightState.moveToNext();
	 }
	 return merged;
 }",0,0,1,0
"public class Case_1 {
	 private int id;
	 public int testFunction1() {
		 return 42;
	 }
	 public int testFunction2() {
		 return 42;
	 }
	 public Integer testFunction3() {
		 return Integer.valueOf(42);
	 }
	 public int getId() {
		 return this.id;
	 }
	 public void setId(final int id) {
		 this.id = id;
	 }
}",0,1,0,0
"private static void testNeurophWekaClassifier(Instances wekaDataset) {
	 try {
		 MultiLayerPerceptron neuralNet = new MultiLayerPerceptron(4, 16, 3);
		 neuralNet.getOutputNeurons().get(0).setLabel(""Setosa"");
		 neuralNet.getOutputNeurons().get(1).setLabel(""Versicolor"");
		 neuralNet.getOutputNeurons().get(2).setLabel(""Virginica"");
		 WekaNeurophClassifier neurophWekaClassifier = new WekaNeurophClassifier(neuralNet);
		 wekaDataset.setClassIndex(4);
		 neurophWekaClassifier.buildClassifier(wekaDataset);
		 double[] item = {
		0.22222222222222213, 0.6249999999999999, 0.06779661016949151, 0.04166666666666667, 0}
		;
		 Instance instance = new DenseInstance(1, item);
		 System.out.println(""NeurophWekaClassifier - classifyInstance for {
		5.1, 3.5, 1.4, 0.2}
		"");
		 System.out.println(""Class idx: ""+neurophWekaClassifier.classifyInstance(instance));
		 System.out.println(""NeurophWekaClassifier - distributionForInstance for {
		5.1, 3.5, 1.4, 0.2}
		"");
		 double dist[] = neurophWekaClassifier.distributionForInstance(instance);
		 for (int i=0;
		 i<dist.length;
		 i++ ) {
			 System.out.println(""Class ""+i+"": ""+dist[i]);
		 }
	 }
	 catch (Exception ex) {
		 Logger.getLogger(WekaNeurophSample.class.getName()).log(Level.SEVERE, null, ex);
	 }
 }",0,0,0,0
"public WikiPage getPageInfo( String page, int version ) throws ProviderException {
	 int latest = findLatestVersion(page);
	 int realVersion;
	 WikiPage p = null;
	 if( version == WikiPageProvider.LATEST_VERSION || version == latest || (version == 1 && latest == -1) ) {
		 realVersion = (latest >= 0) ? latest : 1;
		 p = super.getPageInfo( page, WikiPageProvider.LATEST_VERSION );
		 if( p != null ) {
			 p.setVersion( realVersion );
		 }
	 }
	 else {
		 realVersion = version;
		 File dir = findOldPageDir( page );
		 if( !dir.exists() || !dir.isDirectory() ) {
			 return null;
		 }
		 File file = new File( dir, version+FILE_EXT );
		 if( file.exists() ) {
			 p = new WikiPage( m_engine, page );
			 p.setLastModified( new Date(file.lastModified()) );
			 p.setVersion( version );
		 }
	 }
	 if( p != null ) {
		 try {
			 Properties props = getPageProperties( page );
			 String author = props.getProperty( realVersion+"".author"" );
			 if ( author == null ) {
				 Properties props2 = getHeritagePageProperties( page );
				 author = props2.getProperty( WikiPage.AUTHOR );
			 }
			 if ( author != null ) {
				 p.setAuthor( author );
			 }
			 String changenote = props.getProperty( realVersion+"".changenote"" );
			 if( changenote != null ) p.setAttribute( WikiPage.CHANGENOTE, changenote );
			 setCustomProperties(p, props);
		 }
		 catch( IOException e ) {
			 log.error( ""Cannot get author for page""+page+"": "", e );
		 }
	 }
	 return p;
 }",0,0,1,0
"public void addEllipse(Ellipse elip) {
	 instructions.add(elip);
 }",0,0,0,0
"private void translate() throws BuildException {
	 int filesProcessed = 0;
	 for (int i = 0;
	 i < filesets.size();
	 i++) {
		 FileSet fs = (FileSet) filesets.elementAt(i);
		 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
		 String[] srcFiles = ds.getIncludedFiles();
		 for (int j = 0;
		 j < srcFiles.length;
		 j++) {
			 try {
				 File dest = FILE_UTILS.resolveFile(toDir, srcFiles[j]);
				 try {
					 File destDir = new File(dest.getParent());
					 if (!destDir.exists()) {
						 destDir.mkdirs();
					 }
				 }
				 catch (Exception e) {
					 log(""Exception occurred while trying to check/create "" + "" parent directory. "" + e.getMessage(), Project.MSG_DEBUG);
				 }
				 destLastModified = dest.lastModified();
				 File src = FILE_UTILS.resolveFile(ds.getBasedir(), srcFiles[j]);
				 srcLastModified = src.lastModified();
				 boolean needsWork = forceOverwrite || destLastModified < srcLastModified;
				 if (!needsWork) {
					 for (int icounter = 0;
					 icounter < BUNDLE_MAX_ALTERNATIVES;
					 icounter++) {
						 needsWork = (destLastModified < bundleLastModified[icounter]);
						 if (needsWork) {
							 break;
						 }
					 }
				 }
				 if (needsWork) {
					 log(""Processing "" + srcFiles[j], Project.MSG_DEBUG);
					 FileOutputStream fos = new FileOutputStream(dest);
					 BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, destEncoding));
					 FileInputStream fis = new FileInputStream(src);
					 BufferedReader in = new BufferedReader(new InputStreamReader(fis, srcEncoding));
					 String line;
					 LineTokenizer lineTokenizer = new LineTokenizer();
					 lineTokenizer.setIncludeDelims(true);
					 line = lineTokenizer.getToken(in);
					 while ((line) != null) {
						 int startIndex = line.indexOf(startToken);
						 while (startIndex >= 0 && (startIndex + startToken.length()) <= line.length()) {
							 String replace = null;
							 int endIndex = line.indexOf( endToken, startIndex + startToken.length());
							 if (endIndex < 0) {
								 startIndex += 1;
							 }
							 else {
								 String token = line.substring( startIndex + startToken.length(), endIndex);
								 boolean validToken = true;
								 for (int k = 0;
								 k < token.length() && validToken;
								 k++) {
									 char c = token.charAt(k);
									 if (c == ':' || c == '=' || Character.isSpaceChar(c)) {
										 validToken = false;
									 }
								 }
								 if (!validToken) {
									 startIndex += 1;
								 }
								 else {
									 if (resourceMap.containsKey(token)) {
										 replace = (String) resourceMap.get(token);
									 }
									 else {
										 log(""Replacement string missing for: "" + token, Project.MSG_VERBOSE);
										 replace = startToken + token + endToken;
									 }
									 line = line.substring(0, startIndex) + replace + line.substring(endIndex + endToken.length());
									 startIndex += replace.length();
								 }
							 }
							 startIndex = line.indexOf(startToken, startIndex);
						 }
						 out.write(line);
						 line = lineTokenizer.getToken(in);
					 }
					 if (in != null) {
						 in.close();
					 }
					 if (out != null) {
						 out.close();
					 }
					 ++filesProcessed;
				 }
				 else {
					 log(""Skipping "" + srcFiles[j] + "" as destination file is up to date"", Project.MSG_VERBOSE);
				 }
			 }
			 catch (IOException ioe) {
				 throw new BuildException(ioe.getMessage(), getLocation());
			 }
		 }
	 }
	 log(""Translation performed on "" + filesProcessed + "" file(s)."", Project.MSG_DEBUG);
 }",0,0,1,0
"public class Subchannel extends Pipe {
	private int numRods;
	private double rodDiameter;
	private double pitch;
	public Subchannel() {
		setName(""Subchannel 1"");
		setDescription(""A subchannel plant component for reactors"");
		setId(1);
		setNumRods(1);
		setRodDiameter(1.0);
		setPitch(1.5);
		return;
	}
	public Subchannel(int numRods, double rodDiameter, double pitch) {
		setName(""Subchannel 1"");
		setDescription(""A subchannel plant component for reactors"");
		setId(1);
		setNumRods(numRods);
		setRodDiameter(rodDiameter);
		setPitch(pitch);
		return;
	}
	public int getNumRods() {
		return numRods;
	}
	public void setNumRods(int numRods) {
		if (numRods >= 1) {
			this.numRods = numRods;
		}
		 else {
			throw new InvalidParameterException(""Subchannel error: The number ""+ ""of rods must greater than or equal to 1."");
		}
		return;
	}
	public double getRodDiameter() {
		return rodDiameter;
	}
	public void setRodDiameter(double rodDiameter) {
		if (rodDiameter > 0) {
			this.rodDiameter = rodDiameter;
		}
		 else {
			throw new InvalidParameterException(""Subchannel error: The rod ""+ ""diameter must be non-negative."");
		}
		return;
	}
	public double getPitch() {
		return pitch;
	}
	public void setPitch(double pitch) {
		if (pitch >= rodDiameter) {
			this.pitch = pitch;
		}
		 else {
			throw new InvalidParameterException(""Subchannel error: The rod ""+ ""pitch cannot be smaller than the rod diameter."");
		}
	}
	public boolean equals(Object otherObject) {
		boolean equals = false;
		if (this == otherObject) {
			equals = true;
		}
		else if (otherObject != null && otherObject instanceof Subchannel) {
			Subchannel component = (Subchannel) otherObject;
			equals = (super.equals(component) && numRods == component.numRods&& rodDiameter == component.rodDiameter && pitch == component.pitch);
		}
		return equals;
	}
	public Object clone() {
		Subchannel object = new Subchannel();
		object.copy(this);
		return object;
	}
	public void copy(Subchannel otherObject) {
		if (otherObject == null) {
			return;
		}
		super.copy(otherObject);
		numRods = otherObject.numRods;
		rodDiameter = otherObject.rodDiameter;
		pitch = otherObject.pitch;
		return;
	}
	public int hashCode() {
		int hash = super.hashCode();
		hash = 31 * hash + numRods;
		hash = 31 * hash + new Double(rodDiameter).hashCode();
		hash = 31 * hash + new Double(pitch).hashCode();
		return hash;
	}
	public void accept(IPlantComponentVisitor visitor) {
		if (visitor != null) {
			visitor.visit(this);
		}
		return;
	}
}",1,1,0,0
"public class OdaDimensionState extends ReportElementState{
	protected Dimension element = null;
	public OdaDimensionState( ModuleParserHandler handler,DesignElement theContainer, String prop ){
		super( handler, theContainer, prop );
	}
	public DesignElement getElement( ){
		return element;
	}
	public void parseAttrs( Attributes attrs ) throws XMLParserException{
		element = new OdaDimension( );
		initElement( attrs, true );
	}
}",0,1,0,0
"protected class MappingRuleHandler extends AbstractHandler {
	 private final String[] required = new String[] {
	 MAPPING_RULE_FILTER_ATTRIBUTE, MAPPING_RULE_OUTPUT_ATTRIBUTE }
	;
	 public MappingRuleHandler(AbstractHandler parentHandler, Attributes attributes, List mappingRules) {
		 super(parentHandler, MAPPING_RULE_ELEMENT);
		 mappingRules.add(parseRequiredAttributes(attributes, required));
	 }
	 public void startElement(String name, Attributes attributes) {
		 invalidElement(name, attributes);
	 }
 }",0,0,0,0
"private static void walker(List<List<String>> finalResult, final List<List<String>> input, List<String> listSoFar, final int level) throws SemanticException {
	 if (level == (input.size() - 1)) {
		 assert (input.get(level) != null) : ""Unique skewed element list has null list in "" + level + ""th position."";
		 for (String v : input.get(level)) {
			 List<String> oneCompleteIndex = new ArrayList<String>(listSoFar);
			 oneCompleteIndex.add(v);
			 finalResult.add(oneCompleteIndex);
		 }
		 return;
	 }
	 for (String v : input.get(level)) {
		 List<String> clonedListSoFar = new ArrayList<String>(listSoFar);
		 clonedListSoFar.add(v);
		 int nextLevel = level + 1;
		 walker(finalResult, input, clonedListSoFar, nextLevel);
	 }
 }",0,0,1,0
"private static class getDetailedExperimentTree_resultTupleScheme extends TupleScheme<getDetailedExperimentTree_result> {
	 public void write(org.apache.thrift.protocol.TProtocol prot, getDetailedExperimentTree_result struct) throws org.apache.thrift.TException {
		 TTupleProtocol oprot = (TTupleProtocol) prot;
		 BitSet optionals = new BitSet();
		 if (struct.isSetSuccess()) {
			 optionals.set(0);
		 }
		 if (struct.isSetRse()) {
			 optionals.set(1);
		 }
		 if (struct.isSetEnf()) {
			 optionals.set(2);
		 }
		 oprot.writeBitSet(optionals, 3);
		 if (struct.isSetSuccess()) {
			 struct.success.write(oprot);
		 }
		 if (struct.isSetRse()) {
			 struct.rse.write(oprot);
		 }
		 if (struct.isSetEnf()) {
			 struct.enf.write(oprot);
		 }
	 }
	 public void read(org.apache.thrift.protocol.TProtocol prot, getDetailedExperimentTree_result struct) throws org.apache.thrift.TException {
		 TTupleProtocol iprot = (TTupleProtocol) prot;
		 BitSet incoming = iprot.readBitSet(3);
		 if (incoming.get(0)) {
			 struct.success = new org.apache.airavata.model.experiment.ExperimentModel();
			 struct.success.read(iprot);
			 struct.setSuccessIsSet(true);
		 }
		 if (incoming.get(1)) {
			 struct.rse = new org.apache.airavata.registry.api.exception.RegistryServiceException();
			 struct.rse.read(iprot);
			 struct.setRseIsSet(true);
		 }
		 if (incoming.get(2)) {
			 struct.enf = new org.apache.airavata.model.error.ExperimentNotFoundException();
			 struct.enf.read(iprot);
			 struct.setEnfIsSet(true);
		 }
	 }
 }",0,0,0,0
"public void setMaxSize(final Bytes maxSize){
	this.maxSize = maxSize;
}",0,0,0,0
"public static synchronized WritableComparator get(Class c) {
	 WritableComparator comparator = (WritableComparator)comparators.get(c);
	 if (comparator == null) comparator = new WritableComparator(c);
	 return comparator;
 }",0,0,0,0
"public class Signal {
	 public enum Type {
	 LEAVE_LOOP, LEAVE_ROUTINE, LEAVE_PROGRAM, SQLEXCEPTION, NOTFOUND, UNSUPPORTED_OPERATION, USERDEFINED }
	;
	 Type type;
	 String value = """";
	 Exception exception = null;
	 Signal(Type type, String value) {
		 this.type = type;
		 this.value = value;
		 this.exception = null;
	 }
	 Signal(Type type, String value, Exception exception) {
		 this.type = type;
		 this.value = value;
		 this.exception = exception;
	 }
	 public String getValue() {
		 return value;
	 }
}",0,1,0,0
"protected final void onSetObject(Component component, Object object){
	throw new UnsupportedOperationException();
}",0,0,0,0
"public class Project implements ResourceFactory {
	 private static final String LINE_SEP = System.getProperty(""line.separator"");
	 public static final int MSG_ERR = 0;
	 public static final int MSG_WARN = 1;
	 public static final int MSG_INFO = 2;
	 public static final int MSG_VERBOSE = 3;
	 public static final int MSG_DEBUG = 4;
	 private static final String VISITING = ""VISITING"";
	 private static final String VISITED = ""VISITED"";
	 public static final String JAVA_1_0 = JavaEnvUtils.JAVA_1_0;
	 public static final String JAVA_1_1 = JavaEnvUtils.JAVA_1_1;
	 public static final String JAVA_1_2 = JavaEnvUtils.JAVA_1_2;
	 public static final String JAVA_1_3 = JavaEnvUtils.JAVA_1_3;
	 public static final String JAVA_1_4 = JavaEnvUtils.JAVA_1_4;
	 public static final String TOKEN_START = FilterSet.DEFAULT_TOKEN_START;
	 public static final String TOKEN_END = FilterSet.DEFAULT_TOKEN_END;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private String name;
	 private String description;
	 private Hashtable references = new AntRefTable();
	 private HashMap idReferences = new HashMap();
	 private Project parentIdProject = null;
	 private String defaultTarget;
	 private Hashtable targets = new Hashtable();
	 private FilterSet globalFilterSet = new FilterSet();
	 {
		 globalFilterSet.setProject(this);
	 }
	 private FilterSetCollection globalFilters = new FilterSetCollection(globalFilterSet);
	 private File baseDir;
	 private Vector listeners = new Vector();
	 private ClassLoader coreLoader = null;
	 private Map threadTasks = Collections.synchronizedMap(new WeakHashMap());
	 private Map threadGroupTasks = Collections.synchronizedMap(new WeakHashMap());
	 private InputHandler inputHandler = null;
	 private InputStream defaultInputStream = null;
	 private boolean keepGoingMode = false;
	 private boolean loggingMessage = false;
	 public void setInputHandler(InputHandler handler) {
		 inputHandler = handler;
	 }
	 public void setDefaultInputStream(InputStream defaultInputStream) {
		 this.defaultInputStream = defaultInputStream;
	 }
	 public InputStream getDefaultInputStream() {
		 return defaultInputStream;
	 }
	 public InputHandler getInputHandler() {
		 return inputHandler;
	 }
	 public Project() {
		 inputHandler = new DefaultInputHandler();
	 }
	 public Project createSubProject() {
		 Project subProject = null;
		 try {
			 subProject = (Project) (getClass().newInstance());
		 }
		 catch (Exception e) {
			 subProject = new Project();
		 }
		 initSubProject(subProject);
		 return subProject;
	 }
	 public void initSubProject(Project subProject) {
		 ComponentHelper.getComponentHelper(subProject) .initSubProject(ComponentHelper.getComponentHelper(this));
		 subProject.setDefaultInputStream(getDefaultInputStream());
		 subProject.setKeepGoingMode(this.isKeepGoingMode());
		 subProject.setExecutor(getExecutor().getSubProjectExecutor());
	 }
	 public void init() throws BuildException {
		 initProperties();
		 ComponentHelper.getComponentHelper(this).initDefaultDefinitions();
	 }
	 public void initProperties() throws BuildException {
		 setJavaVersionProperty();
		 setSystemProperties();
		 setPropertyInternal(MagicNames.ANT_VERSION, Main.getAntVersion());
		 setAntLib();
	 }
	 private void setAntLib() {
		 File antlib = org.apache.tools.ant.launch.Locator.getClassSource( Project.class);
		 if (antlib != null) {
			 setPropertyInternal(MagicNames.ANT_LIB, antlib.getAbsolutePath());
		 }
	 }
	 public AntClassLoader createClassLoader(Path path) {
		 return new AntClassLoader( getClass().getClassLoader(), this, path);
	 }
	 public AntClassLoader createClassLoader( ClassLoader parent, Path path) {
		 return new AntClassLoader(parent, this, path);
	 }
	 public void setCoreLoader(ClassLoader coreLoader) {
		 this.coreLoader = coreLoader;
	 }
	 public ClassLoader getCoreLoader() {
		 return coreLoader;
	 }
	 public synchronized void addBuildListener(BuildListener listener) {
		 if (listeners.contains(listener)) {
			 return;
		 }
		 Vector newListeners = getBuildListeners();
		 newListeners.addElement(listener);
		 listeners = newListeners;
	 }
	 public synchronized void removeBuildListener(BuildListener listener) {
		 Vector newListeners = getBuildListeners();
		 newListeners.removeElement(listener);
		 listeners = newListeners;
	 }
	 public Vector getBuildListeners() {
		 return (Vector) listeners.clone();
	 }
	 public void log(String message) {
		 log(message, MSG_INFO);
	 }
	 public void log(String message, int msgLevel) {
		 log(message, null, msgLevel);
	 }
	 public void log(String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(this, message, throwable, msgLevel);
	 }
	 public void log(Task task, String message, int msgLevel) {
		 fireMessageLogged(task, message, null, msgLevel);
	 }
	 public void log(Task task, String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(task, message, throwable, msgLevel);
	 }
	 public void log(Target target, String message, int msgLevel) {
		 log(target, message, null, msgLevel);
	 }
	 public void log(Target target, String message, Throwable throwable, int msgLevel) {
		 fireMessageLogged(target, message, throwable, msgLevel);
	 }
	 public FilterSet getGlobalFilterSet() {
		 return globalFilterSet;
	 }
	 public void setProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this). setProperty(null, name, value, true);
	 }
	 public void setNewProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setNewProperty(null, name, value);
	 }
	 public void setUserProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setUserProperty(null, name, value);
	 }
	 public void setInheritedProperty(String name, String value) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.setInheritedProperty(null, name, value);
	 }
	 private void setPropertyInternal(String name, String value) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.setProperty(null, name, value, false);
	 }
	 public String getProperty(String propertyName) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return (String) ph.getProperty(null, propertyName);
	 }
	 public String replaceProperties(String value) throws BuildException {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.replaceProperties(null, value, null);
	 }
	 public String getUserProperty(String propertyName) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return (String) ph.getUserProperty(null, propertyName);
	 }
	 public Hashtable getProperties() {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.getProperties();
	 }
	 public Hashtable getUserProperties() {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.getUserProperties();
	 }
	 public void copyUserProperties(Project other) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.copyUserProperties(other);
	 }
	 public void copyInheritedProperties(Project other) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.copyInheritedProperties(other);
	 }
	 public void setDefaultTarget(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public String getDefaultTarget() {
		 return defaultTarget;
	 }
	 public void setDefault(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public void setName(String name) {
		 setUserProperty(""ant.project.name"", name);
		 this.name = name;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getDescription() {
		 if (description == null) {
			 description = Description.getDescription(this);
		 }
		 return description;
	 }
	 public void addFilter(String token, String value) {
		 if (token == null) {
			 return;
		 }
		 globalFilterSet.addFilter(new FilterSet.Filter(token, value));
	 }
	 public Hashtable getFilters() {
		 return globalFilterSet.getFilterHash();
	 }
	 public void setBasedir(String baseD) throws BuildException {
		 setBaseDir(new File(baseD));
	 }
	 public void setBaseDir(File baseDir) throws BuildException {
		 baseDir = FILE_UTILS.normalize(baseDir.getAbsolutePath());
		 if (!baseDir.exists()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" does not exist"");
		 }
		 if (!baseDir.isDirectory()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" is not a directory"");
		 }
		 this.baseDir = baseDir;
		 setPropertyInternal(MagicNames.PROJECT_BASEDIR, this.baseDir.getPath());
		 String msg = ""Project base dir set to: "" + this.baseDir;
		 log(msg, MSG_VERBOSE);
	 }
	 public File getBaseDir() {
		 if (baseDir == null) {
			 try {
				 setBasedir(""."");
			 }
			 catch (BuildException ex) {
				 ex.printStackTrace();
			 }
		 }
		 return baseDir;
	 }
	 public void setKeepGoingMode(boolean keepGoingMode) {
		 this.keepGoingMode = keepGoingMode;
	 }
	 public boolean isKeepGoingMode() {
		 return this.keepGoingMode;
	 }
	 public static String getJavaVersion() {
		 return JavaEnvUtils.getJavaVersion();
	 }
	 public void setJavaVersionProperty() throws BuildException {
		 String javaVersion = JavaEnvUtils.getJavaVersion();
		 setPropertyInternal(MagicNames.ANT_JAVA_VERSION, javaVersion);
		 if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_0) || JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1)) {
			 throw new BuildException(""Ant cannot work on Java 1.0 / 1.1"");
		 }
		 log(""Detected Java version: "" + javaVersion + "" in: "" + System.getProperty(""java.home""), MSG_VERBOSE);
		 log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
	 }
	 public void setSystemProperties() {
		 Properties systemP = System.getProperties();
		 Enumeration e = systemP.propertyNames();
		 while (e.hasMoreElements()) {
			 String propertyName = (String) e.nextElement();
			 String value = systemP.getProperty(propertyName);
			 if (value != null) {
				 this.setPropertyInternal(propertyName, value);
			 }
		 }
	 }
	 public void addTaskDefinition(String taskName, Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName, taskClass);
	 }
	 public void checkTaskClass(final Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);
		 if (!Modifier.isPublic(taskClass.getModifiers())) {
			 final String message = taskClass + "" is not public"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 if (Modifier.isAbstract(taskClass.getModifiers())) {
			 final String message = taskClass + "" is abstract"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 try {
			 taskClass.getConstructor((Class[]) null);
		 }
		 catch (NoSuchMethodException e) {
			 final String message = ""No public no-arg constructor in "" + taskClass;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 catch (LinkageError e) {
			 String message = ""Could not load "" + taskClass + "": "" + e;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message, e);
		 }
		 if (!Task.class.isAssignableFrom(taskClass)) {
			 TaskAdapter.checkTaskClass(taskClass, this);
		 }
	 }
	 public Hashtable getTaskDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getTaskDefinitions();
	 }
	 public void addDataTypeDefinition(String typeName, Class typeClass) {
		 ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName, typeClass);
	 }
	 public Hashtable getDataTypeDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();
	 }
	 public void addTarget(Target target) throws BuildException {
		 addTarget(target.getName(), target);
	 }
	 public void addTarget(String targetName, Target target) throws BuildException {
		 if (targets.get(targetName) != null) {
			 throw new BuildException(""Duplicate target: `"" + targetName + ""'"");
		 }
		 addOrReplaceTarget(targetName, target);
	 }
	 public void addOrReplaceTarget(Target target) {
		 addOrReplaceTarget(target.getName(), target);
	 }
	 public void addOrReplaceTarget(String targetName, Target target) {
		 String msg = "" +Target: "" + targetName;
		 log(msg, MSG_DEBUG);
		 target.setProject(this);
		 targets.put(targetName, target);
	 }
	 public Hashtable getTargets() {
		 return targets;
	 }
	 public Task createTask(String taskType) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createTask(taskType);
	 }
	 public Object createDataType(String typeName) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createDataType(typeName);
	 }
	 public void setExecutor(Executor e) {
		 addReference(MagicNames.ANT_EXECUTOR_REFERENCE, e);
	 }
	 public Executor getExecutor() {
		 Object o = getReference(MagicNames.ANT_EXECUTOR_REFERENCE);
		 if (o == null) {
			 String classname = getProperty(MagicNames.ANT_EXECUTOR_CLASSNAME);
			 if (classname == null) {
				 classname = DefaultExecutor.class.getName();
			 }
			 log(""Attempting to create object of type "" + classname, MSG_DEBUG);
			 try {
				 o = Class.forName(classname, true, coreLoader).newInstance();
			 }
			 catch (ClassNotFoundException seaEnEfEx) {
				 try {
					 o = Class.forName(classname).newInstance();
				 }
				 catch (Exception ex) {
					 log(ex.toString(), MSG_ERR);
				 }
			 }
			 catch (Exception ex) {
				 log(ex.toString(), MSG_ERR);
			 }
			 if (o == null) {
				 throw new BuildException( ""Unable to obtain a Target Executor instance."");
			 }
			 setExecutor((Executor) o);
		 }
		 return (Executor) o;
	 }
	 public void executeTargets(Vector names) throws BuildException {
		 getExecutor().executeTargets(this, (String[]) (names.toArray(new String[names.size()])));
	 }
	 public void demuxOutput(String output, boolean isWarning) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 log(output, isWarning ? MSG_WARN : MSG_INFO);
		 }
		 else {
			 if (isWarning) {
				 task.handleErrorOutput(output);
			 }
			 else {
				 task.handleOutput(output);
			 }
		 }
	 }
	 public int defaultInput(byte[] buffer, int offset, int length) throws IOException {
		 if (defaultInputStream != null) {
			 System.out.flush();
			 return defaultInputStream.read(buffer, offset, length);
		 }
		 else {
			 throw new EOFException(""No input provided for project"");
		 }
	 }
	 public int demuxInput(byte[] buffer, int offset, int length) throws IOException {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 return defaultInput(buffer, offset, length);
		 }
		 else {
			 return task.handleInput(buffer, offset, length);
		 }
	 }
	 public void demuxFlush(String output, boolean isError) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);
		 }
		 else {
			 if (isError) {
				 task.handleErrorFlush(output);
			 }
			 else {
				 task.handleFlush(output);
			 }
		 }
	 }
	 public void executeTarget(String targetName) throws BuildException {
		 if (targetName == null) {
			 String msg = ""No target specified"";
			 throw new BuildException(msg);
		 }
		 executeSortedTargets(topoSort(targetName, targets, false));
	 }
	 public void executeSortedTargets(Vector sortedTargets) throws BuildException {
		 Set succeededTargets = new HashSet();
		 BuildException buildException = null;
		 for (Enumeration iter = sortedTargets.elements();
		 iter.hasMoreElements();
		) {
			 Target curtarget = (Target) iter.nextElement();
			 boolean canExecute = true;
			 for (Enumeration depIter = curtarget.getDependencies();
			 depIter.hasMoreElements();
			) {
				 String dependencyName = ((String) depIter.nextElement());
				 if (!succeededTargets.contains(dependencyName)) {
					 canExecute = false;
					 log(curtarget, ""Cannot execute '"" + curtarget.getName() + ""' - '"" + dependencyName + ""' failed or was not executed."", MSG_ERR);
					 break;
				 }
			 }
			 if (canExecute) {
				 Throwable thrownException = null;
				 try {
					 curtarget.performTasks();
					 succeededTargets.add(curtarget.getName());
				 }
				 catch (RuntimeException ex) {
					 if (!(keepGoingMode)) {
						 throw ex;
					 }
					 thrownException = ex;
				 }
				 catch (Throwable ex) {
					 if (!(keepGoingMode)) {
						 throw new BuildException(ex);
					 }
					 thrownException = ex;
				 }
				 if (thrownException != null) {
					 if (thrownException instanceof BuildException) {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 if (buildException == null) {
							 buildException = (BuildException) thrownException;
						 }
					 }
					 else {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 thrownException.printStackTrace(System.err);
						 if (buildException == null) {
							 buildException = new BuildException(thrownException);
						 }
					 }
				 }
			 }
		 }
		 if (buildException != null) {
			 throw buildException;
		 }
	 }
	 public File resolveFile(String fileName, File rootDir) {
		 return FILE_UTILS.resolveFile(rootDir, fileName);
	 }
	 public File resolveFile(String fileName) {
		 return FILE_UTILS.resolveFile(baseDir, fileName);
	 }
	 public static String translatePath(String toProcess) {
		 return FileUtils.translatePath(toProcess);
	 }
	 public void copyFile(String sourceFile, String destFile) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void copyFile(File sourceFile, File destFile) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 FILE_UTILS.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void setFileLastModified(File file, long time) throws BuildException {
		 FILE_UTILS.setFileLastModified(file, time);
		 log(""Setting modification time for "" + file, MSG_VERBOSE);
	 }
	 public static boolean toBoolean(String s) {
		 return (""on"".equalsIgnoreCase(s) || ""true"".equalsIgnoreCase(s) || ""yes"".equalsIgnoreCase(s));
	 }
	 public static Project getProject(Object o) {
		 if (o instanceof ProjectComponent) {
			 return ((ProjectComponent) o).getProject();
		 }
		 try {
			 Method m = o.getClass().getMethod(""getProject"", (Class[]) null);
			 if (Project.class == m.getReturnType()) {
				 return (Project) m.invoke(o, (Object[]) null);
			 }
		 }
		 catch (Exception e) {
		 }
		 return null;
	 }
	 public final Vector topoSort(String root, Hashtable targetTable) throws BuildException {
		 return topoSort(new String[] {
		root}
		, targetTable, true);
	 }
	 public final Vector topoSort(String root, Hashtable targetTable, boolean returnAll) throws BuildException {
		 return topoSort(new String[] {
		root}
		, targetTable, returnAll);
	 }
	 public final Vector topoSort(String[] root, Hashtable targetTable, boolean returnAll) throws BuildException {
		 Vector ret = new Vector();
		 Hashtable state = new Hashtable();
		 Stack visiting = new Stack();
		 for (int i = 0;
		 i < root.length;
		 i++) {
			 String st = (String) (state.get(root[i]));
			 if (st == null) {
				 tsort(root[i], targetTable, state, visiting, ret);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + root[i]);
			 }
		 }
		 StringBuffer buf = new StringBuffer(""Build sequence for target(s)"");
		 for (int j = 0;
		 j < root.length;
		 j++) {
			 buf.append((j == 0) ? "" `"" : "", `"").append(root[j]).append('\'');
		 }
		 buf.append("" is "" + ret);
		 log(buf.toString(), MSG_VERBOSE);
		 Vector complete = (returnAll) ? ret : new Vector(ret);
		 for (Enumeration en = targetTable.keys();
		 en.hasMoreElements();
		) {
			 String curTarget = (String) en.nextElement();
			 String st = (String) state.get(curTarget);
			 if (st == null) {
				 tsort(curTarget, targetTable, state, visiting, complete);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + curTarget);
			 }
		 }
		 log(""Complete build sequence is "" + complete, MSG_VERBOSE);
		 return ret;
	 }
	 private void tsort(String root, Hashtable targetTable, Hashtable state, Stack visiting, Vector ret) throws BuildException {
		 state.put(root, VISITING);
		 visiting.push(root);
		 Target target = (Target) targetTable.get(root);
		 if (target == null) {
			 StringBuffer sb = new StringBuffer(""Target \"""");
			 sb.append(root);
			 sb.append(""\"" does not exist in the project \"""");
			 sb.append(name);
			 sb.append(""\"". "");
			 visiting.pop();
			 if (!visiting.empty()) {
				 String parent = (String) visiting.peek();
				 sb.append(""It is used from target \"""");
				 sb.append(parent);
				 sb.append(""\""."");
			 }
			 throw new BuildException(new String(sb));
		 }
		 for (Enumeration en = target.getDependencies();
		 en.hasMoreElements();
		) {
			 String cur = (String) en.nextElement();
			 String m = (String) state.get(cur);
			 if (m == null) {
				 tsort(cur, targetTable, state, visiting, ret);
			 }
			 else if (m == VISITING) {
				 throw makeCircularException(cur, visiting);
			 }
		 }
		 String p = (String) visiting.pop();
		 if (root != p) {
			 throw new RuntimeException(""Unexpected internal error: expected to "" + ""pop "" + root + "" but got "" + p);
		 }
		 state.put(root, VISITED);
		 ret.addElement(target);
	 }
	 private static BuildException makeCircularException(String end, Stack stk) {
		 StringBuffer sb = new StringBuffer(""Circular dependency: "");
		 sb.append(end);
		 String c;
		 do {
			 c = (String) stk.pop();
			 sb.append("" <- "");
			 sb.append(c);
		 }
		 while (!c.equals(end));
		 return new BuildException(new String(sb));
	 }
	 public void inheritIDReferences(Project parent) {
		 parentIdProject = parent;
	 }
	 private Object resolveIdReference(String key, Project callerProject) {
		 UnknownElement origUE = (UnknownElement) idReferences.get(key);
		 if (origUE == null) {
			 return parentIdProject == null ? null : parentIdProject.resolveIdReference(key, callerProject);
		 }
		 callerProject.log( ""Warning: Reference "" + key + "" has not been set at runtime,"" + "" but was found during"" + LINE_SEP + ""build file parsing, attempting to resolve."" + "" Future versions of Ant may support"" + LINE_SEP + "" referencing ids defined in non-executed targets."", MSG_WARN);
		 UnknownElement copyUE = origUE.copy(callerProject);
		 copyUE.maybeConfigure();
		 return copyUE.getRealThing();
	 }
	 public void addIdReference(String id, Object value) {
		 idReferences.put(id, value);
	 }
	 public void addReference(String referenceName, Object value) {
		 synchronized (references) {
			 Object old = ((AntRefTable) references).getReal(referenceName);
			 if (old == value) {
				 return;
			 }
			 if (old != null && !(old instanceof UnknownElement)) {
				 log(""Overriding previous definition of reference to "" + referenceName, MSG_VERBOSE);
			 }
			 log(""Adding reference: "" + referenceName, MSG_DEBUG);
			 references.put(referenceName, value);
		 }
	 }
	 public Hashtable getReferences() {
		 return references;
	 }
	 public Object getReference(String key) {
		 Object ret = references.get(key);
		 if (ret != null) {
			 return ret;
		 }
		 ret = resolveIdReference(key, this);
		 if (ret == null && !key.equals(MagicNames.REFID_PROPERTY_HELPER)) {
			 Vector p = new Vector();
			 PropertyHelper.getPropertyHelper(this).parsePropertyString( key, new Vector(), p);
			 if (p.size() == 1) {
				 log(""Unresolvable reference "" + key + "" might be a misuse of property expansion syntax."", MSG_WARN);
			 }
		 }
		 return ret;
	 }
	 public String getElementName(Object element) {
		 return ComponentHelper.getComponentHelper(this).getElementName(element);
	 }
	 public void fireBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.buildStarted(event);
		 }
	 }
	 public void fireBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.buildFinished(event);
		 }
		 IntrospectionHelper.clearCache();
	 }
	 public void fireSubBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 Object listener = iter.next();
			 if (listener instanceof SubBuildListener) {
				 ((SubBuildListener) listener).subBuildStarted(event);
			 }
		 }
	 }
	 public void fireSubBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 Object listener = iter.next();
			 if (listener instanceof SubBuildListener) {
				 ((SubBuildListener) listener).subBuildFinished(event);
			 }
		 }
	 }
	 protected void fireTargetStarted(Target target) {
		 BuildEvent event = new BuildEvent(target);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.targetStarted(event);
		 }
	 }
	 protected void fireTargetFinished(Target target, Throwable exception) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.targetFinished(event);
		 }
	 }
	 protected void fireTaskStarted(Task task) {
		 registerThreadTask(Thread.currentThread(), task);
		 BuildEvent event = new BuildEvent(task);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.taskStarted(event);
		 }
	 }
	 protected void fireTaskFinished(Task task, Throwable exception) {
		 registerThreadTask(Thread.currentThread(), null);
		 System.out.flush();
		 System.err.flush();
		 BuildEvent event = new BuildEvent(task);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.taskFinished(event);
		 }
	 }
	 private void fireMessageLoggedEvent(BuildEvent event, String message, int priority) {
		 if (message.endsWith(StringUtils.LINE_SEP)) {
			 int endIndex = message.length() - StringUtils.LINE_SEP.length();
			 event.setMessage(message.substring(0, endIndex), priority);
		 }
		 else {
			 event.setMessage(message, priority);
		 }
		 synchronized (this) {
			 if (loggingMessage) {
				 return;
			 }
			 try {
				 loggingMessage = true;
				 Iterator iter = listeners.iterator();
				 while (iter.hasNext()) {
					 BuildListener listener = (BuildListener) iter.next();
					 listener.messageLogged(event);
				 }
			 }
			 finally {
				 loggingMessage = false;
			 }
		 }
	 }
	 protected void fireMessageLogged(Project project, String message, int priority) {
		 fireMessageLogged(project, message, null, priority);
	 }
	 protected void fireMessageLogged(Project project, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(project);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, int priority) {
		 fireMessageLogged(target, message, null, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, int priority) {
		 fireMessageLogged(task, message, null, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, Throwable throwable, int priority) {
		 BuildEvent event = new BuildEvent(task);
		 event.setException(throwable);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 public synchronized void registerThreadTask(Thread thread, Task task) {
		 if (task != null) {
			 threadTasks.put(thread, task);
			 threadGroupTasks.put(thread.getThreadGroup(), task);
		 }
		 else {
			 threadTasks.remove(thread);
			 threadGroupTasks.remove(thread.getThreadGroup());
		 }
	 }
	 public Task getThreadTask(Thread thread) {
		 Task task = (Task) threadTasks.get(thread);
		 if (task == null) {
			 ThreadGroup group = thread.getThreadGroup();
			 while (task == null && group != null) {
				 task = (Task) threadGroupTasks.get(group);
				 group = group.getParent();
			 }
		 }
		 return task;
	 }
	 private static class AntRefTable extends Hashtable {
		 AntRefTable() {
			 super();
		 }
		 private Object getReal(Object key) {
			 return super.get(key);
		 }
		 public Object get(Object key) {
			 Object o = getReal(key);
			 if (o instanceof UnknownElement) {
				 UnknownElement ue = (UnknownElement) o;
				 ue.maybeConfigure();
				 o = ue.getRealThing();
			 }
			 return o;
		 }
	 }
	 public final void setProjectReference(final Object obj) {
		 if (obj instanceof ProjectComponent) {
			 ((ProjectComponent) obj).setProject(this);
			 return;
		 }
		 try {
			 Method method = obj.getClass().getMethod( ""setProject"", new Class[] {
			Project.class}
			);
			 if (method != null) {
				 method.invoke(obj, new Object[] {
				this}
				);
			 }
		 }
		 catch (Throwable e) {
		 }
	 }
	 public Resource getResource(String name) {
		 return new FileResource(getBaseDir(), name);
	 }
}",1,0,0,0
"public class ParseEngine extends JavaCCGlobals {
	 static private java.io.PrintWriter ostr;
	 static private int gensymindex = 0;
	 static private int indentamt;
	 static private boolean jj2LA;
	 static private List phase2list = new ArrayList();
	 static private List phase3list = new ArrayList();
	 static private java.util.Hashtable phase3table = new java.util.Hashtable();
	 static private boolean javaCodeCheck(Expansion exp) {
		 if (exp instanceof RegularExpression) {
			 return false;
		 }
		 else if (exp instanceof NonTerminal) {
			 NormalProduction prod = ((NonTerminal)exp).getProd();
			 if (prod instanceof JavaCodeProduction) {
				 return true;
			 }
			 else {
				 return javaCodeCheck(prod.getExpansion());
			 }
		 }
		 else if (exp instanceof Choice) {
			 Choice ch = (Choice)exp;
			 for (int i = 0;
			 i < ch.getChoices().size();
			 i++) {
				 if (javaCodeCheck((Expansion)(ch.getChoices().get(i)))) {
					 return true;
				 }
			 }
			 return false;
		 }
		 else if (exp instanceof Sequence) {
			 Sequence seq = (Sequence)exp;
			 for (int i = 0;
			 i < seq.units.size();
			 i++) {
				 Expansion[] units = (Expansion[])seq.units.toArray(new Expansion[seq.units.size()]);
				 if (units[i] instanceof Lookahead && ((Lookahead)units[i]).isExplicit()) {
					 return false;
				 }
				 else if (javaCodeCheck((units[i]))) {
					 return true;
				 }
				 else if (!Semanticize.emptyExpansionExists(units[i])) {
					 return false;
				 }
			 }
			 return false;
		 }
		 else if (exp instanceof OneOrMore) {
			 OneOrMore om = (OneOrMore)exp;
			 return javaCodeCheck(om.expansion);
		 }
		 else if (exp instanceof ZeroOrMore) {
			 ZeroOrMore zm = (ZeroOrMore)exp;
			 return javaCodeCheck(zm.expansion);
		 }
		 else if (exp instanceof ZeroOrOne) {
			 ZeroOrOne zo = (ZeroOrOne)exp;
			 return javaCodeCheck(zo.expansion);
		 }
		 else if (exp instanceof TryBlock) {
			 TryBlock tb = (TryBlock)exp;
			 return javaCodeCheck(tb.exp);
		 }
		 else {
			 return false;
		 }
	 }
	 static private boolean[] firstSet;
	 static private void genFirstSet(Expansion exp) {
		 if (exp instanceof RegularExpression) {
			 firstSet[((RegularExpression)exp).ordinal] = true;
		 }
		 else if (exp instanceof NonTerminal) {
			 if (!(((NonTerminal)exp).getProd() instanceof JavaCodeProduction)) {
				 genFirstSet(((BNFProduction)(((NonTerminal)exp).getProd())).getExpansion());
			 }
		 }
		 else if (exp instanceof Choice) {
			 Choice ch = (Choice)exp;
			 for (int i = 0;
			 i < ch.getChoices().size();
			 i++) {
				 genFirstSet((Expansion)(ch.getChoices().get(i)));
			 }
		 }
		 else if (exp instanceof Sequence) {
			 Sequence seq = (Sequence)exp;
			 Object obj = seq.units.get(0);
			 if ((obj instanceof Lookahead) && (((Lookahead)obj).getActionTokens().size() != 0)) {
				 jj2LA = true;
			 }
			 for (int i = 0;
			 i < seq.units.size();
			 i++) {
				 Expansion unit = (Expansion) seq.units.get(i);
				 if (unit instanceof NonTerminal && ((NonTerminal)unit).getProd() instanceof JavaCodeProduction) {
					 if (i > 0 && seq.units.get(i-1) instanceof Lookahead) {
						 Lookahead la = (Lookahead)seq.units.get(i-1);
						 genFirstSet(la.getLaExpansion());
					 }
				 }
				 else {
					 genFirstSet((Expansion)(seq.units.get(i)));
				 }
				 if (!Semanticize.emptyExpansionExists((Expansion)(seq.units.get(i)))) {
					 break;
				 }
			 }
		 }
		 else if (exp instanceof OneOrMore) {
			 OneOrMore om = (OneOrMore)exp;
			 genFirstSet(om.expansion);
		 }
		 else if (exp instanceof ZeroOrMore) {
			 ZeroOrMore zm = (ZeroOrMore)exp;
			 genFirstSet(zm.expansion);
		 }
		 else if (exp instanceof ZeroOrOne) {
			 ZeroOrOne zo = (ZeroOrOne)exp;
			 genFirstSet(zo.expansion);
		 }
		 else if (exp instanceof TryBlock) {
			 TryBlock tb = (TryBlock)exp;
			 genFirstSet(tb.exp);
		 }
	 }
	 static final int NOOPENSTM = 0;
	 static final int OPENIF = 1;
	 static final int OPENSWITCH = 2;
	 private static void dumpLookaheads(Lookahead[] conds, String[] actions) {
		 for (int i = 0;
		 i < conds.length;
		 i++) {
			 System.err.println(""Lookahead: "" + i);
			 System.err.println(conds[i].dump(0, new HashSet()));
			 System.err.println();
		 }
	 }
	 static String buildLookaheadChecker(Lookahead[] conds, String[] actions) {
		 int state = NOOPENSTM;
		 int indentAmt = 0;
		 boolean[] casedValues = new boolean[tokenCount];
		 String retval = """";
		 Lookahead la;
		 Token t = null;
		 int tokenMaskSize = (tokenCount-1)/32 + 1;
		 int[] tokenMask = null;
		 int index = 0;
		 while (index < conds.length) {
			 la = conds[index];
			 jj2LA = false;
			 if ((la.getAmount() == 0) || Semanticize.emptyExpansionExists(la.getLaExpansion()) || javaCodeCheck(la.getLaExpansion()) ) {
				 if (la.getActionTokens().size() == 0) {
					 break;
				 }
				 else {
					 switch (state) {
						 case NOOPENSTM: retval += ""\n"" + ""if ("";
						 indentAmt++;
						 break;
					 case OPENIF: retval += ""\u0002\n"" + ""}
					 else if ("";
					 break;
					 case OPENSWITCH: retval += ""\u0002\n"" + ""default:"" + ""\u0001"";
					 if (Options.getErrorReporting()) {
						 retval += ""\njj_la1["" + maskindex + ""] = jj_gen;
						"";
						 maskindex++;
					 }
					 maskVals.add(tokenMask);
					 retval += ""\n"" + ""if ("";
					 indentAmt++;
				 }
				 printTokenSetup((Token)(la.getActionTokens().get(0)));
				 for (Iterator it = la.getActionTokens().iterator();
				 it.hasNext();
				) {
					 t = (Token)it.next();
					 retval += printToken(t);
				 }
				 retval += printTrailingComments(t);
				 retval += "") {
					\u0001"" + actions[index];
					 state = OPENIF;
				 }
			 }
			 else if (la.getAmount() == 1 && la.getActionTokens().size() == 0) {
				 if (firstSet == null) {
					 firstSet = new boolean[tokenCount];
				 }
				 for (int i = 0;
				 i < tokenCount;
				 i++) {
					 firstSet[i] = false;
				 }
				 genFirstSet(la.getLaExpansion());
				 if (!jj2LA) {
					 switch (state) {
					 case OPENIF: retval += ""\u0002\n"" + ""}
					 else {
						\u0001"";
						 case NOOPENSTM: retval += ""\n"" + ""switch ("";
						 if (Options.getCacheTokens()) {
							 retval += ""jj_nt.kind) {
								\u0001"";
							 }
							 else {
								 retval += ""(jj_ntk==-1)?jj_ntk():jj_ntk) {
									\u0001"";
								 }
								 for (int i = 0;
								 i < tokenCount;
								 i++) {
									 casedValues[i] = false;
								 }
								 indentAmt++;
								 tokenMask = new int[tokenMaskSize];
								 for (int i = 0;
								 i < tokenMaskSize;
								 i++) {
									 tokenMask[i] = 0;
								 }
							 }
							 for (int i = 0;
							 i < tokenCount;
							 i++) {
								 if (firstSet[i]) {
									 if (!casedValues[i]) {
										 casedValues[i] = true;
										 retval += ""\u0002\ncase "";
										 int j1 = i/32;
										 int j2 = i%32;
										 tokenMask[j1] |= 1 << j2;
										 String s = (String)(names_of_tokens.get(new Integer(i)));
										 if (s == null) {
											 retval += i;
										 }
										 else {
											 retval += s;
										 }
										 retval += "":\u0001"";
									 }
								 }
							 }
							 retval += actions[index];
							 retval += ""\nbreak;
							"";
							 state = OPENSWITCH;
						 }
					 }
					 else {
						 jj2LA = true;
					 }
					 if (jj2LA) {
						 switch (state) {
							 case NOOPENSTM: retval += ""\n"" + ""if ("";
							 indentAmt++;
							 break;
						 case OPENIF: retval += ""\u0002\n"" + ""}
						 else if ("";
						 break;
						 case OPENSWITCH: retval += ""\u0002\n"" + ""default:"" + ""\u0001"";
						 if (Options.getErrorReporting()) {
							 retval += ""\njj_la1["" + maskindex + ""] = jj_gen;
							"";
							 maskindex++;
						 }
						 maskVals.add(tokenMask);
						 retval += ""\n"" + ""if ("";
						 indentAmt++;
					 }
					 jj2index++;
					 la.getLaExpansion().internal_name = ""_"" + jj2index;
					 phase2list.add(la);
					 retval += ""jj_2"" + la.getLaExpansion().internal_name + ""("" + la.getAmount() + "")"";
					 if (la.getActionTokens().size() != 0) {
						 retval += "" && ("";
						 printTokenSetup((Token)(la.getActionTokens().get(0)));
						 for (Iterator it = la.getActionTokens().iterator();
						 it.hasNext();
						) {
							 t = (Token)it.next();
							 retval += printToken(t);
						 }
						 retval += printTrailingComments(t);
						 retval += "")"";
					 }
					 retval += "") {
						\u0001"" + actions[index];
						 state = OPENIF;
					 }
					 index++;
				 }
				 switch (state) {
					 case NOOPENSTM: retval += actions[index];
					 break;
				 case OPENIF: retval += ""\u0002\n"" + ""}
				 else {
					\u0001"" + actions[index];
					 break;
					 case OPENSWITCH: retval += ""\u0002\n"" + ""default:"" + ""\u0001"";
					 if (Options.getErrorReporting()) {
						 retval += ""\njj_la1["" + maskindex + ""] = jj_gen;
						"";
						 maskVals.add(tokenMask);
						 maskindex++;
					 }
					 retval += actions[index];
				 }
				 for (int i = 0;
				 i < indentAmt;
				 i++) {
				 retval += ""\u0002\n}
				"";
			 }
			 return retval;
		 }
		 static void dumpFormattedString(String str) {
			 char ch = ' ';
			 char prevChar;
			 boolean indentOn = true;
			 for (int i = 0;
			 i < str.length();
			 i++) {
				 prevChar = ch;
				 ch = str.charAt(i);
				 if (ch == '\n' && prevChar == '\r') {
				 }
				 else if (ch == '\n' || ch == '\r') {
					 if (indentOn) {
						 phase1NewLine();
					 }
					 else {
						 ostr.println("""");
					 }
				 }
				 else if (ch == '\u0001') {
					 indentamt += 2;
				 }
				 else if (ch == '\u0002') {
					 indentamt -= 2;
				 }
				 else if (ch == '\u0003') {
					 indentOn = false;
				 }
				 else if (ch == '\u0004') {
					 indentOn = true;
				 }
				 else {
					 ostr.print(ch);
				 }
			 }
		 }
		 static void buildPhase1Routine(BNFProduction p) {
			 Token t;
			 t = (Token)(p.getReturnTypeTokens().get(0));
			 boolean voidReturn = false;
			 if (t.kind == JavaCCParserConstants.VOID) {
				 voidReturn = true;
			 }
			 printTokenSetup(t);
			 ccol = 1;
			 printLeadingComments(t, ostr);
			 ostr.print("" "" + staticOpt() + ""final "" +(p.getAccessMod() != null ? p.getAccessMod() : ""public"")+ "" "");
			 cline = t.beginLine;
			 ccol = t.beginColumn;
			 printTokenOnly(t, ostr);
			 for (int i = 1;
			 i < p.getReturnTypeTokens().size();
			 i++) {
				 t = (Token)(p.getReturnTypeTokens().get(i));
				 printToken(t, ostr);
			 }
			 printTrailingComments(t, ostr);
			 ostr.print("" "" + p.getLhs() + ""("");
			 if (p.getParameterListTokens().size() != 0) {
				 printTokenSetup((Token)(p.getParameterListTokens().get(0)));
				 for (java.util.Iterator it = p.getParameterListTokens().iterator();
				 it.hasNext();
				) {
					 t = (Token)it.next();
					 printToken(t, ostr);
				 }
				 printTrailingComments(t, ostr);
			 }
			 ostr.print("") throws ParseException"");
			 for (java.util.Iterator it = p.getThrowsList().iterator();
			 it.hasNext();
			) {
				 ostr.print("", "");
				 java.util.List name = (java.util.List)it.next();
				 for (java.util.Iterator it2 = name.iterator();
				 it2.hasNext();
				) {
					 t = (Token)it2.next();
					 ostr.print(t.image);
				 }
			 }
			 ostr.print("" {
				"");
				 indentamt = 4;
				 if (Options.getDebugParser()) {
					 ostr.println("""");
					 ostr.println("" trace_call(\"""" + p.getLhs() + ""\"");
					"");
					 ostr.print("" try {
						"");
						 indentamt = 6;
					 }
					 if (p.getDeclarationTokens().size() != 0) {
						 printTokenSetup((Token)(p.getDeclarationTokens().get(0)));
						 cline--;
						 for (Iterator it = p.getDeclarationTokens().iterator();
						 it.hasNext();
						) {
							 t = (Token)it.next();
							 printToken(t, ostr);
						 }
						 printTrailingComments(t, ostr);
					 }
					 String code = phase1ExpansionGen(p.getExpansion());
					 dumpFormattedString(code);
					 ostr.println("""");
					 if (p.isJumpPatched() && !voidReturn) {
						 ostr.println("" throw new Error(\""Missing return statement in function\"");
						"");
					 }
					 if (Options.getDebugParser()) {
					 ostr.println("" }
					 finally {
						"");
						 ostr.println("" trace_return(\"""" + p.getLhs() + ""\"");
						"");
					 ostr.println("" }
					"");
				 }
			 ostr.println("" }
			"");
			 ostr.println("""");
		 }
		 static void phase1NewLine() {
			 ostr.println("""");
			 for (int i = 0;
			 i < indentamt;
			 i++) {
				 ostr.print("" "");
			 }
		 }
		 static String phase1ExpansionGen(Expansion e) {
			 String retval = """";
			 Token t = null;
			 Lookahead[] conds;
			 String[] actions;
			 if (e instanceof RegularExpression) {
				 RegularExpression e_nrw = (RegularExpression)e;
				 retval += ""\n"";
				 if (e_nrw.lhsTokens.size() != 0) {
					 printTokenSetup((Token)(e_nrw.lhsTokens.get(0)));
					 for (java.util.Iterator it = e_nrw.lhsTokens.iterator();
					 it.hasNext();
					) {
						 t = (Token)it.next();
						 retval += printToken(t);
					 }
					 retval += printTrailingComments(t);
					 retval += "" = "";
				 }
				 String tail = e_nrw.rhsToken == null ? "");
				"" : "")."" + e_nrw.rhsToken.image + "";
				"";
				 if (e_nrw.label.equals("""")) {
					 Object label = names_of_tokens.get(new Integer(e_nrw.ordinal));
					 if (label != null) {
						 retval += ""jj_consume_token("" + (String)label + tail;
					 }
					 else {
						 retval += ""jj_consume_token("" + e_nrw.ordinal + tail;
					 }
				 }
				 else {
					 retval += ""jj_consume_token("" + e_nrw.label + tail;
				 }
			 }
			 else if (e instanceof NonTerminal) {
				 NonTerminal e_nrw = (NonTerminal)e;
				 retval += ""\n"";
				 if (e_nrw.getLhsTokens().size() != 0) {
					 printTokenSetup((Token)(e_nrw.getLhsTokens().get(0)));
					 for (java.util.Iterator it = e_nrw.getLhsTokens().iterator();
					 it.hasNext();
					) {
						 t = (Token)it.next();
						 retval += printToken(t);
					 }
					 retval += printTrailingComments(t);
					 retval += "" = "";
				 }
				 retval += e_nrw.getName() + ""("";
				 if (e_nrw.getArgumentTokens().size() != 0) {
					 printTokenSetup((Token)(e_nrw.getArgumentTokens().get(0)));
					 for (java.util.Iterator it = e_nrw.getArgumentTokens().iterator();
					 it.hasNext();
					) {
						 t = (Token)it.next();
						 retval += printToken(t);
					 }
					 retval += printTrailingComments(t);
				 }
				 retval += "");
				"";
			 }
			 else if (e instanceof Action) {
				 Action e_nrw = (Action)e;
				 retval += ""\u0003\n"";
				 if (e_nrw.getActionTokens().size() != 0) {
					 printTokenSetup((Token)(e_nrw.getActionTokens().get(0)));
					 ccol = 1;
					 for (Iterator it = e_nrw.getActionTokens().iterator();
					 it.hasNext();
					) {
						 t = (Token)it.next();
						 retval += printToken(t);
					 }
					 retval += printTrailingComments(t);
				 }
				 retval += ""\u0004"";
			 }
			 else if (e instanceof Choice) {
				 Choice e_nrw = (Choice)e;
				 conds = new Lookahead[e_nrw.getChoices().size()];
				 actions = new String[e_nrw.getChoices().size() + 1];
				 actions[e_nrw.getChoices().size()] = ""\n"" + ""jj_consume_token(-1);
				\n"" + ""throw new ParseException();
				"";
				 Sequence nestedSeq;
				 for (int i = 0;
				 i < e_nrw.getChoices().size();
				 i++) {
					 nestedSeq = (Sequence)(e_nrw.getChoices().get(i));
					 actions[i] = phase1ExpansionGen(nestedSeq);
					 conds[i] = (Lookahead)(nestedSeq.units.get(0));
				 }
				 retval = buildLookaheadChecker(conds, actions);
			 }
			 else if (e instanceof Sequence) {
				 Sequence e_nrw = (Sequence)e;
				 for (int i = 1;
				 i < e_nrw.units.size();
				 i++) {
					 retval += phase1ExpansionGen((Expansion)(e_nrw.units.get(i)));
				 }
			 }
			 else if (e instanceof OneOrMore) {
				 OneOrMore e_nrw = (OneOrMore)e;
				 Expansion nested_e = e_nrw.expansion;
				 Lookahead la;
				 if (nested_e instanceof Sequence) {
					 la = (Lookahead)(((Sequence)nested_e).units.get(0));
				 }
				 else {
					 la = new Lookahead();
					 la.setAmount(Options.getLookahead());
					 la.setLaExpansion(nested_e);
				 }
				 retval += ""\n"";
				 int labelIndex = ++gensymindex;
				 retval += ""label_"" + labelIndex + "":\n"";
				 retval += ""while (true) {
					\u0001"";
					 retval += phase1ExpansionGen(nested_e);
					 conds = new Lookahead[1];
					 conds[0] = la;
					 actions = new String[2];
					 actions[0] = ""\n;
					"";
					 actions[1] = ""\nbreak label_"" + labelIndex + "";
					"";
					 retval += buildLookaheadChecker(conds, actions);
				 retval += ""\u0002\n"" + ""}
				"";
			 }
			 else if (e instanceof ZeroOrMore) {
				 ZeroOrMore e_nrw = (ZeroOrMore)e;
				 Expansion nested_e = e_nrw.expansion;
				 Lookahead la;
				 if (nested_e instanceof Sequence) {
					 la = (Lookahead)(((Sequence)nested_e).units.get(0));
				 }
				 else {
					 la = new Lookahead();
					 la.setAmount(Options.getLookahead());
					 la.setLaExpansion(nested_e);
				 }
				 retval += ""\n"";
				 int labelIndex = ++gensymindex;
				 retval += ""label_"" + labelIndex + "":\n"";
				 retval += ""while (true) {
					\u0001"";
					 conds = new Lookahead[1];
					 conds[0] = la;
					 actions = new String[2];
					 actions[0] = ""\n;
					"";
					 actions[1] = ""\nbreak label_"" + labelIndex + "";
					"";
					 retval += buildLookaheadChecker(conds, actions);
					 retval += phase1ExpansionGen(nested_e);
				 retval += ""\u0002\n"" + ""}
				"";
			 }
			 else if (e instanceof ZeroOrOne) {
				 ZeroOrOne e_nrw = (ZeroOrOne)e;
				 Expansion nested_e = e_nrw.expansion;
				 Lookahead la;
				 if (nested_e instanceof Sequence) {
					 la = (Lookahead)(((Sequence)nested_e).units.get(0));
				 }
				 else {
					 la = new Lookahead();
					 la.setAmount(Options.getLookahead());
					 la.setLaExpansion(nested_e);
				 }
				 conds = new Lookahead[1];
				 conds[0] = la;
				 actions = new String[2];
				 actions[0] = phase1ExpansionGen(nested_e);
				 actions[1] = ""\n;
				"";
				 retval += buildLookaheadChecker(conds, actions);
			 }
			 else if (e instanceof TryBlock) {
				 TryBlock e_nrw = (TryBlock)e;
				 Expansion nested_e = e_nrw.exp;
				 java.util.List list;
				 retval += ""\n"";
				 retval += ""try {
					\u0001"";
					 retval += phase1ExpansionGen(nested_e);
				 retval += ""\u0002\n"" + ""}
				"";
				 for (int i = 0;
				 i < e_nrw.catchblks.size();
				 i++) {
					 retval += "" catch ("";
					 list = (java.util.List)(e_nrw.types.get(i));
					 if (list.size() != 0) {
						 printTokenSetup((Token)(list.get(0)));
						 for (java.util.Iterator it = list.iterator();
						 it.hasNext();
						) {
							 t = (Token)it.next();
							 retval += printToken(t);
						 }
						 retval += printTrailingComments(t);
					 }
					 retval += "" "";
					 t = (Token)(e_nrw.ids.get(i));
					 printTokenSetup(t);
					 retval += printToken(t);
					 retval += printTrailingComments(t);
					 retval += "") {
						\u0003\n"";
						 list = (java.util.List)(e_nrw.catchblks.get(i));
						 if (list.size() != 0) {
							 printTokenSetup((Token)(list.get(0)));
							 ccol = 1;
							 for (java.util.Iterator it = list.iterator();
							 it.hasNext();
							) {
								 t = (Token)it.next();
								 retval += printToken(t);
							 }
							 retval += printTrailingComments(t);
						 }
					 retval += ""\u0004\n"" + ""}
					"";
				 }
				 if (e_nrw.finallyblk != null) {
					 retval += "" finally {
						\u0003\n"";
						 if (e_nrw.finallyblk.size() != 0) {
							 printTokenSetup((Token)(e_nrw.finallyblk.get(0)));
							 ccol = 1;
							 for (java.util.Iterator it = e_nrw.finallyblk.iterator();
							 it.hasNext();
							) {
								 t = (Token)it.next();
								 retval += printToken(t);
							 }
							 retval += printTrailingComments(t);
						 }
					 retval += ""\u0004\n"" + ""}
					"";
				 }
			 }
			 return retval;
		 }
		 static void buildPhase2Routine(Lookahead la) {
			 Expansion e = la.getLaExpansion();
			 ostr.println("" "" + staticOpt() + ""private boolean jj_2"" + e.internal_name + ""(int xla) {
				"");
				 ostr.println("" jj_la = xla;
				 jj_lastpos = jj_scanpos = token;
				"");
				 ostr.println("" try {
					 return !jj_3"" + e.internal_name + ""();
				 }
				"");
				 ostr.println("" catch(LookaheadSuccess ls) {
					 return true;
				 }
				"");
				 if (Options.getErrorReporting()) ostr.println("" finally {
					 jj_save("" + (Integer.parseInt(e.internal_name.substring(1))-1) + "", xla);
				 }
				"");
			 ostr.println("" }
			"");
			 ostr.println("""");
			 Phase3Data p3d = new Phase3Data(e, la.getAmount());
			 phase3list.add(p3d);
			 phase3table.put(e, p3d);
		 }
		 static private boolean xsp_declared;
		 static Expansion jj3_expansion;
		 static String genReturn(boolean value) {
			 String retval = (value ? ""true"" : ""false"");
			 if (Options.getDebugLookahead() && jj3_expansion != null) {
				 String tracecode = ""trace_return(\"""" + ((NormalProduction)jj3_expansion.parent).getLhs() + ""(LOOKAHEAD "" + (value ? ""FAILED"" : ""SUCCEEDED"") + "")\"");
				"";
				 if (Options.getErrorReporting()) {
					 tracecode = ""if (!jj_rescan) "" + tracecode;
				 }
				 return ""{
					 "" + tracecode + "" return "" + retval + "";
				 }
				"";
			 }
			 else {
				 return ""return "" + retval + "";
				"";
			 }
		 }
		 private static void generate3R(Expansion e, Phase3Data inf) {
			 Expansion seq = e;
			 if (e.internal_name.equals("""")) {
				 while (true) {
					 if (seq instanceof Sequence && ((Sequence)seq).units.size() == 2) {
						 seq = (Expansion)((Sequence)seq).units.get(1);
					 }
					 else if (seq instanceof NonTerminal) {
						 NonTerminal e_nrw = (NonTerminal)seq;
						 NormalProduction ntprod = (NormalProduction)(production_table.get(e_nrw.getName()));
						 if (ntprod instanceof JavaCodeProduction) {
							 break;
						 }
						 else {
							 seq = ntprod.getExpansion();
						 }
					 }
					 else break;
				 }
				 if (seq instanceof RegularExpression) {
					 e.internal_name = ""jj_scan_token("" + ((RegularExpression)seq).ordinal + "")"";
					 return;
				 }
				 gensymindex++;
				 e.internal_name = ""R_"" + gensymindex;
			 }
			 Phase3Data p3d = (Phase3Data)(phase3table.get(e));
			 if (p3d == null || p3d.count < inf.count) {
				 p3d = new Phase3Data(e, inf.count);
				 phase3list.add(p3d);
				 phase3table.put(e, p3d);
			 }
		 }
		 static void setupPhase3Builds(Phase3Data inf) {
			 Expansion e = inf.exp;
			 if (e instanceof RegularExpression) {
				 ;
			 }
			 else if (e instanceof NonTerminal) {
				 NonTerminal e_nrw = (NonTerminal)e;
				 NormalProduction ntprod = (NormalProduction)(production_table.get(e_nrw.getName()));
				 if (ntprod instanceof JavaCodeProduction) {
					 ;
				 }
				 else {
					 generate3R(ntprod.getExpansion(), inf);
				 }
			 }
			 else if (e instanceof Choice) {
				 Choice e_nrw = (Choice)e;
				 for (int i = 0;
				 i < e_nrw.getChoices().size();
				 i++) {
					 generate3R((Expansion)(e_nrw.getChoices().get(i)), inf);
				 }
			 }
			 else if (e instanceof Sequence) {
				 Sequence e_nrw = (Sequence)e;
				 int cnt = inf.count;
				 for (int i = 1;
				 i < e_nrw.units.size();
				 i++) {
					 Expansion eseq = (Expansion)(e_nrw.units.get(i));
					 setupPhase3Builds(new Phase3Data(eseq, cnt));
					 cnt -= minimumSize(eseq);
					 if (cnt <= 0) break;
				 }
			 }
			 else if (e instanceof TryBlock) {
				 TryBlock e_nrw = (TryBlock)e;
				 setupPhase3Builds(new Phase3Data(e_nrw.exp, inf.count));
			 }
			 else if (e instanceof OneOrMore) {
				 OneOrMore e_nrw = (OneOrMore)e;
				 generate3R(e_nrw.expansion, inf);
			 }
			 else if (e instanceof ZeroOrMore) {
				 ZeroOrMore e_nrw = (ZeroOrMore)e;
				 generate3R(e_nrw.expansion, inf);
			 }
			 else if (e instanceof ZeroOrOne) {
				 ZeroOrOne e_nrw = (ZeroOrOne)e;
				 generate3R(e_nrw.expansion, inf);
			 }
		 }
		 private static String genjj_3Call(Expansion e) {
			 if (e.internal_name.startsWith(""jj_scan_token"")) return e.internal_name;
			 else return ""jj_3"" + e.internal_name + ""()"";
		 }
		 static Hashtable generated = new Hashtable();
		 static void buildPhase3Routine(Phase3Data inf, boolean recursive_call) {
			 Expansion e = inf.exp;
			 Token t = null;
			 if (e.internal_name.startsWith(""jj_scan_token"")) return;
			 if (!recursive_call) {
				 ostr.println("" "" + staticOpt() + ""private boolean jj_3"" + e.internal_name + ""() {
					"");
					 xsp_declared = false;
					 if (Options.getDebugLookahead() && e.parent instanceof NormalProduction) {
						 ostr.print("" "");
						 if (Options.getErrorReporting()) {
							 ostr.print(""if (!jj_rescan) "");
						 }
						 ostr.println(""trace_call(\"""" + ((NormalProduction)e.parent).getLhs() + ""(LOOKING AHEAD...)\"");
						"");
						 jj3_expansion = e;
					 }
					 else {
						 jj3_expansion = null;
					 }
				 }
				 if (e instanceof RegularExpression) {
					 RegularExpression e_nrw = (RegularExpression)e;
					 if (e_nrw.label.equals("""")) {
						 Object label = names_of_tokens.get(new Integer(e_nrw.ordinal));
						 if (label != null) {
							 ostr.println("" if (jj_scan_token("" + (String)label + "")) "" + genReturn(true));
						 }
						 else {
							 ostr.println("" if (jj_scan_token("" + e_nrw.ordinal + "")) "" + genReturn(true));
						 }
					 }
					 else {
						 ostr.println("" if (jj_scan_token("" + e_nrw.label + "")) "" + genReturn(true));
					 }
				 }
				 else if (e instanceof NonTerminal) {
					 NonTerminal e_nrw = (NonTerminal)e;
					 NormalProduction ntprod = (NormalProduction)(production_table.get(e_nrw.getName()));
					 if (ntprod instanceof JavaCodeProduction) {
						 ostr.println("" if (true) {
							 jj_la = 0;
							 jj_scanpos = jj_lastpos;
						 "" + genReturn(false) + ""}
						"");
					 }
					 else {
						 Expansion ntexp = ntprod.getExpansion();
						 ostr.println("" if ("" + genjj_3Call(ntexp)+ "") "" + genReturn(true));
					 }
				 }
				 else if (e instanceof Choice) {
					 Sequence nested_seq;
					 Choice e_nrw = (Choice)e;
					 if (e_nrw.getChoices().size() != 1) {
						 if (!xsp_declared) {
							 xsp_declared = true;
							 ostr.println("" Token xsp;
							"");
						 }
						 ostr.println("" xsp = jj_scanpos;
						"");
					 }
					 for (int i = 0;
					 i < e_nrw.getChoices().size();
					 i++) {
						 nested_seq = (Sequence)(e_nrw.getChoices().get(i));
						 Lookahead la = (Lookahead)(nested_seq.units.get(0));
						 if (la.getActionTokens().size() != 0) {
							 lookaheadNeeded = true;
							 ostr.println("" jj_lookingAhead = true;
							"");
							 ostr.print("" jj_semLA = "");
							 printTokenSetup((Token)(la.getActionTokens().get(0)));
							 for (Iterator it = la.getActionTokens().iterator();
							 it.hasNext();
							) {
								 t = (Token)it.next();
								 printToken(t, ostr);
							 }
							 printTrailingComments(t, ostr);
							 ostr.println("";
							"");
							 ostr.println("" jj_lookingAhead = false;
							"");
						 }
						 ostr.print("" if ("");
						 if (la.getActionTokens().size() != 0) {
							 ostr.print(""!jj_semLA || "");
						 }
						 if (i != e_nrw.getChoices().size() - 1) {
							 ostr.println(genjj_3Call(nested_seq) + "") {
								"");
								 ostr.println("" jj_scanpos = xsp;
								"");
							 }
							 else {
								 ostr.println(genjj_3Call(nested_seq) + "") "" + genReturn(true));
							 }
						 }
						 for (int i = 1;
						 i < e_nrw.getChoices().size();
						 i++) {
						 ostr.println("" }
						"");
					 }
				 }
				 else if (e instanceof Sequence) {
					 Sequence e_nrw = (Sequence)e;
					 int cnt = inf.count;
					 for (int i = 1;
					 i < e_nrw.units.size();
					 i++) {
						 Expansion eseq = (Expansion)(e_nrw.units.get(i));
						 buildPhase3Routine(new Phase3Data(eseq, cnt), true);
						 cnt -= minimumSize(eseq);
						 if (cnt <= 0) break;
					 }
				 }
				 else if (e instanceof TryBlock) {
					 TryBlock e_nrw = (TryBlock)e;
					 buildPhase3Routine(new Phase3Data(e_nrw.exp, inf.count), true);
				 }
				 else if (e instanceof OneOrMore) {
					 if (!xsp_declared) {
						 xsp_declared = true;
						 ostr.println("" Token xsp;
						"");
					 }
					 OneOrMore e_nrw = (OneOrMore)e;
					 Expansion nested_e = e_nrw.expansion;
					 ostr.println("" if ("" + genjj_3Call(nested_e) + "") "" + genReturn(true));
					 ostr.println("" while (true) {
						"");
						 ostr.println("" xsp = jj_scanpos;
						"");
						 ostr.println("" if ("" + genjj_3Call(nested_e) + "") {
							 jj_scanpos = xsp;
							 break;
						 }
						"");
					 ostr.println("" }
					"");
				 }
				 else if (e instanceof ZeroOrMore) {
					 if (!xsp_declared) {
						 xsp_declared = true;
						 ostr.println("" Token xsp;
						"");
					 }
					 ZeroOrMore e_nrw = (ZeroOrMore)e;
					 Expansion nested_e = e_nrw.expansion;
					 ostr.println("" while (true) {
						"");
						 ostr.println("" xsp = jj_scanpos;
						"");
						 ostr.println("" if ("" + genjj_3Call(nested_e) + "") {
							 jj_scanpos = xsp;
							 break;
						 }
						"");
					 ostr.println("" }
					"");
				 }
				 else if (e instanceof ZeroOrOne) {
					 if (!xsp_declared) {
						 xsp_declared = true;
						 ostr.println("" Token xsp;
						"");
					 }
					 ZeroOrOne e_nrw = (ZeroOrOne)e;
					 Expansion nested_e = e_nrw.expansion;
					 ostr.println("" xsp = jj_scanpos;
					"");
					 ostr.println("" if ("" + genjj_3Call(nested_e) + "") jj_scanpos = xsp;
					"");
				 }
				 if (!recursive_call) {
					 ostr.println("" "" + genReturn(false));
				 ostr.println("" }
				"");
				 ostr.println("""");
			 }
		 }
		 static int minimumSize(Expansion e) {
			 return minimumSize(e, Integer.MAX_VALUE);
		 }
		 static int minimumSize(Expansion e, int oldMin) {
			 int retval = 0;
			 if (e.inMinimumSize) {
				 return Integer.MAX_VALUE;
			 }
			 e.inMinimumSize = true;
			 if (e instanceof RegularExpression) {
				 retval = 1;
			 }
			 else if (e instanceof NonTerminal) {
				 NonTerminal e_nrw = (NonTerminal)e;
				 NormalProduction ntprod = (NormalProduction)(production_table.get(e_nrw.getName()));
				 if (ntprod instanceof JavaCodeProduction) {
					 retval = Integer.MAX_VALUE;
				 }
				 else {
					 Expansion ntexp = ntprod.getExpansion();
					 retval = minimumSize(ntexp);
				 }
			 }
			 else if (e instanceof Choice) {
				 int min = oldMin;
				 Expansion nested_e;
				 Choice e_nrw = (Choice)e;
				 for (int i = 0;
				 min > 1 && i < e_nrw.getChoices().size();
				 i++) {
					 nested_e = (Expansion)(e_nrw.getChoices().get(i));
					 int min1 = minimumSize(nested_e, min);
					 if (min > min1) min = min1;
				 }
				 retval = min;
			 }
			 else if (e instanceof Sequence) {
				 int min = 0;
				 Sequence e_nrw = (Sequence)e;
				 for (int i = 1;
				 i < e_nrw.units.size();
				 i++) {
					 Expansion eseq = (Expansion)(e_nrw.units.get(i));
					 int mineseq = minimumSize(eseq);
					 if (min == Integer.MAX_VALUE || mineseq == Integer.MAX_VALUE) {
						 min = Integer.MAX_VALUE;
					 }
					 else {
						 min += mineseq;
						 if (min > oldMin) break;
					 }
				 }
				 retval = min;
			 }
			 else if (e instanceof TryBlock) {
				 TryBlock e_nrw = (TryBlock)e;
				 retval = minimumSize(e_nrw.exp);
			 }
			 else if (e instanceof OneOrMore) {
				 OneOrMore e_nrw = (OneOrMore)e;
				 retval = minimumSize(e_nrw.expansion);
			 }
			 else if (e instanceof ZeroOrMore) {
				 retval = 0;
			 }
			 else if (e instanceof ZeroOrOne) {
				 retval = 0;
			 }
			 else if (e instanceof Lookahead) {
				 retval = 0;
			 }
			 else if (e instanceof Action) {
				 retval = 0;
			 }
			 e.inMinimumSize = false;
			 return retval;
		 }
		 static void build(java.io.PrintWriter ps) {
			 NormalProduction p;
			 JavaCodeProduction jp;
			 Token t = null;
			 ostr = ps;
			 for (java.util.Iterator prodIterator = bnfproductions.iterator();
			 prodIterator.hasNext();
			) {
				 p = (NormalProduction)prodIterator.next();
				 if (p instanceof JavaCodeProduction) {
					 jp = (JavaCodeProduction)p;
					 t = (Token)(jp.getReturnTypeTokens().get(0));
					 printTokenSetup(t);
					 ccol = 1;
					 printLeadingComments(t, ostr);
					 ostr.print("" "" + staticOpt() + (p.getAccessMod() != null ? p.getAccessMod() + "" "" : """"));
					 cline = t.beginLine;
					 ccol = t.beginColumn;
					 printTokenOnly(t, ostr);
					 for (int i = 1;
					 i < jp.getReturnTypeTokens().size();
					 i++) {
						 t = (Token)(jp.getReturnTypeTokens().get(i));
						 printToken(t, ostr);
					 }
					 printTrailingComments(t, ostr);
					 ostr.print("" "" + jp.getLhs() + ""("");
					 if (jp.getParameterListTokens().size() != 0) {
						 printTokenSetup((Token)(jp.getParameterListTokens().get(0)));
						 for (java.util.Iterator it = jp.getParameterListTokens().iterator();
						 it.hasNext();
						) {
							 t = (Token)it.next();
							 printToken(t, ostr);
						 }
						 printTrailingComments(t, ostr);
					 }
					 ostr.print("") throws ParseException"");
					 for (java.util.Iterator it = jp.getThrowsList().iterator();
					 it.hasNext();
					) {
						 ostr.print("", "");
						 java.util.List name = (java.util.List)it.next();
						 for (java.util.Iterator it2 = name.iterator();
						 it2.hasNext();
						) {
							 t = (Token)it2.next();
							 ostr.print(t.image);
						 }
					 }
					 ostr.print("" {
						"");
						 if (Options.getDebugParser()) {
							 ostr.println("""");
							 ostr.println("" trace_call(\"""" + jp.getLhs() + ""\"");
							"");
							 ostr.print("" try {
								"");
							 }
							 if (jp.getCodeTokens().size() != 0) {
								 printTokenSetup((Token)(jp.getCodeTokens().get(0)));
								 cline--;
								 printTokenList(jp.getCodeTokens(), ostr);
							 }
							 ostr.println("""");
							 if (Options.getDebugParser()) {
							 ostr.println("" }
							 finally {
								"");
								 ostr.println("" trace_return(\"""" + jp.getLhs() + ""\"");
								"");
							 ostr.println("" }
							"");
						 }
					 ostr.println("" }
					"");
					 ostr.println("""");
				 }
				 else {
					 buildPhase1Routine((BNFProduction)p);
				 }
			 }
			 for (int phase2index = 0;
			 phase2index < phase2list.size();
			 phase2index++) {
				 buildPhase2Routine((Lookahead)(phase2list.get(phase2index)));
			 }
			 int phase3index = 0;
			 while (phase3index < phase3list.size()) {
				 for (;
				 phase3index < phase3list.size();
				 phase3index++) {
					 setupPhase3Builds((Phase3Data)(phase3list.get(phase3index)));
				 }
			 }
			 for (java.util.Enumeration enumeration = phase3table.elements();
			 enumeration.hasMoreElements();
			) {
				 buildPhase3Routine((Phase3Data)(enumeration.nextElement()), false);
			 }
		 }
		 public static void reInit() {
			 ostr = null;
			 gensymindex = 0;
			 indentamt = 0;
			 jj2LA = false;
			 phase2list = new ArrayList();
			 phase3list = new ArrayList();
			 phase3table = new java.util.Hashtable();
			 firstSet = null;
			 xsp_declared = false;
			 jj3_expansion = null;
		 }
	}
	class Phase3Data {
		 Expansion exp;
		 int count;
		 Phase3Data(Expansion e, int c) {
			 exp = e;
			 count = c;
		 }
	}",1,0,0,0
"public interface PlaybackNearlyFinishedRequestHandler extends RequestHandler {
	 boolean canHandle(HandlerInput input, PlaybackNearlyFinishedRequest playbackNearlyFinishedRequest);
	 Optional<Response> handle(HandlerInput input, PlaybackNearlyFinishedRequest playbackNearlyFinishedRequest);
	 default boolean canHandle(HandlerInput handlerInput) {
		 if (handlerInput.getRequest() instanceof PlaybackNearlyFinishedRequest) {
			 return canHandle(handlerInput, (PlaybackNearlyFinishedRequest)handlerInput.getRequest());
		 }
		 return false;
	 }
	 default Optional<Response> handle(HandlerInput handlerInput) {
		 return handle(handlerInput, (PlaybackNearlyFinishedRequest)handlerInput.getRequest());
	 }
}",0,0,0,0
"public final class ExecutionViewState {
	 private static final String PREF_HEADER_NAME_COLUMN_WIDTH = ""executionsView.headerNameColumnWidth"";
	 private static final String PREF_HEADER_DURATION_COLUMN_WIDTH = ""executionsView.headerDurationColumnWidth"";
	 private int headerNameColumnWidth;
	 private int headerDurationColumnWidth;
	 public void load() {
		 IEclipsePreferences prefs = EclipsePreferencesUtils.getInstanceScope().getNode(UiPlugin.PLUGIN_ID);
		 this.headerNameColumnWidth = prefs.getInt(PREF_HEADER_NAME_COLUMN_WIDTH, 600);
		 this.headerDurationColumnWidth = prefs.getInt(PREF_HEADER_DURATION_COLUMN_WIDTH, 100);
	 }
	 public void save() {
		 IEclipsePreferences prefs = EclipsePreferencesUtils.getInstanceScope().getNode(UiPlugin.PLUGIN_ID);
		 prefs.putInt(PREF_HEADER_NAME_COLUMN_WIDTH, this.headerNameColumnWidth);
		 prefs.putInt(PREF_HEADER_DURATION_COLUMN_WIDTH, this.headerDurationColumnWidth);
		 try {
			 prefs.flush();
		 }
		 catch (BackingStoreException e) {
			 UiPlugin.logger().error(""Unable to store execution view preferences."", e);
		 }
	 }
	 public int getHeaderNameColumnWidth() {
		 return this.headerNameColumnWidth;
	 }
	 public void setHeaderNameColumnWidth(int headerNameColumnWidth) {
		 this.headerNameColumnWidth = headerNameColumnWidth;
	 }
	 public int getHeaderDurationColumnWidth() {
		 return this.headerDurationColumnWidth;
	 }
	 public void setHeaderDurationColumnWidth(int headerDurationColumnWidth) {
		 this.headerDurationColumnWidth = headerDurationColumnWidth;
	 }
	 public void dispose() {
		 save();
	 }
}",0,0,0,0
"public final MarkupContainer getParent(){
	return parent;
}",0,0,0,0
"private final int jjMoveNfa_1(int startState, int curPos){
	 int[] nextStates;
	 int startsAt = 0;
	 jjnewStateCnt = 12;
	 int i = 1;
	 jjstateSet[0] = startState;
	 int j, kind = 0x7fffffff;
	 for (;
	;
	) {
		 if (++jjround == 0x7fffffff) ReInitRounds();
		 if (curChar < 64) {
			 long l = 1L << curChar;
			 MatchLoop: do {
				 switch(jjstateSet[--i]) {
					 case 0: if ((0xbfffff7affffd9ffL & l) != 0L) {
						 if (kind > 9) kind = 9;
						 jjCheckNAdd(11);
					 }
					 else if (curChar == 39) jjCheckNAddTwoStates(9, 10);
					 else if (curChar == 34) jjCheckNAddTwoStates(6, 7);
					 if (curChar == 35) jjCheckNAddStates(0, 2);
					 break;
					 case 1: if ((0xffffffffffffdbffL & l) != 0L) jjCheckNAddStates(0, 2);
					 break;
					 case 2: if ((0x2400L & l) != 0L && kind > 5) kind = 5;
					 break;
					 case 3: if (curChar == 10 && kind > 5) kind = 5;
					 break;
					 case 4: if (curChar == 13) jjstateSet[jjnewStateCnt++] = 3;
					 break;
					 case 5: if (curChar == 34) jjCheckNAddTwoStates(6, 7);
					 break;
					 case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddTwoStates(6, 7);
					 break;
					 case 7: if (curChar == 34 && kind > 8) kind = 8;
					 break;
					 case 8: if (curChar == 39) jjCheckNAddTwoStates(9, 10);
					 break;
					 case 9: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddTwoStates(9, 10);
					 break;
					 case 10: if (curChar == 39 && kind > 8) kind = 8;
					 break;
					 case 11: if ((0xbfffff7affffd9ffL & l) == 0L) break;
					 if (kind > 9) kind = 9;
					 jjCheckNAdd(11);
					 break;
					 default : break;
				 }
			 }
			 while(i != startsAt);
		 }
		 else if (curChar < 128) {
			 long l = 1L << (curChar & 077);
			 MatchLoop: do {
				 switch(jjstateSet[--i]) {
					 case 0: case 11: if (kind > 9) kind = 9;
					 jjCheckNAdd(11);
					 break;
					 case 1: jjAddStates(0, 2);
					 break;
					 case 6: jjAddStates(3, 4);
					 break;
					 case 9: jjAddStates(5, 6);
					 break;
					 default : break;
				 }
			 }
			 while(i != startsAt);
		 }
		 else {
			 int i2 = (curChar & 0xff) >> 6;
			 long l2 = 1L << (curChar & 077);
			 MatchLoop: do {
				 switch(jjstateSet[--i]) {
					 case 0: case 11: if ((jjbitVec0[i2] & l2) == 0L) break;
					 if (kind > 9) kind = 9;
					 jjCheckNAdd(11);
					 break;
					 case 1: if ((jjbitVec0[i2] & l2) != 0L) jjAddStates(0, 2);
					 break;
					 case 6: if ((jjbitVec0[i2] & l2) != 0L) jjAddStates(3, 4);
					 break;
					 case 9: if ((jjbitVec0[i2] & l2) != 0L) jjAddStates(5, 6);
					 break;
					 default : break;
				 }
			 }
			 while(i != startsAt);
		 }
		 if (kind != 0x7fffffff) {
			 jjmatchedKind = kind;
			 jjmatchedPos = curPos;
			 kind = 0x7fffffff;
		 }
		 ++curPos;
		 if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt))) return curPos;
		 try {
			 curChar = input_stream.readChar();
		 }
		 catch(java.io.IOException e) {
			 return curPos;
		 }
	 }
}",0,0,1,0
"static boolean evaluateImpl(Object o1, Object o2) {
	if (o1 == null && o2 == null) {
		return true;
	}
	 else if (o1 != null) {
		if (o2 instanceof Collection) {
			for (Object element : ((Collection<T>) o2)) {
				if (element != null && Evaluator.evaluator(element).eq(element, o1)) {
					return true;
				}
			}
			return false;
		}
		return Evaluator.evaluator(o1).eq(o1, o2);
	}
	return false;
}",0,0,1,0
"public static final class VertexGroupItem<K, VGV> extends Tuple4<K, K, Either<VGV, NullValue>, Long> {
	private final Either.Right<VGV, NullValue> nullValue = new Either.Right<>(NullValue.getInstance());
	public VertexGroupItem() {
		reset();
	}
	public K getVertexId() {
		return f0;
	}
	public void setVertexId(K vertexId) {
		f0 = vertexId;
	}
	public K getGroupRepresentativeId() {
		return f1;
	}
	public void setGroupRepresentativeId(K groupRepresentativeId) {
		f1 = groupRepresentativeId;
	}
	public VGV getVertexGroupValue() {
		return f2.isLeft() ? f2.left() : null;
	}
	public void setVertexGroupValue(VGV vertexGroupValue) {
		if (vertexGroupValue == null) {
			f2 = nullValue;
		}
		 else {
			f2 = new Either.Left<>(vertexGroupValue);
		}
	}
	public Long getVertexGroupCount() {
		return f3;
	}
	public void setVertexGroupCount(Long vertexGroupCount) {
		f3 = vertexGroupCount;
	}
	public void reset() {
		f0 = null;
		f1 = null;
		f2 = nullValue;
		f3 = 0L;
	}
}",0,1,0,0
"public interface IRowCacheEntry{
}",0,0,0,0
"public class Customer1149 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer1149() {
	}
	public Customer1149(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer1149[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"public class SugiyamaLayoutAlgorithm extends JGraphLayoutAlgorithm {
	public static final String SUGIYAMA_VISITED = ""SugiyamaVisited"" ;
	public static final String SUGIYAMA_CELL_WRAPPER =""SugiyamaCellWrapper"" ;
	public static final String SUGIYAMA_SELECTED = ""SugiyamaSelected"" ;
	protected int gridAreaSize = Integer.MIN_VALUE;
	List movements = null;
	int movementsCurrentLoop = -1;
	int movementsMax = Integer.MIN_VALUE;
	int iteration = 0;
	protected boolean vertical = true;
	protected Point spacing = new Point(250, 150);
	 protected boolean flushToOrigin = false;
	public JGraphLayoutSettings createSettings() {
		return new SugiyamaLayoutSettings(this);
	}
	public String toString() {
		return ""Sugiyama"";
	}
	public String getHint() {
		return ""Ignores selection"";
	}
	 public void run(JGraph graph, Object[] dynamic_cells, Object[] static_cells) {
		CellView[] selectedCellViews =graph.getGraphLayoutCache().getMapping(dynamic_cells);
		 gridAreaSize = Integer.MIN_VALUE;
		Rectangle2D maxBounds = new Rectangle2D.Double();
		for (int i = 0;
		 i < selectedCellViews.length;
		 i++) {
			if (selectedCellViews[i] instanceof VertexView) {
				Rectangle2D bounds = selectedCellViews[i].getBounds();
				if (bounds != null)maxBounds.setFrame(0, 0,Math.max(bounds.getWidth(), maxBounds.getWidth()),Math.max(bounds.getHeight(), maxBounds.getHeight()));
			}
		}
		if (spacing.x == 0)spacing.x = (int) (2*maxBounds.getWidth());
		if (spacing.y == 0)spacing.y = (int) (2*maxBounds.getHeight());
		 markSelected(selectedCellViews, true);
		List roots = searchRoots(graph, selectedCellViews);
		if (roots.size() == 0)return;
		List levels = fillLevels(graph, selectedCellViews, roots);
		solveEdgeCrosses(graph, levels);
		moveToBarycenter(graph, selectedCellViews, levels);
		Point min = flushToOrigin ? new Point(0, 0) : findMinimumAndSpacing(selectedCellViews, spacing);
		drawGraph(graph, levels, min, spacing);
		 markSelected(selectedCellViews, false);
	}
	 protected void markSelected(CellView[] selectedCellViews, boolean addMark) {
		 if (addMark) {
			 for (int i = 0;
			 i < selectedCellViews.length;
			 i++) {
				 if (selectedCellViews[i] != null) {
					 selectedCellViews[i].getAttributes().put(SUGIYAMA_SELECTED, Boolean.TRUE);
				 }
			 }
		 }
		 else {
			 for (int i = 0;
			 i < selectedCellViews.length;
			 i++) {
				 if (selectedCellViews[i] != null) {
					 selectedCellViews[i].getAttributes().remove(SUGIYAMA_SELECTED);
				 }
			 }
		 }
	 }
	 protected boolean isSelected(final GraphLayoutCache cache, final Object cell) {
		 final CellView view = cache.getMapping(cell, false);
		 return view != null && view.getAttributes().get(SUGIYAMA_SELECTED) != null;
	 }
	protected List searchRoots(JGraph jgraph, CellView[] selectedCellViews) {
		List vertexViews = new ArrayList(selectedCellViews.length);
		List roots = new ArrayList();
		for (int i = 0;
		 i < selectedCellViews.length;
		 i++) {
			if (selectedCellViews[i] instanceof VertexView) {
				VertexView vertexView = (VertexView) selectedCellViews[i];
				vertexView.getAttributes().remove(SUGIYAMA_VISITED);
				vertexViews.add(selectedCellViews[i]);
			}
		}
		for (int i = 0;
		 i < vertexViews.size();
		 i++) {
			VertexView vertexView = (VertexView) vertexViews.get(i);
			if (vertexView.getAttributes().get(SUGIYAMA_VISITED) == null) {
				searchRoots(jgraph, vertexView, roots);
			}
		}
		if (roots.size() == 0) {
			throw new IllegalArgumentException(""The Graph is not a DAG. Can't use Sugiyama Algorithm!"");
		}
		return roots;
	}
	protected void searchRoots(JGraph jgraph,VertexView vertexViewToInspect,List roots) {
		if (vertexViewToInspect.getAttributes().get(SUGIYAMA_VISITED)!= null) {
			return;
		}
		vertexViewToInspect.getAttributes().put(SUGIYAMA_VISITED, Boolean.TRUE);
		GraphModel model = jgraph.getModel();
		 GraphLayoutCache cache = jgraph.getGraphLayoutCache();
		Object vertex = vertexViewToInspect.getCell();
		int portCount = model.getChildCount(vertex);
		for (int j = 0;
		 j < portCount;
		 j++) {
			Object port = model.getChild(vertex, j);
			boolean isRoot = true;
			Iterator itrEdges = model.edges(port);
			while (itrEdges.hasNext()) {
				Object edge = itrEdges.next();
				 if (!isSelected(cache, edge)) {
					 continue;
				 }
				if (model.getTarget(edge) == port) {
					Object sourcePort = model.getSource(edge);
					Object sourceVertex = model.getParent(sourcePort);
					CellView sourceVertexView =jgraph.getGraphLayoutCache().getMapping(sourceVertex,false);
					if (sourceVertexView instanceof VertexView) {
						searchRoots(jgraph,(VertexView) sourceVertexView,roots);
						isRoot = false;
					}
				}
			}
			if (isRoot) {
				roots.add(vertexViewToInspect);
			}
		}
	}
	protected List fillLevels(JGraph jgraph,CellView[] selectedCellViews,List rootVertexViews) {
		List levels = new Vector();
		for (int i = 0;
		 i < selectedCellViews.length;
		 i++) {
			CellView cellView = selectedCellViews[i];
			if (cellView == null)continue;
			cellView.getAttributes().remove(SUGIYAMA_VISITED);
		}
		Iterator rootIter = rootVertexViews.iterator();
		while (rootIter.hasNext()) {
			VertexView vertexView = (VertexView) rootIter.next();
			fillLevels(jgraph, levels, 0, vertexView);
		}
		return levels;
	}
	protected void fillLevels(JGraph jgraph,List levels,int level,VertexView vertexView) {
		if (vertexView == null)return;
		if (levels.size() == level)levels.add(level, new ArrayList());
		if (vertexView.getAttributes().get(SUGIYAMA_VISITED) != null) {
			return;
		}
		CellWrapper w = (CellWrapper) vertexView.getAttributes().get(SUGIYAMA_CELL_WRAPPER);
		if (w != null) {
			if (w.getLevel() < level){
				List listForTheHigherLevel = (ArrayList) levels.get(w.getLevel());
				listForTheHigherLevel.remove(w);
				vertexView.getAttributes().remove(SUGIYAMA_CELL_WRAPPER);
			}
			else{
				return;
			}
		}
		vertexView.getAttributes().put(SUGIYAMA_VISITED, Boolean.TRUE);
		List listForTheCurrentLevel = (ArrayList) levels.get(level);
		int numberForTheEntry = listForTheCurrentLevel.size();
		CellWrapper wrapper =new CellWrapper(level, numberForTheEntry, vertexView);
		listForTheCurrentLevel.add(wrapper);
		vertexView.getAttributes().put(SUGIYAMA_CELL_WRAPPER, wrapper);
		Object vertex = vertexView.getCell();
		GraphModel model = jgraph.getModel();
		GraphLayoutCache cache = jgraph.getGraphLayoutCache();
		int portCount = model.getChildCount(vertex);
		for (int i = 0;
		 i < portCount;
		 i++) {
			Object port = model.getChild(vertex, i);
			Iterator itrEdges = model.edges(port);
			while (itrEdges.hasNext()) {
				Object edge = itrEdges.next();
				 if (!isSelected(cache, edge)) {
					 continue;
				 }
				if (port == model.getSource(edge)) {
					Object targetPort = model.getTarget(edge);
					Object targetVertex = model.getParent(targetPort);
					 if (!isSelected(cache, targetVertex)) {
						 continue;
					 }
					 VertexView targetVertexView =(VertexView) jgraph.getGraphLayoutCache().getMapping(targetVertex,false);
					fillLevels(jgraph, levels, (level + 1), targetVertexView);
				}
			}
		}
		if (listForTheCurrentLevel.size() > gridAreaSize) {
			gridAreaSize = listForTheCurrentLevel.size();
		}
		vertexView.getAttributes().remove(SUGIYAMA_VISITED);
	}
	protected Point findMinimumAndSpacing(CellView[] graphCellViews,Point spacing) {
		try {
			int min_x = 1000000;
			int min_y = 1000000;
			for (int i = 0;
			 i < graphCellViews.length;
			 i++) {
				CellView cellView = graphCellViews[i];
				if (cellView == null)continue;
				Rectangle2D rect = cellView.getBounds();
				Rectangle cellViewBounds = new Rectangle((int) rect.getX(), (int) rect.getY(), (int) rect.getWidth(), (int) rect.getHeight());
				try {
					if (cellViewBounds.x < min_x)min_x = cellViewBounds.x;
					if (cellViewBounds.y < min_y)min_y = cellViewBounds.y;
				}
				 catch (Exception e) {
					System.err.println(""---------> ERROR in calculateValues."");
					e.printStackTrace();
				}
			}
			return new Point(min_x, min_y);
		}
		 catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}
	protected void updateProgress4Movements() {
		movements.add(new Integer(movementsCurrentLoop));
		iteration++;
		if (movementsCurrentLoop > movementsMax) {
			movementsMax = movementsCurrentLoop;
		}
	}
	protected void solveEdgeCrosses(JGraph jgraph, List levels) {
		movements = new ArrayList(100);
		movementsCurrentLoop = -1;
		movementsMax = Integer.MIN_VALUE;
		iteration = 0;
		while (movementsCurrentLoop != 0) {
			movementsCurrentLoop = 0;
			for (int i = 0;
			 i < levels.size() - 1;
			 i++) {
				movementsCurrentLoop+= solveEdgeCrosses(jgraph, true, levels, i);
			}
			for (int i = levels.size() - 1;
			 i >= 1;
			 i--) {
				movementsCurrentLoop+= solveEdgeCrosses(jgraph, false, levels, i);
			}
			updateProgress4Movements();
		}
	}
	protected int solveEdgeCrosses(JGraph jgraph,boolean down,List levels,int levelIndex) {
		List currentLevel = (List) levels.get(levelIndex);
		int movements = 0;
		Object[] levelSortBefore = currentLevel.toArray();
		Collections.sort(currentLevel);
		for (int j = 0;
		 j < levelSortBefore.length;
		 j++) {
			if (((CellWrapper) levelSortBefore[j]).getEdgeCrossesIndicator()!= ((CellWrapper) currentLevel.get(j)).getEdgeCrossesIndicator()) {
				movements++;
			}
		}
		GraphModel model = jgraph.getModel();
		GraphLayoutCache cache = jgraph.getGraphLayoutCache();
		for (int j = currentLevel.size() - 1;
		 j >= 0;
		 j--) {
			CellWrapper sourceWrapper = (CellWrapper) currentLevel.get(j);
			VertexView sourceView = sourceWrapper.getVertexView();
			Object sourceVertex = sourceView.getCell();
			int sourcePortCount = model.getChildCount(sourceVertex);
			for (int k = 0;
			 k < sourcePortCount;
			 k++) {
				Object sourcePort = model.getChild(sourceVertex, k);
				Iterator sourceEdges = model.edges(sourcePort);
				while (sourceEdges.hasNext()) {
					Object edge = sourceEdges.next();
					 if (!isSelected(cache, edge)) {
						 continue;
					 }
					Object targetPort = null;
					if (down && sourcePort == model.getSource(edge)) {
						targetPort = model.getTarget(edge);
					}
					if (!down && sourcePort == model.getTarget(edge)) {
						targetPort = model.getSource(edge);
					}
					if (targetPort == null)continue;
					Object targetCell = model.getParent(targetPort);
					 if (!isSelected(cache, targetCell)) continue;
					VertexView targetVertexView =(VertexView) jgraph.getGraphLayoutCache().getMapping(targetCell,false);
					if (targetVertexView == null)continue;
					CellWrapper targetWrapper =(CellWrapper) targetVertexView.getAttributes().get(SUGIYAMA_CELL_WRAPPER);
					if (down&& targetWrapper != null&& targetWrapper.getLevel() > levelIndex) {
						targetWrapper.addToEdgeCrossesIndicator(sourceWrapper.getEdgeCrossesIndicator());
					}
					if (!down&& targetWrapper != null&& targetWrapper.getLevel() < levelIndex) {
						targetWrapper.addToEdgeCrossesIndicator(sourceWrapper.getEdgeCrossesIndicator());
					}
				}
			}
		}
		return movements;
	}
	protected void moveToBarycenter(JGraph jgraph,CellView[] allSelectedViews,List levels) {
		GraphModel model = jgraph.getModel();
		GraphLayoutCache cache = jgraph.getGraphLayoutCache();
		for (int i = 0;
		 i < allSelectedViews.length;
		 i++) {
			if (!(allSelectedViews[i] instanceof VertexView))continue;
			VertexView vertexView = (VertexView) allSelectedViews[i];
			CellWrapper currentwrapper =(CellWrapper) vertexView.getAttributes().get(SUGIYAMA_CELL_WRAPPER);
			Object vertex = vertexView.getCell();
			int portCount = model.getChildCount(vertex);
			for (int k = 0;
			 k < portCount;
			 k++) {
				Object port = model.getChild(vertex, k);
				Iterator edges = model.edges(port);
				while (edges.hasNext()) {
					Object edge = edges.next();
					 if (!isSelected(cache, edge)) continue;
					Object neighborPort = null;
					if (port == model.getSource(edge)) {
						neighborPort = model.getTarget(edge);
					}
					 else {
						if (port == model.getTarget(edge)) {
							neighborPort = model.getSource(edge);
						}
						 else {
							continue;
						}
					}
					Object neighborVertex = model.getParent(neighborPort);
					 if (!isSelected(cache, neighborVertex)) continue;
					VertexView neighborVertexView =(VertexView) jgraph.getGraphLayoutCache().getMapping(neighborVertex,false);
					if (neighborVertexView == null|| neighborVertexView == vertexView)continue;
					CellWrapper neighborWrapper =(CellWrapper) neighborVertexView.getAttributes().get(SUGIYAMA_CELL_WRAPPER);
					if (currentwrapper == null|| neighborWrapper == null|| currentwrapper.level == neighborWrapper.level)continue;
					currentwrapper.priority++;
				}
			}
		}
		for (Iterator levelsIter = levels.iterator();
		 levelsIter.hasNext();
		 ) {
			List level = (List) levelsIter.next();
			 int i = 0;
			for (Iterator levelIter = level.iterator();
			 levelIter.hasNext();
			 i++) {
				CellWrapper wrapper = (CellWrapper) levelIter.next();
				wrapper.setGridPosition(i);
			}
		}
		movements.clear();
		movementsCurrentLoop = -1;
		movementsMax = Integer.MIN_VALUE;
		iteration = 0;
		while (movementsCurrentLoop != 0) {
			movementsCurrentLoop = 0;
			for (int i = 1;
			 i < levels.size();
			 i++) {
				movementsCurrentLoop += moveToBarycenter(jgraph, levels, i);
			}
			for (int i = levels.size() - 1;
			 i >= 0;
			 i--) {
				movementsCurrentLoop += moveToBarycenter(jgraph, levels, i);
			}
			this.updateProgress4Movements();
		}
	}
	protected int moveToBarycenter(JGraph jgraph,List levels,int levelIndex) {
		int movements = 0;
		List currentLevel = (List) levels.get(levelIndex);
		GraphModel model = jgraph.getModel();
		GraphLayoutCache cache = jgraph.getGraphLayoutCache();
		for (int currentIndexInTheLevel = 0;
		currentIndexInTheLevel < currentLevel.size();
		currentIndexInTheLevel++) {
			CellWrapper sourceWrapper =(CellWrapper) currentLevel.get(currentIndexInTheLevel);
			float gridPositionsSum = 0;
			float countNodes = 0;
			VertexView vertexView = sourceWrapper.getVertexView();
			Object vertex = vertexView.getCell();
			int portCount = model.getChildCount(vertex);
			for (int i = 0;
			 i < portCount;
			 i++) {
				Object port = model.getChild(vertex, i);
				Iterator edges = model.edges(port);
				while (edges.hasNext()) {
					Object edge = edges.next();
					 if (!isSelected(cache, edge)) continue;
					Object neighborPort = null;
					if (port == model.getSource(edge)) {
						neighborPort = model.getTarget(edge);
					}
					 else {
						if (port == model.getTarget(edge)) {
							neighborPort = model.getSource(edge);
						}
						 else {
							continue;
						}
					}
					Object neighborVertex = model.getParent(neighborPort);
					 if (!isSelected(cache, neighborVertex)) continue;
					VertexView neighborVertexView =(VertexView) jgraph.getGraphLayoutCache().getMapping(neighborVertex,false);
					if (neighborVertexView == null)continue;
					CellWrapper targetWrapper =(CellWrapper) neighborVertexView.getAttributes().get(SUGIYAMA_CELL_WRAPPER);
					if (targetWrapper == sourceWrapper)continue;
					if (targetWrapper == null|| targetWrapper.getLevel() == levelIndex)continue;
					gridPositionsSum += targetWrapper.getGridPosition();
					countNodes++;
				}
			}
			if (countNodes > 0) {
				float tmp = (gridPositionsSum / countNodes);
				int newGridPosition = Math.round(tmp);
				boolean toRight =(newGridPosition > sourceWrapper.getGridPosition());
				boolean moved = true;
				while (newGridPosition != sourceWrapper.getGridPosition()&& moved) {
					moved =move(toRight,currentLevel,currentIndexInTheLevel,sourceWrapper.getPriority());
					if (moved)movements++;
				}
			}
		}
		return movements;
	}
	protected boolean move(boolean toRight,List currentLevel,int currentIndexInTheLevel,int currentPriority) {
		CellWrapper currentWrapper =(CellWrapper) currentLevel.get(currentIndexInTheLevel);
		boolean moved = false;
		int neighborIndexInTheLevel =currentIndexInTheLevel + (toRight ? 1 : -1);
		int newGridPosition =currentWrapper.getGridPosition() + (toRight ? 1 : -1);
		if (0 > newGridPosition || newGridPosition >= gridAreaSize) {
			return false;
		}
		if (toRight&& currentIndexInTheLevel == currentLevel.size() - 1|| !toRight&& currentIndexInTheLevel == 0) {
			moved = true;
		}
		 else {
			CellWrapper neighborWrapper =(CellWrapper) currentLevel.get(neighborIndexInTheLevel);
			int neighborPriority = neighborWrapper.getPriority();
			if (neighborWrapper.getGridPosition() == newGridPosition) {
				if (neighborPriority >= currentPriority) {
					return false;
				}
				 else {
					moved =move(toRight,currentLevel,neighborIndexInTheLevel,currentPriority);
				}
			}
			 else {
				moved = true;
			}
		}
		if (moved) {
			currentWrapper.setGridPosition(newGridPosition);
		}
		return moved;
	}
	protected void drawGraph(JGraph jgraph,List levels,Point min,Point spacing) {
		Map viewMap = new Hashtable();
		for (int rowCellCount = 0;
		rowCellCount < levels.size();
		rowCellCount++) {
			List level = (List) levels.get(rowCellCount);
			for (int colCellCount = 0;
			colCellCount < level.size();
			colCellCount++) {
				CellWrapper wrapper = (CellWrapper) level.get(colCellCount);
				VertexView view = wrapper.vertexView;
				view.getAttributes().remove(SUGIYAMA_CELL_WRAPPER);
				view.getAttributes().remove(SUGIYAMA_VISITED);
				wrapper.vertexView = null;
				if (view == null)continue;
				Rectangle2D rect = (Rectangle2D) view.getBounds().clone();
				Rectangle bounds = new Rectangle((int) rect.getX(), (int) rect.getY(), (int) rect.getWidth(), (int) rect.getHeight());
				bounds.x = min.x + spacing.x * ((vertical) ? wrapper.getGridPosition() : rowCellCount);
				bounds.y = min.y + spacing.y * ((vertical) ? rowCellCount : wrapper.getGridPosition());
				Object cell = view.getCell();
				Map map = new Hashtable();
				GraphConstants.setBounds(map, (Rectangle2D) bounds.clone());
				viewMap.put(cell, map);
			}
		}
		jgraph.getGraphLayoutCache().edit(viewMap, null, null, null);
	}
	class CellWrapper implements Comparable {
		private double edgeCrossesIndicator = 0;
		private int additions = 0;
		int level = 0;
		int gridPosition = 0;
		int priority = 0;
		VertexView vertexView = null;
		CellWrapper(int level,double edgeCrossesIndicator,VertexView vertexView) {
			this.level = level;
			this.edgeCrossesIndicator = edgeCrossesIndicator;
			this.vertexView = vertexView;
			additions++;
		}
		VertexView getVertexView() {
			return vertexView;
		}
		void resetEdgeCrossesIndicator() {
			edgeCrossesIndicator = 0;
			additions = 0;
		}
		double getEdgeCrossesIndicator() {
			if (additions == 0)return 0;
			return edgeCrossesIndicator / additions;
		}
		void addToEdgeCrossesIndicator(double addValue) {
			edgeCrossesIndicator += addValue;
			additions++;
		}
		int getLevel() {
			return level;
		}
		int getGridPosition() {
			return gridPosition;
		}
		void setGridPosition(int pos) {
			this.gridPosition = pos;
		}
		void incrementPriority() {
			priority++;
		}
		int getPriority() {
			return priority;
		}
		public int compareTo(Object compare) {
			if (((CellWrapper) compare).getEdgeCrossesIndicator()== this.getEdgeCrossesIndicator())return 0;
			double compareValue =(((CellWrapper) compare).getEdgeCrossesIndicator()- this.getEdgeCrossesIndicator());
			return (int) (compareValue * 1000);
		}
	}
	public Point getSpacing() {
		return spacing;
	}
	public void setSpacing(Point spacing) {
		this.spacing = spacing;
	}
	public boolean isVertical() {
		return vertical;
	}
	public void setVertical(boolean vertical) {
		this.vertical = vertical;
	}
	 public final boolean getFlushToOrigin() {
		 return flushToOrigin;
	 }
	 public final void setFlushToOrigin(final boolean newFlushToOrigin) {
		 this.flushToOrigin = newFlushToOrigin;
	 }
}",1,0,0,0
"public class Job extends ControlledJob {
	 static final Log LOG = LogFactory.getLog(Job.class);
	 final public static int SUCCESS = 0;
	 final public static int WAITING = 1;
	 final public static int RUNNING = 2;
	 final public static int READY = 3;
	 final public static int FAILED = 4;
	 final public static int DEPENDENT_FAILED = 5;
	 public Job(JobConf jobConf, ArrayList<?> dependingJobs) throws IOException {
		 super(new org.apache.hadoop.mapreduce.Job(jobConf), (List<ControlledJob>) dependingJobs);
	 }
	 public Job(JobConf conf) throws IOException {
		 super(conf);
	 }
	 public JobID getAssignedJobID() {
		 org.apache.hadoop.mapreduce.JobID temp = super.getMapredJobID();
		 if(temp == null) {
			 return null;
		 }
		 return JobID.downgrade(temp);
	 }
	 public void setAssignedJobID(JobID mapredJobID) {
	 }
	 public synchronized JobConf getJobConf() {
		 return new JobConf(super.getJob().getConfiguration());
	 }
	 public synchronized void setJobConf(JobConf jobConf) {
		 try {
			 super.setJob(new org.apache.hadoop.mapreduce.Job(jobConf));
		 }
		 catch (IOException ioe) {
			 LOG.info(""Exception"" + ioe);
		 }
	 }
	 public synchronized int getState() {
		 State state = super.getJobState();
		 if (state == State.SUCCESS) {
			 return SUCCESS;
		 }
		 if (state == State.WAITING) {
			 return WAITING;
		 }
		 if (state == State.RUNNING) {
			 return RUNNING;
		 }
		 if (state == State.READY) {
			 return READY;
		 }
		 if (state == State.FAILED ) {
			 return FAILED;
		 }
		 if (state == State.DEPENDENT_FAILED ) {
			 return DEPENDENT_FAILED;
		 }
		 return -1;
	 }
	 public JobClient getJobClient() {
		 try {
			 return new JobClient(super.getJob().getConfiguration());
		 }
		 catch (IOException ioe) {
			 return null;
		 }
	 }
	 public ArrayList<Job> getDependingJobs() {
		 return JobControl.castToJobList(super.getDependentJobs());
	 }
}",0,0,0,0
"private Entry extractCategory( Session session, Accounts accounts, Account account, Entry entry, String line) throws CanceledException;",0,0,0,1
"class FunctionCall extends Expression {
	 private QName _fname;
	 private final Vector _arguments;
	 private final static Vector EMPTY_ARG_LIST = new Vector(0);
	 protected final static String EXT_XSLTC = TRANSLET_URI;
	 protected final static String JAVA_EXT_XSLTC = EXT_XSLTC + ""/java"";
	 protected final static String EXT_XALAN =""http: protected final static String JAVA_EXT_XALAN =""http: protected final static String JAVA_EXT_XALAN_OLD =""http: protected final static String EXSLT_COMMON =""http: protected final static String EXSLT_MATH =""http: protected final static String EXSLT_SETS =""http: protected final static String EXSLT_DATETIME =""http: protected final static String EXSLT_STRINGS =""http: protected final static int NAMESPACE_FORMAT_JAVA = 0;
	 protected final static int NAMESPACE_FORMAT_CLASS = 1;
	 protected final static int NAMESPACE_FORMAT_PACKAGE = 2;
	 protected final static int NAMESPACE_FORMAT_CLASS_OR_PACKAGE = 3;
	 private int _namespace_format = NAMESPACE_FORMAT_JAVA;
	 Expression _thisArgument = null;
	 private String _className;
	 private Class _clazz;
	 private Method _chosenMethod;
	 private Constructor _chosenConstructor;
	 private MethodType _chosenMethodType;
	 private boolean unresolvedExternal;
	 private boolean _isExtConstructor = false;
	 private boolean _isStatic = false;
	 private static final MultiHashtable _internal2Java = new MultiHashtable();
	 private static final Hashtable _java2Internal = new Hashtable();
	 private static final Hashtable _extensionNamespaceTable = new Hashtable();
	 private static final Hashtable _extensionFunctionTable = new Hashtable();
	 static class JavaType {
		public Class type;
		public int distance;
		public JavaType(Class type, int distance){
			 this.type = type;
			 this.distance = distance;
		}
		public boolean equals(Object query){
			 return query.equals(type);
		}
	 }
	 static {
		try {
			 final Class nodeClass = Class.forName(""org.w3c.dom.Node"");
			 final Class nodeListClass = Class.forName(""org.w3c.dom.NodeList"");
			 _internal2Java.put(Type.Boolean, new JavaType(Boolean.TYPE, 0));
			 _internal2Java.put(Type.Boolean, new JavaType(Boolean.class, 1));
			 _internal2Java.put(Type.Boolean, new JavaType(Object.class, 2));
			 _internal2Java.put(Type.Real, new JavaType(Double.TYPE, 0));
			 _internal2Java.put(Type.Real, new JavaType(Double.class, 1));
			 _internal2Java.put(Type.Real, new JavaType(Float.TYPE, 2));
			 _internal2Java.put(Type.Real, new JavaType(Long.TYPE, 3));
			 _internal2Java.put(Type.Real, new JavaType(Integer.TYPE, 4));
			 _internal2Java.put(Type.Real, new JavaType(Short.TYPE, 5));
			 _internal2Java.put(Type.Real, new JavaType(Byte.TYPE, 6));
			 _internal2Java.put(Type.Real, new JavaType(Character.TYPE, 7));
			 _internal2Java.put(Type.Real, new JavaType(Object.class, 8));
			 _internal2Java.put(Type.Int, new JavaType(Double.TYPE, 0));
			 _internal2Java.put(Type.Int, new JavaType(Double.class, 1));
			 _internal2Java.put(Type.Int, new JavaType(Float.TYPE, 2));
			 _internal2Java.put(Type.Int, new JavaType(Long.TYPE, 3));
			 _internal2Java.put(Type.Int, new JavaType(Integer.TYPE, 4));
			 _internal2Java.put(Type.Int, new JavaType(Short.TYPE, 5));
			 _internal2Java.put(Type.Int, new JavaType(Byte.TYPE, 6));
			 _internal2Java.put(Type.Int, new JavaType(Character.TYPE, 7));
			 _internal2Java.put(Type.Int, new JavaType(Object.class, 8));
			 _internal2Java.put(Type.String, new JavaType(String.class, 0));
			 _internal2Java.put(Type.String, new JavaType(Object.class, 1));
			 _internal2Java.put(Type.NodeSet, new JavaType(nodeListClass, 0));
			 _internal2Java.put(Type.NodeSet, new JavaType(nodeClass, 1));
			 _internal2Java.put(Type.NodeSet, new JavaType(Object.class, 2));
			 _internal2Java.put(Type.NodeSet, new JavaType(String.class, 3));
			 _internal2Java.put(Type.Node, new JavaType(nodeListClass, 0));
			 _internal2Java.put(Type.Node, new JavaType(nodeClass, 1));
			 _internal2Java.put(Type.Node, new JavaType(Object.class, 2));
			 _internal2Java.put(Type.Node, new JavaType(String.class, 3));
			 _internal2Java.put(Type.ResultTree, new JavaType(nodeListClass, 0));
			 _internal2Java.put(Type.ResultTree, new JavaType(nodeClass, 1));
			 _internal2Java.put(Type.ResultTree, new JavaType(Object.class, 2));
			 _internal2Java.put(Type.ResultTree, new JavaType(String.class, 3));
			 _internal2Java.put(Type.Reference, new JavaType(Object.class, 0));
			 _java2Internal.put(Boolean.TYPE, Type.Boolean);
			 _java2Internal.put(Void.TYPE, Type.Void);
			 _java2Internal.put(Character.TYPE, Type.Real);
			 _java2Internal.put(Byte.TYPE, Type.Real);
			 _java2Internal.put(Short.TYPE, Type.Real);
			 _java2Internal.put(Integer.TYPE, Type.Real);
			 _java2Internal.put(Long.TYPE, Type.Real);
			 _java2Internal.put(Float.TYPE, Type.Real);
			 _java2Internal.put(Double.TYPE, Type.Real);
			 _java2Internal.put(String.class, Type.String);
			 _java2Internal.put(Object.class, Type.Reference);
			 _java2Internal.put(nodeListClass, Type.NodeSet);
			 _java2Internal.put(nodeClass, Type.NodeSet);
			 _extensionNamespaceTable.put(EXT_XALAN, ""org.apache.xalan.lib.Extensions"");
			 _extensionNamespaceTable.put(EXSLT_COMMON, ""org.apache.xalan.lib.ExsltCommon"");
			 _extensionNamespaceTable.put(EXSLT_MATH, ""org.apache.xalan.lib.ExsltMath"");
			 _extensionNamespaceTable.put(EXSLT_SETS, ""org.apache.xalan.lib.ExsltSets"");
			 _extensionNamespaceTable.put(EXSLT_DATETIME, ""org.apache.xalan.lib.ExsltDatetime"");
			 _extensionNamespaceTable.put(EXSLT_STRINGS, ""org.apache.xalan.lib.ExsltStrings"");
			 _extensionFunctionTable.put(EXSLT_COMMON + "":nodeSet"", ""nodeset"");
			 _extensionFunctionTable.put(EXSLT_COMMON + "":objectType"", ""objectType"");
			 _extensionFunctionTable.put(EXT_XALAN + "":nodeset"", ""nodeset"");
		}
		catch (ClassNotFoundException e) {
			 System.err.println(e);
		}
	 }
	 public FunctionCall(QName fname, Vector arguments) {
		_fname = fname;
		_arguments = arguments;
		_type = null;
	 }
	 public FunctionCall(QName fname) {
		this(fname, EMPTY_ARG_LIST);
	 }
	 public String getName() {
		return(_fname.toString());
	 }
	 public void setParser(Parser parser) {
		super.setParser(parser);
		if (_arguments != null) {
			 final int n = _arguments.size();
			 for (int i = 0;
			 i < n;
			 i++) {
				final Expression exp = (Expression)_arguments.elementAt(i);
				exp.setParser(parser);
				exp.setParent(this);
			 }
		}
	 }
	 public String getClassNameFromUri(String uri) {
		 String className = (String)_extensionNamespaceTable.get(uri);
		 if (className != null) return className;
		 else {
			 if (uri.startsWith(JAVA_EXT_XSLTC)) {
				 int length = JAVA_EXT_XSLTC.length() + 1;
				 return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
			 }
			 else if (uri.startsWith(JAVA_EXT_XALAN)) {
				 int length = JAVA_EXT_XALAN.length() + 1;
				 return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
			 }
			 else if (uri.startsWith(JAVA_EXT_XALAN_OLD)) {
				 int length = JAVA_EXT_XALAN_OLD.length() + 1;
				 return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
			 }
			 else {
				 int index = uri.lastIndexOf('/');
				 return (index > 0) ? uri.substring(index+1) : uri;
			 }
		 }
	 }
	 public Type typeCheck(SymbolTable stable) throws TypeCheckError {
		 if (_type != null) return _type;
		final String namespace = _fname.getNamespace();
		String local = _fname.getLocalPart();
		if (isExtension()) {
			 _fname = new QName(null, null, local);
			 return typeCheckStandard(stable);
		}
		else if (isStandard()) {
			 return typeCheckStandard(stable);
		}
		else {
			 try {
				 _className = getClassNameFromUri(namespace);
				 final int pos = local.lastIndexOf('.');
				if (pos > 0) {
					 _isStatic = true;
					 if (_className != null && _className.length() > 0) {
						 _namespace_format = NAMESPACE_FORMAT_PACKAGE;
						 _className = _className + ""."" + local.substring(0, pos);
					 }
					 else {
						 _namespace_format = NAMESPACE_FORMAT_JAVA;
						 _className = local.substring(0, pos);
					 }
					 _fname = new QName(namespace, null, local.substring(pos + 1));
				}
				else {
					 if (_className != null && _className.length() > 0) {
						 try {
							 _clazz = ObjectFactory.findProviderClass( _className, ObjectFactory.findClassLoader(), true);
							 _namespace_format = NAMESPACE_FORMAT_CLASS;
						 }
						 catch (ClassNotFoundException e) {
							 _namespace_format = NAMESPACE_FORMAT_PACKAGE;
						 }
					 }
					 else _namespace_format = NAMESPACE_FORMAT_JAVA;
					 if (local.indexOf('-') > 0) {
						 local = replaceDash(local);
					 }
					 String extFunction = (String)_extensionFunctionTable.get(namespace + "":"" + local);
					 if (extFunction != null) {
						 _fname = new QName(null, null, extFunction);
						 return typeCheckStandard(stable);
					 }
					 else _fname = new QName(namespace, null, local);
				}
				return typeCheckExternal(stable);
			 }
			 catch (TypeCheckError e) {
				ErrorMsg errorMsg = e.getErrorMsg();
				if (errorMsg == null) {
					 final String name = _fname.getLocalPart();
					 errorMsg = new ErrorMsg(ErrorMsg.METHOD_NOT_FOUND_ERR, name);
				}
				getParser().reportError(ERROR, errorMsg);
				return _type = Type.Void;
			 }
		 }
	 }
	 public Type typeCheckStandard(SymbolTable stable) throws TypeCheckError {
		_fname.clearNamespace();
		 final int n = _arguments.size();
		final Vector argsType = typeCheckArgs(stable);
		final MethodType args = new MethodType(Type.Void, argsType);
		final MethodType ptype = lookupPrimop(stable, _fname.getLocalPart(), args);
		if (ptype != null) {
			 for (int i = 0;
			 i < n;
			 i++) {
				final Type argType = (Type) ptype.argsType().elementAt(i);
				final Expression exp = (Expression)_arguments.elementAt(i);
				if (!argType.identicalTo(exp.getType())) {
					 try {
						_arguments.setElementAt(new CastExpr(exp, argType), i);
					 }
					 catch (TypeCheckError e) {
						throw new TypeCheckError(this);
					 }
				}
			 }
			 _chosenMethodType = ptype;
			 return _type = ptype.resultType();
		}
		throw new TypeCheckError(this);
	 }
	 public Type typeCheckConstructor(SymbolTable stable) throws TypeCheckError{
		 final Vector constructors = findConstructors();
		if (constructors == null) {
			 throw new TypeCheckError(ErrorMsg.CONSTRUCTOR_NOT_FOUND, _className);
		}
		final int nConstructors = constructors.size();
		final int nArgs = _arguments.size();
		final Vector argsType = typeCheckArgs(stable);
		int bestConstrDistance = Integer.MAX_VALUE;
		_type = null;
		for (int j, i = 0;
		 i < nConstructors;
		 i++) {
			 final Constructor constructor = (Constructor)constructors.elementAt(i);
			 final Class[] paramTypes = constructor.getParameterTypes();
			 Class extType = null;
			 int currConstrDistance = 0;
			 for (j = 0;
			 j < nArgs;
			 j++) {
				extType = paramTypes[j];
				final Type intType = (Type)argsType.elementAt(j);
				Object match = _internal2Java.maps(intType, extType);
				if (match != null) {
					 currConstrDistance += ((JavaType)match).distance;
				}
				else if (intType instanceof ObjectType) {
					 ObjectType objectType = (ObjectType)intType;
					 if (objectType.getJavaClass() == extType) continue;
					 else if (extType.isAssignableFrom(objectType.getJavaClass())) currConstrDistance += 1;
					 else {
						currConstrDistance = Integer.MAX_VALUE;
						break;
					 }
				}
				else {
					 currConstrDistance = Integer.MAX_VALUE;
					 break;
				}
			 }
			 if (j == nArgs && currConstrDistance < bestConstrDistance ) {
				 _chosenConstructor = constructor;
				 _isExtConstructor = true;
				bestConstrDistance = currConstrDistance;
				 _type = (_clazz != null) ? Type.newObjectType(_clazz) : Type.newObjectType(_className);
			 }
		}
		if (_type != null) {
			 return _type;
		}
		throw new TypeCheckError(ErrorMsg.ARGUMENT_CONVERSION_ERR, getMethodSignature(argsType));
	 }
	 public Type typeCheckExternal(SymbolTable stable) throws TypeCheckError {
		int nArgs = _arguments.size();
		final String name = _fname.getLocalPart();
		if (_fname.getLocalPart().equals(""new"")) {
			 return typeCheckConstructor(stable);
		}
		else {
			 boolean hasThisArgument = false;
			 if (nArgs == 0) _isStatic = true;
			 if (!_isStatic) {
				 if (_namespace_format == NAMESPACE_FORMAT_JAVA || _namespace_format == NAMESPACE_FORMAT_PACKAGE) hasThisArgument = true;
				 Expression firstArg = (Expression)_arguments.elementAt(0);
				 Type firstArgType = (Type)firstArg.typeCheck(stable);
				 if (_namespace_format == NAMESPACE_FORMAT_CLASS && firstArgType instanceof ObjectType && _clazz != null && _clazz.isAssignableFrom(((ObjectType)firstArgType).getJavaClass())) hasThisArgument = true;
				 if (hasThisArgument) {
					 _thisArgument = (Expression) _arguments.elementAt(0);
					 _arguments.remove(0);
					 nArgs--;
					 if (firstArgType instanceof ObjectType) {
						 _className = ((ObjectType) firstArgType).getJavaClassName();
					 }
					 else throw new TypeCheckError(ErrorMsg.NO_JAVA_FUNCT_THIS_REF, name);
				 }
			 }
			 else if (_className.length() == 0) {
				final Parser parser = getParser();
				if (parser != null) {
					 reportWarning(this, parser, ErrorMsg.FUNCTION_RESOLVE_ERR, _fname.toString());
				}
				unresolvedExternal = true;
				return _type = Type.Int;
			 }
		}
		final Vector methods = findMethods();
		if (methods == null) {
			 throw new TypeCheckError(ErrorMsg.METHOD_NOT_FOUND_ERR, _className + ""."" + name);
		}
		Class extType = null;
		final int nMethods = methods.size();
		final Vector argsType = typeCheckArgs(stable);
		int bestMethodDistance = Integer.MAX_VALUE;
		_type = null;
		 for (int j, i = 0;
		 i < nMethods;
		 i++) {
			 final Method method = (Method)methods.elementAt(i);
			 final Class[] paramTypes = method.getParameterTypes();
			 int currMethodDistance = 0;
			 for (j = 0;
			 j < nArgs;
			 j++) {
				extType = paramTypes[j];
				final Type intType = (Type)argsType.elementAt(j);
				Object match = _internal2Java.maps(intType, extType);
				if (match != null) {
					 currMethodDistance += ((JavaType)match).distance;
				 }
				else {
					 if (intType instanceof ReferenceType) {
						 currMethodDistance += 1;
					 }
					 else if (intType instanceof ObjectType) {
						 ObjectType object = (ObjectType)intType;
						 if (extType.getName().equals(object.getJavaClassName())) currMethodDistance += 0;
						 else if (extType.isAssignableFrom(object.getJavaClass())) currMethodDistance += 1;
						 else {
							 currMethodDistance = Integer.MAX_VALUE;
							 break;
						 }
					 }
					 else {
						 currMethodDistance = Integer.MAX_VALUE;
						 break;
					 }
				}
			 }
			 if (j == nArgs) {
				 extType = method.getReturnType();
				 _type = (Type) _java2Internal.get(extType);
				 if (_type == null) {
					 _type = Type.newObjectType(extType);
				 }
				 if (_type != null && currMethodDistance < bestMethodDistance) {
					 _chosenMethod = method;
					 bestMethodDistance = currMethodDistance;
				 }
			 }
		}
		if (_chosenMethod != null && _thisArgument == null && !Modifier.isStatic(_chosenMethod.getModifiers())) {
			 throw new TypeCheckError(ErrorMsg.NO_JAVA_FUNCT_THIS_REF, getMethodSignature(argsType));
		}
		if (_type != null) {
			 if (_type == Type.NodeSet) {
				 getXSLTC().setMultiDocument(true);
			 }
			 return _type;
		}
		throw new TypeCheckError(ErrorMsg.ARGUMENT_CONVERSION_ERR, getMethodSignature(argsType));
	 }
	 public Vector typeCheckArgs(SymbolTable stable) throws TypeCheckError {
		final Vector result = new Vector();
		final Enumeration e = _arguments.elements();
		while (e.hasMoreElements()) {
			 final Expression exp = (Expression)e.nextElement();
			 result.addElement(exp.typeCheck(stable));
		}
		return result;
	 }
	 protected final Expression argument(int i) {
		return (Expression)_arguments.elementAt(i);
	 }
	 protected final Expression argument() {
		return argument(0);
	 }
	 protected final int argumentCount() {
		return _arguments.size();
	 }
	 protected final void setArgument(int i, Expression exp) {
		_arguments.setElementAt(exp, i);
	 }
	 public void translateDesynthesized(ClassGenerator classGen, MethodGenerator methodGen) {
		Type type = Type.Boolean;
		if (_chosenMethodType != null) type = _chosenMethodType.resultType();
		final InstructionList il = methodGen.getInstructionList();
		translate(classGen, methodGen);
		if ((type instanceof BooleanType) || (type instanceof IntType)) {
			 _falseList.add(il.append(new IFEQ(null)));
		}
	 }
	 public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
		final int n = argumentCount();
		final ConstantPoolGen cpg = classGen.getConstantPool();
		final InstructionList il = methodGen.getInstructionList();
		final boolean isSecureProcessing = classGen.getParser().getXSLTC().isSecureProcessing();
		int index;
		if (isStandard() || isExtension()) {
			 for (int i = 0;
			 i < n;
			 i++) {
				final Expression exp = argument(i);
				exp.translate(classGen, methodGen);
				exp.startIterator(classGen, methodGen);
			 }
			 final String name = _fname.toString().replace('-', '_') + ""F"";
			 String args = Constants.EMPTYSTRING;
			 if (name.equals(""sumF"")) {
				args = DOM_INTF_SIG;
				il.append(methodGen.loadDOM());
			 }
			 else if (name.equals(""normalize_spaceF"")) {
				if (_chosenMethodType.toSignature(args). equals(""()Ljava/lang/String;
				"")) {
					 args = ""I""+DOM_INTF_SIG;
					 il.append(methodGen.loadContextNode());
					 il.append(methodGen.loadDOM());
				}
			 }
			 index = cpg.addMethodref(BASIS_LIBRARY_CLASS, name, _chosenMethodType.toSignature(args));
			 il.append(new INVOKESTATIC(index));
		}
		else if (unresolvedExternal) {
			 index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""unresolved_externalF"", ""(Ljava/lang/String;
			)V"");
			 il.append(new PUSH(cpg, _fname.toString()));
			 il.append(new INVOKESTATIC(index));
		}
		else if (_isExtConstructor) {
			 if (isSecureProcessing) translateUnallowedExtension(cpg, il);
			 final String clazz = _chosenConstructor.getDeclaringClass().getName();
			 Class[] paramTypes = _chosenConstructor.getParameterTypes();
			 LocalVariableGen[] paramTemp = new LocalVariableGen[n];
			 for (int i = 0;
			 i < n;
			 i++) {
				final Expression exp = argument(i);
				 Type expType = exp.getType();
				exp.translate(classGen, methodGen);
				exp.startIterator(classGen, methodGen);
				expType.translateTo(classGen, methodGen, paramTypes[i]);
				 paramTemp[i] = methodGen.addLocalVariable(""function_call_tmp""+i, expType.toJCType(), null, null);
				 paramTemp[i].setStart( il.append(expType.STORE(paramTemp[i].getIndex())));
			 }
			 il.append(new NEW(cpg.addClass(_className)));
			 il.append(InstructionConstants.DUP);
			 for (int i = 0;
			 i < n;
			 i++) {
				 final Expression arg = argument(i);
				 paramTemp[i].setEnd( il.append(arg.getType().LOAD(paramTemp[i].getIndex())));
			 }
			 final StringBuffer buffer = new StringBuffer();
			 buffer.append('(');
			 for (int i = 0;
			 i < paramTypes.length;
			 i++) {
				buffer.append(getSignature(paramTypes[i]));
			 }
			 buffer.append(')');
			 buffer.append(""V"");
			 index = cpg.addMethodref(clazz, ""<init>"", buffer.toString());
			 il.append(new INVOKESPECIAL(index));
			 (Type.Object).translateFrom(classGen, methodGen, _chosenConstructor.getDeclaringClass());
		}
		else {
			 if (isSecureProcessing) translateUnallowedExtension(cpg, il);
			 final String clazz = _chosenMethod.getDeclaringClass().getName();
			 Class[] paramTypes = _chosenMethod.getParameterTypes();
			 if (_thisArgument != null) {
				_thisArgument.translate(classGen, methodGen);
			 }
			 for (int i = 0;
			 i < n;
			 i++) {
				final Expression exp = argument(i);
				exp.translate(classGen, methodGen);
				exp.startIterator(classGen, methodGen);
				exp.getType().translateTo(classGen, methodGen, paramTypes[i]);
			 }
			 final StringBuffer buffer = new StringBuffer();
			 buffer.append('(');
			 for (int i = 0;
			 i < paramTypes.length;
			 i++) {
				buffer.append(getSignature(paramTypes[i]));
			 }
			 buffer.append(')');
			 buffer.append(getSignature(_chosenMethod.getReturnType()));
			 if (_thisArgument != null && _clazz.isInterface()) {
				 index = cpg.addInterfaceMethodref(clazz, _fname.getLocalPart(), buffer.toString());
				il.append(new INVOKEINTERFACE(index, n+1));
			 }
			 else {
				 index = cpg.addMethodref(clazz, _fname.getLocalPart(), buffer.toString());
				 il.append(_thisArgument != null ? (InvokeInstruction) new INVOKEVIRTUAL(index) : (InvokeInstruction) new INVOKESTATIC(index));
			 }
			 _type.translateFrom(classGen, methodGen,_chosenMethod.getReturnType());
		}
	 }
	 public String toString() {
		return ""funcall("" + _fname + "", "" + _arguments + ')';
	 }
	 public boolean isStandard() {
		final String namespace = _fname.getNamespace();
		return (namespace == null) || (namespace.equals(Constants.EMPTYSTRING));
	 }
	 public boolean isExtension() {
		final String namespace = _fname.getNamespace();
		return (namespace != null) && (namespace.equals(EXT_XSLTC));
	 }
	 private Vector findMethods() {
		 Vector result = null;
		 final String namespace = _fname.getNamespace();
		 if (_className != null && _className.length() > 0) {
			 final int nArgs = _arguments.size();
			 try {
				 if (_clazz == null) {
					 _clazz = ObjectFactory.findProviderClass( _className, ObjectFactory.findClassLoader(), true);
					if (_clazz == null) {
						 final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
						 getParser().reportError(Constants.ERROR, msg);
					}
				 }
				 final String methodName = _fname.getLocalPart();
				 final Method[] methods = _clazz.getMethods();
				 for (int i = 0;
				 i < methods.length;
				 i++) {
					final int mods = methods[i].getModifiers();
					if (Modifier.isPublic(mods) && methods[i].getName().equals(methodName) && methods[i].getParameterTypes().length == nArgs){
						 if (result == null) {
							 result = new Vector();
						 }
						 result.addElement(methods[i]);
					}
				 }
			 }
			 catch (ClassNotFoundException e) {
				 final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
				 getParser().reportError(Constants.ERROR, msg);
			 }
		 }
		 return result;
	 }
	 private Vector findConstructors() {
		 Vector result = null;
		 final String namespace = _fname.getNamespace();
		 final int nArgs = _arguments.size();
		 try {
			 if (_clazz == null) {
				 _clazz = ObjectFactory.findProviderClass( _className, ObjectFactory.findClassLoader(), true);
				 if (_clazz == null) {
					 final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
					 getParser().reportError(Constants.ERROR, msg);
				 }
			 }
			 final Constructor[] constructors = _clazz.getConstructors();
			 for (int i = 0;
			 i < constructors.length;
			 i++) {
				 final int mods = constructors[i].getModifiers();
				 if (Modifier.isPublic(mods) && constructors[i].getParameterTypes().length == nArgs) {
					 if (result == null) {
						 result = new Vector();
					 }
					 result.addElement(constructors[i]);
				 }
			 }
		 }
		 catch (ClassNotFoundException e) {
			 final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
			 getParser().reportError(Constants.ERROR, msg);
		 }
		 return result;
	 }
	 static final String getSignature(Class clazz) {
		if (clazz.isArray()) {
			 final StringBuffer sb = new StringBuffer();
			 Class cl = clazz;
			 while (cl.isArray()) {
				sb.append(""["");
				cl = cl.getComponentType();
			 }
			 sb.append(getSignature(cl));
			 return sb.toString();
		}
		else if (clazz.isPrimitive()) {
			 if (clazz == Integer.TYPE) {
				return ""I"";
			 }
			 else if (clazz == Byte.TYPE) {
				return ""B"";
			 }
			 else if (clazz == Long.TYPE) {
				return ""J"";
			 }
			 else if (clazz == Float.TYPE) {
				return ""F"";
			 }
			 else if (clazz == Double.TYPE) {
				return ""D"";
			 }
			 else if (clazz == Short.TYPE) {
				return ""S"";
			 }
			 else if (clazz == Character.TYPE) {
				return ""C"";
			 }
			 else if (clazz == Boolean.TYPE) {
				return ""Z"";
			 }
			 else if (clazz == Void.TYPE) {
				return ""V"";
			 }
			 else {
				final String name = clazz.toString();
				ErrorMsg err = new ErrorMsg(ErrorMsg.UNKNOWN_SIG_TYPE_ERR,name);
				throw new Error(err.toString());
			 }
		}
		else {
			 return ""L"" + clazz.getName().replace('.', '/') + ';
			';
		}
	 }
	 static final String getSignature(Method meth) {
		final StringBuffer sb = new StringBuffer();
		sb.append('(');
		final Class[] params = meth.getParameterTypes();
		 for (int j = 0;
		 j < params.length;
		 j++) {
			 sb.append(getSignature(params[j]));
		}
		return sb.append(')').append(getSignature(meth.getReturnType())) .toString();
	 }
	 static final String getSignature(Constructor cons) {
		final StringBuffer sb = new StringBuffer();
		sb.append('(');
		final Class[] params = cons.getParameterTypes();
		 for (int j = 0;
		 j < params.length;
		 j++) {
			 sb.append(getSignature(params[j]));
		}
		return sb.append("")V"").toString();
	 }
	 private String getMethodSignature(Vector argsType) {
		 final StringBuffer buf = new StringBuffer(_className);
		 buf.append('.').append(_fname.getLocalPart()).append('(');
		int nArgs = argsType.size();
		 for (int i = 0;
		 i < nArgs;
		 i++) {
			 final Type intType = (Type)argsType.elementAt(i);
			 buf.append(intType.toString());
			 if (i < nArgs - 1) buf.append("", "");
		}
		buf.append(')');
		return buf.toString();
	 }
	 protected static String replaceDash(String name) {
		 char dash = '-';
		 StringBuffer buff = new StringBuffer("""");
		 for (int i = 0;
		 i < name.length();
		 i++) {
			 if (i > 0 && name.charAt(i-1) == dash) buff.append(Character.toUpperCase(name.charAt(i)));
			 else if (name.charAt(i) != dash) buff.append(name.charAt(i));
		 }
		 return buff.toString();
	 }
	 private void translateUnallowedExtension(ConstantPoolGen cpg, InstructionList il) {
		int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""unallowed_extension_functionF"", ""(Ljava/lang/String;
		)V"");
		il.append(new PUSH(cpg, _fname.toString()));
		il.append(new INVOKESTATIC(index));
	 }
 }",1,0,0,0
"public boolean isExists(Object identifier) throws AppCatalogException {
	 HashMap<String, String> ids;
	 if (identifier instanceof Map) {
		 ids = (HashMap) identifier;
	 }
	 else {
		 logger.error(""Identifier should be a map with the field name and it's value"");
		 throw new AppCatalogException(""Identifier should be a map with the field name and it's value"");
	 }
	 EntityManager em = null;
	 try {
		 em = AppCatalogJPAUtils.getEntityManager();
		 ComputeResourcePreference existingPreference = em.find(ComputeResourcePreference.class, new ComputeResourcePreferencePK(ids.get(ComputeResourcePreferenceConstants.GATEWAY_ID), ids.get(ComputeResourcePreferenceConstants.RESOURCE_ID)));
		 if (em.isOpen()) {
			 if (em.getTransaction().isActive()){
				 em.getTransaction().rollback();
			 }
			 em.close();
		 }
		 return existingPreference != null;
	 }
	catch (Exception e) {
		 logger.error(e.getMessage(), e);
		 throw new AppCatalogException(e);
	 }
	 finally {
		 if (em != null && em.isOpen()) {
			 if (em.getTransaction().isActive()) {
				 em.getTransaction().rollback();
			 }
			 em.close();
		 }
	 }
 }",0,0,1,0
"public class Param {
	private String name;
	private String value;
	public void setName( String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setValue( String value) {
		this.value = value;
	}
	public String getValue() {
		return this.value;
	}
	public String toString() {
		return ""JSP Tag Param: name '"" + this.name + ""', value '"" + this.value + ""'"";
	}
}",0,1,0,0
"public class RewriteLoadBalancerClient implements LoadBalancerClient{
	 private static final Logger _log = LoggerFactory.getLogger(TrackerClient.class);
	 private final String _serviceName;
	 private final URI _uri;
	 private final RewriteClient _client;
	 public RewriteLoadBalancerClient(String serviceName, URI uri, TransportClient client) {
		 _serviceName = serviceName;
		 _uri = uri;
		 _client = new RewriteClient(client, new D2URIRewriter(uri));
		 debug(_log, ""created rewrite client: "", this);
	 }
	 public void restRequest(RestRequest request, RequestContext requestContext, Map<String, String> wireAttrs, TransportCallback<RestResponse> callback) {
		 assert _serviceName.equals(LoadBalancerUtil.getServiceNameFromUri(request.getURI()));
		 _client.restRequest(request, requestContext, wireAttrs, callback);
	 }
	 public void streamRequest(StreamRequest request, RequestContext requestContext, Map<String, String> wireAttrs, TransportCallback<StreamResponse> callback) {
		 assert _serviceName.equals(LoadBalancerUtil.getServiceNameFromUri(request.getURI()));
		 _client.streamRequest(request, requestContext, wireAttrs, callback);
	 }
	 public void shutdown(Callback<None> callback) {
		 _client.shutdown(callback);
	 }
	 public TransportClient getWrappedClient() {
		 return _client;
	 }
	 public TransportClient getDecoratedClient() {
		 return _client;
	 }
	 public URI getUri() {
		 return _uri;
	 }
	 public String getServiceName() {
		 return _serviceName;
	 }
	 public String toString() {
		 return ""RewriteLoadBalancerClient [_serviceName="" + _serviceName + "", _uri="" + _uri + "", _wrappedClient="" + _client + ""]"";
	 }
}",0,1,0,0
"public void executeMain() throws BuildException {
	 checkAttributesAndElements();
	 File renamedFile = null;
	 addingNewFiles = true;
	 processDoUpdate();
	 processGroupFilesets();
	 Vector vfss = new Vector();
	 if (baseDir != null) {
		 FileSet fs = (FileSet) getImplicitFileSet().clone();
		 fs.setDir(baseDir);
		 vfss.addElement(fs);
	 }
	 for (int i = 0;
	 i < resources.size();
	 i++) {
		 ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
		 vfss.addElement(rc);
	 }
	 ResourceCollection[] fss = new ResourceCollection[vfss.size()];
	 vfss.copyInto(fss);
	 boolean success = false;
	 try {
		 ArchiveState state = getResourcesToAdd(fss, zipFile, false);
		 if (!state.isOutOfDate()) {
			 return;
		 }
		 updatedFile = true;
		 if (!zipFile.exists() && state.isWithoutAnyResources()) {
			 createEmptyZip(zipFile);
			 return;
		 }
		 Resource[][] addThem = state.getResourcesToAdd();
		 if (doUpdate) {
			 renamedFile = renameFile();
		 }
		 String action = doUpdate ? ""Updating "" : ""Building "";
		 log(action + archiveType + "": "" + zipFile.getAbsolutePath());
		 ZipOutputStream zOut = null;
		 try {
			 if (!skipWriting) {
				 zOut = new ZipOutputStream(zipFile);
				 zOut.setEncoding(encoding);
				 zOut.setMethod(doCompress ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
				 zOut.setLevel(level);
			 }
			 initZipOutputStream(zOut);
			 for (int i = 0;
			 i < fss.length;
			 i++) {
				 if (addThem[i].length != 0) {
					 addResources(fss[i], addThem[i], zOut);
				 }
			 }
			 if (doUpdate) {
				 addingNewFiles = false;
				 ZipFileSet oldFiles = new ZipFileSet();
				 oldFiles.setProject(getProject());
				 oldFiles.setSrc(renamedFile);
				 oldFiles.setDefaultexcludes(false);
				 for (int i = 0;
				 i < addedFiles.size();
				 i++) {
					 PatternSet.NameEntry ne = oldFiles.createExclude();
					 ne.setName((String) addedFiles.elementAt(i));
				 }
				 DirectoryScanner ds = oldFiles.getDirectoryScanner(getProject());
				 ((ZipScanner) ds).setEncoding(encoding);
				 String[] f = ds.getIncludedFiles();
				 Resource[] r = new Resource[f.length];
				 for (int i = 0;
				 i < f.length;
				 i++) {
					 r[i] = ds.getResource(f[i]);
				 }
				 if (!doFilesonly) {
					 String[] d = ds.getIncludedDirectories();
					 Resource[] dr = new Resource[d.length];
					 for (int i = 0;
					 i < d.length;
					 i++) {
						 dr[i] = ds.getResource(d[i]);
					 }
					 Resource[] tmp = r;
					 r = new Resource[tmp.length + dr.length];
					 System.arraycopy(dr, 0, r, 0, dr.length);
					 System.arraycopy(tmp, 0, r, dr.length, tmp.length);
				 }
				 addResources(oldFiles, r, zOut);
			 }
			 if (zOut != null) {
				 zOut.setComment(comment);
			 }
			 finalizeZipOutputStream(zOut);
			 if (doUpdate) {
				 if (!renamedFile.delete()) {
					 log (""Warning: unable to delete temporary file "" + renamedFile.getName(), Project.MSG_WARN);
				 }
			 }
			 success = true;
		 }
		 finally {
			 closeZout(zOut, success);
		 }
	 }
	 catch (IOException ioe) {
		 String msg = ""Problem creating "" + archiveType + "": "" + ioe.getMessage();
		 if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
			 msg += "" (and the archive is probably corrupt but I could not "" + ""delete it)"";
		 }
		 if (doUpdate && renamedFile != null) {
			 try {
				 FILE_UTILS.rename(renamedFile, zipFile);
			 }
			 catch (IOException e) {
				 msg += "" (and I couldn't rename the temporary file "" + renamedFile.getName() + "" back)"";
			 }
		 }
		 throw new BuildException(msg, ioe, getLocation());
	 }
	 finally {
		 cleanUp();
	 }
 }",0,0,1,0
"public void createStreams() {
	 synchronized (outMutex) {
		 outStreams();
		 if (alwaysLogOut || outputStream == null) {
			 OutputStream outputLog = new LogOutputStream(managingTask, Project.MSG_INFO);
			 outputStream = (outputStream == null) ? outputLog : new TeeOutputStream(outputLog, outputStream);
		 }
		 if ((outputFilterChains != null && outputFilterChains.size() > 0) || !(outputEncoding.equalsIgnoreCase(inputEncoding))) {
			 try {
				 LeadPipeInputStream snk = new LeadPipeInputStream();
				 snk.setManagingComponent(managingTask);
				 InputStream outPumpIn = snk;
				 Reader reader = new InputStreamReader(outPumpIn, inputEncoding);
				 if (outputFilterChains != null && outputFilterChains.size() > 0) {
					 ChainReaderHelper helper = new ChainReaderHelper();
					 helper.setProject(managingTask.getProject());
					 helper.setPrimaryReader(reader);
					 helper.setFilterChains(outputFilterChains);
					 reader = helper.getAssembledReader();
				 }
				 outPumpIn = new ReaderInputStream(reader, outputEncoding);
				 Thread t = new Thread(threadGroup, new StreamPumper( outPumpIn, outputStream, true), ""output pumper"");
				 t.setPriority(Thread.MAX_PRIORITY);
				 outputStream = new PipedOutputStream(snk);
				 t.start();
			 }
			 catch (IOException eyeOhEx) {
				 throw new BuildException(""error setting up output stream"", eyeOhEx);
			 }
		 }
	 }
	 synchronized (errMutex) {
		 errorStreams();
		 if (alwaysLogErr || errorStream == null) {
			 OutputStream errorLog = new LogOutputStream(managingTask, Project.MSG_WARN);
			 errorStream = (errorStream == null) ? errorLog : new TeeOutputStream(errorLog, errorStream);
		 }
		 if ((errorFilterChains != null && errorFilterChains.size() > 0) || !(errorEncoding.equalsIgnoreCase(inputEncoding))) {
			 try {
				 LeadPipeInputStream snk = new LeadPipeInputStream();
				 snk.setManagingComponent(managingTask);
				 InputStream errPumpIn = snk;
				 Reader reader = new InputStreamReader(errPumpIn, inputEncoding);
				 if (errorFilterChains != null && errorFilterChains.size() > 0) {
					 ChainReaderHelper helper = new ChainReaderHelper();
					 helper.setProject(managingTask.getProject());
					 helper.setPrimaryReader(reader);
					 helper.setFilterChains(errorFilterChains);
					 reader = helper.getAssembledReader();
				 }
				 errPumpIn = new ReaderInputStream(reader, errorEncoding);
				 Thread t = new Thread(threadGroup, new StreamPumper( errPumpIn, errorStream, true), ""error pumper"");
				 t.setPriority(Thread.MAX_PRIORITY);
				 errorStream = new PipedOutputStream(snk);
				 t.start();
			 }
			 catch (IOException eyeOhEx) {
				 throw new BuildException(""error setting up error stream"", eyeOhEx);
			 }
		 }
	 }
	 synchronized (inMutex) {
		 if (input != null && input.length > 0) {
			 managingTask .log(""Redirecting input from file"" + ((input.length == 1) ? """" : ""s""), Project.MSG_VERBOSE);
			 try {
				 inputStream = new ConcatFileInputStream(input);
			 }
			 catch (IOException eyeOhEx) {
				 throw new BuildException(eyeOhEx);
			 }
			 ((ConcatFileInputStream) inputStream) .setManagingComponent(managingTask);
		 }
		 else if (inputString != null) {
			 StringBuffer buf = new StringBuffer(""Using input "");
			 if (logInputString) {
				 buf.append('""').append(inputString).append('""');
			 }
			 else {
				 buf.append(""string"");
			 }
			 managingTask.log(buf.toString(), Project.MSG_VERBOSE);
			 inputStream = new ByteArrayInputStream(inputString.getBytes());
		 }
		 if (inputStream != null && inputFilterChains != null && inputFilterChains.size() > 0) {
			 ChainReaderHelper helper = new ChainReaderHelper();
			 helper.setProject(managingTask.getProject());
			 try {
				 helper.setPrimaryReader(new InputStreamReader(inputStream, inputEncoding));
			 }
			 catch (IOException eyeOhEx) {
				 throw new BuildException(""error setting up input stream"", eyeOhEx);
			 }
			 helper.setFilterChains(inputFilterChains);
			 inputStream = new ReaderInputStream( helper.getAssembledReader(), inputEncoding);
		 }
	 }
 }",0,0,1,0
"public void changeArrowsOfArrowLink(MindMapArrowLinkModel arrowLink, boolean hasStartArrow, boolean hasEndArrow);",0,0,0,0
"public class LoaderUtils {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 public static void setContextClassLoader(ClassLoader loader) {
		 Thread currentThread = Thread.currentThread();
		 currentThread.setContextClassLoader(loader);
	 }
	 public static ClassLoader getContextClassLoader() {
		 Thread currentThread = Thread.currentThread();
		 return currentThread.getContextClassLoader();
	 }
	 public static boolean isContextLoaderAvailable() {
		 return true;
	 }
	 private static File normalizeSource(File source) {
		 if (source != null) {
			 try {
				 source = FILE_UTILS.normalize(source.getAbsolutePath());
			 }
			 catch (BuildException e) {
			 }
		 }
		 return source;
	 }
	 public static File getClassSource(Class c) {
		 return normalizeSource(Locator.getClassSource(c));
	 }
	 public static File getResourceSource(ClassLoader c, String resource) {
		 if (c == null) {
			 c = LoaderUtils.class.getClassLoader();
		 }
		 return normalizeSource(Locator.getResourceSource(c, resource));
	 }
	 public static String classNameToResource(String className) {
		 return className.replace('.', '/') + "".class"";
	 }
	 public static boolean classExists(ClassLoader loader, String className) {
		 return loader.getResource(classNameToResource(className)) != null;
	 }
}",0,0,0,0
"public void load() {
	BufferedReader br = null;
	try {
		File file = new File(System.getProperty(""user.home""), "".xdman/config.txt"");
		if (!file.exists()) {
			return;
		}
		FileReader r = new FileReader(file);
		br = new BufferedReader(r);
		while (true) {
			String ln = br.readLine();
			if (ln == null)break;
			if (ln.startsWith(""#""))continue;
			int index = ln.indexOf("":"");
			if (index < 1)continue;
			String key = ln.substring(0, index);
			String val = ln.substring(index + 1);
			if (key.equals(""monitoring"")) {
				this.monitoring = val.equals(""true"");
			}
			 else if (key.equals(""downloadFolder"")) {
				this.downloadFolder = val;
			}
			 else if (key.equals(""maxSegments"")) {
				this.maxSegments = Integer.parseInt(val);
			}
			 else if (key.equals(""minSegmentSize"")) {
				this.minSegmentSize = Integer.parseInt(val);
			}
			 else if (key.equals(""networkTimeout"")) {
				this.networkTimeout = Integer.parseInt(val);
			}
			 else if (key.equals(""tcpWindowSize"")) {
				this.tcpWindowSize = Integer.parseInt(val);
			}
			 else if (key.equals(""duplicateAction"")) {
				this.duplicateAction = Integer.parseInt(val);
			}
			 else if (key.equals(""speedLimit"")) {
				this.speedLimit = Integer.parseInt(val);
			}
			 else if (key.equals(""showDownloadWindow"")) {
				this.showDownloadWindow = val.equals(""true"");
			}
			 else if (key.equals(""showDownloadCompleteWindow"")) {
				this.showDownloadCompleteWindow = val.equals(""true"");
			}
			 else if (key.equals(""minVidSize"")) {
				this.minVidSize = Integer.parseInt(val);
			}
			 else if (key.equals(""maxDownloads"")) {
				this.maxDownloads = Integer.parseInt(val);
			}
			 else if (key.equals(""blockedHosts"")) {
				this.blockedHosts = val.split("","");
			}
			 else if (key.equals(""vidUrls"")) {
				this.vidUrls = val.split("","");
			}
			 else if (key.equals(""fileExts"")) {
				this.fileExts = val.split("","");
			}
			 else if (key.equals(""vidExts"")) {
				this.vidExts = val.split("","");
			}
			 else if (key.equals(""proxyMode"")) {
				this.proxyMode = Integer.parseInt(val);
			}
			 else if (key.equals(""proxyPort"")) {
				this.proxyPort = Integer.parseInt(val);
			}
			 else if (key.equals(""socksPort"")) {
				this.socksPort = Integer.parseInt(val);
			}
			 else if (key.equals(""proxyPac"")) {
				this.proxyPac = val;
			}
			 else if (key.equals(""proxyHost"")) {
				this.proxyHost = val;
			}
			 else if (key.equals(""socksHost"")) {
				this.socksHost = val;
			}
			 else if (key.equals(""proxyUser"")) {
				this.proxyUser = val;
			}
			 else if (key.equals(""proxyPass"")) {
				this.proxyPass = val;
			}
			 else if (key.equals(""showVideoNotification"")) {
				this.showVideoNotification = ""true"".equals(val);
			}
			 else if (key.equals(""keepAwake"")) {
				this.keepAwake = ""true"".equals(val);
			}
			 else if (key.equals(""autoStart"")) {
				this.autoStart = ""true"".equals(val);
			}
			 else if (key.equals(""execAntivir"")) {
				this.execAntivir = ""true"".equals(val);
			}
			 else if (key.equals(""execCmd"")) {
				this.execCmd = ""true"".equals(val);
			}
			 else if (key.equals(""antivirExe"")) {
				this.antivirExe = val;
			}
			 else if (key.equals(""antivirCmd"")) {
				this.antivirCmd = val;
			}
			 else if (key.equals(""customCmd"")) {
				this.customCmd = val;
			}
			 else if (key.equals(""autoShutdown"")) {
				this.autoShutdown = ""true"".equals(val);
			}
			 else if (key.equals(""version"")) {
				this.firstRun = !XDMApp.APP_VERSION.equals(val);
			}
			 else if (key.equals(""language"")) {
				this.language = val;
			}
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	try {
		br.close();
	}
	 catch (Exception e) {
	}
}",0,0,1,0
"public class XSAttributeChecker {
	 private static final String ELEMENT_N = ""element_n"";
	 private static final String ELEMENT_R = ""element_r"";
	 private static final String ATTRIBUTE_N = ""attribute_n"";
	 private static final String ATTRIBUTE_R = ""attribute_r"";
	 private static int ATTIDX_COUNT = 0;
	 public static final int ATTIDX_ABSTRACT = ATTIDX_COUNT++;
	 public static final int ATTIDX_AFORMDEFAULT = ATTIDX_COUNT++;
	 public static final int ATTIDX_BASE = ATTIDX_COUNT++;
	 public static final int ATTIDX_BLOCK = ATTIDX_COUNT++;
	 public static final int ATTIDX_BLOCKDEFAULT = ATTIDX_COUNT++;
	 public static final int ATTIDX_DEFAULT = ATTIDX_COUNT++;
	 public static final int ATTIDX_EFORMDEFAULT = ATTIDX_COUNT++;
	 public static final int ATTIDX_FINAL = ATTIDX_COUNT++;
	 public static final int ATTIDX_FINALDEFAULT = ATTIDX_COUNT++;
	 public static final int ATTIDX_FIXED = ATTIDX_COUNT++;
	 public static final int ATTIDX_FORM = ATTIDX_COUNT++;
	 public static final int ATTIDX_ID = ATTIDX_COUNT++;
	 public static final int ATTIDX_ITEMTYPE = ATTIDX_COUNT++;
	 public static final int ATTIDX_MAXOCCURS = ATTIDX_COUNT++;
	 public static final int ATTIDX_MEMBERTYPES = ATTIDX_COUNT++;
	 public static final int ATTIDX_MINOCCURS = ATTIDX_COUNT++;
	 public static final int ATTIDX_MIXED = ATTIDX_COUNT++;
	 public static final int ATTIDX_NAME = ATTIDX_COUNT++;
	 public static final int ATTIDX_NAMESPACE = ATTIDX_COUNT++;
	 public static final int ATTIDX_NAMESPACE_LIST = ATTIDX_COUNT++;
	 public static final int ATTIDX_NILLABLE = ATTIDX_COUNT++;
	 public static final int ATTIDX_NONSCHEMA = ATTIDX_COUNT++;
	 public static final int ATTIDX_PROCESSCONTENTS = ATTIDX_COUNT++;
	 public static final int ATTIDX_PUBLIC = ATTIDX_COUNT++;
	 public static final int ATTIDX_REF = ATTIDX_COUNT++;
	 public static final int ATTIDX_REFER = ATTIDX_COUNT++;
	 public static final int ATTIDX_SCHEMALOCATION = ATTIDX_COUNT++;
	 public static final int ATTIDX_SOURCE = ATTIDX_COUNT++;
	 public static final int ATTIDX_SUBSGROUP = ATTIDX_COUNT++;
	 public static final int ATTIDX_SYSTEM = ATTIDX_COUNT++;
	 public static final int ATTIDX_TARGETNAMESPACE = ATTIDX_COUNT++;
	 public static final int ATTIDX_TYPE = ATTIDX_COUNT++;
	 public static final int ATTIDX_USE = ATTIDX_COUNT++;
	 public static final int ATTIDX_VALUE = ATTIDX_COUNT++;
	 public static final int ATTIDX_ENUMNSDECLS = ATTIDX_COUNT++;
	 public static final int ATTIDX_VERSION = ATTIDX_COUNT++;
	 public static final int ATTIDX_XML_LANG = ATTIDX_COUNT++;
	 public static final int ATTIDX_XPATH = ATTIDX_COUNT++;
	 public static final int ATTIDX_FROMDEFAULT = ATTIDX_COUNT++;
	 public static final int ATTIDX_ISRETURNED = ATTIDX_COUNT++;
	 private static final XIntPool fXIntPool = new XIntPool();
	 private static final XInt INT_QUALIFIED = fXIntPool.getXInt(SchemaSymbols.FORM_QUALIFIED);
	 private static final XInt INT_UNQUALIFIED = fXIntPool.getXInt(SchemaSymbols.FORM_UNQUALIFIED);
	 private static final XInt INT_EMPTY_SET = fXIntPool.getXInt(XSConstants.DERIVATION_NONE);
	 private static final XInt INT_ANY_STRICT = fXIntPool.getXInt(XSWildcardDecl.PC_STRICT);
	 private static final XInt INT_ANY_LAX = fXIntPool.getXInt(XSWildcardDecl.PC_LAX);
	 private static final XInt INT_ANY_SKIP = fXIntPool.getXInt(XSWildcardDecl.PC_SKIP);
	 private static final XInt INT_ANY_ANY = fXIntPool.getXInt(XSWildcardDecl.NSCONSTRAINT_ANY);
	 private static final XInt INT_ANY_LIST = fXIntPool.getXInt(XSWildcardDecl.NSCONSTRAINT_LIST);
	 private static final XInt INT_ANY_NOT = fXIntPool.getXInt(XSWildcardDecl.NSCONSTRAINT_NOT);
	 private static final XInt INT_USE_OPTIONAL = fXIntPool.getXInt(SchemaSymbols.USE_OPTIONAL);
	 private static final XInt INT_USE_REQUIRED = fXIntPool.getXInt(SchemaSymbols.USE_REQUIRED);
	 private static final XInt INT_USE_PROHIBITED = fXIntPool.getXInt(SchemaSymbols.USE_PROHIBITED);
	 private static final XInt INT_WS_PRESERVE = fXIntPool.getXInt(XSSimpleType.WS_PRESERVE);
	 private static final XInt INT_WS_REPLACE = fXIntPool.getXInt(XSSimpleType.WS_REPLACE);
	 private static final XInt INT_WS_COLLAPSE = fXIntPool.getXInt(XSSimpleType.WS_COLLAPSE);
	 private static final XInt INT_UNBOUNDED = fXIntPool.getXInt(SchemaSymbols.OCCURRENCE_UNBOUNDED);
	 private static final Hashtable fEleAttrsMapG = new Hashtable(29);
	 private static final Hashtable fEleAttrsMapL = new Hashtable(79);
	 protected static final int DT_ANYURI = 0;
	 protected static final int DT_ID = 1;
	 protected static final int DT_QNAME = 2;
	 protected static final int DT_STRING = 3;
	 protected static final int DT_TOKEN = 4;
	 protected static final int DT_NCNAME = 5;
	 protected static final int DT_XPATH = 6;
	 protected static final int DT_XPATH1 = 7;
	 protected static final int DT_LANGUAGE = 8;
	 protected static final int DT_COUNT = DT_LANGUAGE + 1;
	 private static final XSSimpleType[] fExtraDVs = new XSSimpleType[DT_COUNT];
	 static {
		 SchemaGrammar grammar = SchemaGrammar.SG_SchemaNS;
		 fExtraDVs[DT_ANYURI] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_ANYURI);
		 fExtraDVs[DT_ID] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_ID);
		 fExtraDVs[DT_QNAME] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_QNAME);
		 fExtraDVs[DT_STRING] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_STRING);
		 fExtraDVs[DT_TOKEN] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_TOKEN);
		 fExtraDVs[DT_NCNAME] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_NCNAME);
		 fExtraDVs[DT_XPATH] = fExtraDVs[DT_STRING];
		 fExtraDVs[DT_XPATH] = fExtraDVs[DT_STRING];
		 fExtraDVs[DT_LANGUAGE] = (XSSimpleType)grammar.getGlobalTypeDecl(SchemaSymbols.ATTVAL_LANGUAGE);
	 }
	 protected static final int DT_BLOCK = -1;
	 protected static final int DT_BLOCK1 = -2;
	 protected static final int DT_FINAL = -3;
	 protected static final int DT_FINAL1 = -4;
	 protected static final int DT_FINAL2 = -5;
	 protected static final int DT_FORM = -6;
	 protected static final int DT_MAXOCCURS = -7;
	 protected static final int DT_MAXOCCURS1 = -8;
	 protected static final int DT_MEMBERTYPES = -9;
	 protected static final int DT_MINOCCURS1 = -10;
	 protected static final int DT_NAMESPACE = -11;
	 protected static final int DT_PROCESSCONTENTS = -12;
	 protected static final int DT_USE = -13;
	 protected static final int DT_WHITESPACE = -14;
	 protected static final int DT_BOOLEAN = -15;
	 protected static final int DT_NONNEGINT = -16;
	 protected static final int DT_POSINT = -17;
	 static {
		 int attCount = 0;
		 int ATT_ABSTRACT_D = attCount++;
		 int ATT_ATTRIBUTE_FD_D = attCount++;
		 int ATT_BASE_R = attCount++;
		 int ATT_BASE_N = attCount++;
		 int ATT_BLOCK_N = attCount++;
		 int ATT_BLOCK1_N = attCount++;
		 int ATT_BLOCK_D_D = attCount++;
		 int ATT_DEFAULT_N = attCount++;
		 int ATT_ELEMENT_FD_D = attCount++;
		 int ATT_FINAL_N = attCount++;
		 int ATT_FINAL1_N = attCount++;
		 int ATT_FINAL_D_D = attCount++;
		 int ATT_FIXED_N = attCount++;
		 int ATT_FIXED_D = attCount++;
		 int ATT_FORM_N = attCount++;
		 int ATT_ID_N = attCount++;
		 int ATT_ITEMTYPE_N = attCount++;
		 int ATT_MAXOCCURS_D = attCount++;
		 int ATT_MAXOCCURS1_D = attCount++;
		 int ATT_MEMBER_T_N = attCount++;
		 int ATT_MINOCCURS_D = attCount++;
		 int ATT_MINOCCURS1_D = attCount++;
		 int ATT_MIXED_D = attCount++;
		 int ATT_MIXED_N = attCount++;
		 int ATT_NAME_R = attCount++;
		 int ATT_NAMESPACE_D = attCount++;
		 int ATT_NAMESPACE_N = attCount++;
		 int ATT_NILLABLE_D = attCount++;
		 int ATT_PROCESS_C_D = attCount++;
		 int ATT_PUBLIC_R = attCount++;
		 int ATT_REF_R = attCount++;
		 int ATT_REFER_R = attCount++;
		 int ATT_SCHEMA_L_R = attCount++;
		 int ATT_SCHEMA_L_N = attCount++;
		 int ATT_SOURCE_N = attCount++;
		 int ATT_SUBSTITUTION_G_N = attCount++;
		 int ATT_SYSTEM_N = attCount++;
		 int ATT_TARGET_N_N = attCount++;
		 int ATT_TYPE_N = attCount++;
		 int ATT_USE_D = attCount++;
		 int ATT_VALUE_NNI_N = attCount++;
		 int ATT_VALUE_PI_N = attCount++;
		 int ATT_VALUE_STR_N = attCount++;
		 int ATT_VALUE_WS_N = attCount++;
		 int ATT_VERSION_N = attCount++;
		 int ATT_XML_LANG = attCount++;
		 int ATT_XPATH_R = attCount++;
		 int ATT_XPATH1_R = attCount++;
		 OneAttr[] allAttrs = new OneAttr[attCount];
		 allAttrs[ATT_ABSTRACT_D] = new OneAttr(SchemaSymbols.ATT_ABSTRACT, DT_BOOLEAN, ATTIDX_ABSTRACT, Boolean.FALSE);
		 allAttrs[ATT_ATTRIBUTE_FD_D] = new OneAttr(SchemaSymbols.ATT_ATTRIBUTEFORMDEFAULT, DT_FORM, ATTIDX_AFORMDEFAULT, INT_UNQUALIFIED);
		 allAttrs[ATT_BASE_R] = new OneAttr(SchemaSymbols.ATT_BASE, DT_QNAME, ATTIDX_BASE, null);
		 allAttrs[ATT_BASE_N] = new OneAttr(SchemaSymbols.ATT_BASE, DT_QNAME, ATTIDX_BASE, null);
		 allAttrs[ATT_BLOCK_N] = new OneAttr(SchemaSymbols.ATT_BLOCK, DT_BLOCK, ATTIDX_BLOCK, null);
		 allAttrs[ATT_BLOCK1_N] = new OneAttr(SchemaSymbols.ATT_BLOCK, DT_BLOCK1, ATTIDX_BLOCK, null);
		 allAttrs[ATT_BLOCK_D_D] = new OneAttr(SchemaSymbols.ATT_BLOCKDEFAULT, DT_BLOCK, ATTIDX_BLOCKDEFAULT, INT_EMPTY_SET);
		 allAttrs[ATT_DEFAULT_N] = new OneAttr(SchemaSymbols.ATT_DEFAULT, DT_STRING, ATTIDX_DEFAULT, null);
		 allAttrs[ATT_ELEMENT_FD_D] = new OneAttr(SchemaSymbols.ATT_ELEMENTFORMDEFAULT, DT_FORM, ATTIDX_EFORMDEFAULT, INT_UNQUALIFIED);
		 allAttrs[ATT_FINAL_N] = new OneAttr(SchemaSymbols.ATT_FINAL, DT_FINAL, ATTIDX_FINAL, null);
		 allAttrs[ATT_FINAL1_N] = new OneAttr(SchemaSymbols.ATT_FINAL, DT_FINAL1, ATTIDX_FINAL, null);
		 allAttrs[ATT_FINAL_D_D] = new OneAttr(SchemaSymbols.ATT_FINALDEFAULT, DT_FINAL2, ATTIDX_FINALDEFAULT, INT_EMPTY_SET);
		 allAttrs[ATT_FIXED_N] = new OneAttr(SchemaSymbols.ATT_FIXED, DT_STRING, ATTIDX_FIXED, null);
		 allAttrs[ATT_FIXED_D] = new OneAttr(SchemaSymbols.ATT_FIXED, DT_BOOLEAN, ATTIDX_FIXED, Boolean.FALSE);
		 allAttrs[ATT_FORM_N] = new OneAttr(SchemaSymbols.ATT_FORM, DT_FORM, ATTIDX_FORM, null);
		 allAttrs[ATT_ID_N] = new OneAttr(SchemaSymbols.ATT_ID, DT_ID, ATTIDX_ID, null);
		 allAttrs[ATT_ITEMTYPE_N] = new OneAttr(SchemaSymbols.ATT_ITEMTYPE, DT_QNAME, ATTIDX_ITEMTYPE, null);
		 allAttrs[ATT_MAXOCCURS_D] = new OneAttr(SchemaSymbols.ATT_MAXOCCURS, DT_MAXOCCURS, ATTIDX_MAXOCCURS, fXIntPool.getXInt(1));
		 allAttrs[ATT_MAXOCCURS1_D] = new OneAttr(SchemaSymbols.ATT_MAXOCCURS, DT_MAXOCCURS1, ATTIDX_MAXOCCURS, fXIntPool.getXInt(1));
		 allAttrs[ATT_MEMBER_T_N] = new OneAttr(SchemaSymbols.ATT_MEMBERTYPES, DT_MEMBERTYPES, ATTIDX_MEMBERTYPES, null);
		 allAttrs[ATT_MINOCCURS_D] = new OneAttr(SchemaSymbols.ATT_MINOCCURS, DT_NONNEGINT, ATTIDX_MINOCCURS, fXIntPool.getXInt(1));
		 allAttrs[ATT_MINOCCURS1_D] = new OneAttr(SchemaSymbols.ATT_MINOCCURS, DT_MINOCCURS1, ATTIDX_MINOCCURS, fXIntPool.getXInt(1));
		 allAttrs[ATT_MIXED_D] = new OneAttr(SchemaSymbols.ATT_MIXED, DT_BOOLEAN, ATTIDX_MIXED, Boolean.FALSE);
		 allAttrs[ATT_MIXED_N] = new OneAttr(SchemaSymbols.ATT_MIXED, DT_BOOLEAN, ATTIDX_MIXED, null);
		 allAttrs[ATT_NAME_R] = new OneAttr(SchemaSymbols.ATT_NAME, DT_NCNAME, ATTIDX_NAME, null);
		 allAttrs[ATT_NAMESPACE_D] = new OneAttr(SchemaSymbols.ATT_NAMESPACE, DT_NAMESPACE, ATTIDX_NAMESPACE, INT_ANY_ANY);
		 allAttrs[ATT_NAMESPACE_N] = new OneAttr(SchemaSymbols.ATT_NAMESPACE, DT_ANYURI, ATTIDX_NAMESPACE, null);
		 allAttrs[ATT_NILLABLE_D] = new OneAttr(SchemaSymbols.ATT_NILLABLE, DT_BOOLEAN, ATTIDX_NILLABLE, Boolean.FALSE);
		 allAttrs[ATT_PROCESS_C_D] = new OneAttr(SchemaSymbols.ATT_PROCESSCONTENTS, DT_PROCESSCONTENTS, ATTIDX_PROCESSCONTENTS, INT_ANY_STRICT);
		 allAttrs[ATT_PUBLIC_R] = new OneAttr(SchemaSymbols.ATT_PUBLIC, DT_TOKEN, ATTIDX_PUBLIC, null);
		 allAttrs[ATT_REF_R] = new OneAttr(SchemaSymbols.ATT_REF, DT_QNAME, ATTIDX_REF, null);
		 allAttrs[ATT_REFER_R] = new OneAttr(SchemaSymbols.ATT_REFER, DT_QNAME, ATTIDX_REFER, null);
		 allAttrs[ATT_SCHEMA_L_R] = new OneAttr(SchemaSymbols.ATT_SCHEMALOCATION, DT_ANYURI, ATTIDX_SCHEMALOCATION, null);
		 allAttrs[ATT_SCHEMA_L_N] = new OneAttr(SchemaSymbols.ATT_SCHEMALOCATION, DT_ANYURI, ATTIDX_SCHEMALOCATION, null);
		 allAttrs[ATT_SOURCE_N] = new OneAttr(SchemaSymbols.ATT_SOURCE, DT_ANYURI, ATTIDX_SOURCE, null);
		 allAttrs[ATT_SUBSTITUTION_G_N] = new OneAttr(SchemaSymbols.ATT_SUBSTITUTIONGROUP, DT_QNAME, ATTIDX_SUBSGROUP, null);
		 allAttrs[ATT_SYSTEM_N] = new OneAttr(SchemaSymbols.ATT_SYSTEM, DT_ANYURI, ATTIDX_SYSTEM, null);
		 allAttrs[ATT_TARGET_N_N] = new OneAttr(SchemaSymbols.ATT_TARGETNAMESPACE, DT_ANYURI, ATTIDX_TARGETNAMESPACE, null);
		 allAttrs[ATT_TYPE_N] = new OneAttr(SchemaSymbols.ATT_TYPE, DT_QNAME, ATTIDX_TYPE, null);
		 allAttrs[ATT_USE_D] = new OneAttr(SchemaSymbols.ATT_USE, DT_USE, ATTIDX_USE, INT_USE_OPTIONAL);
		 allAttrs[ATT_VALUE_NNI_N] = new OneAttr(SchemaSymbols.ATT_VALUE, DT_NONNEGINT, ATTIDX_VALUE, null);
		 allAttrs[ATT_VALUE_PI_N] = new OneAttr(SchemaSymbols.ATT_VALUE, DT_POSINT, ATTIDX_VALUE, null);
		 allAttrs[ATT_VALUE_STR_N] = new OneAttr(SchemaSymbols.ATT_VALUE, DT_STRING, ATTIDX_VALUE, null);
		 allAttrs[ATT_VALUE_WS_N] = new OneAttr(SchemaSymbols.ATT_VALUE, DT_WHITESPACE, ATTIDX_VALUE, null);
		 allAttrs[ATT_VERSION_N] = new OneAttr(SchemaSymbols.ATT_VERSION, DT_TOKEN, ATTIDX_VERSION, null);
		 allAttrs[ATT_XML_LANG] = new OneAttr(SchemaSymbols.ATT_XML_LANG, DT_LANGUAGE, ATTIDX_XML_LANG, null);
		 allAttrs[ATT_XPATH_R] = new OneAttr(SchemaSymbols.ATT_XPATH, DT_XPATH, ATTIDX_XPATH, null);
		 allAttrs[ATT_XPATH1_R] = new OneAttr(SchemaSymbols.ATT_XPATH, DT_XPATH1, ATTIDX_XPATH, null);
		 Container attrList;
		 attrList = Container.getContainer(5);
		 attrList.put(SchemaSymbols.ATT_DEFAULT, allAttrs[ATT_DEFAULT_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 attrList.put(SchemaSymbols.ATT_TYPE, allAttrs[ATT_TYPE_N]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_ATTRIBUTE, attrList);
		 attrList = Container.getContainer(7);
		 attrList.put(SchemaSymbols.ATT_DEFAULT, allAttrs[ATT_DEFAULT_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_N]);
		 attrList.put(SchemaSymbols.ATT_FORM, allAttrs[ATT_FORM_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 attrList.put(SchemaSymbols.ATT_TYPE, allAttrs[ATT_TYPE_N]);
		 attrList.put(SchemaSymbols.ATT_USE, allAttrs[ATT_USE_D]);
		 fEleAttrsMapL.put(ATTRIBUTE_N, attrList);
		 attrList = Container.getContainer(5);
		 attrList.put(SchemaSymbols.ATT_DEFAULT, allAttrs[ATT_DEFAULT_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_REF, allAttrs[ATT_REF_R]);
		 attrList.put(SchemaSymbols.ATT_USE, allAttrs[ATT_USE_D]);
		 fEleAttrsMapL.put(ATTRIBUTE_R, attrList);
		 attrList = Container.getContainer(10);
		 attrList.put(SchemaSymbols.ATT_ABSTRACT, allAttrs[ATT_ABSTRACT_D]);
		 attrList.put(SchemaSymbols.ATT_BLOCK, allAttrs[ATT_BLOCK_N]);
		 attrList.put(SchemaSymbols.ATT_DEFAULT, allAttrs[ATT_DEFAULT_N]);
		 attrList.put(SchemaSymbols.ATT_FINAL, allAttrs[ATT_FINAL_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 attrList.put(SchemaSymbols.ATT_NILLABLE, allAttrs[ATT_NILLABLE_D]);
		 attrList.put(SchemaSymbols.ATT_SUBSTITUTIONGROUP, allAttrs[ATT_SUBSTITUTION_G_N]);
		 attrList.put(SchemaSymbols.ATT_TYPE, allAttrs[ATT_TYPE_N]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_ELEMENT, attrList);
		 attrList = Container.getContainer(10);
		 attrList.put(SchemaSymbols.ATT_BLOCK, allAttrs[ATT_BLOCK_N]);
		 attrList.put(SchemaSymbols.ATT_DEFAULT, allAttrs[ATT_DEFAULT_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_N]);
		 attrList.put(SchemaSymbols.ATT_FORM, allAttrs[ATT_FORM_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MAXOCCURS, allAttrs[ATT_MAXOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_MINOCCURS, allAttrs[ATT_MINOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 attrList.put(SchemaSymbols.ATT_NILLABLE, allAttrs[ATT_NILLABLE_D]);
		 attrList.put(SchemaSymbols.ATT_TYPE, allAttrs[ATT_TYPE_N]);
		 fEleAttrsMapL.put(ELEMENT_N, attrList);
		 attrList = Container.getContainer(4);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MAXOCCURS, allAttrs[ATT_MAXOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_MINOCCURS, allAttrs[ATT_MINOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_REF, allAttrs[ATT_REF_R]);
		 fEleAttrsMapL.put(ELEMENT_R, attrList);
		 attrList = Container.getContainer(6);
		 attrList.put(SchemaSymbols.ATT_ABSTRACT, allAttrs[ATT_ABSTRACT_D]);
		 attrList.put(SchemaSymbols.ATT_BLOCK, allAttrs[ATT_BLOCK1_N]);
		 attrList.put(SchemaSymbols.ATT_FINAL, allAttrs[ATT_FINAL_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MIXED, allAttrs[ATT_MIXED_D]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_COMPLEXTYPE, attrList);
		 attrList = Container.getContainer(4);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 attrList.put(SchemaSymbols.ATT_PUBLIC, allAttrs[ATT_PUBLIC_R]);
		 attrList.put(SchemaSymbols.ATT_SYSTEM, allAttrs[ATT_SYSTEM_N]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_NOTATION, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MIXED, allAttrs[ATT_MIXED_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_COMPLEXTYPE, attrList);
		 attrList = Container.getContainer(1);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_SIMPLECONTENT, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_BASE, allAttrs[ATT_BASE_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_RESTRICTION, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_BASE, allAttrs[ATT_BASE_R]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_EXTENSION, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_REF, allAttrs[ATT_REF_R]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_ATTRIBUTEGROUP, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAMESPACE, allAttrs[ATT_NAMESPACE_D]);
		 attrList.put(SchemaSymbols.ATT_PROCESSCONTENTS, allAttrs[ATT_PROCESS_C_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_ANYATTRIBUTE, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MIXED, allAttrs[ATT_MIXED_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_COMPLEXCONTENT, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_ATTRIBUTEGROUP, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_GROUP, attrList);
		 attrList = Container.getContainer(4);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MAXOCCURS, allAttrs[ATT_MAXOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_MINOCCURS, allAttrs[ATT_MINOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_REF, allAttrs[ATT_REF_R]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_GROUP, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MAXOCCURS, allAttrs[ATT_MAXOCCURS1_D]);
		 attrList.put(SchemaSymbols.ATT_MINOCCURS, allAttrs[ATT_MINOCCURS1_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_ALL, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MAXOCCURS, allAttrs[ATT_MAXOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_MINOCCURS, allAttrs[ATT_MINOCCURS_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_CHOICE, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_SEQUENCE, attrList);
		 attrList = Container.getContainer(5);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MAXOCCURS, allAttrs[ATT_MAXOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_MINOCCURS, allAttrs[ATT_MINOCCURS_D]);
		 attrList.put(SchemaSymbols.ATT_NAMESPACE, allAttrs[ATT_NAMESPACE_D]);
		 attrList.put(SchemaSymbols.ATT_PROCESSCONTENTS, allAttrs[ATT_PROCESS_C_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_ANY, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_UNIQUE, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_KEY, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 attrList.put(SchemaSymbols.ATT_REFER, allAttrs[ATT_REFER_R]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_KEYREF, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_XPATH, allAttrs[ATT_XPATH_R]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_SELECTOR, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_XPATH, allAttrs[ATT_XPATH1_R]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_FIELD, attrList);
		 attrList = Container.getContainer(1);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_ANNOTATION, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_ANNOTATION, attrList);
		 attrList = Container.getContainer(1);
		 attrList.put(SchemaSymbols.ATT_SOURCE, allAttrs[ATT_SOURCE_N]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_APPINFO, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_APPINFO, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_SOURCE, allAttrs[ATT_SOURCE_N]);
		 attrList.put(SchemaSymbols.ATT_XML_LANG, allAttrs[ATT_XML_LANG]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_DOCUMENTATION, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_DOCUMENTATION, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_FINAL, allAttrs[ATT_FINAL1_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAME, allAttrs[ATT_NAME_R]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_SIMPLETYPE, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_FINAL, allAttrs[ATT_FINAL1_N]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_SIMPLETYPE, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_ITEMTYPE, allAttrs[ATT_ITEMTYPE_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_LIST, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_MEMBERTYPES, allAttrs[ATT_MEMBER_T_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_UNION, attrList);
		 attrList = Container.getContainer(8);
		 attrList.put(SchemaSymbols.ATT_ATTRIBUTEFORMDEFAULT, allAttrs[ATT_ATTRIBUTE_FD_D]);
		 attrList.put(SchemaSymbols.ATT_BLOCKDEFAULT, allAttrs[ATT_BLOCK_D_D]);
		 attrList.put(SchemaSymbols.ATT_ELEMENTFORMDEFAULT, allAttrs[ATT_ELEMENT_FD_D]);
		 attrList.put(SchemaSymbols.ATT_FINALDEFAULT, allAttrs[ATT_FINAL_D_D]);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_TARGETNAMESPACE, allAttrs[ATT_TARGET_N_N]);
		 attrList.put(SchemaSymbols.ATT_VERSION, allAttrs[ATT_VERSION_N]);
		 attrList.put(SchemaSymbols.ATT_XML_LANG, allAttrs[ATT_XML_LANG]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_SCHEMA, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_SCHEMALOCATION, allAttrs[ATT_SCHEMA_L_R]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_INCLUDE, attrList);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_REDEFINE, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_NAMESPACE, allAttrs[ATT_NAMESPACE_N]);
		 attrList.put(SchemaSymbols.ATT_SCHEMALOCATION, allAttrs[ATT_SCHEMA_L_N]);
		 fEleAttrsMapG.put(SchemaSymbols.ELT_IMPORT, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_VALUE, allAttrs[ATT_VALUE_NNI_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_LENGTH, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_MINLENGTH, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_MAXLENGTH, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_FRACTIONDIGITS, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_VALUE, allAttrs[ATT_VALUE_PI_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_TOTALDIGITS, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_VALUE, allAttrs[ATT_VALUE_STR_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_PATTERN, attrList);
		 attrList = Container.getContainer(2);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_VALUE, allAttrs[ATT_VALUE_STR_N]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_ENUMERATION, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_VALUE, allAttrs[ATT_VALUE_WS_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_WHITESPACE, attrList);
		 attrList = Container.getContainer(3);
		 attrList.put(SchemaSymbols.ATT_ID, allAttrs[ATT_ID_N]);
		 attrList.put(SchemaSymbols.ATT_VALUE, allAttrs[ATT_VALUE_STR_N]);
		 attrList.put(SchemaSymbols.ATT_FIXED, allAttrs[ATT_FIXED_D]);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_MAXINCLUSIVE, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_MAXEXCLUSIVE, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_MININCLUSIVE, attrList);
		 fEleAttrsMapL.put(SchemaSymbols.ELT_MINEXCLUSIVE, attrList);
	 }
	 protected XSDHandler fSchemaHandler = null;
	 protected SymbolTable fSymbolTable = null;
	 protected Hashtable fNonSchemaAttrs = new Hashtable();
	 protected Vector fNamespaceList = new Vector();
	 protected boolean[] fSeen = new boolean[ATTIDX_COUNT];
	 private static boolean[] fSeenTemp = new boolean[ATTIDX_COUNT];
	 public XSAttributeChecker(XSDHandler schemaHandler) {
		 fSchemaHandler = schemaHandler;
	 }
	 public void reset(SymbolTable symbolTable) {
		 fSymbolTable = symbolTable;
		 fNonSchemaAttrs.clear();
	 }
	 public Object[] checkAttributes(Element element, boolean isGlobal, XSDocumentInfo schemaDoc) {
		 return checkAttributes(element, isGlobal, schemaDoc, false);
	 }
	 public Object[] checkAttributes(Element element, boolean isGlobal, XSDocumentInfo schemaDoc, boolean enumAsQName) {
		 if (element == null) return null;
		 Attr[] attrs = DOMUtil.getAttrs(element);
		 resolveNamespace(element, attrs, schemaDoc.fNamespaceSupport);
		 String uri = DOMUtil.getNamespaceURI(element);
		 String elName = DOMUtil.getLocalName(element);
		 if (!SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(uri)) {
			 reportSchemaError(""s4s-elt-schema-ns"", new Object[] {
			elName}
			, element);
		 }
		 Hashtable eleAttrsMap = fEleAttrsMapG;
		 String lookupName = elName;
		 if (!isGlobal) {
			 eleAttrsMap = fEleAttrsMapL;
			 if (elName.equals(SchemaSymbols.ELT_ELEMENT)) {
				 if (DOMUtil.getAttr(element, SchemaSymbols.ATT_REF) != null) lookupName = ELEMENT_R;
				 else lookupName = ELEMENT_N;
			 }
			 else if (elName.equals(SchemaSymbols.ELT_ATTRIBUTE)) {
				 if (DOMUtil.getAttr(element, SchemaSymbols.ATT_REF) != null) lookupName = ATTRIBUTE_R;
				 else lookupName = ATTRIBUTE_N;
			 }
		 }
		 Container attrList = (Container)eleAttrsMap.get(lookupName);
		 if (attrList == null) {
			 reportSchemaError (""s4s-elt-invalid"", new Object[] {
			elName}
			, element);
			 return null;
		 }
		 Object[] attrValues = getAvailableArray();
		 long fromDefault = 0;
		 System.arraycopy(fSeenTemp, 0, fSeen, 0, ATTIDX_COUNT);
		 int length = attrs.length;
		 Attr sattr = null;
		 for (int i = 0;
		 i < length;
		 i++) {
			 sattr = attrs[i];
			 String attrName = sattr.getName();
			 String attrURI = DOMUtil.getNamespaceURI(sattr);
			 String attrVal = DOMUtil.getValue(sattr);
			 if (attrName.startsWith(""xml"")) {
				 String attrPrefix = DOMUtil.getPrefix(sattr);
				 if (""xmlns"".equals(attrPrefix) || ""xmlns"".equals(attrName)) {
					 continue;
				 }
				 else if (SchemaSymbols.ATT_XML_LANG.equals(attrName) && (SchemaSymbols.ELT_SCHEMA.equals(elName) || SchemaSymbols.ELT_DOCUMENTATION.equals(elName))) {
					 attrURI = null;
				 }
			 }
			 if (attrURI != null && attrURI.length() != 0) {
				 if (attrURI.equals(SchemaSymbols.URI_SCHEMAFORSCHEMA)) {
					 reportSchemaError (""s4s-att-not-allowed"", new Object[] {
					elName, attrName}
					, element);
				 }
				 else {
					 if(attrValues[ATTIDX_NONSCHEMA] == null) {
						 attrValues[ATTIDX_NONSCHEMA] = new Vector(4,2);
					 }
					 ((Vector)attrValues[ATTIDX_NONSCHEMA]).addElement(attrName);
					 ((Vector)attrValues[ATTIDX_NONSCHEMA]).addElement(attrVal);
				 }
				 continue;
			 }
			 OneAttr oneAttr = attrList.get(attrName);
			 if (oneAttr == null) {
				 reportSchemaError (""s4s-att-not-allowed"", new Object[] {
				elName, attrName}
				, element);
				 continue;
			 }
			 fSeen[oneAttr.valueIndex] = true;
			 try {
				 if (oneAttr.dvIndex >= 0) {
					 if (oneAttr.dvIndex != DT_STRING && oneAttr.dvIndex != DT_XPATH && oneAttr.dvIndex != DT_XPATH1) {
						 XSSimpleType dv = fExtraDVs[oneAttr.dvIndex];
						 Object avalue = dv.validate(attrVal, schemaDoc.fValidationContext, null);
						 if (oneAttr.dvIndex == DT_QNAME) {
							 QName qname = (QName)avalue;
							 if(qname.prefix == XMLSymbols.EMPTY_STRING && qname.uri == null && schemaDoc.fIsChameleonSchema) qname.uri = schemaDoc.fTargetNamespace;
						 }
						 attrValues[oneAttr.valueIndex] = avalue;
					 }
					 else {
						 attrValues[oneAttr.valueIndex] = attrVal;
					 }
				 }
				 else {
					 attrValues[oneAttr.valueIndex] = validate(attrValues, attrName, attrVal, oneAttr.dvIndex, schemaDoc);
				 }
			 }
			 catch (InvalidDatatypeValueException ide) {
				 reportSchemaError (""s4s-att-invalid-value"", new Object[] {
				elName, attrName, ide.getMessage()}
				, element);
				 if (oneAttr.dfltValue != null) attrValues[oneAttr.valueIndex] = oneAttr.dfltValue;
			 }
			 if (elName.equals(SchemaSymbols.ELT_ENUMERATION) && enumAsQName) {
				 attrValues[ATTIDX_ENUMNSDECLS] = new SchemaNamespaceSupport(schemaDoc.fNamespaceSupport);
			 }
		 }
		 OneAttr[] reqAttrs = attrList.values;
		 for (int i = 0;
		 i < reqAttrs.length;
		 i++) {
			 OneAttr oneAttr = reqAttrs[i];
			 if (oneAttr.dfltValue != null && !fSeen[oneAttr.valueIndex]) {
				 attrValues[oneAttr.valueIndex] = oneAttr.dfltValue;
				 fromDefault |= (1<<oneAttr.valueIndex);
			 }
		 }
		 attrValues[ATTIDX_FROMDEFAULT] = new Long(fromDefault);
		 if (attrValues[ATTIDX_MAXOCCURS] != null) {
			 int min = ((XInt)attrValues[ATTIDX_MINOCCURS]).intValue();
			 int max = ((XInt)attrValues[ATTIDX_MAXOCCURS]).intValue();
			 if (max != SchemaSymbols.OCCURRENCE_UNBOUNDED) {
				 if (min > max) {
					 reportSchemaError (""p-props-correct.2.1"", new Object[] {
					elName, attrValues[ATTIDX_MINOCCURS], attrValues[ATTIDX_MAXOCCURS]}
					, element);
					 attrValues[ATTIDX_MINOCCURS] = attrValues[ATTIDX_MAXOCCURS];
				 }
			 }
		 }
		 return attrValues;
	 }
	 private Object validate(Object[] attrValues, String attr, String ivalue, int dvIndex, XSDocumentInfo schemaDoc) throws InvalidDatatypeValueException {
		 if (ivalue == null) return null;
		 String value = XMLChar.trim(ivalue);
		 Object retValue = null;
		 Vector memberType;
		 int choice;
		 switch (dvIndex) {
			 case DT_BOOLEAN: if (value.equals(SchemaSymbols.ATTVAL_FALSE) || value.equals(SchemaSymbols.ATTVAL_FALSE_0)) {
				 retValue = Boolean.FALSE;
			 }
			 else if (value.equals(SchemaSymbols.ATTVAL_TRUE) || value.equals(SchemaSymbols.ATTVAL_TRUE_1)) {
				 retValue = Boolean.TRUE;
			 }
			 else {
				 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.1"", new Object[]{
				value, ""boolean""}
				);
			 }
			 break;
			 case DT_NONNEGINT: try {
				 if (value.length() > 0 && value.charAt(0) == '+') value = value.substring(1);
				 retValue = fXIntPool.getXInt(Integer.parseInt(value));
			 }
			 catch (NumberFormatException e) {
				 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.1"", new Object[]{
				value, ""nonNegativeInteger""}
				);
			 }
			 if (((XInt)retValue).intValue() < 0) throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.1"", new Object[]{
			value, ""nonNegativeInteger""}
			);
			 break;
			 case DT_POSINT: try {
				 if (value.length() > 0 && value.charAt(0) == '+') value = value.substring(1);
				 retValue = fXIntPool.getXInt(Integer.parseInt(value));
			 }
			 catch (NumberFormatException e) {
				 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.1"", new Object[]{
				value, ""positiveInteger""}
				);
			 }
			 if (((XInt)retValue).intValue() <= 0) throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.1"", new Object[]{
			value, ""positiveInteger""}
			);
			 break;
			 case DT_BLOCK: choice = 0;
			 if (value.equals (SchemaSymbols.ATTVAL_POUNDALL)) {
				 choice = XSConstants.DERIVATION_SUBSTITUTION|XSConstants.DERIVATION_EXTENSION| XSConstants.DERIVATION_RESTRICTION|XSConstants.DERIVATION_LIST| XSConstants.DERIVATION_UNION;
			 }
			 else {
				 StringTokenizer t = new StringTokenizer(value, "" \n\t\r"");
				 while (t.hasMoreTokens()) {
					 String token = t.nextToken ();
					 if (token.equals (SchemaSymbols.ATTVAL_EXTENSION)) {
						 choice |= XSConstants.DERIVATION_EXTENSION;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_RESTRICTION)) {
						 choice |= XSConstants.DERIVATION_RESTRICTION;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_SUBSTITUTION)) {
						 choice |= XSConstants.DERIVATION_SUBSTITUTION;
					 }
					 else {
						 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.3"", new Object[]{
						value, ""(#all | List of (extension | restriction | substitution))""}
						);
					 }
				 }
			 }
			 retValue = fXIntPool.getXInt(choice);
			 break;
			 case DT_BLOCK1: case DT_FINAL: choice = 0;
			 if (value.equals (SchemaSymbols.ATTVAL_POUNDALL)) {
				 choice = XSConstants.DERIVATION_SUBSTITUTION|XSConstants.DERIVATION_EXTENSION| XSConstants.DERIVATION_RESTRICTION|XSConstants.DERIVATION_LIST| XSConstants.DERIVATION_UNION;
			 }
			 else {
				 StringTokenizer t = new StringTokenizer(value, "" \n\t\r"");
				 while (t.hasMoreTokens()) {
					 String token = t.nextToken ();
					 if (token.equals (SchemaSymbols.ATTVAL_EXTENSION)) {
						 choice |= XSConstants.DERIVATION_EXTENSION;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_RESTRICTION)) {
						 choice |= XSConstants.DERIVATION_RESTRICTION;
					 }
					 else {
						 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.3"", new Object[]{
						value, ""(#all | List of (extension | restriction))""}
						);
					 }
				 }
			 }
			 retValue = fXIntPool.getXInt(choice);
			 break;
			 case DT_FINAL1: choice = 0;
			 if (value.equals (SchemaSymbols.ATTVAL_POUNDALL)) {
				 choice = XSConstants.DERIVATION_SUBSTITUTION|XSConstants.DERIVATION_EXTENSION| XSConstants.DERIVATION_RESTRICTION|XSConstants.DERIVATION_LIST| XSConstants.DERIVATION_UNION;
			 }
			 else {
				 StringTokenizer t = new StringTokenizer(value, "" \n\t\r"");
				 while (t.hasMoreTokens()) {
					 String token = t.nextToken ();
					 if (token.equals (SchemaSymbols.ATTVAL_LIST)) {
						 choice |= XSConstants.DERIVATION_LIST;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_UNION)) {
						 choice |= XSConstants.DERIVATION_UNION;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_RESTRICTION)) {
						 choice |= XSConstants.DERIVATION_RESTRICTION;
					 }
					 else {
						 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.3"", new Object[]{
						value, ""(#all | List of (list | union | restriction))""}
						);
					 }
				 }
			 }
			 retValue = fXIntPool.getXInt(choice);
			 break;
			 case DT_FINAL2: choice = 0;
			 if (value.equals (SchemaSymbols.ATTVAL_POUNDALL)) {
				 choice = XSConstants.DERIVATION_SUBSTITUTION|XSConstants.DERIVATION_EXTENSION| XSConstants.DERIVATION_RESTRICTION|XSConstants.DERIVATION_LIST| XSConstants.DERIVATION_UNION;
			 }
			 else {
				 StringTokenizer t = new StringTokenizer(value, "" \n\t\r"");
				 while (t.hasMoreTokens()) {
					 String token = t.nextToken ();
					 if (token.equals (SchemaSymbols.ATTVAL_EXTENSION)) {
						 choice |= XSConstants.DERIVATION_EXTENSION;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_RESTRICTION)) {
						 choice |= XSConstants.DERIVATION_RESTRICTION;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_LIST)) {
						 choice |= XSConstants.DERIVATION_LIST;
					 }
					 else if (token.equals (SchemaSymbols.ATTVAL_UNION)) {
						 choice |= XSConstants.DERIVATION_UNION;
					 }
					 else {
						 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.3"", new Object[]{
						value, ""(#all | List of (extension | restriction | list | union))""}
						);
					 }
				 }
			 }
			 retValue = fXIntPool.getXInt(choice);
			 break;
			 case DT_FORM: if (value.equals (SchemaSymbols.ATTVAL_QUALIFIED)) retValue = INT_QUALIFIED;
			 else if (value.equals (SchemaSymbols.ATTVAL_UNQUALIFIED)) retValue = INT_UNQUALIFIED;
			 else throw new InvalidDatatypeValueException(""cvc-enumeration-valid"", new Object[]{
			value, ""(qualified | unqualified)""}
			);
			 break;
			 case DT_MAXOCCURS: if (value.equals(SchemaSymbols.ATTVAL_UNBOUNDED)) {
				 retValue = INT_UNBOUNDED;
			 }
			 else {
				 try {
					 retValue = validate(attrValues, attr, value, DT_NONNEGINT, schemaDoc);
				 }
				 catch (NumberFormatException e) {
					 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.3"", new Object[]{
					value, ""(nonNegativeInteger | unbounded)""}
					);
				 }
			 }
			 break;
			 case DT_MAXOCCURS1: if (value.equals(""1"")) retValue = fXIntPool.getXInt(1);
			 else throw new InvalidDatatypeValueException(""cvc-enumeration-valid"", new Object[]{
			value, ""(1)""}
			);
			 break;
			 case DT_MEMBERTYPES: memberType = new Vector();
			 try {
				 StringTokenizer t = new StringTokenizer(value, "" \n\t\r"");
				 while (t.hasMoreTokens()) {
					 String token = t.nextToken ();
					 QName qname = (QName)fExtraDVs[DT_QNAME].validate(token, schemaDoc.fValidationContext, null);
					 if(qname.prefix == XMLSymbols.EMPTY_STRING && qname.uri == null && schemaDoc.fIsChameleonSchema) qname.uri = schemaDoc.fTargetNamespace;
					 memberType.addElement(qname);
				 }
				 retValue = memberType;
			 }
			 catch (InvalidDatatypeValueException ide) {
				 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.2"", new Object[]{
				value, ""(List of QName)""}
				);
			 }
			 break;
			 case DT_MINOCCURS1: if (value.equals(""0"")) retValue = fXIntPool.getXInt(0);
			 else if (value.equals(""1"")) retValue = fXIntPool.getXInt(1);
			 else throw new InvalidDatatypeValueException(""cvc-enumeration-valid"", new Object[]{
			value, ""(0 | 1)""}
			);
			 break;
			 case DT_NAMESPACE: if (value.equals(SchemaSymbols.ATTVAL_TWOPOUNDANY)) {
				 retValue = INT_ANY_ANY;
			 }
			 else if (value.equals(SchemaSymbols.ATTVAL_TWOPOUNDOTHER)) {
				 retValue = INT_ANY_NOT;
				 String[] list = new String[2];
				 list[0] = schemaDoc.fTargetNamespace;
				 list[1] = null;
				 attrValues[ATTIDX_NAMESPACE_LIST] = list;
			 }
			 else {
				 retValue = INT_ANY_LIST;
				 fNamespaceList.removeAllElements();
				 StringTokenizer tokens = new StringTokenizer(value, "" \n\t\r"");
				 String token;
				 String tempNamespace;
				 try {
					 while (tokens.hasMoreTokens()) {
						 token = tokens.nextToken();
						 if (token.equals(SchemaSymbols.ATTVAL_TWOPOUNDLOCAL)) {
							 tempNamespace = null;
						 }
						 else if (token.equals(SchemaSymbols.ATTVAL_TWOPOUNDTARGETNS)) {
							 tempNamespace = schemaDoc.fTargetNamespace;
						 }
						 else {
							 fExtraDVs[DT_ANYURI].validate(token, schemaDoc.fValidationContext, null);
							 tempNamespace = fSymbolTable.addSymbol(token);
						 }
						 if (!fNamespaceList.contains(tempNamespace)) {
							 fNamespaceList.addElement(tempNamespace);
						 }
					 }
				 }
				 catch (InvalidDatatypeValueException ide) {
					 throw new InvalidDatatypeValueException(""cvc-datatype-valid.1.2.3"", new Object[]{
					value, ""((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )""}
					);
				 }
				 int num = fNamespaceList.size();
				 String[] list = new String[num];
				 fNamespaceList.copyInto(list);
				 attrValues[ATTIDX_NAMESPACE_LIST] = list;
			 }
			 break;
			 case DT_PROCESSCONTENTS: if (value.equals (SchemaSymbols.ATTVAL_STRICT)) retValue = INT_ANY_STRICT;
			 else if (value.equals (SchemaSymbols.ATTVAL_LAX)) retValue = INT_ANY_LAX;
			 else if (value.equals (SchemaSymbols.ATTVAL_SKIP)) retValue = INT_ANY_SKIP;
			 else throw new InvalidDatatypeValueException(""cvc-enumeration-valid"", new Object[]{
			value, ""(lax | skip | strict)""}
			);
			 break;
			 case DT_USE: if (value.equals (SchemaSymbols.ATTVAL_OPTIONAL)) retValue = INT_USE_OPTIONAL;
			 else if (value.equals (SchemaSymbols.ATTVAL_REQUIRED)) retValue = INT_USE_REQUIRED;
			 else if (value.equals (SchemaSymbols.ATTVAL_PROHIBITED)) retValue = INT_USE_PROHIBITED;
			 else throw new InvalidDatatypeValueException(""cvc-enumeration-valid"", new Object[]{
			value, ""(optional | prohibited | required)""}
			);
			 break;
			 case DT_WHITESPACE: if (value.equals (SchemaSymbols.ATTVAL_PRESERVE)) retValue = INT_WS_PRESERVE;
			 else if (value.equals (SchemaSymbols.ATTVAL_REPLACE)) retValue = INT_WS_REPLACE;
			 else if (value.equals (SchemaSymbols.ATTVAL_COLLAPSE)) retValue = INT_WS_COLLAPSE;
			 else throw new InvalidDatatypeValueException(""cvc-enumeration-valid"", new Object[]{
			value, ""(preserve | replace | collapse)""}
			);
			 break;
		 }
		 return retValue;
	 }
	 void reportSchemaError (String key, Object[] args, Element ele) {
		 fSchemaHandler.reportSchemaError(key, args, ele);
	 }
	 public void checkNonSchemaAttributes(XSGrammarBucket grammarBucket) {
		 Iterator entries = fNonSchemaAttrs.entrySet().iterator();
		 XSAttributeDecl attrDecl;
		 while (entries.hasNext()) {
			 Map.Entry entry = (Map.Entry) entries.next();
			 String attrRName = (String) entry.getKey();
			 String attrURI = attrRName.substring(0,attrRName.indexOf(','));
			 String attrLocal = attrRName.substring(attrRName.indexOf(',')+1);
			 SchemaGrammar sGrammar = grammarBucket.getGrammar(attrURI);
			 if (sGrammar == null) {
				 continue;
			 }
			 attrDecl = sGrammar.getGlobalAttributeDecl(attrLocal);
			 if (attrDecl == null) {
				 continue;
			 }
			 XSSimpleType dv = (XSSimpleType)attrDecl.getTypeDefinition();
			 if (dv == null) {
				 continue;
			 }
			 Vector values = (Vector) entry.getValue();
			 String elName;
			 String attrName = (String)values.elementAt(0);
			 int count = values.size();
			 for (int i = 1;
			 i < count;
			 i += 2) {
				 elName = (String)values.elementAt(i);
				 try {
					 dv.validate((String)values.elementAt(i+1), null, null);
				 }
				 catch(InvalidDatatypeValueException ide) {
					 reportSchemaError (""s4s-att-invalid-value"", new Object[] {
					elName, attrName, ide.getMessage()}
					, null);
				 }
			 }
		 }
	 }
	 public static String normalize(String content, short ws) {
		 int len = content == null ? 0 : content.length();
		 if (len == 0 || ws == XSSimpleType.WS_PRESERVE) return content;
		 StringBuffer sb = new StringBuffer();
		 if (ws == XSSimpleType.WS_REPLACE) {
			 char ch;
			 for (int i = 0;
			 i < len;
			 i++) {
				 ch = content.charAt(i);
				 if (ch != 0x9 && ch != 0xa && ch != 0xd) sb.append(ch);
				 else sb.append((char)0x20);
			 }
		 }
		 else {
			 char ch;
			 int i;
			 boolean isLeading = true;
			 for (i = 0;
			 i < len;
			 i++) {
				 ch = content.charAt(i);
				 if (ch != 0x9 && ch != 0xa && ch != 0xd && ch != 0x20) {
					 sb.append(ch);
					 isLeading = false;
				 }
				 else {
					 for (;
					 i < len-1;
					 i++) {
						 ch = content.charAt(i+1);
						 if (ch != 0x9 && ch != 0xa && ch != 0xd && ch != 0x20) break;
					 }
					 if (i < len - 1 && !isLeading) sb.append((char)0x20);
				 }
			 }
		 }
		 return sb.toString();
	 }
	 static final int INIT_POOL_SIZE = 10;
	 static final int INC_POOL_SIZE = 10;
	 Object[][] fArrayPool = new Object[INIT_POOL_SIZE][ATTIDX_COUNT];
	 private static Object[] fTempArray = new Object[ATTIDX_COUNT];
	 int fPoolPos = 0;
	 protected Object[] getAvailableArray() {
		 if (fArrayPool.length == fPoolPos) {
			 fArrayPool = new Object[fPoolPos+INC_POOL_SIZE][];
			 for (int i = fPoolPos;
			 i < fArrayPool.length;
			 i++) fArrayPool[i] = new Object[ATTIDX_COUNT];
		 }
		 Object[] retArray = fArrayPool[fPoolPos];
		 fArrayPool[fPoolPos++] = null;
		 System.arraycopy(fTempArray, 0, retArray, 0, ATTIDX_COUNT-1);
		 retArray[ATTIDX_ISRETURNED] = Boolean.FALSE;
		 return retArray;
	 }
	 public void returnAttrArray(Object[] attrArray, XSDocumentInfo schemaDoc) {
		 if (schemaDoc != null) schemaDoc.fNamespaceSupport.popContext();
		 if (fPoolPos == 0 || attrArray == null || attrArray.length != ATTIDX_COUNT || ((Boolean)attrArray[ATTIDX_ISRETURNED]).booleanValue()) {
			 return;
		 }
		 attrArray[ATTIDX_ISRETURNED] = Boolean.TRUE;
		 if(attrArray[ATTIDX_NONSCHEMA] != null) ((Vector)attrArray[ATTIDX_NONSCHEMA]).clear();
		 fArrayPool[--fPoolPos] = attrArray;
	 }
	 public void resolveNamespace(Element element, Attr[] attrs, SchemaNamespaceSupport nsSupport) {
		 nsSupport.pushContext();
		 int length = attrs.length;
		 Attr sattr = null;
		 String rawname, prefix, uri;
		 for (int i = 0;
		 i < length;
		 i++) {
			 sattr = attrs[i];
			 rawname = DOMUtil.getName(sattr);
			 prefix = null;
			 if (rawname.equals(XMLSymbols.PREFIX_XMLNS)) prefix = XMLSymbols.EMPTY_STRING;
			 else if (rawname.startsWith(""xmlns:"")) prefix = fSymbolTable.addSymbol(DOMUtil.getLocalName(sattr));
			 if (prefix != null) {
				 uri = fSymbolTable.addSymbol(DOMUtil.getValue(sattr));
				 nsSupport.declarePrefix(prefix, uri.length()!=0 ? uri : null);
			 }
		 }
	 }
}
class OneAttr {
	 public String name;
	 public int dvIndex;
	 public int valueIndex;
	 public Object dfltValue;
	 public OneAttr(String name, int dvIndex, int valueIndex, Object dfltValue) {
		 this.name = name;
		 this.dvIndex = dvIndex;
		 this.valueIndex = valueIndex;
		 this.dfltValue = dfltValue;
	 }
}
abstract class Container {
	 static final int THRESHOLD = 5;
	 static Container getContainer(int size) {
		 if (size > THRESHOLD) return new LargeContainer(size);
		 else return new SmallContainer(size);
	 }
	 abstract void put(String key, OneAttr value);
	 abstract OneAttr get(String key);
	 OneAttr[] values;
	 int pos = 0;
}
class SmallContainer extends Container {
	 String[] keys;
	 SmallContainer(int size) {
		 keys = new String[size];
		 values = new OneAttr[size];
	 }
	 void put(String key, OneAttr value) {
		 keys[pos] = key;
		 values[pos++] = value;
	 }
	 OneAttr get(String key) {
		 for (int i = 0;
		 i < pos;
		 i++) {
			 if (keys[i].equals(key)) {
				 return values[i];
			 }
		 }
		 return null;
	 }
}
class LargeContainer extends Container {
	 Hashtable items;
	 LargeContainer(int size) {
		 items = new Hashtable(size*2+1);
		 values = new OneAttr[size];
	 }
	 void put(String key, OneAttr value) {
		 items.put(key, value);
		 values[pos++] = value;
	 }
	 OneAttr get(String key) {
		 OneAttr ret = (OneAttr)items.get(key);
		 return ret;
	 }
}",1,0,0,0
"public class Raytracer implements Renderer, Runnable{
	 protected RTObject sceneObject[];
	 protected RTLight light[];
	 protected OctreeNode rootNode, cameraNode, lightNode[];
	 protected ColumnContainer configPanel;
	 protected BCheckBox depthBox, glossBox, shadowBox, causticsBox, transparentBox, hdrBox, adaptiveBox, rouletteBox, reducedMemoryBox;
	 protected BComboBox aliasChoice, maxRaysChoice, minRaysChoice, giModeChoice, scatterModeChoice, diffuseRaysChoice;
	 protected ValueField errorField, rayDepthField, rayCutoffField, smoothField, stepSizeField;
	 protected ValueField extraGIField, extraGIEnvField;
	 protected ValueField globalPhotonsField, globalNeighborPhotonsField, causticsPhotonsField, causticsNeighborPhotonsField, volumePhotonsField, volumeNeighborPhotonsField;
	 protected int pixel[], width, height, rtWidth, rtHeight, maxRayDepth = 8, minRays = 4, maxRays = 16, diffuseRays, antialiasLevel;
	 protected MemoryImageSource imageSource;
	 protected Scene theScene;
	 protected Camera theCamera;
	 protected SceneCamera sceneCamera;
	 protected RenderListener listener;
	 protected Image img;
	 protected volatile Thread renderThread;
	 protected RGBColor ambColor, envColor, fogColor;
	 protected double envParamValue[];
	 protected TextureMapping envMapping;
	 protected int envMode;
	 protected double time, fogDist, surfaceError = 0.02, stepSize = 1.0;
	 protected double smoothing = 1.0, smoothScale, extraGISmoothing = 10.0, extraGIEnvSmoothing = 100.0;
	 protected int giMode = GI_NONE, scatterMode = SCATTER_SINGLE, globalPhotons = 10000, globalNeighborPhotons = 200, causticsPhotons = 10000, causticsNeighborPhotons = 100, volumePhotons = 10000, volumeNeighborPhotons = 100;
	 protected float minRayIntensity = 0.01f, floatImage[][], depthImage[], errorImage[], objectImage[];
	 protected boolean fog, depth = false, gloss = false, penumbra = false, caustics = false, transparentBackground = false, generateHDR = true, adaptive = true, roulette = false, reducedMemory = false;
	 protected boolean needCopyToUI = true;
	 protected PhotonMap globalMap, causticsMap, volumeMap;
	 protected BoundingBox materialBounds;
	 protected ThreadLocal threadContext;
	 public static final double TOL = 1e-12;
	 public static final int GI_NONE = 0;
	 public static final int GI_AMBIENT_OCCLUSION = 1;
	 public static final int GI_MONTE_CARLO = 2;
	 public static final int GI_PHOTON = 3;
	 public static final int GI_HYBRID = 4;
	 public static final int SCATTER_SINGLE = 0;
	 public static final int SCATTER_PHOTONS = 1;
	 public static final int SCATTER_BOTH = 2;
	 public static final float COLOR_THRESH_ABS = 1.0f/128.0f;
	 public static final float COLOR_THRESH_REL = 1.0f/32.0f;
	 public static final int distrib1[] = {
	0, 3, 1, 2, 1, 2, 0, 3, 2, 0, 3, 1, 3, 1, 2, 0}
	;
	 public static final int distrib2[] = {
	0, 1, 2, 3, 3, 0, 1, 2, 1, 2, 3, 0, 0, 1, 2, 3}
	;
	 public static class RayIntersection {
		 public RTObject first, second;
		 public double dist;
		 public RayIntersection() {
		 }
	 }
	 public static class MaterialIntersection {
		 public MaterialMapping mat;
		 public Mat4 toLocal;
		 public double dist;
		 public boolean entered;
		 public OctreeNode node;
		 public MaterialIntersection() {
		 }
	 }
	 public Raytracer() {
		 threadContext = new ThreadLocal() {
			 protected Object initialValue() {
				 return new RaytracerContext(Raytracer.this);
			 }
		 }
		;
	 }
	 public String getName() {
		 return ""Raytracer"";
	 }
	 public synchronized void renderScene(Scene theScene, Camera theCamera, RenderListener rl, SceneCamera sceneCamera) {
		 Dimension dim = theCamera.getSize();
		 listener = rl;
		 this.theScene = theScene;
		 this.theCamera = theCamera;
		 if (sceneCamera == null) {
			 sceneCamera = new SceneCamera();
			 sceneCamera.setDepthOfField(0.0);
			 sceneCamera.setFocalDistance(theCamera.getDistToScreen());
		 }
		 this.sceneCamera = sceneCamera;
		 time = theScene.getTime();
		 width = dim.width;
		 height = dim.height;
		 pixel = new int [width*height];
		 imageSource = new MemoryImageSource(width, height, pixel, 0, width);
		 imageSource.setAnimated(true);
		 img = Toolkit.getDefaultToolkit().createImage(imageSource);
		 int requiredComponents = sceneCamera.getComponentsForFilters();
		 if (generateHDR || (requiredComponents&(ComplexImage.RED+ComplexImage.GREEN+ComplexImage.BLUE)) != 0) floatImage = new float [4][width*height];
		 if ((requiredComponents&ComplexImage.DEPTH) != 0) depthImage = new float [width*height];
		 if ((requiredComponents&ComplexImage.NOISE) != 0) errorImage = new float [width*height];
		 if ((requiredComponents&ComplexImage.OBJECT) != 0) objectImage = new float [width*height];
		 renderThread = new Thread(this, ""Raytracer main thread"");
		 renderThread.setPriority(Thread.NORM_PRIORITY);
		 renderThread.start();
	 }
	 public synchronized void cancelRendering(Scene sc) {
		 Thread t = renderThread;
		 if (theScene != sc) return;
		 renderThread = null;
		 if (t == null) return;
		 try {
			 while (t.isAlive()) {
				 Thread.sleep(100);
			 }
		 }
		 catch (InterruptedException ex) {
		 }
		 RenderListener rl = listener;
		 listener = null;
		 if (rl != null) rl.renderingCanceled();
		 finish();
	 }
	 public Widget getConfigPanel() {
		 if (configPanel == null) {
			 configPanel = new ColumnContainer();
			 FormContainer choicesPanel = new FormContainer(2, 4);
			 configPanel.add(choicesPanel);
			 LayoutInfo leftLayout = new LayoutInfo(LayoutInfo.EAST, LayoutInfo.NONE, new Insets(0, 0, 0, 5), null);
			 LayoutInfo rightLayout = new LayoutInfo(LayoutInfo.WEST, LayoutInfo.NONE, null, null);
			 choicesPanel.add(Translate.label(""surfaceAccuracy""), 0, 0, leftLayout);
			 choicesPanel.add(new BLabel(Translate.text(""Antialiasing"")+"":""), 0, 1, leftLayout);
			 choicesPanel.add(Translate.label(""minRaysPixel""), 0, 2, leftLayout);
			 choicesPanel.add(Translate.label(""maxRaysPixel""), 0, 3, leftLayout);
			 choicesPanel.add(errorField = new ValueField(surfaceError, ValueField.POSITIVE, 6), 1, 0, rightLayout);
			 choicesPanel.add(aliasChoice = new BComboBox(new String [] {
			 Translate.text(""none""), Translate.text(""Medium""), Translate.text(""Maximum"") }
			), 1, 1, rightLayout);
			 choicesPanel.add(minRaysChoice = new BComboBox(), 1, 2, rightLayout);
			 choicesPanel.add(maxRaysChoice = new BComboBox(), 1, 3, rightLayout);
			 for (int i = 4;
			 i <= 1024;
			 i *= 2) {
				 minRaysChoice.add(Integer.toString(i));
				 maxRaysChoice.add(Integer.toString(i));
			 }
			 ColumnContainer boxes = new ColumnContainer();
			 configPanel.add(boxes);
			 boxes.setDefaultLayout(new LayoutInfo(LayoutInfo.WEST, LayoutInfo.NONE, null, null));
			 boxes.add(depthBox = new BCheckBox(Translate.text(""depthOfField""), depth));
			 boxes.add(glossBox = new BCheckBox(Translate.text(""glossTranslucency""), gloss));
			 boxes.add(shadowBox = new BCheckBox(Translate.text(""softShadows""), penumbra));
			 RowContainer buttons = new RowContainer();
			 configPanel.add(buttons);
			 buttons.add(Translate.button(""illumination"", this, ""showIlluminationWindow""));
			 giModeChoice = new BComboBox(new String [] {
			 Translate.text(""none""), Translate.text(""ambientOcclusion""), Translate.text(""monteCarlo""), Translate.text(""photonMappingDirect""), Translate.text(""photonMappingFinalGather"") }
			);
			 scatterModeChoice = new BComboBox(new String [] {
			 Translate.text(""singleScattering""), Translate.text(""photonMapping""), Translate.text(""Both"") }
			);
			 diffuseRaysChoice = new BComboBox();
			 diffuseRaysChoice.add(""1"");
			 for (int i = 4;
			 i <= 64;
			 i *= 2) diffuseRaysChoice.add(Integer.toString(i));
			 globalPhotonsField = new ValueField(globalPhotons, ValueField.POSITIVE+ValueField.INTEGER, 7);
			 globalNeighborPhotonsField = new ValueField(globalNeighborPhotons, ValueField.POSITIVE+ValueField.INTEGER, 4);
			 causticsPhotonsField = new ValueField(causticsPhotons, ValueField.POSITIVE+ValueField.INTEGER, 7);
			 causticsNeighborPhotonsField = new ValueField(causticsNeighborPhotons, ValueField.POSITIVE+ValueField.INTEGER, 4);
			 volumePhotonsField = new ValueField(volumePhotons, ValueField.POSITIVE+ValueField.INTEGER, 7);
			 volumeNeighborPhotonsField = new ValueField(volumeNeighborPhotons, ValueField.POSITIVE+ValueField.INTEGER, 4);
			 causticsBox = new BCheckBox(Translate.text(""useCausticsMap""), caustics);
			 buttons.add(Translate.button(""output"", this, ""showOutputOptionsWindow""));
			 transparentBox = new BCheckBox(Translate.text(""transparentBackground""), transparentBackground);
			 hdrBox = new BCheckBox(Translate.text(""generateHDR""), generateHDR);
			 buttons.add(Translate.button(""advanced"", this, ""showAdvancedOptionsWindow""));
			 rayDepthField = new ValueField(maxRayDepth, ValueField.POSITIVE+ValueField.INTEGER);
			 rayCutoffField = new ValueField(minRayIntensity, ValueField.NONNEGATIVE);
			 smoothField = new ValueField(smoothing, ValueField.NONNEGATIVE);
			 extraGIField = new ValueField(extraGISmoothing, ValueField.POSITIVE);
			 extraGIEnvField = new ValueField(extraGIEnvSmoothing, ValueField.POSITIVE);
			 stepSizeField = new ValueField(stepSize, ValueField.POSITIVE);
			 adaptiveBox = new BCheckBox(Translate.text(""reduceAccuracyForDistant""), adaptive);
			 rouletteBox = new BCheckBox(Translate.text(""russianRoulette""), roulette);
			 reducedMemoryBox = new BCheckBox(Translate.text(""useLessMemory""), reducedMemory);
			 Object raysListener = new Object() {
				 void processEvent(WidgetEvent ev) {
					 boolean multi = (aliasChoice.getSelectedIndex() > 0);
					 depthBox.setEnabled(multi);
					 glossBox.setEnabled(multi);
					 shadowBox.setEnabled(multi);
					 minRaysChoice.setEnabled(multi);
					 maxRaysChoice.setEnabled(multi);
					 if (minRaysChoice.getSelectedIndex() > maxRaysChoice.getSelectedIndex()) {
						 if (ev.getWidget() == maxRaysChoice) minRaysChoice.setSelectedIndex(maxRaysChoice.getSelectedIndex());
						 else maxRaysChoice.setSelectedIndex(minRaysChoice.getSelectedIndex());
					 }
				 }
			 }
			;
			 aliasChoice.addEventLink(ValueChangedEvent.class, raysListener);
			 minRaysChoice.addEventLink(ValueChangedEvent.class, raysListener);
			 maxRaysChoice.addEventLink(ValueChangedEvent.class, raysListener);
			 aliasChoice.dispatchEvent(new ValueChangedEvent(aliasChoice));
			 Object illumListener = new Object() {
				 void processEvent() {
					 int mode = giModeChoice.getSelectedIndex();
					 UIUtilities.setEnabled(diffuseRaysChoice.getParent(), mode == GI_MONTE_CARLO || mode == GI_HYBRID || mode == GI_AMBIENT_OCCLUSION);
					 UIUtilities.setEnabled(globalPhotonsField.getParent(), mode == GI_PHOTON || mode == GI_HYBRID);
					 UIUtilities.setEnabled(causticsPhotonsField.getParent(), causticsBox.getState());
					 UIUtilities.setEnabled(volumePhotonsField.getParent(), scatterModeChoice.getSelectedIndex() > 0);
				 }
			 }
			;
			 giModeChoice.addEventLink(ValueChangedEvent.class, illumListener);
			 causticsBox.addEventLink(ValueChangedEvent.class, illumListener);
			 scatterModeChoice.addEventLink(ValueChangedEvent.class, illumListener);
		 }
		 if (needCopyToUI) copyConfigurationToUI();
		 return configPanel;
	 }
	 protected void showAdvancedOptionsWindow(WidgetEvent ev) {
		 FormContainer content = new FormContainer(2, 10);
		 content.setColumnWeight(0, 0.0);
		 LayoutInfo leftLayout = new LayoutInfo(LayoutInfo.EAST, LayoutInfo.NONE, new Insets(0, 0, 0, 5), null);
		 LayoutInfo rightLayout = new LayoutInfo(LayoutInfo.WEST, LayoutInfo.HORIZONTAL, null, null);
		 content.add(Translate.label(""maxRayTreeDepth""), 0, 0, leftLayout);
		 content.add(Translate.label(""minRayIntensity""), 0, 1, leftLayout);
		 content.add(Translate.label(""matStepSize""), 0, 3, leftLayout);
		 content.add(Translate.label(""texSmoothing""), 0, 4, leftLayout);
		 content.add(rayDepthField, 1, 0, rightLayout);
		 content.add(rayCutoffField, 1, 1, rightLayout);
		 content.add(stepSizeField, 1, 3, rightLayout);
		 content.add(smoothField, 1, 4, rightLayout);
		 content.add(Translate.label(""extraGISmoothing""), 0, 5, 2, 1, rightLayout);
		 RowContainer row = new RowContainer();
		 content.add(row, 0, 6, 2, 1);
		 row.add(new BLabel(Translate.text(""Textures"")+"":""));
		 row.add(extraGIField);
		 row.add(new BLabel(Translate.text(""environment"")+"":""));
		 row.add(extraGIEnvField);
		 content.add(adaptiveBox, 0, 7, 2, 1, rightLayout);
		 content.add(reducedMemoryBox, 0, 8, 2, 1, rightLayout);
		 content.add(rouletteBox, 0, 9, 2, 1, rightLayout);
		 maxRayDepth = (int) rayDepthField.getValue();
		 minRayIntensity = (float) rayCutoffField.getValue();
		 stepSize = stepSizeField.getValue();
		 smoothing = smoothField.getValue();
		 extraGISmoothing = extraGIField.getValue();
		 extraGIEnvSmoothing = extraGIEnvField.getValue();
		 adaptive = adaptiveBox.getState();
		 roulette = rouletteBox.getState();
		 WindowWidget parent = UIUtilities.findWindow(ev.getWidget());
		 PanelDialog dlg = new PanelDialog(parent, Translate.text(""advancedOptions""), content);
		 if (!dlg.clickedOk()) {
			 rayDepthField.setValue(maxRayDepth);
			 rayCutoffField.setValue(minRayIntensity);
			 stepSizeField.setValue(stepSize);
			 smoothField.setValue(smoothing);
			 extraGIField.setValue(extraGISmoothing);
			 extraGIEnvField.setValue(extraGIEnvSmoothing);
			 adaptiveBox.setState(adaptive);
			 rouletteBox.setState(roulette);
			 reducedMemoryBox.setState(reducedMemory);
		 }
	 }
	 protected void showIlluminationWindow(WidgetEvent ev) {
		 ColumnContainer content = new ColumnContainer();
		 LayoutInfo indent0 = new LayoutInfo(LayoutInfo.WEST, LayoutInfo.NONE, null, null);
		 LayoutInfo indent1 = new LayoutInfo(LayoutInfo.WEST, LayoutInfo.NONE, new Insets(0, 20, 0, 0), null);
		 RowContainer row;
		 content.add(row = new RowContainer(), indent0);
		 row.add(Translate.label(""globalIllumination""));
		 row.add(giModeChoice);
		 content.add(row = new RowContainer(), indent1);
		 row.add(Translate.label(""raysToSampleEnvironment""));
		 row.add(diffuseRaysChoice);
		 content.add(row = new RowContainer(), indent1);
		 row.add(Translate.label(""totalPhotons""));
		 row.add(globalPhotonsField);
		 row.add(Translate.label(""numToEstimateLight""));
		 row.add(globalNeighborPhotonsField);
		 content.add(causticsBox, indent0);
		 content.add(row = new RowContainer(), indent1);
		 row.add(Translate.label(""totalPhotons""));
		 row.add(causticsPhotonsField);
		 row.add(Translate.label(""numToEstimateLight""));
		 row.add(causticsNeighborPhotonsField);
		 content.add(row = new RowContainer(), indent0);
		 row.add(Translate.label(""materialScattering""));
		 row.add(scatterModeChoice);
		 content.add(row = new RowContainer(), indent1);
		 row.add(Translate.label(""totalPhotons""));
		 row.add(volumePhotonsField);
		 row.add(Translate.label(""numToEstimateLight""));
		 row.add(volumeNeighborPhotonsField);
		 causticsBox.dispatchEvent(new ValueChangedEvent(causticsBox));
		 giMode = giModeChoice.getSelectedIndex();
		 diffuseRays = Integer.parseInt((String) diffuseRaysChoice.getSelectedValue());
		 globalPhotons = (int) globalPhotonsField.getValue();
		 globalNeighborPhotons = (int) globalNeighborPhotonsField.getValue();
		 caustics = causticsBox.getState();
		 causticsPhotons = (int) causticsPhotonsField.getValue();
		 causticsNeighborPhotons = (int) causticsNeighborPhotonsField.getValue();
		 scatterMode = scatterModeChoice.getSelectedIndex();
		 volumePhotons = (int) volumePhotonsField.getValue();
		 volumeNeighborPhotons = (int) volumeNeighborPhotonsField.getValue();
		 WindowWidget parent = UIUtilities.findWindow(ev.getWidget());
		 PanelDialog dlg = new PanelDialog(parent, Translate.text(""illuminationOptions""), content);
		 if (!dlg.clickedOk()) {
			 giModeChoice.setSelectedIndex(giMode);
			 diffuseRaysChoice.setSelectedValue(Integer.toString(diffuseRays));
			 globalPhotonsField.setValue(globalPhotons);
			 globalNeighborPhotonsField.setValue(globalNeighborPhotons);
			 causticsBox.setState(caustics);
			 causticsPhotonsField.setValue(causticsPhotons);
			 causticsNeighborPhotonsField.setValue(causticsNeighborPhotons);
			 scatterModeChoice.setSelectedIndex(scatterMode);
			 volumePhotonsField.setValue(volumePhotons);
			 volumeNeighborPhotonsField.setValue(volumeNeighborPhotons);
		 }
	 }
	 protected void showOutputOptionsWindow(WidgetEvent ev) {
		 transparentBackground = transparentBox.getState();
		 generateHDR = hdrBox.getState();
		 WindowWidget parent = UIUtilities.findWindow(ev.getWidget());
		 ComponentsDialog dlg = new ComponentsDialog(parent, Translate.text(""outputOptions""), new Widget [] {
		transparentBox, hdrBox}
		, new String [] {
		"""", """"}
		);
		 if (!dlg.clickedOk()) {
			 transparentBox.setState(transparentBackground);
			 hdrBox.setState(generateHDR);
		 }
	 }
	 protected void copyConfigurationToUI() {
		 needCopyToUI = false;
		 if (configPanel == null) getConfigPanel();
		 rayDepthField.setValue(maxRayDepth);
		 rayCutoffField.setValue(minRayIntensity);
		 stepSizeField.setValue(stepSize);
		 smoothField.setValue(smoothing);
		 extraGIField.setValue(extraGISmoothing);
		 extraGIEnvField.setValue(extraGIEnvSmoothing);
		 adaptiveBox.setState(adaptive);
		 rouletteBox.setState(roulette);
		 errorField.setValue(surfaceError);
		 aliasChoice.setSelectedIndex(antialiasLevel);
		 depthBox.setState(depth);
		 glossBox.setState(gloss);
		 shadowBox.setState(penumbra);
		 minRaysChoice.setSelectedValue(Integer.toString(minRays));
		 maxRaysChoice.setSelectedValue(Integer.toString(maxRays));
		 reducedMemoryBox.setState(reducedMemory);
		 giModeChoice.setSelectedIndex(giMode);
		 diffuseRaysChoice.setSelectedValue(Integer.toString(diffuseRays));
		 globalPhotonsField.setValue(globalPhotons);
		 globalNeighborPhotonsField.setValue(globalNeighborPhotons);
		 causticsBox.setState(caustics);
		 causticsPhotonsField.setValue(causticsPhotons);
		 causticsNeighborPhotonsField.setValue(causticsNeighborPhotons);
		 scatterModeChoice.setSelectedIndex(scatterMode);
		 volumePhotonsField.setValue(volumePhotons);
		 volumeNeighborPhotonsField.setValue(volumeNeighborPhotons);
		 transparentBox.setState(transparentBackground);
		 hdrBox.setState(generateHDR);
		 aliasChoice.dispatchEvent(new ValueChangedEvent(aliasChoice));
	 }
	 public boolean recordConfiguration() {
		 maxRayDepth = (int) rayDepthField.getValue();
		 minRayIntensity = (float) rayCutoffField.getValue();
		 stepSize = stepSizeField.getValue();
		 smoothing = smoothField.getValue();
		 extraGISmoothing = extraGIField.getValue();
		 extraGIEnvSmoothing = extraGIEnvField.getValue();
		 adaptive = adaptiveBox.getState();
		 roulette = rouletteBox.getState();
		 surfaceError = errorField.getValue();
		 antialiasLevel = aliasChoice.getSelectedIndex();
		 depth = depthBox.getState();
		 gloss = glossBox.getState();
		 penumbra = shadowBox.getState();
		 minRays = Integer.parseInt((String) minRaysChoice.getSelectedValue());
		 maxRays = Integer.parseInt((String) maxRaysChoice.getSelectedValue());
		 transparentBackground = transparentBox.getState();
		 generateHDR = hdrBox.getState();
		 giMode = giModeChoice.getSelectedIndex();
		 diffuseRays = Integer.parseInt((String) diffuseRaysChoice.getSelectedValue());
		 globalPhotons = (int) globalPhotonsField.getValue();
		 globalNeighborPhotons = (int) globalNeighborPhotonsField.getValue();
		 caustics = causticsBox.getState();
		 causticsPhotons = (int) causticsPhotonsField.getValue();
		 causticsNeighborPhotons = (int) causticsNeighborPhotonsField.getValue();
		 scatterMode = scatterModeChoice.getSelectedIndex();
		 volumePhotons = (int) volumePhotonsField.getValue();
		 volumeNeighborPhotons = (int) volumeNeighborPhotonsField.getValue();
		 reducedMemory = reducedMemoryBox.getState();
		 return true;
	 }
	 public Map<String, Object> getConfiguration() {
		 HashMap<String, Object> map = new HashMap<String, Object>();
		 map.put(""maxRayDepth"", maxRayDepth);
		 map.put(""minRayIntensity"", minRayIntensity);
		 map.put(""materialStepSize"", stepSize);
		 map.put(""textureSmoothing"", smoothing);
		 map.put(""extraGISmoothing"", extraGISmoothing);
		 map.put(""extraGIEnvSmoothing"", extraGIEnvSmoothing);
		 map.put(""reduceAccuracyForDistant"", adaptive);
		 map.put(""russianRouletteSampling"", roulette);
		 map.put(""useLessMemory"", reducedMemory);
		 map.put(""maxSurfaceError"", surfaceError);
		 map.put(""antialiasing"", antialiasLevel);
		 map.put(""depthOfField"", depth);
		 map.put(""gloss"", gloss);
		 map.put(""softShadows"", penumbra);
		 map.put(""minRaysPerPixel"", minRays);
		 map.put(""maxRaysPerPixel"", maxRays);
		 map.put(""transparentBackground"", transparentBackground);
		 map.put(""highDynamicRange"", generateHDR);
		 map.put(""globalIlluminationMode"", giMode);
		 map.put(""raysToSampleEnvironment"", diffuseRays);
		 map.put(""globalIlluminationPhotons"", globalPhotons);
		 map.put(""globalIlluminationPhotonsInEstimate"", globalNeighborPhotons);
		 map.put(""caustics"", caustics);
		 map.put(""causticsPhotons"", causticsPhotons);
		 map.put(""causticsPhotonsInEstimate"", causticsNeighborPhotons);
		 map.put(""scatteringMode"", scatterMode);
		 map.put(""scatteringPhotons"", volumePhotons);
		 map.put(""scatteringPhotonsInEstimate"", volumeNeighborPhotons);
		 return map;
	 }
	 public void setConfiguration(String property, Object value) {
		 needCopyToUI = true;
		 if (""maxRayDepth"".equals(property)) maxRayDepth = (Integer) value;
		 else if (""minRayIntensity"".equals(property)) minRayIntensity = ((Number) value).floatValue();
		 else if (""materialStepSize"".equals(property)) stepSize = ((Number) value).doubleValue();
		 else if (""textureSmoothing"".equals(property)) smoothing = ((Number) value).doubleValue();
		 else if (""extraGISmoothing"".equals(property)) extraGISmoothing = ((Number) value).doubleValue();
		 else if (""extraGIEnvSmoothing"".equals(property)) extraGIEnvSmoothing = ((Number) value).doubleValue();
		 else if (""reduceAccuracyForDistant"".equals(property)) adaptive = (Boolean) value;
		 else if (""russianRouletteSampling"".equals(property)) roulette = (Boolean) value;
		 else if (""useLessMemory"".equals(property)) reducedMemory = (Boolean) value;
		 else if (""maxSurfaceError"".equals(property)) surfaceError = ((Number) value).doubleValue();
		 else if (""antialiasing"".equals(property)) antialiasLevel = (Integer) value;
		 else if (""depthOfField"".equals(property)) depth = (Boolean) value;
		 else if (""gloss"".equals(property)) gloss = (Boolean) value;
		 else if (""softShadows"".equals(property)) penumbra = (Boolean) value;
		 else if (""minRaysPerPixel"".equals(property)) minRays = (Integer) value;
		 else if (""maxRaysPerPixel"".equals(property)) maxRays = (Integer) value;
		 else if (""transparentBackground"".equals(property)) transparentBackground = (Boolean) value;
		 else if (""highDynamicRange"".equals(property)) generateHDR = (Boolean) value;
		 else if (""globalIlluminationMode"".equals(property)) giMode = (Integer) value;
		 else if (""raysToSampleEnvironment"".equals(property)) diffuseRays = (Integer) value;
		 else if (""globalIlluminationPhotons"".equals(property)) globalPhotons = (Integer) value;
		 else if (""globalIlluminationPhotonsInEstimate"".equals(property)) globalNeighborPhotons = (Integer) value;
		 else if (""caustics"".equals(property)) caustics = (Boolean) value;
		 else if (""causticsPhotons"".equals(property)) causticsPhotons = (Integer) value;
		 else if (""causticsPhotonsInEstimate"".equals(property)) causticsNeighborPhotons = (Integer) value;
		 else if (""scatteringMode"".equals(property)) scatterMode = (Integer) value;
		 else if (""scatteringPhotons"".equals(property)) volumePhotons = (Integer) value;
		 else if (""scatteringPhotonsInEstimate"".equals(property)) volumeNeighborPhotons = (Integer) value;
	 }
	 public void configurePreview() {
		 if (needCopyToUI) copyConfigurationToUI();
		 maxRayDepth = 6;
		 minRayIntensity = 0.02f;
		 antialiasLevel = 0;
		 depth = gloss = penumbra = transparentBackground = generateHDR = false;
		 minRays = maxRays = 1;
		 stepSize = 1.0;
		 smoothing = 1.0;
		 extraGISmoothing = 10.0;
		 extraGIEnvSmoothing = 100.0;
		 adaptive = true;
		 reducedMemory = false;
		 roulette = false;
		 surfaceError = 0.02;
		 giMode = GI_NONE;
		 scatterMode = SCATTER_SINGLE;
		 caustics = false;
	 }
	 protected void buildScene(final Scene theScene, final Camera theCamera) {
		 final List<RTObject> obj = Collections.synchronizedList(new ArrayList<RTObject>());
		 final List<RTLight> lt = Collections.synchronizedList(new ArrayList<RTLight>());
		 final Thread mainThread = Thread.currentThread();
		 final List<RTObjectFactory> factories = PluginRegistry.getPlugins(RTObjectFactory.class);
		 ThreadManager threads = new ThreadManager(theScene.getNumObjects(), new ThreadManager.Task() {
			 public void execute(int index) {
				 if (renderThread != mainThread) return;
				 ObjectInfo info = theScene.getObject(index);
				 if (info.isVisible()) addObject(obj, lt, info, theCamera, mainThread, factories);
			 }
			 public void cleanup() {
			 }
		 }
		);
		 threads.run();
		 threads.finish();
		 sceneObject = new RTObject [obj.size()];
		 for (int i = 0;
		 i < sceneObject.length;
		 i++) {
			 sceneObject[i] = obj.get(i);
			 sceneObject[i].index = i;
			 if (sceneObject[i].getMaterialMapping() != null) {
				 if (materialBounds == null) materialBounds = new BoundingBox(sceneObject[i].getBounds());
				 else materialBounds.extend(sceneObject[i].getBounds());
			 }
		 }
		 light = new RTLight [lt.size()];
		 for (int i = 0;
		 i < light.length;
		 i++) light[i] = lt.get(i);
		 ambColor = theScene.getAmbientColor();
		 envColor = theScene.getEnvironmentColor();
		 envMapping = theScene.getEnvironmentMapping();
		 envMode = theScene.getEnvironmentMode();
		 fogColor = theScene.getFogColor();
		 fog = theScene.getFogState();
		 fogDist = theScene.getFogDistance();
		 ParameterValue envParam[] = theScene.getEnvironmentParameterValues();
		 envParamValue = new double [envParam.length];
		 for (int i = 0;
		 i < envParamValue.length;
		 i++) envParamValue[i] = envParam[i].getAverageValue();
	 }
	 protected void addObject(List<RTObject> obj, List<RTLight> lt, ObjectInfo info, Camera camera, Thread mainThread, List<RTObjectFactory> factories) {
		 boolean displaced = false;
		 double tol;
		 if (renderThread != mainThread) return;
		 for (RTObjectFactory factory : factories) if (factory.processObject(info, theScene, camera, obj, lt)) return;
		 Object3D theObject = info.getObject();
		 Mat4 toLocal = info.getCoords().toLocal();
		 Mat4 fromLocal = info.getCoords().fromLocal();
		 if (theObject instanceof PointLight) {
			 lt.add(new RTSphericalLight((PointLight) theObject, info.getCoords(), penumbra));
			 return;
		 }
		 if (theObject instanceof SpotLight) {
			 lt.add(new RTSphericalLight((SpotLight) theObject, info.getCoords(), penumbra));
			 return;
		 }
		 if (theObject instanceof DirectionalLight) {
			 lt.add(new RTDirectionalLight((DirectionalLight) theObject, info.getCoords(), penumbra));
			 return;
		 }
		 while (theObject instanceof ObjectWrapper) theObject = ((ObjectWrapper) theObject).getWrappedObject();
		 if (theObject instanceof ObjectCollection) {
			 Enumeration enm = ((ObjectCollection) theObject).getObjects(info, false, theScene);
			 while (enm.hasMoreElements()) {
				 ObjectInfo elem = (ObjectInfo) enm.nextElement();
				 if (!elem.isVisible()) continue;
				 ObjectInfo copy = elem.duplicate();
				 copy.getCoords().transformCoordinates(fromLocal);
				 addObject(obj, lt, copy, camera, mainThread, factories);
			 }
			 return;
		 }
		 Vec3 cameraOrig = camera.getCameraCoordinates().getOrigin();
		 double distToScreen = theCamera.getDistToScreen();
		 if (adaptive) {
			 double dist = info.getBounds().distanceToPoint(toLocal.times(cameraOrig));
			 if (dist < distToScreen) tol = surfaceError;
			 else tol = surfaceError*dist/distToScreen;
		 }
		 else tol = surfaceError;
		 Texture tex = theObject.getTexture();
		 if (tex != null && tex.hasComponent(Texture.DISPLACEMENT_COMPONENT)) {
			 displaced = true;
			 if (theObject.canConvertToTriangleMesh() != Object3D.CANT_CONVERT) {
				 TriangleMesh tm = theObject.convertToTriangleMesh(tol);
				 tm.setTexture(tex, theObject.getTextureMapping().duplicate());
				 if (theObject.getMaterialMapping() != null) tm.setMaterial(theObject.getMaterial(), theObject.getMaterialMapping().duplicate());
				 theObject = tm;
			 }
		 }
		 if (!info.isDistorted()) {
			 if (theObject instanceof Sphere) {
				 Vec3 rad = ((Sphere) theObject).getRadii();
				 if (rad.x == rad.y && rad.x == rad.z) {
					 obj.add(new RTSphere((Sphere) theObject, fromLocal, toLocal, info.getObject().getAverageParameterValues()));
					 return;
				 }
				 else {
					 obj.add(new RTEllipsoid((Sphere) theObject, fromLocal, toLocal, info.getObject().getAverageParameterValues()));
					 return;
				 }
			 }
			 else if (theObject instanceof Cylinder) {
				 obj.add(new RTCylinder((Cylinder) theObject, fromLocal, toLocal, info.getObject().getAverageParameterValues()));
				 return;
			 }
			 else if (theObject instanceof Cube) {
				 obj.add(new RTCube((Cube) theObject, fromLocal, toLocal, info.getObject().getAverageParameterValues()));
				 return;
			 }
			 else if (theObject instanceof ImplicitObject && ((ImplicitObject) theObject).getPreferDirectRendering()) {
				 obj.add(new RTImplicitObject((ImplicitObject) theObject, fromLocal, toLocal, info.getObject().getAverageParameterValues(), tol));
				 return;
			 }
		 }
		 RenderingMesh mesh = info.getRenderingMesh(tol);
		 if (mesh == null) return;
		 mesh.transformMesh(fromLocal);
		 Vec3 vert[] = mesh.vert;
		 RenderingTriangle t[] = mesh.triangle;
		 if (displaced) {
			 Vec3 cameraZDir = camera.getCameraCoordinates().getZDirection();
			 double vertTol[] = new double [vert.length];
			 if (adaptive) for (int i = 0;
			 i < vert.length;
			 i++) {
				 Vec3 offset = vert[i].minus(cameraOrig);
				 double vertDist = offset.length();
				 if (offset.dot(cameraZDir) < 0.0) vertDist = -vertDist;
				 vertTol[i] = (vertDist < distToScreen ? surfaceError : surfaceError*vertDist/distToScreen);
			 }
			 for (int i = 0;
			 i < t.length;
			 i++) {
				 RenderingTriangle tri = mesh.triangle[i];
				 if (mesh.faceNorm[i].length() < TOL) continue;
				 if (vert[tri.v1].distance(vert[tri.v2]) < TOL) continue;
				 if (vert[tri.v1].distance(vert[tri.v3]) < TOL) continue;
				 if (vert[tri.v2].distance(vert[tri.v3]) < TOL) continue;
				 double localTol;
				 if (adaptive) {
					 localTol = vertTol[tri.v1];
					 if (vertTol[tri.v2] < localTol) localTol = vertTol[tri.v2];
					 if (vertTol[tri.v3] < localTol) localTol = vertTol[tri.v3];
				 }
				 else localTol = tol;
				 RTDisplacedTriangle dispTri = new RTDisplacedTriangle(mesh, i, fromLocal, toLocal, localTol, time);
				 RTObject dt = dispTri;
				 if (!dispTri.isReallyDisplaced()) {
					 if (reducedMemory) dt = new RTTriangleLowMemory(mesh, i, fromLocal, toLocal);
					 else dt = new RTTriangle(mesh, i, fromLocal, toLocal);
				 }
				 obj.add(dt);
				 if (adaptive && dt instanceof RTDisplacedTriangle) {
					 double dist = dt.getBounds().distanceToPoint(cameraOrig);
					 if (dist < distToScreen) ((RTDisplacedTriangle) dt).setTolerance(surfaceError);
					 else ((RTDisplacedTriangle) dt).setTolerance(surfaceError*dist/distToScreen);
				 }
				 if (renderThread != mainThread) return;
			 }
		 }
		 else for (int i = 0;
		 i < t.length;
		 i++) {
			 RenderingTriangle tri = mesh.triangle[i];
			 if (mesh.faceNorm[i].length() < TOL) continue;
			 if (vert[tri.v1].distance(vert[tri.v2]) < TOL) continue;
			 if (vert[tri.v1].distance(vert[tri.v3]) < TOL) continue;
			 if (vert[tri.v2].distance(vert[tri.v3]) < TOL) continue;
			 if (reducedMemory) obj.add(new RTTriangleLowMemory(mesh, i, fromLocal, toLocal));
			 else obj.add(new RTTriangle(mesh, i, fromLocal, toLocal));
		 }
	 }
	 protected void buildTree() {
		 BoundingBox objBounds[] = new BoundingBox [sceneObject.length];
		 double minx, maxx, miny, maxy, minz, maxz;
		 int i;
		 minx = miny = minz = Double.MAX_VALUE;
		 maxx = maxy = maxz = -Double.MAX_VALUE;
		 for (i = 0;
		 i < sceneObject.length;
		 i++) {
			 objBounds[i] = sceneObject[i].getBounds();
			 if (objBounds[i].minx < minx) minx = objBounds[i].minx;
			 if (objBounds[i].maxx > maxx) maxx = objBounds[i].maxx;
			 if (objBounds[i].miny < miny) miny = objBounds[i].miny;
			 if (objBounds[i].maxy > maxy) maxy = objBounds[i].maxy;
			 if (objBounds[i].minz < minz) minz = objBounds[i].minz;
			 if (objBounds[i].maxz > maxz) maxz = objBounds[i].maxz;
		 }
		 minx -= TOL;
		 miny -= TOL;
		 minz -= TOL;
		 maxx += TOL;
		 maxy += TOL;
		 maxz += TOL;
		 rootNode = new OctreeNode(minx, maxx, miny, maxy, minz, maxz, sceneObject, objBounds, null);
		 cameraNode = rootNode.findNode(theCamera.getCameraCoordinates().getOrigin());
		 lightNode = new OctreeNode [light.length];
		 for (i = 0;
		 i < light.length;
		 i++) {
			 if (light[i].getLight() instanceof DirectionalLight) lightNode[i] = null;
			 else lightNode[i] = rootNode.findNode(light[i].getCoords().getOrigin());
		 }
	 }
	 protected void buildPhotonMap() {
		 if (giMode != GI_PHOTON && giMode != GI_HYBRID && !caustics && scatterMode != SCATTER_PHOTONS && scatterMode != SCATTER_BOTH) return;
		 PhotonMap shared = null;
		 if (giMode == GI_PHOTON) {
			 listener.statusChanged(""Building Global Photon Map"");
			 globalMap = shared = new PhotonMap(globalPhotons, globalNeighborPhotons, false, false, true, false, this, rootNode, 1, null);
			 generatePhotons(globalMap);
		 }
		 else if (giMode == GI_HYBRID) {
			 listener.statusChanged(""Building Global Photon Map"");
			 globalMap = shared = new PhotonMap(globalPhotons, globalNeighborPhotons, true, true, true, false, this, rootNode, 0, null);
			 generatePhotons(globalMap);
		 }
		 if (caustics) {
			 BoundingBox bounds = null;
			 for (RTObject obj : sceneObject) {
				 Texture tex = obj.getTextureMapping().getTexture();
				 MaterialMapping mm = obj.getMaterialMapping();
				 if (tex.hasComponent(Texture.SPECULAR_COLOR_COMPONENT) || (tex.hasComponent(Texture.TRANSPARENT_COLOR_COMPONENT) && mm != null && mm.getMaterial().indexOfRefraction() != 1.0)) {
					 if (bounds == null) bounds = obj.getBounds();
					 else bounds = bounds.merge(obj.getBounds());
				 }
			 }
			 if (bounds == null) bounds = new BoundingBox(0, 0, 0, 0, 0, 0);
			 listener.statusChanged(""Building Caustics Photon Map"");
			 causticsMap = shared = new PhotonMap(causticsPhotons, causticsNeighborPhotons, true, false, false, false, this, bounds, 2, shared);
			 generatePhotons(causticsMap);
		 }
		 if (scatterMode == SCATTER_PHOTONS || scatterMode == SCATTER_BOTH) {
			 BoundingBox bounds = null;
			 for (RTObject obj : sceneObject) {
				 Texture tex = obj.getTextureMapping().getTexture();
				 MaterialMapping mm = obj.getMaterialMapping();
				 if (tex.hasComponent(Texture.TRANSPARENT_COLOR_COMPONENT) && mm != null && mm.getMaterial().isScattering()) {
					 if (bounds == null) bounds = obj.getBounds();
					 else bounds = bounds.merge(obj.getBounds());
				 }
			 }
			 if (bounds == null) bounds = new BoundingBox(0, 0, 0, 0, 0, 0);
			 listener.statusChanged(""Building Volume Photon Map"");
			 volumeMap = new PhotonMap(volumePhotons, volumeNeighborPhotons, false, scatterMode == SCATTER_PHOTONS, true, true, this, bounds, 0, shared);
			 generatePhotons(volumeMap);
		 }
	 }
	 protected void generatePhotons(PhotonMap map) {
		 List<PhotonSourceFactory> factories = PluginRegistry.getPlugins(PhotonSourceFactory.class);
		 ArrayList<PhotonSource> sources = new ArrayList<PhotonSource>();
		 for (RTLight lt : light) {
			 boolean processed = false;
			 for (PhotonSourceFactory factory : factories) if (factory.processLight(lt, map, sources)) {
				 processed = true;
				 break;
			 }
			 if (processed) continue;
			 if (lt.getLight() instanceof DirectionalLight) sources.add(new DirectionalPhotonSource((DirectionalLight) lt.getLight(), lt.getCoords(), map));
			 else if (lt.getLight() instanceof PointLight) sources.add(new PointPhotonSource((PointLight) lt.getLight(), lt.getCoords(), map));
			 else if (lt.getLight() instanceof SpotLight) sources.add(new SpotlightPhotonSource((SpotLight) lt.getLight(), lt.getCoords(), map));
		 }
		 ArrayList<PhotonSource> objectSources = new ArrayList<PhotonSource>();
		 for (RTObject obj : sceneObject) {
			 boolean processed = false;
			 for (PhotonSourceFactory factory : factories) if (factory.processObject(obj, map, sources)) {
				 processed = true;
				 break;
			 }
			 if (processed) continue;
			 if (!obj.getTextureMapping().getTexture().hasComponent(Texture.EMISSIVE_COLOR_COMPONENT)) continue;
			 PhotonSource src;
			 if (obj instanceof RTTriangle) src = new TrianglePhotonSource(((RTTriangle) obj).tri, map);
			 else if (obj instanceof RTTriangleLowMemory) src = new TrianglePhotonSource(((RTTriangleLowMemory) obj).tri, map);
			 else if (obj instanceof RTDisplacedTriangle) src = new DisplacedTrianglePhotonSource((RTDisplacedTriangle) obj, map);
			 else if (obj instanceof RTEllipsoid) src = new EllipsoidPhotonSource((RTEllipsoid) obj, map);
			 else if (obj instanceof RTSphere) src = new EllipsoidPhotonSource((RTSphere) obj, map);
			 else if (obj instanceof RTCylinder) src = new CylinderPhotonSource((RTCylinder) obj, map);
			 else if (obj instanceof RTCube) src = new CubePhotonSource((RTCube) obj, map);
			 else continue;
			 if (src.getTotalIntensity() > 0.0) objectSources.add(src);
		 }
		 if (objectSources.size() > 0) sources.add(new CompoundPhotonSource(objectSources.toArray(new PhotonSource[objectSources.size()])));
		 sources.add(new EnvironmentPhotonSource(theScene, map));
		 PhotonSource src[] = sources.toArray(new PhotonSource [sources.size()]);
		 map.generatePhotons(src);
	 }
	 public void run() {
		 long updateTime = System.currentTimeMillis();
		 Thread thisThread = Thread.currentThread();
		 listener.statusChanged(Translate.text(""Processing Scene""));
		 buildScene(theScene, theCamera);
		 if (renderThread != thisThread) return;
		 buildTree();
		 buildPhotonMap();
		 listener.statusChanged(Translate.text(""Rendering""));
		 for (int i = 0;
		 i < pixel.length;
		 i++) pixel[i] = 0;
		 int maxRaysInUse = maxRays;
		 int minRaysInUse = minRays;
		 if (antialiasLevel == 0) minRaysInUse = maxRaysInUse = 1;
		 smoothScale = smoothing*2.0*Math.tan(sceneCamera.getFieldOfView()*Math.PI/360.0)/height;
		 if (maxRaysInUse == 1) {
			 rtWidth = width;
			 rtHeight = height;
			 final int currentRow[] = new int [1];
			 ThreadManager threads = new ThreadManager(width, new ThreadManager.Task() {
				 public void execute(int index) {
					 RaytracerContext context = (RaytracerContext) threadContext.get();
					 PixelInfo pixel = context.tempPixel;
					 pixel.clear();
					 pixel.depth = (float) spawnEyeRay(context, index, currentRow[0], 0, 1);
					 pixel.object = context.firstObjectHit;
					 pixel.add(context.color[0], (float) context.transparency[0]);
					 recordPixel(index, currentRow[0], pixel);
				 }
				 public void cleanup() {
					 ((RaytracerContext) threadContext.get()).cleanup();
				 }
			 }
			);
			 for (currentRow[0] = 0;
			 currentRow[0] < height;
			 currentRow[0]++) {
				 threads.run();
				 if (renderThread != thisThread) {
					 threads.finish();
					 return;
				 }
				 if (System.currentTimeMillis()-updateTime > 5000) {
					 imageSource.newPixels();
					 listener.imageUpdated(img);
					 updateTime = System.currentTimeMillis();
				 }
			 }
			 imageSource.newPixels();
			 threads.finish();
			 finish();
			 return;
		 }
		 PixelInfo tempPixel = new PixelInfo();
		 rtWidth = 2*width+2;
		 rtHeight = 2*height+2;
		 smoothScale *= 0.5;
		 final PixelInfo pix[][] = new PixelInfo [6][rtWidth];
		 for (int i = 0;
		 i < pix.length;
		 i++) for (int j = 0;
		 j < pix[i].length;
		 j++) pix[i][j] = new PixelInfo();
		 int minPerSubpixel = minRaysInUse/4, maxPerSubpixel = maxRaysInUse/4;
		 final int currentRow[] = new int [1];
		 final int currentCount[] = new int [1];
		 ThreadManager threads = new ThreadManager(rtWidth, new ThreadManager.Task() {
			 public void execute(int index) {
				 RaytracerContext context = (RaytracerContext) threadContext.get();
				 PixelInfo tempPixel = context.tempPixel;
				 for (int m = 0;
				 m < 6;
				 m++) {
					 PixelInfo thisPixel = pix[m][index];
					 thisPixel.converged = true;
					 if (thisPixel.needsMore) {
						 tempPixel.clear();
						 int baseNum = (m&1)*8+(index&1)*4;
						 int numNeeded = currentCount[0]-thisPixel.raysSent;
						 for (int k = thisPixel.raysSent;
						 k < currentCount[0];
						 k++) {
							 float dist = (float) spawnEyeRay(context, index, 2*currentRow[0]+m, baseNum+k, numNeeded);
							 if (k < currentCount[0]/2) {
								 thisPixel.add(context.color[0], (float) context.transparency[0]);
								 if (dist < thisPixel.depth) {
									 thisPixel.depth = dist;
									 thisPixel.object = context.firstObjectHit;
								 }
							 }
							 else {
								 tempPixel.add(context.color[0], (float) context.transparency[0]);
								 if (dist < tempPixel.depth) {
									 tempPixel.depth = dist;
									 tempPixel.object = context.firstObjectHit;
								 }
							 }
						 }
						 if (currentCount[0] > 1) thisPixel.converged = thisPixel.matches(tempPixel, COLOR_THRESH_ABS, COLOR_THRESH_REL);
						 thisPixel.add(tempPixel);
					 }
				 }
			 }
			 public void cleanup() {
				 ((RaytracerContext) threadContext.get()).cleanup();
			 }
		 }
		);
		 for (currentRow[0] = 0;
		 currentRow[0] < height-1;
		 currentRow[0]++) {
			 boolean done = false;
			 for (currentCount[0] = minPerSubpixel;
			 currentCount[0] <= maxPerSubpixel && !done;
			 currentCount[0] *= 2) {
				 threads.run();
				 if (renderThread != thisThread) {
					 threads.finish();
					 return;
				 }
				 if (currentCount[0] == 1) for (int m = 0;
				 m < 5;
				 m++) for (int j = 0;
				 j < rtWidth-1;
				 j++) {
					 if (!pix[m][j].matches(pix[m+1][j], COLOR_THRESH_ABS, COLOR_THRESH_REL)) pix[m][j].converged = pix[m+1][j].converged = false;
					 if (!pix[m][j].matches(pix[m][j+1], COLOR_THRESH_ABS, COLOR_THRESH_REL)) pix[m][j].converged = pix[m][j+1].converged = false;
				 }
				 for (int m = 0;
				 m < 6;
				 m++) for (int j = 0;
				 j < rtWidth;
				 j++) pix[m][j].needsMore = false;
				 done = true;
				 for (int m = 0;
				 m < 6;
				 m++) for (int j = 0;
				 j < rtWidth;
				 j++) if (!pix[m][j].converged) {
					 done = false;
					 pix[m][j].needsMore = true;
					 if (m > 0) pix[m-1][j].needsMore = true;
					 if (m < 5) pix[m+1][j].needsMore = true;
					 if (j > 0) pix[m][j-1].needsMore = true;
					 if (j < rtWidth-1) pix[m][j+1].needsMore = true;
				 }
			 }
			 recordRow(pix, tempPixel, currentRow[0]);
			 if (System.currentTimeMillis()-updateTime > 5000) {
				 imageSource.newPixels();
				 listener.imageUpdated(img);
				 updateTime = System.currentTimeMillis();
			 }
			 PixelInfo temp1[] = pix[0], temp2[] = pix[1];
			 for (int j = 0;
			 j < 4;
			 j++) pix[j] = pix[j+2];
			 pix[4] = temp1;
			 pix[5] = temp2;
			 for (int j = 0;
			 j < rtWidth;
			 j++) {
				 pix[4][j].clear();
				 pix[5][j].clear();
			 }
		 }
		 recordRow(pix, tempPixel, height-1);
		 imageSource.newPixels();
		 threads.finish();
		 finish();
	 }
	 protected void recordRow(PixelInfo pix[][], PixelInfo tempPixel, int row) {
		 for (int i = 0;
		 i < width;
		 i++) {
			 int x = i*2+1;
			 tempPixel.copy(pix[1][x]);
			 tempPixel.add(pix[1][x+1]);
			 tempPixel.add(pix[2][x]);
			 tempPixel.add(pix[2][x+1]);
			 if (antialiasLevel == 2) {
				 tempPixel.add(tempPixel);
				 tempPixel.add(pix[0][x]);
				 tempPixel.add(pix[0][x+1]);
				 tempPixel.add(pix[3][x]);
				 tempPixel.add(pix[3][x+1]);
				 tempPixel.add(pix[1][x-1]);
				 tempPixel.add(pix[2][x-1]);
				 tempPixel.add(pix[1][x+2]);
				 tempPixel.add(pix[2][x+2]);
			 }
			 recordPixel(i, row, tempPixel);
			 if (errorImage != null) {
				 if (pix[1][x].raysSent+pix[1][x+1].raysSent+pix[2][x].raysSent+pix[2][x+1].raysSent == 4) {
					 float ninvTotal = 1.0f/tempPixel.raysSent;
					 PixelInfo p1 = pix[1][x];
					 PixelInfo p2 = pix[1][x+1];
					 PixelInfo p3 = pix[2][x];
					 PixelInfo p4 = pix[2][x+1];
					 float ninv1 = 1.0f/p1.raysSent;
					 float ninv2 = 1.0f/p2.raysSent;
					 float ninv3 = 1.0f/p3.raysSent;
					 float ninv4 = 1.0f/p4.raysSent;
					 float r = tempPixel.red*ninvTotal;
					 float g = tempPixel.green*ninvTotal;
					 float b = tempPixel.blue*ninvTotal;
					 errorImage[i+row*width] = ((p1.red*ninv1-r)*(p1.red*ninv1-r) + (p1.green*ninv1-g)*(p1.green*ninv1-g) + (p1.blue*ninv1-b)*(p1.blue*ninv1-b) + (p2.red*ninv2-r)*(p2.red*ninv2-r) + (p2.green*ninv2-g)*(p2.green*ninv2-g) + (p2.blue*ninv2-b)*(p2.blue*ninv2-b) + (p3.red*ninv3-r)*(p2.red*ninv3-r) + (p3.green*ninv3-g)*(p3.green*ninv3-g) + (p3.blue*ninv3-b)*(p3.blue*ninv3-b) + (p4.red*ninv4-r)*(p3.red*ninv4-r) + (p4.green*ninv4-g)*(p4.green*ninv4-g) + (p4.blue*ninv4-b)*(p4.blue*ninv4-b))/12.0f;
				 }
				 else {
					 int degreesOfFreedom = (antialiasLevel == 2 ? tempPixel.raysSent/2 : tempPixel.raysSent);
					 errorImage[i+row*width] = (tempPixel.getRedVariance()+tempPixel.getGreenVariance()+tempPixel.getBlueVariance())/(3.0f*degreesOfFreedom);
				 }
			 }
		 }
	 }
	 protected void recordPixel(int x, int y, PixelInfo pix) {
		 int index = x+y*width;
		 pixel[index] = pix.calcARGB();
		 if (floatImage != null) {
			 float ninv = 1.0f/pix.raysSent;
			 floatImage[0][index] = pix.red*ninv;
			 floatImage[1][index] = pix.green*ninv;
			 floatImage[2][index] = pix.blue*ninv;
			 floatImage[3][index] = 1.0f-pix.transparency*ninv;
		 }
		 if (depthImage != null) depthImage[index] = pix.depth;
		 if (objectImage != null) objectImage[index] = (pix.object == null ? 0.0f : Float.intBitsToFloat(pix.object.getObject().hashCode()));
	 }
	 protected void finish() {
		 sceneObject = null;
		 light = null;
		 rootNode = null;
		 cameraNode = null;
		 lightNode = null;
		 theScene = null;
		 theCamera = null;
		 envMapping = null;
		 renderThread = null;
		 globalMap = null;
		 causticsMap = null;
		 volumeMap = null;
		 RenderListener rl = listener;
		 ComplexImage im = new ComplexImage(img);
		 if (rl != null) {
			 if (floatImage != null) {
				 im.setComponentValues(ComplexImage.RED, floatImage[0]);
				 im.setComponentValues(ComplexImage.GREEN, floatImage[1]);
				 im.setComponentValues(ComplexImage.BLUE, floatImage[2]);
				 im.setComponentValues(ComplexImage.ALPHA, floatImage[3]);
			 }
			 if (depthImage != null) im.setComponentValues(ComplexImage.DEPTH, depthImage);
			 if (objectImage != null) im.setComponentValues(ComplexImage.OBJECT, objectImage);
			 if (errorImage != null) im.setComponentValues(ComplexImage.NOISE, errorImage);
			 listener = null;
		 }
		 img = null;
		 imageSource = null;
		 pixel = null;
		 floatImage = null;
		 depthImage = null;
		 errorImage = null;
		 objectImage = null;
		 System.gc();
		 if (rl != null) rl.imageComplete(im);
	 }
	 protected double spawnEyeRay(RaytracerContext rt, int i, int j, int number, int outOf) {
		 Ray ray = rt.ray[0];
		 Vec3 orig = ray.getOrigin(), dir = ray.getDirection();
		 double h = i-rtWidth*0.5+0.5, v = j-rtHeight*0.5+0.5;
		 if (antialiasLevel > 0) {
			 int rows = FastMath.ceil(Math.sqrt(outOf));
			 int cols = outOf/rows;
			 int num = number%outOf;
			 int row = num/cols;
			 int col = num-row*cols;
			 h += (col+rt.random.nextDouble())/cols-0.5;
			 v += (row+rt.random.nextDouble())/rows-0.5;
		 }
		 double dof1 = 0.0, dof2 = 0.0;
		 if (depth) {
			 dof1 = 0.25*(rt.random.nextDouble()+distrib1[number&15]);
			 dof2 = 0.25*(rt.random.nextDouble()+distrib2[number&15]);
		 }
		 sceneCamera.getRayFromCamera(h/rtHeight, v/rtHeight, dof1, dof2, orig, dir);
		 theCamera.getCameraCoordinates().fromLocal().transform(orig);
		 theCamera.getCameraCoordinates().fromLocal().transformDirection(dir);
		 ray.newID();
		 rt.rayIntensity[0].setRGB(1.0f, 1.0f, 1.0f);
		 rt.firstObjectHit = null;
		 double distScale = 1.0/dir.dot(theCamera.getCameraCoordinates().getZDirection());
		 OctreeNode node = cameraNode;
		 if (node == null) node = rootNode.findFirstNode(ray);
		 if (node == null) {
			 RGBColor color = rt.color[0];
			 TextureSpec surfSpec = rt.surfSpec[0];
			 if (transparentBackground) {
				 rt.transparency[0] = 1.0;
				 color.setRGB(0.0f, 0.0f, 0.0f);
				 return Float.MAX_VALUE;
			 }
			 if (envMode == Scene.ENVIRON_SOLID) {
				 color.copy(envColor);
				 return Float.MAX_VALUE;
			 }
			 envMapping.getTextureSpec(ray.direction, surfSpec, 1.0, smoothScale, time, envParamValue);
			 if (envMode == Scene.ENVIRON_DIFFUSE) color.copy(surfSpec.diffuse);
			 else color.copy(surfSpec.emissive);
			 return Float.MAX_VALUE;
		 }
		 if (!rt.materialAtCameraIsFixed) {
			 rt.materialAtCamera = getMaterialAtPoint(rt, orig, node);
			 rt.materialAtCameraIsFixed = !depth;
		 }
		 if (rt.materialAtCamera == null) return distScale*spawnRay(rt, 0, node, null, null, null, null, null, number, 0.0, true, false);
		 return distScale*spawnRay(rt, 0, node, null, rt.materialAtCamera.getMaterialMapping(), null, rt.materialAtCamera.toLocal(), null, number, 0.0, true, false);
	 }
	 protected RTObject getMaterialAtPoint(RaytracerContext rt, Vec3 pos, OctreeNode node) {
		 if (materialBounds == null || !materialBounds.contains(pos)) return null;
		 Ray r = rt.ray[maxRayDepth];
		 r.origin.set(pos);
		 double len2 = pos.length2();
		 if (len2 > 1e-5) {
			 r.direction.set(pos);
			 r.direction.scale(1.0/Math.sqrt(len2));
		 }
		 else r.direction.set(0.0, 0.0, 1.0);
		 r.newID();
		 int matCount = 0;
		 MaterialIntersection matChange[] = r.rt.matChange;
		 Vec3 trueNorm = r.rt.trueNormal[0];
		 RTObject first, next = null;
		 while (true) {
			 if (next == null) {
				 node = traceRay(r, node);
				 if (node == null) return null;
				 first = rt.intersect.first;
				 next = rt.intersect.second;
			 }
			 else {
				 first = next;
				 next = null;
			 }
			 SurfaceIntersection intersection = rt.lastRayResult[first.index];
			 MaterialMapping mat = first.getMaterialMapping();
			 if (mat != null) {
				 intersection.trueNormal(trueNorm);
				 double angle = -trueNorm.dot(r.getDirection());
				 boolean entered = (angle > 0.0);
				 if (entered) {
					 if (matCount == matChange.length) {
						 rt.increaseMaterialChangeLength();
						 matChange = rt.matChange;
					 }
					 matChange[matCount++].mat = mat;
				 }
				 else if (matCount > 0 && matChange[matCount-1].mat == mat) matCount--;
				 else return first;
			 }
			 if (next == null) {
				 intersection.intersectionPoint(0, r.getOrigin());
				 r.newID();
			 }
		 }
	 }
	 protected double spawnRay(RaytracerContext rt, int treeDepth, OctreeNode node, RTObject first, MaterialMapping currentMaterial, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans, int rayNumber, double totalDist, boolean transmitted, boolean diffuse) {
		 RTObject second = null;
		 double dist, dot, truedot, n, beta = 0.0, d;
		 Vec3 intersectionPoint = rt.pos[treeDepth], norm = rt.normal[treeDepth], trueNorm = rt.trueNormal[treeDepth], temp;
		 boolean totalReflect = false;
		 Ray r = rt.ray[treeDepth];
		 TextureSpec spec = rt.surfSpec[treeDepth];
		 MaterialMapping nextMaterial, oldMaterial;
		 Mat4 nextMatTrans, oldMatTrans = null;
		 RGBColor color = rt.color[treeDepth], rayIntensity = rt.rayIntensity[treeDepth];
		 OctreeNode nextNode;
		 rt.transparency[treeDepth] = 0.0;
		 SurfaceIntersection intersection = SurfaceIntersection.NO_INTERSECTION;
		 if (first != null) {
			 intersection = r.findIntersection(first);
			 if (intersection == SurfaceIntersection.NO_INTERSECTION) {
				 Ray r2 = rt.ray[treeDepth+1];
				 r2.origin.set(r.origin);
				 r2.direction.set(r.direction);
				 r2.origin.x -= TOL*r.direction.x;
				 r2.origin.y -= TOL*r.direction.y;
				 r2.origin.z -= TOL*r.direction.z;
				 intersection = r2.findIntersection(first);
			 }
		 }
		 if (intersection != SurfaceIntersection.NO_INTERSECTION) {
			 intersection.intersectionPoint(0, intersectionPoint);
			 nextNode = rootNode.findNode(intersectionPoint);
		 }
		 else {
			 nextNode = traceRay(r, node);
			 if (nextNode == null) {
				 if (transmitted && transparentBackground) {
					 color.setRGB(0.0f, 0.0f, 0.0f);
					 rt.transparency[treeDepth] = Math.min(Math.min(rayIntensity.getRed(), rayIntensity.getGreen()), rayIntensity.getBlue());
					 return Float.MAX_VALUE;
				 }
				 if (envMode == Scene.ENVIRON_SOLID) {
					 color.copy(envColor);
					 color.multiply(rayIntensity);
					 return Float.MAX_VALUE;
				 }
				 double envSmoothing = (diffuse ? smoothScale*extraGIEnvSmoothing : smoothScale);
				 envMapping.getTextureSpec(r.direction, spec, 1.0, smoothing*envSmoothing, time, envParamValue);
				 if (envMode == Scene.ENVIRON_DIFFUSE) color.copy(spec.diffuse);
				 else color.copy(spec.emissive);
				 color.multiply(rayIntensity);
				 return Float.MAX_VALUE;
			 }
			 first = rt.intersect.first;
			 second = rt.intersect.second;
			 intersection = rt.lastRayResult[first.index];
			 intersection.intersectionPoint(0, intersectionPoint);
		 }
		 if (treeDepth == 0) rt.firstObjectHit = first;
		 dist = intersection.intersectionDist(0);
		 totalDist += dist;
		 intersection.trueNormal(trueNorm);
		 truedot = trueNorm.dot(r.getDirection());
		 double texSmoothing = (diffuse ? smoothScale*extraGISmoothing : smoothScale);
		 if (truedot > 0.0) intersection.intersectionProperties(spec, norm, r.getDirection(), totalDist*texSmoothing*3.0/(2.0+truedot), time);
		 else intersection.intersectionProperties(spec, norm, r.getDirection(), totalDist*texSmoothing*3.0/(2.0-truedot), time);
		 getDirectLight(rt, intersectionPoint, norm, (truedot<0.0), r.getDirection(), treeDepth, nextNode, rayNumber, totalDist, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, diffuse);
		 if (currentMaterial != null) {
			 propagateRay(r, node, dist, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, rt.tempColor, rayIntensity, treeDepth, totalDist);
			 color.multiply(rayIntensity);
			 color.add(rt.tempColor);
		 }
		 else if (fog) {
			 float fract = (float) Math.exp(-dist/fogDist);
			 color.scale(fract);
			 rt.tempColor.copy(fogColor);
			 rt.tempColor.scale(1.0f-fract);
			 color.add(rt.tempColor);
			 color.multiply(rayIntensity);
			 rayIntensity.scale(fract);
		 }
		 else color.multiply(rayIntensity);
		 if (treeDepth == maxRayDepth-1) return dist;
		 if (giMode == GI_AMBIENT_OCCLUSION && diffuse) return dist;
		 boolean spawnSpecular = false, spawnTransmitted = false, spawnDiffuse = false;
		 float specularScale = 1.0f, transmittedScale = 1.0f, diffuseScale = 1.0f;
		 if (roulette) {
			 float prob = (rayIntensity.getRed()*spec.specular.getRed() + rayIntensity.getGreen()*spec.specular.getGreen() + rayIntensity.getBlue()*spec.specular.getBlue())/3.0f;
			 if (prob > rt.random.nextFloat()) {
				 spawnSpecular = true;
				 specularScale = 1.0f/prob;
			 }
			 prob = (rayIntensity.getRed()*spec.transparent.getRed() + rayIntensity.getGreen()*spec.transparent.getGreen() + rayIntensity.getBlue()*spec.transparent.getBlue())/3.0f;
			 if (prob > rt.random.nextFloat()) {
				 spawnTransmitted = true;
				 transmittedScale = 1.0f/prob;
			 }
			 if (giMode == GI_MONTE_CARLO || giMode == GI_AMBIENT_OCCLUSION || (giMode == GI_HYBRID && !diffuse)) {
				 prob = (rayIntensity.getRed()*spec.diffuse.getRed() + rayIntensity.getGreen()*spec.diffuse.getGreen() + rayIntensity.getBlue()*spec.diffuse.getBlue())/3.0f;
				 if (prob > rt.random.nextFloat()) {
					 spawnDiffuse = true;
					 diffuseScale = 1.0f/prob;
				 }
			 }
		 }
		 else {
			 spawnSpecular = (rayIntensity.getRed()*spec.specular.getRed() > minRayIntensity || rayIntensity.getGreen()*spec.specular.getGreen() > minRayIntensity || rayIntensity.getBlue()*spec.specular.getBlue() > minRayIntensity);
			 spawnTransmitted = (rayIntensity.getRed()*spec.transparent.getRed() > minRayIntensity || rayIntensity.getGreen()*spec.transparent.getGreen() > minRayIntensity || rayIntensity.getBlue()*spec.transparent.getBlue() > minRayIntensity);
			 if (giMode == GI_MONTE_CARLO || giMode == GI_AMBIENT_OCCLUSION || (giMode == GI_HYBRID && !diffuse)) spawnDiffuse = (rayIntensity.getRed()*spec.diffuse.getRed() > minRayIntensity || rayIntensity.getGreen()*spec.diffuse.getGreen() > minRayIntensity || rayIntensity.getBlue()*spec.diffuse.getBlue() > minRayIntensity);
		 }
		 dot = norm.dot(r.getDirection());
		 RGBColor col = rt.rayIntensity[treeDepth+1];
		 if (spawnTransmitted) {
			 col.copy(rayIntensity);
			 col.multiply(spec.transparent);
			 col.scale(transmittedScale);
			 rt.ray[treeDepth+1].getOrigin().set(intersectionPoint);
			 temp = rt.ray[treeDepth+1].getDirection();
			 if (first.getMaterialMapping() == null) {
				 temp.set(r.getDirection());
				 nextMaterial = currentMaterial;
				 nextMatTrans = currentMatTrans;
				 oldMaterial = prevMaterial;
				 oldMatTrans = prevMatTrans;
			 }
			 else if (truedot < 0.0) {
				 nextMaterial = first.getMaterialMapping();
				 nextMatTrans = first.toLocal();
				 oldMaterial = currentMaterial;
				 oldMatTrans = currentMatTrans;
				 if (currentMaterial == null) n = nextMaterial.indexOfRefraction();
				 else n = nextMaterial.indexOfRefraction()/currentMaterial.indexOfRefraction();
				 beta = -(dot+Math.sqrt(n*n-1.0+dot*dot));
				 temp.set(norm);
				 temp.scale(beta);
				 temp.add(r.getDirection());
				 temp.scale(1.0/n);
			 }
			 else {
				 if (currentMaterial == first.getMaterialMapping()) {
					 nextMaterial = prevMaterial;
					 nextMatTrans = prevMatTrans;
					 oldMaterial = null;
					 if (nextMaterial == null) n = 1.0/currentMaterial.indexOfRefraction();
					 else n = nextMaterial.indexOfRefraction()/currentMaterial.indexOfRefraction();
				 }
				 else {
					 nextMaterial = currentMaterial;
					 nextMatTrans = currentMatTrans;
					 if (prevMaterial == first.getMaterialMapping()) oldMaterial = null;
					 else {
						 oldMaterial = prevMaterial;
						 oldMatTrans = prevMatTrans;
					 }
					 n = 1.0;
				 }
				 beta = dot-Math.sqrt(n*n-1.0+dot*dot);
				 temp.set(norm);
				 temp.scale(-beta);
				 temp.add(r.getDirection());
				 temp.scale(1.0/n);
			 }
			 if (Double.isNaN(beta)) totalReflect = true;
			 else {
				 d = (truedot > 0.0 ? temp.dot(trueNorm) : -temp.dot(trueNorm));
				 if (d < 0.0) {
					 d += TOL;
					 temp.x -= d*trueNorm.x;
					 temp.y -= d*trueNorm.y;
					 temp.z -= d*trueNorm.z;
					 temp.normalize();
				 }
				 rt.ray[treeDepth+1].newID();
				 if (gloss) randomizeDirection(temp, norm, rt.random, spec.cloudiness, rayNumber+treeDepth+1);
				 spawnRay(rt, treeDepth+1, nextNode, second, nextMaterial, oldMaterial, nextMatTrans, oldMatTrans, rayNumber, totalDist, transmitted, diffuse);
				 color.add(rt.color[treeDepth+1]);
				 if (transmitted && transparentBackground) rt.transparency[treeDepth] = rt.transparency[treeDepth+1];
			 }
		 }
		 if (spawnSpecular || totalReflect) {
			 col.copy(spec.specular);
			 col.scale(specularScale);
			 if (totalReflect) col.add(spec.transparent.getRed()*transmittedScale, spec.transparent.getGreen()*transmittedScale, spec.transparent.getBlue()*transmittedScale);
			 col.multiply(rayIntensity);
			 temp = rt.ray[treeDepth+1].getDirection();
			 temp.set(norm);
			 temp.scale(-2.0*dot);
			 temp.add(r.getDirection());
			 d = (truedot > 0.0 ? temp.dot(trueNorm) : -temp.dot(trueNorm));
			 if (d >= 0.0) {
				 d += TOL;
				 temp.x += d*trueNorm.x;
				 temp.y += d*trueNorm.y;
				 temp.z += d*trueNorm.z;
				 temp.normalize();
			 }
			 rt.ray[treeDepth+1].getOrigin().set(intersectionPoint);
			 rt.ray[treeDepth+1].newID();
			 if (gloss) randomizeDirection(temp, norm, rt.random, spec.roughness, rayNumber+treeDepth+1);
			 spawnRay(rt, treeDepth+1, nextNode, null, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, rayNumber, totalDist, false, diffuse);
			 color.add(rt.color[treeDepth+1]);
		 }
		 if (spawnDiffuse) {
			 int numRays = (diffuse ? 1 : diffuseRays);
			 col.copy(spec.diffuse);
			 col.multiply(rayIntensity);
			 col.scale(diffuseScale);
			 temp = rt.ray[treeDepth+1].getDirection();
			 for (int i = 0;
			 i < numRays;
			 i++) {
				 do {
					 temp.set(0.0, 0.0, 0.0);
					 randomizePoint(temp, rt.random, 1.0, rayNumber+treeDepth+1+i);
					 temp.normalize();
					 d = temp.dot(trueNorm) * (truedot > 0.0 ? 1.0 : -1.0);
				 }
				 while (rt.random.nextDouble() > (d < 0.0 ? -d : d));
				 if (d > 0.0) {
					 temp.scale(-1.0);
				 }
				 rt.ray[treeDepth+1].getOrigin().set(intersectionPoint);
				 rt.ray[treeDepth+1].newID();
				 spawnRay(rt, treeDepth+1, nextNode, null, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans, rayNumber, totalDist, false, true);
				 rt.color[treeDepth+1].scale(1.0f/numRays);
				 color.add(rt.color[treeDepth+1]);
			 }
		 }
		 return dist;
	 }
	 protected void getDirectLight(RaytracerContext rt, Vec3 pos, Vec3 normal, boolean front, Vec3 viewDir, int treeDepth, OctreeNode node, int rayNumber, double totalDist, MaterialMapping currentMaterial, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans, boolean diffuse) {
		 int i;
		 RGBColor lightColor = rt.color[treeDepth+1], finalColor = rt.color[treeDepth];
		 TextureSpec spec = rt.surfSpec[treeDepth];
		 Vec3 dir;
		 Ray r = rt.ray[treeDepth+1];
		 double sign, distToLight, dot;
		 boolean hilight;
		 Light lt;
		 finalColor.copy(ambColor);
		 finalColor.multiply(spec.diffuse);
		 finalColor.add(spec.emissive);
		 if (giMode == GI_AMBIENT_OCCLUSION && diffuse) return;
		 if (giMode == GI_HYBRID && diffuse) {
			 rt.globalMap.getLight(pos, spec, normal, viewDir, front, lightColor);
			 finalColor.add(lightColor);
			 return;
		 }
		 if (giMode == GI_PHOTON) {
			 rt.globalMap.getLight(pos, spec, normal, viewDir, front, lightColor);
			 finalColor.add(lightColor);
		 }
		 if (caustics) {
			 rt.causticsMap.getLight(pos, spec, normal, viewDir, front, lightColor);
			 finalColor.add(lightColor);
		 }
		 dir = r.getDirection();
		 sign = front ? 1.0 : -1.0;
		 hilight = (spec.hilight.getRed() != 0.0 || spec.hilight.getGreen() != 0.0 || spec.hilight.getBlue() != 0.0);
		 for (i = light.length-1;
		 i >= 0;
		 i--) {
			 lt = light[i].getLight();
			 distToLight = light[i].findRayToLight(pos, r, rayNumber+treeDepth+1);
			 r.newID();
			 if (lt.getType() == Light.TYPE_AMBIENT) dot = 1.0;
			 else dot = sign*dir.dot(normal);
			 if (dot > 0.0) {
				 lt.getLight(lightColor, light[i].getCoords().toLocal().times(pos));
				 if (lightColor.getRed()*(spec.diffuse.getRed()*dot+spec.hilight.getRed()) < minRayIntensity && lightColor.getGreen()*(spec.diffuse.getGreen()*dot+spec.hilight.getGreen()) < minRayIntensity && lightColor.getBlue()*(spec.diffuse.getBlue()*dot+spec.hilight.getBlue()) < minRayIntensity) continue;
				 if (lt.getType() == Light.TYPE_AMBIENT || lt.getType() == Light.TYPE_SHADOWLESS || traceLightRay(r, lt, treeDepth+1, node, lightNode[i], distToLight, totalDist, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans)) {
					 RGBColor tempColor = rt.tempColor;
					 tempColor.copy(lightColor);
					 tempColor.multiply(spec.diffuse);
					 tempColor.scale(dot);
					 finalColor.add(tempColor);
					 if (hilight) {
						 dir.subtract(viewDir);
						 dir.normalize();
						 dot = sign*dir.dot(normal);
						 if (dot > 0.0) {
							 tempColor.copy(lightColor);
							 tempColor.multiply(spec.hilight);
							 tempColor.scale(FastMath.pow(dot, (int) ((1.0-spec.roughness)*128.0)+1));
							 finalColor.add(tempColor);
						 }
					 }
				 }
			 }
		 }
	 }
	 protected OctreeNode traceRay(Ray r, OctreeNode node) {
		 RTObject first = null, second = null, obj[];
		 double dist, firstDist = Double.MAX_VALUE, secondDist = Double.MAX_VALUE;
		 Vec3 intersectionPoint = r.rt.pos[maxRayDepth];
		 int i;
		 while (first == null) {
			 obj = node.getObjects();
			 for (i = obj.length-1;
			 i >= 0;
			 i--) {
				 SurfaceIntersection intersection = r.findIntersection(obj[i]);
				 if (intersection != SurfaceIntersection.NO_INTERSECTION) {
					 intersection.intersectionPoint(0, intersectionPoint);
					 if (node.contains(intersectionPoint)) {
						 dist = intersection.intersectionDist(0);
						 if (dist < firstDist) {
							 secondDist = firstDist;
							 second = first;
							 firstDist = dist;
							 first = obj[i];
						 }
						 else if (dist < secondDist) {
							 secondDist = dist;
							 second = obj[i];
						 }
					 }
				 }
			 }
			 if (first == null) {
				 node = node.findNextNode(r);
				 if (node == null) return null;
			 }
		 }
		 RayIntersection intersect = r.rt.intersect;
		 intersect.first = first;
		 intersect.dist = firstDist;
		 if (secondDist-firstDist < TOL) intersect.second = second;
		 else intersect.second = null;
		 return node;
	 }
	 protected boolean traceLightRay(Ray r, Light lt, int treeDepth, OctreeNode node, OctreeNode endNode, double distToLight, double totalDist, MaterialMapping currentMaterial, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans) {
		 RGBColor lightColor = r.rt.color[treeDepth], transColor = r.rt.surfSpec[treeDepth].transparent;
		 Vec3 intersectionPoint = r.rt.pos[maxRayDepth], trueNorm = r.rt.trueNormal[maxRayDepth];
		 MaterialIntersection matChange[] = r.rt.matChange;
		 int i, j, matCount = 0;
		 do {
			 RTObject obj[] = node.getObjects();
			 for (i = obj.length-1;
			 i >= 0;
			 i--) {
				 SurfaceIntersection intersection = r.findIntersection(obj[i]);
				 if (intersection != SurfaceIntersection.NO_INTERSECTION) for (j = 0;
				 ;
				 j++) {
					 intersection.intersectionPoint(j, intersectionPoint);
					 if (node.contains(intersectionPoint)) {
						 double dist = intersection.intersectionDist(j);
						 if (dist < distToLight) {
							 intersection.trueNormal(trueNorm);
							 double angle = -trueNorm.dot(r.getDirection());
							 intersection.intersectionTransparency(j, transColor, angle, (totalDist+dist)*smoothScale, time);
							 lightColor.multiply(transColor);
							 if (lightColor.getRed() < minRayIntensity && lightColor.getGreen() < minRayIntensity && lightColor.getBlue() < minRayIntensity) return false;
							 MaterialMapping mat = obj[i].getMaterialMapping();
							 if (mat != null && mat.castsShadows()) {
								 if (matCount == matChange.length) {
									 r.rt.increaseMaterialChangeLength();
									 matChange = r.rt.matChange;
								 }
								 matChange[matCount].mat = mat;
								 matChange[matCount].toLocal = obj[i].toLocal();
								 matChange[matCount].dist = dist;
								 matChange[matCount].node = node;
								 matChange[matCount].entered = (angle > 0.0)^(j%2==1);
								 matCount++;
							 }
						 }
					 }
					 if (j >= intersection.numIntersections()-1) break;
				 }
			 }
			 if (node == endNode) break;
			 node = node.findNextNode(r);
		 }
		 while (node != null);
		 if (currentMaterial == null && matCount == 0) return true;
		 sortMaterialList(matChange, matCount);
		 if (matCount == matChange.length) {
			 r.rt.increaseMaterialChangeLength();
			 matChange = r.rt.matChange;
		 }
		 matChange[matCount++].dist = distToLight;
		 double dist = 0.0;
		 for (i = 0;
		 ;
		 i++) {
			 if (currentMaterial != null && currentMaterial.castsShadows()) {
				 propagateLightRay(r, node, dist, matChange[i].dist, currentMaterial, lightColor, currentMatTrans, totalDist);
				 if (lightColor.getRed() < minRayIntensity && lightColor.getGreen() < minRayIntensity && lightColor.getBlue() < minRayIntensity) return false;
			 }
			 if (i == matCount-1) break;
			 double n1 = (currentMaterial == null ? 1.0 : currentMaterial.indexOfRefraction());
			 if (matChange[i].entered) {
				 if (matChange[i].mat != currentMaterial) {
					 prevMaterial = currentMaterial;
					 prevMatTrans = currentMatTrans;
					 currentMaterial = matChange[i].mat;
					 currentMatTrans = matChange[i].toLocal;
				 }
			 }
			 else if (matChange[i].mat == currentMaterial) {
				 currentMaterial = prevMaterial;
				 currentMatTrans = prevMatTrans;
				 prevMaterial = null;
			 }
			 else if (matChange[i].mat == prevMaterial) prevMaterial = null;
			 if (caustics) {
				 double n2 = (currentMaterial == null ? 1.0 : currentMaterial.indexOfRefraction());
				 if (n1 != n2) return false;
			 }
			 node = matChange[i].node;
			 dist = matChange[i].dist;
		 }
		 return true;
	 }
	 protected void propagateRay(Ray r, OctreeNode node, double dist, MaterialMapping material, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans, RGBColor emitted, RGBColor filter, int treeDepth, double totalDist) {
		 boolean scattering = material.isScattering();
		 MaterialSpec matSpec = r.rt.matSpec;
		 float re, ge, be, rs, gs, bs;
		 float rf = filter.getRed(), gf = filter.getGreen(), bf = filter.getBlue();
		 if (material instanceof UniformMaterialMapping && !scattering) {
			 material.getMaterialSpec(r.origin, matSpec, 0.0, time);
			 RGBColor trans = matSpec.transparency, blend = matSpec.color;
			 float d = (float) dist;
			 if (trans.getRed() == 1.0f) rs = 1.0f;
			 else rs = (float) Math.pow(trans.getRed(), d);
			 if (trans.getGreen() == 1.0f) gs = 1.0f;
			 else gs = (float) Math.pow(trans.getGreen(), d);
			 if (trans.getBlue() == 1.0f) bs = 1.0f;
			 else bs = (float) Math.pow(trans.getBlue(), d);
			 re = blend.getRed()*rf*(1.0f-rs);
			 ge = blend.getGreen()*gf*(1.0f-gs);
			 be = blend.getBlue()*bf*(1.0f-bs);
			 rf *= rs;
			 gf *= gs;
			 bf *= bs;
		 }
		 else {
			 Vec3 v = r.rt.ray[treeDepth+1].origin, origin = r.origin, direction = r.direction;
			 double x = 0.0, newx, dx, distToScreen = theCamera.getDistToScreen(), step;
			 double origx, origy, origz, dirx, diry, dirz;
			 v.set(origin);
			 currentMatTrans.transform(v);
			 origx = v.x;
			 origy = v.y;
			 origz = v.z;
			 v.set(direction);
			 currentMatTrans.transformDirection(v);
			 dirx = v.x;
			 diry = v.y;
			 dirz = v.z;
			 re = ge = be = 0.0f;
			 step = stepSize*material.getStepSize();
			 do {
				 dx = step*(1.5*r.rt.random.nextDouble());
				 if (adaptive && totalDist > distToScreen) dx *= totalDist/distToScreen;
				 newx = x+dx;
				 if (newx > dist) {
					 dx = dist-x;
					 x = dist;
				 }
				 else x = newx;
				 totalDist += dx;
				 v.set(origx+dirx*x, origy+diry*x, origz+dirz*x);
				 material.getMaterialSpec(v, matSpec, dx, time);
				 RGBColor trans = matSpec.transparency, blend = matSpec.color;
				 if (trans.getRed() == 1.0f) rs = 1.0f;
				 else rs = (float) Math.pow(trans.getRed(), dx);
				 if (trans.getGreen() == 1.0f) gs = 1.0f;
				 else gs = (float) Math.pow(trans.getGreen(), dx);
				 if (trans.getBlue() == 1.0f) bs = 1.0f;
				 else bs = (float) Math.pow(trans.getBlue(), dx);
				 re += blend.getRed()*rf*(1.0f-rs);
				 ge += blend.getGreen()*gf*(1.0f-gs);
				 be += blend.getBlue()*bf*(1.0f-bs);
				 if (scattering) {
					 RGBColor rayIntensity = r.rt.rayIntensity[treeDepth+1];
					 rayIntensity.setRGB(rf, gf, bf);
					 rayIntensity.multiply(matSpec.scattering);
					 if (rayIntensity.getRed() > minRayIntensity || rayIntensity.getGreen() > minRayIntensity || rayIntensity.getBlue() > minRayIntensity) {
						 if (scatterMode == SCATTER_SINGLE || scatterMode == SCATTER_BOTH) {
							 v.set(origin.x+direction.x*x, origin.y+direction.y*x, origin.z+direction.z*x);
							 while (node != null && !node.contains(v)) node = node.findNextNode(r);
							 if (node == null) break;
							 getScatteredLight(r.rt, treeDepth+1, node, matSpec.eccentricity, totalDist, material, prevMaterial, currentMatTrans, prevMatTrans);
							 RGBColor color = r.rt.color[treeDepth+1];
							 re += color.getRed()*(1.0f-rs);
							 ge += color.getGreen()*(1.0f-gs);
							 be += color.getBlue()*(1.0f-bs);
						 }
						 if (r.rt.volumeMap != null) {
							 RGBColor color = r.rt.color[treeDepth+1];
							 r.rt.volumeMap.getVolumeLight(v, matSpec, r.getDirection(), color);
							 color.multiply(rayIntensity);
							 re += color.getRed()*(1.0f-rs);
							 ge += color.getGreen()*(1.0f-gs);
							 be += color.getBlue()*(1.0f-bs);
						 }
					 }
				 }
				 rf *= rs;
				 gf *= gs;
				 bf *= bs;
				 if (rf < minRayIntensity && gf < minRayIntensity && bf < minRayIntensity) {
					 rf = gf = bf = 0.0f;
					 break;
				 }
			 }
			 while (x < dist);
		 }
		 emitted.setRGB(re, ge, be);
		 filter.setRGB(rf, gf, bf);
	 }
	 protected void propagateLightRay(Ray r, OctreeNode node, double startDist, double endDist, MaterialMapping material, RGBColor filter, Mat4 toLocal, double totalDist) {
		 float rf = filter.getRed(), gf = filter.getGreen(), bf = filter.getBlue();
		 MaterialSpec matSpec = r.rt.matSpec;
		 if (material instanceof UniformMaterialMapping) {
			 material.getMaterialSpec(r.origin, matSpec, 0.0, time);
			 RGBColor trans = matSpec.transparency;
			 float d = (float) (endDist-startDist);
			 if (trans.getRed() != 1.0f) rf *= (float) Math.pow(trans.getRed(), d);
			 if (trans.getGreen() != 1.0f) gf *= (float) Math.pow(trans.getGreen(), d);
			 if (trans.getBlue() != 1.0f) bf *= (float) Math.pow(trans.getBlue(), d);
		 }
		 else {
			 Vec3 v = r.rt.ray[maxRayDepth].origin;
			 double x = startDist, newx, dx, distToScreen = theCamera.getDistToScreen(), step;
			 double origx, origy, origz, dirx, diry, dirz;
			 v.set(r.origin);
			 toLocal.transform(v);
			 origx = v.x;
			 origy = v.y;
			 origz = v.z;
			 v.set(r.direction);
			 toLocal.transformDirection(v);
			 dirx = v.x;
			 diry = v.y;
			 dirz = v.z;
			 step = stepSize*material.getStepSize();
			 do {
				 dx = step*(1.5*r.rt.random.nextDouble());
				 if (adaptive && totalDist > distToScreen) dx *= totalDist/distToScreen;
				 newx = x+dx;
				 if (newx > endDist) {
					 dx = endDist-x;
					 x = endDist;
				 }
				 else x = newx;
				 totalDist += dx;
				 v.set(origx+dirx*x, origy+diry*x, origz+dirz*x);
				 material.getMaterialSpec(v, matSpec, dx, time);
				 RGBColor trans = matSpec.transparency;
				 if (trans.getRed() != 1.0f) rf *= (float) Math.pow(trans.getRed(), dx);
				 if (trans.getGreen() != 1.0f) gf *= (float) Math.pow(trans.getGreen(), dx);
				 if (trans.getBlue() != 1.0f) bf *= (float) Math.pow(trans.getBlue(), dx);
				 if (rf < minRayIntensity && gf < minRayIntensity && bf < minRayIntensity) {
					 rf = gf = bf = 0.0f;
					 break;
				 }
			 }
			 while (x < endDist);
		 }
		 filter.setRGB(rf, gf, bf);
	 }
	 protected void getScatteredLight(RaytracerContext rt, int treeDepth, OctreeNode node, double eccentricity, double totalDist, MaterialMapping currentMaterial, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans) {
		 int i;
		 RGBColor filter = rt.rayIntensity[treeDepth], lightColor = rt.color[treeDepth];
		 Ray r = rt.ray[treeDepth];
		 Vec3 dir, pos = r.origin, viewDir = rt.ray[treeDepth-1].direction;
		 double distToLight, fatt, dot;
		 double ec2 = eccentricity*eccentricity;
		 Light lt;
		 rt.tempColor2.setRGB(0.0f, 0.0f, 0.0f);
		 dir = r.getDirection();
		 for (i = light.length-1;
		 i >= 0;
		 i--) {
			 lt = light[i].getLight();
			 distToLight = light[i].findRayToLight(pos, r, -1);
			 r.newID();
			 lt.getLight(lightColor, light[i].getCoords().toLocal().times(pos));
			 lightColor.multiply(filter);
			 if (eccentricity != 0.0 && lt.getType() != Light.TYPE_AMBIENT) {
				 dot = dir.dot(viewDir);
				 fatt = (1.0-ec2)/Math.pow(1.0+ec2-2.0*eccentricity*dot, 1.5);
				 lightColor.scale(fatt);
			 }
			 if (lightColor.getRed() < minRayIntensity && lightColor.getGreen() < minRayIntensity && lightColor.getBlue() < minRayIntensity) continue;
			 if (lt.getType() == Light.TYPE_AMBIENT || lt.getType() == Light.TYPE_SHADOWLESS || traceLightRay(r, lt, treeDepth, node, lightNode[i], distToLight, totalDist, currentMaterial, prevMaterial, currentMatTrans, prevMatTrans)) rt.tempColor2.add(lightColor);
		 }
		 rt.color[treeDepth].copy(rt.tempColor2);
	 }
	 public void randomizePoint(Vec3 pos, Random random, double size, int number) {
		 double x, y, z;
		 int d;
		 if (size == 0.0) return;
		 do {
			 x = random.nextDouble();
			 y = random.nextDouble();
			 z = random.nextDouble();
		 }
		 while (x*x + y*y + z*z > 1.0);
		 x *= size;
		 y *= size;
		 z *= size;
		 d = distrib1[number&15];
		 if (d < 2) x *= -1.0;
		 if (d == 1 || d == 2) y *= -1.0;
		 if ((distrib2[number&15]&1) == 0) z *= -1.0;
		 pos.x += x;
		 pos.y += y;
		 pos.z += z;
	 }
	 public void randomizeDirection(Vec3 dir, Vec3 norm, Random random, double roughness, int number) {
		 double x, y, z, scale, dot1, dot2;
		 int d;
		 if (roughness <= 0.0) return;
		 do {
			 x = random.nextDouble();
			 y = random.nextDouble();
			 z = random.nextDouble();
		 }
		 while (x*x + y*y + z*z > 1.0);
		 scale = Math.pow(roughness, 1.7)*0.5;
		 x *= scale;
		 y *= scale;
		 z *= scale;
		 d = distrib1[number&15];
		 if (d < 2) x *= -1.0;
		 if (d == 1 || d == 2) y *= -1.0;
		 if ((distrib2[number&15]&1) == 0) z *= -1.0;
		 dot1 = dir.dot(norm);
		 dir.x += x;
		 dir.y += y;
		 dir.z += z;
		 dot2 = 2.0*dir.dot(norm);
		 if (dot1 < 0.0 && dot2 > 0.0) {
			 dir.x -= dot2*norm.x;
			 dir.y -= dot2*norm.y;
			 dir.z -= dot2*norm.z;
		 }
		 else if (dot1 > 0.0 && dot2 < 0.0) {
			 dir.x += dot2*norm.x;
			 dir.y += dot2*norm.y;
			 dir.z += dot2*norm.z;
		 }
		 dir.normalize();
	 }
	 protected void sortMaterialList(MaterialIntersection matChange[], int count) {
		 for (int i = 1;
		 i < count;
		 i++) for (int j = i;
		 j > 0 && matChange[j].dist < matChange[j-1].dist;
		 j--) {
			 MaterialIntersection temp = matChange[j-1];
			 matChange[j-1] = matChange[j];
			 matChange[j] = temp;
		 }
	 }
}",1,0,0,0
"final void notifyComponentInstantiationListeners(final Component component){
	final int len = componentInstantiationListeners.length;
	for (int i = 0;
	 i < len;
	 i++){
		componentInstantiationListeners[i].onInstantiation(component);
	}
}",0,0,0,0
"public interface CompilationIdentifier {
	 enum Verbosity {
	 ID, NAME, DETAILED }
	 CompilationRequestIdentifier INVALID_COMPILATION_ID = new CompilationRequestIdentifier() {
		 public String toString() {
			 return toString(Verbosity.DETAILED);
		 }
		 public String toString(Verbosity verbosity) {
			 return ""InvalidCompilationID"";
		 }
		 public CompilationRequest getRequest() {
			 return null;
		 }
	 }
	;
	 String toString();
	 String toString(Verbosity verbosity);
}",0,1,0,0
"public final class CurrentCreationalContext<T> {
	 private final ThreadLocal<CreationalContext<T>> creationalContext = new ThreadLocal<CreationalContext<T>>();
	 public CreationalContext<T> get() {
		 return creationalContext.get();
	 }
	 public void set(CreationalContext<T> value) {
		 creationalContext.set(value);
	 }
	 public void remove() {
		 creationalContext.remove();
	 }
}",1,1,0,0
"public class SystemLoggingModule extends BaseLoggingModule implements LoggingModule {
	 public Level getDefaultLevel() {
		 return Level.INFO;
	 }
	 public String getId() {
		 return ""system"";
	 }
	 public String getName() {
		 return ""System"";
	 }
	 public Collection<String> getPackages() {
		 return ImmutableSet.of( ""org.apache.marmotta.platform.core.filters"", ""org.apache.marmotta.platform.core.startup"", ""org.apache.marmotta.platform.core.servlet"", ""org.apache.marmotta.platform.core.services.modules"", ""org.apache.marmotta.platform.core.webservices.system"", ""org.apache.marmotta.platform.core.jndi"", ""org.apache.marmotta.platform.core.jaxrs"", ""org.apache.marmotta.platform.core.util"" );
	 }
}",0,0,0,0
"static BinaryOutputArchive getArchive(OutputStream strm) {
	 return new BinaryOutputArchive(new DataOutputStream(strm));
 }",0,0,0,0
"public class StaticThemeTemplate implements ThemeTemplate, Serializable {
	 private String id = null;
	 private String name = null;
	 private String description = null;
	 private String action = null;
	 private String link = null;
	 private String contents = null;
	 private boolean hidden = false;
	 private boolean navbar = false;
	 private Date lastModified = new Date();
	 private String templateLanguage = null;
	 private String outputContentType = null;
	 private String decoratorName = null;
	 private ThemeTemplate decorator = null;
	 public StaticThemeTemplate(String id, String lang) {
		 this.id = id;
		 this.name = id;
		 this.description = id;
		 this.link = id;
		 this.templateLanguage = lang;
	 }
	 public String getId() {
		 return id;
	 }
	 public void setId(String id) {
		 this.id = id;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public Date getLastModified() {
		 return lastModified;
	 }
	 public void setLastModified(Date lastModified) {
		 this.lastModified = lastModified;
	 }
	 public String getTemplateLanguage() {
		 return templateLanguage;
	 }
	 public void setTemplateLanguage(String templateLanguage) {
		 this.templateLanguage = templateLanguage;
	 }
	 public String getOutputContentType() {
		 return outputContentType;
	 }
	 public void setOutputContentType(String outputContentType) {
		 this.outputContentType = outputContentType;
	 }
	 public String getAction() {
		 return action;
	 }
	 public void setAction(String action) {
		 this.action = action;
	 }
	 public String getLink() {
		 return link;
	 }
	 public void setLink(String link) {
		 this.link = link;
	 }
	 public boolean isHidden() {
		 return hidden;
	 }
	 public void setHidden(boolean hidden) {
		 this.hidden = hidden;
	 }
	 public boolean isNavbar() {
		 return navbar;
	 }
	 public void setNavbar(boolean navbar) {
		 this.navbar = navbar;
	 }
	 public ThemeTemplate getDecorator() {
		 return decorator;
	 }
	 public void setDecorator(ThemeTemplate decorator) {
		 this.decorator = decorator;
	 }
	 public String getContents() {
		 return contents;
	 }
	 public void setContents(String contents) {
		 this.contents = contents;
	 }
	 public String getDecoratorName() {
		 return decoratorName;
	 }
	 public void setDecoratorName(String decoratorName) {
		 this.decoratorName = decoratorName;
	 }
}",0,1,0,0
"protected JRGridLayout(ExporterNature nature,ElementWrapper[] wrappers,int width,int height,int offsetX,int offsetY,String address);",0,0,0,1
"public void close() throws IOException {
	 pagedb.close();
 }
 public synchronized void close() throws IOException {
	 CloseProcessor pagesByURLProcessor = new PagesByURLProcessor(pagesByURL, pagesByURLWriter, pagesByMD5Writer);
	 long numPBUItems = pagesByURLProcessor.closeDown(tmpDir, newDbDir);
	 CloseProcessor pagesByMD5Processor = new PagesByMD5Processor(pagesByMD5, pagesByMD5Writer);
	 long numPBMItems = pagesByMD5Processor.closeDown(tmpDir, newDbDir);
	 CloseProcessor linksByMD5Processor = new LinksByMD5Processor(linksByMD5, linksByMD5Writer, linksByURLWriter);
	 long numLBMItems = linksByMD5Processor.closeDown(tmpDir, newDbDir);
	 EditSectionGroupWriter targetOutlinkEditsWriter = new EditSectionGroupWriter(nfs, machineNum, totalMachines, LINKS_BY_MD5, LinkInstruction.class, NullWritable.class, new EditSectionGroupWriter.LinkMD5Extractor());
	 File newSectionDir = new File(newDbDir, ""dbsection."" + machineNum);
	 File newPagesByURL = new File(newSectionDir, PAGES_BY_URL);
	 CloseProcessor linksByURLProcessor = new LinksByURLProcessor(linksByURL, linksByURLWriter, new MapFile.Reader(nfs, newPagesByURL.getPath(), new UTF8.Comparator()), targetOutlinkEditsWriter);
	 long numLBUItems = linksByURLProcessor.closeDown(tmpDir, newDbDir);
	 if (numLBUItems != 0) {
		 File newLinksByMD5 = new File(newSectionDir, LINKS_BY_MD5);
		 MapFile.Reader linksByMD5ForStageTwo = new MapFile.Reader(nfs, newLinksByMD5.getPath(), new Link.MD5Comparator());
		 File stageTwoDbDir = new File(newDbDir, ""stage2.subdir"");
		 CloseProcessor linksByMD5StageTwoProcessor = new LinksByMD5Processor(linksByMD5ForStageTwo, targetOutlinkEditsWriter, null);
		 numLBMItems = linksByMD5StageTwoProcessor.closeDown(tmpDir, stageTwoDbDir);
		 linksByMD5ForStageTwo.close();
		 File stageOneLinksByMD5 = new File(newDbDir, LINKS_BY_MD5);
		 File stageTwoLinksByMD5 = new File(stageTwoDbDir, LINKS_BY_MD5);
		 nfs.delete(stageOneLinksByMD5);
		 nfs.rename(stageTwoLinksByMD5, stageOneLinksByMD5);
	 }
	 File sectionStats = new File(newSectionDir, STATS_FILE);
	 DataOutputStream out = new DataOutputStream(nfs.create(sectionStats, true));
	 try {
		 out.write(CUR_VERSION);
		 out.writeLong(numPBUItems);
		 out.writeLong(numLBMItems);
	 }
	 finally {
		 out.close();
	 }
	 pagesByURL.close();
	 pagesByMD5.close();
	 linksByMD5.close();
	 linksByURL.close();
	 nfs.lock(globalWriteLock, true);
	 int numCloses = 0;
	 if (nfs.exists(closeCounter)) {
		 DataInputStream in = new DataInputStream(nfs.open(closeCounter));
		 try {
			 in.read();
			 numCloses = in.readInt();
		 }
		 finally {
			 in.close();
		 }
	 }
	 if (numCloses == totalMachines) {
		 throw new IOException(""All the processors have already shut down. Impossible condition!"");
	 }
	 out = new DataOutputStream(nfs.create(closeCounter, true));
	 try {
		 out.write(CLOSE_COUNTER_VERSION);
		 out.writeInt(numCloses + 1);
	 }
	 finally {
		 out.close();
	 }
	 if (numCloses == totalMachines - 1) {
		 for (int i = 0;
		 i < totalMachines;
		 i++) {
			 new EditSectionGroupReader(nfs, PAGES_BY_URL, i, totalMachines).delete();
			 new EditSectionGroupReader(nfs, PAGES_BY_MD5, i, totalMachines).delete();
			 new EditSectionGroupReader(nfs, LINKS_BY_URL, i, totalMachines).delete();
			 new EditSectionGroupReader(nfs, LINKS_BY_MD5, i, totalMachines).delete();
		 }
		 File dirIsComplete = new File(newDbDir, ""dbIsComplete"");
		 out = new DataOutputStream(nfs.create(dirIsComplete));
		 try {
			 out.writeInt(IS_COMPLETE);
		 }
		 finally {
			 out.close();
		 }
		 nfs.delete(tmpDir);
		 nfs.rename(dbDir, oldDbDir);
		 nfs.rename(newDbDir, dbDir);
		 nfs.delete(oldDbDir);
	 }
	 nfs.release(globalWriteLock);
	 nfs.release(localWriteLock);
 }",0,0,1,0
"public class ApplicationResource extends AbstractContextResource {
	 private static final Logger logger = LoggerFactory.getLogger(ApplicationResource.class);
	 public static final String CONFIRM_APPLICATION_IDENTIFIER = ""confirm_application_identifier"";
	 public static final String RESTORE_PASSWORD = ""restore_password"";
	 OrganizationInfo organization;
	 UUID applicationId;
	 ApplicationInfo application;
	 private SignInProviderFactory signInProviderFactory;
	 public ApplicationResource() {
	 }
	 public ApplicationResource init( OrganizationInfo organization, UUID applicationId ) {
		 this.organization = organization;
		 this.applicationId = applicationId;
		 return this;
	 }
	 public ApplicationResource init( OrganizationInfo organization, ApplicationInfo application ) {
		 this.organization = organization;
		 applicationId = application.getId();
		 this.application = application;
		 return this;
	 }
	 public ApiResponse getApplication( UriInfo ui, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 ServiceManager sm = smf.getServiceManager( applicationId );
		 response.setAction( ""get"" );
		 response.setApplication( sm.getApplication() );
		 response.setParams( ui.getQueryParameters() );
		 response.setResults( management.getApplicationMetadata( applicationId ) );
		 return response;
	 }
	 public ApiResponse getCredentials( UriInfo ui, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 response.setAction(""get application client credentials"");
		 ClientCredentialsInfo credentials = new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ), management.getClientSecretForApplication( applicationId ) );
		 response.setCredentials( credentials );
		 return response;
	 }
	 public ApiResponse generateCredentials( UriInfo ui, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 response.setAction( ""generate application client credentials"" );
		 ClientCredentialsInfo credentials = new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ), management.newClientSecretForApplication(applicationId) );
		 response.setCredentials( credentials );
		 return response;
	 }
	 public ApiResponse getApplicationSize( UriInfo ui, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 response.setAction( ""get application size for all entities"" );
		 long size = management.getApplicationSize(this.applicationId);
		 Map<String,Object> map = new HashMap<>();
		 Map<String,Object> innerMap = new HashMap<>();
		 Map<String,Object> sumMap = new HashMap<>();
		 innerMap.put(""application"",size);
		 sumMap.put(""size"",innerMap);
		 map.put(""aggregation"", sumMap);
		 response.setMetadata(map);
		 return response;
	 }
	 public ApiResponse getCollectionSize( UriInfo ui, String collection_name, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 response.setAction(""get collection size for all entities"");
		 long size = management.getCollectionSize(this.applicationId, collection_name);
		 Map<String,Object> map = new HashMap<>();
		 Map<String,Object> sumMap = new HashMap<>();
		 Map<String,Object> innerMap = new HashMap<>();
		 innerMap.put(collection_name,size);
		 sumMap.put(""size"",innerMap);
		 map.put(""aggregation"",sumMap);
		 response.setMetadata(map);
		 return response;
	 }
	 public ApiResponse getEachCollectionSize( UriInfo ui, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 response.setAction(""get collection size for all entities"");
		 Map<String,Long> sizes = management.getEachCollectionSize(this.applicationId);
		 Map<String,Object> map = new HashMap<>();
		 Map<String,Object> sumMap = new HashMap<>();
		 sumMap.put(""size"",sizes);
		 map.put(""aggregation"",sumMap);
		 response.setMetadata(map);
		 return response;
	 }
	 public ApiResponse configureProvider( UriInfo ui, String siaProvider, Map<String, Object> json, String callback ) throws Exception {
		 ApiResponse response = createApiResponse();
		 response.setAction( ""post signin provider configuration"" );
		 Preconditions.checkArgument( siaProvider != null, ""Sign in provider required"" );
		 SignInAsProvider signInAsProvider = null;
		 if ( StringUtils.equalsIgnoreCase( siaProvider, ""facebook"" ) ) {
			 signInAsProvider = signInProviderFactory.facebook( smf.getServiceManager( applicationId ).getApplication() );
		 }
		 else if ( StringUtils.equalsIgnoreCase( siaProvider, ""pingident"" ) ) {
			 signInAsProvider = signInProviderFactory.pingident( smf.getServiceManager( applicationId ).getApplication() );
		 }
		 else if ( StringUtils.equalsIgnoreCase( siaProvider, ""foursquare"" ) ) {
			 signInAsProvider = signInProviderFactory.foursquare( smf.getServiceManager( applicationId ).getApplication() );
		 }
		 Preconditions.checkArgument( signInAsProvider != null, ""No signin provider found by that name: "" + siaProvider );
		 signInAsProvider.saveToConfiguration( json );
		 return response;
	 }
	 public Response getStatus() {
		 Map<String, Object> statusMap = new HashMap<String, Object>();
		 EntityManager em = emf.getEntityManager( applicationId );
		 if ( !emf.getIndexHealth().equals( Health.RED ) ) {
			 statusMap.put(""message"", ""Index Health Status RED for application "" + applicationId );
			 return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
		 }
		 try {
			 if ( em.getApplication() == null ) {
				 statusMap.put(""message"", ""Application "" + applicationId + "" not found"");
				 return Response.status( SC_NOT_FOUND ).entity( statusMap ).build();
			 }
		 }
		 catch (Exception ex) {
			 statusMap.put(""message"", ""Error looking up application "" + applicationId );
			 return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
		 }
		 return Response.status( SC_OK ).entity( null ).build();
	 }
	 public ApiResponse executePut( UriInfo ui, String body, String callback ) throws Exception {
		 if ( applicationId == null ) {
			 throw new IllegalArgumentException(""Application ID not specified in request"");
		 }
		 ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
		 if (!SubjectUtils.isServiceAdmin()) {
			 String storedRestorePassword = restorePasswordService.getApplicationRestorePassword(applicationId);
			 if (StringUtils.isNotEmpty(storedRestorePassword)) {
				 String suppliedRestorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
				 if (!storedRestorePassword.equals(suppliedRestorePassword)) {
					 throw new IllegalArgumentException(""Application cannot be restored without application password"");
				 }
			 }
		 }
		 management.restoreApplication( applicationId );
		 ApiResponse response = createApiResponse();
		 response.setAction( ""restore"" );
		 response.setApplication( emf.getEntityManager( applicationId ).getApplication() );
		 response.setParams( ui.getQueryParameters() );
		 return response;
	 }
	 public ApiResponse executeDelete( UriInfo ui, String callback, String confirmApplicationIdentifier) throws Exception {
		 if ( application == null && applicationId == null ) {
			 throw new IllegalArgumentException(""Application ID not specified in request"");
		 }
		 if (application == null) {
			 if (!applicationId.toString().equals( confirmApplicationIdentifier )) {
				 throw new IllegalArgumentException( ""Cannot delete application without supplying correct application id."");
			 }
		 }
		 else if (!application.getName().split( ""/"" )[1].equals( confirmApplicationIdentifier ) ) {
			 throw new IllegalArgumentException( ""Cannot delete application without supplying correct application name"");
		 }
		 String restorePassword = null;
		 ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
		 if (SubjectUtils.isServiceAdmin()) {
			 restorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
			 if (StringUtils.isNotEmpty(restorePassword)) {
				 restorePasswordService.setApplicationRestorePassword(applicationId, restorePassword);
			 }
		 }
		 management.deleteApplication( applicationId );
		 if (restorePassword == null) {
			 restorePasswordService.removeApplicationRestorePassword(applicationId);
		 }
		 if (logger.isTraceEnabled()) {
			 logger.trace(""ApplicationResource.delete() deleted appId = {
			}
			"", applicationId);
		 }
		 ApiResponse response = createApiResponse();
		 response.setAction( ""delete"" );
		 response.setApplication(emf.getEntityManager( applicationId ).getApplication());
		 response.setParams(ui.getQueryParameters());
		 if (logger.isTraceEnabled()) {
			 logger.trace(""ApplicationResource.delete() sending response "");
		 }
		 return response;
	 }
	 private ApplicationRestorePasswordService getApplicationRestorePasswordService() {
		 return injector.getInstance(ApplicationRestorePasswordService.class);
	 }
}",1,0,0,0
"public abstract class AbstractBrokerRegistration {
	private final SubscribableChannel clientInboundChannel;
	private final MessageChannel clientOutboundChannel;
	private final List<String> destinationPrefixes;
	public AbstractBrokerRegistration(SubscribableChannel clientInboundChannel,MessageChannel clientOutboundChannel, String[] destinationPrefixes) {
		Assert.notNull(clientOutboundChannel, ""'clientInboundChannel' must not be null"");
		Assert.notNull(clientOutboundChannel, ""'clientOutboundChannel' must not be null"");
		this.clientInboundChannel = clientInboundChannel;
		this.clientOutboundChannel = clientOutboundChannel;
		this.destinationPrefixes = (destinationPrefixes != null ?Arrays.asList(destinationPrefixes) : Collections.emptyList());
	}
	protected SubscribableChannel getClientInboundChannel() {
		return this.clientInboundChannel;
	}
	protected MessageChannel getClientOutboundChannel() {
		return this.clientOutboundChannel;
	}
	protected Collection<String> getDestinationPrefixes() {
		return this.destinationPrefixes;
	}
	protected abstract AbstractBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel);
}",0,0,0,0
"public class Ipam {
	 private String driver;
	 private List<IpamConfig> config;
	 private Map<String, String> options;
	 public String getDriver() {
		 return driver;
	 }
	 public void setDriver(String driver) {
		 this.driver = driver;
	 }
	 public Ipam withDriver(String driver) {
		 this.driver = driver;
		 return this;
	 }
	 public List<IpamConfig> getConfig() {
		 return config;
	 }
	 public void setConfig(List<IpamConfig> config) {
		 this.config = config;
	 }
	 public Ipam withConfig(List<IpamConfig> config) {
		 this.config = config;
		 return this;
	 }
	 public Map<String, String> getOptions() {
		 return options;
	 }
	 public void setOptions(Map<String, String> options) {
		 this.options = options;
	 }
	 public Ipam withOptions(Map<String, String> options) {
		 this.options = options;
		 return this;
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 if (!(obj instanceof Ipam)) {
			 return false;
		 }
		 final Ipam that = (Ipam) obj;
		 return Objects.equals(driver, that.driver) && getConfig().equals(that.getConfig()) && getOptions().equals(that.getOptions());
	 }
	 public int hashCode() {
		 int hash = 7;
		 hash = 31 * hash + Objects.hashCode(driver);
		 hash = 31 * hash + getConfig().hashCode();
		 hash = 31 * hash + getOptions().hashCode();
		 return hash;
	 }
	 public String toString() {
		 return ""Ipam{
		"" + ""driver='"" + driver + '\'' + "", config="" + config + "", options="" + options + '}
		';
	 }
}",0,1,0,0
"private static ClassLoader makeClassLoader(JobConf conf, File workDir) throws IOException {
	 List cp = new ArrayList();
	 String jar = conf.getJar();
	 if (jar != null) {
		 File[] libs = new File(workDir, ""lib"").listFiles();
		 if (libs != null) {
			 for (int i = 0;
			 i < libs.length;
			 i++) {
				 cp.add(new URL(""file:"" + libs[i].toString()));
			 }
		 }
		 cp.add(new URL(""file:"" + new File(workDir, ""classes/"").toString()));
		 cp.add(new URL(""file:"" + workDir.toString() + ""/""));
	 }
	 return new URLClassLoader((URL[]) cp.toArray(new URL[cp.size()]));
 }",0,0,0,0
"public synchronized Object[] startFile( UTF8 src, UTF8 holder, UTF8 clientMachine, boolean overwrite, short replication, long blockSize ) throws IOException {
	 NameNode.stateChangeLog.debug(""DIR* NameSystem.startFile: file "" +src+"" for ""+holder+"" at ""+clientMachine);
	 if( isInSafeMode() ) throw new SafeModeException( ""Cannot create file"" + src, safeMode );
	 if (!isValidName(src.toString())) {
		 throw new IOException(""Invalid file name: "" + src);
	 }
	 try {
		 FileUnderConstruction pendingFile = pendingCreates.get(src);
		 if (pendingFile != null) {
			 Lease lease = leases.get(holder);
			 if (lease != null) {
				 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because current leaseholder is trying to recreate file."");
			 }
			 UTF8 oldholder = pendingFile.getClientName();
			 lease = leases.get(oldholder);
			 if (lease == null) {
				 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because pendingCreates is non-null but no leases found."");
			 }
			 if (lease.expiredSoftLimit()) {
				 lease.releaseLocks();
				 leases.remove(lease.holder);
				 LOG.info(""Removing lease "" + lease + "" "");
				 if (!sortedLeases.remove(lease)) {
					 LOG.error(""Unknown failure trying to remove "" + lease + "" from lease set."");
				 }
			 }
			 else {
				 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because pendingCreates is non-null."");
			 }
		 }
		 try {
			 verifyReplication(src.toString(), replication, clientMachine );
		 }
		 catch( IOException e) {
			 throw new IOException( ""failed to create ""+e.getMessage());
		 }
		 if (!dir.isValidToCreate(src)) {
			 if (overwrite) {
				 delete(src);
			 }
			 else {
				 throw new IOException(""failed to create file "" + src +"" on client "" + clientMachine +"" either because the filename is invalid or the file exists"");
			 }
		 }
		 DatanodeDescriptor targets[] = chooseTargets(replication, null, clientMachine, blockSize);
		 if (targets.length < this.minReplication) {
			 throw new IOException(""failed to create file ""+src +"" on client "" + clientMachine +"" because target-length is "" + targets.length +"", below MIN_REPLICATION ("" + minReplication+ "")"");
		 }
		 pendingCreates.put(src, new FileUnderConstruction(replication, blockSize, holder, clientMachine));
		 NameNode.stateChangeLog.debug( ""DIR* NameSystem.startFile: "" +""add ""+src+"" to pendingCreates for ""+holder );
		 synchronized (leases) {
			 Lease lease = leases.get(holder);
			 if (lease == null) {
				 lease = new Lease(holder);
				 leases.put(holder, lease);
				 sortedLeases.add(lease);
			 }
			 else {
				 sortedLeases.remove(lease);
				 lease.renew();
				 sortedLeases.add(lease);
			 }
			 lease.startedCreate(src);
		 }
		 Object results[] = new Object[2];
		 results[0] = allocateBlock(src);
		 results[1] = targets;
		 return results;
	 }
	 catch (IOException ie) {
		 NameNode.stateChangeLog.warn(""DIR* NameSystem.startFile: "" +ie.getMessage());
		 throw ie;
	 }
 }",0,0,1,0
"public class FoldLeft<T> implements Function<Generator<T>, T>, BinaryFunction<Generator<T>, T, T> {
	 private static class FoldLeftHelper<T> implements Procedure<T> {
		 private final BinaryFunction<? super T, ? super T, ? extends T> function;
		 private T seed;
		 private boolean started;
		 public FoldLeftHelper(BinaryFunction<? super T, ? super T, ? extends T> function) {
			 this(null, function);
		 }
		 FoldLeftHelper(T seed, BinaryFunction<? super T, ? super T, ? extends T> function) {
			 this.seed = seed;
			 started = seed != null ? true : false;
			 this.function = function;
		 }
		 public void run(T obj) {
			 if (!started) {
				 seed = obj;
				 started = true;
			 }
			 else {
				 seed = function.evaluate(seed, obj);
			 }
		 }
		 T getResult() {
			 return started ? seed : null;
		 }
	 }
	 private final BinaryFunction<? super T, ? super T, ? extends T> function;
	 public FoldLeft(BinaryFunction<? super T, ? super T, ? extends T> func) {
		 this.function = func;
	 }
	 public final T evaluate(Generator<T> obj) {
		 FoldLeftHelper<T> helper = new FoldLeftHelper<T>(function);
		 obj.run(helper);
		 return helper.getResult();
	 }
	 public final T evaluate(Generator<T> left, T right) {
		 FoldLeftHelper<T> helper = new FoldLeftHelper<T>(right, function);
		 left.run(helper);
		 return helper.getResult();
	 }
	 public boolean equals(Object obj) {
		 if (obj == this) {
			 return true;
		 }
		 if (!(obj instanceof FoldLeft<?>)) {
			 return false;
		 }
		 return ((FoldLeft<?>) obj).function.equals(function);
	 }
	 public int hashCode() {
		 return ""FoldLeft"".hashCode() << 2 ^ function.hashCode();
	 }
	 public String toString() {
		 return ""FoldLeft<"" + function + "">"";
	 }
}",0,0,0,0
"private static class BeanRegistration {
	private final Class<?> annotatedClass;
	private final Supplier<?> supplier;
	private final Class<? extends Annotation>[] qualifiers;
	public BeanRegistration(Class<?> annotatedClass, Supplier<?> supplier, Class<? extends Annotation>[] qualifiers) {
		this.annotatedClass = annotatedClass;
		this.supplier = supplier;
		this.qualifiers = qualifiers;
	}
	public Class<?> getAnnotatedClass() {
		return this.annotatedClass;
	}
	public Supplier getSupplier() {
		return this.supplier;
	}
	public Class<? extends Annotation>[] getQualifiers() {
		return this.qualifiers;
	}
	public String toString() {
		return this.annotatedClass.getName();
	}
}",0,1,0,0
"public class MainJVM extends AbstractMasterJVM implements MainJVMRemoteI {
	 private static final int MAX_STARTUP_FAILURES = 3;
	 private static final int STARTUP_TIMEOUT = 10000;
	 private final StateMonitor<State> _state;
	 private final ResultHandler _handler = new ResultHandler();
	 private volatile InteractionsModelCallback _interactionsModel;
	 private volatile JUnitModelCallback _junitModel;
	 private volatile DebugModelCallback _debugModel;
	 private volatile boolean _allowAssertions = false;
	 private volatile Iterable<File> _startupClassPath;
	 private volatile File _workingDir;
	 public MainJVM(File wd) {
		 super(InterpreterJVM.class.getName());
		 _workingDir = wd;
		 _interactionsModel = new DummyInteractionsModel();
		 _junitModel = new DummyJUnitModel();
		 _debugModel = new DummyDebugModel();
		 _state = new StateMonitor<State>(new FreshState());
		 _startupClassPath = ReflectUtil.SYSTEM_CLASS_PATH;
	 }
	 public void startInterpreterJVM() {
		 _state.value().start();
	 }
	 public void stopInterpreterJVM() {
		 _state.value().stop();
	 }
	 public void restartInterpreterJVM(boolean force) {
		 _state.value().restart(force);
	 }
	 public void dispose() {
		 _state.value().dispose();
	 }
	 protected void handleSlaveConnected(SlaveRemote newSlave) {
		 InterpreterJVMRemoteI slaveCast = (InterpreterJVMRemoteI) newSlave;
		 _state.value().started(slaveCast);
	 }
	 protected void handleSlaveQuit(int status) {
		 debug.logValue(""Slave quit"", ""status"", status);
		 _state.value().stopped(status);
	 }
	 protected void handleSlaveWontStart(Exception e) {
		 debug.log(""Slave won't start"", e);
		 _state.value().startFailed(e);
	 }
	 public void systemErrPrint(String s) {
		 debug.logStart();
		 _interactionsModel.replSystemErrPrint(s);
		 debug.logEnd();
	 }
	 public void systemOutPrint(String s) {
		 debug.logStart();
		 _interactionsModel.replSystemOutPrint(s);
		 debug.logEnd();
	 }
	 public String getConsoleInput() {
		 String s = _interactionsModel.getConsoleInput();
		 return s;
	 }
	 public void nonTestCase(boolean isTestAll, boolean didCompileFail) {
		 _junitModel.nonTestCase(isTestAll, didCompileFail);
	 }
	 public void classFileError(ClassFileError e) {
		 _junitModel.classFileError(e);
	 }
	 public void testSuiteStarted(int numTests) {
		 _junitModel.testSuiteStarted(numTests);
	 }
	 public void testStarted(String testName) {
		 _junitModel.testStarted(testName);
	 }
	 public void testEnded(String testName, boolean wasSuccessful, boolean causedError) {
		 _junitModel.testEnded(testName, wasSuccessful, causedError);
	 }
	 public void testSuiteEnded(JUnitError[] errors) {
		 _junitModel.testSuiteEnded(errors);
	 }
	 public File getFileForClassName(String className) {
		 return _junitModel.getFileForClassName(className);
	 }
	 public void setInteractionsModel(InteractionsModelCallback model) {
		 _interactionsModel = model;
	 }
	 public void setJUnitModel(JUnitModelCallback model) {
		 _junitModel = model;
	 }
	 public void setDebugModel(DebugModelCallback model) {
		 _debugModel = model;
	 }
	 public void setAllowAssertions(boolean allow) {
		 _allowAssertions = allow;
	 }
	 public void setStartupClassPath(String classPath) {
		 _startupClassPath = IOUtil.parsePath(classPath);
	 }
	 public void setWorkingDirectory(File dir) {
		 _workingDir = dir;
	 }
	 protected InterpretResult.Visitor<Void> resultHandler() {
		 return _handler;
	 }
	 public boolean interpret(final String s) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(true);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 debug.logStart(""Interpreting "" + s);
			 InterpretResult result = remote.interpret(s);
			 result.apply(resultHandler());
			 debug.logEnd(""result"", result);
			 return true;
		 }
		 catch (RemoteException e) {
			 debug.logEnd();
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public Option<Pair<String,String>> getVariableToString(String var) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return Option.none();
		 }
		 try {
			 return Option.some(remote.getVariableToString(var));
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return Option.none();
		 }
	 }
	 public boolean addProjectClassPath(File f) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.addProjectClassPath(f);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean addBuildDirectoryClassPath(File f) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.addBuildDirectoryClassPath(f);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean addProjectFilesClassPath(File f) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.addProjectFilesClassPath(f);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean addExternalFilesClassPath(File f) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.addExternalFilesClassPath(f);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean addExtraClassPath(File f) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.addExtraClassPath(f);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public Option<Iterable<File>> getClassPath() {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return Option.none();
		 }
		 try {
			 return Option.some(remote.getClassPath());
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return Option.none();
		 }
	 }
	 public boolean setPackageScope(String packageName) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.interpret(""package "" + packageName + "";
			"");
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public Option<List<String>> findTestClasses(List<String> classNames, List<File> files) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return Option.none();
		 }
		 try {
			 return Option.some(remote.findTestClasses(classNames, files));
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return Option.none();
		 }
	 }
	 public boolean runTestSuite() {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(true);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 return remote.runTestSuite();
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean addInterpreter(String name) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.addInterpreter(name);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean removeInterpreter(String name) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.removeInterpreter(name);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public Option<Pair<Boolean, Boolean>> setActiveInterpreter(String name) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return Option.none();
		 }
		 try {
			 return Option.some(remote.setActiveInterpreter(name));
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return Option.none();
		 }
	 }
	 public Option<Pair<Boolean, Boolean>> setToDefaultInterpreter() {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return Option.none();
		 }
		 try {
			 return Option.some(remote.setToDefaultInterpreter());
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return Option.none();
		 }
	 }
	 public boolean setEnforceAllAccess(boolean enforce) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.setEnforceAllAccess(enforce);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean setEnforcePrivateAccess(boolean enforce) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.setEnforcePrivateAccess(enforce);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean setRequireSemicolon(boolean require) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.setRequireSemicolon(require);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 public boolean setRequireVariableType(boolean require) {
		 InterpreterJVMRemoteI remote = _state.value().interpreter(false);
		 if (remote == null) {
			 return false;
		 }
		 try {
			 remote.setRequireVariableType(require);
			 return true;
		 }
		 catch (RemoteException e) {
			 _handleRemoteException(e);
			 return false;
		 }
	 }
	 private void _doStartup() {
		 File dir = _workingDir;
		 if (dir == FileOps.NULL_FILE) {
			 dir = IOUtil.WORKING_DIRECTORY;
		 }
		 List<String> jvmArgs = new ArrayList<String>();
		 final CompletionMonitor cm = new CompletionMonitor();
		 boolean repeat;
		 do {
			 repeat = false;
			 File junitLocation = DrJava.getConfig().getSetting(OptionConstants.JUNIT_LOCATION);
			 boolean concJUnitAvailable = !DrJava.getConfig().getSetting(OptionConstants.JUNIT_LOCATION_ENABLED) || edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(junitLocation);
			 File rtLocation = DrJava.getConfig().getSetting(OptionConstants.RT_CONCJUNIT_LOCATION);
			 boolean rtLocationConfigured = edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidRTConcJUnitFile(rtLocation);
			 if (DrJava.getConfig().getSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED). equals(OptionConstants.ConcJUnitCheckChoices.ALL) && !rtLocationConfigured && (rtLocation != null) && (!FileOps.NULL_FILE.equals(rtLocation)) && (rtLocation.exists())) {
				 DrJava.getConfig().setSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED, OptionConstants.ConcJUnitCheckChoices.NO_LUCKY);
				 rtLocationConfigured = false;
				 javax.swing.JOptionPane.showMessageDialog(null, ""The selected file is invalid and was disabled:\n""+rtLocation, ""Invalid ConcJUnit Runtime File"", javax.swing.JOptionPane.ERROR_MESSAGE);
			 }
			 if (concJUnitAvailable && rtLocationConfigured && DrJava.getConfig().getSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED). equals(OptionConstants.ConcJUnitCheckChoices.ALL)) {
				 try {
					 File shortF = FileOps.getShortFile(rtLocation);
					 if (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isCompatibleRTConcJUnitFile(shortF)) {
						 jvmArgs.add(""-Xbootclasspath/p:""+shortF.getAbsolutePath().replace(File.separatorChar, '/'));
					 }
					 else {
						 repeat = true;
						 cm.reset();
						 boolean attempted = edu.rice.cs.drjava.model.junit.ConcJUnitUtils. showIncompatibleWantToRegenerateDialog(null, new Runnable() {
							 public void run() {
								 cm.signal();
							 }
						 }
						, new Runnable() {
							 public void run() {
								 cm.signal();
							 }
						 }
						);
						 while(!cm.attemptEnsureSignaled());
						 if (!attempted) {
							 repeat = false;
						 }
					 }
				 }
				 catch(IOException ioe) {
					 DrJava.getConfig().setSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED, OptionConstants.ConcJUnitCheckChoices.NO_LUCKY);
					 rtLocationConfigured = false;
					 javax.swing.JOptionPane.showMessageDialog(null, ""There was a problem with the selected file, and it was disabled:\n""+rtLocation, ""Invalid ConcJUnit Runtime File"", javax.swing.JOptionPane.ERROR_MESSAGE);
				 }
			 }
		 }
		 while(repeat);
		 if (_allowAssertions) {
			 jvmArgs.add(""-ea"");
		 }
		 int debugPort = _getDebugPort();
		 if (debugPort > -1) {
			 jvmArgs.add(""-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address="" + debugPort);
			 jvmArgs.add(""-Xdebug"");
			 jvmArgs.add(""-Xnoagent"");
			 jvmArgs.add(""-Djava.compiler=NONE"");
		 }
		 String slaveMemory = DrJava.getConfig().getSetting(OptionConstants.SLAVE_JVM_XMX);
		 if (!"""".equals(slaveMemory) && !OptionConstants.heapSizeChoices.get(0).equals(slaveMemory)) {
			 jvmArgs.add(""-Xmx"" + slaveMemory + ""M"");
		 }
		 String slaveArgs = DrJava.getConfig().getSetting(OptionConstants.SLAVE_JVM_ARGS);
		 if (PlatformFactory.ONLY.isMacPlatform()) {
			 jvmArgs.add(""-Xdock:name=Interactions"");
		 }
		 for (File f: _interactionsModel.getCompilerBootClassPath()) {
			 try {
				 File shortF = FileOps.getShortFile(f);
				 jvmArgs.add(""-Xbootclasspath/a:""+shortF.getAbsolutePath().replace(File.separatorChar, '/'));
			 }
			 catch(IOException ioe) {
			 }
		 }
		 jvmArgs.addAll(ArgumentTokenizer.tokenize(slaveArgs));
		 JVMBuilder jvmb = new JVMBuilder(_startupClassPath).directory(dir).jvmArguments(jvmArgs);
		 File junitLocation = DrJava.getConfig().getSetting(OptionConstants.JUNIT_LOCATION);
		 boolean junitLocationConfigured = (edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidJUnitFile(junitLocation) || edu.rice.cs.drjava.model.junit.ConcJUnitUtils.isValidConcJUnitFile(junitLocation));
		 if (DrJava.getConfig().getSetting(OptionConstants.JUNIT_LOCATION_ENABLED) && !junitLocationConfigured && (junitLocation != null) && (!FileOps.NULL_FILE.equals(junitLocation)) && (junitLocation.exists())) {
			 DrJava.getConfig().setSetting(OptionConstants.JUNIT_LOCATION_ENABLED, false);
			 junitLocationConfigured = false;
		 }
		 ArrayList<File> extendedClassPath = new ArrayList<File>();
		 if (DrJava.getConfig().getSetting(OptionConstants.JUNIT_LOCATION_ENABLED) && junitLocationConfigured) {
			 extendedClassPath.add(junitLocation);
		 }
		 for(File f: jvmb.classPath()) {
			 extendedClassPath.add(f);
		 }
		 jvmb = jvmb.classPath(edu.rice.cs.plt.iter.IterUtil.asSizedIterable(extendedClassPath));
		 Map<String, String> props = jvmb.propertiesCopy();
		 boolean all = DrJava.getConfig().getSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED). equals(OptionConstants.ConcJUnitCheckChoices.ALL);
		 boolean noLucky = DrJava.getConfig().getSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED). equals(OptionConstants.ConcJUnitCheckChoices.NO_LUCKY);
		 boolean onlyThreads = DrJava.getConfig().getSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED). equals(OptionConstants.ConcJUnitCheckChoices.ONLY_THREADS);
		 boolean none = DrJava.getConfig().getSetting(OptionConstants.CONCJUNIT_CHECKS_ENABLED). equals(OptionConstants.ConcJUnitCheckChoices.NONE);
		 props.put(""edu.rice.cs.cunit.concJUnit.check.threads.enabled"", new Boolean(!none).toString());
		 props.put(""edu.rice.cs.cunit.concJUnit.check.join.enabled"", new Boolean(all || noLucky).toString());
		 props.put(""edu.rice.cs.cunit.concJUnit.check.lucky.enabled"", new Boolean(all).toString());
		 jvmb = jvmb.properties(props);
		 invokeSlave(jvmb);
	 }
	 private int _getDebugPort() {
		 int port = -1;
		 try {
			 port = _interactionsModel.getDebugPort();
		 }
		 catch (IOException ioe) {
		 }
		 return port;
	 }
	 private void _handleRemoteException(RemoteException e) {
		 if (e instanceof UnmarshalException) {
			 if (e.getCause() instanceof EOFException) return;
			 if ((e.getCause() instanceof SocketException) && (e.getCause().getMessage().equals(""Connection reset""))) return;
		 }
		 DrJavaErrorHandler.record(e);
	 }
	 private abstract class State {
		 public abstract InterpreterJVMRemoteI interpreter(boolean used);
		 public abstract void start();
		 public abstract void stop();
		 public abstract void restart(boolean force);
		 public abstract void dispose();
		 public void started(InterpreterJVMRemoteI i) {
			 throw new IllegalStateException(""Unexpected started() call"");
		 }
		 public void startFailed(Exception e) {
			 throw new IllegalStateException(""Unexpected startFailed() call"");
		 }
		 public void stopped(int status) {
			 throw new IllegalStateException(""Unexpected stopped() call"");
		 }
	 }
	 private class FreshState extends State {
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 return null;
		 }
		 public void start() {
			 if (_state.compareAndSet(this, new StartingState())) {
				 _doStartup();
			 }
			 else {
				 _state.value().start();
			 }
		 }
		 public void stop() {
		 }
		 public void restart(boolean force) {
			 start();
		 }
		 public void dispose() {
			 if (_state.compareAndSet(this, new DisposedState())) {
				 MainJVM.super.dispose();
			 }
			 else {
				 _state.value().dispose();
			 }
		 }
	 }
	 private class StartingState extends State {
		 private final int _failures;
		 public StartingState() {
			 _failures = 0;
		 }
		 private StartingState(int failures) {
			 _failures = failures;
		 }
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 try {
				 return _state.ensureNotState(this, STARTUP_TIMEOUT).interpreter(used);
			 }
			 catch (TimeoutException e) {
				 return null;
			 }
			 catch (InterruptedException e) {
				 throw new UnexpectedException(e);
			 }
		 }
		 public void start() {
		 }
		 public void restart(boolean force) {
			 try {
				 _state.ensureNotState(this, STARTUP_TIMEOUT).restart(force);
			 }
			 catch (Exception e) {
				 throw new UnexpectedException(e);
			 }
		 }
		 public void stop() {
			 try {
				 _state.ensureNotState(this, STARTUP_TIMEOUT).stop();
			 }
			 catch (Exception e) {
				 throw new UnexpectedException(e);
			 }
		 }
		 public void dispose() {
			 stop();
			 _state.value().dispose();
		 }
		 public void started(InterpreterJVMRemoteI i) {
			 if (_state.compareAndSet(this, new FreshRunningState(i))) {
				 boolean enforceAllAccess = DrJava.getConfig().getSetting(OptionConstants.DYNAMICJAVA_ACCESS_CONTROL) .equals(OptionConstants.DynamicJavaAccessControlChoices.PRIVATE_AND_PACKAGE);
				 try {
					 i.setEnforceAllAccess(enforceAllAccess);
				 }
				 catch (RemoteException re) {
					 _handleRemoteException(re);
				 }
				 boolean enforcePrivateAccess = !DrJava.getConfig().getSetting(OptionConstants.DYNAMICJAVA_ACCESS_CONTROL) .equals(OptionConstants.DynamicJavaAccessControlChoices.DISABLED);
				 try {
					 i.setEnforcePrivateAccess(enforcePrivateAccess);
				 }
				 catch (RemoteException re) {
					 _handleRemoteException(re);
				 }
				 Boolean requireSemicolon = DrJava.getConfig().getSetting(OptionConstants.DYNAMICJAVA_REQUIRE_SEMICOLON);
				 try {
					 i.setRequireSemicolon(requireSemicolon);
				 }
				 catch (RemoteException re) {
					 _handleRemoteException(re);
				 }
				 Boolean requireVariableType = DrJava.getConfig().getSetting(OptionConstants.DYNAMICJAVA_REQUIRE_VARIABLE_TYPE);
				 try {
					 i.setRequireVariableType(requireVariableType);
				 }
				 catch (RemoteException re) {
					 _handleRemoteException(re);
				 }
				 _interactionsModel.interpreterReady(_workingDir);
				 _junitModel.junitJVMReady();
			 }
			 else {
				 _state.value().started(i);
			 }
		 }
		 public void startFailed(Exception e) {
			 int count = _failures + 1;
			 if (count < MAX_STARTUP_FAILURES) {
				 if (_state.compareAndSet(this, new StartingState(count))) {
					 _doStartup();
				 }
				 else {
					 _state.value().startFailed(e);
				 }
			 }
			 else {
				 if (_state.compareAndSet(this, new FreshState())) {
					 _interactionsModel.interpreterWontStart(e);
				 }
				 else {
					 _state.value().startFailed(e);
				 }
			 }
		 }
	 }
	 private class RunningState extends State {
		 protected final InterpreterJVMRemoteI _interpreter;
		 public RunningState(InterpreterJVMRemoteI interpreter) {
			 _interpreter = interpreter;
		 }
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 return _interpreter;
		 }
		 public void start() {
		 }
		 public void stop() {
			 if (_state.compareAndSet(this, new StoppingState())) {
				 quitSlave();
			 }
			 else {
				 _state.value().stop();
			 }
		 }
		 public void restart(boolean force) {
			 if (_state.compareAndSet(this, new RestartingState())) {
				 _interactionsModel.interpreterResetting();
				 quitSlave();
			 }
			 else {
				 _state.value().restart(force);
			 }
		 }
		 public void dispose() {
			 stop();
			 _state.value().dispose();
		 }
		 public void stopped(int status) {
			 if (_state.compareAndSet(this, new RestartingState())) {
				 _interactionsModel.replCalledSystemExit(status);
				 _interactionsModel.interpreterResetting();
			 }
			 _state.value().stopped(status);
		 }
	 }
	 private class FreshRunningState extends RunningState {
		 public FreshRunningState(InterpreterJVMRemoteI interpreter) {
			 super(interpreter);
		 }
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 if (used) {
				 _state.compareAndSet(this, new RunningState(_interpreter));
				 return _state.value().interpreter(used);
			 }
			 else {
				 return super.interpreter(used);
			 }
		 }
		 public void restart(boolean force) {
			 if (force) {
				 super.restart(force);
			 }
			 else {
				 _interactionsModel.interpreterReady(_workingDir);
			 }
		 }
	 }
	 private class RestartingState extends State {
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 try {
				 return _state.ensureNotState(this, STARTUP_TIMEOUT).interpreter(used);
			 }
			 catch (TimeoutException e) {
				 return null;
			 }
			 catch (InterruptedException e) {
				 throw new UnexpectedException(e);
			 }
		 }
		 public void start() {
		 }
		 public void stop() {
			 if (!_state.compareAndSet(this, new StoppingState())) {
				 _state.value().stop();
			 }
		 }
		 public void restart(boolean force) {
		 }
		 public void dispose() {
			 if (_state.compareAndSet(this, new DisposedState())) {
				 MainJVM.super.dispose();
			 }
			 else {
				 _state.value().dispose();
			 }
		 }
		 public void stopped(int status) {
			 if (_state.compareAndSet(this, new StartingState())) {
				 _doStartup();
			 }
			 else {
				 _state.value().stopped(status);
			 }
		 }
	 }
	 private class StoppingState extends State {
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 return null;
		 }
		 public void start() {
			 try {
				 _state.ensureNotState(this, STARTUP_TIMEOUT).start();
			 }
			 catch (Exception e) {
				 throw new UnexpectedException(e);
			 }
		 }
		 public void stop() {
		 }
		 public void restart(boolean force) {
			 if (!_state.compareAndSet(this, new RestartingState())) {
				 _state.value().restart(force);
			 }
		 }
		 public void dispose() {
			 if (_state.compareAndSet(this, new DisposedState())) {
				 MainJVM.super.dispose();
			 }
			 else {
				 _state.value().dispose();
			 }
		 }
		 public void stopped(int status) {
			 if (!_state.compareAndSet(this, new FreshState())) {
				 _state.value().stopped(status);
			 }
		 }
	 }
	 private class DisposedState extends State {
		 public InterpreterJVMRemoteI interpreter(boolean used) {
			 throw new IllegalStateException(""MainJVM is disposed"");
		 }
		 public void start() {
			 throw new IllegalStateException(""MainJVM is disposed"");
		 }
		 public void stop() {
			 throw new IllegalStateException(""MainJVM is disposed"");
		 }
		 public void restart(boolean force) {
			 throw new IllegalStateException(""MainJVM is disposed"");
		 }
		 public void dispose() {
		 }
		 public void stopped() {
		 }
	 }
	 private class ResultHandler implements InterpretResult.Visitor<Void> {
		 public Void forNoValue() {
			 _interactionsModel.replReturnedVoid();
			 return null;
		 }
		 public Void forObjectValue(String objString, String objTypeString) {
			 _interactionsModel.replReturnedResult(objString, InteractionsDocument.OBJECT_RETURN_STYLE);
			 return null;
		 }
		 public Void forStringValue(String s) {
			 _interactionsModel.replReturnedResult('""' + s + '""', InteractionsDocument.STRING_RETURN_STYLE);
			 return null;
		 }
		 public Void forCharValue(Character c) {
			 _interactionsModel.replReturnedResult(""'"" + c + ""'"", InteractionsDocument.CHARACTER_RETURN_STYLE);
			 return null;
		 }
		 public Void forNumberValue(Number n) {
			 _interactionsModel.replReturnedResult(n.toString(), InteractionsDocument.NUMBER_RETURN_STYLE);
			 return null;
		 }
		 public Void forBooleanValue(Boolean b) {
			 _interactionsModel.replReturnedResult(b.toString(), InteractionsDocument.OBJECT_RETURN_STYLE);
			 return null;
		 }
		 public Void forEvalException(String message, StackTraceElement[] stackTrace) {
			 _interactionsModel.replThrewException(message, stackTrace);
			 return null;
		 }
		 public Void forException(String message) {
			 _interactionsModel.replThrewException(message);
			 return null;
		 }
		 public Void forUnexpectedException(Throwable t) {
			 _interactionsModel.replReturnedVoid();
			 throw new UnexpectedException(t);
		 }
		 public Void forBusy() {
			 _interactionsModel.replReturnedVoid();
			 throw new UnexpectedException(""MainJVM.interpret() called when InterpreterJVM was busy!"");
		 }
	 }
	 public static class DummyInteractionsModel implements InteractionsModelCallback {
		 public int getDebugPort() throws IOException {
			 return -1;
		 }
		 public void replSystemOutPrint(String s) {
		 }
		 public void replSystemErrPrint(String s) {
		 }
		 public String getConsoleInput() {
			 throw new IllegalStateException(""Cannot request input from dummy interactions model!"");
		 }
		 public void setInputListener(InputListener il) {
			 throw new IllegalStateException(""Cannot set the input listener of dummy interactions model!"");
		 }
		 public void changeInputListener(InputListener from, InputListener to) {
			 throw new IllegalStateException(""Cannot change the input listener of dummy interactions model!"");
		 }
		 public void replReturnedVoid() {
		 }
		 public void replReturnedResult(String result, String style) {
		 }
		 public void replThrewException(String message, StackTraceElement[] stackTrace) {
		 }
		 public void replThrewException(String message) {
		 }
		 public void replReturnedSyntaxError(String errorMessage, String interaction, int startRow, int startCol, int endRow, int endCol) {
		 }
		 public void replCalledSystemExit(int status) {
		 }
		 public void interpreterResetting() {
		 }
		 public void interpreterResetFailed(Throwable th) {
		 }
		 public void interpreterWontStart(Exception e) {
		 }
		 public void interpreterReady(File wd) {
		 }
		 public List<File> getCompilerBootClassPath() {
			 return new ArrayList<File>();
		 }
		 public String transformCommands(String interactionsString) {
			 return interactionsString;
		 }
	 }
	 public static class DummyJUnitModel implements JUnitModelCallback {
		 public void nonTestCase(boolean isTestAll, boolean didCompileFail) {
		 }
		 public void classFileError(ClassFileError e) {
		 }
		 public void testSuiteStarted(int numTests) {
		 }
		 public void testStarted(String testName) {
		 }
		 public void testEnded(String testName, boolean wasSuccessful, boolean causedError) {
		 }
		 public void testSuiteEnded(JUnitError[] errors) {
		 }
		 public File getFileForClassName(String className) {
			 return null;
		 }
		 public Iterable<File> getClassPath() {
			 return IterUtil.empty();
		 }
		 public void junitJVMReady() {
		 }
	 }
	 public static class DummyDebugModel implements DebugModelCallback {
		 public void notifyDebugInterpreterAssignment(String name) {
		 }
	 }
}",1,0,0,0
"public String toString() {
	 return ""{
	"" + toExtension().toString() + ""}
	"";
 }",0,0,0,0
"public Optional<UserEntity> getUser ( final String userId ) {
	 return Optional.ofNullable ( this.userMap.get ( userId ) );
 }",0,0,0,0
"public class NodeValueString extends NodeValue{
	 private String string ;
	 public NodeValueString(String str) {
		 string = str ;
	 }
	 public NodeValueString(String str, Node n) {
		 super(n) ;
		 string = str ;
	 }
	 public boolean isString() {
		 return true ;
	 }
	 public String getString() {
		 return string ;
	 }
	 public String asString() {
		 return string ;
	 }
	 public String toString() {
		 if ( getNode() != null ) {
			 return FmtUtils.stringForNode(getNode()) ;
		 }
		 return '""'+string+'""' ;
	 }
	 protected Node makeNode() {
		 return NodeFactory.createLiteral(string) ;
	 }
	 public void visit(NodeValueVisitor visitor) {
		 visitor.visit(this) ;
	 }
}",0,1,0,0
"public class WrongCustomPartitioner extends Partitioner<PigNullableWritable, Writable> {
	 public int getPartition(PigNullableWritable key, Writable value, int numPartitions) {
		 throw new RuntimeException(""Wrong"");
	 }
}",1,0,0,0
"public class StatementDML extends StatementDMQL {
	 Expression[] targets;
	 Expression updatableTableCheck;
	 RangeVariable checkRangeVariable;
	 boolean isTruncate;
	 public StatementDML(int type, int group, HsqlName schemaName) {
		 super(type, group, schemaName);
	 }
	 StatementDML(Session session, Table targetTable, RangeVariable[] rangeVars, CompileContext compileContext, boolean restartIdentity, int type) {
		 super(StatementTypes.DELETE_WHERE, StatementTypes.X_SQL_DATA_CHANGE, session.getCurrentSchemaHsqlName());
		 this.targetTable = targetTable;
		 this.baseTable = targetTable.getBaseTable() == null ? targetTable : targetTable .getBaseTable();
		 this.targetRangeVariables = rangeVars;
		 this.restartIdentity = restartIdentity;
		 setDatabseObjects(session, compileContext);
		 checkAccessRights(session);
		 if (type == StatementTypes.TRUNCATE) {
			 isTruncate = true;
		 }
		 targetRangeVariables[0].addAllColumns();
	 }
	 StatementDML(Session session, Expression[] targets, Table targetTable, RangeVariable rangeVars[], int[] updateColumnMap, Expression[] colExpressions, boolean[] checkColumns, CompileContext compileContext) {
		 super(StatementTypes.UPDATE_WHERE, StatementTypes.X_SQL_DATA_CHANGE, session.getCurrentSchemaHsqlName());
		 this.targets = targets;
		 this.targetTable = targetTable;
		 this.baseTable = targetTable.getBaseTable() == null ? targetTable : targetTable .getBaseTable();
		 this.updateColumnMap = updateColumnMap;
		 this.updateExpressions = colExpressions;
		 this.updateCheckColumns = checkColumns;
		 this.targetRangeVariables = rangeVars;
		 setDatabseObjects(session, compileContext);
		 checkAccessRights(session);
		 setupChecks();
		 targetRangeVariables[0].addAllColumns();
	 }
	 StatementDML(Session session, Expression[] targets, RangeVariable[] targetRangeVars, int[] insertColMap, int[] updateColMap, boolean[] checkColumns, Expression mergeCondition, Expression insertExpr, Expression[] updateExpr, CompileContext compileContext) {
		 super(StatementTypes.MERGE, StatementTypes.X_SQL_DATA_CHANGE, session.getCurrentSchemaHsqlName());
		 this.targets = targets;
		 this.sourceTable = targetRangeVars[0].rangeTable;
		 this.targetTable = targetRangeVars[1].rangeTable;
		 this.baseTable = targetTable.getBaseTable() == null ? targetTable : targetTable .getBaseTable();
		 this.insertCheckColumns = checkColumns;
		 this.insertColumnMap = insertColMap;
		 this.updateColumnMap = updateColMap;
		 this.insertExpression = insertExpr;
		 this.updateExpressions = updateExpr;
		 this.targetRangeVariables = targetRangeVars;
		 this.condition = mergeCondition;
		 setDatabseObjects(session, compileContext);
		 checkAccessRights(session);
		 setupChecks();
	 }
	 StatementDML() {
		 super(StatementTypes.UPDATE_CURSOR, StatementTypes.X_SQL_DATA_CHANGE, null);
	 }
	 void setupChecks() {
		 if (targetTable != baseTable) {
			 QuerySpecification select = ((TableDerived) targetTable).getQueryExpression() .getMainSelect();
			 this.updatableTableCheck = select.checkQueryCondition;
			 this.checkRangeVariable = select.rangeVariables[0];
		 }
	 }
	 Result getResult(Session session) {
		 Result result = null;
		 switch (type) {
			 case StatementTypes.UPDATE_WHERE : result = executeUpdateStatement(session);
			 break;
			 case StatementTypes.MERGE : result = executeMergeStatement(session);
			 break;
			 case StatementTypes.DELETE_WHERE : if (isTruncate) {
				 result = executeDeleteTruncateStatement(session);
			 }
			 else {
				 result = executeDeleteStatement(session);
			 }
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""StatementDML"");
		 }
		 return result;
	 }
	 void collectTableNamesForRead(OrderedHashSet set) {
		 if (baseTable.isView()) {
			 getTriggerTableNames(set, false);
		 }
		 else if (!baseTable.isTemp()) {
			 for (int i = 0;
			 i < baseTable.fkConstraints.length;
			 i++) {
				 Constraint constraint = baseTable.fkConstraints[i];
				 if (type == StatementTypes.UPDATE_WHERE || type == StatementTypes.MERGE) {
					 if (ArrayUtil.haveCommonElement(constraint.getRefColumns(), updateColumnMap)) {
						 set.add( baseTable.fkConstraints[i].getMain().getName());
					 }
				 }
				 else if (type == StatementTypes.INSERT) {
					 set.add(baseTable.fkConstraints[i].getMain().getName());
				 }
			 }
			 if (type == StatementTypes.UPDATE_WHERE || type == StatementTypes.MERGE) {
				 baseTable.collectFKReadLocks(updateColumnMap, set);
			 }
			 else if (type == StatementTypes.DELETE_WHERE) {
				 baseTable.collectFKReadLocks(null, set);
			 }
			 getTriggerTableNames(set, false);
		 }
		 for (int i = 0;
		 i < rangeVariables.length;
		 i++) {
			 Table rangeTable = rangeVariables[i].rangeTable;
			 HsqlName name = rangeTable.getName();
			 if (rangeTable.isReadOnly() || rangeTable.isTemp()) {
				 continue;
			 }
			 if (name.schema == SqlInvariants.SYSTEM_SCHEMA_HSQLNAME) {
				 continue;
			 }
			 set.add(name);
		 }
		 for (int i = 0;
		 i < subqueries.length;
		 i++) {
			 if (subqueries[i].queryExpression != null) {
				 subqueries[i].queryExpression.getBaseTableNames(set);
			 }
		 }
		 for (int i = 0;
		 i < routines.length;
		 i++) {
			 set.addAll(routines[i].getTableNamesForRead());
		 }
	 }
	 void collectTableNamesForWrite(OrderedHashSet set) {
		 if (baseTable.isView()) {
			 getTriggerTableNames(set, true);
		 }
		 else if (!baseTable.isTemp()) {
			 set.add(baseTable.getName());
			 if (type == StatementTypes.UPDATE_WHERE || type == StatementTypes.MERGE) {
				 baseTable.collectFKWriteLocks(updateColumnMap, set);
			 }
			 else if (type == StatementTypes.DELETE_WHERE) {
				 baseTable.collectFKWriteLocks(null, set);
			 }
			 getTriggerTableNames(set, true);
		 }
	 }
	 void getTriggerTableNames(OrderedHashSet set, boolean write) {
		 for (int i = 0;
		 i < baseTable.triggerList.length;
		 i++) {
			 TriggerDef td = baseTable.triggerList[i];
			 switch (type) {
				 case StatementTypes.INSERT : if (td.getStatementType() == StatementTypes.INSERT) {
					 break;
				 }
				 continue;
				 case StatementTypes.UPDATE_WHERE : if (td.getStatementType() == StatementTypes.UPDATE_WHERE) {
					 break;
				 }
				 continue;
				 case StatementTypes.DELETE_WHERE : if (td.getStatementType() == StatementTypes.DELETE_WHERE) {
					 break;
				 }
				 continue;
				 case StatementTypes.MERGE : if (td.getStatementType() == StatementTypes.INSERT || td.getStatementType() == StatementTypes.UPDATE_WHERE) {
					 break;
				 }
				 continue;
				 default : throw Error.runtimeError(ErrorCode.U_S0500, ""StatementDML"");
			 }
			 if (td.routine != null) {
				 if (write) {
					 set.addAll(td.routine.getTableNamesForWrite());
				 }
				 else {
					 set.addAll(td.routine.getTableNamesForRead());
				 }
			 }
		 }
	 }
	 Result executeUpdateStatement(Session session) {
		 int count = 0;
		 Expression[] colExpressions = updateExpressions;
		 RowSetNavigatorDataChange rowset = new RowSetNavigatorDataChange();
		 Type[] colTypes = baseTable.getColumnTypes();
		 RangeIterator it = RangeVariable.getIterator(session, targetRangeVariables);
		 while (it.next()) {
			 session.sessionData.startRowProcessing();
			 Row row = it.getCurrentRow();
			 Object[] data = row.getData();
			 Object[] newData = getUpdatedData(session, targets, baseTable, updateColumnMap, colExpressions, colTypes, data);
			 if (updatableTableCheck != null) {
				 it.setCurrent(newData);
				 boolean check = updatableTableCheck.testCondition(session);
				 if (!check) {
					 it.release();
					 throw Error.error(ErrorCode.X_44000);
				 }
			 }
			 rowset.addRow(session, row, newData, colTypes, updateColumnMap);
		 }
		 it.release();
		 rowset.beforeFirst();
		 count = update(session, baseTable, rowset);
		 if (count == 1) {
			 return Result.updateOneResult;
		 }
		 else if (count == 0) {
			 return Result.updateZeroResult;
		 }
		 return new Result(ResultConstants.UPDATECOUNT, count);
	 }
	 static Object[] getUpdatedData(Session session, Expression[] targets, Table targetTable, int[] columnMap, Expression[] colExpressions, Type[] colTypes, Object[] oldData) {
		 Object[] data = targetTable.getEmptyRowData();
		 System.arraycopy(oldData, 0, data, 0, data.length);
		 for (int i = 0, ix = 0;
		 i < columnMap.length;
		 ) {
			 Expression expr = colExpressions[ix++];
			 if (expr.getType() == OpTypes.ROW) {
				 Object[] values = expr.getRowValue(session);
				 for (int j = 0;
				 j < values.length;
				 j++, i++) {
					 int colIndex = columnMap[i];
					 Expression e = expr.nodes[j];
					 if (targetTable.identityColumn == colIndex) {
						 if (e.getType() == OpTypes.VALUE && e.valueData == null) {
							 continue;
						 }
					 }
					 if (e.getType() == OpTypes.DEFAULT) {
						 if (targetTable.identityColumn == colIndex) {
							 continue;
						 }
						 data[colIndex] = targetTable.colDefaults[colIndex].getValue( session);
						 continue;
					 }
					 data[colIndex] = colTypes[colIndex].convertToType(session, values[j], e.dataType);
				 }
			 }
			 else if (expr.getType() == OpTypes.ROW_SUBQUERY) {
				 Object[] values = expr.getRowValue(session);
				 for (int j = 0;
				 j < values.length;
				 j++, i++) {
					 int colIndex = columnMap[i];
					 Type colType = expr.subQuery.queryExpression.getMetaData() .columnTypes[j];
					 data[colIndex] = colTypes[colIndex].convertToType(session, values[j], colType);
				 }
			 }
			 else {
				 int colIndex = columnMap[i];
				 if (expr.getType() == OpTypes.DEFAULT) {
					 if (targetTable.identityColumn == colIndex) {
						 i++;
						 continue;
					 }
					 data[colIndex] = targetTable.colDefaults[colIndex].getValue(session);
					 i++;
					 continue;
				 }
				 Object value = expr.getValue(session);
				 if (targets[i].getType() == OpTypes.ARRAY_ACCESS) {
					 data[colIndex] = ((ExpressionAccessor) targets[i]).getUpdatedArray( session, (Object[]) data[colIndex], value, true);
				 }
				 else {
					 data[colIndex] = colTypes[colIndex].convertToType(session, value, expr.dataType);
				 }
				 i++;
			 }
		 }
		 return data;
	 }
	 Result executeMergeStatement(Session session) {
		 Type[] colTypes = baseTable.getColumnTypes();
		 Result resultOut = null;
		 RowSetNavigator generatedNavigator = null;
		 if (generatedIndexes != null) {
			 resultOut = Result.newUpdateCountResult(generatedResultMetaData, 0);
			 generatedNavigator = resultOut.getChainedResult().getNavigator();
		 }
		 int count = 0;
		 RowSetNavigatorClient newData = new RowSetNavigatorClient(8);
		 RowSetNavigatorDataChange updateRowSet = new RowSetNavigatorDataChange();
		 RangeVariable[] joinRangeIterators = targetRangeVariables;
		 RangeIterator[] rangeIterators = new RangeIterator[joinRangeIterators.length];
		 for (int i = 0;
		 i < joinRangeIterators.length;
		 i++) {
			 rangeIterators[i] = joinRangeIterators[i].getIterator(session);
		 }
		 for (int currentIndex = 0;
		 currentIndex >= 0;
		 ) {
			 RangeIterator it = rangeIterators[currentIndex];
			 boolean beforeFirst = it.isBeforeFirst();
			 if (it.next()) {
				 if (currentIndex < joinRangeIterators.length - 1) {
					 currentIndex++;
					 continue;
				 }
			 }
			 else {
				 if (currentIndex == 1 && beforeFirst && insertExpression != null) {
					 Object[] data = getInsertData(session, colTypes, insertExpression.nodes[0].nodes);
					 if (data != null) {
						 newData.add(data);
					 }
				 }
				 it.reset();
				 currentIndex--;
				 continue;
			 }
			 if (updateExpressions.length != 0) {
				 Row row = it.getCurrentRow();
				 Object[] data = getUpdatedData(session, targets, baseTable, updateColumnMap, updateExpressions, colTypes, row.getData());
				 try {
					 updateRowSet.addRow(session, row, data, colTypes, updateColumnMap);
				 }
				 catch (HsqlException e) {
					 for (int i = 0;
					 i < joinRangeIterators.length;
					 i++) {
						 rangeIterators[i].reset();
					 }
					 throw Error.error(ErrorCode.X_21000);
				 }
			 }
		 }
		 for (int i = 0;
		 i < joinRangeIterators.length;
		 i++) {
			 rangeIterators[i].reset();
		 }
		 if (updateExpressions.length != 0) {
			 count = update(session, baseTable, updateRowSet);
		 }
		 if (newData.getSize() > 0) {
			 insertRowSet(session, generatedNavigator, newData);
			 count += newData.getSize();
		 }
		 if (insertExpression != null && baseTable.triggerLists[Trigger.INSERT_AFTER].length > 0) {
			 baseTable.fireTriggers(session, Trigger.INSERT_AFTER, newData);
		 }
		 if (resultOut == null) {
			 if (count == 1) {
				 return Result.updateOneResult;
			 }
			 return new Result(ResultConstants.UPDATECOUNT, count);
		 }
		 else {
			 resultOut.setUpdateCount(count);
			 return resultOut;
		 }
	 }
	 void insertRowSet(Session session, RowSetNavigator generatedNavigator, RowSetNavigator newData) {
		 PersistentStore store = baseTable.getRowStore(session);
		 RangeIterator checkIterator = null;
		 if (updatableTableCheck != null) {
			 checkIterator = checkRangeVariable.getIterator(session);
		 }
		 newData.beforeFirst();
		 if (baseTable.triggerLists[Trigger.INSERT_BEFORE_ROW].length > 0) {
			 while (newData.hasNext()) {
				 Object[] data = (Object[]) newData.getNext();
				 baseTable.fireTriggers(session, Trigger.INSERT_BEFORE_ROW, null, data, null);
			 }
			 newData.beforeFirst();
		 }
		 while (newData.hasNext()) {
			 Object[] data = (Object[]) newData.getNext();
			 baseTable.insertSingleRow(session, store, data, null);
			 if (checkIterator != null) {
				 checkIterator.setCurrent(data);
				 boolean check = updatableTableCheck.testCondition(session);
				 if (!check) {
					 throw Error.error(ErrorCode.X_44000);
				 }
			 }
			 if (generatedNavigator != null) {
				 Object[] generatedValues = getGeneratedColumns(data);
				 generatedNavigator.add(generatedValues);
			 }
		 }
		 newData.beforeFirst();
		 while (newData.hasNext()) {
			 Object[] data = (Object[]) newData.getNext();
			 performIntegrityChecks(session, baseTable, null, data, null);
		 }
		 newData.beforeFirst();
		 if (baseTable.triggerLists[Trigger.INSERT_AFTER_ROW].length > 0) {
			 while (newData.hasNext()) {
				 Object[] data = (Object[]) newData.getNext();
				 baseTable.fireTriggers(session, Trigger.INSERT_AFTER_ROW, null, data, null);
			 }
			 newData.beforeFirst();
		 }
	 }
	 Result insertSingleRow(Session session, PersistentStore store, Object[] data) {
		 if (baseTable.triggerLists[Trigger.INSERT_BEFORE_ROW].length > 0) {
			 baseTable.fireTriggers(session, Trigger.INSERT_BEFORE_ROW, null, data, null);
		 }
		 baseTable.insertSingleRow(session, store, data, null);
		 performIntegrityChecks(session, baseTable, null, data, null);
		 if (session.database.isReferentialIntegrity()) {
			 for (int i = 0, size = baseTable.fkConstraints.length;
			 i < size;
			 i++) {
				 baseTable.fkConstraints[i].checkInsert(session, baseTable, data, true);
			 }
		 }
		 if (baseTable.triggerLists[Trigger.INSERT_AFTER_ROW].length > 0) {
			 baseTable.fireTriggers(session, Trigger.INSERT_AFTER_ROW, null, data, null);
		 }
		 if (baseTable.triggerLists[Trigger.INSERT_AFTER].length > 0) {
			 baseTable.fireTriggers(session, Trigger.INSERT_AFTER, (RowSetNavigator) null);
		 }
		 return Result.updateOneResult;
	 }
	 Object[] getInsertData(Session session, Type[] colTypes, Expression[] rowArgs) {
		 Object[] data = baseTable.getNewRowData(session);
		 session.sessionData.startRowProcessing();
		 for (int i = 0;
		 i < rowArgs.length;
		 i++) {
			 Expression e = rowArgs[i];
			 int colIndex = insertColumnMap[i];
			 if (e.opType == OpTypes.DEFAULT) {
				 if (baseTable.identityColumn == colIndex) {
					 continue;
				 }
				 if (baseTable.colDefaults[colIndex] != null) {
					 data[colIndex] = baseTable.colDefaults[colIndex].getValue(session);
					 continue;
				 }
				 continue;
			 }
			 Object value = e.getValue(session);
			 Type type = colTypes[colIndex];
			 if (colTypes[colIndex] != e.dataType) {
				 value = type.convertToType(session, value, e.dataType);
			 }
			 data[colIndex] = value;
		 }
		 return data;
	 }
	 int update(Session session, Table table, RowSetNavigatorDataChange navigator) {
		 int rowCount = navigator.getSize();
		 for (int i = 0;
		 i < rowCount;
		 i++) {
			 navigator.next();
			 Object[] data = navigator.getCurrentChangedData();
			 table.setIdentityColumn(session, data);
			 table.setGeneratedColumns(session, data);
		 }
		 navigator.beforeFirst();
		 if (table.fkMainConstraints.length > 0) {
			 HashSet path = session.sessionContext.getConstraintPath();
			 for (int i = 0;
			 i < rowCount;
			 i++) {
				 Row row = navigator.getNextRow();
				 Object[] data = navigator.getCurrentChangedData();
				 performReferentialActions(session, table, navigator, row, data, this.updateColumnMap, path);
				 path.clear();
			 }
			 navigator.beforeFirst();
		 }
		 for (int i = 0;
		 i < navigator.getSize();
		 i++) {
			 Row row = navigator.getNextRow();
			 Object[] data = navigator.getCurrentChangedData();
			 int[] changedColumns = navigator.getCurrentChangedColumns();
			 Table currentTable = ((Table) row.getTable());
			 if (currentTable.triggerLists[Trigger.UPDATE_BEFORE_ROW].length > 0) {
				 currentTable.fireTriggers(session, Trigger.UPDATE_BEFORE_ROW, row.getData(), data, changedColumns);
				 currentTable.enforceRowConstraints(session, data);
			 }
		 }
		 if (table.isView) {
			 return rowCount;
		 }
		 navigator.beforeFirst();
		 for (int i = 0;
		 i < navigator.getSize();
		 i++) {
			 Row row = navigator.getNextRow();
			 Table currentTable = ((Table) row.getTable());
			 int[] changedColumns = navigator.getCurrentChangedColumns();
			 session.addDeleteAction(currentTable, row, changedColumns);
		 }
		 navigator.beforeFirst();
		 for (int i = 0;
		 i < navigator.getSize();
		 i++) {
			 Row row = navigator.getNextRow();
			 Object[] data = navigator.getCurrentChangedData();
			 Table currentTable = ((Table) row.getTable());
			 int[] changedColumns = navigator.getCurrentChangedColumns();
			 PersistentStore store = currentTable.getRowStore(session);
			 if (data == null) {
				 continue;
			 }
			 Row newRow = currentTable.insertSingleRow(session, store, data, changedColumns);
		 }
		 navigator.beforeFirst();
		 OrderedHashSet extraUpdateTables = null;
		 boolean hasAfterRowTriggers = table.triggerLists[Trigger.UPDATE_AFTER_ROW].length > 0;
		 for (int i = 0;
		 i < navigator.getSize();
		 i++) {
			 Row row = navigator.getNextRow();
			 Table currentTable = ((Table) row.getTable());
			 Object[] changedData = navigator.getCurrentChangedData();
			 int[] changedColumns = navigator.getCurrentChangedColumns();
			 performIntegrityChecks(session, currentTable, row.getData(), changedData, changedColumns);
			 if (currentTable != table) {
				 if (extraUpdateTables == null) {
					 extraUpdateTables = new OrderedHashSet();
				 }
				 extraUpdateTables.add(currentTable);
				 if (currentTable.triggerLists[Trigger.UPDATE_AFTER_ROW].length > 0) {
					 hasAfterRowTriggers = true;
				 }
			 }
		 }
		 navigator.beforeFirst();
		 if (hasAfterRowTriggers) {
			 for (int i = 0;
			 i < navigator.getSize();
			 i++) {
				 Row row = navigator.getNextRow();
				 Object[] changedData = navigator.getCurrentChangedData();
				 int[] changedColumns = navigator.getCurrentChangedColumns();
				 Table currentTable = ((Table) row.getTable());
				 currentTable.fireTriggers(session, Trigger.UPDATE_AFTER_ROW, row.getData(), changedData, changedColumns);
			 }
			 navigator.beforeFirst();
		 }
		 baseTable.fireTriggers(session, Trigger.UPDATE_AFTER, navigator);
		 if (extraUpdateTables != null) {
			 for (int i = 0;
			 i < extraUpdateTables.size();
			 i++) {
				 Table currentTable = (Table) extraUpdateTables.get(i);
				 currentTable.fireTriggers(session, Trigger.UPDATE_AFTER, navigator);
			 }
		 }
		 return rowCount;
	 }
	 Result executeDeleteStatement(Session session) {
		 int count = 0;
		 RangeIterator it = RangeVariable.getIterator(session, targetRangeVariables);
		 RowSetNavigatorDataChange navigator = new RowSetNavigatorDataChange();
		 while (it.next()) {
			 Row currentRow = it.getCurrentRow();
			 navigator.addRow(currentRow);
		 }
		 it.release();
		 if (navigator.getSize() > 0) {
			 count = delete(session, baseTable, navigator);
		 }
		 else {
			 return Result.updateZeroResult;
		 }
		 if (count == 1) {
			 return Result.updateOneResult;
		 }
		 return new Result(ResultConstants.UPDATECOUNT, count);
	 }
	 Result executeDeleteTruncateStatement(Session session) {
		 PersistentStore store = targetTable.getRowStore(session);
		 RowIterator it = targetTable.getPrimaryIndex().firstRow(store);
		 try {
			 while (it.hasNext()) {
				 Row row = it.getNextRow();
				 session.addDeleteAction((Table) row.getTable(), row, null);
			 }
			 if (restartIdentity && targetTable.identitySequence != null) {
				 targetTable.identitySequence.reset();
			 }
		 }
		 finally {
			 it.release();
		 }
		 return Result.updateOneResult;
	 }
	 int delete(Session session, Table table, RowSetNavigatorDataChange navigator) {
		 int rowCount = navigator.getSize();
		 navigator.beforeFirst();
		 if (table.fkMainConstraints.length > 0) {
			 HashSet path = session.sessionContext.getConstraintPath();
			 for (int i = 0;
			 i < rowCount;
			 i++) {
				 navigator.next();
				 Row row = navigator.getCurrentRow();
				 performReferentialActions(session, table, navigator, row, null, null, path);
				 path.clear();
			 }
			 navigator.beforeFirst();
		 }
		 while (navigator.hasNext()) {
			 navigator.next();
			 Row row = navigator.getCurrentRow();
			 Object[] changedData = navigator.getCurrentChangedData();
			 int[] changedColumns = navigator.getCurrentChangedColumns();
			 Table currentTable = ((Table) row.getTable());
			 if (changedData == null) {
				 currentTable.fireTriggers(session, Trigger.DELETE_BEFORE_ROW, row.getData(), null, null);
			 }
			 else {
				 currentTable.fireTriggers(session, Trigger.UPDATE_BEFORE_ROW, row.getData(), changedData, changedColumns);
			 }
		 }
		 if (table.isView) {
			 return rowCount;
		 }
		 navigator.beforeFirst();
		 boolean hasUpdate = false;
		 for (int i = 0;
		 i < navigator.getSize();
		 i++) {
			 Row row = navigator.getNextRow();
			 Object[] data = navigator.getCurrentChangedData();
			 Table currentTable = ((Table) row.getTable());
			 session.addDeleteAction(currentTable, row, null);
			 if (data != null) {
				 hasUpdate = true;
			 }
		 }
		 navigator.beforeFirst();
		 if (hasUpdate) {
			 for (int i = 0;
			 i < navigator.getSize();
			 i++) {
				 Row row = navigator.getNextRow();
				 Object[] data = navigator.getCurrentChangedData();
				 Table currentTable = ((Table) row.getTable());
				 int[] changedColumns = navigator.getCurrentChangedColumns();
				 PersistentStore store = currentTable.getRowStore(session);
				 if (data == null) {
					 continue;
				 }
				 Row newRow = currentTable.insertSingleRow(session, store, data, changedColumns);
			 }
			 navigator.beforeFirst();
		 }
		 OrderedHashSet extraUpdateTables = null;
		 OrderedHashSet extraDeleteTables = null;
		 boolean hasAfterRowTriggers = table.triggerLists[Trigger.DELETE_AFTER_ROW].length > 0;
		 if (rowCount != navigator.getSize()) {
			 while (navigator.hasNext()) {
				 navigator.next();
				 Row row = navigator.getCurrentRow();
				 Object[] changedData = navigator.getCurrentChangedData();
				 int[] changedColumns = navigator.getCurrentChangedColumns();
				 Table currentTable = ((Table) row.getTable());
				 if (changedData != null) {
					 performIntegrityChecks(session, currentTable, row.getData(), changedData, changedColumns);
				 }
				 if (currentTable != table) {
					 if (changedData == null) {
						 if (currentTable.triggerLists[Trigger.DELETE_AFTER_ROW] .length > 0) {
							 hasAfterRowTriggers = true;
						 }
						 if (extraDeleteTables == null) {
							 extraDeleteTables = new OrderedHashSet();
						 }
						 extraDeleteTables.add(currentTable);
					 }
					 else {
						 if (currentTable.triggerLists[Trigger.UPDATE_AFTER_ROW] .length > 0) {
							 hasAfterRowTriggers = true;
						 }
						 if (extraUpdateTables == null) {
							 extraUpdateTables = new OrderedHashSet();
						 }
						 extraUpdateTables.add(currentTable);
					 }
				 }
			 }
			 navigator.beforeFirst();
		 }
		 if (hasAfterRowTriggers) {
			 while (navigator.hasNext()) {
				 navigator.next();
				 Row row = navigator.getCurrentRow();
				 Object[] changedData = navigator.getCurrentChangedData();
				 Table currentTable = ((Table) row.getTable());
				 if (changedData == null) {
					 currentTable.fireTriggers(session, Trigger.DELETE_AFTER_ROW, row.getData(), null, null);
				 }
				 else {
					 currentTable.fireTriggers(session, Trigger.UPDATE_AFTER_ROW, row.getData(), changedData, null);
				 }
			 }
			 navigator.beforeFirst();
		 }
		 table.fireTriggers(session, Trigger.DELETE_AFTER, navigator);
		 if (extraUpdateTables != null) {
			 for (int i = 0;
			 i < extraUpdateTables.size();
			 i++) {
				 Table currentTable = (Table) extraUpdateTables.get(i);
				 currentTable.fireTriggers(session, Trigger.UPDATE_AFTER, navigator);
			 }
		 }
		 if (extraDeleteTables != null) {
			 for (int i = 0;
			 i < extraDeleteTables.size();
			 i++) {
				 Table currentTable = (Table) extraDeleteTables.get(i);
				 currentTable.fireTriggers(session, Trigger.DELETE_AFTER, navigator);
			 }
		 }
		 return rowCount;
	 }
	 static void performIntegrityChecks(Session session, Table table, Object[] oldData, Object[] newData, int[] updatedColumns) {
		 if (newData == null) {
			 return;
		 }
		 for (int i = 0, size = table.checkConstraints.length;
		 i < size;
		 i++) {
			 table.checkConstraints[i].checkInsert(session, table, newData, oldData == null);
		 }
		 if (!session.database.isReferentialIntegrity()) {
			 return;
		 }
		 for (int i = 0, size = table.fkConstraints.length;
		 i < size;
		 i++) {
			 boolean check = oldData == null;
			 Constraint c = table.fkConstraints[i];
			 if (!check) {
				 check = ArrayUtil.haveCommonElement(c.getRefColumns(), updatedColumns);
			 }
			 if (check) {
				 c.checkInsert(session, table, newData, oldData == null);
			 }
		 }
	 }
	 static void performReferentialActions(Session session, Table table, RowSetNavigatorDataChange navigator, Row row, Object[] data, int[] changedCols, HashSet path) {
		 if (!session.database.isReferentialIntegrity()) {
			 return;
		 }
		 boolean delete = data == null;
		 for (int i = 0, size = table.fkMainConstraints.length;
		 i < size;
		 i++) {
			 Constraint c = table.fkMainConstraints[i];
			 int action = delete ? c.core.deleteAction : c.core.updateAction;
			 if (!delete) {
				 if (!ArrayUtil.haveCommonElement(changedCols, c.core.mainCols)) {
					 continue;
				 }
				 if (c.core.mainIndex.compareRowNonUnique( session, row.getData(), data, c.core.mainCols) == 0) {
					 continue;
				 }
			 }
			 RowIterator refiterator = c.findFkRef(session, row.getData());
			 if (!refiterator.hasNext()) {
				 refiterator.release();
				 continue;
			 }
			 while (refiterator.hasNext()) {
				 Row refRow = refiterator.getNextRow();
				 Object[] refData = null;
				 if (c.core.refIndex.compareRowNonUnique( session, refRow.getData(), row.getData(), c.core.mainCols) != 0) {
					 break;
				 }
				 if (delete && refRow.getId() == row.getId()) {
					 continue;
				 }
				 switch (action) {
					 case SchemaObject.ReferentialAction.CASCADE : {
						 if (delete) {
							 if (navigator.addRow(refRow)) {
								 performReferentialActions(session, c.core.refTable, navigator, refRow, null, null, path);
							 }
							 continue;
						 }
						 refData = c.core.refTable.getEmptyRowData();
						 System.arraycopy(refRow.getData(), 0, refData, 0, refData.length);
						 for (int j = 0;
						 j < c.core.refCols.length;
						 j++) {
							 refData[c.core.refCols[j]] = data[c.core.mainCols[j]];
						 }
						 break;
					 }
					 case SchemaObject.ReferentialAction.SET_NULL : {
						 refData = c.core.refTable.getEmptyRowData();
						 System.arraycopy(refRow.getData(), 0, refData, 0, refData.length);
						 for (int j = 0;
						 j < c.core.refCols.length;
						 j++) {
							 refData[c.core.refCols[j]] = null;
						 }
						 break;
					 }
					 case SchemaObject.ReferentialAction.SET_DEFAULT : {
						 refData = c.core.refTable.getEmptyRowData();
						 System.arraycopy(refRow.getData(), 0, refData, 0, refData.length);
						 for (int j = 0;
						 j < c.core.refCols.length;
						 j++) {
							 ColumnSchema col = c.core.refTable.getColumn(c.core.refCols[j]);
							 refData[c.core.refCols[j]] = col.getDefaultValue(session);
						 }
						 break;
					 }
					 case SchemaObject.ReferentialAction.NO_ACTION : case SchemaObject.ReferentialAction.RESTRICT : {
						 if (navigator.containsDeletedRow(refRow)) {
							 continue;
						 }
						 int errorCode = c.core.deleteAction == SchemaObject.ReferentialAction .NO_ACTION ? ErrorCode.X_23504 : ErrorCode.X_23001;
						 String[] info = new String[] {
						 c.core.refName.name, c.core.refTable.getName().name }
						;
						 refiterator.release();
						 throw Error.error(null, errorCode, ErrorCode.CONSTRAINT, info);
					 }
					 default : continue;
				 }
				 refData = navigator.addRow(session, refRow, refData, table.getColumnTypes(), c.core.refCols);
				 if (!path.add(c)) {
					 continue;
				 }
				 performReferentialActions(session, c.core.refTable, navigator, refRow, refData, c.core.refCols, path);
				 path.remove(c);
			 }
			 refiterator.release();
		 }
	 }
}",1,0,0,0
"protected boolean usingBaseJarName() {
	 return config.baseJarName != null;
 }",0,0,0,0
"NodeSortKey( TransformerImpl transformer, XPath selectPat, boolean treatAsNumbers, boolean descending, String langValue, boolean caseOrderUpper, PrefixResolver namespaceContext) throws javax.xml.transform.TransformerException;",0,0,0,1
"public static float toFloat(ByteBuffer bytes) {
	 return bytes.getFloat(bytes.position());
 }",0,0,0,0
"protected void delFile(FTPClient ftp, String filename) throws IOException, BuildException {
	 if (verbose) {
		 log(""deleting "" + filename);
	 }
	 if (!ftp.deleteFile(resolveFile(filename))) {
		 String s = ""could not delete file: "" + ftp.getReplyString();
		 if (skipFailedTransfers) {
			 log(s, Project.MSG_WARN);
			 skipped++;
		 }
		 else {
			 throw new BuildException(s);
		 }
	 }
	 else {
		 log(""File "" + filename + "" deleted from "" + server, Project.MSG_VERBOSE);
		 transferred++;
	 }
 }",0,0,0,0
"public interface PortSupplier {
	 boolean obtainSpecificPort(int portNumber);
	 int obtainPort(PortRange range);
	 void releasePort(int portNumber);
}",0,0,0,0
"public class TagTag extends DefineTagSupport {
	 private String name;
	 public TagTag() {
	 }
	 public void doTag(XMLOutput output) throws JellyTagException {
		 getTagLibrary().registerDynamicTag( getName(), getBody() );
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
}",0,1,0,0
"public class FluoOracleImpl implements FluoOracle {
	 private static final Logger log = LoggerFactory.getLogger(FluoOracleImpl.class);
	 private FluoConfiguration config;
	 private Environment env;
	 private AutoCloseable reporters;
	 private OracleServer oracleServer;
	 private NodeCache appIdCache;
	 public FluoOracleImpl(FluoConfiguration connConfig) {
		 Objects.requireNonNull(connConfig);
		 Preconditions.checkArgument(connConfig.hasRequiredConnectionProps());
		 config = FluoAdminImpl.mergeZookeeperConfig(connConfig);
		 Preconditions.checkArgument(config.hasRequiredOracleProps());
		 config.setConnectionRetryTimeout(-1);
		 try {
			 config.validate();
		 }
		 catch (Exception e) {
			 throw new IllegalArgumentException(""Invalid FluoConfiguration"", e);
		 }
	 }
	 public void start() {
		 try {
			 env = new Environment(config);
			 reporters = ReporterUtil.setupReporters(env);
			 appIdCache = CuratorUtil.startAppIdWatcher(env);
			 log.info(""Starting Oracle for Fluo '{
			}
			' application with the following configuration:"", config.getApplicationName());
			 env.getConfiguration().print();
			 oracleServer = new OracleServer(env);
			 oracleServer.start();
		 }
		 catch (Exception e) {
			 throw new FluoException(e);
		 }
	 }
	 public void stop() {
		 try {
			 oracleServer.stop();
			 appIdCache.close();
			 reporters.close();
			 env.close();
		 }
		 catch (Exception e) {
			 throw new FluoException(e);
		 }
	 }
	 public static void main(String[] args) {
		 if (args.length != 1) {
			 System.err.println(""Usage: FluoOracleImpl <fluoPropsPath>"");
			 System.exit(-1);
		 }
		 String propsPath = args[0];
		 Objects.requireNonNull(propsPath);
		 File propsFile = new File(propsPath);
		 if (!propsFile.exists()) {
			 System.err.println(""ERROR - Fluo properties file does not exist: "" + propsPath);
			 System.exit(-1);
		 }
		 Preconditions.checkArgument(propsFile.exists());
		 try {
			 FluoConfiguration config = new FluoConfiguration(propsFile);
			 FluoOracleImpl oracle = new FluoOracleImpl(config);
			 oracle.start();
			 while (true) {
				 UtilWaitThread.sleep(10000);
			 }
		 }
		 catch (Exception e) {
			 log.error(""Exception running FluoOracle: "", e);
		 }
	 }
}",0,0,0,0
"final class InterpreterData implements Serializable, DebuggableScript{
	 static final long serialVersionUID = 5067677351589230234L;
	 static final int INITIAL_MAX_ICODE_LENGTH = 1024;
	 static final int INITIAL_STRINGTABLE_SIZE = 64;
	 static final int INITIAL_NUMBERTABLE_SIZE = 64;
	 InterpreterData(int languageVersion, String sourceFile, String encodedSource) {
		 this.languageVersion = languageVersion;
		 this.itsSourceFile = sourceFile;
		 this.encodedSource = encodedSource;
		 init();
	 }
	 InterpreterData(InterpreterData parent) {
		 this.parentData = parent;
		 this.languageVersion = parent.languageVersion;
		 this.itsSourceFile = parent.itsSourceFile;
		 this.encodedSource = parent.encodedSource;
		 init();
	 }
	 private void init() {
		 itsICode = new byte[INITIAL_MAX_ICODE_LENGTH];
		 itsStringTable = new String[INITIAL_STRINGTABLE_SIZE];
	 }
	 String itsName;
	 String itsSourceFile;
	 boolean itsNeedsActivation;
	 int itsFunctionType;
	 String[] itsStringTable;
	 double[] itsDoubleTable;
	 InterpreterData[] itsNestedFunctions;
	 Object[] itsRegExpLiterals;
	 byte[] itsICode;
	 int[] itsExceptionTable;
	 int itsMaxVars;
	 int itsMaxLocals;
	 int itsMaxStack;
	 int itsMaxFrameArray;
	 String[] argNames;
	 int argCount;
	 int itsMaxCalleeArgs;
	 String encodedSource;
	 int encodedSourceStart;
	 int encodedSourceEnd;
	 int languageVersion;
	 boolean useDynamicScope;
	 boolean topLevel;
	 Object[] literalIds;
	 UintMap longJumps;
	 int firstLinePC = -1;
	 InterpreterData parentData;
	 boolean evalScriptFlag;
	 public boolean isTopLevel() {
		 return topLevel;
	 }
	 public boolean isFunction() {
		 return itsFunctionType != 0;
	 }
	 public String getFunctionName() {
		 return itsName;
	 }
	 public int getParamCount() {
		 return argCount;
	 }
	 public int getParamAndVarCount() {
		 return argNames.length;
	 }
	 public String getParamOrVarName(int index) {
		 return argNames[index];
	 }
	 public String getSourceName() {
		 return itsSourceFile;
	 }
	 public boolean isGeneratedScript() {
		 return ScriptRuntime.isGeneratedScript(itsSourceFile);
	 }
	 public int[] getLineNumbers() {
		 return Interpreter.getLineNumbers(this);
	 }
	 public int getFunctionCount() {
		 return (itsNestedFunctions == null) ? 0 : itsNestedFunctions.length;
	 }
	 public DebuggableScript getFunction(int index) {
		 return itsNestedFunctions[index];
	 }
	 public DebuggableScript getParent() {
		 return parentData;
	 }
}",0,0,0,0
"public class ReloadingClassLoader extends URLClassLoader{
	private static final Logger log = LoggerFactory.getLogger(ReloadingClassLoader.class);
	private static final Set<URL> urls = new HashSet<URL>();
	private static final List<String> patterns = new ArrayList<String>();
	private IChangeListener listener;
	private final Duration pollFrequency = Duration.seconds(3);
	private final IModificationWatcher watcher;
	static{
		addClassLoaderUrls(ReloadingClassLoader.class.getClassLoader());
		excludePattern(""org.apache.wicket.*"");
		includePattern(""org.apache.wicket.examples.*"");
	}
	protected boolean tryClassHere(String name){
		if (name != null && (name.startsWith(""java."") || name.startsWith(""javax.servlet""))){
			return false;
		}
		boolean tryHere;
		if (patterns == null || patterns.size() == 0){
			tryHere = true;
		}
		else{
			tryHere = false;
			Iterator<String> includesIterator = patterns.iterator();
			while (includesIterator.hasNext()){
				String rawpattern = includesIterator.next();
				if (rawpattern.length() <= 1){
					continue;
				}
				boolean isInclude = rawpattern.substring(0, 1).equals(""+"");
				String pattern = rawpattern.substring(1);
				if (WildcardMatcherHelper.match(pattern, name) != null){
					tryHere = isInclude;
				}
			}
		}
		return tryHere;
	}
	public static void includePattern(String pattern){
		patterns.add(""+"" + pattern);
	}
	public static void excludePattern(String pattern){
		patterns.add(""-"" + pattern);
	}
	public static List<String> getPatterns(){
		return patterns;
	}
	public static void addLocation(URL url){
		urls.add(url);
	}
	public static Set<URL> getLocations(){
		return urls;
	}
	private static void addClassLoaderUrls(ClassLoader loader){
		if (loader != null){
			final Enumeration<URL> resources;
			try{
				resources = loader.getResources("""");
			}
			catch (IOException e){
				throw new RuntimeException(e);
			}
			while (resources.hasMoreElements()){
				URL location = resources.nextElement();
				ReloadingClassLoader.addLocation(location);
			}
		}
	}
	public ReloadingClassLoader(ClassLoader parent){
		super(new URL[] {
		 }
		, parent);
		addClassLoaderUrls(parent);
		for (Iterator<URL> iter = urls.iterator();
		 iter.hasNext();
		){
			addURL(iter.next());
		}
		watcher = new ModificationWatcher(pollFrequency);
	}
	public final URL getResource(final String name){
		URL resource = findResource(name);
		ClassLoader parent = getParent();
		if (resource == null && parent != null){
			resource = parent.getResource(name);
		}
		return resource;
	}
	public final Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException{
		Class<?> clazz = findLoadedClass(name);
		if (clazz == null){
			final ClassLoader parent = getParent();
			if (tryClassHere(name)){
				try{
					clazz = findClass(name);
					watchForModifications(clazz);
				}
				catch (ClassNotFoundException cnfe){
					if (parent == null){
						throw cnfe;
					}
				}
			}
			if (clazz == null){
				if (parent == null){
					throw new ClassNotFoundException(name);
				}
				else{
					clazz = Class.forName(name, false, parent);
				}
			}
		}
		if (resolve){
			resolveClass(clazz);
		}
		return clazz;
	}
	public void setListener(IChangeListener listener){
		this.listener = listener;
	}
	private void watchForModifications(Class<?> clz){
		Iterator<URL> locationsIterator = urls.iterator();
		File clzFile = null;
		while (locationsIterator.hasNext()){
			URL location = locationsIterator.next();
			String clzLocation = location.getFile() + clz.getName().replaceAll(""\\."", ""/"") +"".class"";
			log.debug(""clzLocation="" + clzLocation);
			clzFile = new File(clzLocation);
			final File finalClzFile = clzFile;
			if (clzFile.exists()){
				log.info(""Watching changes of class "" + clzFile);
				watcher.add(clzFile, new IChangeListener(){
					public void onChange(){
						log.info(""Class file "" + finalClzFile + "" has changed, reloading"");
						try{
							listener.onChange();
						}
						catch (Exception e){
							log.error(""Could not notify listener"", e);
							watcher.remove(finalClzFile);
						}
					}
				}
				);
				break;
			}
			else{
				log.debug(""Class file does not exist: "" + clzFile);
			}
		}
		if (clzFile != null && !clzFile.exists()){
			log.debug(""Could not locate class "" + clz.getName());
		}
	}
	public void destroy(){
		watcher.destroy();
	}
}",0,0,0,0
"public class SSHUserInfo implements UserInfo, UIKeyboardInteractive {
	 private String name;
	 private String password = null;
	 private String keyfile;
	 private String passphrase = null;
	 private boolean trustAllCertificates;
	 public SSHUserInfo() {
		 super();
		 this.trustAllCertificates = false;
	 }
	 public SSHUserInfo(String password, boolean trustAllCertificates) {
		 super();
		 this.password = password;
		 this.trustAllCertificates = trustAllCertificates;
	 }
	 public String getName() {
		 return name;
	 }
	 public String getPassphrase(String message) {
		 return passphrase;
	 }
	 public String getPassword() {
		 return password;
	 }
	 public boolean prompt(String str) {
		 return false;
	 }
	 public boolean retry() {
		 return false;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public void setPassphrase(String passphrase) {
		 this.passphrase = passphrase;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public void setTrust(boolean trust) {
		 this.trustAllCertificates = trust;
	 }
	 public boolean getTrust() {
		 return this.trustAllCertificates;
	 }
	 public String getPassphrase() {
		 return passphrase;
	 }
	 public String getKeyfile() {
		 return keyfile;
	 }
	 public void setKeyfile(String keyfile) {
		 this.keyfile = keyfile;
	 }
	 public boolean promptPassphrase(String message) {
		 return true;
	 }
	 public boolean promptPassword(String passwordPrompt) {
		 return true;
	 }
	 public boolean promptYesNo(String message) {
		 return trustAllCertificates;
	 }
	 public void showMessage(String message) {
	 }
	 public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) {
		 if (prompt.length != 1 || echo[0] || this.password == null) {
			 return null;
		 }
		 String[] response = new String[1];
		 response[0] = this.password;
		 return response;
	 }
}",0,0,0,0
"public class TokenMgrError extends Error{
	 private static final long serialVersionUID = 1L;
	 static final int LEXICAL_ERROR = 0;
	 static final int STATIC_LEXER_ERROR = 1;
	 static final int INVALID_LEXICAL_STATE = 2;
	 static final int LOOP_DETECTED = 3;
	 int errorCode;
	 protected static final String addEscapes(String str) {
		 StringBuffer retval = new StringBuffer();
		 char ch;
		 for (int i = 0;
		 i < str.length();
		 i++) {
			 switch (str.charAt(i)) {
				 case 0 : continue;
				 case '\b': retval.append(""\\b"");
				 continue;
				 case '\t': retval.append(""\\t"");
				 continue;
				 case '\n': retval.append(""\\n"");
				 continue;
				 case '\f': retval.append(""\\f"");
				 continue;
				 case '\r': retval.append(""\\r"");
				 continue;
				 case '\""': retval.append(""\\\"""");
				 continue;
				 case '\'': retval.append(""\\\'"");
				 continue;
				 case '\\': retval.append(""\\\\"");
				 continue;
				 default: if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
					 String s = ""0000"" + Integer.toString(ch, 16);
					 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
				 }
				 else {
					 retval.append(ch);
				 }
				 continue;
			 }
		 }
		 return retval.toString();
	 }
	 protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
		 return(""Lexical error at line "" + errorLine + "", column "" + errorColumn + "". Encountered: "" + (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") + ""after : \"""" + addEscapes(errorAfter) + ""\"""");
	 }
	 public String getMessage() {
		 return super.getMessage();
	 }
	 public TokenMgrError() {
	 }
	 public TokenMgrError(String message, int reason) {
		 super(message);
		 errorCode = reason;
	 }
	 public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
		 this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
	 }
}",1,0,0,0
"public class StreamInSession extends AbstractStreamSession{
	 private static final Logger logger = LoggerFactory.getLogger(StreamInSession.class);
	 private static ConcurrentMap<Pair<InetAddress, Long>, StreamInSession> sessions = new NonBlockingHashMap<Pair<InetAddress, Long>, StreamInSession>();
	 private final Set<PendingFile> files = new NonBlockingHashSet<PendingFile>();
	 private final List<SSTableReader> readers = new ArrayList<SSTableReader>();
	 private PendingFile current;
	 private Socket socket;
	 private volatile int retries;
	 private StreamInSession(Pair<InetAddress, Long> context, IStreamCallback callback) {
		 super(null, context, callback);
	 }
	 public static StreamInSession create(InetAddress host, IStreamCallback callback) {
		 Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, System.nanoTime());
		 StreamInSession session = new StreamInSession(context, callback);
		 sessions.put(context, session);
		 return session;
	 }
	 public static StreamInSession get(InetAddress host, long sessionId) {
		 Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, sessionId);
		 StreamInSession session = sessions.get(context);
		 if (session == null) {
			 StreamInSession possibleNew = new StreamInSession(context, null);
			 if ((session = sessions.putIfAbsent(context, possibleNew)) == null) session = possibleNew;
		 }
		 return session;
	 }
	 public void setCurrentFile(PendingFile file) {
		 this.current = file;
	 }
	 public void setTable(String table) {
		 this.table = table;
	 }
	 public void setSocket(Socket socket) {
		 this.socket = socket;
	 }
	 public void addFiles(Collection<PendingFile> files) {
		 for (PendingFile file : files) {
			 if(logger.isDebugEnabled()) logger.debug(""Adding file {
			}
			 to Stream Request queue"", file.getFilename());
			 this.files.add(file);
		 }
	 }
	 public void finished(PendingFile remoteFile, SSTableReader reader) throws IOException {
		 if (logger.isDebugEnabled()) logger.debug(""Finished {
		}
		 (from {
		}
		). Sending ack to {
		}
		"", new Object[] {
		remoteFile, getHost(), this}
		);
		 assert reader != null;
		 readers.add(reader);
		 files.remove(remoteFile);
		 if (remoteFile.equals(current)) current = null;
		 StreamReply reply = new StreamReply(remoteFile.getFilename(), getSessionId(), StreamReply.Status.FILE_FINISHED);
		 sendMessage(reply.getMessage(Gossiper.instance.getVersion(getHost())));
		 logger.debug(""ack {
		}
		 sent for {
		}
		"", reply, remoteFile);
	 }
	 public void retry(PendingFile remoteFile) throws IOException {
		 retries++;
		 if (retries > DatabaseDescriptor.getMaxStreamingRetries()) {
			 logger.error(String.format(""Failed streaming session %d from %s while receiving %s"", getSessionId(), getHost().toString(), current), new IllegalStateException(""Too many retries for "" + remoteFile));
			 close(false);
			 return;
		 }
		 StreamReply reply = new StreamReply(remoteFile.getFilename(), getSessionId(), StreamReply.Status.FILE_RETRY);
		 logger.info(""Streaming of file {
		}
		 for {
		}
		 failed: requesting a retry."", remoteFile, this);
		 try {
			 sendMessage(reply.getMessage(Gossiper.instance.getVersion(getHost())));
		 }
		 catch (IOException e) {
			 logger.error(""Sending retry message failed, closing session."", e);
			 close(false);
		 }
	 }
	 public void sendMessage(Message message) throws IOException {
		 OutboundTcpConnection.write(message, String.valueOf(getSessionId()), new DataOutputStream(socket.getOutputStream()));
	 }
	 public void closeIfFinished() throws IOException {
		 if (files.isEmpty()) {
			 HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();
			 try {
				 for (SSTableReader sstable : readers) {
					 assert sstable.getTableName().equals(table);
					 if (!sstable.acquireReference()) throw new AssertionError(""We shouldn't fail acquiring a reference on a sstable that has just been transferred"");
					 ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());
					 cfs.addSSTable(sstable);
					 if (!cfstores.containsKey(cfs)) cfstores.put(cfs, new ArrayList<SSTableReader>());
					 cfstores.get(cfs).add(sstable);
				 }
				 for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet()) {
					 if (entry.getKey() != null) entry.getKey().indexManager.maybeBuildSecondaryIndexes(entry.getValue(), entry.getKey().indexManager.getIndexedColumns());
				 }
			 }
			 finally {
				 for (List<SSTableReader> referenced : cfstores.values()) SSTableReader.releaseReferences(referenced);
			 }
			 StreamReply reply = new StreamReply("""", getSessionId(), StreamReply.Status.SESSION_FINISHED);
			 logger.info(""Finished streaming session {
			}
			 from {
			}
			"", getSessionId(), getHost());
			 try {
				 if (socket != null) OutboundTcpConnection.write(reply.getMessage(Gossiper.instance.getVersion(getHost())), context.right.toString(), new DataOutputStream(socket.getOutputStream()));
				 else logger.debug(""No socket to reply to {
				}
				 with!"", getHost());
			 }
			 finally {
				 if (socket != null) socket.close();
			 }
			 close(true);
		 }
	 }
	 protected void closeInternal(boolean success) {
		 sessions.remove(context);
		 if (!success && FailureDetector.instance.isAlive(getHost())) {
			 try {
				 StreamReply reply = new StreamReply("""", getSessionId(), StreamReply.Status.SESSION_FAILURE);
				 MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());
			 }
			 catch (IOException ex) {
				 logger.error(""Error sending streaming session failure notification to "" + getHost(), ex);
			 }
		 }
	 }
	 public static Set<InetAddress> getSources() {
		 HashSet<InetAddress> set = new HashSet<InetAddress>();
		 for (StreamInSession session : sessions.values()) {
			 set.add(session.getHost());
		 }
		 return set;
	 }
	 public static Set<PendingFile> getIncomingFiles(InetAddress host) {
		 Set<PendingFile> set = new HashSet<PendingFile>();
		 for (Map.Entry<Pair<InetAddress, Long>, StreamInSession> entry : sessions.entrySet()) {
			 if (entry.getKey().left.equals(host)) {
				 StreamInSession session = entry.getValue();
				 if (session.current != null) set.add(session.current);
				 set.addAll(session.files);
			 }
		 }
		 return set;
	 }
}",0,0,0,0
"private void initComponents(){
	java.awt.GridBagConstraints gridBagConstraints;
	jPanel1 = new javax.swing.JPanel();
	jLabel3 = new javax.swing.JLabel();
	m_labelVersion = new javax.swing.JLabel();
	jLabel5 = new javax.swing.JLabel();
	jLabel1 = new javax.swing.JLabel();
	jLabel2 = new javax.swing.JLabel();
	jScrollPane1 = new javax.swing.JScrollPane();
	m_licenceTextArea = new javax.swing.JTextArea();
	jPanel2 = new javax.swing.JPanel();
	m_buttonOk = new javax.swing.JButton();
	setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
	setTitle(""About JSmooth"");
	setModal(true);
	setResizable(false);
	addWindowListener(new java.awt.event.WindowAdapter(){
		public void windowClosing(java.awt.event.WindowEvent evt){
			closeDialog(evt);
		}
	}
	);
	jPanel1.setLayout(new java.awt.GridBagLayout());
	jPanel1.setBorder(new javax.swing.border.CompoundBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(5, 5, 5, 5)), new javax.swing.border.EtchedBorder()));
	jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
	jLabel3.setText(""<html><big>JSmooth</big></html>"");
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridx = 2;
	gridBagConstraints.gridy = 1;
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.weightx = 0.5;
	jPanel1.add(jLabel3, gridBagConstraints);
	m_labelVersion.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
	m_labelVersion.setText(""Unknown Version"");
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridy = 2;
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.weightx = 0.5;
	jPanel1.add(m_labelVersion, gridBagConstraints);
	jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
	jLabel5.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/icons/gnome-application-x-jar.png"")));
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.weightx = 0.1;
	jPanel1.add(jLabel5, gridBagConstraints);
	jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
	jLabel1.setText(""<html><b>Author</b></html>"");
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
	jPanel1.add(jLabel1, gridBagConstraints);
	jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
	jLabel2.setText(""Rodrigo Reyes <reyes>"");
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	jPanel1.add(jLabel2, gridBagConstraints);
	m_licenceTextArea.setEditable(false);
	m_licenceTextArea.setLineWrap(true);
	m_licenceTextArea.setText(""This program is free software;
	 you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation;
	 either version 2 of the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
	 without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with this program;
	 if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."");
	m_licenceTextArea.setWrapStyleWord(true);
	jScrollPane1.setViewportView(m_licenceTextArea);
	gridBagConstraints = new java.awt.GridBagConstraints();
	gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	gridBagConstraints.gridheight = 3;
	gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	gridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);
	gridBagConstraints.weightx = 1.0;
	gridBagConstraints.weighty = 1.0;
	jPanel1.add(jScrollPane1, gridBagConstraints);
	getContentPane().add(jPanel1, java.awt.BorderLayout.CENTER);
	m_buttonOk.setText(""OK"");
	m_buttonOk.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			buttonOkActionPerformed(evt);
		}
	}
	);
	jPanel2.add(m_buttonOk);
	getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);
	java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
	setBounds((screenSize.width-450)/2, (screenSize.height-350)/2, 450, 350);
}",0,0,1,0
"public class Parserimplements ParserTreeConstants, ParserConstants {
	 protected JJTParserState jjtree = new JJTParserState();
	boolean retainComments = false;
	 public void setRetainComments( boolean b ) {
		 retainComments = b;
	 }
	 void jjtreeOpenNodeScope(Node n) {
		 ((SimpleNode)n).firstToken = getToken(1);
	 }
	 void jjtreeCloseNodeScope(Node n) {
		 ((SimpleNode)n).lastToken = getToken(0);
	 }
	 void reInitInput( Reader in ) {
		 ReInit(in);
	 }
	 public SimpleNode popNode() {
		 if ( jjtree.nodeArity() > 0) return (SimpleNode)jjtree.popNode();
		 else return null;
	 }
	 void reInitTokenInput( Reader in ) {
		 jj_input_stream.ReInit( in, jj_input_stream.getEndLine(), jj_input_stream.getEndColumn() );
	 }
	 public static void main( String [] args ) throws IOException, ParseException {
		 boolean print = false;
		 int i=0;
		 if ( args[0].equals(""-p"") ) {
			 i++;
			 print=true;
		 }
		 for(;
		 i< args.length;
		 i++) {
			 Reader in = new FileReader(args[i]);
			 Parser parser = new Parser(in);
			 parser.setRetainComments(true);
			 while( !parser.Line() ) if ( print ) System.out.println( parser.popNode() );
		 }
	 }
	 boolean isRegularForStatement() {
		 int curTok = 1;
		 Token tok;
		 tok = getToken(curTok++);
		 if ( tok.kind != FOR ) return false;
		 tok = getToken(curTok++);
		 if ( tok.kind != LPAREN ) return false;
		 while (true) {
			 tok = getToken(curTok++);
			 switch (tok.kind) {
				 case COLON: return false;
				 case SEMICOLON: return true;
				 case EOF: return false;
			 }
		 }
	 }
	 ParseException createParseException( String message ) {
		 Token errortok = token;
		 int line = errortok.beginLine, column = errortok.beginColumn;
		 String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
		 return new ParseException( ""Parse error at line "" + line + "", column "" + column + "" : "" + message );
	 }
	 final public boolean Line() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case 0: jj_consume_token(0);
			 Interpreter.debug(""End of File!"");
			 {
				if (true) return true;
			}
			 break;
			 default: if (jj_2_1(1)) {
				 BlockStatement();
				 {
					if (true) return false;
				}
			 }
			 else {
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public Modifiers Modifiers(int context, boolean lookahead) throws ParseException {
		 Modifiers mods = null;
		 label_1: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ABSTRACT: case FINAL: case NATIVE: case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case STRICTFP: case SYNCHRONIZED: case TRANSIENT: case VOLATILE: ;
				 break;
				 default: break label_1;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PRIVATE: jj_consume_token(PRIVATE);
				 break;
				 case PROTECTED: jj_consume_token(PROTECTED);
				 break;
				 case PUBLIC: jj_consume_token(PUBLIC);
				 break;
				 case SYNCHRONIZED: jj_consume_token(SYNCHRONIZED);
				 break;
				 case FINAL: jj_consume_token(FINAL);
				 break;
				 case NATIVE: jj_consume_token(NATIVE);
				 break;
				 case TRANSIENT: jj_consume_token(TRANSIENT);
				 break;
				 case VOLATILE: jj_consume_token(VOLATILE);
				 break;
				 case ABSTRACT: jj_consume_token(ABSTRACT);
				 break;
				 case STATIC: jj_consume_token(STATIC);
				 break;
				 case STRICTFP: jj_consume_token(STRICTFP);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 if ( !lookahead ) try {
				 if ( mods == null ) mods = new Modifiers();
				 mods.addModifier( context, getToken(0).image );
			 }
			 catch ( IllegalStateException e ) {
				 {
					if (true) throw createParseException( e.getMessage() );
				}
			 }
		 }
		 {
			if (true) return mods;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void ClassDeclaration() throws ParseException {
		 BSHClassDeclaration jjtn000 = new BSHClassDeclaration(JJTCLASSDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Modifiers mods;
		 Token name;
		 int numInterfaces;
		 try {
			 mods = Modifiers(Modifiers.CLASS, false);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CLASS: jj_consume_token(CLASS);
				 break;
				 case INTERFACE: jj_consume_token(INTERFACE);
				 jjtn000.isInterface=true;
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 name = jj_consume_token(IDENTIFIER);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EXTENDS: jj_consume_token(EXTENDS);
				 AmbiguousName();
				 jjtn000.extend = true;
				 break;
				 default: ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IMPLEMENTS: jj_consume_token(IMPLEMENTS);
				 numInterfaces = NameList();
				 jjtn000.numInterfaces=numInterfaces;
				 break;
				 default: ;
			 }
			 Block();
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.modifiers = mods;
			 jjtn000.name = name.image;
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void MethodDeclaration() throws ParseException {
		 BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t = null;
		 Modifiers mods;
		 int count;
		 try {
			 mods = Modifiers(Modifiers.METHOD, false);
			 jjtn000.modifiers = mods;
			 if (jj_2_2(2147483647)) {
				 t = jj_consume_token(IDENTIFIER);
				 jjtn000.name = t.image;
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FLOAT: case INT: case LONG: case SHORT: case VOID: case IDENTIFIER: ReturnType();
					 t = jj_consume_token(IDENTIFIER);
					 jjtn000.name = t.image;
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
			 FormalParameters();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case THROWS: jj_consume_token(THROWS);
				 count = NameList();
				 jjtn000.numThrows=count;
				 break;
				 default: ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LBRACE: Block();
				 break;
				 case SEMICOLON: jj_consume_token(SEMICOLON);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void PackageDeclaration() throws ParseException {
		 BSHPackageDeclaration jjtn000 = new BSHPackageDeclaration(JJTPACKAGEDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(PACKAGE);
			 AmbiguousName();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ImportDeclaration() throws ParseException {
		 BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token s = null;
		 Token t = null;
		 try {
			 if (jj_2_3(3)) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case STATIC: s = jj_consume_token(STATIC);
					 break;
					 default: ;
				 }
				 jj_consume_token(IMPORT);
				 AmbiguousName();
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DOT: t = jj_consume_token(DOT);
					 jj_consume_token(STAR);
					 break;
					 default: ;
				 }
				 jj_consume_token(SEMICOLON);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 if ( s != null ) jjtn000.staticImport = true;
				 if ( t != null ) jjtn000.importPackage = true;
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case IMPORT: jj_consume_token(IMPORT);
					 jj_consume_token(STAR);
					 jj_consume_token(SEMICOLON);
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtreeCloseNodeScope(jjtn000);
					 jjtn000.superImport = true;
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void VariableDeclarator() throws ParseException {
		 BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t;
		 try {
			 t = jj_consume_token(IDENTIFIER);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ASSIGN: jj_consume_token(ASSIGN);
				 VariableInitializer();
				 break;
				 default: ;
			 }
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.name = t.image;
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void VariableInitializer() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case LBRACE: ArrayInitializer();
			 break;
			 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: Expression();
			 break;
			 default: jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ArrayInitializer() throws ParseException {
		 BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(LBRACE);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case LBRACE: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: VariableInitializer();
				 label_2: while (true) {
					 if (jj_2_4(2)) {
						 ;
					 }
					 else {
						 break label_2;
					 }
					 jj_consume_token(COMMA);
					 VariableInitializer();
				 }
				 break;
				 default: ;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case COMMA: jj_consume_token(COMMA);
				 break;
				 default: ;
			 }
			 jj_consume_token(RBRACE);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void FormalParameters() throws ParseException {
		 BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(LPAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FLOAT: case INT: case LONG: case SHORT: case IDENTIFIER: FormalParameter();
				 label_3: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case COMMA: ;
						 break;
						 default: break label_3;
					 }
					 jj_consume_token(COMMA);
					 FormalParameter();
				 }
				 break;
				 default: ;
			 }
			 jj_consume_token(RPAREN);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void FormalParameter() throws ParseException {
		 BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t;
		 try {
			 if (jj_2_5(2)) {
				 Type();
				 t = jj_consume_token(IDENTIFIER);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.name = t.image;
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case IDENTIFIER: t = jj_consume_token(IDENTIFIER);
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtreeCloseNodeScope(jjtn000);
					 jjtn000.name = t.image;
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void Type() throws ParseException {
		 BSHType jjtn000 = new BSHType(JJTTYPE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FLOAT: case INT: case LONG: case SHORT: PrimitiveType();
				 break;
				 case IDENTIFIER: AmbiguousName();
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 label_4: while (true) {
				 if (jj_2_6(2)) {
					 ;
				 }
				 else {
					 break label_4;
				 }
				 jj_consume_token(LBRACKET);
				 jj_consume_token(RBRACKET);
				 jjtn000.addArrayDimension();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ReturnType() throws ParseException {
		 BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case VOID: jj_consume_token(VOID);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.isVoid = true;
				 break;
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FLOAT: case INT: case LONG: case SHORT: case IDENTIFIER: Type();
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void PrimitiveType() throws ParseException {
		 BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: jj_consume_token(BOOLEAN);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Boolean.TYPE;
				 break;
				 case CHAR: jj_consume_token(CHAR);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Character.TYPE;
				 break;
				 case BYTE: jj_consume_token(BYTE);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Byte.TYPE;
				 break;
				 case SHORT: jj_consume_token(SHORT);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Short.TYPE;
				 break;
				 case INT: jj_consume_token(INT);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Integer.TYPE;
				 break;
				 case LONG: jj_consume_token(LONG);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Long.TYPE;
				 break;
				 case FLOAT: jj_consume_token(FLOAT);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Float.TYPE;
				 break;
				 case DOUBLE: jj_consume_token(DOUBLE);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.type = Double.TYPE;
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void AmbiguousName() throws ParseException {
		 BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t;
		 StringBuffer s;
		 try {
			 t = jj_consume_token(IDENTIFIER);
			 s = new StringBuffer(t.image);
			 label_5: while (true) {
				 if (jj_2_7(2)) {
					 ;
				 }
				 else {
					 break label_5;
				 }
				 jj_consume_token(DOT);
				 t = jj_consume_token(IDENTIFIER);
				 s.append("".""+t.image);
			 }
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.text = s.toString();
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public int NameList() throws ParseException {
		 int count = 0;
		 AmbiguousName();
		 ++count;
		 label_6: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case COMMA: ;
				 break;
				 default: break label_6;
			 }
			 jj_consume_token(COMMA);
			 AmbiguousName();
			 ++count;
		 }
		 {
			if (true) return count;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void Expression() throws ParseException {
		 if (jj_2_8(2147483647)) {
			 Assignment();
		 }
		 else {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: ConditionalExpression();
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void Assignment() throws ParseException {
		 BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		int op ;
		 try {
			 PrimaryExpression();
			 op = AssignmentOperator();
			 jjtn000.operator = op;
			 Expression();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public int AssignmentOperator() throws ParseException {
		 Token t;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case ASSIGN: jj_consume_token(ASSIGN);
			 break;
			 case STARASSIGN: jj_consume_token(STARASSIGN);
			 break;
			 case SLASHASSIGN: jj_consume_token(SLASHASSIGN);
			 break;
			 case MODASSIGN: jj_consume_token(MODASSIGN);
			 break;
			 case PLUSASSIGN: jj_consume_token(PLUSASSIGN);
			 break;
			 case MINUSASSIGN: jj_consume_token(MINUSASSIGN);
			 break;
			 case ANDASSIGN: jj_consume_token(ANDASSIGN);
			 break;
			 case XORASSIGN: jj_consume_token(XORASSIGN);
			 break;
			 case ORASSIGN: jj_consume_token(ORASSIGN);
			 break;
			 case LSHIFTASSIGN: jj_consume_token(LSHIFTASSIGN);
			 break;
			 case LSHIFTASSIGNX: jj_consume_token(LSHIFTASSIGNX);
			 break;
			 case RSIGNEDSHIFTASSIGN: jj_consume_token(RSIGNEDSHIFTASSIGN);
			 break;
			 case RSIGNEDSHIFTASSIGNX: jj_consume_token(RSIGNEDSHIFTASSIGNX);
			 break;
			 case RUNSIGNEDSHIFTASSIGN: jj_consume_token(RUNSIGNEDSHIFTASSIGN);
			 break;
			 case RUNSIGNEDSHIFTASSIGNX: jj_consume_token(RUNSIGNEDSHIFTASSIGNX);
			 break;
			 default: jj_consume_token(-1);
			 throw new ParseException();
		 }
		 t = getToken(0);
		 {
			if (true) return t.kind;
		}
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void ConditionalExpression() throws ParseException {
		 ConditionalOrExpression();
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case HOOK: jj_consume_token(HOOK);
			 Expression();
			 jj_consume_token(COLON);
			 BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 ConditionalExpression();
			 }
			 catch (Throwable jjte001) {
				 if (jjtc001) {
					 jjtree.clearNodeScope(jjtn001);
					 jjtc001 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte001 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte001;
					}
				 }
				 if (jjte001 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte001;
					}
				 }
				 {
					if (true) throw (Error)jjte001;
				}
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 3);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
			 break;
			 default: ;
		 }
	 }
	 final public void ConditionalOrExpression() throws ParseException {
		 Token t=null;
		 ConditionalAndExpression();
		 label_7: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOL_OR: case BOOL_ORX: ;
				 break;
				 default: break label_7;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOL_OR: t = jj_consume_token(BOOL_OR);
				 break;
				 case BOOL_ORX: t = jj_consume_token(BOOL_ORX);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 ConditionalAndExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void ConditionalAndExpression() throws ParseException {
		 Token t=null;
		 InclusiveOrExpression();
		 label_8: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOL_AND: case BOOL_ANDX: ;
				 break;
				 default: break label_8;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOL_AND: t = jj_consume_token(BOOL_AND);
				 break;
				 case BOOL_ANDX: t = jj_consume_token(BOOL_ANDX);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 InclusiveOrExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void InclusiveOrExpression() throws ParseException {
		 Token t=null;
		 ExclusiveOrExpression();
		 label_9: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BIT_OR: case BIT_ORX: ;
				 break;
				 default: break label_9;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BIT_OR: t = jj_consume_token(BIT_OR);
				 break;
				 case BIT_ORX: t = jj_consume_token(BIT_ORX);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 ExclusiveOrExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void ExclusiveOrExpression() throws ParseException {
		 Token t=null;
		 AndExpression();
		 label_10: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case XOR: ;
				 break;
				 default: break label_10;
			 }
			 t = jj_consume_token(XOR);
			 AndExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void AndExpression() throws ParseException {
		 Token t=null;
		 EqualityExpression();
		 label_11: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BIT_AND: case BIT_ANDX: ;
				 break;
				 default: break label_11;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BIT_AND: t = jj_consume_token(BIT_AND);
				 break;
				 case BIT_ANDX: t = jj_consume_token(BIT_ANDX);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 EqualityExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void EqualityExpression() throws ParseException {
		 Token t = null;
		 InstanceOfExpression();
		 label_12: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EQ: case NE: ;
				 break;
				 default: break label_12;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EQ: t = jj_consume_token(EQ);
				 break;
				 case NE: t = jj_consume_token(NE);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 InstanceOfExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void InstanceOfExpression() throws ParseException {
		 Token t = null;
		 RelationalExpression();
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case INSTANCEOF: t = jj_consume_token(INSTANCEOF);
			 Type();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
			 break;
			 default: ;
		 }
	 }
	 final public void RelationalExpression() throws ParseException {
		 Token t = null;
		 ShiftExpression();
		 label_13: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case GT: case GTX: case LT: case LTX: case LE: case LEX: case GE: case GEX: ;
				 break;
				 default: break label_13;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LT: t = jj_consume_token(LT);
				 break;
				 case LTX: t = jj_consume_token(LTX);
				 break;
				 case GT: t = jj_consume_token(GT);
				 break;
				 case GTX: t = jj_consume_token(GTX);
				 break;
				 case LE: t = jj_consume_token(LE);
				 break;
				 case LEX: t = jj_consume_token(LEX);
				 break;
				 case GE: t = jj_consume_token(GE);
				 break;
				 case GEX: t = jj_consume_token(GEX);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 ShiftExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void ShiftExpression() throws ParseException {
		 Token t = null;
		 AdditiveExpression();
		 label_14: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LSHIFT: case LSHIFTX: case RSIGNEDSHIFT: case RSIGNEDSHIFTX: case RUNSIGNEDSHIFT: case RUNSIGNEDSHIFTX: ;
				 break;
				 default: break label_14;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LSHIFT: t = jj_consume_token(LSHIFT);
				 break;
				 case LSHIFTX: t = jj_consume_token(LSHIFTX);
				 break;
				 case RSIGNEDSHIFT: t = jj_consume_token(RSIGNEDSHIFT);
				 break;
				 case RSIGNEDSHIFTX: t = jj_consume_token(RSIGNEDSHIFTX);
				 break;
				 case RUNSIGNEDSHIFT: t = jj_consume_token(RUNSIGNEDSHIFT);
				 break;
				 case RUNSIGNEDSHIFTX: t = jj_consume_token(RUNSIGNEDSHIFTX);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 AdditiveExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void AdditiveExpression() throws ParseException {
		 Token t = null;
		 MultiplicativeExpression();
		 label_15: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PLUS: case MINUS: ;
				 break;
				 default: break label_15;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PLUS: t = jj_consume_token(PLUS);
				 break;
				 case MINUS: t = jj_consume_token(MINUS);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 MultiplicativeExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void MultiplicativeExpression() throws ParseException {
		 Token t = null;
		 UnaryExpression();
		 label_16: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case STAR: case SLASH: case MOD: ;
				 break;
				 default: break label_16;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case STAR: t = jj_consume_token(STAR);
				 break;
				 case SLASH: t = jj_consume_token(SLASH);
				 break;
				 case MOD: t = jj_consume_token(MOD);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 UnaryExpression();
			 BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 2);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
	 }
	 final public void UnaryExpression() throws ParseException {
		 Token t = null;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case PLUS: case MINUS: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PLUS: t = jj_consume_token(PLUS);
				 break;
				 case MINUS: t = jj_consume_token(MINUS);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 UnaryExpression();
			 BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 1);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 1);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
			 break;
			 case INCR: PreIncrementExpression();
			 break;
			 case DECR: PreDecrementExpression();
			 break;
			 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: UnaryExpressionNotPlusMinus();
			 break;
			 default: jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void PreIncrementExpression() throws ParseException {
		 Token t = null;
		 t = jj_consume_token(INCR);
		 PrimaryExpression();
		 BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 jjtreeOpenNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, 1);
			 jjtc001 = false;
			 jjtreeCloseNodeScope(jjtn001);
			 jjtn001.kind = t.kind;
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, 1);
				 jjtreeCloseNodeScope(jjtn001);
			 }
		 }
	 }
	 final public void PreDecrementExpression() throws ParseException {
		 Token t = null;
		 t = jj_consume_token(DECR);
		 PrimaryExpression();
		 BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 jjtreeOpenNodeScope(jjtn001);
		 try {
			 jjtree.closeNodeScope(jjtn001, 1);
			 jjtc001 = false;
			 jjtreeCloseNodeScope(jjtn001);
			 jjtn001.kind = t.kind;
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, 1);
				 jjtreeCloseNodeScope(jjtn001);
			 }
		 }
	 }
	 final public void UnaryExpressionNotPlusMinus() throws ParseException {
		 Token t = null;
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case BANG: case TILDE: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case TILDE: t = jj_consume_token(TILDE);
				 break;
				 case BANG: t = jj_consume_token(BANG);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 UnaryExpression();
			 BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 1);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 1);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
			 break;
			 default: if (jj_2_9(2147483647)) {
				 CastExpression();
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: PostfixExpression();
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
	 }
	 final public void CastLookahead() throws ParseException {
		 if (jj_2_10(2)) {
			 jj_consume_token(LPAREN);
			 PrimitiveType();
		 }
		 else if (jj_2_11(2147483647)) {
			 jj_consume_token(LPAREN);
			 AmbiguousName();
			 jj_consume_token(LBRACKET);
			 jj_consume_token(RBRACKET);
		 }
		 else {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LPAREN: jj_consume_token(LPAREN);
				 AmbiguousName();
				 jj_consume_token(RPAREN);
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case TILDE: jj_consume_token(TILDE);
					 break;
					 case BANG: jj_consume_token(BANG);
					 break;
					 case LPAREN: jj_consume_token(LPAREN);
					 break;
					 case IDENTIFIER: jj_consume_token(IDENTIFIER);
					 break;
					 case NEW: jj_consume_token(NEW);
					 break;
					 case FALSE: case NULL: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: Literal();
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void PostfixExpression() throws ParseException {
		 Token t = null;
		 if (jj_2_12(2147483647)) {
			 PrimaryExpression();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case INCR: t = jj_consume_token(INCR);
				 break;
				 case DECR: t = jj_consume_token(DECR);
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
			 BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 jjtreeOpenNodeScope(jjtn001);
			 try {
				 jjtree.closeNodeScope(jjtn001, 1);
				 jjtc001 = false;
				 jjtreeCloseNodeScope(jjtn001);
				 jjtn001.kind = t.kind;
				 jjtn001.postfix = true;
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 1);
					 jjtreeCloseNodeScope(jjtn001);
				 }
			 }
		 }
		 else {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: PrimaryExpression();
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void CastExpression() throws ParseException {
		 BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 if (jj_2_13(2147483647)) {
				 jj_consume_token(LPAREN);
				 Type();
				 jj_consume_token(RPAREN);
				 UnaryExpression();
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LPAREN: jj_consume_token(LPAREN);
					 Type();
					 jj_consume_token(RPAREN);
					 UnaryExpressionNotPlusMinus();
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void PrimaryExpression() throws ParseException {
		 BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 PrimaryPrefix();
			 label_17: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LBRACE: case LBRACKET: case DOT: ;
					 break;
					 default: break label_17;
				 }
				 PrimarySuffix();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void MethodInvocation() throws ParseException {
		 BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 AmbiguousName();
			 Arguments();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void PrimaryPrefix() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case FALSE: case NULL: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: Literal();
			 break;
			 case LPAREN: jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 break;
			 case NEW: AllocationExpression();
			 break;
			 default: if (jj_2_14(2147483647)) {
				 MethodInvocation();
			 }
			 else if (jj_2_15(2147483647)) {
				 Type();
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case IDENTIFIER: AmbiguousName();
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
	 }
	 final public void PrimarySuffix() throws ParseException {
		 BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t = null;
		 try {
			 if (jj_2_16(2)) {
				 jj_consume_token(DOT);
				 jj_consume_token(CLASS);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.operation = BSHPrimarySuffix.CLASS;
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LBRACKET: jj_consume_token(LBRACKET);
					 Expression();
					 jj_consume_token(RBRACKET);
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtreeCloseNodeScope(jjtn000);
					 jjtn000.operation = BSHPrimarySuffix.INDEX;
					 break;
					 case DOT: jj_consume_token(DOT);
					 t = jj_consume_token(IDENTIFIER);
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case LPAREN: Arguments();
						 break;
						 default: ;
					 }
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtreeCloseNodeScope(jjtn000);
					 jjtn000.operation = BSHPrimarySuffix.NAME;
					 jjtn000.field = t.image;
					 break;
					 case LBRACE: jj_consume_token(LBRACE);
					 Expression();
					 jj_consume_token(RBRACE);
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtreeCloseNodeScope(jjtn000);
					 jjtn000.operation = BSHPrimarySuffix.PROPERTY;
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void Literal() throws ParseException {
		 BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token x;
		 boolean b;
		 String literal;
		 char ch;
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case INTEGER_LITERAL: x = jj_consume_token(INTEGER_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 literal = x.image;
				 ch = literal.charAt(literal.length()-1);
				 if(ch == 'l' || ch == 'L') {
					 literal = literal.substring(0,literal.length()-1);
					 jjtn000.value = new Primitive( new Long( literal ).longValue() );
				 }
				 else try {
					 jjtn000.value = new Primitive( Integer.decode( literal ).intValue() );
				 }
				 catch ( NumberFormatException e ) {
					 {
						if (true) throw createParseException( ""Error or number too big for integer type: ""+ literal );
					}
				 }
				 break;
				 case FLOATING_POINT_LITERAL: x = jj_consume_token(FLOATING_POINT_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 literal = x.image;
				 ch = literal.charAt(literal.length()-1);
				 if(ch == 'f' || ch == 'F') {
					 literal = literal.substring(0,literal.length()-1);
					 jjtn000.value = new Primitive( new Float( literal ).floatValue() );
				 }
				 else {
					 if(ch == 'd' || ch == 'D') literal = literal.substring(0,literal.length()-1);
					 jjtn000.value = new Primitive( new Double( literal ).doubleValue() );
				 }
				 break;
				 case CHARACTER_LITERAL: x = jj_consume_token(CHARACTER_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 try {
					 jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
				 }
				 catch ( Exception e ) {
					 {
						if (true) throw createParseException(""Error parsing character: ""+x.image);
					}
				 }
				 break;
				 case STRING_LITERAL: x = jj_consume_token(STRING_LITERAL);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 try {
					 jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
				 }
				 catch ( Exception e ) {
					 {
						if (true) throw createParseException(""Error parsing string: ""+x.image);
					}
				 }
				 break;
				 case FALSE: case TRUE: b = BooleanLiteral();
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.value = new Primitive( b );
				 break;
				 case NULL: NullLiteral();
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.value = Primitive.NULL;
				 break;
				 case VOID: VoidLiteral();
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.value = Primitive.VOID;
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public boolean BooleanLiteral() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case TRUE: jj_consume_token(TRUE);
			 {
				if (true) return true;
			}
			 break;
			 case FALSE: jj_consume_token(FALSE);
			 {
				if (true) return false;
			}
			 break;
			 default: jj_consume_token(-1);
			 throw new ParseException();
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void NullLiteral() throws ParseException {
		 jj_consume_token(NULL);
	 }
	 final public void VoidLiteral() throws ParseException {
		 jj_consume_token(VOID);
	 }
	 final public void Arguments() throws ParseException {
		 BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(LPAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: ArgumentList();
				 break;
				 default: ;
			 }
			 jj_consume_token(RPAREN);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ArgumentList() throws ParseException {
		 Expression();
		 label_18: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case COMMA: ;
				 break;
				 default: break label_18;
			 }
			 jj_consume_token(COMMA);
			 Expression();
		 }
	 }
	 final public void AllocationExpression() throws ParseException {
		 BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 if (jj_2_18(2)) {
				 jj_consume_token(NEW);
				 PrimitiveType();
				 ArrayDimensions();
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case NEW: jj_consume_token(NEW);
					 AmbiguousName();
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case LBRACKET: ArrayDimensions();
						 break;
						 case LPAREN: Arguments();
						 if (jj_2_17(2)) {
							 Block();
						 }
						 else {
							 ;
						 }
						 break;
						 default: jj_consume_token(-1);
						 throw new ParseException();
					 }
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ArrayDimensions() throws ParseException {
		 BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 if (jj_2_21(2)) {
				 label_19: while (true) {
					 jj_consume_token(LBRACKET);
					 Expression();
					 jj_consume_token(RBRACKET);
					 jjtn000.addDefinedDimension();
					 if (jj_2_19(2)) {
						 ;
					 }
					 else {
						 break label_19;
					 }
				 }
				 label_20: while (true) {
					 if (jj_2_20(2)) {
						 ;
					 }
					 else {
						 break label_20;
					 }
					 jj_consume_token(LBRACKET);
					 jj_consume_token(RBRACKET);
					 jjtn000.addUndefinedDimension();
				 }
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LBRACKET: label_21: while (true) {
						 jj_consume_token(LBRACKET);
						 jj_consume_token(RBRACKET);
						 jjtn000.addUndefinedDimension();
						 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
							 case LBRACKET: ;
							 break;
							 default: break label_21;
						 }
					 }
					 ArrayInitializer();
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void Statement() throws ParseException {
		 if (jj_2_22(2)) {
			 LabeledStatement();
		 }
		 else {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LBRACE: Block();
				 break;
				 case SEMICOLON: EmptyStatement();
				 break;
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: StatementExpression();
				 jj_consume_token(SEMICOLON);
				 break;
				 case SWITCH: SwitchStatement();
				 break;
				 case IF: IfStatement();
				 break;
				 case WHILE: WhileStatement();
				 break;
				 case DO: DoStatement();
				 break;
				 default: if (isRegularForStatement()) {
					 ForStatement();
				 }
				 else {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case FOR: EnhancedForStatement();
						 break;
						 case BREAK: BreakStatement();
						 break;
						 case CONTINUE: ContinueStatement();
						 break;
						 case RETURN: ReturnStatement();
						 break;
						 case SYNCHRONIZED: SynchronizedStatement();
						 break;
						 case THROW: ThrowStatement();
						 break;
						 case TRY: TryStatement();
						 break;
						 default: jj_consume_token(-1);
						 throw new ParseException();
					 }
				 }
			 }
		 }
	 }
	 final public void LabeledStatement() throws ParseException {
		 jj_consume_token(IDENTIFIER);
		 jj_consume_token(COLON);
		 Statement();
	 }
	 final public void Block() throws ParseException {
		 BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(LBRACE);
			 label_22: while (true) {
				 if (jj_2_23(1)) {
					 ;
				 }
				 else {
					 break label_22;
				 }
				 BlockStatement();
			 }
			 jj_consume_token(RBRACE);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void BlockStatement() throws ParseException {
		 if (jj_2_24(2147483647)) {
			 ClassDeclaration();
		 }
		 else if (jj_2_25(2147483647)) {
			 MethodDeclaration();
		 }
		 else if (jj_2_26(2147483647)) {
			 MethodDeclaration();
		 }
		 else if (jj_2_27(2147483647)) {
			 TypedVariableDeclaration();
			 jj_consume_token(SEMICOLON);
		 }
		 else if (jj_2_28(1)) {
			 Statement();
		 }
		 else {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IMPORT: case STATIC: ImportDeclaration();
				 break;
				 case PACKAGE: PackageDeclaration();
				 break;
				 case FORMAL_COMMENT: FormalComment();
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void FormalComment() throws ParseException {
		 BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t;
		 try {
			 t = jj_consume_token(FORMAL_COMMENT);
			 jjtree.closeNodeScope(jjtn000, retainComments);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.text=t.image;
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, retainComments);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void EmptyStatement() throws ParseException {
		 jj_consume_token(SEMICOLON);
	 }
	 final public void StatementExpression() throws ParseException {
		 Expression();
	 }
	 final public void SwitchStatement() throws ParseException {
		 BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(SWITCH);
			 jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 jj_consume_token(LBRACE);
			 label_23: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CASE: case _DEFAULT: ;
					 break;
					 default: break label_23;
				 }
				 SwitchLabel();
				 label_24: while (true) {
					 if (jj_2_29(1)) {
						 ;
					 }
					 else {
						 break label_24;
					 }
					 BlockStatement();
				 }
			 }
			 jj_consume_token(RBRACE);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void SwitchLabel() throws ParseException {
		 BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case CASE: jj_consume_token(CASE);
				 Expression();
				 jj_consume_token(COLON);
				 break;
				 case _DEFAULT: jj_consume_token(_DEFAULT);
				 jj_consume_token(COLON);
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.isDefault = true;
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void IfStatement() throws ParseException {
		 BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(IF);
			 jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 Statement();
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ELSE: jj_consume_token(ELSE);
				 Statement();
				 break;
				 default: ;
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void WhileStatement() throws ParseException {
		 BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(WHILE);
			 jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 Statement();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void DoStatement() throws ParseException {
		 BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(DO);
			 Statement();
			 jj_consume_token(WHILE);
			 jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 jj_consume_token(SEMICOLON);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.isDoStatement=true;
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ForStatement() throws ParseException {
		 BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t = null;
		 try {
			 jj_consume_token(FOR);
			 jj_consume_token(LPAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case ABSTRACT: case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FINAL: case FLOAT: case INT: case LONG: case NATIVE: case NEW: case NULL: case PRIVATE: case PROTECTED: case PUBLIC: case SHORT: case STATIC: case STRICTFP: case SYNCHRONIZED: case TRANSIENT: case TRUE: case VOID: case VOLATILE: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: ForInit();
				 jjtn000.hasForInit=true;
				 break;
				 default: ;
			 }
			 jj_consume_token(SEMICOLON);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: Expression();
				 jjtn000.hasExpression=true;
				 break;
				 default: ;
			 }
			 jj_consume_token(SEMICOLON);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: ForUpdate();
				 jjtn000.hasForUpdate=true;
				 break;
				 default: ;
			 }
			 jj_consume_token(RPAREN);
			 Statement();
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void EnhancedForStatement() throws ParseException {
		 BSHEnhancedForStatement jjtn000 = new BSHEnhancedForStatement(JJTENHANCEDFORSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t = null;
		 try {
			 if (jj_2_30(4)) {
				 jj_consume_token(FOR);
				 jj_consume_token(LPAREN);
				 t = jj_consume_token(IDENTIFIER);
				 jj_consume_token(COLON);
				 Expression();
				 jj_consume_token(RPAREN);
				 Statement();
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtc000 = false;
				 jjtreeCloseNodeScope(jjtn000);
				 jjtn000.varName = t.image;
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case FOR: jj_consume_token(FOR);
					 jj_consume_token(LPAREN);
					 Type();
					 t = jj_consume_token(IDENTIFIER);
					 jj_consume_token(COLON);
					 Expression();
					 jj_consume_token(RPAREN);
					 Statement();
					 jjtree.closeNodeScope(jjtn000, true);
					 jjtc000 = false;
					 jjtreeCloseNodeScope(jjtn000);
					 jjtn000.varName = t.image;
					 break;
					 default: jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ForInit() throws ParseException {
		 Token t = null;
		 if (jj_2_31(2147483647)) {
			 TypedVariableDeclaration();
		 }
		 else {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: StatementExpressionList();
				 break;
				 default: jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void TypedVariableDeclaration() throws ParseException {
		 BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		Token t = null;
		 Modifiers mods;
		 try {
			 mods = Modifiers(Modifiers.FIELD, false);
			 Type();
			 VariableDeclarator();
			 label_25: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case COMMA: ;
					 break;
					 default: break label_25;
				 }
				 jj_consume_token(COMMA);
				 VariableDeclarator();
			 }
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.modifiers = mods;
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void StatementExpressionList() throws ParseException {
		 BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 StatementExpression();
			 label_26: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case COMMA: ;
					 break;
					 default: break label_26;
				 }
				 jj_consume_token(COMMA);
				 StatementExpression();
			 }
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ForUpdate() throws ParseException {
		 StatementExpressionList();
	 }
	 final public void BreakStatement() throws ParseException {
		 BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(BREAK);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IDENTIFIER: jj_consume_token(IDENTIFIER);
				 break;
				 default: ;
			 }
			 jj_consume_token(SEMICOLON);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.kind = BREAK;
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ContinueStatement() throws ParseException {
		 BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(CONTINUE);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case IDENTIFIER: jj_consume_token(IDENTIFIER);
				 break;
				 default: ;
			 }
			 jj_consume_token(SEMICOLON);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.kind = CONTINUE;
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ReturnStatement() throws ParseException {
		 BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(RETURN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case BOOLEAN: case BYTE: case CHAR: case DOUBLE: case FALSE: case FLOAT: case INT: case LONG: case NEW: case NULL: case SHORT: case TRUE: case VOID: case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case CHARACTER_LITERAL: case STRING_LITERAL: case IDENTIFIER: case LPAREN: case BANG: case TILDE: case INCR: case DECR: case PLUS: case MINUS: Expression();
				 break;
				 default: ;
			 }
			 jj_consume_token(SEMICOLON);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.kind = RETURN;
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void SynchronizedStatement() throws ParseException {
		 BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(SYNCHRONIZED);
			 jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 Block();
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 jjtn000.isSynchronized=true;
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void ThrowStatement() throws ParseException {
		 BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		 try {
			 jj_consume_token(THROW);
			 Expression();
			 jj_consume_token(SEMICOLON);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final public void TryStatement() throws ParseException {
		 BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 jjtreeOpenNodeScope(jjtn000);
		boolean closed = false;
		 try {
			 jj_consume_token(TRY);
			 Block();
			 label_27: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case CATCH: ;
					 break;
					 default: break label_27;
				 }
				 jj_consume_token(CATCH);
				 jj_consume_token(LPAREN);
				 FormalParameter();
				 jj_consume_token(RPAREN);
				 Block();
				 closed = true;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case FINALLY: jj_consume_token(FINALLY);
				 Block();
				 closed = true;
				 break;
				 default: ;
			 }
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtreeCloseNodeScope(jjtn000);
			 if ( !closed ) {
				if (true) throw generateParseException();
			}
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
				 jjtreeCloseNodeScope(jjtn000);
			 }
		 }
	 }
	 final private boolean jj_2_1(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_1();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_2(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_2();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_3(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_3();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_4(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_4();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_5(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_5();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_6(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_6();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_7(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_7();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_8(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_8();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_9(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_9();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_10(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_10();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_11(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_11();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_12(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_12();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_13(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_13();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_14(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_14();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_15(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_15();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_16(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_16();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_17(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_17();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_18(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_18();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_19(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_19();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_20(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_20();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_21(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_21();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_22(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_22();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_23(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_23();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_24(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_24();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_25(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_25();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_26(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_26();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_27(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_27();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_28(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_28();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_29(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_29();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_30(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_30();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_2_31(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_31();
		 }
		 catch(LookaheadSuccess ls) {
		 }
		 return true;
	 }
	 final private boolean jj_3R_46() {
		 if (jj_3R_91()) return true;
		 return false;
	 }
	 final private boolean jj_3R_28() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_46()) {
			 jj_scanpos = xsp;
			 if (jj_3R_47()) {
				 jj_scanpos = xsp;
				 if (jj_3R_48()) {
					 jj_scanpos = xsp;
					 if (jj_3R_49()) {
						 jj_scanpos = xsp;
						 if (jj_3_28()) {
							 jj_scanpos = xsp;
							 if (jj_3R_50()) {
								 jj_scanpos = xsp;
								 if (jj_3R_51()) {
									 jj_scanpos = xsp;
									 if (jj_3R_52()) return true;
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3_23() {
		 if (jj_3R_28()) return true;
		 return false;
	 }
	 final private boolean jj_3R_161() {
		 if (jj_3R_164()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_169()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_38() {
		 if (jj_scan_token(LBRACE)) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_23()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 if (jj_scan_token(RBRACE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_158() {
		 if (jj_3R_161()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_167()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_40() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(COLON)) return true;
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_156() {
		 if (jj_scan_token(HOOK)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(COLON)) return true;
		 if (jj_3R_108()) return true;
		 return false;
	 }
	 final private boolean jj_3R_165() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(108)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(109)) return true;
		 }
		 if (jj_3R_158()) return true;
		 return false;
	 }
	 final private boolean jj_3R_153() {
		 if (jj_3R_158()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_165()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_90() {
		 if (jj_3R_124()) return true;
		 return false;
	 }
	 final private boolean jj_3R_89() {
		 if (jj_3R_123()) return true;
		 return false;
	 }
	 final private boolean jj_3R_88() {
		 if (jj_3R_122()) return true;
		 return false;
	 }
	 final private boolean jj_3R_162() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(98)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(99)) return true;
		 }
		 if (jj_3R_153()) return true;
		 return false;
	 }
	 final private boolean jj_3R_87() {
		 if (jj_3R_121()) return true;
		 return false;
	 }
	 final private boolean jj_3R_148() {
		 if (jj_3R_153()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_162()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_86() {
		 if (jj_3R_120()) return true;
		 return false;
	 }
	 final private boolean jj_3R_85() {
		 if (jj_3R_119()) return true;
		 return false;
	 }
	 final private boolean jj_3R_84() {
		 if (jj_3R_118()) return true;
		 return false;
	 }
	 final private boolean jj_3R_159() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(96)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(97)) return true;
		 }
		 if (jj_3R_148()) return true;
		 return false;
	 }
	 final private boolean jj_3R_83() {
		 if (jj_3R_117()) return true;
		 return false;
	 }
	 final private boolean jj_3R_135() {
		 if (jj_3R_148()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_159()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_82() {
		 if (jj_3R_116()) return true;
		 return false;
	 }
	 final private boolean jj_3R_81() {
		 if (jj_3R_115()) return true;
		 return false;
	 }
	 final private boolean jj_3R_80() {
		 if (jj_3R_114()) return true;
		 return false;
	 }
	 final private boolean jj_3R_108() {
		 if (jj_3R_135()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_156()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3R_79() {
		 if (jj_3R_113()) return true;
		 return false;
	 }
	 final private boolean jj_3R_78() {
		 if (jj_3R_112()) return true;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3_17() {
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3R_77() {
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3R_45() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_22()) {
			 jj_scanpos = xsp;
			 if (jj_3R_77()) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(78)) {
					 jj_scanpos = xsp;
					 if (jj_3R_78()) {
						 jj_scanpos = xsp;
						 if (jj_3R_79()) {
							 jj_scanpos = xsp;
							 if (jj_3R_80()) {
								 jj_scanpos = xsp;
								 if (jj_3R_81()) {
									 jj_scanpos = xsp;
									 if (jj_3R_82()) {
										 jj_scanpos = xsp;
										 lookingAhead = true;
										 jj_semLA = isRegularForStatement();
										 lookingAhead = false;
										 if (!jj_semLA || jj_3R_83()) {
											 jj_scanpos = xsp;
											 if (jj_3R_84()) {
												 jj_scanpos = xsp;
												 if (jj_3R_85()) {
													 jj_scanpos = xsp;
													 if (jj_3R_86()) {
														 jj_scanpos = xsp;
														 if (jj_3R_87()) {
															 jj_scanpos = xsp;
															 if (jj_3R_88()) {
																 jj_scanpos = xsp;
																 if (jj_3R_89()) {
																	 jj_scanpos = xsp;
																	 if (jj_3R_90()) return true;
																 }
															 }
														 }
													 }
												 }
											 }
										 }
									 }
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3_22() {
		 if (jj_3R_40()) return true;
		 return false;
	 }
	 final private boolean jj_3R_34() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(81)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(120)) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(121)) {
					 jj_scanpos = xsp;
					 if (jj_scan_token(127)) {
						 jj_scanpos = xsp;
						 if (jj_scan_token(118)) {
							 jj_scanpos = xsp;
							 if (jj_scan_token(119)) {
								 jj_scanpos = xsp;
								 if (jj_scan_token(122)) {
									 jj_scanpos = xsp;
									 if (jj_scan_token(126)) {
										 jj_scanpos = xsp;
										 if (jj_scan_token(124)) {
											 jj_scanpos = xsp;
											 if (jj_scan_token(128)) {
												 jj_scanpos = xsp;
												 if (jj_scan_token(129)) {
													 jj_scanpos = xsp;
													 if (jj_scan_token(130)) {
														 jj_scanpos = xsp;
														 if (jj_scan_token(131)) {
															 jj_scanpos = xsp;
															 if (jj_scan_token(132)) {
																 jj_scanpos = xsp;
																 if (jj_scan_token(133)) return true;
															 }
														 }
													 }
												 }
											 }
										 }
									 }
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_111() {
		 if (jj_scan_token(COMMA)) return true;
		 if (jj_3R_29()) return true;
		 return false;
	 }
	 final private boolean jj_3R_160() {
		 if (jj_scan_token(LBRACKET)) return true;
		 if (jj_scan_token(RBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3R_152() {
		 if (jj_3R_69()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_17()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3R_157() {
		 Token xsp;
		 if (jj_3R_160()) return true;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_160()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 if (jj_3R_97()) return true;
		 return false;
	 }
	 final private boolean jj_3_8() {
		 if (jj_3R_33()) return true;
		 if (jj_3R_34()) return true;
		 return false;
	 }
	 final private boolean jj_3_20() {
		 if (jj_scan_token(LBRACKET)) return true;
		 if (jj_scan_token(RBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3R_151() {
		 if (jj_3R_150()) return true;
		 return false;
	 }
	 final private boolean jj_3_19() {
		 if (jj_scan_token(LBRACKET)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3R_107() {
		 if (jj_3R_33()) return true;
		 if (jj_3R_34()) return true;
		 if (jj_3R_39()) return true;
		 return false;
	 }
	 final private boolean jj_3_21() {
		 Token xsp;
		 if (jj_3_19()) return true;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_19()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_20()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_150() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_21()) {
			 jj_scanpos = xsp;
			 if (jj_3R_157()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_71() {
		 if (jj_3R_108()) return true;
		 return false;
	 }
	 final private boolean jj_3R_39() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_70()) {
			 jj_scanpos = xsp;
			 if (jj_3R_71()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_70() {
		 if (jj_3R_107()) return true;
		 return false;
	 }
	 final private boolean jj_3R_145() {
		 if (jj_scan_token(NEW)) return true;
		 if (jj_3R_29()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_151()) {
			 jj_scanpos = xsp;
			 if (jj_3R_152()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3_18() {
		 if (jj_scan_token(NEW)) return true;
		 if (jj_3R_36()) return true;
		 if (jj_3R_150()) return true;
		 return false;
	 }
	 final private boolean jj_3R_130() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_18()) {
			 jj_scanpos = xsp;
			 if (jj_3R_145()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_147() {
		 if (jj_scan_token(COMMA)) return true;
		 if (jj_3R_39()) return true;
		 return false;
	 }
	 final private boolean jj_3R_76() {
		 if (jj_3R_29()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_111()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_134() {
		 if (jj_3R_39()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_147()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_106() {
		 if (jj_3R_134()) return true;
		 return false;
	 }
	 final private boolean jj_3_7() {
		 if (jj_scan_token(DOT)) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3R_69() {
		 if (jj_scan_token(LPAREN)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_106()) jj_scanpos = xsp;
		 if (jj_scan_token(RPAREN)) return true;
		 return false;
	 }
	 final private boolean jj_3R_29() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_7()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_68() {
		 if (jj_scan_token(DOUBLE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_67() {
		 if (jj_scan_token(FLOAT)) return true;
		 return false;
	 }
	 final private boolean jj_3R_155() {
		 if (jj_scan_token(FALSE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_66() {
		 if (jj_scan_token(LONG)) return true;
		 return false;
	 }
	 final private boolean jj_3R_65() {
		 if (jj_scan_token(INT)) return true;
		 return false;
	 }
	 final private boolean jj_3R_154() {
		 if (jj_scan_token(TRUE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_149() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_154()) {
			 jj_scanpos = xsp;
			 if (jj_3R_155()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_64() {
		 if (jj_scan_token(SHORT)) return true;
		 return false;
	 }
	 final private boolean jj_3R_56() {
		 if (jj_3R_29()) return true;
		 return false;
	 }
	 final private boolean jj_3R_63() {
		 if (jj_scan_token(BYTE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_62() {
		 if (jj_scan_token(CHAR)) return true;
		 return false;
	 }
	 final private boolean jj_3R_61() {
		 if (jj_scan_token(BOOLEAN)) return true;
		 return false;
	 }
	 final private boolean jj_3R_36() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_61()) {
			 jj_scanpos = xsp;
			 if (jj_3R_62()) {
				 jj_scanpos = xsp;
				 if (jj_3R_63()) {
					 jj_scanpos = xsp;
					 if (jj_3R_64()) {
						 jj_scanpos = xsp;
						 if (jj_3R_65()) {
							 jj_scanpos = xsp;
							 if (jj_3R_66()) {
								 jj_scanpos = xsp;
								 if (jj_3R_67()) {
									 jj_scanpos = xsp;
									 if (jj_3R_68()) return true;
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_144() {
		 if (jj_scan_token(57)) return true;
		 return false;
	 }
	 final private boolean jj_3R_74() {
		 if (jj_3R_32()) return true;
		 return false;
	 }
	 final private boolean jj_3R_42() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_73()) {
			 jj_scanpos = xsp;
			 if (jj_3R_74()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_73() {
		 if (jj_scan_token(VOID)) return true;
		 return false;
	 }
	 final private boolean jj_3R_143() {
		 if (jj_scan_token(41)) return true;
		 return false;
	 }
	 final private boolean jj_3_6() {
		 if (jj_scan_token(LBRACKET)) return true;
		 if (jj_scan_token(RBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3R_142() {
		 if (jj_3R_149()) return true;
		 return false;
	 }
	 final private boolean jj_3R_55() {
		 if (jj_3R_36()) return true;
		 return false;
	 }
	 final private boolean jj_3R_110() {
		 if (jj_scan_token(COMMA)) return true;
		 if (jj_3R_109()) return true;
		 return false;
	 }
	 final private boolean jj_3R_141() {
		 if (jj_scan_token(STRING_LITERAL)) return true;
		 return false;
	 }
	 final private boolean jj_3R_32() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_55()) {
			 jj_scanpos = xsp;
			 if (jj_3R_56()) return true;
		 }
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_6()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_140() {
		 if (jj_scan_token(CHARACTER_LITERAL)) return true;
		 return false;
	 }
	 final private boolean jj_3R_190() {
		 if (jj_scan_token(FINALLY)) return true;
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3_4() {
		 if (jj_scan_token(COMMA)) return true;
		 if (jj_3R_31()) return true;
		 return false;
	 }
	 final private boolean jj_3R_189() {
		 if (jj_scan_token(CATCH)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_109()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3R_136() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3_5() {
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3R_75() {
		 if (jj_3R_109()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_110()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_109() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_5()) {
			 jj_scanpos = xsp;
			 if (jj_3R_136()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_124() {
		 if (jj_scan_token(TRY)) return true;
		 if (jj_3R_38()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_189()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 xsp = jj_scanpos;
		 if (jj_3R_190()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3R_43() {
		 if (jj_scan_token(LPAREN)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_75()) jj_scanpos = xsp;
		 if (jj_scan_token(RPAREN)) return true;
		 return false;
	 }
	 final private boolean jj_3R_163() {
		 if (jj_3R_31()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_4()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_139() {
		 if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
		 return false;
	 }
	 final private boolean jj_3R_97() {
		 if (jj_scan_token(LBRACE)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_163()) jj_scanpos = xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(79)) jj_scanpos = xsp;
		 if (jj_scan_token(RBRACE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_30() {
		 if (jj_scan_token(DOT)) return true;
		 if (jj_scan_token(STAR)) return true;
		 return false;
	 }
	 final private boolean jj_3R_123() {
		 if (jj_scan_token(THROW)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_180() {
		 if (jj_scan_token(ASSIGN)) return true;
		 if (jj_3R_31()) return true;
		 return false;
	 }
	 final private boolean jj_3R_54() {
		 if (jj_3R_39()) return true;
		 return false;
	 }
	 final private boolean jj_3R_188() {
		 if (jj_3R_39()) return true;
		 return false;
	 }
	 final private boolean jj_3R_53() {
		 if (jj_3R_97()) return true;
		 return false;
	 }
	 final private boolean jj_3R_31() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_53()) {
			 jj_scanpos = xsp;
			 if (jj_3R_54()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_122() {
		 if (jj_scan_token(SYNCHRONIZED)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3R_177() {
		 if (jj_scan_token(COMMA)) return true;
		 if (jj_3R_176()) return true;
		 return false;
	 }
	 final private boolean jj_3R_210() {
		 if (jj_scan_token(COMMA)) return true;
		 if (jj_3R_112()) return true;
		 return false;
	 }
	 final private boolean jj_3R_121() {
		 if (jj_scan_token(RETURN)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_188()) jj_scanpos = xsp;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_129() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_138()) {
			 jj_scanpos = xsp;
			 if (jj_3R_139()) {
				 jj_scanpos = xsp;
				 if (jj_3R_140()) {
					 jj_scanpos = xsp;
					 if (jj_3R_141()) {
						 jj_scanpos = xsp;
						 if (jj_3R_142()) {
							 jj_scanpos = xsp;
							 if (jj_3R_143()) {
								 jj_scanpos = xsp;
								 if (jj_3R_144()) return true;
							 }
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_138() {
		 if (jj_scan_token(INTEGER_LITERAL)) return true;
		 return false;
	 }
	 final private boolean jj_3R_146() {
		 if (jj_3R_69()) return true;
		 return false;
	 }
	 final private boolean jj_3R_176() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_180()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3R_105() {
		 if (jj_3R_129()) return true;
		 return false;
	 }
	 final private boolean jj_3R_120() {
		 if (jj_scan_token(CONTINUE)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(69)) jj_scanpos = xsp;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_119() {
		 if (jj_scan_token(BREAK)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(69)) jj_scanpos = xsp;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_195() {
		 if (jj_3R_205()) return true;
		 return false;
	 }
	 final private boolean jj_3R_128() {
		 if (jj_scan_token(IMPORT)) return true;
		 if (jj_scan_token(STAR)) return true;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_133() {
		 if (jj_scan_token(LBRACE)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RBRACE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_205() {
		 if (jj_3R_112()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_210()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_132() {
		 if (jj_scan_token(DOT)) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_146()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3_3() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(48)) jj_scanpos = xsp;
		 if (jj_scan_token(IMPORT)) return true;
		 if (jj_3R_29()) return true;
		 xsp = jj_scanpos;
		 if (jj_3R_30()) jj_scanpos = xsp;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_94() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_3()) {
			 jj_scanpos = xsp;
			 if (jj_3R_128()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_93() {
		 if (jj_3R_41()) return true;
		 if (jj_3R_32()) return true;
		 if (jj_3R_176()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_177()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_131() {
		 if (jj_scan_token(LBRACKET)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3R_95() {
		 if (jj_scan_token(PACKAGE)) return true;
		 if (jj_3R_29()) return true;
		 return false;
	 }
	 final private boolean jj_3_2() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 return false;
	 }
	 final private boolean jj_3R_175() {
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3_16() {
		 if (jj_scan_token(DOT)) return true;
		 if (jj_scan_token(CLASS)) return true;
		 return false;
	 }
	 final private boolean jj_3R_104() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_16()) {
			 jj_scanpos = xsp;
			 if (jj_3R_131()) {
				 jj_scanpos = xsp;
				 if (jj_3R_132()) {
					 jj_scanpos = xsp;
					 if (jj_3R_133()) return true;
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_174() {
		 if (jj_scan_token(THROWS)) return true;
		 if (jj_3R_76()) return true;
		 return false;
	 }
	 final private boolean jj_3_15() {
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(DOT)) return true;
		 if (jj_scan_token(CLASS)) return true;
		 return false;
	 }
	 final private boolean jj_3_31() {
		 if (jj_3R_41()) return true;
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3_14() {
		 if (jj_3R_37()) return true;
		 return false;
	 }
	 final private boolean jj_3R_126() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3R_127() {
		 if (jj_3R_42()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3R_92() {
		 if (jj_3R_41()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_126()) {
			 jj_scanpos = xsp;
			 if (jj_3R_127()) return true;
		 }
		 if (jj_3R_43()) return true;
		 xsp = jj_scanpos;
		 if (jj_3R_174()) jj_scanpos = xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_175()) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(78)) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_204() {
		 if (jj_3R_205()) return true;
		 return false;
	 }
	 final private boolean jj_3R_103() {
		 if (jj_3R_29()) return true;
		 return false;
	 }
	 final private boolean jj_3R_203() {
		 if (jj_3R_93()) return true;
		 return false;
	 }
	 final private boolean jj_3R_194() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_203()) {
			 jj_scanpos = xsp;
			 if (jj_3R_204()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_102() {
		 if (jj_3R_32()) return true;
		 return false;
	 }
	 final private boolean jj_3R_58() {
		 if (jj_3R_104()) return true;
		 return false;
	 }
	 final private boolean jj_3R_125() {
		 if (jj_scan_token(INTERFACE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_101() {
		 if (jj_3R_37()) return true;
		 return false;
	 }
	 final private boolean jj_3R_100() {
		 if (jj_3R_130()) return true;
		 return false;
	 }
	 final private boolean jj_3R_99() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 return false;
	 }
	 final private boolean jj_3R_137() {
		 if (jj_scan_token(FOR)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(COLON)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_184() {
		 if (jj_scan_token(ELSE)) return true;
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_173() {
		 if (jj_scan_token(IMPLEMENTS)) return true;
		 if (jj_3R_76()) return true;
		 return false;
	 }
	 final private boolean jj_3R_57() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_98()) {
			 jj_scanpos = xsp;
			 if (jj_3R_99()) {
				 jj_scanpos = xsp;
				 if (jj_3R_100()) {
					 jj_scanpos = xsp;
					 if (jj_3R_101()) {
						 jj_scanpos = xsp;
						 if (jj_3R_102()) {
							 jj_scanpos = xsp;
							 if (jj_3R_103()) return true;
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_98() {
		 if (jj_3R_129()) return true;
		 return false;
	 }
	 final private boolean jj_3R_172() {
		 if (jj_scan_token(EXTENDS)) return true;
		 if (jj_3R_29()) return true;
		 return false;
	 }
	 final private boolean jj_3_30() {
		 if (jj_scan_token(FOR)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(COLON)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_118() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_30()) {
			 jj_scanpos = xsp;
			 if (jj_3R_137()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_37() {
		 if (jj_3R_29()) return true;
		 if (jj_3R_69()) return true;
		 return false;
	 }
	 final private boolean jj_3R_185() {
		 if (jj_3R_194()) return true;
		 return false;
	 }
	 final private boolean jj_3R_91() {
		 if (jj_3R_41()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(13)) {
			 jj_scanpos = xsp;
			 if (jj_3R_125()) return true;
		 }
		 if (jj_scan_token(IDENTIFIER)) return true;
		 xsp = jj_scanpos;
		 if (jj_3R_172()) jj_scanpos = xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_173()) jj_scanpos = xsp;
		 if (jj_3R_38()) return true;
		 return false;
	 }
	 final private boolean jj_3_13() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_36()) return true;
		 return false;
	 }
	 final private boolean jj_3R_187() {
		 if (jj_3R_195()) return true;
		 return false;
	 }
	 final private boolean jj_3R_186() {
		 if (jj_3R_39()) return true;
		 return false;
	 }
	 final private boolean jj_3R_33() {
		 if (jj_3R_57()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_58()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_217() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_208()) return true;
		 return false;
	 }
	 final private boolean jj_3R_216() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_191()) return true;
		 return false;
	 }
	 final private boolean jj_3R_117() {
		 if (jj_scan_token(FOR)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_185()) jj_scanpos = xsp;
		 if (jj_scan_token(SEMICOLON)) return true;
		 xsp = jj_scanpos;
		 if (jj_3R_186()) jj_scanpos = xsp;
		 if (jj_scan_token(SEMICOLON)) return true;
		 xsp = jj_scanpos;
		 if (jj_3R_187()) jj_scanpos = xsp;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_214() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_216()) {
			 jj_scanpos = xsp;
			 if (jj_3R_217()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3_12() {
		 if (jj_3R_33()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(100)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(101)) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_219() {
		 if (jj_3R_33()) return true;
		 return false;
	 }
	 final private boolean jj_3R_116() {
		 if (jj_scan_token(DO)) return true;
		 if (jj_3R_45()) return true;
		 if (jj_scan_token(WHILE)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3_11() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_29()) return true;
		 if (jj_scan_token(LBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3R_218() {
		 if (jj_3R_33()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(100)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(101)) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_215() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_218()) {
			 jj_scanpos = xsp;
			 if (jj_3R_219()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_72() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(43)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(44)) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(45)) {
					 jj_scanpos = xsp;
					 if (jj_scan_token(51)) {
						 jj_scanpos = xsp;
						 if (jj_scan_token(27)) {
							 jj_scanpos = xsp;
							 if (jj_scan_token(39)) {
								 jj_scanpos = xsp;
								 if (jj_scan_token(52)) {
									 jj_scanpos = xsp;
									 if (jj_scan_token(58)) {
										 jj_scanpos = xsp;
										 if (jj_scan_token(10)) {
											 jj_scanpos = xsp;
											 if (jj_scan_token(48)) {
												 jj_scanpos = xsp;
												 if (jj_scan_token(49)) return true;
											 }
										 }
									 }
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_115() {
		 if (jj_scan_token(WHILE)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_60() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_29()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(87)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(86)) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(72)) {
					 jj_scanpos = xsp;
					 if (jj_scan_token(69)) {
						 jj_scanpos = xsp;
						 if (jj_scan_token(40)) {
							 jj_scanpos = xsp;
							 if (jj_3R_105()) return true;
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_59() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_29()) return true;
		 if (jj_scan_token(LBRACKET)) return true;
		 if (jj_scan_token(RBRACKET)) return true;
		 return false;
	 }
	 final private boolean jj_3_9() {
		 if (jj_3R_35()) return true;
		 return false;
	 }
	 final private boolean jj_3_29() {
		 if (jj_3R_28()) return true;
		 return false;
	 }
	 final private boolean jj_3R_114() {
		 if (jj_scan_token(IF)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_3R_45()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_184()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3R_41() {
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_72()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_35() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_10()) {
			 jj_scanpos = xsp;
			 if (jj_3R_59()) {
				 jj_scanpos = xsp;
				 if (jj_3R_60()) return true;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3_10() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_36()) return true;
		 return false;
	 }
	 final private boolean jj_3R_213() {
		 if (jj_3R_215()) return true;
		 return false;
	 }
	 final private boolean jj_3R_212() {
		 if (jj_3R_214()) return true;
		 return false;
	 }
	 final private boolean jj_3R_202() {
		 if (jj_scan_token(_DEFAULT)) return true;
		 if (jj_scan_token(COLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_211() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(87)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(86)) return true;
		 }
		 if (jj_3R_191()) return true;
		 return false;
	 }
	 final private boolean jj_3R_208() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_211()) {
			 jj_scanpos = xsp;
			 if (jj_3R_212()) {
				 jj_scanpos = xsp;
				 if (jj_3R_213()) return true;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_201() {
		 if (jj_scan_token(CASE)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(COLON)) return true;
		 return false;
	 }
	 final private boolean jj_3R_193() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_201()) {
			 jj_scanpos = xsp;
			 if (jj_3R_202()) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_183() {
		 if (jj_3R_193()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_29()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_207() {
		 if (jj_scan_token(DECR)) return true;
		 if (jj_3R_33()) return true;
		 return false;
	 }
	 final private boolean jj_3_1() {
		 if (jj_3R_28()) return true;
		 return false;
	 }
	 final private boolean jj_3R_113() {
		 if (jj_scan_token(SWITCH)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_39()) return true;
		 if (jj_scan_token(RPAREN)) return true;
		 if (jj_scan_token(LBRACE)) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_183()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 if (jj_scan_token(RBRACE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_209() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(104)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(105)) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(111)) return true;
			 }
		 }
		 if (jj_3R_191()) return true;
		 return false;
	 }
	 final private boolean jj_3R_206() {
		 if (jj_scan_token(INCR)) return true;
		 if (jj_3R_33()) return true;
		 return false;
	 }
	 final private boolean jj_3R_199() {
		 if (jj_3R_208()) return true;
		 return false;
	 }
	 final private boolean jj_3R_198() {
		 if (jj_3R_207()) return true;
		 return false;
	 }
	 final private boolean jj_3R_197() {
		 if (jj_3R_206()) return true;
		 return false;
	 }
	 final private boolean jj_3R_196() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(102)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(103)) return true;
		 }
		 if (jj_3R_191()) return true;
		 return false;
	 }
	 final private boolean jj_3R_191() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_196()) {
			 jj_scanpos = xsp;
			 if (jj_3R_197()) {
				 jj_scanpos = xsp;
				 if (jj_3R_198()) {
					 jj_scanpos = xsp;
					 if (jj_3R_199()) return true;
				 }
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_44() {
		 if (jj_scan_token(THROWS)) return true;
		 if (jj_3R_76()) return true;
		 return false;
	 }
	 final private boolean jj_3R_112() {
		 if (jj_3R_39()) return true;
		 return false;
	 }
	 final private boolean jj_3R_181() {
		 if (jj_3R_191()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_209()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_200() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(102)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(103)) return true;
		 }
		 if (jj_3R_181()) return true;
		 return false;
	 }
	 final private boolean jj_3R_178() {
		 if (jj_3R_181()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_200()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_96() {
		 if (jj_scan_token(FORMAL_COMMENT)) return true;
		 return false;
	 }
	 final private boolean jj_3R_192() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(112)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(113)) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(114)) {
					 jj_scanpos = xsp;
					 if (jj_scan_token(115)) {
						 jj_scanpos = xsp;
						 if (jj_scan_token(116)) {
							 jj_scanpos = xsp;
							 if (jj_scan_token(117)) return true;
						 }
					 }
				 }
			 }
		 }
		 if (jj_3R_178()) return true;
		 return false;
	 }
	 final private boolean jj_3R_171() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(90)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(95)) return true;
		 }
		 if (jj_3R_166()) return true;
		 return false;
	 }
	 final private boolean jj_3R_170() {
		 if (jj_3R_178()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_192()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_52() {
		 if (jj_3R_96()) return true;
		 return false;
	 }
	 final private boolean jj_3R_182() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(84)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(85)) {
				 jj_scanpos = xsp;
				 if (jj_scan_token(82)) {
					 jj_scanpos = xsp;
					 if (jj_scan_token(83)) {
						 jj_scanpos = xsp;
						 if (jj_scan_token(91)) {
							 jj_scanpos = xsp;
							 if (jj_scan_token(92)) {
								 jj_scanpos = xsp;
								 if (jj_scan_token(93)) {
									 jj_scanpos = xsp;
									 if (jj_scan_token(94)) return true;
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 if (jj_3R_170()) return true;
		 return false;
	 }
	 final private boolean jj_3_27() {
		 if (jj_3R_41()) return true;
		 if (jj_3R_32()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 final private boolean jj_3R_51() {
		 if (jj_3R_95()) return true;
		 return false;
	 }
	 final private boolean jj_3R_168() {
		 if (jj_3R_170()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_182()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_50() {
		 if (jj_3R_94()) return true;
		 return false;
	 }
	 final private boolean jj_3_26() {
		 if (jj_3R_41()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_3R_43()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_44()) jj_scanpos = xsp;
		 if (jj_scan_token(LBRACE)) return true;
		 return false;
	 }
	 final private boolean jj_3R_179() {
		 if (jj_scan_token(INSTANCEOF)) return true;
		 if (jj_3R_32()) return true;
		 return false;
	 }
	 final private boolean jj_3_28() {
		 if (jj_3R_45()) return true;
		 return false;
	 }
	 final private boolean jj_3R_166() {
		 if (jj_3R_168()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_179()) jj_scanpos = xsp;
		 return false;
	 }
	 final private boolean jj_3_25() {
		 if (jj_3R_41()) return true;
		 if (jj_3R_42()) return true;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 return false;
	 }
	 final private boolean jj_3R_49() {
		 if (jj_3R_93()) return true;
		 if (jj_scan_token(SEMICOLON)) return true;
		 return false;
	 }
	 final private boolean jj_3_24() {
		 if (jj_3R_41()) return true;
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(13)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(37)) return true;
		 }
		 return false;
	 }
	 final private boolean jj_3R_167() {
		 if (jj_scan_token(XOR)) return true;
		 if (jj_3R_161()) return true;
		 return false;
	 }
	 final private boolean jj_3R_48() {
		 if (jj_3R_92()) return true;
		 return false;
	 }
	 final private boolean jj_3R_164() {
		 if (jj_3R_166()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_171()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 final private boolean jj_3R_47() {
		 if (jj_3R_92()) return true;
		 return false;
	 }
	 final private boolean jj_3R_169() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(106)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(107)) return true;
		 }
		 if (jj_3R_164()) return true;
		 return false;
	 }
	 public ParserTokenManager token_source;
	 JavaCharStream jj_input_stream;
	 public Token token, jj_nt;
	 private int jj_ntk;
	 private Token jj_scanpos, jj_lastpos;
	 private int jj_la;
	 public boolean lookingAhead = false;
	 private boolean jj_semLA;
	 public Parser(java.io.InputStream stream) {
		 jj_input_stream = new JavaCharStream(stream, 1, 1);
		 token_source = new ParserTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
	 }
	 public void ReInit(java.io.InputStream stream) {
		 jj_input_stream.ReInit(stream, 1, 1);
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
	 }
	 public Parser(java.io.Reader stream) {
		 jj_input_stream = new JavaCharStream(stream, 1, 1);
		 token_source = new ParserTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
	 }
	 public void ReInit(java.io.Reader stream) {
		 jj_input_stream.ReInit(stream, 1, 1);
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
	 }
	 public Parser(ParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
	 }
	 public void ReInit(ParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
	 }
	 final private Token jj_consume_token(int kind) throws ParseException {
		 Token oldToken;
		 if ((oldToken = token).next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 if (token.kind == kind) {
			 return token;
		 }
		 token = oldToken;
		 throw generateParseException();
	 }
	 static private final class LookaheadSuccess extends java.lang.Error {
	 }
	 final private LookaheadSuccess jj_ls = new LookaheadSuccess();
	 final private boolean jj_scan_token(int kind) {
		 if (jj_scanpos == jj_lastpos) {
			 jj_la--;
			 if (jj_scanpos.next == null) {
				 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			 }
			 else {
				 jj_lastpos = jj_scanpos = jj_scanpos.next;
			 }
		 }
		 else {
			 jj_scanpos = jj_scanpos.next;
		 }
		 if (jj_scanpos.kind != kind) return true;
		 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
		 return false;
	 }
	 final public Token getNextToken() {
		 if (token.next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 return token;
	 }
	 final public Token getToken(int index) {
		 Token t = lookingAhead ? jj_scanpos : token;
		 for (int i = 0;
		 i < index;
		 i++) {
			 if (t.next != null) t = t.next;
			 else t = t.next = token_source.getNextToken();
		 }
		 return t;
	 }
	 final private int jj_ntk() {
		 if ((jj_nt=token.next) == null) return (jj_ntk = (token.next=token_source.getNextToken()).kind);
		 else return (jj_ntk = jj_nt.kind);
	 }
	 public ParseException generateParseException() {
		 Token errortok = token.next;
		 int line = errortok.beginLine, column = errortok.beginColumn;
		 String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
		 return new ParseException(""Parse error at line "" + line + "", column "" + column + "". Encountered: "" + mess);
	 }
	 final public void enable_tracing() {
	 }
	 final public void disable_tracing() {
	 }
}",1,0,0,0
"public interface XAConnectionFactory extends ConnectionFactory {
	 TransactionRegistry getTransactionRegistry();
	 Connection createConnection() throws SQLException;
}",0,0,0,0
"public class TransientSolrCoreCacheDefault extends TransientSolrCoreCache {
	 private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
	 private int cacheSize = NodeConfig.NodeConfigBuilder.DEFAULT_TRANSIENT_CACHE_SIZE;
	 protected Observer observer;
	 protected CoreContainer coreContainer;
	 protected final Map<String, CoreDescriptor> transientDescriptors = new LinkedHashMap<>();
	 protected Map<String, SolrCore> transientCores = new LinkedHashMap<>();
	 public TransientSolrCoreCacheDefault(final CoreContainer container) {
		 this.coreContainer = container;
		 this.observer= coreContainer.solrCores;
		 NodeConfig cfg = container.getNodeConfig();
		 if (cfg.getTransientCachePluginInfo() == null) {
			 this.cacheSize = cfg.getTransientCacheSize();
		 }
		 else {
			 NamedList args = cfg.getTransientCachePluginInfo().initArgs;
			 Object obj = args.get(""transientCacheSize"");
			 if (obj != null) {
				 this.cacheSize = (int) obj;
			 }
		 }
		 doInit();
	 }
	 private void doInit() {
		 NodeConfig cfg = coreContainer.getNodeConfig();
		 if (cfg.getTransientCachePluginInfo() == null) {
			 this.cacheSize = cfg.getTransientCacheSize();
		 }
		 else {
			 NamedList args = cfg.getTransientCachePluginInfo().initArgs;
			 Object obj = args.get(""transientCacheSize"");
			 if (obj != null) {
				 this.cacheSize = (int) obj;
			 }
		 }
		 log.info(""Allocating transient cache for {
		}
		 transient cores"", cacheSize);
		 addObserver(this.observer);
		 if (cacheSize < 0) {
			 cacheSize = Integer.MAX_VALUE;
		 }
		 transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {
			 protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {
				 if (size() > cacheSize) {
					 SolrCore coreToClose = eldest.getValue();
					 setChanged();
					 notifyObservers(coreToClose);
					 log.info(""Closing transient core [{
					}
					]"", coreToClose.getName());
					 return true;
				 }
				 return false;
			 }
		 }
		;
	 }
	 public Collection<SolrCore> prepareForShutdown() {
		 List<SolrCore> ret = new ArrayList(transientCores.values());
		 transientCores.clear();
		 return ret;
	 }
	 public CoreContainer getContainer() {
		 return this.coreContainer;
	 }
	 public SolrCore addCore(String name, SolrCore core) {
		 return transientCores.put(name, core);
	 }
	 public Set<String> getAllCoreNames() {
		 return transientDescriptors.keySet();
	 }
	 public Set<String> getLoadedCoreNames() {
		 return transientCores.keySet();
	 }
	 public SolrCore removeCore(String name) {
		 return transientCores.remove(name);
	 }
	 public SolrCore getCore(String name) {
		 return transientCores.get(name);
	 }
	 public boolean containsCore(String name) {
		 return transientCores.containsKey(name);
	 }
	 public void addTransientDescriptor(String rawName, CoreDescriptor cd) {
		 transientDescriptors.put(rawName, cd);
	 }
	 public CoreDescriptor getTransientDescriptor(String name) {
		 return transientDescriptors.get(name);
	 }
	 public CoreDescriptor removeTransientDescriptor(String name) {
		 return transientDescriptors.remove(name);
	 }
	 public List<String> getNamesForCore(SolrCore core) {
		 List<String> ret = new ArrayList<>();
		 for (Map.Entry<String, SolrCore> entry : transientCores.entrySet()) {
			 if (core == entry.getValue()) {
				 ret.add(entry.getKey());
			 }
		 }
		 return ret;
	 }
	 public void close() {
		 deleteObserver(this.observer);
	 }
	 public int getStatus(String coreName) {
		 return 0;
	 }
	 public void setStatus(String coreName, int status) {
	}
 }",0,0,0,0
"public class _RepositorySoap_LabelItem implements ElementSerializable{
	 protected String workspaceName;
	 protected String workspaceOwner;
	 protected _VersionControlLabel label;
	 protected _LabelItemSpec[] labelSpecs;
	 protected _LabelChildOption children;
	 public _RepositorySoap_LabelItem() {
		 super();
	 }
	 public _RepositorySoap_LabelItem( final String workspaceName, final String workspaceOwner, final _VersionControlLabel label, final _LabelItemSpec[] labelSpecs, final _LabelChildOption children) {
		 setWorkspaceName(workspaceName);
		 setWorkspaceOwner(workspaceOwner);
		 setLabel(label);
		 setLabelSpecs(labelSpecs);
		 setChildren(children);
	 }
	 public String getWorkspaceName() {
		 return this.workspaceName;
	 }
	 public void setWorkspaceName(String value) {
		 this.workspaceName = value;
	 }
	 public String getWorkspaceOwner() {
		 return this.workspaceOwner;
	 }
	 public void setWorkspaceOwner(String value) {
		 this.workspaceOwner = value;
	 }
	 public _VersionControlLabel getLabel() {
		 return this.label;
	 }
	 public void setLabel(_VersionControlLabel value) {
		 this.label = value;
	 }
	 public _LabelItemSpec[] getLabelSpecs() {
		 return this.labelSpecs;
	 }
	 public void setLabelSpecs(_LabelItemSpec[] value) {
		 this.labelSpecs = value;
	 }
	 public _LabelChildOption getChildren() {
		 return this.children;
	 }
	 public void setChildren(_LabelChildOption value) {
		 if (value == null) {
			 throw new IllegalArgumentException(""'children' is a required element, its value cannot be null"");
		 }
		 this.children = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 XMLStreamWriterHelper.writeElement( writer, ""workspaceName"", this.workspaceName);
		 XMLStreamWriterHelper.writeElement( writer, ""workspaceOwner"", this.workspaceOwner);
		 if (this.label != null) {
			 this.label.writeAsElement( writer, ""label"");
		 }
		 if (this.labelSpecs != null) {
			 writer.writeStartElement(""labelSpecs"");
			 for (int iterator0 = 0;
			 iterator0 < this.labelSpecs.length;
			 iterator0++) {
				 this.labelSpecs[iterator0].writeAsElement( writer, ""LabelItemSpec"");
			 }
			 writer.writeEndElement();
		 }
		 this.children.writeAsElement( writer, ""children"");
		 writer.writeEndElement();
	 }
}",1,1,0,0
"public class ZipEntry extends java.util.zip.ZipEntry implements Cloneable {
	 private static final int PLATFORM_UNIX = 3;
	 private static final int PLATFORM_FAT = 0;
	 private static final int SHORT_MASK = 0xFFFF;
	 private static final int SHORT_SHIFT = 16;
	 private int internalAttributes = 0;
	 private int platform = PLATFORM_FAT;
	 private long externalAttributes = 0;
	 private Vector extraFields = null;
	 private String name = null;
	 public ZipEntry(String name) {
		 super(name);
	 }
	 public ZipEntry(java.util.zip.ZipEntry entry) throws ZipException {
		 super(entry);
		 byte[] extra = entry.getExtra();
		 if (extra != null) {
			 setExtraFields(ExtraFieldUtils.parse(extra));
		 }
		 else {
			 setExtra();
		 }
	 }
	 public ZipEntry(ZipEntry entry) throws ZipException {
		 this((java.util.zip.ZipEntry) entry);
		 setInternalAttributes(entry.getInternalAttributes());
		 setExternalAttributes(entry.getExternalAttributes());
		 setExtraFields(entry.getExtraFields());
	 }
	 protected ZipEntry() {
		 super("""");
	 }
	 public Object clone() {
		 ZipEntry e = (ZipEntry) super.clone();
		 e.extraFields = extraFields != null ? (Vector) extraFields.clone() : null;
		 e.setInternalAttributes(getInternalAttributes());
		 e.setExternalAttributes(getExternalAttributes());
		 e.setExtraFields(getExtraFields());
		 return e;
	 }
	 public int getInternalAttributes() {
		 return internalAttributes;
	 }
	 public void setInternalAttributes(int value) {
		 internalAttributes = value;
	 }
	 public long getExternalAttributes() {
		 return externalAttributes;
	 }
	 public void setExternalAttributes(long value) {
		 externalAttributes = value;
	 }
	 public void setUnixMode(int mode) {
		 setExternalAttributes((mode << 16) | ((mode & 0200) == 0 ? 1 : 0) | (isDirectory() ? 0x10 : 0));
		 platform = PLATFORM_UNIX;
	 }
	 public int getUnixMode() {
		 return (int) ((getExternalAttributes() >> SHORT_SHIFT) & SHORT_MASK);
	 }
	 public int getPlatform() {
		 return platform;
	 }
	 protected void setPlatform(int platform) {
		 this.platform = platform;
	 }
	 public void setExtraFields(ZipExtraField[] fields) {
		 extraFields = new Vector();
		 for (int i = 0;
		 i < fields.length;
		 i++) {
			 extraFields.addElement(fields[i]);
		 }
		 setExtra();
	 }
	 public ZipExtraField[] getExtraFields() {
		 if (extraFields == null) {
			 return new ZipExtraField[0];
		 }
		 ZipExtraField[] result = new ZipExtraField[extraFields.size()];
		 extraFields.copyInto(result);
		 return result;
	 }
	 public void addExtraField(ZipExtraField ze) {
		 if (extraFields == null) {
			 extraFields = new Vector();
		 }
		 ZipShort type = ze.getHeaderId();
		 boolean done = false;
		 for (int i = 0, fieldsSize = extraFields.size();
		 !done && i < fieldsSize;
		 i++) {
			 if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {
				 extraFields.setElementAt(ze, i);
				 done = true;
			 }
		 }
		 if (!done) {
			 extraFields.addElement(ze);
		 }
		 setExtra();
	 }
	 public void removeExtraField(ZipShort type) {
		 if (extraFields == null) {
			 extraFields = new Vector();
		 }
		 boolean done = false;
		 for (int i = 0, fieldsSize = extraFields.size();
		 !done && i < fieldsSize;
		 i++) {
			 if (((ZipExtraField) extraFields.elementAt(i)).getHeaderId().equals(type)) {
				 extraFields.removeElementAt(i);
				 done = true;
			 }
		 }
		 if (!done) {
			 throw new java.util.NoSuchElementException();
		 }
		 setExtra();
	 }
	 public void setExtra(byte[] extra) throws RuntimeException {
		 try {
			 setExtraFields(ExtraFieldUtils.parse(extra));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e.getMessage());
		 }
	 }
	 protected void setExtra() {
		 super.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields()));
	 }
	 public byte[] getLocalFileDataExtra() {
		 byte[] extra = getExtra();
		 return extra != null ? extra : new byte[0];
	 }
	 public byte[] getCentralDirectoryExtra() {
		 return ExtraFieldUtils.mergeCentralDirectoryData(getExtraFields());
	 }
	 public void setComprSize(long size) {
		 setCompressedSize(size);
	 }
	 public String getName() {
		 return name == null ? super.getName() : name;
	 }
	 public boolean isDirectory() {
		 return getName().endsWith(""/"");
	 }
	 protected void setName(String name) {
		 this.name = name;
	 }
	 public int hashCode() {
		 return getName().hashCode();
	 }
	 public boolean equals(Object o) {
		 return (this == o);
	 }
}",0,0,0,0
"public Row getData() throws IOException {
	 for (Map.Entry<Message, ReadResponse> entry : replies.entrySet()) {
		 ReadResponse result = entry.getValue();
		 if (!result.isDigestQuery()) return result.row();
	 }
	 throw new AssertionError(""getData should not be invoked when no data is present"");
 }",0,0,0,0
"public class ChecksumException extends IOException {
	 public ChecksumException(String description) {
		 super(description);
	 }
}",0,0,0,0
"public class MetadataUtils {
	 private static final Logger LOG = LoggerFactory.getLogger(MetadataUtils.class);
	 public static final String META_DATA = ""metadata"";
	 public static final String ALERT_META_DATA_DAO = ""metadataDao"";
	 public static final String JDBC_USERNAME_PATH = ""jdbc.username"";
	 public static final String JDBC_PASSWORD_PATH = ""jdbc.password"";
	 public static final String JDBC_DRIVER_PATH = ""jdbc.driverClassName"";
	 public static final String JDBC_DATABASE_PATH = ""jdbc.database"";
	 public static final String JDBC_CONNECTION_PATH = ""jdbc.connection"";
	 public static final String JDBC_CONNECTION_PROPERTIES_PATH = ""jdbc.connectionProperties"";
	 public static final String MONGO_CONNECTION_PATH = ""mongo.connection"";
	 public static final String MONGO_DATABASE = ""mongo.database"";
	 public static <T> String getKey(T t) {
		 if (t instanceof StreamDefinition) {
			 return ((StreamDefinition) t).getStreamId();
		 }
		 if (t instanceof PolicyAssignment) {
			 return ((PolicyAssignment) t).getPolicyName();
		 }
		 if (t instanceof ScheduleState) {
			 return ((ScheduleState) t).getVersion();
		 }
		 if (t instanceof AlertPublishEvent) {
			 return ((AlertPublishEvent) t).getAlertId();
		 }
		 try {
			 Method m = t.getClass().getMethod(""getName"");
			 return (String) m.invoke(t);
		 }
		 catch (NoSuchMethodException | SecurityException | InvocationTargetException | IllegalAccessException | IllegalArgumentException e) {
			 LOG.error("" getName not found on given class :"" + t.getClass().getName());
		 }
		 throw new RuntimeException(String.format(""no getName() found on target class %s for matching"", t.getClass() .getName()));
	 }
	 public static Connection getJdbcConnection(Config config) {
		 Connection connection = null;
		 try {
			 if (config.hasPath(JDBC_USERNAME_PATH)) {
				 connection = DriverManager.getConnection( config.getString(JDBC_CONNECTION_PATH), config.getString(JDBC_USERNAME_PATH), config.getString(JDBC_PASSWORD_PATH));
			 }
			 else {
				 connection = DriverManager.getConnection(config.getString(JDBC_CONNECTION_PATH));
			 }
		 }
		 catch (SQLException e) {
			 LOG.error(e.getMessage(), e);
		 }
		 return connection;
	 }
}",0,1,0,0
"public class JarArchiveInputStream extends ZipArchiveInputStream {
	 public JarArchiveInputStream( final InputStream inputStream ) {
		 super(inputStream);
	 }
	 public JarArchiveInputStream( final InputStream inputStream, final String encoding ) {
		 super(inputStream, encoding);
	 }
	 public JarArchiveEntry getNextJarEntry() throws IOException {
		 final ZipArchiveEntry entry = getNextZipEntry();
		 return entry == null ? null : new JarArchiveEntry(entry);
	 }
	 public ArchiveEntry getNextEntry() throws IOException {
		 return getNextJarEntry();
	 }
	 public static boolean matches(final byte[] signature, final int length ) {
		 return ZipArchiveInputStream.matches(signature, length);
	 }
}",0,0,0,0
"public final class Files {
	 private static final int BUFFER_SIZE = 8192;
	 private Files() {
	 }
	 private static FileSystemProvider provider(Path path) {
		 return path.getFileSystem().provider();
	 }
	 private static Runnable asUncheckedRunnable(Closeable c) {
		 return () -> {
			 try {
				 c.close();
			 }
			 catch (IOException e) {
				 throw new UncheckedIOException(e);
			 }
		 }
		;
	 }
	 public static InputStream newInputStream(Path path, OpenOption... options) throws IOException {
		 return provider(path).newInputStream(path, options);
	 }
	 public static OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {
		 return provider(path).newOutputStream(path, options);
	 }
	 public static SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {
		 return provider(path).newByteChannel(path, options, attrs);
	 }
	 public static SeekableByteChannel newByteChannel(Path path, OpenOption... options) throws IOException {
		 Set<OpenOption> set;
		 if (options.length == 0) {
			 set = Collections.emptySet();
		 }
		 else {
			 set = new HashSet<>();
			 Collections.addAll(set, options);
		 }
		 return newByteChannel(path, set);
	 }
	 private static class AcceptAllFilter implements DirectoryStream.Filter<Path> {
		 private AcceptAllFilter() {
		 }
		 public boolean accept(Path entry) {
			 return true;
		 }
		 static final AcceptAllFilter FILTER = new AcceptAllFilter();
	 }
	 public static DirectoryStream<Path> newDirectoryStream(Path dir) throws IOException {
		 return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);
	 }
	 public static DirectoryStream<Path> newDirectoryStream(Path dir, String glob) throws IOException {
		 if (glob.equals(""*"")) return newDirectoryStream(dir);
		 FileSystem fs = dir.getFileSystem();
		 final PathMatcher matcher = fs.getPathMatcher(""glob:"" + glob);
		 DirectoryStream.Filter<Path> filter = new DirectoryStream.Filter<>() {
			 public boolean accept(Path entry) {
				 return matcher.matches(entry.getFileName());
			 }
		 }
		;
		 return fs.provider().newDirectoryStream(dir, filter);
	 }
	 public static DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {
		 return provider(dir).newDirectoryStream(dir, filter);
	 }
	 private static final Set<OpenOption> DEFAULT_CREATE_OPTIONS = Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);
	 public static Path createFile(Path path, FileAttribute<?>... attrs) throws IOException {
		 newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();
		 return path;
	 }
	 public static Path createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {
		 provider(dir).createDirectory(dir, attrs);
		 return dir;
	 }
	 public static Path createDirectories(Path dir, FileAttribute<?>... attrs) throws IOException {
		 try {
			 createAndCheckIsDirectory(dir, attrs);
			 return dir;
		 }
		 catch (FileAlreadyExistsException x) {
			 throw x;
		 }
		 catch (IOException x) {
		 }
		 SecurityException se = null;
		 try {
			 dir = dir.toAbsolutePath();
		 }
		 catch (SecurityException x) {
			 se = x;
		 }
		 Path parent = dir.getParent();
		 while (parent != null) {
			 try {
				 provider(parent).checkAccess(parent);
				 break;
			 }
			 catch (NoSuchFileException x) {
			 }
			 parent = parent.getParent();
		 }
		 if (parent == null) {
			 if (se == null) {
				 throw new FileSystemException(dir.toString(), null, ""Unable to determine if root directory exists"");
			 }
			 else {
				 throw se;
			 }
		 }
		 Path child = parent;
		 for (Path name: parent.relativize(dir)) {
			 child = child.resolve(name);
			 createAndCheckIsDirectory(child, attrs);
		 }
		 return dir;
	 }
	 private static void createAndCheckIsDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {
		 try {
			 createDirectory(dir, attrs);
		 }
		 catch (FileAlreadyExistsException x) {
			 if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS)) throw x;
		 }
	 }
	 public static Path createTempFile(Path dir, String prefix, String suffix, FileAttribute<?>... attrs) throws IOException {
		 return TempFileHelper.createTempFile(Objects.requireNonNull(dir), prefix, suffix, attrs);
	 }
	 public static Path createTempFile(String prefix, String suffix, FileAttribute<?>... attrs) throws IOException {
		 return TempFileHelper.createTempFile(null, prefix, suffix, attrs);
	 }
	 public static Path createTempDirectory(Path dir, String prefix, FileAttribute<?>... attrs) throws IOException {
		 return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir), prefix, attrs);
	 }
	 public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {
		 return TempFileHelper.createTempDirectory(null, prefix, attrs);
	 }
	 public static Path createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) throws IOException {
		 provider(link).createSymbolicLink(link, target, attrs);
		 return link;
	 }
	 public static Path createLink(Path link, Path existing) throws IOException {
		 provider(link).createLink(link, existing);
		 return link;
	 }
	 public static void delete(Path path) throws IOException {
		 provider(path).delete(path);
	 }
	 public static boolean deleteIfExists(Path path) throws IOException {
		 return provider(path).deleteIfExists(path);
	 }
	 public static Path copy(Path source, Path target, CopyOption... options) throws IOException {
		 FileSystemProvider provider = provider(source);
		 if (provider(target) == provider) {
			 provider.copy(source, target, options);
		 }
		 else {
			 CopyMoveHelper.copyToForeignTarget(source, target, options);
		 }
		 return target;
	 }
	 public static Path move(Path source, Path target, CopyOption... options) throws IOException {
		 FileSystemProvider provider = provider(source);
		 if (provider(target) == provider) {
			 provider.move(source, target, options);
		 }
		 else {
			 CopyMoveHelper.moveToForeignTarget(source, target, options);
		 }
		 return target;
	 }
	 public static Path readSymbolicLink(Path link) throws IOException {
		 return provider(link).readSymbolicLink(link);
	 }
	 public static FileStore getFileStore(Path path) throws IOException {
		 return provider(path).getFileStore(path);
	 }
	 public static boolean isSameFile(Path path, Path path2) throws IOException {
		 return provider(path).isSameFile(path, path2);
	 }
	 public static long mismatch(Path path, Path path2) throws IOException {
		 if (isSameFile(path, path2)) {
			 return -1;
		 }
		 byte[] buffer1 = new byte[BUFFER_SIZE];
		 byte[] buffer2 = new byte[BUFFER_SIZE];
		 try (InputStream in1 = Files.newInputStream(path);
		 InputStream in2 = Files.newInputStream(path2);
		) {
			 long totalRead = 0;
			 while (true) {
				 int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);
				 int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);
				 int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);
				 if (i > -1) {
					 return totalRead + i;
				 }
				 if (nRead1 < BUFFER_SIZE) {
					 return -1;
				 }
				 totalRead += nRead1;
			 }
		 }
	 }
	 public static boolean isHidden(Path path) throws IOException {
		 return provider(path).isHidden(path);
	 }
	 private static class FileTypeDetectors{
		 static final FileTypeDetector defaultFileTypeDetector = createDefaultFileTypeDetector();
		 static final List<FileTypeDetector> installedDetectors = loadInstalledDetectors();
		 private static FileTypeDetector createDefaultFileTypeDetector() {
			 return AccessController .doPrivileged(new PrivilegedAction<>() {
				 public FileTypeDetector run() {
					 return sun.nio.fs.DefaultFileTypeDetector.create();
				 }
			}
			);
		 }
		 private static List<FileTypeDetector> loadInstalledDetectors() {
			 return AccessController .doPrivileged(new PrivilegedAction<>() {
				 public List<FileTypeDetector> run() {
					 List<FileTypeDetector> list = new ArrayList<>();
					 ServiceLoader<FileTypeDetector> loader = ServiceLoader .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());
					 for (FileTypeDetector detector: loader) {
						 list.add(detector);
					 }
					 return list;
				 }
			}
			);
		 }
	 }
	 public static String probeContentType(Path path) throws IOException {
		 for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {
			 String result = detector.probeContentType(path);
			 if (result != null) return result;
		 }
		 return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);
	 }
	 public static <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {
		 return provider(path).getFileAttributeView(path, type, options);
	 }
	 public static <A extends BasicFileAttributes> A readAttributes(Path path, Class<A> type, LinkOption... options) throws IOException {
		 return provider(path).readAttributes(path, type, options);
	 }
	 public static Path setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {
		 provider(path).setAttribute(path, attribute, value, options);
		 return path;
	 }
	 public static Object getAttribute(Path path, String attribute, LinkOption... options) throws IOException {
		 if (attribute.indexOf('*') >= 0 || attribute.indexOf(',') >= 0) throw new IllegalArgumentException(attribute);
		 Map<String,Object> map = readAttributes(path, attribute, options);
		 assert map.size() == 1;
		 String name;
		 int pos = attribute.indexOf(':');
		 if (pos == -1) {
			 name = attribute;
		 }
		 else {
			 name = (pos == attribute.length()) ? """" : attribute.substring(pos+1);
		 }
		 return map.get(name);
	 }
	 public static Map<String,Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {
		 return provider(path).readAttributes(path, attributes, options);
	 }
	 public static Set<PosixFilePermission> getPosixFilePermissions(Path path, LinkOption... options) throws IOException {
		 return readAttributes(path, PosixFileAttributes.class, options).permissions();
	 }
	 public static Path setPosixFilePermissions(Path path, Set<PosixFilePermission> perms) throws IOException {
		 PosixFileAttributeView view = getFileAttributeView(path, PosixFileAttributeView.class);
		 if (view == null) throw new UnsupportedOperationException();
		 view.setPermissions(perms);
		 return path;
	 }
	 public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {
		 FileOwnerAttributeView view = getFileAttributeView(path, FileOwnerAttributeView.class, options);
		 if (view == null) throw new UnsupportedOperationException();
		 return view.getOwner();
	 }
	 public static Path setOwner(Path path, UserPrincipal owner) throws IOException {
		 FileOwnerAttributeView view = getFileAttributeView(path, FileOwnerAttributeView.class);
		 if (view == null) throw new UnsupportedOperationException();
		 view.setOwner(owner);
		 return path;
	 }
	 public static boolean isSymbolicLink(Path path) {
		 try {
			 return readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS).isSymbolicLink();
		 }
		 catch (IOException ioe) {
			 return false;
		 }
	 }
	 public static boolean isDirectory(Path path, LinkOption... options) {
		 if (options.length == 0) {
			 FileSystemProvider provider = provider(path);
			 if (provider instanceof AbstractFileSystemProvider) return ((AbstractFileSystemProvider)provider).isDirectory(path);
		 }
		 try {
			 return readAttributes(path, BasicFileAttributes.class, options).isDirectory();
		 }
		 catch (IOException ioe) {
			 return false;
		 }
	 }
	 public static boolean isRegularFile(Path path, LinkOption... options) {
		 if (options.length == 0) {
			 FileSystemProvider provider = provider(path);
			 if (provider instanceof AbstractFileSystemProvider) return ((AbstractFileSystemProvider)provider).isRegularFile(path);
		 }
		 try {
			 return readAttributes(path, BasicFileAttributes.class, options).isRegularFile();
		 }
		 catch (IOException ioe) {
			 return false;
		 }
	 }
	 public static FileTime getLastModifiedTime(Path path, LinkOption... options) throws IOException {
		 return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();
	 }
	 public static Path setLastModifiedTime(Path path, FileTime time) throws IOException {
		 getFileAttributeView(path, BasicFileAttributeView.class) .setTimes(Objects.requireNonNull(time), null, null);
		 return path;
	 }
	 public static long size(Path path) throws IOException {
		 return readAttributes(path, BasicFileAttributes.class).size();
	 }
	 private static boolean followLinks(LinkOption... options) {
		 boolean followLinks = true;
		 for (LinkOption opt: options) {
			 if (opt == LinkOption.NOFOLLOW_LINKS) {
				 followLinks = false;
				 continue;
			 }
			 if (opt == null) throw new NullPointerException();
			 throw new AssertionError(""Should not get here"");
		 }
		 return followLinks;
	 }
	 public static boolean exists(Path path, LinkOption... options) {
		 if (options.length == 0) {
			 FileSystemProvider provider = provider(path);
			 if (provider instanceof AbstractFileSystemProvider) return ((AbstractFileSystemProvider)provider).exists(path);
		 }
		 try {
			 if (followLinks(options)) {
				 provider(path).checkAccess(path);
			 }
			 else {
				 readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);
			 }
			 return true;
		 }
		 catch (IOException x) {
			 return false;
		 }
	 }
	 public static boolean notExists(Path path, LinkOption... options) {
		 try {
			 if (followLinks(options)) {
				 provider(path).checkAccess(path);
			 }
			 else {
				 readAttributes(path, BasicFileAttributes.class, LinkOption.NOFOLLOW_LINKS);
			 }
			 return false;
		 }
		 catch (NoSuchFileException x) {
			 return true;
		 }
		 catch (IOException x) {
			 return false;
		 }
	 }
	 private static boolean isAccessible(Path path, AccessMode... modes) {
		 try {
			 provider(path).checkAccess(path, modes);
			 return true;
		 }
		 catch (IOException x) {
			 return false;
		 }
	 }
	 public static boolean isReadable(Path path) {
		 return isAccessible(path, AccessMode.READ);
	 }
	 public static boolean isWritable(Path path) {
		 return isAccessible(path, AccessMode.WRITE);
	 }
	 public static boolean isExecutable(Path path) {
		 return isAccessible(path, AccessMode.EXECUTE);
	 }
	 public static Path walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth, FileVisitor<? super Path> visitor) throws IOException {
		 try (FileTreeWalker walker = new FileTreeWalker(options, maxDepth)) {
			 FileTreeWalker.Event ev = walker.walk(start);
			 do {
				 FileVisitResult result;
				 switch (ev.type()) {
					 case ENTRY : IOException ioe = ev.ioeException();
					 if (ioe == null) {
						 assert ev.attributes() != null;
						 result = visitor.visitFile(ev.file(), ev.attributes());
					 }
					 else {
						 result = visitor.visitFileFailed(ev.file(), ioe);
					 }
					 break;
					 case START_DIRECTORY : result = visitor.preVisitDirectory(ev.file(), ev.attributes());
					 if (result == FileVisitResult.SKIP_SUBTREE || result == FileVisitResult.SKIP_SIBLINGS) walker.pop();
					 break;
					 case END_DIRECTORY : result = visitor.postVisitDirectory(ev.file(), ev.ioeException());
					 if (result == FileVisitResult.SKIP_SIBLINGS) result = FileVisitResult.CONTINUE;
					 break;
					 default : throw new AssertionError(""Should not get here"");
				 }
				 if (Objects.requireNonNull(result) != FileVisitResult.CONTINUE) {
					 if (result == FileVisitResult.TERMINATE) {
						 break;
					 }
					 else if (result == FileVisitResult.SKIP_SIBLINGS) {
						 walker.skipRemainingSiblings();
					 }
				 }
				 ev = walker.next();
			 }
			 while (ev != null);
		 }
		 return start;
	 }
	 public static Path walkFileTree(Path start, FileVisitor<? super Path> visitor) throws IOException {
		 return walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor);
	 }
	 public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException {
		 CharsetDecoder decoder = cs.newDecoder();
		 Reader reader = new InputStreamReader(newInputStream(path), decoder);
		 return new BufferedReader(reader);
	 }
	 public static BufferedReader newBufferedReader(Path path) throws IOException {
		 return newBufferedReader(path, StandardCharsets.UTF_8);
	 }
	 public static BufferedWriter newBufferedWriter(Path path, Charset cs, OpenOption... options) throws IOException {
		 CharsetEncoder encoder = cs.newEncoder();
		 Writer writer = new OutputStreamWriter(newOutputStream(path, options), encoder);
		 return new BufferedWriter(writer);
	 }
	 public static BufferedWriter newBufferedWriter(Path path, OpenOption... options) throws IOException {
		 return newBufferedWriter(path, StandardCharsets.UTF_8, options);
	 }
	 public static long copy(InputStream in, Path target, CopyOption... options) throws IOException {
		 Objects.requireNonNull(in);
		 boolean replaceExisting = false;
		 for (CopyOption opt: options) {
			 if (opt == StandardCopyOption.REPLACE_EXISTING) {
				 replaceExisting = true;
			 }
			 else {
				 if (opt == null) {
					 throw new NullPointerException(""options contains 'null'"");
				 }
				 else {
					 throw new UnsupportedOperationException(opt + "" not supported"");
				 }
			 }
		 }
		 SecurityException se = null;
		 if (replaceExisting) {
			 try {
				 deleteIfExists(target);
			 }
			 catch (SecurityException x) {
				 se = x;
			 }
		 }
		 OutputStream ostream;
		 try {
			 ostream = newOutputStream(target, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);
		 }
		 catch (FileAlreadyExistsException x) {
			 if (se != null) throw se;
			 throw x;
		 }
		 try (OutputStream out = ostream) {
			 return in.transferTo(out);
		 }
	 }
	 public static long copy(Path source, OutputStream out) throws IOException {
		 Objects.requireNonNull(out);
		 try (InputStream in = newInputStream(source)) {
			 return in.transferTo(out);
		 }
	 }
	 private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
	 private static final jdk.internal.access.JavaLangAccess JLA = jdk.internal.access.SharedSecrets.getJavaLangAccess();
	 private static byte[] read(InputStream source, int initialSize) throws IOException {
		 int capacity = initialSize;
		 byte[] buf = new byte[capacity];
		 int nread = 0;
		 int n;
		 for (;
		;
		) {
			 while ((n = source.read(buf, nread, capacity - nread)) > 0) nread += n;
			 if (n < 0 || (n = source.read()) < 0) break;
			 if (capacity <= MAX_BUFFER_SIZE - capacity) {
				 capacity = Math.max(capacity << 1, BUFFER_SIZE);
			 }
			 else {
				 if (capacity == MAX_BUFFER_SIZE) throw new OutOfMemoryError(""Required array size too large"");
				 capacity = MAX_BUFFER_SIZE;
			 }
			 buf = Arrays.copyOf(buf, capacity);
			 buf[nread++] = (byte)n;
		 }
		 return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
	 }
	 public static byte[] readAllBytes(Path path) throws IOException {
		 try (SeekableByteChannel sbc = Files.newByteChannel(path);
		 InputStream in = Channels.newInputStream(sbc)) {
			 if (sbc instanceof FileChannelImpl) ((FileChannelImpl) sbc).setUninterruptible();
			 long size = sbc.size();
			 if (size > (long) MAX_BUFFER_SIZE) throw new OutOfMemoryError(""Required array size too large"");
			 return read(in, (int)size);
		 }
	 }
	 public static String readString(Path path) throws IOException {
		 return readString(path, StandardCharsets.UTF_8);
	 }
	 public static String readString(Path path, Charset cs) throws IOException {
		 Objects.requireNonNull(path);
		 Objects.requireNonNull(cs);
		 byte[] ba = readAllBytes(path);
		 return JLA.newStringNoRepl(ba, cs);
	 }
	 public static List<String> readAllLines(Path path, Charset cs) throws IOException {
		 try (BufferedReader reader = newBufferedReader(path, cs)) {
			 List<String> result = new ArrayList<>();
			 for (;
			;
			) {
				 String line = reader.readLine();
				 if (line == null) break;
				 result.add(line);
			 }
			 return result;
		 }
	 }
	 public static List<String> readAllLines(Path path) throws IOException {
		 return readAllLines(path, StandardCharsets.UTF_8);
	 }
	 public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException {
		 Objects.requireNonNull(bytes);
		 try (OutputStream out = Files.newOutputStream(path, options)) {
			 int len = bytes.length;
			 int rem = len;
			 while (rem > 0) {
				 int n = Math.min(rem, BUFFER_SIZE);
				 out.write(bytes, (len-rem), n);
				 rem -= n;
			 }
		 }
		 return path;
	 }
	 public static Path write(Path path, Iterable<? extends CharSequence> lines, Charset cs, OpenOption... options) throws IOException {
		 Objects.requireNonNull(lines);
		 CharsetEncoder encoder = cs.newEncoder();
		 OutputStream out = newOutputStream(path, options);
		 try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, encoder))) {
			 for (CharSequence line: lines) {
				 writer.append(line);
				 writer.newLine();
			 }
		 }
		 return path;
	 }
	 public static Path write(Path path, Iterable<? extends CharSequence> lines, OpenOption... options) throws IOException {
		 return write(path, lines, StandardCharsets.UTF_8, options);
	 }
	 public static Path writeString(Path path, CharSequence csq, OpenOption... options) throws IOException {
		 return writeString(path, csq, StandardCharsets.UTF_8, options);
	 }
	 public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options) throws IOException {
		 Objects.requireNonNull(path);
		 Objects.requireNonNull(csq);
		 Objects.requireNonNull(cs);
		 byte[] bytes = JLA.getBytesNoRepl(String.valueOf(csq), cs);
		 write(path, bytes, options);
		 return path;
	 }
	 public static Stream<Path> list(Path dir) throws IOException {
		 DirectoryStream<Path> ds = Files.newDirectoryStream(dir);
		 try {
			 final Iterator<Path> delegate = ds.iterator();
			 Iterator<Path> iterator = new Iterator<>() {
				 public boolean hasNext() {
					 try {
						 return delegate.hasNext();
					 }
					 catch (DirectoryIteratorException e) {
						 throw new UncheckedIOException(e.getCause());
					 }
				 }
				 public Path next() {
					 try {
						 return delegate.next();
					 }
					 catch (DirectoryIteratorException e) {
						 throw new UncheckedIOException(e.getCause());
					 }
				 }
			 }
			;
			 Spliterator<Path> spliterator = Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
			 return StreamSupport.stream(spliterator, false) .onClose(asUncheckedRunnable(ds));
		 }
		 catch (Error|RuntimeException e) {
			 try {
				 ds.close();
			 }
			 catch (IOException ex) {
				 try {
					 e.addSuppressed(ex);
				 }
				 catch (Throwable ignore) {
				}
			 }
			 throw e;
		 }
	 }
	 public static Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options) throws IOException {
		 FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
		 try {
			 Spliterator<FileTreeWalker.Event> spliterator = Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
			 return StreamSupport.stream(spliterator, false) .onClose(iterator::close) .map(entry -> entry.file());
		 }
		 catch (Error|RuntimeException e) {
			 iterator.close();
			 throw e;
		 }
	 }
	 public static Stream<Path> walk(Path start, FileVisitOption... options) throws IOException {
		 return walk(start, Integer.MAX_VALUE, options);
	 }
	 public static Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes> matcher, FileVisitOption... options) throws IOException {
		 FileTreeIterator iterator = new FileTreeIterator(start, maxDepth, options);
		 try {
			 Spliterator<FileTreeWalker.Event> spliterator = Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);
			 return StreamSupport.stream(spliterator, false) .onClose(iterator::close) .filter(entry -> matcher.test(entry.file(), entry.attributes())) .map(entry -> entry.file());
		 }
		 catch (Error|RuntimeException e) {
			 iterator.close();
			 throw e;
		 }
	 }
	 public static Stream<String> lines(Path path, Charset cs) throws IOException {
		 if (path.getFileSystem() == FileSystems.getDefault() && FileChannelLinesSpliterator.SUPPORTED_CHARSET_NAMES.contains(cs.name())) {
			 FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);
			 Stream<String> fcls = createFileChannelLinesStream(fc, cs);
			 if (fcls != null) {
				 return fcls;
			 }
			 fc.close();
		 }
		 return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));
	 }
	 private static Stream<String> createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {
		 try {
			 long length = fc.size();
			 if (length > 0 && length <= Integer.MAX_VALUE) {
				 Spliterator<String> s = new FileChannelLinesSpliterator(fc, cs, 0, (int) length);
				 return StreamSupport.stream(s, false) .onClose(Files.asUncheckedRunnable(fc));
			 }
		 }
		 catch (Error|RuntimeException|IOException e) {
			 try {
				 fc.close();
			 }
			 catch (IOException ex) {
				 try {
					 e.addSuppressed(ex);
				 }
				 catch (Throwable ignore) {
				 }
			 }
			 throw e;
		 }
		 return null;
	 }
	 private static Stream<String> createBufferedReaderLinesStream(BufferedReader br) {
		 try {
			 return br.lines().onClose(asUncheckedRunnable(br));
		 }
		 catch (Error|RuntimeException e) {
			 try {
				 br.close();
			 }
			 catch (IOException ex) {
				 try {
					 e.addSuppressed(ex);
				 }
				 catch (Throwable ignore) {
				 }
			 }
			 throw e;
		 }
	 }
	 public static Stream<String> lines(Path path) throws IOException {
		 return lines(path, StandardCharsets.UTF_8);
	 }
}",1,0,0,0
"public class JodaDateValidator {
	 public enum PostgresDateTimeConstant {
		 POSTGRES_FULL_NAME_OF_DAY(true, ""day""), POSTGRES_DAY_OF_YEAR(false, ""ddd""), POSTGRES_DAY_OF_MONTH(false, ""dd""), POSTGRES_DAY_OF_WEEK(false, ""d""), POSTGRES_NAME_OF_MONTH(true, ""month""), POSTGRES_ABR_NAME_OF_MONTH(true, ""mon""), POSTGRES_YEAR(false, ""y""), POSTGRES_ISO_4YEAR(false, ""iyyy""), POSTGRES_ISO_3YEAR(false, ""iyy""), POSTGRES_ISO_2YEAR(false, ""iy""), POSTGRES_ISO_1YEAR(false, ""i""), POSTGRES_FULL_ERA_NAME(false, ""ee""), POSTGRES_NAME_OF_DAY(true, ""dy""), POSTGRES_HOUR_12_NAME(false, ""hh""), POSTGRES_HOUR_12_OTHER_NAME(false, ""hh12""), POSTGRES_HOUR_24_NAME(false, ""hh24""), POSTGRES_MINUTE_OF_HOUR_NAME(false, ""mi""), POSTGRES_SECOND_OF_MINUTE_NAME(false, ""ss""), POSTGRES_MILLISECOND_OF_MINUTE_NAME(false, ""ms""), POSTGRES_WEEK_OF_YEAR(false, ""ww""), POSTGRES_ISO_WEEK_OF_YEAR(false, ""iw""), POSTGRES_MONTH(false, ""mm""), POSTGRES_HALFDAY_AM(false, ""am""), POSTGRES_HALFDAY_PM(false, ""pm""), PREFIX_FM(false, ""fm""), PREFIX_FX(false, ""fx""), PREFIX_TM(false, ""tm"");
		 private final boolean hasCamelCasing;
		 private final String name;
		 PostgresDateTimeConstant(boolean hasCamelCasing, String name) {
			 this.hasCamelCasing = hasCamelCasing;
			 this.name = name;
		 }
		 public boolean hasCamelCasing() {
			 return hasCamelCasing;
		 }
		 public String getName() {
			 return name;
		 }
	 }
	 private static final Map<PostgresDateTimeConstant, String> postgresToJodaMap = Maps.newTreeMap(new LengthDescComparator());
	 public static final String POSTGRES_ESCAPE_CHARACTER = ""\"""";
	 public static final String JODA_FULL_NAME_OF_DAY = ""EEEE"";
	 public static final String JODA_DAY_OF_YEAR = ""D"";
	 public static final String JODA_DAY_OF_MONTH = ""d"";
	 public static final String JODA_DAY_OF_WEEK = ""e"";
	 public static final String JODA_NAME_OF_MONTH = ""MMMM"";
	 public static final String JODA_ABR_NAME_OF_MONTH = ""MMM"";
	 public static final String JODA_YEAR = ""y"";
	 public static final String JODA_ISO_4YEAR = ""xxxx"";
	 public static final String JODA_ISO_3YEAR = ""xxx"";
	 public static final String JODA_ISO_2YEAR = ""xx"";
	 public static final String JODA_ISO_1YEAR = ""x"";
	 public static final String JODA_FULL_ERA_NAME = ""G"";
	 public static final String JODA_NAME_OF_DAY = ""E"";
	 public static final String JODA_HOUR_12_NAME = ""h"";
	 public static final String JODA_HOUR_24_NAME = ""H"";
	 public static final String JODA_MINUTE_OF_HOUR_NAME = ""m"";
	 public static final String JODA_SECOND_OF_MINUTE_NAME = ""ss"";
	 public static final String JODA_MILLISECOND_OF_MINUTE_NAME = ""SSS"";
	 public static final String JODA_WEEK_OF_YEAR = ""w"";
	 public static final String JODA_MONTH = ""MM"";
	 public static final String JODA_HALFDAY = ""aa"";
	 public static final String JODA_ESCAPE_CHARACTER = ""'"";
	 public static final String EMPTY_STRING = """";
	 static {
		 postgresToJodaMap.put(POSTGRES_FULL_NAME_OF_DAY, JODA_FULL_NAME_OF_DAY);
		 postgresToJodaMap.put(POSTGRES_DAY_OF_YEAR, JODA_DAY_OF_YEAR);
		 postgresToJodaMap.put(POSTGRES_DAY_OF_MONTH, JODA_DAY_OF_MONTH);
		 postgresToJodaMap.put(POSTGRES_DAY_OF_WEEK, JODA_DAY_OF_WEEK);
		 postgresToJodaMap.put(POSTGRES_NAME_OF_MONTH, JODA_NAME_OF_MONTH);
		 postgresToJodaMap.put(POSTGRES_ABR_NAME_OF_MONTH, JODA_ABR_NAME_OF_MONTH);
		 postgresToJodaMap.put(POSTGRES_FULL_ERA_NAME, JODA_FULL_ERA_NAME);
		 postgresToJodaMap.put(POSTGRES_NAME_OF_DAY, JODA_NAME_OF_DAY);
		 postgresToJodaMap.put(POSTGRES_HOUR_12_NAME, JODA_HOUR_12_NAME);
		 postgresToJodaMap.put(POSTGRES_HOUR_12_OTHER_NAME, JODA_HOUR_12_NAME);
		 postgresToJodaMap.put(POSTGRES_HOUR_24_NAME, JODA_HOUR_24_NAME);
		 postgresToJodaMap.put(POSTGRES_MINUTE_OF_HOUR_NAME, JODA_MINUTE_OF_HOUR_NAME);
		 postgresToJodaMap.put(POSTGRES_SECOND_OF_MINUTE_NAME, JODA_SECOND_OF_MINUTE_NAME);
		 postgresToJodaMap.put(POSTGRES_MILLISECOND_OF_MINUTE_NAME, JODA_MILLISECOND_OF_MINUTE_NAME);
		 postgresToJodaMap.put(POSTGRES_WEEK_OF_YEAR, JODA_WEEK_OF_YEAR);
		 postgresToJodaMap.put(POSTGRES_MONTH, JODA_MONTH);
		 postgresToJodaMap.put(POSTGRES_HALFDAY_AM, JODA_HALFDAY);
		 postgresToJodaMap.put(POSTGRES_HALFDAY_PM, JODA_HALFDAY);
		 postgresToJodaMap.put(POSTGRES_ISO_WEEK_OF_YEAR, JODA_WEEK_OF_YEAR);
		 postgresToJodaMap.put(POSTGRES_YEAR, JODA_YEAR);
		 postgresToJodaMap.put(POSTGRES_ISO_1YEAR, JODA_ISO_1YEAR);
		 postgresToJodaMap.put(POSTGRES_ISO_2YEAR, JODA_ISO_2YEAR);
		 postgresToJodaMap.put(POSTGRES_ISO_3YEAR, JODA_ISO_3YEAR);
		 postgresToJodaMap.put(POSTGRES_ISO_4YEAR, JODA_ISO_4YEAR);
		 postgresToJodaMap.put(PREFIX_FM, EMPTY_STRING);
		 postgresToJodaMap.put(PREFIX_FX, EMPTY_STRING);
		 postgresToJodaMap.put(PREFIX_TM, EMPTY_STRING);
	 }
	 public static String toJodaFormat(String pattern) {
		 StringBuilder builder = new StringBuilder(pattern.replaceAll(POSTGRES_ESCAPE_CHARACTER, JODA_ESCAPE_CHARACTER));
		 int start = 0;
		 int minPos;
		 do {
			 minPos = builder.length();
			 PostgresDateTimeConstant firstMatch = null;
			 for (PostgresDateTimeConstant postgresPattern : postgresToJodaMap.keySet()) {
				 int pos;
				 if (postgresPattern.hasCamelCasing()) {
					 pos = builder.indexOf(StringUtils.capitalize(postgresPattern.getName()), start);
					 if (pos >= 0 && pos < minPos) {
						 firstMatch = postgresPattern;
						 minPos = pos;
						 if (minPos == start) {
							 break;
						 }
					 }
				 }
				 pos = builder.indexOf(postgresPattern.getName().toLowerCase(), start);
				 if (pos >= 0 && pos < minPos) {
					 firstMatch = postgresPattern;
					 minPos = pos;
					 if (minPos == start) {
						 break;
					 }
				 }
				 pos = builder.indexOf(postgresPattern.getName().toUpperCase(), start);
				 if (pos >= 0 && pos < minPos) {
					 firstMatch = postgresPattern;
					 minPos = pos;
					 if (minPos == start) {
						 break;
					 }
				 }
			 }
			 if (minPos < builder.length() && firstMatch != null) {
				 String jodaToken = postgresToJodaMap.get(firstMatch);
				 if (StringUtils.countMatches(builder.subSequence(0, minPos), JODA_ESCAPE_CHARACTER) % 2 == 0) {
					 int offset = minPos + firstMatch.getName().length();
					 builder.replace(minPos, offset, jodaToken);
					 start = minPos + jodaToken.length();
				 }
				 else {
					 int endEscapeCharacter = builder.indexOf(JODA_ESCAPE_CHARACTER, minPos);
					 if (endEscapeCharacter >= 0) {
						 start = endEscapeCharacter;
					 }
					 else {
						 break;
					 }
				 }
			 }
		 }
		 while (minPos < builder.length());
		 return builder.toString();
	 }
	 private static class LengthDescComparator implements Comparator<PostgresDateTimeConstant> {
		 public int compare(PostgresDateTimeConstant o1, PostgresDateTimeConstant o2) {
			 int result = o2.getName().length() - o1.getName().length();
			 if (result == 0) {
				 return o1.getName().compareTo(o2.getName());
			 }
			 return result;
		 }
	 }
}",1,1,0,0
"static List<Period> generateSchedule(Calendar startDate,Tenor maturity, Frequency frequency, StubType stubType, Period prototype, int maxPeriods);",0,0,0,1
"public class TokenizedPath {
	 public static final TokenizedPath EMPTY_PATH = new TokenizedPath("""", new String[0]);
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private static final SymbolicLinkUtils SYMLINK_UTILS = SymbolicLinkUtils.getSymbolicLinkUtils();
	 private static final boolean[] CS_SCAN_ONLY = new boolean[] {
	true}
	;
	 private static final boolean[] CS_THEN_NON_CS = new boolean[] {
	true, false}
	;
	 private final String path;
	 private final String tokenizedPath[];
	 public TokenizedPath(String path) {
		 this(path, SelectorUtils.tokenizePathAsArray(path));
	 }
	 public TokenizedPath(TokenizedPath parent, String child) {
		 if (parent.path.length() > 0 && parent.path.charAt(parent.path.length() - 1) != File.separatorChar) {
			 path = parent.path + File.separatorChar + child;
		 }
		 else {
			 path = parent.path + child;
		 }
		 tokenizedPath = new String[parent.tokenizedPath.length + 1];
		 System.arraycopy(parent.tokenizedPath, 0, tokenizedPath, 0, parent.tokenizedPath.length);
		 tokenizedPath[parent.tokenizedPath.length] = child;
	 }
	 TokenizedPath(String path, String[] tokens) {
		 this.path = path;
		 this.tokenizedPath = tokens;
	 }
	 public String toString() {
		 return path;
	 }
	 public int depth() {
		 return tokenizedPath.length;
	 }
	 String[] getTokens() {
		 return tokenizedPath;
	 }
	 public File findFile(File base, final boolean cs) {
		 String[] tokens = tokenizedPath;
		 if (FileUtils.isAbsolutePath(path)) {
			 if (base == null) {
				 String[] s = FILE_UTILS.dissect(path);
				 base = new File(s[0]);
				 tokens = SelectorUtils.tokenizePathAsArray(s[1]);
			 }
			 else {
				 File f = FILE_UTILS.normalize(path);
				 String s = FILE_UTILS.removeLeadingPath(base, f);
				 if (s.equals(f.getAbsolutePath())) {
					 return null;
				 }
				 tokens = SelectorUtils.tokenizePathAsArray(s);
			 }
		 }
		 return findFile(base, tokens, cs);
	 }
	 public boolean isSymlink(File base) {
		 for (int i = 0;
		 i < tokenizedPath.length;
		 i++) {
			 try {
				 if ((base != null && SYMLINK_UTILS.isSymbolicLink(base, tokenizedPath[i])) || (base == null && SYMLINK_UTILS.isSymbolicLink(tokenizedPath[i])) ) {
					 return true;
				 }
				 base = new File(base, tokenizedPath[i]);
			 }
			 catch (java.io.IOException ioe) {
				 String msg = ""IOException caught while checking "" + ""for links, couldn't get canonical path!"";
				 System.err.println(msg);
			 }
		 }
		 return false;
	 }
	 public boolean equals(Object o) {
		 return o instanceof TokenizedPath && path.equals(((TokenizedPath) o).path);
	 }
	 public int hashCode() {
		 return path.hashCode();
	 }
	 private static File findFile(File base, final String[] pathElements, final boolean cs) {
		 for (int current = 0;
		 current < pathElements.length;
		 current++) {
			 if (!base.isDirectory()) {
				 return null;
			 }
			 String[] files = base.list();
			 if (files == null) {
				 throw new BuildException(""IO error scanning directory "" + base.getAbsolutePath());
			 }
			 boolean found = false;
			 boolean[] matchCase = cs ? CS_SCAN_ONLY : CS_THEN_NON_CS;
			 for (int i = 0;
			 !found && i < matchCase.length;
			 i++) {
				 for (int j = 0;
				 !found && j < files.length;
				 j++) {
					 if (matchCase[i] ? files[j].equals(pathElements[current]) : files[j].equalsIgnoreCase(pathElements[current])) {
						 base = new File(base, files[j]);
						 found = true;
					 }
				 }
			 }
			 if (!found) {
				 return null;
			 }
		 }
		 return pathElements.length == 0 && !base.isDirectory() ? null : base;
	 }
	 public TokenizedPattern toPattern() {
		 return new TokenizedPattern(path, tokenizedPath);
	 }
}",0,0,0,0
"private SplittedEntry extractSplittedAmount( Entry entry, String line, short factor) throws CanceledException;",0,0,0,0
"public class ShapeMarshaller {
	 private String action;
	 private String verb;
	 private String target;
	 private String requestUri;
	 private String locationName;
	 private String xmlNameSpaceUri;
	 public String getAction() {
		 return action;
	 }
	 public void setAction(String action) {
		 this.action = action;
	 }
	 public ShapeMarshaller withAction(String action) {
		 setAction(action);
		 return this;
	 }
	 public String getVerb() {
		 return verb;
	 }
	 public void setVerb(String verb) {
		 this.verb = verb;
	 }
	 public ShapeMarshaller withVerb(String verb) {
		 setVerb(verb);
		 return this;
	 }
	 public String getTarget() {
		 return target;
	 }
	 public void setTarget(String target) {
		 this.target = target;
	 }
	 public ShapeMarshaller withTarget(String target) {
		 setTarget(target);
		 return this;
	 }
	 public String getRequestUri() {
		 return requestUri;
	 }
	 public void setRequestUri(String requestUri) {
		 this.requestUri = requestUri;
	 }
	 public ShapeMarshaller withRequestUri(String requestUri) {
		 setRequestUri(requestUri);
		 return this;
	 }
	 public String getLocationName() {
		 return locationName;
	 }
	 public void setLocationName(String locationName) {
		 this.locationName = locationName;
	 }
	 public ShapeMarshaller withLocationName(String locationName) {
		 setLocationName(locationName);
		 return this;
	 }
	 public String getXmlNameSpaceUri() {
		 return xmlNameSpaceUri;
	 }
	 public void setXmlNameSpaceUri(String xmlNameSpaceUri) {
		 this.xmlNameSpaceUri = xmlNameSpaceUri;
	 }
	 public ShapeMarshaller withXmlNameSpaceUri(String xmlNameSpaceUri) {
		 setXmlNameSpaceUri(xmlNameSpaceUri);
		 return this;
	 }
}",1,1,0,0
"public class FILTERFROMFILE extends FilterFunc{
	private String FilterFileName = """";
	public FILTERFROMFILE(){
	 }
	public FILTERFROMFILE(String FilterFileName){
		this.FilterFileName = FilterFileName;
	}
	Map<String, Boolean> lookupTable = null;
	private void init() throws IOException {
		lookupTable = new HashMap<String, Boolean>();
		Properties props = ConfigurationUtil.toProperties(PigMapReduce.sJobConfInternal.get());
		InputStream is = FileLocalizer.openDFSFile(FilterFileName, props);
		BufferedReader reader = new BufferedReader(new InputStreamReader(is));
		while (true){
			String line = reader.readLine();
			if (line == null)break;
			String FilterField = line.split(""\t"")[0];
			lookupTable.put(FilterField, Boolean.TRUE);
		}
	}
	public Boolean exec(Tuple input) throws IOException {
		 if (lookupTable == null){
			init();
		 }
		String s;
		 try {
			 s = input.get(0).toString();
		 }
		 catch (ExecException e) {
			 IOException ioe = new IOException(""Error getting data"");
			 ioe.initCause(e);
			 throw ioe;
		 }
		 boolean matched = lookupTable.containsKey(s);
		 return(matched);
	 }
}",1,0,0,0
"public class HeaderParser {
	 private static final String DIRECTIVE_FILTER = ""filter"";
	 private final String headerName;
	 private final Map<String, String> parameters = new HashMap<>();
	 private final Map<String, String> directives = new HashMap<>();
	 private final Map<String, String> filterValue = new HashMap<>();
	 private final Feedback feedback;
	 private String header;
	 private int pos;
	 private String directiveOrParameterName;
	 private int contentStart;
	 private String versionFilter;
	 public HeaderParser(String headerName, String header, Feedback feedback) {
		 this.headerName = headerName;
		 this.feedback = feedback;
		 if (header != null) {
			 this.header = header.trim();
		 }
		 else {
			 this.header = """";
		 }
	 }
	 private MetadataException metaEx(String key, Object... args) {
		 return new MetadataException(headerName, feedback.l10n(key, args));
	 }
	 public HeaderParser mustExist() throws MetadataException {
		 if (header == null || header.isEmpty()) {
			 throw metaEx(""ERROR_HeaderMissing"", headerName);
		 }
		 return this;
	 }
	 private static boolean isAlphaNum(char c) {
		 return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
	 }
	 private static boolean isToken(char c) {
		 return isAlphaNum(c) || c == '_' || c == '-';
	 }
	 private static boolean isExtended(char c) {
		 return isToken(c) || c == '.';
	 }
	 public boolean getBoolean(Boolean defValue) {
		 if (pos >= header.length()) {
			 if (defValue == null) {
				 throw metaEx(""ERROR_HeaderMissing"", headerName);
			 }
			 return defValue;
		 }
		 else {
			 String s = header.substring(pos).trim().toLowerCase(Locale.ENGLISH);
			 switch (s) {
				 case ""true"": return true;
				 case ""false"": return false;
			 }
			 throw metaEx(""ERROR_HeaderInvalid"", headerName, s);
		 }
	 }
	 public String getContents(String defValue) {
		 if (pos >= header.length()) {
			 return defValue;
		 }
		 else {
			 return header.substring(pos).trim();
		 }
	 }
	 private void addFilterAttribute(String attrName, String value) {
		 if (filterValue.put(attrName, value) != null) {
			 throw metaErr(""ERROR_DuplicateFilterAttribute"");
		 }
	 }
	 private boolean isEmpty() {
		 return pos >= header.length();
	 }
	 public String parseSymbolicName() throws MetadataException {
		 return parseNameOrNamespace(HeaderParser::isToken, ""ERROR_MissingSymbolicName"", ""ERROR_InvalidSymbolicName"", '.');
	 }
	 private char next() {
		 return pos < header.length() ? header.charAt(pos++) : 0;
	 }
	 private void advance() {
		 pos++;
	 }
	 private char ch() {
		 return isEmpty() ? 0 : header.charAt(pos);
	 }
	 private String returnCut() {
		 String s = cut();
		 skipWhitespaces();
		 return s;
	 }
	 private void skipWhitespaces() {
		 while (!isEmpty()) {
			 if (!Character.isWhitespace(ch())) {
				 contentStart = pos;
				 return;
			 }
			 advance();
		 }
		 contentStart = -1;
	 }
	 private void skipWithSemicolon() {
		 skipWhitespaces();
		 if (ch() == ';
		') {
			 advance();
		 }
		 contentStart = -1;
	 }
	 private String cut() {
		 return cut(0);
	 }
	 private String cut(int delim) {
		 int e = pos - delim;
		 return contentStart == -1 || contentStart >= e ? """" : header.substring(contentStart, e);
	 }
	 private void markContent() {
		 contentStart = pos;
	 }
	 private String readExtendedParameter() throws MetadataException {
		 skipWhitespaces();
		 while (!isEmpty()) {
			 char c = next();
			 if (Character.isWhitespace(c)) {
				 break;
			 }
			 if (!isExtended(c)) {
				 throw metaEx(""ERROR_InvalidParameterSyntax"", directiveOrParameterName);
			 }
		 }
		 String s = cut();
		 skipWithSemicolon();
		 return s;
	 }
	 private String readQuotedParameter() throws MetadataException {
		 markContent();
		 while (!isEmpty()) {
			 char c = next();
			 switch (c) {
				 case '""': return cut(1);
				 case '\n': case '\r': case 0: throw metaEx(""ERROR_InvalidQuotedString"");
				 case '\\': next();
				 break;
			 }
		 }
		 throw metaEx(""ERROR_InvalidQuotedString"");
	 }
	 private String parseArgument() throws MetadataException {
		 skipWhitespaces();
		 char c = ch();
		 if (c == ';
		') {
			 throw metaEx(""ERROR_MissingArgument"", directiveOrParameterName);
		 }
		 if (c == '""') {
			 advance();
			 return readQuotedParameter();
		 }
		 else {
			 return readExtendedParameter();
		 }
	 }
	 private String parseNameOrNamespace(Predicate<Character> charAcceptor, String missingKeyName, String invalidKeyName, char compDelimiter) throws MetadataException {
		 if (header == null || isEmpty()) {
			 throw metaEx(missingKeyName);
		 }
		 skipWhitespaces();
		 boolean componentEmpty = true;
		 while (!isEmpty()) {
			 char c = ch();
			 if (c == ';
			') {
				 String s = cut();
				 return s;
			 }
			 advance();
			 if (c == compDelimiter) {
				 if (componentEmpty) {
					 throw metaEx(invalidKeyName);
				 }
				 componentEmpty = true;
				 continue;
			 }
			 if (Character.isWhitespace(c)) {
				 break;
			 }
			 if (!charAcceptor.test(c)) {
				 throw metaEx(invalidKeyName);
			 }
			 componentEmpty = false;
		 }
		 return returnCut();
	 }
	 private String parseNamespace() throws MetadataException {
		 return parseNameOrNamespace(HeaderParser::isExtended, ""ERROR_MissingCapabilityName"", ""ERROR_InvalidCapabilityName"", (char) 0);
	 }
	 public String version() throws MetadataException {
		 int versionStart = -1;
		 int partCount = 0;
		 boolean partContents = false;
		 if (isEmpty()) {
			 throw metaErr(""ERROR_InvalidVersion"");
		 }
		 boolean dash = false;
		 while (!isEmpty()) {
			 char c = ch();
			 if (Character.isWhitespace(c)) {
				 if (versionStart != -1) {
					 break;
				 }
				 advance();
				 continue;
			 }
			 if (c == ';
			') {
				 break;
			 }
			 advance();
			 if (c == '.') {
				 if (++partCount > 3 || !partContents) {
					 throw metaErr(""ERROR_InvalidVersion"");
				 }
				 partContents = false;
				 dash = false;
				 continue;
			 }
			 if (partCount > 0 && partContents && c == '-') {
				 dash = true;
				 continue;
			 }
			 if (c >= '0' && c <= '9') {
				 if (versionStart == -1) {
					 versionStart = pos - 1;
				 }
			 }
			 else {
				 if (partCount < 1) {
					 throw metaErr(""ERROR_InvalidVersion"");
				 }
				 boolean err = false;
				 if (partCount >= 3 || dash) {
					 err = !isToken(c);
				 }
				 else {
					 err = true;
				 }
				 if (err) {
					 throw metaErr(""ERROR_InvalidVersion"");
				 }
			 }
			 partContents = true;
		 }
		 String v = cut();
		 skipWhitespaces();
		 if (!isEmpty() || !partContents) {
			 throw metaErr(""ERROR_InvalidVersion"");
		 }
		 return v;
	 }
	 private String readExtendedName() {
		 skipWhitespaces();
		 while (!isEmpty()) {
			 char c = ch();
			 if (isExtended(c)) {
				 advance();
			 }
			 else if (Character.isWhitespace(c) || c == ':' || c == '=') {
				 break;
			 }
			 else {
				 throw metaEx(""ERROR_InvalidParameterName"");
			 }
		 }
		 return returnCut();
	 }
	 private void parseParameters() {
		 while (!isEmpty()) {
			 String paramOrDirectiveName = readExtendedName();
			 if (paramOrDirectiveName.isEmpty()) {
				 throw metaEx(""ERROR_InvalidParameterName"");
			 }
			 directiveOrParameterName = paramOrDirectiveName;
			 char c = ch();
			 boolean dcolon = c == ':';
			 if (dcolon) {
				 advance();
			 }
			 c = next();
			 if (c != '=') {
				 throw metaEx(""ERROR_InvalidParameterSyntax"", paramOrDirectiveName);
			 }
			 (dcolon ? directives : parameters).put(paramOrDirectiveName, parseArgument());
		 }
	 }
	 private void replaceInputText(String text) {
		 this.header = text;
		 this.pos = 0;
	 }
	 private MetadataException metaErr(String key, Object... args) throws MetadataException {
		 throw metaEx(key, args);
	 }
	 private MetadataException filterError() throws MetadataException {
		 throw metaErr(""ERROR_InvalidFilterSpecification"");
	 }
	 private void parseFilterConjunction() {
		 skipWhitespaces();
		 char c = next();
		 while (c == '(') {
			 parseFilterContent();
			 c = next();
		 }
		 if (c != ')') {
			 throw filterError();
		 }
	 }
	 private void parseFilterClause() {
		 skipWhitespaces();
		 int lastPos = -1;
		 W: while (!isEmpty()) {
			 char c = ch();
			 if (Character.isWhitespace(c)) {
				 if (lastPos == -1) {
					 lastPos = pos;
				 }
				 continue;
			 }
			 switch (c) {
				 case '=': case '<': case '>': case '~': case '(': case ')': break W;
			 }
			 lastPos = -1;
			 advance();
		 }
		 String attributeName = returnCut();
		 char c = next();
		 if (c != '=') {
			 throw metaErr(""ERROR_UnsupportedFilterOperation"");
		 }
		 c = ch();
		 if (c == '*') {
			 throw metaErr(""ERROR_UnsupportedFilterOperation"");
		 }
		 markContent();
		 while (!isEmpty()) {
			 c = next();
			 if (c == ')') {
				 addFilterAttribute(attributeName, cut(1));
				 skipWhitespaces();
				 return;
			 }
			 switch (c) {
				 case '\\': c = next();
				 if (c == 0) {
					 throw filterError();
				 }
				 break;
				 case '*': throw metaErr(""ERROR_UnsupportedFilterOperation"");
				 case '(': case '<': case '>': case '~': case '=': throw filterError();
			 }
		 }
		 throw filterError();
	 }
	 private void parseFilterContent() {
		 skipWhitespaces();
		 char o = ch();
		 if (o == '&') {
			 advance();
			 parseFilterConjunction();
		 }
		 else if (isExtended(o)) {
			 parseFilterClause();
		 }
		 else {
			 throw metaErr(""ERROR_InvalidFilterSpecification"");
		 }
	 }
	 private void parseFilterSpecification() {
		 skipWhitespaces();
		 if (isEmpty()) {
			 throw filterError();
		 }
		 char c = next();
		 if (c == '(') {
			 parseFilterContent();
			 skipWhitespaces();
			 if (!isEmpty()) {
				 throw metaErr(""ERROR_InvalidFilterSpecification"");
			 }
		 }
		 else {
			 throw filterError();
		 }
	 }
	 public Map<String, String> parseRequiredCapabilities() {
		 String namespace = parseNamespace();
		 char c = next();
		 if (c != ';
		' && c != 0) {
			 throw metaErr(""ERROR_InvalidFilterSpecification"");
		 }
		 if (!BundleConstants.GRAALVM_CAPABILITY.equals(namespace)) {
			 throw new DependencyException(namespace, null, null, feedback.l10n(""ERROR_UnknownCapability""));
		 }
		 parseParameters();
		 if (!parameters.isEmpty()) {
			 throw metaErr(""ERROR_UnsupportedParameters"");
		 }
		 versionFilter = directives.remove(DIRECTIVE_FILTER);
		 if (!directives.isEmpty()) {
			 throw metaErr(""ERROR_UnsupportedDirectives"");
		 }
		 if (versionFilter == null) {
			 throw metaErr(""ERROR_MissingVersionFilter"");
		 }
		 replaceInputText(versionFilter);
		 parseFilterSpecification();
		 return filterValue;
	 }
}",1,0,0,0
"public class VXMetricPolicyCount implements java.io.Serializable {
	private static final long serialVersionUID = 1L;
	protected Map<String,VXMetricServiceCount> policyCountList = new HashMap<String,VXMetricServiceCount>();
	protected long totalCount;
	public VXMetricPolicyCount() {
	}
	public Map<String, VXMetricServiceCount> getPolicyCountList() {
		return policyCountList;
	}
	public void setPolicyCountList(Map<String, VXMetricServiceCount> policyCountList) {
		this.policyCountList = policyCountList;
	}
	public long getTotalCount() {
		return totalCount;
	}
	public void setTotalCount(long totalCount) {
		this.totalCount = totalCount;
	}
	public String toString() {
		return ""VXMetricPolicyCount={
		totalCount=""+ totalCount +"", vXMetricServiceCount=[""+ policyCountList.toString() + ""]}
		"";
	}
}",0,0,0,0
"public void close() throws IOException {
	 pagedb.close();
 }
 public synchronized void close() throws IOException {
	 if (haveEdits) {
		 fs.mkdirs(newDbFile);
		 CloseProcessor pagesByURLProcessor = new PagesByURLProcessor(pagesByURL, pagesByURLWriter, pagesByMD5Writer);
		 long numPBUItems = pagesByURLProcessor.closeDown(tmp, newDbFile, pagesByURLEdits);
		 CloseProcessor pagesByMD5Processor = new PagesByMD5Processor(pagesByMD5, pagesByMD5Writer);
		 long numPBMItems = pagesByMD5Processor.closeDown(tmp, newDbFile, pagesByMD5Edits);
		 CloseProcessor linksByMD5Processor = new LinksByMD5Processor(linksByMD5, linksByMD5Writer, linksByURLWriter);
		 long numLBMItems = linksByMD5Processor.closeDown(tmp, newDbFile, linksByMD5Edits);
		 SequenceFile.Writer targetOutlinkEditsWriter = new SequenceFile.Writer(fs, new File(tmp, LINKS_BY_MD5 + "".out"").getPath(), LinkInstruction.class, NullWritable.class);
		 CloseProcessor linksByURLProcessor = new LinksByURLProcessor(linksByURL, linksByURLWriter, new MapFile.Reader(fs, new File(newDbFile, PAGES_BY_URL).getPath(), new UTF8.Comparator()), targetOutlinkEditsWriter);
		 long numLBUItems = linksByURLProcessor.closeDown(tmp, newDbFile, linksByURLEdits);
		 if (numLBUItems == 0) {
			 targetOutlinkEditsWriter.close();
			 File stats = new File(dbFile, STATS_FILE);
			 if (fs.exists(stats)) {
				 DataInputStream in = new DataInputStream(fs.open(stats));
				 try {
					 in.read();
					 in.readLong();
					 numLBMItems = in.readLong();
				 }
				 finally {
					 in.close();
				 }
			 }
		 }
		 else {
			 File stageTwoDbFile = new File(newDbFile, ""stage2.subdir"");
			 fs.mkdirs(stageTwoDbFile);
			 MapFile.Reader linksByMD5ForStageTwo = new MapFile.Reader(fs, new File(newDbFile, LINKS_BY_MD5).getPath(), new Link.MD5Comparator());
			 CloseProcessor linksByMD5StageTwoProcessor = new LinksByMD5Processor(linksByMD5ForStageTwo, targetOutlinkEditsWriter, null);
			 numLBMItems = linksByMD5StageTwoProcessor.closeDown(tmp, stageTwoDbFile, targetOutlinkEdits);
			 linksByMD5ForStageTwo.close();
			 File stageOneLinksByMD5 = new File(newDbFile, LINKS_BY_MD5);
			 fs.delete(stageOneLinksByMD5);
			 fs.rename(new File(stageTwoDbFile, LINKS_BY_MD5), stageOneLinksByMD5);
			 fs.delete(stageTwoDbFile);
		 }
		 File stats = new File(newDbFile, STATS_FILE);
		 DataOutputStream out = new DataOutputStream(fs.create(stats));
		 try {
			 out.write(CUR_VERSION);
			 out.writeLong(numPBUItems);
			 out.writeLong(numLBMItems);
		 }
		 finally {
			 out.close();
		 }
	 }
	 else {
		 pagesByURLWriter.close();
		 pagesByMD5Writer.close();
		 linksByMD5Writer.close();
		 linksByURLWriter.close();
	 }
	 pagesByURL.close();
	 pagesByMD5.close();
	 linksByMD5.close();
	 linksByURL.close();
	 fs.delete(tmp);
	 fs.lock(new File(dbDir, ""dbreadlock""), false);
	 if (haveEdits) {
		 fs.rename(dbFile, oldDbFile);
		 fs.rename(newDbFile, dbFile);
		 FileUtil.fullyDelete(fs, oldDbFile);
	 }
	 else {
		 FileUtil.fullyDelete(fs, newDbFile);
	 }
	 fs.release(new File(dbDir, ""dbreadlock""));
	 fs.release(new File(dbDir, ""dbwritelock""));
 }",0,0,1,0
"public class ActionData {
	 private String portal ;
	 private String page ;
	 private String requestType ;
	 private long handleTime ;
	 private String parameters ;
	 private String error ;
	 public ActionData(String portal, String page, String type, long time, Map params ) {
		 this.portal = portal ;
		 this.page = page ;
		 this.requestType = type ;
		 this.handleTime = time ;
		 Iterator i = params.entrySet().iterator() ;
		 StringBuffer b = new StringBuffer() ;
		 while(i.hasNext()) {
			 b.append(""{
				"") ;
				 Map.Entry entry = (Map.Entry) i.next() ;
				 Object obj = entry.getValue() ;
				 String key = (String)entry.getKey() ;
				 b.append(key).append(""="") ;
				 if(key.startsWith(""password"")) {
					 b.append(""**************"") ;
				 }
				 else {
					 if(obj instanceof String[]) {
						 String[] values = (String[]) obj ;
						 for(int j = 0;
						 j < values.length;
						 j++) {
							 if(j > 0) b.append("", "") ;
							 b.append(values[j]) ;
						 }
					 }
					 else {
						 b.append(obj) ;
					 }
				 }
			 b.append(""}
			 "") ;
		 }
		 this.parameters = b.toString() ;
	 }
	 public String getPortal() {
		 return portal ;
	 }
	 public String getPage() {
		 return page ;
	 }
	 public String getRequestType() {
		 return requestType ;
	 }
	 public long getHandleTime() {
		 return handleTime ;
	 }
	 public String getParameters() {
		 return parameters ;
	 }
	 public String getError() {
		 return error ;
	 }
	 public void setError(String error) {
		 this.error = error ;
	 }
}",0,1,0,0
"private void processIncluded(String name, File file, Vector inc, Vector exc, Vector des) {
	 if (inc.contains(name) || exc.contains(name) || des.contains(name)) {
		 return;
	 }
	 boolean included = false;
	 if (isExcluded(name)) {
		 exc.add(name);
	 }
	 else if (isSelected(name, file)) {
		 included = true;
		 inc.add(name);
	 }
	 else {
		 des.add(name);
	 }
	 everythingIncluded &= included;
 }",0,0,0,0
"public class DefaultCasDocumentProvider extends org.apache.uima.caseditor.editor.CasDocumentProvider {
	 private static final int READ_TIMEOUT = 30000;
	 private Map<Object, PreferenceStore> tsPreferenceStores = new HashMap<Object, PreferenceStore>();
	 private Map<String, IPreferenceStore> sessionPreferenceStores = new HashMap<String, IPreferenceStore>();
	 private static TypeSystemDescription createTypeSystemDescription(InputStream in) throws IOException {
		 XMLInputSource xmlTypeSystemSource = new XMLInputSource(in, new File(""""));
		 XMLParser xmlParser = UIMAFramework.getXMLParser();
		 TypeSystemDescription typeSystemDesciptor;
		 try {
			 typeSystemDesciptor = (TypeSystemDescription) xmlParser .parse(xmlTypeSystemSource);
			 typeSystemDesciptor.resolveImports();
		 }
		 catch (InvalidXMLException e) {
			 throw new IOException(e);
		 }
		 return typeSystemDesciptor;
	 }
	 private static CAS createEmptyCAS(TypeSystemDescription typeSystem) {
		 ResourceSpecifierFactory resourceSpecifierFactory = UIMAFramework .getResourceSpecifierFactory();
		 TypePriorities typePriorities = resourceSpecifierFactory .createTypePriorities();
		 FsIndexDescription indexDesciptor = new FsIndexDescription_impl();
		 indexDesciptor.setLabel(""TOPIndex"");
		 indexDesciptor.setTypeName(""uima.cas.TOP"");
		 indexDesciptor.setKind(FsIndexDescription.KIND_SORTED);
		 CAS cas;
		 try {
			 cas = CasCreationUtils.createCas(typeSystem, typePriorities, new FsIndexDescription[] {
			 indexDesciptor }
			);
		 }
		 catch (ResourceInitializationException e) {
			 e.printStackTrace();
			 cas = null;
		 }
		 return cas;
	 }
	 protected ICasDocument createDocument(Object element) throws CoreException {
		 if (element instanceof CorpusServerCasEditorInput) {
			 CorpusServerCasEditorInput casInput = (CorpusServerCasEditorInput) element;
			 Client client = Client.create();
			 client.setReadTimeout(READ_TIMEOUT);
			 WebResource webResource = client.resource(casInput.getServerUrl());
			 ClientResponse tsResponse = webResource .path(""_typesystem"") .accept(MediaType.TEXT_XML) .header(""Content-Type"", MediaType.TEXT_XML) .get(ClientResponse.class);
			 InputStream tsIn = tsResponse.getEntityInputStream();
			 TypeSystemDescription tsDesc = null;
			 try {
				 tsDesc = createTypeSystemDescription(tsIn);
			 }
			 catch (IOException e) {
				 e.printStackTrace();
			 }
			 finally {
				 try {
					 tsIn.close();
				 }
				 catch (IOException e) {
				 }
			 }
			 CAS cas = createEmptyCAS(tsDesc);
			 ClientResponse casResponse;
			 try {
				 casResponse = webResource .path(URLEncoder.encode(casInput.getName(), ""UTF-8"")) .accept(MediaType.TEXT_XML) .header(""Content-Type"", MediaType.TEXT_XML) .get(ClientResponse.class);
			 }
			 catch (UnsupportedEncodingException e) {
				 throw new RuntimeException(""Should never fail, UTF-8 encoding is available on every JRE!"", e);
			 }
			 InputStream casIn = casResponse.getEntityInputStream();
			 org.apache.uima.caseditor.editor.ICasDocument doc = null;
			 try {
				 doc = new DocumentUimaImpl(cas, casIn, DocumentFormat.XMI);
			 }
			 finally {
				 try {
					 casIn.close();
				 }
				 catch (IOException e) {
				 }
			 }
			 return doc;
		 }
		 return null;
	 }
	 protected void doSaveDocument(IProgressMonitor monitor, Object element, ICasDocument document, boolean overwrite) throws CoreException {
		 if (element instanceof CorpusServerCasEditorInput) {
			 CorpusServerCasEditorInput casInput = (CorpusServerCasEditorInput) element;
			 if (document instanceof DocumentUimaImpl) {
				 DocumentUimaImpl documentImpl = (DocumentUimaImpl) document;
				 ByteArrayOutputStream outStream = new ByteArrayOutputStream(40000);
				 documentImpl.serialize(outStream);
				 Client client = Client.create();
				 client.setReadTimeout(READ_TIMEOUT);
				 WebResource webResource = client.resource(casInput.getServerUrl());
				 byte xmiBytes[] = outStream.toByteArray();
				 String encodedCasId;
				 try {
					 encodedCasId = URLEncoder.encode(casInput.getName(), ""UTF-8"");
				 }
				 catch (UnsupportedEncodingException e) {
					 throw new CoreException(new Status(Status.ERROR, CorpusServerPlugin.PLUGIN_ID, ""Severe error, should never happen, UTF-8 encoding is not supported!""));
				 }
				 ClientResponse response = webResource .path(encodedCasId) .accept(MediaType.TEXT_XML) .header(""Content-Type"", MediaType.TEXT_XML) .put(ClientResponse.class, xmiBytes);
				 if (response.getStatus() != 204) {
					 throw new CoreException(new Status(Status.ERROR, CorpusServerPlugin.PLUGIN_ID, ""Failed to save document, http error code: "" + response.getStatus()));
				 }
			 }
		 }
		 fireElementDirtyStateChanged(element, false);
	 }
	 private String getTypeSystemId(CorpusServerCasEditorInput input) {
		 return input.getServerUrl();
	 }
	 public IPreferenceStore getSessionPreferenceStore(Object element) {
		 IPreferenceStore store = sessionPreferenceStores.get(getTypeSystemId((CorpusServerCasEditorInput) element));
		 if (store == null) {
			 store = new PreferenceStore();
			 sessionPreferenceStores.put(getTypeSystemId((CorpusServerCasEditorInput) element), store);
		 }
		 return store;
	 }
	 protected void disposeElementInfo(Object element, ElementInfo info) {
	 }
	 public Composite createTypeSystemSelectorForm(ICasEditor editor, Composite arg1, IStatus arg2) {
		 return null;
	 }
	 public IPreferenceStore getTypeSystemPreferenceStore(Object element) {
		 PreferenceStore tsStore = tsPreferenceStores.get(element);
		 if (tsStore == null) {
			 IPreferenceStore store = CorpusServerPlugin.getDefault().getPreferenceStore();
			 String tsStoreString = store.getString(getTypeSystemId((CorpusServerCasEditorInput) element));
			 tsStore = new PreferenceStore();
			 if (tsStoreString.length() != 0) {
				 InputStream tsStoreIn = new ByteArrayInputStream(tsStoreString.getBytes(Charset.forName(""UTF-8"")));
				 try {
					 tsStore.load(tsStoreIn);
				 }
				 catch (IOException e) {
					 e.printStackTrace();
				 }
			 }
			 tsPreferenceStores.put(element, tsStore);
		 }
		 return tsStore;
	 }
	 public void saveTypeSystemPreferenceStore(Object element) {
		 PreferenceStore tsStore = tsPreferenceStores.get(element);
		 if (tsStore != null) {
			 ByteArrayOutputStream tsStoreBytes = new ByteArrayOutputStream();
			 try {
				 tsStore.save(tsStoreBytes, """");
			 }
			 catch (IOException e) {
				 e.printStackTrace();
			 }
			 IPreferenceStore store = CorpusServerPlugin.getDefault().getPreferenceStore();
			 store.putValue(getTypeSystemId((CorpusServerCasEditorInput) element), new String(tsStoreBytes.toByteArray(), Charset.forName(""UTF-8"")));
		 }
	 }
}",1,0,0,0
"public class WordCount {
	 final static String STOP_WORDS_FILE = ""wc.stopwords.file"";
	 public static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable>{
		 Set<String> stopWords = new HashSet<String>();
		 protected void setup(Mapper.Context context){
			 Configuration conf = context.getConfiguration();
			 String stp_file_name = conf.get(STOP_WORDS_FILE);
			 if(stp_file_name == null) return;
			 File stp_file = new File(stp_file_name);
			 BufferedReader fis;
			 try {
				 fis = new BufferedReader(new FileReader(stp_file));
			 }
			 catch (FileNotFoundException e) {
				 e.printStackTrace();
				 throw new RuntimeException(""Could not open stopwords file "",e);
			 }
			 String word;
			 try {
				 while((word =fis.readLine()) != null){
					 stopWords.add(word);
				 }
			 }
			 catch (IOException e) {
				 e.printStackTrace();
				 throw new RuntimeException(""error while reading stopwords"",e);
			 }
		 }
		 private final static IntWritable one = new IntWritable(1);
		 private Text word = new Text();
		 public void map(Object key, Text value, Context context ) throws IOException, InterruptedException {
			 StringTokenizer itr = new StringTokenizer(value.toString());
			 while (itr.hasMoreTokens()) {
				 word.set(itr.nextToken());
				 if(stopWords.contains(word.toString())){
					 continue;
				 }
				 context.write(word, one);
			 }
		 }
	 }
	 public static class IntSumReducer extends Reducer<Text,IntWritable,Text,IntWritable> {
		 private IntWritable result = new IntWritable();
		 public void reduce(Text key, Iterable<IntWritable> values, Context context ) throws IOException, InterruptedException {
			 int sum = 0;
			 for (IntWritable val : values) {
				 sum += val.get();
			 }
			 result.set(sum);
			 context.write(key, result);
		 }
	 }
	 public static void main(String[] args) throws Exception {
		 Configuration conf = new Configuration();
		 String[] otherArgs = new GenericOptionsParser(conf, args).getRemainingArgs();
		 if (otherArgs.length < 2) {
			 System.err.println(""Usage: wordcount <in> <out> [wordcount stop word file]"");
			 System.exit(2);
		 }
		 Job job = new Job(conf, ""word count"");
		 job.setJarByClass(WordCount.class);
		 job.setMapperClass(TokenizerMapper.class);
		 job.setCombinerClass(IntSumReducer.class);
		 job.setReducerClass(IntSumReducer.class);
		 job.setOutputKeyClass(Text.class);
		 job.setOutputValueClass(IntWritable.class);
		 FileInputFormat.addInputPath(job, new Path(otherArgs[0]));
		 FileOutputFormat.setOutputPath(job, new Path(otherArgs[1]));
		 if(otherArgs.length > 2){
			 job.getConfiguration().set(STOP_WORDS_FILE, otherArgs[2]);
		 }
		 System.exit(job.waitForCompletion(true) ? 0 : 1);
	 }
}",1,0,0,0
"public class UserUpdateBean{
	 private String name;
	 private String surname;
	 private int age;
	 private String userName;
	 private String password;
	 private UserController controller;
	 private SessionTracker tracker;
	 public UserUpdateBean() {
	 }
	 public String showInfo() {
		 User user = this.controller.getUser(tracker.getUser().getId());
		 setName(user.getName());
		 setSurname(user.getSurname());
		 setAge(user.getAge());
		 setUserName(user.getUserName());
		 setPassword(user.getPassword());
		 return ""toUpdatePage"";
	 }
	 public String clear() {
		 setName("""");
		 setSurname("""");
		 setAge(0);
		 setUserName("""");
		 setPassword("""");
		 return null;
	 }
	 public String update() {
		 this.controller.updateUserInfo(tracker.getUser().getId(), name, surname, age, userName, password);
		 JSFUtility.addInfoMessage(""Personal information is succesfully updated."", """");
		 return null;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getSurname() {
		 return surname;
	 }
	 public void setSurname(String surname) {
		 this.surname = surname;
	 }
	 public int getAge() {
		 return age;
	 }
	 public void setAge(int age) {
		 this.age = age;
	 }
	 public String getUserName() {
		 return userName;
	 }
	 public void setUserName(String userName) {
		 this.userName = userName;
	 }
	 public String getPassword() {
		 return password;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
}",0,1,0,0
"public void write(NutchDocument doc) throws IOException {
	 final SolrInputDocument inputDoc = new SolrInputDocument();
	 for(final Entry<String, NutchField> e : doc) {
		 for (final Object val : e.getValue().getValues()) {
			 Object val2 = val;
			 if (val instanceof Date){
				 val2 = DateUtil.getThreadLocalDateFormat().format(val);
			 }
			 if (e.getKey().equals(""content"")) {
				 val2 = SolrUtils.stripNonCharCodepoints((String)val);
			 }
			 inputDoc.addField(solrMapping.mapKey(e.getKey()), val2, e.getValue().getWeight());
			 String sCopy = solrMapping.mapCopyKey(e.getKey());
			 if (sCopy != e.getKey()) {
				 inputDoc.addField(sCopy, val);
			 }
		 }
	 }
	 inputDoc.setDocumentBoost(doc.getWeight());
	 inputDocs.add(inputDoc);
	 if (inputDocs.size() >= commitSize) {
		 try {
			 LOG.info(""Adding "" + Integer.toString(inputDocs.size()) + "" documents"");
			 solr.add(inputDocs);
		 }
		 catch (final SolrServerException e) {
			 throw makeIOException(e);
		 }
		 inputDocs.clear();
	 }
 }",0,0,0,0
"public class NativeArray extends IdScriptableObject{
	 static final long serialVersionUID = 7331366857676127338L;
	 private static final Object ARRAY_TAG = new Object();
	 static void init(Scriptable scope, boolean sealed) {
		 NativeArray obj = new NativeArray();
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeArray() {
		 dense = null;
		 this.length = 0;
	 }
	 public NativeArray(long length) {
		 int intLength = (int) length;
		 if (intLength == length && intLength > 0) {
			 if (intLength > maximumDenseLength) intLength = maximumDenseLength;
			 dense = new Object[intLength];
			 for (int i=0;
			 i < intLength;
			 i++) dense[i] = NOT_FOUND;
		 }
		 this.length = length;
	 }
	 public NativeArray(Object[] array) {
		 dense = array;
		 this.length = array.length;
	 }
	 public String getClassName() {
		 return ""Array"";
	 }
	 private static final int Id_length = 1, MAX_INSTANCE_ID = 1;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 if (s.equals(""length"")) {
			 return instanceIdInfo(DONTENUM | PERMANENT, Id_length);
		 }
		 return super.findInstanceIdInfo(s);
	 }
	 protected String getInstanceIdName(int id) {
		 if (id == Id_length) {
			 return ""length"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 if (id == Id_length) {
			 return ScriptRuntime.wrapNumber(length);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_length) {
			 setLength(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toLocaleString: arity=1;
			 s=""toLocaleString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_join: arity=1;
			 s=""join"";
			 break;
			 case Id_reverse: arity=0;
			 s=""reverse"";
			 break;
			 case Id_sort: arity=1;
			 s=""sort"";
			 break;
			 case Id_push: arity=1;
			 s=""push"";
			 break;
			 case Id_pop: arity=1;
			 s=""pop"";
			 break;
			 case Id_shift: arity=1;
			 s=""shift"";
			 break;
			 case Id_unshift: arity=1;
			 s=""unshift"";
			 break;
			 case Id_splice: arity=1;
			 s=""splice"";
			 break;
			 case Id_concat: arity=1;
			 s=""concat"";
			 break;
			 case Id_slice: arity=1;
			 s=""slice"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(ARRAY_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(ARRAY_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: {
				 boolean inNewExpr = (thisObj == null);
				 if (!inNewExpr) {
					 return f.construct(cx, scope, args);
				 }
				 return jsConstructor(cx, scope, args);
			 }
			 case Id_toString: return toStringHelper(cx, scope, thisObj, cx.hasFeature(Context.FEATURE_TO_STRING_AS_SOURCE), false);
			 case Id_toLocaleString: return toStringHelper(cx, scope, thisObj, false, true);
			 case Id_toSource: return toStringHelper(cx, scope, thisObj, true, false);
			 case Id_join: return js_join(cx, thisObj, args);
			 case Id_reverse: return js_reverse(cx, thisObj, args);
			 case Id_sort: return js_sort(cx, scope, thisObj, args);
			 case Id_push: return js_push(cx, thisObj, args);
			 case Id_pop: return js_pop(cx, thisObj, args);
			 case Id_shift: return js_shift(cx, thisObj, args);
			 case Id_unshift: return js_unshift(cx, thisObj, args);
			 case Id_splice: return js_splice(cx, scope, thisObj, args);
			 case Id_concat: return js_concat(cx, scope, thisObj, args);
			 case Id_slice: return js_slice(cx, thisObj, args);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 public Object get(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index];
		 return super.get(index, start);
	 }
	 public boolean has(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index] != NOT_FOUND;
		 return super.has(index, start);
	 }
	 private static long toArrayIndex(String id) {
		 double d = ScriptRuntime.toNumber(id);
		 if (d == d) {
			 long index = ScriptRuntime.toUint32(d);
			 if (index == d && index != 4294967295L) {
				 if (Long.toString(index).equals(id)) {
					 return index;
				 }
			 }
		 }
		 return -1;
	 }
	 public void put(String id, Scriptable start, Object value) {
		 super.put(id, start, value);
		 if (start == this) {
			 long index = toArrayIndex(id);
			 if (index >= length) {
				 length = index + 1;
			 }
		 }
	 }
	 public void put(int index, Scriptable start, Object value) {
		 if (start == this && !isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = value;
		 }
		 else {
			 super.put(index, start, value);
		 }
		 if (start == this) {
			 if (this.length <= index) {
				 this.length = (long)index + 1;
			 }
		 }
	 }
	 public void delete(int index) {
		 if (!isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = NOT_FOUND;
		 }
		 else {
			 super.delete(index);
		 }
	 }
	 public Object[] getIds() {
		 Object[] superIds = super.getIds();
		 if (dense == null) {
			 return superIds;
		 }
		 int N = dense.length;
		 long currentLength = length;
		 if (N > currentLength) {
			 N = (int)currentLength;
		 }
		 if (N == 0) {
			 return superIds;
		 }
		 int superLength = superIds.length;
		 Object[] ids = new Object[N + superLength];
		 System.arraycopy(dense, 0, ids, 0, N);
		 int presentCount = 0;
		 for (int i = 0;
		 i != N;
		 ++i) {
			 if (ids[i] != NOT_FOUND) {
				 ids[presentCount] = new Integer(i);
				 ++presentCount;
			 }
		 }
		 if (presentCount != N) {
			 Object[] tmp = new Object[presentCount + superLength];
			 System.arraycopy(ids, 0, tmp, 0, presentCount);
			 ids = tmp;
		 }
		 System.arraycopy(superIds, 0, ids, presentCount, superLength);
		 return ids;
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == ScriptRuntime.NumberClass) {
			 Context cx = Context.getContext();
			 if (cx.getLanguageVersion() == Context.VERSION_1_2) return new Long(length);
		 }
		 return super.getDefaultValue(hint);
	 }
	 private static Object jsConstructor(Context cx, Scriptable scope, Object[] args) {
		 if (args.length == 0) return new NativeArray();
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 return new NativeArray(args);
		 }
		 else {
			 Object arg0 = args[0];
			 if (args.length > 1 || !(arg0 instanceof Number)) {
				 return new NativeArray(args);
			 }
			 else {
				 long len = ScriptRuntime.toUint32(arg0);
				 if (len != ((Number)arg0).doubleValue()) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
				 return new NativeArray(len);
			 }
		 }
	 }
	 public long getLength() {
		 return length;
	 }
	 public long jsGet_length() {
		 return getLength();
	 }
	 private void setLength(Object val) {
		 double d = ScriptRuntime.toNumber(val);
		 long longVal = ScriptRuntime.toUint32(d);
		 if (longVal != d) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
		 if (longVal < length) {
			 if (length - longVal > 0x1000) {
				 Object[] e = getIds();
				 for (int i=0;
				 i < e.length;
				 i++) {
					 Object id = e[i];
					 if (id instanceof String) {
						 String strId = (String)id;
						 long index = toArrayIndex(strId);
						 if (index >= longVal) delete(strId);
					 }
					 else {
						 int index = ((Integer)id).intValue();
						 if (index >= longVal) delete(index);
					 }
				 }
			 }
			 else {
				 for (long i = longVal;
				 i < length;
				 i++) {
					 deleteElem(this, i);
				 }
			 }
		 }
		 length = longVal;
	 }
	 static long getLengthProperty(Context cx, Scriptable obj) {
		 if (obj instanceof NativeString) {
			 return ((NativeString)obj).getLength();
		 }
		 else if (obj instanceof NativeArray) {
			 return ((NativeArray)obj).getLength();
		 }
		 else if (!(obj instanceof Scriptable)) {
			 return 0;
		 }
		 return ScriptRuntime.toUint32( ScriptRuntime.getObjectProp(obj, ""length"", cx));
	 }
	 private static Object setLengthProperty(Context cx, Scriptable target, long length) {
		 return ScriptRuntime.setObjectProp( target, ""length"", ScriptRuntime.wrapNumber(length), cx);
	 }
	 private static void deleteElem(Scriptable target, long index) {
		 int i = (int)index;
		 if (i == index) {
			 target.delete(i);
		 }
		 else {
			 target.delete(Long.toString(index));
		 }
	 }
	 private static Object getElem(Context cx, Scriptable target, long index) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 return ScriptRuntime.getObjectProp(target, id, cx);
		 }
		 else {
			 return ScriptRuntime.getObjectIndex(target, (int)index, cx);
		 }
	 }
	 private static void setElem(Context cx, Scriptable target, long index, Object value) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 ScriptRuntime.setObjectProp(target, id, value, cx);
		 }
		 else {
			 ScriptRuntime.setObjectIndex(target, (int)index, value, cx);
		 }
	 }
	 private static String toStringHelper(Context cx, Scriptable scope, Scriptable thisObj, boolean toSource, boolean toLocale) {
		 long length = getLengthProperty(cx, thisObj);
		 StringBuffer result = new StringBuffer(256);
		 String separator;
		 if (toSource) {
			 result.append('[');
			 separator = "", "";
		 }
		 else {
			 separator = "","";
		 }
		 boolean haslast = false;
		 long i = 0;
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 try {
			 if (!iterating) {
				 cx.iterating.put(thisObj, 0);
				 for (i = 0;
				 i < length;
				 i++) {
					 if (i > 0) result.append(separator);
					 Object elem = getElem(cx, thisObj, i);
					 if (elem == null || elem == Undefined.instance) {
						 haslast = false;
						 continue;
					 }
					 haslast = true;
					 if (toSource) {
						 result.append(ScriptRuntime.uneval(cx, scope, elem));
					 }
					 else if (elem instanceof String) {
						 String s = (String)elem;
						 if (toSource) {
							 result.append('\""');
							 result.append(ScriptRuntime.escapeString(s));
							 result.append('\""');
						 }
						 else {
							 result.append(s);
						 }
					 }
					 else {
						 if (toLocale && elem != Undefined.instance && elem != null) {
							 Callable fun;
							 Scriptable funThis;
							 fun = ScriptRuntime.getPropFunctionAndThis( elem, ""toLocaleString"", cx);
							 funThis = ScriptRuntime.lastStoredScriptable(cx);
							 elem = fun.call(cx, scope, funThis, ScriptRuntime.emptyArgs);
						 }
						 result.append(ScriptRuntime.toString(elem));
					 }
				 }
			 }
		 }
		 finally {
			 if (toplevel) {
				 cx.iterating = null;
			 }
		 }
		 if (toSource) {
			 if (!haslast && i > 0) result.append("", ]"");
			 else result.append(']');
		 }
		 return result.toString();
	 }
	 private static String js_join(Context cx, Scriptable thisObj, Object[] args) {
		 String separator;
		 long llength = getLengthProperty(cx, thisObj);
		 int length = (int)llength;
		 if (llength != length) {
			 throw Context.reportRuntimeError1( ""msg.arraylength.too.big"", String.valueOf(llength));
		 }
		 if (args.length < 1 || args[0] == Undefined.instance) {
			 separator = "","";
		 }
		 else {
			 separator = ScriptRuntime.toString(args[0]);
		 }
		 if (length == 0) {
			 return """";
		 }
		 String[] buf = new String[length];
		 int total_size = 0;
		 for (int i = 0;
		 i != length;
		 i++) {
			 Object temp = getElem(cx, thisObj, i);
			 if (temp != null && temp != Undefined.instance) {
				 String str = ScriptRuntime.toString(temp);
				 total_size += str.length();
				 buf[i] = str;
			 }
		 }
		 total_size += (length - 1) * separator.length();
		 StringBuffer sb = new StringBuffer(total_size);
		 for (int i = 0;
		 i != length;
		 i++) {
			 if (i != 0) {
				 sb.append(separator);
			 }
			 String str = buf[i];
			 if (str != null) {
				 sb.append(str);
			 }
		 }
		 return sb.toString();
	 }
	 private static Scriptable js_reverse(Context cx, Scriptable thisObj, Object[] args) {
		 long len = getLengthProperty(cx, thisObj);
		 long half = len / 2;
		 for(long i=0;
		 i < half;
		 i++) {
			 long j = len - i - 1;
			 Object temp1 = getElem(cx, thisObj, i);
			 Object temp2 = getElem(cx, thisObj, j);
			 setElem(cx, thisObj, i, temp2);
			 setElem(cx, thisObj, j, temp1);
		 }
		 return thisObj;
	 }
	 private static Scriptable js_sort(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 if (length <= 1) {
			 return thisObj;
		 }
		 Object compare;
		 Object[] cmpBuf;
		 if (args.length > 0 && Undefined.instance != args[0]) {
			 compare = args[0];
			 cmpBuf = new Object[2];
		 }
		 else {
			 compare = null;
			 cmpBuf = null;
		 }
		 if (length >= Integer.MAX_VALUE) {
			 heapsort_extended(cx, scope, thisObj, length, compare, cmpBuf);
		 }
		 else {
			 int ilength = (int)length;
			 Object[] working = new Object[ilength];
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 working[i] = getElem(cx, thisObj, i);
			 }
			 heapsort(cx, scope, working, ilength, compare, cmpBuf);
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 setElem(cx, thisObj, i, working[i]);
			 }
		 }
		 return thisObj;
	 }
	 private static boolean isBigger(Context cx, Scriptable scope, Object x, Object y, Object cmp, Object[] cmpBuf) {
		 if (cmp == null) {
			 if (cmpBuf != null) Kit.codeBug();
		 }
		 else {
			 if (cmpBuf == null || cmpBuf.length != 2) Kit.codeBug();
		 }
		 Object undef = Undefined.instance;
		 if (undef == y) {
			 return false;
		 }
		 else if (undef == x) {
			 return true;
		 }
		 if (cmp == null) {
			 String a = ScriptRuntime.toString(x);
			 String b = ScriptRuntime.toString(y);
			 return a.compareTo(b) > 0;
		 }
		 else {
			 cmpBuf[0] = x;
			 cmpBuf[1] = y;
			 Callable fun = ScriptRuntime.getValueFunctionAndThis(cmp, cx);
			 Scriptable funThis = ScriptRuntime.lastStoredScriptable(cx);
			 Object ret = fun.call(cx, scope, funThis, cmpBuf);
			 double d = ScriptRuntime.toNumber(ret);
			 return d > 0;
		 }
	 }
	 private static void heapsort(Context cx, Scriptable scope, Object[] array, int length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (int i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = array[i];
			 heapify(cx, scope, pivot, array, i, length, cmp, cmpBuf);
		 }
		 for (int i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = array[i];
			 array[i] = array[0];
			 heapify(cx, scope, pivot, array, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify(Context cx, Scriptable scope, Object pivot, Object[] array, int i, int end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 int child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = array[child];
			 if (child + 1 < end) {
				 Object nextVal = array[child + 1];
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 array[i] = childVal;
			 i = child;
		 }
		 array[i] = pivot;
	 }
	 private static void heapsort_extended(Context cx, Scriptable scope, Scriptable target, long length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (long i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 heapify_extended(cx, scope, pivot, target, i, length, cmp, cmpBuf);
		 }
		 for (long i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 setElem(cx, target, i, getElem(cx, target, 0));
			 heapify_extended(cx, scope, pivot, target, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify_extended(Context cx, Scriptable scope, Object pivot, Scriptable target, long i, long end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 long child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = getElem(cx, target, child);
			 if (child + 1 < end) {
				 Object nextVal = getElem(cx, target, child + 1);
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 setElem(cx, target, i, childVal);
			 i = child;
		 }
		 setElem(cx, target, i, pivot);
	 }
	 private static Object js_push(Context cx, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 setElem(cx, thisObj, length + i, args[i]);
		 }
		 length += args.length;
		 Object lengthObj = setLengthProperty(cx, thisObj, length);
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) return args.length == 0 ? Undefined.instance : args[args.length - 1];
		 else return lengthObj;
	 }
	 private static Object js_pop(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 length--;
			 result = getElem(cx, thisObj, length);
		 }
		 else {
			 result = Undefined.instance;
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_shift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 long i = 0;
			 length--;
			 result = getElem(cx, thisObj, i);
			 if (length > 0) {
				 for (i = 1;
				 i <= length;
				 i++) {
					 Object temp = getElem(cx, thisObj, i);
					 setElem(cx, thisObj, i - 1, temp);
				 }
			 }
		 }
		 else {
			 result = Undefined.instance;
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_unshift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 int argc = args.length;
		 if (args.length > 0) {
			 if (length > 0) {
				 for (long last = length - 1;
				 last >= 0;
				 last--) {
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, thisObj, last + argc, temp);
				 }
			 }
			 for (int i = 0;
			 i < args.length;
			 i++) {
				 setElem(cx, thisObj, i, args[i]);
			 }
			 length += args.length;
			 return setLengthProperty(cx, thisObj, length);
		 }
		 return ScriptRuntime.wrapNumber(length);
	 }
	 private static Object js_splice(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Object result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 int argc = args.length;
		 if (argc == 0) return result;
		 long length = getLengthProperty(cx, thisObj);
		 long begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
		 argc--;
		 long count;
		 if (args.length == 1) {
			 count = length - begin;
		 }
		 else {
			 double dcount = ScriptRuntime.toInteger(args[1]);
			 if (dcount < 0) {
				 count = 0;
			 }
			 else if (dcount > (length - begin)) {
				 count = length - begin;
			 }
			 else {
				 count = (long)dcount;
			 }
			 argc--;
		 }
		 long end = begin + count;
		 if (count != 0) {
			 if (count == 1 && (cx.getLanguageVersion() == Context.VERSION_1_2)) {
				 result = getElem(cx, thisObj, begin);
			 }
			 else {
				 for (long last = begin;
				 last != end;
				 last++) {
					 Scriptable resultArray = (Scriptable)result;
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, resultArray, last - begin, temp);
				 }
			 }
		 }
		 else if (count == 0 && cx.getLanguageVersion() == Context.VERSION_1_2) {
			 result = Undefined.instance;
		 }
		 long delta = argc - count;
		 if (delta > 0) {
			 for (long last = length - 1;
			 last >= end;
			 last--) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 else if (delta < 0) {
			 for (long last = end;
			 last < length;
			 last++) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 int argoffset = args.length - argc;
		 for (int i = 0;
		 i < argc;
		 i++) {
			 setElem(cx, thisObj, begin + i, args[i + argoffset]);
		 }
		 setLengthProperty(cx, thisObj, length + delta);
		 return result;
	 }
	 private static Scriptable js_concat(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(cx, scope, ""Array"");
		 Scriptable result = ctor.construct(cx, scope, ScriptRuntime.emptyArgs);
		 long length;
		 long slot = 0;
		 if (ScriptRuntime.instanceOf(thisObj, ctor, cx)) {
			 length = getLengthProperty(cx, thisObj);
			 for (slot = 0;
			 slot < length;
			 slot++) {
				 Object temp = getElem(cx, thisObj, slot);
				 setElem(cx, result, slot, temp);
			 }
		 }
		 else {
			 setElem(cx, result, slot++, thisObj);
		 }
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (ScriptRuntime.instanceOf(args[i], ctor, cx)) {
				 Scriptable arg = (Scriptable)args[i];
				 length = getLengthProperty(cx, arg);
				 for (long j = 0;
				 j < length;
				 j++, slot++) {
					 Object temp = getElem(cx, arg, j);
					 setElem(cx, result, slot, temp);
				 }
			 }
			 else {
				 setElem(cx, result, slot++, args[i]);
			 }
		 }
		 return result;
	 }
	 private Scriptable js_slice(Context cx, Scriptable thisObj, Object[] args) {
		 Scriptable scope = getTopLevelScope(this);
		 Scriptable result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 long length = getLengthProperty(cx, thisObj);
		 long begin, end;
		 if (args.length == 0) {
			 begin = 0;
			 end = length;
		 }
		 else {
			 begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
			 if (args.length == 1) {
				 end = length;
			 }
			 else {
				 end = toSliceIndex(ScriptRuntime.toInteger(args[1]), length);
			 }
		 }
		 for (long slot = begin;
		 slot < end;
		 slot++) {
			 Object temp = getElem(cx, thisObj, slot);
			 setElem(cx, result, slot - begin, temp);
		 }
		 return result;
	 }
	 private static long toSliceIndex(double value, long length) {
		 long result;
		 if (value < 0.0) {
			 if (value + length < 0.0) {
				 result = 0;
			 }
			 else {
				 result = (long)(value + length);
			 }
		 }
		 else if (value > length) {
			 result = length;
		 }
		 else {
			 result = (long)value;
		 }
		 return result;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 3: X=""pop"";
				id=Id_pop;
				 break L;
				 case 4: c=s.charAt(0);
				 if (c=='j') {
					 X=""join"";
					id=Id_join;
				 }
				 else if (c=='p') {
					 X=""push"";
					id=Id_push;
				 }
				 else if (c=='s') {
					 X=""sort"";
					id=Id_sort;
				 }
				 break L;
				 case 5: c=s.charAt(1);
				 if (c=='h') {
					 X=""shift"";
					id=Id_shift;
				 }
				 else if (c=='l') {
					 X=""slice"";
					id=Id_slice;
				 }
				 break L;
				 case 6: c=s.charAt(0);
				 if (c=='c') {
					 X=""concat"";
					id=Id_concat;
				 }
				 else if (c=='s') {
					 X=""splice"";
					id=Id_splice;
				 }
				 break L;
				 case 7: c=s.charAt(0);
				 if (c=='r') {
					 X=""reverse"";
					id=Id_reverse;
				 }
				 else if (c=='u') {
					 X=""unshift"";
					id=Id_unshift;
				 }
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
				 case 11: X=""constructor"";
				id=Id_constructor;
				 break L;
				 case 14: X=""toLocaleString"";
				id=Id_toLocaleString;
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toLocaleString = 3, Id_toSource = 4, Id_join = 5, Id_reverse = 6, Id_sort = 7, Id_push = 8, Id_pop = 9, Id_shift = 10, Id_unshift = 11, Id_splice = 12, Id_concat = 13, Id_slice = 14, MAX_PROTOTYPE_ID = 14;
	 private long length;
	 private Object[] dense;
	 private static final int maximumDenseLength = 10000;
}",1,0,0,0
"public class Image extends WebComponent implements IResourceListener{
	private static final long serialVersionUID = 1L;
	private final LocalizedImageResource localizedImageResource = new LocalizedImageResource(this);
	public Image(final String id){
		super(id);
	}
	public Image(final String id, final ResourceReference resourceReference){
		this(id, resourceReference, null);
	}
	public Image(final String id, final ResourceReference resourceReference,ValueMap resourceParameters){
		super(id);
		setImageResourceReference(resourceReference, resourceParameters);
	}
	public Image(final String id, final Resource imageResource){
		super(id);
		setImageResource(imageResource);
	}
	public Image(final String id, final IModel<?> model){
		super(id, model);
	}
	public Image(final String id, final String string){
		this(id, new Model<String>(string));
	}
	public void onResourceRequested(){
		localizedImageResource.onResourceRequested();
	}
	public void setImageResource(final Resource imageResource){
		localizedImageResource.setResource(imageResource);
	}
	public void setImageResourceReference(final ResourceReference resourceReference){
		localizedImageResource.setResourceReference(resourceReference);
	}
	public void setImageResourceReference(final ResourceReference resourceReference,final ValueMap parameters){
		localizedImageResource.setResourceReference(resourceReference, parameters);
	}
	public Component setDefaultModel(IModel<?> model){
		localizedImageResource.setResourceReference(null);
		localizedImageResource.setResource(null);
		return super.setDefaultModel(model);
	}
	protected Resource getImageResource(){
		return localizedImageResource.getResource();
	}
	protected ResourceReference getImageResourceReference(){
		return localizedImageResource.getResourceReference();
	}
	protected IModel<?> initModel(){
		return null;
	}
	protected void onComponentTag(final ComponentTag tag){
		checkComponentTag(tag, ""img"");
		super.onComponentTag(tag);
		final Resource resource = getImageResource();
		if (resource != null){
			localizedImageResource.setResource(resource);
		}
		final ResourceReference resourceReference = getImageResourceReference();
		if (resourceReference != null){
			localizedImageResource.setResourceReference(resourceReference);
		}
		localizedImageResource.setSrcAttribute(tag);
	}
	protected boolean getStatelessHint(){
		return (getImageResource() == null || getImageResource() == localizedImageResource.getResource()) &&localizedImageResource.isStateless();
	}
	protected void onComponentTagBody(final MarkupStream markupStream, final ComponentTag openTag){
	}
}",0,0,0,0
"private class BDMVSAXHandler extends DefaultHandler{
	private String current_tag;
	private StringBuffer buff = new StringBuffer();
	private boolean insideTitle;
	private boolean insideDescription;
	private int maxThumbSize = -1;
	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException{
		if (""di:title"".equalsIgnoreCase(qName)){
			insideTitle = true;
		}
		else if (""di:description"".equalsIgnoreCase(qName)){
			insideDescription = true;
		}
		else if (insideDescription && ""di:thumbnail"".equals(qName)){
			String thumbStr = attributes.getValue(""href"");
			String sizeStr = attributes.getValue(""size"");
			if (thumbStr != null && sizeStr != null){
				int xidx = sizeStr.indexOf('x');
				if (xidx != -1){
					int currSize = 0;
					try{
						currSize = Integer.parseInt(sizeStr.substring(0, xidx)) * Integer.parseInt(sizeStr.substring(xidx + 1));
					}
					catch (NumberFormatException nfe){
						if (sage.Sage.DBG) System.out.println(""ERROR could not extract BDMV thumbnail size of :"" + nfe + "" from "" + sizeStr);
					}
					if (currSize > maxThumbSize){
						metaThumbnail = new java.io.File(new java.io.File(bdmvDir, ""META"" + java.io.File.separator + ""DL""), thumbStr).getAbsolutePath();
					}
				}
			}
		}
		current_tag = qName;
	}
	public void characters(char[] ch, int start, int length){
		String data = new String(ch,start,length);
		if (data.trim().length() == 0)return;
		buff.append(data);
	}
	public void endElement(String uri, String localName, String qName){
		String data = buff.toString().trim();
		if (qName.equals(current_tag))buff = new StringBuffer();
		if (""di:title"".equals(qName))insideTitle = false;
		else if (""di:description"".equals(qName))insideDescription = false;
		else if (insideTitle && ""di:name"".equals(qName)){
			metaTitle = data;
		}
	}
}",1,0,0,0
"public Map< String, String > listLanguages(PageContext pageContext) {
	 Map< String, String > resultMap = new LinkedHashMap<>();
	 String clientLanguage = ((HttpServletRequest) pageContext.getRequest()).getLocale().toString();
	 List< String > entries = ClassUtil.classpathEntriesUnder( DIRECTORY );
	 for( String name : entries ) {
		 if ( name.equals( I18NRESOURCE_EN ) || (name.startsWith( I18NRESOURCE_PREFIX ) && name.endsWith( I18NRESOURCE_SUFFIX ) ) ) {
			 if (name.equals( I18NRESOURCE_EN )) {
				 name = I18NRESOURCE_EN_ID;
			 }
			 else {
				 name = name.substring(I18NRESOURCE_PREFIX.length(), name.lastIndexOf(I18NRESOURCE_SUFFIX));
			 }
			 Locale locale = new Locale(name.substring(0, 2), ((name.indexOf(""_"") == -1) ? """" : name.substring(3, 5)));
			 String defaultLanguage = """";
			 if (clientLanguage.startsWith(name)) {
				 defaultLanguage = LocaleSupport.getLocalizedMessage(pageContext, I18NDEFAULT_LOCALE);
			 }
			 resultMap.put(name, locale.getDisplayName(locale) + "" "" + defaultLanguage);
		 }
	 }
	 return resultMap;
 }",0,0,1,0
"private void initComponents(){
	m_popupMenu = new javax.swing.JPopupMenu();
	m_menuAddItem = new javax.swing.JMenuItem();
	m_menuRemoveItem = new javax.swing.JMenuItem();
	jScrollPane1 = new javax.swing.JScrollPane();
	m_table = new javax.swing.JTable();
	m_menuAddItem.setText(""Add item"");
	m_menuAddItem.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			m_menuAddItemActionPerformed(evt);
		}
	}
	);
	m_popupMenu.add(m_menuAddItem);
	m_menuRemoveItem.setText(""RemoveItems"");
	m_menuRemoveItem.addActionListener(new java.awt.event.ActionListener(){
		public void actionPerformed(java.awt.event.ActionEvent evt){
			m_menuRemoveItemActionPerformed(evt);
		}
	}
	);
	m_popupMenu.add(m_menuRemoveItem);
	setLayout(new java.awt.BorderLayout());
	jScrollPane1.setBorder(null);
	m_table.setModel(new javax.swing.table.DefaultTableModel(new Object [][]{
		{
		null, null, null, null}
		,{
		null, null, null, null}
		,{
		null, null, null, null}
		,{
		null, null, null, null}
	}
	,new String []{
	""Title 1"", ""Title 2"", ""Title 3"", ""Title 4""}
	));
	m_table.setTableHeader(null);
	m_table.addMouseListener(new java.awt.event.MouseAdapter(){
		public void mouseClicked(java.awt.event.MouseEvent evt){
			tableMousePressed(evt);
		}
		public void mousePressed(java.awt.event.MouseEvent evt){
			tableMousePressed(evt);
		}
		public void mouseReleased(java.awt.event.MouseEvent evt){
			tableMousePressed(evt);
		}
	}
	);
	jScrollPane1.setViewportView(m_table);
	add(jScrollPane1, java.awt.BorderLayout.CENTER);
}",0,0,1,0
"public Sampler deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {
	 JsonNode node = jp.getCodec().readTree(jp);
	 String type = node.get(""type"").asText();
	 switch (type) {
		 case ""uniform"": {
			 double lowerBound = node.get(""lower"").asDouble();
			 double upperBound = node.get(""upper"").asDouble();
			 checkArgument( lowerBound >= 0, ""The lower bound of uniform distribution should be a non-negative number, "" + ""but found %s."", lowerBound);
			 return fromRealDistribution(new UniformRealDistribution(lowerBound, upperBound));
		 }
		 case ""exp"": {
			 double mean = node.get(""mean"").asDouble();
			 return fromRealDistribution(new ExponentialDistribution(mean));
		 }
		 case ""normal"": {
			 double mean = node.get(""mean"").asDouble();
			 double stddev = node.get(""stddev"").asDouble();
			 checkArgument( mean >= 0, ""The mean of normal distribution should be a non-negative number, but found %s."", mean);
			 return fromRealDistribution(new NormalDistribution(mean, stddev));
		 }
		 case ""const"": {
			 double constant = node.get(""const"").asDouble();
			 checkArgument( constant >= 0, ""The value of constant distribution should be a non-negative number, but found %s."", constant);
			 return fromRealDistribution(new ConstantRealDistribution(constant));
		 }
		 case ""zipf"": {
			 double param = node.get(""param"").asDouble();
			 final double multiplier = node.has(""multiplier"") ? node.get(""multiplier"").asDouble() : 1.0;
			 checkArgument( param > 1, ""The parameter of the Zipf distribution should be > 1, but found %s."", param);
			 checkArgument( multiplier >= 0, ""The multiplier of the Zipf distribution should be >= 0, but found %s."", multiplier);
			 final ZipfDistribution dist = new ZipfDistribution(100, param);
			 return scaledSampler(fromIntegerDistribution(dist), multiplier);
		 }
		 default: {
			 throw new IllegalArgumentException(""Unknown distribution type: "" + type);
		 }
	 }
 }",0,0,1,0
"public String getClasspathId() {
	 return getDelegate().getClassLoadId();
 }",0,0,0,0
"public void completeRound(File distDir, File scoreFile) throws IOException {
	 int numProcesses = 0;
	 long totalPages = 0;
	 long extent[] = null;
	 File overall = new File(distDir, ""assignComplete"");
	 DataInputStream in = new DataInputStream(new BufferedInputStream(nfs.open(overall)));
	 try {
		 numProcesses = in.readInt();
		 totalPages = in.readLong();
		 extent = new long[numProcesses];
		 for (int i = 0;
		 i < numProcesses;
		 i++) {
			 extent[i] = in.readLong();
		 }
	 }
	 finally {
		 in.close();
		 in = null;
	 }
	 ScoreStats scoreStats = new ScoreStats();
	 IWebDBReader reader = new WebDBReader(nfs, dbDir);
	 IWebDBWriter writer = new WebDBWriter(nfs, dbDir);
	 EditSet editSet = new EditSet(distDir, numProcesses);
	 try {
		 int count = 0;
		 UTF8 curEditURL = new UTF8();
		 ScoreValue curContribution = new ScoreValue();
		 boolean hasEdit = editSet.next(curEditURL, curContribution);
		 for (Enumeration e = reader.pages();
		 e.hasMoreElements();
		 count++) {
			 Page curPage = (Page) e.nextElement();
			 if (! hasEdit) {
				 break;
			 }
			 int comparison = curPage.getURL().compareTo(curEditURL);
			 float newScore = 0.0f, newNextScore = 0.0f;
			 if (comparison < 0) {
				 newScore = (1 - DECAY_VALUE);
				 newNextScore = (1 - DECAY_VALUE);
			 }
			 else if (comparison > 0) {
				 throw new IOException(""Impossible situation. There is a score-edit for "" + curEditURL + "", which comes after the current Page "" + curPage.getURL());
			 }
			 else {
				 while (hasEdit && curPage.getURL().compareTo(curEditURL) == 0) {
					 newScore += curContribution.score();
					 newNextScore += curContribution.nextScore();
					 hasEdit = editSet.next(curEditURL, curContribution);
				 }
				 newScore = (1 - DECAY_VALUE) + (DECAY_VALUE * newScore);
				 newNextScore = (1 - DECAY_VALUE) + (DECAY_VALUE * newNextScore);
			 }
			 curPage.setScore(newScore, newNextScore);
			 writer.addPageWithScore(curPage);
			 scoreStats.addScore(newScore);
			 if ((count % 5000) == 0) {
				 LOG.info(""Pages written: "" + count);
			 }
		 }
		 LOG.info(""Pages encountered: "" + count);
		 LOG.info(""Target pages from init(): "" + totalPages);
	 }
	 finally {
		 reader.close();
		 editSet.close();
		 writer.close();
	 }
	 if (scoreFile.exists()) {
		 scoreFile.delete();
	 }
	 PrintStream pout = new PrintStream(new BufferedOutputStream(nfs.create(scoreFile)));
	 try {
		 scoreStats.emitDistribution(pout);
	 }
	 finally {
		 pout.close();
	 }
	 FileUtil.fullyDelete(nfs, distDir);
 }",0,0,1,0
"public class SerializableLocatorImplimplements org.xml.sax.Locator, java.io.Serializable{
	 static final long serialVersionUID = -2660312888446371460L;
	 public SerializableLocatorImpl () {
	 }
	 public SerializableLocatorImpl (org.xml.sax.Locator locator) {
		 setPublicId(locator.getPublicId());
		 setSystemId(locator.getSystemId());
		 setLineNumber(locator.getLineNumber());
		 setColumnNumber(locator.getColumnNumber());
	 }
	 public String getPublicId () {
		 return publicId;
	 }
	 public String getSystemId () {
		 return systemId;
	 }
	 public int getLineNumber () {
		 return lineNumber;
	 }
	 public int getColumnNumber () {
		 return columnNumber;
	 }
	 public void setPublicId (String publicId) {
		 this.publicId = publicId;
	 }
	 public void setSystemId (String systemId) {
		 this.systemId = systemId;
	 }
	 public void setLineNumber (int lineNumber) {
		 this.lineNumber = lineNumber;
	 }
	 public void setColumnNumber (int columnNumber) {
		 this.columnNumber = columnNumber;
	 }
	 private String publicId;
	 private String systemId;
	 private int lineNumber;
	 private int columnNumber;
}",0,1,0,0
"public synchronized int getIncludedFilesCount() {
	 if (included == null) {
		 throw new IllegalStateException();
	 }
	 return included.size();
 }",0,0,0,0
"public void flushAndSignal(final CountDownLatch latch, ExecutorService sorter, final ExecutorService writer, final ReplayPosition context) {
	 writer.execute(new WrappedRunnable() {
		 public void runMayThrow() throws IOException {
			 cfs.flushLock.lock();
			 try {
				 if (!cfs.isDropped()) {
					 SSTableReader sstable = writeSortedContents(context);
					 cfs.replaceFlushed(Memtable.this, sstable);
				 }
			 }
			 finally {
				 cfs.flushLock.unlock();
			 }
			 latch.countDown();
		 }
	 }
	);
 }",0,0,0,0
"public class SequenceFile {
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.io.SequenceFile"");
	 private SequenceFile() {
	}
	 private static final byte BLOCK_COMPRESS_VERSION = (byte)4;
	 private static final byte CUSTOM_COMPRESS_VERSION = (byte)5;
	 private static byte[] VERSION = new byte[] {
	 (byte)'S', (byte)'E', (byte)'Q', CUSTOM_COMPRESS_VERSION }
	;
	 private static final int SYNC_ESCAPE = -1;
	 private static final int SYNC_HASH_SIZE = 16;
	 private static final int SYNC_SIZE = 4+SYNC_HASH_SIZE;
	 public static final int SYNC_INTERVAL = 100*SYNC_SIZE;
	 public static enum CompressionType {
	 NONE, RECORD, BLOCK }
	 static public CompressionType getCompressionType(Configuration job) {
		 String name = job.get(""io.seqfile.compression.type"");
		 return name == null ? CompressionType.RECORD : CompressionType.valueOf(name);
	 }
	 static public void setCompressionType(Configuration job, CompressionType val) {
		 job.set(""io.seqfile.compression.type"", val.toString());
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec());
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec());
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, Progressable progress) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass, progress);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec(), progress);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, new DefaultCodec(), progress);
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, codec);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, codec);
		 }
		 return writer;
	 }
	 public static Writer createWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Progressable progress) throws IOException {
		 Writer writer = null;
		 if (compressionType == CompressionType.NONE) {
			 writer = new Writer(fs, conf, name, keyClass, valClass, progress);
		 }
		 else if (compressionType == CompressionType.RECORD) {
			 writer = new RecordCompressWriter(fs, conf, name, keyClass, valClass, codec, progress);
		 }
		 else if (compressionType == CompressionType.BLOCK){
			 writer = new BlockCompressWriter(fs, conf, name, keyClass, valClass, codec, progress);
		 }
		 return writer;
	 }
	 private static Writer createWriter(FSDataOutputStream out, Class keyClass, Class valClass, boolean compress, boolean blockCompress, CompressionCodec codec) throws IOException {
		 Writer writer = null;
		 if (!compress) {
			 writer = new Writer(out, keyClass, valClass);
		 }
		 else if (compress && !blockCompress) {
			 writer = new RecordCompressWriter(out, keyClass, valClass, codec);
		 }
		 else {
			 writer = new BlockCompressWriter(out, keyClass, valClass, codec);
		 }
		 return writer;
	 }
	 public static interface ValueBytes {
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException;
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException;
	 }
	 private static class UncompressedBytes implements ValueBytes {
		 private int dataSize;
		 private byte[] data;
		 private UncompressedBytes() {
			 data = null;
			 dataSize = 0;
		 }
		 private void reset(DataInputStream in, int length) throws IOException {
			 data = new byte[length];
			 dataSize = -1;
			 in.readFully(data);
			 dataSize = data.length;
		 }
		 public int getSize() {
			 return dataSize;
		 }
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException {
			 outStream.write(data, 0, dataSize);
		 }
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException {
			 throw new IllegalArgumentException(""UncompressedBytes cannot be compressed!"");
		 }
	 }
	 private static class CompressedBytes implements ValueBytes {
		 private int dataSize;
		 private byte[] data;
		 DataInputBuffer rawData = null;
		 CompressionCodec codec = null;
		 CompressionInputStream decompressedStream = null;
		 private CompressedBytes(CompressionCodec codec) {
			 data = null;
			 dataSize = 0;
			 this.codec = codec;
		 }
		 private void reset(DataInputStream in, int length) throws IOException {
			 data = new byte[length];
			 dataSize = -1;
			 in.readFully(data);
			 dataSize = data.length;
		 }
		 public int getSize() {
			 return dataSize;
		 }
		 public void writeUncompressedBytes(DataOutputStream outStream) throws IOException {
			 if (decompressedStream == null) {
				 rawData = new DataInputBuffer();
				 decompressedStream = codec.createInputStream(rawData);
			 }
			 else {
				 decompressedStream.resetState();
			 }
			 rawData.reset(data, 0, dataSize);
			 byte[] buffer = new byte[8192];
			 int bytesRead = 0;
			 while ((bytesRead = decompressedStream.read(buffer, 0, 8192)) != -1) {
				 outStream.write(buffer, 0, bytesRead);
			 }
		 }
		 public void writeCompressedBytes(DataOutputStream outStream) throws IllegalArgumentException, IOException {
			 outStream.write(data, 0, dataSize);
		 }
	 }
	 public static class Writer {
		 FSDataOutputStream out;
		 DataOutputBuffer buffer = new DataOutputBuffer();
		 Path target = null;
		 Class keyClass;
		 Class valClass;
		 private boolean compress;
		 CompressionCodec codec = null;
		 CompressionOutputStream deflateFilter = null;
		 DataOutputStream deflateOut = null;
		 long lastSyncPos;
		 byte[] sync;
		 {
			 try {
				 MessageDigest digester = MessageDigest.getInstance(""MD5"");
				 digester.update((new UID()+""@""+InetAddress.getLocalHost()).getBytes());
				 sync = digester.digest();
			 }
			 catch (Exception e) {
				 throw new RuntimeException(e);
			 }
		 }
		 public Writer(FileSystem fs, String name, Class keyClass, Class valClass) throws IOException {
			 this(fs, new Path(name), keyClass, valClass, false);
		 }
		 Writer() {
		}
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass) throws IOException {
			 this(fs, name, keyClass, valClass, false);
		 }
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass, Progressable progress) throws IOException {
			 this(fs, name, keyClass, valClass, false, progress);
		 }
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass, boolean compress) throws IOException {
			 init(name, fs.create(name), keyClass, valClass, compress, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public Writer(FileSystem fs, Path name, Class keyClass, Class valClass, boolean compress, Progressable progress) throws IOException {
			 init(name, fs.create(name, progress), keyClass, valClass, compress, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public Writer(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass) throws IOException {
			 this(fs, name, keyClass, valClass, false);
		 }
		 public Writer(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, Progressable progress) throws IOException {
			 this(fs, name, keyClass, valClass, false, progress);
		 }
		 private Writer(FSDataOutputStream out, Class keyClass, Class valClass) throws IOException {
			 init(null, out, keyClass, valClass, false, null);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 void initializeFileHeader() throws IOException{
			 out.write(VERSION);
		 }
		 void finalizeFileHeader() throws IOException{
			 out.write(sync);
			 out.flush();
		 }
		 boolean isCompressed() {
			 return compress;
		 }
		 boolean isBlockCompressed() {
			 return false;
		 }
		 void writeFileHeader() throws IOException {
			 Text.writeString(out, keyClass.getName());
			 Text.writeString(out, valClass.getName());
			 out.writeBoolean(this.isCompressed());
			 out.writeBoolean(this.isBlockCompressed());
			 if(this.isCompressed()) {
				 Text.writeString(out, (codec.getClass()).getName());
			 }
		 }
		 void init(Path name, FSDataOutputStream out, Class keyClass, Class valClass, boolean compress, CompressionCodec codec) throws IOException {
			 this.target = name;
			 this.out = out;
			 this.keyClass = keyClass;
			 this.valClass = valClass;
			 this.compress = compress;
			 this.codec = codec;
			 if(this.codec != null) {
				 this.deflateFilter = this.codec.createOutputStream(buffer);
				 this.deflateOut = new DataOutputStream(new BufferedOutputStream(deflateFilter));
			 }
		 }
		 public Class getKeyClass() {
			 return keyClass;
		 }
		 public Class getValueClass() {
			 return valClass;
		 }
		 public CompressionCodec getCompressionCodec() {
			 return codec;
		 }
		 public synchronized void close() throws IOException {
			 if (out != null) {
				 out.close();
				 out = null;
			 }
		 }
		 synchronized void checkAndWriteSync() throws IOException {
			 if (sync != null && out.getPos() >= lastSyncPos+SYNC_INTERVAL) {
				 lastSyncPos = out.getPos();
				 out.writeInt(SYNC_ESCAPE);
				 out.write(sync);
			 }
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key.getClass().getName() +"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val.getClass().getName() +"" is not ""+valClass);
			 buffer.reset();
			 key.write(buffer);
			 int keyLength = buffer.getLength();
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 if (compress) {
				 deflateFilter.resetState();
				 val.write(deflateOut);
				 deflateOut.flush();
				 deflateFilter.finish();
			 }
			 else {
				 val.write(buffer);
			 }
			 checkAndWriteSync();
			 out.writeInt(buffer.getLength());
			 out.writeInt(keyLength);
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 public synchronized void append(byte[] data, int start, int length, int keyLength) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 checkAndWriteSync();
			 out.writeInt(length);
			 out.writeInt(keyLength);
			 out.write(data, start, length);
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + keyLength);
			 UncompressedBytes value = (UncompressedBytes)val;
			 int valLength = value.getSize();
			 checkAndWriteSync();
			 out.writeInt(keyLength+valLength);
			 out.writeInt(keyLength);
			 out.write(keyData, keyOffset, keyLength);
			 val.writeUncompressedBytes(out);
		 }
		 public synchronized long getLength() throws IOException {
			 return out.getPos();
		 }
	 }
	 static class RecordCompressWriter extends Writer {
		 public RecordCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(name, fs.create(name), keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public RecordCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec, Progressable progress) throws IOException {
			 super.init(name, fs.create(name, progress), keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private RecordCompressWriter(FSDataOutputStream out, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(null, out, keyClass, valClass, true, codec);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 boolean isCompressed() {
			 return true;
		 }
		 boolean isBlockCompressed() {
			 return false;
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key.getClass().getName() +"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val.getClass().getName() +"" is not ""+valClass);
			 buffer.reset();
			 key.write(buffer);
			 int keyLength = buffer.getLength();
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 deflateFilter.resetState();
			 val.write(deflateOut);
			 deflateOut.flush();
			 deflateFilter.finish();
			 checkAndWriteSync();
			 out.writeInt(buffer.getLength());
			 out.writeInt(keyLength);
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val ) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 CompressedBytes value = (CompressedBytes)val;
			 int valLength = value.getSize();
			 checkAndWriteSync();
			 out.writeInt(keyLength+valLength);
			 out.writeInt(keyLength);
			 out.write(keyData, keyOffset, keyLength);
			 val.writeCompressedBytes(out);
		 }
	 }
	 static class BlockCompressWriter extends Writer {
		 private int noBufferedRecords = 0;
		 private DataOutputBuffer keyLenBuffer = new DataOutputBuffer();
		 private DataOutputBuffer keyBuffer = new DataOutputBuffer();
		 private DataOutputBuffer valLenBuffer = new DataOutputBuffer();
		 private DataOutputBuffer valBuffer = new DataOutputBuffer();
		 private int compressionBlockSize;
		 public BlockCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(name, fs.create(name), keyClass, valClass, true, codec);
			 init(conf.getInt(""io.seqfile.compress.blocksize"", 1000000));
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 public BlockCompressWriter(FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionCodec codec, Progressable progress) throws IOException {
			 super.init(name, fs.create(name, progress), keyClass, valClass, true, codec);
			 init(conf.getInt(""io.seqfile.compress.blocksize"", 1000000));
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 private BlockCompressWriter(FSDataOutputStream out, Class keyClass, Class valClass, CompressionCodec codec) throws IOException {
			 super.init(null, out, keyClass, valClass, true, codec);
			 init(1000000);
			 initializeFileHeader();
			 writeFileHeader();
			 finalizeFileHeader();
		 }
		 boolean isCompressed() {
			 return true;
		 }
		 boolean isBlockCompressed() {
			 return true;
		 }
		 void init(int compressionBlockSize) {
			 this.compressionBlockSize = compressionBlockSize;
		 }
		 private synchronized void writeBuffer(DataOutputBuffer uncompressedDataBuffer) throws IOException {
			 deflateFilter.resetState();
			 buffer.reset();
			 deflateOut.write(uncompressedDataBuffer.getData(), 0, uncompressedDataBuffer.getLength());
			 deflateOut.flush();
			 deflateFilter.finish();
			 WritableUtils.writeVInt(out, buffer.getLength());
			 out.write(buffer.getData(), 0, buffer.getLength());
		 }
		 private synchronized void writeBlock() throws IOException {
			 if (noBufferedRecords > 0) {
				 if (sync != null) {
					 out.writeInt(SYNC_ESCAPE);
					 out.write(sync);
				 }
				 WritableUtils.writeVInt(out, noBufferedRecords);
				 writeBuffer(keyLenBuffer);
				 writeBuffer(keyBuffer);
				 writeBuffer(valLenBuffer);
				 writeBuffer(valBuffer);
				 out.flush();
				 keyLenBuffer.reset();
				 keyBuffer.reset();
				 valLenBuffer.reset();
				 valBuffer.reset();
				 noBufferedRecords = 0;
			 }
		 }
		 public synchronized void close() throws IOException {
			 if (out != null) {
				 writeBlock();
				 out.close();
				 out = null;
			 }
		 }
		 public synchronized void append(Writable key, Writable val) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key+"" is not ""+keyClass);
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 int oldKeyLength = keyBuffer.getLength();
			 key.write(keyBuffer);
			 int keyLength = keyBuffer.getLength() - oldKeyLength;
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed: "" + key);
			 WritableUtils.writeVInt(keyLenBuffer, keyLength);
			 int oldValLength = valBuffer.getLength();
			 val.write(valBuffer);
			 int valLength = valBuffer.getLength() - oldValLength;
			 WritableUtils.writeVInt(valLenBuffer, valLength);
			 ++noBufferedRecords;
			 int currentBlockSize = keyBuffer.getLength() + valBuffer.getLength();
			 if (currentBlockSize >= compressionBlockSize) {
				 writeBlock();
			 }
		 }
		 public synchronized void appendRaw( byte[] keyData, int keyOffset, int keyLength, ValueBytes val ) throws IOException {
			 if (keyLength == 0) throw new IOException(""zero length keys not allowed"");
			 UncompressedBytes value = (UncompressedBytes)val;
			 int valLength = value.getSize();
			 WritableUtils.writeVInt(keyLenBuffer, keyLength);
			 keyBuffer.write(keyData, keyOffset, keyLength);
			 WritableUtils.writeVInt(valLenBuffer, valLength);
			 val.writeUncompressedBytes(valBuffer);
			 ++noBufferedRecords;
			 int currentBlockSize = keyBuffer.getLength() + valBuffer.getLength();
			 if (currentBlockSize >= compressionBlockSize) {
				 writeBlock();
			 }
		 }
	 }
	 public static class Reader {
		 private Path file;
		 private FSDataInputStream in;
		 private DataOutputBuffer outBuf = new DataOutputBuffer();
		 private byte version;
		 private Class keyClass;
		 private Class valClass;
		 private CompressionCodec codec = null;
		 private byte[] sync = new byte[SYNC_HASH_SIZE];
		 private byte[] syncCheck = new byte[SYNC_HASH_SIZE];
		 private boolean syncSeen;
		 private long end;
		 private int keyLength;
		 private boolean decompress;
		 private boolean blockCompressed;
		 private Configuration conf;
		 private int noBufferedRecords = 0;
		 private boolean lazyDecompress = true;
		 private boolean valuesDecompressed = true;
		 private int noBufferedKeys = 0;
		 private int noBufferedValues = 0;
		 private DataInputBuffer keyLenBuffer = null;
		 private CompressionInputStream keyLenInFilter = null;
		 private DataInputStream keyLenIn = null;
		 private DataInputBuffer keyBuffer = null;
		 private CompressionInputStream keyInFilter = null;
		 private DataInputStream keyIn = null;
		 private DataInputBuffer valLenBuffer = null;
		 private CompressionInputStream valLenInFilter = null;
		 private DataInputStream valLenIn = null;
		 private DataInputBuffer valBuffer = null;
		 private CompressionInputStream valInFilter = null;
		 private DataInputStream valIn = null;
		 public Reader(FileSystem fs, String file, Configuration conf) throws IOException {
			 this(fs, new Path(file), conf);
		 }
		 public Reader(FileSystem fs, Path file, Configuration conf) throws IOException {
			 this(fs, file, conf.getInt(""io.file.buffer.size"", 4096), conf);
		 }
		 private Reader(FileSystem fs, Path name, int bufferSize, Configuration conf) throws IOException {
			 this.file = name;
			 this.in = fs.open(file, bufferSize);
			 this.end = fs.getLength(file);
			 this.conf = conf;
			 init();
		 }
		 private Reader(FileSystem fs, Path file, int bufferSize, long start, long length, Configuration conf) throws IOException {
			 this.file = file;
			 this.in = fs.open(file, bufferSize);
			 this.conf = conf;
			 seek(start);
			 this.end = in.getPos() + length;
			 init();
		 }
		 private void init() throws IOException {
			 byte[] versionBlock = new byte[VERSION.length];
			 in.readFully(versionBlock);
			 if ((versionBlock[0] != VERSION[0]) || (versionBlock[1] != VERSION[1]) || (versionBlock[2] != VERSION[2])) throw new IOException(file + "" not a SequenceFile"");
			 version = versionBlock[3];
			 if (version > VERSION[3]) throw new VersionMismatchException(VERSION[3], version);
			 if (version < BLOCK_COMPRESS_VERSION) {
				 UTF8 className = new UTF8();
				 className.readFields(in);
				 this.keyClass = WritableName.getClass(className.toString(), conf);
				 className.readFields(in);
				 this.valClass = WritableName.getClass(className.toString(), conf);
			 }
			 else {
				 this.keyClass = WritableName.getClass(Text.readString(in), conf);
				 this.valClass = WritableName.getClass(Text.readString(in), conf);
			 }
			 if (version > 2) {
				 this.decompress = in.readBoolean();
			 }
			 else {
				 decompress = false;
			 }
			 if (version >= BLOCK_COMPRESS_VERSION) {
				 this.blockCompressed = in.readBoolean();
			 }
			 else {
				 blockCompressed = false;
			 }
			 if (decompress) {
				 if (version >= CUSTOM_COMPRESS_VERSION) {
					 String codecClassname = Text.readString(in);
					 try {
						 Class codecClass = conf.getClassByName(codecClassname);
						 this.codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, conf);
					 }
					 catch (ClassNotFoundException cnfe) {
						 throw new IllegalArgumentException(""Unknown codec: "" + codecClassname, cnfe);
					 }
				 }
				 else {
					 codec = new DefaultCodec();
				 }
			 }
			 if (version > 1) {
				 in.readFully(sync);
			 }
			 valBuffer = new DataInputBuffer();
			 if (decompress) {
				 valInFilter = this.codec.createInputStream(valBuffer);
				 valIn = new DataInputStream(valInFilter);
			 }
			 else {
				 valIn = valBuffer;
			 }
			 if (blockCompressed) {
				 keyLenBuffer = new DataInputBuffer();
				 keyBuffer = new DataInputBuffer();
				 valLenBuffer = new DataInputBuffer();
				 keyLenInFilter = this.codec.createInputStream(keyLenBuffer);
				 keyLenIn = new DataInputStream(keyLenInFilter);
				 keyInFilter = this.codec.createInputStream(keyBuffer);
				 keyIn = new DataInputStream(keyInFilter);
				 valLenInFilter = this.codec.createInputStream(valLenBuffer);
				 valLenIn = new DataInputStream(valLenInFilter);
			 }
			 lazyDecompress = conf.getBoolean(""io.seqfile.lazydecompress"", true);
		 }
		 public synchronized void close() throws IOException {
			 in.close();
		 }
		 public Class getKeyClass() {
			 return keyClass;
		 }
		 public Class getValueClass() {
			 return valClass;
		 }
		 public boolean isCompressed() {
			 return decompress;
		 }
		 public boolean isBlockCompressed() {
			 return blockCompressed;
		 }
		 public CompressionCodec getCompressionCodec() {
			 return codec;
		 }
		 private synchronized void readBuffer(DataInputBuffer buffer, CompressionInputStream filter) throws IOException {
			 DataOutputBuffer dataBuffer = new DataOutputBuffer();
			 int dataBufferLength = WritableUtils.readVInt(in);
			 dataBuffer.write(in, dataBufferLength);
			 buffer.reset(dataBuffer.getData(), 0, dataBuffer.getLength());
			 filter.resetState();
		 }
		 private synchronized void readBlock() throws IOException {
			 if (lazyDecompress && !valuesDecompressed) {
				 in.seek(WritableUtils.readVInt(in)+in.getPos());
				 in.seek(WritableUtils.readVInt(in)+in.getPos());
			 }
			 noBufferedKeys = 0;
			 noBufferedValues = 0;
			 noBufferedRecords = 0;
			 valuesDecompressed = false;
			 if (sync != null) {
				 in.readInt();
				 in.readFully(syncCheck);
				 if (!Arrays.equals(sync, syncCheck)) throw new IOException(""File is corrupt!"");
			 }
			 syncSeen = true;
			 noBufferedRecords = WritableUtils.readVInt(in);
			 readBuffer(keyLenBuffer, keyLenInFilter);
			 readBuffer(keyBuffer, keyInFilter);
			 noBufferedKeys = noBufferedRecords;
			 if (!lazyDecompress) {
				 readBuffer(valLenBuffer, valLenInFilter);
				 readBuffer(valBuffer, valInFilter);
				 noBufferedValues = noBufferedRecords;
				 valuesDecompressed = true;
			 }
		 }
		 private synchronized void seekToCurrentValue() throws IOException {
			 if (!blockCompressed) {
				 if (decompress) {
					 valInFilter.resetState();
				 }
				 valBuffer.reset();
			 }
			 else {
				 if (lazyDecompress && !valuesDecompressed) {
					 readBuffer(valLenBuffer, valLenInFilter);
					 readBuffer(valBuffer, valInFilter);
					 noBufferedValues = noBufferedRecords;
					 valuesDecompressed = true;
				 }
				 int skipValBytes = 0;
				 int currentKey = noBufferedKeys + 1;
				 for (int i=noBufferedValues;
				 i > currentKey;
				 --i) {
					 skipValBytes += WritableUtils.readVInt(valLenIn);
					 --noBufferedValues;
				 }
				 if (skipValBytes > 0) {
					 if (valIn.skipBytes(skipValBytes) != skipValBytes) {
						 throw new IOException(""Failed to seek to "" + currentKey + ""(th) value!"");
					 }
				 }
			 }
		 }
		 public synchronized void getCurrentValue(Writable val) throws IOException {
			 if (val instanceof Configurable) {
				 ((Configurable) val).setConf(this.conf);
			 }
			 seekToCurrentValue();
			 if (!blockCompressed) {
				 val.readFields(valIn);
				 if (valIn.read() > 0) {
					 LOG.info(""available bytes: "" + valIn.available());
					 throw new IOException(val+"" read ""+(valBuffer.getPosition()-keyLength) + "" bytes, should read "" + (valBuffer.getLength()-keyLength));
				 }
			 }
			 else {
				 int valLength = WritableUtils.readVInt(valLenIn);
				 val.readFields(valIn);
				 --noBufferedValues;
				 if (valLength < 0) {
					 LOG.debug(val + "" is a zero-length value"");
				 }
			 }
		 }
		 public synchronized boolean next(Writable key) throws IOException {
			 if (key.getClass() != keyClass) throw new IOException(""wrong key class: ""+key.getClass().getName() +"" is not ""+keyClass);
			 if (!blockCompressed) {
				 outBuf.reset();
				 keyLength = next(outBuf);
				 if (keyLength < 0) return false;
				 valBuffer.reset(outBuf.getData(), outBuf.getLength());
				 key.readFields(valBuffer);
				 valBuffer.mark(0);
				 if (valBuffer.getPosition() != keyLength) throw new IOException(key + "" read "" + valBuffer.getPosition() + "" bytes, should read "" + keyLength);
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return false;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 return false;
				 }
				 key.readFields(keyIn);
				 --noBufferedKeys;
			 }
			 return true;
		 }
		 public synchronized boolean next(Writable key, Writable val) throws IOException {
			 if (val.getClass() != valClass) throw new IOException(""wrong value class: ""+val+"" is not ""+valClass);
			 boolean more = next(key);
			 if (more) {
				 getCurrentValue(val);
			 }
			 return more;
		 }
		 private synchronized int checkAndReadSync(int length) throws IOException {
			 if (version > 1 && sync != null && length == SYNC_ESCAPE) {
				 in.readFully(syncCheck);
				 if (!Arrays.equals(sync, syncCheck)) throw new IOException(""File is corrupt!"");
				 syncSeen = true;
				 length = in.readInt();
			 }
			 else {
				 syncSeen = false;
			 }
			 return length;
		 }
		 public synchronized int next(DataOutputBuffer buffer) throws IOException {
			 if (blockCompressed) {
				 throw new IOException(""Unsupported call for block-compressed"" + "" SequenceFiles - use SequenceFile.Reader.next(DataOutputStream, ValueBytes)"");
			 }
			 if (in.getPos() >= end) return -1;
			 try {
				 int length = checkAndReadSync(in.readInt());
				 int keyLength = in.readInt();
				 buffer.write(in, length);
				 return keyLength;
			 }
			 catch (ChecksumException e) {
				 handleChecksumException(e);
				 return next(buffer);
			 }
		 }
		 public ValueBytes createValueBytes() {
			 ValueBytes val = null;
			 if (!decompress || blockCompressed) {
				 val = new UncompressedBytes();
			 }
			 else {
				 val = new CompressedBytes(codec);
			 }
			 return val;
		 }
		 public int nextRaw(DataOutputBuffer key, ValueBytes val) throws IOException {
			 if (!blockCompressed) {
				 if (in.getPos() >= end) return -1;
				 int length = checkAndReadSync(in.readInt());
				 int keyLength = in.readInt();
				 int valLength = length - keyLength;
				 key.write(in, keyLength);
				 if (decompress) {
					 CompressedBytes value = (CompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 else {
					 UncompressedBytes value = (UncompressedBytes)val;
					 value.reset(in, valLength);
				 }
				 return length;
			 }
			 else {
				 syncSeen = false;
				 if (noBufferedKeys == 0) {
					 if (in.getPos() >= end) return -1;
					 try {
						 readBlock();
					 }
					 catch (EOFException eof) {
						 return -1;
					 }
				 }
				 int keyLength = WritableUtils.readVInt(keyLenIn);
				 if (keyLength < 0) {
					 throw new IOException(""zero length key found!"");
				 }
				 key.write(keyIn, keyLength);
				 --noBufferedKeys;
				 seekToCurrentValue();
				 int valLength = WritableUtils.readVInt(valLenIn);
				 UncompressedBytes rawValue = (UncompressedBytes)val;
				 rawValue.reset(valIn, valLength);
				 --noBufferedValues;
				 return (keyLength+valLength);
			 }
		 }
		 private void handleChecksumException(ChecksumException e) throws IOException {
			 if (this.conf.getBoolean(""io.skip.checksum.errors"", false)) {
				 LOG.warn(""Bad checksum at ""+getPosition()+"". Skipping entries."");
				 sync(getPosition()+this.conf.getInt(""io.bytes.per.checksum"", 512));
			 }
			 else {
				 throw e;
			 }
		 }
		 public synchronized void seek(long position) throws IOException {
			 in.seek(position);
			 if (blockCompressed) {
				 noBufferedKeys = 0;
				 valuesDecompressed = true;
			 }
		 }
		 public synchronized void sync(long position) throws IOException {
			 if (position+SYNC_SIZE >= end) {
				 seek(end);
				 return;
			 }
			 try {
				 seek(position+4);
				 in.readFully(syncCheck);
				 int syncLen = sync.length;
				 for (int i = 0;
				 in.getPos() < end;
				 i++) {
					 int j = 0;
					 for (;
					 j < syncLen;
					 j++) {
						 if (sync[j] != syncCheck[(i+j)%syncLen]) break;
					 }
					 if (j == syncLen) {
						 in.seek(in.getPos() - SYNC_SIZE);
						 return;
					 }
					 syncCheck[i%syncLen] = in.readByte();
				 }
			 }
			 catch (ChecksumException e) {
				 handleChecksumException(e);
			 }
		 }
		 public boolean syncSeen() {
			 return syncSeen;
		 }
		 public synchronized long getPosition() throws IOException {
			 return in.getPos();
		 }
		 public String toString() {
			 return file.toString();
		 }
	 }
	 public static class Sorter {
		 private WritableComparator comparator;
		 private Path[] inFiles;
		 private Path outFile;
		 private int memory;
		 private int factor;
		 private FileSystem fs = null;
		 private Class keyClass;
		 private Class valClass;
		 private Configuration conf;
		 public Sorter(FileSystem fs, Class keyClass, Class valClass, Configuration conf) {
			 this(fs, new WritableComparator(keyClass), valClass, conf);
		 }
		 public Sorter(FileSystem fs, WritableComparator comparator, Class valClass, Configuration conf) {
			 this.fs = fs;
			 this.comparator = comparator;
			 this.keyClass = comparator.getKeyClass();
			 this.valClass = valClass;
			 this.memory = conf.getInt(""io.sort.mb"", 100) * 1024 * 1024;
			 this.factor = conf.getInt(""io.sort.factor"", 100);
			 this.conf = conf;
		 }
		 public void setFactor(int factor) {
			 this.factor = factor;
		 }
		 public int getFactor() {
			 return factor;
		 }
		 public void setMemory(int memory) {
			 this.memory = memory;
		 }
		 public int getMemory() {
			 return memory;
		 }
		 public void sort(Path[] inFiles, Path outFile, boolean deleteInput) throws IOException {
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 this.inFiles = inFiles;
			 this.outFile = outFile;
			 int segments = sortPass(deleteInput);
			 int pass = 1;
			 while (segments > 1) {
				 segments = mergePass(pass, segments <= factor);
				 pass++;
			 }
			 for (int i=0;
			 i < pass;
			 ++i) {
				 fs.delete(new Path(outFile.toString() + ""."" + i));
				 fs.delete(new Path(outFile.toString() + ""."" + i + "".index""));
			 }
		 }
		 public void sort(Path inFile, Path outFile) throws IOException {
			 sort(new Path[]{
			inFile}
			, outFile, false);
		 }
		 private int sortPass(boolean deleteInput) throws IOException {
			 LOG.debug(""running sort pass"");
			 SortPass sortPass = new SortPass();
			 try {
				 return sortPass.run(deleteInput);
			 }
			 finally {
				 sortPass.close();
			 }
		 }
		 private class SortPass {
			 private int memoryLimit = memory/4;
			 private int recordLimit = 1000000;
			 private DataOutputBuffer rawKeys = new DataOutputBuffer();
			 private byte[] rawBuffer;
			 private int[] keyOffsets = new int[1024];
			 private int[] pointers = new int[keyOffsets.length];
			 private int[] pointersCopy = new int[keyOffsets.length];
			 private int[] keyLengths = new int[keyOffsets.length];
			 private ValueBytes[] rawValues = new ValueBytes[keyOffsets.length];
			 private ArrayList segmentLengths = new ArrayList();
			 private Reader in = null;
			 private FSDataOutputStream out = null;
			 private FSDataOutputStream indexOut = null;
			 private Path outName;
			 public int run(boolean deleteInput) throws IOException {
				 int segments = 0;
				 int currentFile = 0;
				 boolean atEof = (currentFile >= inFiles.length);
				 boolean isCompressed = false;
				 boolean isBlockCompressed = false;
				 CompressionCodec codec = null;
				 segmentLengths.clear();
				 if (atEof) {
					 return 0;
				 }
				 in = new Reader(fs, inFiles[currentFile], conf);
				 isCompressed = in.isCompressed();
				 isBlockCompressed = in.isBlockCompressed();
				 codec = in.getCompressionCodec();
				 for (int i=0;
				 i < rawValues.length;
				 ++i) {
					 rawValues[i] = null;
				 }
				 while (!atEof) {
					 int count = 0;
					 int bytesProcessed = 0;
					 rawKeys.reset();
					 while (!atEof && bytesProcessed < memoryLimit && count < recordLimit) {
						 int keyOffset = rawKeys.getLength();
						 ValueBytes rawValue = (count == keyOffsets.length || rawValues[count] == null) ? in.createValueBytes() : rawValues[count];
						 int recordLength = in.nextRaw(rawKeys, rawValue);
						 if (recordLength == -1) {
							 in.close();
							 if (deleteInput) {
								 fs.delete(inFiles[currentFile]);
							 }
							 currentFile += 1;
							 atEof = currentFile >= inFiles.length;
							 if (!atEof) {
								 in = new Reader(fs, inFiles[currentFile], conf);
							 }
							 else {
								 in = null;
							 }
							 continue;
						 }
						 int keyLength = rawKeys.getLength() - keyOffset;
						 if (count == keyOffsets.length) grow();
						 keyOffsets[count] = keyOffset;
						 pointers[count] = count;
						 keyLengths[count] = keyLength;
						 rawValues[count] = rawValue;
						 bytesProcessed += recordLength;
						 count++;
					 }
					 LOG.debug(""flushing segment "" + segments);
					 rawBuffer = rawKeys.getData();
					 sort(count);
					 flush(count, bytesProcessed, isCompressed, isBlockCompressed, codec, segments==0 && atEof);
					 segments++;
				 }
				 return segments;
			 }
			 public void close() throws IOException {
				 if (in != null) {
					 in.close();
				 }
				 if (out != null) {
					 out.close();
				 }
				 if (indexOut != null) {
					 indexOut.close();
				 }
			 }
			 private void grow() {
				 int newLength = keyOffsets.length * 3 / 2;
				 keyOffsets = grow(keyOffsets, newLength);
				 pointers = grow(pointers, newLength);
				 pointersCopy = new int[newLength];
				 keyLengths = grow(keyLengths, newLength);
				 rawValues = grow(rawValues, newLength);
			 }
			 private int[] grow(int[] old, int newLength) {
				 int[] result = new int[newLength];
				 System.arraycopy(old, 0, result, 0, old.length);
				 return result;
			 }
			 private ValueBytes[] grow(ValueBytes[] old, int newLength) {
				 ValueBytes[] result = new ValueBytes[newLength];
				 System.arraycopy(old, 0, result, 0, old.length);
				 for (int i=old.length;
				 i < newLength;
				 ++i) {
					 result[i] = null;
				 }
				 return result;
			 }
			 private void flush(int count, int bytesProcessed, boolean isCompressed, boolean isBlockCompressed, CompressionCodec codec, boolean done) throws IOException {
				 if (out == null) {
					 outName = done ? outFile : outFile.suffix("".0"");
					 out = fs.create(outName);
					 if (!done) {
						 indexOut = fs.create(outName.suffix("".index""));
					 }
				 }
				 long segmentStart = out.getPos();
				 Writer writer = createWriter(out, keyClass, valClass, isCompressed, isBlockCompressed, codec);
				 if (!done) {
					 writer.sync = null;
				 }
				 for (int i = 0;
				 i < count;
				 i++) {
					 int p = pointers[i];
					 writer.appendRaw(rawBuffer, keyOffsets[p], keyLengths[p], rawValues[p]);
				 }
				 if (writer instanceof SequenceFile.BlockCompressWriter) {
					 SequenceFile.BlockCompressWriter bcWriter = (SequenceFile.BlockCompressWriter) writer;
					 bcWriter.writeBlock();
				 }
				 writer.out.flush();
				 if (!done) {
					 WritableUtils.writeVLong(indexOut, segmentStart);
					 WritableUtils.writeVLong(indexOut, (writer.out.getPos()-segmentStart));
					 indexOut.flush();
				 }
			 }
			 private void sort(int count) {
				 System.arraycopy(pointers, 0, pointersCopy, 0, count);
				 mergeSort(pointersCopy, pointers, 0, count);
			 }
			 private int compare(int i, int j) {
				 return comparator.compare(rawBuffer, keyOffsets[i], keyLengths[i], rawBuffer, keyOffsets[j], keyLengths[j]);
			 }
			 private void mergeSort(int src[], int dest[], int low, int high) {
				 int length = high - low;
				 if (length < 7) {
					 for (int i=low;
					 i<high;
					 i++) for (int j=i;
					 j>low && compare(dest[j-1], dest[j])>0;
					 j--) swap(dest, j, j-1);
					 return;
				 }
				 int mid = (low + high) >> 1;
				 mergeSort(dest, src, low, mid);
				 mergeSort(dest, src, mid, high);
				 if (compare(src[mid-1], src[mid]) <= 0) {
					 System.arraycopy(src, low, dest, low, length);
					 return;
				 }
				 for (int i = low, p = low, q = mid;
				 i < high;
				 i++) {
					 if (q>=high || p<mid && compare(src[p], src[q]) <= 0) dest[i] = src[p++];
					 else dest[i] = src[q++];
				 }
			 }
			 private void swap(int x[], int a, int b) {
				 int t = x[a];
				 x[a] = x[b];
				 x[b] = t;
			 }
		 }
		 private int mergePass(int pass, boolean last) throws IOException {
			 LOG.debug(""running merge pass="" + pass);
			 MergePass mergePass = new MergePass(pass, last);
			 try {
				 return mergePass.run();
			 }
			 finally {
				 mergePass.close();
			 }
		 }
		 private class MergePass {
			 private boolean last;
			 private MergeQueue queue;
			 private FSDataInputStream in = null;
			 private Path inName;
			 private FSDataInputStream indexIn = null;
			 public MergePass(int pass, boolean last) throws IOException {
				 this.last = last;
				 this.queue = new MergeQueue(factor, last?outFile:outFile.suffix("".""+pass), last);
				 this.inName = outFile.suffix("".""+(pass-1));
				 this.in = fs.open(inName);
				 this.indexIn = fs.open(inName.suffix("".index""));
			 }
			 public void close() throws IOException {
				 in.close();
				 fs.delete(inName);
				 queue.close();
			 }
			 public int run() throws IOException {
				 int segments = 0;
				 long end = fs.getLength(inName);
				 while (in.getPos() < end) {
					 LOG.debug(""merging segment "" + segments);
					 long segmentStart = queue.out.getPos();
					 while (in.getPos() < end && queue.size() < factor) {
						 long segmentOffset = WritableUtils.readVLong(indexIn);
						 long segmentLength = WritableUtils.readVLong(indexIn);
						 Reader reader = new Reader(fs, inName, memory/(factor+1), segmentOffset, segmentLength, conf);
						 reader.sync = null;
						 MergeStream ms = new MergeStream(reader);
						 if (ms.next()) {
							 queue.put(ms);
						 }
						 in.seek(reader.end);
					 }
					 queue.merge();
					 if (!last) {
						 WritableUtils.writeVLong(queue.indexOut, segmentStart);
						 WritableUtils.writeVLong(queue.indexOut, (queue.out.getPos() - segmentStart));
					 }
					 segments++;
				 }
				 return segments;
			 }
		 }
		 public void merge(Path[] inFiles, Path outFile) throws IOException {
			 this.inFiles = inFiles;
			 this.outFile = outFile;
			 this.factor = inFiles.length;
			 if (fs.exists(outFile)) {
				 throw new IOException(""already exists: "" + outFile);
			 }
			 MergeFiles mergeFiles = new MergeFiles();
			 try {
				 mergeFiles.run();
			 }
			 finally {
				 mergeFiles.close();
			 }
		 }
		 private class MergeFiles {
			 private MergeQueue queue;
			 public MergeFiles() throws IOException {
				 this.queue = new MergeQueue(factor, outFile, true);
			 }
			 public void close() throws IOException {
				 queue.close();
			 }
			 public void run() throws IOException {
				 LOG.debug(""merging files="" + inFiles.length);
				 for (int i = 0;
				 i < inFiles.length;
				 i++) {
					 Path inFile = inFiles[i];
					 MergeStream ms = new MergeStream(new Reader(fs, inFile, memory/(factor+1), conf));
					 if (ms.next()) queue.put(ms);
				 }
				 queue.merge();
			 }
		 }
		 private class MergeStream {
			 private Reader in;
			 private DataOutputBuffer rawKey = null;
			 private ValueBytes rawValue = null;
			 public MergeStream(Reader reader) throws IOException {
				 if (reader.keyClass != keyClass) throw new IOException(""wrong key class: "" + reader.getKeyClass() + "" is not "" + keyClass);
				 if (reader.valClass != valClass) throw new IOException(""wrong value class: ""+reader.getValueClass()+ "" is not "" + valClass);
				 this.in = reader;
				 rawKey = new DataOutputBuffer();
				 rawValue = in.createValueBytes();
			 }
			 public boolean next() throws IOException {
				 rawKey.reset();
				 int recordLength = in.nextRaw(rawKey, rawValue);
				 return (recordLength >= 0);
			 }
		 }
		 private class MergeQueue extends PriorityQueue {
			 private Path outName;
			 private FSDataOutputStream out;
			 private FSDataOutputStream indexOut;
			 private boolean done;
			 private boolean compress;
			 private boolean blockCompress;
			 private CompressionCodec codec = null;
			 public void put(MergeStream stream) throws IOException {
				 if (size() == 0) {
					 compress = stream.in.isCompressed();
					 blockCompress = stream.in.isBlockCompressed();
					 codec = stream.in.getCompressionCodec();
				 }
				 else if (compress != stream.in.isCompressed() || blockCompress != stream.in.isBlockCompressed()) {
					 throw new IOException(""All merged files must be compressed or not."");
				 }
				 super.put(stream);
			 }
			 public MergeQueue(int size, Path outName, boolean done) throws IOException {
				 initialize(size);
				 this.outName = outName;
				 this.out = fs.create(this.outName, true, memory/(factor+1));
				 if (!done) {
					 this.indexOut = fs.create(outName.suffix("".index""), true, memory/(factor+1));
				 }
				 this.done = done;
			 }
			 protected boolean lessThan(Object a, Object b) {
				 MergeStream msa = (MergeStream)a;
				 MergeStream msb = (MergeStream)b;
				 return comparator.compare(msa.rawKey.getData(), 0, msa.rawKey.getLength(), msb.rawKey.getData(), 0, msb.rawKey.getLength()) < 0;
			 }
			 public void merge() throws IOException {
				 Writer writer = createWriter(out, keyClass, valClass, compress, blockCompress, codec);
				 if (!done) {
					 writer.sync = null;
				 }
				 while (size() != 0) {
					 MergeStream ms = (MergeStream)top();
					 writer.appendRaw(ms.rawKey.getData(), 0, ms.rawKey.getLength(), ms.rawValue);
					 if (ms.next()) {
						 adjustTop();
					 }
					 else {
						 pop();
						 ms.in.close();
					 }
				 }
				 if (writer instanceof SequenceFile.BlockCompressWriter) {
					 SequenceFile.BlockCompressWriter bcWriter = (SequenceFile.BlockCompressWriter) writer;
					 bcWriter.writeBlock();
				 }
				 out.flush();
			 }
			 public void close() throws IOException {
				 MergeStream ms;
				 while ((ms = (MergeStream)pop()) != null) {
					 ms.in.close();
				 }
				 out.close();
				 if (indexOut != null) {
					 indexOut.close();
				 }
			 }
		 }
	 }
 }",1,0,0,0
"public class FreeableMemory extends Memory{
	 AtomicInteger references = new AtomicInteger(1);
	 public FreeableMemory(long size) {
		 super(size);
	 }
	 public boolean reference() {
		 while (true) {
			 int n = references.get();
			 if (n <= 0) return false;
			 if (references.compareAndSet(n, n + 1)) return true;
		 }
	 }
	 public void unreference() {
		 if (references.decrementAndGet() == 0) free();
	 }
	 protected void finalize() throws Throwable {
		 assert references.get() <= 0;
		 assert peer == 0;
		 super.finalize();
	 }
	 public byte getByte(long offset) {
		 assert peer != 0;
		 return super.getByte(offset);
	 }
}",0,0,0,0
"public class PolylineConnection extends Polyline implements Connection,AnchorListener {
	private ConnectionAnchor startAnchor, endAnchor;
	private ConnectionRouter connectionRouter = ConnectionRouter.NULL;
	private RotatableDecoration startArrow, endArrow;
	{
		setLayoutManager(new DelegatingLayout());
		addPoint(new Point(0, 0));
		addPoint(new Point(100, 100));
	}
	public void addNotify() {
		super.addNotify();
		hookSourceAnchor();
		hookTargetAnchor();
	}
	public void addRoutingListener(RoutingListener listener) {
		if (connectionRouter instanceof RoutingNotifier) {
			RoutingNotifier notifier = (RoutingNotifier) connectionRouter;
			notifier.listeners.add(listener);
		}
		 elseconnectionRouter = new RoutingNotifier(connectionRouter, listener);
	}
	public void anchorMoved(ConnectionAnchor anchor) {
		revalidate();
	}
	public Rectangle getBounds() {
		if (bounds == null) {
			super.getBounds();
			for (int i = 0;
			 i < getChildren().size();
			 i++) {
				IFigure child = (IFigure) getChildren().get(i);
				bounds.union(child.getBounds());
			}
		}
		return bounds;
	}
	public ConnectionRouter getConnectionRouter() {
		if (connectionRouter instanceof RoutingNotifier)return ((RoutingNotifier) connectionRouter).realRouter;
		return connectionRouter;
	}
	public Object getRoutingConstraint() {
		if (getConnectionRouter() != null)return getConnectionRouter().getConstraint(this);
		elsereturn null;
	}
	public ConnectionAnchor getSourceAnchor() {
		return startAnchor;
	}
	protected RotatableDecoration getSourceDecoration() {
		return startArrow;
	}
	public ConnectionAnchor getTargetAnchor() {
		return endAnchor;
	}
	protected RotatableDecoration getTargetDecoration() {
		return endArrow;
	}
	private void hookSourceAnchor() {
		if (getSourceAnchor() != null)getSourceAnchor().addAnchorListener(this);
	}
	private void hookTargetAnchor() {
		if (getTargetAnchor() != null)getTargetAnchor().addAnchorListener(this);
	}
	public void layout() {
		if (getSourceAnchor() != null && getTargetAnchor() != null)connectionRouter.route(this);
		Rectangle oldBounds = bounds;
		super.layout();
		bounds = null;
		if (!getBounds().contains(oldBounds)) {
			getParent().translateToParent(oldBounds);
			getUpdateManager().addDirtyRegion(getParent(), oldBounds);
		}
		repaint();
		fireFigureMoved();
	}
	public void removeNotify() {
		unhookSourceAnchor();
		unhookTargetAnchor();
		connectionRouter.remove(this);
		super.removeNotify();
	}
	public void removeRoutingListener(RoutingListener listener) {
		if (connectionRouter instanceof RoutingNotifier) {
			RoutingNotifier notifier = (RoutingNotifier) connectionRouter;
			notifier.listeners.remove(listener);
			if (notifier.listeners.isEmpty())connectionRouter = notifier.realRouter;
		}
	}
	public void revalidate() {
		super.revalidate();
		connectionRouter.invalidate(this);
	}
	public void setConnectionRouter(ConnectionRouter cr) {
		if (cr == null)cr = ConnectionRouter.NULL;
		ConnectionRouter oldRouter = getConnectionRouter();
		if (oldRouter != cr) {
			connectionRouter.remove(this);
			if (connectionRouter instanceof RoutingNotifier)((RoutingNotifier) connectionRouter).realRouter = cr;
			elseconnectionRouter = cr;
			firePropertyChange(Connection.PROPERTY_CONNECTION_ROUTER,oldRouter, cr);
			revalidate();
		}
	}
	public void setRoutingConstraint(Object cons) {
		if (connectionRouter != null)connectionRouter.setConstraint(this, cons);
		revalidate();
	}
	public void setSourceAnchor(ConnectionAnchor anchor) {
		if (anchor == startAnchor)return;
		unhookSourceAnchor();
		startAnchor = anchor;
		if (getParent() != null)hookSourceAnchor();
		revalidate();
	}
	public void setSourceDecoration(RotatableDecoration dec) {
		if (startArrow == dec)return;
		if (startArrow != null)remove(startArrow);
		startArrow = dec;
		if (startArrow != null)add(startArrow, new ArrowLocator(this, ConnectionLocator.SOURCE));
	}
	public void setTargetAnchor(ConnectionAnchor anchor) {
		if (anchor == endAnchor)return;
		unhookTargetAnchor();
		endAnchor = anchor;
		if (getParent() != null)hookTargetAnchor();
		revalidate();
	}
	public void setTargetDecoration(RotatableDecoration dec) {
		if (endArrow == dec)return;
		if (endArrow != null)remove(endArrow);
		endArrow = dec;
		if (endArrow != null)add(endArrow, new ArrowLocator(this, ConnectionLocator.TARGET));
	}
	private void unhookSourceAnchor() {
		if (getSourceAnchor() != null)getSourceAnchor().removeAnchorListener(this);
	}
	private void unhookTargetAnchor() {
		if (getTargetAnchor() != null)getTargetAnchor().removeAnchorListener(this);
	}
	final class RoutingNotifier implements ConnectionRouter {
		ConnectionRouter realRouter;
		List listeners = new ArrayList(1);
		RoutingNotifier(ConnectionRouter router, RoutingListener listener) {
			realRouter = router;
			listeners.add(listener);
		}
		public Object getConstraint(Connection connection) {
			return realRouter.getConstraint(connection);
		}
		public void invalidate(Connection connection) {
			for (int i = 0;
			 i < listeners.size();
			 i++)((RoutingListener) listeners.get(i)).invalidate(connection);
			realRouter.invalidate(connection);
		}
		public void route(Connection connection) {
			boolean consumed = false;
			for (int i = 0;
			 i < listeners.size();
			 i++)consumed |= ((RoutingListener) listeners.get(i)).route(connection);
			if (!consumed)realRouter.route(connection);
			for (int i = 0;
			 i < listeners.size();
			 i++)((RoutingListener) listeners.get(i)).postRoute(connection);
		}
		public void remove(Connection connection) {
			for (int i = 0;
			 i < listeners.size();
			 i++)((RoutingListener) listeners.get(i)).remove(connection);
			realRouter.remove(connection);
		}
		public void setConstraint(Connection connection, Object constraint) {
			for (int i = 0;
			 i < listeners.size();
			 i++)((RoutingListener) listeners.get(i)).setConstraint(connection,constraint);
			realRouter.setConstraint(connection, constraint);
		}
	}
}",1,1,0,0
"public abstract class AbstractClientProvider {
	 public AbstractClientProvider() {
	 }
	 public static final Set<String> createApplicationTags(String appName, String appVersion, String appDescription) {
		 Set<String> tags = new HashSet<>();
		 tags.add(ServiceUtils.createNameTag(appName));
		 if (appVersion != null) {
			 tags.add(ServiceUtils.createVersionTag(appVersion));
		 }
		 if (appDescription != null) {
			 tags.add(ServiceUtils.createDescriptionTag(appDescription));
		 }
		 return tags;
	 }
	 public abstract void validateArtifact(Artifact artifact, String compName, FileSystem fileSystem) throws IOException;
	 protected abstract void validateConfigFile(ConfigFile configFile, String compName, FileSystem fileSystem) throws IOException;
	 public void validateConfigFiles(List<ConfigFile> configFiles, String compName, FileSystem fs) throws IOException {
		 Set<String> destFileSet = new HashSet<>();
		 for (ConfigFile file : configFiles) {
			 if (file.getType() == null) {
				 throw new IllegalArgumentException(""File type is empty"");
			 }
			 ConfigFile.TypeEnum fileType = file.getType();
			 if (fileType.equals(ConfigFile.TypeEnum.TEMPLATE)) {
				 if (StringUtils.isEmpty(file.getSrcFile()) && !file.getProperties().containsKey(CONTENT)) {
					 throw new IllegalArgumentException(MessageFormat.format(""For {
					0}
					 "" + ""format, either src_file must be specified in ConfigFile,"" + "" or the \""{
					1}
					\"" key must be specified in "" + ""the 'properties' field of ConfigFile. "", ConfigFile.TypeEnum.TEMPLATE, CONTENT));
				 }
			 }
			 else if (fileType.equals(ConfigFile.TypeEnum.STATIC) || fileType.equals( ConfigFile.TypeEnum.ARCHIVE)) {
				 if (!file.getProperties().isEmpty()) {
					 throw new IllegalArgumentException(String .format(""For %s format, should not specify any 'properties.'"", fileType));
				 }
				 String srcFile = file.getSrcFile();
				 if (srcFile == null || srcFile.isEmpty()) {
					 throw new IllegalArgumentException(String.format( ""For %s format, should make sure that srcFile is specified"", fileType));
				 }
				 FileStatus fileStatus = fs.getFileStatus(new Path(srcFile));
				 if (fileStatus != null && fileStatus.isDirectory()) {
					 throw new IllegalArgumentException(""srcFile="" + srcFile + "" is a directory, which is not supported."");
				 }
			 }
			 if (!StringUtils.isEmpty(file.getSrcFile())) {
				 Path p = new Path(file.getSrcFile());
				 if (!fs.exists(p)) {
					 throw new IllegalArgumentException( ""Specified src_file does not exist on "" + fs.getScheme() + "": "" + file.getSrcFile());
				 }
			 }
			 if (StringUtils.isEmpty(file.getDestFile())) {
				 throw new IllegalArgumentException(""dest_file is empty."");
			 }
			 if (destFileSet.contains(file.getDestFile())) {
				 throw new IllegalArgumentException( ""Duplicated ConfigFile exists: "" + file.getDestFile());
			 }
			 destFileSet.add(file.getDestFile());
			 java.nio.file.Path destPath = Paths.get(file.getDestFile());
			 if (!destPath.isAbsolute() && destPath.getNameCount() > 1) {
				 throw new IllegalArgumentException(""Non-absolute dest_file has more "" + ""than one path element"");
			 }
			 validateConfigFile(file, compName, fs);
		 }
	 }
}",1,0,0,0
"abstract class ReferenceLookupHelper extends LookupHelper {
	 JCMemberReference referenceTree;
	 ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site, List<Type> argtypes, List<Type> typeargtypes, MethodResolutionPhase maxPhase) {
		 super(name, site, argtypes, typeargtypes, maxPhase);
		 this.referenceTree = referenceTree;
	 }
	 ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
		 return null;
	 }
	 abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
	 Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym) {
		 if (sym.kind == AMBIGUOUS) {
			 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
			 sym = a_err.mergeAbstracts(site);
		 }
		 return sym;
	 }
 }",0,0,0,0
"public class DTDLocation extends ResourceLocation {
}",0,0,0,0
"public class CheckpointStatsSnapshot implements Serializable {
	private static final long serialVersionUID = 8914278419087217964L;
	private final CheckpointStatsCounts counts;
	private final CompletedCheckpointStatsSummary summary;
	private final CheckpointStatsHistory history;
	private final RestoredCheckpointStats latestRestoredCheckpoint;
	CheckpointStatsSnapshot(CheckpointStatsCounts counts,CompletedCheckpointStatsSummary summary,CheckpointStatsHistory history, RestoredCheckpointStats latestRestoredCheckpoint) {
		this.counts = checkNotNull(counts);
		this.summary= checkNotNull(summary);
		this.history = checkNotNull(history);
		this.latestRestoredCheckpoint = latestRestoredCheckpoint;
	}
	public CheckpointStatsCounts getCounts() {
		return counts;
	}
	public CompletedCheckpointStatsSummary getSummaryStats() {
		return summary;
	}
	public CheckpointStatsHistory getHistory() {
		return history;
	}
	public RestoredCheckpointStats getLatestRestoredCheckpoint() {
		return latestRestoredCheckpoint;
	}
}",0,0,0,0
"public TokenFilter getFilter(TokenStream ts, String field) {
	 return new Filter(ts, (HashSet)commonTerms.get(field));
 }",0,0,0,0
"public static ByteBuffer toUTF8Bytes(UUID version) {
	 return ByteBuffer.wrap(version.toString().getBytes(UTF_8));
 }",0,0,0,0
public void setAggregatedItemsPaint(Paint paint);,0,0,0,0
"public DatanodeInfo[] getDataNodeStats() throws IOException {
	 return dfs.datanodeReport();
 }",0,0,0,0
"protected void createAndShowGUI() {
	 System.setProperty(""swing.defaultlaf"", UIManager.getSystemLookAndFeelClassName());
	 SystemTray tray = SystemTray.getSystemTray();
	 image = DavGatewayTray.loadImage(getTrayIconPath());
	 image2 = DavGatewayTray.loadImage(getTrayIconActivePath());
	 inactiveImage = DavGatewayTray.loadImage(getTrayIconInactivePath());
	 PopupMenu popup = new PopupMenu();
	 aboutFrame = new AboutFrame();
	 ActionListener aboutListener = new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 about();
		 }
	 }
	;
	 MenuItem aboutItem = new MenuItem(BundleMessage.format(""UI_ABOUT""));
	 aboutItem.addActionListener(aboutListener);
	 popup.add(aboutItem);
	 settingsFrame = new SettingsFrame();
	 settingsListener = new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 preferences();
		 }
	 }
	;
	 MenuItem defaultItem = new MenuItem(BundleMessage.format(""UI_SETTINGS""));
	 defaultItem.addActionListener(settingsListener);
	 popup.add(defaultItem);
	 MenuItem logItem = new MenuItem(BundleMessage.format(""UI_SHOW_LOGS""));
	 logItem.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 Logger rootLogger = Logger.getRootLogger();
			 LF5Appender lf5Appender = (LF5Appender) rootLogger.getAppender(""LF5Appender"");
			 if (lf5Appender == null) {
				 logBrokerMonitor = new LogBrokerMonitor(LogLevel.getLog4JLevels()) {
					 protected void closeAfterConfirm() {
						 hide();
					 }
				 }
				;
				 lf5Appender = new LF5Appender(logBrokerMonitor);
				 lf5Appender.setName(""LF5Appender"");
				 rootLogger.addAppender(lf5Appender);
			 }
			 lf5Appender.getLogBrokerMonitor().show();
		 }
	 }
	);
	 popup.add(logItem);
	 ActionListener exitListener = new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 try {
				 DavGateway.stop();
			 }
			 catch (Exception exc) {
				 DavGatewayTray.error(exc);
			 }
			 System.exit(0);
		 }
	 }
	;
	 MenuItem exitItem = new MenuItem(BundleMessage.format(""UI_EXIT""));
	 exitItem.addActionListener(exitListener);
	 popup.add(exitItem);
	 trayIcon = new TrayIcon(image, BundleMessage.format(""UI_DAVMAIL_GATEWAY""), popup);
	 trayIcon.addActionListener(settingsListener);
	 try {
		 tray.add(trayIcon);
	 }
	 catch (AWTException e) {
		 DavGatewayTray.warn(new BundleMessage(""LOG_UNABLE_TO_CREATE_TRAY""), e);
	 }
	 if (Settings.isFirstStart()) {
		 settingsFrame.setVisible(true);
		 settingsFrame.toFront();
		 settingsFrame.repaint();
		 settingsFrame.requestFocus();
	 }
 }",0,0,1,0
"public final class CorePlugin extends Plugin {
	 public static final String PLUGIN_ID = ""org.eclipse.buildship.core"";
	 public static final String GRADLE_JOB_FAMILY = PLUGIN_ID + "".jobs"";
	 private static CorePlugin plugin;
	 private ServiceRegistration loggerService;
	 private ServiceRegistration publishedGradleVersionsService;
	 private ServiceRegistration workspaceOperationsService;
	 private ServiceRegistration internalGradleWorkspaceService;
	 private ServiceRegistration processStreamsProviderService;
	 private ServiceRegistration gradleLaunchConfigurationService;
	 private ServiceRegistration listenerRegistryService;
	 private ServiceTracker loggerServiceTracker;
	 private ServiceTracker publishedGradleVersionsServiceTracker;
	 private ServiceTracker workspaceOperationsServiceTracker;
	 private ServiceTracker internalGradleWorkspaceServiceTracker;
	 private ServiceTracker processStreamsProviderServiceTracker;
	 private ServiceTracker gradleLaunchConfigurationServiceTracker;
	 private ServiceTracker listenerRegistryServiceTracker;
	 private DefaultModelPersistence modelPersistence;
	 private ProjectChangeListener projectChangeListener;
	 private SynchronizingBuildScriptUpdateListener buildScriptUpdateListener;
	 private InvocationCustomizer invocationCustomizer;
	 private ConfigurationManager configurationManager;
	 private DefaultExternalLaunchConfigurationManager externalLaunchConfigurationManager;
	 private ToolingApiOperationManager operationManager;
	 private ExtensionManager extensionManager;
	 public void start(BundleContext bundleContext) throws Exception {
		 super.start(bundleContext);
		 plugin = this;
		 ensureProxySettingsApplied();
		 registerServices(bundleContext);
	 }
	 public void stop(BundleContext context) throws Exception {
		 unregisterServices();
		 plugin = null;
		 super.stop(context);
	 }
	 private void ensureProxySettingsApplied() throws Exception {
		 Platform.getBundle(""org.eclipse.core.net"").start(Bundle.START_TRANSIENT);
	 }
	 private void registerServices(BundleContext context) {
		 Dictionary<String, Object> preferences = new Hashtable<>();
		 preferences.put(Constants.SERVICE_RANKING, 1);
		 this.loggerServiceTracker = createServiceTracker(context, Logger.class);
		 this.publishedGradleVersionsServiceTracker = createServiceTracker(context, PublishedGradleVersionsWrapper.class);
		 this.workspaceOperationsServiceTracker = createServiceTracker(context, WorkspaceOperations.class);
		 this.internalGradleWorkspaceServiceTracker = createServiceTracker(context, InternalGradleWorkspace.class);
		 this.processStreamsProviderServiceTracker = createServiceTracker(context, ProcessStreamsProvider.class);
		 this.gradleLaunchConfigurationServiceTracker = createServiceTracker(context, GradleLaunchConfigurationManager.class);
		 this.listenerRegistryServiceTracker = createServiceTracker(context, ListenerRegistry.class);
		 this.loggerService = registerService(context, Logger.class, createLogger(), preferences);
		 this.publishedGradleVersionsService = registerService(context, PublishedGradleVersionsWrapper.class, createPublishedGradleVersions(), preferences);
		 this.workspaceOperationsService = registerService(context, WorkspaceOperations.class, createWorkspaceOperations(), preferences);
		 this.internalGradleWorkspaceService = registerService(context, InternalGradleWorkspace.class, createGradleWorkspace(), preferences);
		 this.processStreamsProviderService = registerService(context, ProcessStreamsProvider.class, createProcessStreamsProvider(), preferences);
		 this.gradleLaunchConfigurationService = registerService(context, GradleLaunchConfigurationManager.class, createGradleLaunchConfigurationManager(), preferences);
		 this.listenerRegistryService = registerService(context, ListenerRegistry.class, createListenerRegistry(), preferences);
		 this.modelPersistence = DefaultModelPersistence.createAndRegister();
		 this.projectChangeListener = ProjectChangeListener.createAndRegister();
		 this.buildScriptUpdateListener = SynchronizingBuildScriptUpdateListener.createAndRegister();
		 this.invocationCustomizer = new InvocationCustomizerCollector();
		 this.configurationManager = new DefaultConfigurationManager();
		 this.externalLaunchConfigurationManager = DefaultExternalLaunchConfigurationManager.createAndRegister();
		 this.operationManager = new DefaultToolingApiOperationManager();
		 this.extensionManager = new DefaultExtensionManager();
	 }
	 private ServiceTracker createServiceTracker(BundleContext context, Class<?> clazz) {
		 ServiceTracker serviceTracker = new ServiceTracker(context, clazz.getName(), null);
		 serviceTracker.open();
		 return serviceTracker;
	 }
	 private <T> ServiceRegistration registerService(BundleContext context, Class<T> clazz, T service, Dictionary<String, Object> properties) {
		 return context.registerService(clazz.getName(), service, properties);
	 }
	 private EclipseLogger createLogger() {
		 Map<TraceScope, Boolean> tracingEnablement = Maps.newHashMap();
		 for (TraceScope scope : CoreTraceScopes.values()) {
			 String option = Platform.getDebugOption(""org.eclipse.buildship.core/trace/"" + scope.getScopeKey());
			 tracingEnablement.put(scope, ""true"".equalsIgnoreCase(option));
		 }
		 return new EclipseLogger(getLog(), PLUGIN_ID, tracingEnablement);
	 }
	 private PublishedGradleVersionsWrapper createPublishedGradleVersions() {
		 return new PublishedGradleVersionsWrapper();
	 }
	 private WorkspaceOperations createWorkspaceOperations() {
		 return new DefaultWorkspaceOperations();
	 }
	 private InternalGradleWorkspace createGradleWorkspace() {
		 return new DefaultGradleWorkspace();
	 }
	 private ProcessStreamsProvider createProcessStreamsProvider() {
		 return new StdProcessStreamsProvider();
	 }
	 private GradleLaunchConfigurationManager createGradleLaunchConfigurationManager() {
		 return new DefaultGradleLaunchConfigurationManager();
	 }
	 private ListenerRegistry createListenerRegistry() {
		 return new DefaultListenerRegistry();
	 }
	 private void unregisterServices() {
		 this.externalLaunchConfigurationManager.unregister();
		 this.buildScriptUpdateListener.close();
		 this.projectChangeListener.close();
		 this.modelPersistence.close();
		 this.listenerRegistryService.unregister();
		 this.gradleLaunchConfigurationService.unregister();
		 this.processStreamsProviderService.unregister();
		 this.internalGradleWorkspaceService.unregister();
		 this.workspaceOperationsService.unregister();
		 this.publishedGradleVersionsService.unregister();
		 this.loggerService.unregister();
		 this.listenerRegistryServiceTracker.close();
		 this.gradleLaunchConfigurationServiceTracker.close();
		 this.processStreamsProviderServiceTracker.close();
		 this.internalGradleWorkspaceServiceTracker.close();
		 this.workspaceOperationsServiceTracker.close();
		 this.publishedGradleVersionsServiceTracker.close();
		 this.loggerServiceTracker.close();
	 }
	 public static CorePlugin getInstance() {
		 return plugin;
	 }
	 public static Logger logger() {
		 return (Logger) getInstance().loggerServiceTracker.getService();
	 }
	 public static PublishedGradleVersionsWrapper publishedGradleVersions() {
		 return (PublishedGradleVersionsWrapper) getInstance().publishedGradleVersionsServiceTracker.getService();
	 }
	 public static WorkspaceOperations workspaceOperations() {
		 return (WorkspaceOperations) getInstance().workspaceOperationsServiceTracker.getService();
	 }
	 public static InternalGradleWorkspace internalGradleWorkspace() {
		 return (InternalGradleWorkspace) getInstance().internalGradleWorkspaceServiceTracker.getService();
	 }
	 public static ProcessStreamsProvider processStreamsProvider() {
		 return (ProcessStreamsProvider) getInstance().processStreamsProviderServiceTracker.getService();
	 }
	 public static GradleLaunchConfigurationManager gradleLaunchConfigurationManager() {
		 return (GradleLaunchConfigurationManager) getInstance().gradleLaunchConfigurationServiceTracker.getService();
	 }
	 public static ListenerRegistry listenerRegistry() {
		 return (ListenerRegistry) getInstance().listenerRegistryServiceTracker.getService();
	 }
	 public static ModelPersistence modelPersistence() {
		 return getInstance().modelPersistence;
	 }
	 public static InvocationCustomizer invocationCustomizer() {
		 return getInstance().invocationCustomizer;
	 }
	 public static ConfigurationManager configurationManager() {
		 return getInstance().configurationManager;
	 }
	 public static ExternalLaunchConfigurationManager externalLaunchConfigurationManager() {
		 return getInstance().externalLaunchConfigurationManager;
	 }
	 public static ToolingApiOperationManager operationManager() {
		 return getInstance().operationManager;
	 }
	 public static ExtensionManager extensionManager() {
		 return getInstance().extensionManager;
	 }
}",1,0,0,0
"public static char[] add(char[] array, StringBuilder stringBuilder) {
	 return add(array, getCharsFromStringBuilder(stringBuilder));
 }",0,0,0,0
"LogFileLoader(final String path, Instant start, Instant end) {
	 super(path);
	 this.grokCompiler = GrokCompiler.newInstance();
	 this.grokCompiler.registerDefaultPatterns();
	 this.grokCompiler.registerPatternFromClasspath(""/patterns/log-patterns"");
	 this.grok = grokCompiler.compile(logFormat, true);
	 this.start = start;
	 this.end = end;
	 this.parsingErrors = new StringListColumn( new ColumnDescription(parseErrorColumn, ContentsKind.String));
	 this.lineNumber = new IntListColumn( new ColumnDescription(lineNumberColumn, ContentsKind.Integer));
	 String originalPattern = this.grok.getOriginalGrokPattern();
	 String timestampPattern = GrokExtra.extractGroupPattern( this.grokCompiler.getPatternDefinitions(), originalPattern, GenericLogs.timestampColumnName);
	 if (timestampPattern == null) {
		 HillviewLogger.instance.warn(""Pattern does not contain column named 'Timestamp'"", ""{
		0}
		"", originalPattern);
		 this.dateTime = null;
	 }
	 else {
		 this.dateTime = this.grokCompiler.compile( ""%{
		"" + timestampPattern + "":"" + GenericLogs.timestampColumnName + ""}
		"", true);
	 }
 }",0,0,1,0
"public void execute() throws BuildException {
	 if (bundle == null) {
		 throw new BuildException(""The bundle attribute must be set."", getLocation());
	 }
	 if (startToken == null) {
		 throw new BuildException(""The starttoken attribute must be set."", getLocation());
	 }
	 if (endToken == null) {
		 throw new BuildException(""The endtoken attribute must be set."", getLocation());
	 }
	 if (bundleLanguage == null) {
		 Locale l = Locale.getDefault();
		 bundleLanguage = l.getLanguage();
	 }
	 if (bundleCountry == null) {
		 bundleCountry = Locale.getDefault().getCountry();
	 }
	 if (bundleVariant == null) {
		 Locale l = new Locale(bundleLanguage, bundleCountry);
		 bundleVariant = l.getVariant();
	 }
	 if (toDir == null) {
		 throw new BuildException(""The todir attribute must be set."", getLocation());
	 }
	 if (!toDir.exists()) {
		 toDir.mkdirs();
	 }
	 else if (toDir.isFile()) {
		 throw new BuildException(toDir + "" is not a directory"");
	 }
	 if (srcEncoding == null) {
		 srcEncoding = System.getProperty(""file.encoding"");
	 }
	 if (destEncoding == null) {
		 destEncoding = srcEncoding;
	 }
	 if (bundleEncoding == null) {
		 bundleEncoding = srcEncoding;
	 }
	 loadResourceMaps();
	 translate();
 }",0,0,0,0
"public static void main(String[] args) throws IOException, InterruptedException, ConfigurationException, ParseException {
	 CommandLineParser parser = new PosixParser();
	 ToolCommandLine cmd = null;
	 try {
		 cmd = new ToolCommandLine(parser.parse(options, args));
	 }
	 catch (ParseException p) {
		 badUse(p.getMessage());
	 }
	 String host = cmd.hasOption(HOST_OPT.left) ? cmd.getOptionValue(HOST_OPT.left) : DEFAULT_HOST;
	 int port = DEFAULT_PORT;
	 String portNum = cmd.getOptionValue(PORT_OPT.left);
	 if (portNum != null) {
		 try {
			 port = Integer.parseInt(portNum);
		 }
		 catch (NumberFormatException e) {
			 throw new ParseException(""Port must be a number"");
		 }
	 }
	 String username = cmd.getOptionValue(USERNAME_OPT.left);
	 String password = cmd.getOptionValue(PASSWORD_OPT.left);
	 NodeProbe probe = null;
	 try {
		 probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);
	 }
	 catch (IOException ioe) {
		 err(ioe, ""Error connection to remote JMX agent!"");
	 }
	 try {
		 NodeCommand command = null;
		 try {
			 command = cmd.getCommand();
		 }
		 catch (IllegalArgumentException e) {
			 badUse(e.getMessage());
		 }
		 NodeCmd nodeCmd = new NodeCmd(probe);
		 String[] arguments = cmd.getCommandArguments();
		 switch (command) {
			 case RING : if (arguments.length > 0) {
				 nodeCmd.printRing(System.out, arguments[0]);
			 }
			 else {
				 nodeCmd.printRing(System.out, null);
			 }
			;
			 break;
			 case INFO : nodeCmd.printInfo(System.out);
			 break;
			 case CFSTATS : nodeCmd.printColumnFamilyStats(System.out);
			 break;
			 case DECOMMISSION : probe.decommission();
			 break;
			 case TPSTATS : nodeCmd.printThreadPoolStats(System.out);
			 break;
			 case VERSION : nodeCmd.printReleaseVersion(System.out);
			 break;
			 case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out);
			 break;
			 case DISABLEGOSSIP : probe.stopGossiping();
			 break;
			 case ENABLEGOSSIP : probe.startGossiping();
			 break;
			 case DISABLETHRIFT : probe.stopThriftServer();
			 break;
			 case ENABLETHRIFT : probe.startThriftServer();
			 break;
			 case STATUSTHRIFT : nodeCmd.printIsThriftServerRunning(System.out);
			 break;
			 case RESETLOCALSCHEMA: probe.resetLocalSchema();
			 break;
			 case DRAIN : try {
				 probe.drain();
			 }
			 catch (ExecutionException ee) {
				 err(ee, ""Error occured during flushing"");
			 }
			 break;
			 case NETSTATS : if (arguments.length > 0) {
				 nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]), System.out);
			 }
			 else {
				 nodeCmd.printNetworkStats(null, System.out);
			 }
			 break;
			 case SNAPSHOT : case CLEARSNAPSHOT : String tag = cmd.getOptionValue(TAG_OPT.left);
			 handleSnapshots(command, tag, arguments, probe);
			 break;
			 case MOVE : if (arguments.length != 1) {
				 badUse(""Missing token argument for move."");
			 }
			 probe.move(arguments[0]);
			 break;
			 case JOIN: if (probe.isJoined()) {
				 System.err.println(""This node has already joined the ring."");
				 System.exit(1);
			 }
			 probe.joinRing();
			 break;
			 case SETCOMPACTIONTHROUGHPUT : if (arguments.length != 1) {
				 badUse(""Missing value argument."");
			 }
			 probe.setCompactionThroughput(Integer.valueOf(arguments[0]));
			 break;
			 case SETSTREAMTHROUGHPUT : if (arguments.length != 1) {
				 badUse(""Missing value argument."");
			 }
			 probe.setStreamThroughput(Integer.valueOf(arguments[0]));
			 break;
			 case REBUILD : if (arguments.length > 1) {
				 badUse(""Too many arguments."");
			 }
			 probe.rebuild(arguments.length == 1 ? arguments[0] : null);
			 break;
			 case REMOVETOKEN : if (arguments.length != 1) {
				 badUse(""Missing an argument for removetoken (either status, force, or a token)"");
			 }
			 else if (arguments[0].equals(""status"")) {
				 nodeCmd.printRemovalStatus(System.out);
			 }
			 else if (arguments[0].equals(""force"")) {
				 nodeCmd.printRemovalStatus(System.out);
				 probe.forceRemoveCompletion();
			 }
			 else {
				 probe.removeToken(arguments[0]);
			 }
			 break;
			 case INVALIDATEKEYCACHE : probe.invalidateKeyCache();
			 break;
			 case INVALIDATEROWCACHE : probe.invalidateRowCache();
			 break;
			 case CLEANUP : case COMPACT : case REPAIR : case FLUSH : case SCRUB : case UPGRADESSTABLES : optionalKSandCFs(command, cmd, arguments, probe);
			 break;
			 case GETCOMPACTIONTHRESHOLD : if (arguments.length != 2) {
				 badUse(""getcompactionthreshold requires ks and cf args."");
			 }
			 probe.getCompactionThreshold(System.out, arguments[0], arguments[1]);
			 break;
			 case CFHISTOGRAMS : if (arguments.length != 2) {
				 badUse(""cfhistograms requires ks and cf args"");
			 }
			 nodeCmd.printCfHistograms(arguments[0], arguments[1], System.out);
			 break;
			 case SETCACHECAPACITY : if (arguments.length != 4) {
				 badUse(""setcachecapacity requires ks, cf, keycachecap, and rowcachecap args."");
			 }
			 probe.setCacheCapacities(arguments[0], arguments[1], Integer.parseInt(arguments[2]), Integer.parseInt(arguments[3]));
			 break;
			 case SETCOMPACTIONTHRESHOLD : if (arguments.length != 4) {
				 badUse(""setcompactionthreshold requires ks, cf, min, and max threshold args."");
			 }
			 int minthreshold = Integer.parseInt(arguments[2]);
			 int maxthreshold = Integer.parseInt(arguments[3]);
			 if ((minthreshold < 0) || (maxthreshold < 0)) {
				 badUse(""Thresholds must be positive integers"");
			 }
			 if (minthreshold > maxthreshold) {
				 badUse(""Min threshold cannot be greater than max."");
			 }
			 if (minthreshold < 2 && maxthreshold != 0) {
				 badUse(""Min threshold must be at least 2"");
			 }
			 probe.setCompactionThreshold(arguments[0], arguments[1], minthreshold, maxthreshold);
			 break;
			 case GETENDPOINTS : if (arguments.length != 3) {
				 badUse(""getendpoints requires ks, cf and key args"");
			 }
			 nodeCmd.printEndPoints(arguments[0], arguments[1], arguments[2], System.out);
			 break;
			 case REFRESH: if (arguments.length != 2) {
				 badUse(""load_new_sstables requires ks and cf args"");
			 }
			 probe.loadNewSSTables(arguments[0], arguments[1]);
			 break;
			 case REBUILD_INDEX: if (arguments.length < 2) {
				 badUse(""rebuild_index requires ks and cf args"");
			 }
			 if (arguments.length >= 3) probe.rebuildIndex(arguments[0], arguments[1], arguments[2].split("",""));
			 else probe.rebuildIndex(arguments[0], arguments[1]);
			 break;
			 case GOSSIPINFO : nodeCmd.printGossipInfo(System.out);
			 break;
			 case STOP: if (arguments.length != 1) {
				 badUse(""stop requires a type."");
			 }
			 probe.stop(arguments[0].toUpperCase());
			 break;
			 case DESCRIBERING : if (arguments.length != 1) {
				 badUse(""Missing keyspace argument for describering."");
			 }
			 nodeCmd.printDescribeRing(arguments[0], System.out);
			 break;
			 case RANGEKEYSAMPLE : nodeCmd.printRangeKeySample(System.out);
			 break;
			 default : throw new RuntimeException(""Unreachable code."");
		 }
	 }
	 finally {
		 if (probe != null) {
			 try {
				 probe.close();
			 }
			 catch (IOException ex) {
			 }
		 }
	 }
	 System.exit(0);
 }",0,0,1,0
"protected void onValidateModelObjects(){
}",0,0,0,0
"public class LateralGroupCacheJGListener extends LateralCacheJGListener implements ILateralCacheJGListener{
	 private static final Log log = LogFactory.getLog( LateralGroupCacheJGListener.class );
	 protected LateralGroupCacheJGListener( ILateralCacheAttributes ilca ) {
		 super( ilca );
		 log.debug( ""creating LateralGroupCacheJGListener"" );
	 }
	 public static ILateralCacheListener getInstance( ILateralCacheAttributes ilca ) {
		 ILateralCacheListener ins = (ILateralCacheListener) instances .get( String.valueOf( ilca.getUdpMulticastAddr() ) );
		 synchronized ( LateralGroupCacheJGListener.class ) {
			 if ( ins == null ) {
				 ins = new LateralGroupCacheJGListener( ilca );
				 ins.init();
			 }
			 if ( log.isDebugEnabled() ) {
				 log.debug( ""created new listener "" + ilca.getUdpMulticastAddr() );
			 }
			 instances.put( String.valueOf( ilca.getUdpMulticastAddr() ), ins );
		 }
		 return ins;
	 }
	 protected void ensureCacheManager() {
		 try {
			 if ( cacheMgr == null ) {
				 cacheMgr = CompositeCacheManager.getInstance();
				 if ( log.isDebugEnabled() ) {
					 log.debug( "" groupcache cacheMgr = "" + cacheMgr );
				 }
			 }
			 else {
				 if ( log.isDebugEnabled() ) {
					 log.debug( ""already got groupcache cacheMgr = "" + cacheMgr );
				 }
			 }
		 }
		 catch ( Exception e ) {
			 log.error( e );
		 }
	 }
}",0,0,0,0
"public final class C {
	 private C() {
	}
	 public static final long TIME_END_OF_SOURCE = Long.MIN_VALUE;
	 public static final long TIME_UNSET = Long.MIN_VALUE + 1;
	 public static final int INDEX_UNSET = -1;
	 public static final int POSITION_UNSET = -1;
	 public static final int LENGTH_UNSET = -1;
	 public static final int PERCENTAGE_UNSET = -1;
	 public static final long MICROS_PER_SECOND = 1000000L;
	 public static final long NANOS_PER_SECOND = 1000000000L;
	 public static final int BITS_PER_BYTE = 8;
	 public static final int BYTES_PER_FLOAT = 4;
	 public static final String ASCII_NAME = ""US-ASCII"";
	 public static final String UTF8_NAME = ""UTF-8"";
	 public static final String UTF16_NAME = ""UTF-16"";
	 public static final String SERIF_NAME = ""serif"";
	 public static final String SANS_SERIF_NAME = ""sans-serif"";
	 public CryptoMode {
	}
	 public static final int CRYPTO_MODE_UNENCRYPTED = MediaCodec.CRYPTO_MODE_UNENCRYPTED;
	 public static final int CRYPTO_MODE_AES_CTR = MediaCodec.CRYPTO_MODE_AES_CTR;
	 public static final int CRYPTO_MODE_AES_CBC = MediaCodec.CRYPTO_MODE_AES_CBC;
	 public static final int AUDIO_SESSION_ID_UNSET = AudioManager.AUDIO_SESSION_ID_GENERATE;
	 public Encoding {
	}
	 public PcmEncoding {
	}
	 public static final int ENCODING_INVALID = AudioFormat.ENCODING_INVALID;
	 public static final int ENCODING_PCM_8BIT = AudioFormat.ENCODING_PCM_8BIT;
	 public static final int ENCODING_PCM_16BIT = AudioFormat.ENCODING_PCM_16BIT;
	 public static final int ENCODING_PCM_24BIT = 0x80000000;
	 public static final int ENCODING_PCM_32BIT = 0x40000000;
	 public static final int ENCODING_PCM_FLOAT = AudioFormat.ENCODING_PCM_FLOAT;
	 public static final int ENCODING_PCM_MU_LAW = 0x10000000;
	 public static final int ENCODING_PCM_A_LAW = 0x20000000;
	 public static final int ENCODING_AC3 = AudioFormat.ENCODING_AC3;
	 public static final int ENCODING_E_AC3 = AudioFormat.ENCODING_E_AC3;
	 public static final int ENCODING_DTS = AudioFormat.ENCODING_DTS;
	 public static final int ENCODING_DTS_HD = AudioFormat.ENCODING_DTS_HD;
	 public static final int ENCODING_DOLBY_TRUEHD = AudioFormat.ENCODING_DOLBY_TRUEHD;
	 public StreamType {
	}
	 public static final int STREAM_TYPE_ALARM = AudioManager.STREAM_ALARM;
	 public static final int STREAM_TYPE_DTMF = AudioManager.STREAM_DTMF;
	 public static final int STREAM_TYPE_MUSIC = AudioManager.STREAM_MUSIC;
	 public static final int STREAM_TYPE_NOTIFICATION = AudioManager.STREAM_NOTIFICATION;
	 public static final int STREAM_TYPE_RING = AudioManager.STREAM_RING;
	 public static final int STREAM_TYPE_SYSTEM = AudioManager.STREAM_SYSTEM;
	 public static final int STREAM_TYPE_VOICE_CALL = AudioManager.STREAM_VOICE_CALL;
	 public static final int STREAM_TYPE_USE_DEFAULT = AudioManager.USE_DEFAULT_STREAM_TYPE;
	 public static final int STREAM_TYPE_DEFAULT = STREAM_TYPE_MUSIC;
	 public AudioContentType {
	}
	 public static final int CONTENT_TYPE_MOVIE = android.media.AudioAttributes.CONTENT_TYPE_MOVIE;
	 public static final int CONTENT_TYPE_MUSIC = android.media.AudioAttributes.CONTENT_TYPE_MUSIC;
	 public static final int CONTENT_TYPE_SONIFICATION = android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION;
	 public static final int CONTENT_TYPE_SPEECH = android.media.AudioAttributes.CONTENT_TYPE_SPEECH;
	 public static final int CONTENT_TYPE_UNKNOWN = android.media.AudioAttributes.CONTENT_TYPE_UNKNOWN;
	 public AudioFlags {
	}
	 public static final int FLAG_AUDIBILITY_ENFORCED = android.media.AudioAttributes.FLAG_AUDIBILITY_ENFORCED;
	 public AudioUsage {
	}
	 public static final int USAGE_ALARM = android.media.AudioAttributes.USAGE_ALARM;
	 public static final int USAGE_ASSISTANCE_ACCESSIBILITY = android.media.AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY;
	 public static final int USAGE_ASSISTANCE_NAVIGATION_GUIDANCE = android.media.AudioAttributes.USAGE_ASSISTANCE_NAVIGATION_GUIDANCE;
	 public static final int USAGE_ASSISTANCE_SONIFICATION = android.media.AudioAttributes.USAGE_ASSISTANCE_SONIFICATION;
	 public static final int USAGE_ASSISTANT = android.media.AudioAttributes.USAGE_ASSISTANT;
	 public static final int USAGE_GAME = android.media.AudioAttributes.USAGE_GAME;
	 public static final int USAGE_MEDIA = android.media.AudioAttributes.USAGE_MEDIA;
	 public static final int USAGE_NOTIFICATION = android.media.AudioAttributes.USAGE_NOTIFICATION;
	 public static final int USAGE_NOTIFICATION_COMMUNICATION_DELAYED = android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_DELAYED;
	 public static final int USAGE_NOTIFICATION_COMMUNICATION_INSTANT = android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_INSTANT;
	 public static final int USAGE_NOTIFICATION_COMMUNICATION_REQUEST = android.media.AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_REQUEST;
	 public static final int USAGE_NOTIFICATION_EVENT = android.media.AudioAttributes.USAGE_NOTIFICATION_EVENT;
	 public static final int USAGE_NOTIFICATION_RINGTONE = android.media.AudioAttributes.USAGE_NOTIFICATION_RINGTONE;
	 public static final int USAGE_UNKNOWN = android.media.AudioAttributes.USAGE_UNKNOWN;
	 public static final int USAGE_VOICE_COMMUNICATION = android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION;
	 public static final int USAGE_VOICE_COMMUNICATION_SIGNALLING = android.media.AudioAttributes.USAGE_VOICE_COMMUNICATION_SIGNALLING;
	 public AudioFocusGain {
	}
	 public static final int AUDIOFOCUS_NONE = AudioManager.AUDIOFOCUS_NONE;
	 public static final int AUDIOFOCUS_GAIN = AudioManager.AUDIOFOCUS_GAIN;
	 public static final int AUDIOFOCUS_GAIN_TRANSIENT = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT;
	 public static final int AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK;
	 public static final int AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE = AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
	 public BufferFlags {
	}
	 public static final int BUFFER_FLAG_KEY_FRAME = MediaCodec.BUFFER_FLAG_KEY_FRAME;
	 public static final int BUFFER_FLAG_END_OF_STREAM = MediaCodec.BUFFER_FLAG_END_OF_STREAM;
	 public static final int BUFFER_FLAG_LAST_SAMPLE = 1 << 29;
	 public static final int BUFFER_FLAG_ENCRYPTED = 1 << 30;
	 public static final int BUFFER_FLAG_DECODE_ONLY = 1 << 31;
	 public VideoScalingMode {
	}
	 public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT = MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT;
	 public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING = MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING;
	 public static final int VIDEO_SCALING_MODE_DEFAULT = VIDEO_SCALING_MODE_SCALE_TO_FIT;
	 public SelectionFlags {
	}
	 public static final int SELECTION_FLAG_DEFAULT = 1;
	 public static final int SELECTION_FLAG_FORCED = 1 << 1;
	 public static final int SELECTION_FLAG_AUTOSELECT = 1 << 2;
	 public static final String LANGUAGE_UNDETERMINED = ""und"";
	 public ContentType {
	}
	 public static final int TYPE_DASH = 0;
	 public static final int TYPE_SS = 1;
	 public static final int TYPE_HLS = 2;
	 public static final int TYPE_OTHER = 3;
	 public static final int RESULT_END_OF_INPUT = -1;
	 public static final int RESULT_MAX_LENGTH_EXCEEDED = -2;
	 public static final int RESULT_NOTHING_READ = -3;
	 public static final int RESULT_BUFFER_READ = -4;
	 public static final int RESULT_FORMAT_READ = -5;
	 public static final int DATA_TYPE_UNKNOWN = 0;
	 public static final int DATA_TYPE_MEDIA = 1;
	 public static final int DATA_TYPE_MEDIA_INITIALIZATION = 2;
	 public static final int DATA_TYPE_DRM = 3;
	 public static final int DATA_TYPE_MANIFEST = 4;
	 public static final int DATA_TYPE_TIME_SYNCHRONIZATION = 5;
	 public static final int DATA_TYPE_AD = 6;
	 public static final int DATA_TYPE_MEDIA_PROGRESSIVE_LIVE = 7;
	 public static final int DATA_TYPE_CUSTOM_BASE = 10000;
	 public static final int TRACK_TYPE_UNKNOWN = -1;
	 public static final int TRACK_TYPE_DEFAULT = 0;
	 public static final int TRACK_TYPE_AUDIO = 1;
	 public static final int TRACK_TYPE_VIDEO = 2;
	 public static final int TRACK_TYPE_TEXT = 3;
	 public static final int TRACK_TYPE_METADATA = 4;
	 public static final int TRACK_TYPE_CAMERA_MOTION = 5;
	 public static final int TRACK_TYPE_NONE = 6;
	 public static final int TRACK_TYPE_CUSTOM_BASE = 10000;
	 public static final int SELECTION_REASON_UNKNOWN = 0;
	 public static final int SELECTION_REASON_INITIAL = 1;
	 public static final int SELECTION_REASON_MANUAL = 2;
	 public static final int SELECTION_REASON_ADAPTIVE = 3;
	 public static final int SELECTION_REASON_TRICK_PLAY = 4;
	 public static final int SELECTION_REASON_CUSTOM_BASE = 10000;
	 public static final int DEFAULT_BUFFER_SEGMENT_SIZE = 64 * 1024;
	 public static final int DEFAULT_VIDEO_BUFFER_SIZE = 200 * DEFAULT_BUFFER_SEGMENT_SIZE;
	 public static final int DEFAULT_AUDIO_BUFFER_SIZE = 54 * DEFAULT_BUFFER_SEGMENT_SIZE;
	 public static final int DEFAULT_TEXT_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
	 public static final int DEFAULT_METADATA_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
	 public static final int DEFAULT_CAMERA_MOTION_BUFFER_SIZE = 2 * DEFAULT_BUFFER_SEGMENT_SIZE;
	 public static final int DEFAULT_MUXED_BUFFER_SIZE = DEFAULT_VIDEO_BUFFER_SIZE + DEFAULT_AUDIO_BUFFER_SIZE + DEFAULT_TEXT_BUFFER_SIZE;
	 public static final String CENC_TYPE_cenc = ""cenc"";
	 public static final String CENC_TYPE_cbc1 = ""cbc1"";
	 public static final String CENC_TYPE_cens = ""cens"";
	 public static final String CENC_TYPE_cbcs = ""cbcs"";
	 public static final UUID UUID_NIL = new UUID(0L, 0L);
	 public static final UUID COMMON_PSSH_UUID = new UUID(0x1077EFECC0B24D02L, 0xACE33C1E52E2FB4BL);
	 public static final UUID CLEARKEY_UUID = new UUID(0xE2719D58A985B3C9L, 0x781AB030AF78D30EL);
	 public static final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
	 public static final UUID PLAYREADY_UUID = new UUID(0x9A04F07998404286L, 0xAB92E65BE0885F95L);
	 public static final int MSG_SET_SURFACE = 1;
	 public static final int MSG_SET_VOLUME = 2;
	 public static final int MSG_SET_AUDIO_ATTRIBUTES = 3;
	 public static final int MSG_SET_SCALING_MODE = 4;
	 public static final int MSG_SET_AUX_EFFECT_INFO = 5;
	 public static final int MSG_SET_VIDEO_FRAME_METADATA_LISTENER = 6;
	 public static final int MSG_SET_CAMERA_MOTION_LISTENER = 7;
	 public static final int MSG_CUSTOM_BASE = 10000;
	 public StereoMode {
	}
	 public static final int STEREO_MODE_MONO = 0;
	 public static final int STEREO_MODE_TOP_BOTTOM = 1;
	 public static final int STEREO_MODE_LEFT_RIGHT = 2;
	 public static final int STEREO_MODE_STEREO_MESH = 3;
	 public ColorSpace {
	}
	 public static final int COLOR_SPACE_BT709 = MediaFormat.COLOR_STANDARD_BT709;
	 public static final int COLOR_SPACE_BT601 = MediaFormat.COLOR_STANDARD_BT601_PAL;
	 public static final int COLOR_SPACE_BT2020 = MediaFormat.COLOR_STANDARD_BT2020;
	 public ColorTransfer {
	}
	 public static final int COLOR_TRANSFER_SDR = MediaFormat.COLOR_TRANSFER_SDR_VIDEO;
	 public static final int COLOR_TRANSFER_ST2084 = MediaFormat.COLOR_TRANSFER_ST2084;
	 public static final int COLOR_TRANSFER_HLG = MediaFormat.COLOR_TRANSFER_HLG;
	 public ColorRange {
	}
	 public static final int COLOR_RANGE_LIMITED = MediaFormat.COLOR_RANGE_LIMITED;
	 public static final int COLOR_RANGE_FULL = MediaFormat.COLOR_RANGE_FULL;
	 public Projection {
	}
	 public static final int PROJECTION_RECTANGULAR = 0;
	 public static final int PROJECTION_EQUIRECTANGULAR = 1;
	 public static final int PROJECTION_CUBEMAP = 2;
	 public static final int PROJECTION_MESH = 3;
	 public static final int PRIORITY_PLAYBACK = 0;
	 public static final int PRIORITY_DOWNLOAD = PRIORITY_PLAYBACK - 1000;
	 public NetworkType {
	}
	 public static final int NETWORK_TYPE_UNKNOWN = 0;
	 public static final int NETWORK_TYPE_OFFLINE = 1;
	 public static final int NETWORK_TYPE_WIFI = 2;
	 public static final int NETWORK_TYPE_2G = 3;
	 public static final int NETWORK_TYPE_3G = 4;
	 public static final int NETWORK_TYPE_4G = 5;
	 public static final int NETWORK_TYPE_CELLULAR_UNKNOWN = 6;
	 public static final int NETWORK_TYPE_ETHERNET = 7;
	 public static final int NETWORK_TYPE_OTHER = 8;
	 public static long usToMs(long timeUs) {
		 return (timeUs == TIME_UNSET || timeUs == TIME_END_OF_SOURCE) ? timeUs : (timeUs / 1000);
	 }
	 public static long msToUs(long timeMs) {
		 return (timeMs == TIME_UNSET || timeMs == TIME_END_OF_SOURCE) ? timeMs : (timeMs * 1000);
	 }
	 public static int generateAudioSessionIdV21(Context context) {
		 return ((AudioManager) context.getSystemService(Context.AUDIO_SERVICE)) .generateAudioSessionId();
	 }
}",1,1,0,0
",}
)public class Supplier {
private String supplierId;
private String emailAddress;
private String phoneNumber;
private String city;
private String postalCode;
private String street;
private String houseNumber;
private String country;
private String supplierName;
public String getSupplierId() {
	return supplierId;
}
public void setSupplierId(String id) {
	this.supplierId = id;
}
public void setEmailAddress(String param) {
	this.emailAddress = param;
}
public String getEmailAddress() {
	return emailAddress;
}
public void setPhoneNumber(String param) {
	this.phoneNumber = param;
}
public String getPhoneNumber() {
	return phoneNumber;
}
public void setCity(String param) {
	this.city = param;
}
public String getCity() {
	return city;
}
public void setPostalCode(String param) {
	this.postalCode = param;
}
public String getPostalCode() {
	return postalCode;
}
public void setStreet(String param) {
	this.street = param;
}
public String getStreet() {
	return street;
}
public void setHouseNumber(String param) {
	this.houseNumber = param;
}
public String getHouseNumber() {
	return houseNumber;
}
public void setCountry(String param) {
	this.country = param;
}
public String getCountry() {
	return country;
}
public void setSupplierName(String param) {
	this.supplierName = param;
}
public String getSupplierName() {
	return supplierName;
}
}",0,1,0,0
"public class RequestParameters implements IClusterable{
	private static final int MAX_URL_DEPTH = 75;
	private static final long serialVersionUID = 1L;
	private String componentPath;
	private String pageMapName;
	private int versionNumber;
	private boolean onlyProcessIfPathActive = false;
	private String interfaceName;
	private String behaviorId;
	private String componentId;
	private String bookmarkablePageClass;
	private Map<String, ?> parameters;
	private String resourceKey;
	private String path;
	private int urlDepth = -1;
	private String queryString;
	private boolean stateless = true;
	public RequestParameters(){
	}
	public String getBehaviorId(){
		return behaviorId;
	}
	public String getBookmarkablePageClass(){
		return bookmarkablePageClass;
	}
	public String getComponentId(){
		return componentId;
	}
	public String getComponentPath(){
		return componentPath;
	}
	public RequestListenerInterface getInterface(){
		return RequestListenerInterface.forName(getInterfaceName());
	}
	public String getInterfaceName(){
		return interfaceName;
	}
	public String getPageMapName(){
		return pageMapName;
	}
	public Map<String, ?> getParameters(){
		return parameters;
	}
	public String getPath(){
		return path;
	}
	public String getResourceKey(){
		return resourceKey;
	}
	public int getVersionNumber(){
		return versionNumber;
	}
	public boolean isOnlyProcessIfPathActive(){
		return onlyProcessIfPathActive;
	}
	public void setBehaviorId(String behaviorId){
		this.behaviorId = behaviorId;
	}
	public void setBookmarkablePageClass(String bookmarkablePageClass){
		this.bookmarkablePageClass = bookmarkablePageClass;
	}
	public void setComponentId(String componentId){
		this.componentId = componentId;
	}
	public void setComponentPath(String componentPath){
		this.componentPath = componentPath;
	}
	public void setInterfaceName(String interfaceName){
		this.interfaceName = interfaceName;
	}
	public void setOnlyProcessIfPathActive(boolean onlyProcessIfPathActive){
		this.onlyProcessIfPathActive = onlyProcessIfPathActive;
	}
	public void setPageMapName(String pageMapName){
		this.pageMapName = WebRequestCodingStrategy.decodePageMapName(pageMapName);
	}
	public void setParameters(Map<String, ?> parameters){
		this.parameters = parameters;
	}
	public void setPath(String pathInfo){
		path = pathInfo;
	}
	public void setResourceKey(String resourceKey){
		this.resourceKey = resourceKey;
	}
	public void setVersionNumber(int versionNumber){
		this.versionNumber = versionNumber;
	}
	public int getUrlDepth(){
		return urlDepth;
	}
	public void setUrlDepth(int urlDepth){
		if (urlDepth > MAX_URL_DEPTH || urlDepth < -1)throw new RuntimeException(""Url depth has an illegal value: "" + urlDepth);
		this.urlDepth = urlDepth;
	}
	public boolean isStateless(){
		return stateless;
	}
	public void setStateless(boolean stateless){
		this.stateless = stateless;
	}
	public String toString(){
		StringBuffer b = new StringBuffer(""[RequestParameters "");
		if (getComponentPath() != null){
			b.append("" componentPath="").append(getComponentPath());
			b.append("" pageMapName="").append(getPageMapName());
			b.append("" versionNumber="").append(getVersionNumber());
			b.append("" interfaceName="").append(getInterfaceName());
			b.append("" componentId="").append(getComponentId());
			b.append("" behaviorId="").append(getBehaviorId());
			b.append("" urlDepth="").append(getUrlDepth());
		}
		if (getBookmarkablePageClass() != null){
			b.append("" bookmarkablePageClass="").append(getBookmarkablePageClass());
		}
		if (getParameters() != null){
			b.append("" parameters={
				"");
				boolean first = true;
				for (Map.Entry<String, ?> entry : getParameters().entrySet()){
					if (first == false){
						b.append("","");
					}
					first = false;
					Object value = entry.getValue();
					b.append(entry.getKey()).append(""="");
					if (value != null && value instanceof Object[]){
						Object[] values = (Object[])value;
						if (values.length > 1){
							b.append(""{
								"");
								for (int j = 0;
								 j < values.length;
								 j++){
									b.append(values[j]);
									if (j < values.length){
										b.append("","");
									}
								}
							b.append(""}
							"");
						}
						else{
							b.append((values.length == 1) ? values[0] : """");
						}
					}
					else{
						b.append(value);
					}
				}
			b.append(""}
			"");
		}
		if (getResourceKey() != null){
			b.append("" resourceKey="").append(getResourceKey());
		}
		b.append("" onlyProcessIfPathActive="").append(isOnlyProcessIfPathActive());
		b.append(""]"");
		return b.toString();
	}
	public String getQueryString(){
		return queryString;
	}
	public void setQueryString(String queryString){
		this.queryString = queryString;
	}
}",0,0,0,0
public void printAllStocks();,0,0,0,0
"public boolean makeAcquisitionUnstealable(final MessageInstanceConsumer<T> consumer) {
	 EntryState state = _state;
	 if(state instanceof StealableConsumerAcquiredState && ((StealableConsumerAcquiredState) state).getConsumer() == consumer) {
		 UnstealableConsumerAcquiredState unstealableState = ((StealableConsumerAcquiredState) state).getUnstealableState();
		 boolean updated = _stateUpdater.compareAndSet(this, state, unstealableState);
		 if(updated) {
			 notifyStateChange(state, unstealableState);
		 }
		 return updated;
	 }
	 return state instanceof UnstealableConsumerAcquiredState && ((UnstealableConsumerAcquiredState) state).getConsumer() == consumer;
 }",0,0,1,0
"public void characters(char[] ch, int start, int length) throws SAXException {
	 currentText += new String(ch, start, length);
 }",0,0,0,0
"public Task getTaskToRun(String taskTracker, TaskTrackerStatus tts, double avgProgress) {
	 Task t = null;
	 if (hasTask() || hasSpeculativeTask(avgProgress)) {
		 String taskid = (String) usableTaskIds.first();
		 usableTaskIds.remove(taskid);
		 if (isMapTask()) {
			 t = new MapTask(jobFile, taskid, split);
		 }
		 else {
			 String mapIdPredecessors[][] = new String[predecessors.length][];
			 for (int i = 0;
			 i < mapIdPredecessors.length;
			 i++) {
				 mapIdPredecessors[i] = predecessors[i].getAllPossibleTaskIds();
			 }
			 t = new ReduceTask(jobFile, taskid, mapIdPredecessors, partition);
		 }
		 t.setConf(conf);
		 recentTasks.add(taskid);
		 jobtracker.createTaskEntry(taskid, taskTracker, this);
	 }
	 return t;
 }",0,0,0,0
"public class TruffleNFI_DLL implements DLLRFFI {
	 public static final class NFIHandle implements LibHandle {
		 private final String libName;
		 final TruffleObject libHandle;
		 NFIHandle(String libName, TruffleObject libHandle) {
			 this.libName = libName;
			 this.libHandle = libHandle;
		 }
		 public Type getRFFIType() {
			 return RFFIFactory.Type.NFI;
		 }
	 }
	 private static final class TruffleNFI_DLOpenNode extends Node implements DLLRFFI.DLOpenNode {
		 public LibHandle execute(String path, boolean local, boolean now) {
			 String librffiPath = LibPaths.getBuiltinLibPath(""R"");
			 boolean notifyStateRFFI = !librffiPath.equals(path);
			 long before = notifyStateRFFI ? RContext.getInstance().getStateRFFI().beforeDowncall(RFFIFactory.Type.NFI) : 0;
			 try {
				 String libName = DLL.libName(path);
				 Env env = RContext.getInstance().getEnv();
				 TruffleObject libHandle = (TruffleObject) env.parse(Source.newBuilder(""nfi"", prepareLibraryOpen(path, local, now), path).build()).call();
				 return new NFIHandle(libName, libHandle);
			 }
			 finally {
				 if (notifyStateRFFI) {
					 RContext.getInstance().getStateRFFI().afterDowncall(before, RFFIFactory.Type.NFI);
				 }
			 }
		 }
	 }
	 private static String prepareLibraryOpen(String path, boolean local, boolean now) {
		 StringBuilder sb = new StringBuilder(""load"");
		 sb.append(""("");
		 sb.append(local ? ""RTLD_LOCAL"" : ""RTLD_GLOBAL"");
		 sb.append('|');
		 sb.append(now ? ""RTLD_NOW"" : ""RTLD_LAZY"");
		 sb.append("") \"""");
		 sb.append(path);
		 sb.append('""');
		 return sb.toString();
	 }
	 private static class TruffleNFI_DLSymNode extends Node implements DLLRFFI.DLSymNode {
		 private Node lookupSymbol;
		 public SymbolHandle execute(Object handle, String symbol) {
			 assert handle instanceof NFIHandle;
			 NFIHandle nfiHandle = (NFIHandle) handle;
			 if (lookupSymbol == null) {
				 CompilerDirectives.transferToInterpreterAndInvalidate();
				 lookupSymbol = insert(Message.READ.createNode());
			 }
			 try {
				 TruffleObject result = (TruffleObject) ForeignAccess.sendRead(lookupSymbol, nfiHandle.libHandle, symbol);
				 return new SymbolHandle(result);
			 }
			 catch (UnknownIdentifierException e) {
				 throw new UnsatisfiedLinkError();
			 }
			 catch (InteropException e) {
				 throw RInternalError.shouldNotReachHere();
			 }
		 }
	 }
	 private static class TruffleNFI_DLCloseNode extends Node implements DLLRFFI.DLCloseNode {
		 public int execute(Object handle) {
			 assert handle instanceof NFIHandle;
			 return 0;
		 }
	 }
	 public DLOpenNode createDLOpenNode() {
		 return new TruffleNFI_DLOpenNode();
	 }
	 public DLSymNode createDLSymNode() {
		 return new TruffleNFI_DLSymNode();
	 }
	 public DLCloseNode createDLCloseNode() {
		 return new TruffleNFI_DLCloseNode();
	 }
}",1,0,0,0
"public class SerializableGlobalSumAggregateFunction extends AbstractSerializableSumAggregateFunction {
	 public SerializableGlobalSumAggregateFunction(IScalarEvaluatorFactory[] args, IHyracksTaskContext context, SourceLocation sourceLoc) throws HyracksDataException {
		 super(args, context, sourceLoc);
	 }
	 public void step(IFrameTupleReference tuple, byte[] state, int start, int len) throws HyracksDataException {
		 super.step(tuple, state, start, len);
	 }
	 public void finish(byte[] state, int start, int len, DataOutput out) throws HyracksDataException {
		 super.finish(state, start, len, out);
	 }
	 protected boolean skipStep(byte[] state, int start) {
		 ATypeTag aggType = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(state[start + AGG_TYPE_OFFSET]);
		 return aggType == ATypeTag.NULL;
	 }
	 protected void processNull(byte[] state, int start) {
		 state[start + AGG_TYPE_OFFSET] = ATypeTag.SERIALIZED_NULL_TYPE_TAG;
	 }
	 protected void processSystemNull() {
	 }
	 protected void finishNull(DataOutput out) throws IOException {
		 out.writeByte(ATypeTag.SERIALIZED_NULL_TYPE_TAG);
	 }
	 protected void finishSystemNull(DataOutput out) throws IOException {
		 out.writeByte(ATypeTag.SERIALIZED_NULL_TYPE_TAG);
	 }
}",0,0,0,0
"public class DropColumnFamily extends Migration{
	 private String tableName;
	 private String cfName;
	 protected DropColumnFamily() {
	 }
	 public DropColumnFamily(String tableName, String cfName) throws ConfigurationException, IOException {
		 super(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress()), DatabaseDescriptor.getDefsVersion());
		 this.tableName = tableName;
		 this.cfName = cfName;
		 KSMetaData ksm = DatabaseDescriptor.getTableDefinition(tableName);
		 if (ksm == null) throw new ConfigurationException(""No such keyspace: "" + tableName);
		 else if (!ksm.cfMetaData().containsKey(cfName)) throw new ConfigurationException(""CF is not defined in that keyspace."");
		 KSMetaData newKsm = makeNewKeyspaceDefinition(ksm);
		 rm = Migration.makeDefinitionMutation(newKsm, null, newVersion);
	 }
	 private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm) {
		 CFMetaData cfm = ksm.cfMetaData().get(cfName);
		 List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
		 newCfs.remove(cfm);
		 assert newCfs.size() == ksm.cfMetaData().size() - 1;
		 return new KSMetaData(ksm.name, ksm.strategyClass, ksm.strategyOptions, newCfs.toArray(new CFMetaData[newCfs.size()]));
	 }
	 public void applyModels() throws IOException {
		 ColumnFamilyStore cfs = Table.open(tableName).getColumnFamilyStore(cfName);
		 KSMetaData existing = DatabaseDescriptor.getTableDefinition(tableName);
		 CFMetaData cfm = existing.cfMetaData().get(cfName);
		 KSMetaData ksm = makeNewKeyspaceDefinition(existing);
		 CFMetaData.purge(cfm);
		 DatabaseDescriptor.setTableDefinition(ksm, newVersion);
		 if (!StorageService.instance.isClientMode()) {
			 cfs.snapshot(Table.getTimestampedSnapshotName(null));
			 CompactionManager.instance.getCompactionLock().lock();
			 cfs.flushLock.lock();
			 try {
				 Table.open(ksm.name).dropCf(cfm.cfId);
			 }
			 finally {
				 cfs.flushLock.unlock();
				 CompactionManager.instance.getCompactionLock().unlock();
			 }
		 }
	 }
	 public void subdeflate(org.apache.cassandra.db.migration.avro.Migration mi) {
		 org.apache.cassandra.db.migration.avro.DropColumnFamily dcf = new org.apache.cassandra.db.migration.avro.DropColumnFamily();
		 dcf.ksname = new org.apache.avro.util.Utf8(tableName);
		 dcf.cfname = new org.apache.avro.util.Utf8(cfName);
		 mi.migration = dcf;
	 }
	 public void subinflate(org.apache.cassandra.db.migration.avro.Migration mi) {
		 org.apache.cassandra.db.migration.avro.DropColumnFamily dcf = (org.apache.cassandra.db.migration.avro.DropColumnFamily)mi.migration;
		 tableName = dcf.ksname.toString();
		 cfName = dcf.cfname.toString();
	 }
	 public String toString() {
		 return String.format(""Drop column family: %s.%s"", tableName, cfName);
	 }
}",0,0,0,0
"public class DebugTraceBasedRegion extends AbstractTraceRegion {
	private final DebugTraceRegion delegate;
	protected DebugTraceBasedRegion(AbstractTraceRegion parent, DebugTraceRegion delegate) {
		super(parent);
		this.delegate = delegate;
		for (DebugTraceRegion child : delegate.getNestedRegions())new DebugTraceBasedRegion(this, child);
	}
	private LocationData convert(DebugLocationData data) {
		SourceRelativeURI uri = data.getPath() != null ? new SourceRelativeURI(data.getPath()) : null;
		return new LocationData(data.getOffset(), data.getLength(), data.getLineNumber(), data.getEndLineNumber(), uri);
	}
	public List<ILocationData> getAssociatedLocations() {
		List<ILocationData> result = Lists.newArrayListWithCapacity(delegate.getAssociations().size());
		for (DebugLocationData data : delegate.getAssociations())result.add(convert(data));
		return result;
	}
	public SourceRelativeURI getAssociatedSrcRelativePath() {
		SourceRelativeURI path = super.getAssociatedSrcRelativePath();
		if (path != null)return path;
		return getAssociatedSrcRelativePath(delegate);
	}
	protected SourceRelativeURI getAssociatedSrcRelativePath(DebugTraceRegion region) {
		for (DebugLocationData associated : region.getAssociations()) {
			URI uri = associated.getPath();
			if (uri != null)return new SourceRelativeURI(uri);
		}
		EObject container = region.eContainer();
		if (container instanceof DebugTraceRegion)return getAssociatedSrcRelativePath((DebugTraceRegion) container);
		return null;
	}
	public int getMyEndLineNumber() {
		return delegate.getMyEndLineNumber();
	}
	public int getMyLength() {
		return delegate.getMyLength();
	}
	public int getMyLineNumber() {
		return delegate.getMyLineNumber();
	}
	public int getMyOffset() {
		return delegate.getMyOffset();
	}
	public boolean isUseForDebugging() {
		return delegate.isUseForDebugging();
	}
}",0,1,0,0
"String genJavaConstructorSet(String fname, int fIdx) {
	 return "" m""+fname+""=m""+fIdx+"";
	 bs_.set(""+fIdx+"");
	\n"";
 }",0,0,0,0
"public class MapImageLayerTablesSample extends Application {
	 private MapView mapView;
	 private GraphicsOverlay graphicsOverlay;
	 private ServiceFeatureTable commentsTable;
	 private ListView<Feature> commentsListView;
	 public static void main(String[] args) {
		 Application.launch(args);
	 }
	 public void start(Stage stage) {
		 try {
			 StackPane stackPane = new StackPane();
			 Scene scene = new Scene(stackPane);
			 scene.getStylesheets().add(getClass().getResource(""/css/style.css"").toExternalForm());
			 stage.setTitle(""Map Image Layer Tables Sample"");
			 stage.setWidth(800);
			 stage.setHeight(700);
			 stage.setScene(scene);
			 stage.show();
			 ArcGISMap map = new ArcGISMap(Basemap.createStreetsVector());
			 ArcGISMapImageLayer imageLayer = new ArcGISMapImageLayer( ""https: map.getOperationalLayers().add(imageLayer);
			 mapView = new MapView();
			 mapView.setMap(map);
			 graphicsOverlay = new GraphicsOverlay();
			 mapView.getGraphicsOverlays().add(graphicsOverlay);
			 SimpleRenderer renderer = new SimpleRenderer();
			 renderer.setSymbol(new SimpleMarkerSymbol(SimpleMarkerSymbol.Style.CIRCLE, 0xFF00FFFF, 14));
			 graphicsOverlay.setRenderer(renderer);
			 commentsListView = new ListView<>();
			 commentsListView.setMaxSize(200.0, 150.0);
			 commentsListView.setCellFactory(listView -> new ListCell<Feature>() {
				 protected void updateItem(Feature item, boolean empty) {
					 super.updateItem(item, empty);
					 if (item != null) {
						 ArcGISFeature feature = (ArcGISFeature) item;
						 setText((String) feature.getAttributes().get(""comments""));
					 }
				 }
			 }
			);
			 commentsListView.getSelectionModel().selectedItemProperty().addListener(observable -> showRelatedRequests());
			 imageLayer.addDoneLoadingListener(() -> {
				 if (imageLayer.getLoadStatus() == LoadStatus.LOADED) {
					 mapView.setViewpoint(new Viewpoint(imageLayer.getFullExtent()));
					 commentsTable = imageLayer.getTables().get(0);
					 QueryParameters queryParameters = new QueryParameters();
					 queryParameters.setWhereClause(""requestid <> '' AND comments <> ''"");
					 ListenableFuture<FeatureQueryResult> featureQuery = commentsTable.queryFeaturesAsync(queryParameters);
					 featureQuery.addDoneListener(() -> {
						 try {
							 FeatureQueryResult results = featureQuery.get();
							 for (Feature f : results) {
								 commentsListView.getItems().addAll(f);
							 }
						 }
						 catch (InterruptedException | ExecutionException ex) {
							 new Alert(Alert.AlertType.ERROR, ""Error querying comment features"");
						 }
					 }
					);
				 }
				 else {
					 new Alert(Alert.AlertType.ERROR, imageLayer.getLoadError().getMessage()).show();
				 }
			 }
			);
			 stackPane.getChildren().addAll(mapView, commentsListView);
			 StackPane.setAlignment(commentsListView, Pos.TOP_LEFT);
			 StackPane.setMargin(commentsListView, new Insets(10, 0, 0, 10));
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 private void showRelatedRequests() {
		 graphicsOverlay.getGraphics().clear();
		 Feature selectedCommentFeature = commentsListView.getSelectionModel().getSelectedItem();
		 if (selectedCommentFeature != null) {
			 ArcGISFeature feature = (ArcGISFeature) selectedCommentFeature;
			 List<RelationshipInfo> relationshipInfos = commentsTable.getLayerInfo().getRelationshipInfos();
			 if (!relationshipInfos.isEmpty()) {
				 RelationshipInfo commentsRelationshipInfo = relationshipInfos.get(0);
				 RelatedQueryParameters relatedQueryParameters = new RelatedQueryParameters(commentsRelationshipInfo);
				 relatedQueryParameters.setReturnGeometry(true);
				 ListenableFuture<List<RelatedFeatureQueryResult>> relatedFeaturesRequest = commentsTable .queryRelatedFeaturesAsync(feature, relatedQueryParameters);
				 relatedFeaturesRequest.addDoneListener(() -> {
					 try {
						 List<RelatedFeatureQueryResult> results = relatedFeaturesRequest.get();
						 if (!results.isEmpty()) {
							 RelatedFeatureQueryResult relatedResult = results.get(0);
							 if (relatedResult.iterator().hasNext()) {
								 ArcGISFeature relatedFeature = (ArcGISFeature) relatedResult.iterator().next();
								 relatedFeature.loadAsync();
								 relatedFeature.addDoneLoadingListener(() -> {
									 if (relatedFeature.getLoadStatus() == LoadStatus.LOADED) {
										 Point point = (Point) relatedFeature.getGeometry();
										 Graphic graphic = new Graphic(point);
										 graphicsOverlay.getGraphics().add(graphic);
										 mapView.setViewpointCenterAsync(point, 40000);
									 }
								 }
								);
							 }
						 }
						 else {
							 new Alert(Alert.AlertType.INFORMATION, ""No related features found"").show();
						 }
					 }
					 catch (InterruptedException | ExecutionException ex) {
						 new Alert(Alert.AlertType.ERROR, ""Failed to query relationships"").show();
					 }
				 }
				);
			 }
		 }
	 }
	 public void stop() {
		 if (mapView != null) {
			 mapView.dispose();
		 }
	 }
}",1,0,0,0
"public synchronized void gotHeartbeat(UTF8 name, long capacity, long remaining) {
	 synchronized (heartbeats) {
		 synchronized (datanodeMap) {
			 long capacityDiff = 0;
			 long remainingDiff = 0;
			 DatanodeInfo nodeinfo = (DatanodeInfo) datanodeMap.get(name);
			 if (nodeinfo == null) {
				 NameNode.stateChangeLog.fine(""BLOCK* NameSystem.gotHeartbeat: "" +""brand-new heartbeat from ""+name );
				 nodeinfo = new DatanodeInfo(name, capacity, remaining);
				 datanodeMap.put(name, nodeinfo);
				 capacityDiff = capacity;
				 remainingDiff = remaining;
			 }
			 else {
				 capacityDiff = capacity - nodeinfo.getCapacity();
				 remainingDiff = remaining - nodeinfo.getRemaining();
				 heartbeats.remove(nodeinfo);
				 nodeinfo.updateHeartbeat(capacity, remaining);
			 }
			 heartbeats.add(nodeinfo);
			 totalCapacity += capacityDiff;
			 totalRemaining += remainingDiff;
		 }
	 }
 }",0,0,0,0
"public class Token{
	 public static final boolean printTrees = false;
	 static final boolean printICode = false;
	 static final boolean printNames = printTrees || printICode;
	 public final static int ERROR = -1, EOF = 0, EOL = 1, FIRST_BYTECODE_TOKEN = 2, ENTERWITH = 2, LEAVEWITH = 3, RETURN = 4, GOTO = 5, IFEQ = 6, IFNE = 7, SETNAME = 8, BITOR = 9, BITXOR = 10, BITAND = 11, EQ = 12, NE = 13, LT = 14, LE = 15, GT = 16, GE = 17, LSH = 18, RSH = 19, URSH = 20, ADD = 21, SUB = 22, MUL = 23, DIV = 24, MOD = 25, NOT = 26, BITNOT = 27, POS = 28, NEG = 29, NEW = 30, DELPROP = 31, TYPEOF = 32, GETPROP = 33, SETPROP = 34, GETELEM = 35, SETELEM = 36, CALL = 37, NAME = 38, NUMBER = 39, STRING = 40, NULL = 41, THIS = 42, FALSE = 43, TRUE = 44, SHEQ = 45, SHNE = 46, REGEXP = 47, BINDNAME = 48, THROW = 49, RETHROW = 50, IN = 51, INSTANCEOF = 52, LOCAL_LOAD = 53, GETVAR = 54, SETVAR = 55, CATCH_SCOPE = 56, ENUM_INIT_KEYS = 57, ENUM_INIT_VALUES = 58, ENUM_NEXT = 59, ENUM_ID = 60, THISFN = 61, RETURN_RESULT = 62, ARRAYLIT = 63, OBJECTLIT = 64, GET_REF = 65, SET_REF = 66, DEL_REF = 67, REF_CALL = 68, REF_SPECIAL = 69, DEFAULTNAMESPACE = 70, ESCXMLATTR = 71, ESCXMLTEXT = 72, REF_MEMBER = 73, REF_NS_MEMBER = 74, REF_NAME = 75, REF_NS_NAME = 76;
	 public final static int LAST_BYTECODE_TOKEN = REF_NS_NAME, TRY = 77, SEMI = 78, LB = 79, RB = 80, LC = 81, RC = 82, LP = 83, RP = 84, COMMA = 85, ASSIGN = 86, ASSIGN_BITOR = 87, ASSIGN_BITXOR = 88, ASSIGN_BITAND = 89, ASSIGN_LSH = 90, ASSIGN_RSH = 91, ASSIGN_URSH = 92, ASSIGN_ADD = 93, ASSIGN_SUB = 94, ASSIGN_MUL = 95, ASSIGN_DIV = 96, ASSIGN_MOD = 97;
	 public final static int FIRST_ASSIGN = ASSIGN, LAST_ASSIGN = ASSIGN_MOD, HOOK = 98, COLON = 99, OR = 100, AND = 101, INC = 102, DEC = 103, DOT = 104, FUNCTION = 105, EXPORT = 106, IMPORT = 107, IF = 108, ELSE = 109, SWITCH = 110, CASE = 111, DEFAULT = 112, WHILE = 113, DO = 114, FOR = 115, BREAK = 116, CONTINUE = 117, VAR = 118, WITH = 119, CATCH = 120, FINALLY = 121, VOID = 122, RESERVED = 123, EMPTY = 124, BLOCK = 125, LABEL = 126, TARGET = 127, LOOP = 128, EXPR_VOID = 129, EXPR_RESULT = 130, JSR = 131, SCRIPT = 132, TYPEOFNAME = 133, USE_STACK = 134, SETPROP_OP = 135, SETELEM_OP = 136, LOCAL_BLOCK = 137, SET_REF_OP = 138, DOTDOT = 139, COLONCOLON = 140, XML = 141, DOTQUERY = 142, XMLATTR = 143, XMLEND = 144, TO_OBJECT = 145, TO_DOUBLE = 146, LAST_TOKEN = 146;
	 public static String name(int token) {
		 if (!printNames) {
			 return String.valueOf(token);
		 }
		 switch (token) {
			 case ERROR: return ""ERROR"";
			 case EOF: return ""EOF"";
			 case EOL: return ""EOL"";
			 case ENTERWITH: return ""ENTERWITH"";
			 case LEAVEWITH: return ""LEAVEWITH"";
			 case RETURN: return ""RETURN"";
			 case GOTO: return ""GOTO"";
			 case IFEQ: return ""IFEQ"";
			 case IFNE: return ""IFNE"";
			 case SETNAME: return ""SETNAME"";
			 case BITOR: return ""BITOR"";
			 case BITXOR: return ""BITXOR"";
			 case BITAND: return ""BITAND"";
			 case EQ: return ""EQ"";
			 case NE: return ""NE"";
			 case LT: return ""LT"";
			 case LE: return ""LE"";
			 case GT: return ""GT"";
			 case GE: return ""GE"";
			 case LSH: return ""LSH"";
			 case RSH: return ""RSH"";
			 case URSH: return ""URSH"";
			 case ADD: return ""ADD"";
			 case SUB: return ""SUB"";
			 case MUL: return ""MUL"";
			 case DIV: return ""DIV"";
			 case MOD: return ""MOD"";
			 case NOT: return ""NOT"";
			 case BITNOT: return ""BITNOT"";
			 case POS: return ""POS"";
			 case NEG: return ""NEG"";
			 case NEW: return ""NEW"";
			 case DELPROP: return ""DELPROP"";
			 case TYPEOF: return ""TYPEOF"";
			 case GETPROP: return ""GETPROP"";
			 case SETPROP: return ""SETPROP"";
			 case GETELEM: return ""GETELEM"";
			 case SETELEM: return ""SETELEM"";
			 case CALL: return ""CALL"";
			 case NAME: return ""NAME"";
			 case NUMBER: return ""NUMBER"";
			 case STRING: return ""STRING"";
			 case NULL: return ""NULL"";
			 case THIS: return ""THIS"";
			 case FALSE: return ""FALSE"";
			 case TRUE: return ""TRUE"";
			 case SHEQ: return ""SHEQ"";
			 case SHNE: return ""SHNE"";
			 case REGEXP: return ""OBJECT"";
			 case BINDNAME: return ""BINDNAME"";
			 case THROW: return ""THROW"";
			 case RETHROW: return ""RETHROW"";
			 case IN: return ""IN"";
			 case INSTANCEOF: return ""INSTANCEOF"";
			 case LOCAL_LOAD: return ""LOCAL_LOAD"";
			 case GETVAR: return ""GETVAR"";
			 case SETVAR: return ""SETVAR"";
			 case CATCH_SCOPE: return ""CATCH_SCOPE"";
			 case ENUM_INIT_KEYS: return ""ENUM_INIT_KEYS"";
			 case ENUM_INIT_VALUES: return ""ENUM_INIT_VALUES"";
			 case ENUM_NEXT: return ""ENUM_NEXT"";
			 case ENUM_ID: return ""ENUM_ID"";
			 case THISFN: return ""THISFN"";
			 case RETURN_RESULT: return ""RETURN_RESULT"";
			 case ARRAYLIT: return ""ARRAYLIT"";
			 case OBJECTLIT: return ""OBJECTLIT"";
			 case GET_REF: return ""GET_REF"";
			 case SET_REF: return ""SET_REF"";
			 case DEL_REF: return ""DEL_REF"";
			 case REF_CALL: return ""REF_CALL"";
			 case REF_SPECIAL: return ""REF_SPECIAL"";
			 case DEFAULTNAMESPACE:return ""DEFAULTNAMESPACE"";
			 case ESCXMLTEXT: return ""ESCXMLTEXT"";
			 case ESCXMLATTR: return ""ESCXMLATTR"";
			 case REF_MEMBER: return ""REF_MEMBER"";
			 case REF_NS_MEMBER: return ""REF_NS_MEMBER"";
			 case REF_NAME: return ""REF_NAME"";
			 case REF_NS_NAME: return ""REF_NS_NAME"";
			 case TRY: return ""TRY"";
			 case SEMI: return ""SEMI"";
			 case LB: return ""LB"";
			 case RB: return ""RB"";
			 case LC: return ""LC"";
			 case RC: return ""RC"";
			 case LP: return ""LP"";
			 case RP: return ""RP"";
			 case COMMA: return ""COMMA"";
			 case ASSIGN: return ""ASSIGN"";
			 case ASSIGN_BITOR: return ""ASSIGN_BITOR"";
			 case ASSIGN_BITXOR: return ""ASSIGN_BITXOR"";
			 case ASSIGN_BITAND: return ""ASSIGN_BITAND"";
			 case ASSIGN_LSH: return ""ASSIGN_LSH"";
			 case ASSIGN_RSH: return ""ASSIGN_RSH"";
			 case ASSIGN_URSH: return ""ASSIGN_URSH"";
			 case ASSIGN_ADD: return ""ASSIGN_ADD"";
			 case ASSIGN_SUB: return ""ASSIGN_SUB"";
			 case ASSIGN_MUL: return ""ASSIGN_MUL"";
			 case ASSIGN_DIV: return ""ASSIGN_DIV"";
			 case ASSIGN_MOD: return ""ASSIGN_MOD"";
			 case HOOK: return ""HOOK"";
			 case COLON: return ""COLON"";
			 case OR: return ""OR"";
			 case AND: return ""AND"";
			 case INC: return ""INC"";
			 case DEC: return ""DEC"";
			 case DOT: return ""DOT"";
			 case FUNCTION: return ""FUNCTION"";
			 case EXPORT: return ""EXPORT"";
			 case IMPORT: return ""IMPORT"";
			 case IF: return ""IF"";
			 case ELSE: return ""ELSE"";
			 case SWITCH: return ""SWITCH"";
			 case CASE: return ""CASE"";
			 case DEFAULT: return ""DEFAULT"";
			 case WHILE: return ""WHILE"";
			 case DO: return ""DO"";
			 case FOR: return ""FOR"";
			 case BREAK: return ""BREAK"";
			 case CONTINUE: return ""CONTINUE"";
			 case VAR: return ""VAR"";
			 case WITH: return ""WITH"";
			 case CATCH: return ""CATCH"";
			 case FINALLY: return ""FINALLY"";
			 case RESERVED: return ""RESERVED"";
			 case EMPTY: return ""EMPTY"";
			 case BLOCK: return ""BLOCK"";
			 case LABEL: return ""LABEL"";
			 case TARGET: return ""TARGET"";
			 case LOOP: return ""LOOP"";
			 case EXPR_VOID: return ""EXPR_VOID"";
			 case EXPR_RESULT: return ""EXPR_RESULT"";
			 case JSR: return ""JSR"";
			 case SCRIPT: return ""SCRIPT"";
			 case TYPEOFNAME: return ""TYPEOFNAME"";
			 case USE_STACK: return ""USE_STACK"";
			 case SETPROP_OP: return ""SETPROP_OP"";
			 case SETELEM_OP: return ""SETELEM_OP"";
			 case LOCAL_BLOCK: return ""LOCAL_BLOCK"";
			 case SET_REF_OP: return ""SET_REF_OP"";
			 case DOTDOT: return ""DOTDOT"";
			 case COLONCOLON: return ""COLONCOLON"";
			 case XML: return ""XML"";
			 case DOTQUERY: return ""DOTQUERY"";
			 case XMLATTR: return ""XMLATTR"";
			 case XMLEND: return ""XMLEND"";
			 case TO_OBJECT: return ""TO_OBJECT"";
			 case TO_DOUBLE: return ""TO_DOUBLE"";
		 }
		 throw new IllegalStateException(String.valueOf(token));
	 }
}",1,0,0,0
"public class PagedResult<T extends BaseBean> implements Serializable {
	 private static final long serialVersionUID = 3472875885259250934L;
	 private URI prev;
	 private URI next;
	 private final List<T> result = new ArrayList<>();
	 private int page;
	 private int size;
	 private int totalCount;
	 public URI getPrev() {
		 return prev;
	 }
	 public void setPrev(final URI prev) {
		 this.prev = prev;
	 }
	 public URI getNext() {
		 return next;
	 }
	 public void setNext(final URI next) {
		 this.next = next;
	 }
	 public List<T> getResult() {
		 return result;
	 }
	 public int getPage() {
		 return page;
	 }
	 public void setPage(final int page) {
		 this.page = page;
	 }
	 public int getSize() {
		 return size;
	 }
	 public void setSize(final int size) {
		 this.size = size;
	 }
	 public int getTotalCount() {
		 return totalCount;
	 }
	 public void setTotalCount(final int totalCount) {
		 this.totalCount = totalCount;
	 }
	 public int hashCode() {
		 return new HashCodeBuilder(). append(prev). append(next). append(result). append(page). append(size). append(totalCount). build();
	 }
	 public boolean equals(final Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 if (obj == null) {
			 return false;
		 }
		 if (getClass() != obj.getClass()) {
			 return false;
		 }
		 final PagedResult<T> other = (PagedResult<T>) obj;
		 return new EqualsBuilder(). append(prev, other.prev). append(next, other.next). append(result, other.result). append(page, other.page). append(size, other.size). append(totalCount, other.totalCount). build();
	 }
}",1,1,0,0
"protected void clusterRecover(Connection conn, List failedInstances) throws JobPersistenceException {
	 if (failedInstances.size() > 0) {
		 long recoverIds = System.currentTimeMillis();
		 logWarnIfNonZero(failedInstances.size(), ""ClusterManager: detected "" + failedInstances.size() + "" failed or restarted instances."");
		 try {
			 Iterator itr = failedInstances.iterator();
			 while (itr.hasNext()) {
				 SchedulerStateRecord rec = (SchedulerStateRecord) itr .next();
				 getLog().info( ""ClusterManager: Scanning for instance \"""" + rec.getSchedulerInstanceId() + ""\""'s failed in-progress jobs."");
				 List firedTriggerRecs = getDelegate() .selectInstancesFiredTriggerRecords(conn, rec.getSchedulerInstanceId());
				 int acquiredCount = 0;
				 int recoveredCount = 0;
				 int otherCount = 0;
				 Set triggerKeys = new HashSet();
				 Iterator ftItr = firedTriggerRecs.iterator();
				 while (ftItr.hasNext()) {
					 FiredTriggerRecord ftRec = (FiredTriggerRecord) ftItr .next();
					 Key tKey = ftRec.getTriggerKey();
					 Key jKey = ftRec.getJobKey();
					 triggerKeys.add(tKey);
					 if (ftRec.getFireInstanceState().equals(STATE_BLOCKED)) {
						 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_WAITING, STATE_BLOCKED);
					 }
					 else if (ftRec.getFireInstanceState().equals(STATE_PAUSED_BLOCKED)) {
						 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_PAUSED, STATE_PAUSED_BLOCKED);
					 }
					 if (ftRec.getFireInstanceState().equals(STATE_ACQUIRED)) {
						 getDelegate().updateTriggerStateFromOtherState( conn, tKey.getName(), tKey.getGroup(), STATE_WAITING, STATE_ACQUIRED);
						 acquiredCount++;
					 }
					 else if (ftRec.isJobRequestsRecovery()) {
						 if (jobExists(conn, jKey.getName(), jKey.getGroup())) {
							 SimpleTrigger rcvryTrig = new SimpleTrigger( ""recover_"" + rec.getSchedulerInstanceId() + ""_"" + String.valueOf(recoverIds++), Scheduler.DEFAULT_RECOVERY_GROUP, new Date(ftRec.getFireTimestamp()));
							 rcvryTrig.setVolatility(ftRec.isTriggerIsVolatile());
							 rcvryTrig.setJobName(jKey.getName());
							 rcvryTrig.setJobGroup(jKey.getGroup());
							 rcvryTrig.setMisfireInstruction(SimpleTrigger.MISFIRE_INSTRUCTION_FIRE_NOW);
							 rcvryTrig.setPriority(ftRec.getPriority());
							 JobDataMap jd = getDelegate().selectTriggerJobDataMap(conn, tKey.getName(), tKey.getGroup());
							 jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_NAME, tKey.getName());
							 jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_GROUP, tKey.getGroup());
							 jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_FIRETIME_IN_MILLISECONDS, String.valueOf(ftRec.getFireTimestamp()));
							 rcvryTrig.setJobDataMap(jd);
							 rcvryTrig.computeFirstFireTime(null);
							 storeTrigger(conn, null, rcvryTrig, null, false, STATE_WAITING, false, true);
							 recoveredCount++;
						 }
						 else {
							 getLog() .warn( ""ClusterManager: failed job '"" + jKey + ""' no longer exists, cannot schedule recovery."");
							 otherCount++;
						 }
					 }
					 else {
						 otherCount++;
					 }
					 if (ftRec.isJobIsStateful()) {
						 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_WAITING, STATE_BLOCKED);
						 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_PAUSED, STATE_PAUSED_BLOCKED);
					 }
				 }
				 getDelegate().deleteFiredTriggers(conn, rec.getSchedulerInstanceId());
				 int completeCount = 0;
				 for (Iterator triggerKeyIter = triggerKeys.iterator();
				 triggerKeyIter.hasNext();
				) {
					 Key triggerKey = (Key)triggerKeyIter.next();
					 if (getDelegate().selectTriggerState(conn, triggerKey.getName(), triggerKey.getGroup()). equals(STATE_COMPLETE)) {
						 List firedTriggers = getDelegate().selectFiredTriggerRecords(conn, triggerKey.getName(), triggerKey.getGroup());
						 if (firedTriggers.isEmpty()) {
							 SchedulingContext schedulingContext = new SchedulingContext();
							 schedulingContext.setInstanceId(instanceId);
							 if (removeTrigger(conn, schedulingContext, triggerKey.getName(), triggerKey.getGroup())) {
								 completeCount++;
							 }
						 }
					 }
				 }
				 logWarnIfNonZero(acquiredCount, ""ClusterManager: ......Freed "" + acquiredCount + "" acquired trigger(s)."");
				 logWarnIfNonZero(completeCount, ""ClusterManager: ......Deleted "" + completeCount + "" complete triggers(s)."");
				 logWarnIfNonZero(recoveredCount, ""ClusterManager: ......Scheduled "" + recoveredCount + "" recoverable job(s) for recovery."");
				 logWarnIfNonZero(otherCount, ""ClusterManager: ......Cleaned-up "" + otherCount + "" other failed job(s)."");
				 if (rec.getSchedulerInstanceId().equals(getInstanceId()) == false) {
					 getDelegate().deleteSchedulerState(conn, rec.getSchedulerInstanceId());
				 }
			 }
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException(""Failure recovering jobs: "" + e.getMessage(), e);
		 }
	 }
 }",0,0,1,0
"public class ClassCryptFactory implements ICryptFactory{
	private static final Logger log = LoggerFactory.getLogger(ClassCryptFactory.class);
	private final WeakReference<Class<?>> cryptClass;
	private final String encryptionKey;
	public ClassCryptFactory(Class<?> cryptClass, String encryptionKey){
		if (cryptClass == null){
			throw new IllegalArgumentException(""cryptClass cannot be null"");
		}
		if (!ICrypt.class.isAssignableFrom(cryptClass)){
			throw new IllegalArgumentException(""cryptClass must implement ICrypt interface"");
		}
		this.cryptClass = new WeakReference<Class<?>>(cryptClass);
		this.encryptionKey = encryptionKey;
	}
	public ICrypt newCrypt(){
		try{
			ICrypt crypt = (ICrypt)(cryptClass.get()).newInstance();
			log.info(""using encryption/decryption object "" + crypt);
			crypt.setKey(encryptionKey);
			return crypt;
		}
		catch (Throwable e){
			log.warn(""************************** WARNING **************************"");
			log.warn(""As the instantion of encryption/decryption class:"");
			log.warn(""\t"" + cryptClass);
			log.warn(""failed, Wicket will fallback on a dummy implementation"");
			log.warn(""\t("" + NoCrypt.class.getName() + "")"");
			log.warn(""This is not recommended for production systems."");
			log.warn(""Please override method org.apache.wicket.Application.newCrypt()"");
			log.warn(""to provide a custom encryption/decryption implementation"");
			log.warn(""The cause of the instantion failure: "");
			log.warn(""\t"" + e.getMessage());
			if (log.isDebugEnabled()){
				log.debug(""exception: "", e);
			}
			else{
				log.warn(""set log level to DEBUG to display the stack trace."");
			}
			log.warn(""*************************************************************"");
			return new NoCrypt();
		}
	}
}",0,0,0,0
"protected boolean connectImpl() {
	int sleepInterval = 0;
	boolean isRedirect = false;
	if (stop) {
		closeImpl();
		return false;
	}
	if (!""HLS"".equals(chunk.getTag())) {
		if (chunk.getLength() < 0 && chunk.getDownloaded() > 0) {
			errorCode = XDMConstants.ERR_NO_RESUME;
			closeImpl();
			Logger.log(""server does not support resuming"");
			return false;
		}
		try {
			chunk.reopenStream();
		}
		 catch (IOException e) {
			Logger.log(e);
			closeImpl();
			errorCode = XDMConstants.ERR_NO_RESUME;
			return false;
		}
	}
	 else {
		try {
			chunk.reopenStream();
			chunk.resetStream();
			chunk.setDownloaded(0);
		}
		 catch (IOException e) {
			Logger.log(""Stream rest failed"");
			Logger.log(e);
		}
	}
	while (!stop) {
		isRedirect = false;
		try {
			Logger.log(""Connecting to: "" + url + "" "" + chunk.getTag());
			WebProxy wp = ProxyResolver.resolve(url);
			if (wp != null) {
				javaClientRequired = true;
			}
			if (javaClientRequired) {
				hc = new JavaHttpClient(url);
			}
			 else {
				hc = new XDMHttpClient(url);
			}
			if (headers != null) {
				Iterator<HttpHeader> headerIt = headers.getAll();
				while (headerIt.hasNext()) {
					HttpHeader header = headerIt.next();
					hc.setHeader(header.getName(), header.getValue());
				}
			}
			long length = chunk.getLength();
			long startOff = chunk.getStartOffset() + chunk.getDownloaded();
			long endOff = startOff + length - chunk.getDownloaded();
			long expectedLength = endOff - startOff;
			if (length > 0 && expectedLength > 0) {
				Logger.log(chunk + "" requesting:- "" + ""Range:"" + ""bytes="" + startOff + ""-"" + (endOff - 1));
				hc.setHeader(""Range"", ""bytes="" + startOff + ""-"" + (endOff - 1));
			}
			 else {
				hc.setHeader(""Range"", ""bytes=0-"");
			}
			hc.connect();
			if (stop) {
				closeImpl();
				return false;
			}
			int code = hc.getStatusCode();
			Logger.log(chunk + "": "" + code);
			if (code >= 300 && code < 400) {
				closeImpl();
				if (totalLength > 0) {
					errorCode = XDMConstants.ERR_INVALID_RESP;
					Logger.log(chunk + "" Redirecting twice"");
					return false;
				}
				 else {
					url = hc.getResponseHeader(""location"");
					Logger.log(chunk + "" location: "" + url);
					if (!url.startsWith(""http"")) {
						if (!url.startsWith(""/"")) {
							url = ""/"" + url;
						}
					url = ""http:}
					url = url.replace("" "", ""%20"");
					isRedirect = true;
					redirected = true;
					redirectUrl = url;
					throw new Exception(""Redirecting to: "" + url);
				}
			}
			if (code != 200 && code != 206 && code != 416 && code != 413 && code != 401 && code != 408&& code != 407 && code != 503) {
				errorCode = XDMConstants.ERR_INVALID_RESP;
				closeImpl();
				return false;
			}
			if (code == 407 || code == 401) {
				if (javaClientRequired) {
					Logger.log(""asking for password"");
					boolean proxy = code == 407;
					if (!chunk.promptCredential(hc.getHost(), proxy)) {
						errorCode = XDMConstants.ERR_INVALID_RESP;
						closeImpl();
						return false;
					}
				}
				throw new JavaClientRequiredException();
			}
			if (""T1"".equals(chunk.getTag()) || ""T2"".equals(chunk.getTag())) {
				if (""text/plain"".equals(hc.getResponseHeader(""content-type""))) {
					ByteArrayOutputStream bout = new ByteArrayOutputStream();
					InputStream inStr = hc.getInputStream();
					System.out.println(inStr);
					long len = hc.getContentLength();
					int read = 0;
					System.out.println(""reading url of length: "" + len);
					while (true) {
						if (len > 0 && read == len)break;
						int x = inStr.read();
						if (x == -1) {
							if (len > 0) {
								throw new IOException(""Unable to read url: unexpected EOF"");
							}
							 else {
								break;
							}
						}
						read++;
						System.out.print((char) x);
						bout.write(x);
					}
					byte[] buf = bout.toByteArray();
					url = new String(buf, Charset.forName(""ASCII""));
					isRedirect = true;
					throw new Exception(""Youtube text redirect to: "" + url);
				}
			}
			if (((chunk.getDownloaded() + chunk.getStartOffset()) > 0) && code != 206) {
				closeImpl();
				errorCode = XDMConstants.ERR_NO_RESUME;
				return false;
			}
			if (""HLS"".equals(chunk.getTag())) {
				firstLength = -1;
			}
			 else {
				firstLength = hc.getContentLength();
			}
			if (length > 0) {
				if (firstLength != expectedLength){
					Logger.log(chunk + "" length mismatch: expected: "" + expectedLength + "" got: "" + firstLength);
					errorCode = XDMConstants.ERR_NO_RESUME;
					closeImpl();
					return false;
				}
			}
			if (hc.getContentLength() > 0 && XDMUtils.getFreeSpace(null) < hc.getContentLength()) {
				Logger.log(""Disk is full"");
				errorCode = XDMConstants.DISK_FAIURE;
				closeImpl();
				return false;
			}
			in = hc.getInputStream();
			Logger.log(""Connection success"");
			return true;
		}
		 catch (JavaClientRequiredException e) {
			Logger.log(""java client required"");
			javaClientRequired = true;
			sleepInterval = 0;
		}
		 catch (Exception e) {
			Logger.log(chunk);
			Logger.log(e);
			if (isRedirect) {
				closeImpl();
				continue;
			}
			sleepInterval = 5000;
		}
		closeImpl();
		try {
			Thread.sleep(sleepInterval);
		}
		 catch (Exception e) {
		}
	}
	Logger.log(""return as "" + errorCode);
	return false;
}",0,0,1,0
"public class TestHelper {
	 public static int dispAfterNumTuples = 1000;
	 public static boolean bagContains(DataBag db, Tuple t) {
		 Iterator<Tuple> iter = db.iterator();
		 for (Tuple tuple : db) {
			 if (tuple.compareTo(t) == 0 || tupleEquals(tuple, t)) return true;
		 }
		 return false;
	 }
	 public static boolean compareBags(DataBag db1, DataBag db2) {
		 if (db1.size() != db2.size()) return false;
		 boolean equal = true;
		 for (Tuple tuple : db2) {
			 boolean contains = false;
			 for (Tuple tuple2 : db1) {
				 if (tuple.compareTo(tuple2) == 0) {
					 contains = true;
					 break;
				 }
			 }
			 if (!contains) {
				 equal = false;
				 break;
			 }
		 }
		 return equal;
	 }
	 public static boolean compareCogroupOutputs(DataBag db1, DataBag db2) throws ExecException{
		 if (db1.size() != db2.size()) return false;
		 Map<Object,DataBag> first = new HashMap<Object, DataBag>();
		 for (Tuple t : db1) first.put(t.get(0), (DataBag)t.get(1));
		 Map<Object,DataBag> second = new HashMap<Object, DataBag>();
		 for (Tuple t : db2) second.put(t.get(0), (DataBag)t.get(1));
		 Set<Entry<Object,DataBag>> entrySet = first.entrySet();
		 for (Entry<Object,DataBag> entry : entrySet){
			 Object key = entry.getKey();
			 DataBag bagOfSecond = second.get(key);
			 if(bagOfSecond == null) return false;
			 boolean cmpVal = compareBags(bagOfSecond, entry.getValue());
			 if(cmpVal == false) return false;
		 }
		 return true;
	 }
	 public static DataBag projectBag(DataBag db2, int i) throws ExecException {
		 DataBag ret = DefaultBagFactory.getInstance().newDefaultBag();
		 for (Tuple tuple : db2) {
			 Object o = tuple.get(i);
			 Tuple t1 = new DefaultTuple();
			 t1.append(o);
			 ret.add(t1);
		 }
		 return ret;
	 }
	 public static DataBag projectBag(DataBag db2, int[] fields) throws ExecException {
		 DataBag ret = DefaultBagFactory.getInstance().newDefaultBag();
		 for (Tuple tuple : db2) {
			 Tuple t1 = new DefaultTuple();
			 for (int fld : fields) {
				 Object o = tuple.get(fld);
				 t1.append(o);
			 }
			 ret.add(t1);
		 }
		 return ret;
	 }
	 public static int compareInputStreams(InputStream exp, InputStream act) throws IOException{
		 byte[] bExp = new byte[4096], bAct = new byte[4096];
		 int outLen,inLen = -1;
		 while(act.read(bAct)!=-1){
			 exp.read(bExp);
			 int cmp = compareByteArray(bExp, bAct);
			 if(cmp!=0) return cmp;
		 }
		 return 0;
	 }
	 public static int compareByteArray(byte[] b1, byte[] b2){
		 if(b1.length>b2.length) return 1;
		 else if(b1.length<b2.length) return -1;
		 for(int i=0;
		i<b1.length;
		i++){
			 if(b1[i]>b2[i]) return 1;
			 else if(b1[i]<b2[i]) return -1;
		 }
		 return 0;
	 }
	 public static boolean areFilesSame(FileSpec expLocal, FileSpec actHadoop, PigContext pc) throws ExecException, IOException{
		 Random r = new Random();
		 POLoad ldExp = new POLoad(new OperatorKey("""", r.nextLong()));
		 ldExp.setPc(pc);
		 ldExp.setLFile(expLocal);
		 POLoad ldAct = new POLoad(new OperatorKey("""", r.nextLong()));
		 ldAct.setPc(pc);
		 ldAct.setLFile(actHadoop);
		 Tuple t = null;
		 int numActTuples = -1;
		 DataBag bagAct = DefaultBagFactory.getInstance().newDefaultBag();
		 Result resAct = null;
		 while((resAct = ldAct.getNextTuple()).returnStatus!=POStatus.STATUS_EOP){
			 ++numActTuples;
			 bagAct.add(trimTuple((Tuple)resAct.result));
		 }
		 int numExpTuples = -1;
		 DataBag bagExp = DefaultBagFactory.getInstance().newDefaultBag();
		 Result resExp = null;
		 while((resExp = ldExp.getNextTuple()).returnStatus!=POStatus.STATUS_EOP){
			 ++numExpTuples;
			 bagExp.add(trimTuple((Tuple)resExp.result));
		 }
		 if(numActTuples!=numExpTuples) return false;
		 return compareBags(bagExp, bagAct);
	 }
	 private static Tuple trimTuple(Tuple t){
		 Tuple ret = TupleFactory.getInstance().newTuple();
		 for (Object o : t.getAll()) {
			 DataByteArray dba = (DataByteArray)o;
			 DataByteArray nDba = new DataByteArray(dba.toString().trim().getBytes());
			 ret.append(nDba);
		 }
		 return ret;
	 }
	 public static File createTempFile(String[][] data) throws IOException {
		 File fp1 = File.createTempFile(""test"", ""txt"");
		 PrintStream ps = new PrintStream(new FileOutputStream(fp1));
		 for(int i = 0;
		 i < data.length ;
		 i++) {
			 StringBuilder sb = new StringBuilder() ;
			 for(int j = 0 ;
			 j < data[0].length ;
			 j++) {
				 if (j != 0) {
					 sb.append(""\t"") ;
				 }
				 sb.append(data[i][j]) ;
			 }
			 ps.println(sb.toString());
		 }
		 ps.close();
		 return fp1 ;
	 }
	 public static boolean mapEquals(Map<String, Object> expectedMap, Map<String, Object> convertedMap) {
		 if(expectedMap == null) {
			 if(convertedMap != null) {
				 return false;
			 }
		 }
		 else {
			 if (convertedMap == null) {
				 return false;
			 }
		 }
		 if(expectedMap.size() != convertedMap.size()) {
			 return false;
		 }
		 for(String key: expectedMap.keySet()) {
			 Object v = convertedMap.get(key);
			 String convertedValue = new String(((DataByteArray)v).get());
			 if(!expectedMap.get(key).toString().equals(convertedValue)) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public static boolean tupleEquals(Tuple expectedTuple, Tuple convertedTuple) {
		 if(expectedTuple == null) {
			 if(convertedTuple != null) {
				 return false;
			 }
		 }
		 else {
			 if(convertedTuple == null) {
				 return false;
			 }
		 }
		 if(expectedTuple.size() != convertedTuple.size()) {
			 return false;
		 }
		 for(int i = 0;
		 i < expectedTuple.size();
		 ++i) {
			 Object e ;
			 Object c ;
			 try {
				 e = expectedTuple.get(i);
				 c = convertedTuple.get(i);
			 }
			 catch (Exception e1) {
				 return false;
			 }
			 if(e instanceof Map) {
				 Map<String, Object> eMap = (Map<String, Object>)e;
				 if(c instanceof Map) {
					 Map<String, Object> cMap = (Map<String, Object>)c;
					 if(!mapEquals(eMap, cMap)) {
						 return false;
					 }
				 }
				 else {
					 return false;
				 }
			 }
			 else if (e instanceof Tuple) {
				 if(c instanceof Tuple) {
					 if(!tupleEquals((Tuple)e, (Tuple)c)) {
						 return false;
					 }
				 }
				 else {
					 return false;
				 }
			 }
			 else if (e instanceof DataBag){
				 if(c instanceof DataBag) {
					 if(!bagEquals((DataBag)e, (DataBag)c)) {
						 return false;
					 }
				 }
				 else {
					 return false;
				 }
			 }
			 else {
				 if(e == null) {
					 if(c != null) {
						 return false;
					 }
				 }
				 else {
					 if(c == null) {
						 return false;
					 }
					 else {
						 if(!e.equals(c)) {
							 return false;
						 }
					 }
				 }
			 }
		 }
		 return true;
	 }
	 public static boolean bagEquals(DataBag expectedBag, DataBag convertedBag) {
		 if(expectedBag == null) {
			 if(convertedBag != null) {
				 return false;
			 }
		 }
		 else {
			 if(convertedBag == null) {
				 return false;
			 }
		 }
		 if(expectedBag.size() != convertedBag.size()) {
			 return false;
		 }
		 Iterator<Tuple> expectedBagIterator = expectedBag.iterator();
		 Iterator<Tuple> convertedBagIterator = convertedBag.iterator();
		 while(expectedBagIterator.hasNext()) {
			 Tuple expectedBagTuple = expectedBagIterator.next();
			 Tuple convertedBagTuple = convertedBagIterator.next();
			 if(!tupleEquals(expectedBagTuple, convertedBagTuple)) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public static String sortString(String regex, String target, String split) {
		 Pattern p = Pattern.compile(regex);
		 Matcher matcher = p.matcher(target);
		 String original = null;
		 String replaceString = new String();
		 if (matcher.find()) {
			 original = matcher.group(1);
			 String[] out = original.split(split);
			 Collections.sort(Arrays.asList(out));
			 for (int j = 0;
			 j < out.length;
			 j++) {
				 replaceString += (j > 0 ? "", "" + out[j] : out[j]);
			 }
			 return target.replace(original, replaceString);
		 }
		 return target;
	 }
	 public static String sortUDFs(String goldenString) {
		 String regex = ""MapReduce\\([0-9]*\\,(.*)\\) - -[0-9]*\\:"";
		 String[] goldenArray = goldenString.split(""\n"");
		 for (int i = 0;
		 i < goldenArray.length;
		 i++) {
			 goldenString = goldenString.replace(goldenArray[i], sortString(regex, goldenArray[i], "",""));
		 }
		 return goldenString;
	 }
	 public static List<String> sortSubFields(List<String> logMessages) {
		 String regex = ""\\[(.*)\\]"";
		 for (int i = 0;
		 i < logMessages.size();
		 i++) {
			 logMessages.set(i, sortString(regex, logMessages.get(i), "", ""));
		 }
		 return logMessages;
	 }
	 public static String sortStringList(String text, String delimiter1, String delimiter2, String separator){
		 Pattern pattern = Pattern.compile(String.format(""(\\%s.*?\\%s)"", delimiter1, delimiter2));
		 Matcher matcher = pattern.matcher(text);
		 String sortedString = text;
		 while (matcher.find()) {
			 String value = matcher.group(1);
			 value = value.substring(1,value.length()-1);
			 String[] sortedList = value.split(separator);
			 Arrays.sort(sortedList);
			 String sorted = Arrays.asList(sortedList).toString().replaceAll(""(^.|.$)"", """").replace("", "", separator);
			 sorted = String.format(""%s%s%s"", delimiter1, sorted, delimiter2);
			 sortedString = sortedString.replace(matcher.group(1), sorted);
		 }
		 return sortedString;
	 }
 }",1,0,0,0
"class Cel4rreg {
	 long seghigh;
	 long seglow;
	 int p_dsafmt = -1;
	 long p_dsaptr;
	 RegisterSet regs;
	 Cel4rreg() {
		 String useSvcdump = System.getProperty(""zebedee.use.svcdump"");
		 if (useSvcdump != null && useSvcdump.equals(""true"")) {
			 getRegistersFromSvcdump();
			 return;
		 }
		 int whereCount = 0;
		 try {
			 if ((regs = getRegistersFromRTM2()) != null && whereCount++ >= whereSkip) {
				 whereFound = ""RTM2"";
				 failingRegisters = regs;
				 registers = regs;
				 return;
			 }
		 }
		 catch (IOException e) {
			 throw new Error(""oops: "" + e);
		 }
		 try {
			 if ((regs = getRegistersFromBPXGMSTA()) != null && whereCount++ >= whereSkip) {
				 whereFound = regs.whereFound();
				 if (whereFound == null) whereFound = ""BPXGMSTA"";
				 if (tcb.tcbcmp() != 0) failingRegisters = regs;
				 registers = regs;
				 return;
			 }
		 }
		 catch (IOException e) {
		 }
		 try {
			 if ((regs = getRegistersFromLinkageStack()) != null && whereCount++ >= whereSkip) {
				 whereFound = ""Linkage"";
				 if (tcb.tcbcmp() != 0) failingRegisters = regs;
				 registers = regs;
				 return;
			 }
		 }
		 catch (IOException e) {
			 log.logp(Level.WARNING,""com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg"", ""Cel4rreg"",""Unexepected exception"", e);
			 throw new Error(""Unexpected IOException: "" + e);
		 }
		 try {
			 if ((regs = getRegistersFromTCB()) != null && whereCount++ >= whereSkip) {
				 whereFound = ""TCB"";
				 if (tcb.tcbcmp() != 0) failingRegisters = regs;
				 registers = regs;
				 return;
			 }
		 }
		 catch (IOException e) {
			 throw new Error(""oops: "" + e);
		 }
		 try {
			 if (is64bit) {
				 long lca = CeexlaaTemplate.getCeelaa_lca64(inputStream, laa);
				 p_dsaptr = CeelcaTemplate.getCeelca_savstack(inputStream, lca);
				 log.fine(""p_dsaptr from lca = "" + hex(p_dsaptr));
				 p_dsafmt = stackdirection = CEECAASTACK_DOWN;
				 if (validateDSA() == 0 && whereCount++ >= whereSkip) {
					 whereFound = ""LCA"";
					 return;
				 }
			 }
		 }
		 catch (IOException e) {
			 throw new Error(""oops: "" + e);
		 }
		 try {
			 if ((regs = getRegistersFromUsta()) != null && whereCount++ >= whereSkip) {
				 whereFound = regs.whereFound();
				 if (tcb.tcbcmp() != 0) failingRegisters = regs;
				 registers = regs;
				 return;
			 }
		 }
		 catch (IOException e) {
		 }
		 whereFound = ""not found"";
	 }
	 private RegisterSet getRegistersFromRTM2() throws IOException {
		 int level = ceecaalevel();
		 log.finer(""caa level is "" + level);
		 if (is64bit) {
			 stackdirection = CEECAASTACK_DOWN;
			 log.finer(""stack direction is down"");
		 }
		 else if (level >= 13) {
			 stackdirection = ceecaa_stackdirection();
			 log.finer(""stack direction is "" + (stackdirection == CEECAASTACK_UP ? ""up"" : ""down""));
		 }
		 else {
			 stackdirection = CEECAASTACK_UP;
			 log.finer(""stack direction is up"");
		 }
		 if ((stackdirection == CEECAASTACK_DOWN) && !is64bit) {
			 try {
				 long tempptr = ceecaasmcb();
				 seghigh = SmcbTemplate.getSmcb_dsbos(inputStream, tempptr);
				 seglow = CeexstkhTemplate.getStkh_stackfloor(inputStream, seghigh);
			 }
			 catch (Exception e) {
				 return null;
			 }
		 }
		 long rtm2ptr = tcb.tcbrtwa();
		 if (rtm2ptr != 0) {
			 try {
				 log.finer(""found some rtm2 registers"");
				 RegisterSet regs = new RegisterSet();
				 long rtm2grs = rtm2ptr + Ihartm2aTemplate.getRtm2ereg$offset();
				 long rtm2grshi = rtm2ptr + Ihartm2aTemplate.getRtm2g64h$offset();
				 for (int i = 0;
				 i < 16;
				 i++) {
					 long low = space.readUnsignedInt(rtm2grs + i*4);
					 long high = is64bit ? space.readUnsignedInt(rtm2grshi + i*4) : 0;
					 regs.setRegister(i, (high << 32) | low);
				 }
				 long rtm2psw = rtm2ptr + Ihartm2aTemplate.getRtm2apsw$offset();
				 regs.setPSW(space.readLong(rtm2psw));
				 if (registersValid(regs)) {
					 log.finer(""found good dsa in rtm2"");
				 }
				 else {
					 log.finer(""bad dsa in rtm2"");
					 regs = null;
				 }
				 return regs;
			 }
			 catch (IOException e) {
				 throw e;
			 }
			 catch (Exception e) {
				 throw new Error(""oops: "" + e);
			 }
		 }
		 else {
			 log.finer(""failed to get registers from rtm2"");
			 return null;
		 }
	 }
	 private boolean registersValid(RegisterSet regs) throws IOException {
		 if (regs == null) return false;
		 p_dsafmt = stackdirection;
		 if (p_dsafmt == CEECAASTACK_DOWN) {
			 p_dsaptr = regs.getRegisterAsAddress(4);
			 log.finer(""p_dsaptr from reg 4 = "" + hex(p_dsaptr));
		 }
		 else {
			 p_dsaptr = regs.getRegisterAsAddress(13);
			 log.finer(""p_dsaptr from reg 13 = "" + hex(p_dsaptr));
		 }
		 int lastrc = validateDSA();
		 if (lastrc == 0) {
			 log.finer(""found valid dsa"");
			 return true;
		 }
		 else {
			 if (stackdirection == CEECAASTACK_DOWN) {
				 p_dsaptr = regs.getRegisterAsAddress(13);
				 log.finer(""p_dsaptr from reg 13 (again) = "" + hex(p_dsaptr));
				 p_dsafmt = CEECAASTACK_UP;
				 lastrc = validateDSA();
				 if (lastrc == WARNING) {
					 lastrc = validateDSA();
					 if (lastrc == 0) {
						 log.finer(""found valid dsa"");
						 return true;
					 }
				 }
			 }
			 log.finer(""p_dsaptr invalid so reset: "" + hex(p_dsaptr));
			 p_dsaptr = 0;
		 }
		 return false;
	 }
	 private RegisterSet getRegistersFromBPXGMSTA() throws IOException {
		 RegisterSet regs = tcb.getRegistersFromBPXGMSTA();
		 if (is64bit) stackdirection = CEECAASTACK_DOWN;
		 if (registersValid(regs)) {
			 log.finer(""found good dsa in BPXGMSTA"");
			 return regs;
		 }
		 else {
			 log.finer(""BPX registers are invalid so keep looking"");
			 return null;
		 }
	 }
	 private RegisterSet getRegistersFromLinkageStack() throws IOException {
		 log.finer(""enter getRegistersFromLinkageStack"");
		 try {
			 Lse[] linkageStack = tcb.getLinkageStack();
			 if (linkageStack.length == 0) {
				 log.finer(""empty linkage stack"");
				 return null;
			 }
			 for (int i = 0;
			 i < linkageStack.length;
			 i++) {
				 Lse lse = linkageStack[i];
				 if (lse.lses1pasn() == space.getAsid()) {
					 RegisterSet regs = new RegisterSet();
					 if (lse.isZArchitecture() && (lse.lses1typ7() == Lse.LSED1PC || lse.lses1typ7() == Lse.LSED1BAKR)) {
						 log.finer(""found some z arch registers"");
						 regs.setPSW(lse.lses1pswh());
						 for (int j = 0;
						 j < 16;
						 j++) {
							 regs.setRegister(j, lse.lses1grs(j));
						 }
					 }
					 else {
						 log.finer(""found some non z arch registers"");
						 regs.setPSW(lse.lsespsw());
						 for (int j = 0;
						 j < 16;
						 j++) {
							 regs.setRegister(j, lse.lsesgrs(j));
						 }
					 }
					 if (registersValid(regs)) {
						 log.finer(""found good dsa in linkage stack"");
						 return regs;
					 }
				 }
				 else {
					 log.finer(""different asid: "" + hex(lse.lses1pasn()));
				 }
			 }
		 }
		 catch (IOException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 throw new Error(""oops: "" + e);
		 }
		 log.finer(""could not find registers in linkage stack"");
		 return null;
	 }
	 private RegisterSet getRegistersFromTCB() throws IOException {
		 log.finer(""getRegistersFromTCB"");
		 RegisterSet regs = tcb.getRegisters();
		 if (registersValid(regs)) {
			 log.finer(""found good dsa in TCB"");
			 return regs;
		 }
		 else {
			 return null;
		 }
	 }
	 private RegisterSet getRegistersFromUsta() throws IOException {
		 log.fine(""enter getRegistersFromUsta"");
		 RegisterSet regs = tcb.getRegistersFromUsta();
		 if (registersValid(regs)) {
			 log.finer(""found good dsa in Usta"");
			 return regs;
		 }
		 else {
			 boolean isDownStack = stackdirection == CEECAASTACK_DOWN;
			 long dsaptr;
			 if (isDownStack) {
				 dsaptr = regs.getRegister(4);
				 log.finer(""p_dsaptr from reg 4 = "" + hex(p_dsaptr));
			 }
			 else {
				 dsaptr = regs.getRegister(13);
				 log.finer(""p_dsaptr from reg 13 = "" + hex(p_dsaptr));
			 }
			 try {
				 DsaStackFrame dsa = new DsaStackFrame(dsaptr, isDownStack, regs, space, Caa.this);
				 int count = 0;
				 for (;
				 dsa != null;
				 dsa = dsa.getParentFrame()) {
					 if (++count > 3) {
						 p_dsaptr = dsaptr;
						 p_dsafmt = stackdirection;
						 return regs;
					 }
				 }
			 }
			 catch (IOException e) {
			 }
			 catch (AssertionError e) {
			 }
		 }
		 return null;
	 }
	 private void getRegistersFromSvcdump() {
	 }
	 private int validateDSA() {
		 log.finer(""attempt to validate "" + hex(p_dsaptr) + "" on "" + (p_dsafmt == CEECAASTACK_DOWN ? ""down"" : ""up"") + "" stack"");
		 try {
			 if (is64bit) {
				 assert laa != 0;
				 long l_sancptr = CeexlaaTemplate.getCeelaa_sanc64(inputStream, laa);
				 assert l_sancptr != 0;
				 long seghigh = CeexsancTemplate.getSanc_bos(inputStream, l_sancptr);
				 long seglow = 0;
				 long sanc_stack = CeexsancTemplate.getSanc_stack(inputStream, l_sancptr);
				 long sanc_user_stack = CeexsancTemplate.getSanc_user_stack(inputStream, l_sancptr);
				 if (sanc_stack == sanc_user_stack) {
					 seglow = CeexsancTemplate.getSanc_user_floor(inputStream, l_sancptr);
				 }
				 else {
					 seglow = CeexlaaTemplate.getCeelaa_stackfloor64(inputStream, laa);
				 }
				 if (p_dsaptr < seghigh && (p_dsaptr + 0x800) >= seglow && (p_dsaptr & 0xf) == 0) {
					 log.finer(""dsa "" + hex(p_dsaptr) + "" is within seglow = "" + hex(seglow) + "" seghigh = "" + hex(seghigh));
					 return 0;
				 }
				 else {
					 log.finer(""dsa "" + hex(p_dsaptr) + "" is NOT within seglow = "" + hex(seglow) + "" seghigh = "" + hex(seghigh));
					 return ERROR;
				 }
			 }
			 if (p_dsafmt == CEECAASTACK_DOWN) {
			 }
			 else {
				 if (is64bit) return ERROR;
				 long tptr = ceecaaerrcm();
				 if (p_dsaptr < (tptr + hcomLength) && p_dsaptr >= tptr && (p_dsaptr & 7) == 0) {
					 log.finer(""upstack dsa "" + hex(p_dsaptr) + "" is inside hcom"");
					 return 0;
				 }
			 }
			 long ddsa = ceecaaddsa();
			 long dsaptr = p_dsaptr;
			 int dsafmt8 = p_dsafmt;
			 long slowdsaptr = p_dsaptr;
			 int slowdsafmt8 = p_dsafmt;
			 for (boolean slow = false;
			;
			 slow = !slow) {
				 Ceexdsaf dsaf = new Ceexdsaf(space, dsaptr, dsafmt8, is64bit);
				 log.finer(""looping with dsa = "" + hex(dsaptr));
				 if (stackdirection == CEECAASTACK_DOWN && p_dsafmt == CEECAASTACK_UP && dsaptr < seghigh && dsaptr >= seglow) {
					 p_dsaptr = CeedsaTemplate.getCeedsar4(inputStream, dsaptr);
					 p_dsafmt = CEECAASTACK_DOWN;
					 log.finer(""warning, try switching to down stack"");
					 return WARNING;
				 }
				 long callers_dsaptr = dsaf.DSA_Prev;
				 dsafmt8 = dsaf.DSA_Format;
				 if (callers_dsaptr == 0 || callers_dsaptr == F1SA) {
					 log.finer(""cannot backchain futher because "" + (callers_dsaptr == 0 ? ""zero"" : ""linkage stack"") + "" found"");
					 return ERROR;
				 }
				 if (callers_dsaptr == ddsa) {
					 log.finer(""dummy dsa reached"");
					 return 0;
				 }
				 if (dsafmt8 != p_dsafmt) {
					 log.finer(""backchained across a stack transition"");
					 return 0;
				 }
				 if (dsafmt8 == CEECAASTACK_UP) {
					 long tptr = CeedsaTemplate.getCeedsanab(inputStream, callers_dsaptr);
					 if (tptr == dsaptr) {
						 log.finer(""upstack DSA is good"");
						 return 0;
					 }
				 }
				 dsaptr = callers_dsaptr;
				 if (slow) {
					 dsaf = new Ceexdsaf(space, slowdsaptr, slowdsafmt8, is64bit);
					 slowdsaptr = dsaf.DSA_Prev;
					 slowdsafmt8 = dsaf.DSA_Format;
				 }
				 if (dsaptr == slowdsaptr) {
					 log.finer(""loop detected in DSA chain"");
					 return ERROR;
				 }
			 }
		 }
		 catch (IOException e) {
			 log.logp(Level.FINER,""com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg"", ""validateDSA"",""Bad read"", e);
			 return ERROR;
		 }
		 catch (Exception e) {
			 log.logp(Level.WARNING,""com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg"", ""validateDSA"",""Unexepected exception"", e);
			 throw new Error(""Unexpected Exception:: "" + e);
		 }
	 }
 }",1,0,0,0
"public abstract class SizeLimitCollection extends BaseResourceCollectionWrapper {
	 private static final String BAD_COUNT = ""size-limited collection count should be set to an int >= 0"";
	 private int count = 1;
	 public synchronized void setCount(int i) {
		 checkAttributesAllowed();
		 count = i;
	 }
	 public synchronized int getCount() {
		 return count;
	 }
	 public synchronized int size() {
		 int sz = getResourceCollection().size();
		 int ct = getValidCount();
		 return sz < ct ? sz : ct;
	 }
	 protected int getValidCount() {
		 int ct = getCount();
		 if (ct < 0) {
			 throw new BuildException(BAD_COUNT);
		 }
		 return ct;
	 }
}",0,0,0,0
"public class Server implements IReloadable {
	private static final String VERSION = ""1.3.20100406"";
	public static final int REQUEST_TYPE_HTTP = 1;
	public static String BASE_PATH;
	 public static final long startupTime=System.currentTimeMillis();
	 public volatile String SMILEY_SERVER;
	 public volatile boolean USE_SMILEY;
	 public volatile int SMILEY_PER_LINE;
	 public String[] ADMIN_HTTP_USERNAME, ADMIN_HTTP_PASSWORD, ADMIN_HTTP_SECLEVEL;
	 public String DEFAULT_CHARSET=""iso-8859-1"", TIMEZONE, ADMIN_HTTP_ALLOWED, ADMIN_XMLRPC_ALLOWED, DEFAULT_TEMPLATESET, DEFAULT_MEMBERSHIP;
	public long TOUCH_USER_DELAY, READER_MAX_IDLETIME, FILE_CHECK_INTERVAL, FLOOD_PROTECT_MILLIS, USER_TIMEOUT, USER_AWAY_TIMEOUT, USER_REMOVE_SCHEDULE_TIME, HOST_BAN_DURATION, VIP_TIMEOUT, VIP_AWAY_TIMEOUT, READER_TIMEOUT, LOGIN_TIMEOUT, PUNISH_DURATION;
	public boolean ALLOW_EXTERNAL, DEBUG_TEMPLATESET, USE_HTTP11, USE_IP_BAN, THREAD_PER_READ, USE_TOKENSTORE, MD5_PASSWORDS, USE_MESSAGE_RENDER_CACHE, USE_TRAFFIC_MONITOR, USE_CENTRAL_REQUESTQUEUE, ALLOW_CHANGE_USERAGENT, STRICT_HOST_BINDING,CAN_DEL_LOGS, USE_FADECOLOR, USE_BGCOLOR, BLOCKED_NICK_AUTOHARDKICK, USE_PLUGINS;
	public int READER_MAX_QUEUE, READER_MAX_QUEUE_USAGE, MAX_READERS, MAX_BAN_DURATION, MAX_FLOCK_DURATION, MAX_SU_BAN_DURATION, DEFAULT_BAN_DURATION, FLOOD_PROTECT_TOLERANC, FLOOD_BAN_DURATION, READBUFFER_SIZE, MAX_USERS, COLOR_CHANGE_INTERVAL, MESSAGE_FLOOD_INTERVAL, MAX_USERNAME_LENGTH, MAX_DIE_NUMBER, MAX_DIE_EYES, TCP_RECEIVE_BUFFER_WINDOW, LOG_QUEUE_SIZE, MAX_REQUESTS_PER_PROXY_IP, MAX_REQUESTS_PER_IP, MAX_SUUSERS_PER_STARTGROUP, INITIAL_RESPONSE_QUEUE, MAX_RESPONSE_QUEUE, MAX_GROUPNAME_LENGTH, MAX_GROUPTHEME_LENGTH, ADMIN_XMLRPC_PORT, TOOL_PROTECT_COUNTER, TOOL_PROTECT_TOLERANC, TOOL_BAN_DURATION, TOOL_PROTECT_MINMILLS, TOOL_PROTECT_MINCOUNTER, JOIN_PUNISHED_COUNTER, LOGFILE_DELDAYS, LOGFILE_DELHOUR, MESSAGE_FLOOD_LENGHT, MAX_MCALL_KEY, MAX_PMSTORE;
	private Vector<InetAddress> adminHosts;
	private Vector<String> tempAdmins;
	public Vector<InetAddress> allowedLoginHosts;
	 public Vector<String> SERVER_NAME;
	public StringBuffer COOKIE_DOMAIN;
	public TemplateManager templatemanager = null;
	public AuthManager auth;
	public static Server srv = null;
	private Hashtable<String, BanObject> banList;
	private Hashtable<ActionstoreObject, String> storeList;
	public InetAddress lh = null;
	public Propertiesprops;
	public static Calendarcal = Calendar.getInstance();
	private volatile boolean isRunning = true;
	 public Charset defaultCs=Charset.forName(DEFAULT_CHARSET);
	 public CharsetEncoder defaultCsEnc=defaultCs.newEncoder();
	 public static boolean TRACE_CREATE_AND_FINALIZE = false;
	private Hashtable<String, String>tokenStore = new Hashtable<String, String>();
	 public long KEEP_ALIVE_TIMEOUT;
	public String UNAME_PREFIX_GOD, UNAME_PREFIX_GUEST,UNAME_PREFIX_MODERATOR,UNAME_PREFIX_PUNISHED,UNAME_PREFIX_SU,UNAME_PREFIX_VIP,UNAME_SUFFIX_GOD, UNAME_SUFFIX_GUEST,UNAME_SUFFIX_MODERATOR,UNAME_SUFFIX_PUNISHED,UNAME_SUFFIX_SU,UNAME_SUFFIX_VIP;
	 public short FN_DEFAULT_MODE_FALSE = 0;
	 public short FN_DEFAULT_MODE_TRUE = 2;
	 public short COLOR_LOCK_MODE = 0;
	 public short COLOR_LOCK_LEVEL = 1, FADECOLOR_LOCK_LEVEL = -1;
	 public String MIN_BBC_FONT_RIGHT_ENTRACE, MIN_BBC_FONT_RIGHT_SEPA, MIN_BBC_B_RIGHT_ENTRACE, MIN_BBC_B_RIGHT_SEPA, MIN_BBC_U_RIGHT_ENTRACE, MIN_BBC_U_RIGHT_SEPA, MIN_BBC_I_RIGHT_ENTRACE, MIN_BBC_I_RIGHT_SEPA ;
	 public boolean USE_BBC, BBC_CONVERT_GROUPNAME, BBC_CONVERT_GROUPTHEME;
	 public int MAX_BBCTAGS;
	 public HashMap <String, Object> pluginStore = new HashMap<String, Object>();
	 public IServerPlugin [] serverPlugin = null;
	 public HashMap<String, Object> allCommands = new HashMap<String, Object>();
	 public HashMap<String, Object> xmlRpcHandler = new HashMap<String, Object>();
	public Server () {
		LOG_MASK[0]=new Short (LVL_MINOR);
		LOG_MASK[1]=new Short (LVL_MINOR);
		LOG_MASK[2]=new Short (LVL_MINOR);
		LOG_MASK[3]=new Short (LVL_MINOR);
		LOG_MASK[4]=new Short (LVL_MINOR);
		LOG_MASK[5]=new Short (LVL_MINOR);
		LOG_MASK[6]=new Short (LVL_MINOR);
		try {
			 lh = InetAddress.getLocalHost ();
		}
		 catch (UnknownHostException uhe) {
			 System.out.println (""Server: No networkinterface found: "" + uhe.getCause());
			 uhe.printStackTrace();
			 System.exit (1);
		}
		banList = new Hashtable<String, BanObject> ();
		storeList = new Hashtable<ActionstoreObject, String> ();
		props = new Properties ();
		tempAdmins = new Vector<String>();
		adminHosts = new Vector<InetAddress> ();
		allowedLoginHosts = new Vector<InetAddress> ();
	}
	 public static void main (String args[]) {
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (args[i].startsWith (""-b="")) {
				 BASE_PATH=args[0].substring(3);
			 }
			 else if (args[i].equals(""printcharsets"")) {
				 System.out.println(""Available Charsets:"");
				 Set<String> ks = Charset.availableCharsets().keySet();
				 for (Iterator<String> it = ks.iterator();
				 it.hasNext();
				 ) {
					 System.out.print("":> "");
					 System.out.println((String) it.next());
				 }
				 System.exit(0);
			 }
		 }
		 if (BASE_PATH==null) BASE_PATH=""./"";
		srv=new Server ();
		srv.readConfig ();
		srv.initServer ();
		srv.startThreads ();
		 if (srv.USE_CENTRAL_REQUESTQUEUE) Server.log (""Server"", ""starting up with CENTRAL-requestqueue"", Server.MSG_STATE, Server.LVL_MAJOR);
		 else Server.log (""Server"", ""starting up with per RequestReader-requestqueue"", Server.MSG_STATE, Server.LVL_MAJOR);
		 long lastMessage=0;
		while (srv.isRunning ()) {
			try {
				long now = System.currentTimeMillis ();
				long rws[][] = RequestReader.getWorkingSince();
				boolean b[] = RequestReader.getAliveState();
				StringBuffer sb = new StringBuffer (""ThreadsWorkingTime:"");
				for (int i = 0;
				 i < rws.length;
				 i++) {
					if (rws[i][0] == 0) {
						sb.append ("" 0, "");
					}
					 else {
						 sb.append ("" "");
						sb.append (now - rws[i][0]);
						sb.append ("", "");
					}
					if (b[i]) sb.append (""alive@"");
					else sb.append (""dead@"");
					switch ((short) rws[i][1]) {
						case RequestReader.WAITING:sb.append(""waiting"");
						continue;
						case RequestReader.EVAL_GET_MESSAGES_APND2WRITE:sb.append(""appending message to writequeue"");
						continue;
						case RequestReader.EVAL_GET_MESSAGES_SND_MSGS:sb.append(""sending scheduled message"");
						continue;
						case RequestReader.EVAL_GET_MESSAGES:sb.append(""sending messages-frame"");
						continue;
						case RequestReader.EVAL_GET_STATE:sb.append(""retrieving /state"");
						continue;
						case RequestReader.EVAL_GET:sb.append(""evaluating getrequest"");
						continue;
						case RequestReader.EVAL_POST:sb.append(""evaluating postrequest"");
						continue;
						case RequestReader.EVAL_POST_LOGIN:sb.append(""loging in"");
						continue;
						case RequestReader.EVAL_PREP4SEND:sb.append(""perparing for sending"");
						continue;
						case RequestReader.EVAL_SEND:sb.append(""evaluating a /SEND request"");
						continue;
						case RequestReader.EVAL_SENDFINAL:sb.append(""sending content"");
						continue;
						case RequestReader.EVALUATE_COMMAND:sb.append(""evaluating a command"");
						 String cmd = RequestReader.getCurrCommant(i);
						 if (cmd != null) sb.append ("" ("").append (cmd).append ("")"");
						continue;
						case RequestReader.EVALUATING:sb.append(""evaluating"");
						continue;
						case RequestReader.PARSE_MSG:sb.append(""parsing message"");
						continue;
						case RequestReader.READING:sb.append(""reading"");
						continue;
						case RequestReader.EVAL_POST_LOGIN_RESULT:sb.append(""evaluating login-result"");
						continue;
						case RequestReader.TRYLOGIN:sb.append(""trylogin"");
						continue;
						case RequestReader.TRYLOGIN_AUTHENTICATE:sb.append(""trylogin authenticate"");
						continue;
						case RequestReader.TRYLOGIN_CHECK_FRIENDS:sb.append(""trylogin check friends"");
						continue;
						case RequestReader.TRYLOGIN_CHECK4PRESENCE:sb.append(""trylogin check for presence"");
						continue;
						case RequestReader.TRYLOGIN_CORRECT_PERMISSION:sb.append(""trylogin correct permission"");
						continue;
						case RequestReader.TRYLOGIN_SCHEDULE_FRIENDMSGS:sb.append(""trylogin schedule online-friends-messages"");
						continue;
						case RequestReader.TRYLOGIN_SCHEDULE_VIPMSG:sb.append(""trylogin schedule vip-message"");
						continue;
						case RequestReader.TRYLOGIN_SEND_LOGINMSG:sb.append(""trylogin send loginmessages"");
						continue;
						case RequestReader.TRYLOGIN_SET_GROUP:sb.append(""trylogin set group"");
						continue;
						case RequestReader.TRYLOGIN_SET_PERMISSION:sb.append(""trylogin set permission"");
						continue;
					}
				}
				Server.log (""static Server"", sb.toString(), MSG_STATE, LVL_VERBOSE);
				 Runtime r = Runtime.getRuntime ();
				 long free = r.freeMemory ();
				 long total = r.totalMemory ();
				 long max = r.maxMemory ();
				 long used = r.totalMemory () - r.freeMemory ();
				 sb = new StringBuffer();
				 sb.append (""Memory-Report (VM-MaxSize/VM-CurrSize/free/used): "");
				 sb.append (max).append (""/"");
				 sb.append (total).append (""/"");
				 sb.append (free).append (""/"");
				 sb.append (used);
				 Server.log (null, sb.toString(), MSG_STATE, LVL_MINOR);
				 long lVal = now + 30001;
				for (Enumeration<String> e = srv.banList.keys ();
				 e.hasMoreElements () ;
				 ) {
					Object key = e.nextElement ();
					BanObject bObj = (BanObject) srv.banList.get(key);
					if (bObj == null)continue;
					if (bObj.bannedBy.equals(""Config( parmaBannedIp )""))continue;
					if (bObj.time < now) {
						if (checkLogLvl (Server.MSG_STATE, Server.LVL_MINOR)) {
							sb = new StringBuffer (""Server: removing ban for "").append (key);
							Server.log (""static Server"", sb.toString (), MSG_STATE, LVL_MINOR);
						}
						srv.banList.remove (key);
					}
					 else if (bObj.time < lVal) lVal = bObj.time;
				}
				lVal = now + 30001;
				for (Enumeration<ActionstoreObject> e = srv.storeList.keys();
				 e.hasMoreElements();
				) {
					Object key = e.nextElement();
					ActionstoreObject sObj = (ActionstoreObject) key;
					if (sObj == null)continue;
					if (sObj.time < now) {
						if (checkLogLvl(Server.MSG_STATE, Server.LVL_MINOR)) {
							sb = new StringBuffer(""Server: removing store for "");
							sb.append(sObj.usr);
							sb.append(""("");
							sb.append(sObj.action);
							sb.append("")"");
							Server.log(""static Server"", sb.toString(),MSG_STATE, LVL_MINOR);
						}
						srv.storeList.remove(key);
						if (sObj.equalsActionState(IActionStates.SUBAN)) {
							Group g = GroupManager.mgr.getGroup(sObj.room);
							User u = UserManager.mgr.getUserByName(sObj.usr);
							if (g != null) {
								if (u != null) {
									MessageParser mp = new MessageParser();
									mp.setMessageTemplate(""message.uban.server"");
									mp.setTargetGroup(g);
									u.sendMessage(mp);
									g.setBanForUser(u.getName(), false);
								}
								 elseg.setBanForUser(sObj.usr, false);
							}
						}
						if (sObj.equalsActionState(IActionStates.FLOCKCOL)) {
							 User u =UserManager.mgr.getUserByName(sObj.usr);
							 if (u!=null) u.setCollock(false);
						}
						 if (sObj.equalsActionState(IActionStates.FLOCKAWAY)) {
							 User u =UserManager.mgr.getUserByName(sObj.usr);
							 if (u!=null) u.setAwaylock(false);
						 }
						 if (sObj.equalsActionState(IActionStates.FLOCKME)) {
							 User u =UserManager.mgr.getUserByName(sObj.usr);
							 if (u!=null) u.setActlock(false);
						 }
						 sObj.clearObject();
					}
					 else if (sObj.time < lVal)lVal = sObj.time;
				}
				long slpTime = lVal - now;
				if (slpTime < 30)slpTime = 30;
				Thread.sleep(slpTime);
			}
			 catch (Exception ie) {
			}
		}
	}
	private void startThreads() {
		try {
			UserManager.startUserManager();
			RequestReader.startRequestReader(true);
			RequestReader.startRequestReader(true);
			CentralSelector.startCentralSelector();
			Responder.startResponder();
			Listener.startListener();
			LogCleaner.startLogCleaner();
		}
		 catch (Exception e) {
			Server.debug(this, ""Exception during starting threads:"", e, MSG_ERROR, LVL_HALT);
		}
		try {
			 TrafficMonitor.startTrafficMonitor();
		 }
		catch (Exception e) {
			 Server.debug(this, ""Exception during starting TrafficMonitor: "", e, MSG_ERROR, LVL_MAJOR);
		 }
		 try {
			 XmlRpcManager.startManager();
		 }
		 catch (Exception e) {
			 Server.debug(this, ""Exception during starting XmlRpcManager (Server will not be reachable via XML-RPC):"", e, MSG_ERROR, LVL_MAJOR);
		 }
	}
	public void readConfig() {
		Server.log(this, ""FreeCS Startup"", MSG_CONFIG, LVL_MINOR);
		StringBuffer sb = new StringBuffer(BASE_PATH).append(""/config"");
		File cFile = new File(sb.toString());
		if (!cFile.exists()) {
			Server.log(this, ""config directory missing\r\n"" + BASE_PATH + ""/config"", MSG_ERROR, LVL_HALT);
		}
		sb = new StringBuffer(BASE_PATH).append(""/config/config.cfg"");
		cFile = new File(sb.toString());
		if (!cFile.exists()) {
			Server.log(this, ""config file missing\r\n"" + sb.toString(), MSG_ERROR, LVL_HALT);
		}
		try {
			FileInputStream in = new FileInputStream(cFile);
			props.load(in);
			in.close();
		}
		 catch (FileNotFoundException fnfe) {
		}
		 catch (IOException ioe) {
			Server.log(this, ""unable to read config-files"", MSG_ERROR, LVL_HALT);
		}
		if (props.getProperty(""port"") == null)Server.log(this, ""No port specified in config: port=[portnumber]"", MSG_ERROR, LVL_HALT);
		checkForConfigValues();
		configFile = cFile;
		lastModified = cFile.lastModified();
		FileMonitor.getFileMonitor().addReloadable(srv);
	}
	private synchronized void checkForConfigValues() {
		 String sgroups = props.getProperty(""startgroups"");
		 if (sgroups == null) Server.log(this, ""No starting-rooms are deffined: startrooms=[room1/TITLE1 [, room2/TITLE2, ..."", MSG_ERROR, LVL_HALT);
		 GroupManager.mgr.updateStartingGroups(sgroups.split("",""));
		Server.log (this, ""updating log-destinations"", MSG_CONFIG, LVL_MINOR);
		LOGFILE[MSG_CONFIG] = checkProperty(""logfileCfg"", ""console"");
		LOGFILE[MSG_AUTH] = checkProperty(""logfileAuth"", ""console"");
		LOGFILE[MSG_STATE] = checkProperty(""logfileState"", ""console"");
		LOGFILE[MSG_TRAFFIC] = checkProperty(""logfileTraffic"", ""console"");
		LOGFILE[MSG_ERROR] = checkProperty(""logfileError"", ""console"");
		LOGFILE[MSG_MESSAGE] = checkProperty(""logfileMessage"", ""console"");
		if (LOGFILE[MSG_MESSAGE]!= null && !LOGFILE[MSG_MESSAGE].equals(""console"")){
			 File f = new File(LOGFILE[MSG_MESSAGE]);
			 if (!f.exists()){
				 f.mkdirs();
			 }
		}
		LOG_QUEUE_SIZE = checkProperty(""logQueueSize"", 500);
		 try {
			LogWriter l = LogWriter.instance;
		}
		 catch (Exception e) {
			e.printStackTrace();
		}
		Server.log(this, ""Reading config..."", MSG_CONFIG, LVL_MINOR);
		READBUFFER_SIZE = checkProperty(""readbuffer"", 640);
		READER_MAX_IDLETIME = checkProperty(""threadMaxIdletime"", 30000);
		READER_MAX_QUEUE = checkProperty(""ioQueueSize"", 5);
		FLOOD_PROTECT_TOLERANC = checkProperty(""floodProtectTolerance"",3);
		FLOOD_PROTECT_MILLIS = checkProperty(""floodProtectMillis"", 500);
		FLOOD_BAN_DURATION = checkProperty(""floodBanDuration"", 30000);
		TOOL_PROTECT_TOLERANC = checkProperty(""toolProtectTolerance"", 250);
		TOOL_PROTECT_COUNTER = checkProperty(""toolProtectCounter"", 10);
		TOOL_BAN_DURATION = checkProperty(""toolBanDuration"", 600) * 60000;
		TOOL_PROTECT_MINMILLS = checkProperty(""toolProtectMinmills"", 12000);
		TOOL_PROTECT_MINCOUNTER = checkProperty(""toolProtectMincounter"",10);
		JOIN_PUNISHED_COUNTER = checkProperty(""joinpunishedcounter"",2);
		COLOR_CHANGE_INTERVAL = checkProperty(""colorChangeInterval"", 15000);
		 MESSAGE_FLOOD_INTERVAL = checkProperty(""messageFloodInterval"", 5000);
		USER_TIMEOUT = checkProperty(""userTimeout"", 15) * 60000;
		if (USER_TIMEOUT < 0) {
			 USER_TIMEOUT = 15 * 60000;
			 Server.log(this, ""WARNING Usrtimeout < 0 setting Standarttimeout"", Server.MSG_CONFIG, Server.LVL_MAJOR);
		 }
		USER_AWAY_TIMEOUT = checkProperty(""userAwayTimeout"", 30) * 60000;
		if (USER_AWAY_TIMEOUT < 0){
			 Server.log(this, ""WARNING UsrAwayTimeout < 0 deactivated"", Server.MSG_CONFIG, Server.LVL_MAJOR);
		}
		USER_REMOVE_SCHEDULE_TIME = checkProperty(""userRemoveDelay"", 2000);
		TCP_RECEIVE_BUFFER_WINDOW = checkProperty(""tcpReceiveBuffer"", 4096);
		FILE_CHECK_INTERVAL = checkProperty(""fileCheckInterval"", 10000);
		 if (FILE_CHECK_INTERVAL < 1000) FILE_CHECK_INTERVAL = 1000;
		 CAN_DEL_LOGS = checkProperty(""canDelLogs"", false);
		 LOGFILE_DELHOUR = checkProperty(""logfileDelhour"", 1);
		 LOGFILE_DELDAYS = checkProperty(""logfileDeldays"", 2);
		 if (LOGFILE_DELDAYS <2) LOGFILE_DELDAYS =2;
		 String ndcs = checkProperty(""charset"", ""iso-8859-1"");
		 if (!ndcs.equals(DEFAULT_CHARSET)) {
			 defaultCs = Charset.forName(ndcs);
			 defaultCsEnc = defaultCs.newEncoder();
			 DEFAULT_CHARSET=ndcs;
		 }
		 int cookied = 0;
		 String cookiedomain = props.getProperty(""cookieDomain"");
		 if (cookiedomain != null) {
			 StringBuffer cookie = new StringBuffer();
			 String cd[] = cookiedomain.split("","");
			 for (int i = 0;
			 i < cd.length;
			 i++) {
				 cookied ++;
				 cookie.append(cd[i].trim().toLowerCase()).append("","");
				 Server.log (""[Server]"", ""CookieDomain Configured: ""+ cd[i].trim().toLowerCase(), Server.MSG_CONFIG, Server.LVL_MAJOR);
			 }
			 COOKIE_DOMAIN = new StringBuffer(cookie);
		 }
		 String servername = props.getProperty(""server"");
		 if (servername != null) {
			 int servern = 0;
			 Vector<String> server = new Vector<String>();
			 String sv[] = servername.split("","");
			 for (int i = 0;
			 i < sv.length;
			 i++) {
				 servern ++;
				 server.addElement(sv[i].trim().toLowerCase());
				 Server.log (""[Server]"", ""Server Configured: ""+ sv[i].trim().toLowerCase(), Server.MSG_CONFIG, Server.LVL_MAJOR);
			 }
			 SERVER_NAME = new Vector<String>(server);
			 if (servern >1) if (cookied < servern || cookied > servern) Server.log (this, ""Server Halt:CookieDomain("" +cookied+"")<>Servername(""+servern+"")"", Server.MSG_ERROR ,Server.LVL_HALT);
		 }
		 DEFAULT_MEMBERSHIP = checkProperty(""defaultMembership"",""standart"");
		USE_SMILEY = checkProperty(""useSmiley"", false);
		 SMILEY_PER_LINE = checkProperty(""SmileyPerLine"", 5);
		 SMILEY_SERVER = checkProperty(""SmileysDir"", ""/static"");
		 BLOCKED_NICK_AUTOHARDKICK = checkProperty(""blockedNickAutohardkick"", false);
		 USE_PLUGINS = checkProperty(""usePlugins"", false);
		 USE_BBC = checkProperty(""useBBC"", false);
		 BBC_CONVERT_GROUPNAME = checkProperty(""bbcConvertGroupname"", false);
		BBC_CONVERT_GROUPTHEME = checkProperty(""bbcConvertGrouptheme"",false);
		MAX_BBCTAGS = checkProperty(""maxBBCTags"", 1);
		if (MAX_BBCTAGS<1 || MAX_BBCTAGS>5)MAX_BBCTAGS =1;
		MIN_BBC_FONT_RIGHT_ENTRACE = checkProperty(""minBbcFontRightEntrace"",""user"");
		MIN_BBC_FONT_RIGHT_SEPA = checkProperty(""minBbcFontRightSepa"", ""user"");
		MIN_BBC_B_RIGHT_ENTRACE = checkProperty(""minBbcBRightEntrace"", ""user"");
		MIN_BBC_B_RIGHT_SEPA = checkProperty(""minBbcBRightSepa"", ""user"");
		MIN_BBC_I_RIGHT_ENTRACE = checkProperty(""minBbcIRightEntrace"", ""user"");
		MIN_BBC_I_RIGHT_SEPA = checkProperty(""minBbcIRightSepa"", ""user"");
		MIN_BBC_U_RIGHT_ENTRACE = checkProperty(""minBbcURightEntrace"", ""user"");
		MIN_BBC_U_RIGHT_SEPA = checkProperty(""minBbcURightSepa"", ""user"");
		ALLOW_EXTERNAL = checkProperty(""allowExternalLogin"", true);
		 USE_CENTRAL_REQUESTQUEUE = checkProperty(""useCentralRequestqueue"",false);
		DEBUG_TEMPLATESET = checkProperty(""debugTemplateset"", false);
		 STRICT_HOST_BINDING = checkProperty(""useStrictHostBinding"", true);
		MAX_READERS = checkProperty(""maxThreads"", 100);
		USE_HTTP11 = checkProperty(""useHTTP1.1"", true);
		MAX_USERS = checkProperty(""maxUsers"", 2000);
		TOUCH_USER_DELAY = checkProperty(""touchUserDelay"", 20000);
		MAX_BAN_DURATION = checkProperty(""maxBanDuration"", 120);
		USE_IP_BAN = checkProperty(""useIpBan"", true);
		DEFAULT_BAN_DURATION = checkProperty(""defaultBanDuration"", 10);
		INITIAL_RESPONSE_QUEUE = checkProperty(""responseQueueSize"", 100);
		 MAX_RESPONSE_QUEUE = checkProperty(""maxResponseQueueSize"", 1000);
		MAX_REQUESTS_PER_PROXY_IP = checkProperty(""maxRequestsPerProxy"", 20000);
		MAX_REQUESTS_PER_IP = checkProperty(""maxRequestsPerIp"", 90);
		HOST_BAN_DURATION = checkProperty(""floodHostBanDuration"", 3600000);
		USE_TRAFFIC_MONITOR = checkProperty(""useTrafficMonitor"", false);
		MAX_DIE_NUMBER = checkProperty(""maximumDieNumber"", 10);
		MAX_DIE_EYES = checkProperty(""maximumDieEyes"", 20);
		MAX_SUUSERS_PER_STARTGROUP = checkProperty(""maxSuPerStartgroup"", 5);
		USE_TOKENSTORE= checkProperty(""useTokenedLogin"",false);
		 MD5_PASSWORDS = checkProperty(""MD5EncodePasswords"", false);
		 MAX_USERNAME_LENGTH = checkProperty(""maxUserNameLength"", 30);
		 MAX_GROUPNAME_LENGTH = checkProperty(""maxGroupNameLength"", -1);
		 MAX_GROUPTHEME_LENGTH = checkProperty(""maxGroupThemeLength"", -1);
		 MESSAGE_FLOOD_LENGHT = checkProperty(""messageFloodLength"", -1);
		 USE_MESSAGE_RENDER_CACHE = checkProperty(""useMessageRenderCache"",false);
		 VIP_TIMEOUT = checkProperty(""vipTimeout"", 0) * 60000;
		 VIP_AWAY_TIMEOUT = checkProperty(""vipAwayTimeout"", 0) * 60000;
		 MAX_MCALL_KEY = checkProperty(""maxMcallKey"", 30);
		 MAX_PMSTORE = checkProperty(""maxPmstore"", 0);
		 String httpUname = checkProperty(""admin.http.username"", null);
		 if (httpUname!=null) ADMIN_HTTP_USERNAME = httpUname.split("","");
		 String httpPassword = checkProperty(""admin.http.password"", null);
		 if (httpPassword!=null) ADMIN_HTTP_PASSWORD = httpPassword.split("","");
		 String sLevel = checkProperty(""admin.http.securitylevel"", null);
		 if (sLevel!=null) ADMIN_HTTP_SECLEVEL = sLevel.split("","");
		 ADMIN_HTTP_ALLOWED= checkProperty(""admin.http.allowedClients"", """");
		 ADMIN_XMLRPC_PORT = checkProperty(""admin.xmlrpc.port"", 0);
		 ADMIN_XMLRPC_ALLOWED = checkProperty(""admin.xmlrpc.allowedClients"", """");
		UNAME_PREFIX_GOD = checkProperty(""prefix.admin"",""<b>"");
		UNAME_SUFFIX_GOD = checkProperty(""suffix.admin"",""(A)</b>"");
		UNAME_PREFIX_GUEST = checkProperty(""prefix.guest"","""");
		UNAME_SUFFIX_GUEST = checkProperty(""suffix.guest"",""(G)"");
		UNAME_PREFIX_MODERATOR = checkProperty(""prefix.moderator"","""");
		UNAME_SUFFIX_MODERATOR = checkProperty(""suffix.moderator"",""(M)"");
		UNAME_PREFIX_PUNISHED = checkProperty(""prefix.punished"",""<s>"");
		UNAME_SUFFIX_PUNISHED = checkProperty(""suffix.punished"",""</s>"");
		UNAME_PREFIX_SU = checkProperty(""prefix.su"", ""<i>"");
		UNAME_SUFFIX_SU = checkProperty(""suffix.su"", ""</i>"");
		UNAME_PREFIX_VIP = checkProperty(""prefix.vip"", ""<b>"");
		UNAME_SUFFIX_VIP = checkProperty(""suffix.vip"", ""</b>"");
		 READER_TIMEOUT = checkProperty(""readerTimeout"", 5000);
		 LOGIN_TIMEOUT = checkProperty(""loginTimeout"", 20000);
		 FN_DEFAULT_MODE_FALSE = (short) checkProperty(""friendNotificationMode.false"", 0);
		 FN_DEFAULT_MODE_TRUE = (short) checkProperty(""friendNotificationMode.true"", 2);
		 COLOR_LOCK_MODE = (short) checkProperty(""colorLockMode"", 0);
		 COLOR_LOCK_LEVEL = (short) checkProperty(""colorLockLevel"", 1);
		 if (COLOR_LOCK_LEVEL <1 || COLOR_LOCK_LEVEL>10) COLOR_LOCK_LEVEL = 1;
		 FADECOLOR_LOCK_LEVEL = (short) checkProperty(""fadecolorLockLevel"", -1);
		 if (FADECOLOR_LOCK_LEVEL == -1) FADECOLOR_LOCK_LEVEL = COLOR_LOCK_LEVEL;
		 if (FADECOLOR_LOCK_LEVEL <1 || FADECOLOR_LOCK_LEVEL>10) FADECOLOR_LOCK_LEVEL = 1;
		 KEEP_ALIVE_TIMEOUT = checkProperty(""keepAliveTimeout"", 30) * 1000;
		PUNISH_DURATION = checkProperty(""punishBanDuration"", -1);
		 ALLOW_CHANGE_USERAGENT = checkProperty(""allowChangeUseragent"",true);
		 MAX_FLOCK_DURATION = checkProperty(""maxFlockDuration"", -1);
		MAX_SU_BAN_DURATION = checkProperty(""maxSuBanDuration"", -1);
		 DEFAULT_TEMPLATESET = checkProperty(""defaultTemplateset"",null);
		 TRACE_CREATE_AND_FINALIZE = checkProperty(""traceCreateAndFinalize"",false);
		 if (USE_PLUGINS){
			 String plugins = props.getProperty(""plugins"");
			 if (plugins != null) {
				 String values[] = plugins.split("","");
				 Vector<String> pluginUrl = new Vector<String>();
				 for (int i = 0;
				 i < values.length;
				 i++) pluginUrl.add(values[i].trim());
				 loadPlugin(pluginUrl);
			 }
			 else {
				 resetPluginStore();
			 }
		 }
		 else {
			 resetPluginStore();
		 }
		 String url = props.getProperty(""commandsUrl"");
		 if (url != null) {
			 String values[] = url.split("","");
			 Vector<String> jarUrl = new Vector<String>();
			 for (int i = 0;
			 i < values.length;
			 i++) jarUrl.add(values[i].trim());
			 loadCommands(jarUrl);
			 CommandSet.getCommandSet().checkCommendSet();
		 }
		 else {
			 Vector<String> jarUrl = new Vector<String>();
			 jarUrl.add(""lib/freecs.jar"");
			 loadCommands(jarUrl);
		 }
		 String xmlRpcHandlerUrl = props.getProperty(""xmlRpcHandlerUrl"");
		 if (xmlRpcHandlerUrl != null) {
			 String values[] = xmlRpcHandlerUrl.split("","");
			 Vector<String> jarUrl = new Vector<String>();
			 for (int i = 0;
			 i < values.length;
			 i++) jarUrl.add(values[i].trim());
			 loadXmlRpcHandler(jarUrl);
		 }
		String val = props.getProperty(""moderatedgroups"");
		if (val != null) {
			String values[] = val.split("","");
			Vector<String> names = new Vector<String>();
			for (int i = 0;
			 i < values.length;
			 i++)names.add(values[i].trim().toLowerCase());
			GroupManager.mgr.updateModeratedGroups(names);
		}
		 else {
			GroupManager.mgr.updateModeratedGroups(new Vector<String>());
		}
		val = props.getProperty(""vips"");
		if (val != null) {
			Vector<String> tvl = new Vector<String>();
			String values[] = val.split("","");
			for (int i = 0;
			 i < values.length;
			 i++) {
				tvl.addElement(values[i].trim().toLowerCase());
			}
			UserManager.mgr.updateVips(tvl);
		}
		 elseUserManager.mgr.updateVips(new Vector<String>());
		 val = props.getProperty(""admins"");
		 if (val != null) {
			 Vector<String> tvl = new Vector<String>();
			 String values[] = val.split("","");
			 for (int i = 0;
			 i < values.length;
			 i++) {
				 tvl.addElement(values[i].trim().toLowerCase());
			 }
			 UserManager.mgr.updateAdmins(tvl);
		 }
		 else UserManager.mgr.updateAdmins(new Vector<String>());
		val = props.getProperty(""moderators"");
		if (val != null) {
			Vector<String> tvl = new Vector<String>();
			String values[] = val.split("","");
			for (int i = 0;
			 i < values.length;
			 i++) {
				tvl.addElement(values[i].trim().toLowerCase());
			}
			UserManager.mgr.updateModerators(tvl);
		}
		 elseUserManager.mgr.updateModerators(new Vector<String>());
		val = props.getProperty(""guests"");
		if (val != null) {
			Vector<String> tvl = new Vector<String>();
			String values[] = val.split("","");
			for (int i = 0;
			 i < values.length;
			 i++) {
				tvl.addElement(values[i].trim().toLowerCase());
			}
			UserManager.mgr.updateGuests(tvl);
		}
		 elseUserManager.mgr.updateGuests(new Vector<String>());
		val = srv.ADMIN_HTTP_ALLOWED;
		if (val != null) {
			String hsts[] = val.split("","");
			Vector<InetAddress> newHsts = new Vector<InetAddress>();
			for (int i = 0;
			 i < hsts.length;
			 i++) {
				try {
					InetAddress ia = InetAddress.getByName(hsts[i].trim());
					if (!newHsts.contains(ia))newHsts.addElement(ia);
				}
				 catch (Exception e) {
					StringBuffer tsb = new StringBuffer(""Server.checkForConfigValues: unable to add adminHost "");
					tsb.append(hsts[i]);
					Server.debug(this, tsb.toString(), e, Server.MSG_ERROR, Server.LVL_MAJOR);
				}
			}
			Vector<InetAddress> remove = (Vector) adminHosts.clone();
			remove.removeAll(newHsts);
			newHsts.removeAll(adminHosts);
			adminHosts.removeAll(remove);
			adminHosts.addAll(newHsts);
			for (Enumeration<String> tp = tempAdmins.elements();
			 tp.hasMoreElements();
			 ) {
				 String u = (String) tp.nextElement();
				 User nu = UserManager.mgr.getUserByName(u);
				 if (nu != null) addTempAdminhost(nu);
			 }
		}
		val = props.getProperty(""permaBannedIp"");
		if (val != null) {
			String hsts[] = val.split("","");
			Vector<InetAddress> newHsts = new Vector<InetAddress>();
			for (int i = 0;
			 i < hsts.length;
			 i++) {
				try {
					InetAddress ia = InetAddress.getByName(hsts[i].trim());
					if (!newHsts.contains(ia)){
						newHsts.addElement(ia);
						 permaBanHost (ia, ""perma banned IP"");
					}
				}
				 catch (Exception e) {
					StringBuffer tsb = new StringBuffer(""Server.checkForConfigValues: unable to add perma banned IP "");
					tsb.append(hsts[i]);
					Server.debug(this, tsb.toString(), e, Server.MSG_ERROR, Server.LVL_MAJOR);
				}
			}
		}
		String oldTimeZone = TIMEZONE;
		TIMEZONE = checkProperty(""timezone"", null);
		TimeZone tz = null;
		if (TIMEZONE == null || TIMEZONE.length() < 1) {
			StringBuffer sb = new StringBuffer(""checkForConfigValues: setting TimeZone to default-TimeZone ("");
			tz = TimeZone.getDefault();
			sb.append(tz.getID());
			sb.append("")"");
			Server.log(this, sb.toString(), Server.MSG_STATE, Server.LVL_MINOR);
			if (tz.equals(cal.getTimeZone()))tz = null;
		}
		 else if (oldTimeZone == null || !oldTimeZone.equals(TIMEZONE)) {
			try {
				tz = TimeZone.getTimeZone(TIMEZONE);
				if (tz.equals(cal.getTimeZone())) {
					Server.log(this, ""checkForConfigVals: TimeZone has not changed"", Server.MSG_ERROR, Server.LVL_MINOR);
					tz = null;
				}
				 else if (!tz.getID().equals(TIMEZONE)) {
					StringBuffer sb = new StringBuffer(""checkForConfigVals: TimeZone is set to "");
					sb.append(tz.getID());
					sb.append("" now. The following TimeZones are available:\r\n"");
					String[] ids = TimeZone.getAvailableIDs();
					for (int i = 0;
					 i < ids.length;
					 i++) {
						sb.append(ids[i]);
						if (i < ids.length)sb.append("", "");
					}
					Server.log(this, sb.toString(), Server.MSG_STATE, Server.LVL_MINOR);
				}
				StringBuffer sb = new StringBuffer(""checkForConfigValues: setting TimeZone to "");
				sb.append(tz.getID());
				Server.log(this, sb.toString(), Server.MSG_STATE, Server.LVL_MINOR);
			}
			 catch (Exception e) {
				Server.debug(this, ""checkForConfigValues: unable to set TimeZone!"", e, Server.MSG_ERROR, Server.LVL_MAJOR);
			}
		}
		if (tz != null) {
			cal.setTimeZone(tz);
		}
		 Listener.updateSscRecieveBuffer(this.TCP_RECEIVE_BUFFER_WINDOW);
		 val = checkProperty(""allowedLoginHosts"", null);
		 if (val != null) {
			 String hsts[] = val.split("","");
			 Vector<InetAddress> newHsts = new Vector<InetAddress>();
			 for (int i = 0;
			 i < hsts.length;
			 i++) {
				 try {
					 InetAddress ia = InetAddress.getByName(hsts[i].trim());
					 if (!newHsts.contains(ia)) newHsts.addElement(ia);
				 }
				 catch (Exception e) {
					 StringBuffer tsb = new StringBuffer(""Server.checkForConfigValues: unable to add adminHost "");
					 tsb.append(hsts[i]);
					 Server.debug(this, tsb.toString(), e, Server.MSG_ERROR, Server.LVL_MAJOR);
				 }
			 }
			 Vector<InetAddress> remove = (Vector) allowedLoginHosts.clone();
			 remove.removeAll(newHsts);
			 newHsts.removeAll(allowedLoginHosts);
			 allowedLoginHosts.removeAll(remove);
			 allowedLoginHosts.addAll(newHsts);
		 }
		String logVal = props.getProperty(""debug"");
		if (logVal != null && logVal.equalsIgnoreCase(""false""))DEBUG = false;
		else if (logVal != null && logVal.equalsIgnoreCase(""true""))DEBUG = true;
		logVal = props.getProperty(""log_config"");
		if (logVal != null)LOG_MASK[MSG_CONFIG] = new Short(Short.parseShort(logVal, 10));
		logVal = props.getProperty(""log_auth"");
		if (logVal != null)LOG_MASK[MSG_AUTH] = new Short(Short.parseShort(logVal, 10));
		logVal = props.getProperty(""log_state"");
		if (logVal != null)LOG_MASK[MSG_STATE] = new Short(Short.parseShort(logVal, 10));
		logVal = props.getProperty(""log_traffic"");
		if (logVal != null)LOG_MASK[MSG_TRAFFIC] = new Short(Short.parseShort(logVal, 10));
		logVal = props.getProperty(""log_error"");
		if (logVal != null)LOG_MASK[MSG_ERROR] = new Short(Short.parseShort(logVal, 10));
		logVal = props.getProperty(""log_message"");
		if (logVal != null)LOG_MASK[MSG_MESSAGE] = new Short(Short.parseShort(logVal, 10));
		logVal = props.getProperty(""log_sepamessage"");
		if (logVal != null)LOG_MASK[MSG_SEPAMESSAGE] = new Short(Short.parseShort(logVal, 10));
	}
	private void loadCommands(Vector<String> jarUrl){
		 allCommands = new HashMap<String, Object>();
		 Vector<String> commandUrl = new Vector<String>();
		 HashMap<String, Object> commandsStore = new HashMap<String, Object>();
		 Enumeration<JarEntry> entries = null;
		 for (Iterator<String> iterator = jarUrl.iterator();
		 iterator.hasNext();
		) {
			 String jUrl = (String) iterator.next();
			 try {
				 entries = new JarFile(jUrl).entries();
			 }
			 catch (IOException e) {
				 Server.log(this, ""Jar File:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
			 }
			 String packagePattern = ""freecs/commands/[^/]+\\.class"";
			 if (entries == null) Server.log(this, ""illegal jar File"", Server.MSG_ERROR, Server.LVL_HALT);
			 while (entries.hasMoreElements()) {
				 JarEntry jarEntry = entries.nextElement();
				 if (jarEntry.getName().matches(packagePattern)){
					 StringBuilder url = new StringBuilder(jarEntry.getName());
					 int i = url.toString().indexOf(""."");
					 url = new StringBuilder(url.substring(0, i).toString().replaceAll(""/"", "".""));
					 if (url.toString().equals(""freecs.commands.AbstractCommand"") || url.toString().equals(""freecs.commands.CommandSet"")) continue;
					 commandUrl.add(url.toString());
					 Class<?> piClass = null;
					 try {
						 piClass = Class.forName(url.toString());
					 }
					 catch (ClassNotFoundException e) {
						 Server.log(this, ""Class.forName:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
					 }
					 if (piClass == null) continue;
					 Method getInstance = null;
					 try {
						 getInstance = piClass.getMethod(""getInstance"");
					 }
					 catch (SecurityException e) {
						 Server.log(this, ""get Instance:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
					 }
					 catch (NoSuchMethodException e) {
						 Server.log(this, ""get Instance:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
					 }
					 if (getInstance==null){
						 Server.log(this, ""Specified command-object doesn't implement static getInstance"", Server.MSG_ERROR, Server.LVL_MAJOR);
						 continue;
					 }
				 }
				 else {
					 Server.log(this, ""ignore Command Url ""+jarEntry.getName(), Server.MSG_CONFIG, Server.LVL_VERY_VERBOSE);
				 }
			 }
		 }
		 for (Iterator<String> iterator = commandUrl.iterator();
		 iterator.hasNext();
		) {
			 StringBuilder url = new StringBuilder((String) iterator.next());
			 if (url.toString().length()<1) continue;
			 Object o = null;
			;
			 synchronized (commandsStore) {
				 o = commandsStore.get(url.toString());
				 if (o == null) {
					 try {
						 Class<?> piClass = null;
						 try {
							 piClass = Class.forName(url.toString());
						 }
						 catch (ClassNotFoundException e) {
							 Server.log(this, ""Class.forName:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
						 }
						 Method getInstance = piClass.getMethod(""getInstance"");
						 if (getInstance==null){
							 Server.log(this, ""Specified Command-object doesn't implement static getMasterInstance"", Server.MSG_ERROR, Server.LVL_MAJOR);
							 continue;
						 }
						 Object arg0 = null;
						 o = getInstance.invoke(arg0);
						 if (!(o instanceof ICommand)){
							 Server.log(this, ""Specified Command-object (""+url.toString()+"") doesn't implement interface ICommand"", Server.MSG_ERROR, Server.LVL_MAJOR);
							 continue;
						 }
						 commandsStore.put(url.toString(), o);
					 }
					 catch (Exception e) {
						 Server.log (this, ""invalid url for Command: (""+e+"") Url:"" + url.toString(), Server.MSG_ERROR, Server.LVL_MINOR);
						 continue;
					 }
				 }
			 }
			 String cmd = ((ICommand) o).getCmd();
			 String version = ((ICommand) o).getVersion();
			 if (!version.startsWith(""1."")){
				 Server.log(this, ""invalid commandversion ""+cmd+"" (""+url.toString()+"")"", Server.MSG_ERROR, Server.LVL_MAJOR);
				 continue;
			 }
			 if (!allCommands.containsKey(cmd)){
				 allCommands.put(((ICommand) o).getCmd(), ((ICommand) o).instanceForSystem());
				 if (Server.DEBUG) Server.log(this, ""added Command ""+cmd+""[ ""+version+"" ] (""+url.toString(), Server.MSG_CONFIG, Server.LVL_MAJOR);
			 }
			 else {
				 Server.log(this, ""Command ""+cmd+"" exists!"", Server.MSG_CONFIG, Server.LVL_MAJOR);
				 if (Server.DEBUG) Server.log(this, ""ignore Command ""+cmd+""[ ""+version+"" ] (""+url, Server.MSG_CONFIG, Server.LVL_MAJOR);
			 }
		 }
		 commandUrl =null;
		 commandsStore = null;
		 entries = null;
	}
	 private void loadXmlRpcHandler(Vector<String> jarUrl){
		 xmlRpcHandler = new HashMap<String, Object>();
		 Vector<String> xmlRpcUrl = new Vector<String>();
		 HashMap<String, Object> handlerStore = new HashMap<String, Object>();
		 Enumeration<JarEntry> entries = null;
		 for (Iterator<String> iterator = jarUrl.iterator();
		 iterator.hasNext();
		) {
			 String jUrl = (String) iterator.next();
			 try {
				 entries = new JarFile(jUrl).entries();
			 }
			 catch (IOException e) {
				 Server.log(this, ""Jar File:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
			 }
			 String packagePattern = ""freecs/external/xmlrpc/[^/]+\\.class"";
			 if (entries == null) Server.log(this, ""illegal jar File"", Server.MSG_ERROR, Server.LVL_HALT);
			 while (entries.hasMoreElements()) {
				 JarEntry jarEntry = entries.nextElement();
				 if (jarEntry.getName().matches(packagePattern)){
					 StringBuilder url = new StringBuilder(jarEntry.getName());
					 int i = url.toString().indexOf(""."");
					 url = new StringBuilder(url.substring(0, i).toString().replaceAll(""/"", "".""));
					 if (url.toString().equals(""freecs.external.xmlrpc.XmlRpcSendUser"") || url.toString().equals(""freecs.external.xmlrpc.XmlRpcManager"") || url.toString().equals(""freecs.external.xmlrpc.XmlRpcSendUser$UserState"")) continue;
					 xmlRpcUrl.add(url.toString());
					 Class<?> piClass = null;
					 try {
						 piClass = Class.forName(url.toString());
					 }
					 catch (ClassNotFoundException e) {
						 Server.log(this, ""Class.forName:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
					 }
					 if (piClass == null) continue;
					 Method getInstance = null;
					 try {
						 getInstance = piClass.getMethod(""getInstance"");
					 }
					 catch (SecurityException e) {
						 Server.log(this, ""get Instance:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
					 }
					 catch (NoSuchMethodException e) {
						 Server.log(this, ""get Instance:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
					 }
					 if (getInstance==null){
						 Server.log(this, ""Specified xml rpc handler-object (""+url.toString()+"") doesn't implement static getInstance"", Server.MSG_ERROR, Server.LVL_MAJOR);
						 continue;
					 }
				 }
				 else {
					 Server.log(this, ""ignore XmlRpcHandler Url ""+jarEntry.getName(), Server.MSG_CONFIG, Server.LVL_VERY_VERBOSE);
				 }
			 }
		 }
		 for (Iterator<String> iterator = xmlRpcUrl.iterator();
		 iterator.hasNext();
		) {
			 StringBuilder url = new StringBuilder((String) iterator.next());
			 if (url.toString().length()<1) continue;
			 Object o = null;
			;
			 synchronized (handlerStore) {
				 o = handlerStore.get(url.toString());
				 if (o == null) {
					 try {
						 Class<?> piClass = Class.forName(url.toString());
						 Method getInstance = piClass.getMethod(""getInstance"");
						 if (getInstance==null){
							 Server.log(this, ""Specified Handler-object doesn't implement static getMasterInstance"", Server.MSG_ERROR, Server.LVL_MAJOR);
							 continue;
						 }
						 Object arg0 = null;
						 o = getInstance.invoke(arg0);
						 if (!(o instanceof IXmlRpcHandler)){
							 Server.log(this, ""Specified Handler-object doesn't implement interface IXmlRpcHandler"", Server.MSG_ERROR, Server.LVL_MAJOR);
							 continue;
						 }
						 handlerStore.put(url.toString(), o);
					 }
					 catch (Exception e) {
						 Server.log (this, ""invalid url for Handler: (""+e+"") Url:"" + url, Server.MSG_ERROR, Server.LVL_MINOR);
						 continue;
					 }
				 }
			 }
			 String handler = ((IXmlRpcHandler) o).getHandlername();
			 String version = ((IXmlRpcHandler) o).getVersion();
			 if (!version.startsWith(""1."")){
				 Server.log(this, ""invalid xmlrpchandlerversion ""+handler+"" (""+url+"")"", Server.MSG_ERROR, Server.LVL_MAJOR);
				 continue;
			 }
			 if (!xmlRpcHandler.containsKey(handler)){
				 xmlRpcHandler.put(((IXmlRpcHandler) o).getHandlername(), ((IXmlRpcHandler) o).instanceForSystem());
				 if (Server.DEBUG) Server.log(this, ""add XmlRpcHandler ""+handler+""[ ""+version+"" ] (""+url+"")"", Server.MSG_CONFIG, Server.LVL_MAJOR);
			 }
			 else {
				 Server.log(this, ""XmlRpcHandler ""+handler+"" exists!"", Server.MSG_CONFIG, Server.LVL_MAJOR);
				 if (Server.DEBUG) Server.log(this, ""ignore XmlRpcHandler ""+handler+""[ ""+version+"" ] (""+url, Server.MSG_CONFIG, Server.LVL_MAJOR);
			 }
		 }
		 xmlRpcUrl =null;
		 handlerStore = null;
		 entries = null;
	 }
	private void resetPluginStore() {
		 pluginStore = new HashMap<String, Object>();
		 serverPlugin = null;
	 }
	 private void loadPlugin(Vector<String> pluginUrl) {
		 Vector<IServerPlugin> plugins = new Vector<IServerPlugin>();
		 for (Iterator<String> iterator = pluginUrl.iterator();
		 iterator.hasNext();
		) {
			 StringBuilder url = new StringBuilder((String) iterator.next());
			 if (url.toString().length()<1) continue;
			 Object o;
			 synchronized (pluginStore) {
				 o = pluginStore.get(url.toString());
				 if (o == null) {
					 try {
						 Class<?> piClass = null;
						 try {
							 piClass = Class.forName(url.toString());
						 }
						 catch (ClassNotFoundException e) {
							 Server.log(this, ""Class.forName:""+e, Server.MSG_ERROR, Server.LVL_MAJOR);
						 }
						 if (piClass == null) continue;
						 Method getInstance = piClass.getMethod(""getMasterInstance"");
						 if (getInstance==null){
							 Server.log(this, ""Specified plugin-object doesn't implement static getMasterInstance"", Server.MSG_ERROR, Server.LVL_MAJOR);
							 continue;
						 }
						 Object arg0 = null;
						 o = getInstance.invoke(arg0);
						 if (!(o instanceof IServerPlugin)){
							 Server.log(this, ""Specified plugin-object doesn't implement interface IServerPlugin"", Server.MSG_ERROR, Server.LVL_MAJOR);
							 continue;
						 }
						 pluginStore.put(url.toString(), o);
					 }
					 catch (Exception e) {
						 Server.log (this, ""invalid url for Plugin: (""+e+"") Url:"" + url.toString(), Server.MSG_ERROR, Server.LVL_MINOR);
						 continue;
					 }
				 }
			 }
			 try {
				 plugins.add(((IServerPlugin) o).instanceForSystem());
			 }
			 catch (Exception e) {
				 Server.debug(this, ""catched exception while getting ServerPlugin-instance"", e, Server.MSG_STATE, Server.LVL_MAJOR);
			 }
			 serverPlugin = plugins.toArray(new IServerPlugin[0]);
		 }
		 plugins = null;
	 }
	private boolean checkProperty (String p, boolean def) {
		String pval = props.getProperty (p);
		if (pval == null) return def;
		return pval.equalsIgnoreCase(""true"");
	}
	private long checkProperty (String p, long def) {
		String pval = props.getProperty (p);
		if (pval == null) return def;
		 try {
			 return Long.parseLong (pval, 10);
		 }
		 catch (Exception e) {
			 Server.debug(""Server"", ""invalid value specified for configuration-parameter "" + pval, e , Server.MSG_ERROR, Server.LVL_MAJOR);
			 return def;
		 }
	}
	private int checkProperty (String p, int def) {
		String pval = props.getProperty (p);
		if (pval == null) return def;
		 try {
			 return Integer.parseInt (pval.trim(), 10);
		 }
		 catch (Exception e) {
			 Server.debug(""Server"", ""invalid value specified for configuration-parameter "" + pval, e , Server.MSG_ERROR, Server.LVL_MAJOR);
			 return def;
		 }
	}
	private String checkProperty (String p, String def) {
		String pval = props.getProperty (p);
		if (pval == null) return def;
		return pval;
	}
	public void initServer() {
		try {
			if (templatemanager == null)templatemanager = new TemplateManager();
		}
		 catch (IOException ioe) {
			Server.debug(this, ""unable to load TemplateSet: "", ioe, MSG_ERROR, LVL_HALT);
		}
		auth = AuthManager.instance;
		auth.init();
		Runtime rt = Runtime.getRuntime();
		rt.addShutdownHook(new CleanupClass());
	}
	public void removeToken (String cookie) {
		if (cookie == null) return;
		tokenStore.remove(cookie);
	}
	public boolean isTokenValid (String token, String cookie) {
		if (!USE_TOKENSTORE)return true;
		if (token == null || cookie == null)return false;
		String t = (String) tokenStore.get(cookie);
		if (t==null || !t.equals(token))return false;
		return true;
	}
	public void addToken (String token, String cookie) {
		if (!USE_TOKENSTORE || token==null || cookie==null)return;
		tokenStore.put(cookie, token);
	}
	public void startShutdown() {
		isRunning = false;
	}
	public boolean isRunning() {
		return isRunning;
	}
	 public boolean isAdminHost(InetAddress ia) {
		return adminHosts.contains(ia);
	}
	 public void addTempAdminhost(User nu){
		 InetAddress ia = nu.conn.clientAddress;
		 if (ia != null && mayTempAdminhost(nu.conn.clientIp)){
			 if (!adminHosts.contains(ia)){
				 nu.setAsTempadminhost();
				 StringBuffer sb = new StringBuffer(""["").append(nu.getName()).append(""] "");
				 sb.append(nu.conn.clientIp).append("" add tempAdminhost"");
				 Server.log(this,sb.toString() , MSG_STATE, LVL_MAJOR);
				 adminHosts.add(ia);
				 if (!tempAdmins.contains(nu.getName().toLowerCase())) tempAdmins.add(nu.getName().toLowerCase());
			 }
		 }
	 }
	 public void removeTempAdminhost(User nu){
		 if (!tempAdmins.contains(nu.getName().toLowerCase())) return;
		 InetAddress ia = nu.conn.clientAddress;
		 if (ia != null){
			 StringBuffer sb = new StringBuffer(""["").append(nu.getName()).append(""] "");
			 sb.append(nu.conn.clientIp).append("" remove tempAdminhost"");
			 Server.log(this,sb.toString() , MSG_STATE, LVL_MAJOR);
			 adminHosts.remove(ia);
			 tempAdmins.remove(nu.getName().toLowerCase());
		 }
	 }
	 private boolean mayTempAdminhost(String ia) {
		 if (ia.startsWith(""192.168."") || ia.startsWith(""10."") || ia.startsWith(""172.16"") || ia.equals(""127.0.0.1"")) return false;
		 return true;
	 }
	public InetAddress getLocalHost() {
		return lh;
	}
	public String getProperty(String key) {
		return props.getProperty(key);
	}
	public String getUrl() {
		StringBuffer sb = new StringBuffer();
		 sb.append(SERVER_NAME == null ? lh.getCanonicalHostName() : SERVER_NAME.firstElement());
		String port = props.getProperty(""mappedPort"");
		 if (port==null) port = props.getProperty(""port"");
		 if (!""80"".equals(port)) {
			 sb.append("":"");
			 sb.append(port);
		 }
		return (sb.toString());
	}
	public static String getVersion() {
		return VERSION;
	}
	 public void banUser (User u, String msgTemplate, String message, long millis, String bannedBy) {
		 if (u==null) return;
		 MessageParser mp = new MessageParser ();
		 mp.setSender (u);
		 mp.setUsercontext(u);
		 Group g = u.getGroup ();
		 if (g != null) {
			 mp.setMessageTemplate (msgTemplate);
			 g.removeUser (u);
			 g.sendMessage(mp);
		 }
		 banUser (u, message, millis, bannedBy);
	 }
	 public void banUser (Vector<User> v, String message, long millis, String bannedBy) {
		 for (Enumeration<User> e = v.elements();
		 e.hasMoreElements();
		 ) {
			 User u = (User) e.nextElement();
			 this.banUser (u, message, millis, bannedBy);
		 }
	 }
	 public void banUser (User u, String message, long millis, String bannedBy) {
		 if (u==null) return;
		 StringBuffer sb = new StringBuffer (""banUser: User="");
		 sb.append (u.getName ());
		 sb.append ("" BannedBy="");
		 sb.append (bannedBy);
		 sb.append ("" Cookie="");
		 sb.append (u.getCookie());
		 if (u.conn == null) {
			 sb.append ("" Connection-Object was null"");
		 }
		 else if (u.conn.clientIp != null) {
			 sb.append("" +IP="");
			 sb.append(u.conn.clientIp);
		 }
		 else {
			 sb.append("" Came over Proxy (Proxy: "");
			 sb.append(u.conn.peerIp);
			 sb.append("", ForwardChain: "");
			 sb.append(u.conn.fwChain);
		 }
		 sb.append ("" Duration="");
		 sb.append (millis/1000);
		 sb.append (""secs Message="");
		 sb.append (message);
		 Server.log (this, sb.toString(), Server.MSG_AUTH, Server.LVL_MAJOR);
		 BanObject bo = new BanObject (message, bannedBy, System.currentTimeMillis () + millis);
		 bo.cookie = u.getCookie();
		 bo.usr = u.getName().toLowerCase().trim();
		 bo.email = (String) u.getProperty(""email"");
		 if (bo.email != null) {
			 bo.email = bo.email.trim().toLowerCase();
			 banList.put (bo.email, bo);
		 }
		 banList.put (bo.usr, bo);
		 banList.put (bo.cookie, bo);
		 if (USE_IP_BAN && u.conn != null && u.conn.isBanable()) {
			 bo.con=u.conn;
			 banList.put (bo.con.getBanKey(), bo);
		 }
		 u.sendQuitMessage(true, null);
	 }
	 public void banConn(Connection conn, String user, String cookie, String message, long millis){
		 if (conn != null && conn.isBanable()) {
			 BanObject bo = new BanObject (message, ""SYS"", System.currentTimeMillis () + millis);
			 bo.cookie = cookie;
			 bo.usr = user;
			 bo.con=conn;
			 banList.put (bo.usr, bo);
			 banList.put (bo.cookie, bo);
			 banList.put (bo.con.getBanKey(), bo);
			 StringBuffer sb = new StringBuffer (""banUser: User="");
			 sb.append (user);
			 if (conn == null) {
				 sb.append ("" Connection-Object was null"");
			 }
			 else if (conn.clientIp != null) {
				 sb.append("" +IP="");
				 sb.append(conn.clientIp);
			 }
			 else {
				 sb.append("" Came over Proxy (Proxy: "");
				 sb.append(conn.peerIp);
				 sb.append("", ForwardChain: "");
				 sb.append(conn.fwChain);
			 }
			 sb.append ("" Duration="");
			 sb.append (millis/1000);
			 sb.append (""secs Message="");
			 sb.append (message);
			 Server.log (this, sb.toString(), Server.MSG_AUTH, Server.LVL_MAJOR);
		 }
	 }
	 public boolean removeBan (String key) {
		 BanObject bo = (BanObject) banList.get(key);
		 if (bo == null) return false;
		 if (bo.hostban!=null) {
			 banList.remove(bo.hostban);
		 }
		 else {
			 if (bo.usr!=null) banList.remove(bo.usr);
			 if (bo.cookie!=null) banList.remove(bo.cookie);
			 if (bo.con!=null) banList.remove(bo.con.getBanKey());
			 if (bo.email!=null) banList.remove(bo.email);
		 }
		 return true;
	 }
	 public BanObject[] getBanList() {
		 if (banList.size() < 0) {
			 return new BanObject[0];
		 }
		 Vector<Object> v = new Vector<Object>();
		 for (Enumeration<BanObject> e = banList.elements();
		 e.hasMoreElements();
		 ) {
			 Object o = e.nextElement();
			 v.add(o);
		 }
		 return (BanObject[]) v.toArray(new BanObject[0]);
	 }
	public void banHost (InetAddress ia, long millis, String msg) {
		 BanObject bo = new BanObject (msg, ""Server"", millis);
		 bo.hostban = ia.getHostAddress();
		banList.put (bo.hostban, bo);
	}
	public void permaBanHost (InetAddress ia, String msg) {
		BanObject bo = new BanObject (msg, ""Config( parmaBannedIp )"", 0);
		 bo.hostban = ia.getHostAddress();
		banList.put (bo.hostban, bo);
		StringBuffer sb = new StringBuffer (""banHost: Host="");
		 sb.append (bo.hostban);
		 if (ia.getHostName() != null){
			 sb.append("" ("");
			 sb.append(ia.getHostName());
			 sb.append("")"");
		 }
		 sb.append ("" Message="");
		 sb.append (msg);
		 Server.log (this, sb.toString(), Server.MSG_STATE, Server.LVL_MAJOR);
	}
	public boolean isBanned (Object o) {
		if (o == null) return false;
		 BanObject b;
		if (o instanceof String) {
			String s = ((String) o).toLowerCase();
			b = (BanObject) banList.get (s);
		}
		 else if (o instanceof Connection) {
			Connection conn = (Connection) o;
			 if (!conn.isBanable()) return false;
			b = (BanObject) banList.get(conn.getBanKey());
		}
		 else if (o instanceof InetAddress) {
			 InetAddress ia = (InetAddress) o;
			 b = (BanObject) banList.get(ia.getHostAddress());
		 }
		 else {
			 b = (BanObject) banList.get (o);
		 }
		if (b == null) return false;
		if (b.time < System.currentTimeMillis ()) {
			banList.remove (o);
			return false;
		}
		return true;
	}
	public BanObject getBanObject (Object o) {
		 if (o == null) return null;
		 BanObject b;
		 if (o instanceof String) {
			 String s = ((String) o).toLowerCase();
			 b = banList.get (s);
		 }
		 else if (o instanceof Connection) {
			 Connection conn = (Connection) o;
			 if (!conn.isBanable()) return null;
			 b = banList.get(conn.getBanKey());
		 }
		 else if (o instanceof InetAddress) {
			 InetAddress ia = (InetAddress) o;
			 b = banList.get(ia.getHostAddress());
		 }
		 else {
			 b = banList.get (o);
		 }
		 return b;
	 }
	public boolean isTrafficBanned (Object o) {
		if (o == null) return false;
		 BanObject b = null;
		 if (o instanceof Connection) return false;
		 InetAddress ia = null;
		 try {
			 ia = (InetAddress) o;
		 }
		 catch (ClassCastException ce){
			 Server.log(this, ce.toString(), Server.MSG_ERROR, Server.LVL_MAJOR);
			 return false;
		 }
		if (o instanceof InetAddress) {
			 b = (BanObject) banList.get(ia.getHostAddress());
		 }
		 if (b == null || b.hostban == null) return false;
		if (b.bannedBy.equals(""Config( parmaBannedIp )""))return true;
		if (b.hostban != null && !b.hostban.equals(ia.getHostAddress()))return false;
		if (b.time < System.currentTimeMillis ()) {
			banList.remove (o);
			return false;
		}
		return true;
	}
	 public void storeUser (Vector<Object> v, int action, String message, long millis, String storedBy) {
		 for (Enumeration<?> e = v.elements();
		 e.hasMoreElements();
		 ) {
			 User u = (User) e.nextElement();
			 this.storeUser (action, u, message, millis, storedBy);
		}
	 }
	 public void storeUser (int action, User u, String message, long millis, String storedBy) {
		 if (u==null) return;
		if (action != IActionStates.PUNISH && action != IActionStates.FLOCKCOL && action != IActionStates.FLOCKAWAY && action != IActionStates.FLOCKME && action != IActionStates.SUBAN &&action != IActionStates.ISPUNISHABLE) return;
		 if (action == IActionStates.PUNISH && srv.PUNISH_DURATION == -1) return;
		 if (action == IActionStates.ISPUNISHABLE && (srv.PUNISH_DURATION == -1 || MESSAGE_FLOOD_LENGHT == -1)) return;
		 if ((action == IActionStates.FLOCKCOL || action == IActionStates.FLOCKAWAY || action == IActionStates.FLOCKME) && srv.MAX_FLOCK_DURATION == -1){
			 return;
		 }
		 String room = """";
		 if (UserManager.mgr.getUserByName(storedBy) != null) room = UserManager.mgr.getUserByName(storedBy).getGroup().getName();
		 String actionString = null;
		 if (action== IActionStates.FLOCKCOL) actionString =""FLOCKCOL"";
		 if (action== IActionStates.FLOCKAWAY) actionString =""FLOCKAWAY"";
		 if (action== IActionStates.FLOCKME) actionString =""FLOCKME"";
		 if (action== IActionStates.ISPUNISHABLE) actionString =""ISPUNISHABLE"";
		 if (action== IActionStates.PUNISH) actionString =""PUNISH"";
		 if (action== IActionStates.SUBAN) actionString =""SUBAN"";
		 StringBuffer sb = new StringBuffer (""StorUser: User="");
		sb.append (u.getName ());
		sb.append ("" StoredBy="");
		sb.append (storedBy);
		sb.append ("" Action="");
		sb.append (actionString);
		sb.append ("" Cookie="");
		sb.append (u.getCookie());
		if (u.conn == null) {
			 sb.append ("" Connection-Object was null"");
		}
		 else if (u.conn.clientIp != null) {
			 sb.append("" +IP="");
			 sb.append(u.conn.clientIp);
		 }
		 else {
			 sb.append("" Came over Proxy (Proxy: "");
			 sb.append(u.conn.peerIp);
			 sb.append("", ForwardChain: "");
			 sb.append(u.conn.fwChain);
		 }
		 sb.append ("" Duration="");
		 sb.append (millis/1000);
		 sb.append (""secs Message="");
		 sb.append (message);
		 sb.append ("" room="");
		 sb.append (room);
		 Server.log (this, sb.toString(), Server.MSG_STATE, Server.LVL_MAJOR);
		 ActionstoreObject po = new ActionstoreObject (action, message, storedBy, room, System.currentTimeMillis () + millis);
		 if (USE_IP_BAN && u.conn != null && u.conn.isBanable()&& po.equalsActionState(IActionStates.ISPUNISHABLE)) {
			 po.con=u.conn;
		 }
		 po.u = u;
		 po.cookie = u.getCookie();
		 po.usr = u.getName().toLowerCase().trim();
		 storeList.put (po, po.usr);
	 }
	 public ActionstoreObject[] getStoreList() {
		 if (storeList.size() < 0) {
			 return new ActionstoreObject[0];
		 }
		 Vector<Object> v = new Vector<Object>();
		 for (Enumeration<ActionstoreObject> e = storeList.keys();
		 e.hasMoreElements();
		 ) {
			 Object o = e.nextElement();
			 if (v.contains(o)) continue;
			 v.add(o);
		 }
		return (ActionstoreObject[]) v.toArray(new ActionstoreObject[0]);
	}
	 public boolean removeStore (Object val, int action) {
		 for (Enumeration<?> e = srv.storeList.keys();
		 e.hasMoreElements () ;
		 ) {
			 Object key = e.nextElement ();
			ActionstoreObject so = (ActionstoreObject) key;
			if (so.usr.equals(val) && so.action == action) {
				 if (so.equalsActionState(IActionStates.FLOCKCOL)) {
					 User u =UserManager.mgr.getUserByName(so.usr);
					 if (u!=null) u.setCollock(false);
				 }
				 if (so.equalsActionState(IActionStates.FLOCKAWAY)) {
					 User u =UserManager.mgr.getUserByName(so.usr);
					 if (u!=null) u.setAwaylock(false);
				 }
				 if (so.equalsActionState(IActionStates.FLOCKME)) {
					 User u =UserManager.mgr.getUserByName(so.usr);
					 if (u!=null) u.setActlock(false);
				 }
				srv.storeList.remove(key);
				so.clearObject();
				return true;
			}
		}
		return false;
	}
	public boolean isPunished (Object o) {
		if (o == null || srv.storeList.size() == 0) return false;
		 Hashtable<?, ?> st= (Hashtable<?, ?>) srv.storeList.clone();
		for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			 Object key = e.nextElement ();
			 ActionstoreObject p = (ActionstoreObject) key;
			 if (p.usr.equals(o) && p.equalsActionState(IActionStates.PUNISH)) {
				 if (p.time < System.currentTimeMillis ()) {
					 storeList.remove (key);
					 p.clearObject();
					 return false;
				 }
				 return true;
			 }
			 if (p.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
				 p.clearObject();
			 }
		}
		return false;
	 }
	public boolean isEntranceBanned (Object o) {
		if (o == null || srv.storeList.size() == 0) return false;
		 Hashtable<?, ?> st= (Hashtable<?, ?>) srv.storeList.clone();
		for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			 Object key = e.nextElement ();
			 ActionstoreObject p = (ActionstoreObject) key;
			 if (p.usr.equals(o) && p.equalsActionState(IActionStates.SUBAN)) {
				 if (p.time < System.currentTimeMillis ()) {
					 storeList.remove (key);
					 p.clearObject();
					 return false;
				 }
				 return true;
			 }
			 if (p.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
				 p.clearObject();
			 }
		}
		return false;
	 }
	public boolean isCollocked (Object o) {
		 if (o == null || srv.storeList.size() == 0) return false;
		 Hashtable<?, ?> st= (Hashtable<?, ?>) srv.storeList.clone();
		for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			Object key = e.nextElement ();
			ActionstoreObject l = (ActionstoreObject) key;
			if (l.usr.equals(o) && l.equalsActionState(IActionStates.FLOCKCOL)) {
				if (l.time < System.currentTimeMillis ()) {
					storeList.remove (key);
					l.clearObject();
					return false;
				}
				return true;
			}
			if (l.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
				 l.clearObject();
			}
		}
		 return false;
	 }
	 public boolean isActlocked (Object o) {
		 if (o == null || srv.storeList.size() == 0) return false;
		 Hashtable<?, ?> st = (Hashtable<?, ?>) srv.storeList.clone();
		 for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			 Object key = e.nextElement ();
			 ActionstoreObject l = (ActionstoreObject) key;
			 if (l.usr.equals(o) && l.equalsActionState(IActionStates.FLOCKME)) {
				 if (l.time < System.currentTimeMillis ()) {
					 storeList.remove (key);
					 l.clearObject();
					 return false;
				 }
				 return true;
			 }
			 if (l.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
				 l.clearObject();
			 }
		 }
		 return false;
	 }
	 public boolean isAwaylocked (Object o) {
		 if (o == null || srv.storeList.size() == 0) return false;
		 Hashtable<?, ?> st = (Hashtable<?, ?>) srv.storeList.clone();
		 for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			 Object key = e.nextElement ();
			 ActionstoreObject l = (ActionstoreObject) key;
			 if (l.usr.equals(o) && l.equalsActionState(IActionStates.FLOCKAWAY)) {
				 if (l.time < System.currentTimeMillis ()) {
					 storeList.remove (key);
					 l.clearObject();
					 return false;
				 }
				 return true;
			 }
			 if (l.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
				 l.clearObject();
			 }
		 }
		 return false;
	 }
	public boolean isPunishable (Object o) {
		 if (o == null || srv.storeList.size() == 0) return false;
		 Hashtable<?, ?> st= (Hashtable<?, ?>) srv.storeList.clone();
		for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			Object key = e.nextElement ();
			ActionstoreObject l = (ActionstoreObject) key;
			if (l.usr.equals(o) && l.equalsActionState(IActionStates.ISPUNISHABLE)) {
				if (l.time < System.currentTimeMillis ()) {
					storeList.remove (key);
					return false;
				}
				return true;
			}
			if (l.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
			}
		}
		 return false;
	 }
	public User getPunishableKey (Object o) {
		 if (o == null || srv.storeList.size() == 0) return null;
		 Hashtable<?, ?> st= (Hashtable<?, ?>) srv.storeList.clone();
		for (Enumeration<?> e = st.keys();
		 e.hasMoreElements () ;
		 ) {
			Object key = e.nextElement ();
			ActionstoreObject l = (ActionstoreObject) key;
			if (l.usr.equals(o) && l.equalsActionState(IActionStates.ISPUNISHABLE)) {
				if (l.time < System.currentTimeMillis ()) {
					storeList.remove (key);
					return null;
				}
				return l.u;
			}
			if (l.time < System.currentTimeMillis ()) {
				 storeList.remove (key);
			}
		}
		 return null;
	 }
	public static String[] LOGFILE = {
	""console"", ""console"", ""console"", ""console"", ""console"", ""console"", ""console""}
	;
	 public static final short MSG_CONFIG = 0;
	 public static final short MSG_AUTH = 1;
	 public static final short MSG_STATE = 2;
	 public static final short MSG_TRAFFIC = 3;
	 public static final short MSG_ERROR = 4;
	 public static final short MSG_MESSAGE = 5;
	 public static final short MSG_SEPAMESSAGE = 6;
	 public static final short LVL_HALT = 0;
	 public static final short LVL_MAJOR = 1;
	 public static final short LVL_MINOR = 2;
	 public static final short LVL_VERBOSE = 3;
	 public static final short LVL_VERY_VERBOSE = 4;
	 public static boolean DEBUG = false;
	 public static Short LOG_MASK[] = new Short[7];
	 public static boolean checkLogLvl (short type, short lvl) {
		 return (LOG_MASK[type].intValue () >= lvl || DEBUG);
	 }
	 public static void log (Object o, String msg, short type, short lvl) {
		 StringBuffer sb = new StringBuffer ();
		 try {
			 if (LOG_MASK[type].intValue () < lvl && !DEBUG) return;
			 sb.append (""["");
			 sb.append (Server.formatDefaultTimeStamp (System.currentTimeMillis ()));
			 switch (lvl) {
				 case LVL_MAJOR: sb.append (""] MAJOR-| "");
				 break;
				 case LVL_HALT: sb.append (""] HALT -| "");
				 break;
				 default: sb.append (""] -| "");
			 }
			 if (o != null) {
				 sb.append (o.toString());
				 sb.append ("": "");
			 }
			 sb.append (msg);
			 sb.append (""\r\n"");
			 if ((type == MSG_CONFIG && LOGFILE[MSG_CONFIG].equals(""console"")) || (type == MSG_AUTH && LOGFILE[MSG_AUTH].equals(""console"")) || (type == MSG_STATE && LOGFILE[MSG_STATE].equals(""console"")) || (type == MSG_TRAFFIC && LOGFILE[MSG_TRAFFIC].equals(""console"")) || (type == MSG_ERROR && LOGFILE[MSG_ERROR].equals(""console""))) {
				 System.out.print (sb.toString ());
			 }
			 else {
				 LogWriter.instance.addLogMessage (type, sb.toString());
			 }
			 if (lvl == LVL_HALT) System.exit (1);
		 }
		 catch (Exception e) {
			 System.err.println(""Server.log caused Exception for Message:"");
			 System.err.print(sb.toString());
			 e.printStackTrace();
		 }
	 }
	 public static void logMessage (MessageState messageState, Object o, String msg, short type, short lvl) {
		 StringBuffer sb = new StringBuffer ();
		 try {
			 if (LOG_MASK[type].intValue () < lvl && !DEBUG) return;
			 sb.append (""["");
			 sb.append (Server.formatDefaultTimeStamp (System.currentTimeMillis ()));
			 sb.append (""]"");
			 if (o != null) {
				 sb.append (o.toString());
				 sb.append ("": "");
			 }
			 sb.append (msg);
			 sb.append (""\r\n"");
			 if ((type == MSG_MESSAGE && LOGFILE[MSG_MESSAGE].equals(""console"")) || (type == MSG_SEPAMESSAGE) && LOGFILE[MSG_MESSAGE].equals(""console"")) {
				 System.out.print (sb.toString ());
			 }
			 else {
				 LogWriter.instance.addMessageLogMessage (messageState, type, sb.toString());
			 }
			 if (lvl == LVL_HALT) System.exit (1);
		 }
		 catch (Exception e) {
			 System.err.println(""Server.log caused Exception for Message:"");
			 System.err.print(sb.toString());
			 e.printStackTrace();
		 }
	 }
	 public static void debug (Object o, String prefix, Throwable t, short type, short lvl) {
		 if (LOG_MASK[type].intValue () < lvl && !DEBUG) return;
		 StringBuffer sb = new StringBuffer ();
		 sb.append (prefix);
		 sb.append (""\r\n"");
		 sb.append (t.toString ());
		 StackTraceElement ste[] = t.getStackTrace ();
		 for (int i = 0;
		 i < ste.length;
		 i++) {
			 sb.append (""\r\n at "");
			 sb.append (ste[i].getClassName ());
			 sb.append (""("");
			 sb.append (ste[i].getFileName ());
			 sb.append ("":"");
			 sb.append (ste[i].getLineNumber ());
			 sb.append ("")"");
		 }
		 log (o, sb.toString (), type, lvl);
	 }
	 private long lastModified;
	 private File configFile;
	 public long lastModified () {
		 return lastModified;
	 }
	 public void changed () {
		 try {
			 FileInputStream fis = new FileInputStream (configFile);
			 Properties tprop = new Properties ();
			 tprop.load (fis);
			 fis.close ();
			 props = tprop;
			 checkForConfigValues ();
			 lastModified = configFile.lastModified ();
			 Server.log (this, ""reload: reloaded configfile"", Server.MSG_STATE, Server.LVL_MINOR);
		 }
		 catch (Exception e) {
			 Server.debug (this, ""reload: "", e, Server.MSG_ERROR, Server.LVL_MAJOR);
		 }
	 }
	 public void removed () {
		 Server.log (this, ""CRITICAL-WARNING: Config file has been removed!\r\nThe Serverconfiguration of the last configuration-file present will stay in charge, but the server won't start if no config is present!"", Server.MSG_ERROR, Server.LVL_MAJOR);
	 }
	 public File getFile () {
		 return configFile;
	 }
	public boolean filePresent() {
		return true;
	 }
	public void created() {
		changed();
	}
	public String getFormatedTime (String pattern) {
		return formatTimeStamp (System.currentTimeMillis(), pattern);
	 }
	 public static SimpleDateFormat defaultDateFormat = new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss"");
	 public static SimpleDateFormat hourSDF = new SimpleDateFormat (""HH"");
	 public static SimpleDateFormat minuteSDF = new SimpleDateFormat (""mm"");
	 public static String formatDefaultTimeStamp (long ts) {
		 cal.setTimeInMillis(ts);
		 return defaultDateFormat.format (cal.getTime());
	 }
	public String formatTimeStamp (long ts, String pattern) {
		SimpleDateFormat sdf = new SimpleDateFormat (pattern);
		cal.setTimeInMillis (ts);
		return sdf.format (cal.getTime ());
	}
	 public static String formatTimeStamp (long ts, SimpleDateFormat sdf) {
		 cal.setTimeInMillis (ts);
		 return sdf.format (cal.getTime ());
	 }
	public File getConfigDir() {
		return (configFile != null) ? configFile.getParentFile() : null;
	}
	 public String toString () {
		 return (""[Server]"");
	 }
}",1,0,0,0
"public abstract class PerRowSecondaryIndex extends SecondaryIndex{
	 public abstract void applyIndexUpdates(ByteBuffer rowKey, ColumnFamily cf, SortedSet<ByteBuffer> mutatedIndexedColumns, ColumnFamily oldIndexedColumns) throws IOException;
	 public abstract void deleteFromIndex(DecoratedKey<?> key, List<IColumn> indexedColumnsInRow);
	 public String getNameForSystemTable(ByteBuffer columnName) {
		 try {
			 return getIndexName()+ByteBufferUtil.string(columnName);
		 }
		 catch (CharacterCodingException e) {
			 throw new RuntimeException(e);
		 }
	 }
}",0,0,0,0
"public static class Builder{
	 private final EagleServiceSingleEntityQueryRequest rawQuery;
	 public Builder(){
		 this.rawQuery= new EagleServiceSingleEntityQueryRequest();
	 }
	 public EagleServiceSingleEntityQueryRequest done(){
		 return this.rawQuery;
	 }
	 public Builder query(String query) {
		 this.rawQuery.setQuery(query);
		 return this;
	 }
	 public Builder startTime(long startTime) {
		 this.rawQuery.setStartTime(startTime);
		 return this;
	 }
	 public Builder endTime(long endTime) {
		 this.rawQuery.setEndTime(endTime);
		 return this;
	 }
	 public Builder pageSize(int pageSize) {
		 this.rawQuery.setPageSize(pageSize);
		 return this;
	 }
	 public Builder startRowkey(String startRowkey) {
		 this.rawQuery.setStartRowkey(startRowkey);
		 return this;
	 }
	 public Builder treeAgg(boolean treeAgg) {
		 this.rawQuery.setTreeAgg(treeAgg);
		 return this;
	 }
	 public Builder filerIfMissing(boolean filterIfMissing) {
		 this.rawQuery.setFilterIfMissing(filterIfMissing);
		 return this;
	 }
	 public Builder metricName(String metricName) {
		 this.rawQuery.setMetricName(metricName);
		 return this;
	 }
	 public Builder verbose(Boolean verbose) {
		 this.rawQuery.setVerbose(verbose);
		 return this;
	 }
 }",0,1,0,0
"public class InstantiatedVersionedLabel extends VersionedLabel implements InstantiatedVersionedComponent {
	 private final String instanceId;
	 private final String groupId;
	 public InstantiatedVersionedLabel(final String instanceId, final String instanceGroupId) {
		 this.instanceId = instanceId;
		 this.groupId = instanceGroupId;
	 }
	 public String getInstanceId() {
		 return instanceId;
	 }
	 public String getInstanceGroupId() {
		 return groupId;
	 }
}",0,1,0,0
"public static BufferedImage resizeImage(BufferedImage inputImage, int max) {
	 int width = inputImage.getWidth();
	 int height = inputImage.getHeight();
	 int targetWidth;
	 int targetHeight;
	 if (width <= max && height <= max) {
		 return inputImage;
	 }
	 else if (width > height) {
		 targetWidth = max;
		 targetHeight = targetWidth * height / width;
	 }
	 else {
		 targetHeight = max;
		 targetWidth = targetHeight * width / height;
	 }
	 Image scaledImage = inputImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_SMOOTH);
	 BufferedImage targetImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
	 targetImage.getGraphics().drawImage(scaledImage, 0, 0, null);
	 return targetImage;
 }",0,0,0,0
"public class LabelIconPanel extends Panel{
	private static final long serialVersionUID = 1L;
	public LabelIconPanel(String id, IModel<Object> model, BaseTree tree){
		super(id, model);
		addComponents(model, tree);
	}
	protected void addComponents(IModel<Object> model, BaseTree tree){
		add(newImageComponent(""icon"", tree, model));
		add(newContentComponent(""content"", tree, model));
	}
	protected Component newImageComponent(String componentId, final BaseTree tree,final IModel<Object> model){
		return new Image(componentId){
			private static final long serialVersionUID = 1L;
			protected ResourceReference getImageResourceReference(){
				return LabelIconPanel.this.getImageResourceReference(tree, model.getObject());
			}
		}
		;
	}
	protected Component newContentComponent(String componentId, BaseTree tree, IModel<Object> model){
		return new Label(componentId, model);
	}
	protected ResourceReference getImageResourceReference(BaseTree tree, Object node){
		TreeModel model = (TreeModel)tree.getDefaultModelObject();
		if (model.isLeaf(node)){
			return getResourceItemLeaf(node);
		}
		else{
			if (tree.getTreeState().isNodeExpanded(node)){
				return getResourceFolderOpen(node);
			}
			else{
				return getResourceFolderClosed(node);
			}
		}
	}
	protected IModel<Object> wrapNodeModel(IModel<Object> nodeModel){
		return nodeModel;
	}
	protected ResourceReference getResourceFolderClosed(Object node){
		return RESOURCE_FOLDER_CLOSED;
	}
	protected ResourceReference getResourceFolderOpen(Object node){
		return RESOURCE_FOLDER_OPEN;
	}
	protected ResourceReference getResourceItemLeaf(Object node){
		return RESOURCE_ITEM;
	}
	private static final ResourceReference RESOURCE_FOLDER_OPEN = new ResourceReference(LabelIconPanel.class, ""res/folder-open.gif"");
	private static final ResourceReference RESOURCE_FOLDER_CLOSED = new ResourceReference(LabelIconPanel.class, ""res/folder-closed.gif"");
	private static final ResourceReference RESOURCE_ITEM = new ResourceReference(LabelIconPanel.class, ""res/item.gif"");
}",0,0,0,0
"public synchronized int getType(){
	return type;
}",0,0,0,0
"public static String getInitialAddress(Configuration conf) {
	 return conf.get(INITIAL_THRIFT_ADDRESS);
 }",0,0,0,0
"private void save(ObjectOutputStream out) throws IOException {
	out.writeInt(maxSize);
	out.writeInt(size());
	for (Entry entry : history) {
		out.writeObject(entry);
	}
}",0,0,0,0
"public abstract class AbstractBraveClientProvider extends AbstractTracingProvider {
	 protected static final Logger LOG = LogUtils.getL7dLogger(AbstractBraveClientProvider.class);
	 protected static final String TRACE_SPAN = ""org.apache.cxf.tracing.client.brave.span"";
	 private final HttpTracing brave;
	 public AbstractBraveClientProvider(final HttpTracing brave) {
		 this.brave = brave;
	 }
	 protected TraceScopeHolder<TraceScope> startTraceSpan(final Map<String, List<String>> requestHeaders, URI uri, String method) {
		 final Request request = HttpAdapterFactory.request(requestHeaders, uri, method);
		 final HttpClientAdapter<Request, ?> adapter = HttpClientAdapterFactory.create(request);
		 final HttpClientHandler<Request, ?> handler = HttpClientHandler.create(brave, adapter);
		 final Span span = handler.handleSend( brave .tracing() .propagation() .injector(inject(requestHeaders)), request);
		 SpanInScope scope = null;
		 if (!isAsyncInvocation() && span != null) {
			 scope = brave.tracing().tracer().withSpanInScope(span);
		 }
		 return new TraceScopeHolder<TraceScope>(new TraceScope(span, scope), scope == null );
	 }
	 private <C> Setter<C, String> inject(final Map<String, List<String>> requestHeaders) {
		 return (carrier, key, value) -> {
			 if (!requestHeaders.containsKey(key)) {
				 requestHeaders.put(key, Collections.singletonList(value));
			 }
		 }
		;
	 }
	 private boolean isAsyncInvocation() {
		 return !PhaseInterceptorChain.getCurrentMessage().getExchange().isSynchronous();
	 }
	 protected void stopTraceSpan(final TraceScopeHolder<TraceScope> holder, final int responseStatus) {
		 if (holder == null) {
			 return;
		 }
		 final TraceScope scope = holder.getScope();
		 if (scope != null) {
			 try {
				 if (holder.isDetached()) {
					 brave.tracing().tracer().joinSpan(scope.getSpan().context());
				 }
				 final Response response = HttpAdapterFactory.response(responseStatus);
				 final HttpClientAdapter<?, Response> adapter = HttpClientAdapterFactory.create(response);
				 final HttpClientHandler<?, Response> handler = HttpClientHandler.create(brave, adapter);
				 handler.handleReceive(response, null, scope.getSpan());
			 }
			 finally {
				 scope.close();
			 }
		 }
	 }
}",1,0,0,0
"public synchronized String system_add_keyspace(KsDef ks_def) throws InvalidRequestException, SchemaDisagreementException, TException {
	 logger.debug(""add_keyspace"");
	 state().hasKeyspaceListAccess(Permission.WRITE);
	 validateSchemaAgreement();
	 for (CfDef cf : ks_def.cf_defs) {
		 if (!cf.getKeyspace().equals(ks_def.getName())) {
			 throw new InvalidRequestException(""CsDef ("" + cf.getName() +"") had a keyspace definition that did not match KsDef"");
		 }
	 }
	 try {
		 Collection<CFMetaData> cfDefs = new ArrayList<CFMetaData>(ks_def.cf_defs.size());
		 for (CfDef cf_def : ks_def.cf_defs) {
			 CFMetaData.addDefaultIndexNames(cf_def);
			 ThriftValidation.validateCfDef(cf_def, null);
			 cfDefs.add(CFMetaData.fromThrift(cf_def));
		 }
		 ThriftValidation.validateKsDef(ks_def);
		 applyMigrationOnStage(new AddKeyspace(KSMetaData.fromThrift(ks_def, cfDefs.toArray(new CFMetaData[cfDefs.size()]))));
		 return DatabaseDescriptor.getDefsVersion().toString();
	 }
	 catch (ConfigurationException e) {
		 InvalidRequestException ex = new InvalidRequestException(e.getMessage());
		 ex.initCause(e);
		 throw ex;
	 }
	 catch (IOException e) {
		 InvalidRequestException ex = new InvalidRequestException(e.getMessage());
		 ex.initCause(e);
		 throw ex;
	 }
 }",0,0,0,0
"public abstract static class Builder<T extends Builder<T>> {
	 protected abstract T self();
	 protected Long id;
	 protected String name;
	 protected String description;
	 public T id(Long id) {
		 this.id = id;
		 return self();
	 }
	 public T name(String name) {
		 this.name = name;
		 return self();
	 }
	 public T description(String description) {
		 this.description = description;
		 return self();
	 }
	 public Option build() {
		 return new Option(id, name, description);
	 }
	 public T fromOption(Option in) {
		 return this .id(in.getId()) .name(in.getName()) .description(in.getDescription());
	 }
 }",0,1,0,0
"public URI(String p_scheme, String p_userinfo, String p_host, int p_port, String p_path, String p_queryString, String p_fragment) throws MalformedURIException;",0,0,0,1
"private void performCommonProcessing(Operation currentOperation, KuduExecutionContext kuduExecutionContext) {
	 currentOperation.setExternalConsistencyMode(kuduExecutionContext.getExternalConsistencyMode());
	 Long propagatedTimeStamp = kuduExecutionContext.getPropagatedTimestamp();
	 if ( propagatedTimeStamp != null) {
		 currentOperation.setPropagatedTimestamp(propagatedTimeStamp);
	 }
	 PartialRow partialRow = currentOperation.getRow();
	 Object payload = kuduExecutionContext.getPayload();
	 Set<String> doNotWriteColumns = kuduExecutionContext.getDoNotWriteColumns();
	 if (doNotWriteColumns == null) {
		 doNotWriteColumns = new HashSet<>();
	 }
	 for (String columnName: kuduColumnBasedGetters.keySet()) {
		 if ( doNotWriteColumns.contains(columnName)) {
			 continue;
		 }
		 ColumnSchema columnSchema = allColumnDefs.get(columnName);
		 Type dataType = columnSchema.getType();
		 try {
			 switch (dataType) {
				 case STRING: PojoUtils.Getter<Object, String> stringGetter = ((PojoUtils.Getter<Object, String>)kuduColumnBasedGetters .get(columnName));
				 if (stringGetter != null) {
					 final String stringValue = stringGetter.get(payload);
					 if (stringValue != null) {
						 partialRow.addString(columnName, stringValue);
					 }
				 }
				 break;
				 case BINARY: PojoUtils.Getter<Object, ByteBuffer> byteBufferGetter = ((PojoUtils.Getter<Object, ByteBuffer>) kuduColumnBasedGetters.get(columnName));
				 if (byteBufferGetter != null) {
					 final ByteBuffer byteBufferValue = byteBufferGetter.get(payload);
					 if (byteBufferValue != null) {
						 partialRow.addBinary(columnName, byteBufferValue);
					 }
				 }
				 break;
				 case BOOL: PojoUtils.GetterBoolean<Object> boolGetter = ((PojoUtils.GetterBoolean<Object>)kuduColumnBasedGetters.get( columnName));
				 if (boolGetter != null) {
					 final boolean boolValue = boolGetter.get(payload);
					 partialRow.addBoolean(columnName, boolValue);
				 }
				 break;
				 case DOUBLE: PojoUtils.GetterDouble<Object> doubleGetter = ((PojoUtils.GetterDouble<Object>)kuduColumnBasedGetters.get( columnName));
				 if (doubleGetter != null) {
					 final double doubleValue = doubleGetter.get(payload);
					 partialRow.addDouble(columnName, doubleValue);
				 }
				 break;
				 case FLOAT: PojoUtils.GetterFloat<Object> floatGetter = ((PojoUtils.GetterFloat<Object>)kuduColumnBasedGetters.get( columnName));
				 if (floatGetter != null) {
					 final float floatValue = floatGetter.get(payload);
					 partialRow.addFloat(columnName, floatValue);
				 }
				 break;
				 case INT8: PojoUtils.GetterByte<Object> byteGetter = ((PojoUtils.GetterByte<Object>)kuduColumnBasedGetters.get( columnName));
				 if (byteGetter != null) {
					 final byte byteValue = byteGetter.get(payload);
					 partialRow.addByte(columnName, byteValue);
				 }
				 break;
				 case INT16: PojoUtils.GetterShort<Object> shortGetter = ((PojoUtils.GetterShort<Object>)kuduColumnBasedGetters.get( columnName));
				 if (shortGetter != null) {
					 final short shortValue = shortGetter.get(payload);
					 partialRow.addShort(columnName, shortValue);
				 }
				 break;
				 case INT32: PojoUtils.GetterInt<Object> intGetter = ((PojoUtils.GetterInt<Object>) kuduColumnBasedGetters.get(columnName));
				 if (intGetter != null) {
					 final int intValue = intGetter.get(payload);
					 partialRow.addInt(columnName, intValue);
				 }
				 break;
				 case INT64: case UNIXTIME_MICROS: PojoUtils.GetterLong<Object> longGetter = ((PojoUtils.GetterLong<Object>)kuduColumnBasedGetters.get( columnName));
				 if (longGetter != null) {
					 final long longValue = longGetter.get(payload);
					 partialRow.addLong(columnName, longValue);
				 }
				 break;
				 default: LOG.error(columnName + "" is not of the supported data type"");
				 throw new UnsupportedOperationException(""Kudu does not support data type for column "" + columnName);
			 }
		 }
		 catch ( Exception ex ) {
			 LOG.error("" Exception while fetching the value of "" + columnName + "" because "" + ex.getMessage());
			 partialRow.setNull(columnName);
		 }
	 }
	 try {
		 kuduSession.apply(currentOperation);
	 }
	 catch (KuduException e) {
		 throw new RuntimeException(""Could not execute operation because "" + e.getMessage(), e);
	 }
 }",0,0,1,0
"public class DialogTextEditor extends DialogCellEditor{
	 private boolean isSelection = false;
	 private boolean isDeleteable = false;
	 private boolean isSelectable = false;
	 private ModifyListener modifyListener;
	private Text text;
	public DialogTextEditor(Composite parent) {
		super(parent);
	}
	protected Object openDialogBox(Control cellEditorWindow) {
		FileDialog dialog = new FileDialog(cellEditorWindow.getShell(), SWT.OPEN);
		return dialog.open();
	}
	 protected Button createButton(Composite parent) {
		 Button button = super.createButton(parent);
		 button.setText(""Browse..."");
		 return button;
	 }
	protected Control createContents(Composite cell) {
		text = new Text(cell, getStyle());
		 text.addSelectionListener(new SelectionAdapter() {
			public void widgetDefaultSelected(SelectionEvent e) {
				 handleDefaultSelection(e);
			 }
		 }
		);
		 text.addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent e) {
				 keyReleaseOccured(e);
				 if ((getControl() == null) || getControl().isDisposed()) {
					return;
				}
				 checkSelection();
				 checkDeleteable();
				 checkSelectable();
			 }
		 }
		);
		 text.addTraverseListener(e -> {
			 if (e.detail == SWT.TRAVERSE_ESCAPE || e.detail == SWT.TRAVERSE_RETURN) {
				 e.doit = false;
			 }
		}
		);
		 text.addMouseListener(new MouseAdapter() {
			public void mouseUp(MouseEvent e) {
				 checkSelection();
				 checkDeleteable();
				 checkSelectable();
			 }
		 }
		);
		 text.addFocusListener(new FocusAdapter() {
			public void focusLost(FocusEvent e) {
				 doSetValue(text.getText());
			 }
		 }
		);
		 text.setFont(cell.getFont());
		 text.setBackground(cell.getBackground());
		 text.setText("""");
		 text.addModifyListener(getModifyListener());
		 return text;
	}
	protected void doSetFocus() {
		 if (text != null) {
			 text.selectAll();
			 text.setFocus();
			 checkSelection();
			 checkDeleteable();
			 checkSelectable();
		 }
	 }
	 private void checkSelection() {
		 boolean oldIsSelection = isSelection;
		 isSelection = text.getSelectionCount() > 0;
		 if (oldIsSelection != isSelection) {
			 fireEnablementChanged(COPY);
			 fireEnablementChanged(CUT);
		 }
	 }
	 private void checkDeleteable() {
		 boolean oldIsDeleteable = isDeleteable;
		 isDeleteable = isDeleteEnabled();
		 if (oldIsDeleteable != isDeleteable) {
			 fireEnablementChanged(DELETE);
		 }
	 }
	 private void checkSelectable() {
		 boolean oldIsSelectable = isSelectable;
		 isSelectable = isSelectAllEnabled();
		 if (oldIsSelectable != isSelectable) {
			 fireEnablementChanged(SELECT_ALL);
		 }
	 }
	 protected void handleDefaultSelection(SelectionEvent event) {
		 fireApplyEditorValue();
		 deactivate();
	 }
	 private ModifyListener getModifyListener() {
		 if (modifyListener == null) {
			modifyListener = this::editOccured;
		 }
		 return modifyListener;
	 }
	 protected void editOccured(ModifyEvent e) {
		 String value = text.getText();
		 if (value == null) {
			value = """";
		}
		 Object typedValue = value;
		 boolean oldValidState = isValueValid();
		 boolean newValidState = isCorrect(typedValue);
		 if (!newValidState) {
			 setErrorMessage(MessageFormat.format(getErrorMessage(), new Object[] {
			 value }
			));
		 }
		 valueChanged(oldValidState, newValidState);
	 }
	protected void keyReleaseOccured(KeyEvent keyEvent) {
		 if (keyEvent.character == '\r') {
			 if (text != null && !text.isDisposed() && (text.getStyle() & SWT.MULTI) != 0) {
				 if ((keyEvent.stateMask & SWT.CTRL) != 0) {
					 super.keyReleaseOccured(keyEvent);
				 }
			 }
			 return;
		 }
		 super.keyReleaseOccured(keyEvent);
	 }
	 protected void updateContents(Object value) {
		 if (text == null) {
			return;
		}
		 String val = """";
		 if (value != null) {
			val = value.toString();
		}
		 text.setText(val);
		 Assert.isTrue(text != null && (val instanceof String));
		 text.removeModifyListener(getModifyListener());
		 text.setText((String) val);
		 text.addModifyListener(getModifyListener());
	 }
}",0,0,0,0
"public class StackRoots {
	private ArrayList<J9ObjectPointer> _allStackRoots = new ArrayList<J9ObjectPointer>();
	private ArrayList<VoidPointer> _allAddresses = new ArrayList<VoidPointer>();
	private static StackRoots _singleton;
	private class StackWalkerCallbacks implements IStackWalkerCallbacks{
		public FrameCallbackResult frameWalkFunction(J9VMThreadPointer walkThread, WalkState walkState){
			return FrameCallbackResult.KEEP_ITERATING;
		}
		public void objectSlotWalkFunction(J9VMThreadPointer walkThread, WalkState walkState, PointerPointer objectSlot, VoidPointer stackAddress){
			if (walkState.method.isNull()){
				return;
			}
			try {
				J9ObjectPointer object = J9ObjectPointer.cast(objectSlot.at(0));
				if (object.notNull()) {
					_allStackRoots.add(object);
					_allAddresses.add(VoidPointer.cast(objectSlot));
				}
			}
			 catch (CorruptDataException e) {
				throw new UnsupportedOperationException(""Corrupt objectSlot detected"");
			}
		}
		public void fieldSlotWalkFunction(J9VMThreadPointer walkThread,WalkState walkState, ObjectReferencePointer objectSlot,VoidPointer stackLocation){
			if (walkState.method.isNull()){
				return;
			}
			try {
				J9ObjectPointer object = objectSlot.at(0);
				if (object.notNull()) {
					_allStackRoots.add(object);
					_allAddresses.add(VoidPointer.cast(objectSlot));
				}
			}
			 catch (CorruptDataException e) {
				throw new UnsupportedOperationException(""Corrupt objectSlot detected"");
			}
		}
	}
	private StackRoots() throws CorruptDataException{
		_allStackRoots = new ArrayList<J9ObjectPointer>();
		_allAddresses = new ArrayList<VoidPointer>();
		walkStacks();
	}
	public static StackRoots from() throws CorruptDataException {
		if (null != _singleton) {
			return _singleton;
		}
		_singleton = new StackRoots();
		return _singleton;
	}
	private void walkStacks() throws CorruptDataException{
		GCVMThreadListIterator threadIterator = GCVMThreadListIterator.from();
		while (threadIterator.hasNext()) {
			J9VMThreadPointer next = threadIterator.next();
			WalkState walkState = new WalkState();
			walkState.walkThread = next;
			walkState.flags = J9_STACKWALK_SKIP_INLINES | J9_STACKWALK_ITERATE_O_SLOTS | J9_STACKWALK_ITERATE_METHOD_CLASS_SLOTS;
			walkState.callBacks = new StackWalkerCallbacks();
			 StackWalkResult result = StackWalkResult.STACK_CORRUPT;
			result = StackWalker.walkStackFrames(walkState);
			if (StackWalkResult.NONE != result) {
				throw new UnsupportedOperationException(""Failed to walk stack"");
			}
		}
	}
	public static ArrayList<J9ObjectPointer> allRoots() throws CorruptDataException{
		StackRoots stackRoots= new StackRoots();
		return stackRoots._allStackRoots;
	}
	public static GCIterator stackRootIterator() throws CorruptDataException{
		final StackRoots stackRootSet = StackRoots.from();
		final Iterator<J9ObjectPointer> rootSetIterator = stackRootSet._allStackRoots.iterator();
		final Iterator<VoidPointer> rootSetAddressIterator = stackRootSet._allAddresses.iterator();
		return new GCIterator() {
			public boolean hasNext() {
				return rootSetIterator.hasNext();
			}
			public VoidPointer nextAddress() {
				rootSetIterator.next();
				return rootSetAddressIterator.next();
			}
			public Object next() {
				rootSetAddressIterator.next();
				return rootSetIterator.next();
			 }
		}
		;
	}
}",0,0,0,0
"public class BrowseHookFactory extends HookFactoryAdapter {
	public BrowseHookFactory() {
		super();
	}
	public Vector getPossibleNodeHooks() {
		return new Vector();
	}
	public Vector getPossibleModeControllerHooks() {
		return new Vector();
	}
	public ModeControllerHook createModeControllerHook(String hookName) {
		return null;
	}
	public NodeHook createNodeHook(String hookName) {
		NodeHook hook;
		if(hookName.equals(ReminderHookBase.PLUGIN_LABEL)) {
			hook = new BrowseReminderHook();
		}
		 else {
			hook = new PermanentNodeHookSubstituteUnknown(hookName);
		}
		hook.setProperties(new Properties());
		hook.setName(hookName);
		hook.setPluginBaseClass(null);
		return hook;
	}
	public List getHookMenuPositions(String hookName) {
		return null;
	}
	public HookInstanciationMethod getInstanciationMethod(String hookName) {
		return null;
	}
	public List getRegistrations() {
		return null;
	}
	public Object getPluginBaseClass(String hookName) {
		return null;
	}
}",0,0,0,0
"public void updateState(X509Certificate cert) throws CertificateException, IOException, CertPathValidatorException {
	 if (cert == null) {
		 return;
	 }
	 subjectDN = cert.getSubjectX500Principal();
	 X509CertImpl icert = X509CertImpl.toImpl(cert);
	 PublicKey newKey = cert.getPublicKey();
	 if (PKIX.isDSAPublicKeyWithoutParams(newKey)) {
		 newKey = BasicChecker.makeInheritedParamsKey(newKey, pubKey);
	 }
	 pubKey = newKey;
	 if (init) {
		 init = false;
		 return;
	 }
	 subjKeyId = icert.getSubjectKeyIdentifierExtension();
	 crlSign = RevocationChecker.certCanSignCrl(cert);
	 if (nc != null) {
		 nc.merge(icert.getNameConstraintsExtension());
	 }
	 else {
		 nc = icert.getNameConstraintsExtension();
		 if (nc != null) {
			 nc = (NameConstraintsExtension) nc.clone();
		 }
	 }
	 explicitPolicy = PolicyChecker.mergeExplicitPolicy(explicitPolicy, icert, false);
	 policyMapping = PolicyChecker.mergePolicyMapping(policyMapping, icert);
	 inhibitAnyPolicy = PolicyChecker.mergeInhibitAnyPolicy(inhibitAnyPolicy, icert);
	 certIndex++;
	 remainingCACerts = ConstraintsChecker.mergeBasicConstraints(cert, remainingCACerts);
	 init = false;
 }",0,0,1,0
"public class ColumnFamilyOutputFormat extends OutputFormat<ByteBuffer,List<Mutation>> implements org.apache.hadoop.mapred.OutputFormat<ByteBuffer,List<Mutation>>{
	 private static final Logger logger = LoggerFactory.getLogger(ColumnFamilyOutputFormat.class);
	 public static final String BATCH_THRESHOLD = ""mapreduce.output.columnfamilyoutputformat.batch.threshold"";
	 public static final String QUEUE_SIZE = ""mapreduce.output.columnfamilyoutputformat.queue.size"";
	 public void checkOutputSpecs(JobContext context) {
		 checkOutputSpecs(context.getConfiguration());
	 }
	 private void checkOutputSpecs(Configuration conf) {
		 if (ConfigHelper.getOutputKeyspace(conf) == null || ConfigHelper.getOutputColumnFamily(conf) == null) {
			 throw new UnsupportedOperationException(""you must set the keyspace and columnfamily with setColumnFamily()"");
		 }
	 }
	 public OutputCommitter getOutputCommitter(TaskAttemptContext context) throws IOException, InterruptedException {
		 return new NullOutputCommitter();
	 }
	 public void checkOutputSpecs(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job) throws IOException {
		 checkOutputSpecs(job);
	 }
	 public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress) throws IOException {
		 return new ColumnFamilyRecordWriter(job);
	 }
	 public ColumnFamilyRecordWriter getRecordWriter(final TaskAttemptContext context) throws IOException, InterruptedException {
		 return new ColumnFamilyRecordWriter(context);
	 }
	 public static Cassandra.Client createAuthenticatedClient(TSocket socket, Configuration conf) throws InvalidRequestException, TException, AuthenticationException, AuthorizationException {
		 TBinaryProtocol binaryProtocol = new TBinaryProtocol(new TFramedTransport(socket));
		 Cassandra.Client client = new Cassandra.Client(binaryProtocol);
		 socket.open();
		 client.set_keyspace(ConfigHelper.getOutputKeyspace(conf));
		 if (ConfigHelper.getOutputKeyspaceUserName(conf) != null) {
			 Map<String, String> creds = new HashMap<String, String>();
			 creds.put(SimpleAuthenticator.USERNAME_KEY, ConfigHelper.getOutputKeyspaceUserName(conf));
			 creds.put(SimpleAuthenticator.PASSWORD_KEY, ConfigHelper.getOutputKeyspacePassword(conf));
			 AuthenticationRequest authRequest = new AuthenticationRequest(creds);
			 client.login(authRequest);
		 }
		 return client;
	 }
	 public static class NullOutputCommitter extends OutputCommitter {
		 public void abortTask(TaskAttemptContext taskContext) {
		 }
		 public void cleanupJob(JobContext jobContext) {
		 }
		 public void commitTask(TaskAttemptContext taskContext) {
		 }
		 public boolean needsTaskCommit(TaskAttemptContext taskContext) {
			 return false;
		 }
		 public void setupJob(JobContext jobContext) {
		 }
		 public void setupTask(TaskAttemptContext taskContext) {
		 }
	 }
}",0,0,0,0
"public class Exit extends Task {
	 private static class NestedCondition extends ConditionBase implements Condition {
		 public boolean eval() {
			 if (countConditions() != 1) {
				 throw new BuildException( ""A single nested condition is required."");
			 }
			 return ((Condition) (getConditions().nextElement())).eval();
		 }
	 }
	 private String message;
	 private String ifCondition, unlessCondition;
	 private NestedCondition nestedCondition;
	 private Integer status;
	 public void setMessage(String value) {
		 this.message = value;
	 }
	 public void setIf(String c) {
		 ifCondition = c;
	 }
	 public void setUnless(String c) {
		 unlessCondition = c;
	 }
	 public void setStatus(int i) {
		 status = new Integer(i);
	 }
	 public void execute() throws BuildException {
		 boolean fail = (nestedConditionPresent()) ? testNestedCondition() : (testIfCondition() && testUnlessCondition());
		 if (fail) {
			 String text = null;
			 if (message != null && message.trim().length() > 0) {
				 text = message.trim();
			 }
			 else {
				 if (ifCondition != null && ifCondition.length() > 0 && getProject().getProperty(ifCondition) != null) {
					 text = ""if="" + ifCondition;
				 }
				 if (unlessCondition != null && unlessCondition.length() > 0 && getProject().getProperty(unlessCondition) == null) {
					 if (text == null) {
						 text = """";
					 }
					 else {
						 text += "" and "";
					 }
					 text += ""unless="" + unlessCondition;
				 }
				 if (nestedConditionPresent()) {
					 text = ""condition satisfied"";
				 }
				 else {
					 if (text == null) {
						 text = ""No message"";
					 }
				 }
			 }
			 log(""failing due to "" + text, Project.MSG_DEBUG);
			 throw ((status == null) ? new BuildException(text) : new ExitStatusException(text, status.intValue()));
		 }
	 }
	 public void addText(String msg) {
		 if (message == null) {
			 message = """";
		 }
		 message += getProject().replaceProperties(msg);
	 }
	 public ConditionBase createCondition() {
		 if (nestedCondition != null) {
			 throw new BuildException(""Only one nested condition is allowed."");
		 }
		 nestedCondition = new NestedCondition();
		 return nestedCondition;
	 }
	 private boolean testIfCondition() {
		 if (ifCondition == null || """".equals(ifCondition)) {
			 return true;
		 }
		 return getProject().getProperty(ifCondition) != null;
	 }
	 private boolean testUnlessCondition() {
		 if (unlessCondition == null || """".equals(unlessCondition)) {
			 return true;
		 }
		 return getProject().getProperty(unlessCondition) == null;
	 }
	 private boolean testNestedCondition() {
		 boolean result = nestedConditionPresent();
		 if (result && ifCondition != null || unlessCondition != null) {
			 throw new BuildException(""Nested conditions "" + ""not permitted in conjunction with if/unless attributes"");
		 }
		 return result && nestedCondition.eval();
	 }
	 private boolean nestedConditionPresent() {
		 return (nestedCondition != null);
	 }
}",0,0,0,0
"public class TfsGitTreeEntriesJson {
	 private final String objectId;
	 private final List<TfsGitTreeEntryJson> treeEntries;
	 private final int size;
	 public TfsGitTreeEntriesJson( final String objectId, final List<TfsGitTreeEntryJson> treeEntries, final int size) throws JsonProcessingException {
		 this.objectId = objectId;
		 this.treeEntries = treeEntries;
		 this.size = size;
	 }
	 public String getObjectId() {
		 return objectId;
	 }
	 public List<TfsGitTreeEntryJson> getTreeEntries() {
		 return treeEntries;
	 }
	 public int getSize() {
		 return size;
	 }
}",0,1,0,0
"public interface IPrepareCommit {
	 void prepareCommit(BatchId id, BasicOutputCollector collector) throws FailedException;
}",0,0,0,0
"public class AuditDAOUtil extends HibernateDaoSupport implements Auditor {
	 private static Log log = LogFactory.getLog(AuditDAOUtil.class);
	 private TransactionTemplate txTemplate = null;
	 public void audit(String subjectType, String action, String message) {
		 final Audit audit = new Audit();
		 audit.setAction(action);
		 audit.setDateTime(new Date());
		 audit.setMessage(message);
		 audit.setSubjectType(subjectType);
		 txTemplate.execute( new TransactionCallback() {
			 public Object doInTransaction(TransactionStatus ts) {
				 try {
					 log.debug(""Before Saving of the Audit Object"");
					 getHibernateTemplate().saveOrUpdate(audit);
					 log.debug(""After Saving of the AUdit Object"");
				 }
				 catch(Exception ex) {
					 log.warn(""Setting Rollback Only"",ex);
					 ts.setRollbackOnly();
				 }
				 return null;
			 }
		 }
		 );
	 }
	 public void audit(String subjectType, Long subjectOid, String action, String message) {
		 User user = AuthUtil.getRemoteUserObject();
		 if (user == null) {
			 this.audit(subjectType, action, message);
			 return;
		 }
		 final Audit audit = new Audit();
		 audit.setAction(action);
		 audit.setDateTime(new Date());
		 audit.setFirstname(user.getFirstname());
		 audit.setLastname(user.getLastname());
		 audit.setMessage(message);
		 audit.setSubjectOid(subjectOid);
		 audit.setSubjectType(subjectType);
		 audit.setUserName(user.getUsername());
		 audit.setUserOid(user.getOid());
		 audit.setAgencyOid(user.getAgency().getOid());
		 txTemplate.execute( new TransactionCallback() {
			 public Object doInTransaction(TransactionStatus ts) {
				 try {
					 log.debug(""Before Saving of the Audit Object"");
					 getHibernateTemplate().saveOrUpdate(audit);
					 log.debug(""After Saving of the AUdit Object"");
				 }
				 catch(Exception ex) {
					 log.warn(""Setting Rollback Only"",ex);
					 ts.setRollbackOnly();
				 }
				 return null;
			 }
		 }
		 );
	 }
	 public void audit(User aUser, String subjectType, Long subjectOid, String action, String message) {
		 log.debug(""Recieved audit request for "" + aUser + "" "" + subjectType + "" "" + subjectOid + "" "" + action + "" "" + message);
		 final Audit audit = new Audit();
		 audit.setAction(action);
		 audit.setDateTime(new Date());
		 audit.setFirstname(aUser.getFirstname());
		 audit.setLastname(aUser.getLastname());
		 audit.setMessage(message);
		 audit.setSubjectOid(subjectOid);
		 audit.setSubjectType(subjectType);
		 audit.setUserName(aUser.getUsername());
		 audit.setUserOid(aUser.getOid());
		 audit.setAgencyOid(aUser.getAgency().getOid());
		 txTemplate.execute( new TransactionCallback() {
			 public Object doInTransaction(TransactionStatus ts) {
				 try {
					 log.debug(""Before Saving of the Audit Object"");
					 getHibernateTemplate().saveOrUpdate(audit);
					 log.debug(""After Saving of the AUdit Object"");
				 }
				 catch(Exception ex) {
					 log.warn(""Setting Rollback Only"",ex);
					 ts.setRollbackOnly();
				 }
				 return null;
			 }
		 }
		 );
		 log.debug(""Processed audit request for "" + aUser + "" "" + subjectType + "" "" + subjectOid + "" "" + action + "" "" + message);
	 }
	 public void setTxTemplate(TransactionTemplate txTemplate) {
		 this.txTemplate = txTemplate;
	 }
}",0,1,0,0
"public interface XtypePackage extends EPackage{
	String eNAME = ""xtype"";
	String eNS_URI = ""http:String eNS_PREFIX = ""xtype"";
	XtypePackage eINSTANCE = org.eclipse.xtext.xtype.impl.XtypePackageImpl.init();
	int XFUNCTION_TYPE_REF = 0;
	int XFUNCTION_TYPE_REF__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;
	int XFUNCTION_TYPE_REF__PARAM_TYPES = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;
	int XFUNCTION_TYPE_REF__RETURN_TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;
	int XFUNCTION_TYPE_REF__TYPE = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 2;
	int XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 3;
	int XFUNCTION_TYPE_REF_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 4;
	int XCOMPUTED_TYPE_REFERENCE = 1;
	int XCOMPUTED_TYPE_REFERENCE__EQUIVALENT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE__EQUIVALENT;
	int XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 0;
	int XCOMPUTED_TYPE_REFERENCE_FEATURE_COUNT = TypesPackage.JVM_SPECIALIZED_TYPE_REFERENCE_FEATURE_COUNT + 1;
	int XIMPORT_SECTION = 2;
	int XIMPORT_SECTION__IMPORT_DECLARATIONS = 0;
	int XIMPORT_SECTION_FEATURE_COUNT = 1;
	int XIMPORT_DECLARATION = 3;
	int XIMPORT_DECLARATION__WILDCARD = 0;
	int XIMPORT_DECLARATION__EXTENSION = 1;
	int XIMPORT_DECLARATION__STATIC = 2;
	int XIMPORT_DECLARATION__IMPORTED_TYPE = 3;
	int XIMPORT_DECLARATION__MEMBER_NAME = 4;
	int XIMPORT_DECLARATION__IMPORTED_NAMESPACE = 5;
	int XIMPORT_DECLARATION_FEATURE_COUNT = 6;
	int IJVM_TYPE_REFERENCE_PROVIDER = 4;
	EClass getXFunctionTypeRef();
	EReference getXFunctionTypeRef_ParamTypes();
	EReference getXFunctionTypeRef_ReturnType();
	EReference getXFunctionTypeRef_Type();
	EAttribute getXFunctionTypeRef_InstanceContext();
	EClass getXComputedTypeReference();
	EAttribute getXComputedTypeReference_TypeProvider();
	EClass getXImportSection();
	EReference getXImportSection_ImportDeclarations();
	EClass getXImportDeclaration();
	EAttribute getXImportDeclaration_Wildcard();
	EAttribute getXImportDeclaration_Extension();
	EAttribute getXImportDeclaration_Static();
	EReference getXImportDeclaration_ImportedType();
	EAttribute getXImportDeclaration_MemberName();
	EAttribute getXImportDeclaration_ImportedNamespace();
	EDataType getIJvmTypeReferenceProvider();
	XtypeFactory getXtypeFactory();
	interface Literals{
		EClass XFUNCTION_TYPE_REF = eINSTANCE.getXFunctionTypeRef();
		EReference XFUNCTION_TYPE_REF__PARAM_TYPES = eINSTANCE.getXFunctionTypeRef_ParamTypes();
		EReference XFUNCTION_TYPE_REF__RETURN_TYPE = eINSTANCE.getXFunctionTypeRef_ReturnType();
		EReference XFUNCTION_TYPE_REF__TYPE = eINSTANCE.getXFunctionTypeRef_Type();
		EAttribute XFUNCTION_TYPE_REF__INSTANCE_CONTEXT = eINSTANCE.getXFunctionTypeRef_InstanceContext();
		EClass XCOMPUTED_TYPE_REFERENCE = eINSTANCE.getXComputedTypeReference();
		EAttribute XCOMPUTED_TYPE_REFERENCE__TYPE_PROVIDER = eINSTANCE.getXComputedTypeReference_TypeProvider();
		EClass XIMPORT_SECTION = eINSTANCE.getXImportSection();
		EReference XIMPORT_SECTION__IMPORT_DECLARATIONS = eINSTANCE.getXImportSection_ImportDeclarations();
		EClass XIMPORT_DECLARATION = eINSTANCE.getXImportDeclaration();
		EAttribute XIMPORT_DECLARATION__WILDCARD = eINSTANCE.getXImportDeclaration_Wildcard();
		EAttribute XIMPORT_DECLARATION__EXTENSION = eINSTANCE.getXImportDeclaration_Extension();
		EAttribute XIMPORT_DECLARATION__STATIC = eINSTANCE.getXImportDeclaration_Static();
		EReference XIMPORT_DECLARATION__IMPORTED_TYPE = eINSTANCE.getXImportDeclaration_ImportedType();
		EAttribute XIMPORT_DECLARATION__MEMBER_NAME = eINSTANCE.getXImportDeclaration_MemberName();
		EAttribute XIMPORT_DECLARATION__IMPORTED_NAMESPACE = eINSTANCE.getXImportDeclaration_ImportedNamespace();
		EDataType IJVM_TYPE_REFERENCE_PROVIDER = eINSTANCE.getIJvmTypeReferenceProvider();
	}
}",1,1,0,0
"protected ModelAndView handle(HttpServletRequest req, HttpServletResponse res, Object comm, BindException errors) throws Exception {
	BrowseCommand command = (BrowseCommand) comm;
	String base = req.getContextPath() + req.getServletPath();
	String line = req.getRequestURI().substring(base.length());
	Matcher matcher = p.matcher(line);
	if(matcher.matches()) {
		command.setHrOid(Long.parseLong(matcher.group(1)));
		command.setResource(matcher.group(2));
	}
	if(req.getQueryString() != null) {
		command.setResource(command.getResource() + ""?"" + req.getQueryString());
	}
	if( command.getResource().startsWith(""/"")) {
		command.setResource(command.getResource().substring(1));
	}
	Pattern urlBreakerPattern = Pattern.compile(""(.*?):Matcher urlBreakerMatcher = urlBreakerPattern.matcher(command.getResource());
	if(urlBreakerMatcher.matches()) {
		 command.setResource(urlBreakerMatcher.group(1) + "":urlBreakerMatcher.group(2).toLowerCase() + ""/"" + urlBreakerMatcher.group(3));
	}
	HarvestResourceDTO dto = qualityReviewFacade.getHarvestResourceDTO(command.getHrOid(), command.getResource());
	if( dto == null) {
		log.debug(""Resource not found: "" + command.getResource());
		return new ModelAndView(""browse-tool-not-found"", ""resourceName"", command.getResource());
	}
	else {
		Header[] headers = qualityReviewFacade.getHttpHeaders(dto);
		if(dto.getStatusCode() == HttpServletResponse.SC_MOVED_TEMPORARILY || dto.getStatusCode() == HttpServletResponse.SC_MOVED_PERMANENTLY) {
			 res.setStatus(dto.getStatusCode());
			String location = getHeaderValue(headers, ""Location"");
			if(location!=null) {
				 String newUrl = browseHelper.convertUrl(command.getHrOid(), command.getResource(), location);
				res.setHeader(""Location"", newUrl);
			}
		}
		String realContentType = getHeaderValue(headers, ""Content-Type"");
		String simpleContentType = this.getSimpleContentType(realContentType);
		String charset = null;
		if(realContentType != null) {
			 Matcher charsetMatcher = CHARSET_PATTERN.matcher(realContentType);
			if(charsetMatcher.find()) {
				 charset = charsetMatcher.group(1);
				log.info(""Desired charset: "" + charset + "" for "" + command.getResource());
			}
			else {
				log.info(""No charset: "" + charset + "" ("" + command.getResource());
			}
		}
		if(browseHelper.isReplaceable(simpleContentType)) {
			StringBuilder content = readFile(dto, charset);
			String baseUrl = command.getResource();
			Pattern baseUrlGetter = BrowseHelper.getTagMagixPattern(""BASE"", ""HREF"");
			Matcher m = baseUrlGetter.matcher(content);
			if(m.find()) {
				String u = m.group(1);
				if(u.startsWith(""\"""") && u.endsWith(""\"""") || u.startsWith(""'"") && u.endsWith(""'"")) {
					int lastEndComment = content.lastIndexOf(""-->"", m.start());
					int lastStartComment = content.lastIndexOf(""<!--"", m.start());
					if(lastStartComment < 0 || lastEndComment > lastStartComment) {
						 baseUrl = u.substring(1, u.length()-1);
					}
				}
			}
			browseHelper.fix(content, simpleContentType, command.getHrOid(), baseUrl);
			ModelAndView mav = new ModelAndView(""browse-tool-html"");
			mav.addObject(""content"", content.toString());
			mav.addObject(""Content-Type"", realContentType);
			return mav;
		}
		else {
			if(dto.getLength() > MAX_MEMORY_SIZE) {
				Date dt = new Date();
				File f = qualityReviewFacade.getResource(dto);
				ModelAndView mav = new ModelAndView(""browse-tool-other"");
				mav.addObject(""file"", f);
				mav.addObject(""contentType"", realContentType);
				log.info(""TIME TO GET RESOURCE(old): "" + (new Date().getTime() - dt.getTime()));
				return mav;
			}
			else {
				Date dt = new Date();
				byte[] bytesBuffer = qualityReviewFacade.getSmallResource(dto);
				ModelAndView mav = new ModelAndView(""browse-tool-other-small"");
				mav.addObject(""bytesBuffer"", bytesBuffer);
				mav.addObject(""contentType"", realContentType);
				log.info(""TIME TO GET RESOURCE(new): "" + (new Date().getTime() - dt.getTime()));
				return mav;
			}
		}
	}
}",0,0,1,0
"public interface Type {
	 String getName();
}",0,1,0,0
"public class Rpm extends Task {
	 private static final String PATH1 = ""PATH"";
	 private static final String PATH2 = ""Path"";
	 private static final String PATH3 = ""path"";
	 private String specFile;
	 private File topDir;
	 private String command = ""-bb"";
	 private String rpmBuildCommand = null;
	 private boolean cleanBuildDir = false;
	 private boolean removeSpec = false;
	 private boolean removeSource = false;
	 private File output;
	 private File error;
	 private boolean failOnError = false;
	 private boolean quiet = false;
	 public void execute() throws BuildException {
		 Commandline toExecute = new Commandline();
		 toExecute.setExecutable(rpmBuildCommand == null ? guessRpmBuildCommand() : rpmBuildCommand);
		 if (topDir != null) {
			 toExecute.createArgument().setValue(""--define"");
			 toExecute.createArgument().setValue(""_topdir "" + topDir);
		 }
		 toExecute.createArgument().setLine(command);
		 if (cleanBuildDir) {
			 toExecute.createArgument().setValue(""--clean"");
		 }
		 if (removeSpec) {
			 toExecute.createArgument().setValue(""--rmspec"");
		 }
		 if (removeSource) {
			 toExecute.createArgument().setValue(""--rmsource"");
		 }
		 toExecute.createArgument().setValue(""SPECS/"" + specFile);
		 ExecuteStreamHandler streamhandler = null;
		 OutputStream outputstream = null;
		 OutputStream errorstream = null;
		 if (error == null && output == null) {
			 if (!quiet) {
				 streamhandler = new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN);
			 }
			 else {
				 streamhandler = new LogStreamHandler(this, Project.MSG_DEBUG, Project.MSG_DEBUG);
			 }
		 }
		 else {
			 if (output != null) {
				 try {
					 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(output));
					 outputstream = new PrintStream(bos);
				 }
				 catch (IOException e) {
					 throw new BuildException(e, getLocation());
				 }
			 }
			 else if (!quiet) {
				 outputstream = new LogOutputStream(this, Project.MSG_INFO);
			 }
			 else {
				 outputstream = new LogOutputStream(this, Project.MSG_DEBUG);
			 }
			 if (error != null) {
				 try {
					 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(error));
					 errorstream = new PrintStream(bos);
				 }
				 catch (IOException e) {
					 throw new BuildException(e, getLocation());
				 }
			 }
			 else if (!quiet) {
				 errorstream = new LogOutputStream(this, Project.MSG_WARN);
			 }
			 else {
				 errorstream = new LogOutputStream(this, Project.MSG_DEBUG);
			 }
			 streamhandler = new PumpStreamHandler(outputstream, errorstream);
		 }
		 Execute exe = getExecute(toExecute, streamhandler);
		 try {
			 log(""Building the RPM based on the "" + specFile + "" file"");
			 int returncode = exe.execute();
			 if (Execute.isFailure(returncode)) {
				 String msg = ""'"" + toExecute.getExecutable() + ""' failed with exit code "" + returncode;
				 if (failOnError) {
					 throw new BuildException(msg);
				 }
				 log(msg, Project.MSG_ERR);
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(e, getLocation());
		 }
		 finally {
			 FileUtils.close(outputstream);
			 FileUtils.close(errorstream);
		 }
	 }
	 public void setTopDir(File td) {
		 this.topDir = td;
	 }
	 public void setCommand(String c) {
		 this.command = c;
	 }
	 public void setSpecFile(String sf) {
		 if ((sf == null) || (sf.trim().length() == 0)) {
			 throw new BuildException(""You must specify a spec file"", getLocation());
		 }
		 this.specFile = sf;
	 }
	 public void setCleanBuildDir(boolean cbd) {
		 cleanBuildDir = cbd;
	 }
	 public void setRemoveSpec(boolean rs) {
		 removeSpec = rs;
	 }
	 public void setRemoveSource(boolean rs) {
		 removeSource = rs;
	 }
	 public void setOutput(File output) {
		 this.output = output;
	 }
	 public void setError(File error) {
		 this.error = error;
	 }
	 public void setRpmBuildCommand(String c) {
		 this.rpmBuildCommand = c;
	 }
	 public void setFailOnError(boolean value) {
		 failOnError = value;
	 }
	 public void setQuiet(boolean value) {
		 quiet = value;
	 }
	 protected String guessRpmBuildCommand() {
		 Map env = Execute.getEnvironmentVariables();
		 String path = (String) env.get(PATH1);
		 if (path == null) {
			 path = (String) env.get(PATH2);
			 if (path == null) {
				 path = (String) env.get(PATH3);
			 }
		 }
		 if (path != null) {
			 Path p = new Path(getProject(), path);
			 String[] pElements = p.list();
			 for (int i = 0;
			 i < pElements.length;
			 i++) {
				 File f = new File(pElements[i], ""rpmbuild"" + (Os.isFamily(""dos"") ? "".exe"" : """"));
				 if (f.canRead()) {
					 return f.getAbsolutePath();
				 }
			 }
		 }
		 return ""rpm"";
	 }
	 protected Execute getExecute(Commandline toExecute, ExecuteStreamHandler streamhandler) {
		 Execute exe = new Execute(streamhandler, null);
		 exe.setAntRun(getProject());
		 if (topDir == null) {
			 topDir = getProject().getBaseDir();
		 }
		 exe.setWorkingDirectory(topDir);
		 exe.setCommandline(toExecute.getCommandline());
		 return exe;
	 }
}",0,0,0,0
"public class AssemblerConfig {
	 private File portletDescriptor;
	 private File webappDescriptor;
	 private File destination;
	 private String dispatchServletClass;
	 private File source;
	 private int assemblerSinkBuflen = 1024 * 4;
	 public File getPortletDescriptor() {
		 return portletDescriptor;
	 }
	 public void setPortletDescriptor(File portletDescriptor) {
		 this.portletDescriptor = portletDescriptor;
	 }
	 public File getWebappDescriptor() {
		 return webappDescriptor;
	 }
	 public void setWebappDescriptor(File webappDescriptor) {
		 this.webappDescriptor = webappDescriptor;
	 }
	 public File getDestination() {
		 return destination;
	 }
	 public void setDestination(File destination) {
		 this.destination = destination;
	 }
	 public String getDispatchServletClass() {
		 return dispatchServletClass;
	 }
	 public void setDispatchServletClass(String dispatchServletClass) {
		 this.dispatchServletClass = dispatchServletClass;
	 }
	 public void setWarSource(File source) {
		 this.source = source;
	 }
	 public void setSource(File source) {
		 this.source = source;
	 }
	 public File getWarSource() {
		 return source;
	 }
	 public File getSource() {
		 return source;
	 }
	 public int getAssemblerSinkBuflen() {
		 return assemblerSinkBuflen;
	 }
	 public void setAssemblerSinkBuflen(int buflen) {
		 this.assemblerSinkBuflen = buflen;
	 }
}",0,1,0,0
"public ByteBuffer fromString(String source) throws MarshalException {
	 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
	 Double d;
	 try {
		 d = Double.parseDouble(source);
	 }
	 catch (NumberFormatException e1) {
		 throw new MarshalException(String.format(""unable to coerce '%s' to a double"", source), e1);
	 }
	 return decompose(d);
 }",0,0,0,0
"public class TestTezCompiler {
	 private static PigContext pc;
	 private static PigServer pigServer;
	 private static final int MAX_SIZE = 100000;
	 private boolean generate = false;
	 public static void setUpBeforeClass() throws Exception {
		 resetFileLocalizer();
		 pc = new PigContext(new TezLocalExecType(), new Properties());
		 FileUtils.deleteDirectory(new File(""/tmp/pigoutput""));
	 }
	 public static void tearDownAfterClass() throws Exception {
		 resetFileLocalizer();
	 }
	 public void setUp() throws ExecException {
		 resetScope();
		 pc.getProperties().remove(PigConfiguration.PIG_OPT_MULTIQUERY);
		 pc.getProperties().remove(PigConfiguration.PIG_TEZ_OPT_UNION);
		 pc.getProperties().remove(PigConfiguration.PIG_EXEC_NO_SECONDARY_KEY);
		 pc.getProperties().remove(PigConfiguration.PIG_BLOOMJOIN_STRATEGY);
		 pigServer = new PigServer(pc);
	 }
	 private void resetScope() {
		 NodeIdGenerator.reset();
		 PigServer.resetScope();
		 TezPlanContainer.resetScope();
	 }
	 private static void resetFileLocalizer() {
		 FileLocalizer.deleteTempFiles();
		 FileLocalizer.setInitialized(false);
		 FileLocalizer.setR(new Random(1331L));
	 }
	 public void testStoreLoad() throws Exception {
		 String query = ""a = load 'file: ""store a into 'file: ""b = load 'file: ""store b into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-1.gld"");
	 }
	 public void testStoreLoadMultiple() throws Exception {
		 String query = ""a = load 'file: ""store a into 'file: ""a = load 'file: ""store a into 'file: ""a = load 'file: ""store a into 'file: ""a = load 'file: ""store a into 'file: ""a = load 'file: ""b = load 'file: ""c = load 'file: ""d = cogroup a by $0, b by $0, c by $0;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-2.gld"");
	 }
	 public void testStoreLoadJoinMultiple() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by $0 == 1;
		"" + ""c = filter a by $0 == 2;
		"" + ""store b into 'file: ""store c into 'file: ""d = load 'file: ""e = load 'file: ""f = join d by $0, e by $0;
		"" + ""store f into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-3.gld"");
		 resetScope();
		 query = ""a = load 'file: ""b = distinct a;
		"" + ""c = group a by $0;
		"" + ""store b into 'file: ""store c into 'file: ""d = load 'file: ""e = load 'file: ""f = load 'file: ""g = join d by $0, f by $0 using 'repl';
		"" + ""h = join e by $0, f by $0 using 'repl';
		"" + ""store g into 'file: ""store h into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-4.gld"");
	 }
	 public void testStoreLoadSplit() throws Exception {
		 resetFileLocalizer();
		 String query = ""a = load 'file: ""a1 = filter a by $0 == 5;
		"" + ""store a1 into 'file: ""b = load 'file: ""c = join a by $0, b by $0;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-5.gld"");
		 query = ""a = load 'file: ""a = distinct a;
		"" + ""store a into 'file: ""b = load 'file: ""c = join a by $0, b by $0;
		"" + ""store c into 'file: resetScope();
		 resetFileLocalizer();
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-6.gld"");
		 query = ""a = load 'file: ""store a into 'file: ""a1 = filter a by $0 == 5;
		"" + ""store a1 into 'file: ""a2 = distinct a1;
		"" + ""store a2 into 'file: ""a3 = group a2 by $0;
		"" + ""store a3 into 'file: ""b = load 'file: ""c = join a1 by $0, b by $0;
		"" + ""store c into 'file: resetScope();
		 resetFileLocalizer();
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-LoadStore-7.gld"");
	 }
	 public void testNative() throws Exception {
		 String query = ""a = load 'file: ""b = native 'hadoop-examples.jar' Store a into '/tmp/table_testNativeMRJobSimple_input' Load '/tmp/table_testNativeMRJobSimple_output' `wordcount /tmp/table_testNativeMRJobSimple_input /tmp/table_testNativeMRJobSimple_output`;
		"" + ""store b into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Native-1.gld"");
	 }
	 public void testFilter() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x > 0;
		"" + ""c = foreach b generate y;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Filter-1.gld"");
	 }
	 public void testGroupBy() throws Exception {
		 String query = ""a = load 'file: ""b = group a by x;
		"" + ""c = foreach b generate group, COUNT(a.x);
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Group-1.gld"");
	 }
	 public void testJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = join a by x, b by x;
		"" + ""d = foreach c generate a::x as x, y, z;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Join-1.gld"");
	 }
	 public void testMergeJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = join a by x, b by x using 'merge';
		"" + ""d = foreach c generate a::x as x, y, z;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MergeJoin-1.gld"");
	 }
	 public void testMergeCogroup() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = cogroup a by x, b by x using 'merge';
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MergeCogroup-1.gld"");
	 }
	 public void testBloomJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""d = join b by x, a by x, c by x using 'bloom';
		"" + ""e = foreach d generate a::x as x, y, z, w;
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-1.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-1-KeyToReducer.gld"");
	 }
	 public void testBloomJoinLeftOuter() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""d = join a by x left, b by x using 'bloom';
		"" + ""e = foreach d generate a::x as x, y, z;
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-2.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-2-KeyToReducer.gld"");
	 }
	 public void testBloomJoinUnion() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""b = union b, c;
		"" + ""d = join a by x, b by x using 'bloom';
		"" + ""e = foreach d generate a::x as x, y, z;
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-3.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-3-KeyToReducer.gld"");
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, null);
		 resetScope();
		 query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""b = union b, c;
		"" + ""d = join b by x, a by x using 'bloom';
		"" + ""e = foreach d generate a::x as x, y, z;
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-4.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-4-KeyToReducer.gld"");
	 }
	 public void testBloomJoinSplit() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""a1 = filter a by x == 3;
		"" + ""a2 = filter a by x == 4;
		"" + ""d = join a1 by x, a2 by x, b by x using 'bloom';
		"" + ""e = foreach d generate a1::x as x, a1::y as y1, a2::y as y2, z;
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-5.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-5-KeyToReducer.gld"");
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, null);
		 resetScope();
		 query = ""a = load 'file: ""b = load 'file: ""a1 = filter a by x == 3;
		"" + ""a2 = filter a by x == 4;
		"" + ""d = join b by x, a1 by x using 'bloom';
		"" + ""e = foreach d generate a1::x as x, y, z;
		"" + ""store a2 into 'file: ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-6.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-6-KeyToReducer.gld"");
	 }
	 public void testBloomSelfJoin() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x < 5;
		"" + ""c = filter a by x == 10;
		"" + ""d = filter a by x > 10;
		"" + ""e = join b by x, c by x, d by x using 'bloom';
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-7.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_BLOOMJOIN_STRATEGY, ""reduce"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-BloomJoin-7-KeyToReducer.gld"");
	 }
	 public void testSelfJoin() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x < 5;
		"" + ""c = filter a by x == 10;
		"" + ""d = filter a by x > 10;
		"" + ""e = join b by x, c by x, d by x;
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SelfJoin-1.gld"");
	 }
	 public void testSelfJoinSkewed() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x < 5;
		"" + ""c = filter a by x == 10;
		"" + ""d = join b by x, c by x using 'skewed';
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SelfJoin-2.gld"");
	 }
	 public void testSelfJoinReplicated() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x < 5;
		"" + ""c = filter a by x == 10;
		"" + ""d = filter a by x > 10;
		"" + ""e = join b by x, c by x, d by x using 'replicated';
		"" + ""store e into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SelfJoin-3.gld"");
	 }
	 public void testSelfJoinUnionReplicated() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union a, b;
		"" + ""d = join b by x, c by x using 'replicated';
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SelfJoin-4.gld"");
	 }
	 public void testSelfJoinUnion() throws Exception {
		 String query = ""a = load 'file: ""a1 = filter a by x > 5;
		"" + ""a2 = filter a by x < 2;
		"" + ""b = union a1, a2;
		"" + ""c = join b by x, a by x;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SelfJoin-5.gld"");
	 }
	 public void testSelfJoinUnionDifferentMembers() throws Exception {
		 String query = ""a = load 'file: ""a1 = filter a by x > 5;
		"" + ""a2 = filter a by x < 2;
		"" + ""a3 = filter a by y == 10;
		"" + ""a4 = join a2 by x, a3 by x;
		"" + ""a5 = foreach a4 generate a2::x as x, a3::y as y;
		"" + ""b = union a1, a5;
		"" + ""c = join b by x, a by x;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SelfJoin-6.gld"");
	 }
	 public void testCross() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = cross a, b;
		"" + ""d = foreach c generate a::x as x, y, z;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Cross-1.gld"");
	 }
	 public void testSelfCross() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x < 5;
		"" + ""c = filter a by x == 10;
		"" + ""d = cross b, c;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Cross-2.gld"");
	 }
	 public void testCrossScalarSplit() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = cross b, a;
		"" + ""d = foreach c generate a.x, a.y, z;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Cross-3.gld"");
	 }
	 public void testSkewedJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = join a by x, b by x using 'skewed';
		"" + ""d = foreach c generate a::x as x, y, z;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SkewJoin-1.gld"");
	 }
	 public void testSkewedJoinFilter() throws Exception {
		 String query = ""a = load 'file: ""a = filter a by x == 1;
		"" + ""b = load 'file: ""c = join a by x, b by x using 'skewed';
		"" + ""d = foreach c generate a::x as x, y, z;
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SkewJoin-2.gld"");
	 }
	 public void testLimit() throws Exception {
		 String query = ""a = load 'file: ""b = limit a 10;
		"" + ""c = foreach b generate y;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Limit-1.gld"");
	 }
	 public void testLimitOrderby() throws Exception {
		 String query = ""a = load 'file: ""b = order a by x, y;
		"" + ""c = limit b 10;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Limit-2.gld"");
	 }
	 public void testLimitScalarOrderby() throws Exception {
		 String query = ""a = load 'file: ""b = order a by x, y;
		"" + ""g = group a all;
		"" + ""h = foreach g generate COUNT(a) as sum;
		"" + ""c = limit b h.sum/2;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Limit-3.gld"");
	 }
	 public void testLimitReplJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = limit a 1;
		"" + ""d = join c by x, b by x using 'replicated';
		"" + ""store a into 'file: ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Limit-4.gld"");
	 }
	 public void testDistinct() throws Exception {
		 String query = ""a = load 'file: ""b = distinct a;
		"" + ""c = foreach b generate y;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Distinct-1.gld"");
	 }
	 public void testDistinctAlgebraicUdfCombiner() throws Exception {
		 String query = ""a = load 'file: ""b = group a by x;
		"" + ""c = foreach b {
			 d = distinct a;
			 generate COUNT(d);
		 }
		;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Distinct-2.gld"");
	 }
	 public void testReplicatedJoinInMapper() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""d = join a by x, b by x, c by x using 'replicated';
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-FRJoin-1.gld"");
	 }
	 public void testReplicatedJoinInReducer() throws Exception {
		 String query = ""a = load 'file: ""b = group a by x;
		"" + ""b1 = foreach b generate group, COUNT(a.y);
		"" + ""c = load 'file: ""d = join b1 by group, c by x using 'replicated';
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-FRJoin-2.gld"");
	 }
	 public void testStream() throws Exception {
		 String query = ""a = load 'file: ""b = stream a through `stream.pl -n 5`;
		"" + ""STORE b INTO 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Stream-1.gld"");
	 }
	 public void testSecondaryKeySort() throws Exception {
		 String query = ""a = load 'file: ""b = group a by $0;
		"" + ""c = foreach b {
			 d = limit a 10;
			 e = order d by $1;
			 f = order e by $0;
			 generate group, f;
		}
		;
		""+ ""store c INTO 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SecKeySort-1.gld"");
		 setProperty(PigConfiguration.PIG_EXEC_NO_SECONDARY_KEY, ""true"");
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-SecKeySort-2.gld"");
	 }
	 public void testOrderBy() throws Exception {
		 String query = ""a = load 'file: ""b = order a by x;
		"" + ""STORE b INTO 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Order-1.gld"");
	 }
	 public void testOrderByWithFilter() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x == 1;
		"" + ""c = order b by x;
		"" + ""STORE c INTO 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Order-2.gld"");
	 }
	 public void testOrderByReadOnceLoadFunc() throws Exception {
		 setProperty(""pig.sort.readonce.loadfuncs"",""org.apache.pig.backend.hadoop.hbase.HBaseStorage,org.apache.pig.backend.hadoop.accumulo.AccumuloStorage"");
		 String query = ""a = load 'file: ""b = order a by x;
		"" + ""STORE b INTO 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Order-3.gld"");
		 setProperty(""pig.sort.readonce.loadfuncs"", null);
	 }
	 public void testCogroupWithAlgebraiceUDF() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = cogroup a by x, b by x;
		"" + ""d = foreach c generate group, COUNT(a.y), COUNT(b.z);
		"" + ""store d into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Cogroup-1.gld"");
	 }
	 public void testMulitQueryWithSplitSingleVertex() throws Exception {
		 String query = ""a = load 'file: ""split a into b if x <= 5, c if x <= 10, d if x >10;
		"" + ""store b into 'file: ""store c into 'file: ""store d into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-1.gld"");
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-1-OPTOFF.gld"");
	 }
	 public void testMulitQueryWithSplitMultiVertex() throws Exception {
		 String query = ""a = load 'file: ""split a into b if x <= 5, c if x <= 10, d if x >10;
		"" + ""split b into e if x < 3, f if x >= 3;
		"" + ""b1 = group b by x;
		"" + ""b2 = foreach b1 generate group, SUM(b.x);
		"" + ""c1 = join c by x, b by x;
		"" + ""c2 = group c by x;
		"" + ""c3 = foreach c2 generate group, SUM(c.x);
		"" + ""d1 = filter d by x == 5;
		"" + ""e1 = order e by x;
		"" + ""f1 = limit f 1;
		"" + ""f2 = union d1, f1;
		"" + ""store b1 into 'file: ""store b2 into 'file: ""store c1 into 'file: ""store c3 into 'file: ""store d1 into 'file: ""store e1 into 'file: ""store f1 into 'file: ""store f2 into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-2.gld"");
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-2-OPTOFF.gld"");
	 }
	 public void testMultiQueryWithGroupBy() throws Exception {
		 String query = ""a = load 'file: ""b = group a by x;
		"" + ""b = foreach b generate group, COUNT(a.x);
		"" + ""c = group a by (x,y);
		"" + ""c = foreach c generate group, COUNT(a.y);
		"" + ""store b into 'file: ""store c into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-3.gld"");
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-3-OPTOFF.gld"");
	 }
	 public void testMultiQueryWithJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = join a by x, b by x;
		"" + ""d = foreach c generate $0, $1, $3;
		"" + ""e = foreach c generate $0, $1, $2, $3;
		"" + ""store c into 'file: ""store d into 'file: ""store e into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-4.gld"");
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-4-OPTOFF.gld"");
	 }
	 public void testMultiQueryWithNestedSplit() throws Exception {
		 String query = ""a = load 'file: ""b = group a by x;
		"" + ""store b into 'file: ""c = foreach b generate a.x, a.y;
		"" + ""store c into 'file: ""d = foreach b GENERATE FLATTEN(a);
		"" + ""store d into 'file: ""e = foreach d GENERATE a::x, a::y;
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-5.gld"");
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-5-OPTOFF.gld"");
	 }
	 public void testMultiQueryScalar() throws Exception {
		 String query = ""a = load 'file: ""b = group a by x;
		"" + ""c = foreach b generate group, COUNT(a) as cnt;
		"" + ""SPLIT a into d if (2 * c.cnt) < y, e OTHERWISE;
		"" + ""store d into 'file: ""store e into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-6.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-6-OPTOFF.gld"");
	 }
	 public void testMultiQueryMultipleReplicateJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = join a by $0, b by $0 using 'replicated';
		"" + ""d = join a by $1, b by $1 using 'replicated';
		"" + ""e = union c,d;
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-7.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-7-OPTOFF.gld"");
	 }
	 public void testMultiQueryMultipleScalar() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x == 5;
		"" + ""b = foreach b generate $0 as b1;
		"" + ""c = filter a by x == 10;
		"" + ""c = foreach c generate $0 as c1;
		"" + ""d = group a by x;
		"" + ""e = foreach d generate group, b.b1, c.c1;
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-8.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-8-OPTOFF.gld"");
	 }
	 public void testMultiQueryMultipleReplicateJoinWithUnion() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""d = union a, b;
		"" + ""e = filter c by y < 2;
		"" + ""f = filter c by y > 5;
		"" + ""g = join d by x, e by x using 'replicated';
		"" + ""h = join g by d::x, f by x using 'replicated';
		"" + ""store h into 'file: setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-9.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-9-OPTOFF.gld"");
		 query = ""a = load 'file: ""b = filter a by x == 2;
		"" + ""c = load 'file: ""d = union a, b;
		"" + ""e = filter c by y < 2;
		"" + ""f = filter c by y > 5;
		"" + ""g = join d by x, e by x using 'replicated';
		"" + ""h = join g by d::x, f by x using 'replicated';
		"" + ""store h into 'file: resetScope();
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-10.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_OPT_MULTIQUERY, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-MQ-10-OPTOFF.gld"");
	 }
	 public void testUnionStore() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""store c into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-OPTOFF.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b PARALLEL 15;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-OPTOFF.gld"");
	 }
	 public void testUnionIncludeExcludeStoreFunc() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""store c into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 String oldSupported = getProperty(PigConfiguration.PIG_TEZ_OPT_UNION_SUPPORTED_STOREFUNCS);
		 String oldUnSupported = getProperty(PigConfiguration.PIG_TEZ_OPT_UNION_UNSUPPORTED_STOREFUNCS);
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_UNSUPPORTED_STOREFUNCS, PigStorage.class.getName());
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-OPTOFF.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_UNSUPPORTED_STOREFUNCS, null);
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_SUPPORTED_STOREFUNCS, OrcStorage.class.getName());
		 query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""store c into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-DummyStore-OPTOFF.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_SUPPORTED_STOREFUNCS, null);
		 query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""store c into 'file: TestDummyStoreFuncParallelWriteDisabled.class.getName() + ""();
		"";
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-DummyStore2-OPTOFF.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_SUPPORTED_STOREFUNCS, null);
		 query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""store c into 'file: TestDummyStoreFuncParallelWriteEnabled.class.getName() + ""();
		"";
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-DummyStore3.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_UNSUPPORTED_STOREFUNCS, PigStorage.class.getName());
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_SUPPORTED_STOREFUNCS, null);
		 query = ""a = load 'file: ""split a into b if x > 5, c if x == 7, d if x == 8, e otherwise;
		"" + ""u1 = union onschema b, c;
		"" + ""store u1 into 'file: ""u2 = union onschema a, b, c;
		"" + ""store u2 into 'file: ""u3 = union onschema d, e;
		"" + ""store u3 into 'file: ""j1 = join d by x, a by x using 'replicated';
		"" + ""j1 = foreach j1 generate d::x as x, d::y as y;
		"" + ""u4 = union onschema j1, a;
		"" + ""store u4 into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-1-SplitStore.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_SUPPORTED_STOREFUNCS, oldSupported);
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION_UNSUPPORTED_STOREFUNCS, oldUnSupported);
	 }
	 public void testUnionGroupBy() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = group c by x;
		"" + ""e = foreach d generate group, SUM(c.y);
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-2.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-2-OPTOFF.gld"");
	 }
	 public void testUnionJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join c by x, d by x;
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-3.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-3-OPTOFF.gld"");
	 }
	 public void testUnionReplicateJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join c by x, d by x using 'replicated';
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-4.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-4-OPTOFF.gld"");
		 query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join d by x, c by x using 'replicated';
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-5.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-5-OPTOFF.gld"");
	 }
	 public void testUnionSkewedJoin() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join c by x, d by x using 'skewed';
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-6.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-6-OPTOFF.gld"");
	 }
	 public void testUnionOrderby() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = order c by x;
		"" + ""store d into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-7.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-7-OPTOFF.gld"");
	 }
	 public void testUnionLimit() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = limit c 1;
		"" + ""store d into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-8.gld"");
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-8-OPTOFF.gld"");
	 }
	 public void testUnionSplit() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""split a into a1 if x > 100, a2 otherwise;
		"" + ""c = union onschema a1, a2, b;
		"" + ""split c into d if x > 500, e otherwise;
		"" + ""store a2 into 'file: ""store d into 'file: ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-9.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-9-OPTOFF.gld"");
	 }
	 public void testUnionUnion() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = union onschema c, d;
		"" + ""f = group e by x;
		"" + ""store e into 'file: ""store f into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-10.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-10-OPTOFF.gld"");
	 }
	 public void testUnionUnionStore() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = union onschema c, d;
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-11.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-11-OPTOFF.gld"");
	 }
	 public void testMultipleUnionSplitJoin() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x == 2;
		"" + ""b1 = foreach b generate *;
		"" + ""b2 = foreach b generate *;
		"" + ""b3 = union onschema b1, b2;
		"" + ""c = filter a by x == 3;
		"" + ""c1 = foreach c generate y, x;
		"" + ""c2 = foreach c generate y, x;
		"" + ""c3 = union c1, c2;
		"" + ""a1 = union onschema b3, c3;
		"" + ""store a1 into 'file: ""d = load 'file: ""e = join a1 by x, d by x using 'skewed';
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-12.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-12-OPTOFF.gld"");
	 }
	 public void testUnionSplitReplicateJoin() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x == 2;
		"" + ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join c by x, d by x using 'replicated';
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-13.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-13-OPTOFF.gld"");
		 query = ""a = load 'file: ""b = filter a by x == 2;
		"" + ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join d by x, c by x using 'replicated';
		"" + ""store e into 'file: resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-14.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-14-OPTOFF.gld"");
	 }
	 public void testUnionSplitSkewedJoin() throws Exception {
		 String query = ""a = load 'file: ""b = filter a by x == 2;
		"" + ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join c by x, d by x using 'skewed';
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-15.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-15-OPTOFF.gld"");
		 query = ""a = load 'file: ""b = filter a by x == 2;
		"" + ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = join d by x, c by x using 'skewed';
		"" + ""store e into 'file: resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-16.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-16-OPTOFF.gld"");
	 }
	 public void testUnionScalar() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = filter c by x == d.x;
		"" + ""store e into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-17.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-17-OPTOFF.gld"");
		 query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""d = load 'file: ""e = filter d by x == c.x;
		"" + ""store e into 'file: resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-18.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-18-OPTOFF.gld"");
	 }
	 public void testUnionSplitUnionStore() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = union onschema a, b;
		"" + ""split c into d if x <= 5, e if x <= 10, f if x >10, g if y == '6';
		"" + ""h = union onschema d, e;
		"" + ""i = union onschema f, g;
		"" + ""store h into 'file: ""store i into 'file: resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-19.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-19-OPTOFF.gld"");
		 query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""u1 = union onschema a, b;
		"" + ""SPLIT u1 INTO r IF x != '', s OTHERWISE;
		"" + ""d = JOIN r BY x LEFT, c BY y;
		"" + ""u2 = UNION ONSCHEMA d, s;
		"" + ""e = FILTER u2 BY x == '';
		"" + ""f = FILTER u2 BY x == 'm';
		"" + ""u3 = UNION ONSCHEMA e, f;
		"" + ""store u3 into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-20.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-20-OPTOFF.gld"");
	 }
	 public void testUnionSplitUnionLimitStore() throws Exception {
		 String query = ""a = load 'file: ""b = load 'file: ""c = load 'file: ""u1 = union onschema a, b;
		"" + ""SPLIT u1 INTO r IF x != '', s OTHERWISE;
		"" + ""d = JOIN r BY x LEFT, c BY y;
		"" + ""u2 = UNION ONSCHEMA d, s;
		"" + ""e = FILTER u2 BY x == '';
		"" + ""f = FILTER u2 BY x == 'm';
		"" + ""u3 = UNION ONSCHEMA e, f;
		"" + ""SPLIT u3 INTO t if x != '', u OTHERWISE;
		"" + ""v = LIMIT t 10;
		"" + ""store v into 'file: setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + true);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-21.gld"");
		 resetScope();
		 setProperty(PigConfiguration.PIG_TEZ_OPT_UNION, """" + false);
		 run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-21-OPTOFF.gld"");
	 }
	 public void testRank() throws Exception {
		 String query = ""a = load 'file: ""b = rank a;
		"" + ""store b into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Rank-1.gld"");
	 }
	 public void testRankBy() throws Exception {
		 String query = ""a = load 'file: ""b = rank a by x;
		"" + ""store b into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Rank-2.gld"");
	 }
	 public void testJoinUnionSingleMemberOverlappingPredecessor() throws Exception {
		 String query = ""A = load 'file: ""A1 = FILTER A by a1 > 10;
		"" + ""A2 = FILTER A by a2 > 10;
		"" + ""B = UNION A1, A2;
		"" + ""C = join A1 by a1, A2 by a1;
		"" + ""D = DISTINCT C;
		"" + ""Z = join B by a1, D by A1::a1 using 'replicated';
		 "" + ""store Z into 'file: run(query, ""test/org/apache/pig/test/data/GoldenFiles/tez/TEZC-Union-22.gld"");
	 }
	 private String getProperty(String property) {
		 return pigServer.getPigContext().getProperties().getProperty(property);
	 }
	 private void setProperty(String property, String value) {
		 if (value == null) {
			 pigServer.getPigContext().getProperties().remove(property);
		 }
		 else {
			 pigServer.getPigContext().getProperties().setProperty(property, value);
		 }
	 }
	 private void run(String query, String expectedFile) throws Exception {
		 PhysicalPlan pp = Util.buildPp(pigServer, query);
		 TezLauncher launcher = new TezLauncher();
		 pc.inExplain = true;
		 TezPlanContainer tezPlanContainer = launcher.compile(pp, pc);
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 PrintStream ps = new PrintStream(baos);
		 TezPlanContainerPrinter printer = new TezPlanContainerPrinter(ps, tezPlanContainer);
		 printer.visit();
		 String compiledPlan = baos.toString();
		 System.out.println();
		 System.out.println(""<<<"" + compiledPlan + "">>>"");
		 if (generate) {
			 FileOutputStream fos = new FileOutputStream(expectedFile);
			 fos.write(baos.toByteArray());
			 fos.close();
			 return;
		 }
		 FileInputStream fis = new FileInputStream(expectedFile);
		 byte[] b = new byte[MAX_SIZE];
		 int len = fis.read(b);
		 fis.close();
		 String goldenPlan = new String(b, 0, len);
		 if (goldenPlan.charAt(len-1) == '\n') {
			 goldenPlan = goldenPlan.substring(0, len-1);
		 }
		 System.out.println(""-------------"");
		 System.out.println(""Golden"");
		 System.out.println(""<<<"" + goldenPlan + "">>>"");
		 System.out.println(""-------------"");
		 String goldenPlanClean = Util.standardizeNewline(goldenPlan).trim();
		 String compiledPlanClean = Util.standardizeNewline(compiledPlan).trim();
		 assertEquals(TestHelper.sortUDFs(Util.removeSignature(goldenPlanClean)), TestHelper.sortUDFs(Util.removeSignature(compiledPlanClean)));
	 }
	 public static class TestDummyStoreFunc extends StoreFunc {
		 public OutputFormat getOutputFormat() throws IOException {
			 return null;
		 }
		 public void setStoreLocation(String location, Job job) throws IOException {
		 }
		 public void prepareToWrite(RecordWriter writer) throws IOException {
		 }
		 public void putNext(Tuple t) throws IOException {
		 }
	 }
	 public static class TestDummyStoreFuncParallelWriteEnabled extends TestDummyStoreFunc {
		 public Boolean supportsParallelWriteToStoreLocation() {
			 return true;
		 }
	 }
	 public static class TestDummyStoreFuncParallelWriteDisabled extends TestDummyStoreFunc {
		 public Boolean supportsParallelWriteToStoreLocation() {
			 return false;
		 }
	 }
}",1,0,0,0
"private final class FindInMethod extends MethodVisitor {
	 private final String name;
	 private final String desc;
	 private final int access;
	 private FindInAnno fia;
	 private boolean bodyGenerated;
	 public FindInMethod(int access, String name, String desc, MethodVisitor mv) {
		 super(Opcodes.ASM5, mv);
		 this.access = access;
		 this.name = name;
		 this.desc = desc;
	 }
	 public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
		 if (""Lnet/java/html/js/JavaScriptBody;
		"".equals(desc)) {
			 found++;
			 return new FindInAnno();
		 }
		 return super.visitAnnotation(desc, visible);
	 }
	 private void generateJSBody(FindInAnno fia) {
		 this.fia = fia;
	 }
	 public void visitCode() {
		 if (fia == null) {
			 return;
		 }
		 generateBody(true);
	 }
	 private boolean generateBody(boolean hasCode) {
		 if (bodyGenerated) {
			 return false;
		 }
		 bodyGenerated = true;
		 if (mv != null) {
			 AnnotationVisitor va = super.visitAnnotation(""Lnet/java/html/js/JavaScriptBody;
			"", false);
			 AnnotationVisitor varr = va.visitArray(""args"");
			 for (String argName : fia.args) {
				 varr.visit(null, argName);
			 }
			 varr.visitEnd();
			 va.visit(""javacall"", fia.javacall);
			 va.visit(""body"", fia.body);
			 va.visitEnd();
		 }
		 String body;
		 List<String> args;
		 if (fia.javacall) {
			 body = callback(fia.body);
			 args = new ArrayList<String>(fia.args);
			 args.add(""vm"");
		 }
		 else {
			 body = fia.body;
			 args = fia.args;
		 }
		 super.visitFieldInsn( Opcodes.GETSTATIC, FindInClass.this.name, ""$$fn$$"" + name + ""_"" + found, ""Lorg/netbeans/html/boot/spi/Fn;
		"" );
		 super.visitInsn(Opcodes.DUP);
		 super.visitMethodInsn( Opcodes.INVOKESTATIC, ""org/netbeans/html/boot/spi/Fn"", ""isValid"", ""(Lorg/netbeans/html/boot/spi/Fn;
		)Z"" );
		 Label ifNotNull = new Label();
		 super.visitJumpInsn(Opcodes.IFNE, ifNotNull);
		 super.visitInsn(Opcodes.POP);
		 super.visitLdcInsn(Type.getObjectType(FindInClass.this.name));
		 super.visitInsn(fia.keepAlive ? Opcodes.ICONST_1 : Opcodes.ICONST_0);
		 super.visitLdcInsn(body);
		 super.visitIntInsn(Opcodes.SIPUSH, args.size());
		 super.visitTypeInsn(Opcodes.ANEWARRAY, ""java/lang/String"");
		 boolean needsVM = false;
		 for (int i = 0;
		 i < args.size();
		 i++) {
			 assert !needsVM;
			 String argName = args.get(i);
			 needsVM = ""vm"".equals(argName);
			 super.visitInsn(Opcodes.DUP);
			 super.visitIntInsn(Opcodes.BIPUSH, i);
			 super.visitLdcInsn(argName);
			 super.visitInsn(Opcodes.AASTORE);
		 }
		 super.visitMethodInsn(Opcodes.INVOKESTATIC, ""org/netbeans/html/boot/spi/Fn"", ""define"", ""(Ljava/lang/Class;
		ZLjava/lang/String;
		[Ljava/lang/String;
		)Lorg/netbeans/html/boot/spi/Fn;
		"" );
		 Label noPresenter = new Label();
		 super.visitInsn(Opcodes.DUP);
		 super.visitJumpInsn(Opcodes.IFNULL, noPresenter);
		 int cnt = resourcesCnt;
		 while (cnt > 0) {
			 String resource = resources[--cnt];
			 if (resource == null) {
				 continue;
			 }
			 super.visitLdcInsn(Type.getObjectType(FindInClass.this.name));
			 super.visitLdcInsn(resource);
			 super.visitMethodInsn(Opcodes.INVOKESTATIC, ""org/netbeans/html/boot/spi/Fn"", ""preload"", ""(Lorg/netbeans/html/boot/spi/Fn;
			Ljava/lang/Class;
			Ljava/lang/String;
			)Lorg/netbeans/html/boot/spi/Fn;
			"" );
		 }
		 super.visitInsn(Opcodes.DUP);
		 super.visitFieldInsn( Opcodes.PUTSTATIC, FindInClass.this.name, ""$$fn$$"" + name + ""_"" + found, ""Lorg/netbeans/html/boot/spi/Fn;
		"" );
		 super.visitLabel(ifNotNull);
		 final int offset;
		 if ((access & Opcodes.ACC_STATIC) == 0) {
			 offset = 1;
			 super.visitIntInsn(Opcodes.ALOAD, 0);
		 }
		 else {
			 offset = 0;
			 super.visitInsn(Opcodes.ACONST_NULL);
		 }
		 super.visitIntInsn(Opcodes.SIPUSH, args.size());
		 super.visitTypeInsn(Opcodes.ANEWARRAY, ""java/lang/Object"");
		 class SV extends SignatureVisitor {
			 private boolean nowReturn;
			 private Type returnType;
			 private int index;
			 private int loadIndex = offset;
			 public SV() {
				 super(Opcodes.ASM5);
			 }
			 public void visitBaseType(char descriptor) {
				 final Type t = Type.getType("""" + descriptor);
				 if (nowReturn) {
					 returnType = t;
					 return;
				 }
				 FindInMethod.super.visitInsn(Opcodes.DUP);
				 FindInMethod.super.visitIntInsn(Opcodes.SIPUSH, index++);
				 FindInMethod.super.visitVarInsn(t.getOpcode(Opcodes.ILOAD), loadIndex++);
				 String factory;
				 switch (descriptor) {
					 case 'I': factory = ""java/lang/Integer"";
					 break;
					 case 'J': factory = ""java/lang/Long"";
					 loadIndex++;
					 break;
					 case 'S': factory = ""java/lang/Short"";
					 break;
					 case 'F': factory = ""java/lang/Float"";
					 break;
					 case 'D': factory = ""java/lang/Double"";
					 loadIndex++;
					 break;
					 case 'Z': factory = ""java/lang/Boolean"";
					 break;
					 case 'C': factory = ""java/lang/Character"";
					 break;
					 case 'B': factory = ""java/lang/Byte"";
					 break;
					 default: throw new IllegalStateException(t.toString());
				 }
				 FindInMethod.super.visitMethodInsn(Opcodes.INVOKESTATIC, factory, ""valueOf"", ""("" + descriptor + "")L"" + factory + "";
				"" );
				 FindInMethod.super.visitInsn(Opcodes.AASTORE);
			 }
			 public SignatureVisitor visitArrayType() {
				 if (nowReturn) {
					 return new SignatureVisitor(Opcodes.ASM5) {
						 public void visitClassType(String name) {
							 returnType = Type.getType(""["" + Type.getObjectType(name).getDescriptor());
						 }
						 public void visitBaseType(char descriptor) {
							 returnType = Type.getType(""["" + descriptor);
						 }
					 }
					;
				 }
				 loadObject();
				 return new SignatureWriter();
			 }
			 public void visitClassType(String name) {
				 if (nowReturn) {
					 returnType = Type.getObjectType(name);
					 return;
				 }
				 loadObject();
			 }
			 public SignatureVisitor visitReturnType() {
				 nowReturn = true;
				 return this;
			 }
			 private void loadObject() {
				 FindInMethod.super.visitInsn(Opcodes.DUP);
				 FindInMethod.super.visitIntInsn(Opcodes.SIPUSH, index++);
				 FindInMethod.super.visitVarInsn(Opcodes.ALOAD, loadIndex++);
				 FindInMethod.super.visitInsn(Opcodes.AASTORE);
			 }
		 }
		 SV sv = new SV();
		 SignatureReader sr = new SignatureReader(desc);
		 sr.accept(sv);
		 if (needsVM) {
			 FindInMethod.super.visitInsn(Opcodes.DUP);
			 FindInMethod.super.visitIntInsn(Opcodes.SIPUSH, sv.index);
			 int lastSlash = FindInClass.this.name.lastIndexOf('/');
			 String jsCallbacks = FindInClass.this.name.substring(0, lastSlash + 1) + ""$JsCallbacks$"";
			 FindInMethod.super.visitFieldInsn(Opcodes.GETSTATIC, jsCallbacks, ""VM"", ""L"" + jsCallbacks + "";
			"");
			 FindInMethod.super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, jsCallbacks, ""current"", ""()L"" + jsCallbacks + "";
			"");
			 FindInMethod.super.visitInsn(Opcodes.AASTORE);
		 }
		 if (fia.wait4js) {
			 super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""org/netbeans/html/boot/spi/Fn"", ""invoke"", ""(Ljava/lang/Object;
			[Ljava/lang/Object;
			)Ljava/lang/Object;
			"" );
			 switch (sv.returnType.getSort()) {
				 case Type.VOID: super.visitInsn(Opcodes.RETURN);
				 break;
				 case Type.ARRAY: case Type.OBJECT: super.visitTypeInsn(Opcodes.CHECKCAST, sv.returnType.getInternalName());
				 super.visitInsn(Opcodes.ARETURN);
				 break;
				 case Type.BOOLEAN: {
					 Label handleNullValue = new Label();
					 super.visitInsn(Opcodes.DUP);
					 super.visitJumpInsn(Opcodes.IFNULL, handleNullValue);
					 super.visitTypeInsn(Opcodes.CHECKCAST, ""java/lang/Boolean"");
					 super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/Boolean"", ""booleanValue"", ""()Z"" );
					 super.visitInsn(Opcodes.IRETURN);
					 super.visitLabel(handleNullValue);
					 super.visitInsn(Opcodes.ICONST_0);
					 super.visitInsn(Opcodes.IRETURN);
					 break;
				 }
				 default: super.visitTypeInsn(Opcodes.CHECKCAST, ""java/lang/Number"");
				 super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""java/lang/Number"", sv.returnType.getClassName() + ""Value"", ""()"" + sv.returnType.getDescriptor() );
				 super.visitInsn(sv.returnType.getOpcode(Opcodes.IRETURN));
			 }
		 }
		 else {
			 super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ""org/netbeans/html/boot/spi/Fn"", ""invokeLater"", ""(Ljava/lang/Object;
			[Ljava/lang/Object;
			)V"" );
			 super.visitInsn(Opcodes.RETURN);
		 }
		 super.visitLabel(noPresenter);
		 if (hasCode) {
			 super.visitCode();
		 }
		 else {
			 super.visitTypeInsn(Opcodes.NEW, ""java/lang/IllegalStateException"");
			 super.visitInsn(Opcodes.DUP);
			 super.visitLdcInsn(""No presenter active. Use BrwsrCtx.execute!"");
			 super.visitMethodInsn(Opcodes.INVOKESPECIAL, ""java/lang/IllegalStateException"", ""<init>"", ""(Ljava/lang/String;
			)V"" );
			 this.visitInsn(Opcodes.ATHROW);
		 }
		 return true;
	 }
	 public void visitEnd() {
		 super.visitEnd();
		 if (fia != null) {
			 if (generateBody(false)) {
				 super.visitMaxs(1, 0);
			 }
			 FindInClass.this.superField( Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC, ""$$fn$$"" + name + ""_"" + found, ""Lorg/netbeans/html/boot/spi/Fn;
			"", null, null );
		 }
	 }
	 private final class FindInAnno extends AnnotationVisitor {
		 List<String> args = new ArrayList<String>();
		 String body;
		 boolean javacall = false;
		 boolean wait4js = true;
		 boolean keepAlive = true;
		 public FindInAnno() {
			 super(Opcodes.ASM5);
		 }
		 public void visit(String name, Object value) {
			 if (name == null) {
				 args.add((String) value);
				 return;
			 }
			 if (name.equals(""javacall"")) {
				 javacall = (Boolean) value;
				 return;
			 }
			 if (name.equals(""wait4js"")) {
				 wait4js = (Boolean) value;
				 return;
			 }
			 if (name.equals(""keepAlive"")) {
				 keepAlive = (Boolean) value;
				 return;
			 }
			 assert name.equals(""body"");
			 body = (String) value;
		 }
		 public AnnotationVisitor visitArray(String name) {
			 return this;
		 }
		 public void visitEnd() {
			 if (body != null) {
				 generateJSBody(this);
			 }
		 }
	 }
 }",1,0,0,0
"public static final class PutRolesRoleIdResponse {
	 private PutRolesRoleIdResponse() {
	 }
	 final class PutRolesRoleIdResponseChanges {
		 private PutRolesRoleIdResponseChanges(){
		}
		 "") public String description;
	 }
	 public Long resourceId;
	 public PutRolesRoleIdResponseChanges changes;
 }",0,0,0,0
"public void putNextEntry(TarEntry entry) throws IOException {
	 if (entry.getName().length() >= TarConstants.NAMELEN) {
		 if (longFileMode == LONGFILE_GNU) {
			 TarEntry longLinkEntry = new TarEntry(TarConstants.GNU_LONGLINK, TarConstants.LF_GNUTYPE_LONGNAME);
			 longLinkEntry.setSize(entry.getName().length() + 1);
			 putNextEntry(longLinkEntry);
			 write(entry.getName().getBytes());
			 write(0);
			 closeEntry();
		 }
		 else if (longFileMode != LONGFILE_TRUNCATE) {
			 throw new RuntimeException(""file name '"" + entry.getName() + ""' is too long ( > "" + TarConstants.NAMELEN + "" bytes)"");
		 }
	 }
	 entry.writeEntryHeader(recordBuf);
	 buffer.writeRecord(recordBuf);
	 currBytes = 0;
	 if (entry.isDirectory()) {
		 currSize = 0;
	 }
	 else {
		 currSize = entry.getSize();
	 }
	 currName = entry.getName();
 }",0,0,0,0
"public class OutErrSummaryJUnitResultFormatter extends SummaryJUnitResultFormatter {
	 public OutErrSummaryJUnitResultFormatter() {
		 super();
		 setWithOutAndErr(true);
	 }
}",0,0,0,0
"public void drawItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset data, int row, int column, int pass);",0,0,0,1
"public class ReportInstance extends AbstractDTOBase {
	 private String id;
	 private ReportStatusEnum status;
	 private String url;
	 private String ownerId;
	 private Boolean hasDetailRows;
	 private ZonedDateTime completionDate;
	 private ZonedDateTime requestDate;
	 public String getId() {
		 return id;
	 }
	 public void setId(String id) {
		 this.id = id;
	 }
	 public ReportStatusEnum getStatus() {
		 return status;
	 }
	 public void setStatus(ReportStatusEnum status) {
		 this.status = status;
	 }
	 public String getUrl() {
		 return url;
	 }
	 public void setUrl(String url) {
		 this.url = url;
	 }
	 public String getOwnerId() {
		 return ownerId;
	 }
	 public void setOwnerId(String ownerId) {
		 this.ownerId = ownerId;
	 }
	 public Boolean getHasDetailRows() {
		 return hasDetailRows;
	 }
	 public void setHasDetailRows(Boolean hasDetailRows) {
		 this.hasDetailRows = hasDetailRows;
	 }
	 public ZonedDateTime getCompletionDate() {
		 return completionDate;
	 }
	 public void setCompletionDate(ZonedDateTime completionDate) {
		 this.completionDate = completionDate;
	 }
	 public ZonedDateTime getRequestDate() {
		 return requestDate;
	 }
	 public void setRequestDate(ZonedDateTime requestDate) {
		 this.requestDate = requestDate;
	 }
}",1,1,0,0
"public class InternalImportUriUiTestLanguageParser extends AbstractInternalAntlrParser {
	 public static final String[] tokenNames = new String[] {
	 ""<invalid>"", ""<EOR>"", ""<DOWN>"", ""<UP>"", ""RULE_STRING"", ""RULE_ID"", ""RULE_INT"", ""RULE_ML_COMMENT"", ""RULE_SL_COMMENT"", ""RULE_WS"", ""RULE_ANY_OTHER"", ""'import'"", ""'type'"", ""'extends'"" }
	;
	 public static final int RULE_ID=5;
	 public static final int RULE_WS=9;
	 public static final int RULE_STRING=4;
	 public static final int RULE_ANY_OTHER=10;
	 public static final int RULE_SL_COMMENT=8;
	 public static final int RULE_INT=6;
	 public static final int T__11=11;
	 public static final int RULE_ML_COMMENT=7;
	 public static final int T__12=12;
	 public static final int T__13=13;
	 public static final int EOF=-1;
	 public InternalImportUriUiTestLanguageParser(TokenStream input) {
		 this(input, new RecognizerSharedState());
	 }
	 public InternalImportUriUiTestLanguageParser(TokenStream input, RecognizerSharedState state) {
		 super(input, state);
	 }
	 public String[] getTokenNames() {
		 return InternalImportUriUiTestLanguageParser.tokenNames;
	 }
	 public String getGrammarFileName() {
		 return ""InternalImportUriUiTestLanguage.g"";
	 }
	 private ImportUriUiTestLanguageGrammarAccess grammarAccess;
	 public InternalImportUriUiTestLanguageParser(TokenStream input, ImportUriUiTestLanguageGrammarAccess grammarAccess) {
		 this(input);
		 this.grammarAccess = grammarAccess;
		 registerRules(grammarAccess.getGrammar());
	 }
	 protected String getFirstRuleName() {
		 return ""Main"";
	 }
	 protected ImportUriUiTestLanguageGrammarAccess getGrammarAccess() {
		 return grammarAccess;
	 }
	 public final EObject entryRuleMain() throws RecognitionException {
		 EObject current = null;
		 EObject iv_ruleMain = null;
		 try {
			 {
				 newCompositeNode(grammarAccess.getMainRule());
				 pushFollow(FollowSets000.FOLLOW_1);
				 iv_ruleMain=ruleMain();
				 state._fsp--;
				 current =iv_ruleMain;
				 match(input,EOF,FollowSets000.FOLLOW_2);
			 }
		 }
		 catch (RecognitionException re) {
			 recover(input,re);
			 appendSkippedTokens();
		 }
		 finally {
		 }
		 return current;
	 }
	 public final EObject ruleMain() throws RecognitionException {
		 EObject current = null;
		 EObject lv_imports_0_0 = null;
		 EObject lv_types_1_0 = null;
		 enterRule();
		 try {
			 {
				 {
					 loop1: do {
						 int alt1=2;
						 int LA1_0 = input.LA(1);
						 if ( (LA1_0==11) ) {
							 alt1=1;
						 }
						 switch (alt1) {
							 case 1 : {
								 {
									 newCompositeNode(grammarAccess.getMainAccess().getImportsImportParserRuleCall_0_0());
									 pushFollow(FollowSets000.FOLLOW_3);
									 lv_imports_0_0=ruleImport();
									 state._fsp--;
									 if (current==null) {
										 current = createModelElementForParent(grammarAccess.getMainRule());
									 }
									 add( current, ""imports"", lv_imports_0_0, ""org.eclipse.xtext.ui.tests.linking.ImportUriUiTestLanguage.Import"");
									 afterParserOrEnumRuleCall();
								 }
							 }
							 break;
							 default : break loop1;
						 }
					 }
					 while (true);
					 loop2: do {
						 int alt2=2;
						 int LA2_0 = input.LA(1);
						 if ( (LA2_0==12) ) {
							 alt2=1;
						 }
						 switch (alt2) {
							 case 1 : {
								 {
									 newCompositeNode(grammarAccess.getMainAccess().getTypesTypeParserRuleCall_1_0());
									 pushFollow(FollowSets000.FOLLOW_4);
									 lv_types_1_0=ruleType();
									 state._fsp--;
									 if (current==null) {
										 current = createModelElementForParent(grammarAccess.getMainRule());
									 }
									 add( current, ""types"", lv_types_1_0, ""org.eclipse.xtext.ui.tests.linking.ImportUriUiTestLanguage.Type"");
									 afterParserOrEnumRuleCall();
								 }
							 }
							 break;
							 default : break loop2;
						 }
					 }
					 while (true);
				 }
			 }
			 leaveRule();
		 }
		 catch (RecognitionException re) {
			 recover(input,re);
			 appendSkippedTokens();
		 }
		 finally {
		 }
		 return current;
	 }
	 public final EObject entryRuleImport() throws RecognitionException {
		 EObject current = null;
		 EObject iv_ruleImport = null;
		 try {
			 {
				 newCompositeNode(grammarAccess.getImportRule());
				 pushFollow(FollowSets000.FOLLOW_1);
				 iv_ruleImport=ruleImport();
				 state._fsp--;
				 current =iv_ruleImport;
				 match(input,EOF,FollowSets000.FOLLOW_2);
			 }
		 }
		 catch (RecognitionException re) {
			 recover(input,re);
			 appendSkippedTokens();
		 }
		 finally {
		 }
		 return current;
	 }
	 public final EObject ruleImport() throws RecognitionException {
		 EObject current = null;
		 Token otherlv_0=null;
		 Token lv_importURI_1_0=null;
		 enterRule();
		 try {
			 {
				 {
					 otherlv_0=(Token)match(input,11,FollowSets000.FOLLOW_5);
					 newLeafNode(otherlv_0, grammarAccess.getImportAccess().getImportKeyword_0());
					 {
						 {
							 lv_importURI_1_0=(Token)match(input,RULE_STRING,FollowSets000.FOLLOW_2);
							 newLeafNode(lv_importURI_1_0, grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0());
							 if (current==null) {
								 current = createModelElement(grammarAccess.getImportRule());
							 }
							 setWithLastConsumed( current, ""importURI"", lv_importURI_1_0, ""org.eclipse.xtext.common.Terminals.STRING"");
						 }
					 }
				 }
			 }
			 leaveRule();
		 }
		 catch (RecognitionException re) {
			 recover(input,re);
			 appendSkippedTokens();
		 }
		 finally {
		 }
		 return current;
	 }
	 public final EObject entryRuleType() throws RecognitionException {
		 EObject current = null;
		 EObject iv_ruleType = null;
		 try {
			 {
				 newCompositeNode(grammarAccess.getTypeRule());
				 pushFollow(FollowSets000.FOLLOW_1);
				 iv_ruleType=ruleType();
				 state._fsp--;
				 current =iv_ruleType;
				 match(input,EOF,FollowSets000.FOLLOW_2);
			 }
		 }
		 catch (RecognitionException re) {
			 recover(input,re);
			 appendSkippedTokens();
		 }
		 finally {
		 }
		 return current;
	 }
	 public final EObject ruleType() throws RecognitionException {
		 EObject current = null;
		 Token otherlv_0=null;
		 Token lv_name_1_0=null;
		 Token otherlv_2=null;
		 Token otherlv_3=null;
		 enterRule();
		 try {
			 {
				 {
					 otherlv_0=(Token)match(input,12,FollowSets000.FOLLOW_6);
					 newLeafNode(otherlv_0, grammarAccess.getTypeAccess().getTypeKeyword_0());
					 {
						 {
							 lv_name_1_0=(Token)match(input,RULE_ID,FollowSets000.FOLLOW_7);
							 newLeafNode(lv_name_1_0, grammarAccess.getTypeAccess().getNameIDTerminalRuleCall_1_0());
							 if (current==null) {
								 current = createModelElement(grammarAccess.getTypeRule());
							 }
							 setWithLastConsumed( current, ""name"", lv_name_1_0, ""org.eclipse.xtext.common.Terminals.ID"");
						 }
					 }
					 otherlv_2=(Token)match(input,13,FollowSets000.FOLLOW_6);
					 newLeafNode(otherlv_2, grammarAccess.getTypeAccess().getExtendsKeyword_2());
					 {
						 {
							 if (current==null) {
								 current = createModelElement(grammarAccess.getTypeRule());
							 }
							 otherlv_3=(Token)match(input,RULE_ID,FollowSets000.FOLLOW_2);
							 newLeafNode(otherlv_3, grammarAccess.getTypeAccess().getExtendsTypeCrossReference_3_0());
						 }
					 }
				 }
			 }
			 leaveRule();
		 }
		 catch (RecognitionException re) {
			 recover(input,re);
			 appendSkippedTokens();
		 }
		 finally {
		 }
		 return current;
	 }
	 private static class FollowSets000 {
		 public static final BitSet FOLLOW_1 = new BitSet(new long[]{
		0x0000000000000000L}
		);
		 public static final BitSet FOLLOW_2 = new BitSet(new long[]{
		0x0000000000000002L}
		);
		 public static final BitSet FOLLOW_3 = new BitSet(new long[]{
		0x0000000000001802L}
		);
		 public static final BitSet FOLLOW_4 = new BitSet(new long[]{
		0x0000000000001002L}
		);
		 public static final BitSet FOLLOW_5 = new BitSet(new long[]{
		0x0000000000000010L}
		);
		 public static final BitSet FOLLOW_6 = new BitSet(new long[]{
		0x0000000000000020L}
		);
		 public static final BitSet FOLLOW_7 = new BitSet(new long[]{
		0x0000000000002000L}
		);
	 }
}",0,0,0,0
"public boolean filterEntry(Entry entry,Account account,VerySimpleDateFormat dateFormat);",0,0,0,0
"public class WebXml {
	 protected static final String ORDER_OTHERS = ""org.apache.catalina.order.others"";
	 private static final StringManager sm = StringManager.getManager(Constants.Package);
	 private static final org.apache.juli.logging.Log log= org.apache.juli.logging.LogFactory.getLog(WebXml.class);
	 private Set<String> absoluteOrdering = null;
	 public void addAbsoluteOrdering(String fragmentName) {
		 if (absoluteOrdering == null) {
			 absoluteOrdering = new LinkedHashSet<String>();
		 }
		 absoluteOrdering.add(fragmentName);
	 }
	 public void addAbsoluteOrderingOthers() {
		 if (absoluteOrdering == null) {
			 absoluteOrdering = new LinkedHashSet<String>();
		 }
		 absoluteOrdering.add(ORDER_OTHERS);
	 }
	 public Set<String> getAbsoluteOrdering() {
		 return absoluteOrdering;
	 }
	 private Set<String> after = new LinkedHashSet<String>();
	 public void addAfterOrdering(String fragmentName) {
		 after.add(fragmentName);
	 }
	 public void addAfterOrderingOthers() {
		 if (before.contains(ORDER_OTHERS)) {
			 throw new IllegalArgumentException(sm.getString( ""webXml.multipleOther""));
		 }
		 after.add(ORDER_OTHERS);
	 }
	 public Set<String> getAfterOrdering() {
		 return after;
	 }
	 private Set<String> before = new LinkedHashSet<String>();
	 public void addBeforeOrdering(String fragmentName) {
		 before.add(fragmentName);
	 }
	 public void addBeforeOrderingOthers() {
		 if (after.contains(ORDER_OTHERS)) {
			 throw new IllegalArgumentException(sm.getString( ""webXml.multipleOther""));
		 }
		 before.add(ORDER_OTHERS);
	 }
	 public Set<String> getBeforeOrdering() {
		 return before;
	 }
	 public String getVersion() {
		 StringBuilder sb = new StringBuilder(3);
		 sb.append(majorVersion);
		 sb.append('.');
		 sb.append(minorVersion);
		 return sb.toString();
	 }
	 public void setVersion(String version) {
		 if (version == null) return;
		 String major = null;
		 String minor = null;
		 int split = version.indexOf('.');
		 if (split < 0) {
			 major = version;
		 }
		 else {
			 major = version.substring(0, split);
			 minor = version.substring(split + 1);
		 }
		 if (major == null || major.length() == 0) {
			 majorVersion = 0;
		 }
		 else {
			 try {
				 majorVersion = Integer.parseInt(major);
			 }
			 catch (NumberFormatException nfe) {
				 log.warn(sm.getString(""webXml.version.nfe"", major, version), nfe);
				 majorVersion = 0;
			 }
		 }
		 if (minor == null || minor.length() == 0) {
			 minorVersion = 0;
		 }
		 else {
			 try {
				 minorVersion = Integer.parseInt(minor);
			 }
			 catch (NumberFormatException nfe) {
				 log.warn(sm.getString(""webXml.version.nfe"", minor, version), nfe);
				 minorVersion = 0;
			 }
		 }
	 }
	 private String publicId = null;
	 public String getPublicId() {
		 return publicId;
	 }
	 public void setPublicId(String publicId) {
		 if (publicId == null) {
		 }
		 else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_30. equalsIgnoreCase(publicId) || org.apache.catalina.startup.Constants.WebFragmentSchemaPublicId_30. equalsIgnoreCase(publicId)) {
			 majorVersion = 3;
			 minorVersion = 0;
			 this.publicId = publicId;
		 }
		 else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_25. equalsIgnoreCase(publicId)) {
			 majorVersion = 2;
			 minorVersion = 5;
			 this.publicId = publicId;
		 }
		 else if (org.apache.catalina.startup.Constants.WebSchemaPublicId_24. equalsIgnoreCase(publicId)) {
			 majorVersion = 2;
			 minorVersion = 4;
			 this.publicId = publicId;
		 }
		 else if (org.apache.catalina.startup.Constants.WebDtdPublicId_23. equalsIgnoreCase(publicId)) {
			 majorVersion = 2;
			 minorVersion = 3;
			 this.publicId = publicId;
		 }
		 else if (org.apache.catalina.startup.Constants.WebDtdPublicId_22. equalsIgnoreCase(publicId)) {
			 majorVersion = 2;
			 minorVersion = 2;
			 this.publicId = publicId;
		 }
		 else if (""datatypes"".equals(publicId)) {
		 }
		 else {
			 log.warn(sm.getString(""webxml.unrecognisedPublicId"", publicId));
		 }
	 }
	 private boolean metadataComplete = false;
	 public boolean isMetadataComplete() {
		 return metadataComplete;
	 }
	 public void setMetadataComplete(boolean metadataComplete) {
		 this.metadataComplete = metadataComplete;
	 }
	 private String name = null;
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 if (ORDER_OTHERS.equalsIgnoreCase(name)) {
			 log.warn(sm.getString(""webXml.reservedName"", name));
		 }
		 else {
			 this.name = name;
		 }
	 }
	 private int majorVersion = 3;
	 private int minorVersion = 0;
	 public int getMajorVersion() {
		 return majorVersion;
	 }
	 public int getMinorVersion() {
		 return minorVersion;
	 }
	 private String displayName = null;
	 public String getDisplayName() {
		 return displayName;
	 }
	 public void setDisplayName(String displayName) {
		 this.displayName = displayName;
	 }
	 private boolean distributable = false;
	 public boolean isDistributable() {
		 return distributable;
	 }
	 public void setDistributable(boolean distributable) {
		 this.distributable = distributable;
	 }
	 private Map<String,String> contextParams = new HashMap<String,String>();
	 public void addContextParam(String param, String value) {
		 contextParams.put(param, value);
	 }
	 public Map<String,String> getContextParams() {
		 return contextParams;
	 }
	 private Map<String,FilterDef> filters = new LinkedHashMap<String,FilterDef>();
	 public void addFilter(FilterDef filter) {
		 if (filters.containsKey(filter.getFilterName())) {
			 throw new IllegalArgumentException( sm.getString(""webXml.duplicateFilter"", filter.getFilterName()));
		 }
		 filters.put(filter.getFilterName(), filter);
	 }
	 public Map<String,FilterDef> getFilters() {
		 return filters;
	 }
	 private Set<FilterMap> filterMaps = new LinkedHashSet<FilterMap>();
	 private Set<String> filterMappingNames = new HashSet<String>();
	 public void addFilterMapping(FilterMap filterMap) {
		 filterMaps.add(filterMap);
		 filterMappingNames.add(filterMap.getFilterName());
	 }
	 public Set<FilterMap> getFilterMappings() {
		 return filterMaps;
	 }
	 private Set<String> listeners = new LinkedHashSet<String>();
	 public void addListener(String className) {
		 listeners.add(className);
	 }
	 public Set<String> getListeners() {
		 return listeners;
	 }
	 private Map<String,ServletDef> servlets = new HashMap<String,ServletDef>();
	 public void addServlet(ServletDef servletDef) {
		 servlets.put(servletDef.getServletName(), servletDef);
	 }
	 public Map<String,ServletDef> getServlets() {
		 return servlets;
	 }
	 private Map<String,String> servletMappings = new HashMap<String,String>();
	 private Set<String> servletMappingNames = new HashSet<String>();
	 public void addServletMapping(String urlPattern, String servletName) {
		 servletMappings.put(urlPattern, servletName);
		 servletMappingNames.add(servletName);
	 }
	 public Map<String,String> getServletMappings() {
		 return servletMappings;
	 }
	 private SessionConfig sessionConfig = new SessionConfig();
	 public void setSessionConfig(SessionConfig sessionConfig) {
		 this.sessionConfig = sessionConfig;
	 }
	 public SessionConfig getSessionConfig() {
		 return sessionConfig;
	 }
	 private Map<String,String> mimeMappings = new HashMap<String,String>();
	 public void addMimeMapping(String extension, String mimeType) {
		 mimeMappings.put(extension, mimeType);
	 }
	 public Map<String,String> getMimeMappings() {
		 return mimeMappings;
	 }
	 private boolean replaceWelcomeFiles = false;
	 public void setReplaceWelcomeFiles(boolean replaceWelcomeFiles) {
		 this.replaceWelcomeFiles = replaceWelcomeFiles;
	 }
	 private Set<String> welcomeFiles = new LinkedHashSet<String>();
	 public void addWelcomeFile(String welcomeFile) {
		 if (replaceWelcomeFiles) {
			 welcomeFiles.clear();
			 replaceWelcomeFiles = false;
		 }
		 welcomeFiles.add(welcomeFile);
	 }
	 public Set<String> getWelcomeFiles() {
		 return welcomeFiles;
	 }
	 private Map<String,ErrorPage> errorPages = new HashMap<String,ErrorPage>();
	 public void addErrorPage(ErrorPage errorPage) {
		 errorPages.put(errorPage.getName(), errorPage);
	 }
	 public Map<String,ErrorPage> getErrorPages() {
		 return errorPages;
	 }
	 private Map<String,String> taglibs = new HashMap<String,String>();
	 public void addTaglib(String uri, String location) {
		 if (taglibs.containsKey(uri)) {
			 throw new IllegalArgumentException( sm.getString(""webXml.duplicateTaglibUri"", uri));
		 }
		 taglibs.put(uri, location);
	 }
	 public Map<String,String> getTaglibs() {
		 return taglibs;
	 }
	 private Set<JspPropertyGroup> jspPropertyGroups = new HashSet<JspPropertyGroup>();
	 public void addJspPropertyGroup(JspPropertyGroup propertyGroup) {
		 jspPropertyGroups.add(propertyGroup);
	 }
	 public Set<JspPropertyGroup> getJspPropertyGroups() {
		 return jspPropertyGroups;
	 }
	 private Set<SecurityConstraint> securityConstraints = new HashSet<SecurityConstraint>();
	 public void addSecurityConstraint(SecurityConstraint securityConstraint) {
		 securityConstraints.add(securityConstraint);
	 }
	 public Set<SecurityConstraint> getSecurityConstraints() {
		 return securityConstraints;
	 }
	 private LoginConfig loginConfig = null;
	 public void setLoginConfig(LoginConfig loginConfig) {
		 this.loginConfig = loginConfig;
	 }
	 public LoginConfig getLoginConfig() {
		 return loginConfig;
	 }
	 private Set<String> securityRoles = new HashSet<String>();
	 public void addSecurityRole(String securityRole) {
		 securityRoles.add(securityRole);
	 }
	 public Set<String> getSecurityRoles() {
		 return securityRoles;
	 }
	 private Map<String,ContextEnvironment> envEntries = new HashMap<String,ContextEnvironment>();
	 public void addEnvEntry(ContextEnvironment envEntry) {
		 if (envEntries.containsKey(envEntry.getName())) {
			 throw new IllegalArgumentException( sm.getString(""webXml.duplicateEnvEntry"", envEntry.getName()));
		 }
		 envEntries.put(envEntry.getName(),envEntry);
	 }
	 public Map<String,ContextEnvironment> getEnvEntries() {
		 return envEntries;
	 }
	 private Map<String,ContextEjb> ejbRefs = new HashMap<String,ContextEjb>();
	 public void addEjbRef(ContextEjb ejbRef) {
		 ejbRefs.put(ejbRef.getName(),ejbRef);
	 }
	 public Map<String,ContextEjb> getEjbRefs() {
		 return ejbRefs;
	 }
	 private Map<String,ContextLocalEjb> ejbLocalRefs = new HashMap<String,ContextLocalEjb>();
	 public void addEjbLocalRef(ContextLocalEjb ejbLocalRef) {
		 ejbLocalRefs.put(ejbLocalRef.getName(),ejbLocalRef);
	 }
	 public Map<String,ContextLocalEjb> getEjbLocalRefs() {
		 return ejbLocalRefs;
	 }
	 private Map<String,ContextService> serviceRefs = new HashMap<String,ContextService>();
	 public void addServiceRef(ContextService serviceRef) {
		 serviceRefs.put(serviceRef.getName(), serviceRef);
	 }
	 public Map<String,ContextService> getServiceRefs() {
		 return serviceRefs;
	 }
	 private Map<String,ContextResource> resourceRefs = new HashMap<String,ContextResource>();
	 public void addResourceRef(ContextResource resourceRef) {
		 if (resourceRefs.containsKey(resourceRef.getName())) {
			 throw new IllegalArgumentException( sm.getString(""webXml.duplicateResourceRef"", resourceRef.getName()));
		 }
		 resourceRefs.put(resourceRef.getName(), resourceRef);
	 }
	 public Map<String,ContextResource> getResourceRefs() {
		 return resourceRefs;
	 }
	 private Map<String,ContextResourceEnvRef> resourceEnvRefs = new HashMap<String,ContextResourceEnvRef>();
	 public void addResourceEnvRef(ContextResourceEnvRef resourceEnvRef) {
		 if (resourceEnvRefs.containsKey(resourceEnvRef.getName())) {
			 throw new IllegalArgumentException( sm.getString(""webXml.duplicateResourceEnvRef"", resourceEnvRef.getName()));
		 }
		 resourceEnvRefs.put(resourceEnvRef.getName(), resourceEnvRef);
	 }
	 public Map<String,ContextResourceEnvRef> getResourceEnvRefs() {
		 return resourceEnvRefs;
	 }
	 private Map<String,MessageDestinationRef> messageDestinationRefs = new HashMap<String,MessageDestinationRef>();
	 public void addMessageDestinationRef( MessageDestinationRef messageDestinationRef) {
		 if (messageDestinationRefs.containsKey( messageDestinationRef.getName())) {
			 throw new IllegalArgumentException(sm.getString( ""webXml.duplicateMessageDestinationRef"", messageDestinationRef.getName()));
		 }
		 messageDestinationRefs.put(messageDestinationRef.getName(), messageDestinationRef);
	 }
	 public Map<String,MessageDestinationRef> getMessageDestinationRefs() {
		 return messageDestinationRefs;
	 }
	 private Map<String,MessageDestination> messageDestinations = new HashMap<String,MessageDestination>();
	 public void addMessageDestination( MessageDestination messageDestination) {
		 if (messageDestinations.containsKey( messageDestination.getName())) {
			 throw new IllegalArgumentException( sm.getString(""webXml.duplicateMessageDestination"", messageDestination.getName()));
		 }
		 messageDestinations.put(messageDestination.getName(), messageDestination);
	 }
	 public Map<String,MessageDestination> getMessageDestinations() {
		 return messageDestinations;
	 }
	 private Map<String,String> localeEncodingMappings = new HashMap<String,String>();
	 public void addLocaleEncodingMapping(String locale, String encoding) {
		 localeEncodingMappings.put(locale, encoding);
	 }
	 public Map<String,String> getLocalEncodingMappings() {
		 return localeEncodingMappings;
	 }
	 private URL uRL = null;
	 public void setURL(URL url) {
		 this.uRL = url;
	 }
	 public URL getURL() {
		 return uRL;
	 }
	 public String toString() {
		 StringBuilder buf = new StringBuilder(32);
		 buf.append(""Name: "");
		 buf.append(getName());
		 buf.append("", URL: "");
		 buf.append(getURL());
		 return buf.toString();
	 }
	 private static final String INDENT2 = "" "";
	 private static final String INDENT4 = "" "";
	 private static final String INDENT6 = "" "";
	 public String toXml() {
		 StringBuilder sb = new StringBuilder(2048);
		 sb.append(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");
		 sb.append(""<web-app xmlns=\""http: sb.append("" xmlns:xsi="");
		 sb.append(""\""http: sb.append("" xsi:schemaLocation="");
		 sb.append(""\""http: sb.append("" version=\"""");
		 sb.append(getVersion());
		 sb.append(""\""\n"");
		 sb.append("" metadata-complete=\""true\"">\n\n"");
		 appendElement(sb, INDENT2, ""display-name"", displayName);
		 if (isDistributable()) {
			 sb.append("" <distributable/>\n\n"");
		 }
		 for (Map.Entry<String, String> entry : contextParams.entrySet()) {
			 sb.append("" <context-param>\n"");
			 appendElement(sb, INDENT4, ""param-name"", entry.getKey());
			 appendElement(sb, INDENT4, ""param-valuee"", entry.getValue());
			 sb.append("" </context-param>\n"");
		 }
		 sb.append('\n');
		 for (Map.Entry<String, FilterDef> entry : filters.entrySet()) {
			 FilterDef filterDef = entry.getValue();
			 sb.append("" <filter>\n"");
			 appendElement(sb, INDENT4, ""description"", filterDef.getDescription());
			 appendElement(sb, INDENT4, ""display-name"", filterDef.getDisplayName());
			 appendElement(sb, INDENT4, ""filter-name"", filterDef.getFilterName());
			 appendElement(sb, INDENT4, ""filter-class"", filterDef.getFilterClass());
			 appendElement(sb, INDENT4, ""async-supported"", filterDef.getAsyncSupported());
			 for (Map.Entry<String, String> param : filterDef.getParameterMap().entrySet()) {
				 sb.append("" <init-param>\n"");
				 appendElement(sb, INDENT6, ""param-name"", param.getKey());
				 appendElement(sb, INDENT6, ""param-value"", param.getValue());
				 sb.append("" </init-param>\n"");
			 }
			 sb.append("" </filter>\n"");
		 }
		 sb.append('\n');
		 for (FilterMap filterMap : filterMaps) {
			 sb.append("" <filter-mapping>\n"");
			 appendElement(sb, INDENT4, ""filter-name"", filterMap.getFilterName());
			 if (filterMap.getMatchAllServletNames()) {
				 sb.append("" <servlet-name>*</servlet-name>\n"");
			 }
			 else {
				 for (String servletName : filterMap.getServletNames()) {
					 appendElement(sb, INDENT4, ""servlet-name"", servletName);
				 }
			 }
			 if (filterMap.getMatchAllUrlPatterns()) {
				 sb.append("" <url-pattern>*</url-pattern>\n"");
			 }
			 else {
				 for (String urlPattern : filterMap.getURLPatterns()) {
					 appendElement(sb, INDENT4, ""url-pattern"", urlPattern);
				 }
			 }
			 for (String dispatcher : filterMap.getDispatcherNames()) {
				 appendElement(sb, INDENT4, ""dispatcher"", dispatcher);
			 }
			 sb.append("" </filter-mapping>\n"");
		 }
		 sb.append('\n');
		 for (String listener : listeners) {
			 sb.append("" <listener>\n"");
			 appendElement(sb, INDENT4, ""listener-class"", listener);
			 sb.append("" </listener>\n"");
		 }
		 sb.append('\n');
		 for (Map.Entry<String, ServletDef> entry : servlets.entrySet()) {
			 ServletDef servletDef = entry.getValue();
			 sb.append("" <servlet>\n"");
			 appendElement(sb, INDENT4, ""description"", servletDef.getDescription());
			 appendElement(sb, INDENT4, ""display-name"", servletDef.getDisplayName());
			 appendElement(sb, INDENT4, ""servlet-name"", entry.getKey());
			 appendElement(sb, INDENT4, ""servlet-class"", servletDef.getServletClass());
			 appendElement(sb, INDENT4, ""jsp-file"", servletDef.getJspFile());
			 for (Map.Entry<String, String> param : servletDef.getParameterMap().entrySet()) {
				 sb.append("" <init-param>\n"");
				 appendElement(sb, INDENT6, ""param-name"", param.getKey());
				 appendElement(sb, INDENT6, ""param-value"", param.getValue());
				 sb.append("" </init-param>\n"");
			 }
			 appendElement(sb, INDENT4, ""load-on-startup"", servletDef.getLoadOnStartup());
			 appendElement(sb, INDENT4, ""enabled"", servletDef.getEnabled());
			 appendElement(sb, INDENT4, ""async-supported"", servletDef.getAsyncSupported());
			 if (servletDef.getRunAs() != null) {
				 sb.append("" <run-as>\n"");
				 appendElement(sb, INDENT6, ""role-name"", servletDef.getRunAs());
				 sb.append("" </run-as>\n"");
			 }
			 for (SecurityRoleRef roleRef : servletDef.getSecurityRoleRefs()) {
				 sb.append("" <security-role-ref>\n"");
				 appendElement(sb, INDENT6, ""role-name"", roleRef.getName());
				 appendElement(sb, INDENT6, ""role-link"", roleRef.getLink());
				 sb.append("" </security-role-ref>\n"");
			 }
			 MultipartDef multipartDef = servletDef.getMultipartDef();
			 if (multipartDef != null) {
				 sb.append("" <multipart-config>\n"");
				 appendElement(sb, INDENT6, ""location"", multipartDef.getLocation());
				 appendElement(sb, INDENT6, ""max-file-size"", multipartDef.getMaxFileSize());
				 appendElement(sb, INDENT6, ""max-request-size"", multipartDef.getMaxRequestSize());
				 appendElement(sb, INDENT6, ""file-size-threshold"", multipartDef.getFileSizeThreshold());
				 sb.append("" </multipart-config>\n"");
			 }
			 sb.append("" </servlet>\n"");
		 }
		 sb.append('\n');
		 for (Map.Entry<String, String> entry : servletMappings.entrySet()) {
			 sb.append("" <servlet-mapping>\n"");
			 appendElement(sb, INDENT4, ""servlet-name"", entry.getValue());
			 appendElement(sb, INDENT4, ""url-pattern"", entry.getKey());
			 sb.append("" </servlet-mapping>\n"");
		 }
		 sb.append('\n');
		 if (sessionConfig != null) {
			 sb.append("" <session-config>\n"");
			 appendElement(sb, INDENT4, ""session-timeout"", sessionConfig.getSessionTimeout());
			 sb.append("" <cookie-config>\n"");
			 appendElement(sb, INDENT6, ""name"", sessionConfig.getCookieName());
			 appendElement(sb, INDENT6, ""domain"", sessionConfig.getCookieDomain());
			 appendElement(sb, INDENT6, ""path"", sessionConfig.getCookiePath());
			 appendElement(sb, INDENT6, ""comment"", sessionConfig.getCookieComment());
			 appendElement(sb, INDENT6, ""http-only"", sessionConfig.getCookieHttpOnly());
			 appendElement(sb, INDENT6, ""secure"", sessionConfig.getCookieSecure());
			 appendElement(sb, INDENT6, ""max-age"", sessionConfig.getCookieMaxAge());
			 sb.append("" </cookie-config>\n"");
			 for (SessionTrackingMode stm : sessionConfig.getSessionTrackingModes()) {
				 appendElement(sb, INDENT4, ""tracking-mode"", stm.name());
			 }
			 sb.append("" </session-config>\n\n"");
		 }
		 for (Map.Entry<String, String> entry : mimeMappings.entrySet()) {
			 sb.append("" <mime-mapping>\n"");
			 appendElement(sb, INDENT4, ""extension"", entry.getKey());
			 appendElement(sb, INDENT4, ""mime-type"", entry.getValue());
			 sb.append("" </mime-mapping>\n"");
		 }
		 sb.append('\n');
		 if (welcomeFiles.size() > 0) {
			 sb.append("" <welcome-file-list>\n"");
			 for (String welcomeFile : welcomeFiles) {
				 appendElement(sb, INDENT4, ""welcome-file"", welcomeFile);
			 }
			 sb.append("" </welcome-file-list>\n\n"");
		 }
		 for (ErrorPage errorPage : errorPages.values()) {
			 sb.append("" <error-page>\n"");
			 if (errorPage.getExceptionType() == null) {
				 appendElement(sb, INDENT4, ""error-code"", Integer.toString(errorPage.getErrorCode()));
			 }
			 else {
				 appendElement(sb, INDENT4, ""exception-type"", errorPage.getExceptionType());
			 }
			 appendElement(sb, INDENT4, ""location"", errorPage.getLocation());
			 sb.append("" </error-page>\n"");
		 }
		 sb.append('\n');
		 if (taglibs.size() > 0 || jspPropertyGroups.size() > 0) {
			 sb.append("" <jsp-config>\n"");
			 for (Map.Entry<String, String> entry : taglibs.entrySet()) {
				 sb.append("" <taglib>\n"");
				 appendElement(sb, INDENT6, ""taglib-uri"", entry.getKey());
				 appendElement(sb, INDENT6, ""taglib-location"", entry.getValue());
				 sb.append("" </taglib>\n"");
			 }
			 for (JspPropertyGroup jpg : jspPropertyGroups) {
				 sb.append("" <jsp-property-group>\n"");
				 appendElement(sb, INDENT6, ""url-pattern"", jpg.getUrlPattern());
				 appendElement(sb, INDENT6, ""el-ignored"", jpg.getElIgnored());
				 appendElement(sb, INDENT6, ""scripting-invalid"", jpg.getScriptingInvalid());
				 appendElement(sb, INDENT6, ""page-encoding"", jpg.getPageEncoding());
				 for (String prelude : jpg.getIncludePreludes()) {
					 appendElement(sb, INDENT6, ""include-prelude"", prelude);
				 }
				 for (String coda : jpg.getIncludeCodas()) {
					 appendElement(sb, INDENT6, ""include-coda"", coda);
				 }
				 appendElement(sb, INDENT6, ""is-xml"", jpg.getIsXml());
				 appendElement(sb, INDENT6, ""deferred-syntax-allowed-as-literal"", jpg.getDeferredSyntax());
				 appendElement(sb, INDENT6, ""trim-directive-whitespaces"", jpg.getTrimWhitespace());
				 appendElement(sb, INDENT6, ""default-content-type"", jpg.getDefaultContentType());
				 appendElement(sb, INDENT6, ""buffer"", jpg.getBuffer());
				 appendElement(sb, INDENT6, ""error-on-undeclared-namespace"", jpg.getErrorOnUndeclaredNamespace());
				 sb.append("" </jsp-property-group>\n"");
			 }
			 sb.append("" </jsp-config>\n\n"");
		 }
		 for (SecurityConstraint constraint : securityConstraints) {
			 sb.append("" <security-constraint>\n"");
			 appendElement(sb, INDENT4, ""display-name"", constraint.getDisplayName());
			 for (SecurityCollection collection : constraint.findCollections()) {
				 sb.append("" <web-resource-collection>\n"");
				 appendElement(sb, INDENT6, ""web-resource-name"", collection.getName());
				 appendElement(sb, INDENT6, ""description"", collection.getDescription());
				 for (String urlPattern : collection.findPatterns()) {
					 appendElement(sb, INDENT6, ""url-pattern"", urlPattern);
				 }
				 for (String method : collection.findMethods()) {
					 appendElement(sb, INDENT6, ""http-method"", method);
				 }
				 for (String method : collection.findOmittedMethods()) {
					 appendElement(sb, INDENT6, ""http-method-omission"", method);
				 }
				 sb.append("" </web-resource-collection>\n"");
			 }
			 if (constraint.findAuthRoles().length > 0) {
				 sb.append("" <auth-constraint>\n"");
				 for (String role : constraint.findAuthRoles()) {
					 appendElement(sb, INDENT6, ""role-name"", role);
				 }
				 sb.append("" </auth-constraint>\n"");
			 }
			 if (constraint.getUserConstraint() != null) {
				 sb.append("" <user-data-constraint>\n"");
				 appendElement(sb, INDENT6, ""transport-guarantee"", constraint.getUserConstraint());
				 sb.append("" </user-data-constraint>\n"");
			 }
			 sb.append("" </security-constraint>\n"");
		 }
		 sb.append('\n');
		 if (loginConfig != null) {
			 sb.append("" <login-config>\n"");
			 appendElement(sb, INDENT4, ""auth-method"", loginConfig.getAuthMethod());
			 appendElement(sb,INDENT4, ""realm-name"", loginConfig.getRealmName());
			 if (loginConfig.getErrorPage() != null || loginConfig.getLoginPage() != null) {
				 sb.append("" <form-login-config>\n"");
				 appendElement(sb, INDENT6, ""form-login-page"", loginConfig.getLoginPage());
				 appendElement(sb, INDENT6, ""form-error-page"", loginConfig.getErrorPage());
				 sb.append("" </form-login-config>\n"");
			 }
			 sb.append("" </login-config>\n\n"");
		 }
		 for (String roleName : securityRoles) {
			 sb.append("" <security-role>\n"");
			 appendElement(sb, INDENT4, ""role-name"", roleName);
			 sb.append("" </security-role>\n"");
		 }
		 for (ContextEnvironment envEntry : envEntries.values()) {
			 sb.append("" <env-entry>\n"");
			 appendElement(sb, INDENT4, ""description"", envEntry.getDescription());
			 appendElement(sb, INDENT4, ""env-entry-name"", envEntry.getName());
			 appendElement(sb, INDENT4, ""env-entry-type"", envEntry.getType());
			 appendElement(sb, INDENT4, ""env-entry-value"", envEntry.getValue());
			 for (InjectionTarget target : envEntry.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </env-entry>\n"");
		 }
		 sb.append('\n');
		 for (ContextEjb ejbRef : ejbRefs.values()) {
			 sb.append("" <ejb-ref>\n"");
			 appendElement(sb, INDENT4, ""description"", ejbRef.getDescription());
			 appendElement(sb, INDENT4, ""ejb-ref-name"", ejbRef.getName());
			 appendElement(sb, INDENT4, ""ejb-ref-type"", ejbRef.getType());
			 appendElement(sb, INDENT4, ""home"", ejbRef.getHome());
			 appendElement(sb, INDENT4, ""remote"", ejbRef.getRemote());
			 appendElement(sb, INDENT4, ""ejb-link"", ejbRef.getLink());
			 for (InjectionTarget target : ejbRef.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </ejb-ref>\n"");
		 }
		 sb.append('\n');
		 for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) {
			 sb.append("" <ejb-local-ref>\n"");
			 appendElement(sb, INDENT4, ""description"", ejbLocalRef.getDescription());
			 appendElement(sb, INDENT4, ""ejb-ref-name"", ejbLocalRef.getName());
			 appendElement(sb, INDENT4, ""ejb-ref-type"", ejbLocalRef.getType());
			 appendElement(sb, INDENT4, ""local-home"", ejbLocalRef.getHome());
			 appendElement(sb, INDENT4, ""local"", ejbLocalRef.getLocal());
			 appendElement(sb, INDENT4, ""ejb-link"", ejbLocalRef.getLink());
			 for (InjectionTarget target : ejbLocalRef.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </ejb-local-ref>\n"");
		 }
		 sb.append('\n');
		 for (ContextService serviceRef : serviceRefs.values()) {
			 sb.append("" <service-ref>\n"");
			 appendElement(sb, INDENT4, ""description"", serviceRef.getDescription());
			 appendElement(sb, INDENT4, ""display-name"", serviceRef.getDisplayname());
			 appendElement(sb, INDENT4, ""service-ref-name"", serviceRef.getName());
			 appendElement(sb, INDENT4, ""service-interface"", serviceRef.getInterface());
			 appendElement(sb, INDENT4, ""service-ref-type"", serviceRef.getType());
			 appendElement(sb, INDENT4, ""wsdl-file"", serviceRef.getWsdlfile());
			 appendElement(sb, INDENT4, ""jaxrpc-mapping-file"", serviceRef.getJaxrpcmappingfile());
			 String qname = serviceRef.getServiceqnameNamespaceURI();
			 if (qname != null) {
				 qname = qname + "":"";
			 }
			 qname = qname + serviceRef.getServiceqnameLocalpart();
			 appendElement(sb, INDENT4, ""service-qname"", qname);
			 Iterator<String> endpointIter = serviceRef.getServiceendpoints();
			 while (endpointIter.hasNext()) {
				 String endpoint = endpointIter.next();
				 sb.append("" <port-component-ref>\n"");
				 appendElement(sb, INDENT6, ""service-endpoint-interface"", endpoint);
				 appendElement(sb, INDENT6, ""port-component-link"", serviceRef.getProperty(endpoint));
				 sb.append("" </port-component-ref>\n"");
			 }
			 Iterator<String> handlerIter = serviceRef.getHandlers();
			 while (handlerIter.hasNext()) {
				 String handler = handlerIter.next();
				 sb.append("" <handler>\n"");
				 ContextHandler ch = serviceRef.getHandler(handler);
				 appendElement(sb, INDENT6, ""handler-name"", ch.getName());
				 appendElement(sb, INDENT6, ""handler-class"", ch.getHandlerclass());
				 sb.append("" </handler>\n"");
			 }
			 for (InjectionTarget target : serviceRef.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </service-ref>\n"");
		 }
		 sb.append('\n');
		 for (ContextResource resourceRef : resourceRefs.values()) {
			 sb.append("" <resource-ref>\n"");
			 appendElement(sb, INDENT4, ""description"", resourceRef.getDescription());
			 appendElement(sb, INDENT4, ""res-ref-name"", resourceRef.getName());
			 appendElement(sb, INDENT4, ""res-type"", resourceRef.getType());
			 appendElement(sb, INDENT4, ""res-auth"", resourceRef.getAuth());
			 appendElement(sb, INDENT4, ""res-sharing-scope"", resourceRef.getScope());
			 for (InjectionTarget target : resourceRef.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </resource-ref>\n"");
		 }
		 sb.append('\n');
		 for (ContextResourceEnvRef resourceEnvRef : resourceEnvRefs.values()) {
			 sb.append("" <resource-env-ref>\n"");
			 appendElement(sb, INDENT4, ""description"", resourceEnvRef.getDescription());
			 appendElement(sb, INDENT4, ""resource-env-ref-name"", resourceEnvRef.getName());
			 appendElement(sb, INDENT4, ""resource-env-ref-type"", resourceEnvRef.getType());
			 for (InjectionTarget target : resourceEnvRef.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </resource-env-ref>\n"");
		 }
		 sb.append('\n');
		 for (MessageDestinationRef mdr : messageDestinationRefs.values()) {
			 sb.append("" <message-destination-ref>\n"");
			 appendElement(sb, INDENT4, ""description"", mdr.getDescription());
			 appendElement(sb, INDENT4, ""message-destination-ref-name"", mdr.getName());
			 appendElement(sb, INDENT4, ""message-destination-type"", mdr.getType());
			 appendElement(sb, INDENT4, ""message-destination-usage"", mdr.getUsage());
			 appendElement(sb, INDENT4, ""message-destination-link"", mdr.getLink());
			 for (InjectionTarget target : mdr.getInjectionTargets()) {
				 sb.append("" <injection-target>\n"");
				 appendElement(sb, INDENT6, ""injection-target-class"", target.getTargetClass());
				 appendElement(sb, INDENT6, ""injection-target-name"", target.getTargetName());
				 sb.append("" </injection-target>\n"");
			 }
			 sb.append("" </message-destination-ref>\n"");
		 }
		 sb.append('\n');
		 for (MessageDestination md : messageDestinations.values()) {
			 sb.append("" <message-destination>\n"");
			 appendElement(sb, INDENT4, ""description"", md.getDescription());
			 appendElement(sb, INDENT4, ""display-name"", md.getDisplayName());
			 appendElement(sb, INDENT4, ""message-destination-name"", md.getName());
			 sb.append("" </message-destination>\n"");
		 }
		 sb.append('\n');
		 if (localeEncodingMappings.size() > 0) {
			 sb.append("" <locale-encoding-mapping-list>\n"");
			 for (Map.Entry<String, String> entry : localeEncodingMappings.entrySet()) {
				 sb.append("" <locale-encoding-mapping>\n"");
				 appendElement(sb, INDENT6, ""locale"", entry.getKey());
				 appendElement(sb, INDENT6, ""encoding"", entry.getValue());
				 sb.append("" </locale-encoding-mapping>\n"");
			 }
			 sb.append("" </locale-encoding-mapping-list>\n"");
		 }
		 sb.append(""</web-app>"");
		 return sb.toString();
	 }
	 private static void appendElement(StringBuilder sb, String indent, String elementName, String value) {
		 if (value == null || value.length() == 0) return;
		 sb.append(indent);
		 sb.append('<');
		 sb.append(elementName);
		 sb.append('>');
		 sb.append(escapeXml(value));
		 sb.append(""</"");
		 sb.append(elementName);
		 sb.append("">\n"");
	 }
	 private static void appendElement(StringBuilder sb, String indent, String elementName, Object value) {
		 if (value == null) return;
		 appendElement(sb, indent, elementName, value.toString());
	 }
	 private static String escapeXml(String s) {
		 if (s == null) return null;
		 StringBuilder sb = new StringBuilder();
		 for (int i = 0;
		 i < s.length();
		 i++) {
			 char c = s.charAt(i);
			 if (c == '<') {
				 sb.append(""&lt;
				"");
			 }
			 else if (c == '>') {
				 sb.append(""&gt;
				"");
			 }
			 else if (c == '\'') {
				 sb.append(""&apos;
				"");
			 }
			 else if (c == '&') {
				 sb.append(""&amp;
				"");
			 }
			 else if (c == '""') {
				 sb.append(""&quot;
				"");
			 }
			 else {
				 sb.append(c);
			 }
		 }
		 return sb.toString();
	 }
	 public void configureContext(Context context) {
		 context.setPublicId(publicId);
		 context.setEffectiveMajorVersion(getMajorVersion());
		 context.setEffectiveMinorVersion(getMinorVersion());
		 for (Entry<String, String> entry : contextParams.entrySet()) {
			 context.addParameter(entry.getKey(), entry.getValue());
		 }
		 context.setDisplayName(displayName);
		 context.setDistributable(distributable);
		 for (ContextLocalEjb ejbLocalRef : ejbLocalRefs.values()) {
			 context.getNamingResources().addLocalEjb(ejbLocalRef);
		 }
		 for (ContextEjb ejbRef : ejbRefs.values()) {
			 context.getNamingResources().addEjb(ejbRef);
		 }
		 for (ContextEnvironment environment : envEntries.values()) {
			 context.getNamingResources().addEnvironment(environment);
		 }
		 for (ErrorPage errorPage : errorPages.values()) {
			 context.addErrorPage(errorPage);
		 }
		 for (FilterDef filter : filters.values()) {
			 if (filter.getAsyncSupported() == null) {
				 filter.setAsyncSupported(""false"");
			 }
			 context.addFilterDef(filter);
		 }
		 for (FilterMap filterMap : filterMaps) {
			 context.addFilterMap(filterMap);
		 }
		 for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) {
			 JspPropertyGroupDescriptor descriptor = new ApplicationJspPropertyGroupDescriptor(jspPropertyGroup);
			 context.getJspConfigDescriptor().getJspPropertyGroups().add( descriptor);
		 }
		 for (String listener : listeners) {
			 context.addApplicationListener(listener);
		 }
		 for (Entry<String, String> entry : localeEncodingMappings.entrySet()) {
			 context.addLocaleEncodingMappingParameter(entry.getKey(), entry.getValue());
		 }
		 if (loginConfig != null) {
			 context.setLoginConfig(loginConfig);
		 }
		 for (MessageDestinationRef mdr : messageDestinationRefs.values()) {
			 context.getNamingResources().addMessageDestinationRef(mdr);
		 }
		 context.setIgnoreAnnotations(metadataComplete);
		 for (Entry<String, String> entry : mimeMappings.entrySet()) {
			 context.addMimeMapping(entry.getKey(), entry.getValue());
		 }
		 for (ContextResourceEnvRef resource : resourceEnvRefs.values()) {
			 context.getNamingResources().addResourceEnvRef(resource);
		 }
		 for (ContextResource resource : resourceRefs.values()) {
			 context.getNamingResources().addResource(resource);
		 }
		 for (SecurityConstraint constraint : securityConstraints) {
			 context.addConstraint(constraint);
		 }
		 for (String role : securityRoles) {
			 context.addSecurityRole(role);
		 }
		 for (ContextService service : serviceRefs.values()) {
			 context.getNamingResources().addService(service);
		 }
		 for (ServletDef servlet : servlets.values()) {
			 Wrapper wrapper = context.createWrapper();
			 String jspFile = servlet.getJspFile();
			 if (jspFile != null) {
				 wrapper.setJspFile(jspFile);
			 }
			 if (servlet.getLoadOnStartup() != null) {
				 wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());
			 }
			 if (servlet.getEnabled() != null) {
				 wrapper.setEnabled(servlet.getEnabled().booleanValue());
			 }
			 wrapper.setName(servlet.getServletName());
			 Map<String,String> params = servlet.getParameterMap();
			 for (Entry<String, String> entry : params.entrySet()) {
				 wrapper.addInitParameter(entry.getKey(), entry.getValue());
			 }
			 wrapper.setRunAs(servlet.getRunAs());
			 Set<SecurityRoleRef> roleRefs = servlet.getSecurityRoleRefs();
			 for (SecurityRoleRef roleRef : roleRefs) {
				 wrapper.addSecurityReference( roleRef.getName(), roleRef.getLink());
			 }
			 wrapper.setServletClass(servlet.getServletClass());
			 MultipartDef multipartdef = servlet.getMultipartDef();
			 if (multipartdef != null) {
				 if (multipartdef.getMaxFileSize() != null && multipartdef.getMaxRequestSize()!= null && multipartdef.getFileSizeThreshold() != null) {
					 wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation(), Long.parseLong(multipartdef.getMaxFileSize()), Long.parseLong(multipartdef.getMaxRequestSize()), Integer.parseInt( multipartdef.getFileSizeThreshold())));
				 }
				 else {
					 wrapper.setMultipartConfigElement(new MultipartConfigElement( multipartdef.getLocation()));
				 }
			 }
			 if (servlet.getAsyncSupported() != null) {
				 wrapper.setAsyncSupported( servlet.getAsyncSupported().booleanValue());
			 }
			 context.addChild(wrapper);
		 }
		 for (Entry<String, String> entry : servletMappings.entrySet()) {
			 context.addServletMapping(entry.getKey(), entry.getValue());
		 }
		 if (sessionConfig != null) {
			 if (sessionConfig.getSessionTimeout() != null) {
				 context.setSessionTimeout( sessionConfig.getSessionTimeout().intValue());
			 }
			 SessionCookieConfig scc = context.getServletContext().getSessionCookieConfig();
			 scc.setName(sessionConfig.getCookieName());
			 scc.setDomain(sessionConfig.getCookieDomain());
			 scc.setPath(sessionConfig.getCookiePath());
			 scc.setComment(sessionConfig.getCookieComment());
			 if (sessionConfig.getCookieHttpOnly() != null) {
				 scc.setHttpOnly(sessionConfig.getCookieHttpOnly().booleanValue());
			 }
			 if (sessionConfig.getCookieSecure() != null) {
				 scc.setSecure(sessionConfig.getCookieSecure().booleanValue());
			 }
			 if (sessionConfig.getCookieMaxAge() != null) {
				 scc.setMaxAge(sessionConfig.getCookieMaxAge().intValue());
			 }
			 if (sessionConfig.getSessionTrackingModes().size() > 0) {
				 context.getServletContext().setSessionTrackingModes( sessionConfig.getSessionTrackingModes());
			 }
		 }
		 for (Entry<String, String> entry : taglibs.entrySet()) {
			 TaglibDescriptor descriptor = new ApplicationTaglibDescriptor( entry.getValue(), entry.getKey());
			 context.getJspConfigDescriptor().getTaglibs().add(descriptor);
		 }
		 for (String welcomeFile : welcomeFiles) {
			 context.addWelcomeFile(welcomeFile);
		 }
		 for (JspPropertyGroup jspPropertyGroup : jspPropertyGroups) {
			 String jspServletName = context.findServletMapping(""*.jsp"");
			 if (jspServletName == null) {
				 jspServletName = ""jsp"";
			 }
			 if (context.findChild(jspServletName) != null) {
				 context.addServletMapping(jspPropertyGroup.getUrlPattern(), jspServletName, true);
			 }
			 else {
				 if(log.isDebugEnabled()) log.debug(""Skiping "" + jspPropertyGroup.getUrlPattern() + "" , no servlet "" + jspServletName);
			 }
		 }
	 }
	 public boolean merge(Set<WebXml> fragments) {
		 WebXml temp = new WebXml();
		 Map<String,Boolean> mergeInjectionFlags = new HashMap<String, Boolean>();
		 for (WebXml fragment : fragments) {
			 if (!mergeMap(fragment.getContextParams(), contextParams, temp.getContextParams(), fragment, ""Context Parameter"")) {
				 return false;
			 }
		 }
		 contextParams.putAll(temp.getContextParams());
		 if (displayName == null) {
			 for (WebXml fragment : fragments) {
				 String value = fragment.getDisplayName();
				 if (value != null) {
					 if (temp.getDisplayName() == null) {
						 temp.setDisplayName(value);
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictDisplayName"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 displayName = temp.getDisplayName();
		 }
		 if (distributable) {
			 for (WebXml fragment : fragments) {
				 if (!fragment.isDistributable()) {
					 distributable = false;
					 break;
				 }
			 }
		 }
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getEjbLocalRefs(), ejbLocalRefs, temp.getEjbLocalRefs(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 ejbLocalRefs.putAll(temp.getEjbLocalRefs());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getEjbRefs(), ejbRefs, temp.getEjbRefs(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 ejbRefs.putAll(temp.getEjbRefs());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getEnvEntries(), envEntries, temp.getEnvEntries(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 envEntries.putAll(temp.getEnvEntries());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 if (!mergeMap(fragment.getErrorPages(), errorPages, temp.getErrorPages(), fragment, ""Error Page"")) {
				 return false;
			 }
		 }
		 errorPages.putAll(temp.getErrorPages());
		 for (WebXml fragment : fragments) {
			 Iterator<FilterMap> iterFilterMaps = fragment.getFilterMappings().iterator();
			 while (iterFilterMaps.hasNext()) {
				 FilterMap filterMap = iterFilterMaps.next();
				 if (filterMappingNames.contains(filterMap.getFilterName())) {
					 iterFilterMaps.remove();
				 }
			 }
		 }
		 for (WebXml fragment : fragments) {
			 for (FilterMap filterMap : fragment.getFilterMappings()) {
				 addFilterMapping(filterMap);
			 }
		 }
		 for (WebXml fragment : fragments) {
			 for (Map.Entry<String,FilterDef> entry : fragment.getFilters().entrySet()) {
				 if (filters.containsKey(entry.getKey())) {
					 mergeFilter(entry.getValue(), filters.get(entry.getKey()), false);
				 }
				 else {
					 if (temp.getFilters().containsKey(entry.getKey())) {
						 if (!(mergeFilter(entry.getValue(), temp.getFilters().get(entry.getKey()), true))) {
							 log.error(sm.getString( ""webXml.mergeConflictFilter"", entry.getKey(), fragment.getName(), fragment.getURL()));
							 return false;
						 }
					 }
					 else {
						 temp.getFilters().put(entry.getKey(), entry.getValue());
					 }
				 }
			 }
		 }
		 filters.putAll(temp.getFilters());
		 for (WebXml fragment : fragments) {
			 for (JspPropertyGroup jspPropertyGroup : fragment.getJspPropertyGroups()) {
				 addJspPropertyGroup(jspPropertyGroup);
			 }
		 }
		 for (WebXml fragment : fragments) {
			 for (String listener : fragment.getListeners()) {
				 addListener(listener);
			 }
		 }
		 for (WebXml fragment : fragments) {
			 if (!mergeMap(fragment.getLocalEncodingMappings(), localeEncodingMappings, temp.getLocalEncodingMappings(), fragment, ""Locale Encoding Mapping"")) {
				 return false;
			 }
		 }
		 localeEncodingMappings.putAll(temp.getLocalEncodingMappings());
		 if (getLoginConfig() == null) {
			 LoginConfig tempLoginConfig = null;
			 for (WebXml fragment : fragments) {
				 LoginConfig fragmentLoginConfig = fragment.loginConfig;
				 if (fragmentLoginConfig != null) {
					 if (tempLoginConfig == null || fragmentLoginConfig.equals(tempLoginConfig)) {
						 tempLoginConfig = fragmentLoginConfig;
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictLoginConfig"", fragment.getName(), fragment.getURL()));
					 }
				 }
			 }
			 loginConfig = tempLoginConfig;
		 }
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getMessageDestinationRefs(), messageDestinationRefs, temp.getMessageDestinationRefs(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 messageDestinationRefs.putAll(temp.getMessageDestinationRefs());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getMessageDestinations(), messageDestinations, temp.getMessageDestinations(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 messageDestinations.putAll(temp.getMessageDestinations());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 if (!mergeMap(fragment.getMimeMappings(), mimeMappings, temp.getMimeMappings(), fragment, ""Mime Mapping"")) {
				 return false;
			 }
		 }
		 mimeMappings.putAll(temp.getMimeMappings());
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getResourceEnvRefs(), resourceEnvRefs, temp.getResourceEnvRefs(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 resourceEnvRefs.putAll(temp.getResourceEnvRefs());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getResourceRefs(), resourceRefs, temp.getResourceRefs(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 resourceRefs.putAll(temp.getResourceRefs());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 for (SecurityConstraint constraint : fragment.getSecurityConstraints()) {
				 addSecurityConstraint(constraint);
			 }
		 }
		 for (WebXml fragment : fragments) {
			 for (String role : fragment.getSecurityRoles()) {
				 addSecurityRole(role);
			 }
		 }
		 for (WebXml fragment : fragments) {
			 if (!mergeResourceMap(fragment.getServiceRefs(), serviceRefs, temp.getServiceRefs(), mergeInjectionFlags, fragment)) {
				 return false;
			 }
		 }
		 serviceRefs.putAll(temp.getServiceRefs());
		 mergeInjectionFlags.clear();
		 for (WebXml fragment : fragments) {
			 Iterator<Map.Entry<String,String>> iterServletMaps = fragment.getServletMappings().entrySet().iterator();
			 while (iterServletMaps.hasNext()) {
				 Map.Entry<String,String> servletMap = iterServletMaps.next();
				 if (servletMappingNames.contains(servletMap.getValue())) {
					 iterServletMaps.remove();
				 }
			 }
		 }
		 for (WebXml fragment : fragments) {
			 for (Map.Entry<String,String> mapping : fragment.getServletMappings().entrySet()) {
				 addServletMapping(mapping.getKey(), mapping.getValue());
			 }
		 }
		 for (WebXml fragment : fragments) {
			 for (Map.Entry<String,ServletDef> entry : fragment.getServlets().entrySet()) {
				 if (servlets.containsKey(entry.getKey())) {
					 mergeServlet(entry.getValue(), servlets.get(entry.getKey()), false);
				 }
				 else {
					 if (temp.getServlets().containsKey(entry.getKey())) {
						 if (!(mergeServlet(entry.getValue(), temp.getServlets().get(entry.getKey()), true))) {
							 log.error(sm.getString( ""webXml.mergeConflictServlet"", entry.getKey(), fragment.getName(), fragment.getURL()));
							 return false;
						 }
					 }
					 else {
						 temp.getServlets().put(entry.getKey(), entry.getValue());
					 }
				 }
			 }
		 }
		 servlets.putAll(temp.getServlets());
		 if (sessionConfig.getSessionTimeout() == null) {
			 for (WebXml fragment : fragments) {
				 Integer value = fragment.getSessionConfig().getSessionTimeout();
				 if (value != null) {
					 if (temp.getSessionConfig().getSessionTimeout() == null) {
						 temp.getSessionConfig().setSessionTimeout(value.toString());
					 }
					 else if (value.equals( temp.getSessionConfig().getSessionTimeout())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionTimeout"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 if (temp.getSessionConfig().getSessionTimeout() != null) {
				 sessionConfig.setSessionTimeout( temp.getSessionConfig().getSessionTimeout().toString());
			 }
		 }
		 if (sessionConfig.getCookieName() == null) {
			 for (WebXml fragment : fragments) {
				 String value = fragment.getSessionConfig().getCookieName();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookieName() == null) {
						 temp.getSessionConfig().setCookieName(value);
					 }
					 else if (value.equals( temp.getSessionConfig().getCookieName())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookieName"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 sessionConfig.setCookieName( temp.getSessionConfig().getCookieName());
		 }
		 if (sessionConfig.getCookieDomain() == null) {
			 for (WebXml fragment : fragments) {
				 String value = fragment.getSessionConfig().getCookieDomain();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookieDomain() == null) {
						 temp.getSessionConfig().setCookieDomain(value);
					 }
					 else if (value.equals( temp.getSessionConfig().getCookieDomain())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookieDomain"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 sessionConfig.setCookieDomain( temp.getSessionConfig().getCookieDomain());
		 }
		 if (sessionConfig.getCookiePath() == null) {
			 for (WebXml fragment : fragments) {
				 String value = fragment.getSessionConfig().getCookiePath();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookiePath() == null) {
						 temp.getSessionConfig().setCookiePath(value);
					 }
					 else if (value.equals( temp.getSessionConfig().getCookiePath())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookiePath"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 sessionConfig.setCookiePath( temp.getSessionConfig().getCookiePath());
		 }
		 if (sessionConfig.getCookieComment() == null) {
			 for (WebXml fragment : fragments) {
				 String value = fragment.getSessionConfig().getCookieComment();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookieComment() == null) {
						 temp.getSessionConfig().setCookieComment(value);
					 }
					 else if (value.equals( temp.getSessionConfig().getCookieComment())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookieComment"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 sessionConfig.setCookieComment( temp.getSessionConfig().getCookieComment());
		 }
		 if (sessionConfig.getCookieHttpOnly() == null) {
			 for (WebXml fragment : fragments) {
				 Boolean value = fragment.getSessionConfig().getCookieHttpOnly();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookieHttpOnly() == null) {
						 temp.getSessionConfig().setCookieHttpOnly(value.toString());
					 }
					 else if (value.equals( temp.getSessionConfig().getCookieHttpOnly())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookieHttpOnly"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 if (temp.getSessionConfig().getCookieHttpOnly() != null) {
				 sessionConfig.setCookieHttpOnly( temp.getSessionConfig().getCookieHttpOnly().toString());
			 }
		 }
		 if (sessionConfig.getCookieSecure() == null) {
			 for (WebXml fragment : fragments) {
				 Boolean value = fragment.getSessionConfig().getCookieSecure();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookieSecure() == null) {
						 temp.getSessionConfig().setCookieSecure(value.toString());
					 }
					 else if (value.equals( temp.getSessionConfig().getCookieSecure())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookieSecure"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 if (temp.getSessionConfig().getCookieSecure() != null) {
				 sessionConfig.setCookieSecure( temp.getSessionConfig().getCookieSecure().toString());
			 }
		 }
		 if (sessionConfig.getCookieMaxAge() == null) {
			 for (WebXml fragment : fragments) {
				 Integer value = fragment.getSessionConfig().getCookieMaxAge();
				 if (value != null) {
					 if (temp.getSessionConfig().getCookieMaxAge() == null) {
						 temp.getSessionConfig().setCookieMaxAge(value.toString());
					 }
					 else if (value.equals( temp.getSessionConfig().getCookieMaxAge())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionCookieMaxAge"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 if (temp.getSessionConfig().getCookieMaxAge() != null) {
				 sessionConfig.setCookieMaxAge( temp.getSessionConfig().getCookieMaxAge().toString());
			 }
		 }
		 if (sessionConfig.getSessionTrackingModes().size() == 0) {
			 for (WebXml fragment : fragments) {
				 EnumSet<SessionTrackingMode> value = fragment.getSessionConfig().getSessionTrackingModes();
				 if (value.size() > 0) {
					 if (temp.getSessionConfig().getSessionTrackingModes().size() == 0) {
						 temp.getSessionConfig().getSessionTrackingModes().addAll(value);
					 }
					 else if (value.equals( temp.getSessionConfig().getSessionTrackingModes())) {
					 }
					 else {
						 log.error(sm.getString( ""webXml.mergeConflictSessionTrackingMode"", fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
			 }
			 sessionConfig.getSessionTrackingModes().addAll( temp.getSessionConfig().getSessionTrackingModes());
		 }
		 for (WebXml fragment : fragments) {
			 if (!mergeMap(fragment.getTaglibs(), taglibs, temp.getTaglibs(), fragment, ""Taglibs"")) {
				 return false;
			 }
		 }
		 taglibs.putAll(temp.getTaglibs());
		 for (WebXml fragment : fragments) {
			 for (String welcomeFile : fragment.getWelcomeFiles()) {
				 addWelcomeFile(welcomeFile);
			 }
		 }
		 return true;
	 }
	 private static <T extends ResourceBase> boolean mergeResourceMap( Map<String, T> fragmentResources, Map<String, T> mainResources, Map<String, T> tempResources, Map<String,Boolean> mergeInjectionFlags, WebXml fragment) {
		 for (T resource : fragmentResources.values()) {
			 String resourceName = resource.getName();
			 boolean mergeInjectionFlag = false;
			 if (mainResources.containsKey(resourceName)) {
				 if (mergeInjectionFlags.containsKey(resourceName)) {
					 mergeInjectionFlag = mergeInjectionFlags.get(resourceName).booleanValue();
				 }
				 else {
					 if (mainResources.get( resourceName).getInjectionTargets().size() == 0) {
						 mergeInjectionFlag = true;
					 }
					 mergeInjectionFlags.put(resourceName, Boolean.valueOf(mergeInjectionFlag));
				 }
				 if (mergeInjectionFlag) {
					 mainResources.get(resourceName).getInjectionTargets().addAll( resource.getInjectionTargets());
				 }
			 }
			 else {
				 if (tempResources.containsKey(resourceName)) {
					 log.error(sm.getString( ""webXml.mergeConflictResource"", resourceName, fragment.getName(), fragment.getURL()));
					 return false;
				 }
				 tempResources.put(resourceName, resource);
			 }
		 }
		 return true;
	 }
	 private static <T> boolean mergeMap(Map<String,T> fragmentMap, Map<String,T> mainMap, Map<String,T> tempMap, WebXml fragment, String mapName) {
		 for (Entry<String, T> entry : fragmentMap.entrySet()) {
			 final String key = entry.getKey();
			 if (!mainMap.containsKey(key)) {
				 T value = entry.getValue();
				 if (tempMap.containsKey(key)) {
					 if (value != null && !value.equals( tempMap.get(key))) {
						 log.error(sm.getString( ""webXml.mergeConflictString"", mapName, key, fragment.getName(), fragment.getURL()));
						 return false;
					 }
				 }
				 else {
					 tempMap.put(key, value);
				 }
			 }
		 }
		 return true;
	 }
	 private static boolean mergeFilter(FilterDef src, FilterDef dest, boolean failOnConflict) {
		 if (dest.getAsyncSupported() == null) {
			 dest.setAsyncSupported(src.getAsyncSupported());
		 }
		 else if (src.getAsyncSupported() != null) {
			 if (failOnConflict && !src.getAsyncSupported().equals(dest.getAsyncSupported())) {
				 return false;
			 }
		 }
		 if (dest.getFilterClass() == null) {
			 dest.setFilterClass(src.getFilterClass());
		 }
		 else if (src.getFilterClass() != null) {
			 if (failOnConflict && !src.getFilterClass().equals(dest.getFilterClass())) {
				 return false;
			 }
		 }
		 for (Map.Entry<String,String> srcEntry : src.getParameterMap().entrySet()) {
			 if (dest.getParameterMap().containsKey(srcEntry.getKey())) {
				 if (failOnConflict && !dest.getParameterMap().get( srcEntry.getKey()).equals(srcEntry.getValue())) {
					 return false;
				 }
			 }
			 else {
				 dest.addInitParameter(srcEntry.getKey(), srcEntry.getValue());
			 }
		 }
		 return true;
	 }
	 private static boolean mergeServlet(ServletDef src, ServletDef dest, boolean failOnConflict) {
		 if (dest.getServletClass() != null && dest.getJspFile() != null) {
			 return false;
		 }
		 if (src.getServletClass() != null && src.getJspFile() != null) {
			 return false;
		 }
		 if (dest.getServletClass() == null && dest.getJspFile() == null) {
			 dest.setServletClass(src.getServletClass());
			 dest.setJspFile(src.getJspFile());
		 }
		 else if (failOnConflict) {
			 if (src.getServletClass() != null && (dest.getJspFile() != null || !src.getServletClass().equals(dest.getServletClass()))) {
				 return false;
			 }
			 if (src.getJspFile() != null && (dest.getServletClass() != null || !src.getJspFile().equals(dest.getJspFile()))) {
				 return false;
			 }
		 }
		 for (SecurityRoleRef securityRoleRef : src.getSecurityRoleRefs()) {
			 dest.addSecurityRoleRef(securityRoleRef);
		 }
		 if (dest.getLoadOnStartup() == null) {
			 if (src.getLoadOnStartup() != null) {
				 dest.setLoadOnStartup(src.getLoadOnStartup().toString());
			 }
		 }
		 else if (src.getLoadOnStartup() != null) {
			 if (failOnConflict && !src.getLoadOnStartup().equals(dest.getLoadOnStartup())) {
				 return false;
			 }
		 }
		 if (dest.getEnabled() == null) {
			 if (src.getEnabled() != null) {
				 dest.setEnabled(src.getEnabled().toString());
			 }
		 }
		 else if (src.getEnabled() != null) {
			 if (failOnConflict && !src.getEnabled().equals(dest.getEnabled())) {
				 return false;
			 }
		 }
		 for (Map.Entry<String,String> srcEntry : src.getParameterMap().entrySet()) {
			 if (dest.getParameterMap().containsKey(srcEntry.getKey())) {
				 if (failOnConflict && !dest.getParameterMap().get( srcEntry.getKey()).equals(srcEntry.getValue())) {
					 return false;
				 }
			 }
			 else {
				 dest.addInitParameter(srcEntry.getKey(), srcEntry.getValue());
			 }
		 }
		 if (dest.getMultipartDef() == null) {
			 dest.setMultipartDef(src.getMultipartDef());
		 }
		 else if (src.getMultipartDef() != null) {
			 return mergeMultipartDef(src.getMultipartDef(), dest.getMultipartDef(), failOnConflict);
		 }
		 if (dest.getAsyncSupported() == null) {
			 if (src.getAsyncSupported() != null) {
				 dest.setAsyncSupported(src.getAsyncSupported().toString());
			 }
		 }
		 else if (src.getAsyncSupported() != null) {
			 if (failOnConflict && !src.getAsyncSupported().equals(dest.getAsyncSupported())) {
				 return false;
			 }
		 }
		 return true;
	 }
	 private static boolean mergeMultipartDef(MultipartDef src, MultipartDef dest, boolean failOnConflict) {
		 if (dest.getLocation() == null) {
			 dest.setLocation(src.getLocation());
		 }
		 else if (src.getLocation() != null) {
			 if (failOnConflict && !src.getLocation().equals(dest.getLocation())) {
				 return false;
			 }
		 }
		 if (dest.getFileSizeThreshold() == null) {
			 dest.setFileSizeThreshold(src.getFileSizeThreshold());
		 }
		 else if (src.getFileSizeThreshold() != null) {
			 if (failOnConflict && !src.getFileSizeThreshold().equals( dest.getFileSizeThreshold())) {
				 return false;
			 }
		 }
		 if (dest.getMaxFileSize() == null) {
			 dest.setMaxFileSize(src.getMaxFileSize());
		 }
		 else if (src.getLocation() != null) {
			 if (failOnConflict && !src.getMaxFileSize().equals(dest.getMaxFileSize())) {
				 return false;
			 }
		 }
		 if (dest.getMaxRequestSize() == null) {
			 dest.setMaxRequestSize(src.getMaxRequestSize());
		 }
		 else if (src.getMaxRequestSize() != null) {
			 if (failOnConflict && !src.getMaxRequestSize().equals( dest.getMaxRequestSize())) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public static Set<WebXml> orderWebFragments(WebXml application, Map<String,WebXml> fragments) {
		 Set<WebXml> orderedFragments = new LinkedHashSet<WebXml>();
		 boolean absoluteOrdering = (application.getAbsoluteOrdering() != null);
		 if (absoluteOrdering) {
			 Set<String> requestedOrder = application.getAbsoluteOrdering();
			 for (String requestedName : requestedOrder) {
				 if (WebXml.ORDER_OTHERS.equals(requestedName)) {
					 for (Entry<String, WebXml> entry : fragments.entrySet()) {
						 if (!requestedOrder.contains(entry.getKey())) {
							 WebXml fragment = entry.getValue();
							 if (fragment != null) {
								 orderedFragments.add(fragment);
							 }
						 }
					 }
				 }
				 else {
					 WebXml fragment = fragments.get(requestedName);
					 if (fragment != null) {
						 orderedFragments.add(fragment);
					 }
					 else {
						 log.warn(sm.getString(""webXml.wrongFragmentName"",requestedName));
					 }
				 }
			 }
		 }
		 else {
			 List<String> order = new LinkedList<String>();
			 order.addAll(fragments.keySet());
			 for (WebXml fragment : fragments.values()) {
				 String name = fragment.getName();
				 if (fragment.getBeforeOrdering().contains(WebXml.ORDER_OTHERS)) {
					 order.remove(name);
					 order.add(0, name);
				 }
				 else if (fragment.getAfterOrdering().contains(WebXml.ORDER_OTHERS)) {
					 order.remove(name);
					 order.add(name);
				 }
			 }
			 for (WebXml fragment : fragments.values()) {
				 String name = fragment.getName();
				 for (String before : fragment.getBeforeOrdering()) {
					 if (!before.equals(WebXml.ORDER_OTHERS) && order.contains(before) && order.indexOf(before) < order.indexOf(name)) {
						 order.remove(name);
						 order.add(order.indexOf(before), name);
					 }
				 }
				 for (String after : fragment.getAfterOrdering()) {
					 if (!after.equals(WebXml.ORDER_OTHERS) && order.contains(after) && order.indexOf(after) > order.indexOf(name)) {
						 order.remove(name);
						 order.add(order.indexOf(after) + 1, name);
					 }
				 }
			 }
			 for (WebXml fragment : fragments.values()) {
				 String name = fragment.getName();
				 for (String before : fragment.getBeforeOrdering()) {
					 if (!before.equals(WebXml.ORDER_OTHERS) && order.contains(before) && order.indexOf(before) < order.indexOf(name)) {
						 throw new IllegalArgumentException(sm.getString(""""));
					 }
				 }
				 for (String after : fragment.getAfterOrdering()) {
					 if (!after.equals(WebXml.ORDER_OTHERS) && order.contains(after) && order.indexOf(after) > order.indexOf(name)) {
						 throw new IllegalArgumentException();
					 }
				 }
			 }
			 for (String name : order) {
				 orderedFragments.add(fragments.get(name));
			 }
		 }
		 return orderedFragments;
	 }
}",1,0,0,0
"public Response getSavingsTemplate(final Long officeId, final Long staffId, final String dateFormat) {
	 return bulkImportWorkbookPopulatorService.getTemplate(GlobalEntityType.SAVINGS_ACCOUNT.toString(),officeId, staffId,dateFormat);
 }",0,0,0,0
"public static class Operator extends JexlException {
	 public Operator(JexlNode node, String symbol, Throwable cause) {
		 super(node, symbol, cause);
	 }
	 public String getSymbol() {
		 return super.detailedMessage();
	 }
	 protected String detailedMessage() {
		 return ""error calling operator '"" + getSymbol() + ""'"";
	 }
 }",0,0,0,0
"public abstract class AbstractHotDeploymentTool implements HotDeploymentTool {
	 private ServerDeploy task;
	 private Path classpath;
	 private String userName;
	 private String password;
	 private String server;
	 public Path createClasspath() {
		 if (classpath == null) {
			 classpath = new Path(task.getProject());
		 }
		 return classpath.createPath();
	 }
	 protected abstract boolean isActionValid();
	 public void validateAttributes() throws BuildException {
		 if (task.getAction() == null) {
			 throw new BuildException(""The \""action\"" attribute must be set"");
		 }
		 if (!isActionValid()) {
			 throw new BuildException(""Invalid action \"""" + task.getAction() + ""\"" passed"");
		 }
		 if (classpath == null) {
			 throw new BuildException(""The classpath attribute must be set"");
		 }
	 }
	 public abstract void deploy() throws BuildException;
	 public void setTask(ServerDeploy task) {
		 this.task = task;
	 }
	 protected ServerDeploy getTask() {
		 return task;
	 }
	 public Path getClasspath() {
		 return classpath;
	 }
	 public void setClasspath(Path classpath) {
		 this.classpath = classpath;
	 }
	 public String getUserName() {
		 return userName;
	 }
	 public void setUserName(String userName) {
		 this.userName = userName;
	 }
	 public String getPassword() {
		 return password;
	 }
	 public void setPassword(String password) {
		 this.password = password;
	 }
	 public String getServer() {
		 return server;
	 }
	 public void setServer(String server) {
		 this.server = server;
	 }
}",0,0,0,0
"public final boolean isPersistent(){
	return supportsPersistence() && getFlag(FLAG_PERSISTENT);
}",0,0,0,0
"public final class LdapProtocolUtils{
	 public static final String COOKIE_DELIM = "","";
	 public static final String REPLICA_ID_PREFIX = ""rid="";
	 public static final int REPLICA_ID_PREFIX_LEN = REPLICA_ID_PREFIX.length();
	 public static final String CSN_PREFIX = ""csn="";
	 private static final int CSN_PREFIX_LEN = CSN_PREFIX.length();
	 private static final Logger LOG = LoggerFactory.getLogger( LdapProtocolUtils.class );
	 private LdapProtocolUtils() {
	 }
	 public static void setRequestControls( OperationContext opContext, Request request ) {
		 if ( request.getControls() != null ) {
			 opContext .addRequestControls( request.getControls().values().toArray( LdapProtocolConstants.EMPTY_CONTROLS ) );
		 }
	 }
	 public static void setResponseControls( OperationContext opContext, Response response ) {
		 response.addAllControls( opContext.getResponseControls() );
	 }
	 public static byte[] createCookie( int replicaId, String csn ) {
		 String replicaIdStr = StringUtils.leftPad( Integer.toString( replicaId ), 3, '0' );
		 return Strings.getBytesUtf8( REPLICA_ID_PREFIX + replicaIdStr + COOKIE_DELIM + CSN_PREFIX + csn );
	 }
	 public static boolean isValidCookie( String cookieString ) {
		 if ( ( cookieString == null ) || ( cookieString.trim().length() == 0 ) ) {
			 return false;
		 }
		 int pos = cookieString.indexOf( COOKIE_DELIM );
		 if ( pos <= REPLICA_ID_PREFIX_LEN ) {
			 return false;
		 }
		 String replicaId = cookieString.substring( REPLICA_ID_PREFIX_LEN, pos );
		 try {
			 Integer.parseInt( replicaId );
		 }
		 catch ( NumberFormatException e ) {
			 LOG.debug( ""Failed to parse the replica id {
			}
			"", replicaId );
			 return false;
		 }
		 if ( pos == cookieString.length() ) {
			 return false;
		 }
		 String csnString = cookieString.substring( pos + 1 + CSN_PREFIX_LEN );
		 return Csn.isValid( csnString );
	 }
	 public static String getCsn( String cookieString ) {
		 int pos = cookieString.indexOf( COOKIE_DELIM );
		 return cookieString.substring( pos + 1 + CSN_PREFIX_LEN );
	 }
	 public static int getReplicaId( String cookieString ) {
		 String replicaId = cookieString.substring( REPLICA_ID_PREFIX_LEN, cookieString.indexOf( COOKIE_DELIM ) );
		 return Integer.parseInt( replicaId );
	 }
}",1,0,0,0
"public class ExplainTask extends Task<ExplainWork> implements Serializable {
	 public static final String STAGE_DEPENDENCIES = ""STAGE DEPENDENCIES"";
	 private static final long serialVersionUID = 1L;
	 public static final String EXPL_COLUMN_NAME = ""Explain"";
	 private final Set<Operator<?>> visitedOps = new HashSet<Operator<?>>();
	 private boolean isLogical = false;
	 protected final Logger LOG;
	 public ExplainTask() {
		 super();
		 LOG = LoggerFactory.getLogger(this.getClass().getName());
	 }
	 static JSONObject getJSONDependencies(ExplainWork work) throws Exception {
		 assert(work.getDependency());
		 JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());
		 JSONArray inputTableInfo = new JSONArray();
		 JSONArray inputPartitionInfo = new JSONArray();
		 for (ReadEntity input: work.getInputs()) {
			 switch (input.getType()) {
				 case TABLE: Table table = input.getTable();
				 JSONObject tableInfo = new JSONObject();
				 tableInfo.put(""tablename"", table.getCompleteName());
				 tableInfo.put(""tabletype"", table.getTableType().toString());
				 if ((input.getParents() != null) && (!input.getParents().isEmpty())) {
					 tableInfo.put(""tableParents"", input.getParents().toString());
				 }
				 inputTableInfo.put(tableInfo);
				 break;
				 case PARTITION: JSONObject partitionInfo = new JSONObject();
				 partitionInfo.put(""partitionName"", input.getPartition().getCompleteName());
				 if ((input.getParents() != null) && (!input.getParents().isEmpty())) {
					 partitionInfo.put(""partitionParents"", input.getParents().toString());
				 }
				 inputPartitionInfo.put(partitionInfo);
				 break;
				 default: break;
			 }
		 }
		 outJSONObject.put(""input_tables"", inputTableInfo);
		 outJSONObject.put(""input_partitions"", inputPartitionInfo);
		 return outJSONObject;
	 }
	 public JSONObject getJSONCBOPlan(PrintStream out, ExplainWork work) throws Exception {
		 JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());
		 boolean jsonOutput = work.isFormatted();
		 String cboPlan = work.getCboPlan();
		 if (cboPlan != null) {
			 if (jsonOutput) {
				 outJSONObject.put(""CBOPlan"", cboPlan);
			 }
			 else {
				 out.println(""CBO PLAN:"");
				 out.println(cboPlan);
			 }
		 }
		 return outJSONObject;
	 }
	 public JSONObject getJSONLogicalPlan(PrintStream out, ExplainWork work) throws Exception {
		 isLogical = true;
		 JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());
		 boolean jsonOutput = work.isFormatted();
		 if (jsonOutput) {
			 out = null;
		 }
		 if (work.getParseContext() != null) {
			 if (out != null) {
				 out.print(""LOGICAL PLAN:"");
			 }
			 JSONObject jsonPlan = outputMap(work.getParseContext().getTopOps(), true, out, work.getExtended(), jsonOutput, 0);
			 if (out != null) {
				 out.println();
			 }
			 if (jsonOutput) {
				 outJSONObject.put(""LOGICAL PLAN"", jsonPlan);
			 }
		 }
		 else {
			 System.err.println(""No parse context!"");
		 }
		 return outJSONObject;
	 }
	 private static String trueCondNameVectorizationEnabled = HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED.varname + "" IS true"";
	 private static String falseCondNameVectorizationEnabled = HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED.varname + "" IS false"";
	 ImmutablePair<Boolean, JSONObject> outputPlanVectorization(PrintStream out, boolean jsonOutput) throws Exception {
		 if (out != null) {
			 out.println(""PLAN VECTORIZATION:"");
		 }
		 JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;
		 HiveConf hiveConf = queryState.getConf();
		 boolean isVectorizationEnabled = HiveConf.getBoolVar(hiveConf, HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED);
		 String isVectorizationEnabledCondName = (isVectorizationEnabled ? trueCondNameVectorizationEnabled : falseCondNameVectorizationEnabled);
		 List<String> isVectorizationEnabledCondList = Arrays.asList(isVectorizationEnabledCondName);
		 if (out != null) {
			 out.print(indentString(2));
			 out.print(""enabled: "");
			 out.println(isVectorizationEnabled);
			 out.print(indentString(2));
			 if (!isVectorizationEnabled) {
				 out.print(""enabledConditionsNotMet: "");
			 }
			 else {
				 out.print(""enabledConditionsMet: "");
			 }
			 out.println(isVectorizationEnabledCondList);
		 }
		 if (jsonOutput) {
			 json.put(""enabled"", isVectorizationEnabled);
			 JSONArray jsonArray = new JSONArray(Arrays.asList(isVectorizationEnabledCondName));
			 if (!isVectorizationEnabled) {
				 json.put(""enabledConditionsNotMet"", jsonArray);
			 }
			 else {
				 json.put(""enabledConditionsMet"", jsonArray);
			 }
		 }
		 return new ImmutablePair<Boolean, JSONObject>(isVectorizationEnabled, jsonOutput ? json : null);
	 }
	 public JSONObject getJSONPlan(PrintStream out, ExplainWork work) throws Exception {
		 return getJSONPlan(out, work.getRootTasks(), work.getFetchTask(), work.isFormatted(), work.getExtended(), work.isAppendTaskType(), work.getCboInfo(), work.getOptimizedSQL());
	 }
	 public JSONObject getJSONPlan(PrintStream out, List<Task<?>> tasks, Task<?> fetchTask, boolean jsonOutput, boolean isExtended, boolean appendTaskType, String cboInfo, String optimizedSQL) throws Exception {
		 JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());
		 if (jsonOutput) {
			 out = null;
		 }
		 if (optimizedSQL != null) {
			 if (jsonOutput) {
				 outJSONObject.put(""optimizedSQL"", optimizedSQL);
			 }
			 else {
				 out.print(""OPTIMIZED SQL: "");
				 out.println(optimizedSQL);
			 }
		 }
		 List<Task> ordered = StageIDsRearranger.getExplainOrder(conf, tasks);
		 if (fetchTask != null) {
			 fetchTask.setParentTasks((List)StageIDsRearranger.getFetchSources(tasks));
			 if (fetchTask.getNumParent() == 0) {
				 fetchTask.setRootTask(true);
			 }
			 ordered.add(fetchTask);
		 }
		 boolean suppressOthersForVectorization = false;
		 if (this.work != null && this.work.isVectorization()) {
			 ImmutablePair<Boolean, JSONObject> planVecPair = outputPlanVectorization(out, jsonOutput);
			 if (this.work.isVectorizationOnly()) {
				 suppressOthersForVectorization = !planVecPair.left;
			 }
			 if (out != null) {
				 out.println();
			 }
			 if (jsonOutput) {
				 outJSONObject.put(""PLAN VECTORIZATION"", planVecPair.right);
			 }
		 }
		 if (!suppressOthersForVectorization) {
			 JSONObject jsonDependencies = outputDependencies(out, jsonOutput, appendTaskType, ordered);
			 if (out != null) {
				 out.println();
			 }
			 if (jsonOutput) {
				 if (cboInfo != null) {
					 outJSONObject.put(""cboInfo"", cboInfo);
				 }
				 outJSONObject.put(STAGE_DEPENDENCIES, jsonDependencies);
			 }
			 JSONObject jsonPlan = outputStagePlans(out, ordered, jsonOutput, isExtended);
			 if (jsonOutput) {
				 outJSONObject.put(""STAGE PLANS"", jsonPlan);
			 }
			 if (fetchTask != null) {
				 fetchTask.setParentTasks(null);
			 }
		 }
		 return jsonOutput ? outJSONObject : null;
	 }
	 private List<String> toString(Collection<?> objects) {
		 List<String> list = new ArrayList<String>();
		 for (Object object : objects) {
			 list.add(String.valueOf(object));
		 }
		 return list;
	 }
	 private Object toJson(String header, String message, PrintStream out, ExplainWork work) throws Exception {
		 if (work.isFormatted()) {
			 return message;
		 }
		 out.print(header);
		 out.println("": "");
		 out.print(indentString(2));
		 out.println(message);
		 return null;
	 }
	 private Object toJson(String header, List<String> messages, PrintStream out, ExplainWork work) throws Exception {
		 if (work.isFormatted()) {
			 return new JSONArray(messages);
		 }
		 out.print(header);
		 out.println("": "");
		 for (String message : messages) {
			 out.print(indentString(2));
			 out.print(message);
			 out.println();
		 }
		 return null;
	 }
	 private JSONObject getLocks(PrintStream out, ExplainWork work) {
		 JSONObject jsonObject = new JSONObject(new LinkedHashMap<>());
		 boolean jsonOutput = work.isFormatted();
		 if (jsonOutput) {
			 out = null;
		 }
		 List<LockComponent> lockComponents = AcidUtils.makeLockComponents(work.getOutputs(), work.getInputs(), conf);
		 if (null != out) {
			 out.print(""LOCK INFORMATION:\n"");
		 }
		 List<ExplainLockDesc> locks = new ArrayList<>(lockComponents.size());
		 for (LockComponent component : lockComponents) {
			 ExplainLockDesc lockDesc = new ExplainLockDesc(component);
			 if (null != out) {
				 out.print(lockDesc.getFullName());
				 out.print("" -> "");
				 out.print(lockDesc.getLockType());
				 out.print('\n');
			 }
			 else {
				 locks.add(lockDesc);
			 }
		 }
		 if (jsonOutput) {
			 jsonObject.put(""LOCK INFORMATION:"", locks);
		 }
		 return jsonObject;
	 }
	 public int execute(DriverContext driverContext) {
		 PrintStream out = null;
		 try {
			 Path resFile = work.getResFile();
			 OutputStream outS = resFile.getFileSystem(conf).create(resFile);
			 out = new PrintStream(outS);
			 if (work.isCbo()) {
				 JSONObject jsonCBOPlan = getJSONCBOPlan(out, work);
				 if (work.isFormatted()) {
					 out.print(jsonCBOPlan);
				 }
			 }
			 else if (work.isLogical()) {
				 JSONObject jsonLogicalPlan = getJSONLogicalPlan(out, work);
				 if (work.isFormatted()) {
					 out.print(jsonLogicalPlan);
				 }
			 }
			 else if (work.isAuthorize()) {
				 JSONObject jsonAuth = collectAuthRelatedEntities(out, work);
				 if (work.isFormatted()) {
					 out.print(jsonAuth);
				 }
			 }
			 else if (work.getDependency()) {
				 JSONObject jsonDependencies = getJSONDependencies(work);
				 out.print(jsonDependencies);
			 }
			 else if (work.isLocks()) {
				 JSONObject jsonLocks = getLocks(out, work);
				 if(work.isFormatted()) {
					 out.print(jsonLocks);
				 }
			 }
			 else if (work.isAst()) {
				 if (work.getAstStringTree() != null) {
					 outputAST(work.getAstStringTree(), out, work.isFormatted(), 0);
				 }
			 }
			 else {
				 if (work.isUserLevelExplain()) {
					 JsonParser jsonParser = JsonParserFactory.getParser(conf);
					 work.getConfig().setFormatted(true);
					 JSONObject jsonPlan = getJSONPlan(out, work);
					 if (work.getCboInfo() != null) {
						 jsonPlan.put(""cboInfo"", work.getCboInfo());
					 }
					 try {
						 jsonParser.print(jsonPlan, out);
					 }
					 catch (Exception e) {
						 LOG.error(""Running explain user level has problem."" + "" Falling back to normal explain."", e);
						 work.getConfig().setFormatted(false);
						 work.getConfig().setUserLevelExplain(false);
						 jsonPlan = getJSONPlan(out, work);
					 }
				 }
				 else {
					 JSONObject jsonPlan = getJSONPlan(out, work);
					 if (work.isFormatted()) {
						 JsonParser jsonParser = JsonParserFactory.getParser(conf);
						 if (jsonParser != null) {
							 jsonParser.print(jsonPlan, null);
							 LOG.info(""JsonPlan is augmented to {
							}
							"", jsonPlan);
						 }
						 out.print(jsonPlan);
					 }
				 }
			 }
			 out.close();
			 out = null;
			 return (0);
		 }
		 catch (Exception e) {
			 LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));
			 setException(e);
			 return (1);
		 }
		 finally {
			 IOUtils.closeStream(out);
		 }
	 }
	 JSONObject collectAuthRelatedEntities(PrintStream out, ExplainWork work) throws Exception {
		 BaseSemanticAnalyzer analyzer = work.getAnalyzer();
		 HiveOperation operation = queryState.getHiveOperation();
		 JSONObject object = new JSONObject(new LinkedHashMap<>());
		 Object jsonInput = toJson(""INPUTS"", toString(analyzer.getInputs()), out, work);
		 if (work.isFormatted()) {
			 object.put(""INPUTS"", jsonInput);
		 }
		 Object jsonOutput = toJson(""OUTPUTS"", toString(analyzer.getOutputs()), out, work);
		 if (work.isFormatted()) {
			 object.put(""OUTPUTS"", jsonOutput);
		 }
		 String userName = SessionState.get().getAuthenticator().getUserName();
		 Object jsonUser = toJson(""CURRENT_USER"", userName, out, work);
		 if (work.isFormatted()) {
			 object.put(""CURRENT_USER"", jsonUser);
		 }
		 Object jsonOperation = toJson(""OPERATION"", operation.name(), out, work);
		 if (work.isFormatted()) {
			 object.put(""OPERATION"", jsonOperation);
		 }
		 if (analyzer.skipAuthorization()) {
			 return object;
		 }
		 final List<String> exceptions = new ArrayList<String>();
		 Object delegate = SessionState.get().getActiveAuthorizer();
		 if (delegate != null) {
			 Class itface = SessionState.get().getAuthorizerInterface();
			 Object authorizer = AuthorizationFactory.create(delegate, itface, new AuthorizationFactory.AuthorizationExceptionHandler() {
				 public void exception(Exception exception) {
					 exceptions.add(exception.getMessage());
				 }
			 }
			);
			 SessionState.get().setActiveAuthorizer(authorizer);
			 try {
				 Driver.doAuthorization(queryState.getHiveOperation(), analyzer, """");
			 }
			 finally {
				 SessionState.get().setActiveAuthorizer(delegate);
			 }
		 }
		 if (!exceptions.isEmpty()) {
			 Object jsonFails = toJson(""AUTHORIZATION_FAILURES"", exceptions, out, work);
			 if (work.isFormatted()) {
				 object.put(""AUTHORIZATION_FAILURES"", jsonFails);
			 }
		 }
		 return object;
	 }
	 private static String indentString(int indent) {
		 StringBuilder sb = new StringBuilder();
		 for (int i = 0;
		 i < indent;
		 ++i) {
			 sb.append("" "");
		 }
		 return sb.toString();
	 }
	 JSONObject outputMap(Map<?, ?> mp, boolean hasHeader, PrintStream out, boolean extended, boolean jsonOutput, int indent) throws Exception {
		 TreeMap<Object, Object> tree = getBasictypeKeyedMap(mp);
		 JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;
		 if (out != null && hasHeader && !mp.isEmpty()) {
			 out.println();
		 }
		 for (Entry<?, ?> ent : tree.entrySet()) {
			 if (out != null) {
				 out.print(indentString(indent));
				 out.print(ent.getKey());
				 out.print("" "");
			 }
			 if (isPrintable(ent.getValue())) {
				 if (out != null) {
					 out.print(ent.getValue());
					 out.println();
				 }
				 if (jsonOutput) {
					 json.put(ent.getKey().toString(), ent.getValue().toString());
				 }
			 }
			 else if (ent.getValue() instanceof List) {
				 if (ent.getValue() != null && !((List<?>)ent.getValue()).isEmpty() && ((List<?>)ent.getValue()).get(0) != null && ((List<?>)ent.getValue()).get(0) instanceof TezWork.Dependency) {
					 if (out != null) {
						 boolean isFirst = true;
						 for (TezWork.Dependency dep: (List<TezWork.Dependency>)ent.getValue()) {
							 if (!isFirst) {
								 out.print("", "");
							 }
							 else {
								 out.print(""<- "");
								 isFirst = false;
							 }
							 out.print(dep.getName());
							 out.print("" ("");
							 out.print(dep.getType());
							 out.print("")"");
						 }
						 out.println();
					 }
					 if (jsonOutput) {
						 for (TezWork.Dependency dep: (List<TezWork.Dependency>)ent.getValue()) {
							 JSONObject jsonDep = new JSONObject(new LinkedHashMap<>());
							 jsonDep.put(""parent"", dep.getName());
							 jsonDep.put(""type"", dep.getType());
							 json.accumulate(ent.getKey().toString(), jsonDep);
						 }
					 }
				 }
				 else if (ent.getValue() != null && !((List<?>) ent.getValue()).isEmpty() && ((List<?>) ent.getValue()).get(0) != null && ((List<?>) ent.getValue()).get(0) instanceof SparkWork.Dependency) {
					 if (out != null) {
						 boolean isFirst = true;
						 for (SparkWork.Dependency dep: (List<SparkWork.Dependency>) ent.getValue()) {
							 if (!isFirst) {
								 out.print("", "");
							 }
							 else {
								 out.print(""<- "");
								 isFirst = false;
							 }
							 out.print(dep.getName());
							 out.print("" ("");
							 out.print(dep.getShuffleType());
							 out.print("", "");
							 out.print(dep.getNumPartitions());
							 out.print("")"");
						 }
						 out.println();
					 }
					 if (jsonOutput) {
						 for (SparkWork.Dependency dep: (List<SparkWork.Dependency>) ent.getValue()) {
							 JSONObject jsonDep = new JSONObject(new LinkedHashMap<>());
							 jsonDep.put(""parent"", dep.getName());
							 jsonDep.put(""type"", dep.getShuffleType());
							 jsonDep.put(""partitions"", dep.getNumPartitions());
							 json.accumulate(ent.getKey().toString(), jsonDep);
						 }
					 }
				 }
				 else {
					 if (out != null) {
						 out.print(ent.getValue().toString());
						 out.println();
					 }
					 if (jsonOutput) {
						 json.put(ent.getKey().toString(), ent.getValue().toString());
					 }
				 }
			 }
			 else if (ent.getValue() instanceof Map) {
				 String stringValue = getBasictypeKeyedMap((Map)ent.getValue()).toString();
				 if (out != null) {
					 out.print(stringValue);
					 out.println();
				 }
				 if (jsonOutput) {
					 json.put(ent.getKey().toString(), stringValue);
				 }
			 }
			 else if (ent.getValue() != null) {
				 if (out != null) {
					 out.println();
				 }
				 JSONObject jsonOut = outputPlan(ent.getValue(), out, extended, jsonOutput, jsonOutput ? 0 : indent + 2);
				 if (jsonOutput) {
					 json.put(ent.getKey().toString(), jsonOut);
				 }
			 }
			 else {
				 if (out != null) {
					 out.println();
				 }
			 }
		 }
		 return jsonOutput ? json : null;
	 }
	 private TreeMap<Object, Object> getBasictypeKeyedMap(Map<?, ?> mp) {
		 TreeMap<Object, Object> ret = new TreeMap<Object, Object>();
		 if (mp.size() > 0) {
			 Object firstKey = mp.keySet().iterator().next();
			 if (firstKey.getClass().isPrimitive() || firstKey instanceof String) {
				 ret.putAll(mp);
				 return ret;
			 }
			 else {
				 for (Entry<?, ?> entry : mp.entrySet()) {
					 ret.put(entry.getKey().toString(), entry.getValue());
				 }
			 }
		 }
		 return ret;
	 }
	 private JSONArray outputList(List<?> l, PrintStream out, boolean hasHeader, boolean extended, boolean jsonOutput, int indent, boolean inTest) throws Exception {
		 boolean first_el = true;
		 boolean nl = false;
		 JSONArray outputArray = new JSONArray();
		 for (Object o : l) {
			 if (isPrintable(o)) {
				 String delim = first_el ? "" "" : "", "";
				 if (out != null) {
					 out.print(delim);
					 out.print(o);
				 }
				 if (jsonOutput) {
					 outputArray.put(o);
				 }
				 nl = true;
			 }
			 else {
				 if (first_el && (out != null) && hasHeader) {
					 out.println();
				 }
				 JSONObject jsonOut = outputPlan(o, out, extended, jsonOutput, jsonOutput ? 0 : (hasHeader ? indent + 2 : indent), """", inTest);
				 if (jsonOutput) {
					 outputArray.put(jsonOut);
				 }
			 }
			 first_el = false;
		 }
		 if (nl && (out != null)) {
			 out.println();
		 }
		 return jsonOutput ? outputArray : null;
	 }
	 private boolean isPrintable(Object val) {
		 if (val instanceof Boolean || val instanceof String || val instanceof Integer || val instanceof Long || val instanceof Byte || val instanceof Float || val instanceof Double || val instanceof Path) {
			 return true;
		 }
		 if (val != null && val.getClass().isPrimitive()) {
			 return true;
		 }
		 return false;
	 }
	 private JSONObject outputPlan(Object work, PrintStream out, boolean extended, boolean jsonOutput, int indent) throws Exception {
		 return outputPlan(work, out, extended, jsonOutput, indent, """");
	 }
	 private boolean isInvokeVectorization(Vectorization vectorization) {
		 boolean invokeFlag = true;
		 final boolean desireOnly = this.work.isVectorizationOnly();
		 final VectorizationDetailLevel desiredVecDetailLevel = this.work.isVectorizationDetailLevel();
		 switch (vectorization) {
			 case NON_VECTORIZED: if (desireOnly) {
				 invokeFlag = false;
			 }
			 break;
			 case SUMMARY: case OPERATOR: case EXPRESSION: case DETAIL: if (vectorization.rank < desiredVecDetailLevel.rank) {
				 invokeFlag = false;
			 }
			 break;
			 case SUMMARY_PATH: case OPERATOR_PATH: if (desireOnly) {
				 if (vectorization.rank < desiredVecDetailLevel.rank) {
					 invokeFlag = false;
				 }
			 }
			 break;
			 default: throw new RuntimeException(""Unknown EXPLAIN vectorization "" + vectorization);
		 }
		 return invokeFlag;
	 }
	 private boolean isInvokeNonVectorization(Vectorization vectorization) {
		 boolean invokeFlag = true;
		 switch (vectorization) {
			 case SUMMARY: case OPERATOR: case EXPRESSION: case DETAIL: invokeFlag = false;
			 break;
			 case NON_VECTORIZED: break;
			 case SUMMARY_PATH: case OPERATOR_PATH: break;
			 default: throw new RuntimeException(""Unknown EXPLAIN vectorization "" + vectorization);
		 }
		 return invokeFlag;
	 }
	 JSONObject outputPlan(Object work, PrintStream out, boolean extended, boolean jsonOutput, int indent, String appendToHeader) throws Exception {
		 return outputPlan(work, out, extended, jsonOutput, indent, appendToHeader, queryState.getConf().getBoolVar(ConfVars.HIVE_IN_TEST));
	 }
	 public JSONObject outputPlan(Object work, PrintStream out, boolean extended, boolean jsonOutput, int indent, String appendToHeader, boolean inTest) throws Exception {
		 Annotation note = AnnotationUtils.getAnnotation(work.getClass(), Explain.class);
		 String keyJSONObject = null;
		 if (note instanceof Explain) {
			 Explain xpl_note = (Explain) note;
			 boolean invokeFlag = false;
			 if (this.work != null && this.work.isUserLevelExplain()) {
				 invokeFlag = Level.USER.in(xpl_note.explainLevels());
			 }
			 else {
				 if (extended) {
					 invokeFlag = Level.EXTENDED.in(xpl_note.explainLevels());
				 }
				 else {
					 invokeFlag = Level.DEFAULT.in(xpl_note.explainLevels()) || (this.work != null && this.work.isDebug() && Level.DEBUG.in(xpl_note.explainLevels()));
				 }
			 }
			 if (invokeFlag) {
				 Vectorization vectorization = xpl_note.vectorization();
				 if (this.work != null && this.work.isVectorization()) {
					 invokeFlag = isInvokeVectorization(vectorization);
				 }
				 else {
					 invokeFlag = isInvokeNonVectorization(vectorization);
				 }
			 }
			 if (invokeFlag) {
				 keyJSONObject = xpl_note.displayName();
				 if (out != null) {
					 out.print(indentString(indent));
					 if (appendToHeader != null && !appendToHeader.isEmpty()) {
						 out.println(xpl_note.displayName() + appendToHeader);
					 }
					 else {
						 out.println(xpl_note.displayName());
					 }
				 }
			 }
		 }
		 JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;
		 if (work instanceof Operator) {
			 Operator<? extends OperatorDesc> operator = (Operator<? extends OperatorDesc>) work;
			 if (operator.getConf() != null) {
				 String appender = isLogical ? "" ("" + operator.getOperatorId() + "")"" : """";
				 JSONObject jsonOut = outputPlan(operator.getConf(), out, extended, jsonOutput, jsonOutput ? 0 : indent, appender, inTest);
				 if (this.work != null && (this.work.isUserLevelExplain() || this.work.isFormatted())) {
					 if (jsonOut != null && jsonOut.length() > 0) {
						 ((JSONObject) jsonOut.get(JSONObject.getNames(jsonOut)[0])).put(""OperatorId:"", operator.getOperatorId());
					 }
					 if (!this.work.isUserLevelExplain() && this.work.isFormatted() && operator.getConf() instanceof ReduceSinkDesc ) {
						 ((JSONObject) jsonOut.get(JSONObject.getNames(jsonOut)[0])).put(""outputname:"", ((ReduceSinkDesc) operator.getConf()).getOutputName());
					 }
				 }
				 if (jsonOutput) {
					 json = jsonOut;
				 }
			 }
			 if (!visitedOps.contains(operator) || !isLogical) {
				 visitedOps.add(operator);
				 if (operator.getChildOperators() != null) {
					 int cindent = jsonOutput ? 0 : indent + 2;
					 for (Operator<? extends OperatorDesc> op : operator.getChildOperators()) {
						 JSONObject jsonOut = outputPlan(op, out, extended, jsonOutput, cindent, """", inTest);
						 if (jsonOutput) {
							 ((JSONObject)json.get(JSONObject.getNames(json)[0])).accumulate(""children"", jsonOut);
						 }
					 }
				 }
			 }
			 if (jsonOutput) {
				 return json;
			 }
			 return null;
		 }
		 Method[] methods = work.getClass().getMethods();
		 Arrays.sort(methods, new MethodComparator());
		 for (Method m : methods) {
			 int prop_indents = jsonOutput ? 0 : indent + 2;
			 note = AnnotationUtils.getAnnotation(m, Explain.class);
			 if (note instanceof Explain) {
				 Explain xpl_note = (Explain) note;
				 boolean invokeFlag = false;
				 if (this.work != null && this.work.isUserLevelExplain()) {
					 invokeFlag = Level.USER.in(xpl_note.explainLevels());
				 }
				 else {
					 if (extended) {
						 invokeFlag = Level.EXTENDED.in(xpl_note.explainLevels());
					 }
					 else {
						 invokeFlag = Level.DEFAULT.in(xpl_note.explainLevels()) || (this.work != null && this.work.isDebug() && Level.DEBUG.in(xpl_note.explainLevels()));
					 }
				 }
				 if (invokeFlag) {
					 Vectorization vectorization = xpl_note.vectorization();
					 if (invokeFlag) {
						 if (this.work != null && this.work.isVectorization()) {
							 invokeFlag = isInvokeVectorization(vectorization);
						 }
						 else {
							 invokeFlag = isInvokeNonVectorization(vectorization);
						 }
					 }
				 }
				 if (invokeFlag) {
					 Object val = null;
					 try {
						 if(postProcess(xpl_note)) {
							 val = m.invoke(work, inTest);
						 }
						 else{
							 val = m.invoke(work);
						 }
					 }
					 catch (InvocationTargetException ex) {
						 val = null;
					 }
					 if (val == null) {
						 continue;
					 }
					 if(xpl_note.jsonOnly() && !jsonOutput) {
						 continue;
					 }
					 String header = null;
					 boolean skipHeader = xpl_note.skipHeader();
					 boolean emptyHeader = false;
					 if (!xpl_note.displayName().equals("""")) {
						 header = indentString(prop_indents) + xpl_note.displayName() + "":"";
					 }
					 else {
						 emptyHeader = true;
						 prop_indents = indent;
						 header = indentString(prop_indents);
					 }
					 if (isPrintable(val)) {
						 if (out != null && shouldPrint(xpl_note, val)) {
							 if (!skipHeader) {
								 out.print(header);
								 out.print("" "");
							 }
							 out.println(val);
						 }
						 if (jsonOutput && shouldPrint(xpl_note, val)) {
							 json.put(header, val.toString());
						 }
						 continue;
					 }
					 int ind = 0;
					 if (!jsonOutput) {
						 if (!skipHeader) {
							 ind = prop_indents + 2;
						 }
						 else {
							 ind = indent;
						 }
					 }
					 if (val instanceof Map) {
						 Map<?, ?> mp = (Map<?, ?>) val;
						 if (out != null && !skipHeader && mp != null && !mp.isEmpty()) {
							 out.print(header);
						 }
						 JSONObject jsonOut = outputMap(mp, !skipHeader && !emptyHeader, out, extended, jsonOutput, ind);
						 if (jsonOutput && !mp.isEmpty()) {
							 json.put(header, jsonOut);
						 }
						 continue;
					 }
					 if (val instanceof List || val instanceof Set) {
						 List l = val instanceof List ? (List)val : new ArrayList((Set)val);
						 if (out != null && !skipHeader && l != null && !l.isEmpty()) {
							 out.print(header);
						 }
						 JSONArray jsonOut = outputList(l, out, !skipHeader && !emptyHeader, extended, jsonOutput, ind, inTest);
						 if (jsonOutput && !l.isEmpty()) {
							 json.put(header, jsonOut);
						 }
						 continue;
					 }
					 try {
						 if (!skipHeader && out != null) {
							 out.println(header);
						 }
						 JSONObject jsonOut = outputPlan(val, out, extended, jsonOutput, ind, """", inTest);
						 if (jsonOutput && jsonOut != null && jsonOut.length() != 0) {
							 if (!skipHeader) {
								 json.put(header, jsonOut);
							 }
							 else {
								 for(String k: JSONObject.getNames(jsonOut)) {
									 json.put(k, jsonOut.get(k));
								 }
							 }
						 }
						 continue;
					 }
					 catch (ClassCastException ce) {
					 }
				 }
			 }
		 }
		 if (jsonOutput) {
			 if (keyJSONObject != null) {
				 JSONObject ret = new JSONObject(new LinkedHashMap<>());
				 ret.put(keyJSONObject, json);
				 return ret;
			 }
			 return json;
		 }
		 return null;
	 }
	 private boolean postProcess(Explain exp) {
		 return exp.postProcess();
	 }
	 private boolean shouldPrint(Explain exp, Object val) {
		 if (exp.displayOnlyOnTrue() && (val instanceof Boolean) & !((Boolean)val)) {
			 return false;
		 }
		 return true;
	 }
	 private JSONObject outputPlan(Task<?> task, PrintStream out, JSONObject parentJSON, boolean extended, boolean jsonOutput, int indent) throws Exception {
		 if (out != null) {
			 out.print(indentString(indent));
			 out.print(""Stage: "");
			 out.print(task.getId());
			 out.print(""\n"");
		 }
		 JSONObject jsonOutputPlan = outputPlan(task.getWork(), out, extended, jsonOutput, jsonOutput ? 0 : indent + 2);
		 if (out != null) {
			 out.println();
		 }
		 if (jsonOutput) {
			 parentJSON.put(task.getId(), jsonOutputPlan);
		 }
		 return null;
	 }
	 JSONObject outputDependencies(Task<?> task, PrintStream out, JSONObject parentJson, boolean jsonOutput, boolean taskType, int indent) throws Exception {
		 boolean first = true;
		 JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;
		 if (out != null) {
			 out.print(indentString(indent));
			 out.print(task.getId());
		 }
		 if ((task.getParentTasks() == null || task.getParentTasks().isEmpty())) {
			 if (task.isRootTask()) {
				 if (out != null) {
					 out.print("" is a root stage"");
				 }
				 if (jsonOutput) {
					 json.put(""ROOT STAGE"", ""TRUE"");
				 }
			 }
		 }
		 else {
			 StringBuilder s = new StringBuilder();
			 first = true;
			 for (Task<?> parent : task.getParentTasks()) {
				 if (!first) {
					 s.append("", "");
				 }
				 first = false;
				 s.append(parent.getId());
			 }
			 if (out != null) {
				 out.print("" depends on stages: "");
				 out.print(s.toString());
			 }
			 if (jsonOutput) {
				 json.put(""DEPENDENT STAGES"", s.toString());
			 }
		 }
		 Task<?> currBackupTask = task.getBackupTask();
		 if (currBackupTask != null) {
			 if (out != null) {
				 out.print("" has a backup stage: "");
				 out.print(currBackupTask.getId());
			 }
			 if (jsonOutput) {
				 json.put(""BACKUP STAGE"", currBackupTask.getId());
			 }
		 }
		 if (task instanceof ConditionalTask && ((ConditionalTask) task).getListTasks() != null) {
			 StringBuilder s = new StringBuilder();
			 first = true;
			 for (Task<?> con : ((ConditionalTask) task).getListTasks()) {
				 if (!first) {
					 s.append("", "");
				 }
				 first = false;
				 s.append(con.getId());
			 }
			 if (out != null) {
				 out.print("" , consists of "");
				 out.print(s.toString());
			 }
			 if (jsonOutput) {
				 json.put(""CONDITIONAL CHILD TASKS"", s.toString());
			 }
		 }
		 if (taskType) {
			 if (out != null) {
				 out.print("" ["");
				 out.print(task.getType());
				 out.print(""]"");
			 }
			 if (jsonOutput) {
				 json.put(""TASK TYPE"", task.getType().name());
			 }
		 }
		 if (out != null) {
			 out.println();
		 }
		 return jsonOutput ? json : null;
	 }
	 public String outputAST(String treeString, PrintStream out, boolean jsonOutput, int indent) throws JSONException {
		 if (out != null) {
			 out.print(indentString(indent));
			 out.println(""ABSTRACT SYNTAX TREE:"");
			 out.print(indentString(indent + 2));
			 out.println(treeString);
		 }
		 return jsonOutput ? treeString : null;
	 }
	 public JSONObject outputDependencies(PrintStream out, boolean jsonOutput, boolean appendTaskType, List<Task> tasks) throws Exception {
		 if (out != null) {
			 out.println(STAGE_DEPENDENCIES + "":"");
		 }
		 JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;
		 for (Task task : tasks) {
			 JSONObject jsonOut = outputDependencies(task, out, json, jsonOutput, appendTaskType, 2);
			 if (jsonOutput && jsonOut != null) {
				 json.put(task.getId(), jsonOut);
			 }
		 }
		 return jsonOutput ? json : null;
	 }
	 public JSONObject outputStagePlans(PrintStream out, List<Task> tasks, boolean jsonOutput, boolean isExtended) throws Exception {
		 if (out != null) {
			 out.println(""STAGE PLANS:"");
		 }
		 JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;
		 for (Task task : tasks) {
			 outputPlan(task, out, json, isExtended, jsonOutput, 2);
		 }
		 return jsonOutput ? json : null;
	 }
	 public class MethodComparator implements Comparator<Method> {
		 public int compare(Method m1, Method m2) {
			 return m1.getName().compareTo(m2.getName());
		 }
	 }
	 public StageType getType() {
		 return StageType.EXPLAIN;
	 }
	 public String getName() {
		 return ""EXPLAIN"";
	 }
	 public static List<FieldSchema> getResultSchema() {
		 FieldSchema tmpFieldSchema = new FieldSchema();
		 List<FieldSchema> colList = new ArrayList<FieldSchema>();
		 tmpFieldSchema.setName(EXPL_COLUMN_NAME);
		 tmpFieldSchema.setType(STRING_TYPE_NAME);
		 colList.add(tmpFieldSchema);
		 return colList;
	 }
	 public boolean canExecuteInParallel() {
		 return false;
	 }
}",1,0,0,0
"public class Button extends FormComponent<String> implements IFormSubmittingComponent{
	private static final long serialVersionUID = 1L;
	private boolean defaultFormProcessing = true;
	public Button(String id){
		super(id);
		setVersioned(true);
		setOutputMarkupId(true);
	}
	public Button(final String id, final IModel<String> model){
		super(id, model);
		setVersioned(true);
		setOutputMarkupId(true);
	}
	protected IModel<String> initModel(){
		return null;
	}
	public final boolean getDefaultFormProcessing(){
		return defaultFormProcessing;
	}
	public final Button setDefaultFormProcessing(boolean defaultFormProcessing){
		if (this.defaultFormProcessing != defaultFormProcessing){
			addStateChange(new Change(){
				private static final long serialVersionUID = 1L;
				boolean formerValue = Button.this.defaultFormProcessing;
				public void undo(){
					Button.this.defaultFormProcessing = formerValue;
				}
				public String toString(){
					return ""DefaultFormProcessingChange[component: "" + getPath() +"", default processing: "" + formerValue + ""]"";
				}
			}
			);
		}
		this.defaultFormProcessing = defaultFormProcessing;
		return this;
	}
	public void updateModel(){
	}
	protected String getOnClickScript(){
		return null;
	}
	protected void onComponentTag(final ComponentTag tag){
		super.onComponentTag(tag);
		try{
			String value = getDefaultModelObjectAsString();
			if (value != null && !"""".equals(value)){
				tag.put(""value"", value);
			}
		}
		catch (Exception e){
		}
		final String onClickJavaScript = getOnClickScript();
		if (onClickJavaScript != null){
			tag.put(""onclick"", onClickJavaScript);
		}
	}
	public void onSubmit(){
	}
}",0,0,0,0
"void onReadPlainValue(int sheetIndex, int rowIndex, int columnIndex, ICacheEntry entry);",0,0,0,1
"public void run() {
	 String line;
	 StringTokenizer tokens;
	 try {
		 ExchangeSessionFactory.checkConfig();
		 sendOK(""DavMail "" + DavGateway.getCurrentVersion() + "" POP ready at "" + new Date());
		 for (;
		 ;
		) {
			 line = readClient();
			 if (line == null) {
				 break;
			 }
			 tokens = new StringTokenizer(line);
			 if (tokens.hasMoreTokens()) {
				 String command = tokens.nextToken();
				 if (""QUIT"".equalsIgnoreCase(command)) {
					 if (session != null) {
						 session.purgeOldestTrashAndSentMessages();
					 }
					 sendOK(""Bye"");
					 break;
				 }
				 else if (""USER"".equalsIgnoreCase(command)) {
					 userName = null;
					 password = null;
					 session = null;
					 if (tokens.hasMoreTokens()) {
						 userName = line.substring(""USER "".length());
						 sendOK(""USER : "" + userName);
						 state = State.USER;
					 }
					 else {
						 sendERR(""invalid syntax"");
						 state = State.INITIAL;
					 }
				 }
				 else if (""PASS"".equalsIgnoreCase(command)) {
					 if (state != State.USER) {
						 sendERR(""invalid state"");
						 state = State.INITIAL;
					 }
					 else if (!tokens.hasMoreTokens()) {
						 sendERR(""invalid syntax"");
					 }
					 else {
						 password = line.substring(""PASS"".length() + 1);
						 try {
							 session = ExchangeSessionFactory.getInstance(userName, password);
							 sendOK(""PASS"");
							 state = State.AUTHENTICATED;
						 }
						 catch (SocketException e) {
							 LOGGER.warn(BundleMessage.formatLog(""LOG_CLIENT_CLOSED_CONNECTION""));
						 }
						 catch (Exception e) {
							 DavGatewayTray.error(e);
							 sendERR(e);
						 }
					 }
				 }
				 else if (""CAPA"".equalsIgnoreCase(command)) {
					 sendOK(""Capability list follows"");
					 printCapabilities();
				 }
				 else if (state != State.AUTHENTICATED) {
					 sendERR(""Invalid state not authenticated"");
				 }
				 else {
					 if (messages == null) {
						 messages = session.getAllMessageUidAndSize(""INBOX"");
					 }
					 if (""STAT"".equalsIgnoreCase(command)) {
						 sendOK(messages.size() + "" "" + getTotalMessagesLength());
					 }
					 else if (""NOOP"".equalsIgnoreCase(command)) {
						 sendOK("""");
					 }
					 else if (""LIST"".equalsIgnoreCase(command)) {
						 if (tokens.hasMoreTokens()) {
							 String token = tokens.nextToken();
							 try {
								 int messageNumber = Integer.valueOf(token);
								 ExchangeSession.Message message = messages.get(messageNumber - 1);
								 sendOK("""" + messageNumber + ' ' + message.size);
							 }
							 catch (NumberFormatException e) {
								 sendERR(""Invalid message index: "" + token);
							 }
							 catch (IndexOutOfBoundsException e) {
								 sendERR(""Invalid message index: "" + token);
							 }
						 }
						 else {
							 sendOK(messages.size() + "" messages ("" + getTotalMessagesLength() + "" octets)"");
							 printList();
						 }
					 }
					 else if (""UIDL"".equalsIgnoreCase(command)) {
						 if (tokens.hasMoreTokens()) {
							 String token = tokens.nextToken();
							 try {
								 int messageNumber = Integer.valueOf(token);
								 sendOK(messageNumber + "" "" + messages.get(messageNumber - 1).getUid());
							 }
							 catch (NumberFormatException e) {
								 sendERR(""Invalid message index: "" + token);
							 }
							 catch (IndexOutOfBoundsException e) {
								 sendERR(""Invalid message index: "" + token);
							 }
						 }
						 else {
							 sendOK(messages.size() + "" messages ("" + getTotalMessagesLength() + "" octets)"");
							 printUidList();
						 }
					 }
					 else if (""RETR"".equalsIgnoreCase(command)) {
						 if (tokens.hasMoreTokens()) {
							 try {
								 int messageNumber = Integer.valueOf(tokens.nextToken()) - 1;
								 ExchangeSession.Message message = messages.get(messageNumber);
								 os.write(""+OK "".getBytes(""ASCII""));
								 os.flush();
								 MessageLoadThread.loadMimeMessage(message, os);
								 sendClient("""");
								 DoubleDotOutputStream doubleDotOutputStream = new DoubleDotOutputStream(os);
								 IOUtil.write(message.getRawInputStream(), doubleDotOutputStream);
								 doubleDotOutputStream.close();
								 if (Settings.getBooleanProperty(""davmail.popMarkReadOnRetr"")) {
									 message.markRead();
								 }
							 }
							 catch (SocketException e) {
								 LOGGER.warn(BundleMessage.formatLog(""LOG_CLIENT_CLOSED_CONNECTION""));
							 }
							 catch (Exception e) {
								 DavGatewayTray.error(new BundleMessage(""LOG_ERROR_RETRIEVING_MESSAGE""), e);
								 sendERR(""error retrieving message "" + e + ' ' + e.getMessage());
							 }
						 }
						 else {
							 sendERR(""invalid message index"");
						 }
					 }
					 else if (""DELE"".equalsIgnoreCase(command)) {
						 if (tokens.hasMoreTokens()) {
							 ExchangeSession.Message message;
							 try {
								 int messageNumber = Integer.valueOf(tokens. nextToken()) - 1;
								 message = messages.get(messageNumber);
								 message.moveToTrash();
								 sendOK(""DELETE"");
							 }
							 catch (NumberFormatException e) {
								 sendERR(""invalid message index"");
							 }
							 catch (IndexOutOfBoundsException e) {
								 sendERR(""invalid message index"");
							 }
						 }
						 else {
							 sendERR(""invalid message index"");
						 }
					 }
					 else if (""TOP"".equalsIgnoreCase(command)) {
						 int message = 0;
						 try {
							 message = Integer.valueOf(tokens.nextToken());
							 int lines = Integer.valueOf(tokens.nextToken());
							 ExchangeSession.Message m = messages.get(message - 1);
							 sendOK("""");
							 DoubleDotOutputStream doubleDotOutputStream = new DoubleDotOutputStream(os);
							 IOUtil.write(m.getRawInputStream(), new TopOutputStream(doubleDotOutputStream, lines));
							 doubleDotOutputStream.close();
						 }
						 catch (NumberFormatException e) {
							 sendERR(""invalid command"");
						 }
						 catch (IndexOutOfBoundsException e) {
							 sendERR(""invalid message index: "" + message);
						 }
						 catch (Exception e) {
							 sendERR(""error retreiving top of messages"");
							 DavGatewayTray.error(e);
						 }
					 }
					 else if (""RSET"".equalsIgnoreCase(command)) {
						 sendOK(""RSET"");
					 }
					 else {
						 sendERR(""unknown command"");
					 }
				 }
			 }
			 else {
				 sendERR(""unknown command"");
			 }
			 os.flush();
		 }
	 }
	 catch (SocketException e) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
	 }
	 catch (Exception e) {
		 DavGatewayTray.log(e);
		 try {
			 sendERR(e.getMessage());
		 }
		 catch (IOException e2) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
		 }
	 }
	 finally {
		 close();
	 }
	 DavGatewayTray.resetIcon();
 }",0,0,1,0
"public class MapFile {
	 public static final String INDEX_FILE_NAME = ""index"";
	 public static final String DATA_FILE_NAME = ""data"";
	 protected MapFile() {
	}
	 public static class Writer {
		 private SequenceFile.Writer data;
		 private SequenceFile.Writer index;
		 private int indexInterval = 128;
		 private long size;
		 private LongWritable position = new LongWritable();
		 private WritableComparator comparator;
		 private DataInputBuffer inBuf = new DataInputBuffer();
		 private DataOutputBuffer outBuf = new DataOutputBuffer();
		 private WritableComparable lastKey;
		 public Writer(FileSystem fs, String dirName, Class keyClass, Class valClass) throws IOException {
			 this(fs, dirName, WritableComparator.get(keyClass), valClass, false);
		 }
		 public Writer(FileSystem fs, String dirName, Class keyClass, Class valClass, boolean compress) throws IOException {
			 this(fs, dirName, WritableComparator.get(keyClass), valClass, compress);
		 }
		 public Writer(FileSystem fs, String dirName, WritableComparator comparator, Class valClass) throws IOException {
			 this(fs, dirName, comparator, valClass, false);
		 }
		 public Writer(FileSystem fs, String dirName, WritableComparator comparator, Class valClass, boolean compress) throws IOException {
			 this.comparator = comparator;
			 this.lastKey = comparator.newKey();
			 Path dir = new Path(dirName);
			 fs.mkdirs(dir);
			 Path dataFile = new Path(dir, DATA_FILE_NAME);
			 Path indexFile = new Path(dir, INDEX_FILE_NAME);
			 Class keyClass = comparator.getKeyClass();
			 this.data = new SequenceFile.Writer(fs, dataFile, keyClass, valClass, compress);
			 this.index = new SequenceFile.Writer(fs, indexFile, keyClass, LongWritable.class);
		 }
		 public int getIndexInterval() {
			 return indexInterval;
		 }
		 public void setIndexInterval(int interval) {
			 indexInterval = interval;
		 }
		 public synchronized void close() throws IOException {
			 data.close();
			 index.close();
		 }
		 public synchronized void append(WritableComparable key, Writable val) throws IOException {
			 checkKey(key);
			 if (size % indexInterval == 0) {
				 position.set(data.getLength());
				 index.append(key, position);
			 }
			 data.append(key, val);
			 size++;
		 }
		 private void checkKey(WritableComparable key) throws IOException {
			 if (size != 0 && comparator.compare(lastKey, key) > 0) throw new IOException(""key out of order: ""+key+"" after ""+lastKey);
			 outBuf.reset();
			 key.write(outBuf);
			 inBuf.reset(outBuf.getData(), outBuf.getLength());
			 lastKey.readFields(inBuf);
		 }
	 }
	 public static class Reader {
		 private int INDEX_SKIP = 0;
		 private WritableComparator comparator;
		 private DataOutputBuffer keyBuf = new DataOutputBuffer();
		 private DataOutputBuffer nextBuf = new DataOutputBuffer();
		 private int nextKeyLen = -1;
		 private long seekPosition = -1;
		 private int seekIndex = -1;
		 private long firstPosition;
		 private WritableComparable getKey;
		 private SequenceFile.Reader data;
		 private SequenceFile.Reader index;
		 private boolean indexClosed = false;
		 private int count = -1;
		 private WritableComparable[] keys;
		 private long[] positions;
		 public Class getKeyClass() {
			 return data.getKeyClass();
		 }
		 public Class getValueClass() {
			 return data.getValueClass();
		 }
		 public Reader(FileSystem fs, String dirName, Configuration conf) throws IOException {
			 this(fs, dirName, null, conf);
			 INDEX_SKIP = conf.getInt(""io.map.index.skip"", 0);
		 }
		 public Reader(FileSystem fs, String dirName, WritableComparator comparator, Configuration conf) throws IOException {
			 Path dir = new Path(dirName);
			 Path dataFile = new Path(dir, DATA_FILE_NAME);
			 Path indexFile = new Path(dir, INDEX_FILE_NAME);
			 this.data = new SequenceFile.Reader(fs, dataFile, conf);
			 this.firstPosition = data.getPosition();
			 if (comparator == null) this.comparator = WritableComparator.get(data.getKeyClass());
			 else this.comparator = comparator;
			 this.getKey = this.comparator.newKey();
			 this.index = new SequenceFile.Reader(fs, indexFile, conf);
		 }
		 private void readIndex() throws IOException {
			 if (this.keys != null) return;
			 this.count = 0;
			 this.keys = new WritableComparable[1024];
			 this.positions = new long[1024];
			 try {
				 int skip = INDEX_SKIP;
				 LongWritable position = new LongWritable();
				 WritableComparable lastKey = null;
				 while (true) {
					 WritableComparable k = comparator.newKey();
					 if (!index.next(k, position)) break;
					 if (lastKey != null && comparator.compare(lastKey, k) > 0) throw new IOException(""key out of order: ""+k+"" after ""+lastKey);
					 lastKey = k;
					 if (skip > 0) {
						 skip--;
						 continue;
					 }
					 else {
						 skip = INDEX_SKIP;
					 }
					 if (count == keys.length) {
						 int newLength = (keys.length*3)/2;
						 WritableComparable[] newKeys = new WritableComparable[newLength];
						 long[] newPositions = new long[newLength];
						 System.arraycopy(keys, 0, newKeys, 0, count);
						 System.arraycopy(positions, 0, newPositions, 0, count);
						 keys = newKeys;
						 positions = newPositions;
					 }
					 keys[count] = k;
					 positions[count] = position.get();
					 count++;
				 }
			 }
			 catch (EOFException e) {
				 SequenceFile.LOG.warning(""Unexpected EOF reading "" + index + "" at entry #"" + count + "". Ignoring."");
			 }
			 finally {
				indexClosed = true;
				 index.close();
			 }
		 }
		 public synchronized void reset() throws IOException {
			 data.seek(firstPosition);
		 }
		 public synchronized void finalKey(WritableComparable key) throws IOException {
			 long originalPosition = data.getPosition();
			 try {
				 readIndex();
				 if (count > 0) {
					 data.seek(positions[count-1]);
				 }
				 else {
					 reset();
				 }
				 while (data.next(key)) {
				}
			 }
			 finally {
				 data.seek(originalPosition);
			 }
		 }
		 public synchronized boolean seek(WritableComparable key) throws IOException {
			 readIndex();
			 keyBuf.reset();
			 key.write(keyBuf);
			 if (seekIndex != -1 && seekIndex+1 < count && comparator.compare(key,keys[seekIndex+1])<0 && comparator.compare(keyBuf.getData(), 0, keyBuf.getLength(), nextBuf.getData(), 0, nextKeyLen) >= 0) {
			 }
			 else {
				 seekIndex = binarySearch(key);
				 if (seekIndex < 0) seekIndex = -seekIndex-2;
				 if (seekIndex == -1) seekPosition = firstPosition;
				 else seekPosition = positions[seekIndex];
			 }
			 data.seek(seekPosition);
			 while ((nextKeyLen = data.next(nextBuf.reset())) != -1) {
				 int c = comparator.compare(keyBuf.getData(), 0, keyBuf.getLength(), nextBuf.getData(), 0, nextKeyLen);
				 if (c <= 0) {
					 data.seek(seekPosition);
					 return c == 0;
				 }
				 seekPosition = data.getPosition();
			 }
			 return false;
		 }
		 private int binarySearch(WritableComparable key) {
			 int low = 0;
			 int high = count-1;
			 while (low <= high) {
				 int mid = (low + high) >> 1;
				 WritableComparable midVal = keys[mid];
				 int cmp = comparator.compare(midVal, key);
				 if (cmp < 0) low = mid + 1;
				 else if (cmp > 0) high = mid - 1;
				 else return mid;
			 }
			 return -(low + 1);
		 }
		 public synchronized boolean next(WritableComparable key, Writable val) throws IOException {
			 return data.next(key, val);
		 }
		 public synchronized Writable get(WritableComparable key, Writable val) throws IOException {
			 if (seek(key)) {
				 next(getKey, val);
				 return val;
			 }
			 else return null;
		 }
		 public synchronized void close() throws IOException {
			 if (! indexClosed) {
				index.close();
			 }
			 data.close();
		 }
	 }
	 public static void rename(FileSystem fs, String oldName, String newName) throws IOException {
		 Path oldDir = new Path(oldName);
		 Path newDir = new Path(newName);
		 if (!fs.rename(oldDir, newDir)) {
			 throw new IOException(""Could not rename "" + oldDir + "" to "" + newDir);
		 }
	 }
	 public static void delete(FileSystem fs, String name) throws IOException {
		 Path dir = new Path(name);
		 Path data = new Path(dir, DATA_FILE_NAME);
		 Path index = new Path(dir, INDEX_FILE_NAME);
		 fs.delete(data);
		 fs.delete(index);
		 fs.delete(dir);
	 }
	 public static long fix(FileSystem fs, Path dir, Class keyClass, Class valueClass, boolean dryrun, Configuration conf) throws Exception {
		 String dr = (dryrun ? ""[DRY RUN ] "" : """");
		 Path data = new Path(dir, DATA_FILE_NAME);
		 Path index = new Path(dir, INDEX_FILE_NAME);
		 int indexInterval = 128;
		 if (!fs.exists(data)) {
			 throw new Exception(dr + ""Missing data file in "" + dir + "", impossible to fix this."");
		 }
		 if (fs.exists(index)) {
			 return -1;
		 }
		 SequenceFile.Reader dataReader = new SequenceFile.Reader(fs, data, conf);
		 if (!dataReader.getKeyClass().equals(keyClass)) {
			 throw new Exception(dr + ""Wrong key class in "" + dir + "", expected"" + keyClass.getName() + "", got "" + dataReader.getKeyClass().getName());
		 }
		 if (!dataReader.getValueClass().equals(valueClass)) {
			 throw new Exception(dr + ""Wrong value class in "" + dir + "", expected"" + valueClass.getName() + "", got "" + dataReader.getValueClass().getName());
		 }
		 long cnt = 0L;
		 Writable key = (Writable)keyClass.getConstructor(new Class[0]).newInstance(new Object[0]);
		 Writable value = (Writable)valueClass.getConstructor(new Class[0]).newInstance(new Object[0]);
		 SequenceFile.Writer indexWriter = null;
		 if (!dryrun) indexWriter = new SequenceFile.Writer(fs, index, keyClass, LongWritable.class);
		 try {
			 long pos = 0L;
			 LongWritable position = new LongWritable();
			 while(dataReader.next(key, value)) {
				 cnt++;
				 if (cnt % indexInterval == 0) {
					 position.set(pos);
					 if (!dryrun) indexWriter.append(key, position);
				 }
				 pos = dataReader.getPosition();
			 }
		 }
		 catch(Throwable t) {
		 }
		 dataReader.close();
		 if (!dryrun) indexWriter.close();
		 return cnt;
	 }
	 public static void main(String[] args) throws Exception {
		 String usage = ""Usage: MapFile inFile outFile"";
		 if (args.length != 2) {
			 System.err.println(usage);
			 System.exit(-1);
		 }
		 String in = args[0];
		 String out = args[1];
		 Configuration conf = new Configuration();
		 int ioFileBufferSize = conf.getInt(""io.file.buffer.size"", 4096);
		 FileSystem fs = new LocalFileSystem(conf);
		 MapFile.Reader reader = new MapFile.Reader(fs, in, conf);
		 MapFile.Writer writer = new MapFile.Writer(fs, out, reader.getKeyClass(), reader.getValueClass());
		 WritableComparable key = (WritableComparable)reader.getKeyClass().newInstance();
		 Writable value = (Writable)reader.getValueClass().newInstance();
		 while (reader.next(key, value)) writer.append(key, value);
		 writer.close();
	 }
}",0,0,0,0
"public static long pop_array(long A[], int wordOffset, int numWords) {
	 int n = wordOffset+numWords;
	 long tot=0, tot8=0;
	 long ones=0, twos=0, fours=0;
	 int i;
	 for (i = wordOffset;
	 i <= n - 8;
	 i+=8) {
		 long twosA,twosB,foursA,foursB,eights;
		 {
			 long b=A[i], c=A[i+1];
			 long u=ones ^ b;
			 twosA=(ones & b)|( u & c);
			 ones=u^c;
		 }
		 {
			 long b=A[i+2], c=A[i+3];
			 long u=ones^b;
			 twosB =(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursA=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 {
			 long b=A[i+4], c=A[i+5];
			 long u=ones^b;
			 twosA=(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long b=A[i+6], c=A[i+7];
			 long u=ones^b;
			 twosB=(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursB=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 {
			 long u=fours^foursA;
			 eights=(fours&foursA)|(u&foursB);
			 fours=u^foursB;
		 }
		 tot8 += pop(eights);
	 }
	 if (i<=n-4) {
		 long twosA, twosB, foursA, eights;
		 {
			 long b=A[i], c=A[i+1];
			 long u=ones ^ b;
			 twosA=(ones & b)|( u & c);
			 ones=u^c;
		 }
		 {
			 long b=A[i+2], c=A[i+3];
			 long u=ones^b;
			 twosB =(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursA=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 eights=fours&foursA;
		 fours=fours^foursA;
		 tot8 += pop(eights);
		 i+=4;
	 }
	 if (i<=n-2) {
		 long b=A[i], c=A[i+1];
		 long u=ones ^ b;
		 long twosA=(ones & b)|( u & c);
		 ones=u^c;
		 long foursA=twos&twosA;
		 twos=twos^twosA;
		 long eights=fours&foursA;
		 fours=fours^foursA;
		 tot8 += pop(eights);
		 i+=2;
	 }
	 if (i<n) {
		 tot += pop(A[i]);
	 }
	 tot += (pop(fours)<<2) + (pop(twos)<<1) + pop(ones) + (tot8<<3);
	 return tot;
 }",0,0,1,0
"public class CookieValuePersister implements IValuePersister{
	private static final long serialVersionUID = 1L;
	private final static Logger log = LoggerFactory.getLogger(CookieValuePersister.class);
	private final CookieValuePersisterSettings settings;
	public CookieValuePersister(){
		settings = new CookieValuePersisterSettings();
	}
	public CookieValuePersister(final CookieValuePersisterSettings settings){
		this.settings = settings;
	}
	public void clear(final String key){
		final Cookie cookie = getCookie(getSaveKey(key));
		if (cookie != null){
			clear(cookie);
		}
	}
	public void clear(FormComponent<?> formComponent){
		clear(formComponent.getPageRelativePath());
	}
	public String load(final String key){
		final Cookie cookie = getCookie(getSaveKey(key));
		if (cookie != null){
			return cookie.getValue();
		}
		return null;
	}
	public void load(FormComponent<?> formComponent){
		String value = load(formComponent.getPageRelativePath());
		if (value != null){
			formComponent.setModelValue(value.split(FormComponent.VALUE_SEPARATOR));
		}
	}
	public void save(String key, final String value){
		key = getSaveKey(key);
		Cookie cookie = getCookie(key);
		if (cookie == null){
			cookie = new Cookie(key, value == null ? """" : value);
		}
		else{
			cookie.setValue(value == null ? """" : value);
		}
		cookie.setSecure(false);
		cookie.setMaxAge(settings.getMaxAge());
		save(cookie);
	}
	public void save(FormComponent<?> formComponent){
		save(formComponent.getPageRelativePath(), formComponent.getValue());
	}
	protected String getSaveKey(String key){
		if (Strings.isEmpty(key)){
			throw new IllegalArgumentException(""A Cookie name can not be null or empty"");
		}
		key = key.replace(""."", "".."");
		key = key.replace("":"", ""."");
		return key;
	}
	private void clear(final Cookie cookie){
		if (cookie != null){
			cookie.setMaxAge(0);
			cookie.setValue(null);
			save(cookie);
			if (log.isDebugEnabled()){
				log.debug(""Removed Cookie: "" + cookie.getName());
			}
		}
	}
	private Cookie getCookie(final String name){
		try{
			Cookie cookie = getWebRequest().getCookie(name);
			if (log.isDebugEnabled()){
				if (cookie != null){
					log.debug(""Found Cookie with name="" + name + "" and request URI="" +getWebRequest().getHttpServletRequest().getRequestURI());
				}
				else{
					log.debug(""Unable to find Cookie with name="" + name + "" and request URI="" +getWebRequest().getHttpServletRequest().getRequestURI());
				}
			}
			return cookie;
		}
		catch (NullPointerException ex){
		}
		return null;
	}
	private Cookie save(final Cookie cookie){
		if (cookie == null){
			return null;
		}
		final String comment = settings.getComment();
		if (comment != null){
			cookie.setComment(comment);
		}
		final String domain = settings.getDomain();
		if (domain != null){
			cookie.setDomain(domain);
		}
		String path = getWebRequest().getHttpServletRequest().getContextPath();
		if (Strings.isEmpty(path)){
			path = ""/"";
		}
		cookie.setPath(path);
		cookie.setVersion(settings.getVersion());
		cookie.setSecure(settings.getSecure());
		getWebResponse().addCookie(cookie);
		if (log.isDebugEnabled()){
			log.debug(""Cookie saved: "" + cookieToDebugString(cookie) + "";
			 request URI="" +getWebRequest().getHttpServletRequest().getRequestURI());
		}
		return cookie;
	}
	private WebRequest getWebRequest(){
		return (WebRequest)RequestCycle.get().getRequest();
	}
	private WebResponse getWebResponse(){
		return (WebResponse)RequestCycle.get().getResponse();
	}
	private String cookieToDebugString(final Cookie cookie){
		return ""[Cookie "" + "" name = "" + cookie.getName() + "", value = "" + cookie.getValue() +"", domain = "" + cookie.getDomain() + "", path = "" + cookie.getPath() + "", maxAge = "" +Time.valueOf(cookie.getMaxAge()).toDateString() + ""("" + cookie.getMaxAge() + "")"" + ""]"";
	}
}",0,0,0,0
"public class IncludeTransform implements Transform {
	 public List<Metric> transform(QueryContext context, List<Metric> metrics) {
		 throw new UnsupportedOperationException(""Include Transform cannot be performed without an regular expression."");
	 }
	 public List<Metric> transform(QueryContext queryContext, List<Metric> metrics, List<String> constants) {
		 SystemAssert.requireArgument(metrics != null, ""Cannot transform null metric/metrics"");
		 SystemAssert.requireArgument(constants != null && constants.size() == 1, ""Include transform require regex, only exactly one constant allowed."");
		 SystemAssert.requireArgument(!constants.get(0).equals(""""), ""Expression can't be an empty string"");
		 List<Metric> includeMetricList = new ArrayList<Metric>();
		 String expr = constants.get(0);
		 for (Metric metric : metrics) {
			 String name = metric.getIdentifier();
			 boolean isMatch = name.matches(expr);
			 if (isMatch) {
				 includeMetricList.add(metric);
			 }
		 }
		 return includeMetricList;
	 }
	 public String getResultScopeName() {
		 return TransformFactory.Function.INCLUDE.name();
	 }
	 public List<Metric> transform(QueryContext queryContext, List<Metric>... listOfList) {
		 throw new UnsupportedOperationException(""Include doesn't need list of list!"");
	 }
}",0,0,0,0
"public class ReflectUtil {
	 private ReflectUtil() {
	 }
	 public static Object newInstance(Class ofClass, Class[] argTypes, Object[] args) {
		 try {
			 Constructor con = ofClass.getConstructor(argTypes);
			 return con.newInstance(args);
		 }
		 catch (Exception t) {
			 throwBuildException(t);
			 return null;
		 }
	 }
	 public static Object invoke(Object obj, String methodName) {
		 try {
			 Method method;
			 method = obj.getClass().getMethod( methodName, (Class[]) null);
			 return method.invoke(obj, (Object[]) null);
		 }
		 catch (Exception t) {
			 throwBuildException(t);
			 return null;
		 }
	 }
	 public static Object invokeStatic(Object obj, String methodName) {
		 try {
			 Method method;
			 method = ((Class) obj).getMethod( methodName, (Class[]) null);
			 return method.invoke(obj, (Object[]) null);
		 }
		 catch (Exception t) {
			 throwBuildException(t);
			 return null;
		 }
	 }
	 public static Object invoke( Object obj, String methodName, Class argType, Object arg) {
		 try {
			 Method method;
			 method = obj.getClass().getMethod( methodName, new Class[] {
			argType}
			);
			 return method.invoke(obj, new Object[] {
			arg}
			);
		 }
		 catch (Exception t) {
			 throwBuildException(t);
			 return null;
		 }
	 }
	 public static Object invoke( Object obj, String methodName, Class argType1, Object arg1, Class argType2, Object arg2) {
		 try {
			 Method method;
			 method = obj.getClass().getMethod( methodName, new Class[] {
			argType1, argType2}
			);
			 return method.invoke(obj, new Object[] {
			arg1, arg2}
			);
		 }
		 catch (Exception t) {
			 throwBuildException(t);
			 return null;
		 }
	 }
	 public static Object getField(Object obj, String fieldName) throws BuildException {
		 try {
			 Field field = obj.getClass().getDeclaredField(fieldName);
			 field.setAccessible(true);
			 return field.get(obj);
		 }
		 catch (Exception t) {
			 throwBuildException(t);
			 return null;
		 }
	 }
	 public static void throwBuildException(Exception t) throws BuildException {
		 throw toBuildException(t);
	 }
	 public static BuildException toBuildException(Exception t) {
		 if (t instanceof InvocationTargetException) {
			 Throwable t2 = ((InvocationTargetException) t) .getTargetException();
			 if (t2 instanceof BuildException) {
				 return (BuildException) t2;
			 }
			 return new BuildException(t2);
		 }
		 else {
			 return new BuildException(t);
		 }
	 }
	 public static boolean respondsTo(Object o, String methodName) throws BuildException {
		 try {
			 Method[] methods = o.getClass().getMethods();
			 for (int i = 0;
			 i < methods.length;
			 i++) {
				 if (methods[i].getName().equals(methodName)) {
					 return true;
				 }
			 }
			 return false;
		 }
		 catch (Exception t) {
			 throw toBuildException(t);
		 }
	 }
}",0,0,0,0
"public void updateVAAndSize(Vector oldsections, Vector newsections) {
	long codebase = findNewVA(this.BaseOfCode, oldsections, newsections);
	long codesize = findNewSize(this.BaseOfCode, oldsections, newsections);
	this.BaseOfCode = codebase;
	this.SizeOfCode = codesize;
	this.AddressOfEntryPoint = findNewVA(this.AddressOfEntryPoint, oldsections, newsections);
	long database = findNewVA(this.BaseOfData, oldsections, newsections);
	long datasize = findNewSize(this.BaseOfData, oldsections, newsections);
	this.BaseOfData = database;
	long imagesize = 0;
	for (int i=0;
	 i<newsections.size();
	 i++) {
		PESection sect = (PESection)newsections.get(i);
		long curmax = sect.VirtualAddress + sect.VirtualSize;
		if (curmax > imagesize) imagesize = curmax;
	 }
	this.SizeOfImage = imagesize;
	ExportDirectory_Size = findNewSize(ExportDirectory_VA, oldsections, newsections);
	ExportDirectory_VA = findNewVA(ExportDirectory_VA, oldsections, newsections);
	ImportDirectory_Size = findNewSize(ImportDirectory_VA, oldsections, newsections);
	ImportDirectory_VA = findNewVA(ImportDirectory_VA, oldsections, newsections);
	ResourceDirectory_Size = findNewSize(ResourceDirectory_VA, oldsections, newsections);
	ResourceDirectory_VA = findNewVA(ResourceDirectory_VA, oldsections, newsections);
	ExceptionDirectory_Size = findNewSize(ExceptionDirectory_VA, oldsections, newsections);
	ExceptionDirectory_VA = findNewVA(ExceptionDirectory_VA, oldsections, newsections);
	SecurityDirectory_Size = findNewSize(SecurityDirectory_VA, oldsections, newsections);
	SecurityDirectory_VA = findNewVA(SecurityDirectory_VA, oldsections, newsections);
	BaseRelocationTable_Size = findNewSize(BaseRelocationTable_VA, oldsections, newsections);
	BaseRelocationTable_VA = findNewVA(BaseRelocationTable_VA, oldsections, newsections);
	DebugDirectory_Size = findNewSize(DebugDirectory_VA, oldsections, newsections);
	DebugDirectory_VA = findNewVA(DebugDirectory_VA, oldsections, newsections);
	ArchitectureSpecificData_Size = findNewSize(ArchitectureSpecificData_VA, oldsections, newsections);
	ArchitectureSpecificData_VA = findNewVA(ArchitectureSpecificData_VA, oldsections, newsections);
	RVAofGP_Size = findNewSize(RVAofGP_VA, oldsections, newsections);
	RVAofGP_VA = findNewVA(RVAofGP_VA, oldsections, newsections);
	TLSDirectory_Size = findNewSize(TLSDirectory_VA, oldsections, newsections);
	TLSDirectory_VA = findNewVA(TLSDirectory_VA, oldsections, newsections);
	LoadConfigurationDirectory_Size = findNewSize(LoadConfigurationDirectory_VA, oldsections, newsections);
	LoadConfigurationDirectory_VA = findNewVA(LoadConfigurationDirectory_VA, oldsections, newsections);
	BoundImportDirectoryinheaders_Size = findNewSize(BoundImportDirectoryinheaders_VA, oldsections, newsections);
	BoundImportDirectoryinheaders_VA = findNewVA(BoundImportDirectoryinheaders_VA, oldsections, newsections);
	ImportAddressTable_Size = findNewSize(ImportAddressTable_VA, oldsections, newsections);
	ImportAddressTable_VA = findNewVA(ImportAddressTable_VA, oldsections, newsections);
	DelayLoadImportDescriptors_Size = findNewSize(DelayLoadImportDescriptors_VA, oldsections, newsections);
	DelayLoadImportDescriptors_VA = findNewVA(DelayLoadImportDescriptors_VA, oldsections, newsections);
	COMRuntimedescriptor_Size = findNewSize(COMRuntimedescriptor_VA, oldsections, newsections);
	COMRuntimedescriptor_VA = findNewVA(COMRuntimedescriptor_VA, oldsections, newsections);
 }",0,0,1,0
"public class XMLJUnitResultFormatter implements JUnitResultFormatter, XMLConstants {
	 private static final double ONE_SECOND = 1000.0;
	 private static final String UNKNOWN = ""unknown"";
	 private static DocumentBuilder getDocumentBuilder() {
		 try {
			 return DocumentBuilderFactory.newInstance().newDocumentBuilder();
		 }
		 catch (Exception exc) {
			 throw new ExceptionInInitializerError(exc);
		 }
	 }
	 private Document doc;
	 private Element rootElement;
	 private Hashtable testElements = new Hashtable();
	 private Hashtable failedTests = new Hashtable();
	 private Hashtable testStarts = new Hashtable();
	 private OutputStream out;
	 public XMLJUnitResultFormatter() {
	 }
	 public void setOutput(OutputStream out) {
		 this.out = out;
	 }
	 public void setSystemOutput(String out) {
		 formatOutput(SYSTEM_OUT, out);
	 }
	 public void setSystemError(String out) {
		 formatOutput(SYSTEM_ERR, out);
	 }
	 public void startTestSuite(JUnitTest suite) {
		 doc = getDocumentBuilder().newDocument();
		 rootElement = doc.createElement(TESTSUITE);
		 String n = suite.getName();
		 rootElement.setAttribute(ATTR_NAME, n == null ? UNKNOWN : n);
		 final String timestamp = DateUtils.format(new Date(), DateUtils.ISO8601_DATETIME_PATTERN);
		 rootElement.setAttribute(TIMESTAMP, timestamp);
		 rootElement.setAttribute(HOSTNAME, getHostname());
		 Element propsElement = doc.createElement(PROPERTIES);
		 rootElement.appendChild(propsElement);
		 Properties props = suite.getProperties();
		 if (props != null) {
			 Enumeration e = props.propertyNames();
			 while (e.hasMoreElements()) {
				 String name = (String) e.nextElement();
				 Element propElement = doc.createElement(PROPERTY);
				 propElement.setAttribute(ATTR_NAME, name);
				 propElement.setAttribute(ATTR_VALUE, props.getProperty(name));
				 propsElement.appendChild(propElement);
			 }
		 }
	 }
	 private String getHostname() {
		 try {
			 return InetAddress.getLocalHost().getHostName();
		 }
		 catch (UnknownHostException e) {
			 return ""localhost"";
		 }
	 }
	 public void endTestSuite(JUnitTest suite) throws BuildException {
		 rootElement.setAttribute(ATTR_TESTS, """" + suite.runCount());
		 rootElement.setAttribute(ATTR_FAILURES, """" + suite.failureCount());
		 rootElement.setAttribute(ATTR_ERRORS, """" + suite.errorCount());
		 rootElement.setAttribute( ATTR_TIME, """" + (suite.getRunTime() / ONE_SECOND));
		 if (out != null) {
			 Writer wri = null;
			 try {
				 wri = new BufferedWriter(new OutputStreamWriter(out, ""UTF8""));
				 wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n"");
				 (new DOMElementWriter()).write(rootElement, wri, 0, "" "");
			 }
			 catch (IOException exc) {
				 throw new BuildException(""Unable to write log file"", exc);
			 }
			 finally {
				 if (wri != null) {
					 try {
						 wri.flush();
					 }
					 catch (IOException ex) {
					 }
				 }
				 if (out != System.out && out != System.err) {
					 FileUtils.close(wri);
				 }
			 }
		 }
	 }
	 public void startTest(Test t) {
		 testStarts.put(t, new Long(System.currentTimeMillis()));
	 }
	 public void endTest(Test test) {
		 if (!testStarts.containsKey(test)) {
			 startTest(test);
		 }
		 Element currentTest = null;
		 if (!failedTests.containsKey(test)) {
			 currentTest = doc.createElement(TESTCASE);
			 String n = JUnitVersionHelper.getTestCaseName(test);
			 currentTest.setAttribute(ATTR_NAME, n == null ? UNKNOWN : n);
			 currentTest.setAttribute(ATTR_CLASSNAME, JUnitVersionHelper.getTestCaseClassName(test));
			 rootElement.appendChild(currentTest);
			 testElements.put(test, currentTest);
		 }
		 else {
			 currentTest = (Element) testElements.get(test);
		 }
		 Long l = (Long) testStarts.get(test);
		 currentTest.setAttribute(ATTR_TIME, """" + ((System.currentTimeMillis() - l.longValue()) / ONE_SECOND));
	 }
	 public void addFailure(Test test, Throwable t) {
		 formatError(FAILURE, test, t);
	 }
	 public void addFailure(Test test, AssertionFailedError t) {
		 addFailure(test, (Throwable) t);
	 }
	 public void addError(Test test, Throwable t) {
		 formatError(ERROR, test, t);
	 }
	 private void formatError(String type, Test test, Throwable t) {
		 if (test != null) {
			 endTest(test);
			 failedTests.put(test, test);
		 }
		 Element nested = doc.createElement(type);
		 Element currentTest = null;
		 if (test != null) {
			 currentTest = (Element) testElements.get(test);
		 }
		 else {
			 currentTest = rootElement;
		 }
		 currentTest.appendChild(nested);
		 String message = t.getMessage();
		 if (message != null && message.length() > 0) {
			 nested.setAttribute(ATTR_MESSAGE, t.getMessage());
		 }
		 nested.setAttribute(ATTR_TYPE, t.getClass().getName());
		 String strace = JUnitTestRunner.getFilteredTrace(t);
		 Text trace = doc.createTextNode(strace);
		 nested.appendChild(trace);
	 }
	 private void formatOutput(String type, String output) {
		 Element nested = doc.createElement(type);
		 rootElement.appendChild(nested);
		 nested.appendChild(doc.createCDATASection(output));
	 }
}",0,0,0,0
"protected Object makeObject(UnknownElement ue, RuntimeConfigurable w) {
	 ComponentHelper helper = ComponentHelper.getComponentHelper( getProject());
	 String name = ue.getComponentName();
	 Object o = helper.createComponent(ue, ue.getNamespace(), name);
	 if (o == null) {
		 throw getNotFoundException(""task or type"", name);
	 }
	 if (o instanceof PreSetDef.PreSetDefinition) {
		 PreSetDef.PreSetDefinition def = (PreSetDef.PreSetDefinition) o;
		 o = def.createObject(ue.getProject());
		 if (o == null) {
			 throw getNotFoundException( ""preset "" + name, def.getPreSets().getComponentName());
		 }
		 ue.applyPreSet(def.getPreSets());
		 if (o instanceof Task) {
			 Task task = (Task) o;
			 task.setTaskType(ue.getTaskType());
			 task.setTaskName(ue.getTaskName());
			 task.init();
		 }
	 }
	 if (o instanceof UnknownElement) {
		 o = ((UnknownElement) o).makeObject((UnknownElement) o, w);
	 }
	 if (o instanceof Task) {
		 ((Task) o).setOwningTarget(getOwningTarget());
	 }
	 if (o instanceof ProjectComponent) {
		 ((ProjectComponent) o).setLocation(getLocation());
	 }
	 return o;
 }",0,0,0,0
"public class DIRuntimeException extends RuntimeException {
	private static final long serialVersionUID = 396131653561690312L;
	 public DIRuntimeException() {
	 }
	 public DIRuntimeException(String messageFormat, Object... messageArgs) {
		 super(String.format(messageFormat, messageArgs));
	 }
	 public DIRuntimeException(Throwable cause) {
		 super(cause);
	 }
	 public DIRuntimeException(String messageFormat, Throwable cause, Object... messageArgs) {
		 super(String.format(messageFormat, messageArgs), cause);
	 }
}",0,1,0,0
"public AbstractBounds<Token> toTokenBounds() {
	 return (left instanceof RowPosition) ? new Bounds<Token>(((RowPosition)left).getToken(), ((RowPosition)right).getToken(), partitioner) : (Bounds<Token>)this;
 }",0,0,0,0
"public class DataSource extends ExtensionPoint {
	 static final String XML_NAME = ""dataSource"";
	 public DataSource() {
		 super();
	 }
	 public void declareExtensions(ExtensionProfile extProfile) {
		 if (extProfile.isDeclared(DataSource.class)) {
			 return;
		 }
		 extProfile.declare(DataSource.class, Property.getDefaultDescription(false, true));
		 extProfile.declare(DataSource.class, TableId.getDefaultDescription(true, false));
		 extProfile.declare(DataSource.class, TableName.getDefaultDescription(true, false));
	 }
	 public List<Property> getProperties() {
		 return getRepeatingExtension(Property.class);
	 }
	 public void addProperty(Property property) {
		 getProperties().add(property);
	 }
	 public boolean hasProperties() {
		 return hasRepeatingExtension(Property.class);
	 }
	 public TableId getTableId() {
		 return getExtension(TableId.class);
	 }
	 public void setTableId(TableId tableId) {
		 if (tableId == null) {
			 removeExtension(TableId.class);
		 }
		 else {
			 setExtension(tableId);
		 }
	 }
	 public boolean hasTableId() {
		 return hasExtension(TableId.class);
	 }
	 public TableName getTableName() {
		 return getExtension(TableName.class);
	 }
	 public void setTableName(TableName tableName) {
		 if (tableName == null) {
			 removeExtension(TableName.class);
		 }
		 else {
			 setExtension(tableName);
		 }
	 }
	 public boolean hasTableName() {
		 return hasExtension(TableName.class);
	 }
	 protected void validate() {
	 }
	 public static ExtensionDescription getDefaultDescription(boolean required, boolean repeatable) {
		 ExtensionDescription desc = ExtensionDescription.getDefaultDescription(DataSource.class);
		 desc.setRequired(required);
		 desc.setRepeatable(repeatable);
		 return desc;
	 }
	 public String toString() {
		 return ""{
		DataSource}
		"";
	 }
	 public String getProperty(String name) {
		 if (hasProperties()) {
			 for (Property property : getProperties()) {
				 if (property.hasName() && property.getName().equalsIgnoreCase(name)) {
					 return property.getValue();
				 }
			 }
		 }
		 return null;
	 }
}",1,1,0,0
"public void run() {
	 try {
		 initialize();
	 }
	 catch (Exception e) {
		 abort(""Fatal exception during initialization"", e);
	 }
	 this.regionServerThread = Thread.currentThread();
	 try {
		 while (!this.stopped) {
			 if (tryReportForDuty()) break;
		 }
		 long lastMsg = 0;
		 List<HMsg> outboundMessages = new ArrayList<HMsg>();
		 for (int tries = 0;
		 !this.stopped && isHealthy();
		) {
			 if (!isClusterUp()) {
				 if (isOnlineRegionsEmpty()) {
					 stop(""Exiting;
					 cluster shutdown set and not carrying any regions"");
				 }
				 else if (!this.stopping) {
					 this.stopping = true;
					 closeUserRegions(this.abortRequested);
				 }
				 else if (this.stopping && LOG.isDebugEnabled()) {
					 LOG.debug(""Waiting on "" + getOnlineRegionsAsPrintableString());
				 }
			 }
			 long now = System.currentTimeMillis();
			 if ((now - lastMsg) >= msgInterval || !outboundMessages.isEmpty()) {
				 try {
					 doMetrics();
					 tryRegionServerReport(outboundMessages);
					 lastMsg = System.currentTimeMillis();
					 tries = 0;
					 if (this.stopped) continue;
				 }
				 catch (Exception e) {
					 if (e instanceof IOException) {
						 e = RemoteExceptionHandler.checkIOException((IOException) e);
					 }
					 if (e instanceof YouAreDeadException) {
						 throw e;
					 }
					 tries++;
					 if (tries > 0 && (tries % this.numRetries) == 0) {
						 checkFileSystem();
					 }
					 if (this.stopped) {
						 continue;
					 }
					 LOG.warn(""Attempt="" + tries, e);
					 lastMsg = System.currentTimeMillis();
				 }
			 }
			 now = System.currentTimeMillis();
			 HMsg msg = this.outboundMsgs.poll((msgInterval - (now - lastMsg)), TimeUnit.MILLISECONDS);
			 if (msg != null) outboundMessages.add(msg);
		 }
	 }
	 catch (Throwable t) {
		 if (!checkOOME(t)) {
			 abort(""Unhandled exception: "" + t.getMessage(), t);
		 }
	 }
	 this.leases.closeAfterLeasesExpire();
	 this.server.stop();
	 if (this.infoServer != null) {
		 LOG.info(""Stopping infoServer"");
		 try {
			 this.infoServer.stop();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
	 }
	 LruBlockCache c = (LruBlockCache) StoreFile.getBlockCache(this.conf);
	 if (c != null) {
		 c.shutdown();
	 }
	 if (this.cacheFlusher != null) this.cacheFlusher.interruptIfNecessary();
	 if (this.compactSplitThread != null) this.compactSplitThread.interruptIfNecessary();
	 if (this.hlogRoller != null) this.hlogRoller.interruptIfNecessary();
	 if (this.majorCompactionChecker != null) this.majorCompactionChecker.interrupt();
	 if (this.killed) {
	 }
	 else if (abortRequested) {
		 if (this.fsOk) {
			 closeAllRegions(abortRequested);
			 closeWAL(false);
		 }
		 LOG.info(""aborting server at: "" + this.serverInfo.getServerName());
	 }
	 else {
		 closeAllRegions(abortRequested);
		 closeWAL(true);
		 closeAllScanners();
		 LOG.info(""stopping server at: "" + this.serverInfo.getServerName());
	 }
	 if (this.catalogTracker != null) this.catalogTracker.stop();
	 if (this.fsOk) waitOnAllRegionsToClose();
	 if (this.hbaseMaster != null) {
		 HBaseRPC.stopProxy(this.hbaseMaster);
		 this.hbaseMaster = null;
	 }
	 this.leases.close();
	 HConnectionManager.deleteConnection(conf, true);
	 this.zooKeeper.close();
	 if (!killed) {
		 join();
	 }
	 LOG.info(Thread.currentThread().getName() + "" exiting"");
 }",0,0,1,0
"private void createNetwork(List<Integer> neuronsInLayers, NeuronProperties neuronProperties) {
	 this.setNetworkType(NeuralNetworkType.MULTI_LAYER_PERCEPTRON);
	 NeuronProperties inputNeuronProperties = new NeuronProperties(InputNeuron.class, Linear.class);
	 Layer layer = LayerFactory.createLayer(neuronsInLayers.get(0), inputNeuronProperties);
	 boolean useBias = true;
	 if (neuronProperties.hasProperty(""useBias"")) {
		 useBias = (Boolean) neuronProperties.getProperty(""useBias"");
	 }
	 if (useBias) {
		 layer.addNeuron(new BiasNeuron());
	 }
	 this.addLayer(layer);
	 Layer prevLayer = layer;
	 for (int layerIdx = 1;
	 layerIdx < neuronsInLayers.size();
	 layerIdx++) {
		 Integer neuronsNum = neuronsInLayers.get(layerIdx);
		 layer = LayerFactory.createLayer(neuronsNum, neuronProperties);
		 if (useBias && (layerIdx < (neuronsInLayers.size() - 1))) {
			 layer.addNeuron(new BiasNeuron());
		 }
		 this.addLayer(layer);
		 if (prevLayer != null) {
			 ConnectionFactory.fullConnect(prevLayer, layer);
		 }
		 prevLayer = layer;
	 }
	 NeuralNetworkFactory.setDefaultIO(this);
	 this.setLearningRule(new MomentumBackpropagation());
	 this.randomizeWeights(new RangeRandomizer(-0.7, 0.7));
 }",0,0,1,0
"protected int fullyResolveEntity(boolean allowExt) throws XMLStreamException {
	 char c = getNextCharFromCurrent(SUFFIX_IN_ENTITY_REF);
	 if (c == '#') {
		 final StringBuffer originalSurface = new StringBuffer(""#"");
		 int ch = resolveCharEnt(originalSurface);
		 if (mCfgTreatCharRefsAsEntities) {
			 final char[] originalChars = new char[originalSurface.length()];
			 originalSurface.getChars(0, originalSurface.length(), originalChars, 0);
			 mCurrEntity = getIntEntity(ch, originalChars);
			 return 0;
		 }
		 return ch;
	 }
	 String id = parseEntityName(c);
	 c = id.charAt(0);
	 char d = CHAR_NULL;
	 if (c == 'a') {
		 if (id.equals(""amp"")) {
			 d = '&';
		 }
		 else if (id.equals(""apos"")) {
			 d = '\'';
		 }
	 }
	 else if (c == 'g') {
		 if (id.length() == 2 && id.charAt(1) == 't') {
			 d = '>';
		 }
	 }
	 else if (c == 'l') {
		 if (id.length() == 2 && id.charAt(1) == 't') {
			 d = '<';
		 }
	 }
	 else if (c == 'q') {
		 if (id.equals(""quot"")) {
			 d = '""';
		 }
	 }
	 if (d != CHAR_NULL) {
		 if (mCfgTreatCharRefsAsEntities) {
			 final char[] originalChars = new char[id.length()];
			 id.getChars(0, id.length(), originalChars, 0);
			 mCurrEntity = getIntEntity(d, originalChars);
			 return 0;
		 }
		 return d;
	 }
	 final EntityDecl e = expandEntity(id, allowExt, null);
	 if (mCfgTreatCharRefsAsEntities) {
		 mCurrEntity = e;
	 }
	 return 0;
 }",0,0,1,0
"public void extractKeyAliasFromColumns(CFMetaData cfm) {
	 clause.extractKeysFromColumns(cfm);
 }",0,0,0,0
"public class Parser{
	 final static int CLEAR_TI_MASK = 0xFFFF, TI_AFTER_EOL = 1 << 16, TI_CHECK_LABEL = 1 << 17;
	 CompilerEnvirons compilerEnv;
	 private ErrorReporter errorReporter;
	 private String sourceURI;
	 boolean calledByCompileFunction;
	 private TokenStream ts;
	 private int currentFlaggedToken;
	 private int syntaxErrorCount;
	 private IRFactory nf;
	 private int nestingOfFunction;
	 private Decompiler decompiler;
	 private String encodedSource;
	 ScriptOrFnNode currentScriptOrFn;
	 private int nestingOfWith;
	 private Hashtable labelSet;
	 private ObjArray loopSet;
	 private ObjArray loopAndSwitchSet;
	 private static class ParserException extends RuntimeException {
		 static final long serialVersionUID = 5882582646773765630L;
	 }
	 public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {
		 this.compilerEnv = compilerEnv;
		 this.errorReporter = errorReporter;
	 }
	 protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {
		 return new Decompiler();
	 }
	 void addWarning(String messageId, String messageArg) {
		 String message = ScriptRuntime.getMessage1(messageId, messageArg);
		 errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 void addError(String messageId) {
		 ++syntaxErrorCount;
		 String message = ScriptRuntime.getMessage0(messageId);
		 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 RuntimeException reportError(String messageId) {
		 addError(messageId);
		 throw new ParserException();
	 }
	 private int peekToken() throws IOException {
		 int tt = currentFlaggedToken;
		 if (tt == Token.EOF) {
			 tt = ts.getToken();
			 if (tt == Token.EOL) {
				 do {
					 tt = ts.getToken();
				 }
				 while (tt == Token.EOL);
				 tt |= TI_AFTER_EOL;
			 }
			 currentFlaggedToken = tt;
		 }
		 return tt & CLEAR_TI_MASK;
	 }
	 private int peekFlaggedToken() throws IOException {
		 peekToken();
		 return currentFlaggedToken;
	 }
	 private void consumeToken() {
		 currentFlaggedToken = Token.EOF;
	 }
	 private int nextToken() throws IOException {
		 int tt = peekToken();
		 consumeToken();
		 return tt;
	 }
	 private int nextFlaggedToken() throws IOException {
		 peekToken();
		 int ttFlagged = currentFlaggedToken;
		 consumeToken();
		 return ttFlagged;
	 }
	 private boolean matchToken(int toMatch) throws IOException {
		 int tt = peekToken();
		 if (tt != toMatch) {
			 return false;
		 }
		 consumeToken();
		 return true;
	 }
	 private int peekTokenOrEOL() throws IOException {
		 int tt = peekToken();
		 if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {
			 tt = Token.EOL;
		 }
		 return tt;
	 }
	 private void setCheckForLabel() {
		 if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME) throw Kit.codeBug();
		 currentFlaggedToken |= TI_CHECK_LABEL;
	 }
	 private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {
		 if (!matchToken(toMatch)) {
			 reportError(messageId);
		 }
	 }
	 private void mustHaveXML() {
		 if (!compilerEnv.isXmlAvailable()) {
			 reportError(""msg.XML.not.available"");
		 }
	 }
	 public String getEncodedSource() {
		 return encodedSource;
	 }
	 public boolean eof() {
		 return ts.eof();
	 }
	 boolean insideFunction() {
		 return nestingOfFunction != 0;
	 }
	 private Node enterLoop(Node loopLabel) {
		 Node loop = nf.createLoopNode(loopLabel, ts.getLineno());
		 if (loopSet == null) {
			 loopSet = new ObjArray();
			 if (loopAndSwitchSet == null) {
				 loopAndSwitchSet = new ObjArray();
			 }
		 }
		 loopSet.push(loop);
		 loopAndSwitchSet.push(loop);
		 return loop;
	 }
	 private void exitLoop() {
		 loopSet.pop();
		 loopAndSwitchSet.pop();
	 }
	 private Node enterSwitch(Node switchSelector, int lineno) {
		 Node switchNode = nf.createSwitch(switchSelector, lineno);
		 if (loopAndSwitchSet == null) {
			 loopAndSwitchSet = new ObjArray();
		 }
		 loopAndSwitchSet.push(switchNode);
		 return switchNode;
	 }
	 private void exitSwitch() {
		 loopAndSwitchSet.pop();
	 }
	 public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, null, sourceString, lineno);
		 try {
			 return parse();
		 }
		 catch (IOException ex) {
			 throw new IllegalStateException();
		 }
	 }
	 public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, sourceReader, null, lineno);
		 return parse();
	 }
	 private ScriptOrFnNode parse() throws IOException {
		 this.decompiler = createDecompiler(compilerEnv);
		 this.nf = new IRFactory(this);
		 currentScriptOrFn = nf.createScript();
		 int sourceStartOffset = decompiler.getCurrentOffset();
		 this.encodedSource = null;
		 decompiler.addToken(Token.SCRIPT);
		 this.currentFlaggedToken = Token.EOF;
		 this.syntaxErrorCount = 0;
		 int baseLineno = ts.getLineno();
		 Node pn = nf.createLeaf(Token.BLOCK);
		 try {
			 for (;
			;
			) {
				 int tt = peekToken();
				 if (tt <= Token.EOF) {
					 break;
				 }
				 Node n;
				 if (tt == Token.FUNCTION) {
					 consumeToken();
					 try {
						 n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);
					 }
					 catch (ParserException e) {
						 break;
					 }
				 }
				 else {
					 n = statement();
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (StackOverflowError ex) {
			 String msg = ScriptRuntime.getMessage0( ""mag.too.deep.parser.recursion"");
			 throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);
		 }
		 if (this.syntaxErrorCount != 0) {
			 String msg = String.valueOf(this.syntaxErrorCount);
			 msg = ScriptRuntime.getMessage1(""msg.got.syntax.errors"", msg);
			 throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);
		 }
		 currentScriptOrFn.setSourceName(sourceURI);
		 currentScriptOrFn.setBaseLineno(baseLineno);
		 currentScriptOrFn.setEndLineno(ts.getLineno());
		 int sourceEndOffset = decompiler.getCurrentOffset();
		 currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);
		 nf.initScript(currentScriptOrFn, pn);
		 if (compilerEnv.isGeneratingSource()) {
			 encodedSource = decompiler.getEncodedSource();
		 }
		 this.decompiler = null;
		 return currentScriptOrFn;
	 }
	 private Node parseFunctionBody() throws IOException {
		 ++nestingOfFunction;
		 Node pn = nf.createBlock(ts.getLineno());
		 try {
			 bodyLoop: for (;
			;
			) {
				 Node n;
				 int tt = peekToken();
				 switch (tt) {
					 case Token.ERROR: case Token.EOF: case Token.RC: break bodyLoop;
					 case Token.FUNCTION: consumeToken();
					 n = function(FunctionNode.FUNCTION_STATEMENT);
					 break;
					 default: n = statement();
					 break;
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (ParserException e) {
		 }
		 finally {
			 --nestingOfFunction;
		 }
		 return pn;
	 }
	 private Node function(int functionType) throws IOException, ParserException {
		 int syntheticType = functionType;
		 int baseLineno = ts.getLineno();
		 int functionSourceStart = decompiler.markFunctionStart(functionType);
		 String name;
		 Node memberExprNode = null;
		 if (matchToken(Token.NAME)) {
			 name = ts.getString();
			 decompiler.addName(name);
			 if (!matchToken(Token.LP)) {
				 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
					 Node memberExprHead = nf.createName(name);
					 name = """";
					 memberExprNode = memberExprTail(false, memberExprHead);
				 }
				 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
			 }
		 }
		 else if (matchToken(Token.LP)) {
			 name = """";
		 }
		 else {
			 name = """";
			 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
				 memberExprNode = memberExpr(false);
			 }
			 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
		 }
		 if (memberExprNode != null) {
			 syntheticType = FunctionNode.FUNCTION_EXPRESSION;
		 }
		 boolean nested = insideFunction();
		 FunctionNode fnNode = nf.createFunction(name);
		 if (nested || nestingOfWith > 0) {
			 fnNode.itsIgnoreDynamicScope = true;
		 }
		 int functionIndex = currentScriptOrFn.addFunction(fnNode);
		 int functionSourceEnd;
		 ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;
		 currentScriptOrFn = fnNode;
		 int savedNestingOfWith = nestingOfWith;
		 nestingOfWith = 0;
		 Hashtable savedLabelSet = labelSet;
		 labelSet = null;
		 ObjArray savedLoopSet = loopSet;
		 loopSet = null;
		 ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;
		 loopAndSwitchSet = null;
		 Node body;
		 try {
			 decompiler.addToken(Token.LP);
			 if (!matchToken(Token.RP)) {
				 boolean first = true;
				 do {
					 if (!first) decompiler.addToken(Token.COMMA);
					 first = false;
					 mustMatchToken(Token.NAME, ""msg.no.parm"");
					 String s = ts.getString();
					 if (fnNode.hasParamOrVar(s)) {
						 addWarning(""msg.dup.parms"", s);
					 }
					 fnNode.addParam(s);
					 decompiler.addName(s);
				 }
				 while (matchToken(Token.COMMA));
				 mustMatchToken(Token.RP, ""msg.no.paren.after.parms"");
			 }
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.LC, ""msg.no.brace.body"");
			 decompiler.addEOL(Token.LC);
			 body = parseFunctionBody();
			 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
			 decompiler.addToken(Token.RC);
			 functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {
					 int tt = peekTokenOrEOL();
					 if (tt == Token.FUNCTION) {
						 reportError(""msg.no.semi.stmt"");
					 }
				 }
				 decompiler.addToken(Token.EOL);
			 }
		 }
		 finally {
			 loopAndSwitchSet = savedLoopAndSwitchSet;
			 loopSet = savedLoopSet;
			 labelSet = savedLabelSet;
			 nestingOfWith = savedNestingOfWith;
			 currentScriptOrFn = savedScriptOrFn;
		 }
		 fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);
		 fnNode.setSourceName(sourceURI);
		 fnNode.setBaseLineno(baseLineno);
		 fnNode.setEndLineno(ts.getLineno());
		 Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
		 if (memberExprNode != null) {
			 pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 pn = nf.createExprStatementNoReturn(pn, baseLineno);
			 }
		 }
		 return pn;
	 }
	 private Node statements() throws IOException {
		 Node pn = nf.createBlock(ts.getLineno());
		 int tt;
		 while((tt = peekToken()) > Token.EOF && tt != Token.RC) {
			 nf.addChildToBack(pn, statement());
		 }
		 return pn;
	 }
	 private Node condition() throws IOException, ParserException {
		 Node pn;
		 mustMatchToken(Token.LP, ""msg.no.paren.cond"");
		 decompiler.addToken(Token.LP);
		 pn = expr(false);
		 mustMatchToken(Token.RP, ""msg.no.paren.after.cond"");
		 decompiler.addToken(Token.RP);
		 return pn;
	 }
	 private Node matchJumpLabelName() throws IOException, ParserException {
		 Node label = null;
		 int tt = peekTokenOrEOL();
		 if (tt == Token.NAME) {
			 consumeToken();
			 String name = ts.getString();
			 decompiler.addName(name);
			 if (labelSet != null) {
				 label = (Node)labelSet.get(name);
			 }
			 if (label == null) {
				 reportError(""msg.undef.label"");
			 }
		 }
		 return label;
	 }
	 private Node statement() throws IOException {
		 try {
			 Node pn = statementHelper(null);
			 if (pn != null) {
				 return pn;
			 }
		 }
		 catch (ParserException e) {
		 }
		 int lineno = ts.getLineno();
		 guessingStatementEnd: for (;
		;
		) {
			 int tt = peekTokenOrEOL();
			 consumeToken();
			 switch (tt) {
				 case Token.ERROR: case Token.EOF: case Token.EOL: case Token.SEMI: break guessingStatementEnd;
			 }
		 }
		 return nf.createExprStatement(nf.createName(""error""), lineno);
	 }
	 private Node statementHelper(Node statementLabel) throws IOException, ParserException {
		 Node pn = null;
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.IF: {
				 consumeToken();
				 decompiler.addToken(Token.IF);
				 int lineno = ts.getLineno();
				 Node cond = condition();
				 decompiler.addEOL(Token.LC);
				 Node ifTrue = statement();
				 Node ifFalse = null;
				 if (matchToken(Token.ELSE)) {
					 decompiler.addToken(Token.RC);
					 decompiler.addToken(Token.ELSE);
					 decompiler.addEOL(Token.LC);
					 ifFalse = statement();
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createIf(cond, ifTrue, ifFalse, lineno);
				 return pn;
			 }
			 case Token.SWITCH: {
				 consumeToken();
				 decompiler.addToken(Token.SWITCH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.switch"");
				 decompiler.addToken(Token.LP);
				 pn = enterSwitch(expr(false), lineno);
				 try {
					 mustMatchToken(Token.RP, ""msg.no.paren.after.switch"");
					 decompiler.addToken(Token.RP);
					 mustMatchToken(Token.LC, ""msg.no.brace.switch"");
					 decompiler.addEOL(Token.LC);
					 boolean hasDefault = false;
					 switchLoop: for (;
					;
					) {
						 tt = nextToken();
						 Node caseExpression;
						 switch (tt) {
							 case Token.RC: break switchLoop;
							 case Token.CASE: decompiler.addToken(Token.CASE);
							 caseExpression = expr(false);
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 case Token.DEFAULT: if (hasDefault) {
								 reportError(""msg.double.switch.default"");
							 }
							 decompiler.addToken(Token.DEFAULT);
							 hasDefault = true;
							 caseExpression = null;
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 default: reportError(""msg.bad.switch"");
							 break switchLoop;
						 }
						 Node block = nf.createLeaf(Token.BLOCK);
						 while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {
							 nf.addChildToBack(block, statement());
						 }
						 nf.addSwitchCase(pn, caseExpression, block);
					 }
					 decompiler.addEOL(Token.RC);
					 nf.closeSwitch(pn);
				 }
				 finally {
					 exitSwitch();
				 }
				 return pn;
			 }
			 case Token.WHILE: {
				 consumeToken();
				 decompiler.addToken(Token.WHILE);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node cond = condition();
					 decompiler.addEOL(Token.LC);
					 Node body = statement();
					 decompiler.addEOL(Token.RC);
					 pn = nf.createWhile(loop, cond, body);
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.DO: {
				 consumeToken();
				 decompiler.addToken(Token.DO);
				 decompiler.addEOL(Token.LC);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node body = statement();
					 decompiler.addToken(Token.RC);
					 mustMatchToken(Token.WHILE, ""msg.no.while.do"");
					 decompiler.addToken(Token.WHILE);
					 Node cond = condition();
					 pn = nf.createDoWhile(loop, body, cond);
				 }
				 finally {
					 exitLoop();
				 }
				 matchToken(Token.SEMI);
				 decompiler.addEOL(Token.SEMI);
				 return pn;
			 }
			 case Token.FOR: {
				 consumeToken();
				 boolean isForEach = false;
				 decompiler.addToken(Token.FOR);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node init;
					 Node cond;
					 Node incr = null;
					 Node body;
					 if (matchToken(Token.NAME)) {
						 decompiler.addName(ts.getString());
						 if (ts.getString().equals(""each"")) {
							 isForEach = true;
						 }
						 else {
							 reportError(""msg.no.paren.for"");
						 }
					 }
					 mustMatchToken(Token.LP, ""msg.no.paren.for"");
					 decompiler.addToken(Token.LP);
					 tt = peekToken();
					 if (tt == Token.SEMI) {
						 init = nf.createLeaf(Token.EMPTY);
					 }
					 else {
						 if (tt == Token.VAR) {
							 consumeToken();
							 init = variables(true);
						 }
						 else {
							 init = expr(true);
						 }
					 }
					 if (matchToken(Token.IN)) {
						 decompiler.addToken(Token.IN);
						 cond = expr(false);
					 }
					 else {
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.SEMI) {
							 cond = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 cond = expr(false);
						 }
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for.cond"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.RP) {
							 incr = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 incr = expr(false);
						 }
					 }
					 mustMatchToken(Token.RP, ""msg.no.paren.for.ctrl"");
					 decompiler.addToken(Token.RP);
					 decompiler.addEOL(Token.LC);
					 body = statement();
					 decompiler.addEOL(Token.RC);
					 if (incr == null) {
						 pn = nf.createForIn(loop, init, cond, body, isForEach);
					 }
					 else {
						 pn = nf.createFor(loop, init, cond, incr, body);
					 }
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.TRY: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 Node tryblock;
				 Node catchblocks = null;
				 Node finallyblock = null;
				 decompiler.addToken(Token.TRY);
				 decompiler.addEOL(Token.LC);
				 tryblock = statement();
				 decompiler.addEOL(Token.RC);
				 catchblocks = nf.createLeaf(Token.BLOCK);
				 boolean sawDefaultCatch = false;
				 int peek = peekToken();
				 if (peek == Token.CATCH) {
					 while (matchToken(Token.CATCH)) {
						 if (sawDefaultCatch) {
							 reportError(""msg.catch.unreachable"");
						 }
						 decompiler.addToken(Token.CATCH);
						 mustMatchToken(Token.LP, ""msg.no.paren.catch"");
						 decompiler.addToken(Token.LP);
						 mustMatchToken(Token.NAME, ""msg.bad.catchcond"");
						 String varName = ts.getString();
						 decompiler.addName(varName);
						 Node catchCond = null;
						 if (matchToken(Token.IF)) {
							 decompiler.addToken(Token.IF);
							 catchCond = expr(false);
						 }
						 else {
							 sawDefaultCatch = true;
						 }
						 mustMatchToken(Token.RP, ""msg.bad.catchcond"");
						 decompiler.addToken(Token.RP);
						 mustMatchToken(Token.LC, ""msg.no.brace.catchblock"");
						 decompiler.addEOL(Token.LC);
						 nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(), ts.getLineno()));
						 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
						 decompiler.addEOL(Token.RC);
					 }
				 }
				 else if (peek != Token.FINALLY) {
					 mustMatchToken(Token.FINALLY, ""msg.try.no.catchfinally"");
				 }
				 if (matchToken(Token.FINALLY)) {
					 decompiler.addToken(Token.FINALLY);
					 decompiler.addEOL(Token.LC);
					 finallyblock = statement();
					 decompiler.addEOL(Token.RC);
				 }
				 pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);
				 return pn;
			 }
			 case Token.THROW: {
				 consumeToken();
				 if (peekTokenOrEOL() == Token.EOL) {
					 reportError(""msg.bad.throw.eol"");
				 }
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.THROW);
				 pn = nf.createThrow(expr(false), lineno);
				 break;
			 }
			 case Token.BREAK: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.BREAK);
				 Node breakStatement = matchJumpLabelName();
				 if (breakStatement == null) {
					 if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {
						 reportError(""msg.bad.break"");
						 return null;
					 }
					 breakStatement = (Node)loopAndSwitchSet.peek();
				 }
				 pn = nf.createBreak(breakStatement, lineno);
				 break;
			 }
			 case Token.CONTINUE: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.CONTINUE);
				 Node loop;
				 Node label = matchJumpLabelName();
				 if (label == null) {
					 if (loopSet == null || loopSet.size() == 0) {
						 reportError(""msg.continue.outside"");
						 return null;
					 }
					 loop = (Node)loopSet.peek();
				 }
				 else {
					 loop = nf.getLabelLoop(label);
					 if (loop == null) {
						 reportError(""msg.continue.nonloop"");
						 return null;
					 }
				 }
				 pn = nf.createContinue(loop, lineno);
				 break;
			 }
			 case Token.WITH: {
				 consumeToken();
				 decompiler.addToken(Token.WITH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.with"");
				 decompiler.addToken(Token.LP);
				 Node obj = expr(false);
				 mustMatchToken(Token.RP, ""msg.no.paren.after.with"");
				 decompiler.addToken(Token.RP);
				 decompiler.addEOL(Token.LC);
				 ++nestingOfWith;
				 Node body;
				 try {
					 body = statement();
				 }
				 finally {
					 --nestingOfWith;
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createWith(obj, body, lineno);
				 return pn;
			 }
			 case Token.VAR: {
				 consumeToken();
				 pn = variables(false);
				 break;
			 }
			 case Token.RETURN: {
				 if (!insideFunction()) {
					 reportError(""msg.bad.return"");
				 }
				 consumeToken();
				 decompiler.addToken(Token.RETURN);
				 int lineno = ts.getLineno();
				 Node retExpr;
				 tt = peekTokenOrEOL();
				 switch (tt) {
					 case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null;
					 break;
					 default: retExpr = expr(false);
				 }
				 pn = nf.createReturn(retExpr, lineno);
				 break;
			 }
			 case Token.LC: consumeToken();
			 if (statementLabel != null) {
				 decompiler.addToken(Token.LC);
			 }
			 pn = statements();
			 mustMatchToken(Token.RC, ""msg.no.brace.block"");
			 if (statementLabel != null) {
				 decompiler.addEOL(Token.RC);
			 }
			 return pn;
			 case Token.ERROR: case Token.SEMI: consumeToken();
			 pn = nf.createLeaf(Token.EMPTY);
			 return pn;
			 case Token.FUNCTION: {
				 consumeToken();
				 pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);
				 return pn;
			 }
			 case Token.DEFAULT : consumeToken();
			 mustHaveXML();
			 decompiler.addToken(Token.DEFAULT);
			 int nsLine = ts.getLineno();
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""xml""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""namespace""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!matchToken(Token.ASSIGN)) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addToken(Token.ASSIGN);
			 Node expr = expr(false);
			 pn = nf.createDefaultNamespace(expr, nsLine);
			 break;
			 case Token.NAME: {
				 int lineno = ts.getLineno();
				 String name = ts.getString();
				 setCheckForLabel();
				 pn = expr(false);
				 if (pn.getType() != Token.LABEL) {
					 pn = nf.createExprStatement(pn, lineno);
				 }
				 else {
					 if (peekToken() != Token.COLON) Kit.codeBug();
					 consumeToken();
					 decompiler.addName(name);
					 decompiler.addEOL(Token.COLON);
					 if (labelSet == null) {
						 labelSet = new Hashtable();
					 }
					 else if (labelSet.containsKey(name)) {
						 reportError(""msg.dup.label"");
					 }
					 boolean firstLabel;
					 if (statementLabel == null) {
						 firstLabel = true;
						 statementLabel = pn;
					 }
					 else {
						 firstLabel = false;
					 }
					 labelSet.put(name, statementLabel);
					 try {
						 pn = statementHelper(statementLabel);
					 }
					 finally {
						 labelSet.remove(name);
					 }
					 if (firstLabel) {
						 pn = nf.createLabeledStatement(statementLabel, pn);
					 }
					 return pn;
				 }
				 break;
			 }
			 default: {
				 int lineno = ts.getLineno();
				 pn = expr(false);
				 pn = nf.createExprStatement(pn, lineno);
				 break;
			 }
		 }
		 int ttFlagged = peekFlaggedToken();
		 switch (ttFlagged & CLEAR_TI_MASK) {
			 case Token.SEMI: consumeToken();
			 break;
			 case Token.ERROR: case Token.EOF: case Token.RC: break;
			 default: if ((ttFlagged & TI_AFTER_EOL) == 0) {
				 reportError(""msg.no.semi.stmt"");
			 }
			 break;
		 }
		 decompiler.addEOL(Token.SEMI);
		 return pn;
	 }
	 private Node variables(boolean inForInit) throws IOException, ParserException {
		 Node pn = nf.createVariables(ts.getLineno());
		 boolean first = true;
		 decompiler.addToken(Token.VAR);
		 for (;
		;
		) {
			 Node name;
			 Node init;
			 mustMatchToken(Token.NAME, ""msg.bad.var"");
			 String s = ts.getString();
			 if (!first) decompiler.addToken(Token.COMMA);
			 first = false;
			 decompiler.addName(s);
			 currentScriptOrFn.addVar(s);
			 name = nf.createName(s);
			 if (matchToken(Token.ASSIGN)) {
				 decompiler.addToken(Token.ASSIGN);
				 init = assignExpr(inForInit);
				 nf.addChildToBack(name, init);
			 }
			 nf.addChildToBack(pn, name);
			 if (!matchToken(Token.COMMA)) break;
		 }
		 return pn;
	 }
	 private Node expr(boolean inForInit) throws IOException, ParserException {
		 Node pn = assignExpr(inForInit);
		 while (matchToken(Token.COMMA)) {
			 decompiler.addToken(Token.COMMA);
			 pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node assignExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = condExpr(inForInit);
		 int tt = peekToken();
		 if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
			 consumeToken();
			 decompiler.addToken(tt);
			 pn = nf.createAssignment(tt, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node condExpr(boolean inForInit) throws IOException, ParserException {
		 Node ifTrue;
		 Node ifFalse;
		 Node pn = orExpr(inForInit);
		 if (matchToken(Token.HOOK)) {
			 decompiler.addToken(Token.HOOK);
			 ifTrue = assignExpr(false);
			 mustMatchToken(Token.COLON, ""msg.no.colon.cond"");
			 decompiler.addToken(Token.COLON);
			 ifFalse = assignExpr(inForInit);
			 return nf.createCondExpr(pn, ifTrue, ifFalse);
		 }
		 return pn;
	 }
	 private Node orExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = andExpr(inForInit);
		 if (matchToken(Token.OR)) {
			 decompiler.addToken(Token.OR);
			 pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node andExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitOrExpr(inForInit);
		 if (matchToken(Token.AND)) {
			 decompiler.addToken(Token.AND);
			 pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitXorExpr(inForInit);
		 while (matchToken(Token.BITOR)) {
			 decompiler.addToken(Token.BITOR);
			 pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitAndExpr(inForInit);
		 while (matchToken(Token.BITXOR)) {
			 decompiler.addToken(Token.BITXOR);
			 pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = eqExpr(inForInit);
		 while (matchToken(Token.BITAND)) {
			 decompiler.addToken(Token.BITAND);
			 pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node eqExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = relExpr(inForInit);
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: consumeToken();
				 int decompilerToken = tt;
				 int parseToken = tt;
				 if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
					 switch (tt) {
						 case Token.EQ: parseToken = Token.SHEQ;
						 break;
						 case Token.NE: parseToken = Token.SHNE;
						 break;
						 case Token.SHEQ: decompilerToken = Token.EQ;
						 break;
						 case Token.SHNE: decompilerToken = Token.NE;
						 break;
					 }
				 }
				 decompiler.addToken(decompilerToken);
				 pn = nf.createBinary(parseToken, pn, relExpr(inForInit));
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node relExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = shiftExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.IN: if (inForInit) break;
				 case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, shiftExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node shiftExpr() throws IOException, ParserException {
		 Node pn = addExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.LSH: case Token.URSH: case Token.RSH: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, addExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node addExpr() throws IOException, ParserException {
		 Node pn = mulExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 if (tt == Token.ADD || tt == Token.SUB) {
				 consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, mulExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node mulExpr() throws IOException, ParserException {
		 Node pn = unaryExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.MUL: case Token.DIV: case Token.MOD: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, unaryExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node unaryExpr() throws IOException, ParserException {
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createUnary(tt, unaryExpr());
			 case Token.ADD: consumeToken();
			 decompiler.addToken(Token.POS);
			 return nf.createUnary(Token.POS, unaryExpr());
			 case Token.SUB: consumeToken();
			 decompiler.addToken(Token.NEG);
			 return nf.createUnary(Token.NEG, unaryExpr());
			 case Token.INC: case Token.DEC: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createIncDec(tt, false, memberExpr(true));
			 case Token.DELPROP: consumeToken();
			 decompiler.addToken(Token.DELPROP);
			 return nf.createUnary(Token.DELPROP, unaryExpr());
			 case Token.ERROR: consumeToken();
			 break;
			 case Token.LT: if (compilerEnv.isXmlAvailable()) {
				 consumeToken();
				 Node pn = xmlInitializer();
				 return memberExprTail(true, pn);
			 }
			 default: Node pn = memberExpr(true);
			 tt = peekTokenOrEOL();
			 if (tt == Token.INC || tt == Token.DEC) {
				 consumeToken();
				 decompiler.addToken(tt);
				 return nf.createIncDec(tt, true, pn);
			 }
			 return pn;
		 }
		 return nf.createName(""err"");
	 }
	 private Node xmlInitializer() throws IOException {
		 int tt = ts.getFirstXMLToken();
		 if (tt != Token.XML && tt != Token.XMLEND) {
			 reportError(""msg.syntax"");
			 return null;
		 }
		 Node pnXML = nf.createLeaf(Token.NEW);
		 String xml = ts.getString();
		 boolean fAnonymous = xml.trim().startsWith(""<>"");
		 Node pn = nf.createName(fAnonymous ? ""XMLList"" : ""XML"");
		 nf.addChildToBack(pnXML, pn);
		 pn = null;
		 Node expr;
		 for (;
		;
		tt = ts.getNextXMLToken()) {
			 switch (tt) {
				 case Token.XML: xml = ts.getString();
				 decompiler.addName(xml);
				 mustMatchToken(Token.LC, ""msg.syntax"");
				 decompiler.addToken(Token.LC);
				 expr = (peekToken() == Token.RC) ? nf.createString("""") : expr(false);
				 mustMatchToken(Token.RC, ""msg.syntax"");
				 decompiler.addToken(Token.RC);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 int nodeType;
				 if (ts.isXMLAttribute()) {
					 nodeType = Token.ESCXMLATTR;
				 }
				 else {
					 nodeType = Token.ESCXMLTEXT;
				 }
				 expr = nf.createUnary(nodeType, expr);
				 pn = nf.createBinary(Token.ADD, pn, expr);
				 break;
				 case Token.XMLEND: xml = ts.getString();
				 decompiler.addName(xml);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 nf.addChildToBack(pnXML, pn);
				 return pnXML;
				 default: reportError(""msg.syntax"");
				 return null;
			 }
		 }
	 }
	 private void argumentList(Node listNode) throws IOException, ParserException {
		 boolean matched;
		 matched = matchToken(Token.RP);
		 if (!matched) {
			 boolean first = true;
			 do {
				 if (!first) decompiler.addToken(Token.COMMA);
				 first = false;
				 nf.addChildToBack(listNode, assignExpr(false));
			 }
			 while (matchToken(Token.COMMA));
			 mustMatchToken(Token.RP, ""msg.no.paren.arg"");
		 }
		 decompiler.addToken(Token.RP);
	 }
	 private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {
		 int tt;
		 Node pn;
		 tt = peekToken();
		 if (tt == Token.NEW) {
			 consumeToken();
			 decompiler.addToken(Token.NEW);
			 pn = nf.createCallOrNew(Token.NEW, memberExpr(false));
			 if (matchToken(Token.LP)) {
				 decompiler.addToken(Token.LP);
				 argumentList(pn);
			 }
			 tt = peekToken();
			 if (tt == Token.LC) {
				 nf.addChildToBack(pn, primaryExpr());
			 }
		 }
		 else {
			 pn = primaryExpr();
		 }
		 return memberExprTail(allowCallSyntax, pn);
	 }
	 private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {
		 tailLoop: for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.DOT: case Token.DOTDOT: {
					 int memberTypeFlags;
					 String s;
					 consumeToken();
					 decompiler.addToken(tt);
					 memberTypeFlags = 0;
					 if (tt == Token.DOTDOT) {
						 mustHaveXML();
						 memberTypeFlags = Node.DESCENDANTS_FLAG;
					 }
					 if (!compilerEnv.isXmlAvailable()) {
						 mustMatchToken(Token.NAME, ""msg.no.name.after.dot"");
						 s = ts.getString();
						 decompiler.addName(s);
						 pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);
						 break;
					 }
					 tt = nextToken();
					 switch (tt) {
						 case Token.NAME: s = ts.getString();
						 decompiler.addName(s);
						 pn = propertyName(pn, s, memberTypeFlags);
						 break;
						 case Token.MUL: decompiler.addName(""*"");
						 pn = propertyName(pn, ""*"", memberTypeFlags);
						 break;
						 case Token.XMLATTR: decompiler.addToken(Token.XMLATTR);
						 pn = attributeAccess(pn, memberTypeFlags);
						 break;
						 default: reportError(""msg.no.name.after.dot"");
					 }
				 }
				 break;
				 case Token.DOTQUERY: consumeToken();
				 mustHaveXML();
				 decompiler.addToken(Token.DOTQUERY);
				 pn = nf.createDotQuery(pn, expr(false), ts.getLineno());
				 mustMatchToken(Token.RP, ""msg.no.paren"");
				 decompiler.addToken(Token.RP);
				 break;
				 case Token.LB: consumeToken();
				 decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, null, expr(false), 0);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 break;
				 case Token.LP: if (!allowCallSyntax) {
					 break tailLoop;
				 }
				 consumeToken();
				 decompiler.addToken(Token.LP);
				 pn = nf.createCallOrNew(Token.CALL, pn);
				 argumentList(pn);
				 break;
				 default: break tailLoop;
			 }
		 }
		 return pn;
	 }
	 private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {
		 memberTypeFlags |= Node.ATTRIBUTE_FLAG;
		 int tt = nextToken();
		 switch (tt) {
			 case Token.NAME: {
				 String s = ts.getString();
				 decompiler.addName(s);
				 pn = propertyName(pn, s, memberTypeFlags);
			 }
			 break;
			 case Token.MUL: decompiler.addName(""*"");
			 pn = propertyName(pn, ""*"", memberTypeFlags);
			 break;
			 case Token.LB: decompiler.addToken(Token.LB);
			 pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);
			 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
			 decompiler.addToken(Token.RB);
			 break;
			 default: reportError(""msg.no.name.after.xmlAttr"");
			 pn = nf.createPropertyGet(pn, null, ""?"", memberTypeFlags);
			 break;
		 }
		 return pn;
	 }
	 private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {
		 String namespace = null;
		 if (matchToken(Token.COLONCOLON)) {
			 decompiler.addToken(Token.COLONCOLON);
			 namespace = name;
			 int tt = nextToken();
			 switch (tt) {
				 case Token.NAME: name = ts.getString();
				 decompiler.addName(name);
				 break;
				 case Token.MUL: decompiler.addName(""*"");
				 name = ""*"";
				 break;
				 case Token.LB: decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 return pn;
				 default: reportError(""msg.no.name.after.coloncolon"");
				 name = ""?"";
			 }
		 }
		 pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);
		 return pn;
	 }
	 private Node primaryExpr() throws IOException, ParserException {
		 Node pn;
		 int ttFlagged = nextFlaggedToken();
		 int tt = ttFlagged & CLEAR_TI_MASK;
		 switch(tt) {
			 case Token.FUNCTION: return function(FunctionNode.FUNCTION_EXPRESSION);
			 case Token.LB: {
				 ObjArray elems = new ObjArray();
				 int skipCount = 0;
				 decompiler.addToken(Token.LB);
				 boolean after_lb_or_comma = true;
				 for (;
				;
				) {
					 tt = peekToken();
					 if (tt == Token.COMMA) {
						 consumeToken();
						 decompiler.addToken(Token.COMMA);
						 if (!after_lb_or_comma) {
							 after_lb_or_comma = true;
						 }
						 else {
							 elems.add(null);
							 ++skipCount;
						 }
					 }
					 else if (tt == Token.RB) {
						 consumeToken();
						 decompiler.addToken(Token.RB);
						 break;
					 }
					 else {
						 if (!after_lb_or_comma) {
							 reportError(""msg.no.bracket.arg"");
						 }
						 elems.add(assignExpr(false));
						 after_lb_or_comma = false;
					 }
				 }
				 return nf.createArrayLiteral(elems, skipCount);
			 }
			 case Token.LC: {
				 ObjArray elems = new ObjArray();
				 decompiler.addToken(Token.LC);
				 if (!matchToken(Token.RC)) {
					 boolean first = true;
					 commaloop: do {
						 Object property;
						 if (!first) decompiler.addToken(Token.COMMA);
						 else first = false;
						 tt = peekToken();
						 switch(tt) {
							 case Token.NAME: case Token.STRING: consumeToken();
							 String s = ts.getString();
							 if (tt == Token.NAME) {
								 decompiler.addName(s);
							 }
							 else {
								 decompiler.addString(s);
							 }
							 property = ScriptRuntime.getIndexObject(s);
							 break;
							 case Token.NUMBER: consumeToken();
							 double n = ts.getNumber();
							 decompiler.addNumber(n);
							 property = ScriptRuntime.getIndexObject(n);
							 break;
							 case Token.RC: break commaloop;
							 default: reportError(""msg.bad.prop"");
							 break commaloop;
						 }
						 mustMatchToken(Token.COLON, ""msg.no.colon.prop"");
						 decompiler.addToken(Token.OBJECTLIT);
						 elems.add(property);
						 elems.add(assignExpr(false));
					 }
					 while (matchToken(Token.COMMA));
					 mustMatchToken(Token.RC, ""msg.no.brace.prop"");
				 }
				 decompiler.addToken(Token.RC);
				 return nf.createObjectLiteral(elems);
			 }
			 case Token.LP: decompiler.addToken(Token.LP);
			 pn = expr(false);
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.RP, ""msg.no.paren"");
			 return pn;
			 case Token.XMLATTR: mustHaveXML();
			 decompiler.addToken(Token.XMLATTR);
			 pn = attributeAccess(null, 0);
			 return pn;
			 case Token.NAME: {
				 String name = ts.getString();
				 if ((ttFlagged & TI_CHECK_LABEL) != 0) {
					 if (peekToken() == Token.COLON) {
						 return nf.createLabel(ts.getLineno());
					 }
				 }
				 decompiler.addName(name);
				 if (compilerEnv.isXmlAvailable()) {
					 pn = propertyName(null, name, 0);
				 }
				 else {
					 pn = nf.createName(name);
				 }
				 return pn;
			 }
			 case Token.NUMBER: {
				 double n = ts.getNumber();
				 decompiler.addNumber(n);
				 return nf.createNumber(n);
			 }
			 case Token.STRING: {
				 String s = ts.getString();
				 decompiler.addString(s);
				 return nf.createString(s);
			 }
			 case Token.DIV: case Token.ASSIGN_DIV: {
				 ts.readRegExp(tt);
				 String flags = ts.regExpFlags;
				 ts.regExpFlags = null;
				 String re = ts.getString();
				 decompiler.addRegexp(re, flags);
				 int index = currentScriptOrFn.addRegexp(re, flags);
				 return nf.createRegExp(index);
			 }
			 case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: decompiler.addToken(tt);
			 return nf.createLeaf(tt);
			 case Token.RESERVED: reportError(""msg.reserved.id"");
			 break;
			 case Token.ERROR: break;
			 case Token.EOF: reportError(""msg.unexpected.eof"");
			 break;
			 default: reportError(""msg.syntax"");
			 break;
		 }
		 return null;
	 }
}",1,0,0,0
"public class TagUtils{
	public TagUtils(){
	}
	public static final boolean isBodyTag(final ComponentTag tag){
		return (""body"".equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null));
	}
	public static final boolean isHeadTag(final ComponentTag tag){
		return (""head"".equalsIgnoreCase(tag.getName()) && (tag.getNamespace() == null));
	}
}",0,0,0,0
public Collection getEntities();,0,0,0,0
"public abstract class SubmitTransitionXCommand extends TransitionXCommand<String> {
	 public SubmitTransitionXCommand(String name, String type, int priority) {
		 super(name, type, priority);
	 }
	 public SubmitTransitionXCommand(String name, String type, int priority, boolean dryrun) {
		 super(name, type, priority, dryrun);
	 }
	 protected abstract String submit() throws CommandException;
	 public void transitToNext() {
		 if (job == null) {
			 job = this.getJob();
		 }
		 job.setStatus(Job.Status.PREP);
		 job.resetPending();
	 }
	 protected String execute() throws CommandException {
		 try {
			 transitToNext();
			 String jobId = submit();
			 return jobId;
		 }
		 finally {
			 notifyParent();
		 }
	 }
}",0,0,0,0
"public class VMSVersioningFTPEntryParser extends VMSFTPEntryParser{
	 private final Pattern _preparse_pattern_;
	 private static final String PRE_PARSE_REGEX = ""(.*?);
	([0-9]+)\\s*.*"";
	 public VMSVersioningFTPEntryParser() {
		 this(null);
	 }
	 public VMSVersioningFTPEntryParser(FTPClientConfig config) {
		 super();
		 configure(config);
		 try {
			 _preparse_pattern_ = Pattern.compile(PRE_PARSE_REGEX);
		 }
		 catch (PatternSyntaxException pse) {
			 throw new IllegalArgumentException ( ""Unparseable regex supplied: "" + PRE_PARSE_REGEX);
		 }
	 }
	 public List<String> preParse(List<String> original) {
		 HashMap<String, Integer> existingEntries = new HashMap<String, Integer>();
		 ListIterator<String> iter = original.listIterator();
		 while (iter.hasNext()) {
			 String entry = iter.next().trim();
			 MatchResult result = null;
			 Matcher _preparse_matcher_ = _preparse_pattern_.matcher(entry);
			 if (_preparse_matcher_.matches()) {
				 result = _preparse_matcher_.toMatchResult();
				 String name = result.group(1);
				 String version = result.group(2);
				 Integer nv = Integer.valueOf(version);
				 Integer existing = existingEntries.get(name);
				 if (null != existing) {
					 if (nv.intValue() < existing.intValue()) {
						 iter.remove();
						 continue;
					 }
				 }
				 existingEntries.put(name, nv);
			 }
		 }
		 while (iter.hasPrevious()) {
			 String entry = iter.previous().trim();
			 MatchResult result = null;
			 Matcher _preparse_matcher_ = _preparse_pattern_.matcher(entry);
			 if (_preparse_matcher_.matches()) {
				 result = _preparse_matcher_.toMatchResult();
				 String name = result.group(1);
				 String version = result.group(2);
				 Integer nv = Integer.valueOf(version);
				 Integer existing = existingEntries.get(name);
				 if (null != existing) {
					 if (nv.intValue() < existing.intValue()) {
						 iter.remove();
					 }
				 }
			 }
		 }
		 return original;
	 }
	 protected boolean isVersioning() {
		 return true;
	 }
}",0,0,0,0
static int parseInteger(String s);,0,0,0,0
