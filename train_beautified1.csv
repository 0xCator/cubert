code,godclass,dataclass,longmethod,longparamlist
"public void execute() throws BuildException {
	 ClassLoader al = createLoader();
	 if (!definerSet) {
		 if (getURI() == null) {
			 throw new BuildException( ""name, file or resource attribute of "" + getTaskName() + "" is undefined"", getLocation());
		 }
		 if (getURI().startsWith(MagicNames.ANTLIB_PREFIX)) {
			 String uri1 = getURI();
			 setResource(makeResourceFromURI(uri1));
		 }
		 else {
			 throw new BuildException( ""Only antlib URIs can be located from the URI alone,"" + ""not the URI "" + getURI());
		 }
	 }
	 if (name != null) {
		 if (classname == null) {
			 throw new BuildException( ""classname attribute of "" + getTaskName() + "" element "" + ""is undefined"", getLocation());
		 }
		 addDefinition(al, name, classname);
	 }
	 else {
		 if (classname != null) {
			 String msg = ""You must not specify classname "" + ""together with file or resource."";
			 throw new BuildException(msg, getLocation());
		 }
		 Enumeration urls = null;
		 if (file != null) {
			 final URL url = fileToURL();
			 if (url == null) {
				 return;
			 }
			 urls = new Enumeration() {
				 private boolean more = true;
				 public boolean hasMoreElements() {
					 return more;
				 }
				 public Object nextElement() throws NoSuchElementException {
					 if (more) {
						 more = false;
						 return url;
					 }
					 else {
						 throw new NoSuchElementException();
					 }
				 }
			 }
			;
		 }
		 else {
			 urls = resourceToURLs(al);
		 }
		 while (urls.hasMoreElements()) {
			 URL url = (URL) urls.nextElement();
			 int fmt = this.format;
			 if (url.toString().toLowerCase(Locale.ENGLISH).endsWith("".xml"")) {
				 fmt = Format.XML;
			 }
			 if (fmt == Format.PROPERTIES) {
				 loadProperties(al, url);
				 break;
			 }
			 else {
				 if (resourceStack.getStack().get(url) != null) {
					 log(""Warning: Recursive loading of "" + url + "" ignored"" + "" at "" + getLocation() + "" originally loaded at "" + resourceStack.getStack().get(url), Project.MSG_WARN);
				 }
				 else {
					 try {
						 resourceStack.getStack().put(url, getLocation());
						 loadAntlib(al, url);
					 }
					 finally {
						 resourceStack.getStack().remove(url);
					 }
				 }
			 }
		 }
	 }
 }",0,0,0,0
"public class RefreshAuthorizationPolicyProtocolClientSideTranslatorPB implements ProtocolMetaInterface, RefreshAuthorizationPolicyProtocol, Closeable {
	 private final static RpcController NULL_CONTROLLER = null;
	 private final RefreshAuthorizationPolicyProtocolPB rpcProxy;
	 private final static RefreshServiceAclRequestProto VOID_REFRESH_SERVICE_ACL_REQUEST = RefreshServiceAclRequestProto.newBuilder().build();
	 public RefreshAuthorizationPolicyProtocolClientSideTranslatorPB( RefreshAuthorizationPolicyProtocolPB rpcProxy) {
		 this.rpcProxy = rpcProxy;
	 }
	 public void close() throws IOException {
		 RPC.stopProxy(rpcProxy);
	 }
	 public void refreshServiceAcl() throws IOException {
		 try {
			 rpcProxy.refreshServiceAcl(NULL_CONTROLLER, VOID_REFRESH_SERVICE_ACL_REQUEST);
		 }
		 catch (ServiceException se) {
			 throw ProtobufHelper.getRemoteException(se);
		 }
	 }
	 public boolean isMethodSupported(String methodName) throws IOException {
		 return RpcClientUtil.isMethodSupported(rpcProxy, RefreshAuthorizationPolicyProtocolPB.class, RPC.RpcKind.RPC_PROTOCOL_BUFFER, RPC.getProtocolVersion(RefreshAuthorizationPolicyProtocolPB.class), methodName);
	 }
}",0,0,0,0
"int loadFSEdits(File edits, Configuration conf) throws IOException {
	 int numEdits = 0;
	 int logVersion = 0;
	 if (edits.exists()) {
		 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(edits)));
		 in.mark( 4 );
		 if( in.available() > 0 ) {
			 logVersion = in.readByte();
			 in.reset();
			 if( logVersion >= 0 ) logVersion = 0;
			 else logVersion = in.readInt();
			 if( logVersion < DFS_CURRENT_VERSION ) throw new IOException( ""Unexpected version of the file system log file: "" + logVersion + "". Current version = "" + DFS_CURRENT_VERSION + ""."" );
		 }
		 short replication = (short)conf.getInt(""dfs.replication"", 3);
		 try {
			 while (in.available() > 0) {
				 byte opcode = in.readByte();
				 numEdits++;
				 switch (opcode) {
					 case OP_ADD: {
						 UTF8 name = new UTF8();
						 ArrayWritable aw = null;
						 Writable writables[];
						 if( logVersion >= 0 ) name.readFields(in);
						 else {
							 aw = new ArrayWritable(UTF8.class);
							 aw.readFields(in);
							 writables = aw.get();
							 if( writables.length != 2 ) throw new IOException(""Incorrect data fortmat. "" + ""Name & replication pair expected"");
							 name = (UTF8) writables[0];
							 replication = Short.parseShort( ((UTF8)writables[1]).toString());
							 replication = adjustReplication( replication, conf );
						 }
						 aw = new ArrayWritable(Block.class);
						 aw.readFields(in);
						 writables = aw.get();
						 Block blocks[] = new Block[writables.length];
						 System.arraycopy(writables, 0, blocks, 0, blocks.length);
						 unprotectedAddFile(name, new INode( name.toString(), blocks, replication ));
						 break;
					 }
					 case OP_SET_REPLICATION: {
						 UTF8 src = new UTF8();
						 UTF8 repl = new UTF8();
						 src.readFields(in);
						 repl.readFields(in);
						 replication=adjustReplication( fromLogReplication(repl), conf);
						 unprotectedSetReplication(src.toString(), replication, null);
						 break;
					 }
					 case OP_RENAME: {
						 UTF8 src = new UTF8();
						 UTF8 dst = new UTF8();
						 src.readFields(in);
						 dst.readFields(in);
						 unprotectedRenameTo(src, dst);
						 break;
					 }
					 case OP_DELETE: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 unprotectedDelete(src);
						 break;
					 }
					 case OP_MKDIR: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 unprotectedMkdir(src.toString());
						 break;
					 }
					 default: {
						 throw new IOException(""Never seen opcode "" + opcode);
					 }
				 }
			 }
		 }
		 finally {
			 in.close();
		 }
	 }
	 if( logVersion != DFS_CURRENT_VERSION ) numEdits++;
	 return numEdits;
 }",0,0,1,0
"public BytesRef next() {
	 if (input.position() < end) {
		 try {
			 int code = input.readVInt();
			 boolean newField = (code & 1) != 0;
			 if (newField) {
				 field = input.readString();
			 }
			 int prefix = code >>> 1;
			 int suffix = input.readVInt();
			 readTermBytes(prefix, suffix);
			 return bytes;
		 }
		 catch (IOException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 else {
		 field = null;
		 return null;
	 }
 }",0,0,1,0
"public class ArrayMap<K, V> extends AbstractMap<K, V> {
	 private Object[] table;
	 private int size;
	 protected transient Collection<V> values;
	 public ArrayMap() {
		 this(32);
	 }
	 public ArrayMap(int capacity) {
		 table = new Object[capacity * 2];
		 size = 0;
	 }
	 public V get(Object key) {
		 for (int i = 0, l = size << 1;
		 i < l;
		 i += 2) {
			 if (key.equals(table[i])) {
				 return (V) table[i + 1];
			 }
		 }
		 return null;
	 }
	 public V put(K key, V value) {
		 for (int i = 0, l = size << 1;
		 i < l;
		 i += 2) {
			 if (key.equals(table[i])) {
				 V old = (V) table[i + 1];
				 table[i + 1] = value;
				 return old;
			 }
		 }
		 if (size * 2 == table.length) {
			 Object[] n = new Object[table.length * 2];
			 System.arraycopy(table, 0, n, 0, table.length);
			 table = n;
		 }
		 int i = size++ << 1;
		 table[i++] = key;
		 table[i] = value;
		 return null;
	 }
	 public V getOrCompute(K key) {
		 for (int i = 0, l = size << 1;
		 i < l;
		 i += 2) {
			 if (key.equals(table[i])) {
				 return (V) table[i + 1];
			 }
		 }
		 V v = compute(key);
		 if (size << 1 == table.length) {
			 Object[] n = new Object[table.length << 1];
			 System.arraycopy(table, 0, n, 0, table.length);
			 table = n;
		 }
		 int i = size++ << 1;
		 table[i++] = key;
		 table[i] = v;
		 return v;
	 }
	 protected V compute(K key) {
		 throw new UnsupportedOperationException();
	 }
	 public Collection<V> values() {
		 if (values == null) {
			 values = new AbstractCollection<V>() {
				 public Iterator<V> iterator() {
					 return new Iterator<V>() {
						 int index = 0;
						 public boolean hasNext() {
							 return index < size;
						 }
						 public V next() {
							 if (index >= size) {
								 throw new NoSuchElementException();
							 }
							 return (V) table[(index++ << 1) + 1];
						 }
						 public void remove() {
							 throw new UnsupportedOperationException();
						 }
					 }
					;
				 }
				 public int size() {
					 return size;
				 }
			 }
			;
		 }
		 return values;
	 }
	 public Set<Entry<K, V>> entrySet() {
		 return new AbstractSet<Entry<K, V>>() {
			 public Iterator<Entry<K, V>> iterator() {
				 return new Iterator<Entry<K, V>>() {
					 FastEntry<K, V> entry = new FastEntry<K, V>();
					 int index = 0;
					 public boolean hasNext() {
						 return index < size;
					 }
					 public FastEntry<K, V> next() {
						 if (index >= size) {
							 throw new NoSuchElementException();
						 }
						 int i = index << 1;
						 entry.key = (K) table[i];
						 entry.value = (V) table[i + 1];
						 index++;
						 return entry;
					 }
					 public void remove() {
						 throw new UnsupportedOperationException();
					 }
				 }
				;
			 }
			 public int size() {
				 return size;
			 }
		 }
		;
	 }
	 static class FastEntry<K, V> implements Entry<K, V> {
		 K key;
		 V value;
		 public K getKey() {
			 return key;
		 }
		 public V getValue() {
			 return value;
		 }
		 public V setValue(V value) {
			 throw new UnsupportedOperationException();
		 }
	 }
}",1,0,0,0
"public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgColor, ImageObserver imageobserver);",0,0,0,1
"public class ShadowNfcAdapter {
	 NfcAdapter nfcAdapter;
	 private static boolean hardwareExists = true;
	 private boolean enabled;
	 private Activity enabledActivity;
	 private PendingIntent intent;
	 private IntentFilter[] filters;
	 private String[][] techLists;
	 private Activity disabledActivity;
	 private NdefMessage ndefPushMessage;
	 private boolean ndefPushMessageSet;
	 private NfcAdapter.CreateNdefMessageCallback ndefPushMessageCallback;
	 private NfcAdapter.OnNdefPushCompleteCallback onNdefPushCompleteCallback;
	 protected static NfcAdapter getNfcAdapter(Context context) {
		 if (!hardwareExists) {
			 return null;
		 }
		 return ReflectionHelpers.callConstructor(NfcAdapter.class);
	 }
	 protected void enableForegroundDispatch( Activity activity, PendingIntent intent, IntentFilter[] filters, String[][] techLists) {
		 this.enabledActivity = activity;
		 this.intent = intent;
		 this.filters = filters;
		 this.techLists = techLists;
	 }
	 protected void disableForegroundDispatch(Activity activity) {
		 disabledActivity = activity;
	 }
	 protected void setNdefPushMessage( NdefMessage message, Activity activity, Activity... activities) {
		 if (activity == null) {
			 throw new NullPointerException(""activity cannot be null"");
		 }
		 for (Activity a : activities) {
			 if (a == null) {
				 throw new NullPointerException(""activities cannot contain null"");
			 }
		 }
		 this.ndefPushMessage = message;
		 this.ndefPushMessageSet = true;
	 }
	 protected void setNdefPushMessageCallback( NfcAdapter.CreateNdefMessageCallback callback, Activity activity, Activity... activities) {
		 this.ndefPushMessageCallback = callback;
	 }
	 protected void setOnNdefPushCompleteCallback( NfcAdapter.OnNdefPushCompleteCallback callback, Activity activity, Activity... activities) {
		 if (activity == null) {
			 throw new NullPointerException(""activity cannot be null"");
		 }
		 for (Activity a : activities) {
			 if (a == null) {
				 throw new NullPointerException(""activities cannot contain null"");
			 }
		 }
		 this.onNdefPushCompleteCallback = callback;
	 }
	 protected boolean isEnabled() {
		 return enabled;
	 }
	 public static void setNfcHardwareExists(boolean hardwareExists) {
		 ShadowNfcAdapter.hardwareExists = hardwareExists;
	 }
	 public void setEnabled(boolean enabled) {
		 this.enabled = enabled;
	 }
	 public Activity getEnabledActivity() {
		 return enabledActivity;
	 }
	 public PendingIntent getIntent() {
		 return intent;
	 }
	 public IntentFilter[] getFilters() {
		 return filters;
	 }
	 public String[][] getTechLists() {
		 return techLists;
	 }
	 public Activity getDisabledActivity() {
		 return disabledActivity;
	 }
	 public NfcAdapter.CreateNdefMessageCallback getNdefPushMessageCallback() {
		 return ndefPushMessageCallback;
	 }
	 public NfcAdapter.OnNdefPushCompleteCallback getOnNdefPushCompleteCallback() {
		 return onNdefPushCompleteCallback;
	 }
	 public NdefMessage getNdefPushMessage() {
		 if (!ndefPushMessageSet) {
			 throw new IllegalStateException();
		 }
		 return ndefPushMessage;
	 }
	 public static synchronized void reset() {
		 hardwareExists = true;
	 }
}",1,1,0,0
"public class TimelineMetricCacheProvider {
	 private TimelineMetricCache timelineMetricsCache;
	 private volatile boolean isCacheInitialized = false;
	 public static final String TIMELINE_METRIC_CACHE_MANAGER_NAME = ""timelineMetricCacheManager"";
	 public static final String TIMELINE_METRIC_CACHE_INSTANCE_NAME = ""timelineMetricCache"";
	 Configuration configuration;
	 TimelineMetricCacheEntryFactory cacheEntryFactory;
	 private final static Logger LOG = LoggerFactory.getLogger(TimelineMetricCacheProvider.class);
	 public TimelineMetricCacheProvider(Configuration configuration, TimelineMetricCacheEntryFactory cacheEntryFactory) {
		 this.configuration = configuration;
		 this.cacheEntryFactory = cacheEntryFactory;
	 }
	 private synchronized void initializeCache() {
		 if (isCacheInitialized) {
			 return;
		 }
		 System.setProperty(""net.sf.ehcache.skipUpdateCheck"", ""true"");
		 if (configuration.useMetricsCacheCustomSizingEngine()) {
			 System.setProperty(""net.sf.ehcache.sizeofengine."" + TIMELINE_METRIC_CACHE_MANAGER_NAME, ""org.apache.ambari.server.controller.metrics.timeline.cache.TimelineMetricsCacheSizeOfEngine"");
		 }
		 net.sf.ehcache.config.Configuration managerConfig = new net.sf.ehcache.config.Configuration();
		 managerConfig.setName(TIMELINE_METRIC_CACHE_MANAGER_NAME);
		 managerConfig.setMaxBytesLocalHeap(configuration.getMetricsCacheManagerHeapPercent());
		 CacheManager manager = CacheManager.create(managerConfig);
		 LOG.info(""Creating Metrics Cache with timeouts => ttl = "" + configuration.getMetricCacheTTLSeconds() + "", idle = "" + configuration.getMetricCacheIdleSeconds());
		 CacheConfiguration cacheConfiguration = createCacheConfiguration();
		 Cache cache = new Cache(cacheConfiguration);
		 timelineMetricsCache = new TimelineMetricCache(cache, cacheEntryFactory);
		 LOG.info(""Registering metrics cache with provider: name = "" + cache.getName() + "", guid: "" + cache.getGuid());
		 manager.addCache(timelineMetricsCache);
		 isCacheInitialized = true;
	 }
	 public CacheConfiguration createCacheConfiguration() {
		 CacheConfiguration cacheConfiguration = new CacheConfiguration() .name(TIMELINE_METRIC_CACHE_INSTANCE_NAME) .timeToLiveSeconds(configuration.getMetricCacheTTLSeconds()) .timeToIdleSeconds(configuration.getMetricCacheIdleSeconds()) .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU) .sizeOfPolicy(new SizeOfPolicyConfiguration() .maxDepth(10000) .maxDepthExceededBehavior(MaxDepthExceededBehavior.CONTINUE)) .eternal(false) .persistence(new PersistenceConfiguration() .strategy(Strategy.NONE.name()));
		 return cacheConfiguration;
	 }
	 public TimelineMetricCache getTimelineMetricsCache() {
		 if (configuration.isMetricsCacheDisabled()) {
			 return null;
		 }
		 if (!isCacheInitialized) {
			 initializeCache();
		 }
		 return timelineMetricsCache;
	 }
}",0,0,0,0
"public void addHeader(String name, String value){
	List<String> list = (List<String>)headers.get(name);
	if (list == null){
		list = new ArrayList<String>(1);
		headers.put(name, list);
	}
	list.add(value);
}",0,0,0,0
"public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
	 TokenStream input = (TokenStream)_input;
	 int _s = s;
	 switch ( s ) {
		 case 0 : int LA60_0 = input.LA(1);
		 int index60_0 = input.index();
		 input.rewind();
		 s = -1;
		 if ( (LA60_0==RULE_ID) ) {
			s = 1;
		}
		 else if ( (LA60_0==14) ) {
			s = 2;
		}
		 else if ( (LA60_0==39) && (synpred33_InternalXbaseWithAnnotations())) {
			s = 3;
		}
		 else if ( ((LA60_0>=RULE_STRING && LA60_0<=RULE_DECIMAL)||(LA60_0>=18 && LA60_0<=19)||LA60_0==26||(LA60_0>=42 && LA60_0<=43)||LA60_0==48||LA60_0==55||LA60_0==59||LA60_0==61||(LA60_0>=65 && LA60_0<=67)||(LA60_0>=70 && LA60_0<=82)||LA60_0==84) ) {
			s = 4;
		}
		 input.seek(index60_0);
		 if ( s>=0 ) return s;
		 break;
		 case 1 : int LA60_1 = input.LA(1);
		 int index60_1 = input.index();
		 input.rewind();
		 s = -1;
		 if ( (synpred33_InternalXbaseWithAnnotations()) ) {
			s = 3;
		}
		 else if ( (true) ) {
			s = 4;
		}
		 input.seek(index60_1);
		 if ( s>=0 ) return s;
		 break;
		 case 2 : int LA60_2 = input.LA(1);
		 int index60_2 = input.index();
		 input.rewind();
		 s = -1;
		 if ( (synpred33_InternalXbaseWithAnnotations()) ) {
			s = 3;
		}
		 else if ( (true) ) {
			s = 4;
		}
		 input.seek(index60_2);
		 if ( s>=0 ) return s;
		 break;
	 }
	 if (state.backtracking>0) {
		state.failed=true;
		 return -1;
	}
	 NoViableAltException nvae = new NoViableAltException(getDescription(), 60, _s, input);
	 error(nvae);
	 throw nvae;
 }",0,0,1,0
"public class JdbcSource implements ISource {
	 private static final Logger logger = LoggerFactory.getLogger(JdbcSource.class);
	 public static final int SOURCE_ID = 16;
	 private JdbcConnector dataSource;
	 public JdbcSource(KylinConfig config) {
		 try {
			 dataSource = SourceConnectorFactory.getJdbcConnector(config);
		 }
		 catch (Throwable e) {
			 logger.warn(""DataSource cannot be connected. This may not be required in a MapReduce job."", e);
		 }
	 }
	 public ISourceMetadataExplorer getSourceMetadataExplorer() {
		 return new JdbcExplorer(dataSource);
	 }
	 public <I> I adaptToBuildEngine(Class<I> engineInterface) {
		 if (engineInterface == IMRInput.class) {
			 return (I) new JdbcHiveMRInput(dataSource);
		 }
		 else if (engineInterface == ISparkInput.class) {
			 return (I) new JdbcHiveSparkInput(dataSource);
		 }
		 else {
			 throw new RuntimeException(""Cannot adapt to "" + engineInterface);
		 }
	 }
	 public IReadableTable createReadableTable(TableDesc tableDesc, String uuid) {
		 return new JdbcTable(dataSource, tableDesc);
	 }
	 public SourcePartition enrichSourcePartitionBeforeBuild(IBuildable buildable, SourcePartition srcPartition) {
		 SourcePartition result = SourcePartition.getCopyOf(srcPartition);
		 result.setSegRange(null);
		 return result;
	 }
	 public ISampleDataDeployer getSampleDataDeployer() {
		 return new JdbcExplorer(dataSource);
	 }
	 public void unloadTable(String tableName, String project) throws IOException{
	 }
	 public void close() throws IOException {
		 if (dataSource != null) dataSource.close();
	 }
}",0,0,0,0
"static class DFA12 extends DFA {
	 public DFA12(BaseRecognizer recognizer) {
		 this.recognizer = recognizer;
		 this.decisionNumber = 12;
		 this.eot = DFA12_eot;
		 this.eof = DFA12_eof;
		 this.min = DFA12_min;
		 this.max = DFA12_max;
		 this.accept = DFA12_accept;
		 this.special = DFA12_special;
		 this.transition = DFA12_transition;
	 }
	 public String getDescription() {
		 return ""1:1: Tokens : ( T__11 | T__12 | T__13 | T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | RULE_ID | RULE_INT | RULE_STRING | RULE_ML_COMMENT | RULE_SL_COMMENT | RULE_WS | RULE_ANY_OTHER );
		"";
	 }
	 public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
		 IntStream input = _input;
		 int _s = s;
		 switch ( s ) {
			 case 0 : int LA12_0 = input.LA(1);
			 s = -1;
			 if ( (LA12_0=='s') ) {
				s = 1;
			}
			 else if ( (LA12_0=='c') ) {
				s = 2;
			}
			 else if ( (LA12_0=='i') ) {
				s = 3;
			}
			 else if ( (LA12_0=='a') ) {
				s = 4;
			}
			 else if ( (LA12_0=='d') ) {
				s = 5;
			}
			 else if ( (LA12_0=='^') ) {
				s = 6;
			}
			 else if ( ((LA12_0>='A' && LA12_0<='Z')||LA12_0=='_'||LA12_0=='b'||(LA12_0>='e' && LA12_0<='h')||(LA12_0>='j' && LA12_0<='r')||(LA12_0>='t' && LA12_0<='z')) ) {
				s = 7;
			}
			 else if ( ((LA12_0>='0' && LA12_0<='9')) ) {
				s = 8;
			}
			 else if ( (LA12_0=='\""') ) {
				s = 9;
			}
			 else if ( (LA12_0=='\'') ) {
				s = 10;
			}
			 else if ( (LA12_0=='/') ) {
				s = 11;
			}
			 else if ( ((LA12_0>='\t' && LA12_0<='\n')||LA12_0=='\r'||LA12_0==' ') ) {
				s = 12;
			}
			 else if ( ((LA12_0>='\u0000' && LA12_0<='\b')||(LA12_0>='\u000B' && LA12_0<='\f')||(LA12_0>='\u000E' && LA12_0<='\u001F')||LA12_0=='!'||(LA12_0>='#' && LA12_0<='&')||(LA12_0>='(' && LA12_0<='.')||(LA12_0>=':' && LA12_0<='@')||(LA12_0>='[' && LA12_0<=']')||LA12_0=='`'||(LA12_0>='{
				' && LA12_0<='\uFFFF')) ) {
					s = 13;
				}
				 if ( s>=0 ) return s;
				 break;
				 case 1 : int LA12_9 = input.LA(1);
				 s = -1;
				 if ( ((LA12_9>='\u0000' && LA12_9<='\uFFFF')) ) {
					s = 22;
				}
				 else s = 13;
				 if ( s>=0 ) return s;
				 break;
				 case 2 : int LA12_10 = input.LA(1);
				 s = -1;
				 if ( ((LA12_10>='\u0000' && LA12_10<='\uFFFF')) ) {
					s = 22;
				}
				 else s = 13;
				 if ( s>=0 ) return s;
				 break;
			 }
			 NoViableAltException nvae = new NoViableAltException(getDescription(), 12, _s, input);
			 error(nvae);
			 throw nvae;
		 }
	 }",1,0,0,0
"private int resolveCharEnt(StringBuffer originalCharacters) throws XMLStreamException {
	 int value = 0;
	 char c = getNextChar(SUFFIX_IN_ENTITY_REF);
	 if (originalCharacters != null) {
		 originalCharacters.append(c);
	 }
	 if (c == 'x') {
		 while (true) {
			 c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++] : getNextCharFromCurrent(SUFFIX_IN_ENTITY_REF);
			 if (c == ';
			') {
				 break;
			 }
			 if (originalCharacters != null) {
				 originalCharacters.append(c);
			 }
			 value = value << 4;
			 if (c <= '9' && c >= '0') {
				 value += (c - '0');
			 }
			 else if (c >= 'a' && c <= 'f') {
				 value += 10 + (c - 'a');
			 }
			 else if (c >= 'A' && c <= 'F') {
				 value += 10 + (c - 'A');
			 }
			 else {
				 throwUnexpectedChar(c, "";
				 expected a hex digit (0-9a-fA-F)."");
			 }
			 if (value > MAX_UNICODE_CHAR) {
				 reportUnicodeOverflow();
			 }
		 }
	 }
	 else {
		 while (c != ';
		') {
			 if (c <= '9' && c >= '0') {
				 value = (value * 10) + (c - '0');
				 if (value > MAX_UNICODE_CHAR) {
					 reportUnicodeOverflow();
				 }
			 }
			 else {
				 throwUnexpectedChar(c, "";
				 expected a decimal number."");
			 }
			 c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++] : getNextCharFromCurrent(SUFFIX_IN_ENTITY_REF);
			 if (originalCharacters != null && c != ';
			') {
				 originalCharacters.append(c);
			 }
		 }
	 }
	 validateChar(value);
	 return value;
 }",0,0,1,0
"public static void validateKeyspaceNotSystem(String modifiedKeyspace) throws InvalidRequestException {
	 if (modifiedKeyspace.equalsIgnoreCase(Table.SYSTEM_TABLE)) throw new InvalidRequestException(""system keyspace is not user-modifiable"");
 }",0,0,0,0
"public String classify(double[] pattern) {
	 NeuralNetwork<T> nnet = getParentNetwork();
	 nnet.setInput(pattern);
	 nnet.calculate();
	 Neuron maxNeuron = null;
	 double maxOutput = Double.MIN_VALUE;
	 for (Neuron neuron : nnet.getOutputNeurons()) {
		 if (neuron.getOutput() > maxOutput) {
			 maxOutput = neuron.getOutput();
			 maxNeuron = neuron;
		 }
	 }
	 if (maxOutput > threshold) return maxNeuron.getLabel();
	 else return null;
 }",0,0,0,0
"public static void keepAwakePing() {
	try {
		int os = detectOS();
		if (os == LINUX) {
			LinuxUtils.keepAwakePing();
		}
		 else if (os == WINDOWS) {
			WinUtils.keepAwakePing();
		}
		 else if (os == MAC) {
			MacUtils.keepAwakePing();
		}
	}
	 catch (Throwable e) {
		Logger.log(e);
	}
}",0,0,0,0
"private void processSingleRecord(final Record record) {
	 String data = null;
	 final ObjectMapper mapper = new ObjectMapper();
	 try {
		 final ByteBuffer buffer = record.getData();
		 data = new String(buffer.array(), ""UTF-8"");
		 final RekognitionOutput output = mapper.readValue(data, RekognitionOutput.class);
		 final String fragmentNumber = output .getInputInformation() .getKinesisVideo() .getFragmentNumber();
		 final Double frameOffsetInSeconds = output .getInputInformation() .getKinesisVideo() .getFrameOffsetInSeconds();
		 final Double serverTimestamp = output .getInputInformation() .getKinesisVideo() .getServerTimestamp();
		 final Double producerTimestamp = output .getInputInformation() .getKinesisVideo() .getProducerTimestamp();
		 final double detectedTime = output.getInputInformation().getKinesisVideo().getServerTimestamp() + output.getInputInformation().getKinesisVideo().getFrameOffsetInSeconds() * 1000L;
		 final RekognizedOutput rekognizedOutput = RekognizedOutput.builder() .fragmentNumber(fragmentNumber) .serverTimestamp(serverTimestamp) .producerTimestamp(producerTimestamp) .frameOffsetInSeconds(frameOffsetInSeconds) .detectedTime(detectedTime) .build();
		 final List<FaceSearchResponse> responses = output.getFaceSearchResponse();
		 responses.forEach(response -> {
			 final DetectedFace detectedFace = response.getDetectedFace();
			 final List<MatchedFace> matchedFaces = response.getMatchedFaces();
			 final RekognizedOutput.FaceSearchOutput faceSearchOutput = RekognizedOutput.FaceSearchOutput.builder() .detectedFace(detectedFace) .matchedFaceList(matchedFaces) .build();
			 rekognizedOutput.addFaceSearchOutput(faceSearchOutput);
		 }
		);
		 log.info(""Found Rekognized results for fragment number : {
		}
		"", fragmentNumber);
		 rekognizedFragmentsIndex.add(fragmentNumber, producerTimestamp.longValue(), serverTimestamp.longValue(), rekognizedOutput);
	 }
	 catch (final NumberFormatException e) {
		 log.warn(""Record does not match sample record format. Ignoring record with data : {
		}
		"", data, e);
	 }
	 catch (final Exception e) {
		 log.error(""Unable to process record !"", e);
	 }
 }",0,0,1,0
"public class ScriptSchemaTestLoader extends PigStorageWithSchema {
	static volatile Schema scriptSchema;
	public ResourceSchema getSchema(String location, Job job)throws IOException {
		scriptSchema = Utils.getScriptSchema(getUDFContextSignature(),job.getConfiguration());
		return null;
	}
	public static Schema getScriptSchema() {
		return scriptSchema;
	}
}",1,0,0,0
"public class TestTezJobControlCompiler {
	 private static PigContext pc;
	 private static PigServer pigServer;
	 private static URI input1;
	 private static URI input2;
	 public static void setUpBeforeClass() throws Exception {
		 input1 = Util.createTempFileDelOnExit(""input1"", ""txt"").toURI();
		 input2 = Util.createTempFileDelOnExit(""input2"", ""txt"").toURI();
		 FileUtils.deleteDirectory(new File(""/tmp/pigoutput""));
	 }
	 public static void tearDownAfterClass() throws Exception {
	 }
	 public void setUp() throws ExecException {
		 pc = new PigContext(new TezLocalExecType(), new Properties());
		 pigServer = new PigServer(pc);
	 }
	 public void testRun1() throws Exception {
		 String query = ""a = load '"" + input1 +""' as (x:int, y:int);
		"" + ""b = filter a by x > 0;
		"" + ""c = foreach b generate y;
		"" + ""store c into 'file: Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 List<TezOperator> roots = compiledPlan.first.getRoots();
		 assertEquals(1, roots.size());
		 Vertex root = compiledPlan.second.getVertex(roots.get(0).getOperatorKey().toString());
		 assertNotNull(root);
		 assertEquals(0, root.getInputVertices().size());
		 assertEquals(0, root.getOutputVertices().size());
	 }
	 public void testRun2() throws Exception {
		 String query = ""a = load '"" + input1 +""' as (x:int, y:int);
		"" + ""b = group a by x;
		"" + ""c = foreach b generate group, a;
		"" + ""store c into 'file: Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 List<TezOperator> roots = compiledPlan.first.getRoots();
		 assertEquals(1, roots.size());
		 List<TezOperator> leaves = compiledPlan.first.getLeaves();
		 assertEquals(1, leaves.size());
		 Vertex root = compiledPlan.second.getVertex(roots.get(0).getOperatorKey().toString());
		 assertNotNull(root);
		 assertEquals(0, root.getInputVertices().size());
		 assertEquals(1, root.getOutputVertices().size());
		 Vertex leaf = compiledPlan.second.getVertex(leaves.get(0).getOperatorKey().toString());
		 assertNotNull(leaf);
		 assertEquals(1, leaf.getInputVertices().size());
		 assertEquals(0, leaf.getOutputVertices().size());
		 assertEquals(root.getOutputVertices().get(0), leaf);
		 assertEquals(root, leaf.getInputVertices().get(0));
	 }
	 public void testRun3() throws Exception {
		 String query = ""a = load '"" + input1 +""' as (x:int, y:int);
		"" + ""b = load '"" + input2 +""' as (x:int, z:int);
		"" + ""c = join a by x, b by x;
		"" + ""d = foreach c generate a::x as x, y, z;
		"" + ""store d into 'file: Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 List<TezOperator> roots = compiledPlan.first.getRoots();
		 assertEquals(2, roots.size());
		 List<TezOperator> leaves = compiledPlan.first.getLeaves();
		 assertEquals(1, leaves.size());
		 Vertex root0 = compiledPlan.second.getVertex(roots.get(0).getOperatorKey().toString());
		 Vertex root1 = compiledPlan.second.getVertex(roots.get(1).getOperatorKey().toString());
		 assertNotNull(root0);
		 assertNotNull(root1);
		 assertEquals(0, root0.getInputVertices().size());
		 assertEquals(1, root1.getOutputVertices().size());
		 Vertex leaf = compiledPlan.second.getVertex(leaves.get(0).getOperatorKey().toString());
		 assertNotNull(leaf);
		 assertEquals(2, leaf.getInputVertices().size());
		 assertEquals(0, leaf.getOutputVertices().size());
		 assertEquals(root0.getOutputVertices().get(0), leaf);
		 assertEquals(root1.getOutputVertices().get(0), leaf);
		 assertTrue(leaf.getInputVertices().contains(root0));
		 assertTrue(leaf.getInputVertices().contains(root1));
	 }
	 static public class ArbitarySplitsInputformat extends TextInputFormat {
		 public List<InputSplit> getSplits(JobContext job) throws IOException {
			 String inputDir = job.getConfiguration().get(INPUT_DIR, """");
			 String numSplitString = inputDir.substring(inputDir.lastIndexOf(""/"")+1);
			 int numSplit = Integer.parseInt(numSplitString);
			 List<InputSplit> splits = new ArrayList<InputSplit>();
			 for (int i=0;
			i<numSplit;
			i++) {
				 splits.add(new FileSplit(new Path(""dummy""), 0, 0, null));
			 }
			 return splits;
		 }
	 }
	 static public class ArbitarySplitsLoader extends PigStorage {
		 public ArbitarySplitsLoader() {
		}
		 public InputFormat getInputFormat() {
			 return new ArbitarySplitsInputformat();
		 }
	 }
	 public void testTezParallelismEstimatorOrderBy() throws Exception{
		 pc.getProperties().setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 String query = ""a = load '2' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, age:int, gpa:double);
		"" + ""b = group a by name parallel 3;
		"" + ""c = foreach b generate group as name, AVG(a.age) as age;
		"" + ""d = order c by age;
		"" + ""store d into 'output';
		"";
		 Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 TezOperator sortOper = compiledPlan.first.getLeaves().get(0);
		 Vertex sortVertex = compiledPlan.second.getVertex(sortOper.getOperatorKey().toString());
		 assertEquals(sortVertex.getParallelism(), -1);
	 }
	 public void testTezParallelismEstimatorFilterFlatten() throws Exception{
		 pc.getProperties().setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 String query = ""a = load '10' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, age:int, gpa:double);
		"" + ""b = filter a by age>20;
		"" + ""c = group b by name;
		"" + ""d = foreach c generate group, flatten(b.gpa);
		"" + ""e = group d by group;
		"" + ""store e into 'output';
		"";
		 Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 TezOperator leafOper = compiledPlan.first.getLeaves().get(0);
		 assertTrue(leafOper.isUseGraceParallelism());
		 Vertex leafVertex = compiledPlan.second.getVertex(leafOper.getOperatorKey().toString());
		 assertEquals(leafVertex.getParallelism(), -1);
	 }
	 public void testTezParallelismEstimatorHashJoin() throws Exception{
		 pc.getProperties().setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 String query = ""a = load '10' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, age:int, gpa:double);
		"" + ""b = load '5' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, course:chararray);
		"" + ""c = join a by name, b by name;
		"" + ""store c into 'output';
		"";
		 Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 TezOperator leafOper = compiledPlan.first.getLeaves().get(0);
		 Vertex leafVertex = compiledPlan.second.getVertex(leafOper.getOperatorKey().toString());
		 assertEquals(leafVertex.getParallelism(), 15);
	 }
	 public void testTezParallelismEstimatorSplitBranch() throws Exception{
		 pc.getProperties().setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 String query = ""a = load '10' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, age:int, gpa:double);
		"" + ""b = filter a by age>20;
		"" + ""c = filter a by age>50;
		"" + ""store b into 'o1';
		"" + ""d = group c by name;
		"" + ""store d into 'o2';
		"";
		 Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 List<TezOperator> leaves = compiledPlan.first.getLeaves();
		 Collections.sort(leaves);
		 TezOperator leafOper = leaves.get(1);
		 assertTrue(leafOper.isUseGraceParallelism());
		 Vertex leafVertex = compiledPlan.second.getVertex(leafOper.getOperatorKey().toString());
		 assertEquals(leafVertex.getParallelism(), -1);
	 }
	 public void testTezParallelismDefaultParallelism() throws Exception{
		 pc.getProperties().setProperty(PigConfiguration.PIG_NO_SPLIT_COMBINATION, ""true"");
		 pc.defaultParallel = 5;
		 String query = ""a = load '10' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, age:int, gpa:double);
		"" + ""b = group a by name;
		"" + ""store b into 'output';
		"";
		 Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 TezOperator leafOper = compiledPlan.first.getLeaves().get(0);
		 Vertex leafVertex = compiledPlan.second.getVertex(leafOper.getOperatorKey().toString());
		 assertEquals(leafVertex.getParallelism(), 5);
		 pc.defaultParallel = -1;
	 }
	 public void testShuffleVertexManagerConfig() throws Exception{
		 pc.getProperties().setProperty(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART, ""0.3"");
		 pc.getProperties().setProperty(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM, ""500"");
		 try {
			 String query = ""a = load '10' using "" + ArbitarySplitsLoader.class.getName() + ""() as (name:chararray, age:int, gpa:double);
			"" + ""b = limit a 5;
			"" + ""c = group b by name;
			"" + ""store c into 'output';
			"";
			 VertexManagerPluginDescriptor vmPlugin = getLeafVertexVMPlugin(query);
			 Configuration vmPluginConf = TezUtils.createConfFromUserPayload(vmPlugin.getUserPayload());
			 assertEquals(PigGraceShuffleVertexManager.class.getName(), vmPlugin.getClassName());
			 assertEquals(7, vmPluginConf.size());
			 assertEquals(""0.3"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MIN_SRC_FRACTION));
			 assertEquals(""0.3"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MAX_SRC_FRACTION));
			 assertEquals(""true"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_ENABLE_AUTO_PARALLEL));
			 assertEquals(""500"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_DESIRED_TASK_INPUT_SIZE));
			 assertEquals(""500"", vmPluginConf.get(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM));
			 pc.getProperties().setProperty(PigConfiguration.PIG_TEZ_GRACE_PARALLELISM, ""false"");
			 vmPlugin = getLeafVertexVMPlugin(query);
			 vmPluginConf = TezUtils.createConfFromUserPayload(vmPlugin.getUserPayload());
			 assertEquals(ShuffleVertexManager.class.getName(), vmPlugin.getClassName());
			 assertEquals(4, vmPluginConf.size());
			 assertEquals(""0.3"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MIN_SRC_FRACTION));
			 assertEquals(""0.3"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MAX_SRC_FRACTION));
			 assertEquals(""true"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_ENABLE_AUTO_PARALLEL));
			 assertEquals(""500"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_DESIRED_TASK_INPUT_SIZE));
			 pc.defaultParallel = 2;
			 vmPlugin = getLeafVertexVMPlugin(query);
			 vmPluginConf = TezUtils.createConfFromUserPayload(vmPlugin.getUserPayload());
			 assertEquals(ShuffleVertexManager.class.getName(), vmPlugin.getClassName());
			 assertEquals(2, vmPluginConf.size());
			 assertEquals(""0.3"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MIN_SRC_FRACTION));
			 assertEquals(""0.3"", vmPluginConf.get(ShuffleVertexManager.TEZ_SHUFFLE_VERTEX_MANAGER_MAX_SRC_FRACTION));
		 }
		 finally {
			 pc.getProperties().remove(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART);
			 pc.getProperties().remove(InputSizeReducerEstimator.BYTES_PER_REDUCER_PARAM);
			 pc.getProperties().remove(PigConfiguration.PIG_TEZ_GRACE_PARALLELISM);
			 pc.defaultParallel = -1;
		 }
	 }
	 private VertexManagerPluginDescriptor getLeafVertexVMPlugin(String query) throws Exception {
		 Pair<TezOperPlan, DAG> compiledPlan = compile(query);
		 TezOperator leafOper = compiledPlan.first.getLeaves().get(0);
		 Vertex leafVertex = compiledPlan.second.getVertex(leafOper.getOperatorKey().toString());
		 Field vmPluginField = Vertex.class.getDeclaredField(""vertexManagerPlugin"");
		 vmPluginField.setAccessible(true);
		 VertexManagerPluginDescriptor vmPlugin = (VertexManagerPluginDescriptor) vmPluginField.get(leafVertex);
		 return vmPlugin;
	 }
	 private Pair<TezOperPlan, DAG> compile(String query) throws Exception {
		 PhysicalPlan pp = Util.buildPp(pigServer, query);
		 TezCompiler comp = new TezCompiler(pp, pc);
		 TezOperPlan tezPlan = comp.compile();
		 TezLauncher.processLoadAndParallelism(tezPlan, pc);
		 TezPlanContainerNode tezPlanNode = new TezPlanContainerNode(OperatorKey.genOpKey(""DAGName""), tezPlan);
		 TezScriptState scriptState = new TezScriptState(""test"");
		 ScriptState.start(scriptState);
		 scriptState.setDAGScriptInfo(tezPlanNode);
		 TezJobCompiler jobComp = new TezJobCompiler(pc, new Configuration());
		 DAG dag = jobComp.buildDAG(tezPlanNode, new HashMap<String, LocalResource>());
		 return new Pair<TezOperPlan, DAG>(tezPlan, dag);
	 }
}",1,0,0,0
"private void handleFetch(ExchangeSession.Message message, int currentIndex, String parameters) throws IOException, MessagingException {
	 StringBuilder buffer = new StringBuilder();
	 MessageWrapper messageWrapper = new MessageWrapper(os, buffer, message);
	 buffer.append(""* "").append(currentIndex).append("" FETCH (UID "").append(message.getImapUid());
	 if (parameters != null) {
		 StringTokenizer paramTokens = new StringTokenizer(parameters);
		 while (paramTokens.hasMoreTokens()) {
			 String param = paramTokens.nextToken().toUpperCase();
			 if (""FLAGS"".equals(param)) {
				 buffer.append("" FLAGS ("").append(message.getImapFlags()).append(')');
			 }
			 else if (""RFC822.SIZE"".equals(param)) {
				 int size;
				 if (parameters.contains(""BODY.PEEK[HEADER.FIELDS ("") && !parameters.contains(""X-LABEL"")) {
					 size = message.size;
				 }
				 else {
					 size = messageWrapper.getMimeMessageSize();
				 }
				 buffer.append("" RFC822.SIZE "").append(size);
			 }
			 else if (""ENVELOPE"".equals(param)) {
				 appendEnvelope(buffer, messageWrapper);
			 }
			 else if (""BODYSTRUCTURE"".equals(param)) {
				 appendBodyStructure(buffer, messageWrapper);
			 }
			 else if (""INTERNALDATE"".equals(param) && message.date != null && message.date.length() > 0) {
				 try {
					 SimpleDateFormat dateParser = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"");
					 dateParser.setTimeZone(ExchangeSession.GMT_TIMEZONE);
					 Date date = ExchangeSession.getZuluDateFormat().parse(message.date);
					 SimpleDateFormat dateFormatter = new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss Z"", Locale.ENGLISH);
					 buffer.append("" INTERNALDATE \"""").append(dateFormatter.format(date)).append('\""');
				 }
				 catch (ParseException e) {
					 throw new DavMailException(""EXCEPTION_INVALID_DATE"", message.date);
				 }
			 }
			 else if (""RFC822"".equals(param) || param.startsWith(""BODY["") || param.startsWith(""BODY.PEEK["") || ""RFC822.HEADER"".equals(param)) {
				 if (param.indexOf('[') >= 0) {
					 StringBuilder paramBuffer = new StringBuilder(param);
					 while (paramTokens.hasMoreTokens() && paramBuffer.indexOf(""]"") < 0) {
						 paramBuffer.append(' ').append(paramTokens.nextToken());
					 }
					 param = paramBuffer.toString();
				 }
				 int startIndex = 0;
				 int maxSize = Integer.MAX_VALUE;
				 int ltIndex = param.indexOf('<');
				 if (ltIndex >= 0) {
					 int dotIndex = param.indexOf('.', ltIndex);
					 if (dotIndex >= 0) {
						 startIndex = Integer.parseInt(param.substring(ltIndex + 1, dotIndex));
						 maxSize = Integer.parseInt(param.substring(dotIndex + 1, param.indexOf('>')));
					 }
				 }
				 ByteArrayOutputStream baos = new ByteArrayOutputStream();
				 InputStream partInputStream = null;
				 OutputStream partOutputStream = null;
				 String partIndexString = StringUtil.getToken(param, ""["", ""]"");
				 if ((partIndexString == null || partIndexString.length() == 0) && !""RFC822.HEADER"".equals(param)) {
					 partOutputStream = new PartialOutputStream(baos, startIndex, maxSize);
					 partInputStream = messageWrapper.getRawInputStream();
				 }
				 else if (""TEXT"".equals(partIndexString)) {
					 partOutputStream = new PartOutputStream(baos, false, true, startIndex, maxSize);
					 partInputStream = messageWrapper.getRawInputStream();
				 }
				 else if (""RFC822.HEADER"".equals(param) || (partIndexString != null && partIndexString.startsWith(""HEADER""))) {
					 String[] requestedHeaders = getRequestedHeaders(partIndexString);
					 if (requestedHeaders != null && requestedHeaders.length == 1 && ""content-class"".equals(requestedHeaders[0]) && message.contentClass != null) {
						 baos.write(""Content-class: "".getBytes(""UTF-8""));
						 baos.write(message.contentClass.getBytes(""UTF-8""));
						 baos.write(13);
						 baos.write(10);
					 }
					 else if (requestedHeaders == null) {
						 partOutputStream = new PartOutputStream(baos, true, false, startIndex, maxSize);
						 partInputStream = messageWrapper.getRawInputStream();
					 }
					 else {
						 Enumeration headerEnumeration = messageWrapper.getMatchingHeaderLines(requestedHeaders);
						 while (headerEnumeration.hasMoreElements()) {
							 baos.write(((String) headerEnumeration.nextElement()).getBytes(""UTF-8""));
							 baos.write(13);
							 baos.write(10);
						 }
					 }
				 }
				 else if (partIndexString != null) {
					 MimePart bodyPart = messageWrapper.getMimeMessage();
					 String[] partIndexStrings = partIndexString.split(""\\."");
					 for (String subPartIndexString : partIndexStrings) {
						 if (""MIME"".equals(subPartIndexString)) {
							 break;
						 }
						 int subPartIndex;
						 try {
							 subPartIndex = Integer.parseInt(subPartIndexString);
						 }
						 catch (NumberFormatException e) {
							 throw new DavMailException(""EXCEPTION_INVALID_PARAMETER"", param);
						 }
						 Object mimeBody = bodyPart.getContent();
						 if (mimeBody instanceof MimeMultipart) {
							 MimeMultipart multiPart = (MimeMultipart) mimeBody;
							 if (subPartIndex - 1 < multiPart.getCount()) {
								 bodyPart = (MimePart) multiPart.getBodyPart(subPartIndex - 1);
							 }
							 else {
								 throw new DavMailException(""EXCEPTION_INVALID_PARAMETER"", param);
							 }
						 }
						 else if (subPartIndex != 1) {
							 throw new DavMailException(""EXCEPTION_INVALID_PARAMETER"", param);
						 }
					 }
					 partOutputStream = new PartialOutputStream(baos, startIndex, maxSize);
					 if (bodyPart instanceof MimeMessage) {
						 partInputStream = ((MimeMessage) bodyPart).getRawInputStream();
					 }
					 else {
						 partInputStream = ((MimeBodyPart) bodyPart).getRawInputStream();
					 }
				 }
				 if (partInputStream != null && partOutputStream != null) {
					 IOUtil.write(partInputStream, partOutputStream);
					 partInputStream.close();
					 partOutputStream.close();
				 }
				 baos.close();
				 if (""RFC822.HEADER"".equals(param)) {
					 buffer.append("" RFC822.HEADER "");
				 }
				 else {
					 buffer.append("" BODY["").append(partIndexString).append(']');
				 }
				 if (startIndex > 0 || maxSize != Integer.MAX_VALUE) {
					 buffer.append('<').append(startIndex).append('>');
				 }
				 buffer.append("" {
				"").append(baos.size()).append('}
				');
				 sendClient(buffer.toString());
				 if (LOGGER.isDebugEnabled() && baos.size() < 2048) {
					 LOGGER.debug(new String(baos.toByteArray(), ""UTF-8""));
				 }
				 os.write(baos.toByteArray());
				 os.flush();
				 buffer.setLength(0);
			 }
		 }
	 }
	 buffer.append(')');
	 sendClient(buffer.toString());
	 message.dropMimeMessage();
 }",0,0,1,0
"from BacklogMetricBean a ""), ,}
)public class BacklogMetricBean {
 private String id;
 private String entityName;
 private String clusterName;
 private Date nominalTime;
 private String entityType;
 public String getId() {
	 return id;
 }
 public String getEntityName() {
	 return entityName;
 }
 public String getClusterName() {
	 return clusterName;
 }
 public Date getNominalTime() {
	 return nominalTime;
 }
 public void setId(String id) {
	 this.id = id;
 }
 public void setEntityName(String entityName) {
	 this.entityName = entityName;
 }
 public void setClusterName(String clusterName) {
	 this.clusterName = clusterName;
 }
 public void setNominalTime(Date nominalTime) {
	 this.nominalTime = nominalTime;
 }
 public String getEntityType() {
	 return entityType;
 }
 public void setEntityType(String entityType) {
	 this.entityType = entityType;
 }
}",0,1,0,0
"public boolean eval() throws BuildException {
	 isCondition = true;
	 return validateAndExecute();
 }",0,0,0,0
"public class AuthorizationManagerAllowAll implements AuthorizationManager {
	 public void init(final DeploymentCategory deploymentCategory) {
	 }
	 public void shutdown() {
	 }
	 public boolean isUsable(final AuthenticationSession session, final ObjectAdapter target, final Identifier identifier) {
		 return true;
	 }
	 public boolean isVisible(final AuthenticationSession session, final ObjectAdapter target, final Identifier identifier) {
		 return true;
	 }
}",0,0,0,0
"public class C extends B {
	public int getInt() {
		return super.getInt();
	}
	public String toString(boolean b, String s) {
		return super.toString(b, s);
	}
	public String run1() {
		return Integer.toString(getInt());
	}
	public String run2() {
		return toString(false, ""abc"");
	}
}",1,0,0,0
"public interface CanalMetricsService {
	 void initialize();
	 void terminate();
	 boolean isRunning();
	 void register(CanalInstance instance);
	 void unregister(CanalInstance instance);
	 void setServerPort(int port);
}",0,0,0,0
"protected String getLogin() {
	 return vssLogin != null ? FLAG_LOGIN + vssLogin : """";
 }",0,0,0,0
"public class RebalanceResult {
	 private Map<String, Map<String, String>> idealStateMapping;
	 private PartitionAssignment partitionAssignment;
	 private String status;
	 public RebalanceResult() {
	 }
	 public RebalanceResult( Map<String, Map<String, String>> idealStateMapping, PartitionAssignment partitionAssignment, String status) {
		 this.idealStateMapping = idealStateMapping;
		 this.partitionAssignment = partitionAssignment;
		 this.status = status;
	 }
	 public Map<String, Map<String, String>> getIdealStateMapping() {
		 return idealStateMapping;
	 }
	 public void setIdealStateMapping(Map<String, Map<String, String>> idealStateMapping) {
		 this.idealStateMapping = idealStateMapping;
	 }
	 public PartitionAssignment getPartitionAssignment() {
		 return partitionAssignment;
	 }
	 public void setPartitionAssignment(PartitionAssignment partitionAssignment) {
		 this.partitionAssignment = partitionAssignment;
	 }
	 public String getStatus() {
		 return status;
	 }
	 public void setStatus(String status) {
		 this.status = status;
	 }
}",0,0,0,0
"public class InternalCacheBuilder {
	 private static final Logger logger = LogService.getLogger();
	 private static final String USE_ASYNC_EVENT_LISTENERS_PROPERTY = GEMFIRE_PREFIX + ""Cache.ASYNC_EVENT_LISTENERS"";
	 private static final boolean IS_EXISTING_OK_DEFAULT = true;
	 private static final boolean IS_CLIENT_DEFAULT = false;
	 private final Properties configProperties;
	 private final CacheConfig cacheConfig;
	 private final CompositeMeterRegistryFactory compositeMeterRegistryFactory;
	 private final Consumer<CompositeMeterRegistry> metricsSessionInitializer;
	 private final Supplier<InternalDistributedSystem> singletonSystemSupplier;
	 private final Supplier<InternalCache> singletonCacheSupplier;
	 private final InternalDistributedSystemConstructor internalDistributedSystemConstructor;
	 private final InternalCacheConstructor internalCacheConstructor;
	 private boolean isExistingOk = IS_EXISTING_OK_DEFAULT;
	 private boolean isClient = IS_CLIENT_DEFAULT;
	 private boolean useAsyncEventListeners = Boolean.getBoolean(USE_ASYNC_EVENT_LISTENERS_PROPERTY);
	 private PoolFactory poolFactory;
	 private TypeRegistry typeRegistry;
	 public InternalCacheBuilder() {
		 this(new Properties(), new CacheConfig());
	 }
	 public InternalCacheBuilder(Properties configProperties) {
		 this(configProperties == null ? new Properties() : configProperties, new CacheConfig());
	 }
	 public InternalCacheBuilder(CacheConfig cacheConfig) {
		 this(new Properties(), cacheConfig);
	 }
	 private InternalCacheBuilder(Properties configProperties, CacheConfig cacheConfig) {
		 this(configProperties, cacheConfig, new CacheMeterRegistryFactory(), CacheLifecycleMetricsSession.builder()::build, InternalDistributedSystem::getConnectedInstance, InternalDistributedSystem::connectInternal, GemFireCacheImpl::getInstance, GemFireCacheImpl::new);
	 }
	 InternalCacheBuilder(Properties configProperties, CacheConfig cacheConfig, CompositeMeterRegistryFactory compositeMeterRegistryFactory, Consumer<CompositeMeterRegistry> metricsSessionInitializer, Supplier<InternalDistributedSystem> singletonSystemSupplier, InternalDistributedSystemConstructor internalDistributedSystemConstructor, Supplier<InternalCache> singletonCacheSupplier, InternalCacheConstructor internalCacheConstructor) {
		 this.configProperties = configProperties;
		 this.cacheConfig = cacheConfig;
		 this.compositeMeterRegistryFactory = compositeMeterRegistryFactory;
		 this.metricsSessionInitializer = metricsSessionInitializer;
		 this.singletonSystemSupplier = singletonSystemSupplier;
		 this.internalDistributedSystemConstructor = internalDistributedSystemConstructor;
		 this.internalCacheConstructor = internalCacheConstructor;
		 this.singletonCacheSupplier = singletonCacheSupplier;
	 }
	 public InternalCache create() throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
		 synchronized (InternalCacheBuilder.class) {
			 InternalDistributedSystem internalDistributedSystem = findInternalDistributedSystem() .orElseGet(() -> createInternalDistributedSystem());
			 return create(internalDistributedSystem);
		 }
	 }
	 public InternalCache create(InternalDistributedSystem internalDistributedSystem) throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
		 requireNonNull(internalDistributedSystem, ""internalDistributedSystem"");
		 try {
			 synchronized (InternalCacheBuilder.class) {
				 synchronized (GemFireCacheImpl.class) {
					 InternalCache cache = existingCache(internalDistributedSystem::getCache, singletonCacheSupplier);
					 if (cache == null) {
						 int systemId = internalDistributedSystem.getConfig().getDistributedSystemId();
						 String memberName = internalDistributedSystem.getName();
						 String hostName = internalDistributedSystem.getDistributedMember().getHost();
						 CompositeMeterRegistry compositeMeterRegistry = compositeMeterRegistryFactory .create(systemId, memberName, hostName);
						 metricsSessionInitializer.accept(compositeMeterRegistry);
						 cache = internalCacheConstructor.construct(isClient, poolFactory, internalDistributedSystem, cacheConfig, useAsyncEventListeners, typeRegistry, compositeMeterRegistry);
						 internalDistributedSystem.setCache(cache);
						 cache.initialize();
					 }
					 else {
						 internalDistributedSystem.setCache(cache);
					 }
					 return cache;
				 }
			 }
		 }
		 catch (CacheXmlException | IllegalArgumentException e) {
			 logger.error(e.getLocalizedMessage());
			 throw e;
		 }
		 catch (Error | RuntimeException e) {
			 logger.error(e);
			 throw e;
		 }
	 }
	 public InternalCacheBuilder set(String name, String value) {
		 configProperties.setProperty(name, value);
		 return this;
	 }
	 public InternalCacheBuilder setPdxReadSerialized(boolean readSerialized) {
		 cacheConfig.setPdxReadSerialized(readSerialized);
		 return this;
	 }
	 public InternalCacheBuilder setSecurityManager(SecurityManager securityManager) {
		 cacheConfig.setSecurityManager(securityManager);
		 return this;
	 }
	 public InternalCacheBuilder setPostProcessor(PostProcessor postProcessor) {
		 cacheConfig.setPostProcessor(postProcessor);
		 return this;
	 }
	 public InternalCacheBuilder setPdxSerializer(PdxSerializer serializer) {
		 cacheConfig.setPdxSerializer(serializer);
		 return this;
	 }
	 public InternalCacheBuilder setPdxDiskStore(String diskStoreName) {
		 cacheConfig.setPdxDiskStore(diskStoreName);
		 return this;
	 }
	 public InternalCacheBuilder setPdxPersistent(boolean isPersistent) {
		 cacheConfig.setPdxPersistent(isPersistent);
		 return this;
	 }
	 public InternalCacheBuilder setPdxIgnoreUnreadFields(boolean ignore) {
		 cacheConfig.setPdxIgnoreUnreadFields(ignore);
		 return this;
	 }
	 public InternalCacheBuilder setCacheXMLDescription(String cacheXML) {
		 if (cacheXML != null) {
			 cacheConfig.setCacheXMLDescription(cacheXML);
		 }
		 return this;
	 }
	 public InternalCacheBuilder setIsExistingOk(boolean isExistingOk) {
		 this.isExistingOk = isExistingOk;
		 return this;
	 }
	 public InternalCacheBuilder setIsClient(boolean isClient) {
		 this.isClient = isClient;
		 return this;
	 }
	 public InternalCacheBuilder setUseAsyncEventListeners(boolean useAsyncEventListeners) {
		 this.useAsyncEventListeners = useAsyncEventListeners;
		 return this;
	 }
	 public InternalCacheBuilder setPoolFactory(PoolFactory poolFactory) {
		 this.poolFactory = poolFactory;
		 return this;
	 }
	 public InternalCacheBuilder setTypeRegistry(TypeRegistry typeRegistry) {
		 this.typeRegistry = typeRegistry;
		 return this;
	 }
	 private Optional<InternalDistributedSystem> findInternalDistributedSystem() {
		 InternalDistributedSystem internalDistributedSystem = null;
		 if (configProperties.isEmpty() && !ALLOW_MULTIPLE_SYSTEMS) {
			 internalDistributedSystem = singletonSystemSupplier.get();
			 validateUsabilityOfSecurityCallbacks(internalDistributedSystem, cacheConfig);
		 }
		 return Optional.ofNullable(internalDistributedSystem);
	 }
	 private InternalDistributedSystem createInternalDistributedSystem() {
		 SecurityConfig securityConfig = new SecurityConfig( cacheConfig.getSecurityManager(), cacheConfig.getPostProcessor());
		 return internalDistributedSystemConstructor.construct(configProperties, securityConfig);
	 }
	 private InternalCache existingCache(Supplier<? extends InternalCache> systemCacheSupplier, Supplier<? extends InternalCache> singletonCacheSupplier) {
		 InternalCache cache = ALLOW_MULTIPLE_SYSTEMS ? systemCacheSupplier.get() : singletonCacheSupplier.get();
		 if (validateExistingCache(cache)) {
			 return cache;
		 }
		 return null;
	 }
	 private boolean validateExistingCache(InternalCache existingCache) {
		 if (existingCache == null || existingCache.isClosed()) {
			 return false;
		 }
		 if (isExistingOk) {
			 cacheConfig.validateCacheConfig(existingCache);
		 }
		 else {
			 existingCache.throwCacheExistsException();
		 }
		 return true;
	 }
	 private static void validateUsabilityOfSecurityCallbacks( InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig) throws GemFireSecurityException {
		 if (internalDistributedSystem == null) {
			 return;
		 }
		 if (cacheConfig.getSecurityManager() != null) {
			 throw new GemFireSecurityException( ""Existing DistributedSystem connection cannot use specified SecurityManager"");
		 }
		 if (cacheConfig.getPostProcessor() != null) {
			 throw new GemFireSecurityException( ""Existing DistributedSystem connection cannot use specified PostProcessor"");
		 }
	 }
	 interface InternalCacheConstructor {
		 InternalCache construct(boolean isClient, PoolFactory poolFactory, InternalDistributedSystem internalDistributedSystem, CacheConfig cacheConfig, boolean useAsyncEventListeners, TypeRegistry typeRegistry, MeterRegistry meterRegistry);
	 }
	 interface InternalDistributedSystemConstructor {
		 InternalDistributedSystem construct(Properties configProperties, SecurityConfig securityConfig);
	 }
}",1,1,0,0
"protected void extractFile(FileUtils fileUtils, File srcF, File dir, InputStream compressedInputStream, String entryName, Date entryDate, boolean isDirectory, FileNameMapper mapper) throws IOException {
	 if (stripAbsolutePathSpec && entryName.length() > 0 && (entryName.charAt(0) == File.separatorChar || entryName.charAt(0) == '/' || entryName.charAt(0) == '\\')) {
		 log(""stripped absolute path spec from "" + entryName, Project.MSG_VERBOSE);
		 entryName = entryName.substring(1);
	 }
	 if (patternsets != null && patternsets.size() > 0) {
		 String name = entryName.replace('/', File.separatorChar) .replace('\\', File.separatorChar);
		 boolean included = false;
		 Set includePatterns = new HashSet();
		 Set excludePatterns = new HashSet();
		 final int size = patternsets.size();
		 for (int v = 0;
		 v < size;
		 v++) {
			 PatternSet p = (PatternSet) patternsets.elementAt(v);
			 String[] incls = p.getIncludePatterns(getProject());
			 if (incls == null || incls.length == 0) {
				 incls = new String[] {
				""**""}
				;
			 }
			 for (int w = 0;
			 w < incls.length;
			 w++) {
				 String pattern = incls[w].replace('/', File.separatorChar) .replace('\\', File.separatorChar);
				 if (pattern.endsWith(File.separator)) {
					 pattern += ""**"";
				 }
				 includePatterns.add(pattern);
			 }
			 String[] excls = p.getExcludePatterns(getProject());
			 if (excls != null) {
				 for (int w = 0;
				 w < excls.length;
				 w++) {
					 String pattern = excls[w] .replace('/', File.separatorChar) .replace('\\', File.separatorChar);
					 if (pattern.endsWith(File.separator)) {
						 pattern += ""**"";
					 }
					 excludePatterns.add(pattern);
				 }
			 }
		 }
		 for (Iterator iter = includePatterns.iterator();
		 !included && iter.hasNext();
		) {
			 String pattern = (String) iter.next();
			 included = SelectorUtils.matchPath(pattern, name);
		 }
		 for (Iterator iter = excludePatterns.iterator();
		 included && iter.hasNext();
		) {
			 String pattern = (String) iter.next();
			 included = !SelectorUtils.matchPath(pattern, name);
		 }
		 if (!included) {
			 log(""skipping "" + entryName + "" as it is excluded or not included."", Project.MSG_VERBOSE);
			 return;
		 }
	 }
	 String[] mappedNames = mapper.mapFileName(entryName);
	 if (mappedNames == null || mappedNames.length == 0) {
		 mappedNames = new String[] {
		entryName}
		;
	 }
	 File f = fileUtils.resolveFile(dir, mappedNames[0]);
	 try {
		 if (!overwrite && f.exists() && f.lastModified() >= entryDate.getTime()) {
			 log(""Skipping "" + f + "" as it is up-to-date"", Project.MSG_DEBUG);
			 return;
		 }
		 log(""expanding "" + entryName + "" to "" + f, Project.MSG_VERBOSE);
		 File dirF = f.getParentFile();
		 if (dirF != null) {
			 dirF.mkdirs();
		 }
		 if (isDirectory) {
			 f.mkdirs();
		 }
		 else {
			 byte[] buffer = new byte[BUFFER_SIZE];
			 int length = 0;
			 FileOutputStream fos = null;
			 try {
				 fos = new FileOutputStream(f);
				 while ((length = compressedInputStream.read(buffer)) >= 0) {
					 fos.write(buffer, 0, length);
				 }
				 fos.close();
				 fos = null;
			 }
			 finally {
				 FileUtils.close(fos);
			 }
		 }
		 fileUtils.setFileLastModified(f, entryDate.getTime());
	 }
	 catch (FileNotFoundException ex) {
		 log(""Unable to expand to file "" + f.getPath(), ex, Project.MSG_WARN);
	 }
 }",0,0,1,0
"private void hqr2 () {
	 int nn = this.n;
	 int n = nn-1;
	 int low = 0;
	 int high = nn-1;
	 double eps = Math.pow(2.0,-52.0);
	 double exshift = 0.0;
	 double p=0,q=0,r=0,s=0,z=0,t,w,x,y;
	 double norm = 0.0;
	 for (int i = 0;
	 i < nn;
	 i++) {
		 if (i < low | i > high) {
			d[i] = H[i][i];
			e[i] = 0.0;
		 }
		 for (int j = Math.max(i-1,0);
		 j < nn;
		 j++) {
			norm = norm + Math.abs(H[i][j]);
		 }
	 }
	 int iter = 0;
	 while (n >= low) {
		 int l = n;
		 while (l > low) {
			s = Math.abs(H[l-1][l-1]) + Math.abs(H[l][l]);
			if (s == 0.0) {
				 s = norm;
			}
			if (Math.abs(H[l][l-1]) < eps * s) {
				 break;
			}
			l--;
		 }
		 if (l == n) {
			H[n][n] = H[n][n] + exshift;
			d[n] = H[n][n];
			e[n] = 0.0;
			n--;
			iter = 0;
		 }
		 else if (l == n-1) {
			w = H[n][n-1] * H[n-1][n];
			p = (H[n-1][n-1] - H[n][n]) / 2.0;
			q = p * p + w;
			z = Math.sqrt(Math.abs(q));
			H[n][n] = H[n][n] + exshift;
			H[n-1][n-1] = H[n-1][n-1] + exshift;
			x = H[n][n];
			if (q >= 0) {
				 if (p >= 0) {
					 z = p + z;
				 }
				 else {
					 z = p - z;
				 }
				 d[n-1] = x + z;
				 d[n] = d[n-1];
				 if (z != 0.0) {
					 d[n] = x - w / z;
				 }
				 e[n-1] = 0.0;
				 e[n] = 0.0;
				 x = H[n][n-1];
				 s = Math.abs(x) + Math.abs(z);
				 p = x / s;
				 q = z / s;
				 r = Math.sqrt(p * p+q * q);
				 p = p / r;
				 q = q / r;
				 for (int j = n-1;
				 j < nn;
				 j++) {
					 z = H[n-1][j];
					 H[n-1][j] = q * z + p * H[n][j];
					 H[n][j] = q * H[n][j] - p * z;
				 }
				 for (int i = 0;
				 i <= n;
				 i++) {
					 z = H[i][n-1];
					 H[i][n-1] = q * z + p * H[i][n];
					 H[i][n] = q * H[i][n] - p * z;
				 }
				 for (int i = low;
				 i <= high;
				 i++) {
					 z = V[i][n-1];
					 V[i][n-1] = q * z + p * V[i][n];
					 V[i][n] = q * V[i][n] - p * z;
				 }
			}
			 else {
				 d[n-1] = x + p;
				 d[n] = x + p;
				 e[n-1] = z;
				 e[n] = -z;
			}
			n = n - 2;
			iter = 0;
		 }
		 else {
			x = H[n][n];
			y = 0.0;
			w = 0.0;
			if (l < n) {
				 y = H[n-1][n-1];
				 w = H[n][n-1] * H[n-1][n];
			}
			if (iter == 10) {
				 exshift += x;
				 for (int i = low;
				 i <= n;
				 i++) {
					 H[i][i] -= x;
				 }
				 s = Math.abs(H[n][n-1]) + Math.abs(H[n-1][n-2]);
				 x = y = 0.75 * s;
				 w = -0.4375 * s * s;
			}
			if (iter == 30) {
				s = (y - x) / 2.0;
				s = s * s + w;
				if (s > 0) {
					s = Math.sqrt(s);
					if (y < x) {
						 s = -s;
					}
					s = x - w / ((y - x) / 2.0 + s);
					for (int i = low;
					 i <= n;
					 i++) {
						 H[i][i] -= s;
					}
					exshift += s;
					x = y = w = 0.964;
				}
			}
			iter = iter + 1;
			 int m = n-2;
			while (m >= l) {
				 z = H[m][m];
				 r = x - z;
				 s = y - z;
				 p = (r * s - w) / H[m+1][m] + H[m][m+1];
				 q = H[m+1][m+1] - z - r - s;
				 r = H[m+2][m+1];
				 s = Math.abs(p) + Math.abs(q) + Math.abs(r);
				 p = p / s;
				 q = q / s;
				 r = r / s;
				 if (m == l) {
					 break;
				 }
				 if (Math.abs(H[m][m-1]) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H[m-1][m-1]) + Math.abs(z) + Math.abs(H[m+1][m+1])))) {
					 break;
				 }
				 m--;
			}
			for (int i = m+2;
			 i <= n;
			 i++) {
				 H[i][i-2] = 0.0;
				 if (i > m+2) {
					 H[i][i-3] = 0.0;
				 }
			}
			for (int k = m;
			 k <= n-1;
			 k++) {
				 boolean notlast = (k != n-1);
				 if (k != m) {
					 p = H[k][k-1];
					 q = H[k+1][k-1];
					 r = (notlast ? H[k+2][k-1] : 0.0);
					 x = Math.abs(p) + Math.abs(q) + Math.abs(r);
					 if (x != 0.0) {
						 p = p / x;
						 q = q / x;
						 r = r / x;
					 }
				 }
				 if (x == 0.0) {
					 break;
				 }
				 s = Math.sqrt(p * p + q * q + r * r);
				 if (p < 0) {
					 s = -s;
				 }
				 if (s != 0) {
					 if (k != m) {
						 H[k][k-1] = -s * x;
					 }
					 else if (l != m) {
						 H[k][k-1] = -H[k][k-1];
					 }
					 p = p + s;
					 x = p / s;
					 y = q / s;
					 z = r / s;
					 q = q / p;
					 r = r / p;
					 for (int j = k;
					 j < nn;
					 j++) {
						 p = H[k][j] + q * H[k+1][j];
						 if (notlast) {
							p = p + r * H[k+2][j];
							H[k+2][j] = H[k+2][j] - p * z;
						 }
						 H[k][j] = H[k][j] - p * x;
						 H[k+1][j] = H[k+1][j] - p * y;
					 }
					 for (int i = 0;
					 i <= Math.min(n,k+3);
					 i++) {
						 p = x * H[i][k] + y * H[i][k+1];
						 if (notlast) {
							p = p + z * H[i][k+2];
							H[i][k+2] = H[i][k+2] - p * r;
						 }
						 H[i][k] = H[i][k] - p;
						 H[i][k+1] = H[i][k+1] - p * q;
					 }
					 for (int i = low;
					 i <= high;
					 i++) {
						 p = x * V[i][k] + y * V[i][k+1];
						 if (notlast) {
							p = p + z * V[i][k+2];
							V[i][k+2] = V[i][k+2] - p * r;
						 }
						 V[i][k] = V[i][k] - p;
						 V[i][k+1] = V[i][k+1] - p * q;
					 }
				 }
			 }
		 }
	 }
	 if (norm == 0.0) {
		 return;
	 }
	 for (n = nn-1;
	 n >= 0;
	 n--) {
		 p = d[n];
		 q = e[n];
		 if (q == 0) {
			int l = n;
			H[n][n] = 1.0;
			for (int i = n-1;
			 i >= 0;
			 i--) {
				 w = H[i][i] - p;
				 r = 0.0;
				 for (int j = l;
				 j <= n;
				 j++) {
					 r = r + H[i][j] * H[j][n];
				 }
				 if (e[i] < 0.0) {
					 z = w;
					 s = r;
				 }
				 else {
					 l = i;
					 if (e[i] == 0.0) {
						 if (w != 0.0) {
							H[i][n] = -r / w;
						 }
						 else {
							H[i][n] = -r / (eps * norm);
						 }
					 }
					 else {
						 x = H[i][i+1];
						 y = H[i+1][i];
						 q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
						 t = (x * s - z * r) / q;
						 H[i][n] = t;
						 if (Math.abs(x) > Math.abs(z)) {
							H[i+1][n] = (-r - w * t) / x;
						 }
						 else {
							H[i+1][n] = (-s - y * t) / z;
						 }
					 }
					 t = Math.abs(H[i][n]);
					 if ((eps * t) * t > 1) {
						 for (int j = i;
						 j <= n;
						 j++) {
							H[j][n] = H[j][n] / t;
						 }
					 }
				 }
			}
		 }
		 else if (q < 0) {
			int l = n-1;
			if (Math.abs(H[n][n-1]) > Math.abs(H[n-1][n])) {
				 H[n-1][n-1] = q / H[n][n-1];
				 H[n-1][n] = -(H[n][n] - p) / H[n][n-1];
			}
			 else {
				 cdiv(0.0,-H[n-1][n],H[n-1][n-1]-p,q);
				 H[n-1][n-1] = cdivr;
				 H[n-1][n] = cdivi;
			}
			H[n][n-1] = 0.0;
			H[n][n] = 1.0;
			for (int i = n-2;
			 i >= 0;
			 i--) {
				 double ra,sa,vr,vi;
				 ra = 0.0;
				 sa = 0.0;
				 for (int j = l;
				 j <= n;
				 j++) {
					 ra = ra + H[i][j] * H[j][n-1];
					 sa = sa + H[i][j] * H[j][n];
				 }
				 w = H[i][i] - p;
				 if (e[i] < 0.0) {
					 z = w;
					 r = ra;
					 s = sa;
				 }
				 else {
					 l = i;
					 if (e[i] == 0) {
						 cdiv(-ra,-sa,w,q);
						 H[i][n-1] = cdivr;
						 H[i][n] = cdivi;
					 }
					 else {
						 x = H[i][i+1];
						 y = H[i+1][i];
						 vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
						 vi = (d[i] - p) * 2.0 * q;
						 if (vr == 0.0 & vi == 0.0) {
							vr = eps * norm * (Math.abs(w) + Math.abs(q) +Math.abs(x) + Math.abs(y) + Math.abs(z));
						 }
						 cdiv(x*r-z*ra+q*sa,x*s-z*sa-q*ra,vr,vi);
						 H[i][n-1] = cdivr;
						 H[i][n] = cdivi;
						 if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
							H[i+1][n-1] = (-ra - w * H[i][n-1] + q * H[i][n]) / x;
							H[i+1][n] = (-sa - w * H[i][n] - q * H[i][n-1]) / x;
						 }
						 else {
							cdiv(-r-y*H[i][n-1],-s-y*H[i][n],z,q);
							H[i+1][n-1] = cdivr;
							H[i+1][n] = cdivi;
						 }
					 }
					 t = Math.max(Math.abs(H[i][n-1]),Math.abs(H[i][n]));
					 if ((eps * t) * t > 1) {
						 for (int j = i;
						 j <= n;
						 j++) {
							H[j][n-1] = H[j][n-1] / t;
							H[j][n] = H[j][n] / t;
						 }
					 }
				 }
			}
		 }
	 }
	 for (int i = 0;
	 i < nn;
	 i++) {
		 if (i < low | i > high) {
			for (int j = i;
			 j < nn;
			 j++) {
				 V[i][j] = H[i][j];
			}
		 }
	 }
	 for (int j = nn-1;
	 j >= low;
	 j--) {
		 for (int i = low;
		 i <= high;
		 i++) {
			z = 0.0;
			for (int k = low;
			 k <= Math.min(j,high);
			 k++) {
				 z = z + V[i][k] * H[k][j];
			}
			V[i][j] = z;
		 }
	 }
 }",0,0,1,0
"protected void createAndShowGUI() {
	 System.setProperty(""swing.defaultlaf"", UIManager.getSystemLookAndFeelClassName());
	 image = DavGatewayTray.loadImage(""tray.png"");
	 image2 = DavGatewayTray.loadImage(AwtGatewayTray.TRAY_ACTIVE_PNG);
	 inactiveImage = DavGatewayTray.loadImage(AwtGatewayTray.TRAY_INACTIVE_PNG);
	 mainFrame = new JFrame();
	 mainFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	 mainFrame.setTitle(BundleMessage.format(""UI_DAVMAIL_GATEWAY""));
	 mainFrame.setIconImage(image);
	 JPanel errorPanel = new JPanel();
	 errorPanel.setBorder(BorderFactory.createTitledBorder(BundleMessage.format(""UI_LAST_MESSAGE"")));
	 errorPanel.setLayout(new BoxLayout(errorPanel, BoxLayout.X_AXIS));
	 errorArea = new JTextPane();
	 errorArea.setEditable(false);
	 errorArea.setBackground(mainFrame.getBackground());
	 errorLabel = new JLabel();
	 errorPanel.add(errorLabel);
	 errorPanel.add(errorArea);
	 JPanel messagePanel = new JPanel();
	 messagePanel.setBorder(BorderFactory.createTitledBorder(BundleMessage.format(""UI_LAST_LOG"")));
	 messagePanel.setLayout(new BoxLayout(messagePanel, BoxLayout.X_AXIS));
	 messageArea = new JTextPane();
	 messageArea.setText(BundleMessage.format(""LOG_STARTING_DAVMAIL""));
	 messageArea.setEditable(false);
	 messageArea.setBackground(mainFrame.getBackground());
	 messagePanel.add(messageArea);
	 JPanel mainPanel = new JPanel();
	 mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
	 mainPanel.add(errorPanel);
	 mainPanel.add(messagePanel);
	 mainFrame.add(mainPanel);
	 aboutFrame = new AboutFrame();
	 settingsFrame = new SettingsFrame();
	 buildMenu();
	 mainFrame.setMinimumSize(new Dimension(400, 180));
	 mainFrame.pack();
	 if (mainFrame.getSize().width < 400 || mainFrame.getSize().height < 180) {
		 mainFrame.setSize(Math.max(mainFrame.getSize().width, 400), Math.max(mainFrame.getSize().height, 180));
	 }
	 mainFrame.setLocation(mainFrame.getToolkit().getScreenSize().width / 2 - mainFrame.getSize().width / 2, mainFrame.getToolkit().getScreenSize().height / 2 - mainFrame.getSize().height / 2);
	 mainFrame.setVisible(true);
	 if (Settings.isFirstStart()) {
		 settingsFrame.setVisible(true);
		 settingsFrame.toFront();
		 settingsFrame.repaint();
		 settingsFrame.requestFocus();
	 }
 }",0,0,1,0
"public class TestNewPlanOperatorPlan {
	 public static class FooLoad extends PigStorage {
		 public FooLoad(String[] params) {
		 }
	 }
	 private static class SillyPlan extends BaseOperatorPlan {
		 SillyPlan() {
			 super();
		 }
	 }
	 static public class DummyLoad extends PigStorage {
		 public DummyLoad(String a, String b) {
		 }
		 public DummyLoad(String a) {
		 }
	 }
	 private static class SillyOperator extends Operator {
		 private String name;
		 SillyOperator(String n, SillyPlan p) {
			 super(n, p);
			 name = n;
		 }
		 public void accept(PlanVisitor v) {
			 if (v instanceof SillyVisitor) {
				 ((SillyVisitor)v).visitSillyOperator(this);
			 }
		 }
		 public boolean isEqual(Operator operator) {
			 return (name.compareTo(operator.getName()) == 0);
		 }
	 }
	 private static class SillyVisitor extends PlanVisitor {
		 StringBuffer buf;
		 protected SillyVisitor(OperatorPlan plan, PlanWalker walker) {
			 super(plan, walker);
			 buf = new StringBuffer();
		 }
		 public void visitSillyOperator(SillyOperator so) {
			 buf.append(so.getName());
		 }
		 public String getVisitPattern() {
			 return buf.toString();
		 }
	 }
	 Configuration conf = null;
	 public void setUp() throws Exception {
		 PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
		 pc.connect();
		 conf = new Configuration( ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()) );
	 }
	 public void testPlanEdgeInsert() {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 PlanEdge edges = new PlanEdge();
		 edges.put(fred, joe, 0);
		 Collection<Operator> c = edges.get(fred);
		 assertEquals(1, c.size());
		 Operator[] a = new Operator[1];
		 Operator[] b = c.toArray(a);
		 assertEquals(joe, b[0]);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 edges.put(fred, bob);
		 c = edges.get(fred);
		 assertEquals(2, c.size());
		 a = new Operator[2];
		 b = c.toArray(a);
		 assertEquals(joe, b[0]);
		 assertEquals(bob, b[1]);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 edges.put(fred, jill, 1);
		 c = edges.get(fred);
		 assertEquals(3, c.size());
		 a = new Operator[3];
		 b = c.toArray(a);
		 assertEquals(joe, b[0]);
		 assertEquals(jill, b[1]);
		 assertEquals(bob, b[2]);
	 }
	 public void testPlanEdgeInsertFirstIndexBad() {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 PlanEdge edges = new PlanEdge();
		 boolean caught = false;
		 try {
			 edges.put(fred, joe, 1);
		 }
		 catch (IndexOutOfBoundsException e) {
			 caught = true;
		 }
		 assertTrue(caught);
		 caught = false;
		 edges.put(fred, joe);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 try {
			 edges.put(fred, bob, 2);
		 }
		 catch (IndexOutOfBoundsException e) {
			 caught = true;
		 }
		 assertTrue(caught);
	 }
	 public void testOperatorPlan() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jim = new SillyOperator(""jim"", plan);
		 SillyOperator sam = new SillyOperator(""sam"", plan);
		 List<Operator> list = plan.getSources();
		 assertEquals(0, list.size());
		 list = plan.getSinks();
		 assertEquals(0, list.size());
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jim);
		 plan.add(sam);
		 list = plan.getSources();
		 assertEquals(5, list.size());
		 list = plan.getSinks();
		 assertEquals(5, list.size());
		 plan.connect(fred, bob);
		 plan.connect(joe, bob);
		 plan.connect(bob, jim);
		 plan.connect(bob, sam);
		 list = plan.getSources();
		 assertEquals(2, list.size());
		 for (Operator op : list) {
			 assertTrue(fred.isEqual(op) || joe.isEqual(op));
		 }
		 list = plan.getSinks();
		 assertEquals(2, list.size());
		 for (Operator op : list) {
			 assertTrue(jim.isEqual(op) || sam.isEqual(op));
		 }
		 list = plan.getSuccessors(fred);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getSuccessors(joe);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getPredecessors(jim);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getPredecessors(sam);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getPredecessors(bob);
		 assertEquals(2, list.size());
		 assertEquals(fred, list.get(0));
		 assertEquals(joe, list.get(1));
		 list = plan.getSuccessors(bob);
		 assertEquals(2, list.size());
		 assertEquals(jim, list.get(0));
		 assertEquals(sam, list.get(1));
		 Pair<Integer, Integer> p1 = plan.disconnect(bob, jim);
		 Pair<Integer, Integer> p2 = plan.disconnect(fred, bob);
		 plan.connect(bob, p1.first, fred, p1.second);
		 plan.connect(jim, p2.first, bob, p2.second);
		 list = plan.getSources();
		 assertEquals(2, list.size());
		 for (Operator op : list) {
			 assertTrue(jim.isEqual(op) || joe.isEqual(op));
		 }
		 list = plan.getSinks();
		 assertEquals(2, list.size());
		 for (Operator op : list) {
			 assertTrue(fred.isEqual(op) || sam.isEqual(op));
		 }
		 list = plan.getSuccessors(jim);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getSuccessors(joe);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getPredecessors(fred);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getPredecessors(sam);
		 assertEquals(1, list.size());
		 assertEquals(bob, list.get(0));
		 list = plan.getPredecessors(bob);
		 assertEquals(2, list.size());
		 assertEquals(jim, list.get(0));
		 assertEquals(joe, list.get(1));
		 list = plan.getSuccessors(bob);
		 assertEquals(2, list.size());
		 assertEquals(fred, list.get(0));
		 assertEquals(sam, list.get(1));
	 }
	 public void testDisconnectAndRemove() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.connect(fred, joe);
		 plan.remove(bob);
		 plan.disconnect(fred, joe);
		 List<Operator> list = plan.getSources();
		 assertEquals(2, list.size());
		 list = plan.getSinks();
		 assertEquals(2, list.size());
		 plan.remove(fred);
		 plan.remove(joe);
		 assertEquals(0, plan.size());
		 list = plan.getSources();
		 assertEquals(0, list.size());
		 list = plan.getSinks();
		 assertEquals(0, list.size());
	 }
	 public void testRemoveNegative() {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.connect(fred, joe);
		 boolean caught = false;
		 try {
			 plan.remove(fred);
		 }
		 catch (FrontendException e) {
			 caught = true;
		 }
		 assertTrue(caught);
		 caught = false;
		 try {
			 plan.remove(joe);
		 }
		 catch (FrontendException e) {
			 caught = true;
		 }
		 assertTrue(caught);
	 }
	 public void testDisconnectNegative() {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 boolean caught = false;
		 try {
			 plan.disconnect(fred, joe);
		 }
		 catch (FrontendException e) {
			 caught = true;
		 }
		 assertTrue(caught);
	 }
	 public void testDependencyOrderWalkerLinear() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.connect(fred, joe);
		 plan.connect(joe, bob);
		 SillyVisitor v = new SillyVisitor(plan, new DependencyOrderWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 assertEquals(""fredjoebob"", s);
	 }
	 public void testDependencyOrderWalkerTree() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 SillyOperator jane = new SillyOperator(""jane"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jill);
		 plan.add(jane);
		 plan.connect(fred, bob);
		 plan.connect(joe, bob);
		 plan.connect(bob, jill);
		 plan.connect(jane, jill);
		 SillyVisitor v = new SillyVisitor(plan, new DependencyOrderWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 if (!s.equals(""fredjoebobjanejill"") && !s.equals(""joefredbobjanejill"") && !s.equals(""janefredjoebobjill"") && !s.equals(""janejoefredbobjill"")) {
			 System.out.println(""Invalid order "" + s);
			 fail();
		 }
	 }
	 public void testDependencyOrderWalkerGraph() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 SillyOperator jane = new SillyOperator(""jane"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jill);
		 plan.add(jane);
		 plan.connect(fred, bob);
		 plan.connect(joe, bob);
		 plan.connect(bob, jill);
		 plan.connect(bob, jane);
		 SillyVisitor v = new SillyVisitor(plan, new DependencyOrderWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 if (!s.equals(""fredjoebobjanejill"") && !s.equals(""joefredbobjanejill"") && !s.equals(""fredjoebobjilljane"") && !s.equals(""joefredbobjilljane"")) {
			 System.out.println(""Invalid order "" + s);
			 fail();
		 }
	 }
	 public void testDepthFirstWalkerLinear() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.connect(fred, joe);
		 plan.connect(joe, bob);
		 SillyVisitor v = new SillyVisitor(plan, new DepthFirstWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 assertEquals(""fredjoebob"", s);
	 }
	 public void testDepthFirstWalkerTree() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 SillyOperator jane = new SillyOperator(""jane"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jill);
		 plan.add(jane);
		 plan.connect(fred, bob);
		 plan.connect(fred, joe);
		 plan.connect(joe, jill);
		 plan.connect(joe, jane);
		 SillyVisitor v = new SillyVisitor(plan, new DepthFirstWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 assertEquals(""fredbobjoejilljane"", s);
	 }
	 public void testDepthFirstWalkerGraph() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 SillyOperator jane = new SillyOperator(""jane"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jill);
		 plan.add(jane);
		 plan.connect(fred, bob);
		 plan.connect(joe, bob);
		 plan.connect(bob, jill);
		 plan.connect(bob, jane);
		 SillyVisitor v = new SillyVisitor(plan, new DepthFirstWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 if (!s.equals(""fredbobjilljanejoe"") && !s.equals(""joebobjilljanefred"")) {
			 System.out.println(""Invalid order "" + s);
			 fail();
		 }
	 }
	 public void testReverseDependencyOrderWalkerLinear() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.connect(fred, joe);
		 plan.connect(joe, bob);
		 SillyVisitor v = new SillyVisitor(plan, new ReverseDependencyOrderWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 assertEquals(""bobjoefred"", s);
	 }
	 public void testReverseDependencyOrderWalkerTree() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 SillyOperator jane = new SillyOperator(""jane"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jill);
		 plan.add(jane);
		 plan.connect(fred, bob);
		 plan.connect(joe, bob);
		 plan.connect(bob, jill);
		 plan.connect(jane, jill);
		 SillyVisitor v = new SillyVisitor(plan, new ReverseDependencyOrderWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 if (!s.equals(""jilljanebobjoefred"") && !s.equals(""jilljanebobfredjoe"") && !s.equals(""jillbobjoefredjane"") && !s.equals(""jillbobjoejanefred"") && !s.equals(""jillbobfredjoejane"") && !s.equals(""jillbobfredjanejoe"") && !s.equals(""jillbobjanejoefred"") && !s.equals(""jillbobjanefredjoe"")) {
			 System.out.println(""Invalid order "" + s);
			 fail();
		 }
	 }
	 public void testReverseDependencyOrderWalkerGraph() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 SillyOperator fred = new SillyOperator(""fred"", plan);
		 SillyOperator joe = new SillyOperator(""joe"", plan);
		 SillyOperator bob = new SillyOperator(""bob"", plan);
		 SillyOperator jill = new SillyOperator(""jill"", plan);
		 SillyOperator jane = new SillyOperator(""jane"", plan);
		 plan.add(fred);
		 plan.add(joe);
		 plan.add(bob);
		 plan.add(jill);
		 plan.add(jane);
		 plan.connect(fred, bob);
		 plan.connect(joe, bob);
		 plan.connect(bob, jill);
		 plan.connect(bob, jane);
		 SillyVisitor v = new SillyVisitor(plan, new ReverseDependencyOrderWalker(plan));
		 v.visit();
		 String s = v.getVisitPattern();
		 if (!s.equals(""jilljanebobjoefred"") && !s.equals(""jilljanebobfredjoe"") && !s.equals(""janejillbobjoefred"") && !s.equals(""janejillbobfredjoe"")) {
			 System.out.println(""Invalid order "" + s);
			 fail();
		 }
	 }
	 private static class TestLogicalVisitor extends LogicalRelationalNodesVisitor {
		 StringBuffer bf = new StringBuffer();
		 protected TestLogicalVisitor(OperatorPlan plan) throws FrontendException {
			 super(plan, new DepthFirstWalker(plan));
		 }
		 public void visit(LOLoad load) {
			 bf.append(""load "");
		 }
		 String getVisitPlan() {
			 return bf.toString();
		 }
	 }
	 public void testLogicalPlanVisitor() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LOLoad load = newLOLoad(null, null, lp, conf);
		 lp.add(load);
		 TestLogicalVisitor v = new TestLogicalVisitor(lp);
		 v.visit();
		 assertEquals(""load "", v.getVisitPlan());
	 }
	 public void testBinaryOperatorOrder() throws FrontendException {
		 LogicalExpressionPlan ep = new LogicalExpressionPlan();
		 ConstantExpression c = new ConstantExpression(ep, new Integer(5));
		 ProjectExpression p = new ProjectExpression(ep, 0, 0, null);
		 EqualExpression e = new EqualExpression(ep, p, c);
		 assertEquals(p, e.getLhs());
		 assertEquals(c, e.getRhs());
	 }
	 private static class TestExpressionVisitor extends LogicalExpressionVisitor {
		 StringBuffer bf = new StringBuffer();
		 protected TestExpressionVisitor(OperatorPlan plan) throws FrontendException {
			 super(plan, new DepthFirstWalker(plan));
		 }
		 public void visit(AndExpression andExpr) {
			 bf.append(""and "");
		 }
		 public void visit(EqualExpression equal) {
			 bf.append(""equal "");
		 }
		 public void visit(ProjectExpression project) {
			 bf.append(""project "");
		 }
		 public void visit(ConstantExpression constant) {
			 bf.append(""constant "");
		 }
		 String getVisitPlan() {
			 return bf.toString();
		 }
	 }
	 public void testExpressionPlanVisitor() throws FrontendException {
		 LogicalExpressionPlan ep = new LogicalExpressionPlan();
		 ConstantExpression c = new ConstantExpression(ep, new Integer(5));
		 ProjectExpression p = new ProjectExpression(ep, 0, 0, null);
		 EqualExpression e = new EqualExpression(ep, p, c);
		 ConstantExpression c2 = new ConstantExpression(ep, new Boolean(""true""));
		 new AndExpression(ep, e, c2);
		 TestExpressionVisitor v = new TestExpressionVisitor(ep);
		 v.visit();
		 assertEquals(""and equal project constant constant "", v.getVisitPlan());
	 }
	 public void testExpressionEquality() throws FrontendException {
		 LogicalExpressionPlan ep1 = new LogicalExpressionPlan();
		 ConstantExpression c1 = new ConstantExpression(ep1, new Integer(5));
		 ProjectExpression p1 = new ProjectExpression(ep1, 0, 0, null);
		 EqualExpression e1 = new EqualExpression(ep1, p1, c1);
		 ConstantExpression ca1 = new ConstantExpression(ep1, new Boolean(""true""));
		 AndExpression a1 = new AndExpression(ep1, e1, ca1);
		 LogicalExpressionPlan ep2 = new LogicalExpressionPlan();
		 ConstantExpression c2 = new ConstantExpression(ep2, new Integer(5));
		 ProjectExpression p2 = new ProjectExpression(ep2, 0, 0, null);
		 EqualExpression e2 = new EqualExpression(ep2, p2, c2);
		 ConstantExpression ca2 = new ConstantExpression(ep2, new Boolean(""true""));
		 AndExpression a2 = new AndExpression(ep2, e2, ca2);
		 assertTrue(ep1.isEqual(ep2));
		 assertTrue(c1.isEqual(c2));
		 assertTrue(p1.isEqual(p2));
		 assertTrue(e1.isEqual(e2));
		 assertTrue(ca1.isEqual(ca2));
		 assertTrue(a1.isEqual(a2));
		 LogicalExpressionPlan ep3 = new LogicalExpressionPlan();
		 ConstantExpression c3 = new ConstantExpression(ep3, new Integer(3));
		 ProjectExpression p3 = new ProjectExpression(ep3, 0, 1, null);
		 EqualExpression e3 = new EqualExpression(ep3, p3, c3);
		 ConstantExpression ca3 = new ConstantExpression(ep3, ""true"");
		 AndExpression a3 = new AndExpression(ep3, e3, ca3);
		 assertFalse(ep1.isEqual(ep3));
		 assertFalse(c1.isEqual(c3));
		 assertFalse(p1.isEqual(p3));
		 assertFalse(e1.isEqual(e3));
		 assertFalse(ca1.isEqual(ca3));
		 assertFalse(a1.isEqual(a3));
		 LogicalExpressionPlan ep4 = new LogicalExpressionPlan();
		 ProjectExpression p4 = new ProjectExpression(ep4, 1, 0, null);
		 assertFalse(ep1.isEqual(ep4));
		 assertFalse(p1.isEqual(p4));
	 }
	 public void testRelationalEquality() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 {
			 LogicalSchema aschema = new LogicalSchema();
			 aschema.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
			 LOLoad A = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
			 ""x"", ""y"" }
			)), aschema, lp, conf);
			 lp.add(A);
			 LogicalSchema bschema = new LogicalSchema();
			 bschema.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
			 LOLoad B = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), bschema, lp, conf);
			 lp.add(B);
			 LogicalSchema cschema = new LogicalSchema();
			 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
			 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
			 LogicalExpressionPlan aprojplan = new LogicalExpressionPlan();
			 new ProjectExpression(aprojplan, 0, 0, null);
			 LogicalExpressionPlan bprojplan = new LogicalExpressionPlan();
			 new ProjectExpression(bprojplan, 1, 0, null);
			 MultiMap<Integer, LogicalExpressionPlan> mm = new MultiMap<Integer, LogicalExpressionPlan>();
			 mm.put(0, aprojplan);
			 mm.put(1, bprojplan);
			 LOJoin C = new LOJoin(lp, mm, JOINTYPE.HASH, new boolean[] {
			 true, true }
			);
			 C.neverUseForRealSetSchema(cschema);
			 lp.add(C);
			 lp.connect(A, C);
			 lp.connect(B, C);
			 LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
			 ProjectExpression fy = new ProjectExpression(filterPlan, 0, 1, null);
			 ConstantExpression fc = new ConstantExpression(filterPlan, new Integer(0));
			 new EqualExpression(filterPlan, fy, fc);
			 LOFilter D = new LOFilter(lp, filterPlan);
			 D.neverUseForRealSetSchema(cschema);
			 lp.add(D);
			 lp.connect(C, D);
		 }
		 LogicalPlan lp1 = new LogicalPlan();
		 {
			 LogicalSchema aschema = new LogicalSchema();
			 aschema.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
			 LOLoad A = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
			 ""x"", ""y"" }
			)), aschema, lp1, conf);
			 lp1.add(A);
			 LogicalSchema bschema = new LogicalSchema();
			 bschema.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
			 LOLoad B = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), bschema, lp1, conf);
			 lp1.add(B);
			 LogicalSchema cschema = new LogicalSchema();
			 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
			 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
			 LogicalExpressionPlan aprojplan = new LogicalExpressionPlan();
			 new ProjectExpression(aprojplan, 0, 0, null);
			 LogicalExpressionPlan bprojplan = new LogicalExpressionPlan();
			 new ProjectExpression(bprojplan, 1, 0, null);
			 MultiMap<Integer, LogicalExpressionPlan> mm = new MultiMap<Integer, LogicalExpressionPlan>();
			 mm.put(0, aprojplan);
			 mm.put(1, bprojplan);
			 LOJoin C = new LOJoin(lp1, mm, JOINTYPE.HASH, new boolean[] {
			 true, true }
			);
			 C.neverUseForRealSetSchema(cschema);
			 lp1.add(C);
			 lp1.connect(A, C);
			 lp1.connect(B, C);
			 LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
			 ProjectExpression fy = new ProjectExpression(filterPlan, 0, 1, null);
			 ConstantExpression fc = new ConstantExpression(filterPlan, new Integer(0));
			 new EqualExpression(filterPlan, fy, fc);
			 LOFilter D = new LOFilter(lp1, filterPlan);
			 D.neverUseForRealSetSchema(cschema);
			 lp1.add(D);
			 lp1.connect(C, D);
		 }
		 assertTrue(lp.isEqual(lp1));
	 }
	 public void testLoadEqualityDifferentFuncSpecCtorArgs() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad load1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp, conf);
		 lp.add(load1);
		 LOLoad load2 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""z"" }
		)), aschema1, lp, conf);
		 lp.add(load2);
		 assertFalse(load1.isEqual(load2));
	 }
	 public void testLoadEqualityDifferentNumFuncSpecCstorArgs() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad load1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp, conf);
		 lp.add(load1);
		 LOLoad load3 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), ""x"")), aschema1, lp, conf);
		 lp.add(load3);
		 assertFalse(load1.isEqual(load3));
	 }
	 public void testLoadEqualityDifferentFunctionNames() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad load1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp, conf);
		 lp.add(load1);
		 LOLoad load4 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""z"" }
		)), aschema1, lp, conf);
		 lp.add(load4);
		 assertFalse(load1.isEqual(load4));
	 }
	 public void testLoadEqualityDifferentFileName() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad load1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp, conf);
		 lp.add(load1);
		 LOLoad load5 = newLOLoad(new FileSpec(""/def"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""z"" }
		)), aschema1, lp, conf);
		 lp.add(load5);
		 assertFalse(load1.isEqual(load5));
	 }
	 public void testRelationalEqualityDifferentSchema() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad load1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp, conf);
		 lp.add(load1);
		 LogicalSchema aschema2 = new LogicalSchema();
		 aschema2.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.CHARARRAY));
		 LOLoad load6 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""z"" }
		)), aschema2, lp, conf);
		 lp.add(load6);
		 assertFalse(load1.isEqual(load6));
	 }
	 public void testRelationalEqualityNullSchemas() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LOLoad load7 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), null, lp, conf);
		 lp.add(load7);
		 LOLoad load8 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), null, lp, conf);
		 lp.add(load8);
		 assertTrue(load7.isEqual(load8));
	 }
	 public void testRelationalEqualityOneNullOneNotNullSchema() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad load1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp, conf);
		 lp.add(load1);
		 LOLoad load9 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""z"" }
		)), null, lp, conf);
		 lp.add(load9);
		 assertFalse(load1.isEqual(load9));
	 }
	 public void testFilterDifferentPredicates() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalExpressionPlan fp1 = new LogicalExpressionPlan();
		 ProjectExpression fy1 = new ProjectExpression(fp1, 0, 1, null);
		 ConstantExpression fc1 = new ConstantExpression(fp1, new Integer(0));
		 new EqualExpression(fp1, fy1, fc1);
		 LOFilter D1 = new LOFilter(lp, fp1);
		 LogicalSchema cschema = new LogicalSchema();
		 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 D1.neverUseForRealSetSchema(cschema);
		 lp.add(D1);
		 LogicalExpressionPlan fp2 = new LogicalExpressionPlan();
		 ProjectExpression fy2 = new ProjectExpression(fp2, 0, 1, null);
		 ConstantExpression fc2 = new ConstantExpression(fp2, new Integer(1));
		 new EqualExpression(fp2, fy2, fc2);
		 LOFilter D2 = new LOFilter(lp, fp2);
		 D2.neverUseForRealSetSchema(cschema);
		 lp.add(D2);
		 assertFalse(D1.isEqual(D2));
	 }
	 public void testJoinDifferentJoinTypes() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema jaschema1 = new LogicalSchema();
		 jaschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema1, lp, conf);
		 lp.add(A1);
		 LogicalSchema jbschema1 = new LogicalSchema();
		 jbschema1.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad B1 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema1, lp, conf);
		 lp.add(B1);
		 LogicalSchema jcschema1 = new LogicalSchema();
		 jcschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema1.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan1 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan1, 0, 0, null);
		 LogicalExpressionPlan bprojplan1 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan1, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm1 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm1.put(0, aprojplan1);
		 mm1.put(1, bprojplan1);
		 LOJoin C1 = new LOJoin(lp, mm1, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C1.neverUseForRealSetSchema(jcschema1);
		 lp.add(C1);
		 lp.connect(A1, C1);
		 lp.connect(B1, C1);
		 LogicalSchema jaschema2 = new LogicalSchema();
		 jaschema2.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A2 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema2, lp, conf);
		 lp.add(A2);
		 LogicalSchema jbschema2 = new LogicalSchema();
		 jbschema2.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad B2 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema2, lp, conf);
		 lp.add(B2);
		 LogicalSchema jcschema2 = new LogicalSchema();
		 jcschema2.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema2.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan2 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan2, 0, 0, null);
		 LogicalExpressionPlan bprojplan2 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan2, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm2 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm2.put(0, aprojplan2);
		 mm2.put(1, bprojplan2);
		 LOJoin C2 = new LOJoin(lp, mm2, JOINTYPE.SKEWED, new boolean[] {
		 true, true }
		);
		 C2.neverUseForRealSetSchema(jcschema2);
		 lp.add(C2);
		 lp.connect(A2, C2);
		 lp.connect(B2, C2);
		 assertFalse(C1.isEqual(C2));
	 }
	 public void testJoinDifferentInner() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema jaschema1 = new LogicalSchema();
		 jaschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema1, lp, conf);
		 lp.add(A1);
		 LogicalSchema jbschema1 = new LogicalSchema();
		 jbschema1.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad B1 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema1, lp, conf);
		 lp.add(B1);
		 LogicalSchema jcschema1 = new LogicalSchema();
		 jcschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema1.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan1 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan1, 0, 0, null);
		 LogicalExpressionPlan bprojplan1 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan1, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm1 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm1.put(0, aprojplan1);
		 mm1.put(1, bprojplan1);
		 LOJoin C1 = new LOJoin(lp, mm1, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C1.neverUseForRealSetSchema(jcschema1);
		 lp.add(C1);
		 lp.connect(A1, C1);
		 lp.connect(B1, C1);
		 LogicalSchema jaschema3 = new LogicalSchema();
		 jaschema3.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A3 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema3, lp, conf);
		 lp.add(A3);
		 LogicalSchema jbschema3 = new LogicalSchema();
		 jbschema3.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad B3 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema3, lp, conf);
		 lp.add(B3);
		 LogicalSchema jcschema3 = new LogicalSchema();
		 jcschema3.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema3.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan3 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan3, 0, 0, null);
		 LogicalExpressionPlan bprojplan3 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan3, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm3 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm3.put(0, aprojplan3);
		 mm3.put(1, bprojplan3);
		 LOJoin C3 = new LOJoin(lp, mm3, JOINTYPE.HASH, new boolean[] {
		 true, false }
		);
		 C3.neverUseForRealSetSchema(jcschema3);
		 lp.add(C3);
		 lp.connect(A3, C3);
		 lp.connect(B3, C3);
		 assertFalse(C1.isEqual(C3));
	 }
	 public void testJoinDifferentNumInputs() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema jaschema1 = new LogicalSchema();
		 jaschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema1, lp, conf);
		 lp.add(A1);
		 LogicalSchema jbschema1 = new LogicalSchema();
		 jbschema1.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad B1 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema1, lp, conf);
		 lp.add(B1);
		 LogicalSchema jcschema1 = new LogicalSchema();
		 jcschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema1.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan1 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan1, 0, 0, null);
		 LogicalExpressionPlan bprojplan1 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan1, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm1 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm1.put(0, aprojplan1);
		 mm1.put(1, bprojplan1);
		 LOJoin C1 = new LOJoin(lp, mm1, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C1.neverUseForRealSetSchema(jcschema1);
		 lp.add(C1);
		 lp.connect(A1, C1);
		 lp.connect(B1, C1);
		 LogicalSchema jaschema5 = new LogicalSchema();
		 jaschema5.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A5 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema5, lp, conf);
		 lp.add(A5);
		 LogicalSchema jbschema5 = new LogicalSchema();
		 jbschema5.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad B5 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema5, lp, conf);
		 lp.add(B5);
		 LogicalSchema jbetaschema5 = new LogicalSchema();
		 jbetaschema5.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LOLoad Beta5 = newLOLoad(new FileSpec(""/ghi"", new FuncSpec(""PigStorage"", ""\t"")), jbetaschema5, lp, conf);
		 lp.add(Beta5);
		 LogicalSchema jcschema5 = new LogicalSchema();
		 jcschema5.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema5.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan5 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan5, 0, 0, null);
		 LogicalExpressionPlan bprojplan5 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan5, 1, 0, null);
		 LogicalExpressionPlan betaprojplan5 = new LogicalExpressionPlan();
		 new ProjectExpression(betaprojplan5, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm5 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm5.put(0, aprojplan5);
		 mm5.put(1, bprojplan5);
		 mm5.put(2, betaprojplan5);
		 LOJoin C5 = new LOJoin(lp, mm5, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C5.neverUseForRealSetSchema(jcschema5);
		 lp.add(C5);
		 lp.connect(A5, C5);
		 lp.connect(B5, C5);
		 lp.connect(Beta5, C5);
		 assertFalse(C1.isEqual(C5));
	 }
	 public void testJoinDifferentJoinKeys() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema jaschema6 = new LogicalSchema();
		 jaschema6.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A6 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema6, lp, conf);
		 lp.add(A6);
		 LogicalSchema jbschema6 = new LogicalSchema();
		 jbschema6.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 jbschema6.addField(new LogicalSchema.LogicalFieldSchema( ""z"", null, DataType.LONG));
		 LOLoad B6 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema6, lp, conf);
		 lp.add(B6);
		 LogicalSchema jcschema6 = new LogicalSchema();
		 jcschema6.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema6.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan6 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan6, 0, 0, null);
		 LogicalExpressionPlan bprojplan6 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan6, 1, 0, null);
		 LogicalExpressionPlan b2projplan6 = new LogicalExpressionPlan();
		 new ProjectExpression(b2projplan6, 1, 1, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm6 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm6.put(0, aprojplan6);
		 mm6.put(1, bprojplan6);
		 mm6.put(1, b2projplan6);
		 LOJoin C6 = new LOJoin(lp, mm6, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C6.neverUseForRealSetSchema(jcschema6);
		 lp.add(C6);
		 lp.connect(A6, C6);
		 lp.connect(B6, C6);
		 LogicalSchema jaschema7 = new LogicalSchema();
		 jaschema7.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A7 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema7, lp, conf);
		 lp.add(A7);
		 LogicalSchema jbschema7 = new LogicalSchema();
		 jbschema7.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 jbschema7.addField(new LogicalSchema.LogicalFieldSchema( ""z"", null, DataType.LONG));
		 LOLoad B7 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema7, lp, conf);
		 lp.add(B7);
		 LogicalSchema jcschema7 = new LogicalSchema();
		 jcschema7.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema7.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan7 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan7, 0, 0, null);
		 LogicalExpressionPlan bprojplan7 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan7, 1, 1, null);
		 LogicalExpressionPlan b2projplan7 = new LogicalExpressionPlan();
		 new ProjectExpression(b2projplan7, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm7 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm7.put(0, aprojplan7);
		 mm7.put(1, bprojplan7);
		 mm7.put(1, b2projplan7);
		 LOJoin C7 = new LOJoin(lp, mm7, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C7.neverUseForRealSetSchema(jcschema7);
		 lp.add(C7);
		 lp.connect(A7, C7);
		 lp.connect(B7, C7);
		 assertFalse(C6.isEqual(C7));
	 }
	 public void testJoinDifferentNumJoinKeys() throws FrontendException {
		 LogicalPlan lp = new LogicalPlan();
		 LogicalSchema jaschema6 = new LogicalSchema();
		 jaschema6.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A6 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema6, lp, conf);
		 lp.add(A6);
		 LogicalSchema jbschema6 = new LogicalSchema();
		 jbschema6.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 jbschema6.addField(new LogicalSchema.LogicalFieldSchema( ""z"", null, DataType.LONG));
		 LOLoad B6 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema6, lp, conf);
		 lp.add(B6);
		 LogicalSchema jcschema6 = new LogicalSchema();
		 jcschema6.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema6.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan6 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan6, 0, 0, null);
		 LogicalExpressionPlan bprojplan6 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan6, 1, 0, null);
		 LogicalExpressionPlan b2projplan6 = new LogicalExpressionPlan();
		 new ProjectExpression(b2projplan6, 1, 1, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm6 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm6.put(0, aprojplan6);
		 mm6.put(1, bprojplan6);
		 mm6.put(1, b2projplan6);
		 LOJoin C6 = new LOJoin(lp, mm6, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C6.neverUseForRealSetSchema(jcschema6);
		 lp.add(C6);
		 lp.connect(A6, C6);
		 lp.connect(B6, C6);
		 LogicalSchema jaschema8 = new LogicalSchema();
		 jaschema8.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A8 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(""org.apache.pig.test.TestNewPlanOperatorPlan$FooLoad"", new String[] {
		 ""x"", ""y"" }
		)), jaschema8, lp, conf);
		 lp.add(A8);
		 LogicalSchema jbschema8 = new LogicalSchema();
		 jbschema8.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 jbschema8.addField(new LogicalSchema.LogicalFieldSchema( ""z"", null, DataType.LONG));
		 LOLoad B8 = newLOLoad(new FileSpec(""/def"", new FuncSpec(""PigStorage"", ""\t"")), jbschema8, lp, conf);
		 lp.add(B8);
		 LogicalSchema jcschema8 = new LogicalSchema();
		 jcschema8.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 jcschema8.addField(new LogicalSchema.LogicalFieldSchema( ""y"", null, DataType.INTEGER));
		 LogicalExpressionPlan aprojplan8 = new LogicalExpressionPlan();
		 new ProjectExpression(aprojplan8, 0, 0, null);
		 LogicalExpressionPlan bprojplan8 = new LogicalExpressionPlan();
		 new ProjectExpression(bprojplan8, 1, 0, null);
		 MultiMap<Integer, LogicalExpressionPlan> mm8 = new MultiMap<Integer, LogicalExpressionPlan>();
		 mm8.put(0, aprojplan8);
		 mm8.put(1, bprojplan8);
		 LOJoin C8 = new LOJoin(lp, mm8, JOINTYPE.HASH, new boolean[] {
		 true, true }
		);
		 C8.neverUseForRealSetSchema(jcschema8);
		 lp.add(C8);
		 lp.connect(A8, C8);
		 lp.connect(B8, C8);
		 assertFalse(C6.isEqual(C8));
	 }
	 public void testRelationalSameOpDifferentPreds() throws FrontendException {
		 LogicalPlan lp1 = new LogicalPlan();
		 LogicalSchema aschema1 = new LogicalSchema();
		 aschema1.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 LOLoad A1 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""y"" }
		)), aschema1, lp1, conf);
		 lp1.add(A1);
		 LogicalExpressionPlan fp1 = new LogicalExpressionPlan();
		 ProjectExpression fy1 = new ProjectExpression(fp1, 0, 0, null);
		 ConstantExpression fc1 = new ConstantExpression(fp1, new Integer(0));
		 new EqualExpression(fp1, fy1, fc1);
		 LOFilter D1 = new LOFilter(lp1, fp1);
		 LogicalSchema cschema = new LogicalSchema();
		 cschema.addField(new LogicalSchema.LogicalFieldSchema( ""x"", null, DataType.INTEGER));
		 D1.neverUseForRealSetSchema(cschema);
		 lp1.add(D1);
		 lp1.connect(A1, D1);
		 LogicalPlan lp2 = new LogicalPlan();
		 LOLoad A2 = newLOLoad(new FileSpec(""/abc"", new FuncSpec(DummyLoad.class.getName(), new String[] {
		 ""x"", ""z"" }
		)), null, lp2, conf);
		 lp2.add(A2);
		 LogicalExpressionPlan fp2 = new LogicalExpressionPlan();
		 ProjectExpression fy2 = new ProjectExpression(fp2, 0, 0, null);
		 ConstantExpression fc2 = new ConstantExpression(fp2, new Integer(0));
		 new EqualExpression(fp2, fy2, fc2);
		 LOFilter D2 = new LOFilter(lp2, fp2);
		 D2.neverUseForRealSetSchema(cschema);
		 lp2.add(D2);
		 lp2.connect(A2, D2);
		 assertTrue(D1.isEqual(D2));
	 }
	 public void testReplace1() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator join1 = new SillyOperator(""join1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.add(join1);
		 plan.connect(load1, join1);
		 plan.connect(load2, filter1);
		 plan.connect(filter1, join1);
		 plan.connect(join1, filter2);
		 Operator join2 = new SillyOperator(""join2"", plan);
		 plan.replace(join1, join2);
		 List<Operator> preds = plan.getPredecessors(join2);
		 assertEquals(2, preds.size());
		 assertTrue(preds.contains(load1));
		 assertTrue(preds.contains(filter1));
		 List<Operator> succs = plan.getSuccessors(join2);
		 assertEquals(1, succs.size());
		 assertTrue(succs.contains(filter2));
	 }
	 public void testReplace2() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator split1 = new SillyOperator(""split1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(split1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, split1);
		 plan.connect(split1, filter1);
		 plan.connect(split1, filter2);
		 Operator split2 = new SillyOperator(""split2"", plan);
		 plan.replace(split1, split2);
		 List<Operator> preds = plan.getPredecessors(split2);
		 assertEquals(1, preds.size());
		 assertTrue(preds.contains(load1));
		 List<Operator> succs = plan.getSuccessors(split2);
		 assertEquals(2, succs.size());
		 assertTrue(succs.contains(filter1));
		 assertTrue(succs.contains(filter2));
	 }
	 public void testReplace3() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, filter1);
		 plan.connect(filter1, filter2);
		 Operator filter3 = new SillyOperator(""filter3"", plan);
		 plan.replace(filter1, filter3);
		 List<Operator> preds = plan.getPredecessors(filter3);
		 assertEquals(1, preds.size());
		 assertTrue(preds.contains(load1));
		 List<Operator> succs = plan.getSuccessors(filter3);
		 assertEquals(1, succs.size());
		 assertTrue(succs.contains(filter2));
	 }
	 public void testReplace4() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, filter1);
		 plan.connect(filter1, filter2);
		 Operator filter3 = new SillyOperator(""filter3"", plan);
		 plan.replace(filter2, filter3);
		 List<Operator> preds = plan.getPredecessors(filter3);
		 assertEquals(1, preds.size());
		 assertTrue(preds.contains(filter1));
		 List<Operator> succs = plan.getSuccessors(filter3);
		 assertNull(succs);
	 }
	 public void testReplace5() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, filter1);
		 plan.connect(filter1, filter2);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 plan.replace(load1, load2);
		 List<Operator> preds = plan.getPredecessors(load2);
		 assertNull(preds);
		 List<Operator> succs = plan.getSuccessors(load2);
		 assertEquals(1, succs.size());
		 assertTrue(succs.contains(filter1));
	 }
	 public void testReplace6() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator fake1 = new SillyOperator(""fake1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 Operator filter3 = new SillyOperator(""filter3"", plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.add(filter3);
		 plan.add(fake1);
		 plan.connect(load1, fake1);
		 plan.connect(load2, filter1);
		 plan.connect(filter1, fake1);
		 plan.connect(fake1, filter2);
		 plan.connect(fake1, filter3);
		 Operator fake2 = new SillyOperator(""fake2"", plan);
		 plan.replace(fake1, fake2);
		 List<Operator> preds = plan.getPredecessors(fake2);
		 assertEquals(2, preds.size());
		 assertTrue(preds.contains(load1));
		 assertTrue(preds.contains(filter1));
		 List<Operator> succs = plan.getSuccessors(fake2);
		 assertEquals(2, succs.size());
		 assertTrue(succs.contains(filter2));
		 assertTrue(succs.contains(filter3));
	 }
	 public void testRemove1() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator join1 = new SillyOperator(""join1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.add(join1);
		 plan.connect(load1, join1);
		 plan.connect(load2, filter1);
		 plan.connect(filter1, join1);
		 plan.connect(join1, filter2);
		 plan.removeAndReconnect(filter1);
		 List<Operator> preds = plan.getPredecessors(join1);
		 assertEquals(2, preds.size());
		 assertTrue(preds.contains(load2));
	 }
	 public void testRemove2() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator join1 = new SillyOperator(""join1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.add(join1);
		 plan.connect(load1, join1);
		 plan.connect(load2, filter1);
		 plan.connect(filter1, join1);
		 plan.connect(join1, filter2);
		 plan.removeAndReconnect(load1);
		 List<Operator> preds = plan.getPredecessors(join1);
		 assertEquals(1, preds.size());
		 assertTrue(preds.contains(filter1));
		 plan.removeAndReconnect(filter1);
		 preds = plan.getPredecessors(join1);
		 assertEquals(1, preds.size());
		 assertTrue(preds.contains(load2));
	 }
	 public void testRemove3() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, filter1);
		 plan.connect(filter1, filter2);
		 plan.removeAndReconnect(filter2);
		 List<Operator> succs = plan.getSuccessors(filter2);
		 assertNull(succs);
	 }
	 public void testRemove4() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator join1 = new SillyOperator(""join1"", plan);
		 Operator fake1 = new SillyOperator(""fake1"", plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(filter1);
		 plan.add(join1);
		 plan.connect(load1, join1);
		 plan.connect(load2, filter1);
		 plan.connect(filter1, join1);
		 plan.connect(join1, fake1);
		 plan.removeAndReconnect(join1);
		 List<Operator> preds = plan.getPredecessors(fake1);
		 assertEquals(2, preds.size());
		 assertTrue(preds.contains(load1));
		 assertTrue(preds.contains(filter1));
	 }
	 public void testRemove5() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator split1 = new SillyOperator(""split1"", plan);
		 Operator split2 = new SillyOperator(""split2"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(split1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, split1);
		 plan.connect(split1, split2);
		 plan.connect(split2, filter1);
		 plan.connect(split2, filter2);
		 plan.removeAndReconnect(split2);
		 List<Operator> succs = plan.getSuccessors(split1);
		 assertEquals(2, succs.size());
		 assertTrue(succs.contains(filter1));
		 assertTrue(succs.contains(filter2));
	 }
	 public void testRemove6() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator load2 = new SillyOperator(""load2"", plan);
		 Operator fake1 = new SillyOperator(""fake1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.add(load1);
		 plan.add(load2);
		 plan.add(fake1);
		 plan.add(filter1);
		 plan.add(filter2);
		 plan.connect(load1, fake1);
		 plan.connect(load2, fake1);
		 plan.connect(fake1, filter1);
		 plan.connect(fake1, filter2);
		 try {
			 plan.removeAndReconnect(fake1);
		 }
		 catch (FrontendException e) {
			 assertEquals(2256, e.getErrorCode());
			 throw e;
		 }
	 }
	 public void testInsertBetween1() throws FrontendException {
		 SillyPlan plan = new SillyPlan();
		 Operator load1 = new SillyOperator(""load1"", plan);
		 Operator filter1 = new SillyOperator(""filter1"", plan);
		 plan.add(load1);
		 plan.add(filter1);
		 plan.connect(load1, filter1);
		 Operator filter2 = new SillyOperator(""filter2"", plan);
		 plan.insertBetween(load1, filter2, filter1);
		 List<Operator> succs = plan.getSuccessors(filter2);
		 assertEquals(1, succs.size());
		 assertTrue(succs.contains(filter1));
		 List<Operator> preds = plan.getPredecessors(filter2);
		 assertEquals(1, preds.size());
		 assertTrue(preds.contains(load1));
	 }
}",1,0,0,0
"public final class JarLibManifestTask extends Task {
	 private static final String MANIFEST_VERSION = ""1.0"";
	 private static final String CREATED_BY = ""Created-By"";
	 private File destFile;
	 private Extension extension;
	 private final ArrayList dependencies = new ArrayList();
	 private final ArrayList optionals = new ArrayList();
	 private final ArrayList extraAttributes = new ArrayList();
	 public void setDestfile(final File destFile) {
		 this.destFile = destFile;
	 }
	 public void addConfiguredExtension(final ExtensionAdapter extensionAdapter) throws BuildException {
		 if (null != extension) {
			 final String message = ""Can not have multiple extensions defined in one library."";
			 throw new BuildException(message);
		 }
		 extension = extensionAdapter.toExtension();
	 }
	 public void addConfiguredDepends(final ExtensionSet extensionSet) {
		 dependencies.add(extensionSet);
	 }
	 public void addConfiguredOptions(final ExtensionSet extensionSet) {
		 optionals.add(extensionSet);
	 }
	 public void addConfiguredAttribute(final ExtraAttribute attribute) {
		 extraAttributes.add(attribute);
	 }
	 public void execute() throws BuildException {
		 validate();
		 final Manifest manifest = new Manifest();
		 final Attributes attributes = manifest.getMainAttributes();
		 attributes.put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION);
		 final String createdBy = ""Apache Ant "" + getProject().getProperty(MagicNames.ANT_VERSION);
		 attributes.putValue(CREATED_BY, createdBy);
		 appendExtraAttributes(attributes);
		 if (null != extension) {
			 Extension.addExtension(extension, attributes);
		 }
		 final ArrayList depends = toExtensions(dependencies);
		 appendExtensionList(attributes, Extension.EXTENSION_LIST, ""lib"", depends.size());
		 appendLibraryList(attributes, ""lib"", depends);
		 final ArrayList option = toExtensions(optionals);
		 appendExtensionList(attributes, Extension.OPTIONAL_EXTENSION_LIST, ""opt"", option.size());
		 appendLibraryList(attributes, ""opt"", option);
		 try {
			 final String message = ""Generating manifest "" + destFile.getAbsoluteFile();
			 log(message, Project.MSG_INFO);
			 writeManifest(manifest);
		 }
		 catch (final IOException ioe) {
			 throw new BuildException(ioe.getMessage(), ioe);
		 }
	 }
	 private void validate() throws BuildException {
		 if (null == destFile) {
			 final String message = ""Destfile attribute not specified."";
			 throw new BuildException(message);
		 }
		 if (destFile.exists() && !destFile.isFile()) {
			 final String message = destFile + "" is not a file."";
			 throw new BuildException(message);
		 }
	 }
	 private void appendExtraAttributes(final Attributes attributes) {
		 final Iterator iterator = extraAttributes.iterator();
		 while (iterator.hasNext()) {
			 final ExtraAttribute attribute = (ExtraAttribute) iterator.next();
			 attributes.putValue(attribute.getName(), attribute.getValue());
		 }
	 }
	 private void writeManifest(final Manifest manifest) throws IOException {
		 FileOutputStream output = null;
		 try {
			 output = new FileOutputStream(destFile);
			 manifest.write(output);
			 output.flush();
		 }
		 finally {
			 if (null != output) {
				 try {
					 output.close();
				 }
				 catch (IOException e) {
				 }
			 }
		 }
	 }
	 private void appendLibraryList(final Attributes attributes, final String listPrefix, final ArrayList extensions) throws BuildException {
		 final int size = extensions.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 final Extension ext = (Extension) extensions.get(i);
			 final String prefix = listPrefix + i + ""-"";
			 Extension.addExtension(ext, prefix, attributes);
		 }
	 }
	 private void appendExtensionList(final Attributes attributes, final Attributes.Name extensionKey, final String listPrefix, final int size) {
		 final StringBuffer sb = new StringBuffer();
		 for (int i = 0;
		 i < size;
		 i++) {
			 sb.append(listPrefix);
			 sb.append(i);
			 sb.append(' ');
		 }
		 attributes.put(extensionKey, sb.toString());
	 }
	 private ArrayList toExtensions(final ArrayList extensionSets) throws BuildException {
		 final ArrayList results = new ArrayList();
		 final int size = extensionSets.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 final ExtensionSet set = (ExtensionSet) extensionSets.get(i);
			 final Extension[] extensions = set.toExtensions(getProject());
			 for (int j = 0;
			 j < extensions.length;
			 j++) {
				 results.add(extensions[ j ]);
			 }
		 }
		 return results;
	 }
}",0,0,0,0
"class TokenStream{
	 private final static int EOF_CHAR = -1;
	 TokenStream(Parser parser, Reader sourceReader, String sourceString, int lineno) {
		 this.parser = parser;
		 this.lineno = lineno;
		 if (sourceReader != null) {
			 if (sourceString != null) Kit.codeBug();
			 this.sourceReader = sourceReader;
			 this.sourceBuffer = new char[512];
			 this.sourceEnd = 0;
		 }
		 else {
			 if (sourceString == null) Kit.codeBug();
			 this.sourceString = sourceString;
			 this.sourceEnd = sourceString.length();
		 }
		 this.sourceCursor = 0;
	 }
	 String tokenToString(int token) {
		 if (Token.printTrees) {
			 String name = Token.name(token);
			 switch (token) {
				 case Token.STRING: case Token.REGEXP: case Token.NAME: return name + "" `"" + this.string + ""'"";
				 case Token.NUMBER: return ""NUMBER "" + this.number;
			 }
			 return name;
		 }
		 return """";
	 }
	 static boolean isKeyword(String s) {
		 return Token.EOF != stringToKeyword(s);
	 }
	 private static int stringToKeyword(String name) {
		 final int Id_break = Token.BREAK, Id_case = Token.CASE, Id_continue = Token.CONTINUE, Id_default = Token.DEFAULT, Id_delete = Token.DELPROP, Id_do = Token.DO, Id_else = Token.ELSE, Id_export = Token.EXPORT, Id_false = Token.FALSE, Id_for = Token.FOR, Id_function = Token.FUNCTION, Id_if = Token.IF, Id_in = Token.IN, Id_new = Token.NEW, Id_null = Token.NULL, Id_return = Token.RETURN, Id_switch = Token.SWITCH, Id_this = Token.THIS, Id_true = Token.TRUE, Id_typeof = Token.TYPEOF, Id_var = Token.VAR, Id_void = Token.VOID, Id_while = Token.WHILE, Id_with = Token.WITH, Id_abstract = Token.RESERVED, Id_boolean = Token.RESERVED, Id_byte = Token.RESERVED, Id_catch = Token.CATCH, Id_char = Token.RESERVED, Id_class = Token.RESERVED, Id_const = Token.RESERVED, Id_debugger = Token.RESERVED, Id_double = Token.RESERVED, Id_enum = Token.RESERVED, Id_extends = Token.RESERVED, Id_final = Token.RESERVED, Id_finally = Token.FINALLY, Id_float = Token.RESERVED, Id_goto = Token.RESERVED, Id_implements = Token.RESERVED, Id_import = Token.IMPORT, Id_instanceof = Token.INSTANCEOF, Id_int = Token.RESERVED, Id_interface = Token.RESERVED, Id_long = Token.RESERVED, Id_native = Token.RESERVED, Id_package = Token.RESERVED, Id_private = Token.RESERVED, Id_protected = Token.RESERVED, Id_public = Token.RESERVED, Id_short = Token.RESERVED, Id_static = Token.RESERVED, Id_super = Token.RESERVED, Id_synchronized = Token.RESERVED, Id_throw = Token.THROW, Id_throws = Token.RESERVED, Id_transient = Token.RESERVED, Id_try = Token.TRY, Id_volatile = Token.RESERVED;
		 int id;
		 String s = name;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 2: c=s.charAt(1);
				 if (c=='f') {
					 if (s.charAt(0)=='i') {
						id=Id_if;
						 break L0;
					}
				 }
				 else if (c=='n') {
					 if (s.charAt(0)=='i') {
						id=Id_in;
						 break L0;
					}
				 }
				 else if (c=='o') {
					 if (s.charAt(0)=='d') {
						id=Id_do;
						 break L0;
					}
				 }
				 break L;
				 case 3: switch (s.charAt(0)) {
					 case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {
						id=Id_for;
						 break L0;
					}
					 break L;
					 case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {
						id=Id_int;
						 break L0;
					}
					 break L;
					 case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {
						id=Id_new;
						 break L0;
					}
					 break L;
					 case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {
						id=Id_try;
						 break L0;
					}
					 break L;
					 case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {
						id=Id_var;
						 break L0;
					}
					 break L;
				 }
				 break L;
				 case 4: switch (s.charAt(0)) {
					 case 'b': X=""byte"";
					id=Id_byte;
					 break L;
					 case 'c': c=s.charAt(3);
					 if (c=='e') {
						 if (s.charAt(2)=='s' && s.charAt(1)=='a') {
							id=Id_case;
							 break L0;
						}
					 }
					 else if (c=='r') {
						 if (s.charAt(2)=='a' && s.charAt(1)=='h') {
							id=Id_char;
							 break L0;
						}
					 }
					 break L;
					 case 'e': c=s.charAt(3);
					 if (c=='e') {
						 if (s.charAt(2)=='s' && s.charAt(1)=='l') {
							id=Id_else;
							 break L0;
						}
					 }
					 else if (c=='m') {
						 if (s.charAt(2)=='u' && s.charAt(1)=='n') {
							id=Id_enum;
							 break L0;
						}
					 }
					 break L;
					 case 'g': X=""goto"";
					id=Id_goto;
					 break L;
					 case 'l': X=""long"";
					id=Id_long;
					 break L;
					 case 'n': X=""null"";
					id=Id_null;
					 break L;
					 case 't': c=s.charAt(3);
					 if (c=='e') {
						 if (s.charAt(2)=='u' && s.charAt(1)=='r') {
							id=Id_true;
							 break L0;
						}
					 }
					 else if (c=='s') {
						 if (s.charAt(2)=='i' && s.charAt(1)=='h') {
							id=Id_this;
							 break L0;
						}
					 }
					 break L;
					 case 'v': X=""void"";
					id=Id_void;
					 break L;
					 case 'w': X=""with"";
					id=Id_with;
					 break L;
				 }
				 break L;
				 case 5: switch (s.charAt(2)) {
					 case 'a': X=""class"";
					id=Id_class;
					 break L;
					 case 'e': X=""break"";
					id=Id_break;
					 break L;
					 case 'i': X=""while"";
					id=Id_while;
					 break L;
					 case 'l': X=""false"";
					id=Id_false;
					 break L;
					 case 'n': c=s.charAt(0);
					 if (c=='c') {
						 X=""const"";
						id=Id_const;
					 }
					 else if (c=='f') {
						 X=""final"";
						id=Id_final;
					 }
					 break L;
					 case 'o': c=s.charAt(0);
					 if (c=='f') {
						 X=""float"";
						id=Id_float;
					 }
					 else if (c=='s') {
						 X=""short"";
						id=Id_short;
					 }
					 break L;
					 case 'p': X=""super"";
					id=Id_super;
					 break L;
					 case 'r': X=""throw"";
					id=Id_throw;
					 break L;
					 case 't': X=""catch"";
					id=Id_catch;
					 break L;
				 }
				 break L;
				 case 6: switch (s.charAt(1)) {
					 case 'a': X=""native"";
					id=Id_native;
					 break L;
					 case 'e': c=s.charAt(0);
					 if (c=='d') {
						 X=""delete"";
						id=Id_delete;
					 }
					 else if (c=='r') {
						 X=""return"";
						id=Id_return;
					 }
					 break L;
					 case 'h': X=""throws"";
					id=Id_throws;
					 break L;
					 case 'm': X=""import"";
					id=Id_import;
					 break L;
					 case 'o': X=""double"";
					id=Id_double;
					 break L;
					 case 't': X=""static"";
					id=Id_static;
					 break L;
					 case 'u': X=""public"";
					id=Id_public;
					 break L;
					 case 'w': X=""switch"";
					id=Id_switch;
					 break L;
					 case 'x': X=""export"";
					id=Id_export;
					 break L;
					 case 'y': X=""typeof"";
					id=Id_typeof;
					 break L;
				 }
				 break L;
				 case 7: switch (s.charAt(1)) {
					 case 'a': X=""package"";
					id=Id_package;
					 break L;
					 case 'e': X=""default"";
					id=Id_default;
					 break L;
					 case 'i': X=""finally"";
					id=Id_finally;
					 break L;
					 case 'o': X=""boolean"";
					id=Id_boolean;
					 break L;
					 case 'r': X=""private"";
					id=Id_private;
					 break L;
					 case 'x': X=""extends"";
					id=Id_extends;
					 break L;
				 }
				 break L;
				 case 8: switch (s.charAt(0)) {
					 case 'a': X=""abstract"";
					id=Id_abstract;
					 break L;
					 case 'c': X=""continue"";
					id=Id_continue;
					 break L;
					 case 'd': X=""debugger"";
					id=Id_debugger;
					 break L;
					 case 'f': X=""function"";
					id=Id_function;
					 break L;
					 case 'v': X=""volatile"";
					id=Id_volatile;
					 break L;
				 }
				 break L;
				 case 9: c=s.charAt(0);
				 if (c=='i') {
					 X=""interface"";
					id=Id_interface;
				 }
				 else if (c=='p') {
					 X=""protected"";
					id=Id_protected;
				 }
				 else if (c=='t') {
					 X=""transient"";
					id=Id_transient;
				 }
				 break L;
				 case 10: c=s.charAt(1);
				 if (c=='m') {
					 X=""implements"";
					id=Id_implements;
				 }
				 else if (c=='n') {
					 X=""instanceof"";
					id=Id_instanceof;
				 }
				 break L;
				 case 12: X=""synchronized"";
				id=Id_synchronized;
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 if (id == 0) {
			 return Token.EOF;
		 }
		 return id & 0xff;
	 }
	 final int getLineno() {
		 return lineno;
	 }
	 final String getString() {
		 return string;
	 }
	 final double getNumber() {
		 return number;
	 }
	 final boolean eof() {
		 return hitEOF;
	 }
	 final int getToken() throws IOException {
		 int c;
		 retry: for (;
		;
		) {
			 for (;
			;
			) {
				 c = getChar();
				 if (c == EOF_CHAR) {
					 return Token.EOF;
				 }
				 else if (c == '\n') {
					 dirtyLine = false;
					 return Token.EOL;
				 }
				 else if (!isJSSpace(c)) {
					 if (c != '-') {
						 dirtyLine = true;
					 }
					 break;
				 }
			 }
			 if (c == '@') return Token.XMLATTR;
			 boolean identifierStart;
			 boolean isUnicodeEscapeStart = false;
			 if (c == '\\') {
				 c = getChar();
				 if (c == 'u') {
					 identifierStart = true;
					 isUnicodeEscapeStart = true;
					 stringBufferTop = 0;
				 }
				 else {
					 identifierStart = false;
					 ungetChar(c);
					 c = '\\';
				 }
			 }
			 else {
				 identifierStart = Character.isJavaIdentifierStart((char)c);
				 if (identifierStart) {
					 stringBufferTop = 0;
					 addToString(c);
				 }
			 }
			 if (identifierStart) {
				 boolean containsEscape = isUnicodeEscapeStart;
				 for (;
				;
				) {
					 if (isUnicodeEscapeStart) {
						 int escapeVal = 0;
						 for (int i = 0;
						 i != 4;
						 ++i) {
							 c = getChar();
							 escapeVal = Kit.xDigitToInt(c, escapeVal);
							 if (escapeVal < 0) {
								 break;
							 }
						 }
						 if (escapeVal < 0) {
							 parser.addError(""msg.invalid.escape"");
							 return Token.ERROR;
						 }
						 addToString(escapeVal);
						 isUnicodeEscapeStart = false;
					 }
					 else {
						 c = getChar();
						 if (c == '\\') {
							 c = getChar();
							 if (c == 'u') {
								 isUnicodeEscapeStart = true;
								 containsEscape = true;
							 }
							 else {
								 parser.addError(""msg.illegal.character"");
								 return Token.ERROR;
							 }
						 }
						 else {
							 if (c == EOF_CHAR || !Character.isJavaIdentifierPart((char)c)) {
								 break;
							 }
							 addToString(c);
						 }
					 }
				 }
				 ungetChar(c);
				 String str = getStringFromBuffer();
				 if (!containsEscape) {
					 int result = stringToKeyword(str);
					 if (result != Token.EOF) {
						 if (result != Token.RESERVED) {
							 return result;
						 }
						 else if (!parser.compilerEnv. isReservedKeywordAsIdentifier()) {
							 return result;
						 }
						 else {
							 parser.addWarning(""msg.reserved.keyword"", str);
						 }
					 }
				 }
				 this.string = (String)allStrings.intern(str);
				 return Token.NAME;
			 }
			 if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {
				 stringBufferTop = 0;
				 int base = 10;
				 if (c == '0') {
					 c = getChar();
					 if (c == 'x' || c == 'X') {
						 base = 16;
						 c = getChar();
					 }
					 else if (isDigit(c)) {
						 base = 8;
					 }
					 else {
						 addToString('0');
					 }
				 }
				 if (base == 16) {
					 while (0 <= Kit.xDigitToInt(c, 0)) {
						 addToString(c);
						 c = getChar();
					 }
				 }
				 else {
					 while ('0' <= c && c <= '9') {
						 if (base == 8 && c >= '8') {
							 parser.addWarning(""msg.bad.octal.literal"", c == '8' ? ""8"" : ""9"");
							 base = 10;
						 }
						 addToString(c);
						 c = getChar();
					 }
				 }
				 boolean isInteger = true;
				 if (base == 10 && (c == '.' || c == 'e' || c == 'E')) {
					 isInteger = false;
					 if (c == '.') {
						 do {
							 addToString(c);
							 c = getChar();
						 }
						 while (isDigit(c));
					 }
					 if (c == 'e' || c == 'E') {
						 addToString(c);
						 c = getChar();
						 if (c == '+' || c == '-') {
							 addToString(c);
							 c = getChar();
						 }
						 if (!isDigit(c)) {
							 parser.addError(""msg.missing.exponent"");
							 return Token.ERROR;
						 }
						 do {
							 addToString(c);
							 c = getChar();
						 }
						 while (isDigit(c));
					 }
				 }
				 ungetChar(c);
				 String numString = getStringFromBuffer();
				 double dval;
				 if (base == 10 && !isInteger) {
					 try {
						 dval = Double.valueOf(numString).doubleValue();
					 }
					 catch (NumberFormatException ex) {
						 parser.addError(""msg.caught.nfe"");
						 return Token.ERROR;
					 }
				 }
				 else {
					 dval = ScriptRuntime.stringToNumber(numString, 0, base);
				 }
				 this.number = dval;
				 return Token.NUMBER;
			 }
			 if (c == '""' || c == '\'') {
				 int quoteChar = c;
				 stringBufferTop = 0;
				 c = getChar();
				 strLoop: while (c != quoteChar) {
					 if (c == '\n' || c == EOF_CHAR) {
						 ungetChar(c);
						 parser.addError(""msg.unterminated.string.lit"");
						 return Token.ERROR;
					 }
					 if (c == '\\') {
						 int escapeVal;
						 c = getChar();
						 switch (c) {
							 case 'b': c = '\b';
							 break;
							 case 'f': c = '\f';
							 break;
							 case 'n': c = '\n';
							 break;
							 case 'r': c = '\r';
							 break;
							 case 't': c = '\t';
							 break;
							 case 'v': c = 0xb;
							 break;
							 case 'u': int escapeStart = stringBufferTop;
							 addToString('u');
							 escapeVal = 0;
							 for (int i = 0;
							 i != 4;
							 ++i) {
								 c = getChar();
								 escapeVal = Kit.xDigitToInt(c, escapeVal);
								 if (escapeVal < 0) {
									 continue strLoop;
								 }
								 addToString(c);
							 }
							 stringBufferTop = escapeStart;
							 c = escapeVal;
							 break;
							 case 'x': c = getChar();
							 escapeVal = Kit.xDigitToInt(c, 0);
							 if (escapeVal < 0) {
								 addToString('x');
								 continue strLoop;
							 }
							 else {
								 int c1 = c;
								 c = getChar();
								 escapeVal = Kit.xDigitToInt(c, escapeVal);
								 if (escapeVal < 0) {
									 addToString('x');
									 addToString(c1);
									 continue strLoop;
								 }
								 else {
									 c = escapeVal;
								 }
							 }
							 break;
							 default: if ('0' <= c && c < '8') {
								 int val = c - '0';
								 c = getChar();
								 if ('0' <= c && c < '8') {
									 val = 8 * val + c - '0';
									 c = getChar();
									 if ('0' <= c && c < '8' && val <= 037) {
										 val = 8 * val + c - '0';
										 c = getChar();
									 }
								 }
								 ungetChar(c);
								 c = val;
							 }
						 }
					 }
					 addToString(c);
					 c = getChar();
				 }
				 String str = getStringFromBuffer();
				 this.string = (String)allStrings.intern(str);
				 return Token.STRING;
			 }
			 switch (c) {
				 case ';
				': return Token.SEMI;
				 case '[': return Token.LB;
				 case ']': return Token.RB;
				 case '{
					': return Token.LC;
				 case '}
				': return Token.RC;
				 case '(': return Token.LP;
				 case ')': return Token.RP;
				 case ',': return Token.COMMA;
				 case '?': return Token.HOOK;
				 case ':': if (matchChar(':')) {
					 return Token.COLONCOLON;
				 }
				 else {
					 return Token.COLON;
				 }
				 case '.': if (matchChar('.')) {
					 return Token.DOTDOT;
				 }
				 else if (matchChar('(')) {
					 return Token.DOTQUERY;
				 }
				 else {
					 return Token.DOT;
				 }
				 case '|': if (matchChar('|')) {
					 return Token.OR;
				 }
				 else if (matchChar('=')) {
					 return Token.ASSIGN_BITOR;
				 }
				 else {
					 return Token.BITOR;
				 }
				 case '^': if (matchChar('=')) {
					 return Token.ASSIGN_BITXOR;
				 }
				 else {
					 return Token.BITXOR;
				 }
				 case '&': if (matchChar('&')) {
					 return Token.AND;
				 }
				 else if (matchChar('=')) {
					 return Token.ASSIGN_BITAND;
				 }
				 else {
					 return Token.BITAND;
				 }
				 case '=': if (matchChar('=')) {
					 if (matchChar('=')) return Token.SHEQ;
					 else return Token.EQ;
				 }
				 else {
					 return Token.ASSIGN;
				 }
				 case '!': if (matchChar('=')) {
					 if (matchChar('=')) return Token.SHNE;
					 else return Token.NE;
				 }
				 else {
					 return Token.NOT;
				 }
				 case '<': if (matchChar('!')) {
					 if (matchChar('-')) {
						 if (matchChar('-')) {
							 skipLine();
							 continue retry;
						 }
						 ungetChar('-');
					 }
					 ungetChar('!');
				 }
				 if (matchChar('<')) {
					 if (matchChar('=')) {
						 return Token.ASSIGN_LSH;
					 }
					 else {
						 return Token.LSH;
					 }
				 }
				 else {
					 if (matchChar('=')) {
						 return Token.LE;
					 }
					 else {
						 return Token.LT;
					 }
				 }
				 case '>': if (matchChar('>')) {
					 if (matchChar('>')) {
						 if (matchChar('=')) {
							 return Token.ASSIGN_URSH;
						 }
						 else {
							 return Token.URSH;
						 }
					 }
					 else {
						 if (matchChar('=')) {
							 return Token.ASSIGN_RSH;
						 }
						 else {
							 return Token.RSH;
						 }
					 }
				 }
				 else {
					 if (matchChar('=')) {
						 return Token.GE;
					 }
					 else {
						 return Token.GT;
					 }
				 }
				 case '*': if (matchChar('=')) {
					 return Token.ASSIGN_MUL;
				 }
				 else {
					 return Token.MUL;
				 }
				 case '/': if (matchChar('/')) {
					 skipLine();
					 continue retry;
				 }
				 if (matchChar('*')) {
					 boolean lookForSlash = false;
					 for (;
					;
					) {
						 c = getChar();
						 if (c == EOF_CHAR) {
							 parser.addError(""msg.unterminated.comment"");
							 return Token.ERROR;
						 }
						 else if (c == '*') {
							 lookForSlash = true;
						 }
						 else if (c == '/') {
							 if (lookForSlash) {
								 continue retry;
							 }
						 }
						 else {
							 lookForSlash = false;
						 }
					 }
				 }
				 if (matchChar('=')) {
					 return Token.ASSIGN_DIV;
				 }
				 else {
					 return Token.DIV;
				 }
				 case '%': if (matchChar('=')) {
					 return Token.ASSIGN_MOD;
				 }
				 else {
					 return Token.MOD;
				 }
				 case '~': return Token.BITNOT;
				 case '+': if (matchChar('=')) {
					 return Token.ASSIGN_ADD;
				 }
				 else if (matchChar('+')) {
					 return Token.INC;
				 }
				 else {
					 return Token.ADD;
				 }
				 case '-': if (matchChar('=')) {
					 c = Token.ASSIGN_SUB;
				 }
				 else if (matchChar('-')) {
					 if (!dirtyLine) {
						 if (matchChar('>')) {
							 skipLine();
							 continue retry;
						 }
					 }
					 c = Token.DEC;
				 }
				 else {
					 c = Token.SUB;
				 }
				 dirtyLine = true;
				 return c;
				 default: parser.addError(""msg.illegal.character"");
				 return Token.ERROR;
			 }
		 }
	 }
	 private static boolean isAlpha(int c) {
		 if (c <= 'Z') {
			 return 'A' <= c;
		 }
		 else {
			 return 'a' <= c && c <= 'z';
		 }
	 }
	 static boolean isDigit(int c) {
		 return '0' <= c && c <= '9';
	 }
	 static boolean isJSSpace(int c) {
		 if (c <= 127) {
			 return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;
		 }
		 else {
			 return c == 0xA0 || Character.getType((char)c) == Character.SPACE_SEPARATOR;
		 }
	 }
	 private static boolean isJSFormatChar(int c) {
		 return c > 127 && Character.getType((char)c) == Character.FORMAT;
	 }
	 void readRegExp(int startToken) throws IOException {
		 stringBufferTop = 0;
		 if (startToken == Token.ASSIGN_DIV) {
			 addToString('=');
		 }
		 else {
			 if (startToken != Token.DIV) Kit.codeBug();
		 }
		 int c;
		 while ((c = getChar()) != '/') {
			 if (c == '\n' || c == EOF_CHAR) {
				 ungetChar(c);
				 throw parser.reportError(""msg.unterminated.re.lit"");
			 }
			 if (c == '\\') {
				 addToString(c);
				 c = getChar();
			 }
			 addToString(c);
		 }
		 int reEnd = stringBufferTop;
		 while (true) {
			 if (matchChar('g')) addToString('g');
			 else if (matchChar('i')) addToString('i');
			 else if (matchChar('m')) addToString('m');
			 else break;
		 }
		 if (isAlpha(peekChar())) {
			 throw parser.reportError(""msg.invalid.re.flag"");
		 }
		 this.string = new String(stringBuffer, 0, reEnd);
		 this.regExpFlags = new String(stringBuffer, reEnd, stringBufferTop - reEnd);
	 }
	 boolean isXMLAttribute() {
		 return xmlIsAttribute;
	 }
	 int getFirstXMLToken() throws IOException {
		 xmlOpenTagsCount = 0;
		 xmlIsAttribute = false;
		 xmlIsTagContent = false;
		 ungetChar('<');
		 return getNextXMLToken();
	 }
	 int getNextXMLToken() throws IOException {
		 stringBufferTop = 0;
		 for (int c = getChar();
		 c != EOF_CHAR;
		 c = getChar()) {
			 if (xmlIsTagContent) {
				 switch (c) {
					 case '>': addToString(c);
					 xmlIsTagContent = false;
					 xmlIsAttribute = false;
					 break;
					 case '/': addToString(c);
					 if (peekChar() == '>') {
						 c = getChar();
						 addToString(c);
						 xmlIsTagContent = false;
						 xmlOpenTagsCount--;
					 }
					 break;
					 case '{
						': ungetChar(c);
						 this.string = getStringFromBuffer();
						 return Token.XML;
						 case '\'': case '""': addToString(c);
						 if (!readQuotedString(c)) return Token.ERROR;
						 break;
						 case '=': addToString(c);
						 xmlIsAttribute = true;
						 break;
						 case ' ': case '\t': case '\r': case '\n': addToString(c);
						 break;
						 default: addToString(c);
						 xmlIsAttribute = false;
						 break;
					 }
					 if (!xmlIsTagContent && xmlOpenTagsCount == 0) {
						 this.string = getStringFromBuffer();
						 return Token.XMLEND;
					 }
				 }
				 else {
					 switch (c) {
						 case '<': addToString(c);
						 c = peekChar();
						 switch (c) {
							 case '!': c = getChar();
							 addToString(c);
							 c = peekChar();
							 switch (c) {
								 case '-': c = getChar();
								 addToString(c);
								 c = getChar();
								 if (c == '-') {
									 addToString(c);
									 if(!readXmlComment()) return Token.ERROR;
								 }
								 else {
									 stringBufferTop = 0;
									 this.string = null;
									 parser.addError(""msg.XML.bad.form"");
									 return Token.ERROR;
								 }
								 break;
								 case '[': c = getChar();
								 addToString(c);
								 if (getChar() == 'C' && getChar() == 'D' && getChar() == 'A' && getChar() == 'T' && getChar() == 'A' && getChar() == '[') {
									 addToString('C');
									 addToString('D');
									 addToString('A');
									 addToString('T');
									 addToString('A');
									 addToString('[');
									 if (!readCDATA()) return Token.ERROR;
								 }
								 else {
									 stringBufferTop = 0;
									 this.string = null;
									 parser.addError(""msg.XML.bad.form"");
									 return Token.ERROR;
								 }
								 break;
								 default: if(!readEntity()) return Token.ERROR;
								 break;
							 }
							 break;
							 case '?': c = getChar();
							 addToString(c);
							 if (!readPI()) return Token.ERROR;
							 break;
							 case '/': c = getChar();
							 addToString(c);
							 if (xmlOpenTagsCount == 0) {
								 stringBufferTop = 0;
								 this.string = null;
								 parser.addError(""msg.XML.bad.form"");
								 return Token.ERROR;
							 }
							 xmlIsTagContent = true;
							 xmlOpenTagsCount--;
							 break;
							 default: xmlIsTagContent = true;
							 xmlOpenTagsCount++;
							 break;
						 }
						 break;
						 case '{
							': ungetChar(c);
							 this.string = getStringFromBuffer();
							 return Token.XML;
							 default: addToString(c);
							 break;
						 }
					 }
				 }
				 stringBufferTop = 0;
				 this.string = null;
				 parser.addError(""msg.XML.bad.form"");
				 return Token.ERROR;
			 }
			 private boolean readQuotedString(int quote) throws IOException {
				 for (int c = getChar();
				 c != EOF_CHAR;
				 c = getChar()) {
					 addToString(c);
					 if (c == quote) return true;
				 }
				 stringBufferTop = 0;
				 this.string = null;
				 parser.addError(""msg.XML.bad.form"");
				 return false;
			 }
			 private boolean readXmlComment() throws IOException {
				 for (int c = getChar();
				 c != EOF_CHAR;
				) {
					 addToString(c);
					 if (c == '-' && peekChar() == '-') {
						 c = getChar();
						 addToString(c);
						 if (peekChar() == '>') {
							 c = getChar();
							 addToString(c);
							 return true;
						 }
						 else {
							 continue;
						 }
					 }
					 c = getChar();
				 }
				 stringBufferTop = 0;
				 this.string = null;
				 parser.addError(""msg.XML.bad.form"");
				 return false;
			 }
			 private boolean readCDATA() throws IOException {
				 for (int c = getChar();
				 c != EOF_CHAR;
				) {
					 addToString(c);
					 if (c == ']' && peekChar() == ']') {
						 c = getChar();
						 addToString(c);
						 if (peekChar() == '>') {
							 c = getChar();
							 addToString(c);
							 return true;
						 }
						 else {
							 continue;
						 }
					 }
					 c = getChar();
				 }
				 stringBufferTop = 0;
				 this.string = null;
				 parser.addError(""msg.XML.bad.form"");
				 return false;
			 }
			 private boolean readEntity() throws IOException {
				 int declTags = 1;
				 for (int c = getChar();
				 c != EOF_CHAR;
				 c = getChar()) {
					 addToString(c);
					 switch (c) {
						 case '<': declTags++;
						 break;
						 case '>': declTags--;
						 if (declTags == 0) return true;
						 break;
					 }
				 }
				 stringBufferTop = 0;
				 this.string = null;
				 parser.addError(""msg.XML.bad.form"");
				 return false;
			 }
			 private boolean readPI() throws IOException {
				 for (int c = getChar();
				 c != EOF_CHAR;
				 c = getChar()) {
					 addToString(c);
					 if (c == '?' && peekChar() == '>') {
						 c = getChar();
						 addToString(c);
						 return true;
					 }
				 }
				 stringBufferTop = 0;
				 this.string = null;
				 parser.addError(""msg.XML.bad.form"");
				 return false;
			 }
			 private String getStringFromBuffer() {
				 return new String(stringBuffer, 0, stringBufferTop);
			 }
			 private void addToString(int c) {
				 int N = stringBufferTop;
				 if (N == stringBuffer.length) {
					 char[] tmp = new char[stringBuffer.length * 2];
					 System.arraycopy(stringBuffer, 0, tmp, 0, N);
					 stringBuffer = tmp;
				 }
				 stringBuffer[N] = (char)c;
				 stringBufferTop = N + 1;
			 }
			 private void ungetChar(int c) {
				 if (ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\n') Kit.codeBug();
				 ungetBuffer[ungetCursor++] = c;
			 }
			 private boolean matchChar(int test) throws IOException {
				 int c = getChar();
				 if (c == test) {
					 return true;
				 }
				 else {
					 ungetChar(c);
					 return false;
				 }
			 }
			 private int peekChar() throws IOException {
				 int c = getChar();
				 ungetChar(c);
				 return c;
			 }
			 private int getChar() throws IOException {
				 if (ungetCursor != 0) {
					 return ungetBuffer[--ungetCursor];
				 }
				 for(;
				;
				) {
					 int c;
					 if (sourceString != null) {
						 if (sourceCursor == sourceEnd) {
							 hitEOF = true;
							 return EOF_CHAR;
						 }
						 c = sourceString.charAt(sourceCursor++);
					 }
					 else {
						 if (sourceCursor == sourceEnd) {
							 if (!fillSourceBuffer()) {
								 hitEOF = true;
								 return EOF_CHAR;
							 }
						 }
						 c = sourceBuffer[sourceCursor++];
					 }
					 if (lineEndChar >= 0) {
						 if (lineEndChar == '\r' && c == '\n') {
							 lineEndChar = '\n';
							 continue;
						 }
						 lineEndChar = -1;
						 lineStart = sourceCursor - 1;
						 lineno++;
					 }
					 if (c <= 127) {
						 if (c == '\n' || c == '\r') {
							 lineEndChar = c;
							 c = '\n';
						 }
					 }
					 else {
						 if (isJSFormatChar(c)) {
							 continue;
						 }
						 if (ScriptRuntime.isJSLineTerminator(c)) {
							 lineEndChar = c;
							 c = '\n';
						 }
					 }
					 return c;
				 }
			 }
			 private void skipLine() throws IOException {
				 int c;
				 while ((c = getChar()) != EOF_CHAR && c != '\n') {
				 }
				 ungetChar(c);
			 }
			 final int getOffset() {
				 int n = sourceCursor - lineStart;
				 if (lineEndChar >= 0) {
					 --n;
				 }
				 return n;
			 }
			 final String getLine() {
				 if (sourceString != null) {
					 int lineEnd = sourceCursor;
					 if (lineEndChar >= 0) {
						 --lineEnd;
					 }
					 else {
						 for (;
						 lineEnd != sourceEnd;
						 ++lineEnd) {
							 int c = sourceString.charAt(lineEnd);
							 if (ScriptRuntime.isJSLineTerminator(c)) {
								 break;
							 }
						 }
					 }
					 return sourceString.substring(lineStart, lineEnd);
				 }
				 else {
					 int lineLength = sourceCursor - lineStart;
					 if (lineEndChar >= 0) {
						 --lineLength;
					 }
					 else {
						 for (;
						;
						 ++lineLength) {
							 int i = lineStart + lineLength;
							 if (i == sourceEnd) {
								 try {
									 if (!fillSourceBuffer()) {
										 break;
									 }
								 }
								 catch (IOException ioe) {
									 break;
								 }
								 i = lineStart + lineLength;
							 }
							 int c = sourceBuffer[i];
							 if (ScriptRuntime.isJSLineTerminator(c)) {
								 break;
							 }
						 }
					 }
					 return new String(sourceBuffer, lineStart, lineLength);
				 }
			 }
			 private boolean fillSourceBuffer() throws IOException {
				 if (sourceString != null) Kit.codeBug();
				 if (sourceEnd == sourceBuffer.length) {
					 if (lineStart != 0) {
						 System.arraycopy(sourceBuffer, lineStart, sourceBuffer, 0, sourceEnd - lineStart);
						 sourceEnd -= lineStart;
						 sourceCursor -= lineStart;
						 lineStart = 0;
					 }
					 else {
						 char[] tmp = new char[sourceBuffer.length * 2];
						 System.arraycopy(sourceBuffer, 0, tmp, 0, sourceEnd);
						 sourceBuffer = tmp;
					 }
				 }
				 int n = sourceReader.read(sourceBuffer, sourceEnd, sourceBuffer.length - sourceEnd);
				 if (n < 0) {
					 return false;
				 }
				 sourceEnd += n;
				 return true;
			 }
			 private boolean dirtyLine;
			 String regExpFlags;
			 private String line;
			 private boolean fromEval;
			 private String string = """";
			 private double number;
			 private char[] stringBuffer = new char[128];
			 private int stringBufferTop;
			 private ObjToIntMap allStrings = new ObjToIntMap(50);
			 private final int[] ungetBuffer = new int[3];
			 private int ungetCursor;
			 private boolean hitEOF = false;
			 private int lineStart = 0;
			 private int lineno;
			 private int lineEndChar = -1;
			 private String sourceString;
			 private Reader sourceReader;
			 private char[] sourceBuffer;
			 private int sourceEnd;
			 private int sourceCursor;
			 private boolean xmlIsAttribute;
			 private boolean xmlIsTagContent;
			 private int xmlOpenTagsCount;
			 private Parser parser;
		}",0,0,0,0
"public class Project {
	 public static final int MSG_ERR = 0;
	 public static final int MSG_WARN = 1;
	 public static final int MSG_INFO = 2;
	 public static final int MSG_VERBOSE = 3;
	 public static final int MSG_DEBUG = 4;
	 private static final String VISITING = ""VISITING"";
	 private static final String VISITED = ""VISITED"";
	 private static final String ANTCLASSLOADER_JDK12 = ""org.apache.tools.ant.loader.AntClassLoader2"";
	 public static final String JAVA_1_0 = JavaEnvUtils.JAVA_1_0;
	 public static final String JAVA_1_1 = JavaEnvUtils.JAVA_1_1;
	 public static final String JAVA_1_2 = JavaEnvUtils.JAVA_1_2;
	 public static final String JAVA_1_3 = JavaEnvUtils.JAVA_1_3;
	 public static final String JAVA_1_4 = JavaEnvUtils.JAVA_1_4;
	 public static final String TOKEN_START = FilterSet.DEFAULT_TOKEN_START;
	 public static final String TOKEN_END = FilterSet.DEFAULT_TOKEN_END;
	 private String name;
	 private String description;
	 private Hashtable references = new AntRefTable(this);
	 private String defaultTarget;
	 private Hashtable targets = new Hashtable();
	 private FilterSet globalFilterSet = new FilterSet();
	 private FilterSetCollection globalFilters = new FilterSetCollection(globalFilterSet);
	 private File baseDir;
	 private Vector listeners = new Vector();
	 private ClassLoader coreLoader = null;
	 private Hashtable threadTasks = new Hashtable();
	 private Hashtable threadGroupTasks = new Hashtable();
	 private InputHandler inputHandler = null;
	 private InputStream defaultInputStream = null;
	 private boolean keepGoingMode = false;
	 public void setInputHandler(InputHandler handler) {
		 inputHandler = handler;
	 }
	 public void setDefaultInputStream(InputStream defaultInputStream) {
		 this.defaultInputStream = defaultInputStream;
	 }
	 public InputStream getDefaultInputStream() {
		 return defaultInputStream;
	 }
	 public InputHandler getInputHandler() {
		 return inputHandler;
	 }
	 private FileUtils fileUtils;
	 private boolean loggingMessage = false;
	 public Project() {
		 fileUtils = FileUtils.newFileUtils();
		 inputHandler = new DefaultInputHandler();
	 }
	 public void initSubProject(Project subProject) {
		 ComponentHelper.getComponentHelper(subProject) .initSubProject(ComponentHelper.getComponentHelper(this));
		 subProject.setKeepGoingMode(this.isKeepGoingMode());
	 }
	 public void init() throws BuildException {
		 setJavaVersionProperty();
		 ComponentHelper.getComponentHelper(this).initDefaultDefinitions();
		 setSystemProperties();
	 }
	 private AntClassLoader createClassLoader() {
		 AntClassLoader loader = null;
		 if (!JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1)) {
			 try {
				 Class loaderClass = Class.forName(ANTCLASSLOADER_JDK12);
				 loader = (AntClassLoader) loaderClass.newInstance();
			 }
			 catch (Exception e) {
				 log(""Unable to create Class Loader: "" + e.getMessage(), Project.MSG_DEBUG);
			 }
		 }
		 if (loader == null) {
			 loader = new AntClassLoader();
		 }
		 loader.setProject(this);
		 return loader;
	 }
	 public AntClassLoader createClassLoader(Path path) {
		 AntClassLoader loader = createClassLoader();
		 loader.setClassPath(path);
		 return loader;
	 }
	 public void setCoreLoader(ClassLoader coreLoader) {
		 this.coreLoader = coreLoader;
	 }
	 public ClassLoader getCoreLoader() {
		 return coreLoader;
	 }
	 public synchronized void addBuildListener(BuildListener listener) {
		 Vector newListeners = getBuildListeners();
		 newListeners.addElement(listener);
		 listeners = newListeners;
	 }
	 public synchronized void removeBuildListener(BuildListener listener) {
		 Vector newListeners = getBuildListeners();
		 newListeners.removeElement(listener);
		 listeners = newListeners;
	 }
	 public Vector getBuildListeners() {
		 return (Vector) listeners.clone();
	 }
	 public void log(String message) {
		 log(message, MSG_INFO);
	 }
	 public void log(String message, int msgLevel) {
		 fireMessageLogged(this, message, msgLevel);
	 }
	 public void log(Task task, String message, int msgLevel) {
		 fireMessageLogged(task, message, msgLevel);
	 }
	 public void log(Target target, String message, int msgLevel) {
		 fireMessageLogged(target, message, msgLevel);
	 }
	 public FilterSet getGlobalFilterSet() {
		 return globalFilterSet;
	 }
	 public void setProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this). setProperty(null, name, value, true);
	 }
	 public void setNewProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setNewProperty(null, name, value);
	 }
	 public void setUserProperty(String name, String value) {
		 PropertyHelper.getPropertyHelper(this).setUserProperty(null, name, value);
	 }
	 public void setInheritedProperty(String name, String value) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.setInheritedProperty(null, name, value);
	 }
	 private void setPropertyInternal(String name, String value) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.setProperty(null, name, value, false);
	 }
	 public String getProperty(String name) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return (String) ph.getProperty(null, name);
	 }
	 public String replaceProperties(String value) throws BuildException {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.replaceProperties(null, value, null);
	 }
	 public String getUserProperty(String name) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return (String) ph.getUserProperty(null, name);
	 }
	 public Hashtable getProperties() {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.getProperties();
	 }
	 public Hashtable getUserProperties() {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 return ph.getUserProperties();
	 }
	 public void copyUserProperties(Project other) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.copyUserProperties(other);
	 }
	 public void copyInheritedProperties(Project other) {
		 PropertyHelper ph = PropertyHelper.getPropertyHelper(this);
		 ph.copyInheritedProperties(other);
	 }
	 public void setDefaultTarget(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public String getDefaultTarget() {
		 return defaultTarget;
	 }
	 public void setDefault(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public void setName(String name) {
		 setUserProperty(""ant.project.name"", name);
		 this.name = name;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getDescription() {
		 if (description == null) {
			 description = Description.getDescription(this);
		 }
		 return description;
	 }
	 public void addFilter(String token, String value) {
		 if (token == null) {
			 return;
		 }
		 globalFilterSet.addFilter(new FilterSet.Filter(token, value));
	 }
	 public Hashtable getFilters() {
		 return globalFilterSet.getFilterHash();
	 }
	 public void setBasedir(String baseD) throws BuildException {
		 setBaseDir(new File(baseD));
	 }
	 public void setBaseDir(File baseDir) throws BuildException {
		 baseDir = fileUtils.normalize(baseDir.getAbsolutePath());
		 if (!baseDir.exists()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" does not exist"");
		 }
		 if (!baseDir.isDirectory()) {
			 throw new BuildException(""Basedir "" + baseDir.getAbsolutePath() + "" is not a directory"");
		 }
		 this.baseDir = baseDir;
		 setPropertyInternal(""basedir"", this.baseDir.getPath());
		 String msg = ""Project base dir set to: "" + this.baseDir;
		 log(msg, MSG_VERBOSE);
	 }
	 public File getBaseDir() {
		 if (baseDir == null) {
			 try {
				 setBasedir(""."");
			 }
			 catch (BuildException ex) {
				 ex.printStackTrace();
			 }
		 }
		 return baseDir;
	 }
	 public void setKeepGoingMode(boolean keepGoingMode) {
		 this.keepGoingMode = keepGoingMode;
	 }
	 public boolean isKeepGoingMode() {
		 return this.keepGoingMode;
	 }
	 public static String getJavaVersion() {
		 return JavaEnvUtils.getJavaVersion();
	 }
	 public void setJavaVersionProperty() throws BuildException {
		 String javaVersion = JavaEnvUtils.getJavaVersion();
		 setPropertyInternal(""ant.java.version"", javaVersion);
		 if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_0)) {
			 throw new BuildException(""Ant cannot work on Java 1.0"");
		 }
		 log(""Detected Java version: "" + javaVersion + "" in: "" + System.getProperty(""java.home""), MSG_VERBOSE);
		 log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
	 }
	 public void setSystemProperties() {
		 Properties systemP = System.getProperties();
		 Enumeration e = systemP.keys();
		 while (e.hasMoreElements()) {
			 Object name = e.nextElement();
			 String value = systemP.get(name).toString();
			 this.setPropertyInternal(name.toString(), value);
		 }
	 }
	 public void addTaskDefinition(String taskName, Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).addTaskDefinition(taskName, taskClass);
	 }
	 public void checkTaskClass(final Class taskClass) throws BuildException {
		 ComponentHelper.getComponentHelper(this).checkTaskClass(taskClass);
		 if (!Modifier.isPublic(taskClass.getModifiers())) {
			 final String message = taskClass + "" is not public"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 if (Modifier.isAbstract(taskClass.getModifiers())) {
			 final String message = taskClass + "" is abstract"";
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 try {
			 taskClass.getConstructor(null);
		 }
		 catch (NoSuchMethodException e) {
			 final String message = ""No public no-arg constructor in "" + taskClass;
			 log(message, Project.MSG_ERR);
			 throw new BuildException(message);
		 }
		 if (!Task.class.isAssignableFrom(taskClass)) {
			 TaskAdapter.checkTaskClass(taskClass, this);
		 }
	 }
	 public Hashtable getTaskDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getTaskDefinitions();
	 }
	 public void addDataTypeDefinition(String typeName, Class typeClass) {
		 ComponentHelper.getComponentHelper(this).addDataTypeDefinition(typeName, typeClass);
	 }
	 public Hashtable getDataTypeDefinitions() {
		 return ComponentHelper.getComponentHelper(this).getDataTypeDefinitions();
	 }
	 public void addTarget(Target target) throws BuildException {
		 String name = target.getName();
		 if (targets.get(name) != null) {
			 throw new BuildException(""Duplicate target: `"" + name + ""'"");
		 }
		 addOrReplaceTarget(name, target);
	 }
	 public void addTarget(String targetName, Target target) throws BuildException {
		 if (targets.get(targetName) != null) {
			 throw new BuildException(""Duplicate target: `"" + targetName + ""'"");
		 }
		 addOrReplaceTarget(targetName, target);
	 }
	 public void addOrReplaceTarget(Target target) {
		 addOrReplaceTarget(target.getName(), target);
	 }
	 public void addOrReplaceTarget(String targetName, Target target) {
		 String msg = "" +Target: "" + targetName;
		 log(msg, MSG_DEBUG);
		 target.setProject(this);
		 targets.put(targetName, target);
	 }
	 public Hashtable getTargets() {
		 return targets;
	 }
	 public Task createTask(String taskType) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createTask(taskType);
	 }
	 public Object createDataType(String typeName) throws BuildException {
		 return ComponentHelper.getComponentHelper(this).createDataType(typeName);
	 }
	 public void executeTargets(Vector targetNames) throws BuildException {
		 for (int i = 0;
		 i < targetNames.size();
		 i++) {
			 executeTarget((String) targetNames.elementAt(i));
		 }
	 }
	 public void demuxOutput(String output, boolean isWarning) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 log(output, isWarning ? MSG_WARN : MSG_INFO);
		 }
		 else {
			 if (isWarning) {
				 task.handleErrorOutput(output);
			 }
			 else {
				 task.handleOutput(output);
			 }
		 }
	 }
	 public int defaultInput(byte[] buffer, int offset, int length) throws IOException {
		 if (defaultInputStream != null) {
			 System.out.flush();
			 return defaultInputStream.read(buffer, offset, length);
		 }
		 else {
			 throw new EOFException(""No input provided for project"");
		 }
	 }
	 public int demuxInput(byte[] buffer, int offset, int length) throws IOException {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 return defaultInput(buffer, offset, length);
		 }
		 else {
			 return task.handleInput(buffer, offset, length);
		 }
	 }
	 public void demuxFlush(String output, boolean isError) {
		 Task task = getThreadTask(Thread.currentThread());
		 if (task == null) {
			 fireMessageLogged(this, output, isError ? MSG_ERR : MSG_INFO);
		 }
		 else {
			 if (isError) {
				 task.handleErrorFlush(output);
			 }
			 else {
				 task.handleFlush(output);
			 }
		 }
	 }
	 public void executeTarget(String targetName) throws BuildException {
		 if (targetName == null) {
			 String msg = ""No target specified"";
			 throw new BuildException(msg);
		 }
		 Vector sortedTargets = topoSort(targetName, targets);
		 Set succeededTargets = new HashSet();
		 BuildException buildException = null;
		 for (Enumeration iter = sortedTargets.elements();
		 iter.hasMoreElements();
		) {
			 Target curtarget = (Target) iter.nextElement();
			 boolean canExecute = true;
			 for (Enumeration depIter = curtarget.getDependencies();
			 depIter.hasMoreElements();
			) {
				 String dependencyName = ((String) depIter.nextElement());
				 if (!succeededTargets.contains(dependencyName)) {
					 canExecute = false;
					 log(curtarget, ""Cannot execute '"" + curtarget.getName() + ""' - '"" + dependencyName + ""' failed or was not executed."", MSG_ERR);
					 break;
				 }
			 }
			 if (canExecute) {
				 Throwable thrownException = null;
				 try {
					 curtarget.performTasks();
					 succeededTargets.add(curtarget.getName());
				 }
				 catch (RuntimeException ex) {
					 if (!(keepGoingMode)) {
						 throw ex;
					 }
					 thrownException = ex;
				 }
				 catch (Throwable ex) {
					 if (!(keepGoingMode)) {
						 throw new BuildException(ex);
					 }
					 thrownException = ex;
				 }
				 if (thrownException != null) {
					 if (thrownException instanceof BuildException) {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 if (buildException == null) {
							 buildException = (BuildException) thrownException;
						 }
					 }
					 else {
						 log(curtarget, ""Target '"" + curtarget.getName() + ""' failed with message '"" + thrownException.getMessage() + ""'."", MSG_ERR);
						 thrownException.printStackTrace(System.err);
						 if (buildException == null) {
							 buildException = new BuildException(thrownException);
						 }
					 }
				 }
			 }
			 if (curtarget.getName().equals(targetName)) {
				 break;
			 }
		 }
		 if (buildException != null) {
			 throw buildException;
		 }
	 }
	 public File resolveFile(String fileName, File rootDir) {
		 return fileUtils.resolveFile(rootDir, fileName);
	 }
	 public File resolveFile(String fileName) {
		 return fileUtils.resolveFile(baseDir, fileName);
	 }
	 public static String translatePath(String toProcess) {
		 if (toProcess == null || toProcess.length() == 0) {
			 return """";
		 }
		 StringBuffer path = new StringBuffer(toProcess.length() + 50);
		 PathTokenizer tokenizer = new PathTokenizer(toProcess);
		 while (tokenizer.hasMoreTokens()) {
			 String pathComponent = tokenizer.nextToken();
			 pathComponent = pathComponent.replace('/', File.separatorChar);
			 pathComponent = pathComponent.replace('\\', File.separatorChar);
			 if (path.length() != 0) {
				 path.append(File.pathSeparatorChar);
			 }
			 path.append(pathComponent);
		 }
		 return path.toString();
	 }
	 public void copyFile(String sourceFile, String destFile) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void copyFile(File sourceFile, File destFile) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile, filtering ? globalFilters : null);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 fileUtils.copyFile(sourceFile, destFile, filtering ? globalFilters : null, overwrite, preserveLastModified);
	 }
	 public void setFileLastModified(File file, long time) throws BuildException {
		 if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_1)) {
			 log(""Cannot change the modification time of "" + file + "" in JDK 1.1"", Project.MSG_WARN);
			 return;
		 }
		 fileUtils.setFileLastModified(file, time);
		 log(""Setting modification time for "" + file, MSG_VERBOSE);
	 }
	 public static boolean toBoolean(String s) {
		 return (""on"".equalsIgnoreCase(s) || ""true"".equalsIgnoreCase(s) || ""yes"".equalsIgnoreCase(s));
	 }
	 public final Vector topoSort(String root, Hashtable targets) throws BuildException {
		 Vector ret = new Vector();
		 Hashtable state = new Hashtable();
		 Stack visiting = new Stack();
		 tsort(root, targets, state, visiting, ret);
		 log(""Build sequence for target `"" + root + ""' is "" + ret, MSG_VERBOSE);
		 for (Enumeration en = targets.keys();
		 en.hasMoreElements();
		) {
			 String curTarget = (String) en.nextElement();
			 String st = (String) state.get(curTarget);
			 if (st == null) {
				 tsort(curTarget, targets, state, visiting, ret);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: "" + curTarget);
			 }
		 }
		 log(""Complete build sequence is "" + ret, MSG_VERBOSE);
		 return ret;
	 }
	 private final void tsort(String root, Hashtable targets, Hashtable state, Stack visiting, Vector ret) throws BuildException {
		 state.put(root, VISITING);
		 visiting.push(root);
		 Target target = (Target) targets.get(root);
		 if (target == null) {
			 StringBuffer sb = new StringBuffer(""Target `"");
			 sb.append(root);
			 sb.append(""' does not exist in this project. "");
			 visiting.pop();
			 if (!visiting.empty()) {
				 String parent = (String) visiting.peek();
				 sb.append(""It is used from target `"");
				 sb.append(parent);
				 sb.append(""'."");
			 }
			 throw new BuildException(new String(sb));
		 }
		 for (Enumeration en = target.getDependencies();
		 en.hasMoreElements();
		) {
			 String cur = (String) en.nextElement();
			 String m = (String) state.get(cur);
			 if (m == null) {
				 tsort(cur, targets, state, visiting, ret);
			 }
			 else if (m == VISITING) {
				 throw makeCircularException(cur, visiting);
			 }
		 }
		 String p = (String) visiting.pop();
		 if (root != p) {
			 throw new RuntimeException(""Unexpected internal error: expected to "" + ""pop "" + root + "" but got "" + p);
		 }
		 state.put(root, VISITED);
		 ret.addElement(target);
	 }
	 private static BuildException makeCircularException(String end, Stack stk) {
		 StringBuffer sb = new StringBuffer(""Circular dependency: "");
		 sb.append(end);
		 String c;
		 do {
			 c = (String) stk.pop();
			 sb.append("" <- "");
			 sb.append(c);
		 }
		 while (!c.equals(end));
		 return new BuildException(new String(sb));
	 }
	 public void addReference(String name, Object value) {
		 synchronized (references) {
			 Object old = ((AntRefTable) references).getReal(name);
			 if (old == value) {
				 return;
			 }
			 if (old != null && !(old instanceof UnknownElement)) {
				 log(""Overriding previous definition of reference to "" + name, MSG_WARN);
			 }
			 log(""Adding reference: "" + name, MSG_DEBUG);
			 references.put(name, value);
		 }
	 }
	 public Hashtable getReferences() {
		 return references;
	 }
	 public Object getReference(String key) {
		 return references.get(key);
	 }
	 public String getElementName(Object element) {
		 return ComponentHelper.getComponentHelper(this).getElementName(element);
	 }
	 public void fireBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.buildStarted(event);
		 }
	 }
	 public void fireBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.buildFinished(event);
		 }
	 }
	 protected void fireTargetStarted(Target target) {
		 BuildEvent event = new BuildEvent(target);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.targetStarted(event);
		 }
	 }
	 protected void fireTargetFinished(Target target, Throwable exception) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.targetFinished(event);
		 }
	 }
	 protected void fireTaskStarted(Task task) {
		 registerThreadTask(Thread.currentThread(), task);
		 BuildEvent event = new BuildEvent(task);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.taskStarted(event);
		 }
	 }
	 protected void fireTaskFinished(Task task, Throwable exception) {
		 registerThreadTask(Thread.currentThread(), null);
		 System.out.flush();
		 System.err.flush();
		 BuildEvent event = new BuildEvent(task);
		 event.setException(exception);
		 Iterator iter = listeners.iterator();
		 while (iter.hasNext()) {
			 BuildListener listener = (BuildListener) iter.next();
			 listener.taskFinished(event);
		 }
	 }
	 private void fireMessageLoggedEvent(BuildEvent event, String message, int priority) {
		 if (message.endsWith(StringUtils.LINE_SEP)) {
			 int endIndex = message.length() - StringUtils.LINE_SEP.length();
			 event.setMessage(message.substring(0, endIndex), priority);
		 }
		 else {
			 event.setMessage(message, priority);
		 }
		 synchronized (this) {
			 if (loggingMessage) {
				 throw new BuildException(""Listener attempted to access "" + (priority == MSG_ERR ? ""System.err"" : ""System.out"") + "" - infinite loop terminated"");
			 }
			 try {
				 loggingMessage = true;
				 Iterator iter = listeners.iterator();
				 while (iter.hasNext()) {
					 BuildListener listener = (BuildListener) iter.next();
					 listener.messageLogged(event);
				 }
			 }
			 finally {
				 loggingMessage = false;
			 }
		 }
	 }
	 protected void fireMessageLogged(Project project, String message, int priority) {
		 BuildEvent event = new BuildEvent(project);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, int priority) {
		 BuildEvent event = new BuildEvent(target);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, int priority) {
		 BuildEvent event = new BuildEvent(task);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 public synchronized void registerThreadTask(Thread thread, Task task) {
		 if (task != null) {
			 threadTasks.put(thread, task);
			 threadGroupTasks.put(thread.getThreadGroup(), task);
		 }
		 else {
			 threadTasks.remove(thread);
			 threadGroupTasks.remove(thread.getThreadGroup());
		 }
	 }
	 public Task getThreadTask(Thread thread) {
		 Task task = (Task) threadTasks.get(thread);
		 if (task == null) {
			 ThreadGroup group = thread.getThreadGroup();
			 while (task == null && group != null) {
				 task = (Task) threadGroupTasks.get(group);
				 group = group.getParent();
			 }
		 }
		 return task;
	 }
	 private static class AntRefTable extends Hashtable {
		 private Project project;
		 public AntRefTable(Project project) {
			 super();
			 this.project = project;
		 }
		 public Object getReal(Object key) {
			 return super.get(key);
		 }
		 public Object get(Object key) {
			 Object o = super.get(key);
			 if (o instanceof UnknownElement) {
				 UnknownElement ue = (UnknownElement) o;
				 ue.maybeConfigure();
				 o = ue.getRealThing();
			 }
			 return o;
		 }
	 }
	 public final void setProjectReference(final Object obj) {
		 if (obj instanceof ProjectComponent) {
			 ((ProjectComponent) obj).setProject(this);
			 return;
		 }
		 try {
			 Method method = obj.getClass().getMethod( ""setProject"", new Class[] {
			Project.class}
			);
			 if (method != null) {
				 method.invoke(obj, new Object[] {
				this}
				);
			 }
		 }
		 catch (Throwable e) {
		 }
	 }
}",1,0,0,0
"public class Interpreter{
	 private static final int Icode_DUP = -1, Icode_DUP2 = -2, Icode_SWAP = -3, Icode_POP = -4, Icode_POP_RESULT = -5, Icode_IFEQ_POP = -6, Icode_VAR_INC_DEC = -7, Icode_NAME_INC_DEC = -8, Icode_PROP_INC_DEC = -9, Icode_ELEM_INC_DEC = -10, Icode_REF_INC_DEC = -11, Icode_SCOPE = -12, Icode_SCOPE_LOAD = -13, Icode_SCOPE_SAVE = -14, Icode_TYPEOFNAME = -15, Icode_NAME_AND_THIS = -16, Icode_PROP_AND_THIS = -17, Icode_ELEM_AND_THIS = -18, Icode_VALUE_AND_THIS = -19, Icode_CLOSURE_EXPR = -20, Icode_CLOSURE_STMT = -21, Icode_CALLSPECIAL = -22, Icode_RETUNDEF = -23, Icode_GOSUB = -24, Icode_STARTSUB = -25, Icode_RETSUB = -26, Icode_LINE = -27, Icode_SHORTNUMBER = -28, Icode_INTNUMBER = -29, Icode_LITERAL_NEW = -30, Icode_LITERAL_SET = -31, Icode_SPARE_ARRAYLIT = -32, Icode_REG_IND_C0 = -33, Icode_REG_IND_C1 = -34, Icode_REG_IND_C2 = -35, Icode_REG_IND_C3 = -36, Icode_REG_IND_C4 = -37, Icode_REG_IND_C5 = -38, Icode_REG_IND1 = -39, Icode_REG_IND2 = -40, Icode_REG_IND4 = -41, Icode_REG_STR_C0 = -42, Icode_REG_STR_C1 = -43, Icode_REG_STR_C2 = -44, Icode_REG_STR_C3 = -45, Icode_REG_STR1 = -46, Icode_REG_STR2 = -47, Icode_REG_STR4 = -48, Icode_GETVAR1 = -49, Icode_SETVAR1 = -50, Icode_UNDEF = -51, Icode_ZERO = -52, Icode_ONE = -53, Icode_ENTERDQ = -54, Icode_LEAVEDQ = -55, Icode_TAIL_CALL = -56, Icode_LOCAL_CLEAR = -57, MIN_ICODE = -57;
	 private CompilerEnvirons compilerEnv;
	 private boolean itsInFunctionFlag;
	 private InterpreterData itsData;
	 private ScriptOrFnNode scriptOrFn;
	 private int itsICodeTop;
	 private int itsStackDepth;
	 private int itsLineNumber;
	 private int itsDoubleTableTop;
	 private ObjToIntMap itsStrings = new ObjToIntMap(20);
	 private int itsLocalTop;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsLiteralIds = new ObjArray();
	 private int itsExceptionTableTop;
	 private static final int EXCEPTION_TRY_START_SLOT = 0;
	 private static final int EXCEPTION_TRY_END_SLOT = 1;
	 private static final int EXCEPTION_HANDLER_SLOT = 2;
	 private static final int EXCEPTION_TYPE_SLOT = 3;
	 private static final int EXCEPTION_LOCAL_SLOT = 4;
	 private static final int EXCEPTION_SCOPE_SLOT = 5;
	 private static final int EXCEPTION_SLOT_SIZE = 6;
	 private static final int ECF_TAIL = 1 << 0;
	 private static class CallFrame implements Cloneable, Serializable {
		 CallFrame parentFrame;
		 int frameIndex;
		 boolean frozen;
		 InterpretedFunction fnOrScript;
		 InterpreterData idata;
		 Object[] stack;
		 double[] sDbl;
		 CallFrame varSource;
		 int localShift;
		 int emptyStackTop;
		 DebugFrame debuggerFrame;
		 boolean useActivation;
		 Scriptable thisObj;
		 Scriptable[] scriptRegExps;
		 Object result;
		 double resultDbl;
		 int pc;
		 int pcPrevBranch;
		 int pcSourceLineStart;
		 Scriptable scope;
		 int savedStackTop;
		 int savedCallOp;
		 CallFrame cloneFrozen() {
			 if (!frozen) Kit.codeBug();
			 CallFrame copy;
			 try {
				 copy = (CallFrame)clone();
			 }
			 catch (CloneNotSupportedException ex) {
				 throw new IllegalStateException();
			 }
			 copy.stack = (Object[])stack.clone();
			 copy.sDbl = (double[])sDbl.clone();
			 copy.frozen = false;
			 return copy;
		 }
	 }
	 private static final class ContinuationJump implements Serializable {
		 CallFrame capturedFrame;
		 CallFrame branchFrame;
		 Object result;
		 double resultDbl;
		 ContinuationJump(Continuation c, CallFrame current) {
			 this.capturedFrame = (CallFrame)c.getImplementation();
			 if (this.capturedFrame == null || current == null) {
				 this.branchFrame = null;
			 }
			 else {
				 CallFrame chain1 = this.capturedFrame;
				 CallFrame chain2 = current;
				 int diff = chain1.frameIndex - chain2.frameIndex;
				 if (diff != 0) {
					 if (diff < 0) {
						 chain1 = current;
						 chain2 = this.capturedFrame;
						 diff = -diff;
					 }
					 do {
						 chain1 = chain1.parentFrame;
					 }
					 while (--diff != 0);
					 if (chain1.frameIndex != chain2.frameIndex) Kit.codeBug();
				 }
				 while (chain1 != chain2 && chain1 != null) {
					 chain1 = chain1.parentFrame;
					 chain2 = chain2.parentFrame;
				 }
				 this.branchFrame = chain1;
				 if (this.branchFrame != null && !this.branchFrame.frozen) Kit.codeBug();
			 }
		 }
	 }
	 static {
		 if (Token.LAST_BYTECODE_TOKEN > 127) {
			 String str = ""Violation of Token.LAST_BYTECODE_TOKEN <= 127"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
		 if (MIN_ICODE < -128) {
			 String str = ""Violation of Interpreter.MIN_ICODE >= -128"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
	 }
	 private static String bytecodeName(int bytecode) {
		 if (!validBytecode(bytecode)) {
			 throw new IllegalArgumentException(String.valueOf(bytecode));
		 }
		 if (!Token.printICode) {
			 return String.valueOf(bytecode);
		 }
		 if (validTokenCode(bytecode)) {
			 return Token.name(bytecode);
		 }
		 switch (bytecode) {
			 case Icode_DUP: return ""DUP"";
			 case Icode_DUP2: return ""DUP2"";
			 case Icode_SWAP: return ""SWAP"";
			 case Icode_POP: return ""POP"";
			 case Icode_POP_RESULT: return ""POP_RESULT"";
			 case Icode_IFEQ_POP: return ""IFEQ_POP"";
			 case Icode_VAR_INC_DEC: return ""VAR_INC_DEC"";
			 case Icode_NAME_INC_DEC: return ""NAME_INC_DEC"";
			 case Icode_PROP_INC_DEC: return ""PROP_INC_DEC"";
			 case Icode_ELEM_INC_DEC: return ""ELEM_INC_DEC"";
			 case Icode_REF_INC_DEC: return ""REF_INC_DEC"";
			 case Icode_SCOPE: return ""SCOPE"";
			 case Icode_SCOPE_LOAD: return ""SCOPE_LOAD"";
			 case Icode_SCOPE_SAVE: return ""SCOPE_SAVE"";
			 case Icode_TYPEOFNAME: return ""TYPEOFNAME"";
			 case Icode_NAME_AND_THIS: return ""NAME_AND_THIS"";
			 case Icode_PROP_AND_THIS: return ""PROP_AND_THIS"";
			 case Icode_ELEM_AND_THIS: return ""ELEM_AND_THIS"";
			 case Icode_VALUE_AND_THIS: return ""VALUE_AND_THIS"";
			 case Icode_CLOSURE_EXPR: return ""CLOSURE_EXPR"";
			 case Icode_CLOSURE_STMT: return ""CLOSURE_STMT"";
			 case Icode_CALLSPECIAL: return ""CALLSPECIAL"";
			 case Icode_RETUNDEF: return ""RETUNDEF"";
			 case Icode_GOSUB: return ""GOSUB"";
			 case Icode_STARTSUB: return ""STARTSUB"";
			 case Icode_RETSUB: return ""RETSUB"";
			 case Icode_LINE: return ""LINE"";
			 case Icode_SHORTNUMBER: return ""SHORTNUMBER"";
			 case Icode_INTNUMBER: return ""INTNUMBER"";
			 case Icode_LITERAL_NEW: return ""LITERAL_NEW"";
			 case Icode_LITERAL_SET: return ""LITERAL_SET"";
			 case Icode_SPARE_ARRAYLIT: return ""SPARE_ARRAYLIT"";
			 case Icode_REG_IND_C0: return ""REG_IND_C0"";
			 case Icode_REG_IND_C1: return ""REG_IND_C1"";
			 case Icode_REG_IND_C2: return ""REG_IND_C2"";
			 case Icode_REG_IND_C3: return ""REG_IND_C3"";
			 case Icode_REG_IND_C4: return ""REG_IND_C4"";
			 case Icode_REG_IND_C5: return ""REG_IND_C5"";
			 case Icode_REG_IND1: return ""LOAD_IND1"";
			 case Icode_REG_IND2: return ""LOAD_IND2"";
			 case Icode_REG_IND4: return ""LOAD_IND4"";
			 case Icode_REG_STR_C0: return ""REG_STR_C0"";
			 case Icode_REG_STR_C1: return ""REG_STR_C1"";
			 case Icode_REG_STR_C2: return ""REG_STR_C2"";
			 case Icode_REG_STR_C3: return ""REG_STR_C3"";
			 case Icode_REG_STR1: return ""LOAD_STR1"";
			 case Icode_REG_STR2: return ""LOAD_STR2"";
			 case Icode_REG_STR4: return ""LOAD_STR4"";
			 case Icode_GETVAR1: return ""GETVAR1"";
			 case Icode_SETVAR1: return ""SETVAR1"";
			 case Icode_UNDEF: return ""UNDEF"";
			 case Icode_ZERO: return ""ZERO"";
			 case Icode_ONE: return ""ONE"";
			 case Icode_ENTERDQ: return ""ENTERDQ"";
			 case Icode_LEAVEDQ: return ""LEAVEDQ"";
			 case Icode_TAIL_CALL: return ""TAIL_CALL"";
			 case Icode_LOCAL_CLEAR: return ""LOCAL_CLEAR"";
		 }
		 throw new IllegalStateException(String.valueOf(bytecode));
	 }
	 private static boolean validIcode(int icode) {
		 return MIN_ICODE <= icode && icode <= -1;
	 }
	 private static boolean validTokenCode(int token) {
		 return Token.FIRST_BYTECODE_TOKEN <= token && token <= Token.LAST_BYTECODE_TOKEN;
	 }
	 private static boolean validBytecode(int bytecode) {
		 return validIcode(bytecode) || validTokenCode(bytecode);
	 }
	 public Object compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, String encodedSource, boolean returnFunction) {
		 this.compilerEnv = compilerEnv;
		 new NodeTransformer().transform(tree);
		 if (Token.printTrees) {
			 System.out.println(tree.toStringTree(tree));
		 }
		 if (returnFunction) {
			 tree = tree.getFunctionNode(0);
		 }
		 scriptOrFn = tree;
		 itsData = new InterpreterData(compilerEnv.getLanguageVersion(), scriptOrFn.getSourceName(), encodedSource);
		 itsData.topLevel = true;
		 if (returnFunction) {
			 generateFunctionICode();
		 }
		 else {
			 generateICodeFromTree(scriptOrFn);
		 }
		 return itsData;
	 }
	 public Script createScriptObject(Object bytecode, Object staticSecurityDomain) {
		 InterpreterData idata = (InterpreterData)bytecode;
		 return InterpretedFunction.createScript(itsData, staticSecurityDomain);
	 }
	 public Function createFunctionObject(Context cx, Scriptable scope, Object bytecode, Object staticSecurityDomain) {
		 InterpreterData idata = (InterpreterData)bytecode;
		 return InterpretedFunction.createFunction(cx, scope, itsData, staticSecurityDomain);
	 }
	 private void generateFunctionICode() {
		 itsInFunctionFlag = true;
		 FunctionNode theFunction = (FunctionNode)scriptOrFn;
		 itsData.itsFunctionType = theFunction.getFunctionType();
		 itsData.itsNeedsActivation = theFunction.requiresActivation();
		 itsData.itsName = theFunction.getFunctionName();
		 if (!theFunction.getIgnoreDynamicScope()) {
			 if (compilerEnv.isUseDynamicScope()) {
				 itsData.useDynamicScope = true;
			 }
		 }
		 generateICodeFromTree(theFunction.getLastChild());
	 }
	 private void generateICodeFromTree(Node tree) {
		 generateNestedFunctions();
		 generateRegExpLiterals();
		 visitStatement(tree);
		 fixLabelGotos();
		 if (itsData.itsFunctionType == 0) {
			 addToken(Token.RETURN_RESULT);
		 }
		 if (itsData.itsICode.length != itsICodeTop) {
			 byte[] tmp = new byte[itsICodeTop];
			 System.arraycopy(itsData.itsICode, 0, tmp, 0, itsICodeTop);
			 itsData.itsICode = tmp;
		 }
		 if (itsStrings.size() == 0) {
			 itsData.itsStringTable = null;
		 }
		 else {
			 itsData.itsStringTable = new String[itsStrings.size()];
			 ObjToIntMap.Iterator iter = itsStrings.newIterator();
			 for (iter.start();
			 !iter.done();
			 iter.next()) {
				 String str = (String)iter.getKey();
				 int index = iter.getValue();
				 if (itsData.itsStringTable[index] != null) Kit.codeBug();
				 itsData.itsStringTable[index] = str;
			 }
		 }
		 if (itsDoubleTableTop == 0) {
			 itsData.itsDoubleTable = null;
		 }
		 else if (itsData.itsDoubleTable.length != itsDoubleTableTop) {
			 double[] tmp = new double[itsDoubleTableTop];
			 System.arraycopy(itsData.itsDoubleTable, 0, tmp, 0, itsDoubleTableTop);
			 itsData.itsDoubleTable = tmp;
		 }
		 if (itsExceptionTableTop != 0 && itsData.itsExceptionTable.length != itsExceptionTableTop) {
			 int[] tmp = new int[itsExceptionTableTop];
			 System.arraycopy(itsData.itsExceptionTable, 0, tmp, 0, itsExceptionTableTop);
			 itsData.itsExceptionTable = tmp;
		 }
		 itsData.itsMaxVars = scriptOrFn.getParamAndVarCount();
		 itsData.itsMaxFrameArray = itsData.itsMaxVars + itsData.itsMaxLocals + itsData.itsMaxStack;
		 itsData.argNames = scriptOrFn.getParamAndVarNames();
		 itsData.argCount = scriptOrFn.getParamCount();
		 itsData.encodedSourceStart = scriptOrFn.getEncodedSourceStart();
		 itsData.encodedSourceEnd = scriptOrFn.getEncodedSourceEnd();
		 if (itsLiteralIds.size() != 0) {
			 itsData.literalIds = itsLiteralIds.toArray();
		 }
		 if (Token.printICode) dumpICode(itsData);
	 }
	 private void generateNestedFunctions() {
		 int functionCount = scriptOrFn.getFunctionCount();
		 if (functionCount == 0) return;
		 InterpreterData[] array = new InterpreterData[functionCount];
		 for (int i = 0;
		 i != functionCount;
		 i++) {
			 FunctionNode def = scriptOrFn.getFunctionNode(i);
			 Interpreter jsi = new Interpreter();
			 jsi.compilerEnv = compilerEnv;
			 jsi.scriptOrFn = def;
			 jsi.itsData = new InterpreterData(itsData);
			 jsi.generateFunctionICode();
			 array[i] = jsi.itsData;
		 }
		 itsData.itsNestedFunctions = array;
	 }
	 private void generateRegExpLiterals() {
		 int N = scriptOrFn.getRegexpCount();
		 if (N == 0) return;
		 Context cx = Context.getContext();
		 RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);
		 Object[] array = new Object[N];
		 for (int i = 0;
		 i != N;
		 i++) {
			 String string = scriptOrFn.getRegexpString(i);
			 String flags = scriptOrFn.getRegexpFlags(i);
			 array[i] = rep.compileRegExp(cx, string, flags);
		 }
		 itsData.itsRegExpLiterals = array;
	 }
	 private void updateLineNumber(Node node) {
		 int lineno = node.getLineno();
		 if (lineno != itsLineNumber && lineno >= 0) {
			 if (itsData.firstLinePC < 0) {
				 itsData.firstLinePC = lineno;
			 }
			 itsLineNumber = lineno;
			 addIcode(Icode_LINE);
			 addUint16(lineno & 0xFFFF);
		 }
	 }
	 private RuntimeException badTree(Node node) {
		 throw new RuntimeException(node.toString());
	 }
	 private void visitStatement(Node node) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 int fnType = scriptOrFn.getFunctionNode(fnIndex). getFunctionType();
				 if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 addIndexOp(Icode_CLOSURE_STMT, fnIndex);
				 }
				 else {
					 if (fnType != FunctionNode.FUNCTION_STATEMENT) {
						 throw Kit.codeBug();
					 }
				 }
			 }
			 break;
			 case Token.SCRIPT: case Token.LABEL: case Token.LOOP: case Token.BLOCK: case Token.EMPTY: case Token.WITH: updateLineNumber(node);
			 while (child != null) {
				 visitStatement(child);
				 child = child.getNext();
			 }
			 break;
			 case Token.ENTERWITH: visitExpression(child, 0);
			 addToken(Token.ENTERWITH);
			 stackChange(-1);
			 break;
			 case Token.LEAVEWITH: addToken(Token.LEAVEWITH);
			 break;
			 case Token.LOCAL_BLOCK: {
				 int local = allocLocal();
				 node.putIntProp(Node.LOCAL_PROP, local);
				 updateLineNumber(node);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, local);
				 releaseLocal(local);
			 }
			 break;
			 case Token.SWITCH: updateLineNumber(node);
			 {
				 Node switchNode = (Node.Jump)node;
				 visitExpression(child, 0);
				 for (Node.Jump caseNode = (Node.Jump)child.getNext();
				 caseNode != null;
				 caseNode = (Node.Jump)caseNode.getNext()) {
					 if (caseNode.getType() != Token.CASE) throw badTree(caseNode);
					 Node test = caseNode.getFirstChild();
					 addIcode(Icode_DUP);
					 stackChange(1);
					 visitExpression(test, 0);
					 addToken(Token.SHEQ);
					 stackChange(-1);
					 addGoto(caseNode.target, Icode_IFEQ_POP);
					 stackChange(-1);
				 }
				 addIcode(Icode_POP);
				 stackChange(-1);
			 }
			 break;
			 case Token.TARGET: markTargetLabel(node);
			 break;
			 case Token.IFEQ : case Token.IFNE : {
				 Node target = ((Node.Jump)node).target;
				 visitExpression(child, 0);
				 addGoto(target, type);
				 stackChange(-1);
			 }
			 break;
			 case Token.GOTO: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, type);
			 }
			 break;
			 case Token.JSR: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, Icode_GOSUB);
			 }
			 break;
			 case Token.FINALLY: {
				 stackChange(1);
				 int finallyRegister = getLocalBlockRef(node);
				 addIndexOp(Icode_STARTSUB, finallyRegister);
				 stackChange(-1);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_RETSUB, finallyRegister);
			 }
			 break;
			 case Token.EXPR_VOID: case Token.EXPR_RESULT: updateLineNumber(node);
			 visitExpression(child, 0);
			 addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);
			 stackChange(-1);
			 break;
			 case Token.TRY: {
				 Node.Jump tryNode = (Node.Jump)node;
				 int exceptionObjectLocal = getLocalBlockRef(tryNode);
				 int scopeLocal = allocLocal();
				 addIndexOp(Icode_SCOPE_SAVE, scopeLocal);
				 int tryStart = itsICodeTop;
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 Node catchTarget = tryNode.target;
				 if (catchTarget != null) {
					 int catchStartPC = itsLabelTable[getTargetLabel(catchTarget)];
					 addExceptionHandler( tryStart, catchStartPC, catchStartPC, false, exceptionObjectLocal, scopeLocal);
				 }
				 Node finallyTarget = tryNode.getFinally();
				 if (finallyTarget != null) {
					 int finallyStartPC = itsLabelTable[getTargetLabel(finallyTarget)];
					 addExceptionHandler( tryStart, finallyStartPC, finallyStartPC, true, exceptionObjectLocal, scopeLocal);
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);
				 releaseLocal(scopeLocal);
			 }
			 break;
			 case Token.CATCH_SCOPE: {
				 int localIndex = getLocalBlockRef(node);
				 int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringPrefix(name);
				 addIndexPrefix(localIndex);
				 addToken(Token.CATCH_SCOPE);
				 addUint8(scopeIndex != 0 ? 1 : 0);
				 stackChange(-1);
			 }
			 break;
			 case Token.THROW: updateLineNumber(node);
			 visitExpression(child, 0);
			 addToken(Token.THROW);
			 addUint16(itsLineNumber & 0xFFFF);
			 stackChange(-1);
			 break;
			 case Token.RETHROW: updateLineNumber(node);
			 addIndexOp(Token.RETHROW, getLocalBlockRef(node));
			 break;
			 case Token.RETURN: updateLineNumber(node);
			 if (child != null) {
				 visitExpression(child, ECF_TAIL);
				 addToken(Token.RETURN);
				 stackChange(-1);
			 }
			 else {
				 addIcode(Icode_RETUNDEF);
			 }
			 break;
			 case Token.RETURN_RESULT: updateLineNumber(node);
			 addToken(Token.RETURN_RESULT);
			 break;
			 case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES : visitExpression(child, 0);
			 addIndexOp(type, getLocalBlockRef(node));
			 stackChange(-1);
			 break;
			 default: throw badTree(node);
		 }
		 if (itsStackDepth != 0) {
			 throw Kit.codeBug();
		 }
	 }
	 private void visitExpression(Node node, int contextFlags) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 int savedStackDepth = itsStackDepth;
		 int expectedStackDelta = 1;
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);
				 if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {
					 throw Kit.codeBug();
				 }
				 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.LOCAL_LOAD: {
				 int localIndex = getLocalBlockRef(node);
				 addIndexOp(Token.LOCAL_LOAD, localIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.COMMA: {
				 Node lastChild = node.getLastChild();
				 while (child != lastChild) {
					 visitExpression(child, 0);
					 addIcode(Icode_POP);
					 stackChange(-1);
					 child = child.getNext();
				 }
				 visitExpression(child, contextFlags & ECF_TAIL);
			 }
			 break;
			 case Token.USE_STACK: stackChange(1);
			 break;
			 case Token.REF_CALL: expectedStackDelta = 2;
			 case Token.CALL: case Token.NEW: {
				 if (type == Token.NEW) {
					 visitExpression(child, 0);
				 }
				 else {
					 generateCallFunAndThis(child);
				 }
				 int argCount = 0;
				 while ((child = child.getNext()) != null) {
					 visitExpression(child, 0);
					 ++argCount;
				 }
				 int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL);
				 if (callType != Node.NON_SPECIALCALL) {
					 addIndexOp(Icode_CALLSPECIAL, argCount);
					 addUint8(callType);
					 addUint8(type == Token.NEW ? 1 : 0);
					 addUint16(itsLineNumber & 0xFFFF);
				 }
				 else {
					 if (type == Token.CALL) {
						 if ((contextFlags & ECF_TAIL) != 0) {
							 type = Icode_TAIL_CALL;
						 }
					 }
					 addIndexOp(type, argCount);
				 }
				 if (type == Token.NEW || type == Token.REF_CALL) {
					 stackChange(-argCount);
				 }
				 else {
					 stackChange(-1 - argCount);
				 }
				 if (argCount > itsData.itsMaxCalleeArgs) {
					 itsData.itsMaxCalleeArgs = argCount;
				 }
			 }
			 break;
			 case Token.AND: case Token.OR: {
				 visitExpression(child, 0);
				 addIcode(Icode_DUP);
				 stackChange(1);
				 int afterSecondJumpStart = itsICodeTop;
				 int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;
				 addForwardGoto(jump);
				 stackChange(-1);
				 addIcode(Icode_POP);
				 stackChange(-1);
				 child = child.getNext();
				 visitExpression(child, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterSecondJumpStart);
			 }
			 break;
			 case Token.HOOK: {
				 Node ifThen = child.getNext();
				 Node ifElse = ifThen.getNext();
				 visitExpression(child, 0);
				 int elseJumpStart = itsICodeTop;
				 addForwardGoto(Token.IFNE);
				 stackChange(-1);
				 visitExpression(ifThen, contextFlags & ECF_TAIL);
				 int afterElseJumpStart = itsICodeTop;
				 addForwardGoto(Token.GOTO);
				 resolveForwardGoto(elseJumpStart);
				 itsStackDepth = savedStackDepth;
				 visitExpression(ifElse, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterElseJumpStart);
			 }
			 break;
			 case Token.GETPROP: visitExpression(child, 0);
			 child = child.getNext();
			 addStringOp(Token.GETPROP, child.getString());
			 break;
			 case Token.GETELEM: case Token.DELPROP: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 addToken(type);
			 stackChange(-1);
			 break;
			 case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0);
			 if (type == Token.VOID) {
				 addIcode(Icode_POP);
				 addIcode(Icode_UNDEF);
			 }
			 else {
				 addToken(type);
			 }
			 break;
			 case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0);
			 addToken(type);
			 stackChange(-1);
			 break;
			 case Token.SETPROP: case Token.SETPROP_OP: {
				 visitExpression(child, 0);
				 child = child.getNext();
				 String property = child.getString();
				 child = child.getNext();
				 if (type == Token.SETPROP_OP) {
					 addIcode(Icode_DUP);
					 stackChange(1);
					 addStringOp(Token.GETPROP, property);
					 stackChange(-1);
				 }
				 visitExpression(child, 0);
				 addStringOp(Token.SETPROP, property);
				 stackChange(-1);
			 }
			 break;
			 case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SETELEM_OP) {
				 addIcode(Icode_DUP2);
				 stackChange(2);
				 addToken(Token.GETELEM);
				 stackChange(-1);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SETELEM);
			 stackChange(-2);
			 break;
			 case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SET_REF_OP) {
				 addIcode(Icode_DUP2);
				 stackChange(2);
				 addToken(Token.GET_REF);
				 stackChange(-1);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SET_REF);
			 stackChange(-2);
			 break;
			 case Token.SETNAME: {
				 String name = child.getString();
				 visitExpression(child, 0);
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringOp(Token.SETNAME, name);
				 stackChange(-1);
			 }
			 break;
			 case Token.TYPEOFNAME: {
				 String name = node.getString();
				 int index = -1;
				 if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getParamOrVarIndex(name);
				 if (index == -1) {
					 addStringOp(Icode_TYPEOFNAME, name);
					 stackChange(1);
				 }
				 else {
					 addVarOp(Token.GETVAR, index);
					 stackChange(1);
					 addToken(Token.TYPEOF);
				 }
			 }
			 break;
			 case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString());
			 stackChange(1);
			 break;
			 case Token.INC: case Token.DEC: visitIncDec(node, child);
			 break;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 int inum = (int)num;
				 if (inum == num) {
					 if (inum == 0) {
						 addIcode(Icode_ZERO);
						 if (1.0 / num < 0.0) {
							 addToken(Token.NEG);
						 }
					 }
					 else if (inum == 1) {
						 addIcode(Icode_ONE);
					 }
					 else if ((short)inum == inum) {
						 addIcode(Icode_SHORTNUMBER);
						 addUint16(inum & 0xFFFF);
					 }
					 else {
						 addIcode(Icode_INTNUMBER);
						 addInt(inum);
					 }
				 }
				 else {
					 int index = getDoubleIndex(num);
					 addIndexOp(Token.NUMBER, index);
				 }
				 stackChange(1);
			 }
			 break;
			 case Token.GETVAR: {
				 String name = node.getString();
				 if (itsData.itsNeedsActivation) {
					 addIcode(Icode_SCOPE);
					 stackChange(1);
					 addStringOp(Token.GETPROP, name);
				 }
				 else {
					 int index = scriptOrFn.getParamOrVarIndex(name);
					 addVarOp(Token.GETVAR, index);
					 stackChange(1);
				 }
			 }
			 break;
			 case Token.SETVAR: {
				 if (itsData.itsNeedsActivation) {
					 child.setType(Token.BINDNAME);
					 node.setType(Token.SETNAME);
					 visitExpression(node, 0);
				 }
				 else {
					 String name = child.getString();
					 child = child.getNext();
					 visitExpression(child, 0);
					 int index = scriptOrFn.getParamOrVarIndex(name);
					 addVarOp(Token.SETVAR, index);
				 }
			 }
			 break;
			 case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type);
			 stackChange(1);
			 break;
			 case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node));
			 stackChange(1);
			 break;
			 case Token.REGEXP: {
				 int index = node.getExistingIntProp(Node.REGEXP_PROP);
				 addIndexOp(Token.REGEXP, index);
				 stackChange(1);
			 }
			 break;
			 case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child);
			 break;
			 case Token.REF_SPECIAL: visitExpression(child, 0);
			 addStringOp(type, (String)node.getProp(Node.NAME_PROP));
			 stackChange(1);
			 expectedStackDelta = 2;
			 break;
			 case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: {
				 int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);
				 int childCount = 0;
				 do {
					 visitExpression(child, 0);
					 ++childCount;
					 child = child.getNext();
				 }
				 while (child != null);
				 addIndexOp(type, memberTypeFlags);
				 stackChange(2 - childCount);
				 expectedStackDelta = 2;
			 }
			 break;
			 case Token.DOTQUERY: {
				 int queryPC;
				 updateLineNumber(node);
				 visitExpression(child, 0);
				 addIcode(Icode_ENTERDQ);
				 stackChange(-1);
				 queryPC = itsICodeTop;
				 visitExpression(child.getNext(), 0);
				 addBackwardGoto(Icode_LEAVEDQ, queryPC);
			 }
			 break;
			 case Token.DEFAULTNAMESPACE : case Token.ESCXMLATTR : case Token.ESCXMLTEXT : visitExpression(child, 0);
			 addToken(type);
			 break;
			 default: throw badTree(node);
		 }
		 if (savedStackDepth + expectedStackDelta != itsStackDepth) {
			 Kit.codeBug();
		 }
	 }
	 private void generateCallFunAndThis(Node left) {
		 int type = left.getType();
		 switch (type) {
			 case Token.NAME: {
				 String name = left.getString();
				 addStringOp(Icode_NAME_AND_THIS, name);
				 stackChange(2);
				 break;
			 }
			 case Token.GETPROP: case Token.GETELEM: {
				 Node target = left.getFirstChild();
				 visitExpression(target, 0);
				 Node id = target.getNext();
				 if (type == Token.GETPROP) {
					 String property = id.getString();
					 addStringOp(Icode_PROP_AND_THIS, property);
					 stackChange(1);
				 }
				 else {
					 visitExpression(id, 0);
					 addIcode(Icode_ELEM_AND_THIS);
				 }
				 break;
			 }
			 default: visitExpression(left, 0);
			 addIcode(Icode_VALUE_AND_THIS);
			 stackChange(1);
			 break;
		 }
	 }
	 private void visitIncDec(Node node, Node child) {
		 int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);
		 int childType = child.getType();
		 switch (childType) {
			 case Token.GETVAR : {
				 String name = child.getString();
				 if (itsData.itsNeedsActivation) {
					 addIcode(Icode_SCOPE);
					 stackChange(1);
					 addStringOp(Icode_PROP_INC_DEC, name);
					 addUint8(incrDecrMask);
				 }
				 else {
					 int i = scriptOrFn.getParamOrVarIndex(name);
					 addVarOp(Icode_VAR_INC_DEC, i);
					 addUint8(incrDecrMask);
					 stackChange(1);
				 }
				 break;
			 }
			 case Token.NAME : {
				 String name = child.getString();
				 addStringOp(Icode_NAME_INC_DEC, name);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.GETPROP : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 String property = object.getNext().getString();
				 addStringOp(Icode_PROP_INC_DEC, property);
				 addUint8(incrDecrMask);
				 break;
			 }
			 case Token.GETELEM : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 Node index = object.getNext();
				 visitExpression(index, 0);
				 addIcode(Icode_ELEM_INC_DEC);
				 addUint8(incrDecrMask);
				 stackChange(-1);
				 break;
			 }
			 case Token.GET_REF : {
				 Node ref = child.getFirstChild();
				 visitExpression(ref, 0);
				 addIcode(Icode_REF_INC_DEC);
				 addUint8(incrDecrMask);
				 stackChange(-1);
				 break;
			 }
			 default : {
				 throw badTree(node);
			 }
		 }
	 }
	 private void visitLiteral(Node node, Node child) {
		 int type = node.getType();
		 int count;
		 Object[] propertyIds = null;
		 if (type == Token.ARRAYLIT) {
			 count = 0;
			 for (Node n = child;
			 n != null;
			 n = n.getNext()) {
				 ++count;
			 }
		 }
		 else if (type == Token.OBJECTLIT) {
			 propertyIds = (Object[])node.getProp(Node.OBJECT_IDS_PROP);
			 count = propertyIds.length;
		 }
		 else {
			 throw badTree(node);
		 }
		 addIndexOp(Icode_LITERAL_NEW, count);
		 stackChange(1);
		 while (child != null) {
			 visitExpression(child, 0);
			 addIcode(Icode_LITERAL_SET);
			 stackChange(-1);
			 child = child.getNext();
		 }
		 if (type == Token.ARRAYLIT) {
			 int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);
			 if (skipIndexes == null) {
				 addToken(Token.ARRAYLIT);
			 }
			 else {
				 int index = itsLiteralIds.size();
				 itsLiteralIds.add(skipIndexes);
				 addIndexOp(Icode_SPARE_ARRAYLIT, index);
			 }
		 }
		 else {
			 int index = itsLiteralIds.size();
			 itsLiteralIds.add(propertyIds);
			 addIndexOp(Token.OBJECTLIT, index);
		 }
	 }
	 private int getLocalBlockRef(Node node) {
		 Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
		 return localBlock.getExistingIntProp(Node.LOCAL_PROP);
	 }
	 private int getTargetLabel(Node target) {
		 int label = target.labelId();
		 if (label != -1) {
			 return label;
		 }
		 label = itsLabelTableTop;
		 if (itsLabelTable == null || label == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, label);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = label + 1;
		 itsLabelTable[label] = -1;
		 target.labelId(label);
		 return label;
	 }
	 private void markTargetLabel(Node target) {
		 int label = getTargetLabel(target);
		 if (itsLabelTable[label] != -1) {
			 Kit.codeBug();
		 }
		 itsLabelTable[label] = itsICodeTop;
	 }
	 private void addGoto(Node target, int gotoOp) {
		 int label = getTargetLabel(target);
		 if (!(label < itsLabelTableTop)) Kit.codeBug();
		 int targetPC = itsLabelTable[label];
		 int gotoPC = itsICodeTop;
		 if (validIcode(gotoOp)) {
			 addIcode(gotoOp);
		 }
		 else {
			 addToken(gotoOp);
		 }
		 if (targetPC != -1) {
			 recordJump(gotoPC, targetPC);
			 itsICodeTop += 2;
		 }
		 else {
			 addUint16(0);
			 int top = itsFixupTableTop;
			 if (itsFixupTable == null || top == itsFixupTable.length) {
				 if (itsFixupTable == null) {
					 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
				 }
				 else {
					 long[] tmp = new long[itsFixupTable.length * 2];
					 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
					 itsFixupTable = tmp;
				 }
			 }
			 itsFixupTableTop = top + 1;
			 itsFixupTable[top] = ((long)label << 32) | gotoPC;
		 }
	 }
	 private void fixLabelGotos() {
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int jumpSource = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw Kit.codeBug();
			 }
			 recordJump(jumpSource, pc);
		 }
		 itsFixupTableTop = 0;
	 }
	 private void addBackwardGoto(int gotoOp, int jumpPC) {
		 if (jumpPC >= itsICodeTop) throw Kit.codeBug();
		 int fromPC = itsICodeTop;
		 addIcode(gotoOp);
		 recordJump(fromPC, jumpPC);
		 itsICodeTop += 2;
	 }
	 private void addForwardGoto(int gotoOp) {
		 addToken(gotoOp);
		 addUint16(0);
	 }
	 private void resolveForwardGoto(int fromPC) {
		 if (fromPC + 3 > itsICodeTop) throw Kit.codeBug();
		 recordJump(fromPC, itsICodeTop);
	 }
	 private void recordJump(int jumpSource, int jumpDestination) {
		 if (jumpSource == jumpDestination) throw Kit.codeBug();
		 int offsetSite = jumpSource + 1;
		 int offset = jumpDestination - jumpSource;
		 if (offset != (short)offset) {
			 if (itsData.longJumps == null) {
				 itsData.longJumps = new UintMap();
			 }
			 itsData.longJumps.put(offsetSite, jumpDestination);
			 offset = 0;
		 }
		 itsData.itsICode[offsetSite] = (byte)(offset >> 8);
		 itsData.itsICode[offsetSite + 1] = (byte)offset;
	 }
	 private void addToken(int token) {
		 if (!validTokenCode(token)) throw Kit.codeBug();
		 addUint8(token);
	 }
	 private void addIcode(int icode) {
		 if (!validIcode(icode)) throw Kit.codeBug();
		 addUint8(icode & 0xFF);
	 }
	 private void addUint8(int value) {
		 if ((value & ~0xFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top == array.length) {
			 array = increaseICodeCapasity(1);
		 }
		 array[top] = (byte)value;
		 itsICodeTop = top + 1;
	 }
	 private void addUint16(int value) {
		 if ((value & ~0xFFFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 2 > array.length) {
			 array = increaseICodeCapasity(2);
		 }
		 array[top] = (byte)(value >>> 8);
		 array[top + 1] = (byte)value;
		 itsICodeTop = top + 2;
	 }
	 private void addInt(int i) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 4 > array.length) {
			 array = increaseICodeCapasity(4);
		 }
		 array[top] = (byte)(i >>> 24);
		 array[top + 1] = (byte)(i >>> 16);
		 array[top + 2] = (byte)(i >>> 8);
		 array[top + 3] = (byte)i;
		 itsICodeTop = top + 4;
	 }
	 private int getDoubleIndex(double num) {
		 int index = itsDoubleTableTop;
		 if (index == 0) {
			 itsData.itsDoubleTable = new double[64];
		 }
		 else if (itsData.itsDoubleTable.length == index) {
			 double[] na = new double[index * 2];
			 System.arraycopy(itsData.itsDoubleTable, 0, na, 0, index);
			 itsData.itsDoubleTable = na;
		 }
		 itsData.itsDoubleTable[index] = num;
		 itsDoubleTableTop = index + 1;
		 return index;
	 }
	 private void addVarOp(int op, int varIndex) {
		 switch (op) {
			 case Token.GETVAR: case Token.SETVAR: if (varIndex < 128) {
				 addIcode(op == Token.GETVAR ? Icode_GETVAR1 : Icode_SETVAR1);
				 addUint8(varIndex);
				 return;
			 }
			 case Icode_VAR_INC_DEC: addIndexOp(op, varIndex);
			 return;
		 }
		 throw Kit.codeBug();
	 }
	 private void addStringOp(int op, String str) {
		 addStringPrefix(str);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addIndexOp(int op, int index) {
		 addIndexPrefix(index);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addStringPrefix(String str) {
		 int index = itsStrings.get(str, -1);
		 if (index == -1) {
			 index = itsStrings.size();
			 itsStrings.put(str, index);
		 }
		 if (index < 4) {
			 addIcode(Icode_REG_STR_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_STR1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_STR2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_STR4);
			 addInt(index);
		 }
	 }
	 private void addIndexPrefix(int index) {
		 if (index < 0) Kit.codeBug();
		 if (index < 6) {
			 addIcode(Icode_REG_IND_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_IND1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_IND2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_IND4);
			 addInt(index);
		 }
	 }
	 private void addExceptionHandler(int icodeStart, int icodeEnd, int handlerStart, boolean isFinally, int exceptionObjectLocal, int scopeLocal) {
		 int top = itsExceptionTableTop;
		 int[] table = itsData.itsExceptionTable;
		 if (table == null) {
			 if (top != 0) Kit.codeBug();
			 table = new int[EXCEPTION_SLOT_SIZE * 2];
			 itsData.itsExceptionTable = table;
		 }
		 else if (table.length == top) {
			 table = new int[table.length * 2];
			 System.arraycopy(itsData.itsExceptionTable, 0, table, 0, top);
			 itsData.itsExceptionTable = table;
		 }
		 table[top + EXCEPTION_TRY_START_SLOT] = icodeStart;
		 table[top + EXCEPTION_TRY_END_SLOT] = icodeEnd;
		 table[top + EXCEPTION_HANDLER_SLOT] = handlerStart;
		 table[top + EXCEPTION_TYPE_SLOT] = isFinally ? 1 : 0;
		 table[top + EXCEPTION_LOCAL_SLOT] = exceptionObjectLocal;
		 table[top + EXCEPTION_SCOPE_SLOT] = scopeLocal;
		 itsExceptionTableTop = top + EXCEPTION_SLOT_SIZE;
	 }
	 private byte[] increaseICodeCapasity(int extraSize) {
		 int capacity = itsData.itsICode.length;
		 int top = itsICodeTop;
		 if (top + extraSize <= capacity) throw Kit.codeBug();
		 capacity *= 2;
		 if (top + extraSize > capacity) {
			 capacity = top + extraSize;
		 }
		 byte[] array = new byte[capacity];
		 System.arraycopy(itsData.itsICode, 0, array, 0, top);
		 itsData.itsICode = array;
		 return array;
	 }
	 private void stackChange(int change) {
		 if (change <= 0) {
			 itsStackDepth += change;
		 }
		 else {
			 int newDepth = itsStackDepth + change;
			 if (newDepth > itsData.itsMaxStack) {
				 itsData.itsMaxStack = newDepth;
			 }
			 itsStackDepth = newDepth;
		 }
	 }
	 private int allocLocal() {
		 int localSlot = itsLocalTop;
		 ++itsLocalTop;
		 if (itsLocalTop > itsData.itsMaxLocals) {
			 itsData.itsMaxLocals = itsLocalTop;
		 }
		 return localSlot;
	 }
	 private void releaseLocal(int localSlot) {
		 --itsLocalTop;
		 if (localSlot != itsLocalTop) Kit.codeBug();
	 }
	 private static int getShort(byte[] iCode, int pc) {
		 return (iCode[pc] << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getIndex(byte[] iCode, int pc) {
		 return ((iCode[pc] & 0xFF) << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getInt(byte[] iCode, int pc) {
		 return (iCode[pc] << 24) | ((iCode[pc + 1] & 0xFF) << 16) | ((iCode[pc + 2] & 0xFF) << 8) | (iCode[pc + 3] & 0xFF);
	 }
	 private static int getExceptionHandler(CallFrame frame, boolean onlyFinally) {
		 int[] exceptionTable = frame.idata.itsExceptionTable;
		 if (exceptionTable == null) {
			 return -1;
		 }
		 int pc = frame.pc - 1;
		 int best = -1, bestStart = 0, bestEnd = 0;
		 for (int i = 0;
		 i != exceptionTable.length;
		 i += EXCEPTION_SLOT_SIZE) {
			 int start = exceptionTable[i + EXCEPTION_TRY_START_SLOT];
			 int end = exceptionTable[i + EXCEPTION_TRY_END_SLOT];
			 if (!(start <= pc && pc < end)) {
				 continue;
			 }
			 if (onlyFinally && exceptionTable[i + EXCEPTION_TYPE_SLOT] != 1) {
				 continue;
			 }
			 if (best >= 0) {
				 if (bestEnd < end) {
					 continue;
				 }
				 if (bestStart > start) Kit.codeBug();
				 if (bestEnd == end) Kit.codeBug();
			 }
			 best = i;
			 bestStart = start;
			 bestEnd = end;
		 }
		 return best;
	 }
	 private static void dumpICode(InterpreterData idata) {
		 if (!Token.printICode) {
			 return;
		 }
		 byte iCode[] = idata.itsICode;
		 int iCodeLength = iCode.length;
		 String[] strings = idata.itsStringTable;
		 PrintStream out = System.out;
		 out.println(""ICode dump, for "" + idata.itsName + "", length = "" + iCodeLength);
		 out.println(""MaxStack = "" + idata.itsMaxStack);
		 int indexReg = 0;
		 for (int pc = 0;
		 pc < iCodeLength;
		 ) {
			 out.flush();
			 out.print("" ["" + pc + ""] "");
			 int token = iCode[pc];
			 int icodeLength = bytecodeSpan(token);
			 String tname = bytecodeName(token);
			 int old_pc = pc;
			 ++pc;
			 switch (token) {
				 default: if (icodeLength != 1) Kit.codeBug();
				 out.println(tname);
				 break;
				 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : {
					 int newPC = pc + getShort(iCode, pc) - 1;
					 out.println(tname + "" "" + newPC);
					 pc += 2;
					 break;
				 }
				 case Icode_VAR_INC_DEC : case Icode_NAME_INC_DEC : case Icode_PROP_INC_DEC : case Icode_ELEM_INC_DEC : case Icode_REF_INC_DEC: {
					 int incrDecrType = iCode[pc];
					 out.println(tname + "" "" + incrDecrType);
					 ++pc;
					 break;
				 }
				 case Icode_CALLSPECIAL : {
					 int callType = iCode[pc] & 0xFF;
					 boolean isNew = (iCode[pc + 1] != 0);
					 int line = getIndex(iCode, pc+2);
					 out.println(tname+"" ""+callType+"" ""+isNew+"" ""+indexReg+"" ""+line);
					 pc += 4;
					 break;
				 }
				 case Token.CATCH_SCOPE: {
					 boolean afterFisrtFlag = (iCode[pc] != 0);
					 out.println(tname+"" ""+afterFisrtFlag);
					 ++pc;
				 }
				 break;
				 case Token.REGEXP : out.println(tname+"" ""+idata.itsRegExpLiterals[indexReg]);
				 break;
				 case Token.OBJECTLIT : case Icode_SPARE_ARRAYLIT : out.println(tname+"" ""+idata.literalIds[indexReg]);
				 break;
				 case Icode_CLOSURE_EXPR : case Icode_CLOSURE_STMT : out.println(tname+"" ""+idata.itsNestedFunctions[indexReg]);
				 break;
				 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : case Token.NEW : out.println(tname+' '+indexReg);
				 break;
				 case Token.THROW : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_SHORTNUMBER : {
					 int value = getShort(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_INTNUMBER : {
					 int value = getInt(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 4;
					 break;
				 }
				 case Token.NUMBER : {
					 double value = idata.itsDoubleTable[indexReg];
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_LINE : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR1: {
					 String str = strings[0xFF & iCode[pc]];
					 out.println(tname + "" \"""" + str + '""');
					 ++pc;
					 break;
				 }
				 case Icode_REG_STR2: {
					 String str = strings[getIndex(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR4: {
					 String str = strings[getInt(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 4;
					 break;
				 }
				 case Icode_REG_IND1: {
					 indexReg = 0xFF & iCode[pc];
					 out.println(tname+"" ""+indexReg);
					 ++pc;
					 break;
				 }
				 case Icode_REG_IND2: {
					 indexReg = getIndex(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_IND4: {
					 indexReg = getInt(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 4;
					 break;
				 }
				 case Icode_GETVAR1: case Icode_SETVAR1: indexReg = iCode[pc];
				 out.println(tname+"" ""+indexReg);
				 ++pc;
				 break;
			 }
			 if (old_pc + icodeLength != pc) Kit.codeBug();
		 }
		 int[] table = idata.itsExceptionTable;
		 if (table != null) {
			 out.println(""Exception handlers: "" +table.length / EXCEPTION_SLOT_SIZE);
			 for (int i = 0;
			 i != table.length;
			 i += EXCEPTION_SLOT_SIZE) {
				 int tryStart = table[i + EXCEPTION_TRY_START_SLOT];
				 int tryEnd = table[i + EXCEPTION_TRY_END_SLOT];
				 int handlerStart = table[i + EXCEPTION_HANDLER_SLOT];
				 int type = table[i + EXCEPTION_TYPE_SLOT];
				 int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];
				 int scopeLocal = table[i + EXCEPTION_SCOPE_SLOT];
				 out.println("" tryStart=""+tryStart+"" tryEnd=""+tryEnd +"" handlerStart=""+handlerStart +"" type=""+(type == 0 ? ""catch"" : ""finally"") +"" exceptionLocal=""+exceptionLocal);
			 }
		 }
		 out.flush();
	 }
	 private static int bytecodeSpan(int bytecode) {
		 switch (bytecode) {
			 case Token.THROW : return 1 + 2;
			 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : return 1 + 2;
			 case Icode_CALLSPECIAL : return 1 + 1 + 1 + 2;
			 case Token.CATCH_SCOPE: return 1 + 1;
			 case Icode_VAR_INC_DEC: case Icode_NAME_INC_DEC: case Icode_PROP_INC_DEC: case Icode_ELEM_INC_DEC: case Icode_REF_INC_DEC: return 1 + 1;
			 case Icode_SHORTNUMBER : return 1 + 2;
			 case Icode_INTNUMBER : return 1 + 4;
			 case Icode_REG_IND1: return 1 + 1;
			 case Icode_REG_IND2: return 1 + 2;
			 case Icode_REG_IND4: return 1 + 4;
			 case Icode_REG_STR1: return 1 + 1;
			 case Icode_REG_STR2: return 1 + 2;
			 case Icode_REG_STR4: return 1 + 4;
			 case Icode_GETVAR1: case Icode_SETVAR1: return 1 + 1;
			 case Icode_LINE : return 1 + 2;
		 }
		 if (!validBytecode(bytecode)) throw Kit.codeBug();
		 return 1;
	 }
	 static int[] getLineNumbers(InterpreterData data) {
		 UintMap presentLines = new UintMap();
		 byte[] iCode = data.itsICode;
		 int iCodeLength = iCode.length;
		 for (int pc = 0;
		 pc != iCodeLength;
		) {
			 int bytecode = iCode[pc];
			 int span = bytecodeSpan(bytecode);
			 if (bytecode == Icode_LINE) {
				 if (span != 3) Kit.codeBug();
				 int line = getIndex(iCode, pc + 1);
				 presentLines.put(line, 0);
			 }
			 pc += span;
		 }
		 return presentLines.getKeys();
	 }
	 static String getSourcePositionFromStack(Context cx, int[] linep) {
		 CallFrame frame = (CallFrame)cx.interpreterLineCounting;
		 InterpreterData idata = frame.idata;
		 if (frame.pcSourceLineStart >= 0) {
			 linep[0] = getIndex(idata.itsICode, frame.pcSourceLineStart);
		 }
		 else {
			 linep[0] = 0;
		 }
		 return idata.itsSourceFile;
	 }
	 static String getEncodedSource(InterpreterData idata) {
		 if (idata.encodedSource == null) {
			 return null;
		 }
		 return idata.encodedSource.substring(idata.encodedSourceStart, idata.encodedSourceEnd);
	 }
	 private static void initFunction(Context cx, Scriptable scope, InterpretedFunction parent, int index) {
		 InterpretedFunction fn;
		 fn = InterpretedFunction.createFunction(cx, scope, parent, index);
		 ScriptRuntime.initFunction(cx, scope, fn, fn.idata.itsFunctionType, parent.idata.evalScriptFlag);
	 }
	 static Object interpret(InterpretedFunction ifun, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) {
			 return ScriptRuntime.doTopCall(ifun, cx, scope, thisObj, args);
		 }
		 if (cx.interpreterSecurityDomain != ifun.securityDomain) {
			 Object savedDomain = cx.interpreterSecurityDomain;
			 cx.interpreterSecurityDomain = ifun.securityDomain;
			 try {
				 return ifun.securityController.callWithDomain( ifun.securityDomain, cx, ifun, scope, thisObj, args);
			 }
			 finally {
				 cx.interpreterSecurityDomain = savedDomain;
			 }
		 }
		 CallFrame frame = new CallFrame();
		 initFrame(cx, scope, thisObj, args, null, 0, args.length, ifun, null, frame);
		 Object result;
		 try {
			 result = interpret(cx, frame, null);
		 }
		 finally {
			 cx.interpreterLineCounting = null;
		 }
		 return result;
	 }
	 public static Object restartContinuation(Continuation c, Context cx, Scriptable scope, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) {
			 return ScriptRuntime.doTopCall(c, cx, scope, null, args);
		 }
		 Object arg;
		 if (args.length == 0) {
			 arg = Undefined.instance;
		 }
		 else {
			 arg = args[0];
		 }
		 CallFrame capturedFrame = (CallFrame)c.getImplementation();
		 if (capturedFrame == null) {
			 return arg;
		 }
		 ContinuationJump cjump = new ContinuationJump(c, null);
		 cjump.result = arg;
		 return interpret(cx, null, cjump);
	 }
	 private static Object interpret(Context cx, CallFrame frame, Object throwable) {
		 final Object DBL_MRK = UniqueTag.DOUBLE_MARK;
		 final Scriptable undefined = Undefined.instance;
		 final boolean instructionCounting = (cx.instructionThreshold != 0);
		 final int INVOCATION_COST = 100;
		 final int EXCEPTION_COST = 100;
		 String stringReg = null;
		 int indexReg = -1;
		 if (throwable != null) {
			 if (!(throwable instanceof ContinuationJump)) {
				 Kit.codeBug();
			 }
		 }
		 StateLoop: for (;
		;
		) {
			 withoutExceptions: try {
				 if (throwable != null) {
					 if (indexReg >= 0) {
						 if (frame.frozen) {
							 frame = frame.cloneFrozen();
						 }
						 int[] table = frame.idata.itsExceptionTable;
						 frame.pc = table[indexReg + EXCEPTION_HANDLER_SLOT];
						 if (instructionCounting) {
							 frame.pcPrevBranch = frame.pc;
						 }
						 frame.savedStackTop = frame.emptyStackTop;
						 int scopeLocal = frame.localShift + table[indexReg + EXCEPTION_SCOPE_SLOT];
						 int exLocal = frame.localShift + table[indexReg + EXCEPTION_LOCAL_SLOT];
						 frame.scope = (Scriptable)frame.stack[scopeLocal];
						 frame.stack[exLocal] = throwable;
						 throwable = null;
					 }
					 else {
						 ContinuationJump cjump = (ContinuationJump)throwable;
						 throwable = null;
						 if (cjump.branchFrame != frame) Kit.codeBug();
						 if (cjump.capturedFrame == null) Kit.codeBug();
						 int rewindCount = cjump.capturedFrame.frameIndex + 1;
						 if (cjump.branchFrame != null) {
							 rewindCount -= cjump.branchFrame.frameIndex;
						 }
						 int enterCount = 0;
						 CallFrame[] enterFrames = null;
						 CallFrame x = cjump.capturedFrame;
						 for (int i = 0;
						 i != rewindCount;
						 ++i) {
							 if (!x.frozen) Kit.codeBug();
							 if (isFrameEnterExitRequired(x)) {
								 if (enterFrames == null) {
									 enterFrames = new CallFrame[rewindCount - i];
								 }
								 enterFrames[enterCount] = x;
								 ++enterCount;
							 }
							 x = x.parentFrame;
						 }
						 while (enterCount != 0) {
							 --enterCount;
							 x = enterFrames[enterCount];
							 enterFrame(cx, x, ScriptRuntime.emptyArgs);
						 }
						 frame = cjump.capturedFrame.cloneFrozen();
						 setCallResult(frame, cjump.result, cjump.resultDbl);
					 }
				 }
				 else {
					 if (frame.frozen) Kit.codeBug();
				 }
				 Object[] stack = frame.stack;
				 double[] sDbl = frame.sDbl;
				 Object[] vars = frame.varSource.stack;
				 double[] varDbls = frame.varSource.sDbl;
				 byte[] iCode = frame.idata.itsICode;
				 String[] strings = frame.idata.itsStringTable;
				 int stackTop = frame.savedStackTop;
				 cx.interpreterLineCounting = frame;
				 Loop: for (;
				;
				) {
					 int op = iCode[frame.pc++];
					 jumplessRun: {
						switch (op) {
							 case Token.THROW: {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int sourceLine = getIndex(iCode, frame.pc);
								 throwable = new JavaScriptException(value, frame.idata.itsSourceFile, sourceLine);
								 break withoutExceptions;
							 }
							 case Token.RETHROW: {
								 indexReg += frame.localShift;
								 throwable = stack[indexReg];
								 break withoutExceptions;
							 }
							 case Token.GE : case Token.LE : case Token.GT : case Token.LT : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 object_compare: {
									 number_compare: {
										 double rDbl, lDbl;
										 if (rhs == DBL_MRK) {
											 rDbl = sDbl[stackTop + 1];
											 lDbl = stack_double(frame, stackTop);
										 }
										 else if (lhs == DBL_MRK) {
											 rDbl = ScriptRuntime.toNumber(rhs);
											 lDbl = sDbl[stackTop];
										 }
										 else {
											 break number_compare;
										 }
										 switch (op) {
											 case Token.GE: valBln = (lDbl >= rDbl);
											 break object_compare;
											 case Token.LE: valBln = (lDbl <= rDbl);
											 break object_compare;
											 case Token.GT: valBln = (lDbl > rDbl);
											 break object_compare;
											 case Token.LT: valBln = (lDbl < rDbl);
											 break object_compare;
											 default: throw Kit.codeBug();
										 }
									 }
									 switch (op) {
										 case Token.GE: valBln = ScriptRuntime.cmp_LE(rhs, lhs);
										 break;
										 case Token.LE: valBln = ScriptRuntime.cmp_LE(lhs, rhs);
										 break;
										 case Token.GT: valBln = ScriptRuntime.cmp_LT(rhs, lhs);
										 break;
										 case Token.LT: valBln = ScriptRuntime.cmp_LT(lhs, rhs);
										 break;
										 default: throw Kit.codeBug();
									 }
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IN : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 boolean valBln = ScriptRuntime.in(lhs, rhs, cx, frame.scope);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.INSTANCEOF : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 boolean valBln = ScriptRuntime.instanceOf(lhs, rhs, cx, frame.scope);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.EQ : case Token.NE : {
								 --stackTop;
								 boolean valBln;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 if (rhs == DBL_MRK) {
									 if (lhs == DBL_MRK) {
										 valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
									 }
									 else {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
									 }
								 }
								 else {
									 if (lhs == DBL_MRK) {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
									 }
									 else {
										 valBln = ScriptRuntime.eq(lhs, rhs);
									 }
								 }
								 valBln ^= (op == Token.NE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.SHEQ : case Token.SHNE : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 shallow_compare: {
									 double rdbl, ldbl;
									 if (rhs == DBL_MRK) {
										 rdbl = sDbl[stackTop + 1];
										 if (lhs == DBL_MRK) {
											 ldbl = sDbl[stackTop];
										 }
										 else if (lhs instanceof Number) {
											 ldbl = ((Number)lhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else if (lhs == DBL_MRK) {
										 ldbl = sDbl[stackTop];
										 if (rhs == DBL_MRK) {
											 rdbl = sDbl[stackTop + 1];
										 }
										 else if (rhs instanceof Number) {
											 rdbl = ((Number)rhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else {
										 valBln = ScriptRuntime.shallowEq(lhs, rhs);
										 break shallow_compare;
									 }
									 valBln = (ldbl == rdbl);
								 }
								 valBln ^= (op == Token.SHNE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IFNE : if (stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Token.IFEQ : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Icode_IFEQ_POP : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 stack[stackTop--] = null;
							 break jumplessRun;
							 case Token.GOTO : break jumplessRun;
							 case Icode_GOSUB : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.pc + 2;
							 break jumplessRun;
							 case Icode_STARTSUB : if (stackTop == frame.emptyStackTop + 1) {
								 indexReg += frame.localShift;
								 stack[indexReg] = stack[stackTop];
								 sDbl[indexReg] = sDbl[stackTop];
								 --stackTop;
							 }
							 else {
								 if (stackTop != frame.emptyStackTop) Kit.codeBug();
							 }
							 continue Loop;
							 case Icode_RETSUB : {
								 if (instructionCounting) {
									 addInstructionCount(cx, frame, 0);
								 }
								 indexReg += frame.localShift;
								 Object value = stack[indexReg];
								 if (value != DBL_MRK) {
									 throwable = value;
									 break withoutExceptions;
								 }
								 frame.pc = (int)sDbl[indexReg];
								 if (instructionCounting) {
									 frame.pcPrevBranch = frame.pc;
								 }
								 continue Loop;
							 }
							 case Icode_POP : stack[stackTop] = null;
							 stackTop--;
							 continue Loop;
							 case Icode_POP_RESULT : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 stack[stackTop] = null;
							 --stackTop;
							 continue Loop;
							 case Icode_DUP : stack[stackTop + 1] = stack[stackTop];
							 sDbl[stackTop + 1] = sDbl[stackTop];
							 stackTop++;
							 continue Loop;
							 case Icode_DUP2 : stack[stackTop + 1] = stack[stackTop - 1];
							 sDbl[stackTop + 1] = sDbl[stackTop - 1];
							 stack[stackTop + 2] = stack[stackTop];
							 sDbl[stackTop + 2] = sDbl[stackTop];
							 stackTop += 2;
							 continue Loop;
							 case Icode_SWAP : {
								 Object o = stack[stackTop];
								 stack[stackTop] = stack[stackTop - 1];
								 stack[stackTop - 1] = o;
								 double d = sDbl[stackTop];
								 sDbl[stackTop] = sDbl[stackTop - 1];
								 sDbl[stackTop - 1] = d;
								 continue Loop;
							 }
							 case Token.RETURN : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 --stackTop;
							 break Loop;
							 case Token.RETURN_RESULT : break Loop;
							 case Icode_RETUNDEF : frame.result = undefined;
							 break Loop;
							 case Token.BITNOT : {
								 int rIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ~rIntValue;
								 continue Loop;
							 }
							 case Token.BITAND : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lIntValue & rIntValue;
								 continue Loop;
							 }
							 case Token.BITOR : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lIntValue | rIntValue;
								 continue Loop;
							 }
							 case Token.BITXOR : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lIntValue ^ rIntValue;
								 continue Loop;
							 }
							 case Token.LSH : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lIntValue << rIntValue;
								 continue Loop;
							 }
							 case Token.RSH : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lIntValue >> rIntValue;
								 continue Loop;
							 }
							 case Token.URSH : {
								 int rIntValue = stack_int32(frame, stackTop) & 0x1F;
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;
								 continue Loop;
							 }
							 case Token.NEG : {
								 double rDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = -rDbl;
								 continue Loop;
							 }
							 case Token.POS : {
								 double rDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = rDbl;
								 continue Loop;
							 }
							 case Token.ADD : --stackTop;
							 do_add(stack, sDbl, stackTop, cx);
							 continue Loop;
							 case Token.SUB : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lDbl - rDbl;
								 continue Loop;
							 }
							 case Token.MUL : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lDbl * rDbl;
								 continue Loop;
							 }
							 case Token.DIV : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lDbl / rDbl;
								 continue Loop;
							 }
							 case Token.MOD : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = lDbl % rDbl;
								 continue Loop;
							 }
							 case Token.NOT : stack[stackTop] = ScriptRuntime.wrapBoolean( !stack_boolean(frame, stackTop));
							 continue Loop;
							 case Token.BINDNAME : stack[++stackTop] = ScriptRuntime.bind(cx, frame.scope, stringReg);
							 continue Loop;
							 case Token.SETNAME : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable lhs = (Scriptable)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx, frame.scope, stringReg);
								 continue Loop;
							 }
							 case Token.DELPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.delete(lhs, rhs, cx);
								 continue Loop;
							 }
							 case Token.GETPROP : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getObjectProp(lhs, stringReg, cx);
								 continue Loop;
							 }
							 case Token.SETPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setObjectProp(lhs, stringReg, rhs, cx);
								 continue Loop;
							 }
							 case Icode_PROP_INC_DEC : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.propIncrDecr(lhs, stringReg, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GETELEM : {
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.getObjectElem(lhs, id, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.getObjectIndex(lhs, d, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Token.SETELEM : {
								 stackTop -= 2;
								 Object rhs = stack[stackTop + 2];
								 if (rhs == DBL_MRK) {
									 rhs = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);
								 }
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.setObjectElem(lhs, id, rhs, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.setObjectIndex(lhs, d, rhs, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Icode_ELEM_INC_DEC: {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.elemIncrDecr(lhs, rhs, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GET_REF : {
								 Scriptable target = (Scriptable)stack[stackTop];
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refGet(ref, target, cx);
								 continue Loop;
							 }
							 case Token.SET_REF : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable target = (Scriptable)stack[stackTop];
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refSet(ref, target, value, cx);
								 continue Loop;
							 }
							 case Token.DEL_REF : {
								 Scriptable target = (Scriptable)stack[stackTop];
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refDel(ref, target, cx);
								 continue Loop;
							 }
							 case Icode_REF_INC_DEC : {
								 Scriptable target = (Scriptable)stack[stackTop];
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refIncrDecr(ref, target, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.LOCAL_LOAD : ++stackTop;
							 indexReg += frame.localShift;
							 stack[stackTop] = stack[indexReg];
							 sDbl[stackTop] = sDbl[indexReg];
							 continue Loop;
							 case Icode_LOCAL_CLEAR : indexReg += frame.localShift;
							 stack[indexReg] = null;
							 continue Loop;
							 case Icode_NAME_AND_THIS : ++stackTop;
							 stack[stackTop] = ScriptRuntime.getNameFunctionAndThis(stringReg, cx, frame.scope);
							 ++stackTop;
							 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
							 continue Loop;
							 case Icode_PROP_AND_THIS: {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getPropFunctionAndThis(obj, stringReg, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_ELEM_AND_THIS: {
								 Object obj = stack[stackTop - 1];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop - 1]);
								 Object id = stack[stackTop];
								 if (id == DBL_MRK) id = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop - 1] = ScriptRuntime.getElemFunctionAndThis(obj, id, cx);
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_VALUE_AND_THIS : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getValueFunctionAndThis(value, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_CALLSPECIAL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 int callType = iCode[frame.pc] & 0xFF;
								 boolean isNew = (iCode[frame.pc + 1] != 0);
								 int sourceLine = getIndex(iCode, frame.pc + 2);
								 if (isNew) {
									 stackTop -= indexReg;
									 Object function = stack[stackTop];
									 if (function == DBL_MRK) function = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 1, indexReg);
									 stack[stackTop] = ScriptRuntime.newSpecial( cx, function, outArgs, frame.scope, callType);
								 }
								 else {
									 stackTop -= 1 + indexReg;
									 Scriptable functionThis = (Scriptable)stack[stackTop + 1];
									 Function function = (Function)stack[stackTop];
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callSpecial( cx, function, functionThis, outArgs, frame.scope, frame.thisObj, callType, frame.idata.itsSourceFile, sourceLine);
								 }
								 frame.pc += 4;
								 continue Loop;
							 }
							 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= 1 + indexReg;
								 Function fun = (Function)stack[stackTop];
								 Scriptable funThisObj = (Scriptable)stack[stackTop + 1];
								 Scriptable calleeScope = frame.scope;
								 if (frame.useActivation) {
									 calleeScope = ScriptableObject.getTopLevelScope(frame.scope);
								 }
								 if (op == Token.REF_CALL) {
									 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callRef(fun, funThisObj, outArgs, cx, calleeScope);
									 ++stackTop;
									 stack[stackTop] = Ref.popTarget(cx);
									 continue Loop;
								 }
								 if (fun instanceof InterpretedFunction) {
									 InterpretedFunction ifun = (InterpretedFunction)fun;
									 if (frame.fnOrScript.securityDomain == ifun.securityDomain) {
										 CallFrame callParentFrame = frame;
										 CallFrame calleeFrame = new CallFrame();
										 if (op == Icode_TAIL_CALL) {
											 callParentFrame = frame.parentFrame;
										 }
										 initFrame(cx, calleeScope, funThisObj, stack, sDbl, stackTop + 2, indexReg, ifun, callParentFrame, calleeFrame);
										 if (op == Icode_TAIL_CALL) {
											 exitFrame(cx, frame, null);
										 }
										 else {
											 frame.savedStackTop = stackTop;
											 frame.savedCallOp = op;
										 }
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (fun instanceof Continuation) {
									 ContinuationJump cjump;
									 cjump = new ContinuationJump((Continuation)fun, frame);
									 if (indexReg == 0) {
										 cjump.result = undefined;
									 }
									 else {
										 cjump.result = stack[stackTop + 2];
										 cjump.resultDbl = sDbl[stackTop + 2];
									 }
									 throwable = cjump;
									 break withoutExceptions;
								 }
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
								 stack[stackTop] = fun.call(cx, calleeScope, funThisObj, outArgs);
								 continue Loop;
							 }
							 case Token.NEW : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= indexReg;
								 Object lhs = stack[stackTop];
								 if (lhs instanceof InterpretedFunction) {
									 InterpretedFunction f = (InterpretedFunction)lhs;
									 if (frame.fnOrScript.securityDomain == f.securityDomain) {
										 Scriptable newInstance = f.createObject(cx, frame.scope);
										 CallFrame calleeFrame = new CallFrame();
										 initFrame(cx, frame.scope, newInstance, stack, sDbl, stackTop + 1, indexReg, f, frame, calleeFrame);
										 stack[stackTop] = newInstance;
										 frame.savedStackTop = stackTop;
										 frame.savedCallOp = op;
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (!(lhs instanceof Function)) {
									 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 throw ScriptRuntime.notFunctionError(lhs);
								 }
								 Function fun = (Function)lhs;
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 1, indexReg);
								 stack[stackTop] = fun.construct(cx, frame.scope, outArgs);
								 continue Loop;
							 }
							 case Token.TYPEOF : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.typeof(lhs);
								 continue Loop;
							 }
							 case Icode_TYPEOFNAME : stack[++stackTop] = ScriptRuntime.typeofName(frame.scope, stringReg);
							 continue Loop;
							 case Token.STRING : stack[++stackTop] = stringReg;
							 continue Loop;
							 case Icode_SHORTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getShort(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_INTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Token.NUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.idata.itsDoubleTable[indexReg];
							 continue Loop;
							 case Token.NAME : stack[++stackTop] = ScriptRuntime.name(cx, frame.scope, stringReg);
							 continue Loop;
							 case Icode_NAME_INC_DEC : stack[++stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, stringReg, iCode[frame.pc]);
							 ++frame.pc;
							 continue Loop;
							 case Icode_SETVAR1: indexReg = iCode[frame.pc++];
							 case Token.SETVAR : if (!frame.useActivation) {
								 vars[indexReg] = stack[stackTop];
								 varDbls[indexReg] = sDbl[stackTop];
							 }
							 else {
								 Object val = stack[stackTop];
								 if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stringReg = frame.idata.argNames[indexReg];
								 frame.scope.put(stringReg, frame.scope, val);
							 }
							 continue Loop;
							 case Icode_GETVAR1: indexReg = iCode[frame.pc++];
							 case Token.GETVAR : ++stackTop;
							 if (!frame.useActivation) {
								 stack[stackTop] = vars[indexReg];
								 sDbl[stackTop] = varDbls[indexReg];
							 }
							 else {
								 stringReg = frame.idata.argNames[indexReg];
								 stack[stackTop] = frame.scope.get(stringReg, frame.scope);
							 }
							 continue Loop;
							 case Icode_VAR_INC_DEC : {
								 ++stackTop;
								 int incrDecrMask = iCode[frame.pc];
								 if (!frame.useActivation) {
									 stack[stackTop] = DBL_MRK;
									 Object varValue = vars[indexReg];
									 double d;
									 if (varValue == DBL_MRK) {
										 d = varDbls[indexReg];
									 }
									 else {
										 d = ScriptRuntime.toNumber(varValue);
										 vars[indexReg] = DBL_MRK;
									 }
									 double d2 = ((incrDecrMask & Node.DECR_FLAG) == 0) ? d + 1.0 : d - 1.0;
									 varDbls[indexReg] = d2;
									 sDbl[stackTop] = ((incrDecrMask & Node.POST_FLAG) == 0) ? d2 : d;
								 }
								 else {
									 String varName = frame.idata.argNames[indexReg];
									 stack[stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, varName, incrDecrMask);
								 }
								 ++frame.pc;
								 continue Loop;
							 }
							 case Icode_ZERO : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_ONE : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 1;
							 continue Loop;
							 case Token.NULL : stack[++stackTop] = null;
							 continue Loop;
							 case Token.THIS : stack[++stackTop] = frame.thisObj;
							 continue Loop;
							 case Token.THISFN : stack[++stackTop] = frame.fnOrScript;
							 continue Loop;
							 case Token.FALSE : stack[++stackTop] = Boolean.FALSE;
							 continue Loop;
							 case Token.TRUE : stack[++stackTop] = Boolean.TRUE;
							 continue Loop;
							 case Icode_UNDEF : stack[++stackTop] = undefined;
							 continue Loop;
							 case Token.ENTERWITH : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterWith(lhs, cx, frame.scope);
								 continue Loop;
							 }
							 case Token.LEAVEWITH : frame.scope = ScriptRuntime.leaveWith(frame.scope);
							 continue Loop;
							 case Token.CATCH_SCOPE : {
								 --stackTop;
								 indexReg += frame.localShift;
								 boolean afterFirstScope = (frame.idata.itsICode[frame.pc] != 0);
								 Throwable caughtException = (Throwable)stack[stackTop + 1];
								 Scriptable lastCatchScope;
								 if (!afterFirstScope) {
									 lastCatchScope = null;
								 }
								 else {
									 lastCatchScope = (Scriptable)stack[indexReg];
								 }
								 stack[indexReg] = ScriptRuntime.newCatchScope(caughtException, lastCatchScope, stringReg, cx, frame.scope);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.ENUM_INIT_KEYS : case Token.ENUM_INIT_VALUES : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 indexReg += frame.localShift;
								 stack[indexReg] = ScriptRuntime.enumInit( lhs, cx, (op == Token.ENUM_INIT_VALUES));
								 continue Loop;
							 }
							 case Token.ENUM_NEXT : case Token.ENUM_ID : {
								 indexReg += frame.localShift;
								 Object val = stack[indexReg];
								 ++stackTop;
								 stack[stackTop] = (op == Token.ENUM_NEXT) ? (Object)ScriptRuntime.enumNext(val) : (Object)ScriptRuntime.enumId(val, cx);
								 continue Loop;
							 }
							 case Token.REF_SPECIAL : {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.specialRef(obj, stringReg, cx);
								 ++stackTop;
								 stack[stackTop] = Ref.popTarget(cx);
								 continue Loop;
							 }
							 case Token.REF_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, elem, cx, indexReg);
								 ++stackTop;
								 stack[stackTop] = Ref.popTarget(cx);
								 continue Loop;
							 }
							 case Token.REF_NS_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, ns, elem, cx, indexReg);
								 ++stackTop;
								 stack[stackTop] = Ref.popTarget(cx);
								 continue Loop;
							 }
							 case Token.REF_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(name, cx, frame.scope, indexReg);
								 ++stackTop;
								 stack[stackTop] = Ref.popTarget(cx);
								 continue Loop;
							 }
							 case Token.REF_NS_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(ns, name, cx, frame.scope, indexReg);
								 ++stackTop;
								 stack[stackTop] = Ref.popTarget(cx);
								 continue Loop;
							 }
							 case Icode_SCOPE : stack[++stackTop] = frame.scope;
							 continue Loop;
							 case Icode_SCOPE_LOAD : indexReg += frame.localShift;
							 frame.scope = (Scriptable)stack[indexReg];
							 continue Loop;
							 case Icode_SCOPE_SAVE : indexReg += frame.localShift;
							 stack[indexReg] = frame.scope;
							 continue Loop;
							 case Icode_CLOSURE_EXPR : stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Icode_CLOSURE_STMT : initFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Token.REGEXP : stack[++stackTop] = frame.scriptRegExps[indexReg];
							 continue Loop;
							 case Icode_LITERAL_NEW : ++stackTop;
							 stack[stackTop] = new Object[indexReg];
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_LITERAL_SET : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Token.ARRAYLIT : case Icode_SPARE_ARRAYLIT : case Token.OBJECTLIT : {
								 Object[] data = (Object[])stack[stackTop];
								 Object val;
								 if (op == Token.OBJECTLIT) {
									 Object[] ids = (Object[])frame.idata.literalIds[indexReg];
									 val = ScriptRuntime.newObjectLiteral(ids, data, cx, frame.scope);
								 }
								 else {
									 int[] skipIndexces = null;
									 if (op == Icode_SPARE_ARRAYLIT) {
										 skipIndexces = (int[])frame.idata.literalIds[indexReg];
									 }
									 val = ScriptRuntime.newArrayLiteral(data, skipIndexces, cx, frame.scope);
								 }
								 stack[stackTop] = val;
								 continue Loop;
							 }
							 case Icode_ENTERDQ : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterDotQuery(lhs, frame.scope);
								 continue Loop;
							 }
							 case Icode_LEAVEDQ : {
								 boolean valBln = stack_boolean(frame, stackTop);
								 Object x = ScriptRuntime.updateDotQuery(valBln, frame.scope);
								 if (x != null) {
									 stack[stackTop] = x;
									 frame.scope = ScriptRuntime.leaveDotQuery(frame.scope);
									 frame.pc += 2;
									 continue Loop;
								 }
								 --stackTop;
								 break jumplessRun;
							 }
							 case Token.DEFAULTNAMESPACE : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setDefaultNamespace(value, cx);
								 continue Loop;
							 }
							 case Token.ESCXMLATTR : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeAttributeValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Token.ESCXMLTEXT : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeTextValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Icode_LINE : frame.pcSourceLineStart = frame.pc;
							 if (frame.debuggerFrame != null) {
								 int line = getIndex(iCode, frame.pc);
								 frame.debuggerFrame.onLineChange(cx, line);
							 }
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND_C0: indexReg = 0;
							 continue Loop;
							 case Icode_REG_IND_C1: indexReg = 1;
							 continue Loop;
							 case Icode_REG_IND_C2: indexReg = 2;
							 continue Loop;
							 case Icode_REG_IND_C3: indexReg = 3;
							 continue Loop;
							 case Icode_REG_IND_C4: indexReg = 4;
							 continue Loop;
							 case Icode_REG_IND_C5: indexReg = 5;
							 continue Loop;
							 case Icode_REG_IND1: indexReg = 0xFF & iCode[frame.pc];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_IND2: indexReg = getIndex(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND4: indexReg = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Icode_REG_STR_C0: stringReg = strings[0];
							 continue Loop;
							 case Icode_REG_STR_C1: stringReg = strings[1];
							 continue Loop;
							 case Icode_REG_STR_C2: stringReg = strings[2];
							 continue Loop;
							 case Icode_REG_STR_C3: stringReg = strings[3];
							 continue Loop;
							 case Icode_REG_STR1: stringReg = strings[0xFF & iCode[frame.pc]];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_STR2: stringReg = strings[getIndex(iCode, frame.pc)];
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_STR4: stringReg = strings[getInt(iCode, frame.pc)];
							 frame.pc += 4;
							 continue Loop;
							 default : dumpICode(frame.idata);
							 throw new RuntimeException( ""Unknown icode : ""+op+"" @ pc : ""+(frame.pc-1));
						}
					 }
					 if (instructionCounting) {
						 addInstructionCount(cx, frame, 2);
					 }
					 int offset = getShort(iCode, frame.pc);
					 if (offset != 0) {
						 frame.pc += offset - 1;
					 }
					 else {
						 frame.pc = frame.idata.longJumps. getExistingInt(frame.pc);
					 }
					 if (instructionCounting) {
						 frame.pcPrevBranch = frame.pc;
					 }
					 continue Loop;
				 }
				 exitFrame(cx, frame, null);
				 Object callResult = frame.result;
				 double callResultDbl = frame.resultDbl;
				 if (frame.parentFrame != null) {
					 frame = frame.parentFrame;
					 if (frame.frozen) {
						 frame = frame.cloneFrozen();
					 }
					 setCallResult(frame, callResult, callResultDbl);
					 continue StateLoop;
				 }
				 return (callResult != DBL_MRK) ? callResult : ScriptRuntime.wrapNumber(callResultDbl);
			 }
			 catch (Throwable ex) {
				 if (throwable != null) {
					 ex.printStackTrace(System.err);
					 throw new IllegalStateException();
				 }
				 throwable = ex;
			 }
			 if (throwable == null) Kit.codeBug();
			 final int EX_CATCH_STATE = 2;
			 final int EX_FINALLY_STATE = 1;
			 final int EX_NO_JS_STATE = 0;
			 int exState;
			 ContinuationJump cjump = null;
			 if (throwable instanceof JavaScriptException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EcmaError) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EvaluatorException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof RuntimeException) {
				 exState = EX_FINALLY_STATE;
			 }
			 else if (throwable instanceof Error) {
				 exState = EX_NO_JS_STATE;
			 }
			 else {
				 exState = EX_FINALLY_STATE;
				 cjump = (ContinuationJump)throwable;
			 }
			 if (instructionCounting) {
				 try {
					 addInstructionCount(cx, frame, EXCEPTION_COST);
				 }
				 catch (RuntimeException ex) {
					 throwable = ex;
					 exState = EX_FINALLY_STATE;
				 }
				 catch (Error ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 if (frame.debuggerFrame != null && throwable instanceof RuntimeException) {
				 RuntimeException rex = (RuntimeException)throwable;
				 try {
					 frame.debuggerFrame.onExceptionThrown(cx, rex);
				 }
				 catch (Throwable ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 for (;
			;
			) {
				 if (exState != EX_NO_JS_STATE) {
					 boolean onlyFinally = (exState != EX_CATCH_STATE);
					 indexReg = getExceptionHandler(frame, onlyFinally);
					 if (indexReg >= 0) {
						 continue StateLoop;
					 }
				 }
				 exitFrame(cx, frame, throwable);
				 frame = frame.parentFrame;
				 if (frame == null) {
					 break;
				 }
				 if (cjump != null && cjump.branchFrame == frame) {
					 indexReg = -1;
					 continue StateLoop;
				 }
			 }
			 if (cjump != null) {
				 if (cjump.branchFrame != null) {
					 Kit.codeBug();
				 }
				 if (cjump.capturedFrame != null) {
					 indexReg = -1;
					 continue StateLoop;
				 }
				 return (cjump.result != DBL_MRK) ? cjump.result : ScriptRuntime.wrapNumber(cjump.resultDbl);
			 }
			 if (throwable instanceof RuntimeException) {
				 throw (RuntimeException)throwable;
			 }
			 else {
				 throw (Error)throwable;
			 }
		 }
	 }
	 private static void initFrame(Context cx, Scriptable callerScope, Scriptable thisObj, Object[] args, double[] argsDbl, int argShift, int argCount, InterpretedFunction fnOrScript, CallFrame parentFrame, CallFrame frame) {
		 InterpreterData idata = fnOrScript.idata;
		 boolean useActivation = idata.itsNeedsActivation;
		 DebugFrame debuggerFrame = null;
		 if (cx.debugger != null) {
			 debuggerFrame = cx.debugger.getFrame(cx, idata);
			 if (debuggerFrame != null) {
				 useActivation = true;
			 }
		 }
		 if (useActivation) {
			 if (argsDbl != null) {
				 args = getArgsArray(args, argsDbl, argShift, argCount);
			 }
			 argShift = 0;
			 argsDbl = null;
		 }
		 Scriptable scope;
		 if (idata.itsFunctionType != 0) {
			 if (!idata.useDynamicScope) {
				 scope = fnOrScript.getParentScope();
			 }
			 else {
				 scope = callerScope;
			 }
			 if (useActivation) {
				 scope = ScriptRuntime.createFunctionActivation( fnOrScript, scope, args);
			 }
		 }
		 else {
			 scope = callerScope;
			 ScriptRuntime.initScript(fnOrScript, thisObj, cx, scope, fnOrScript.idata.evalScriptFlag);
		 }
		 if (idata.itsNestedFunctions != null) {
			 if (idata.itsFunctionType != 0 && !idata.itsNeedsActivation) Kit.codeBug();
			 for (int i = 0;
			 i < idata.itsNestedFunctions.length;
			 i++) {
				 InterpreterData fdata = idata.itsNestedFunctions[i];
				 if (fdata.itsFunctionType == FunctionNode.FUNCTION_STATEMENT) {
					 initFunction(cx, scope, fnOrScript, i);
				 }
			 }
		 }
		 Scriptable[] scriptRegExps = null;
		 if (idata.itsRegExpLiterals != null) {
			 if (idata.itsFunctionType != 0) {
				 scriptRegExps = fnOrScript.functionRegExps;
			 }
			 else {
				 scriptRegExps = fnOrScript.createRegExpWraps(cx, scope);
			 }
		 }
		 int emptyStackTop = idata.itsMaxVars + idata.itsMaxLocals - 1;
		 int maxFrameArray = idata.itsMaxFrameArray;
		 if (maxFrameArray != emptyStackTop + idata.itsMaxStack + 1) Kit.codeBug();
		 Object[] stack;
		 double[] sDbl;
		 boolean stackReuse;
		 if (frame.stack != null && maxFrameArray <= frame.stack.length) {
			 stackReuse = true;
			 stack = frame.stack;
			 sDbl = frame.sDbl;
		 }
		 else {
			 stackReuse = false;
			 stack = new Object[maxFrameArray];
			 sDbl = new double[maxFrameArray];
		 }
		 int definedArgs = idata.argCount;
		 if (definedArgs > argCount) {
			 definedArgs = argCount;
		 }
		 frame.parentFrame = parentFrame;
		 frame.frameIndex = (parentFrame == null) ? 0 : parentFrame.frameIndex + 1;
		 frame.frozen = false;
		 frame.fnOrScript = fnOrScript;
		 frame.idata = idata;
		 frame.stack = stack;
		 frame.sDbl = sDbl;
		 frame.varSource = frame;
		 frame.localShift = idata.itsMaxVars;
		 frame.emptyStackTop = emptyStackTop;
		 frame.debuggerFrame = debuggerFrame;
		 frame.useActivation = useActivation;
		 frame.thisObj = thisObj;
		 frame.scriptRegExps = scriptRegExps;
		 frame.result = Undefined.instance;
		 frame.pc = 0;
		 frame.pcPrevBranch = 0;
		 frame.pcSourceLineStart = idata.firstLinePC;
		 frame.scope = scope;
		 frame.savedStackTop = emptyStackTop;
		 frame.savedCallOp = 0;
		 System.arraycopy(args, argShift, stack, 0, definedArgs);
		 if (argsDbl != null) {
			 System.arraycopy(argsDbl, argShift, sDbl, 0, definedArgs);
		 }
		 for (int i = definedArgs;
		 i != idata.itsMaxVars;
		 ++i) {
			 stack[i] = Undefined.instance;
		 }
		 if (stackReuse) {
			 for (int i = emptyStackTop + 1;
			 i != stack.length;
			 ++i) {
				 stack[i] = null;
			 }
		 }
		 enterFrame(cx, frame, args);
	 }
	 private static boolean isFrameEnterExitRequired(CallFrame frame) {
		 return frame.debuggerFrame != null || frame.idata.itsNeedsActivation;
	 }
	 private static void enterFrame(Context cx, CallFrame frame, Object[] args) {
		 if (frame.debuggerFrame != null) {
			 frame.debuggerFrame.onEnter(cx, frame.scope, frame.thisObj, args);
		 }
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.enterActivationFunction(cx, frame.scope);
		 }
	 }
	 private static void exitFrame(Context cx, CallFrame frame, Object throwable) {
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.exitActivationFunction(cx);
		 }
		 if (frame.debuggerFrame != null) {
			 try {
				 if (throwable instanceof Throwable) {
					 frame.debuggerFrame.onExit(cx, true, (Throwable)throwable);
				 }
				 else {
					 Object result;
					 ContinuationJump cjump = (ContinuationJump)throwable;
					 if (cjump == null) {
						 result = frame.result;
					 }
					 else {
						 result = cjump.result;
					 }
					 if (result == UniqueTag.DOUBLE_MARK) {
						 double resultDbl;
						 if (cjump == null) {
							 resultDbl = frame.resultDbl;
						 }
						 else {
							 resultDbl = cjump.resultDbl;
						 }
						 result = ScriptRuntime.wrapNumber(resultDbl);
					 }
					 frame.debuggerFrame.onExit(cx, false, result);
				 }
			 }
			 catch (Throwable ex) {
				 System.err.println(""RHINO USAGE WARNING: onExit terminated with exception"");
				 ex.printStackTrace(System.err);
			 }
		 }
	 }
	 private static void setCallResult(CallFrame frame, Object callResult, double callResultDbl) {
		 if (frame.savedCallOp == Token.CALL) {
			 frame.stack[frame.savedStackTop] = callResult;
			 frame.sDbl[frame.savedStackTop] = callResultDbl;
		 }
		 else if (frame.savedCallOp == Token.NEW) {
			 if (callResult instanceof Scriptable && callResult != Undefined.instance) {
				 frame.stack[frame.savedStackTop] = callResult;
			 }
		 }
		 else {
			 Kit.codeBug();
		 }
		 frame.savedCallOp = 0;
	 }
	 private static void captureContinuation(Context cx, CallFrame frame, int stackTop) {
		 Continuation c = new Continuation();
		 ScriptRuntime.setObjectProtoAndParent( c, ScriptRuntime.getTopCallScope(cx));
		 CallFrame x = frame.parentFrame;
		 while (x != null && !x.frozen) {
			 x.frozen = true;
			 for (int i = x.savedStackTop + 1;
			 i != x.stack.length;
			 ++i) {
				 x.stack[i] = null;
			 }
			 if (x.savedCallOp == Token.CALL) {
				 x.stack[x.savedStackTop] = null;
			 }
			 else {
				 if (x.savedCallOp != Token.NEW) Kit.codeBug();
			 }
			 x = x.parentFrame;
		 }
		 c.initImplementation(frame.parentFrame);
		 frame.stack[stackTop] = c;
	 }
	 private static int stack_int32(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 double value;
		 if (x == UniqueTag.DOUBLE_MARK) {
			 value = frame.sDbl[i];
		 }
		 else {
			 value = ScriptRuntime.toNumber(x);
		 }
		 return ScriptRuntime.toInt32(value);
	 }
	 private static double stack_double(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x != UniqueTag.DOUBLE_MARK) {
			 return ScriptRuntime.toNumber(x);
		 }
		 else {
			 return frame.sDbl[i];
		 }
	 }
	 private static boolean stack_boolean(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x == Boolean.TRUE) {
			 return true;
		 }
		 else if (x == Boolean.FALSE) {
			 return false;
		 }
		 else if (x == UniqueTag.DOUBLE_MARK) {
			 double d = frame.sDbl[i];
			 return d == d && d != 0.0;
		 }
		 else if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 double d = ((Number)x).doubleValue();
			 return (d == d && d != 0.0);
		 }
		 else if (x instanceof Boolean) {
			 return ((Boolean)x).booleanValue();
		 }
		 else {
			 return ScriptRuntime.toBoolean(x);
		 }
	 }
	 private static void do_add(Object[] stack, double[] sDbl, int stackTop, Context cx) {
		 Object rhs = stack[stackTop + 1];
		 Object lhs = stack[stackTop];
		 double d;
		 boolean leftRightOrder;
		 if (rhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop + 1];
			 if (lhs == UniqueTag.DOUBLE_MARK) {
				 sDbl[stackTop] += d;
				 return;
			 }
			 leftRightOrder = true;
		 }
		 else if (lhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop];
			 lhs = rhs;
			 leftRightOrder = false;
		 }
		 else {
			 if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
				 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
			 }
			 else if (lhs instanceof String) {
				 String lstr = (String)lhs;
				 String rstr = ScriptRuntime.toString(rhs);
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else if (rhs instanceof String) {
				 String lstr = ScriptRuntime.toString(lhs);
				 String rstr = (String)rhs;
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
				 double rDbl = (rhs instanceof Number) ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
				 stack[stackTop] = UniqueTag.DOUBLE_MARK;
				 sDbl[stackTop] = lDbl + rDbl;
			 }
			 return;
		 }
		 if (lhs instanceof Scriptable) {
			 rhs = ScriptRuntime.wrapNumber(d);
			 if (!leftRightOrder) {
				 Object tmp = lhs;
				 lhs = rhs;
				 rhs = tmp;
			 }
			 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
		 }
		 else if (lhs instanceof String) {
			 String lstr = (String)lhs;
			 String rstr = ScriptRuntime.toString(d);
			 if (leftRightOrder) {
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 stack[stackTop] = rstr.concat(lstr);
			 }
		 }
		 else {
			 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
			 stack[stackTop] = UniqueTag.DOUBLE_MARK;
			 sDbl[stackTop] = lDbl + d;
		 }
	 }
	 private static Object[] getArgsArray(Object[] stack, double[] sDbl, int shift, int count) {
		 if (count == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] args = new Object[count];
		 for (int i = 0;
		 i != count;
		 ++i, ++shift) {
			 Object val = stack[shift];
			 if (val == UniqueTag.DOUBLE_MARK) {
				 val = ScriptRuntime.wrapNumber(sDbl[shift]);
			 }
			 args[i] = val;
		 }
		 return args;
	 }
	 private static void addInstructionCount(Context cx, CallFrame frame, int extra) {
		 cx.instructionCount += frame.pc - frame.pcPrevBranch + extra;
		 if (cx.instructionCount > cx.instructionThreshold) {
			 cx.observeInstructionCount(cx.instructionCount);
			 cx.instructionCount = 0;
		 }
	 }
}",1,0,0,0
"public ByteBuffer fromString(String source) throws MarshalException {
	 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
	 BigDecimal decimal;
	 try {
		 decimal = new BigDecimal(source);
	 }
	 catch (Exception e) {
		 throw new MarshalException(String.format(""unable to make BigDecimal from '%s'"", source), e);
	 }
	 return decompose(decimal);
 }",0,0,0,0
"private void initUI() {
	int y = 0;
	int h = 0;
	JPanel panel = new JPanel();
	panel.setLayout(null);
	panel.setOpaque(false);
	y += 10;
	h = 30;
	JLabel lblFileTitle = new JLabel(StringResource.get(""ND_FILE""));
	lblFileTitle.setForeground(Color.WHITE);
	lblFileTitle.setFont(FontResource.getNormalFont());
	lblFileTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblFileTitle);
	y += h;
	h = 25;
	txtDefFile = new JTextField();
	txtDefFile.setBounds(15, y, 350 - 50, h);
	txtDefFile.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtDefFile.setEditable(false);
	txtDefFile.setForeground(Color.WHITE);
	txtDefFile.setOpaque(false);
	panel.add(txtDefFile);
	y += h;
	h = 30;
	JLabel lblFolderTitle = new JLabel(StringResource.get(""CD_LOC""));
	lblFolderTitle.setForeground(Color.WHITE);
	lblFolderTitle.setFont(FontResource.getNormalFont());
	lblFolderTitle.setBounds(15, y, 350 - 50, h);
	panel.add(lblFolderTitle);
	y += h;
	h = 25;
	txtDefFolder = new JTextField();
	txtDefFolder.setBounds(15, y, 350 - 50, h);
	txtDefFolder.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtDefFolder.setEditable(false);
	txtDefFolder.setForeground(Color.WHITE);
	txtDefFolder.setOpaque(false);
	panel.add(txtDefFolder);
	y += h;
	h = 30;
	JLabel lblUrlTitle = new JLabel(StringResource.get(""ND_ADDRESS""));
	lblUrlTitle.setForeground(Color.WHITE);
	lblUrlTitle.setFont(FontResource.getNormalFont());
	lblUrlTitle.setBounds(15, y, 350 - 50, h);
	panel.add(lblUrlTitle);
	y += h;
	h = 25;
	txtUrl = new JTextField();
	txtUrl.setBounds(15, y, 350 - 50, h);
	txtUrl.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtUrl.setEditable(false);
	txtUrl.setForeground(Color.WHITE);
	txtUrl.setOpaque(false);
	panel.add(txtUrl);
	y += h;
	h = 30;
	JLabel lblSizeLabel = new JLabel(StringResource.get(""PROP_SIZE""));
	lblSizeLabel.setForeground(Color.WHITE);
	lblSizeLabel.setFont(FontResource.getNormalFont());
	lblSizeLabel.setBounds(15, y, 100, h);
	panel.add(lblSizeLabel);
	lblSize = new JLabel();
	lblSize.setForeground(Color.WHITE);
	lblSize.setFont(FontResource.getNormalFont());
	lblSize.setBounds(115, y, 200, h);
	panel.add(lblSize);
	y += h;
	h = 30;
	JLabel lblDateLabel = new JLabel(StringResource.get(""PROP_DATE""));
	lblDateLabel.setForeground(Color.WHITE);
	lblDateLabel.setFont(FontResource.getNormalFont());
	lblDateLabel.setBounds(15, y, 100, h);
	panel.add(lblDateLabel);
	lblDate = new JLabel();
	lblDate.setForeground(Color.WHITE);
	lblDate.setFont(FontResource.getNormalFont());
	lblDate.setBounds(115, y, 200, h);
	panel.add(lblDate);
	y += h;
	h = 30;
	JLabel lblTypeLabel = new JLabel(StringResource.get(""PROP_TYPE""));
	lblTypeLabel.setForeground(Color.WHITE);
	lblTypeLabel.setFont(FontResource.getNormalFont());
	lblTypeLabel.setBounds(15, y, 100, h);
	panel.add(lblTypeLabel);
	lblType = new JLabel();
	lblType.setForeground(Color.WHITE);
	lblType.setFont(FontResource.getNormalFont());
	lblType.setBounds(115, y, 200, h);
	panel.add(lblType);
	y += h;
	h = 30;
	JLabel lblRefererLabel = new JLabel(StringResource.get(""PROP_REFERER""));
	lblRefererLabel.setForeground(Color.WHITE);
	lblRefererLabel.setFont(FontResource.getNormalFont());
	lblRefererLabel.setBounds(15, y, 100, h);
	panel.add(lblRefererLabel);
	lblReferer = new JLabel();
	lblReferer.setForeground(Color.WHITE);
	lblReferer.setFont(FontResource.getNormalFont());
	lblReferer.setBounds(115, y, 200, h);
	panel.add(lblReferer);
	y += h;
	h = 30;
	JLabel lblCookieTitle = new JLabel(StringResource.get(""PROP_COOKIE""));
	lblCookieTitle.setForeground(Color.WHITE);
	lblCookieTitle.setFont(FontResource.getNormalFont());
	lblCookieTitle.setBounds(15, y, 350 - 30, h);
	panel.add(lblCookieTitle);
	y += h;
	y += 10;
	h = 120;
	txtCookie = new JTextArea();
	txtCookie.setBounds(15, y, 350 - 50, h);
	txtCookie.setBorder(new LineBorder(ColorResource.getDarkBtnColor()));
	txtCookie.setEditable(false);
	txtCookie.setForeground(Color.WHITE);
	txtCookie.setOpaque(false);
	panel.add(txtCookie);
	y += h;
	y += 50;
	panel.setPreferredSize(new Dimension(350, y));
	panel.setBounds(0, 0, 350, y);
	jsp.setViewportView(panel);
}",0,0,1,0
"static Object createObject(String factoryId, String propertiesFilename, String fallbackClassName) throws ConfigurationError;",0,0,0,1
"public final EObject ruleXOtherOperatorExpression() throws RecognitionException {
	 EObject current = null;
	 EObject this_XAdditiveExpression_0 = null;
	 EObject lv_rightOperand_3_0 = null;
	 enterRule();
	 try {
		 {
			 {
				 if ( state.backtracking==0 ) {
					 newCompositeNode(grammarAccess.getXOtherOperatorExpressionAccess().getXAdditiveExpressionParserRuleCall_0());
				 }
				 pushFollow(FOLLOW_14);
				 this_XAdditiveExpression_0=ruleXAdditiveExpression();
				 state._fsp--;
				 if (state.failed) return current;
				 if ( state.backtracking==0 ) {
					 current = this_XAdditiveExpression_0;
					 afterParserOrEnumRuleCall();
				 }
				 loop11: do {
					 int alt11=2;
					 alt11 = dfa11.predict(input);
					 switch (alt11) {
						 case 1 : {
							 {
								 {
									 {
										 if ( state.backtracking==0 ) {
											 current = forceCreateModelElementAndSet( grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0(), current);
										 }
									 }
									 {
										 {
											 if ( state.backtracking==0 ) {
												 if (current==null) {
													 current = createModelElement(grammarAccess.getXOtherOperatorExpressionRule());
												 }
											 }
											 if ( state.backtracking==0 ) {
												 newCompositeNode(grammarAccess.getXOtherOperatorExpressionAccess().getFeatureJvmIdentifiableElementCrossReference_1_0_0_1_0());
											 }
											 pushFollow(FOLLOW_4);
											 ruleOpOther();
											 state._fsp--;
											 if (state.failed) return current;
											 if ( state.backtracking==0 ) {
												 afterParserOrEnumRuleCall();
											 }
										 }
									 }
								 }
							 }
							 {
								 {
									 if ( state.backtracking==0 ) {
										 newCompositeNode(grammarAccess.getXOtherOperatorExpressionAccess().getRightOperandXAdditiveExpressionParserRuleCall_1_1_0());
									 }
									 pushFollow(FOLLOW_14);
									 lv_rightOperand_3_0=ruleXAdditiveExpression();
									 state._fsp--;
									 if (state.failed) return current;
									 if ( state.backtracking==0 ) {
										 if (current==null) {
											 current = createModelElementForParent(grammarAccess.getXOtherOperatorExpressionRule());
										 }
										 set( current, ""rightOperand"", lv_rightOperand_3_0, ""org.eclipse.xtext.xbase.Xbase.XAdditiveExpression"");
										 afterParserOrEnumRuleCall();
									 }
								 }
							 }
						 }
						 break;
						 default : break loop11;
					 }
				 }
				 while (true);
			 }
		 }
		 if ( state.backtracking==0 ) {
			 leaveRule();
		 }
	 }
	 catch (RecognitionException re) {
		 recover(input,re);
		 appendSkippedTokens();
	 }
	 finally {
	 }
	 return current;
 }",0,0,1,0
"public class XMLUtils{
	private Document document_;
	 private XPath xpath_;
	 public XMLUtils(String xmlSrc) throws FileNotFoundException, ParserConfigurationException, SAXException, IOException {
		 DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		 DocumentBuilder db = dbf.newDocumentBuilder();
		 File xmlFile = new File(xmlSrc);
		 document_ = db.parse(xmlFile);
		 XPathFactory xpathFactory = XPathFactory.newInstance();
		 xpath_ = xpathFactory.newXPath();
	 }
	public String getNodeValue(String xql) throws XPathExpressionException{
		 String value = xpath_.compile(xql).evaluate(document_);
		 return """".equals(value) ? null : value;
	 }
	public String[] getNodeValues(String xql) throws XPathExpressionException{
		 XPathExpression expr = xpath_.compile(xql);
		 NodeList nl = (NodeList)expr.evaluate(document_, XPathConstants.NODESET);
		 int size = nl.getLength();
		 String[] values = new String[size];
		 for ( int i = 0;
		 i < size;
		 ++i ) {
			 Node node = nl.item(i);
			 node = node.getFirstChild();
			 values[i] = node.getNodeValue();
		 }
		 return values;
	 }
	public NodeList getRequestedNodeList(String xql) throws XPathExpressionException{
		 XPathExpression expr = xpath_.compile(xql);
		 NodeList nodeList = (NodeList)expr.evaluate(document_, XPathConstants.NODESET);
		return nodeList;
	}
	public static String getAttributeValue(Node node, String attrName) throws TransformerException{
		 String value = null;
		node = node.getAttributes().getNamedItem(attrName);
		if ( node != null ){
			 value = node.getNodeValue();
		}
		return value;
	}
}",0,0,0,0
"final class ArrowType extends JSType {
	 private static final long serialVersionUID = 1L;
	 final Node parameters;
	 JSType returnType;
	 final boolean returnTypeInferred;
	 ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType) {
		 this(registry, parameters, returnType, false);
	 }
	 ArrowType(JSTypeRegistry registry, Node parameters, JSType returnType, boolean returnTypeInferred) {
		 super(registry);
		 this.parameters = parameters == null ? registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) : parameters;
		 this.returnType = returnType == null ? getNativeType(UNKNOWN_TYPE) : returnType;
		 this.returnTypeInferred = returnTypeInferred;
	 }
	 public boolean isSubtype(JSType that) {
		 return isSubtype(that, ImplCache.create(), SubtypingMode.NORMAL);
	 }
	 protected boolean isSubtype(JSType other, ImplCache implicitImplCache, SubtypingMode subtypingMode) {
		 if (!(other instanceof ArrowType)) {
			 return false;
		 }
		 ArrowType that = (ArrowType) other;
		 if (!this.returnType.isSubtype(that.returnType, implicitImplCache, subtypingMode)) {
			 return false;
		 }
		 Node thisParam = parameters.getFirstChild();
		 Node thatParam = that.parameters.getFirstChild();
		 while (thisParam != null && thatParam != null) {
			 JSType thisParamType = thisParam.getJSType();
			 JSType thatParamType = thatParam.getJSType();
			 if (thisParamType != null) {
				 if (thatParamType == null || !thatParamType.isSubtype(thisParamType, implicitImplCache, subtypingMode)) {
					 return false;
				 }
			 }
			 boolean thisIsVarArgs = thisParam.isVarArgs();
			 boolean thatIsVarArgs = thatParam.isVarArgs();
			 boolean thisIsOptional = thisIsVarArgs || thisParam.isOptionalArg();
			 boolean thatIsOptional = thatIsVarArgs || thatParam.isOptionalArg();
			 if (!thisIsOptional && thatIsOptional) {
				 boolean isTopFunction = thatIsVarArgs && (thatParamType == null || thatParamType.isUnknownType() || thatParamType.isNoType());
				 if (!isTopFunction) {
					 return false;
				 }
			 }
			 if (!thisIsVarArgs) {
				 thisParam = thisParam.getNext();
			 }
			 if (!thatIsVarArgs) {
				 thatParam = thatParam.getNext();
			 }
			 if (thisIsVarArgs && thatIsVarArgs) {
				 thisParam = null;
				 thatParam = null;
			 }
		 }
		 return thisParam == null || thisParam.isOptionalArg() || thisParam.isVarArgs() || thatParam != null;
	 }
	 boolean hasEqualParameters(ArrowType that, EquivalenceMethod eqMethod, EqCache eqCache) {
		 Node thisParam = parameters.getFirstChild();
		 Node otherParam = that.parameters.getFirstChild();
		 while (thisParam != null && otherParam != null) {
			 JSType thisParamType = thisParam.getJSType();
			 JSType otherParamType = otherParam.getJSType();
			 if (thisParamType != null) {
				 if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType, eqMethod, eqCache)) {
					 return false;
				 }
			 }
			 else {
				 if (otherParamType != null) {
					 return false;
				 }
			 }
			 if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {
				 return false;
			 }
			 if (thisParam.isVarArgs() != otherParam.isVarArgs()) {
				 return false;
			 }
			 thisParam = thisParam.getNext();
			 otherParam = otherParam.getNext();
		 }
		 return thisParam == otherParam;
	 }
	 boolean checkArrowEquivalenceHelper( ArrowType that, EquivalenceMethod eqMethod, EqCache eqCache) {
		 if (!returnType.checkEquivalenceHelper( that.returnType, eqMethod, eqCache)) {
			 return false;
		 }
		 return hasEqualParameters(that, eqMethod, eqCache);
	 }
	 int recursionUnsafeHashCode() {
		 int hashCode = Objects.hashCode(returnType);
		 if (parameters != null) {
			 Node param = parameters.getFirstChild();
			 while (param != null) {
				 hashCode = hashCode * 31 + Objects.hashCode(param.getJSType());
				 param = param.getNext();
			 }
		 }
		 return hashCode;
	 }
	 public JSType getLeastSupertype(JSType that) {
		 throw new UnsupportedOperationException();
	 }
	 public JSType getGreatestSubtype(JSType that) {
		 throw new UnsupportedOperationException();
	 }
	 public TernaryValue testForEquality(JSType that) {
		 throw new UnsupportedOperationException();
	 }
	 public <T> T visit(Visitor<T> visitor) {
		 throw new UnsupportedOperationException();
	 }
	 <T> T visit(RelationshipVisitor<T> visitor, JSType that) {
		 throw new UnsupportedOperationException();
	 }
	 public BooleanLiteralSet getPossibleToBooleanOutcomes() {
		 return BooleanLiteralSet.TRUE;
	 }
	 JSType resolveInternal(ErrorReporter reporter) {
		 returnType = safeResolve(returnType, reporter);
		 if (parameters != null) {
			 for (Node paramNode = parameters.getFirstChild();
			 paramNode != null;
			 paramNode = paramNode.getNext()) {
				 paramNode.setJSType(paramNode.getJSType().resolve(reporter));
			 }
		 }
		 return this;
	 }
	 boolean hasUnknownParamsOrReturn() {
		 if (parameters != null) {
			 for (Node paramNode = parameters.getFirstChild();
			 paramNode != null;
			 paramNode = paramNode.getNext()) {
				 JSType type = paramNode.getJSType();
				 if (type == null || type.isUnknownType()) {
					 return true;
				 }
			 }
		 }
		 return returnType == null || returnType.isUnknownType();
	 }
	 StringBuilder appendTo(StringBuilder sb, boolean forAnnotations) {
		 return sb.append(""[ArrowType]"");
	 }
	 public boolean hasAnyTemplateTypesInternal() {
		 return returnType.hasAnyTemplateTypes() || hasTemplatedParameterType();
	 }
	 private boolean hasTemplatedParameterType() {
		 if (parameters != null) {
			 for (Node paramNode = parameters.getFirstChild();
			 paramNode != null;
			 paramNode = paramNode.getNext()) {
				 JSType type = paramNode.getJSType();
				 if (type != null && type.hasAnyTemplateTypes()) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
}",1,0,0,0
"public void write(DataOutput out) throws IOException {
	 if (compactedCf != null) {
		 DataOutputBuffer buffer = new DataOutputBuffer();
		 DataOutputBuffer headerBuffer = new DataOutputBuffer();
		 ColumnIndexer.serialize(compactedCf, headerBuffer);
		 ColumnFamily.serializer().serializeForSSTable(compactedCf, buffer);
		 out.writeLong(headerBuffer.getLength() + buffer.getLength());
		 out.write(headerBuffer.getData(), 0, headerBuffer.getLength());
		 out.write(buffer.getData(), 0, buffer.getLength());
	 }
 }",0,0,0,0
"public class GridNearAtomicSingleUpdateRequest extends GridNearAtomicAbstractSingleUpdateRequest {
	 private static final long serialVersionUID = 0L;
	 protected KeyCacheObject key;
	 protected CacheObject val;
	 public GridNearAtomicSingleUpdateRequest() {
	 }
	 GridNearAtomicSingleUpdateRequest( int cacheId, UUID nodeId, long futId, AffinityTopologyVersion topVer, CacheWriteSynchronizationMode syncMode, GridCacheOperation op, UUID subjId, int taskNameHash, byte flags, boolean addDepInfo ) {
		 super(cacheId, nodeId, futId, topVer, syncMode, op, subjId, taskNameHash, flags, addDepInfo );
	 }
	 public int partition() {
		 assert key != null;
		 return key.partition();
	 }
	 public void addUpdateEntry(KeyCacheObject key, Object val, long conflictTtl, long conflictExpireTime, GridCacheVersion conflictVer) {
		 assert op != TRANSFORM;
		 assert val != null || op == DELETE;
		 assert conflictTtl < 0 : conflictTtl;
		 assert conflictExpireTime < 0 : conflictExpireTime;
		 assert conflictVer == null : conflictVer;
		 this.key = key;
		 if (val != null) {
			 assert val instanceof CacheObject : val;
			 this.val = (CacheObject)val;
		 }
	 }
	 public int size() {
		 assert key != null;
		 return key == null ? 0 : 1;
	 }
	 public List<KeyCacheObject> keys() {
		 return Collections.singletonList(key);
	 }
	 public KeyCacheObject key(int idx) {
		 assert idx == 0 : idx;
		 return key;
	 }
	 public List<?> values() {
		 return Collections.singletonList(val);
	 }
	 public CacheObject value(int idx) {
		 assert idx == 0 : idx;
		 return val;
	 }
	 public EntryProcessor<Object, Object, Object> entryProcessor(int idx) {
		 assert idx == 0 : idx;
		 return null;
	 }
	 public CacheObject writeValue(int idx) {
		 assert idx == 0 : idx;
		 return val;
	 }
	 public List<GridCacheVersion> conflictVersions() {
		 return null;
	 }
	 public GridCacheVersion conflictVersion(int idx) {
		 assert idx == 0 : idx;
		 return null;
	 }
	 public long conflictTtl(int idx) {
		 assert idx == 0 : idx;
		 return CU.TTL_NOT_CHANGED;
	 }
	 public long conflictExpireTime(int idx) {
		 assert idx == 0 : idx;
		 return CU.EXPIRE_TIME_CALCULATE;
	 }
	 public void prepareMarshal(GridCacheSharedContext ctx) throws IgniteCheckedException {
		 super.prepareMarshal(ctx);
		 GridCacheContext cctx = ctx.cacheContext(cacheId);
		 prepareMarshalCacheObject(key, cctx);
		 if (val != null) prepareMarshalCacheObject(val, cctx);
	 }
	 public void finishUnmarshal(GridCacheSharedContext ctx, ClassLoader ldr) throws IgniteCheckedException {
		 super.finishUnmarshal(ctx, ldr);
		 GridCacheContext cctx = ctx.cacheContext(cacheId);
		 key.finishUnmarshal(cctx.cacheObjectContext(), ldr);
		 if (val != null) val.finishUnmarshal(cctx.cacheObjectContext(), ldr);
	 }
	 public boolean writeTo(ByteBuffer buf, MessageWriter writer) {
		 writer.setBuffer(buf);
		 if (!super.writeTo(buf, writer)) return false;
		 if (!writer.isHeaderWritten()) {
			 if (!writer.writeHeader(directType(), fieldsCount())) return false;
			 writer.onHeaderWritten();
		 }
		 switch (writer.state()) {
			 case 11: if (!writer.writeMessage(""key"", key)) return false;
			 writer.incrementState();
			 case 12: if (!writer.writeMessage(""val"", val)) return false;
			 writer.incrementState();
		 }
		 return true;
	 }
	 public boolean readFrom(ByteBuffer buf, MessageReader reader) {
		 reader.setBuffer(buf);
		 if (!reader.beforeMessageRead()) return false;
		 if (!super.readFrom(buf, reader)) return false;
		 switch (reader.state()) {
			 case 11: key = reader.readMessage(""key"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
			 case 12: val = reader.readMessage(""val"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
		 }
		 return reader.afterMessageRead(GridNearAtomicSingleUpdateRequest.class);
	 }
	 public void cleanup(boolean clearKey) {
		 val = null;
		 if (clearKey) key = null;
	 }
	 public short directType() {
		 return 125;
	 }
	 public byte fieldsCount() {
		 return 13;
	 }
	 public String toString() {
		 return S.toString(GridNearAtomicSingleUpdateRequest.class, this, ""parent"", super.toString());
	 }
}",1,1,0,0
"public class JmxSupport {
	 private final static Logger LOGGER = Logger.getLogger(JmxSupport.class.getName());
	 private static final String HOTSPOT_DIAGNOSTIC_MXBEAN_NAME = ""com.sun.management:type=HotSpotDiagnostic"";
	 private static final String DIAGNOSTIC_COMMAND_MXBEAN_NAME = ""com.sun.management:type=DiagnosticCommand"";
	 private static final String ALL_OBJECTS_OPTION = ""-all"";
	 private static final String HISTOGRAM_COMMAND = ""gcClassHistogram"";
	 private JvmMXBeans mxbeans;
	 private JmxModel jmxModel;
	 private boolean hotspotDiagnosticInitialized;
	 private final Object hotspotDiagnosticLock = new Object();
	 private HotSpotDiagnosticMXBean hotspotDiagnosticMXBean;
	 private final Object readOnlyConnectionLock = new Object();
	 private Boolean readOnlyConnection;
	 private Boolean hasDumpAllThreads;
	 private final Object hasDumpAllThreadsLock = new Object();
	 JmxSupport(JmxModel jmx) {
		 jmxModel = jmx;
	 }
	 private RuntimeMXBean getRuntime() {
		 JvmMXBeans jmx = getJvmMXBeans();
		 if (jmx != null) {
			 return jmx.getRuntimeMXBean();
		 }
		 return null;
	 }
	 private synchronized JvmMXBeans getJvmMXBeans() {
		 if (mxbeans == null) {
			 if (jmxModel.getConnectionState() == ConnectionState.CONNECTED) {
				 mxbeans = JvmMXBeansFactory.getJvmMXBeans(jmxModel);
			 }
		 }
		 return mxbeans;
	 }
	 Properties getSystemProperties() {
		 try {
			 RuntimeMXBean runtime = getRuntime();
			 if (runtime != null) {
				 Properties prop = new Properties();
				 prop.putAll(runtime.getSystemProperties());
				 return prop;
			 }
			 return null;
		 }
		 catch (Exception e) {
			 LOGGER.throwing(JmxSupport.class.getName(), ""getSystemProperties"", e);
			 return null;
		 }
	 }
	 synchronized boolean isReadOnlyConnection() {
		 synchronized (readOnlyConnectionLock) {
			 if (readOnlyConnection == null) {
				 readOnlyConnection = Boolean.FALSE;
				 ThreadMXBean threads = getThreadBean();
				 if (threads != null) {
					 try {
						 threads.getThreadInfo(1);
					 }
					 catch (SecurityException ex) {
						 readOnlyConnection = Boolean.TRUE;
					 }
				 }
			 }
			 return readOnlyConnection.booleanValue();
		 }
	 }
	 ThreadMXBean getThreadBean() {
		 JvmMXBeans jmx = getJvmMXBeans();
		 if (jmx != null) {
			 return jmx.getThreadMXBean();
		 }
		 return null;
	 }
	 HotSpotDiagnosticMXBean getHotSpotDiagnostic() {
		 synchronized (hotspotDiagnosticLock) {
			 if (hotspotDiagnosticInitialized) {
				 return hotspotDiagnosticMXBean;
			 }
			 JvmMXBeans jmx = getJvmMXBeans();
			 if (jmx != null) {
				 try {
					 hotspotDiagnosticMXBean = jmx.getMXBean( ObjectName.getInstance(HOTSPOT_DIAGNOSTIC_MXBEAN_NAME), HotSpotDiagnosticMXBean.class);
				 }
				 catch (MalformedObjectNameException e) {
					 ErrorManager.getDefault().log(ErrorManager.WARNING, ""Couldn't find HotSpotDiagnosticMXBean: "" + e.getLocalizedMessage());
				 }
				 catch (IllegalArgumentException ex) {
					 ErrorManager.getDefault().notify(ErrorManager.INFORMATIONAL, ex);
				 }
			 }
			 hotspotDiagnosticInitialized = true;
			 return hotspotDiagnosticMXBean;
		 }
	 }
	 String takeThreadDump(long[] threadIds) {
		 ThreadMXBean threadMXBean = getThreadBean();
		 if (threadMXBean == null) {
			 return null;
		 }
		 ThreadInfo[] threads;
		 StringBuilder sb = new StringBuilder(4096);
		 SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
		 if (hasDumpAllThreads()) {
			 threads = threadMXBean.getThreadInfo(threadIds, true, true);
		 }
		 else {
			 threads = threadMXBean.getThreadInfo(threadIds, Integer.MAX_VALUE);
		 }
		 sb.append(df.format(new Date()) + ""\n"");
		 printThreads(sb, threadMXBean, threads);
		 return sb.toString();
	 }
	 String takeThreadDump() {
		 try {
			 ThreadMXBean threadMXBean = getThreadBean();
			 if (threadMXBean == null) {
				 return null;
			 }
			 ThreadInfo[] threads;
			 Properties prop = getSystemProperties();
			 StringBuilder sb = new StringBuilder(4096);
			 SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
			 sb.append(df.format(new Date()) + ""\n"");
			 sb.append(""Full thread dump "" + prop.getProperty(""java.vm.name"") + "" ("" + prop.getProperty(""java.vm.version"") + "" "" + prop.getProperty(""java.vm.info"") + ""):\n"");
			 if (hasDumpAllThreads()) {
				 threads = threadMXBean.dumpAllThreads(true, true);
			 }
			 else {
				 long[] threadIds = threadMXBean.getAllThreadIds();
				 threads = threadMXBean.getThreadInfo(threadIds, Integer.MAX_VALUE);
			 }
			 printThreads(sb, threadMXBean, threads);
			 return sb.toString();
		 }
		 catch (Exception e) {
			 LOGGER.log(Level.INFO,""takeThreadDump"", e);
			 return null;
		 }
	 }
	 private void printThreads(final StringBuilder sb, final ThreadMXBean threadMXBean, ThreadInfo[] threads) {
		 boolean jdk16 = hasDumpAllThreads();
		 for (ThreadInfo thread : threads) {
			 if (thread != null) {
				 if (jdk16) {
					 print16Thread(sb, threadMXBean, thread);
				 }
				 else {
					 print15Thread(sb, thread);
				 }
			 }
		 }
	 }
	 private void print16Thread(final StringBuilder sb, final ThreadMXBean threadMXBean, final ThreadInfo thread) {
		 MonitorInfo[] monitors = null;
		 if (threadMXBean.isObjectMonitorUsageSupported()) {
			 monitors = thread.getLockedMonitors();
		 }
		 sb.append(""\n\"""" + thread.getThreadName() + ""\"" - Thread t@"" + thread.getThreadId() + ""\n"");
		 sb.append("" java.lang.Thread.State: "" + thread.getThreadState());
		 sb.append(""\n"");
		 int index = 0;
		 for (StackTraceElement st : thread.getStackTrace()) {
			 LockInfo lock = thread.getLockInfo();
			 String lockOwner = thread.getLockOwnerName();
			 sb.append(""\tat "" + st.toString() + ""\n"");
			 if (index == 0) {
				 if (""java.lang.Object"".equals(st.getClassName()) && ""wait"".equals(st.getMethodName())) {
					 if (lock != null) {
						 sb.append(""\t- waiting on "");
						 printLock(sb,lock);
						 sb.append(""\n"");
					 }
				 }
				 else if (lock != null) {
					 if (lockOwner == null) {
						 sb.append(""\t- parking to wait for "");
						 printLock(sb,lock);
						 sb.append(""\n"");
					 }
					 else {
						 sb.append(""\t- waiting to lock "");
						 printLock(sb,lock);
						 sb.append("" owned by \""""+lockOwner+""\"" t@""+thread.getLockOwnerId()+""\n"");
					 }
				 }
			 }
			 printMonitors(sb, monitors, index);
			 index++;
		 }
		 StringBuilder jnisb = new StringBuilder();
		 printMonitors(jnisb, monitors, -1);
		 if (jnisb.length() > 0) {
			 sb.append("" JNI locked monitors:\n"");
			 sb.append(jnisb);
		 }
		 if (threadMXBean.isSynchronizerUsageSupported()) {
			 sb.append(""\n Locked ownable synchronizers:"");
			 LockInfo[] synchronizers = thread.getLockedSynchronizers();
			 if (synchronizers == null || synchronizers.length == 0) {
				 sb.append(""\n\t- None\n"");
			 }
			 else {
				 for (LockInfo li : synchronizers) {
					 sb.append(""\n\t- locked "");
					 printLock(sb,li);
					 sb.append(""\n"");
				 }
			 }
		 }
	 }
	 private void printMonitors(final StringBuilder sb, final MonitorInfo[] monitors, final int index) {
		 if (monitors != null) {
			 for (MonitorInfo mi : monitors) {
				 if (mi.getLockedStackDepth() == index) {
					 sb.append(""\t- locked "");
					 printLock(sb,mi);
					 sb.append(""\n"");
				 }
			 }
		 }
	 }
	 private void print15Thread(final StringBuilder sb, final ThreadInfo thread) {
		 sb.append(""\n\"""" + thread.getThreadName() + ""\"" - Thread t@"" + thread.getThreadId() + ""\n"");
		 sb.append("" java.lang.Thread.State: "" + thread.getThreadState());
		 if (thread.getLockName() != null) {
			 sb.append("" on "" + thread.getLockName());
			 if (thread.getLockOwnerName() != null) {
				 sb.append("" owned by: "" + thread.getLockOwnerName());
			 }
		 }
		 sb.append(""\n"");
		 for (StackTraceElement st : thread.getStackTrace()) {
			 sb.append("" at "" + st.toString() + ""\n"");
		 }
	 }
	 private void printLock(StringBuilder sb,LockInfo lock) {
		 String id = Integer.toHexString(lock.getIdentityHashCode());
		 String className = lock.getClassName();
		 sb.append(""<""+id+""> (a ""+className+"")"");
	 }
	 boolean takeHeapDump(String fileName) {
		 HotSpotDiagnosticMXBean hsDiagnostic = getHotSpotDiagnostic();
		 if (hsDiagnostic != null) {
			 try {
				 hsDiagnostic.dumpHeap(fileName,true);
			 }
			 catch (IOException ex) {
				 LOGGER.log(Level.INFO,""takeHeapDump"", ex);
				 return false;
			 }
			 return true;
		 }
		 return false;
	 }
	 String getFlagValue(String name) {
		 HotSpotDiagnosticMXBean hsDiagnostic = getHotSpotDiagnostic();
		 if (hsDiagnostic != null) {
			 VMOption option = hsDiagnostic.getVMOption(name);
			 if (option != null) {
				 return option.getValue();
			 }
		 }
		 return null;
	 }
	 HeapHistogram takeHeapHistogram() {
		 if (jmxModel.getConnectionState() == ConnectionState.CONNECTED) {
			 MBeanServerConnection conn = jmxModel.getMBeanServerConnection();
			 try {
				 ObjectName diagCommName = new ObjectName(DIAGNOSTIC_COMMAND_MXBEAN_NAME);
				 if (conn.isRegistered(diagCommName)) {
					 Object histo = conn.invoke(diagCommName, HISTOGRAM_COMMAND, new Object[] {
						new String[] {
						ALL_OBJECTS_OPTION}
					}
					, new String[] {
					String[].class.getName()}
					 );
					 if (histo instanceof String) {
						 return new HeapHistogramImpl((String)histo);
					 }
				 }
			 }
			 catch (MalformedObjectNameException ex) {
				 Exceptions.printStackTrace(ex);
			 }
			 catch (IOException ex) {
				 LOGGER.log(Level.INFO,""takeHeapHistogram"", ex);
			 }
			 catch (InstanceNotFoundException ex) {
				 Exceptions.printStackTrace(ex);
			 }
			 catch (MBeanException ex) {
				 Exceptions.printStackTrace(ex);
			 }
			 catch (ReflectionException ex) {
				 Exceptions.printStackTrace(ex);
			 }
		 }
		 return null;
	 }
	 void setFlagValue(String name, String value) {
		 HotSpotDiagnosticMXBean hsDiagnostic = getHotSpotDiagnostic();
		 if (hsDiagnostic != null) {
			 hsDiagnostic.setVMOption(name,value);
		 }
	 }
	 private boolean hasDumpAllThreads() {
		 synchronized (hasDumpAllThreadsLock) {
			 if (hasDumpAllThreads == null) {
				 hasDumpAllThreads = Boolean.FALSE;
				 try {
					 ObjectName threadObjName = new ObjectName(ManagementFactory.THREAD_MXBEAN_NAME);
					 MBeanInfo threadInfo = jmxModel.getMBeanServerConnection().getMBeanInfo(threadObjName);
					 if (threadInfo != null) {
						 for (MBeanOperationInfo op : threadInfo.getOperations()) {
							 if (""dumpAllThreads"".equals(op.getName())) {
								 hasDumpAllThreads = Boolean.TRUE;
							 }
						 }
					 }
				 }
				 catch (Exception ex) {
					 LOGGER.log(Level.INFO,""hasDumpAllThreads"", ex);
				 }
			 }
			 return hasDumpAllThreads.booleanValue();
		 }
	 }
}",1,0,0,0
"public final class BridgePatternParser extends org.apache.log4j.helpers.PatternParser {
	 public BridgePatternParser( final String conversionPattern) {
		 super(conversionPattern);
	 }
	 public org.apache.log4j.helpers.PatternConverter parse() {
		 return new BridgePatternConverter(pattern);
	 }
}",0,0,0,0
"public void setVm(String vm) {
	 vmCommand.setExecutable(vm);
 }",0,0,0,0
"public ValueEval evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);",0,0,0,0
"private static void init() {
	 try {
		 Reader reader = NutchConf.get().getConfResourceAsReader (NutchConf.get().get(""analysis.common.terms.file""));
		 BufferedReader in = new BufferedReader(reader);
		 String line;
		 while ((line = in.readLine()) != null) {
			 line = line.trim();
			 if (line.startsWith(""#"") || """".equals(line)) continue;
			 TokenStream ts = new NutchDocumentTokenizer(new StringReader(line));
			 Token token = ts.next();
			 if (token == null) {
				 LOG.warning(""Line does not contain a field name: "" + line);
				 continue;
			 }
			 String field = token.termText();
			 token = ts.next();
			 if (token == null) {
				 LOG.warning(""Line contains only a field name, no word: "" + line);
				 continue;
			 }
			 String gram = token.termText();
			 while ((token = ts.next()) != null) {
				 gram = gram + SEPARATOR + token.termText();
			 }
			 HashSet table = (HashSet)COMMON_TERMS.get(field);
			 if (table == null) {
				 table = new HashSet();
				 COMMON_TERMS.put(field, table);
			 }
			 table.add(gram);
		 }
	 }
	 catch (IOException e) {
		 throw new RuntimeException(e.toString());
	 }
 }",0,0,0,0
"private void createPopupMenu() {
	popupCtx = new JPopupMenu();
	addMenuItem(""CTX_OPEN_FILE"", popupCtx);
	addMenuItem(""CTX_OPEN_FOLDER"", popupCtx);
	addMenuItem(""CTX_SAVE_AS"", popupCtx);
	addMenuItem(""MENU_PAUSE"", popupCtx);
	addMenuItem(""MENU_RESUME"", popupCtx);
	addMenuItem(""MENU_DELETE_DWN"", popupCtx);
	addMenuItem(""MENU_REFRESH_LINK"", popupCtx);
	addMenuItem(""CTX_COPY_URL"", popupCtx);
	addMenuItem(""CTX_COPY_FILE"", popupCtx);
	convertMenu = createMenu(StringResource.get(""OPT_CONVERT""));
	convertMenu.setBorder(new EmptyBorder(5, 10, 5, 5));
	convertMenu.setFont(FontResource.getNormalFont());
	MediaFormat[] fmts = MediaFormats.getSupportedFormats();
	for (int i = 1;
	 i < fmts.length;
	 i++) {
		MediaFormat fmt = fmts[i];
		JMenuItem mitem = new JMenuItem(fmt.toString());
		mitem.setName(""FORMAT="" + i);
		mitem.addActionListener(this);
		convertMenu.add(mitem);
	}
	popupCtx.add(convertMenu);
	addMenuItem(""MENU_PROPERTIES"", popupCtx);
	popupCtx.setInvoker(lv.getTable());
	lv.getTable().addMouseListener(new MouseAdapter() {
		public void mouseReleased(MouseEvent me) {
			if (me.getButton() == MouseEvent.BUTTON3 || SwingUtilities.isRightMouseButton(me) || me.isPopupTrigger()|| isMacPopupTrigger(me)) {
				Point p = me.getPoint();
				JTable tbl = lv.getTable();
				if (tbl.getRowCount() < 1)return;
				if (tbl.getSelectedRow() < 0) {
					int row = tbl.rowAtPoint(p);
					if (row >= 0) {
						tbl.setRowSelectionInterval(row, row);
					}
				}
				if (tbl.getSelectedRows().length > 0) {
					popupCtx.show(lv.getTable(), me.getX(), me.getY());
				}
			}
		}
	}
	);
}",0,0,1,0
"public class SensorResource extends AbstractBrooklynRestResource implements SensorApi {
	 private static final Logger log = LoggerFactory.getLogger(SensorResource.class);
	 public List<SensorSummary> list(final String application, final String entityToken) {
		 final Entity entity = brooklyn().getEntity(application, entityToken);
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"", Entitlements.getEntitlementContext().user(), entity);
		 }
		 List<SensorSummary> result = Lists.newArrayList();
		 for (AttributeSensor<?> sensor : filter(entity.getEntityType().getSensors(), AttributeSensor.class)) {
			 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
				 log.trace(""User {
				}
				 not authorized to see sensor {
				}
				 of entity {
				}
				;
				 excluding from AttributeSensor list results"", new Object[] {
				Entitlements.getEntitlementContext().user(), sensor.getName(), entity}
				);
				 continue;
			 }
			 result.add(SensorTransformer.sensorSummary(entity, sensor, ui.getBaseUriBuilder()));
		 }
		 return result;
	 }
	 public Map<String, Object> batchSensorRead(final String application, final String entityToken, final Boolean raw) {
		 final Entity entity = brooklyn().getEntity(application, entityToken);
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"", Entitlements.getEntitlementContext().user(), entity);
		 }
		 Map<String, Object> sensorMap = Maps.newHashMap();
		 Iterable<AttributeSensor> sensors = filter(entity.getEntityType().getSensors(), AttributeSensor.class);
		 for (AttributeSensor<?> sensor : sensors) {
			 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
				 log.trace(""User {
				}
				 not authorized to see sensor {
				}
				 of entity {
				}
				;
				 excluding from current-state results"", new Object[] {
				Entitlements.getEntitlementContext().user(), sensor.getName(), entity}
				);
				 continue;
			 }
			 Object value = entity.getAttribute(findSensor(entity, sensor.getName()));
			 sensorMap.put(sensor.getName(), resolving(value).preferJson(true).asJerseyOutermostReturnValue(false).raw(raw).context(entity).timeout(Duration.ZERO).renderAs(sensor).resolve());
		 }
		 return sensorMap;
	 }
	 protected Object get(boolean preferJson, String application, String entityToken, String sensorName, Boolean raw) {
		 final Entity entity = brooklyn().getEntity(application, entityToken);
		 AttributeSensor<?> sensor = findSensor(entity, sensorName);
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_ENTITY, entity)) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s'"", Entitlements.getEntitlementContext().user(), entity);
		 }
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.SEE_SENSOR, new EntityAndItem<String>(entity, sensor.getName()))) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to see entity '%s' sensor '%s'"", Entitlements.getEntitlementContext().user(), entity, sensor.getName());
		 }
		 Object value = entity.getAttribute(sensor);
		 return resolving(value).preferJson(preferJson).asJerseyOutermostReturnValue(true).raw(raw).context(entity).immediately(true).renderAs(sensor).resolve();
	 }
	 public String getPlain(String application, String entityToken, String sensorName, final Boolean raw) {
		 return (String) get(false, application, entityToken, sensorName, raw);
	 }
	 public Object get(final String application, final String entityToken, String sensorName, final Boolean raw) {
		 return get(true, application, entityToken, sensorName, raw);
	 }
	 private AttributeSensor<?> findSensor(Entity entity, String name) {
		 Sensor<?> s = entity.getEntityType().getSensor(name);
		 if (s instanceof AttributeSensor) return (AttributeSensor<?>) s;
		 return new BasicAttributeSensor<Object>(Object.class, name);
	 }
	 public void setFromMap(String application, String entityToken, Map newValues) {
		 final Entity entity = brooklyn().getEntity(application, entityToken);
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"", Entitlements.getEntitlementContext().user(), entity);
		 }
		 if (log.isDebugEnabled()) log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" setting sensors ""+newValues);
		 for (Object entry: newValues.entrySet()) {
			 String sensorName = Strings.toString(((Map.Entry)entry).getKey());
			 Object newValue = ((Map.Entry)entry).getValue();
			 AttributeSensor sensor = findSensor(entity, sensorName);
			 entity.sensors().set(sensor, newValue);
		 }
	 }
	 public void set(String application, String entityToken, String sensorName, Object newValue) {
		 final Entity entity = brooklyn().getEntity(application, entityToken);
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"", Entitlements.getEntitlementContext().user(), entity);
		 }
		 AttributeSensor sensor = findSensor(entity, sensorName);
		 if (log.isDebugEnabled()) log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" setting sensor ""+sensorName+"" to ""+newValue);
		 entity.sensors().set(sensor, newValue);
	 }
	 public void delete(String application, String entityToken, String sensorName) {
		 final Entity entity = brooklyn().getEntity(application, entityToken);
		 if (!Entitlements.isEntitled(mgmt().getEntitlementManager(), Entitlements.MODIFY_ENTITY, entity)) {
			 throw WebResourceUtils.forbidden(""User '%s' is not authorized to modify entity '%s'"", Entitlements.getEntitlementContext().user(), entity);
		 }
		 AttributeSensor<?> sensor = findSensor(entity, sensorName);
		 if (log.isDebugEnabled()) log.debug(""REST user ""+Entitlements.getEntitlementContext()+"" deleting sensor ""+sensorName);
		 ((EntityInternal)entity).sensors().remove(sensor);
	 }
}",1,0,0,0
"public class PeriodFormatterData {
	 final DataRecord dr;
	 String localeName;
	 public static boolean trace = false;
	 public PeriodFormatterData(String localeName, DataRecord dr) {
		 this.dr = dr;
		 this.localeName = localeName;
		 if(localeName == null) {
			 throw new NullPointerException(""localename is null"");
		 }
		 if (dr == null) {
			 throw new NullPointerException(""data record is null"");
		 }
	 }
	 public int pluralization() {
		 return dr.pl;
	 }
	 public boolean allowZero() {
		 return dr.allowZero;
	 }
	 public boolean weeksAloneOnly() {
		 return dr.weeksAloneOnly;
	 }
	 public int useMilliseconds() {
		 return dr.useMilliseconds;
	 }
	 public boolean appendPrefix(int tl, int td, StringBuffer sb) {
		 if (dr.scopeData != null) {
			 int ix = tl * 3 + td;
			 ScopeData sd = dr.scopeData[ix];
			 if (sd != null) {
				 String prefix = sd.prefix;
				 if (prefix != null) {
					 sb.append(prefix);
					 return sd.requiresDigitPrefix;
				 }
			 }
		 }
		 return false;
	 }
	 public void appendSuffix(int tl, int td, StringBuffer sb) {
		 if (dr.scopeData != null) {
			 int ix = tl * 3 + td;
			 ScopeData sd = dr.scopeData[ix];
			 if (sd != null) {
				 String suffix = sd.suffix;
				 if (suffix != null) {
					 if (trace) {
						 System.out.println(""appendSuffix '"" + suffix + ""'"");
					 }
					 sb.append(suffix);
				 }
			 }
		 }
	 }
	 public boolean appendUnit(TimeUnit unit, int count, int cv, int uv, boolean useCountSep, boolean useDigitPrefix, boolean multiple, boolean last, boolean wasSkipped, StringBuffer sb) {
		 int px = unit.ordinal();
		 boolean willRequireSkipMarker = false;
		 if (dr.requiresSkipMarker != null && dr.requiresSkipMarker[px] && dr.skippedUnitMarker != null) {
			 if (!wasSkipped && last) {
				 sb.append(dr.skippedUnitMarker);
			 }
			 willRequireSkipMarker = true;
		 }
		 if (uv != EUnitVariant.PLURALIZED) {
			 boolean useMedium = uv == EUnitVariant.MEDIUM;
			 String[] names = useMedium ? dr.mediumNames : dr.shortNames;
			 if (names == null || names[px] == null) {
				 names = useMedium ? dr.shortNames : dr.mediumNames;
			 }
			 if (names != null && names[px] != null) {
				 appendCount(unit, false, false, count, cv, useCountSep, names[px], last, sb);
				 return false;
			 }
		 }
		 if (cv == ECountVariant.HALF_FRACTION && dr.halfSupport != null) {
			 switch (dr.halfSupport[px]) {
				 case EHalfSupport.YES: break;
				 case EHalfSupport.ONE_PLUS: if (count > 1000) {
					 break;
				 }
				 case EHalfSupport.NO: {
					 count = (count / 500) * 500;
					 cv = ECountVariant.DECIMAL1;
				 }
				 break;
			 }
		 }
		 String name = null;
		 int form = computeForm(unit, count, cv, multiple && last);
		 if (form == FORM_SINGULAR_SPELLED) {
			 if (dr.singularNames == null) {
				 form = FORM_SINGULAR;
				 name = dr.pluralNames[px][form];
			 }
			 else {
				 name = dr.singularNames[px];
			 }
		 }
		 else if (form == FORM_SINGULAR_NO_OMIT) {
			 name = dr.pluralNames[px][FORM_SINGULAR];
		 }
		 else if (form == FORM_HALF_SPELLED) {
			 name = dr.halfNames[px];
		 }
		 else {
			 try {
				 name = dr.pluralNames[px][form];
			 }
			 catch (NullPointerException e) {
				 System.out.println(""Null Pointer in PeriodFormatterData[""+localeName+""].au px: "" + px + "" form: "" + form + "" pn: "" + Arrays.toString(dr.pluralNames));
				 throw e;
			 }
		 }
		 if (name == null) {
			 form = FORM_PLURAL;
			 name = dr.pluralNames[px][form];
		 }
		 boolean omitCount = (form == FORM_SINGULAR_SPELLED || form == FORM_HALF_SPELLED) || (dr.omitSingularCount && form == FORM_SINGULAR) || (dr.omitDualCount && form == FORM_DUAL);
		 int suffixIndex = appendCount(unit, omitCount, useDigitPrefix, count, cv, useCountSep, name, last, sb);
		 if (last && suffixIndex >= 0) {
			 String suffix = null;
			 if (dr.rqdSuffixes != null && suffixIndex < dr.rqdSuffixes.length) {
				 suffix = dr.rqdSuffixes[suffixIndex];
			 }
			 if (suffix == null && dr.optSuffixes != null && suffixIndex < dr.optSuffixes.length) {
				 suffix = dr.optSuffixes[suffixIndex];
			 }
			 if (suffix != null) {
				 sb.append(suffix);
			 }
		 }
		 return willRequireSkipMarker;
	 }
	 public int appendCount(TimeUnit unit, boolean omitCount, boolean useDigitPrefix, int count, int cv, boolean useSep, String name, boolean last, StringBuffer sb) {
		 if (cv == ECountVariant.HALF_FRACTION && dr.halves == null) {
			 cv = ECountVariant.INTEGER;
		 }
		 if (!omitCount && useDigitPrefix && dr.digitPrefix != null) {
			 sb.append(dr.digitPrefix);
		 }
		 int index = unit.ordinal();
		 switch (cv) {
			 case ECountVariant.INTEGER: {
				 if (!omitCount) {
					 appendInteger(count/1000, 1, 10, sb);
				 }
			 }
			 break;
			 case ECountVariant.INTEGER_CUSTOM: {
				 int val = count / 1000;
				 if (unit == TimeUnit.MINUTE && (dr.fiveMinutes != null || dr.fifteenMinutes != null)) {
					 if (val != 0 && val % 5 == 0) {
						 if (dr.fifteenMinutes != null && (val == 15 || val == 45)) {
							 val = val == 15 ? 1 : 3;
							 if (!omitCount) appendInteger(val, 1, 10, sb);
							 name = dr.fifteenMinutes;
							 index = 8;
							 break;
						 }
						 if (dr.fiveMinutes != null) {
							 val = val / 5;
							 if (!omitCount) appendInteger(val, 1, 10, sb);
							 name = dr.fiveMinutes;
							 index = 9;
							 break;
						 }
					 }
				 }
				 if (!omitCount) appendInteger(val, 1, 10, sb);
			 }
			 break;
			 case ECountVariant.HALF_FRACTION: {
				 int v = count / 500;
				 if (v != 1) {
					 if (!omitCount) appendCountValue(count, 1, 0, sb);
				 }
				 if ((v & 0x1) == 1) {
					 if (v == 1 && dr.halfNames != null && dr.halfNames[index] != null) {
						 sb.append(name);
						 return last ? index : -1;
					 }
					 int solox = v == 1 ? 0 : 1;
					 if (dr.genders != null && dr.halves.length > 2) {
						 if (dr.genders[index] == EGender.F) {
							 solox += 2;
						 }
					 }
					 int hp = dr.halfPlacements == null ? EHalfPlacement.PREFIX : dr.halfPlacements[solox & 0x1];
					 String half = dr.halves[solox];
					 String measure = dr.measures == null ? null : dr.measures[index];
					 switch (hp) {
						 case EHalfPlacement.PREFIX: sb.append(half);
						 break;
						 case EHalfPlacement.AFTER_FIRST: {
							 if (measure != null) {
								 sb.append(measure);
								 sb.append(half);
								 if (useSep && !omitCount) {
									 sb.append(dr.countSep);
								 }
								 sb.append(name);
							 }
							 else {
								 sb.append(name);
								 sb.append(half);
								 return last ? index : -1;
							 }
						 }
						 return -1;
						 case EHalfPlacement.LAST: {
							 if (measure != null) {
								 sb.append(measure);
							 }
							 if (useSep && !omitCount) {
								 sb.append(dr.countSep);
							 }
							 sb.append(name);
							 sb.append(half);
						 }
						 return last ? index : -1;
					 }
				 }
			 }
			 break;
			 default: {
				 int decimals = 1;
				 switch (cv) {
					 case ECountVariant.DECIMAL2: decimals = 2;
					 break;
					 case ECountVariant.DECIMAL3: decimals = 3;
					 break;
					 default: break;
				 }
				 if (!omitCount) appendCountValue(count, 1, decimals, sb);
			 }
			 break;
		 }
		 if (!omitCount && useSep) {
			 sb.append(dr.countSep);
		 }
		 if (!omitCount && dr.measures != null && index < dr.measures.length) {
			 String measure = dr.measures[index];
			 if (measure != null) {
				 sb.append(measure);
			 }
		 }
		 sb.append(name);
		 return last ? index : -1;
	 }
	 public void appendCountValue(int count, int integralDigits, int decimalDigits, StringBuffer sb) {
		 int ival = count / 1000;
		 if (decimalDigits == 0) {
			 appendInteger(ival, integralDigits, 10, sb);
			 return;
		 }
		 if (dr.requiresDigitSeparator && sb.length() > 0) {
			 sb.append(' ');
		 }
		 appendDigits(ival, integralDigits, 10, sb);
		 int dval = count % 1000;
		 if (decimalDigits == 1) {
			 dval /= 100;
		 }
		 else if (decimalDigits == 2) {
			 dval /= 10;
		 }
		 sb.append(dr.decimalSep);
		 appendDigits(dval, decimalDigits, decimalDigits, sb);
		 if (dr.requiresDigitSeparator) {
			 sb.append(' ');
		 }
	 }
	 public void appendInteger(int num, int mindigits, int maxdigits, StringBuffer sb) {
		 if (dr.numberNames != null && num < dr.numberNames.length) {
			 String name = dr.numberNames[num];
			 if (name != null) {
				 sb.append(name);
				 return;
			 }
		 }
		 if (dr.requiresDigitSeparator && sb.length() > 0) {
			 sb.append(' ');
		 }
		 switch (dr.numberSystem) {
			 case ENumberSystem.DEFAULT: appendDigits(num, mindigits, maxdigits, sb);
			 break;
			 case ENumberSystem.CHINESE_TRADITIONAL: sb.append( Utils.chineseNumber(num, Utils.ChineseDigits.TRADITIONAL));
			 break;
			 case ENumberSystem.CHINESE_SIMPLIFIED: sb.append( Utils.chineseNumber(num, Utils.ChineseDigits.SIMPLIFIED));
			 break;
			 case ENumberSystem.KOREAN: sb.append( Utils.chineseNumber(num, Utils.ChineseDigits.KOREAN));
			 break;
		 }
		 if (dr.requiresDigitSeparator) {
			 sb.append(' ');
		 }
	 }
	 public void appendDigits(long num, int mindigits, int maxdigits, StringBuffer sb) {
		 char[] buf = new char[maxdigits];
		 int ix = maxdigits;
		 while (ix > 0 && num > 0) {
			 buf[--ix] = (char)(dr.zero + (num % 10));
			 num /= 10;
		 }
		 for (int e = maxdigits - mindigits;
		 ix > e;
		) {
			 buf[--ix] = dr.zero;
		 }
		 sb.append(buf, ix, maxdigits - ix);
	 }
	 public void appendSkippedUnit(StringBuffer sb) {
		 if (dr.skippedUnitMarker != null) {
			 sb.append(dr.skippedUnitMarker);
		 }
	 }
	 public boolean appendUnitSeparator(TimeUnit unit, boolean longSep, boolean afterFirst, boolean beforeLast, StringBuffer sb) {
		 if ((longSep && dr.unitSep != null) || dr.shortUnitSep != null) {
			 if (longSep && dr.unitSep != null) {
				 int ix = (afterFirst ? 2 : 0) + (beforeLast ? 1 : 0);
				 sb.append(dr.unitSep[ix]);
				 return dr.unitSepRequiresDP != null && dr.unitSepRequiresDP[ix];
			 }
			 sb.append(dr.shortUnitSep);
		 }
		 return false;
	 }
	 private static final int FORM_PLURAL = 0, FORM_SINGULAR = 1, FORM_DUAL = 2, FORM_PAUCAL = 3, FORM_SINGULAR_SPELLED = 4, FORM_SINGULAR_NO_OMIT = 5, FORM_HALF_SPELLED = 6;
	 private int computeForm(TimeUnit unit, int count, int cv, boolean lastOfMultiple) {
		 if (trace) {
			 System.err.println(""pfd.cf unit: "" + unit + "" count: "" + count + "" cv: "" + cv + "" dr.pl: "" + dr.pl);
			 Thread.dumpStack();
		 }
		 if (dr.pl == EPluralization.NONE) {
			 return FORM_PLURAL;
		 }
		 int val = count/1000;
		 switch (cv) {
			 case ECountVariant.INTEGER: case ECountVariant.INTEGER_CUSTOM: {
			 }
			 break;
			 case ECountVariant.HALF_FRACTION: {
				 switch (dr.fractionHandling) {
					 case EFractionHandling.FPLURAL: return FORM_PLURAL;
					 case EFractionHandling.FSINGULAR_PLURAL_ANDAHALF: case EFractionHandling.FSINGULAR_PLURAL: {
						 int v = count / 500;
						 if (v == 1) {
							 if (dr.halfNames != null && dr.halfNames[unit.ordinal()] != null) {
								 return FORM_HALF_SPELLED;
							 }
							 return FORM_SINGULAR_NO_OMIT;
						 }
						 if ((v & 0x1) == 1) {
							 if (dr.pl == EPluralization.ARABIC && v > 21) {
								 return FORM_SINGULAR_NO_OMIT;
							 }
							 if (v == 3 && dr.pl == EPluralization.PLURAL && dr.fractionHandling != EFractionHandling.FSINGULAR_PLURAL_ANDAHALF) {
								 return FORM_PLURAL;
							 }
						 }
					 }
					 break;
					 case EFractionHandling.FPAUCAL: {
						 int v = count / 500;
						 if (v == 1 || v == 3) {
							 return FORM_PAUCAL;
						 }
					 }
					 break;
					 default: throw new IllegalStateException();
				 }
			 }
			 break;
			 default: {
				 switch (dr.decimalHandling) {
					 case EDecimalHandling.DPLURAL: break;
					 case EDecimalHandling.DSINGULAR: return FORM_SINGULAR_NO_OMIT;
					 case EDecimalHandling.DSINGULAR_SUBONE: if (count < 1000) {
						 return FORM_SINGULAR_NO_OMIT;
					 }
					 break;
					 case EDecimalHandling.DPAUCAL: if (dr.pl == EPluralization.PAUCAL) {
						 return FORM_PAUCAL;
					 }
					 break;
					 default: break;
				 }
				 return FORM_PLURAL;
			 }
		 }
		 if (trace && count == 0) {
			 System.err.println(""EZeroHandling = "" + dr.zeroHandling);
		 }
		 if (count == 0 && dr.zeroHandling == EZeroHandling.ZSINGULAR) {
			 return FORM_SINGULAR_SPELLED;
		 }
		 int form = FORM_PLURAL;
		 switch(dr.pl) {
			 case EPluralization.NONE: break;
			 case EPluralization.PLURAL: {
				 if (val == 1) {
					 form = FORM_SINGULAR_SPELLED;
				 }
			 }
			 break;
			 case EPluralization.DUAL: {
				 if (val == 2) {
					 form = FORM_DUAL;
				 }
				 else if (val == 1) {
					 form = FORM_SINGULAR;
				 }
			 }
			 break;
			 case EPluralization.PAUCAL: {
				 int v = val;
				 v = v % 100;
				 if (v > 20) {
					 v = v % 10;
				 }
				 if (v == 1) {
					 form = FORM_SINGULAR;
				 }
				 else if (v > 1 && v < 5) {
					 form = FORM_PAUCAL;
				 }
			 }
			 break;
			 case EPluralization.HEBREW: {
				 if (val == 2) {
					 form = FORM_DUAL;
				 }
				 else if (val == 1) {
					 if (lastOfMultiple) {
						 form = FORM_SINGULAR_SPELLED;
					 }
					 else {
						 form = FORM_SINGULAR;
					 }
				 }
				 else if (unit == TimeUnit.YEAR && val > 11) {
					 form = FORM_SINGULAR_NO_OMIT;
				 }
			 }
			 break;
			 case EPluralization.ARABIC: {
				 if (val == 2) {
					 form = FORM_DUAL;
				 }
				 else if (val == 1) {
					 form = FORM_SINGULAR;
				 }
				 else if (val > 10) {
					 form = FORM_SINGULAR_NO_OMIT;
				 }
			 }
			 break;
			 default: System.err.println(""dr.pl is "" + dr.pl);
			 throw new IllegalStateException();
		 }
		 return form;
	 }
}",1,0,0,0
"class LinkedRPObjectList extends LinkedList<RPObject> {
	private static final long serialVersionUID = -7221795029536087812L;
	private static final Logger logger = Log4J.getLogger(LinkedRPObjectList.class);
	public RPObject getByIDIgnoringZone(RPObject.ID id) {
		int oid = id.getObjectID();
		for (RPObject object : this) {
			if (object.getID().getObjectID() == oid) {
				return object;
			}
		}
		return null;
	}
	public boolean hasByIDIgnoringZone(RPObject.ID id) {
		int oid = id.getObjectID();
		for (RPObject object : this) {
			if (oid == object.getID().getObjectID()) {
				return true;
			}
		}
		return false;
	}
	public RPObject removeByIDIgnoringZone(RPObject.ID id) {
		int oid = id.getObjectID();
		Iterator<RPObject> itr = this.iterator();
		while (itr.hasNext()) {
			RPObject rpobject = itr.next();
			if (rpobject.getID().getObjectID() == oid) {
				itr.remove();
				return rpobject;
			}
		}
		return null;
	}
	public boolean add(RPObject object) {
		 checkObjectNotAllreadyInList(object);
		return super.add(object);
	}
	private void checkObjectNotAllreadyInList(RPObject object) {
		RPObject.ID id = object.getID();
		RPObject oldObject = getByIDIgnoringZone(id);
		if (oldObject != null) {
			if (oldObject == object) {
				logger.error(""Object cannot be added to list because it is already part of it: "" + object, new Throwable());
			}
			 else {
				 logger.error(""Object cannot be added to list because another object with the same ID is part of it. objectToAdd: "" + object + "" objectAlreadyInList: "" + oldObject, new Throwable());
			}
		}
	}
}",1,0,0,0
"public class ExecuteOn extends ExecTask {
	 protected Vector filesets = new Vector();
	 private Union resources = null;
	 private boolean relative = false;
	 private boolean parallel = false;
	 private boolean forwardSlash = false;
	 protected String type = FileDirBoth.FILE;
	 protected Commandline.Marker srcFilePos = null;
	 private boolean skipEmpty = false;
	 protected Commandline.Marker targetFilePos = null;
	 protected Mapper mapperElement = null;
	 protected FileNameMapper mapper = null;
	 protected File destDir = null;
	 private int maxParallel = -1;
	 private boolean addSourceFile = true;
	 private boolean verbose = false;
	 private boolean ignoreMissing = true;
	 private boolean force = false;
	 protected boolean srcIsFirst = true;
	 public void addFileset(FileSet set) {
		 filesets.addElement(set);
	 }
	 public void addDirset(DirSet set) {
		 filesets.addElement(set);
	 }
	 public void addFilelist(FileList list) {
		 add(list);
	 }
	 public void add(ResourceCollection rc) {
		 if (resources == null) {
			 resources = new Union();
		 }
		 resources.add(rc);
	 }
	 public void setRelative(boolean relative) {
		 this.relative = relative;
	 }
	 public void setParallel(boolean parallel) {
		 this.parallel = parallel;
	 }
	 public void setType(FileDirBoth type) {
		 this.type = type.getValue();
	 }
	 public void setSkipEmptyFilesets(boolean skip) {
		 skipEmpty = skip;
	 }
	 public void setDest(File destDir) {
		 this.destDir = destDir;
	 }
	 public void setForwardslash(boolean forwardSlash) {
		 this.forwardSlash = forwardSlash;
	 }
	 public void setMaxParallel(int max) {
		 maxParallel = max;
	 }
	 public void setAddsourcefile(boolean b) {
		 addSourceFile = b;
	 }
	 public void setVerbose(boolean b) {
		 verbose = b;
	 }
	 public void setIgnoremissing(boolean b) {
		 ignoreMissing = b;
	 }
	 public void setForce(boolean b) {
		 force = b;
	 }
	 public Commandline.Marker createSrcfile() {
		 if (srcFilePos != null) {
			 throw new BuildException(getTaskType() + "" doesn\'t support multiple "" + ""srcfile elements."", getLocation());
		 }
		 srcFilePos = cmdl.createMarker();
		 return srcFilePos;
	 }
	 public Commandline.Marker createTargetfile() {
		 if (targetFilePos != null) {
			 throw new BuildException(getTaskType() + "" doesn\'t support multiple "" + ""targetfile elements."", getLocation());
		 }
		 targetFilePos = cmdl.createMarker();
		 srcIsFirst = (srcFilePos != null);
		 return targetFilePos;
	 }
	 public Mapper createMapper() throws BuildException {
		 if (mapperElement != null) {
			 throw new BuildException(""Cannot define more than one mapper"", getLocation());
		 }
		 mapperElement = new Mapper(getProject());
		 return mapperElement;
	 }
	 public void add(FileNameMapper fileNameMapper) {
		 createMapper().add(fileNameMapper);
	 }
	 protected void checkConfiguration() {
		 if (""execon"".equals(getTaskName())) {
			 log(""!! execon is deprecated. Use apply instead. !!"");
		 }
		 super.checkConfiguration();
		 if (filesets.size() == 0 && resources == null) {
			 throw new BuildException(""no resources specified"", getLocation());
		 }
		 if (targetFilePos != null && mapperElement == null) {
			 throw new BuildException(""targetfile specified without mapper"", getLocation());
		 }
		 if (destDir != null && mapperElement == null) {
			 throw new BuildException(""dest specified without mapper"", getLocation());
		 }
		 if (mapperElement != null) {
			 mapper = mapperElement.getImplementation();
		 }
	 }
	 protected ExecuteStreamHandler createHandler() throws BuildException {
		 return (redirectorElement == null) ? super.createHandler() : new PumpStreamHandler();
	 }
	 protected void setupRedirector() {
		 super.setupRedirector();
		 redirector.setAppendProperties(true);
	 }
	 protected void runExec(Execute exe) throws BuildException {
		 int totalFiles = 0;
		 int totalDirs = 0;
		 boolean haveExecuted = false;
		 try {
			 Vector fileNames = new Vector();
			 Vector baseDirs = new Vector();
			 final int size = filesets.size();
			 for (int i = 0;
			 i < size;
			 i++) {
				 String currentType = type;
				 AbstractFileSet fs = (AbstractFileSet) filesets.elementAt(i);
				 if (fs instanceof DirSet) {
					 if (!FileDirBoth.DIR.equals(type)) {
						 log(""Found a nested dirset but type is "" + type + "". "" + ""Temporarily switching to type=\""dir\"" on the"" + "" assumption that you really did mean"" + "" <dirset> not <fileset>."", Project.MSG_DEBUG);
						 currentType = FileDirBoth.DIR;
					 }
				 }
				 File base = fs.getDir(getProject());
				 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
				 if (!FileDirBoth.DIR.equals(currentType)) {
					 String[] s = getFiles(base, ds);
					 for (int j = 0;
					 j < s.length;
					 j++) {
						 totalFiles++;
						 fileNames.addElement(s[j]);
						 baseDirs.addElement(base);
					 }
				 }
				 if (!FileDirBoth.FILE.equals(currentType)) {
					 String[] s = getDirs(base, ds);
					 for (int j = 0;
					 j < s.length;
					 j++) {
						 totalDirs++;
						 fileNames.addElement(s[j]);
						 baseDirs.addElement(base);
					 }
				 }
				 if (fileNames.size() == 0 && skipEmpty) {
					 logSkippingFileset(currentType, ds, base);
					 continue;
				 }
				 if (!parallel) {
					 String[] s = new String[fileNames.size()];
					 fileNames.copyInto(s);
					 for (int j = 0;
					 j < s.length;
					 j++) {
						 String[] command = getCommandline(s[j], base);
						 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
						 exe.setCommandline(command);
						 if (redirectorElement != null) {
							 setupRedirector();
							 redirectorElement.configure(redirector, s[j]);
						 }
						 if (redirectorElement != null || haveExecuted) {
							 exe.setStreamHandler(redirector.createHandler());
						 }
						 runExecute(exe);
						 haveExecuted = true;
					 }
					 fileNames.removeAllElements();
					 baseDirs.removeAllElements();
				 }
			 }
			 if (resources != null) {
				 Iterator iter = resources.iterator();
				 while (iter.hasNext()) {
					 Resource res = (Resource) iter.next();
					 if (!res.isExists() && ignoreMissing) {
						 continue;
					 }
					 File base = null;
					 String name = res.getName();
					 FileProvider fp = (FileProvider) res.as(FileProvider.class);
					 if (fp != null) {
						 FileResource fr = ResourceUtils.asFileResource(fp);
						 base = fr.getBaseDir();
						 if (base == null) {
							 name = fr.getFile().getAbsolutePath();
						 }
					 }
					 if (restrict(new String[] {
					name}
					, base).length == 0) {
						 continue;
					 }
					 if ((!res.isDirectory() || !res.isExists()) && !FileDirBoth.DIR.equals(type)) {
						 totalFiles++;
					 }
					 else if (res.isDirectory() && !FileDirBoth.FILE.equals(type)) {
						 totalDirs++;
					 }
					 else {
						 continue;
					 }
					 baseDirs.add(base);
					 fileNames.add(name);
					 if (!parallel) {
						 String[] command = getCommandline(name, base);
						 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
						 exe.setCommandline(command);
						 if (redirectorElement != null) {
							 setupRedirector();
							 redirectorElement.configure(redirector, name);
						 }
						 if (redirectorElement != null || haveExecuted) {
							 exe.setStreamHandler(redirector.createHandler());
						 }
						 runExecute(exe);
						 haveExecuted = true;
						 fileNames.removeAllElements();
						 baseDirs.removeAllElements();
					 }
				 }
			 }
			 if (parallel && (fileNames.size() > 0 || !skipEmpty)) {
				 runParallel(exe, fileNames, baseDirs);
				 haveExecuted = true;
			 }
			 if (haveExecuted) {
				 log(""Applied "" + cmdl.getExecutable() + "" to "" + totalFiles + "" file"" + (totalFiles != 1 ? ""s"" : """") + "" and "" + totalDirs + "" director"" + (totalDirs != 1 ? ""ies"" : ""y"") + ""."", verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(""Execute failed: "" + e, e, getLocation());
		 }
		 finally {
			 logFlush();
			 redirector.setAppendProperties(false);
			 redirector.setProperties();
		 }
	 }
	 private void logSkippingFileset( String currentType, DirectoryScanner ds, File base) {
		 int includedCount = ((!FileDirBoth.DIR.equals(currentType)) ? ds.getIncludedFilesCount() : 0) + ((!FileDirBoth.FILE.equals(currentType)) ? ds.getIncludedDirsCount() : 0);
		 log(""Skipping fileset for directory "" + base + "". It is "" + ((includedCount > 0) ? ""up to date."" : ""empty.""), verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
	 }
	 protected String[] getCommandline(String[] srcFiles, File[] baseDirs) {
		 final char fileSeparator = File.separatorChar;
		 Vector targets = new Vector();
		 if (targetFilePos != null) {
			 HashSet addedFiles = new HashSet();
			 for (int i = 0;
			 i < srcFiles.length;
			 i++) {
				 String[] subTargets = mapper.mapFileName(srcFiles[i]);
				 if (subTargets != null) {
					 for (int j = 0;
					 j < subTargets.length;
					 j++) {
						 String name = null;
						 if (!relative) {
							 name = (new File(destDir, subTargets[j])).getAbsolutePath();
						 }
						 else {
							 name = subTargets[j];
						 }
						 if (forwardSlash && fileSeparator != '/') {
							 name = name.replace(fileSeparator, '/');
						 }
						 if (!addedFiles.contains(name)) {
							 targets.addElement(name);
							 addedFiles.add(name);
						 }
					 }
				 }
			 }
		 }
		 String[] targetFiles = (String[]) targets.toArray(new String[targets.size()]);
		 if (!addSourceFile) {
			 srcFiles = new String[0];
		 }
		 String[] orig = cmdl.getCommandline();
		 String[] result = new String[orig.length + srcFiles.length + targetFiles.length];
		 int srcIndex = orig.length;
		 if (srcFilePos != null) {
			 srcIndex = srcFilePos.getPosition();
		 }
		 if (targetFilePos != null) {
			 int targetIndex = targetFilePos.getPosition();
			 if (srcIndex < targetIndex || (srcIndex == targetIndex && srcIsFirst)) {
				 System.arraycopy(orig, 0, result, 0, srcIndex);
				 System.arraycopy(orig, srcIndex, result, srcIndex + srcFiles.length, targetIndex - srcIndex);
				 insertTargetFiles(targetFiles, result, targetIndex + srcFiles.length, targetFilePos.getPrefix(), targetFilePos.getSuffix());
				 System.arraycopy(orig, targetIndex, result, targetIndex + srcFiles.length + targetFiles.length, orig.length - targetIndex);
			 }
			 else {
				 System.arraycopy(orig, 0, result, 0, targetIndex);
				 insertTargetFiles(targetFiles, result, targetIndex, targetFilePos.getPrefix(), targetFilePos.getSuffix());
				 System.arraycopy(orig, targetIndex, result, targetIndex + targetFiles.length, srcIndex - targetIndex);
				 System.arraycopy(orig, srcIndex, result, srcIndex + srcFiles.length + targetFiles.length, orig.length - srcIndex);
				 srcIndex += targetFiles.length;
			 }
		 }
		 else {
			 System.arraycopy(orig, 0, result, 0, srcIndex);
			 System.arraycopy(orig, srcIndex, result, srcIndex + srcFiles.length, orig.length - srcIndex);
		 }
		 for (int i = 0;
		 i < srcFiles.length;
		 i++) {
			 String src;
			 if (relative) {
				 src = srcFiles[i];
			 }
			 else {
				 src = new File(baseDirs[i], srcFiles[i]).getAbsolutePath();
			 }
			 if (forwardSlash && fileSeparator != '/') {
				 src = src.replace(fileSeparator, '/');
			 }
			 if (srcFilePos != null && (srcFilePos.getPrefix().length() > 0 || srcFilePos.getSuffix().length() > 0)) {
				 src = srcFilePos.getPrefix() + src + srcFilePos.getSuffix();
			 }
			 result[srcIndex + i] = src;
		 }
		 return result;
	 }
	 protected String[] getCommandline(String srcFile, File baseDir) {
		 return getCommandline(new String[] {
		srcFile}
		, new File[] {
		baseDir}
		);
	 }
	 protected String[] getFiles(File baseDir, DirectoryScanner ds) {
		 return restrict(ds.getIncludedFiles(), baseDir);
	 }
	 protected String[] getDirs(File baseDir, DirectoryScanner ds) {
		 return restrict(ds.getIncludedDirectories(), baseDir);
	 }
	 protected String[] getFilesAndDirs(FileList list) {
		 return restrict(list.getFiles(getProject()), list.getDir(getProject()));
	 }
	 private String[] restrict(String[] s, File baseDir) {
		 return (mapper == null || force) ? s : new SourceFileScanner(this).restrict(s, baseDir, destDir, mapper);
	 }
	 protected void runParallel(Execute exe, Vector fileNames, Vector baseDirs) throws IOException, BuildException {
		 String[] s = new String[fileNames.size()];
		 fileNames.copyInto(s);
		 File[] b = new File[baseDirs.size()];
		 baseDirs.copyInto(b);
		 if (maxParallel <= 0 || s.length == 0 ) {
			 String[] command = getCommandline(s, b);
			 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
			 exe.setCommandline(command);
			 if (redirectorElement != null) {
				 setupRedirector();
				 redirectorElement.configure(redirector, null);
				 exe.setStreamHandler(redirector.createHandler());
			 }
			 runExecute(exe);
		 }
		 else {
			 int stillToDo = fileNames.size();
			 int currentOffset = 0;
			 while (stillToDo > 0) {
				 int currentAmount = Math.min(stillToDo, maxParallel);
				 String[] cs = new String[currentAmount];
				 System.arraycopy(s, currentOffset, cs, 0, currentAmount);
				 File[] cb = new File[currentAmount];
				 System.arraycopy(b, currentOffset, cb, 0, currentAmount);
				 String[] command = getCommandline(cs, cb);
				 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
				 exe.setCommandline(command);
				 if (redirectorElement != null) {
					 setupRedirector();
					 redirectorElement.configure(redirector, null);
				 }
				 if (redirectorElement != null || currentOffset > 0) {
					 exe.setStreamHandler(redirector.createHandler());
				 }
				 runExecute(exe);
				 stillToDo -= currentAmount;
				 currentOffset += currentAmount;
			 }
		 }
	 }
	 private static void insertTargetFiles(String[] targetFiles, String[] arguments, int insertPosition, String prefix, String suffix) {
		 if (prefix.length() == 0 && suffix.length() == 0) {
			 System.arraycopy(targetFiles, 0, arguments, insertPosition, targetFiles.length);
		 }
		 else {
			 for (int i = 0;
			 i < targetFiles.length;
			 i++) {
				 arguments[insertPosition + i] = prefix + targetFiles[i] + suffix;
			 }
		 }
	 }
	 public static class FileDirBoth extends EnumeratedAttribute {
		 public static final String FILE = ""file"";
		 public static final String DIR = ""dir"";
		 public String[] getValues() {
			 return new String[] {
			FILE, DIR, ""both""}
			;
		 }
	 }
}",0,0,0,0
"public final class PluginArchiver {
	 private static final String DESCRIPTOR_ENTRY_NAME = ""JPF-DESCRIPTOR"";
	 public static void pack(final PluginDescriptor descr, final PathResolver pathResolver, final File destFile) throws IOException {
		 pack(pathResolver.resolvePath(descr, ""/""), ""JPF plug-in ""+ descr.getId() + "" of version "" + descr.getVersion(), destFile);
	 }
	 public static void pack(final PluginFragment fragment, final PathResolver pathResolver, final File destFile) throws IOException {
		 pack(pathResolver.resolvePath(fragment, ""/""), ""JPF plug-in fragment ""+ fragment.getId() + "" of version "" + fragment.getVersion(), destFile);
	 }
	 private static void pack(final URL url, final String comment, final File destFile) throws IOException {
		 ZipOutputStream zipStrm = new ZipOutputStream( new BufferedOutputStream(new FileOutputStream( destFile, false)));
		 try {
			 zipStrm.setComment(comment);
			 File file = IoUtil.url2file(url);
			 if (file == null) {
				 throw new IOException(""resolved URL "" + url + "" is not local file system location pointer"");
			 }
			 File[] files = file.listFiles();
			 for (int i = 0;
			 i < files.length;
			 i++) {
				 packEntry(zipStrm, null, files[i]);
			 }
		 }
		 finally {
			 zipStrm.close();
		 }
	 }
	 public static Collection pack(final PluginRegistry registry, final PathResolver pathResolver, final File destFile) throws IOException {
		 return pack(registry, pathResolver, destFile, new Filter() {
			 public boolean accept(final String id, final Version version, final boolean isFragment) {
				 return true;
			 }
		 }
		);
	 }
	 public static Collection pack(final PluginRegistry registry, final PathResolver pathResolver, final File destFile, final Filter filter) throws IOException {
		 Set result;
		 ZipOutputStream zipStrm = new ZipOutputStream( new BufferedOutputStream(new FileOutputStream( destFile, false)));
		 try {
			 zipStrm.setComment(""JPF plug-ins archive"");
			 ZipEntry entry = new ZipEntry(DESCRIPTOR_ENTRY_NAME);
			 entry.setComment(""JPF plug-ins archive descriptor"");
			 zipStrm.putNextEntry(entry);
			 result = writeDescripor(registry, filter, new ObjectOutputStream(zipStrm));
			 zipStrm.closeEntry();
			 for (Iterator it = registry.getPluginDescriptors().iterator();
			 it.hasNext();
			) {
				 PluginDescriptor descr = (PluginDescriptor) it.next();
				 if (!result.contains(descr.getUniqueId())) {
					 continue;
				 }
				 URL url = pathResolver.resolvePath(descr, ""/"");
				 File file = IoUtil.url2file(url);
				 if (file == null) {
					 throw new IOException(""resolved URL "" + url + "" is not local file system location pointer"");
				 }
				 entry = new ZipEntry(descr.getUniqueId() + ""/"");
				 entry.setComment(""Content for JPF plug-in "" + descr.getId() + "" version "" + descr.getVersion());
				 entry.setTime(file.lastModified());
				 zipStrm.putNextEntry(entry);
				 File[] files = file.listFiles();
				 for (int i = 0;
				 i < files.length;
				 i++) {
					 packEntry(zipStrm, entry, files[i]);
				 }
			 }
			 for (Iterator it = registry.getPluginFragments().iterator();
			 it.hasNext();
			) {
				 PluginFragment fragment = (PluginFragment) it.next();
				 if (!result.contains(fragment.getUniqueId())) {
					 continue;
				 }
				 URL url = pathResolver.resolvePath(fragment, ""/"");
				 File file = IoUtil.url2file(url);
				 if (file == null) {
					 throw new IOException(""resolved URL "" + url + "" is not local file system location pointer"");
				 }
				 entry = new ZipEntry(fragment.getUniqueId() + ""/"");
				 entry.setComment(""Content for JPF plug-in fragment "" + fragment.getId() + "" version "" + fragment.getVersion());
				 entry.setTime(file.lastModified());
				 zipStrm.putNextEntry(entry);
				 File[] files = file.listFiles();
				 for (int i = 0;
				 i < files.length;
				 i++) {
					 packEntry(zipStrm, entry, files[i]);
				 }
			 }
		 }
		 finally {
			 zipStrm.close();
		 }
		 return result;
	 }
	 private static void packEntry(final ZipOutputStream zipStrm, final ZipEntry parentEntry, final File file) throws IOException {
		 String parentEntryName = (parentEntry == null) ? """" : parentEntry.getName();
		 if (file.isFile()) {
			 ZipEntry entry = new ZipEntry(parentEntryName + file.getName());
			 entry.setTime(file.lastModified());
			 zipStrm.putNextEntry(entry);
			 BufferedInputStream fileStrm = new BufferedInputStream( new FileInputStream(file));
			 try {
				 IoUtil.copyStream(fileStrm, zipStrm, 1024);
			 }
			 finally {
				 fileStrm.close();
			 }
			 return;
		 }
		 ZipEntry entry = new ZipEntry(parentEntryName + file.getName() + ""/"");
		 entry.setTime(file.lastModified());
		 zipStrm.putNextEntry(entry);
		 File[] files = file.listFiles();
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 packEntry(zipStrm, entry, files[i]);
		 }
	 }
	 public static Collection unpack(final URL archiveFile, final PluginRegistry registry, final File destFolder) throws ManifestProcessingException, IOException, ClassNotFoundException {
		 return unpack(archiveFile, registry, destFolder, new Filter() {
			 public boolean accept(final String id, final Version version, final boolean isFragment) {
				 return true;
			 }
		 }
		);
	 }
	 public static Collection unpack(final URL archiveFile, final PluginRegistry registry, final File destFolder, final Filter filter) throws IOException, ManifestProcessingException, ClassNotFoundException {
		 Set result;
		 int count = 0;
		 ZipInputStream zipStrm = new ZipInputStream(new BufferedInputStream( archiveFile.openStream()));
		 try {
			 ZipEntry entry = zipStrm.getNextEntry();
			 if (entry == null) {
				 throw new IOException( ""invalid plug-ins archive, no entries found"");
			 }
			 if (!DESCRIPTOR_ENTRY_NAME.equals(entry.getName())) {
				 throw new IOException(""invalid plug-ins archive "" + archiveFile + "", entry "" + DESCRIPTOR_ENTRY_NAME + "" not found as first ZIP entry in the archive file"");
			 }
			 ObjectInputStream strm = new ObjectInputStream(zipStrm);
			 result = readDescriptor(strm, registry, destFolder, filter);
			 entry = zipStrm.getNextEntry();
			 while (entry != null) {
				 String name = entry.getName();
				 if (name.endsWith(""/"") && (name.lastIndexOf('/', name.length() - 2) == -1)) {
					 String uid = name.substring(0, name.length() - 1);
					 if (!result.contains(uid)) {
						 entry = zipStrm.getNextEntry();
						 continue;
					 }
					 count++;
				 }
				 else {
					 int p = name.indexOf('/');
					 if ((p == -1) || (p == 0) || !result.contains(name.substring(0, p))) {
						 entry = zipStrm.getNextEntry();
						 continue;
					 }
				 }
				 unpackEntry(zipStrm, entry, destFolder);
				 entry = zipStrm.getNextEntry();
			 }
		 }
		 finally {
			 zipStrm.close();
		 }
		 if (result.size() != count) {
			 throw new IOException(""invalid plug-ins number ("" + count + "") found in the archive, expected number according to "" + ""the archive descriptor is "" + result.size());
		 }
		 return result;
	 }
	 public static Collection unpack(final URL archiveFile, final File destFolder) throws ManifestProcessingException, IOException, ClassNotFoundException {
		 return unpack(archiveFile, ObjectFactory.newInstance().createRegistry(), destFolder);
	 }
	 public static Collection unpack(final URL archiveFile, final File destFolder, final Filter filter) throws ManifestProcessingException, IOException, ClassNotFoundException {
		 return unpack(archiveFile, ObjectFactory.newInstance().createRegistry(), destFolder, filter);
	 }
	 private static void unpackEntry(final ZipInputStream zipStrm, final ZipEntry entry, final File destFolder) throws IOException {
		 String name = entry.getName();
		 if (name.endsWith(""/"")) {
			 File folder = new File(destFolder.getCanonicalPath() + ""/"" + name);
			 if (!folder.exists() && !folder.mkdirs()) {
				 throw new IOException(""can't create folder "" + folder);
			 }
			 folder.setLastModified(entry.getTime());
			 return;
		 }
		 File file = new File(destFolder.getCanonicalPath() + ""/"" + name);
		 File folder = file.getParentFile();
		 if (!folder.exists() && !folder.mkdirs()) {
			 throw new IOException(""can't create folder "" + folder);
		 }
		 OutputStream strm = new BufferedOutputStream( new FileOutputStream(file, false));
		 try {
			 IoUtil.copyStream(zipStrm, strm, 1024);
		 }
		 finally {
			 strm.close();
		 }
		 file.setLastModified(entry.getTime());
	 }
	 public static Collection readDescriptor(final URL archiveFile, final PluginRegistry registry) throws IOException, ClassNotFoundException, ManifestProcessingException {
		 return readDescriptor(archiveFile, registry, new Filter() {
			 public boolean accept(final String id, final Version version, final boolean isFragment) {
				 return true;
			 }
		 }
		);
	 }
	 public static Collection readDescriptor(final URL archiveFile, final PluginRegistry registry, final Filter filter) throws IOException, ClassNotFoundException, ManifestProcessingException {
		 ZipInputStream zipStrm = new ZipInputStream(new BufferedInputStream( archiveFile.openStream()));
		 try {
			 ZipEntry entry = zipStrm.getNextEntry();
			 if (entry == null) {
				 throw new IOException( ""invalid plug-ins archive, no entries found"");
			 }
			 if (!DESCRIPTOR_ENTRY_NAME.equals(entry.getName())) {
				 throw new IOException(""invalid plug-ins archive "" + archiveFile + "", entry "" + DESCRIPTOR_ENTRY_NAME + "" not found as first ZIP entry in the archive file"");
			 }
			 ObjectInputStream strm = new ObjectInputStream(zipStrm);
			 return readDescriptor(strm, registry, Util.getTempFolder(), filter);
		 }
		 finally {
			 zipStrm.close();
		 }
	 }
	 private static Set writeDescripor(final PluginRegistry registry, final Filter filter, final ObjectOutputStream strm) throws IOException {
		 Map result = new HashMap();
		 for (Iterator it = registry.getPluginDescriptors().iterator();
		 it.hasNext();
		) {
			 PluginDescriptor descr = (PluginDescriptor) it.next();
			 if (!filter.accept(descr.getId(), descr.getVersion(), false)) {
				 continue;
			 }
			 result.put(descr.getUniqueId(), new ArchiveDescriptorEntry(descr.getId(), descr.getVersion(), false, Util.readUrlContent(descr.getLocation())));
		 }
		 for (Iterator it = registry.getPluginFragments().iterator();
		 it.hasNext();
		) {
			 PluginFragment fragment = (PluginFragment) it.next();
			 if (!filter.accept(fragment.getId(), fragment.getVersion(), true)) {
				 continue;
			 }
			 result.put(fragment.getUniqueId(), new ArchiveDescriptorEntry(fragment.getId(), fragment.getVersion(), true, Util.readUrlContent(fragment.getLocation())));
		 }
		 strm.writeObject(result.values().toArray( new ArchiveDescriptorEntry[result.size()]));
		 return result.keySet();
	 }
	 private static Set readDescriptor(final ObjectInputStream strm, final PluginRegistry registry, final File tempFolder, final Filter filter) throws IOException, ClassNotFoundException, ManifestProcessingException {
		 ArchiveDescriptorEntry[] data = (ArchiveDescriptorEntry[]) strm.readObject();
		 Set urls = new HashSet();
		 Set files = new HashSet();
		 for (int i = 0;
		 i < data.length;
		 i++) {
			 if (!filter.accept(data[i].getId(), data[i].getVersion(), data[i].isFragment())) {
				 continue;
			 }
			 File file = File.createTempFile(""manifest."", null, tempFolder);
			 file.deleteOnExit();
			 OutputStream fileStrm = new BufferedOutputStream( new FileOutputStream(file, false));
			 try {
				 fileStrm.write(data[i].getData());
			 }
			 finally {
				 fileStrm.close();
			 }
			 files.add(file);
			 urls.add(IoUtil.file2url(file));
		 }
		 Set result = new HashSet();
		 try {
			 for (Iterator it = registry.register((URL[]) urls.toArray( new URL[urls.size()])).values().iterator();
			 it.hasNext();
			) {
				 Object obj = it.next();
				 if (obj instanceof PluginDescriptor) {
					 result.add(((PluginDescriptor) obj).getUniqueId());
				 }
				 else if (obj instanceof PluginFragment) {
					 result.add(((PluginFragment) obj).getUniqueId());
				 }
				 else {
				 }
			 }
		 }
		 finally {
			 for (Iterator it = files.iterator();
			 it.hasNext();
			) {
				 ((File) it.next()).delete();
			 }
		 }
		 return result;
	 }
	 private PluginArchiver() {
	 }
	 public static interface Filter {
		 boolean accept(String id, Version version, boolean isFragment);
	 }
	 private static class ArchiveDescriptorEntry implements Serializable {
		 private static final long serialVersionUID = 8749937247555974932L;
		 private final String id;
		 private final Version version;
		 private final boolean isFragment;
		 private final byte[] data;
		 protected ArchiveDescriptorEntry(final String anId, final Version aVersion, final boolean fragment, final byte[] aData) {
			 id = anId;
			 version = aVersion;
			 isFragment = fragment;
			 data = aData;
		 }
		 protected String getId() {
			 return id;
		 }
		 protected Version getVersion() {
			 return version;
		 }
		 protected boolean isFragment() {
			 return isFragment;
		 }
		 protected byte[] getData() {
			 return data;
		 }
	 }
}",1,0,0,0
"public int from(MemberGroupLayout.ColumnSpans columnSpans) {
	 if (this == LEFT) return columnSpans.getLeft();
	 if (this == MIDDLE) return columnSpans.getMiddle();
	 if (this == RIGHT) return columnSpans.getRight();
	 throw new IllegalStateException();
 }",0,0,0,0
"int loadFSEdits( Configuration conf ) throws IOException {
	 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
	 FSDirectory fsDir = fsNamesys.dir;
	 int numEdits = 0;
	 int logVersion = 0;
	 if (editsFile.exists()) {
		 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(editsFile)));
		 in.mark( 4 );
		 if( in.available() > 0 ) {
			 logVersion = in.readByte();
			 in.reset();
			 if( logVersion >= 0 ) logVersion = 0;
			 else logVersion = in.readInt();
			 if( logVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IOException( ""Unexpected version of the file system log file: "" + logVersion + "". Current version = "" + FSConstants.DFS_CURRENT_VERSION + ""."" );
		 }
		 short replication = (short)conf.getInt(""dfs.replication"", 3);
		 try {
			 while (in.available() > 0) {
				 byte opcode = in.readByte();
				 numEdits++;
				 switch (opcode) {
					 case OP_ADD: {
						 UTF8 name = new UTF8();
						 ArrayWritable aw = null;
						 Writable writables[];
						 if( logVersion >= 0 ) name.readFields(in);
						 else {
							 aw = new ArrayWritable(UTF8.class);
							 aw.readFields(in);
							 writables = aw.get();
							 if( writables.length != 2 ) throw new IOException(""Incorrect data fortmat. "" + ""Name & replication pair expected"");
							 name = (UTF8) writables[0];
							 replication = Short.parseShort( ((UTF8)writables[1]).toString());
							 replication = adjustReplication( replication, conf );
						 }
						 aw = new ArrayWritable(Block.class);
						 aw.readFields(in);
						 writables = aw.get();
						 Block blocks[] = new Block[writables.length];
						 System.arraycopy(writables, 0, blocks, 0, blocks.length);
						 fsDir.unprotectedAddFile(name, blocks, replication );
						 break;
					 }
					 case OP_SET_REPLICATION: {
						 UTF8 src = new UTF8();
						 UTF8 repl = new UTF8();
						 src.readFields(in);
						 repl.readFields(in);
						 replication = adjustReplication( fromLogReplication(repl), conf);
						 fsDir.unprotectedSetReplication(src.toString(), replication, null);
						 break;
					 }
					 case OP_RENAME: {
						 UTF8 src = new UTF8();
						 UTF8 dst = new UTF8();
						 src.readFields(in);
						 dst.readFields(in);
						 fsDir.unprotectedRenameTo(src, dst);
						 break;
					 }
					 case OP_DELETE: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedDelete(src);
						 break;
					 }
					 case OP_MKDIR: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedMkdir(src.toString());
						 break;
					 }
					 case OP_DATANODE_ADD: {
						 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
						 DatanodeDescriptor node = new DatanodeDescriptor();
						 node.readFields(in);
						 fsNamesys.unprotectedAddDatanode( node );
						 break;
					 }
					 case OP_DATANODE_REMOVE: {
						 if( logVersion > -3 ) throw new IOException(""Unexpected opcode "" + opcode + "" for version "" + logVersion );
						 DatanodeID nodeID = new DatanodeID();
						 nodeID.readFields(in);
						 DatanodeDescriptor node = fsNamesys.getDatanode( nodeID );
						 if( node != null ) {
							 fsNamesys.unprotectedRemoveDatanode( node );
							 fsNamesys.wipeDatanode( nodeID );
						 }
						 break;
					 }
					 default: {
						 throw new IOException(""Never seen opcode "" + opcode);
					 }
				 }
			 }
		 }
		 finally {
			 in.close();
		 }
	 }
	 if( logVersion != FSConstants.DFS_CURRENT_VERSION ) numEdits++;
	 return numEdits;
 }",0,0,1,0
"private static class TAppendStandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
	 public TAppendStandardScheme getScheme() {
		 return new TAppendStandardScheme();
	 }
 }",0,0,0,0
"protected void addSchemaLocations() {
	 Iterator it = schemaLocations.values().iterator();
	 StringBuffer buffer = new StringBuffer();
	 int count = 0;
	 while (it.hasNext()) {
		 if (count > 0) {
			 buffer.append(' ');
		 }
		 SchemaLocation schemaLocation = (SchemaLocation) it.next();
		 String tuple = schemaLocation.getURIandLocation();
		 buffer.append(tuple);
		 log(""Adding schema "" + tuple, Project.MSG_VERBOSE);
		 count++;
	 }
	 if (count > 0) {
		 setProperty(XmlConstants.PROPERTY_SCHEMA_LOCATION, buffer.toString());
	 }
 }",0,0,0,0
"public String getKeepTaskFilesPattern() {
	 return get(""keep.task.files.pattern"");
 }",0,0,0,0
"protected boolean validateToken(String token) {
	 try {
		 SignedJWT signed = SignedJWT.parse(token);
		 boolean sigValid = validateSignature(signed);
		 if (!sigValid) {
			 LOGGER.warn(""Signature of JWT token could not be verified. Please check the public key"");
			 return false;
		 }
		 boolean expValid = validateExpiration(signed);
		 if (!expValid) {
			 LOGGER.warn(""Expiration time validation of JWT token failed."");
			 return false;
		 }
		 String currentUser = (String) org.apache.shiro.SecurityUtils.getSubject().getPrincipal();
		 if (currentUser == null) {
			 return true;
		 }
		 String cookieUser = signed.getJWTClaimsSet().getSubject();
		 if (!cookieUser.equals(currentUser)) {
			 return false;
		 }
		 return true;
	 }
	 catch (ParseException ex) {
		 LOGGER.info(""ParseException in validateToken"", ex);
		 return false;
	 }
 }",0,0,1,0
"public abstract class LFOAbstractType{
	 protected int field_1_lsid;
	 protected int field_2_unused1;
	 protected int field_3_unused2;
	 protected byte field_4_clfolvl;
	 protected byte field_5_ibstFltAutoNum;
	 protected Grfhic field_6_grfhic;
	 protected byte field_7_unused3;
	 protected LFOAbstractType() {
		 this.field_6_grfhic = new Grfhic();
	 }
	 protected void fillFields( byte[] data, int offset ) {
		 field_1_lsid = LittleEndian.getInt( data, 0x0 + offset );
		 field_2_unused1 = LittleEndian.getInt( data, 0x4 + offset );
		 field_3_unused2 = LittleEndian.getInt( data, 0x8 + offset );
		 field_4_clfolvl = data[ 0xc + offset ];
		 field_5_ibstFltAutoNum = data[ 0xd + offset ];
		 field_6_grfhic = new Grfhic( data, 0xe + offset );
		 field_7_unused3 = data[ 0xf + offset ];
	 }
	 public void serialize( byte[] data, int offset ) {
		 LittleEndian.putInt( data, 0x0 + offset, field_1_lsid );
		 LittleEndian.putInt( data, 0x4 + offset, field_2_unused1 );
		 LittleEndian.putInt( data, 0x8 + offset, field_3_unused2 );
		 data[ 0xc + offset ] = field_4_clfolvl;
		 data[ 0xd + offset ] = field_5_ibstFltAutoNum;
		 field_6_grfhic.serialize( data, 0xe + offset );
		 data[ 0xf + offset ] = field_7_unused3;
	 }
	 public byte[] serialize() {
		 final byte[] result = new byte[ getSize() ];
		 serialize( result, 0 );
		 return result;
	 }
	 public static int getSize() {
		 return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;
	 }
	 public boolean equals( Object obj ) {
		 if ( this == obj ) return true;
		 if ( obj == null ) return false;
		 if ( getClass() != obj.getClass() ) return false;
		 LFOAbstractType other = (LFOAbstractType) obj;
		 if ( field_1_lsid != other.field_1_lsid ) return false;
		 if ( field_2_unused1 != other.field_2_unused1 ) return false;
		 if ( field_3_unused2 != other.field_3_unused2 ) return false;
		 if ( field_4_clfolvl != other.field_4_clfolvl ) return false;
		 if ( field_5_ibstFltAutoNum != other.field_5_ibstFltAutoNum ) return false;
		 if ( field_6_grfhic == null ) {
			 if ( other.field_6_grfhic != null ) return false;
		 }
		 else if ( !field_6_grfhic.equals( other.field_6_grfhic ) ) return false;
		 if ( field_7_unused3 != other.field_7_unused3 ) return false;
		 return true;
	 }
	 public int hashCode() {
		 final int prime = 31;
		 int result = 1;
		 result = prime * result + field_1_lsid;
		 result = prime * result + field_2_unused1;
		 result = prime * result + field_3_unused2;
		 result = prime * result + field_4_clfolvl;
		 result = prime * result + field_5_ibstFltAutoNum;
		 result = prime * result + ((field_6_grfhic == null) ? 0 : field_6_grfhic.hashCode());
		 result = prime * result + field_7_unused3;
		 return result;
	 }
	 public String toString() {
		 StringBuilder builder = new StringBuilder();
		 builder.append(""[LFO]\n"");
		 builder.append( "" .lsid = "" );
		 builder.append("" ( "").append( field_1_lsid ).append( "" )\n"" );
		 builder.append( "" .unused1 = "" );
		 builder.append("" ( "").append( field_2_unused1 ).append( "" )\n"" );
		 builder.append( "" .unused2 = "" );
		 builder.append("" ( "").append( field_3_unused2 ).append( "" )\n"" );
		 builder.append( "" .clfolvl = "" );
		 builder.append("" ( "").append( field_4_clfolvl ).append( "" )\n"" );
		 builder.append( "" .ibstFltAutoNum = "" );
		 builder.append("" ( "").append( field_5_ibstFltAutoNum ).append( "" )\n"" );
		 builder.append( "" .grfhic = "" );
		 builder.append("" ( "").append( field_6_grfhic == null ? ""null"" : field_6_grfhic.toString().replaceAll( ""\n"", ""\n "" ) ).append( "" )\n"" );
		 builder.append( "" .unused3 = "" );
		 builder.append("" ( "").append( field_7_unused3 ).append( "" )\n"" );
		 builder.append(""[/LFO]"");
		 return builder.toString();
	 }
	 public int getLsid() {
		 return field_1_lsid;
	 }
	 public void setLsid( int field_1_lsid ) {
		 this.field_1_lsid = field_1_lsid;
	 }
	 public int getUnused1() {
		 return field_2_unused1;
	 }
	 public void setUnused1( int field_2_unused1 ) {
		 this.field_2_unused1 = field_2_unused1;
	 }
	 public int getUnused2() {
		 return field_3_unused2;
	 }
	 public void setUnused2( int field_3_unused2 ) {
		 this.field_3_unused2 = field_3_unused2;
	 }
	 public byte getClfolvl() {
		 return field_4_clfolvl;
	 }
	 public void setClfolvl( byte field_4_clfolvl ) {
		 this.field_4_clfolvl = field_4_clfolvl;
	 }
	 public byte getIbstFltAutoNum() {
		 return field_5_ibstFltAutoNum;
	 }
	 public void setIbstFltAutoNum( byte field_5_ibstFltAutoNum ) {
		 this.field_5_ibstFltAutoNum = field_5_ibstFltAutoNum;
	 }
	 public Grfhic getGrfhic() {
		 return field_6_grfhic;
	 }
	 public void setGrfhic( Grfhic field_6_grfhic ) {
		 this.field_6_grfhic = field_6_grfhic;
	 }
	 public byte getUnused3() {
		 return field_7_unused3;
	 }
	 public void setUnused3( byte field_7_unused3 ) {
		 this.field_7_unused3 = field_7_unused3;
	 }
}",1,1,0,0
"public class Javadoc extends Task {
	 public class DocletParam {
		 private String name;
		 private String value;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setValue(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
	 }
	 public static class ExtensionInfo extends ProjectComponent {
		 private String name;
		 private Path path;
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setPath(Path path) {
			 if (this.path == null) {
				 this.path = path;
			 }
			 else {
				 this.path.append(path);
			 }
		 }
		 public Path getPath() {
			 return path;
		 }
		 public Path createPath() {
			 if (path == null) {
				 path = new Path(getProject());
			 }
			 return path.createPath();
		 }
		 public void setPathRef(Reference r) {
			 createPath().setRefid(r);
		 }
	 }
	 public class DocletInfo extends ExtensionInfo {
		 private Vector params = new Vector();
		 public DocletParam createParam() {
			 DocletParam param = new DocletParam();
			 params.addElement(param);
			 return param;
		 }
		 public Enumeration getParams() {
			 return params.elements();
		 }
	 }
	 public static class PackageName {
		 private String name;
		 public void setName(String name) {
			 this.name = name.trim();
		 }
		 public String getName() {
			 return name;
		 }
		 public String toString() {
			 return getName();
		 }
	 }
	 public static class SourceFile {
		 private File file;
		 public SourceFile() {
		 }
		 public SourceFile(File file) {
			 this.file = file;
		 }
		 public void setFile(File file) {
			 this.file = file;
		 }
		 public File getFile() {
			 return file;
		 }
	 }
	 public static class Html {
		 private StringBuffer text = new StringBuffer();
		 public void addText(String t) {
			 text.append(t);
		 }
		 public String getText() {
			 return text.substring(0);
		 }
	 }
	 public static class AccessType extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			""protected"", ""public"", ""package"", ""private""}
			;
		 }
	 }
	 public class ResourceCollectionContainer {
		 private ArrayList rcs = new ArrayList();
		 public void add(ResourceCollection rc) {
			 rcs.add(rc);
		 }
		 private Iterator iterator() {
			 return rcs.iterator();
		 }
	 }
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private Commandline cmd = new Commandline();
	 private void addArgIf(boolean b, String arg) {
		 if (b) {
			 cmd.createArgument().setValue(arg);
		 }
	 }
	 private void addArgIfNotEmpty(String key, String value) {
		 if (value != null && value.length() != 0) {
			 cmd.createArgument().setValue(key);
			 cmd.createArgument().setValue(value);
		 }
		 else {
			 log(""Warning: Leaving out empty argument '"" + key + ""'"", Project.MSG_WARN);
		 }
	 }
	 private boolean failOnError = false;
	 private Path sourcePath = null;
	 private File destDir = null;
	 private Vector sourceFiles = new Vector();
	 private Vector packageNames = new Vector();
	 private Vector excludePackageNames = new Vector(1);
	 private boolean author = true;
	 private boolean version = true;
	 private DocletInfo doclet = null;
	 private Path classpath = null;
	 private Path bootclasspath = null;
	 private String group = null;
	 private String packageList = null;
	 private Vector links = new Vector();
	 private Vector groups = new Vector();
	 private Vector tags = new Vector();
	 private boolean useDefaultExcludes = true;
	 private Html doctitle = null;
	 private Html header = null;
	 private Html footer = null;
	 private Html bottom = null;
	 private boolean useExternalFile = false;
	 private String source = null;
	 private boolean linksource = false;
	 private boolean breakiterator = false;
	 private String noqualifier;
	 private boolean includeNoSourcePackages = false;
	 private boolean old = false;
	 private String executable = null;
	 private ResourceCollectionContainer nestedSourceFiles = new ResourceCollectionContainer();
	 private Vector packageSets = new Vector();
	 public void setUseExternalFile(boolean b) {
		 useExternalFile = b;
	 }
	 public void setDefaultexcludes(boolean useDefaultExcludes) {
		 this.useDefaultExcludes = useDefaultExcludes;
	 }
	 public void setMaxmemory(String max) {
		 cmd.createArgument().setValue(""-J-Xmx"" + max);
	 }
	 public void setAdditionalparam(String add) {
		 cmd.createArgument().setLine(add);
	 }
	 public Commandline.Argument createArg() {
		 return cmd.createArgument();
	 }
	 public void setSourcepath(Path src) {
		 if (sourcePath == null) {
			 sourcePath = src;
		 }
		 else {
			 sourcePath.append(src);
		 }
	 }
	 public Path createSourcepath() {
		 if (sourcePath == null) {
			 sourcePath = new Path(getProject());
		 }
		 return sourcePath.createPath();
	 }
	 public void setSourcepathRef(Reference r) {
		 createSourcepath().setRefid(r);
	 }
	 public void setDestdir(File dir) {
		 destDir = dir;
		 cmd.createArgument().setValue(""-d"");
		 cmd.createArgument().setFile(destDir);
	 }
	 public void setSourcefiles(String src) {
		 StringTokenizer tok = new StringTokenizer(src, "","");
		 while (tok.hasMoreTokens()) {
			 String f = tok.nextToken();
			 SourceFile sf = new SourceFile();
			 sf.setFile(getProject().resolveFile(f.trim()));
			 addSource(sf);
		 }
	 }
	 public void addSource(SourceFile sf) {
		 sourceFiles.addElement(sf);
	 }
	 public void setPackagenames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addPackage(pn);
		 }
	 }
	 public void addPackage(PackageName pn) {
		 packageNames.addElement(pn);
	 }
	 public void setExcludePackageNames(String packages) {
		 StringTokenizer tok = new StringTokenizer(packages, "","");
		 while (tok.hasMoreTokens()) {
			 String p = tok.nextToken();
			 PackageName pn = new PackageName();
			 pn.setName(p);
			 addExcludePackage(pn);
		 }
	 }
	 public void addExcludePackage(PackageName pn) {
		 excludePackageNames.addElement(pn);
	 }
	 public void setOverview(File f) {
		 cmd.createArgument().setValue(""-overview"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setPublic(boolean b) {
		 addArgIf(b, ""-public"");
	 }
	 public void setProtected(boolean b) {
		 addArgIf(b, ""-protected"");
	 }
	 public void setPackage(boolean b) {
		 addArgIf(b, ""-package"");
	 }
	 public void setPrivate(boolean b) {
		 addArgIf(b, ""-private"");
	 }
	 public void setAccess(AccessType at) {
		 cmd.createArgument().setValue(""-"" + at.getValue());
	 }
	 public void setDoclet(String docletName) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setName(docletName);
	 }
	 public void setDocletPath(Path docletPath) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.setPath(docletPath);
	 }
	 public void setDocletPathRef(Reference r) {
		 if (doclet == null) {
			 doclet = new DocletInfo();
			 doclet.setProject(getProject());
		 }
		 doclet.createPath().setRefid(r);
	 }
	 public DocletInfo createDoclet() {
		 if (doclet == null) {
			 doclet = new DocletInfo();
		 }
		 return doclet;
	 }
	 public void addTaglet(ExtensionInfo tagletInfo) {
		 tags.addElement(tagletInfo);
	 }
	 public void setOld(boolean b) {
		 old = b;
	 }
	 public void setClasspath(Path path) {
		 if (classpath == null) {
			 classpath = path;
		 }
		 else {
			 classpath.append(path);
		 }
	 }
	 public Path createClasspath() {
		 if (classpath == null) {
			 classpath = new Path(getProject());
		 }
		 return classpath.createPath();
	 }
	 public void setClasspathRef(Reference r) {
		 createClasspath().setRefid(r);
	 }
	 public void setBootclasspath(Path path) {
		 if (bootclasspath == null) {
			 bootclasspath = path;
		 }
		 else {
			 bootclasspath.append(path);
		 }
	 }
	 public Path createBootclasspath() {
		 if (bootclasspath == null) {
			 bootclasspath = new Path(getProject());
		 }
		 return bootclasspath.createPath();
	 }
	 public void setBootClasspathRef(Reference r) {
		 createBootclasspath().setRefid(r);
	 }
	 public void setExtdirs(String path) {
		 cmd.createArgument().setValue(""-extdirs"");
		 cmd.createArgument().setValue(path);
	 }
	 public void setExtdirs(Path path) {
		 cmd.createArgument().setValue(""-extdirs"");
		 cmd.createArgument().setPath(path);
	 }
	 public void setVerbose(boolean b) {
		 addArgIf(b, ""-verbose"");
	 }
	 public void setLocale(String locale) {
		 cmd.createArgument(true).setValue(locale);
		 cmd.createArgument(true).setValue(""-locale"");
	 }
	 public void setEncoding(String enc) {
		 cmd.createArgument().setValue(""-encoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setVersion(boolean b) {
		 this.version = b;
	 }
	 public void setUse(boolean b) {
		 addArgIf(b, ""-use"");
	 }
	 public void setAuthor(boolean b) {
		 author = b;
	 }
	 public void setSplitindex(boolean b) {
		 addArgIf(b, ""-splitindex"");
	 }
	 public void setWindowtitle(String title) {
		 addArgIfNotEmpty(""-windowtitle"", title);
	 }
	 public void setDoctitle(String doctitle) {
		 Html h = new Html();
		 h.addText(doctitle);
		 addDoctitle(h);
	 }
	 public void addDoctitle(Html text) {
		 doctitle = text;
	 }
	 public void setHeader(String header) {
		 Html h = new Html();
		 h.addText(header);
		 addHeader(h);
	 }
	 public void addHeader(Html text) {
		 header = text;
	 }
	 public void setFooter(String footer) {
		 Html h = new Html();
		 h.addText(footer);
		 addFooter(h);
	 }
	 public void addFooter(Html text) {
		 footer = text;
	 }
	 public void setBottom(String bottom) {
		 Html h = new Html();
		 h.addText(bottom);
		 addBottom(h);
	 }
	 public void addBottom(Html text) {
		 bottom = text;
	 }
	 public void setLinkoffline(String src) {
		 LinkArgument le = createLink();
		 le.setOffline(true);
		 String linkOfflineError = ""The linkoffline attribute must include"" + "" a URL and a package-list file location separated by a"" + "" space"";
		 if (src.trim().length() == 0) {
			 throw new BuildException(linkOfflineError);
		 }
		 StringTokenizer tok = new StringTokenizer(src, "" "", false);
		 le.setHref(tok.nextToken());
		 if (!tok.hasMoreTokens()) {
			 throw new BuildException(linkOfflineError);
		 }
		 le.setPackagelistLoc(getProject().resolveFile(tok.nextToken()));
	 }
	 public void setGroup(String src) {
		 group = src;
	 }
	 public void setLink(String src) {
		 createLink().setHref(src);
	 }
	 public void setNodeprecated(boolean b) {
		 addArgIf(b, ""-nodeprecated"");
	 }
	 public void setNodeprecatedlist(boolean b) {
		 addArgIf(b, ""-nodeprecatedlist"");
	 }
	 public void setNotree(boolean b) {
		 addArgIf(b, ""-notree"");
	 }
	 public void setNoindex(boolean b) {
		 addArgIf(b, ""-noindex"");
	 }
	 public void setNohelp(boolean b) {
		 addArgIf(b, ""-nohelp"");
	 }
	 public void setNonavbar(boolean b) {
		 addArgIf(b, ""-nonavbar"");
	 }
	 public void setSerialwarn(boolean b) {
		 addArgIf(b, ""-serialwarn"");
	 }
	 public void setStylesheetfile(File f) {
		 cmd.createArgument().setValue(""-stylesheetfile"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setHelpfile(File f) {
		 cmd.createArgument().setValue(""-helpfile"");
		 cmd.createArgument().setFile(f);
	 }
	 public void setDocencoding(String enc) {
		 cmd.createArgument().setValue(""-docencoding"");
		 cmd.createArgument().setValue(enc);
	 }
	 public void setPackageList(String src) {
		 packageList = src;
	 }
	 public LinkArgument createLink() {
		 LinkArgument la = new LinkArgument();
		 links.addElement(la);
		 return la;
	 }
	 public class LinkArgument {
		 private String href;
		 private boolean offline = false;
		 private File packagelistLoc;
		 private boolean resolveLink = false;
		 public LinkArgument() {
		 }
		 public void setHref(String hr) {
			 href = hr;
		 }
		 public String getHref() {
			 return href;
		 }
		 public void setPackagelistLoc(File src) {
			 packagelistLoc = src;
		 }
		 public File getPackagelistLoc() {
			 return packagelistLoc;
		 }
		 public void setOffline(boolean offline) {
			 this.offline = offline;
		 }
		 public boolean isLinkOffline() {
			 return offline;
		 }
		 public void setResolveLink(boolean resolve) {
			 this.resolveLink = resolve;
		 }
		 public boolean shouldResolveLink() {
			 return resolveLink;
		 }
	 }
	 public TagArgument createTag() {
		 TagArgument ta = new TagArgument();
		 tags.addElement (ta);
		 return ta;
	 }
	 static final String[] SCOPE_ELEMENTS = {
	 ""overview"", ""packages"", ""types"", ""constructors"", ""methods"", ""fields"" }
	;
	 public class TagArgument extends FileSet {
		 private String name = null;
		 private boolean enabled = true;
		 private String scope = ""a"";
		 public TagArgument () {
		 }
		 public void setName (String name) {
			 this.name = name;
		 }
		 public void setScope (String verboseScope) throws BuildException {
			 verboseScope = verboseScope.toLowerCase(Locale.US);
			 boolean[] elements = new boolean[SCOPE_ELEMENTS.length];
			 boolean gotAll = false;
			 boolean gotNotAll = false;
			 StringTokenizer tok = new StringTokenizer (verboseScope, "","");
			 while (tok.hasMoreTokens()) {
				 String next = tok.nextToken().trim();
				 if (next.equals(""all"")) {
					 if (gotAll) {
						 getProject().log (""Repeated tag scope element: all"", Project.MSG_VERBOSE);
					 }
					 gotAll = true;
				 }
				 else {
					 int i;
					 for (i = 0;
					 i < SCOPE_ELEMENTS.length;
					 i++) {
						 if (next.equals (SCOPE_ELEMENTS[i])) {
							 break;
						 }
					 }
					 if (i == SCOPE_ELEMENTS.length) {
						 throw new BuildException (""Unrecognised scope element: "" + next);
					 }
					 else {
						 if (elements[i]) {
							 getProject().log (""Repeated tag scope element: "" + next, Project.MSG_VERBOSE);
						 }
						 elements[i] = true;
						 gotNotAll = true;
					 }
				 }
			 }
			 if (gotNotAll && gotAll) {
				 throw new BuildException (""Mixture of \""all\"" and other scope "" + ""elements in tag parameter."");
			 }
			 if (!gotNotAll && !gotAll) {
				 throw new BuildException (""No scope elements specified in tag "" + ""parameter."");
			 }
			 if (gotAll) {
				 this.scope = ""a"";
			 }
			 else {
				 StringBuffer buff = new StringBuffer (elements.length);
				 for (int i = 0;
				 i < elements.length;
				 i++) {
					 if (elements[i]) {
						 buff.append (SCOPE_ELEMENTS[i].charAt(0));
					 }
				 }
				 this.scope = buff.toString();
			 }
		 }
		 public void setEnabled (boolean enabled) {
			 this.enabled = enabled;
		 }
		 public String getParameter() throws BuildException {
			 if (name == null || name.equals("""")) {
				 throw new BuildException (""No name specified for custom tag."");
			 }
			 if (getDescription() != null) {
				 return name + "":"" + (enabled ? """" : ""X"") + scope + "":"" + getDescription();
			 }
			 else {
				 return name + "":"" + (enabled ? """" : ""X"") + scope + "":"" + name;
			 }
		 }
	 }
	 public GroupArgument createGroup() {
		 GroupArgument ga = new GroupArgument();
		 groups.addElement(ga);
		 return ga;
	 }
	 public class GroupArgument {
		 private Html title;
		 private Vector packages = new Vector();
		 public GroupArgument() {
		 }
		 public void setTitle(String src) {
			 Html h = new Html();
			 h.addText(src);
			 addTitle(h);
		 }
		 public void addTitle(Html text) {
			 title = text;
		 }
		 public String getTitle() {
			 return title != null ? title.getText() : null;
		 }
		 public void setPackages(String src) {
			 StringTokenizer tok = new StringTokenizer(src, "","");
			 while (tok.hasMoreTokens()) {
				 String p = tok.nextToken();
				 PackageName pn = new PackageName();
				 pn.setName(p);
				 addPackage(pn);
			 }
		 }
		 public void addPackage(PackageName pn) {
			 packages.addElement(pn);
		 }
		 public String getPackages() {
			 StringBuffer p = new StringBuffer();
			 for (int i = 0;
			 i < packages.size();
			 i++) {
				 if (i > 0) {
					 p.append("":"");
				 }
				 p.append(packages.elementAt(i).toString());
			 }
			 return p.toString();
		 }
	 }
	 public void setCharset(String src) {
		 this.addArgIfNotEmpty(""-charset"", src);
	 }
	 public void setFailonerror(boolean b) {
		 failOnError = b;
	 }
	 public void setSource(String source) {
		 this.source = source;
	 }
	 public void setExecutable(String executable) {
		 this.executable = executable;
	 }
	 public void addPackageset(DirSet packageSet) {
		 packageSets.addElement(packageSet);
	 }
	 public void addFileset(FileSet fs) {
		 createSourceFiles().add(fs);
	 }
	 public ResourceCollectionContainer createSourceFiles() {
		 return nestedSourceFiles;
	 }
	 public void setLinksource(boolean b) {
		 this.linksource = b;
	 }
	 public void setBreakiterator(boolean b) {
		 this.breakiterator = b;
	 }
	 public void setNoqualifier(String noqualifier) {
		 this.noqualifier = noqualifier;
	 }
	 public void setIncludeNoSourcePackages(boolean b) {
		 this.includeNoSourcePackages = b;
	 }
	 public void execute() throws BuildException {
		 if (""javadoc2"".equals(getTaskType())) {
			 log(""Warning: the task name <javadoc2> is deprecated. Use <javadoc> instead."", Project.MSG_WARN);
		 }
		 boolean javadoc4 = !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2) && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_3);
		 boolean javadoc5 = javadoc4 && !JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_4);
		 Vector packagesToDoc = new Vector();
		 Path sourceDirs = new Path(getProject());
		 if (packageList != null && sourcePath == null) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying packagelist."";
			 throw new BuildException(msg);
		 }
		 if (sourcePath != null) {
			 sourceDirs.addExisting(sourcePath);
		 }
		 parsePackages(packagesToDoc, sourceDirs);
		 if (packagesToDoc.size() != 0 && sourceDirs.size() == 0) {
			 String msg = ""sourcePath attribute must be set when "" + ""specifying package names."";
			 throw new BuildException(msg);
		 }
		 Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
		 addSourceFiles(sourceFilesToDoc);
		 if (packageList == null && packagesToDoc.size() == 0 && sourceFilesToDoc.size() == 0) {
			 throw new BuildException(""No source files and no packages have "" + ""been specified."");
		 }
		 log(""Generating Javadoc"", Project.MSG_INFO);
		 Commandline toExecute = (Commandline) cmd.clone();
		 if (executable != null) {
			 toExecute.setExecutable(executable);
		 }
		 else {
			 toExecute.setExecutable(JavaEnvUtils.getJdkExecutable(""javadoc""));
		 }
		 if (doctitle != null) {
			 toExecute.createArgument().setValue(""-doctitle"");
			 toExecute.createArgument().setValue(expand(doctitle.getText()));
		 }
		 if (header != null) {
			 toExecute.createArgument().setValue(""-header"");
			 toExecute.createArgument().setValue(expand(header.getText()));
		 }
		 if (footer != null) {
			 toExecute.createArgument().setValue(""-footer"");
			 toExecute.createArgument().setValue(expand(footer.getText()));
		 }
		 if (bottom != null) {
			 toExecute.createArgument().setValue(""-bottom"");
			 toExecute.createArgument().setValue(expand(bottom.getText()));
		 }
		 if (classpath == null) {
			 classpath = (new Path(getProject())).concatSystemClasspath(""last"");
		 }
		 else {
			 classpath = classpath.concatSystemClasspath(""ignore"");
		 }
		 if (classpath.size() > 0) {
			 toExecute.createArgument().setValue(""-classpath"");
			 toExecute.createArgument().setPath(classpath);
		 }
		 if (sourceDirs.size() > 0) {
			 toExecute.createArgument().setValue(""-sourcepath"");
			 toExecute.createArgument().setPath(sourceDirs);
		 }
		 if (version && doclet == null) {
			 toExecute.createArgument().setValue(""-version"");
		 }
		 if (author && doclet == null) {
			 toExecute.createArgument().setValue(""-author"");
		 }
		 if (doclet == null && destDir == null) {
			 throw new BuildException(""destdir attribute must be set!"");
		 }
		 if (doclet != null) {
			 if (doclet.getName() == null) {
				 throw new BuildException(""The doclet name must be "" + ""specified."", getLocation());
			 }
			 else {
				 toExecute.createArgument().setValue(""-doclet"");
				 toExecute.createArgument().setValue(doclet.getName());
				 if (doclet.getPath() != null) {
					 Path docletPath = doclet.getPath().concatSystemClasspath(""ignore"");
					 if (docletPath.size() != 0) {
						 toExecute.createArgument().setValue(""-docletpath"");
						 toExecute.createArgument().setPath(docletPath);
					 }
				 }
				 for (Enumeration e = doclet.getParams();
				 e.hasMoreElements();
				) {
					 DocletParam param = (DocletParam) e.nextElement();
					 if (param.getName() == null) {
						 throw new BuildException(""Doclet parameters must "" + ""have a name"");
					 }
					 toExecute.createArgument().setValue(param.getName());
					 if (param.getValue() != null) {
						 toExecute.createArgument() .setValue(param.getValue());
					 }
				 }
			 }
		 }
		 Path bcp = new Path(getProject());
		 if (bootclasspath != null) {
			 bcp.append(bootclasspath);
		 }
		 bcp = bcp.concatSystemBootClasspath(""ignore"");
		 if (bcp.size() > 0) {
			 toExecute.createArgument().setValue(""-bootclasspath"");
			 toExecute.createArgument().setPath(bcp);
		 }
		 if (links.size() != 0) {
			 for (Enumeration e = links.elements();
			 e.hasMoreElements();
			) {
				 LinkArgument la = (LinkArgument) e.nextElement();
				 if (la.getHref() == null || la.getHref().length() == 0) {
					 log(""No href was given for the link - skipping"", Project.MSG_VERBOSE);
					 continue;
				 }
				 String link = null;
				 if (la.shouldResolveLink()) {
					 File hrefAsFile = getProject().resolveFile(la.getHref());
					 if (hrefAsFile.exists()) {
						 try {
							 link = FILE_UTILS.getFileURL(hrefAsFile) .toExternalForm();
						 }
						 catch (MalformedURLException ex) {
							 log(""Warning: link location was invalid "" + hrefAsFile, Project.MSG_WARN);
						 }
					 }
				 }
				 if (link == null) {
					 try {
						 URL base = new URL(""file: new URL(base, la.getHref());
						 link = la.getHref();
					 }
					 catch (MalformedURLException mue) {
						 log(""Link href \"""" + la.getHref() + ""\"" is not a valid url - skipping link"", Project.MSG_WARN);
						 continue;
					 }
				 }
				 if (la.isLinkOffline()) {
					 File packageListLocation = la.getPackagelistLoc();
					 if (packageListLocation == null) {
						 throw new BuildException(""The package list"" + "" location for link "" + la.getHref() + "" must be provided "" + ""because the link is "" + ""offline"");
					 }
					 File packageListFile = new File(packageListLocation, ""package-list"");
					 if (packageListFile.exists()) {
						 try {
							 String packageListURL = FILE_UTILS.getFileURL(packageListLocation) .toExternalForm();
							 toExecute.createArgument() .setValue(""-linkoffline"");
							 toExecute.createArgument() .setValue(link);
							 toExecute.createArgument() .setValue(packageListURL);
						 }
						 catch (MalformedURLException ex) {
							 log(""Warning: Package list location was "" + ""invalid "" + packageListLocation, Project.MSG_WARN);
						 }
					 }
					 else {
						 log(""Warning: No package list was found at "" + packageListLocation, Project.MSG_VERBOSE);
					 }
				 }
				 else {
					 toExecute.createArgument().setValue(""-link"");
					 toExecute.createArgument().setValue(link);
				 }
			 }
		 }
		 if (group != null) {
			 StringTokenizer tok = new StringTokenizer(group, "","", false);
			 while (tok.hasMoreTokens()) {
				 String grp = tok.nextToken().trim();
				 int space = grp.indexOf("" "");
				 if (space > 0) {
					 String name = grp.substring(0, space);
					 String pkgList = grp.substring(space + 1);
					 toExecute.createArgument().setValue(""-group"");
					 toExecute.createArgument().setValue(name);
					 toExecute.createArgument().setValue(pkgList);
				 }
			 }
		 }
		 if (groups.size() != 0) {
			 for (Enumeration e = groups.elements();
			 e.hasMoreElements();
			) {
				 GroupArgument ga = (GroupArgument) e.nextElement();
				 String title = ga.getTitle();
				 String packages = ga.getPackages();
				 if (title == null || packages == null) {
					 throw new BuildException(""The title and packages must "" + ""be specified for group "" + ""elements."");
				 }
				 toExecute.createArgument().setValue(""-group"");
				 toExecute.createArgument().setValue(expand(title));
				 toExecute.createArgument().setValue(packages);
			 }
		 }
		 if (javadoc4 || executable != null) {
			 for (Enumeration e = tags.elements();
			 e.hasMoreElements();
			) {
				 Object element = e.nextElement();
				 if (element instanceof TagArgument) {
					 TagArgument ta = (TagArgument) element;
					 File tagDir = ta.getDir(getProject());
					 if (tagDir == null) {
						 toExecute.createArgument().setValue (""-tag"");
						 toExecute.createArgument() .setValue (ta.getParameter());
					 }
					 else {
						 DirectoryScanner tagDefScanner = ta.getDirectoryScanner(getProject());
						 String[] files = tagDefScanner.getIncludedFiles();
						 for (int i = 0;
						 i < files.length;
						 i++) {
							 File tagDefFile = new File(tagDir, files[i]);
							 try {
								 BufferedReader in = new BufferedReader( new FileReader(tagDefFile) );
								 String line = null;
								 while ((line = in.readLine()) != null) {
									 toExecute.createArgument() .setValue(""-tag"");
									 toExecute.createArgument() .setValue(line);
								 }
								 in.close();
							 }
							 catch (IOException ioe) {
								 throw new BuildException(""Couldn't read "" + "" tag file from "" + tagDefFile.getAbsolutePath(), ioe);
							 }
						 }
					 }
				 }
				 else {
					 ExtensionInfo tagletInfo = (ExtensionInfo) element;
					 toExecute.createArgument().setValue(""-taglet"");
					 toExecute.createArgument().setValue(tagletInfo .getName());
					 if (tagletInfo.getPath() != null) {
						 Path tagletPath = tagletInfo.getPath() .concatSystemClasspath(""ignore"");
						 if (tagletPath.size() != 0) {
							 toExecute.createArgument() .setValue(""-tagletpath"");
							 toExecute.createArgument().setPath(tagletPath);
						 }
					 }
				 }
			 }
			 String sourceArg = source != null ? source : getProject().getProperty(MagicNames.BUILD_JAVAC_SOURCE);
			 if (sourceArg != null) {
				 toExecute.createArgument().setValue(""-source"");
				 toExecute.createArgument().setValue(sourceArg);
			 }
			 if (linksource && doclet == null) {
				 toExecute.createArgument().setValue(""-linksource"");
			 }
			 if (breakiterator && (doclet == null || javadoc5)) {
				 toExecute.createArgument().setValue(""-breakiterator"");
			 }
			 if (noqualifier != null && doclet == null) {
				 toExecute.createArgument().setValue(""-noqualifier"");
				 toExecute.createArgument().setValue(noqualifier);
			 }
		 }
		 else {
			 if (!tags.isEmpty()) {
				 log(""-tag and -taglet options not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
			 }
			 if (source != null) {
				 log(""-source option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
			 }
			 if (linksource) {
				 log(""-linksource option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
			 }
			 if (breakiterator) {
				 log(""-breakiterator option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
			 }
			 if (noqualifier != null) {
				 log(""-noqualifier option not supported on Javadoc < 1.4"", Project.MSG_VERBOSE);
			 }
		 }
		 if (!javadoc4 || executable != null) {
			 if (old) {
				 toExecute.createArgument().setValue(""-1.1"");
			 }
		 }
		 else {
			 if (old) {
				 log(""Javadoc 1.4 doesn't support the -1.1 switch anymore"", Project.MSG_WARN);
			 }
		 }
		 if (useExternalFile && javadoc4) {
			 writeExternalArgs(toExecute);
		 }
		 File tmpList = null;
		 PrintWriter srcListWriter = null;
		 try {
			 if (useExternalFile) {
				 if (tmpList == null) {
					 tmpList = FILE_UTILS.createTempFile(""javadoc"", """", null);
					 tmpList.deleteOnExit();
					 toExecute.createArgument() .setValue(""@"" + tmpList.getAbsolutePath());
				 }
				 srcListWriter = new PrintWriter( new FileWriter(tmpList.getAbsolutePath(), true));
			 }
			 Enumeration e = packagesToDoc.elements();
			 while (e.hasMoreElements()) {
				 String packageName = (String) e.nextElement();
				 if (useExternalFile) {
					 srcListWriter.println(packageName);
				 }
				 else {
					 toExecute.createArgument().setValue(packageName);
				 }
			 }
			 e = sourceFilesToDoc.elements();
			 while (e.hasMoreElements()) {
				 SourceFile sf = (SourceFile) e.nextElement();
				 String sourceFileName = sf.getFile().getAbsolutePath();
				 if (useExternalFile) {
					 if (javadoc4 && sourceFileName.indexOf("" "") > -1) {
						 String name = sourceFileName;
						 if (File.separatorChar == '\\') {
							 name = sourceFileName.replace(File.separatorChar, '/');
						 }
						 srcListWriter.println(""\"""" + name + ""\"""");
					 }
					 else {
						 srcListWriter.println(sourceFileName);
					 }
				 }
				 else {
					 toExecute.createArgument().setValue(sourceFileName);
				 }
			 }
		 }
		 catch (IOException e) {
			 tmpList.delete();
			 throw new BuildException(""Error creating temporary file"", e, getLocation());
		 }
		 finally {
			 if (srcListWriter != null) {
				 srcListWriter.close();
			 }
		 }
		 if (packageList != null) {
			 toExecute.createArgument().setValue(""@"" + packageList);
		 }
		 log(toExecute.describeCommand(), Project.MSG_VERBOSE);
		 log(""Javadoc execution"", Project.MSG_INFO);
		 JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
		 JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
		 Execute exe = new Execute(new PumpStreamHandler(out, err));
		 exe.setAntRun(getProject());
		 exe.setWorkingDirectory(null);
		 try {
			 exe.setCommandline(toExecute.getCommandline());
			 int ret = exe.execute();
			 if (ret != 0 && failOnError) {
				 throw new BuildException(""Javadoc returned "" + ret, getLocation());
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(""Javadoc failed: "" + e, e, getLocation());
		 }
		 finally {
			 if (tmpList != null) {
				 tmpList.delete();
				 tmpList = null;
			 }
			 out.logFlush();
			 err.logFlush();
			 try {
				 out.close();
				 err.close();
			 }
			 catch (IOException e) {
			 }
		 }
	 }
	 private void writeExternalArgs(Commandline toExecute) {
		 File optionsTmpFile = null;
		 PrintWriter optionsListWriter = null;
		 try {
			 optionsTmpFile = FILE_UTILS.createTempFile( ""javadocOptions"", """", null);
			 optionsTmpFile.deleteOnExit();
			 String[] listOpt = toExecute.getArguments();
			 toExecute.clearArgs();
			 toExecute.createArgument().setValue( ""@"" + optionsTmpFile.getAbsolutePath());
			 optionsListWriter = new PrintWriter( new FileWriter(optionsTmpFile.getAbsolutePath(), true));
			 for (int i = 0;
			 i < listOpt.length;
			 i++) {
				 String string = listOpt[i];
				 if (string.startsWith(""-J-"")) {
					 toExecute.createArgument().setValue(string);
				 }
				 else {
					 if (string.startsWith(""-"")) {
						 optionsListWriter.print(string);
						 optionsListWriter.print("" "");
					 }
					 else {
						 optionsListWriter.println(quoteString(string));
					 }
				 }
			 }
			 optionsListWriter.close();
		 }
		 catch (IOException ex) {
			 if (optionsTmpFile != null) {
				 optionsTmpFile.delete();
			 }
			 throw new BuildException( ""Error creating or writing temporary file for javadoc options"", ex, getLocation());
		 }
		 finally {
			 FILE_UTILS.close(optionsListWriter);
		 }
	 }
	 private String quoteString(String str) {
		 if (str.indexOf(' ') == -1 && str.indexOf('\'') == -1 && str.indexOf('""') == -1) {
			 return str;
		 }
		 if (str.indexOf('\'') == -1) {
			 return quoteString(str, '\'');
		 }
		 else {
			 return quoteString(str, '""');
		 }
	 }
	 private String quoteString(String str, char delim) {
		 StringBuffer buf = new StringBuffer(str.length() * 2);
		 buf.append(delim);
		 if (str.indexOf('\\') != -1) {
			 str = replace(str, '\\', ""\\\\"");
		 }
		 if (str.indexOf(delim) != -1) {
			 str = replace(str, delim, ""\\"" + delim);
		 }
		 buf.append(str);
		 buf.append(delim);
		 return buf.toString();
	 }
	 private String replace(String str, char fromChar, String toString) {
		 StringBuffer buf = new StringBuffer(str.length() * 2);
		 for (int i = 0;
		 i < str.length();
		 ++i) {
			 char ch = str.charAt(i);
			 if (ch == fromChar) {
				 buf.append(toString);
			 }
			 else {
				 buf.append(ch);
			 }
		 }
		 return buf.toString();
	 }
	 private void addSourceFiles(Vector sf) {
		 Iterator e = nestedSourceFiles.iterator();
		 while (e.hasNext()) {
			 ResourceCollection rc = (ResourceCollection) e.next();
			 if (!rc.isFilesystemOnly()) {
				 throw new BuildException(""only file system based resources are"" + "" supported by javadoc"");
			 }
			 if (rc instanceof FileSet) {
				 FileSet fs = (FileSet) rc;
				 if (!fs.hasPatterns() && !fs.hasSelectors()) {
					 fs = (FileSet) fs.clone();
					 fs.createInclude().setName(""**package.html"");
				 }
			 }
		 }
		 Iterator iter = rc.iterator();
		 while (iter.hasNext()) {
			 sf.addElement(new SourceFile(((FileResource) iter.next()) .getFile()));
		 }
	 }
 }
 private void parsePackages(Vector pn, Path sp) {
	 Vector addedPackages = new Vector();
	 Vector dirSets = (Vector) packageSets.clone();
	 if (sourcePath != null) {
		 PatternSet ps = new PatternSet();
		 if (packageNames.size() > 0) {
			 Enumeration e = packageNames.elements();
			 while (e.hasMoreElements()) {
				 PackageName p = (PackageName) e.nextElement();
				 String pkg = p.getName().replace('.', '/');
				 if (pkg.endsWith(""*"")) {
					 pkg += ""*"";
				 }
				 ps.createInclude().setName(pkg);
			 }
		 }
		 else {
			 ps.createInclude().setName(""**"");
		 }
		 Enumeration e = excludePackageNames.elements();
		 while (e.hasMoreElements()) {
			 PackageName p = (PackageName) e.nextElement();
			 String pkg = p.getName().replace('.', '/');
			 if (pkg.endsWith(""*"")) {
				 pkg += ""*"";
			 }
			 ps.createExclude().setName(pkg);
		 }
		 String[] pathElements = sourcePath.list();
		 for (int i = 0;
		 i < pathElements.length;
		 i++) {
			 File dir = new File(pathElements[i]);
			 if (dir.isDirectory()) {
				 DirSet ds = new DirSet();
				 ds.setDefaultexcludes(useDefaultExcludes);
				 ds.setDir(dir);
				 ds.createPatternSet().addConfiguredPatternset(ps);
				 dirSets.addElement(ds);
			 }
			 else {
				 log(""Skipping "" + pathElements[i] + "" since it is no directory."", Project.MSG_WARN);
			 }
		 }
	 }
	 Enumeration e = dirSets.elements();
	 while (e.hasMoreElements()) {
		 DirSet ds = (DirSet) e.nextElement();
		 File baseDir = ds.getDir(getProject());
		 log(""scanning "" + baseDir + "" for packages."", Project.MSG_DEBUG);
		 DirectoryScanner dsc = ds.getDirectoryScanner(getProject());
		 String[] dirs = dsc.getIncludedDirectories();
		 boolean containsPackages = false;
		 for (int i = 0;
		 i < dirs.length;
		 i++) {
			 File pd = new File(baseDir, dirs[i]);
			 String[] files = pd.list(new FilenameFilter () {
				 public boolean accept(File dir1, String name) {
					 return name.endsWith("".java"") || (includeNoSourcePackages && name.equals(""package.html""));
				 }
			 }
			);
			 if (files.length > 0) {
				 if ("""".equals(dirs[i])) {
					 log(baseDir + "" contains source files in the default package,"" + "" you must specify them as source files"" + "" not packages."", Project.MSG_WARN);
				 }
				 else {
					 containsPackages = true;
					 String packageName = dirs[i].replace(File.separatorChar, '.');
					 if (!addedPackages.contains(packageName)) {
						 addedPackages.addElement(packageName);
						 pn.addElement(packageName);
					 }
				 }
			 }
		 }
		 if (containsPackages) {
			 sp.createPathElement().setLocation(baseDir);
		 }
		 else {
			 log(baseDir + "" doesn\'t contain any packages, dropping it."", Project.MSG_VERBOSE);
		 }
	 }
 }
 private class JavadocOutputStream extends LogOutputStream {
	 JavadocOutputStream(int level) {
		 super(Javadoc.this, level);
	 }
	 private String queuedLine = null;
	 protected void processLine(String line, int messageLevel) {
		 if (messageLevel == Project.MSG_INFO && line.startsWith(""Generating "")) {
			 if (queuedLine != null) {
				 super.processLine(queuedLine, Project.MSG_VERBOSE);
			 }
			 queuedLine = line;
		 }
		 else {
			 if (queuedLine != null) {
				 if (line.startsWith(""Building "")) {
					 super.processLine(queuedLine, Project.MSG_VERBOSE);
				 }
				 else {
					 super.processLine(queuedLine, Project.MSG_INFO);
				 }
				 queuedLine = null;
			 }
			 super.processLine(line, messageLevel);
		 }
	 }
	 protected void logFlush() {
		 if (queuedLine != null) {
			 super.processLine(queuedLine, Project.MSG_VERBOSE);
			 queuedLine = null;
		 }
	 }
 }
 protected String expand(String content) {
	 return getProject().replaceProperties(content);
 }
}",1,0,0,0
"public class DataSourceNodeProvider extends DefaultNodeProvider{
	public void createContextMenu( TreeViewer sourceViewer, Object object,IMenuManager menu ){
		super.createContextMenu( sourceViewer, object, menu );
		menu.insertBefore( IWorkbenchActionConstants.MB_ADDITIONS + ""-refresh"", new ShowPropertyAction( object ) );
	}
	public Object[] getChildren( Object model ){
		return new Object[]{
		}
		;
	}
	public String getNodeDisplayName( Object model ){
		return DEUtil.getDisplayLabel( model, false );
	}
}",0,0,0,0
"public class FastByteArrayOutputStream extends OutputStream {
	 protected byte[] buf;
	 protected int count;
	 public FastByteArrayOutputStream() {
		 buf = new byte[32];
	 }
	 public FastByteArrayOutputStream(int size) {
		 if (size >= 0) {
			 buf = new byte[size];
		 }
		 else {
			 throw new IllegalArgumentException();
		 }
	 }
	 public void close() throws IOException {
		 super.close();
	 }
	 private void expand(int i) {
		 if (count + i <= buf.length) {
			 return;
		 }
		 byte[] newbuf = new byte[(count + i) * 2];
		 System.arraycopy(buf, 0, newbuf, 0, count);
		 buf = newbuf;
	 }
	 public void reset() {
		 count = 0;
	 }
	 public int size() {
		 return count;
	 }
	 public byte[] toByteArray() {
		 byte[] newArray = new byte[count];
		 System.arraycopy(buf, 0, newArray, 0, count);
		 return newArray;
	 }
	 public String toString() {
		 return new String(buf, 0, count);
	 }
	 public String toString(int hibyte) {
		 char[] newBuf = new char[size()];
		 for (int i = 0;
		 i < newBuf.length;
		 i++) {
			 newBuf[i] = (char) (((hibyte & 0xff) << 8) | (buf[i] & 0xff));
		 }
		 return new String(newBuf);
	 }
	 public String toString(String enc) throws UnsupportedEncodingException {
		 return new String(buf, 0, count, enc);
	 }
	 public void write(byte[] buffer, int offset, int len) {
		 if (offset < 0 || offset > buffer.length || len < 0 || len > buffer.length - offset) {
			 throw new IndexOutOfBoundsException();
		 }
		 if (len == 0) {
			 return;
		 }
		 expand(len);
		 System.arraycopy(buffer, offset, buf, this.count, len);
		 this.count += len;
	 }
	 public void write(int oneByte) {
		 if (count == buf.length) {
			 expand(1);
		 }
		 buf[count++] = (byte) oneByte;
	 }
	 public void writeTo(OutputStream out) throws IOException {
		 out.write(buf, 0, count);
	 }
}",0,0,0,0
"private void convert(String name) {
	try {
		File inputFile = null, outputFile = null;
		String[] ids = lv.getSelectedIds();
		if (ids.length > 0) {
			String id = ids[0];
			DownloadEntry ent = XDMApp.getInstance().getEntry(id);
			if (ent.getState() != XDMConstants.FINISHED) {
				return;
			}
			inputFile = new File(ent.getFolder(), ent.getFile());
			if (!inputFile.exists()) {
				System.out.println(""Input file does not exists"");
			}
			int index = Integer.parseInt(name.split(""="")[1]);
			MediaFormat fmt = MediaFormats.getSupportedFormats()[index];
			String ext = fmt.getFormat();
			String newFileName = XDMUtils.getFileNameWithoutExtension(ent.getFile()) + ""."" + ext;
			JFileChooser jfc = new JFileChooser();
			jfc.setSelectedFile(new File(ent.getFolder(), newFileName));
			if (jfc.showSaveDialog(this) != JFileChooser.APPROVE_OPTION) {
				return;
			}
			outputFile = jfc.getSelectedFile();
			System.out.println(outputFile);
			MediaConversionWnd wnd = new MediaConversionWnd(inputFile, outputFile, fmt, -1);
			wnd.setVisible(true);
			wnd.convert();
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
}",0,0,0,0
"public class Kjc extends DefaultCompilerAdapter {
	 public boolean execute() throws BuildException {
		 attributes.log(""Using kjc compiler"", Project.MSG_VERBOSE);
		 Commandline cmd = setupKjcCommand();
		 cmd.setExecutable(""at.dms.kjc.Main"");
		 ExecuteJava ej = new ExecuteJava();
		 ej.setJavaCommand(cmd);
		 return ej.fork(getJavac()) == 0;
	 }
	 protected Commandline setupKjcCommand() {
		 Commandline cmd = new Commandline();
		 Path classpath = getCompileClasspath();
		 if (deprecation) {
			 cmd.createArgument().setValue(""-deprecation"");
		 }
		 if (destDir != null) {
			 cmd.createArgument().setValue(""-d"");
			 cmd.createArgument().setFile(destDir);
		 }
		 cmd.createArgument().setValue(""-classpath"");
		 Path cp = new Path(project);
		 Path p = getBootClassPath();
		 if (p.size() > 0) {
			 cp.append(p);
		 }
		 if (extdirs != null) {
			 cp.addExtdirs(extdirs);
		 }
		 cp.append(classpath);
		 if (compileSourcepath != null) {
			 cp.append(compileSourcepath);
		 }
		 else {
			 cp.append(src);
		 }
		 cmd.createArgument().setPath(cp);
		 if (encoding != null) {
			 cmd.createArgument().setValue(""-encoding"");
			 cmd.createArgument().setValue(encoding);
		 }
		 if (debug) {
			 cmd.createArgument().setValue(""-g"");
		 }
		 if (optimize) {
			 cmd.createArgument().setValue(""-O2"");
		 }
		 if (verbose) {
			 cmd.createArgument().setValue(""-verbose"");
		 }
		 addCurrentCompilerArgs(cmd);
		 logAndAddFilesToCompile(cmd);
		 return cmd;
	 }
}",0,0,0,0
"public interface LabelBindingListener {
	 public static class Listeners extends ListenerList<LabelBindingListener> implements LabelBindingListener {
		 public void textKeyChanged(Label label, String previousTextKey) {
			 forEach(listener -> listener.textKeyChanged(label, previousTextKey));
		 }
		 public void textBindTypeChanged(Label label, BindType previousTextBindType) {
			 forEach(listener -> listener.textBindTypeChanged(label, previousTextBindType));
		 }
		 public void textBindMappingChanged(Label label, Label.TextBindMapping previousTextBindMapping) {
			 forEach(listener -> listener.textBindMappingChanged(label, previousTextBindMapping));
		 }
	 }
	 public static class Adapter implements LabelBindingListener {
		 public void textKeyChanged(Label label, String previousTextKey) {
		 }
		 public void textBindTypeChanged(Label label, BindType previousTextBindType) {
		 }
		 public void textBindMappingChanged(Label label, Label.TextBindMapping previousTextBindMapping) {
		 }
	 }
	 default void textKeyChanged(Label label, String previousTextKey) {
	 }
	 default void textBindTypeChanged(Label label, BindType previousTextBindType) {
	 }
	 default void textBindMappingChanged(Label label, Label.TextBindMapping previousTextBindMapping) {
	 }
}",0,0,0,0
"public interface MailboxAnnotationManager {
	 List<MailboxAnnotation> getAllAnnotations(MailboxPath mailboxPath, MailboxSession session) throws MailboxException;
	 List<MailboxAnnotation> getAnnotationsByKeys(MailboxPath mailboxPath, MailboxSession session, Set<MailboxAnnotationKey> keys) throws MailboxException;
	 List<MailboxAnnotation> getAnnotationsByKeysWithOneDepth(MailboxPath mailboxPath, MailboxSession session, Set<MailboxAnnotationKey> keys) throws MailboxException;
	 List<MailboxAnnotation> getAnnotationsByKeysWithAllDepth(MailboxPath mailboxPath, MailboxSession session, Set<MailboxAnnotationKey> keys) throws MailboxException;
	 void updateAnnotations(MailboxPath mailboxPath, MailboxSession session, List<MailboxAnnotation> mailboxAnnotations) throws MailboxException, AnnotationException;
}",0,0,0,0
"public class RegexpUtil {
	 public static boolean hasFlag(int options, int flag) {
		 return ((options & flag) > 0);
	 }
	 public static int removeFlag(int options, int flag) {
		 return (options & (0xFFFFFFFF - flag));
	 }
}",0,0,0,0
"public Collection<ValidationResult> validate(final ValidationContext validationContext, final CredentialsStrategy primaryStrategy) {
	 boolean thisIsSelectedStrategy = this == primaryStrategy;
	 Boolean useStrategy = validationContext.getProperty(strategyProperty).asBoolean();
	 if (!thisIsSelectedStrategy && useStrategy) {
		 String failureFormat = ""property %1$s cannot be used with %2$s"";
		 Collection<ValidationResult> validationFailureResults = new ArrayList<ValidationResult>();
		 String message = String.format(failureFormat, strategyProperty.getDisplayName(), primaryStrategy.getName());
		 validationFailureResults.add(new ValidationResult.Builder() .subject(strategyProperty.getDisplayName()) .valid(false) .explanation(message).build());
		 return validationFailureResults;
	 }
	 return null;
 }",0,0,1,0
"public TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {
	Assert.state(target != null, ""Target must not be null"");
	Class<T> type = (target instanceof Class ? (Class<T>) target : target.getClass());
	if (type.isArray() && name.equals(""length"")) {
		if (target instanceof Class) {
			throw new AccessException(""Cannot access length on array class itself"");
		}
		return new TypedValue(Array.getLength(target));
	}
	PropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);
	InvokerPair invoker = this.readerCache.get(cacheKey);
	this.lastReadInvokerPair = invoker;
	if (invoker == null || invoker.member instanceof Method) {
		Method method = (Method) (invoker != null ? invoker.member : null);
		if (method == null) {
			method = findGetterForProperty(name, type, target);
			if (method != null) {
				Property property = new Property(type, method, null);
				TypeDescriptor typeDescriptor = new TypeDescriptor(property);
				invoker = new InvokerPair(method, typeDescriptor);
				this.lastReadInvokerPair = invoker;
				this.readerCache.put(cacheKey, invoker);
			}
		}
		if (method != null) {
			try {
				ReflectionUtils.makeAccessible(method);
				Object value = method.invoke(target);
				return new TypedValue(value, invoker.typeDescriptor.narrow(value));
			}
			catch (Exception ex) {
				throw new AccessException(""Unable to access property '"" + name + ""' through getter method"", ex);
			}
		}
	}
	if (invoker == null || invoker.member instanceof Field) {
		Field field = (Field) (invoker == null ? null : invoker.member);
		if (field == null) {
			field = findField(name, type, target);
			if (field != null) {
				invoker = new InvokerPair(field, new TypeDescriptor(field));
				this.lastReadInvokerPair = invoker;
				this.readerCache.put(cacheKey, invoker);
			}
		}
		if (field != null) {
			try {
				ReflectionUtils.makeAccessible(field);
				Object value = field.get(target);
				return new TypedValue(value, invoker.typeDescriptor.narrow(value));
			}
			catch (Exception ex) {
				throw new AccessException(""Unable to access field '"" + name + ""'"", ex);
			}
		}
	}
	throw new AccessException(""Neither getter method nor field found for property '"" + name + ""'"");
}",0,0,1,0
"public class XMLDOMWriterImpl implements XMLStreamWriterBase {
	 private Document ownerDoc = null;
	 private Node currentNode = null;
	 private Node node = null;
	 private NamespaceSupport namespaceContext = null;
	 private boolean [] needContextPop = null;
	 private StringBuffer stringBuffer = null;
	 private int resizeValue = 20;
	 private int depth = 0;
	 public XMLDOMWriterImpl(DOMResult result) {
		 node = result.getNode();
		 if( node.getNodeType() == Node.DOCUMENT_NODE){
			 ownerDoc = (Document)node;
			 currentNode = ownerDoc;
		 }
		else{
			 ownerDoc = node.getOwnerDocument();
			 currentNode = node;
		 }
		 stringBuffer = new StringBuffer();
		 needContextPop = new boolean[resizeValue];
		 namespaceContext = new NamespaceSupport();
	 }
	 public void close() throws XMLStreamException {
	 }
	 public void flush() throws XMLStreamException {
	 }
	 public javax.xml.namespace.NamespaceContext getNamespaceContext() {
		 return null;
	 }
	 public String getPrefix(String namespaceURI) throws XMLStreamException {
		 String prefix = null;
		 if(this.namespaceContext != null){
			 prefix = namespaceContext.getPrefix(namespaceURI);
		 }
		 return prefix;
	 }
	 public Object getProperty(String str) throws IllegalArgumentException {
		 throw new UnsupportedOperationException();
	 }
	 public void setDefaultNamespace(String uri) throws XMLStreamException {
		 namespaceContext.declarePrefix(XMLConstants.DEFAULT_NS_PREFIX, uri);
		 if(!needContextPop[depth]){
			 needContextPop[depth] = true;
		 }
	 }
	 public void setNamespaceContext(javax.xml.namespace.NamespaceContext namespaceContext) throws XMLStreamException {
		 throw new UnsupportedOperationException();
	 }
	 public void setPrefix(String prefix, String uri) throws XMLStreamException {
		 if(prefix == null){
			 throw new XMLStreamException(""Prefix cannot be null"");
		 }
		 namespaceContext.declarePrefix(prefix, uri);
		 if(!needContextPop[depth]){
			 needContextPop[depth] = true;
		 }
	 }
	 public void writeAttribute(String localName, String value) throws XMLStreamException {
		 if(currentNode.getNodeType() == Node.ELEMENT_NODE){
			 Attr attr = ownerDoc.createAttribute(localName);
			 attr.setValue(value);
			 ((Element)currentNode).setAttributeNode(attr);
		 }
		else{
			 throw new IllegalStateException(""Current DOM Node type is ""+ currentNode.getNodeType() + ""and does not allow attributes to be set "");
		 }
	 }
	 public void writeAttribute(String namespaceURI,String localName,String value)throws XMLStreamException {
		 if(currentNode.getNodeType() == Node.ELEMENT_NODE){
			 String prefix = null;
			 if(namespaceURI == null ){
				 throw new XMLStreamException(""NamespaceURI cannot be null"");
			 }
			 if(localName == null){
				 throw new XMLStreamException(""Local name cannot be null"");
			 }
			 if(namespaceContext != null){
				 prefix = namespaceContext.getPrefix(namespaceURI);
			 }
			 if(prefix == null){
				 throw new XMLStreamException(""Namespace URI ""+namespaceURI + ""is not bound to any prefix"" );
			 }
			 String qualifiedName = null;
			 if(prefix.isEmpty()){
				 qualifiedName = localName;
			 }
			else{
				 qualifiedName = getQName(prefix,localName);
			 }
			 Attr attr = ownerDoc.createAttributeNS(namespaceURI, qualifiedName);
			 attr.setValue(value);
			 ((Element)currentNode).setAttributeNode(attr);
		 }
		else{
			 throw new IllegalStateException(""Current DOM Node type is ""+ currentNode.getNodeType() + ""and does not allow attributes to be set "");
		 }
	 }
	 public void writeAttribute(String prefix,String namespaceURI,String localName,String value)throws XMLStreamException {
		 if(currentNode.getNodeType() == Node.ELEMENT_NODE){
			 if(namespaceURI == null ){
				 throw new XMLStreamException(""NamespaceURI cannot be null"");
			 }
			 if(localName == null){
				 throw new XMLStreamException(""Local name cannot be null"");
			 }
			 if(prefix == null){
				 throw new XMLStreamException(""prefix cannot be null"");
			 }
			 String qualifiedName = null;
			 if(prefix.isEmpty()){
				 qualifiedName = localName;
			 }
			else{
				 qualifiedName = getQName(prefix,localName);
			 }
			 Attr attr = ownerDoc.createAttributeNS(namespaceURI, qualifiedName);
			 attr.setValue(value);
			 ((Element)currentNode).setAttributeNodeNS(attr);
		 }
		else{
			 throw new IllegalStateException(""Current DOM Node type is ""+ currentNode.getNodeType() + ""and does not allow attributes to be set "");
		 }
	 }
	 public void writeCData(String data) throws XMLStreamException {
		 if(data == null){
			 throw new XMLStreamException(""CDATA cannot be null"");
		 }
		 CDATASection cdata = ownerDoc.createCDATASection(data);
		 getNode().appendChild(cdata);
	 }
	 public void writeCharacters(String charData) throws XMLStreamException {
		 Text text = ownerDoc.createTextNode(charData);
		 currentNode.appendChild(text);
	 }
	 public void writeCharacters(char[] values, int param, int param2) throws XMLStreamException {
		 Text text = ownerDoc.createTextNode(new String(values,param,param2));
		 currentNode.appendChild(text);
	 }
	 public void writeComment(String str) throws XMLStreamException {
		 Comment comment = ownerDoc.createComment(str);
		 getNode().appendChild(comment);
	 }
	 public void writeDTD(String str) throws XMLStreamException {
		 throw new UnsupportedOperationException();
	 }
	 public void writeDefaultNamespace(String namespaceURI) throws XMLStreamException {
		 if(currentNode.getNodeType() == Node.ELEMENT_NODE){
			 String qname = XMLConstants.XMLNS_ATTRIBUTE;
			 ((Element)currentNode).setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI,qname, namespaceURI);
		 }
		else{
			 throw new IllegalStateException(""Current DOM Node type is ""+ currentNode.getNodeType() + ""and does not allow attributes to be set "");
		 }
	 }
	 public void writeEmptyElement(String localName) throws XMLStreamException {
		 if(ownerDoc != null){
			 Element element = ownerDoc.createElement(localName);
			 if(currentNode!=null){
				 currentNode.appendChild(element);
			 }
			else{
				 ownerDoc.appendChild(element);
			 }
		 }
	 }
	 public void writeEmptyElement(String namespaceURI, String localName) throws XMLStreamException {
		 if(ownerDoc != null){
			 String qualifiedName = null;
			 String prefix = null;
			 if(namespaceURI == null ){
				 throw new XMLStreamException(""NamespaceURI cannot be null"");
			 }
			 if(localName == null){
				 throw new XMLStreamException(""Local name cannot be null"");
			 }
			 if(namespaceContext != null){
				 prefix = namespaceContext.getPrefix(namespaceURI);
			 }
			 if(prefix == null){
				 throw new XMLStreamException(""Namespace URI ""+namespaceURI + ""is not bound to any prefix"" );
			 }
			 if("""".equals(prefix)){
				 qualifiedName = localName;
			 }
			else{
				 qualifiedName = getQName(prefix,localName);
			 }
			 Element element = ownerDoc.createElementNS(namespaceURI, qualifiedName);
			 if(currentNode!=null){
				 currentNode.appendChild(element);
			 }
			else{
				 ownerDoc.appendChild(element);
			 }
		 }
	 }
	 public void writeEmptyElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
		 if(ownerDoc != null){
			 if(namespaceURI == null ){
				 throw new XMLStreamException(""NamespaceURI cannot be null"");
			 }
			 if(localName == null){
				 throw new XMLStreamException(""Local name cannot be null"");
			 }
			 if(prefix == null){
				 throw new XMLStreamException(""Prefix cannot be null"");
			 }
			 String qualifiedName = null;
			 if("""".equals(prefix)){
				 qualifiedName = localName;
			 }
			else{
				 qualifiedName = getQName(prefix,localName);
			 }
			 Element el = ownerDoc.createElementNS(namespaceURI,qualifiedName);
			 if(currentNode!=null){
				 currentNode.appendChild(el);
			 }
			else{
				 ownerDoc.appendChild(el);
			 }
		 }
	 }
	 public void writeEndDocument() throws XMLStreamException {
		 currentNode = null;
		 for(int i=0;
		 i< depth;
		i++){
			 if(needContextPop[depth]){
				 needContextPop[depth] = false;
				 namespaceContext.popContext();
			 }
			 depth--;
		 }
		 depth =0;
	 }
	 public void writeEndElement() throws XMLStreamException {
		 Node node= currentNode.getParentNode();
		 if(currentNode.getNodeType() == Node.DOCUMENT_NODE){
			 currentNode = null;
		 }
		else{
			 currentNode = node;
		 }
		 if(needContextPop[depth]){
			 needContextPop[depth] = false;
			 namespaceContext.popContext();
		 }
		 depth--;
	 }
	 public void writeEntityRef(String name) throws XMLStreamException {
		 EntityReference er = ownerDoc.createEntityReference(name);
		 currentNode.appendChild(er);
	 }
	 public void writeNamespace(String prefix, String namespaceURI) throws XMLStreamException {
		 if (prefix == null) {
			 throw new XMLStreamException(""prefix cannot be null"");
		 }
		 if (namespaceURI == null) {
			 throw new XMLStreamException(""NamespaceURI cannot be null"");
		 }
		 String qname = null;
		 if (prefix.isEmpty()) {
			 qname = XMLConstants.XMLNS_ATTRIBUTE;
		 }
		 else {
			 qname = getQName(XMLConstants.XMLNS_ATTRIBUTE,prefix);
		 }
		 ((Element)currentNode).setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI,qname, namespaceURI);
	 }
	 public void writeProcessingInstruction(String target) throws XMLStreamException {
		 if(target == null){
			 throw new XMLStreamException(""Target cannot be null"");
		 }
		 ProcessingInstruction pi = ownerDoc.createProcessingInstruction(target, """");
		 currentNode.appendChild(pi);
	 }
	 public void writeProcessingInstruction(String target, String data) throws XMLStreamException {
		 if(target == null){
			 throw new XMLStreamException(""Target cannot be null"");
		 }
		 ProcessingInstruction pi = ownerDoc.createProcessingInstruction(target, data);
		 currentNode.appendChild(pi);
	 }
	 public void writeStartDocument() throws XMLStreamException {
		 ownerDoc.setXmlVersion(""1.0"");
	 }
	 public void writeStartDocument(String version) throws XMLStreamException {
		 writeStartDocument(null, version, false, false);
	 }
	 public void writeStartDocument(String encoding, String version) throws XMLStreamException {
		 writeStartDocument(encoding, version, false, false);
	 }
	 public void writeStartDocument(String encoding, String version, boolean standalone, boolean standaloneSet) throws XMLStreamException {
		 if (encoding != null && ownerDoc.getClass().isAssignableFrom(DocumentImpl.class)) {
			 ((DocumentImpl)ownerDoc).setXmlEncoding(encoding);
		 }
		 ownerDoc.setXmlVersion(version);
		 if (standaloneSet) {
			 ownerDoc.setXmlStandalone(standalone);
		 }
	 }
	 public void writeStartElement(String localName) throws XMLStreamException {
		 if(ownerDoc != null){
			 Element element = ownerDoc.createElement(localName);
			 if(currentNode!=null){
				 currentNode.appendChild(element);
			 }
			else{
				 ownerDoc.appendChild(element);
			 }
			 currentNode = element;
		 }
		 if(needContextPop[depth]){
			 namespaceContext.pushContext();
		 }
		 incDepth();
	 }
	 public void writeStartElement(String namespaceURI, String localName) throws XMLStreamException {
		 if(ownerDoc != null){
			 String qualifiedName = null;
			 String prefix = null;
			 if(namespaceURI == null ){
				 throw new XMLStreamException(""NamespaceURI cannot be null"");
			 }
			 if(localName == null){
				 throw new XMLStreamException(""Local name cannot be null"");
			 }
			 if(namespaceContext != null){
				 prefix = namespaceContext.getPrefix(namespaceURI);
			 }
			 if(prefix == null){
				 throw new XMLStreamException(""Namespace URI ""+namespaceURI + ""is not bound to any prefix"" );
			 }
			 if("""".equals(prefix)){
				 qualifiedName = localName;
			 }
			else{
				 qualifiedName = getQName(prefix,localName);
			 }
			 Element element = ownerDoc.createElementNS(namespaceURI, qualifiedName);
			 if(currentNode!=null){
				 currentNode.appendChild(element);
			 }
			else{
				 ownerDoc.appendChild(element);
			 }
			 currentNode = element;
		 }
		 if(needContextPop[depth]){
			 namespaceContext.pushContext();
		 }
		 incDepth();
	 }
	 public void writeStartElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {
		 if(ownerDoc != null){
			 String qname = null;
			 if(namespaceURI == null ){
				 throw new XMLStreamException(""NamespaceURI cannot be null"");
			 }
			 if(localName == null){
				 throw new XMLStreamException(""Local name cannot be null"");
			 }
			 if(prefix == null){
				 throw new XMLStreamException(""Prefix cannot be null"");
			 }
			 if(prefix.isEmpty()){
				 qname = localName;
			 }
			else{
				 qname = getQName(prefix,localName);
			 }
			 Element el = ownerDoc.createElementNS(namespaceURI,qname);
			 if(currentNode!=null){
				 currentNode.appendChild(el);
			 }
			else{
				 ownerDoc.appendChild(el);
			 }
			 currentNode = el;
			 if(needContextPop[depth]){
				 namespaceContext.pushContext();
			 }
			 incDepth();
		 }
	 }
	 private String getQName(String prefix , String localName){
		 stringBuffer.setLength(0);
		 stringBuffer.append(prefix);
		 stringBuffer.append("":"");
		 stringBuffer.append(localName);
		 return stringBuffer.toString();
	 }
	 private Node getNode(){
		 if(currentNode == null){
			 return ownerDoc;
		 }
		 else{
			 return currentNode;
		 }
	 }
	 private void incDepth() {
		 depth++;
		 if (depth == needContextPop.length) {
			 boolean[] array = new boolean[depth + resizeValue];
			 System.arraycopy(needContextPop, 0, array, 0, depth);
			 needContextPop = array;
		 }
	 }
}",1,0,0,0
"public void setThreads(int min, int max) {
	 listener.setMinThreads(min);
	 listener.setMaxThreads(max);
 }",0,0,0,0
"public class OpenBuildDefinitionVNextAction extends BuildDefinitionVNextAction {
	 public void doRun(final IAction action) {
		 final DefinitionReference buildDefinition = getSelectedBuildDefinition();
		 if (buildDefinition != null) {
			 new OpenBuildDefinitionVNextTask(getShell(), getConnection(), buildDefinition).run();
			 ;
		 }
	 }
}",0,0,0,0
"public void changeArrowsOfArrowLink( MindMapArrowLinkModel arrowLink,boolean hasStartArrow,boolean hasEndArrow);",0,0,0,0
"class DFA103 extends DFA {
	 public DFA103(BaseRecognizer recognizer) {
		 this.recognizer = recognizer;
		 this.decisionNumber = 103;
		 this.eot = dfa_48;
		 this.eof = dfa_66;
		 this.min = dfa_49;
		 this.max = dfa_50;
		 this.accept = dfa_51;
		 this.special = dfa_52;
		 this.transition = dfa_53;
	 }
	 public String getDescription() {
		 return ""11979:2: ( rule__Unit__UnorderedGroup_7__4 )?"";
	 }
	 public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
		 TokenStream input = (TokenStream)_input;
		 int _s = s;
		 switch ( s ) {
			 case 0 : int LA103_0 = input.LA(1);
			 int index103_0 = input.index();
			 input.rewind();
			 s = -1;
			 if ( LA103_0 == Source && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 0) ) {
				s = 1;
			}
			 else if ( LA103_0 == Output && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 1) ) {
				s = 2;
			}
			 else if ( LA103_0 == Provides && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 2) ) {
				s = 3;
			}
			 else if ( LA103_0 == Requires && ( getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 3) || getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 4) ) ) {
				s = 4;
			}
			 else if ( LA103_0 == RULE_DOCUMENTATION && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 5) ) {
				s = 5;
			}
			 else if ( LA103_0 == RULE_ID && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 5) ) {
				s = 6;
			}
			 else if ( LA103_0 == Final && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 5) ) {
				s = 7;
			}
			 else if ( LA103_0 == Function && getUnorderedGroupHelper().canSelect(grammarAccess.getUnitAccess().getUnorderedGroup_7(), 5) ) {
				s = 8;
			}
			 else if ( (LA103_0==EOF||LA103_0==RightCurlyBracket) ) {
				s = 9;
			}
			 input.seek(index103_0);
			 if ( s>=0 ) return s;
			 break;
		 }
		 if (state.backtracking>0) {
			state.failed=true;
			 return -1;
		}
		 NoViableAltException nvae = new NoViableAltException(getDescription(), 103, _s, input);
		 error(nvae);
		 throw nvae;
	 }
 }",1,1,0,0
"public void setIgnoreSystemClasses(boolean ignoreSystemClasses) {
	 this.ignoreSystemClasses = ignoreSystemClasses;
 }",0,0,0,0
"class EventDetails {
	 private final long mTimeStamp;
	 private final Priority mPriority;
	 private final String mCategoryName;
	 private final String mNDC;
	 private final String mThreadName;
	 private final String mMessage;
	 private final String[] mThrowableStrRep;
	 private final String mLocationDetails;
	 EventDetails(long aTimeStamp, Priority aPriority, String aCategoryName, String aNDC, String aThreadName, String aMessage, String[] aThrowableStrRep, String aLocationDetails) {
		 mTimeStamp = aTimeStamp;
		 mPriority = aPriority;
		 mCategoryName = aCategoryName;
		 mNDC = aNDC;
		 mThreadName = aThreadName;
		 mMessage = aMessage;
		 mThrowableStrRep = aThrowableStrRep;
		 mLocationDetails = aLocationDetails;
	 }
	 EventDetails(LoggingEvent aEvent) {
		 this(aEvent.timeStamp, aEvent.getLevel(), aEvent.getLoggerName(), aEvent.getNDC(), aEvent.getThreadName(), aEvent.getRenderedMessage(), aEvent.getThrowableStrRep(), (aEvent.getLocationInformation() == null) ? null : aEvent.getLocationInformation().fullInfo);
	 }
	 long getTimeStamp() {
		 return mTimeStamp;
	 }
	 Priority getPriority() {
		 return mPriority;
	 }
	 String getCategoryName() {
		 return mCategoryName;
	 }
	 String getNDC() {
		 return mNDC;
	 }
	 String getThreadName() {
		 return mThreadName;
	 }
	 String getMessage() {
		 return mMessage;
	 }
	 String getLocationDetails(){
		 return mLocationDetails;
	 }
	 String[] getThrowableStrRep() {
		 return mThrowableStrRep;
	 }
}",0,1,0,0
"public boolean hasRunOnMachine(String tracker){
	 return this.activeTasks.values().contains(tracker) || hasFailedOnMachine(tracker) ;
 }",0,0,0,0
"private void loadQueues() {
	File file = new File(Config.getInstance().getDataFolder(), ""queues.txt"");
	DownloadQueue defaultQ = new DownloadQueue("""",StringResource.get(""DEF_QUEUE""));
	queueList.add(defaultQ);
	if (!file.exists()) {
		return;
	}
	SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd"");
	BufferedReader reader = null;
	try {
		reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), Charset.forName(""UTF-8"")));
		int count = Integer.parseInt(reader.readLine().trim());
		for (int i = 0;
		 i < count;
		 i++) {
			String id = reader.readLine().trim();
			String name = reader.readLine().trim();
			DownloadQueue queue = null;
			if ("""".equals(id)) {
				queue = defaultQ;
			}
			 else {
				queue = new DownloadQueue(id, name);
			}
			int c = Integer.parseInt(reader.readLine().trim());
			for (int j = 0;
			 j < c;
			 j++) {
				queue.getQueuedItems().add(reader.readLine().trim());
			}
			boolean hasStartTime = Integer.parseInt(reader.readLine()) == 1;
			if (hasStartTime) {
				queue.setStartTime(Long.parseLong(reader.readLine()));
				boolean hasEndTime = Integer.parseInt(reader.readLine()) == 1;
				if (hasEndTime) {
					queue.setEndTime(Long.parseLong(reader.readLine()));
				}
				boolean isPeriodic = Integer.parseInt(reader.readLine()) == 1;
				queue.setPeriodic(isPeriodic);
				if (isPeriodic) {
					queue.setDayMask(Integer.parseInt(reader.readLine()));
				}
				 else {
					if (Integer.parseInt(reader.readLine()) == 1) {
						String ln = reader.readLine();
						queue.setExecDate(dateFormatter.parse(ln));
					}
				}
			}
			if (queue.getQueueId().length() > 0) {
				queueList.add(queue);
			}
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	try {
		reader.close();
	}
	 catch (Exception e1) {
	}
}",0,0,1,0
"class GatewayReceiverParser extends AbstractSimpleBeanDefinitionParser {
	protected Class<?> getBeanClass(Element element) {
		return GatewayReceiverFactoryBean.class;
	}
	protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
		String cacheRef = element.getAttribute(ParsingUtils.CACHE_REF_ATTRIBUTE_NAME);
		builder.addConstructorArgReference(SpringUtils.defaultIfEmpty(cacheRef, GemfireConstants.DEFAULT_GEMFIRE_CACHE_NAME));
		builder.setLazyInit(false);
		ParsingUtils.setPropertyValue(element, builder, ""bind-address"");
		ParsingUtils.setPropertyValue(element, builder, ""hostname-for-senders"");
		ParsingUtils.setPropertyValue(element, builder, ""start-port"");
		ParsingUtils.setPropertyValue(element, builder, ""end-port"");
		ParsingUtils.setPropertyValue(element, builder, ""manual-start"");
		ParsingUtils.setPropertyValue(element, builder, ""maximum-time-between-pings"");
		ParsingUtils.setPropertyValue(element, builder, ""socket-buffer-size"");
		ParsingUtils.parseTransportFilters(element, parserContext, builder);
	}
}",0,0,0,0
"protected void checkParameters() throws BuildException {
	 assertTrue(getServerName() != null, ""ServerName must be set."");
	 assertTrue(getServerPort() != -1, ""ServerPort must be set."");
	 assertTrue(getProjectName() != null, ""ProjectName must be set."");
	 assertTrue(getViewName() != null, ""ViewName must be set."");
	 assertTrue(getUsername() != null, ""Username must be set."");
	 assertTrue(getPassword() != null, ""Password must be set."");
	 assertTrue(getTargetFolder() != null, ""TargetFolder must be set."");
	 if ((getTargetFolder().endsWith(""/"") || getTargetFolder().endsWith(""\\"")) && getTargetFolder().length() > 1) {
		 setTargetFolder(getTargetFolder().substring(0, getTargetFolder().length() - 1));
	 }
	 java.io.File dirExist = new java.io.File(getTargetFolder());
	 if (dirExist.isDirectory() && !getForce()) {
		 throw new BuildException(""Target directory exists. Set \""force\"" "" + ""to \""true\"" to continue anyway."");
	 }
 }",0,0,0,0
"public class CachingStatsSource implements StatsSource {
	 private final Cache<OpTreeSignature, OperatorStats> cache;
	 public CachingStatsSource(int cacheSize) {
		 cache = CacheBuilder.newBuilder().maximumSize(cacheSize).build();
	 }
	 public void put(OpTreeSignature sig, OperatorStats opStat) {
		 cache.put(sig, opStat);
	 }
	 public Optional<OperatorStats> lookup(OpTreeSignature treeSig) {
		 return Optional.ofNullable(cache.getIfPresent(treeSig));
	 }
	 public boolean canProvideStatsFor(Class<?> clazz) {
		 if (cache.size() > 0 && Operator.class.isAssignableFrom(clazz)) {
			 return true;
		 }
		 return false;
	 }
	 public void putAll(Map<OpTreeSignature, OperatorStats> map) {
		 for (Entry<OpTreeSignature, OperatorStats> entry : map.entrySet()) {
			 put(entry.getKey(), entry.getValue());
		 }
	 }
}",0,0,0,0
"public static class cancel_delegation_token<I extends Iface> extends org.apache.thrift.ProcessFunction<I, cancel_delegation_token_args> {
	 public cancel_delegation_token() {
		 super(""cancel_delegation_token"");
	 }
	 public cancel_delegation_token_args getEmptyArgsInstance() {
		 return new cancel_delegation_token_args();
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public cancel_delegation_token_result getResult(I iface, cancel_delegation_token_args args) throws org.apache.thrift.TException {
		 cancel_delegation_token_result result = new cancel_delegation_token_result();
		 try {
			 iface.cancel_delegation_token(args.token_str_form);
		 }
		 catch (MetaException o1) {
			 result.o1 = o1;
		 }
		 return result;
	 }
 }",0,0,0,0
"public class PdfDocument extends Document {
	 public static class PdfInfo extends PdfDictionary {
		 PdfInfo() {
			 super();
			 addProducer();
			 addCreationDate();
		 }
		 PdfInfo(String author, String title, String subject) {
			 this();
			 addTitle(title);
			 addSubject(subject);
			 addAuthor(author);
		 }
		 void addTitle(String title) {
			 put(PdfName.TITLE, new PdfString(title, PdfObject.TEXT_UNICODE));
		 }
		 void addSubject(String subject) {
			 put(PdfName.SUBJECT, new PdfString(subject, PdfObject.TEXT_UNICODE));
		 }
		 void addKeywords(String keywords) {
			 put(PdfName.KEYWORDS, new PdfString(keywords, PdfObject.TEXT_UNICODE));
		 }
		 void addAuthor(String author) {
			 put(PdfName.AUTHOR, new PdfString(author, PdfObject.TEXT_UNICODE));
		 }
		 void addCreator(String creator) {
			 put(PdfName.CREATOR, new PdfString(creator, PdfObject.TEXT_UNICODE));
		 }
		 void addProducer() {
			 put(PdfName.PRODUCER, new PdfString(getVersion()));
		 }
		 void addCreationDate() {
			 PdfString date = new PdfDate();
			 put(PdfName.CREATIONDATE, date);
			 put(PdfName.MODDATE, date);
		 }
		 void addkey(String key, String value) {
			 if (key.equals(""Producer"") || key.equals(""CreationDate"")) return;
			 put(new PdfName(key), new PdfString(value, PdfObject.TEXT_UNICODE));
		 }
	 }
	 static class PdfCatalog extends PdfDictionary {
		 PdfWriter writer;
		 PdfCatalog(PdfIndirectReference pages, PdfWriter writer) {
			 super(CATALOG);
			 this.writer = writer;
			 put(PdfName.PAGES, pages);
		 }
		 void addNames(TreeMap<String, Destination> localDestinations, HashMap<String, PdfObject> documentLevelJS, HashMap<String, PdfObject> documentFileAttachment, PdfWriter writer) {
			 if (localDestinations.isEmpty() && documentLevelJS.isEmpty() && documentFileAttachment.isEmpty()) return;
			 try {
				 PdfDictionary names = new PdfDictionary();
				 if (!localDestinations.isEmpty()) {
					 PdfArray ar = new PdfArray();
					 for (Map.Entry<String, Destination> entry : localDestinations.entrySet()) {
						 String name = entry.getKey();
						 Destination dest = entry.getValue();
						 if (dest.destination == null) continue;
						 PdfIndirectReference ref = dest.reference;
						 ar.add(new PdfString(name, null));
						 ar.add(ref);
					 }
					 if (ar.size() > 0) {
						 PdfDictionary dests = new PdfDictionary();
						 dests.put(PdfName.NAMES, ar);
						 names.put(PdfName.DESTS, writer.addToBody(dests).getIndirectReference());
					 }
				 }
				 if (!documentLevelJS.isEmpty()) {
					 PdfDictionary tree = PdfNameTree.writeTree(documentLevelJS, writer);
					 names.put(PdfName.JAVASCRIPT, writer.addToBody(tree).getIndirectReference());
				 }
				 if (!documentFileAttachment.isEmpty()) {
					 names.put(PdfName.EMBEDDEDFILES, writer.addToBody(PdfNameTree.writeTree(documentFileAttachment, writer)).getIndirectReference());
				 }
				 if (names.size() > 0) put(PdfName.NAMES, writer.addToBody(names).getIndirectReference());
			 }
			 catch (IOException e) {
				 throw new ExceptionConverter(e);
			 }
		 }
		 void setOpenAction(PdfAction action) {
			 put(PdfName.OPENACTION, action);
		 }
		 void setAdditionalActions(PdfDictionary actions) {
			 try {
				 put(PdfName.AA, writer.addToBody(actions).getIndirectReference());
			 }
			 catch (Exception e) {
				 throw new ExceptionConverter(e);
			 }
		 }
	 }
	 public PdfDocument() {
		 super();
		 addProducer();
		 addCreationDate();
	 }
	 protected PdfWriter writer;
	 public void addWriter(PdfWriter writer) throws DocumentException {
		 if (this.writer == null) {
			 this.writer = writer;
			 annotationsImp = new PdfAnnotationsImp(writer);
			 return;
		 }
		 throw new DocumentException(MessageLocalization.getComposedMessage(""you.can.only.add.a.writer.to.a.pdfdocument.once""));
	 }
	 protected PdfContentByte text;
	 protected PdfContentByte graphics;
	 protected float leading = 0;
	 public float getLeading() {
		 return leading;
	 }
	 void setLeading(float leading) {
		 this.leading = leading;
	 }
	 protected int alignment = Element.ALIGN_LEFT;
	 protected float currentHeight = 0;
	 protected boolean isSectionTitle = false;
	 protected int leadingCount = 0;
	 protected PdfAction anchorAction = null;
	 public boolean add(Element element) throws DocumentException {
		 if (writer != null && writer.isPaused()) {
			 return false;
		 }
		 try {
			 switch(element.type()) {
				 case Element.HEADER: info.addkey(((Meta)element).getName(), ((Meta)element).getContent());
				 break;
				 case Element.TITLE: info.addTitle(((Meta)element).getContent());
				 break;
				 case Element.SUBJECT: info.addSubject(((Meta)element).getContent());
				 break;
				 case Element.KEYWORDS: info.addKeywords(((Meta)element).getContent());
				 break;
				 case Element.AUTHOR: info.addAuthor(((Meta)element).getContent());
				 break;
				 case Element.CREATOR: info.addCreator(((Meta)element).getContent());
				 break;
				 case Element.PRODUCER: info.addProducer();
				 break;
				 case Element.CREATIONDATE: info.addCreationDate();
				 break;
				 case Element.CHUNK: {
					 if (line == null) {
						 carriageReturn();
					 }
					 PdfChunk chunk = new PdfChunk((Chunk) element, anchorAction);
					 {
						 PdfChunk overflow;
						 while ((overflow = line.add(chunk)) != null) {
							 carriageReturn();
							 chunk = overflow;
							 chunk.trimFirstSpace();
						 }
					 }
					 pageEmpty = false;
					 if (chunk.isAttribute(Chunk.NEWPAGE)) {
						 newPage();
					 }
					 break;
				 }
				 case Element.ANCHOR: {
					 leadingCount++;
					 Anchor anchor = (Anchor) element;
					 String url = anchor.getReference();
					 leading = anchor.getLeading();
					 if (url != null) {
						 anchorAction = new PdfAction(url);
					 }
					 element.process(this);
					 anchorAction = null;
					 leadingCount--;
					 break;
				 }
				 case Element.ANNOTATION: {
					 if (line == null) {
						 carriageReturn();
					 }
					 Annotation annot = (Annotation) element;
					 Rectangle rect = new Rectangle(0, 0);
					 if (line != null) rect = new Rectangle(annot.llx(indentRight() - line.widthLeft()), annot.ury(indentTop() - currentHeight - 20), annot.urx(indentRight() - line.widthLeft() + 20), annot.lly(indentTop() - currentHeight));
					 PdfAnnotation an = PdfAnnotationsImp.convertAnnotation(writer, annot, rect);
					 annotationsImp.addPlainAnnotation(an);
					 pageEmpty = false;
					 break;
				 }
				 case Element.PHRASE: {
					 leadingCount++;
					 leading = ((Phrase) element).getLeading();
					 element.process(this);
					 leadingCount--;
					 break;
				 }
				 case Element.PARAGRAPH: {
					 leadingCount++;
					 Paragraph paragraph = (Paragraph) element;
					 addSpacing(paragraph.getSpacingBefore(), leading, paragraph.getFont());
					 alignment = paragraph.getAlignment();
					 leading = paragraph.getTotalLeading();
					 carriageReturn();
					 if (currentHeight + line.height() + leading > indentTop() - indentBottom()) {
						 newPage();
					 }
					 indentation.indentLeft += paragraph.getIndentationLeft();
					 indentation.indentRight += paragraph.getIndentationRight();
					 carriageReturn();
					 PdfPageEvent pageEvent = writer.getPageEvent();
					 if (pageEvent != null && !isSectionTitle) pageEvent.onParagraph(writer, this, indentTop() - currentHeight);
					 if (paragraph.getKeepTogether()) {
						 carriageReturn();
						 PdfPTable table = new PdfPTable(1);
						 table.setWidthPercentage(100f);
						 PdfPCell cell = new PdfPCell();
						 cell.addElement(paragraph);
						 cell.setBorder(Rectangle.NO_BORDER);
						 cell.setPadding(0);
						 table.addCell(cell);
						 indentation.indentLeft -= paragraph.getIndentationLeft();
						 indentation.indentRight -= paragraph.getIndentationRight();
						 this.add(table);
						 indentation.indentLeft += paragraph.getIndentationLeft();
						 indentation.indentRight += paragraph.getIndentationRight();
					 }
					 else {
						 line.setExtraIndent(paragraph.getFirstLineIndent());
						 element.process(this);
						 carriageReturn();
						 addSpacing(paragraph.getSpacingAfter(), paragraph.getTotalLeading(), paragraph.getFont());
					 }
					 if (pageEvent != null && !isSectionTitle) pageEvent.onParagraphEnd(writer, this, indentTop() - currentHeight);
					 alignment = Element.ALIGN_LEFT;
					 indentation.indentLeft -= paragraph.getIndentationLeft();
					 indentation.indentRight -= paragraph.getIndentationRight();
					 carriageReturn();
					 leadingCount--;
					 break;
				 }
				 case Element.SECTION: case Element.CHAPTER: {
					 Section section = (Section) element;
					 PdfPageEvent pageEvent = writer.getPageEvent();
					 boolean hasTitle = section.isNotAddedYet() && section.getTitle() != null;
					 if (section.isTriggerNewPage()) {
						 newPage();
					 }
					 if (hasTitle) {
						 float fith = indentTop() - currentHeight;
						 int rotation = pageSize.getRotation();
						 if (rotation == 90 || rotation == 180) fith = pageSize.getHeight() - fith;
						 PdfDestination destination = new PdfDestination(PdfDestination.FITH, fith);
						 while (currentOutline.level() >= section.getDepth()) {
							 currentOutline = currentOutline.parent();
						 }
						 PdfOutline outline = new PdfOutline(currentOutline, destination, section.getBookmarkTitle(), section.isBookmarkOpen());
						 currentOutline = outline;
					 }
					 carriageReturn();
					 indentation.sectionIndentLeft += section.getIndentationLeft();
					 indentation.sectionIndentRight += section.getIndentationRight();
					 if (section.isNotAddedYet() && pageEvent != null) if (element.type() == Element.CHAPTER) pageEvent.onChapter(writer, this, indentTop() - currentHeight, section.getTitle());
					 else pageEvent.onSection(writer, this, indentTop() - currentHeight, section.getDepth(), section.getTitle());
					 if (hasTitle) {
						 isSectionTitle = true;
						 add(section.getTitle());
						 isSectionTitle = false;
					 }
					 indentation.sectionIndentLeft += section.getIndentation();
					 element.process(this);
					 flushLines();
					 indentation.sectionIndentLeft -= section.getIndentationLeft() + section.getIndentation();
					 indentation.sectionIndentRight -= section.getIndentationRight();
					 if (section.isComplete() && pageEvent != null) if (element.type() == Element.CHAPTER) pageEvent.onChapterEnd(writer, this, indentTop() - currentHeight);
					 else pageEvent.onSectionEnd(writer, this, indentTop() - currentHeight);
					 break;
				 }
				 case Element.LIST: {
					 List list = (List) element;
					 if (list.isAlignindent()) {
						 list.normalizeIndentation();
					 }
					 indentation.listIndentLeft += list.getIndentationLeft();
					 indentation.indentRight += list.getIndentationRight();
					 element.process(this);
					 indentation.listIndentLeft -= list.getIndentationLeft();
					 indentation.indentRight -= list.getIndentationRight();
					 carriageReturn();
					 break;
				 }
				 case Element.LISTITEM: {
					 leadingCount++;
					 ListItem listItem = (ListItem) element;
					 addSpacing(listItem.getSpacingBefore(), leading, listItem.getFont());
					 alignment = listItem.getAlignment();
					 indentation.listIndentLeft += listItem.getIndentationLeft();
					 indentation.indentRight += listItem.getIndentationRight();
					 leading = listItem.getTotalLeading();
					 carriageReturn();
					 line.setListItem(listItem);
					 element.process(this);
					 addSpacing(listItem.getSpacingAfter(), listItem.getTotalLeading(), listItem.getFont());
					 if (line.hasToBeJustified()) {
						 line.resetAlignment();
					 }
					 carriageReturn();
					 indentation.listIndentLeft -= listItem.getIndentationLeft();
					 indentation.indentRight -= listItem.getIndentationRight();
					 leadingCount--;
					 break;
				 }
				 case Element.RECTANGLE: {
					 Rectangle rectangle = (Rectangle) element;
					 graphics.rectangle(rectangle);
					 pageEmpty = false;
					 break;
				 }
				 case Element.PTABLE: {
					 PdfPTable ptable = (PdfPTable)element;
					 if (ptable.size() <= ptable.getHeaderRows()) break;
					 ensureNewLine();
					 flushLines();
					 addPTable(ptable);
					 pageEmpty = false;
					 newLine();
					 break;
				 }
				 case Element.MULTI_COLUMN_TEXT: {
					 ensureNewLine();
					 flushLines();
					 MultiColumnText multiText = (MultiColumnText) element;
					 float height = multiText.write(writer.getDirectContent(), this, indentTop() - currentHeight);
					 currentHeight += height;
					 text.moveText(0, -1f* height);
					 pageEmpty = false;
					 break;
				 }
				 case Element.JPEG: case Element.JPEG2000: case Element.JBIG2: case Element.IMGRAW: case Element.IMGTEMPLATE: {
					 add((Image) element);
					 break;
				 }
				 case Element.YMARK: {
					 DrawInterface zh = (DrawInterface)element;
					 zh.draw(graphics, indentLeft(), indentBottom(), indentRight(), indentTop(), indentTop() - currentHeight - (leadingCount > 0 ? leading : 0));
					 pageEmpty = false;
					 break;
				 }
				 case Element.MARKED: {
					 MarkedObject mo;
					 if (element instanceof MarkedSection) {
						 mo = ((MarkedSection)element).getTitle();
						 if (mo != null) {
							 mo.process(this);
						 }
					 }
					 mo = (MarkedObject)element;
					 mo.process(this);
					 break;
				 }
				 default: return false;
			 }
			 lastElementType = element.type();
			 return true;
		 }
		 catch(Exception e) {
			 throw new DocumentException(e);
		 }
	 }
	 public void open() {
		 if (!open) {
			 super.open();
			 writer.open();
			 rootOutline = new PdfOutline(writer);
			 currentOutline = rootOutline;
		 }
		 try {
			 initPage();
		 }
		 catch(DocumentException de) {
			 throw new ExceptionConverter(de);
		 }
	 }
	 public void close() {
		 if (close) {
			 return;
		 }
		 try {
			 boolean wasImage = imageWait != null;
			 newPage();
			 if (imageWait != null || wasImage) newPage();
			 if (annotationsImp.hasUnusedAnnotations()) throw new RuntimeException(MessageLocalization.getComposedMessage(""not.all.annotations.could.be.added.to.the.document.the.document.doesn.t.have.enough.pages""));
			 PdfPageEvent pageEvent = writer.getPageEvent();
			 if (pageEvent != null) pageEvent.onCloseDocument(writer, this);
			 super.close();
			 writer.addLocalDestinations(localDestinations);
			 calculateOutlineCount();
			 writeOutlines();
		 }
		 catch(Exception e) {
			 throw ExceptionConverter.convertException(e);
		 }
		 writer.close();
	 }
	 protected int textEmptySize;
	 protected byte[] xmpMetadata = null;
	public void setXmpMetadata(byte[] xmpMetadata) {
		this.xmpMetadata = xmpMetadata;
	}
	 public boolean newPage() {
		 lastElementType = -1;
		 if (isPageEmpty()) {
			 setNewPageSizeAndMargins();
			 return false;
		 }
		 if (!open || close) {
			 throw new RuntimeException(MessageLocalization.getComposedMessage(""the.document.is.not.open""));
		 }
		 PdfPageEvent pageEvent = writer.getPageEvent();
		 if (pageEvent != null) pageEvent.onEndPage(writer, this);
		 super.newPage();
		 indentation.imageIndentLeft = 0;
		 indentation.imageIndentRight = 0;
		 try {
			 flushLines();
			 int rotation = pageSize.getRotation();
			 if (writer.isPdfX()) {
				 if (thisBoxSize.containsKey(""art"") && thisBoxSize.containsKey(""trim"")) throw new PdfXConformanceException(MessageLocalization.getComposedMessage(""only.one.of.artbox.or.trimbox.can.exist.in.the.page""));
				 if (!thisBoxSize.containsKey(""art"") && !thisBoxSize.containsKey(""trim"")) {
					 if (thisBoxSize.containsKey(""crop"")) thisBoxSize.put(""trim"", thisBoxSize.get(""crop""));
					 else thisBoxSize.put(""trim"", new PdfRectangle(pageSize, pageSize.getRotation()));
				 }
			 }
			 pageResources.addDefaultColorDiff(writer.getDefaultColorspace());
			 if (writer.isRgbTransparencyBlending()) {
				 PdfDictionary dcs = new PdfDictionary();
				 dcs.put(PdfName.CS, PdfName.DEVICERGB);
				 pageResources.addDefaultColorDiff(dcs);
			 }
			 PdfDictionary resources = pageResources.getResources();
			 PdfPage page = new PdfPage(new PdfRectangle(pageSize, rotation), thisBoxSize, resources, rotation);
			 page.put(PdfName.TABS, writer.getTabs());
			 if (xmpMetadata != null) {
				 PdfStream xmp = new PdfStream(xmpMetadata);
				 xmp.put(PdfName.TYPE, PdfName.METADATA);
				 xmp.put(PdfName.SUBTYPE, PdfName.XML);
				 PdfEncryption crypto = writer.getEncryption();
				 if (crypto != null && !crypto.isMetadataEncrypted()) {
					 PdfArray ar = new PdfArray();
					 ar.add(PdfName.CRYPT);
					 xmp.put(PdfName.FILTER, ar);
				 }
				 page.put(PdfName.METADATA, writer.addToBody(xmp).getIndirectReference());
			 }
			 if (this.transition!=null) {
				 page.put(PdfName.TRANS, this.transition.getTransitionDictionary());
				 transition = null;
			 }
			 if (this.duration>0) {
				 page.put(PdfName.DUR,new PdfNumber(this.duration));
				 duration = 0;
			 }
			 if (pageAA != null) {
				 page.put(PdfName.AA, writer.addToBody(pageAA).getIndirectReference());
				 pageAA = null;
			 }
			 if (thumb != null) {
				 page.put(PdfName.THUMB, thumb);
				 thumb = null;
			 }
			 if (writer.getUserunit() > 0f) {
				 page.put(PdfName.USERUNIT, new PdfNumber(writer.getUserunit()));
			 }
			 if (annotationsImp.hasUnusedAnnotations()) {
				 PdfArray array = annotationsImp.rotateAnnotations(writer, pageSize);
				 if (array.size() != 0) page.put(PdfName.ANNOTS, array);
			 }
			 if (writer.isTagged()) page.put(PdfName.STRUCTPARENTS, new PdfNumber(writer.getCurrentPageNumber() - 1));
			 if (text.size() > textEmptySize) text.endText();
			 else text = null;
			 writer.add(page, new PdfContents(writer.getDirectContentUnder(), graphics, text, writer.getDirectContent(), pageSize));
			 initPage();
		 }
		 catch(DocumentException de) {
			 throw new ExceptionConverter(de);
		 }
		 catch (IOException ioe) {
			 throw new ExceptionConverter(ioe);
		 }
		 return true;
	 }
	 public boolean setPageSize(Rectangle pageSize) {
		 if (writer != null && writer.isPaused()) {
			 return false;
		 }
		 nextPageSize = new Rectangle(pageSize);
		 return true;
	 }
	 protected float nextMarginLeft;
	 protected float nextMarginRight;
	 protected float nextMarginTop;
	 protected float nextMarginBottom;
	 public boolean setMargins(float marginLeft, float marginRight, float marginTop, float marginBottom) {
		 if (writer != null && writer.isPaused()) {
			 return false;
		 }
		 nextMarginLeft = marginLeft;
		 nextMarginRight = marginRight;
		 nextMarginTop = marginTop;
		 nextMarginBottom = marginBottom;
		 return true;
	 }
	 public boolean setMarginMirroring(boolean MarginMirroring) {
		 if (writer != null && writer.isPaused()) {
			 return false;
		 }
		 return super.setMarginMirroring(MarginMirroring);
	 }
	 public boolean setMarginMirroringTopBottom(boolean MarginMirroringTopBottom) {
		 if (writer != null && writer.isPaused()) {
			 return false;
		 }
		 return super.setMarginMirroringTopBottom(MarginMirroringTopBottom);
	 }
	 public void setPageCount(int pageN) {
		 if (writer != null && writer.isPaused()) {
			 return;
		 }
		 super.setPageCount(pageN);
	 }
	 public void resetPageCount() {
		 if (writer != null && writer.isPaused()) {
			 return;
		 }
		 super.resetPageCount();
	 }
	 protected boolean firstPageEvent = true;
	 protected void initPage() throws DocumentException {
		 pageN++;
		 annotationsImp.resetAnnotations();
		 pageResources = new PageResources();
		 writer.resetContent();
		 graphics = new PdfContentByte(writer);
		 markPoint = 0;
		 setNewPageSizeAndMargins();
		 imageEnd = -1;
		 indentation.imageIndentRight = 0;
		 indentation.imageIndentLeft = 0;
		 indentation.indentBottom = 0;
		 indentation.indentTop = 0;
		 currentHeight = 0;
		 thisBoxSize = new HashMap<String, PdfRectangle>(boxSize);
		 if (pageSize.getBackgroundColor() != null || pageSize.hasBorders() || pageSize.getBorderColor() != null) {
			 add(pageSize);
		 }
		 float oldleading = leading;
		 int oldAlignment = alignment;
		 pageEmpty = true;
		 try {
			 if (imageWait != null) {
				 add(imageWait);
				 imageWait = null;
			 }
		 }
		 catch(Exception e) {
			 throw new ExceptionConverter(e);
		 }
		 leading = oldleading;
		 alignment = oldAlignment;
		 carriageReturn();
		 PdfPageEvent pageEvent = writer.getPageEvent();
		 if (pageEvent != null) {
			 if (firstPageEvent) {
				 pageEvent.onOpenDocument(writer, this);
			 }
			 pageEvent.onStartPage(writer, this);
		 }
		 firstPageEvent = false;
	 }
	 protected PdfLine line = null;
	 protected ArrayList<PdfLine> lines = new ArrayList<PdfLine>();
	 protected void newLine() throws DocumentException {
		 lastElementType = -1;
		 carriageReturn();
		 if (lines != null && !lines.isEmpty()) {
			 lines.add(line);
			 currentHeight += line.height();
		 }
		 line = new PdfLine(indentLeft(), indentRight(), alignment, leading);
	 }
	 protected void carriageReturn() {
		 if (lines == null) {
			 lines = new ArrayList<PdfLine>();
		 }
		 if (line != null) {
			 if (currentHeight + line.height() + leading < indentTop() - indentBottom()) {
				 if (line.size() > 0) {
					 currentHeight += line.height();
					 lines.add(line);
					 pageEmpty = false;
				 }
			 }
			 else {
				 newPage();
			 }
		 }
		 if (imageEnd > -1 && currentHeight > imageEnd) {
			 imageEnd = -1;
			 indentation.imageIndentRight = 0;
			 indentation.imageIndentLeft = 0;
		 }
		 line = new PdfLine(indentLeft(), indentRight(), alignment, leading);
	 }
	 public float getVerticalPosition(boolean ensureNewLine) {
		 if (ensureNewLine) {
			 ensureNewLine();
		 }
		 return top() - currentHeight - indentation.indentTop;
	 }
	 protected int lastElementType = -1;
	 protected void ensureNewLine() {
		 try {
			 if (lastElementType == Element.PHRASE || lastElementType == Element.CHUNK) {
				 newLine();
				 flushLines();
			 }
		 }
		 catch (DocumentException ex) {
			 throw new ExceptionConverter(ex);
		 }
	 }
	 protected float flushLines() throws DocumentException {
		 if (lines == null) {
			 return 0;
		 }
		 if (line != null && line.size() > 0) {
			 lines.add(line);
			 line = new PdfLine(indentLeft(), indentRight(), alignment, leading);
		 }
		 if (lines.isEmpty()) {
			 return 0;
		 }
		 Object currentValues[] = new Object[2];
		 PdfFont currentFont = null;
		 float displacement = 0;
		 Float lastBaseFactor = new Float(0);
		 currentValues[1] = lastBaseFactor;
		 for (PdfLine l: lines) {
			 float moveTextX = l.indentLeft() - indentLeft() + indentation.indentLeft + indentation.listIndentLeft + indentation.sectionIndentLeft;
			 text.moveText(moveTextX, -l.height());
			 if (l.listSymbol() != null) {
				 ColumnText.showTextAligned(graphics, Element.ALIGN_LEFT, new Phrase(l.listSymbol()), text.getXTLM() - l.listIndent(), text.getYTLM(), 0);
			 }
			 currentValues[0] = currentFont;
			 writeLineToContent(l, text, graphics, currentValues, writer.getSpaceCharRatio());
			 currentFont = (PdfFont)currentValues[0];
			 displacement += l.height();
			 text.moveText(-moveTextX, 0);
		 }
		 lines = new ArrayList<PdfLine>();
		 return displacement;
	 }
	 static final String hangingPunctuation = "".,;
	:'"";
	 float writeLineToContent(PdfLine line, PdfContentByte text, PdfContentByte graphics, Object currentValues[], float ratio) throws DocumentException {
		 PdfFont currentFont = (PdfFont)currentValues[0];
		 float lastBaseFactor = ((Float)currentValues[1]).floatValue();
		 PdfChunk chunk;
		 int numberOfSpaces;
		 int lineLen;
		 boolean isJustified;
		 float hangingCorrection = 0;
		 float hScale = 1;
		 float lastHScale = Float.NaN;
		 float baseWordSpacing = 0;
		 float baseCharacterSpacing = 0;
		 float glueWidth = 0;
		 float lastX = text.getXTLM() + line.getOriginalWidth();
		 numberOfSpaces = line.numberOfSpaces();
		 lineLen = line.getLineLengthUtf32();
		 isJustified = line.hasToBeJustified() && (numberOfSpaces != 0 || lineLen > 1);
		 int separatorCount = line.getSeparatorCount();
		 if (separatorCount > 0) {
			 glueWidth = line.widthLeft() / separatorCount;
		 }
		 else if (isJustified && separatorCount == 0) {
			 if (line.isNewlineSplit() && line.widthLeft() >= lastBaseFactor * (ratio * numberOfSpaces + lineLen - 1)) {
				 if (line.isRTL()) {
					 text.moveText(line.widthLeft() - lastBaseFactor * (ratio * numberOfSpaces + lineLen - 1), 0);
				 }
				 baseWordSpacing = ratio * lastBaseFactor;
				 baseCharacterSpacing = lastBaseFactor;
			 }
			 else {
				 float width = line.widthLeft();
				 PdfChunk last = line.getChunk(line.size() - 1);
				 if (last != null) {
					 String s = last.toString();
					 char c;
					 if (s.length() > 0 && hangingPunctuation.indexOf((c = s.charAt(s.length() - 1))) >= 0) {
						 float oldWidth = width;
						 width += last.font().width(c) * 0.4f;
						 hangingCorrection = width - oldWidth;
					 }
				 }
				 float baseFactor = width / (ratio * numberOfSpaces + lineLen - 1);
				 baseWordSpacing = ratio * baseFactor;
				 baseCharacterSpacing = baseFactor;
				 lastBaseFactor = baseFactor;
			 }
		 }
		 else if (line.alignment == Element.ALIGN_LEFT || line.alignment == Element.ALIGN_UNDEFINED) {
			 lastX -= line.widthLeft();
		 }
		 int lastChunkStroke = line.getLastStrokeChunk();
		 int chunkStrokeIdx = 0;
		 float xMarker = text.getXTLM();
		 float baseXMarker = xMarker;
		 float yMarker = text.getYTLM();
		 boolean adjustMatrix = false;
		 float tabPosition = 0;
		 for (Iterator<PdfChunk> j = line.iterator();
		 j.hasNext();
		 ) {
			 chunk = j.next();
			 BaseColor color = chunk.color();
			 float fontSize = chunk.font().size();
			 float ascender = chunk.font().getFont().getFontDescriptor(BaseFont.ASCENT, fontSize);
			 float descender = chunk.font().getFont().getFontDescriptor(BaseFont.DESCENT, fontSize);
			 hScale = 1;
			 if (chunkStrokeIdx <= lastChunkStroke) {
				 float width;
				 if (isJustified) {
					 width = chunk.getWidthCorrected(baseCharacterSpacing, baseWordSpacing);
				 }
				 else {
					 width = chunk.width();
				 }
				 if (chunk.isStroked()) {
					 PdfChunk nextChunk = line.getChunk(chunkStrokeIdx + 1);
					 if (chunk.isSeparator()) {
						 width = glueWidth;
						 Object[] sep = (Object[])chunk.getAttribute(Chunk.SEPARATOR);
						 DrawInterface di = (DrawInterface)sep[0];
						 Boolean vertical = (Boolean)sep[1];
						 if (vertical.booleanValue()) {
							 di.draw(graphics, baseXMarker, yMarker + descender, baseXMarker + line.getOriginalWidth(), ascender - descender, yMarker);
						 }
						 else {
							 di.draw(graphics, xMarker, yMarker + descender, xMarker + width, ascender - descender, yMarker);
						 }
					 }
					 if (chunk.isTab()) {
						 Object[] tab = (Object[])chunk.getAttribute(Chunk.TAB);
						 DrawInterface di = (DrawInterface)tab[0];
						 tabPosition = ((Float)tab[1]).floatValue() + ((Float)tab[3]).floatValue();
						 if (tabPosition > xMarker) {
							 di.draw(graphics, xMarker, yMarker + descender, tabPosition, ascender - descender, yMarker);
						 }
						 float tmp = xMarker;
						 xMarker = tabPosition;
						 tabPosition = tmp;
					 }
					 if (chunk.isAttribute(Chunk.BACKGROUND)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.BACKGROUND)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 Object bgr[] = (Object[])chunk.getAttribute(Chunk.BACKGROUND);
						 graphics.setColorFill((BaseColor)bgr[0]);
						 float extra[] = (float[])bgr[1];
						 graphics.rectangle(xMarker - extra[0], yMarker + descender - extra[1] + chunk.getTextRise(), width - subtract + extra[0] + extra[2], ascender - descender + extra[1] + extra[3]);
						 graphics.fill();
						 graphics.setGrayFill(0);
					 }
					 if (chunk.isAttribute(Chunk.UNDERLINE)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.UNDERLINE)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 Object unders[][] = (Object[][])chunk.getAttribute(Chunk.UNDERLINE);
						 BaseColor scolor = null;
						 for (int k = 0;
						 k < unders.length;
						 ++k) {
							 Object obj[] = unders[k];
							 scolor = (BaseColor)obj[0];
							 float ps[] = (float[])obj[1];
							 if (scolor == null) scolor = color;
							 if (scolor != null) graphics.setColorStroke(scolor);
							 graphics.setLineWidth(ps[0] + fontSize * ps[1]);
							 float shift = ps[2] + fontSize * ps[3];
							 int cap2 = (int)ps[4];
							 if (cap2 != 0) graphics.setLineCap(cap2);
							 graphics.moveTo(xMarker, yMarker + shift);
							 graphics.lineTo(xMarker + width - subtract, yMarker + shift);
							 graphics.stroke();
							 if (scolor != null) graphics.resetGrayStroke();
							 if (cap2 != 0) graphics.setLineCap(0);
						 }
						 graphics.setLineWidth(1);
					 }
					 if (chunk.isAttribute(Chunk.ACTION)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.ACTION)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 text.addAnnotation(new PdfAnnotation(writer, xMarker, yMarker + descender + chunk.getTextRise(), xMarker + width - subtract, yMarker + ascender + chunk.getTextRise(), (PdfAction)chunk.getAttribute(Chunk.ACTION)));
					 }
					 if (chunk.isAttribute(Chunk.REMOTEGOTO)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.REMOTEGOTO)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 Object obj[] = (Object[])chunk.getAttribute(Chunk.REMOTEGOTO);
						 String filename = (String)obj[0];
						 if (obj[1] instanceof String) remoteGoto(filename, (String)obj[1], xMarker, yMarker + descender + chunk.getTextRise(), xMarker + width - subtract, yMarker + ascender + chunk.getTextRise());
						 else remoteGoto(filename, ((Integer)obj[1]).intValue(), xMarker, yMarker + descender + chunk.getTextRise(), xMarker + width - subtract, yMarker + ascender + chunk.getTextRise());
					 }
					 if (chunk.isAttribute(Chunk.LOCALGOTO)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.LOCALGOTO)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 localGoto((String)chunk.getAttribute(Chunk.LOCALGOTO), xMarker, yMarker, xMarker + width - subtract, yMarker + fontSize);
					 }
					 if (chunk.isAttribute(Chunk.LOCALDESTINATION)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.LOCALDESTINATION)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 localDestination((String)chunk.getAttribute(Chunk.LOCALDESTINATION), new PdfDestination(PdfDestination.XYZ, xMarker, yMarker + fontSize, 0));
					 }
					 if (chunk.isAttribute(Chunk.GENERICTAG)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.GENERICTAG)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 Rectangle rect = new Rectangle(xMarker, yMarker, xMarker + width - subtract, yMarker + fontSize);
						 PdfPageEvent pev = writer.getPageEvent();
						 if (pev != null) pev.onGenericTag(writer, this, rect, (String)chunk.getAttribute(Chunk.GENERICTAG));
					 }
					 if (chunk.isAttribute(Chunk.PDFANNOTATION)) {
						 float subtract = lastBaseFactor;
						 if (nextChunk != null && nextChunk.isAttribute(Chunk.PDFANNOTATION)) subtract = 0;
						 if (nextChunk == null) subtract += hangingCorrection;
						 PdfAnnotation annot = PdfFormField.shallowDuplicate((PdfAnnotation)chunk.getAttribute(Chunk.PDFANNOTATION));
						 annot.put(PdfName.RECT, new PdfRectangle(xMarker, yMarker + descender, xMarker + width - subtract, yMarker + ascender));
						 text.addAnnotation(annot);
					 }
					 float params[] = (float[])chunk.getAttribute(Chunk.SKEW);
					 Float hs = (Float)chunk.getAttribute(Chunk.HSCALE);
					 if (params != null || hs != null) {
						 float b = 0, c = 0;
						 if (params != null) {
							 b = params[0];
							 c = params[1];
						 }
						 if (hs != null) hScale = hs.floatValue();
						 text.setTextMatrix(hScale, b, c, 1, xMarker, yMarker);
					 }
					 if (chunk.isAttribute(Chunk.CHAR_SPACING)) {
						 Float cs = (Float) chunk.getAttribute(Chunk.CHAR_SPACING);
						text.setCharacterSpacing(cs.floatValue());
					}
					 if (chunk.isImage()) {
						 Image image = chunk.getImage();
						 float matrix[] = image.matrix();
						 matrix[Image.CX] = xMarker + chunk.getImageOffsetX() - matrix[Image.CX];
						 matrix[Image.CY] = yMarker + chunk.getImageOffsetY() - matrix[Image.CY];
						 graphics.addImage(image, matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
						 text.moveText(xMarker + lastBaseFactor + image.getScaledWidth() - text.getXTLM(), 0);
					 }
				 }
				 xMarker += width;
				 ++chunkStrokeIdx;
			 }
			 if (chunk.font().compareTo(currentFont) != 0) {
				 currentFont = chunk.font();
				 text.setFontAndSize(currentFont.getFont(), currentFont.size());
			 }
			 float rise = 0;
			 Object textRender[] = (Object[])chunk.getAttribute(Chunk.TEXTRENDERMODE);
			 int tr = 0;
			 float strokeWidth = 1;
			 BaseColor strokeColor = null;
			 Float fr = (Float)chunk.getAttribute(Chunk.SUBSUPSCRIPT);
			 if (textRender != null) {
				 tr = ((Integer)textRender[0]).intValue() & 3;
				 if (tr != PdfContentByte.TEXT_RENDER_MODE_FILL) text.setTextRenderingMode(tr);
				 if (tr == PdfContentByte.TEXT_RENDER_MODE_STROKE || tr == PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE) {
					 strokeWidth = ((Float)textRender[1]).floatValue();
					 if (strokeWidth != 1) text.setLineWidth(strokeWidth);
					 strokeColor = (BaseColor)textRender[2];
					 if (strokeColor == null) strokeColor = color;
					 if (strokeColor != null) text.setColorStroke(strokeColor);
				 }
			 }
			 if (fr != null) rise = fr.floatValue();
			 if (color != null) text.setColorFill(color);
			 if (rise != 0) text.setTextRise(rise);
			 if (chunk.isImage()) {
				 adjustMatrix = true;
			 }
			 else if (chunk.isHorizontalSeparator()) {
				 PdfTextArray array = new PdfTextArray();
				 array.add(-glueWidth * 1000f / chunk.font.size() / hScale);
				 text.showText(array);
			 }
			 else if (chunk.isTab()) {
				 PdfTextArray array = new PdfTextArray();
				 array.add((tabPosition - xMarker) * 1000f / chunk.font.size() / hScale);
				 text.showText(array);
			 }
			 else if (isJustified && numberOfSpaces > 0 && chunk.isSpecialEncoding()) {
				 if (hScale != lastHScale) {
					 lastHScale = hScale;
					 text.setWordSpacing(baseWordSpacing / hScale);
					 text.setCharacterSpacing(baseCharacterSpacing / hScale + text.getCharacterSpacing());
				 }
				 String s = chunk.toString();
				 int idx = s.indexOf(' ');
				 if (idx < 0) text.showText(s);
				 else {
					 float spaceCorrection = - baseWordSpacing * 1000f / chunk.font.size() / hScale;
					 PdfTextArray textArray = new PdfTextArray(s.substring(0, idx));
					 int lastIdx = idx;
					 while ((idx = s.indexOf(' ', lastIdx + 1)) >= 0) {
						 textArray.add(spaceCorrection);
						 textArray.add(s.substring(lastIdx, idx));
						 lastIdx = idx;
					 }
					 textArray.add(spaceCorrection);
					 textArray.add(s.substring(lastIdx));
					 text.showText(textArray);
				 }
			 }
			 else {
				 if (isJustified && hScale != lastHScale) {
					 lastHScale = hScale;
					 text.setWordSpacing(baseWordSpacing / hScale);
					 text.setCharacterSpacing(baseCharacterSpacing / hScale + text.getCharacterSpacing());
				 }
				 text.showText(chunk.toString());
			 }
			 if (rise != 0) text.setTextRise(0);
			 if (color != null) text.resetRGBColorFill();
			 if (tr != PdfContentByte.TEXT_RENDER_MODE_FILL) text.setTextRenderingMode(PdfContentByte.TEXT_RENDER_MODE_FILL);
			 if (strokeColor != null) text.resetRGBColorStroke();
			 if (strokeWidth != 1) text.setLineWidth(1);
			 if (chunk.isAttribute(Chunk.SKEW) || chunk.isAttribute(Chunk.HSCALE)) {
				 adjustMatrix = true;
				 text.setTextMatrix(xMarker, yMarker);
			 }
			 if (chunk.isAttribute(Chunk.CHAR_SPACING)) {
				text.setCharacterSpacing(baseCharacterSpacing);
			 }
		 }
		 if (isJustified) {
			 text.setWordSpacing(0);
			 text.setCharacterSpacing(0);
			 if (line.isNewlineSplit()) lastBaseFactor = 0;
		 }
		 if (adjustMatrix) text.moveText(baseXMarker - text.getXTLM(), 0);
		 currentValues[0] = currentFont;
		 currentValues[1] = new Float(lastBaseFactor);
		 return lastX;
	 }
	 protected Indentation indentation = new Indentation();
	 public static class Indentation {
		 float indentLeft = 0;
		 float sectionIndentLeft = 0;
		 float listIndentLeft = 0;
		 float imageIndentLeft = 0;
		 float indentRight = 0;
		 float sectionIndentRight = 0;
		 float imageIndentRight = 0;
		 float indentTop = 0;
		 float indentBottom = 0;
	 }
	 protected float indentLeft() {
		 return left(indentation.indentLeft + indentation.listIndentLeft + indentation.imageIndentLeft + indentation.sectionIndentLeft);
	 }
	 protected float indentRight() {
		 return right(indentation.indentRight + indentation.sectionIndentRight + indentation.imageIndentRight);
	 }
	 protected float indentTop() {
		 return top(indentation.indentTop);
	 }
	 float indentBottom() {
		 return bottom(indentation.indentBottom);
	 }
	 protected void addSpacing(float extraspace, float oldleading, Font f) {
		 if (extraspace == 0) return;
		 if (pageEmpty) return;
		 if (currentHeight + line.height() + leading > indentTop() - indentBottom()) return;
		 leading = extraspace;
		 carriageReturn();
		 if (f.isUnderlined() || f.isStrikethru()) {
			 f = new Font(f);
			 int style = f.getStyle();
			 style &= ~Font.UNDERLINE;
			 style &= ~Font.STRIKETHRU;
			 f.setStyle(style);
		 }
		 Chunk space = new Chunk("" "", f);
		 space.process(this);
		 carriageReturn();
		 leading = oldleading;
	 }
	 protected PdfInfo info = new PdfInfo();
	 PdfInfo getInfo() {
		 return info;
	 }
	 PdfCatalog getCatalog(PdfIndirectReference pages) {
		 PdfCatalog catalog = new PdfCatalog(pages, writer);
		 if (rootOutline.getKids().size() > 0) {
			 catalog.put(PdfName.PAGEMODE, PdfName.USEOUTLINES);
			 catalog.put(PdfName.OUTLINES, rootOutline.indirectReference());
		 }
		 writer.getPdfVersion().addToCatalog(catalog);
		 viewerPreferences.addToCatalog(catalog);
		 if (pageLabels != null) {
			 catalog.put(PdfName.PAGELABELS, pageLabels.getDictionary(writer));
		 }
		 catalog.addNames(localDestinations, getDocumentLevelJS(), documentFileAttachment, writer);
		 if (openActionName != null) {
			 PdfAction action = getLocalGotoAction(openActionName);
			 catalog.setOpenAction(action);
		 }
		 else if (openActionAction != null) catalog.setOpenAction(openActionAction);
		 if (additionalActions != null) {
			 catalog.setAdditionalActions(additionalActions);
		 }
		 if (collection != null) {
			 catalog.put(PdfName.COLLECTION, collection);
		 }
		 if (annotationsImp.hasValidAcroForm()) {
			 try {
				 catalog.put(PdfName.ACROFORM, writer.addToBody(annotationsImp.getAcroForm()).getIndirectReference());
			 }
			 catch (IOException e) {
				 throw new ExceptionConverter(e);
			 }
		 }
		 return catalog;
	 }
	 protected PdfOutline rootOutline;
	 protected PdfOutline currentOutline;
	 void addOutline(PdfOutline outline, String name) {
		 localDestination(name, outline.getPdfDestination());
	 }
	 public PdfOutline getRootOutline() {
		 return rootOutline;
	 }
	 void calculateOutlineCount() {
		 if (rootOutline.getKids().size() == 0) return;
		 traverseOutlineCount(rootOutline);
	 }
	 void traverseOutlineCount(PdfOutline outline) {
		 ArrayList<PdfOutline> kids = outline.getKids();
		 PdfOutline parent = outline.parent();
		 if (kids.isEmpty()) {
			 if (parent != null) {
				 parent.setCount(parent.getCount() + 1);
			 }
		 }
		 else {
			 for (int k = 0;
			 k < kids.size();
			 ++k) {
				 traverseOutlineCount(kids.get(k));
			 }
			 if (parent != null) {
				 if (outline.isOpen()) {
					 parent.setCount(outline.getCount() + parent.getCount() + 1);
				 }
				 else {
					 parent.setCount(parent.getCount() + 1);
					 outline.setCount(-outline.getCount());
				 }
			 }
		 }
	 }
	 void writeOutlines() throws IOException {
		 if (rootOutline.getKids().size() == 0) return;
		 outlineTree(rootOutline);
		 writer.addToBody(rootOutline, rootOutline.indirectReference());
	 }
	 void outlineTree(PdfOutline outline) throws IOException {
		 outline.setIndirectReference(writer.getPdfIndirectReference());
		 if (outline.parent() != null) outline.put(PdfName.PARENT, outline.parent().indirectReference());
		 ArrayList<PdfOutline> kids = outline.getKids();
		 int size = kids.size();
		 for (int k = 0;
		 k < size;
		 ++k) outlineTree(kids.get(k));
		 for (int k = 0;
		 k < size;
		 ++k) {
			 if (k > 0) kids.get(k).put(PdfName.PREV, kids.get(k - 1).indirectReference());
			 if (k < size - 1) kids.get(k).put(PdfName.NEXT, kids.get(k + 1).indirectReference());
		 }
		 if (size > 0) {
			 outline.put(PdfName.FIRST, kids.get(0).indirectReference());
			 outline.put(PdfName.LAST, kids.get(size - 1).indirectReference());
		 }
		 for (int k = 0;
		 k < size;
		 ++k) {
			 PdfOutline kid = kids.get(k);
			 writer.addToBody(kid, kid.indirectReference());
		 }
	 }
	 protected PdfViewerPreferencesImp viewerPreferences = new PdfViewerPreferencesImp();
	 void setViewerPreferences(int preferences) {
		 this.viewerPreferences.setViewerPreferences(preferences);
	 }
	 void addViewerPreference(PdfName key, PdfObject value) {
		 this.viewerPreferences.addViewerPreference(key, value);
	 }
	 protected PdfPageLabels pageLabels;
	 void setPageLabels(PdfPageLabels pageLabels) {
		 this.pageLabels = pageLabels;
	 }
	 void localGoto(String name, float llx, float lly, float urx, float ury) {
		 PdfAction action = getLocalGotoAction(name);
		 annotationsImp.addPlainAnnotation(new PdfAnnotation(writer, llx, lly, urx, ury, action));
	 }
	 void remoteGoto(String filename, String name, float llx, float lly, float urx, float ury) {
		 annotationsImp.addPlainAnnotation(new PdfAnnotation(writer, llx, lly, urx, ury, new PdfAction(filename, name)));
	 }
	 void remoteGoto(String filename, int page, float llx, float lly, float urx, float ury) {
		 addAnnotation(new PdfAnnotation(writer, llx, lly, urx, ury, new PdfAction(filename, page)));
	 }
	 void setAction(PdfAction action, float llx, float lly, float urx, float ury) {
		 addAnnotation(new PdfAnnotation(writer, llx, lly, urx, ury, action));
	 }
	 protected TreeMap<String, Destination> localDestinations = new TreeMap<String, Destination>();
	 PdfAction getLocalGotoAction(String name) {
		 PdfAction action;
		 Destination dest = localDestinations.get(name);
		 if (dest == null) dest = new Destination();
		 if (dest.action == null) {
			 if (dest.reference == null) {
				 dest.reference = writer.getPdfIndirectReference();
			 }
			 action = new PdfAction(dest.reference);
			 dest.action = action;
			 localDestinations.put(name, dest);
		 }
		 else {
			 action = dest.action;
		 }
		 return action;
	 }
	 boolean localDestination(String name, PdfDestination destination) {
		 Destination dest = localDestinations.get(name);
		 if (dest == null) dest = new Destination();
		 if (dest.destination != null) return false;
		 dest.destination = destination;
		 localDestinations.put(name, dest);
		 if (!destination.hasPage()) destination.addPage(writer.getCurrentPage());
		 return true;
	 }
	 int jsCounter;
	 protected HashMap<String, PdfObject> documentLevelJS = new HashMap<String, PdfObject>();
	 protected static final DecimalFormat SIXTEEN_DIGITS = new DecimalFormat(""0000000000000000"");
	 void addJavaScript(PdfAction js) {
		 if (js.get(PdfName.JS) == null) throw new RuntimeException(MessageLocalization.getComposedMessage(""only.javascript.actions.are.allowed""));
		 try {
			 documentLevelJS.put(SIXTEEN_DIGITS.format(jsCounter++), writer.addToBody(js).getIndirectReference());
		 }
		 catch (IOException e) {
			 throw new ExceptionConverter(e);
		 }
	 }
	 void addJavaScript(String name, PdfAction js) {
		 if (js.get(PdfName.JS) == null) throw new RuntimeException(MessageLocalization.getComposedMessage(""only.javascript.actions.are.allowed""));
		 try {
			 documentLevelJS.put(name, writer.addToBody(js).getIndirectReference());
		 }
		 catch (IOException e) {
			 throw new ExceptionConverter(e);
		 }
	 }
	 HashMap<String, PdfObject> getDocumentLevelJS() {
		 return documentLevelJS;
	 }
	 protected HashMap<String, PdfObject> documentFileAttachment = new HashMap<String, PdfObject>();
	 void addFileAttachment(String description, PdfFileSpecification fs) throws IOException {
		 if (description == null) {
			 PdfString desc = (PdfString)fs.get(PdfName.DESC);
			 if (desc == null) {
				 description = """";
			 }
			 else {
				 description = PdfEncodings.convertToString(desc.getBytes(), null);
			 }
		 }
		 fs.addDescription(description, true);
		 if (description.length() == 0) description = ""Unnamed"";
		 String fn = PdfEncodings.convertToString(new PdfString(description, PdfObject.TEXT_UNICODE).getBytes(), null);
		 int k = 0;
		 while (documentFileAttachment.containsKey(fn)) {
			 ++k;
			 fn = PdfEncodings.convertToString(new PdfString(description + "" "" + k, PdfObject.TEXT_UNICODE).getBytes(), null);
		 }
		 documentFileAttachment.put(fn, fs.getReference());
	 }
	 HashMap<String, PdfObject> getDocumentFileAttachment() {
		 return documentFileAttachment;
	 }
	 protected String openActionName;
	 void setOpenAction(String name) {
		 openActionName = name;
		 openActionAction = null;
	 }
	 protected PdfAction openActionAction;
	 void setOpenAction(PdfAction action) {
		 openActionAction = action;
		 openActionName = null;
	 }
	 protected PdfDictionary additionalActions;
	 void addAdditionalAction(PdfName actionType, PdfAction action) {
		 if (additionalActions == null) {
			 additionalActions = new PdfDictionary();
		 }
		 if (action == null) additionalActions.remove(actionType);
		 else additionalActions.put(actionType, action);
		 if (additionalActions.size() == 0) additionalActions = null;
	 }
	 protected PdfCollection collection;
	public void setCollection(PdfCollection collection) {
		this.collection = collection;
	}
	PdfAnnotationsImp annotationsImp;
	 PdfAcroForm getAcroForm() {
		 return annotationsImp.getAcroForm();
	 }
	 void setSigFlags(int f) {
		 annotationsImp.setSigFlags(f);
	 }
	 void addCalculationOrder(PdfFormField formField) {
		 annotationsImp.addCalculationOrder(formField);
	 }
	 void addAnnotation(PdfAnnotation annot) {
		 pageEmpty = false;
		 annotationsImp.addAnnotation(annot);
	 }
	 protected int markPoint;
	int getMarkPoint() {
		 return markPoint;
	}
	void incMarkPoint() {
		 ++markPoint;
	}
	 protected Rectangle nextPageSize = null;
	 protected HashMap<String, PdfRectangle> thisBoxSize = new HashMap<String, PdfRectangle>();
	 protected HashMap<String, PdfRectangle> boxSize = new HashMap<String, PdfRectangle>();
	 void setCropBoxSize(Rectangle crop) {
		 setBoxSize(""crop"", crop);
	 }
	 void setBoxSize(String boxName, Rectangle size) {
		 if (size == null) boxSize.remove(boxName);
		 else boxSize.put(boxName, new PdfRectangle(size));
	 }
	 protected void setNewPageSizeAndMargins() {
		 pageSize = nextPageSize;
		 if (marginMirroring && (getPageNumber() & 1) == 0) {
			 marginRight = nextMarginLeft;
			 marginLeft = nextMarginRight;
		 }
		 else {
			 marginLeft = nextMarginLeft;
			 marginRight = nextMarginRight;
		 }
		 if (marginMirroringTopBottom && (getPageNumber() & 1) == 0) {
			 marginTop = nextMarginBottom;
			 marginBottom = nextMarginTop;
		 }
		 else {
			 marginTop = nextMarginTop;
			 marginBottom = nextMarginBottom;
		 }
		 text = new PdfContentByte(writer);
		 text.reset();
		 text.beginText();
		 textEmptySize = text.size();
		 text.moveText(left(), top());
	 }
	 Rectangle getBoxSize(String boxName) {
		 PdfRectangle r = thisBoxSize.get(boxName);
		 if (r != null) return r.getRectangle();
		 return null;
	 }
	 private boolean pageEmpty = true;
	 void setPageEmpty(boolean pageEmpty) {
		 this.pageEmpty = pageEmpty;
	 }
	 boolean isPageEmpty() {
		 return writer == null || writer.getDirectContent().size() == 0 && writer.getDirectContentUnder().size() == 0 && (pageEmpty || writer.isPaused());
	 }
	 protected int duration=-1;
	 protected PdfTransition transition=null;
	 void setDuration(int seconds) {
		 if (seconds > 0) this.duration=seconds;
		 else this.duration=-1;
	 }
	 void setTransition(PdfTransition transition) {
		 this.transition=transition;
	 }
	 protected PdfDictionary pageAA = null;
	 void setPageAction(PdfName actionType, PdfAction action) {
		 if (pageAA == null) {
			 pageAA = new PdfDictionary();
		 }
		 pageAA.put(actionType, action);
	 }
	 protected PdfIndirectReference thumb;
	 void setThumbnail(Image image) throws PdfException, DocumentException {
		 thumb = writer.getImageReference(writer.addDirectImageSimple(image));
	 }
	 protected PageResources pageResources;
	 PageResources getPageResources() {
		 return pageResources;
	 }
	 protected boolean strictImageSequence = false;
	 boolean isStrictImageSequence() {
		 return this.strictImageSequence;
	 }
	 void setStrictImageSequence(boolean strictImageSequence) {
		 this.strictImageSequence = strictImageSequence;
	 }
	 protected float imageEnd = -1;
	public void clearTextWrap() {
		float tmpHeight = imageEnd - currentHeight;
		if (line != null) {
			tmpHeight += line.height();
		}
		if (imageEnd > -1 && tmpHeight > 0) {
			carriageReturn();
			currentHeight += tmpHeight;
		}
	}
	 protected Image imageWait = null;
	 protected void add(Image image) throws PdfException, DocumentException {
		 if (image.hasAbsoluteY()) {
			 graphics.addImage(image);
			 pageEmpty = false;
			 return;
		 }
		 if (currentHeight != 0 && indentTop() - currentHeight - image.getScaledHeight() < indentBottom()) {
			 if (!strictImageSequence && imageWait == null) {
				 imageWait = image;
				 return;
			 }
			 newPage();
			 if (currentHeight != 0 && indentTop() - currentHeight - image.getScaledHeight() < indentBottom()) {
				 imageWait = image;
				 return;
			 }
		 }
		 pageEmpty = false;
		 if (image == imageWait) imageWait = null;
		 boolean textwrap = (image.getAlignment() & Image.TEXTWRAP) == Image.TEXTWRAP && !((image.getAlignment() & Image.MIDDLE) == Image.MIDDLE);
		 boolean underlying = (image.getAlignment() & Image.UNDERLYING) == Image.UNDERLYING;
		 float diff = leading / 2;
		 if (textwrap) {
			 diff += leading;
		 }
		 float lowerleft = indentTop() - currentHeight - image.getScaledHeight() -diff;
		 float mt[] = image.matrix();
		 float startPosition = indentLeft() - mt[4];
		 if ((image.getAlignment() & Image.RIGHT) == Image.RIGHT) startPosition = indentRight() - image.getScaledWidth() - mt[4];
		 if ((image.getAlignment() & Image.MIDDLE) == Image.MIDDLE) startPosition = indentLeft() + (indentRight() - indentLeft() - image.getScaledWidth()) / 2 - mt[4];
		 if (image.hasAbsoluteX()) startPosition = image.getAbsoluteX();
		 if (textwrap) {
			 if (imageEnd < 0 || imageEnd < currentHeight + image.getScaledHeight() + diff) {
				 imageEnd = currentHeight + image.getScaledHeight() + diff;
			 }
			 if ((image.getAlignment() & Image.RIGHT) == Image.RIGHT) {
				 indentation.imageIndentRight += image.getScaledWidth() + image.getIndentationLeft();
			 }
			 else {
				 indentation.imageIndentLeft += image.getScaledWidth() + image.getIndentationRight();
			 }
		 }
		 else {
			 if ((image.getAlignment() & Image.RIGHT) == Image.RIGHT) startPosition -= image.getIndentationRight();
			 else if ((image.getAlignment() & Image.MIDDLE) == Image.MIDDLE) startPosition += image.getIndentationLeft() - image.getIndentationRight();
			 else startPosition += image.getIndentationLeft();
		 }
		 graphics.addImage(image, mt[0], mt[1], mt[2], mt[3], startPosition, lowerleft - mt[5]);
		 if (!(textwrap || underlying)) {
			 currentHeight += image.getScaledHeight() + diff;
			 flushLines();
			 text.moveText(0, - (image.getScaledHeight() + diff));
			 newLine();
		 }
	 }
	 void addPTable(PdfPTable ptable) throws DocumentException {
		 ColumnText ct = new ColumnText(writer.getDirectContent());
		 if (ptable.getKeepTogether() && !fitsPage(ptable, 0f) && currentHeight > 0) {
			 newPage();
		 }
		 if (currentHeight > 0) {
			 Paragraph p = new Paragraph();
			 p.setLeading(0);
			 ct.addElement(p);
		 }
		 ct.addElement(ptable);
		 boolean he = ptable.isHeadersInEvent();
		 ptable.setHeadersInEvent(true);
		 int loop = 0;
		 while (true) {
			 ct.setSimpleColumn(indentLeft(), indentBottom(), indentRight(), indentTop() - currentHeight);
			 int status = ct.go();
			 if ((status & ColumnText.NO_MORE_TEXT) != 0) {
				 text.moveText(0, ct.getYLine() - indentTop() + currentHeight);
				 currentHeight = indentTop() - ct.getYLine();
				 break;
			 }
			 if (indentTop() - currentHeight == ct.getYLine()) ++loop;
			 else loop = 0;
			 if (loop == 3) {
				 add(new Paragraph(""ERROR: Infinite table loop""));
				 break;
			 }
			 newPage();
		 }
		 ptable.setHeadersInEvent(he);
	 }
	 boolean fitsPage(PdfPTable table, float margin) {
		 if (!table.isLockedWidth()) {
			 float totalWidth = (indentRight() - indentLeft()) * table.getWidthPercentage() / 100;
			 table.setTotalWidth(totalWidth);
		 }
		 ensureNewLine();
		 return table.getTotalHeight() + (currentHeight > 0 ? table.spacingBefore() : 0f) <= indentTop() - currentHeight - indentBottom() - margin;
	 }
	 public class Destination {
		 public PdfAction action;
		 public PdfIndirectReference reference;
		 public PdfDestination destination;
	 }
}",1,0,0,0
"public void info(final String message) {
	 task.log(message, Project.MSG_INFO);
 }",0,0,0,0
"public void setMaxParallel(int max) {
	 throw new BuildException(getTaskType() + "" doesn\'t support the maxparallel attribute"", getLocation());
 }",0,0,0,0
"private static final class TomcatInjections {
	 private TomcatInjections() {
	 }
	 private static Map<String, Map<String, String>> buildInjectionMap(final NamingResourcesImpl namingResources) {
		 final Map<String, Map<String, String>> injectionMap = new HashMap<>();
		 for (final Injectable resource : namingResources.findLocalEjbs()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 for (final Injectable resource : namingResources.findEjbs()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 for (final Injectable resource : namingResources.findEnvironments()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 for (final Injectable resource : namingResources.findMessageDestinationRefs()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 for (final Injectable resource : namingResources.findResourceEnvRefs()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 for (final Injectable resource : namingResources.findResources()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 for (final Injectable resource : namingResources.findServices()) {
			 addInjectionTarget(resource, injectionMap);
		 }
		 return injectionMap;
	 }
	 private static void addInjectionTarget(final Injectable resource, final Map<String, Map<String, String>> injectionMap) {
		 final List<InjectionTarget> injectionTargets = resource.getInjectionTargets();
		 if (injectionTargets != null && !injectionTargets.isEmpty()) {
			 final String jndiName = resource.getName();
			 for (final InjectionTarget injectionTarget : injectionTargets) {
				 final String clazz = injectionTarget.getTargetClass();
				 Map<String, String> injections = injectionMap.get(clazz);
				 if (injections == null) {
					 injections = new HashMap<>();
					 injectionMap.put(clazz, injections);
				 }
				 injections.put(injectionTarget.getTargetName(), jndiName);
			 }
		 }
	 }
 }",1,0,0,0
"public OptionalDontShowMeAgainDialog(JFrame pFrame, Component pComponent, String pMessageId,String pTitleId, TextTranslator pTextTranslator, DontShowPropertyHandler pDontShowPropertyHandler, int pMessageType);",0,0,0,1
"public boolean isClosed(){
	return closed;
}",0,0,0,0
"public class HighlightStatus {
	 public static final int NORMAL = 0;
	 public static final int COMMENTED = 1;
	 public static final int SINGLE_QUOTED = 2;
	 public static final int DOUBLE_QUOTED = 3;
	 public static final int KEYWORD = 4;
	 public static final int NUMBER = 5;
	 public static final int TYPE = 6;
	 private int _state;
	 private int _location;
	 private int _length;
	 public HighlightStatus(int location, int length, int state) {
		 _location = location;
		 _length = length;
		 _state = state;
	 }
	 public int getState() {
		 return _state;
	 }
	 public int getLocation() {
		 return _location;
	 }
	 public int getLength() {
		 return _length;
	 }
}",0,1,0,0
"public class MavenWrapperDownloader {
	 private static final String DEFAULT_DOWNLOAD_URL = ""https: private static final String MAVEN_WRAPPER_PROPERTIES_PATH = "".mvn/wrapper/maven-wrapper.properties"";
	 private static final String MAVEN_WRAPPER_JAR_PATH = "".mvn/wrapper/maven-wrapper.jar"";
	 private static final String PROPERTY_NAME_WRAPPER_URL = ""wrapperUrl"";
	 public static void main(String args[]) {
		 System.out.println(""- Downloader started"");
		 File baseDirectory = new File(args[0]);
		 System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());
		 File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
		 String url = DEFAULT_DOWNLOAD_URL;
		 if(mavenWrapperPropertyFile.exists()) {
			 FileInputStream mavenWrapperPropertyFileInputStream = null;
			 try {
				 mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
				 Properties mavenWrapperProperties = new Properties();
				 mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
				 url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
			 }
			 catch (IOException e) {
				 System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
			 }
			 finally {
				 try {
					 if(mavenWrapperPropertyFileInputStream != null) {
						 mavenWrapperPropertyFileInputStream.close();
					 }
				 }
				 catch (IOException e) {
				 }
			 }
		 }
		 System.out.println(""- Downloading from: : "" + url);
		 File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
		 if(!outputFile.getParentFile().exists()) {
			 if(!outputFile.getParentFile().mkdirs()) {
				 System.out.println( ""- ERROR creating output direcrory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
			 }
		 }
		 System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
		 try {
			 downloadFileFromURL(url, outputFile);
			 System.out.println(""Done"");
			 System.exit(0);
		 }
		 catch (Throwable e) {
			 System.out.println(""- Error downloading"");
			 e.printStackTrace();
			 System.exit(1);
		 }
	 }
	 private static void downloadFileFromURL(String urlString, File destination) throws Exception {
		 URL website = new URL(urlString);
		 ReadableByteChannel rbc;
		 rbc = Channels.newChannel(website.openStream());
		 FileOutputStream fos = new FileOutputStream(destination);
		 fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
		 fos.close();
		 rbc.close();
	 }
}",1,0,0,0
"public Object clone() throws CloneNotSupportedException {
	 ProjectComponent pc = (ProjectComponent) super.clone();
	 pc.setLocation(getLocation());
	 pc.setProject(getProject());
	 return pc;
 }",0,0,0,0
"public class LaunchRequest {
	private String jobName;
	String jobParameters;
	public String getJobName() {
		return jobName;
	}
	public void setJobName(String jobName) {
		this.jobName = jobName;
	}
	public String getJobParameters() {
		return jobParameters;
	}
	public void setJobParameters(String jobParameters) {
		this.jobParameters = jobParameters;
	}
}",0,1,0,0
"class TaskInProgress {
	 static final int MAX_TASK_EXECS = 1;
	 static final int MAX_TASK_FAILURES = 4;
	 static final double SPECULATIVE_GAP = 0.2;
	 static final long SPECULATIVE_LAG = 60 * 1000;
	 private static NumberFormat idFormat = NumberFormat.getInstance();
	 static {
		 idFormat.setMinimumIntegerDigits(6);
		 idFormat.setGroupingUsed(false);
	 }
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.mapred.TaskInProgress"");
	 private String jobFile = null;
	 private FileSplit split = null;
	 private int numMaps;
	 private int partition;
	 private JobTracker jobtracker;
	 private String id;
	 private String totalTaskIds[];
	 private JobInProgress job;
	 private int numTaskFailures = 0;
	 private double progress = 0;
	 private String state = """";
	 private long startTime = 0;
	 private long execStartTime = 0 ;
	 private long execFinishTime = 0 ;
	 private int completes = 0;
	 private boolean failed = false;
	 private boolean killed = false;
	 private TreeSet usableTaskIds = new TreeSet();
	 private TreeSet recentTasks = new TreeSet();
	 private JobConf conf;
	 private boolean runSpeculative;
	 private Map<String,List<String>> taskDiagnosticData = new TreeMap();
	 private TreeMap taskStatuses = new TreeMap();
	 private TreeSet machinesWhereFailed = new TreeSet();
	 private TreeSet tasksReportedClosed = new TreeSet();
	 public TaskInProgress(String uniqueString, String jobFile, FileSplit split, JobTracker jobtracker, JobConf conf, JobInProgress job, int partition) {
		 this.jobFile = jobFile;
		 this.split = split;
		 this.jobtracker = jobtracker;
		 this.job = job;
		 this.conf = conf;
		 this.partition = partition;
		 init(uniqueString);
	 }
	 public TaskInProgress(String uniqueString, String jobFile, int numMaps, int partition, JobTracker jobtracker, JobConf conf, JobInProgress job) {
		 this.jobFile = jobFile;
		 this.numMaps = numMaps;
		 this.partition = partition;
		 this.jobtracker = jobtracker;
		 this.job = job;
		 this.conf = conf;
		 init(uniqueString);
	 }
	 private String makeUniqueString(String uniqueBase) {
		 StringBuffer result = new StringBuffer();
		 result.append(uniqueBase);
		 if (isMapTask()) {
			 result.append(""_m_"");
		 }
		 else {
			 result.append(""_r_"");
		 }
		 result.append(idFormat.format(partition));
		 return result.toString();
	 }
	 void init(String jobUniqueString) {
		 this.startTime = System.currentTimeMillis();
		 this.runSpeculative = conf.getSpeculativeExecution();
		 String uniqueString = makeUniqueString(jobUniqueString);
		 this.id = ""tip_"" + uniqueString;
		 this.totalTaskIds = new String[MAX_TASK_EXECS + MAX_TASK_FAILURES];
		 for (int i = 0;
		 i < totalTaskIds.length;
		 i++) {
			 totalTaskIds[i] = ""task_"" + uniqueString + ""_"" + i;
			 usableTaskIds.add(totalTaskIds[i]);
		 }
	 }
	 public JobInProgress getJob() {
		 return job;
	 }
	 public String getTIPId() {
		 return this.id;
	 }
	 public boolean isMapTask() {
		 return split != null;
	 }
	 public boolean isRunning() {
		 return !recentTasks.isEmpty();
	 }
	 public boolean isComplete() {
		 return (completes > 0);
	 }
	 public boolean isComplete(String taskid) {
		 TaskStatus status = (TaskStatus) taskStatuses.get(taskid);
		 if (status == null) {
			 return false;
		 }
		 return ((completes > 0) && (status.getRunState() == TaskStatus.State.SUCCEEDED));
	 }
	 public boolean isFailed() {
		 return failed;
	 }
	 public int numTaskFailures() {
		 return numTaskFailures;
	 }
	 public double getProgress() {
		 return progress;
	 }
	 public boolean shouldCloseForClosedJob(String taskid) {
		 TaskStatus ts = (TaskStatus) taskStatuses.get(taskid);
		 if ((ts != null) && (! tasksReportedClosed.contains(taskid)) && (job.getStatus().getRunState() != JobStatus.RUNNING)) {
			 tasksReportedClosed.add(taskid);
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 synchronized TaskReport generateSingleReport() {
		 ArrayList diagnostics = new ArrayList();
		 for (Iterator i = taskDiagnosticData.values().iterator();
		 i.hasNext();
		) {
			 diagnostics.addAll((List)i.next());
		 }
		 TaskReport report = new TaskReport (getTIPId(), (float)progress, state, (String[])diagnostics.toArray(new String[diagnostics.size()]), execStartTime, execFinishTime);
		 return report ;
	 }
	 synchronized List<String> getDiagnosticInfo(String taskId) {
		 return taskDiagnosticData.get(taskId);
	 }
	 synchronized boolean updateStatus(TaskStatus status) {
		 String taskid = status.getTaskId();
		 String diagInfo = status.getDiagnosticInfo();
		 TaskStatus oldStatus = (TaskStatus) taskStatuses.get(taskid);
		 boolean changed = true;
		 if (diagInfo != null && diagInfo.length() > 0) {
			 LOG.info(""Error from ""+taskid+"": ""+diagInfo);
			 List diagHistory = (List) taskDiagnosticData.get(taskid);
			 if (diagHistory == null) {
				 diagHistory = new ArrayList();
				 taskDiagnosticData.put(taskid, diagHistory);
			 }
			 diagHistory.add(diagInfo);
		 }
		 if (oldStatus != null) {
			 TaskStatus.State oldState = oldStatus.getRunState();
			 TaskStatus.State newState = status.getRunState();
			 if (newState == TaskStatus.State.RUNNING && (oldState == TaskStatus.State.FAILED || oldState == TaskStatus.State.KILLED || oldState == TaskStatus.State.SUCCEEDED)) {
				 return false;
			 }
			 changed = oldState != newState;
		 }
		 taskStatuses.put(taskid, status);
		 recomputeProgress();
		 return changed;
	 }
	 public void failedSubTask(String taskid, String trackerName) {
		 LOG.info(""Task '"" + taskid + ""' has been lost."");
		 TaskStatus status = (TaskStatus) taskStatuses.get(taskid);
		 if (status != null) {
			 status.setRunState(TaskStatus.State.FAILED);
			 if( 0 == status.getFinishTime() ){
				 status.setFinishTime(System.currentTimeMillis());
			 }
		 }
		 this.recentTasks.remove(taskid);
		 if (this.completes > 0) {
			 this.completes--;
		 }
		 numTaskFailures++;
		 if (numTaskFailures >= MAX_TASK_FAILURES) {
			 LOG.info(""TaskInProgress "" + getTIPId() + "" has failed "" + numTaskFailures + "" times."");
			 kill();
		 }
		 machinesWhereFailed.add(trackerName);
	 }
	 public void completed(String taskid) {
		 LOG.info(""Task '"" + taskid + ""' has completed."");
		 TaskStatus status = (TaskStatus) taskStatuses.get(taskid);
		 status.setRunState(TaskStatus.State.SUCCEEDED);
		 recentTasks.remove(taskid);
		 this.completes++;
		 recomputeProgress();
	 }
	 public TaskStatus[] getTaskStatuses() {
		return (TaskStatus[])taskStatuses.values().toArray(new TaskStatus[taskStatuses.size()]);
	 }
	 public void kill() {
		 if (isComplete() || failed) {
			 return;
		 }
		 this.failed = true;
		 killed = true;
		 recomputeProgress();
	 }
	 public boolean wasKilled() {
		 return killed;
	 }
	 void recomputeProgress() {
		 if (isComplete()) {
			 this.progress = 1;
			 this.execFinishTime = System.currentTimeMillis();
		 }
		 else if (failed) {
			 this.progress = 0;
			 this.execFinishTime = System.currentTimeMillis();
		 }
		 else {
			 double bestProgress = 0;
			 String bestState = """";
			 for (Iterator it = taskStatuses.keySet().iterator();
			 it.hasNext();
			 ) {
				 String taskid = (String) it.next();
				 TaskStatus status = (TaskStatus) taskStatuses.get(taskid);
				 if (status.getRunState() == TaskStatus.State.SUCCEEDED) {
					 bestProgress = 1;
					 bestState = status.getStateString();
					 break;
				 }
				 else if (status.getRunState() == TaskStatus.State.RUNNING) {
					 if (status.getProgress() >= bestProgress) {
						 bestProgress = status.getProgress();
						 bestState = status.getStateString();
					 }
				 }
			 }
			 this.progress = bestProgress;
			 this.state = bestState;
		 }
	 }
	 boolean isRunnable() {
		 return !failed && (completes == 0);
	 }
	 boolean hasSpeculativeTask(double averageProgress) {
		 if (isMapTask() && recentTasks.size() <= MAX_TASK_EXECS && runSpeculative && (averageProgress - progress >= SPECULATIVE_GAP) && (System.currentTimeMillis() - startTime >= SPECULATIVE_LAG)) {
			 return true;
		 }
		 return false;
	 }
	 public Task getTaskToRun(String taskTracker) {
		 Task t = null;
		 if( 0 == execStartTime ){
			 execStartTime = System.currentTimeMillis();
		 }
		 String taskid = (String) usableTaskIds.first();
		 usableTaskIds.remove(taskid);
		 String jobId = job.getProfile().getJobId();
		 if (isMapTask()) {
			 t = new MapTask(jobId, jobFile, taskid, partition, split);
		 }
		 else {
			 t = new ReduceTask(jobId, jobFile, taskid, partition, numMaps);
		 }
		 t.setConf(conf);
		 recentTasks.add(taskid);
		 jobtracker.createTaskEntry(taskid, taskTracker, this);
		 return t;
	 }
	 public boolean hasFailedOnMachine(String tracker) {
		 return machinesWhereFailed.contains(tracker);
	 }
	 public int getNumberOfFailedMachines() {
		 return machinesWhereFailed.size();
	 }
	 public int getIdWithinJob() {
		 return partition;
	 }
}",0,0,0,0
"public final class OptRuntime extends ScriptRuntime{
	 public static final Double zeroObj = new Double(0.0);
	 public static final Double oneObj = new Double(1.0);
	 public static final Double minusOneObj = new Double(-1.0);
	 public static Object call0(Callable fun, Scriptable thisObj, Context cx, Scriptable scope) {
		 return fun.call(cx, scope, thisObj, ScriptRuntime.emptyArgs);
	 }
	 public static Object call1(Callable fun, Scriptable thisObj, Object arg0, Context cx, Scriptable scope) {
		 return fun.call(cx, scope, thisObj, new Object[] {
		 arg0 }
		 );
	 }
	 public static Object call2(Callable fun, Scriptable thisObj, Object arg0, Object arg1, Context cx, Scriptable scope) {
		 return fun.call(cx, scope, thisObj, new Object[] {
		 arg0, arg1 }
		);
	 }
	 public static Object callN(Callable fun, Scriptable thisObj, Object[] args, Context cx, Scriptable scope) {
		 return fun.call(cx, scope, thisObj, args);
	 }
	 public static Object callName(Object[] args, String name, Context cx, Scriptable scope) {
		 Callable f = getNameFunctionAndThis(name, cx, scope);
		 Scriptable thisObj = lastStoredScriptable(cx);
		 return f.call(cx, scope, thisObj, args);
	 }
	 public static Object callName0(String name, Context cx, Scriptable scope) {
		 Callable f = getNameFunctionAndThis(name, cx, scope);
		 Scriptable thisObj = lastStoredScriptable(cx);
		 return f.call(cx, scope, thisObj, ScriptRuntime.emptyArgs);
	 }
	 public static Object callProp0(Object value, String property, Context cx, Scriptable scope) {
		 Callable f = getPropFunctionAndThis(value, property, cx);
		 Scriptable thisObj = lastStoredScriptable(cx);
		 return f.call(cx, scope, thisObj, ScriptRuntime.emptyArgs);
	 }
	 public static Object add(Object val1, double val2) {
		 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(null);
		 if (!(val1 instanceof String)) return wrapDouble(toNumber(val1) + val2);
		 return ((String)val1).concat(toString(val2));
	 }
	 public static Object add(double val1, Object val2) {
		 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(null);
		 if (!(val2 instanceof String)) return wrapDouble(toNumber(val2) + val1);
		 return toString(val1).concat((String)val2);
	 }
	 public static Object elemIncrDecr(Object obj, double index, Context cx, int incrDecrMask) {
		 return ScriptRuntime.elemIncrDecr(obj, new Double(index), cx, incrDecrMask);
	 }
	 public static Object[] padStart(Object[] currentArgs, int count) {
		 Object[] result = new Object[currentArgs.length + count];
		 System.arraycopy(currentArgs, 0, result, count, currentArgs.length);
		 return result;
	 }
	 public static void initFunction(NativeFunction fn, int functionType, Scriptable scope, Context cx) {
		 ScriptRuntime.initFunction(cx, scope, fn, functionType, false);
	 }
	 public static Object callSpecial(Context cx, Callable fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String fileName, int lineNumber) {
		 return ScriptRuntime.callSpecial(cx, fun, thisObj, args, scope, callerThis, callType, fileName, lineNumber);
	 }
	 public static Object newObjectSpecial(Context cx, Object fun, Object[] args, Scriptable scope, Scriptable callerThis, int callType) {
		 return ScriptRuntime.newSpecial(cx, fun, args, scope, callType);
	 }
	 public static Double wrapDouble(double num) {
		 if (num == 0.0) {
			 if (1 / num > 0) {
				 return zeroObj;
			 }
		 }
		 else if (num == 1.0) {
			 return oneObj;
		 }
		 else if (num == -1.0) {
			 return minusOneObj;
		 }
		 else if (num != num) {
			 return NaNobj;
		 }
		 return new Double(num);
	 }
	 static String encodeIntArray(int[] array) {
		 if (array == null) {
			 return null;
		 }
		 int n = array.length;
		 char[] buffer = new char[1 + n * 2];
		 buffer[0] = 1;
		 for (int i = 0;
		 i != n;
		 ++i) {
			 int value = array[i];
			 int shift = 1 + i * 2;
			 buffer[shift] = (char)(value >>> 16);
			 buffer[shift + 1] = (char)value;
		 }
		 return new String(buffer);
	 }
	 private static int[] decodeIntArray(String str, int arraySize) {
		 if (arraySize == 0) {
			 if (str != null) throw new IllegalArgumentException();
			 return null;
		 }
		 if (str.length() != 1 + arraySize * 2 && str.charAt(0) != 1) {
			 throw new IllegalArgumentException();
		 }
		 int[] array = new int[arraySize];
		 for (int i = 0;
		 i != arraySize;
		 ++i) {
			 int shift = 1 + i * 2;
			 array[i] = (str.charAt(shift) << 16) | str.charAt(shift + 1);
		 }
		 return array;
	 }
	 public static Scriptable newArrayLiteral(Object[] objects, String encodedInts, int skipCount, Context cx, Scriptable scope) {
		 int[] skipIndexces = decodeIntArray(encodedInts, skipCount);
		 return newArrayLiteral(objects, skipIndexces, cx, scope);
	 }
	 public static void main(final Script script, final String[] args) {
		 Context.call(new ContextAction() {
			 public Object run(Context cx) {
				 ScriptableObject global = getGlobal(cx);
				 Object[] argsCopy = new Object[args.length];
				 System.arraycopy(args, 0, argsCopy, 0, args.length);
				 Scriptable argsObj = cx.newArray(global, argsCopy);
				 global.defineProperty(""arguments"", argsObj, ScriptableObject.DONTENUM);
				 script.exec(cx, global);
				 return null;
			 }
		 }
		);
	 }
}",0,0,0,0
"public void evaluateExtraParams() {
	 super.evaluateExtraParams();
	 if (emptyOption != null) {
		 addParameter(""emptyOption"", findValue(emptyOption, Boolean.class));
	 }
	 if (multiple != null) {
		 addParameter(""multiple"", findValue(multiple, Boolean.class));
	 }
	 if (size != null) {
		 addParameter(""size"", findString(size));
	 }
	 if ((headerKey != null) && (headerValue != null)) {
		 addParameter(""headerKey"", findString(headerKey));
		 addParameter(""headerValue"", findString(headerValue));
	 }
	 if (doubleMultiple != null) {
		 addParameter(""doubleMultiple"", findValue(doubleMultiple, Boolean.class));
	 }
	 if (doubleSize != null) {
		 addParameter(""doubleSize"", findString(doubleSize));
	 }
	 if (doubleDisabled != null) {
		 addParameter(""doubleDisabled"", findValue(doubleDisabled, Boolean.class));
	 }
	 if (doubleName != null) {
		 addParameter(""doubleName"", findString(this.doubleName));
	 }
	 if (doubleList != null) {
		 addParameter(""doubleList"", doubleList);
	 }
	 Object tmpDoubleList = findValue(doubleList);
	 if (doubleListKey != null) {
		 addParameter(""doubleListKey"", doubleListKey);
	 }
	else if (tmpDoubleList instanceof Map) {
		 addParameter(""doubleListKey"", ""key"");
	 }
	 if (doubleListValue != null) {
		 if (altSyntax()) {
			 if (doubleListValue.startsWith(""%{
			"") && doubleListValue.endsWith(""}
			"")) {
				 doubleListValue = doubleListValue.substring(2, doubleListValue.length() - 1);
			 }
		 }
		 addParameter(""doubleListValue"", doubleListValue);
	 }
	else if (tmpDoubleList instanceof Map) {
		 addParameter(""doubleListValue"", ""value"");
	 }
	 if (formName != null) {
		 addParameter(""formName"", findString(formName));
	 }
	 else {
		 Component form = findAncestor(Form.class);
		 if (form != null) {
			 addParameter(""formName"", form.getParameters().get(""name""));
		 }
	 }
	 Class valueClazz = getValueClassType();
	 if (valueClazz != null) {
		 if (doubleValue != null) {
			 addParameter(""doubleNameValue"", findValue(doubleValue, valueClazz));
		 }
		 else if (doubleName != null) {
			 addParameter(""doubleNameValue"", findValue(doubleName.toString(), valueClazz));
		 }
	 }
	 else {
		 if (doubleValue != null) {
			 addParameter(""doubleNameValue"", findValue(doubleValue));
		 }
		 else if (doubleName != null) {
			 addParameter(""doubleNameValue"", findValue(doubleName.toString()));
		 }
	 }
	 Form form = (Form) findAncestor(Form.class);
	 if (doubleId != null) {
		 if (altSyntax()) {
			 addParameter(""doubleId"", findString(doubleId));
		 }
		 else {
			 addParameter(""doubleId"", doubleId);
		 }
	 }
	 else if (form != null) {
		 addParameter(""doubleId"", form.getParameters().get(""id"") + ""_"" +escape(this.doubleName));
	 }
	 if (doubleOnclick != null) {
		 addParameter(""doubleOnclick"", findString(doubleOnclick));
	 }
	 if (doubleOndblclick != null) {
		 addParameter(""doubleOndblclick"", findString(doubleOndblclick));
	 }
	 if (doubleOnmousedown != null) {
		 addParameter(""doubleOnmousedown"", findString(doubleOnmousedown));
	 }
	 if (doubleOnmouseup != null) {
		 addParameter(""doubleOnmouseup"", findString(doubleOnmouseup));
	 }
	 if (doubleOnmouseover != null) {
		 addParameter(""doubleOnmouseover"", findString(doubleOnmouseover));
	 }
	 if (doubleOnmousemove != null) {
		 addParameter(""doubleOnmousemove"", findString(doubleOnmousemove));
	 }
	 if (doubleOnmouseout != null) {
		 addParameter(""doubleOnmouseout"", findString(doubleOnmouseout));
	 }
	 if (doubleOnfocus != null) {
		 addParameter(""doubleOnfocus"", findString(doubleOnfocus));
	 }
	 if (doubleOnblur != null) {
		 addParameter(""doubleOnblur"", findString(doubleOnblur));
	 }
	 if (doubleOnkeypress != null) {
		 addParameter(""doubleOnkeypress"", findString(doubleOnkeypress));
	 }
	 if (doubleOnkeydown != null) {
		 addParameter(""doubleOnkeydown"", findString(doubleOnkeydown));
	 }
	 if (doubleOnselect != null) {
		 addParameter(""doubleOnselect"", findString(doubleOnselect));
	 }
	 if (doubleOnchange != null) {
		 addParameter(""doubleOnchange"", findString(doubleOnchange));
	 }
	 if (doubleCssClass != null) {
		 addParameter(""doubleCss"", findString(doubleCssClass));
	 }
	 if (doubleCssStyle != null) {
		 addParameter(""doubleStyle"", findString(doubleCssStyle));
	 }
	 if (doubleHeaderKey != null && doubleHeaderValue != null) {
		 addParameter(""doubleHeaderKey"", findString(doubleHeaderKey));
		 addParameter(""doubleHeaderValue"", findString(doubleHeaderValue));
	 }
	 if (doubleEmptyOption != null) {
		 addParameter(""doubleEmptyOption"", findValue(doubleEmptyOption, Boolean.class));
	 }
	 if (doubleAccesskey != null) {
		 addParameter(""doubleAccesskey"", findString(doubleAccesskey));
	 }
 }",0,0,1,0
"class BloomFilterSerializer implements ICompactSerializer2<BloomFilter>{
	 public void serialize(BloomFilter bf, DataOutput dos) throws IOException {
		 long[] bits = bf.bitset.getBits();
		 int bitLength = bits.length;
		 dos.writeInt(bf.getHashCount());
		 dos.writeInt(bitLength);
		 for (int i = 0;
		 i < bitLength;
		 i++) dos.writeLong(bits[i]);
	 }
	 public BloomFilter deserialize(DataInput dis) throws IOException {
		 int hashes = dis.readInt();
		 int bitLength = dis.readInt();
		 long[] bits = new long[bitLength];
		 for (int i = 0;
		 i < bitLength;
		 i++) bits[i] = dis.readLong();
		 OpenBitSet bs = new OpenBitSet(bits, bitLength);
		 return new BloomFilter(hashes, bs);
	 }
}",0,0,0,0
"public class ServerResource {
	 private Config config;
	 public ServerConfig.ServerVersion version() {
		 return ServerConfig.getServerVersion();
	 }
	 public String config() {
		 return config.root().render(ConfigRenderOptions.concise());
	 }
}",0,0,0,0
"public final class MessageTransfer extends Method {
	 public static final int TYPE = 1025;
	 private int _bodySize;
	 public final int getStructType() {
		 return TYPE;
	 }
	 public final int getSizeWidth() {
		 return 0;
	 }
	 public final int getPackWidth() {
		 return 2;
	 }
	 public final boolean hasPayload() {
		 return true;
	 }
	 public final byte getEncodedTrack() {
		 return Frame.L4;
	 }
	 public final boolean isConnectionControl() {
		 return false;
	 }
	 private short packing_flags = 0;
	 private String destination;
	 private MessageAcceptMode acceptMode;
	 private MessageAcquireMode acquireMode;
	 private Header header;
	 private QpidByteBuffer _body;
	 public MessageTransfer() {
	}
	 public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, java.nio.ByteBuffer body, Option ... options) {
		 this(destination, acceptMode, acquireMode, header, QpidByteBuffer.wrap(body), options);
	 }
	 public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, QpidByteBuffer body, Option ... _options) {
		 if(destination != null) {
			 setDestination(destination);
		 }
		 if(acceptMode != null) {
			 setAcceptMode(acceptMode);
		 }
		 if(acquireMode != null) {
			 setAcquireMode(acquireMode);
		 }
		 setHeader(header);
		 setBody(body);
		 for (int i=0;
		 i < _options.length;
		 i++) {
			 switch (_options[i]) {
				 case SYNC: this.setSync(true);
				 break;
				 case BATCH: this.setBatch(true);
				 break;
				 case UNRELIABLE: this.setUnreliable(true);
				 break;
				 case NONE: break;
				 default: throw new IllegalArgumentException(""invalid option: "" + _options[i]);
			 }
		 }
	 }
	 public <C> void dispatch(C context, MethodDelegate<C> delegate) {
		 delegate.messageTransfer(context, this);
	 }
	 public final boolean hasDestination() {
		 return (packing_flags & 256) != 0;
	 }
	 public final MessageTransfer clearDestination() {
		 packing_flags &= ~256;
		 this.destination = null;
		 setDirty(true);
		 return this;
	 }
	 public final String getDestination() {
		 return destination;
	 }
	 public final MessageTransfer setDestination(String value) {
		 this.destination = value;
		 packing_flags |= 256;
		 setDirty(true);
		 return this;
	 }
	 public final MessageTransfer destination(String value) {
		 return setDestination(value);
	 }
	 public final boolean hasAcceptMode() {
		 return (packing_flags & 512) != 0;
	 }
	 public final MessageTransfer clearAcceptMode() {
		 packing_flags &= ~512;
		 this.acceptMode = null;
		 setDirty(true);
		 return this;
	 }
	 public final MessageAcceptMode getAcceptMode() {
		 return acceptMode;
	 }
	 public final MessageTransfer setAcceptMode(MessageAcceptMode value) {
		 this.acceptMode = value;
		 packing_flags |= 512;
		 setDirty(true);
		 return this;
	 }
	 public final MessageTransfer acceptMode(MessageAcceptMode value) {
		 return setAcceptMode(value);
	 }
	 public final boolean hasAcquireMode() {
		 return (packing_flags & 1024) != 0;
	 }
	 public final MessageTransfer clearAcquireMode() {
		 packing_flags &= ~1024;
		 this.acquireMode = null;
		 setDirty(true);
		 return this;
	 }
	 public final MessageAcquireMode getAcquireMode() {
		 return acquireMode;
	 }
	 public final MessageTransfer setAcquireMode(MessageAcquireMode value) {
		 this.acquireMode = value;
		 packing_flags |= 1024;
		 setDirty(true);
		 return this;
	 }
	 public final MessageTransfer acquireMode(MessageAcquireMode value) {
		 return setAcquireMode(value);
	 }
	 public final Header getHeader() {
		 return this.header;
	 }
	 public final void setHeader(Header header) {
		 this.header = header;
	 }
	 public final MessageTransfer header(Header header) {
		 setHeader(header);
		 return this;
	 }
	 public final QpidByteBuffer getBody() {
		 return _body;
	 }
	 public final void setBody(QpidByteBuffer body) {
		 if (body == null) {
			 _bodySize = 0;
			 if (_body != null) {
				 _body.dispose();
			 }
			 _body = null;
		 }
		 else {
			 _body = body.duplicate();
			 _bodySize = _body.remaining();
		 }
	 }
	 public int getBodySize() {
		 return _bodySize;
	 }
	 public void write(Encoder enc) {
		 enc.writeUint16(packing_flags);
		 if ((packing_flags & 256) != 0) {
			 enc.writeStr8(this.destination);
		 }
		 if ((packing_flags & 512) != 0) {
			 enc.writeUint8(this.acceptMode.getValue());
		 }
		 if ((packing_flags & 1024) != 0) {
			 enc.writeUint8(this.acquireMode.getValue());
		 }
	 }
	 public void read(Decoder dec) {
		 packing_flags = (short) dec.readUint16();
		 if ((packing_flags & 256) != 0) {
			 this.destination = dec.readStr8();
		 }
		 if ((packing_flags & 512) != 0) {
			 this.acceptMode = MessageAcceptMode.get(dec.readUint8());
		 }
		 if ((packing_flags & 1024) != 0) {
			 this.acquireMode = MessageAcquireMode.get(dec.readUint8());
		 }
	 }
	 public Map<String,Object> getFields() {
		 Map<String,Object> result = new LinkedHashMap<String,Object>();
		 if ((packing_flags & 256) != 0) {
			 result.put(""destination"", getDestination());
		 }
		 if ((packing_flags & 512) != 0) {
			 result.put(""acceptMode"", getAcceptMode());
		 }
		 if ((packing_flags & 1024) != 0) {
			 result.put(""acquireMode"", getAcquireMode());
		 }
		 return result;
	 }
	 public void dispose() {
		 if (_body != null) {
			 _body.dispose();
			 _body = null;
		 }
	 }
}",1,1,0,0
"private static VersionTagHolder createVersionTagHolder() {
	 VersionTagHolder versionHolder = new VersionTagHolder();
	 versionHolder.setOperation(Operation.GET_FOR_REGISTER_INTEREST);
	 return versionHolder;
 }",0,0,0,0
"private String toString(Attribute_Code code, HashSet referedLines) {
	StringBuffer buf = new StringBuffer();
	Attribute_Code.Opcode op;
	Attribute_Code.Opcode[] ops = code.codes;
	byte[][] operands;
	int ti, def, low, high, jump_count, npairs;
	String soffset;
	Attribute_LocalVariableTable.LocalVariable[] lvts = null;
	for (int i = 0;
	 i < code.attributes_count;
	 i++) {
		if (code.attributes[i] instanceof Attribute_LocalVariableTable) {
			lvts = ((Attribute_LocalVariableTable) code.attributes[i]).local_variable_table;
			break;
		}
	}
	if (code.code_length != 0) {
		for (int t = 0;
		 t < ops.length;
		 t++) {
			op = ops[t];
			operands = op.operands;
			soffset = Integer.toString(op.offset);
			if (referedLines.contains(soffset) == true) {
				if (config.labelInSingleLine == true) {
					buf.append(config.labelPrefix + soffset + "" : "");
					buf.append(Constants.LINE_SEPARATER);
					buf.append(config.instructionPadding);
				}
				 else {
					buf.append(Util.padChar(config.labelPrefix + soffset, config.labelLength, ' ') + "" : "");
				}
			}
			 else {
				buf.append(config.instructionPadding);
			}
			buf.append(Constants.OPCODE_NAMES[0xFF & op.opcode] + "" "");
			switch (op.opcode) {
				case Constants.TABLESWITCH:def = Util.getNum(operands[1]) + op.offset;
				low = Util.getNum(operands[2]);
				high = Util.getNum(operands[3]);
				jump_count = high - low + 1;
				buf.append(""default="" + config.labelPrefix + def + "", low="" + low + "", high="" + high + "", jump_table:"");
				for (int i = 0;
				 i < jump_count;
				 i++) {
					buf.append(config.labelPrefix + (Util.getNum(operands[i + 4]) + op.offset) + "","");
				}
				buf.deleteCharAt(buf.length() - 1);
				break;
				case Constants.LOOKUPSWITCH: {
					def = Util.getNum(operands[1]) + op.offset;
					npairs = Util.getNum(operands[2]);
					buf.append(""default="" + config.labelPrefix + def + "", npairs="" + npairs + "", jump_table:"");
					if (npairs != 0) {
						for (int i = 0;
						 i < npairs;
						 i++) {
							buf.append(Util.getNum(operands[i * 2 + 3]));
							buf.append(""->"");
							buf.append(config.labelPrefix + (Util.getNum(operands[i * 2 + 4]) + op.offset) + "","");
						}
						buf.deleteCharAt(buf.length() - 1);
					}
				}
				break;
				case Constants.GOTO:case Constants.IFEQ:case Constants.IFGE:case Constants.IFGT:case Constants.IFLE:case Constants.IFLT:case Constants.JSR:case Constants.IFNE:case Constants.IFNONNULL:case Constants.IFNULL:case Constants.IF_ACMPEQ:case Constants.IF_ACMPNE:case Constants.IF_ICMPEQ:case Constants.IF_ICMPGE:case Constants.IF_ICMPGT:case Constants.IF_ICMPLE:case Constants.IF_ICMPLT:case Constants.IF_ICMPNE:case Constants.GOTO_W:case Constants.JSR_W:buf.append(config.labelPrefix + (Util.getSignedNum(operands[0]) + op.offset));
				break;
				case Constants.ALOAD:case Constants.ASTORE:case Constants.DLOAD:case Constants.DSTORE:case Constants.FLOAD:case Constants.FSTORE:case Constants.ILOAD:case Constants.ISTORE:case Constants.LLOAD:case Constants.LSTORE:case Constants.RET:ti = Util.getNum(operands[0]);
				 buf.append(getLocalVariableName(ti, op.offset, lvts) + ""("" + ti + "")"");
				break;
				case Constants.WIDE:break;
				case Constants.NEWARRAY:buf.append(Constants.TYPE_NAMES[Util.getNum(operands[0])]);
				break;
				case Constants.GETFIELD:case Constants.GETSTATIC:case Constants.PUTFIELD:case Constants.PUTSTATIC:case Constants.NEW:case Constants.CHECKCAST:case Constants.INSTANCEOF:case Constants.INVOKESPECIAL:case Constants.INVOKESTATIC:case Constants.INVOKEVIRTUAL:buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
				break;
				case Constants.INVOKEINTERFACE:buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
				buf.append("" "");
				buf.append(Util.getNum(operands[1]));
				break;
				case Constants.LDC_W:case Constants.LDC2_W:case Constants.LDC:buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
				break;
				case Constants.ANEWARRAY:buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
				break;
				case Constants.MULTIANEWARRAY:buf.append(toString(cpl.getConstant(Util.getNum(operands[0]))));
				buf.append(' ');
				buf.append(Util.getNum(operands[1]));
				break;
				case Constants.IINC:ti = Util.getNum(operands[0]);
				buf.append(getLocalVariableName(ti, op.offset, lvts) + ""("" + ti + "") "" + Util.getSignedNum(operands[1]));
				break;
				default:if (operands != null) {
					for (int i = 0;
					 i < operands.length;
					 i++) {
						buf.append(Util.getNum(operands[i]) + "" "");
					}
				}
			}
			if (config.showInfo == true) {
				buf.append("" buf.append(OpcodeHelper.getOpcodeInfo(op.opcode).operation);
			}
			buf.append(Constants.LINE_SEPARATER);
		}
	}
	for (int i = 0;
	 i < code.attributes_count;
	 i++) {
		if (code.attributes[i] instanceof Attribute_LocalVariableTable&& ((Attribute_LocalVariableTable) code.attributes[i]).local_variable_table_length != 0) {
			buf.append(Constants.LINE_SEPARATER);
			buf.append(toString((Attribute_LocalVariableTable) code.attributes[i], ops));
			break;
		}
	}
	if (code.exception_table_length != 0) {
		buf.append(Constants.LINE_SEPARATER);
		buf.append(Constants.LINE_SEPARATER);
		buf.append(""["" + Constants.ATTRIBUTE_NAME_EXCEPTION_TABLE + "":"");
		for (int i = 0;
		 i < code.exception_table_length;
		 i++) {
			buf.append(Constants.LINE_SEPARATER);
			buf.append(""start="" + config.labelPrefix + code.exception_table[i].start_pc);
			buf.append("" , "");
			buf.append(""end="" + config.labelPrefix + code.exception_table[i].end_pc);
			buf.append("" , "");
			buf.append(""handler="" + config.labelPrefix + code.exception_table[i].handler_pc);
			buf.append("" , "");
			if (code.exception_table[i].catch_type != 0) {
				buf.append(""catch_type="" + toString(cpl.getConstant(code.exception_table[i].catch_type)));
			}
			 else {
				buf.append(""catch_type=0"");
			}
		}
		buf.append(""]"");
	}
	if (config.showLineNumber == true) {
		for (int i = 0;
		 i < code.attributes_count;
		 i++) {
			if (code.attributes[i] instanceof Attribute_LineNumberTable&& ((Attribute_LineNumberTable) code.attributes[i]).line_number_table_length != 0) {
				buf.append(Constants.LINE_SEPARATER);
				buf.append(Constants.LINE_SEPARATER);
				buf.append(toString((Attribute_LineNumberTable) code.attributes[i]));
				break;
			}
		}
	}
	buf.append(Constants.LINE_SEPARATER);
	buf.append(Constants.LINE_SEPARATER);
	buf.append(""["" + Constants.ATTRIBUTE_NAME_MAX_STACK + "" : "" + code.max_stack + ""]"");
	buf.append(Constants.LINE_SEPARATER);
	buf.append(""["" + Constants.ATTRIBUTE_NAME_MAX_LOCAL + "" : "" + code.max_locals + ""]"");
	return buf.toString();
}",0,0,1,0
"public class FormDataValidator implements Validator{
	 public ValidationResult validate ( final Object target ) {
		 final SimpleValidationContext ctx = new SimpleValidationContext ();
		 for ( final Method m : target.getClass ().getMethods () ) {
			 final DataValidator dv = m.getAnnotation ( DataValidator.class );
			 if ( dv == null ) {
				 continue;
			 }
			 try {
				 m.invoke ( target, ctx );
			 }
			 catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) {
				 ctx.error ( null, new ExceptionError ( e ) );
			 }
		 }
		 return ctx.getResult ();
	 }
}",0,0,0,0
"public LocationInfo(Throwable t, String fqnOfCallingClass) {
	 if(t == null || fqnOfCallingClass == null)return;
	 if (getLineNumberMethod != null) {
		 try {
			 Object[] noArgs = null;
			 Object[] elements = (Object[]) getStackTraceMethod.invoke(t, noArgs);
			 String prevClass = NA;
			 for(int i = elements.length - 1;
			 i >= 0;
			 i--) {
				 String thisClass = (String) getClassNameMethod.invoke(elements[i], noArgs);
				 if(fqnOfCallingClass.equals(thisClass)) {
					 int caller = i + 1;
					 if (caller < elements.length) {
						 className = prevClass;
						 methodName = (String) getMethodNameMethod.invoke(elements[caller], noArgs);
						 fileName = (String) getFileNameMethod.invoke(elements[caller], noArgs);
						 if (fileName == null) {
							 fileName = NA;
						 }
						 int line = ((Integer) getLineNumberMethod.invoke(elements[caller], noArgs)).intValue();
						 if (line < 0) {
							 lineNumber = NA;
						 }
						 else {
							 lineNumber = String.valueOf(line);
						 }
						 StringBuffer buf = new StringBuffer();
						 buf.append(className);
						 buf.append(""."");
						 buf.append(methodName);
						 buf.append(""("");
						 buf.append(fileName);
						 buf.append("":"");
						 buf.append(lineNumber);
						 buf.append("")"");
						 this.fullInfo = buf.toString();
					 }
					 return;
				 }
				 prevClass = thisClass;
			 }
			 return;
		 }
		 catch(IllegalAccessException ex) {
			 LogLog.debug(""LocationInfo failed using JDK 1.4 methods"", ex);
		 }
		 catch(InvocationTargetException ex) {
			 if (ex.getTargetException() instanceof InterruptedException || ex.getTargetException() instanceof InterruptedIOException) {
				 Thread.currentThread().interrupt();
			 }
			 LogLog.debug(""LocationInfo failed using JDK 1.4 methods"", ex);
		 }
		 catch(RuntimeException ex) {
			 LogLog.debug(""LocationInfo failed using JDK 1.4 methods"", ex);
		 }
	 }
	 String s;
	 synchronized(sw) {
		t.printStackTrace(pw);
		s = sw.toString();
		sw.getBuffer().setLength(0);
	 }
	 int ibegin, iend;
	 ibegin = s.lastIndexOf(fqnOfCallingClass);
	 if(ibegin == -1)return;
	 if (ibegin + fqnOfCallingClass.length() < s.length() && s.charAt(ibegin + fqnOfCallingClass.length()) != '.') {
		 int i = s.lastIndexOf(fqnOfCallingClass + ""."");
		 if (i != -1) {
			 ibegin = i;
		 }
	 }
	 ibegin = s.indexOf(Layout.LINE_SEP, ibegin);
	 if(ibegin == -1)return;
	 ibegin+= Layout.LINE_SEP_LEN;
	 iend = s.indexOf(Layout.LINE_SEP, ibegin);
	 if(iend == -1)return;
	 if(!inVisualAge) {
		ibegin = s.lastIndexOf(""at "", iend);
		if(ibegin == -1) return;
		ibegin += 3;
	 }
	 this.fullInfo = s.substring(ibegin, iend);
 }",0,0,1,0
"public void drawDomainGridline(Graphics2D g2, CategoryPlot plot, Rectangle2D dataArea, double value);",0,0,0,0
"public class ProjectList extends DataType implements Cloneable{
	 protected ArrayList list = new ArrayList();
	 public void addProjectInfo(ProjectInfo pro) {
		 list.add(pro);
	 }
	 public ProjectInfo getProject(int index) {
		 assert(index>=0 && index<list.size());
		 return (ProjectInfo)list.get(index);
	 }
	 public int getCount() {
		 return list.size();
	 }
}",0,1,0,0
"static Class findProviderClass(String className, ClassLoader cl, boolean doFallback) throws ClassNotFoundException, ConfigurationError {
	 SecurityManager security = System.getSecurityManager();
	 try{
		 if (security != null){
			 final int lastDot = className.lastIndexOf('.');
			 String packageName = className;
			 if (lastDot != -1) packageName = className.substring(0, lastDot);
			 security.checkPackageAccess(packageName);
		 }
	 }
	catch(SecurityException e){
		 throw e;
	 }
	 Class providerClass;
	 if (cl == null) {
		 providerClass = Class.forName(className);
	 }
	 else {
		 try {
			 providerClass = cl.loadClass(className);
		 }
		 catch (ClassNotFoundException x) {
			 if (doFallback) {
				 ClassLoader current = ObjectFactory.class.getClassLoader();
				 if (current == null) {
					 providerClass = Class.forName(className);
				 }
				 else if (cl != current) {
					 cl = current;
					 providerClass = cl.loadClass(className);
				 }
				 else {
					 throw x;
				 }
			 }
			 else {
				 throw x;
			 }
		 }
	 }
	 return providerClass;
 }",0,0,1,0
"public class NERPhraseGeneralizer extends PhraseGeneralizer {
	public List<ParseTreeChunk> generalize(Object chunk1o, Object chunk2o) {
		ParseTreeChunk chunk1 = (ParseTreeChunk)chunk1o, chunk2 = (ParseTreeChunk)chunk2o;
		List<ParseTreeNode> results = new ArrayList<ParseTreeNode>();
		List<ParseTreeChunk> resultChunks = new ArrayList<ParseTreeChunk>();
		List<String> pos1 = chunk1.getPOSs();
		List<String> pos2 = chunk2.getPOSs();
		List<String> lem1 = chunk1.getLemmas();
		List<String> lem2 = chunk2.getLemmas();
		List<String> ner1 = new ArrayList<String>();
		List<String> ner2 = new ArrayList<String>();
		for (ParseTreeNode node: chunk1.getParseTreeNodes()) {
			if (node.getNe()!=null && !node.getNe().equals(""O""))ner1.add(node.getNe());
		}
		for (ParseTreeNode node: chunk2.getParseTreeNodes()) {
			if (node.getNe()!=null && !node.getNe().equals(""O""))ner2.add(node.getNe());
		}
		List<String> overlap = new ArrayList<String>(ner1);
		overlap.retainAll(ner2);
		overlap = new ArrayList<String>(new HashSet<String>(overlap));
		if (overlap == null || overlap.size() < 1)return null;
		List<Integer> occur1 = new ArrayList<Integer>(), occur2 = new ArrayList<Integer>();
		for (String word : overlap) {
			Integer i1 = ner1.indexOf(word);
			Integer i2 = ner2.indexOf(word);
			occur1.add(i1);
			occur2.add(i2);
		}
		if (chunk1.getMainPOS().startsWith(""VP"") && chunk2.getMainPOS().startsWith(""VP"")) {
			Integer i1 = null, i2 = null;
			for(int i=0;
			 i< pos1.size();
			 i++){
				if (pos1.get(i).startsWith(""VB"")){
					i1 = i;
					break;
				}
			}
			for(int i=0;
			 i< pos2.size();
			 i++){
				if (pos2.get(i).startsWith(""VB"")){
					i2 = i;
					break;
				}
			}
			occur1.add(i1);
			occur2.add(i2);
		}
		List<List<int[]>> overlapsPlaus = new ArrayList<List<int[]>>();
		List<int[]> accum = new ArrayList<int[]>();
		accum.add(new int[] {
		 occur1.get(0), occur2.get(0) }
		);
		for (int i = 1;
		 i < occur1.size();
		 i++) {
			if (occur1.get(i) > occur1.get(i - 1)&& occur2.get(i) > occur2.get(i - 1))accum.add(new int[] {
			 occur1.get(i), occur2.get(i) }
			);
			else {
				overlapsPlaus.add(accum);
				if (occur1!=null && occur2!=null && i<occur1.size() && i<occur2.size() ){
					accum = new ArrayList<int[]>();
					accum.add(new int[] {
					 occur1.get(i), occur2.get(i) }
					);
				}
			}
		}
		if (accum.size() > 0) {
			overlapsPlaus.add(accum);
		}
		for (List<int[]> occur : overlapsPlaus) {
			List<Integer> occr1 = new ArrayList<Integer>(), occr2 = new ArrayList<Integer>();
			for (int[] column : occur) {
				occr1.add(column[0]);
				occr2.add(column[1]);
			}
			int ov1 = 0, ov2 = 0;
			 List<String> commonPOS = new ArrayList<String>(), commonLemmas = new ArrayList<String>();
			int k1 = occr1.get(ov1) - 2, k2 = occr2.get(ov2) - 2;
			Boolean bReachedCommonWord = false;
			while (k1 < 0 || k2 < 0) {
				k1++;
				k2++;
			}
			int k1max = pos1.size() - 1, k2max = pos2.size() - 1;
			while (k1 <= k1max && k2 <= k2max) {
				String sim = null;
				List<String> sims = posManager.generalize(pos1.get(k1), pos2.get(k2));
				if (!sims.isEmpty())sim = sims.get(0);
				String lemmaMatch = null;
				List<String> lemmaMatchs = lemmaFormManager.generalize(lem1.get(k1),lem2.get(k2));
				if (!lemmaMatchs.isEmpty())lemmaMatch = lemmaMatchs.get(0);
				if ((sim != null)&& (lemmaMatch == null || (lemmaMatch != null && !lemmaMatch.equals(""fail"")))) {
					commonPOS.add(pos1.get(k1));
					List<ParseTreeNode> genRes = nodeGen.generalize(chunk1.getParseTreeNodes().get(k1), chunk2.getParseTreeNodes().get(k2));
					 if (genRes.size()==1)results.add(genRes.get(0));
					if (lemmaMatch != null) {
						commonLemmas.add(lemmaMatch);
						if (k1 == occr1.get(ov1) && k2 == occr2.get(ov2))bReachedCommonWord = true;
						 else {
							if (occr1.size() > ov1 + 1 && occr2.size() > ov2 + 1&& k1 == occr1.get(ov1 + 1) && k2 == occr2.get(ov2 + 1)) {
								ov1++;
								ov2++;
								bReachedCommonWord = true;
							}
						}
					}
					 else {
						commonLemmas.add(""*"");
					}
					 k1++;
					k2++;
				}
				 else if (!bReachedCommonWord) {
					k1++;
					k2++;
				}
				 else {
					ov1++;
					ov2++;
					if (ov1 > occr1.size() - 1 || ov2 > occr2.size() - 1)break;
					int kk1 = occr1.get(ov1) - 2, kk2 = occr2.get(ov2) - 2;
					int countMove = 0;
					while ((kk1 < k1 + 1 || kk2 < k2 + 1) && countMove < 2) {
						 kk1++;
						kk2++;
						countMove++;
					}
					k1 = kk1;
					k2 = kk2;
					if (k1 > k1max)k1 = k1max;
					if (k2 > k2max)k2 = k2max;
					bReachedCommonWord = false;
				}
			}
			ParseTreeChunk currResult = new ParseTreeChunk(results),currResultOld = new ParseTreeChunk(commonLemmas, commonPOS, 0, 0);
			resultChunks.add(currResult);
		}
		return resultChunks;
	}
}",0,0,0,0
"public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter{
	 private final Map<DecoratedKey, ColumnFamily> keys = new TreeMap<DecoratedKey, ColumnFamily>();
	 private final long bufferSize;
	 private long currentSize;
	 public SSTableSimpleUnsortedWriter(File directory, String keyspace, String columnFamily, AbstractType comparator, AbstractType subComparator, int bufferSizeInMB) throws IOException {
		 super(directory, new CFMetaData(keyspace, columnFamily, subComparator == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super, comparator, subComparator));
		 this.bufferSize = bufferSizeInMB * 1024 * 1024;
	 }
	 protected void writeRow(DecoratedKey key, ColumnFamily columnFamily) throws IOException {
		 ColumnFamily previous = keys.put(key, columnFamily);
		 currentSize += key.key.remaining() + columnFamily.serializedSize() * 1.2;
		 if (previous != null) columnFamily.addAll(previous);
		 if (currentSize > bufferSize) sync();
	 }
	 public void close() throws IOException {
		 sync();
	 }
	 private void sync() throws IOException {
		 if (keys.isEmpty()) return;
		 SSTableWriter writer = getWriter();
		 for (Map.Entry<DecoratedKey, ColumnFamily> entry : keys.entrySet()) {
			 writer.append(entry.getKey(), entry.getValue());
		 }
		 writer.closeAndOpenReader();
		 currentSize = 0;
		 keys.clear();
	 }
}",0,0,0,0
"public class Customer extends AbstractDocument {
	private String firstname, lastname;
	private EmailAddress emailAddress;
	private Set<Address> addresses = new HashSet<Address>();
	public Customer(String firstname, String lastname) {
		Assert.hasText(firstname);
		Assert.hasText(lastname);
		this.firstname = firstname;
		this.lastname = lastname;
	}
	protected Customer() {
	}
	public void add(Address address) {
		Assert.notNull(address);
		this.addresses.add(address);
	}
	public String getFirstname() {
		return firstname;
	}
	public String getLastname() {
		return lastname;
	}
	public void setLastname(String lastname) {
		this.lastname = lastname;
	}
	public EmailAddress getEmailAddress() {
		return emailAddress;
	}
	public void setEmailAddress(EmailAddress emailAddress) {
		this.emailAddress = emailAddress;
	}
	public Set<Address> getAddresses() {
		return Collections.unmodifiableSet(addresses);
	}
}",1,1,0,0
"public class ChannelTypeXmlResult {
	 private ChannelType channelType;
	 private ConfigDescription configDescription;
	 private boolean system;
	 public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription) {
		 this(channelType, configDescription, false);
	 }
	 public ChannelTypeXmlResult(ChannelType channelType, ConfigDescription configDescription, boolean system) {
		 this.channelType = channelType;
		 this.configDescription = configDescription;
		 this.system = system;
	 }
	 public ChannelType toChannelType() {
		 return this.channelType;
	 }
	 public ConfigDescription getConfigDescription() {
		 return this.configDescription;
	 }
	 public boolean isSystem() {
		 return system;
	 }
	 public String toString() {
		 return ""ChannelTypeXmlResult [channelType="" + channelType + "", configDescription="" + configDescription + ""]"";
	 }
}",0,1,0,0
"protected int getMaxSizePerSession(){
	return maxSizePerSession;
}",0,0,0,0
"public class CommitLog{
	 private static final int MAX_OUTSTANDING_REPLAY_COUNT = 1024;
	 static final Logger logger = LoggerFactory.getLogger(CommitLog.class);
	 public static final CommitLog instance = new CommitLog();
	 private final Deque<CommitLogSegment> segments = new ArrayDeque<CommitLogSegment>();
	 private final ICommitLogExecutorService executor;
	 private volatile int segmentSize = 128*1024*1024;
	 private CommitLog() {
		 try {
			 DatabaseDescriptor.createAllDirectories();
			 segmentSize = DatabaseDescriptor.getCommitLogSegmentSize();
		 }
		 catch (IOException e) {
			 throw new IOError(e);
		 }
		 segments.add(new CommitLogSegment());
		 executor = DatabaseDescriptor.getCommitLogSync() == Config.CommitLogSync.batch ? new BatchCommitLogExecutorService() : new PeriodicCommitLogExecutorService(this);
	 }
	 public void resetUnsafe() {
		 segments.clear();
		 segments.add(new CommitLogSegment());
	 }
	 private boolean manages(String name) {
		 for (CommitLogSegment segment : segments) {
			 if (segment.getPath().endsWith(name)) return true;
		 }
		 return false;
	 }
	 public static int recover() throws IOException {
		 String directory = DatabaseDescriptor.getCommitLogLocation();
		 File[] files = new File(directory).listFiles(new FilenameFilter() {
			 public boolean accept(File dir, String name) {
				 return CommitLogSegment.possibleCommitLogFile(name) && !instance.manages(name);
			 }
		 }
		);
		 if (files.length == 0) {
			 logger.info(""No commitlog files found;
			 skipping replay"");
			 return 0;
		 }
		 Arrays.sort(files, new FileUtils.FileComparator());
		 logger.info(""Replaying "" + StringUtils.join(files, "", ""));
		 int replayed = recover(files);
		 for (File f : files) {
			 if (!f.delete()) logger.error(""Unable to remove "" + f + "";
			 you should remove it manually or next restart will replay it again (harmless, but time-consuming)"");
		 }
		 logger.info(""Log replay complete, "" + replayed + "" replayed mutations"");
		 return replayed;
	 }
	 public static int recover(File[] clogs) throws IOException {
		 final Set<Table> tablesRecovered = new HashSet<Table>();
		 List<Future<?>> futures = new ArrayList<Future<?>>();
		 byte[] bytes = new byte[4096];
		 Map<Integer, AtomicInteger> invalidMutations = new HashMap<Integer, AtomicInteger>();
		 final AtomicInteger replayedCount = new AtomicInteger();
		 final Map<Integer, ReplayPosition> cfPositions = new HashMap<Integer, ReplayPosition>();
		 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
			 ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables());
			 cfPositions.put(cfs.metadata.cfId, rp);
		 }
		 final ReplayPosition globalPosition = Ordering.from(ReplayPosition.comparator).min(cfPositions.values());
		 for (final File file : clogs) {
			 final long segment = CommitLogSegment.idFromFilename(file.getName());
			 int bufferSize = (int) Math.min(Math.max(file.length(), 1), 32 * 1024 * 1024);
			 BufferedRandomAccessFile reader = new BufferedRandomAccessFile(new File(file.getAbsolutePath()), ""r"", bufferSize, true);
			 assert reader.length() <= Integer.MAX_VALUE;
			 try {
				 int replayPosition;
				 if (globalPosition.segment < segment) replayPosition = 0;
				 else if (globalPosition.segment == segment) replayPosition = globalPosition.position;
				 else replayPosition = (int) reader.length();
				 if (replayPosition < 0 || replayPosition >= reader.length()) {
					 logger.debug(""skipping replay of fully-flushed {
					}
					"", file);
					 continue;
				 }
				 reader.seek(replayPosition);
				 if (logger.isDebugEnabled()) logger.debug(""Replaying "" + file + "" starting at "" + reader.getFilePointer());
				 while (!reader.isEOF()) {
					 if (logger.isDebugEnabled()) logger.debug(""Reading mutation at "" + reader.getFilePointer());
					 long claimedCRC32;
					 Checksum checksum = new CRC32();
					 int serializedSize;
					 try {
						 serializedSize = reader.readInt();
						 if (serializedSize < 10) break;
						 long claimedSizeChecksum = reader.readLong();
						 checksum.update(serializedSize);
						 if (checksum.getValue() != claimedSizeChecksum) break;
						 if (serializedSize > bytes.length) bytes = new byte[(int) (1.2 * serializedSize)];
						 reader.readFully(bytes, 0, serializedSize);
						 claimedCRC32 = reader.readLong();
					 }
					 catch(EOFException eof) {
						 break;
					 }
					 checksum.update(bytes, 0, serializedSize);
					 if (claimedCRC32 != checksum.getValue()) {
						 continue;
					 }
					 ByteArrayInputStream bufIn = new ByteArrayInputStream(bytes, 0, serializedSize);
					 RowMutation rm = null;
					 try {
						 rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_, false);
					 }
					 catch (UnserializableColumnFamilyException ex) {
						 AtomicInteger i = invalidMutations.get(ex.cfId);
						 if (i == null) {
							 i = new AtomicInteger(1);
							 invalidMutations.put(ex.cfId, i);
						 }
						 else i.incrementAndGet();
						 continue;
					 }
					 if (logger.isDebugEnabled()) logger.debug(String.format(""replaying mutation for %s.%s: %s"", rm.getTable(), ByteBufferUtil.bytesToHex(rm.key()), ""{
					"" + StringUtils.join(rm.getColumnFamilies(), "", "") + ""}
					""));
					 final long entryLocation = reader.getFilePointer();
					 final RowMutation frm = rm;
					 Runnable runnable = new WrappedRunnable() {
						 public void runMayThrow() throws IOException {
							 if (DatabaseDescriptor.getKSMetaData(frm.getTable()) == null) return;
							 final Table table = Table.open(frm.getTable());
							 RowMutation newRm = new RowMutation(frm.getTable(), frm.key());
							 for (ColumnFamily columnFamily : frm.getColumnFamilies()) {
								 if (CFMetaData.getCF(columnFamily.id()) == null) continue;
								 ReplayPosition rp = cfPositions.get(columnFamily.id());
								 if (segment > rp.segment || (segment == rp.segment && entryLocation > rp.position)) {
									 newRm.add(columnFamily);
									 replayedCount.incrementAndGet();
								 }
							 }
							 if (!newRm.isEmpty()) {
								 Table.open(newRm.getTable()).apply(newRm, false);
								 tablesRecovered.add(table);
							 }
						 }
					 }
					;
					 futures.add(StageManager.getStage(Stage.MUTATION).submit(runnable));
					 if (futures.size() > MAX_OUTSTANDING_REPLAY_COUNT) {
						 FBUtilities.waitOnFutures(futures);
						 futures.clear();
					 }
				 }
			 }
			 finally {
				 FileUtils.closeQuietly(reader);
				 logger.info(""Finished reading "" + file);
			 }
		 }
		 for (Map.Entry<Integer, AtomicInteger> entry : invalidMutations.entrySet()) logger.info(String.format(""Skipped %d mutations from unknown (probably removed) CF with id %d"", entry.getValue().intValue(), entry.getKey()));
		 FBUtilities.waitOnFutures(futures);
		 logger.debug(""Finished waiting on mutations from recovery"");
		 futures.clear();
		 for (Table table : tablesRecovered) futures.addAll(table.flush());
		 FBUtilities.waitOnFutures(futures);
		 return replayedCount.get();
	 }
	 private CommitLogSegment currentSegment() {
		 return segments.getLast();
	 }
	 public ReplayPosition getContext() {
		 Callable<ReplayPosition> task = new Callable<ReplayPosition>() {
			 public ReplayPosition call() throws Exception {
				 return currentSegment().getContext();
			 }
		 }
		;
		 try {
			 return executor.submit(task).get();
		 }
		 catch (InterruptedException e) {
			 throw new RuntimeException(e);
		 }
		 catch (ExecutionException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public int segmentsCount() {
		 return segments.size();
	 }
	 public void add(RowMutation rowMutation) throws IOException {
		 executor.add(new LogRecordAdder(rowMutation));
	 }
	 public void discardCompletedSegments(final Integer cfId, final ReplayPosition context) throws IOException {
		 Callable task = new Callable() {
			 public Object call() throws IOException {
				 discardCompletedSegmentsInternal(context, cfId);
				 return null;
			 }
		 }
		;
		 try {
			 executor.submit(task).get();
		 }
		 catch (InterruptedException e) {
			 throw new RuntimeException(e);
		 }
		 catch (ExecutionException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 private void discardCompletedSegmentsInternal(ReplayPosition context, Integer id) throws IOException {
		 if (logger.isDebugEnabled()) logger.debug(""discard completed log segments for "" + context + "", column family "" + id + ""."");
		 Iterator<CommitLogSegment> iter = segments.iterator();
		 while (iter.hasNext()) {
			 CommitLogSegment segment = iter.next();
			 if (segment.id == context.segment) {
				 segment.turnOffIfNotWritten(id, context.position);
				 maybeDiscardSegment(segment, iter);
				 break;
			 }
			 segment.turnOff(id);
			 maybeDiscardSegment(segment, iter);
		 }
	 }
	 private void maybeDiscardSegment(CommitLogSegment segment, Iterator<CommitLogSegment> iter) {
		 if (segment.isSafeToDelete() && iter.hasNext()) {
			 logger.info(""Discarding obsolete commit log:"" + segment);
			 segment.close();
			 DeletionService.executeDelete(segment.getPath());
			 iter.remove();
		 }
		 else {
			 if (logger.isDebugEnabled()) logger.debug(""Not safe to delete commit log "" + segment + "";
			 dirty is "" + segment.dirtyString() + "";
			 hasNext: "" + iter.hasNext());
		 }
	 }
	 void sync() throws IOException {
		 currentSegment().sync();
	 }
	 class LogRecordAdder implements Callable, Runnable {
		 final RowMutation rowMutation;
		 LogRecordAdder(RowMutation rm) {
			 this.rowMutation = rm;
		 }
		 public void run() {
			 try {
				 currentSegment().write(rowMutation);
				 if (currentSegment().length() >= segmentSize) {
					 sync();
					 segments.add(new CommitLogSegment());
				 }
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
		 public Object call() throws Exception {
			 run();
			 return null;
		 }
	 }
	 public void shutdownBlocking() throws InterruptedException {
		 executor.shutdown();
		 executor.awaitTermination();
	 }
}",0,0,0,0
"protected final OutputStream getOutputStream() throws IOException {
	 if (AggregateTransformer.FRAMES.equals(caller.format)) {
		 return new ByteArrayOutputStream();
	 }
	 else {
		 return new BufferedOutputStream( new FileOutputStream(new File(caller.toDir, ""junit-noframes.html"")));
	 }
 }",0,0,0,0
"public OutputStream getOutput(String pathname, boolean append, short repl_count, int chunk_size) throws IOException;",0,0,0,0
"private static class CorrelateFactoryImpl implements CorrelateFactory {
	 public RelNode createCorrelate(RelNode left, RelNode right, CorrelationId correlationId, ImmutableBitSet requiredColumns, SemiJoinType joinType) {
		 return LogicalCorrelate.create(left, right, correlationId, requiredColumns, joinType);
	 }
 }",0,0,0,0
"public class RangeSliceReply{
	 public final List<Row> rows;
	 public RangeSliceReply(List<Row> rows) {
		 this.rows = rows;
	 }
	 public Message getReply(Message originalMessage) throws IOException {
		 int size = DBConstants.intSize;
		 for (Row row : rows) size += Row.serializer().serializedSize(row, originalMessage.getVersion());
		 DataOutputBuffer buffer = new DataOutputBuffer(size);
		 buffer.writeInt(rows.size());
		 for (Row row : rows) Row.serializer().serialize(row, buffer, originalMessage.getVersion());
		 assert buffer.getLength() == buffer.getData().length;
		 return originalMessage.getReply(FBUtilities.getBroadcastAddress(), buffer.getData(), originalMessage.getVersion());
	 }
	 public String toString() {
		 return ""RangeSliceReply{
		"" + ""rows="" + StringUtils.join(rows, "","") + '}
		';
	 }
	 public static RangeSliceReply read(byte[] body, int version) throws IOException {
		 FastByteArrayInputStream bufIn = new FastByteArrayInputStream(body);
		 DataInputStream dis = new DataInputStream(bufIn);
		 int rowCount = dis.readInt();
		 List<Row> rows = new ArrayList<Row>(rowCount);
		 for (int i = 0;
		 i < rowCount;
		 i++) {
			 rows.add(Row.serializer().deserialize(dis, version));
		 }
		 return new RangeSliceReply(rows);
	 }
}",0,0,0,0
"public class CachingFolderInfo extends net.suberic.pooka.UIDFolderInfo {
	 private MessageCache cache = null;
	 protected static String disconnectedMessage = ""error.CachingFolder.disconnected"";
	 boolean autoCache = false;
	 public CachingFolderInfo(StoreInfo parent, String fname) {
		 super(parent, fname);
		 if (! getCacheHeadersOnly()) {
			 autoCache = Pooka.getProperty(getFolderProperty() + "".autoCache"", Pooka.getProperty(getParentStore().getStoreProperty() + "".autoCache"", Pooka.getProperty(""Pooka.autoCache"", ""false""))).equalsIgnoreCase(""true"");
		 }
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".autoCache"");
	 }
	 public CachingFolderInfo(FolderInfo parent, String fname) {
		 super(parent, fname);
		 if (! getCacheHeadersOnly()) {
			 autoCache = Pooka.getProperty(getFolderProperty() + "".autoCache"", Pooka.getProperty(getParentStore().getStoreProperty() + "".autoCache"", Pooka.getProperty(""Pooka.autoCache"", ""false""))).equalsIgnoreCase(""true"");
		 }
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".autoCache"");
		 Pooka.getResources().addValueChangeListener(this, getFolderProperty() + "".cacheHeadersOnly"");
		 Pooka.getResources().addValueChangeListener(this, getParentStore().getStoreProperty() + "".autoCache"");
		 Pooka.getResources().addValueChangeListener(this, getParentStore().getStoreProperty() + "".cacheHeadersOnly"");
	 }
	 protected FetchProfile createColumnInformation() {
		 FetchProfile fp = super.createColumnInformation();
		 fp = new FetchProfile();
		 fp.add(FetchProfile.Item.FLAGS);
		 fp.add(com.sun.mail.imap.IMAPFolder.FetchProfileItem.HEADERS);
		 return fp;
	 }
	 public void loadFolder(boolean pConnectStore) throws OperationCancelledException {
		 if (cache == null) {
			 try {
				 this.cache = new SimpleFileCache(this, getCacheDirectory());
				 type = type | Folder.HOLDS_MESSAGES;
				 setStatus(DISCONNECTED);
			 }
			 catch (java.io.IOException ioe) {
				 System.out.println(""Error creating cache!"");
				 ioe.printStackTrace();
				 return;
			 }
		 }
		 if (isLoaded() || (loading && children == null)) return;
		 Folder[] tmpFolder = null;
		 Folder tmpParentFolder;
		 try {
			 loading = true;
			 if (getParentStore().isConnected()) {
				 if (getParentFolder() == null) {
					 try {
						 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": checking parent store connection."");
						 Store store = getParentStore().getStore();
						 try {
							 if (getLogger().isLoggable(Level.FINE)) {
								 getLogger().log(Level.FINE, ""checking to see if "" + getFolderID() + "" is a shared folder."");
							 }
							 Folder[] sharedFolders = store.getSharedNamespaces();
							 if (sharedFolders != null && sharedFolders.length > 0) {
								 for (int i = 0;
								 ( tmpFolder == null || tmpFolder.length == 0 ) && i < sharedFolders.length;
								 i++) {
									 if (sharedFolders[i].getName().equalsIgnoreCase(getFolderName())) {
										 if (!mNamespace) {
											 Pooka.setProperty(getFolderID() + ""._namespace"", ""true"");
											 mNamespace = true;
										 }
										 tmpFolder = new Folder[1];
										 tmpFolder[0] = sharedFolders[i] ;
									 }
								 }
							 }
						 }
						 catch (Exception e) {
						 }
						 if (tmpFolder == null || tmpFolder.length == 0) {
							 tmpParentFolder = store.getDefaultFolder();
							 if (getLogger().isLoggable(Level.FINE)) {
								 getLogger().log(Level.FINE, ""got "" + tmpParentFolder + "" as Default Folder for store."");
								 getLogger().log(Level.FINE, ""doing a list on default folder "" + tmpParentFolder + "" for folder "" + getFolderName());
							 }
							 tmpFolder = tmpParentFolder.list(getFolderName());
						 }
						 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""got "" + tmpFolder + "" as Folder for folder "" + getFolderID() + ""."");
					 }
					 catch (MessagingException me) {
						 me.printStackTrace();
						 if (getLogger().isLoggable(Level.FINE)) {
							 getLogger().log(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception from parentStore getting folder: "" + me);
							 me.printStackTrace();
						 }
						 tmpFolder =null;
					 }
				 }
				 else {
					 if (!getParentFolder().isLoaded()) getParentFolder().loadFolder();
					 if (!getParentFolder().isLoaded()) {
						 tmpFolder = null;
					 }
					 else {
						 tmpParentFolder = getParentFolder().getFolder();
						 if (tmpParentFolder != null) {
							 tmpFolder = tmpParentFolder.list(getFolderName());
						 }
						 else {
							 tmpFolder = null;
						 }
					 }
				 }
				 if (tmpFolder != null && tmpFolder.length > 0) {
					 setFolder(tmpFolder[0]);
					 if (! getFolder().isSubscribed()) getFolder().setSubscribed(true);
					 setStatus(CLOSED);
					 getFolder().addMessageChangedListener(this);
				 }
				 else {
					 if (cache != null) setStatus(CACHE_ONLY);
					 else setStatus(INVALID);
					 setFolder(new FolderProxy(getFolderName()));
				 }
			 }
			 else {
				 setFolder(new FolderProxy(getFolderName()));
			 }
		 }
		 catch (MessagingException me) {
			 if (getLogger().isLoggable(Level.FINE)) {
				 getLogger().log(Level.FINE, Thread.currentThread() + ""loading folder "" + getFolderID() + "": caught messaging exception;
				 setting loaded to false: "" + me.getMessage() );
				 me.printStackTrace();
			 }
			 setStatus(NOT_LOADED);
			 setFolder(new FolderProxy(getFolderName()));
		 }
		 finally {
			 initializeFolderInfo();
			 loading = false;
		 }
	 }
	 public void opened (ConnectionEvent e) {
		 super.opened(e);
		 rematchFilters();
	 }
	 public void openFolder(int mode, boolean pConnectStore) throws MessagingException, OperationCancelledException {
		 try {
			 getLogger().log(Level.FINE, this + "": checking parent store."");
			 if (!getParentStore().isConnected() && pConnectStore && getParentStore().getPreferredStatus() == FolderInfo.CONNECTED) {
				 getLogger().log(Level.FINE, this + "": parent store isn't connected. trying connection."");
				 try {
					 getParentStore().connectStore();
				 }
				 catch (OperationCancelledException oce) {
					 getLogger().log(Level.INFO, ""Login cancelled."");
				 }
			 }
			 getLogger().log(Level.FINE, this + "": loading folder."");
			 if (! isLoaded() && status != CACHE_ONLY) loadFolder();
			 getLogger().log(Level.FINE, this + "": folder loaded. status is "" + status + "";
			 checked on parent store. trying isLoaded() and isAvailable()."");
			 if (status == CLOSED || status == LOST_CONNECTION || status == DISCONNECTED) {
				 getLogger().log(Level.FINE, this + "": isLoaded() and isAvailable()."");
				 if (getFolder().isOpen()) {
					 if (getFolder().getMode() == mode) return;
					 else {
						 getFolder().close(false);
						 openFolder(mode);
					 }
				 }
				 else {
					 Folder f = getFolder();
					 getFolder().open(mode);
					 updateFolderOpenStatus(true);
					 resetMessageCounts();
				 }
			 }
			 else if (status == INVALID) {
				 throw new MessagingException(Pooka.getProperty(""error.folderInvalid"", ""Error: folder is invalid. "") + getFolderID());
			 }
		 }
		 catch (MessagingException me) {
			 setStatus(DISCONNECTED);
			 throw me;
		 }
		 finally {
			 resetMessageCounts();
		 }
	 }
	 public void disconnected(ConnectionEvent e) {
		 super.disconnected(e);
		 rematchFilters();
	 }
	 public void closed(ConnectionEvent e) {
		 super.closed(e);
		 rematchFilters();
	 }
	 protected void rematchFilters() {
		 if (folderTableModel != null) {
			 List allProxies = folderTableModel.getAllProxies();
			 for (int i = 0;
			 i < allProxies.size();
			 i++) {
				 ((MessageProxy) allProxies.get(i)).clearMatchedFilters();
			 }
			 mMessageLoader.loadMessages(allProxies);
		 }
	 }
	 protected void updateDisplay(boolean start) {
		 if (getFolderDisplayUI() != null) {
			 if (start) {
				 getFolderDisplayUI().setBusy(true);
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""messages.CachingFolder.loading.starting"", ""Loading messages.""));
			 }
			 else {
				 getFolderDisplayUI().setBusy(false);
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""messages.CachingFolder.loading.finished"", ""Done loading messages.""));
			 }
		 }
	 }
	 protected void updateFolderStatusForLoading() throws MessagingException, OperationCancelledException {
		 if (preferredStatus < DISCONNECTED && !(isConnected() && getParentStore().getConnection().getStatus() == NetworkConnection.CONNECTED )) {
			 try {
				 openFolder(Folder.READ_WRITE);
			 }
			 catch (MessagingException me) {
				 uidValidity = cache.getUIDValidity();
				 preferredStatus = DISCONNECTED;
			 }
		 }
	 }
	 protected List createInfosAndProxies() throws MessagingException {
		 List messageProxies = new Vector();
		 if (getStatus() > CONNECTED) {
			 uidValidity = cache.getUIDValidity();
		 }
		 if (isConnected()) {
			 try {
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.CachingFolder.synchronizing.writingChanges"", ""Writing local changes to server...""));
				 getCache().writeChangesToServer(getFolder());
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing.loading"", ""Loading messages from folder...""));
				 FetchProfile uidFetchProfile = new FetchProfile();
				 uidFetchProfile.add(UIDFolder.FetchProfileItem.UID);
				 getLogger().log(Level.FINE, ""getting messages."");
				 Message[] messages = getFolder().getMessages();
				 getLogger().log(Level.FINE, ""fetching messages."");
				 getFolder().fetch(messages, uidFetchProfile);
				 getLogger().log(Level.FINE, ""done fetching messages. getting uid's"");
				 long[] uids = new long[messages.length];
				 for (int i = 0;
				 i < messages.length;
				 i++) {
					 uids[i] = getUID(messages[i]);
				 }
				 MessageInfo mi;
				 for (int i = 0;
				 i < uids.length;
				 i++) {
					 Message m = new CachingMimeMessage(this, uids[i]);
					 mi = new MessageInfo(m, this);
					 messageProxies.add(new MessageProxy(getColumnValues() , mi));
					 messageToInfoTable.put(m, mi);
					 uidToInfoTable.put(new Long(uids[i]), mi);
				 }
				 return messageProxies;
			 }
			 catch (Exception e) {
				 final Exception fe = e;
				 javax.swing.SwingUtilities.invokeLater(new Runnable() {
					 public void run() {
						 if (getFolderDisplayUI() != null) {
							 getFolderDisplayUI().showError(Pooka.getProperty(""error.CachingFolder.synchronzing"", ""Error synchronizing with folder""), Pooka.getProperty(""error.CachingFolder.synchronzing.title"", ""Error synchronizing with folder""), fe);
						 }
						 else {
							 Pooka.getUIFactory().showError(Pooka.getProperty(""error.CachingFolder.synchronzing"", ""Error synchronizing with folder""), Pooka.getProperty(""error.CachingFolder.synchronzing.title"", ""Error synchronizing with folder""), fe);
						 }
					 }
				 }
				);
			 }
		 }
		 long[] uids = cache.getMessageUids();
		 MessageInfo mi;
		 for (int i = 0;
		 i < uids.length;
		 i++) {
			 Message m = new CachingMimeMessage(this, uids[i]);
			 mi = new MessageInfo(m, this);
			 MessageProxy mp = new MessageProxy(getColumnValues() , mi);
			 mp.setRefresh(true);
			 messageProxies.add(mp);
			 messageToInfoTable.put(m, mi);
			 uidToInfoTable.put(new Long(uids[i]), mi);
		 }
		 return messageProxies;
	 }
	 protected void updateCache() throws MessagingException {
		 if (isConnected()) {
			 synchronizeCache();
		 }
	 }
	 public void fetch(MessageInfo[] messages, FetchProfile profile) throws MessagingException {
		 if (getLogger().isLoggable(Level.FINE)) {
			 if (messages == null) getLogger().log(Level.FINE, ""cachingFolderInfo: fetching with null messages."");
			 else getLogger().log(Level.FINE, ""cachingFolderInfo: fetching "" + messages.length + "" messages."");
		 }
		 int cacheStatus = -1;
		 boolean doFlags = profile.contains(FetchProfile.Item.FLAGS);
		 String[] headers = profile.getHeaderNames();
		 boolean doHeaders = (profile.contains(FetchProfile.Item.ENVELOPE) || profile.contains(FetchProfile.Item.CONTENT_INFO) || profile.contains(com.sun.mail.imap.IMAPFolder.FetchProfileItem.HEADERS) || (headers != null && headers.length > 0));
		 if (doFlags && doHeaders) {
			 cacheStatus = SimpleFileCache.FLAGS_AND_HEADERS;
		 }
		 else if (doFlags) {
			 cacheStatus = SimpleFileCache.FLAGS;
		 }
		 else if (doHeaders) {
			 cacheStatus = SimpleFileCache.HEADERS;
		 }
		 if (isConnected()) {
			 if (getLogger().isLoggable(Level.FINE)) {
				 getLogger().log(Level.FINE, ""CachingFolderInfo: connected. checking for already-cached messages."");
			 }
			 if (doHeaders) {
				 FetchProfile fp = new FetchProfile();
				 if (doFlags) {
					 fp.add(FetchProfile.Item.FLAGS);
				 }
				 java.util.LinkedList flagsOnly = new java.util.LinkedList();
				 java.util.LinkedList headersAndFlags = new java.util.LinkedList();
				 for (int i = 0 ;
				 i < messages.length;
				 i++) {
					 Message current = messages[i].getMessage();
					 if (current != null && current instanceof UIDMimeMessage) {
						 long uid = ((UIDMimeMessage) current).getUID();
						 if (getCache().getCacheStatus(((UIDMimeMessage) current).getUID()) >= MessageCache.HEADERS) {
							 flagsOnly.add(messages[i]);
						 }
						 else {
							 headersAndFlags.add(messages[i]);
						 }
					 }
				 }
				 if (getLogger().isLoggable(Level.FINE)) {
					 getLogger().log(Level.FINE, ""CachingFolderInfo: running fetch against "" + headersAndFlags.size() + "" full messages, plus "" + flagsOnly.size() + "" flags-only messages"");
				 }
				 MessageInfo[] headersAndFlagsArray = (MessageInfo[]) headersAndFlags.toArray(new MessageInfo[0]);
				 MessageInfo[] flagsOnlyArray = (MessageInfo[]) flagsOnly.toArray(new MessageInfo[0]);
				 super.fetch(headersAndFlagsArray, profile);
				 super.fetch(flagsOnlyArray, fp);
				 if (cacheStatus != -1) {
					 for (int i = 0;
					 i < headersAndFlagsArray.length;
					 i++) {
						 Message m = headersAndFlagsArray[i].getRealMessage();
						 if (m != null) {
							 long uid = getUID(m);
							 getCache().cacheMessage((MimeMessage)m, uid, cache.getUIDValidity(), cacheStatus);
						 }
					 }
					 for (int i = 0;
					 i < flagsOnlyArray.length;
					 i++) {
						 Message m = flagsOnlyArray[i].getRealMessage();
						 if (m != null) {
							 long uid = getUID(m);
							 getCache().cacheMessage((MimeMessage)m, uid, cache.getUIDValidity(), MessageCache.FLAGS);
						 }
					 }
				 }
			 }
			 else {
				 if (getLogger().isLoggable(Level.FINE)) {
					 getLogger().log(Level.FINE, ""CachingFolderInfo: running fetch against folder."");
				 }
				 super.fetch(messages, profile);
				 if (cacheStatus != -1) {
					 for (int i = 0;
					 i < messages.length;
					 i++) {
						 Message m = messages[i].getRealMessage();
						 if (m != null) {
							 long uid = getUID(m);
							 getCache().cacheMessage((MimeMessage)m, uid, cache.getUIDValidity(), cacheStatus);
						 }
					 }
				 }
			 }
		 }
		 else {
			 for (int i = 0;
			 i < messages.length;
			 i++) {
				 Message current = messages[i].getMessage();
				 if (current != null && current instanceof UIDMimeMessage) {
					 long uid = ((UIDMimeMessage) current).getUID();
					 if (cacheStatus == SimpleFileCache.FLAGS_AND_HEADERS || cacheStatus == SimpleFileCache.FLAGS) {
						 getCache().getFlags(uid, cache.getUIDValidity());
					 }
					 if (cacheStatus == SimpleFileCache.FLAGS_AND_HEADERS || cacheStatus == SimpleFileCache.HEADERS) {
						 getCache().getHeaders(uid, cache.getUIDValidity());
					 }
				 }
				 messages[i].setFetched(true);
			 }
		 }
	 }
	 public void refreshHeaders(MessageInfo mi) throws MessagingException {
		 cacheMessage(mi, SimpleFileCache.HEADERS);
	 }
	 public void refreshFlags(MessageInfo mi) throws MessagingException {
		 if (isConnected()) cacheMessage(mi, SimpleFileCache.FLAGS);
	 }
	 public int getFirstUnreadMessage() {
		 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""getting first unread message"");
		 if (! tracksUnreadMessages()) return -1;
		 if (getFolderTableModel() == null) return -1;
		 if (isConnected()) {
			 return super.getFirstUnreadMessage();
		 }
		 else {
			 try {
				 int countUnread = 0;
				 int i;
				 int unreadCount = cache.getUnreadMessageCount();
				 if (unreadCount > 0) {
					 long[] uids = getCache().getMessageUids();
					 for (i = uids.length - 1;
					 ( i >= 0 && countUnread < unreadCount) ;
					 i--) {
						 MessageInfo mi = getMessageInfoByUid(uids[i]);
						 if (! mi.getFlags().contains(Flags.Flag.SEEN)) countUnread++;
					 }
					 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""Returning "" + i);
					 return i + 1;
				 }
				 else {
					 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""Returning -1"");
					 return -1;
				 }
			 }
			 catch (MessagingException me) {
				 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""Messaging Exception. Returning -1"");
				 return -1;
			 }
		 }
	 }
	 public boolean hasUnread() {
		 if (! tracksUnreadMessages()) return false;
		 else return (getUnreadCount() > 0);
	 }
	 public void resetMessageCounts() {
		 try {
			 if (getLogger().isLoggable(Level.FINE)) {
				 if (getFolder() != null) getLogger().log(Level.FINE, ""running resetMessageCounts. unread message count is "" + getFolder().getUnreadMessageCount());
				 else getLogger().log(Level.FINE, ""running resetMessageCounts. getFolder() is null."");
			 }
			 if (isConnected()) {
				 if (tracksUnreadMessages()) unreadCount = getFolder().getUnreadMessageCount();
				 messageCount = getFolder().getMessageCount();
			 }
			 else if (getCache() != null) {
				 messageCount = getCache().getMessageCount();
				 if (tracksUnreadMessages()) unreadCount = getCache().getUnreadMessageCount();
			 }
			 else {
			 }
		 }
		 catch (MessagingException me) {
			 unreadCount = 0;
		 }
		 updateNode();
	 }
	 public void synchronizeCache() throws MessagingException {
		 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""synchronizing cache."");
		 try {
			 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing"", ""Re-synchronizing with folder...""));
			 if (getFolderDisplayUI() != null) {
				 getFolderDisplayUI().setBusy(true);
			 }
			 long cacheUidValidity = getCache().getUIDValidity();
			 if (uidValidity != cacheUidValidity) {
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""error.UIDFolder.validityMismatch"", ""Error: validity not correct. reloading...""));
				 getCache().invalidateCache();
				 getCache().setUIDValidity(uidValidity);
				 cacheUidValidity = uidValidity;
			 }
			 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.CachingFolder.synchronizing.writingChanges"", ""Writing local changes to server...""));
			 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronzing.writingChanges"", ""Writing local changes to server""));
			 getCache().writeChangesToServer(getFolder());
			 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing.loading"", ""Loading messages from folder...""));
			 FetchProfile fp = new FetchProfile();
			 fp.add(UIDFolder.FetchProfileItem.UID);
			 fp.add(FetchProfile.Item.FLAGS);
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""getting messages."");
			 Message[] messages = getFolder().getMessages();
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""fetching messages."");
			 String messageCount = messages == null ? ""null"" : Integer.toString(messages.length);
			 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing.fetchingMessages"", ""Fetching"") + "" "" + messageCount + "" "" + Pooka.getProperty(""message.UIDFolder.synchronizing.messages"", ""messages.""));
			 getFolder().fetch(messages, fp);
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""done fetching messages. getting uid's"");
			 long[] uids = new long[messages.length];
			 for (int i = 0;
			 i < messages.length;
			 i++) {
				 uids[i] = getUID(messages[i]);
			 }
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""synchronizing--uids.length = "" + uids.length);
			 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing"", ""Comparing new messages to current list...""));
			 long[] addedUids = cache.getAddedMessages(uids, uidValidity);
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""synchronizing--addedUids.length = "" + addedUids.length);
			 if (addedUids.length > 0) {
				 Message[] addedMsgs = ((UIDFolder)getFolder()).getMessagesByUID(addedUids);
				 MessageCountEvent mce = new MessageCountEvent(getFolder(), MessageCountEvent.ADDED, false, addedMsgs);
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing.loadingMessages"", ""Loading"") + "" "" + addedUids.length + "" "" + Pooka.getProperty(""message.UIDFolder.synchronizing.messages"", ""messages.""));
				 messagesAdded(mce);
			 }
			 long[] removedUids = cache.getRemovedMessages(uids, uidValidity);
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""synchronizing--removedUids.length = "" + removedUids.length);
			 if (removedUids.length > 0) {
				 Message[] removedMsgs = new Message[removedUids.length];
				 for (int i = 0 ;
				 i < removedUids.length;
				 i++) {
					 MessageInfo mi = getMessageInfoByUid(removedUids[i]);
					 if (mi != null) removedMsgs[i] = mi.getMessage();
					 if (removedMsgs[i] == null) {
						 removedMsgs[i] = new CachingMimeMessage(this, removedUids[i]);
					 }
				 }
				 MessageCountEvent mce = new MessageCountEvent(getFolder(), MessageCountEvent.REMOVED, false, removedMsgs);
				 showStatusMessage(getFolderDisplayUI(), Pooka.getProperty(""message.UIDFolder.synchronizing.removingMessages"", ""Removing"") + "" "" + removedUids.length + "" "" + Pooka.getProperty(""message.UIDFolder.synchronizing.messages"", ""messages.""));
				 messagesRemoved(mce);
			 }
			 updateFlags(uids, messages, cacheUidValidity);
		 }
		 finally {
			 if (getFolderDisplayUI() != null) {
				 getFolderDisplayUI().clearStatusMessage();
				 getFolderDisplayUI().setBusy(false);
			 }
			 else Pooka.getUIFactory().clearStatus();
		 }
	 }
	 protected void runMessagesAdded(MessageCountEvent mce) {
		 if (folderTableModel != null) {
			 Message[] addedMessages = mce.getMessages();
			 int fetchBatchSize = 25;
			 int loadBatchSize = 25;
			 try {
				 fetchBatchSize = Integer.parseInt(Pooka.getProperty(""Pooka.fetchBatchSize"", ""50""));
			 }
			 catch (NumberFormatException nfe) {
			 }
			 MessageInfo mi;
			 Vector addedProxies = new Vector();
			 List addedInfos = new java.util.ArrayList();
			 for (int i = 0;
			 i < addedMessages.length;
			 i++) {
				 if (addedMessages[i] instanceof CachingMimeMessage) {
					 long uid = ((CachingMimeMessage) addedMessages[i]).getUID();
					 mi = getMessageInfoByUid(uid);
					 if (mi != null) {
						 addedInfos.add(mi);
						 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, getFolderID() + "": this is a duplicate. not making a new messageinfo for it."");
					 }
					 else {
						 mi = new MessageInfo(addedMessages[i], CachingFolderInfo.this);
						 addedInfos.add(mi);
						 addedProxies.add(new MessageProxy(getColumnValues(), mi));
						 messageToInfoTable.put(addedMessages[i], mi);
						 uidToInfoTable.put(new Long(((CachingMimeMessage) addedMessages[i]).getUID()), mi);
					 }
				 }
				 else {
					 long uid = -1;
					 try {
						 uid = getUID(addedMessages[i]);
					 }
					 catch (MessagingException me) {
					 }
					 mi = getMessageInfoByUid(uid);
					 if (mi != null) {
						 addedInfos.add(mi);
						 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, getFolderID() + "": this is a duplicate. not making a new messageinfo for it."");
						 if (autoCache) {
							 mMessageLoader.cacheMessages(new MessageProxy[] {
							 getMessageInfoByUid(uid).getMessageProxy()}
							);
						 }
					 }
					 else {
						 CachingMimeMessage newMsg = new CachingMimeMessage(CachingFolderInfo.this, uid);
						 mi = new MessageInfo(newMsg, CachingFolderInfo.this);
						 addedInfos.add(mi);
						 addedProxies.add(new MessageProxy(getColumnValues(), mi));
						 messageToInfoTable.put(newMsg, mi);
						 uidToInfoTable.put(new Long(uid), mi);
					 }
				 }
			 }
			 try {
				 List preloadMessages = addedInfos;
				 if (addedInfos.size() > fetchBatchSize) {
					 preloadMessages = addedInfos.subList(0, fetchBatchSize);
				 }
				 MessageInfo[] preloadArray = new MessageInfo[preloadMessages.size()];
				 for (int i = 0;
				 i < preloadMessages.size();
				 i++) {
					 preloadArray[i] = (MessageInfo) preloadMessages.get(i);
				 }
				 fetch(preloadArray, fetchProfile);
			 }
			 catch (MessagingException me) {
				 getLogger().warning(""error prefetching messages: "" + me.toString());
			 }
			 getCache().writeMsgFile();
			 clearStatusMessage(getFolderDisplayUI());
			 addedProxies.removeAll(applyFilters(addedProxies));
			 if (addedProxies.size() > 0) {
				 if (getFolderTableModel() != null) getFolderTableModel().addRows(addedProxies);
				 setNewMessages(true);
				 resetMessageCounts();
				 MessageProxy[] addedArray = (MessageProxy[]) addedProxies.toArray(new MessageProxy[0]);
				 mMessageLoader.loadMessages(addedArray, net.suberic.pooka.thread.MessageLoader.HIGH);
				 if (autoCache) {
					 mMessageLoader.cacheMessages(addedArray);
				 }
				 Message[] newMsgs = new Message[addedProxies.size()];
				 for (int i = 0;
				 i < addedProxies.size();
				 i++) {
					 newMsgs[i] = ((MessageProxy)addedProxies.elementAt(i)).getMessageInfo().getMessage();
				 }
				 MessageCountEvent newMce = new MessageCountEvent(getFolder(), mce.getType(), mce.isRemoved(), newMsgs);
				 fireMessageCountEvent(newMce);
			 }
		 }
	 }
	 protected void runMessagesRemoved(MessageCountEvent mce) {
		 Message[] removedMessages = mce.getMessages();
		 Message[] removedCachingMessages = new Message[removedMessages.length];
		 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""removedMessages was of size "" + removedMessages.length);
		 MessageInfo mi;
		 Vector removedProxies=new Vector();
		 for (int i = 0;
		 i < removedMessages.length;
		 i++) {
			 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""checking for existence of message."");
			 if (removedMessages[i] != null && removedMessages[i] instanceof CachingMimeMessage) {
				 removedCachingMessages[i] = removedMessages[i];
				 long uid = ((CachingMimeMessage) removedMessages[i]).getUID();
				 mi = getMessageInfoByUid(uid);
				 if (mi != null) {
					 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""message exists--removing"");
					 if ( mi.getMessageProxy() != null) {
						 mi.getMessageProxy().close();
						 removedProxies.add(mi.getMessageProxy());
					 }
					 messageToInfoTable.remove(mi);
					 uidToInfoTable.remove(new Long(((CachingMimeMessage) removedMessages[i]).getUID()));
				 }
				 getCache().invalidateCache(((CachingMimeMessage) removedMessages[i]).getUID(), SimpleFileCache.MESSAGE);
			 }
			 else {
				 long uid = -1;
				 try {
					 uid = getUID(removedMessages[i]);
				 }
				 catch (MessagingException me) {
				 }
				 mi = getMessageInfoByUid(uid);
				 if (mi != null) {
					 removedCachingMessages[i] = mi.getMessage();
					 if (mi.getMessageProxy() != null) mi.getMessageProxy().close();
					 if (getLogger().isLoggable(Level.FINE)) getLogger().log(Level.FINE, ""message exists--removing"");
					 Message localMsg = mi.getMessage();
					 removedProxies.add(mi.getMessageProxy());
					 messageToInfoTable.remove(localMsg);
					 uidToInfoTable.remove(new Long(uid));
				 }
				 else {
					 removedCachingMessages[i] = removedMessages[i];
				 }
				 getCache().invalidateCache(uid, SimpleFileCache.MESSAGE);
			 }
		 }
		 MessageCountEvent newMce = new MessageCountEvent(getFolder(), mce.getType(), mce.isRemoved(), removedCachingMessages);
		 if (getFolderDisplayUI() != null) {
			 if (removedProxies.size() > 0) {
				 getFolderDisplayUI().removeRows(removedProxies);
			 }
			 resetMessageCounts();
			 fireMessageCountEvent(newMce);
		 }
		 else {
			 resetMessageCounts();
			 fireMessageCountEvent(newMce);
			 if (removedProxies.size() > 0) getFolderTableModel().removeRows(removedProxies);
		 }
	 }
	 public void runMessageChanged(MessageChangedEvent mce) {
		 boolean updateInfo = false;
		 try {
			 updateInfo = (!mce.getMessage().isSet(Flags.Flag.DELETED) || ! Pooka.getProperty(""Pooka.autoExpunge"", ""true"").equalsIgnoreCase(""true""));
		 }
		 catch (MessagingException me) {
		 }
		 if (updateInfo) {
			 try {
				 Message msg = mce.getMessage();
				 long uid = -1;
				 uid = getUID(msg);
				 if (msg != null){
					 if (mce.getMessageChangeType() == MessageChangedEvent.FLAGS_CHANGED) getCache().cacheMessage((MimeMessage)msg, uid, uidValidity, SimpleFileCache.FLAGS);
					 else if (mce.getMessageChangeType() == MessageChangedEvent.ENVELOPE_CHANGED) getCache().cacheMessage((MimeMessage)msg, uid, uidValidity, SimpleFileCache.HEADERS);
				 }
				 MessageInfo mi = getMessageInfoByUid(uid);
				 if (mi != null) {
					 MessageProxy mp = mi.getMessageProxy();
					 if (mp != null) {
						 mp.unloadTableInfo();
						 mp.loadTableInfo();
					 }
				 }
			 }
			 catch (MessagingException me) {
			 }
			 if (! (mce instanceof net.suberic.pooka.event.MessageTableInfoChangedEvent)) {
				 resetMessageCounts();
			 }
		 }
		 fireMessageChangedEvent(mce);
	 }
	 public void setFlags(MessageInfo[] msgs, Flags flag, boolean value) throws MessagingException {
		 for (int i = 0;
		 i < msgs.length;
		 i++) {
			 msgs[i].getRealMessage().setFlags(flag, value);
		 }
	 }
	 public void copyMessages(MessageInfo[] msgs, FolderInfo targetFolder) throws MessagingException, OperationCancelledException {
		 if (isConnected()) super.copyMessages(msgs, targetFolder);
		 else targetFolder.appendMessages(msgs);
	 }
	 public void appendMessages(MessageInfo[] msgs) throws MessagingException, OperationCancelledException {
		 if (isAvailable()) {
			 if (isConnected()) {
				 super.appendMessages(msgs);
			 }
			 else {
				 if (! isLoaded()) loadFolder();
				 getCache().appendMessages(msgs);
			 }
		 }
		 else {
			 throw new MessagingException(""cannot append messages to an unavailable folder."");
		 }
	 }
	 public void expunge() throws MessagingException, OperationCancelledException {
		 if (isConnected()) getFolder().expunge();
		 else if (shouldBeConnected()) {
			 openFolder(Folder.READ_WRITE);
			 getFolder().expunge();
		 }
		 else {
			 getCache().expungeMessages();
		 }
	 }
	 public void cacheMessage (MessageInfo info, int cacheStatus) throws MessagingException {
		 if (status == CONNECTED) {
			 Message m = info.getMessage();
			 if (m instanceof CachingMimeMessage) {
				 long uid = ((CachingMimeMessage)m).getUID();
				 MimeMessage realMessage = getRealMessageById(uid);
				 getCache().cacheMessage(realMessage, uid, uidValidity, cacheStatus);
			 }
			 else if (m instanceof MimeMessage) {
				 long uid = getUID(m);
				 getCache().cacheMessage((MimeMessage)m, uid, uidValidity, cacheStatus);
			 }
			 else {
				 throw new MessagingException(Pooka.getProperty(""error.CachingFolderInfo.unknownMessageType"", ""Error: unknownMessageType.""));
			 }
		 }
		 else {
			 throw new MessagingException(Pooka.getProperty(""error.CachingFolderInfo.cacheWhileDisconnected"", ""Error: You cannot cache messages unless you\nare connected to the folder.""));
		 }
	 }
	 protected FolderInfo createChildFolder(String newFolderName) {
		 if (! Pooka.getProperty(getFolderProperty() + ""."" + newFolderName + "".cacheMessages"", ""true"").equalsIgnoreCase(""false"")) {
			 return new CachingFolderInfo(this, newFolderName);
		 }
		 else if (Pooka.getProperty(getParentStore().getStoreProperty() + "".protocol"", ""mbox"").equalsIgnoreCase(""imap"")) {
			 return new UIDFolderInfo(this, newFolderName);
		 }
		 else {
			 return new FolderInfo(this, newFolderName);
		 }
	 }
	 public void closeFolder(boolean expunge) throws MessagingException {
		 closeFolder(expunge, false);
	 }
	 public void closeFolder(boolean expunge, boolean closeDisplay) throws MessagingException {
		 if (closeDisplay && getFolderDisplayUI() != null) getFolderDisplayUI().closeFolderDisplay();
		 if (isLoaded() && isAvailable()) {
			 if (isConnected()) {
				 try {
					 getFolder().close(expunge);
				 }
				 catch (java.lang.IllegalStateException ise) {
					 throw new MessagingException(ise.getMessage(), ise);
				 }
			 }
			 if (getCache() != null) {
				 setStatus(DISCONNECTED);
			 }
			 else {
				 setStatus(CLOSED);
			 }
		 }
	 }
	 public void unsubscribe() {
		 super.unsubscribe();
		 getCache().invalidateCache();
	 }
	 public MessageInfo[] search(javax.mail.search.SearchTerm term) throws MessagingException, OperationCancelledException {
		 if (isConnected()) {
			 return super.search(term);
		 }
		 else {
			 return getCache().search(term);
		 }
	 }
	 protected String getDefaultDisplayFiltersResource() {
		 if (getCacheHeadersOnly()) {
			 return super.getDefaultDisplayFiltersResource();
		 }
		 else if (isSentFolder()) return ""CachingFolderInfo.sentFolderDefaultDisplayFilters"";
		 else return ""CachingFolderInfo.defaultDisplayFilters"";
	 }
	 public boolean isCached(long uid) {
		 return getCache().isFullyCached(uid);
	 }
	 public MessageCache getCache() {
		 return cache;
	 }
	 public boolean showCacheInfo() {
		 if (Pooka.getProperty(getFolderProperty() + "".showCacheInfo"", ""false"").equalsIgnoreCase(""true"")) return true;
		 else {
			 if (getStatus() == CONNECTED) {
				 return false;
			 }
			 else return true;
		 }
	 }
	 public String getCacheDirectory() {
		 String localDir = Pooka.getResourceManager().translateName(Pooka.getProperty(getFolderProperty() + "".cacheDir"", """"));
		 if (!localDir.equals("""")) return localDir;
		 localDir = Pooka.getProperty(""Pooka.defaultMailSubDir"", """");
		 if (localDir.equals("""")) localDir = Pooka.getPookaManager().getPookaRoot().getAbsolutePath() + File.separator + "".pooka"";
		 localDir = Pooka.getResourceManager().translateName(localDir);
		 localDir = localDir + File.separatorChar + ""cache"";
		 FolderInfo currentFolder = this;
		 StringBuffer subDir = new StringBuffer();
		 subDir.insert(0, currentFolder.getFolderName());
		 subDir.insert(0, File.separatorChar);
		 while (currentFolder.getParentFolder() != null) {
			 currentFolder = currentFolder.getParentFolder();
			 subDir.insert(0, currentFolder.getFolderName());
			 subDir.insert(0, File.separatorChar);
		 }
		 subDir.insert(0, currentFolder.getParentStore().getStoreID());
		 subDir.insert(0, File.separatorChar);
		 return localDir + subDir.toString();
	 }
	 public boolean isLoaded() {
		 return (getFolder() != null && ( ! (getFolder() instanceof FolderProxy)) && cache != null);
	 }
	 public long getUID(Message m) throws MessagingException {
		 if (m instanceof SimpleFileCache.LocalMimeMessage) {
			 return ((SimpleFileCache.LocalMimeMessage) m).getUID();
		 }
		 else {
			 return super.getUID(m);
		 }
	 }
	 public void showStatusMessage(net.suberic.pooka.gui.FolderDisplayUI pUI, String message) {
		 if (pUI != null) pUI.showStatusMessage(message);
		 else Pooka.getUIFactory().showStatusMessage(message);
	 }
	 public void valueChanged(String changedValue) {
		 if (changedValue.equals(getFolderProperty() + "".autoCache"") || changedValue.equals(getParentStore().getStoreProperty() + "".autoCache"")) {
			 if (! getCacheHeadersOnly()) {
				 autoCache = Pooka.getProperty(getFolderProperty() + "".autoCache"", Pooka.getProperty(getFolderProperty() + "".autoCache"", Pooka.getProperty(getParentStore().getStoreProperty() + "".autoCache"", Pooka.getProperty(""Pooka.autoCache"", ""false"")))).equalsIgnoreCase(""true"");
			 }
		 }
		 else if (changedValue.equals(getFolderProperty() + "".cacheHeadersOnly"") || changedValue.equals(getParentStore().getStoreProperty() + "".cacheHeadersOnly"")) {
			 if (! getCacheHeadersOnly()) {
				 autoCache = Pooka.getProperty(getFolderProperty() + "".autoCache"", Pooka.getProperty(getParentStore().getStoreProperty() + "".autoCache"", Pooka.getProperty(""Pooka.autoCache"", ""false""))).equalsIgnoreCase(""true"");
			 }
			 createFilters();
			 if (getFolderNode() != null) getFolderNode().popupMenu = null;
		 }
		 else {
			 super.valueChanged(changedValue);
		 }
	 }
	 public boolean getCacheHeadersOnly() {
		 return Pooka.getProperty(getFolderProperty() + "".cacheHeadersOnly"", Pooka.getProperty(getParentStore().getStoreProperty() + "".cacheHeadersOnly"", ""false"")).equalsIgnoreCase(""true"");
	 }
}",1,0,0,0
"private Iso3166Country(String fullName, String threeLetterCode,int numberCode);",0,0,0,0
"public class NativeRegExp extends IdScriptableObject implements Function{
	 private static final Object REGEXP_TAG = new Object();
	 public static final int JSREG_GLOB = 0x1;
	 public static final int JSREG_FOLD = 0x2;
	 public static final int JSREG_MULTILINE = 0x4;
	 public static final int TEST = 0;
	 public static final int MATCH = 1;
	 public static final int PREFIX = 2;
	 private static final boolean debug = false;
	 private static final byte REOP_EMPTY = 0;
	 private static final byte REOP_ALT = 1;
	 private static final byte REOP_BOL = 2;
	 private static final byte REOP_EOL = 3;
	 private static final byte REOP_WBDRY = 4;
	 private static final byte REOP_WNONBDRY = 5;
	 private static final byte REOP_QUANT = 6;
	 private static final byte REOP_STAR = 7;
	 private static final byte REOP_PLUS = 8;
	 private static final byte REOP_OPT = 9;
	 private static final byte REOP_LPAREN = 10;
	 private static final byte REOP_RPAREN = 11;
	 private static final byte REOP_DOT = 12;
	 private static final byte REOP_CCLASS = 13;
	 private static final byte REOP_DIGIT = 14;
	 private static final byte REOP_NONDIGIT = 15;
	 private static final byte REOP_ALNUM = 16;
	 private static final byte REOP_NONALNUM = 17;
	 private static final byte REOP_SPACE = 18;
	 private static final byte REOP_NONSPACE = 19;
	 private static final byte REOP_BACKREF = 20;
	 private static final byte REOP_FLAT = 21;
	 private static final byte REOP_FLAT1 = 22;
	 private static final byte REOP_JUMP = 23;
	 private static final byte REOP_DOTSTAR = 24;
	 private static final byte REOP_ANCHOR = 25;
	 private static final byte REOP_EOLONLY = 26;
	 private static final byte REOP_UCFLAT = 27;
	 private static final byte REOP_UCFLAT1 = 28;
	 private static final byte REOP_UCCLASS = 29;
	 private static final byte REOP_NUCCLASS = 30;
	 private static final byte REOP_BACKREFi = 31;
	 private static final byte REOP_FLATi = 32;
	 private static final byte REOP_FLAT1i = 33;
	 private static final byte REOP_UCFLATi = 34;
	 private static final byte REOP_UCFLAT1i = 35;
	 private static final byte REOP_ANCHOR1 = 36;
	 private static final byte REOP_NCCLASS = 37;
	 private static final byte REOP_DOTSTARMIN = 38;
	 private static final byte REOP_LPARENNON = 39;
	 private static final byte REOP_RPARENNON = 40;
	 private static final byte REOP_ASSERT = 41;
	 private static final byte REOP_ASSERT_NOT = 42;
	 private static final byte REOP_ASSERTTEST = 43;
	 private static final byte REOP_ASSERTNOTTEST = 44;
	 private static final byte REOP_MINIMALSTAR = 45;
	 private static final byte REOP_MINIMALPLUS = 46;
	 private static final byte REOP_MINIMALOPT = 47;
	 private static final byte REOP_MINIMALQUANT = 48;
	 private static final byte REOP_ENDCHILD = 49;
	 private static final byte REOP_CLASS = 50;
	 private static final byte REOP_REPEAT = 51;
	 private static final byte REOP_MINIMALREPEAT = 52;
	 private static final byte REOP_END = 53;
	 public static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeRegExp proto = new NativeRegExp();
		 proto.re = (RECompiled)compileRE("""", null, false);
		 proto.activatePrototypeMap(MAX_PROTOTYPE_ID);
		 proto.setParentScope(scope);
		 proto.setPrototype(getObjectPrototype(scope));
		 NativeRegExpCtor ctor = new NativeRegExpCtor();
		 ScriptRuntime.setFunctionProtoAndParent(ctor, scope);
		 ctor.setImmunePrototypeProperty(proto);
		 if (sealed) {
			 proto.sealObject();
			 ctor.sealObject();
		 }
		 defineProperty(scope, ""RegExp"", ctor, ScriptableObject.DONTENUM);
	 }
	 NativeRegExp(Scriptable scope, Object regexpCompiled) {
		 this.re = (RECompiled)regexpCompiled;
		 this.lastIndex = 0;
		 ScriptRuntime.setObjectProtoAndParent(this, scope);
	 }
	 public String getClassName() {
		 return ""RegExp"";
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return execSub(cx, scope, args, MATCH);
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 return (Scriptable)execSub(cx, scope, args, MATCH);
	 }
	 Scriptable compile(Context cx, Scriptable scope, Object[] args) {
		 if (args.length > 0 && args[0] instanceof NativeRegExp) {
			 if (args.length > 1 && args[1] != Undefined.instance) {
				 throw ScriptRuntime.typeError0(""msg.bad.regexp.compile"");
			 }
			 NativeRegExp thatObj = (NativeRegExp) args[0];
			 this.re = thatObj.re;
			 this.lastIndex = thatObj.lastIndex;
			 return this;
		 }
		 String s = args.length == 0 ? """" : ScriptRuntime.toString(args[0]);
		 String global = args.length > 1 && args[1] != Undefined.instance ? ScriptRuntime.toString(args[1]) : null;
		 this.re = (RECompiled)compileRE(s, global, false);
		 this.lastIndex = 0;
		 return this;
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 buf.append('/');
		 if (re.source.length != 0) {
			 buf.append(re.source);
		 }
		 else {
			 buf.append(""(?:)"");
		 }
		 buf.append('/');
		 if ((re.flags & JSREG_GLOB) != 0) buf.append('g');
		 if ((re.flags & JSREG_FOLD) != 0) buf.append('i');
		 if ((re.flags & JSREG_MULTILINE) != 0) buf.append('m');
		 return buf.toString();
	 }
	 NativeRegExp() {
	 }
	 private static RegExpImpl getImpl(Context cx) {
		 return (RegExpImpl) ScriptRuntime.getRegExpProxy(cx);
	 }
	 private Object execSub(Context cx, Scriptable scopeObj, Object[] args, int matchType) {
		 RegExpImpl reImpl = getImpl(cx);
		 String str;
		 if (args.length == 0) {
			 str = reImpl.input;
			 if (str == null) {
				 reportError(""msg.no.re.input.for"", toString());
			 }
		 }
		 else {
			 str = ScriptRuntime.toString(args[0]);
		 }
		 double d = ((re.flags & JSREG_GLOB) != 0) ? lastIndex : 0;
		 Object rval;
		 if (d < 0 || str.length() < d) {
			 lastIndex = 0;
			 rval = null;
		 }
		 else {
			 int indexp[] = {
			 (int)d }
			;
			 rval = executeRegExp(cx, scopeObj, reImpl, str, indexp, matchType);
			 if ((re.flags & JSREG_GLOB) != 0) {
				 lastIndex = (rval == null || rval == Undefined.instance) ? 0 : indexp[0];
			 }
		 }
		 return rval;
	 }
	 static Object compileRE(String str, String global, boolean flat) {
		 RECompiled regexp = new RECompiled();
		 regexp.source = str.toCharArray();
		 int length = str.length();
		 int flags = 0;
		 if (global != null) {
			 for (int i = 0;
			 i < global.length();
			 i++) {
				 char c = global.charAt(i);
				 if (c == 'g') {
					 flags |= JSREG_GLOB;
				 }
				 else if (c == 'i') {
					 flags |= JSREG_FOLD;
				 }
				 else if (c == 'm') {
					 flags |= JSREG_MULTILINE;
				 }
				 else {
					 reportError(""msg.invalid.re.flag"", String.valueOf(c));
				 }
			 }
		 }
		 regexp.flags = flags;
		 CompilerState state = new CompilerState(regexp.source, length, flags);
		 if (flat && length > 0) {
			if (debug) {
				System.out.println(""flat = \"""" + str + ""\"""");
			}
			 state.result = new RENode(REOP_FLAT);
			 state.result.chr = state.cpbegin[0];
			 state.result.length = length;
			 state.result.flatIndex = 0;
			 state.progLength += 5;
		 }
		 else if (!parseDisjunction(state)) return null;
		 regexp.program = new byte[state.progLength + 1];
		 if (state.classCount != 0) {
			 regexp.classList = new RECharSet[state.classCount];
			 regexp.classCount = state.classCount;
		 }
		 int endPC = emitREBytecode(state, regexp, 0, state.result);
		 regexp.program[endPC++] = REOP_END;
		if (debug) {
			System.out.println(""Prog. length = "" + endPC);
			for (int i = 0;
			 i < endPC;
			 i++) {
				 System.out.print(regexp.program[i]);
				 if (i < (endPC - 1)) System.out.print("", "");
			}
			System.out.println();
		}
		 regexp.parenCount = state.parenCount;
		 switch (regexp.program[0]) {
			 case REOP_UCFLAT1: case REOP_UCFLAT1i: regexp.anchorCh = (char)getIndex(regexp.program, 1);
			 break;
			 case REOP_FLAT1: case REOP_FLAT1i: regexp.anchorCh = (char)(regexp.program[1] & 0xFF);
			 break;
			 case REOP_FLAT: case REOP_FLATi: int k = getIndex(regexp.program, 1);
			 regexp.anchorCh = regexp.source[k];
			 break;
		 }
		if (debug) {
			if (regexp.anchorCh >= 0) {
				 System.out.println(""Anchor ch = '"" + (char)regexp.anchorCh + ""'"");
			}
		}
		 return regexp;
	 }
	 static boolean isDigit(char c) {
		 return '0' <= c && c <= '9';
	 }
	 private static boolean isWord(char c) {
		 return Character.isLetter(c) || isDigit(c) || c == '_';
	 }
	 private static boolean isLineTerm(char c) {
		 return ScriptRuntime.isJSLineTerminator(c);
	 }
	 private static boolean isREWhiteSpace(int c) {
		 return (c == '\u0020' || c == '\u0009' || c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029 || c == '\u000C' || c == '\u000B' || c == '\u00A0' || Character.getType((char)c) == Character.SPACE_SEPARATOR);
	 }
	 private static char upcase(char ch) {
		 if (ch < 128) {
			 if ('a' <= ch && ch <= 'z') {
				 return (char)(ch + ('A' - 'a'));
			 }
			 return ch;
		 }
		 char cu = Character.toUpperCase(ch);
		 if ((ch >= 128) && (cu < 128)) return ch;
		 return cu;
	 }
	 private static char downcase(char ch) {
		 if (ch < 128) {
			 if ('A' <= ch && ch <= 'Z') {
				 return (char)(ch + ('a' - 'A'));
			 }
			 return ch;
		 }
		 char cl = Character.toLowerCase(ch);
		 if ((ch >= 128) && (cl < 128)) return ch;
		 return cl;
	 }
	 private static int toASCIIHexDigit(int c) {
		 if (c < '0') return -1;
		 if (c <= '9') {
			 return c - '0';
		 }
		 c |= 0x20;
		 if ('a' <= c && c <= 'f') {
			 return c - 'a' + 10;
		 }
		 return -1;
	 }
	 private static boolean parseDisjunction(CompilerState state) {
		 if (!parseAlternative(state)) return false;
		 char[] source = state.cpbegin;
		 int index = state.cp;
		 if (index != source.length && source[index] == '|') {
			 RENode altResult;
			 ++state.cp;
			 altResult = new RENode(REOP_ALT);
			 altResult.kid = state.result;
			 if (!parseDisjunction(state)) return false;
			 altResult.kid2 = state.result;
			 state.result = altResult;
			 state.progLength += 9;
		 }
		 return true;
	 }
	 private static boolean parseAlternative(CompilerState state) {
		 RENode headTerm = null;
		 RENode tailTerm = null;
		 char[] source = state.cpbegin;
		 while (true) {
			 if (state.cp == state.cpend || source[state.cp] == '|' || (state.parenNesting != 0 && source[state.cp] == ')')) {
				 if (headTerm == null) {
					 state.result = new RENode(REOP_EMPTY);
				 }
				 else state.result = headTerm;
				 return true;
			 }
			 if (!parseTerm(state)) return false;
			 if (headTerm == null) headTerm = state.result;
			 else {
				 if (tailTerm == null) {
					 headTerm.next = state.result;
					 tailTerm = state.result;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
				 else {
					 tailTerm.next = state.result;
					 tailTerm = tailTerm.next;
					 while (tailTerm.next != null) tailTerm = tailTerm.next;
				 }
			 }
		 }
	 }
	 private static boolean calculateBitmapSize(CompilerState state, RENode target, char[] src, int index, int end) {
		 char rangeStart = 0;
		 char c;
		 int n;
		 int digit;
		 int nDigits;
		 int i;
		 int max = 0;
		 boolean inRange = false;
		 target.bmsize = 0;
		 if (index == end) return true;
		 if (src[index] == '^') ++index;
		 while (index != end) {
			 int localMax = 0;
			 nDigits = 2;
			 switch (src[index]) {
				 case '\\': ++index;
				 c = src[index++];
				 switch (c) {
					 case 'b': localMax = 0x8;
					 break;
					 case 'f': localMax = 0xC;
					 break;
					 case 'n': localMax = 0xA;
					 break;
					 case 'r': localMax = 0xD;
					 break;
					 case 't': localMax = 0x9;
					 break;
					 case 'v': localMax = 0xB;
					 break;
					 case 'c': if (((index + 1) < end) && Character.isLetter(src[index + 1])) localMax = (char)(src[index++] & 0x1F);
					 else localMax = '\\';
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (index < end);
					 i++) {
						 c = src[index++];
						 n = Kit.xDigitToInt(c, n);
						 if (n < 0) {
							 index -= (i + 1);
							 n = '\\';
							 break;
						 }
					 }
					 localMax = n;
					 break;
					 case 'd': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 localMax = '9';
					 break;
					 case 'D': case 's': case 'S': case 'w': case 'W': if (inRange) {
						 reportError(""msg.bad.range"", """");
						 return false;
					 }
					 target.bmsize = 65535;
					 return true;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = src[index];
					 if ('0' <= c && c <= '7') {
						 index++;
						 n = 8 * n + (c - '0');
						 c = src[index];
						 if ('0' <= c && c <= '7') {
							 index++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else index--;
						 }
					 }
					 localMax = n;
					 break;
					 default: localMax = c;
					 break;
				 }
				 break;
				 default: localMax = src[index++];
				 break;
			 }
			 if (inRange) {
				 if (rangeStart > localMax) {
					 reportError(""msg.bad.range"", """");
					 return false;
				 }
				 inRange = false;
			 }
			 else {
				 if (index < (end - 1)) {
					 if (src[index] == '-') {
						 ++index;
						 inRange = true;
						 rangeStart = (char)localMax;
						 continue;
					 }
				 }
			 }
			 if ((state.flags & JSREG_FOLD) != 0){
				 char cu = upcase((char)localMax);
				 char cd = downcase((char)localMax);
				 localMax = (cu >= cd) ? cu : cd;
			 }
			 if (localMax > max) max = localMax;
		 }
		 target.bmsize = max;
		 return true;
	 }
	 private static void doFlat(CompilerState state, char c) {
		 state.result = new RENode(REOP_FLAT);
		 state.result.chr = c;
		 state.result.length = 1;
		 state.result.flatIndex = -1;
		 state.progLength += 3;
	 }
	 private static int getDecimalValue(char c, CompilerState state, int maxValue, String overflowMessageId) {
		 boolean overflow = false;
		 int start = state.cp;
		 char[] src = state.cpbegin;
		 int value = c - '0';
		 for (;
		 state.cp != state.cpend;
		 ++state.cp) {
			 c = src[state.cp];
			 if (!isDigit(c)) {
				 break;
			 }
			 if (!overflow) {
				 int digit = c - '0';
				 if (value < (maxValue - digit) / 10) {
					 value = value * 10 + digit;
				 }
				 else {
					 overflow = true;
					 value = maxValue;
				 }
			 }
		 }
		 if (overflow) {
			 reportError(overflowMessageId, String.valueOf(src, start, state.cp - start));
		 }
		 return value;
	 }
	 private static boolean parseTerm(CompilerState state) {
		 char[] src = state.cpbegin;
		 char c = src[state.cp++];
		 int nDigits = 2;
		 int parenBaseCount = state.parenCount;
		 int num, tmp;
		 RENode term;
		 int termStart;
		 int ocp = state.cp;
		 switch (c) {
			 case '^': state.result = new RENode(REOP_BOL);
			 state.progLength++;
			 return true;
			 case '$': state.result = new RENode(REOP_EOL);
			 state.progLength++;
			 return true;
			 case '\\': if (state.cp < state.cpend) {
				 c = src[state.cp++];
				 switch (c) {
					 case 'b' : state.result = new RENode(REOP_WBDRY);
					 state.progLength++;
					 return true;
					 case 'B': state.result = new RENode(REOP_WNONBDRY);
					 state.progLength++;
					 return true;
					 case '0': num = 0;
					 while (state.cp < state.cpend) {
						 c = src[state.cp];
						 if ((c >= '0') && (c <= '7')) {
							 state.cp++;
							 tmp = 8 * num + (c - '0');
							 if (tmp > 0377) break;
							 num = tmp;
						 }
						 else break;
					 }
					 c = (char)(num);
					 doFlat(state, c);
					 break;
					 case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': termStart = state.cp - 1;
					 num = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.backref"");
					 if ((num > 9) && (num > state.parenCount)) {
						 state.cp = termStart;
						 num = 0;
						 while (state.cp < state.cpend) {
							 c = src[state.cp];
							 if ((c >= '0') && (c <= '7')) {
								 state.cp++;
								 tmp = 8 * num + (c - '0');
								 if (tmp > 0377) break;
								 num = tmp;
							 }
							 else break;
						 }
						 c = (char)(num);
						 doFlat(state, c);
						 break;
					 }
					 state.result = new RENode(REOP_BACKREF);
					 state.result.parenIndex = num - 1;
					 state.progLength += 3;
					 break;
					 case 'f': c = 0xC;
					 doFlat(state, c);
					 break;
					 case 'n': c = 0xA;
					 doFlat(state, c);
					 break;
					 case 'r': c = 0xD;
					 doFlat(state, c);
					 break;
					 case 't': c = 0x9;
					 doFlat(state, c);
					 break;
					 case 'v': c = 0xB;
					 doFlat(state, c);
					 break;
					 case 'c': if (((state.cp + 1) < state.cpend) && Character.isLetter(src[state.cp + 1])) c = (char)(src[state.cp++] & 0x1F);
					 else {
						 --state.cp;
						 c = '\\';
					 }
					 doFlat(state, c);
					 break;
					 case 'u': nDigits += 2;
					 case 'x': {
						 int n = 0;
						 int i;
						 for (i = 0;
						 (i < nDigits) && (state.cp < state.cpend);
						 i++) {
							 int digit;
							 c = src[state.cp++];
							 n = Kit.xDigitToInt(c, n);
							 if (n < 0) {
								 state.cp -= (i + 2);
								 n = src[state.cp++];
								 break;
							 }
						 }
						 c = (char)(n);
					 }
					 doFlat(state, c);
					 break;
					 case 'd': state.result = new RENode(REOP_DIGIT);
					 state.progLength++;
					 break;
					 case 'D': state.result = new RENode(REOP_NONDIGIT);
					 state.progLength++;
					 break;
					 case 's': state.result = new RENode(REOP_SPACE);
					 state.progLength++;
					 break;
					 case 'S': state.result = new RENode(REOP_NONSPACE);
					 state.progLength++;
					 break;
					 case 'w': state.result = new RENode(REOP_ALNUM);
					 state.progLength++;
					 break;
					 case 'W': state.result = new RENode(REOP_NONALNUM);
					 state.progLength++;
					 break;
					 default: state.result = new RENode(REOP_FLAT);
					 state.result.chr = c;
					 state.result.length = 1;
					 state.result.flatIndex = state.cp - 1;
					 state.progLength += 3;
					 break;
				 }
				 break;
			 }
			 else {
				 reportError(""msg.trail.backslash"", """");
				 return false;
			 }
			 case '(': {
				 RENode result = null;
				 termStart = state.cp;
				 if (state.cp + 1 < state.cpend && src[state.cp] == '?' && ((c = src[state.cp + 1]) == '=' || c == '!' || c == ':')) {
					 state.cp += 2;
					 if (c == '=') {
						 result = new RENode(REOP_ASSERT);
						 state.progLength += 4;
					 }
					 else if (c == '!') {
						 result = new RENode(REOP_ASSERT_NOT);
						 state.progLength += 4;
					 }
				 }
				 else {
					 result = new RENode(REOP_LPAREN);
					 state.progLength += 6;
					 result.parenIndex = state.parenCount++;
				 }
				 ++state.parenNesting;
				 if (!parseDisjunction(state)) return false;
				 if (state.cp == state.cpend || src[state.cp] != ')') {
					 reportError(""msg.unterm.paren"", """");
					 return false;
				 }
				 ++state.cp;
				 --state.parenNesting;
				 if (result != null) {
					 result.kid = state.result;
					 state.result = result;
				 }
				 break;
			 }
			 case ')': reportError(""msg.re.unmatched.right.paren"", """");
			 return false;
			 case '[': state.result = new RENode(REOP_CLASS);
			 termStart = state.cp;
			 state.result.startIndex = termStart;
			 while (true) {
				 if (state.cp == state.cpend) {
					 reportError(""msg.unterm.class"", """");
					 return false;
				 }
				 if (src[state.cp] == '\\') state.cp++;
				 else {
					 if (src[state.cp] == ']') {
						 state.result.kidlen = state.cp - termStart;
						 break;
					 }
				 }
				 state.cp++;
			 }
			 state.result.index = state.classCount++;
			 if (!calculateBitmapSize(state, state.result, src, termStart, state.cp++)) return false;
			 state.progLength += 3;
			 break;
			 case '.': state.result = new RENode(REOP_DOT);
			 state.progLength++;
			 break;
			 case '*': case '+': case '?': reportError(""msg.bad.quant"", String.valueOf(src[state.cp - 1]));
			 return false;
			 default: state.result = new RENode(REOP_FLAT);
			 state.result.chr = c;
			 state.result.length = 1;
			 state.result.flatIndex = state.cp - 1;
			 state.progLength += 3;
			 break;
		 }
		 term = state.result;
		 if (state.cp == state.cpend) {
			 return true;
		 }
		 boolean hasQ = false;
		 switch (src[state.cp]) {
			 case '+': state.result = new RENode(REOP_QUANT);
			 state.result.min = 1;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '*': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = -1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '?': state.result = new RENode(REOP_QUANT);
			 state.result.min = 0;
			 state.result.max = 1;
			 state.progLength += 8;
			 hasQ = true;
			 break;
			 case '{
				': {
					 int min = 0;
					 int max = -1;
					 int leftCurl = state.cp;
					 c = src[++state.cp];
					 if (isDigit(c)) {
						 ++state.cp;
						 min = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.min"");
						 c = src[state.cp];
						 if (c == ',') {
							 c = src[++state.cp];
							 if (isDigit(c)) {
								 ++state.cp;
								 max = getDecimalValue(c, state, 0xFFFF, ""msg.overlarge.max"");
								 c = src[state.cp];
								 if (min > max) {
									 reportError(""msg.max.lt.min"", String.valueOf(src[state.cp]));
									 return false;
								 }
							 }
						 }
						 else {
							 max = min;
						 }
					 if (c == '}
					') {
						 state.result = new RENode(REOP_QUANT);
						 state.result.min = min;
						 state.result.max = max;
						 state.progLength += 12;
						 hasQ = true;
					 }
				 }
				 if (!hasQ) {
					 state.cp = leftCurl;
				 }
				 break;
			 }
		 }
		 if (!hasQ) return true;
		 ++state.cp;
		 state.result.kid = term;
		 state.result.parenIndex = parenBaseCount;
		 state.result.parenCount = state.parenCount - parenBaseCount;
		 if ((state.cp < state.cpend) && (src[state.cp] == '?')) {
			 ++state.cp;
			 state.result.greedy = false;
		 }
		 else state.result.greedy = true;
		 return true;
	 }
	 private static void resolveForwardJump(byte[] array, int from, int pc) {
		 if (from > pc) throw Kit.codeBug();
		 addIndex(array, from, pc - from);
	 }
	 private static int getOffset(byte[] array, int pc) {
		 return getIndex(array, pc);
	 }
	 private static int addIndex(byte[] array, int pc, int index) {
		 if (index < 0) throw Kit.codeBug();
		 if (index > 0xFFFF) throw Context.reportRuntimeError(""Too complex regexp"");
		 array[pc] = (byte)(index >> 8);
		 array[pc + 1] = (byte)(index);
		 return pc + 2;
	 }
	 private static int getIndex(byte[] array, int pc) {
		 return ((array[pc] & 0xFF) << 8) | (array[pc + 1] & 0xFF);
	 }
	 private static final int OFFSET_LEN = 2;
	 private static final int INDEX_LEN = 2;
	 private static int emitREBytecode(CompilerState state, RECompiled re, int pc, RENode t) {
		 RENode nextAlt;
		 int nextAltFixup, nextTermFixup;
		 byte[] program = re.program;
		 while (t != null) {
			 program[pc++] = t.op;
			 switch (t.op) {
				 case REOP_EMPTY: --pc;
				 break;
				 case REOP_ALT: nextAlt = t.kid2;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_JUMP;
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextAltFixup, pc);
				 pc = emitREBytecode(state, re, pc, nextAlt);
				 program[pc++] = REOP_JUMP;
				 nextAltFixup = pc;
				 pc += OFFSET_LEN;
				 resolveForwardJump(program, nextTermFixup, pc);
				 resolveForwardJump(program, nextAltFixup, pc);
				 break;
				 case REOP_FLAT: if (t.flatIndex != -1) {
					 while ((t.next != null) && (t.next.op == REOP_FLAT) && ((t.flatIndex + t.length) == t.next.flatIndex)) {
						 t.length += t.next.length;
						 t.next = t.next.next;
					 }
				 }
				 if ((t.flatIndex != -1) && (t.length > 1)) {
					 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLATi;
					 else program[pc - 1] = REOP_FLAT;
					 pc = addIndex(program, pc, t.flatIndex);
					 pc = addIndex(program, pc, t.length);
				 }
				 else {
					 if (t.chr < 256) {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_FLAT1i;
						 else program[pc - 1] = REOP_FLAT1;
						 program[pc++] = (byte)(t.chr);
					 }
					 else {
						 if ((state.flags & JSREG_FOLD) != 0) program[pc - 1] = REOP_UCFLAT1i;
						 else program[pc - 1] = REOP_UCFLAT1;
						 pc = addIndex(program, pc, t.chr);
					 }
				 }
				 break;
				 case REOP_LPAREN: pc = addIndex(program, pc, t.parenIndex);
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_RPAREN;
				 pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_BACKREF: pc = addIndex(program, pc, t.parenIndex);
				 break;
				 case REOP_ASSERT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_ASSERT_NOT: nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ASSERTNOTTEST;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_QUANT: if ((t.min == 0) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
				 else if ((t.min == 0) && (t.max == 1)) program[pc - 1] = (t.greedy) ? REOP_OPT : REOP_MINIMALOPT;
				 else if ((t.min == 1) && (t.max == -1)) program[pc - 1] = (t.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
				 else {
					 if (!t.greedy) program[pc - 1] = REOP_MINIMALQUANT;
					 pc = addIndex(program, pc, t.min);
					 pc = addIndex(program, pc, t.max + 1);
				 }
				 pc = addIndex(program, pc, t.parenCount);
				 pc = addIndex(program, pc, t.parenIndex);
				 nextTermFixup = pc;
				 pc += OFFSET_LEN;
				 pc = emitREBytecode(state, re, pc, t.kid);
				 program[pc++] = REOP_ENDCHILD;
				 resolveForwardJump(program, nextTermFixup, pc);
				 break;
				 case REOP_CLASS: pc = addIndex(program, pc, t.index);
				 re.classList[t.index] = new RECharSet(t.bmsize, t.startIndex, t.kidlen);
				 break;
				 default: break;
			 }
			 t = t.next;
		 }
		 return pc;
	 }
	 private static void pushProgState(REGlobalData gData, int min, int max, REBackTrackData backTrackLastToSave, int continuation_pc, int continuation_op) {
		 gData.stateStackTop = new REProgState(gData.stateStackTop, min, max, gData.cp, backTrackLastToSave, continuation_pc, continuation_op);
	 }
	 private static REProgState popProgState(REGlobalData gData) {
		 REProgState state = gData.stateStackTop;
		 gData.stateStackTop = state.previous;
		 return state;
	 }
	 private static void pushBackTrackState(REGlobalData gData, byte op, int target) {
		 gData.backTrackStackTop = new REBackTrackData(gData, op, target);
	 }
	 private static boolean flatNMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (gData.regexp.source[matchChars + i] != chars[gData.cp + i]) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean flatNIMatcher(REGlobalData gData, int matchChars, int length, char[] chars, int end) {
		 if ((gData.cp + length) > end) return false;
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (upcase(gData.regexp.source[matchChars + i]) != upcase(chars[gData.cp + i])) {
				 return false;
			 }
		 }
		 gData.cp += length;
		 return true;
	 }
	 private static boolean backrefMatcher(REGlobalData gData, int parenIndex, char[] chars, int end) {
		 int len;
		 int i;
		 int parenContent = gData.parens_index(parenIndex);
		 if (parenContent == -1) return true;
		 len = gData.parens_length(parenIndex);
		 if ((gData.cp + len) > end) return false;
		 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (upcase(chars[parenContent + i]) != upcase(chars[gData.cp + i])) return false;
			 }
		 }
		 else {
			 for (i = 0;
			 i < len;
			 i++) {
				 if (chars[parenContent + i] != chars[gData.cp + i]) return false;
			 }
		 }
		 gData.cp += len;
		 return true;
	 }
	 private static void addCharacterToCharSet(RECharSet cs, char c) {
		 int byteIndex = (int)(c / 8);
		 if (c > cs.length) throw new RuntimeException();
		 cs.bits[byteIndex] |= 1 << (c & 0x7);
	 }
	 private static void addCharacterRangeToCharSet(RECharSet cs, char c1, char c2) {
		 int i;
		 int byteIndex1 = (int)(c1 / 8);
		 int byteIndex2 = (int)(c2 / 8);
		 if ((c2 > cs.length) || (c1 > c2)) throw new RuntimeException();
		 c1 &= 0x7;
		 c2 &= 0x7;
		 if (byteIndex1 == byteIndex2) {
			 cs.bits[byteIndex1] |= ((int)(0xFF) >> (7 - (c2 - c1))) << c1;
		 }
		 else {
			 cs.bits[byteIndex1] |= 0xFF << c1;
			 for (i = byteIndex1 + 1;
			 i < byteIndex2;
			 i++) cs.bits[i] = (byte)0xFF;
			 cs.bits[byteIndex2] |= (int)(0xFF) >> (7 - c2);
		 }
	 }
	 private static void processCharSet(REGlobalData gData, RECharSet charSet) {
		 synchronized (charSet) {
			 if (!charSet.converted) {
				 processCharSetImpl(gData, charSet);
				 charSet.converted = true;
			 }
		 }
	 }
	 private static void processCharSetImpl(REGlobalData gData, RECharSet charSet) {
		 int src = charSet.startIndex;
		 int end = src + charSet.strlength;
		 char rangeStart = 0, thisCh;
		 int byteLength;
		 char c;
		 int n;
		 int nDigits;
		 int i;
		 boolean inRange = false;
		 charSet.sense = true;
		 byteLength = (charSet.length / 8) + 1;
		 charSet.bits = new byte[byteLength];
		 if (src == end) return;
		 if (gData.regexp.source[src] == '^') {
			 charSet.sense = false;
			 ++src;
		 }
		 while (src != end) {
			 nDigits = 2;
			 switch (gData.regexp.source[src]) {
				 case '\\': ++src;
				 c = gData.regexp.source[src++];
				 switch (c) {
					 case 'b': thisCh = 0x8;
					 break;
					 case 'f': thisCh = 0xC;
					 break;
					 case 'n': thisCh = 0xA;
					 break;
					 case 'r': thisCh = 0xD;
					 break;
					 case 't': thisCh = 0x9;
					 break;
					 case 'v': thisCh = 0xB;
					 break;
					 case 'c': if (((src + 1) < end) && isWord(gData.regexp.source[src + 1])) thisCh = (char)(gData.regexp.source[src++] & 0x1F);
					 else {
						 --src;
						 thisCh = '\\';
					 }
					 break;
					 case 'u': nDigits += 2;
					 case 'x': n = 0;
					 for (i = 0;
					 (i < nDigits) && (src < end);
					 i++) {
						 c = gData.regexp.source[src++];
						 int digit = toASCIIHexDigit(c);
						 if (digit < 0) {
							 src -= (i + 1);
							 n = '\\';
							 break;
						 }
						 n = (n << 4) | digit;
					 }
					 thisCh = (char)(n);
					 break;
					 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': n = (c - '0');
					 c = gData.regexp.source[src];
					 if ('0' <= c && c <= '7') {
						 src++;
						 n = 8 * n + (c - '0');
						 c = gData.regexp.source[src];
						 if ('0' <= c && c <= '7') {
							 src++;
							 i = 8 * n + (c - '0');
							 if (i <= 0377) n = i;
							 else src--;
						 }
					 }
					 thisCh = (char)(n);
					 break;
					 case 'd': addCharacterRangeToCharSet(charSet, '0', '9');
					 continue;
					 case 'D': addCharacterRangeToCharSet(charSet, (char)0, (char)('0' - 1));
					 addCharacterRangeToCharSet(charSet, (char)('9' + 1), (char)(charSet.length));
					 continue;
					 case 's': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'S': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (!isREWhiteSpace(i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'w': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 case 'W': for (i = (int)(charSet.length);
					 i >= 0;
					 i--) if (!isWord((char)i)) addCharacterToCharSet(charSet, (char)(i));
					 continue;
					 default: thisCh = c;
					 break;
				 }
				 break;
				 default: thisCh = gData.regexp.source[src++];
				 break;
			 }
			 if (inRange) {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterRangeToCharSet(charSet, upcase(rangeStart), upcase(thisCh));
					 addCharacterRangeToCharSet(charSet, downcase(rangeStart), downcase(thisCh));
				 }
				 else {
					 addCharacterRangeToCharSet(charSet, rangeStart, thisCh);
				 }
				 inRange = false;
			 }
			 else {
				 if ((gData.regexp.flags & JSREG_FOLD) != 0) {
					 addCharacterToCharSet(charSet, upcase(thisCh));
					 addCharacterToCharSet(charSet, downcase(thisCh));
				 }
				 else {
					 addCharacterToCharSet(charSet, thisCh);
				 }
				 if (src < (end - 1)) {
					 if (gData.regexp.source[src] == '-') {
						 ++src;
						 inRange = true;
						 rangeStart = thisCh;
					 }
				 }
			 }
		 }
	 }
	 private static boolean classMatcher(REGlobalData gData, RECharSet charSet, char ch) {
		 if (!charSet.converted) {
			 processCharSet(gData, charSet);
		 }
		 int byteIndex = ch / 8;
		 if (charSet.sense) {
			 if ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) )) return false;
		 }
		 else {
			 if (! ((charSet.length == 0) || ( (ch > charSet.length) || ((charSet.bits[byteIndex] & (1 << (ch & 0x7))) == 0) ))) return false;
		 }
		 return true;
	 }
	 private static boolean executeREBytecode(REGlobalData gData, char[] chars, int end) {
		 int pc = 0;
		 byte program[] = gData.regexp.program;
		 int currentContinuation_op;
		 int currentContinuation_pc;
		 boolean result = false;
		 currentContinuation_pc = 0;
		 currentContinuation_op = REOP_END;
		if (debug) {
			System.out.println(""Input = \"""" + new String(chars) + ""\"", start at "" + gData.cp);
		}
		 int op = program[pc++];
		 for (;
		;
		) {
			if (debug) {
				System.out.println(""Testing at "" + gData.cp + "", op = "" + op);
			}
			 switch (op) {
				 case REOP_EMPTY: result = true;
				 break;
				 case REOP_BOL: if (gData.cp != 0) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp - 1])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_EOL: if (gData.cp != end) {
					 if (gData.multiline || ((gData.regexp.flags & JSREG_MULTILINE) != 0)) {
						 if (!isLineTerm(chars[gData.cp])) {
							 result = false;
							 break;
						 }
					 }
					 else {
						 result = false;
						 break;
					 }
				 }
				 result = true;
				 break;
				 case REOP_WBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ !((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_WNONBDRY: result = ((gData.cp == 0 || !isWord(chars[gData.cp - 1])) ^ ((gData.cp < end) && isWord(chars[gData.cp])));
				 break;
				 case REOP_DOT: result = (gData.cp != end && !isLineTerm(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_DIGIT: result = (gData.cp != end && isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONDIGIT: result = (gData.cp != end && !isDigit(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_SPACE: result = (gData.cp != end && isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONSPACE: result = (gData.cp != end && !isREWhiteSpace(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_ALNUM: result = (gData.cp != end && isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_NONALNUM: result = (gData.cp != end && !isWord(chars[gData.cp]));
				 if (result) {
					 gData.cp++;
				 }
				 break;
				 case REOP_FLAT: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLATi: {
					 int offset = getIndex(program, pc);
					 pc += INDEX_LEN;
					 int length = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = flatNIMatcher(gData, offset, length, chars, end);
				 }
				 break;
				 case REOP_FLAT1: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_FLAT1i: {
					 char matchCh = (char)(program[pc++] & 0xFF);
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && chars[gData.cp] == matchCh);
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_UCFLAT1i: {
					 char matchCh = (char)getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = (gData.cp != end && upcase(chars[gData.cp]) == upcase(matchCh));
					 if (result) {
						 gData.cp++;
					 }
				 }
				 break;
				 case REOP_ALT: {
					 int nextpc;
					 byte nextop;
					 pushProgState(gData, 0, 0, null, currentContinuation_pc, currentContinuation_op);
					 nextpc = pc + getOffset(program, pc);
					 nextop = program[nextpc++];
					 pushBackTrackState(gData, nextop, nextpc);
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_JUMP: {
					 int offset;
					 REProgState state = popProgState(gData);
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 offset = getOffset(program, pc);
					 pc += offset;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_LPAREN: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 gData.set_parens(parenIndex, gData.cp, 0);
					 op = program[pc++];
				 }
				 continue;
				 case REOP_RPAREN: {
					 int cap_index;
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 cap_index = gData.parens_index(parenIndex);
					 gData.set_parens(parenIndex, cap_index, gData.cp - cap_index);
					 if (parenIndex > gData.lastParen) gData.lastParen = parenIndex;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_BACKREF: {
					 int parenIndex = getIndex(program, pc);
					 pc += INDEX_LEN;
					 result = backrefMatcher(gData, parenIndex, chars, end);
				 }
				 break;
				 case REOP_CLASS: {
					 int index = getIndex(program, pc);
					 pc += INDEX_LEN;
					 if (gData.cp != end) {
						 if (classMatcher(gData, gData.regexp.classList[index], chars[gData.cp])) {
							 gData.cp++;
							 result = true;
							 break;
						 }
					 }
					 result = false;
				 }
				 break;
				 case REOP_ASSERT: case REOP_ASSERT_NOT: {
					 byte testOp;
					 pushProgState(gData, 0, 0, gData.backTrackStackTop, currentContinuation_pc, currentContinuation_op);
					 if (op == REOP_ASSERT) {
						 testOp = REOP_ASSERTTEST;
					 }
					 else {
						 testOp = REOP_ASSERTNOTTEST;
					 }
					 pushBackTrackState(gData, testOp, pc + getOffset(program, pc));
					 pc += INDEX_LEN;
					 op = program[pc++];
				 }
				 continue;
				 case REOP_ASSERTTEST: case REOP_ASSERTNOTTEST: {
					 REProgState state = popProgState(gData);
					 gData.cp = state.index;
					 gData.backTrackStackTop = state.backTrack;
					 currentContinuation_pc = state.continuation_pc;
					 currentContinuation_op = state.continuation_op;
					 if (result) {
						 if (op == REOP_ASSERTTEST) {
							 result = true;
						 }
						 else {
							 result = false;
						 }
					 }
					 else {
						 if (op == REOP_ASSERTTEST) {
						 }
						 else {
							 result = true;
						 }
					 }
				 }
				 break;
				 case REOP_STAR: case REOP_PLUS: case REOP_OPT: case REOP_QUANT: case REOP_MINIMALSTAR: case REOP_MINIMALPLUS: case REOP_MINIMALOPT: case REOP_MINIMALQUANT: {
					 int min, max;
					 boolean greedy = false;
					 switch (op) {
						 case REOP_STAR: greedy = true;
						 case REOP_MINIMALSTAR: min = 0;
						 max = -1;
						 break;
						 case REOP_PLUS: greedy = true;
						 case REOP_MINIMALPLUS: min = 1;
						 max = -1;
						 break;
						 case REOP_OPT: greedy = true;
						 case REOP_MINIMALOPT: min = 0;
						 max = 1;
						 break;
						 case REOP_QUANT: greedy = true;
						 case REOP_MINIMALQUANT: min = getOffset(program, pc);
						 pc += INDEX_LEN;
						 max = getOffset(program, pc) - 1;
						 pc += INDEX_LEN;
						 break;
						 default: throw Kit.codeBug();
					 }
					 pushProgState(gData, min, max, null, currentContinuation_pc, currentContinuation_op);
					 if (greedy) {
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 pc += 3 * INDEX_LEN;
						 op = program[pc++];
					 }
					 else {
						 if (min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 pc += 3 * INDEX_LEN;
							 op = program[pc++];
						 }
						 else {
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
					 }
				 }
				 continue;
				 case REOP_ENDCHILD: pc = currentContinuation_pc;
				 op = currentContinuation_op;
				 continue;
				 case REOP_REPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.min == 0) result = true;
						 currentContinuation_pc = state.continuation_pc;
						 currentContinuation_op = state.continuation_op;
						 pc += 2 * INDEX_LEN;
						 pc = pc + getOffset(program, pc);
						 break;
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 if (new_max == 0) {
							 result = true;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 break;
						 }
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 currentContinuation_op = REOP_REPEAT;
						 currentContinuation_pc = pc;
						 pushBackTrackState(gData, REOP_REPEAT, pc);
						 int parenCount = getIndex(program, pc);
						 pc += INDEX_LEN;
						 int parenIndex = getIndex(program, pc);
						 pc += 2 * INDEX_LEN;
						 op = program[pc++];
						 for (int k = 0;
						 k < parenCount;
						 k++) {
							 gData.set_parens(parenIndex + k, -1, 0);
						 }
					 }
				 }
				 continue;
				 case REOP_MINIMALREPEAT: {
					 REProgState state = popProgState(gData);
					 if (!result) {
						 if (state.max == -1 || state.max > 0) {
							 pushProgState(gData, state.min, state.max, null, state.continuation_pc, state.continuation_op);
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
							 continue;
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
					 }
					 else {
						 if (state.min == 0 && gData.cp == state.index) {
							 result = false;
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 break;
						 }
						 int new_min = state.min, new_max = state.max;
						 if (new_min != 0) new_min--;
						 if (new_max != -1) new_max--;
						 pushProgState(gData, new_min, new_max, null, state.continuation_pc, state.continuation_op);
						 if (new_min != 0) {
							 currentContinuation_op = REOP_MINIMALREPEAT;
							 currentContinuation_pc = pc;
							 int parenCount = getIndex(program, pc);
							 pc += INDEX_LEN;
							 int parenIndex = getIndex(program, pc);
							 pc += 2 * INDEX_LEN;
							 for (int k = 0;
							 k < parenCount;
							 k++) {
								 gData.set_parens(parenIndex + k, -1, 0);
							 }
							 op = program[pc++];
						 }
						 else {
							 currentContinuation_pc = state.continuation_pc;
							 currentContinuation_op = state.continuation_op;
							 pushBackTrackState(gData, REOP_MINIMALREPEAT, pc);
							 popProgState(gData);
							 pc += 2 * INDEX_LEN;
							 pc = pc + getOffset(program, pc);
							 op = program[pc++];
						 }
						 continue;
					 }
				 }
				 case REOP_END: return true;
				 default: throw Kit.codeBug();
			 }
			 if (!result) {
				 REBackTrackData backTrackData = gData.backTrackStackTop;
				 if (backTrackData != null) {
					 gData.backTrackStackTop = backTrackData.previous;
					 gData.lastParen = backTrackData.lastParen;
					 if (backTrackData.parens != null) {
						 gData.parens = (long[])backTrackData.parens.clone();
					 }
					 gData.cp = backTrackData.cp;
					 gData.stateStackTop = backTrackData.stateStackTop;
					 currentContinuation_op = gData.stateStackTop.continuation_op;
					 currentContinuation_pc = gData.stateStackTop.continuation_pc;
					 pc = backTrackData.continuation_pc;
					 op = backTrackData.continuation_op;
					 continue;
				 }
				 else return false;
			 }
			 op = program[pc++];
		 }
	 }
	 private static boolean matchRegExp(REGlobalData gData, RECompiled re, char[] chars, int start, int end, boolean multiline) {
		 if (re.parenCount != 0) {
			 gData.parens = new long[re.parenCount];
		 }
		 else {
			 gData.parens = null;
		 }
		 gData.backTrackStackTop = null;
		 gData.stateStackTop = null;
		 gData.multiline = multiline;
		 gData.regexp = re;
		 gData.lastParen = 0;
		 int anchorCh = gData.regexp.anchorCh;
		 for (int i = start;
		 i <= end;
		 ++i) {
			 if (anchorCh >= 0) {
				 for (;
				;
				) {
					 if (i == end) {
						 return false;
					 }
					 char matchCh = chars[i];
					 if (matchCh == anchorCh || ((gData.regexp.flags & JSREG_FOLD) != 0 && upcase(matchCh) == upcase((char)anchorCh))) {
						 break;
					 }
					 ++i;
				 }
			 }
			 gData.cp = i;
			 for (int j = 0;
			 j < re.parenCount;
			 j++) {
				 gData.set_parens(j, -1, 0);
			 }
			 boolean result = executeREBytecode(gData, chars, end);
			 gData.backTrackStackTop = null;
			 gData.stateStackTop = null;
			 if (result) {
				 gData.skipped = i - start;
				 return true;
			 }
		 }
		 return false;
	 }
	 Object executeRegExp(Context cx, Scriptable scopeObj, RegExpImpl res, String str, int indexp[], int matchType) {
		 REGlobalData gData = new REGlobalData();
		 int start = indexp[0];
		 char[] charArray = str.toCharArray();
		 int end = charArray.length;
		 if (start > end) start = end;
		 boolean matches = matchRegExp(gData, re, charArray, start, end, res.multiline);
		 if (!matches) {
			 if (matchType != PREFIX) return null;
			 return Undefined.instance;
		 }
		 int index = gData.cp;
		 int i = index;
		 indexp[0] = i;
		 int matchlen = i - (start + gData.skipped);
		 int ep = index;
		 index -= matchlen;
		 Object result;
		 Scriptable obj;
		 if (matchType == TEST) {
			 result = Boolean.TRUE;
			 obj = null;
		 }
		 else {
			 Scriptable scope = getTopLevelScope(scopeObj);
			 result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
			 obj = (Scriptable) result;
			 String matchstr = new String(charArray, index, matchlen);
			 obj.put(0, obj, matchstr);
		 }
		 if (re.parenCount == 0) {
			 res.parens = null;
			 res.lastParen = SubString.emptySubString;
		 }
		 else {
			 SubString parsub = null;
			 int num;
			 res.parens = new SubString[re.parenCount];
			 for (num = 0;
			 num < re.parenCount;
			 num++) {
				 int cap_index = gData.parens_index(num);
				 String parstr;
				 if (cap_index != -1) {
					 int cap_length = gData.parens_length(num);
					 parsub = new SubString(charArray, cap_index, cap_length);
					 res.parens[num] = parsub;
					 if (matchType == TEST) continue;
					 parstr = parsub.toString();
					 obj.put(num+1, obj, parstr);
				 }
				 else {
					 if (matchType != TEST) obj.put(num+1, obj, Undefined.instance);
				 }
			 }
			 res.lastParen = parsub;
		 }
		 if (! (matchType == TEST)) {
			 obj.put(""index"", obj, new Integer(start + gData.skipped));
			 obj.put(""input"", obj, str);
		 }
		 if (res.lastMatch == null) {
			 res.lastMatch = new SubString();
			 res.leftContext = new SubString();
			 res.rightContext = new SubString();
		 }
		 res.lastMatch.charArray = charArray;
		 res.lastMatch.index = index;
		 res.lastMatch.length = matchlen;
		 res.leftContext.charArray = charArray;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 res.leftContext.index = start;
			 res.leftContext.length = gData.skipped;
		 }
		 else {
			 res.leftContext.index = 0;
			 res.leftContext.length = start + gData.skipped;
		 }
		 res.rightContext.charArray = charArray;
		 res.rightContext.index = ep;
		 res.rightContext.length = end - ep;
		 return result;
	 }
	 int getFlags() {
		 return re.flags;
	 }
	 private static void reportError(String messageId, String arg) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg);
		 throw ScriptRuntime.constructError(""SyntaxError"", msg);
	 }
	 private static final int Id_lastIndex = 1, Id_source = 2, Id_global = 3, Id_ignoreCase = 4, Id_multiline = 5, MAX_INSTANCE_ID = 5;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 int s_length = s.length();
			 if (s_length==6) {
				 c=s.charAt(0);
				 if (c=='g') {
					 X=""global"";
					id=Id_global;
				 }
				 else if (c=='s') {
					 X=""source"";
					id=Id_source;
				 }
			 }
			 else if (s_length==9) {
				 c=s.charAt(0);
				 if (c=='l') {
					 X=""lastIndex"";
					id=Id_lastIndex;
				 }
				 else if (c=='m') {
					 X=""multiline"";
					id=Id_multiline;
				 }
			 }
			 else if (s_length==10) {
				 X=""ignoreCase"";
				id=Id_ignoreCase;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 if (id == 0) return super.findInstanceIdInfo(s);
		 int attr;
		 switch (id) {
			 case Id_lastIndex: attr = PERMANENT | DONTENUM;
			 break;
			 case Id_source: case Id_global: case Id_ignoreCase: case Id_multiline: attr = PERMANENT | READONLY | DONTENUM;
			 break;
			 default: throw new IllegalStateException();
		 }
		 return instanceIdInfo(attr, id);
	 }
	 protected String getInstanceIdName(int id) {
		 switch (id) {
			 case Id_lastIndex: return ""lastIndex"";
			 case Id_source: return ""source"";
			 case Id_global: return ""global"";
			 case Id_ignoreCase: return ""ignoreCase"";
			 case Id_multiline: return ""multiline"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 switch (id) {
			 case Id_lastIndex: return ScriptRuntime.wrapNumber(lastIndex);
			 case Id_source: return new String(re.source);
			 case Id_global: return ScriptRuntime.wrapBoolean((re.flags & JSREG_GLOB) != 0);
			 case Id_ignoreCase: return ScriptRuntime.wrapBoolean((re.flags & JSREG_FOLD) != 0);
			 case Id_multiline: return ScriptRuntime.wrapBoolean((re.flags & JSREG_MULTILINE) != 0);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_lastIndex) {
			 lastIndex = ScriptRuntime.toNumber(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_compile: arity=1;
			 s=""compile"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_exec: arity=1;
			 s=""exec"";
			 break;
			 case Id_test: arity=1;
			 s=""test"";
			 break;
			 case Id_prefix: arity=1;
			 s=""prefix"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(REGEXP_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(REGEXP_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_compile: return realThis(thisObj, f).compile(cx, scope, args);
			 case Id_toString: case Id_toSource: return realThis(thisObj, f).toString();
			 case Id_exec: return realThis(thisObj, f).execSub(cx, scope, args, MATCH);
			 case Id_test: {
				 Object x = realThis(thisObj, f).execSub(cx, scope, args, TEST);
				 return Boolean.TRUE.equals(x) ? Boolean.TRUE : Boolean.FALSE;
			 }
			 case Id_prefix: return realThis(thisObj, f).execSub(cx, scope, args, PREFIX);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 private static NativeRegExp realThis(Scriptable thisObj, IdFunctionObject f) {
		 if (!(thisObj instanceof NativeRegExp)) throw incompatibleCallError(f);
		 return (NativeRegExp)thisObj;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 4: c=s.charAt(0);
				 if (c=='e') {
					 X=""exec"";
					id=Id_exec;
				 }
				 else if (c=='t') {
					 X=""test"";
					id=Id_test;
				 }
				 break L;
				 case 6: X=""prefix"";
				id=Id_prefix;
				 break L;
				 case 7: X=""compile"";
				id=Id_compile;
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_compile = 1, Id_toString = 2, Id_toSource = 3, Id_exec = 4, Id_test = 5, Id_prefix = 6, MAX_PROTOTYPE_ID = 6;
	 private RECompiled re;
	 double lastIndex;
 }
;
 class RECompiled implements Serializable{
	 char []source;
	 int parenCount;
	 int flags;
	 byte[] program;
	 int classCount;
	 RECharSet[] classList;
	 int anchorCh = -1;
 }
class RENode {
	 RENode(byte op) {
		 this.op = op;
	 }
	 byte op;
	 RENode next;
	 RENode kid;
	 RENode kid2;
	 int num;
	 int parenIndex;
	 int min;
	 int max;
	 int parenCount;
	 boolean greedy;
	 int startIndex;
	 int kidlen;
	 int bmsize;
	 int index;
	 char chr;
	 int length;
	 int flatIndex;
 }
class CompilerState {
	 CompilerState(char[] source, int length, int flags) {
		 this.cpbegin = source;
		 this.cp = 0;
		 this.cpend = length;
		 this.flags = flags;
		 this.parenCount = 0;
		 this.classCount = 0;
		 this.progLength = 0;
	 }
	 Context cx;
	 char cpbegin[];
	 int cpend;
	 int cp;
	 int flags;
	 int parenCount;
	 int parenNesting;
	 int classCount;
	 int progLength;
	 RENode result;
}
class REProgState{
	 REProgState(REProgState previous, int min, int max, int index, REBackTrackData backTrack, int continuation_pc, int continuation_op) {
		 this.previous = previous;
		 this.min = min;
		 this.max = max;
		 this.index = index;
		 this.continuation_op = continuation_op;
		 this.continuation_pc = continuation_pc;
		 this.backTrack = backTrack;
	 }
	 REProgState previous;
	 int min;
	 int max;
	 int index;
	 int continuation_op;
	 int continuation_pc;
	 REBackTrackData backTrack;
 }
class REBackTrackData {
	 REBackTrackData(REGlobalData gData, int op, int pc) {
		 previous = gData.backTrackStackTop;
		 continuation_op = op;
		 continuation_pc = pc;
		 lastParen = gData.lastParen;
		 if (gData.parens != null) {
			 parens = (long[])gData.parens.clone();
		 }
		 cp = gData.cp;
		 stateStackTop = gData.stateStackTop;
	 }
	 REBackTrackData previous;
	 int continuation_op;
	 int continuation_pc;
	 int lastParen;
	 long[] parens;
	 int cp;
	 REProgState stateStackTop;
 }
class REGlobalData {
	 boolean multiline;
	 RECompiled regexp;
	 int lastParen;
	 int skipped;
	 int cp;
	 long[] parens;
	 REProgState stateStackTop;
	 REBackTrackData backTrackStackTop;
	 int parens_index(int i) {
		 return (int)(parens[i]);
	 }
	 int parens_length(int i) {
		 return (int)(parens[i] >>> 32);
	 }
	 void set_parens(int i, int index, int length) {
		 parens[i] = ((long)index & 0xffffffffL) | ((long)length << 32);
	 }
}
final class RECharSet implements Serializable{
	 RECharSet(int length, int startIndex, int strlength) {
		 this.length = length;
		 this.startIndex = startIndex;
		 this.strlength = strlength;
	 }
	 int length;
	 int startIndex;
	 int strlength;
	 volatile transient boolean converted;
	 volatile transient boolean sense;
	 volatile transient byte[] bits;
}",1,0,0,0
"public class Parser{
	 final static int CLEAR_TI_MASK = 0xFFFF, TI_AFTER_EOL = 1 << 16, TI_CHECK_LABEL = 1 << 17;
	 CompilerEnvirons compilerEnv;
	 private ErrorReporter errorReporter;
	 private String sourceURI;
	 private TokenStream ts;
	 private int currentFlaggedToken;
	 private int syntaxErrorCount;
	 private IRFactory nf;
	 private int nestingOfFunction;
	 private Decompiler decompiler;
	 private String encodedSource;
	 ScriptOrFnNode currentScriptOrFn;
	 private int nestingOfWith;
	 private Hashtable labelSet;
	 private ObjArray loopSet;
	 private ObjArray loopAndSwitchSet;
	 private static class ParserException extends RuntimeException {
	 }
	 public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {
		 this.compilerEnv = compilerEnv;
		 this.errorReporter = errorReporter;
	 }
	 protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {
		 return new Decompiler();
	 }
	 void addWarning(String messageId, String messageArg) {
		 String message = ScriptRuntime.getMessage1(messageId, messageArg);
		 errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 void addError(String messageId) {
		 ++syntaxErrorCount;
		 String message = ScriptRuntime.getMessage0(messageId);
		 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 RuntimeException reportError(String messageId) {
		 addError(messageId);
		 throw new ParserException();
	 }
	 private int peekToken() throws IOException {
		 int tt = currentFlaggedToken;
		 if (tt == Token.EOF) {
			 tt = ts.getToken();
			 if (tt == Token.EOL) {
				 do {
					 tt = ts.getToken();
				 }
				 while (tt == Token.EOL);
				 tt |= TI_AFTER_EOL;
			 }
			 currentFlaggedToken = tt;
		 }
		 return tt & CLEAR_TI_MASK;
	 }
	 private int peekFlaggedToken() throws IOException {
		 peekToken();
		 return currentFlaggedToken;
	 }
	 private void consumeToken() {
		 currentFlaggedToken = Token.EOF;
	 }
	 private int nextToken() throws IOException {
		 int tt = peekToken();
		 consumeToken();
		 return tt;
	 }
	 private int nextFlaggedToken() throws IOException {
		 peekToken();
		 int ttFlagged = currentFlaggedToken;
		 consumeToken();
		 return ttFlagged;
	 }
	 private boolean matchToken(int toMatch) throws IOException {
		 int tt = peekToken();
		 if (tt != toMatch) {
			 return false;
		 }
		 consumeToken();
		 return true;
	 }
	 private int peekTokenOrEOL() throws IOException {
		 int tt = peekToken();
		 if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {
			 tt = Token.EOL;
		 }
		 return tt;
	 }
	 private void setCheckForLabel() {
		 if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME) throw Kit.codeBug();
		 currentFlaggedToken |= TI_CHECK_LABEL;
	 }
	 private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {
		 if (!matchToken(toMatch)) {
			 reportError(messageId);
		 }
	 }
	 private void mustHaveXML() {
		 if (!compilerEnv.isXmlAvailable()) {
			 reportError(""msg.XML.not.available"");
		 }
	 }
	 public String getEncodedSource() {
		 return encodedSource;
	 }
	 public boolean eof() {
		 return ts.eof();
	 }
	 boolean insideFunction() {
		 return nestingOfFunction != 0;
	 }
	 private Node enterLoop(Node loopLabel) {
		 Node loop = nf.createLoopNode(loopLabel, ts.getLineno());
		 if (loopSet == null) {
			 loopSet = new ObjArray();
			 if (loopAndSwitchSet == null) {
				 loopAndSwitchSet = new ObjArray();
			 }
		 }
		 loopSet.push(loop);
		 loopAndSwitchSet.push(loop);
		 return loop;
	 }
	 private void exitLoop() {
		 loopSet.pop();
		 loopAndSwitchSet.pop();
	 }
	 private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel) {
		 Node switchNode = nf.createSwitch(switchSelector, lineno);
		 if (loopAndSwitchSet == null) {
			 loopAndSwitchSet = new ObjArray();
		 }
		 loopAndSwitchSet.push(switchNode);
		 return switchNode;
	 }
	 private void exitSwitch() {
		 loopAndSwitchSet.pop();
	 }
	 public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, null, sourceString, lineno);
		 try {
			 return parse();
		 }
		 catch (IOException ex) {
			 throw new IllegalStateException();
		 }
	 }
	 public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, sourceReader, null, lineno);
		 return parse();
	 }
	 private ScriptOrFnNode parse() throws IOException {
		 this.decompiler = createDecompiler(compilerEnv);
		 this.nf = new IRFactory(this);
		 currentScriptOrFn = nf.createScript();
		 int sourceStartOffset = decompiler.getCurrentOffset();
		 this.encodedSource = null;
		 decompiler.addToken(Token.SCRIPT);
		 this.currentFlaggedToken = Token.EOF;
		 this.syntaxErrorCount = 0;
		 int baseLineno = ts.getLineno();
		 Node pn = nf.createLeaf(Token.BLOCK);
		 try {
			 for (;
			;
			) {
				 int tt = peekToken();
				 if (tt <= Token.EOF) {
					 break;
				 }
				 Node n;
				 if (tt == Token.FUNCTION) {
					 consumeToken();
					 try {
						 n = function(FunctionNode.FUNCTION_STATEMENT);
					 }
					 catch (ParserException e) {
						 break;
					 }
				 }
				 else {
					 n = statement();
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (StackOverflowError ex) {
			 String msg = ScriptRuntime.getMessage0( ""mag.too.deep.parser.recursion"");
			 throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);
		 }
		 if (this.syntaxErrorCount != 0) {
			 String msg = String.valueOf(this.syntaxErrorCount);
			 msg = ScriptRuntime.getMessage1(""msg.got.syntax.errors"", msg);
			 throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);
		 }
		 currentScriptOrFn.setSourceName(sourceURI);
		 currentScriptOrFn.setBaseLineno(baseLineno);
		 currentScriptOrFn.setEndLineno(ts.getLineno());
		 int sourceEndOffset = decompiler.getCurrentOffset();
		 currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);
		 nf.initScript(currentScriptOrFn, pn);
		 if (compilerEnv.isGeneratingSource()) {
			 encodedSource = decompiler.getEncodedSource();
		 }
		 this.decompiler = null;
		 return currentScriptOrFn;
	 }
	 private Node parseFunctionBody() throws IOException {
		 ++nestingOfFunction;
		 Node pn = nf.createBlock(ts.getLineno());
		 try {
			 bodyLoop: for (;
			;
			) {
				 Node n;
				 int tt = peekToken();
				 switch (tt) {
					 case Token.ERROR: case Token.EOF: case Token.RC: break bodyLoop;
					 case Token.FUNCTION: consumeToken();
					 n = function(FunctionNode.FUNCTION_STATEMENT);
					 break;
					 default: n = statement();
					 break;
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (ParserException e) {
		 }
		 finally {
			 --nestingOfFunction;
		 }
		 return pn;
	 }
	 private Node function(int functionType) throws IOException, ParserException {
		 int syntheticType = functionType;
		 int baseLineno = ts.getLineno();
		 int functionSourceStart = decompiler.markFunctionStart(functionType);
		 String name;
		 Node memberExprNode = null;
		 if (matchToken(Token.NAME)) {
			 name = ts.getString();
			 decompiler.addName(name);
			 if (!matchToken(Token.LP)) {
				 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
					 Node memberExprHead = nf.createName(name);
					 name = """";
					 memberExprNode = memberExprTail(false, memberExprHead);
				 }
				 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
			 }
		 }
		 else if (matchToken(Token.LP)) {
			 name = """";
		 }
		 else {
			 name = """";
			 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
				 memberExprNode = memberExpr(false);
			 }
			 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
		 }
		 if (memberExprNode != null) {
			 syntheticType = FunctionNode.FUNCTION_EXPRESSION;
		 }
		 boolean nested = insideFunction();
		 FunctionNode fnNode = nf.createFunction(name);
		 if (nested || nestingOfWith > 0) {
			 fnNode.itsIgnoreDynamicScope = true;
		 }
		 int functionIndex = currentScriptOrFn.addFunction(fnNode);
		 int functionSourceEnd;
		 ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;
		 currentScriptOrFn = fnNode;
		 int savedNestingOfWith = nestingOfWith;
		 nestingOfWith = 0;
		 Hashtable savedLabelSet = labelSet;
		 labelSet = null;
		 ObjArray savedLoopSet = loopSet;
		 loopSet = null;
		 ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;
		 loopAndSwitchSet = null;
		 Node body;
		 String source;
		 try {
			 decompiler.addToken(Token.LP);
			 if (!matchToken(Token.RP)) {
				 boolean first = true;
				 do {
					 if (!first) decompiler.addToken(Token.COMMA);
					 first = false;
					 mustMatchToken(Token.NAME, ""msg.no.parm"");
					 String s = ts.getString();
					 if (fnNode.hasParamOrVar(s)) {
						 addWarning(""msg.dup.parms"", s);
					 }
					 fnNode.addParam(s);
					 decompiler.addName(s);
				 }
				 while (matchToken(Token.COMMA));
				 mustMatchToken(Token.RP, ""msg.no.paren.after.parms"");
			 }
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.LC, ""msg.no.brace.body"");
			 decompiler.addEOL(Token.LC);
			 body = parseFunctionBody();
			 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
			 decompiler.addToken(Token.RC);
			 functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {
					 int tt = peekTokenOrEOL();
					 if (tt == Token.FUNCTION) {
						 reportError(""msg.no.semi.stmt"");
					 }
				 }
				 decompiler.addToken(Token.EOL);
			 }
		 }
		 finally {
			 loopAndSwitchSet = savedLoopAndSwitchSet;
			 loopSet = savedLoopSet;
			 labelSet = savedLabelSet;
			 nestingOfWith = savedNestingOfWith;
			 currentScriptOrFn = savedScriptOrFn;
		 }
		 fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);
		 fnNode.setSourceName(sourceURI);
		 fnNode.setBaseLineno(baseLineno);
		 fnNode.setEndLineno(ts.getLineno());
		 Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
		 if (memberExprNode != null) {
			 pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
			 pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 pn = nf.createExprStatementNoReturn(pn, baseLineno);
			 }
		 }
		 return pn;
	 }
	 private Node statements() throws IOException {
		 Node pn = nf.createBlock(ts.getLineno());
		 int tt;
		 while((tt = peekToken()) > Token.EOF && tt != Token.RC) {
			 nf.addChildToBack(pn, statement());
		 }
		 return pn;
	 }
	 private Node condition() throws IOException, ParserException {
		 Node pn;
		 mustMatchToken(Token.LP, ""msg.no.paren.cond"");
		 decompiler.addToken(Token.LP);
		 pn = expr(false);
		 mustMatchToken(Token.RP, ""msg.no.paren.after.cond"");
		 decompiler.addToken(Token.RP);
		 return pn;
	 }
	 private Node matchJumpLabelName() throws IOException, ParserException {
		 Node label = null;
		 int tt = peekTokenOrEOL();
		 if (tt == Token.NAME) {
			 consumeToken();
			 String name = ts.getString();
			 decompiler.addName(name);
			 if (labelSet != null) {
				 label = (Node)labelSet.get(name);
			 }
			 if (label == null) {
				 reportError(""msg.undef.label"");
			 }
		 }
		 return label;
	 }
	 private Node statement() throws IOException {
		 try {
			 Node pn = statementHelper(null);
			 if (pn != null) {
				 return pn;
			 }
		 }
		 catch (ParserException e) {
		 }
		 int lineno = ts.getLineno();
		 guessingStatementEnd: for (;
		;
		) {
			 int tt = peekTokenOrEOL();
			 consumeToken();
			 switch (tt) {
				 case Token.ERROR: case Token.EOF: case Token.EOL: case Token.SEMI: break guessingStatementEnd;
			 }
		 }
		 return nf.createExprStatement(nf.createName(""error""), lineno);
	 }
	 private Node statementHelper(Node statementLabel) throws IOException, ParserException {
		 Node pn = null;
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.IF: {
				 consumeToken();
				 decompiler.addToken(Token.IF);
				 int lineno = ts.getLineno();
				 Node cond = condition();
				 decompiler.addEOL(Token.LC);
				 Node ifTrue = statement();
				 Node ifFalse = null;
				 if (matchToken(Token.ELSE)) {
					 decompiler.addToken(Token.RC);
					 decompiler.addToken(Token.ELSE);
					 decompiler.addEOL(Token.LC);
					 ifFalse = statement();
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createIf(cond, ifTrue, ifFalse, lineno);
				 return pn;
			 }
			 case Token.SWITCH: {
				 consumeToken();
				 decompiler.addToken(Token.SWITCH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.switch"");
				 decompiler.addToken(Token.LP);
				 pn = enterSwitch(expr(false), lineno, statementLabel);
				 try {
					 mustMatchToken(Token.RP, ""msg.no.paren.after.switch"");
					 decompiler.addToken(Token.RP);
					 mustMatchToken(Token.LC, ""msg.no.brace.switch"");
					 decompiler.addEOL(Token.LC);
					 boolean hasDefault = false;
					 switchLoop: for (;
					;
					) {
						 tt = nextToken();
						 Node caseExpression;
						 switch (tt) {
							 case Token.RC: break switchLoop;
							 case Token.CASE: decompiler.addToken(Token.CASE);
							 caseExpression = expr(false);
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 case Token.DEFAULT: if (hasDefault) {
								 reportError(""msg.double.switch.default"");
							 }
							 decompiler.addToken(Token.DEFAULT);
							 hasDefault = true;
							 caseExpression = null;
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 default: reportError(""msg.bad.switch"");
							 break switchLoop;
						 }
						 Node block = nf.createLeaf(Token.BLOCK);
						 while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {
							 nf.addChildToBack(block, statement());
						 }
						 nf.addSwitchCase(pn, caseExpression, block);
					 }
					 decompiler.addEOL(Token.RC);
					 nf.closeSwitch(pn);
				 }
				 finally {
					 exitSwitch();
				 }
				 return pn;
			 }
			 case Token.WHILE: {
				 consumeToken();
				 decompiler.addToken(Token.WHILE);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node cond = condition();
					 decompiler.addEOL(Token.LC);
					 Node body = statement();
					 decompiler.addEOL(Token.RC);
					 pn = nf.createWhile(loop, cond, body);
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.DO: {
				 consumeToken();
				 decompiler.addToken(Token.DO);
				 decompiler.addEOL(Token.LC);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node body = statement();
					 decompiler.addToken(Token.RC);
					 mustMatchToken(Token.WHILE, ""msg.no.while.do"");
					 decompiler.addToken(Token.WHILE);
					 Node cond = condition();
					 pn = nf.createDoWhile(loop, body, cond);
				 }
				 finally {
					 exitLoop();
				 }
				 matchToken(Token.SEMI);
				 decompiler.addEOL(Token.SEMI);
				 return pn;
			 }
			 case Token.FOR: {
				 consumeToken();
				 boolean isForEach = false;
				 decompiler.addToken(Token.FOR);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node init;
					 Node cond;
					 Node incr = null;
					 Node body;
					 if (matchToken(Token.NAME)) {
						 decompiler.addName(ts.getString());
						 if (ts.getString().equals(""each"")) {
							 isForEach = true;
						 }
						 else {
							 reportError(""msg.no.paren.for"");
						 }
					 }
					 mustMatchToken(Token.LP, ""msg.no.paren.for"");
					 decompiler.addToken(Token.LP);
					 tt = peekToken();
					 if (tt == Token.SEMI) {
						 init = nf.createLeaf(Token.EMPTY);
					 }
					 else {
						 if (tt == Token.VAR) {
							 consumeToken();
							 init = variables(true);
						 }
						 else {
							 init = expr(true);
						 }
					 }
					 if (matchToken(Token.IN)) {
						 decompiler.addToken(Token.IN);
						 cond = expr(false);
					 }
					 else {
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.SEMI) {
							 cond = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 cond = expr(false);
						 }
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for.cond"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.RP) {
							 incr = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 incr = expr(false);
						 }
					 }
					 mustMatchToken(Token.RP, ""msg.no.paren.for.ctrl"");
					 decompiler.addToken(Token.RP);
					 decompiler.addEOL(Token.LC);
					 body = statement();
					 decompiler.addEOL(Token.RC);
					 if (incr == null) {
						 pn = nf.createForIn(loop, init, cond, body, isForEach);
					 }
					 else {
						 pn = nf.createFor(loop, init, cond, incr, body);
					 }
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.TRY: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 Node tryblock;
				 Node catchblocks = null;
				 Node finallyblock = null;
				 decompiler.addToken(Token.TRY);
				 decompiler.addEOL(Token.LC);
				 tryblock = statement();
				 decompiler.addEOL(Token.RC);
				 catchblocks = nf.createLeaf(Token.BLOCK);
				 boolean sawDefaultCatch = false;
				 int peek = peekToken();
				 if (peek == Token.CATCH) {
					 while (matchToken(Token.CATCH)) {
						 if (sawDefaultCatch) {
							 reportError(""msg.catch.unreachable"");
						 }
						 decompiler.addToken(Token.CATCH);
						 mustMatchToken(Token.LP, ""msg.no.paren.catch"");
						 decompiler.addToken(Token.LP);
						 mustMatchToken(Token.NAME, ""msg.bad.catchcond"");
						 String varName = ts.getString();
						 decompiler.addName(varName);
						 Node catchCond = null;
						 if (matchToken(Token.IF)) {
							 decompiler.addToken(Token.IF);
							 catchCond = expr(false);
						 }
						 else {
							 sawDefaultCatch = true;
						 }
						 mustMatchToken(Token.RP, ""msg.bad.catchcond"");
						 decompiler.addToken(Token.RP);
						 mustMatchToken(Token.LC, ""msg.no.brace.catchblock"");
						 decompiler.addEOL(Token.LC);
						 nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(), ts.getLineno()));
						 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
						 decompiler.addEOL(Token.RC);
					 }
				 }
				 else if (peek != Token.FINALLY) {
					 mustMatchToken(Token.FINALLY, ""msg.try.no.catchfinally"");
				 }
				 if (matchToken(Token.FINALLY)) {
					 decompiler.addToken(Token.FINALLY);
					 decompiler.addEOL(Token.LC);
					 finallyblock = statement();
					 decompiler.addEOL(Token.RC);
				 }
				 pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);
				 return pn;
			 }
			 case Token.THROW: {
				 consumeToken();
				 if (peekTokenOrEOL() == Token.EOL) {
					 reportError(""msg.bad.throw.eol"");
				 }
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.THROW);
				 pn = nf.createThrow(expr(false), lineno);
				 break;
			 }
			 case Token.BREAK: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.BREAK);
				 Node breakStatement = matchJumpLabelName();
				 if (breakStatement == null) {
					 if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {
						 reportError(""msg.bad.break"");
						 return null;
					 }
					 breakStatement = (Node)loopAndSwitchSet.peek();
				 }
				 pn = nf.createBreak(breakStatement, lineno);
				 break;
			 }
			 case Token.CONTINUE: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.CONTINUE);
				 Node loop;
				 Node label = matchJumpLabelName();
				 if (label == null) {
					 if (loopSet == null || loopSet.size() == 0) {
						 reportError(""msg.continue.outside"");
						 return null;
					 }
					 loop = (Node)loopSet.peek();
				 }
				 else {
					 loop = nf.getLabelLoop(label);
					 if (loop == null) {
						 reportError(""msg.continue.nonloop"");
						 return null;
					 }
				 }
				 pn = nf.createContinue(loop, lineno);
				 break;
			 }
			 case Token.WITH: {
				 consumeToken();
				 decompiler.addToken(Token.WITH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.with"");
				 decompiler.addToken(Token.LP);
				 Node obj = expr(false);
				 mustMatchToken(Token.RP, ""msg.no.paren.after.with"");
				 decompiler.addToken(Token.RP);
				 decompiler.addEOL(Token.LC);
				 ++nestingOfWith;
				 Node body;
				 try {
					 body = statement();
				 }
				 finally {
					 --nestingOfWith;
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createWith(obj, body, lineno);
				 return pn;
			 }
			 case Token.VAR: {
				 consumeToken();
				 pn = variables(false);
				 break;
			 }
			 case Token.RETURN: {
				 if (!insideFunction()) {
					 reportError(""msg.bad.return"");
				 }
				 consumeToken();
				 decompiler.addToken(Token.RETURN);
				 int lineno = ts.getLineno();
				 Node retExpr;
				 tt = peekTokenOrEOL();
				 switch (tt) {
					 case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null;
					 break;
					 default: retExpr = expr(false);
				 }
				 pn = nf.createReturn(retExpr, lineno);
				 break;
			 }
			 case Token.LC: consumeToken();
			 if (statementLabel != null) {
				 decompiler.addToken(Token.LC);
			 }
			 pn = statements();
			 mustMatchToken(Token.RC, ""msg.no.brace.block"");
			 if (statementLabel != null) {
				 decompiler.addEOL(Token.RC);
			 }
			 return pn;
			 case Token.ERROR: case Token.SEMI: consumeToken();
			 pn = nf.createLeaf(Token.EMPTY);
			 return pn;
			 case Token.FUNCTION: {
				 consumeToken();
				 pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);
				 return pn;
			 }
			 case Token.DEFAULT : consumeToken();
			 mustHaveXML();
			 decompiler.addToken(Token.DEFAULT);
			 int nsLine = ts.getLineno();
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""xml""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""namespace""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName(ts.getString());
			 if (!matchToken(Token.ASSIGN)) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addToken(Token.ASSIGN);
			 Node expr = expr(false);
			 pn = nf.createDefaultNamespace(expr, nsLine);
			 break;
			 case Token.NAME: {
				 int lineno = ts.getLineno();
				 String name = ts.getString();
				 setCheckForLabel();
				 pn = expr(false);
				 if (pn.getType() != Token.LABEL) {
					 pn = nf.createExprStatement(pn, lineno);
				 }
				 else {
					 if (peekToken() != Token.COLON) Kit.codeBug();
					 consumeToken();
					 decompiler.addName(name);
					 decompiler.addEOL(Token.COLON);
					 if (labelSet == null) {
						 labelSet = new Hashtable();
					 }
					 else if (labelSet.containsKey(name)) {
						 reportError(""msg.dup.label"");
					 }
					 boolean firstLabel;
					 if (statementLabel == null) {
						 firstLabel = true;
						 statementLabel = pn;
					 }
					 else {
						 firstLabel = false;
					 }
					 labelSet.put(name, statementLabel);
					 try {
						 pn = statementHelper(statementLabel);
					 }
					 finally {
						 labelSet.remove(name);
					 }
					 if (firstLabel) {
						 pn = nf.createLabeledStatement(statementLabel, pn);
					 }
					 return pn;
				 }
				 break;
			 }
			 default: {
				 int lineno = ts.getLineno();
				 pn = expr(false);
				 pn = nf.createExprStatement(pn, lineno);
				 break;
			 }
		 }
		 int ttFlagged = peekFlaggedToken();
		 switch (ttFlagged & CLEAR_TI_MASK) {
			 case Token.SEMI: consumeToken();
			 break;
			 case Token.ERROR: case Token.EOF: case Token.RC: break;
			 default: if ((ttFlagged & TI_AFTER_EOL) == 0) {
				 reportError(""msg.no.semi.stmt"");
			 }
			 break;
		 }
		 decompiler.addEOL(Token.SEMI);
		 return pn;
	 }
	 private Node variables(boolean inForInit) throws IOException, ParserException {
		 Node pn = nf.createVariables(ts.getLineno());
		 boolean first = true;
		 decompiler.addToken(Token.VAR);
		 for (;
		;
		) {
			 Node name;
			 Node init;
			 mustMatchToken(Token.NAME, ""msg.bad.var"");
			 String s = ts.getString();
			 if (!first) decompiler.addToken(Token.COMMA);
			 first = false;
			 decompiler.addName(s);
			 currentScriptOrFn.addVar(s);
			 name = nf.createName(s);
			 if (matchToken(Token.ASSIGN)) {
				 decompiler.addToken(Token.ASSIGN);
				 init = assignExpr(inForInit);
				 nf.addChildToBack(name, init);
			 }
			 nf.addChildToBack(pn, name);
			 if (!matchToken(Token.COMMA)) break;
		 }
		 return pn;
	 }
	 private Node expr(boolean inForInit) throws IOException, ParserException {
		 Node pn = assignExpr(inForInit);
		 while (matchToken(Token.COMMA)) {
			 decompiler.addToken(Token.COMMA);
			 pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node assignExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = condExpr(inForInit);
		 int tt = peekToken();
		 if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
			 consumeToken();
			 decompiler.addToken(tt);
			 pn = nf.createAssignment(tt, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node condExpr(boolean inForInit) throws IOException, ParserException {
		 Node ifTrue;
		 Node ifFalse;
		 Node pn = orExpr(inForInit);
		 if (matchToken(Token.HOOK)) {
			 decompiler.addToken(Token.HOOK);
			 ifTrue = assignExpr(false);
			 mustMatchToken(Token.COLON, ""msg.no.colon.cond"");
			 decompiler.addToken(Token.COLON);
			 ifFalse = assignExpr(inForInit);
			 return nf.createCondExpr(pn, ifTrue, ifFalse);
		 }
		 return pn;
	 }
	 private Node orExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = andExpr(inForInit);
		 if (matchToken(Token.OR)) {
			 decompiler.addToken(Token.OR);
			 pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node andExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitOrExpr(inForInit);
		 if (matchToken(Token.AND)) {
			 decompiler.addToken(Token.AND);
			 pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitXorExpr(inForInit);
		 while (matchToken(Token.BITOR)) {
			 decompiler.addToken(Token.BITOR);
			 pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitAndExpr(inForInit);
		 while (matchToken(Token.BITXOR)) {
			 decompiler.addToken(Token.BITXOR);
			 pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = eqExpr(inForInit);
		 while (matchToken(Token.BITAND)) {
			 decompiler.addToken(Token.BITAND);
			 pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node eqExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = relExpr(inForInit);
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: consumeToken();
				 int decompilerToken = tt;
				 int parseToken = tt;
				 if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
					 switch (tt) {
						 case Token.EQ: parseToken = Token.SHEQ;
						 break;
						 case Token.NE: parseToken = Token.SHNE;
						 break;
						 case Token.SHEQ: decompilerToken = Token.EQ;
						 break;
						 case Token.SHNE: decompilerToken = Token.NE;
						 break;
					 }
				 }
				 decompiler.addToken(decompilerToken);
				 pn = nf.createBinary(parseToken, pn, relExpr(inForInit));
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node relExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = shiftExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.IN: if (inForInit) break;
				 case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, shiftExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node shiftExpr() throws IOException, ParserException {
		 Node pn = addExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.LSH: case Token.URSH: case Token.RSH: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, addExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node addExpr() throws IOException, ParserException {
		 Node pn = mulExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 if (tt == Token.ADD || tt == Token.SUB) {
				 consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, mulExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node mulExpr() throws IOException, ParserException {
		 Node pn = unaryExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.MUL: case Token.DIV: case Token.MOD: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, unaryExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node unaryExpr() throws IOException, ParserException {
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createUnary(tt, unaryExpr());
			 case Token.ADD: consumeToken();
			 decompiler.addToken(Token.POS);
			 return nf.createUnary(Token.POS, unaryExpr());
			 case Token.SUB: consumeToken();
			 decompiler.addToken(Token.NEG);
			 return nf.createUnary(Token.NEG, unaryExpr());
			 case Token.INC: case Token.DEC: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createIncDec(tt, false, memberExpr(true));
			 case Token.DELPROP: consumeToken();
			 decompiler.addToken(Token.DELPROP);
			 return nf.createUnary(Token.DELPROP, unaryExpr());
			 case Token.ERROR: consumeToken();
			 break;
			 case Token.LT: if (compilerEnv.isXmlAvailable()) {
				 consumeToken();
				 Node pn = xmlInitializer();
				 return memberExprTail(true, pn);
			 }
			 default: Node pn = memberExpr(true);
			 tt = peekTokenOrEOL();
			 if (tt == Token.INC || tt == Token.DEC) {
				 consumeToken();
				 decompiler.addToken(tt);
				 return nf.createIncDec(tt, true, pn);
			 }
			 return pn;
		 }
		 return nf.createName(""err"");
	 }
	 private Node xmlInitializer() throws IOException {
		 int tt = ts.getFirstXMLToken();
		 if (tt != Token.XML && tt != Token.XMLEND) {
			 reportError(""msg.syntax"");
			 return null;
		 }
		 Node pnXML = nf.createLeaf(Token.NEW);
		 decompiler.addToken(Token.NEW);
		 decompiler.addToken(Token.DOT);
		 String xml = ts.getString();
		 boolean fAnonymous = xml.trim().startsWith(""<>"");
		 decompiler.addName(fAnonymous ? ""XMLList"" : ""XML"");
		 Node pn = nf.createName(fAnonymous ? ""XMLList"" : ""XML"");
		 nf.addChildToBack(pnXML, pn);
		 pn = null;
		 Node expr;
		 for (;
		;
		tt = ts.getNextXMLToken()) {
			 switch (tt) {
				 case Token.XML: xml = ts.getString();
				 decompiler.addString(xml);
				 mustMatchToken(Token.LC, ""msg.syntax"");
				 decompiler.addToken(Token.LC);
				 expr = (peekToken() == Token.RC) ? nf.createString("""") : expr(false);
				 mustMatchToken(Token.RC, ""msg.syntax"");
				 decompiler.addToken(Token.RC);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 int nodeType;
				 if (ts.isXMLAttribute()) {
					 nodeType = Token.ESCXMLATTR;
				 }
				 else {
					 nodeType = Token.ESCXMLTEXT;
				 }
				 expr = nf.createUnary(nodeType, expr);
				 pn = nf.createBinary(Token.ADD, pn, expr);
				 break;
				 case Token.XMLEND: xml = ts.getString();
				 decompiler.addString(xml);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 nf.addChildToBack(pnXML, pn);
				 return pnXML;
				 default: reportError(""msg.syntax"");
				 return null;
			 }
		 }
	 }
	 private void argumentList(Node listNode) throws IOException, ParserException {
		 boolean matched;
		 matched = matchToken(Token.RP);
		 if (!matched) {
			 boolean first = true;
			 do {
				 if (!first) decompiler.addToken(Token.COMMA);
				 first = false;
				 nf.addChildToBack(listNode, assignExpr(false));
			 }
			 while (matchToken(Token.COMMA));
			 mustMatchToken(Token.RP, ""msg.no.paren.arg"");
		 }
		 decompiler.addToken(Token.RP);
	 }
	 private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {
		 int tt;
		 Node pn;
		 tt = peekToken();
		 if (tt == Token.NEW) {
			 consumeToken();
			 decompiler.addToken(Token.NEW);
			 pn = nf.createCallOrNew(Token.NEW, memberExpr(false));
			 if (matchToken(Token.LP)) {
				 decompiler.addToken(Token.LP);
				 argumentList(pn);
			 }
			 tt = peekToken();
			 if (tt == Token.LC) {
				 nf.addChildToBack(pn, primaryExpr());
			 }
		 }
		 else {
			 pn = primaryExpr();
		 }
		 return memberExprTail(allowCallSyntax, pn);
	 }
	 private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {
		 tailLoop: for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.DOT: case Token.DOTDOT: {
					 int memberTypeFlags;
					 String s;
					 consumeToken();
					 decompiler.addToken(tt);
					 memberTypeFlags = 0;
					 if (tt == Token.DOTDOT) {
						 mustHaveXML();
						 memberTypeFlags = Node.DESCENDANTS_FLAG;
					 }
					 if (!compilerEnv.isXmlAvailable()) {
						 mustMatchToken(Token.NAME, ""msg.no.name.after.dot"");
						 s = ts.getString();
						 decompiler.addName(s);
						 pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);
						 break;
					 }
					 tt = nextToken();
					 switch (tt) {
						 case Token.NAME: s = ts.getString();
						 decompiler.addName(s);
						 pn = propertyName(pn, s, memberTypeFlags);
						 break;
						 case Token.MUL: decompiler.addName(""*"");
						 pn = propertyName(pn, ""*"", memberTypeFlags);
						 break;
						 case Token.XMLATTR: decompiler.addToken(Token.XMLATTR);
						 pn = attributeAccess(pn, memberTypeFlags);
						 break;
						 default: reportError(""msg.no.name.after.dot"");
					 }
				 }
				 break;
				 case Token.DOTQUERY: consumeToken();
				 mustHaveXML();
				 decompiler.addToken(Token.DOTQUERY);
				 pn = nf.createDotQuery(pn, expr(false), ts.getLineno());
				 mustMatchToken(Token.RP, ""msg.no.paren"");
				 break;
				 case Token.LB: consumeToken();
				 decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, null, expr(false), 0);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 break;
				 case Token.LP: if (!allowCallSyntax) {
					 break tailLoop;
				 }
				 consumeToken();
				 decompiler.addToken(Token.LP);
				 pn = nf.createCallOrNew(Token.CALL, pn);
				 argumentList(pn);
				 break;
				 default: break tailLoop;
			 }
		 }
		 return pn;
	 }
	 private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {
		 memberTypeFlags |= Node.ATTRIBUTE_FLAG;
		 int tt = nextToken();
		 switch (tt) {
			 case Token.NAME: {
				 String s = ts.getString();
				 decompiler.addName(s);
				 pn = propertyName(pn, s, memberTypeFlags);
			 }
			 break;
			 case Token.MUL: decompiler.addName(""*"");
			 pn = propertyName(pn, ""*"", memberTypeFlags);
			 break;
			 case Token.LB: decompiler.addToken(Token.LB);
			 pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);
			 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
			 decompiler.addToken(Token.RB);
			 break;
			 default: reportError(""msg.no.name.after.xmlAttr"");
			 pn = nf.createPropertyGet(pn, null, ""?"", memberTypeFlags);
			 break;
		 }
		 return pn;
	 }
	 private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {
		 String namespace = null;
		 if (matchToken(Token.COLONCOLON)) {
			 decompiler.addToken(Token.COLONCOLON);
			 namespace = name;
			 int tt = nextToken();
			 switch (tt) {
				 case Token.NAME: name = ts.getString();
				 decompiler.addName(name);
				 break;
				 case Token.MUL: decompiler.addName(""*"");
				 name = ""*"";
				 break;
				 case Token.LB: decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 return pn;
				 default: reportError(""msg.no.name.after.coloncolon"");
				 name = ""?"";
			 }
		 }
		 pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);
		 return pn;
	 }
	 private Node primaryExpr() throws IOException, ParserException {
		 Node pn;
		 int ttFlagged = nextFlaggedToken();
		 int tt = ttFlagged & CLEAR_TI_MASK;
		 switch(tt) {
			 case Token.FUNCTION: return function(FunctionNode.FUNCTION_EXPRESSION);
			 case Token.LB: {
				 ObjArray elems = new ObjArray();
				 int skipCount = 0;
				 decompiler.addToken(Token.LB);
				 boolean after_lb_or_comma = true;
				 for (;
				;
				) {
					 tt = peekToken();
					 if (tt == Token.COMMA) {
						 consumeToken();
						 decompiler.addToken(Token.COMMA);
						 if (!after_lb_or_comma) {
							 after_lb_or_comma = true;
						 }
						 else {
							 elems.add(null);
							 ++skipCount;
						 }
					 }
					 else if (tt == Token.RB) {
						 consumeToken();
						 decompiler.addToken(Token.RB);
						 break;
					 }
					 else {
						 if (!after_lb_or_comma) {
							 reportError(""msg.no.bracket.arg"");
						 }
						 elems.add(assignExpr(false));
						 after_lb_or_comma = false;
					 }
				 }
				 return nf.createArrayLiteral(elems, skipCount);
			 }
			 case Token.LC: {
				 ObjArray elems = new ObjArray();
				 decompiler.addToken(Token.LC);
				 if (!matchToken(Token.RC)) {
					 boolean first = true;
					 commaloop: do {
						 Object property;
						 if (!first) decompiler.addToken(Token.COMMA);
						 else first = false;
						 tt = peekToken();
						 switch(tt) {
							 case Token.NAME: case Token.STRING: consumeToken();
							 String s = ts.getString();
							 if (tt == Token.NAME) {
								 decompiler.addName(s);
							 }
							 else {
								 decompiler.addString(s);
							 }
							 property = ScriptRuntime.getIndexObject(s);
							 break;
							 case Token.NUMBER: consumeToken();
							 double n = ts.getNumber();
							 decompiler.addNumber(n);
							 property = ScriptRuntime.getIndexObject(n);
							 break;
							 case Token.RC: break commaloop;
							 default: reportError(""msg.bad.prop"");
							 break commaloop;
						 }
						 mustMatchToken(Token.COLON, ""msg.no.colon.prop"");
						 decompiler.addToken(Token.OBJECTLIT);
						 elems.add(property);
						 elems.add(assignExpr(false));
					 }
					 while (matchToken(Token.COMMA));
					 mustMatchToken(Token.RC, ""msg.no.brace.prop"");
				 }
				 decompiler.addToken(Token.RC);
				 return nf.createObjectLiteral(elems);
			 }
			 case Token.LP: decompiler.addToken(Token.LP);
			 pn = expr(false);
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.RP, ""msg.no.paren"");
			 return pn;
			 case Token.XMLATTR: mustHaveXML();
			 decompiler.addToken(Token.XMLATTR);
			 pn = attributeAccess(null, 0);
			 return pn;
			 case Token.NAME: {
				 String name = ts.getString();
				 if ((ttFlagged & TI_CHECK_LABEL) != 0) {
					 if (peekToken() == Token.COLON) {
						 return nf.createLabel(ts.getLineno());
					 }
				 }
				 decompiler.addName(name);
				 if (compilerEnv.isXmlAvailable()) {
					 pn = propertyName(null, name, 0);
				 }
				 else {
					 pn = nf.createName(name);
				 }
				 return pn;
			 }
			 case Token.NUMBER: {
				 double n = ts.getNumber();
				 decompiler.addNumber(n);
				 return nf.createNumber(n);
			 }
			 case Token.STRING: {
				 String s = ts.getString();
				 decompiler.addString(s);
				 return nf.createString(s);
			 }
			 case Token.DIV: case Token.ASSIGN_DIV: {
				 ts.readRegExp(tt);
				 String flags = ts.regExpFlags;
				 ts.regExpFlags = null;
				 String re = ts.getString();
				 decompiler.addRegexp(re, flags);
				 int index = currentScriptOrFn.addRegexp(re, flags);
				 return nf.createRegExp(index);
			 }
			 case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: decompiler.addToken(tt);
			 return nf.createLeaf(tt);
			 case Token.RESERVED: reportError(""msg.reserved.id"");
			 break;
			 case Token.ERROR: break;
			 case Token.EOF: reportError(""msg.unexpected.eof"");
			 break;
			 default: reportError(""msg.syntax"");
			 break;
		 }
		 return null;
	 }
}",1,0,0,0
"public static Neuron createNeuron(NeuronProperties neuronProperties) {
	 InputFunction inputFunction = null;
	 Class inputFunctionClass = neuronProperties.getInputFunction();
	 if ( inputFunctionClass != null) {
		 inputFunction = createInputFunction(inputFunctionClass);
	 }
	TransferFunction transferFunction = createTransferFunction(neuronProperties.getTransferFunctionProperties());
	Neuron neuron = null;
	Class neuronClass = neuronProperties.getNeuronType();
	 try {
		 Class[] paramTypes = {
		InputFunction.class, TransferFunction.class}
		;
		 Constructor con = neuronClass.getConstructor(paramTypes);
		 Object[] paramList = new Object[2];
		 paramList[0] = inputFunction;
		 paramList[1] = transferFunction;
		 neuron = (Neuron) con.newInstance(paramList);
	 }
	 catch (NoSuchMethodException e) {
	 }
	 catch (InstantiationException e) {
		 throw new NeurophException(""InstantiationException while creating Neuron!"", e);
	 }
	 catch (IllegalAccessException e) {
		 throw new NeurophException(""IllegalAccessException while creating Neuron!"", e);
	 }
	 catch (InvocationTargetException e) {
		 throw new NeurophException(""InvocationTargetException while creating Neuron!"", e);
	 }
	 if (neuron == null) {
		 try {
			 neuron = (Neuron) neuronClass.newInstance();
		 }
		 catch(IllegalAccessException e) {
			 System.err.println(""InstantiationException while creating Neuron!"");
			 e.printStackTrace();
		 }
		 catch (InstantiationException e) {
			 System.err.println(""InstantiationException while creating Neuron!"");
			 e.printStackTrace();
		 }
	 }
	 if (neuronProperties.hasProperty(""thresh"")) {
		 ((ThresholdNeuron)neuron).setThresh((Double)neuronProperties.getProperty(""thresh""));
	 }
	 else if (neuronProperties.hasProperty(""bias"")) {
		 ((InputOutputNeuron)neuron).setBias((Double)neuronProperties.getProperty(""bias""));
	 }
	 return neuron;
 }",0,0,1,0
"public final void synpred200_InternalN4JSParser_fragment() throws RecognitionException {
	 {
		 {
			 {
				 {
					 pushFollow(FOLLOW_2);
					 ruleEqualityOperator();
					 state._fsp--;
					 if (state.failed) return ;
				 }
			 }
		 }
	 }
 }",0,0,1,0
"public class UpdatedExpressions {
	 private List<List<GroovyExpression>> updatedChildren = new ArrayList<>();
	 private boolean changed = false;
	 public UpdatedExpressions(boolean changed, List<List<GroovyExpression>> updatedChildren) {
		 this.changed = changed;
		 this.updatedChildren = updatedChildren;
	 }
	 public List<List<GroovyExpression>> getUpdatedChildren() {
		 return updatedChildren;
	 }
	 public boolean hasChanges() {
		 return changed;
	 }
}",0,0,0,0
"public void initCaches() {
	 long start = System.currentTimeMillis();
	 for (DecoratedKey key : rowCache.readSaved()) cacheRow(key);
	 if (rowCache.size() > 0) logger.info(String.format(""completed loading (%d ms;
	 %d keys) row cache for %s.%s"", System.currentTimeMillis()-start, rowCache.size(), table.name, columnFamily));
	 scheduleCacheSaving(metadata.getRowCacheSavePeriodInSeconds(), metadata.getKeyCacheSavePeriodInSeconds());
 }",0,0,0,0
"public class IdentityQueryFilter extends SliceQueryFilter{
	 public IdentityQueryFilter() {
		 super(ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, Integer.MAX_VALUE);
	 }
	 public SuperColumn filterSuperColumn(SuperColumn superColumn, int gcBefore) {
		 return superColumn;
	 }
}",0,0,0,0
"public class CheckstyleViolationCheckMojo extends AbstractMojo{
	 private static final String JAVA_FILES = ""**\\ private File outputFile;
	 private String outputFileFormat;
	 private boolean failOnViolation;
	 private int maxAllowedViolations;
	 private String violationSeverity = ""error"";
	 private String violationIgnore;
	 private boolean skip;
	 private boolean skipExec;
	 private boolean logViolationsToConsole;
	 protected List<Resource> resources;
	 protected List<Resource> testResources;
	 private String configLocation;
	 private String propertiesLocation;
	 private String propertyExpansion;
	 private String headerLocation;
	 private String cacheFile;
	 private String suppressionsFileExpression;
	 private String suppressionsLocation;
	 private String encoding;
	 protected CheckstyleExecutor checkstyleExecutor;
	 private boolean consoleOutput;
	 protected MavenProject project;
	 private PluginDescriptor plugin;
	 private File useFile;
	 private String excludes;
	 private String includes;
	 private String resourceExcludes;
	 private String resourceIncludes;
	 private boolean failsOnError;
	 private File testSourceDirectory;
	 private List<String> testSourceDirectories;
	 private boolean includeTestSourceDirectory;
	 private File sourceDirectory;
	 private List<String> sourceDirectories;
	 private boolean includeResources = true;
	 private boolean includeTestResources = true;
	 private PlexusConfiguration checkstyleRules;
	 private File rulesFiles;
	 private String checkstyleRulesHeader;
	 private boolean omitIgnoredModules;
	 private ByteArrayOutputStream stringOutputStream;
	 private File outputXmlFile;
	 public void execute() throws MojoExecutionException, MojoFailureException {
		 checkDeprecatedParameterUsage( sourceDirectory, ""sourceDirectory"", ""sourceDirectories"" );
		 checkDeprecatedParameterUsage( testSourceDirectory, ""testSourceDirectory"", ""testSourceDirectories"" );
		 if ( skip ) {
			 return;
		 }
		 outputXmlFile = outputFile;
		 if ( !skipExec ) {
			 if ( checkstyleRules != null ) {
				 if ( !DEFAULT_CONFIG_LOCATION.equals( configLocation ) ) {
					 throw new MojoExecutionException( ""If you use inline configuration for rules, don't specify "" + ""a configLocation"" );
				 }
				 if ( checkstyleRules.getChildCount() > 1 ) {
					 throw new MojoExecutionException( ""Currently only one root module is supported"" );
				 }
				 PlexusConfiguration checkerModule = checkstyleRules.getChild( 0 );
				 try {
					 FileUtils.forceMkdir( rulesFiles.getParentFile() );
					 FileUtils.fileWrite( rulesFiles, checkstyleRulesHeader + checkerModule.toString() );
				 }
				 catch ( final IOException e ) {
					 throw new MojoExecutionException( e.getMessage(), e );
				 }
				 configLocation = rulesFiles.getAbsolutePath();
			 }
			 ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
			 try {
				 CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();
				 request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput ) .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes ) .setResourceIncludes( resourceIncludes ) .setResourceExcludes( resourceExcludes ) .setIncludeResources( includeResources ) .setIncludeTestResources( includeTestResources ) .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() ) .setProject( project ).setSourceDirectories( getSourceDirectories() ) .setResources( resources ).setTestResources( testResources ) .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation ) .setTestSourceDirectories( getTestSourceDirectories() ).setConfigLocation( configLocation ) .setConfigurationArtifacts( collectArtifacts( ""config"" ) ) .setPropertyExpansion( propertyExpansion ) .setHeaderLocation( headerLocation ).setLicenseArtifacts( collectArtifacts( ""license"" ) ) .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression ) .setEncoding( encoding ).setPropertiesLocation( propertiesLocation ) .setOmitIgnoredModules( omitIgnoredModules );
				 checkstyleExecutor.executeCheckstyle( request );
			 }
			 catch ( CheckstyleException e ) {
				 throw new MojoExecutionException( ""Failed during checkstyle configuration"", e );
			 }
			 catch ( CheckstyleExecutorException e ) {
				 throw new MojoExecutionException( ""Failed during checkstyle execution"", e );
			 }
			 finally {
				 Thread.currentThread().setContextClassLoader( currentClassLoader );
			 }
		 }
		 if ( !""xml"".equals( outputFileFormat ) && skipExec ) {
			 throw new MojoExecutionException( ""Output format is '"" + outputFileFormat + ""', checkstyle:check requires format to be 'xml' when using skipExec."" );
		 }
		 if ( !outputXmlFile.exists() ) {
			 getLog().info( ""Unable to perform checkstyle:check, unable to find checkstyle:checkstyle outputFile."" );
			 return;
		 }
		 try ( Reader reader = new BufferedReader( ReaderFactory.newXmlReader( outputXmlFile ) ) ) {
			 XmlPullParser xpp = new MXParser();
			 xpp.setInput( reader );
			 int violations = countViolations( xpp );
			 if ( violations > maxAllowedViolations ) {
				 if ( failOnViolation ) {
					 String msg = ""You have "" + violations + "" Checkstyle violation"" + ( ( violations > 1 ) ? ""s"" : """" ) + ""."";
					 if ( maxAllowedViolations > 0 ) {
						 msg += "" The maximum number of allowed violations is "" + maxAllowedViolations + ""."";
					 }
					 throw new MojoFailureException( msg );
				 }
				 getLog().warn( ""checkstyle:check violations detected but failOnViolation set to false"" );
			 }
		 }
		 catch ( IOException | XmlPullParserException e ) {
			 throw new MojoExecutionException( ""Unable to read Checkstyle results xml: "" + outputXmlFile.getAbsolutePath(), e );
		 }
	 }
	 private void checkDeprecatedParameterUsage( Object parameter, String name, String replacement ) throws MojoFailureException {
		 if ( parameter != null ) {
			 throw new MojoFailureException( ""You are using '"" + name + ""' which has been removed"" + "" from the maven-checkstyle-plugin. "" + ""Please use '"" + replacement + ""' and refer to the >>Major Version Upgrade to version 3.0.0<< "" + ""on the plugin site."" );
		 }
	 }
	 private int countViolations( XmlPullParser xpp ) throws XmlPullParserException, IOException {
		 int count = 0;
		 int ignoreCount = 0;
		 List<RuleUtil.Matcher> ignores = violationIgnore == null ? Collections.<RuleUtil.Matcher>emptyList() : RuleUtil.parseMatchers( violationIgnore.split( "","" ) );
		 String basedir = project.getBasedir().getAbsolutePath();
		 String file = """";
		 for ( int eventType = xpp.getEventType();
		 eventType != XmlPullParser.END_DOCUMENT;
		 eventType = xpp.next() ) {
			 if ( eventType != XmlPullParser.START_TAG ) {
				 continue;
			 }
			 else if ( ""file"".equals( xpp.getName() ) ) {
				 file = PathTool.getRelativeFilePath( basedir, xpp.getAttributeValue( """", ""name"" ) );
			 }
			 else if ( ""error"".equals( xpp.getName() ) ) {
				 String severity = xpp.getAttributeValue( """", ""severity"" );
				 if ( !isViolation( severity ) ) {
					 continue;
				 }
				 String source = xpp.getAttributeValue( """", ""source"" );
				 if ( ignore( ignores, source ) ) {
					 ignoreCount++;
				 }
				 else {
					 count++;
					 if ( logViolationsToConsole ) {
						 String line = xpp.getAttributeValue( """", ""line"" );
						 String column = xpp.getAttributeValue( """", ""column"" );
						 String message = xpp.getAttributeValue( """", ""message"" );
						 String rule = RuleUtil.getName( source );
						 String category = RuleUtil.getCategory( source );
						 log( severity, file + "":["" + line + ( ( column == null ) ? """" : ( ',' + column ) ) + ""] ("" + category + "") "" + rule + "": "" + message );
					 }
				 }
			 }
		 }
		 if ( ignoreCount > 0 ) {
			 getLog().info( ""Ignored "" + ignoreCount + "" error"" + ( ( ignoreCount > 1 ) ? ""s"" : """" ) + "", "" + count + "" violation"" + ( ( count > 1 ) ? ""s"" : """" ) + "" remaining."" );
		 }
		 return count;
	 }
	 private void log( String severity, String message ) {
		 if ( ""info"".equals( severity ) ) {
			 getLog().info( message );
		 }
		 else if ( ""warning"".equals( severity ) ) {
			 getLog().warn( message );
		 }
		 else {
			 getLog().error( message );
		 }
	 }
	 private boolean isViolation( String severity ) {
		 if ( ""error"".equals( severity ) ) {
			 return ""error"".equals( violationSeverity ) || ""warning"".equals( violationSeverity ) || ""info"".equals( violationSeverity );
		 }
		 else if ( ""warning"".equals( severity ) ) {
			 return ""warning"".equals( violationSeverity ) || ""info"".equals( violationSeverity );
		 }
		 else if ( ""info"".equals( severity ) ) {
			 return ""info"".equals( violationSeverity );
		 }
		 else {
			 return false;
		 }
	 }
	 private boolean ignore( List<RuleUtil.Matcher> ignores, String source ) {
		 for ( RuleUtil.Matcher ignore : ignores ) {
			 if ( ignore.match( source ) ) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private DefaultLogger getConsoleListener() throws MojoExecutionException {
		 DefaultLogger consoleListener;
		 if ( useFile == null ) {
			 stringOutputStream = new ByteArrayOutputStream();
			 consoleListener = new DefaultLogger( stringOutputStream, false );
		 }
		 else {
			 OutputStream out = getOutputStream( useFile );
			 consoleListener = new DefaultLogger( out, true );
		 }
		 return consoleListener;
	 }
	 private OutputStream getOutputStream( File file ) throws MojoExecutionException {
		 File parentFile = file.getAbsoluteFile().getParentFile();
		 if ( !parentFile.exists() ) {
			 parentFile.mkdirs();
		 }
		 FileOutputStream fileOutputStream;
		 try {
			 fileOutputStream = new FileOutputStream( file );
		 }
		 catch ( FileNotFoundException e ) {
			 throw new MojoExecutionException( ""Unable to create output stream: "" + file, e );
		 }
		 return fileOutputStream;
	 }
	 private AuditListener getListener() throws MojoFailureException, MojoExecutionException {
		 AuditListener listener = null;
		 if ( StringUtils.isNotEmpty( outputFileFormat ) ) {
			 File resultFile = outputFile;
			 OutputStream out = getOutputStream( resultFile );
			 if ( ""xml"".equals( outputFileFormat ) ) {
				 listener = new XMLLogger( out, true );
			 }
			 else if ( ""plain"".equals( outputFileFormat ) ) {
				 try {
					 outputXmlFile = File.createTempFile( ""checkstyle-result"", "".xml"" );
					 outputXmlFile.deleteOnExit();
					 OutputStream xmlOut = getOutputStream( outputXmlFile );
					 CompositeAuditListener compoundListener = new CompositeAuditListener();
					 compoundListener.addListener( new XMLLogger( xmlOut, true ) );
					 compoundListener.addListener( new DefaultLogger( out, true ) );
					 listener = compoundListener;
				 }
				 catch ( IOException e ) {
					 throw new MojoExecutionException( ""Unable to create temporary file"", e );
				 }
			 }
			 else {
				 throw new MojoFailureException( ""Invalid output file format: ("" + outputFileFormat + ""). Must be 'plain' or 'xml'."" );
			 }
		 }
		 return listener;
	 }
	 private List<Artifact> collectArtifacts( String hint ) {
		 List<Artifact> artifacts = new ArrayList<>();
		 PluginManagement pluginManagement = project.getBuild().getPluginManagement();
		 if ( pluginManagement != null ) {
			 artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( pluginManagement.getPluginsAsMap(), hint ) );
		 }
		 artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( project.getBuild().getPluginsAsMap(), hint ) );
		 return artifacts;
	 }
	 private List<Artifact> getCheckstylePluginDependenciesAsArtifacts( Map<String, Plugin> plugins, String hint ) {
		 List<Artifact> artifacts = new ArrayList<>();
		 Plugin checkstylePlugin = plugins.get( plugin.getGroupId() + "":"" + plugin.getArtifactId() );
		 if ( checkstylePlugin != null ) {
			 for ( Dependency dep : checkstylePlugin.getDependencies() ) {
				 String depKey = dep.getGroupId() + "":"" + dep.getArtifactId();
				 artifacts.add( (Artifact) plugin.getArtifactMap().get( depKey ) );
			 }
		 }
		 return artifacts;
	 }
	 private List<File> getSourceDirectories() {
		 if ( sourceDirectories == null ) {
			 sourceDirectories = project.getCompileSourceRoots();
		 }
		 List<File> sourceDirs = new ArrayList<>( sourceDirectories.size() );
		 for ( String sourceDir : sourceDirectories ) {
			 sourceDirs.add( FileUtils.resolveFile( project.getBasedir(), sourceDir ) );
		 }
		 return sourceDirs;
	 }
	 private List<File> getTestSourceDirectories() {
		 if ( testSourceDirectories == null ) {
			 testSourceDirectories = project.getTestCompileSourceRoots();
		 }
		 List<File> testSourceDirs = new ArrayList<>( testSourceDirectories.size() );
		 for ( String testSourceDir : testSourceDirectories ) {
			 testSourceDirs.add( FileUtils.resolveFile( project.getBasedir(), testSourceDir ) );
		 }
		 return testSourceDirs;
	 }
}",1,1,0,0
"public class ListCrossConnectGroupsRequest extends com.oracle.bmc.requests.BmcRequest {
	 private String compartmentId;
	 private Integer limit;
	 private String page;
	 private String displayName;
	 private SortBy sortBy;
	 public enum SortBy {
		 Timecreated(""TIMECREATED""), Displayname(""DISPLAYNAME""), ;
		 private final String value;
		 private static java.util.Map<String, SortBy> map;
		 static {
			 map = new java.util.HashMap<>();
			 for (SortBy v : SortBy.values()) {
				 map.put(v.getValue(), v);
			 }
		 }
		 SortBy(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
		 public static SortBy create(String key) {
			 if (map.containsKey(key)) {
				 return map.get(key);
			 }
			 throw new RuntimeException(""Invalid SortBy: "" + key);
		 }
	 }
	;
	 private SortOrder sortOrder;
	 public enum SortOrder {
		 Asc(""ASC""), Desc(""DESC""), ;
		 private final String value;
		 private static java.util.Map<String, SortOrder> map;
		 static {
			 map = new java.util.HashMap<>();
			 for (SortOrder v : SortOrder.values()) {
				 map.put(v.getValue(), v);
			 }
		 }
		 SortOrder(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
		 public static SortOrder create(String key) {
			 if (map.containsKey(key)) {
				 return map.get(key);
			 }
			 throw new RuntimeException(""Invalid SortOrder: "" + key);
		 }
	 }
	;
	 private CrossConnectGroup.LifecycleState lifecycleState;
	 public static class Builder {
		 private com.oracle.bmc.util.internal.Consumer<javax.ws.rs.client.Invocation.Builder> invocationCallback = null;
		 public Builder invocationCallback( com.oracle.bmc.util.internal.Consumer<javax.ws.rs.client.Invocation.Builder> invocationCallback) {
			 this.invocationCallback = invocationCallback;
			 return this;
		 }
		 public Builder copy(ListCrossConnectGroupsRequest o) {
			 compartmentId(o.getCompartmentId());
			 limit(o.getLimit());
			 page(o.getPage());
			 displayName(o.getDisplayName());
			 sortBy(o.getSortBy());
			 sortOrder(o.getSortOrder());
			 lifecycleState(o.getLifecycleState());
			 invocationCallback(o.getInvocationCallback());
			 return this;
		 }
		 public ListCrossConnectGroupsRequest build() {
			 ListCrossConnectGroupsRequest request = buildWithoutInvocationCallback();
			 request.setInvocationCallback(invocationCallback);
			 return request;
		 }
	 }
}",0,0,0,0
"private ApplicationDTO buildApplicationDTO( ApplicationRuntimeInformation ari) {
	 ApplicationDTO applicationDTO = new ApplicationDTO(){
	}
	;
	 applicationDTO.name = getServiceName( ari._cachingServiceReference::getProperty);
	 applicationDTO.base = _whiteboard.getApplicationBase( ari._cachingServiceReference::getProperty);
	 applicationDTO.serviceId = (Long)ari._cachingServiceReference.getProperty(""service.id"");
	 applicationDTO.resourceDTOs = getApplicationEndpointsStream( applicationDTO.name).toArray( ResourceDTO[]::new );
	 applicationDTO.extensionDTOs = getApplicationExtensionsStream( applicationDTO.name).toArray( ExtensionDTO[]::new );
	 Map<String, Set<ExtensionDTO>> nameBoundExtensions = new HashMap<>();
	 Map<ExtensionDTO, Set<ResourceDTO>> extensionResources = new HashMap<>();
	 for (ExtensionDTO extensionDTO : applicationDTO.extensionDTOs) {
		 if (extensionDTO.nameBindings == null) {
			 continue;
		 }
		 for (String nameBinding : extensionDTO.nameBindings) {
			 Set<ExtensionDTO> extensionDTOS = nameBoundExtensions.computeIfAbsent( nameBinding, __ -> new HashSet<>() );
			 extensionDTOS.add(extensionDTO);
		 }
	 }
	 for (ResourceDTO resourceDTO : applicationDTO.resourceDTOs) {
		 for (ResourceMethodInfoDTO resourceMethodInfo : resourceDTO.resourceMethods) {
			 if (resourceMethodInfo.nameBindings == null) {
				 continue;
			 }
			 for (String nameBinding : resourceMethodInfo.nameBindings) {
				 Set<ExtensionDTO> extensionDTOS = nameBoundExtensions.get( nameBinding);
				 if (extensionDTOS != null) {
					 for (ExtensionDTO extensionDTO : extensionDTOS) {
						 Set<ResourceDTO> resourceDTOS = extensionResources.computeIfAbsent( extensionDTO, __ -> new HashSet<>());
						 resourceDTOS.add(resourceDTO);
					 }
				 }
			 }
		 }
	 }
	 extensionResources.forEach( (extensionDTO, resourceDTOS) -> extensionDTO.filteredByName = resourceDTOS.toArray( new ResourceDTO[0]) );
	 CxfJaxrsServiceRegistrator cxfJaxRsServiceRegistrator = ari._cxfJaxRsServiceRegistrator;
	 Bus bus = cxfJaxRsServiceRegistrator.getBus();
	 Iterable<Class<T>> resourceClasses = cxfJaxRsServiceRegistrator.getStaticResourceClasses();
	 ArrayList<ResourceMethodInfoDTO> resourceMethodInfoDTOS = new ArrayList<>();
	 for (Class<T> resourceClass : resourceClasses) {
		 resourceMethodInfoDTOS.addAll( ClassIntrospector.getResourceMethodInfos(resourceClass, bus));
	 }
	 applicationDTO.resourceMethods = resourceMethodInfoDTOS.toArray( new ResourceMethodInfoDTO[0]);
	 return applicationDTO;
 }",0,0,1,0
"public class XSDHandler {
	 protected static final String VALIDATION = Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
	 protected static final String XMLSCHEMA_VALIDATION = Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
	 protected static final String ALLOW_JAVA_ENCODINGS = Constants.XERCES_FEATURE_PREFIX + Constants.ALLOW_JAVA_ENCODINGS_FEATURE;
	 protected static final String CONTINUE_AFTER_FATAL_ERROR = Constants.XERCES_FEATURE_PREFIX + Constants.CONTINUE_AFTER_FATAL_ERROR_FEATURE;
	 protected static final String STANDARD_URI_CONFORMANT_FEATURE = Constants.XERCES_FEATURE_PREFIX + Constants.STANDARD_URI_CONFORMANT_FEATURE;
	 protected static final String DISALLOW_DOCTYPE = Constants.XERCES_FEATURE_PREFIX + Constants.DISALLOW_DOCTYPE_DECL_FEATURE;
	 protected static final String GENERATE_SYNTHETIC_ANNOTATIONS = Constants.XERCES_FEATURE_PREFIX + Constants.GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE;
	 protected static final String VALIDATE_ANNOTATIONS = Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATE_ANNOTATIONS_FEATURE;
	 protected static final String HONOUR_ALL_SCHEMALOCATIONS = Constants.XERCES_FEATURE_PREFIX + Constants.HONOUR_ALL_SCHEMALOCATIONS_FEATURE;
	 protected static final String NAMESPACE_GROWTH = Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACE_GROWTH_FEATURE;
	 protected static final String TOLERATE_DUPLICATES = Constants.XERCES_FEATURE_PREFIX + Constants.TOLERATE_DUPLICATES_FEATURE;
	 private static final String NAMESPACE_PREFIXES = Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACE_PREFIXES_FEATURE;
	 protected static final String STRING_INTERNING = Constants.SAX_FEATURE_PREFIX + Constants.STRING_INTERNING_FEATURE;
	 protected static final String ERROR_HANDLER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_HANDLER_PROPERTY;
	 protected static final String JAXP_SCHEMA_SOURCE = Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE;
	 public static final String ENTITY_RESOLVER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
	 protected static final String ENTITY_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY;
	 public static final String ERROR_REPORTER = Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
	 public static final String XMLGRAMMAR_POOL = Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
	 public static final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
	 protected static final String SECURITY_MANAGER = Constants.XERCES_PROPERTY_PREFIX + Constants.SECURITY_MANAGER_PROPERTY;
	 protected static final String LOCALE = Constants.XERCES_PROPERTY_PREFIX + Constants.LOCALE_PROPERTY;
	 protected static final boolean DEBUG_NODE_POOL = false;
	 final static int ATTRIBUTE_TYPE = 1;
	 final static int ATTRIBUTEGROUP_TYPE = 2;
	 final static int ELEMENT_TYPE = 3;
	 final static int GROUP_TYPE = 4;
	 final static int IDENTITYCONSTRAINT_TYPE = 5;
	 final static int NOTATION_TYPE = 6;
	 final static int TYPEDECL_TYPE = 7;
	 public final static String REDEF_IDENTIFIER = ""_fn3dktizrknc9pi"";
	 protected Hashtable fNotationRegistry = new Hashtable();
	 protected XSDeclarationPool fDeclPool = null;
	 private Hashtable fUnparsedAttributeRegistry = new Hashtable();
	 private Hashtable fUnparsedAttributeGroupRegistry = new Hashtable();
	 private Hashtable fUnparsedElementRegistry = new Hashtable();
	 private Hashtable fUnparsedGroupRegistry = new Hashtable();
	 private Hashtable fUnparsedIdentityConstraintRegistry = new Hashtable();
	 private Hashtable fUnparsedNotationRegistry = new Hashtable();
	 private Hashtable fUnparsedTypeRegistry = new Hashtable();
	 private Hashtable fUnparsedAttributeRegistrySub = new Hashtable();
	 private Hashtable fUnparsedAttributeGroupRegistrySub = new Hashtable();
	 private Hashtable fUnparsedElementRegistrySub = new Hashtable();
	 private Hashtable fUnparsedGroupRegistrySub = new Hashtable();
	 private Hashtable fUnparsedIdentityConstraintRegistrySub = new Hashtable();
	 private Hashtable fUnparsedNotationRegistrySub = new Hashtable();
	 private Hashtable fUnparsedTypeRegistrySub = new Hashtable();
	 private Hashtable fUnparsedRegistriesExt[] = new Hashtable[] {
	 null, new Hashtable(), new Hashtable(), new Hashtable(), new Hashtable(), new Hashtable(), new Hashtable(), new Hashtable(), }
	;
	 private Hashtable fXSDocumentInfoRegistry = new Hashtable();
	 private Hashtable fDependencyMap = new Hashtable();
	 private Hashtable fImportMap = new Hashtable();
	 private Vector fAllTNSs = new Vector();
	 private Hashtable fLocationPairs = null;
	 private static final Hashtable EMPTY_TABLE = new Hashtable();
	 Hashtable fHiddenNodes = null;
	 private String null2EmptyString(String ns) {
		 return ns == null ? XMLSymbols.EMPTY_STRING : ns;
	 }
	 private String emptyString2Null(String ns) {
		 return ns == XMLSymbols.EMPTY_STRING ? null : ns;
	 }
	 private String doc2SystemId(Element ele) {
		 String documentURI = null;
		 if(ele.getOwnerDocument() instanceof org.apache.xerces.impl.xs.opti.SchemaDOM){
			 documentURI = ((org.apache.xerces.impl.xs.opti.SchemaDOM) ele.getOwnerDocument()).getDocumentURI();
		 }
		 return documentURI != null ? documentURI : (String) fDoc2SystemId.get(ele);
	 }
	 private Hashtable fTraversed = new Hashtable();
	 private Hashtable fDoc2SystemId = new Hashtable();
	 private XSDocumentInfo fRoot = null;
	 private Hashtable fDoc2XSDocumentMap = new Hashtable();
	 private Hashtable fRedefine2XSDMap = new Hashtable();
	 private Hashtable fRedefine2NSSupport = new Hashtable();
	 private Hashtable fRedefinedRestrictedAttributeGroupRegistry = new Hashtable();
	 private Hashtable fRedefinedRestrictedGroupRegistry = new Hashtable();
	 private boolean fLastSchemaWasDuplicate;
	 private boolean fValidateAnnotations = false;
	 private boolean fHonourAllSchemaLocations = false;
	 boolean fNamespaceGrowth = false;
	 boolean fTolerateDuplicates = false;
	 private XMLErrorReporter fErrorReporter;
	 private XMLEntityResolver fEntityResolver;
	 private XSAttributeChecker fAttributeChecker;
	 private SymbolTable fSymbolTable;
	 private XSGrammarBucket fGrammarBucket;
	 private XSDDescription fSchemaGrammarDescription;
	 private XMLGrammarPool fGrammarPool;
	 / public SchemaGrammar parseSchema(XMLInputSource is, XSDDescription desc, Hashtable locationPairs) throws IOException {
		 fLocationPairs = locationPairs;
		 fSchemaParser.resetNodePool();
		 SchemaGrammar grammar = null;
		 String schemaNamespace = null;
		 short referType = desc.getContextType();
		 if (referType != XSDDescription.CONTEXT_PREPARSE){
			 if (fHonourAllSchemaLocations && referType == XSDDescription.CONTEXT_IMPORT && isExistingGrammar(desc, fNamespaceGrowth)) {
				 grammar = fGrammarBucket.getGrammar(desc.getTargetNamespace());
			 }
			 else {
				 grammar = findGrammar(desc, fNamespaceGrowth);
			 }
			 if (grammar != null) {
				 if (!fNamespaceGrowth) {
					 return grammar;
				 }
				 else {
					 try {
						 if (grammar.getDocumentLocations().contains(XMLEntityManager.expandSystemId(is.getSystemId(), is.getBaseSystemId(), false))) {
							 return grammar;
						 }
					 }
					 catch (MalformedURIException e) {
					 }
				 }
			 }
			 schemaNamespace = desc.getTargetNamespace();
			 if (schemaNamespace != null) {
				 schemaNamespace = fSymbolTable.addSymbol(schemaNamespace);
			 }
		 }
		 prepareForParse();
		 Element schemaRoot = null;
		 if (is instanceof DOMInputSource) {
			 schemaRoot = getSchemaDocument(schemaNamespace, (DOMInputSource) is, referType == XSDDescription.CONTEXT_PREPARSE, referType, null);
		 }
		 else if (is instanceof SAXInputSource) {
			 schemaRoot = getSchemaDocument(schemaNamespace, (SAXInputSource) is, referType == XSDDescription.CONTEXT_PREPARSE, referType, null);
		 }
		 else if (is instanceof StAXInputSource) {
			 schemaRoot = getSchemaDocument(schemaNamespace, (StAXInputSource) is, referType == XSDDescription.CONTEXT_PREPARSE, referType, null);
		 }
		 else if (is instanceof XSInputSource) {
			 schemaRoot = getSchemaDocument((XSInputSource) is, desc);
		 }
		 else {
			 schemaRoot = getSchemaDocument(schemaNamespace, is, referType == XSDDescription.CONTEXT_PREPARSE, referType, null);
		 }
		 if (schemaRoot == null) {
			 if (is instanceof XSInputSource) {
				 return fGrammarBucket.getGrammar(desc.getTargetNamespace());
			 }
			 return grammar;
		 }
		 if (referType == XSDDescription.CONTEXT_PREPARSE) {
			 Element schemaElem = schemaRoot;
			 schemaNamespace = DOMUtil.getAttrValue(schemaElem, SchemaSymbols.ATT_TARGETNAMESPACE);
			 if(schemaNamespace != null && schemaNamespace.length() > 0) {
				 schemaNamespace = fSymbolTable.addSymbol(schemaNamespace);
				 desc.setTargetNamespace(schemaNamespace);
			 }
			 else {
				 schemaNamespace = null;
			 }
			 grammar = findGrammar(desc, fNamespaceGrowth);
			 String schemaId = XMLEntityManager.expandSystemId(is.getSystemId(), is.getBaseSystemId(), false);
			 if (grammar != null) {
				 if (!fNamespaceGrowth || (schemaId != null && grammar.getDocumentLocations().contains(schemaId))) {
					 return grammar;
				 }
			 }
			 XSDKey key = new XSDKey(schemaId, referType, schemaNamespace);
			 fTraversed.put(key, schemaRoot);
			 if (schemaId != null) {
				 fDoc2SystemId.put(schemaRoot, schemaId);
			 }
		 }
		 prepareForTraverse();
		 fRoot = constructTrees(schemaRoot, is.getSystemId(), desc, grammar != null);
		 if (fRoot == null) {
			 return null;
		 }
		 buildGlobalNameRegistries();
		 ArrayList annotationInfo = fValidateAnnotations ? new ArrayList() : null;
		 traverseSchemas(annotationInfo);
		 traverseLocalElements();
		 resolveKeyRefs();
		 for (int i = fAllTNSs.size() - 1;
		 i >= 0;
		 i--) {
			 String tns = (String)fAllTNSs.elementAt(i);
			 Vector ins = (Vector)fImportMap.get(tns);
			 SchemaGrammar sg = fGrammarBucket.getGrammar(emptyString2Null(tns));
			 if (sg == null) continue;
			 SchemaGrammar isg;
			 int count = 0;
			 for (int j = 0;
			 j < ins.size();
			 j++) {
				 isg = fGrammarBucket.getGrammar((String)ins.elementAt(j));
				 if (isg != null) ins.setElementAt(isg, count++);
			 }
			 ins.setSize(count);
			 sg.setImportedGrammars(ins);
		 }
		 if (fValidateAnnotations && annotationInfo.size() > 0) {
			 validateAnnotations(annotationInfo);
		 }
		 return fGrammarBucket.getGrammar(fRoot.fTargetNamespace);
	 }
	 private void validateAnnotations(ArrayList annotationInfo) {
		 if (fAnnotationValidator == null) {
			 createAnnotationValidator();
		 }
		 final int size = annotationInfo.size();
		 final XMLInputSource src = new XMLInputSource(null, null, null);
		 fGrammarBucketAdapter.refreshGrammars(fGrammarBucket);
		 for (int i = 0;
		 i < size;
		 i += 2) {
			 src.setSystemId((String) annotationInfo.get(i));
			 XSAnnotationInfo annotation = (XSAnnotationInfo) annotationInfo.get(i+1);
			 while (annotation != null) {
				 src.setCharacterStream(new StringReader(annotation.fAnnotation));
				 try {
					 fAnnotationValidator.parse(src);
				 }
				 catch (IOException exc) {
				}
				 annotation = annotation.next;
			 }
		 }
	 }
	 private void createAnnotationValidator() {
		 fAnnotationValidator = new XML11Configuration();
		 fGrammarBucketAdapter = new XSAnnotationGrammarPool();
		 fAnnotationValidator.setFeature(VALIDATION, true);
		 fAnnotationValidator.setFeature(XMLSCHEMA_VALIDATION, true);
		 fAnnotationValidator.setProperty(XMLGRAMMAR_POOL, fGrammarBucketAdapter);
		 XMLErrorHandler errorHandler = fErrorReporter.getErrorHandler();
		 fAnnotationValidator.setProperty(ERROR_HANDLER, (errorHandler != null) ? errorHandler : new DefaultErrorHandler());
		 Locale locale = fErrorReporter.getLocale();
		 fAnnotationValidator.setProperty(LOCALE, locale);
	 }
	 SchemaGrammar getGrammar(String tns) {
		 return fGrammarBucket.getGrammar(tns);
	 }
	 protected SchemaGrammar findGrammar(XSDDescription desc, boolean ignoreConflict) {
		 SchemaGrammar sg = fGrammarBucket.getGrammar(desc.getTargetNamespace());
		 if (sg == null) {
			 if (fGrammarPool != null) {
				 sg = (SchemaGrammar)fGrammarPool.retrieveGrammar(desc);
				 if (sg != null) {
					 if (!fGrammarBucket.putGrammar(sg, true, ignoreConflict)) {
						 reportSchemaWarning(""GrammarConflict"", null, null);
						 sg = null;
					 }
				 }
			 }
		 }
		 return sg;
	 }
	 private static final String[][] NS_ERROR_CODES = {
		 {
		""src-include.2.1"", ""src-include.2.1""}
		, {
		""src-redefine.3.1"", ""src-redefine.3.1""}
		, {
		""src-import.3.1"", ""src-import.3.2""}
		, null, {
		""TargetNamespace.1"", ""TargetNamespace.2""}
		, {
		""TargetNamespace.1"", ""TargetNamespace.2""}
		, {
		""TargetNamespace.1"", ""TargetNamespace.2""}
		, {
		""TargetNamespace.1"", ""TargetNamespace.2""}
	 }
	;
	 private static final String[] ELE_ERROR_CODES = {
	 ""src-include.1"", ""src-redefine.2"", ""src-import.2"", ""schema_reference.4"", ""schema_reference.4"", ""schema_reference.4"", ""schema_reference.4"", ""schema_reference.4"" }
	;
	 protected XSDocumentInfo constructTrees(Element schemaRoot, String locationHint, XSDDescription desc, boolean nsCollision) {
		 if (schemaRoot == null) return null;
		 String callerTNS = desc.getTargetNamespace();
		 short referType = desc.getContextType();
		 XSDocumentInfo currSchemaInfo = null;
		 try {
			 currSchemaInfo = new XSDocumentInfo(schemaRoot, fAttributeChecker, fSymbolTable);
		 }
		 catch (XMLSchemaException se) {
			 reportSchemaError(ELE_ERROR_CODES[referType], new Object[]{
			locationHint}
			, schemaRoot);
			 return null;
		 }
		 if (currSchemaInfo.fTargetNamespace != null && currSchemaInfo.fTargetNamespace.length() == 0) {
			 reportSchemaWarning(""EmptyTargetNamespace"", new Object[]{
			locationHint}
			,schemaRoot);
			 currSchemaInfo.fTargetNamespace = null;
		 }
		 if (callerTNS != null) {
			 int secondIdx = 0;
			 if (referType == XSDDescription.CONTEXT_INCLUDE || referType == XSDDescription.CONTEXT_REDEFINE) {
				 if (currSchemaInfo.fTargetNamespace == null) {
					 currSchemaInfo.fTargetNamespace = callerTNS;
					 currSchemaInfo.fIsChameleonSchema = true;
				 }
				 else if (callerTNS != currSchemaInfo.fTargetNamespace) {
					 reportSchemaError(NS_ERROR_CODES[referType][secondIdx], new Object [] {
					callerTNS, currSchemaInfo.fTargetNamespace}
					,schemaRoot);
					 return null;
				 }
			 }
			 else if (referType != XSDDescription.CONTEXT_PREPARSE && callerTNS != currSchemaInfo.fTargetNamespace) {
				 reportSchemaError(NS_ERROR_CODES[referType][secondIdx], new Object [] {
				callerTNS, currSchemaInfo.fTargetNamespace}
				,schemaRoot);
				 return null;
			 }
		 }
		 else if (currSchemaInfo.fTargetNamespace != null) {
			 if (referType == XSDDescription.CONTEXT_PREPARSE) {
				 desc.setTargetNamespace(currSchemaInfo.fTargetNamespace);
				 callerTNS = currSchemaInfo.fTargetNamespace;
			 }
			 else {
				 int secondIdx = 1;
				 reportSchemaError(NS_ERROR_CODES[referType][secondIdx], new Object [] {
				callerTNS, currSchemaInfo.fTargetNamespace}
				,schemaRoot);
				 return null;
			 }
		 }
		 currSchemaInfo.addAllowedNS(currSchemaInfo.fTargetNamespace);
		 SchemaGrammar sg = null;
		 if (nsCollision) {
			 SchemaGrammar sg2 = fGrammarBucket.getGrammar(currSchemaInfo.fTargetNamespace);
			 if (sg2.isImmutable()) {
				 sg = new SchemaGrammar(sg2);
				 fGrammarBucket.putGrammar(sg);
				 updateImportListWith(sg);
			 }
			 else {
				 sg = sg2;
			 }
			 updateImportListFor(sg);
		 }
		 else if (referType == XSDDescription.CONTEXT_INCLUDE || referType == XSDDescription.CONTEXT_REDEFINE) {
			 sg = fGrammarBucket.getGrammar(currSchemaInfo.fTargetNamespace);
		 }
		 else if(fHonourAllSchemaLocations && referType == XSDDescription.CONTEXT_IMPORT) {
			 sg = findGrammar(desc, false);
			 if(sg == null) {
				 sg = new SchemaGrammar(currSchemaInfo.fTargetNamespace, desc.makeClone(), fSymbolTable);
				 fGrammarBucket.putGrammar(sg);
			 }
		 }
		 else {
			 sg = new SchemaGrammar(currSchemaInfo.fTargetNamespace, desc.makeClone(), fSymbolTable);
			 fGrammarBucket.putGrammar(sg);
		 }
		 sg.addDocument(null, (String)fDoc2SystemId.get(currSchemaInfo.fSchemaElement));
		 fDoc2XSDocumentMap.put(schemaRoot, currSchemaInfo);
		 Vector dependencies = new Vector();
		 Element rootNode = schemaRoot;
		 Element newSchemaRoot = null;
		 for (Element child = DOMUtil.getFirstChildElement(rootNode);
		 child != null;
		 child = DOMUtil.getNextSiblingElement(child)) {
			 String schemaNamespace=null;
			 String schemaHint=null;
			 String localName = DOMUtil.getLocalName(child);
			 short refType = -1;
			 boolean importCollision = false;
			 if (localName.equals(SchemaSymbols.ELT_ANNOTATION)) continue;
			 else if (localName.equals(SchemaSymbols.ELT_IMPORT)) {
				 refType = XSDDescription.CONTEXT_IMPORT;
				 Object[] importAttrs = fAttributeChecker.checkAttributes(child, true, currSchemaInfo);
				 schemaHint = (String)importAttrs[XSAttributeChecker.ATTIDX_SCHEMALOCATION];
				 schemaNamespace = (String)importAttrs[XSAttributeChecker.ATTIDX_NAMESPACE];
				 if (schemaNamespace != null) schemaNamespace = fSymbolTable.addSymbol(schemaNamespace);
				 Element importChild = DOMUtil.getFirstChildElement(child);
				 if(importChild != null ) {
					 String importComponentType = DOMUtil.getLocalName(importChild);
					 if (importComponentType.equals(SchemaSymbols.ELT_ANNOTATION)) {
						 sg.addAnnotation( fElementTraverser.traverseAnnotationDecl(importChild, importAttrs, true, currSchemaInfo));
					 }
					 else {
						 reportSchemaError(""s4s-elt-must-match.1"", new Object [] {
						localName, ""annotation?"", importComponentType}
						, child);
					 }
					 if(DOMUtil.getNextSiblingElement(importChild) != null) {
						 reportSchemaError(""s4s-elt-must-match.1"", new Object [] {
						localName, ""annotation?"", DOMUtil.getLocalName(DOMUtil.getNextSiblingElement(importChild))}
						, child);
					 }
				 }
				 else {
					 String text = DOMUtil.getSyntheticAnnotation(child);
					 if (text != null) {
						 sg.addAnnotation(fElementTraverser.traverseSyntheticAnnotation(child, text, importAttrs, true, currSchemaInfo));
					 }
				 }
				 fAttributeChecker.returnAttrArray(importAttrs, currSchemaInfo);
				 if (schemaNamespace == currSchemaInfo.fTargetNamespace) {
					 reportSchemaError(schemaNamespace != null ? ""src-import.1.1"" : ""src-import.1.2"", new Object [] {
					schemaNamespace}
					, child);
					 continue;
				 }
				 if(currSchemaInfo.isAllowedNS(schemaNamespace)) {
					 if(!fHonourAllSchemaLocations && !fNamespaceGrowth) continue;
				 }
				 else {
					 currSchemaInfo.addAllowedNS(schemaNamespace);
				 }
				 String tns = null2EmptyString(currSchemaInfo.fTargetNamespace);
				 Vector ins = (Vector)fImportMap.get(tns);
				 if (ins == null) {
					 fAllTNSs.addElement(tns);
					 ins = new Vector();
					 fImportMap.put(tns, ins);
					 ins.addElement(schemaNamespace);
				 }
				 else if (!ins.contains(schemaNamespace)){
					 ins.addElement(schemaNamespace);
				 }
				 fSchemaGrammarDescription.reset();
				 fSchemaGrammarDescription.setContextType(XSDDescription.CONTEXT_IMPORT);
				 fSchemaGrammarDescription.setBaseSystemId(doc2SystemId(schemaRoot));
				 fSchemaGrammarDescription.setLiteralSystemId(schemaHint);
				 fSchemaGrammarDescription.setLocationHints(new String[]{
				schemaHint}
				);
				 fSchemaGrammarDescription.setTargetNamespace(schemaNamespace);
				 SchemaGrammar isg = findGrammar(fSchemaGrammarDescription, fNamespaceGrowth);
				 if (isg != null) {
					 if (fNamespaceGrowth) {
						 try {
							 if (isg.getDocumentLocations().contains(XMLEntityManager.expandSystemId(schemaHint, fSchemaGrammarDescription.getBaseSystemId(), false))) {
								 continue;
							 }
							 else {
								 importCollision = true;
							 }
						 }
						 catch (MalformedURIException e) {
						 }
					 }
					 else if (!fHonourAllSchemaLocations || isExistingGrammar(fSchemaGrammarDescription, false)) {
						 continue;
					 }
				 }
				 newSchemaRoot = resolveSchema(fSchemaGrammarDescription, false, child, isg == null);
			 }
			 else if ((localName.equals(SchemaSymbols.ELT_INCLUDE)) || (localName.equals(SchemaSymbols.ELT_REDEFINE))) {
				 Object[] includeAttrs = fAttributeChecker.checkAttributes(child, true, currSchemaInfo);
				 schemaHint = (String)includeAttrs[XSAttributeChecker.ATTIDX_SCHEMALOCATION];
				 if (localName.equals(SchemaSymbols.ELT_REDEFINE)) {
					 fRedefine2NSSupport.put(child, new SchemaNamespaceSupport(currSchemaInfo.fNamespaceSupport));
				 }
				 if(localName.equals(SchemaSymbols.ELT_INCLUDE)) {
					 Element includeChild = DOMUtil.getFirstChildElement(child);
					 if(includeChild != null ) {
						 String includeComponentType = DOMUtil.getLocalName(includeChild);
						 if (includeComponentType.equals(SchemaSymbols.ELT_ANNOTATION)) {
							 sg.addAnnotation( fElementTraverser.traverseAnnotationDecl(includeChild, includeAttrs, true, currSchemaInfo));
						 }
						 else {
							 reportSchemaError(""s4s-elt-must-match.1"", new Object [] {
							localName, ""annotation?"", includeComponentType}
							, child);
						 }
						 if(DOMUtil.getNextSiblingElement(includeChild) != null) {
							 reportSchemaError(""s4s-elt-must-match.1"", new Object [] {
							localName, ""annotation?"", DOMUtil.getLocalName(DOMUtil.getNextSiblingElement(includeChild))}
							, child);
						 }
					 }
					 else {
						 String text = DOMUtil.getSyntheticAnnotation(child);
						 if (text != null) {
							 sg.addAnnotation(fElementTraverser.traverseSyntheticAnnotation(child, text, includeAttrs, true, currSchemaInfo));
						 }
					 }
				 }
				 else {
					 for (Element redefinedChild = DOMUtil.getFirstChildElement(child);
					 redefinedChild != null;
					 redefinedChild = DOMUtil.getNextSiblingElement(redefinedChild)) {
						 String redefinedComponentType = DOMUtil.getLocalName(redefinedChild);
						 if (redefinedComponentType.equals(SchemaSymbols.ELT_ANNOTATION)) {
							 sg.addAnnotation( fElementTraverser.traverseAnnotationDecl(redefinedChild, includeAttrs, true, currSchemaInfo));
							 DOMUtil.setHidden(redefinedChild, fHiddenNodes);
						 }
						 else {
							 String text = DOMUtil.getSyntheticAnnotation(child);
							 if (text != null) {
								 sg.addAnnotation(fElementTraverser.traverseSyntheticAnnotation(child, text, includeAttrs, true, currSchemaInfo));
							 }
						 }
					 }
				 }
				 fAttributeChecker.returnAttrArray(includeAttrs, currSchemaInfo);
				 if (schemaHint == null) {
					 reportSchemaError(""s4s-att-must-appear"", new Object [] {
					 ""<include> or <redefine>"", ""schemaLocation""}
					, child);
				 }
				 boolean mustResolve = false;
				 refType = XSDDescription.CONTEXT_INCLUDE;
				 if(localName.equals(SchemaSymbols.ELT_REDEFINE)) {
					 mustResolve = nonAnnotationContent(child);
					 refType = XSDDescription.CONTEXT_REDEFINE;
				 }
				 fSchemaGrammarDescription.reset();
				 fSchemaGrammarDescription.setContextType(refType);
				 fSchemaGrammarDescription.setBaseSystemId(doc2SystemId(schemaRoot));
				 fSchemaGrammarDescription.setLocationHints(new String[]{
				schemaHint}
				);
				 fSchemaGrammarDescription.setTargetNamespace(callerTNS);
				 boolean alreadyTraversed = false;
				 XMLInputSource schemaSource = resolveSchemaSource(fSchemaGrammarDescription, mustResolve, child, true);
				 if (fNamespaceGrowth && refType == XSDDescription.CONTEXT_INCLUDE) {
					 try {
						 final String schemaId = XMLEntityManager.expandSystemId(schemaSource.getSystemId(), schemaSource.getBaseSystemId(), false);
						 alreadyTraversed = sg.getDocumentLocations().contains(schemaId);
					 }
					 catch(MalformedURIException e) {
					 }
				 }
				 if (!alreadyTraversed) {
					 newSchemaRoot = resolveSchema(schemaSource, fSchemaGrammarDescription, mustResolve, child);
					 schemaNamespace = currSchemaInfo.fTargetNamespace;
				 }
				 else {
					 fLastSchemaWasDuplicate = true;
				 }
			 }
			 else {
				 break;
			 }
			 XSDocumentInfo newSchemaInfo = null;
			 if (fLastSchemaWasDuplicate) {
				 newSchemaInfo = newSchemaRoot == null ? null : (XSDocumentInfo)fDoc2XSDocumentMap.get(newSchemaRoot);
			 }
			 else {
				 newSchemaInfo = constructTrees(newSchemaRoot, schemaHint, fSchemaGrammarDescription, importCollision);
			 }
			 if (localName.equals(SchemaSymbols.ELT_REDEFINE) && newSchemaInfo != null) {
				 fRedefine2XSDMap.put(child, newSchemaInfo);
			 }
			 if (newSchemaRoot != null) {
				 if (newSchemaInfo != null) dependencies.addElement(newSchemaInfo);
				 newSchemaRoot = null;
			 }
		 }
		 fDependencyMap.put(currSchemaInfo, dependencies);
		 return currSchemaInfo;
	 }
	 private boolean isExistingGrammar(XSDDescription desc, boolean ignoreConflict) {
		 SchemaGrammar sg = fGrammarBucket.getGrammar(desc.getTargetNamespace());
		 if (sg == null) {
			 return findGrammar(desc, ignoreConflict) != null;
		 }
		 else if (sg.isImmutable()) {
			 return true;
		 }
		 else {
			 try {
				 return sg.getDocumentLocations().contains(XMLEntityManager.expandSystemId(desc.getLiteralSystemId(), desc.getBaseSystemId(), false));
			 }
			 catch (MalformedURIException e) {
				 return false;
			 }
		 }
	 }
	 private void updateImportListFor(SchemaGrammar grammar) {
		 Vector importedGrammars = grammar.getImportedGrammars();
		 if (importedGrammars != null) {
			 for (int i=0;
			 i<importedGrammars.size();
			 i++) {
				 SchemaGrammar isg1 = (SchemaGrammar) importedGrammars.elementAt(i);
				 SchemaGrammar isg2 = fGrammarBucket.getGrammar(isg1.getTargetNamespace());
				 if (isg2 != null && isg1 != isg2) {
					 importedGrammars.set(i, isg2);
				 }
			 }
		 }
	 }
	 private void updateImportListWith(SchemaGrammar newGrammar) {
		 SchemaGrammar[] schemaGrammars = fGrammarBucket.getGrammars();
		 for (int i = 0;
		 i < schemaGrammars.length;
		 ++i) {
			 SchemaGrammar sg = schemaGrammars[i];
			 if (sg != newGrammar) {
				 Vector importedGrammars = sg.getImportedGrammars();
				 if (importedGrammars != null) {
					 for (int j=0;
					 j<importedGrammars.size();
					 j++) {
						 SchemaGrammar isg = (SchemaGrammar) importedGrammars.elementAt(j);
						 if (null2EmptyString(isg.getTargetNamespace()).equals(null2EmptyString(newGrammar.getTargetNamespace()))) {
							 if (isg != newGrammar) {
								 importedGrammars.set(j, newGrammar);
							 }
							 break;
						 }
					 }
				 }
			 }
		 }
	 }
	 protected void buildGlobalNameRegistries() {
		 Stack schemasToProcess = new Stack();
		 schemasToProcess.push(fRoot);
		 while (!schemasToProcess.empty()) {
			 XSDocumentInfo currSchemaDoc = (XSDocumentInfo)schemasToProcess.pop();
			 Element currDoc = currSchemaDoc.fSchemaElement;
			 if(DOMUtil.isHidden(currDoc, fHiddenNodes)){
				 continue;
			 }
			 Element currRoot = currDoc;
			 boolean dependenciesCanOccur = true;
			 for (Element globalComp = DOMUtil.getFirstChildElement(currRoot);
			 globalComp != null;
			 globalComp = DOMUtil.getNextSiblingElement(globalComp)) {
				 if (DOMUtil.getLocalName(globalComp).equals(SchemaSymbols.ELT_ANNOTATION)) {
					 continue;
				 }
				 else if (DOMUtil.getLocalName(globalComp).equals(SchemaSymbols.ELT_INCLUDE) || DOMUtil.getLocalName(globalComp).equals(SchemaSymbols.ELT_IMPORT)) {
					 if (!dependenciesCanOccur) {
						 reportSchemaError(""s4s-elt-invalid-content.3"", new Object [] {
						DOMUtil.getLocalName(globalComp)}
						, globalComp);
					 }
					 DOMUtil.setHidden(globalComp, fHiddenNodes);
				 }
				 else if (DOMUtil.getLocalName(globalComp).equals(SchemaSymbols.ELT_REDEFINE)) {
					 if (!dependenciesCanOccur) {
						 reportSchemaError(""s4s-elt-invalid-content.3"", new Object [] {
						DOMUtil.getLocalName(globalComp)}
						, globalComp);
					 }
					 for (Element redefineComp = DOMUtil.getFirstChildElement(globalComp);
					 redefineComp != null;
					 redefineComp = DOMUtil.getNextSiblingElement(redefineComp)) {
						 String lName = DOMUtil.getAttrValue(redefineComp, SchemaSymbols.ATT_NAME);
						 if (lName.length() == 0) continue;
						 String qName = currSchemaDoc.fTargetNamespace == null ? "",""+lName: currSchemaDoc.fTargetNamespace +"",""+lName;
						 String componentType = DOMUtil.getLocalName(redefineComp);
						 if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTEGROUP)) {
							 checkForDuplicateNames(qName, ATTRIBUTEGROUP_TYPE, fUnparsedAttributeGroupRegistry, fUnparsedAttributeGroupRegistrySub, redefineComp, currSchemaDoc);
							 String targetLName = DOMUtil.getAttrValue(redefineComp, SchemaSymbols.ATT_NAME)+REDEF_IDENTIFIER;
							 renameRedefiningComponents(currSchemaDoc, redefineComp, SchemaSymbols.ELT_ATTRIBUTEGROUP, lName, targetLName);
						 }
						 else if ((componentType.equals(SchemaSymbols.ELT_COMPLEXTYPE)) || (componentType.equals(SchemaSymbols.ELT_SIMPLETYPE))) {
							 checkForDuplicateNames(qName, TYPEDECL_TYPE, fUnparsedTypeRegistry, fUnparsedTypeRegistrySub, redefineComp, currSchemaDoc);
							 String targetLName = DOMUtil.getAttrValue(redefineComp, SchemaSymbols.ATT_NAME) + REDEF_IDENTIFIER;
							 if (componentType.equals(SchemaSymbols.ELT_COMPLEXTYPE)) {
								 renameRedefiningComponents(currSchemaDoc, redefineComp, SchemaSymbols.ELT_COMPLEXTYPE, lName, targetLName);
							 }
							 else {
								 renameRedefiningComponents(currSchemaDoc, redefineComp, SchemaSymbols.ELT_SIMPLETYPE, lName, targetLName);
							 }
						 }
						 else if (componentType.equals(SchemaSymbols.ELT_GROUP)) {
							 checkForDuplicateNames(qName, GROUP_TYPE, fUnparsedGroupRegistry, fUnparsedGroupRegistrySub, redefineComp, currSchemaDoc);
							 String targetLName = DOMUtil.getAttrValue(redefineComp, SchemaSymbols.ATT_NAME)+REDEF_IDENTIFIER;
							 renameRedefiningComponents(currSchemaDoc, redefineComp, SchemaSymbols.ELT_GROUP, lName, targetLName);
						 }
					 }
				 }
				 else {
					 dependenciesCanOccur = false;
					 String lName = DOMUtil.getAttrValue(globalComp, SchemaSymbols.ATT_NAME);
					 if (lName.length() == 0) continue;
					 String qName = currSchemaDoc.fTargetNamespace == null? "",""+lName: currSchemaDoc.fTargetNamespace +"",""+lName;
					 String componentType = DOMUtil.getLocalName(globalComp);
					 if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTE)) {
						 checkForDuplicateNames(qName, ATTRIBUTE_TYPE, fUnparsedAttributeRegistry, fUnparsedAttributeRegistrySub, globalComp, currSchemaDoc);
					 }
					 else if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTEGROUP)) {
						 checkForDuplicateNames(qName, ATTRIBUTEGROUP_TYPE, fUnparsedAttributeGroupRegistry, fUnparsedAttributeGroupRegistrySub, globalComp, currSchemaDoc);
					 }
					 else if ((componentType.equals(SchemaSymbols.ELT_COMPLEXTYPE)) || (componentType.equals(SchemaSymbols.ELT_SIMPLETYPE))) {
						 checkForDuplicateNames(qName, TYPEDECL_TYPE, fUnparsedTypeRegistry, fUnparsedTypeRegistrySub, globalComp, currSchemaDoc);
					 }
					 else if (componentType.equals(SchemaSymbols.ELT_ELEMENT)) {
						 checkForDuplicateNames(qName, ELEMENT_TYPE, fUnparsedElementRegistry, fUnparsedElementRegistrySub, globalComp, currSchemaDoc);
					 }
					 else if (componentType.equals(SchemaSymbols.ELT_GROUP)) {
						 checkForDuplicateNames(qName, GROUP_TYPE, fUnparsedGroupRegistry, fUnparsedGroupRegistrySub, globalComp, currSchemaDoc);
					 }
					 else if (componentType.equals(SchemaSymbols.ELT_NOTATION)) {
						 checkForDuplicateNames(qName, NOTATION_TYPE, fUnparsedNotationRegistry, fUnparsedNotationRegistrySub, globalComp, currSchemaDoc);
					 }
				 }
			 }
			 DOMUtil.setHidden(currDoc, fHiddenNodes);
			 Vector currSchemaDepends = (Vector)fDependencyMap.get(currSchemaDoc);
			 for (int i = 0;
			 i < currSchemaDepends.size();
			 i++) {
				 schemasToProcess.push(currSchemaDepends.elementAt(i));
			 }
		 }
	 }
	 protected void traverseSchemas(ArrayList annotationInfo) {
		 setSchemasVisible(fRoot);
		 Stack schemasToProcess = new Stack();
		 schemasToProcess.push(fRoot);
		 while (!schemasToProcess.empty()) {
			 XSDocumentInfo currSchemaDoc = (XSDocumentInfo)schemasToProcess.pop();
			 Element currDoc = currSchemaDoc.fSchemaElement;
			 SchemaGrammar currSG = fGrammarBucket.getGrammar(currSchemaDoc.fTargetNamespace);
			 if(DOMUtil.isHidden(currDoc, fHiddenNodes)) {
				 continue;
			 }
			 Element currRoot = currDoc;
			 boolean sawAnnotation = false;
			 for (Element globalComp = DOMUtil.getFirstVisibleChildElement(currRoot, fHiddenNodes);
			 globalComp != null;
			 globalComp = DOMUtil.getNextVisibleSiblingElement(globalComp, fHiddenNodes)) {
				 DOMUtil.setHidden(globalComp, fHiddenNodes);
				 String componentType = DOMUtil.getLocalName(globalComp);
				 if (DOMUtil.getLocalName(globalComp).equals(SchemaSymbols.ELT_REDEFINE)) {
					 currSchemaDoc.backupNSSupport((SchemaNamespaceSupport)fRedefine2NSSupport.get(globalComp));
					 for (Element redefinedComp = DOMUtil.getFirstVisibleChildElement(globalComp, fHiddenNodes);
					 redefinedComp != null;
					 redefinedComp = DOMUtil.getNextVisibleSiblingElement(redefinedComp, fHiddenNodes)) {
						 String redefinedComponentType = DOMUtil.getLocalName(redefinedComp);
						 DOMUtil.setHidden(redefinedComp, fHiddenNodes);
						 if (redefinedComponentType.equals(SchemaSymbols.ELT_ATTRIBUTEGROUP)) {
							 fAttributeGroupTraverser.traverseGlobal(redefinedComp, currSchemaDoc, currSG);
						 }
						 else if (redefinedComponentType.equals(SchemaSymbols.ELT_COMPLEXTYPE)) {
							 fComplexTypeTraverser.traverseGlobal(redefinedComp, currSchemaDoc, currSG);
						 }
						 else if (redefinedComponentType.equals(SchemaSymbols.ELT_GROUP)) {
							 fGroupTraverser.traverseGlobal(redefinedComp, currSchemaDoc, currSG);
						 }
						 else if (redefinedComponentType.equals(SchemaSymbols.ELT_SIMPLETYPE)) {
							 fSimpleTypeTraverser.traverseGlobal(redefinedComp, currSchemaDoc, currSG);
						 }
						 else {
							 reportSchemaError(""s4s-elt-must-match.1"", new Object [] {
							DOMUtil.getLocalName(globalComp), ""(annotation | (simpleType | complexType | group | attributeGroup))*"", redefinedComponentType}
							, redefinedComp);
						 }
					 }
					 currSchemaDoc.restoreNSSupport();
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTE)) {
					 fAttributeTraverser.traverseGlobal(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTEGROUP)) {
					 fAttributeGroupTraverser.traverseGlobal(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_COMPLEXTYPE)) {
					 fComplexTypeTraverser.traverseGlobal(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_ELEMENT)) {
					 fElementTraverser.traverseGlobal(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_GROUP)) {
					 fGroupTraverser.traverseGlobal(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_NOTATION)) {
					 fNotationTraverser.traverse(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_SIMPLETYPE)) {
					 fSimpleTypeTraverser.traverseGlobal(globalComp, currSchemaDoc, currSG);
				 }
				 else if (componentType.equals(SchemaSymbols.ELT_ANNOTATION)) {
					 currSG.addAnnotation(fElementTraverser.traverseAnnotationDecl(globalComp, currSchemaDoc.getSchemaAttrs(), true, currSchemaDoc));
					 sawAnnotation = true;
				 }
				 else {
					 reportSchemaError(""s4s-elt-invalid-content.1"", new Object [] {
					SchemaSymbols.ELT_SCHEMA, DOMUtil.getLocalName(globalComp)}
					, globalComp);
				 }
			 }
			 if (!sawAnnotation) {
				 String text = DOMUtil.getSyntheticAnnotation(currRoot);
				 if (text != null) {
					 currSG.addAnnotation(fElementTraverser.traverseSyntheticAnnotation(currRoot, text, currSchemaDoc.getSchemaAttrs(), true, currSchemaDoc));
				 }
			 }
			 if (annotationInfo != null) {
				 XSAnnotationInfo info = currSchemaDoc.getAnnotations();
				 if (info != null) {
					 annotationInfo.add(doc2SystemId(currDoc));
					 annotationInfo.add(info);
				 }
			 }
			 currSchemaDoc.returnSchemaAttrs();
			 DOMUtil.setHidden(currDoc, fHiddenNodes);
			 Vector currSchemaDepends = (Vector)fDependencyMap.get(currSchemaDoc);
			 for (int i = 0;
			 i < currSchemaDepends.size();
			 i++) {
				 schemasToProcess.push(currSchemaDepends.elementAt(i));
			 }
		 }
	 }
	 private Vector fReportedTNS = null;
	 private final boolean needReportTNSError(String uri) {
		 if (fReportedTNS == null) fReportedTNS = new Vector();
		 else if (fReportedTNS.contains(uri)) return false;
		 fReportedTNS.addElement(uri);
		 return true;
	 }
	 private static final String[] COMP_TYPE = {
	 null, ""attribute declaration"", ""attribute group"", ""element declaration"", ""group"", ""identity constraint"", ""notation"", ""type definition"", }
	;
	 private static final String[] CIRCULAR_CODES = {
	 ""Internal-Error"", ""Internal-Error"", ""src-attribute_group.3"", ""e-props-correct.6"", ""mg-props-correct.2"", ""Internal-Error"", ""Internal-Error"", ""st-props-correct.2"", }
	;
	 void addGlobalAttributeDecl(XSAttributeDecl decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getName() : namespace + "","" + decl.getName();
		 if (fGlobalAttrDecls.get(declKey) == null) {
			 fGlobalAttrDecls.put(declKey, decl);
		 }
	 }
	 void addGlobalAttributeGroupDecl(XSAttributeGroupDecl decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getName() : namespace + "","" + decl.getName();
		 if (fGlobalAttrGrpDecls.get(declKey) == null) {
			 fGlobalAttrGrpDecls.put(declKey, decl);
		 }
	 }
	 void addGlobalElementDecl(XSElementDecl decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getName() : namespace + "","" + decl.getName();
		 if (fGlobalElemDecls.get(declKey) == null) {
			 fGlobalElemDecls.put(declKey, decl);
		 }
	 }
	 void addGlobalGroupDecl(XSGroupDecl decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getName() : namespace + "","" + decl.getName();
		 if (fGlobalGroupDecls.get(declKey) == null) {
			 fGlobalGroupDecls.put(declKey, decl);
		 }
	 }
	 void addGlobalNotationDecl(XSNotationDecl decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getName() : namespace + "","" + decl.getName();
		 if (fGlobalNotationDecls.get(declKey) == null) {
			 fGlobalNotationDecls.put(declKey, decl);
		 }
	 }
	 void addGlobalTypeDecl(XSTypeDefinition decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getName() : namespace + "","" + decl.getName();
		 if (fGlobalTypeDecls.get(declKey) == null) {
			 fGlobalTypeDecls.put(declKey, decl);
		 }
	 }
	 void addIDConstraintDecl(IdentityConstraint decl) {
		 final String namespace = decl.getNamespace();
		 final String declKey = (namespace == null || namespace.length() == 0) ? "","" + decl.getIdentityConstraintName() : namespace + "","" + decl.getIdentityConstraintName();
		 if (fGlobalIDConstraintDecls.get(declKey) == null) {
			 fGlobalIDConstraintDecls.put(declKey, decl);
		 }
	 }
	 private XSAttributeDecl getGlobalAttributeDecl(String declKey) {
		 return (XSAttributeDecl)fGlobalAttrDecls.get(declKey);
	 }
	 private XSAttributeGroupDecl getGlobalAttributeGroupDecl(String declKey) {
		 return (XSAttributeGroupDecl)fGlobalAttrGrpDecls.get(declKey);
	 }
	 private XSElementDecl getGlobalElementDecl(String declKey) {
		 return (XSElementDecl)fGlobalElemDecls.get(declKey);
	 }
	 private XSGroupDecl getGlobalGroupDecl(String declKey) {
		 return (XSGroupDecl)fGlobalGroupDecls.get(declKey);
	 }
	 private XSNotationDecl getGlobalNotationDecl(String declKey) {
		 return (XSNotationDecl)fGlobalNotationDecls.get(declKey);
	 }
	 private XSTypeDefinition getGlobalTypeDecl(String declKey) {
		 return (XSTypeDefinition)fGlobalTypeDecls.get(declKey);
	 }
	 private IdentityConstraint getIDConstraintDecl(String declKey) {
		 return (IdentityConstraint)fGlobalIDConstraintDecls.get(declKey);
	 }
	 protected Object getGlobalDecl(XSDocumentInfo currSchema, int declType, QName declToTraverse, Element elmNode) {
		 if (DEBUG_NODE_POOL) {
			 System.out.println(""TRAVERSE_GL: ""+declToTraverse.toString());
		 }
		 if (declToTraverse.uri != null && declToTraverse.uri == SchemaSymbols.URI_SCHEMAFORSCHEMA) {
			 if (declType == TYPEDECL_TYPE) {
				 Object retObj = SchemaGrammar.SG_SchemaNS.getGlobalTypeDecl(declToTraverse.localpart);
				 if (retObj != null) return retObj;
			 }
		 }
		 if (!currSchema.isAllowedNS(declToTraverse.uri)) {
			 if (currSchema.needReportTNSError(declToTraverse.uri)) {
				 String code = declToTraverse.uri == null ? ""src-resolve.4.1"" : ""src-resolve.4.2"";
				 reportSchemaError(code, new Object[]{
				fDoc2SystemId.get(currSchema.fSchemaElement), declToTraverse.uri, declToTraverse.rawname}
				, elmNode);
			 }
		 }
		 SchemaGrammar sGrammar = fGrammarBucket.getGrammar(declToTraverse.uri);
		 if (sGrammar == null) {
			 if (needReportTNSError(declToTraverse.uri)) reportSchemaError(""src-resolve"", new Object[]{
			declToTraverse.rawname, COMP_TYPE[declType]}
			, elmNode);
			 return null;
		 }
		 Object retObj = getGlobalDeclFromGrammar(sGrammar, declType, declToTraverse.localpart);
		 String declKey = declToTraverse.uri == null? "",""+declToTraverse.localpart: declToTraverse.uri+"",""+declToTraverse.localpart;
		 if (!fTolerateDuplicates) {
			 if (retObj != null) {
				 return retObj;
			 }
		 }
		 else {
			 Object retObj2 = getGlobalDecl(declKey, declType);
			 if (retObj2 != null) {
				 return retObj2;
			 }
		 }
		 XSDocumentInfo schemaWithDecl = null;
		 Element decl = null;
		 XSDocumentInfo declDoc = null;
		 switch (declType) {
			 case ATTRIBUTE_TYPE : decl = (Element)fUnparsedAttributeRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedAttributeRegistrySub.get(declKey);
			 break;
			 case ATTRIBUTEGROUP_TYPE : decl = (Element)fUnparsedAttributeGroupRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedAttributeGroupRegistrySub.get(declKey);
			 break;
			 case ELEMENT_TYPE : decl = (Element)fUnparsedElementRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedElementRegistrySub.get(declKey);
			 break;
			 case GROUP_TYPE : decl = (Element)fUnparsedGroupRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedGroupRegistrySub.get(declKey);
			 break;
			 case IDENTITYCONSTRAINT_TYPE : decl = (Element)fUnparsedIdentityConstraintRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedIdentityConstraintRegistrySub.get(declKey);
			 break;
			 case NOTATION_TYPE : decl = (Element)fUnparsedNotationRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedNotationRegistrySub.get(declKey);
			 break;
			 case TYPEDECL_TYPE : decl = (Element)fUnparsedTypeRegistry.get(declKey);
			 declDoc = (XSDocumentInfo)fUnparsedTypeRegistrySub.get(declKey);
			 break;
			 default: reportSchemaError(""Internal-Error"", new Object [] {
				""XSDHandler asked to locate component of type "" + declType + "";
			 it does not recognize this type!""}
			, elmNode);
		 }
		 if (decl == null) {
			 if (retObj == null) {
				 reportSchemaError(""src-resolve"", new Object[]{
				declToTraverse.rawname, COMP_TYPE[declType]}
				, elmNode);
			 }
			 return retObj;
		 }
		 schemaWithDecl = findXSDocumentForDecl(currSchema, decl, declDoc);
		 if (schemaWithDecl == null) {
			 if (retObj == null) {
				 String code = declToTraverse.uri == null ? ""src-resolve.4.1"" : ""src-resolve.4.2"";
				 reportSchemaError(code, new Object[]{
				fDoc2SystemId.get(currSchema.fSchemaElement), declToTraverse.uri, declToTraverse.rawname}
				, elmNode);
			 }
			 return retObj;
		 }
		 if (DOMUtil.isHidden(decl, fHiddenNodes)) {
			 if (retObj == null) {
				 String code = CIRCULAR_CODES[declType];
				 if (declType == TYPEDECL_TYPE) {
					 if (SchemaSymbols.ELT_COMPLEXTYPE.equals(DOMUtil.getLocalName(decl))) {
						 code = ""ct-props-correct.3"";
					 }
				 }
				 reportSchemaError(code, new Object [] {
				declToTraverse.prefix+"":""+declToTraverse.localpart}
				, elmNode);
			 }
			 return retObj;
		 }
		 return traverseGlobalDecl(declType, decl, schemaWithDecl, sGrammar);
	 }
	 protected Object getGlobalDecl(String declKey, int declType) {
		 Object retObj = null;
		 switch (declType) {
			 case ATTRIBUTE_TYPE : retObj = getGlobalAttributeDecl(declKey);
			 break;
			 case ATTRIBUTEGROUP_TYPE : retObj = getGlobalAttributeGroupDecl(declKey);
			 break;
			 case ELEMENT_TYPE : retObj = getGlobalElementDecl(declKey);
			 break;
			 case GROUP_TYPE : retObj = getGlobalGroupDecl(declKey);
			 break;
			 case IDENTITYCONSTRAINT_TYPE : retObj = getIDConstraintDecl(declKey);
			 break;
			 case NOTATION_TYPE : retObj = getGlobalNotationDecl(declKey);
			 break;
			 case TYPEDECL_TYPE : retObj = getGlobalTypeDecl(declKey);
			 break;
		 }
		 return retObj;
	 }
	 protected Object getGlobalDeclFromGrammar(SchemaGrammar sGrammar, int declType, String localpart) {
		 Object retObj = null;
		 switch (declType) {
			 case ATTRIBUTE_TYPE : retObj = sGrammar.getGlobalAttributeDecl(localpart);
			 break;
			 case ATTRIBUTEGROUP_TYPE : retObj = sGrammar.getGlobalAttributeGroupDecl(localpart);
			 break;
			 case ELEMENT_TYPE : retObj = sGrammar.getGlobalElementDecl(localpart);
			 break;
			 case GROUP_TYPE : retObj = sGrammar.getGlobalGroupDecl(localpart);
			 break;
			 case IDENTITYCONSTRAINT_TYPE : retObj = sGrammar.getIDConstraintDecl(localpart);
			 break;
			 case NOTATION_TYPE : retObj = sGrammar.getGlobalNotationDecl(localpart);
			 break;
			 case TYPEDECL_TYPE : retObj = sGrammar.getGlobalTypeDecl(localpart);
			 break;
		 }
		 return retObj;
	 }
	 protected Object getGlobalDeclFromGrammar(SchemaGrammar sGrammar, int declType, String localpart, String schemaLoc) {
		 Object retObj = null;
		 switch (declType) {
			 case ATTRIBUTE_TYPE : retObj = sGrammar.getGlobalAttributeDecl(localpart, schemaLoc);
			 break;
			 case ATTRIBUTEGROUP_TYPE : retObj = sGrammar.getGlobalAttributeGroupDecl(localpart, schemaLoc);
			 break;
			 case ELEMENT_TYPE : retObj = sGrammar.getGlobalElementDecl(localpart, schemaLoc);
			 break;
			 case GROUP_TYPE : retObj = sGrammar.getGlobalGroupDecl(localpart, schemaLoc);
			 break;
			 case IDENTITYCONSTRAINT_TYPE : retObj = sGrammar.getIDConstraintDecl(localpart, schemaLoc);
			 break;
			 case NOTATION_TYPE : retObj = sGrammar.getGlobalNotationDecl(localpart, schemaLoc);
			 break;
			 case TYPEDECL_TYPE : retObj = sGrammar.getGlobalTypeDecl(localpart, schemaLoc);
			 break;
		 }
		 return retObj;
	 }
	 protected Object traverseGlobalDecl(int declType, Element decl, XSDocumentInfo schemaDoc, SchemaGrammar grammar) {
		 Object retObj = null;
		 DOMUtil.setHidden(decl, fHiddenNodes);
		 SchemaNamespaceSupport nsSupport = null;
		 Element parent = DOMUtil.getParent(decl);
		 if (DOMUtil.getLocalName(parent).equals(SchemaSymbols.ELT_REDEFINE)) nsSupport = (SchemaNamespaceSupport)fRedefine2NSSupport.get(parent);
		 schemaDoc.backupNSSupport(nsSupport);
		 switch (declType) {
			 case TYPEDECL_TYPE : if (DOMUtil.getLocalName(decl).equals(SchemaSymbols.ELT_COMPLEXTYPE)) {
				 retObj = fComplexTypeTraverser.traverseGlobal(decl, schemaDoc, grammar);
			 }
			 else {
				 retObj = fSimpleTypeTraverser.traverseGlobal(decl, schemaDoc, grammar);
			 }
			 break;
			 case ATTRIBUTE_TYPE : retObj = fAttributeTraverser.traverseGlobal(decl, schemaDoc, grammar);
			 break;
			 case ELEMENT_TYPE : retObj = fElementTraverser.traverseGlobal(decl, schemaDoc, grammar);
			 break;
			 case ATTRIBUTEGROUP_TYPE : retObj = fAttributeGroupTraverser.traverseGlobal(decl, schemaDoc, grammar);
			 break;
			 case GROUP_TYPE : retObj = fGroupTraverser.traverseGlobal(decl, schemaDoc, grammar);
			 break;
			 case NOTATION_TYPE : retObj = fNotationTraverser.traverse(decl, schemaDoc, grammar);
			 break;
			 case IDENTITYCONSTRAINT_TYPE : break;
		 }
		 schemaDoc.restoreNSSupport();
		 return retObj;
	 }
	 public String schemaDocument2SystemId(XSDocumentInfo schemaDoc) {
		 return (String)fDoc2SystemId.get(schemaDoc.fSchemaElement);
	 }
	 Object getGrpOrAttrGrpRedefinedByRestriction(int type, QName name, XSDocumentInfo currSchema, Element elmNode) {
		 String realName = name.uri != null?name.uri+"",""+name.localpart: "",""+name.localpart;
		 String nameToFind = null;
		 switch (type) {
			 case ATTRIBUTEGROUP_TYPE: nameToFind = (String)fRedefinedRestrictedAttributeGroupRegistry.get(realName);
			 break;
			 case GROUP_TYPE: nameToFind = (String)fRedefinedRestrictedGroupRegistry.get(realName);
			 break;
			 default: return null;
		 }
		 if (nameToFind == null) return null;
		 int commaPos = nameToFind.indexOf("","");
		 QName qNameToFind = new QName(XMLSymbols.EMPTY_STRING, nameToFind.substring(commaPos+1), nameToFind.substring(commaPos), (commaPos == 0)? null : nameToFind.substring(0, commaPos));
		 Object retObj = getGlobalDecl(currSchema, type, qNameToFind, elmNode);
		 if(retObj == null) {
			 switch (type) {
				 case ATTRIBUTEGROUP_TYPE: reportSchemaError(""src-redefine.7.2.1"", new Object []{
				name.localpart}
				, elmNode);
				 break;
				 case GROUP_TYPE: reportSchemaError(""src-redefine.6.2.1"", new Object []{
				name.localpart}
				, elmNode);
				 break;
			 }
			 return null;
		 }
		 return retObj;
	 }
	 protected void resolveKeyRefs() {
		 for (int i=0;
		 i<fKeyrefStackPos;
		 i++) {
			 XSDocumentInfo keyrefSchemaDoc = fKeyrefsMapXSDocumentInfo[i];
			 keyrefSchemaDoc.fNamespaceSupport.makeGlobal();
			 keyrefSchemaDoc.fNamespaceSupport.setEffectiveContext( fKeyrefNamespaceContext[i] );
			 SchemaGrammar keyrefGrammar = fGrammarBucket.getGrammar(keyrefSchemaDoc.fTargetNamespace);
			 DOMUtil.setHidden(fKeyrefs[i], fHiddenNodes);
			 fKeyrefTraverser.traverse(fKeyrefs[i], fKeyrefElems[i], keyrefSchemaDoc, keyrefGrammar);
		 }
	 }
	 protected Hashtable getIDRegistry() {
		 return fUnparsedIdentityConstraintRegistry;
	 }
	 protected Hashtable getIDRegistry_sub() {
		 return fUnparsedIdentityConstraintRegistrySub;
	 }
	 protected void storeKeyRef (Element keyrefToStore, XSDocumentInfo schemaDoc, XSElementDecl currElemDecl) {
		 String keyrefName = DOMUtil.getAttrValue(keyrefToStore, SchemaSymbols.ATT_NAME);
		 if (keyrefName.length() != 0) {
			 String keyrefQName = schemaDoc.fTargetNamespace == null? "","" + keyrefName: schemaDoc.fTargetNamespace+"",""+keyrefName;
			 checkForDuplicateNames(keyrefQName, IDENTITYCONSTRAINT_TYPE, fUnparsedIdentityConstraintRegistry, fUnparsedIdentityConstraintRegistrySub, keyrefToStore, schemaDoc);
		 }
		 if (fKeyrefStackPos == fKeyrefs.length) {
			 Element [] elemArray = new Element [fKeyrefStackPos + INC_KEYREF_STACK_AMOUNT];
			 System.arraycopy(fKeyrefs, 0, elemArray, 0, fKeyrefStackPos);
			 fKeyrefs = elemArray;
			 XSElementDecl [] declArray = new XSElementDecl [fKeyrefStackPos + INC_KEYREF_STACK_AMOUNT];
			 System.arraycopy(fKeyrefElems, 0, declArray, 0, fKeyrefStackPos);
			 fKeyrefElems = declArray;
			 String[][] stringArray = new String [fKeyrefStackPos + INC_KEYREF_STACK_AMOUNT][];
			 System.arraycopy(fKeyrefNamespaceContext, 0, stringArray, 0, fKeyrefStackPos);
			 fKeyrefNamespaceContext = stringArray;
			 XSDocumentInfo [] xsDocumentInfo = new XSDocumentInfo [fKeyrefStackPos + INC_KEYREF_STACK_AMOUNT];
			 System.arraycopy(fKeyrefsMapXSDocumentInfo, 0, xsDocumentInfo, 0, fKeyrefStackPos);
			 fKeyrefsMapXSDocumentInfo = xsDocumentInfo;
		 }
		 fKeyrefs[fKeyrefStackPos] = keyrefToStore;
		 fKeyrefElems[fKeyrefStackPos] = currElemDecl;
		 fKeyrefNamespaceContext[fKeyrefStackPos] = schemaDoc.fNamespaceSupport.getEffectiveLocalContext();
		 fKeyrefsMapXSDocumentInfo[fKeyrefStackPos++] = schemaDoc;
	 }
	 private Element resolveSchema(XSDDescription desc, boolean mustResolve, Element referElement, boolean usePairs) {
		 XMLInputSource schemaSource = null;
		 try {
			 Hashtable pairs = usePairs ? fLocationPairs : EMPTY_TABLE;
			 schemaSource = XMLSchemaLoader.resolveDocument(desc, pairs, fEntityResolver);
		 }
		 catch (IOException ex) {
			 if (mustResolve) {
				 reportSchemaError(""schema_reference.4"", new Object[]{
				desc.getLocationHints()[0]}
				, referElement);
			 }
			 else {
				 reportSchemaWarning(""schema_reference.4"", new Object[]{
				desc.getLocationHints()[0]}
				, referElement);
			 }
		 }
		 if (schemaSource instanceof DOMInputSource) {
			 return getSchemaDocument(desc.getTargetNamespace(), (DOMInputSource) schemaSource, mustResolve, desc.getContextType(), referElement);
		 }
		 else if (schemaSource instanceof SAXInputSource) {
			 return getSchemaDocument(desc.getTargetNamespace(), (SAXInputSource) schemaSource, mustResolve, desc.getContextType(), referElement);
		 }
		 else if (schemaSource instanceof StAXInputSource) {
			 return getSchemaDocument(desc.getTargetNamespace(), (StAXInputSource) schemaSource, mustResolve, desc.getContextType(), referElement);
		 }
		 else if (schemaSource instanceof XSInputSource) {
			 return getSchemaDocument((XSInputSource) schemaSource, desc);
		 }
		 return getSchemaDocument(desc.getTargetNamespace(), schemaSource, mustResolve, desc.getContextType(), referElement);
	 }
	 private Element resolveSchema(XMLInputSource schemaSource, XSDDescription desc, boolean mustResolve, Element referElement) {
		 if (schemaSource instanceof DOMInputSource) {
			 return getSchemaDocument(desc.getTargetNamespace(), (DOMInputSource) schemaSource, mustResolve, desc.getContextType(), referElement);
		 }
		 else if (schemaSource instanceof SAXInputSource) {
			 return getSchemaDocument(desc.getTargetNamespace(), (SAXInputSource) schemaSource, mustResolve, desc.getContextType(), referElement);
		 }
		 else if (schemaSource instanceof StAXInputSource) {
			 return getSchemaDocument(desc.getTargetNamespace(), (StAXInputSource) schemaSource, mustResolve, desc.getContextType(), referElement);
		 }
		 else if (schemaSource instanceof XSInputSource) {
			 return getSchemaDocument((XSInputSource) schemaSource, desc);
		 }
		 return getSchemaDocument(desc.getTargetNamespace(), schemaSource, mustResolve, desc.getContextType(), referElement);
	 }
	 private XMLInputSource resolveSchemaSource(XSDDescription desc, boolean mustResolve, Element referElement, boolean usePairs) {
		 XMLInputSource schemaSource = null;
		 try {
			 Hashtable pairs = usePairs ? fLocationPairs : EMPTY_TABLE;
			 schemaSource = XMLSchemaLoader.resolveDocument(desc, pairs, fEntityResolver);
		 }
		 catch (IOException ex) {
			 if (mustResolve) {
				 reportSchemaError(""schema_reference.4"", new Object[]{
				desc.getLocationHints()[0]}
				, referElement);
			 }
			 else {
				 reportSchemaWarning(""schema_reference.4"", new Object[]{
				desc.getLocationHints()[0]}
				, referElement);
			 }
		 }
		 return schemaSource;
	 }
	 private Element getSchemaDocument(String schemaNamespace, XMLInputSource schemaSource, boolean mustResolve, short referType, Element referElement) {
		 boolean hasInput = true;
		 IOException exception = null;
		 Element schemaElement = null;
		 try {
			 if (schemaSource != null && (schemaSource.getSystemId() != null || schemaSource.getByteStream() != null || schemaSource.getCharacterStream() != null)) {
				 XSDKey key = null;
				 String schemaId = null;
				 if (referType != XSDDescription.CONTEXT_PREPARSE){
					 schemaId = XMLEntityManager.expandSystemId(schemaSource.getSystemId(), schemaSource.getBaseSystemId(), false);
					 key = new XSDKey(schemaId, referType, schemaNamespace);
					 if((schemaElement = (Element)fTraversed.get(key)) != null) {
						 fLastSchemaWasDuplicate = true;
						 return schemaElement;
					 }
				 }
				 fSchemaParser.parse(schemaSource);
				 Document schemaDocument = fSchemaParser.getDocument();
				 schemaElement = schemaDocument != null ? DOMUtil.getRoot(schemaDocument) : null;
				 return getSchemaDocument0(key, schemaId, schemaElement);
			 }
			 else {
				 hasInput = false;
			 }
		 }
		 catch (IOException ex) {
			 exception = ex;
		 }
		 return getSchemaDocument1(mustResolve, hasInput, schemaSource, referElement, exception);
	 }
	 private Element getSchemaDocument(String schemaNamespace, SAXInputSource schemaSource, boolean mustResolve, short referType, Element referElement) {
		 XMLReader parser = schemaSource.getXMLReader();
		 InputSource inputSource = schemaSource.getInputSource();
		 boolean hasInput = true;
		 IOException exception = null;
		 Element schemaElement = null;
		 try {
			 if (inputSource != null && (inputSource.getSystemId() != null || inputSource.getByteStream() != null || inputSource.getCharacterStream() != null)) {
				 XSDKey key = null;
				 String schemaId = null;
				 if (referType != XSDDescription.CONTEXT_PREPARSE) {
					 schemaId = XMLEntityManager.expandSystemId(inputSource.getSystemId(), schemaSource.getBaseSystemId(), false);
					 key = new XSDKey(schemaId, referType, schemaNamespace);
					 if ((schemaElement = (Element) fTraversed.get(key)) != null) {
						 fLastSchemaWasDuplicate = true;
						 return schemaElement;
					 }
				 }
				 boolean namespacePrefixes = false;
				 if (parser != null) {
					 try {
						 namespacePrefixes = parser.getFeature(NAMESPACE_PREFIXES);
					 }
					 catch (SAXException se) {
					}
				 }
				 else {
					 try {
						 parser = XMLReaderFactory.createXMLReader();
					 }
					 catch (SAXException se) {
						 parser = new SAXParser();
					 }
					 try {
						 parser.setFeature(NAMESPACE_PREFIXES, true);
						 namespacePrefixes = true;
						 if (parser instanceof SAXParser) {
							 Object securityManager = fSchemaParser.getProperty(SECURITY_MANAGER);
							 if (securityManager != null) {
								 parser.setProperty(SECURITY_MANAGER, securityManager);
							 }
						 }
					 }
					 catch (SAXException se) {
					}
				 }
				 boolean stringsInternalized = false;
				 try {
					 stringsInternalized = parser.getFeature(STRING_INTERNING);
				 }
				 catch (SAXException exc) {
				 }
				 if (fXSContentHandler == null) {
					 fXSContentHandler = new SchemaContentHandler();
				 }
				 fXSContentHandler.reset(fSchemaParser, fSymbolTable, namespacePrefixes, stringsInternalized);
				 parser.setContentHandler(fXSContentHandler);
				 parser.setErrorHandler(fErrorReporter.getSAXErrorHandler());
				 parser.parse(inputSource);
				 try {
					 parser.setContentHandler(null);
					 parser.setErrorHandler(null);
				 }
				 catch (Exception e) {
				}
				 Document schemaDocument = fXSContentHandler.getDocument();
				 schemaElement = schemaDocument != null ? DOMUtil.getRoot(schemaDocument) : null;
				 return getSchemaDocument0(key, schemaId, schemaElement);
			 }
			 else {
				 hasInput = false;
			 }
		 }
		 catch (SAXParseException spe) {
			 throw SAX2XNIUtil.createXMLParseException0(spe);
		 }
		 catch (SAXException se) {
			 throw SAX2XNIUtil.createXNIException0(se);
		 }
		 catch (IOException ioe) {
			 exception = ioe;
		 }
		 return getSchemaDocument1(mustResolve, hasInput, schemaSource, referElement, exception);
	 }
	 private Element getSchemaDocument(String schemaNamespace, DOMInputSource schemaSource, boolean mustResolve, short referType, Element referElement) {
		 boolean hasInput = true;
		 IOException exception = null;
		 Element schemaElement = null;
		 Element schemaRootElement = null;
		 final Node node = schemaSource.getNode();
		 short nodeType = -1;
		 if (node != null) {
			 nodeType = node.getNodeType();
			 if (nodeType == Node.DOCUMENT_NODE) {
				 schemaRootElement = DOMUtil.getRoot((Document) node);
			 }
			 else if (nodeType == Node.ELEMENT_NODE) {
				 schemaRootElement = (Element) node;
			 }
		 }
		 try {
			 if (schemaRootElement != null) {
				 XSDKey key = null;
				 String schemaId = null;
				 if (referType != XSDDescription.CONTEXT_PREPARSE) {
					 schemaId = XMLEntityManager.expandSystemId(schemaSource.getSystemId(), schemaSource.getBaseSystemId(), false);
					 boolean isDocument = (nodeType == Node.DOCUMENT_NODE);
					 if (!isDocument) {
						 Node parent = schemaRootElement.getParentNode();
						 if (parent != null) {
							 isDocument = (parent.getNodeType() == Node.DOCUMENT_NODE);
						 }
					 }
					 if (isDocument) {
						 key = new XSDKey(schemaId, referType, schemaNamespace);
						 if ((schemaElement = (Element) fTraversed.get(key)) != null) {
							 fLastSchemaWasDuplicate = true;
							 return schemaElement;
						 }
					 }
				 }
				 schemaElement = schemaRootElement;
				 return getSchemaDocument0(key, schemaId, schemaElement);
			 }
			 else {
				 hasInput = false;
			 }
		 }
		 catch (IOException ioe) {
			 exception = ioe;
		 }
		 return getSchemaDocument1(mustResolve, hasInput, schemaSource, referElement, exception);
	 }
	 private Element getSchemaDocument(String schemaNamespace, StAXInputSource schemaSource, boolean mustResolve, short referType, Element referElement) {
		 IOException exception = null;
		 Element schemaElement = null;
		 try {
			 final boolean consumeRemainingContent = schemaSource.shouldConsumeRemainingContent();
			 final XMLStreamReader streamReader = schemaSource.getXMLStreamReader();
			 final XMLEventReader eventReader = schemaSource.getXMLEventReader();
			 XSDKey key = null;
			 String schemaId = null;
			 if (referType != XSDDescription.CONTEXT_PREPARSE) {
				 schemaId = XMLEntityManager.expandSystemId(schemaSource.getSystemId(), schemaSource.getBaseSystemId(), false);
				 boolean isDocument = consumeRemainingContent;
				 if (!isDocument) {
					 if (streamReader != null) {
						 isDocument = (streamReader.getEventType() == XMLStreamReader.START_DOCUMENT);
					 }
					 else {
						 isDocument = eventReader.peek().isStartDocument();
					 }
				 }
				 if (isDocument) {
					 key = new XSDKey(schemaId, referType, schemaNamespace);
					 if ((schemaElement = (Element) fTraversed.get(key)) != null) {
						 fLastSchemaWasDuplicate = true;
						 return schemaElement;
					 }
				 }
			 }
			 if (fStAXSchemaParser == null) {
				 fStAXSchemaParser = new StAXSchemaParser();
			 }
			 fStAXSchemaParser.reset(fSchemaParser, fSymbolTable);
			 if (streamReader != null) {
				 fStAXSchemaParser.parse(streamReader);
				 if (consumeRemainingContent) {
					 while (streamReader.hasNext()) {
						 streamReader.next();
					 }
				 }
			 }
			 else {
				 fStAXSchemaParser.parse(eventReader);
				 if (consumeRemainingContent) {
					 while (eventReader.hasNext()) {
						 eventReader.nextEvent();
					 }
				 }
			 }
			 Document schemaDocument = fStAXSchemaParser.getDocument();
			 schemaElement = schemaDocument != null ? DOMUtil.getRoot(schemaDocument) : null;
			 return getSchemaDocument0(key, schemaId, schemaElement);
		 }
		 catch (XMLStreamException e) {
			 StAXLocationWrapper slw = new StAXLocationWrapper();
			 slw.setLocation(e.getLocation());
			 throw new XMLParseException(slw, e.getMessage(), e);
		 }
		 catch (IOException e) {
			 exception = e;
		 }
		 return getSchemaDocument1(mustResolve, true, schemaSource, referElement, exception);
	 }
	 private Element getSchemaDocument0(XSDKey key, String schemaId, Element schemaElement) {
		 if (key != null) {
			 fTraversed.put(key, schemaElement);
		 }
		 if (schemaId != null) {
			 fDoc2SystemId.put(schemaElement, schemaId);
		 }
		 fLastSchemaWasDuplicate = false;
		 return schemaElement;
	 }
	 private Element getSchemaDocument1(boolean mustResolve, boolean hasInput, XMLInputSource schemaSource, Element referElement, IOException ioe) {
		 if (mustResolve) {
			 if (hasInput) {
				 reportSchemaError(""schema_reference.4"", new Object[]{
				schemaSource.getSystemId()}
				, referElement, ioe);
			 }
			 else {
				 reportSchemaError(""schema_reference.4"", new Object[]{
				schemaSource == null ? """" : schemaSource.getSystemId()}
				, referElement, ioe);
			 }
		 }
		 else if (hasInput) {
			 reportSchemaWarning(""schema_reference.4"", new Object[]{
			schemaSource.getSystemId()}
			, referElement, ioe);
		 }
		 fLastSchemaWasDuplicate = false;
		 return null;
	 }
	 private Element getSchemaDocument(XSInputSource schemaSource, XSDDescription desc) {
		 SchemaGrammar[] grammars = schemaSource.getGrammars();
		 short referType = desc.getContextType();
		 if (grammars != null && grammars.length > 0) {
			 Vector expandedGrammars = expandGrammars(grammars);
			 if (fNamespaceGrowth || !existingGrammars(expandedGrammars)) {
				 addGrammars(expandedGrammars);
				 if (referType == XSDDescription.CONTEXT_PREPARSE) {
					 desc.setTargetNamespace(grammars[0].getTargetNamespace());
				 }
			 }
		 }
		 else {
			 XSObject[] components = schemaSource.getComponents();
			 if (components != null && components.length > 0) {
				 Hashtable importDependencies = new Hashtable();
				 Vector expandedComponents = expandComponents(components, importDependencies);
				 if (fNamespaceGrowth || canAddComponents(expandedComponents)) {
					 addGlobalComponents(expandedComponents, importDependencies);
					 if (referType == XSDDescription.CONTEXT_PREPARSE) {
						 desc.setTargetNamespace(components[0].getNamespace());
					 }
				 }
			 }
		 }
		 return null;
	 }
	 private Vector expandGrammars(SchemaGrammar[] grammars) {
		 Vector currGrammars = new Vector();
		 for (int i=0;
		 i<grammars.length;
		 i++) {
			 if (!currGrammars.contains(grammars[i])) {
				 currGrammars.add(grammars[i]);
			 }
		 }
		 SchemaGrammar sg1, sg2;
		 Vector gs;
		 for (int i = 0;
		 i < currGrammars.size();
		 i++) {
			 sg1 = (SchemaGrammar)currGrammars.elementAt(i);
			 gs = sg1.getImportedGrammars();
			 if (gs == null) {
				 continue;
			 }
			 for (int j = gs.size() - 1;
			 j >= 0;
			 j--) {
				 sg2 = (SchemaGrammar)gs.elementAt(j);
				 if (!currGrammars.contains(sg2)) {
					 currGrammars.addElement(sg2);
				 }
			 }
		 }
		 return currGrammars;
	 }
	 private boolean existingGrammars(Vector grammars) {
		 int length = grammars.size();
		 final XSDDescription desc = new XSDDescription();
		 for (int i=0;
		 i < length;
		 i++) {
			 final SchemaGrammar sg1 = (SchemaGrammar)grammars.elementAt(i);
			 desc.setNamespace(sg1.getTargetNamespace());
			 final SchemaGrammar sg2 = findGrammar(desc, false);
			 if (sg2 != null) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private boolean canAddComponents(Vector components) {
		 final int size = components.size();
		 final XSDDescription desc = new XSDDescription();
		 for (int i=0;
		 i<size;
		 i++) {
			 XSObject component = (XSObject) components.elementAt(i);
			 if (!canAddComponent(component, desc)) {
				 return false;
			 }
		 }
		 return true;
	 }
	 private boolean canAddComponent(XSObject component, XSDDescription desc) {
		 desc.setNamespace(component.getNamespace());
		 final SchemaGrammar sg = findGrammar(desc, false);
		 if (sg == null) {
			 return true;
		 }
		 else if (sg.isImmutable()) {
			 return false;
		 }
		 short componentType = component.getType();
		 final String name = component.getName();
		 switch (componentType) {
			 case XSConstants.TYPE_DEFINITION : if (sg.getGlobalTypeDecl(name) == component) {
				 return true;
			 }
			 break;
			 case XSConstants.ATTRIBUTE_DECLARATION : if (sg.getGlobalAttributeDecl(name) == component) {
				 return true;
			 }
			 break;
			 case XSConstants.ATTRIBUTE_GROUP : if (sg.getGlobalAttributeDecl(name) == component) {
				 return true;
			 }
			 break;
			 case XSConstants.ELEMENT_DECLARATION : if (sg.getGlobalElementDecl(name) == component) {
				 return true;
			 }
			 break;
			 case XSConstants.MODEL_GROUP_DEFINITION : if (sg.getGlobalGroupDecl(name) == component) {
				 return true;
			 }
			 break;
			 case XSConstants.NOTATION_DECLARATION : if (sg.getGlobalNotationDecl(name) == component) {
				 return true;
			 }
			 break;
			 case XSConstants.IDENTITY_CONSTRAINT : case XSConstants.ATTRIBUTE_USE : default : return true;
		 }
		 return false;
	 }
	 private void addGrammars(Vector grammars) {
		 int length = grammars.size();
		 XSDDescription desc = new XSDDescription();
		 for (int i=0;
		 i < length;
		 i++) {
			 final SchemaGrammar sg1 = (SchemaGrammar)grammars.elementAt(i);
			 desc.setNamespace(sg1.getTargetNamespace());
			 final SchemaGrammar sg2 = findGrammar(desc, fNamespaceGrowth);
			 if (sg1 != sg2) {
				 addGrammarComponents(sg1, sg2);
			 }
		 }
	 }
	 private void addGrammarComponents(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 if (dstGrammar == null) {
			 createGrammarFrom(srcGrammar);
			 return;
		 }
		 SchemaGrammar tmpGrammar = dstGrammar;
		 if (tmpGrammar.isImmutable()) {
			 tmpGrammar = createGrammarFrom(dstGrammar);
		 }
		 addNewGrammarLocations(srcGrammar, tmpGrammar);
		 addNewImportedGrammars(srcGrammar, tmpGrammar);
		 addNewGrammarComponents(srcGrammar, tmpGrammar);
	 }
	 private SchemaGrammar createGrammarFrom(SchemaGrammar grammar) {
		 SchemaGrammar newGrammar = new SchemaGrammar(grammar);
		 fGrammarBucket.putGrammar(newGrammar);
		 updateImportListWith(newGrammar);
		 updateImportListFor(newGrammar);
		 return newGrammar;
	 }
	 private void addNewGrammarLocations(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 final StringList locations = srcGrammar.getDocumentLocations();
		 final int locSize = locations.size();
		 final StringList locations2 = dstGrammar.getDocumentLocations();
		 for (int i=0;
		 i<locSize;
		 i++) {
			 String loc = locations.item(i);
			 if (!locations2.contains(loc)) {
				 dstGrammar.addDocument(null, loc);
			 }
		 }
	 }
	 private void addNewImportedGrammars(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 final Vector igs1 = srcGrammar.getImportedGrammars();
		 if (igs1 != null) {
			 Vector igs2 = dstGrammar.getImportedGrammars();
			 if (igs2 == null) {
				 igs2 = ((Vector) igs1.clone());
				 dstGrammar.setImportedGrammars(igs2);
			 }
			 else {
				 updateImportList(igs1, igs2);
			 }
		 }
	 }
	 private void updateImportList(Vector importedSrc, Vector importedDst) {
		 final int size = importedSrc.size();
		 for (int i=0;
		 i<size;
		 i++) {
			 final SchemaGrammar sg = (SchemaGrammar) importedSrc.elementAt(i);
			 if (!containedImportedGrammar(importedDst, sg)) {
				 importedDst.add(sg);
			 }
		 }
	 }
	 private void addNewGrammarComponents(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 dstGrammar.resetComponents();
		 addGlobalElementDecls(srcGrammar, dstGrammar);
		 addGlobalAttributeDecls(srcGrammar, dstGrammar);
		 addGlobalAttributeGroupDecls(srcGrammar, dstGrammar);
		 addGlobalGroupDecls(srcGrammar, dstGrammar);
		 addGlobalTypeDecls(srcGrammar, dstGrammar);
		 addGlobalNotationDecls(srcGrammar, dstGrammar);
	 }
	 private void addGlobalElementDecls(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 XSNamedMap components = srcGrammar.getComponents(XSConstants.ELEMENT_DECLARATION);
		 int len = components.getLength();
		 XSElementDecl srcDecl, dstDecl;
		 for (int i=0;
		 i<len;
		 i++) {
			 srcDecl = (XSElementDecl) components.item(i);
			 dstDecl = dstGrammar.getGlobalElementDecl(srcDecl.getName());
			 if (dstDecl == null) {
				 dstGrammar.addGlobalElementDecl(srcDecl);
			 }
			 else if (dstDecl != srcDecl){
			 }
		 }
		 ObjectList componentsExt = srcGrammar.getComponentsExt(XSConstants.ELEMENT_DECLARATION);
		 len = componentsExt.getLength();
		 for (int i=0;
		 i<len;
		 i+= 2) {
			 final String key = (String) componentsExt.item(i);
			 final int index = key.indexOf(',');
			 final String location = key.substring(0, index);
			 final String name = key.substring(index + 1, key.length());
			 srcDecl = (XSElementDecl)componentsExt.item(i+1);
			 dstDecl = dstGrammar.getGlobalElementDecl(name, location);
			 if ( dstDecl == null) {
				 dstGrammar.addGlobalElementDecl(srcDecl, location);
			 }
			 else if (dstDecl != srcDecl){
			 }
		 }
	 }
	 private void addGlobalAttributeDecls(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 XSNamedMap components = srcGrammar.getComponents(XSConstants.ATTRIBUTE_DECLARATION);
		 int len = components.getLength();
		 XSAttributeDecl srcDecl, dstDecl;
		 for (int i=0;
		 i<len;
		 i++) {
			 srcDecl = (XSAttributeDecl) components.item(i);
			 dstDecl = dstGrammar.getGlobalAttributeDecl(srcDecl.getName());
			 if (dstDecl == null) {
				 dstGrammar.addGlobalAttributeDecl(srcDecl);
			 }
			 else if (dstDecl != srcDecl && !fTolerateDuplicates) {
				 reportSharingError(srcDecl.getNamespace(), srcDecl.getName());
			 }
		 }
		 ObjectList componentsExt = srcGrammar.getComponentsExt(XSConstants.ATTRIBUTE_DECLARATION);
		 len = componentsExt.getLength();
		 for (int i=0;
		 i<len;
		 i+= 2) {
			 final String key = (String) componentsExt.item(i);
			 final int index = key.indexOf(',');
			 final String location = key.substring(0, index);
			 final String name = key.substring(index + 1, key.length());
			 srcDecl = (XSAttributeDecl)componentsExt.item(i+1);
			 dstDecl = dstGrammar.getGlobalAttributeDecl(name, location);
			 if (dstDecl == null) {
				 dstGrammar.addGlobalAttributeDecl(srcDecl, location);
			 }
			 else if (dstDecl != srcDecl) {
			 }
		 }
	 }
	 private void addGlobalAttributeGroupDecls(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 XSNamedMap components = srcGrammar.getComponents(XSConstants.ATTRIBUTE_GROUP);
		 int len = components.getLength();
		 XSAttributeGroupDecl srcDecl, dstDecl;
		 for (int i=0;
		 i<len;
		 i++) {
			 srcDecl = (XSAttributeGroupDecl) components.item(i);
			 dstDecl = dstGrammar.getGlobalAttributeGroupDecl(srcDecl.getName());
			 if (dstDecl == null) {
				 dstGrammar.addGlobalAttributeGroupDecl(srcDecl);
			 }
			 else if (dstDecl != srcDecl && !fTolerateDuplicates) {
				 reportSharingError(srcDecl.getNamespace(), srcDecl.getName());
			 }
		 }
		 ObjectList componentsExt = srcGrammar.getComponentsExt(XSConstants.ATTRIBUTE_GROUP);
		 len = componentsExt.getLength();
		 for (int i=0;
		 i<len;
		 i+= 2) {
			 final String key = (String) componentsExt.item(i);
			 final int index = key.indexOf(',');
			 final String location = key.substring(0, index);
			 final String name = key.substring(index + 1, key.length());
			 srcDecl = (XSAttributeGroupDecl)componentsExt.item(i+1);
			 dstDecl = dstGrammar.getGlobalAttributeGroupDecl(name, location);
			 if (dstDecl == null) {
				 dstGrammar.addGlobalAttributeGroupDecl(srcDecl, location);
			 }
			 else if (dstDecl != srcDecl) {
			 }
		 }
	 }
	 private void addGlobalNotationDecls(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 XSNamedMap components = srcGrammar.getComponents(XSConstants.NOTATION_DECLARATION);
		 int len = components.getLength();
		 XSNotationDecl srcDecl, dstDecl;
		 for (int i=0;
		 i<len;
		 i++) {
			 srcDecl = (XSNotationDecl) components.item(i);
			 dstDecl = dstGrammar.getGlobalNotationDecl(srcDecl.getName());
			 if (dstDecl == null) {
				 dstGrammar.addGlobalNotationDecl(srcDecl);
			 }
			 else if (dstDecl != srcDecl && !fTolerateDuplicates) {
				 reportSharingError(srcDecl.getNamespace(), srcDecl.getName());
			 }
		 }
		 ObjectList componentsExt = srcGrammar.getComponentsExt(XSConstants.NOTATION_DECLARATION);
		 len = componentsExt.getLength();
		 for (int i=0;
		 i<len;
		 i+= 2) {
			 final String key = (String) componentsExt.item(i);
			 final int index = key.indexOf(',');
			 final String location = key.substring(0, index);
			 final String name = key.substring(index + 1, key.length());
			 srcDecl = (XSNotationDecl)componentsExt.item(i+1);
			 dstDecl = dstGrammar.getGlobalNotationDecl(name, location);
			 if (dstDecl == null) {
				 dstGrammar.addGlobalNotationDecl(srcDecl, location);
			 }
			 else if (dstDecl != srcDecl) {
			 }
		 }
	 }
	 private void addGlobalGroupDecls(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 XSNamedMap components = srcGrammar.getComponents(XSConstants.MODEL_GROUP_DEFINITION);
		 int len = components.getLength();
		 XSGroupDecl srcDecl, dstDecl;
		 for (int i=0;
		 i<len;
		 i++) {
			 srcDecl = (XSGroupDecl) components.item(i);
			 dstDecl = dstGrammar.getGlobalGroupDecl(srcDecl.getName());
			 if (dstDecl == null) {
				 dstGrammar.addGlobalGroupDecl(srcDecl);
			 }
			 else if (srcDecl != dstDecl && !fTolerateDuplicates) {
				 reportSharingError(srcDecl.getNamespace(), srcDecl.getName());
			 }
		 }
		 ObjectList componentsExt = srcGrammar.getComponentsExt(XSConstants.MODEL_GROUP_DEFINITION);
		 len = componentsExt.getLength();
		 for (int i=0;
		 i<len;
		 i+= 2) {
			 final String key = (String) componentsExt.item(i);
			 final int index = key.indexOf(',');
			 final String location = key.substring(0, index);
			 final String name = key.substring(index + 1, key.length());
			 srcDecl = (XSGroupDecl)componentsExt.item(i+1);
			 dstDecl = dstGrammar.getGlobalGroupDecl(name, location);
			 if (dstDecl == null) {
				 dstGrammar.addGlobalGroupDecl(srcDecl, location);
			 }
			 else if (dstDecl != srcDecl) {
			 }
		 }
	 }
	 private void addGlobalTypeDecls(SchemaGrammar srcGrammar, SchemaGrammar dstGrammar) {
		 XSNamedMap components = srcGrammar.getComponents(XSConstants.TYPE_DEFINITION);
		 int len = components.getLength();
		 XSTypeDefinition srcDecl, dstDecl;
		 for (int i=0;
		 i<len;
		 i++) {
			 srcDecl = (XSTypeDefinition) components.item(i);
			 dstDecl = dstGrammar.getGlobalTypeDecl(srcDecl.getName());
			 if (dstDecl == null) {
				 dstGrammar.addGlobalTypeDecl(srcDecl);
			 }
			 else if (dstDecl != srcDecl && !fTolerateDuplicates) {
				 reportSharingError(srcDecl.getNamespace(), srcDecl.getName());
			 }
		 }
		 ObjectList componentsExt = srcGrammar.getComponentsExt(XSConstants.TYPE_DEFINITION);
		 len = componentsExt.getLength();
		 for (int i=0;
		 i<len;
		 i+= 2) {
			 final String key = (String) componentsExt.item(i);
			 final int index = key.indexOf(',');
			 final String location = key.substring(0, index);
			 final String name = key.substring(index + 1, key.length());
			 srcDecl = (XSTypeDefinition)componentsExt.item(i+1);
			 dstDecl = dstGrammar.getGlobalTypeDecl(name, location);
			 if (dstDecl == null) {
				 dstGrammar.addGlobalTypeDecl(srcDecl, location);
			 }
			 else if (dstDecl != srcDecl) {
			 }
		 }
	 }
	 private Vector expandComponents(XSObject[] components, Hashtable dependencies) {
		 Vector newComponents = new Vector();
		 for (int i=0;
		 i<components.length;
		 i++) {
			 if (!newComponents.contains(components[i])) {
				 newComponents.add(components[i]);
			 }
		 }
		 for (int i=0;
		 i<newComponents.size();
		 i++) {
			 final XSObject component = (XSObject) newComponents.elementAt(i);
			 expandRelatedComponents(component, newComponents, dependencies);
		 }
		 return newComponents;
	 }
	 private void expandRelatedComponents(XSObject component, Vector componentList, Hashtable dependencies) {
		 short componentType = component.getType();
		 switch (componentType) {
			 case XSConstants.TYPE_DEFINITION : expandRelatedTypeComponents((XSTypeDefinition) component, componentList, component.getNamespace(), dependencies);
			 break;
			 case XSConstants.ATTRIBUTE_DECLARATION : expandRelatedAttributeComponents((XSAttributeDeclaration) component, componentList, component.getNamespace(), dependencies);
			 break;
			 case XSConstants.ATTRIBUTE_GROUP : expandRelatedAttributeGroupComponents((XSAttributeGroupDefinition) component, componentList, component.getNamespace(), dependencies);
			 case XSConstants.ELEMENT_DECLARATION : expandRelatedElementComponents((XSElementDeclaration) component, componentList, component.getNamespace(), dependencies);
			 break;
			 case XSConstants.MODEL_GROUP_DEFINITION : expandRelatedModelGroupDefinitionComponents((XSModelGroupDefinition) component, componentList, component.getNamespace(), dependencies);
			 case XSConstants.ATTRIBUTE_USE : case XSConstants.NOTATION_DECLARATION : case XSConstants.IDENTITY_CONSTRAINT : default : break;
		 }
	 }
	 private void expandRelatedAttributeComponents(XSAttributeDeclaration decl, Vector componentList, String namespace, Hashtable dependencies) {
		 addRelatedType(decl.getTypeDefinition(), componentList, namespace, dependencies);
	 }
	 private void expandRelatedElementComponents(XSElementDeclaration decl, Vector componentList, String namespace, Hashtable dependencies) {
		 addRelatedType(decl.getTypeDefinition(), componentList, namespace, dependencies);
		 final XSElementDeclaration subElemDecl = decl.getSubstitutionGroupAffiliation();
		 if (subElemDecl != null) {
			 addRelatedElement(subElemDecl, componentList, namespace, dependencies);
		 }
	 }
	 private void expandRelatedTypeComponents(XSTypeDefinition type, Vector componentList, String namespace, Hashtable dependencies) {
		 if (type instanceof XSComplexTypeDecl) {
			 expandRelatedComplexTypeComponents((XSComplexTypeDecl) type, componentList, namespace, dependencies);
		 }
		 else if (type instanceof XSSimpleTypeDecl) {
			 expandRelatedSimpleTypeComponents((XSSimpleTypeDefinition) type, componentList, namespace, dependencies);
		 }
	 }
	 private void expandRelatedModelGroupDefinitionComponents(XSModelGroupDefinition modelGroupDef, Vector componentList, String namespace, Hashtable dependencies) {
		 expandRelatedModelGroupComponents(modelGroupDef.getModelGroup(), componentList, namespace, dependencies);
	 }
	 private void expandRelatedAttributeGroupComponents(XSAttributeGroupDefinition attrGroup, Vector componentList , String namespace, Hashtable dependencies) {
		 expandRelatedAttributeUsesComponents(attrGroup.getAttributeUses(), componentList, namespace, dependencies);
	 }
	 private void expandRelatedComplexTypeComponents(XSComplexTypeDecl type, Vector componentList, String namespace, Hashtable dependencies) {
		 addRelatedType(type.getBaseType(), componentList, namespace, dependencies);
		 expandRelatedAttributeUsesComponents(type.getAttributeUses(), componentList, namespace, dependencies);
		 final XSParticle particle = type.getParticle();
		 if (particle != null) {
			 expandRelatedParticleComponents(particle, componentList, namespace, dependencies);
		 }
	 }
	 private void expandRelatedSimpleTypeComponents(XSSimpleTypeDefinition type, Vector componentList, String namespace, Hashtable dependencies) {
		 final XSTypeDefinition baseType = type.getBaseType();
		 if (baseType != null) {
			 addRelatedType(baseType, componentList, namespace, dependencies);
		 }
		 final XSTypeDefinition itemType = type.getItemType();
		 if (itemType != null) {
			 addRelatedType(itemType, componentList, namespace, dependencies);
		 }
		 final XSTypeDefinition primitiveType = type.getPrimitiveType();
		 if (primitiveType != null) {
			 addRelatedType(primitiveType, componentList, namespace, dependencies);
		 }
		 final XSObjectList memberTypes = type.getMemberTypes();
		 if (memberTypes.size() > 0) {
			 for (int i=0;
			 i<memberTypes.size();
			 i++) {
				 addRelatedType((XSTypeDefinition)memberTypes.item(i), componentList, namespace, dependencies);
			 }
		 }
	 }
	 private void expandRelatedAttributeUsesComponents(XSObjectList attrUses, Vector componentList, String namespace, Hashtable dependencies) {
		 final int attrUseSize = (attrUses == null) ? 0 : attrUses.size();
		 for (int i=0;
		 i<attrUseSize;
		 i++) {
			 expandRelatedAttributeUseComponents((XSAttributeUse)attrUses.item(i), componentList, namespace, dependencies);
		 }
	 }
	 private void expandRelatedAttributeUseComponents(XSAttributeUse component, Vector componentList, String namespace, Hashtable dependencies) {
		 addRelatedAttribute(component.getAttrDeclaration(), componentList, namespace, dependencies);
	 }
	 private void expandRelatedParticleComponents(XSParticle component, Vector componentList, String namespace, Hashtable dependencies) {
		 XSTerm term = component.getTerm();
		 switch (term.getType()) {
			 case XSConstants.ELEMENT_DECLARATION : addRelatedElement((XSElementDeclaration) term, componentList, namespace, dependencies);
			 break;
			 case XSConstants.MODEL_GROUP : expandRelatedModelGroupComponents((XSModelGroup) term, componentList, namespace, dependencies);
			 break;
			 default: break;
		 }
	 }
	 private void expandRelatedModelGroupComponents(XSModelGroup modelGroup, Vector componentList, String namespace, Hashtable dependencies) {
		 XSObjectList particles = modelGroup.getParticles();
		 final int length = (particles == null) ? 0 : particles.getLength();
		 for (int i=0;
		 i<length;
		 i++) {
			 expandRelatedParticleComponents((XSParticle)particles.item(i), componentList, namespace, dependencies);
		 }
	 }
	 private void addRelatedType(XSTypeDefinition type, Vector componentList, String namespace, Hashtable dependencies) {
		 if (!type.getAnonymous()) {
			 if (!type.getNamespace().equals(SchemaSymbols.URI_SCHEMAFORSCHEMA)) {
				 if (!componentList.contains(type)) {
					 final Vector importedNamespaces = findDependentNamespaces(namespace, dependencies);
					 addNamespaceDependency(namespace, type.getNamespace(), importedNamespaces);
					 componentList.add(type);
				 }
			 }
		 }
		 else {
			 expandRelatedTypeComponents(type, componentList, namespace, dependencies);
		 }
	 }
	 private void addRelatedElement(XSElementDeclaration decl, Vector componentList, String namespace, Hashtable dependencies) {
		 if (decl.getScope() == XSConstants.SCOPE_GLOBAL) {
			 if (!componentList.contains(decl)) {
				 Vector importedNamespaces = findDependentNamespaces(namespace, dependencies);
				 addNamespaceDependency(namespace, decl.getNamespace(), importedNamespaces);
				 componentList.add(decl);
			 }
		 }
		 else {
			 expandRelatedElementComponents(decl, componentList, namespace, dependencies);
		 }
	 }
	 private void addRelatedAttribute(XSAttributeDeclaration decl, Vector componentList, String namespace, Hashtable dependencies) {
		 if (decl.getScope() == XSConstants.SCOPE_GLOBAL) {
			 if (!componentList.contains(decl)) {
				 Vector importedNamespaces = findDependentNamespaces(namespace, dependencies);
				 addNamespaceDependency(namespace, decl.getNamespace(), importedNamespaces);
				 componentList.add(decl);
			 }
		 }
		 else {
			 expandRelatedAttributeComponents(decl, componentList, namespace, dependencies);
		 }
	 }
	 private void addGlobalComponents(Vector components, Hashtable importDependencies) {
		 final XSDDescription desc = new XSDDescription();
		 final int size = components.size();
		 for (int i=0;
		 i<size;
		 i++) {
			 addGlobalComponent((XSObject) components.elementAt(i), desc);
		 }
		 updateImportDependencies(importDependencies);
	 }
	 private void addGlobalComponent(XSObject component, XSDDescription desc) {
		 final String namespace = component.getNamespace();
		 desc.setNamespace(namespace);
		 final SchemaGrammar sg = getSchemaGrammar(desc);
		 short componentType = component.getType();
		 final String name = component.getName();
		 switch (componentType) {
			 case XSConstants.TYPE_DEFINITION : if (!((XSTypeDefinition) component).getAnonymous()) {
				 if (sg.getGlobalTypeDecl(name) == null) {
					 sg.addGlobalTypeDecl((XSTypeDefinition) component);
				 }
				 if (sg.getGlobalTypeDecl(name, """") == null) {
					 sg.addGlobalTypeDecl((XSTypeDefinition) component, """");
				 }
			 }
			 break;
			 case XSConstants.ATTRIBUTE_DECLARATION : if (((XSAttributeDecl) component).getScope() == XSAttributeDecl.SCOPE_GLOBAL) {
				 if (sg.getGlobalAttributeDecl(name) == null) {
					 sg.addGlobalAttributeDecl((XSAttributeDecl) component);
				 }
				 if (sg.getGlobalAttributeDecl(name, """") == null) {
					 sg.addGlobalAttributeDecl((XSAttributeDecl) component, """");
				 }
			 }
			 break;
			 case XSConstants.ATTRIBUTE_GROUP : if (sg.getGlobalAttributeDecl(name) == null) {
				 sg.addGlobalAttributeGroupDecl((XSAttributeGroupDecl) component);
			 }
			 if (sg.getGlobalAttributeDecl(name, """") == null) {
				 sg.addGlobalAttributeGroupDecl((XSAttributeGroupDecl) component, """");
			 }
			 break;
			 case XSConstants.ELEMENT_DECLARATION : if (((XSElementDecl) component).getScope() == XSElementDecl.SCOPE_GLOBAL) {
				 sg.addGlobalElementDeclAll((XSElementDecl) component);
				 if (sg.getGlobalElementDecl(name) == null) {
					 sg.addGlobalElementDecl((XSElementDecl) component);
				 }
				 if (sg.getGlobalElementDecl(name, """") == null) {
					 sg.addGlobalElementDecl((XSElementDecl) component, """");
				 }
			 }
			 break;
			 case XSConstants.MODEL_GROUP_DEFINITION : if (sg.getGlobalGroupDecl(name) == null) {
				 sg.addGlobalGroupDecl((XSGroupDecl) component);
			 }
			 if (sg.getGlobalGroupDecl(name, """") == null) {
				 sg.addGlobalGroupDecl((XSGroupDecl) component, """");
			 }
			 break;
			 case XSConstants.NOTATION_DECLARATION : if (sg.getGlobalNotationDecl(name) == null) {
				 sg.addGlobalNotationDecl((XSNotationDecl) component);
			 }
			 if (sg.getGlobalNotationDecl(name, """") == null) {
				 sg.addGlobalNotationDecl((XSNotationDecl) component, """");
			 }
			 break;
			 case XSConstants.IDENTITY_CONSTRAINT : case XSConstants.ATTRIBUTE_USE : default : break;
		 }
	 }
	 private void updateImportDependencies(Hashtable table) {
		 Enumeration keys = table.keys();
		 String namespace;
		 Vector importList;
		 while (keys.hasMoreElements()) {
			 namespace = (String) keys.nextElement();
			 importList = (Vector) table.get(null2EmptyString(namespace));
			 if (importList.size() > 0) {
				 expandImportList(namespace, importList);
			 }
		 }
	 }
	 private void expandImportList(String namespace, Vector namespaceList) {
		 SchemaGrammar sg = fGrammarBucket.getGrammar(namespace);
		 if (sg != null) {
			 Vector isgs = sg.getImportedGrammars();
			 if (isgs == null) {
				 isgs = new Vector();
				 addImportList(sg, isgs, namespaceList);
				 sg.setImportedGrammars(isgs);
			 }
			 else {
				 updateImportList(sg, isgs, namespaceList);
			 }
		 }
	 }
	 private void addImportList(SchemaGrammar sg, Vector importedGrammars, Vector namespaceList) {
		 final int size = namespaceList.size();
		 SchemaGrammar isg;
		 for (int i=0;
		 i<size;
		 i++) {
			 isg = fGrammarBucket.getGrammar((String)namespaceList.elementAt(i));
			 if (isg != null) {
				 importedGrammars.add(isg);
			 }
			 else {
			 }
		 }
	 }
	 private void updateImportList(SchemaGrammar sg, Vector importedGrammars, Vector namespaceList) {
		 final int size = namespaceList.size();
		 SchemaGrammar isg;
		 for (int i=0;
		 i<size;
		 i++) {
			 isg = fGrammarBucket.getGrammar((String)namespaceList.elementAt(i));
			 if (isg != null) {
				 if (!containedImportedGrammar(importedGrammars, isg)) {
					 importedGrammars.add(isg);
				 }
			 }
			 else {
			 }
		 }
	 }
	 private boolean containedImportedGrammar(Vector importedGrammar, SchemaGrammar grammar) {
		 final int size = importedGrammar.size();
		 SchemaGrammar sg;
		 for (int i=0;
		 i<size;
		 i++) {
			 sg = (SchemaGrammar) importedGrammar.elementAt(i);
			 if (null2EmptyString(sg.getTargetNamespace()).equals(null2EmptyString(grammar.getTargetNamespace()))) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private SchemaGrammar getSchemaGrammar(XSDDescription desc) {
		 SchemaGrammar sg = findGrammar(desc, fNamespaceGrowth);
		 if (sg == null) {
			 sg = new SchemaGrammar(desc.getNamespace(), desc.makeClone(), fSymbolTable);
			 fGrammarBucket.putGrammar(sg);
		 }
		 else if (sg.isImmutable()){
			 sg = createGrammarFrom(sg);
		 }
		 return sg;
	 }
	 private Vector findDependentNamespaces(String namespace, Hashtable table) {
		 final String ns = null2EmptyString(namespace);
		 Vector namespaceList = (Vector) table.get(ns);
		 if (namespaceList == null) {
			 namespaceList = new Vector();
			 table.put(ns, namespaceList);
		 }
		 return namespaceList;
	 }
	 private void addNamespaceDependency(String namespace1, String namespace2, Vector list) {
		 final String ns1 = null2EmptyString(namespace1);
		 final String ns2 = null2EmptyString(namespace2);
		 if (!ns1.equals(ns2)) {
			 if (!list.contains(ns2)) {
				 list.add(ns2);
			 }
		 }
	 }
	 private void reportSharingError(String namespace, String name) {
		 final String qName = (namespace == null) ? "","" + name : namespace + "","" + name;
		 reportSchemaError(""sch-props-correct.2"", new Object [] {
		qName}
		, null);
	 }
	 private void createTraversers() {
		 fAttributeChecker = new XSAttributeChecker(this);
		 fAttributeGroupTraverser = new XSDAttributeGroupTraverser(this, fAttributeChecker);
		 fAttributeTraverser = new XSDAttributeTraverser(this, fAttributeChecker);
		 fComplexTypeTraverser = new XSDComplexTypeTraverser(this, fAttributeChecker);
		 fElementTraverser = new XSDElementTraverser(this, fAttributeChecker);
		 fGroupTraverser = new XSDGroupTraverser(this, fAttributeChecker);
		 fKeyrefTraverser = new XSDKeyrefTraverser(this, fAttributeChecker);
		 fNotationTraverser = new XSDNotationTraverser(this, fAttributeChecker);
		 fSimpleTypeTraverser = new XSDSimpleTypeTraverser(this, fAttributeChecker);
		 fUniqueOrKeyTraverser = new XSDUniqueOrKeyTraverser(this, fAttributeChecker);
		 fWildCardTraverser = new XSDWildcardTraverser(this, fAttributeChecker);
	 }
	 void prepareForParse() {
		 fTraversed.clear();
		 fDoc2SystemId.clear();
		 fHiddenNodes.clear();
		 fLastSchemaWasDuplicate = false;
	 }
	 void prepareForTraverse() {
		 fUnparsedAttributeRegistry.clear();
		 fUnparsedAttributeGroupRegistry.clear();
		 fUnparsedElementRegistry.clear();
		 fUnparsedGroupRegistry.clear();
		 fUnparsedIdentityConstraintRegistry.clear();
		 fUnparsedNotationRegistry.clear();
		 fUnparsedTypeRegistry.clear();
		 fUnparsedAttributeRegistrySub.clear();
		 fUnparsedAttributeGroupRegistrySub.clear();
		 fUnparsedElementRegistrySub.clear();
		 fUnparsedGroupRegistrySub.clear();
		 fUnparsedIdentityConstraintRegistrySub.clear();
		 fUnparsedNotationRegistrySub.clear();
		 fUnparsedTypeRegistrySub.clear();
		 for (int i=1;
		 i<= TYPEDECL_TYPE;
		 i++) {
			 fUnparsedRegistriesExt[i].clear();
		 }
		 fXSDocumentInfoRegistry.clear();
		 fDependencyMap.clear();
		 fDoc2XSDocumentMap.clear();
		 fRedefine2XSDMap.clear();
		 fRedefine2NSSupport.clear();
		 fAllTNSs.removeAllElements();
		 fImportMap.clear();
		 fRoot = null;
		 for (int i = 0;
		 i < fLocalElemStackPos;
		 i++) {
			 fParticle[i] = null;
			 fLocalElementDecl[i] = null;
			 fLocalElementDecl_schema[i] = null;
			 fLocalElemNamespaceContext[i] = null;
		 }
		 fLocalElemStackPos = 0;
		 for (int i = 0;
		 i < fKeyrefStackPos;
		 i++) {
			 fKeyrefs[i] = null;
			 fKeyrefElems[i] = null;
			 fKeyrefNamespaceContext[i] = null;
			 fKeyrefsMapXSDocumentInfo[i] = null;
		 }
		 fKeyrefStackPos = 0;
		 if (fAttributeChecker == null) {
			 createTraversers();
		 }
		 Locale locale = fErrorReporter.getLocale();
		 fAttributeChecker.reset(fSymbolTable);
		 fAttributeGroupTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fAttributeTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fComplexTypeTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fElementTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fGroupTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fKeyrefTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fNotationTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fSimpleTypeTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fUniqueOrKeyTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fWildCardTraverser.reset(fSymbolTable, fValidateAnnotations, locale);
		 fRedefinedRestrictedAttributeGroupRegistry.clear();
		 fRedefinedRestrictedGroupRegistry.clear();
		 fGlobalAttrDecls.clear();
		 fGlobalAttrGrpDecls.clear();
		 fGlobalElemDecls.clear();
		 fGlobalGroupDecls.clear();
		 fGlobalNotationDecls.clear();
		 fGlobalIDConstraintDecls.clear();
		 fGlobalTypeDecls.clear();
	 }
	 public void setDeclPool (XSDeclarationPool declPool){
		 fDeclPool = declPool;
	 }
	 public void setDVFactory(SchemaDVFactory dvFactory){
		 fDVFactory = dvFactory;
	 }
	 public void reset(XMLComponentManager componentManager) {
		 fSymbolTable = (SymbolTable) componentManager.getProperty(SYMBOL_TABLE);
		 fEntityResolver = (XMLEntityResolver) componentManager.getProperty(ENTITY_MANAGER);
		 XMLEntityResolver er = (XMLEntityResolver)componentManager.getProperty(ENTITY_RESOLVER);
		 if (er != null) fSchemaParser.setEntityResolver(er);
		 fErrorReporter = (XMLErrorReporter) componentManager.getProperty(ERROR_REPORTER);
		 try {
			 XMLErrorHandler currErrorHandler = fErrorReporter.getErrorHandler();
			 if (currErrorHandler != fSchemaParser.getProperty(ERROR_HANDLER)) {
				 fSchemaParser.setProperty(ERROR_HANDLER, (currErrorHandler != null) ? currErrorHandler : new DefaultErrorHandler());
				 if (fAnnotationValidator != null) {
					 fAnnotationValidator.setProperty(ERROR_HANDLER, (currErrorHandler != null) ? currErrorHandler : new DefaultErrorHandler());
				 }
			 }
			 Locale currentLocale = fErrorReporter.getLocale();
			 if (currentLocale != fSchemaParser.getProperty(LOCALE)) {
				 fSchemaParser.setProperty(LOCALE, currentLocale);
				 if (fAnnotationValidator != null) {
					 fAnnotationValidator.setProperty(LOCALE, currentLocale);
				 }
			 }
		 }
		 catch (XMLConfigurationException e) {
		}
		 try {
			 fValidateAnnotations = componentManager.getFeature(VALIDATE_ANNOTATIONS);
		 }
		 catch (XMLConfigurationException e) {
			 fValidateAnnotations = false;
		 }
		 try {
			 fHonourAllSchemaLocations = componentManager.getFeature(HONOUR_ALL_SCHEMALOCATIONS);
		 }
		 catch (XMLConfigurationException e) {
			 fHonourAllSchemaLocations = false;
		 }
		 try {
			 fNamespaceGrowth = componentManager.getFeature(NAMESPACE_GROWTH);
		 }
		 catch (XMLConfigurationException e) {
			 fNamespaceGrowth = false;
		 }
		 try {
			 fTolerateDuplicates = componentManager.getFeature(TOLERATE_DUPLICATES);
		 }
		 catch (XMLConfigurationException e) {
			 fTolerateDuplicates = false;
		 }
		 try {
			 fSchemaParser.setFeature( CONTINUE_AFTER_FATAL_ERROR, fErrorReporter.getFeature(CONTINUE_AFTER_FATAL_ERROR));
		 }
		 catch (XMLConfigurationException e) {
		 }
		 try {
			 fSchemaParser.setFeature( ALLOW_JAVA_ENCODINGS, componentManager.getFeature(ALLOW_JAVA_ENCODINGS));
		 }
		 catch (XMLConfigurationException e) {
		 }
		 try {
			 fSchemaParser.setFeature( STANDARD_URI_CONFORMANT_FEATURE, componentManager.getFeature(STANDARD_URI_CONFORMANT_FEATURE));
		 }
		 catch (XMLConfigurationException e) {
		 }
		 try {
			 fGrammarPool = (XMLGrammarPool) componentManager.getProperty(XMLGRAMMAR_POOL);
		 }
		 catch (XMLConfigurationException e) {
			 fGrammarPool = null;
		 }
		 try {
			 fSchemaParser.setFeature( DISALLOW_DOCTYPE, componentManager.getFeature(DISALLOW_DOCTYPE));
		 }
		 catch (XMLConfigurationException e) {
		 }
		 try {
			 Object security = componentManager.getProperty(SECURITY_MANAGER);
			 if (security != null){
				 fSchemaParser.setProperty(SECURITY_MANAGER, security);
			 }
		 }
		 catch (XMLConfigurationException e) {
		 }
	 }
	 void traverseLocalElements() {
		 fElementTraverser.fDeferTraversingLocalElements = false;
		 for (int i = 0;
		 i < fLocalElemStackPos;
		 i++) {
			 Element currElem = fLocalElementDecl[i];
			 XSDocumentInfo currSchema = fLocalElementDecl_schema[i];
			 SchemaGrammar currGrammar = fGrammarBucket.getGrammar(currSchema.fTargetNamespace);
			 fElementTraverser.traverseLocal (fParticle[i], currElem, currSchema, currGrammar, fAllContext[i], fParent[i], fLocalElemNamespaceContext[i]);
			 if (fParticle[i].fType == XSParticleDecl.PARTICLE_EMPTY) {
				 XSModelGroupImpl group = null;
				 if (fParent[i] instanceof XSComplexTypeDecl) {
					 XSParticle p = ((XSComplexTypeDecl)fParent[i]).getParticle();
					 if (p != null) group = (XSModelGroupImpl)p.getTerm();
				 }
				 else {
					 group = ((XSGroupDecl)fParent[i]).fModelGroup;
				 }
				 if (group != null) removeParticle(group, fParticle[i]);
			 }
		 }
	 }
	 private boolean removeParticle(XSModelGroupImpl group, XSParticleDecl particle) {
		 XSParticleDecl member;
		 for (int i = 0;
		 i < group.fParticleCount;
		 i++) {
			 member = group.fParticles[i];
			 if (member == particle) {
				 for (int j = i;
				 j < group.fParticleCount-1;
				 j++) group.fParticles[j] = group.fParticles[j+1];
				 group.fParticleCount--;
				 return true;
			 }
			 if (member.fType == XSParticleDecl.PARTICLE_MODELGROUP) {
				 if (removeParticle((XSModelGroupImpl)member.fValue, particle)) return true;
			 }
		 }
		 return false;
	 }
	 void fillInLocalElemInfo(Element elmDecl, XSDocumentInfo schemaDoc, int allContextFlags, XSObject parent, XSParticleDecl particle) {
		 if (fParticle.length == fLocalElemStackPos) {
			 XSParticleDecl[] newStackP = new XSParticleDecl[fLocalElemStackPos+INC_STACK_SIZE];
			 System.arraycopy(fParticle, 0, newStackP, 0, fLocalElemStackPos);
			 fParticle = newStackP;
			 Element[] newStackE = new Element[fLocalElemStackPos+INC_STACK_SIZE];
			 System.arraycopy(fLocalElementDecl, 0, newStackE, 0, fLocalElemStackPos);
			 fLocalElementDecl = newStackE;
			 XSDocumentInfo [] newStackE_schema = new XSDocumentInfo[fLocalElemStackPos+INC_STACK_SIZE];
			 System.arraycopy(fLocalElementDecl_schema, 0, newStackE_schema, 0, fLocalElemStackPos);
			 fLocalElementDecl_schema = newStackE_schema;
			 int[] newStackI = new int[fLocalElemStackPos+INC_STACK_SIZE];
			 System.arraycopy(fAllContext, 0, newStackI, 0, fLocalElemStackPos);
			 fAllContext = newStackI;
			 XSObject[] newStackC = new XSObject[fLocalElemStackPos+INC_STACK_SIZE];
			 System.arraycopy(fParent, 0, newStackC, 0, fLocalElemStackPos);
			 fParent = newStackC;
			 String [][] newStackN = new String [fLocalElemStackPos+INC_STACK_SIZE][];
			 System.arraycopy(fLocalElemNamespaceContext, 0, newStackN, 0, fLocalElemStackPos);
			 fLocalElemNamespaceContext = newStackN;
		 }
		 fParticle[fLocalElemStackPos] = particle;
		 fLocalElementDecl[fLocalElemStackPos] = elmDecl;
		 fLocalElementDecl_schema[fLocalElemStackPos] = schemaDoc;
		 fAllContext[fLocalElemStackPos] = allContextFlags;
		 fParent[fLocalElemStackPos] = parent;
		 fLocalElemNamespaceContext[fLocalElemStackPos++] = schemaDoc.fNamespaceSupport.getEffectiveLocalContext();
	 }
	 void checkForDuplicateNames(String qName, int declType, Hashtable registry, Hashtable registry_sub, Element currComp, XSDocumentInfo currSchema) {
		 Object objElem = null;
		 if ((objElem = registry.get(qName)) == null) {
			 if (fNamespaceGrowth && !fTolerateDuplicates) {
				 checkForDuplicateNames(qName, declType, currComp);
			 }
			 registry.put(qName, currComp);
			 registry_sub.put(qName, currSchema);
		 }
		 else {
			 Element collidingElem = (Element)objElem;
			 XSDocumentInfo collidingElemSchema = (XSDocumentInfo)registry_sub.get(qName);
			 if (collidingElem == currComp) return;
			 Element elemParent = null;
			 XSDocumentInfo redefinedSchema = null;
			 boolean collidedWithRedefine = true;
			 if ((DOMUtil.getLocalName((elemParent = DOMUtil.getParent(collidingElem))).equals(SchemaSymbols.ELT_REDEFINE))) {
				 redefinedSchema = (XSDocumentInfo)(fRedefine2XSDMap.get(elemParent));
			 }
			 else if ((DOMUtil.getLocalName(DOMUtil.getParent(currComp)).equals(SchemaSymbols.ELT_REDEFINE))) {
				 redefinedSchema = collidingElemSchema;
				 collidedWithRedefine = false;
			 }
			 if (redefinedSchema != null) {
				 if(collidingElemSchema == currSchema){
					 reportSchemaError(""sch-props-correct.2"", new Object[]{
					qName}
					, currComp);
					 return;
				 }
				 String newName = qName.substring(qName.lastIndexOf(',')+1)+REDEF_IDENTIFIER;
				 if (redefinedSchema == currSchema) {
					 currComp.setAttribute(SchemaSymbols.ATT_NAME, newName);
					 if (currSchema.fTargetNamespace == null){
						 registry.put("",""+newName, currComp);
						 registry_sub.put("",""+newName, currSchema);
					 }
					 else{
						 registry.put(currSchema.fTargetNamespace+"",""+newName, currComp);
						 registry_sub.put(currSchema.fTargetNamespace+"",""+newName, currSchema);
					 }
					 if (currSchema.fTargetNamespace == null) checkForDuplicateNames("",""+newName, declType, registry, registry_sub, currComp, currSchema);
					 else checkForDuplicateNames(currSchema.fTargetNamespace+"",""+newName, declType, registry, registry_sub, currComp, currSchema);
				 }
				 else {
					 if (collidedWithRedefine) {
						 if (currSchema.fTargetNamespace == null) checkForDuplicateNames("",""+newName, declType, registry, registry_sub, currComp, currSchema);
						 else checkForDuplicateNames(currSchema.fTargetNamespace+"",""+newName, declType, registry, registry_sub, currComp, currSchema);
					 }
					 else {
						 reportSchemaError(""sch-props-correct.2"", new Object [] {
						qName}
						, currComp);
					 }
				 }
			 }
			 else {
				 if (!fTolerateDuplicates || fUnparsedRegistriesExt[declType].get(qName) == currSchema) {
					 reportSchemaError(""sch-props-correct.2"", new Object []{
					qName}
					, currComp);
				 }
			 }
		 }
		 if (fTolerateDuplicates) {
			 fUnparsedRegistriesExt[declType].put(qName, currSchema);
		 }
	 }
	 void checkForDuplicateNames(String qName, int declType, Element currComp) {
		 int namespaceEnd = qName.indexOf(',');
		 String namespace = qName.substring(0, namespaceEnd);
		 SchemaGrammar grammar = fGrammarBucket.getGrammar(emptyString2Null(namespace));
		 if (grammar != null) {
			 Object obj = getGlobalDeclFromGrammar(grammar, declType, qName.substring(namespaceEnd + 1));
			 if (obj != null) {
				 reportSchemaError(""sch-props-correct.2"", new Object []{
				qName}
				, currComp);
			 }
		 }
	 }
	 private void renameRedefiningComponents(XSDocumentInfo currSchema, Element child, String componentType, String oldName, String newName) {
		 if (componentType.equals(SchemaSymbols.ELT_SIMPLETYPE)) {
			 Element grandKid = DOMUtil.getFirstChildElement(child);
			 if (grandKid == null) {
				 reportSchemaError(""src-redefine.5.a.a"", null, child);
			 }
			 else {
				 String grandKidName = DOMUtil.getLocalName(grandKid);
				 if (grandKidName.equals(SchemaSymbols.ELT_ANNOTATION)) {
					 grandKid = DOMUtil.getNextSiblingElement(grandKid);
				 }
				 if (grandKid == null) {
					 reportSchemaError(""src-redefine.5.a.a"", null, child);
				 }
				 else {
					 grandKidName = DOMUtil.getLocalName(grandKid);
					 if (!grandKidName.equals(SchemaSymbols.ELT_RESTRICTION)) {
						 reportSchemaError(""src-redefine.5.a.b"", new Object[]{
						grandKidName}
						, child);
					 }
					 else {
						 Object[] attrs = fAttributeChecker.checkAttributes(grandKid, false, currSchema);
						 QName derivedBase = (QName)attrs[XSAttributeChecker.ATTIDX_BASE];
						 if (derivedBase == null || derivedBase.uri != currSchema.fTargetNamespace || !derivedBase.localpart.equals(oldName)) {
							 reportSchemaError(""src-redefine.5.a.c"", new Object[]{
							grandKidName, (currSchema.fTargetNamespace==null?"""":currSchema.fTargetNamespace) + "","" + oldName}
							, child);
						 }
						 else {
							 if (derivedBase.prefix != null && derivedBase.prefix.length() > 0) grandKid.setAttribute( SchemaSymbols.ATT_BASE, derivedBase.prefix + "":"" + newName );
							 else grandKid.setAttribute( SchemaSymbols.ATT_BASE, newName );
						 }
						 fAttributeChecker.returnAttrArray(attrs, currSchema);
					 }
				 }
			 }
		 }
		 else if (componentType.equals(SchemaSymbols.ELT_COMPLEXTYPE)) {
			 Element grandKid = DOMUtil.getFirstChildElement(child);
			 if (grandKid == null) {
				 reportSchemaError(""src-redefine.5.b.a"", null, child);
			 }
			 else {
				 if (DOMUtil.getLocalName(grandKid).equals(SchemaSymbols.ELT_ANNOTATION)) {
					 grandKid = DOMUtil.getNextSiblingElement(grandKid);
				 }
				 if (grandKid == null) {
					 reportSchemaError(""src-redefine.5.b.a"", null, child);
				 }
				 else {
					 Element greatGrandKid = DOMUtil.getFirstChildElement(grandKid);
					 if (greatGrandKid == null) {
						 reportSchemaError(""src-redefine.5.b.b"", null, grandKid);
					 }
					 else {
						 String greatGrandKidName = DOMUtil.getLocalName(greatGrandKid);
						 if (greatGrandKidName.equals(SchemaSymbols.ELT_ANNOTATION)) {
							 greatGrandKid = DOMUtil.getNextSiblingElement(greatGrandKid);
						 }
						 if (greatGrandKid == null) {
							 reportSchemaError(""src-redefine.5.b.b"", null, grandKid);
						 }
						 else {
							 greatGrandKidName = DOMUtil.getLocalName(greatGrandKid);
							 if (!greatGrandKidName.equals(SchemaSymbols.ELT_RESTRICTION) && !greatGrandKidName.equals(SchemaSymbols.ELT_EXTENSION)) {
								 reportSchemaError(""src-redefine.5.b.c"", new Object[]{
								greatGrandKidName}
								, greatGrandKid);
							 }
							 else {
								 Object[] attrs = fAttributeChecker.checkAttributes(greatGrandKid, false, currSchema);
								 QName derivedBase = (QName)attrs[XSAttributeChecker.ATTIDX_BASE];
								 if (derivedBase == null || derivedBase.uri != currSchema.fTargetNamespace || !derivedBase.localpart.equals(oldName)) {
									 reportSchemaError(""src-redefine.5.b.d"", new Object[]{
									greatGrandKidName, (currSchema.fTargetNamespace==null?"""":currSchema.fTargetNamespace) + "","" + oldName}
									, greatGrandKid);
								 }
								 else {
									 if (derivedBase.prefix != null && derivedBase.prefix.length() > 0) greatGrandKid.setAttribute( SchemaSymbols.ATT_BASE, derivedBase.prefix + "":"" + newName );
									 else greatGrandKid.setAttribute( SchemaSymbols.ATT_BASE, newName );
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 else if (componentType.equals(SchemaSymbols.ELT_ATTRIBUTEGROUP)) {
			 String processedBaseName = (currSchema.fTargetNamespace == null)? "",""+oldName:currSchema.fTargetNamespace+"",""+oldName;
			 int attGroupRefsCount = changeRedefineGroup(processedBaseName, componentType, newName, child, currSchema);
			 if (attGroupRefsCount > 1) {
				 reportSchemaError(""src-redefine.7.1"", new Object []{
				new Integer(attGroupRefsCount)}
				, child);
			 }
			 else if (attGroupRefsCount == 1) {
			 }
			 else if (currSchema.fTargetNamespace == null) fRedefinedRestrictedAttributeGroupRegistry.put(processedBaseName, "",""+newName);
			 else fRedefinedRestrictedAttributeGroupRegistry.put(processedBaseName, currSchema.fTargetNamespace+"",""+newName);
		 }
		 else if (componentType.equals(SchemaSymbols.ELT_GROUP)) {
			 String processedBaseName = (currSchema.fTargetNamespace == null)? "",""+oldName:currSchema.fTargetNamespace+"",""+oldName;
			 int groupRefsCount = changeRedefineGroup(processedBaseName, componentType, newName, child, currSchema);
			 if (groupRefsCount > 1) {
				 reportSchemaError(""src-redefine.6.1.1"", new Object []{
				new Integer(groupRefsCount)}
				, child);
			 }
			 else if (groupRefsCount == 1) {
			 }
			 else {
				 if (currSchema.fTargetNamespace == null) fRedefinedRestrictedGroupRegistry.put(processedBaseName, "",""+newName);
				 else fRedefinedRestrictedGroupRegistry.put(processedBaseName, currSchema.fTargetNamespace+"",""+newName);
			 }
		 }
		 else {
			 reportSchemaError(""Internal-Error"", new Object [] {
				""could not handle this particular <redefine>;
			 please submit your schemas and instance document in a bug report!""}
			, child);
		 }
	 }
	 private String findQName(String name, XSDocumentInfo schemaDoc) {
		 SchemaNamespaceSupport currNSMap = schemaDoc.fNamespaceSupport;
		 int colonPtr = name.indexOf(':');
		 String prefix = XMLSymbols.EMPTY_STRING;
		 if (colonPtr > 0) prefix = name.substring(0, colonPtr);
		 String uri = currNSMap.getURI(fSymbolTable.addSymbol(prefix));
		 String localpart = (colonPtr == 0)?name:name.substring(colonPtr+1);
		 if (prefix == XMLSymbols.EMPTY_STRING && uri == null && schemaDoc.fIsChameleonSchema) uri = schemaDoc.fTargetNamespace;
		 if (uri == null) return "",""+localpart;
		 return uri+"",""+localpart;
	 }
	 private int changeRedefineGroup(String originalQName, String elementSought, String newName, Element curr, XSDocumentInfo schemaDoc) {
		 int result = 0;
		 for (Element child = DOMUtil.getFirstChildElement(curr);
		 child != null;
		 child = DOMUtil.getNextSiblingElement(child)) {
			 String name = DOMUtil.getLocalName(child);
			 if (!name.equals(elementSought)) result += changeRedefineGroup(originalQName, elementSought, newName, child, schemaDoc);
			 else {
				 String ref = child.getAttribute( SchemaSymbols.ATT_REF );
				 if (ref.length() != 0) {
					 String processedRef = findQName(ref, schemaDoc);
					 if (originalQName.equals(processedRef)) {
						 String prefix = XMLSymbols.EMPTY_STRING;
						 int colonptr = ref.indexOf("":"");
						 if (colonptr > 0) {
							 prefix = ref.substring(0,colonptr);
							 child.setAttribute(SchemaSymbols.ATT_REF, prefix + "":"" + newName);
						 }
						 else child.setAttribute(SchemaSymbols.ATT_REF, newName);
						 result++;
						 if (elementSought.equals(SchemaSymbols.ELT_GROUP)) {
							 String minOccurs = child.getAttribute( SchemaSymbols.ATT_MINOCCURS );
							 String maxOccurs = child.getAttribute( SchemaSymbols.ATT_MAXOCCURS );
							 if (!((maxOccurs.length() == 0 || maxOccurs.equals(""1"")) && (minOccurs.length() == 0 || minOccurs.equals(""1"")))) {
								 reportSchemaError(""src-redefine.6.1.2"", new Object [] {
								ref}
								, child);
							 }
						 }
					 }
				 }
			 }
		 }
		 return result;
	 }
	 private XSDocumentInfo findXSDocumentForDecl(XSDocumentInfo currSchema, Element decl, XSDocumentInfo decl_Doc) {
		 if (DEBUG_NODE_POOL) {
			 System.out.println(""DOCUMENT NS:""+ currSchema.fTargetNamespace+"" hashcode:""+ ((Object)currSchema.fSchemaElement).hashCode());
		 }
		 Object temp = decl_Doc;
		 if (temp == null) {
			 return null;
		 }
		 XSDocumentInfo declDocInfo = (XSDocumentInfo)temp;
		 return declDocInfo;
	 }
	 private boolean nonAnnotationContent(Element elem) {
		 for(Element child = DOMUtil.getFirstChildElement(elem);
		 child != null;
		 child = DOMUtil.getNextSiblingElement(child)) {
			 if(!(DOMUtil.getLocalName(child).equals(SchemaSymbols.ELT_ANNOTATION))) return true;
		 }
		 return false;
	 }
	 private void setSchemasVisible(XSDocumentInfo startSchema) {
		 if (DOMUtil.isHidden(startSchema.fSchemaElement, fHiddenNodes)) {
			 DOMUtil.setVisible(startSchema.fSchemaElement, fHiddenNodes);
			 Vector dependingSchemas = (Vector)fDependencyMap.get(startSchema);
			 for (int i = 0;
			 i < dependingSchemas.size();
			 i++) {
				 setSchemasVisible((XSDocumentInfo)dependingSchemas.elementAt(i));
			 }
		 }
	 }
	 private SimpleLocator xl = new SimpleLocator();
	 public SimpleLocator element2Locator(Element e) {
		 if (!( e instanceof ElementImpl)) return null;
		 SimpleLocator l = new SimpleLocator();
		 return element2Locator(e, l) ? l : null;
	 }
	 public boolean element2Locator(Element e, SimpleLocator l) {
		 if (l == null) return false;
		 if (e instanceof ElementImpl) {
			 ElementImpl ele = (ElementImpl)e;
			 Document doc = ele.getOwnerDocument();
			 String sid = (String)fDoc2SystemId.get(DOMUtil.getRoot(doc));
			 int line = ele.getLineNumber();
			 int column = ele.getColumnNumber();
			 l.setValues(sid, sid, line, column, ele.getCharacterOffset());
			 return true;
		 }
		 return false;
	 }
	 void reportSchemaError(String key, Object[] args, Element ele) {
		 reportSchemaError(key, args, ele, null);
	 }
	 void reportSchemaError(String key, Object[] args, Element ele, Exception exception) {
		 if (element2Locator(ele, xl)) {
			 fErrorReporter.reportError(xl, XSMessageFormatter.SCHEMA_DOMAIN, key, args, XMLErrorReporter.SEVERITY_ERROR, exception);
		 }
		 else {
			 fErrorReporter.reportError(XSMessageFormatter.SCHEMA_DOMAIN, key, args, XMLErrorReporter.SEVERITY_ERROR, exception);
		 }
	 }
	 void reportSchemaWarning(String key, Object[] args, Element ele) {
		 reportSchemaWarning(key, args, ele, null);
	 }
	 void reportSchemaWarning(String key, Object[] args, Element ele, Exception exception) {
		 if (element2Locator(ele, xl)) {
			 fErrorReporter.reportError(xl, XSMessageFormatter.SCHEMA_DOMAIN, key, args, XMLErrorReporter.SEVERITY_WARNING, exception);
		 }
		 else {
			 fErrorReporter.reportError(XSMessageFormatter.SCHEMA_DOMAIN, key, args, XMLErrorReporter.SEVERITY_WARNING, exception);
		 }
	 }
	 private static class XSAnnotationGrammarPool implements XMLGrammarPool {
		 private XSGrammarBucket fGrammarBucket;
		 private Grammar [] fInitialGrammarSet;
		 public Grammar[] retrieveInitialGrammarSet(String grammarType) {
			 if (grammarType == XMLGrammarDescription.XML_SCHEMA) {
				 if (fInitialGrammarSet == null) {
					 if (fGrammarBucket == null) {
						 fInitialGrammarSet = new Grammar [] {
						SchemaGrammar.Schema4Annotations.INSTANCE}
						;
					 }
					 else {
						 SchemaGrammar [] schemaGrammars = fGrammarBucket.getGrammars();
						 for (int i = 0;
						 i < schemaGrammars.length;
						 ++i) {
							 if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(schemaGrammars[i].getTargetNamespace())) {
								 fInitialGrammarSet = schemaGrammars;
								 return fInitialGrammarSet;
							 }
						 }
						 Grammar [] grammars = new Grammar[schemaGrammars.length + 1];
						 System.arraycopy(schemaGrammars, 0, grammars, 0, schemaGrammars.length);
						 grammars[grammars.length - 1] = SchemaGrammar.Schema4Annotations.INSTANCE;
						 fInitialGrammarSet = grammars;
					 }
				 }
				 return fInitialGrammarSet;
			 }
			 return new Grammar[0];
		 }
		 public void cacheGrammars(String grammarType, Grammar[] grammars) {
		 }
		 public Grammar retrieveGrammar(XMLGrammarDescription desc) {
			 if (desc.getGrammarType() == XMLGrammarDescription.XML_SCHEMA) {
				 final String tns = ((XMLSchemaDescription) desc).getTargetNamespace();
				 if (fGrammarBucket != null) {
					 Grammar grammar = fGrammarBucket.getGrammar(tns);
					 if (grammar != null) {
						 return grammar;
					 }
				 }
				 if (SchemaSymbols.URI_SCHEMAFORSCHEMA.equals(tns)) {
					 return SchemaGrammar.Schema4Annotations.INSTANCE;
				 }
			 }
			 return null;
		 }
		 public void refreshGrammars(XSGrammarBucket gBucket) {
			 fGrammarBucket = gBucket;
			 fInitialGrammarSet = null;
		 }
		 public void lockPool() {
		}
		 public void unlockPool() {
		}
		 public void clear() {
		}
	 }
	 private static class XSDKey {
		 String systemId;
		 short referType;
		 String referNS;
		 XSDKey(String systemId, short referType, String referNS) {
			 this.systemId = systemId;
			 this.referType = referType;
			 this.referNS = referNS;
		 }
		 public int hashCode() {
			 return referNS == null ? 0 : referNS.hashCode();
		 }
		 public boolean equals(Object obj) {
			 if (!(obj instanceof XSDKey)) {
				 return false;
			 }
			 XSDKey key = (XSDKey)obj;
			 if (referNS != key.referNS) return false;
			 if (systemId == null || !systemId.equals(key.systemId)) {
				 return false;
			 }
			 return true;
		 }
	 }
	 private static final class SAX2XNIUtil extends ErrorHandlerWrapper {
		 public static XMLParseException createXMLParseException0(SAXParseException exception) {
			 return createXMLParseException(exception);
		 }
		 public static XNIException createXNIException0(SAXException exception) {
			 return createXNIException(exception);
		 }
	 }
	 public void setGenerateSyntheticAnnotations(boolean state) {
		 fSchemaParser.setFeature(GENERATE_SYNTHETIC_ANNOTATIONS, state);
	 }
}",1,0,0,0
"public class NodeEntryImpl extends HierarchyEntryImpl implements NodeEntry {
	 private static Logger log = LoggerFactory.getLogger(NodeEntryImpl.class);
	 private String uniqueID;
	 private final ChildNodeEntries childNodeEntries;
	 private final ChildNodeAttic childNodeAttic;
	 private final ChildPropertyEntries properties;
	 private final Map<Name, PropertyEntry> propertiesInAttic;
	 private RevertInfo revertInfo;
	 private NodeEntryImpl(NodeEntryImpl parent, Name name, String uniqueID, EntryFactory factory) {
		 super(parent, name, factory);
		 this.uniqueID = uniqueID;
		 properties = new ChildPropertyEntriesImpl(this, factory);
		 childNodeEntries = new ChildNodeEntriesImpl(this, factory, null);
		 propertiesInAttic = new HashMap<Name, PropertyEntry>();
		 childNodeAttic = new ChildNodeAttic();
		 factory.notifyEntryCreated(this);
	 }
	 static NodeEntry createRootEntry(EntryFactory factory) {
		 return new NodeEntryImpl(null, NameConstants.ROOT, null, factory);
	 }
	 static NodeEntry createNodeEntry(NodeEntryImpl parent, Name name, String uniqueId, EntryFactory factory) {
		 return new NodeEntryImpl(parent, name, uniqueId, factory);
	 }
	 public boolean denotesNode() {
		 return true;
	 }
	 public void reload(boolean recursive) {
		 super.reload(recursive);
		 if (recursive && !Status.isTerminal(getStatus())) {
			 for (Iterator<HierarchyEntry> it = getAllChildEntries(true);
			 it.hasNext();
			) {
				 HierarchyEntry ce = it.next();
				 ce.reload(recursive);
			 }
		 }
	 }
	 public void revert() throws RepositoryException {
		 if (!propertiesInAttic.isEmpty()) {
			 properties.addAll(propertiesInAttic.values());
			 propertiesInAttic.clear();
		 }
		 super.revert();
	 }
	 public void transientRemove() throws RepositoryException {
		 for (Iterator<HierarchyEntry> it = getAllChildEntries(false);
		 it.hasNext();
		) {
			 HierarchyEntry ce = it.next();
			 ce.transientRemove();
		 }
		 if (!propertiesInAttic.isEmpty()) {
			 properties.addAll(propertiesInAttic.values());
			 propertiesInAttic.clear();
		 }
		 super.transientRemove();
	 }
	 public void remove() {
		 super.internalRemove(false);
		 boolean staleParent = (getStatus() == Status.STALE_DESTROYED);
		 for (Iterator<HierarchyEntry> it = getAllChildEntries(true);
		 it.hasNext();
		) {
			 HierarchyEntryImpl ce = (HierarchyEntryImpl) it.next();
			 ce.internalRemove(staleParent);
		 }
	 }
	 void internalRemove(boolean staleParent) {
		 super.internalRemove(staleParent);
		 staleParent = (staleParent || (getStatus() == Status.STALE_DESTROYED));
		 for (Iterator<HierarchyEntry> it = getAllChildEntries(true);
		 it.hasNext();
		) {
			 HierarchyEntryImpl ce = (HierarchyEntryImpl) it.next();
			 ce.internalRemove(staleParent);
		 }
	 }
	 public void complete(Operation operation) throws RepositoryException {
		 if (operation instanceof AddNode) {
			 complete((AddNode) operation);
		 }
		 else if (operation instanceof AddProperty) {
			 complete((AddProperty) operation);
		 }
		 else if (operation instanceof SetMixin) {
			 complete((SetMixin) operation);
		 }
		 else if (operation instanceof SetPrimaryType) {
			 complete((SetPrimaryType) operation);
		 }
		 else if (operation instanceof Remove) {
			 complete((Remove) operation);
		 }
		 else if (operation instanceof ReorderNodes) {
			 complete((ReorderNodes) operation);
		 }
		 else if (operation instanceof Move) {
			 complete((Move) operation);
		 }
		 else {
			 throw new IllegalArgumentException();
		 }
	 }
	 public NodeId getId() throws InvalidItemStateException, RepositoryException {
		 return getId(false);
	 }
	 public NodeId getWorkspaceId() throws InvalidItemStateException, RepositoryException {
		 return getId(true);
	 }
	 private NodeId getId(boolean wspId) throws RepositoryException {
		 if (parent == null) {
			 return getIdFactory().createNodeId((String) null, getPathFactory().getRootPath());
		 }
		 else if (uniqueID != null) {
			 return getIdFactory().createNodeId(uniqueID);
		 }
		 else {
			 return buildNodeId(this, getPathFactory(), getIdFactory(), wspId);
		 }
	 }
	 private static NodeId buildNodeId(NodeEntryImpl entry, PathFactory pathFactory, IdFactory idFactory, boolean wspId) throws RepositoryException {
		 PathBuilder pathBuilder = new PathBuilder(pathFactory);
		 while (entry.getParent() != null && entry.getUniqueID() == null) {
			 pathBuilder.addFirst(entry.getName(wspId), entry.getIndex(wspId));
			 entry = (wspId && entry.revertInfo != null) ? entry.revertInfo.oldParent : entry.parent;
		 }
		 if (entry.getParent() == null) {
			 pathBuilder.addRoot();
			 return idFactory.createNodeId((String) null, pathBuilder.getPath());
		 }
		 else {
			 return idFactory.createNodeId(entry.getUniqueID(), pathBuilder.getPath());
		 }
	 }
	 public String getUniqueID() {
		 return uniqueID;
	 }
	 public void setUniqueID(String uniqueID) {
		 String old = this.uniqueID;
		 boolean mod = (uniqueID == null) ? old != null : !uniqueID.equals(old);
		 if (mod) {
			 this.uniqueID = uniqueID;
			 factory.notifyIdChange(this, old);
		 }
	 }
	 public int getIndex() throws InvalidItemStateException, RepositoryException {
		 return getIndex(false);
	 }
	 public NodeState getNodeState() throws ItemNotFoundException, RepositoryException {
		 return (NodeState) getItemState();
	 }
	 public NodeEntry getDeepNodeEntry(Path path) throws PathNotFoundException, RepositoryException {
		 NodeEntryImpl entry = this;
		 Path.Element[] elems = path.getElements();
		 for (int i = 0;
		 i < elems.length;
		 i++) {
			 Path.Element elem = elems[i];
			 if (elem.denotesRoot()) {
				 if (entry.getParent() != null) {
					 throw new RepositoryException(""NodeEntry out of 'hierarchy' "" + path.toString());
				 }
				 continue;
			 }
			 int index = elem.getNormalizedIndex();
			 Name name = elem.getName();
			 NodeEntry cne = entry.getNodeEntry(name, index, false);
			 if (cne != null) {
				 entry = (NodeEntryImpl) cne;
			 }
			 else {
				 if (entry.childNodeEntries.isComplete()) {
					 throw new PathNotFoundException(factory.saveGetJCRPath(path));
				 }
				 List<NodeEntry> siblings = entry.childNodeEntries.get(name);
				 if (entry.containsAtticChild(siblings, name, index)) {
					 throw new PathNotFoundException(factory.saveGetJCRPath(path));
				 }
				 if (entry.getStatus() == Status.NEW) {
					 throw new PathNotFoundException(factory.saveGetJCRPath(path));
				 }
				 PathBuilder pb = new PathBuilder(getPathFactory());
				 for (int j = i;
				 j < elems.length;
				 j++) {
					 pb.addLast(elems[j]);
				 }
				 Path remainingPath = pb.getPath();
				 NodeId parentId = entry.getWorkspaceId();
				 IdFactory idFactory = factory.getIdFactory();
				 NodeId nodeId = idFactory.createNodeId(parentId, remainingPath);
				 NodeEntry ne = entry.loadNodeEntry(nodeId);
				 if (ne != null) {
					 return ne;
				 }
				 else {
					 throw new PathNotFoundException(factory.saveGetJCRPath(path));
				 }
			 }
		 }
		 return entry;
	 }
	 public PropertyEntry getDeepPropertyEntry(Path path) throws PathNotFoundException, RepositoryException {
		 NodeEntryImpl entry = this;
		 Path.Element[] elems = path.getElements();
		 int i = 0;
		 for (;
		 i < elems.length-1;
		 i++) {
			 Path.Element elem = elems[i];
			 if (elems[i].denotesRoot()) {
				 if (entry.getParent() != null) {
					 throw new RepositoryException(""NodeEntry out of 'hierarchy' "" + path.toString());
				 }
				 continue;
			 }
			 int index = elem.getNormalizedIndex();
			 Name name = elem.getName();
			 NodeEntry cne = entry.getNodeEntry(name, index, false);
			 if (cne != null) {
				 entry = (NodeEntryImpl) cne;
			 }
			 else {
				 if (entry.childNodeEntries.isComplete()) {
					 throw new PathNotFoundException(factory.saveGetJCRPath(path));
				 }
				 List<NodeEntry> siblings = entry.childNodeEntries.get(name);
				 if (entry.containsAtticChild(siblings, name, index)) {
					 throw new PathNotFoundException(factory.saveGetJCRPath(path));
				 }
				 break;
			 }
		 }
		 int st = entry.getStatus();
		 PropertyEntry pe;
		 if (i == elems.length-1 && Status.INVALIDATED != st && Status._UNDEFINED_ != st) {
			 pe = entry.properties.get(path.getName());
		 }
		 else {
			 PathBuilder pb = new PathBuilder(getPathFactory());
			 for (int j = i;
			 j < elems.length;
			 j++) {
				 pb.addLast(elems[j]);
			 }
			 Path remainingPath = pb.getPath();
			 IdFactory idFactory = getIdFactory();
			 NodeId parentId = entry.getWorkspaceId();
			 if (remainingPath.getLength() != 1) {
				 parentId = idFactory.createNodeId(parentId, remainingPath.getAncestor(1));
			 }
			 PropertyId propId = idFactory.createPropertyId(parentId, remainingPath.getName());
			 pe = entry.loadPropertyEntry(propId);
		 }
		 if (pe == null) {
			 throw new PathNotFoundException(factory.saveGetJCRPath(path));
		 }
		 return pe;
	 }
	 public HierarchyEntry lookupDeepEntry(Path workspacePath) {
		 NodeEntryImpl entry = this;
		 for (int i = 0;
		 i < workspacePath.getLength();
		 i++) {
			 Path.Element elem = workspacePath.getElements()[i];
			 if (elem.denotesRoot()) {
				 if (getParent() != null) {
					 log.warn(""NodeEntry out of 'hierarchy'"" + workspacePath.toString());
					 return null;
				 }
				 continue;
			 }
			 int index = elem.getNormalizedIndex();
			 Name childName = elem.getName();
			 NodeEntry cne = entry.lookupNodeEntry(null, childName, index);
			 if (cne != null) {
				 entry = (NodeEntryImpl) cne;
			 }
			 else if (index == Path.INDEX_DEFAULT && i == workspacePath.getLength() - 1) {
				 return entry.lookupPropertyEntry(childName);
			 }
			 else {
				 return null;
			 }
		 }
		 return entry;
	 }
	 public synchronized boolean hasNodeEntry(Name nodeName) {
		 List<NodeEntry> namedEntries = childNodeEntries.get(nodeName);
		 if (namedEntries.isEmpty()) {
			 return false;
		 }
		 else {
			 return EntryValidation.containsValidNodeEntry(namedEntries.iterator());
		 }
	 }
	 public synchronized boolean hasNodeEntry(Name nodeName, int index) {
		 try {
			 return getNodeEntry(nodeName, index) != null;
		 }
		 catch (RepositoryException e) {
			 log.debug(""Unable to determine if a child node with name "" + nodeName + "" exists."");
			 return false;
		 }
	 }
	 public synchronized NodeEntry getNodeEntry(Name nodeName, int index) throws RepositoryException {
		 return getNodeEntry(nodeName, index, false);
	 }
	 public NodeEntry getNodeEntry(Name nodeName, int index, boolean loadIfNotFound) throws RepositoryException {
		 List<NodeEntry> entries = childNodeEntries.get(nodeName);
		 NodeEntry cne = null;
		 if (entries.size() >= index) {
			 int eIndex = 1;
			 for (int i = 0;
			 i < entries.size() && cne == null;
			 i++) {
				 NodeEntry ne = entries.get(i);
				 if (EntryValidation.isValidNodeEntry(ne)) {
					 if (eIndex == index) {
						 cne = ne;
					 }
					 eIndex++;
				 }
			 }
		 }
		 if (cne == null && loadIfNotFound && !containsAtticChild(entries, nodeName, index) && !childNodeEntries.isComplete()) {
			 NodeId cId = getIdFactory().createNodeId(getWorkspaceId(), getPathFactory().create(nodeName, index));
			 cne = loadNodeEntry(cId);
		 }
		 return cne;
	 }
	 public synchronized Iterator<NodeEntry> getNodeEntries() throws RepositoryException {
		 Collection<NodeEntry> entries = new ArrayList<NodeEntry>();
		 for (Iterator<NodeEntry> it = getCompleteChildNodeEntries().iterator();
		 it.hasNext();
		) {
			 NodeEntry entry = it.next();
			 if (EntryValidation.isValidNodeEntry(entry)) {
				 entries.add(entry);
			 }
		 }
		 return new RangeIteratorAdapter(Collections.unmodifiableCollection(entries));
	 }
	 public synchronized List<NodeEntry> getNodeEntries(Name nodeName) throws RepositoryException {
		 List<NodeEntry> namedEntries = getCompleteChildNodeEntries().get(nodeName);
		 if (namedEntries.isEmpty()) {
			 return Collections.emptyList();
		 }
		 else {
			 List<NodeEntry> entries = new ArrayList<NodeEntry>();
			 NodeEntry[] arr = namedEntries.toArray(new NodeEntry[namedEntries.size()]);
			 for (int i = 0;
			 i < arr.length;
			 i++) {
				 NodeEntry cne = arr[i];
				 if (EntryValidation.isValidNodeEntry(cne)) {
					 entries.add(cne);
				 }
			 }
			 return Collections.unmodifiableList(entries);
		 }
	 }
	 public void setNodeEntries(Iterator<ChildInfo> childInfos) throws RepositoryException {
		 if (childNodeAttic.isEmpty()) {
			 ((ChildNodeEntriesImpl) childNodeEntries).update(childInfos);
		 }
		 else {
			 List<ChildInfo> remaining = new ArrayList<ChildInfo>();
			 while (childInfos.hasNext()) {
				 ChildInfo ci = childInfos.next();
				 if (!childNodeAttic.contains(ci.getName(), ci.getIndex(), ci.getUniqueID())) {
					 remaining.add(ci);
				 }
			 }
			 ((ChildNodeEntriesImpl) childNodeEntries).update(remaining.iterator());
		 }
	 }
	 public NodeEntry getOrAddNodeEntry(Name nodeName, int index, String uniqueID) throws RepositoryException {
		 NodeEntry ne = lookupNodeEntry(uniqueID, nodeName, index);
		 if (ne == null) {
			 ne = internalAddNodeEntry(nodeName, uniqueID, index);
		 }
		 else {
			 log.debug(""Child NodeEntry already exists -> didn't add."");
		 }
		 return ne;
	 }
	 public NodeEntry addNewNodeEntry(Name nodeName, String uniqueID, Name primaryNodeType, QNodeDefinition definition) throws RepositoryException {
		 NodeEntry entry = internalAddNodeEntry(nodeName, uniqueID, Path.INDEX_UNDEFINED);
		 NodeState state = getItemStateFactory().createNewNodeState(entry, primaryNodeType, definition);
		 entry.setItemState(state);
		 return entry;
	 }
	 public synchronized boolean hasPropertyEntry(Name propName) {
		 PropertyEntry entry = properties.get(propName);
		 return EntryValidation.isValidPropertyEntry(entry);
	 }
	 public synchronized PropertyEntry getPropertyEntry(Name propName) {
		 PropertyEntry entry = properties.get(propName);
		 if (EntryValidation.isValidPropertyEntry(entry)) {
			 return entry;
		 }
		 else {
			 return null;
		 }
	 }
	 public PropertyEntry getPropertyEntry(Name propName, boolean loadIfNotFound) throws RepositoryException {
		 return getPropertyEntry(propName);
	 }
	 public synchronized Iterator<PropertyEntry> getPropertyEntries() {
		 Collection<PropertyEntry> props;
		 if (getStatus() == Status.EXISTING_MODIFIED) {
			 props = new ArrayList<PropertyEntry>();
			 Object[] arr = properties.getPropertyEntries().toArray();
			 for (int i = 0;
			 i < arr.length;
			 i++) {
				 PropertyEntry propEntry = (PropertyEntry) arr[i];
				 if (EntryValidation.isValidPropertyEntry(propEntry)) {
					 props.add(propEntry);
				 }
			 }
		 }
		 else {
			 props = properties.getPropertyEntries();
		 }
		 return new RangeIteratorAdapter(Collections.unmodifiableCollection(props));
	 }
	 public PropertyEntry getOrAddPropertyEntry(Name propName) throws ItemExistsException {
		 PropertyEntry pe = lookupPropertyEntry(propName);
		 if (pe == null) {
			 pe = internalAddPropertyEntry(propName, true);
		 }
		 else {
			 log.debug(""Child PropertyEntry already exists -> didn't add."");
		 }
		 return pe;
	 }
	 public void setPropertyEntries(Collection<Name> propNames) throws ItemExistsException, RepositoryException {
		 Set<Name> diff = new HashSet<Name>();
		 diff.addAll(properties.getPropertyNames());
		 boolean containsExtra = diff.removeAll(propNames);
		 for (Iterator<Name> it = propNames.iterator();
		 it.hasNext();
		) {
			 Name propName = it.next();
			 if (!properties.contains(propName)) {
				 internalAddPropertyEntry(propName, false);
			 }
		 }
		 ItemState state = internalGetItemState();
		 if (containsExtra && (state == null || state.getStatus() == Status.INVALIDATED)) {
			 for (Iterator<Name> it = diff.iterator();
			 it.hasNext();
			) {
				 Name propName = it.next();
				 PropertyEntry pEntry = properties.get(propName);
				 if (pEntry != null) {
					 pEntry.remove();
				 }
			 }
		 }
	 }
	 public PropertyEntry addNewPropertyEntry(Name propName, QPropertyDefinition definition, QValue[] values, int propertyType) throws ItemExistsException, RepositoryException {
		 PropertyEntry existing = properties.get(propName);
		 if (existing != null) {
			 try {
				 PropertyState existingState = existing.getPropertyState();
				 int status = existingState.getStatus();
				 if (Status.isTerminal(status)) {
					 properties.remove(existing);
				 }
				 else if (status == Status.EXISTING_REMOVED) {
					 propertiesInAttic.put(propName, existing);
				 }
				 else {
					 throw new ItemExistsException(propName.toString());
				 }
			 }
			 catch (ItemNotFoundException e) {
				 properties.remove(existing);
			 }
			 catch (RepositoryException e) {
				 properties.remove(existing);
			 }
		 }
		 PropertyEntry entry = factory.createPropertyEntry(this, propName);
		 PropertyState state = getItemStateFactory().createNewPropertyState(entry, definition, values, propertyType);
		 entry.setItemState(state);
		 properties.add(entry);
		 return entry;
	 }
	 public void orderBefore(NodeEntry beforeEntry) throws RepositoryException {
		 if (Status.NEW == getStatus()) {
			 parent.childNodeEntries.reorder(this, beforeEntry);
		 }
		 else {
			 createRevertInfo();
			 parent.childNodeEntries.reorder(this, beforeEntry);
		 }
	 }
	 public NodeEntry move(Name newName, NodeEntry newParent, boolean transientMove) throws RepositoryException {
		 if (parent == null) {
			 throw new RepositoryException(""Root cannot be moved."");
		 }
		 if (transientMove) {
			 createRevertInfo();
			 if (Status.NEW != getStatus()) {
				 if (newParent != revertInfo.oldParent) {
					 revertInfo.oldParent.childNodeAttic.add(this);
				 }
				 else {
					 revertInfo.oldParent.childNodeAttic.remove(this);
				 }
			 }
		 }
		 NodeEntry entry = parent.childNodeEntries.remove(this);
		 if (entry != this) {
			 String msg = ""Internal error. Attempt to move NodeEntry ("" + getName() + "") which is not connected to its parent."";
			 log.error(msg);
			 throw new RepositoryException(msg);
		 }
		 parent = (NodeEntryImpl) newParent;
		 name = newName;
		 parent.childNodeEntries.add(this);
		 return this;
	 }
	 public boolean isTransientlyMoved() {
		 return revertInfo != null && revertInfo.isMoved();
	 }
	 public void refresh(Event childEvent) {
		 ItemId eventId = childEvent.getItemId();
		 Path eventPath = childEvent.getPath();
		 Name eventName = eventPath.getName();
		 HierarchyEntry child = eventId == null ? null : lookupEntry(eventId, eventPath);
		 switch (childEvent.getType()) {
			 case Event.NODE_ADDED: case Event.PROPERTY_ADDED: if (child == null || child.getStatus() == Status.REMOVED) {
				 if (childEvent.getType() == Event.NODE_ADDED) {
					 String uniqueChildID = (eventId.getPath() == null) ? eventId.getUniqueID() : null;
					 int index = eventPath.getNormalizedIndex();
					 internalAddNodeEntry(eventName, uniqueChildID, index);
				 }
				 else {
					 internalAddPropertyEntry(eventName, true);
				 }
			 }
			 else {
				 int status = child.getStatus();
				 if (Status.NEW == status) {
					 internalGetItemState().setStatus(Status.MODIFIED);
				 }
			 }
			 break;
			 case Event.NODE_REMOVED: case Event.PROPERTY_REMOVED: if (child != null) {
				 int status = child.getStatus();
				 if (Status.EXISTING_REMOVED == status) {
					 internalGetItemState().setStatus(Status.MODIFIED);
				 }
				 child.remove();
			 }
			 break;
			 case Event.PROPERTY_CHANGED: if (child == null) {
				 internalAddPropertyEntry(eventName, true);
			 }
			 else if (child.isAvailable()) {
				 int status = child.getStatus();
				 if (Status.isStale(status)) {
				 }
				 else if (Status.isTransient(child.getStatus())) {
					 ((HierarchyEntryImpl) child).internalGetItemState().setStatus(Status.MODIFIED);
				 }
				 else {
					 child.invalidate(false);
					 if (StateUtility.isUuidOrMixin(eventName)) {
						 notifyUUIDorMIXINModified((PropertyEntry) child);
					 }
				 }
			 }
			 break;
			 case Event.NODE_MOVED: throw new UnsupportedOperationException(""Implementation missing"");
			 case Event.PERSIST: throw new UnsupportedOperationException(""Implementation missing"");
			 default: throw new IllegalArgumentException(""Illegal event type "" + childEvent.getType() + "" for NodeState."");
		 }
	 }
	 ItemState doResolve() throws ItemNotFoundException, RepositoryException {
		 return getItemStateFactory().createNodeState(getWorkspaceId(), this);
	 }
	 Path buildPath(boolean wspPath) throws RepositoryException {
		 PathFactory pf = getPathFactory();
		 if (parent == null) {
			 return pf.getRootPath();
		 }
		 PathBuilder builder = new PathBuilder(pf);
		 buildPath(builder, this, wspPath);
		 return builder.getPath();
	 }
	 private static void buildPath(PathBuilder builder, NodeEntryImpl nEntry, boolean wspPath) throws RepositoryException {
		 NodeEntryImpl parentEntry = (wspPath && nEntry.revertInfo != null) ? nEntry.revertInfo.oldParent : nEntry.parent;
		 if (parentEntry == null) {
			 builder.addRoot();
			 return;
		 }
		 buildPath(builder, parentEntry, wspPath);
		 int index = nEntry.getIndex(wspPath);
		 Name name = nEntry.getName(wspPath);
		 builder.addLast(name, index);
	 }
	 private NodeEntry internalAddNodeEntry(Name nodeName, String uniqueID, int index) {
		 NodeEntry entry = factory.createNodeEntry(this, nodeName, uniqueID);
		 childNodeEntries.add(entry, index);
		 return entry;
	 }
	 private PropertyEntry internalAddPropertyEntry(Name propName, boolean notifySpecial) {
		 PropertyEntry entry = factory.createPropertyEntry(this, propName);
		 properties.add(entry);
		 if (notifySpecial && StateUtility.isUuidOrMixin(propName)) {
			 notifyUUIDorMIXINModified(entry);
		 }
		 return entry;
	 }
	 void internalRemoveChildEntry(HierarchyEntry childEntry) {
		 if (childEntry.denotesNode()) {
			 if (childNodeEntries.remove((NodeEntry) childEntry) == null) {
				 childNodeAttic.remove((NodeEntry) childEntry);
			 }
		 }
		 else {
			 Name propName = childEntry.getName();
			 PropertyEntry atticEntry = propertiesInAttic.get(propName);
			 if (atticEntry == null) {
				 properties.remove((PropertyEntry) childEntry);
			 }
			 else if (atticEntry == childEntry) {
				 propertiesInAttic.remove(propName);
			 }
			 if (StateUtility.isUuidOrMixin(propName)) {
				 notifyUUIDorMIXINRemoved(propName);
			 }
		 }
	 }
	 protected void invalidateInternal(boolean recursive) {
		 if (recursive) {
			 for (Iterator<HierarchyEntry> it = getAllChildEntries(true);
			 it.hasNext();
			) {
				 HierarchyEntry ce = it.next();
				 ce.invalidate(true);
			 }
		 }
		 super.invalidateInternal(true);
	 }
	 boolean matches(Name oldName, int oldIndex) {
		 try {
			 return getName(true).equals(oldName) && getIndex(true) == oldIndex;
		 }
		 catch (RepositoryException e) {
			 return false;
		 }
	 }
	 boolean matches(Name oldName) {
		 return getName(true).equals(oldName);
	 }
	 private Name getName(boolean wspName) {
		 if (wspName && revertInfo != null) {
			 return revertInfo.oldName;
		 }
		 else {
			 return name;
		 }
	 }
	 private int getIndex(boolean wspIndex) throws InvalidItemStateException, RepositoryException {
		 if (parent == null) {
			 return Path.INDEX_DEFAULT;
		 }
		 if (wspIndex && revertInfo != null) {
			 return revertInfo.oldIndex;
		 }
		 else {
			 NodeState state = (NodeState) internalGetItemState();
			 if (state == null || !state.hasDefinition() || state.getDefinition().allowsSameNameSiblings()) {
				 return parent.getChildIndex(this, wspIndex);
			 }
			 else {
				 return Path.INDEX_DEFAULT;
			 }
		 }
	 }
	 private NodeEntry loadNodeEntry(NodeId childId) throws RepositoryException {
		 try {
			 NodeState state = getItemStateFactory().createDeepNodeState(childId, this);
			 return state.getNodeEntry();
		 }
		 catch (ItemNotFoundException e) {
			 return null;
		 }
	 }
	 private PropertyEntry loadPropertyEntry(PropertyId childId) throws RepositoryException {
		 try {
			 PropertyState state = getItemStateFactory().createDeepPropertyState(childId, this);
			 return (PropertyEntry) state.getHierarchyEntry();
		 }
		 catch (ItemNotFoundException e) {
			 return null;
		 }
	 }
	 private HierarchyEntry lookupEntry(ItemId eventId, Path eventPath) {
		 Name childName = eventPath.getName();
		 HierarchyEntry child;
		 if (eventId.denotesNode()) {
			 String uniqueChildID = (eventId.getPath() == null) ? eventId.getUniqueID() : null;
			 int index = eventPath.getNormalizedIndex();
			 child = lookupNodeEntry(uniqueChildID, childName, index);
		 }
		 else {
			 child = lookupPropertyEntry(childName);
		 }
		 return child;
	 }
	 private NodeEntry lookupNodeEntry(String uniqueChildId, Name childName, int index) {
		 NodeEntry child = null;
		 if (uniqueChildId != null) {
			 child = childNodeAttic.get(uniqueChildId);
			 if (child == null) {
				 child = childNodeEntries.get(childName, uniqueChildId);
			 }
		 }
		 if (child == null) {
			 child = childNodeAttic.get(childName, index);
			 if (child == null && childNodeEntries != null) {
				 child = childNodeEntries.get(childName, index);
			 }
		 }
		 return child;
	 }
	 private PropertyEntry lookupPropertyEntry(Name childName) {
		 PropertyEntry child = propertiesInAttic.get(childName);
		 if (child == null) {
			 child = properties.get(childName);
		 }
		 return child;
	 }
	 private void notifyUUIDorMIXINModified(PropertyEntry child) {
		 try {
			 if (NameConstants.JCR_UUID.equals(child.getName())) {
				 PropertyState ps = child.getPropertyState();
				 setUniqueID(ps.getValue().getString());
			 }
			 else if (NameConstants.JCR_MIXINTYPES.equals(child.getName())) {
				 NodeState state = (NodeState) internalGetItemState();
				 if (state != null) {
					 PropertyState ps = child.getPropertyState();
					 state.setMixinTypeNames(StateUtility.getMixinNames(ps));
				 }
			 }
		 }
		 catch (ItemNotFoundException e) {
			 log.debug(""Property with name "" + child.getName() + "" does not exist (anymore)"");
		 }
		 catch (RepositoryException e) {
			 log.debug(""Unable to access child property "" + child.getName(), e.getMessage());
		 }
	 }
	 private void notifyUUIDorMIXINRemoved(Name propName) {
		 if (NameConstants.JCR_UUID.equals(propName)) {
			 setUniqueID(null);
		 }
		 else if (NameConstants.JCR_MIXINTYPES.equals(propName)) {
			 NodeState state = (NodeState) internalGetItemState();
			 if (state != null) {
				 state.setMixinTypeNames(Name.EMPTY_ARRAY);
			 }
		 }
	 }
	 private ChildNodeEntries getCompleteChildNodeEntries() throws InvalidItemStateException, RepositoryException {
		 try {
			 childNodeEntries.reload();
		 }
		 catch (ItemNotFoundException e) {
			 log.debug(""NodeEntry does not exist (anymore) -> remove."");
			 remove();
			 throw new InvalidItemStateException(e);
		 }
		 return childNodeEntries;
	 }
	 private Iterator<HierarchyEntry> getAllChildEntries(boolean includeAttic) {
		 IteratorChain<HierarchyEntry> chain = new IteratorChain<>();
		 if (includeAttic) {
			 Collection<PropertyEntry> attic = propertiesInAttic.values();
			 chain.addIterator(new ArrayList<PropertyEntry>(attic).iterator());
		 }
		 synchronized (properties) {
			 Collection<PropertyEntry> props = properties.getPropertyEntries();
			 chain.addIterator(props.iterator());
		 }
		 synchronized (childNodeEntries) {
			 chain.addIterator(childNodeEntries.iterator());
		 }
		 return chain;
	 }
	 private int getChildIndex(NodeEntry cne, boolean wspIndex) throws ItemNotFoundException, RepositoryException {
		 List<NodeEntry> sns = new ArrayList<NodeEntry>(childNodeEntries.get(cne.getName()));
		 if (wspIndex) {
			 List<NodeEntryImpl> atticSiblings = childNodeAttic.get(cne.getName());
			 for (Iterator<NodeEntryImpl> it = atticSiblings.iterator();
			 it.hasNext();
			) {
				 NodeEntryImpl sibl = it.next();
				 if (sibl.revertInfo != null) {
					 sns.add(sibl.revertInfo.oldIndex - 1, sibl);
				 }
				 else {
					 log.error(""Sibling in attic doesn't have revertInfo...."");
				 }
			 }
		 }
		 if (sns.isEmpty()) {
			 String msg = ""NodeEntry "" + cne.getName() + "" is disconnected from its parent -> remove."";
			 cne.remove();
			 throw new InvalidItemStateException(msg);
		 }
		 else if (sns.size() == 1) {
			 return Path.INDEX_DEFAULT;
		 }
		 else {
			 int index = Path.INDEX_DEFAULT;
			 for (Iterator<NodeEntry> it = sns.iterator();
			 it.hasNext();
			 ) {
				 NodeEntry entry = it.next();
				 if (entry == cne) {
					 return index;
				 }
				 boolean isValid = (wspIndex) ? EntryValidation.isValidWorkspaceNodeEntry(entry) : EntryValidation.isValidNodeEntry(entry);
				 if (isValid) {
					 index++;
				 }
			 }
			 return Path.INDEX_DEFAULT;
		 }
	 }
	 private boolean containsAtticChild(List<NodeEntry> siblings, Name childName, int childIndex) {
		 if (childNodeAttic.contains(childName, childIndex)) {
			 return true;
		 }
		 if (childIndex > Path.INDEX_DEFAULT) {
			 List<NodeEntryImpl> siblingsInAttic = childNodeAttic.get(childName);
			 if (siblings.size() < childIndex && childIndex <= siblings.size() + siblingsInAttic.size()) {
				 return true;
			 }
		 }
		 if (getStatus() == Status.EXISTING_MODIFIED) {
			 for (Iterator<NodeEntry> it = siblings.iterator();
			 it.hasNext();
			) {
				 NodeEntry child = it.next();
				 if (!EntryValidation.isValidNodeEntry(child) || ((NodeEntryImpl)child).revertInfo != null && ((NodeEntryImpl)child).revertInfo.oldIndex == childIndex) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 private void createRevertInfo() throws RepositoryException {
		 if (revertInfo == null && getStatus() != Status.NEW) {
			 revertInfo = new RevertInfo();
		 }
	 }
	 private void complete(AddNode operation) throws RepositoryException {
		 if (operation.getParentState().getHierarchyEntry() != this) {
			 throw new IllegalArgumentException();
		 }
		 for (Iterator<ItemState> it = operation.getAddedStates().iterator();
		 it.hasNext();
		) {
			 HierarchyEntry he = it.next().getHierarchyEntry();
			 if (he.getStatus() == Status.NEW) {
				 switch (operation.getStatus()) {
					 case Operation.STATUS_PERSISTED: ((HierarchyEntryImpl) he).internalGetItemState().setStatus(Status.EXISTING);
					 he.invalidate(false);
					 break;
					 case Operation.STATUS_UNDO: he.revert();
					 break;
				 default: }
			 }
		 }
	 }
	 private void complete(AddProperty operation) throws RepositoryException {
		 if (operation.getParentState().getHierarchyEntry() != this) {
			 throw new IllegalArgumentException();
		 }
		 PropertyEntry pe = getPropertyEntry(operation.getPropertyName());
		 if (pe != null && pe.getStatus() == Status.NEW) {
			 switch (operation.getStatus()) {
				 case Operation.STATUS_PERSISTED: PropertyState addedState = (PropertyState) ((PropertyEntryImpl) pe).internalGetItemState();
				 addedState.setStatus(Status.EXISTING);
				 QPropertyDefinition pd = addedState.getDefinition();
				 if (pd.isAutoCreated() || pd.isProtected()) {
					 pe.invalidate(true);
				 }
				 break;
				 case Operation.STATUS_UNDO: pe.revert();
				 break;
			 default: }
		 }
	 }
	 private void complete(Remove operation) throws RepositoryException {
		 HierarchyEntry rmEntry = operation.getRemoveState().getHierarchyEntry();
		 if (rmEntry.getParent() != this) {
			 throw new IllegalArgumentException();
		 }
		 switch (operation.getStatus()) {
			 case Operation.STATUS_PERSISTED: if (Status.isTerminal(rmEntry.getStatus())) {
				 log.debug(""Removal of State "" + rmEntry + "" has already been completed."");
			 }
			 rmEntry.remove();
			 break;
			 case Operation.STATUS_UNDO: if (!rmEntry.denotesNode()) {
				 Name propName = rmEntry.getName();
				 if (propertiesInAttic.containsKey(propName)) {
					 properties.add(propertiesInAttic.remove(propName));
				 }
			 }
			 rmEntry.revert();
			 break;
		 default: }
	 }
	 private void complete(SetMixin operation) throws RepositoryException {
		 if (operation.getNodeState().getHierarchyEntry() != this) {
			 throw new IllegalArgumentException();
		 }
		 PropertyEntry pe = getPropertyEntry(NameConstants.JCR_MIXINTYPES);
		 if (pe != null) {
			 PropertyState pState = pe.getPropertyState();
			 switch (operation.getStatus()) {
				 case Operation.STATUS_PERSISTED: Name[] mixins = StateUtility.getMixinNames(pState);
				 getNodeState().setMixinTypeNames(mixins);
				 if (pState.getStatus() == Status.NEW || pState.getStatus() == Status.EXISTING_MODIFIED) {
					 pState.setStatus(Status.EXISTING);
				 }
				 break;
				 case Operation.STATUS_UNDO: pe.revert();
				 break;
			 default: }
		 }
	 }
	 private void complete(SetPrimaryType operation) throws RepositoryException {
		 if (operation.getNodeState().getHierarchyEntry() != this) {
			 throw new IllegalArgumentException();
		 }
		 PropertyEntry pe = getPropertyEntry(NameConstants.JCR_PRIMARYTYPE);
		 if (pe != null) {
			 PropertyState pState = pe.getPropertyState();
			 switch (operation.getStatus()) {
				 case Operation.STATUS_PERSISTED: if (pState.getStatus() == Status.NEW || pState.getStatus() == Status.EXISTING_MODIFIED) {
					 pState.setStatus(Status.EXISTING);
				 }
				 break;
				 case Operation.STATUS_UNDO: pe.revert();
				 break;
			 default: }
		 }
	 }
	 private void complete(ReorderNodes operation) throws RepositoryException {
		 HierarchyEntry he = operation.getInsertNode().getHierarchyEntry();
		 if (he != this) {
			 throw new IllegalArgumentException();
		 }
		 switch (operation.getStatus()) {
			 case Operation.STATUS_PERSISTED: if (revertInfo != null && !revertInfo.isMoved()) {
				 revertInfo.dispose(true);
			 }
			 break;
			 case Operation.STATUS_UNDO: if (he.getStatus() == Status.NEW) {
				 he.revert();
			 }
			 else if (revertInfo != null && !revertInfo.isMoved()) {
				 revertInfo.dispose(false);
			 }
			 break;
		 default: }
	 }
	 private void complete(Move operation) throws RepositoryException {
		 HierarchyEntry he = operation.getSourceState().getHierarchyEntry();
		 if (he != this) {
			 throw new IllegalArgumentException();
		 }
		 switch (operation.getStatus()) {
			 case Operation.STATUS_PERSISTED: if (getStatus() != Status.NEW && revertInfo != null) {
				 revertInfo.oldParent.childNodeAttic.remove(this);
				 revertInfo.dispose(true);
			 }
			 break;
			 case Operation.STATUS_UNDO: if (getStatus() == Status.NEW) {
				 revert();
			 }
			 else if (revertInfo != null) {
				 revertMove();
				 revertInfo.dispose(false);
			 }
			 break;
		 default: }
	 }
	 private void revertMove() {
		 NodeEntryImpl oldParent = revertInfo.oldParent;
		 if (oldParent == parent) {
			 parent.childNodeEntries.remove(this);
		 }
		 else {
			 parent.childNodeEntries.remove(this);
			 oldParent.childNodeAttic.remove(this);
			 parent = oldParent;
		 }
		 name = revertInfo.oldName;
		 parent.childNodeEntries.add(this, revertInfo.oldIndex, revertInfo.oldSuccessor);
	 }
	 private class RevertInfo {
		 private final NodeEntryImpl oldParent;
		 private final Name oldName;
		 private final int oldIndex;
		 private final NodeEntry oldSuccessor;
		 private final NodeEntry oldPredecessor;
		 private RevertInfo() throws InvalidItemStateException, RepositoryException {
			 this.oldParent = parent;
			 this.oldName = name;
			 this.oldIndex = getIndex();
			 this.oldSuccessor = ((ChildNodeEntriesImpl) parent.childNodeEntries).getNext(NodeEntryImpl.this);
			 this.oldPredecessor = ((ChildNodeEntriesImpl) parent.childNodeEntries).getPrevious(NodeEntryImpl.this);
		 }
		 private boolean isMoved() {
			 return oldParent != getParent() || !getName().equals(oldName);
		 }
		 private void dispose(boolean persisted) {
			 if (!persisted) {
				 NodeEntry ne = NodeEntryImpl.this;
				 ChildNodeEntriesImpl parentCNEs = (ChildNodeEntriesImpl) parent.childNodeEntries;
				 parentCNEs.reorderAfter(ne, revertInfo.oldPredecessor);
				 try {
					 if (oldIndex != ne.getIndex()) {
						 log.warn(""Reverting didn't restore the correct index."");
					 }
				 }
				 catch (RepositoryException e) {
					 log.warn(""Unable to calculate index. {
					}
					"", e.getMessage());
				 }
			 }
			 revertInfo = null;
		 }
	 }
}",1,0,0,0
"public class ByteBufferOutputStream extends OutputStream {
	private static Logger logger = Logger.getLogger(ByteBufferOutputStream.class.getName());
	static {
		logger.setLevel(Level.INFO);
	}
	public static void setDebug(boolean flag) {
		if(flag) logger.setLevel(Level.FINEST);
		elselogger.setLevel(Level.INFO);
	}
	public static boolean isLoggable(Level level) {
		return logger.isLoggable(level);
	}
	private ArrayList bufferList;
	private ByteBuffer lastByteBuffer = null;
	private NonBlockingClientHandler handler;
	private Object toNotify = null;
	public ByteBufferOutputStream(ArrayList bufferList, ClientHandler handler) {
		if(bufferList==null || handler==null)throw new IllegalArgumentException(""ArrayList or ClientHandler was null."");
		this.bufferList = bufferList;
		this.handler = (NonBlockingClientHandler) handler;
	}
	public synchronized void close() {
		if(lastByteBuffer!=null) {
			returnBufferBack(lastByteBuffer);
		}
	}
	public void flush() throws IOException {
		if(bufferList.size()!=0 || lastByteBuffer!=null) {
			handler.registerWrite();
		}
		 else {
			return;
		}
		while(bufferList.size()>=5) {
			handler.waitTillFullyWritten();
		}
	}
	public synchronized void write(int b) throws IOException {
		handler.isConnected();
		ByteBuffer byteBuffer = null;
		if(bufferList.size()!=0) {
			byteBuffer = (ByteBuffer) bufferList.remove(bufferList.size()-1);
			if(byteBuffer.remaining()==0) {
				bufferList.add(byteBuffer);
				byteBuffer = null;
			}
		}
		try {
			if(byteBuffer==null) {
				byteBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
			}
		}
		 catch(Exception e) {
			logger.warning(""Could not borrow ByteBufer from pool: ""+e);
			throw new IOException(e.toString());
		}
		byteBuffer.put((byte)b);
		bufferList.add(byteBuffer);
	}
	public void write(byte[] b) throws IOException {
		write(b, 0, b.length);
	}
	public synchronized void write(byte[] b, int off, int len) throws IOException {
		if(len==0) {
			return;
		}
		handler.isConnected();
		ByteBuffer byteBuffer = null;
		int remaining = 0;
		int toWrite = len;
		if(toWrite!=0 && bufferList.size()!=0) {
			byteBuffer = (ByteBuffer) bufferList.remove(bufferList.size()-1);
			if(byteBuffer.remaining()==0) {
				bufferList.add(byteBuffer);
				byteBuffer = null;
			}
		}
		while(toWrite!=0) {
			try {
				if(byteBuffer==null) {
					byteBuffer = (ByteBuffer) handler.getServer().getByteBufferPool().borrowObject();
				}
			}
			 catch(Exception e) {
				logger.warning(""Could not borrow ByteBufer from pool: ""+e);
				throw new IOException(e.toString());
			}
			remaining = byteBuffer.remaining();
			if(remaining < toWrite) {
				byteBuffer.put(b, off, remaining);
				off = off + remaining;
				toWrite = toWrite - remaining;
			}
			 else {
				byteBuffer.put(b, off, toWrite);
				toWrite=0;
			}
			bufferList.add(byteBuffer);
			byteBuffer = null;
		}
	}
	public synchronized boolean writeAllByteBuffer() throws IOException {
		if(lastByteBuffer!=null) {
			writeLastByteBuffer();
			if(lastByteBuffer!=null) return false;
		}
		if(bufferList.size()==0) {
			if(toNotify!=null) {
				synchronized(toNotify) {
					toNotify.notify();
					toNotify = null;
				}
			}
			return true;
		}
		while(bufferList.size()!=0) {
			lastByteBuffer = (ByteBuffer) bufferList.remove(0);
			lastByteBuffer.flip();
			writeLastByteBuffer();
			if(lastByteBuffer != null) return false;
		}
		if(toNotify!=null) {
			synchronized(toNotify) {
				toNotify.notify();
				toNotify = null;
			}
		}
		return true;
	}
	private synchronized void writeLastByteBuffer() throws IOException {
		int written = 0;
		while(lastByteBuffer.remaining()!=0) {
			java.nio.channels.SocketChannel sc = handler.getSocketChannel();
			if(sc!=null && sc.isOpen()) {
				written = sc.write(lastByteBuffer);
				if(written==0) {
					break;
				}
				if(logger.isLoggable(Level.FINEST)) {
					 logger.finest(""Written ""+written+"" bytes"");
				}
			}
			 else {
				throw new IOException(""SocketChannel was closed."");
			}
		}
		if(lastByteBuffer.remaining()==0) {
			returnBufferBack(lastByteBuffer);
			lastByteBuffer = null;
		}
	}
	private void returnBufferBack(ByteBuffer byteBuffer) {
		try {
			handler.getServer().getByteBufferPool().returnObject(byteBuffer);
		}
		 catch(Exception er) {
			logger.warning(""Error while returning ByteBuffer to pool: ""+er);
		}
	}
	public void forceNotify() {
		if(toNotify==null) return;
		synchronized(toNotify) {
			toNotify.notify();
			toNotify = null;
		}
	}
	public boolean isDataAvailableForWrite(Object toNotify) {
		if(lastByteBuffer!=null) {
			if(this.toNotify!=null) {
				throw new IllegalStateException(""toNotify object was already set!"");
			}
			this.toNotify = toNotify;
			return true;
		}
		if(bufferList.size()==0) {
			return false;
		}
		 else {
			if(this.toNotify!=null) {
				throw new IllegalStateException(""toNotify object was already set!"");
			}
			this.toNotify = toNotify;
			return true;
		}
	}
}",1,0,0,0
"public ConnectionTableNIO(Receiver r, InetAddress bind_addr, InetAddress external_addr, int srv_port, int max_port, long reaper_interval, long conn_expire_time, boolean doStart ) throws Exception;",0,0,0,1
"public static void validateMutation(String keyspace, String cfName, Mutation mut) throws InvalidRequestException {
	 ColumnOrSuperColumn cosc = mut.column_or_supercolumn;
	 Deletion del = mut.deletion;
	 if (cosc != null && del != null) throw new InvalidRequestException(""Mutation may have either a ColumnOrSuperColumn or a Deletion, but not both"");
	 if (cosc != null) {
		 validateColumnOrSuperColumn(keyspace, cfName, cosc);
	 }
	 else if (del != null) {
		 validateDeletion(keyspace, cfName, del);
	 }
	 else {
		 throw new InvalidRequestException(""Mutation must have one ColumnOrSuperColumn or one Deletion"");
	 }
 }",0,0,0,0
"public class Product {
	 private long id;
	 private String description;
	 public long getId() {
		 return id;
	 }
	 public void setId(long id) {
		 this.id = id;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public void setDescription(String d) {
		 this.description = d;
	 }
}",0,1,0,0
"public abstract class Task extends ProjectComponent {
	 protected Target target;
	 protected String taskName;
	 protected String taskType;
	 protected RuntimeConfigurable wrapper;
	 private boolean invalid;
	 public Task() {
	 }
	 public void setOwningTarget(Target target) {
		 this.target = target;
	 }
	 public Target getOwningTarget() {
		 return target;
	 }
	 public void setTaskName(String name) {
		 this.taskName = name;
	 }
	 public String getTaskName() {
		 return taskName;
	 }
	 public void setTaskType(String type) {
		 this.taskType = type;
	 }
	 public void init() throws BuildException {
	 }
	 public void execute() throws BuildException {
	 }
	 public RuntimeConfigurable getRuntimeConfigurableWrapper() {
		 if (wrapper == null) {
			 wrapper = new RuntimeConfigurable(this, getTaskName());
		 }
		 return wrapper;
	 }
	 public void setRuntimeConfigurableWrapper(RuntimeConfigurable wrapper) {
		 this.wrapper = wrapper;
	 }
	 public void maybeConfigure() throws BuildException {
		 if (!invalid) {
			 if (wrapper != null) {
				 wrapper.maybeConfigure(getProject());
			 }
		 }
		 else {
			 getReplacement();
		 }
	 }
	 public void reconfigure() {
		 if (wrapper != null) {
			 wrapper.reconfigure(getProject());
		 }
	 }
	 protected void handleOutput(String output) {
		 log(output, Project.MSG_INFO);
	 }
	 protected void handleFlush(String output) {
		 handleOutput(output);
	 }
	 protected int handleInput(byte[] buffer, int offset, int length) throws IOException {
		 return getProject().defaultInput(buffer, offset, length);
	 }
	 protected void handleErrorOutput(String output) {
		 log(output, Project.MSG_WARN);
	 }
	 protected void handleErrorFlush(String output) {
		 handleErrorOutput(output);
	 }
	 public void log(String msg) {
		 log(msg, Project.MSG_INFO);
	 }
	 public void log(String msg, int msgLevel) {
		 if (getProject() != null) {
			 getProject().log(this, msg, msgLevel);
		 }
		 else {
			 super.log(msg, msgLevel);
		 }
	 }
	 public void log(Throwable t, int msgLevel) {
		 if (t != null) {
			 log(t.getMessage(), t, msgLevel);
		 }
	 }
	 public void log(String msg, Throwable t, int msgLevel) {
		 if (getProject() != null) {
			 getProject().log(this, msg, t, msgLevel);
		 }
		 else {
			 super.log(msg, msgLevel);
		 }
	 }
	 public final void perform() {
		 if (!invalid) {
			 getProject().fireTaskStarted(this);
			 Throwable reason = null;
			 try {
				 maybeConfigure();
				 DispatchUtils.execute(this);
			 }
			 catch (BuildException ex) {
				 if (ex.getLocation() == Location.UNKNOWN_LOCATION) {
					 ex.setLocation(getLocation());
				 }
				 reason = ex;
				 throw ex;
			 }
			 catch (Exception ex) {
				 reason = ex;
				 BuildException be = new BuildException(ex);
				 be.setLocation(getLocation());
				 throw be;
			 }
			 catch (Error ex) {
				 reason = ex;
				 throw ex;
			 }
			 finally {
				 getProject().fireTaskFinished(this, reason);
			 }
		 }
		 else {
			 UnknownElement ue = getReplacement();
			 Task task = ue.getTask();
			 task.perform();
		 }
	 }
	 final void markInvalid() {
		 invalid = true;
	 }
	 protected final boolean isInvalid() {
		 return invalid;
	 }
	 private UnknownElement replacement;
	 private UnknownElement getReplacement() {
		 if (replacement == null) {
			 replacement = new UnknownElement(taskType);
			 replacement.setProject(getProject());
			 replacement.setTaskType(taskType);
			 replacement.setTaskName(taskName);
			 replacement.setLocation(getLocation());
			 replacement.setOwningTarget(target);
			 replacement.setRuntimeConfigurableWrapper(wrapper);
			 wrapper.setProxy(replacement);
			 replaceChildren(wrapper, replacement);
			 target.replaceChild(this, replacement);
			 replacement.maybeConfigure();
		 }
		 return replacement;
	 }
	 private void replaceChildren(RuntimeConfigurable wrapper, UnknownElement parentElement) {
		 Enumeration e = wrapper.getChildren();
		 while (e.hasMoreElements()) {
			 RuntimeConfigurable childWrapper = (RuntimeConfigurable) e.nextElement();
			 UnknownElement childElement = new UnknownElement(childWrapper.getElementTag());
			 parentElement.addChild(childElement);
			 childElement.setProject(getProject());
			 childElement.setRuntimeConfigurableWrapper(childWrapper);
			 childWrapper.setProxy(childElement);
			 replaceChildren(childWrapper, childElement);
		 }
	 }
	 public String getTaskType() {
		 return taskType;
	 }
	 protected RuntimeConfigurable getWrapper() {
		 return wrapper;
	 }
	 public final void bindToOwner(Task owner) {
		 setProject(owner.getProject());
		 setOwningTarget(owner.getOwningTarget());
		 setTaskName(owner.getTaskName());
		 setDescription(owner.getDescription());
		 setLocation(owner.getLocation());
		 setTaskType(owner.getTaskType());
	 }
}",0,0,0,0
"public abstract class AbstractControllerService extends AbstractConfigurableComponent implements ControllerService {
	 private String identifier;
	 private ControllerServiceLookup serviceLookup;
	 private ComponentLog logger;
	 private StateManager stateManager;
	 private volatile ConfigurationContext configurationContext;
	 private volatile boolean enabled = false;
	 public final void initialize(final ControllerServiceInitializationContext context) throws InitializationException {
		 this.identifier = context.getIdentifier();
		 serviceLookup = context.getControllerServiceLookup();
		 logger = context.getLogger();
		 stateManager = context.getStateManager();
		 init(context);
	 }
	 public String getIdentifier() {
		 return identifier;
	 }
	 protected final ControllerServiceLookup getControllerServiceLookup() {
		 return serviceLookup;
	 }
	 protected void init(final ControllerServiceInitializationContext config) throws InitializationException {
	 }
	 public final void enabled() {
		 this.enabled = true;
	 }
	 public final void disabled() {
		 this.enabled = false;
	 }
	 public boolean isEnabled() {
		 return this.enabled;
	 }
	 protected ComponentLog getLogger() {
		 return logger;
	 }
	 protected StateManager getStateManager() {
		 return stateManager;
	 }
	 public final void abstractStoreConfigContext(final ConfigurationContext configContext) {
		 this.configurationContext = configContext;
	 }
	 public final void abstractClearConfigContext() {
		 this.configurationContext = null;
	 }
	 protected ConfigurationContext getConfigurationContext() {
		 final ConfigurationContext context = this.configurationContext;
		 if (context == null) {
			 throw new IllegalStateException(""No Configuration Context exists"");
		 }
		 return configurationContext;
	 }
	 protected PropertyValue getProperty(final PropertyDescriptor descriptor) {
		 return getConfigurationContext().getProperty(descriptor);
	 }
}",1,1,0,0
"public class Job20LineHistoryEventEmitter extends HistoryEventEmitter {
	 static List<SingleEventEmitter> nonFinals = new LinkedList<SingleEventEmitter>();
	 static List<SingleEventEmitter> finals = new LinkedList<SingleEventEmitter>();
	 Long originalSubmitTime = null;
	 static {
		 nonFinals.add(new JobSubmittedEventEmitter());
		 nonFinals.add(new JobPriorityChangeEventEmitter());
		 nonFinals.add(new JobStatusChangedEventEmitter());
		 nonFinals.add(new JobInitedEventEmitter());
		 nonFinals.add(new JobInfoChangeEventEmitter());
		 finals.add(new JobUnsuccessfulCompletionEventEmitter());
		 finals.add(new JobFinishedEventEmitter());
	 }
	 Job20LineHistoryEventEmitter() {
		 super();
	 }
	 static private class JobSubmittedEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 JobID jobID = JobID.forName(jobIDName);
			 if (jobIDName == null) {
				 return null;
			 }
			 String submitTime = line.get(""SUBMIT_TIME"");
			 String jobConf = line.get(""JOBCONF"");
			 String user = line.get(""USER"");
			 if (user == null) {
				 user = ""nulluser"";
			 }
			 String jobName = line.get(""JOBNAME"");
			 String jobQueueName = line.get(""JOB_QUEUE"");
			 String workflowId = line.get(""WORKFLOW_ID"");
			 if (workflowId == null) {
				 workflowId = """";
			 }
			 String workflowName = line.get(""WORKFLOW_NAME"");
			 if (workflowName == null) {
				 workflowName = """";
			 }
			 String workflowNodeName = line.get(""WORKFLOW_NODE_NAME"");
			 if (workflowNodeName == null) {
				 workflowNodeName = """";
			 }
			 String workflowAdjacencies = line.get(""WORKFLOW_ADJACENCIES"");
			 if (workflowAdjacencies == null) {
				 workflowAdjacencies = """";
			 }
			 String workflowTags = line.get(""WORKFLOW_TAGS"");
			 if (workflowTags == null) {
				 workflowTags = """";
			 }
			 if (submitTime != null) {
				 Job20LineHistoryEventEmitter that = (Job20LineHistoryEventEmitter) thatg;
				 that.originalSubmitTime = Long.parseLong(submitTime);
				 Map<JobACL, AccessControlList> jobACLs = new HashMap<JobACL, AccessControlList>();
				 return new JobSubmittedEvent(jobID, jobName, user, that.originalSubmitTime, jobConf, jobACLs, jobQueueName, workflowId, workflowName, workflowNodeName, workflowAdjacencies, workflowTags);
			 }
			 return null;
		 }
	 }
	 static private class JobPriorityChangeEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 JobID jobID = JobID.forName(jobIDName);
			 if (jobIDName == null) {
				 return null;
			 }
			 String priority = line.get(""JOB_PRIORITY"");
			 if (priority != null) {
				 return new JobPriorityChangeEvent(jobID, JobPriority.valueOf(priority));
			 }
			 return null;
		 }
	 }
	 static private class JobInitedEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 if (jobIDName == null) {
				 return null;
			 }
			 JobID jobID = JobID.forName(jobIDName);
			 String launchTime = line.get(""LAUNCH_TIME"");
			 String status = line.get(""JOB_STATUS"");
			 String totalMaps = line.get(""TOTAL_MAPS"");
			 String totalReduces = line.get(""TOTAL_REDUCES"");
			 String uberized = line.get(""UBERIZED"");
			 if (launchTime != null && totalMaps != null && totalReduces != null) {
				 return new JobInitedEvent(jobID, Long.parseLong(launchTime), Integer .parseInt(totalMaps), Integer.parseInt(totalReduces), status, Boolean.parseBoolean(uberized));
			 }
			 return null;
		 }
	 }
	 static private class JobStatusChangedEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 if (jobIDName == null) {
				 return null;
			 }
			 JobID jobID = JobID.forName(jobIDName);
			 String status = line.get(""JOB_STATUS"");
			 if (status != null) {
				 return new JobStatusChangedEvent(jobID, status);
			 }
			 return null;
		 }
	 }
	 static private class JobInfoChangeEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 if (jobIDName == null) {
				 return null;
			 }
			 JobID jobID = JobID.forName(jobIDName);
			 String launchTime = line.get(""LAUNCH_TIME"");
			 if (launchTime != null) {
				 Job20LineHistoryEventEmitter that = (Job20LineHistoryEventEmitter) thatg;
				 return new JobInfoChangeEvent(jobID, that.originalSubmitTime, Long .parseLong(launchTime));
			 }
			 return null;
		 }
	 }
	 static private class JobUnsuccessfulCompletionEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 if (jobIDName == null) {
				 return null;
			 }
			 JobID jobID = JobID.forName(jobIDName);
			 String finishTime = line.get(""FINISH_TIME"");
			 String status = line.get(""JOB_STATUS"");
			 String finishedMaps = line.get(""FINISHED_MAPS"");
			 String finishedReduces = line.get(""FINISHED_REDUCES"");
			 if (status != null && !status.equalsIgnoreCase(""success"") && finishTime != null && finishedMaps != null && finishedReduces != null) {
				 return new JobUnsuccessfulCompletionEvent(jobID, Long .parseLong(finishTime), Integer.parseInt(finishedMaps), Integer .parseInt(finishedReduces), -1, -1, -1, -1, status);
			 }
			 return null;
		 }
	 }
	 static private class JobFinishedEventEmitter extends SingleEventEmitter {
		 HistoryEvent maybeEmitEvent(ParsedLine line, String jobIDName, HistoryEventEmitter thatg) {
			 if (jobIDName == null) {
				 return null;
			 }
			 JobID jobID = JobID.forName(jobIDName);
			 String finishTime = line.get(""FINISH_TIME"");
			 String status = line.get(""JOB_STATUS"");
			 String finishedMaps = line.get(""FINISHED_MAPS"");
			 String finishedReduces = line.get(""FINISHED_REDUCES"");
			 String failedMaps = line.get(""FAILED_MAPS"");
			 String failedReduces = line.get(""FAILED_REDUCES"");
			 String counters = line.get(""COUNTERS"");
			 if (status != null && status.equalsIgnoreCase(""success"") && finishTime != null && finishedMaps != null && finishedReduces != null) {
				 return new JobFinishedEvent(jobID, Long.parseLong(finishTime), Integer .parseInt(finishedMaps), Integer.parseInt(finishedReduces), Integer .parseInt(failedMaps), Integer.parseInt(failedReduces), -1, -1, null, null, maybeParseCounters(counters));
			 }
			 return null;
		 }
	 }
	 List<SingleEventEmitter> finalSEEs() {
		 return finals;
	 }
	 List<SingleEventEmitter> nonFinalSEEs() {
		 return nonFinals;
	 }
}",1,1,0,0
"public String getUrl() {
	 ensureInflated();
	 return url;
 }",0,0,0,0
"public interface ArtifactDiscoveryListener{
	 void artifactDiscovered( ArtifactContext ac );
}",0,0,0,0
"abstract public class ToStream extends SerializerBase{
	 private static final String COMMENT_BEGIN = ""<!--"";
	 private static final String COMMENT_END = ""-->"";
	 protected BoolStack m_disableOutputEscapingStates = new BoolStack();
	 EncodingInfo m_encodingInfo = new EncodingInfo(null,null, '\u0000');
	 protected BoolStack m_preserves = new BoolStack();
	 protected boolean m_ispreserve = false;
	 protected boolean m_isprevtext = false;
	 private static final char[] s_systemLineSep;
	 static {
		 SecuritySupport ss = SecuritySupport.getInstance();
		 s_systemLineSep = ss.getSystemProperty(""line.separator"").toCharArray();
	 }
	 protected char[] m_lineSep = s_systemLineSep;
	 protected boolean m_lineSepUse = true;
	 protected int m_lineSepLen = m_lineSep.length;
	 protected CharInfo m_charInfo;
	 boolean m_shouldFlush = true;
	 protected boolean m_spaceBeforeClose = false;
	 boolean m_startNewLine;
	 protected boolean m_inDoctype = false;
	 boolean m_isUTF8 = false;
	 protected boolean m_cdataStartCalled = false;
	 private boolean m_expandDTDEntities = true;
	 public ToStream() {
	 }
	 protected void closeCDATA() throws org.xml.sax.SAXException {
		 try {
			 m_writer.write(CDATA_DELIMITER_CLOSE);
			 m_cdataTagOpen = false;
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 public void serialize(Node node) throws IOException {
		 try {
			 TreeWalker walker = new TreeWalker(this);
			 walker.traverse(node);
		 }
		 catch (org.xml.sax.SAXException se) {
			 throw new WrappedRuntimeException(se);
		 }
	 }
	 protected boolean m_escaping = true;
	 protected final void flushWriter() throws org.xml.sax.SAXException {
		 final java.io.Writer writer = m_writer;
		 if (null != writer) {
			 try {
				 if (writer instanceof WriterToUTF8Buffered) {
					 if (m_shouldFlush) ((WriterToUTF8Buffered) writer).flush();
					 else ((WriterToUTF8Buffered) writer).flushBuffer();
				 }
				 if (writer instanceof WriterToASCI) {
					 if (m_shouldFlush) writer.flush();
				 }
				 else {
					 writer.flush();
				 }
			 }
			 catch (IOException ioe) {
				 throw new org.xml.sax.SAXException(ioe);
			 }
		 }
	 }
	 OutputStream m_outputStream;
	 public OutputStream getOutputStream() {
		 return m_outputStream;
	 }
	 public void elementDecl(String name, String model) throws SAXException {
		 if (m_inExternalDTD) return;
		 try {
			 final java.io.Writer writer = m_writer;
			 DTDprolog();
			 writer.write(""<!ELEMENT "");
			 writer.write(name);
			 writer.write(' ');
			 writer.write(model);
			 writer.write('>');
			 writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 public void internalEntityDecl(String name, String value) throws SAXException {
		 if (m_inExternalDTD) return;
		 try {
			 DTDprolog();
			 outputEntityDecl(name, value);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 void outputEntityDecl(String name, String value) throws IOException {
		 final java.io.Writer writer = m_writer;
		 writer.write(""<!ENTITY "");
		 writer.write(name);
		 writer.write("" \"""");
		 writer.write(value);
		 writer.write(""\"">"");
		 writer.write(m_lineSep, 0, m_lineSepLen);
	 }
	 protected final void outputLineSep() throws IOException {
		 m_writer.write(m_lineSep, 0, m_lineSepLen);
	 }
	 void setProp(String name, String val, boolean defaultVal) {
		 if (val != null) {
			 char first = getFirstCharLocName(name);
			 switch (first) {
				 case 'c': if (OutputKeys.CDATA_SECTION_ELEMENTS.equals(name)) {
					 String cdataSectionNames = val;
					 addCdataSectionElements(cdataSectionNames);
				 }
				 break;
				 case 'd': if (OutputKeys.DOCTYPE_SYSTEM.equals(name)) {
					 this.m_doctypeSystem = val;
				 }
				 else if (OutputKeys.DOCTYPE_PUBLIC.equals(name)) {
					 this.m_doctypePublic = val;
					 if (val.startsWith(""- m_spaceBeforeClose = true;
				 }
				 break;
				 case 'e': String newEncoding = val;
				 if (OutputKeys.ENCODING.equals(name)) {
					 String possible_encoding = Encodings.getMimeEncoding(val);
					 if (possible_encoding != null) {
						 super.setProp(""mime-name"", possible_encoding, defaultVal);
					 }
					 final String oldExplicitEncoding = getOutputPropertyNonDefault(OutputKeys.ENCODING);
					 final String oldDefaultEncoding = getOutputPropertyDefault(OutputKeys.ENCODING);
					 if ( (defaultVal && ( oldDefaultEncoding == null || !oldDefaultEncoding.equalsIgnoreCase(newEncoding))) || ( !defaultVal && (oldExplicitEncoding == null || !oldExplicitEncoding.equalsIgnoreCase(newEncoding) ))) {
						 EncodingInfo encodingInfo = Encodings.getEncodingInfo(newEncoding);
						 if (newEncoding != null && encodingInfo.name == null) {
							 final String msg = Utils.messages.createMessage( MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{
							 newEncoding }
							);
							 final String msg2 = ""Warning: encoding \"""" + newEncoding + ""\"" not supported, using "" + Encodings.DEFAULT_MIME_ENCODING;
							 try {
								 final Transformer tran = super.getTransformer();
								 if (tran != null) {
									 final ErrorListener errHandler = tran .getErrorListener();
									 if (null != errHandler && m_sourceLocator != null) {
										 errHandler .warning(new TransformerException( msg, m_sourceLocator));
										 errHandler .warning(new TransformerException( msg2, m_sourceLocator));
									 }
									 else {
										 System.out.println(msg);
										 System.out.println(msg2);
									 }
								 }
								 else {
									 System.out.println(msg);
									 System.out.println(msg2);
								 }
							 }
							 catch (Exception e) {
							 }
							 newEncoding = Encodings.DEFAULT_MIME_ENCODING;
							 val = Encodings.DEFAULT_MIME_ENCODING;
							 encodingInfo = Encodings.getEncodingInfo(newEncoding);
						 }
						 if (defaultVal == false || oldExplicitEncoding == null) {
							 m_encodingInfo = encodingInfo;
							 if (newEncoding != null) m_isUTF8 = newEncoding.equals(Encodings.DEFAULT_MIME_ENCODING);
							 OutputStream os = getOutputStream();
							 if (os != null) {
								 Writer w = getWriter();
								 String oldEncoding = getOutputProperty(OutputKeys.ENCODING);
								 if ((w == null || !m_writer_set_by_user) && !newEncoding.equalsIgnoreCase(oldEncoding)) {
									 super.setProp(name, val, defaultVal);
									 setOutputStreamInternal(os,false);
								 }
							 }
						 }
					 }
				 }
				 break;
				 case 'i': if (OutputPropertiesFactory.S_KEY_INDENT_AMOUNT.equals(name)) {
					 setIndentAmount(Integer.parseInt(val));
				 }
				 else if (OutputKeys.INDENT.equals(name)) {
					 boolean b = ""yes"".equals(val) ? true : false;
					 m_doIndent = b;
				 }
				 break;
				 case 'l': if (OutputPropertiesFactory.S_KEY_LINE_SEPARATOR.equals(name)) {
					 m_lineSep = val.toCharArray();
					 m_lineSepLen = m_lineSep.length;
				 }
				 break;
				 case 'm': if (OutputKeys.MEDIA_TYPE.equals(name)) {
					 m_mediatype = val;
				 }
				 break;
				 case 'o': if (OutputKeys.OMIT_XML_DECLARATION.equals(name)) {
					 boolean b = ""yes"".equals(val) ? true : false;
					 this.m_shouldNotWriteXMLHeader = b;
				 }
				 break;
				 case 's': if (OutputKeys.STANDALONE.equals(name)) {
					 if (defaultVal) {
						 setStandaloneInternal(val);
					 }
					 else {
						 m_standaloneWasSpecified = true;
						 setStandaloneInternal(val);
					 }
				 }
				 break;
				 case 'v': if (OutputKeys.VERSION.equals(name)) {
					 m_version = val;
				 }
				 break;
				 default: break;
			 }
			 super.setProp(name, val, defaultVal);
		 }
	 }
	 public void setOutputFormat(Properties format) {
		 boolean shouldFlush = m_shouldFlush;
		 if (format != null) {
			 Enumeration propNames;
			 propNames = format.propertyNames();
			 while (propNames.hasMoreElements()) {
				 String key = (String) propNames.nextElement();
				 String value = format.getProperty(key);
				 String explicitValue = (String) format.get(key);
				 if (explicitValue == null && value != null) {
					 this.setOutputPropertyDefault(key,value);
				 }
				 if (explicitValue != null) {
					 this.setOutputProperty(key,explicitValue);
				 }
			 }
		 }
		 String entitiesFileName = (String) format.get(OutputPropertiesFactory.S_KEY_ENTITIES);
		 if (null != entitiesFileName) {
			 String method = (String) format.get(OutputKeys.METHOD);
			 m_charInfo = CharInfo.getCharInfo(entitiesFileName, method);
		 }
		 m_shouldFlush = shouldFlush;
	 }
	 public Properties getOutputFormat() {
		 Properties def = new Properties();
		 {
			 Set s = getOutputPropDefaultKeys();
			 Iterator i = s.iterator();
			 while (i.hasNext()) {
				 String key = (String) i.next();
				 String val = getOutputPropertyDefault(key);
				 def.put(key, val);
			 }
		 }
		 Properties props = new Properties(def);
		 {
			 Set s = getOutputPropKeys();
			 Iterator i = s.iterator();
			 while (i.hasNext()) {
				 String key = (String) i.next();
				 String val = getOutputPropertyNonDefault(key);
				 if (val != null) props.put(key, val);
			 }
		 }
		 return props;
	 }
	 public void setWriter(Writer writer) {
		 setWriterInternal(writer, true);
	 }
	 private boolean m_writer_set_by_user;
	 private void setWriterInternal(Writer writer, boolean setByUser) {
		 m_writer_set_by_user = setByUser;
		 m_writer = writer;
		 if (m_tracer != null) {
			 boolean noTracerYet = true;
			 Writer w2 = m_writer;
			 while (w2 instanceof WriterChain) {
				 if (w2 instanceof SerializerTraceWriter) {
					 noTracerYet = false;
					 break;
				 }
				 w2 = ((WriterChain)w2).getWriter();
			 }
			 if (noTracerYet) m_writer = new SerializerTraceWriter(m_writer, m_tracer);
		 }
	 }
	 public boolean setLineSepUse(boolean use_sytem_line_break) {
		 boolean oldValue = m_lineSepUse;
		 m_lineSepUse = use_sytem_line_break;
		 return oldValue;
	 }
	 public void setOutputStream(OutputStream output) {
		 setOutputStreamInternal(output, true);
	 }
	 private void setOutputStreamInternal(OutputStream output, boolean setByUser) {
		 m_outputStream = output;
		 String encoding = getOutputProperty(OutputKeys.ENCODING);
		 if (Encodings.DEFAULT_MIME_ENCODING.equalsIgnoreCase(encoding)) {
			 setWriterInternal(new WriterToUTF8Buffered(output), false);
		 }
		 else if ( ""WINDOWS-1250"".equals(encoding) || ""US-ASCII"".equals(encoding) || ""ASCII"".equals(encoding)) {
			 setWriterInternal(new WriterToASCI(output), false);
		 }
		 else if (encoding != null) {
			 Writer osw = null;
			 try {
				 osw = Encodings.getWriter(output, encoding);
			 }
			 catch (UnsupportedEncodingException uee) {
				 osw = null;
			 }
			 if (osw == null) {
				 System.out.println( ""Warning: encoding \"""" + encoding + ""\"" not supported"" + "", using "" + Encodings.DEFAULT_MIME_ENCODING);
				 encoding = Encodings.DEFAULT_MIME_ENCODING;
				 setEncoding(encoding);
				 try {
					 osw = Encodings.getWriter(output, encoding);
				 }
				 catch (UnsupportedEncodingException e) {
					 e.printStackTrace();
				 }
			 }
			 setWriterInternal(osw,false);
		 }
		 else {
			 Writer osw = new OutputStreamWriter(output);
			 setWriterInternal(osw,false);
		 }
	 }
	 public boolean setEscaping(boolean escape) {
		 final boolean temp = m_escaping;
		 m_escaping = escape;
		 return temp;
	 }
	 protected void indent(int depth) throws IOException {
		 if (m_startNewLine) outputLineSep();
		 if (m_indentAmount > 0) printSpace(depth * m_indentAmount);
	 }
	 protected void indent() throws IOException {
		 indent(m_elemContext.m_currentElemDepth);
	 }
	 private void printSpace(int n) throws IOException {
		 final java.io.Writer writer = m_writer;
		 for (int i = 0;
		 i < n;
		 i++) {
			 writer.write(' ');
		 }
	 }
	 public void attributeDecl( String eName, String aName, String type, String valueDefault, String value) throws SAXException {
		 if (m_inExternalDTD) return;
		 try {
			 final java.io.Writer writer = m_writer;
			 DTDprolog();
			 writer.write(""<!ATTLIST "");
			 writer.write(eName);
			 writer.write(' ');
			 writer.write(aName);
			 writer.write(' ');
			 writer.write(type);
			 if (valueDefault != null) {
				 writer.write(' ');
				 writer.write(valueDefault);
			 }
			 writer.write('>');
			 writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 public Writer getWriter() {
		 return m_writer;
	 }
	 public void externalEntityDecl( String name, String publicId, String systemId) throws SAXException {
		 try {
			 DTDprolog();
			 m_writer.write(""<!ENTITY "");
			 m_writer.write(name);
			 if (publicId != null) {
				 m_writer.write("" PUBLIC \"""");
				 m_writer.write(publicId);
			 }
			 else {
				 m_writer.write("" SYSTEM \"""");
				 m_writer.write(systemId);
			 }
			 m_writer.write(""\"" >"");
			 m_writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 catch (IOException e) {
			 e.printStackTrace();
		 }
	 }
	 protected boolean escapingNotNeeded(char ch) {
		 final boolean ret;
		 if (ch < 127) {
			 if (ch >= CharInfo.S_SPACE || (CharInfo.S_LINEFEED == ch || CharInfo.S_CARRIAGERETURN == ch || CharInfo.S_HORIZONAL_TAB == ch)) ret= true;
			 else ret = false;
		 }
		 else {
			 ret = m_encodingInfo.isInEncoding(ch);
		 }
		 return ret;
	 }
	 protected int writeUTF16Surrogate(char c, char ch[], int i, int end) throws IOException {
		 int codePoint = 0;
		 if (i + 1 >= end) {
			 throw new IOException( Utils.messages.createMessage( MsgKey.ER_INVALID_UTF16_SURROGATE, new Object[] {
			 Integer.toHexString((int) c)}
			));
		 }
		 final char high = c;
		 final char low = ch[i+1];
		 if (!Encodings.isLowUTF16Surrogate(low)) {
			 throw new IOException( Utils.messages.createMessage( MsgKey.ER_INVALID_UTF16_SURROGATE, new Object[] {
			 Integer.toHexString((int) c) + "" "" + Integer.toHexString(low)}
			));
		 }
		 final java.io.Writer writer = m_writer;
		 if (m_encodingInfo.isInEncoding(c,low)) {
			 writer.write(ch,i,2);
		 }
		 else {
			 final String encoding = getEncoding();
			 if (encoding != null) {
				 codePoint = Encodings.toCodePoint(high, low);
				 writer.write('&');
				 writer.write('#');
				 writer.write(Integer.toString(codePoint));
				 writer.write(';
				');
			 }
			 else {
				 writer.write(ch, i, 2);
			 }
		 }
		 return codePoint;
	 }
	 int accumDefaultEntity( java.io.Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException {
		 if (!escLF && CharInfo.S_LINEFEED == ch) {
			 writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 else {
			 if ((fromTextNode && m_charInfo.shouldMapTextChar(ch)) || (!fromTextNode && m_charInfo.shouldMapAttrChar(ch))) {
				 String outputStringForChar = m_charInfo.getOutputStringForChar(ch);
				 if (null != outputStringForChar) {
					 writer.write(outputStringForChar);
				 }
				 else return i;
			 }
			 else return i;
		 }
		 return i + 1;
	 }
	 void writeNormalizedChars( char ch[], int start, int length, boolean isCData, boolean useSystemLineSeparator) throws IOException, org.xml.sax.SAXException {
		 final java.io.Writer writer = m_writer;
		 int end = start + length;
		 for (int i = start;
		 i < end;
		 i++) {
			 char c = ch[i];
			 if (CharInfo.S_LINEFEED == c && useSystemLineSeparator) {
				 writer.write(m_lineSep, 0, m_lineSepLen);
			 }
			 else if (isCData && (!escapingNotNeeded(c))) {
				 if (m_cdataTagOpen) closeCDATA();
				 if (Encodings.isHighUTF16Surrogate(c)) {
					 writeUTF16Surrogate(c, ch, i, end);
					 i++ ;
				 }
				 else {
					 writer.write(""&#"");
					 String intStr = Integer.toString((int) c);
					 writer.write(intStr);
					 writer.write(';
					');
				 }
			 }
			 else if ( isCData && ((i < (end - 2)) && (']' == c) && (']' == ch[i + 1]) && ('>' == ch[i + 2]))) {
				 writer.write(CDATA_CONTINUE);
				 i += 2;
			 }
			 else {
				 if (escapingNotNeeded(c)) {
					 if (isCData && !m_cdataTagOpen) {
						 writer.write(CDATA_DELIMITER_OPEN);
						 m_cdataTagOpen = true;
					 }
					 writer.write(c);
				 }
				 else if (Encodings.isHighUTF16Surrogate(c)) {
					 if (m_cdataTagOpen) closeCDATA();
					 writeUTF16Surrogate(c, ch, i, end);
					 i++;
				 }
				 else {
					 if (m_cdataTagOpen) closeCDATA();
					 writer.write(""&#"");
					 String intStr = Integer.toString((int) c);
					 writer.write(intStr);
					 writer.write(';
					');
				 }
			 }
		 }
	 }
	 public void endNonEscaping() throws org.xml.sax.SAXException {
		 m_disableOutputEscapingStates.pop();
	 }
	 public void startNonEscaping() throws org.xml.sax.SAXException {
		 m_disableOutputEscapingStates.push(true);
	 }
	 protected void cdata(char ch[], int start, final int length) throws org.xml.sax.SAXException {
		 try {
			 final int old_start = start;
			 if (m_elemContext.m_startTagOpen) {
				 closeStartTag();
				 m_elemContext.m_startTagOpen = false;
			 }
			 m_ispreserve = true;
			 if (shouldIndent()) indent();
			 boolean writeCDataBrackets = (((length >= 1) && escapingNotNeeded(ch[start])));
			 if (writeCDataBrackets && !m_cdataTagOpen) {
				 m_writer.write(CDATA_DELIMITER_OPEN);
				 m_cdataTagOpen = true;
			 }
			 if (isEscapingDisabled()) {
				 charactersRaw(ch, start, length);
			 }
			 else writeNormalizedChars(ch, start, length, true, m_lineSepUse);
			 if (writeCDataBrackets) {
				 if (ch[start + length - 1] == ']') closeCDATA();
			 }
			 if (m_tracer != null) super.fireCDATAEvent(ch, old_start, length);
		 }
		 catch (IOException ioe) {
			 throw new org.xml.sax.SAXException( Utils.messages.createMessage( MsgKey.ER_OIERROR, null), ioe);
		 }
	 }
	 private boolean isEscapingDisabled() {
		 return m_disableOutputEscapingStates.peekOrFalse();
	 }
	 protected void charactersRaw(char ch[], int start, int length) throws org.xml.sax.SAXException {
		 if (m_inEntityRef) return;
		 try {
			 if (m_elemContext.m_startTagOpen) {
				 closeStartTag();
				 m_elemContext.m_startTagOpen = false;
			 }
			 m_ispreserve = true;
			 m_writer.write(ch, start, length);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 public void characters(final char chars[], final int start, final int length) throws org.xml.sax.SAXException {
		 if (length == 0 || (m_inEntityRef && !m_expandDTDEntities)) return;
		 m_docIsEmpty = false;
		 if (m_elemContext.m_startTagOpen) {
			 closeStartTag();
			 m_elemContext.m_startTagOpen = false;
		 }
		 else if (m_needToCallStartDocument) {
			 startDocumentInternal();
		 }
		 if (m_cdataStartCalled || m_elemContext.m_isCdataSection) {
			 cdata(chars, start, length);
			 return;
		 }
		 if (m_cdataTagOpen) closeCDATA();
		 if (m_disableOutputEscapingStates.peekOrFalse() || (!m_escaping)) {
			 charactersRaw(chars, start, length);
			 if (m_tracer != null) super.fireCharEvent(chars, start, length);
			 return;
		 }
		 if (m_elemContext.m_startTagOpen) {
			 closeStartTag();
			 m_elemContext.m_startTagOpen = false;
		 }
		 try {
			 int i;
			 int startClean;
			 final int end = start + length;
			 int lastDirtyCharProcessed = start - 1;
			 final Writer writer = m_writer;
			 boolean isAllWhitespace = true;
			 i = start;
			 while (i < end && isAllWhitespace) {
				 char ch1 = chars[i];
				 if (m_charInfo.shouldMapTextChar(ch1)) {
					 writeOutCleanChars(chars, i, lastDirtyCharProcessed);
					 String outputStringForChar = m_charInfo .getOutputStringForChar(ch1);
					 writer.write(outputStringForChar);
					 isAllWhitespace = false;
					 lastDirtyCharProcessed = i;
					 i++;
				 }
				 else {
					 switch (ch1) {
						 case CharInfo.S_SPACE: i++;
						 break;
						 case CharInfo.S_LINEFEED: lastDirtyCharProcessed = processLineFeed(chars, i, lastDirtyCharProcessed, writer);
						 i++;
						 break;
						 case CharInfo.S_CARRIAGERETURN: writeOutCleanChars(chars, i, lastDirtyCharProcessed);
						 writer.write(""&#13;
						"");
						 lastDirtyCharProcessed = i;
						 i++;
						 break;
						 case CharInfo.S_HORIZONAL_TAB: i++;
						 break;
						 default: isAllWhitespace = false;
						 break;
					 }
				 }
			 }
			 if (i < end || !isAllWhitespace) m_ispreserve = true;
			 for (;
			 i < end;
			 i++) {
				 char ch = chars[i];
				 if (m_charInfo.shouldMapTextChar(ch)) {
					 writeOutCleanChars(chars, i, lastDirtyCharProcessed);
					 String outputStringForChar = m_charInfo.getOutputStringForChar(ch);
					 writer.write(outputStringForChar);
					 lastDirtyCharProcessed = i;
				 }
				 else {
					 if (ch <= 0x1F) {
						 switch (ch) {
							 case CharInfo.S_HORIZONAL_TAB: break;
							 case CharInfo.S_LINEFEED: lastDirtyCharProcessed = processLineFeed(chars, i, lastDirtyCharProcessed, writer);
							 break;
							 case CharInfo.S_CARRIAGERETURN: writeOutCleanChars(chars, i, lastDirtyCharProcessed);
							 writer.write(""&#13;
							"");
							 lastDirtyCharProcessed = i;
							 break;
							 default: writeOutCleanChars(chars, i, lastDirtyCharProcessed);
							 writer.write(""&#"");
							 writer.write(Integer.toString(ch));
							 writer.write(';
							');
							 lastDirtyCharProcessed = i;
							 break;
						 }
					 }
					 else if (ch < 0x7F) {
					 }
					 else if (ch <= 0x9F){
						 writeOutCleanChars(chars, i, lastDirtyCharProcessed);
						 writer.write(""&#"");
						 writer.write(Integer.toString(ch));
						 writer.write(';
						');
						 lastDirtyCharProcessed = i;
					 }
					 else if (ch == CharInfo.S_LINE_SEPARATOR) {
						 writeOutCleanChars(chars, i, lastDirtyCharProcessed);
						 writer.write(""&#8232;
						"");
						 lastDirtyCharProcessed = i;
					 }
					 else if (m_encodingInfo.isInEncoding(ch)) {
					 }
					 else {
						 writeOutCleanChars(chars, i, lastDirtyCharProcessed);
						 writer.write(""&#"");
						 writer.write(Integer.toString(ch));
						 writer.write(';
						');
						 lastDirtyCharProcessed = i;
					 }
				 }
			 }
			 startClean = lastDirtyCharProcessed + 1;
			 if (i > startClean) {
				 int lengthClean = i - startClean;
				 m_writer.write(chars, startClean, lengthClean);
			 }
			 m_isprevtext = true;
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
		 if (m_tracer != null) super.fireCharEvent(chars, start, length);
	 }
	private int processLineFeed(final char[] chars, int i, int lastProcessed, final Writer writer) throws IOException {
		if (!m_lineSepUse || (m_lineSepLen ==1 && m_lineSep[0] == CharInfo.S_LINEFEED)){
		}
		else {
			 writeOutCleanChars(chars, i, lastProcessed);
			 writer.write(m_lineSep, 0, m_lineSepLen);
			 lastProcessed = i;
		}
		return lastProcessed;
	}
	 private void writeOutCleanChars(final char[] chars, int i, int lastProcessed) throws IOException {
		 int startClean;
		 startClean = lastProcessed + 1;
		 if (startClean < i) {
			 int lengthClean = i - startClean;
			 m_writer.write(chars, startClean, lengthClean);
		 }
	 }
	 private static boolean isCharacterInC0orC1Range(char ch) {
		 if(ch == 0x09 || ch == 0x0A || ch == 0x0D) return false;
		 else return (ch >= 0x7F && ch <= 0x9F)|| (ch >= 0x01 && ch <= 0x1F);
	 }
	 private static boolean isNELorLSEPCharacter(char ch) {
		 return (ch == 0x85 || ch == 0x2028);
	 }
	 private int processDirty( char[] chars, int end, int i, char ch, int lastDirty, boolean fromTextNode) throws IOException {
		 int startClean = lastDirty + 1;
		 if (i > startClean) {
			 int lengthClean = i - startClean;
			 m_writer.write(chars, startClean, lengthClean);
		 }
		 if (CharInfo.S_LINEFEED == ch && fromTextNode) {
			 m_writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 else {
			 startClean = accumDefaultEscape( m_writer, (char)ch, i, chars, end, fromTextNode, false);
			 i = startClean - 1;
		 }
		 return i;
	 }
	 public void characters(String s) throws org.xml.sax.SAXException {
		 if (m_inEntityRef && !m_expandDTDEntities) return;
		 final int length = s.length();
		 if (length > m_charsBuff.length) {
			 m_charsBuff = new char[length * 2 + 1];
		 }
		 s.getChars(0, length, m_charsBuff, 0);
		 characters(m_charsBuff, 0, length);
	 }
	 private int accumDefaultEscape( Writer writer, char ch, int i, char[] chars, int len, boolean fromTextNode, boolean escLF) throws IOException {
		 int pos = accumDefaultEntity(writer, ch, i, chars, len, fromTextNode, escLF);
		 if (i == pos) {
			 if (Encodings.isHighUTF16Surrogate(ch)) {
				 char next;
				 int codePoint = 0;
				 if (i + 1 >= len) {
					 throw new IOException( Utils.messages.createMessage( MsgKey.ER_INVALID_UTF16_SURROGATE, new Object[] {
					 Integer.toHexString(ch)}
					));
				 }
				 else {
					 next = chars[++i];
					 if (!(Encodings.isLowUTF16Surrogate(next))) throw new IOException( Utils.messages.createMessage( MsgKey .ER_INVALID_UTF16_SURROGATE, new Object[] {
					 Integer.toHexString(ch) + "" "" + Integer.toHexString(next)}
					));
					 codePoint = Encodings.toCodePoint(ch,next);
				 }
				 writer.write(""&#"");
				 writer.write(Integer.toString(codePoint));
				 writer.write(';
				');
				 pos += 2;
			 }
			 else {
				 if (isCharacterInC0orC1Range(ch) || isNELorLSEPCharacter(ch)) {
					 writer.write(""&#"");
					 writer.write(Integer.toString(ch));
					 writer.write(';
					');
				 }
				 else if ((!escapingNotNeeded(ch) || ( (fromTextNode && m_charInfo.shouldMapTextChar(ch)) || (!fromTextNode && m_charInfo.shouldMapAttrChar(ch)))) && m_elemContext.m_currentElemDepth > 0) {
					 writer.write(""&#"");
					 writer.write(Integer.toString(ch));
					 writer.write(';
					');
				 }
				 else {
					 writer.write(ch);
				 }
				 pos++;
			 }
		 }
		 return pos;
	 }
	 public void startElement( String namespaceURI, String localName, String name, Attributes atts) throws org.xml.sax.SAXException {
		 if (m_inEntityRef) return;
		 if (m_needToCallStartDocument) {
			 startDocumentInternal();
			 m_needToCallStartDocument = false;
			 m_docIsEmpty = false;
		 }
		 else if (m_cdataTagOpen) closeCDATA();
		 try {
			 if (m_needToOutputDocTypeDecl) {
				 if(null != getDoctypeSystem()) {
					 outputDocTypeDecl(name, true);
				 }
				 m_needToOutputDocTypeDecl = false;
			 }
			 if (m_elemContext.m_startTagOpen) {
				 closeStartTag();
				 m_elemContext.m_startTagOpen = false;
			 }
			 if (namespaceURI != null) ensurePrefixIsDeclared(namespaceURI, name);
			 m_ispreserve = false;
			 if (shouldIndent() && m_startNewLine) {
				 indent();
			 }
			 m_startNewLine = true;
			 final java.io.Writer writer = m_writer;
			 writer.write('<');
			 writer.write(name);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
		 if (atts != null) addAttributes(atts);
		 m_elemContext = m_elemContext.push(namespaceURI,localName,name);
		 m_isprevtext = false;
		 if (m_tracer != null) firePseudoAttributes();
	 }
	 public void startElement( String elementNamespaceURI, String elementLocalName, String elementName) throws SAXException {
		 startElement(elementNamespaceURI, elementLocalName, elementName, null);
	 }
	 public void startElement(String elementName) throws SAXException {
		 startElement(null, null, elementName, null);
	 }
	 void outputDocTypeDecl(String name, boolean closeDecl) throws SAXException {
		 if (m_cdataTagOpen) closeCDATA();
		 try {
			 final java.io.Writer writer = m_writer;
			 writer.write(""<!DOCTYPE "");
			 writer.write(name);
			 String doctypePublic = getDoctypePublic();
			 if (null != doctypePublic) {
				 writer.write("" PUBLIC \"""");
				 writer.write(doctypePublic);
				 writer.write('\""');
			 }
			 String doctypeSystem = getDoctypeSystem();
			 if (null != doctypeSystem) {
				 if (null == doctypePublic) writer.write("" SYSTEM \"""");
				 else writer.write("" \"""");
				 writer.write(doctypeSystem);
				 if (closeDecl) {
					 writer.write(""\"">"");
					 writer.write(m_lineSep, 0, m_lineSepLen);
					 closeDecl = false;
				 }
				 else writer.write('\""');
			 }
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 public void processAttributes(java.io.Writer writer, int nAttrs) throws IOException, SAXException {
		 String encoding = getEncoding();
		 for (int i = 0;
		 i < nAttrs;
		 i++) {
			 final String name = m_attributes.getQName(i);
			 final String value = m_attributes.getValue(i);
			 writer.write(' ');
			 writer.write(name);
			 writer.write(""=\"""");
			 writeAttrString(writer, value, encoding);
			 writer.write('\""');
		 }
	 }
	 public void writeAttrString( Writer writer, String string, String encoding) throws IOException {
		 final int len = string.length();
		 if (len > m_attrBuff.length) {
			 m_attrBuff = new char[len*2 + 1];
		 }
		 string.getChars(0,len, m_attrBuff, 0);
		 final char[] stringChars = m_attrBuff;
		 for (int i = 0;
		 i < len;
		 i++) {
			 char ch = stringChars[i];
			 if (m_charInfo.shouldMapAttrChar(ch)) {
				 accumDefaultEscape(writer, ch, i, stringChars, len, false, true);
			 }
			 else {
				 if (0x0 <= ch && ch <= 0x1F) {
					 switch (ch) {
						 case CharInfo.S_HORIZONAL_TAB: writer.write(""&#9;
						"");
						 break;
						 case CharInfo.S_LINEFEED: writer.write(""&#10;
						"");
						 break;
						 case CharInfo.S_CARRIAGERETURN: writer.write(""&#13;
						"");
						 break;
						 default: writer.write(""&#"");
						 writer.write(Integer.toString(ch));
						 writer.write(';
						');
						 break;
					 }
				 }
				 else if (ch < 0x7F) {
					 writer.write(ch);
				 }
				 else if (ch <= 0x9F){
					 writer.write(""&#"");
					 writer.write(Integer.toString(ch));
					 writer.write(';
					');
				 }
				 else if (ch == CharInfo.S_LINE_SEPARATOR) {
					 writer.write(""&#8232;
					"");
				 }
				 else if (m_encodingInfo.isInEncoding(ch)) {
					 writer.write(ch);
				 }
				 else {
					 writer.write(""&#"");
					 writer.write(Integer.toString(ch));
					 writer.write(';
					');
				 }
			 }
		 }
	 }
	 public void endElement(String namespaceURI, String localName, String name) throws org.xml.sax.SAXException {
		 if (m_inEntityRef) return;
		 m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth, null);
		 try {
			 final java.io.Writer writer = m_writer;
			 if (m_elemContext.m_startTagOpen) {
				 if (m_tracer != null) super.fireStartElem(m_elemContext.m_elementName);
				 int nAttrs = m_attributes.getLength();
				 if (nAttrs > 0) {
					 processAttributes(m_writer, nAttrs);
					 m_attributes.clear();
				 }
				 if (m_spaceBeforeClose) writer.write("" />"");
				 else writer.write(""/>"");
			 }
			 else {
				 if (m_cdataTagOpen) closeCDATA();
				 if (shouldIndent()) indent(m_elemContext.m_currentElemDepth - 1);
				 writer.write('<');
				 writer.write('/');
				 writer.write(name);
				 writer.write('>');
			 }
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
		 if (!m_elemContext.m_startTagOpen && m_doIndent) {
			 m_ispreserve = m_preserves.isEmpty() ? false : m_preserves.pop();
		 }
		 m_isprevtext = false;
		 if (m_tracer != null) super.fireEndElem(name);
		 m_elemContext = m_elemContext.m_prev;
	 }
	 public void endElement(String name) throws org.xml.sax.SAXException {
		 endElement(null, null, name);
	 }
	 public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException {
		 startPrefixMapping(prefix, uri, true);
	 }
	 public boolean startPrefixMapping( String prefix, String uri, boolean shouldFlush) throws org.xml.sax.SAXException {
		 boolean pushed;
		 int pushDepth;
		 if (shouldFlush) {
			 flushPending();
			 pushDepth = m_elemContext.m_currentElemDepth + 1;
		 }
		 else {
			 pushDepth = m_elemContext.m_currentElemDepth;
		 }
		 pushed = m_prefixMap.pushNamespace(prefix, uri, pushDepth);
		 if (pushed) {
			 String name;
			 if (EMPTYSTRING.equals(prefix)) {
				 name = ""xmlns"";
				 addAttributeAlways(XMLNS_URI, name, name, ""CDATA"", uri, false);
			 }
			 else {
				 if (!EMPTYSTRING.equals(uri)) {
					 name = ""xmlns:"" + prefix;
					 addAttributeAlways(XMLNS_URI, prefix, name, ""CDATA"", uri, false);
				 }
			 }
		 }
		 return pushed;
	 }
	 public void comment(char ch[], int start, int length) throws org.xml.sax.SAXException {
		 int start_old = start;
		 if (m_inEntityRef) return;
		 if (m_elemContext.m_startTagOpen) {
			 closeStartTag();
			 m_elemContext.m_startTagOpen = false;
		 }
		 else if (m_needToCallStartDocument) {
			 startDocumentInternal();
			 m_needToCallStartDocument = false;
		 }
		 try {
			 final int limit = start + length;
			 boolean wasDash = false;
			 if (m_cdataTagOpen) closeCDATA();
			 if (shouldIndent()) indent();
			 final java.io.Writer writer = m_writer;
			 writer.write(COMMENT_BEGIN);
			 for (int i = start;
			 i < limit;
			 i++) {
				 if (wasDash && ch[i] == '-') {
					 writer.write(ch, start, i - start);
					 writer.write("" -"");
					 start = i + 1;
				 }
				 wasDash = (ch[i] == '-');
			 }
			 if (length > 0) {
				 final int remainingChars = (limit - start);
				 if (remainingChars > 0) writer.write(ch, start, remainingChars);
				 if (ch[limit - 1] == '-') writer.write(' ');
			 }
			 writer.write(COMMENT_END);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
		 m_startNewLine = true;
		 if (m_tracer != null) super.fireCommentEvent(ch, start_old,length);
	 }
	 public void endCDATA() throws org.xml.sax.SAXException {
		 if (m_cdataTagOpen) closeCDATA();
		 m_cdataStartCalled = false;
	 }
	 public void endDTD() throws org.xml.sax.SAXException {
		 try {
			 if (m_needToOutputDocTypeDecl) {
				 outputDocTypeDecl(m_elemContext.m_elementName, false);
				 m_needToOutputDocTypeDecl = false;
			 }
			 final java.io.Writer writer = m_writer;
			 if (!m_inDoctype) writer.write(""]>"");
			 else {
				 writer.write('>');
			 }
			 writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 catch (IOException e) {
			 throw new SAXException(e);
		 }
	 }
	 public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException {
	 }
	 public void ignorableWhitespace(char ch[], int start, int length) throws org.xml.sax.SAXException {
		 if (0 == length) return;
		 characters(ch, start, length);
	 }
	 public void skippedEntity(String name) throws org.xml.sax.SAXException {
	 }
	 public void startCDATA() throws org.xml.sax.SAXException {
		 m_cdataStartCalled = true;
	 }
	 public void startEntity(String name) throws org.xml.sax.SAXException {
		 if (name.equals(""[dtd]"")) m_inExternalDTD = true;
		 if (!m_expandDTDEntities && !m_inExternalDTD) {
			 startNonEscaping();
			 characters(""&"" + name + ';
			');
			 endNonEscaping();
		 }
		 m_inEntityRef = true;
	 }
	 protected void closeStartTag() throws SAXException {
		 if (m_elemContext.m_startTagOpen) {
			 try {
				 if (m_tracer != null) super.fireStartElem(m_elemContext.m_elementName);
				 int nAttrs = m_attributes.getLength();
				 if (nAttrs > 0) {
					 processAttributes(m_writer, nAttrs);
					 m_attributes.clear();
				 }
				 m_writer.write('>');
			 }
			 catch (IOException e) {
				 throw new SAXException(e);
			 }
			 if (m_CdataElems != null) m_elemContext.m_isCdataSection = isCdataSection();
			 if (m_doIndent) {
				 m_isprevtext = false;
				 m_preserves.push(m_ispreserve);
			 }
		 }
	 }
	 public void startDTD(String name, String publicId, String systemId) throws org.xml.sax.SAXException {
		 setDoctypeSystem(systemId);
		 setDoctypePublic(publicId);
		 m_elemContext.m_elementName = name;
		 m_inDoctype = true;
	 }
	 public int getIndentAmount() {
		 return m_indentAmount;
	 }
	 public void setIndentAmount(int m_indentAmount) {
		 this.m_indentAmount = m_indentAmount;
	 }
	 protected boolean shouldIndent() {
		 return m_doIndent && (!m_ispreserve && !m_isprevtext) && m_elemContext.m_currentElemDepth > 0;
	 }
	 private void setCdataSectionElements(String key, Properties props) {
		 String s = props.getProperty(key);
		 if (null != s) {
			 Vector v = new Vector();
			 int l = s.length();
			 boolean inCurly = false;
			 StringBuffer buf = new StringBuffer();
			 for (int i = 0;
			 i < l;
			 i++) {
				 char c = s.charAt(i);
				 if (Character.isWhitespace(c)) {
					 if (!inCurly) {
						 if (buf.length() > 0) {
							 addCdataSectionElement(buf.toString(), v);
							 buf.setLength(0);
						 }
						 continue;
					 }
				 }
				 else if ('{
					' == c) inCurly = true;
				 else if ('}
				' == c) inCurly = false;
				 buf.append(c);
			 }
			 if (buf.length() > 0) {
				 addCdataSectionElement(buf.toString(), v);
				 buf.setLength(0);
			 }
			 setCdataSectionElements(v);
		 }
	 }
	 private void addCdataSectionElement(String URI_and_localName, Vector v) {
		 StringTokenizer tokenizer = new StringTokenizer(URI_and_localName, ""{
		}
		"", false);
		 String s1 = tokenizer.nextToken();
		 String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;
		 if (null == s2) {
			 v.addElement(null);
			 v.addElement(s1);
		 }
		 else {
			 v.addElement(s1);
			 v.addElement(s2);
		 }
	 }
	 public void setCdataSectionElements(Vector URI_and_localNames) {
		 if (URI_and_localNames != null) {
			 final int len = URI_and_localNames.size() - 1;
			 if (len > 0) {
				 final StringBuffer sb = new StringBuffer();
				 for (int i = 0;
				 i < len;
				 i += 2) {
					 if (i != 0) sb.append(' ');
					 final String uri = (String) URI_and_localNames.elementAt(i);
					 final String localName = (String) URI_and_localNames.elementAt(i + 1);
					 if (uri != null) {
						 sb.append('{
							');
							 sb.append(uri);
						 sb.append('}
						');
					 }
					 sb.append(localName);
				 }
				 m_StringOfCDATASections = sb.toString();
			 }
		 }
		 initCdataElems(m_StringOfCDATASections);
	 }
	 protected String ensureAttributesNamespaceIsDeclared( String ns, String localName, String rawName) throws org.xml.sax.SAXException {
		 if (ns != null && ns.length() > 0) {
			 int index = 0;
			 String prefixFromRawName = (index = rawName.indexOf("":"")) < 0 ? """" : rawName.substring(0, index);
			 if (index > 0) {
				 String uri = m_prefixMap.lookupNamespace(prefixFromRawName);
				 if (uri != null && uri.equals(ns)) {
					 return null;
				 }
				 else {
					 this.startPrefixMapping(prefixFromRawName, ns, false);
					 this.addAttribute( ""http: prefixFromRawName, ""xmlns:"" + prefixFromRawName, ""CDATA"", ns, false);
					 return prefixFromRawName;
				 }
			 }
			 else {
				 String prefix = m_prefixMap.lookupPrefix(ns);
				 if (prefix == null) {
					 prefix = m_prefixMap.generateNextPrefix();
					 this.startPrefixMapping(prefix, ns, false);
					 this.addAttribute( ""http: prefix, ""xmlns:"" + prefix, ""CDATA"", ns, false);
				 }
				 return prefix;
			 }
		 }
		 return null;
	 }
	 void ensurePrefixIsDeclared(String ns, String rawName) throws org.xml.sax.SAXException {
		 if (ns != null && ns.length() > 0) {
			 int index;
			 final boolean no_prefix = ((index = rawName.indexOf("":"")) < 0);
			 String prefix = (no_prefix) ? """" : rawName.substring(0, index);
			 if (null != prefix) {
				 String foundURI = m_prefixMap.lookupNamespace(prefix);
				 if ((null == foundURI) || !foundURI.equals(ns)) {
					 this.startPrefixMapping(prefix, ns);
					 this.addAttributeAlways( ""http: no_prefix ? ""xmlns"" : prefix, no_prefix ? ""xmlns"" : (""xmlns:""+ prefix), ""CDATA"", ns, false);
				 }
			 }
		 }
	 }
	 public void flushPending() throws SAXException {
		 if (m_needToCallStartDocument) {
			 startDocumentInternal();
			 m_needToCallStartDocument = false;
		 }
		 if (m_elemContext.m_startTagOpen) {
			 closeStartTag();
			 m_elemContext.m_startTagOpen = false;
		 }
		 if (m_cdataTagOpen) {
			 closeCDATA();
			 m_cdataTagOpen = false;
		 }
		 if (m_writer != null) {
			 try {
				 m_writer.flush();
			 }
			 catch(IOException e) {
			 }
		 }
	 }
	 public void setContentHandler(ContentHandler ch) {
	 }
	 public boolean addAttributeAlways( String uri, String localName, String rawName, String type, String value, boolean xslAttribute) {
		 boolean was_added;
		 int index;
		 if (uri == null || localName == null || uri.length() == 0) index = m_attributes.getIndex(rawName);
		 else {
			 index = m_attributes.getIndex(uri, localName);
		 }
		 if (index >= 0) {
			 String old_value = null;
			 if (m_tracer != null) {
				 old_value = m_attributes.getValue(index);
				 if (value.equals(old_value)) old_value = null;
			 }
			 m_attributes.setValue(index, value);
			 was_added = false;
			 if (old_value != null) firePseudoAttributes();
		 }
		 else {
			 if (xslAttribute) {
				 final int colonIndex = rawName.indexOf(':');
				 if (colonIndex > 0) {
					 String prefix = rawName.substring(0,colonIndex);
					 NamespaceMappings.MappingRecord existing_mapping = m_prefixMap.getMappingFromPrefix(prefix);
					 if (existing_mapping != null && existing_mapping.m_declarationDepth == m_elemContext.m_currentElemDepth && !existing_mapping.m_uri.equals(uri)) {
						 prefix = m_prefixMap.lookupPrefix(uri);
						 if (prefix == null) {
							 prefix = m_prefixMap.generateNextPrefix();
						 }
						 rawName = prefix + ':' + localName;
					 }
				 }
				 try {
					 String prefixUsed = ensureAttributesNamespaceIsDeclared( uri, localName, rawName);
				 }
				 catch (SAXException e) {
					 e.printStackTrace();
				 }
			 }
			 m_attributes.addAttribute(uri, localName, rawName, type, value);
			 was_added = true;
			 if (m_tracer != null) firePseudoAttributes();
		 }
		 return was_added;
	 }
	 protected void firePseudoAttributes() {
		 if (m_tracer != null) {
			 try {
				 m_writer.flush();
				 StringBuffer sb = new StringBuffer();
				 int nAttrs = m_attributes.getLength();
				 if (nAttrs > 0) {
					 java.io.Writer writer = new ToStream.WritertoStringBuffer(sb);
					 processAttributes(writer, nAttrs);
				 }
				 sb.append('>');
				 char ch[] = sb.toString().toCharArray();
				 m_tracer.fireGenerateEvent( SerializerTrace.EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS, ch, 0, ch.length);
			 }
			 catch (IOException ioe) {
			 }
			 catch (SAXException se) {
			 }
		 }
	 }
	 private class WritertoStringBuffer extends java.io.Writer {
		 final private StringBuffer m_stringbuf;
		 WritertoStringBuffer(StringBuffer sb) {
			 m_stringbuf = sb;
		 }
		 public void write(char[] arg0, int arg1, int arg2) throws IOException {
			 m_stringbuf.append(arg0, arg1, arg2);
		 }
		 public void flush() throws IOException {
		 }
		 public void close() throws IOException {
		 }
		 public void write(int i) {
			 m_stringbuf.append((char) i);
		 }
		 public void write(String s) {
			 m_stringbuf.append(s);
		 }
	 }
	 public void setTransformer(Transformer transformer) {
		 super.setTransformer(transformer);
		 if (m_tracer != null && !(m_writer instanceof SerializerTraceWriter) ) setWriterInternal(new SerializerTraceWriter(m_writer, m_tracer), false);
	 }
	 public boolean reset() {
		 boolean wasReset = false;
		 if (super.reset()) {
			 resetToStream();
			 wasReset = true;
		 }
		 return wasReset;
	 }
	 private void resetToStream() {
		 this.m_cdataStartCalled = false;
		 this.m_disableOutputEscapingStates.clear();
		 this.m_escaping = true;
		 this.m_expandDTDEntities = true;
		 this.m_inDoctype = false;
		 this.m_ispreserve = false;
		 this.m_isprevtext = false;
		 this.m_isUTF8 = false;
		 this.m_lineSep = s_systemLineSep;
		 this.m_lineSepLen = s_systemLineSep.length;
		 this.m_lineSepUse = true;
		 this.m_preserves.clear();
		 this.m_shouldFlush = true;
		 this.m_spaceBeforeClose = false;
		 this.m_startNewLine = false;
		 this.m_writer_set_by_user = false;
	 }
	 public void setEncoding(String encoding) {
		 setOutputProperty(OutputKeys.ENCODING,encoding);
	 }
	 static final class BoolStack {
		 private boolean m_values[];
		 private int m_allocatedSize;
		 private int m_index;
		 public BoolStack() {
			 this(32);
		 }
		 public BoolStack(int size) {
			 m_allocatedSize = size;
			 m_values = new boolean[size];
			 m_index = -1;
		 }
		 public final int size() {
			 return m_index + 1;
		 }
		 public final void clear() {
			 m_index = -1;
		 }
		 public final boolean push(boolean val) {
			 if (m_index == m_allocatedSize - 1) grow();
			 return (m_values[++m_index] = val);
		 }
		 public final boolean pop() {
			 return m_values[m_index--];
		 }
		 public final boolean popAndTop() {
			 m_index--;
			 return (m_index >= 0) ? m_values[m_index] : false;
		 }
		 public final void setTop(boolean b) {
			 m_values[m_index] = b;
		 }
		 public final boolean peek() {
			 return m_values[m_index];
		 }
		 public final boolean peekOrFalse() {
			 return (m_index > -1) ? m_values[m_index] : false;
		 }
		 public final boolean peekOrTrue() {
			 return (m_index > -1) ? m_values[m_index] : true;
		 }
		 public boolean isEmpty() {
			 return (m_index == -1);
		 }
		 private void grow() {
			 m_allocatedSize *= 2;
			 boolean newVector[] = new boolean[m_allocatedSize];
			 System.arraycopy(m_values, 0, newVector, 0, m_index + 1);
			 m_values = newVector;
		 }
	 }
	 public void notationDecl(String name, String pubID, String sysID) throws SAXException {
		 try {
			 DTDprolog();
			 m_writer.write(""<!NOTATION "");
			 m_writer.write(name);
			 if (pubID != null) {
				 m_writer.write("" PUBLIC \"""");
				 m_writer.write(pubID);
			 }
			 else {
				 m_writer.write("" SYSTEM \"""");
				 m_writer.write(sysID);
			 }
			 m_writer.write(""\"" >"");
			 m_writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 catch (IOException e) {
			 e.printStackTrace();
		 }
	 }
	 public void unparsedEntityDecl(String name, String pubID, String sysID, String notationName) throws SAXException {
		 try {
			 DTDprolog();
			 m_writer.write(""<!ENTITY "");
			 m_writer.write(name);
			 if (pubID != null) {
				 m_writer.write("" PUBLIC \"""");
				 m_writer.write(pubID);
			 }
			 else {
				 m_writer.write("" SYSTEM \"""");
				 m_writer.write(sysID);
			 }
			 m_writer.write(""\"" NDATA "");
			 m_writer.write(notationName);
			 m_writer.write("" >"");
			 m_writer.write(m_lineSep, 0, m_lineSepLen);
		 }
		 catch (IOException e) {
			 e.printStackTrace();
		 }
	 }
	 private void DTDprolog() throws SAXException, IOException {
		 final java.io.Writer writer = m_writer;
		 if (m_needToOutputDocTypeDecl) {
			 outputDocTypeDecl(m_elemContext.m_elementName, false);
			 m_needToOutputDocTypeDecl = false;
		 }
		 if (m_inDoctype) {
			 writer.write("" ["");
			 writer.write(m_lineSep, 0, m_lineSepLen);
			 m_inDoctype = false;
		 }
	 }
	 public void setDTDEntityExpansion(boolean expand) {
		 m_expandDTDEntities = expand;
	 }
	 public void setNewLine (char[] eolChars) {
		 m_lineSep = eolChars;
		 m_lineSepLen = eolChars.length;
	 }
	 public void addCdataSectionElements(String URI_and_localNames) {
		 if (URI_and_localNames != null) initCdataElems(URI_and_localNames);
		 if (m_StringOfCDATASections == null) m_StringOfCDATASections = URI_and_localNames;
		 else m_StringOfCDATASections += ("" "" + URI_and_localNames);
	 }
}",1,0,0,0
"public class JdkDelegatingLogListener extends AbstractFlashingObject implements LogListener {
	 public static final String DO_NOT_LOG = ""#DO_NOT_LOG"";
	 private final static Logger LOGGER = HandlerUtils.getLogger(JdkDelegatingLogListener.class);
	 private volatile LogReaderService logReaderService;
	 public static String cleanThrowable(final Throwable throwable) {
		 final StringBuilder result = new StringBuilder();
		 result.append(LINE_SEPARATOR);
		 result.append(throwable.toString().replace(DO_NOT_LOG, """"));
		 result.append(LINE_SEPARATOR);
		 for (final StackTraceElement ste : throwable.getStackTrace()) {
			 result.append(ste);
			 result.append(LINE_SEPARATOR);
		 }
		 return result.toString();
	 }
	 protected void activate(final ComponentContext context) {
		 logReaderService.addLogListener(this);
		 final Enumeration<LogEntry> latestLogs = logReaderService.getLog();
		 if (latestLogs.hasMoreElements()) {
			 logNow(latestLogs.nextElement(), false);
		 }
	 }
	 private String buildMessage(final LogEntry entry) {
		 final StringBuilder sb = new StringBuilder();
		 sb.append(""["").append(entry.getBundle()).append(""] "").append(entry.getMessage());
		 return sb.toString();
	 }
	 private boolean containsDoNotLogTag(final Throwable throwable) {
		 if (throwable == null) {
			 return false;
		 }
		 if (throwable.getMessage().contains(DO_NOT_LOG)) {
			 return true;
		 }
		 final StringWriter sw = new StringWriter();
		 throwable.printStackTrace(new PrintWriter(sw));
		 return sw.toString().contains(DO_NOT_LOG);
	 }
	 protected void deactivate(final ComponentContext context) {
		 logReaderService.removeLogListener(this);
	 }
	 public void logged(final LogEntry entry) {
		 if (containsDoNotLogTag(entry.getException())) {
			 if (isDevelopmentMode()) {
				 logNow(entry, true);
			 }
		 }
		 else {
			 logNow(entry, false);
		 }
	 }
	 private void logNow(final LogEntry entry, final boolean removeDoNotLogTag) {
		 final int osgiLevel = entry.getLevel();
		 Level jdkLevel = Level.FINEST;
		 if (osgiLevel == LogService.LOG_DEBUG) {
			 jdkLevel = Level.FINE;
		 }
		 else if (osgiLevel == LogService.LOG_INFO) {
			 jdkLevel = Level.INFO;
		 }
		 else if (osgiLevel == LogService.LOG_WARNING) {
			 jdkLevel = Level.WARNING;
		 }
		 else if (osgiLevel == LogService.LOG_ERROR) {
			 jdkLevel = Level.SEVERE;
		 }
		 if (jdkLevel.intValue() <= Level.INFO.intValue()) {
			 if (isDevelopmentMode()) {
				 flash(jdkLevel, buildMessage(entry), MY_SLOT);
				 flash(jdkLevel, """", MY_SLOT);
			 }
		 }
		 else {
			 if (removeDoNotLogTag) {
				 LOGGER.log(jdkLevel, buildMessage(entry) + cleanThrowable(entry.getException()));
			 }
			 else {
				 LOGGER.log(jdkLevel, buildMessage(entry), entry.getException());
			 }
		 }
	 }
}",1,0,0,0
"public class DistributedFileSystem extends FileSystem {
	 private Path workingDir = new Path(""/user"", System.getProperty(""user.name""));
	 private String name;
	 private FileSystem localFs;
	 DFSClient dfs;
	 public DistributedFileSystem(InetSocketAddress namenode, Configuration conf) throws IOException {
		 super(conf);
		 this.dfs = new DFSClient(namenode, conf);
		 this.name = namenode.getHostName() + "":"" + namenode.getPort();
		 this.localFs = getNamed(""local"", conf);
	 }
	 public String getName() {
		 return name;
	 }
	 public Path getWorkingDirectory() {
		 return workingDir;
	 }
	 public long getDefaultBlockSize() {
		 return dfs.getDefaultBlockSize();
	 }
	 public long getBlockSize(Path f) throws IOException {
		 return dfs.getBlockSize(makeAbsolute(f));
	 }
	 public short getDefaultReplication() {
		 return dfs.getDefaultReplication();
	 }
	 private Path makeAbsolute(Path f) {
		 if (f.isAbsolute()) {
			 return f;
		 }
		 else {
			 return new Path(workingDir, f);
		 }
	 }
	 public void setWorkingDirectory(Path dir) {
		 workingDir = makeAbsolute(dir);
	 }
	 private UTF8 getPath(Path file) {
		 return new UTF8(makeAbsolute(file).toString());
	 }
	 public String[][] getFileCacheHints(Path f, long start, long len) throws IOException {
		 return dfs.getHints(getPath(f), start, len);
	 }
	 public FSInputStream openRaw(Path f) throws IOException {
		 return dfs.open(getPath(f));
	 }
	 public FSOutputStream createRaw(Path f, boolean overwrite, short replication, long blockSize) throws IOException {
		 return dfs.create(getPath(f), overwrite, replication, blockSize);
	 }
	 public FSOutputStream createRaw(Path f, boolean overwrite, short replication, long blockSize, Progressable progress) throws IOException {
		 return dfs.create(getPath(f), overwrite, replication, blockSize, progress);
	 }
	 public boolean setReplicationRaw( Path src, short replication ) throws IOException {
		 return dfs.setReplication(getPath(src), replication);
	 }
	 public boolean renameRaw(Path src, Path dst) throws IOException {
		 return dfs.rename(getPath(src), getPath(dst));
	 }
	 public boolean deleteRaw(Path f) throws IOException {
		 return dfs.delete(getPath(f));
	 }
	 public boolean exists(Path f) throws IOException {
		 return dfs.exists(getPath(f));
	 }
	 public boolean isDirectory(Path f) throws IOException {
		 if (f instanceof DfsPath) {
			 return ((DfsPath)f).isDirectory();
		 }
		 return dfs.isDirectory(getPath(f));
	 }
	 public long getLength(Path f) throws IOException {
		 if (f instanceof DfsPath) {
			 return ((DfsPath)f).length();
		 }
		 DFSFileInfo info[] = dfs.listPaths(getPath(f));
		 return (info == null) ? 0 : info[0].getLen();
	 }
	 public short getReplication(Path f) throws IOException {
		 if (f instanceof DfsPath) {
			 return ((DfsPath)f).getReplication();
		 }
		 DFSFileInfo info[] = dfs.listPaths(getPath(f));
		 return info[0].getReplication();
	 }
	 public Path[] listPathsRaw(Path f) throws IOException {
		 DFSFileInfo info[] = dfs.listPaths(getPath(f));
		 if (info == null) {
			 return new Path[0];
		 }
		 else {
			 Path results[] = new DfsPath[info.length];
			 for (int i = 0;
			 i < info.length;
			 i++) {
				 results[i] = new DfsPath(info[i]);
			 }
			 return results;
		 }
	 }
	 public boolean mkdirs(Path f) throws IOException {
		 return dfs.mkdirs(getPath(f));
	 }
	 public void lock(Path f, boolean shared) throws IOException {
		 dfs.lock(getPath(f), ! shared);
	 }
	 public void release(Path f) throws IOException {
		 dfs.release(getPath(f));
	 }
	 public void moveFromLocalFile(Path src, Path dst) throws IOException {
		 FileUtil.copy(localFs, src, this, dst, true, getConf());
	 }
	 public void copyFromLocalFile(Path src, Path dst) throws IOException {
		 FileUtil.copy(localFs, src, this, dst, false, getConf());
	 }
	 public void copyToLocalFile(Path src, Path dst) throws IOException {
		 FileUtil.copy(this, src, localFs, dst, false, getConf());
	 }
	 public Path startLocalOutput(Path fsOutputFile, Path tmpLocalFile) throws IOException {
		 return tmpLocalFile;
	 }
	 public void completeLocalOutput(Path fsOutputFile, Path tmpLocalFile) throws IOException {
		 moveFromLocalFile(tmpLocalFile, fsOutputFile);
	 }
	 public void close() throws IOException {
		 super.close();
		 dfs.close();
	 }
	 public String toString() {
		 return ""DFS["" + dfs + ""]"";
	 }
	 DFSClient getClient() {
		 return dfs;
	 }
	 public void reportChecksumFailure(Path f, FSInputStream in, long start, long length, int crc) {
	 }
	 public long getRawCapacity() throws IOException{
		 return dfs.totalRawCapacity();
	 }
	 public long getRawUsed() throws IOException{
		 return dfs.totalRawUsed();
	 }
	 public long getUsed()throws IOException{
		 long used = 0;
		 DFSFileInfo dfsFiles[] = dfs.listPaths(getPath(new Path(""/"")));
		 for(int i=0;
		i<dfsFiles.length;
		i++){
			 used += dfsFiles[i].getContentsLen();
		 }
		 return used;
	 }
	 public DatanodeInfo[] getDataNodeStats() throws IOException {
		 return dfs.datanodeReport();
	 }
	 public boolean setSafeMode( FSConstants.SafeModeAction action ) throws IOException {
		 return dfs.setSafeMode( action );
	 }
}",0,0,0,0
"public void actionPerformed(ActionEvent e) {
	if (e.getSource() instanceof JRadioButton) {
		JRadioButton chk = (JRadioButton) e.getSource();
		if (""Q_DAILY"".equals(chk.getName()) || ""Q_ONCE"".equals(chk.getName())) {
			enableSchedulerFields();
		}
	}
	if (e.getSource() instanceof JMenuItem) {
		String name = ((JMenuItem) e.getSource()).getName();
		if (name != null) {
			if (name.startsWith(""Q_MOVE_TO:"")) {
				String targetQ = """";
				if (name.endsWith("":"")) {
					targetQ = """";
				}
				 else {
					targetQ = name.split("":"")[1].trim();
				}
				int index = qItemsList.getSelectedIndex();
				if (index < 0)return;
				String id = queuedItemsModel.get(index);
				Logger.log(""Moving to target queue: "" + targetQ);
				index = qList.getSelectedIndex();
				if (index < 0)return;
				DownloadQueue sourceQ = queueModel.getElementAt(index);
				sourceQ.removeFromQueue(id);
				QueueManager.getInstance().getQueueById(targetQ).addToQueue(id);
				loadSchedulerSettings(index);
			}
			return;
		}
	}
	if (e.getSource() instanceof JCheckBox) {
		JCheckBox chk = (JCheckBox) e.getSource();
		if (""MSG_Q_START"".equals(chk.getName())) {
			enableSchedulerFields();
		}
	}
	 else if (e.getSource() instanceof JButton) {
		JButton btn = (JButton) e.getSource();
		String name = btn.getName();
		if (""BTN_Q_SAVE"".equals(name)) {
			saveQueue();
			return;
		}
		if (""Q_MOVE_TO"".equals(name)) {
			showMoveQPopup(btn);
			return;
		}
		if (""BTN_Q_DEL"".equals(name)) {
			removeQueue();
		}
		if (""Q_MOVE_UP"".equals(name)) {
			queueMoveUp();
			return;
		}
		if (""Q_MOVE_DN"".equals(name)) {
			queueMoveDown();
			return;
		}
		if (""BTN_Q_NEW"".equals(name)) {
			createNewQueue();
			return;
		}
		if (""BTN_DEF_FILE_EXT"".equals(name)) {
			txtFileTyp.setText(XDMUtils.appendArray2Str(Config.getInstance().getDefaultFileTypes()));
			return;
		}
		if (""BTN_DEF_VID_EXT"".equals(name)) {
			txtVidType.setText(XDMUtils.appendArray2Str(Config.getInstance().getDefaultVideoTypes()));
			return;
		}
		if (""BTN_Q_NEW"".equals(name)) {
			createNewQueue();
			return;
		}
		if (""DEL_CRED"".equals(name)) {
			int index = passList.getSelectedIndex();
			if (index > -1) {
				PasswordItem item = passListModel.get(index);
				CredentialManager.getInstance().removeSavedCredential(item.host);
				loadPasswordSettings();
			}
		}
		if (""NEW_CRED"".equals(name)) {
			txtCredHostName.setText("""");
			txtUserName.setText("""");
			txtPassword.setText("""");
		}
		if (""SAVE_CRED"".equals(name)) {
			savePasswordSettings();
		}
		if (""BROWSE_ANTIVIR"".equals(name)) {
			JFileChooser jfc = new JFileChooser();
			if (jfc.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
				txtAntivirCmd.setText(jfc.getSelectedFile().getAbsolutePath());
			}
		}
		if (""SETTINGS_FOLDER_CHANGE"".equals(name)) {
			JFileChooser jfc = new JFileChooser();
			jfc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
			if (jfc.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
				txtDefFolder.setText(jfc.getSelectedFile().getAbsolutePath());
			}
		}
		if (""FF_INSTALL"".equals(name)) {
			if (!BrowserLauncher.launchFirefox(ffAMOURL)) {
				String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Mozilla Firefox"", ffAMOURL);
				MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,MessageBox.OK);
			}
		}
		if (""CR_INSTALL"".equals(name)) {
			if (!BrowserLauncher.launchChrome(chromeWebStoreURL)) {
				String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Google Chrome"",chromeWebStoreURL);
				MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,MessageBox.OK);
			}
		}
		if (""CM_INSTALL"".equals(name)) {
			String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Chromium"", chromeWebStoreURL);
			MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,MessageBox.OK);
		}
		if (""VL_INSTALL"".equals(name)) {
			String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Vivaldi"", chromeWebStoreURL);
			MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,MessageBox.OK);
		}
		if (""OP_INSTALL"".equals(name)) {
			String msg = String.format(StringResource.get(""MSG_ADDON_DESC""), ""Opera"", operaExtURL);
			MessageBox.show(parent, StringResource.get(""MSG_ADDON_TITLE""), msg, MessageBox.OK_OPTION,MessageBox.OK);
		}
		if (setPage(name)) {
			level = 1;
			SwingUtilities.invokeLater(new Runnable() {
				public void run() {
					jsp.getVerticalScrollBar().setValue(0);
				}
			}
			);
		}
	}
}",0,0,1,0
"private ClearCacheResponse( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
	 initFields();
	 int mutable_bitField0_ = 0;
	 com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder();
	 try {
		 boolean done = false;
		 while (!done) {
			 int tag = input.readTag();
			 switch (tag) {
				 case 0: done = true;
				 break;
				 default: {
					 if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
						 done = true;
					 }
					 break;
				 }
				 case 8: {
					 bitField0_ |= 0x00000001;
					 unfreedBytes_ = input.readInt64();
					 break;
				 }
			 }
		 }
	 }
	 catch (com.google.protobuf.InvalidProtocolBufferException e) {
		 throw e.setUnfinishedMessage(this);
	 }
	 catch (java.io.IOException e) {
		 throw new com.google.protobuf.InvalidProtocolBufferException( e.getMessage()).setUnfinishedMessage(this);
	 }
	 finally {
		 this.unknownFields = unknownFields.build();
		 makeExtensionsImmutable();
	 }
 }",0,0,1,0
"public int setPath(Path2D path) {
	 Rectangle2D bounds = path.getBounds2D();
	 PathIterator it = path.getPathIterator(null);
	 List<byte[]> segInfo = new ArrayList<>();
	 List<Point2D.Double> pntInfo = new ArrayList<>();
	 boolean isClosed = false;
	 int numPoints = 0;
	 while (!it.isDone()) {
		 double[] vals = new double[6];
		 int type = it.currentSegment(vals);
		 switch (type) {
			 case PathIterator.SEG_MOVETO: pntInfo.add(new Point2D.Double(vals[0], vals[1]));
			 segInfo.add(SEGMENTINFO_MOVETO);
			 numPoints++;
			 break;
			 case PathIterator.SEG_LINETO: pntInfo.add(new Point2D.Double(vals[0], vals[1]));
			 segInfo.add(SEGMENTINFO_LINETO);
			 segInfo.add(SEGMENTINFO_ESCAPE);
			 numPoints++;
			 break;
			 case PathIterator.SEG_CUBICTO: pntInfo.add(new Point2D.Double(vals[0], vals[1]));
			 pntInfo.add(new Point2D.Double(vals[2], vals[3]));
			 pntInfo.add(new Point2D.Double(vals[4], vals[5]));
			 segInfo.add(SEGMENTINFO_CUBICTO);
			 segInfo.add(SEGMENTINFO_ESCAPE2);
			 numPoints++;
			 break;
			 case PathIterator.SEG_QUADTO: LOG.log(POILogger.WARN, ""SEG_QUADTO is not supported"");
			 break;
			 case PathIterator.SEG_CLOSE: pntInfo.add(pntInfo.get(0));
			 segInfo.add(SEGMENTINFO_LINETO);
			 segInfo.add(SEGMENTINFO_ESCAPE);
			 segInfo.add(SEGMENTINFO_LINETO);
			 segInfo.add(SEGMENTINFO_CLOSE);
			 isClosed = true;
			 numPoints++;
			 break;
			 default: LOG.log(POILogger.WARN, ""Ignoring invalid segment type ""+type);
			 break;
		 }
		 it.next();
	 }
	 if(!isClosed) {
		 segInfo.add(SEGMENTINFO_LINETO);
	 }
	 segInfo.add(SEGMENTINFO_END);
	 AbstractEscherOptRecord opt = getEscherOptRecord();
	 opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__SHAPEPATH, 0x4));
	 EscherArrayProperty verticesProp = new EscherArrayProperty((short)(EscherProperties.GEOMETRY__VERTICES + 0x4000), false, null);
	 verticesProp.setNumberOfElementsInArray(pntInfo.size());
	 verticesProp.setNumberOfElementsInMemory(pntInfo.size());
	 verticesProp.setSizeOfElements(8);
	 for (int i = 0;
	 i < pntInfo.size();
	 i++) {
		 Point2D.Double pnt = pntInfo.get(i);
		 byte[] data = new byte[8];
		 LittleEndian.putInt(data, 0, Units.pointsToMaster(pnt.getX() - bounds.getX()));
		 LittleEndian.putInt(data, 4, Units.pointsToMaster(pnt.getY() - bounds.getY()));
		 verticesProp.setElement(i, data);
	 }
	 opt.addEscherProperty(verticesProp);
	 EscherArrayProperty segmentsProp = new EscherArrayProperty((short)(EscherProperties.GEOMETRY__SEGMENTINFO + 0x4000), false, null);
	 segmentsProp.setNumberOfElementsInArray(segInfo.size());
	 segmentsProp.setNumberOfElementsInMemory(segInfo.size());
	 segmentsProp.setSizeOfElements(0x2);
	 for (int i = 0;
	 i < segInfo.size();
	 i++) {
		 byte[] seg = segInfo.get(i);
		 segmentsProp.setElement(i, seg);
	 }
	 opt.addEscherProperty(segmentsProp);
	 opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, Units.pointsToMaster(bounds.getWidth())));
	 opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, Units.pointsToMaster(bounds.getHeight())));
	 opt.sortProperties();
	 setAnchor(bounds);
	 return numPoints;
 }",0,0,1,0
"public abstract class ScriptableObject implements Scriptable, Serializable, DebuggableObject, ConstProperties{
	 public static final int EMPTY = 0x00;
	 public static final int READONLY = 0x01;
	 public static final int DONTENUM = 0x02;
	 public static final int PERMANENT = 0x04;
	 public static final int UNINITIALIZED_CONST = 0x08;
	 public static final int CONST = PERMANENT|READONLY|UNINITIALIZED_CONST;
	 private Scriptable prototypeObject;
	 private Scriptable parentScopeObject;
	 private static final Slot REMOVED = new Slot(null, 0, READONLY);
	 static {
		 REMOVED.wasDeleted = 1;
	 }
	 private transient Slot[] slots;
	 private int count;
	 private transient Slot lastAccess = REMOVED;
	 private transient volatile Hashtable associatedValues;
	 private static final int SLOT_QUERY = 1;
	 private static final int SLOT_MODIFY = 2;
	 private static final int SLOT_REMOVE = 3;
	 private static final int SLOT_MODIFY_GETTER_SETTER = 4;
	 private static final int SLOT_MODIFY_CONST = 5;
	 private static class Slot implements Serializable {
		 static final long serialVersionUID = -3539051633409902634L;
		 String name;
		 int indexOrHash;
		 private volatile short attributes;
		 transient volatile byte wasDeleted;
		 volatile Object value;
		 transient volatile Slot next;
		 Slot(String name, int indexOrHash, int attributes) {
			 this.name = name;
			 this.indexOrHash = indexOrHash;
			 this.attributes = (short)attributes;
		 }
		 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
			 in.defaultReadObject();
			 if (name != null) {
				 indexOrHash = name.hashCode();
			 }
		 }
		 final int getAttributes() {
			 return attributes;
		 }
		 final synchronized void setAttributes(int value) {
			 checkValidAttributes(value);
			 attributes = (short)value;
		 }
		 final void checkNotReadonly() {
			 if ((attributes & READONLY) != 0) {
				 String str = (name != null ? name : Integer.toString(indexOrHash));
				 throw Context.reportRuntimeError1(""msg.modify.readonly"", str);
			 }
		 }
	 }
	 private static final class GetterSlot extends Slot {
		 static final long serialVersionUID = -4900574849788797588L;
		 Object getter;
		 Object setter;
		 GetterSlot(String name, int indexOrHash, int attributes) {
			 super(name, indexOrHash, attributes);
		 }
	 }
	 static void checkValidAttributes(int attributes) {
		 final int mask = READONLY | DONTENUM | PERMANENT | UNINITIALIZED_CONST;
		 if ((attributes & ~mask) != 0) {
			 throw new IllegalArgumentException(String.valueOf(attributes));
		 }
	 }
	 public ScriptableObject() {
	 }
	 public ScriptableObject(Scriptable scope, Scriptable prototype) {
		 if (scope == null) throw new IllegalArgumentException();
		 parentScopeObject = scope;
		 prototypeObject = prototype;
	 }
	 public abstract String getClassName();
	 public boolean has(String name, Scriptable start) {
		 return null != getSlot(name, 0, SLOT_QUERY);
	 }
	 public boolean has(int index, Scriptable start) {
		 return null != getSlot(null, index, SLOT_QUERY);
	 }
	 public Object get(String name, Scriptable start) {
		 return getImpl(name, 0, start);
	 }
	 public Object get(int index, Scriptable start) {
		 return getImpl(null, index, start);
	 }
	 public void put(String name, Scriptable start, Object value) {
		 if (putImpl(name, 0, start, value, EMPTY)) return;
		 if (start == this) throw Kit.codeBug();
		 start.put(name, start, value);
	 }
	 public void put(int index, Scriptable start, Object value) {
		 if (putImpl(null, index, start, value, EMPTY)) return;
		 if (start == this) throw Kit.codeBug();
		 start.put(index, start, value);
	 }
	 public void delete(String name) {
		 checkNotSealed(name, 0);
		 accessSlot(name, 0, SLOT_REMOVE);
	 }
	 public void delete(int index) {
		 checkNotSealed(null, index);
		 accessSlot(null, index, SLOT_REMOVE);
	 }
	 public void putConst(String name, Scriptable start, Object value) {
		 if (putImpl(name, 0, start, value, READONLY)) return;
		 if (start == this) throw Kit.codeBug();
		 if (start instanceof ConstProperties) ((ConstProperties)start).putConst(name, start, value);
		 else start.put(name, start, value);
	 }
	 public void defineConst(String name, Scriptable start) {
		 if (putImpl(name, 0, start, Undefined.instance, UNINITIALIZED_CONST)) return;
		 if (start == this) throw Kit.codeBug();
		 if (start instanceof ConstProperties) ((ConstProperties)start).defineConst(name, start);
	 }
	 public boolean isConst(String name) {
		 Slot slot = getSlot(name, 0, SLOT_QUERY);
		 if (slot == null) {
			 return false;
		 }
		 return (slot.getAttributes() & (PERMANENT|READONLY)) == (PERMANENT|READONLY);
	 }
	 public final int getAttributes(String name, Scriptable start) {
		 return getAttributes(name);
	 }
	 public final int getAttributes(int index, Scriptable start) {
		 return getAttributes(index);
	 }
	 public final void setAttributes(String name, Scriptable start, int attributes) {
		 setAttributes(name, attributes);
	 }
	 public void setAttributes(int index, Scriptable start, int attributes) {
		 setAttributes(index, attributes);
	 }
	 public int getAttributes(String name) {
		 return findAttributeSlot(name, 0, SLOT_QUERY).getAttributes();
	 }
	 public int getAttributes(int index) {
		 return findAttributeSlot(null, index, SLOT_QUERY).getAttributes();
	 }
	 public void setAttributes(String name, int attributes) {
		 checkNotSealed(name, 0);
		 findAttributeSlot(name, 0, SLOT_MODIFY).setAttributes(attributes);
	 }
	 public void setAttributes(int index, int attributes) {
		 checkNotSealed(null, index);
		 findAttributeSlot(null, index, SLOT_MODIFY).setAttributes(attributes);
	 }
	 public void setGetterOrSetter(String name, int index, Callable getterOrSeter, boolean isSetter) {
		 if (name != null && index != 0) throw new IllegalArgumentException(name);
		 checkNotSealed(name, index);
		 GetterSlot gslot = (GetterSlot)getSlot(name, index, SLOT_MODIFY_GETTER_SETTER);
		 gslot.checkNotReadonly();
		 if (isSetter) {
			 gslot.setter = getterOrSeter;
		 }
		 else {
			 gslot.getter = getterOrSeter;
		 }
		 gslot.value = Undefined.instance;
	 }
	 public Object getGetterOrSetter(String name, int index, boolean isSetter) {
		 if (name != null && index != 0) throw new IllegalArgumentException(name);
		 Slot slot = getSlot(name, index, SLOT_QUERY);
		 if (slot == null) return null;
		 if (slot instanceof GetterSlot) {
			 GetterSlot gslot = (GetterSlot)slot;
			 Object result = isSetter ? gslot.setter : gslot.getter;
			 return result != null ? result : Undefined.instance;
		 }
		 else return Undefined.instance;
	 }
	 void addLazilyInitializedValue(String name, int index, LazilyLoadedCtor init, int attributes) {
		 if (name != null && index != 0) throw new IllegalArgumentException(name);
		 checkNotSealed(name, index);
		 GetterSlot gslot = (GetterSlot)getSlot(name, index, SLOT_MODIFY_GETTER_SETTER);
		 gslot.setAttributes(attributes);
		 gslot.getter = null;
		 gslot.setter = null;
		 gslot.value = init;
	 }
	 public Scriptable getPrototype() {
		 return prototypeObject;
	 }
	 public void setPrototype(Scriptable m) {
		 prototypeObject = m;
	 }
	 public Scriptable getParentScope() {
		 return parentScopeObject;
	 }
	 public void setParentScope(Scriptable m) {
		 parentScopeObject = m;
	 }
	 public Object[] getIds() {
		 return getIds(false);
	 }
	 public Object[] getAllIds() {
		 return getIds(true);
	 }
	 public Object getDefaultValue(Class typeHint) {
		 return getDefaultValue(this, typeHint);
	 }
	 public static Object getDefaultValue(Scriptable object, Class typeHint) {
		 Context cx = null;
		 for (int i=0;
		 i < 2;
		 i++) {
			 boolean tryToString;
			 if (typeHint == ScriptRuntime.StringClass) {
				 tryToString = (i == 0);
			 }
			 else {
				 tryToString = (i == 1);
			 }
			 String methodName;
			 Object[] args;
			 if (tryToString) {
				 methodName = ""toString"";
				 args = ScriptRuntime.emptyArgs;
			 }
			 else {
				 methodName = ""valueOf"";
				 args = new Object[1];
				 String hint;
				 if (typeHint == null) {
					 hint = ""undefined"";
				 }
				 else if (typeHint == ScriptRuntime.StringClass) {
					 hint = ""string"";
				 }
				 else if (typeHint == ScriptRuntime.ScriptableClass) {
					 hint = ""object"";
				 }
				 else if (typeHint == ScriptRuntime.FunctionClass) {
					 hint = ""function"";
				 }
				 else if (typeHint == ScriptRuntime.BooleanClass || typeHint == Boolean.TYPE) {
					 hint = ""boolean"";
				 }
				 else if (typeHint == ScriptRuntime.NumberClass || typeHint == ScriptRuntime.ByteClass || typeHint == Byte.TYPE || typeHint == ScriptRuntime.ShortClass || typeHint == Short.TYPE || typeHint == ScriptRuntime.IntegerClass || typeHint == Integer.TYPE || typeHint == ScriptRuntime.FloatClass || typeHint == Float.TYPE || typeHint == ScriptRuntime.DoubleClass || typeHint == Double.TYPE) {
					 hint = ""number"";
				 }
				 else {
					 throw Context.reportRuntimeError1( ""msg.invalid.type"", typeHint.toString());
				 }
				 args[0] = hint;
			 }
			 Object v = getProperty(object, methodName);
			 if (!(v instanceof Function)) continue;
			 Function fun = (Function) v;
			 if (cx == null) cx = Context.getContext();
			 v = fun.call(cx, fun.getParentScope(), object, args);
			 if (v != null) {
				 if (!(v instanceof Scriptable)) {
					 return v;
				 }
				 if (typeHint == ScriptRuntime.ScriptableClass || typeHint == ScriptRuntime.FunctionClass) {
					 return v;
				 }
				 if (tryToString && v instanceof Wrapper) {
					 Object u = ((Wrapper)v).unwrap();
					 if (u instanceof String) return u;
				 }
			 }
		 }
		 String arg = (typeHint == null) ? ""undefined"" : typeHint.getName();
		 throw ScriptRuntime.typeError1(""msg.default.value"", arg);
	 }
	 public boolean hasInstance(Scriptable instance) {
		 return ScriptRuntime.jsDelegatesTo(instance, this);
	 }
	 protected Object equivalentValues(Object value) {
		 return (this == value) ? Boolean.TRUE : Scriptable.NOT_FOUND;
	 }
	 public static void defineClass(Scriptable scope, Class clazz) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 defineClass(scope, clazz, false, false);
	 }
	 public static void defineClass(Scriptable scope, Class clazz, boolean sealed) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 defineClass(scope, clazz, sealed, false);
	 }
	 public static String defineClass(Scriptable scope, Class clazz, boolean sealed, boolean mapInheritance) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 BaseFunction ctor = buildClassCtor(scope, clazz, sealed, mapInheritance);
		 if (ctor == null) return null;
		 String name = ctor.getClassPrototype().getClassName();
		 defineProperty(scope, name, ctor, ScriptableObject.DONTENUM);
		 return name;
	 }
	 static BaseFunction buildClassCtor(Scriptable scope, Class clazz, boolean sealed, boolean mapInheritance) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 for (int i=0;
		 i < methods.length;
		 i++) {
			 Method method = methods[i];
			 if (!method.getName().equals(""init"")) continue;
			 Class[] parmTypes = method.getParameterTypes();
			 if (parmTypes.length == 3 && parmTypes[0] == ScriptRuntime.ContextClass && parmTypes[1] == ScriptRuntime.ScriptableClass && parmTypes[2] == Boolean.TYPE && Modifier.isStatic(method.getModifiers())) {
				 Object args[] = {
				 Context.getContext(), scope, sealed ? Boolean.TRUE : Boolean.FALSE }
				;
				 method.invoke(null, args);
				 return null;
			 }
			 if (parmTypes.length == 1 && parmTypes[0] == ScriptRuntime.ScriptableClass && Modifier.isStatic(method.getModifiers())) {
				 Object args[] = {
				 scope }
				;
				 method.invoke(null, args);
				 return null;
			 }
		 }
		 Constructor[] ctors = clazz.getConstructors();
		 Constructor protoCtor = null;
		 for (int i=0;
		 i < ctors.length;
		 i++) {
			 if (ctors[i].getParameterTypes().length == 0) {
				 protoCtor = ctors[i];
				 break;
			 }
		 }
		 if (protoCtor == null) {
			 throw Context.reportRuntimeError1( ""msg.zero.arg.ctor"", clazz.getName());
		 }
		 Scriptable proto = (Scriptable) protoCtor.newInstance(ScriptRuntime.emptyArgs);
		 String className = proto.getClassName();
		 Scriptable superProto = null;
		 if (mapInheritance) {
			 Class superClass = clazz.getSuperclass();
			 if (ScriptRuntime.ScriptableClass.isAssignableFrom(superClass) && !Modifier.isAbstract(superClass.getModifiers())) {
				 String name = ScriptableObject.defineClass(scope, superClass, sealed, mapInheritance);
				 if (name != null) {
					 superProto = ScriptableObject.getClassPrototype(scope, name);
				 }
			 }
		 }
		 if (superProto == null) {
			 superProto = ScriptableObject.getObjectPrototype(scope);
		 }
		 proto.setPrototype(superProto);
		 final String functionPrefix = ""jsFunction_"";
		 final String staticFunctionPrefix = ""jsStaticFunction_"";
		 final String getterPrefix = ""jsGet_"";
		 final String setterPrefix = ""jsSet_"";
		 final String ctorName = ""jsConstructor"";
		 Member ctorMember = FunctionObject.findSingleMethod(methods, ctorName);
		 if (ctorMember == null) {
			 if (ctors.length == 1) {
				 ctorMember = ctors[0];
			 }
			 else if (ctors.length == 2) {
				 if (ctors[0].getParameterTypes().length == 0) ctorMember = ctors[1];
				 else if (ctors[1].getParameterTypes().length == 0) ctorMember = ctors[0];
			 }
			 if (ctorMember == null) {
				 throw Context.reportRuntimeError1( ""msg.ctor.multiple.parms"", clazz.getName());
			 }
		 }
		 FunctionObject ctor = new FunctionObject(className, ctorMember, scope);
		 if (ctor.isVarArgsMethod()) {
			 throw Context.reportRuntimeError1 (""msg.varargs.ctor"", ctorMember.getName());
		 }
		 ctor.initAsConstructor(scope, proto);
		 Method finishInit = null;
		 for (int i=0;
		 i < methods.length;
		 i++) {
			 if (methods[i] == ctorMember) {
				 continue;
			 }
			 String name = methods[i].getName();
			 if (name.equals(""finishInit"")) {
				 Class[] parmTypes = methods[i].getParameterTypes();
				 if (parmTypes.length == 3 && parmTypes[0] == ScriptRuntime.ScriptableClass && parmTypes[1] == FunctionObject.class && parmTypes[2] == ScriptRuntime.ScriptableClass && Modifier.isStatic(methods[i].getModifiers())) {
					 finishInit = methods[i];
					 continue;
				 }
			 }
			 if (name.indexOf('$') != -1) continue;
			 if (name.equals(ctorName)) continue;
			 String prefix = null;
			 if (name.startsWith(functionPrefix)) {
				 prefix = functionPrefix;
			 }
			 else if (name.startsWith(staticFunctionPrefix)) {
				 prefix = staticFunctionPrefix;
				 if (!Modifier.isStatic(methods[i].getModifiers())) {
					 throw Context.reportRuntimeError( ""jsStaticFunction must be used with static method."");
				 }
			 }
			 else if (name.startsWith(getterPrefix)) {
				 prefix = getterPrefix;
			 }
			 else if (name.startsWith(setterPrefix)) {
				 prefix = setterPrefix;
			 }
			 else {
				 continue;
			 }
			 name = name.substring(prefix.length());
			 if (prefix == setterPrefix) continue;
			 if (prefix == getterPrefix) {
				 if (!(proto instanceof ScriptableObject)) {
					 throw Context.reportRuntimeError2( ""msg.extend.scriptable"", proto.getClass().toString(), name);
				 }
				 Method setter = FunctionObject.findSingleMethod( methods, setterPrefix + name);
				 int attr = ScriptableObject.PERMANENT | ScriptableObject.DONTENUM | (setter != null ? 0 : ScriptableObject.READONLY);
				 ((ScriptableObject) proto).defineProperty(name, null, methods[i], setter, attr);
				 continue;
			 }
			 FunctionObject f = new FunctionObject(name, methods[i], proto);
			 if (f.isVarArgsConstructor()) {
				 throw Context.reportRuntimeError1 (""msg.varargs.fun"", ctorMember.getName());
			 }
			 Scriptable dest = prefix == staticFunctionPrefix ? ctor : proto;
			 defineProperty(dest, name, f, DONTENUM);
			 if (sealed) {
				 f.sealObject();
			 }
		 }
		 if (finishInit != null) {
			 Object[] finishArgs = {
			 scope, ctor, proto }
			;
			 finishInit.invoke(null, finishArgs);
		 }
		 if (sealed) {
			 ctor.sealObject();
			 if (proto instanceof ScriptableObject) {
				 ((ScriptableObject) proto).sealObject();
			 }
		 }
		 return ctor;
	 }
	 public void defineProperty(String propertyName, Object value, int attributes) {
		 checkNotSealed(propertyName, 0);
		 put(propertyName, this, value);
		 setAttributes(propertyName, attributes);
	 }
	 public static void defineProperty(Scriptable destination, String propertyName, Object value, int attributes) {
		 if (!(destination instanceof ScriptableObject)) {
			 destination.put(propertyName, destination, value);
			 return;
		 }
		 ScriptableObject so = (ScriptableObject)destination;
		 so.defineProperty(propertyName, value, attributes);
	 }
	 public static void defineConstProperty(Scriptable destination, String propertyName) {
		 if (destination instanceof ConstProperties) {
			 ConstProperties cp = (ConstProperties)destination;
			 cp.defineConst(propertyName, destination);
		 }
		 else defineProperty(destination, propertyName, Undefined.instance, CONST);
	 }
	 public void defineProperty(String propertyName, Class clazz, int attributes) {
		 int length = propertyName.length();
		 if (length == 0) throw new IllegalArgumentException();
		 char[] buf = new char[3 + length];
		 propertyName.getChars(0, length, buf, 3);
		 buf[3] = Character.toUpperCase(buf[3]);
		 buf[0] = 'g';
		 buf[1] = 'e';
		 buf[2] = 't';
		 String getterName = new String(buf);
		 buf[0] = 's';
		 String setterName = new String(buf);
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 Method getter = FunctionObject.findSingleMethod(methods, getterName);
		 Method setter = FunctionObject.findSingleMethod(methods, setterName);
		 if (setter == null) attributes |= ScriptableObject.READONLY;
		 defineProperty(propertyName, null, getter, setter == null ? null : setter, attributes);
	 }
	 public void defineProperty(String propertyName, Object delegateTo, Method getter, Method setter, int attributes) {
		 MemberBox getterBox = null;
		 if (getter != null) {
			 getterBox = new MemberBox(getter);
			 boolean delegatedForm;
			 if (!Modifier.isStatic(getter.getModifiers())) {
				 delegatedForm = (delegateTo != null);
				 getterBox.delegateTo = delegateTo;
			 }
			 else {
				 delegatedForm = true;
				 getterBox.delegateTo = Void.TYPE;
			 }
			 String errorId = null;
			 Class[] parmTypes = getter.getParameterTypes();
			 if (parmTypes.length == 0) {
				 if (delegatedForm) {
					 errorId = ""msg.obj.getter.parms"";
				 }
			 }
			 else if (parmTypes.length == 1) {
				 Object argType = parmTypes[0];
				 if (!(argType == ScriptRuntime.ScriptableClass || argType == ScriptRuntime.ScriptableObjectClass)) {
					 errorId = ""msg.bad.getter.parms"";
				 }
				 else if (!delegatedForm) {
					 errorId = ""msg.bad.getter.parms"";
				 }
			 }
			 else {
				 errorId = ""msg.bad.getter.parms"";
			 }
			 if (errorId != null) {
				 throw Context.reportRuntimeError1(errorId, getter.toString());
			 }
		 }
		 MemberBox setterBox = null;
		 if (setter != null) {
			 if (setter.getReturnType() != Void.TYPE) throw Context.reportRuntimeError1(""msg.setter.return"", setter.toString());
			 setterBox = new MemberBox(setter);
			 boolean delegatedForm;
			 if (!Modifier.isStatic(setter.getModifiers())) {
				 delegatedForm = (delegateTo != null);
				 setterBox.delegateTo = delegateTo;
			 }
			 else {
				 delegatedForm = true;
				 setterBox.delegateTo = Void.TYPE;
			 }
			 String errorId = null;
			 Class[] parmTypes = setter.getParameterTypes();
			 if (parmTypes.length == 1) {
				 if (delegatedForm) {
					 errorId = ""msg.setter2.expected"";
				 }
			 }
			 else if (parmTypes.length == 2) {
				 Object argType = parmTypes[0];
				 if (!(argType == ScriptRuntime.ScriptableClass || argType == ScriptRuntime.ScriptableObjectClass)) {
					 errorId = ""msg.setter2.parms"";
				 }
				 else if (!delegatedForm) {
					 errorId = ""msg.setter1.parms"";
				 }
			 }
			 else {
				 errorId = ""msg.setter.parms"";
			 }
			 if (errorId != null) {
				 throw Context.reportRuntimeError1(errorId, setter.toString());
			 }
		 }
		 GetterSlot gslot = (GetterSlot)getSlot(propertyName, 0, SLOT_MODIFY_GETTER_SETTER);
		 gslot.setAttributes(attributes);
		 gslot.getter = getterBox;
		 gslot.setter = setterBox;
	 }
	 public void defineFunctionProperties(String[] names, Class clazz, int attributes) {
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 for (int i=0;
		 i < names.length;
		 i++) {
			 String name = names[i];
			 Method m = FunctionObject.findSingleMethod(methods, name);
			 if (m == null) {
				 throw Context.reportRuntimeError2( ""msg.method.not.found"", name, clazz.getName());
			 }
			 FunctionObject f = new FunctionObject(name, m, this);
			 defineProperty(name, f, attributes);
		 }
	 }
	 public static Scriptable getObjectPrototype(Scriptable scope) {
		 return getClassPrototype(scope, ""Object"");
	 }
	 public static Scriptable getFunctionPrototype(Scriptable scope) {
		 return getClassPrototype(scope, ""Function"");
	 }
	 public static Scriptable getClassPrototype(Scriptable scope, String className) {
		 scope = getTopLevelScope(scope);
		 Object ctor = getProperty(scope, className);
		 Object proto;
		 if (ctor instanceof BaseFunction) {
			 proto = ((BaseFunction)ctor).getPrototypeProperty();
		 }
		 else if (ctor instanceof Scriptable) {
			 Scriptable ctorObj = (Scriptable)ctor;
			 proto = ctorObj.get(""prototype"", ctorObj);
		 }
		 else {
			 return null;
		 }
		 if (proto instanceof Scriptable) {
			 return (Scriptable)proto;
		 }
		 return null;
	 }
	 public static Scriptable getTopLevelScope(Scriptable obj) {
		 for (;
		;
		) {
			 Scriptable parent = obj.getParentScope();
			 if (parent == null) {
				 return obj;
			 }
			 obj = parent;
		 }
	 }
	 public synchronized void sealObject() {
		 if (count >= 0) {
			 count = ~count;
		 }
	 }
	 public final boolean isSealed() {
		 return count < 0;
	 }
	 private void checkNotSealed(String name, int index) {
		 if (!isSealed()) return;
		 String str = (name != null) ? name : Integer.toString(index);
		 throw Context.reportRuntimeError1(""msg.modify.sealed"", str);
	 }
	 public static Object getProperty(Scriptable obj, String name) {
		 Scriptable start = obj;
		 Object result;
		 do {
			 result = obj.get(name, start);
			 if (result != Scriptable.NOT_FOUND) break;
			 obj = obj.getPrototype();
		 }
		 while (obj != null);
		 return result;
	 }
	 public static Object getProperty(Scriptable obj, int index) {
		 Scriptable start = obj;
		 Object result;
		 do {
			 result = obj.get(index, start);
			 if (result != Scriptable.NOT_FOUND) break;
			 obj = obj.getPrototype();
		 }
		 while (obj != null);
		 return result;
	 }
	 public static boolean hasProperty(Scriptable obj, String name) {
		 return null != getBase(obj, name);
	 }
	 public static void redefineProperty(Scriptable obj, String name, boolean isConst) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) return;
		 if (base instanceof ConstProperties) {
			 ConstProperties cp = (ConstProperties)base;
			 if (cp.isConst(name)) throw Context.reportRuntimeError1(""msg.const.redecl"", name);
		 }
		 if (isConst) throw Context.reportRuntimeError1(""msg.var.redecl"", name);
	 }
	 public static boolean hasProperty(Scriptable obj, int index) {
		 return null != getBase(obj, index);
	 }
	 public static void putProperty(Scriptable obj, String name, Object value) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) base = obj;
		 base.put(name, obj, value);
	 }
	 public static void putConstProperty(Scriptable obj, String name, Object value) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) base = obj;
		 if (base instanceof ConstProperties) ((ConstProperties)base).putConst(name, obj, value);
	 }
	 public static void putProperty(Scriptable obj, int index, Object value) {
		 Scriptable base = getBase(obj, index);
		 if (base == null) base = obj;
		 base.put(index, obj, value);
	 }
	 public static boolean deleteProperty(Scriptable obj, String name) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) return true;
		 base.delete(name);
		 return !base.has(name, obj);
	 }
	 public static boolean deleteProperty(Scriptable obj, int index) {
		 Scriptable base = getBase(obj, index);
		 if (base == null) return true;
		 base.delete(index);
		 return !base.has(index, obj);
	 }
	 public static Object[] getPropertyIds(Scriptable obj) {
		 if (obj == null) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] result = obj.getIds();
		 ObjToIntMap map = null;
		 for (;
		;
		) {
			 obj = obj.getPrototype();
			 if (obj == null) {
				 break;
			 }
			 Object[] ids = obj.getIds();
			 if (ids.length == 0) {
				 continue;
			 }
			 if (map == null) {
				 if (result.length == 0) {
					 result = ids;
					 continue;
				 }
				 map = new ObjToIntMap(result.length + ids.length);
				 for (int i = 0;
				 i != result.length;
				 ++i) {
					 map.intern(result[i]);
				 }
				 result = null;
			 }
			 for (int i = 0;
			 i != ids.length;
			 ++i) {
				 map.intern(ids[i]);
			 }
		 }
		 if (map != null) {
			 result = map.getKeys();
		 }
		 return result;
	 }
	 public static Object callMethod(Scriptable obj, String methodName, Object[] args) {
		 return callMethod(null, obj, methodName, args);
	 }
	 public static Object callMethod(Context cx, Scriptable obj, String methodName, Object[] args) {
		 Object funObj = getProperty(obj, methodName);
		 if (!(funObj instanceof Function)) {
			 throw ScriptRuntime.notFunctionError(obj, methodName);
		 }
		 Function fun = (Function)funObj;
		 Scriptable scope = ScriptableObject.getTopLevelScope(obj);
		 if (cx != null) {
			 return fun.call(cx, scope, obj, args);
		 }
		 else {
			 return Context.call(null, fun, scope, obj, args);
		 }
	 }
	 private static Scriptable getBase(Scriptable obj, String name) {
		 do {
			 if (obj.has(name, obj)) break;
			 obj = obj.getPrototype();
		 }
		 while(obj != null);
		 return obj;
	 }
	 private static Scriptable getBase(Scriptable obj, int index) {
		 do {
			 if (obj.has(index, obj)) break;
			 obj = obj.getPrototype();
		 }
		 while(obj != null);
		 return obj;
	 }
	 public final Object getAssociatedValue(Object key) {
		 Hashtable h = associatedValues;
		 if (h == null) return null;
		 return h.get(key);
	 }
	 public static Object getTopScopeValue(Scriptable scope, Object key) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 for (;
		;
		) {
			 if (scope instanceof ScriptableObject) {
				 ScriptableObject so = (ScriptableObject)scope;
				 Object value = so.getAssociatedValue(key);
				 if (value != null) {
					 return value;
				 }
			 }
			 scope = scope.getPrototype();
			 if (scope == null) {
				 return null;
			 }
		 }
	 }
	 public final Object associateValue(Object key, Object value) {
		 if (value == null) throw new IllegalArgumentException();
		 Hashtable h = associatedValues;
		 if (h == null) {
			 synchronized (this) {
				 h = associatedValues;
				 if (h == null) {
					 h = new Hashtable();
					 associatedValues = h;
				 }
			 }
		 }
		 return Kit.initHash(h, key, value);
	 }
	 private Object getImpl(String name, int index, Scriptable start) {
		 Slot slot = getSlot(name, index, SLOT_QUERY);
		 if (slot == null) {
			 return Scriptable.NOT_FOUND;
		 }
		 if (!(slot instanceof GetterSlot)) {
			 return slot.value;
		 }
		 Object getterObj = ((GetterSlot)slot).getter;
		 if (getterObj != null) {
			 if (getterObj instanceof MemberBox) {
				 MemberBox nativeGetter = (MemberBox)getterObj;
				 Object getterThis;
				 Object[] args;
				 if (nativeGetter.delegateTo == null) {
					 getterThis = start;
					 args = ScriptRuntime.emptyArgs;
				 }
				 else {
					 getterThis = nativeGetter.delegateTo;
					 args = new Object[] {
					 start }
					;
				 }
				 return nativeGetter.invoke(getterThis, args);
			 }
			 else {
				 Callable f = (Callable)getterObj;
				 Context cx = Context.getContext();
				 return f.call(cx, ScriptRuntime.getTopCallScope(cx), start, ScriptRuntime.emptyArgs);
			 }
		 }
		 Object value = slot.value;
		 if (value instanceof LazilyLoadedCtor) {
			 LazilyLoadedCtor initializer = (LazilyLoadedCtor)value;
			 try {
				 initializer.init();
			 }
			 finally {
				 value = initializer.getValue();
				 slot.value = value;
			 }
		 }
		 return value;
	 }
	 private boolean putImpl(String name, int index, Scriptable start, Object value, int constFlag) {
		 Slot slot;
		 if (this != start) {
			 slot = getSlot(name, index, SLOT_QUERY);
			 if (slot == null) {
				 return false;
			 }
		 }
		 else {
			 checkNotSealed(name, index);
			 if (constFlag != EMPTY) {
				 slot = getSlot(name, index, SLOT_MODIFY_CONST);
				 int attr = slot.getAttributes();
				 if ((attr & READONLY) == 0) throw Context.reportRuntimeError1(""msg.var.redecl"", name);
				 if ((attr & UNINITIALIZED_CONST) != 0) {
					 slot.value = value;
					 if (constFlag != UNINITIALIZED_CONST) slot.setAttributes(attr & ~UNINITIALIZED_CONST);
				 }
				 return true;
			 }
			 slot = getSlot(name, index, SLOT_MODIFY);
		 }
		 if ((slot.getAttributes() & READONLY) != 0) return true;
		 if (slot instanceof GetterSlot) {
			 Object setterObj = ((GetterSlot)slot).setter;
			 if (setterObj != null) {
				 Context cx = Context.getContext();
				 if (setterObj instanceof MemberBox) {
					 MemberBox nativeSetter = (MemberBox)setterObj;
					 Class pTypes[] = nativeSetter.argTypes;
					 Class valueType = pTypes[pTypes.length - 1];
					 int tag = FunctionObject.getTypeTag(valueType);
					 Object actualArg = FunctionObject.convertArg(cx, start, value, tag);
					 Object setterThis;
					 Object[] args;
					 if (nativeSetter.delegateTo == null) {
						 setterThis = start;
						 args = new Object[] {
						 actualArg }
						;
					 }
					 else {
						 setterThis = nativeSetter.delegateTo;
						 args = new Object[] {
						 start, actualArg }
						;
					 }
					 nativeSetter.invoke(setterThis, args);
				 }
				 else {
					 Callable f = (Callable)setterObj;
					 f.call(cx, ScriptRuntime.getTopCallScope(cx), start, new Object[] {
					 value }
					);
				 }
				 return true;
			 }
		 }
		 if (this == start) {
			 slot.value = value;
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 private Slot findAttributeSlot(String name, int index, int accessType) {
		 Slot slot = getSlot(name, index, accessType);
		 if (slot == null) {
			 String str = (name != null ? name : Integer.toString(index));
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", str);
		 }
		 return slot;
	 }
	 private Slot getSlot(String name, int index, int accessType) {
		 Slot slot;
		 lastAccessCheck: {
			 slot = lastAccess;
			 if (name != null) {
				 if (name != slot.name) break lastAccessCheck;
			 }
			 else {
				 if (slot.name != null || index != slot.indexOrHash) break lastAccessCheck;
			 }
			 if (slot.wasDeleted != 0) break lastAccessCheck;
			 if (accessType == SLOT_MODIFY_GETTER_SETTER && !(slot instanceof GetterSlot)) break lastAccessCheck;
			 return slot;
		 }
		 slot = accessSlot(name, index, accessType);
		 if (slot != null) {
			 lastAccess = slot;
		 }
		 return slot;
	 }
	 private Slot accessSlot(String name, int index, int accessType) {
		 int indexOrHash = (name != null ? name.hashCode() : index);
		 if (accessType == SLOT_QUERY || accessType == SLOT_MODIFY || accessType == SLOT_MODIFY_CONST || accessType == SLOT_MODIFY_GETTER_SETTER) {
			 Slot[] slotsLocalRef = slots;
			 if (slotsLocalRef == null) {
				 if (accessType == SLOT_QUERY) return null;
			 }
			 else {
				 int tableSize = slotsLocalRef.length;
				 int slotIndex = getSlotIndex(tableSize, indexOrHash);
				 Slot slot = slotsLocalRef[slotIndex];
				 while (slot != null) {
					 String sname = slot.name;
					 if (sname != null) {
						 if (sname == name) break;
						 if (name != null && indexOrHash == slot.indexOrHash) {
							 if (name.equals(sname)) {
								 slot.name = name;
								 break;
							 }
						 }
					 }
					 else if (name == null && indexOrHash == slot.indexOrHash) {
						 break;
					 }
					 slot = slot.next;
				 }
				 if (accessType == SLOT_QUERY) {
					 return slot;
				 }
				 else if (accessType == SLOT_MODIFY) {
					 if (slot != null) return slot;
				 }
				 else if (accessType == SLOT_MODIFY_GETTER_SETTER) {
					 if (slot instanceof GetterSlot) return slot;
				 }
				 else if (accessType == SLOT_MODIFY_CONST) {
					 if (slot != null) return slot;
				 }
			 }
			 synchronized (this) {
				 slotsLocalRef = slots;
				 int insertPos;
				 if (count == 0) {
					 slotsLocalRef = new Slot[5];
					 slots = slotsLocalRef;
					 insertPos = getSlotIndex(slotsLocalRef.length, indexOrHash);
				 }
				 else {
					 int tableSize = slotsLocalRef.length;
					 insertPos = getSlotIndex(tableSize, indexOrHash);
					 Slot prev = slotsLocalRef[insertPos];
					 Slot slot = prev;
					 while (slot != null) {
						 if (slot.indexOrHash == indexOrHash && (slot.name == name || (name != null && name.equals(slot.name)))) {
							 break;
						 }
						 prev = slot;
						 slot = slot.next;
					 }
					 if (slot != null) {
						 if (accessType == SLOT_MODIFY_GETTER_SETTER && !(slot instanceof GetterSlot)) {
							 GetterSlot newSlot = new GetterSlot(name, indexOrHash, slot.getAttributes());
							 newSlot.value = slot.value;
							 newSlot.next = slot.next;
							 if (prev == slot) {
								 slotsLocalRef[insertPos] = newSlot;
							 }
							 else {
								 prev.next = newSlot;
							 }
							 slot.wasDeleted = (byte)1;
							 if (slot == lastAccess) {
								 lastAccess = REMOVED;
							 }
							 slot = newSlot;
						 }
						 else if (accessType == SLOT_MODIFY_CONST) {
							 return null;
						 }
						 return slot;
					 }
					 if (4 * (count + 1) > 3 * slotsLocalRef.length) {
						 slotsLocalRef = new Slot[slotsLocalRef.length * 2 + 1];
						 copyTable(slots, slotsLocalRef, count);
						 slots = slotsLocalRef;
						 insertPos = getSlotIndex(slotsLocalRef.length, indexOrHash);
					 }
				 }
				 Slot newSlot = (accessType == SLOT_MODIFY_GETTER_SETTER ? new GetterSlot(name, indexOrHash, 0) : new Slot(name, indexOrHash, 0));
				 if (accessType == SLOT_MODIFY_CONST) newSlot.setAttributes(CONST);
				 ++count;
				 addKnownAbsentSlot(slotsLocalRef, newSlot, insertPos);
				 return newSlot;
			 }
		 }
		 else if (accessType == SLOT_REMOVE) {
			 synchronized (this) {
				 Slot[] slotsLocalRef = slots;
				 if (count != 0) {
					 int tableSize = slots.length;
					 int slotIndex = getSlotIndex(tableSize, indexOrHash);
					 Slot prev = slotsLocalRef[slotIndex];
					 Slot slot = prev;
					 while (slot != null) {
						 if (slot.indexOrHash == indexOrHash && (slot.name == name || (name != null && name.equals(slot.name)))) {
							 break;
						 }
						 prev = slot;
						 slot = slot.next;
					 }
					 if (slot != null && (slot.getAttributes() & PERMANENT) == 0) {
						 count--;
						 if (prev == slot) {
							 slotsLocalRef[slotIndex] = slot.next;
						 }
						 else {
							 prev.next = slot.next;
						 }
						 slot.wasDeleted = (byte)1;
						 if (slot == lastAccess) {
							 lastAccess = REMOVED;
						 }
					 }
				 }
			 }
			 return null;
		 }
		 else {
			 throw Kit.codeBug();
		 }
	 }
	 private static int getSlotIndex(int tableSize, int indexOrHash) {
		 return (indexOrHash & 0x7fffffff) % tableSize;
	 }
	 private static void copyTable(Slot[] slots, Slot[] newSlots, int count) {
		 if (count == 0) throw Kit.codeBug();
		 int tableSize = newSlots.length;
		 int i = slots.length;
		 for (;
		;
		) {
			 --i;
			 Slot slot = slots[i];
			 while (slot != null) {
				 int insertPos = getSlotIndex(tableSize, slot.indexOrHash);
				 Slot next = slot.next;
				 addKnownAbsentSlot(newSlots, slot, insertPos);
				 slot.next = null;
				 slot = next;
				 if (--count == 0) return;
			 }
		 }
	 }
	 private static void addKnownAbsentSlot(Slot[] slots, Slot slot, int insertPos) {
		 if (slots[insertPos] == null) {
			 slots[insertPos] = slot;
		 }
		 else {
			 Slot prev = slots[insertPos];
			 while (prev.next != null) {
				 prev = prev.next;
			 }
			 prev.next = slot;
		 }
	 }
	 Object[] getIds(boolean getAll) {
		 Slot[] s = slots;
		 Object[] a = ScriptRuntime.emptyArgs;
		 if (s == null) return a;
		 int c = 0;
		 for (int i=0;
		 i < s.length;
		 i++) {
			 Slot slot = s[i];
			 while (slot != null) {
				 if (getAll || (slot.getAttributes() & DONTENUM) == 0) {
					 if (c == 0) a = new Object[s.length];
					 a[c++] = (slot.name != null ? (Object) slot.name : new Integer(slot.indexOrHash));
				 }
				 slot = slot.next;
			 }
		 }
		 if (c == a.length) return a;
		 Object[] result = new Object[c];
		 System.arraycopy(a, 0, result, 0, c);
		 return result;
	 }
	 private synchronized void writeObject(ObjectOutputStream out) throws IOException {
		 out.defaultWriteObject();
		 int objectsCount = count;
		 if (objectsCount < 0) {
			 objectsCount = ~objectsCount;
		 }
		 if (objectsCount == 0) {
			 out.writeInt(0);
		 }
		 else {
			 out.writeInt(slots.length);
			 for (int i = 0;
			 i < slots.length;
			 ++i) {
				 Slot slot = slots[i];
				 while (slot != null) {
					 out.writeObject(slot);
					 slot = slot.next;
					 if (--objectsCount == 0) return;
				 }
			 }
		 }
	 }
	 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		 in.defaultReadObject();
		 lastAccess = REMOVED;
		 int tableSize = in.readInt();
		 if (tableSize != 0) {
			 slots = new Slot[tableSize];
			 int objectsCount = count;
			 if (objectsCount < 0) {
				 objectsCount = ~objectsCount;
			 }
			 for (int i = 0;
			 i != objectsCount;
			 ++i) {
				 Slot slot = (Slot)in.readObject();
				 int slotIndex = getSlotIndex(tableSize, slot.indexOrHash);
				 addKnownAbsentSlot(slots, slot, slotIndex);
			 }
		 }
	 }
}",1,0,0,0
"protected void writeFolderId(Writer writer) throws IOException {
	 if (folderId != null) {
		 if (updates == null) {
			 writer.write(""<m:FolderIds>"");
		 }
		 folderId.write(writer);
		 if (updates == null) {
			 writer.write(""</m:FolderIds>"");
		 }
	 }
 }",0,0,0,0
"public void setMapOutputCompressorClass(Class codecClass) {
	 setCompressMapOutput(true);
	 setClass(""mapred.output.compression.codec"", codecClass, CompressionCodec.class);
 }",0,0,0,0
"class Block{
	 private static class FatBlock {
		 private static Block[] reduceToArray(ObjToIntMap map) {
			 Block[] result = null;
			 if (!map.isEmpty()) {
				 result = new Block[map.size()];
				 int i = 0;
				 ObjToIntMap.Iterator iter = map.newIterator();
				 for (iter.start();
				 !iter.done();
				 iter.next()) {
					 FatBlock fb = (FatBlock)(iter.getKey());
					 result[i++] = fb.realBlock;
				 }
			 }
			 return result;
		 }
		 void addSuccessor(FatBlock b) {
			 successors.put(b, 0);
		 }
		 void addPredecessor(FatBlock b) {
			 predecessors.put(b, 0);
		 }
		 Block[] getSuccessors() {
			 return reduceToArray(successors);
		 }
		 Block[] getPredecessors() {
			 return reduceToArray(predecessors);
		 }
		 private ObjToIntMap successors = new ObjToIntMap();
		 private ObjToIntMap predecessors = new ObjToIntMap();
		 Block realBlock;
	 }
	 Block(int startNodeIndex, int endNodeIndex) {
		 itsStartNodeIndex = startNodeIndex;
		 itsEndNodeIndex = endNodeIndex;
	 }
	 static void runFlowAnalyzes(OptFunctionNode fn, Node[] statementNodes) {
		 int paramCount = fn.fnode.getParamCount();
		 int varCount = fn.fnode.getParamAndVarCount();
		 int[] varTypes = new int[varCount];
		 for (int i = 0;
		 i != paramCount;
		 ++i) {
			 varTypes[i] = Optimizer.AnyType;
		 }
		 for (int i = paramCount;
		 i != varCount;
		 ++i) {
			 varTypes[i] = Optimizer.NoType;
		 }
		 Block[] theBlocks = buildBlocks(statementNodes);
		 if (DEBUG) {
			 ++debug_blockCount;
			 System.out.println(""-------------------""+fn.fnode.getFunctionName()+"" ""+debug_blockCount+""--------"");
			 System.out.println(toString(theBlocks, statementNodes));
		 }
		 reachingDefDataFlow(fn, statementNodes, theBlocks, varTypes);
		 typeFlow(fn, statementNodes, theBlocks, varTypes);
		 if (DEBUG) {
			 for (int i = 0;
			 i < theBlocks.length;
			 i++) {
				 System.out.println(""For block "" + theBlocks[i].itsBlockID);
				 theBlocks[i].printLiveOnEntrySet(fn);
			 }
			 System.out.println(""Variable Table, size = "" + varCount);
			 for (int i = 0;
			 i != varCount;
			 i++) {
				 System.out.println(""[""+i+""] type: ""+varTypes[i]);
			 }
		 }
		 for (int i = paramCount;
		 i != varCount;
		 i++) {
			 if (varTypes[i] == Optimizer.NumberType) {
				 fn.setIsNumberVar(i);
			 }
		 }
	 }
	 private static Block[] buildBlocks(Node[] statementNodes) {
		 Hashtable theTargetBlocks = new Hashtable();
		 ObjArray theBlocks = new ObjArray();
		 int beginNodeIndex = 0;
		 for (int i = 0;
		 i < statementNodes.length;
		 i++) {
			 switch (statementNodes[i].getType()) {
				 case Token.TARGET : {
					 if (i != beginNodeIndex) {
						 FatBlock fb = newFatBlock(beginNodeIndex, i - 1);
						 if (statementNodes[beginNodeIndex].getType() == Token.TARGET) theTargetBlocks.put(statementNodes[beginNodeIndex], fb);
						 theBlocks.add(fb);
						 beginNodeIndex = i;
					 }
				 }
				 break;
				 case Token.IFNE : case Token.IFEQ : case Token.GOTO : {
					 FatBlock fb = newFatBlock(beginNodeIndex, i);
					 if (statementNodes[beginNodeIndex].getType() == Token.TARGET) theTargetBlocks.put(statementNodes[beginNodeIndex], fb);
					 theBlocks.add(fb);
					 beginNodeIndex = i + 1;
				 }
				 break;
			 }
		 }
		 if (beginNodeIndex != statementNodes.length) {
			 FatBlock fb = newFatBlock(beginNodeIndex, statementNodes.length - 1);
			 if (statementNodes[beginNodeIndex].getType() == Token.TARGET) theTargetBlocks.put(statementNodes[beginNodeIndex], fb);
			 theBlocks.add(fb);
		 }
		 for (int i = 0;
		 i < theBlocks.size();
		 i++) {
			 FatBlock fb = (FatBlock)(theBlocks.get(i));
			 Node blockEndNode = statementNodes[fb.realBlock.itsEndNodeIndex];
			 int blockEndNodeType = blockEndNode.getType();
			 if ((blockEndNodeType != Token.GOTO) && (i < (theBlocks.size() - 1))) {
				 FatBlock fallThruTarget = (FatBlock)(theBlocks.get(i + 1));
				 fb.addSuccessor(fallThruTarget);
				 fallThruTarget.addPredecessor(fb);
			 }
			 if ( (blockEndNodeType == Token.IFNE) || (blockEndNodeType == Token.IFEQ) || (blockEndNodeType == Token.GOTO) ) {
				 Node target = ((Node.Jump)blockEndNode).target;
				 FatBlock branchTargetBlock = (FatBlock)(theTargetBlocks.get(target));
				 target.putProp(Node.TARGETBLOCK_PROP, branchTargetBlock.realBlock);
				 fb.addSuccessor(branchTargetBlock);
				 branchTargetBlock.addPredecessor(fb);
			 }
		 }
		 Block[] result = new Block[theBlocks.size()];
		 for (int i = 0;
		 i < theBlocks.size();
		 i++) {
			 FatBlock fb = (FatBlock)(theBlocks.get(i));
			 Block b = fb.realBlock;
			 b.itsSuccessors = fb.getSuccessors();
			 b.itsPredecessors = fb.getPredecessors();
			 b.itsBlockID = i;
			 result[i] = b;
		 }
		 return result;
	 }
	 private static FatBlock newFatBlock(int startNodeIndex, int endNodeIndex) {
		 FatBlock fb = new FatBlock();
		 fb.realBlock = new Block(startNodeIndex, endNodeIndex);
		 return fb;
	 }
	 private static String toString(Block[] blockList, Node[] statementNodes) {
		 if (!DEBUG) return null;
		 StringWriter sw = new StringWriter();
		 PrintWriter pw = new PrintWriter(sw);
		 pw.println(blockList.length + "" Blocks"");
		 for (int i = 0;
		 i < blockList.length;
		 i++) {
			 Block b = blockList[i];
			 pw.println(""#"" + b.itsBlockID);
			 pw.println(""from "" + b.itsStartNodeIndex + "" "" + statementNodes[b.itsStartNodeIndex].toString());
			 pw.println(""thru "" + b.itsEndNodeIndex + "" "" + statementNodes[b.itsEndNodeIndex].toString());
			 pw.print(""Predecessors "");
			 if (b.itsPredecessors != null) {
				 for (int j = 0;
				 j < b.itsPredecessors.length;
				 j++) pw.print(b.itsPredecessors[j].itsBlockID + "" "");
				 pw.println();
			 }
			 else pw.println(""none"");
			 pw.print(""Successors "");
			 if (b.itsSuccessors != null) {
				 for (int j = 0;
				 j < b.itsSuccessors.length;
				 j++) pw.print(b.itsSuccessors[j].itsBlockID + "" "");
				 pw.println();
			 }
			 else pw.println(""none"");
		 }
		 return sw.toString();
	 }
	 private static void reachingDefDataFlow(OptFunctionNode fn, Node[] statementNodes, Block theBlocks[], int[] varTypes) {
		 for (int i = 0;
		 i < theBlocks.length;
		 i++) {
			 theBlocks[i].initLiveOnEntrySets(fn, statementNodes);
		 }
		 boolean visit[] = new boolean[theBlocks.length];
		 boolean doneOnce[] = new boolean[theBlocks.length];
		 int vIndex = theBlocks.length - 1;
		 boolean needRescan = false;
		 visit[vIndex] = true;
		 while (true) {
			 if (visit[vIndex] || !doneOnce[vIndex]) {
				 doneOnce[vIndex] = true;
				 visit[vIndex] = false;
				 if (theBlocks[vIndex].doReachedUseDataFlow()) {
					 Block pred[] = theBlocks[vIndex].itsPredecessors;
					 if (pred != null) {
						 for (int i = 0;
						 i < pred.length;
						 i++) {
							 int index = pred[i].itsBlockID;
							 visit[index] = true;
							 needRescan |= (index > vIndex);
						 }
					 }
				 }
			 }
			 if (vIndex == 0) {
				 if (needRescan) {
					 vIndex = theBlocks.length - 1;
					 needRescan = false;
				 }
				 else break;
			 }
			 else vIndex--;
		 }
		 theBlocks[0].markAnyTypeVariables(varTypes);
	 }
	 private static void typeFlow(OptFunctionNode fn, Node[] statementNodes, Block theBlocks[], int[] varTypes) {
		 boolean visit[] = new boolean[theBlocks.length];
		 boolean doneOnce[] = new boolean[theBlocks.length];
		 int vIndex = 0;
		 boolean needRescan = false;
		 visit[vIndex] = true;
		 while (true) {
			 if (visit[vIndex] || !doneOnce[vIndex]) {
				 doneOnce[vIndex] = true;
				 visit[vIndex] = false;
				 if (theBlocks[vIndex].doTypeFlow(fn, statementNodes, varTypes)) {
					 Block succ[] = theBlocks[vIndex].itsSuccessors;
					 if (succ != null) {
						 for (int i = 0;
						 i < succ.length;
						 i++) {
							 int index = succ[i].itsBlockID;
							 visit[index] = true;
							 needRescan |= (index < vIndex);
						 }
					 }
				 }
			 }
			 if (vIndex == (theBlocks.length - 1)) {
				 if (needRescan) {
					 vIndex = 0;
					 needRescan = false;
				 }
				 else break;
			 }
			 else vIndex++;
		 }
	 }
	 private static boolean assignType(int[] varTypes, int index, int type) {
		 return type != (varTypes[index] |= type);
	 }
	 private void markAnyTypeVariables(int[] varTypes) {
		 for (int i = 0;
		 i != varTypes.length;
		 i++) {
			 if (itsLiveOnEntrySet.test(i)) {
				 assignType(varTypes, i, Optimizer.AnyType);
			 }
		 }
	 }
	 private void lookForVariableAccess(OptFunctionNode fn, Node n) {
		 switch (n.getType()) {
			 case Token.DEC : case Token.INC : {
				 Node child = n.getFirstChild();
				 if (child.getType() == Token.GETVAR) {
					 int varIndex = fn.getVarIndex(child);
					 if (!itsNotDefSet.test(varIndex)) itsUseBeforeDefSet.set(varIndex);
					 itsNotDefSet.set(varIndex);
				 }
			 }
			 break;
			 case Token.SETVAR : {
				 Node lhs = n.getFirstChild();
				 Node rhs = lhs.getNext();
				 lookForVariableAccess(fn, rhs);
				 itsNotDefSet.set(fn.getVarIndex(n));
			 }
			 break;
			 case Token.GETVAR : {
				 int varIndex = fn.getVarIndex(n);
				 if (!itsNotDefSet.test(varIndex)) itsUseBeforeDefSet.set(varIndex);
			 }
			 break;
			 default : Node child = n.getFirstChild();
			 while (child != null) {
				 lookForVariableAccess(fn, child);
				 child = child.getNext();
			 }
			 break;
		 }
	 }
	 private void initLiveOnEntrySets(OptFunctionNode fn, Node[] statementNodes) {
		 int listLength = fn.getVarCount();
		 itsUseBeforeDefSet = new DataFlowBitSet(listLength);
		 itsNotDefSet = new DataFlowBitSet(listLength);
		 itsLiveOnEntrySet = new DataFlowBitSet(listLength);
		 itsLiveOnExitSet = new DataFlowBitSet(listLength);
		 for (int i = itsStartNodeIndex;
		 i <= itsEndNodeIndex;
		 i++) {
			 Node n = statementNodes[i];
			 lookForVariableAccess(fn, n);
		 }
		 itsNotDefSet.not();
	 }
	 private boolean doReachedUseDataFlow() {
		 itsLiveOnExitSet.clear();
		 if (itsSuccessors != null) for (int i = 0;
		 i < itsSuccessors.length;
		 i++) itsLiveOnExitSet.or(itsSuccessors[i].itsLiveOnEntrySet);
		 return itsLiveOnEntrySet.df2(itsLiveOnExitSet, itsUseBeforeDefSet, itsNotDefSet);
	 }
	 private static int findExpressionType(OptFunctionNode fn, Node n, int[] varTypes) {
		 switch (n.getType()) {
			 case Token.NUMBER : return Optimizer.NumberType;
			 case Token.CALL : case Token.NEW : case Token.REF_CALL : return Optimizer.AnyType;
			 case Token.GETELEM : return Optimizer.AnyType;
			 case Token.GETVAR : return varTypes[fn.getVarIndex(n)];
			 case Token.INC : case Token.DEC : case Token.DIV: case Token.MOD: case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.LSH: case Token.RSH: case Token.URSH: case Token.SUB : return Optimizer.NumberType;
			 case Token.ADD : {
				 Node child = n.getFirstChild();
				 int lType = findExpressionType(fn, child, varTypes);
				 int rType = findExpressionType(fn, child.getNext(), varTypes);
				 return lType | rType;
			 }
		 }
		 Node child = n.getFirstChild();
		 if (child == null) {
			 return Optimizer.AnyType;
		 }
		 else {
			 int result = Optimizer.NoType;
			 while (child != null) {
				 result |= findExpressionType(fn, child, varTypes);
				 child = child.getNext();
			 }
			 return result;
		 }
	 }
	 private static boolean findDefPoints(OptFunctionNode fn, Node n, int[] varTypes) {
		 boolean result = false;
		 Node child = n.getFirstChild();
		 switch (n.getType()) {
			 default : while (child != null) {
				 result |= findDefPoints(fn, child, varTypes);
				 child = child.getNext();
			 }
			 break;
			 case Token.DEC : case Token.INC : if (child.getType() == Token.GETVAR) {
				 int i = fn.getVarIndex(child);
				 result |= assignType(varTypes, i, Optimizer.NumberType);
			 }
			 break;
			 case Token.SETPROP : case Token.SETPROP_OP : if (child.getType() == Token.GETVAR) {
				 int i = fn.getVarIndex(child);
				 assignType(varTypes, i, Optimizer.AnyType);
			 }
			 while (child != null) {
				 result |= findDefPoints(fn, child, varTypes);
				 child = child.getNext();
			 }
			 break;
			 case Token.SETVAR : {
				 Node rValue = child.getNext();
				 int theType = findExpressionType(fn, rValue, varTypes);
				 int i = fn.getVarIndex(n);
				 result |= assignType(varTypes, i, theType);
				 break;
			 }
		 }
		 return result;
	 }
	 private boolean doTypeFlow(OptFunctionNode fn, Node[] statementNodes, int[] varTypes) {
		 boolean changed = false;
		 for (int i = itsStartNodeIndex;
		 i <= itsEndNodeIndex;
		 i++) {
			 Node n = statementNodes[i];
			 if (n != null) changed |= findDefPoints(fn, n, varTypes);
		 }
		 return changed;
	 }
	 private boolean isLiveOnEntry(int index) {
		 return (itsLiveOnEntrySet != null) && (itsLiveOnEntrySet.test(index));
	 }
	 private void printLiveOnEntrySet(OptFunctionNode fn) {
		 if (DEBUG) {
			 for (int i = 0;
			 i < fn.getVarCount();
			 i++) {
				 String name = fn.fnode.getParamOrVarName(i);
				 if (itsUseBeforeDefSet.test(i)) System.out.println(name + "" is used before def'd"");
				 if (itsNotDefSet.test(i)) System.out.println(name + "" is not def'd"");
				 if (itsLiveOnEntrySet.test(i)) System.out.println(name + "" is live on entry"");
				 if (itsLiveOnExitSet.test(i)) System.out.println(name + "" is live on exit"");
			 }
		 }
	 }
	 private Block[] itsSuccessors;
	 private Block[] itsPredecessors;
	 private int itsStartNodeIndex;
	 private int itsEndNodeIndex;
	 private int itsBlockID;
	 private DataFlowBitSet itsLiveOnEntrySet;
	 private DataFlowBitSet itsLiveOnExitSet;
	 private DataFlowBitSet itsUseBeforeDefSet;
	 private DataFlowBitSet itsNotDefSet;
	 static final boolean DEBUG = false;
	 private static int debug_blockCount;
}",0,0,0,0
"public CFMetaData keyValidator(AbstractType<T> prop) {
	keyValidator = prop;
	 updateCfDef();
	 return this;
}",0,0,0,0
"public synchronized void setNotificationRegistration(final String token) {
	 ConnectedDevicesNotificationRegistrationManager registrationManager = mPlatform.getNotificationRegistrationManager();
	 ConnectedDevicesNotificationRegistration registration = new ConnectedDevicesNotificationRegistration();
	 registration.setType(ConnectedDevicesNotificationType.FCM);
	 registration.setToken(token);
	 registration.setAppId(Secrets.FCM_SENDER_ID);
	 registration.setAppDisplayName(""GraphNotificationsSample"");
	 Log.i(TAG, ""Completing the RomeNotificationReceiver operation with token: "" + token);
	 for (final Account account : mAccounts) {
		 registrationManager.registerForAccountAsync(account.getAccount(), registration) .whenCompleteAsync((Boolean success, Throwable throwable) -> {
			 if (throwable != null) {
				 Log.e(TAG, ""Exception encountered in registerForAccountAsync"", throwable);
			 }
			 else if (!success) {
				 Log.e(TAG, ""Failed to register account "" + account.getAccount().getId() + "" for cloud notifications!"");
			 }
			 else {
				 Log.i(TAG, ""Successfully registered account "" + account.getAccount().getId() + "" for cloud notifications"");
			 }
		 }
		);
	 }
	 RomeNotificationReceiver.setNotificationRegistration(registration);
	 for (Account account : mAccounts) {
		 if (account.getRegistrationState() == AccountRegistrationState.IN_APP_CACHE_AND_SDK_CACHE) {
			 account.registerAccountWithSdkAsync();
		 }
	 }
 }",0,0,1,0
"public static void transferSSTables(StreamOutSession session, Iterable<SSTableReader> sstables, Collection<Range<Token>> ranges, OperationType type) throws IOException {
	 List<PendingFile> pending = createPendingFiles(sstables, ranges, type);
	 session.addFilesToStream(pending);
	 session.begin();
 }",0,0,0,0
"public long getPendingTasks() {
	 return executor.getPendingTasks();
 }",0,0,0,0
"class ExceptionalRequestHandler implements HttpHandler {
	 private static final Logger LOG = Logger.getLogger(ExceptionalRequestHandler.class.getName());
	 private HttpHandler delegate;
	 private Config runtime;
	 private IScheduler scheduler;
	 ExceptionalRequestHandler(HttpHandler delegate, Config runtime, IScheduler scheduler) {
		 this.delegate = delegate;
		 this.runtime = runtime;
		 this.scheduler = scheduler;
	 }
	 public void handle(HttpExchange exchange) throws IOException {
		 try {
			 delegate.handle(exchange);
			 sendResponse(exchange, true);
		 }
		 catch (TerminateSchedulerException e) {
			 sendResponse(exchange, true);
			 LOG.info(""Request handler issuing a terminate request to scheduler"");
			 try {
				 scheduler.close();
			 }
			 finally {
				 Runtime.schedulerShutdown(runtime).terminate();
			 }
		 }
		 catch (Exception e) {
			 handleFailure(exchange, e);
		 }
	 }
	 private static void handleFailure(HttpExchange exchange, Exception e) {
		 LOG.log(Level.SEVERE, String.format(""Failed to handle %s request"", exchange.getRequestURI()), e);
		 sendResponse(exchange, false);
	 }
	 private static void sendResponse(HttpExchange exchange, boolean success) {
		 Scheduler.SchedulerResponse response = SchedulerUtils.constructSchedulerResponse(success);
		 NetworkUtils.sendHttpResponse(exchange, response.toByteArray());
	 }
}",0,0,0,0
"private String format(String s, Object[] arguments) {
	 if (arguments == null) {
		 return s;
	 }
	 int i = 0;
	 while (i < arguments.length) {
		 String delimiter = ""{
		"" + i + ""}
		"";
		 while (s.contains(delimiter)) {
			 s = s.replace(delimiter, String.valueOf(arguments[i]));
		 }
		 i++;
	 }
	 return s;
 }",0,0,1,0
"public static void m() {
	 C c = new C();
	 E1 e1 = new E1();
	 E2 e2 = new E2();
	 c.foo(e1,e2.getClass());
 }",0,0,1,0
"public class ExprList implements Iterable<Expr>{
	 private final List<Expr> expressions ;
	 public static ExprList copy(ExprList other) {
		 return new ExprList(other) ;
	 }
	 public static ExprList create(Collection<Expr> exprs) {
		 ExprList exprList = new ExprList() ;
		 exprs.forEach(exprList::add) ;
		 return exprList ;
	 }
	 public static final ExprList emptyList = new ExprList(Collections.emptyList()) ;
	 public ExprList() {
		 expressions = new ArrayList<>() ;
	 }
	 private ExprList(ExprList other) {
		 this() ;
		 expressions.addAll(other.expressions) ;
	 }
	 public ExprList(Expr expr) {
		 this() ;
		 expressions.add(expr) ;
	 }
	 public ExprList(List<Expr> x) {
		 expressions = x ;
	 }
	 public boolean isSatisfied(Binding binding, ExecutionContext execCxt) {
		 for (Expr expr : expressions) {
			 if ( !expr.isSatisfied(binding, execCxt) ) return false ;
		 }
		 return true ;
	 }
	 public Expr get(int idx) {
		 return expressions.get(idx) ;
	 }
	 public int size() {
		 return expressions.size() ;
	 }
	 public boolean isEmpty() {
		 return expressions.isEmpty() ;
	 }
	 public ExprList subList(int fromIdx, int toIdx) {
		 return new ExprList(expressions.subList(fromIdx, toIdx)) ;
	 }
	 public ExprList tail(int fromIdx) {
		 return subList(fromIdx, expressions.size()) ;
	 }
	 public Set<Var> getVarsMentioned() {
		 Set<Var> x = new HashSet<>() ;
		 varsMentioned(x) ;
		 return x ;
	 }
	 public void varsMentioned(Collection<Var> acc) {
		 for (Expr expr : expressions) ExprVars.varsMentioned(acc, expr);
	 }
	 public ExprList applyNodeTransform(NodeTransform transform) {
		 ExprList x = new ExprList() ;
		 for ( Expr e : expressions) x.add(e.applyNodeTransform(transform));
		 return x ;
	 }
	 public ExprList copySubstitute(Binding binding) {
		 ExprList x = new ExprList() ;
		 for (Expr expr : expressions ) {
			 expr = expr.copySubstitute(binding) ;
			 x.add(expr) ;
		 }
		 return x ;
	 }
	 public void addAll(ExprList exprs) {
		 expressions.addAll(exprs.getList()) ;
	 }
	 public void add(Expr expr) {
		 expressions.add(expr) ;
	 }
	 public List<Expr> getList() {
		 return Collections.unmodifiableList(expressions) ;
	 }
	 public List<Expr> getListRaw() {
		 return expressions ;
	 }
	 public Iterator<Expr> iterator() {
		 return expressions.iterator() ;
	 }
	 public void prepareExprs(Context context) {
		 ExprBuild build = new ExprBuild(context) ;
		 for (Expr expr : expressions) Walker.walk(expr, build) ;
	 }
	 public String toString() {
		 return expressions.toString() ;
	 }
	 public int hashCode() {
		 return expressions.hashCode() ;
	 }
	 public boolean equals(ExprList other, boolean bySyntax) {
		 if ( this == other ) return true ;
		 if (expressions.size() != other.expressions.size()) return false;
		 for ( int i = 0 ;
		 i < expressions.size() ;
		 i++ ) {
			 Expr e1 = expressions.get(i) ;
			 Expr e2 = other.expressions.get(i) ;
			 if ( ! e1.equals(e2, bySyntax) ) return false ;
		 }
		 return true ;
	 }
	 public boolean equals(Object other) {
		 if ( this == other ) return true ;
		 if ( ! ( other instanceof ExprList ) ) return false ;
		 ExprList exprs = (ExprList)other ;
		 return equals((ExprList)other, false) ;
	 }
	 public static ExprList splitConjunction(ExprList exprList1) {
		 ExprList exprList2 = new ExprList() ;
		 for (Expr expr : exprList1) split(exprList2, expr) ;
		 return exprList2 ;
	 }
	 private static ExprList splitConjunction(Expr expr) {
		 ExprList exprList = new ExprList() ;
		 split(exprList, expr) ;
		 return exprList ;
	 }
	 private static void split(ExprList exprList, Expr expr) {
		 while (expr instanceof E_LogicalAnd) {
			 E_LogicalAnd x = (E_LogicalAnd)expr ;
			 Expr left = x.getArg1() ;
			 Expr right = x.getArg2() ;
			 split(exprList, left) ;
			 expr = right ;
		 }
		 exprList.add(expr) ;
	 }
}",1,1,0,0
"public String exportSchemaToYAML() throws IOException {
	 return ssProxy.exportSchema();
 }",0,0,0,0
"public void addAnnotation(XYAnnotation annotation, Layer layer);",0,0,0,0
"private static class SortedNumericDocValuesSub extends DocIDMerger.Sub {
	 final SortedNumericDocValues values;
	 public SortedNumericDocValuesSub(MergeState.DocMap docMap, SortedNumericDocValues values) {
		 super(docMap);
		 this.values = values;
		 assert values.docID() == -1;
	 }
	 public int nextDoc() throws IOException {
		 return values.nextDoc();
	 }
 }",0,0,0,0
"public class ExcludingBounds<T extends RingPosition> extends AbstractBounds<T>{
	 public ExcludingBounds(T left, T right) {
		 this(left, right, StorageService.getPartitioner());
	 }
	 ExcludingBounds(T left, T right, IPartitioner partitioner) {
		 super(left, right, partitioner);
		 assert left.compareTo(right) < 0 || right.isMinimum(partitioner) : ""("" + left + "","" + right + "")"";
	 }
	 public boolean contains(T position) {
		 return Range.contains(left, right, position) && !right.equals(position);
	 }
	 public Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position) {
		 assert contains(position) || left.equals(position);
		 if (left.equals(position)) return null;
		 AbstractBounds<T> lb = new Range<T>(left, position, partitioner);
		 AbstractBounds<T> rb = new ExcludingBounds<T>(position, right, partitioner);
		 return new Pair<AbstractBounds<T>, AbstractBounds<T>>(lb, rb);
	 }
	 public List<? extends AbstractBounds<T>> unwrap() {
		 return Collections.<AbstractBounds<T>>singletonList(this);
	 }
	 public boolean equals(Object o) {
		 if (!(o instanceof ExcludingBounds)) return false;
		 ExcludingBounds<T> rhs = (ExcludingBounds<T>)o;
		 return left.equals(rhs.left) && right.equals(rhs.right);
	 }
	 public String toString() {
		 return ""("" + left + "","" + right + "")"";
	 }
	 private static ExcludingBounds<RowPosition> makeRowBounds(Token left, Token right, IPartitioner partitioner) {
		 return new ExcludingBounds<RowPosition>(left.maxKeyBound(partitioner), right.minKeyBound(partitioner), partitioner);
	 }
	 public AbstractBounds<RowPosition> toRowBounds() {
		 return (left instanceof Token) ? makeRowBounds((Token)left, (Token)right, partitioner) : (ExcludingBounds<RowPosition>)this;
	 }
	 public AbstractBounds<Token> toTokenBounds() {
		 return (left instanceof RowPosition) ? new ExcludingBounds<Token>(((RowPosition)left).getToken(), ((RowPosition)right).getToken(), partitioner) : (ExcludingBounds<Token>)this;
	 }
}",0,0,0,0
"class CssLicenseHeaderHandler extends AbstractLicenseHeaderHandler{
	public CssLicenseHeaderHandler(String[] ignoreFiles){
		super(ignoreFiles);
	}
	protected String getLicenseHeaderFilename(){
		return ""cssLicense.txt"";
	}
	public boolean checkLicenseHeader(File file){
		Revision revision = null;
		try{
			String header = extractLicenseHeader(file, 0, 16);
			revision = Diff.diff(getLicenseHeader().split(LINE_ENDING), header.split(LINE_ENDING));
		}
		catch (Exception e){
			Assert.fail(e.getMessage());
		}
		return revision.size() == 0;
	}
	public String[] getSuffixes(){
		return new String[] {
		 ""css"" }
		;
	}
	public boolean addLicenseHeader(File file){
		prependLicenseHeader(file);
		return true;
	}
}",0,0,0,0
"protected int getLabelID(View v) throws BuildException {
	 if (null != this.label) {
		 findLabel(v);
		 return this.labelInUse.getID();
	 }
	 return -1;
 }",0,0,0,0
"public void read(org.apache.thrift.protocol.TProtocol prot, getNamespaceIteratorSetting_result struct) throws org.apache.thrift.TException {
	 org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
	 java.util.BitSet incoming = iprot.readBitSet(4);
	 if (incoming.get(0)) {
		 struct.success = new IteratorSetting();
		 struct.success.read(iprot);
		 struct.setSuccessIsSet(true);
	 }
	 if (incoming.get(1)) {
		 struct.ouch1 = new AccumuloException();
		 struct.ouch1.read(iprot);
		 struct.setOuch1IsSet(true);
	 }
	 if (incoming.get(2)) {
		 struct.ouch2 = new AccumuloSecurityException();
		 struct.ouch2.read(iprot);
		 struct.setOuch2IsSet(true);
	 }
	 if (incoming.get(3)) {
		 struct.ouch3 = new NamespaceNotFoundException();
		 struct.ouch3.read(iprot);
		 struct.setOuch3IsSet(true);
	 }
 }",0,0,1,0
"public void addUptodate(UpToDate u) {
	 conditions.addElement(u);
 }",0,0,0,0
"public class CountTrigger implements Trigger {
	private final int count;
	private final long period;
	private final TimeUnit timeUnit;
	private volatile long initialDelay = 0;
	private volatile boolean fixedRate = false;
	private volatile int counter = 0;
	public CountTrigger(long period) {
		this(1, period, null);
	}
	public CountTrigger(int count, long period, TimeUnit timeUnit) {
		this(count, period, 0, timeUnit);
	}
	public CountTrigger(int count, long period, long initialDelay, TimeUnit timeUnit) {
		Assert.isTrue(period >= 0, ""period must not be negative"");
		Assert.isTrue(count >= 0, ""count must not be negative"");
		this.timeUnit = (timeUnit != null ? timeUnit : TimeUnit.MILLISECONDS);
		this.period = this.timeUnit.toMillis(period);
		this.count = count;
		setInitialDelay(initialDelay);
	}
	public void setInitialDelay(long initialDelay) {
		this.initialDelay = this.timeUnit.toMillis(initialDelay);
	}
	public void setFixedRate(boolean fixedRate) {
		this.fixedRate = fixedRate;
	}
	public Date nextExecutionTime(TriggerContext triggerContext) {
		if (count > 0) {
			if (++counter > count) {
				return null;
			}
		}
		if (triggerContext.lastScheduledExecutionTime() == null) {
			return new Date(System.currentTimeMillis() + this.initialDelay);
		}
		else if (this.fixedRate) {
			return new Date(triggerContext.lastScheduledExecutionTime().getTime() + this.period);
		}
		return new Date(triggerContext.lastCompletionTime().getTime() + this.period);
	}
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + count;
		result = prime * result + (fixedRate ? 1231 : 1237);
		result = prime * result + (int) (initialDelay ^ (initialDelay >>> 32));
		result = prime * result + (int) (period ^ (period >>> 32));
		return result;
	}
	public boolean equals(Object obj) {
		if (this == obj)return true;
		if (obj == null)return false;
		if (getClass() != obj.getClass())return false;
		CountTrigger other = (CountTrigger) obj;
		if (count != other.count)return false;
		if (fixedRate != other.fixedRate)return false;
		if (initialDelay != other.initialDelay)return false;
		if (period != other.period)return false;
		return true;
	}
}",0,0,0,0
"public void update(State state, long stamp) {
	 this.state = state;
	 this.stamp = stamp;
 }",0,0,0,0
"public void execute() throws BuildException {
	 checkTaskName();
	 Vector packagesToDoc = new Vector();
	 Path sourceDirs = new Path(getProject());
	 checkPackageAndSourcePath();
	 if (sourcePath != null) {
		 sourceDirs.addExisting(sourcePath);
	 }
	 parsePackages(packagesToDoc, sourceDirs);
	 checkPackages(packagesToDoc, sourceDirs);
	 Vector sourceFilesToDoc = (Vector) sourceFiles.clone();
	 addSourceFiles(sourceFilesToDoc);
	 checkPackagesToDoc(packagesToDoc, sourceFilesToDoc);
	 log(""Generating Javadoc"", Project.MSG_INFO);
	 Commandline toExecute = (Commandline) cmd.clone();
	 if (executable != null) {
		 toExecute.setExecutable(executable);
	 }
	 else {
		 toExecute.setExecutable(JavaEnvUtils.getJdkExecutable(""javadoc""));
	 }
	 generalJavadocArguments(toExecute);
	 doSourcePath(toExecute, sourceDirs);
	 doDoclet(toExecute);
	 doBootPath(toExecute);
	 doLinks(toExecute);
	 doGroup(toExecute);
	 doGroups(toExecute);
	 if (JAVADOC_4 || executable != null) {
		 doJava14(toExecute);
		 if (breakiterator && (doclet == null || JAVADOC_5)) {
			 toExecute.createArgument().setValue(""-breakiterator"");
		 }
	 }
	 else {
		 doNotJava14();
	 }
	 if (!JAVADOC_4 || executable != null) {
		 if (old) {
			 toExecute.createArgument().setValue(""-1.1"");
		 }
	 }
	 else {
		 if (old) {
			 log(""Javadoc 1.4 doesn't support the -1.1 switch anymore"", Project.MSG_WARN);
		 }
	 }
	 if (useExternalFile && JAVADOC_4) {
		 writeExternalArgs(toExecute);
	 }
	 File tmpList = null;
	 PrintWriter srcListWriter = null;
	 try {
		 if (useExternalFile) {
			 tmpList = FILE_UTILS.createTempFile(""javadoc"", """", null, true, true);
			 toExecute.createArgument() .setValue(""@"" + tmpList.getAbsolutePath());
			 srcListWriter = new PrintWriter( new FileWriter(tmpList.getAbsolutePath(), true));
		 }
		 doSourceAndPackageNames( toExecute, packagesToDoc, sourceFilesToDoc, useExternalFile, tmpList, srcListWriter);
	 }
	 catch (IOException e) {
		 tmpList.delete();
		 throw new BuildException(""Error creating temporary file"", e, getLocation());
	 }
	 finally {
		 if (srcListWriter != null) {
			 srcListWriter.close();
		 }
	 }
	 if (packageList != null) {
		 toExecute.createArgument().setValue(""@"" + packageList);
	 }
	 log(toExecute.describeCommand(), Project.MSG_VERBOSE);
	 log(""Javadoc execution"", Project.MSG_INFO);
	 JavadocOutputStream out = new JavadocOutputStream(Project.MSG_INFO);
	 JavadocOutputStream err = new JavadocOutputStream(Project.MSG_WARN);
	 Execute exe = new Execute(new PumpStreamHandler(out, err));
	 exe.setAntRun(getProject());
	 exe.setWorkingDirectory(null);
	 try {
		 exe.setCommandline(toExecute.getCommandline());
		 int ret = exe.execute();
		 if (ret != 0 && failOnError) {
			 throw new BuildException(""Javadoc returned "" + ret, getLocation());
		 }
	 }
	 catch (IOException e) {
		 throw new BuildException(""Javadoc failed: "" + e, e, getLocation());
	 }
	 finally {
		 if (tmpList != null) {
			 tmpList.delete();
			 tmpList = null;
		 }
		 out.logFlush();
		 err.logFlush();
		 try {
			 out.close();
			 err.close();
		 }
		 catch (IOException e) {
		 }
	 }
 }",0,0,1,0
"protected void logExcludes() {
	 if (DEFAULT_EXCLUDESETTING != this.excludes) {
		 log("" Excludes specified: "" + this.excludes);
	 }
 }",0,0,0,0
"public void addFileset(final FileSet fileSet) {
	 extensionsFilesets.add(fileSet);
 }",0,0,0,0
"public class SetOrderAttributesResponse {
	 protected SetOrderAttributesResult setOrderAttributesResult;
	 protected ResponseMetadata responseMetadata;
	 public SetOrderAttributesResponse() {
		 super();
	 }
	 public SetOrderAttributesResult getSetOrderAttributesResult() {
		 return setOrderAttributesResult;
	 }
	 public ResponseMetadata getResponseMetadata() {
		 return responseMetadata;
	 }
}",0,1,0,0
"private void doRun(Map<Method, CEntryPointData> entryPoints, Method mainEntryPoint, JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k, SubstitutionProcessor harnessSubstitutions, ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {
	 List<HostedMethod> hostedEntryPoints = new ArrayList<>();
	 OptionValues options = HostedOptionValues.singleton();
	 SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();
	 try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {
		 setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);
		 boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);
		 if (returnAfterAnalysis) {
			 return;
		 }
		 NativeImageHeap heap;
		 HostedMethod mainEntryPointHostedStub;
		 HostedMetaAccess hMetaAccess;
		 SharedRuntimeConfigurationBuilder runtime;
		 try (StopTimer t = new Timer(imageName, ""universe"").start()) {
			 hUniverse = new HostedUniverse(bigbang);
			 hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());
			 new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse), bigbang.getUnsupportedFeatures()).build(debug);
			 runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();
			 registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse, hMetaAccess, hUniverse, nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()), bigbang.getHostVM().getClassInitializationSupport());
			 if (NativeImageOptions.PrintUniverse.getValue()) {
				 printTypes();
			 }
			 for (AnalysisMethod m : aUniverse.getMethods()) {
				 if (m.isEntryPoint()) {
					 HostedMethod found = hUniverse.lookup(m);
					 assert found != null;
					 hostedEntryPoints.add(found);
				 }
			 }
			 if (mainEntryPoint != null) {
				 AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);
				 mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);
				 assert hostedEntryPoints.contains(mainEntryPointHostedStub);
			 }
			 else {
				 mainEntryPointHostedStub = null;
			 }
			 if (hostedEntryPoints.size() == 0) {
				 throw UserError.abort(""Warning: no entry points found, i.e., no method annotated with @"" + CEntryPoint.class.getSimpleName());
			 }
			 heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);
			 BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
			 featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));
			 bigbang.getUnsupportedFeatures().report(bigbang);
		 }
		 catch (UnsupportedFeatureException ufe) {
			 throw UserError.abort(ufe.getMessage());
		 }
		 recordMethodsWithStackValues();
		 recordRestrictHeapAccessCallees(aUniverse.getMethods());
		 bigbang.cleanupAfterAnalysis();
		 NativeImageCodeCache codeCache;
		 CompileQueue compileQueue;
		 try (StopTimer t = new Timer(imageName, ""compile"").start()) {
			 compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(), compilationExecutor);
			 compileQueue.finish(debug);
			 hUniverse.getMethods().forEach(HostedMethod::clear);
			 codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);
			 codeCache.layoutConstants();
			 codeCache.layoutMethods(debug, imageName);
			 AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
			 featureHandler.forEachFeature(feature -> feature.afterCompilation(config));
		 }
		 try (Indent indent = debug.logAndIndent(""create native image"")) {
			 try (DebugContext.Scope buildScope = debug.scope(""CreateBootImage"")) {
				 try (StopTimer t = new Timer(imageName, ""image"").start()) {
					 heap.addInitialObjects();
					 codeCache.addConstantsToHeap();
					 heap.addTrailingObjects();
					 AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);
					 featureHandler.forEachFeature(feature -> feature.afterHeapLayout(config));
					 this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());
					 image.build(debug);
					 if (NativeImageOptions.PrintUniverse.getValue()) {
						 codeCache.printCompilationResults();
					 }
				 }
			 }
		 }
		 BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image, runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);
		 featureHandler.forEachFeature(feature -> feature.beforeImageWrite(beforeConfig));
		 try (StopTimer t = new Timer(imageName, ""write"").start()) {
			 Path tmpDir = tempDirectory();
			 Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();
			 AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);
			 featureHandler.forEachFeature(feature -> feature.afterImageWrite(afterConfig));
		 }
	 }
 }",0,0,1,0
"protected float removeInstanceTime(InstanceTime time, boolean isBegin) {
	 hasPropagated = true;
	 List instanceTimes = isBegin ? beginInstanceTimes : endInstanceTimes;
	 int index = Collections.binarySearch(instanceTimes, time);
	 for (int i = index;
	 i >= 0;
	 i--) {
		 InstanceTime it = (InstanceTime) instanceTimes.get(i);
		 if (it == time) {
			 instanceTimes.remove(i);
			 break;
		 }
		 if (it.compareTo(time) != 0) {
			 break;
		 }
	 }
	 int len = instanceTimes.size();
	 for (int i = index + 1;
	 i < len;
	 i++) {
		 InstanceTime it = (InstanceTime) instanceTimes.get(i);
		 if (it == time) {
			 instanceTimes.remove(i);
			 break;
		 }
		 if (it.compareTo(time) != 0) {
			 break;
		 }
	 }
	 shouldUpdateCurrentInterval = true;
	 float ret;
	 if (root.isSampling() && !isSampling) {
		 ret = sampleAt(root.getCurrentTime(), root.isHyperlinking());
	 }
	 else {
		 ret = Float.POSITIVE_INFINITY;
	 }
	 hasPropagated = false;
	 root.currentIntervalWillUpdate();
	 return ret;
 }",0,0,1,0
"protected String urlDecodePathComponent(String value){
	String component = super.urlDecodePathComponent(value);
	if (component != null && component.contains(""_-"")){
		component = decodeDot(component);
	}
	return component;
}",0,0,0,0
"public void addConfiguredPatternset(PatternSet p) {
	 if (isReference()) {
		 throw noChildrenAllowed();
	 }
	 String[] nestedIncludes = p.getIncludePatterns(getProject());
	 String[] nestedExcludes = p.getExcludePatterns(getProject());
	 if (nestedIncludes != null) {
		 for (int i = 0;
		 i < nestedIncludes.length;
		 i++) {
			 createInclude().setName(nestedIncludes[i]);
		 }
	 }
	 if (nestedExcludes != null) {
		 for (int i = 0;
		 i < nestedExcludes.length;
		 i++) {
			 createExclude().setName(nestedExcludes[i]);
		 }
	 }
 }",0,0,0,0
"public class JFloat extends JType {
	 public JFloat() {
		 super(""float"", ""float"", ""Float"", ""Float"", ""toFloat"");
	 }
	 public String getSignature() {
		 return ""f"";
	 }
	 public String genJavaHashCode(String fname) {
		 return "" ret = Float.floatToIntBits(""+fname+"");
		\n"";
	 }
}",0,0,0,0
"public interface Range<T extends Comparable<?>, S> extends Iterable<T> {
	 BoundType DEFAULT_LEFT_BOUND_TYPE = BoundType.CLOSED;
	 BoundType DEFAULT_RIGHT_BOUND_TYPE = BoundType.OPEN;
	 Endpoint<T> getLeftEndpoint();
	 Endpoint<T> getRightEndpoint();
	 S getStep();
	 boolean isEmpty();
	 boolean contains(T obj);
	 boolean containsAll(Collection<T> col);
}",0,0,0,0
"public class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {
	 protected final HotSpotGraalRuntimeProvider runtime;
	 protected final HotSpotRegistersProvider registers;
	 protected final HotSpotConstantReflectionProvider constantReflection;
	 protected InstanceOfSnippets.Templates instanceofSnippets;
	 protected NewObjectSnippets.Templates newObjectSnippets;
	 protected MonitorSnippets.Templates monitorSnippets;
	 protected WriteBarrierSnippets.Templates writeBarrierSnippets;
	 protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
	 protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;
	 protected AssertionSnippets.Templates assertionSnippets;
	 protected ArrayCopySnippets.Templates arraycopySnippets;
	 protected StringToBytesSnippets.Templates stringToBytesSnippets;
	 protected HashCodeSnippets.Templates hashCodeSnippets;
	 protected ResolveConstantSnippets.Templates resolveConstantSnippets;
	 protected ProfileSnippets.Templates profileSnippets;
	 protected ObjectCloneSnippets.Templates objectCloneSnippets;
	 protected ForeignCallSnippets.Templates foreignCallSnippets;
	 public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers, HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {
		 super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);
		 this.runtime = runtime;
		 this.registers = registers;
		 this.constantReflection = constantReflection;
	 }
	 public void initialize(OptionValues options, Iterable<DebugHandlersFactory> factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
		 super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
		 assert target == providers.getCodeCache().getTarget();
		 instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
		 newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);
		 monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
		 writeBarrierSnippets = new WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
		 exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
		 unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);
		 assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
		 arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
		 stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
		 hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
		 resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
		 if (!JavaVersionUtil.Java8OrEarlier) {
			 profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);
		 }
		 objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
		 foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
	 }
	 public MonitorSnippets.Templates getMonitorSnippets() {
		 return monitorSnippets;
	 }
	 public void lower(Node n, LoweringTool tool) {
		 StructuredGraph graph = (StructuredGraph) n.graph();
		 try (DebugCloseable context = n.withNodeSourcePosition()) {
			 if (n instanceof Invoke) {
				 lowerInvoke((Invoke) n, tool, graph);
			 }
			 else if (n instanceof LoadMethodNode) {
				 lowerLoadMethodNode((LoadMethodNode) n);
			 }
			 else if (n instanceof GetClassNode) {
				 lowerGetClassNode((GetClassNode) n, tool, graph);
			 }
			 else if (n instanceof StoreHubNode) {
				 lowerStoreHubNode((StoreHubNode) n, graph);
			 }
			 else if (n instanceof OSRStartNode) {
				 lowerOSRStartNode((OSRStartNode) n);
			 }
			 else if (n instanceof BytecodeExceptionNode) {
				 lowerBytecodeExceptionNode((BytecodeExceptionNode) n);
			 }
			 else if (n instanceof InstanceOfNode) {
				 InstanceOfNode instanceOfNode = (InstanceOfNode) n;
				 if (graph.getGuardsStage().areDeoptsFixed()) {
					 instanceofSnippets.lower(instanceOfNode, tool);
				 }
				 else {
					 if (instanceOfNode.allowsNull()) {
						 ValueNode object = instanceOfNode.getValue();
						 LogicNode newTypeCheck = graph.addOrUniqueWithInputs(InstanceOfNode.create(instanceOfNode.type(), object, instanceOfNode.profile(), instanceOfNode.getAnchor()));
						 LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
						 instanceOfNode.replaceAndDelete(newNode);
					 }
				 }
			 }
			 else if (n instanceof InstanceOfDynamicNode) {
				 InstanceOfDynamicNode instanceOfDynamicNode = (InstanceOfDynamicNode) n;
				 if (graph.getGuardsStage().areDeoptsFixed()) {
					 instanceofSnippets.lower(instanceOfDynamicNode, tool);
				 }
				 else {
					 ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();
					 if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {
						 ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));
						 instanceOfDynamicNode.setMirror(classGetHub);
					 }
					 if (instanceOfDynamicNode.allowsNull()) {
						 ValueNode object = instanceOfDynamicNode.getObject();
						 LogicNode newTypeCheck = graph.addOrUniqueWithInputs( InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));
						 LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
						 instanceOfDynamicNode.replaceAndDelete(newNode);
					 }
				 }
			 }
			 else if (n instanceof ClassIsAssignableFromNode) {
				 if (graph.getGuardsStage().areDeoptsFixed()) {
					 instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);
				 }
			 }
			 else if (n instanceof NewInstanceNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 newObjectSnippets.lower((NewInstanceNode) n, registers, tool);
				 }
			 }
			 else if (n instanceof DynamicNewInstanceNode) {
				 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;
				 if (newInstanceNode.getClassClass() == null) {
					 JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));
					 ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);
					 newInstanceNode.setClassClass(classClass);
				 }
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 newObjectSnippets.lower(newInstanceNode, registers, tool);
				 }
			 }
			 else if (n instanceof NewArrayNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 newObjectSnippets.lower((NewArrayNode) n, registers, tool);
				 }
			 }
			 else if (n instanceof DynamicNewArrayNode) {
				 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;
				 if (dynamicNewArrayNode.getVoidClass() == null) {
					 JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));
					 ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
					 dynamicNewArrayNode.setVoidClass(voidClass);
				 }
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);
				 }
			 }
			 else if (n instanceof VerifyHeapNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);
				 }
			 }
			 else if (n instanceof RawMonitorEnterNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
				 }
			 }
			 else if (n instanceof MonitorExitNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 monitorSnippets.lower((MonitorExitNode) n, registers, tool);
				 }
			 }
			 else if (n instanceof ArrayCopyNode) {
				 arraycopySnippets.lower((ArrayCopyNode) n, tool);
			 }
			 else if (n instanceof ArrayCopyWithSlowPathNode) {
				 arraycopySnippets.lower((ArrayCopyWithSlowPathNode) n, tool);
			 }
			 else if (n instanceof G1PreWriteBarrier) {
				 writeBarrierSnippets.lower((G1PreWriteBarrier) n, registers, tool);
			 }
			 else if (n instanceof G1PostWriteBarrier) {
				 writeBarrierSnippets.lower((G1PostWriteBarrier) n, registers, tool);
			 }
			 else if (n instanceof G1ReferentFieldReadBarrier) {
				 writeBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, registers, tool);
			 }
			 else if (n instanceof SerialWriteBarrier) {
				 writeBarrierSnippets.lower((SerialWriteBarrier) n, tool);
			 }
			 else if (n instanceof SerialArrayRangeWriteBarrier) {
				 writeBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);
			 }
			 else if (n instanceof G1ArrayRangePreWriteBarrier) {
				 writeBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, registers, tool);
			 }
			 else if (n instanceof G1ArrayRangePostWriteBarrier) {
				 writeBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, registers, tool);
			 }
			 else if (n instanceof NewMultiArrayNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 newObjectSnippets.lower((NewMultiArrayNode) n, tool);
				 }
			 }
			 else if (n instanceof LoadExceptionObjectNode) {
				 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
			 }
			 else if (n instanceof AssertionNode) {
				 assertionSnippets.lower((AssertionNode) n, tool);
			 }
			 else if (n instanceof StringToBytesNode) {
				 if (graph.getGuardsStage().areDeoptsFixed()) {
					 stringToBytesSnippets.lower((StringToBytesNode) n, tool);
				 }
			 }
			 else if (n instanceof IntegerDivRemNode) {
			 }
			 else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
			 }
			 else if (n instanceof ClassGetHubNode) {
				 lowerClassGetHubNode((ClassGetHubNode) n, tool);
			 }
			 else if (n instanceof HubGetClassNode) {
				 lowerHubGetClassNode((HubGetClassNode) n, tool);
			 }
			 else if (n instanceof KlassLayoutHelperNode) {
				 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);
			 }
			 else if (n instanceof ComputeObjectAddressNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 lowerComputeObjectAddressNode((ComputeObjectAddressNode) n);
				 }
			 }
			 else if (n instanceof IdentityHashCodeNode) {
				 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
			 }
			 else if (n instanceof ResolveDynamicConstantNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
				 }
			 }
			 else if (n instanceof ResolveConstantNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
				 }
			 }
			 else if (n instanceof ResolveMethodAndLoadCountersNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
				 }
			 }
			 else if (n instanceof InitializeKlassNode) {
				 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
					 resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
				 }
			 }
			 else if (n instanceof ProfileNode) {
				 profileSnippets.lower((ProfileNode) n, tool);
			 }
			 else {
				 super.lower(n, tool);
			 }
		 }
	 }
	 private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
		 for (Node use : n.usages().snapshot()) {
			 if (use instanceof FixedNode) {
				 FixedNode fixed = (FixedNode) use;
				 StructuredGraph graph = n.graph();
				 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));
				 graph.addBeforeFixed(fixed, address);
				 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));
				 use.replaceFirstInput(n, add);
			 }
			 else {
				 throw GraalError.shouldNotReachHere(""Unexpected floating use of ComputeObjectAddressNode "" + n);
			 }
		 }
		 GraphUtil.unlinkFixedNode(n);
		 n.safeDelete();
	 }
	 private void lowerKlassLayoutHelperNode(KlassLayoutHelperNode n, LoweringTool tool) {
		 if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
			 return;
		 }
		 StructuredGraph graph = n.graph();
		 assert !n.getHub().isConstant();
		 AddressNode address = createOffsetAddress(graph, n.getHub(), runtime.getVMConfig().klassLayoutHelperOffset);
		 n.replaceAtUsagesAndDelete(graph.unique(new FloatingReadNode(address, KLASS_LAYOUT_HELPER_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE)));
	 }
	 private void lowerHubGetClassNode(HubGetClassNode n, LoweringTool tool) {
		 if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
			 return;
		 }
		 ValueNode hub = n.getHub();
		 GraalHotSpotVMConfig vmConfig = runtime.getVMConfig();
		 StructuredGraph graph = n.graph();
		 assert !hub.isConstant() || GraalOptions.ImmutableCode.getValue(graph.getOptions());
		 AddressNode mirrorAddress = createOffsetAddress(graph, hub, vmConfig.classMirrorOffset);
		 FloatingReadNode read = graph.unique( new FloatingReadNode(mirrorAddress, CLASS_MIRROR_LOCATION, null, vmConfig.classMirrorIsHandle ? StampFactory.forKind(target.wordJavaKind) : n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
		 if (vmConfig.classMirrorIsHandle) {
			 AddressNode address = createOffsetAddress(graph, read, 0);
			 read = graph.unique(new FloatingReadNode(address, CLASS_MIRROR_HANDLE_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
		 }
		 n.replaceAtUsagesAndDelete(read);
	 }
	 private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {
		 if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
			 return;
		 }
		 StructuredGraph graph = n.graph();
		 assert !n.getValue().isConstant();
		 AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);
		 FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
		 n.replaceAtUsagesAndDelete(read);
	 }
	 private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {
		 if (invoke.callTarget() instanceof MethodCallTargetNode) {
			 MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
			 NodeInputList<ValueNode> parameters = callTarget.arguments();
			 ValueNode receiver = parameters.size() <= 0 ? null : parameters.get(0);
			 if (!callTarget.isStatic() && receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp && !StampTool.isPointerNonNull(receiver)) {
				 ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);
				 parameters.set(0, nonNullReceiver);
				 receiver = nonNullReceiver;
			 }
			 JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());
			 LoweredCallTargetNode loweredCallTarget = null;
			 OptionValues options = graph.getOptions();
			 if (InlineVTableStubs.getValue(options) && callTarget.invokeKind().isIndirect() && (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {
				 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
				 ResolvedJavaType receiverType = invoke.getReceiverType();
				 if (hsMethod.isInVirtualMethodTable(receiverType)) {
					 JavaKind wordKind = runtime.getTarget().wordJavaKind;
					 ValueNode hub = createReadHub(graph, receiver, tool);
					 ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);
					 int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;
					 AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);
					 ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));
					 loweredCallTarget = graph.add(new HotSpotIndirectCallTargetNode(metaspaceMethod, compiledEntry, parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(), signature, callTarget.targetMethod(), HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));
					 graph.addBeforeFixed(invoke.asNode(), metaspaceMethod);
					 graph.addAfterFixed(metaspaceMethod, compiledEntry);
				 }
			 }
			 if (loweredCallTarget == null) {
				 loweredCallTarget = graph.add(new HotSpotDirectCallTargetNode(parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(), signature, callTarget.targetMethod(), HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));
			 }
			 callTarget.replaceAndDelete(loweredCallTarget);
		 }
	 }
	 private CompressEncoding getOopEncoding() {
		 return runtime.getVMConfig().getOopEncoding();
	 }
	 protected Stamp loadCompressedStamp(ObjectStamp stamp) {
		 return HotSpotNarrowOopStamp.compressed(stamp, getOopEncoding());
	 }
	 protected ValueNode newCompressionNode(CompressionOp op, ValueNode value) {
		 return new HotSpotCompressionNode(op, value, getOopEncoding());
	 }
	 public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {
		 HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;
		 JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());
		 return ConstantNode.forConstant(base, metaAccess, graph);
	 }
	 protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {
		 AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);
		 return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));
	 }
	 protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
		 StructuredGraph graph = load.graph();
		 if (!(load instanceof GuardedUnsafeLoadNode) && !graph.getGuardsStage().allowsFloatingGuards() && addReadBarrier(load)) {
			 unsafeLoadSnippets.lower(load, tool);
		 }
		 else {
			 super.lowerUnsafeLoadNode(load, tool);
		 }
	 }
	 private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {
		 StructuredGraph graph = loadMethodNode.graph();
		 HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();
		 ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());
		 graph.replaceFixed(loadMethodNode, metaspaceMethod);
	 }
	 private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {
		 StampProvider stampProvider = tool.getStampProvider();
		 LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));
		 HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));
		 getClass.replaceAtUsagesAndDelete(hubGetClass);
		 hub.lower(tool);
		 hubGetClass.lower(tool);
	 }
	 private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {
		 WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());
		 graph.replaceFixed(storeHub, hub);
	 }
	 public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
		 return (entryKind == JavaKind.Object && !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.IMPRECISE : BarrierType.NONE;
	 }
	 public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
		 return (entryKind == JavaKind.Object && !runtime.getVMConfig().useDeferredInitBarriers) ? BarrierType.PRECISE : BarrierType.NONE;
	 }
	 private void lowerOSRStartNode(OSRStartNode osrStart) {
		 StructuredGraph graph = osrStart.graph();
		 if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
			 StartNode newStart = graph.add(new StartNode());
			 ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));
			 ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));
			 migrationEnd.setStateAfter(osrStart.stateAfter());
			 newStart.setNext(migrationEnd);
			 FixedNode next = osrStart.next();
			 osrStart.setNext(null);
			 migrationEnd.setNext(next);
			 graph.setStart(newStart);
			 final int wordSize = target.wordSize;
			 int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;
			 for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {
				 int size = osrLocal.getStackKind().getSlotCount();
				 int offset = localsOffset - (osrLocal.index() + size - 1) * wordSize;
				 AddressNode address = createOffsetAddress(graph, buffer, offset);
				 ReadNode load = graph.add(new ReadNode(address, any(), osrLocal.stamp(NodeView.DEFAULT), BarrierType.NONE));
				 osrLocal.replaceAndDelete(load);
				 graph.addBeforeFixed(migrationEnd, load);
			 }
			 final int lockCount = osrStart.stateAfter().locksSize();
			 final int locksOffset = (graph.method().getMaxLocals() + lockCount * 2 - 1) * wordSize;
			 for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {
				 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();
				 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();
				 final int index = lock.index();
				 final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;
				 final int offsetLockObject = locksOffset - index * 2 * wordSize;
				 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);
				 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
				 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);
				 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));
				 graph.addBeforeFixed(migrationEnd, beginLockScope);
				 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);
				 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE));
				 graph.addBeforeFixed(migrationEnd, writeStackSlot);
				 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);
				 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
				 lock.replaceAndDelete(loadObject);
				 graph.addBeforeFixed(migrationEnd, loadObject);
			 }
			 osrStart.replaceAtUsagesAndDelete(newStart);
		 }
	 }
	 static final class Exceptions {
		 protected static final EnumMap<BytecodeExceptionKind, RuntimeException> cachedExceptions;
		 static {
			 cachedExceptions = new EnumMap<>(BytecodeExceptionKind.class);
			 cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));
			 cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));
			 cachedExceptions.put(BytecodeExceptionKind.CLASS_CAST, clearStackTrace(new ClassCastException()));
			 cachedExceptions.put(BytecodeExceptionKind.ARRAY_STORE, clearStackTrace(new ArrayStoreException()));
			 cachedExceptions.put(BytecodeExceptionKind.DIVISION_BY_ZERO, clearStackTrace(new ArithmeticException()));
		 }
		 private static RuntimeException clearStackTrace(RuntimeException ex) {
			 ex.setStackTrace(new StackTraceElement[0]);
			 return ex;
		 }
	 }
	 public static final class RuntimeCalls {
		 public static final EnumMap<BytecodeExceptionKind, ForeignCallDescriptor> runtimeCalls;
		 static {
			 runtimeCalls = new EnumMap<>(BytecodeExceptionKind.class);
			 runtimeCalls.put(BytecodeExceptionKind.ARRAY_STORE, new ForeignCallDescriptor(""createArrayStoreException"", ArrayStoreException.class, Object.class));
			 runtimeCalls.put(BytecodeExceptionKind.CLASS_CAST, new ForeignCallDescriptor(""createClassCastException"", ClassCastException.class, Object.class, KlassPointer.class));
			 runtimeCalls.put(BytecodeExceptionKind.NULL_POINTER, new ForeignCallDescriptor(""createNullPointerException"", NullPointerException.class));
			 runtimeCalls.put(BytecodeExceptionKind.OUT_OF_BOUNDS, new ForeignCallDescriptor(""createOutOfBoundsException"", ArrayIndexOutOfBoundsException.class, int.class, int.class));
			 runtimeCalls.put(BytecodeExceptionKind.DIVISION_BY_ZERO, new ForeignCallDescriptor(""createDivisionByZeroException"", ArithmeticException.class));
			 runtimeCalls.put(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW, new ForeignCallDescriptor(""createIntegerExactOverflowException"", ArithmeticException.class));
			 runtimeCalls.put(BytecodeExceptionKind.LONG_EXACT_OVERFLOW, new ForeignCallDescriptor(""createLongExactOverflowException"", ArithmeticException.class));
		 }
	 }
	 private void throwCachedException(BytecodeExceptionNode node) {
		 if (IS_IN_NATIVE_IMAGE) {
			 throw new InternalError(""Can't throw exception from SVM object"");
		 }
		 Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());
		 assert exception != null;
		 StructuredGraph graph = node.graph();
		 FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);
		 graph.replaceFixedWithFloating(node, exceptionNode);
	 }
	 private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {
		 if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {
			 throwCachedException(node);
			 return;
		 }
		 ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());
		 assert descriptor != null;
		 StructuredGraph graph = node.graph();
		 ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));
		 graph.replaceFixedWithFixed(node, foreignCallNode);
	 }
	 private boolean addReadBarrier(RawLoadNode load) {
		 if (runtime.getVMConfig().useG1GC && load.graph().getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS && load.object().getStackKind() == JavaKind.Object && load.accessKind() == JavaKind.Object && !StampTool.isPointerAlwaysNull(load.object())) {
			 ResolvedJavaType type = StampTool.typeOrNull(load.object());
			 if (type != null && !type.isArray()) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {
		 return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));
	 }
	 private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {
		 assert vtableEntryOffset > 0;
		 Stamp methodStamp = MethodPointerStamp.methodNonNull();
		 AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);
		 ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));
		 return metaspaceMethod;
	 }
	 protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {
		 if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
			 return graph.unique(new LoadHubNode(tool.getStampProvider(), object));
		 }
		 assert !object.isConstant() || object.isNullConstant();
		 KlassPointerStamp hubStamp = KlassPointerStamp.klassNonNull();
		 if (runtime.getVMConfig().useCompressedClassPointers) {
			 hubStamp = hubStamp.compressed(runtime.getVMConfig().getKlassEncoding());
		 }
		 AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
		 LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;
		 FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));
		 if (runtime.getVMConfig().useCompressedClassPointers) {
			 return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
		 }
		 else {
			 return memoryRead;
		 }
	 }
	 private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
		 assert !object.isConstant() || object.asConstant().isDefaultForKind();
		 ValueNode writeValue = value;
		 if (runtime.getVMConfig().useCompressedClassPointers) {
			 writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
		 }
		 AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
		 return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE));
	 }
	 protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {
		 HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;
		 BarrierType barrierType = BarrierType.NONE;
		 if (runtime.getVMConfig().useG1GC && loadField.getJavaKind() == JavaKind.Object && metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) && loadField.getName().equals(""referent"")) {
			 barrierType = BarrierType.PRECISE;
		 }
		 return barrierType;
	 }
	 public int fieldOffset(ResolvedJavaField f) {
		 return f.getOffset();
	 }
	 public int arrayLengthOffset() {
		 return runtime.getVMConfig().arrayOopDescLengthOffset();
	 }
	 protected final JavaKind getStorageKind(ResolvedJavaField field) {
		 return field.getJavaKind();
	 }
	 public ObjectCloneSnippets.Templates getObjectCloneSnippets() {
		 return objectCloneSnippets;
	 }
	 public ForeignCallSnippets.Templates getForeignCallSnippets() {
		 return foreignCallSnippets;
	 }
}",1,0,0,0
"public void saveQueues() {
	int count = queueList.size();
	File file = new File(Config.getInstance().getDataFolder(), ""queues.txt"");
	BufferedWriter writer = null;
	String newLine = System.getProperty(""line.separator"");
	SimpleDateFormat dateFormatter = new SimpleDateFormat(""yyyy-MM-dd"");
	try {
		writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), Charset.forName(""UTF-8"")));
		writer.write(count + newLine);
		for (int i = 0;
		 i < count;
		 i++) {
			DownloadQueue queue = queueList.get(i);
			writer.write(queue.getQueueId() + newLine);
			writer.write(queue.getName() + newLine);
			ArrayList<String> queuedItems = queue.getQueuedItems();
			writer.write(queuedItems.size() + newLine);
			for (int j = 0;
			 j < queuedItems.size();
			 j++) {
				writer.write(queuedItems.get(j) + newLine);
			}
			if (queue.getStartTime() != -1) {
				writer.write(""1"" + newLine);
				writer.write(queue.getStartTime() + newLine);
				if (queue.getEndTime() != -1) {
					writer.write(""1"" + newLine);
					writer.write(queue.getEndTime() + newLine);
				}
				 else {
					writer.write(""0"" + newLine);
				}
				writer.write((queue.isPeriodic() ? 1 : 0) + newLine);
				if (queue.isPeriodic()) {
					writer.write(queue.getDayMask() + newLine);
				}
				 else {
					if (queue.getExecDate() != null) {
						writer.write(""1"" + newLine);
						writer.write(dateFormatter.format(queue.getExecDate()) + newLine);
					}
					 else {
						writer.write(""0"" + newLine);
					}
				}
			}
			 else {
				writer.write(""0"" + newLine);
			}
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	if (writer != null) {
		try {
			writer.close();
		}
		 catch (IOException e) {
			Logger.log(e);
		}
	}
}",0,0,1,0
"public class StreamRecordComparator<IN> implements Comparator<StreamRecord<IN>>, Serializable {
	 private static final long serialVersionUID = 1581054988433915305L;
	 public int compare(StreamRecord<IN> o1, StreamRecord<IN> o2) {
		 if (o1.getTimestamp() < o2.getTimestamp()) {
			 return -1;
		 }
		 else if (o1.getTimestamp() > o2.getTimestamp()) {
			 return 1;
		 }
		 else {
			 return 0;
		 }
	 }
}",0,0,0,0
"public abstract class PendingActionNotificationResponse extends ImmutableObject implements ResponseData {
	 static class NameOrId extends ImmutableObject {
		 String value;
		 boolean actionResult;
	 }
	 NameOrId nameOrId;
	 Trid trid;
	 DateTime processedDate;
	 public String getNameAsString() {
		 return nameOrId.value;
	 }
	 public Trid getTrid() {
		 return trid;
	 }
	 public boolean getActionResult() {
		 return nameOrId.actionResult;
	 }
	 protected static <T extends PendingActionNotificationResponse> T init( T response, String nameOrId, boolean actionResult, Trid trid, DateTime processedDate) {
		 response.nameOrId = new NameOrId();
		 response.nameOrId.value = nameOrId;
		 response.nameOrId.actionResult = actionResult;
		 response.trid = trid;
		 response.processedDate = processedDate;
		 return response;
	 }
	 public static class DomainPendingActionNotificationResponse extends PendingActionNotificationResponse {
		 NameOrId getName() {
			 return nameOrId;
		 }
		 public static DomainPendingActionNotificationResponse create( String fullyQualifiedDomainName, boolean actionResult, Trid trid, DateTime processedDate) {
			 return init( new DomainPendingActionNotificationResponse(), fullyQualifiedDomainName, actionResult, trid, processedDate);
		 }
	 }
	 public static class ContactPendingActionNotificationResponse extends PendingActionNotificationResponse {
		 NameOrId getId() {
			 return nameOrId;
		 }
		 public static ContactPendingActionNotificationResponse create( String contactId, boolean actionResult, Trid trid, DateTime processedDate) {
			 return init( new ContactPendingActionNotificationResponse(), contactId, actionResult, trid, processedDate);
		 }
	 }
	 public static class HostPendingActionNotificationResponse extends PendingActionNotificationResponse {
		 NameOrId getName() {
			 return nameOrId;
		 }
		 public static HostPendingActionNotificationResponse create( String fullyQualifiedHostName, boolean actionResult, Trid trid, DateTime processedDate) {
			 return init( new HostPendingActionNotificationResponse(), fullyQualifiedHostName, actionResult, trid, processedDate);
		 }
	 }
}",1,1,0,0
"private void renderSmoothTriangle(Vec2 pos1, double zf1, Vec2 pos2, double zf2, Vec2 pos3, double zf3, int width, int height, double clip, RGBColor color1, RGBColor color2, RGBColor color3) {
	 int x1, y1, z1, x2, y2, z2, x3, y3, z3;
	 int dx1, dx2, dy1, dy2, dz1, dz2, mx1, mx2, mz1, mz2;
	 int xstart, xend, yend, zstart, zend, y, z, dz, left, right, i, index;
	 int red1, green1, blue1, red2, green2, blue2, red3, green3, blue3;
	 int dred1, dred2, dgreen1, dgreen2, dblue1, dblue2, mred1, mred2, mgreen1, mgreen2, mblue1, mblue2;
	 int redstart, redend, greenstart, greenend, bluestart, blueend, red, green, blue, dred, dgreen, dblue;
	 int clipDist = (int) (clip*65535.0);
	 if (pos1.y <= pos2.y && pos1.y <= pos3.y) {
		 x1 = ((int) pos1.x) << 16;
		 y1 = ((int) pos1.y);
		 z1 = (int) (zf1*65535.0);
		 red1 = (int) (color1.getRed()*65535.0f);
		 green1 = (int) (color1.getGreen()*65535.0f);
		 blue1 = (int) (color1.getBlue()*65535.0f);
		 if (pos2.y < pos3.y) {
			 x2 = ((int) pos2.x) << 16;
			 y2 = ((int) pos2.y);
			 z2 = (int) (zf2*65535.0);
			 red2 = (int) (color2.getRed()*65535.0f);
			 green2 = (int) (color2.getGreen()*65535.0f);
			 blue2 = (int) (color2.getBlue()*65535.0f);
			 x3 = ((int) pos3.x) << 16;
			 y3 = ((int) pos3.y);
			 z3 = (int) (zf3*65535.0);
			 red3 = (int) (color3.getRed()*65535.0f);
			 green3 = (int) (color3.getGreen()*65535.0f);
			 blue3 = (int) (color3.getBlue()*65535.0f);
		 }
		 else {
			 x2 = ((int) pos3.x) << 16;
			 y2 = ((int) pos3.y);
			 z2 = (int) (zf3*65535.0);
			 red2 = (int) (color3.getRed()*65535.0f);
			 green2 = (int) (color3.getGreen()*65535.0f);
			 blue2 = (int) (color3.getBlue()*65535.0f);
			 x3 = ((int) pos2.x) << 16;
			 y3 = ((int) pos2.y);
			 z3 = (int) (zf2*65535.0);
			 red3 = (int) (color2.getRed()*65535.0f);
			 green3 = (int) (color2.getGreen()*65535.0f);
			 blue3 = (int) (color2.getBlue()*65535.0f);
		 }
	 }
	 else if (pos2.y <= pos1.y && pos2.y <= pos3.y) {
		 x1 = ((int) pos2.x) << 16;
		 y1 = ((int) pos2.y);
		 z1 = (int) (zf2*65535.0);
		 red1 = (int) (color2.getRed()*65535.0f);
		 green1 = (int) (color2.getGreen()*65535.0f);
		 blue1 = (int) (color2.getBlue()*65535.0f);
		 if (pos1.y < pos3.y) {
			 x2 = ((int) pos1.x) << 16;
			 y2 = ((int) pos1.y);
			 z2 = (int) (zf1*65535.0);
			 red2 = (int) (color1.getRed()*65535.0f);
			 green2 = (int) (color1.getGreen()*65535.0f);
			 blue2 = (int) (color1.getBlue()*65535.0f);
			 x3 = ((int) pos3.x) << 16;
			 y3 = ((int) pos3.y);
			 z3 = (int) (zf3*65535.0);
			 red3 = (int) (color3.getRed()*65535.0f);
			 green3 = (int) (color3.getGreen()*65535.0f);
			 blue3 = (int) (color3.getBlue()*65535.0f);
		 }
		 else {
			 x2 = ((int) pos3.x) << 16;
			 y2 = ((int) pos3.y);
			 z2 = (int) (zf3*65535.0);
			 red2 = (int) (color3.getRed()*65535.0f);
			 green2 = (int) (color3.getGreen()*65535.0f);
			 blue2 = (int) (color3.getBlue()*65535.0f);
			 x3 = ((int) pos1.x) << 16;
			 y3 = ((int) pos1.y);
			 z3 = (int) (zf1*65535.0);
			 red3 = (int) (color1.getRed()*65535.0f);
			 green3 = (int) (color1.getGreen()*65535.0f);
			 blue3 = (int) (color1.getBlue()*65535.0f);
		 }
	 }
	 else {
		 x1 = ((int) pos3.x) << 16;
		 y1 = ((int) pos3.y);
		 z1 = (int) (zf3*65535.0);
		 red1 = (int) (color3.getRed()*65535.0f);
		 green1 = (int) (color3.getGreen()*65535.0f);
		 blue1 = (int) (color3.getBlue()*65535.0f);
		 if (pos1.y < pos2.y) {
			 x2 = ((int) pos1.x) << 16;
			 y2 = ((int) pos1.y);
			 z2 = (int) (zf1*65535.0);
			 red2 = (int) (color1.getRed()*65535.0f);
			 green2 = (int) (color1.getGreen()*65535.0f);
			 blue2 = (int) (color1.getBlue()*65535.0f);
			 x3 = ((int) pos2.x) << 16;
			 y3 = ((int) pos2.y);
			 z3 = (int) (zf2*65535.0);
			 red3 = (int) (color2.getRed()*65535.0f);
			 green3 = (int) (color2.getGreen()*65535.0f);
			 blue3 = (int) (color2.getBlue()*65535.0f);
		 }
		 else {
			 x2 = ((int) pos2.x) << 16;
			 y2 = ((int) pos2.y);
			 z2 = (int) (zf2*65535.0);
			 red2 = (int) (color2.getRed()*65535.0f);
			 green2 = (int) (color2.getGreen()*65535.0f);
			 blue2 = (int) (color2.getBlue()*65535.0f);
			 x3 = ((int) pos1.x) << 16;
			 y3 = ((int) pos1.y);
			 z3 = (int) (zf1*65535.0);
			 red3 = (int) (color1.getRed()*65535.0f);
			 green3 = (int) (color1.getGreen()*65535.0f);
			 blue3 = (int) (color1.getBlue()*65535.0f);
		 }
	 }
	 dx1 = x3-x1;
	 dy1 = y3-y1;
	 dz1 = z3-z1;
	 if (dy1 == 0) return;
	 dred1 = red3-red1;
	 dgreen1 = green3-green1;
	 dblue1 = blue3-blue1;
	 dx2 = x2-x1;
	 dy2 = y2-y1;
	 dz2 = z2-z1;
	 dred2 = red2-red1;
	 dgreen2 = green2-green1;
	 dblue2 = blue2-blue1;
	 mx1 = dx1/dy1;
	 mz1 = dz1/dy1;
	 mred1 = dred1/dy1;
	 mgreen1 = dgreen1/dy1;
	 mblue1 = dblue1/dy1;
	 xstart = xend = x1;
	 zstart = zend = z1;
	 redstart = redend = red1;
	 greenstart = greenend = green1;
	 bluestart = blueend = blue1;
	 y = y1;
	 if (dy2 != 0) {
		 mx2 = dx2/dy2;
		 mz2 = dz2/dy2;
		 mred2 = dred2/dy2;
		 mgreen2 = dgreen2/dy2;
		 mblue2 = dblue2/dy2;
		 if (y2 < 0) {
			 xstart += mx1*dy2;
			 xend += mx2*dy2;
			 zstart += mz1*dy2;
			 zend += mz2*dy2;
			 redstart += mred1*dy2;
			 redend += mred2*dy2;
			 greenstart += mgreen1*dy2;
			 greenend += mgreen2*dy2;
			 bluestart += mblue1*dy2;
			 blueend += mblue2*dy2;
			 y = y2;
		 }
		 else if (y < 0) {
			 xstart -= mx1*y;
			 xend -= mx2*y;
			 zstart -= mz1*y;
			 zend -= mz2*y;
			 redstart -= mred1*y;
			 redend -= mred2*y;
			 greenstart -= mgreen1*y;
			 greenend -= mgreen2*y;
			 bluestart -= mblue1*y;
			 blueend -= mblue2*y;
			 y = 0;
		 }
		 yend = (y2 < height ? y2 : height);
		 index = y*width;
		 while (y < yend) {
			 if (xstart < xend) {
				 left = xstart >> 16;
				 right = xend >> 16;
				 z = zstart;
				 dz = zend-zstart;
				 red = redstart;
				 dred = redend-redstart;
				 green = greenstart;
				 dgreen = greenend-greenstart;
				 blue = bluestart;
				 dblue = blueend-bluestart;
			 }
			 else {
				 left = xend >> 16;
				 right = xstart >> 16;
				 z = zend;
				 dz = zstart-zend;
				 red = redend;
				 dred = redstart-redend;
				 green = greenend;
				 dgreen = greenstart-greenend;
				 blue = blueend;
				 dblue = bluestart-blueend;
			 }
			 if (left != right) {
				 dz /= (right-left);
				 dred /= (right-left);
				 dgreen /= (right-left);
				 dblue /= (right-left);
				 if (left < 0) {
					 z -= left*dz;
					 red -= left*dred;
					 green -= left*dgreen;
					 blue -= left*dblue;
					 left = 0;
				 }
				 if (right > width) right = width;
				 for (i = left;
				 i < right;
				 i++) {
					 if (z < zbuffer[index+i] && z > clipDist) {
						 pixel[index+i] = 0xFF000000 + ((red & 0xFF00)<<8) + (green & 0xFF00) + (blue >> 8);
						 zbuffer[index+i] = z;
					 }
					 z += dz;
					 red += dred;
					 green += dgreen;
					 blue += dblue;
				 }
			 }
			 xstart += mx1;
			 zstart += mz1;
			 redstart += mred1;
			 greenstart += mgreen1;
			 bluestart += mblue1;
			 xend += mx2;
			 zend += mz2;
			 redend += mred2;
			 greenend += mgreen2;
			 blueend += mblue2;
			 index += width;
			 y++;
		 }
	 }
	 dx2 = x3-x2;
	 dy2 = y3-y2;
	 dz2 = z3-z2;
	 dred2 = red3-red2;
	 dgreen2 = green3-green2;
	 dblue2 = blue3-blue2;
	 if (dy2 != 0) {
		 mx2 = dx2/dy2;
		 mz2 = dz2/dy2;
		 mred2 = dred2/dy2;
		 mgreen2 = dgreen2/dy2;
		 mblue2 = dblue2/dy2;
		 xend = x2;
		 zend = z2;
		 redend = red2;
		 greenend = green2;
		 blueend = blue2;
		 if (y < 0) {
			 xstart -= mx1*y;
			 xend -= mx2*y;
			 zstart -= mz1*y;
			 zend -= mz2*y;
			 redstart -= mred1*y;
			 redend -= mred2*y;
			 greenstart -= mgreen1*y;
			 greenend -= mgreen2*y;
			 bluestart -= mblue1*y;
			 blueend -= mblue2*y;
			 y = 0;
		 }
		 yend = (y3 < height ? y3 : height);
		 index = y*width;
		 while (y < yend) {
			 if (xstart < xend) {
				 left = xstart >> 16;
				 right = xend >> 16;
				 z = zstart;
				 dz = zend-zstart;
				 red = redstart;
				 dred = redend-redstart;
				 green = greenstart;
				 dgreen = greenend-greenstart;
				 blue = bluestart;
				 dblue = blueend-bluestart;
			 }
			 else {
				 left = xend >> 16;
				 right = xstart >> 16;
				 z = zend;
				 dz = zstart-zend;
				 red = redend;
				 dred = redstart-redend;
				 green = greenend;
				 dgreen = greenstart-greenend;
				 blue = blueend;
				 dblue = bluestart-blueend;
			 }
			 if (left != right) {
				 dz /= (right-left);
				 dred /= (right-left);
				 dgreen /= (right-left);
				 dblue /= (right-left);
				 if (left < 0) {
					 z -= left*dz;
					 red -= left*dred;
					 green -= left*dgreen;
					 blue -= left*dblue;
					 left = 0;
				 }
				 if (right > width) right = width;
				 for (i = left;
				 i < right;
				 i++) {
					 if (z < zbuffer[index+i] && z > clipDist) {
						 pixel[index+i] = 0xFF000000 + ((red & 0xFF00)<<8) + (green & 0xFF00) + (blue >> 8);
						 zbuffer[index+i] = z;
					 }
					 z += dz;
					 red += dred;
					 green += dgreen;
					 blue += dblue;
				 }
			 }
			 xstart += mx1;
			 zstart += mz1;
			 redstart += mred1;
			 greenstart += mgreen1;
			 bluestart += mblue1;
			 xend += mx2;
			 zend += mz2;
			 redend += mred2;
			 greenend += mgreen2;
			 blueend += mblue2;
			 index += width;
			 y++;
		 }
	 }
 }",0,0,1,0
"public class ManageSoftwareModuleFilters implements Serializable {
	 private static final long serialVersionUID = -1631725636290496525L;
	 private SoftwareModuleType softwareModuleType;
	 private String searchText;
	 public Optional<SoftwareModuleType> getSoftwareModuleType() {
		 return Optional.ofNullable(softwareModuleType);
	 }
	 public void setSoftwareModuleType(final SoftwareModuleType softwareModuleType) {
		 this.softwareModuleType = softwareModuleType;
	 }
	 public Optional<String> getSearchText() {
		 return Optional.ofNullable(searchText);
	 }
	 public void setSearchText(final String searchText) {
		 this.searchText = searchText;
	 }
}",0,1,0,0
"public Map<Integer, CQLStatement> getPrepared() {
	 return prepared;
 }",0,0,0,0
"public class _ReportingService2005Soap_ValidateExtensionSettings implements ElementSerializable{
	 protected String extension;
	 protected _ParameterValueOrFieldReference[] parameterValues;
	 public _ReportingService2005Soap_ValidateExtensionSettings() {
		 super();
	 }
	 public _ReportingService2005Soap_ValidateExtensionSettings( final String extension, final _ParameterValueOrFieldReference[] parameterValues) {
		 setExtension(extension);
		 setParameterValues(parameterValues);
	 }
	 public String getExtension() {
		 return this.extension;
	 }
	 public void setExtension(String value) {
		 this.extension = value;
	 }
	 public _ParameterValueOrFieldReference[] getParameterValues() {
		 return this.parameterValues;
	 }
	 public void setParameterValues(_ParameterValueOrFieldReference[] value) {
		 this.parameterValues = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 XMLStreamWriterHelper.writeElement( writer, ""Extension"", this.extension);
		 if (this.parameterValues != null) {
			 writer.writeStartElement(""ParameterValues"");
			 for (int iterator0 = 0;
			 iterator0 < this.parameterValues.length;
			 iterator0++) {
				 this.parameterValues[iterator0].writeAsElement( writer, ""ParameterValueOrFieldReference"");
			 }
			 writer.writeEndElement();
		 }
		 writer.writeEndElement();
	 }
}",1,1,0,0
"public void reduce(WritableComparable key, Iterator values, OutputCollector output, Reporter reporter) throws IOException {
	 CrawlDatum lastG = null;
	 CrawlDatum lastF = null;
	 CrawlDatum lastSig = null;
	 Content lastC = null;
	 ParseData lastPD = null;
	 ParseText lastPT = null;
	 String lastGname = null;
	 String lastFname = null;
	 String lastSigname = null;
	 String lastCname = null;
	 String lastPDname = null;
	 String lastPTname = null;
	 TreeMap linked = new TreeMap();
	 while (values.hasNext()) {
		 MetaWrapper wrapper = (MetaWrapper)values.next();
		 Object o = wrapper.get();
		 String spString = wrapper.getMeta(SEGMENT_PART_KEY);
		 if (spString == null) {
			 throw new IOException(""Null segment part, key="" + key);
		 }
		 SegmentPart sp = SegmentPart.parse(spString);
		 if (o instanceof CrawlDatum) {
			 CrawlDatum val = (CrawlDatum)o;
			 if (sp.partName.equals(CrawlDatum.GENERATE_DIR_NAME)) {
				 if (lastG == null) {
					 lastG = val;
					 lastGname = sp.segmentName;
				 }
				 else {
					 if (lastGname.compareTo(sp.segmentName) < 0) {
						 lastG = val;
						 lastGname = sp.segmentName;
					 }
				 }
			 }
			 else if (sp.partName.equals(CrawlDatum.FETCH_DIR_NAME)) {
				 if (lastF == null) {
					 lastF = val;
					 lastFname = sp.segmentName;
				 }
				 else {
					 if (lastFname.compareTo(sp.segmentName) < 0) {
						 lastF = val;
						 lastFname = sp.segmentName;
					 }
				 }
			 }
			 else if (sp.partName.equals(CrawlDatum.PARSE_DIR_NAME)) {
				 if (val.getStatus() == CrawlDatum.STATUS_SIGNATURE) {
					 if (lastSig == null) {
						 lastSig = val;
						 lastSigname = sp.segmentName;
					 }
					 else {
						 if (lastSigname.compareTo(sp.segmentName) < 0) {
							 lastSig = val;
							 lastSigname = sp.segmentName;
						 }
					 }
					 continue;
				 }
				 ArrayList segLinked = (ArrayList)linked.get(sp.segmentName);
				 if (segLinked == null) {
					 segLinked = new ArrayList();
					 linked.put(sp.segmentName, segLinked);
				 }
				 segLinked.add(val);
			 }
			 else {
				 throw new IOException(""Cannot determine segment part: "" + sp.partName);
			 }
		 }
		 else if (o instanceof Content) {
			 if (lastC == null) {
				 lastC = (Content)o;
				 lastCname = sp.segmentName;
			 }
			 else {
				 if (lastCname.compareTo(sp.segmentName) < 0) {
					 lastC = (Content)o;
					 lastCname = sp.segmentName;
				 }
			 }
		 }
		 else if (o instanceof ParseData) {
			 if (lastPD == null) {
				 lastPD = (ParseData)o;
				 lastPDname = sp.segmentName;
			 }
			 else {
				 if (lastPDname.compareTo(sp.segmentName) < 0) {
					 lastPD = (ParseData)o;
					 lastPDname = sp.segmentName;
				 }
			 }
		 }
		 else if (o instanceof ParseText) {
			 if (lastPT == null) {
				 lastPT = (ParseText)o;
				 lastPTname = sp.segmentName;
			 }
			 else {
				 if (lastPTname.compareTo(sp.segmentName) < 0) {
					 lastPT = (ParseText)o;
					 lastPTname = sp.segmentName;
				 }
			 }
		 }
	 }
	 curCount++;
	 String sliceName = null;
	 MetaWrapper wrapper = new MetaWrapper();
	 if (sliceSize > 0) {
		 sliceName = String.valueOf(curCount / sliceSize);
		 wrapper.setMeta(SEGMENT_SLICE_KEY, sliceName);
	 }
	 SegmentPart sp = new SegmentPart();
	 if (lastG != null) {
		 wrapper.set(lastG);
		 sp.partName = CrawlDatum.GENERATE_DIR_NAME;
		 sp.segmentName = lastGname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastF != null) {
		 wrapper.set(lastF);
		 sp.partName = CrawlDatum.FETCH_DIR_NAME;
		 sp.segmentName = lastFname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastSig != null) {
		 wrapper.set(lastSig);
		 sp.partName = CrawlDatum.PARSE_DIR_NAME;
		 sp.segmentName = lastSigname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastC != null) {
		 wrapper.set(lastC);
		 sp.partName = Content.DIR_NAME;
		 sp.segmentName = lastCname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastPD != null) {
		 wrapper.set(lastPD);
		 sp.partName = ParseData.DIR_NAME;
		 sp.segmentName = lastPDname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (lastPT != null) {
		 wrapper.set(lastPT);
		 sp.partName = ParseText.DIR_NAME;
		 sp.segmentName = lastPTname;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 output.collect(key, wrapper);
	 }
	 if (linked.size() > 0) {
		 String name = (String)linked.lastKey();
		 sp.partName = CrawlDatum.PARSE_DIR_NAME;
		 sp.segmentName = name;
		 wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());
		 ArrayList segLinked = (ArrayList)linked.get(name);
		 for (int i = 0;
		 i < segLinked.size();
		 i++) {
			 CrawlDatum link = (CrawlDatum)segLinked.get(i);
			 wrapper.set(link);
			 output.collect(key, wrapper);
		 }
	 }
 }",0,0,1,0
"public final class StringSequenceNumberConverter {
	 private StringSequenceNumberConverter() {
	 }
	 public static SequenceNumberProvider toSequenceNumberProvider(String sequenceNumber) {
		 return new StaticSequenceNumberProvider(sequenceNumber);
	 }
}",0,0,0,0
"class WGTestSuite extends TestSuite implements ARPErrorNumbers {
	static private Resource jena2;
	static private Model testResults;
	static private void initResults() {
		logging = true;
		testResults = ModelFactory.createDefaultModel();
		jena2 = testResults.createResource(BASE_RESULTS_URI + ""#jena"");
		jena2.addProperty(RDFS.label, ""Jena"");
		testResults.setNsPrefix(""results"", OWLResults.NS);
	}
	static void logResult(Resource test, int type) {
	}
	private static boolean logging = false;
	private static String BASE_RESULTS_URI = ""http: static public boolean checkMessages = false;
	 static private boolean doSemanticTests() {
		 return ARPTests.internet;
	 }
	 static private boolean inDevelopment = false;
	 Model loadRDF(InputSupplier in, RDFErrorHandler eh, String base) throws IOException {
		 Model model = ModelFactory.createDefaultModel();
		 RDFXMLReader jr = new RDFXMLReader();
		 if (eh != null) jr.setErrorHandler(eh);
		 jr.setProperty(""error-mode"", ""strict"");
		 if ( base.contains( ""/xmlns/"" ) || base.contains( ""/comments/"" ) ) jr.setProperty(""embedding"",""true"");
		 try ( InputStream inx = in.open() ) {
			 jr.read(model, inx, base);
		 }
		 return model;
	 }
	 static Model loadNT(InputStream in, String base) throws IOException {
		 Model model = ModelFactory.createDefaultModel();
		 model.read(in, base, ""N-TRIPLE"");
		 in.close();
		 return model;
	 }
	static private class DummyTest extends TestCase {
		DummyTest() {
			super(""save results"");
		}
		 public void runTest() throws IOException {
			if (logging) {
				 RDFWriterI w = new RDFXML_Abbrev();
				 w.setProperty(""xmlbase"",BASE_RESULTS_URI );
				 try ( OutputStream out = new FileOutputStream(""/tmp/rdf-results.rdf"") ) {
					 w.write(testResults,out,BASE_RESULTS_URI);
				 }
			}
		}
	}
	 static String testNS = ""http: static String jjcNS = ""http: static private Property status;
	 static private Property input;
	 static private Property output;
	 static private Property warning;
	 static private Property errorCodes;
	 static {
		 status = new PropertyImpl(testNS, ""status"");
		 input = new PropertyImpl(testNS, ""inputDocument"");
		 output = new PropertyImpl(testNS, ""outputDocument"");
		 warning = new PropertyImpl(testNS, ""warning"");
		 errorCodes = new PropertyImpl(jjcNS, ""error"");
	 }
	 static private Resource rdfxml = new ResourceImpl(testNS, ""RDF-XML-Document"");
	 static private Resource ntriple = new ResourceImpl(testNS, ""NT-Document"");
	 private String testDir;
	 private Act noop = new Act() {
		 public void act(Resource r) {
		 }
	 }
	;
	 private Act semTest = new Act() {
		 public void act(Resource r) {
			 if (doSemanticTests()){
			 }
		 }
	 }
	;
	 InputStreamFactoryTests factory;
	 static private Collection<String> misc = Arrays.asList( new String[] {
		 ""http: private Map<ResourceImpl, Act> behaviours = new HashMap<>();
		 {
			 behaviours .put(new ResourceImpl(testNS + ""PositiveParserTest""), new Act() {
				 public void act(Resource r) {
					 if (r.hasProperty(warning)) {
						 addTest(r, new WarningTest(r));
					 }
					 else {
						 addTest(r, new PositiveTest(r));
					 }
				 }
			 }
			);
			 behaviours .put(new ResourceImpl(testNS + ""NegativeParserTest""), new Act() {
				 public void act(Resource r) {
					 addTest(r, new NegativeTest(r));
				 }
			 }
			);
			 behaviours.put(new ResourceImpl(testNS + ""False-Document""), noop);
			 behaviours.put(new ResourceImpl(testNS + ""RDF-XML-Document""), noop);
			 behaviours.put(new ResourceImpl(testNS + ""NT-Document""), noop);
			 behaviours.put( new ResourceImpl(testNS + ""PositiveEntailmentTest""), semTest);
			 behaviours.put( new ResourceImpl(testNS + ""NegativeEntailmentTest""), semTest);
			 behaviours .put(new ResourceImpl(testNS + ""MiscellaneousTest""), new Act() {
				 public void act(Resource r) {
					 String uri = r.getURI();
					 if (!misc.contains(uri)) System.err.println( ""MiscellaneousTest: "" + uri + "" - ignored!"");
				 }
			 }
			);
		 }
		 private Model loadRDF(final InputStreamFactoryTests fact, final String file) {
			 Model m = null;
			 String base = fact.getBase().toString();
			 if (!base.endsWith(""/"")) base = base + ""/"";
			 try ( InputStream in = fact.fullyOpen(file) ) {
				 if (in == null ) return null;
				 m = loadRDF(()->fact.fullyOpen(file) , null, base + file);
			 }
			 catch (JenaException e) {
				 throw e;
			 }
			 catch (Exception e) {
				 if (file.equals(""Manifest.rdf"")) {
					 System.err.println(""Failed to open Manifest.rdf"");
					 e.printStackTrace();
				 }
			 }
			 return m;
		 }
		 WGTestSuite(InputStreamFactoryTests fact, String name, boolean dynamic) {
			 super(name);
			 factory = fact;
			 testDir = fact.getBase();
			 if (dynamic) try {
				 System.err.println(testDir);
				 wgReasoner = new WGReasonerTester(""Manifest.rdf"", ""testing/wg/"");
				 Model m = loadRDF(fact, ""Manifest.rdf"");
				 Model extra = loadRDF(fact, ""Manifest-extra.rdf"");
				 Model wrong = loadRDF(fact, ""Manifest-wrong.rdf"");
				 if (extra != null) m = m.add(extra);
				 if (wrong != null) m = m.difference(wrong);
				 StmtIterator si = m.listStatements( null, RDF.type, (RDFNode) null );
				 while (si.hasNext()) {
					 Statement st = si.nextStatement();
					 Act action = behaviours.get(st.getObject());
					 if (action == null) {
						 System.err.println( ""Unknown test class: "" + ((Resource) st.getObject()).getURI());
					 }
					 else {
						 action.act(st.getSubject());
					 }
				 }
				 if ( ARPTests.internet) {
					 initResults();
					 addTest(new DummyTest());
				 }
			 }
			 catch (RuntimeException re) {
				 re.printStackTrace();
				 throw re;
			 }
			 catch (Exception e) {
				 e.printStackTrace();
				 throw new JenaException( e );
			 }
		 }
		 static TestSuite suite(String testDir, String d, String nm) {
			 return new WGTestSuite( new InputStreamFactoryTests(testDir, d), nm, true);
		 }
		 private Map<String, TestSuite> parts = new HashMap<>();
		 private void addTest(Resource key, TestCase test) {
			 String keyName = key.hasProperty(status) ? key.getRequiredProperty(status).getString() : ""no status"";
			 TestSuite sub = parts.get(keyName);
			 if (sub == null) {
				 if ( keyName.equals(""OBSOLETED"")) return;
				 if ( keyName.equals(""OBSOLETE"")) return;
				 if ( keyName.equals(""NOT_APPROVED"")) return;
				 sub = new TestSuite();
				 sub.setName(keyName);
				 parts.put(keyName, sub);
				 addTest(sub);
			 }
			 sub.addTest(test);
		 }
		 final static String errorLevelName[] = new String[] {
		 ""warning"", ""error"", ""fatal"" }
		;
		 interface Act {
			 void act(Resource r) ;
		 }
		 private WGReasonerTester wgReasoner;
		 class ReasoningTest extends Test {
			 ReasoningTest(Resource r) {
				 super(r);
			 }
			 protected void runTest() throws IOException {
				 int rslt = WGReasonerTester.FAIL;
				 try {
					 JenaParameters.enableWhitespaceCheckingOfTypedLiterals = true;
					 Resource config = ModelFactory.createDefaultModel().createResource() .addProperty(ReasonerVocabulary.PROPsetRDFSLevel, ""full"");
					 rslt = wgReasoner.runTestDetailedResponse(testID.getURI(), RDFSRuleReasonerFactory.theInstance(),this,config);
				 }
				 finally {
					 logResult(testID,rslt);
				 }
			}
			 String createMe() {
				throw new UnsupportedOperationException();
			}
			 void reallyRunTest() {
				throw new BrokenException("""");
			}
		 }
		 private String relativize(String uri) {
			 IRIx base2 = IRIx.create(testDir);
			 IRIx uri2 = IRIx.create(uri);
			 IRIx relative = base2.relativize(uri2);
			 return relative.str();
		 }
		 abstract class Test extends TestCase implements RDFErrorHandler {
			 Resource testID;
			 String createURI() {
				 return ""\"""" + testID.getURI() + ""\"""";
			 }
			 abstract String createMe();
			 Test(Resource r) {
				 super( relativize(r.getURI()) );
				 testID = r;
			 }
			 String create(Property p) {
				 Resource file = testID.getRequiredProperty(p).getResource();
				 Resource t = file.getRequiredProperty(RDF.type).getResource();
				 if (ntriple.equals(t)) {
					 return ""\"""" + file.getURI() + ""\"",false"";
				 }
				 else if (rdfxml.equals(t)) {
					 return ""\"""" + file.getURI() + ""\"",true"";
				 }
				 else {
					 return ""Unrecognized file type: "" + t;
				 }
			 }
			 Model read(Property p) throws IOException {
				 Resource file = testID.getRequiredProperty(p).getResource();
				 Resource t = file.getRequiredProperty(RDF.type).getResource();
				 final String uri = file.getURI();
				 if (ntriple.equals(t)) {
					 return loadNT(factory.open(uri),uri);
				 }
				 else if (rdfxml.equals(t)) {
					 return loadRDF( ()->factory.open(uri), this, uri);
				 }
				 else {
					 fail(""Unrecognized file type: "" + t);
				 }
				 return null;
			 }
			 protected void runTest() throws IOException {
				 int rslt = WGReasonerTester.FAIL;
				 try {
					 reallyRunTest();
					 rslt = WGReasonerTester.PASS;
				 }
				 finally {
					 logResult(testID,rslt);
				 }
			 }
			 abstract void reallyRunTest();
			 public void warning(Exception e) {
				 error(0, e);
			 }
			 public void error(Exception e) {
				 error(1, e);
			 }
			 public void fatalError(Exception e) {
				 error(2, e);
			 }
			 private void error(int level, Exception e) {
				 if (e instanceof ParseException) {
					 int eCode = ((ParseException) e).getErrorNumber();
					 if (eCode == ERR_SYNTAX_ERROR) {
						 String msg = e.getMessage();
						 if ( msg.contains( ""Unusual"" ) || msg.contains( ""Internal"" ) ) {
							 System.err.println(testID.getURI());
							 System.err.println(msg);
							 fail(msg);
						 }
						 if (checkMessages) {
							 System.err.println(testID.getURI());
							 System.err.println(msg);
						 }
					 }
					 onError(level, eCode);
				 }
				 else if (e instanceof SAXException) {
					 fail(""Not expecting a SAXException: "" + e.getMessage());
				 }
				 else {
					 fail(""Not expecting an Exception: "" + e.getMessage());
				 }
			 }
			 private void println(String m) {
				 System.err.println(m);
			 }
			 void onError(int level, int num) {
				 String msg = ""Parser reports unexpected "" + errorLevelName[level] + "": "" + ParseException.errorCodeName(num);
				 println(msg);
				 fail(msg);
			 }
		 }
		 class PositiveTest extends NegativeTest {
			 String createMe() {
				 return createURI() + "","" + create(input) + "","" + create(output);
			 }
			 PositiveTest(Resource nm) {
				 super(nm);
				 expectedLevel = -1;
			 }
			 protected void reallyRunTest() {
				 try {
					 Model m2 = read(output);
					 super.reallyRunTest();
					 if (!m1.equals(m2)) {
						 assertTrue(m1.isIsomorphicWith( m2 ) );
					 }
				 }
				 catch (RuntimeException e) {
					 throw e;
				 }
				 catch (Exception e) {
					 fail(e.getMessage());
				 }
			 }
			 void initExpected() {
				 expected = new HashSet<>();
			 }
		 }
		 class WarningTest extends PositiveTest {
			 String createMe() {
				 return createURI() + "","" + create(input) + "","" + create(output) + "","" + createExpected();
			 }
			 WarningTest(Resource nm) {
				 super(nm);
				 expectedLevel = 0;
			 }
			 void initExpected() {
				 initExpectedFromModel();
			 }
		 }
		 class NegativeTest extends Test {
			 Model m1;
			 Set<Integer> expected;
			 int expectedLevel = 1;
			 private Set<Integer> found = new HashSet<>();
			 private int errorCnt[] = new int[] {
			 0, 0, 0 }
			;
			 String createExpected() {
				 String rslt = ""new int[]{
					"";
					 if ( expected == null) return ""null"";
					 Iterator<Integer> it = expected.iterator();
					 while (it.hasNext()) rslt += it.next() + "", "";
				 return rslt + ""}
				"";
			 }
			 String createMe() {
				 return createURI() + "","" + create(input) + "","" + createExpected();
			 }
			 NegativeTest(Resource nm) {
				 super(nm);
				 initExpected();
			 }
			 void initExpectedFromModel() {
				 StmtIterator si = testID.listProperties(errorCodes);
				 if (si.hasNext()) {
					 expected = new HashSet<>();
					 while (si.hasNext()) {
						 String uri = si.nextStatement().getResource().getURI();
						 String fieldName = uri.substring(uri.lastIndexOf('#') + 1);
						 expected.add(Integer.valueOf(ParseException.errorCode(fieldName)));
					 }
				 }
			 }
			 void initExpected() {
				 initExpectedFromModel();
			 }
			 protected void reallyRunTest() {
				 try {
					 m1 = read(input);
				 }
				 catch (JenaException re) {
					 if (re.getCause() instanceof SAXException) {
					 }
					 else {
						 fail(re.getMessage());
					 }
				 }
				 catch (IOException ioe) {
					 fail(ioe.getMessage());
				 }
				 if (expected != null && !expected.equals(found)) {
					 Set<Integer> dup = new HashSet<>();
					 dup.addAll(found);
					 dup.removeAll(expected);
					 expected.removeAll(found);
					 Iterator<Integer> it = expected.iterator();
					 while (it.hasNext()) {
						 int eCode = it.next().intValue();
						 String msg = ""Expected error "" + ParseException.errorCodeName(eCode) + "", was not detected."";
						 if (errorCnt[2] == 0) fail(msg);
						 else if ( eCode == ERR_SYNTAX_ERROR && getName().startsWith(""rdf-nnn/67_"") && ""1234"".indexOf( getName().charAt(""rdf-nnn/67_"".length())) != -1) {
						 }
						 else {
							 System.err.println(""Test: "" + getName());
							 System.err.println(msg);
						 }
					 }
					 it = dup.iterator();
					 while (it.hasNext()) fail( ""Detected error "" + ParseException.errorCodeName( it.next().intValue()) + "", was not expected."");
				 }
				 for (int j = 2;
				 j >= 0;
				 j--) if (j == expectedLevel) {
					 if (errorCnt[j] == 0 && (j != 1 || errorCnt[2] == 0)) fail( ""No "" + errorLevelName[expectedLevel] + "" in input file of class "" + getClass().getName());
				 }
				 else if (expected == null) {
					 if (errorCnt[j] != 0) fail( ""Inappropriate "" + errorLevelName[j] + "" in input file of class "" + getClass().getName());
				 }
			 }
			 void onError(int level, int id) {
				 Integer err = Integer.valueOf(id);
				 found.add(err);
				 errorCnt[level]++;
				 if (expected != null) {
					 if (!expected.contains(err)) super.onError(level, id);
				 }
				 else if (inDevelopment) {
					 System.err.println( ""<rdf:Description rdf:about='"" + testID.getURI() + ""'>\n"" + ""<jjc:error rdf:resource='"" + jjcNS + ParseException.errorCodeName(id) + ""'/>\n</rdf:Description>"");
				 }
			 }
		 }
		 class Test2 extends TestCase implements RDFErrorHandler {
			 Test2(String r) {
				 super(relativize(r));
			 }
			 Model read(String file, boolean type) throws IOException {
				 if (!type) {
					 return loadNT(factory.open(file),file);
				 }
				 final String uri = file;
				 return loadRDF( ()->factory.open(uri) , this, uri);
			 }
			 public void warning(Exception e) {
				 error(0, e);
			 }
			 public void error(Exception e) {
				 error(1, e);
			 }
			 public void fatalError(Exception e) {
				 error(2, e);
			 }
			 private void error(int level, Exception e) {
				 if (e instanceof ParseException) {
					 int eCode = ((ParseException) e).getErrorNumber();
					 if (eCode == ERR_SYNTAX_ERROR) {
						 String msg = e.getMessage();
						 if ( msg.contains( ""Unusual"" ) || msg.contains( ""Internal"" ) ) {
							 System.err.println(getName());
							 System.err.println(msg);
							 fail(msg);
						 }
					 }
					 onError(level, eCode);
				 }
				 else if (e instanceof SAXException) {
					 fail(""Not expecting a SAXException: "" + e.getMessage());
				 }
				 else {
					 fail(""Not expecting an Exception: "" + e.getMessage());
				 }
			 }
			 private void println(String m) {
				 System.err.println(m);
			 }
			 void onError(int level, int num) {
				 String msg = ""Parser reports unexpected "" + errorLevelName[level] + "": "" + ParseException.errorCodeName(num);
				 println(msg);
				 fail(msg);
			 }
		 }
		 class PositiveTest2 extends NegativeTest2 {
			 String out;
			 boolean outtype;
			 PositiveTest2( String uri, String in, boolean intype, String out, boolean outtype) {
				 this(uri, in, intype, out, outtype, new int[] {
				 }
				);
			 }
			 PositiveTest2( String uri, String in, boolean intype, String out, boolean outtype, int errs[]) {
				 super(uri, in, intype, errs);
				 expectedLevel = -1;
				 this.out = out;
				 this.outtype = outtype;
			 }
			 protected void runTest() {
				 try {
					 Model m2 = read(out, outtype);
					 super.runTest();
					 if (!m1.isIsomorphicWith(m2)) {
						 System.err.println(""====="");
						 m1.write(System.err,""N-TRIPLE"");
						 System.err.println(""====="");
						 m2.write(System.err,""N-TRIPLE"");
						 System.err.println(""====="");
						 fail(""Models were not equal."");
					 }
				 }
				 catch (RuntimeException e) {
					 throw e;
				 }
				 catch (Exception e) {
					 fail(e.getMessage());
				 }
			 }
			 void initExpected() {
				 expected = new HashSet<>();
			 }
		 }
		 class WarningTest2 extends PositiveTest2 {
			 WarningTest2( String uri, String in, boolean intype, String out, boolean outtype, int errs[]) {
				 super(uri, in, intype, out, outtype, errs);
				 expectedLevel = 0;
			 }
		 }
		 class NegativeTest2 extends Test2 {
			 Model m1;
			 Set<Integer> expected;
			 int expectedLevel = 1;
			 String in;
			 boolean intype;
			 private Set<Integer> found = new HashSet<>();
			 private int errorCnt[] = new int[] {
			 0, 0, 0 }
			;
			 NegativeTest2(String uri, String in, boolean intype, int errs[]) {
				 super(uri);
				 this.in = in;
				 this.intype = intype;
				 initExpected(errs);
			 }
			 void initExpected(int errs[]) {
				 if ( errs == null ) return;
				 if (errs.length != 0) expected = new HashSet<>();
				 for ( int err : errs ) {
					 expected.add( Integer.valueOf( err ) );
				 }
			 }
			 protected void runTest() {
				 try {
					 m1 = read(in, intype);
				 }
				 catch (JenaException re) {
					 if (re.getCause() instanceof SAXException) {
					 }
					 else {
						 fail(re.getMessage()+""\n File: ""+in);
					 }
				 }
				 catch (IOException ioe) {
					 fail(ioe.getMessage());
				 }
				 HashSet<Integer> ex2 = expected==null?null:new HashSet<>(expected);
				 if (expected==null) for (int j = 2;
				 j >= 0;
				 j--) if (j != expectedLevel) {
					 if (errorCnt[j] != 0) ex2 = new HashSet<>();
				 }
				 if (ex2 != null && !ex2.equals(found)) {
					 Set<Integer> dup = new HashSet<>();
					 dup.addAll(found);
					 dup.removeAll(ex2);
					 ex2.removeAll(found);
					 if (expected != null) expected.removeAll(found);
					 Iterator<Integer> it = ex2.iterator();
					 while (it.hasNext()) {
						 int eCode = it.next().intValue();
						 String msg = ""Expected error "" + ParseException.errorCodeName(eCode) + "", was not detected."";
						 if (errorCnt[2] == 0) {
							 fail(msg);
						 }
						 else {
							 System.err.println(""Test: "" + getName());
							 System.err.println(msg);
						 }
					 }
					 it = dup.iterator();
					 while (it.hasNext()) fail( ""Detected error "" + ParseException.errorCodeName( it.next().intValue()) + "", was not expected."");
				 }
				 for (int j = 2;
				 j >= 0;
				 j--) if (j == expectedLevel) {
					 if (errorCnt[j] == 0 && (j != 1 || errorCnt[2] == 0)) fail( ""No "" + errorLevelName[expectedLevel] + "" in input file of class "" + getClass().getName());
				 }
				 else if (expected == null) {
					 if (errorCnt[j] != 0) fail( ""Inappropriate "" + errorLevelName[j] + "" in input file of class "" + getClass().getName());
				 }
			 }
			 void onError(int level, int id) {
				 Integer err = Integer.valueOf(id);
				 found.add(err);
				 errorCnt[level]++;
				 if (expected != null) {
					 if (!expected.contains(err)) super.onError(level, id);
				 }
			 }
		 }
		 TestCase createPositiveTest( String uri, String in, boolean intype, String out, boolean outtype) {
			 return new PositiveTest2(uri, in, intype, out, outtype);
		 }
		 TestCase createWarningTest( String uri, String in, boolean intype, String out, boolean outtype, int e[]) {
			 return new WarningTest2(uri, in, intype, out, outtype, e);
		 }
		 TestCase createNegativeTest( String uri, String in, boolean intype, int e[]) {
			 return new NegativeTest2(uri, in, intype, e);
		 }
	}",1,0,0,0
"public abstract class AbstractSshMessage {
	 private static final double ONE_SECOND = 1000.0;
	 private Session session;
	 private boolean verbose;
	 private LogListener listener = new LogListener() {
		 public void log(String message) {
		 }
	 }
	;
	 public AbstractSshMessage(Session session) {
		 this(false, session);
	 }
	 public AbstractSshMessage(boolean verbose, Session session) {
		 this.verbose = verbose;
		 this.session = session;
	 }
	 protected Channel openExecChannel(String command) throws JSchException {
		 ChannelExec channel = (ChannelExec) session.openChannel(""exec"");
		 channel.setCommand(command);
		 return channel;
	 }
	 protected ChannelSftp openSftpChannel() throws JSchException {
		 ChannelSftp channel = (ChannelSftp) session.openChannel(""sftp"");
		 return channel;
	 }
	 protected void sendAck(OutputStream out) throws IOException {
		 byte[] buf = new byte[1];
		 buf[0] = 0;
		 out.write(buf);
		 out.flush();
	 }
	 protected void waitForAck(InputStream in) throws IOException, BuildException {
		 int b = in.read();
		 if (b == -1) {
			 throw new BuildException(""No response from server"");
		 }
		 else if (b != 0) {
			 StringBuffer sb = new StringBuffer();
			 int c = in.read();
			 while (c > 0 && c != '\n') {
				 sb.append((char) c);
				 c = in.read();
			 }
			 if (b == 1) {
				 throw new BuildException(""server indicated an error: "" + sb.toString());
			 }
			 else if (b == 2) {
				 throw new BuildException(""server indicated a fatal error: "" + sb.toString());
			 }
			 else {
				 throw new BuildException(""unknown response, code "" + b + "" message: "" + sb.toString());
			 }
		 }
	 }
	 public abstract void execute() throws IOException, JSchException;
	 public void setLogListener(LogListener aListener) {
		 listener = aListener;
	 }
	 protected void log(String message) {
		 listener.log(message);
	 }
	 protected void logStats(long timeStarted, long timeEnded, long totalLength) {
		 double duration = (timeEnded - timeStarted) / ONE_SECOND;
		 NumberFormat format = NumberFormat.getNumberInstance();
		 format.setMaximumFractionDigits(2);
		 format.setMinimumFractionDigits(1);
		 listener.log(""File transfer time: "" + format.format(duration) + "" Average Rate: "" + format.format(totalLength / duration) + "" B/s"");
	 }
	 protected final boolean getVerbose() {
		 return verbose;
	 }
	 protected final int trackProgress(long filesize, long totalLength, int percentTransmitted) {
		 int percent = (int) Math.round(Math.floor((totalLength / (double) filesize) * 100));
		 if (percent > percentTransmitted) {
			 if (filesize < 1048576) {
				 if (percent % 10 == 0) {
					 if (percent == 100) {
						 System.out.println("" 100%"");
					 }
					 else {
						 System.out.print(""*"");
					 }
				 }
			 }
			 else {
				 if (percent == 50) {
					 System.out.println("" 50%"");
				 }
				 else if (percent == 100) {
					 System.out.println("" 100%"");
				 }
				 else {
					 System.out.print(""."");
				 }
			 }
		 }
		 return percent;
	 }
	 private ProgressMonitor monitor = null;
	 protected SftpProgressMonitor getProgressMonitor() {
		 if (monitor == null) {
			 monitor = new ProgressMonitor();
		 }
		 return monitor;
	 }
	 private class ProgressMonitor implements SftpProgressMonitor {
		 private long initFileSize = 0;
		 private long totalLength = 0;
		 private int percentTransmitted = 0;
		 public void init(int op, String src, String dest, long max) {
			 initFileSize = max;
			 totalLength = 0;
			 percentTransmitted = 0;
		 }
		 public boolean count(long len) {
			 totalLength += len;
			 percentTransmitted = trackProgress(initFileSize, totalLength, percentTransmitted);
			 return true;
		 }
		 public void end() {
		 }
		 public long getTotalLength() {
			 return totalLength;
		 }
	 }
}",0,0,0,0
"public class GlobalSqlStddevPopAggregateDescriptor extends AbstractAggregateFunctionDynamicDescriptor {
	 private static final long serialVersionUID = 1L;
	 public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() {
		 public IFunctionDescriptor createFunctionDescriptor() {
			 return new GlobalSqlStddevPopAggregateDescriptor();
		 }
	 }
	;
	 public FunctionIdentifier getIdentifier() {
		 return BuiltinFunctions.GLOBAL_SQL_STDDEV_POP;
	 }
	 public IAggregateEvaluatorFactory createAggregateEvaluatorFactory(final IScalarEvaluatorFactory[] args) {
		 return new IAggregateEvaluatorFactory() {
			 private static final long serialVersionUID = 1L;
			 public IAggregateEvaluator createAggregateEvaluator(final IHyracksTaskContext ctx) throws HyracksDataException {
				 return new GlobalSqlStddevAggregateFunction(args, ctx, true, sourceLoc);
			 }
		 }
		;
	 }
}",0,0,0,0
"protected HSSFCellStyle getLoadedCellStyle(short mode,short backcolor,short horizontalAlignment,short verticalAlignment,short rotation,HSSFFont font,JRExporterGridCell gridCell);",0,0,0,1
"public class GwtDeviceServiceImpl extends KapuaRemoteServiceServlet implements GwtDeviceService {
	 private static final long serialVersionUID = -1391026997499175151L;
	 private static final KapuaLocator LOCATOR = KapuaLocator.getInstance();
	 private static final AuthorizationService AUTHORIZATION_SERVICE = LOCATOR.getService(AuthorizationService.class);
	 private static final PermissionFactory PERMISSION_FACTORY = LOCATOR.getFactory(PermissionFactory.class);
	 private boolean isSameId;
	 public GwtDevice findDevice(String scopeIdString, String deviceIdString) throws GwtKapuaException {
		 GwtDevice gwtDevice = null;
		 try {
			 KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
			 KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
			 KapuaLocator locator = KapuaLocator.getInstance();
			 DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
			 Device device = deviceRegistryService.find(scopeId, deviceId);
			 gwtDevice = KapuaGwtDeviceModelConverter.convertDevice(device);
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
		 return gwtDevice;
	 }
	 public ListLoadResult<GwtGroupedNVPair> findDeviceProfile(String scopeIdString, String deviceIdString) throws GwtKapuaException {
		 List<GwtGroupedNVPair> pairs = new ArrayList<GwtGroupedNVPair>();
		 KapuaLocator locator = KapuaLocator.getInstance();
		 DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
		 DeviceEventService deviceEventService = locator.getService(DeviceEventService.class);
		 final DeviceConnectionService deviceConnectionService = locator.getService(DeviceConnectionService.class);
		 GroupService groupService = locator.getService(GroupService.class);
		 final UserService userService = locator.getService(UserService.class);
		 try {
			 final KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
			 KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
			 final Device device = deviceRegistryService.find(scopeId, deviceId);
			 if (device != null) {
				 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devStatus"", device.getStatus().toString()));
				 final DeviceConnection deviceConnection;
				 if (device.getConnectionId() != null) {
					 if (device.getConnection() != null) {
						 deviceConnection = device.getConnection();
					 }
					 else {
						 deviceConnection = KapuaSecurityUtils.doPrivileged(new Callable<DeviceConnection>() {
							 public DeviceConnection call() throws Exception {
								 return deviceConnectionService.find(device.getScopeId(), device.getConnectionId());
							 }
						 }
						);
					 }
				 }
				 else {
					 deviceConnection = null;
				 }
				 if (deviceConnection != null) {
					 User lastConnectedUser = KapuaSecurityUtils.doPrivileged(new Callable<User>() {
						 public User call() throws Exception {
							 return userService.find(scopeId, deviceConnection.getUserId());
						 }
					 }
					);
					 User reservedUser = null;
					 if (deviceConnection.getReservedUserId() != null) {
						 reservedUser = KapuaSecurityUtils.doPrivileged(new Callable<User>() {
							 public User call() throws Exception {
								 return userService.find(scopeId, deviceConnection.getReservedUserId());
							 }
						 }
						);
					 }
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connConnectionStatus"", deviceConnection.getStatus().toString()));
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientId"", device.getClientId()));
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserName"", lastConnectedUser != null ? lastConnectedUser.getName() : null));
					 if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(new UserDomain(), Actions.read, scopeId))) {
						 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connReservedUserId"", reservedUser != null ? reservedUser.getName() : null));
					 }
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserCouplingMode"", GwtConnectionUserCouplingMode.valueOf(deviceConnection.getUserCouplingMode().name()).getLabel()));
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientIp"", deviceConnection.getClientIp()));
					 pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIface"", device.getConnectionInterface()));
					 pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIp"", deviceConnection.getClientIp()));
					 pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIfaceIp"", device.getConnectionIp()));
					 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devConnectionStatus"", deviceConnection.getStatus().toString()));
				 }
				 else {
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connConnectionStatus"", DeviceConnectionStatus.DISCONNECTED.toString()));
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientId"", null));
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserName"", null));
					 if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(new UserDomain(), Actions.read, scopeId))) {
						 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connReservedUserId"", null));
					 }
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserCouplingMode"", null));
					 pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientIp"", null));
					 pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIface"", null));
					 pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIp"", null));
					 pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIfaceIp"", null));
					 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devConnectionStatus"", DeviceConnectionStatus.DISCONNECTED.toString()));
				 }
				 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devClientId"", device.getClientId()));
				 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devDisplayName"", device.getDisplayName()));
				 if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(new GroupDomain(), Actions.read, device.getScopeId()))) {
					 if (device.getGroupId() != null) {
						 Group group = groupService.find(scopeId, device.getGroupId());
						 if (group != null) {
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devGroupName"", group.getName()));
						 }
					 }
					 else {
						 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devGroupName"", null));
					 }
				 }
				 if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(DeviceDomains.DEVICE_EVENT_DOMAIN, Actions.read, device.getScopeId()))) {
					 if (device.getLastEventId() != null) {
						 DeviceEvent lastEvent = deviceEventService.find(scopeId, device.getLastEventId());
						 if (lastEvent != null) {
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", lastEvent.getResource()));
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", lastEvent.getReceivedOn()));
						 }
						 else {
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", null));
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", null));
						 }
					 }
					 else {
						 if (deviceConnection != null) {
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", deviceConnection.getStatus().name()));
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", deviceConnection.getModifiedOn()));
						 }
						 else {
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", null));
							 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", null));
						 }
					 }
				 }
				 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devApps"", device.getApplicationIdentifiers()));
				 pairs.add(new GwtGroupedNVPair(""devInfo"", ""devAccEnc"", device.getAcceptEncoding()));
				 pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute1"", device.getCustomAttribute1()));
				 pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute2"", device.getCustomAttribute2()));
				 pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute3"", device.getCustomAttribute3()));
				 pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute4"", device.getCustomAttribute4()));
				 pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute5"", device.getCustomAttribute5()));
				 pairs.add(new GwtGroupedNVPair(""devHw"", ""devModelId"", device.getModelId()));
				 pairs.add(new GwtGroupedNVPair(""devHw"", ""devModelName"", device.getModelName()));
				 pairs.add(new GwtGroupedNVPair(""devHw"", ""devSerialNumber"", device.getSerialNumber()));
				 pairs.add(new GwtGroupedNVPair(""devSw"", ""devFirmwareVersion"", device.getFirmwareVersion()));
				 pairs.add(new GwtGroupedNVPair(""devSw"", ""devBiosVersion"", device.getBiosVersion()));
				 pairs.add(new GwtGroupedNVPair(""devSw"", ""devOsVersion"", device.getOsVersion()));
				 pairs.add(new GwtGroupedNVPair(""devJava"", ""devJvmVersion"", device.getJvmVersion()));
				 if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(DeviceDomains.DEVICE_EVENT_DOMAIN, Actions.read, device.getScopeId()))) {
					 DeviceEventFactory deviceEventFactory = locator.getFactory(DeviceEventFactory.class);
					 DeviceEventQuery eventQuery = deviceEventFactory .newQuery(device.getScopeId());
					 eventQuery.setLimit(1);
					 eventQuery.setSortCriteria(new FieldSortCriteria(DeviceEventAttributes.RECEIVED_ON, SortOrder.DESCENDING));
					 AndPredicateImpl andPredicate = new AndPredicateImpl();
					 andPredicate.and(new AttributePredicateImpl<KapuaId>(DeviceEventAttributes.DEVICE_ID, device.getId()));
					 andPredicate.and(new AttributePredicateImpl<String>(DeviceEventAttributes.RESOURCE, ""BIRTH""));
					 eventQuery.setPredicate(andPredicate);
					 KapuaListResult<DeviceEvent> events = deviceEventService.query(eventQuery);
					 DeviceEvent lastEvent = events.getFirstItem();
					 if (lastEvent != null) {
						 KapuaPosition eventPosition = lastEvent.getPosition();
						 if (eventPosition != null) {
							 pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLat"", String.valueOf(eventPosition.getLatitude())));
							 pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLong"", String.valueOf(eventPosition.getLongitude())));
						 }
					 }
					 else {
						 pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLat"", null));
						 pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLong"", null));
					 }
				 }
				 pairs.add(new GwtGroupedNVPair(""modemInfo"", ""modemImei"", device.getImei()));
				 pairs.add(new GwtGroupedNVPair(""modemInfo"", ""modemImsi"", device.getImsi()));
				 pairs.add(new GwtGroupedNVPair(""modemInfo"", ""modemIccid"", device.getIccid()));
			 }
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
		 return new BaseListLoadResult<GwtGroupedNVPair>(pairs);
	 }
	 public PagingLoadResult<GwtDevice> query(PagingLoadConfig loadConfig, GwtDeviceQuery gwtDeviceQuery) throws GwtKapuaException {
		 KapuaLocator locator = KapuaLocator.getInstance();
		 DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
		 List<GwtDevice> gwtDevices = new ArrayList<GwtDevice>();
		 BasePagingLoadResult<GwtDevice> gwtResults;
		 int totalResult = 0;
		 try {
			 DeviceQuery deviceQuery = GwtKapuaDeviceModelConverter.convertDeviceQuery(loadConfig, gwtDeviceQuery);
			 deviceQuery.addFetchAttributes(DeviceAttributes.CONNECTION);
			 deviceQuery.addFetchAttributes(DeviceAttributes.LAST_EVENT);
			 KapuaListResult<Device> devices = deviceRegistryService.query(deviceQuery);
			 totalResult = (int) deviceRegistryService.count(deviceQuery);
			 for (Device d : devices.getItems()) {
				 GwtDevice gwtDevice = KapuaGwtDeviceModelConverter.convertDevice(d);
				 gwtDevice.setConnectionIp(d.getConnectionIp());
				 gwtDevice.setConnectionInterface(d.getConnectionInterface());
				 DeviceConnection deviceConnection = d.getConnection();
				 if (deviceConnection != null) {
					 gwtDevice.setClientIp(deviceConnection.getClientIp());
					 gwtDevice.setGwtDeviceConnectionStatus(deviceConnection.getStatus().name());
					 gwtDevice.setLastEventOn(deviceConnection.getModifiedOn());
					 gwtDevice.setLastEventType(deviceConnection.getStatus().name());
				 }
				 else {
					 gwtDevice.setGwtDeviceConnectionStatus(GwtDeviceConnectionStatus.UNKNOWN.name());
				 }
				 if (d.getLastEvent() != null) {
					 DeviceEvent lastEvent = d.getLastEvent();
					 gwtDevice.setLastEventType(lastEvent.getResource());
					 gwtDevice.setLastEventOn(lastEvent.getReceivedOn());
				 }
				 gwtDevices.add(gwtDevice);
			 }
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
		 gwtResults = new BasePagingLoadResult<GwtDevice>(gwtDevices);
		 gwtResults.setOffset(loadConfig != null ? loadConfig.getOffset() : 0);
		 gwtResults.setTotalLength(totalResult);
		 return gwtResults;
	 }
	 public List<GwtDevice> query(GwtDeviceQuery gwtDeviceQuery) throws GwtKapuaException {
		 return query(null, gwtDeviceQuery).getData();
	 }
	 public GwtDevice createDevice(GwtXSRFToken xsrfToken, GwtDeviceCreator gwtDeviceCreator) throws GwtKapuaException {
		 checkXSRFToken(xsrfToken);
		 KapuaLocator locator = KapuaLocator.getInstance();
		 DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
		 DeviceFactory deviceFactory = locator.getFactory(DeviceFactory.class);
		 GwtDevice gwtDevice = null;
		 try {
			 KapuaId scopeId = KapuaEid.parseCompactId(gwtDeviceCreator.getScopeId());
			 DeviceCreator deviceCreator = deviceFactory.newCreator(scopeId, gwtDeviceCreator.getClientId());
			 deviceCreator.setDisplayName(gwtDeviceCreator.getDisplayName());
			 deviceCreator.setGroupId(GwtKapuaCommonsModelConverter.convertKapuaId(gwtDeviceCreator.getGroupId()));
			 deviceCreator.setStatus((DeviceStatus.valueOf(gwtDeviceCreator.getDeviceStatus())));
			 deviceCreator.setCustomAttribute1(gwtDeviceCreator.getCustomAttribute1());
			 deviceCreator.setCustomAttribute2(gwtDeviceCreator.getCustomAttribute2());
			 deviceCreator.setCustomAttribute3(gwtDeviceCreator.getCustomAttribute3());
			 deviceCreator.setCustomAttribute4(gwtDeviceCreator.getCustomAttribute4());
			 deviceCreator.setCustomAttribute5(gwtDeviceCreator.getCustomAttribute5());
			 Device device = deviceRegistryService.create(deviceCreator);
			 gwtDevice = KapuaGwtDeviceModelConverter.convertDevice(device);
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
		 return gwtDevice;
	 }
	 public GwtDevice updateAttributes(GwtXSRFToken xsrfToken, GwtDevice gwtDevice) throws GwtKapuaException {
		 checkXSRFToken(xsrfToken);
		 KapuaLocator locator = KapuaLocator.getInstance();
		 DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
		 Device device = null;
		 GwtDevice gwtDeviceUpdated = null;
		 try {
			 KapuaId scopeId = KapuaEid.parseCompactId(gwtDevice.getScopeId());
			 KapuaId deviceId = KapuaEid.parseCompactId(gwtDevice.getId());
			 device = deviceRegistryService.find(scopeId, deviceId);
			 device.setDisplayName(gwtDevice.getUnescapedDisplayName());
			 device.setStatus(DeviceStatus.valueOf(gwtDevice.getGwtDeviceStatus()));
			 device.setGroupId(GwtKapuaCommonsModelConverter.convertKapuaId(gwtDevice.getGroupId()));
			 device.setCustomAttribute1(gwtDevice.getUnescapedCustomAttribute1());
			 device.setCustomAttribute2(gwtDevice.getUnescapedCustomAttribute2());
			 device.setCustomAttribute3(gwtDevice.getUnescapedCustomAttribute3());
			 device.setCustomAttribute4(gwtDevice.getUnescapedCustomAttribute4());
			 device.setCustomAttribute5(gwtDevice.getUnescapedCustomAttribute5());
			 device.setOptlock(gwtDevice.getOptlock());
			 device = deviceRegistryService.update(device);
			 gwtDeviceUpdated = KapuaGwtDeviceModelConverter.convertDevice(device);
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
		 return gwtDeviceUpdated;
	 }
	 public void deleteDevice(GwtXSRFToken xsrfToken, String scopeIdString, String clientId) throws GwtKapuaException {
		 checkXSRFToken(xsrfToken);
		 try {
			 KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
			 KapuaLocator locator = KapuaLocator.getInstance();
			 DeviceRegistryService drs = locator.getService(DeviceRegistryService.class);
			 Device d = drs.findByClientId(scopeId, clientId);
			 drs.delete(d.getScopeId(), d.getId());
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
	 }
	 public void addDeviceTag(GwtXSRFToken xsrfToken, String scopeIdString, String deviceIdString, String tagIdString) throws GwtKapuaException {
		 checkXSRFToken(xsrfToken);
		 try {
			 KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
			 KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
			 KapuaId tagId = KapuaEid.parseCompactId(tagIdString);
			 KapuaLocator locator = KapuaLocator.getInstance();
			 DeviceRegistryService drs = locator.getService(DeviceRegistryService.class);
			 TagService tagService = locator.getService(TagService.class);
			 Device device = drs.find(scopeId, deviceId);
			 Set<KapuaId> tagIds = device.getTagIds();
			 if (tagIds.contains(tagId)) {
				 Tag tag = tagService.find(scopeId, tagId);
				 isSameId = true;
				 if (tag != null) {
					 throw new KapuaDuplicateNameException(tag.getName());
				 }
			 }
			 tagIds.add(tagId);
			 device.setTagIds(tagIds);
			 drs.update(device);
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
	 }
	 public void deleteDeviceTag(GwtXSRFToken xsrfToken, String scopeIdString, String deviceIdString, String tagIdString) throws GwtKapuaException {
		 checkXSRFToken(xsrfToken);
		 try {
			 KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
			 KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
			 KapuaId tagId = KapuaEid.parseCompactId(tagIdString);
			 KapuaLocator locator = KapuaLocator.getInstance();
			 DeviceRegistryService drs = locator.getService(DeviceRegistryService.class);
			 Device device = drs.find(scopeId, deviceId);
			 Set<KapuaId> tagIds = device.getTagIds();
			 tagIds.remove(tagId);
			 device.setTagIds(tagIds);
			 drs.update(device);
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
	 }
	 public PagingLoadResult<GwtDeviceEvent> findDeviceEvents(PagingLoadConfig loadConfig, GwtDevice gwtDevice, Date startDate, Date endDate) throws GwtKapuaException {
		 ArrayList<GwtDeviceEvent> gwtDeviceEvents = new ArrayList<GwtDeviceEvent>();
		 BasePagingLoadResult<GwtDeviceEvent> gwtResults = null;
		 KapuaLocator locator = KapuaLocator.getInstance();
		 DeviceEventService des = locator.getService(DeviceEventService.class);
		 DeviceEventFactory deviceEventFactory = locator.getFactory(DeviceEventFactory.class);
		 try {
			 BasePagingLoadConfig bplc = (BasePagingLoadConfig) loadConfig;
			 DeviceEventQuery query = deviceEventFactory.newQuery(KapuaEid.parseCompactId(gwtDevice.getScopeId()));
			 AndPredicate andPredicate = new AndPredicateImpl();
			 andPredicate.and(new AttributePredicateImpl<KapuaId>(DeviceEventAttributes.DEVICE_ID, KapuaEid.parseCompactId(gwtDevice.getId())));
			 andPredicate.and(new AttributePredicateImpl<Date>(DeviceEventAttributes.RECEIVED_ON, startDate, Operator.GREATER_THAN));
			 andPredicate.and(new AttributePredicateImpl<Date>(DeviceEventAttributes.RECEIVED_ON, endDate, Operator.LESS_THAN));
			 query.setPredicate(andPredicate);
			 query.setSortCriteria(new FieldSortCriteria(DeviceEventAttributes.RECEIVED_ON, SortOrder.DESCENDING));
			 query.setOffset(bplc.getOffset());
			 query.setLimit(bplc.getLimit());
			 KapuaListResult<DeviceEvent> deviceEvents = des.query(query);
			 for (DeviceEvent deviceEvent : deviceEvents.getItems()) {
				 gwtDeviceEvents.add(KapuaGwtDeviceModelConverter.convertDeviceEvent(deviceEvent));
			 }
			 gwtResults = new BasePagingLoadResult<GwtDeviceEvent>(gwtDeviceEvents);
			 gwtResults.setOffset(loadConfig.getOffset());
			 gwtResults.setTotalLength((int) des.count(query));
		 }
		 catch (Throwable t) {
			 KapuaExceptionHandler.handle(t);
		 }
		 return gwtResults;
	 }
	 public String getTileEndpoint() throws GwtKapuaException {
		 return ConsoleSetting.getInstance().getString(ConsoleSettingKeys.DEVICE_MAP_TILE_URI);
	 }
	 public boolean isMapEnabled() {
		 return ConsoleSetting.getInstance().getBoolean(ConsoleSettingKeys.DEVICE_MAP_ENABLED);
	 }
}",1,0,0,0
"public T getObject(){
	return listView.getModelObject().get(index);
}",0,0,0,0
"public CredentialPromptDialog(String prompt) {
	 setAlwaysOnTop(true);
	 setTitle(BundleMessage.format(""UI_KERBEROS_CREDENTIAL_PROMPT""));
	 try {
		 setIconImage(DavGatewayTray.getFrameIcon());
	 }
	 catch (NoSuchMethodError error) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
	 }
	 JPanel questionPanel = new JPanel();
	 questionPanel.setLayout(new BoxLayout(questionPanel, BoxLayout.Y_AXIS));
	 JLabel imageLabel = new JLabel();
	 imageLabel.setIcon(UIManager.getIcon(""OptionPane.questionIcon""));
	 questionPanel.add(imageLabel);
	 passwordField.setMaximumSize(passwordField.getPreferredSize());
	 passwordField.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
			 principal = principalField.getText();
			 password = passwordField.getPassword();
			 setVisible(false);
		 }
	 }
	);
	 JPanel credentialPanel = new JPanel(new GridLayout(2, 2));
	 JLabel promptLabel = new JLabel(' ' +prompt.trim());
	 promptLabel.setHorizontalAlignment(SwingConstants.RIGHT);
	 promptLabel.setVerticalAlignment(SwingConstants.CENTER);
	 credentialPanel.add(promptLabel);
	 principalField.setMaximumSize(principalField.getPreferredSize());
	 credentialPanel.add(principalField);
	 JLabel passwordLabel = new JLabel(BundleMessage.format(""UI_KERBEROS_PASSWORD_PROMPT""));
	 passwordLabel.setHorizontalAlignment(SwingConstants.RIGHT);
	 passwordLabel.setVerticalAlignment(SwingConstants.CENTER);
	 credentialPanel.add(passwordLabel);
	 passwordField.setMaximumSize(passwordField.getPreferredSize());
	 credentialPanel.add(passwordField);
	 add(questionPanel, BorderLayout.WEST);
	 add(credentialPanel, BorderLayout.CENTER);
	 add(getButtonPanel(), BorderLayout.SOUTH);
	 setModal(true);
	 pack();
	 setLocation(getToolkit().getScreenSize().width / 2 - getSize().width / 2, getToolkit().getScreenSize().height / 2 - getSize().height / 2);
	 setAlwaysOnTop(true);
	 setVisible(true);
 }",0,0,1,0
"public final void rule__FunctionTypeExpressionOLD__Group__9() throws RecognitionException {
	 int stackSize = keepStackSize();
	 try {
		 {
			 pushFollow(FOLLOW_2);
			 rule__FunctionTypeExpressionOLD__Group__9__Impl();
			 state._fsp--;
			 if (state.failed) return ;
		 }
	 }
	 catch (RecognitionException re) {
		 reportError(re);
		 recover(input,re);
	 }
	 finally {
		 restoreStackSize(stackSize);
	 }
	 return ;
 }",0,0,1,0
"public class GpuResourceHandlerImpl implements ResourceHandler {
	 final static Logger LOG = LoggerFactory .getLogger(GpuResourceHandlerImpl.class);
	 public static final String EXCLUDED_GPUS_CLI_OPTION = ""--excluded_gpus"";
	 public static final String CONTAINER_ID_CLI_OPTION = ""--container_id"";
	 private final Context nmContext;
	 private final GpuResourceAllocator gpuAllocator;
	 private final CGroupsHandler cGroupsHandler;
	 private final PrivilegedOperationExecutor privilegedOperationExecutor;
	 private final GpuDiscoverer gpuDiscoverer;
	 public GpuResourceHandlerImpl(Context nmContext, CGroupsHandler cGroupsHandler, PrivilegedOperationExecutor privilegedOperationExecutor, GpuDiscoverer gpuDiscoverer) {
		 this.nmContext = nmContext;
		 this.cGroupsHandler = cGroupsHandler;
		 this.privilegedOperationExecutor = privilegedOperationExecutor;
		 this.gpuAllocator = new GpuResourceAllocator(nmContext);
		 this.gpuDiscoverer = gpuDiscoverer;
	 }
	 public List<PrivilegedOperation> bootstrap(Configuration configuration) throws ResourceHandlerException {
		 List<GpuDevice> usableGpus;
		 try {
			 usableGpus = gpuDiscoverer.getGpusUsableByYarn();
			 if (usableGpus == null || usableGpus.isEmpty()) {
				 String message = ""GPU is enabled on the NodeManager, but couldn't find "" + ""any usable GPU devices, please double check configuration!"";
				 LOG.error(message);
				 throw new ResourceHandlerException(message);
			 }
		 }
		 catch (YarnException e) {
			 LOG.error(""Exception when trying to get usable GPU device"", e);
			 throw new ResourceHandlerException(e);
		 }
		 for (GpuDevice gpu : usableGpus) {
			 gpuAllocator.addGpu(gpu);
		 }
		 this.cGroupsHandler.initializeCGroupController( CGroupsHandler.CGroupController.DEVICES);
		 return null;
	 }
	 public synchronized List<PrivilegedOperation> preStart(Container container) throws ResourceHandlerException {
		 String containerIdStr = container.getContainerId().toString();
		 GpuResourceAllocator.GpuAllocation allocation = gpuAllocator.assignGpus( container);
		 cGroupsHandler.createCGroup(CGroupsHandler.CGroupController.DEVICES, containerIdStr);
		 if (!DockerLinuxContainerRuntime.isDockerContainerRequested( nmContext.getConf(), container.getLaunchContext().getEnvironment())) {
			 try {
				 PrivilegedOperation privilegedOperation = new PrivilegedOperation( PrivilegedOperation.OperationType.GPU, Arrays.asList(CONTAINER_ID_CLI_OPTION, containerIdStr));
				 if (!allocation.getDeniedGPUs().isEmpty()) {
					 List<Integer> minorNumbers = new ArrayList<>();
					 for (GpuDevice deniedGpu : allocation.getDeniedGPUs()) {
						 minorNumbers.add(deniedGpu.getMinorNumber());
					 }
					 privilegedOperation.appendArgs(Arrays.asList(EXCLUDED_GPUS_CLI_OPTION, StringUtils.join("","", minorNumbers)));
				 }
				 privilegedOperationExecutor.executePrivilegedOperation( privilegedOperation, true);
			 }
			 catch (PrivilegedOperationException e) {
				 cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES, containerIdStr);
				 LOG.warn(""Could not update cgroup for container"", e);
				 throw new ResourceHandlerException(e);
			 }
			 List<PrivilegedOperation> ret = new ArrayList<>();
			 ret.add(new PrivilegedOperation( PrivilegedOperation.OperationType.ADD_PID_TO_CGROUP, PrivilegedOperation.CGROUP_ARG_PREFIX + cGroupsHandler .getPathForCGroupTasks(CGroupsHandler.CGroupController.DEVICES, containerIdStr)));
			 return ret;
		 }
		 return null;
	 }
	 public GpuResourceAllocator getGpuAllocator() {
		 return gpuAllocator;
	 }
	 public List<PrivilegedOperation> reacquireContainer(ContainerId containerId) throws ResourceHandlerException {
		 gpuAllocator.recoverAssignedGpus(containerId);
		 return null;
	 }
	 public List<PrivilegedOperation> updateContainer(Container container) throws ResourceHandlerException {
		 return null;
	 }
	 public synchronized List<PrivilegedOperation> postComplete( ContainerId containerId) throws ResourceHandlerException {
		 gpuAllocator.cleanupAssignGpus(containerId);
		 cGroupsHandler.deleteCGroup(CGroupsHandler.CGroupController.DEVICES, containerId.toString());
		 return null;
	 }
	 public List<PrivilegedOperation> teardown() throws ResourceHandlerException {
		 return null;
	 }
	 public String toString() {
		 return GpuResourceHandlerImpl.class.getName() + ""{
		"" + ""gpuAllocator="" + gpuAllocator + '}
		';
	 }
}",0,0,0,0
"public void injectURLFile(File urlList) throws IOException {
	 nextFetch = urlList.lastModified();
	 BufferedReader reader = new BufferedReader(new FileReader(urlList));
	 try {
		 String curStr = null;
		 LOG.info(""Starting URL processing"");
		 while ((curStr = reader.readLine()) != null) {
			 String url = curStr.trim();
			 if (addPage(url)) this.pages++;
			 printStatusBar(2000,50000);
		 }
		 LOG.info(""Added "" + pages + "" pages"");
	 }
	 catch (Exception e) {
		 LOG.severe(""error while injecting:"" + e);
		 e.printStackTrace();
	 }
	 finally {
		 reader.close();
	 }
 }",0,0,0,0
"protected void reBuffer() throws IOException {
	 resetBuffer();
	 if (bufferOffset >= channel.size()) return;
	 channel.position(bufferOffset);
	 int read = 0;
	 while (read < buffer.length) {
		 int n = super.read(buffer, read, buffer.length - read);
		 if (n < 0) break;
		 read += n;
	 }
	 validBufferBytes = read;
	 bytesSinceCacheFlush += read;
	 if (skipIOCache && bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE) {
		 CLibrary.trySkipCache(this.fd, 0, 0);
		 bytesSinceCacheFlush = 0;
	 }
 }",0,0,0,0
"private static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {
	 int lengthDataBits = binaryData.length * EIGHTBIT;
	 int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;
	 int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;
	 byte encodedData[] = null;
	 int encodedDataLength = 0;
	 int nbrChunks = 0;
	 if (fewerThan24bits != 0) {
		 encodedDataLength = (numberTriplets + 1) * 4;
	 }
	 else {
		 encodedDataLength = numberTriplets * 4;
	 }
	 if (isChunked) {
		 nbrChunks = (CHUNK_SEPARATOR.length == 0 ? 0 : (int)Math.ceil((float)encodedDataLength / CHUNK_SIZE));
		 encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;
	 }
	 encodedData = new byte[encodedDataLength];
	 byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;
	 int encodedIndex = 0;
	 int dataIndex = 0;
	 int i = 0;
	 int nextSeparatorIndex = CHUNK_SIZE;
	 int chunksSoFar = 0;
	 for (i = 0;
	 i < numberTriplets;
	 i++) {
		 dataIndex = i * 3;
		 b1 = binaryData[dataIndex];
		 b2 = binaryData[dataIndex + 1];
		 b3 = binaryData[dataIndex + 2];
		 l = (byte)(b2 & 0x0f);
		 k = (byte)(b1 & 0x03);
		 byte val1 = ((b1 & SIGN) == 0) ? (byte)(b1 >> 2) : (byte)((b1) >> 2 ^ 0xc0);
		 byte val2 = ((b2 & SIGN) == 0) ? (byte)(b2 >> 4) : (byte)((b2) >> 4 ^ 0xf0);
		 byte val3 = ((b3 & SIGN) == 0) ? (byte)(b3 >> 6) : (byte)((b3) >> 6 ^ 0xfc);
		 encodedData[encodedIndex] = lookUpBase64Alphabet[val1];
		 encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];
		 encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];
		 encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];
		 encodedIndex += 4;
		 if (isChunked) {
			 if (encodedIndex == nextSeparatorIndex) {
				 System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);
				 chunksSoFar++;
				 nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);
				 encodedIndex += CHUNK_SEPARATOR.length;
			 }
		 }
	 }
	 dataIndex = i * 3;
	 if (fewerThan24bits == EIGHTBIT) {
		 b1 = binaryData[dataIndex];
		 k = (byte)(b1 & 0x03);
		 byte val1 = ((b1 & SIGN) == 0) ? (byte)(b1 >> 2) : (byte)((b1) >> 2 ^ 0xc0);
		 encodedData[encodedIndex] = lookUpBase64Alphabet[val1];
		 encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];
		 encodedData[encodedIndex + 2] = PAD;
		 encodedData[encodedIndex + 3] = PAD;
	 }
	 else if (fewerThan24bits == SIXTEENBIT) {
		 b1 = binaryData[dataIndex];
		 b2 = binaryData[dataIndex + 1];
		 l = (byte)(b2 & 0x0f);
		 k = (byte)(b1 & 0x03);
		 byte val1 = ((b1 & SIGN) == 0) ? (byte)(b1 >> 2) : (byte)((b1) >> 2 ^ 0xc0);
		 byte val2 = ((b2 & SIGN) == 0) ? (byte)(b2 >> 4) : (byte)((b2) >> 4 ^ 0xf0);
		 encodedData[encodedIndex] = lookUpBase64Alphabet[val1];
		 encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];
		 encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];
		 encodedData[encodedIndex + 3] = PAD;
	 }
	 if (isChunked) {
		 if (chunksSoFar < nbrChunks) {
			 System.arraycopy( CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);
		 }
	 }
	 return encodedData;
 }",0,0,1,0
"public class TemporalIntervalStartDatetimeAccessor extends AbstractScalarFunctionDynamicDescriptor {
	 private static final long serialVersionUID = 1L;
	 private static final FunctionIdentifier FID = BuiltinFunctions.ACCESSOR_TEMPORAL_INTERVAL_START_DATETIME;
	 public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory() {
		 public IFunctionDescriptor createFunctionDescriptor() {
			 return new TemporalIntervalStartDatetimeAccessor();
		 }
	 }
	;
	 public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) {
		 return new IScalarEvaluatorFactory() {
			 private static final long serialVersionUID = 1L;
			 public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException {
				 return new IScalarEvaluator() {
					 private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage();
					 private final DataOutput out = resultStorage.getDataOutput();
					 private final IPointable argPtr = new VoidPointable();
					 private final IScalarEvaluator eval = args[0].createScalarEvaluator(ctx);
					 private final ISerializerDeserializer<ADateTime> datetimeSerde = SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADATETIME);
					 private final AMutableDateTime aDateTime = new AMutableDateTime(0);
					 public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException {
						 eval.evaluate(tuple, argPtr);
						 byte[] bytes = argPtr.getByteArray();
						 int startOffset = argPtr.getStartOffset();
						 resultStorage.reset();
						 try {
							 if (bytes[startOffset] == ATypeTag.SERIALIZED_INTERVAL_TYPE_TAG) {
								 byte timeType = AIntervalSerializerDeserializer.getIntervalTimeType(bytes, startOffset + 1);
								 long startTime = AIntervalSerializerDeserializer.getIntervalStart(bytes, startOffset + 1);
								 if (timeType == ATypeTag.SERIALIZED_DATETIME_TYPE_TAG) {
									 aDateTime.setValue(startTime);
									 datetimeSerde.serialize(aDateTime, out);
								 }
								 else {
									 throw new InvalidDataFormatException(sourceLoc, getIdentifier(), ATypeTag.SERIALIZED_INTERVAL_TYPE_TAG);
								 }
							 }
							 else {
								 throw new TypeMismatchException(sourceLoc, getIdentifier(), 0, bytes[startOffset], ATypeTag.SERIALIZED_INTERVAL_TYPE_TAG);
							 }
						 }
						 catch (IOException e) {
							 throw HyracksDataException.create(e);
						 }
						 result.set(resultStorage);
					 }
				 }
				;
			 }
		 }
		;
	 }
	 public FunctionIdentifier getIdentifier() {
		 return FID;
	 }
}",1,0,0,0
"final class NativeDate extends IdScriptableObject{
	 static final long serialVersionUID = -8307438915861678966L;
	 private static final Object DATE_TAG = new Object();
	 private static final String js_NaN_date_str = ""Invalid Date"";
	 static void init(Scriptable scope, boolean sealed) {
		 NativeDate obj = new NativeDate();
		 obj.date = ScriptRuntime.NaN;
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeDate() {
		 if (thisTimeZone == null) {
			 thisTimeZone = java.util.TimeZone.getDefault();
			 LocalTZA = thisTimeZone.getRawOffset();
		 }
	 }
	 public String getClassName() {
		 return ""Date"";
	 }
	 public Object getDefaultValue(Class typeHint) {
		 if (typeHint == null) typeHint = ScriptRuntime.StringClass;
		 return super.getDefaultValue(typeHint);
	 }
	 double getJSTimeValue() {
		 return date;
	 }
	 protected void fillConstructorProperties(IdFunctionObject ctor) {
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_now, ""now"", 0);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_parse, ""parse"", 1);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_UTC, ""UTC"", 1);
		 super.fillConstructorProperties(ctor);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toTimeString: arity=0;
			 s=""toTimeString"";
			 break;
			 case Id_toDateString: arity=0;
			 s=""toDateString"";
			 break;
			 case Id_toLocaleString: arity=0;
			 s=""toLocaleString"";
			 break;
			 case Id_toLocaleTimeString: arity=0;
			 s=""toLocaleTimeString"";
			 break;
			 case Id_toLocaleDateString: arity=0;
			 s=""toLocaleDateString"";
			 break;
			 case Id_toUTCString: arity=0;
			 s=""toUTCString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_valueOf: arity=0;
			 s=""valueOf"";
			 break;
			 case Id_getTime: arity=0;
			 s=""getTime"";
			 break;
			 case Id_getYear: arity=0;
			 s=""getYear"";
			 break;
			 case Id_getFullYear: arity=0;
			 s=""getFullYear"";
			 break;
			 case Id_getUTCFullYear: arity=0;
			 s=""getUTCFullYear"";
			 break;
			 case Id_getMonth: arity=0;
			 s=""getMonth"";
			 break;
			 case Id_getUTCMonth: arity=0;
			 s=""getUTCMonth"";
			 break;
			 case Id_getDate: arity=0;
			 s=""getDate"";
			 break;
			 case Id_getUTCDate: arity=0;
			 s=""getUTCDate"";
			 break;
			 case Id_getDay: arity=0;
			 s=""getDay"";
			 break;
			 case Id_getUTCDay: arity=0;
			 s=""getUTCDay"";
			 break;
			 case Id_getHours: arity=0;
			 s=""getHours"";
			 break;
			 case Id_getUTCHours: arity=0;
			 s=""getUTCHours"";
			 break;
			 case Id_getMinutes: arity=0;
			 s=""getMinutes"";
			 break;
			 case Id_getUTCMinutes: arity=0;
			 s=""getUTCMinutes"";
			 break;
			 case Id_getSeconds: arity=0;
			 s=""getSeconds"";
			 break;
			 case Id_getUTCSeconds: arity=0;
			 s=""getUTCSeconds"";
			 break;
			 case Id_getMilliseconds: arity=0;
			 s=""getMilliseconds"";
			 break;
			 case Id_getUTCMilliseconds: arity=0;
			 s=""getUTCMilliseconds"";
			 break;
			 case Id_getTimezoneOffset: arity=0;
			 s=""getTimezoneOffset"";
			 break;
			 case Id_setTime: arity=1;
			 s=""setTime"";
			 break;
			 case Id_setMilliseconds: arity=1;
			 s=""setMilliseconds"";
			 break;
			 case Id_setUTCMilliseconds: arity=1;
			 s=""setUTCMilliseconds"";
			 break;
			 case Id_setSeconds: arity=2;
			 s=""setSeconds"";
			 break;
			 case Id_setUTCSeconds: arity=2;
			 s=""setUTCSeconds"";
			 break;
			 case Id_setMinutes: arity=3;
			 s=""setMinutes"";
			 break;
			 case Id_setUTCMinutes: arity=3;
			 s=""setUTCMinutes"";
			 break;
			 case Id_setHours: arity=4;
			 s=""setHours"";
			 break;
			 case Id_setUTCHours: arity=4;
			 s=""setUTCHours"";
			 break;
			 case Id_setDate: arity=1;
			 s=""setDate"";
			 break;
			 case Id_setUTCDate: arity=1;
			 s=""setUTCDate"";
			 break;
			 case Id_setMonth: arity=2;
			 s=""setMonth"";
			 break;
			 case Id_setUTCMonth: arity=2;
			 s=""setUTCMonth"";
			 break;
			 case Id_setFullYear: arity=3;
			 s=""setFullYear"";
			 break;
			 case Id_setUTCFullYear: arity=3;
			 s=""setUTCFullYear"";
			 break;
			 case Id_setYear: arity=1;
			 s=""setYear"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(DATE_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(DATE_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case ConstructorId_now: return ScriptRuntime.wrapNumber(now());
			 case ConstructorId_parse: {
				 String dataStr = ScriptRuntime.toString(args, 0);
				 return ScriptRuntime.wrapNumber(date_parseString(dataStr));
			 }
			 case ConstructorId_UTC: return ScriptRuntime.wrapNumber(jsStaticFunction_UTC(args));
			 case Id_constructor: {
				 if (thisObj != null) return date_format(now(), Id_toString);
				 return jsConstructor(args);
			 }
		 }
		 if (!(thisObj instanceof NativeDate)) throw incompatibleCallError(f);
		 NativeDate realThis = (NativeDate)thisObj;
		 double t = realThis.date;
		 switch (id) {
			 case Id_toString: case Id_toTimeString: case Id_toDateString: if (t == t) {
				 return date_format(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toLocaleString: case Id_toLocaleTimeString: case Id_toLocaleDateString: if (t == t) {
				 return toLocale_helper(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toUTCString: if (t == t) {
				 return js_toUTCString(t);
			 }
			 return js_NaN_date_str;
			 case Id_toSource: return ""(new Date(""+ScriptRuntime.toString(t)+""))"";
			 case Id_valueOf: case Id_getTime: return ScriptRuntime.wrapNumber(t);
			 case Id_getYear: case Id_getFullYear: case Id_getUTCFullYear: if (t == t) {
				 if (id != Id_getUTCFullYear) t = LocalTime(t);
				 t = YearFromTime(t);
				 if (id == Id_getYear) {
					 if (cx.hasFeature(Context.FEATURE_NON_ECMA_GET_YEAR)) {
						 if (1900 <= t && t < 2000) {
							 t -= 1900;
						 }
					 }
					 else {
						 t -= 1900;
					 }
				 }
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMonth: case Id_getUTCMonth: if (t == t) {
				 if (id == Id_getMonth) t = LocalTime(t);
				 t = MonthFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDate: case Id_getUTCDate: if (t == t) {
				 if (id == Id_getDate) t = LocalTime(t);
				 t = DateFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDay: case Id_getUTCDay: if (t == t) {
				 if (id == Id_getDay) t = LocalTime(t);
				 t = WeekDay(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getHours: case Id_getUTCHours: if (t == t) {
				 if (id == Id_getHours) t = LocalTime(t);
				 t = HourFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMinutes: case Id_getUTCMinutes: if (t == t) {
				 if (id == Id_getMinutes) t = LocalTime(t);
				 t = MinFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getSeconds: case Id_getUTCSeconds: if (t == t) {
				 if (id == Id_getSeconds) t = LocalTime(t);
				 t = SecFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMilliseconds: case Id_getUTCMilliseconds: if (t == t) {
				 if (id == Id_getMilliseconds) t = LocalTime(t);
				 t = msFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getTimezoneOffset: if (t == t) {
				 t = (t - LocalTime(t)) / msPerMinute;
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setTime: t = TimeClip(ScriptRuntime.toNumber(args, 0));
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setMilliseconds: case Id_setUTCMilliseconds: case Id_setSeconds: case Id_setUTCSeconds: case Id_setMinutes: case Id_setUTCMinutes: case Id_setHours: case Id_setUTCHours: t = makeTime(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setDate: case Id_setUTCDate: case Id_setMonth: case Id_setUTCMonth: case Id_setFullYear: case Id_setUTCFullYear: t = makeDate(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setYear: {
				 double year = ScriptRuntime.toNumber(args, 0);
				 if (year != year || Double.isInfinite(year)) {
					 t = ScriptRuntime.NaN;
				 }
				 else {
					 if (t != t) {
						 t = 0;
					 }
					 else {
						 t = LocalTime(t);
					 }
					 if (year >= 0 && year <= 99) year += 1900;
					 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
					 t = MakeDate(day, TimeWithinDay(t));
					 t = internalUTC(t);
					 t = TimeClip(t);
				 }
			 }
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
	 }
	 private static final double HalfTimeDomain = 8.64e15;
	 private static final double HoursPerDay = 24.0;
	 private static final double MinutesPerHour = 60.0;
	 private static final double SecondsPerMinute = 60.0;
	 private static final double msPerSecond = 1000.0;
	 private static final double MinutesPerDay = (HoursPerDay * MinutesPerHour);
	 private static final double SecondsPerDay = (MinutesPerDay * SecondsPerMinute);
	 private static final double SecondsPerHour = (MinutesPerHour * SecondsPerMinute);
	 private static final double msPerDay = (SecondsPerDay * msPerSecond);
	 private static final double msPerHour = (SecondsPerHour * msPerSecond);
	 private static final double msPerMinute = (SecondsPerMinute * msPerSecond);
	 private static double Day(double t) {
		 return Math.floor(t / msPerDay);
	 }
	 private static double TimeWithinDay(double t) {
		 double result;
		 result = t % msPerDay;
		 if (result < 0) result += msPerDay;
		 return result;
	 }
	 private static boolean IsLeapYear(int year) {
		 return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
	 }
	 private static double DayFromYear(double y) {
		 return ((365 * ((y)-1970) + Math.floor(((y)-1969)/4.0) - Math.floor(((y)-1901)/100.0) + Math.floor(((y)-1601)/400.0)));
	 }
	 private static double TimeFromYear(double y) {
		 return DayFromYear(y) * msPerDay;
	 }
	 private static int YearFromTime(double t) {
		 int lo = (int) Math.floor((t / msPerDay) / 366) + 1970;
		 int hi = (int) Math.floor((t / msPerDay) / 365) + 1970;
		 int mid;
		 if (hi < lo) {
			 int temp = lo;
			 lo = hi;
			 hi = temp;
		 }
		 while (hi > lo) {
			 mid = (hi + lo) / 2;
			 if (TimeFromYear(mid) > t) {
				 hi = mid - 1;
			 }
			 else {
				 lo = mid + 1;
				 if (TimeFromYear(lo) > t) {
					 return mid;
				 }
			 }
		 }
		 return lo;
	 }
	 private static double DayFromMonth(int m, int year) {
		 int day = m * 30;
		 if (m >= 7) {
			 day += m / 2 - 1;
		 }
		 else if (m >= 2) {
			 day += (m - 1) / 2 - 1;
		 }
		 else {
			 day += m;
		 }
		 if (m >= 2 && IsLeapYear(year)) {
			 ++day;
		 }
		 return day;
	 }
	 private static int MonthFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? 0 : 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 1;
			 --d;
		 }
		 int estimate = d / 30;
		 int mstart;
		 switch (estimate) {
			 case 0: return 2;
			 case 1: mstart = 31;
			 break;
			 case 2: mstart = 31+30;
			 break;
			 case 3: mstart = 31+30+31;
			 break;
			 case 4: mstart = 31+30+31+30;
			 break;
			 case 5: mstart = 31+30+31+30+31;
			 break;
			 case 6: mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return 11;
			 default: throw Kit.codeBug();
		 }
		 return (d >= mstart) ? estimate + 2 : estimate + 1;
	 }
	 private static int DateFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? d + 31 + 28 + 1 : d + 28 + 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 29;
			 --d;
		 }
		 int mdays, mstart;
		 switch (d / 30) {
			 case 0: return d + 1;
			 case 1: mdays = 31;
			 mstart = 31;
			 break;
			 case 2: mdays = 30;
			 mstart = 31+30;
			 break;
			 case 3: mdays = 31;
			 mstart = 31+30+31;
			 break;
			 case 4: mdays = 30;
			 mstart = 31+30+31+30;
			 break;
			 case 5: mdays = 31;
			 mstart = 31+30+31+30+31;
			 break;
			 case 6: mdays = 31;
			 mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mdays = 30;
			 mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mdays = 31;
			 mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mdays = 30;
			 mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return d - (31+30+31+30+31+31+30+31+30) + 1;
			 default: throw Kit.codeBug();
		 }
		 d -= mstart;
		 if (d < 0) {
			 d += mdays;
		 }
		 return d + 1;
	 }
	 private static int WeekDay(double t) {
		 double result;
		 result = Day(t) + 4;
		 result = result % 7;
		 if (result < 0) result += 7;
		 return (int) result;
	 }
	 private static double now() {
		 return System.currentTimeMillis();
	 }
	 private final static boolean TZO_WORKAROUND = false;
	 private static double DaylightSavingTA(double t) {
		 if (t < 0.0 || t > 2145916800000.0) {
			 int year = EquivalentYear(YearFromTime(t));
			 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
			 t = MakeDate(day, TimeWithinDay(t));
		 }
		 if (!TZO_WORKAROUND) {
			 Date date = new Date((long) t);
			 if (thisTimeZone.inDaylightTime(date)) return msPerHour;
			 else return 0;
		 }
		 else {
			 t += LocalTZA + (HourFromTime(t) <= 2 ? msPerHour : 0);
			 int year = YearFromTime(t);
			 double offset = thisTimeZone.getOffset(year > 0 ? 1 : 0, year, MonthFromTime(t), DateFromTime(t), WeekDay(t), (int)TimeWithinDay(t));
			 if ((offset - LocalTZA) != 0) return msPerHour;
			 else return 0;
		 }
	 }
	 private static int EquivalentYear(int year) {
		 int day = (int) DayFromYear(year) + 4;
		 day = day % 7;
		 if (day < 0) day += 7;
		 if (IsLeapYear(year)) {
			 switch (day) {
				 case 0: return 1984;
				 case 1: return 1996;
				 case 2: return 1980;
				 case 3: return 1992;
				 case 4: return 1976;
				 case 5: return 1988;
				 case 6: return 1972;
			 }
		 }
		 else {
			 switch (day) {
				 case 0: return 1978;
				 case 1: return 1973;
				 case 2: return 1974;
				 case 3: return 1975;
				 case 4: return 1981;
				 case 5: return 1971;
				 case 6: return 1977;
			 }
		 }
		 throw Kit.codeBug();
	 }
	 private static double LocalTime(double t) {
		 return t + LocalTZA + DaylightSavingTA(t);
	 }
	 private static double internalUTC(double t) {
		 return t - LocalTZA - DaylightSavingTA(t - LocalTZA);
	 }
	 private static int HourFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerHour) % HoursPerDay;
		 if (result < 0) result += HoursPerDay;
		 return (int) result;
	 }
	 private static int MinFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerMinute) % MinutesPerHour;
		 if (result < 0) result += MinutesPerHour;
		 return (int) result;
	 }
	 private static int SecFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerSecond) % SecondsPerMinute;
		 if (result < 0) result += SecondsPerMinute;
		 return (int) result;
	 }
	 private static int msFromTime(double t) {
		 double result;
		 result = t % msPerSecond;
		 if (result < 0) result += msPerSecond;
		 return (int) result;
	 }
	 private static double MakeTime(double hour, double min, double sec, double ms) {
	 return ((hour * MinutesPerHour + min) * SecondsPerMinute + sec) }
	 private static double MakeDay(double year, double month, double date) {
		 year += Math.floor(month / 12);
		 month = month % 12;
		 if (month < 0) month += 12;
		 double yearday = Math.floor(TimeFromYear(year) / msPerDay);
		 double monthday = DayFromMonth((int)month, (int)year);
		 return yearday + monthday + date - 1;
	 }
	 private static double MakeDate(double day, double time) {
		 return day * msPerDay + time;
	 }
	 private static double TimeClip(double d) {
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY || Math.abs(d) > HalfTimeDomain) {
			 return ScriptRuntime.NaN;
		 }
		 if (d > 0.0) return Math.floor(d + 0.);
		 else return Math.ceil(d + 0.);
	 }
	 private static double date_msecFromDate(double year, double mon, double mday, double hour, double min, double sec, double msec) {
		 double day;
		 double time;
		 double result;
		 day = MakeDay(year, mon, mday);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(day, time);
		 return result;
	 }
	 private static final int MAXARGS = 7;
	 private static double date_msecFromArgs(Object[] args) {
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 return ScriptRuntime.NaN;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 if (loop == 2) {
					 array[loop] = 1;
				 }
				 else {
					 array[loop] = 0;
				 }
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 return date_msecFromDate(array[0], array[1], array[2], array[3], array[4], array[5], array[6]);
	 }
	 private static double jsStaticFunction_UTC(Object[] args) {
		 return TimeClip(date_msecFromArgs(args));
	 }
	 private static double date_parseString(String s) {
		 int year = -1;
		 int mon = -1;
		 int mday = -1;
		 int hour = -1;
		 int min = -1;
		 int sec = -1;
		 char c = 0;
		 char si = 0;
		 int i = 0;
		 int n = -1;
		 double tzoffset = -1;
		 char prevc = 0;
		 int limit = 0;
		 boolean seenplusminus = false;
		 limit = s.length();
		 while (i < limit) {
			 c = s.charAt(i);
			 i++;
			 if (c <= ' ' || c == ',' || c == '-') {
				 if (i < limit) {
					 si = s.charAt(i);
					 if (c == '-' && '0' <= si && si <= '9') {
						 prevc = c;
					 }
				 }
				 continue;
			 }
			 if (c == '(') {
				 int depth = 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 i++;
					 if (c == '(') depth++;
					 else if (c == ')') if (--depth <= 0) break;
				 }
				 continue;
			 }
			 if ('0' <= c && c <= '9') {
				 n = c - '0';
				 while (i < limit && '0' <= (c = s.charAt(i)) && c <= '9') {
					 n = n * 10 + c - '0';
					 i++;
				 }
				 if ((prevc == '+' || prevc == '-')) {
					 seenplusminus = true;
					 if (n < 24) n = n * 60;
					 else n = n % 100 + n / 100 * 60;
					 if (prevc == '+') n = -n;
					 if (tzoffset != 0 && tzoffset != -1) return ScriptRuntime.NaN;
					 tzoffset = n;
				 }
				 else if (n >= 70 || (prevc == '/' && mon >= 0 && mday >= 0 && year < 0)) {
					 if (year >= 0) return ScriptRuntime.NaN;
					 else if (c <= ' ' || c == ',' || c == '/' || i >= limit) year = n < 100 ? n + 1900 : n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == ':') {
					 if (hour < 0) hour = n;
					 else if (min < 0) min = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == '/') {
					 if (mon < 0) mon = n-1;
					 else if (mday < 0) mday = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (i < limit && c != ',' && c > ' ' && c != '-') {
					 return ScriptRuntime.NaN;
				 }
				 else if (seenplusminus && n < 60) {
					 if (tzoffset < 0) tzoffset -= n;
					 else tzoffset += n;
				 }
				 else if (hour >= 0 && min < 0) {
					 min = n;
				 }
				 else if (min >= 0 && sec < 0) {
					 sec = n;
				 }
				 else if (mday < 0) {
					 mday = n;
				 }
				 else {
					 return ScriptRuntime.NaN;
				 }
				 prevc = 0;
			 }
			 else if (c == '/' || c == ':' || c == '+' || c == '-') {
				 prevc = c;
			 }
			 else {
				 int st = i - 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 if (!(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))) break;
					 i++;
				 }
				 int letterCount = i - st;
				 if (letterCount < 2) return ScriptRuntime.NaN;
				 String wtb = ""am;
				pm;
				"" +""monday;
				tuesday;
				wednesday;
				thursday;
				friday;
				"" +""saturday;
				sunday;
				"" +""january;
				february;
				march;
				april;
				may;
				june;
				"" +""july;
				august;
				september;
				october;
				november;
				december;
				"" +""gmt;
				ut;
				utc;
				est;
				edt;
				cst;
				cdt;
				mst;
				mdt;
				pst;
				pdt;
				"";
				 int index = 0;
				 for (int wtbOffset = 0;
				 ;
				) {
					 int wtbNext = wtb.indexOf(';
					', wtbOffset);
					 if (wtbNext < 0) return ScriptRuntime.NaN;
					 if (wtb.regionMatches(true, wtbOffset, s, st, letterCount)) break;
					 wtbOffset = wtbNext + 1;
					 ++index;
				 }
				 if (index < 2) {
					 if (hour > 12 || hour < 0) {
						 return ScriptRuntime.NaN;
					 }
					 else if (index == 0) {
						 if (hour == 12) hour = 0;
					 }
					 else {
						 if (hour != 12) hour += 12;
					 }
				 }
				 else if ((index -= 2) < 7) {
				 }
				 else if ((index -= 7) < 12) {
					 if (mon < 0) {
						 mon = index;
					 }
					 else {
						 return ScriptRuntime.NaN;
					 }
				 }
				 else {
					 index -= 12;
					 switch (index) {
						 case 0 : tzoffset = 0;
						 break;
						 case 1 : tzoffset = 0;
						 break;
						 case 2 : tzoffset = 0;
						 break;
						 case 3 : tzoffset = 5 * 60;
						 break;
						 case 4 : tzoffset = 4 * 60;
						 break;
						 case 5 : tzoffset = 6 * 60;
						 break;
						 case 6 : tzoffset = 5 * 60;
						 break;
						 case 7 : tzoffset = 7 * 60;
						 break;
						 case 8 : tzoffset = 6 * 60;
						 break;
						 case 9 : tzoffset = 8 * 60;
						 break;
						 case 10 :tzoffset = 7 * 60;
						 break;
						 default: Kit.codeBug();
					 }
				 }
			 }
		 }
		 if (year < 0 || mon < 0 || mday < 0) return ScriptRuntime.NaN;
		 if (sec < 0) sec = 0;
		 if (min < 0) min = 0;
		 if (hour < 0) hour = 0;
		 double msec = date_msecFromDate(year, mon, mday, hour, min, sec, 0);
		 if (tzoffset == -1) {
			 return internalUTC(msec);
		 }
		 else {
			 return msec + tzoffset * msPerMinute;
		 }
	 }
	 private static String date_format(double t, int methodId) {
		 StringBuffer result = new StringBuffer(60);
		 double local = LocalTime(t);
		 if (methodId != Id_toTimeString) {
			 appendWeekDayName(result, WeekDay(local));
			 result.append(' ');
			 appendMonthName(result, MonthFromTime(local));
			 result.append(' ');
			 append0PaddedUint(result, DateFromTime(local), 2);
			 result.append(' ');
			 int year = YearFromTime(local);
			 if (year < 0) {
				 result.append('-');
				 year = -year;
			 }
			 append0PaddedUint(result, year, 4);
			 if (methodId != Id_toDateString) result.append(' ');
		 }
		 if (methodId != Id_toDateString) {
			 append0PaddedUint(result, HourFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, MinFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, SecFromTime(local), 2);
			 int minutes = (int) Math.floor((LocalTZA + DaylightSavingTA(t)) / msPerMinute);
			 int offset = (minutes / 60) * 100 + minutes % 60;
			 if (offset > 0) {
				 result.append("" GMT+"");
			 }
			 else {
				 result.append("" GMT-"");
				 offset = -offset;
			 }
			 append0PaddedUint(result, offset, 4);
			 if (timeZoneFormatter == null) timeZoneFormatter = new java.text.SimpleDateFormat(""zzz"");
			 if (t < 0.0 || t > 2145916800000.0) {
				 int equiv = EquivalentYear(YearFromTime(local));
				 double day = MakeDay(equiv, MonthFromTime(t), DateFromTime(t));
				 t = MakeDate(day, TimeWithinDay(t));
			 }
			 result.append("" ("");
			 java.util.Date date = new Date((long) t);
			 synchronized (timeZoneFormatter) {
				 result.append(timeZoneFormatter.format(date));
			 }
			 result.append(')');
		 }
		 return result.toString();
	 }
	 private static Object jsConstructor(Object[] args) {
		 NativeDate obj = new NativeDate();
		 if (args.length == 0) {
			 obj.date = now();
			 return obj;
		 }
		 if (args.length == 1) {
			 Object arg0 = args[0];
			 if (arg0 instanceof Scriptable) arg0 = ((Scriptable) arg0).getDefaultValue(null);
			 double date;
			 if (arg0 instanceof String) {
				 date = date_parseString((String)arg0);
			 }
			 else {
				 date = ScriptRuntime.toNumber(arg0);
			 }
			 obj.date = TimeClip(date);
			 return obj;
		 }
		 double time = date_msecFromArgs(args);
		 if (!Double.isNaN(time) && !Double.isInfinite(time)) time = TimeClip(internalUTC(time));
		 obj.date = time;
		 return obj;
	 }
	 private static String toLocale_helper(double t, int methodId) {
		 java.text.DateFormat formatter;
		 switch (methodId) {
			 case Id_toLocaleString: if (localeDateTimeFormatter == null) {
				 localeDateTimeFormatter = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
			 }
			 formatter = localeDateTimeFormatter;
			 break;
			 case Id_toLocaleTimeString: if (localeTimeFormatter == null) {
				 localeTimeFormatter = DateFormat.getTimeInstance(DateFormat.LONG);
			 }
			 formatter = localeTimeFormatter;
			 break;
			 case Id_toLocaleDateString: if (localeDateFormatter == null) {
				 localeDateFormatter = DateFormat.getDateInstance(DateFormat.LONG);
			 }
			 formatter = localeDateFormatter;
			 break;
			 default: formatter = null;
		 }
		 synchronized (formatter) {
			 return formatter.format(new Date((long) t));
		 }
	 }
	 private static String js_toUTCString(double date) {
		 StringBuffer result = new StringBuffer(60);
		 appendWeekDayName(result, WeekDay(date));
		 result.append("", "");
		 append0PaddedUint(result, DateFromTime(date), 2);
		 result.append(' ');
		 appendMonthName(result, MonthFromTime(date));
		 result.append(' ');
		 int year = YearFromTime(date);
		 if (year < 0) {
			 result.append('-');
			 year = -year;
		 }
		 append0PaddedUint(result, year, 4);
		 result.append(' ');
		 append0PaddedUint(result, HourFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, MinFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, SecFromTime(date), 2);
		 result.append("" GMT"");
		 return result.toString();
	 }
	 private static void append0PaddedUint(StringBuffer sb, int i, int minWidth) {
		 if (i < 0) Kit.codeBug();
		 int scale = 1;
		 --minWidth;
		 if (i >= 10) {
			 if (i < 1000 * 1000 * 1000) {
				 for (;
				;
				) {
					 int newScale = scale * 10;
					 if (i < newScale) {
						 break;
					 }
					 --minWidth;
					 scale = newScale;
				 }
			 }
			 else {
				 minWidth -= 9;
				 scale = 1000 * 1000 * 1000;
			 }
		 }
		 while (minWidth > 0) {
			 sb.append('0');
			 --minWidth;
		 }
		 while (scale != 1) {
			 sb.append((char)('0' + (i / scale)));
			 i %= scale;
			 scale /= 10;
		 }
		 sb.append((char)('0' + i));
	 }
	 private static void appendMonthName(StringBuffer sb, int index) {
		 String months = ""Jan""+""Feb""+""Mar""+""Apr""+""May""+""Jun"" +""Jul""+""Aug""+""Sep""+""Oct""+""Nov""+""Dec"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(months.charAt(index + i));
		 }
	 }
	 private static void appendWeekDayName(StringBuffer sb, int index) {
		 String days = ""Sun""+""Mon""+""Tue""+""Wed""+""Thu""+""Fri""+""Sat"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(days.charAt(index + i));
		 }
	 }
	 private static double makeTime(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCMilliseconds: local = false;
			 case Id_setMilliseconds: maxargs = 1;
			 break;
			 case Id_setUTCSeconds: local = false;
			 case Id_setSeconds: maxargs = 2;
			 break;
			 case Id_setUTCMinutes: local = false;
			 case Id_setMinutes: maxargs = 3;
			 break;
			 case Id_setUTCHours: local = false;
			 case Id_setHours: maxargs = 4;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[4];
		 double hour, min, sec, msec;
		 double lorutime;
		 double time;
		 double result;
		 if (date != date) return date;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (local) lorutime = LocalTime(date);
		 else lorutime = date;
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 4 && i < stop) hour = conv[i++];
		 else hour = HourFromTime(lorutime);
		 if (maxargs >= 3 && i < stop) min = conv[i++];
		 else min = MinFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) sec = conv[i++];
		 else sec = SecFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) msec = conv[i++];
		 else msec = msFromTime(lorutime);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(Day(lorutime), time);
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 private static double makeDate(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCDate: local = false;
			 case Id_setDate: maxargs = 1;
			 break;
			 case Id_setUTCMonth: local = false;
			 case Id_setMonth: maxargs = 2;
			 break;
			 case Id_setUTCFullYear: local = false;
			 case Id_setFullYear: maxargs = 3;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[3];
		 double year, month, day;
		 double lorutime;
		 double result;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (date != date) {
			 if (args.length < 3) {
				 return ScriptRuntime.NaN;
			 }
			 else {
				 lorutime = 0;
			 }
		 }
		 else {
			 if (local) lorutime = LocalTime(date);
			 else lorutime = date;
		 }
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 3 && i < stop) year = conv[i++];
		 else year = YearFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) month = conv[i++];
		 else month = MonthFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) day = conv[i++];
		 else day = DateFromTime(lorutime);
		 day = MakeDay(year, month, day);
		 result = MakeDate(day, TimeWithinDay(lorutime));
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 6: X=""getDay"";
				id=Id_getDay;
				 break L;
				 case 7: switch (s.charAt(3)) {
					 case 'D': c=s.charAt(0);
					 if (c=='g') {
						 X=""getDate"";
						id=Id_getDate;
					 }
					 else if (c=='s') {
						 X=""setDate"";
						id=Id_setDate;
					 }
					 break L;
					 case 'T': c=s.charAt(0);
					 if (c=='g') {
						 X=""getTime"";
						id=Id_getTime;
					 }
					 else if (c=='s') {
						 X=""setTime"";
						id=Id_setTime;
					 }
					 break L;
					 case 'Y': c=s.charAt(0);
					 if (c=='g') {
						 X=""getYear"";
						id=Id_getYear;
					 }
					 else if (c=='s') {
						 X=""setYear"";
						id=Id_setYear;
					 }
					 break L;
					 case 'u': X=""valueOf"";
					id=Id_valueOf;
					 break L;
				 }
				 break L;
				 case 8: switch (s.charAt(3)) {
					 case 'H': c=s.charAt(0);
					 if (c=='g') {
						 X=""getHours"";
						id=Id_getHours;
					 }
					 else if (c=='s') {
						 X=""setHours"";
						id=Id_setHours;
					 }
					 break L;
					 case 'M': c=s.charAt(0);
					 if (c=='g') {
						 X=""getMonth"";
						id=Id_getMonth;
					 }
					 else if (c=='s') {
						 X=""setMonth"";
						id=Id_setMonth;
					 }
					 break L;
					 case 'o': X=""toSource"";
					id=Id_toSource;
					 break L;
					 case 't': X=""toString"";
					id=Id_toString;
					 break L;
				 }
				 break L;
				 case 9: X=""getUTCDay"";
				id=Id_getUTCDay;
				 break L;
				 case 10: c=s.charAt(3);
				 if (c=='M') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getMinutes"";
						id=Id_getMinutes;
					 }
					 else if (c=='s') {
						 X=""setMinutes"";
						id=Id_setMinutes;
					 }
				 }
				 else if (c=='S') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getSeconds"";
						id=Id_getSeconds;
					 }
					 else if (c=='s') {
						 X=""setSeconds"";
						id=Id_setSeconds;
					 }
				 }
				 else if (c=='U') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getUTCDate"";
						id=Id_getUTCDate;
					 }
					 else if (c=='s') {
						 X=""setUTCDate"";
						id=Id_setUTCDate;
					 }
				 }
				 break L;
				 case 11: switch (s.charAt(3)) {
					 case 'F': c=s.charAt(0);
					 if (c=='g') {
						 X=""getFullYear"";
						id=Id_getFullYear;
					 }
					 else if (c=='s') {
						 X=""setFullYear"";
						id=Id_setFullYear;
					 }
					 break L;
					 case 'M': X=""toGMTString"";
					id=Id_toGMTString;
					 break L;
					 case 'T': X=""toUTCString"";
					id=Id_toUTCString;
					 break L;
					 case 'U': c=s.charAt(0);
					 if (c=='g') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""getUTCHours"";
							id=Id_getUTCHours;
						 }
						 else if (c=='t') {
							 X=""getUTCMonth"";
							id=Id_getUTCMonth;
						 }
					 }
					 else if (c=='s') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""setUTCHours"";
							id=Id_setUTCHours;
						 }
						 else if (c=='t') {
							 X=""setUTCMonth"";
							id=Id_setUTCMonth;
						 }
					 }
					 break L;
					 case 's': X=""constructor"";
					id=Id_constructor;
					 break L;
				 }
				 break L;
				 case 12: c=s.charAt(2);
				 if (c=='D') {
					 X=""toDateString"";
					id=Id_toDateString;
				 }
				 else if (c=='T') {
					 X=""toTimeString"";
					id=Id_toTimeString;
				 }
				 break L;
				 case 13: c=s.charAt(0);
				 if (c=='g') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""getUTCMinutes"";
						id=Id_getUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""getUTCSeconds"";
						id=Id_getUTCSeconds;
					 }
				 }
				 else if (c=='s') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""setUTCMinutes"";
						id=Id_setUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""setUTCSeconds"";
						id=Id_setUTCSeconds;
					 }
				 }
				 break L;
				 case 14: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCFullYear"";
					id=Id_getUTCFullYear;
				 }
				 else if (c=='s') {
					 X=""setUTCFullYear"";
					id=Id_setUTCFullYear;
				 }
				 else if (c=='t') {
					 X=""toLocaleString"";
					id=Id_toLocaleString;
				 }
				 break L;
				 case 15: c=s.charAt(0);
				 if (c=='g') {
					 X=""getMilliseconds"";
					id=Id_getMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setMilliseconds"";
					id=Id_setMilliseconds;
				 }
				 break L;
				 case 17: X=""getTimezoneOffset"";
				id=Id_getTimezoneOffset;
				 break L;
				 case 18: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCMilliseconds"";
					id=Id_getUTCMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setUTCMilliseconds"";
					id=Id_setUTCMilliseconds;
				 }
				 else if (c=='t') {
					 c=s.charAt(8);
					 if (c=='D') {
						 X=""toLocaleDateString"";
						id=Id_toLocaleDateString;
					 }
					 else if (c=='T') {
						 X=""toLocaleTimeString"";
						id=Id_toLocaleTimeString;
					 }
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
			 break L0;
		 }
		 return id;
	 }
	 private static final int ConstructorId_now = -3, ConstructorId_parse = -2, ConstructorId_UTC = -1, Id_constructor = 1, Id_toString = 2, Id_toTimeString = 3, Id_toDateString = 4, Id_toLocaleString = 5, Id_toLocaleTimeString = 6, Id_toLocaleDateString = 7, Id_toUTCString = 8, Id_toSource = 9, Id_valueOf = 10, Id_getTime = 11, Id_getYear = 12, Id_getFullYear = 13, Id_getUTCFullYear = 14, Id_getMonth = 15, Id_getUTCMonth = 16, Id_getDate = 17, Id_getUTCDate = 18, Id_getDay = 19, Id_getUTCDay = 20, Id_getHours = 21, Id_getUTCHours = 22, Id_getMinutes = 23, Id_getUTCMinutes = 24, Id_getSeconds = 25, Id_getUTCSeconds = 26, Id_getMilliseconds = 27, Id_getUTCMilliseconds = 28, Id_getTimezoneOffset = 29, Id_setTime = 30, Id_setMilliseconds = 31, Id_setUTCMilliseconds = 32, Id_setSeconds = 33, Id_setUTCSeconds = 34, Id_setMinutes = 35, Id_setUTCMinutes = 36, Id_setHours = 37, Id_setUTCHours = 38, Id_setDate = 39, Id_setUTCDate = 40, Id_setMonth = 41, Id_setUTCMonth = 42, Id_setFullYear = 43, Id_setUTCFullYear = 44, Id_setYear = 45, MAX_PROTOTYPE_ID = 45;
	 private static final int Id_toGMTString = Id_toUTCString;
	 private static java.util.TimeZone thisTimeZone;
	 private static double LocalTZA;
	 private static java.text.DateFormat timeZoneFormatter;
	 private static java.text.DateFormat localeDateTimeFormatter;
	 private static java.text.DateFormat localeDateFormatter;
	 private static java.text.DateFormat localeTimeFormatter;
	 private double date;
}",1,0,0,0
"public static class getGatewayResourceProfile<I extends Iface> extends org.apache.thrift.ProcessFunction<I, getGatewayResourceProfile_args> {
	 public getGatewayResourceProfile() {
		 super(""getGatewayResourceProfile"");
	 }
	 public getGatewayResourceProfile_args getEmptyArgsInstance() {
		 return new getGatewayResourceProfile_args();
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public getGatewayResourceProfile_result getResult(I iface, getGatewayResourceProfile_args args) throws org.apache.thrift.TException {
		 getGatewayResourceProfile_result result = new getGatewayResourceProfile_result();
		 try {
			 result.success = iface.getGatewayResourceProfile(args.authzToken, args.gatewayID);
		 }
		 catch (org.apache.airavata.model.error.InvalidRequestException ire) {
			 result.ire = ire;
		 }
		 catch (org.apache.airavata.model.error.AiravataClientException ace) {
			 result.ace = ace;
		 }
		 catch (org.apache.airavata.model.error.AiravataSystemException ase) {
			 result.ase = ase;
		 }
		 catch (org.apache.airavata.model.error.AuthorizationException ae) {
			 result.ae = ae;
		 }
		 return result;
	 }
 }",0,1,0,0
"private void updateSchedulerFields() {
	int index = qList.getSelectedIndex();
	if (index < 0)return;
	DownloadQueue q = queueModel.getElementAt(index);
	txtQueueName.setText(q.getName());
	loadQueuedItems(q);
	btnQMoveTo.setEnabled(QueueManager.getInstance().getQueueList().size() > 1 && q.getQueuedItems().size() > 0);
	Date startTime = DateTimeUtils.addTimePart(q.getStartTime());
	Date endTime = DateTimeUtils.addTimePart(q.getEndTime());
	if (startTime == null) {
		endTime = null;
	}
	chkQStart.setSelected(startTime != null);
	chkQStop.setSelected(endTime != null);
	if (startTime == null) {
		startTime = DateTimeUtils.getDefaultStart();
	}
	if (endTime == null || endTime.before(startTime)) {
		endTime = DateTimeUtils.getDefaultEnd();
	}
	spinnerDateModel1.setValue(startTime);
	spinnerDateModel2.setValue(endTime);
	for (int i = 1;
	 i <= 7;
	 i++) {
		JCheckBox chk = chkDays[i - 1];
		chk.setSelected(false);
	}
	int mask = 0x01;
	if (q.isPeriodic()) {
		for (int i = 1;
		 i <= 7;
		 i++) {
			JCheckBox chk = chkDays[i - 1];
			chk.setSelected((q.getDayMask() & mask) == mask);
			mask = mask << 1;
		}
		radPeriodic.setSelected(true);
	}
	 else {
		Date execDate = q.getExecDate();
		if (execDate == null || execDate.before(new Date())) {
			execDate = new Date();
		}
		radOnetime.setSelected(true);
		spinnerDateModel3.setValue(execDate);
	}
	enableSchedulerFields();
}",0,0,1,0
"public class LexicalUUIDType extends AbstractUUIDType{
	 public static final LexicalUUIDType instance = new LexicalUUIDType();
	 LexicalUUIDType() {
	}
	 public UUID compose(ByteBuffer bytes) {
		 return UUIDGen.getUUID(bytes);
	 }
	 public ByteBuffer decompose(UUID value) {
		 return ByteBuffer.wrap(UUIDGen.decompose(value));
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 if (o1.remaining() == 0) {
			 return o2.remaining() == 0 ? 0 : -1;
		 }
		 if (o2.remaining() == 0) {
			 return 1;
		 }
		 return UUIDGen.getUUID(o1).compareTo(UUIDGen.getUUID(o2));
	 }
	 public String getString(ByteBuffer bytes) {
		 if (bytes.remaining() == 0) {
			 return """";
		 }
		 if (bytes.remaining() != 16) {
			 throw new MarshalException(""UUIDs must be exactly 16 bytes"");
		 }
		 return UUIDGen.getUUID(bytes).toString();
	 }
	 public String toString(UUID uuid) {
		 return uuid.toString();
	 }
	 public ByteBuffer fromString(String source) throws MarshalException {
		 if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;
		 try {
			 return decompose(UUID.fromString(source));
		 }
		 catch (IllegalArgumentException e) {
			 throw new MarshalException(String.format(""unable to make UUID from '%s'"", source), e);
		 }
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 if (bytes.remaining() != 16 && bytes.remaining() != 0) throw new MarshalException(String.format(""LexicalUUID should be 16 or 0 bytes (%d)"", bytes.remaining()));
	 }
	 public Class<UUID> getType() {
		 return UUID.class;
	 }
}",0,0,0,0
"public final class PageViewTelemetryFilter implements TelemetryProcessor {
	 private long durationThresholdInMS = 0l;
	 private final Set<String> notNeededUrls = new HashSet<String>();
	 private final Set<String> notNeededNames = new HashSet<String>();
	 public PageViewTelemetryFilter() {
	 }
	 public boolean process(Telemetry telemetry) {
		 if (telemetry == null) {
			 return true;
		 }
		 if (!(telemetry instanceof PageViewTelemetry)) {
			 return true;
		 }
		 PageViewTelemetry asPVT = (PageViewTelemetry) telemetry;
		 URI uri = asPVT.getUri();
		 if (uri == null) {
			 return true;
		 }
		 else {
			 String uriPath = uri.toString();
			 for (String notNeededUri : notNeededUrls) {
				 if (uriPath.contains(notNeededUri)) {
					 return false;
				 }
			 }
		 }
		 if (notNeededNames.contains(asPVT.getName())) {
			 return false;
		 }
		 long pvtDuration = asPVT.getDuration();
		 if (durationThresholdInMS <= pvtDuration) {
			 return true;
		 }
		 return false;
	 }
	 public void setDurationThresholdInMS(String durationThresholdInMS) throws NumberFormatException {
		 try {
			 this.durationThresholdInMS = Long.valueOf(durationThresholdInMS);
			 InternalLogger.INSTANCE.trace(""PageViewTelemetryFilter: successfully set DurationThresholdInMS to %s"", durationThresholdInMS);
		 }
		 catch (NumberFormatException e) {
			 InternalLogger.INSTANCE.error(""PageViewTelemetryFilter: failed to set DurationThresholdInMS:%s Exception : %s "", durationThresholdInMS, ExceptionUtils.getStackTrace(e));
			 throw e;
		 }
	 }
	 public void setNotNeededNames(String notNeededNames) throws Throwable {
		 try {
			 List<String> notNeededAsList = Arrays.asList(notNeededNames.split("",""));
			 for (String notNeeded : notNeededAsList) {
				 String ready = notNeeded.trim();
				 if (LocalStringsUtils.isNullOrEmpty(ready)) {
					 continue;
				 }
				 this.notNeededNames.add(ready);
			 }
			 InternalLogger.INSTANCE.trace(String.format(""PageViewTelemetryFilter: set NotNeededNames: %s"", notNeededNames));
		 }
		 catch (ThreadDeath td) {
			 throw td;
		 }
		 catch (Throwable t) {
			 try {
				 InternalLogger.INSTANCE.trace(""PageViewTelemetryFilter: failed to parse NotNeededNames: %s Exception : %s"", notNeededNames, ExceptionUtils.getStackTrace(t));
			 }
			 catch (ThreadDeath td) {
				 throw td;
			 }
			 catch (Throwable t2) {
			 }
			 throw t;
		 }
	 }
	 public void setNotNeededUrls(String notNeededUrls) throws Throwable {
		 try {
			 List<String> notNeededAsList = Arrays.asList(notNeededUrls.split("",""));
			 for (String notNeeded : notNeededAsList) {
				 String ready = notNeeded.trim();
				 if (LocalStringsUtils.isNullOrEmpty(ready)) {
					 continue;
				 }
				 this.notNeededUrls.add(ready);
			 }
			 InternalLogger.INSTANCE.trace(""PageViewTelemetryFilter: set %s"", notNeededUrls);
		 }
		 catch (ThreadDeath td) {
			 throw td;
		 }
		 catch (Throwable t) {
			 try {
				 InternalLogger.INSTANCE.error(""PageViewTelemetryFilter: failed to parse NotNeededUrls: %s Exception : %s"", notNeededUrls, ExceptionUtils.getStackTrace(t));
			 }
			 catch (ThreadDeath td) {
				 throw td;
			 }
			 catch (Throwable t2) {
			 }
			 throw t;
		 }
	 }
}",0,0,0,0
"public class NativeArray extends IdScriptableObject{
	 private static final Object ARRAY_TAG = new Object();
	 static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeArray obj = new NativeArray();
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeArray() {
		 dense = null;
		 this.length = 0;
	 }
	 public NativeArray(long length) {
		 int intLength = (int) length;
		 if (intLength == length && intLength > 0) {
			 if (intLength > maximumDenseLength) intLength = maximumDenseLength;
			 dense = new Object[intLength];
			 for (int i=0;
			 i < intLength;
			 i++) dense[i] = NOT_FOUND;
		 }
		 this.length = length;
	 }
	 public NativeArray(Object[] array) {
		 dense = array;
		 this.length = array.length;
	 }
	 public String getClassName() {
		 return ""Array"";
	 }
	 private static final int Id_length = 1, MAX_INSTANCE_ID = 1;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 if (s.equals(""length"")) {
			 return instanceIdInfo(DONTENUM | PERMANENT, Id_length);
		 }
		 return super.findInstanceIdInfo(s);
	 }
	 protected String getInstanceIdName(int id) {
		 if (id == Id_length) {
			 return ""length"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 if (id == Id_length) {
			 return ScriptRuntime.wrapNumber(length);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_length) {
			 setLength(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toLocaleString: arity=1;
			 s=""toLocaleString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_join: arity=1;
			 s=""join"";
			 break;
			 case Id_reverse: arity=0;
			 s=""reverse"";
			 break;
			 case Id_sort: arity=1;
			 s=""sort"";
			 break;
			 case Id_push: arity=1;
			 s=""push"";
			 break;
			 case Id_pop: arity=1;
			 s=""pop"";
			 break;
			 case Id_shift: arity=1;
			 s=""shift"";
			 break;
			 case Id_unshift: arity=1;
			 s=""unshift"";
			 break;
			 case Id_splice: arity=1;
			 s=""splice"";
			 break;
			 case Id_concat: arity=1;
			 s=""concat"";
			 break;
			 case Id_slice: arity=1;
			 s=""slice"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(ARRAY_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(ARRAY_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: {
				 boolean inNewExpr = (thisObj == null);
				 if (!inNewExpr) {
					 return f.construct(cx, scope, args);
				 }
				 return jsConstructor(cx, scope, args);
			 }
			 case Id_toString: return toStringHelper(cx, scope, thisObj, cx.hasFeature(Context.FEATURE_TO_STRING_AS_SOURCE), false);
			 case Id_toLocaleString: return toStringHelper(cx, scope, thisObj, false, true);
			 case Id_toSource: return toStringHelper(cx, scope, thisObj, true, false);
			 case Id_join: return js_join(cx, thisObj, args);
			 case Id_reverse: return js_reverse(cx, thisObj, args);
			 case Id_sort: return js_sort(cx, scope, thisObj, args);
			 case Id_push: return js_push(cx, thisObj, args);
			 case Id_pop: return js_pop(cx, thisObj, args);
			 case Id_shift: return js_shift(cx, thisObj, args);
			 case Id_unshift: return js_unshift(cx, thisObj, args);
			 case Id_splice: return js_splice(cx, scope, thisObj, args);
			 case Id_concat: return js_concat(cx, scope, thisObj, args);
			 case Id_slice: return js_slice(cx, thisObj, args);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 public Object get(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index];
		 return super.get(index, start);
	 }
	 public boolean has(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index] != NOT_FOUND;
		 return super.has(index, start);
	 }
	 private static long toArrayIndex(String id) {
		 double d = ScriptRuntime.toNumber(id);
		 if (d == d) {
			 long index = ScriptRuntime.toUint32(d);
			 if (index == d && index != 4294967295L) {
				 if (Long.toString(index).equals(id)) {
					 return index;
				 }
			 }
		 }
		 return -1;
	 }
	 public void put(String id, Scriptable start, Object value) {
		 super.put(id, start, value);
		 if (start == this) {
			 long index = toArrayIndex(id);
			 if (index >= length) {
				 length = index + 1;
			 }
		 }
	 }
	 public void put(int index, Scriptable start, Object value) {
		 if (start == this && !isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = value;
		 }
		 else {
			 super.put(index, start, value);
		 }
		 if (start == this) {
			 if (this.length <= index) {
				 this.length = (long)index + 1;
			 }
		 }
	 }
	 public void delete(int index) {
		 if (!isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = NOT_FOUND;
		 }
		 else {
			 super.delete(index);
		 }
	 }
	 public Object[] getIds() {
		 Object[] superIds = super.getIds();
		 if (dense == null) {
			 return superIds;
		 }
		 int N = dense.length;
		 long currentLength = length;
		 if (N > currentLength) {
			 N = (int)currentLength;
		 }
		 if (N == 0) {
			 return superIds;
		 }
		 int superLength = superIds.length;
		 Object[] ids = new Object[N + superLength];
		 System.arraycopy(dense, 0, ids, 0, N);
		 int presentCount = 0;
		 for (int i = 0;
		 i != N;
		 ++i) {
			 if (ids[i] != NOT_FOUND) {
				 ids[presentCount] = new Integer(i);
				 ++presentCount;
			 }
		 }
		 if (presentCount != N) {
			 Object[] tmp = new Object[presentCount + superLength];
			 System.arraycopy(ids, 0, tmp, 0, presentCount);
			 ids = tmp;
		 }
		 System.arraycopy(superIds, 0, ids, presentCount, superLength);
		 return ids;
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == ScriptRuntime.NumberClass) {
			 Context cx = Context.getContext();
			 if (cx.getLanguageVersion() == Context.VERSION_1_2) return new Long(length);
		 }
		 return super.getDefaultValue(hint);
	 }
	 private static Object jsConstructor(Context cx, Scriptable scope, Object[] args) {
		 if (args.length == 0) return new NativeArray();
		 if (cx.getLanguageVersion() == cx.VERSION_1_2) {
			 return new NativeArray(args);
		 }
		 else {
			 Object arg0 = args[0];
			 if (args.length > 1 || !(arg0 instanceof Number)) {
				 return new NativeArray(args);
			 }
			 else {
				 long len = ScriptRuntime.toUint32(arg0);
				 if (len != ((Number)arg0).doubleValue()) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
				 return new NativeArray(len);
			 }
		 }
	 }
	 public long getLength() {
		 return length;
	 }
	 public long jsGet_length() {
		 return getLength();
	 }
	 private void setLength(Object val) {
		 double d = ScriptRuntime.toNumber(val);
		 long longVal = ScriptRuntime.toUint32(d);
		 if (longVal != d) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
		 if (longVal < length) {
			 if (length - longVal > 0x1000) {
				 Object[] e = getIds();
				 for (int i=0;
				 i < e.length;
				 i++) {
					 Object id = e[i];
					 if (id instanceof String) {
						 String strId = (String)id;
						 long index = toArrayIndex(strId);
						 if (index >= longVal) delete(strId);
					 }
					 else {
						 int index = ((Integer)id).intValue();
						 if (index >= longVal) delete(index);
					 }
				 }
			 }
			 else {
				 for (long i = longVal;
				 i < length;
				 i++) {
					 deleteElem(this, i);
				 }
			 }
		 }
		 length = longVal;
	 }
	 static long getLengthProperty(Context cx, Scriptable obj) {
		 if (obj instanceof NativeString) {
			 return ((NativeString)obj).getLength();
		 }
		 else if (obj instanceof NativeArray) {
			 return ((NativeArray)obj).getLength();
		 }
		 else if (!(obj instanceof Scriptable)) {
			 return 0;
		 }
		 return ScriptRuntime.toUint32( ScriptRuntime.getObjectProp(obj, ""length"", cx));
	 }
	 private static Object setLengthProperty(Context cx, Scriptable target, long length) {
		 return ScriptRuntime.setObjectProp( target, ""length"", ScriptRuntime.wrapNumber(length), cx);
	 }
	 private static void deleteElem(Scriptable target, long index) {
		 int i = (int)index;
		 if (i == index) {
			 target.delete(i);
		 }
		 else {
			 target.delete(Long.toString(index));
		 }
	 }
	 private static Object getElem(Context cx, Scriptable target, long index) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 return ScriptRuntime.getObjectProp(target, id, cx);
		 }
		 else {
			 return ScriptRuntime.getObjectIndex(target, (int)index, cx);
		 }
	 }
	 private static void setElem(Context cx, Scriptable target, long index, Object value) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 ScriptRuntime.setObjectProp(target, id, value, cx);
		 }
		 else {
			 ScriptRuntime.setObjectIndex(target, (int)index, value, cx);
		 }
	 }
	 private static String toStringHelper(Context cx, Scriptable scope, Scriptable thisObj, boolean toSource, boolean toLocale) {
		 long length = getLengthProperty(cx, thisObj);
		 StringBuffer result = new StringBuffer(256);
		 String separator;
		 if (toSource) {
			 result.append('[');
			 separator = "", "";
		 }
		 else {
			 separator = "","";
		 }
		 boolean haslast = false;
		 long i = 0;
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 try {
			 if (!iterating) {
				 cx.iterating.put(thisObj, 0);
				 for (i = 0;
				 i < length;
				 i++) {
					 if (i > 0) result.append(separator);
					 Object elem = getElem(cx, thisObj, i);
					 if (elem == null || elem == Undefined.instance) {
						 haslast = false;
						 continue;
					 }
					 haslast = true;
					 if (toSource) {
						 result.append(ScriptRuntime.uneval(cx, scope, elem));
					 }
					 else if (elem instanceof String) {
						 String s = (String)elem;
						 if (toSource) {
							 result.append('\""');
							 result.append(ScriptRuntime.escapeString(s));
							 result.append('\""');
						 }
						 else {
							 result.append(s);
						 }
					 }
					 else {
						 if (toLocale && elem != Undefined.instance && elem != null) {
							 Function fun;
							 Scriptable funThis;
							 fun = ScriptRuntime.getPropFunctionAndThis( elem, ""toLocaleString"", cx);
							 funThis = ScriptRuntime.lastStoredScriptable(cx);
							 elem = fun.call(cx, scope, funThis, ScriptRuntime.emptyArgs);
						 }
						 result.append(ScriptRuntime.toString(elem));
					 }
				 }
			 }
		 }
		 finally {
			 if (toplevel) {
				 cx.iterating = null;
			 }
		 }
		 if (toSource) {
			 if (!haslast && i > 0) result.append("", ]"");
			 else result.append(']');
		 }
		 return result.toString();
	 }
	 private static String js_join(Context cx, Scriptable thisObj, Object[] args) {
		 String separator;
		 long llength = getLengthProperty(cx, thisObj);
		 int length = (int)llength;
		 if (llength != length) {
			 throw Context.reportRuntimeError1( ""msg.arraylength.too.big"", String.valueOf(llength));
		 }
		 if (args.length < 1 || args[0] == Undefined.instance) {
			 separator = "","";
		 }
		 else {
			 separator = ScriptRuntime.toString(args[0]);
		 }
		 if (length == 0) {
			 return """";
		 }
		 String[] buf = new String[length];
		 int total_size = 0;
		 for (int i = 0;
		 i != length;
		 i++) {
			 Object temp = getElem(cx, thisObj, i);
			 if (temp != null && temp != Undefined.instance) {
				 String str = ScriptRuntime.toString(temp);
				 total_size += str.length();
				 buf[i] = str;
			 }
		 }
		 total_size += (length - 1) * separator.length();
		 StringBuffer sb = new StringBuffer(total_size);
		 for (int i = 0;
		 i != length;
		 i++) {
			 if (i != 0) {
				 sb.append(separator);
			 }
			 String str = buf[i];
			 if (str != null) {
				 sb.append(str);
			 }
		 }
		 return sb.toString();
	 }
	 private static Scriptable js_reverse(Context cx, Scriptable thisObj, Object[] args) {
		 long len = getLengthProperty(cx, thisObj);
		 long half = len / 2;
		 for(long i=0;
		 i < half;
		 i++) {
			 long j = len - i - 1;
			 Object temp1 = getElem(cx, thisObj, i);
			 Object temp2 = getElem(cx, thisObj, j);
			 setElem(cx, thisObj, i, temp2);
			 setElem(cx, thisObj, j, temp1);
		 }
		 return thisObj;
	 }
	 private static Scriptable js_sort(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 if (length <= 1) {
			 return thisObj;
		 }
		 Object compare;
		 Object[] cmpBuf;
		 if (args.length > 0 && Undefined.instance != args[0]) {
			 compare = args[0];
			 cmpBuf = new Object[2];
		 }
		 else {
			 compare = null;
			 cmpBuf = null;
		 }
		 if (length >= Integer.MAX_VALUE) {
			 heapsort_extended(cx, scope, thisObj, length, compare, cmpBuf);
		 }
		 else {
			 int ilength = (int)length;
			 Object[] working = new Object[ilength];
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 working[i] = getElem(cx, thisObj, i);
			 }
			 heapsort(cx, scope, working, ilength, compare, cmpBuf);
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 setElem(cx, thisObj, i, working[i]);
			 }
		 }
		 return thisObj;
	 }
	 private static boolean isBigger(Context cx, Scriptable scope, Object x, Object y, Object cmp, Object[] cmpBuf) {
		 if (cmp == null) {
			 if (cmpBuf != null) Kit.codeBug();
		 }
		 else {
			 if (cmpBuf == null || cmpBuf.length != 2) Kit.codeBug();
		 }
		 Object undef = Undefined.instance;
		 if (undef == y) {
			 return false;
		 }
		 else if (undef == x) {
			 return true;
		 }
		 if (cmp == null) {
			 String a = ScriptRuntime.toString(x);
			 String b = ScriptRuntime.toString(y);
			 return a.compareTo(b) > 0;
		 }
		 else {
			 cmpBuf[0] = x;
			 cmpBuf[1] = y;
			 Function fun = ScriptRuntime.getValueFunctionAndThis(cmp, cx);
			 Scriptable funThis = ScriptRuntime.lastStoredScriptable(cx);
			 Object ret = fun.call(cx, scope, funThis, cmpBuf);
			 double d = ScriptRuntime.toNumber(ret);
			 return d > 0;
		 }
	 }
	 private static void heapsort(Context cx, Scriptable scope, Object[] array, int length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (int i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = array[i];
			 heapify(cx, scope, pivot, array, i, length, cmp, cmpBuf);
		 }
		 for (int i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = array[i];
			 array[i] = array[0];
			 heapify(cx, scope, pivot, array, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify(Context cx, Scriptable scope, Object pivot, Object[] array, int i, int end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 int child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = array[child];
			 if (child + 1 < end) {
				 Object nextVal = array[child + 1];
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 array[i] = childVal;
			 i = child;
		 }
		 array[i] = pivot;
	 }
	 private static void heapsort_extended(Context cx, Scriptable scope, Scriptable target, long length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (long i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 heapify_extended(cx, scope, pivot, target, i, length, cmp, cmpBuf);
		 }
		 for (long i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 setElem(cx, target, i, getElem(cx, target, 0));
			 heapify_extended(cx, scope, pivot, target, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify_extended(Context cx, Scriptable scope, Object pivot, Scriptable target, long i, long end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 long child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = getElem(cx, target, child);
			 if (child + 1 < end) {
				 Object nextVal = getElem(cx, target, child + 1);
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 setElem(cx, target, i, childVal);
			 i = child;
		 }
		 setElem(cx, target, i, pivot);
	 }
	 private static Object js_push(Context cx, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 setElem(cx, thisObj, length + i, args[i]);
		 }
		 length += args.length;
		 Object lengthObj = setLengthProperty(cx, thisObj, length);
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) return args.length == 0 ? Context.getUndefinedValue() : args[args.length - 1];
		 else return lengthObj;
	 }
	 private static Object js_pop(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 length--;
			 result = getElem(cx, thisObj, length);
		 }
		 else {
			 result = Context.getUndefinedValue();
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_shift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 long i = 0;
			 length--;
			 result = getElem(cx, thisObj, i);
			 if (length > 0) {
				 for (i = 1;
				 i <= length;
				 i++) {
					 Object temp = getElem(cx, thisObj, i);
					 setElem(cx, thisObj, i - 1, temp);
				 }
			 }
		 }
		 else {
			 result = Context.getUndefinedValue();
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_unshift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 int argc = args.length;
		 if (args.length > 0) {
			 if (length > 0) {
				 for (long last = length - 1;
				 last >= 0;
				 last--) {
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, thisObj, last + argc, temp);
				 }
			 }
			 for (int i = 0;
			 i < args.length;
			 i++) {
				 setElem(cx, thisObj, i, args[i]);
			 }
			 length += args.length;
			 return setLengthProperty(cx, thisObj, length);
		 }
		 return ScriptRuntime.wrapNumber(length);
	 }
	 private static Object js_splice(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Object result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 int argc = args.length;
		 if (argc == 0) return result;
		 long length = getLengthProperty(cx, thisObj);
		 long begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
		 argc--;
		 long count;
		 if (args.length == 1) {
			 count = length - begin;
		 }
		 else {
			 double dcount = ScriptRuntime.toInteger(args[1]);
			 if (dcount < 0) {
				 count = 0;
			 }
			 else if (dcount > (length - begin)) {
				 count = length - begin;
			 }
			 else {
				 count = (long)dcount;
			 }
			 argc--;
		 }
		 long end = begin + count;
		 if (count != 0) {
			 if (count == 1 && (cx.getLanguageVersion() == Context.VERSION_1_2)) {
				 result = getElem(cx, thisObj, begin);
			 }
			 else {
				 for (long last = begin;
				 last != end;
				 last++) {
					 Scriptable resultArray = (Scriptable)result;
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, resultArray, last - begin, temp);
				 }
			 }
		 }
		 else if (count == 0 && cx.getLanguageVersion() == Context.VERSION_1_2) {
			 result = Context.getUndefinedValue();
		 }
		 long delta = argc - count;
		 if (delta > 0) {
			 for (long last = length - 1;
			 last >= end;
			 last--) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 else if (delta < 0) {
			 for (long last = end;
			 last < length;
			 last++) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 int argoffset = args.length - argc;
		 for (int i = 0;
		 i < argc;
		 i++) {
			 setElem(cx, thisObj, begin + i, args[i + argoffset]);
		 }
		 setLengthProperty(cx, thisObj, length + delta);
		 return result;
	 }
	 private static Scriptable js_concat(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(cx, scope, ""Array"");
		 Scriptable result = ctor.construct(cx, scope, ScriptRuntime.emptyArgs);
		 long length;
		 long slot = 0;
		 if (ScriptRuntime.instanceOf(thisObj, ctor, cx, scope)) {
			 length = getLengthProperty(cx, thisObj);
			 for (slot = 0;
			 slot < length;
			 slot++) {
				 Object temp = getElem(cx, thisObj, slot);
				 setElem(cx, result, slot, temp);
			 }
		 }
		 else {
			 setElem(cx, result, slot++, thisObj);
		 }
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (ScriptRuntime.instanceOf(args[i], ctor, cx, scope)) {
				 Scriptable arg = (Scriptable)args[i];
				 length = getLengthProperty(cx, arg);
				 for (long j = 0;
				 j < length;
				 j++, slot++) {
					 Object temp = getElem(cx, arg, j);
					 setElem(cx, result, slot, temp);
				 }
			 }
			 else {
				 setElem(cx, result, slot++, args[i]);
			 }
		 }
		 return result;
	 }
	 private Scriptable js_slice(Context cx, Scriptable thisObj, Object[] args) {
		 Scriptable scope = getTopLevelScope(this);
		 Scriptable result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 long length = getLengthProperty(cx, thisObj);
		 long begin, end;
		 if (args.length == 0) {
			 begin = 0;
			 end = length;
		 }
		 else {
			 begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
			 if (args.length == 1) {
				 end = length;
			 }
			 else {
				 end = toSliceIndex(ScriptRuntime.toInteger(args[1]), length);
			 }
		 }
		 for (long slot = begin;
		 slot < end;
		 slot++) {
			 Object temp = getElem(cx, thisObj, slot);
			 setElem(cx, result, slot - begin, temp);
		 }
		 return result;
	 }
	 private static long toSliceIndex(double value, long length) {
		 long result;
		 if (value < 0.0) {
			 if (value + length < 0.0) {
				 result = 0;
			 }
			 else {
				 result = (long)(value + length);
			 }
		 }
		 else if (value > length) {
			 result = length;
		 }
		 else {
			 result = (long)value;
		 }
		 return result;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 3: X=""pop"";
				id=Id_pop;
				 break L;
				 case 4: c=s.charAt(0);
				 if (c=='j') {
					 X=""join"";
					id=Id_join;
				 }
				 else if (c=='p') {
					 X=""push"";
					id=Id_push;
				 }
				 else if (c=='s') {
					 X=""sort"";
					id=Id_sort;
				 }
				 break L;
				 case 5: c=s.charAt(1);
				 if (c=='h') {
					 X=""shift"";
					id=Id_shift;
				 }
				 else if (c=='l') {
					 X=""slice"";
					id=Id_slice;
				 }
				 break L;
				 case 6: c=s.charAt(0);
				 if (c=='c') {
					 X=""concat"";
					id=Id_concat;
				 }
				 else if (c=='s') {
					 X=""splice"";
					id=Id_splice;
				 }
				 break L;
				 case 7: c=s.charAt(0);
				 if (c=='r') {
					 X=""reverse"";
					id=Id_reverse;
				 }
				 else if (c=='u') {
					 X=""unshift"";
					id=Id_unshift;
				 }
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
				 case 11: X=""constructor"";
				id=Id_constructor;
				 break L;
				 case 14: X=""toLocaleString"";
				id=Id_toLocaleString;
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toLocaleString = 3, Id_toSource = 4, Id_join = 5, Id_reverse = 6, Id_sort = 7, Id_push = 8, Id_pop = 9, Id_shift = 10, Id_unshift = 11, Id_splice = 12, Id_concat = 13, Id_slice = 14, MAX_PROTOTYPE_ID = 14;
	 private long length;
	 private Object[] dense;
	 private static final int maximumDenseLength = 10000;
}",1,0,0,0
"private void updateStatus() {
	try {
		long now = System.currentTimeMillis();
		if (this.eta == null) {
			this.eta = ""---"";
		}
		if (converting) {
			progress = this.convertPrg;
		}
		 else if (assembling) {
			long len = length > 0 ? length : downloaded;
			progress = (int) ((totalAssembled * 100) / len);
		}
		 else {
			long downloaded2 = 0;
			int processedSegments = 0;
			int partPrg = 0;
			downloadSpeed = 0;
			for (int i = 0;
			 i < chunks.size();
			 i++) {
				Segment s = chunks.get(i);
				downloaded2 += s.getDownloaded();
				downloadSpeed += s.getTransferRate();
				if (s.isFinished()) {
					processedSegments++;
				}
				 else if (s.getDownloaded() > 0 && s.getLength() > 0) {
					int prg2 = (int) ((s.getDownloaded() * 100) / s.getLength());
					partPrg += prg2;
				}
			}
			this.downloaded = downloaded2;
			if (chunks.size() > 0) {
				progress = (int) ((processedSegments * 100) / chunks.size());
				progress += (partPrg / chunks.size());
				if (segDet == null) {
					segDet = new SegmentDetails();
					if (segDet.getCapacity() < chunks.size()) {
						segDet.extend(chunks.size() - segDet.getCapacity());
					}
					segDet.setChunkCount(chunks.size());
				}
				SegmentInfo info = segDet.getChunkUpdates().get(0);
				info.setDownloaded(progress);
				info.setLength(100);
				info.setStart(0);
				long diff = downloaded - lastDownloaded;
				long timeSpend = now - prevTime;
				if (timeSpend > 0) {
					float rate = ((float) diff / timeSpend) * 1000;
					if (rate > downloadSpeed) {
						downloadSpeed = rate;
					}
					int prgDiff = progress - lastProgress;
					if (prgDiff > 0) {
						long eta = (timeSpend * (100 - progress) / 1000 * prgDiff);
						lastProgress = progress;
						this.eta = FormatUtilities.hms((int) eta);
					}
					prevTime = now;
					lastDownloaded = downloaded;
				}
			}
		}
		listener.downloadUpdated(id);
	}
	 catch (Exception e) {
		Logger.log(e);
	}
}",0,0,1,0
"public static class Argument {
	public static Argument SKIP_TESTS = Argument.arg(""skipTests"");
	 String name;
	 Optional<ArgumentValue<?>> value;
	private Argument(String name, ArgumentValue<?> value) {
		this(name, Optional.of(value));
	}
	static Argument of(String name) {
		return new Argument(name, Optional.empty());
	}
	public static Argument profile(String name, String... others) {
		Assert.hasText(name, ""Profiles must not be null or empty!"");
		Assert.notNull(others, ""Other profiles must not be null!"");
		String profiles = Stream.concat(Stream.of(name), Arrays.stream(others)).collect(Collectors.joining("",""));
		return Argument.of(""-P"".concat(profiles));
	}
	public static Argument arg(String name) {
		return Argument.of(""-D"".concat(name));
	}
	public static Argument debug() {
		return Argument.of(""-X"");
	}
	public Argument withValue(Object value) {
		return new Argument(name, ArgumentValue.of(value));
	}
	public Argument withQuotedValue(Object value) {
		return new Argument(name, ArgumentValue.of(value, it -> String.format(""\""%s\"""", it.toString())));
	}
	public Argument withValue(Masked masked) {
		return new Argument(name, ArgumentValue.of(masked));
	}
	public String toCommandLineArgument() {
		return toNameValuePair(value.map(ArgumentValue::toCommandLine));
	}
	public String toString() {
		return toNameValuePair(value.map(Object::toString));
	}
	private String toNameValuePair(Optional<String> source) {
		return source.map(it -> String.format(""%s=%s"", name, it)).orElse(name);
	}
	private static class ArgumentValue<T> {
		private final T value;
		private final Optional<Function<T, String>> preparer;
		private final Optional<Function<T, String>> toString;
		public static <T> ArgumentValue<T> of(T value) {
			return new ArgumentValue<>(value, Optional.empty(), Optional.empty());
		}
		public static <T> ArgumentValue<T> of(T value, Function<T, String> preparer) {
			return new ArgumentValue<>(value, Optional.of(preparer), Optional.empty());
		}
		public static <T extends Masked> ArgumentValue<T> of(T masked) {
			return new ArgumentValue<>(masked, Optional.empty(), Optional.of(it -> it.masked()));
		}
		public String toCommandLine() {
			return preparer.map(it -> it.apply(value)).orElseGet(() -> value.toString());
		}
		public String toString() {
			return toString.map(it -> it.apply(value)).orElseGet(() -> toCommandLine());
		}
	}
}",1,0,0,0
"protected MindMapXMLElement(ModeController pModeController, Vector ArrowLinkAdapters, HashMap IDToTarget);",0,0,0,0
"public class LinearPartitionChunk<T> implements PartitionChunk<T>{
	 private final int chunkNumber;
	 private final T object;
	 public LinearPartitionChunk( int chunkNumber, T object ) {
		 this.chunkNumber = chunkNumber;
		 this.object = object;
	 }
	 public T getObject() {
		 return object;
	 }
	 public boolean abuts(PartitionChunk<T> chunk) {
		 return true;
	 }
	 public boolean isStart() {
		 return true;
	 }
	 public boolean isEnd() {
		 return true;
	 }
	 public int getChunkNumber() {
		 return chunkNumber;
	 }
	 public int compareTo(PartitionChunk<T> chunk) {
		 if (chunk instanceof LinearPartitionChunk) {
			 LinearPartitionChunk<T> linearChunk = (LinearPartitionChunk<T>) chunk;
			 return Integer.compare(chunkNumber, linearChunk.chunkNumber);
		 }
		 throw new IllegalArgumentException(""Cannot compare against something that is not a LinearPartitionChunk."");
	 }
	 public boolean equals(Object o) {
		 if (this == o) {
			 return true;
		 }
		 if (o == null || getClass() != o.getClass()) {
			 return false;
		 }
		 return compareTo((LinearPartitionChunk<T>) o) == 0;
	 }
	 public int hashCode() {
		 return chunkNumber;
	 }
}",0,0,0,0
"private List<String> getSubSplits(String keyspace, String cfName, TokenRange range, Configuration conf) throws IOException {
	 int splitsize = ConfigHelper.getInputSplitSize(conf);
	 for (String host : range.endpoints) {
		 try {
			 Cassandra.Client client = createConnection(host, ConfigHelper.getRpcPort(conf), true);
			 client.set_keyspace(keyspace);
			 return client.describe_splits(cfName, range.start_token, range.end_token, splitsize);
		 }
		 catch (IOException e) {
			 logger.debug(""failed connect to endpoint "" + host, e);
		 }
		 catch (TException e) {
			 throw new RuntimeException(e);
		 }
		 catch (InvalidRequestException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 throw new IOException(""failed connecting to all endpoints "" + StringUtils.join(range.endpoints, "",""));
 }",0,0,0,0
"public static void scrubDataDirectories(String table, String columnFamily) {
	 logger.info(""Removing compacted SSTable files (see http: for (Map.Entry<Descriptor,Set<Component>> sstableFiles : files(table, columnFamily, true, true).entrySet()) {
		 Descriptor desc = sstableFiles.getKey();
		 Set<Component> components = sstableFiles.getValue();
		 if (components.contains(Component.COMPACTED_MARKER) || desc.temporary) {
			 SSTable.delete(desc, components);
			 continue;
		 }
		 File dataFile = new File(desc.filenameFor(Component.DATA));
		 if (components.contains(Component.DATA) && dataFile.length() > 0) continue;
		 logger.warn(""Removing orphans for {
		}
		: {
		}
		"", desc, components);
		 for (Component component : components) {
			 try {
				 FileUtils.deleteWithConfirm(desc.filenameFor(component));
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
		 }
	 }
	 Pattern tmpCacheFilePattern = Pattern.compile(table + ""-"" + columnFamily + ""-(Key|Row)Cache.*\\.tmp$"");
	 File dir = new File(DatabaseDescriptor.getSavedCachesLocation());
	 if (dir.exists()) {
		 assert dir.isDirectory();
		 for (File file : dir.listFiles()) if (tmpCacheFilePattern.matcher(file.getName()).matches()) if (!file.delete()) logger.warn(""could not delete "" + file.getAbsolutePath());
	 }
	 CFMetaData cfm = DatabaseDescriptor.getCFMetaData(table, columnFamily);
	 if (cfm != null) {
		 for (ColumnDefinition def : cfm.getColumn_metadata().values()) scrubDataDirectories(table, cfm.indexColumnFamilyName(def));
	 }
 }",0,0,0,0
"public class KerningRecord implements IDataType{
	 private int code1;
	 private int code2;
	 private int adjustment;
	 public int getCode1() {
		 return code1;
	 }
	 public void setCode1(int code1) {
		 this.code1 = code1;
	 }
	 public int getCode2() {
		 return code2;
	 }
	 public void setCode2(int code2) {
		 this.code2 = code2;
	 }
	 public int getAdjustment() {
		 return adjustment;
	 }
	 public void setAdjustment(int adjustment) {
		 this.adjustment = adjustment;
	 }
}",0,1,0,0
"public class WebClientInfo extends ClientInfo{
	private static final long serialVersionUID = 1L;
	private static final Logger log = LoggerFactory.getLogger(WebClientInfo.class);
	private final String userAgent;
	private final ClientProperties properties = new ClientProperties();
	public WebClientInfo(WebRequestCycle requestCycle){
		super();
		HttpServletRequest httpServletRequest = requestCycle.getWebRequest().getHttpServletRequest();
		userAgent = httpServletRequest.getHeader(""User-Agent"");
		properties.setRemoteAddress(getRemoteAddr(requestCycle));
		init();
	}
	public WebClientInfo(WebRequestCycle requestCycle, String userAgent){
		super();
		this.userAgent = userAgent;
		requestCycle.getWebRequest().getHttpServletRequest();
		properties.setRemoteAddress(getRemoteAddr(requestCycle));
		init();
	}
	public final ClientProperties getProperties(){
		return properties;
	}
	public final String getUserAgent(){
		return userAgent;
	}
	protected String getRemoteAddr(WebRequestCycle requestCycle){
		HttpServletRequest httpServletReq = requestCycle.getWebRequest().getHttpServletRequest();
		String remoteAddr = httpServletReq.getHeader(""X-Forwarded-For"");
		if (remoteAddr == null){
			remoteAddr = httpServletReq.getRemoteAddr();
		}
		else{
			if (remoteAddr.indexOf("","") != -1){
				remoteAddr = remoteAddr.split("","")[0].trim();
			}
		}
		return remoteAddr;
	}
	private final void init(){
		String userAgent = (getUserAgent() != null) ? getUserAgent().toLowerCase() : """";
		boolean browserChrome = userAgent.indexOf(""chrome"") != -1;
		boolean browserOpera = userAgent.indexOf(""opera"") != -1;
		boolean browserKonqueror = userAgent.indexOf(""konqueror"") != -1;
		boolean deceptiveUserAgent = browserOpera || browserKonqueror || browserChrome;
		boolean browserSafari = !deceptiveUserAgent && userAgent.indexOf(""safari"") != -1;
		deceptiveUserAgent = deceptiveUserAgent || browserSafari;
		boolean browserMozilla = !deceptiveUserAgent && userAgent.indexOf(""gecko"") != -1;
		boolean browserFireFox = userAgent.indexOf(""firefox"") != -1;
		boolean browserInternetExplorer = !deceptiveUserAgent && userAgent.indexOf(""msie"") != -1;
		int majorVersion = -1, minorVersion = -1;
		if (browserOpera){
			properties.setBrowserOpera(true);
		}
		else if (browserKonqueror){
			properties.setBrowserKonqueror(true);
		}
		else if (browserSafari){
			properties.setBrowserSafari(true);
		}
		else if (browserChrome){
			properties.setBrowserChrome(true);
		}
		else if (browserMozilla){
			properties.setBrowserMozilla(true);
			if (browserFireFox){
				properties.setBrowserMozillaFirefox(true);
			}
		}
		else if (browserInternetExplorer){
			properties.setBrowserInternetExplorer(true);
			Matcher matcher = Pattern.compile(""msie (\\d+)"").matcher(userAgent);
			if (matcher.find()){
				majorVersion = Integer.parseInt(matcher.group(1));
			}
		}
		if (majorVersion != -1){
			properties.setBrowserVersionMajor(majorVersion);
		}
		if (minorVersion != -1){
			properties.setBrowserVersionMinor(minorVersion);
		}
		if (browserInternetExplorer){
			properties.setProprietaryIECssExpressionsSupported(true);
			properties.setQuirkCssPositioningOneSideOnly(true);
			properties.setQuirkIERepaint(true);
			properties.setQuirkIESelectZIndex(true);
			properties.setQuirkIETextareaNewlineObliteration(true);
			properties.setQuirkIESelectPercentWidth(true);
			properties.setQuirkIESelectListDomUpdate(true);
			properties.setQuirkIETablePercentWidthScrollbarError(true);
			properties.setQuirkCssBackgroundAttachmentUseFixed(true);
			properties.setQuirkCssBorderCollapseInside(true);
			properties.setQuirkCssBorderCollapseFor0Padding(true);
			if (majorVersion < 7){
				properties.setProprietaryIEPngAlphaFilterRequired(true);
			}
		}
		if (browserMozilla){
			properties.setQuirkMozillaTextInputRepaint(true);
			properties.setQuirkMozillaPerformanceLargeDomRemove(true);
		}
		if (log.isDebugEnabled()){
			log.debug(""determined user agent: "" + properties);
		}
	}
}",0,0,0,0
"public class MoveTargetsCommand {
	public static final String ACTION_SEARCH = ""Search"";
	public static final String ACTION_CANCEL = ""Cancel"";
	public static final String ACTION_MOVE_TARGETS = ""Move"";
	public static final String SESSION_TARGETGROUP = ""MoveTargetTargetGroup"";
	private String search = null;
	private int pageNumber = 0;
	private String selectedPageSize;
	private String actionCmd = null;
	private long[] parentOids = null;
	private int parentIndex = 0;
	private int selectedCount = 0;
	public MoveTargetsCommand(){
		parentOids = new long[0];
	}
	public String getActionCmd() {
		return actionCmd;
	}
	public void setActionCmd(String action) {
		this.actionCmd = action;
	}
	public int getPageNumber() {
		return pageNumber;
	}
	public void setPageNumber(int pageNumber) {
		this.pageNumber = pageNumber;
	}
	public String getSelectedPageSize() {
		return selectedPageSize;
	}
	public void setSelectedPageSize(String selectedPageSize) {
		this.selectedPageSize = selectedPageSize;
	}
	public String getSearch() {
		return search;
	}
	public void setSearch(String search) {
		this.search = search;
	}
	public long[] getParentOids() {
		return parentOids;
	}
	public void setParentOids(long[] parentOids) {
		this.parentOids = parentOids;
	}
	public int getParentIndex() {
		return parentIndex;
	}
	public void setParentIndex(int parentIndex) {
		this.parentIndex = parentIndex;
	}
	public int getSelectedCount() {
		return selectedCount;
	}
	public void setSelectedCount(int selectedCount) {
		this.selectedCount = selectedCount;
	}
}",0,1,0,0
"private boolean optimizeForGoal(ClusterModel clusterModel, Goal goal, GoalViolations goalViolations, Set<Integer> excludedBrokersForLeadership, Set<Integer> excludedBrokersForReplicaMove) throws KafkaCruiseControlException {
	 if (clusterModel.topics().isEmpty()) {
		 LOG.info(""Skipping goal violation detection because the cluster model does not have any topic."");
		 return false;
	 }
	 Map<TopicPartition, List<Integer>> initReplicaDistribution = clusterModel.getReplicaDistribution();
	 Map<TopicPartition, Integer> initLeaderDistribution = clusterModel.getLeaderDistribution();
	 try {
		 goal.optimize(clusterModel, new HashSet<>(), new OptimizationOptions(excludedTopics(clusterModel), excludedBrokersForLeadership, excludedBrokersForReplicaMove));
	 }
	 catch (OptimizationFailureException ofe) {
		 goalViolations.addViolation(goal.name(), false);
		 return true;
	 }
	 Set<ExecutionProposal> proposals = AnalyzerUtils.getDiff(initReplicaDistribution, initLeaderDistribution, clusterModel);
	 LOG.trace(""{
	}
	 generated {
	}
	 proposals"", goal.name(), proposals.size());
	 if (!proposals.isEmpty()) {
		 goalViolations.addViolation(goal.name(), true);
		 return true;
	 }
	 else {
		 return false;
	 }
 }",0,0,1,0
"public RecordWriter getRecordWriter(FileSystem fs, JobConf job, String name, Progressable progress) throws IOException {
	 this.urlNormalizers = new URLNormalizers(job, URLNormalizers.SCOPE_OUTLINK);
	 this.filters = new URLFilters(job);
	 this.scfilters = new ScoringFilters(job);
	 final float interval = job.getFloat(""db.default.fetch.interval"", 30f);
	 final boolean ignoreExternalLinks = job.getBoolean(""db.ignore.external.links"", false);
	 Path text = new Path(new Path(job.getOutputPath(), ParseText.DIR_NAME), name);
	 Path data = new Path(new Path(job.getOutputPath(), ParseData.DIR_NAME), name);
	 Path crawl = new Path(new Path(job.getOutputPath(), CrawlDatum.PARSE_DIR_NAME), name);
	 final MapFile.Writer textOut = new MapFile.Writer(job, fs, text.toString(), Text.class, ParseText.class, CompressionType.RECORD);
	 final MapFile.Writer dataOut = new MapFile.Writer(job, fs, data.toString(), Text.class,ParseData.class);
	 final SequenceFile.Writer crawlOut = SequenceFile.createWriter(fs, job, crawl, Text.class, CrawlDatum.class);
	 return new RecordWriter() {
		 public void write(WritableComparable key, Writable value) throws IOException {
			 Parse parse = (Parse)value;
			 String fromUrl = key.toString();
			 String fromHost = null;
			 String toHost = null;
			 textOut.append(key, new ParseText(parse.getText()));
			 ParseData parseData = parse.getData();
			 String sig = parseData.getContentMeta().get(Nutch.SIGNATURE_KEY);
			 if (sig != null) {
				 byte[] signature = StringUtil.fromHexString(sig);
				 if (signature != null) {
					 CrawlDatum d = new CrawlDatum(CrawlDatum.STATUS_SIGNATURE, 0.0f);
					 d.setSignature(signature);
					 crawlOut.append(key, d);
				 }
			 }
			 Outlink[] links = parseData.getOutlinks();
			 if (ignoreExternalLinks) {
				 try {
					 fromHost = new URL(fromUrl).getHost().toLowerCase();
				 }
				 catch (MalformedURLException e) {
					 fromHost = null;
				 }
			 }
			 else {
				 fromHost = null;
			 }
			 String[] toUrls = new String[links.length];
			 int validCount = 0;
			 for (int i = 0;
			 i < links.length;
			 i++) {
				 String toUrl = links[i].getToUrl();
				 try {
					 toUrl = urlNormalizers.normalize(toUrl, URLNormalizers.SCOPE_OUTLINK);
					 toUrl = filters.filter(toUrl);
				 }
				 catch (Exception e) {
					 toUrl = null;
				 }
				 if (fromUrl.equals(toUrl)) toUrl = null;
				 if (toUrl != null) validCount++;
				 toUrls[i] = toUrl;
			 }
			 CrawlDatum adjust = null;
			 for (int i = 0;
			 i < toUrls.length;
			 i++) {
				 if (toUrls[i] == null) continue;
				 if (ignoreExternalLinks) {
					 try {
						 toHost = new URL(toUrls[i]).getHost().toLowerCase();
					 }
					 catch (MalformedURLException e) {
						 toHost = null;
					 }
					 if (toHost == null || !toHost.equals(fromHost)) {
						 continue;
					 }
				 }
				 CrawlDatum target = new CrawlDatum(CrawlDatum.STATUS_LINKED, interval);
				 Text targetUrl = new Text(toUrls[i]);
				 adjust = null;
				 try {
					 adjust = scfilters.distributeScoreToOutlink((Text)key, targetUrl, parseData, target, null, links.length, validCount);
				 }
				 catch (ScoringFilterException e) {
					 if (LOG.isWarnEnabled()) {
						 LOG.warn(""Cannot distribute score from "" + key + "" to "" + targetUrl + "" - skipped ("" + e.getMessage());
					 }
					 continue;
				 }
				 crawlOut.append(targetUrl, target);
				 if (adjust != null) crawlOut.append(key, adjust);
			 }
			 dataOut.append(key, parseData);
		 }
		 public void close(Reporter reporter) throws IOException {
			 textOut.close();
			 dataOut.close();
			 crawlOut.close();
		 }
	 }
	;
 }",0,0,1,0
"public class Replace extends MatchingTask {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private File sourceFile = null;
	 private NestedString token = null;
	 private NestedString value = new NestedString();
	 private Resource propertyResource = null;
	 private Resource replaceFilterResource = null;
	 private Properties properties = null;
	 private ArrayList replacefilters = new ArrayList();
	 private File dir = null;
	 private int fileCount;
	 private int replaceCount;
	 private boolean summary = false;
	 private String encoding = null;
	 private Union resources;
	 private boolean preserveLastModified = false;
	 private boolean failOnNoReplacements = false;
	 public class NestedString {
		 private boolean expandProperties = false;
		 private StringBuffer buf = new StringBuffer();
		 public void setExpandProperties(boolean b) {
			 expandProperties = b;
		 }
		 public void addText(String val) {
			 buf.append(val);
		 }
		 public String getText() {
			 String s = buf.toString();
			 return expandProperties ? getProject().replaceProperties(s) : s;
		 }
	 }
	 public class Replacefilter {
		 private NestedString token;
		 private NestedString value;
		 private String replaceValue;
		 private String property;
		 private StringBuffer inputBuffer;
		 private StringBuffer outputBuffer = new StringBuffer();
		 public void validate() throws BuildException {
			 if (token == null) {
				 String message = ""token is a mandatory for replacefilter."";
				 throw new BuildException(message);
			 }
			 if ("""".equals(token.getText())) {
				 String message = ""The token must not be an empty "" + ""string."";
				 throw new BuildException(message);
			 }
			 if ((value != null) && (property != null)) {
				 String message = ""Either value or property "" + ""can be specified, but a replacefilter "" + ""element cannot have both."";
				 throw new BuildException(message);
			 }
			 if ((property != null)) {
				 if (propertyResource == null) {
					 String message = ""The replacefilter's property attribute "" + ""can only be used with the replacetask's "" + ""propertyFile/Resource attribute."";
					 throw new BuildException(message);
				 }
				 if (properties == null || properties.getProperty(property) == null) {
					 String message = ""property \"""" + property + ""\"" was not found in "" + propertyResource.getName();
					 throw new BuildException(message);
				 }
			 }
			 replaceValue = getReplaceValue();
		 }
		 public String getReplaceValue() {
			 if (property != null) {
				 return properties.getProperty(property);
			 }
			 else if (value != null) {
				 return value.getText();
			 }
			 else if (Replace.this.value != null) {
				 return Replace.this.value.getText();
			 }
			 else {
				 return """";
			 }
		 }
		 public void setToken(String t) {
			 createReplaceToken().addText(t);
		 }
		 public String getToken() {
			 return token.getText();
		 }
		 public void setValue(String value) {
			 createReplaceValue().addText(value);
		 }
		 public String getValue() {
			 return value.getText();
		 }
		 public void setProperty(String property) {
			 this.property = property;
		 }
		 public String getProperty() {
			 return property;
		 }
		 public NestedString createReplaceToken() {
			 if (token == null) {
				 token = new NestedString();
			 }
			 return token;
		 }
		 public NestedString createReplaceValue() {
			 if (value == null) {
				 value = new NestedString();
			 }
			 return value;
		 }
		 StringBuffer getOutputBuffer() {
			 return outputBuffer;
		 }
		 void setInputBuffer(StringBuffer input) {
			 inputBuffer = input;
		 }
		 boolean process() {
			 String t = getToken();
			 if (inputBuffer.length() > t.length()) {
				 int pos = replace();
				 pos = Math.max((inputBuffer.length() - t.length()), pos);
				 outputBuffer.append(inputBuffer.substring(0, pos));
				 inputBuffer.delete(0, pos);
				 return true;
			 }
			 return false;
		 }
		 void flush() {
			 replace();
			 outputBuffer.append(inputBuffer);
			 inputBuffer.delete(0, inputBuffer.length());
		 }
		 private int replace() {
			 String t = getToken();
			 int found = inputBuffer.indexOf(t);
			 int pos = -1;
			 final int tokenLength = t.length();
			 final int replaceValueLength = replaceValue.length();
			 while (found >= 0) {
				 inputBuffer.replace(found, found + tokenLength, replaceValue);
				 pos = found + replaceValueLength;
				 found = inputBuffer.indexOf(t, pos);
				 ++replaceCount;
			 }
			 return pos;
		 }
	 }
	 private class FileInput {
		 private StringBuffer outputBuffer;
		 private Reader reader;
		 private char[] buffer;
		 private static final int BUFF_SIZE = 4096;
		 FileInput(File source) throws IOException {
			 outputBuffer = new StringBuffer();
			 buffer = new char[BUFF_SIZE];
			 if (encoding == null) {
				 reader = new BufferedReader(new FileReader(source));
			 }
			 else {
				 reader = new BufferedReader(new InputStreamReader( new FileInputStream(source), encoding));
			 }
		 }
		 StringBuffer getOutputBuffer() {
			 return outputBuffer;
		 }
		 boolean readChunk() throws IOException {
			 int bufferLength = 0;
			 bufferLength = reader.read(buffer);
			 if (bufferLength < 0) {
				 return false;
			 }
			 outputBuffer.append(new String(buffer, 0, bufferLength));
			 return true;
		 }
		 void close() throws IOException {
			 reader.close();
		 }
		 void closeQuietly() {
			 FileUtils.close(reader);
		 }
	 }
	 private class FileOutput {
		 private StringBuffer inputBuffer;
		 private Writer writer;
		 FileOutput(File out) throws IOException {
			 if (encoding == null) {
				 writer = new BufferedWriter(new FileWriter(out));
			 }
			 else {
				 writer = new BufferedWriter(new OutputStreamWriter (new FileOutputStream(out), encoding));
			 }
		 }
		 void setInputBuffer(StringBuffer input) {
			 inputBuffer = input;
		 }
		 boolean process() throws IOException {
			 writer.write(inputBuffer.toString());
			 inputBuffer.delete(0, inputBuffer.length());
			 return false;
		 }
		 void flush() throws IOException {
			 process();
			 writer.flush();
		 }
		 void close() throws IOException {
			 writer.close();
		 }
		 void closeQuietly() {
			 FileUtils.close(writer);
		 }
	 }
	 public void execute() throws BuildException {
		 ArrayList savedFilters = (ArrayList) replacefilters.clone();
		 Properties savedProperties = properties == null ? null : (Properties) properties.clone();
		 if (token != null) {
			 StringBuffer val = new StringBuffer(value.getText());
			 stringReplace(val, ""\r\n"", ""\n"");
			 stringReplace(val, ""\n"", StringUtils.LINE_SEP);
			 StringBuffer tok = new StringBuffer(token.getText());
			 stringReplace(tok, ""\r\n"", ""\n"");
			 stringReplace(tok, ""\n"", StringUtils.LINE_SEP);
			 Replacefilter firstFilter = createPrimaryfilter();
			 firstFilter.setToken(tok.toString());
			 firstFilter.setValue(val.toString());
		 }
		 try {
			 if (replaceFilterResource != null) {
				 Properties props = getProperties(replaceFilterResource);
				 Iterator e = props.keySet().iterator();
				 while (e.hasNext()) {
					 String tok = e.next().toString();
					 Replacefilter replaceFilter = createReplacefilter();
					 replaceFilter.setToken(tok);
					 replaceFilter.setValue(props.getProperty(tok));
				 }
			 }
			 validateAttributes();
			 if (propertyResource != null) {
				 properties = getProperties(propertyResource);
			 }
			 validateReplacefilters();
			 fileCount = 0;
			 replaceCount = 0;
			 if (sourceFile != null) {
				 processFile(sourceFile);
			 }
			 if (dir != null) {
				 DirectoryScanner ds = super.getDirectoryScanner(dir);
				 String[] srcs = ds.getIncludedFiles();
				 for (int i = 0;
				 i < srcs.length;
				 i++) {
					 File file = new File(dir, srcs[i]);
					 processFile(file);
				 }
			 }
			 if (resources != null) {
				 for (Iterator i = resources.iterator();
				 i.hasNext();
				 ) {
					 FileProvider fp = (FileProvider) ((Resource) i.next()) .as(FileProvider.class);
					 processFile(fp.getFile());
				 }
			 }
			 if (summary) {
				 log(""Replaced "" + replaceCount + "" occurrences in "" + fileCount + "" files."", Project.MSG_INFO);
			 }
			 if (failOnNoReplacements && replaceCount == 0) {
				 throw new BuildException(""didn't replace anything"");
			 }
		 }
		 finally {
			 replacefilters = savedFilters;
			 properties = savedProperties;
		 }
	 }
	 public void validateAttributes() throws BuildException {
		 if (sourceFile == null && dir == null && resources == null) {
			 String message = ""Either the file or the dir attribute "" + ""or nested resources must be specified"";
			 throw new BuildException(message, getLocation());
		 }
		 if (propertyResource != null && !propertyResource.isExists()) {
			 String message = ""Property file "" + propertyResource.getName() + "" does not exist."";
			 throw new BuildException(message, getLocation());
		 }
		 if (token == null && replacefilters.size() == 0) {
			 String message = ""Either token or a nested replacefilter "" + ""must be specified"";
			 throw new BuildException(message, getLocation());
		 }
		 if (token != null && """".equals(token.getText())) {
			 String message = ""The token attribute must not be an empty string."";
			 throw new BuildException(message, getLocation());
		 }
	 }
	 public void validateReplacefilters() throws BuildException {
		 final int size = replacefilters.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 Replacefilter element = (Replacefilter) replacefilters.get(i);
			 element.validate();
		 }
	 }
	 public Properties getProperties(File propertyFile) throws BuildException {
		 return getProperties(new FileResource(getProject(), propertyFile));
	 }
	 public Properties getProperties(Resource propertyResource) throws BuildException {
		 Properties props = new Properties();
		 InputStream in = null;
		 try {
			 in = propertyResource.getInputStream();
			 props.load(in);
		 }
		 catch (IOException e) {
			 String message = ""Property resource ("" + propertyResource.getName() + "") cannot be loaded."";
			 throw new BuildException(message);
		 }
		 finally {
			 FileUtils.close(in);
		 }
		 return props;
	 }
	 private void processFile(File src) throws BuildException {
		 if (!src.exists()) {
			 throw new BuildException(""Replace: source file "" + src.getPath() + "" doesn't exist"", getLocation());
		 }
		 File temp = null;
		 FileInput in = null;
		 FileOutput out = null;
		 try {
			 in = new FileInput(src);
			 temp = FILE_UTILS.createTempFile(""rep"", "".tmp"", src.getParentFile(), false, true);
			 out = new FileOutput(temp);
			 int repCountStart = replaceCount;
			 logFilterChain(src.getPath());
			 out.setInputBuffer(buildFilterChain(in.getOutputBuffer()));
			 while (in.readChunk()) {
				 if (processFilterChain()) {
					 out.process();
				 }
			 }
			 flushFilterChain();
			 out.flush();
			 in.close();
			 in = null;
			 out.close();
			 out = null;
			 boolean changes = (replaceCount != repCountStart);
			 if (changes) {
				 fileCount++;
				 long origLastModified = src.lastModified();
				 FILE_UTILS.rename(temp, src);
				 if (preserveLastModified) {
					 FILE_UTILS.setFileLastModified(src, origLastModified);
				 }
				 temp = null;
			 }
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""IOException in "" + src + "" - "" + ioe.getClass().getName() + "":"" + ioe.getMessage(), ioe, getLocation());
		 }
		 finally {
			 if (null != in) {
				 in.closeQuietly();
			 }
			 if (null != out) {
				 out.closeQuietly();
			 }
			 if (temp != null) {
				 if (!temp.delete()) {
					 temp.deleteOnExit();
				 }
			 }
		 }
	 }
	 private void flushFilterChain() {
		 final int size = replacefilters.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 Replacefilter filter = (Replacefilter) replacefilters.get(i);
			 filter.flush();
		 }
	 }
	 private boolean processFilterChain() {
		 final int size = replacefilters.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 Replacefilter filter = (Replacefilter) replacefilters.get(i);
			 if (!filter.process()) {
				 return false;
			 }
		 }
		 return true;
	 }
	 private StringBuffer buildFilterChain(StringBuffer inputBuffer) {
		 StringBuffer buf = inputBuffer;
		 final int size = replacefilters.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 Replacefilter filter = (Replacefilter) replacefilters.get(i);
			 filter.setInputBuffer(buf);
			 buf = filter.getOutputBuffer();
		 }
		 return buf;
	 }
	 private void logFilterChain(String filename) {
		 final int size = replacefilters.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 Replacefilter filter = (Replacefilter) replacefilters.get(i);
			 log(""Replacing in "" + filename + "": "" + filter.getToken() + "" --> "" + filter.getReplaceValue(), Project.MSG_VERBOSE);
		 }
	 }
	 public void setFile(File file) {
		 this.sourceFile = file;
	 }
	 public void setSummary(boolean summary) {
		 this.summary = summary;
	 }
	 public void setReplaceFilterFile(File replaceFilterFile) {
		 setReplaceFilterResource(new FileResource(getProject(), replaceFilterFile));
	 }
	 public void setReplaceFilterResource(Resource replaceFilter) {
		 this.replaceFilterResource = replaceFilter;
	 }
	 public void setDir(File dir) {
		 this.dir = dir;
	 }
	 public void setToken(String token) {
		 createReplaceToken().addText(token);
	 }
	 public void setValue(String value) {
		 createReplaceValue().addText(value);
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public NestedString createReplaceToken() {
		 if (token == null) {
			 token = new NestedString();
		 }
		 return token;
	 }
	 public NestedString createReplaceValue() {
		 return value;
	 }
	 public void setPropertyFile(File propertyFile) {
		 setPropertyResource(new FileResource(propertyFile));
	 }
	 public void setPropertyResource(Resource propertyResource) {
		 this.propertyResource = propertyResource;
	 }
	 public Replacefilter createReplacefilter() {
		 Replacefilter filter = new Replacefilter();
		 replacefilters.add(filter);
		 return filter;
	 }
	 public void addConfigured(ResourceCollection rc) {
		 if (!rc.isFilesystemOnly()) {
			 throw new BuildException(""only filesystem resources are supported"");
		 }
		 if (resources == null) {
			 resources = new Union();
		 }
		 resources.add(rc);
	 }
	 public void setPreserveLastModified(boolean b) {
		 preserveLastModified = b;
	 }
	 public void setFailOnNoReplacements(boolean b) {
		 failOnNoReplacements = b;
	 }
	 private Replacefilter createPrimaryfilter() {
		 Replacefilter filter = new Replacefilter();
		 replacefilters.add(0, filter);
		 return filter;
	 }
	 private void stringReplace(StringBuffer str, String str1, String str2) {
		 int found = str.indexOf(str1);
		 final int str1Length = str1.length();
		 final int str2Length = str2.length();
		 while (found >= 0) {
			 str.replace(found, found + str1Length, str2);
			 found = str.indexOf(str1, found + str2Length);
		 }
	 }
}",0,0,0,0
"public final Object getSourceValue(){
	return sourceValue;
}",0,0,0,0
"protected void drawLeftPen(Graphics2D grx, JRPen topPen, JRPen leftPen, JRPen bottomPen, JRPrintElement element, int offsetX, int offsetY);",0,0,0,1
"public static class EmfPolyPolygon16 extends EmfPolyPolygon {
	 public HemfRecordType getEmfRecordType() {
		 return HemfRecordType.polyPolygon16;
	 }
	 protected long readPoint(LittleEndianInputStream leis, Point2D point) {
		 return readPointS(leis, point);
	 }
 }",0,0,0,0
"static class OplogEntryIdSet {
	 private final IntOpenHashSet ints = new IntOpenHashSet((int) INVALID_ID);
	 private final LongOpenHashSet longs = new LongOpenHashSet((int) INVALID_ID);
	 public void add(long id) {
		 if (id == 0) {
			 throw new IllegalArgumentException();
		 }
		 else if (id > 0 && id <= 0x00000000FFFFFFFFL) {
			 this.ints.add((int) id);
		 }
		 else {
			 this.longs.add(id);
		 }
	 }
	 public boolean contains(long id) {
		 if (id >= 0 && id <= 0x00000000FFFFFFFFL) {
			 return this.ints.contains((int) id);
		 }
		 else {
			 return this.longs.contains(id);
		 }
	 }
	 public int size() {
		 return this.ints.size() + this.longs.size();
	 }
 }",0,0,0,0
"private void doSmapText(Node n) {
	 String text = n.getText();
	 int index = 0;
	 int next = 0;
	 int lineCount = 1;
	 int skippedLines = 0;
	 boolean slashStarSeen = false;
	 boolean beginning = true;
	 while ((next = text.indexOf('\n', index)) > -1) {
		 if (beginning) {
			 String line = text.substring(index, next).trim();
			 if (!slashStarSeen && line.startsWith("""");
			 if (endIndex >= 0) {
				 slashStarSeen = false;
				 if (endIndex < line.length() - 2) {
					 skippedLines--;
					 beginning = false;
				 }
			 }
		 }
		 else if (line.length() == 0 || line.startsWith("" skippedLines++;
	 }
	 else {
		 beginning = false;
	 }
 }
 lineCount++;
 index = next + 1;
 }
 doSmap(n, lineCount, 1, skippedLines);
 }",0,0,1,0
"public class BuckAddDependencyIntention extends BaseIntentionAction {
	 private static Logger LOGGER = Logger.getInstance(BuckAddDependencyIntention.class);
	 public static BuckAddDependencyIntention create( PsiJavaCodeReferenceElement referenceElement, PsiClass psiClass) {
		 VirtualFile editSourceFile = referenceElement.getContainingFile().getVirtualFile();
		 if (editSourceFile == null) {
			 return null;
		 }
		 Project project = referenceElement.getProject();
		 BuckTargetLocator buckTargetLocator = BuckTargetLocator.getInstance(project);
		 VirtualFile editBuildFile = buckTargetLocator.findBuckFileForVirtualFile(editSourceFile).orElse(null);
		 if (editBuildFile == null) {
			 return null;
		 }
		 VirtualFile importSourceFile = psiClass.getContainingFile().getVirtualFile();
		 if (importSourceFile == null) {
			 return null;
		 }
		 VirtualFile importBuildFile = buckTargetLocator.findBuckFileForVirtualFile(importSourceFile).orElse(null);
		 if (importBuildFile == null) {
			 return null;
		 }
		 if (importBuildFile.equals(editBuildFile)) {
			 return null;
		 }
		 ProjectFileIndex projectFileIndex = ProjectFileIndex.getInstance(project);
		 Module editModule = projectFileIndex.getModuleForFile(editSourceFile);
		 if (editModule == null) {
			 return null;
		 }
		 Module importModule = projectFileIndex.getModuleForFile(importSourceFile);
		 if (importModule == null) {
			 return null;
		 }
		 BuckTarget editSourceTarget = buckTargetLocator .findTargetPatternForVirtualFile(editSourceFile) .flatMap(BuckTargetPattern::asBuckTarget) .orElse(null);
		 if (editSourceTarget == null) {
			 return null;
		 }
		 BuckTarget importSourceTarget = buckTargetLocator .findTargetPatternForVirtualFile(importSourceFile) .flatMap(BuckTargetPattern::asBuckTarget) .orElse(null);
		 if (importSourceTarget == null) {
			 return null;
		 }
		 return new BuckAddDependencyIntention( project, referenceElement, editBuildFile, editSourceFile, editSourceTarget, editModule, psiClass, importBuildFile, importSourceFile, importSourceTarget, importModule);
	 }
	 private Project project;
	 private PsiJavaCodeReferenceElement referenceElement;
	 private VirtualFile editBuildFile;
	 private VirtualFile editSourceFile;
	 private BuckTarget editSourceTarget;
	 private BuckTarget editTarget;
	 private Module editModule;
	 private PsiClass psiClass;
	 private VirtualFile importBuildFile;
	 private VirtualFile importSourceFile;
	 private BuckTarget importSourceTarget;
	 private BuckTarget importTarget;
	 private Module importModule;
	 BuckAddDependencyIntention( Project project, PsiJavaCodeReferenceElement referenceElement, VirtualFile editBuildFile, VirtualFile editSourceFile, BuckTarget editSourceTarget, Module editModule, PsiClass psiClass, VirtualFile importBuildFile, VirtualFile importSourceFile, BuckTarget importSourceTarget, Module importModule) {
		 this.project = project;
		 this.referenceElement = referenceElement;
		 this.editBuildFile = editBuildFile;
		 this.editSourceFile = editSourceFile;
		 this.editSourceTarget = editSourceTarget;
		 this.editModule = editModule;
		 this.psiClass = psiClass;
		 this.importBuildFile = importBuildFile;
		 this.importSourceFile = importSourceFile;
		 this.importSourceTarget = importSourceTarget;
		 this.importModule = importModule;
		 String message = ""Add BUCK dependency on owner("" + importSourceTarget + "")"";
		 setText(message);
	 }
	 public String getFamilyName() {
		 return this.getClass().getSimpleName();
	 }
	 public boolean isAvailable( Project project, Editor editor, PsiFile psiFile) {
		 return true;
	 }
	 public void invoke( Project project, Editor editor, PsiFile psiFile) throws IncorrectOperationException {
		 String msg = ""Invoked for project "" + project.getName() + "" and file "" + psiFile.getName();
		 LOGGER.info(msg);
		 queryBuckForTargets(editor);
	 }
	 static class TargetMetadata {
		 public BuckTarget target;
		 public List<BuckTarget> deps;
		 public List<BuckTargetPattern> visibility;
		 public List<String> srcs;
		 public List<String> resources;
		 static TargetMetadata from( BuckTargetLocator buckTargetLocator, BuckTarget target, JsonObject payload) {
			 TargetMetadata targetMetadata = new TargetMetadata();
			 targetMetadata.target = target;
			 targetMetadata.srcs = stringListOrNull(payload.get(""srcs""));
			 targetMetadata.resources = stringListOrNull(payload.get(""resources""));
			 targetMetadata.deps = Optional.ofNullable(stringListOrNull(payload.get(""deps""))) .map( deps -> deps.stream() .map( s -> BuckTarget.parse(s).map(buckTargetLocator::resolve).orElse(null)) .collect(Collectors.toList())) .orElse(null);
			 List<String> optionalVisibility = stringListOrNull(payload.get(""visibility""));
			 if (optionalVisibility == null) {
				 targetMetadata.visibility = Collections.singletonList(target.asPattern().asPackageMatchingPattern());
			 }
			 else if (optionalVisibility.contains(""PUBLIC"")) {
				 targetMetadata.visibility = null;
			 }
			 else {
				 targetMetadata.visibility = optionalVisibility .stream() .map(p -> BuckTargetPattern.parse(p).map(buckTargetLocator::resolve).orElse(null)) .collect(Collectors.toList());
			 }
			 return targetMetadata;
		 }
		 static List<String> stringListOrNull( JsonElement jsonElement) {
			 if (jsonElement == null) {
				 return null;
			 }
			 return new Gson().fromJson(jsonElement, new TypeToken<List<String>>() {
			}
			.getType());
		 }
		 boolean isVisibleTo(BuckTarget target) {
			 if (visibility == null) {
				 return true;
			 }
			 return visibility.stream().anyMatch(pattern -> pattern.matches(target));
		 }
		 boolean hasDependencyOn(BuckTarget target) {
			 return deps.stream().anyMatch(dep -> dep.equals(target));
		 }
		 boolean contains(BuckTarget targetFile) {
			 if (!target.asPattern().asPackageMatchingPattern().matches(targetFile)) {
				 return false;
			 }
			 String relativeToBuildFile = targetFile.getRuleName();
			 return srcs.contains(relativeToBuildFile) || resources.contains(relativeToBuildFile);
		 }
	 }
	 private void queryBuckForTargets(Editor editor) {
		 BuckTargetLocator buckTargetLocator = BuckTargetLocator.getInstance(project);
		 String editPath = editSourceFile.getPath();
		 String importPath = importSourceFile.getPath();
		 BuckJsonCommandHandler<List<TargetMetadata>> handler = new BuckJsonCommandHandler<>( project, BuckCommand.QUERY, new Callback<List<TargetMetadata>>() {
			 public List<TargetMetadata> deserialize(JsonElement jsonElement) throws IOException {
				 Type type = new TypeToken<Map<String, JsonObject>>() {
				}
				.getType();
				 Map<String, JsonObject> raw = new Gson().fromJson(jsonElement, type);
				 List<TargetMetadata> results = new ArrayList<>();
				 for (Entry<String, JsonObject> entry : raw.entrySet()) {
					 BuckTarget.parse(entry.getKey()) .map(buckTargetLocator::resolve) .map( target -> TargetMetadata.from(buckTargetLocator, target, entry.getValue())) .ifPresent(results::add);
				 }
				 return results;
			 }
			 public void onSuccess(List<TargetMetadata> results, String stderr) {
				 List<TargetMetadata> editTargets = new ArrayList<>();
				 List<TargetMetadata> importTargets = new ArrayList<>();
				 for (TargetMetadata targetMetadata : results) {
					 if (targetMetadata.contains(editSourceTarget)) {
						 editTargets.add(targetMetadata);
					 }
					 if (targetMetadata.contains(importSourceTarget)) {
						 importTargets.add(targetMetadata);
					 }
				 }
				 updateDependencies(editor, editTargets, importTargets);
			 }
			 public void onFailure( String stdout, String stderr, Integer exitCode, Throwable throwable) {
				 BuckNotification.getInstance(project) .showWarningBalloon( ""Could not determine owners for "" + editSourceFile + "" and/or "" + importSourceFile);
				 return;
			 }
		 }
		);
		 handler .command() .addParameters( ""owner(%s)"", editPath, importPath, ""--output-attributes=deps|srcs|visibility|resources"");
		 handler.runInCurrentThreadPostEnd(() -> {
		}
		);
	 }
	 private void hyperlinkActivated( Notification notification, HyperlinkEvent event) {
		 String href = event.getDescription();
		 switch (href) {
			 case ""editTarget"": if (BuckTargetLocator.getInstance(project) .findElementForTarget(editTarget) .filter(target -> target instanceof NavigatablePsiElement) .map(target -> (NavigatablePsiElement) target) .filter(Navigatable::canNavigate) .map( e -> {
				 e.navigate(true);
				 return true;
			 }
			) .orElse(false)) {
				 break;
			 }
			 case ""editBuildFile"": FileEditorManager.getInstance(project).openFile(editBuildFile, true);
			 break;
			 case ""editSourceFile"": FileEditorManager.getInstance(project).openFile(editSourceFile, true);
			 break;
			 case ""importTarget"": if (BuckTargetLocator.getInstance(project) .findElementForTarget(importTarget) .filter(target -> target instanceof NavigatablePsiElement) .map(target -> (NavigatablePsiElement) target) .filter(Navigatable::canNavigate) .map( e -> {
				 e.navigate(true);
				 return true;
			 }
			) .orElse(false)) {
				 break;
			 }
			 case ""importBuildFile"": FileEditorManager.getInstance(project).openFile(importBuildFile, true);
			 break;
			 case ""importSourceFile"": FileEditorManager.getInstance(project).openFile(importSourceFile, true);
			 break;
		 }
	 }
	 private void updateDependencies( Editor editor, List<TargetMetadata> editTargets, List<TargetMetadata> importTargets) {
		 if (editTargets.size() == 0) {
			 String message = ""<html><b>Add dependency failed</b>: Couldn't determine a Buck owner for <a href='editSourceFile'>"" + editSourceTarget + ""</a> in <a href='editBuildFile'>"" + editBuildFile.getPath() + ""</a>"";
			 BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
			 return;
		 }
		 if (importTargets.size() == 0) {
			 String message = ""<html><b>Add dependency failed</b>: Couldn't determine a Buck owner for <a href='importSourceFile'>"" + importSourceTarget + ""</a> in <a href='importBuildFile'>"" + importBuildFile.getPath() + ""</a></html>"";
			 BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
			 return;
		 }
		 TargetMetadata editTargetMetadata = editTargets.get(0);
		 TargetMetadata importTargetMetadata = importTargets.get(0);
		 editTarget = editTargetMetadata.target;
		 importTarget = importTargetMetadata.target;
		 if (!importTargetMetadata.isVisibleTo(editTarget)) {
			 String message = ""<html><b>Add dependency failed</b>: The target <a href='importTarget'>"" + importTarget + ""</a> is not visible to <a href='editTarget'>"" + editTarget + ""</a></html>"";
			 BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
			 return;
		 }
		 if (!editTargetMetadata.hasDependencyOn(importTarget)) {
			 if (!BuckDeps.modifyTargetToAddDependency( editBuildFile, editTarget.toString(), importTarget.toString())) {
				 String message = ""<html><b>Add dependency failed</b>: Could not add modify build file for <a href='editTarget'>"" + editTarget + ""</a> to add dependency on <a href='importTarget'>"" + importTarget + ""</a></html>"";
				 BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
				 return;
			 }
		 }
		 else {
			 String message = ""<html>No need to modify build file <a href='editBuildFile'>"" + editBuildFile + ""</a>, already has dependency from <a href='editTarget'>"" + editTarget + ""</a> to <a href='importTarget'>"" + importTarget + ""</a></html>"";
			 BuckNotification.getInstance(project).showInfoBalloon(message, this::hyperlinkActivated);
		 }
		 ModuleRootModificationUtil.updateModel( editModule, (modifiableRootModel -> {
			 if (modifiableRootModel.findModuleOrderEntry(importModule) != null) {
				 LOGGER.info( ""No need to modify module "" + editModule.getName() + "", already has dependency on "" + importModule.getName());
			 }
			 else {
				 modifiableRootModel.addModuleOrderEntry(importModule);
				 LOGGER.info( ""Successfully added module dependency from "" + editModule.getName() + "" on "" + importModule.getName());
			 }
			 new AddImportAction(project, referenceElement, editor, psiClass).execute();
		 }
		));
	 }
}",1,0,0,0
"public class QueryItemTreeControl extends Composite {
	 public static interface QueryItemDoubleClickedListener {
		 public void queryItemDoubleClicked(QueryItem queryItem);
	 }
	 public static interface QueryItemSelectionListener {
		 public void queryItemSelected(QueryItem queryItem);
	 }
	 private final Project[] projects;
	 private final String[] activeProjectNames;
	 private TreeViewer treeViewer;
	 private QueryItem selectedQueryItem;
	 private final QueryItemType itemTypes;
	 private final Set<QueryItemDoubleClickedListener> queryDoubleClickListeners = new HashSet<QueryItemDoubleClickedListener>();
	 private final Set<QueryItemSelectionListener> querySelectionListeners = new HashSet<QueryItemSelectionListener>();
	 public QueryItemTreeControl( final Composite parent, final int style, final TFSServer server, final Project[] projects, final QueryItem initialQueryItem, final QueryItemType itemTypes) {
		 this( parent, style, projects, ProjectInfoHelper.getProjectNames(server.getProjectCache().getActiveTeamProjects()), initialQueryItem, itemTypes);
	 }
	 public QueryItemTreeControl( final Composite parent, final int style, final Project[] projects, final String[] activeProjects, final QueryItem initialQueryItem, final QueryItemType itemTypes) {
		 super(parent, style);
		 this.projects = projects;
		 selectedQueryItem = initialQueryItem;
		 this.itemTypes = itemTypes;
		 activeProjectNames = activeProjects;
		 Arrays.sort(activeProjectNames);
		 if (activeProjectNames.length > 0) {
			 createUI();
		 }
		 else {
			 createNoProjectsUI();
		 }
	 }
	 public QueryItem getSelectedQueryItem() {
		 return selectedQueryItem;
	 }
	 public void addQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {
		 synchronized (queryDoubleClickListeners) {
			 queryDoubleClickListeners.add(listener);
		 }
	 }
	 public void removeQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {
		 synchronized (queryDoubleClickListeners) {
			 queryDoubleClickListeners.remove(listener);
		 }
	 }
	 public void addQueryItemSelectionListener(final QueryItemSelectionListener listener) {
		 synchronized (querySelectionListeners) {
			 querySelectionListeners.add(listener);
		 }
	 }
	 public void removeQueryItemSelectionListener(final QueryItemSelectionListener listener) {
		 synchronized (querySelectionListeners) {
			 querySelectionListeners.remove(listener);
		 }
	 }
	 private void createUI() {
		 setLayout(new FillLayout());
		 treeViewer = new TreeViewer(this, SWT.BORDER);
		 treeViewer.setContentProvider(new ContentProvider(activeProjectNames));
		 treeViewer.setLabelProvider(new LabelProvider());
		 treeViewer.addDoubleClickListener(new DoubleClickListener(treeViewer, queryDoubleClickListeners));
		 treeViewer.addSelectionChangedListener(new SelectionChangedListener(querySelectionListeners));
		 addContextMenu();
		 treeViewer.setInput(projects);
		 if (selectedQueryItem != null) {
			 treeViewer.setSelection(new StructuredSelection(selectedQueryItem), true);
		 }
	 }
	 private void createNoProjectsUI() {
		 setLayout(new FillLayout());
		 final Label label = new Label(this, SWT.WRAP);
		 label.setText(Messages.getString(""QueryItemTreeControl.NoTeamProjectsLabelText""));
	 }
	 private void addContextMenu() {
		 final MenuManager menuMgr = new MenuManager(""#PopUp"");
		 final IAction copyToClipboardAction = new Action() {
			 public void run() {
				 final IStructuredSelection selection = (IStructuredSelection) treeViewer.getSelection();
				 final QueryDefinition queryDefinition = (QueryDefinition) selection.getFirstElement();
				 UIHelpers.copyToClipboard(queryDefinition.getQueryText());
			 }
		 }
		;
		 copyToClipboardAction.setText(Messages.getString(""QueryItemTreeControl.CopyWiqlToClipboard""));
		 copyToClipboardAction.setEnabled(false);
		 menuMgr.add(copyToClipboardAction);
		 treeViewer.getControl().setMenu(menuMgr.createContextMenu(treeViewer.getControl()));
		 treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
			 public void selectionChanged(final SelectionChangedEvent event) {
				 final IStructuredSelection selection = (IStructuredSelection) event.getSelection();
				 final boolean enable = (selection.getFirstElement() instanceof QueryDefinition);
				 copyToClipboardAction.setEnabled(enable);
			 }
		 }
		);
	 }
	 private class SelectionChangedListener implements ISelectionChangedListener {
		 private final Set<QueryItemSelectionListener> listeners;
		 public SelectionChangedListener(final Set<QueryItemSelectionListener> listeners) {
			 this.listeners = listeners;
		 }
		 public void selectionChanged(final SelectionChangedEvent event) {
			 final Object selected = ((IStructuredSelection) event.getSelection()).getFirstElement();
			 if (selected instanceof QueryItem && itemTypes.contains(((QueryItem) selected).getType())) {
				 selectedQueryItem = (QueryItem) selected;
			 }
			 else {
				 selectedQueryItem = null;
			 }
			 synchronized (listeners) {
				 for (final QueryItemSelectionListener listener : listeners) {
					 listener.queryItemSelected(selectedQueryItem);
				 }
			 }
		 }
	 }
	 private static class DoubleClickListener extends TreeViewerDoubleClickListener {
		 private final Set<QueryItemDoubleClickedListener> listeners;
		 public DoubleClickListener(final TreeViewer treeViewer, final Set<QueryItemDoubleClickedListener> listeners) {
			 super(treeViewer);
			 this.listeners = listeners;
		 }
		 public void doubleClick(final DoubleClickEvent event) {
			 super.doubleClick(event);
			 final Object element = ((IStructuredSelection) event.getSelection()).getFirstElement();
			 if (element instanceof QueryDefinition) {
				 final QueryDefinition queryDefinition = (QueryDefinition) element;
				 synchronized (listeners) {
					 for (final QueryItemDoubleClickedListener listener : listeners) {
						 listener.queryItemDoubleClicked(queryDefinition);
					 }
				 }
			 }
		 }
	 }
	 private class ContentProvider extends TreeContentProvider {
		 private final String[] activeProjectNames;
		 public ContentProvider(final String[] activeProjectNames) {
			 this.activeProjectNames = activeProjectNames;
		 }
		 public Object getParent(final Object element) {
			 if (element instanceof QueryHierarchy) {
				 return null;
			 }
			 return ((QueryItem) element).getParent();
		 }
		 public Object[] getChildren(final Object parentElement) {
			 final QueryItemType displayTypes = getDisplayTypes();
			 if (parentElement instanceof QueryFolder) {
				 final List<QueryItem> childList = new ArrayList<QueryItem>();
				 final QueryItem[] children = ((QueryFolder) parentElement).getItems();
				 for (final QueryItem child : children) {
					 if (displayTypes.contains(child.getType())) {
						 childList.add(child);
					 }
				 }
				 return childList.toArray(new QueryItem[childList.size()]);
			 }
			 return null;
		 }
		 public boolean hasChildren(final Object element) {
			 final QueryItemType displayTypes = getDisplayTypes();
			 if (element instanceof QueryFolder) {
				 final QueryItem[] children = ((QueryFolder) element).getItems();
				 for (int i = 0;
				 i < children.length;
				 i++) {
					 if (displayTypes.contains(children[i].getType())) {
						 return true;
					 }
				 }
			 }
			 return false;
		 }
		 private QueryItemType getDisplayTypes() {
			 if (itemTypes.contains(QueryItemType.QUERY_DEFINITION)) {
				 return QueryItemType.ALL;
			 }
			 else if (itemTypes.contains(QueryItemType.QUERY_FOLDER)) {
				 return QueryItemType.ALL_FOLDERS;
			 }
			 return itemTypes;
		 }
		 public Object[] getElements(final Object inputElement) {
			 final Project[] projects = (Project[]) inputElement;
			 final List<QueryHierarchy> queryHierarchies = new ArrayList<QueryHierarchy>();
			 final Map<String, Project> availableProjects = new HashMap<String, Project>();
			 for (final Project project : projects) {
				 availableProjects.put(project.getName(), project);
			 }
			 for (final String activeProjectName : activeProjectNames) {
				 final Project project = availableProjects.get(activeProjectName);
				 if (project != null) {
					 queryHierarchies.add(project.getQueryHierarchy());
				 }
			 }
			 return queryHierarchies.toArray(new QueryHierarchy[queryHierarchies.size()]);
		 }
	 }
	 private static class LabelProvider extends org.eclipse.jface.viewers.LabelProvider {
		 private final Map<QueryDefinition, StoredQuery> definitionToQueryMap = new HashMap<QueryDefinition, StoredQuery>();
		 private final ImageHelper imageHelper = new ImageHelper(TFSCommonUIClientPlugin.PLUGIN_ID);
		 public LabelProvider() {
		 }
		 public Image getImage(final Object element) {
			 if (element instanceof QueryHierarchy) {
				 return imageHelper.getImage(""images/common/team_project.gif"");
			 }
			 if (element instanceof QueryFolder) {
				 final QueryFolder queryFolder = (QueryFolder) element;
				 if (GUID.EMPTY.getGUIDString().replaceAll(""-"", """").equals(queryFolder.getParent().getID())) {
					 if (queryFolder.isPersonal()) {
						 return imageHelper.getImage(""images/wit/query_group_my.gif"");
					 }
					 return imageHelper.getImage(""images/wit/query_group_team.gif"");
				 }
				 return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_FOLDER);
			 }
			 if (element instanceof QueryDefinition) {
				 final QueryDefinition queryDefinition = (QueryDefinition) element;
				 StoredQuery query = definitionToQueryMap.get(queryDefinition);
				 if (query == null) {
					 query = new StoredQueryImpl( queryDefinition.getID(), queryDefinition.getName(), queryDefinition.getQueryText(), queryDefinition.isPersonal() ? QueryScope.PRIVATE : QueryScope.PUBLIC, queryDefinition.getProject().getID(), (ProjectImpl) queryDefinition.getProject(), queryDefinition.isDeleted(), queryDefinition.getProject().getWITContext());
					 definitionToQueryMap.put(queryDefinition, query);
				 }
				 if (QueryType.LIST.equals(queryDefinition.getQueryType())) {
					 return imageHelper.getImage(""images/wit/query_type_flat.gif"");
				 }
				 else if (QueryType.TREE.equals(queryDefinition.getQueryType())) {
					 return imageHelper.getImage(""images/wit/query_type_tree.gif"");
				 }
				 else if (QueryType.ONE_HOP.equals(queryDefinition.getQueryType())) {
					 return imageHelper.getImage(""images/wit/query_type_onehop.gif"");
				 }
				 return imageHelper.getImage(""images/wit/query_type_flat_error.gif"");
			 }
			 return imageHelper.getImage(""images/wit/query.gif"");
		 }
		 public String getText(final Object element) {
			 return ((QueryItem) element).getName();
		 }
		 public void dispose() {
			 imageHelper.dispose();
		 }
	 }
}",1,0,0,0
"private final class EntryIterator implements Iterator<Cache.Entry<K, V>> {
	 private final Iterator<GridCacheMapEntry> internalIterator;
	 private GridCacheMapEntry current;
	 private final boolean keepBinary;
	 private EntryIterator(Iterator<GridCacheMapEntry> internalIterator, boolean keepBinary) {
		 this.internalIterator = internalIterator;
		 this.keepBinary = keepBinary;
	 }
	 public boolean hasNext() {
		 return internalIterator.hasNext();
	 }
	 public Cache.Entry<K, V> next() {
		 current = internalIterator.next();
		 return current.wrapLazyValue(keepBinary);
	 }
	 public void remove() {
		 if (current == null) throw new IllegalStateException();
		 try {
			 getAndRemove((K)current.wrapLazyValue(keepBinary).getKey());
		 }
		 catch (IgniteCheckedException e) {
			 throw new IgniteException(e);
		 }
		 current = null;
	 }
 }",0,0,0,0
"public void setState(int state) {
	this.state = state;
}",0,0,0,0
"private static class TestId {
	 final String testClass;
	 final String id;
	 public TestId(String testClass, String id) {
		 this.testClass = testClass;
		 this.id = id;
	 }
	 public int hashCode() {
		 return Objects.hash(testClass, id);
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (obj instanceof TestId) {
			 TestId other = (TestId) obj;
			 return id.equals(other.id) && testClass.equals(other.testClass);
		 }
		 return false;
	 }
 }",0,0,0,0
"public class UpdateNetworkCmd extends BaseAsyncCustomIdCmd {
	 public static final Logger s_logger = Logger.getLogger(UpdateNetworkCmd.class.getName());
	 private static final String s_name = ""updatenetworkresponse"";
	 protected Long id;
	 private String name;
	 private String displayText;
	 private String networkDomain;
	 private Boolean changeCidr;
	 private Long networkOfferingId;
	 private String guestVmCidr;
	 private Boolean updateInSequence;
	 private Boolean displayNetwork;
	 private Boolean forced;
	 public Long getId() {
		 return id;
	 }
	 public String getNetworkName() {
		 return name;
	 }
	 public String getDisplayText() {
		 return displayText;
	 }
	 public String getNetworkDomain() {
		 return networkDomain;
	 }
	 public Long getNetworkOfferingId() {
		 return networkOfferingId;
	 }
	 public Boolean getChangeCidr() {
		 if (changeCidr != null) {
			 return changeCidr;
		 }
		 return false;
	 }
	 public String getGuestVmCidr() {
		 return guestVmCidr;
	 }
	 public Boolean getDisplayNetwork() {
		 return displayNetwork;
	 }
	 public Boolean getUpdateInSequence(){
		 if(updateInSequence ==null) return false;
		 else return updateInSequence;
	 }
	 public boolean getForced(){
		 if(forced==null){
			 return false;
		 }
		 return forced;
	 }
	 public String getCommandName() {
		 return s_name;
	 }
	 public long getEntityOwnerId() {
		 Network network = _networkService.getNetwork(id);
		 if (network == null) {
			 throw new InvalidParameterValueException(""Networkd ID="" + id + "" doesn't exist"");
		 }
		 else {
			 return _networkService.getNetwork(id).getAccountId();
		 }
	 }
	 public void execute() throws InsufficientCapacityException, ConcurrentOperationException {
		 User callerUser = _accountService.getActiveUser(CallContext.current().getCallingUserId());
		 Account callerAccount = _accountService.getActiveAccountById(callerUser.getAccountId());
		 Network network = _networkService.getNetwork(id);
		 if (network == null) {
			 throw new InvalidParameterValueException(""Couldn't find network by ID"");
		 }
		 Network result = _networkService.updateGuestNetwork(getId(), getNetworkName(), getDisplayText(), callerAccount, callerUser, getNetworkDomain(), getNetworkOfferingId(), getChangeCidr(), getGuestVmCidr(), getDisplayNetwork(), getCustomId(), getUpdateInSequence(), getForced());
		 if (result != null) {
			 NetworkResponse response = _responseGenerator.createNetworkResponse(ResponseView.Restricted, result);
			 response.setResponseName(getCommandName());
			 setResponseObject(response);
		 }
		 else {
			 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to update network"");
		 }
	 }
	 public String getEventDescription() {
		 StringBuilder eventMsg = new StringBuilder(""Updating network: "" + getId());
		 if (getNetworkOfferingId() != null) {
			 Network network = _networkService.getNetwork(getId());
			 if (network == null) {
				 throw new InvalidParameterValueException(""Networkd ID="" + id + "" doesn't exist"");
			 }
			 if (network.getNetworkOfferingId() != getNetworkOfferingId()) {
				 NetworkOffering oldOff = _entityMgr.findById(NetworkOffering.class, network.getNetworkOfferingId());
				 NetworkOffering newOff = _entityMgr.findById(NetworkOffering.class, getNetworkOfferingId());
				 if (newOff == null) {
					 throw new InvalidParameterValueException(""Networkd offering ID supplied is invalid"");
				 }
				 eventMsg.append("". Original network offering ID: "" + oldOff.getUuid() + "", new network offering ID: "" + newOff.getUuid());
			 }
		 }
		 return eventMsg.toString();
	 }
	 public String getEventType() {
		 return EventTypes.EVENT_NETWORK_UPDATE;
	 }
	 public String getSyncObjType() {
		 return BaseAsyncCmd.networkSyncObject;
	 }
	 public Long getSyncObjId() {
		 return id;
	 }
	 public void checkUuid() {
		 if (getCustomId() != null) {
			 _uuidMgr.checkUuid(getCustomId(), Network.class);
		 }
	 }
}",1,1,0,0
"private void createMainMenu() {
	JMenuBar bar = new JMenuBar();
	bar.setBorderPainted(false);
	bar.setForeground(ColorResource.getWhite());
	bar.setMaximumSize(new Dimension(bar.getMaximumSize().width, 30));
	bar.setBackground(ColorResource.getTitleColor());
	JMenu file = createMenu(StringResource.get(""MENU_FILE""));
	addMenuItem(""MENU_ADD_URL"", file);
	addMenuItem(""MENU_VIDEO_DWN"", file);
	addMenuItem(""MENU_DELETE_DWN"", file);
	addMenuItem(""MENU_DELETE_COMPLETED"", file);
	addMenuItem(""MENU_EXPORT"", file);
	addMenuItem(""MENU_IMPORT"", file);
	addMenuItem(""MENU_EXIT"", file);
	JMenu dwn = createMenu(StringResource.get(""MENU_DOWNLOAD""));
	addMenuItem(""MENU_PAUSE"", dwn);
	addMenuItem(""MENU_RESUME"", dwn);
	addMenuItem(""MENU_RESTART"", dwn);
	addMenuItem(""DESC_Q_TITLE"", dwn);
	PopupMenuListener popupListener = new PopupMenuListener() {
		public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
			loadQueueMenu(startQMenu);
			loadQueueMenu(stopQMenu);
		}
		public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
		}
		public void popupMenuCanceled(PopupMenuEvent e) {
		}
	}
	;
	startQMenu = addSubMenu(""MENU_START_Q"", dwn, popupListener);
	stopQMenu = addSubMenu(""MENU_STOP_Q"", dwn, popupListener);
	JMenu tools = createMenu(StringResource.get(""MENU_TOOLS""));
	addMenuItem(""MENU_OPTIONS"", tools);
	addMenuItem(""MENU_REFRESH_LINK"", tools);
	addMenuItem(""MENU_PROPERTIES"", tools);
	addMenuItem(""MENU_SPEED_LIMITER"", tools);
	addMenuItem(""MENU_LANG"", tools);
	addMenuItem(""MENU_BROWSER_INT"", tools);
	JMenu help = createMenu(StringResource.get(""MENU_HELP""));
	addMenuItem(""MENU_CONTENTS"", help);
	addMenuItem(""MENU_HOME_PAGE"", help);
	addMenuItem(""MENU_UPDATE"", help);
	addMenuItem(""OPT_UPDATE_FFMPEG"", help);
	addMenuItem(""MENU_ABOUT"", help);
	bar.add(file);
	bar.add(dwn);
	bar.add(tools);
	bar.add(help);
	Box menuBox = Box.createHorizontalBox();
	menuBox.add(Box.createHorizontalGlue());
	menuBox.add(bar);
	menuBox.add(Box.createHorizontalStrut(30));
	getTitlePanel().add(menuBox);
}",0,0,1,0
"public NestedLoopJoin(IHyracksTaskContext ctx, FrameTupleAccessor accessorOuter, FrameTupleAccessor accessorInner, ITuplePairComparator comparatorsOuter2Inner, int memSize, IPredicateEvaluator predEval, boolean isLeftOuter, IMissingWriter[] missingWriters) throws HyracksDataException {
	 this.accessorInner = accessorInner;
	 this.accessorOuter = accessorOuter;
	 this.appender = new FrameTupleAppender();
	 this.tpComparator = comparatorsOuter2Inner;
	 this.outBuffer = new VSizeFrame(ctx);
	 this.innerBuffer = new VSizeFrame(ctx);
	 this.appender.reset(outBuffer, true);
	 if (memSize < 3) {
		 throw new HyracksDataException(""Not enough memory is available for Nested Loop Join"");
	 }
	 this.outerBufferMngr = new VariableFrameMemoryManager(new VariableFramePool(ctx, ctx.getInitialFrameSize() * (memSize - 2)), FrameFreeSlotPolicyFactory.createFreeSlotPolicy(EnumFreeSlotPolicy.LAST_FIT, memSize - 2));
	 this.predEvaluator = predEval;
	 this.isReversed = false;
	 this.isLeftOuter = isLeftOuter;
	 if (isLeftOuter) {
		 int innerFieldCount = this.accessorInner.getFieldCount();
		 missingTupleBuilder = new ArrayTupleBuilder(innerFieldCount);
		 DataOutput out = missingTupleBuilder.getDataOutput();
		 for (int i = 0;
		 i < innerFieldCount;
		 i++) {
			 missingWriters[i].writeMissing(out);
			 missingTupleBuilder.addFieldEndOffset();
		 }
	 }
	 else {
		 missingTupleBuilder = null;
	 }
	 FileReference file = ctx.getJobletContext().createManagedWorkspaceFile(this.getClass().getSimpleName() + this.toString());
	 runFileWriter = new RunFileWriter(file, ctx.getIoManager());
	 runFileWriter.open();
 }",0,0,1,0
"private TransformerFactory getFactory() throws BuildException {
	 if (tfactory != null) {
		 return tfactory;
	 }
	 if (factoryName == null) {
		 tfactory = TransformerFactory.newInstance();
	 }
	 else {
		 try {
			 Class clazz = null;
			 try {
				 clazz = Class.forName(factoryName, true, Thread.currentThread() .getContextClassLoader());
			 }
			 catch (ClassNotFoundException cnfe) {
				 String msg = ""Failed to load "" + factoryName + "" via the configured classpath, will try"" + "" Ant's classpath instead."";
				 if (logger != null) {
					 logger.log(msg);
				 }
				 else if (project != null) {
					 project.log(msg, Project.MSG_WARN);
				 }
				 else {
					 System.err.println(msg);
				 }
			 }
			 if (clazz == null) {
				 clazz = Class.forName(factoryName);
			 }
			 tfactory = (TransformerFactory) clazz.newInstance();
		 }
		 catch (Exception e) {
			 throw new BuildException(e);
		 }
	 }
	 try {
		 Field _isNotSecureProcessing = tfactory.getClass().getDeclaredField(""_isNotSecureProcessing"");
		 _isNotSecureProcessing.setAccessible(true);
		 _isNotSecureProcessing.set(tfactory, Boolean.TRUE);
	 }
	 catch (Exception x) {
		 if (project != null) {
			 project.log(x.toString(), Project.MSG_DEBUG);
		 }
	 }
	 tfactory.setErrorListener(this);
	 final int size = attributes.size();
	 for (int i = 0;
	 i < size;
	 i++) {
		 final Object[] pair = (Object[]) attributes.elementAt(i);
		 tfactory.setAttribute((String) pair[0], pair[1]);
	 }
	 if (uriResolver != null) {
		 tfactory.setURIResolver(uriResolver);
	 }
	 return tfactory;
 }",0,0,0,0
"public boolean hasInputConnectionFrom(Neuron neuron) {
	 for (Connection connection : inputConnections) {
		 if (connection.getFromNeuron() == neuron) {
			 return true;
		 }
	 }
	 return false;
 }",0,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 originalImage = image;
	 int width = originalImage.getWidth();
	 int height = originalImage.getHeight();
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 int alpha;
	 double gray;
	 double[][] G = new double[width][height];
	 gray = new Color(originalImage.getRGB(0, 0)).getRed();
	 G[0][0] = gray / 255;
	 for (int i = 1;
	 i < width;
	 i++) {
		 gray = new Color(originalImage.getRGB(i, 0)).getRed();
		 G[i][0] = G[i - 1][0] + gray / 255;
	 }
	 for (int j = 1;
	 j < height;
	 j++) {
		 gray = new Color(originalImage.getRGB(0, j)).getRed();
		 G[0][j] = G[0][j - 1] + gray / 255;
	 }
	 for (int i = 1;
	 i < width;
	 i++) {
		 for (int j = 1;
		 j < height;
		 j++) {
			 gray = new Color(originalImage.getRGB(i, j)).getRed();
			 G[i][j] = gray / 255 + G[i][j - 1] + G[i - 1][j] - G[i - 1][j - 1];
		 }
	 }
	 int d = windowSize / 2;
	 int A = 0;
	 int B = 0;
	 int C = 0;
	 int D = 0;
	 double s;
	 double m;
	 double delta;
	 double treshold;
	 int newColor;
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 if (i + d - 1 >= width) {
				 A = width - 1;
			 }
			 else {
				 A = i + d - 1;
			 }
			 if (j + d - 1 >= height) {
				 B = height - 1;
			 }
			 else {
				 B = j + d - 1;
			 }
			 if (i - d < 0) {
				 C = 0;
			 }
			 else {
				 C = i - d;
			 }
			 if (j - d < 0) {
				 D = 0;
			 }
			 else {
				 D = j - d;
			 }
			 s = (G[A][B] + G[C][D]) - (G[C][B] + G[A][D]);
			 m = s / (windowSize * windowSize);
			 gray = new Color(originalImage.getRGB(i, j)).getRed();
			 delta = gray / 255 - m;
			 treshold = m * (1 + k * (delta / (1.0 - delta) - 1));
			 if (gray / 255 > treshold) {
				 newColor = 255;
			 }
			 else {
				 newColor = 0;
			 }
			 alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 newColor = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
			 filteredImage.setRGB(i, j, newColor);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public void execute() throws BuildException {
	 File savedDir = dir;
	 String savedAntFile = antFile;
	 Vector locals = new Vector(targets);
	 try {
		 getNewProject();
		 if (dir == null && inheritAll) {
			 dir = getProject().getBaseDir();
		 }
		 initializeProject();
		 if (dir != null) {
			 newProject.setBaseDir(dir);
			 if (savedDir != null) {
				 newProject.setInheritedProperty(MagicNames.PROJECT_BASEDIR, dir.getAbsolutePath());
			 }
		 }
		 else {
			 dir = getProject().getBaseDir();
		 }
		 overrideProperties();
		 if (antFile == null) {
			 antFile = Main.DEFAULT_BUILD_FILENAME;
		 }
		 File file = FILE_UTILS.resolveFile(dir, antFile);
		 antFile = file.getAbsolutePath();
		 log(""calling target(s) "" + ((locals.size() > 0) ? locals.toString() : ""[default]"") + "" in build file "" + antFile, Project.MSG_VERBOSE);
		 newProject.setUserProperty(MagicNames.ANT_FILE , antFile);
		 String thisAntFile = getProject().getProperty(MagicNames.ANT_FILE);
		 if (thisAntFile != null && file.equals(getProject().resolveFile(thisAntFile)) && getOwningTarget() != null) {
			 if (getOwningTarget().getName().equals("""")) {
				 if (getTaskName().equals(""antcall"")) {
					 throw new BuildException(""antcall must not be used at"" + "" the top level."");
				 }
				 throw new BuildException(getTaskName() + "" task at the"" + "" top level must not invoke"" + "" its own build file."");
			 }
		 }
		 try {
			 ProjectHelper.configureProject(newProject, file);
		 }
		 catch (BuildException ex) {
			 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
		 }
		 if (locals.size() == 0) {
			 String defaultTarget = newProject.getDefaultTarget();
			 if (defaultTarget != null) {
				 locals.add(defaultTarget);
			 }
		 }
		 if (newProject.getProperty(MagicNames.ANT_FILE) .equals(getProject().getProperty(MagicNames.ANT_FILE)) && getOwningTarget() != null) {
			 String owningTargetName = getOwningTarget().getName();
			 if (locals.contains(owningTargetName)) {
				 throw new BuildException(getTaskName() + "" task calling "" + ""its own parent target."");
			 }
			 boolean circular = false;
			 for (Iterator it = locals.iterator();
			 !circular && it.hasNext();
			) {
				 Target other = (Target) (getProject().getTargets().get(it.next()));
				 circular |= (other != null && other.dependsOn(owningTargetName));
			 }
			 if (circular) {
				 throw new BuildException(getTaskName() + "" task calling a target"" + "" that depends on"" + "" its parent target \'"" + owningTargetName + ""\'."");
			 }
		 }
		 addReferences();
		 if (locals.size() > 0 && !(locals.size() == 1 && """".equals(locals.get(0)))) {
			 BuildException be = null;
			 try {
				 log(""Entering "" + antFile + ""..."", Project.MSG_VERBOSE);
				 newProject.fireSubBuildStarted();
				 newProject.executeTargets(locals);
			 }
			 catch (BuildException ex) {
				 be = ProjectHelper .addLocationToBuildException(ex, getLocation());
				 throw be;
			 }
			 finally {
				 log(""Exiting "" + antFile + ""."", Project.MSG_VERBOSE);
				 newProject.fireSubBuildFinished(be);
			 }
		 }
	 }
	 finally {
		 newProject = null;
		 Enumeration e = properties.elements();
		 while (e.hasMoreElements()) {
			 Property p = (Property) e.nextElement();
			 p.setProject(null);
		 }
		 if (output != null && out != null) {
			 try {
				 out.close();
			 }
			 catch (final Exception ex) {
			 }
		 }
		 dir = savedDir;
		 antFile = savedAntFile;
	 }
 }",0,0,1,0
"private static class Empty extends Predicates<String> {
	 private static final long serialVersionUID = 1L;
	 public boolean accept(String anObject) {
		 return anObject != null && anObject.length() == 0;
	 }
	 public String toString() {
		 return ""StringPredicates.empty()"";
	 }
 }",0,0,0,0
"public int [][] createN (double [][] Tinv, double [][] R, double [][] T) {
	 int [][] Nmatrix = new int [N][N];
	 double [][] tmp = multiply(multiply(Tinv, R), T);
	 for (int i = 0;
	 i < N;
	 i++) {
		 for (int j = 0;
		 j < N;
		 j++) {
			 Nmatrix[i][j] = (int) (Math.round(tmp[i][j])+128);
		 }
	 }
	 return Nmatrix;
 }",0,0,0,0
"private static class SynchronossFilePart extends SynchronossPart implements FilePart {
	private static final OpenOption[] FILE_CHANNEL_OPTIONS ={
	StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE}
	;
	private final String filename;
	SynchronossFilePart(HttpHeaders headers, String filename, StreamStorage storage, DataBufferFactory factory) {
		super(headers, storage, factory);
		this.filename = filename;
	}
	public String filename() {
		return this.filename;
	}
	public Mono<Void> transferTo(Path dest) {
		ReadableByteChannel input = null;
		FileChannel output = null;
		try {
			input = Channels.newChannel(getStorage().getInputStream());
			output = FileChannel.open(dest, FILE_CHANNEL_OPTIONS);
			long size = (input instanceof FileChannel ? ((FileChannel) input).size() : Long.MAX_VALUE);
			long totalWritten = 0;
			while (totalWritten < size) {
				long written = output.transferFrom(input, totalWritten, size - totalWritten);
				if (written <= 0) {
					break;
				}
				totalWritten += written;
			}
		}
		catch (IOException ex) {
			return Mono.error(ex);
		}
		finally {
			if (input != null) {
				try {
					input.close();
				}
				catch (IOException ignored) {
				}
			}
			if (output != null) {
				try {
					output.close();
				}
				catch (IOException ignored) {
				}
			}
		}
		return Mono.empty();
	}
	public String toString() {
		return ""Part '"" + name() + ""', filename='"" + this.filename + ""'"";
	}
}",0,0,0,0
"public void assertNoErrorMessage(){
	List<Serializable> messages = getMessages(FeedbackMessage.ERROR);
	Assert.assertTrue(""expect no error message, but contains\n"" + WicketTesterHelper.asLined(messages),messages.isEmpty());
}",0,0,0,0
"public synchronized boolean contains(Object o) {
	 return indexOf(o) >= 0;
 }",0,0,0,0
"public static String abbreviateHtmlString(String str, int maxLength, boolean byNumberOfWords) {
	 if (str == null || str.length() <= maxLength) {
		 return str;
	 }
	 int sz = str.length();
	 StringBuffer buffer = new StringBuffer(sz);
	 boolean inTag = false;
	 boolean inTagName = false;
	 boolean endingTag = false;
	 int count = 0;
	 boolean chopped = false;
	 int entityChars = 0;
	 StringBuffer currentTag = new StringBuffer(5);
	 List openTags = new ArrayList(5);
	 int i;
	 for (i = 0;
	 i < sz;
	 i++) {
		 if (count >= maxLength) {
			 chopped = true;
			 break;
		 }
		 char c = str.charAt(i);
		 if (c == '<') {
			 inTag = true;
			 inTagName = true;
		 }
		 else if (inTag) {
			 if (inTagName && c == '/') {
				 if (currentTag.length() == 0) {
					 endingTag = true;
				 }
				 else {
					 inTagName = false;
				 }
				 currentTag = new StringBuffer(5);
			 }
			 else if (inTagName && (c == ' ' || c == '>')) {
				 inTagName = false;
				 if (!endingTag) {
					 openTags.add(currentTag.toString());
				 }
				 else {
					 openTags.remove(currentTag.toString());
				 }
				 currentTag = new StringBuffer(5);
				 if (c == '>') {
					 inTag = false;
				 }
			 }
			 else if (c == '>') {
				 inTag = false;
			 }
			 else if (inTagName) {
				 currentTag.append(c);
			 }
		 }
		 else {
			 if (byNumberOfWords) {
				 if (Character.isWhitespace(c)) {
					 count++;
				 }
			 }
			 else {
				 if (c == '&') {
					 entityChars = 1;
				 }
				 else if (entityChars == 0) {
					 count++;
				 }
				 else {
					 if (entityChars > 0 && c == ';
					') {
						 entityChars = 0;
						 count++;
					 }
					 else {
						 entityChars++;
					 }
					 if (entityChars > 5) {
						 count += entityChars;
						 entityChars = 0;
					 }
				 }
			 }
		 }
		 if (inTag || (!byNumberOfWords || count < maxLength)) {
			 buffer.append(c);
		 }
	 }
	 if (chopped) {
		 buffer.append(""..."");
	 }
	 if (openTags.size() > 0) {
		 String remainingToken = str.substring(i);
		 for (int j = openTags.size() - 1;
		 j >= 0;
		 j--) {
			 String closingTag = ""</"" + openTags.get(j) + "">"";
			 if (remainingToken.indexOf(closingTag) > -1) {
				 buffer.append(closingTag);
			 }
		 }
	 }
	 return buffer.toString();
 }",0,0,1,0
"public void writeAxisFormat(String indent,JRFont axisLabelFont, Color axisLabelColor,JRFont axisTickLabelFont, Color axisTickLabelColor,String axisTickLabelMask, Boolean axisVerticalTickLabels, Color axisLineColor,String parentName,String axisNameSuffix,boolean isToSet);",0,0,0,1
"public class NativeJavaClass extends NativeJavaObject implements Function {
	 public NativeJavaClass() {
	 }
	 public NativeJavaClass(Scriptable scope, Class cl) {
		 this.parent = scope;
		 this.javaObject = cl;
		 initMembers();
	 }
	 protected void initMembers() {
		 Class cl = (Class)javaObject;
		 members = JavaMembers.lookupClass(parent, cl, cl);
		 staticFieldAndMethods = members.getFieldAndMethodsObjects(this, cl, true);
	 }
	 public String getClassName() {
		 return ""JavaClass"";
	 }
	 public boolean has(String name, Scriptable start) {
		 return members.has(name, true);
	 }
	 public Object get(String name, Scriptable start) {
		 if (name.equals(""prototype"")) return null;
		 Object result = Scriptable.NOT_FOUND;
		 if (staticFieldAndMethods != null) {
			 result = staticFieldAndMethods.get(name);
			 if (result != null) return result;
		 }
		 if (members.has(name, true)) {
			 result = members.get(this, name, javaObject, true);
		 }
		 else {
			 Class nestedClass = findNestedClass(getClassObject(), name);
			 if (nestedClass == null) {
				 throw members.reportMemberNotFound(name);
			 }
			 NativeJavaClass nestedValue = new NativeJavaClass (ScriptableObject.getTopLevelScope(this), nestedClass);
			 nestedValue.setParentScope(this);
			 result = nestedValue;
		 }
		 return result;
	 }
	 public void put(String name, Scriptable start, Object value) {
		 members.put(this, name, javaObject, value, true);
	 }
	 public Object[] getIds() {
		 return members.getIds(true);
	 }
	 public Class getClassObject() {
		 return (Class) super.unwrap();
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == null || hint == ScriptRuntime.StringClass) return this.toString();
		 if (hint == ScriptRuntime.BooleanClass) return Boolean.TRUE;
		 if (hint == ScriptRuntime.NumberClass) return ScriptRuntime.NaNobj;
		 return this;
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (args.length == 1 && args[0] instanceof Scriptable) {
			 Class c = getClassObject();
			 Scriptable p = (Scriptable) args[0];
			 do {
				 if (p instanceof Wrapper) {
					 Object o = ((Wrapper) p).unwrap();
					 if (c.isInstance(o)) return p;
				 }
				 p = p.getPrototype();
			 }
			 while (p != null);
		 }
		 return construct(cx, scope, args);
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 Class classObject = getClassObject();
		 int modifiers = classObject.getModifiers();
		 if (! (Modifier.isInterface(modifiers) || Modifier.isAbstract(modifiers))) {
			 MemberBox[] ctors = members.ctors;
			 int index = NativeJavaMethod.findFunction(cx, ctors, args);
			 if (index < 0) {
				 String sig = NativeJavaMethod.scriptSignature(args);
				 throw Context.reportRuntimeError2( ""msg.no.java.ctor"", classObject.getName(), sig);
			 }
			 return constructSpecific(cx, scope, args, ctors[index]);
		 }
		 else {
			 Scriptable topLevel = ScriptableObject.getTopLevelScope(this);
			 String msg = """";
			 try {
				 Object v = topLevel.get(""JavaAdapter"", topLevel);
				 if (v != NOT_FOUND) {
					 Function f = (Function) v;
					 Object[] adapterArgs = {
					 this, args[0] }
					;
					 return (Scriptable) f.construct(cx, topLevel, adapterArgs);
				 }
			 }
			 catch (Exception ex) {
				 String m = ex.getMessage();
				 if (m != null) msg = m;
			 }
			 throw Context.reportRuntimeError2( ""msg.cant.instantiate"", msg, classObject.getName());
		 }
	 }
	 static Scriptable constructSpecific(Context cx, Scriptable scope, Object[] args, MemberBox ctor) {
		 Scriptable topLevel = ScriptableObject.getTopLevelScope(scope);
		 Class classObject = ctor.getDeclaringClass();
		 Class[] argTypes = ctor.argTypes;
		 Object[] origArgs = args;
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 Object arg = args[i];
			 Object x = NativeJavaObject.coerceType(argTypes[i], arg, true);
			 if (x != arg) {
				 if (args == origArgs) {
					 args = (Object[])origArgs.clone();
				 }
				 args[i] = x;
			 }
		 }
		 Object instance = ctor.newInstance(args);
		 return cx.getWrapFactory().wrapNewObject(cx, topLevel, instance);
	 }
	 public String toString() {
		 return ""[JavaClass "" + getClassObject().getName() + ""]"";
	 }
	 public boolean hasInstance(Scriptable value) {
		 if (value instanceof Wrapper && !(value instanceof NativeJavaClass)) {
			 Object instance = ((Wrapper)value).unwrap();
			 return getClassObject().isInstance(instance);
		 }
		 return false;
	 }
	 private static Class findNestedClass(Class parentClass, String name) {
		 String nestedClassName = parentClass.getName() + '$' + name;
		 ClassLoader loader = parentClass.getClassLoader();
		 if (loader == null) {
			 return Kit.classOrNull(nestedClassName);
		 }
		 else {
			 return Kit.classOrNull(loader, nestedClassName);
		 }
	 }
	 private Hashtable staticFieldAndMethods;
}",0,0,0,0
"public class Jext{
	 public static String RELEASE = ""5.0 <Karsten/Tiger>"";
	 public static String BUILD = ""05.00.01.00"";
	 public static boolean DELETE_OLD_SETTINGS = true;
	 public static boolean DEBUG = false;
	 public static final String[] NEW_LINE = {
	 ""\r"", ""\n"", ""\r\n"" }
	;
	 public static final String SETTINGS_DIRECTORY = System.getProperty(""user.home"") + File.separator + "".jext"" + File.separator;
	 public static final String JEXT_HOME = System.getProperty(""user.dir"");
	 public static final int JEXT_SERVER_PORT = 49152;
	 public static ArrayList modes;
	 public static ArrayList modesFileFilters;
	 private static String language = ""English"";
	 private static ZipFile languagePack;
	 private static ArrayList languageEntries;
	 private static boolean flatMenus = true;
	 private static boolean buttonsHighlight = true;
	 private static JextLoader jextLoader;
	 private static boolean isServerEnabled;
	 private static ArrayList plugins;
	 public static String usrProps;
	 private static SplashScreen splash;
	 private static Properties props, defaultProps;
	 private static ArrayList instances = new ArrayList(5);
	 private static HashMap actionHash;
	 private static HashMap pythonActionHash = new HashMap();
	 private static VersionCheck check;
	 private static DefaultInputHandler inputHandler;
	 private static final String USER_PROPS = SETTINGS_DIRECTORY + "".jext-props.xml"";
	 private static boolean runInBg = false;
	 private static boolean keepInMemory = false;
	 private static boolean defaultKeepInMemory = false;
	 private static boolean goingToKill = false;
	 private static JextFrame builtTextArea = null;
	 public static boolean getButtonsHighlight() {
		 return buttonsHighlight;
	 }
	 public static boolean getFlatMenus() {
		 return flatMenus;
	 }
	 public static void stopAutoCheck() {
		 if (check != null) {
			 check.interrupt();
			 check = null;
		 }
	 }
	 public static DefaultInputHandler getInputHandler() {
		 return inputHandler;
	 }
	 public static void addAction(MenuAction action) {
		 String name = action.getName();
		 actionHash.put(name, action);
		 String keyStroke = getProperty(name.concat("".shortcut""));
		 if (keyStroke != null) inputHandler.addKeyBinding(keyStroke, action);
	 }
	 public static void addPythonAction(String name, String script, boolean editAction) {
		 PythonAction action;
		 if (!editAction) action = new PythonAction(name, script);
		 else action = new PythonEditAction(name, script);
		 pythonActionHash.put(name, action);
		 String keyStroke = getProperty(name.concat("".shortcut""));
		 if (keyStroke != null) inputHandler.addKeyBinding(keyStroke, action);
	 }
	 public static MenuAction getAction(String action) {
		 Object o = actionHash.get(action);
		 if (o == null) o = pythonActionHash.get(action);
		 return (MenuAction) o;
	 }
	 private static void initActions() {
		 actionHash = new HashMap();
		 inputHandler = new DefaultInputHandler();
		 inputHandler.addDefaultKeyBindings();
		 loadXMLActions(Jext.class.getResourceAsStream(""jext.actions.xml""), ""jext.actions.xml"");
		 addAction(new BeginLine());
		 addAction(new BoxComment());
		 addAction(new CompleteWord());
		 addAction(new CompleteWordAll());
		 addAction(new CreateTemplate());
		 addAction(new EndLine());
		 addAction(new JoinAllLines());
		 addAction(new JoinLines());
		 addAction(new LeftIndent());
		 addAction(new OpenUrl());
		 addAction(new Print());
		 addAction(new RemoveWhitespace());
		 addAction(new RightIndent());
		 addAction(new SimpleComment());
		 addAction(new SimpleUnComment());
		 addAction(new SpacesToTabs());
		 addAction(new TabsToSpaces());
		 addAction(new ToLowerCase());
		 addAction(new ToUpperCase());
		 addAction(new WingComment());
		 addAction(new WordCount());
		 addAction(new OneAutoIndent());
		 loadXMLOneClickActions(Jext.class.getResourceAsStream(""jext.oneclickactions.xml""), ""jext.oneclickactions.xml"");
		 addJextKeyBindings();
	 }
	 private static void addJextKeyBindings() {
		 inputHandler.addKeyBinding(""CA+UP"", new ScrollUp());
		 inputHandler.addKeyBinding(""CA+PAGE_UP"", new ScrollPageUp());
		 inputHandler.addKeyBinding(""CA+DOWN"", new ScrollDown());
		 inputHandler.addKeyBinding(""CA+PAGE_DOWN"", new ScrollPageDown());
		 inputHandler.addKeyBinding(""C+UP"", new PrevLineIndent());
		 inputHandler.addKeyBinding(""C+DOWN"", new NextLineIndent());
		 inputHandler.addKeyBinding(""ENTER"", new IndentOnEnter());
		 inputHandler.addKeyBinding(""TAB"", new IndentOnTab());
		 inputHandler.addKeyBinding(""S+TAB"", new LeftIndent());
		 inputHandler.addKeyBinding(""C+INSERT"", getAction(""copy""));
		 inputHandler.addKeyBinding(""S+INSERT"", getAction(""paste""));
		 inputHandler.addKeyBinding(""CA+LEFT"", new CsWord(CsWord.NO_ACTION, TextUtilities.BACKWARD));
		 inputHandler.addKeyBinding(""CA+RIGHT"", new CsWord(CsWord.NO_ACTION, TextUtilities.FORWARD));
		 inputHandler.addKeyBinding(""CAS+LEFT"", new CsWord(CsWord.SELECT, TextUtilities.BACKWARD));
		 inputHandler.addKeyBinding(""CAS+RIGHT"", new CsWord(CsWord.SELECT, TextUtilities.FORWARD));
		 inputHandler.addKeyBinding(""CA+BACK_SPACE"", new CsWord(CsWord.DELETE, TextUtilities.BACKWARD));
		 inputHandler.addKeyBinding(""CAS+BACK_SPACE"", new CsWord(CsWord.DELETE, TextUtilities.FORWARD));
		 if (Utilities.JDK_VERSION.charAt(2) >= '4') {
			 inputHandler.addKeyBinding(""C+PAGE_UP"", new TabSwitcher(false));
			 inputHandler.addKeyBinding(""C+PAGE_DOWN"", new TabSwitcher(true));
		 }
	 }
	 private static void initPlugins() {
		 plugins = new ArrayList();
		 loadPlugins(JEXT_HOME + File.separator + ""plugins"");
		 loadPlugins(SETTINGS_DIRECTORY + ""plugins"");
	 }
	 public static void assocPluginsToModes() {
		 Mode mode;
		 String modeName;
		 String pluginModes;
		 for (int i = 0;
		 i < plugins.size();
		 i++) {
			 Plugin plugin = (Plugin) plugins.get(i);
			 pluginModes = getProperty(""plugin."" + plugin.getClass().getName() + "".modes"");
			 if (pluginModes != null) {
				 StringTokenizer tok = new StringTokenizer(pluginModes);
				 while (tok.hasMoreTokens()) {
					 modeName = tok.nextToken();
					 mode = getMode(modeName);
					 mode.addPlugin( plugin);
				 }
			 }
		 }
	 }
	 public static void loadPlugins(String directory) {
		 String[] args = {
		 directory }
		;
		 System.out.println(getProperty(""jar.scanningdir"", args));
		 File file = new File(directory);
		 if (!(file.exists() || file.isDirectory())) return;
		 String[] plugins = file.list();
		 if (plugins == null) return;
		 for (int i = 0;
		 i < plugins.length;
		 i++) {
			 String plugin = plugins[i];
			 if (!plugin.toLowerCase().endsWith("".jar"")) continue;
			 try {
				 new JARClassLoader(directory + File.separator + plugin);
			 }
			 catch(IOException io) {
				 String[] args2 = {
				 plugin }
				;
				 System.err.println(getProperty(""jar.error.load"", args2));
				 io.printStackTrace();
			 }
		 }
	 }
	 public static void addPlugin(Plugin plugin) {
		 plugins.add(plugin);
		 try {
			 plugin.start();
		 }
		 catch (Throwable t) {
			 System.err.println(""#--An exception has occurred while starting plugin:"");
			 t.printStackTrace();
		 }
		 if (plugin instanceof SkinFactory) {
			 SkinManager.registerSkinFactory((SkinFactory) plugin);
		 }
	 }
	 public static Plugin getPlugin(String name) {
		 for (int i = 0;
		 i < plugins.size();
		 i++) {
			 Plugin p = (Plugin) plugins.get(i);
			 if (p.getClass().getName().equalsIgnoreCase(name)) return p;
		 }
		 return null;
	 }
	 public static Plugin[] getPlugins() {
		 Plugin[] p = (Plugin[]) plugins.toArray(new Plugin[0]);
		 return p;
	 }
	 public static JextFrame newWindow(String args[]) {
		 return newWindow(args, true);
	 }
	 public static JextFrame newWindow() {
		 return newWindow(null, true);
	 }
	 static JextFrame newWindow(String args[], boolean toShow) {
		 synchronized (instances) {
			 JextFrame window;
			 if (toShow && builtTextArea != null) {
				 if (args != null) for (int i = 0;
				 i < args.length;
				 i++) builtTextArea.open(args[i]);
				 builtTextArea.setVisible(true);
				 window = builtTextArea;
				 builtTextArea = null;
			 }
			 else {
				 window = new JextFrame(args, toShow);
				 instances.add(window);
			 }
			 return window;
		 }
	 }
	 public static int getWindowsCount() {
		 return instances.size();
	 }
	 public static void propertiesChanged() {
		 for (int i = 0;
		 i < instances.size();
		 i++) ((JextFrame) instances.get(i)).loadProperties();
	 }
	 public static void recentChanged(JextFrame instance) {
		 JextFrame listener;
		 for (int i = 0;
		 i < instances.size();
		 i++) {
			 listener = (JextFrame) instances.get(i);
			 if (listener != instance && listener != null) listener.reloadRecent();
		 }
	 }
	 public static ArrayList getInstances() {
		 return instances;
	 }
	 public static Toolkit getMyToolkit() {
		 return Toolkit.getDefaultToolkit();
	 }
	 public static String getHomeDirectory() {
		 return JEXT_HOME;
	 }
	 public static void saveProps() {
		 if (usrProps != null) {
			 try {
				 OutputStream out = new FileOutputStream(usrProps);
				 props.store(out, ""Jext Properties"");
				 out.close();
			 }
			 catch (IOException io) {
			 }
		 }
	 }
	 public static void saveXMLProps(String description) {
		 saveXMLProps(usrProps, description);
	 }
	 public static void saveXMLProps(String userProps, String description) {
		 if (userProps != null) {
			 try {
				 BufferedWriter out = new BufferedWriter(new FileWriter(userProps));
				 String _out = new String(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
				 out.write(_out, 0, _out.length());
				 out.newLine();
				 _out = new String(""<!DOCTYPE xproperties SYSTEM \""xproperties.dtd\"" >"");
				 out.write(_out, 0, _out.length());
				 out.newLine();
				 _out = ""<!-- Last save: "" + (new Date()).toString() + "" -->"";
				 out.write(_out, 0, _out.length());
				 out.newLine();
				 if (description == null) description = new String(""Properties"");
				 description = ""<!-- "" + description + "" -->"";
				 out.write(description, 0, description.length());
				 out.newLine();
				 out.newLine();
				 _out = new String(""<xproperties>"");
				 out.write(_out, 0, _out.length());
				 out.newLine();
				 setProperty(""properties.version"", BUILD);
				 char c = '\0';
				 StringBuffer buf;
				 Enumeration k = props.keys();
				 Enumeration e = props.elements();
				 for ( ;
				 e.hasMoreElements();
				 ) {
					 buf = new StringBuffer("" <property name=\"""");
					 buf.append(k.nextElement());
					 buf.append(""\"" value=\"""");
					 String _e = (String) e.nextElement();
					 for (int i = 0;
					 i < _e.length();
					 i++) {
						 switch(c = _e.charAt(i)) {
							 case '\\': buf.append('\\');
							 buf.append('\\');
							 break;
							 case '\'': buf.append(""&apos;
							"");
							 break;
							 case '&': buf.append(""&amp;
							"");
							 break;
							 case '\""': buf.append(""&#34;
							"");
							 break;
							 case '\n': buf.append('\\');
							 buf.append('n');
							 break;
							 case '\r': buf.append('\\');
							 buf.append('r');
							 break;
							 default: buf.append(c);
						 }
					 }
					 buf.append(""\"" />"");
					 out.write(buf.toString(), 0, buf.length());
					 out.newLine();
				 }
				 _out = new String(""</xproperties>"");
				 out.write(_out, 0, _out.length());
				 out.close();
			 }
			 catch (IOException io) {
			 }
		 }
	 }
	 public static Properties getProperties() {
		 return props;
	 }
	 public static void loadXMLProps(InputStream in, String fileName) {
		 XPropertiesReader.read(in, fileName);
	 }
	 public static void loadXMLProps(InputStream in, String fileName, boolean toTranslate) {
		 XPropertiesReader.read(in, fileName, toTranslate);
	 }
	 public static void loadXMLActions(InputStream in, String fileName) {
		 PyActionsReader.read(in, fileName);
	 }
	 public static void loadXMLOneClickActions(InputStream in, String fileName) {
		 OneClickActionsReader.read(in, fileName);
	 }
	 public static InputStream getLanguageStream(InputStream in, String fileName) {
		 ZipEntry entry;
		 if (languagePack != null && (entry = languagePackContains(fileName)) != null) {
			 try {
				 return languagePack.getInputStream(entry);
			 }
			 catch (IOException ioe) {
				 return in;
			 }
		 }
		 else return in;
	 }
	 public static ZipEntry languagePackContains(String fileName) {
		 for (int i = 0;
		 i < languageEntries.size();
		 i++) {
			 ZipEntry entry = (ZipEntry) languageEntries.get(i);
			 if (entry.getName().equalsIgnoreCase(fileName)) return entry;
		 }
		 return null;
	 }
	 public static void loadProps(InputStream in) {
		 try {
			 props.load(new BufferedInputStream(in));
			 in.close();
		 }
		 catch (IOException ioe) {
		 }
	 }
	 public static void initDirectories() {
		 File dir = new File(SETTINGS_DIRECTORY);
		 if (!dir.exists()) {
			 dir.mkdir();
			 dir = new File(SETTINGS_DIRECTORY + ""plugins"" + File.separator);
			 if (!dir.exists()) dir.mkdir();
			 dir = new File(SETTINGS_DIRECTORY + ""scripts"" + File.separator);
			 if (!dir.exists()) dir.mkdir();
			 dir = new File(SETTINGS_DIRECTORY + ""xinsert"" + File.separator);
			 if (!dir.exists()) dir.mkdir();
		 }
	 }
	 public static void initProperties() {
		 usrProps = SETTINGS_DIRECTORY + "".jext-props.xml"";
		 defaultProps = props = new Properties();
		 File lang = new File(SETTINGS_DIRECTORY + "".lang"");
		 if (lang.exists()) {
			 try {
				 BufferedReader reader = new BufferedReader(new FileReader(lang));
				 String language = reader.readLine();
				 reader.close();
				 if (language != null && !language.equals(""English"")) {
					 File langPack = new File(JEXT_HOME + File.separator + ""lang"" + File.separator + language + ""_pack.jar"");
					 if (langPack.exists()) {
						 languagePack = new ZipFile(langPack);
						 languageEntries = new ArrayList();
						 Enumeration entries = languagePack.entries();
						 while (entries.hasMoreElements()) languageEntries.add(entries.nextElement());
						 setLanguage(language);
					 }
					 else lang.delete();
				 }
			 }
			 catch (IOException ioe) {
			 }
		 }
		 loadXMLProps(Jext.class.getResourceAsStream(""jext-text.props.xml""), ""jext-text.props.xml"");
		 loadXMLProps(Jext.class.getResourceAsStream(""jext-keys.props.xml""), ""jext-keys.props.xml"");
		 loadXMLProps(Jext.class.getResourceAsStream(""jext-defs.props.xml""), ""jext-defs.props.xml"");
		 loadXMLProps(Jext.class.getResourceAsStream(""jext-tips.props.xml""), ""jext-tips.props.xml"");
		 Properties pyProps = new Properties();
		 pyProps.put(""python.cachedir"", SETTINGS_DIRECTORY + ""pythoncache"" + File.separator);
		 PythonInterpreter.initialize(System.getProperties(), pyProps, new String[0]);
		 initPlugins();
		 if (usrProps != null) {
			 props = new Properties(defaultProps);
			 try {
				 loadXMLProps(new FileInputStream(USER_PROPS), "".jext-props.xml"");
				 if (DELETE_OLD_SETTINGS) {
					 String pVersion = getProperty(""properties.version"");
					 if (pVersion == null || BUILD.compareTo(pVersion) > 0) {
						 File userSettings = new File(USER_PROPS);
						 if (userSettings.exists()) {
							 userSettings.delete();
							 defaultProps = props = new Properties();
							 loadXMLProps(Jext.class.getResourceAsStream(""jext-text.props.xml""), ""jext-text.props.xml"");
							 loadXMLProps(Jext.class.getResourceAsStream(""jext-keys.props.xml""), ""jext-keys.props.xml"");
							 loadXMLProps(Jext.class.getResourceAsStream(""jext-defs.props.xml""), ""jext-defs.props.xml"");
							 loadXMLProps(Jext.class.getResourceAsStream(""jext-tips.props.xml""), ""jext-tips.props.xml"");
							 JARClassLoader.reloadPluginsProperties();
							 props = new Properties(defaultProps);
						 }
					 }
				 }
			 }
			 catch (FileNotFoundException fnfe) {
			 }
			 catch (IOException ioe) {
			 }
		 }
		 initModes();
		 Search.load();
		 if (Utilities.JDK_VERSION.charAt(2) >= '4') {
			 try {
				 Class cl = Class.forName(""org.jext.JavaSupport"");
				 Method m = cl.getMethod(""initJavaSupport"", new Class[0]);
				 if (m != null) m.invoke(null, new Object[0]);
			 }
			 catch (Exception e) {
			 }
		 }
		 System.getProperties().put(""java.protocol.handler.pkgs"", ""org.jext.protocol|"" + System.getProperty(""java.protocol.handler.pkgs"", """"));
		 initActions();
		 JARClassLoader.initPlugins();
		 initUI();
		 sortModes();
		 assocPluginsToModes();
	 }
	 public static void setLanguage(String lang) {
		 language = lang;
	 }
	 public static String getLanguage() {
		 return language;
	 }
	 public static void executeScripts(JextFrame parent) {
		 String dir = SETTINGS_DIRECTORY + ""scripts"" + File.separator;
		 String[] scripts = Utilities.getWildCardMatches(dir, ""*.jext-script"", false);
		 if (scripts == null) return;
		 for (int i = 0;
		 i < scripts.length;
		 i++) org.jext.scripting.dawn.Run.runScript(dir + scripts[i], parent, false);
		 scripts = Utilities.getWildCardMatches(dir, ""*.py"", false);
		 if (scripts == null) return;
		 for (int i = 0;
		 i < scripts.length;
		 i++) org.jext.scripting.python.Run.runScript(dir + scripts[i], parent);
	 }
	 private static void sortModes() {
		 String[] modeNames = new String[modes.size()];
		 for (int i = 0;
		 i < modeNames.length;
		 i++) modeNames[i] = ((Mode) modes.get(i)).getUserModeName();
		 Arrays.sort(modeNames);
		 ArrayList v = new ArrayList(modeNames.length);
		 for (int i = 0;
		 i < modeNames.length;
		 i++) {
			 int j = 0;
			 String name = modeNames[i];
			 while (!((Mode) modes.get(j)).getUserModeName().equals(name)) {
				 if (j == modes.size() - 1) break;
				 else j++;
			 }
			 v.add(modes.get(j));
		 }
		 modes = v;
		 v = null;
	 }
	 private static void initUI() {
		 SkinManager.applySelectedSkin();
		 flatMenus = getBooleanProperty(""flatMenus"");
		 buttonsHighlight = getBooleanProperty(""buttonsHighlight"");
		 JextButton.setRollover(getBooleanProperty(""toolbarRollover""));
	 }
	 private static void initModes() {
		 StringTokenizer _tok = new StringTokenizer(getProperty(""jext.modes""), "" "");
		 Mode _mode;
		 modes = new ArrayList(_tok.countTokens());
		 modesFileFilters = new ArrayList(_tok.countTokens());
		 for ( ;
		 _tok.hasMoreTokens();
		 ) {
			 modes.add(_mode = new Mode(_tok.nextToken()));
			 modesFileFilters.add(new ModeFileFilter(_mode));
		 }
	 }
	 public static Mode getMode(String modeName) {
		 for (int i = 0;
		 i < modes.size();
		 i++) {
			 Mode _mode = (Mode) modes.get(i);
			 if (_mode.getModeName().equalsIgnoreCase(modeName)) return _mode;
		 }
		 return null;
	 }
	 public static ArrayList getModes() {
		 return modes;
	 }
	 public static void addMode(Mode mode) {
		 modes.add(mode);
		 modesFileFilters.add(new ModeFileFilter(mode));
	 }
	 public static void setProperty(String name, String value) {
		 if (name == null || value == null) return;
		 props.put(name, value);
	 }
	 public static boolean getBooleanProperty(String name) {
		 String p = getProperty(name);
		 if (p == null) return false;
		 else return p.equals(""on"") || p.equals(""true"");
	 }
	 public static boolean getBooleanProperty(String name, String def) {
		 String p = getProperty(name, def);
		 if (p == null) return false;
		 else return p.equals(""on"") || p.equals(""true"");
	 }
	 public static String getProperty(String name) {
		 return props.getProperty(name);
	 }
	 public static final String getProperty(String name, String def) {
		 return props.getProperty(name, def);
	 }
	 public static final String getProperty(String name, Object[] args) {
		 if (name == null) return null;
		 if (args == null) return props.getProperty(name, name);
		 else return MessageFormat.format(props.getProperty(name, name), args);
	 }
	 public static void unsetProperty(String name) {
		 if (defaultProps.get(name) != null) props.put(name, """");
		 else props.remove(name);
	 }
	 public static void exit() {
		 synchronized (instances) {
			 Object[] o = instances.toArray();
			 for (int i = o.length - 1;
			 i >= 0;
			 i--) {
				 JextFrame instance = ((JextFrame) o[i]);
				 closeToQuit(instance);
			 }
		 }
	 }
	 static void finalCleanupAndExit() {
		 System.exit(0);
	 }
	 static void stopPlugins() {
		 Plugin[] plugins = getPlugins();
		 for (int i = 0;
		 i < plugins.length;
		 i++) try {
			 plugins[i].stop();
		 }
		 catch (Throwable t) {
			 System.err.println(""#--An exception has occurred while stopping plugin:"");
			 t.printStackTrace();
		 }
	 }
	 public static void closeToQuit(JextFrame frame) {
		 closeToQuit(frame,false);
	 }
	 static void closeToQuit(JextFrame frame, boolean isKillingServer) {
		 if (isKillingServer) runInBg = false;
		 frame.closeToQuit();
	 }
	 public static void closeWindow(JextFrame frame) {
		 synchronized (instances) {
			 if (getWindowsCount() == 1) frame.fireJextEvent(JextEvent.KILLING_JEXT);
			 else frame.fireJextEvent(JextEvent.CLOSING_WINDOW);
			 frame.closeWindow();
			 if (getWindowsCount() == 0) {
				 if (!isRunningBg()) stopServer();
				 Search.save();
				 if (!isRunningBg()) stopPlugins();
				 frame.saveConsole();
				 GUIUtilities.saveGeometry(frame, ""jext"");
				 saveXMLProps(""Jext v"" + Jext.RELEASE + "" b"" + Jext.BUILD);
				 frame = null;
				 System.gc();
				 if (isRunningBg()) builtTextArea = newWindow(null, false);
				 else System.exit(0);
			 }
		 }
	 }
	 public static SplashScreen getSplashScreen() {
		 return splash;
	 }
	 public static void setSplashProgress(int val) {
		 if (splash != null) splash.setProgress(val);
	 }
	 public static void setSplashText(String text) {
		 if (splash != null) splash.setText(text);
	 }
	 public static void killSplashScreen() {
		 if (splash != null) {
			 splash.dispose();
			 splash = null;
		 }
	 }
	 public static void stopServer() {
		 if (jextLoader != null) {
			 jextLoader.stop();
			 jextLoader = null;
		 }
	 }
	 public static boolean isServerEnabled() {
		 return isServerEnabled;
	 }
	 public static boolean isDefaultKeepInMemory() {
		 return defaultKeepInMemory;
	 }
	 public static void setDefaultKeepInMemory(boolean val) {
		 defaultKeepInMemory = val;
		 if (val) {
		 }
	 }
	 public static void setServerEnabled(boolean on) {
		 isServerEnabled = on;
	 }
	 public static void loadInSingleJVMInstance(String[] args) {
		 try {
			 File security = new File(SETTINGS_DIRECTORY + "".security"");
			 if (!security.exists()) isServerEnabled = true;
			 else {
				 BufferedReader reader = new BufferedReader(new FileReader(security));
				 isServerEnabled = new Boolean(reader.readLine()).booleanValue();
				 reader.close();
			 }
		 }
		 catch (IOException ioe) {
		 }
		 if (!isServerEnabled && !runInBg) return;
		 File authorizationKey = new File(SETTINGS_DIRECTORY + "".auth-key"");
		 if (authorizationKey.exists()) {
			 try {
				 BufferedReader reader = new BufferedReader(new FileReader(authorizationKey));
				 int port = Integer.parseInt(reader.readLine());
				 String key = reader.readLine();
				 reader.close();
				 Socket client = new Socket(""127.0.0.1"", JEXT_SERVER_PORT + port);
				 if (!runInBg) {
					 PrintWriter writer = new PrintWriter(client.getOutputStream());
					 StringBuffer _args = new StringBuffer();
					 if (goingToKill) {
						 _args.append(""kill"");
					 }
					 else {
						 _args.append(""load_jext:"");
						 for (int i = 0;
						 i < args.length;
						 i++) {
							 _args.append(args[i]);
							 if (i != args.length - 1) _args.append('?');
						 }
					 }
					 _args.append(':').append(key);
					 writer.write(_args.toString());
					 writer.flush();
					 writer.close();
				 }
				 else System.out.println(""Jext is already running, either in background or foreground."");
				 client.close();
				 System.exit(5);
			 }
			 catch (Exception e) {
				 authorizationKey.delete();
				 if (goingToKill) {
					 System.err.println(""No jext instance found!"");
					 System.exit(0);
				 }
				 else jextLoader = new JextLoader();
			 }
		 }
		 else if (!goingToKill) {
			 jextLoader = new JextLoader();
		 }
		 else {
			 System.err.println(""No jext instance found!"");
			 System.exit(0);
		 }
	 }
	 public static boolean isRunningBg() {
		 return runInBg;
	 }
	 private static String[] parseOptions(String [] args) {
		 int argLn = args.length;
		 ArrayList newArgs = new ArrayList(argLn);
		 try {
			 File showbg = new File(SETTINGS_DIRECTORY + "".showBg"");
			 if (!showbg.exists()) keepInMemory = false;
			 else {
				 BufferedReader reader = new BufferedReader(new FileReader(showbg));
				 keepInMemory = new Boolean(reader.readLine()).booleanValue();
				 reader.close();
			 }
		 }
		 catch (IOException ioe) {
		 }
		 defaultKeepInMemory = runInBg = keepInMemory;
		 for (int i = 0;
		 i < argLn;
		 i++) {
			 if (""-bg"".equals(args[i])) {
				 runInBg = true;
				 keepInMemory = false;
				 goingToKill = false;
			 }
			 else if (""-kill"".equals(args[i])) {
				 goingToKill = true;
				 keepInMemory = false;
				 runInBg = false;
			 }
			 else if (""-showbg"".equals(args[i])) {
				 runInBg = true;
				 keepInMemory = true;
				 goingToKill = false;
			 }
			 else if (""-debug"".equals(args[i])) DEBUG = true;
			 else newArgs.add(args[i]);
		 }
		 return (String[]) newArgs.toArray(new String[0]);
	 }
	 public static void main(String args[]) {
		 System.setErr(System.out);
		 initDirectories();
		 args = parseOptions(args);
		 synchronized (instances) {
			 loadInSingleJVMInstance(args);
			 initProperties();
			 if (!isRunningBg()) {
				 splash = new SplashScreen();
				 newWindow(args);
			 }
			 else {
				 if (keepInMemory) splash = new SplashScreen();
				 builtTextArea = newWindow(args, false);
				 if (keepInMemory) newWindow(null, true);
			 }
		 }
		 if (getBooleanProperty(""check"")) check = new VersionCheck();
	 }
}",1,0,0,0
"public void createTargetInstances(AbstractTarget aTarget, Schedule aSchedule, boolean checkAgency) {
	 int objectType = aTarget.getObjectType();
	 if(objectType == AbstractTarget.TYPE_GROUP) {
		 if(!(aTarget instanceof TargetGroup)) {
			 aTarget = targetDao.loadGroup(aTarget.getOid());
		 }
	 }
	 if( objectType == AbstractTarget.TYPE_TARGET || objectType == AbstractTarget.TYPE_GROUP && ((TargetGroup)aTarget).getSipType() == TargetGroup.ONE_SIP ) {
		 if(checkAgency && !aTarget.getOwner().getAgency().equals(aSchedule.getOwningUser().getAgency())) {
			 return;
		 }
		 else if(!aTarget.isSchedulable()) {
			 return;
		 }
		 else {
			 Set<TargetInstance> targetInstances = new HashSet<TargetInstance>();
			 int daysToSchedule = EnvironmentFactory.getEnv().getDaysToSchedule();
			 Calendar cal = Calendar.getInstance();
			 cal.setTime(new Date());
			 cal.add(Calendar.DAY_OF_MONTH, daysToSchedule);
			 Date scheduleTill = aSchedule.getEndDate() == null ? cal.getTime() : DateUtils.earliestDate(aSchedule.getEndDate(), cal.getTime());
			 Date startFrom = targetDao.getLatestScheduledDate(aTarget, aSchedule);
			 if(startFrom == null) {
				 startFrom = new Date();
			 }
			 startFrom = DateUtils.latestDate(startFrom, aSchedule.getStartDate());
			 List<Annotation> targetAnnotations = getAnnotations(aTarget);
			 boolean firstForTarget = false;
			 for(startFrom = aSchedule.getNextExecutionDate(startFrom);
			 startFrom != null && startFrom.before(scheduleTill);
			 startFrom = aSchedule.getNextExecutionDate(startFrom)) {
				 TargetInstance ti = new TargetInstance();
				 ti.setTarget(aTarget);
				 ti.setSchedule(aSchedule);
				 ti.setScheduledTime(startFrom);
				 ti.setOwner(aSchedule.getOwningUser());
				 if ( !firstForTarget && instanceManager.countTargetInstancesByTarget(aTarget.getOid()) == 0 ) {
					 ti.setFirstFromTarget(true);
					 firstForTarget = true;
				 }
				 if( objectType == AbstractTarget.TYPE_TARGET ) {
					 for (Iterator<Annotation> i = targetAnnotations.iterator( );
					 i.hasNext();
					 ) {
						 Annotation toCopy = i.next();
						 if (toCopy.isAlertable()) {
							 Annotation annotation = new Annotation();
							 annotation.setDate(toCopy.getDate());
							 annotation.setNote(toCopy.getNote());
							 annotation.setAlertable(true);
							 annotation.setUser(toCopy.getUser());
							 annotation.setObjectType(TargetInstance.class.getName());
							 ti.addAnnotation(annotation);
						 }
					 }
					 ti.setUseAQA(isTargetUsingAQA(aTarget.getOid()));
				 }
				 targetInstances.add(ti);
			 }
			 for(TargetInstance toSave: targetInstances) {
				 targetInstanceDao.save(toSave);
				 for(Annotation anno : toSave.getAnnotations()) {
					 anno.setObjectOid(toSave.getOid());
				 }
				 annotationDAO.saveAnnotations(toSave.getAnnotations());
				 log.debug("" Saved TI: "" + toSave.getOid());
			 }
			 System.out.println("" Created "" + targetInstances.size());
		 }
	 }
	 else if(objectType == AbstractTarget.TYPE_GROUP && ((TargetGroup)aTarget).getSipType() == TargetGroup.MANY_SIP) {
		 TargetGroup aTargetGroup = (TargetGroup) aTarget;
		 for(GroupMember member: aTargetGroup.getChildren()) {
			 AbstractTarget child = member.getChild();
			 if(child.getObjectType() == AbstractTarget.TYPE_GROUP) {
				 TargetGroup childGroup = targetDao.loadGroup(child.getOid(), false);
				 if(subGroupTypeName.equals(childGroup.getType())) {
					 continue;
				 }
			 }
			 createTargetInstances(child, aSchedule, checkAgency);
		 }
		 return;
	 }
	 else {
		 String type = null;
		 if(aTarget instanceof TargetGroup) {
			 type = """" + ((TargetGroup) aTarget).getSipType();
		 }
		 throw new WCTRuntimeException(""Unknown Target Type: "" + aTarget.getClass() + "" ("" + type + "")"");
	 }
 }",0,0,1,0
"public static class PrimitiveByteArrayConverter extends IdentityConverter<byte[]> {
	private static final long serialVersionUID = -2007960927801689921L;
	public static final PrimitiveByteArrayConverter INSTANCE = new PrimitiveByteArrayConverter();
	private PrimitiveByteArrayConverter() {
	}
	byte[] toExternalImpl(BaseRow row, int column) {
		return row.getBinary(column);
	}
}",0,0,0,0
"public class OpenJDK8ServerALPNProcessor implements ALPNProcessor.Server{
	 private static final Logger LOG = Log.getLogger(OpenJDK8ServerALPNProcessor.class);
	 public void init() {
		 if (JavaVersion.VERSION.getPlatform()!=8) throw new IllegalStateException(this + "" not applicable for java ""+JavaVersion.VERSION);
		 if (ALPN.class.getClassLoader()!=null) throw new IllegalStateException(ALPN.class.getName() + "" must be on JVM boot classpath"");
		 if (LOG.isDebugEnabled()) ALPN.debug = true;
	 }
	 public boolean appliesTo(SSLEngine sslEngine) {
		 return sslEngine.getClass().getName().startsWith(""sun.security.ssl."");
	 }
	 public void configure(SSLEngine sslEngine, Connection connection) {
		 connection.addListener(new ALPNListener((ALPNServerConnection)connection));
	 }
	 private final class ALPNListener implements ALPN.ServerProvider, Connection.Listener {
		 private final ALPNServerConnection alpnConnection;
		 private ALPNListener(ALPNServerConnection connection) {
			 alpnConnection = connection;
		 }
		 public void onOpened(Connection connection) {
			 if (LOG.isDebugEnabled()) LOG.debug(""onOpened {
			}
			"", alpnConnection);
			 ALPN.put(alpnConnection.getSSLEngine(), this);
		 }
		 public void onClosed(Connection connection) {
			 if (LOG.isDebugEnabled()) LOG.debug(""onClosed {
			}
			"", alpnConnection);
			 ALPN.remove(alpnConnection.getSSLEngine());
		 }
		 public void unsupported() {
			 if (LOG.isDebugEnabled()) LOG.debug(""unsupported {
			}
			"", alpnConnection);
			 alpnConnection.select(Collections.emptyList());
		 }
		 public String select(List<String> protocols) throws SSLException {
			 if (LOG.isDebugEnabled()) LOG.debug(""select {
			}
			 {
			}
			"", alpnConnection, protocols);
			 alpnConnection.select(protocols);
			 return alpnConnection.getProtocol();
		 }
	 }
}",0,0,0,0
"public class DotnetResource {
	 private File file;
	 private boolean embed = true;
	 private Boolean isPublic = null;
	 private String name = null;
	 private ArrayList fileSets = new ArrayList();
	 private String namespace = null;
	 public boolean isEmbed() {
		 return embed;
	 }
	 public void setEmbed(boolean embed) {
		 this.embed = embed;
	 }
	 public File getFile() {
		 return file;
	 }
	 public void setFile(File file) {
		 this.file = file;
	 }
	 public Boolean getPublic() {
		 return isPublic;
	 }
	 public void setPublic(Boolean aPublic) {
		 isPublic = aPublic;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getNamespace() {
		 return namespace;
	 }
	 public void setNamespace(String namespace) {
		 if (namespace == null) {
			 this.namespace = null;
		 }
		 else {
			 this.namespace = (namespace.length() == 0 || namespace.endsWith(""."") ? namespace : namespace + '.');
		 }
	 }
	 private void checkParameters() {
		 if (hasFilesets()) {
			 if (getName() != null) {
				 throw new BuildException( ""Cannot use <resource name=\""...\""> attribute with filesets"");
			 }
			 if (getFile() != null) {
				 throw new BuildException( ""Cannot use <resource file=\""...\""> attribute with filesets"");
			 }
		 }
		 else {
			 if (getNamespace() != null) {
				 throw new BuildException( ""Cannot use <resource namespace=\""...\""> attribute without filesets"");
			 }
		 }
	 }
	 public void getParameters(Project p, NetCommand command, boolean csharpStyle) {
		 checkParameters();
		 if (hasFilesets()) {
			 for (Iterator listIter = fileSets.iterator();
			 listIter.hasNext();
			) {
				 FileSet fs = (FileSet) listIter.next();
				 String baseDirectory = fs.getDir(p).toString();
				 String namespace = getNamespace();
				 DirectoryScanner ds = fs.getDirectoryScanner(p);
				 String[] files = ds.getIncludedFiles();
				 for (int i = 0;
				 i < files.length;
				 i++) {
					 String file = files[i];
					 command.addArgument(getParameter(baseDirectory + File.separatorChar + file, (namespace == null ? null : namespace + file.replace(File.separatorChar, '.')), csharpStyle));
				 }
			 }
		 }
		 else {
			 command.addArgument(getParameter(getFile().toString(), getName(), csharpStyle));
		 }
	 }
	 private String getParameter(String fileName, String name, boolean csharpStyle) {
		 StringBuffer buffer = new StringBuffer();
		 buffer.append(isEmbed() ? ""/resource"" : ""/linkresource"");
		 buffer.append(':');
		 buffer.append(fileName);
		 if (name != null) {
			 buffer.append(',');
			 buffer.append(name);
			 if (csharpStyle) {
				 if (getPublic() != null) {
					 throw new BuildException(""This compiler does not support the "" + ""public/private option."");
				 }
				 else {
					 if (getPublic() != null) {
						 buffer.append(',');
						 buffer.append(getPublic().booleanValue() ? ""public"" : ""private"");
					 }
				 }
			 }
			 else if (getPublic() != null) {
				 throw new BuildException(""You cannot have a public or private "" + ""option without naming the resource"");
			 }
		 }
		 return buffer.toString();
	 }
	 public void addFileset(FileSet fileset) {
		 fileSets.add(fileset);
	 }
	 public boolean hasFilesets() {
		 return fileSets.size() > 0;
	 }
}",0,0,0,0
"public class Customer1392 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer1392() {
	}
	public Customer1392(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer1392[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"public void addSetup(Sequential sequence) {
	 logOverride(""setup"", setup);
	 setup = sequence;
 }",0,0,0,0
"public class PdfTargetDictionary extends PdfDictionary {
	public PdfTargetDictionary(PdfTargetDictionary nested) {
		super();
		put(PdfName.R, PdfName.P);
		if (nested != null)setAdditionalPath(nested);
	}
	public PdfTargetDictionary(boolean child) {
		super();
		if (child) {
			put(PdfName.R, PdfName.C);
		}
		else {
			put(PdfName.R, PdfName.P);
		}
	}
	public void setEmbeddedFileName(String target) {
		put(PdfName.N, new PdfString(target, null));
	}
	public void setFileAttachmentPagename(String name) {
		put(PdfName.P, new PdfString(name, null));
	}
	public void setFileAttachmentPage(int page) {
		put(PdfName.P, new PdfNumber(page));
	}
	public void setFileAttachmentName(String name) {
		put(PdfName.A, new PdfString(name, PdfObject.TEXT_UNICODE));
	}
	public void setFileAttachmentIndex(int annotation) {
		put(PdfName.A, new PdfNumber(annotation));
	}
	public void setAdditionalPath(PdfTargetDictionary nested) {
		put(PdfName.T, nested);
	}
}",0,0,0,0
"public class FloatPeriod extends Period{
	private double notional;
	private Iso4217Currency currency;
	private String index;
	private BusinessDayConvention businessDayConvention;
	private DaycountCalculator daycountCalculator;
	private HolidayCalendar paymentHolidayCalendar;
	private HolidayCalendar fixingHolidayCalendar;
	private Frequency frequency;
	private int fixingOffset;
	public FloatPeriod clone(){
		FloatPeriod period = new FloatPeriod();
		period.setStartCalendar(getStartCalendar());
		period.setEndCalendar(getEndCalendar());
		period.setReferenceStartCalendar(getReferenceStartCalendar());
		period.setReferenceEndCalendar(getReferenceEndCalendar());
		period.notional = notional;
		period.currency = currency;
		period.index = index;
		period.businessDayConvention = businessDayConvention;
		period.daycountCalculator = daycountCalculator;
		period.paymentHolidayCalendar = paymentHolidayCalendar;
		period.fixingHolidayCalendar = fixingHolidayCalendar;
		period.frequency = frequency;
		period.fixingOffset = fixingOffset;
		return period;
	}
	public BusinessDayConvention getBusinessDayConvention(){
		return businessDayConvention;
	}
	public void setBusinessDayConvention(BusinessDayConvention businessDayConvention){
		this.businessDayConvention = businessDayConvention;
	}
	public Iso4217Currency getCurrency(){
		return currency;
	}
	public void setCurrency(Iso4217Currency currency){
		this.currency = currency;
	}
	public DaycountCalculator getDaycountCalculator(){
		return daycountCalculator;
	}
	public void setDaycountCalculator(DaycountCalculator daycountCalculator){
		this.daycountCalculator = daycountCalculator;
	}
	public String getIndex(){
		return index;
	}
	public void setIndex(String index){
		this.index = index;
	}
	public HolidayCalendar getPaymentHolidayCalendar(){
		return paymentHolidayCalendar;
	}
	public void setPaymentHolidayCalendar(HolidayCalendar holidayCalendar){
		this.paymentHolidayCalendar = holidayCalendar;
	}
	public double getNotional(){
		return notional;
	}
	public void setNotional(double notional){
		this.notional = notional;
	}
	public Frequency getFrequency(){
		return frequency;
	}
	public void setFrequency(Frequency frequency){
		this.frequency = frequency;
	}
	public int getFixingOffset(){
		return fixingOffset;
	}
	public void setFixingOffset(int fixingOffset){
		this.fixingOffset = fixingOffset;
	}
	public HolidayCalendar getFixingHolidayCalendar(){
		return fixingHolidayCalendar;
	}
	public void setFixingHolidayCalendar(HolidayCalendar fixingHolidayCalendar){
		this.fixingHolidayCalendar = fixingHolidayCalendar;
	}
	public Calendar getAdjustedStartCalendar() {
		return fixingHolidayCalendar.adjust(getStartCalendar(),getBusinessDayConvention());
	}
	public Calendar getAdjustedEndCalendar() {
		return fixingHolidayCalendar.adjust(getEndCalendar(),getBusinessDayConvention());
	}
	public double getDaycountFraction() {
		return daycountCalculator.calculateDaycountFraction(getAdjustedStartCalendar(), getAdjustedEndCalendar());
	}
	public String getPaymentDescription() {
		return getIndex()+"":""+getCurrency().name()+"":""+getFrequency().getTenorDescriptor();
	}
	public Calendar getFixingDate() {
		return fixingHolidayCalendar.advanceBusinessDays(getAdjustedStartCalendar(),getFixingOffset());
	}
	public Calendar getPaymentDate() {
		return getAdjustedStartCalendar();
	}
}",0,1,0,0
"public class ServletContextAttributeFactoryBean implements FactoryBean<Object>, ServletContextAware {
	private String attributeName;
	private Object attribute;
	public void setAttributeName(String attributeName) {
		this.attributeName = attributeName;
	}
	public void setServletContext(ServletContext servletContext) {
		if (this.attributeName == null) {
			throw new IllegalArgumentException(""Property 'attributeName' is required"");
		}
		this.attribute = servletContext.getAttribute(this.attributeName);
		if (this.attribute == null) {
			throw new IllegalStateException(""No ServletContext attribute '"" + this.attributeName + ""' found"");
		}
	}
	public Object getObject() throws Exception {
		return this.attribute;
	}
	public Class<?> getObjectType() {
		return (this.attribute != null ? this.attribute.getClass() : null);
	}
	public boolean isSingleton() {
		return true;
	}
}",0,1,0,0
"public class XMLSchedulingDataProcessorPlugin extends SchedulerPluginWithUserTransactionSupport implements FileScanListener {
	 private static final int MAX_JOB_TRIGGER_NAME_LEN = 80;
	 private static final String JOB_INITIALIZATION_PLUGIN_NAME = ""JobSchedulingDataLoaderPlugin"";
	 private static final String FILE_NAME_DELIMITERS = "","";
	 private boolean failOnFileNotFound = true;
	 private String fileNames = XMLSchedulingDataProcessor.QUARTZ_XML_DEFAULT_FILE_NAME;
	 private Map jobFiles = new LinkedHashMap();
	 private long scanInterval = 0;
	 boolean started = false;
	 protected ClassLoadHelper classLoadHelper = null;
	 private Set jobTriggerNameSet = new HashSet();
	 public XMLSchedulingDataProcessorPlugin() {
	 }
	 public String getFileNames() {
		 return fileNames;
	 }
	 public void setFileNames(String fileNames) {
		 this.fileNames = fileNames;
	 }
	 public long getScanInterval() {
		 return scanInterval / 1000;
	 }
	 public void setScanInterval(long scanInterval) {
		 this.scanInterval = scanInterval * 1000;
	 }
	 public boolean isFailOnFileNotFound() {
		 return failOnFileNotFound;
	 }
	 public void setFailOnFileNotFound(boolean failOnFileNotFound) {
		 this.failOnFileNotFound = failOnFileNotFound;
	 }
	 public void initialize(String name, final Scheduler scheduler) throws SchedulerException {
		 super.initialize(name, scheduler);
		 classLoadHelper = new CascadingClassLoadHelper();
		 classLoadHelper.initialize();
		 getLog().info(""Registering Quartz Job Initialization Plug-in."");
		 StringTokenizer stok = new StringTokenizer(fileNames, FILE_NAME_DELIMITERS);
		 while (stok.hasMoreTokens()) {
			 final String fileName = stok.nextToken();
			 final JobFile jobFile = new JobFile(fileName);
			 jobFiles.put(fileName, jobFile);
		 }
	 }
	 public void start(UserTransaction userTransaction) {
		 try {
			 if (jobFiles.isEmpty() == false) {
				 if (scanInterval > 0) {
					 getScheduler().getContext().put(JOB_INITIALIZATION_PLUGIN_NAME + '_' + getName(), this);
				 }
				 Iterator iterator = jobFiles.values().iterator();
				 while (iterator.hasNext()) {
					 JobFile jobFile = (JobFile)iterator.next();
					 if (scanInterval > 0) {
						 String jobTriggerName = buildJobTriggerName(jobFile.getFileBasename());
						 SimpleTrigger trig = new SimpleTrigger( jobTriggerName, JOB_INITIALIZATION_PLUGIN_NAME, new Date(), null, SimpleTrigger.REPEAT_INDEFINITELY, scanInterval);
						 trig.setVolatility(true);
						 JobDetail job = new JobDetail( jobTriggerName, JOB_INITIALIZATION_PLUGIN_NAME, FileScanJob.class);
						 job.setVolatility(true);
						 job.getJobDataMap().put(FileScanJob.FILE_NAME, jobFile.getFileName());
						 job.getJobDataMap().put(FileScanJob.FILE_SCAN_LISTENER_NAME, JOB_INITIALIZATION_PLUGIN_NAME + '_' + getName());
						 getScheduler().scheduleJob(job, trig);
						 getLog().debug(""Scheduled file scan job for data file: {
						}
						, at interval: {
						}
						"", jobFile.getFileName(), scanInterval);
					 }
					 processFile(jobFile);
				 }
			 }
		 }
		 catch(SchedulerException se) {
			 getLog().error(""Error starting background-task for watching jobs file."", se);
		 }
		 finally {
			 started = true;
		 }
	 }
	 private String buildJobTriggerName( String fileBasename) {
		 String jobTriggerName = JOB_INITIALIZATION_PLUGIN_NAME + '_' + getName() + '_' + fileBasename.replace('.', '_');
		 if (jobTriggerName.length() > MAX_JOB_TRIGGER_NAME_LEN) {
			 jobTriggerName = jobTriggerName.substring(0, MAX_JOB_TRIGGER_NAME_LEN);
		 }
		 int currentIndex = 1;
		 while (jobTriggerNameSet.add(jobTriggerName) == false) {
			 if (currentIndex > 1) {
				 jobTriggerName = jobTriggerName.substring(0, jobTriggerName.lastIndexOf('_'));
			 }
			 String numericSuffix = ""_"" + currentIndex++;
			 if (jobTriggerName.length() > (MAX_JOB_TRIGGER_NAME_LEN - numericSuffix.length())) {
				 jobTriggerName = jobTriggerName.substring(0, (MAX_JOB_TRIGGER_NAME_LEN - numericSuffix.length()));
			 }
			 jobTriggerName += numericSuffix;
		 }
		 return jobTriggerName;
	 }
	 public void shutdown() {
	 }
	 private void processFile(JobFile jobFile) {
		 if (jobFile == null || !jobFile.getFileFound()) {
			 return;
		 }
		 try {
			 XMLSchedulingDataProcessor processor = new XMLSchedulingDataProcessor(this.classLoadHelper);
			 processor.addJobGroupToNeverDelete(JOB_INITIALIZATION_PLUGIN_NAME);
			 processor.addTriggerGroupToNeverDelete(JOB_INITIALIZATION_PLUGIN_NAME);
			 processor.processFileAndScheduleJobs( jobFile.getFileName(), jobFile.getFileName(), getScheduler());
		 }
		 catch (Exception e) {
			 getLog().error(""Error scheduling jobs: "" + e.getMessage(), e);
		 }
	 }
	 public void processFile(String filePath) {
		 processFile((JobFile)jobFiles.get(filePath));
	 }
	 public void fileUpdated(String fileName) {
		 if (started) {
			 processFile(fileName);
		 }
	 }
	 class JobFile {
		 private String fileName;
		 private String filePath;
		 private String fileBasename;
		 private boolean fileFound;
		 protected JobFile(String fileName) throws SchedulerException {
			 this.fileName = fileName;
			 initialize();
		 }
		 protected String getFileName() {
			 return fileName;
		 }
		 protected boolean getFileFound() {
			 return fileFound;
		 }
		 protected String getFilePath() {
			 return filePath;
		 }
		 protected String getFileBasename() {
			 return fileBasename;
		 }
		 private void initialize() throws SchedulerException {
			 InputStream f = null;
			 try {
				 String furl = null;
				 File file = new File(getFileName());
				 if (!file.exists()) {
					 URL url = classLoadHelper.getResource(getFileName());
					 if(url != null) {
						 try {
							 furl = URLDecoder.decode(url.getPath(), ""UTF-8"");
						 }
						 catch (UnsupportedEncodingException e) {
							 furl = url.getPath();
						 }
						 file = new File(furl);
						 try {
							 f = url.openStream();
						 }
						 catch (IOException ignor) {
						 }
					 }
				 }
				 else {
					 try {
						 f = new java.io.FileInputStream(file);
					 }
					catch (FileNotFoundException e) {
					 }
				 }
				 if (f == null) {
					 if (isFailOnFileNotFound()) {
						 throw new SchedulerException( ""File named '"" + getFileName() + ""' does not exist."");
					 }
					 else {
						 getLog().warn(""File named '"" + getFileName() + ""' does not exist."");
					 }
				 }
				 else {
					 fileFound = true;
					 filePath = (furl != null) ? furl : file.getAbsolutePath();
					 fileBasename = file.getName();
				 }
			 }
			 finally {
				 try {
					 if (f != null) {
						 f.close();
					 }
				 }
				 catch (IOException ioe) {
					 getLog().warn(""Error closing jobs file "" + getFileName(), ioe);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class StartHandler implements EventHandler<StartTime> {
	 public void onNext(final StartTime startTime) {
		 LOG.log(Level.INFO, ""StartTime: {
		0}
		"", startTime);
		 resourceRequestHandler.releaseResourceRequestGate();
	 }
 }",0,0,0,0
"public int nextInt(int ub) {
	 if (ub <= 0) throw new IllegalArgumentException(""ub must be positive"");
	 if ( lastUb_ != ub ) {
		 bs_.clear();
		 lastUb_ = ub;
	 }
	 else if(bs_.cardinality() == ub) {
		 bs_.clear();
	 }
	 int value = super.nextInt(ub);
	 while ( bs_.get(value) ) {
		 value = super.nextInt(ub);
	 }
	 bs_.set(value);
	 return value;
 }",0,0,0,0
"public final void rule__MdCategory__Group_4_0__1__Impl() throws RecognitionException {
	 int stackSize = keepStackSize();
	 try {
		 {
			 {
				 if ( state.backtracking==0 ) {
					 before(grammarAccess.getMdCategoryAccess().getLabelAssignment_4_0_1());
				 }
				 {
					 pushFollow(FOLLOW_2);
					 rule__MdCategory__LabelAssignment_4_0_1();
					 state._fsp--;
					 if (state.failed) return ;
				 }
				 if ( state.backtracking==0 ) {
					 after(grammarAccess.getMdCategoryAccess().getLabelAssignment_4_0_1());
				 }
			 }
		 }
	 }
	 catch (RecognitionException re) {
		 reportError(re);
		 recover(input,re);
	 }
	 finally {
		 restoreStackSize(stackSize);
	 }
	 return ;
 }",0,0,1,0
"private void flushBlock() throws IOException {
	 if (this.debug) {
		 System.err.println(""TarBuffer.flushBlock() called."");
	 }
	 if (this.outStream == null) {
		 throw new IOException(""writing to an input buffer"");
	 }
	 if (this.currRecIdx > 0) {
		 this.writeBlock();
	 }
 }",0,0,0,0
"private void assemble() throws IOException {
	InputStream in = null;
	OutputStream out = null;
	totalAssembled = 0L;
	assembling = true;
	assembleFinished = false;
	File outFile = new File(getOutputFolder(), getOutputFileName(true));
	try {
		if (stopFlag)return;
		byte buf[] = new byte[8192 * 8];
		Logger.log(""assembling... "");
		Collections.sort(chunks, new SegmentComparator());
		out = new FileOutputStream(outFile);
		for (int i = 0;
		 i < chunks.size();
		 i++) {
			Logger.log(""chunk "" + i + "" "" + stopFlag);
			Segment c = chunks.get(i);
			in = new FileInputStream(new File(folder, c.getId()));
			long rem = c.getLength();
			while (true) {
				int x = (int) (rem > 0 ? (rem > buf.length ? buf.length : rem) : buf.length);
				int r = in.read(buf, 0, x);
				if (stopFlag) {
					return;
				}
				if (r == -1) {
					if (length > 0) {
						throw new IllegalArgumentException(""Assemble EOF"");
					}
					 else {
						break;
					}
				}
				out.write(buf, 0, r);
				if (stopFlag) {
					return;
				}
				if (length > 0) {
					rem -= r;
					if (rem == 0)break;
				}
				totalAssembled += r;
				long now = System.currentTimeMillis();
				if (now - lastUpdated > 1000) {
					updateStatus();
					lastUpdated = now;
				}
			}
			in.close();
		}
		out.close();
		setLastModifiedDate(outFile);
		assembleFinished = true;
	}
	 catch (Exception e) {
		Logger.log(e);
		throw new IOException(e);
	}
	 finally {
		if (in != null) {
			try {
				in.close();
			}
			 catch (Exception e2) {
			}
		}
		if (out != null) {
			try {
				out.close();
			}
			 catch (Exception e2) {
			}
		}
	}
}",0,0,1,0
"public void execute() throws BuildException {
	 if (file == null) {
		 log(message, logLevel);
	 }
	 else {
		 Writer out = null;
		 try {
			 String filename = file.getAbsolutePath();
			 if (encoding == null || encoding.length() == 0) {
				 out = new FileWriter(filename, append);
			 }
			 else {
				 out = new BufferedWriter( new OutputStreamWriter( new FileOutputStream(filename, append), encoding));
			 }
			 out.write(message, 0, message.length());
		 }
		 catch (IOException ioe) {
			 throw new BuildException(ioe, getLocation());
		 }
		 finally {
			 FileUtils.close(out);
		 }
	 }
 }",0,0,0,0
"public class GenericsUtils {
	 public static final GenericsType[] EMPTY_GENERICS_ARRAY = GenericsType.EMPTY_ARRAY;
	 public static final String JAVA_LANG_OBJECT = ""java.lang.Object"";
	 public static GenericsType[] alignGenericTypes(final GenericsType[] redirectGenericTypes, final GenericsType[] parameterizedTypes, final GenericsType[] alignmentTarget) {
		 if (alignmentTarget == null) return EMPTY_GENERICS_ARRAY;
		 if (parameterizedTypes == null || parameterizedTypes.length == 0) return alignmentTarget;
		 GenericsType[] generics = new GenericsType[alignmentTarget.length];
		 for (int i = 0, scgtLength = alignmentTarget.length;
		 i < scgtLength;
		 i++) {
			 final GenericsType currentTarget = alignmentTarget[i];
			 GenericsType match = null;
			 if (redirectGenericTypes != null) {
				 for (int j = 0;
				 j < redirectGenericTypes.length && match == null;
				 j++) {
					 GenericsType redirectGenericType = redirectGenericTypes[j];
					 if (redirectGenericType.isCompatibleWith(currentTarget.getType())) {
						 if (currentTarget.isPlaceholder() && redirectGenericType.isPlaceholder() && !currentTarget.getName().equals(redirectGenericType.getName())) {
							 boolean skip = false;
							 for (int k = j + 1;
							 k < redirectGenericTypes.length && !skip;
							 k++) {
								 GenericsType ogt = redirectGenericTypes[k];
								 if (ogt.isPlaceholder() && ogt.isCompatibleWith(currentTarget.getType()) && ogt.getName().equals(currentTarget.getName())) {
									 skip = true;
								 }
							 }
							 if (skip) continue;
						 }
						 match = parameterizedTypes[j];
						 if (currentTarget.isWildcard()) {
							 ClassNode lower = currentTarget.getLowerBound() != null ? match.getType() : null;
							 ClassNode[] currentUpper = currentTarget.getUpperBounds();
							 ClassNode[] upper = currentUpper != null ? new ClassNode[currentUpper.length] : null;
							 if (upper != null) {
								 for (int k = 0;
								 k < upper.length;
								 k++) {
									 upper[k] = currentUpper[k].isGenericsPlaceHolder() ? match.getType() : currentUpper[k];
								 }
							 }
							 match = new GenericsType(ClassHelper.makeWithoutCaching(""?""), upper, lower);
							 match.setWildcard(true);
						 }
					 }
				 }
			 }
			 if (match == null) {
				 match = currentTarget;
			 }
			 generics[i] = match;
		 }
		 return generics;
	 }
	 public static GenericsType buildWildcardType(final ClassNode... types) {
		 ClassNode base = ClassHelper.makeWithoutCaching(""?"");
		 GenericsType gt = new GenericsType(base, types, null);
		 gt.setWildcard(true);
		 return gt;
	 }
	 public static Map<GenericsTypeName, GenericsType> extractPlaceholders(ClassNode cn) {
		 Map<GenericsTypeName, GenericsType> ret = new HashMap<GenericsTypeName, GenericsType>();
		 extractPlaceholders(cn, ret);
		 return ret;
	 }
	 public static void extractPlaceholders(ClassNode node, Map<GenericsTypeName, GenericsType> map) {
		 if (node == null) return;
		 if (node.isArray()) {
			 extractPlaceholders(node.getComponentType(), map);
			 return;
		 }
		 if (!node.isUsingGenerics() || !node.isRedirectNode()) return;
		 GenericsType[] parameterized = node.getGenericsTypes();
		 if (parameterized == null || parameterized.length == 0) return;
		 GenericsType[] redirectGenericsTypes = node.redirect().getGenericsTypes();
		 if (redirectGenericsTypes == null || (node.isGenericsPlaceHolder() && redirectGenericsTypes.length != parameterized.length) ) {
			 redirectGenericsTypes = parameterized;
		 }
		 if (redirectGenericsTypes.length != parameterized.length) {
			 throw new GroovyBugError(""Expected earlier checking to detect generics parameter arity mismatch"" + ""\nExpected: "" + node.getName() + toGenericTypesString(redirectGenericsTypes) + ""\nSupplied: "" + node.getName() + toGenericTypesString(parameterized));
		 }
		 List<GenericsType> valueList = new LinkedList<>();
		 for (int i = 0;
		 i < redirectGenericsTypes.length;
		 i++) {
			 GenericsType redirectType = redirectGenericsTypes[i];
			 if (redirectType.isPlaceholder()) {
				 GenericsTypeName name = new GenericsTypeName(redirectType.getName());
				 if (!map.containsKey(name)) {
					 GenericsType value = parameterized[i];
					 map.put(name, value);
					 valueList.add(value);
				 }
			 }
		 }
		 for (GenericsType value : valueList) {
			 if (value.isWildcard()) {
				 ClassNode lowerBound = value.getLowerBound();
				 if (lowerBound != null) {
					 extractPlaceholders(lowerBound, map);
				 }
				 ClassNode[] upperBounds = value.getUpperBounds();
				 if (upperBounds != null) {
					 for (ClassNode upperBound : upperBounds) {
						 extractPlaceholders(upperBound, map);
					 }
				 }
			 }
			 else if (!value.isPlaceholder()) {
				 extractPlaceholders(value.getType(), map);
			 }
		 }
	 }
	 public static String toGenericTypesString(GenericsType[] genericsTypes) {
		 if (genericsTypes == null) return """";
		 StringBuilder sb = new StringBuilder(""<"");
		 for (int i = 0, n = genericsTypes.length;
		 i < n;
		 i++) {
			 sb.append(genericsTypes[i].toString());
			 if (i < n - 1) {
				 sb.append("","");
			 }
		 }
		 sb.append(""> "");
		 return sb.toString();
	 }
	 public static ClassNode parameterizeInterfaceGenerics(final ClassNode hint, final ClassNode target) {
		 return parameterizeType(hint, target);
	 }
	 public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {
		 if (hint.isArray()) {
			 if (target.isArray()) {
				 return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();
			 }
			 return target;
		 }
		 if (!target.equals(hint) && implementsInterfaceOrIsSubclassOf(target, hint)) {
			 ClassNode nextSuperClass = ClassHelper.getNextSuperClass(target, hint);
			 if (!hint.equals(nextSuperClass)) {
				 Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);
				 extractSuperClassGenerics(hint, nextSuperClass, genericsSpec);
				 ClassNode result = correctToGenericsSpecRecurse(genericsSpec, nextSuperClass);
				 return parameterizeType(result, target);
			 }
		 }
		 Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);
		 ClassNode targetRedirect = target.redirect();
		 genericsSpec = createGenericsSpec(targetRedirect, genericsSpec);
		 extractSuperClassGenerics(hint, targetRedirect, genericsSpec);
		 return correctToGenericsSpecRecurse(genericsSpec, targetRedirect);
	 }
	 public static ClassNode nonGeneric(ClassNode type) {
		 if (type.isUsingGenerics()) {
			 final ClassNode nonGen = ClassHelper.makeWithoutCaching(type.getName());
			 nonGen.setRedirect(type);
			 nonGen.setGenericsTypes(null);
			 nonGen.setUsingGenerics(false);
			 return nonGen;
		 }
		 if (type.isArray() && type.getComponentType().isUsingGenerics()) {
			 return type.getComponentType().getPlainNodeReference().makeArray();
		 }
		 return type;
	 }
	 public static ClassNode newClass(ClassNode type) {
		 return type.getPlainNodeReference();
	 }
	 public static ClassNode makeClassSafe(Class klass) {
		 return makeClassSafeWithGenerics(ClassHelper.make(klass));
	 }
	 public static ClassNode makeClassSafeWithGenerics(Class klass, ClassNode genericsType) {
		 GenericsType[] genericsTypes = new GenericsType[1];
		 genericsTypes[0] = new GenericsType(genericsType);
		 return makeClassSafeWithGenerics(ClassHelper.make(klass), genericsTypes);
	 }
	 public static ClassNode makeClassSafe0(ClassNode type, GenericsType... genericTypes) {
		 ClassNode plainNodeReference = newClass(type);
		 if (genericTypes != null && genericTypes.length > 0) {
			 plainNodeReference.setGenericsTypes(genericTypes);
			 if (type.isGenericsPlaceHolder()) plainNodeReference.setGenericsPlaceHolder(true);
		 }
		 return plainNodeReference;
	 }
	 public static ClassNode makeClassSafeWithGenerics(ClassNode type, GenericsType... genericTypes) {
		 if (type.isArray()) {
			 return makeClassSafeWithGenerics(type.getComponentType(), genericTypes).makeArray();
		 }
		 GenericsType[] gtypes = GenericsType.EMPTY_ARRAY;
		 if (genericTypes != null) {
			 gtypes = new GenericsType[genericTypes.length];
			 System.arraycopy(genericTypes, 0, gtypes, 0, gtypes.length);
		 }
		 return makeClassSafe0(type, gtypes);
	 }
	 public static MethodNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, MethodNode mn) {
		 ClassNode correctedType = correctToGenericsSpecRecurse(genericsSpec, mn.getReturnType());
		 Parameter[] origParameters = mn.getParameters();
		 Parameter[] newParameters = new Parameter[origParameters.length];
		 for (int i = 0;
		 i < origParameters.length;
		 i++) {
			 Parameter origParameter = origParameters[i];
			 newParameters[i] = new Parameter(correctToGenericsSpecRecurse(genericsSpec, origParameter.getType()), origParameter.getName(), origParameter.getInitialExpression());
		 }
		 return new MethodNode(mn.getName(), mn.getModifiers(), correctedType, newParameters, mn.getExceptions(), mn.getCode());
	 }
	 public static ClassNode correctToGenericsSpecRecurse(Map<String, ClassNode> genericsSpec, ClassNode type) {
		 return correctToGenericsSpecRecurse(genericsSpec, type, new ArrayList<String>());
	 }
	 public static ClassNode[] correctToGenericsSpecRecurse(Map<String, ClassNode> genericsSpec, ClassNode[] types) {
		 if (types == null || types.length == 1) return types;
		 ClassNode[] newTypes = new ClassNode[types.length];
		 boolean modified = false;
		 for (int i = 0;
		 i < types.length;
		 i++) {
			 newTypes[i] = correctToGenericsSpecRecurse(genericsSpec, types[i], new ArrayList<String>());
			 modified = modified || (types[i] != newTypes[i]);
		 }
		 if (!modified) return types;
		 return newTypes;
	 }
	 public static ClassNode correctToGenericsSpecRecurse(Map<String, ClassNode> genericsSpec, ClassNode type, List<String> exclusions) {
		 if (type.isArray()) {
			 return correctToGenericsSpecRecurse(genericsSpec, type.getComponentType(), exclusions).makeArray();
		 }
		 if (type.isGenericsPlaceHolder() && !exclusions.contains(type.getUnresolvedName())) {
			 String name = type.getGenericsTypes()[0].getName();
			 type = genericsSpec.get(name);
			 if (type != null && type.isGenericsPlaceHolder() && type.getGenericsTypes() == null) {
				 ClassNode placeholder = ClassHelper.makeWithoutCaching(type.getUnresolvedName());
				 placeholder.setGenericsPlaceHolder(true);
				 type = makeClassSafeWithGenerics(type, new GenericsType(placeholder));
			 }
		 }
		 if (type == null) type = ClassHelper.OBJECT_TYPE;
		 GenericsType[] oldgTypes = type.getGenericsTypes();
		 GenericsType[] newgTypes = GenericsType.EMPTY_ARRAY;
		 if (oldgTypes != null) {
			 newgTypes = new GenericsType[oldgTypes.length];
			 for (int i = 0;
			 i < newgTypes.length;
			 i++) {
				 GenericsType oldgType = oldgTypes[i];
				 if (oldgType.isPlaceholder()) {
					 if (genericsSpec.get(oldgType.getName()) != null) {
						 newgTypes[i] = new GenericsType(genericsSpec.get(oldgType.getName()));
					 }
					 else {
						 newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);
					 }
				 }
				 else if (oldgType.isWildcard()) {
					 ClassNode oldLower = oldgType.getLowerBound();
					 ClassNode lower = oldLower != null ? correctToGenericsSpecRecurse(genericsSpec, oldLower, exclusions) : null;
					 ClassNode[] oldUpper = oldgType.getUpperBounds();
					 ClassNode[] upper = null;
					 if (oldUpper != null) {
						 upper = new ClassNode[oldUpper.length];
						 for (int j = 0;
						 j < oldUpper.length;
						 j++) {
							 upper[j] = correctToGenericsSpecRecurse(genericsSpec, oldUpper[j], exclusions);
						 }
					 }
					 GenericsType fixed = new GenericsType(oldgType.getType(), upper, lower);
					 fixed.setName(oldgType.getName());
					 fixed.setWildcard(true);
					 newgTypes[i] = fixed;
				 }
				 else {
					 newgTypes[i] = new GenericsType(correctToGenericsSpecRecurse(genericsSpec, correctToGenericsSpec(genericsSpec, oldgType), exclusions));
				 }
			 }
		 }
		 return makeClassSafeWithGenerics(type, newgTypes);
	 }
	 public static ClassNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, GenericsType type) {
		 ClassNode ret = null;
		 if (type.isPlaceholder()) {
			 String name = type.getName();
			 ret = genericsSpec.get(name);
		 }
		 if (ret == null) ret = type.getType();
		 return ret;
	 }
	 public static ClassNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, ClassNode type) {
		 if (type.isArray()) {
			 return correctToGenericsSpec(genericsSpec, type.getComponentType()).makeArray();
		 }
		 if (type.isGenericsPlaceHolder()) {
			 String name = type.getGenericsTypes()[0].getName();
			 type = genericsSpec.get(name);
		 }
		 if (type == null) type = ClassHelper.OBJECT_TYPE;
		 return type;
	 }
	 public static Map<String, ClassNode> createGenericsSpec(ClassNode current) {
		 return createGenericsSpec(current, Collections.EMPTY_MAP);
	 }
	 public static Map<String, ClassNode> createGenericsSpec(ClassNode current, Map<String, ClassNode> oldSpec) {
		 Map<String, ClassNode> ret = new HashMap<String, ClassNode>(oldSpec);
		 GenericsType[] sgts = current.getGenericsTypes();
		 if (sgts != null) {
			 ClassNode[] spec = new ClassNode[sgts.length];
			 for (int i = 0;
			 i < spec.length;
			 i++) {
				 spec[i] = correctToGenericsSpec(ret, sgts[i]);
			 }
			 GenericsType[] newGts = current.redirect().getGenericsTypes();
			 if (newGts == null) return ret;
			 ret.clear();
			 for (int i = 0;
			 i < spec.length;
			 i++) {
				 ret.put(newGts[i].getName(), spec[i]);
			 }
		 }
		 return ret;
	 }
	 public static Map<String, ClassNode> addMethodGenerics(MethodNode current, Map<String, ClassNode> oldSpec) {
		 Map<String, ClassNode> ret = new HashMap<String, ClassNode>(oldSpec);
		 GenericsType[] sgts = current.getGenericsTypes();
		 if (sgts != null) {
			 for (GenericsType sgt : sgts) {
				 String name = sgt.getName();
				 if (sgt.isPlaceholder()) {
					 ClassNode redirect;
					 if (sgt.getUpperBounds() != null) {
						 redirect = sgt.getUpperBounds()[0];
					 }
					 else if (sgt.getLowerBound() != null) {
						 redirect = sgt.getLowerBound();
					 }
					 else {
						 redirect = ClassHelper.OBJECT_TYPE;
					 }
					 ClassNode type = ClassHelper.makeWithoutCaching(name);
					 type.setGenericsPlaceHolder(true);
					 type.setRedirect(redirect);
					 ret.put(name, type);
				 }
				 else {
					 ret.put(name, sgt.getType());
				 }
			 }
		 }
		 return ret;
	 }
	 public static void extractSuperClassGenerics(ClassNode type, ClassNode target, Map<String, ClassNode> spec) {
		 if (target == null || type == target) return;
		 if (type.isArray() && target.isArray()) {
			 extractSuperClassGenerics(type.getComponentType(), target.getComponentType(), spec);
		 }
		 else if (type.isArray() && JAVA_LANG_OBJECT.equals(target.getName())) {
		 }
		 else if (target.isGenericsPlaceHolder() || type.equals(target) || !implementsInterfaceOrIsSubclassOf(type, target)) {
			 if (target.isGenericsPlaceHolder()) {
				 spec.put(target.getGenericsTypes()[0].getName(), type);
			 }
			 else {
				 extractSuperClassGenerics(type.getGenericsTypes(), target.getGenericsTypes(), spec);
			 }
		 }
		 else {
			 ClassNode superClass = getSuperClass(type, target);
			 if (superClass != null) {
				 ClassNode corrected = getCorrectedClassNode(type, superClass, false);
				 extractSuperClassGenerics(corrected, target, spec);
			 }
			 else {
				 throw new GroovyBugError(""The type "" + type + "" seems not to normally extend "" + target + "". Sorry, I cannot handle this."");
			 }
		 }
	 }
	 public static ClassNode getSuperClass(ClassNode type, ClassNode target) {
		 ClassNode superClass = ClassHelper.getNextSuperClass(type, target);
		 if (superClass == null) {
			 if (ClassHelper.isPrimitiveType(type)) {
				 superClass = ClassHelper.getNextSuperClass(ClassHelper.getWrapper(type), target);
			 }
		 }
		 return superClass;
	 }
	 private static void extractSuperClassGenerics(GenericsType[] usage, GenericsType[] declaration, Map<String, ClassNode> spec) {
		 if (usage == null || declaration == null || declaration.length == 0) return;
		 if (usage.length != declaration.length) return;
		 for (int i = 0;
		 i < usage.length;
		 i++) {
			 GenericsType ui = usage[i];
			 GenericsType di = declaration[i];
			 if (di.isPlaceholder()) {
				 spec.put(di.getName(), ui.getType());
			 }
			 else if (di.isWildcard()) {
				 if (ui.isWildcard()) {
					 extractSuperClassGenerics(ui.getLowerBound(), di.getLowerBound(), spec);
					 extractSuperClassGenerics(ui.getUpperBounds(), di.getUpperBounds(), spec);
				 }
				 else {
					 ClassNode cu = ui.getType();
					 extractSuperClassGenerics(cu, di.getLowerBound(), spec);
					 ClassNode[] upperBounds = di.getUpperBounds();
					 if (upperBounds != null) {
						 for (ClassNode cn : upperBounds) {
							 extractSuperClassGenerics(cu, cn, spec);
						 }
					 }
				 }
			 }
			 else {
				 extractSuperClassGenerics(ui.getType(), di.getType(), spec);
			 }
		 }
	 }
	 private static void extractSuperClassGenerics(ClassNode[] usage, ClassNode[] declaration, Map<String, ClassNode> spec) {
		 if (usage == null || declaration == null || declaration.length == 0) return;
		 for (int i = 0;
		 i < usage.length;
		 i++) {
			 ClassNode ui = usage[i];
			 ClassNode di = declaration[i];
			 if (di.isGenericsPlaceHolder()) {
				 spec.put(di.getGenericsTypes()[0].getName(), di);
			 }
			 else if (di.isUsingGenerics()) {
				 extractSuperClassGenerics(ui.getGenericsTypes(), di.getGenericsTypes(), spec);
			 }
		 }
	 }
	 public static ClassNode[] parseClassNodesFromString( final String option, final SourceUnit sourceUnit, final CompilationUnit compilationUnit, final MethodNode mn, final ASTNode usage) {
		 GroovyLexer lexer = new GroovyLexer(new StringReader(""DummyNode<"" + option + "">""));
		 final GroovyRecognizer rn = GroovyRecognizer.make(lexer);
		 try {
			 rn.classOrInterfaceType(true);
			 final AtomicReference<ClassNode> ref = new AtomicReference<ClassNode>();
			 AntlrParserPlugin plugin = new AntlrParserPlugin() {
				 public ModuleNode buildAST(final SourceUnit sourceUnit, final ClassLoader classLoader, final Reduction cst) throws ParserException {
					 ref.set(makeTypeWithArguments(rn.getAST()));
					 return null;
				 }
			 }
			;
			 plugin.buildAST(null, null, null);
			 ClassNode parsedNode = ref.get();
			 GenericsType[] parsedNodeGenericsTypes = parsedNode.getGenericsTypes();
			 if (parsedNodeGenericsTypes == null) {
				 return null;
			 }
			 ClassNode[] signature = new ClassNode[parsedNodeGenericsTypes.length];
			 for (int i = 0;
			 i < parsedNodeGenericsTypes.length;
			 i++) {
				 final GenericsType genericsType = parsedNodeGenericsTypes[i];
				 signature[i] = resolveClassNode(sourceUnit, compilationUnit, mn, usage, genericsType.getType());
			 }
			 return signature;
		 }
		 catch (RecognitionException | ParserException | TokenStreamException e) {
			 sourceUnit.addError(new IncorrectTypeHintException(mn, e, usage.getLineNumber(), usage.getColumnNumber()));
		 }
		 return null;
	 }
	 private static ClassNode resolveClassNode(final SourceUnit sourceUnit, final CompilationUnit compilationUnit, final MethodNode mn, final ASTNode usage, final ClassNode parsedNode) {
		 ClassNode dummyClass = new ClassNode(""dummy"", 0, ClassHelper.OBJECT_TYPE);
		 dummyClass.setModule(new ModuleNode(sourceUnit));
		 dummyClass.setGenericsTypes(mn.getDeclaringClass().getGenericsTypes());
		 MethodNode dummyMN = new MethodNode( ""dummy"", 0, parsedNode, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE );
		 dummyMN.setGenericsTypes(mn.getGenericsTypes());
		 dummyClass.addMethod(dummyMN);
		 ResolveVisitor visitor = new ResolveVisitor(compilationUnit) {
			 public void addError(final String msg, final ASTNode expr) {
				 sourceUnit.addError(new IncorrectTypeHintException(mn, msg, usage.getLineNumber(), usage.getColumnNumber()));
			 }
		 }
		;
		 visitor.startResolving(dummyClass, sourceUnit);
		 return dummyMN.getReturnType();
	 }
	 public static GenericsType[] applyGenericsContextToPlaceHolders(Map<String, ClassNode> genericsSpec, GenericsType[] oldPlaceHolders) {
		 if (oldPlaceHolders == null || oldPlaceHolders.length == 0) return oldPlaceHolders;
		 if (genericsSpec.isEmpty()) return oldPlaceHolders;
		 GenericsType[] newTypes = new GenericsType[oldPlaceHolders.length];
		 for (int i = 0;
		 i < oldPlaceHolders.length;
		 i++) {
			 GenericsType old = oldPlaceHolders[i];
			 if (!old.isPlaceholder()) throw new GroovyBugError(""Given generics type "" + old + "" must be a placeholder!"");
			 ClassNode fromSpec = genericsSpec.get(old.getName());
			 if (fromSpec != null) {
				 if (fromSpec.isGenericsPlaceHolder()) {
					 ClassNode[] upper = new ClassNode[]{
					fromSpec.redirect()}
					;
					 newTypes[i] = new GenericsType(fromSpec, upper, null);
				 }
				 else {
					 newTypes[i] = new GenericsType(fromSpec);
				 }
			 }
			 else {
				 ClassNode[] upper = old.getUpperBounds();
				 ClassNode[] newUpper = upper;
				 if (upper != null && upper.length > 0) {
					 ClassNode[] upperCorrected = new ClassNode[upper.length];
					 for (int j = 0;
					 j < upper.length;
					 j++) {
						 upperCorrected[i] = correctToGenericsSpecRecurse(genericsSpec, upper[j]);
					 }
					 upper = upperCorrected;
				 }
				 ClassNode lower = old.getLowerBound();
				 ClassNode newLower = correctToGenericsSpecRecurse(genericsSpec, lower);
				 if (lower == newLower && upper == newUpper) {
					 newTypes[i] = oldPlaceHolders[i];
				 }
				 else {
					 ClassNode newPlaceHolder = ClassHelper.make(old.getName());
					 GenericsType gt = new GenericsType(newPlaceHolder, newUpper, newLower);
					 gt.setPlaceholder(true);
					 newTypes[i] = gt;
				 }
			 }
		 }
		 return newTypes;
	 }
	 private static final String TRUE_STR = ""true"";
	 private static final boolean PARAMETERIZED_TYPE_CACHE_ENABLED = TRUE_STR.equals(SystemUtil.getSystemPropertySafe(""groovy.enable.parameterized.type.cache"", TRUE_STR));
	 public static ClassNode findParameterizedTypeFromCache(final ClassNode genericsClass, final ClassNode actualType, boolean tryToFindExactType) {
		 if (!PARAMETERIZED_TYPE_CACHE_ENABLED) {
			 return findParameterizedType(genericsClass, actualType, tryToFindExactType);
		 }
		 SoftReference<ClassNode> sr = PARAMETERIZED_TYPE_CACHE.getAndPut(new ParameterizedTypeCacheKey(genericsClass, actualType), key -> new SoftReference<>(findParameterizedType(key.getGenericsClass(), key.getActualType(), tryToFindExactType)));
		 return null == sr ? null : sr.get();
	 }
	 public static ClassNode findParameterizedType(ClassNode genericsClass, ClassNode actualType, boolean tryToFindExactType) {
		 ClassNode parameterizedType = null;
		 if (null == genericsClass.getGenericsTypes()) {
			 return parameterizedType;
		 }
		 GenericsType[] declaringGenericsTypes = genericsClass.getGenericsTypes();
		 List<ClassNode> classNodeList = new LinkedList<>(getAllSuperClassesAndInterfaces(actualType));
		 classNodeList.add(0, actualType);
		 LinkedList<ClassNode> parameterizedTypeCandidateList = new LinkedList<>();
		 for (ClassNode cn : classNodeList) {
			 if (cn == genericsClass) {
				 continue;
			 }
			 if (tryToFindExactType && null != cn.getGenericsTypes() && hasNonPlaceHolders(cn)) {
				 parameterizedTypeCandidateList.add(cn);
			 }
			 if (!(genericsClass.equals(cn.redirect()))) {
				 continue;
			 }
			 if (isGenericsTypeArraysLengthEqual(declaringGenericsTypes, cn.getGenericsTypes())) {
				 parameterizedType = cn;
				 break;
			 }
		 }
		 if (null == parameterizedType) {
			 if (!parameterizedTypeCandidateList.isEmpty()) {
				 parameterizedType = parameterizedTypeCandidateList.getLast();
			 }
		 }
		 return parameterizedType;
	 }
	 private static boolean isGenericsTypeArraysLengthEqual(GenericsType[] declaringGenericsTypes, GenericsType[] actualGenericsTypes) {
		 return null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length;
	 }
	 private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiver) {
		 List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
		 List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiver);
		 superClassAndInterfaceList.addAll(allSuperClassNodeList);
		 superClassAndInterfaceList.addAll(actualReceiver.getAllInterfaces());
		 for (ClassNode superClassNode : allSuperClassNodeList) {
			 superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
		 }
		 return superClassAndInterfaceList;
	 }
	 private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiver) {
		 List<ClassNode> superClassNodeList = new LinkedList<>();
		 for (ClassNode cn = actualReceiver.getUnresolvedSuperClass();
		 null != cn && ClassHelper.OBJECT_TYPE != cn;
		 cn = cn.getUnresolvedSuperClass()) {
			 superClassNodeList.add(cn);
		 }
		 return superClassNodeList;
	 }
	 private static final EvictableCache<ParameterizedTypeCacheKey, SoftReference<ClassNode>> PARAMETERIZED_TYPE_CACHE = new ConcurrentSoftCache<>(64);
	 public static void clearParameterizedTypeCache() {
		 PARAMETERIZED_TYPE_CACHE.clearAll();
	 }
	 public static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver) {
		 return doMakeDeclaringAndActualGenericsTypeMap(declaringClass, actualReceiver, false).getV1();
	 }
	 public static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMapOfExactType(ClassNode declaringClass, ClassNode actualReceiver) {
		 List<ClassNode> parameterizedTypeList = new LinkedList<>();
		 Map<GenericsType, GenericsType> result = makeDeclaringAndActualGenericsTypeMapOfExactType(declaringClass, actualReceiver, parameterizedTypeList);
		 return connectGenericsTypes(result);
	 }
	 private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMapOfExactType(ClassNode declaringClass, ClassNode actualReceiver, List<ClassNode> parameterizedTypeList) {
		 Tuple2<Map<GenericsType, GenericsType>, ClassNode> resultAndParameterizedTypeTuple = doMakeDeclaringAndActualGenericsTypeMap(declaringClass, actualReceiver, true);
		 ClassNode parameterizedType = resultAndParameterizedTypeTuple.getV2();
		 Map<GenericsType, GenericsType> result = resultAndParameterizedTypeTuple.getV1();
		 if (hasPlaceHolders(parameterizedType) && !parameterizedTypeList.contains(parameterizedType)) {
			 parameterizedTypeList.add(parameterizedType);
			 result.putAll(makeDeclaringAndActualGenericsTypeMapOfExactType(parameterizedType, actualReceiver, parameterizedTypeList));
		 }
		 return connectGenericsTypes(result);
	 }
	 private static Tuple2<Map<GenericsType, GenericsType>, ClassNode> doMakeDeclaringAndActualGenericsTypeMap(ClassNode declaringClass, ClassNode actualReceiver, boolean tryToFindExactType) {
		 ClassNode parameterizedType = findParameterizedTypeFromCache(declaringClass, actualReceiver, tryToFindExactType);
		 if (null == parameterizedType) {
			 return tuple(Collections.emptyMap(), parameterizedType);
		 }
		 Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
		 result.putAll(makePlaceholderAndParameterizedTypeMap(declaringClass));
		 result.putAll(makePlaceholderAndParameterizedTypeMap(parameterizedType));
		 result = connectGenericsTypes(result);
		 return tuple(result, parameterizedType);
	 }
	 private static Map<GenericsType, GenericsType> makePlaceholderAndParameterizedTypeMap(ClassNode declaringClass) {
		 if (null == declaringClass) {
			 return Collections.emptyMap();
		 }
		 Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
		 ClassNode redirectDeclaringClass = declaringClass.redirect();
		 GenericsType[] declaringGenericsTypes = declaringClass.getGenericsTypes();
		 GenericsType[] redirectDeclaringGenericsTypes = redirectDeclaringClass.getGenericsTypes();
		 if (null != declaringGenericsTypes && null != redirectDeclaringGenericsTypes) {
			 for (int i = 0, n = declaringGenericsTypes.length;
			 i < n;
			 i++) {
				 result.put(redirectDeclaringGenericsTypes[i], declaringGenericsTypes[i]);
			 }
		 }
		 return result;
	 }
	 private static Map<GenericsType, GenericsType> connectGenericsTypes(Map<GenericsType, GenericsType> genericsTypeMap) {
		 Map<GenericsType, GenericsType> result = new LinkedHashMap<>();
		 outter: for (Map.Entry<GenericsType, GenericsType> entry : genericsTypeMap.entrySet()) {
			 GenericsType key = entry.getKey();
			 GenericsType value = entry.getValue();
			 if (value.isPlaceholder()) {
				 for (Map.Entry<GenericsType, GenericsType> genericsTypeMapEntry : genericsTypeMap.entrySet()) {
					 GenericsType genericsTypeMapEntryValue = genericsTypeMapEntry.getValue();
					 if (!genericsTypeMapEntryValue.isPlaceholder() && (genericsTypeMapEntry.getKey().getName().equals(value.getName()))) {
						 result.put(key, genericsTypeMapEntryValue);
						 continue outter;
					 }
				 }
			 }
			 result.put(key, value);
		 }
		 return result;
	 }
	 public static boolean hasNonPlaceHolders(ClassNode parameterizedType) {
		 return checkPlaceHolders(parameterizedType, genericsType -> !genericsType.isPlaceholder());
	 }
	 public static boolean hasPlaceHolders(ClassNode parameterizedType) {
		 return checkPlaceHolders(parameterizedType, genericsType -> genericsType.isPlaceholder());
	 }
	 private static boolean checkPlaceHolders(ClassNode parameterizedType, Predicate<GenericsType> p) {
		 if (null == parameterizedType) return false;
		 GenericsType[] genericsTypes = parameterizedType.getGenericsTypes();
		 if (null == genericsTypes) return false;
		 for (GenericsType genericsType : genericsTypes) {
			 if (p.test(genericsType)) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public static Tuple2<ClassNode[], ClassNode> parameterizeSAM(ClassNode sam) {
		 MethodNode methodNode = ClassHelper.findSAM(sam);
		 final Map<GenericsType, GenericsType> map = makeDeclaringAndActualGenericsTypeMapOfExactType(methodNode.getDeclaringClass(), sam);
		 ClassNode[] parameterTypes = Arrays.stream(methodNode.getParameters()) .map(e -> {
			 ClassNode originalParameterType = e.getType();
			 return originalParameterType.isGenericsPlaceHolder() ? findActualTypeByGenericsPlaceholderName(originalParameterType.getUnresolvedName(), map) : originalParameterType;
		 }
		) .toArray(ClassNode[]::new);
		 ClassNode originalReturnType = methodNode.getReturnType();
		 ClassNode returnType = originalReturnType.isGenericsPlaceHolder() ? findActualTypeByGenericsPlaceholderName(originalReturnType.getUnresolvedName(), map) : originalReturnType;
		 return tuple(parameterTypes, returnType);
	 }
	 public static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
		 for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
			 GenericsType declaringGenericsType = entry.getKey();
			 if (placeholderName.equals(declaringGenericsType.getName())) {
				 return entry.getValue().getType().redirect();
			 }
		 }
		 return null;
	 }
	 private static class ParameterizedTypeCacheKey {
		 private ClassNode genericsClass;
		 private ClassNode actualType;
		 public ParameterizedTypeCacheKey(ClassNode genericsClass, ClassNode actualType) {
			 this.genericsClass = genericsClass;
			 this.actualType = actualType;
		 }
		 public ClassNode getGenericsClass() {
			 return genericsClass;
		 }
		 public void setGenericsClass(ClassNode genericsClass) {
			 this.genericsClass = genericsClass;
		 }
		 public ClassNode getActualType() {
			 return actualType;
		 }
		 public void setActualType(ClassNode actualType) {
			 this.actualType = actualType;
		 }
		 public boolean equals(Object o) {
			 if (this == o) return true;
			 if (o == null || getClass() != o.getClass()) return false;
			 ParameterizedTypeCacheKey cacheKey = (ParameterizedTypeCacheKey) o;
			 return genericsClass == cacheKey.genericsClass && actualType == cacheKey.actualType;
		 }
		 public int hashCode() {
			 return Objects.hash(genericsClass, actualType);
		 }
	 }
}",1,0,0,0
"public void sequence(ISerializationContext context, EObject semanticObject) {
	EPackage epackage = semanticObject.eClass().getEPackage();
	ParserRule rule = context.getParserRule();
	Action action = context.getAssignedAction();
	Set<Parameter> parameters = context.getEnabledBooleanParameters();
	if (epackage == Bug250313Package.eINSTANCE)switch (semanticObject.eClass().getClassifierID()) {
		case Bug250313Package.CHILD1:sequence_Child1(context, (Child1) semanticObject);
		 return;
		 case Bug250313Package.CHILD2:sequence_Child2(context, (Child2) semanticObject);
		 return;
		 case Bug250313Package.MODEL:sequence_Model(context, (Model) semanticObject);
		 return;
	 }
	if (errorAcceptor != null)errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
}",0,0,1,0
"public class BasicUUID implements UUID, Formatable{
	private long majorId;
	 private long timemillis;
	private int sequence;
	public BasicUUID(long majorId, long timemillis, int sequence){
		this.majorId = majorId;
		this.timemillis = timemillis;
		this.sequence = sequence;
	}
	public BasicUUID(String uuidstring){
		StringReader sr = new StringReader(uuidstring);
		sequence = (int) readMSB(sr);
		long ltimemillis = readMSB(sr) << 32;
		ltimemillis += readMSB(sr) << 16;
		ltimemillis += readMSB(sr);
		timemillis = ltimemillis;
		majorId = readMSB(sr);
	}
	public BasicUUID() {
		 super();
	 }
	public void writeExternal(ObjectOutput out) throws IOException {
		out.writeLong(majorId);
		out.writeLong(timemillis);
		out.writeInt(sequence);
	}
	public void readExternal(ObjectInput in) throws IOException{
		majorId = in.readLong();
		timemillis = in.readLong();
		sequence = in.readInt();
	}
	public int getTypeFormatId() {
		return StoredFormatIds.BASIC_UUID;
	}
	private static void writeMSB(char[] data, int offset, long value, int nbytes) {
		 for (int i = nbytes - 1;
		 i >= 0;
		 i--){
			 long b = (value & (255L << (8 * i))) >>> (8 * i);
			 int c = (int) ((b & 0xf0) >> 4);
			 data[offset++] = (char) (c < 10 ? c + '0' : (c - 10) + 'a');
			 c = (int) (b & 0x0f);
			 data[offset++] = (char) (c < 10 ? c + '0' : (c - 10) + 'a');
		}
	 }
	private static long readMSB(StringReader sr) {
		long value = 0;
		try{
			int c;
			while ((c = sr.read()) != -1){
				if (c == '-')break;
				value <<= 4;
				int nibble;
				if (c <= '9')nibble = c - '0';
				else if (c <= 'F')nibble = c - 'A' + 10;
				elsenibble = c - 'a' + 10;
				value += nibble;
			}
		}
		catch (Exception e){
		}
		return value;
	 }
	public boolean equals(Object otherObject){
		if (!(otherObject instanceof BasicUUID))return false;
		BasicUUID other = (BasicUUID) otherObject;
		return (this.sequence == other.sequence)&& (this.timemillis == other.timemillis)&& (this.majorId == other.majorId);
	}
	public int hashCode(){
		long hc = majorId ^ timemillis;
		return sequence ^ ((int) (hc >> 4));
	}
	public String toString() {
		return stringWorkhorse( '-' );
	}
	public String toANSIidentifier() {
		return ""U"" + stringWorkhorse( 'X' );
	}
	publicStringstringWorkhorse( char separator ){
		char[] data = new char[36];
		writeMSB(data, 0, (long) sequence, 4);
		int offset = 8;
		if (separator != 0) data[offset++] = separator;
		long ltimemillis = timemillis;
		writeMSB(data, offset, (ltimemillis & 0x0000ffff00000000L) >>> 32, 2);
		offset += 4;
		if (separator != 0) data[offset++] = separator;
		writeMSB(data, offset, (ltimemillis & 0x00000000ffff0000L) >>> 16, 2);
		offset += 4;
		if (separator != 0) data[offset++] = separator;
		writeMSB(data, offset, (ltimemillis & 0x000000000000ffffL), 2);
		offset += 4;
		if (separator != 0) data[offset++] = separator;
		writeMSB(data, offset, majorId, 6);
		offset += 12;
		return new String(data, 0, offset);
	}
	public UUID cloneMe(){
		returnnewBasicUUID(majorId, timemillis, sequence);
	}
}",1,1,0,0
"private BuildException noChildrenAllowed() {
	 return new BuildException(""You must not specify nested "" + ""elements when using the refid attribute."");
 }",0,0,0,0
"public class ImportTask extends Task {
	 private String file;
	 private boolean optional;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 public void setOptional(boolean optional) {
		 this.optional = optional;
	 }
	 public void setFile(String file) {
		 this.file = file;
	 }
	 public void execute() {
		 if (file == null) {
			 throw new BuildException(""import requires file attribute"");
		 }
		 if (getOwningTarget() == null || !"""".equals(getOwningTarget().getName())) {
			 throw new BuildException(""import only allowed as a top-level task"");
		 }
		 ProjectHelper helper = (ProjectHelper) getProject(). getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
		 if (helper == null) {
			 throw new BuildException(""import requires support in ProjectHelper"");
		 }
		 Vector importStack = helper.getImportStack();
		 if (importStack.size() == 0) {
			 throw new BuildException(""import requires support in ProjectHelper"");
		 }
		 if (getLocation() == null || getLocation().getFileName() == null) {
			 throw new BuildException(""Unable to get location of import task"");
		 }
		 File buildFile = new File(getLocation().getFileName()).getAbsoluteFile();
		 File buildFileParent = new File(buildFile.getParent());
		 File importedFile = FILE_UTILS.resolveFile(buildFileParent, file);
		 getProject().log(""Importing file "" + importedFile + "" from "" + buildFile.getAbsolutePath(), Project.MSG_VERBOSE);
		 if (!importedFile.exists()) {
			 String message = ""Cannot find "" + file + "" imported from "" + buildFile.getAbsolutePath();
			 if (optional) {
				 getProject().log(message, Project.MSG_VERBOSE);
				 return;
			 }
			 else {
				 throw new BuildException(message);
			 }
		 }
		 if (importStack.contains(importedFile)) {
			 getProject().log( ""Skipped already imported file:\n "" + importedFile + ""\n"", Project.MSG_VERBOSE);
			 return;
		 }
		 try {
			 helper.parse(getProject(), importedFile);
		 }
		 catch (BuildException ex) {
			 throw ProjectHelper.addLocationToBuildException( ex, getLocation());
		 }
	 }
}",0,0,0,0
"public class Project {
	 public static final int MSG_ERR = 0;
	 public static final int MSG_WARN = 1;
	 public static final int MSG_INFO = 2;
	 public static final int MSG_VERBOSE = 3;
	 public static final int MSG_DEBUG = 4;
	 private static final String VISITING = ""VISITING"";
	 private static final String VISITED = ""VISITED"";
	 private static String javaVersion;
	 public static final String JAVA_1_0 = ""1.0"";
	 public static final String JAVA_1_1 = ""1.1"";
	 public static final String JAVA_1_2 = ""1.2"";
	 public static final String JAVA_1_3 = ""1.3"";
	 public static final String TOKEN_START = ""@"";
	 public static final String TOKEN_END = ""@"";
	 private String name;
	 private Hashtable properties = new Hashtable();
	 private Hashtable userProperties = new Hashtable();
	 private Hashtable references = new Hashtable();
	 private String defaultTarget;
	 private Hashtable dataClassDefinitions = new Hashtable();
	 private Hashtable taskClassDefinitions = new Hashtable();
	 private Hashtable targets = new Hashtable();
	 private Hashtable filters = new Hashtable();
	 private File baseDir;
	 private Vector listeners = new Vector();
	 private static java.lang.reflect.Method setLastModified = null;
	 private static Object lockReflection = new Object();
	 static {
		 try {
			 javaVersion = JAVA_1_0;
			 Class.forName(""java.lang.Void"");
			 javaVersion = JAVA_1_1;
			 Class.forName(""java.lang.ThreadLocal"");
			 javaVersion = JAVA_1_2;
			 Class.forName(""java.lang.StrictMath"");
			 javaVersion = JAVA_1_3;
		 }
		 catch (ClassNotFoundException cnfe) {
		 }
	 }
	 public Project() {
	 }
	 public void init() throws BuildException {
		 setJavaVersionProperty();
		 String defs = ""/org/apache/tools/ant/taskdefs/defaults.properties"";
		 try {
			 Properties props = new Properties();
			 InputStream in = this.getClass().getResourceAsStream(defs);
			 if (in == null) {
				 throw new BuildException(""Can't load default task list"");
			 }
			 props.load(in);
			 in.close();
			 Enumeration enum = props.propertyNames();
			 while (enum.hasMoreElements()) {
				 String key = (String) enum.nextElement();
				 String value = props.getProperty(key);
				 try {
					 Class taskClass = Class.forName(value);
					 addTaskDefinition(key, taskClass);
				 }
				 catch (NoClassDefFoundError ncdfe) {
				 }
				 catch (ClassNotFoundException cnfe) {
				 }
			 }
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Can't load default task list"");
		 }
		 String dataDefs = ""/org/apache/tools/ant/types/defaults.properties"";
		 try{
			 Properties props = new Properties();
			 InputStream in = this.getClass().getResourceAsStream(dataDefs);
			 if (in == null) {
				 throw new BuildException(""Can't load default datatype list"");
			 }
			 props.load(in);
			 in.close();
			 Enumeration enum = props.propertyNames();
			 while (enum.hasMoreElements()) {
				 String key = (String) enum.nextElement();
				 String value = props.getProperty(key);
				 try {
					 Class dataClass = Class.forName(value);
					 addDataTypeDefinition(key, dataClass);
				 }
				 catch (NoClassDefFoundError ncdfe) {
				 }
				 catch (ClassNotFoundException cnfe) {
				 }
			 }
		 }
		 catch (IOException ioe) {
			 throw new BuildException(""Can't load default datatype list"");
		 }
		 Properties systemP = System.getProperties();
		 Enumeration e = systemP.keys();
		 while (e.hasMoreElements()) {
			 String name = (String) e.nextElement();
			 String value = (String) systemP.get(name);
			 this.setProperty(name, value);
		 }
	 }
	 public void addBuildListener(BuildListener listener) {
		 listeners.addElement(listener);
	 }
	 public void removeBuildListener(BuildListener listener) {
		 listeners.removeElement(listener);
	 }
	 public Vector getBuildListeners() {
		 return listeners;
	 }
	 public void log(String msg) {
		 log(msg, MSG_INFO);
	 }
	 public void log(String msg, int msgLevel) {
		 fireMessageLogged(this, msg, msgLevel);
	 }
	 public void log(Task task, String msg, int msgLevel) {
		 fireMessageLogged(task, msg, msgLevel);
	 }
	 public void log(Target target, String msg, int msgLevel) {
		 fireMessageLogged(target, msg, msgLevel);
	 }
	 public void setProperty(String name, String value) {
		 if (null != userProperties.get(name)) return;
		 log(""Setting project property: "" + name + "" -> "" + value, MSG_DEBUG);
		 properties.put(name, value);
	 }
	 public void setUserProperty(String name, String value) {
		 log(""Setting ro project property: "" + name + "" -> "" + value, MSG_DEBUG);
		 userProperties.put(name, value);
		 properties.put(name, value);
	 }
	 public String getProperty(String name) {
		 if (name == null) return null;
		 String property = (String) properties.get(name);
		 return property;
	 }
	 public String getUserProperty(String name) {
		 if (name == null) return null;
		 String property = (String) userProperties.get(name);
		 return property;
	 }
	 public Hashtable getProperties() {
		 return properties;
	 }
	 public Hashtable getUserProperties() {
		 return userProperties;
	 }
	 public void setDefaultTarget(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public String getDefaultTarget() {
		 return defaultTarget;
	 }
	 public void setDefault(String defaultTarget) {
		 this.defaultTarget = defaultTarget;
	 }
	 public void setName(String name) {
		 setUserProperty(""ant.project.name"", name);
		 this.name = name;
	 }
	 public String getName() {
		 return name;
	 }
	 public void addFilter(String token, String value) {
		 if (token == null) return;
		 log(""Setting token to filter: "" + token + "" -> "" + value, MSG_DEBUG);
		 this.filters.put(token, value);
	 }
	 public Hashtable getFilters() {
		 return filters;
	 }
	 public void setBasedir(String baseD) throws BuildException {
		 try {
			 setBaseDir(new File(new File(baseD).getCanonicalPath()));
		 }
		 catch (IOException ioe) {
			 String msg = ""Can't set basedir "" + baseD + "" due to "" + ioe.getMessage();
			 throw new BuildException(msg);
		 }
	 }
	 public void setBaseDir(File baseDir) {
		 this.baseDir = baseDir;
		 setProperty( ""basedir"", baseDir.getAbsolutePath());
		 String msg = ""Project base dir set to: "" + baseDir;
		 log(msg, MSG_VERBOSE);
	 }
	 public File getBaseDir() {
		 if (baseDir == null) {
			 try {
				 setBasedir(""."");
			 }
			 catch (BuildException ex) {
				 ex.printStackTrace();
			 }
		 }
		 return baseDir;
	 }
	 public static String getJavaVersion() {
		 return javaVersion;
	 }
	 public void setJavaVersionProperty() {
		 setProperty(""ant.java.version"", javaVersion);
		 if (javaVersion == JAVA_1_0) {
			 throw new BuildException(""Ant cannot work on Java 1.0"");
		 }
		 log(""Detected Java Version: "" + javaVersion, MSG_VERBOSE);
		 log(""Detected OS: "" + System.getProperty(""os.name""), MSG_VERBOSE);
	 }
	 public void addTaskDefinition(String taskName, Class taskClass) {
		 String msg = "" +User task: "" + taskName + "" "" + taskClass.getName();
		 log(msg, MSG_DEBUG);
		 taskClassDefinitions.put(taskName, taskClass);
	 }
	 public Hashtable getTaskDefinitions() {
		 return taskClassDefinitions;
	 }
	 public void addDataTypeDefinition(String typeName, Class typeClass) {
		 String msg = "" +User datatype: "" + typeName + "" "" + typeClass.getName();
		 log(msg, MSG_DEBUG);
		 dataClassDefinitions.put(typeName, typeClass);
	 }
	 public Hashtable getDataTypeDefinitions() {
		 return dataClassDefinitions;
	 }
	 public void addTarget(Target target) {
		 String name = target.getName();
		 if (targets.get(name) != null) {
			 throw new BuildException(""Duplicate target: `""+name+""'"");
		 }
		 addOrReplaceTarget(name, target);
	 }
	 public void addTarget(String targetName, Target target) throws BuildException {
		 if (targets.get(targetName) != null) {
			 throw new BuildException(""Duplicate target: `""+targetName+""'"");
		 }
		 addOrReplaceTarget(targetName, target);
	 }
	 public void addOrReplaceTarget(Target target) {
		 addOrReplaceTarget(target.getName(), target);
	 }
	 public void addOrReplaceTarget(String targetName, Target target) {
		 String msg = "" +Target: "" + targetName;
		 log(msg, MSG_DEBUG);
		 target.setProject(this);
		 targets.put(targetName, target);
	 }
	 public Hashtable getTargets() {
		 return targets;
	 }
	 public Task createTask(String taskType) throws BuildException {
		 Class c = (Class) taskClassDefinitions.get(taskType);
		 if (c == null) return null;
		 try {
			 Object o = c.newInstance();
			 Task task = null;
			 if( o instanceof Task ) {
				 task=(Task)o;
			 }
			 else {
				 TaskAdapter taskA=new TaskAdapter();
				 taskA.setProxy( o );
				 task=taskA;
			 }
			 task.setProject(this);
			 task.setTaskType(taskType);
			 task.setTaskName(taskType);
			 String msg = "" +Task: "" + taskType;
			 log (msg, MSG_DEBUG);
			 return task;
		 }
		 catch (Throwable t) {
			 String msg = ""Could not create task of type: "" + taskType + "" due to "" + t;
			 throw new BuildException(msg, t);
		 }
	 }
	 public Object createDataType(String typeName) throws BuildException {
		 Class c = (Class) dataClassDefinitions.get(typeName);
		 if (c == null) return null;
		 try {
			 java.lang.reflect.Constructor ctor = null;
			 boolean noArg = false;
			 try {
				 ctor = c.getConstructor(new Class[0]);
				 noArg = true;
			 }
			 catch (NoSuchMethodException nse) {
				 ctor = c.getConstructor(new Class[] {
				getClass()}
				);
				 noArg = false;
			 }
			 Object o = null;
			 if (noArg) {
				 o = ctor.newInstance(new Object[0]);
			 }
			 else {
				 o = ctor.newInstance(new Object[] {
				this}
				);
			 }
			 String msg = "" +DataType: "" + typeName;
			 log (msg, MSG_DEBUG);
			 return o;
		 }
		 catch (java.lang.reflect.InvocationTargetException ite) {
			 Throwable t = ite.getTargetException();
			 String msg = ""Could not create datatype of type: "" + typeName + "" due to "" + t;
			 throw new BuildException(msg, t);
		 }
		 catch (Throwable t) {
			 String msg = ""Could not create datatype of type: "" + typeName + "" due to "" + t;
			 throw new BuildException(msg, t);
		 }
	 }
	 public void executeTargets(Vector targetNames) throws BuildException {
		 Throwable error = null;
		 for (int i = 0;
		 i < targetNames.size();
		 i++) {
			 executeTarget((String)targetNames.elementAt(i));
		 }
	 }
	 public void executeTarget(String targetName) throws BuildException {
		 if (targetName == null) {
			 String msg = ""No target specified"";
			 throw new BuildException(msg);
		 }
		 Vector sortedTargets = topoSort(targetName, targets);
		 int curidx = 0;
		 Target curtarget;
		 do {
			 curtarget = (Target) sortedTargets.elementAt(curidx++);
			 runTarget(curtarget);
		 }
		 while (!curtarget.getName().equals(targetName));
	 }
	 public File resolveFile(String fileName) {
		 fileName = fileName.replace('/', File.separatorChar).replace('\\', File.separatorChar);
		 if (fileName.startsWith(File.separator)) {
			 try {
				 return new File(new File(fileName).getCanonicalPath());
			 }
			 catch (IOException e) {
				 log(""IOException getting canonical path for "" + fileName + "": "" + e.getMessage(), MSG_ERR);
				 return new File(fileName);
			 }
		 }
		 if (fileName.length() >= 2 && Character.isLetter(fileName.charAt(0)) && fileName.charAt(1) == ':') {
			 char[] ca = fileName.replace('/', '\\').toCharArray();
			 char c;
			 StringBuffer sb = new StringBuffer();
			 for (int i = 0;
			 i < ca.length;
			 i++) {
				 if ((ca[i] != '\\') || (ca[i] == '\\' && i > 0 && ca[i - 1] != '\\')) {
					 if (i == 0 && Character.isLetter(ca[i]) && i < ca.length - 1 && ca[i + 1] == ':') {
						 c = Character.toUpperCase(ca[i]);
					 }
					 else {
						 c = ca[i];
					 }
					 sb.append(c);
				 }
			 }
			 return new File(sb.toString());
		 }
		 File file = new File(baseDir.getAbsolutePath());
		 StringTokenizer tok = new StringTokenizer(fileName, File.separator, false);
		 while (tok.hasMoreTokens()) {
			 String part = tok.nextToken();
			 if (part.equals("".."")) {
				 String parentFile = file.getParent();
				 if (parentFile == null) {
					 throw new BuildException(""The file or path you specified ("" + fileName + "") is invalid releative to "" + baseDir.getAbsolutePath());
				 }
				 file = new File(parentFile);
			 }
			 else if (part.equals(""."")) {
			 }
			 else {
				 file = new File(file, part);
			 }
		 }
		 try {
			 return new File(file.getCanonicalPath());
		 }
		 catch (IOException e) {
			 log(""IOException getting canonical path for "" + file + "": "" + e.getMessage(), MSG_ERR);
			 return new File(file.getAbsolutePath());
		 }
	 }
	 static public String translatePath(String to_process) {
		 if ( to_process == null || to_process.length() == 0 ) {
			 return """";
		 }
		 StringBuffer path = new StringBuffer(to_process.length() + 50);
		 PathTokenizer tokenizer = new PathTokenizer(to_process);
		 while (tokenizer.hasMoreTokens()) {
			 String pathComponent = tokenizer.nextToken();
			 pathComponent = pathComponent.replace('/', File.separatorChar);
			 pathComponent = pathComponent.replace('\\', File.separatorChar);
			 if (path.length() != 0) {
				 path.append(File.pathSeparatorChar);
			 }
			 path.append(pathComponent);
		 }
		 return path.toString();
	 }
	 public void copyFile(String sourceFile, String destFile) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), false);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filtering);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filtering, overwrite);
	 }
	 public void copyFile(String sourceFile, String destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 copyFile(new File(sourceFile), new File(destFile), filtering, overwrite, preserveLastModified);
	 }
	 public void copyFile(File sourceFile, File destFile) throws IOException {
		 copyFile(sourceFile, destFile, false);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering) throws IOException {
		 copyFile(sourceFile, destFile, filtering, false);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite) throws IOException {
		 copyFile(sourceFile, destFile, filtering, overwrite, false);
	 }
	 public void copyFile(File sourceFile, File destFile, boolean filtering, boolean overwrite, boolean preserveLastModified) throws IOException {
		 if (overwrite || destFile.lastModified() < sourceFile.lastModified()) {
			 log(""Copy: "" + sourceFile.getAbsolutePath() + "" -> "" + destFile.getAbsolutePath(), MSG_VERBOSE);
			 File parent = new File(destFile.getParent());
			 if (!parent.exists()) {
				 parent.mkdirs();
			 }
			 if (filtering) {
				 BufferedReader in = new BufferedReader(new FileReader(sourceFile));
				 BufferedWriter out = new BufferedWriter(new FileWriter(destFile));
				 int length;
				 String newline = null;
				 String line = in.readLine();
				 while (line != null) {
					 if (line.length() == 0) {
						 out.newLine();
					 }
					 else {
						 newline = replace(line, filters);
						 out.write(newline);
						 out.newLine();
					 }
					 line = in.readLine();
				 }
				 out.close();
				 in.close();
			 }
			 else {
				 FileInputStream in = new FileInputStream(sourceFile);
				 FileOutputStream out = new FileOutputStream(destFile);
				 byte[] buffer = new byte[8 * 1024];
				 int count = 0;
				 do {
					 out.write(buffer, 0, count);
					 count = in.read(buffer, 0, buffer.length);
				 }
				 while (count != -1);
				 in.close();
				 out.close();
			 }
			 if (preserveLastModified) {
				 setFileLastModified(destFile, sourceFile.lastModified());
			 }
		 }
	 }
	 void setFileLastModified(File file, long time) throws BuildException {
		 if (getJavaVersion() == JAVA_1_1) {
			 log(""Cannot change the modification time of "" + file + "" in JDK 1.1"", Project.MSG_WARN);
			 return;
		 }
		 if (setLastModified == null) {
			 synchronized (lockReflection) {
				 if (setLastModified == null) {
					 try {
						 setLastModified = java.io.File.class.getMethod(""setLastModified"", new Class[] {
						Long.TYPE}
						);
					 }
					 catch (NoSuchMethodException nse) {
						 throw new BuildException(""File.setlastModified not in JDK > 1.1?"", nse);
					 }
				 }
			 }
		 }
		 Long[] times = new Long[1];
		 if (time < 0) {
			 times[0] = new Long(System.currentTimeMillis());
		 }
		 else {
			 times[0] = new Long(time);
		 }
		 try {
			 log(""Setting modification time for "" + file, MSG_VERBOSE);
			 setLastModified.invoke(file, times);
		 }
		 catch (java.lang.reflect.InvocationTargetException ite) {
			 Throwable nested = ite.getTargetException();
			 throw new BuildException(""Exception setting the modification time "" + ""of "" + file, nested);
		 }
		 catch (Throwable other) {
			 throw new BuildException(""Exception setting the modification time "" + ""of "" + file, other);
		 }
	 }
	 private String replace(String s, Hashtable tokens) {
		 int index = s.indexOf(TOKEN_START);
		 if (index > -1) {
			 try {
				 StringBuffer b = new StringBuffer();
				 int i = 0;
				 String token = null;
				 String value = null;
				 do {
					 int endIndex = s.indexOf(TOKEN_END, index + TOKEN_START.length() + 1);
					 if (endIndex == -1) {
						 break;
					 }
					 token = s.substring(index + TOKEN_START.length(), endIndex);
					 b.append(s.substring(i, index));
					 if (tokens.containsKey(token)) {
						 value = (String) tokens.get(token);
						 log(""Replacing: "" + TOKEN_START + token + TOKEN_END + "" -> "" + value, MSG_VERBOSE);
						 b.append(value);
						 i = index + TOKEN_START.length() + token.length() + TOKEN_END.length();
					 }
					 else {
						 b.append(TOKEN_START);
						 i = index + TOKEN_START.length();
					 }
				 }
				 while ((index = s.indexOf(TOKEN_START, i)) > -1);
				 b.append(s.substring(i));
				 return b.toString();
			 }
			 catch (StringIndexOutOfBoundsException e) {
				 return s;
			 }
		 }
		 else {
			 return s;
		 }
	 }
	 public static boolean toBoolean(String s) {
		 return (s.equalsIgnoreCase(""on"") || s.equalsIgnoreCase(""true"") || s.equalsIgnoreCase(""yes""));
	 }
	 public void runTarget(Target target) throws BuildException {
		 try {
			 fireTargetStarted(target);
			 target.execute();
			 fireTargetFinished(target, null);
		 }
		 catch(RuntimeException exc) {
			 fireTargetFinished(target, exc);
			 throw exc;
		 }
	 }
	 public final Vector topoSort(String root, Hashtable targets) throws BuildException {
		 Vector ret = new Vector();
		 Hashtable state = new Hashtable();
		 Stack visiting = new Stack();
		 tsort(root, targets, state, visiting, ret);
		 log(""Build sequence for target `""+root+""' is ""+ret, MSG_VERBOSE);
		 for (Enumeration en=targets.keys();
		 en.hasMoreElements();
		) {
			 String curTarget = (String)(en.nextElement());
			 String st = (String) state.get(curTarget);
			 if (st == null) {
				 tsort(curTarget, targets, state, visiting, ret);
			 }
			 else if (st == VISITING) {
				 throw new RuntimeException(""Unexpected node in visiting state: ""+curTarget);
			 }
		 }
		 log(""Complete build sequence is ""+ret, MSG_VERBOSE);
		 return ret;
	 }
	 private final void tsort(String root, Hashtable targets, Hashtable state, Stack visiting, Vector ret) throws BuildException {
		 state.put(root, VISITING);
		 visiting.push(root);
		 Target target = (Target)(targets.get(root));
		 if (target == null) {
			 StringBuffer sb = new StringBuffer(""Target `"");
			 sb.append(root);
			 sb.append(""' does not exist in this project. "");
			 visiting.pop();
			 if (!visiting.empty()) {
				 String parent = (String)visiting.peek();
				 sb.append(""It is used from target `"");
				 sb.append(parent);
				 sb.append(""'."");
			 }
			 throw new BuildException(new String(sb));
		 }
		 for (Enumeration en=target.getDependencies();
		 en.hasMoreElements();
		) {
			 String cur = (String) en.nextElement();
			 String m=(String)state.get(cur);
			 if (m == null) {
				 tsort(cur, targets, state, visiting, ret);
			 }
			 else if (m == VISITING) {
				 throw makeCircularException(cur, visiting);
			 }
		 }
		 String p = (String) visiting.pop();
		 if (root != p) {
			 throw new RuntimeException(""Unexpected internal error: expected to pop ""+root+"" but got ""+p);
		 }
		 state.put(root, VISITED);
		 ret.addElement(target);
	 }
	 private static BuildException makeCircularException(String end, Stack stk) {
		 StringBuffer sb = new StringBuffer(""Circular dependency: "");
		 sb.append(end);
		 String c;
		 do {
			 c = (String)stk.pop();
			 sb.append("" <- "");
			 sb.append(c);
		 }
		 while(!c.equals(end));
		 return new BuildException(new String(sb));
	 }
	 public void addReference(String name, Object value) {
		 references.put(name,value);
	 }
	 public Hashtable getReferences() {
		 return references;
	 }
	 protected void fireBuildStarted() {
		 BuildEvent event = new BuildEvent(this);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.buildStarted(event);
		 }
	 }
	 protected void fireBuildFinished(Throwable exception) {
		 BuildEvent event = new BuildEvent(this);
		 event.setException(exception);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.buildFinished(event);
		 }
	 }
	 protected void fireTargetStarted(Target target) {
		 BuildEvent event = new BuildEvent(target);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.targetStarted(event);
		 }
	 }
	 protected void fireTargetFinished(Target target, Throwable exception) {
		 BuildEvent event = new BuildEvent(target);
		 event.setException(exception);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.targetFinished(event);
		 }
	 }
	 protected void fireTaskStarted(Task task) {
		 BuildEvent event = new BuildEvent(task);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.taskStarted(event);
		 }
	 }
	 protected void fireTaskFinished(Task task, Throwable exception) {
		 BuildEvent event = new BuildEvent(task);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.taskFinished(event);
		 }
	 }
	 private void fireMessageLoggedEvent(BuildEvent event, String message, int priority) {
		 event.setMessage(message, priority);
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 BuildListener listener = (BuildListener) listeners.elementAt(i);
			 listener.messageLogged(event);
		 }
	 }
	 protected void fireMessageLogged(Project project, String message, int priority) {
		 BuildEvent event = new BuildEvent(project);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Target target, String message, int priority) {
		 BuildEvent event = new BuildEvent(target);
		 fireMessageLoggedEvent(event, message, priority);
	 }
	 protected void fireMessageLogged(Task task, String message, int priority) {
		 BuildEvent event = new BuildEvent(task);
		 fireMessageLoggedEvent(event, message, priority);
	 }
}",1,0,0,0
"final class NativeDate extends IdScriptableObject{
	 static final long serialVersionUID = -8307438915861678966L;
	 private static final Object DATE_TAG = new Object();
	 private static final String js_NaN_date_str = ""Invalid Date"";
	 static void init(Scriptable scope, boolean sealed) {
		 NativeDate obj = new NativeDate();
		 obj.date = ScriptRuntime.NaN;
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeDate() {
		 if (thisTimeZone == null) {
			 thisTimeZone = java.util.TimeZone.getDefault();
			 LocalTZA = thisTimeZone.getRawOffset();
		 }
	 }
	 public String getClassName() {
		 return ""Date"";
	 }
	 public Object getDefaultValue(Class typeHint) {
		 if (typeHint == null) typeHint = ScriptRuntime.StringClass;
		 return super.getDefaultValue(typeHint);
	 }
	 double getJSTimeValue() {
		 return date;
	 }
	 protected void fillConstructorProperties(IdFunctionObject ctor) {
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_now, ""now"", 0);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_parse, ""parse"", 1);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_UTC, ""UTC"", 1);
		 super.fillConstructorProperties(ctor);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toTimeString: arity=0;
			 s=""toTimeString"";
			 break;
			 case Id_toDateString: arity=0;
			 s=""toDateString"";
			 break;
			 case Id_toLocaleString: arity=0;
			 s=""toLocaleString"";
			 break;
			 case Id_toLocaleTimeString: arity=0;
			 s=""toLocaleTimeString"";
			 break;
			 case Id_toLocaleDateString: arity=0;
			 s=""toLocaleDateString"";
			 break;
			 case Id_toUTCString: arity=0;
			 s=""toUTCString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_valueOf: arity=0;
			 s=""valueOf"";
			 break;
			 case Id_getTime: arity=0;
			 s=""getTime"";
			 break;
			 case Id_getYear: arity=0;
			 s=""getYear"";
			 break;
			 case Id_getFullYear: arity=0;
			 s=""getFullYear"";
			 break;
			 case Id_getUTCFullYear: arity=0;
			 s=""getUTCFullYear"";
			 break;
			 case Id_getMonth: arity=0;
			 s=""getMonth"";
			 break;
			 case Id_getUTCMonth: arity=0;
			 s=""getUTCMonth"";
			 break;
			 case Id_getDate: arity=0;
			 s=""getDate"";
			 break;
			 case Id_getUTCDate: arity=0;
			 s=""getUTCDate"";
			 break;
			 case Id_getDay: arity=0;
			 s=""getDay"";
			 break;
			 case Id_getUTCDay: arity=0;
			 s=""getUTCDay"";
			 break;
			 case Id_getHours: arity=0;
			 s=""getHours"";
			 break;
			 case Id_getUTCHours: arity=0;
			 s=""getUTCHours"";
			 break;
			 case Id_getMinutes: arity=0;
			 s=""getMinutes"";
			 break;
			 case Id_getUTCMinutes: arity=0;
			 s=""getUTCMinutes"";
			 break;
			 case Id_getSeconds: arity=0;
			 s=""getSeconds"";
			 break;
			 case Id_getUTCSeconds: arity=0;
			 s=""getUTCSeconds"";
			 break;
			 case Id_getMilliseconds: arity=0;
			 s=""getMilliseconds"";
			 break;
			 case Id_getUTCMilliseconds: arity=0;
			 s=""getUTCMilliseconds"";
			 break;
			 case Id_getTimezoneOffset: arity=0;
			 s=""getTimezoneOffset"";
			 break;
			 case Id_setTime: arity=1;
			 s=""setTime"";
			 break;
			 case Id_setMilliseconds: arity=1;
			 s=""setMilliseconds"";
			 break;
			 case Id_setUTCMilliseconds: arity=1;
			 s=""setUTCMilliseconds"";
			 break;
			 case Id_setSeconds: arity=2;
			 s=""setSeconds"";
			 break;
			 case Id_setUTCSeconds: arity=2;
			 s=""setUTCSeconds"";
			 break;
			 case Id_setMinutes: arity=3;
			 s=""setMinutes"";
			 break;
			 case Id_setUTCMinutes: arity=3;
			 s=""setUTCMinutes"";
			 break;
			 case Id_setHours: arity=4;
			 s=""setHours"";
			 break;
			 case Id_setUTCHours: arity=4;
			 s=""setUTCHours"";
			 break;
			 case Id_setDate: arity=1;
			 s=""setDate"";
			 break;
			 case Id_setUTCDate: arity=1;
			 s=""setUTCDate"";
			 break;
			 case Id_setMonth: arity=2;
			 s=""setMonth"";
			 break;
			 case Id_setUTCMonth: arity=2;
			 s=""setUTCMonth"";
			 break;
			 case Id_setFullYear: arity=3;
			 s=""setFullYear"";
			 break;
			 case Id_setUTCFullYear: arity=3;
			 s=""setUTCFullYear"";
			 break;
			 case Id_setYear: arity=1;
			 s=""setYear"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(DATE_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(DATE_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case ConstructorId_now: return ScriptRuntime.wrapNumber(now());
			 case ConstructorId_parse: {
				 String dataStr = ScriptRuntime.toString(args, 0);
				 return ScriptRuntime.wrapNumber(date_parseString(dataStr));
			 }
			 case ConstructorId_UTC: return ScriptRuntime.wrapNumber(jsStaticFunction_UTC(args));
			 case Id_constructor: {
				 if (thisObj != null) return date_format(now(), Id_toString);
				 return jsConstructor(args);
			 }
		 }
		 if (!(thisObj instanceof NativeDate)) throw incompatibleCallError(f);
		 NativeDate realThis = (NativeDate)thisObj;
		 double t = realThis.date;
		 switch (id) {
			 case Id_toString: case Id_toTimeString: case Id_toDateString: if (t == t) {
				 return date_format(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toLocaleString: case Id_toLocaleTimeString: case Id_toLocaleDateString: if (t == t) {
				 return toLocale_helper(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toUTCString: if (t == t) {
				 return js_toUTCString(t);
			 }
			 return js_NaN_date_str;
			 case Id_toSource: return ""(new Date(""+ScriptRuntime.toString(t)+""))"";
			 case Id_valueOf: case Id_getTime: return ScriptRuntime.wrapNumber(t);
			 case Id_getYear: case Id_getFullYear: case Id_getUTCFullYear: if (t == t) {
				 if (id != Id_getUTCFullYear) t = LocalTime(t);
				 t = YearFromTime(t);
				 if (id == Id_getYear) {
					 if (cx.hasFeature(Context.FEATURE_NON_ECMA_GET_YEAR)) {
						 if (1900 <= t && t < 2000) {
							 t -= 1900;
						 }
					 }
					 else {
						 t -= 1900;
					 }
				 }
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMonth: case Id_getUTCMonth: if (t == t) {
				 if (id == Id_getMonth) t = LocalTime(t);
				 t = MonthFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDate: case Id_getUTCDate: if (t == t) {
				 if (id == Id_getDate) t = LocalTime(t);
				 t = DateFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDay: case Id_getUTCDay: if (t == t) {
				 if (id == Id_getDay) t = LocalTime(t);
				 t = WeekDay(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getHours: case Id_getUTCHours: if (t == t) {
				 if (id == Id_getHours) t = LocalTime(t);
				 t = HourFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMinutes: case Id_getUTCMinutes: if (t == t) {
				 if (id == Id_getMinutes) t = LocalTime(t);
				 t = MinFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getSeconds: case Id_getUTCSeconds: if (t == t) {
				 if (id == Id_getSeconds) t = LocalTime(t);
				 t = SecFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMilliseconds: case Id_getUTCMilliseconds: if (t == t) {
				 if (id == Id_getMilliseconds) t = LocalTime(t);
				 t = msFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getTimezoneOffset: if (t == t) {
				 t = (t - LocalTime(t)) / msPerMinute;
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setTime: t = TimeClip(ScriptRuntime.toNumber(args, 0));
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setMilliseconds: case Id_setUTCMilliseconds: case Id_setSeconds: case Id_setUTCSeconds: case Id_setMinutes: case Id_setUTCMinutes: case Id_setHours: case Id_setUTCHours: t = makeTime(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setDate: case Id_setUTCDate: case Id_setMonth: case Id_setUTCMonth: case Id_setFullYear: case Id_setUTCFullYear: t = makeDate(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setYear: {
				 double year = ScriptRuntime.toNumber(args, 0);
				 if (year != year || Double.isInfinite(year)) {
					 t = ScriptRuntime.NaN;
				 }
				 else {
					 if (t != t) {
						 t = 0;
					 }
					 else {
						 t = LocalTime(t);
					 }
					 if (year >= 0 && year <= 99) year += 1900;
					 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
					 t = MakeDate(day, TimeWithinDay(t));
					 t = internalUTC(t);
					 t = TimeClip(t);
				 }
			 }
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
	 }
	 private static final double HalfTimeDomain = 8.64e15;
	 private static final double HoursPerDay = 24.0;
	 private static final double MinutesPerHour = 60.0;
	 private static final double SecondsPerMinute = 60.0;
	 private static final double msPerSecond = 1000.0;
	 private static final double MinutesPerDay = (HoursPerDay * MinutesPerHour);
	 private static final double SecondsPerDay = (MinutesPerDay * SecondsPerMinute);
	 private static final double SecondsPerHour = (MinutesPerHour * SecondsPerMinute);
	 private static final double msPerDay = (SecondsPerDay * msPerSecond);
	 private static final double msPerHour = (SecondsPerHour * msPerSecond);
	 private static final double msPerMinute = (SecondsPerMinute * msPerSecond);
	 private static double Day(double t) {
		 return Math.floor(t / msPerDay);
	 }
	 private static double TimeWithinDay(double t) {
		 double result;
		 result = t % msPerDay;
		 if (result < 0) result += msPerDay;
		 return result;
	 }
	 private static boolean IsLeapYear(int year) {
		 return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
	 }
	 private static double DayFromYear(double y) {
		 return ((365 * ((y)-1970) + Math.floor(((y)-1969)/4.0) - Math.floor(((y)-1901)/100.0) + Math.floor(((y)-1601)/400.0)));
	 }
	 private static double TimeFromYear(double y) {
		 return DayFromYear(y) * msPerDay;
	 }
	 private static int YearFromTime(double t) {
		 int lo = (int) Math.floor((t / msPerDay) / 366) + 1970;
		 int hi = (int) Math.floor((t / msPerDay) / 365) + 1970;
		 int mid;
		 if (hi < lo) {
			 int temp = lo;
			 lo = hi;
			 hi = temp;
		 }
		 while (hi > lo) {
			 mid = (hi + lo) / 2;
			 if (TimeFromYear(mid) > t) {
				 hi = mid - 1;
			 }
			 else {
				 lo = mid + 1;
				 if (TimeFromYear(lo) > t) {
					 return mid;
				 }
			 }
		 }
		 return lo;
	 }
	 private static boolean InLeapYear(double t) {
		 return IsLeapYear(YearFromTime(t));
	 }
	 private static double DayFromMonth(int m, int year) {
		 int day = m * 30;
		 if (m >= 7) {
			 day += m / 2 - 1;
		 }
		 else if (m >= 2) {
			 day += (m - 1) / 2 - 1;
		 }
		 else {
			 day += m;
		 }
		 if (m >= 2 && IsLeapYear(year)) {
			 ++day;
		 }
		 return day;
	 }
	 private static int MonthFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? 0 : 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 1;
			 --d;
		 }
		 int estimate = d / 30;
		 int mstart;
		 switch (estimate) {
			 case 0: return 2;
			 case 1: mstart = 31;
			 break;
			 case 2: mstart = 31+30;
			 break;
			 case 3: mstart = 31+30+31;
			 break;
			 case 4: mstart = 31+30+31+30;
			 break;
			 case 5: mstart = 31+30+31+30+31;
			 break;
			 case 6: mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return 11;
			 default: throw Kit.codeBug();
		 }
		 return (d >= mstart) ? estimate + 2 : estimate + 1;
	 }
	 private static int DateFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? d + 31 + 28 + 1 : d + 28 + 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 29;
			 --d;
		 }
		 int mdays, mstart;
		 switch (d / 30) {
			 case 0: return d + 1;
			 case 1: mdays = 31;
			 mstart = 31;
			 break;
			 case 2: mdays = 30;
			 mstart = 31+30;
			 break;
			 case 3: mdays = 31;
			 mstart = 31+30+31;
			 break;
			 case 4: mdays = 30;
			 mstart = 31+30+31+30;
			 break;
			 case 5: mdays = 31;
			 mstart = 31+30+31+30+31;
			 break;
			 case 6: mdays = 31;
			 mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mdays = 30;
			 mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mdays = 31;
			 mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mdays = 30;
			 mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return d - (31+30+31+30+31+31+30+31+30) + 1;
			 default: throw Kit.codeBug();
		 }
		 d -= mstart;
		 if (d < 0) {
			 d += mdays;
		 }
		 return d + 1;
	 }
	 private static int WeekDay(double t) {
		 double result;
		 result = Day(t) + 4;
		 result = result % 7;
		 if (result < 0) result += 7;
		 return (int) result;
	 }
	 private static double now() {
		 return (double) System.currentTimeMillis();
	 }
	 private final static boolean TZO_WORKAROUND = false;
	 private static double DaylightSavingTA(double t) {
		 if (t < 0.0 || t > 2145916800000.0) {
			 int year = EquivalentYear(YearFromTime(t));
			 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
			 t = MakeDate(day, TimeWithinDay(t));
		 }
		 if (!TZO_WORKAROUND) {
			 Date date = new Date((long) t);
			 if (thisTimeZone.inDaylightTime(date)) return msPerHour;
			 else return 0;
		 }
		 else {
			 t += LocalTZA + (HourFromTime(t) <= 2 ? msPerHour : 0);
			 int year = YearFromTime(t);
			 double offset = thisTimeZone.getOffset(year > 0 ? 1 : 0, year, MonthFromTime(t), DateFromTime(t), WeekDay(t), (int)TimeWithinDay(t));
			 if ((offset - LocalTZA) != 0) return msPerHour;
			 else return 0;
		 }
	 }
	 private static int EquivalentYear(int year) {
		 int day = (int) DayFromYear(year) + 4;
		 day = day % 7;
		 if (day < 0) day += 7;
		 if (IsLeapYear(year)) {
			 switch (day) {
				 case 0: return 1984;
				 case 1: return 1996;
				 case 2: return 1980;
				 case 3: return 1992;
				 case 4: return 1976;
				 case 5: return 1988;
				 case 6: return 1972;
			 }
		 }
		 else {
			 switch (day) {
				 case 0: return 1978;
				 case 1: return 1973;
				 case 2: return 1974;
				 case 3: return 1975;
				 case 4: return 1981;
				 case 5: return 1971;
				 case 6: return 1977;
			 }
		 }
		 throw Kit.codeBug();
	 }
	 private static double LocalTime(double t) {
		 return t + LocalTZA + DaylightSavingTA(t);
	 }
	 private static double internalUTC(double t) {
		 return t - LocalTZA - DaylightSavingTA(t - LocalTZA);
	 }
	 private static int HourFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerHour) % HoursPerDay;
		 if (result < 0) result += HoursPerDay;
		 return (int) result;
	 }
	 private static int MinFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerMinute) % MinutesPerHour;
		 if (result < 0) result += MinutesPerHour;
		 return (int) result;
	 }
	 private static int SecFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerSecond) % SecondsPerMinute;
		 if (result < 0) result += SecondsPerMinute;
		 return (int) result;
	 }
	 private static int msFromTime(double t) {
		 double result;
		 result = t % msPerSecond;
		 if (result < 0) result += msPerSecond;
		 return (int) result;
	 }
	 private static double MakeTime(double hour, double min, double sec, double ms) {
	 return ((hour * MinutesPerHour + min) * SecondsPerMinute + sec) }
	 private static double MakeDay(double year, double month, double date) {
		 year += Math.floor(month / 12);
		 month = month % 12;
		 if (month < 0) month += 12;
		 double yearday = Math.floor(TimeFromYear(year) / msPerDay);
		 double monthday = DayFromMonth((int)month, (int)year);
		 return yearday + monthday + date - 1;
	 }
	 private static double MakeDate(double day, double time) {
		 return day * msPerDay + time;
	 }
	 private static double TimeClip(double d) {
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY || Math.abs(d) > HalfTimeDomain) {
			 return ScriptRuntime.NaN;
		 }
		 if (d > 0.0) return Math.floor(d + 0.);
		 else return Math.ceil(d + 0.);
	 }
	 private static double date_msecFromDate(double year, double mon, double mday, double hour, double min, double sec, double msec) {
		 double day;
		 double time;
		 double result;
		 day = MakeDay(year, mon, mday);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(day, time);
		 return result;
	 }
	 private static final int MAXARGS = 7;
	 private static double jsStaticFunction_UTC(Object[] args) {
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 return ScriptRuntime.NaN;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 array[loop] = 0;
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 if (array[2] < 1) array[2] = 1;
		 d = date_msecFromDate(array[0], array[1], array[2], array[3], array[4], array[5], array[6]);
		 d = TimeClip(d);
		 return d;
	 }
	 private static double date_parseString(String s) {
		 int year = -1;
		 int mon = -1;
		 int mday = -1;
		 int hour = -1;
		 int min = -1;
		 int sec = -1;
		 char c = 0;
		 char si = 0;
		 int i = 0;
		 int n = -1;
		 double tzoffset = -1;
		 char prevc = 0;
		 int limit = 0;
		 boolean seenplusminus = false;
		 limit = s.length();
		 while (i < limit) {
			 c = s.charAt(i);
			 i++;
			 if (c <= ' ' || c == ',' || c == '-') {
				 if (i < limit) {
					 si = s.charAt(i);
					 if (c == '-' && '0' <= si && si <= '9') {
						 prevc = c;
					 }
				 }
				 continue;
			 }
			 if (c == '(') {
				 int depth = 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 i++;
					 if (c == '(') depth++;
					 else if (c == ')') if (--depth <= 0) break;
				 }
				 continue;
			 }
			 if ('0' <= c && c <= '9') {
				 n = c - '0';
				 while (i < limit && '0' <= (c = s.charAt(i)) && c <= '9') {
					 n = n * 10 + c - '0';
					 i++;
				 }
				 if ((prevc == '+' || prevc == '-')) {
					 seenplusminus = true;
					 if (n < 24) n = n * 60;
					 else n = n % 100 + n / 100 * 60;
					 if (prevc == '+') n = -n;
					 if (tzoffset != 0 && tzoffset != -1) return ScriptRuntime.NaN;
					 tzoffset = n;
				 }
				 else if (n >= 70 || (prevc == '/' && mon >= 0 && mday >= 0 && year < 0)) {
					 if (year >= 0) return ScriptRuntime.NaN;
					 else if (c <= ' ' || c == ',' || c == '/' || i >= limit) year = n < 100 ? n + 1900 : n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == ':') {
					 if (hour < 0) hour = n;
					 else if (min < 0) min = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == '/') {
					 if (mon < 0) mon = n-1;
					 else if (mday < 0) mday = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (i < limit && c != ',' && c > ' ' && c != '-') {
					 return ScriptRuntime.NaN;
				 }
				 else if (seenplusminus && n < 60) {
					 if (tzoffset < 0) tzoffset -= n;
					 else tzoffset += n;
				 }
				 else if (hour >= 0 && min < 0) {
					 min = n;
				 }
				 else if (min >= 0 && sec < 0) {
					 sec = n;
				 }
				 else if (mday < 0) {
					 mday = n;
				 }
				 else {
					 return ScriptRuntime.NaN;
				 }
				 prevc = 0;
			 }
			 else if (c == '/' || c == ':' || c == '+' || c == '-') {
				 prevc = c;
			 }
			 else {
				 int st = i - 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 if (!(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))) break;
					 i++;
				 }
				 int letterCount = i - st;
				 if (letterCount < 2) return ScriptRuntime.NaN;
				 String wtb = ""am;
				pm;
				"" +""monday;
				tuesday;
				wednesday;
				thursday;
				friday;
				"" +""saturday;
				sunday;
				"" +""january;
				february;
				march;
				april;
				may;
				june;
				"" +""july;
				august;
				september;
				october;
				november;
				december;
				"" +""gmt;
				ut;
				utc;
				est;
				edt;
				cst;
				cdt;
				mst;
				mdt;
				pst;
				pdt;
				"";
				 int index = 0;
				 for (int wtbOffset = 0;
				 ;
				) {
					 int wtbNext = wtb.indexOf(';
					', wtbOffset);
					 if (wtbNext < 0) return ScriptRuntime.NaN;
					 if (wtb.regionMatches(true, wtbOffset, s, st, letterCount)) break;
					 wtbOffset = wtbNext + 1;
					 ++index;
				 }
				 if (index < 2) {
					 if (hour > 12 || hour < 0) {
						 return ScriptRuntime.NaN;
					 }
					 else if (index == 0) {
						 if (hour == 12) hour = 0;
					 }
					 else {
						 if (hour != 12) hour += 12;
					 }
				 }
				 else if ((index -= 2) < 7) {
				 }
				 else if ((index -= 7) < 12) {
					 if (mon < 0) {
						 mon = index;
					 }
					 else {
						 return ScriptRuntime.NaN;
					 }
				 }
				 else {
					 index -= 12;
					 switch (index) {
						 case 0 : tzoffset = 0;
						 break;
						 case 1 : tzoffset = 0;
						 break;
						 case 2 : tzoffset = 0;
						 break;
						 case 3 : tzoffset = 5 * 60;
						 break;
						 case 4 : tzoffset = 4 * 60;
						 break;
						 case 5 : tzoffset = 6 * 60;
						 break;
						 case 6 : tzoffset = 5 * 60;
						 break;
						 case 7 : tzoffset = 7 * 60;
						 break;
						 case 8 : tzoffset = 6 * 60;
						 break;
						 case 9 : tzoffset = 8 * 60;
						 break;
						 case 10 :tzoffset = 7 * 60;
						 break;
						 default: Kit.codeBug();
					 }
				 }
			 }
		 }
		 if (year < 0 || mon < 0 || mday < 0) return ScriptRuntime.NaN;
		 if (sec < 0) sec = 0;
		 if (min < 0) min = 0;
		 if (hour < 0) hour = 0;
		 double msec = date_msecFromDate(year, mon, mday, hour, min, sec, 0);
		 if (tzoffset == -1) {
			 return internalUTC(msec);
		 }
		 else {
			 return msec + tzoffset * msPerMinute;
		 }
	 }
	 private static String date_format(double t, int methodId) {
		 StringBuffer result = new StringBuffer(60);
		 double local = LocalTime(t);
		 if (methodId != Id_toTimeString) {
			 appendWeekDayName(result, WeekDay(local));
			 result.append(' ');
			 appendMonthName(result, MonthFromTime(local));
			 result.append(' ');
			 append0PaddedUint(result, DateFromTime(local), 2);
			 result.append(' ');
			 int year = YearFromTime(local);
			 if (year < 0) {
				 result.append('-');
				 year = -year;
			 }
			 append0PaddedUint(result, year, 4);
			 if (methodId != Id_toDateString) result.append(' ');
		 }
		 if (methodId != Id_toDateString) {
			 append0PaddedUint(result, HourFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, MinFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, SecFromTime(local), 2);
			 int minutes = (int) Math.floor((LocalTZA + DaylightSavingTA(t)) / msPerMinute);
			 int offset = (minutes / 60) * 100 + minutes % 60;
			 if (offset > 0) {
				 result.append("" GMT+"");
			 }
			 else {
				 result.append("" GMT-"");
				 offset = -offset;
			 }
			 append0PaddedUint(result, offset, 4);
			 if (timeZoneFormatter == null) timeZoneFormatter = new java.text.SimpleDateFormat(""zzz"");
			 if (t < 0.0 || t > 2145916800000.0) {
				 int equiv = EquivalentYear(YearFromTime(local));
				 double day = MakeDay(equiv, MonthFromTime(t), DateFromTime(t));
				 t = MakeDate(day, TimeWithinDay(t));
			 }
			 result.append("" ("");
			 java.util.Date date = new Date((long) t);
			 result.append(timeZoneFormatter.format(date));
			 result.append(')');
		 }
		 return result.toString();
	 }
	 private static Object jsConstructor(Object[] args) {
		 NativeDate obj = new NativeDate();
		 if (args.length == 0) {
			 obj.date = now();
			 return obj;
		 }
		 if (args.length == 1) {
			 Object arg0 = args[0];
			 if (arg0 instanceof Scriptable) arg0 = ((Scriptable) arg0).getDefaultValue(null);
			 double date;
			 if (arg0 instanceof String) {
				 date = date_parseString((String)arg0);
			 }
			 else {
				 date = ScriptRuntime.toNumber(arg0);
			 }
			 obj.date = TimeClip(date);
			 return obj;
		 }
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 obj.date = ScriptRuntime.NaN;
					 return obj;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 array[loop] = 0;
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 if (array[2] < 1) array[2] = 1;
		 double day = MakeDay(array[0], array[1], array[2]);
		 double time = MakeTime(array[3], array[4], array[5], array[6]);
		 time = MakeDate(day, time);
		 time = internalUTC(time);
		 obj.date = TimeClip(time);
		 return obj;
	 }
	 private static String toLocale_helper(double t, int methodId) {
		 java.text.DateFormat formatter;
		 switch (methodId) {
			 case Id_toLocaleString: if (localeDateTimeFormatter == null) {
				 localeDateTimeFormatter = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
			 }
			 formatter = localeDateTimeFormatter;
			 break;
			 case Id_toLocaleTimeString: if (localeTimeFormatter == null) {
				 localeTimeFormatter = DateFormat.getTimeInstance(DateFormat.LONG);
			 }
			 formatter = localeTimeFormatter;
			 break;
			 case Id_toLocaleDateString: if (localeDateFormatter == null) {
				 localeDateFormatter = DateFormat.getDateInstance(DateFormat.LONG);
			 }
			 formatter = localeDateFormatter;
			 break;
			 default: formatter = null;
		 }
		 return formatter.format(new Date((long) t));
	 }
	 private static String js_toUTCString(double date) {
		 StringBuffer result = new StringBuffer(60);
		 appendWeekDayName(result, WeekDay(date));
		 result.append("", "");
		 append0PaddedUint(result, DateFromTime(date), 2);
		 result.append(' ');
		 appendMonthName(result, MonthFromTime(date));
		 result.append(' ');
		 int year = YearFromTime(date);
		 if (year < 0) {
			 result.append('-');
			 year = -year;
		 }
		 append0PaddedUint(result, year, 4);
		 result.append(' ');
		 append0PaddedUint(result, HourFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, MinFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, SecFromTime(date), 2);
		 result.append("" GMT"");
		 return result.toString();
	 }
	 private static void append0PaddedUint(StringBuffer sb, int i, int minWidth) {
		 if (i < 0) Kit.codeBug();
		 int scale = 1;
		 --minWidth;
		 if (i >= 10) {
			 if (i < 1000 * 1000 * 1000) {
				 for (;
				;
				) {
					 int newScale = scale * 10;
					 if (i < newScale) {
						 break;
					 }
					 --minWidth;
					 scale = newScale;
				 }
			 }
			 else {
				 minWidth -= 9;
				 scale = 1000 * 1000 * 1000;
			 }
		 }
		 while (minWidth > 0) {
			 sb.append('0');
			 --minWidth;
		 }
		 while (scale != 1) {
			 sb.append((char)('0' + (i / scale)));
			 i %= scale;
			 scale /= 10;
		 }
		 sb.append((char)('0' + i));
	 }
	 private static void appendMonthName(StringBuffer sb, int index) {
		 String months = ""Jan""+""Feb""+""Mar""+""Apr""+""May""+""Jun"" +""Jul""+""Aug""+""Sep""+""Oct""+""Nov""+""Dec"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(months.charAt(index + i));
		 }
	 }
	 private static void appendWeekDayName(StringBuffer sb, int index) {
		 String days = ""Sun""+""Mon""+""Tue""+""Wed""+""Thu""+""Fri""+""Sat"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(days.charAt(index + i));
		 }
	 }
	 private static double makeTime(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCMilliseconds: local = false;
			 case Id_setMilliseconds: maxargs = 1;
			 break;
			 case Id_setUTCSeconds: local = false;
			 case Id_setSeconds: maxargs = 2;
			 break;
			 case Id_setUTCMinutes: local = false;
			 case Id_setMinutes: maxargs = 3;
			 break;
			 case Id_setUTCHours: local = false;
			 case Id_setHours: maxargs = 4;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[4];
		 double hour, min, sec, msec;
		 double lorutime;
		 double time;
		 double result;
		 if (date != date) return date;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (local) lorutime = LocalTime(date);
		 else lorutime = date;
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 4 && i < stop) hour = conv[i++];
		 else hour = HourFromTime(lorutime);
		 if (maxargs >= 3 && i < stop) min = conv[i++];
		 else min = MinFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) sec = conv[i++];
		 else sec = SecFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) msec = conv[i++];
		 else msec = msFromTime(lorutime);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(Day(lorutime), time);
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 private static double makeDate(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCDate: local = false;
			 case Id_setDate: maxargs = 1;
			 break;
			 case Id_setUTCMonth: local = false;
			 case Id_setMonth: maxargs = 2;
			 break;
			 case Id_setUTCFullYear: local = false;
			 case Id_setFullYear: maxargs = 3;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[3];
		 double year, month, day;
		 double lorutime;
		 double result;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (date != date) {
			 if (args.length < 3) {
				 return ScriptRuntime.NaN;
			 }
			 else {
				 lorutime = 0;
			 }
		 }
		 else {
			 if (local) lorutime = LocalTime(date);
			 else lorutime = date;
		 }
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 3 && i < stop) year = conv[i++];
		 else year = YearFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) month = conv[i++];
		 else month = MonthFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) day = conv[i++];
		 else day = DateFromTime(lorutime);
		 day = MakeDay(year, month, day);
		 result = MakeDate(day, TimeWithinDay(lorutime));
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 6: X=""getDay"";
				id=Id_getDay;
				 break L;
				 case 7: switch (s.charAt(3)) {
					 case 'D': c=s.charAt(0);
					 if (c=='g') {
						 X=""getDate"";
						id=Id_getDate;
					 }
					 else if (c=='s') {
						 X=""setDate"";
						id=Id_setDate;
					 }
					 break L;
					 case 'T': c=s.charAt(0);
					 if (c=='g') {
						 X=""getTime"";
						id=Id_getTime;
					 }
					 else if (c=='s') {
						 X=""setTime"";
						id=Id_setTime;
					 }
					 break L;
					 case 'Y': c=s.charAt(0);
					 if (c=='g') {
						 X=""getYear"";
						id=Id_getYear;
					 }
					 else if (c=='s') {
						 X=""setYear"";
						id=Id_setYear;
					 }
					 break L;
					 case 'u': X=""valueOf"";
					id=Id_valueOf;
					 break L;
				 }
				 break L;
				 case 8: switch (s.charAt(3)) {
					 case 'H': c=s.charAt(0);
					 if (c=='g') {
						 X=""getHours"";
						id=Id_getHours;
					 }
					 else if (c=='s') {
						 X=""setHours"";
						id=Id_setHours;
					 }
					 break L;
					 case 'M': c=s.charAt(0);
					 if (c=='g') {
						 X=""getMonth"";
						id=Id_getMonth;
					 }
					 else if (c=='s') {
						 X=""setMonth"";
						id=Id_setMonth;
					 }
					 break L;
					 case 'o': X=""toSource"";
					id=Id_toSource;
					 break L;
					 case 't': X=""toString"";
					id=Id_toString;
					 break L;
				 }
				 break L;
				 case 9: X=""getUTCDay"";
				id=Id_getUTCDay;
				 break L;
				 case 10: c=s.charAt(3);
				 if (c=='M') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getMinutes"";
						id=Id_getMinutes;
					 }
					 else if (c=='s') {
						 X=""setMinutes"";
						id=Id_setMinutes;
					 }
				 }
				 else if (c=='S') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getSeconds"";
						id=Id_getSeconds;
					 }
					 else if (c=='s') {
						 X=""setSeconds"";
						id=Id_setSeconds;
					 }
				 }
				 else if (c=='U') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getUTCDate"";
						id=Id_getUTCDate;
					 }
					 else if (c=='s') {
						 X=""setUTCDate"";
						id=Id_setUTCDate;
					 }
				 }
				 break L;
				 case 11: switch (s.charAt(3)) {
					 case 'F': c=s.charAt(0);
					 if (c=='g') {
						 X=""getFullYear"";
						id=Id_getFullYear;
					 }
					 else if (c=='s') {
						 X=""setFullYear"";
						id=Id_setFullYear;
					 }
					 break L;
					 case 'M': X=""toGMTString"";
					id=Id_toGMTString;
					 break L;
					 case 'T': X=""toUTCString"";
					id=Id_toUTCString;
					 break L;
					 case 'U': c=s.charAt(0);
					 if (c=='g') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""getUTCHours"";
							id=Id_getUTCHours;
						 }
						 else if (c=='t') {
							 X=""getUTCMonth"";
							id=Id_getUTCMonth;
						 }
					 }
					 else if (c=='s') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""setUTCHours"";
							id=Id_setUTCHours;
						 }
						 else if (c=='t') {
							 X=""setUTCMonth"";
							id=Id_setUTCMonth;
						 }
					 }
					 break L;
					 case 's': X=""constructor"";
					id=Id_constructor;
					 break L;
				 }
				 break L;
				 case 12: c=s.charAt(2);
				 if (c=='D') {
					 X=""toDateString"";
					id=Id_toDateString;
				 }
				 else if (c=='T') {
					 X=""toTimeString"";
					id=Id_toTimeString;
				 }
				 break L;
				 case 13: c=s.charAt(0);
				 if (c=='g') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""getUTCMinutes"";
						id=Id_getUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""getUTCSeconds"";
						id=Id_getUTCSeconds;
					 }
				 }
				 else if (c=='s') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""setUTCMinutes"";
						id=Id_setUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""setUTCSeconds"";
						id=Id_setUTCSeconds;
					 }
				 }
				 break L;
				 case 14: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCFullYear"";
					id=Id_getUTCFullYear;
				 }
				 else if (c=='s') {
					 X=""setUTCFullYear"";
					id=Id_setUTCFullYear;
				 }
				 else if (c=='t') {
					 X=""toLocaleString"";
					id=Id_toLocaleString;
				 }
				 break L;
				 case 15: c=s.charAt(0);
				 if (c=='g') {
					 X=""getMilliseconds"";
					id=Id_getMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setMilliseconds"";
					id=Id_setMilliseconds;
				 }
				 break L;
				 case 17: X=""getTimezoneOffset"";
				id=Id_getTimezoneOffset;
				 break L;
				 case 18: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCMilliseconds"";
					id=Id_getUTCMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setUTCMilliseconds"";
					id=Id_setUTCMilliseconds;
				 }
				 else if (c=='t') {
					 c=s.charAt(8);
					 if (c=='D') {
						 X=""toLocaleDateString"";
						id=Id_toLocaleDateString;
					 }
					 else if (c=='T') {
						 X=""toLocaleTimeString"";
						id=Id_toLocaleTimeString;
					 }
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int ConstructorId_now = -3, ConstructorId_parse = -2, ConstructorId_UTC = -1, Id_constructor = 1, Id_toString = 2, Id_toTimeString = 3, Id_toDateString = 4, Id_toLocaleString = 5, Id_toLocaleTimeString = 6, Id_toLocaleDateString = 7, Id_toUTCString = 8, Id_toSource = 9, Id_valueOf = 10, Id_getTime = 11, Id_getYear = 12, Id_getFullYear = 13, Id_getUTCFullYear = 14, Id_getMonth = 15, Id_getUTCMonth = 16, Id_getDate = 17, Id_getUTCDate = 18, Id_getDay = 19, Id_getUTCDay = 20, Id_getHours = 21, Id_getUTCHours = 22, Id_getMinutes = 23, Id_getUTCMinutes = 24, Id_getSeconds = 25, Id_getUTCSeconds = 26, Id_getMilliseconds = 27, Id_getUTCMilliseconds = 28, Id_getTimezoneOffset = 29, Id_setTime = 30, Id_setMilliseconds = 31, Id_setUTCMilliseconds = 32, Id_setSeconds = 33, Id_setUTCSeconds = 34, Id_setMinutes = 35, Id_setUTCMinutes = 36, Id_setHours = 37, Id_setUTCHours = 38, Id_setDate = 39, Id_setUTCDate = 40, Id_setMonth = 41, Id_setUTCMonth = 42, Id_setFullYear = 43, Id_setUTCFullYear = 44, Id_setYear = 45, MAX_PROTOTYPE_ID = 45;
	 private static final int Id_toGMTString = Id_toUTCString;
	 private static java.util.TimeZone thisTimeZone;
	 private static double LocalTZA;
	 private static java.text.DateFormat timeZoneFormatter;
	 private static java.text.DateFormat localeDateTimeFormatter;
	 private static java.text.DateFormat localeDateFormatter;
	 private static java.text.DateFormat localeTimeFormatter;
	 private double date;
}",1,0,0,0
"public void sendFreeBusy(String body) throws IOException {
	 HashMap<String, String> valueMap = new HashMap<String, String>();
	 ArrayList<String> attendees = new ArrayList<String>();
	 HashMap<String, String> attendeeKeyMap = new HashMap<String, String>();
	 ICSBufferedReader reader = new ICSBufferedReader(new StringReader(body));
	 String line;
	 String key;
	 while ((line = reader.readLine()) != null) {
		 int index = line.indexOf(':');
		 if (index <= 0) {
			 throw new DavMailException(""EXCEPTION_INVALID_REQUEST"", body);
		 }
		 String fullkey = line.substring(0, index);
		 String value = line.substring(index + 1);
		 int semicolonIndex = fullkey.indexOf(';
		');
		 if (semicolonIndex > 0) {
			 key = fullkey.substring(0, semicolonIndex);
		 }
		 else {
			 key = fullkey;
		 }
		 if (""ATTENDEE"".equals(key)) {
			 attendees.add(value);
			 attendeeKeyMap.put(value, fullkey);
		 }
		 else {
			 valueMap.put(key, value);
		 }
	 }
	 HashMap<String, ExchangeSession.FreeBusy> freeBusyMap = new HashMap<String, ExchangeSession.FreeBusy>();
	 for (String attendee : attendees) {
		 ExchangeSession.FreeBusy freeBusy = session.getFreebusy(attendee, valueMap.get(""DTSTART""), valueMap.get(""DTEND""));
		 if (freeBusy != null) {
			 freeBusyMap.put(attendee, freeBusy);
		 }
	 }
	 CaldavResponse response = new CaldavResponse(HttpStatus.SC_OK);
	 response.startScheduleResponse();
	 for (Map.Entry<String, ExchangeSession.FreeBusy> entry : freeBusyMap.entrySet()) {
		 String attendee = entry.getKey();
		 response.startRecipientResponse(attendee);
		 StringBuilder ics = new StringBuilder();
		 ics.append(""BEGIN:VCALENDAR"").append((char) 13).append((char) 10) .append(""VERSION:2.0"").append((char) 13).append((char) 10) .append(""PRODID:- .append(""METHOD:REPLY"").append((char) 13).append((char) 10) .append(""BEGIN:VFREEBUSY"").append((char) 13).append((char) 10) .append(""DTSTAMP:"").append(valueMap.get(""DTSTAMP"")).append("""").append((char) 13).append((char) 10) .append(""ORGANIZER:"").append(valueMap.get(""ORGANIZER"")).append("""").append((char) 13).append((char) 10) .append(""DTSTART:"").append(valueMap.get(""DTSTART"")).append("""").append((char) 13).append((char) 10) .append(""DTEND:"").append(valueMap.get(""DTEND"")).append("""").append((char) 13).append((char) 10) .append(""UID:"").append(valueMap.get(""UID"")).append("""").append((char) 13).append((char) 10) .append(attendeeKeyMap.get(attendee)).append(':').append(attendee).append("""").append((char) 13).append((char) 10);
		 entry.getValue().appendTo(ics);
		 ics.append(""END:VFREEBUSY"").append((char) 13).append((char) 10) .append(""END:VCALENDAR"");
		 response.appendCalendarData(ics.toString());
		 response.endRecipientResponse();
	 }
	 response.endScheduleResponse();
	 response.close();
 }",0,0,1,0
"public class PresentSelector extends BaseSelector {
	 private File targetdir = null;
	 private Mapper mapperElement = null;
	 private FileNameMapper map = null;
	 private boolean destmustexist = true;
	 public PresentSelector() {
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer(""{
			presentselector targetdir: "");
			 if (targetdir == null) {
				 buf.append(""NOT YET SET"");
			 }
			 else {
				 buf.append(targetdir.getName());
			 }
			 buf.append("" present: "");
			 if (destmustexist) {
				 buf.append(""both"");
			 }
			 else {
				 buf.append(""srconly"");
			 }
			 if (map != null) {
				 buf.append(map.toString());
			 }
			 else if (mapperElement != null) {
				 buf.append(mapperElement.toString());
			 }
		 buf.append(""}
		"");
		 return buf.toString();
	 }
	 public void setTargetdir(File targetdir) {
		 this.targetdir = targetdir;
	 }
	 public Mapper createMapper() throws BuildException {
		 if (map != null || mapperElement != null) {
			 throw new BuildException(""Cannot define more than one mapper"");
		 }
		 mapperElement = new Mapper(getProject());
		 return mapperElement;
	 }
	 public void addConfigured(FileNameMapper fileNameMapper) {
		 if (map != null || mapperElement != null) {
			 throw new BuildException(""Cannot define more than one mapper"");
		 }
		 this.map = fileNameMapper;
	 }
	 public void setPresent(FilePresence fp) {
		 if (fp.getIndex() == 0) {
			 destmustexist = false;
		 }
	 }
	 public void verifySettings() {
		 if (targetdir == null) {
			 setError(""The targetdir attribute is required."");
		 }
		 if (map == null) {
			 if (mapperElement == null) {
				 map = new IdentityMapper();
			 }
			 else {
				 map = mapperElement.getImplementation();
				 if (map == null) {
					 setError(""Could not set <mapper> element."");
				 }
			 }
		 }
	 }
	 public boolean isSelected(File basedir, String filename, File file) {
		 validate();
		 String[] destfiles = map.mapFileName(filename);
		 if (destfiles == null) {
			 return false;
		 }
		 if (destfiles.length != 1 || destfiles[0] == null) {
			 throw new BuildException(""Invalid destination file results for "" + targetdir + "" with filename "" + filename);
		 }
		 String destname = destfiles[0];
		 File destfile = FileUtils.getFileUtils().resolveFile(targetdir, destname);
		 return destfile.exists() == destmustexist;
	 }
	 public static class FilePresence extends EnumeratedAttribute {
		 public String[] getValues() {
			 return new String[] {
			 ""srconly"", ""both"" }
			;
		 }
	 }
}",0,0,0,0
"final class DatabaseInformationFullextends org.hsqldb.dbinfo.DatabaseInformationMain {
	 final static HashMappedList statementMap;
	 static {
		 synchronized (DatabaseInformationFull.class) {
			 final String resourceFileName = ""/org/hsqldb/resources/information-schema.sql"";
			 final String[] starters = new String[]{
				 "" DatabaseInformationFull(Database db) {
					 super(db);
				 }
				 protected Table generateTable(Session session, int tableIndex) {
					 switch (tableIndex) {
						 case SYSTEM_CACHEINFO : return SYSTEM_CACHEINFO(session);
						 case SYSTEM_COMMENTS : return SYSTEM_COMMENTS(session);
						 case SYSTEM_SESSIONINFO : return SYSTEM_SESSIONINFO(session);
						 case SYSTEM_PROPERTIES : return SYSTEM_PROPERTIES(session);
						 case SYSTEM_SESSIONS : return SYSTEM_SESSIONS(session);
						 case SYSTEM_TEXTTABLES : return SYSTEM_TEXTTABLES(session);
						 case ADMINISTRABLE_ROLE_AUTHORIZATIONS : return ADMINISTRABLE_ROLE_AUTHORIZATIONS(session);
						 case APPLICABLE_ROLES : return APPLICABLE_ROLES(session);
						 case ASSERTIONS : return ASSERTIONS(session);
						 case AUTHORIZATIONS : return AUTHORIZATIONS(session);
						 case CHARACTER_SETS : return CHARACTER_SETS(session);
						 case CHECK_CONSTRAINT_ROUTINE_USAGE : return CHECK_CONSTRAINT_ROUTINE_USAGE(session);
						 case CHECK_CONSTRAINTS : return CHECK_CONSTRAINTS(session);
						 case COLLATIONS : return COLLATIONS(session);
						 case COLUMN_COLUMN_USAGE : return COLUMN_COLUMN_USAGE(session);
						 case COLUMN_DOMAIN_USAGE : return COLUMN_DOMAIN_USAGE(session);
						 case COLUMN_UDT_USAGE : return COLUMN_UDT_USAGE(session);
						 case CONSTRAINT_COLUMN_USAGE : return CONSTRAINT_COLUMN_USAGE(session);
						 case CONSTRAINT_TABLE_USAGE : return CONSTRAINT_TABLE_USAGE(session);
						 case COLUMNS : return COLUMNS(session);
						 case DATA_TYPE_PRIVILEGES : return DATA_TYPE_PRIVILEGES(session);
						 case DOMAIN_CONSTRAINTS : return DOMAIN_CONSTRAINTS(session);
						 case DOMAINS : return DOMAINS(session);
						 case ENABLED_ROLES : return ENABLED_ROLES(session);
						 case JAR_JAR_USAGE : return JAR_JAR_USAGE(session);
						 case JARS : return JARS(session);
						 case KEY_COLUMN_USAGE : return KEY_COLUMN_USAGE(session);
						 case METHOD_SPECIFICATIONS : return METHOD_SPECIFICATIONS(session);
						 case MODULE_COLUMN_USAGE : return MODULE_COLUMN_USAGE(session);
						 case MODULE_PRIVILEGES : return MODULE_PRIVILEGES(session);
						 case MODULE_TABLE_USAGE : return MODULE_TABLE_USAGE(session);
						 case MODULES : return MODULES(session);
						 case PARAMETERS : return PARAMETERS(session);
						 case REFERENTIAL_CONSTRAINTS : return REFERENTIAL_CONSTRAINTS(session);
						 case ROLE_AUTHORIZATION_DESCRIPTORS : return ROLE_AUTHORIZATION_DESCRIPTORS(session);
						 case ROLE_COLUMN_GRANTS : return ROLE_COLUMN_GRANTS(session);
						 case ROLE_ROUTINE_GRANTS : return ROLE_ROUTINE_GRANTS(session);
						 case ROLE_TABLE_GRANTS : return ROLE_TABLE_GRANTS(session);
						 case ROLE_USAGE_GRANTS : return ROLE_USAGE_GRANTS(session);
						 case ROLE_UDT_GRANTS : return ROLE_UDT_GRANTS(session);
						 case ROUTINE_COLUMN_USAGE : return ROUTINE_COLUMN_USAGE(session);
						 case ROUTINE_JAR_USAGE : return ROUTINE_JAR_USAGE(session);
						 case ROUTINE_PRIVILEGES : return ROUTINE_PRIVILEGES(session);
						 case ROUTINE_ROUTINE_USAGE : return ROUTINE_ROUTINE_USAGE(session);
						 case ROUTINE_SEQUENCE_USAGE : return ROUTINE_SEQUENCE_USAGE(session);
						 case ROUTINE_TABLE_USAGE : return ROUTINE_TABLE_USAGE(session);
						 case ROUTINES : return ROUTINES(session);
						 case SCHEMATA : return SCHEMATA(session);
						 case SEQUENCES : return SEQUENCES(session);
						 case SQL_FEATURES : return SQL_FEATURES(session);
						 case SQL_IMPLEMENTATION_INFO : return SQL_IMPLEMENTATION_INFO(session);
						 case SQL_PACKAGES : return SQL_PACKAGES(session);
						 case SQL_PARTS : return SQL_PARTS(session);
						 case SQL_SIZING : return SQL_SIZING(session);
						 case SQL_SIZING_PROFILES : return SQL_SIZING_PROFILES(session);
						 case TABLE_CONSTRAINTS : return TABLE_CONSTRAINTS(session);
						 case TABLES : return TABLES(session);
						 case TRANSLATIONS : return TRANSLATIONS(session);
						 case TRIGGERED_UPDATE_COLUMNS : return TRIGGERED_UPDATE_COLUMNS(session);
						 case TRIGGER_COLUMN_USAGE : return TRIGGER_COLUMN_USAGE(session);
						 case TRIGGER_ROUTINE_USAGE : return TRIGGER_ROUTINE_USAGE(session);
						 case TRIGGER_SEQUENCE_USAGE : return TRIGGER_SEQUENCE_USAGE(session);
						 case TRIGGER_TABLE_USAGE : return TRIGGER_TABLE_USAGE(session);
						 case TRIGGERS : return TRIGGERS(session);
						 case UDT_PRIVILEGES : return UDT_PRIVILEGES(session);
						 case USAGE_PRIVILEGES : return USAGE_PRIVILEGES(session);
						 case USER_DEFINED_TYPES : return USER_DEFINED_TYPES(session);
						 case VIEW_COLUMN_USAGE : return VIEW_COLUMN_USAGE(session);
						 case VIEW_ROUTINE_USAGE : return VIEW_ROUTINE_USAGE(session);
						 case VIEW_TABLE_USAGE : return VIEW_TABLE_USAGE(session);
						 case VIEWS : return VIEWS(session);
						 default : return super.generateTable(session, tableIndex);
					 }
				 }
				 Table SYSTEM_CACHEINFO(Session session) {
					 Table t = sysTables[SYSTEM_CACHEINFO];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[SYSTEM_CACHEINFO]);
						 addColumn(t, ""CACHE_FILE"", CHARACTER_DATA);
						 addColumn(t, ""MAX_CACHE_COUNT"", CARDINAL_NUMBER);
						 addColumn(t, ""MAX_CACHE_BYTES"", CARDINAL_NUMBER);
						 addColumn(t, ""CACHE_SIZE"", CARDINAL_NUMBER);
						 addColumn(t, ""CACHE_BYTES"", CARDINAL_NUMBER);
						 addColumn(t, ""FILE_FREE_BYTES"", CARDINAL_NUMBER);
						 addColumn(t, ""FILE_FREE_COUNT"", CARDINAL_NUMBER);
						 addColumn(t, ""FILE_FREE_POS"", CARDINAL_NUMBER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SYSTEM_CACHEINFO].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[]{
						 0 }
						, true);
						 return t;
					 }
					 final int icache_file = 0;
					 final int imax_cache_sz = 1;
					 final int imax_cache_bytes = 2;
					 final int icache_size = 3;
					 final int icache_length = 4;
					 final int ifree_bytes = 5;
					 final int ifree_count = 6;
					 final int ifree_pos = 7;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 DataFileCache cache = null;
					 Object[] row;
					 HashSet cacheSet;
					 Iterator caches;
					 Iterator tables;
					 Table table;
					 int iFreeBytes;
					 int iLargestFreeItem;
					 long lSmallestFreeItem;
					 cacheSet = new HashSet();
					 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
					 while (tables.hasNext()) {
						 table = (Table) tables.next();
						 PersistentStore currentStore = session.sessionData.getRowStore(t);
						 if (session.getGrantee().isFullyAccessibleByRole( table.getName())) {
							 if (currentStore != null) {
								 cache = currentStore.getCache();
							 }
							 if (cache != null) {
								 cacheSet.add(cache);
							 }
						 }
					 }
					 caches = cacheSet.iterator();
					 while (caches.hasNext()) {
						 cache = (DataFileCache) caches.next();
						 row = t.getEmptyRowData();
						 row[icache_file] = FileUtil.getFileUtil().canonicalOrAbsolutePath( cache.getFileName());
						 row[imax_cache_sz] = ValuePool.getLong(cache.capacity());
						 row[imax_cache_bytes] = ValuePool.getLong(cache.bytesCapacity());
						 row[icache_size] = ValuePool.getLong(cache.getCachedObjectCount());
						 row[icache_length] = ValuePool.getLong(cache.getTotalCachedBlockSize());
						 row[ifree_bytes] = ValuePool.getLong(cache.getTotalFreeBlockSize());
						 row[ifree_count] = ValuePool.getLong(cache.getFreeBlockCount());
						 row[ifree_pos] = ValuePool.getLong(cache.getFileFreePos());
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table SYSTEM_COMMENTS(Session session) {
					 Table t = sysTables[SYSTEM_COMMENTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[SYSTEM_COMMENTS]);
						 addColumn(t, ""OBJECT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_TYPE"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COMMENT"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SYSTEM_COMMENTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 final int catalog = 0;
					 final int schema = 1;
					 final int name = 2;
					 final int type = 3;
					 final int column_name = 4;
					 final int remark = 5;
					 Iterator it;
					 Object[] row;
					 DITableInfo ti = new DITableInfo();
					 it = allTables();
					 while (it.hasNext()) {
						 Table table = (Table) it.next();
						 if (!session.getGrantee().isAccessible(table)) {
							 continue;
						 }
						 ti.setTable(table);
						 int colCount = table.getColumnCount();
						 for (int i = 0;
						 i < colCount;
						 i++) {
							 ColumnSchema column = table.getColumn(i);
							 if (column.getName().comment == null) {
								 continue;
							 }
							 row = t.getEmptyRowData();
							 row[catalog] = database.getCatalogName().name;
							 row[schema] = table.getSchemaName().name;
							 row[name] = table.getName().name;
							 row[type] = ""COLUMN"";
							 row[column_name] = column.getName().name;
							 row[remark] = column.getName().comment;
							 t.insertSys(store, row);
						 }
						 if (table.getTableType() != Table.SYSTEM_TABLE && table.getName().comment == null) {
							 continue;
						 }
						 row = t.getEmptyRowData();
						 row[catalog] = database.getCatalogName().name;
						 row[schema] = table.getSchemaName().name;
						 row[name] = table.getName().name;
						 row[type] = table.isView() || table.getTableType() == Table.SYSTEM_TABLE ? ""VIEW"" : ""TABLE"";
						 row[column_name] = null;
						 row[remark] = ti.getRemark();
						 t.insertSys(store, row);
					 }
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 SchemaObject object = (SchemaObject) it.next();
						 if (!session.getGrantee().isAccessible(object)) {
							 continue;
						 }
						 if (object.getName().comment == null) {
							 continue;
						 }
						 row = t.getEmptyRowData();
						 row[catalog] = database.getCatalogName().name;
						 row[schema] = object.getSchemaName().name;
						 row[name] = object.getName().name;
						 row[type] = ""ROUTINE"";
						 row[column_name] = null;
						 row[remark] = object.getName().comment;
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table SYSTEM_PROPERTIES(Session session) {
					 Table t = sysTables[SYSTEM_PROPERTIES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[SYSTEM_PROPERTIES]);
						 addColumn(t, ""PROPERTY_SCOPE"", CHARACTER_DATA);
						 addColumn(t, ""PROPERTY_NAMESPACE"", CHARACTER_DATA);
						 addColumn(t, ""PROPERTY_NAME"", CHARACTER_DATA);
						 addColumn(t, ""PROPERTY_VALUE"", CHARACTER_DATA);
						 addColumn(t, ""PROPERTY_CLASS"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SYSTEM_PROPERTIES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2 }
						, true);
						 return t;
					 }
					 final int iscope = 0;
					 final int ins = 1;
					 final int iname = 2;
					 final int ivalue = 3;
					 final int iclass = 4;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 String scope;
					 String nameSpace;
					 Object[] row;
					 HsqlDatabaseProperties props;
					 scope = ""SESSION"";
					 props = database.getProperties();
					 nameSpace = ""database.properties"";
					 Iterator it = props.getUserDefinedPropertyData().iterator();
					 while (it.hasNext()) {
						 Object[] metaData = (Object[]) it.next();
						 row = t.getEmptyRowData();
						 row[iscope] = scope;
						 row[ins] = nameSpace;
						 row[iname] = metaData[HsqlProperties.indexName];
						 row[ivalue] = props.getProperty((String) row[iname]);
						 row[iclass] = metaData[HsqlProperties.indexClass];
						 t.insertSys(store, row);
					 }
					 row = t.getEmptyRowData();
					 row[iscope] = scope;
					 row[ins] = nameSpace;
					 row[iname] = ""SCRIPT FORMAT"";
					 try {
						 row[ivalue] = ScriptWriterBase .LIST_SCRIPT_FORMATS[database.logger.getScriptType()];
					 }
					 catch (Exception e) {
					}
					 row[iclass] = ""String"";
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[iscope] = scope;
					 row[ins] = nameSpace;
					 row[iname] = ""WRITE DELAY"";
					 row[ivalue] = """" + database.logger.getWriteDelay();
					 row[iclass] = ""Integer"";
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[iscope] = scope;
					 row[ins] = nameSpace;
					 row[iname] = ""REFERENTIAL INTEGRITY"";
					 row[ivalue] = database.isReferentialIntegrity() ? ""true"" : ""false"";
					 row[iclass] = ""Boolean"";
					 t.insertSys(store, row);
					 return t;
				 }
				 Table SYSTEM_SESSIONINFO(Session session) {
					 Table t = sysTables[SYSTEM_SESSIONINFO];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[SYSTEM_SESSIONINFO]);
						 addColumn(t, ""KEY"", CHARACTER_DATA);
						 addColumn(t, ""VALUE"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SYSTEM_SESSIONINFO].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[]{
						 0 }
						, true);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Object[] row;
					 row = t.getEmptyRowData();
					 row[0] = ""SESSION ID"";
					 row[1] = String.valueOf(session.getId());
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""AUTOCOMMIT"";
					 row[1] = session.isAutoCommit() ? Tokens.T_TRUE : Tokens.T_FALSE;
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""USER"";
					 row[1] = session.getUsername();
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""SESSION READONLY"";
					 row[1] = session.isReadOnlyDefault() ? Tokens.T_TRUE : Tokens.T_FALSE;
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""DATABASE READONLY"";
					 row[1] = database.isReadOnly() ? Tokens.T_TRUE : Tokens.T_FALSE;
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""DATABASE"";
					 row[1] = database.getURI();
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""IDENTITY"";
					 row[1] = String.valueOf(session.getLastIdentity());
					 t.insertSys(store, row);
					 row = t.getEmptyRowData();
					 row[0] = ""CURRENT SCHEMA"";
					 row[1] = String.valueOf(session.getSchemaName(null));
					 t.insertSys(store, row);
					 return t;
				 }
				 Table SYSTEM_SESSIONS(Session session) {
					 Table t = sysTables[SYSTEM_SESSIONS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[SYSTEM_SESSIONS]);
						 addColumn(t, ""SESSION_ID"", CARDINAL_NUMBER);
						 addColumn(t, ""CONNECTED"", TIME_STAMP);
						 addColumn(t, ""USER_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""IS_ADMIN"", Type.SQL_BOOLEAN);
						 addColumn(t, ""AUTOCOMMIT"", Type.SQL_BOOLEAN);
						 addColumn(t, ""READONLY"", Type.SQL_BOOLEAN);
						 addColumn(t, ""LAST_IDENTITY"", CARDINAL_NUMBER);
						 addColumn(t, ""TRANSACTION_SIZE"", CARDINAL_NUMBER);
						 addColumn(t, ""SCHEMA"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SYSTEM_SESSIONS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[]{
						 0 }
						, true);
						 return t;
					 }
					 final int isid = 0;
					 final int ict = 1;
					 final int iuname = 2;
					 final int iis_admin = 3;
					 final int iautocmt = 4;
					 final int ireadonly = 5;
					 final int ilast_id = 6;
					 final int it_size = 7;
					 final int it_schema = 8;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session[] sessions;
					 Session s;
					 Object[] row;
					 sessions = database.sessionManager.getVisibleSessions(session);
					 for (int i = 0;
					 i < sessions.length;
					 i++) {
						 s = sessions[i];
						 row = t.getEmptyRowData();
						 row[isid] = ValuePool.getLong(s.getId());
						 row[ict] = new TimestampData(s.getConnectTime() / 1000);
						 row[iuname] = s.getUsername();
						 row[iis_admin] = ValuePool.getBoolean(s.isAdmin());
						 row[iautocmt] = ValuePool.getBoolean(s.isAutoCommit());
						 row[ireadonly] = ValuePool.getBoolean(s.isReadOnlyDefault());
						 row[ilast_id] = ValuePool.getLong(((Number) s.getLastIdentity()).longValue());
						 row[it_size] = ValuePool.getLong(s.getTransactionSize());
						 row[it_schema] = s.getCurrentSchemaHsqlName().name;
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table SYSTEM_TEXTTABLES(Session session) {
					 Table t = sysTables[SYSTEM_TEXTTABLES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[SYSTEM_TEXTTABLES]);
						 addColumn(t, ""TABLE_CAT"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEM"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DATA_SOURCE_DEFINTION"", CHARACTER_DATA);
						 addColumn(t, ""FILE_PATH"", CHARACTER_DATA);
						 addColumn(t, ""FILE_ENCODING"", CHARACTER_DATA);
						 addColumn(t, ""FIELD_SEPARATOR"", CHARACTER_DATA);
						 addColumn(t, ""VARCHAR_SEPARATOR"", CHARACTER_DATA);
						 addColumn(t, ""LONGVARCHAR_SEPARATOR"", CHARACTER_DATA);
						 addColumn(t, ""IS_IGNORE_FIRST"", Type.SQL_BOOLEAN);
						 addColumn(t, ""IS_ALL_QUOTED"", Type.SQL_BOOLEAN);
						 addColumn(t, ""IS_QUOTED"", Type.SQL_BOOLEAN);
						 addColumn(t, ""IS_DESC"", Type.SQL_BOOLEAN);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SYSTEM_TEXTTABLES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, }
						, false);
						 return t;
					 }
					 final int itable_cat = 0;
					 final int itable_schem = 1;
					 final int itable_name = 2;
					 final int idsd = 3;
					 final int ifile_path = 4;
					 final int ifile_enc = 5;
					 final int ifs = 6;
					 final int ivfs = 7;
					 final int ilvfs = 8;
					 final int iif = 9;
					 final int iiq = 10;
					 final int iiaq = 11;
					 final int iid = 12;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator tables;
					 Table table;
					 Object[] row;
					 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
					 while (tables.hasNext()) {
						 table = (Table) tables.next();
						 PersistentStore currentStore = session.sessionData.getRowStore(t);
						 if (!table.isText() || !isAccessibleTable(session, table)) {
							 continue;
						 }
						 row = t.getEmptyRowData();
						 row[itable_cat] = database.getCatalogName().name;
						 row[itable_schem] = table.getSchemaName().name;
						 row[itable_name] = table.getName().name;
						 row[idsd] = ((TextTable) table).getDataSource();
						 TextCache cache = (TextCache) currentStore.getCache();
						 if (cache != null) {
							 row[ifile_path] = FileUtil.getFileUtil().canonicalOrAbsolutePath( cache.getFileName());
							 row[ifile_enc] = cache.stringEncoding;
							 row[ifs] = cache.fs;
							 row[ivfs] = cache.vs;
							 row[ilvfs] = cache.lvs;
							 row[iif] = ValuePool.getBoolean(cache.ignoreFirst);
							 row[iiq] = ValuePool.getBoolean(cache.isQuoted);
							 row[iiaq] = ValuePool.getBoolean(cache.isAllQuoted);
							 row[iid] = ((TextTable) table).isDescDataSource() ? Boolean.TRUE : Boolean.FALSE;
						 }
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table ADMINISTRABLE_ROLE_AUTHORIZATIONS(Session session) {
					 Table t = sysTables[ADMINISTRABLE_ROLE_AUTHORIZATIONS];
					 if (t == null) {
						 t = createBlankTable( sysTableHsqlNames[ADMINISTRABLE_ROLE_AUTHORIZATIONS]);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""ROLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""IS_GRANTABLE"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ADMINISTRABLE_ROLE_AUTHORIZATIONS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2 }
						, false);
						 return t;
					 }
					 if (session.isAdmin()) {
						 insertRoles(session, t, session.getGrantee(), true);
					 }
					 return t;
				 }
				 Table APPLICABLE_ROLES(Session session) {
					 Table t = sysTables[APPLICABLE_ROLES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[APPLICABLE_ROLES]);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""ROLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""IS_GRANTABLE"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[APPLICABLE_ROLES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2 }
						, false);
						 return t;
					 }
					 insertRoles(session, t, session.getGrantee(), session.isAdmin());
					 return t;
				 }
				 private void insertRoles(Session session, Table t, Grantee role, boolean isGrantable) {
					 final int grantee = 0;
					 final int role_name = 1;
					 final int is_grantable = 2;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 if (isGrantable) {
						 Set roles = database.getGranteeManager().getRoleNames();
						 Iterator it = roles.iterator();
						 while (it.hasNext()) {
							 String roleName = (String) it.next();
							 Object[] row = t.getEmptyRowData();
							 row[grantee] = role.getNameString();
							 row[role_name] = roleName;
							 row[is_grantable] = ""YES"";
							 t.insertSys(store, row);
						 }
					 }
					 else {
						 OrderedHashSet roles = role.getDirectRoles();
						 for (int i = 0;
						 i < roles.size();
						 i++) {
							 String roleName = (String) roles.get(i);
							 Object[] row = t.getEmptyRowData();
							 row[grantee] = role.getNameString();
							 row[role_name] = roleName;
							 row[is_grantable] = Tokens.T_NO;
							 t.insertSys(store, row);
							 role = database.getGranteeManager().getRole(roleName);
							 insertRoles(session, t, role, isGrantable);
						 }
					 }
				 }
				 Table ASSERTIONS(Session session) {
					 Table t = sysTables[ASSERTIONS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ASSERTIONS]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""IS_DEFERRABLE"", YES_OR_NO);
						 addColumn(t, ""INITIALLY_DEFERRED"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ASSERTIONS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2 }
						, false);
						 return t;
					 }
					 final int constraint_catalog = 0;
					 final int constraint_schema = 1;
					 final int constraint_name = 2;
					 final int is_deferrable = 3;
					 final int initially_deferred = 4;
					 return t;
				 }
				 Table AUTHORIZATIONS(Session session) {
					 Table t = sysTables[AUTHORIZATIONS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[AUTHORIZATIONS]);
						 addColumn(t, ""AUTHORIZATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""AUTHORIZATION_TYPE"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[AUTHORIZATIONS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[]{
						 0 }
						, true);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator grantees;
					 Grantee grantee;
					 Object[] row;
					 grantees = session.getGrantee().visibleGrantees().iterator();
					 while (grantees.hasNext()) {
						 grantee = (Grantee) grantees.next();
						 row = t.getEmptyRowData();
						 row[0] = grantee.getNameString();
						 row[1] = grantee.isRole() ? ""ROLE"" : ""USER"";
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table CHARACTER_SETS(Session session) {
					 Table t = sysTables[CHARACTER_SETS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[CHARACTER_SETS]);
						 addColumn(t, ""CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_REPERTOIRE"", SQL_IDENTIFIER);
						 addColumn(t, ""FORM_OF_USE"", SQL_IDENTIFIER);
						 addColumn(t, ""DEFAULT_COLLATE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""DEFAULT_COLLATE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""DEFAULT_COLLATE_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[CHARACTER_SETS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2 }
						, false);
						 return t;
					 }
					 final int character_set_catalog = 0;
					 final int character_set_schema = 1;
					 final int character_set_name = 2;
					 final int character_repertoire = 3;
					 final int form_of_use = 4;
					 final int default_collate_catalog = 5;
					 final int default_collate_schema = 6;
					 final int default_collate_name = 7;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it = database.schemaManager.databaseObjectIterator( SchemaObject.CHARSET);
					 while (it.hasNext()) {
						 Charset charset = (Charset) it.next();
						 if (!session.getGrantee().isAccessible(charset)) {
							 continue;
						 }
						 Object[] data = t.getEmptyRowData();
						 data[character_set_catalog] = database.getCatalogName().name;
						 data[character_set_schema] = charset.getSchemaName().name;
						 data[character_set_name] = charset.getName().name;
						 data[character_repertoire] = ""UCS"";
						 data[form_of_use] = ""UTF16"";
						 data[default_collate_catalog] = data[character_set_catalog];
						 if (charset.base == null) {
							 data[default_collate_schema] = data[character_set_schema];
							 data[default_collate_name] = data[character_set_name];
						 }
						 else {
							 data[default_collate_schema] = charset.base.schema.name;
							 data[default_collate_name] = charset.base.name;
						 }
						 t.insertSys(store, data);
					 }
					 return t;
				 }
				 Table CHECK_CONSTRAINT_ROUTINE_USAGE(Session session) {
					 Table t = sysTables[CHECK_CONSTRAINT_ROUTINE_USAGE];
					 if (t == null) {
						 t = createBlankTable( sysTableHsqlNames[CHECK_CONSTRAINT_ROUTINE_USAGE]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[CHECK_CONSTRAINT_ROUTINE_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5 }
						, false);
						 return t;
					 }
					 final int constraint_catalog = 0;
					 final int constraint_schema = 1;
					 final int constraint_name = 2;
					 final int specific_catalog = 3;
					 final int specific_schema = 4;
					 final int specific_name = 5;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator constraints;
					 Constraint constraint;
					 OrderedHashSet references;
					 RoutineSchema routine;
					 Object[] row;
					 constraints = database.schemaManager.databaseObjectIterator( SchemaObject.CONSTRAINT);
					 while (constraints.hasNext()) {
						 HsqlName constraintName = (HsqlName) constraints.next();
						 if (constraintName.parent == null) {
							 continue;
						 }
						 if (!session.getGrantee().isFullyAccessibleByRole( constraintName.parent)) {
							 continue;
						 }
						 switch (constraintName.parent.type) {
							 case SchemaObject.TABLE : {
								 Table table;
								 try {
									 table = (Table) database.schemaManager.getSchemaObject( constraintName.parent.name, constraintName.parent.schema.name, SchemaObject.TABLE);
								 }
								 catch (Exception e) {
									 continue;
								 }
								 constraint = table.getConstraint(constraintName.name);
								 if (constraint.getConstraintType() != SchemaObject.ConstraintTypes.CHECK) {
									 continue;
								 }
								 break;
							 }
							 case SchemaObject.DOMAIN : {
								 Type domain;
								 try {
									 domain = (Type) database.schemaManager.getSchemaObject( constraintName.parent.name, constraintName.parent.schema.name, SchemaObject.DOMAIN);
								 }
								 catch (Exception e) {
									 continue;
								 }
								 constraint = domain.userTypeModifier.getConstraint( constraintName.name);
							 }
							 default : continue;
						 }
						 references = constraint.getReferences();
						 for (int i = 0;
						 i < references.size();
						 i++) {
							 HsqlName name = (HsqlName) references.get(i);
							 if (name.type != SchemaObject.SPECIFIC_ROUTINE) {
								 continue;
							 }
							 row = t.getEmptyRowData();
							 row[constraint_catalog] = database.getCatalogName();
							 row[constraint_schema] = constraint.getSchemaName().name;
							 row[constraint_name] = constraint.getName().name;
							 row[specific_catalog] = database.getCatalogName();
							 row[specific_schema] = name.schema.name;
							 row[specific_name] = name.name;
							 t.insertSys(store, row);
						 }
					 }
					 return t;
				 }
				 Table CHECK_CONSTRAINTS(Session session) {
					 Table t = sysTables[CHECK_CONSTRAINTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[CHECK_CONSTRAINTS]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""CHECK_CLAUSE"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[CHECK_CONSTRAINTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 2, 1, 0 }
						, false);
						 return t;
					 }
					 final int constraint_catalog = 0;
					 final int constraint_schema = 1;
					 final int constraint_name = 2;
					 final int check_clause = 3;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator tables;
					 Table table;
					 Constraint[] tableConstraints;
					 int constraintCount;
					 Constraint constraint;
					 Object[] row;
					 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
					 while (tables.hasNext()) {
						 table = (Table) tables.next();
						 if (table.isView() || !session.getGrantee().isFullyAccessibleByRole( table.getName())) {
							 continue;
						 }
						 tableConstraints = table.getConstraints();
						 constraintCount = tableConstraints.length;
						 for (int i = 0;
						 i < constraintCount;
						 i++) {
							 constraint = tableConstraints[i];
							 if (constraint.getConstraintType() != SchemaObject.ConstraintTypes.CHECK) {
								 continue;
							 }
							 row = t.getEmptyRowData();
							 row[constraint_catalog] = database.getCatalogName().name;
							 row[constraint_schema] = table.getSchemaName().name;
							 row[constraint_name] = constraint.getName().name;
							 try {
								 row[check_clause] = constraint.getCheckSQL();
							 }
							 catch (Exception e) {
							}
							 t.insertSys(store, row);
						 }
					 }
					 Iterator it = database.schemaManager.databaseObjectIterator(SchemaObject.DOMAIN);
					 while (it.hasNext()) {
						 Type domain = (Type) it.next();
						 if (!domain.isDomainType()) {
							 continue;
						 }
						 if (!session.getGrantee().isFullyAccessibleByRole( domain.getName())) {
							 continue;
						 }
						 tableConstraints = domain.userTypeModifier.getConstraints();
						 constraintCount = tableConstraints.length;
						 for (int i = 0;
						 i < constraintCount;
						 i++) {
							 constraint = tableConstraints[i];
							 row = t.getEmptyRowData();
							 row[constraint_catalog] = database.getCatalogName().name;
							 row[constraint_schema] = domain.getSchemaName().name;
							 row[constraint_name] = constraint.getName().name;
							 try {
								 row[check_clause] = constraint.getCheckSQL();
							 }
							 catch (Exception e) {
							}
							 t.insertSys(store, row);
						 }
					 }
					 return t;
				 }
				 Table COLLATIONS(Session session) {
					 Table t = sysTables[COLLATIONS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[COLLATIONS]);
						 addColumn(t, ""COLLATION_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""PAD_ATTRIBUTE"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[COLLATIONS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2 }
						, false);
						 return t;
					 }
					 final int collation_catalog = 0;
					 final int collation_schema = 1;
					 final int collation_name = 2;
					 final int pad_attribute = 3;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator collations;
					 String collation;
					 String collationSchema = SqlInvariants.PUBLIC_SCHEMA;
					 String padAttribute = ""NO PAD"";
					 Object[] row;
					 collations = Collation.nameToJavaName.keySet().iterator();
					 while (collations.hasNext()) {
						 row = t.getEmptyRowData();
						 collation = (String) collations.next();
						 row[collation_catalog] = database.getCatalogName().name;
						 row[collation_schema] = collationSchema;
						 row[collation_name] = collation;
						 row[pad_attribute] = padAttribute;
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table COLUMN_COLUMN_USAGE(Session session) {
					 Table t = sysTables[COLUMN_COLUMN_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[COLUMN_COLUMN_USAGE]);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DEPENDENT_COLUMN"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[COLUMN_COLUMN_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4 }
						, false);
						 return t;
					 }
					 final int table_catalog = 0;
					 final int table_schema = 1;
					 final int table_name = 2;
					 final int column_name = 3;
					 final int dependent_column = 4;
					 return t;
				 }
				 Table COLUMN_DOMAIN_USAGE(Session session) {
					 Table t = sysTables[COLUMN_DOMAIN_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[COLUMN_DOMAIN_USAGE]);
						 addColumn(t, ""DOMAIN_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[COLUMN_DOMAIN_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5, 6 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT DOMAIN_CATALOG, DOMAIN_SCHEMA, DOMAIN_NAME, TABLE_CATALOG, "" + ""TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS "" + ""WHERE DOMAIN_NAME IS NOT NULL;
					"", ResultProperties.defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table COLUMN_UDT_USAGE(Session session) {
					 Table t = sysTables[COLUMN_UDT_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[COLUMN_UDT_USAGE]);
						 addColumn(t, ""UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[COLUMN_UDT_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5, 6 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT UDT_CATALOG, UDT_SCHEMA, UDT_NAME, TABLE_CATALOG, "" + ""TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS "" + ""WHERE UDT_NAME IS NOT NULL;
					"", ResultProperties.defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table COLUMNS(Session session) {
					 Table t = sysTables[COLUMNS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[COLUMNS]);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ORDINAL_POSITION"", CARDINAL_NUMBER);
						 addColumn(t, ""COLUMN_DEFAULT"", CHARACTER_DATA);
						 addColumn(t, ""IS_NULLABLE"", YES_OR_NO);
						 addColumn(t, ""DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""CHARACTER_MAXIMUM_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_OCTET_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_PRECISION_RADIX"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_SCALE"", CARDINAL_NUMBER);
						 addColumn(t, ""DATETIME_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""INTERVAL_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""INTERVAL_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_SET_CATALOG"", CHARACTER_DATA);
						 addColumn(t, ""CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""MAXIMUM_CARDINALITY"", CARDINAL_NUMBER);
						 addColumn(t, ""DTD_IDENTIFIER"", SQL_IDENTIFIER);
						 addColumn(t, ""IS_SELF_REFERENCING"", YES_OR_NO);
						 addColumn(t, ""IS_IDENTITY"", YES_OR_NO);
						 addColumn(t, ""IDENTITY_GENERATION"", CHARACTER_DATA);
						 addColumn(t, ""IDENTITY_START"", CHARACTER_DATA);
						 addColumn(t, ""IDENTITY_INCREMENT"", CHARACTER_DATA);
						 addColumn(t, ""IDENTITY_MAXIMUM"", CHARACTER_DATA);
						 addColumn(t, ""IDENTITY_MINIMUM"", CHARACTER_DATA);
						 addColumn(t, ""IDENTITY_CYCLE"", YES_OR_NO);
						 addColumn(t, ""IS_GENERATED"", CHARACTER_DATA);
						 addColumn(t, ""GENERATION_EXPRESSION"", CHARACTER_DATA);
						 addColumn(t, ""IS_UPDATABLE"", YES_OR_NO);
						 addColumn(t, ""DECLARED_DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""DECLARED_NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""DECLARED_NUMERIC_SCALE"", CARDINAL_NUMBER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[COLUMNS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 3, 2, 1, 4 }
						, false);
						 return t;
					 }
					 final int table_cat = 0;
					 final int table_schem = 1;
					 final int table_name = 2;
					 final int column_name = 3;
					 final int ordinal_position = 4;
					 final int column_default = 5;
					 final int is_nullable = 6;
					 final int data_type = 7;
					 final int character_maximum_length = 8;
					 final int character_octet_length = 9;
					 final int numeric_precision = 10;
					 final int numeric_precision_radix = 11;
					 final int numeric_scale = 12;
					 final int datetime_precision = 13;
					 final int interval_type = 14;
					 final int interval_precision = 15;
					 final int character_set_catalog = 16;
					 final int character_set_schema = 17;
					 final int character_set_name = 18;
					 final int collation_catalog = 19;
					 final int collation_schema = 20;
					 final int collation_name = 21;
					 final int domain_catalog = 22;
					 final int domain_schema = 23;
					 final int domain_name = 24;
					 final int udt_catalog = 25;
					 final int udt_schema = 26;
					 final int udt_name = 27;
					 final int scope_catalog = 28;
					 final int scope_schema = 29;
					 final int scope_name = 30;
					 final int maximum_cardinality = 31;
					 final int dtd_identifier = 32;
					 final int is_self_referencing = 33;
					 final int is_identity = 34;
					 final int identity_generation = 35;
					 final int identity_start = 36;
					 final int identity_increment = 37;
					 final int identity_maximum = 38;
					 final int identity_minimum = 39;
					 final int identity_cycle = 40;
					 final int is_generated = 41;
					 final int generation_expression = 42;
					 final int is_updatable = 43;
					 final int declared_data_type = 44;
					 final int declared_numeric_precision = 45;
					 final int declared_numeric_scale = 46;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 int columnCount;
					 Iterator tables;
					 Table table;
					 Object[] row;
					 OrderedHashSet columnList;
					 Type type;
					 tables = allTables();
					 while (tables.hasNext()) {
						 table = (Table) tables.next();
						 columnList = session.getGrantee().getColumnsForAllPrivileges(table);
						 if (columnList.isEmpty()) {
							 continue;
						 }
						 columnCount = table.getColumnCount();
						 for (int i = 0;
						 i < columnCount;
						 i++) {
							 ColumnSchema column = table.getColumn(i);
							 type = column.getDataType();
							 if (!columnList.contains(column.getName())) {
								 continue;
							 }
							 row = t.getEmptyRowData();
							 row[table_cat] = database.getCatalogName().name;
							 row[table_schem] = table.getSchemaName().name;
							 row[table_name] = table.getName().name;
							 row[column_name] = column.getName().name;
							 row[ordinal_position] = ValuePool.getLong(i + 1);
							 row[column_default] = column.getDefaultSQL();
							 row[is_nullable] = column.isNullable() ? ""YES"" : ""NO"";
							 row[data_type] = type.getFullNameString();
							 if (type.isCharacterType()) {
								 row[character_maximum_length] = ValuePool.getLong(type.precision);
								 row[character_octet_length] = ValuePool.getLong(type.precision * 2);
								 row[character_set_catalog] = database.getCatalogName().name;
								 row[character_set_schema] = ((CharacterType) type).getCharacterSet() .getSchemaName().name;
								 row[character_set_name] = ((CharacterType) type).getCharacterSet().getName() .name;
								 row[collation_catalog] = database.getCatalogName().name;
								 row[collation_schema] = ((CharacterType) type).getCollation().getSchemaName() .name;
								 row[collation_name] = ((CharacterType) type).getCollation().getName().name;
							 }
							 else if (type.isNumberType()) {
								 row[numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
								 row[declared_numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
								 if (type.isExactNumberType()) {
									 row[numeric_scale] = row[declared_numeric_scale] = ValuePool.getLong(type.scale);
								 }
								 row[numeric_precision_radix] = ValuePool.getLong(type.getPrecisionRadix());
							 }
							 else if (type.isBooleanType()) {
							 }
							 else if (type.isDateTimeType()) {
								 row[datetime_precision] = ValuePool.getLong(type.scale);
							 }
							 else if (type.isIntervalType()) {
								 row[data_type] = ""INTERVAL"";
								 row[interval_type] = ((IntervalType) type).getQualifier(type.typeCode);
								 row[interval_precision] = ValuePool.getLong(type.precision);
								 row[datetime_precision] = ValuePool.getLong(type.scale);
							 }
							 else if (type.isBinaryType()) {
								 row[character_maximum_length] = ValuePool.getLong(type.precision);
								 row[character_octet_length] = ValuePool.getLong(type.precision);
							 }
							 else if (type.isBitType()) {
								 row[character_maximum_length] = ValuePool.getLong(type.precision);
								 row[character_octet_length] = ValuePool.getLong(type.precision);
							 }
							 else if (type.isArrayType()) {
								 row[maximum_cardinality] = ValuePool.getLong(type.arrayLimitCardinality());
							 }
							 if (type.isDomainType()) {
								 row[domain_catalog] = database.getCatalogName().name;
								 row[domain_schema] = type.getSchemaName().name;
								 row[domain_name] = type.getName().name;
							 }
							 if (type.isDistinctType()) {
								 row[udt_catalog] = database.getCatalogName().name;
								 row[udt_schema] = type.getSchemaName().name;
								 row[udt_name] = type.getName().name;
							 }
							 row[scope_catalog] = null;
							 row[scope_schema] = null;
							 row[scope_name] = null;
							 row[dtd_identifier] = null;
							 row[is_self_referencing] = null;
							 row[is_identity] = column.isIdentity() ? ""YES"" : ""NO"";
							 if (column.isIdentity()) {
								 NumberSequence sequence = column.getIdentitySequence();
								 row[identity_generation] = sequence.isAlways() ? ""ALWAYS"" : ""BY DEFAULT"";
								 row[identity_start] = Long.toString(sequence.getStartValue());
								 row[identity_increment] = Long.toString(sequence.getIncrement());
								 row[identity_maximum] = Long.toString(sequence.getMaxValue());
								 row[identity_minimum] = Long.toString(sequence.getMinValue());
								 row[identity_cycle] = sequence.isCycle() ? ""YES"" : ""NO"";
							 }
							 row[is_generated] = ""NEVER"";
							 if (column.isGenerated()) {
								 row[is_generated] = ""ALWAYS"";
								 row[generation_expression] = column.getGeneratingExpression().getSQL();
							 }
							 row[is_updatable] = table.isWritable() ? ""YES"" : ""NO"";
							 row[declared_data_type] = row[data_type];
							 if (type.isNumberType()) {
								 row[declared_numeric_precision] = row[numeric_precision];
								 row[declared_numeric_scale] = row[numeric_scale];
							 }
							 t.insertSys(store, row);
						 }
					 }
					 return t;
				 }
				 Table CONSTRAINT_COLUMN_USAGE(Session session) {
					 Table t = sysTables[CONSTRAINT_COLUMN_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[CONSTRAINT_COLUMN_USAGE]);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[CONSTRAINT_COLUMN_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5, 6 }
						, false);
						 return t;
					 }
					 final int table_catalog = 0;
					 final int table_schems = 1;
					 final int table_name = 2;
					 final int column_name = 3;
					 final int constraint_catalog = 4;
					 final int constraint_schema = 5;
					 final int constraint_name = 6;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 String constraintCatalog;
					 String constraintSchema;
					 String constraintName;
					 Iterator tables;
					 Table table;
					 Constraint[] constraints;
					 int constraintCount;
					 Constraint constraint;
					 Iterator iterator;
					 Object[] row;
					 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
					 while (tables.hasNext()) {
						 table = (Table) tables.next();
						 if (table.isView() || !session.getGrantee().isFullyAccessibleByRole( table.getName())) {
							 continue;
						 }
						 constraints = table.getConstraints();
						 constraintCount = constraints.length;
						 constraintCatalog = database.getCatalogName().name;
						 constraintSchema = table.getSchemaName().name;
						 for (int i = 0;
						 i < constraintCount;
						 i++) {
							 constraint = constraints[i];
							 constraintName = constraint.getName().name;
							 switch (constraint.getConstraintType()) {
								 case SchemaObject.ConstraintTypes.CHECK : {
									 OrderedHashSet expressions = constraint.getCheckColumnExpressions();
									 if (expressions == null) {
										 break;
									 }
									 iterator = expressions.iterator();
									 while (iterator.hasNext()) {
										 ExpressionColumn expr = (ExpressionColumn) iterator.next();
										 HsqlName name = expr.getBaseColumnHsqlName();
										 if (name.type != SchemaObject.COLUMN) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[table_catalog] = database.getCatalogName().name;
										 row[table_schems] = name.schema.name;
										 row[table_name] = name.parent.name;
										 row[column_name] = name.name;
										 row[constraint_catalog] = constraintCatalog;
										 row[constraint_schema] = constraintSchema;
										 row[constraint_name] = constraintName;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
									 break;
								 }
								 case SchemaObject.ConstraintTypes.UNIQUE : case SchemaObject.ConstraintTypes.PRIMARY_KEY : case SchemaObject.ConstraintTypes.FOREIGN_KEY : {
									 Table target = table;
									 int[] cols = constraint.getMainColumns();
									 if (constraint.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY) {
										 target = constraint.getMain();
									 }
									 for (int j = 0;
									 j < cols.length;
									 j++) {
										 row = t.getEmptyRowData();
										 row[table_catalog] = database.getCatalogName().name;
										 row[table_schems] = constraintSchema;
										 row[table_name] = target.getName().name;
										 row[column_name] = target.getColumn(cols[j]).getName().name;
										 row[constraint_catalog] = constraintCatalog;
										 row[constraint_schema] = constraintSchema;
										 row[constraint_name] = constraintName;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
							 }
						 }
					 }
					 return t;
				 }
				 Table CONSTRAINT_TABLE_USAGE(Session session) {
					 Table t = sysTables[CONSTRAINT_TABLE_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[CONSTRAINT_TABLE_USAGE]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[CONSTRAINT_TABLE_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""select DISTINCT CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, "" + ""CONSTRAINT_NAME, TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME "" + ""from INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE"", ResultProperties .defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table DATA_TYPE_PRIVILEGES(Session session) {
					 Table t = sysTables[DATA_TYPE_PRIVILEGES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[DATA_TYPE_PRIVILEGES]);
						 addColumn(t, ""OBJECT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_TYPE"", SQL_IDENTIFIER);
						 addColumn(t, ""DTD_IDENTIFIER"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[DATA_TYPE_PRIVILEGES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 String sql = (String) statementMap.get("""");
					 Result rs = sys.executeDirectStatement(sql, ResultProperties.defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table DOMAIN_CONSTRAINTS(Session session) {
					 Table t = sysTables[DOMAIN_CONSTRAINTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[DOMAIN_CONSTRAINTS]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""IS_DEFERRABLE"", YES_OR_NO);
						 addColumn(t, ""INITIALLY_DEFERRED"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[DOMAIN_CONSTRAINTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 4, 5, 6 }
						, false);
						 return t;
					 }
					 final int constraint_catalog = 0;
					 final int constraint_schema = 1;
					 final int constraint_name = 2;
					 final int domain_catalog = 3;
					 final int domain_schema = 4;
					 final int domain_name = 5;
					 final int is_deferrable = 6;
					 final int initially_deferred = 7;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it = database.schemaManager.databaseObjectIterator(SchemaObject.DOMAIN);
					 while (it.hasNext()) {
						 Type domain = (Type) it.next();
						 if (!domain.isDomainType()) {
							 continue;
						 }
						 if (!session.getGrantee().isFullyAccessibleByRole( domain.getName())) {
							 continue;
						 }
						 Constraint[] constraints = domain.userTypeModifier.getConstraints();
						 for (int i = 0;
						 i < constraints.length;
						 i++) {
							 Object[] data = t.getEmptyRowData();
							 data[constraint_catalog] = data[domain_catalog] = database.getCatalogName().name;
							 data[constraint_schema] = data[domain_schema] = domain.getSchemaName().name;
							 data[constraint_name] = constraints[i].getName().name;
							 data[domain_name] = domain.getName().name;
							 data[is_deferrable] = Tokens.T_NO;
							 data[initially_deferred] = Tokens.T_NO;
							 t.insertSys(store, data);
						 }
					 }
					 return t;
				 }
				 Table DOMAINS(Session session) {
					 Table t = sysTables[DOMAINS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[DOMAINS]);
						 addColumn(t, ""DOMAIN_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""DOMAIN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DATA_TYPE"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_MAXIMUM_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_OCTET_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_PRECISION_RADIX"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_SCALE"", CARDINAL_NUMBER);
						 addColumn(t, ""DATETIME_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""INTERVAL_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""INTERVAL_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""DOMAIN_DEFAULT"", CHARACTER_DATA);
						 addColumn(t, ""MAXIMUM_CARDINALITY"", CARDINAL_NUMBER);
						 addColumn(t, ""DTD_IDENTIFIER"", SQL_IDENTIFIER);
						 addColumn(t, ""DECLARED_DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""DECLARED_NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""DECLARED_NUMERIC_SCLAE"", CARDINAL_NUMBER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[DOMAINS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 4, 5, 6 }
						, false);
						 return t;
					 }
					 final int domain_catalog = 0;
					 final int domain_schema = 1;
					 final int domain_name = 2;
					 final int data_type = 3;
					 final int character_maximum_length = 4;
					 final int character_octet_length = 5;
					 final int character_set_catalog = 6;
					 final int character_set_schema = 7;
					 final int character_set_name = 8;
					 final int collation_catalog = 9;
					 final int collation_schema = 10;
					 final int collation_name = 11;
					 final int numeric_precision = 12;
					 final int numeric_precision_radix = 13;
					 final int numeric_scale = 14;
					 final int datetime_precision = 15;
					 final int interval_type = 16;
					 final int interval_precision = 17;
					 final int domain_default = 18;
					 final int maximum_cardinality = 19;
					 final int dtd_identifier = 20;
					 final int declared_data_type = 21;
					 final int declared_numeric_precision = 22;
					 final int declared_numeric_scale = 23;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it = database.schemaManager.databaseObjectIterator(SchemaObject.DOMAIN);
					 while (it.hasNext()) {
						 Type type = (Type) it.next();
						 if (!type.isDomainType()) {
							 continue;
						 }
						 if (!session.getGrantee().isAccessible(type)) {
							 continue;
						 }
						 Object[] row = t.getEmptyRowData();
						 row[domain_catalog] = database.getCatalogName().name;
						 row[domain_schema] = type.getSchemaName().name;
						 row[domain_name] = type.getName().name;
						 row[data_type] = type.getFullNameString();
						 if (type.isCharacterType()) {
							 row[character_maximum_length] = ValuePool.getLong(type.precision);
							 row[character_octet_length] = ValuePool.getLong(type.precision row[character_set_catalog] = database.getCatalogName().name;
							 row[character_set_schema] = ((CharacterType) type).getCharacterSet().getSchemaName() .name;
							 row[character_set_name] = ((CharacterType) type).getCharacterSet().getName().name;
							 row[collation_catalog] = database.getCatalogName().name;
							 row[collation_schema] = ((CharacterType) type).getCollation().getSchemaName().name;
							 row[collation_name] = ((CharacterType) type).getCollation().getName().name;
						 }
						 else if (type.isNumberType()) {
							 row[numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
							 row[declared_numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
							 if (type.isExactNumberType()) {
								 row[numeric_scale] = row[declared_numeric_scale] = ValuePool.getLong(type.scale);
							 }
							 row[numeric_precision_radix] = ValuePool.getLong(type.getPrecisionRadix());
						 }
						 else if (type.isBooleanType()) {
						 }
						 else if (type.isDateTimeType()) {
							 row[datetime_precision] = ValuePool.getLong(type.scale);
						 }
						 else if (type.isIntervalType()) {
							 row[data_type] = ""INTERVAL"";
							 row[interval_type] = ((IntervalType) type).getQualifier(type.typeCode);
							 row[interval_precision] = ValuePool.getLong(type.precision);
							 row[datetime_precision] = ValuePool.getLong(type.scale);
						 }
						 else if (type.isBinaryType()) {
							 row[character_maximum_length] = ValuePool.getLong(type.precision);
							 row[character_octet_length] = ValuePool.getLong(type.precision);
						 }
						 else if (type.isBitType()) {
							 row[character_maximum_length] = ValuePool.getLong(type.precision);
							 row[character_octet_length] = ValuePool.getLong(type.precision);
						 }
						 else if (type.isArrayType()) {
							 row[maximum_cardinality] = ValuePool.getLong(type.arrayLimitCardinality());
						 }
						 Expression defaultExpression = type.userTypeModifier.getDefaultClause();
						 if (defaultExpression != null) {
							 row[domain_default] = defaultExpression.getSQL();
						 }
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table ENABLED_ROLES(Session session) {
					 Table t = sysTables[ENABLED_ROLES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ENABLED_ROLES]);
						 addColumn(t, ""ROLE_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ENABLED_ROLES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[]{
						 0 }
						, true);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator grantees;
					 Grantee grantee;
					 Object[] row;
					 grantees = session.getGrantee().getAllRoles().iterator();
					 while (grantees.hasNext()) {
						 grantee = (Grantee) grantees.next();
						 row = t.getEmptyRowData();
						 row[0] = grantee.getNameString();
						 t.insertSys(store, row);
					 }
					 return t;
				 }
				 Table JAR_JAR_USAGE(Session session) {
					 Table t = sysTables[JAR_JAR_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[JAR_JAR_USAGE]);
						 addColumn(t, ""PATH_JAR_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""PATH_JAR_SCHAMA"", SQL_IDENTIFIER);
						 addColumn(t, ""PATH_JAR_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[JAR_JAR_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5 }
						, false);
						 return t;
					 }
					 final int path_jar_catalog = 0;
					 final int path_jar_schema = 1;
					 final int path_jar_name = 2;
					 final int jar_catalog = 3;
					 final int jar_schema = 4;
					 final int jar_name = 5;
					 Iterator it;
					 Object[] row;
					 return t;
				 }
				 Table JARS(Session session) {
					 Table t = sysTables[JARS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[JARS]);
						 addColumn(t, ""JAR_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_PATH"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[JARS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3 }
						, false);
						 return t;
					 }
					 final int jar_catalog = 0;
					 final int jar_schema = 1;
					 final int jar_name = 2;
					 final int jar_path = 3;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it;
					 Object[] row;
					 return t;
				 }
				 Table KEY_COLUMN_USAGE(Session session) {
					 Table t = sysTables[KEY_COLUMN_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[KEY_COLUMN_USAGE]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ORDINAL_POSITION"", CARDINAL_NUMBER);
						 addColumn(t, ""POSITION_IN_UNIQUE_CONSTRAINT"", CARDINAL_NUMBER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[KEY_COLUMN_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 2, 1, 0, 6, 7 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator tables;
					 Object[] row;
					 final int constraint_catalog = 0;
					 final int constraint_schema = 1;
					 final int constraint_name = 2;
					 final int table_catalog = 3;
					 final int table_schema = 4;
					 final int table_name = 5;
					 final int column_name = 6;
					 final int ordinal_position = 7;
					 final int position_in_unique_constraint = 8;
					 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
					 while (tables.hasNext()) {
						 Table table = (Table) tables.next();
						 String tableCatalog = database.getCatalogName().name;
						 String tableSchema = table.getSchemaName().name;
						 String tableName = table.getName().name;
						 if (table.isView() || !isAccessibleTable(session, table)) {
							 continue;
						 }
						 Constraint[] constraints = table.getConstraints();
						 for (int i = 0;
						 i < constraints.length;
						 i++) {
							 Constraint constraint = constraints[i];
							 if (constraint.getConstraintType() == SchemaObject .ConstraintTypes.PRIMARY_KEY || constraint .getConstraintType() == SchemaObject.ConstraintTypes .UNIQUE || constraint .getConstraintType() == SchemaObject.ConstraintTypes .FOREIGN_KEY) {
								 String constraintName = constraint.getName().name;
								 int[] cols = constraint.getMainColumns();
								 int[] uniqueColMap = null;
								 if (constraint.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY) {
									 Table uniqueConstTable = constraint.getMain();
									 Constraint uniqueConstraint = uniqueConstTable.getConstraint( constraint.getUniqueName().name);
									 int[] uniqueConstIndexes = uniqueConstraint.getMainColumns();
									 uniqueColMap = new int[cols.length];
									 for (int j = 0;
									 j < cols.length;
									 j++) {
										 uniqueColMap[j] = ArrayUtil.find(uniqueConstIndexes, cols[j]);
									 }
									 cols = constraint.getRefColumns();
								 }
								 for (int j = 0;
								 j < cols.length;
								 j++) {
									 row = t.getEmptyRowData();
									 row[constraint_catalog] = tableCatalog;
									 row[constraint_schema] = tableSchema;
									 row[constraint_name] = constraintName;
									 row[table_catalog] = tableCatalog;
									 row[table_schema] = tableSchema;
									 row[table_name] = tableName;
									 row[column_name] = table.getColumn(cols[j]).getName().name;
									 row[ordinal_position] = ValuePool.getLong(j + 1);
									 if (constraint.getConstraintType() == SchemaObject.ConstraintTypes.FOREIGN_KEY) {
										 row[position_in_unique_constraint] = ValuePool.getInt(uniqueColMap[j] + 1);
									 }
									 t.insertSys(store, row);
								 }
							 }
						 }
					 }
					 return t;
				 }
				 Table METHOD_SPECIFICATION_PARAMETERS(Session session) {
					 return null;
				 }
				 Table METHOD_SPECIFICATIONS(Session session) {
					 return null;
				 }
				 Table MODULE_COLUMN_USAGE(Session session) {
					 return null;
				 }
				 Table MODULE_PRIVILEGES(Session session) {
					 return null;
				 }
				 Table MODULE_TABLE_USAGE(Session session) {
					 return null;
				 }
				 Table MODULES(Session session) {
					 return null;
				 }
				 Table PARAMETERS(Session session) {
					 Table t = sysTables[PARAMETERS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[PARAMETERS]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ORDINAL_POSITION"", CARDINAL_NUMBER);
						 addColumn(t, ""PARAMETER_MODE"", CHARACTER_DATA);
						 addColumn(t, ""IS_RESULT"", YES_OR_NO);
						 addColumn(t, ""AS_LOCATOR"", YES_OR_NO);
						 addColumn(t, ""PARAMETER_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""FROM_SQL_SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""FROM_SQL_SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""FROM_SQL_SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TO_SQL_SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TO_SQL_SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TO_SQL_SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""CHARACTER_MAXIMUM_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_OCTET_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_SET_CATALOG"", CHARACTER_DATA);
						 addColumn(t, ""CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_PRECISION_RADIX"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_SCALE"", CARDINAL_NUMBER);
						 addColumn(t, ""DATETIME_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""INTERVAL_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""INTERVAL_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""MAXIMUM_CARDINALITY"", CARDINAL_NUMBER);
						 addColumn(t, ""DTD_IDENTIFIER"", SQL_IDENTIFIER);
						 addColumn(t, ""DECLARED_DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""DECLARED_NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""DECLARED_NUMERIC_SCALE"", CARDINAL_NUMBER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[PARAMETERS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 final int specific_cat = 0;
					 final int specific_schem = 1;
					 final int specific_name = 2;
					 final int ordinal_position = 3;
					 final int parameter_mode = 4;
					 final int is_result = 5;
					 final int as_locator = 6;
					 final int parameter_name = 7;
					 final int from_specific_catalog = 8;
					 final int from_specific_schema = 9;
					 final int from_specific_name = 10;
					 final int to_specific_catalog = 11;
					 final int to_specific_schema = 12;
					 final int to_specific_name = 13;
					 final int data_type = 14;
					 final int character_maximum_length = 15;
					 final int character_octet_length = 16;
					 final int character_set_catalog = 17;
					 final int character_set_schema = 18;
					 final int character_set_name = 19;
					 final int collation_catalog = 20;
					 final int collation_schema = 21;
					 final int collation_name = 22;
					 final int numeric_precision = 23;
					 final int numeric_precision_radix = 24;
					 final int numeric_scale = 25;
					 final int datetime_precision = 26;
					 final int interval_type = 27;
					 final int interval_precision = 28;
					 final int udt_catalog = 29;
					 final int udt_schema = 30;
					 final int udt_name = 31;
					 final int scope_catalog = 32;
					 final int scope_schema = 33;
					 final int scope_name = 34;
					 final int maximum_cardinality = 35;
					 final int dtd_identifier = 36;
					 int columnCount;
					 Iterator routines;
					 RoutineSchema routineSchema;
					 Routine routine;
					 Object[] row;
					 Type type;
					 routines = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (routines.hasNext()) {
						 routineSchema = (RoutineSchema) routines.next();
						 if (!session.getGrantee().isAccessible(routineSchema)) {
							 continue;
						 }
						 Routine[] specifics = routineSchema.getSpecificRoutines();
						 for (int i = 0;
						 i < specifics.length;
						 i++) {
							 routine = specifics[i];
							 columnCount = routine.getParameterCount();
							 for (int j = 0;
							 j < columnCount;
							 j++) {
								 ColumnSchema column = routine.getParameter(j);
								 type = column.getDataType();
								 row = t.getEmptyRowData();
								 row[specific_cat] = database.getCatalogName().name;
								 row[specific_schem] = routine.getSchemaName().name;
								 row[specific_name] = routine.getSpecificName().name;
								 row[parameter_name] = column.getName().name;
								 row[ordinal_position] = ValuePool.getLong(j + 1);
								 switch (column.getParameterMode()) {
									 case SchemaObject.ParameterModes.PARAM_IN : row[parameter_mode] = ""IN"";
									 break;
									 case SchemaObject.ParameterModes.PARAM_OUT : row[parameter_mode] = ""OUT"";
									 break;
									 case SchemaObject.ParameterModes.PARAM_INOUT : row[parameter_mode] = ""INOUT"";
									 break;
								 }
								 row[is_result] = ""NO"";
								 row[as_locator] = ""NO"";
								 row[data_type] = type.getFullNameString();
								 if (type.isCharacterType()) {
									 row[character_maximum_length] = ValuePool.getLong(type.precision);
									 row[character_octet_length] = ValuePool.getLong(type.precision * 2);
									 row[character_set_catalog] = database.getCatalogName().name;
									 row[character_set_schema] = ((CharacterType) type).getCharacterSet() .getSchemaName().name;
									 row[character_set_name] = ((CharacterType) type).getCharacterSet().getName() .name;
									 row[collation_catalog] = database.getCatalogName().name;
									 row[collation_schema] = ((CharacterType) type).getCollation() .getSchemaName().name;
									 row[collation_name] = ((CharacterType) type).getCollation().getName() .name;
								 }
								 else if (type.isNumberType()) {
									 row[numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
									 row[numeric_precision_radix] = ValuePool.getLong(type.getPrecisionRadix());
								 }
								 else if (type.isBooleanType()) {
								 }
								 else if (type.isDateTimeType()) {
									 row[datetime_precision] = ValuePool.getLong(type.scale);
								 }
								 else if (type.isIntervalType()) {
									 row[data_type] = ""INTERVAL"";
									 row[interval_type] = ((IntervalType) type).getQualifier(type.typeCode);
									 row[interval_precision] = ValuePool.getLong(type.precision);
									 row[datetime_precision] = ValuePool.getLong(type.scale);
								 }
								 else if (type.isBinaryType()) {
									 row[character_maximum_length] = ValuePool.getLong(type.precision);
									 row[character_octet_length] = ValuePool.getLong(type.precision);
								 }
								 else if (type.isBitType()) {
									 row[character_maximum_length] = ValuePool.getLong(type.precision);
									 row[character_octet_length] = ValuePool.getLong(type.precision);
								 }
								 else if (type.isArrayType()) {
									 row[maximum_cardinality] = ValuePool.getLong(type.arrayLimitCardinality());
								 }
								 if (type.isDistinctType()) {
									 row[udt_catalog] = database.getCatalogName().name;
									 row[udt_schema] = type.getSchemaName().name;
									 row[udt_name] = type.getName().name;
								 }
								 t.insertSys(store, row);
							 }
						 }
					 }
					 return t;
				 }
				 Table REFERENTIAL_CONSTRAINTS(Session session) {
					 Table t = sysTables[REFERENTIAL_CONSTRAINTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[REFERENTIAL_CONSTRAINTS]);
						 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""UNIQUE_CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""UNIQUE_CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""UNIQUE_CONSTRAINT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""MATCH_OPTION"", CHARACTER_DATA);
						 addColumn(t, ""UPDATE_RULE"", CHARACTER_DATA);
						 addColumn(t, ""DELETE_RULE"", CHARACTER_DATA);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[REFERENTIAL_CONSTRAINTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, }
						, false);
						 return t;
					 }
					 final int constraint_catalog = 0;
					 final int constraint_schema = 1;
					 final int constraint_name = 2;
					 final int unique_constraint_catalog = 3;
					 final int unique_constraint_schema = 4;
					 final int unique_constraint_name = 5;
					 final int match_option = 6;
					 final int update_rule = 7;
					 final int delete_rule = 8;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator tables;
					 Table table;
					 Constraint[] constraints;
					 Constraint constraint;
					 Object[] row;
					 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
					 while (tables.hasNext()) {
						 table = (Table) tables.next();
						 if (table.isView() || !session.getGrantee().hasNonSelectTableRight(table)) {
							 continue;
						 }
						 constraints = table.getConstraints();
						 for (int i = 0;
						 i < constraints.length;
						 i++) {
							 constraint = constraints[i];
							 if (constraint.getConstraintType() != SchemaObject.ConstraintTypes.FOREIGN_KEY) {
								 continue;
							 }
							 HsqlName uniqueName = constraint.getUniqueName();
							 row = t.getEmptyRowData();
							 row[constraint_catalog] = database.getCatalogName().name;
							 row[constraint_schema] = constraint.getSchemaName().name;
							 row[constraint_name] = constraint.getName().name;
							 if (isAccessibleTable(session, constraint.getMain())) {
								 row[unique_constraint_catalog] = database.getCatalogName().name;
								 row[unique_constraint_schema] = uniqueName.schema.name;
								 row[unique_constraint_name] = uniqueName.name;
							 }
							 row[match_option] = Tokens.T_NONE;
							 row[update_rule] = constraint.getUpdateActionString();
							 row[delete_rule] = constraint.getDeleteActionString();
							 t.insertSys(store, row);
						 }
					 }
					 return t;
				 }
				 Table ROLE_COLUMN_GRANTS(Session session) {
					 Table t = sysTables[ROLE_COLUMN_GRANTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROLE_COLUMN_GRANTS]);
						 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROLE_COLUMN_GRANTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 5, 6, 1, 0, 4, 3, 2 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT GRANTOR, GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, PRIVILEGE_TYPE, IS_GRANTABLE "" + ""FROM INFORMATION_SCHEMA.COLUMN_PRIVILEGES "" + ""JOIN INFORMATION_SCHEMA.APPLICABLE_ROLES ON GRANTEE = ROLE_NAME;
					"", ResultProperties.defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table ROLE_ROUTINE_GRANTS(Session session) {
					 Table t = sysTables[ROLE_ROUTINE_GRANTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROLE_ROUTINE_GRANTS]);
						 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROLE_ROUTINE_GRANTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT GRANTOR, GRANTEE, SPECIFIC_CATALOG, SPECIFIC_SCHEMA, "" + ""SPECIFIC_NAME, ROUTINE_CATALOG, ROUTINE_SCHEMA, ROUTINE_NAME, "" + ""PRIVILEGE_TYPE, IS_GRANTABLE "" + ""FROM INFORMATION_SCHEMA.ROUTINE_PRIVILEGES "" + ""JOIN INFORMATION_SCHEMA.APPLICABLE_ROLES ON GRANTEE = ROLE_NAME;
					"", ResultProperties .defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 final int grantor = 0;
					 final int grantee = 1;
					 final int table_name = 2;
					 final int specific_catalog = 3;
					 final int specific_schema = 4;
					 final int specific_name = 5;
					 final int routine_catalog = 6;
					 final int routine_schema = 7;
					 final int routine_name = 8;
					 final int privilege_type = 9;
					 final int is_grantable = 10;
					 return t;
				 }
				 Table ROLE_TABLE_GRANTS(Session session) {
					 Table t = sysTables[ROLE_TABLE_GRANTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROLE_TABLE_GRANTS]);
						 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
						 addColumn(t, ""WITH_HIERARCHY"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROLE_TABLE_GRANTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 3, 4, 5, 0, 1 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT GRANTOR, GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, "" + ""PRIVILEGE_TYPE, IS_GRANTABLE, 'NO' "" + ""FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES "" + ""JOIN INFORMATION_SCHEMA.APPLICABLE_ROLES ON GRANTEE = ROLE_NAME;
					"", ResultProperties .defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table ROLE_UDT_GRANTS(Session session) {
					 Table t = sysTables[ROLE_UDT_GRANTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROLE_UDT_GRANTS]);
						 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROLE_TABLE_GRANTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, null, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT GRANTOR, GRANTEE, UDT_CATALOG, UDT_SCHEMA, UDT_NAME, "" + ""PRIVILEGE_TYPE, IS_GRANTABLE "" + ""FROM INFORMATION_SCHEMA.UDT_PRIVILEGES "" + ""JOIN INFORMATION_SCHEMA.APPLICABLE_ROLES ON GRANTEE = ROLE_NAME;
					"", ResultProperties .defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table ROLE_USAGE_GRANTS(Session session) {
					 Table t = sysTables[ROLE_USAGE_GRANTS];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROLE_USAGE_GRANTS]);
						 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""OBJECT_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROLE_USAGE_GRANTS].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5, 6, 7 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
					 Result rs = sys.executeDirectStatement( ""SELECT GRANTOR, GRANTEE, OBJECT_CATALOG, OBJECT_SCHEMA, OBJECT_NAME, "" + ""OBJECT_TYPE, PRIVILEGE_TYPE, IS_GRANTABLE "" + ""FROM INFORMATION_SCHEMA.USAGE_PRIVILEGES "" + ""JOIN INFORMATION_SCHEMA.APPLICABLE_ROLES ON GRANTEE = ROLE_NAME;
					"", ResultProperties .defaultPropsValue);
					 t.insertSys(store, rs);
					 sys.close();
					 return t;
				 }
				 Table ROUTINE_COLUMN_USAGE(Session session) {
					 Table t = sysTables[ROUTINE_COLUMN_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINE_COLUMN_USAGE]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINE_COLUMN_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 3, 4, 5, 0, 1, 2, 6, 7, 8, 9 }
						, false);
						 return t;
					 }
					 PersistentStore store = session.sessionData.getRowStore(t);
					 final int specific_catalog = 0;
					 final int specific_schema = 1;
					 final int specific_name = 2;
					 final int routine_catalog = 3;
					 final int routine_schema = 4;
					 final int routine_name = 5;
					 final int table_catalog = 6;
					 final int table_schema = 7;
					 final int table_name = 8;
					 final int column_name = 9;
					 Iterator it;
					 Object[] row;
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 RoutineSchema routine = (RoutineSchema) it.next();
						 if (!session.getGrantee().isAccessible(routine)) {
							 continue;
						 }
						 Routine[] specifics = routine.getSpecificRoutines();
						 for (int m = 0;
						 m < specifics.length;
						 m++) {
							 OrderedHashSet set = specifics[m].getReferences();
							 for (int i = 0;
							 i < set.size();
							 i++) {
								 HsqlName refName = (HsqlName) set.get(i);
								 if (refName.type != SchemaObject.COLUMN) {
									 continue;
								 }
								 if (!session.getGrantee().isAccessible(refName)) {
									 continue;
								 }
								 row = t.getEmptyRowData();
								 row[specific_catalog] = database.getCatalogName().name;
								 row[specific_schema] = specifics[m].getSchemaName().name;
								 row[specific_name] = specifics[m].getSpecificName().name;
								 row[routine_catalog] = database.getCatalogName().name;
								 row[routine_schema] = routine.getSchemaName().name;
								 row[routine_name] = routine.getName().name;
								 row[table_catalog] = database.getCatalogName().name;
								 row[table_schema] = refName.parent.schema.name;
								 row[table_name] = refName.parent.name;
								 row[column_name] = refName.name;
								 try {
									 t.insertSys(store, row);
								 }
								 catch (HsqlException e) {
								}
							 }
						 }
					 }
					 return t;
				 }
				 Table ROUTINE_PRIVILEGES(Session session) {
					 Table t = sysTables[ROUTINE_PRIVILEGES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINE_PRIVILEGES]);
						 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
						 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINE_PRIVILEGES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
						, false);
						 return t;
					 }
					 final int grantor = 0;
					 final int grantee = 1;
					 final int specific_catalog = 2;
					 final int specific_schema = 3;
					 final int specific_name = 4;
					 final int routine_catalog = 5;
					 final int routine_schema = 6;
					 final int routine_name = 7;
					 final int privilege_type = 8;
					 final int is_grantable = 9;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Grantee granteeObject;
					 String privilege;
					 Iterator routines;
					 RoutineSchema routine;
					 Object[] row;
					 OrderedHashSet grantees = session.getGrantee().getGranteeAndAllRolesWithPublic();
					 routines = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (routines.hasNext()) {
						 routine = (RoutineSchema) routines.next();
						 for (int i = 0;
						 i < grantees.size();
						 i++) {
							 granteeObject = (Grantee) grantees.get(i);
							 OrderedHashSet rights = granteeObject.getAllDirectPrivileges(routine);
							 OrderedHashSet grants = granteeObject.getAllGrantedPrivileges(routine);
							 if (!grants.isEmpty()) {
								 grants.addAll(rights);
								 rights = grants;
							 }
							 for (int j = 0;
							 j < rights.size();
							 j++) {
								 Right right = (Right) rights.get(j);
								 Right grantableRight = right.getGrantableRights();
								 for (int k = 0;
								 k < Right.privilegeTypes.length;
								 k++) {
									 if (!right.canAccessFully(Right.privilegeTypes[k])) {
										 continue;
									 }
									 Routine[] specifics = routine.getSpecificRoutines();
									 for (int m = 0;
									 m < specifics.length;
									 m++) {
										 privilege = Right.privilegeNames[k];
										 row = t.getEmptyRowData();
										 row[grantor] = right.getGrantor().getName().name;
										 row[grantee] = right.getGrantee().getName().name;
										 row[specific_catalog] = database.getCatalogName().name;
										 row[specific_schema] = specifics[m].getSchemaName().name;
										 row[specific_name] = specifics[m].getSpecificName().name;
										 row[routine_catalog] = database.getCatalogName().name;
										 row[routine_schema] = routine.getSchemaName().name;
										 row[routine_name] = routine.getName().name;
										 row[privilege_type] = privilege;
										 row[is_grantable] = right.getGrantee() == routine.getOwner() || grantableRight.canAccessFully( Right.privilegeTypes[k]) ? ""YES"" : ""NO"";
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
							 }
						 }
					 }
					 return t;
				 }
				 Table ROUTINE_JAR_USAGE(Session session) {
					 Table t = sysTables[ROUTINE_JAR_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINE_JAR_USAGE]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""JAR_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINE_JAR_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5 }
						, false);
						 return t;
					 }
					 final int specific_catalog = 0;
					 final int specific_schema = 1;
					 final int specific_name = 2;
					 final int jar_catalog = 3;
					 final int jar_schema = 4;
					 final int jar_name = 5;
					 Iterator it;
					 Object[] row;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 RoutineSchema routine = (RoutineSchema) it.next();
						 if (!session.getGrantee().isAccessible(routine)) {
							 continue;
						 }
						 Routine[] specifics = routine.getSpecificRoutines();
						 for (int m = 0;
						 m < specifics.length;
						 m++) {
							 if (specifics[m].getLanguage() != Routine.LANGUAGE_JAVA) {
								 continue;
							 }
							 row = t.getEmptyRowData();
							 row[specific_catalog] = database.getCatalogName().name;
							 row[specific_schema] = routine.getSchemaName().name;
							 row[specific_name] = routine.getName().name;
							 row[jar_catalog] = database.getCatalogName().name;
							 row[jar_schema] = database.schemaManager.getSQLJSchemaHsqlName();
							 row[jar_name] = ""CLASSPATH"";
							 t.insertSys(store, row);
						 }
					 }
					 return t;
				 }
				 Table ROUTINE_ROUTINE_USAGE(Session session) {
					 Table t = sysTables[ROUTINE_ROUTINE_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINE_ROUTINE_USAGE]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINE_ROUTINE_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5 }
						, false);
						 return t;
					 }
					 final int specific_catalog = 0;
					 final int specific_schema = 1;
					 final int specific_name = 2;
					 final int routine_catalog = 3;
					 final int routine_schema = 4;
					 final int routine_name = 5;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it;
					 Object[] row;
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 RoutineSchema routine = (RoutineSchema) it.next();
						 if (!session.getGrantee().isAccessible(routine)) {
							 continue;
						 }
						 Routine[] specifics = routine.getSpecificRoutines();
						 for (int m = 0;
						 m < specifics.length;
						 m++) {
							 OrderedHashSet set = specifics[m].getReferences();
							 for (int i = 0;
							 i < set.size();
							 i++) {
								 HsqlName refName = (HsqlName) set.get(i);
								 if (refName.type != SchemaObject.SPECIFIC_ROUTINE) {
									 continue;
								 }
								 if (!session.getGrantee().isAccessible(refName)) {
									 continue;
								 }
								 row = t.getEmptyRowData();
								 row[specific_catalog] = database.getCatalogName().name;
								 row[specific_schema] = specifics[m].getSchemaName().name;
								 row[specific_name] = specifics[m].getSpecificName().name;
								 row[routine_catalog] = database.getCatalogName().name;
								 row[routine_schema] = refName.schema.name;
								 row[routine_name] = refName.name;
								 try {
									 t.insertSys(store, row);
								 }
								 catch (HsqlException e) {
								}
							 }
						 }
					 }
					 return t;
				 }
				 Table ROUTINE_SEQUENCE_USAGE(Session session) {
					 Table t = sysTables[ROUTINE_SEQUENCE_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINE_SEQUENCE_USAGE]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""SEQUENCE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SEQUENCE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SEQUENCE_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINE_SEQUENCE_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 0, 1, 2, 3, 4, 5 }
						, false);
						 return t;
					 }
					 final int specific_catalog = 0;
					 final int specific_schema = 1;
					 final int specific_name = 2;
					 final int sequence_catalog = 3;
					 final int sequence_schema = 4;
					 final int sequence_name = 5;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it;
					 Object[] row;
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 RoutineSchema routine = (RoutineSchema) it.next();
						 if (!session.getGrantee().isAccessible(routine)) {
							 continue;
						 }
						 Routine[] specifics = routine.getSpecificRoutines();
						 for (int m = 0;
						 m < specifics.length;
						 m++) {
							 OrderedHashSet set = specifics[m].getReferences();
							 for (int i = 0;
							 i < set.size();
							 i++) {
								 HsqlName refName = (HsqlName) set.get(i);
								 if (refName.type != SchemaObject.SEQUENCE) {
									 continue;
								 }
								 if (!session.getGrantee().isAccessible(refName)) {
									 continue;
								 }
								 row = t.getEmptyRowData();
								 row[specific_catalog] = database.getCatalogName().name;
								 row[specific_schema] = specifics[m].getSchemaName().name;
								 row[specific_name] = specifics[m].getSpecificName().name;
								 row[sequence_catalog] = database.getCatalogName().name;
								 row[sequence_schema] = refName.schema.name;
								 row[sequence_name] = refName.name;
								 try {
									 t.insertSys(store, row);
								 }
								 catch (HsqlException e) {
								}
							 }
						 }
					 }
					 return t;
				 }
				 Table ROUTINE_TABLE_USAGE(Session session) {
					 Table t = sysTables[ROUTINE_TABLE_USAGE];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINE_TABLE_USAGE]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINE_TABLE_USAGE].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 3, 4, 5, 0, 1, 2, 6, 7, 8 }
						, false);
						 return t;
					 }
					 final int specific_catalog = 0;
					 final int specific_schema = 1;
					 final int specific_name = 2;
					 final int routine_catalog = 3;
					 final int routine_schema = 4;
					 final int routine_name = 5;
					 final int table_catalog = 6;
					 final int table_schema = 7;
					 final int table_name = 8;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it;
					 Object[] row;
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 RoutineSchema routine = (RoutineSchema) it.next();
						 if (!session.getGrantee().isAccessible(routine)) {
							 continue;
						 }
						 Routine[] specifics = routine.getSpecificRoutines();
						 for (int m = 0;
						 m < specifics.length;
						 m++) {
							 OrderedHashSet set = specifics[m].getReferences();
							 for (int i = 0;
							 i < set.size();
							 i++) {
								 HsqlName refName = (HsqlName) set.get(i);
								 if (refName.type != SchemaObject.TABLE && refName.type != SchemaObject.VIEW) {
									 continue;
								 }
								 if (!session.getGrantee().isAccessible(refName)) {
									 continue;
								 }
								 row = t.getEmptyRowData();
								 row[specific_catalog] = database.getCatalogName().name;
								 row[specific_schema] = specifics[m].getSchemaName().name;
								 row[specific_name] = specifics[m].getSpecificName().name;
								 row[routine_catalog] = database.getCatalogName().name;
								 row[routine_schema] = routine.getSchemaName().name;
								 row[routine_name] = routine.getName().name;
								 row[table_catalog] = database.getCatalogName().name;
								 row[table_schema] = refName.schema.name;
								 row[table_name] = refName.name;
								 try {
									 t.insertSys(store, row);
								 }
								 catch (HsqlException e) {
								}
							 }
						 }
					 }
					 return t;
				 }
				 Table ROUTINES(Session session) {
					 Table t = sysTables[ROUTINES];
					 if (t == null) {
						 t = createBlankTable(sysTableHsqlNames[ROUTINES]);
						 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""MODULE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""MODULE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""MODULE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""CHARACTER_MAXIMUM_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_OCTET_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""CHARACTER_SET_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""COLLATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_PRECISION_RADIX"", CARDINAL_NUMBER);
						 addColumn(t, ""NUMERIC_SCALE"", CARDINAL_NUMBER);
						 addColumn(t, ""DATETIME_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""INTERVAL_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""INTERVAL_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""TYPE_UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TYPE_UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TYPE_UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""SCOPE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""MAXIMUM_CARDINALITY"", CARDINAL_NUMBER);
						 addColumn(t, ""DTD_IDENTIFIER"", SQL_IDENTIFIER);
						 addColumn(t, ""ROUTINE_BODY"", CHARACTER_DATA);
						 addColumn(t, ""ROUTINE_DEFINITION"", CHARACTER_DATA);
						 addColumn(t, ""EXTERNAL_NAME"", CHARACTER_DATA);
						 addColumn(t, ""EXTERNAL_LANGUAGE"", CHARACTER_DATA);
						 addColumn(t, ""PARAMETER_STYLE"", CHARACTER_DATA);
						 addColumn(t, ""IS_DETERMINISTIC"", YES_OR_NO);
						 addColumn(t, ""SQL_DATA_ACCESS"", CHARACTER_DATA);
						 addColumn(t, ""IS_NULL_CALL"", YES_OR_NO);
						 addColumn(t, ""SQL_PATH"", CHARACTER_DATA);
						 addColumn(t, ""SCHEMA_LEVEL_ROUTINE"", YES_OR_NO);
						 addColumn(t, ""MAX_DYNAMIC_RESULT_SETS"", CARDINAL_NUMBER);
						 addColumn(t, ""IS_USER_DEFINED_CAST"", YES_OR_NO);
						 addColumn(t, ""IS_IMPLICITLY_INVOCABLE"", YES_OR_NO);
						 addColumn(t, ""SECURITY_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""TO_SQL_SPECIFIC_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""TO_SQL_SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""TO_SQL_SPECIFIC_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""AS_LOCATOR"", YES_OR_NO);
						 addColumn(t, ""CREATED"", TIME_STAMP);
						 addColumn(t, ""LAST_ALTERED"", TIME_STAMP);
						 addColumn(t, ""NEW_SAVEPOINT_LEVEL"", YES_OR_NO);
						 addColumn(t, ""IS_UDT_DEPENDENT"", YES_OR_NO);
						 addColumn(t, ""RESULT_CAST_FROM_DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""RESULT_CAST_AS_LOCATOR"", YES_OR_NO);
						 addColumn(t, ""RESULT_CAST_CHAR_MAX_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_CHAR_OCTET_LENGTH"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_CHAR_SET_CATALOG"", CHARACTER_DATA);
						 addColumn(t, ""RESULT_CAST_CHAR_SET_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_CHARACTER_SET_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_COLLATION_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_COLLATION_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_COLLATION_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_NUMERIC_RADIX"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_NUMERIC_SCALE"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_DATETIME_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_INTERVAL_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""RESULT_CAST_INTERVAL_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_TYPE_UDT_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_TYPE_UDT_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_TYPE_UDT_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_SCOPE_CATALOG"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_SCOPE_SCHEMA"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_SCOPE_NAME"", SQL_IDENTIFIER);
						 addColumn(t, ""RESULT_CAST_MAX_CARDINALITY"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_DTD_IDENTIFIER"", CHARACTER_DATA);
						 addColumn(t, ""DECLARED_DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""DECLARED_NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""DECLARED_NUMERIC_SCALE"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_FROM_DECLARED_DATA_TYPE"", CHARACTER_DATA);
						 addColumn(t, ""RESULT_CAST_DECLARED_NUMERIC_PRECISION"", CARDINAL_NUMBER);
						 addColumn(t, ""RESULT_CAST_DECLARED_NUMERIC_SCALE"", CARDINAL_NUMBER);
						 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROUTINES].name, false, SchemaObject.INDEX);
						 t.createPrimaryKeyConstraint(name, new int[] {
						 3, 4, 5, 0, 1, 2 }
						, false);
						 return t;
					 }
					 final int specific_catalog = 0;
					 final int specific_schema = 1;
					 final int specific_name = 2;
					 final int routine_catalog = 3;
					 final int routine_schema = 4;
					 final int routine_name = 5;
					 final int routine_type = 6;
					 final int module_catalog = 7;
					 final int module_schema = 8;
					 final int module_name = 9;
					 final int udt_catalog = 10;
					 final int udt_schema = 11;
					 final int udt_name = 12;
					 final int data_type = 13;
					 final int character_maximum_length = 14;
					 final int character_octet_length = 15;
					 final int character_set_catalog = 16;
					 final int character_set_schema = 17;
					 final int character_set_name = 18;
					 final int collation_catalog = 19;
					 final int collation_schema = 20;
					 final int collation_name = 21;
					 final int numeric_precision = 22;
					 final int numeric_precision_radix = 23;
					 final int numeric_scale = 24;
					 final int datetime_precision = 25;
					 final int interval_type = 26;
					 final int interval_precision = 27;
					 final int type_udt_catalog = 28;
					 final int type_udt_schema = 29;
					 final int type_udt_name = 30;
					 final int scope_catalog = 31;
					 final int scope_schema = 32;
					 final int scope_name = 33;
					 final int maximum_cardinality = 34;
					 final int dtd_identifier = 35;
					 final int routine_body = 36;
					 final int routine_definition = 37;
					 final int external_name = 38;
					 final int external_language = 39;
					 final int parameter_style = 40;
					 final int is_deterministic = 41;
					 final int sql_data_access = 42;
					 final int is_null_call = 43;
					 final int sql_path = 44;
					 final int schema_level_routine = 45;
					 final int max_dynamic_result_sets = 46;
					 final int is_user_defined_cast = 47;
					 final int is_implicitly_invocable = 48;
					 final int security_type = 49;
					 final int to_sql_specific_catalog = 50;
					 final int to_sql_specific_schema = 51;
					 final int to_sql_specific_name = 52;
					 final int as_locator = 53;
					 final int created = 54;
					 final int last_altered = 55;
					 final int new_savepoint_level = 56;
					 final int is_udt_dependent = 57;
					 final int result_cast_from_data_type = 58;
					 final int result_cast_as_locator = 59;
					 final int result_cast_char_max_length = 60;
					 final int result_cast_char_octet_length = 61;
					 final int result_cast_char_set_catalog = 62;
					 final int result_cast_char_set_schema = 63;
					 final int result_cast_character_set_name = 64;
					 final int result_cast_collation_catalog = 65;
					 final int result_cast_collation_schema = 66;
					 final int result_cast_collation_name = 67;
					 final int result_cast_numeric_precision = 68;
					 final int result_cast_numeric_radix = 69;
					 final int result_cast_numeric_scale = 70;
					 final int result_cast_datetime_precision = 71;
					 final int result_cast_interval_type = 72;
					 final int result_cast_interval_precision = 73;
					 final int result_cast_type_udt_catalog = 74;
					 final int result_cast_type_udt_schema = 75;
					 final int result_cast_type_udt_name = 76;
					 final int result_cast_scope_catalog = 77;
					 final int result_cast_scope_schema = 78;
					 final int result_cast_scope_name = 79;
					 final int result_cast_max_cardinality = 80;
					 final int result_cast_dtd_identifier = 81;
					 final int declared_data_type = 82;
					 final int declared_numeric_precision = 83;
					 final int declared_numeric_scale = 84;
					 final int result_cast_from_declared_data_type = 85;
					 final int result_cast_declared_numeric_precision = 86;
					 final int result_cast_declared_numeric_scale = 87;
					 PersistentStore store = session.sessionData.getRowStore(t);
					 Iterator it;
					 Object[] row;
					 it = database.schemaManager.databaseObjectIterator( SchemaObject.ROUTINE);
					 while (it.hasNext()) {
						 RoutineSchema routine = (RoutineSchema) it.next();
						 if (!session.getGrantee().isAccessible(routine)) {
							 continue;
						 }
						 Routine[] specifics = routine.getSpecificRoutines();
						 for (int m = 0;
						 m < specifics.length;
						 m++) {
							 row = t.getEmptyRowData();
							 Routine specific = specifics[m];
							 Type type = specific.isProcedure() ? null : specific .getReturnType();
							 row[specific_catalog] = database.getCatalogName().name;
							 row[specific_schema] = specific.getSchemaName().name;
							 row[specific_name] = specific.getSpecificName().name;
							 row[routine_catalog] = database.getCatalogName().name;
							 row[routine_schema] = routine.getSchemaName().name;
							 row[routine_name] = specific.getName().name;
							 row[routine_type] = specific.isProcedure() ? Tokens.T_PROCEDURE : Tokens.T_FUNCTION;
							 row[module_catalog] = null;
							 row[module_schema] = null;
							 row[module_name] = null;
							 row[udt_catalog] = null;
							 row[udt_schema] = null;
							 row[udt_name] = null;
							 row[data_type] = type == null ? null : type.getNameString();
							 if (type != null) {
								 if (type.isCharacterType()) {
									 row[character_maximum_length] = ValuePool.getLong(type.precision);
									 row[character_octet_length] = ValuePool.getLong(type.precision * 2);
									 row[character_set_catalog] = database.getCatalogName().name;
									 row[character_set_schema] = ((CharacterType) type).getCharacterSet() .getSchemaName().name;
									 row[character_set_name] = ((CharacterType) type).getCharacterSet().getName() .name;
									 row[collation_catalog] = database.getCatalogName().name;
									 row[collation_schema] = ((CharacterType) type).getCollation() .getSchemaName().name;
									 row[collation_name] = ((CharacterType) type).getCollation().getName() .name;
								 }
								 else if (type.isNumberType()) {
									 row[numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
									 row[declared_numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
									 if (type.isExactNumberType()) {
										 row[numeric_scale] = row[declared_numeric_scale] = ValuePool.getLong(type.scale);
									 }
									 row[numeric_precision_radix] = ValuePool.getLong(type.getPrecisionRadix());
								 }
								 else if (type.isBooleanType()) {
								 }
								 else if (type.isDateTimeType()) {
									 row[datetime_precision] = ValuePool.getLong(type.scale);
								 }
								 else if (type.isIntervalType()) {
									 row[data_type] = ""INTERVAL"";
									 row[interval_type] = ((IntervalType) type).getQualifier(type.typeCode);
									 row[interval_precision] = ValuePool.getLong(type.precision);
									 row[datetime_precision] = ValuePool.getLong(type.scale);
								 }
								 else if (type.isBinaryType()) {
									 row[character_maximum_length] = ValuePool.getLong(type.precision);
									 row[character_octet_length] = ValuePool.getLong(type.precision);
								 }
								 else if (type.isBitType()) {
									 row[character_maximum_length] = ValuePool.getLong(type.precision);
									 row[character_octet_length] = ValuePool.getLong(type.precision);
								 }
								 else if (type.isArrayType()) {
									 row[maximum_cardinality] = ValuePool.getLong(type.arrayLimitCardinality());
								 }
							 }
							 row[type_udt_catalog] = null;
							 row[type_udt_schema] = null;
							 row[type_udt_name] = null;
							 row[scope_catalog] = null;
							 row[scope_schema] = null;
							 row[scope_name] = null;
							 row[dtd_identifier] = null;
							 / Table SCHEMATA(Session session) {
								 Table t = sysTables[SCHEMATA];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SCHEMATA]);
									 addColumn(t, ""CATALOG_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SCHEMA_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SCHEMA_OWNER"", SQL_IDENTIFIER);
									 addColumn(t, ""DEFAULT_CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""DEFAULT_CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""DEFAULT_CHARACTER_SET_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SQL_PATH"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SCHEMATA].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator schemas;
								 String schema;
								 String dcsSchema = SqlInvariants.INFORMATION_SCHEMA;
								 String dcsName = ValuePool.getString(""UTF16"");
								 String sqlPath = null;
								 Grantee user = session.getGrantee();
								 Object[] row;
								 final int schema_catalog = 0;
								 final int schema_name = 1;
								 final int schema_owner = 2;
								 final int default_character_set_catalog = 3;
								 final int default_character_set_schema = 4;
								 final int default_character_set_name = 5;
								 final int sql_path = 6;
								 schemas = database.schemaManager.fullSchemaNamesIterator();
								 while (schemas.hasNext()) {
									 schema = (String) schemas.next();
									 if (!user.hasSchemaUpdateOrGrantRights(schema)) {
										 continue;
									 }
									 row = t.getEmptyRowData();
									 row[schema_catalog] = database.getCatalogName().name;
									 row[schema_name] = schema;
									 row[schema_owner] = database.schemaManager.toSchemaOwner(schema).getNameString();
									 row[default_character_set_catalog] = database.getCatalogName().name;
									 row[default_character_set_schema] = dcsSchema;
									 row[default_character_set_name] = dcsName;
									 row[sql_path] = sqlPath;
									 t.insertSys(store, row);
								 }
								 return t;
							 }
							 Table SQL_FEATURES(Session session) {
								 Table t = sysTables[SQL_FEATURES];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SQL_FEATURES]);
									 addColumn(t, ""FEATURE_ID"", CHARACTER_DATA);
									 addColumn(t, ""FEATURE_NAME"", CHARACTER_DATA);
									 addColumn(t, ""SUB_FEATURE_ID"", CHARACTER_DATA);
									 addColumn(t, ""SUB_FEATURE_NAME"", CHARACTER_DATA);
									 addColumn(t, ""IS_SUPPORTED"", YES_OR_NO);
									 addColumn(t, ""IS_VERIFIED_BY"", CHARACTER_DATA);
									 addColumn(t, ""COMMENTS"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SQL_FEATURES].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 2 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
								 String sql = (String) statementMap.get("""");
								 Result rs = sys.executeDirectStatement(sql, ResultProperties.defaultPropsValue);
								 t.insertSys(store, rs);
								 return t;
							 }
							 Table SQL_IMPLEMENTATION_INFO(Session session) {
								 Table t = sysTables[SQL_IMPLEMENTATION_INFO];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SQL_IMPLEMENTATION_INFO]);
									 addColumn(t, ""IMPLEMENTATION_INFO_ID"", CHARACTER_DATA);
									 addColumn(t, ""IMPLEMENTATION_INFO_NAME"", CHARACTER_DATA);
									 addColumn(t, ""INTEGER_VALUE"", CARDINAL_NUMBER);
									 addColumn(t, ""CHARACTER_VALUE"", CHARACTER_DATA);
									 addColumn(t, ""COMMENTS"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SQL_IMPLEMENTATION_INFO].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[]{
									 0 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
								 return t;
							 }
							 Table SQL_PACKAGES(Session session) {
								 Table t = sysTables[SQL_PACKAGES];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SQL_PACKAGES]);
									 addColumn(t, ""ID"", CHARACTER_DATA);
									 addColumn(t, ""NAME"", CHARACTER_DATA);
									 addColumn(t, ""IS_SUPPORTED"", YES_OR_NO);
									 addColumn(t, ""IS_VERIFIED_BY"", CHARACTER_DATA);
									 addColumn(t, ""COMMENTS"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SQL_PACKAGES].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[]{
									 0 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
								 String sql = (String) statementMap.get("""");
								 Result rs = sys.executeDirectStatement(sql, ResultProperties.defaultPropsValue);
								 t.insertSys(store, rs);
								 return t;
							 }
							 Table SQL_PARTS(Session session) {
								 Table t = sysTables[SQL_PARTS];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SQL_PARTS]);
									 addColumn(t, ""PART"", CHARACTER_DATA);
									 addColumn(t, ""NAME"", CHARACTER_DATA);
									 addColumn(t, ""IS_SUPPORTED"", YES_OR_NO);
									 addColumn(t, ""IS_VERIFIED_BY"", CHARACTER_DATA);
									 addColumn(t, ""COMMENTS"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SQL_PARTS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[]{
									 0 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
								 String sql = (String) statementMap.get("""");
								 Result rs = sys.executeDirectStatement(sql, ResultProperties.defaultPropsValue);
								 t.insertSys(store, rs);
								 return t;
							 }
							 Table SQL_SIZING(Session session) {
								 Table t = sysTables[SQL_SIZING];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SQL_SIZING]);
									 addColumn(t, ""SIZING_ID"", CARDINAL_NUMBER);
									 addColumn(t, ""SIZING_NAME"", CHARACTER_DATA);
									 addColumn(t, ""SUPPORTED_VALUE"", CARDINAL_NUMBER);
									 addColumn(t, ""COMMENTS"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SQL_SIZING].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[]{
									 0 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
								 String sql = (String) statementMap.get("""");
								 Result rs = sys.executeDirectStatement(sql, ResultProperties.defaultPropsValue);
								 t.insertSys(store, rs);
								 return t;
							 }
							 Table SQL_SIZING_PROFILES(Session session) {
								 Table t = sysTables[SQL_SIZING_PROFILES];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[SQL_SIZING_PROFILES]);
									 addColumn(t, ""SIZING_ID"", CARDINAL_NUMBER);
									 addColumn(t, ""SIZING_NAME"", CHARACTER_DATA);
									 addColumn(t, ""PROFILE_ID"", CARDINAL_NUMBER);
									 addColumn(t, ""PROFILE_NAME"", CHARACTER_DATA);
									 addColumn(t, ""REQUIRED_VALUE"", CARDINAL_NUMBER);
									 addColumn(t, ""COMMENTS"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[SQL_SIZING_PROFILES].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[]{
									 0 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Session sys = database.sessionManager.newSysSession( SqlInvariants.INFORMATION_SCHEMA_HSQLNAME, session.getUser());
								 return t;
							 }
							 Table TABLE_CONSTRAINTS(Session session) {
								 Table t = sysTables[TABLE_CONSTRAINTS];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TABLE_CONSTRAINTS]);
									 addColumn(t, ""CONSTRAINT_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""CONSTRAINT_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""CONSTRAINT_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""CONSTRAINT_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""IS_DEFERRABLE"", YES_OR_NO);
									 addColumn(t, ""INITIALLY_DEFERRED"", YES_OR_NO);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TABLE_CONSTRAINTS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 4, 5, 6 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator tables;
								 Table table;
								 Constraint[] constraints;
								 int constraintCount;
								 Constraint constraint;
								 String cat;
								 String schem;
								 Object[] row;
								 final int constraint_catalog = 0;
								 final int constraint_schema = 1;
								 final int constraint_name = 2;
								 final int constraint_type = 3;
								 final int table_catalog = 4;
								 final int table_schema = 5;
								 final int table_name = 6;
								 final int is_deferable = 7;
								 final int initially_deferred = 8;
								 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
								 table = null;
								 while (tables.hasNext()) {
									 table = (Table) tables.next();
									 if (table.isView() || !isAccessibleTable(session, table)) {
										 continue;
									 }
									 constraints = table.getConstraints();
									 constraintCount = constraints.length;
									 for (int i = 0;
									 i < constraintCount;
									 i++) {
										 constraint = constraints[i];
										 row = t.getEmptyRowData();
										 switch (constraint.getConstraintType()) {
											 case SchemaObject.ConstraintTypes.CHECK : {
												 row[constraint_type] = ""CHECK"";
												 break;
											 }
											 case SchemaObject.ConstraintTypes.UNIQUE : {
												 row[constraint_type] = ""UNIQUE"";
												 break;
											 }
											 case SchemaObject.ConstraintTypes.FOREIGN_KEY : {
												 row[constraint_type] = ""FOREIGN KEY"";
												 table = constraint.getRef();
												 break;
											 }
											 case SchemaObject.ConstraintTypes.PRIMARY_KEY : {
												 row[constraint_type] = ""PRIMARY KEY"";
												 break;
											 }
											 case SchemaObject.ConstraintTypes.MAIN : default : {
												 continue;
											 }
										 }
										 cat = database.getCatalogName().name;
										 schem = table.getSchemaName().name;
										 row[constraint_catalog] = cat;
										 row[constraint_schema] = schem;
										 row[constraint_name] = constraint.getName().name;
										 row[table_catalog] = cat;
										 row[table_schema] = schem;
										 row[table_name] = table.getName().name;
										 row[is_deferable] = Tokens.T_NO;
										 row[initially_deferred] = Tokens.T_NO;
										 t.insertSys(store, row);
									 }
								 }
								 return t;
							 }
							 Table TRANSLATIONS(Session session) {
								 Table t = sysTables[TRANSLATIONS];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRANSLATIONS]);
									 addColumn(t, ""TRANSLATION_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRANSLATION_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRANSLATION_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SOURCE_CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""SOURCE_CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""SOURCE_CHARACTER_SET_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""TARGET_CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TARGET_CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TARGET_CHARACTER_SET_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""TRANSLATION_SOURCE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRANSLATION_SOURCE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRANSLATION_SOURCE_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRANSLATIONS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2 }
									, false);
									 return t;
								 }
								 return t;
							 }
							 Table TRIGGER_COLUMN_USAGE(Session session) {
								 Table t = sysTables[TRIGGER_COLUMN_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRIGGER_COLUMN_USAGE]);
									 addColumn(t, ""TRIGGER_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRIGGER_COLUMN_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5, 6 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int trigger_catalog = 0;
								 final int trigger_schema = 1;
								 final int trigger_name = 2;
								 final int table_catalog = 3;
								 final int table_schema = 4;
								 final int table_name = 5;
								 final int column_name = 6;
								 Iterator it;
								 Object[] row;
								 it = database.schemaManager.databaseObjectIterator( SchemaObject.TRIGGER);
								 while (it.hasNext()) {
									 TriggerDef trigger = (TriggerDef) it.next();
									 if (!session.getGrantee().isAccessible(trigger)) {
										 continue;
									 }
									 OrderedHashSet set = trigger.getReferences();
									 for (int i = 0;
									 i < set.size();
									 i++) {
										 HsqlName refName = (HsqlName) set.get(i);
										 if (refName.type != SchemaObject.COLUMN) {
											 continue;
										 }
										 if (!session.getGrantee().isAccessible(refName)) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[trigger_catalog] = database.getCatalogName().name;
										 row[trigger_schema] = trigger.getSchemaName().name;
										 row[trigger_name] = trigger.getName().name;
										 row[table_catalog] = database.getCatalogName().name;
										 row[table_schema] = refName.parent.schema.name;
										 row[table_name] = refName.parent.name;
										 row[column_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table TRIGGER_ROUTINE_USAGE(Session session) {
								 Table t = sysTables[TRIGGER_ROUTINE_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRIGGER_ROUTINE_USAGE]);
									 addColumn(t, ""TRIGGER_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRIGGER_ROUTINE_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int trigger_catalog = 0;
								 final int trigger_schema = 1;
								 final int trigger_name = 2;
								 final int specific_catalog = 3;
								 final int specific_schema = 4;
								 final int specific_name = 5;
								 Iterator it;
								 Object[] row;
								 it = database.schemaManager.databaseObjectIterator( SchemaObject.TRIGGER);
								 while (it.hasNext()) {
									 TriggerDef trigger = (TriggerDef) it.next();
									 if (!session.getGrantee().isAccessible(trigger)) {
										 continue;
									 }
									 OrderedHashSet set = trigger.getReferences();
									 for (int i = 0;
									 i < set.size();
									 i++) {
										 HsqlName refName = (HsqlName) set.get(i);
										 if (refName.type != SchemaObject.SPECIFIC_ROUTINE) {
											 continue;
										 }
										 if (!session.getGrantee().isAccessible(refName)) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[trigger_catalog] = database.getCatalogName().name;
										 row[trigger_schema] = trigger.getSchemaName().name;
										 row[trigger_name] = trigger.getName().name;
										 row[specific_catalog] = database.getCatalogName().name;
										 row[specific_schema] = refName.schema.name;
										 row[specific_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table TRIGGER_SEQUENCE_USAGE(Session session) {
								 Table t = sysTables[TRIGGER_SEQUENCE_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRIGGER_SEQUENCE_USAGE]);
									 addColumn(t, ""TRIGGER_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SEQUENCE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""SEQUENCE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""SEQUENCE_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRIGGER_SEQUENCE_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int trigger_catalog = 0;
								 final int trigger_schema = 1;
								 final int trigger_name = 2;
								 final int sequence_catalog = 3;
								 final int sequence_schema = 4;
								 final int sequence_name = 5;
								 Iterator it;
								 Object[] row;
								 it = database.schemaManager.databaseObjectIterator( SchemaObject.TRIGGER);
								 while (it.hasNext()) {
									 TriggerDef trigger = (TriggerDef) it.next();
									 if (!session.getGrantee().isAccessible(trigger)) {
										 continue;
									 }
									 OrderedHashSet set = trigger.getReferences();
									 for (int i = 0;
									 i < set.size();
									 i++) {
										 HsqlName refName = (HsqlName) set.get(i);
										 if (refName.type != SchemaObject.SEQUENCE) {
											 continue;
										 }
										 if (!session.getGrantee().isAccessible(refName)) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[trigger_catalog] = database.getCatalogName().name;
										 row[trigger_schema] = trigger.getSchemaName().name;
										 row[trigger_name] = trigger.getName().name;
										 row[sequence_catalog] = database.getCatalogName().name;
										 row[sequence_schema] = refName.schema.name;
										 row[sequence_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table TRIGGER_TABLE_USAGE(Session session) {
								 Table t = sysTables[TRIGGER_TABLE_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRIGGER_TABLE_USAGE]);
									 addColumn(t, ""TRIGGER_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRIGGER_TABLE_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int trigger_catalog = 0;
								 final int trigger_schema = 1;
								 final int trigger_name = 2;
								 final int table_catalog = 3;
								 final int table_schema = 4;
								 final int table_name = 5;
								 Iterator it;
								 Object[] row;
								 it = database.schemaManager.databaseObjectIterator( SchemaObject.TRIGGER);
								 while (it.hasNext()) {
									 TriggerDef trigger = (TriggerDef) it.next();
									 if (!session.getGrantee().isAccessible(trigger)) {
										 continue;
									 }
									 OrderedHashSet set = trigger.getReferences();
									 for (int i = 0;
									 i < set.size();
									 i++) {
										 HsqlName refName = (HsqlName) set.get(i);
										 if (refName.type != SchemaObject.TABLE && refName.type != SchemaObject.VIEW) {
											 continue;
										 }
										 if (!session.getGrantee().isAccessible(refName)) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[trigger_catalog] = database.getCatalogName().name;
										 row[trigger_schema] = trigger.getSchemaName().name;
										 row[trigger_name] = trigger.getName().name;
										 row[table_catalog] = database.getCatalogName().name;
										 row[table_schema] = refName.schema.name;
										 row[table_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table TRIGGERS(Session session) {
								 Table t = sysTables[TRIGGERS];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRIGGERS]);
									 addColumn(t, ""TRIGGER_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_MANIPULATION"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_TABLE"", SQL_IDENTIFIER);
									 addColumn(t, ""ACTION_ORDER"", CARDINAL_NUMBER);
									 addColumn(t, ""ACTION_CONDITION"", CHARACTER_DATA);
									 addColumn(t, ""ACTION_STATEMENT"", CHARACTER_DATA);
									 addColumn(t, ""ACTION_ORIENTATION"", CHARACTER_DATA);
									 addColumn(t, ""ACTION_TIMING"", CHARACTER_DATA);
									 addColumn(t, ""ACTION_REFERENCE_OLD_TABLE"", SQL_IDENTIFIER);
									 addColumn(t, ""ACTION_REFERENCE_NEW_TABLE"", SQL_IDENTIFIER);
									 addColumn(t, ""ACTION_REFERENCE_OLD_ROW"", SQL_IDENTIFIER);
									 addColumn(t, ""ACTION_REFERENCE_NEW_ROW"", SQL_IDENTIFIER);
									 addColumn(t, ""CREATED"", TIME_STAMP);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRIGGERS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int trigger_catalog = 0;
								 final int trigger_schema = 1;
								 final int trigger_name = 2;
								 final int event_manipulation = 3;
								 final int event_object_catalog = 4;
								 final int event_object_schema = 5;
								 final int event_object_table = 6;
								 final int action_order = 7;
								 final int action_condition = 8;
								 final int action_statement = 9;
								 final int action_orientation = 10;
								 final int action_timing = 11;
								 final int action_reference_old_table = 12;
								 final int action_reference_new_table = 13;
								 final int action_reference_old_row = 14;
								 final int action_reference_new_row = 15;
								 final int created = 16;
								 Iterator it;
								 Object[] row;
								 it = database.schemaManager.databaseObjectIterator( SchemaObject.TRIGGER);
								 while (it.hasNext()) {
									 TriggerDef trigger = (TriggerDef) it.next();
									 if (!session.getGrantee().isAccessible(trigger)) {
										 continue;
									 }
									 row = t.getEmptyRowData();
									 row[trigger_catalog] = database.getCatalogName().name;
									 row[trigger_schema] = trigger.getSchemaName().name;
									 row[trigger_name] = trigger.getName().name;
									 row[event_manipulation] = trigger.getEventTypeString();
									 row[event_object_catalog] = database.getCatalogName().name;
									 row[event_object_schema] = trigger.getTable().getSchemaName().name;
									 row[event_object_table] = trigger.getTable().getName().name;
									 int order = trigger.getTable().getTriggerIndex(trigger.getName().name);
									 row[action_order] = ValuePool.getLong(order);
									 row[action_condition] = trigger.getConditionSQL();
									 row[action_statement] = trigger.getProcedureSQL();
									 row[action_orientation] = trigger.getActionOrientationString();
									 row[action_timing] = trigger.getActionTimingString();
									 row[action_reference_old_table] = trigger.getOldTransitionTableName();
									 row[action_reference_new_table] = trigger.getNewTransitionTableName();
									 row[action_reference_old_row] = trigger.getOldTransitionRowName();
									 row[action_reference_new_row] = trigger.getNewTransitionRowName();
									 row[created] = null;
									 t.insertSys(store, row);
								 }
								 return t;
							 }
							 Table TRIGGERED_UPDATE_COLUMNS(Session session) {
								 Table t = sysTables[TRIGGERED_UPDATE_COLUMNS];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[TRIGGERED_UPDATE_COLUMNS]);
									 addColumn(t, ""TRIGGER_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TRIGGER_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_TABLE"", SQL_IDENTIFIER);
									 addColumn(t, ""EVENT_OBJECT_COLUMN"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[TRIGGERED_UPDATE_COLUMNS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5, 6 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int trigger_catalog = 0;
								 final int trigger_schema = 1;
								 final int trigger_name = 2;
								 final int event_object_catalog = 3;
								 final int event_object_schema = 4;
								 final int event_object_table = 5;
								 final int event_object_column = 6;
								 Iterator it;
								 Object[] row;
								 it = database.schemaManager.databaseObjectIterator( SchemaObject.TRIGGER);
								 while (it.hasNext()) {
									 TriggerDef trigger = (TriggerDef) it.next();
									 if (!session.getGrantee().isAccessible(trigger)) {
										 continue;
									 }
									 int[] colIndexes = trigger.getUpdateColumnIndexes();
									 if (colIndexes == null) {
										 continue;
									 }
									 for (int i = 0;
									 i < colIndexes.length;
									 i++) {
										 ColumnSchema column = trigger.getTable().getColumn(colIndexes[i]);
										 row = t.getEmptyRowData();
										 row[trigger_catalog] = database.getCatalogName().name;
										 row[trigger_schema] = trigger.getSchemaName().name;
										 row[trigger_name] = trigger.getName().name;
										 row[event_object_catalog] = database.getCatalogName().name;
										 row[event_object_schema] = trigger.getTable().getSchemaName().name;
										 row[event_object_table] = trigger.getTable().getName().name;
										 row[event_object_column] = column.getNameString();
										 t.insertSys(store, row);
									 }
								 }
								 return t;
							 }
							 Table UDT_PRIVILEGES(Session session) {
								 Table t = sysTables[UDT_PRIVILEGES];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[UDT_PRIVILEGES]);
									 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
									 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
									 addColumn(t, ""UDT_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""UDT_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""UDT_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[UDT_PRIVILEGES].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4 }
									, false);
									 return t;
								 }
								 final int grantor = 0;
								 final int grantee = 1;
								 final int udt_catalog = 2;
								 final int udt_schema = 3;
								 final int udt_name = 4;
								 final int privilege_type = 5;
								 final int is_grantable = 6;
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator objects = database.schemaManager.databaseObjectIterator(SchemaObject.TYPE);
								 OrderedHashSet grantees = session.getGrantee().getGranteeAndAllRolesWithPublic();
								 while (objects.hasNext()) {
									 SchemaObject object = (SchemaObject) objects.next();
									 if (object.getType() != SchemaObject.TYPE) {
										 continue;
									 }
									 for (int i = 0;
									 i < grantees.size();
									 i++) {
										 Grantee granteeObject = (Grantee) grantees.get(i);
										 OrderedHashSet rights = granteeObject.getAllDirectPrivileges(object);
										 OrderedHashSet grants = granteeObject.getAllGrantedPrivileges(object);
										 if (!grants.isEmpty()) {
											 grants.addAll(rights);
											 rights = grants;
										 }
										 for (int j = 0;
										 j < rights.size();
										 j++) {
											 Right right = (Right) rights.get(j);
											 Right grantableRight = right.getGrantableRights();
											 Object[] row;
											 row = t.getEmptyRowData();
											 row[grantor] = right.getGrantor().getName().name;
											 row[grantee] = right.getGrantee().getName().name;
											 row[udt_catalog] = database.getCatalogName().name;
											 row[udt_schema] = object.getSchemaName().name;
											 row[udt_name] = object.getName().name;
											 row[privilege_type] = Tokens.T_USAGE;
											 row[is_grantable] = right.getGrantee() == object.getOwner() || grantableRight.isFull() ? Tokens.T_YES : Tokens.T_NO;
											;
											 try {
												 t.insertSys(store, row);
											 }
											 catch (HsqlException e) {
											}
										 }
									 }
								 }
								 return t;
							 }
							 Table USAGE_PRIVILEGES(Session session) {
								 Table t = sysTables[USAGE_PRIVILEGES];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[USAGE_PRIVILEGES]);
									 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
									 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
									 addColumn(t, ""OBJECT_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""OBJECT_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""OBJECT_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""OBJECT_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""PRIVILEGE_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[USAGE_PRIVILEGES].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5, 6, 7 }
									, false);
									 return t;
								 }
								 Object[] row;
								 final int grantor = 0;
								 final int grantee = 1;
								 final int object_catalog = 2;
								 final int object_schema = 3;
								 final int object_name = 4;
								 final int object_type = 5;
								 final int privilege_type = 6;
								 final int is_grantable = 7;
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator objects = new WrapperIterator(database.schemaManager .databaseObjectIterator(SchemaObject.SEQUENCE), database .schemaManager.databaseObjectIterator(SchemaObject.COLLATION));
								 objects = new WrapperIterator( objects, database.schemaManager.databaseObjectIterator( SchemaObject.CHARSET));
								 objects = new WrapperIterator( objects, database.schemaManager.databaseObjectIterator( SchemaObject.DOMAIN));
								 OrderedHashSet grantees = session.getGrantee().getGranteeAndAllRolesWithPublic();
								 while (objects.hasNext()) {
									 SchemaObject object = (SchemaObject) objects.next();
									 for (int i = 0;
									 i < grantees.size();
									 i++) {
										 Grantee granteeObject = (Grantee) grantees.get(i);
										 OrderedHashSet rights = granteeObject.getAllDirectPrivileges(object);
										 OrderedHashSet grants = granteeObject.getAllGrantedPrivileges(object);
										 if (!grants.isEmpty()) {
											 grants.addAll(rights);
											 rights = grants;
										 }
										 for (int j = 0;
										 j < rights.size();
										 j++) {
											 Right right = (Right) rights.get(j);
											 Right grantableRight = right.getGrantableRights();
											 row = t.getEmptyRowData();
											 row[grantor] = right.getGrantor().getName().name;
											 row[grantee] = right.getGrantee().getName().name;
											 row[object_catalog] = database.getCatalogName().name;
											 row[object_schema] = object.getSchemaName().name;
											 row[object_name] = object.getName().name;
											 row[object_type] = SchemaObjectSet.getName(object.getName().type);
											 row[privilege_type] = Tokens.T_USAGE;
											 row[is_grantable] = right.getGrantee() == object.getOwner() || grantableRight.isFull() ? Tokens.T_YES : Tokens.T_NO;
											;
											 try {
												 t.insertSys(store, row);
											 }
											 catch (HsqlException e) {
											}
										 }
									 }
								 }
								 return t;
							 }
							 Table USER_DEFINED_TYPES(Session session) {
								 Table t = sysTables[USER_DEFINED_TYPES];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[USER_DEFINED_TYPES]);
									 addColumn(t, ""USER_DEFINED_TYPE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""USER_DEFINED_TYPE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""USER_DEFINED_TYPE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""USER_DEFINED_TYPE_CATEGORY"", SQL_IDENTIFIER);
									 addColumn(t, ""IS_INSTANTIABLE"", YES_OR_NO);
									 addColumn(t, ""IS_FINAL"", YES_OR_NO);
									 addColumn(t, ""ORDERING_FORM"", SQL_IDENTIFIER);
									 addColumn(t, ""ORDERING_CATEGORY"", SQL_IDENTIFIER);
									 addColumn(t, ""ORDERING_ROUTINE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""ORDERING_ROUTINE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""ORDERING_ROUTINE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""REFERENCE_TYPE"", SQL_IDENTIFIER);
									 addColumn(t, ""DATA_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""CHARACTER_MAXIMUM_LENGTH"", CARDINAL_NUMBER);
									 addColumn(t, ""CHARACTER_OCTET_LENGTH"", CARDINAL_NUMBER);
									 addColumn(t, ""CHARACTER_SET_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""CHARACTER_SET_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""CHARACTER_SET_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""COLLATION_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""COLLATION_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""COLLATION_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""NUMERIC_PRECISION"", CARDINAL_NUMBER);
									 addColumn(t, ""NUMERIC_PRECISION_RADIX"", CARDINAL_NUMBER);
									 addColumn(t, ""NUMERIC_SCALE"", CARDINAL_NUMBER);
									 addColumn(t, ""DATETIME_PRECISION"", CARDINAL_NUMBER);
									 addColumn(t, ""INTERVAL_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""INTERVAL_PRECISION"", CARDINAL_NUMBER);
									 addColumn(t, ""SOURCE_DTD_IDENTIFIER"", CHARACTER_DATA);
									 addColumn(t, ""REF_DTD_IDENTIFIER"", CHARACTER_DATA);
									 addColumn(t, ""DECLARED_DATA_TYPE"", CHARACTER_DATA);
									 addColumn(t, ""DECLARED_NUMERIC_PRECISION"", CARDINAL_NUMBER);
									 addColumn(t, ""DECLARED_NUMERIC_SCALE"", CARDINAL_NUMBER);
									 addColumn(t, ""EXTERNAL_NAME"", CHARACTER_DATA);
									 addColumn(t, ""EXTERNAL_LANGUAGE"", CHARACTER_DATA);
									 addColumn(t, ""JAVA_INTERFACE"", CHARACTER_DATA);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[USER_DEFINED_TYPES].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 4, 5, 6 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 final int user_defined_type_catalog = 0;
								 final int user_defined_type_schema = 1;
								 final int user_defined_type_name = 2;
								 final int user_defined_type_category = 3;
								 final int is_instantiable = 4;
								 final int is_final = 5;
								 final int ordering_form = 6;
								 final int ordering_category = 7;
								 final int ordering_routine_catalog = 8;
								 final int ordering_routine_schema = 9;
								 final int ordering_routine_name = 10;
								 final int reference_type = 11;
								 final int data_type = 12;
								 final int character_maximum_length = 13;
								 final int character_octet_length = 14;
								 final int character_set_catalog = 15;
								 final int character_set_schema = 16;
								 final int character_set_name = 17;
								 final int collation_catalog = 18;
								 final int collation_schema = 19;
								 final int collation_name = 20;
								 final int numeric_precision = 21;
								 final int numeric_precision_radix = 22;
								 final int numeric_scale = 23;
								 final int datetime_precision = 24;
								 final int interval_type = 25;
								 final int interval_precision = 26;
								 final int source_dtd_identifier = 27;
								 final int ref_dtd_identifier = 28;
								 final int declared_data_type = 29;
								 final int declared_numeric_precision = 30;
								 final int declared_numeric_scale = 31;
								 Iterator it = database.schemaManager.databaseObjectIterator(SchemaObject.TYPE);
								 while (it.hasNext()) {
									 Type type = (Type) it.next();
									 if (!type.isDistinctType()) {
										 continue;
									 }
									 Object[] row = t.getEmptyRowData();
									 row[user_defined_type_catalog] = database.getCatalogName().name;
									 row[user_defined_type_schema] = type.getSchemaName().name;
									 row[user_defined_type_name] = type.getName().name;
									 row[data_type] = type.getFullNameString();
									 row[declared_data_type] = type.getFullNameString();
									 row[user_defined_type_category] = ""DISTINCT"";
									 row[is_instantiable] = ""YES"";
									 row[is_final] = ""YES"";
									 row[ordering_form] = ""FULL"";
									 if (type.isCharacterType()) {
										 row[character_maximum_length] = ValuePool.getLong(type.precision);
										 row[character_octet_length] = ValuePool.getLong(type.precision row[character_set_catalog] = database.getCatalogName().name;
										 row[character_set_schema] = ((CharacterType) type).getCharacterSet().getSchemaName() .name;
										 row[character_set_name] = ((CharacterType) type).getCharacterSet().getName().name;
										 row[collation_catalog] = database.getCatalogName().name;
										 row[collation_schema] = ((CharacterType) type).getCollation().getSchemaName().name;
										 row[collation_name] = ((CharacterType) type).getCollation().getName().name;
									 }
									 else if (type.isNumberType()) {
										 row[numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
										 row[declared_numeric_precision] = ValuePool.getLong( ((NumberType) type).getNumericPrecisionInRadix());
										 if (type.isExactNumberType()) {
											 row[numeric_scale] = row[declared_numeric_scale] = ValuePool.getLong(type.scale);
										 }
										 row[numeric_precision_radix] = ValuePool.getLong(type.getPrecisionRadix());
									 }
									 else if (type.isBooleanType()) {
									}
									 else if (type.isDateTimeType()) {
										 row[datetime_precision] = ValuePool.getLong(type.scale);
									 }
									 else if (type.isIntervalType()) {
										 row[data_type] = ""INTERVAL"";
										 row[interval_type] = ((IntervalType) type).getQualifier(type.typeCode);
										 row[interval_precision] = ValuePool.getLong(type.precision);
										 row[datetime_precision] = ValuePool.getLong(type.scale);
									 }
									 else if (type.isBinaryType()) {
										 row[character_maximum_length] = ValuePool.getLong(type.precision);
										 row[character_octet_length] = ValuePool.getLong(type.precision);
									 }
									 else if (type.isBitType()) {
										 row[character_maximum_length] = ValuePool.getLong(type.precision);
										 row[character_octet_length] = ValuePool.getLong(type.precision);
									 }
									 row[source_dtd_identifier] = row[user_defined_type_name];
									 t.insertSys(store, row);
								 }
								 return t;
							 }
							 Table VIEW_COLUMN_USAGE(Session session) {
								 Table t = sysTables[VIEW_COLUMN_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[VIEW_COLUMN_USAGE]);
									 addColumn(t, ""VIEW_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""COLUMN_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[VIEW_COLUMN_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5, 6 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 String viewCatalog;
								 String viewSchema;
								 String viewName;
								 Iterator tables;
								 View view;
								 Table table;
								 Object[] row;
								 Iterator iterator;
								 final int view_catalog = 0;
								 final int view_schema = 1;
								 final int view_name = 2;
								 final int table_catalog = 3;
								 final int table_schema = 4;
								 final int table_name = 5;
								 final int column_name = 6;
								 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
								 while (tables.hasNext()) {
									 table = (Table) tables.next();
									 if (table.isView() && session.getGrantee().isFullyAccessibleByRole( table.getName())) {
									 }
									 else {
										 continue;
									 }
									 viewCatalog = database.getCatalogName().name;
									 viewSchema = table.getSchemaName().name;
									 viewName = table.getName().name;
									 view = (View) table;
									 OrderedHashSet references = view.getReferences();
									 iterator = references.iterator();
									 while (iterator.hasNext()) {
										 HsqlName refName = (HsqlName) iterator.next();
										 if (refName.type != SchemaObject.COLUMN) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[view_catalog] = viewCatalog;
										 row[view_schema] = viewSchema;
										 row[view_name] = viewName;
										 row[table_catalog] = viewCatalog;
										 row[table_schema] = refName.parent.schema.name;
										 row[table_name] = refName.parent.name;
										 row[column_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table VIEW_ROUTINE_USAGE(Session session) {
								 Table t = sysTables[VIEW_ROUTINE_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[VIEW_ROUTINE_USAGE]);
									 addColumn(t, ""VIEW_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""SPECIFIC_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""SPECIFIC_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""SPECIFIC_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[VIEW_ROUTINE_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator tables;
								 Table table;
								 Object[] row;
								 final int view_catalog = 0;
								 final int view_schema = 1;
								 final int view_name = 2;
								 final int specific_catalog = 3;
								 final int specific_schema = 4;
								 final int specific_name = 5;
								 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
								 while (tables.hasNext()) {
									 table = (Table) tables.next();
									 if (table.isView() && session.getGrantee().isFullyAccessibleByRole( table.getName())) {
									 }
									 else {
										 continue;
									 }
									 OrderedHashSet set = table.getReferences();
									 for (int i = 0;
									 i < set.size();
									 i++) {
										 HsqlName refName = (HsqlName) set.get(i);
										 if (!session.getGrantee().isFullyAccessibleByRole(refName)) {
											 continue;
										 }
										 if (refName.type != SchemaObject.SPECIFIC_ROUTINE) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[view_catalog] = database.getCatalogName().name;
										 row[view_schema] = table.getSchemaName().name;
										 row[view_name] = table.getName().name;
										 row[specific_catalog] = database.getCatalogName().name;
										 row[specific_schema] = refName.schema.name;
										 row[specific_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table VIEW_TABLE_USAGE(Session session) {
								 Table t = sysTables[VIEW_TABLE_USAGE];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[VIEW_TABLE_USAGE]);
									 addColumn(t, ""VIEW_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[VIEW_TABLE_USAGE].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1, 2, 3, 4, 5 }
									, false);
									 return t;
								 }
								 final int view_catalog = 0;
								 final int view_schema = 1;
								 final int view_name = 2;
								 final int table_catalog = 3;
								 final int table_schema = 4;
								 final int table_name = 5;
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator tables;
								 Table table;
								 Object[] row;
								 tables = database.schemaManager.databaseObjectIterator(SchemaObject.TABLE);
								 while (tables.hasNext()) {
									 table = (Table) tables.next();
									 if (table.isView() && session.getGrantee().isFullyAccessibleByRole( table.getName())) {
									 }
									 else {
										 continue;
									 }
									 OrderedHashSet references = table.getReferences();
									 for (int i = 0;
									 i < references.size();
									 i++) {
										 HsqlName refName = (HsqlName) references.get(i);
										 if (!session.getGrantee().isFullyAccessibleByRole(refName)) {
											 continue;
										 }
										 if (refName.type != SchemaObject.TABLE) {
											 continue;
										 }
										 row = t.getEmptyRowData();
										 row[view_catalog] = database.getCatalogName().name;
										 row[view_schema] = table.getSchemaName().name;
										 row[view_name] = table.getName().name;
										 row[table_catalog] = database.getCatalogName().name;
										 row[table_schema] = refName.schema.name;
										 row[table_name] = refName.name;
										 try {
											 t.insertSys(store, row);
										 }
										 catch (HsqlException e) {
										}
									 }
								 }
								 return t;
							 }
							 Table VIEWS(Session session) {
								 Table t = sysTables[VIEWS];
								 if (t == null) {
									 t = createBlankTable(sysTableHsqlNames[VIEWS]);
									 addColumn(t, ""TABLE_CATALOG"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_SCHEMA"", SQL_IDENTIFIER);
									 addColumn(t, ""TABLE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""VIEW_DEFINITION"", CHARACTER_DATA);
									 addColumn(t, ""CHECK_OPTION"", CHARACTER_DATA);
									 addColumn(t, ""IS_UPDATABLE"", YES_OR_NO);
									 addColumn(t, ""INSERTABLE_INTO"", YES_OR_NO);
									 addColumn(t, ""IS_TRIGGER_UPDATABLE"", YES_OR_NO);
									 addColumn(t, ""IS_TRIGGER_DELETABLE"", YES_OR_NO);
									 addColumn(t, ""IS_TRIGGER_INSERTABLE_INTO"", YES_OR_NO);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[VIEWS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 1, 2, 0 }
									, false);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 Iterator tables;
								 Table table;
								 Object[] row;
								 final int table_catalog = 0;
								 final int table_schema = 1;
								 final int table_name = 2;
								 final int view_definition = 3;
								 final int check_option = 4;
								 final int is_updatable = 5;
								 final int insertable_into = 6;
								 final int is_trigger_updatable = 7;
								 final int is_trigger_deletable = 8;
								 final int is_trigger_insertable_into = 9;
								 tables = allTables();
								 while (tables.hasNext()) {
									 table = (Table) tables.next();
									 if ((table.getSchemaName() != SqlInvariants .INFORMATION_SCHEMA_HSQLNAME && !table .isView()) || !isAccessibleTable(session, table)) {
										 continue;
									 }
									 row = t.getEmptyRowData();
									 row[table_catalog] = database.getCatalogName().name;
									 row[table_schema] = table.getSchemaName().name;
									 row[table_name] = table.getName().name;
									 String check = Tokens.T_NONE;
									 if (table instanceof View) {
										 if (session.getGrantee().isFullyAccessibleByRole( table.getName())) {
											 row[view_definition] = ((View) table).getStatement();
										 }
										 switch (((View) table).getCheckOption()) {
											 case SchemaObject.ViewCheckModes.CHECK_NONE : break;
											 case SchemaObject.ViewCheckModes.CHECK_LOCAL : check = Tokens.T_LOCAL;
											 break;
											 case SchemaObject.ViewCheckModes.CHECK_CASCADE : check = Tokens.T_CASCADED;
											 break;
										 }
									 }
									 row[check_option] = check;
									 row[is_updatable] = table.isUpdatable() ? Tokens.T_YES : Tokens.T_NO;
									 row[insertable_into] = table.isInsertable() ? Tokens.T_YES : Tokens.T_NO;
									 row[is_trigger_updatable] = null;
									 row[is_trigger_deletable] = null;
									 row[is_trigger_insertable_into] = null;
									 t.insertSys(store, row);
								 }
								 return t;
							 }
							 Table ROLE_AUTHORIZATION_DESCRIPTORS(Session session) {
								 Table t = sysTables[ROLE_AUTHORIZATION_DESCRIPTORS];
								 if (t == null) {
									 t = createBlankTable( sysTableHsqlNames[ROLE_AUTHORIZATION_DESCRIPTORS]);
									 addColumn(t, ""ROLE_NAME"", SQL_IDENTIFIER);
									 addColumn(t, ""GRANTEE"", SQL_IDENTIFIER);
									 addColumn(t, ""GRANTOR"", SQL_IDENTIFIER);
									 addColumn(t, ""IS_GRANTABLE"", YES_OR_NO);
									 HsqlName name = HsqlNameManager.newInfoSchemaObjectName( sysTableHsqlNames[ROLE_AUTHORIZATION_DESCRIPTORS].name, false, SchemaObject.INDEX);
									 t.createPrimaryKeyConstraint(name, new int[] {
									 0, 1 }
									, true);
									 return t;
								 }
								 PersistentStore store = session.sessionData.getRowStore(t);
								 String grantorName = SqlInvariants.SYSTEM_AUTHORIZATION_NAME;
								 Iterator grantees;
								 Grantee granteeObject;
								 String granteeName;
								 Iterator roles;
								 String roleName;
								 String isGrantable;
								 Object[] row;
								 final int role_name = 0;
								 final int grantee = 1;
								 final int grantor = 2;
								 final int is_grantable = 3;
								 grantees = session.getGrantee().visibleGrantees().iterator();
								 while (grantees.hasNext()) {
									 granteeObject = (Grantee) grantees.next();
									 granteeName = granteeObject.getNameString();
									 roles = granteeObject.getDirectRoles().iterator();
									 isGrantable = granteeObject.isAdmin() ? Tokens.T_YES : Tokens.T_NO;
									;
									 while (roles.hasNext()) {
										 Grantee role = (Grantee) roles.next();
										 row = t.getEmptyRowData();
										 row[role_name] = role.getNameString();
										 row[grantee] = granteeName;
										 row[grantor] = grantorName;
										 row[is_grantable] = isGrantable;
										 t.insertSys(store, row);
									 }
								 }
								 return t;
							 }
						}",1,0,0,0
"public NotionalPeriod(Calendar startCalendar, Calendar endCalendar, Notional notional);",0,0,0,0
"public class ConfigurationListener extends Phase implements org.osgi.service.cm.ConfigurationListener {
	public static class Builder {
		public Builder(ContainerState containerState) {
			_containerState = containerState;
		}
		public Builder component(Component component) {
			_component = component;
			return this;
		}
		public ConfigurationListener build() {
			Objects.requireNonNull(_component);
			return new ConfigurationListener(_containerState, _component);
		}
		private Component _component;
		private final ContainerState _containerState;
	}
	protected ConfigurationListener(ContainerState containerState,Component component) {
		super(containerState, component);
		_component = component;
		_log = containerState.containerLogs().getLogger(getClass());
	}
	public boolean close() {
		try (Syncro open = syncro.open()) {
			if (_listenerService != null) {
				_listenerService.unregister();
				_listenerService = null;
			}
			return next.map(next -> {
				submit(next.closeOp(), next::close).onFailure(f -> {
					_log.error(l -> l.error(""CCR Failure in configuration listener close on {
					}
					"", next, f));
					error(f);
				}
				);
				return true;
			}
			).orElse(true);
		}
	}
	public Op closeOp() {
		return Op.of(Mode.CLOSE, Type.CONFIGURATION_LISTENER, _component.template().name);
	}
	public void configurationEvent(ConfigurationEvent event) {
		next.map(next -> (Component)next).ifPresent(next -> next.configurationTemplates().stream().filter(t -> Predicates.isMatchingConfiguration(event).test(t)).findFirst().ifPresent(t -> {
			String eventString = Arrays.asList(event.getPid(), event.getFactoryPid(), type(event)).toString();
			Promise<Boolean> result = containerState.submit(Op.of(Mode.OPEN, Type.CONFIGURATION_EVENT, eventString),() -> {
				_log.debug(l -> l.debug(""CCR Event {
				}
				 matched {
				}
				 because of {
				}
				"", eventString, _component.template().name, _component.template().configurations));
				processEvent(next, t, event);
				return true;
			}
			);
			try {
				result.getValue();
			}
			catch (Exception e) {
				Throw.exception(e);
			}
		}
		));
	}
	public boolean open() {
		try (Syncro open = syncro.open()) {
			if (containerState.bundleContext() == null) {
				return false;
			}
			Dictionary<String, Object> properties = new Hashtable<>();
			properties.put(""name"", toString());
			properties.put(Constants.SERVICE_DESCRIPTION, ""Aries CDI - Configuration Listener for "" + containerState.bundle());
			properties.put(Constants.SERVICE_VENDOR, ""Apache Software Foundation"");
			_listenerService = containerState.bundleContext().registerService(org.osgi.service.cm.ConfigurationListener.class, this, properties);
			return next.map(next -> (Component)next).map(component -> {
				submit(component.openOp(), component::open).then(s -> {
					component.configurationTemplates().stream().filter(ct -> Objects.nonNull(ct.pid)).forEach(template -> {
						if (template.maximumCardinality == MaximumCardinality.ONE) {
							containerState.findConfig(template.pid).ifPresent(c -> processEvent(component,template,new ConfigurationEvent(containerState.caTracker().getServiceReference(),ConfigurationEvent.CM_UPDATED,null,c.getPid())));
						}
						else {
							containerState.findConfigs(template.pid, true).ifPresent(arr -> Arrays.stream(arr).forEach(c -> processEvent(component,template,new ConfigurationEvent(containerState.caTracker().getServiceReference(),ConfigurationEvent.CM_UPDATED,c.getFactoryPid(),c.getPid()))));
						}
					}
					);
					return s;
				}
				,f -> {
					_log.error(l -> l.error(""CCR Failure during configuration start on {
					}
					"", next, f.getFailure()));
					error(f.getFailure());
				}
				);
				return true;
			}
			).orElse(true);
		}
	}
	public Op openOp() {
		return Op.of(Mode.OPEN, Type.CONFIGURATION_LISTENER, _component.template().name);
	}
	public String toString() {
		return Arrays.asList(getClass().getSimpleName(), _component).toString();
	}
	private void processEvent(Component component, ConfigurationTemplateDTO t, ConfigurationEvent event) {
		boolean required = t.policy == ConfigurationPolicy.REQUIRED;
		boolean single = t.maximumCardinality == MaximumCardinality.ONE;
		switch (event.getType()) {
			case ConfigurationEvent.CM_DELETED:component.instances().stream().map(ExtendedComponentInstanceDTO.class::cast).filter(instance -> (!single && event.getPid().equals(instance.pid)) || single).forEach(instance -> {
				submit(instance.closeOp(), instance::close).then(s -> {
					if (!required) {
						instance.configurations.removeIf(c -> c.template == t);
						submit(instance.openOp(), instance::open);
					}
					else {
						component.instances().remove(instance);
					}
					return s;
				}
				);
			}
			);
			return;
			case ConfigurationEvent.CM_LOCATION_CHANGED:break;
			case ConfigurationEvent.CM_UPDATED:if (!single &&!component.instances().stream().map(ExtendedComponentInstanceDTO.class::cast).filter(instance -> event.getPid().equals(instance.pid)).findFirst().isPresent()) {
				ExtendedComponentInstanceDTO instance = new ExtendedComponentInstanceDTO(containerState, _component.activatorBuilder());
				instance.activations = new CopyOnWriteArrayList<>();
				instance.configurations = new CopyOnWriteArrayList<>();
				instance.pid = event.getPid();
				instance.references = new CopyOnWriteArrayList<>();
				instance.template = component.template();
				component.instances().add(instance);
			}
			containerState.findConfig(event.getPid()).ifPresent(configuration -> {
				ExtendedConfigurationDTO configurationDTO = new ExtendedConfigurationDTO();
				configurationDTO.configuration = configuration;
				configurationDTO.pid = configuration.getPid();
				configurationDTO.properties = Maps.of(configuration.getProcessedProperties(event.getReference()));
				configurationDTO.template = t;
				component.instances().stream().map(ExtendedComponentInstanceDTO.class::cast).filter(instance -> (!single && event.getPid().equals(instance.pid)) || single).forEach(instance -> {
					submit(instance.closeOp(), instance::close).then(s -> {
						instance.configurations.removeIf(c -> c.template == t);
						instance.configurations.add(configurationDTO);
						submit(instance.openOp(), instance::open);
						return s;
					}
					);
				}
				);
			}
			);
			break;
		}
	}
	private String type(ConfigurationEvent event) {
		if (event.getType() == ConfigurationEvent.CM_DELETED)return ""DELETED"";
		if (event.getType() == ConfigurationEvent.CM_LOCATION_CHANGED)return ""LOCATION_CHANGED"";
		if (event.getType() == ConfigurationEvent.CM_UPDATED)return ""UPDATED"";
		throw new IllegalArgumentException(""CM Event type "" + event.getType());
	}
	private volatile ServiceRegistration<org.osgi.service.cm.ConfigurationListener> _listenerService;
	private final Component _component;
	private final Logger _log;
}",1,0,0,0
"public class NodeImpl extends ItemImpl implements Node {
	 private static Logger log = LoggerFactory.getLogger(NodeImpl.class);
	 protected NodeImpl(SessionImpl session, NodeState state, ItemLifeCycleListener[] listeners) {
		 super(session, state, listeners);
		 Name nodeTypeName = state.getNodeTypeName();
		 if (!session.getNodeTypeManager().hasNodeType(nodeTypeName)) {
			 throw new IllegalArgumentException(""Unknown nodetype "" + LogUtil.saveGetJCRName(nodeTypeName, session.getNameResolver()));
		 }
	 }
	 public String getName() throws RepositoryException {
		 checkStatus();
		 return session.getNameResolver().getJCRName(getQName());
	 }
	 public void accept(ItemVisitor visitor) throws RepositoryException {
		 checkStatus();
		 visitor.visit(this);
	 }
	 public boolean isNode() {
		 return true;
	 }
	 public Node addNode(String relPath) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {
		 return addNode(relPath, null);
	 }
	 public Node addNode(String relPath, String primaryNodeTypeName) throws ItemExistsException, PathNotFoundException, NoSuchNodeTypeException, LockException, VersionException, ConstraintViolationException, RepositoryException {
		 checkIsWritable();
		 Path nodePath = getPath(relPath).getNormalizedPath();
		 if (nodePath.getIndex() != Path.INDEX_UNDEFINED) {
			 String msg = ""Illegal subscript specified: "" + relPath;
			 log.debug(msg);
			 throw new RepositoryException(msg);
		 }
		 NodeImpl parentNode;
		 if (nodePath.getLength() == 1) {
			 parentNode = this;
		 }
		 else {
			 Path parentPath = nodePath.getAncestor(1);
			 ItemManager itemMgr = getItemManager();
			 if (itemMgr.nodeExists(parentPath)) {
				 parentNode = (NodeImpl) itemMgr.getNode(parentPath);
			 }
			 else if (itemMgr.propertyExists(parentPath)) {
				 String msg = ""Cannot add a node to property "" + LogUtil.safeGetJCRPath(parentPath, session.getPathResolver());
				 log.debug(msg);
				 throw new ConstraintViolationException(msg);
			 }
			 else {
				 throw new PathNotFoundException(""Cannot add a new node to a non-existing parent at "" + LogUtil.safeGetJCRPath(parentPath, session.getPathResolver()));
			 }
		 }
		 Name nodeName = nodePath.getName();
		 Name ntName = (primaryNodeTypeName == null) ? null : getQName(primaryNodeTypeName);
		 return parentNode.createNode(nodeName, ntName);
	 }
	 public synchronized void orderBefore(String srcChildRelPath, String destChildRelPath) throws UnsupportedRepositoryOperationException, VersionException, ConstraintViolationException, ItemNotFoundException, LockException, RepositoryException {
		 checkIsWritable();
		 if (!getPrimaryNodeType().hasOrderableChildNodes()) {
			 throw new UnsupportedRepositoryOperationException(""Child node ordering not supported on node "" + safeGetJCRPath());
		 }
		 if (srcChildRelPath.equals(destChildRelPath)) {
			 return;
		 }
		 if (!hasNode(srcChildRelPath)) {
			 throw new ItemNotFoundException(""Node "" + safeGetJCRPath() + "" has no child node with name "" + srcChildRelPath);
		 }
		 if (destChildRelPath != null && !hasNode(destChildRelPath)) {
			 throw new ItemNotFoundException(""Node "" + safeGetJCRPath() + "" has no child node with name "" + destChildRelPath);
		 }
		 Path srcPath = getReorderPath(srcChildRelPath);
		 Path beforePath = null;
		 if (destChildRelPath != null) {
			 beforePath = getReorderPath(destChildRelPath);
		 }
		 Operation op = ReorderNodes.create(getNodeState(), srcPath, beforePath);
		 session.getSessionItemStateManager().execute(op);
	 }
	 public Property setProperty(String name, Value value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 int type = PropertyType.UNDEFINED;
		 if (value != null) {
			 type = value.getType();
		 }
		 return setProperty(name, value, type);
	 }
	 public Property setProperty(String name, Value value, int type) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 checkIsWritable();
		 Name propName = getQName(name);
		 Property prop;
		 if (hasProperty(propName)) {
			 prop = getProperty(propName);
			 Value v = (type == PropertyType.UNDEFINED) ? value : ValueHelper.convert(value, type, session.getValueFactory());
			 prop.setValue(v);
		 }
		 else {
			 if (value == null) {
				 return new StaleProperty();
			 }
			 else {
				 prop = createProperty(propName, value, type);
			 }
		 }
		 return prop;
	 }
	 public Property setProperty(String name, Value[] values) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 int type;
		 if (values == null || values.length == 0 || values[0] == null) {
			 type = PropertyType.UNDEFINED;
		 }
		 else {
			 type = values[0].getType();
		 }
		 return setProperty(name, values, type);
	 }
	 public Property setProperty(String name, Value[] values, int type) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 checkIsWritable();
		 Name propName = getQName(name);
		 Property prop;
		 if (hasProperty(propName)) {
			 prop = getProperty(propName);
			 Value[] vs = (type == PropertyType.UNDEFINED) ? values : ValueHelper.convert(values, type, session.getValueFactory());
			 prop.setValue(vs);
		 }
		 else {
			 if (values == null) {
				 throw new ItemNotFoundException(""Cannot remove a non-existing property."");
			 }
			 else {
				 prop = createProperty(propName, values, type);
			 }
		 }
		 return prop;
	 }
	 public Property setProperty(String name, String[] values) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 return setProperty(name, values, PropertyType.UNDEFINED);
	 }
	 public Property setProperty(String name, String[] values, int type) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 Value[] vs;
		 if (type == PropertyType.UNDEFINED) {
			 vs = ValueHelper.convert(values, PropertyType.STRING, session.getValueFactory());
		 }
		 else {
			 vs = ValueHelper.convert(values, type, session.getValueFactory());
		 }
		 return setProperty(name, vs, type);
	 }
	 public Property setProperty(String name, String value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 Value v = (value == null) ? null : session.getValueFactory().createValue(value, PropertyType.STRING);
		 return setProperty(name, v, PropertyType.UNDEFINED);
	 }
	 public Property setProperty(String name, String value, int type) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 Value v = (value == null) ? null : session.getValueFactory().createValue(value, type);
		 return setProperty(name, v, type);
	 }
	 public Property setProperty(String name, InputStream value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 Value v = (value == null ? null : session.getValueFactory().createValue(value));
		 return setProperty(name, v, PropertyType.BINARY);
	 }
	 public Property setProperty(String name, Binary value) throws RepositoryException {
		 Value v = (value == null ? null : session.getValueFactory().createValue(value));
		 return setProperty(name, v, PropertyType.BINARY);
	 }
	 public Property setProperty(String name, boolean value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 return setProperty(name, session.getValueFactory().createValue(value), PropertyType.BOOLEAN);
	 }
	 public Property setProperty(String name, double value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 return setProperty(name, session.getValueFactory().createValue(value), PropertyType.DOUBLE);
	 }
	 public Property setProperty(String name, BigDecimal value) throws RepositoryException {
		 Value v = (value == null ? null : session.getValueFactory().createValue(value));
		 return setProperty(name, v, PropertyType.DECIMAL);
	 }
	 public Property setProperty(String name, long value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 return setProperty(name, session.getValueFactory().createValue(value), PropertyType.LONG);
	 }
	 public Property setProperty(String name, Calendar value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 Value v = (value == null ? null : session.getValueFactory().createValue(value));
		 return setProperty(name, v, PropertyType.DATE);
	 }
	 public Property setProperty(String name, Node value) throws ValueFormatException, VersionException, LockException, ConstraintViolationException, RepositoryException {
		 checkIsWritable();
		 Value v;
		 if (value == null) {
			 v = null;
		 }
		 else {
			 PropertyImpl.checkValidReference(value, PropertyType.REFERENCE, session.getNameResolver());
			 v = session.getValueFactory().createValue(value);
		 }
		 return setProperty(name, v, PropertyType.REFERENCE);
	 }
	 public Node getNode(String relPath) throws PathNotFoundException, RepositoryException {
		 checkStatus();
		 NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
		 if (nodeEntry == null) {
			 throw new PathNotFoundException(relPath);
		 }
		 try {
			 return (Node) getItemManager().getItem(nodeEntry);
		 }
		 catch (ItemNotFoundException e) {
			 throw new PathNotFoundException(relPath, e);
		 }
	 }
	 public NodeIterator getNodes() throws RepositoryException {
		 checkStatus();
		 try {
			 return getItemManager().getChildNodes(getNodeEntry());
		 }
		 catch (ItemNotFoundException infe) {
			 String msg = ""Failed to list the child nodes of "" + safeGetJCRPath();
			 log.debug(msg);
			 throw new RepositoryException(msg, infe);
		 }
		 catch (AccessDeniedException ade) {
			 String msg = ""Failed to list the child nodes of "" + safeGetJCRPath();
			 log.debug(msg);
			 throw new RepositoryException(msg, ade);
		 }
	 }
	 public NodeIterator getNodes(String namePattern) throws RepositoryException {
		 checkStatus();
		 return ChildrenCollectorFilter.collectChildNodes(this, namePattern);
	 }
	 public NodeIterator getNodes(String[] nameGlobs) throws RepositoryException {
		 checkStatus();
		 return ChildrenCollectorFilter.collectChildNodes(this, nameGlobs);
	 }
	 public Property getProperty(String relPath) throws PathNotFoundException, RepositoryException {
		 checkStatus();
		 PropertyEntry entry = resolveRelativePropertyPath(relPath);
		 if (entry == null) {
			 throw new PathNotFoundException(relPath);
		 }
		 try {
			 return (Property) getItemManager().getItem(entry);
		 }
		 catch (AccessDeniedException e) {
			 throw new PathNotFoundException(relPath);
		 }
		 catch (ItemNotFoundException e) {
			 throw new PathNotFoundException(relPath);
		 }
	 }
	 public PropertyIterator getProperties() throws RepositoryException {
		 checkStatus();
		 try {
			 return getItemManager().getChildProperties(getNodeEntry());
		 }
		 catch (ItemNotFoundException infe) {
			 String msg = ""Failed to list the child properties of "" + getPath();
			 log.debug(msg);
			 throw new RepositoryException(msg, infe);
		 }
		 catch (AccessDeniedException ade) {
			 String msg = ""Failed to list the child properties of "" + getPath();
			 log.debug(msg);
			 throw new RepositoryException(msg, ade);
		 }
	 }
	 public PropertyIterator getProperties(String namePattern) throws RepositoryException {
		 checkStatus();
		 return ChildrenCollectorFilter.collectProperties(this, namePattern);
	 }
	 public PropertyIterator getProperties(String[] nameGlobs) throws RepositoryException {
		 checkStatus();
		 return ChildrenCollectorFilter.collectProperties(this, nameGlobs);
	 }
	 public Item getPrimaryItem() throws ItemNotFoundException, RepositoryException {
		 checkStatus();
		 String name = getPrimaryNodeType().getPrimaryItemName();
		 if (name == null) {
			 throw new ItemNotFoundException(""No primary item present on Node "" + safeGetJCRPath());
		 }
		 if (hasProperty(name)) {
			 return getProperty(name);
		 }
		 else if (hasNode(name)) {
			 return getNode(name);
		 }
		 else {
			 throw new ItemNotFoundException(""Primary item "" + name + "" does not exist on Node "" + safeGetJCRPath());
		 }
	 }
	 public String getUUID() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkStatus();
		 String uuid = getNodeState().getUniqueID();
		 if (uuid == null || !isNodeType(NameConstants.MIX_REFERENCEABLE)) {
			 throw new UnsupportedRepositoryOperationException();
		 }
		 return uuid;
	 }
	 public String getIdentifier() throws RepositoryException {
		 checkStatus();
		 return session.getIdFactory().toJcrIdentifier(getNodeEntry().getId());
	 }
	 public int getIndex() throws RepositoryException {
		 checkStatus();
		 int index = getNodeEntry().getIndex();
		 if (index == Path.INDEX_UNDEFINED) {
			 throw new RepositoryException(""Error while retrieving index."");
		 }
		 return index;
	 }
	 public PropertyIterator getReferences() throws RepositoryException {
		 return getReferences(null);
	 }
	 public PropertyIterator getReferences(String name) throws RepositoryException {
		 return getReferences(name, false);
	 }
	 public PropertyIterator getWeakReferences() throws RepositoryException {
		 return getWeakReferences(null);
	 }
	 public PropertyIterator getWeakReferences(String name) throws RepositoryException {
		 return getReferences(name, true);
	 }
	 public boolean hasNode(String relPath) throws RepositoryException {
		 checkStatus();
		 NodeEntry nodeEntry = resolveRelativeNodePath(relPath);
		 return (nodeEntry != null) && getItemManager().itemExists(nodeEntry);
	 }
	 public boolean hasProperty(String relPath) throws RepositoryException {
		 checkStatus();
		 PropertyEntry childEntry = resolveRelativePropertyPath(relPath);
		 return (childEntry != null) && getItemManager().itemExists(childEntry);
	 }
	 private boolean hasProperty(Name propertyName) {
		 return getNodeEntry().hasPropertyEntry(propertyName);
	 }
	 public boolean hasNodes() throws RepositoryException {
		 checkStatus();
		 return getItemManager().hasChildNodes(getNodeEntry());
	 }
	 public boolean hasProperties() throws RepositoryException {
		 checkStatus();
		 return getItemManager().hasChildProperties(getNodeEntry());
	 }
	 public NodeType getPrimaryNodeType() throws RepositoryException {
		 checkStatus();
		 return session.getNodeTypeManager().getNodeType(getPrimaryNodeTypeName());
	 }
	 public void setPrimaryType(String nodeTypeName) throws RepositoryException {
		 checkStatus();
		 if (getNodeState().isRoot()) {
			 String msg = ""The primary type of the root node may not be changed."";
			 log.debug(msg);
			 throw new RepositoryException(msg);
		 }
		 Name ntName = getQName(nodeTypeName);
		 if (ntName.equals(getPrimaryNodeTypeName())) {
			 log.debug(""Changing the primary type has no effect: '"" + nodeTypeName + ""' already is the primary node type."");
			 return;
		 }
		 NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
		 NodeType nt = ntMgr.getNodeType(ntName);
		 if (nt.isMixin() || nt.isAbstract()) {
			 throw new ConstraintViolationException(""Cannot change the primary type: '"" + nodeTypeName + ""' is a mixin type or abstract."");
		 }
		 Operation op = SetPrimaryType.create(getNodeState(), ntName);
		 session.getSessionItemStateManager().execute(op);
	 }
	 public NodeType[] getMixinNodeTypes() throws RepositoryException {
		 checkStatus();
		 Name[] mixinNames = getNodeState().getMixinTypeNames();
		 NodeType[] nta = new NodeType[mixinNames.length];
		 for (int i = 0;
		 i < mixinNames.length;
		 i++) {
			 nta[i] = session.getNodeTypeManager().getNodeType(mixinNames[i]);
		 }
		 return nta;
	 }
	 public boolean isNodeType(String nodeTypeName) throws RepositoryException {
		 checkStatus();
		 if (session.getNameResolver().getJCRName(getPrimaryNodeTypeName()).equals(nodeTypeName)) {
			 return true;
		 }
		 return isNodeType(getQName(nodeTypeName));
	 }
	 public void addMixin(String mixinName) throws NoSuchNodeTypeException, VersionException, ConstraintViolationException, LockException, RepositoryException {
		 checkIsWritable();
		 Name mixinQName = getQName(mixinName);
		 List<Name> mixinValue = getMixinTypes();
		 if (!mixinValue.contains(mixinQName) && !isNodeType(mixinQName)) {
			 if (!canAddMixin(mixinQName)) {
				 throw new ConstraintViolationException(""Cannot add '"" + mixinName + ""' mixin type."");
			 }
			 mixinValue.add(mixinQName);
			 Operation op = SetMixin.create(getNodeState(), mixinValue.toArray(new Name[mixinValue.size()]));
			 session.getSessionItemStateManager().execute(op);
		 }
	 }
	 public void removeMixin(String mixinName) throws NoSuchNodeTypeException, VersionException, ConstraintViolationException, LockException, RepositoryException {
		 checkIsWritable();
		 Name ntName = getQName(mixinName);
		 List<Name> mixinValue = getMixinTypes();
		 if (!mixinValue.remove(ntName)) {
			 throw new NoSuchNodeTypeException(""Cannot remove mixin '"" + mixinName + ""': Nodetype is not present on this node."");
		 }
		 NodeTypeImpl mixin = session.getNodeTypeManager().getNodeType(ntName);
		 if (mixin.isNodeType(NameConstants.MIX_REFERENCEABLE)) {
			 EffectiveNodeType entRemaining = getRemainingENT(mixinValue);
			 if (!entRemaining.includesNodeType(NameConstants.MIX_REFERENCEABLE)) {
				 PropertyIterator iter = getReferences();
				 if (iter.hasNext()) {
					 throw new ConstraintViolationException(""Mixin type "" + mixinName + "" can not be removed: the node is being referenced through at least one property of type REFERENCE"");
				 }
			 }
		 }
		 if (mixin.isNodeType((NameConstants.MIX_LOCKABLE))) {
			 EffectiveNodeType entRemaining = getRemainingENT(mixinValue);
			 if (!entRemaining.includesNodeType(NameConstants.MIX_LOCKABLE) && isLocked()) {
				 throw new ConstraintViolationException(mixinName + "" can not be removed: the node is locked."");
			 }
		 }
		 Name[] mixins = mixinValue.toArray(new Name[mixinValue.size()]);
		 Operation op = SetMixin.create(getNodeState(), mixins);
		 session.getSessionItemStateManager().execute(op);
	 }
	 private List<Name> getMixinTypes() {
		 Name[] mixinValue;
		 if (getNodeState().getStatus() == Status.EXISTING) {
			 mixinValue = getNodeState().getMixinTypeNames();
		 }
		 else {
			 try {
				 PropertyEntry pe = getNodeEntry().getPropertyEntry(NameConstants.JCR_MIXINTYPES);
				 if (pe != null) {
					 mixinValue = StateUtility.getMixinNames(pe.getPropertyState());
				 }
				 else {
					 mixinValue = getNodeState().getMixinTypeNames();
				 }
			 }
			 catch (RepositoryException e) {
				 log.warn(""Internal error"", e);
				 mixinValue = Name.EMPTY_ARRAY;
			 }
		 }
		 List<Name> l = new ArrayList<Name>();
		 l.addAll(Arrays.asList(mixinValue));
		 return l;
	 }
	 private EffectiveNodeType getRemainingENT(List<Name> remainingMixins) throws ConstraintViolationException, NoSuchNodeTypeException {
		 Name[] allRemaining = remainingMixins.toArray(new Name[remainingMixins.size() + 1]);
		 allRemaining[remainingMixins.size()] = getPrimaryNodeTypeName();
		 return session.getEffectiveNodeTypeProvider().getEffectiveNodeType(allRemaining);
	 }
	 public boolean canAddMixin(String mixinName) throws RepositoryException {
		 if (!isWritable()) {
			 return false;
		 }
		 try {
			 session.getValidator().checkIsWritable(getNodeState(), ItemStateValidator.CHECK_ALL);
			 return canAddMixin(getQName(mixinName));
		 }
		 catch (LockException e) {
			 log.debug(""Cannot add mixin '"" + mixinName + ""': "" + e.getMessage());
			 return false;
		 }
		 catch (VersionException e) {
			 log.debug(""Cannot add mixin '"" + mixinName + ""': "" + e.getMessage());
			 return false;
		 }
		 catch (ConstraintViolationException e) {
			 log.debug(""Cannot add mixin '"" + mixinName + ""': "" + e.getMessage());
			 return false;
		 }
	 }
	 public NodeDefinition getDefinition() throws RepositoryException {
		 checkStatus();
		 QNodeDefinition qnd = getNodeState().getDefinition();
		 return session.getNodeTypeManager().getNodeDefinition(qnd);
	 }
	 public Version checkin() throws VersionException, UnsupportedRepositoryOperationException, InvalidItemStateException, LockException, RepositoryException {
		 checkIsVersionable();
		 checkHasPendingChanges();
		 checkIsLocked();
		 if (isCheckedOut()) {
			 NodeEntry newVersion = session.getVersionStateManager().checkin(getNodeState());
			 return (Version) getItemManager().getItem(newVersion);
		 }
		 else {
			 log.debug(""Node "" + safeGetJCRPath() + "" is already checked in."");
			 return getBaseVersion();
		 }
	 }
	 public void checkout() throws UnsupportedRepositoryOperationException, LockException, RepositoryException {
		 checkIsVersionable();
		 checkIsLocked();
		 if (!isCheckedOut()) {
			 if (session.isSupportedOption(Repository.OPTION_ACTIVITIES_SUPPORTED)) {
				 NodeImpl activity = (NodeImpl) session.getWorkspace().getVersionManager().getActivity();
				 NodeId activityId = (activity == null) ? null : activity.getNodeState().getNodeId();
				 session.getVersionStateManager().checkout(getNodeState(), activityId);
			 }
			 else {
				 session.getVersionStateManager().checkout(getNodeState());
			 }
		 }
		 else {
			 log.debug(""Node "" + safeGetJCRPath() + "" is already checked out."");
		 }
	 }
	 Version checkpoint() throws RepositoryException {
		 checkIsVersionable();
		 checkHasPendingChanges();
		 checkIsLocked();
		 if (!isCheckedOut()) {
			 checkout();
			 return getBaseVersion();
		 }
		 else {
			 NodeEntry newVersion;
			 if (session.isSupportedOption(Repository.OPTION_ACTIVITIES_SUPPORTED)) {
				 NodeImpl activity = (NodeImpl) session.getWorkspace().getVersionManager().getActivity();
				 NodeId activityId = (activity == null) ? null : activity.getNodeState().getNodeId();
				 newVersion = session.getVersionStateManager().checkpoint(getNodeState(), activityId);
			 }
			 else {
				 newVersion = session.getVersionStateManager().checkpoint(getNodeState());
			 }
			 return (Version) getItemManager().getItem(newVersion);
		 }
	 }
	 public void doneMerge(Version version) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
		 resolveMergeConflict(version, true);
	 }
	 public void cancelMerge(Version version) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
		 resolveMergeConflict(version, false);
	 }
	 private void resolveMergeConflict(Version version, boolean done) throws VersionException, InvalidItemStateException, UnsupportedRepositoryOperationException, RepositoryException {
		 checkIsVersionable();
		 checkHasPendingChanges();
		 checkIsLocked();
		 if (!isCheckedOut()) {
			 String msg = ""Unable to resolve merge conflict. Node is checked-in: "" + safeGetJCRPath();
			 log.error(msg);
			 throw new VersionException(msg);
		 }
		 boolean isConflicting = false;
		 if (hasProperty(NameConstants.JCR_MERGEFAILED)) {
			 Value[] vals = getProperty(NameConstants.JCR_MERGEFAILED).getValues();
			 for (int i = 0;
			 i < vals.length && !isConflicting;
			 i++) {
				 isConflicting = vals[i].getString().equals(version.getUUID());
			 }
		 }
		 if (!isConflicting) {
			 String msg = ""Unable to resolve merge conflict. Specified version is not in jcr:mergeFailed property: "" + safeGetJCRPath();
			 log.error(msg);
			 throw new VersionException(msg);
		 }
		 NodeState versionState = session.getVersionState(version);
		 session.getVersionStateManager().resolveMergeConflict(getNodeState(), versionState, done);
	 }
	 public void update(String srcWorkspaceName) throws NoSuchWorkspaceException, AccessDeniedException, LockException, InvalidItemStateException, RepositoryException {
		 checkIsWritable();
		 checkSessionHasPendingChanges();
		 if (session.getWorkspace().getName().equals(srcWorkspaceName)) {
			 return;
		 }
		 try {
			 getCorrespondingNodePath(srcWorkspaceName);
		 }
		 catch (ItemNotFoundException e) {
			 return;
		 }
		 Operation op = Update.create(getNodeState(), srcWorkspaceName);
		 ((WorkspaceImpl)session.getWorkspace()).getUpdatableItemStateManager().execute(op);
	 }
	 public NodeIterator merge(String srcWorkspace, boolean bestEffort) throws NoSuchWorkspaceException, AccessDeniedException, VersionException, LockException, InvalidItemStateException, RepositoryException {
		 return session.getWorkspace().getVersionManager().merge(getPath(), srcWorkspace, bestEffort);
	 }
	 public NodeIterator merge(String srcWorkspace, boolean bestEffort, boolean isShallow) throws RepositoryException {
		 return session.getWorkspace().getVersionManager().merge(getPath(), srcWorkspace, bestEffort, isShallow);
	 }
	 public String getCorrespondingNodePath(String workspaceName) throws ItemNotFoundException, NoSuchWorkspaceException, AccessDeniedException, RepositoryException {
		 checkStatus();
		 SessionImpl srcSession = null;
		 try {
			 srcSession = session.switchWorkspace(workspaceName);
			 NodeImpl referenceableNode = this;
			 while (referenceableNode.getDepth() != Path.ROOT_DEPTH && !referenceableNode.isNodeType(NameConstants.MIX_REFERENCEABLE)) {
				 referenceableNode = (NodeImpl) referenceableNode.getParent();
			 }
			 String correspondingPath;
			 if (referenceableNode.getDepth() == Path.ROOT_DEPTH) {
				 if (!srcSession.getItemManager().nodeExists(getQPath())) {
					 throw new ItemNotFoundException(""No corresponding path found in workspace "" + workspaceName + ""("" + safeGetJCRPath() + "")"");
				 }
				 else {
					 correspondingPath = getPath();
				 }
			 }
			 else {
				 Node correspNode = srcSession.getNodeByUUID(referenceableNode.getUUID());
				 if (referenceableNode == this) {
					 correspondingPath = correspNode.getPath();
				 }
				 else {
					 Path p = referenceableNode.getQPath().computeRelativePath(getQPath());
					 String relPath = session.getPathResolver().getJCRPath(p);
					 if (!correspNode.hasNode(relPath)) {
						 throw new ItemNotFoundException(""No corresponding path found in workspace "" + workspaceName + ""("" + safeGetJCRPath() + "")"");
					 }
					 else {
						 correspondingPath = correspNode.getNode(relPath).getPath();
					 }
				 }
			 }
			 return correspondingPath;
		 }
		 finally {
			 if (srcSession != null) {
				 srcSession.logout();
			 }
		 }
	 }
	 public boolean isCheckedOut() throws RepositoryException {
		 checkStatus();
		 if (isNew()) {
			 return true;
		 }
		 return session.getVersionStateManager().isCheckedOut(getNodeState());
	 }
	 public void restore(String versionName, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
		 checkSessionHasPendingChanges();
		 Version v = getVersionHistory().getVersion(versionName);
		 restore(this, null, v, removeExisting);
	 }
	 public void restore(Version version, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, RepositoryException {
		 checkSessionHasPendingChanges();
		 restore(this, null, version, removeExisting);
	 }
	 public void restore(Version version, String relPath, boolean removeExisting) throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
		 checkSessionHasPendingChanges();
		 if (hasNode(relPath)) {
			 getNode(relPath).restore(version, removeExisting);
		 }
		 else {
			 Path nPath = getPath(relPath);
			 Path parentPath = nPath.getAncestor(1);
			 ItemManager itemMgr = getItemManager();
			 if (itemMgr.nodeExists(parentPath)) {
				 Node parent = itemMgr.getNode(parentPath);
				 Path relQPath = parentPath.computeRelativePath(nPath);
				 NodeImpl parentNode = ((NodeImpl)parent);
				 restore(parentNode, relQPath, version, removeExisting);
			 }
			 else if (itemMgr.propertyExists(parentPath)) {
				 throw new ConstraintViolationException(""Cannot restore to a parent presenting a property (relative path = '"" + relPath + ""'"");
			 }
			 else {
				 throw new PathNotFoundException(""Cannot restore to relative path '"" + relPath + "": Ancestor does not exist."");
			 }
		 }
	 }
	 public void restoreByLabel(String versionLabel, boolean removeExisting) throws VersionException, ItemExistsException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
		 checkSessionHasPendingChanges();
		 Version v = getVersionHistory().getVersionByLabel(versionLabel);
		 if (v == null) {
			 throw new VersionException(""No version for label "" + versionLabel + "" found."");
		 }
		 restore(this, null, v, removeExisting);
	 }
	 private void restore(NodeImpl targetNode, Path relQPath, Version version, boolean removeExisting) throws PathNotFoundException, ItemExistsException, VersionException, ConstraintViolationException, UnsupportedRepositoryOperationException, LockException, InvalidItemStateException, RepositoryException {
		 if (relQPath == null) {
			 targetNode.checkIsVersionable();
			 VersionHistory vH = targetNode.getVersionHistory();
			 if (!vH.isSame(version.getContainingHistory())) {
				 throw new VersionException(""Version "" + version + "" does not correspond to the restore target."");
			 }
			 if (vH.getRootVersion().isSame(version)) {
				 throw new VersionException(""Attempt to restore root version."");
			 }
			 targetNode.checkIsWritable();
			 targetNode.checkIsLocked();
		 }
		 else {
			 if (!targetNode.isCheckedOut()) {
				 throw new VersionException(""Parent "" + targetNode.safeGetJCRPath() + "" for non-existing restore target '"" + LogUtil.safeGetJCRPath(relQPath, session.getPathResolver()) + ""' must be checked out."");
			 }
			 targetNode.checkIsLocked();
		 }
		 NodeState versionState = session.getVersionState(version);
		 session.getVersionStateManager().restore(targetNode.getNodeState(), relQPath, versionState, removeExisting);
	 }
	 public VersionHistory getVersionHistory() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkIsVersionable();
		 return (VersionHistory) getProperty(NameConstants.JCR_VERSIONHISTORY).getNode();
	 }
	 public Version getBaseVersion() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkIsVersionable();
		 return (Version) getProperty(NameConstants.JCR_BASEVERSION).getNode();
	 }
	 public Lock lock(boolean isDeep, boolean isSessionScoped) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
		 return lock(isDeep, isSessionScoped, Long.MAX_VALUE, null);
	 }
	 public Lock lock(boolean isDeep, boolean isSessionScoped, long timeoutHint, String ownerHint) throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
		 checkIsLockable();
		 checkHasPendingChanges();
		 return session.getLockStateManager().lock(getNodeState(), isDeep, isSessionScoped, timeoutHint, ownerHint);
	 }
	 public Lock getLock() throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, RepositoryException {
		 checkStatus();
		 return session.getLockStateManager().getLock(getNodeState());
	 }
	 public void unlock() throws UnsupportedRepositoryOperationException, LockException, AccessDeniedException, InvalidItemStateException, RepositoryException {
		 checkIsLockable();
		 checkHasPendingChanges();
		 session.getLockStateManager().unlock(getNodeState());
	 }
	 public boolean holdsLock() throws RepositoryException {
		 checkStatus();
		 if (isNew() || !isNodeType(NameConstants.MIX_LOCKABLE)) {
			 return false;
		 }
		 else {
			 LockStateManager lMgr = session.getLockStateManager();
			 return (lMgr.isLocked(getNodeState()) && lMgr.getLock(getNodeState()).getNode().isSame(this));
		 }
	 }
	 public boolean isLocked() throws RepositoryException {
		 checkStatus();
		 return session.getLockStateManager().isLocked(getNodeState());
	 }
	 public void followLifecycleTransition(String transition) throws RepositoryException {
		 session.checkSupportedOption(Repository.OPTION_LIFECYCLE_SUPPORTED);
		 throw new UnsupportedRepositoryOperationException(""JCR-1104"");
	 }
	 public String[] getAllowedLifecycleTransistions() throws RepositoryException {
		 session.checkSupportedOption(Repository.OPTION_LIFECYCLE_SUPPORTED);
		 throw new UnsupportedRepositoryOperationException(""JCR-1104"");
	 }
	 public NodeIterator getSharedSet() throws RepositoryException {
		 throw new UnsupportedRepositoryOperationException(""JCR-1104"");
	 }
	 public void removeShare() throws RepositoryException {
		 throw new UnsupportedRepositoryOperationException(""JCR-1104"");
	 }
	 public void removeSharedSet() throws RepositoryException {
		 throw new UnsupportedRepositoryOperationException(""JCR-1104"");
	 }
	 boolean isNodeType(Name qName) throws RepositoryException {
		 if (qName.equals(getPrimaryNodeTypeName())) {
			 return true;
		 }
		 for (Name mixin : getNodeState().getMixinTypeNames()) {
			 if (mixin.equals(qName)) {
				 return true;
			 }
		 }
		 if (getNodeState().getStatus() == Status.NEW && session.getNodeTypeManager().getNodeType(qName).isMixin()) {
			 return false;
		 }
		 EffectiveNodeType effnt = session.getEffectiveNodeTypeProvider().getEffectiveNodeType(getNodeState().getNodeTypeNames());
		 return effnt.includesNodeType(qName);
	 }
	 Name getQName() throws RepositoryException {
		 if (getNodeState().isRoot()) {
			 return NameConstants.ROOT;
		 }
		 return getNodeState().getName();
	 }
	 private void checkSessionHasPendingChanges() throws RepositoryException {
		 session.checkHasPendingChanges();
	 }
	 private void checkHasPendingChanges() throws InvalidItemStateException, RepositoryException {
		 if (hasPendingChanges()) {
			 String msg = ""Node has pending changes: "" + getPath();
			 log.debug(msg);
			 throw new InvalidItemStateException(msg);
		 }
	 }
	 private boolean hasPendingChanges() {
		 return isModified() || isNew();
	 }
	 private void checkIsLockable() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkStatus();
		 if (!isNodeType(NameConstants.MIX_LOCKABLE)) {
			 String msg = ""Unable to perform locking operation on non-lockable node: "" + getPath();
			 log.debug(msg);
			 throw new LockException(msg);
		 }
	 }
	 void checkIsLocked() throws LockException, RepositoryException {
		 if (isNew()) {
			 return;
		 }
		 session.getLockStateManager().checkLock(getNodeState());
	 }
	 private void checkIsVersionable() throws UnsupportedRepositoryOperationException, RepositoryException {
		 checkStatus();
		 if (!isNodeType(NameConstants.MIX_VERSIONABLE)) {
			 String msg = ""Unable to perform versioning operation on non versionable node: "" + getPath();
			 log.debug(msg);
			 throw new UnsupportedRepositoryOperationException(msg);
		 }
	 }
	 private synchronized Node createNode(Name nodeName, Name nodeTypeName) throws ItemExistsException, NoSuchNodeTypeException, VersionException, ConstraintViolationException, LockException, RepositoryException {
		 QNodeDefinition definition = session.getItemDefinitionProvider().getQNodeDefinition(getNodeState().getAllNodeTypeNames(), nodeName, nodeTypeName);
		 if (nodeTypeName == null) {
			 nodeTypeName = definition.getDefaultPrimaryType();
		 }
		 Operation an = AddNode.create(getNodeState(), nodeName, nodeTypeName, null);
		 session.getSessionItemStateManager().execute(an);
		 List<ItemState> addedStates = ((AddNode) an).getAddedStates();
		 ItemState nState = addedStates.get(0);
		 return (Node) getItemManager().getItem(nState.getHierarchyEntry());
	 }
	 protected Node getNode(Name nodeName, int index) throws PathNotFoundException, RepositoryException {
		 checkStatus();
		 try {
			 NodeEntry nEntry = getNodeEntry().getNodeEntry(nodeName, index);
			 if (nEntry == null) {
				 throw new PathNotFoundException(LogUtil.saveGetJCRName(nodeName, session.getNameResolver()));
			 }
			 return (Node) getItemManager().getItem(nEntry);
		 }
		 catch (AccessDeniedException e) {
			 throw new PathNotFoundException(LogUtil.saveGetJCRName(nodeName, session.getNameResolver()));
		 }
	 }
	 protected Property getProperty(Name qName) throws PathNotFoundException, RepositoryException {
		 checkStatus();
		 try {
			 PropertyEntry pEntry = getNodeEntry().getPropertyEntry(qName, true);
			 if (pEntry == null) {
				 throw new PathNotFoundException(LogUtil.saveGetJCRName(qName, session.getNameResolver()));
			 }
			 return (Property) getItemManager().getItem(pEntry);
		 }
		 catch (AccessDeniedException e) {
			 throw new PathNotFoundException(LogUtil.saveGetJCRName(qName, session.getNameResolver()));
		 }
	 }
	 private Property createProperty(Name qName, Value value, int type) throws ConstraintViolationException, RepositoryException {
		 QPropertyDefinition def = getApplicablePropertyDefinition(qName, type, false);
		 int targetType = def.getRequiredType();
		 if (targetType == PropertyType.UNDEFINED) {
			 targetType = type;
		 }
		 QValue qvs;
		 if (targetType == PropertyType.UNDEFINED) {
			 qvs = ValueFormat.getQValue(value, session.getNamePathResolver(), session.getQValueFactory());
			 targetType = qvs.getType();
		 }
		 else {
			 Value targetValue = ValueHelper.convert(value, targetType, session.getValueFactory());
			 qvs = ValueFormat.getQValue(targetValue, session.getNamePathResolver(), session.getQValueFactory());
		 }
		 return createProperty(qName, targetType, def, new QValue[] {
		qvs}
		);
	 }
	 private Property createProperty(Name qName, Value[] values, int type) throws ConstraintViolationException, RepositoryException {
		 QPropertyDefinition def = getApplicablePropertyDefinition(qName, type, true);
		 int targetType = def.getRequiredType();
		 if (targetType == PropertyType.UNDEFINED) {
			 if (type == PropertyType.UNDEFINED) {
				 if (values.length > 0) {
					 for (Value value : values) {
						 if (value != null) {
							 targetType = value.getType();
							 break;
						 }
					 }
				 }
				 if (targetType == PropertyType.UNDEFINED) {
					 targetType = PropertyType.STRING;
				 }
			 }
			 else {
				 targetType = type;
			 }
		 }
		 Value[] targetValues = ValueHelper.convert(values, targetType, session.getValueFactory());
		 QValue[] qvs = ValueFormat.getQValues(targetValues, session.getNamePathResolver(), session.getQValueFactory());
		 return createProperty(qName, targetType, def, qvs);
	 }
	 private Property createProperty(Name qName, int type, QPropertyDefinition def, QValue[] qvs) throws ConstraintViolationException, RepositoryException {
		 Operation op = AddProperty.create(getNodeState(), qName, type, def, qvs);
		 session.getSessionItemStateManager().execute(op);
		 return getProperty(qName);
	 }
	 private Name getQName(String jcrName) throws RepositoryException {
		 Name qName;
		 try {
			 qName = session.getNameResolver().getQName(jcrName);
		 }
		 catch (NameException upe) {
			 throw new RepositoryException(""invalid name: ""+ jcrName, upe);
		 }
		 return qName;
	 }
	 private Name getPrimaryNodeTypeName() {
		 return getNodeState().getNodeTypeName();
	 }
	 private LazyItemIterator getReferences(String name, boolean weak) throws RepositoryException {
		 checkStatus();
		 Name propName = (name == null) ? null : getQName(name);
		 Iterator<PropertyId> itr = getNodeState().getNodeReferences(propName, weak);
		 return new LazyItemIterator(getItemManager(), session.getHierarchyManager(), itr);
	 }
	 private boolean canAddMixin(Name mixinName) throws NoSuchNodeTypeException, ConstraintViolationException {
		 NodeTypeManagerImpl ntMgr = session.getNodeTypeManager();
		 NodeType mixin = ntMgr.getNodeType(mixinName);
		 if (!mixin.isMixin()) {
			 log.error(mixin.getName() + "": not a mixin node type"");
			 return false;
		 }
		 Name[] existingNts = getNodeState().getNodeTypeNames();
		 EffectiveNodeType entExisting = session.getEffectiveNodeTypeProvider().getEffectiveNodeType(existingNts);
		 if (!entExisting.supportsMixin(mixinName)) {
			 log.debug(mixin.getName() + "": not supported on node type "" + getPrimaryNodeTypeName());
			 return false;
		 }
		 Name[] resultingNts = new Name[existingNts.length + 1];
		 System.arraycopy(existingNts, 0, resultingNts, 0, existingNts.length);
		 resultingNts[existingNts.length] = mixinName;
		 session.getEffectiveNodeTypeProvider().getEffectiveNodeType(resultingNts);
		 return true;
	 }
	 private NodeState getNodeState() {
		 return (NodeState) getItemState();
	 }
	 private NodeEntry getNodeEntry() {
		 return (NodeEntry) getItemState().getHierarchyEntry();
	 }
	 private Path getReorderPath(String relativePath) throws RepositoryException {
		 try {
			 Path p = session.getPathResolver().getQPath(relativePath);
			 if (p.isAbsolute() || p.getLength() != 1 || p.getDepth() != 1) {
				 throw new RepositoryException(""Invalid relative path: "" + relativePath);
			 }
			 return p;
		 }
		 catch (NameException e) {
			 String msg = ""Invalid relative path: "" + relativePath;
			 log.debug(msg);
			 throw new RepositoryException(msg, e);
		 }
	 }
	 private Path getPath(String relativeJcrPath) throws RepositoryException {
		 try {
			 Path p = session.getPathResolver().getQPath(relativeJcrPath);
			 return getPath(p);
		 }
		 catch (NameException e) {
			 String msg = ""Invalid relative path: "" + relativeJcrPath;
			 log.debug(msg);
			 throw new RepositoryException(msg, e);
		 }
	 }
	 private Path getPath(Path relativePath) throws RepositoryException {
		 if (relativePath.getLength() == 1 && relativePath.denotesCurrent()) {
			 return getQPath();
		 }
		 return session.getPathFactory().create(getQPath(), relativePath, true);
	 }
	 private NodeEntry resolveRelativeNodePath(String relPath) throws RepositoryException {
		 NodeEntry targetEntry = null;
		 try {
			 Path rp = session.getPathResolver().getQPath(relPath);
			 if (rp.getLength() == 1) {
				 if (rp.denotesCurrent()) {
					 targetEntry = getNodeEntry();
				 }
				 else if (rp.denotesParent()) {
					 targetEntry = getNodeEntry().getParent();
				 }
				 else {
					 targetEntry = getNodeEntry().getNodeEntry( rp.getName(), rp.getNormalizedIndex(), true);
				 }
			 }
			 else {
				 Path p = getPath(rp);
				 targetEntry = session.getHierarchyManager().getNodeEntry(p.getCanonicalPath());
			 }
		 }
		 catch (PathNotFoundException e) {
		 }
		 catch (NameException e) {
			 String msg = ""Invalid relative path: "" + relPath;
			 log.debug(msg);
			 throw new RepositoryException(msg, e);
		 }
		 return targetEntry;
	 }
	 private PropertyEntry resolveRelativePropertyPath(String relPath) throws RepositoryException {
		 PropertyEntry targetEntry = null;
		 try {
			 Path rp = session.getPathResolver().getQPath(relPath);
			 if (rp.getLength() == 1 && rp.denotesName()) {
				 Name propName = rp.getName();
				 targetEntry = getNodeEntry().getPropertyEntry(propName, true);
			 }
			 else {
				 Path p = getPath(rp).getCanonicalPath();
				 try {
					 targetEntry = session.getHierarchyManager().getPropertyEntry(p);
				 }
				 catch (PathNotFoundException e) {
				 }
			 }
		 }
		 catch (NameException e) {
			 String msg = ""failed to resolve property path "" + relPath + "" relative to "" + safeGetJCRPath();
			 log.debug(msg);
			 throw new RepositoryException(msg, e);
		 }
		 return targetEntry;
	 }
	 private QPropertyDefinition getApplicablePropertyDefinition(Name propertyName, int type, boolean multiValued) throws ConstraintViolationException, RepositoryException {
		 return session.getItemDefinitionProvider().getQPropertyDefinition(getNodeState().getAllNodeTypeNames(), propertyName, type, multiValued);
	 }
}",1,0,0,0
"static void setToBox(Byte border,Byte topBorder,Byte leftBorder,Byte bottomBorder,Byte rightBorder,Color borderColor,Color topBorderColor,Color leftBorderColor,Color bottomBorderColor,Color rightBorderColor,Integer padding,Integer topPadding,Integer leftPadding,Integer bottomPadding,Integer rightPadding,JRLineBox box);",0,0,0,1
"public void BFS(int startI, int startJ, String imageName) {
	 LinkedList<String> queue = new LinkedList<String>();
	 int letterWidth = 80;
	 int letterHeight = 80;
	 int gapX = 30;
	 int gapY = 30;
	 BufferedImage letter = new BufferedImage(letterWidth, letterHeight, BufferedImage.TYPE_BYTE_BINARY);
	 int alpha = new Color(originalImage.getRGB(startI, startJ)).getAlpha();
	 int white = ImageUtilities.colorToRGB(alpha, 255, 255, 255);
	 int black = ImageUtilities.colorToRGB(alpha, 0, 0, 0);
	 for (int i = 0;
	 i < letterWidth;
	 i++) {
		 for (int j = 0;
		 j < letterHeight;
		 j++) {
			 letter.setRGB(i, j, white);
		 }
	 }
	 int count = 0;
	 String positions = startI + "" "" + startJ;
	 visited[startI][startJ] = true;
	 queue.addLast(positions);
	 while (!queue.isEmpty()) {
		 String pos = queue.removeFirst();
		 String[] posArray = pos.split("" "");
		 int x = Integer.parseInt(posArray[0]);
		 int y = Integer.parseInt(posArray[1]);
		 visited[x][y] = true;
		 int posX = startI - x + gapX;
		 int posY = startJ - y + gapY;
		 count++;
		 try {
			 letter.setRGB(posX, posY, black);
		 }
		 catch (Exception e) {
			 e.printStackTrace();
			 System.out.println(""posX "" + posX);
			 System.out.println(""posY "" + posY);
			 System.out.println(""letterWidth "" + letter.getWidth());
			 System.out.println(""letterHeight "" + letter.getHeight());
			 throw e;
		 }
		 for (int i = x - 1;
		 i <= x + 1;
		 i++) {
			 for (int j = y - 1;
			 j <= y + 1;
			 j++) {
				 if (i >= 0 && j >= 0 && i < originalImage.getWidth() && j < originalImage.getHeight()) {
					 if (!visited[i][j]) {
						 int color = new Color(originalImage.getRGB(i, j)).getRed();
						 if (color < 10) {
							 visited[i][j] = true;
							 String tmpPos = i + "" "" + j;
							 queue.addLast(tmpPos);
						 }
					 }
				 }
			 }
		 }
	 }
	 System.out.println(""count = "" + count);
	 if (count < 3) {
		 return;
	 }
	 try {
		 saveToFile(letter, imageName);
	 }
	 catch (IOException ex) {
		 ex.printStackTrace();
	 }
 }",0,0,1,0
"protected boolean isRebuildRequired(File genericJarFile, File weblogicJarFile) {
	 boolean rebuild = false;
	 JarFile genericJar = null;
	 JarFile wlJar = null;
	 File newWLJarFile = null;
	 JarOutputStream newJarStream = null;
	 ClassLoader genericLoader = null;
	 try {
		 log(""Checking if weblogic Jar needs to be rebuilt for jar "" + weblogicJarFile.getName(), Project.MSG_VERBOSE);
		 if (genericJarFile.exists() && genericJarFile.isFile() && weblogicJarFile.exists() && weblogicJarFile.isFile()) {
			 genericJar = new JarFile(genericJarFile);
			 wlJar = new JarFile(weblogicJarFile);
			 Hashtable genericEntries = new Hashtable();
			 Hashtable wlEntries = new Hashtable();
			 Hashtable replaceEntries = new Hashtable();
			 for (Enumeration e = genericJar.entries();
			 e.hasMoreElements();
			) {
				 JarEntry je = (JarEntry) e.nextElement();
				 genericEntries.put(je.getName().replace('\\', '/'), je);
			 }
			 for (Enumeration e = wlJar.entries();
			 e.hasMoreElements();
			) {
				 JarEntry je = (JarEntry) e.nextElement();
				 wlEntries.put(je.getName(), je);
			 }
			 genericLoader = getClassLoaderFromJar(genericJarFile);
			 for (Enumeration e = genericEntries.keys();
			 e.hasMoreElements();
			) {
				 String filepath = (String) e.nextElement();
				 if (wlEntries.containsKey(filepath)) {
					 JarEntry genericEntry = (JarEntry) genericEntries.get(filepath);
					 JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);
					 if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) {
						 if (genericEntry.getName().endsWith("".class"")) {
							 String classname = genericEntry.getName().replace(File.separatorChar, '.');
							 classname = classname.substring(0, classname.lastIndexOf("".class""));
							 Class genclass = genericLoader.loadClass(classname);
							 if (genclass.isInterface()) {
								 log(""Interface "" + genclass.getName() + "" has changed"", Project.MSG_VERBOSE);
								 rebuild = true;
								 break;
							 }
							 else {
								 replaceEntries.put(filepath, genericEntry);
							 }
						 }
						 else {
							 if (!genericEntry.getName().equals(""META-INF/MANIFEST.MF"")) {
								 log(""Non class file "" + genericEntry.getName() + "" has changed"", Project.MSG_VERBOSE);
								 rebuild = true;
								 break;
							 }
						 }
					 }
				 }
				 else {
					 log(""File "" + filepath + "" not present in weblogic jar"", Project.MSG_VERBOSE);
					 rebuild = true;
					 break;
				 }
			 }
			 if (!rebuild) {
				 log(""No rebuild needed - updating jar"", Project.MSG_VERBOSE);
				 newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + "".temp"");
				 if (newWLJarFile.exists()) {
					 newWLJarFile.delete();
				 }
				 newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile));
				 newJarStream.setLevel(0);
				 for (Enumeration e = wlEntries.elements();
				 e.hasMoreElements();
				) {
					 byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
					 int bytesRead;
					 InputStream is;
					 JarEntry je = (JarEntry) e.nextElement();
					 if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) {
						 newJarStream.setLevel(0);
					 }
					 else {
						 newJarStream.setLevel(JAR_COMPRESS_LEVEL);
					 }
					 if (replaceEntries.containsKey(je.getName())) {
						 log(""Updating Bean class from generic Jar "" + je.getName(), Project.MSG_VERBOSE);
						 je = (JarEntry) replaceEntries.get(je.getName());
						 is = genericJar.getInputStream(je);
					 }
					 else {
						 is = wlJar.getInputStream(je);
					 }
					 newJarStream.putNextEntry(new JarEntry(je.getName()));
					 while ((bytesRead = is.read(buffer)) != -1) {
						 newJarStream.write(buffer, 0, bytesRead);
					 }
					 is.close();
				 }
			 }
			 else {
				 log(""Weblogic Jar rebuild needed due to changed "" + ""interface or XML"", Project.MSG_VERBOSE);
			 }
		 }
		 else {
			 rebuild = true;
		 }
	 }
	 catch (ClassNotFoundException cnfe) {
		 String cnfmsg = ""ClassNotFoundException while processing ejb-jar file"" + "". Details: "" + cnfe.getMessage();
		 throw new BuildException(cnfmsg, cnfe);
	 }
	 catch (IOException ioe) {
		 String msg = ""IOException while processing ejb-jar file "" + "". Details: "" + ioe.getMessage();
		 throw new BuildException(msg, ioe);
	 }
	 finally {
		 if (genericJar != null) {
			 try {
				 genericJar.close();
			 }
			 catch (IOException closeException) {
			 }
		 }
		 if (wlJar != null) {
			 try {
				 wlJar.close();
			 }
			 catch (IOException closeException) {
			 }
		 }
		 if (newJarStream != null) {
			 try {
				 newJarStream.close();
			 }
			 catch (IOException closeException) {
			 }
			 try {
				 FILE_UTILS.rename(newWLJarFile, weblogicJarFile);
			 }
			 catch (IOException renameException) {
				 log(renameException.getMessage(), Project.MSG_WARN);
				 rebuild = true;
			 }
		 }
		 if (genericLoader != null && genericLoader instanceof AntClassLoader) {
			 AntClassLoader loader = (AntClassLoader) genericLoader;
			 loader.cleanup();
		 }
	 }
	 return rebuild;
 }",0,0,1,0
"public Chunk getRevised(){
	return revised;
}",0,0,0,0
"public Enumeration<String> getHeaders(final String name){
	List<String> list = (List<String>)headers.get(name);
	if (list == null){
		list = new ArrayList<String>();
	}
	return Collections.enumeration(list);
}",0,0,0,0
"public class DecoratedKey<T extends Token> implements Comparable<DecoratedKey>{
	 private static IPartitioner partitioner = StorageService.getPartitioner();
	 public static final Comparator<DecoratedKey> comparator = new Comparator<DecoratedKey>() {
		 public int compare(DecoratedKey o1, DecoratedKey o2) {
			 return o1.compareTo(o2);
		 }
	 }
	;
	 public final T token;
	 public final ByteBuffer key;
	 public DecoratedKey(T token, ByteBuffer key) {
		 super();
		 assert token != null;
		 this.token = token;
		 this.key = key;
	 }
	 public int hashCode() {
		 return token.hashCode();
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (obj == null) return false;
		 if (getClass() != obj.getClass()) return false;
		 DecoratedKey other = (DecoratedKey) obj;
		 return token.equals(other.token);
	 }
	 public int compareTo(DecoratedKey other) {
		 return token.compareTo(other.token);
	 }
	 public boolean isEmpty() {
		 return token.equals(partitioner.getMinimumToken());
	 }
	 public String toString() {
		 String keystring = key == null ? ""null"" : ByteBufferUtil.bytesToHex(key);
		 return ""DecoratedKey("" + token + "", "" + keystring + "")"";
	 }
}",0,0,0,0
"static Supplier<Object> supplierFromDimensionSelector(final DimensionSelector selector) {
	 Preconditions.checkNotNull(selector, ""selector"");
	 return () -> {
		 final IndexedInts row = selector.getRow();
		 if (row.size() == 1) {
			 return selector.lookupName(row.get(0));
		 }
		 else {
			 return null;
		 }
	 }
	;
 }",0,0,1,0
"public class TubeEditorWindow extends CurveEditorWindow{
	 private BCheckBoxMenuItem endsItem[];
	 private boolean topology;
	 public TubeEditorWindow(EditingWindow parent, String title, ObjectInfo obj, Runnable onClose, boolean allowTopology) {
		 super(parent, title, obj);
		 this.onClose = onClose;
		 topology = allowTopology;
		 FormContainer content = new FormContainer(new double [] {
		0, 1}
		, new double [] {
		1, 0, 0}
		);
		 setContent(content);
		 content.setDefaultLayout(new LayoutInfo(LayoutInfo.CENTER, LayoutInfo.BOTH, null, null));
		 content.add(helpText = new BLabel(), 0, 1, 2, 1);
		 content.add(viewsContainer, 1, 0);
		 RowContainer buttons = new RowContainer();
		 buttons.add(Translate.button(""ok"", this, ""doOk""));
		 buttons.add(Translate.button(""cancel"", this, ""doCancel""));
		 content.add(buttons, 0, 2, 2, 1, new LayoutInfo());
		 content.add(tools = new ToolPalette(1, 7), 0, 0, new LayoutInfo(LayoutInfo.NORTH, LayoutInfo.NONE, null, null));
		 EditingTool metaTool, altTool, compoundTool;
		 tools.addTool(defaultTool = new ReshapeMeshTool(this, this));
		 tools.addTool(new ScaleMeshTool(this, this));
		 tools.addTool(new RotateMeshTool(this, this, false));
		 tools.addTool(new SkewMeshTool(this, this));
		 tools.addTool(new TaperMeshTool(this, this));
		 tools.addTool(compoundTool = new MoveScaleRotateMeshTool(this, this));
		 if (ArtOfIllusion.getPreferences().getUseCompoundMeshTool()) defaultTool = compoundTool;
		 tools.addTool(metaTool = new MoveViewTool(this));
		 tools.addTool(altTool = new RotateViewTool(this));
		 tools.setDefaultTool(defaultTool);
		 tools.selectTool(defaultTool);
		 for (int i = 0;
		 i < theView.length;
		 i++) {
			 MeshViewer view = (MeshViewer) theView[i];
			 view.setMetaTool(metaTool);
			 view.setAltTool(altTool);
			 view.setScene(parent.getScene(), obj);
		 }
		 createEditMenu();
		 createMeshMenu((Tube) obj.getObject());
		 createViewMenu();
		 recursivelyAddListeners(this);
		 UIUtilities.applyDefaultFont(content);
		 UIUtilities.applyDefaultBackground(content);
		 Rectangle screenBounds = GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds();
		 Dimension windowDim = new Dimension((screenBounds.width*3)/4, (screenBounds.height*3)/4);
		 setBounds(new Rectangle((screenBounds.width-windowDim.width)/2, (screenBounds.height-windowDim.height)/2, windowDim.width, windowDim.height));
		 tools.requestFocus();
		 selected = new boolean [((Tube) obj.getObject()).getVertices().length];
		 findSelectionDistance();
		 updateMenus();
	 }
	 void createMeshMenu(Tube obj) {
		 meshMenu = Translate.menu(""tube"");
		 menubar.add(meshMenu);
		 meshMenuItem = new BMenuItem [8];
		 meshMenuItem[0] = Translate.menuItem(""deletePoints"", this, ""deleteCommand"");
		 if (topology) meshMenu.add(meshMenuItem[0]);
		 meshMenuItem[1] = Translate.menuItem(""subdivide"", this, ""subdivideCommand"");
		 if (topology) meshMenu.add(meshMenuItem[1]);
		 meshMenu.add(meshMenuItem[2] = Translate.menuItem(""editPoints"", this, ""setPointsCommand""));
		 meshMenu.add(meshMenuItem[3] = Translate.menuItem(""transformPoints"", this, ""transformPointsCommand""));
		 meshMenu.add(meshMenuItem[4] = Translate.menuItem(""randomize"", this, ""randomizeCommand""));
		 meshMenu.add(meshMenuItem[5] = Translate.menuItem(""parameters"", this, ""setParametersCommand""));
		 meshMenu.add(meshMenuItem[6] = Translate.menuItem(""thickness"", this, ""setThicknessCommand""));
		 meshMenu.add(Translate.menuItem(""centerTube"", this, ""centerCommand""));
		 meshMenu.addSeparator();
		 meshMenu.add(meshMenuItem[7] = Translate.menuItem(""smoothness"", this, ""setSmoothnessCommand""));
		 meshMenu.add(smoothMenu = Translate.menu(""smoothingMethod""));
		 smoothItem = new BCheckBoxMenuItem [3];
		 smoothMenu.add(smoothItem[0] = Translate.checkboxMenuItem(""none"", this, ""smoothingChanged"", obj.getSmoothingMethod() == Curve.NO_SMOOTHING));
		 smoothMenu.add(smoothItem[1] = Translate.checkboxMenuItem(""interpolating"", this, ""smoothingChanged"", obj.getSmoothingMethod() == Curve.INTERPOLATING));
		 smoothMenu.add(smoothItem[2] = Translate.checkboxMenuItem(""approximating"", this, ""smoothingChanged"", obj.getSmoothingMethod() == Curve.APPROXIMATING));
		 endsItem = new BCheckBoxMenuItem [3];
		 BMenu endsMenu = Translate.menu(""endsStyle"");
		 meshMenu.add(endsMenu);
		 endsMenu.add(endsItem[0] = Translate.checkboxMenuItem(""openEnds"", this, ""endsStyleChanged"", obj.getEndsStyle() == Tube.OPEN_ENDS));
		 endsMenu.add(endsItem[1] = Translate.checkboxMenuItem(""closedEnds"", this, ""endsStyleChanged"", obj.getEndsStyle() == Tube.CLOSED_ENDS));
		 endsMenu.add(endsItem[2] = Translate.checkboxMenuItem(""flatEnds"", this, ""endsStyleChanged"", obj.getEndsStyle() == Tube.FLAT_ENDS));
	 }
	 protected BMenu createShowMenu() {
		 BMenu menu = Translate.menu(""show"");
		 MeshViewer view = (MeshViewer) theView[currentView];
		 showItem = new BCheckBoxMenuItem [4];
		 menu.add(showItem[0] = Translate.checkboxMenuItem(""curve"", this, ""shownItemChanged"", view.getMeshVisible()));
		 menu.add(showItem[1] = Translate.checkboxMenuItem(""surface"", this, ""shownItemChanged"", view.getSurfaceVisible()));
		 menu.add(showItem[3] = Translate.checkboxMenuItem(""entireScene"", this, ""shownItemChanged"", view.getSceneVisible()));
		 return menu;
	 }
	 public void updateMenus() {
		 super.updateMenus();
		 int i;
		 for (i = 0;
		 i < selected.length && !selected[i];
		 i++);
		 if (i < selected.length) {
			 editMenuItem[0].setEnabled(true);
			 for (i = 0;
			 i < meshMenuItem.length;
			 i++) meshMenuItem[i].setEnabled(true);
		 }
		 else {
			 editMenuItem[0].setEnabled(false);
			 for (i = 0;
			 i < meshMenuItem.length;
			 i++) meshMenuItem[i].setEnabled(false);
		 }
	 }
	 private void endsStyleChanged(WidgetEvent ev) {
		 Widget source = ev.getWidget();
		 for (int i = 0;
		 i < endsItem.length;
		 i++) if (source == endsItem[i]) {
			 for (int j = 0;
			 j < endsItem.length;
			 j++) endsItem[j].setState(false);
			 endsItem[i].setState(true);
			 ((Tube) objInfo.getObject()).setEndsStyle(i);
			 objectChanged();
			 updateImage();
		 }
	 }
	 protected void doOk() {
		 Tube theMesh = (Tube) objInfo.getObject();
		 if (((Tube) oldMesh).getMaterial() != null) {
			 if (!theMesh.isClosed()) {
				 String options[] = new String [] {
				Translate.text(""button.ok""), Translate.text(""button.cancel"")}
				;
				 BStandardDialog dlg = new BStandardDialog("""", UIUtilities.breakString(Translate.text(""surfaceNoLongerClosed"")), BStandardDialog.WARNING);
				 int choice = dlg.showOptionDialog(this, options, options[0]);
				 if (choice == 1) return;
				 theMesh.setMaterial(null, null);
			 }
			 else theMesh.setMaterial(((Tube) oldMesh).getMaterial(), ((Tube) oldMesh).getMaterialMapping());
		 }
		 oldMesh.copyObject(theMesh);
		 oldMesh = null;
		 dispose();
		 onClose.run();
	 }
	 protected void doCancel() {
		 oldMesh = null;
		 dispose();
	 }
	 public void deleteCommand() {
		 if (!topology) return;
		 int i, j, num = 0;
		 Tube theTube = (Tube) objInfo.getObject();
		 boolean newsel[];
		 MeshVertex vt[] = theTube.getVertices(), newv[];
		 double t[] = theTube.getThickness(), newt[];
		 float s[] = theTube.getSmoothness(), news[];
		 for (i = 0;
		 i < selected.length;
		 i++) if (selected[i])num++;
		 if (num == 0) return;
		 if (theTube.getEndsStyle() != Tube.CLOSED_ENDS && selected.length-num < 2) {
			 new BStandardDialog("""", Translate.text(""tubeNeeds2Points""), BStandardDialog.INFORMATION).showMessageDialog(this);
			 return;
		 }
		 if (theTube.getEndsStyle() == Tube.CLOSED_ENDS && selected.length-num < 3) {
			 new BStandardDialog("""", Translate.text(""tubeNeeds3Points""), BStandardDialog.INFORMATION).showMessageDialog(this);
			 return;
		 }
		 setUndoRecord(new UndoRecord(this, false, UndoRecord.COPY_OBJECT, new Object [] {
		theTube, theTube.duplicate()}
		));
		 newv = new MeshVertex [vt.length-num];
		 newt = new double [vt.length-num];
		 news = new float [vt.length-num];
		 newsel = new boolean [vt.length-num];
		 for (i = 0, j = 0;
		 i < vt.length;
		 i++) {
			 if (!selected[i]) {
				 newsel[j] = selected[i];
				 newt[j] = t[i];
				 news[j] = s[i];
				 newv[j++] = vt[i];
			 }
		 }
		 theTube.setShape(newv, news, newt);
		 setSelection(newsel);
		 objectChanged();
		 updateImage();
	 }
	 public void subdivideCommand() {
		 Tube theTube = (Tube) objInfo.getObject();
		 MeshVertex vt[] = theTube.getVertices(), newpos[];
		 float s[] = theTube.getSmoothness(), news[];
		 double t[] = theTube.getThickness(), newt[];
		 int numParam = (theTube.getParameters() == null ? 0 : theTube.getParameters().length);
		 double param[][], newparam[][], paramTemp[] = new double [numParam];
		 boolean newsel[], split[];
		 int i, j, p1, p3, p4, splitcount = 0, method = theTube.getSmoothingMethod();
		 param = new double [vt.length][numParam];
		 ParameterValue paramValue[] = theTube.getParameterValues();
		 for (i = 0;
		 i < numParam;
		 i++) {
			 if (paramValue[i] instanceof VertexParameterValue) {
				 double val[] = ((VertexParameterValue) paramValue[i]).getValue();
				 for (j = 0;
				 j < val.length;
				 j++) param[j][i] = val[j];
			 }
		 }
		 if (theTube.getEndsStyle() == Tube.CLOSED_ENDS) split = new boolean [vt.length];
		 else split = new boolean [vt.length-1];
		 for (i = 0;
		 i < split.length;
		 i++) if (selected[i] && selected[(i+1)%selected.length]) {
			 split[i] = true;
			 splitcount++;
		 }
		 newpos = new MeshVertex [vt.length+splitcount];
		 news = new float [vt.length+splitcount];
		 newt = new double [vt.length+splitcount];
		 newparam = new double [vt.length+splitcount][numParam];
		 newsel = new boolean [vt.length+splitcount];
		 for (i = 0, j = 0;
		 i < split.length;
		 i++) {
			 newsel[j] = selected[i];
			 p1 = i-1;
			 if (p1 < 0) {
				 if (theTube.getEndsStyle() == Tube.CLOSED_ENDS) p1 = vt.length-1;
				 else p1 = 0;
			 }
			 if (i < vt.length-1) p3 = i+1;
			 else {
				 if (theTube.getEndsStyle() == Tube.CLOSED_ENDS) p3 = 0;
				 else p3 = vt.length-1;
			 }
			 if (selected[i] && method == Mesh.APPROXIMATING) {
				 newpos[j] = SplineMesh.calcApproxPoint(vt, s, param, paramTemp, p1, i, p3);
				 newt[j] = Tube.calcApproxThickness(t, s, p1, i, p3);
				 for (int k = 0;
				 k < numParam;
				 k++) newparam[j][k] = paramTemp[k];
			 }
			 else {
				 newpos[j] = vt[i];
				 newt[j] = t[i];
				 newparam[j] = param[i];
			 }
			 if (selected[i]) news[j] = Math.min(s[i]*2.0f, 1.0f);
			 else news[j] = s[i];
			 if (!split[i]) {
				 j++;
				 continue;
			 }
			 if (method == Mesh.NO_SMOOTHING) {
				 newpos[j+1] = MeshVertex.blend(vt[i], vt[p3], 0.5, 0.5);
				 for (int k = 0;
				 k < numParam;
				 k++) newparam[j+1][k] = 0.5*(param[i][k]+param[p3][k]);
			 }
			 else if (method == Mesh.INTERPOLATING) {
				 if (i < vt.length-2) p4 = i+2;
				 else {
					 if (theTube.getEndsStyle() == Tube.CLOSED_ENDS) p4 = (i+2)%vt.length;
					 else p4 = vt.length-1;
				 }
				 newpos[j+1] = SplineMesh.calcInterpPoint(vt, s, param, paramTemp, p1, i, p3, p4);
				 newt[j+1] = Tube.calcInterpThickness(t, s, p1, i, p3, p4);
				 for (int k = 0;
				 k < numParam;
				 k++) newparam[j+1][k] = paramTemp[k];
			 }
			 else {
				 newpos[j+1] = MeshVertex.blend(vt[i], vt[p3], 0.5, 0.5);
				 newt[j+1] = 0.5*(t[i]+t[p3]);
				 for (int k = 0;
				 k < numParam;
				 k++) newparam[j+1][k] = 0.5*(param[i][k]+param[p3][k]);
			 }
			 news[j+1] = 1.0f;
			 newsel[j+1] = true;
			 j += 2;
		 }
		 if (theTube.getEndsStyle() != Tube.CLOSED_ENDS) {
			 newpos[0] = vt[0];
			 newpos[j] = vt[i];
			 newt[0] = t[0];
			 newt[j] = t[i];
			 news[j] = s[i];
			 newparam[0] = param[0];
			 newparam[j] = param[i];
			 newsel[j] = selected[i];
		 }
		 setUndoRecord(new UndoRecord(this, false, UndoRecord.COPY_OBJECT, new Object [] {
		theTube, theTube.duplicate()}
		));
		 theTube.setShape(newpos, news, newt);
		 for (i = 0;
		 i < numParam;
		 i++) {
			 if (paramValue[i] instanceof VertexParameterValue) {
				 double val[] = new double [newpos.length];
				 for (j = 0;
				 j < val.length;
				 j++) val[j] = newparam[j][i];
				 paramValue[i] = new VertexParameterValue(val);
			 }
		 }
		 theTube.setParameterValues(paramValue);
		 setSelection(newsel);
		 objectChanged();
		 updateImage();
	 }
	 public void setThicknessCommand() {
		 Tube theTube = (Tube) objInfo.getObject();
		 double thickness[] = theTube.getThickness(), initial = -1;
		 int selectDist[] = getSelectionDistance();
		 for (int i = 0;
		 i < selectDist.length;
		 i++) if (selectDist[i] == 0) {
			 if (initial == -1) initial = thickness[i];
			 else if (initial != thickness[i]) initial = Double.NaN;
		 }
		 if (initial == -1) return;
		 ValueField thicknessField = new ValueField(initial, ValueField.NONNEGATIVE, 5);
		 ComponentsDialog dlg = new ComponentsDialog(this, Translate.text(""setThicknessTitle""), new Widget [] {
		thicknessField}
		, new String [] {
		Translate.text(""Thickness"")}
		);
		 if (!dlg.clickedOk() || Double.isNaN(thicknessField.getValue())) return;
		 setUndoRecord(new UndoRecord(this, false, UndoRecord.COPY_OBJECT, new Object [] {
		theTube, theTube.duplicate()}
		));
		 for (int i = 0;
		 i < selectDist.length;
		 i++) if (selectDist[i] == 0) thickness[i] = thicknessField.getValue();
		 theTube.setThickness(thickness);
		 objectChanged();
		 updateImage();
	 }
}",1,0,0,0
"public static class MissingRequirement extends ConfigurationException {
	 private static final long serialVersionUID = -5579697104441150933L;
	 public MissingRequirement( String required, String var, String source, int line ) {
		 super( null, source, line );
		 this.required = required;
	 }
	 public String required;
 }",0,0,0,0
"public class WebdavServlet extends DefaultServlet {
	 private static final long serialVersionUID = 1L;
	 private static final String METHOD_PROPFIND = ""PROPFIND"";
	 private static final String METHOD_PROPPATCH = ""PROPPATCH"";
	 private static final String METHOD_MKCOL = ""MKCOL"";
	 private static final String METHOD_COPY = ""COPY"";
	 private static final String METHOD_MOVE = ""MOVE"";
	 private static final String METHOD_LOCK = ""LOCK"";
	 private static final String METHOD_UNLOCK = ""UNLOCK"";
	 private static final int FIND_BY_PROPERTY = 0;
	 private static final int FIND_ALL_PROP = 1;
	 private static final int FIND_PROPERTY_NAMES = 2;
	 private static final int LOCK_CREATION = 0;
	 private static final int LOCK_REFRESH = 1;
	 private static final int DEFAULT_TIMEOUT = 3600;
	 private static final int MAX_TIMEOUT = 604800;
	 protected static final String DEFAULT_NAMESPACE = ""DAV:"";
	 protected static final SimpleDateFormat creationDateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
	 protected static MessageDigest md5Helper;
	 protected static final MD5Encoder md5Encoder = new MD5Encoder();
	 static {
		 creationDateFormat.setTimeZone(TimeZone.getTimeZone(""GMT""));
	 }
	 private Hashtable<String,LockInfo> resourceLocks = new Hashtable<String,LockInfo>();
	 private Hashtable<String,Vector<String>> lockNullResources = new Hashtable<String,Vector<String>>();
	 private Vector<LockInfo> collectionLocks = new Vector<LockInfo>();
	 private String secret = ""catalina"";
	 private int maxDepth = 3;
	 public void init() throws ServletException {
		 super.init();
		 if (getServletConfig().getInitParameter(""secret"") != null) secret = getServletConfig().getInitParameter(""secret"");
		 if (getServletConfig().getInitParameter(""maxDepth"") != null) maxDepth = Integer.parseInt( getServletConfig().getInitParameter(""maxDepth""));
		 try {
			 md5Helper = MessageDigest.getInstance(""MD5"");
		 }
		 catch (NoSuchAlgorithmException e) {
			 throw new UnavailableException(""No MD5"");
		 }
	 }
	 protected DocumentBuilder getDocumentBuilder() throws ServletException {
		 DocumentBuilder documentBuilder = null;
		 DocumentBuilderFactory documentBuilderFactory = null;
		 try {
			 documentBuilderFactory = DocumentBuilderFactory.newInstance();
			 documentBuilderFactory.setNamespaceAware(true);
			 documentBuilderFactory.setExpandEntityReferences(false);
			 documentBuilder = documentBuilderFactory.newDocumentBuilder();
			 documentBuilder.setEntityResolver( new WebdavResolver(this.getServletContext()));
		 }
		 catch(ParserConfigurationException e) {
			 throw new ServletException (sm.getString(""webdavservlet.jaxpfailed""));
		 }
		 return documentBuilder;
	 }
	 protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 String method = req.getMethod();
		 if (debug > 0) {
			 String path = getRelativePath(req);
			 log(""["" + method + ""] "" + path);
		 }
		 if (method.equals(METHOD_PROPFIND)) {
			 doPropfind(req, resp);
		 }
		 else if (method.equals(METHOD_PROPPATCH)) {
			 doProppatch(req, resp);
		 }
		 else if (method.equals(METHOD_MKCOL)) {
			 doMkcol(req, resp);
		 }
		 else if (method.equals(METHOD_COPY)) {
			 doCopy(req, resp);
		 }
		 else if (method.equals(METHOD_MOVE)) {
			 doMove(req, resp);
		 }
		 else if (method.equals(METHOD_LOCK)) {
			 doLock(req, resp);
		 }
		 else if (method.equals(METHOD_UNLOCK)) {
			 doUnlock(req, resp);
		 }
		 else {
			 super.service(req, resp);
		 }
	 }
	 protected boolean checkIfHeaders(HttpServletRequest request, HttpServletResponse response, ResourceAttributes resourceAttributes) throws IOException {
		 if (!super.checkIfHeaders(request, response, resourceAttributes)) return false;
		 return true;
	 }
	 protected String getRelativePath(HttpServletRequest request) {
		 if (request.getAttribute(Globals.INCLUDE_REQUEST_URI_ATTR) != null) {
			 String result = (String) request.getAttribute( Globals.INCLUDE_PATH_INFO_ATTR);
			 if ((result == null) || (result.equals(""""))) result = ""/"";
			 return (result);
		 }
		 String result = request.getPathInfo();
		 if ((result == null) || (result.equals(""""))) {
			 result = ""/"";
		 }
		 return (result);
	 }
	 protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 resp.addHeader(""DAV"", ""1,2"");
		 StringBuilder methodsAllowed = determineMethodsAllowed(resources, req);
		 resp.addHeader(""Allow"", methodsAllowed.toString());
		 resp.addHeader(""MS-Author-Via"", ""DAV"");
	 }
	 protected void doPropfind(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 if (!listings) {
			 StringBuilder methodsAllowed = determineMethodsAllowed(resources, req);
			 resp.addHeader(""Allow"", methodsAllowed.toString());
			 resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
			 return;
		 }
		 String path = getRelativePath(req);
		 if (path.endsWith(""/"")) path = path.substring(0, path.length() - 1);
		 if ((path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"")) || (path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF""))) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 Vector<String> properties = null;
		 int depth = maxDepth;
		 int type = FIND_ALL_PROP;
		 String depthStr = req.getHeader(""Depth"");
		 if (depthStr == null) {
			 depth = maxDepth;
		 }
		 else {
			 if (depthStr.equals(""0"")) {
				 depth = 0;
			 }
			 else if (depthStr.equals(""1"")) {
				 depth = 1;
			 }
			 else if (depthStr.equals(""infinity"")) {
				 depth = maxDepth;
			 }
		 }
		 Node propNode = null;
		 if (req.getContentLength() > 0) {
			 DocumentBuilder documentBuilder = getDocumentBuilder();
			 try {
				 Document document = documentBuilder.parse (new InputSource(req.getInputStream()));
				 Element rootElement = document.getDocumentElement();
				 NodeList childList = rootElement.getChildNodes();
				 for (int i=0;
				 i < childList.getLength();
				 i++) {
					 Node currentNode = childList.item(i);
					 switch (currentNode.getNodeType()) {
						 case Node.TEXT_NODE: break;
						 case Node.ELEMENT_NODE: if (currentNode.getNodeName().endsWith(""prop"")) {
							 type = FIND_BY_PROPERTY;
							 propNode = currentNode;
						 }
						 if (currentNode.getNodeName().endsWith(""propname"")) {
							 type = FIND_PROPERTY_NAMES;
						 }
						 if (currentNode.getNodeName().endsWith(""allprop"")) {
							 type = FIND_ALL_PROP;
						 }
						 break;
					 }
				 }
			 }
			 catch (SAXException e) {
				 resp.sendError(WebdavStatus.SC_BAD_REQUEST);
			 }
			 catch (IOException e) {
				 resp.sendError(WebdavStatus.SC_BAD_REQUEST);
			 }
		 }
		 if (type == FIND_BY_PROPERTY) {
			 properties = new Vector<String>();
			 NodeList childList = propNode.getChildNodes();
			 for (int i=0;
			 i < childList.getLength();
			 i++) {
				 Node currentNode = childList.item(i);
				 switch (currentNode.getNodeType()) {
					 case Node.TEXT_NODE: break;
					 case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName();
					 String propertyName = null;
					 if (nodeName.indexOf(':') != -1) {
						 propertyName = nodeName.substring (nodeName.indexOf(':') + 1);
					 }
					 else {
						 propertyName = nodeName;
					 }
					 properties.addElement(propertyName);
					 break;
				 }
			 }
		 }
		 boolean exists = true;
		 Object object = null;
		 try {
			 object = resources.lookup(path);
		 }
		 catch (NamingException e) {
			 exists = false;
			 int slash = path.lastIndexOf('/');
			 if (slash != -1) {
				 String parentPath = path.substring(0, slash);
				 Vector<String> currentLockNullResources = lockNullResources.get(parentPath);
				 if (currentLockNullResources != null) {
					 Enumeration<String> lockNullResourcesList = currentLockNullResources.elements();
					 while (lockNullResourcesList.hasMoreElements()) {
						 String lockNullPath = lockNullResourcesList.nextElement();
						 if (lockNullPath.equals(path)) {
							 resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
							 resp.setContentType(""text/xml;
							 charset=UTF-8"");
							 XMLWriter generatedXML = new XMLWriter(resp.getWriter());
							 generatedXML.writeXMLHeader();
							 generatedXML.writeElement (null, ""multistatus"" + generateNamespaceDeclarations(), XMLWriter.OPENING);
							 parseLockNullProperties (req, generatedXML, lockNullPath, type, properties);
							 generatedXML.writeElement(null, ""multistatus"", XMLWriter.CLOSING);
							 generatedXML.sendData();
							 return;
						 }
					 }
				 }
			 }
		 }
		 if (!exists) {
			 resp.sendError(HttpServletResponse.SC_NOT_FOUND, path);
			 return;
		 }
		 resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
		 resp.setContentType(""text/xml;
		 charset=UTF-8"");
		 XMLWriter generatedXML = new XMLWriter(resp.getWriter());
		 generatedXML.writeXMLHeader();
		 generatedXML.writeElement(null, ""multistatus"" + generateNamespaceDeclarations(), XMLWriter.OPENING);
		 if (depth == 0) {
			 parseProperties(req, generatedXML, path, type, properties);
		 }
		 else {
			 Stack<String> stack = new Stack<String>();
			 stack.push(path);
			 Stack<String> stackBelow = new Stack<String>();
			 while ((!stack.isEmpty()) && (depth >= 0)) {
				 String currentPath = stack.pop();
				 parseProperties(req, generatedXML, currentPath, type, properties);
				 try {
					 object = resources.lookup(currentPath);
				 }
				 catch (NamingException e) {
					 continue;
				 }
				 if ((object instanceof DirContext) && (depth > 0)) {
					 try {
						 NamingEnumeration<NameClassPair> enumeration = resources.list(currentPath);
						 while (enumeration.hasMoreElements()) {
							 NameClassPair ncPair = enumeration.nextElement();
							 String newPath = currentPath;
							 if (!(newPath.endsWith(""/""))) newPath += ""/"";
							 newPath += ncPair.getName();
							 stackBelow.push(newPath);
						 }
					 }
					 catch (NamingException e) {
						 resp.sendError (HttpServletResponse.SC_INTERNAL_SERVER_ERROR, path);
						 return;
					 }
					 String lockPath = currentPath;
					 if (lockPath.endsWith(""/"")) lockPath = lockPath.substring(0, lockPath.length() - 1);
					 Vector<String> currentLockNullResources = lockNullResources.get(lockPath);
					 if (currentLockNullResources != null) {
						 Enumeration<String> lockNullResourcesList = currentLockNullResources.elements();
						 while (lockNullResourcesList.hasMoreElements()) {
							 String lockNullPath = lockNullResourcesList.nextElement();
							 parseLockNullProperties (req, generatedXML, lockNullPath, type, properties);
						 }
					 }
				 }
				 if (stack.isEmpty()) {
					 depth--;
					 stack = stackBelow;
					 stackBelow = new Stack<String>();
				 }
				 generatedXML.sendData();
			 }
		 }
		 generatedXML.writeElement(null, ""multistatus"", XMLWriter.CLOSING);
		 generatedXML.sendData();
	 }
	 protected void doProppatch(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED);
	 }
	 protected void doMkcol(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 String path = getRelativePath(req);
		 if ((path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"")) || (path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF""))) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 boolean exists = true;
		 try {
			 resources.lookup(path);
		 }
		 catch (NamingException e) {
			 exists = false;
		 }
		 if (exists) {
			 StringBuilder methodsAllowed = determineMethodsAllowed(resources, req);
			 resp.addHeader(""Allow"", methodsAllowed.toString());
			 resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
			 return;
		 }
		 if (req.getContentLength() > 0) {
			 DocumentBuilder documentBuilder = getDocumentBuilder();
			 try {
				 documentBuilder.parse(new InputSource(req.getInputStream()));
				 resp.sendError(WebdavStatus.SC_NOT_IMPLEMENTED);
				 return;
			 }
			 catch(SAXException saxe) {
				 resp.sendError(WebdavStatus.SC_UNSUPPORTED_MEDIA_TYPE);
				 return;
			 }
		 }
		 boolean result = true;
		 try {
			 resources.createSubcontext(path);
		 }
		 catch (NamingException e) {
			 result = false;
		 }
		 if (!result) {
			 resp.sendError(WebdavStatus.SC_CONFLICT, WebdavStatus.getStatusText (WebdavStatus.SC_CONFLICT));
		 }
		 else {
			 resp.setStatus(WebdavStatus.SC_CREATED);
			 lockNullResources.remove(path);
		 }
	 }
	 protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 deleteResource(req, resp);
	 }
	 protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 super.doPut(req, resp);
		 String path = getRelativePath(req);
		 lockNullResources.remove(path);
	 }
	 protected void doCopy(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 copyResource(req, resp);
	 }
	 protected void doMove(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 String path = getRelativePath(req);
		 if (copyResource(req, resp)) {
			 deleteResource(path, req, resp, false);
		 }
	 }
	 protected void doLock(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 LockInfo lock = new LockInfo();
		 String depthStr = req.getHeader(""Depth"");
		 if (depthStr == null) {
			 lock.depth = maxDepth;
		 }
		 else {
			 if (depthStr.equals(""0"")) {
				 lock.depth = 0;
			 }
			 else {
				 lock.depth = maxDepth;
			 }
		 }
		 int lockDuration = DEFAULT_TIMEOUT;
		 String lockDurationStr = req.getHeader(""Timeout"");
		 if (lockDurationStr == null) {
			 lockDuration = DEFAULT_TIMEOUT;
		 }
		 else {
			 int commaPos = lockDurationStr.indexOf("","");
			 if (commaPos != -1) {
				 lockDurationStr = lockDurationStr.substring(0,commaPos);
			 }
			 if (lockDurationStr.startsWith(""Second-"")) {
				 lockDuration = (new Integer(lockDurationStr.substring(7))).intValue();
			 }
			 else {
				 if (lockDurationStr.equalsIgnoreCase(""infinity"")) {
					 lockDuration = MAX_TIMEOUT;
				 }
				 else {
					 try {
						 lockDuration = (new Integer(lockDurationStr)).intValue();
					 }
					 catch (NumberFormatException e) {
						 lockDuration = MAX_TIMEOUT;
					 }
				 }
			 }
			 if (lockDuration == 0) {
				 lockDuration = DEFAULT_TIMEOUT;
			 }
			 if (lockDuration > MAX_TIMEOUT) {
				 lockDuration = MAX_TIMEOUT;
			 }
		 }
		 lock.expiresAt = System.currentTimeMillis() + (lockDuration * 1000);
		 int lockRequestType = LOCK_CREATION;
		 Node lockInfoNode = null;
		 DocumentBuilder documentBuilder = getDocumentBuilder();
		 try {
			 Document document = documentBuilder.parse(new InputSource (req.getInputStream()));
			 Element rootElement = document.getDocumentElement();
			 lockInfoNode = rootElement;
		 }
		 catch (IOException e) {
			 lockRequestType = LOCK_REFRESH;
		 }
		 catch (SAXException e) {
			 lockRequestType = LOCK_REFRESH;
		 }
		 if (lockInfoNode != null) {
			 NodeList childList = lockInfoNode.getChildNodes();
			 StringWriter strWriter = null;
			 DOMWriter domWriter = null;
			 Node lockScopeNode = null;
			 Node lockTypeNode = null;
			 Node lockOwnerNode = null;
			 for (int i=0;
			 i < childList.getLength();
			 i++) {
				 Node currentNode = childList.item(i);
				 switch (currentNode.getNodeType()) {
					 case Node.TEXT_NODE: break;
					 case Node.ELEMENT_NODE: String nodeName = currentNode.getNodeName();
					 if (nodeName.endsWith(""lockscope"")) {
						 lockScopeNode = currentNode;
					 }
					 if (nodeName.endsWith(""locktype"")) {
						 lockTypeNode = currentNode;
					 }
					 if (nodeName.endsWith(""owner"")) {
						 lockOwnerNode = currentNode;
					 }
					 break;
				 }
			 }
			 if (lockScopeNode != null) {
				 childList = lockScopeNode.getChildNodes();
				 for (int i=0;
				 i < childList.getLength();
				 i++) {
					 Node currentNode = childList.item(i);
					 switch (currentNode.getNodeType()) {
						 case Node.TEXT_NODE: break;
						 case Node.ELEMENT_NODE: String tempScope = currentNode.getNodeName();
						 if (tempScope.indexOf(':') != -1) {
							 lock.scope = tempScope.substring (tempScope.indexOf(':') + 1);
						 }
						 else {
							 lock.scope = tempScope;
						 }
						 break;
					 }
				 }
				 if (lock.scope == null) {
					 resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
				 }
			 }
			 else {
				 resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
			 }
			 if (lockTypeNode != null) {
				 childList = lockTypeNode.getChildNodes();
				 for (int i=0;
				 i < childList.getLength();
				 i++) {
					 Node currentNode = childList.item(i);
					 switch (currentNode.getNodeType()) {
						 case Node.TEXT_NODE: break;
						 case Node.ELEMENT_NODE: String tempType = currentNode.getNodeName();
						 if (tempType.indexOf(':') != -1) {
							 lock.type = tempType.substring(tempType.indexOf(':') + 1);
						 }
						 else {
							 lock.type = tempType;
						 }
						 break;
					 }
				 }
				 if (lock.type == null) {
					 resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
				 }
			 }
			 else {
				 resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
			 }
			 if (lockOwnerNode != null) {
				 childList = lockOwnerNode.getChildNodes();
				 for (int i=0;
				 i < childList.getLength();
				 i++) {
					 Node currentNode = childList.item(i);
					 switch (currentNode.getNodeType()) {
						 case Node.TEXT_NODE: lock.owner += currentNode.getNodeValue();
						 break;
						 case Node.ELEMENT_NODE: strWriter = new StringWriter();
						 domWriter = new DOMWriter(strWriter, true);
						 domWriter.setQualifiedNames(false);
						 domWriter.print(currentNode);
						 lock.owner += strWriter.toString();
						 break;
					 }
				 }
				 if (lock.owner == null) {
					 resp.setStatus(WebdavStatus.SC_BAD_REQUEST);
				 }
			 }
			 else {
				 lock.owner = new String();
			 }
		 }
		 String path = getRelativePath(req);
		 lock.path = path;
		 boolean exists = true;
		 Object object = null;
		 try {
			 object = resources.lookup(path);
		 }
		 catch (NamingException e) {
			 exists = false;
		 }
		 Enumeration<LockInfo> locksList = null;
		 if (lockRequestType == LOCK_CREATION) {
			 String lockTokenStr = req.getServletPath() + ""-"" + lock.type + ""-"" + lock.scope + ""-"" + req.getUserPrincipal() + ""-"" + lock.depth + ""-"" + lock.owner + ""-"" + lock.tokens + ""-"" + lock.expiresAt + ""-"" + System.currentTimeMillis() + ""-"" + secret;
			 String lockToken = md5Encoder.encode(md5Helper.digest(lockTokenStr.getBytes()));
			 if ( (exists) && (object instanceof DirContext) && (lock.depth == maxDepth) ) {
				 Vector<String> lockPaths = new Vector<String>();
				 locksList = collectionLocks.elements();
				 while (locksList.hasMoreElements()) {
					 LockInfo currentLock = locksList.nextElement();
					 if (currentLock.hasExpired()) {
						 resourceLocks.remove(currentLock.path);
						 continue;
					 }
					 if ( (currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive())) ) {
						 lockPaths.addElement(currentLock.path);
					 }
				 }
				 locksList = resourceLocks.elements();
				 while (locksList.hasMoreElements()) {
					 LockInfo currentLock = locksList.nextElement();
					 if (currentLock.hasExpired()) {
						 resourceLocks.remove(currentLock.path);
						 continue;
					 }
					 if ( (currentLock.path.startsWith(lock.path)) && ((currentLock.isExclusive()) || (lock.isExclusive())) ) {
						 lockPaths.addElement(currentLock.path);
					 }
				 }
				 if (!lockPaths.isEmpty()) {
					 Enumeration<String> lockPathsList = lockPaths.elements();
					 resp.setStatus(WebdavStatus.SC_CONFLICT);
					 XMLWriter generatedXML = new XMLWriter();
					 generatedXML.writeXMLHeader();
					 generatedXML.writeElement (null, ""multistatus"" + generateNamespaceDeclarations(), XMLWriter.OPENING);
					 while (lockPathsList.hasMoreElements()) {
						 generatedXML.writeElement(null, ""response"", XMLWriter.OPENING);
						 generatedXML.writeElement(null, ""href"", XMLWriter.OPENING);
						 generatedXML .writeText(lockPathsList.nextElement());
						 generatedXML.writeElement(null, ""href"", XMLWriter.CLOSING);
						 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
						 generatedXML .writeText(""HTTP/1.1 "" + WebdavStatus.SC_LOCKED + "" "" + WebdavStatus .getStatusText(WebdavStatus.SC_LOCKED));
						 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
						 generatedXML.writeElement(null, ""response"", XMLWriter.CLOSING);
					 }
					 generatedXML.writeElement(null, ""multistatus"", XMLWriter.CLOSING);
					 Writer writer = resp.getWriter();
					 writer.write(generatedXML.toString());
					 writer.close();
					 return;
				 }
				 boolean addLock = true;
				 locksList = collectionLocks.elements();
				 while (locksList.hasMoreElements()) {
					 LockInfo currentLock = locksList.nextElement();
					 if (currentLock.path.equals(lock.path)) {
						 if (currentLock.isExclusive()) {
							 resp.sendError(WebdavStatus.SC_LOCKED);
							 return;
						 }
						 else {
							 if (lock.isExclusive()) {
								 resp.sendError(WebdavStatus.SC_LOCKED);
								 return;
							 }
						 }
						 currentLock.tokens.addElement(lockToken);
						 lock = currentLock;
						 addLock = false;
					 }
				 }
				 if (addLock) {
					 lock.tokens.addElement(lockToken);
					 collectionLocks.addElement(lock);
				 }
			 }
			 else {
				 LockInfo presentLock = resourceLocks.get(lock.path);
				 if (presentLock != null) {
					 if ((presentLock.isExclusive()) || (lock.isExclusive())) {
						 resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
						 return;
					 }
					 else {
						 presentLock.tokens.addElement(lockToken);
						 lock = presentLock;
					 }
				 }
				 else {
					 lock.tokens.addElement(lockToken);
					 resourceLocks.put(lock.path, lock);
					 exists = true;
					 try {
						 object = resources.lookup(path);
					 }
					 catch (NamingException e) {
						 exists = false;
					 }
					 if (!exists) {
						 int slash = lock.path.lastIndexOf('/');
						 String parentPath = lock.path.substring(0, slash);
						 Vector<String> lockNulls = lockNullResources.get(parentPath);
						 if (lockNulls == null) {
							 lockNulls = new Vector<String>();
							 lockNullResources.put(parentPath, lockNulls);
						 }
						 lockNulls.addElement(lock.path);
					 }
					 resp.addHeader(""Lock-Token"", ""<opaquelocktoken:"" + lockToken + "">"");
				 }
			 }
		 }
		 if (lockRequestType == LOCK_REFRESH) {
			 String ifHeader = req.getHeader(""If"");
			 if (ifHeader == null) ifHeader = """";
			 LockInfo toRenew = resourceLocks.get(path);
			 Enumeration<String> tokenList = null;
			 tokenList = toRenew.tokens.elements();
			 while (tokenList.hasMoreElements()) {
				 String token = tokenList.nextElement();
				 if (ifHeader.indexOf(token) != -1) {
					 toRenew.expiresAt = lock.expiresAt;
					 lock = toRenew;
				 }
			 }
			 Enumeration<LockInfo> collectionLocksList = collectionLocks.elements();
			 while (collectionLocksList.hasMoreElements()) {
				 toRenew = collectionLocksList.nextElement();
				 if (path.equals(toRenew.path)) {
					 tokenList = toRenew.tokens.elements();
					 while (tokenList.hasMoreElements()) {
						 String token = tokenList.nextElement();
						 if (ifHeader.indexOf(token) != -1) {
							 toRenew.expiresAt = lock.expiresAt;
							 lock = toRenew;
						 }
					 }
				 }
			 }
		 }
		 XMLWriter generatedXML = new XMLWriter();
		 generatedXML.writeXMLHeader();
		 generatedXML.writeElement(null, ""prop"" + generateNamespaceDeclarations(), XMLWriter.OPENING);
		 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.OPENING);
		 lock.toXML(generatedXML);
		 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.CLOSING);
		 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
		 resp.setStatus(WebdavStatus.SC_OK);
		 resp.setContentType(""text/xml;
		 charset=UTF-8"");
		 Writer writer = resp.getWriter();
		 writer.write(generatedXML.toString());
		 writer.close();
	 }
	 protected void doUnlock(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		 if (readOnly) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return;
		 }
		 if (isLocked(req)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return;
		 }
		 String path = getRelativePath(req);
		 String lockTokenHeader = req.getHeader(""Lock-Token"");
		 if (lockTokenHeader == null) lockTokenHeader = """";
		 LockInfo lock = resourceLocks.get(path);
		 Enumeration<String> tokenList = null;
		 if (lock != null) {
			 tokenList = lock.tokens.elements();
			 while (tokenList.hasMoreElements()) {
				 String token = tokenList.nextElement();
				 if (lockTokenHeader.indexOf(token) != -1) {
					 lock.tokens.removeElement(token);
				 }
			 }
			 if (lock.tokens.isEmpty()) {
				 resourceLocks.remove(path);
				 lockNullResources.remove(path);
			 }
		 }
		 Enumeration<LockInfo> collectionLocksList = collectionLocks.elements();
		 while (collectionLocksList.hasMoreElements()) {
			 lock = collectionLocksList.nextElement();
			 if (path.equals(lock.path)) {
				 tokenList = lock.tokens.elements();
				 while (tokenList.hasMoreElements()) {
					 String token = tokenList.nextElement();
					 if (lockTokenHeader.indexOf(token) != -1) {
						 lock.tokens.removeElement(token);
						 break;
					 }
				 }
				 if (lock.tokens.isEmpty()) {
					 collectionLocks.removeElement(lock);
					 lockNullResources.remove(path);
				 }
			 }
		 }
		 resp.setStatus(WebdavStatus.SC_NO_CONTENT);
	 }
	 private String generateNamespaceDeclarations() {
		 return "" xmlns=\"""" + DEFAULT_NAMESPACE + ""\"""";
	 }
	 private boolean isLocked(HttpServletRequest req) {
		 String path = getRelativePath(req);
		 String ifHeader = req.getHeader(""If"");
		 if (ifHeader == null) ifHeader = """";
		 String lockTokenHeader = req.getHeader(""Lock-Token"");
		 if (lockTokenHeader == null) lockTokenHeader = """";
		 return isLocked(path, ifHeader + lockTokenHeader);
	 }
	 private boolean isLocked(String path, String ifHeader) {
		 LockInfo lock = resourceLocks.get(path);
		 Enumeration<String> tokenList = null;
		 if ((lock != null) && (lock.hasExpired())) {
			 resourceLocks.remove(path);
		 }
		 else if (lock != null) {
			 tokenList = lock.tokens.elements();
			 boolean tokenMatch = false;
			 while (tokenList.hasMoreElements()) {
				 String token = tokenList.nextElement();
				 if (ifHeader.indexOf(token) != -1) tokenMatch = true;
			 }
			 if (!tokenMatch) return true;
		 }
		 Enumeration<LockInfo> collectionLocksList = collectionLocks.elements();
		 while (collectionLocksList.hasMoreElements()) {
			 lock = collectionLocksList.nextElement();
			 if (lock.hasExpired()) {
				 collectionLocks.removeElement(lock);
			 }
			 else if (path.startsWith(lock.path)) {
				 tokenList = lock.tokens.elements();
				 boolean tokenMatch = false;
				 while (tokenList.hasMoreElements()) {
					 String token = tokenList.nextElement();
					 if (ifHeader.indexOf(token) != -1) tokenMatch = true;
				 }
				 if (!tokenMatch) return true;
			 }
		 }
		 return false;
	 }
	 private boolean copyResource(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		 String destinationPath = req.getHeader(""Destination"");
		 if (destinationPath == null) {
			 resp.sendError(WebdavStatus.SC_BAD_REQUEST);
			 return false;
		 }
		 destinationPath = RequestUtil.URLDecode(destinationPath, ""UTF8"");
		 int protocolIndex = destinationPath.indexOf("": if (protocolIndex >= 0) {
			 int firstSeparator = destinationPath.indexOf(""/"", protocolIndex + 4);
			 if (firstSeparator < 0) {
				 destinationPath = ""/"";
			 }
			 else {
				 destinationPath = destinationPath.substring(firstSeparator);
			 }
		 }
		 else {
			 String hostName = req.getServerName();
			 if ((hostName != null) && (destinationPath.startsWith(hostName))) {
				 destinationPath = destinationPath.substring(hostName.length());
			 }
			 int portIndex = destinationPath.indexOf("":"");
			 if (portIndex >= 0) {
				 destinationPath = destinationPath.substring(portIndex);
			 }
			 if (destinationPath.startsWith("":"")) {
				 int firstSeparator = destinationPath.indexOf(""/"");
				 if (firstSeparator < 0) {
					 destinationPath = ""/"";
				 }
				 else {
					 destinationPath = destinationPath.substring(firstSeparator);
				 }
			 }
		 }
		 destinationPath = RequestUtil.normalize(destinationPath);
		 String contextPath = req.getContextPath();
		 if ((contextPath != null) && (destinationPath.startsWith(contextPath))) {
			 destinationPath = destinationPath.substring(contextPath.length());
		 }
		 String pathInfo = req.getPathInfo();
		 if (pathInfo != null) {
			 String servletPath = req.getServletPath();
			 if ((servletPath != null) && (destinationPath.startsWith(servletPath))) {
				 destinationPath = destinationPath .substring(servletPath.length());
			 }
		 }
		 if (debug > 0) log(""Dest path :"" + destinationPath);
		 if ((destinationPath.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"")) || (destinationPath.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF""))) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return false;
		 }
		 String path = getRelativePath(req);
		 if ((path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"")) || (path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF""))) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return false;
		 }
		 if (destinationPath.equals(path)) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return false;
		 }
		 boolean overwrite = true;
		 String overwriteHeader = req.getHeader(""Overwrite"");
		 if (overwriteHeader != null) {
			 if (overwriteHeader.equalsIgnoreCase(""T"")) {
				 overwrite = true;
			 }
			 else {
				 overwrite = false;
			 }
		 }
		 boolean exists = true;
		 try {
			 resources.lookup(destinationPath);
		 }
		 catch (NamingException e) {
			 exists = false;
		 }
		 if (overwrite) {
			 if (exists) {
				 if (!deleteResource(destinationPath, req, resp, true)) {
					 return false;
				 }
			 }
			 else {
				 resp.setStatus(WebdavStatus.SC_CREATED);
			 }
		 }
		 else {
			 if (exists) {
				 resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
				 return false;
			 }
		 }
		 Hashtable<String,Integer> errorList = new Hashtable<String,Integer>();
		 boolean result = copyResource(resources, errorList, path, destinationPath);
		 if ((!result) || (!errorList.isEmpty())) {
			 if (errorList.size() == 1) {
				 resp.sendError(errorList.elements().nextElement().intValue());
			 }
			 else {
				 sendReport(req, resp, errorList);
			 }
			 return false;
		 }
		 if (exists) {
			 resp.setStatus(WebdavStatus.SC_NO_CONTENT);
		 }
		 else {
			 resp.setStatus(WebdavStatus.SC_CREATED);
		 }
		 lockNullResources.remove(destinationPath);
		 return true;
	 }
	 private boolean copyResource(DirContext dirContext, Hashtable<String,Integer> errorList, String source, String dest) {
		 if (debug > 1) log(""Copy: "" + source + "" To: "" + dest);
		 Object object = null;
		 try {
			 object = dirContext.lookup(source);
		 }
		 catch (NamingException e) {
		 }
		 if (object instanceof DirContext) {
			 try {
				 dirContext.createSubcontext(dest);
			 }
			 catch (NamingException e) {
				 errorList.put (dest, new Integer(WebdavStatus.SC_CONFLICT));
				 return false;
			 }
			 try {
				 NamingEnumeration<NameClassPair> enumeration = dirContext.list(source);
				 while (enumeration.hasMoreElements()) {
					 NameClassPair ncPair = enumeration.nextElement();
					 String childDest = dest;
					 if (!childDest.equals(""/"")) childDest += ""/"";
					 childDest += ncPair.getName();
					 String childSrc = source;
					 if (!childSrc.equals(""/"")) childSrc += ""/"";
					 childSrc += ncPair.getName();
					 copyResource(dirContext, errorList, childSrc, childDest);
				 }
			 }
			 catch (NamingException e) {
				 errorList.put (dest, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
				 return false;
			 }
		 }
		 else {
			 if (object instanceof Resource) {
				 try {
					 dirContext.bind(dest, object);
				 }
				 catch (NamingException e) {
					 if (e.getCause() instanceof FileNotFoundException) {
						 errorList.put(source, new Integer(WebdavStatus.SC_CONFLICT));
					 }
					 else {
						 errorList.put(source, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
					 }
					 return false;
				 }
			 }
			 else {
				 errorList.put (source, new Integer(WebdavStatus.SC_INTERNAL_SERVER_ERROR));
				 return false;
			 }
		 }
		 return true;
	 }
	 private boolean deleteResource(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		 String path = getRelativePath(req);
		 return deleteResource(path, req, resp, true);
	 }
	 private boolean deleteResource(String path, HttpServletRequest req, HttpServletResponse resp, boolean setStatus) throws IOException {
		 if ((path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"")) || (path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF""))) {
			 resp.sendError(WebdavStatus.SC_FORBIDDEN);
			 return false;
		 }
		 String ifHeader = req.getHeader(""If"");
		 if (ifHeader == null) ifHeader = """";
		 String lockTokenHeader = req.getHeader(""Lock-Token"");
		 if (lockTokenHeader == null) lockTokenHeader = """";
		 if (isLocked(path, ifHeader + lockTokenHeader)) {
			 resp.sendError(WebdavStatus.SC_LOCKED);
			 return false;
		 }
		 boolean exists = true;
		 Object object = null;
		 try {
			 object = resources.lookup(path);
		 }
		 catch (NamingException e) {
			 exists = false;
		 }
		 if (!exists) {
			 resp.sendError(WebdavStatus.SC_NOT_FOUND);
			 return false;
		 }
		 boolean collection = (object instanceof DirContext);
		 if (!collection) {
			 try {
				 resources.unbind(path);
			 }
			 catch (NamingException e) {
				 resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
				 return false;
			 }
		 }
		 else {
			 Hashtable<String,Integer> errorList = new Hashtable<String,Integer>();
			 deleteCollection(req, resources, path, errorList);
			 try {
				 resources.unbind(path);
			 }
			 catch (NamingException e) {
				 errorList.put(path, new Integer (WebdavStatus.SC_INTERNAL_SERVER_ERROR));
			 }
			 if (!errorList.isEmpty()) {
				 sendReport(req, resp, errorList);
				 return false;
			 }
		 }
		 if (setStatus) {
			 resp.setStatus(WebdavStatus.SC_NO_CONTENT);
		 }
		 return true;
	 }
	 private void deleteCollection(HttpServletRequest req, DirContext dirContext, String path, Hashtable<String,Integer> errorList) {
		 if (debug > 1) log(""Delete:"" + path);
		 if ((path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"")) || (path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF""))) {
			 errorList.put(path, new Integer(WebdavStatus.SC_FORBIDDEN));
			 return;
		 }
		 String ifHeader = req.getHeader(""If"");
		 if (ifHeader == null) ifHeader = """";
		 String lockTokenHeader = req.getHeader(""Lock-Token"");
		 if (lockTokenHeader == null) lockTokenHeader = """";
		 Enumeration<NameClassPair> enumeration = null;
		 try {
			 enumeration = dirContext.list(path);
		 }
		 catch (NamingException e) {
			 errorList.put(path, new Integer (WebdavStatus.SC_INTERNAL_SERVER_ERROR));
			 return;
		 }
		 while (enumeration.hasMoreElements()) {
			 NameClassPair ncPair = enumeration.nextElement();
			 String childName = path;
			 if (!childName.equals(""/"")) childName += ""/"";
			 childName += ncPair.getName();
			 if (isLocked(childName, ifHeader + lockTokenHeader)) {
				 errorList.put(childName, new Integer(WebdavStatus.SC_LOCKED));
			 }
			 else {
				 try {
					 Object object = dirContext.lookup(childName);
					 if (object instanceof DirContext) {
						 deleteCollection(req, dirContext, childName, errorList);
					 }
					 try {
						 dirContext.unbind(childName);
					 }
					 catch (NamingException e) {
						 if (!(object instanceof DirContext)) {
							 errorList.put (childName, new Integer (WebdavStatus.SC_INTERNAL_SERVER_ERROR));
						 }
					 }
				 }
				 catch (NamingException e) {
					 errorList.put (childName, new Integer (WebdavStatus.SC_INTERNAL_SERVER_ERROR));
				 }
			 }
		 }
	 }
	 private void sendReport(HttpServletRequest req, HttpServletResponse resp, Hashtable<String,Integer> errorList) throws IOException {
		 resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
		 String absoluteUri = req.getRequestURI();
		 String relativePath = getRelativePath(req);
		 XMLWriter generatedXML = new XMLWriter();
		 generatedXML.writeXMLHeader();
		 generatedXML.writeElement(null, ""multistatus"" + generateNamespaceDeclarations(), XMLWriter.OPENING);
		 Enumeration<String> pathList = errorList.keys();
		 while (pathList.hasMoreElements()) {
			 String errorPath = pathList.nextElement();
			 int errorCode = errorList.get(errorPath).intValue();
			 generatedXML.writeElement(null, ""response"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""href"", XMLWriter.OPENING);
			 String toAppend = errorPath.substring(relativePath.length());
			 if (!toAppend.startsWith(""/"")) toAppend = ""/"" + toAppend;
			 generatedXML.writeText(absoluteUri + toAppend);
			 generatedXML.writeElement(null, ""href"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML .writeText(""HTTP/1.1 "" + errorCode + "" "" + WebdavStatus.getStatusText(errorCode));
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""response"", XMLWriter.CLOSING);
		 }
		 generatedXML.writeElement(null, ""multistatus"", XMLWriter.CLOSING);
		 Writer writer = resp.getWriter();
		 writer.write(generatedXML.toString());
		 writer.close();
	 }
	 private void parseProperties(HttpServletRequest req, XMLWriter generatedXML, String path, int type, Vector<String> propertiesVector) {
		 if (path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"") || path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF"")) return;
		 CacheEntry cacheEntry = resources.lookupCache(path);
		 if (!cacheEntry.exists) {
			 return;
		 }
		 generatedXML.writeElement(null, ""response"", XMLWriter.OPENING);
		 String status = new String(""HTTP/1.1 "" + WebdavStatus.SC_OK + "" "" + WebdavStatus.getStatusText (WebdavStatus.SC_OK));
		 generatedXML.writeElement(null, ""href"", XMLWriter.OPENING);
		 String href = req.getContextPath() + req.getServletPath();
		 if ((href.endsWith(""/"")) && (path.startsWith(""/""))) href += path.substring(1);
		 else href += path;
		 if ((cacheEntry.context != null) && (!href.endsWith(""/""))) href += ""/"";
		 generatedXML.writeText(rewriteUrl(href));
		 generatedXML.writeElement(null, ""href"", XMLWriter.CLOSING);
		 String resourceName = path;
		 int lastSlash = path.lastIndexOf('/');
		 if (lastSlash != -1) resourceName = resourceName.substring(lastSlash + 1);
		 switch (type) {
			 case FIND_ALL_PROP : generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
			 generatedXML.writeProperty (null, ""creationdate"", getISOCreationDate(cacheEntry.attributes.getCreation()));
			 generatedXML.writeElement(null, ""displayname"", XMLWriter.OPENING);
			 generatedXML.writeData(resourceName);
			 generatedXML.writeElement(null, ""displayname"", XMLWriter.CLOSING);
			 if (cacheEntry.resource != null) {
				 generatedXML.writeProperty (null, ""getlastmodified"", FastHttpDateFormat.formatDate (cacheEntry.attributes.getLastModified(), null));
				 generatedXML.writeProperty (null, ""getcontentlength"", String.valueOf(cacheEntry.attributes.getContentLength()));
				 String contentType = getServletContext().getMimeType (cacheEntry.name);
				 if (contentType != null) {
					 generatedXML.writeProperty(null, ""getcontenttype"", contentType);
				 }
				 generatedXML.writeProperty(null, ""getetag"", cacheEntry.attributes.getETag());
				 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.NO_CONTENT);
			 }
			 else {
				 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.OPENING);
				 generatedXML.writeElement(null, ""collection"", XMLWriter.NO_CONTENT);
				 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.CLOSING);
			 }
			 generatedXML.writeProperty(null, ""source"", """");
			 String supportedLocks = ""<lockentry>"" + ""<lockscope><exclusive/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"" + ""<lockentry>"" + ""<lockscope><shared/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"";
			 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.OPENING);
			 generatedXML.writeText(supportedLocks);
			 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.CLOSING);
			 generateLockDiscovery(path, generatedXML);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML.writeText(status);
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 break;
			 case FIND_PROPERTY_NAMES : generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""creationdate"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""displayname"", XMLWriter.NO_CONTENT);
			 if (cacheEntry.resource != null) {
				 generatedXML.writeElement(null, ""getcontentlanguage"", XMLWriter.NO_CONTENT);
				 generatedXML.writeElement(null, ""getcontentlength"", XMLWriter.NO_CONTENT);
				 generatedXML.writeElement(null, ""getcontenttype"", XMLWriter.NO_CONTENT);
				 generatedXML.writeElement(null, ""getetag"", XMLWriter.NO_CONTENT);
				 generatedXML.writeElement(null, ""getlastmodified"", XMLWriter.NO_CONTENT);
			 }
			 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""source"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML.writeText(status);
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 break;
			 case FIND_BY_PROPERTY : Vector<String> propertiesNotFound = new Vector<String>();
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
			 Enumeration<String> properties = propertiesVector.elements();
			 while (properties.hasMoreElements()) {
				 String property = properties.nextElement();
				 if (property.equals(""creationdate"")) {
					 generatedXML.writeProperty (null, ""creationdate"", getISOCreationDate(cacheEntry.attributes.getCreation()));
				 }
				 else if (property.equals(""displayname"")) {
					 generatedXML.writeElement (null, ""displayname"", XMLWriter.OPENING);
					 generatedXML.writeData(resourceName);
					 generatedXML.writeElement (null, ""displayname"", XMLWriter.CLOSING);
				 }
				 else if (property.equals(""getcontentlanguage"")) {
					 if (cacheEntry.context != null) {
						 propertiesNotFound.addElement(property);
					 }
					 else {
						 generatedXML.writeElement(null, ""getcontentlanguage"", XMLWriter.NO_CONTENT);
					 }
				 }
				 else if (property.equals(""getcontentlength"")) {
					 if (cacheEntry.context != null) {
						 propertiesNotFound.addElement(property);
					 }
					 else {
						 generatedXML.writeProperty (null, ""getcontentlength"", (String.valueOf(cacheEntry.attributes.getContentLength())));
					 }
				 }
				 else if (property.equals(""getcontenttype"")) {
					 if (cacheEntry.context != null) {
						 propertiesNotFound.addElement(property);
					 }
					 else {
						 generatedXML.writeProperty (null, ""getcontenttype"", getServletContext().getMimeType (cacheEntry.name));
					 }
				 }
				 else if (property.equals(""getetag"")) {
					 if (cacheEntry.context != null) {
						 propertiesNotFound.addElement(property);
					 }
					 else {
						 generatedXML.writeProperty (null, ""getetag"", cacheEntry.attributes.getETag());
					 }
				 }
				 else if (property.equals(""getlastmodified"")) {
					 if (cacheEntry.context != null) {
						 propertiesNotFound.addElement(property);
					 }
					 else {
						 generatedXML.writeProperty (null, ""getlastmodified"", FastHttpDateFormat.formatDate (cacheEntry.attributes.getLastModified(), null));
					 }
				 }
				 else if (property.equals(""resourcetype"")) {
					 if (cacheEntry.context != null) {
						 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.OPENING);
						 generatedXML.writeElement(null, ""collection"", XMLWriter.NO_CONTENT);
						 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.CLOSING);
					 }
					 else {
						 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.NO_CONTENT);
					 }
				 }
				 else if (property.equals(""source"")) {
					 generatedXML.writeProperty(null, ""source"", """");
				 }
				 else if (property.equals(""supportedlock"")) {
					 supportedLocks = ""<lockentry>"" + ""<lockscope><exclusive/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"" + ""<lockentry>"" + ""<lockscope><shared/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"";
					 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.OPENING);
					 generatedXML.writeText(supportedLocks);
					 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.CLOSING);
				 }
				 else if (property.equals(""lockdiscovery"")) {
					 if (!generateLockDiscovery(path, generatedXML)) propertiesNotFound.addElement(property);
				 }
				 else {
					 propertiesNotFound.addElement(property);
				 }
			 }
			 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML.writeText(status);
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 Enumeration<String> propertiesNotFoundList = propertiesNotFound.elements();
			 if (propertiesNotFoundList.hasMoreElements()) {
				 status = new String(""HTTP/1.1 "" + WebdavStatus.SC_NOT_FOUND + "" "" + WebdavStatus.getStatusText (WebdavStatus.SC_NOT_FOUND));
				 generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
				 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
				 while (propertiesNotFoundList.hasMoreElements()) {
					 generatedXML.writeElement (null, propertiesNotFoundList.nextElement(), XMLWriter.NO_CONTENT);
				 }
				 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
				 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
				 generatedXML.writeText(status);
				 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
				 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 }
			 break;
		 }
		 generatedXML.writeElement(null, ""response"", XMLWriter.CLOSING);
	 }
	 private void parseLockNullProperties(HttpServletRequest req, XMLWriter generatedXML, String path, int type, Vector<String> propertiesVector) {
		 if (path.toUpperCase(Locale.ENGLISH).startsWith(""/WEB-INF"") || path.toUpperCase(Locale.ENGLISH).startsWith(""/META-INF"")) return;
		 LockInfo lock = resourceLocks.get(path);
		 if (lock == null) return;
		 generatedXML.writeElement(null, ""response"", XMLWriter.OPENING);
		 String status = new String(""HTTP/1.1 "" + WebdavStatus.SC_OK + "" "" + WebdavStatus.getStatusText (WebdavStatus.SC_OK));
		 generatedXML.writeElement(null, ""href"", XMLWriter.OPENING);
		 String absoluteUri = req.getRequestURI();
		 String relativePath = getRelativePath(req);
		 String toAppend = path.substring(relativePath.length());
		 if (!toAppend.startsWith(""/"")) toAppend = ""/"" + toAppend;
		 generatedXML.writeText(rewriteUrl(RequestUtil.normalize( absoluteUri + toAppend)));
		 generatedXML.writeElement(null, ""href"", XMLWriter.CLOSING);
		 String resourceName = path;
		 int lastSlash = path.lastIndexOf('/');
		 if (lastSlash != -1) resourceName = resourceName.substring(lastSlash + 1);
		 switch (type) {
			 case FIND_ALL_PROP : generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
			 generatedXML.writeProperty (null, ""creationdate"", getISOCreationDate(lock.creationDate.getTime()));
			 generatedXML.writeElement (null, ""displayname"", XMLWriter.OPENING);
			 generatedXML.writeData(resourceName);
			 generatedXML.writeElement (null, ""displayname"", XMLWriter.CLOSING);
			 generatedXML.writeProperty(null, ""getlastmodified"", FastHttpDateFormat.formatDate (lock.creationDate.getTime(), null));
			 generatedXML.writeProperty (null, ""getcontentlength"", String.valueOf(0));
			 generatedXML.writeProperty(null, ""getcontenttype"", """");
			 generatedXML.writeProperty(null, ""getetag"", """");
			 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""lock-null"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.CLOSING);
			 generatedXML.writeProperty(null, ""source"", """");
			 String supportedLocks = ""<lockentry>"" + ""<lockscope><exclusive/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"" + ""<lockentry>"" + ""<lockscope><shared/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"";
			 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.OPENING);
			 generatedXML.writeText(supportedLocks);
			 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.CLOSING);
			 generateLockDiscovery(path, generatedXML);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML.writeText(status);
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 break;
			 case FIND_PROPERTY_NAMES : generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""creationdate"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""displayname"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""getcontentlanguage"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""getcontentlength"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""getcontenttype"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""getetag"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""getlastmodified"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""source"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML.writeText(status);
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 break;
			 case FIND_BY_PROPERTY : Vector<String> propertiesNotFound = new Vector<String>();
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
			 Enumeration<String> properties = propertiesVector.elements();
			 while (properties.hasMoreElements()) {
				 String property = properties.nextElement();
				 if (property.equals(""creationdate"")) {
					 generatedXML.writeProperty (null, ""creationdate"", getISOCreationDate(lock.creationDate.getTime()));
				 }
				 else if (property.equals(""displayname"")) {
					 generatedXML.writeElement (null, ""displayname"", XMLWriter.OPENING);
					 generatedXML.writeData(resourceName);
					 generatedXML.writeElement (null, ""displayname"", XMLWriter.CLOSING);
				 }
				 else if (property.equals(""getcontentlanguage"")) {
					 generatedXML.writeElement(null, ""getcontentlanguage"", XMLWriter.NO_CONTENT);
				 }
				 else if (property.equals(""getcontentlength"")) {
					 generatedXML.writeProperty (null, ""getcontentlength"", (String.valueOf(0)));
				 }
				 else if (property.equals(""getcontenttype"")) {
					 generatedXML.writeProperty (null, ""getcontenttype"", """");
				 }
				 else if (property.equals(""getetag"")) {
					 generatedXML.writeProperty(null, ""getetag"", """");
				 }
				 else if (property.equals(""getlastmodified"")) {
					 generatedXML.writeProperty (null, ""getlastmodified"", FastHttpDateFormat.formatDate (lock.creationDate.getTime(), null));
				 }
				 else if (property.equals(""resourcetype"")) {
					 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.OPENING);
					 generatedXML.writeElement(null, ""lock-null"", XMLWriter.NO_CONTENT);
					 generatedXML.writeElement(null, ""resourcetype"", XMLWriter.CLOSING);
				 }
				 else if (property.equals(""source"")) {
					 generatedXML.writeProperty(null, ""source"", """");
				 }
				 else if (property.equals(""supportedlock"")) {
					 supportedLocks = ""<lockentry>"" + ""<lockscope><exclusive/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"" + ""<lockentry>"" + ""<lockscope><shared/></lockscope>"" + ""<locktype><write/></locktype>"" + ""</lockentry>"";
					 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.OPENING);
					 generatedXML.writeText(supportedLocks);
					 generatedXML.writeElement(null, ""supportedlock"", XMLWriter.CLOSING);
				 }
				 else if (property.equals(""lockdiscovery"")) {
					 if (!generateLockDiscovery(path, generatedXML)) propertiesNotFound.addElement(property);
				 }
				 else {
					 propertiesNotFound.addElement(property);
				 }
			 }
			 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
			 generatedXML.writeText(status);
			 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 Enumeration<String> propertiesNotFoundList = propertiesNotFound.elements();
			 if (propertiesNotFoundList.hasMoreElements()) {
				 status = new String(""HTTP/1.1 "" + WebdavStatus.SC_NOT_FOUND + "" "" + WebdavStatus.getStatusText (WebdavStatus.SC_NOT_FOUND));
				 generatedXML.writeElement(null, ""propstat"", XMLWriter.OPENING);
				 generatedXML.writeElement(null, ""prop"", XMLWriter.OPENING);
				 while (propertiesNotFoundList.hasMoreElements()) {
					 generatedXML.writeElement (null, propertiesNotFoundList.nextElement(), XMLWriter.NO_CONTENT);
				 }
				 generatedXML.writeElement(null, ""prop"", XMLWriter.CLOSING);
				 generatedXML.writeElement(null, ""status"", XMLWriter.OPENING);
				 generatedXML.writeText(status);
				 generatedXML.writeElement(null, ""status"", XMLWriter.CLOSING);
				 generatedXML.writeElement(null, ""propstat"", XMLWriter.CLOSING);
			 }
			 break;
		 }
		 generatedXML.writeElement(null, ""response"", XMLWriter.CLOSING);
	 }
	 private boolean generateLockDiscovery (String path, XMLWriter generatedXML) {
		 LockInfo resourceLock = resourceLocks.get(path);
		 Enumeration<LockInfo> collectionLocksList = collectionLocks.elements();
		 boolean wroteStart = false;
		 if (resourceLock != null) {
			 wroteStart = true;
			 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.OPENING);
			 resourceLock.toXML(generatedXML);
		 }
		 while (collectionLocksList.hasMoreElements()) {
			 LockInfo currentLock = collectionLocksList.nextElement();
			 if (path.startsWith(currentLock.path)) {
				 if (!wroteStart) {
					 wroteStart = true;
					 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.OPENING);
				 }
				 currentLock.toXML(generatedXML);
			 }
		 }
		 if (wroteStart) {
			 generatedXML.writeElement(null, ""lockdiscovery"", XMLWriter.CLOSING);
		 }
		 else {
			 return false;
		 }
		 return true;
	 }
	 private String getISOCreationDate(long creationDate) {
		 StringBuilder creationDateValue = new StringBuilder (creationDateFormat.format (new Date(creationDate)));
		 return creationDateValue.toString();
	 }
	 private StringBuilder determineMethodsAllowed(DirContext dirContext, HttpServletRequest req) {
		 StringBuilder methodsAllowed = new StringBuilder();
		 boolean exists = true;
		 Object object = null;
		 try {
			 String path = getRelativePath(req);
			 object = dirContext.lookup(path);
		 }
		 catch (NamingException e) {
			 exists = false;
		 }
		 if (!exists) {
			 methodsAllowed.append(""OPTIONS, MKCOL, PUT, LOCK"");
			 return methodsAllowed;
		 }
		 methodsAllowed.append(""OPTIONS, GET, HEAD, POST, DELETE, TRACE"");
		 methodsAllowed.append("", PROPPATCH, COPY, MOVE, LOCK, UNLOCK"");
		 if (listings) {
			 methodsAllowed.append("", PROPFIND"");
		 }
		 if (!(object instanceof DirContext)) {
			 methodsAllowed.append("", PUT"");
		 }
		 return methodsAllowed;
	 }
	 private class LockInfo {
		 public LockInfo() {
		 }
		 String path = ""/"";
		 String type = ""write"";
		 String scope = ""exclusive"";
		 int depth = 0;
		 String owner = """";
		 Vector<String> tokens = new Vector<String>();
		 long expiresAt = 0;
		 Date creationDate = new Date();
		 public String toString() {
			 String result = ""Type:"" + type + ""\n"";
			 result += ""Scope:"" + scope + ""\n"";
			 result += ""Depth:"" + depth + ""\n"";
			 result += ""Owner:"" + owner + ""\n"";
			 result += ""Expiration:"" + FastHttpDateFormat.formatDate(expiresAt, null) + ""\n"";
			 Enumeration<String> tokensList = tokens.elements();
			 while (tokensList.hasMoreElements()) {
				 result += ""Token:"" + tokensList.nextElement() + ""\n"";
			 }
			 return result;
		 }
		 public boolean hasExpired() {
			 return (System.currentTimeMillis() > expiresAt);
		 }
		 public boolean isExclusive() {
			 return (scope.equals(""exclusive""));
		 }
		 public void toXML(XMLWriter generatedXML) {
			 generatedXML.writeElement(null, ""activelock"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, ""locktype"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, type, XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""locktype"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""lockscope"", XMLWriter.OPENING);
			 generatedXML.writeElement(null, scope, XMLWriter.NO_CONTENT);
			 generatedXML.writeElement(null, ""lockscope"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""depth"", XMLWriter.OPENING);
			 if (depth == maxDepth) {
				 generatedXML.writeText(""Infinity"");
			 }
			 else {
				 generatedXML.writeText(""0"");
			 }
			 generatedXML.writeElement(null, ""depth"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""owner"", XMLWriter.OPENING);
			 generatedXML.writeText(owner);
			 generatedXML.writeElement(null, ""owner"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""timeout"", XMLWriter.OPENING);
			 long timeout = (expiresAt - System.currentTimeMillis()) / 1000;
			 generatedXML.writeText(""Second-"" + timeout);
			 generatedXML.writeElement(null, ""timeout"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""locktoken"", XMLWriter.OPENING);
			 Enumeration<String> tokensList = tokens.elements();
			 while (tokensList.hasMoreElements()) {
				 generatedXML.writeElement(null, ""href"", XMLWriter.OPENING);
				 generatedXML.writeText(""opaquelocktoken:"" + tokensList.nextElement());
				 generatedXML.writeElement(null, ""href"", XMLWriter.CLOSING);
			 }
			 generatedXML.writeElement(null, ""locktoken"", XMLWriter.CLOSING);
			 generatedXML.writeElement(null, ""activelock"", XMLWriter.CLOSING);
		 }
	 }
	 private class WebdavResolver implements EntityResolver {
		 private ServletContext context;
		 public WebdavResolver(ServletContext theContext) {
			 context = theContext;
		 }
		 public InputSource resolveEntity (String publicId, String systemId) {
			 context.log(sm.getString(""webdavservlet.enternalEntityIgnored"", publicId, systemId));
			 return new InputSource( new StringReader(""Ignored external entity""));
		 }
	 }
}
class WebdavStatus {
	 private static Hashtable<Integer,String> mapStatusCodes = new Hashtable<Integer,String>();
	 public static final int SC_OK = HttpServletResponse.SC_OK;
	 public static final int SC_CREATED = HttpServletResponse.SC_CREATED;
	 public static final int SC_ACCEPTED = HttpServletResponse.SC_ACCEPTED;
	 public static final int SC_NO_CONTENT = HttpServletResponse.SC_NO_CONTENT;
	 public static final int SC_MOVED_PERMANENTLY = HttpServletResponse.SC_MOVED_PERMANENTLY;
	 public static final int SC_MOVED_TEMPORARILY = HttpServletResponse.SC_MOVED_TEMPORARILY;
	 public static final int SC_NOT_MODIFIED = HttpServletResponse.SC_NOT_MODIFIED;
	 public static final int SC_BAD_REQUEST = HttpServletResponse.SC_BAD_REQUEST;
	 public static final int SC_UNAUTHORIZED = HttpServletResponse.SC_UNAUTHORIZED;
	 public static final int SC_FORBIDDEN = HttpServletResponse.SC_FORBIDDEN;
	 public static final int SC_NOT_FOUND = HttpServletResponse.SC_NOT_FOUND;
	 public static final int SC_INTERNAL_SERVER_ERROR = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
	 public static final int SC_NOT_IMPLEMENTED = HttpServletResponse.SC_NOT_IMPLEMENTED;
	 public static final int SC_BAD_GATEWAY = HttpServletResponse.SC_BAD_GATEWAY;
	 public static final int SC_SERVICE_UNAVAILABLE = HttpServletResponse.SC_SERVICE_UNAVAILABLE;
	 public static final int SC_CONTINUE = 100;
	 public static final int SC_METHOD_NOT_ALLOWED = 405;
	 public static final int SC_CONFLICT = 409;
	 public static final int SC_PRECONDITION_FAILED = 412;
	 public static final int SC_REQUEST_TOO_LONG = 413;
	 public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;
	 public static final int SC_MULTI_STATUS = 207;
	 public static final int SC_UNPROCESSABLE_ENTITY = 418;
	 public static final int SC_INSUFFICIENT_SPACE_ON_RESOURCE = 419;
	 public static final int SC_METHOD_FAILURE = 420;
	 public static final int SC_LOCKED = 423;
	 static {
		 addStatusCodeMap(SC_OK, ""OK"");
		 addStatusCodeMap(SC_CREATED, ""Created"");
		 addStatusCodeMap(SC_ACCEPTED, ""Accepted"");
		 addStatusCodeMap(SC_NO_CONTENT, ""No Content"");
		 addStatusCodeMap(SC_MOVED_PERMANENTLY, ""Moved Permanently"");
		 addStatusCodeMap(SC_MOVED_TEMPORARILY, ""Moved Temporarily"");
		 addStatusCodeMap(SC_NOT_MODIFIED, ""Not Modified"");
		 addStatusCodeMap(SC_BAD_REQUEST, ""Bad Request"");
		 addStatusCodeMap(SC_UNAUTHORIZED, ""Unauthorized"");
		 addStatusCodeMap(SC_FORBIDDEN, ""Forbidden"");
		 addStatusCodeMap(SC_NOT_FOUND, ""Not Found"");
		 addStatusCodeMap(SC_INTERNAL_SERVER_ERROR, ""Internal Server Error"");
		 addStatusCodeMap(SC_NOT_IMPLEMENTED, ""Not Implemented"");
		 addStatusCodeMap(SC_BAD_GATEWAY, ""Bad Gateway"");
		 addStatusCodeMap(SC_SERVICE_UNAVAILABLE, ""Service Unavailable"");
		 addStatusCodeMap(SC_CONTINUE, ""Continue"");
		 addStatusCodeMap(SC_METHOD_NOT_ALLOWED, ""Method Not Allowed"");
		 addStatusCodeMap(SC_CONFLICT, ""Conflict"");
		 addStatusCodeMap(SC_PRECONDITION_FAILED, ""Precondition Failed"");
		 addStatusCodeMap(SC_REQUEST_TOO_LONG, ""Request Too Long"");
		 addStatusCodeMap(SC_UNSUPPORTED_MEDIA_TYPE, ""Unsupported Media Type"");
		 addStatusCodeMap(SC_MULTI_STATUS, ""Multi-Status"");
		 addStatusCodeMap(SC_UNPROCESSABLE_ENTITY, ""Unprocessable Entity"");
		 addStatusCodeMap(SC_INSUFFICIENT_SPACE_ON_RESOURCE, ""Insufficient Space On Resource"");
		 addStatusCodeMap(SC_METHOD_FAILURE, ""Method Failure"");
		 addStatusCodeMap(SC_LOCKED, ""Locked"");
	 }
	 public static String getStatusText(int nHttpStatusCode) {
		 Integer intKey = new Integer(nHttpStatusCode);
		 if (!mapStatusCodes.containsKey(intKey)) {
			 return """";
		 }
		 else {
			 return mapStatusCodes.get(intKey);
		 }
	 }
	 private static void addStatusCodeMap(int nKey, String strVal) {
		 mapStatusCodes.put(new Integer(nKey), strVal);
	 }
}",1,0,0,0
"public class SQLDocument extends DTMDocument{
	 private boolean DEBUG = false;
	 private static final String S_NAMESPACE = ""http: private static final String S_SQL = ""sql"";
	 private static final String S_ROW_SET = ""row-set"";
	 private static final String S_METADATA = ""metadata"";
	 private static final String S_COLUMN_HEADER = ""column-header"";
	 private static final String S_ROW = ""row"";
	 private static final String S_COL = ""col"";
	 private static final String S_OUT_PARAMETERS = ""out-parameters"";
	 private static final String S_CATALOGUE_NAME = ""catalogue-name"";
	 private static final String S_DISPLAY_SIZE = ""column-display-size"";
	 private static final String S_COLUMN_LABEL = ""column-label"";
	 private static final String S_COLUMN_NAME = ""column-name"";
	 private static final String S_COLUMN_TYPE = ""column-type"";
	 private static final String S_COLUMN_TYPENAME = ""column-typename"";
	 private static final String S_PRECISION = ""precision"";
	 private static final String S_SCALE = ""scale"";
	 private static final String S_SCHEMA_NAME = ""schema-name"";
	 private static final String S_TABLE_NAME = ""table-name"";
	 private static final String S_CASESENSITIVE = ""case-sensitive"";
	 private static final String S_DEFINITELYWRITABLE = ""definitely-writable"";
	 private static final String S_ISNULLABLE = ""nullable"";
	 private static final String S_ISSIGNED = ""signed"";
	 private static final String S_ISWRITEABLE = ""writable"";
	 private static final String S_ISSEARCHABLE = ""searchable"";
	 private int m_SQL_TypeID = 0;
	 private int m_MetaData_TypeID = 0;
	 private int m_ColumnHeader_TypeID = 0;
	 private int m_RowSet_TypeID = 0;
	 private int m_Row_TypeID = 0;
	 private int m_Col_TypeID = 0;
	 private int m_OutParameter_TypeID = 0;
	 private int m_ColAttrib_CATALOGUE_NAME_TypeID = 0;
	 private int m_ColAttrib_DISPLAY_SIZE_TypeID = 0;
	 private int m_ColAttrib_COLUMN_LABEL_TypeID = 0;
	 private int m_ColAttrib_COLUMN_NAME_TypeID = 0;
	 private int m_ColAttrib_COLUMN_TYPE_TypeID = 0;
	 private int m_ColAttrib_COLUMN_TYPENAME_TypeID = 0;
	 private int m_ColAttrib_PRECISION_TypeID = 0;
	 private int m_ColAttrib_SCALE_TypeID = 0;
	 private int m_ColAttrib_SCHEMA_NAME_TypeID = 0;
	 private int m_ColAttrib_TABLE_NAME_TypeID = 0;
	 private int m_ColAttrib_CASESENSITIVE_TypeID = 0;
	 private int m_ColAttrib_DEFINITELYWRITEABLE_TypeID = 0;
	 private int m_ColAttrib_ISNULLABLE_TypeID = 0;
	 private int m_ColAttrib_ISSIGNED_TypeID = 0;
	 private int m_ColAttrib_ISWRITEABLE_TypeID = 0;
	 private int m_ColAttrib_ISSEARCHABLE_TypeID = 0;
	 private Statement m_Statement = null;
	 private ExpressionContext m_ExpressionContext = null;
	 private ConnectionPool m_ConnectionPool = null;
	 private ResultSet m_ResultSet = null;
	 private SQLQueryParser m_QueryParser = null;
	 private int[] m_ColHeadersIdx;
	 private int m_ColCount;
	 private int m_MetaDataIdx = DTM.NULL;
	 private int m_RowSetIdx = DTM.NULL;
	 private int m_SQLIdx = DTM.NULL;
	 private int m_FirstRowIdx = DTM.NULL;
	 private int m_LastRowIdx = DTM.NULL;
	 private boolean m_StreamingMode = true;
	 private boolean m_MultipleResults = false;
	 private boolean m_HasErrors = false;
	 private boolean m_IsStatementCachingEnabled = false;
	 private XConnection m_XConnection = null;
	 public SQLDocument(DTMManager mgr, int ident) {
		 super(mgr, ident);
	 }
	 public static SQLDocument getNewDocument(ExpressionContext exprContext) {
		 DTMManager mgr = ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
		 DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
		 int dtmIdent = mgrDefault.getFirstFreeDTMID();
		 SQLDocument doc = new SQLDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS);
		 mgrDefault.addDTM(doc, dtmIdent);
		 doc.setExpressionContext(exprContext);
		 return doc;
	 }
	 protected void setExpressionContext(ExpressionContext expr) {
		 m_ExpressionContext = expr;
	 }
	 public ExpressionContext getExpressionContext() {
		 return m_ExpressionContext;
	 }
	 public void execute(XConnection xconn, SQLQueryParser query) throws SQLException {
		 try {
			 m_StreamingMode = ""true"".equals(xconn.getFeature(""streaming""));
			 m_MultipleResults = ""true"".equals(xconn.getFeature(""multiple-results""));
			 m_IsStatementCachingEnabled = ""true"".equals(xconn.getFeature(""cache-statements""));
			 m_XConnection = xconn;
			 m_QueryParser = query;
			 executeSQLStatement();
			 createExpandedNameTable();
			 m_DocumentIdx = addElement(0, m_Document_TypeID, DTM.NULL, DTM.NULL);
			 m_SQLIdx = addElement(1, m_SQL_TypeID, m_DocumentIdx, DTM.NULL);
			 if ( ! m_MultipleResults ) extractSQLMetaData(m_ResultSet.getMetaData());
		 }
		 catch(SQLException e) {
			 m_HasErrors = true;
			 throw e;
		 }
	 }
	 private void executeSQLStatement() throws SQLException {
		 m_ConnectionPool = m_XConnection.getConnectionPool();
		 Connection conn = m_ConnectionPool.getConnection();
		 if (! m_QueryParser.hasParameters() ) {
			 m_Statement = conn.createStatement();
			 m_ResultSet = m_Statement.executeQuery(m_QueryParser.getSQLQuery());
		 }
		 else if (m_QueryParser.isCallable()) {
			 CallableStatement cstmt = conn.prepareCall(m_QueryParser.getSQLQuery());
			 m_QueryParser.registerOutputParameters(cstmt);
			 m_QueryParser.populateStatement(cstmt, m_ExpressionContext);
			 m_Statement = cstmt;
			 if (! cstmt.execute()) throw new SQLException(""Error in Callable Statement"");
			 m_ResultSet = m_Statement.getResultSet();
		 }
		 else {
			 PreparedStatement stmt = conn.prepareStatement(m_QueryParser.getSQLQuery());
			 m_QueryParser.populateStatement(stmt, m_ExpressionContext);
			 m_Statement = stmt;
			 m_ResultSet = stmt.executeQuery();
		 }
	 }
	 public void skip( int value ) {
		 try {
			 if (m_ResultSet != null) m_ResultSet.relative(value);
		 }
		 catch(Exception origEx) {
			 try {
				 for (int x=0;
				 x<value;
				 x++) {
					 if (! m_ResultSet.next()) break;
				 }
			 }
			 catch(Exception e) {
				 m_XConnection.setError(origEx, this, checkWarnings());
				 m_XConnection.setError(e, this, checkWarnings());
			 }
		 }
	 }
	 private void extractSQLMetaData( ResultSetMetaData meta ) {
		 m_MetaDataIdx = addElement(1, m_MetaData_TypeID, m_MultipleResults ? m_RowSetIdx : m_SQLIdx, DTM.NULL);
		 try {
			 m_ColCount = meta.getColumnCount();
			 m_ColHeadersIdx = new int[m_ColCount];
		 }
		 catch(Exception e) {
			 m_XConnection.setError(e, this, checkWarnings());
		 }
		 int lastColHeaderIdx = DTM.NULL;
		 int i = 1;
		 for (i=1;
		 i<= m_ColCount;
		 i++) {
			 m_ColHeadersIdx[i-1] = addElement(2,m_ColumnHeader_TypeID, m_MetaDataIdx, lastColHeaderIdx);
			 lastColHeaderIdx = m_ColHeadersIdx[i-1];
			 try {
				 addAttributeToNode( meta.getColumnName(i), m_ColAttrib_COLUMN_NAME_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_COLUMN_NAME_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.getColumnLabel(i), m_ColAttrib_COLUMN_LABEL_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_COLUMN_LABEL_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.getCatalogName(i), m_ColAttrib_CATALOGUE_NAME_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_CATALOGUE_NAME_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( new Integer(meta.getColumnDisplaySize(i)), m_ColAttrib_DISPLAY_SIZE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_DISPLAY_SIZE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( new Integer(meta.getColumnType(i)), m_ColAttrib_COLUMN_TYPE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_COLUMN_TYPE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.getColumnTypeName(i), m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( new Integer(meta.getPrecision(i)), m_ColAttrib_PRECISION_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_PRECISION_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( new Integer(meta.getScale(i)), m_ColAttrib_SCALE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_SCALE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.getSchemaName(i), m_ColAttrib_SCHEMA_NAME_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_SCHEMA_NAME_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.getTableName(i), m_ColAttrib_TABLE_NAME_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_TABLE_NAME_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.isCaseSensitive(i) ? S_ISTRUE : S_ISFALSE, m_ColAttrib_CASESENSITIVE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_CASESENSITIVE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.isDefinitelyWritable(i) ? S_ISTRUE : S_ISFALSE, m_ColAttrib_DEFINITELYWRITEABLE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_DEFINITELYWRITEABLE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.isNullable(i) != 0 ? S_ISTRUE : S_ISFALSE, m_ColAttrib_ISNULLABLE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_ISNULLABLE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.isSigned(i) ? S_ISTRUE : S_ISFALSE, m_ColAttrib_ISSIGNED_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_ISSIGNED_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.isWritable(i) == true ? S_ISTRUE : S_ISFALSE, m_ColAttrib_ISWRITEABLE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_ISWRITEABLE_TypeID, lastColHeaderIdx);
			 }
			 try {
				 addAttributeToNode( meta.isSearchable(i) == true ? S_ISTRUE : S_ISFALSE, m_ColAttrib_ISSEARCHABLE_TypeID, lastColHeaderIdx);
			 }
			 catch(Exception e) {
				 addAttributeToNode( S_ATTRIB_NOT_SUPPORTED, m_ColAttrib_ISSEARCHABLE_TypeID, lastColHeaderIdx);
			 }
		 }
	 }
	 protected void createExpandedNameTable( ) {
		 super.createExpandedNameTable();
		 m_SQL_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SQL, DTM.ELEMENT_NODE);
		 m_MetaData_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_METADATA, DTM.ELEMENT_NODE);
		 m_ColumnHeader_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_HEADER, DTM.ELEMENT_NODE);
		 m_RowSet_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ROW_SET, DTM.ELEMENT_NODE);
		 m_Row_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ROW, DTM.ELEMENT_NODE);
		 m_Col_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COL, DTM.ELEMENT_NODE);
		 m_OutParameter_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_OUT_PARAMETERS, DTM.ELEMENT_NODE);
		 m_ColAttrib_CATALOGUE_NAME_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CATALOGUE_NAME, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_DISPLAY_SIZE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DISPLAY_SIZE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_COLUMN_LABEL_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_LABEL, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_COLUMN_NAME_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_NAME, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_COLUMN_TYPE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_TYPE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_COLUMN_TYPENAME_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_TYPENAME, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_PRECISION_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_PRECISION, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_SCALE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SCALE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_SCHEMA_NAME_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SCHEMA_NAME, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_TABLE_NAME_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_TABLE_NAME, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_CASESENSITIVE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CASESENSITIVE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_DEFINITELYWRITEABLE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DEFINITELYWRITABLE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_ISNULLABLE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISNULLABLE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_ISSIGNED_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISSIGNED, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_ISWRITEABLE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISWRITEABLE, DTM.ATTRIBUTE_NODE);
		 m_ColAttrib_ISSEARCHABLE_TypeID = m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISSEARCHABLE, DTM.ATTRIBUTE_NODE);
	 }
	 private boolean addRowToDTMFromResultSet( ) {
		 try {
			 if (m_FirstRowIdx == DTM.NULL) {
				 m_RowSetIdx = addElement(1, m_RowSet_TypeID, m_SQLIdx, m_MultipleResults ? m_RowSetIdx : m_MetaDataIdx);
				 if ( m_MultipleResults ) extractSQLMetaData(m_ResultSet.getMetaData());
			 }
			 if ( ! m_ResultSet.next()) {
				 if (m_StreamingMode && (m_LastRowIdx != DTM.NULL)) {
					 m_nextsib.setElementAt(DTM.NULL, m_LastRowIdx);
				 }
				 m_ResultSet.close();
				 if ( m_MultipleResults ) {
					 while ( !m_Statement.getMoreResults() && m_Statement.getUpdateCount() >= 0 ) ;
					 m_ResultSet = m_Statement.getResultSet();
				 }
				 else m_ResultSet = null;
				 if ( m_ResultSet != null ) {
					 m_FirstRowIdx = DTM.NULL;
					 addRowToDTMFromResultSet();
				 }
				 else {
					 Vector parameters = m_QueryParser.getParameters();
					 if ( parameters != null ) {
						 int outParamIdx = addElement(1, m_OutParameter_TypeID, m_SQLIdx, m_RowSetIdx);
						 int lastColID = DTM.NULL;
						 for ( int indx = 0 ;
						 indx < parameters.size() ;
						 indx++ ) {
							 QueryParameter parm = (QueryParameter)parameters.elementAt(indx);
							 if ( parm.isOutput() ) {
								 Object rawobj = ((CallableStatement)m_Statement).getObject(indx + 1);
								 lastColID = addElementWithData(rawobj, 2, m_Col_TypeID, outParamIdx, lastColID);
								 addAttributeToNode(parm.getName(), m_ColAttrib_COLUMN_NAME_TypeID, lastColID);
								 addAttributeToNode(parm.getName(), m_ColAttrib_COLUMN_LABEL_TypeID, lastColID);
								 addAttributeToNode(new Integer(parm.getType()), m_ColAttrib_COLUMN_TYPE_TypeID, lastColID);
								 addAttributeToNode(parm.getTypeName(), m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColID);
							 }
						 }
					 }
					 SQLWarning warn = checkWarnings();
					 if ( warn != null )m_XConnection.setError(null, null, warn);
				 }
				 return false;
			 }
			 if (m_FirstRowIdx == DTM.NULL) {
				 m_FirstRowIdx = addElement(2, m_Row_TypeID, m_RowSetIdx, m_MultipleResults ? m_MetaDataIdx : DTM.NULL);
				 m_LastRowIdx = m_FirstRowIdx;
				 if (m_StreamingMode) {
					 m_nextsib.setElementAt(m_LastRowIdx, m_LastRowIdx);
				 }
			 }
			 else {
				 if (! m_StreamingMode) {
					 m_LastRowIdx = addElement(2, m_Row_TypeID, m_RowSetIdx, m_LastRowIdx);
				 }
			 }
			 int colID = _firstch(m_LastRowIdx);
			 int pcolID = DTM.NULL;
			 for (int i=1;
			 i<= m_ColCount;
			 i++) {
				 Object o = m_ResultSet.getObject(i);
				 if (colID == DTM.NULL) {
					 pcolID = addElementWithData(o,3,m_Col_TypeID, m_LastRowIdx, pcolID);
					 cloneAttributeFromNode(pcolID, m_ColHeadersIdx[i-1]);
				 }
				 else {
					 int dataIdent = _firstch(colID);
					 if (dataIdent == DTM.NULL) {
						 error(""Streaming Mode, Data Error"");
					 }
					 else {
						 m_ObjectArray.setAt(dataIdent, o);
					 }
				 }
				 if (colID != DTM.NULL) {
					 colID = _nextsib(colID);
				 }
			 }
		 }
		 catch(Exception e) {
			 if (DEBUG) {
				 System.out.println( ""SQL Error Fetching next row ["" + e.getLocalizedMessage() + ""]"");
			 }
			 m_XConnection.setError(e, this, checkWarnings());
			 m_HasErrors = true;
		 }
		 return true;
	 }
	 public boolean hasErrors() {
		 return m_HasErrors;
	 }
	 public void close(boolean flushConnPool ) {
		 try {
			 SQLWarning warn = checkWarnings();
			 if ( warn != null ) m_XConnection.setError(null, null, warn);
		 }
		 catch(Exception e) {
		}
		 try {
			 if (null != m_ResultSet) {
				 m_ResultSet.close();
				 m_ResultSet = null;
			 }
		 }
		 catch(Exception e) {
		}
		 Connection conn = null;
		 try {
			 if (null != m_Statement) {
				 conn = m_Statement.getConnection();
				 m_Statement.close();
				 m_Statement = null;
			 }
		 }
		 catch(Exception e) {
		}
		 try {
			 if (conn != null) {
				 if (m_HasErrors) m_ConnectionPool.releaseConnectionOnError(conn);
				 else m_ConnectionPool.releaseConnection(conn);
			 }
		 }
		 catch(Exception e) {
		}
		 getManager().release(this, true);
	 }
	 protected boolean nextNode( ) {
		 if (DEBUG) System.out.println(""nextNode()"");
		 try {
			 return false;
		 }
		 catch(Exception e) {
			 return false;
		 }
	 }
	 protected int _nextsib( int identity ) {
		 if ( m_ResultSet != null ) {
			 int id = _exptype(identity);
			 if (m_FirstRowIdx == DTM.NULL) {
				 addRowToDTMFromResultSet();
			 }
			 if ( ( id == m_Row_TypeID) && (identity >= m_LastRowIdx) ) {
				 if (DEBUG) System.out.println(""reading from the ResultSet"");
				 addRowToDTMFromResultSet();
			 }
			 else if ( m_MultipleResults && identity == m_RowSetIdx ) {
				 if (DEBUG) System.out.println(""reading for next ResultSet"");
				 int startIdx = m_RowSetIdx;
				 while ( startIdx == m_RowSetIdx && m_ResultSet != null ) addRowToDTMFromResultSet();
			 }
		 }
		 return super._nextsib(identity);
	 }
	 public void documentRegistration() {
		 if (DEBUG) System.out.println(""Document Registration"");
	 }
	 public void documentRelease() {
		 if (DEBUG) System.out.println(""Document Release"");
	 }
	 public SQLWarning checkWarnings() {
		 SQLWarning warn = null;
		 if ( m_Statement != null ) {
			 try {
				 warn = m_Statement.getWarnings();
				 m_Statement.clearWarnings();
			 }
			 catch (SQLException se) {
			}
		 }
		 return(warn);
	 }
}",1,0,0,0
"private AttributeSetter createAttributeSetter(final Method m, Class arg, final String attrName) {
	 final Class reflectedArg = PRIMITIVE_TYPE_MAP.containsKey(arg) ? (Class) PRIMITIVE_TYPE_MAP.get(arg) : arg;
	 if (java.lang.Object.class == reflectedArg) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 throw new BuildException( ""Internal ant problem - this should not get called"");
			 }
		 }
		;
	 }
	 if (java.lang.String.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 m.invoke(parent, (Object[]) new String[] {
				value}
				);
			 }
		 }
		;
	 }
	 if (java.lang.Character.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 if (value.length() == 0) {
					 throw new BuildException(""The value \""\"" is not a "" + ""legal value for attribute \"""" + attrName + ""\"""");
				 }
				 m.invoke(parent, (Object[]) new Character[] {
				new Character(value.charAt(0))}
				);
			 }
		 }
		;
	 }
	 if (java.lang.Boolean.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 m.invoke(parent, (Object[]) new Boolean[] {
				 Project.toBoolean(value) ? Boolean.TRUE : Boolean.FALSE }
				);
			 }
		 }
		;
	 }
	 if (java.lang.Class.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 m.invoke(parent, new Object[] {
					Class.forName(value)}
					);
				 }
				 catch (ClassNotFoundException ce) {
					 throw new BuildException(ce);
				 }
			 }
		 }
		;
	 }
	 if (java.io.File.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException {
				 m.invoke(parent, new Object[] {
				p.resolveFile(value)}
				);
			 }
		 }
		;
	 }
	 if (Resource.class.equals(reflectedArg) || FileProvider.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 m.invoke(parent, new Object[] {
				 new FileResource(p, p.resolveFile(value)) }
				);
			 }
			;
		 }
		;
	 }
	 if (EnumeratedAttribute.class.isAssignableFrom(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 EnumeratedAttribute ea = (EnumeratedAttribute) reflectedArg.newInstance();
					 ea.setValue(value);
					 m.invoke(parent, new Object[] {
					ea}
					);
				 }
				 catch (InstantiationException ie) {
					 throw new BuildException(ie);
				 }
			 }
		 }
		;
	 }
	 AttributeSetter setter = getEnumSetter(reflectedArg, m, arg);
	 if (setter != null) {
		 return setter;
	 }
	 if (java.lang.Long.class.equals(reflectedArg)) {
		 return new AttributeSetter(m, arg) {
			 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
				 try {
					 m.invoke(parent, new Object[] {
					 new Long(StringUtils.parseHumanSizes(value)) }
					);
				 }
				 catch (NumberFormatException e) {
					 throw new BuildException(""Can't assign non-numeric"" + "" value '"" + value + ""' to"" + "" attribute "" + attrName);
				 }
				 catch (InvocationTargetException e) {
					 throw e;
				 }
				 catch (IllegalAccessException e) {
					 throw e;
				 }
				 catch (Exception e) {
					 throw new BuildException(e);
				 }
			 }
		 }
		;
	 }
	 boolean includeProject;
	 Constructor c;
	 try {
		 c = reflectedArg.getConstructor(new Class[] {
		Project.class, String.class}
		);
		 includeProject = true;
	 }
	 catch (NoSuchMethodException nme) {
		 try {
			 c = reflectedArg.getConstructor(new Class[] {
			String.class}
			);
			 includeProject = false;
		 }
		 catch (NoSuchMethodException nme2) {
			 return null;
		 }
	 }
	 final boolean finalIncludeProject = includeProject;
	 final Constructor finalConstructor = c;
	 return new AttributeSetter(m, arg) {
		 public void set(Project p, Object parent, String value) throws InvocationTargetException, IllegalAccessException, BuildException {
			 try {
				 Object[] args = finalIncludeProject ? new Object[] {
				p, value}
				 : new Object[] {
				value}
				;
				 Object attribute = finalConstructor.newInstance(args);
				 if (p != null) {
					 p.setProjectReference(attribute);
				 }
				 m.invoke(parent, new Object[] {
				attribute}
				);
			 }
			 catch (InvocationTargetException e) {
				 Throwable cause = e.getCause();
				 if (cause instanceof IllegalArgumentException) {
					 throw new BuildException(""Can't assign value '"" + value + ""' to attribute "" + attrName + "", reason: "" + cause.getClass() + "" with message '"" + cause.getMessage() + ""'"");
				 }
				 throw e;
			 }
			 catch (InstantiationException ie) {
				 throw new BuildException(ie);
			 }
		 }
	 }
	;
 }",0,0,1,0
"protected class ValueIterable implements Iterable<VALUEIN> {
	 private ValueIterator iterator = new ValueIterator();
	 public Iterator<VALUEIN> iterator() {
		 return iterator;
	 }
 }",0,1,0,0
"class TrueTypeFont extends BaseFont {
	 static final String codePages[] = {
		 ""1252 Latin 1"", ""1250 Latin 2: Eastern Europe"", ""1251 Cyrillic"", ""1253 Greek"", ""1254 Turkish"", ""1255 Hebrew"", ""1256 Arabic"", ""1257 Windows Baltic"", ""1258 Vietnamese"", null, null, null, null, null, null, null, ""874 Thai"", ""932 JIS/Japan"", ""936 Chinese: Simplified chars--PRC and Singapore"", ""949 Korean Wansung"", ""950 Chinese: Traditional chars--Taiwan and Hong Kong"", ""1361 Korean Johab"", null, null, null, null, null, null, null, ""Macintosh Character Set (US Roman)"", ""OEM Character Set"", ""Symbol Character Set"", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, ""869 IBM Greek"", ""866 MS-DOS Russian"", ""865 MS-DOS Nordic"", ""864 Arabic"", ""863 MS-DOS Canadian French"", ""862 Hebrew"", ""861 MS-DOS Icelandic"", ""860 MS-DOS Portuguese"", ""857 IBM Turkish"", ""855 IBM Cyrillic;
		 primarily Russian"", ""852 Latin 2"", ""775 MS-DOS Baltic"", ""737 Greek;
		 former 437 G"", ""708 Arabic;
	 ASMO 708"", ""850 WE/Latin 1"", ""437 US""}
	;
	 protected boolean justNames = false;
	 protected HashMap<String, int[]> tables;
	 protected RandomAccessFileOrArray rf;
	 protected String fileName;
	 protected boolean cff = false;
	 protected int cffOffset;
	 protected int cffLength;
	 protected int directoryOffset;
	 protected String ttcIndex;
	 protected String style = """";
	 protected FontHeader head = new FontHeader();
	 protected HorizontalHeader hhea = new HorizontalHeader();
	 protected WindowsMetrics os_2 = new WindowsMetrics();
	 protected int GlyphWidths[];
	 protected int bboxes[][];
	 protected HashMap<Integer, int[]> cmap10;
	 protected HashMap<Integer, int[]> cmap31;
	 protected HashMap<Integer, int[]> cmapExt;
	 protected IntHashtable kerning = new IntHashtable();
	 protected String fontName;
	 protected String fullName[][];
	 protected String allNameEntries[][];
	 protected String familyName[][];
	 protected double italicAngle;
	 protected boolean isFixedPitch = false;
	 protected int underlinePosition;
	 protected int underlineThickness;
	 protected static class FontHeader {
		 int flags;
		 int unitsPerEm;
		 short xMin;
		 short yMin;
		 short xMax;
		 short yMax;
		 int macStyle;
	 }
	 protected static class HorizontalHeader {
		 short Ascender;
		 short Descender;
		 short LineGap;
		 int advanceWidthMax;
		 short minLeftSideBearing;
		 short minRightSideBearing;
		 short xMaxExtent;
		 short caretSlopeRise;
		 short caretSlopeRun;
		 int numberOfHMetrics;
	 }
	 protected static class WindowsMetrics {
		 short xAvgCharWidth;
		 int usWeightClass;
		 int usWidthClass;
		 short fsType;
		 short ySubscriptXSize;
		 short ySubscriptYSize;
		 short ySubscriptXOffset;
		 short ySubscriptYOffset;
		 short ySuperscriptXSize;
		 short ySuperscriptYSize;
		 short ySuperscriptXOffset;
		 short ySuperscriptYOffset;
		 short yStrikeoutSize;
		 short yStrikeoutPosition;
		 short sFamilyClass;
		 byte panose[] = new byte[10];
		 byte achVendID[] = new byte[4];
		 int fsSelection;
		 int usFirstCharIndex;
		 int usLastCharIndex;
		 short sTypoAscender;
		 short sTypoDescender;
		 short sTypoLineGap;
		 int usWinAscent;
		 int usWinDescent;
		 int ulCodePageRange1;
		 int ulCodePageRange2;
		 int sCapHeight;
	 }
	 protected TrueTypeFont() {
	 }
	 TrueTypeFont(String ttFile, String enc, boolean emb, byte ttfAfm[], boolean justNames, boolean forceRead) throws DocumentException, IOException {
		 this.justNames = justNames;
		 String nameBase = getBaseName(ttFile);
		 String ttcName = getTTCName(nameBase);
		 if (nameBase.length() < ttFile.length()) {
			 style = ttFile.substring(nameBase.length());
		 }
		 encoding = enc;
		 embedded = emb;
		 fileName = ttcName;
		 fontType = FONT_TYPE_TT;
		 ttcIndex = """";
		 if (ttcName.length() < nameBase.length()) ttcIndex = nameBase.substring(ttcName.length() + 1);
		 if (fileName.toLowerCase().endsWith("".ttf"") || fileName.toLowerCase().endsWith("".otf"") || fileName.toLowerCase().endsWith("".ttc"")) {
			 process(ttfAfm, forceRead);
			 if (!justNames && embedded && os_2.fsType == 2) throw new DocumentException(MessageLocalization.getComposedMessage(""1.cannot.be.embedded.due.to.licensing.restrictions"", fileName + style));
		 }
		 else throw new DocumentException(MessageLocalization.getComposedMessage(""1.is.not.a.ttf.otf.or.ttc.font.file"", fileName + style));
		 if (!encoding.startsWith(""#"")) PdfEncodings.convertToBytes("" "", enc);
		 createEncoding();
	 }
	 protected static String getTTCName(String name) {
		 int idx = name.toLowerCase().indexOf("".ttc,"");
		 if (idx < 0) return name;
		 else return name.substring(0, idx + 4);
	 }
	 void fillTables() throws DocumentException, IOException {
		 int table_location[];
		 table_location = tables.get(""head"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""head"", fileName + style));
		 rf.seek(table_location[0] + 16);
		 head.flags = rf.readUnsignedShort();
		 head.unitsPerEm = rf.readUnsignedShort();
		 rf.skipBytes(16);
		 head.xMin = rf.readShort();
		 head.yMin = rf.readShort();
		 head.xMax = rf.readShort();
		 head.yMax = rf.readShort();
		 head.macStyle = rf.readUnsignedShort();
		 table_location = tables.get(""hhea"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""hhea"", fileName + style));
		 rf.seek(table_location[0] + 4);
		 hhea.Ascender = rf.readShort();
		 hhea.Descender = rf.readShort();
		 hhea.LineGap = rf.readShort();
		 hhea.advanceWidthMax = rf.readUnsignedShort();
		 hhea.minLeftSideBearing = rf.readShort();
		 hhea.minRightSideBearing = rf.readShort();
		 hhea.xMaxExtent = rf.readShort();
		 hhea.caretSlopeRise = rf.readShort();
		 hhea.caretSlopeRun = rf.readShort();
		 rf.skipBytes(12);
		 hhea.numberOfHMetrics = rf.readUnsignedShort();
		 table_location = tables.get(""OS/2"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""OS/2"", fileName + style));
		 rf.seek(table_location[0]);
		 int version = rf.readUnsignedShort();
		 os_2.xAvgCharWidth = rf.readShort();
		 os_2.usWeightClass = rf.readUnsignedShort();
		 os_2.usWidthClass = rf.readUnsignedShort();
		 os_2.fsType = rf.readShort();
		 os_2.ySubscriptXSize = rf.readShort();
		 os_2.ySubscriptYSize = rf.readShort();
		 os_2.ySubscriptXOffset = rf.readShort();
		 os_2.ySubscriptYOffset = rf.readShort();
		 os_2.ySuperscriptXSize = rf.readShort();
		 os_2.ySuperscriptYSize = rf.readShort();
		 os_2.ySuperscriptXOffset = rf.readShort();
		 os_2.ySuperscriptYOffset = rf.readShort();
		 os_2.yStrikeoutSize = rf.readShort();
		 os_2.yStrikeoutPosition = rf.readShort();
		 os_2.sFamilyClass = rf.readShort();
		 rf.readFully(os_2.panose);
		 rf.skipBytes(16);
		 rf.readFully(os_2.achVendID);
		 os_2.fsSelection = rf.readUnsignedShort();
		 os_2.usFirstCharIndex = rf.readUnsignedShort();
		 os_2.usLastCharIndex = rf.readUnsignedShort();
		 os_2.sTypoAscender = rf.readShort();
		 os_2.sTypoDescender = rf.readShort();
		 if (os_2.sTypoDescender > 0) os_2.sTypoDescender = (short)-os_2.sTypoDescender;
		 os_2.sTypoLineGap = rf.readShort();
		 os_2.usWinAscent = rf.readUnsignedShort();
		 os_2.usWinDescent = rf.readUnsignedShort();
		 os_2.ulCodePageRange1 = 0;
		 os_2.ulCodePageRange2 = 0;
		 if (version > 0) {
			 os_2.ulCodePageRange1 = rf.readInt();
			 os_2.ulCodePageRange2 = rf.readInt();
		 }
		 if (version > 1) {
			 rf.skipBytes(2);
			 os_2.sCapHeight = rf.readShort();
		 }
		 else os_2.sCapHeight = (int)(0.7 * head.unitsPerEm);
		 table_location = tables.get(""post"");
		 if (table_location == null) {
			 italicAngle = -Math.atan2(hhea.caretSlopeRun, hhea.caretSlopeRise) * 180 / Math.PI;
			 return;
		 }
		 rf.seek(table_location[0] + 4);
		 short mantissa = rf.readShort();
		 int fraction = rf.readUnsignedShort();
		 italicAngle = mantissa + fraction / 16384.0d;
		 underlinePosition = rf.readShort();
		 underlineThickness = rf.readShort();
		 isFixedPitch = rf.readInt() != 0;
	 }
	 String getBaseFont() throws DocumentException, IOException {
		 int table_location[];
		 table_location = tables.get(""name"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""name"", fileName + style));
		 rf.seek(table_location[0] + 2);
		 int numRecords = rf.readUnsignedShort();
		 int startOfStorage = rf.readUnsignedShort();
		 for (int k = 0;
		 k < numRecords;
		 ++k) {
			 int platformID = rf.readUnsignedShort();
			 int platformEncodingID = rf.readUnsignedShort();
			 int languageID = rf.readUnsignedShort();
			 int nameID = rf.readUnsignedShort();
			 int length = rf.readUnsignedShort();
			 int offset = rf.readUnsignedShort();
			 if (nameID == 6) {
				 rf.seek(table_location[0] + startOfStorage + offset);
				 if (platformID == 0 || platformID == 3) return readUnicodeString(length);
				 else return readStandardString(length);
			 }
		 }
		 File file = new File(fileName);
		 return file.getName().replace(' ', '-');
	 }
	 String[][] getNames(int id) throws DocumentException, IOException {
		 int table_location[];
		 table_location = tables.get(""name"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""name"", fileName + style));
		 rf.seek(table_location[0] + 2);
		 int numRecords = rf.readUnsignedShort();
		 int startOfStorage = rf.readUnsignedShort();
		 ArrayList<String[]> names = new ArrayList<String[]>();
		 for (int k = 0;
		 k < numRecords;
		 ++k) {
			 int platformID = rf.readUnsignedShort();
			 int platformEncodingID = rf.readUnsignedShort();
			 int languageID = rf.readUnsignedShort();
			 int nameID = rf.readUnsignedShort();
			 int length = rf.readUnsignedShort();
			 int offset = rf.readUnsignedShort();
			 if (nameID == id) {
				 int pos = rf.getFilePointer();
				 rf.seek(table_location[0] + startOfStorage + offset);
				 String name;
				 if (platformID == 0 || platformID == 3 || platformID == 2 && platformEncodingID == 1){
					 name = readUnicodeString(length);
				 }
				 else {
					 name = readStandardString(length);
				 }
				 names.add(new String[]{
				String.valueOf(platformID), String.valueOf(platformEncodingID), String.valueOf(languageID), name}
				);
				 rf.seek(pos);
			 }
		 }
		 String thisName[][] = new String[names.size()][];
		 for (int k = 0;
		 k < names.size();
		 ++k) thisName[k] = names.get(k);
		 return thisName;
	 }
	 String[][] getAllNames() throws DocumentException, IOException {
		 int table_location[];
		 table_location = tables.get(""name"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""name"", fileName + style));
		 rf.seek(table_location[0] + 2);
		 int numRecords = rf.readUnsignedShort();
		 int startOfStorage = rf.readUnsignedShort();
		 ArrayList<String[]> names = new ArrayList<String[]>();
		 for (int k = 0;
		 k < numRecords;
		 ++k) {
			 int platformID = rf.readUnsignedShort();
			 int platformEncodingID = rf.readUnsignedShort();
			 int languageID = rf.readUnsignedShort();
			 int nameID = rf.readUnsignedShort();
			 int length = rf.readUnsignedShort();
			 int offset = rf.readUnsignedShort();
			 int pos = rf.getFilePointer();
			 rf.seek(table_location[0] + startOfStorage + offset);
			 String name;
			 if (platformID == 0 || platformID == 3 || platformID == 2 && platformEncodingID == 1){
				 name = readUnicodeString(length);
			 }
			 else {
				 name = readStandardString(length);
			 }
			 names.add(new String[]{
			String.valueOf(nameID), String.valueOf(platformID), String.valueOf(platformEncodingID), String.valueOf(languageID), name}
			);
			 rf.seek(pos);
		 }
		 String thisName[][] = new String[names.size()][];
		 for (int k = 0;
		 k < names.size();
		 ++k) thisName[k] = names.get(k);
		 return thisName;
	 }
	 void checkCff() {
		 int table_location[];
		 table_location = tables.get(""CFF "");
		 if (table_location != null) {
			 cff = true;
			 cffOffset = table_location[0];
			 cffLength = table_location[1];
		 }
	 }
	 void process(byte ttfAfm[], boolean preload) throws DocumentException, IOException {
		 tables = new HashMap<String, int[]>();
		 try {
			 if (ttfAfm == null) rf = new RandomAccessFileOrArray(fileName, preload, Document.plainRandomAccess);
			 else rf = new RandomAccessFileOrArray(ttfAfm);
			 if (ttcIndex.length() > 0) {
				 int dirIdx = Integer.parseInt(ttcIndex);
				 if (dirIdx < 0) throw new DocumentException(MessageLocalization.getComposedMessage(""the.font.index.for.1.must.be.positive"", fileName));
				 String mainTag = readStandardString(4);
				 if (!mainTag.equals(""ttcf"")) throw new DocumentException(MessageLocalization.getComposedMessage(""1.is.not.a.valid.ttc.file"", fileName));
				 rf.skipBytes(4);
				 int dirCount = rf.readInt();
				 if (dirIdx >= dirCount) throw new DocumentException(MessageLocalization.getComposedMessage(""the.font.index.for.1.must.be.between.0.and.2.it.was.3"", fileName, String.valueOf(dirCount - 1), String.valueOf(dirIdx)));
				 rf.skipBytes(dirIdx * 4);
				 directoryOffset = rf.readInt();
			 }
			 rf.seek(directoryOffset);
			 int ttId = rf.readInt();
			 if (ttId != 0x00010000 && ttId != 0x4F54544F) throw new DocumentException(MessageLocalization.getComposedMessage(""1.is.not.a.valid.ttf.or.otf.file"", fileName));
			 int num_tables = rf.readUnsignedShort();
			 rf.skipBytes(6);
			 for (int k = 0;
			 k < num_tables;
			 ++k) {
				 String tag = readStandardString(4);
				 rf.skipBytes(4);
				 int table_location[] = new int[2];
				 table_location[0] = rf.readInt();
				 table_location[1] = rf.readInt();
				 tables.put(tag, table_location);
			 }
			 checkCff();
			 fontName = getBaseFont();
			 fullName = getNames(4);
			 familyName = getNames(1);
			 allNameEntries = getAllNames();
			 if (!justNames) {
				 fillTables();
				 readGlyphWidths();
				 readCMaps();
				 readKerning();
				 readBbox();
				 GlyphWidths = null;
			 }
		 }
		 finally {
			 if (rf != null) {
				 rf.close();
				 if (!embedded) rf = null;
			 }
		 }
	 }
	 protected String readStandardString(int length) throws IOException {
		 byte buf[] = new byte[length];
		 rf.readFully(buf);
		 try {
			 return new String(buf, WINANSI);
		 }
		 catch (Exception e) {
			 throw new ExceptionConverter(e);
		 }
	 }
	 protected String readUnicodeString(int length) throws IOException {
		 StringBuffer buf = new StringBuffer();
		 length /= 2;
		 for (int k = 0;
		 k < length;
		 ++k) {
			 buf.append(rf.readChar());
		 }
		 return buf.toString();
	 }
	 protected void readGlyphWidths() throws DocumentException, IOException {
		 int table_location[];
		 table_location = tables.get(""hmtx"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""hmtx"", fileName + style));
		 rf.seek(table_location[0]);
		 GlyphWidths = new int[hhea.numberOfHMetrics];
		 for (int k = 0;
		 k < hhea.numberOfHMetrics;
		 ++k) {
			 GlyphWidths[k] = rf.readUnsignedShort() * 1000 / head.unitsPerEm;
			 rf.readUnsignedShort();
		 }
	 }
	 protected int getGlyphWidth(int glyph) {
		 if (glyph >= GlyphWidths.length) glyph = GlyphWidths.length - 1;
		 return GlyphWidths[glyph];
	 }
	 private void readBbox() throws DocumentException, IOException {
		 int tableLocation[];
		 tableLocation = tables.get(""head"");
		 if (tableLocation == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""head"", fileName + style));
		 rf.seek(tableLocation[0] + TrueTypeFontSubSet.HEAD_LOCA_FORMAT_OFFSET);
		 boolean locaShortTable = rf.readUnsignedShort() == 0;
		 tableLocation = tables.get(""loca"");
		 if (tableLocation == null) return;
		 rf.seek(tableLocation[0]);
		 int locaTable[];
		 if (locaShortTable) {
			 int entries = tableLocation[1] / 2;
			 locaTable = new int[entries];
			 for (int k = 0;
			 k < entries;
			 ++k) locaTable[k] = rf.readUnsignedShort() * 2;
		 }
		 else {
			 int entries = tableLocation[1] / 4;
			 locaTable = new int[entries];
			 for (int k = 0;
			 k < entries;
			 ++k) locaTable[k] = rf.readInt();
		 }
		 tableLocation = tables.get(""glyf"");
		 if (tableLocation == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""glyf"", fileName + style));
		 int tableGlyphOffset = tableLocation[0];
		 bboxes = new int[locaTable.length - 1][];
		 for (int glyph = 0;
		 glyph < locaTable.length - 1;
		 ++glyph) {
			 int start = locaTable[glyph];
			 if (start != locaTable[glyph + 1]) {
				 rf.seek(tableGlyphOffset + start + 2);
				 bboxes[glyph] = new int[]{
				 rf.readShort() * 1000 / head.unitsPerEm, rf.readShort() * 1000 / head.unitsPerEm, rf.readShort() * 1000 / head.unitsPerEm, rf.readShort() * 1000 / head.unitsPerEm}
				;
			 }
		 }
	 }
	 void readCMaps() throws DocumentException, IOException {
		 int table_location[];
		 table_location = tables.get(""cmap"");
		 if (table_location == null) throw new DocumentException(MessageLocalization.getComposedMessage(""table.1.does.not.exist.in.2"", ""cmap"", fileName + style));
		 rf.seek(table_location[0]);
		 rf.skipBytes(2);
		 int num_tables = rf.readUnsignedShort();
		 fontSpecific = false;
		 int map10 = 0;
		 int map31 = 0;
		 int map30 = 0;
		 int mapExt = 0;
		 for (int k = 0;
		 k < num_tables;
		 ++k) {
			 int platId = rf.readUnsignedShort();
			 int platSpecId = rf.readUnsignedShort();
			 int offset = rf.readInt();
			 if (platId == 3 && platSpecId == 0) {
				 fontSpecific = true;
				 map30 = offset;
			 }
			 else if (platId == 3 && platSpecId == 1) {
				 map31 = offset;
			 }
			 else if (platId == 3 && platSpecId == 10) {
				 mapExt = offset;
			 }
			 if (platId == 1 && platSpecId == 0) {
				 map10 = offset;
			 }
		 }
		 if (map10 > 0) {
			 rf.seek(table_location[0] + map10);
			 int format = rf.readUnsignedShort();
			 switch (format) {
				 case 0: cmap10 = readFormat0();
				 break;
				 case 4: cmap10 = readFormat4();
				 break;
				 case 6: cmap10 = readFormat6();
				 break;
			 }
		 }
		 if (map31 > 0) {
			 rf.seek(table_location[0] + map31);
			 int format = rf.readUnsignedShort();
			 if (format == 4) {
				 cmap31 = readFormat4();
			 }
		 }
		 if (map30 > 0) {
			 rf.seek(table_location[0] + map30);
			 int format = rf.readUnsignedShort();
			 if (format == 4) {
				 cmap10 = readFormat4();
			 }
		 }
		 if (mapExt > 0) {
			 rf.seek(table_location[0] + mapExt);
			 int format = rf.readUnsignedShort();
			 switch (format) {
				 case 0: cmapExt = readFormat0();
				 break;
				 case 4: cmapExt = readFormat4();
				 break;
				 case 6: cmapExt = readFormat6();
				 break;
				 case 12: cmapExt = readFormat12();
				 break;
			 }
		 }
	 }
	 HashMap<Integer, int[]> readFormat12() throws IOException {
		 HashMap<Integer, int[]> h = new HashMap<Integer, int[]>();
		 rf.skipBytes(2);
		 int table_lenght = rf.readInt();
		 rf.skipBytes(4);
		 int nGroups = rf.readInt();
		 for (int k = 0;
		 k < nGroups;
		 k++) {
			 int startCharCode = rf.readInt();
			 int endCharCode = rf.readInt();
			 int startGlyphID = rf.readInt();
			 for (int i = startCharCode;
			 i <= endCharCode;
			 i++) {
				 int[] r = new int[2];
				 r[0] = startGlyphID;
				 r[1] = getGlyphWidth(r[0]);
				 h.put(new Integer(i), r);
				 startGlyphID++;
			 }
		 }
		 return h;
	 }
	 HashMap<Integer, int[]> readFormat0() throws IOException {
		 HashMap<Integer, int[]> h = new HashMap<Integer, int[]>();
		 rf.skipBytes(4);
		 for (int k = 0;
		 k < 256;
		 ++k) {
			 int r[] = new int[2];
			 r[0] = rf.readUnsignedByte();
			 r[1] = getGlyphWidth(r[0]);
			 h.put(new Integer(k), r);
		 }
		 return h;
	 }
	 HashMap<Integer, int[]> readFormat4() throws IOException {
		 HashMap<Integer, int[]> h = new HashMap<Integer, int[]>();
		 int table_lenght = rf.readUnsignedShort();
		 rf.skipBytes(2);
		 int segCount = rf.readUnsignedShort() / 2;
		 rf.skipBytes(6);
		 int endCount[] = new int[segCount];
		 for (int k = 0;
		 k < segCount;
		 ++k) {
			 endCount[k] = rf.readUnsignedShort();
		 }
		 rf.skipBytes(2);
		 int startCount[] = new int[segCount];
		 for (int k = 0;
		 k < segCount;
		 ++k) {
			 startCount[k] = rf.readUnsignedShort();
		 }
		 int idDelta[] = new int[segCount];
		 for (int k = 0;
		 k < segCount;
		 ++k) {
			 idDelta[k] = rf.readUnsignedShort();
		 }
		 int idRO[] = new int[segCount];
		 for (int k = 0;
		 k < segCount;
		 ++k) {
			 idRO[k] = rf.readUnsignedShort();
		 }
		 int glyphId[] = new int[table_lenght / 2 - 8 - segCount * 4];
		 for (int k = 0;
		 k < glyphId.length;
		 ++k) {
			 glyphId[k] = rf.readUnsignedShort();
		 }
		 for (int k = 0;
		 k < segCount;
		 ++k) {
			 int glyph;
			 for (int j = startCount[k];
			 j <= endCount[k] && j != 0xFFFF;
			 ++j) {
				 if (idRO[k] == 0) {
					 glyph = j + idDelta[k] & 0xFFFF;
				 }
				 else {
					 int idx = k + idRO[k] / 2 - segCount + j - startCount[k];
					 if (idx >= glyphId.length) continue;
					 glyph = glyphId[idx] + idDelta[k] & 0xFFFF;
				 }
				 int r[] = new int[2];
				 r[0] = glyph;
				 r[1] = getGlyphWidth(r[0]);
				 h.put(new Integer(fontSpecific ? ((j & 0xff00) == 0xf000 ? j & 0xff : j) : j), r);
			 }
		 }
		 return h;
	 }
	 HashMap<Integer, int[]> readFormat6() throws IOException {
		 HashMap<Integer, int[]> h = new HashMap<Integer, int[]>();
		 rf.skipBytes(4);
		 int start_code = rf.readUnsignedShort();
		 int code_count = rf.readUnsignedShort();
		 for (int k = 0;
		 k < code_count;
		 ++k) {
			 int r[] = new int[2];
			 r[0] = rf.readUnsignedShort();
			 r[1] = getGlyphWidth(r[0]);
			 h.put(new Integer(k + start_code), r);
		 }
		 return h;
	 }
	 void readKerning() throws IOException {
		 int table_location[];
		 table_location = tables.get(""kern"");
		 if (table_location == null) return;
		 rf.seek(table_location[0] + 2);
		 int nTables = rf.readUnsignedShort();
		 int checkpoint = table_location[0] + 4;
		 int length = 0;
		 for (int k = 0;
		 k < nTables;
		 ++k) {
			 checkpoint += length;
			 rf.seek(checkpoint);
			 rf.skipBytes(2);
			 length = rf.readUnsignedShort();
			 int coverage = rf.readUnsignedShort();
			 if ((coverage & 0xfff7) == 0x0001) {
				 int nPairs = rf.readUnsignedShort();
				 rf.skipBytes(6);
				 for (int j = 0;
				 j < nPairs;
				 ++j) {
					 int pair = rf.readInt();
					 int value = rf.readShort() * 1000 / head.unitsPerEm;
					 kerning.put(pair, value);
				 }
			 }
		 }
	 }
	 public int getKerning(int char1, int char2) {
		 int metrics[] = getMetricsTT(char1);
		 if (metrics == null) return 0;
		 int c1 = metrics[0];
		 metrics = getMetricsTT(char2);
		 if (metrics == null) return 0;
		 int c2 = metrics[0];
		 return kerning.get((c1 << 16) + c2);
	 }
	 int getRawWidth(int c, String name) {
		 int[] metric = getMetricsTT(c);
		 if (metric == null) return 0;
		 return metric[1];
	 }
	 protected PdfDictionary getFontDescriptor(PdfIndirectReference fontStream, String subsetPrefix, PdfIndirectReference cidset) {
		 PdfDictionary dic = new PdfDictionary(PdfName.FONTDESCRIPTOR);
		 dic.put(PdfName.ASCENT, new PdfNumber(os_2.sTypoAscender * 1000 / head.unitsPerEm));
		 dic.put(PdfName.CAPHEIGHT, new PdfNumber(os_2.sCapHeight * 1000 / head.unitsPerEm));
		 dic.put(PdfName.DESCENT, new PdfNumber(os_2.sTypoDescender * 1000 / head.unitsPerEm));
		 dic.put(PdfName.FONTBBOX, new PdfRectangle( head.xMin * 1000 / head.unitsPerEm, head.yMin * 1000 / head.unitsPerEm, head.xMax * 1000 / head.unitsPerEm, head.yMax * 1000 / head.unitsPerEm));
		 if (cidset != null) dic.put(PdfName.CIDSET, cidset);
		 if (cff) {
			 if (encoding.startsWith(""Identity-"")) dic.put(PdfName.FONTNAME, new PdfName(subsetPrefix + fontName+""-""+encoding));
			 else dic.put(PdfName.FONTNAME, new PdfName(subsetPrefix + fontName + style));
		 }
		 else dic.put(PdfName.FONTNAME, new PdfName(subsetPrefix + fontName + style));
		 dic.put(PdfName.ITALICANGLE, new PdfNumber(italicAngle));
		 dic.put(PdfName.STEMV, new PdfNumber(80));
		 if (fontStream != null) {
			 if (cff) dic.put(PdfName.FONTFILE3, fontStream);
			 else dic.put(PdfName.FONTFILE2, fontStream);
		 }
		 int flags = 0;
		 if (isFixedPitch) flags |= 1;
		 flags |= fontSpecific ? 4 : 32;
		 if ((head.macStyle & 2) != 0) flags |= 64;
		 if ((head.macStyle & 1) != 0) flags |= 262144;
		 dic.put(PdfName.FLAGS, new PdfNumber(flags));
		 return dic;
	 }
	 protected PdfDictionary getFontBaseType(PdfIndirectReference fontDescriptor, String subsetPrefix, int firstChar, int lastChar, byte shortTag[]) {
		 PdfDictionary dic = new PdfDictionary(PdfName.FONT);
		 if (cff) {
			 dic.put(PdfName.SUBTYPE, PdfName.TYPE1);
			 dic.put(PdfName.BASEFONT, new PdfName(fontName + style));
		 }
		 else {
			 dic.put(PdfName.SUBTYPE, PdfName.TRUETYPE);
			 dic.put(PdfName.BASEFONT, new PdfName(subsetPrefix + fontName + style));
		 }
		 dic.put(PdfName.BASEFONT, new PdfName(subsetPrefix + fontName + style));
		 if (!fontSpecific) {
			 for (int k = firstChar;
			 k <= lastChar;
			 ++k) {
				 if (!differences[k].equals(notdef)) {
					 firstChar = k;
					 break;
				 }
			 }
			 if (encoding.equals(""Cp1252"") || encoding.equals(""MacRoman"")) dic.put(PdfName.ENCODING, encoding.equals(""Cp1252"") ? PdfName.WIN_ANSI_ENCODING : PdfName.MAC_ROMAN_ENCODING);
			 else {
				 PdfDictionary enc = new PdfDictionary(PdfName.ENCODING);
				 PdfArray dif = new PdfArray();
				 boolean gap = true;
				 for (int k = firstChar;
				 k <= lastChar;
				 ++k) {
					 if (shortTag[k] != 0) {
						 if (gap) {
							 dif.add(new PdfNumber(k));
							 gap = false;
						 }
						 dif.add(new PdfName(differences[k]));
					 }
					 else gap = true;
				 }
				 enc.put(PdfName.DIFFERENCES, dif);
				 dic.put(PdfName.ENCODING, enc);
			 }
		 }
		 dic.put(PdfName.FIRSTCHAR, new PdfNumber(firstChar));
		 dic.put(PdfName.LASTCHAR, new PdfNumber(lastChar));
		 PdfArray wd = new PdfArray();
		 for (int k = firstChar;
		 k <= lastChar;
		 ++k) {
			 if (shortTag[k] == 0) wd.add(new PdfNumber(0));
			 else wd.add(new PdfNumber(widths[k]));
		 }
		 dic.put(PdfName.WIDTHS, wd);
		 if (fontDescriptor != null) dic.put(PdfName.FONTDESCRIPTOR, fontDescriptor);
		 return dic;
	 }
	 protected byte[] getFullFont() throws IOException {
		 RandomAccessFileOrArray rf2 = null;
		 try {
			 rf2 = new RandomAccessFileOrArray(rf);
			 rf2.reOpen();
			 byte b[] = new byte[rf2.length()];
			 rf2.readFully(b);
			 return b;
		 }
		 finally {
			 try {
				if (rf2 != null) {
					rf2.close();
				}
			}
			 catch (Exception e) {
			}
		 }
	 }
	 protected static int[] compactRanges(ArrayList<int[]> ranges) {
		 ArrayList<int[]> simp = new ArrayList<int[]>();
		 for (int k = 0;
		 k < ranges.size();
		 ++k) {
			 int[] r = ranges.get(k);
			 for (int j = 0;
			 j < r.length;
			 j += 2) {
				 simp.add(new int[]{
				Math.max(0, Math.min(r[j], r[j + 1])), Math.min(0xffff, Math.max(r[j], r[j + 1]))}
				);
			 }
		 }
		 for (int k1 = 0;
		 k1 < simp.size() - 1;
		 ++k1) {
			 for (int k2 = k1 + 1;
			 k2 < simp.size();
			 ++k2) {
				 int[] r1 = simp.get(k1);
				 int[] r2 = simp.get(k2);
				 if (r1[0] >= r2[0] && r1[0] <= r2[1] || r1[1] >= r2[0] && r1[0] <= r2[1]) {
					 r1[0] = Math.min(r1[0], r2[0]);
					 r1[1] = Math.max(r1[1], r2[1]);
					 simp.remove(k2);
					 --k2;
				 }
			 }
		 }
		 int[] s = new int[simp.size() * 2];
		 for (int k = 0;
		 k < simp.size();
		 ++k) {
			 int[] r = simp.get(k);
			 s[k * 2] = r[0];
			 s[k * 2 + 1] = r[1];
		 }
		 return s;
	 }
	 protected void addRangeUni(HashMap<Integer, int[]> longTag, boolean includeMetrics, boolean subsetp) {
		 if (!subsetp && (subsetRanges != null || directoryOffset > 0)) {
			 int[] rg = subsetRanges == null && directoryOffset > 0 ? new int[]{
			0, 0xffff}
			 : compactRanges(subsetRanges);
			 HashMap<Integer, int[]> usemap;
			 if (!fontSpecific && cmap31 != null) usemap = cmap31;
			 else if (fontSpecific && cmap10 != null) usemap = cmap10;
			 else if (cmap31 != null) usemap = cmap31;
			 else usemap = cmap10;
			 for (Map.Entry<Integer, int[]> e: usemap.entrySet()) {
				 int[] v = e.getValue();
				 Integer gi = new Integer(v[0]);
				 if (longTag.containsKey(gi)) continue;
				 int c = e.getKey().intValue();
				 boolean skip = true;
				 for (int k = 0;
				 k < rg.length;
				 k += 2) {
					 if (c >= rg[k] && c <= rg[k + 1]) {
						 skip = false;
						 break;
					 }
				 }
				 if (!skip) longTag.put(gi, includeMetrics ? new int[]{
				v[0], v[1], c}
				 : null);
			 }
		 }
	 }
	 protected void addRangeUni(HashSet<Integer> longTag, boolean subsetp) {
		 if (!subsetp && (subsetRanges != null || directoryOffset > 0)) {
			 int[] rg = subsetRanges == null && directoryOffset > 0 ? new int[]{
			0, 0xffff}
			 : compactRanges(subsetRanges);
			 HashMap<Integer, int[]> usemap;
			 if (!fontSpecific && cmap31 != null) usemap = cmap31;
			 else if (fontSpecific && cmap10 != null) usemap = cmap10;
			 else if (cmap31 != null) usemap = cmap31;
			 else usemap = cmap10;
			 for (Map.Entry<Integer, int[]> e: usemap.entrySet()) {
				 int[] v = e.getValue();
				 Integer gi = new Integer(v[0]);
				 if (longTag.contains(gi)) continue;
				 int c = e.getKey().intValue();
				 boolean skip = true;
				 for (int k = 0;
				 k < rg.length;
				 k += 2) {
					 if (c >= rg[k] && c <= rg[k + 1]) {
						 skip = false;
						 break;
					 }
				 }
				 if (!skip) longTag.add(gi);
			 }
		 }
	 }
	 void writeFont(PdfWriter writer, PdfIndirectReference ref, Object params[]) throws DocumentException, IOException {
		 int firstChar = ((Integer)params[0]).intValue();
		 int lastChar = ((Integer)params[1]).intValue();
		 byte shortTag[] = (byte[])params[2];
		 boolean subsetp = ((Boolean)params[3]).booleanValue() && subset;
		 if (!subsetp) {
			 firstChar = 0;
			 lastChar = shortTag.length - 1;
			 for (int k = 0;
			 k < shortTag.length;
			 ++k) shortTag[k] = 1;
		 }
		 PdfIndirectReference ind_font = null;
		 PdfObject pobj = null;
		 PdfIndirectObject obj = null;
		 String subsetPrefix = """";
		 if (embedded) {
			 if (cff) {
				 pobj = new StreamFont(readCffFont(), ""Type1C"", compressionLevel);
				 obj = writer.addToBody(pobj);
				 ind_font = obj.getIndirectReference();
			 }
			 else {
				 if (subsetp) subsetPrefix = createSubsetPrefix();
				 HashSet<Integer> glyphs = new HashSet<Integer>();
				 for (int k = firstChar;
				 k <= lastChar;
				 ++k) {
					 if (shortTag[k] != 0) {
						 int[] metrics = null;
						 if (specialMap != null) {
							 int[] cd = GlyphList.nameToUnicode(differences[k]);
							 if (cd != null) metrics = getMetricsTT(cd[0]);
						 }
						 else {
							 if (fontSpecific) metrics = getMetricsTT(k);
							 else metrics = getMetricsTT(unicodeDifferences[k]);
						 }
						 if (metrics != null) glyphs.add(new Integer(metrics[0]));
					 }
				 }
				 addRangeUni(glyphs, subsetp);
				 byte[] b = null;
				 if (subsetp || directoryOffset != 0 || subsetRanges != null) {
					 TrueTypeFontSubSet sb = new TrueTypeFontSubSet(fileName, new RandomAccessFileOrArray(rf), glyphs, directoryOffset, true, !subsetp);
					 b = sb.process();
				 }
				 else {
					 b = getFullFont();
				 }
				 int lengths[] = new int[]{
				b.length}
				;
				 pobj = new StreamFont(b, lengths, compressionLevel);
				 obj = writer.addToBody(pobj);
				 ind_font = obj.getIndirectReference();
			 }
		 }
		 pobj = getFontDescriptor(ind_font, subsetPrefix, null);
		 if (pobj != null){
			 obj = writer.addToBody(pobj);
			 ind_font = obj.getIndirectReference();
		 }
		 pobj = getFontBaseType(ind_font, subsetPrefix, firstChar, lastChar, shortTag);
		 writer.addToBody(pobj, ref);
	 }
	 protected byte[] readCffFont() throws IOException {
		 RandomAccessFileOrArray rf2 = new RandomAccessFileOrArray(rf);
		 byte b[] = new byte[cffLength];
		 try {
			 rf2.reOpen();
			 rf2.seek(cffOffset);
			 rf2.readFully(b);
		 }
		 finally {
			 try {
				 rf2.close();
			 }
			 catch (Exception e) {
			 }
		 }
		 return b;
	 }
	 public PdfStream getFullFontStream() throws IOException, DocumentException {
		 if (cff) {
			 return new StreamFont(readCffFont(), ""Type1C"", compressionLevel);
		 }
		 else {
			 byte[] b = getFullFont();
			 int lengths[] = new int[]{
			b.length}
			;
			 return new StreamFont(b, lengths, compressionLevel);
		 }
	 }
	 public float getFontDescriptor(int key, float fontSize) {
		 switch (key) {
			 case ASCENT: return os_2.sTypoAscender * fontSize / head.unitsPerEm;
			 case CAPHEIGHT: return os_2.sCapHeight * fontSize / head.unitsPerEm;
			 case DESCENT: return os_2.sTypoDescender * fontSize / head.unitsPerEm;
			 case ITALICANGLE: return (float)italicAngle;
			 case BBOXLLX: return fontSize * head.xMin / head.unitsPerEm;
			 case BBOXLLY: return fontSize * head.yMin / head.unitsPerEm;
			 case BBOXURX: return fontSize * head.xMax / head.unitsPerEm;
			 case BBOXURY: return fontSize * head.yMax / head.unitsPerEm;
			 case AWT_ASCENT: return fontSize * hhea.Ascender / head.unitsPerEm;
			 case AWT_DESCENT: return fontSize * hhea.Descender / head.unitsPerEm;
			 case AWT_LEADING: return fontSize * hhea.LineGap / head.unitsPerEm;
			 case AWT_MAXADVANCE: return fontSize * hhea.advanceWidthMax / head.unitsPerEm;
			 case UNDERLINE_POSITION: return (underlinePosition - underlineThickness / 2) * fontSize / head.unitsPerEm;
			 case UNDERLINE_THICKNESS: return underlineThickness * fontSize / head.unitsPerEm;
			 case STRIKETHROUGH_POSITION: return os_2.yStrikeoutPosition * fontSize / head.unitsPerEm;
			 case STRIKETHROUGH_THICKNESS: return os_2.yStrikeoutSize * fontSize / head.unitsPerEm;
			 case SUBSCRIPT_SIZE: return os_2.ySubscriptYSize * fontSize / head.unitsPerEm;
			 case SUBSCRIPT_OFFSET: return -os_2.ySubscriptYOffset * fontSize / head.unitsPerEm;
			 case SUPERSCRIPT_SIZE: return os_2.ySuperscriptYSize * fontSize / head.unitsPerEm;
			 case SUPERSCRIPT_OFFSET: return os_2.ySuperscriptYOffset * fontSize / head.unitsPerEm;
			 case WEIGHT_CLASS: return os_2.usWeightClass;
			 case WIDTH_CLASS: return os_2.usWidthClass;
		 }
		 return 0;
	 }
	 public int[] getMetricsTT(int c) {
		 if (cmapExt != null) return cmapExt.get(new Integer(c));
		 if (!fontSpecific && cmap31 != null) return cmap31.get(new Integer(c));
		 if (fontSpecific && cmap10 != null) return cmap10.get(new Integer(c));
		 if (cmap31 != null) return cmap31.get(new Integer(c));
		 if (cmap10 != null) return cmap10.get(new Integer(c));
		 return null;
	 }
	 public String getPostscriptFontName() {
		 return fontName;
	 }
	 public String[] getCodePagesSupported() {
		 long cp = ((long)os_2.ulCodePageRange2 << 32) + (os_2.ulCodePageRange1 & 0xffffffffL);
		 int count = 0;
		 long bit = 1;
		 for (int k = 0;
		 k < 64;
		 ++k) {
			 if ((cp & bit) != 0 && codePages[k] != null) ++count;
			 bit <<= 1;
		 }
		 String ret[] = new String[count];
		 count = 0;
		 bit = 1;
		 for (int k = 0;
		 k < 64;
		 ++k) {
			 if ((cp & bit) != 0 && codePages[k] != null) ret[count++] = codePages[k];
			 bit <<= 1;
		 }
		 return ret;
	 }
	 public String[][] getFullFontName() {
		 return fullName;
	 }
	 public String[][] getAllNameEntries() {
		 return allNameEntries;
	 }
	 public String[][] getFamilyFontName() {
		 return familyName;
	 }
	 public boolean hasKernPairs() {
		 return kerning.size() > 0;
	 }
	 public void setPostscriptFontName(String name) {
		 fontName = name;
	 }
	 public boolean setKerning(int char1, int char2, int kern) {
		 int metrics[] = getMetricsTT(char1);
		 if (metrics == null) return false;
		 int c1 = metrics[0];
		 metrics = getMetricsTT(char2);
		 if (metrics == null) return false;
		 int c2 = metrics[0];
		 kerning.put((c1 << 16) + c2, kern);
		 return true;
	 }
	 protected int[] getRawCharBBox(int c, String name) {
		 HashMap<Integer, int[]> map = null;
		 if (name == null || cmap31 == null) map = cmap10;
		 else map = cmap31;
		 if (map == null) return null;
		 int metric[] = map.get(new Integer(c));
		 if (metric == null || bboxes == null) return null;
		 return bboxes[metric[0]];
	 }
}",1,0,0,0
"public void executeMain() throws BuildException {
	 checkAttributesAndElements();
	 File renamedFile = null;
	 addingNewFiles = true;
	 processDoUpdate();
	 processGroupFilesets();
	 Vector vfss = new Vector();
	 if (baseDir != null) {
		 FileSet fs = (FileSet) getImplicitFileSet().clone();
		 fs.setDir(baseDir);
		 vfss.addElement(fs);
	 }
	 final int size = resources.size();
	 for (int i = 0;
	 i < size;
	 i++) {
		 ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
		 vfss.addElement(rc);
	 }
	 ResourceCollection[] fss = new ResourceCollection[vfss.size()];
	 vfss.copyInto(fss);
	 boolean success = false;
	 try {
		 ArchiveState state = getResourcesToAdd(fss, zipFile, false);
		 if (!state.isOutOfDate()) {
			 return;
		 }
		 File parent = zipFile.getParentFile();
		 if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
			 throw new BuildException(""Failed to create missing parent"" + "" directory for "" + zipFile);
		 }
		 updatedFile = true;
		 if (!zipFile.exists() && state.isWithoutAnyResources()) {
			 createEmptyZip(zipFile);
			 return;
		 }
		 Resource[][] addThem = state.getResourcesToAdd();
		 if (doUpdate) {
			 renamedFile = renameFile();
		 }
		 String action = doUpdate ? ""Updating "" : ""Building "";
		 if (!skipWriting) {
			 log(action + archiveType + "": "" + zipFile.getAbsolutePath());
		 }
		 ZipOutputStream zOut = null;
		 try {
			 if (!skipWriting) {
				 zOut = new ZipOutputStream(zipFile);
				 zOut.setEncoding(encoding);
				 zOut.setUseLanguageEncodingFlag(useLanguageEncodingFlag);
				 zOut.setCreateUnicodeExtraFields(createUnicodeExtraFields. getPolicy());
				 zOut.setFallbackToUTF8(fallBackToUTF8);
				 zOut.setMethod(doCompress ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
				 zOut.setLevel(level);
			 }
			 initZipOutputStream(zOut);
			 for (int i = 0;
			 i < fss.length;
			 i++) {
				 if (addThem[i].length != 0) {
					 addResources(fss[i], addThem[i], zOut);
				 }
			 }
			 if (doUpdate) {
				 addingNewFiles = false;
				 ZipFileSet oldFiles = new ZipFileSet();
				 oldFiles.setProject(getProject());
				 oldFiles.setSrc(renamedFile);
				 oldFiles.setDefaultexcludes(false);
				 final int addSize = addedFiles.size();
				 for (int i = 0;
				 i < addSize;
				 i++) {
					 PatternSet.NameEntry ne = oldFiles.createExclude();
					 ne.setName((String) addedFiles.elementAt(i));
				 }
				 DirectoryScanner ds = oldFiles.getDirectoryScanner(getProject());
				 ((ZipScanner) ds).setEncoding(encoding);
				 String[] f = ds.getIncludedFiles();
				 Resource[] r = new Resource[f.length];
				 for (int i = 0;
				 i < f.length;
				 i++) {
					 r[i] = ds.getResource(f[i]);
				 }
				 if (!doFilesonly) {
					 String[] d = ds.getIncludedDirectories();
					 Resource[] dr = new Resource[d.length];
					 for (int i = 0;
					 i < d.length;
					 i++) {
						 dr[i] = ds.getResource(d[i]);
					 }
					 Resource[] tmp = r;
					 r = new Resource[tmp.length + dr.length];
					 System.arraycopy(dr, 0, r, 0, dr.length);
					 System.arraycopy(tmp, 0, r, dr.length, tmp.length);
				 }
				 addResources(oldFiles, r, zOut);
			 }
			 if (zOut != null) {
				 zOut.setComment(comment);
			 }
			 finalizeZipOutputStream(zOut);
			 if (doUpdate) {
				 if (!renamedFile.delete()) {
					 log (""Warning: unable to delete temporary file "" + renamedFile.getName(), Project.MSG_WARN);
				 }
			 }
			 success = true;
		 }
		 finally {
			 closeZout(zOut, success);
		 }
	 }
	 catch (IOException ioe) {
		 String msg = ""Problem creating "" + archiveType + "": "" + ioe.getMessage();
		 if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
			 msg += "" (and the archive is probably corrupt but I could not "" + ""delete it)"";
		 }
		 if (doUpdate && renamedFile != null) {
			 try {
				 FILE_UTILS.rename(renamedFile, zipFile);
			 }
			 catch (IOException e) {
				 msg += "" (and I couldn't rename the temporary file "" + renamedFile.getName() + "" back)"";
			 }
		 }
		 throw new BuildException(msg, ioe, getLocation());
	 }
	 finally {
		 cleanUp();
	 }
 }",0,0,1,0
"public static CqlResult process(String queryString, ClientState clientState) throws RecognitionException, UnavailableException, InvalidRequestException, TimedOutException, SchemaDisagreementException {
	 logger.trace(""CQL QUERY: {
	}
	"", queryString);
	 return processStatement(getStatement(queryString, clientState).statement, clientState, Collections.<ByteBuffer>emptyList());
 }",0,0,0,0
"class TestStreamEvaluatorFactory implements TransformEvaluatorFactory {
	 private final EvaluationContext evaluationContext;
	 TestStreamEvaluatorFactory(EvaluationContext evaluationContext) {
		 this.evaluationContext = evaluationContext;
	 }
	 public <InputT> TransformEvaluator<InputT> forApplication( AppliedPTransform<?, ?, ?> application, CommittedBundle<?> inputBundle) {
		 return createEvaluator((AppliedPTransform) application);
	 }
	 public void cleanup() throws Exception {
	}
	 private <InputT, OutputT> TransformEvaluator<? super InputT> createEvaluator( AppliedPTransform<PBegin, PCollection<OutputT>, TestStream<OutputT>> application) {
		 return (TransformEvaluator<InputT>) new Evaluator<>(application, evaluationContext);
	 }
	 private static class Evaluator<T> implements TransformEvaluator<TestStreamIndex<T>> {
		 private final AppliedPTransform<PBegin, PCollection<T>, TestStream<T>> application;
		 private final EvaluationContext context;
		 private final StepTransformResult.Builder resultBuilder;
		 private Evaluator( AppliedPTransform<PBegin, PCollection<T>, TestStream<T>> application, EvaluationContext context) {
			 this.application = application;
			 this.context = context;
			 this.resultBuilder = StepTransformResult.withoutHold(application);
		 }
		 public void processElement(WindowedValue<TestStreamIndex<T>> element) throws Exception {
			 TestStreamIndex<T> streamIndex = element.getValue();
			 List<Event<T>> events = streamIndex.getTestStream().getEvents();
			 int index = streamIndex.getIndex();
			 Instant watermark = element.getTimestamp();
			 Event<T> event = events.get(index);
			 if (event.getType().equals(EventType.ELEMENT)) {
				 UncommittedBundle<T> bundle = context.createBundle( (PCollection<T>) Iterables.getOnlyElement(application.getOutputs().values()));
				 for (TimestampedValue<T> elem : ((ElementEvent<T>) event).getElements()) {
					 bundle.add( WindowedValue.timestampedValueInGlobalWindow(elem.getValue(), elem.getTimestamp()));
				 }
				 resultBuilder.addOutput(bundle);
			 }
			 if (event.getType().equals(EventType.WATERMARK)) {
				 watermark = ((WatermarkEvent<T>) event).getWatermark();
			 }
			 if (event.getType().equals(EventType.PROCESSING_TIME)) {
				 ((TestClock) context.getClock()) .advance(((ProcessingTimeEvent<T>) event).getProcessingTimeAdvance());
			 }
			 TestStreamIndex<T> next = streamIndex.next();
			 if (next.getIndex() < events.size()) {
				 resultBuilder.addUnprocessedElements( Collections.singleton(WindowedValue.timestampedValueInGlobalWindow(next, watermark)));
			 }
		 }
		 public TransformResult<TestStreamIndex<T>> finishBundle() throws Exception {
			 return resultBuilder.build();
		 }
	 }
	 static class TestClock implements Clock {
		 private final AtomicReference<Instant> currentTime = new AtomicReference<>(BoundedWindow.TIMESTAMP_MIN_VALUE);
		 public void advance(Duration amount) {
			 Instant now = currentTime.get();
			 currentTime.compareAndSet(now, now.plus(amount));
		 }
		 public Instant now() {
			 return currentTime.get();
		 }
	 }
	 private static class TestClockSupplier implements Supplier<Clock> {
		 public Clock get() {
			 return new TestClock();
		 }
	 }
	 static class DirectTestStreamFactory<T> implements PTransformOverrideFactory< PBegin, PCollection<T>, PTransform<PBegin, PCollection<T>>> {
		 private final DirectRunner runner;
		 DirectTestStreamFactory(DirectRunner runner) {
			 this.runner = runner;
		 }
		 public PTransformReplacement<PBegin, PCollection<T>> getReplacementTransform( AppliedPTransform<PBegin, PCollection<T>, PTransform<PBegin, PCollection<T>>> transform) {
			 try {
				 return PTransformReplacement.of( transform.getPipeline().begin(), new DirectTestStream<>(runner, TestStreamTranslation.getTestStream(transform)));
			 }
			 catch (IOException exc) {
				 throw new RuntimeException( String.format( ""Transform could not be converted to %s"", TestStream.class.getSimpleName()), exc);
			 }
		 }
		 public Map<PValue, ReplacementOutput> mapOutputs( Map<TupleTag<?>, PValue> outputs, PCollection<T> newOutput) {
			 return ReplacementOutputs.singleton(outputs, newOutput);
		 }
		 static final String DIRECT_TEST_STREAM_URN = ""urn:beam:directrunner:transforms:test_stream:v1"";
		 static class DirectTestStream<T> extends PTransform<PBegin, PCollection<T>> {
			 private final transient DirectRunner runner;
			 private final TestStream<T> original;
			 DirectTestStream(DirectRunner runner, TestStream<T> transform) {
				 this.runner = runner;
				 this.original = transform;
			 }
			 public PCollection<T> expand(PBegin input) {
				 runner.setClockSupplier(new TestClockSupplier());
				 return PCollection.createPrimitiveOutputInternal( input.getPipeline(), WindowingStrategy.globalDefault(), IsBounded.UNBOUNDED, original.getValueCoder());
			 }
		 }
	 }
	 static class InputProvider<T> implements RootInputProvider<T, TestStreamIndex<T>, PBegin> {
		 private final EvaluationContext evaluationContext;
		 InputProvider(EvaluationContext evaluationContext) {
			 this.evaluationContext = evaluationContext;
		 }
		 public Collection<CommittedBundle<TestStreamIndex<T>>> getInitialInputs( AppliedPTransform<PBegin, PCollection<T>, PTransform<PBegin, PCollection<T>>> transform, int targetParallelism) {
			 DirectTestStreamFactory.DirectTestStream<T> testStream = (DirectTestStreamFactory.DirectTestStream<T>) transform.getTransform();
			 CommittedBundle<TestStreamIndex<T>> initialBundle = evaluationContext .<TestStreamIndex<T>>createRootBundle() .add(WindowedValue.valueInGlobalWindow(TestStreamIndex.of(testStream.original))) .commit(BoundedWindow.TIMESTAMP_MAX_VALUE);
			 return Collections.singleton(initialBundle);
		 }
	 }
	 abstract static class TestStreamIndex<T> {
		 static <T> TestStreamIndex<T> of(TestStream<T> stream) {
			 return new AutoValue_TestStreamEvaluatorFactory_TestStreamIndex<>(stream, 0);
		 }
		 abstract TestStream<T> getTestStream();
		 abstract int getIndex();
		 TestStreamIndex<T> next() {
			 return new AutoValue_TestStreamEvaluatorFactory_TestStreamIndex<>( getTestStream(), getIndex() + 1);
		 }
	 }
}",0,0,0,0
"public static final class StoreConstantOp extends MemOp implements SPARCTailDelayedLIRInstruction {
	 public static final LIRInstructionClass<StoreConstantOp> TYPE = LIRInstructionClass.create(StoreConstantOp.class);
	 public static final SizeEstimate SIZE = SizeEstimate.create(2);
	 protected final JavaConstant input;
	 public StoreConstantOp(PlatformKind kind, SPARCAddressValue address, JavaConstant input, LIRFrameState state) {
		 super(TYPE, SIZE, kind, address, state);
		 this.input = input;
		 if (!input.isDefaultForKind()) {
			 throw GraalError.shouldNotReachHere(""Can only store null constants to memory"");
		 }
	 }
	 public void emitMemAccess(CompilationResultBuilder crb, SPARCMacroAssembler masm) {
		 try (ScratchRegister sc = masm.getScratchRegister()) {
			 Register scratch = sc.getRegister();
			 SPARCAddress addr = generateSimm13OffsetLoad(address.toAddress(), masm, scratch);
			 getDelayedControlTransfer().emitControlTransfer(crb, masm);
			 if (state != null) {
				 crb.recordImplicitException(masm.position(), state);
			 }
			 int byteCount = kind.getSizeInBytes();
			 masm.st(g0, addr, byteCount);
		 }
	 }
 }",0,0,0,0
"public abstract class ArchiveScanner extends DirectoryScanner {
	 protected File srcFile;
	 private Resource src;
	 private Resource lastScannedResource;
	 private TreeMap fileEntries = new TreeMap();
	 private TreeMap dirEntries = new TreeMap();
	 private TreeMap matchFileEntries = new TreeMap();
	 private TreeMap matchDirEntries = new TreeMap();
	 private String encoding;
	 private boolean errorOnMissingArchive = true;
	 public void setErrorOnMissingArchive(boolean errorOnMissingArchive) {
		 this.errorOnMissingArchive = errorOnMissingArchive;
	 }
	 public void scan() {
		 if (src == null || (!src.isExists() && !errorOnMissingArchive)) {
			 return;
		 }
		 super.scan();
	 }
	 public void setSrc(File srcFile) {
		 setSrc(new FileResource(srcFile));
	 }
	 public void setSrc(Resource src) {
		 this.src = src;
		 FileProvider fp = (FileProvider) src.as(FileProvider.class);
		 if (fp != null) {
			 srcFile = fp.getFile();
		 }
	 }
	 public void setEncoding(String encoding) {
		 this.encoding = encoding;
	 }
	 public String[] getIncludedFiles() {
		 if (src == null) {
			 return super.getIncludedFiles();
		 }
		 scanme();
		 Set s = matchFileEntries.keySet();
		 return (String[]) (s.toArray(new String[s.size()]));
	 }
	 public int getIncludedFilesCount() {
		 if (src == null) {
			 return super.getIncludedFilesCount();
		 }
		 scanme();
		 return matchFileEntries.size();
	 }
	 public String[] getIncludedDirectories() {
		 if (src == null) {
			 return super.getIncludedDirectories();
		 }
		 scanme();
		 Set s = matchDirEntries.keySet();
		 return (String[]) (s.toArray(new String[s.size()]));
	 }
	 public int getIncludedDirsCount() {
		 if (src == null) {
			 return super.getIncludedDirsCount();
		 }
		 scanme();
		 return matchDirEntries.size();
	 }
	 Iterator getResourceFiles(Project project) {
		 if (src == null) {
			 return new FileResourceIterator(project, getBasedir(), getIncludedFiles());
		 }
		 scanme();
		 return matchFileEntries.values().iterator();
	 }
	 Iterator getResourceDirectories(Project project) {
		 if (src == null) {
			 return new FileResourceIterator(project, getBasedir(), getIncludedDirectories());
		 }
		 scanme();
		 return matchDirEntries.values().iterator();
	 }
	 public void init() {
		 if (includes == null) {
			 includes = new String[1];
			 includes[0] = ""**"";
		 }
		 if (excludes == null) {
			 excludes = new String[0];
		 }
	 }
	 public boolean match(String path) {
		 String vpath = path.replace('/', File.separatorChar). replace('\\', File.separatorChar);
		 return isIncluded(vpath) && !isExcluded(vpath);
	 }
	 public Resource getResource(String name) {
		 if (src == null) {
			 return super.getResource(name);
		 }
		 if (name.equals("""")) {
			 return new Resource("""", true, Long.MAX_VALUE, true);
		 }
		 scanme();
		 if (fileEntries.containsKey(name)) {
			 return (Resource) fileEntries.get(name);
		 }
		 name = trimSeparator(name);
		 if (dirEntries.containsKey(name)) {
			 return (Resource) dirEntries.get(name);
		 }
		 return new Resource(name);
	 }
	 protected abstract void fillMapsFromArchive(Resource archive, String encoding, Map fileEntries, Map matchFileEntries, Map dirEntries, Map matchDirEntries);
	 private void scanme() {
		 if (!src.isExists() && !errorOnMissingArchive) {
			 return;
		 }
		 Resource thisresource = new Resource(src.getName(), src.isExists(), src.getLastModified());
		 if (lastScannedResource != null && lastScannedResource.getName().equals(thisresource.getName()) && lastScannedResource.getLastModified() == thisresource.getLastModified()) {
			 return;
		 }
		 init();
		 fileEntries.clear();
		 dirEntries.clear();
		 matchFileEntries.clear();
		 matchDirEntries.clear();
		 fillMapsFromArchive(src, encoding, fileEntries, matchFileEntries, dirEntries, matchDirEntries);
		 lastScannedResource = thisresource;
	 }
	 protected static final String trimSeparator(String s) {
		 return s.endsWith(""/"") ? s.substring(0, s.length() - 1) : s;
	 }
}",0,0,0,0
"public class JJDoc extends Task {
	 private static final String OUTPUT_FILE = ""OUTPUT_FILE"";
	 private static final String TEXT = ""TEXT"";
	 private static final String ONE_TABLE = ""ONE_TABLE"";
	 private final Hashtable optionalAttrs = new Hashtable();
	 private String outputFile = null;
	 private boolean plainText = false;
	 private static final String DEFAULT_SUFFIX_HTML = "".html"";
	 private static final String DEFAULT_SUFFIX_TEXT = "".txt"";
	 private File targetFile = null;
	 private File javaccHome = null;
	 private CommandlineJava cmdl = new CommandlineJava();
	 private String maxMemory = null;
	 public void setText(boolean plainText) {
		 optionalAttrs.put(TEXT, plainText ? Boolean.TRUE : Boolean.FALSE);
		 this.plainText = plainText;
	 }
	 public void setOnetable(boolean oneTable) {
		 optionalAttrs.put(ONE_TABLE, oneTable ? Boolean.TRUE : Boolean.FALSE);
	 }
	 public void setOutputfile(String outputFile) {
		 this.outputFile = outputFile;
	 }
	 public void setTarget(File target) {
		 this.targetFile = target;
	 }
	 public void setJavacchome(File javaccHome) {
		 this.javaccHome = javaccHome;
	 }
	 public void setMaxmemory(String max) {
		 maxMemory = max;
	 }
	 public JJDoc() {
		 cmdl.setVm(JavaEnvUtils.getJreExecutable(""java""));
	 }
	 public void execute() throws BuildException {
		 Enumeration iter = optionalAttrs.keys();
		 while (iter.hasMoreElements()) {
			 String name = (String) iter.nextElement();
			 Object value = optionalAttrs.get(name);
			 cmdl.createArgument() .setValue(""-"" + name + "":"" + value.toString());
		 }
		 if (targetFile == null || !targetFile.isFile()) {
			 throw new BuildException(""Invalid target: "" + targetFile);
		 }
		 if (outputFile != null) {
			 cmdl.createArgument() .setValue(""-"" + OUTPUT_FILE + "":"" + outputFile.replace('\\', '/'));
		 }
		 File javaFile = new File(createOutputFileName(targetFile, outputFile, plainText));
		 if (javaFile.exists() && targetFile.lastModified() < javaFile.lastModified()) {
			 log(""Target is already built - skipping ("" + targetFile + "")"", Project.MSG_VERBOSE);
			 return;
		 }
		 cmdl.createArgument().setValue(targetFile.getAbsolutePath());
		 final Path classpath = cmdl.createClasspath(getProject());
		 final File javaccJar = JavaCC.getArchiveFile(javaccHome);
		 classpath.createPathElement().setPath(javaccJar.getAbsolutePath());
		 classpath.addJavaRuntime();
		 cmdl.setClassname(JavaCC.getMainClass(classpath, JavaCC.TASKDEF_TYPE_JJDOC));
		 cmdl.setMaxmemory(maxMemory);
		 final Commandline.Argument arg = cmdl.createVmArgument();
		 arg.setValue(""-Dinstall.root="" + javaccHome.getAbsolutePath());
		 final Execute process = new Execute(new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_INFO), null);
		 log(cmdl.describeCommand(), Project.MSG_VERBOSE);
		 process.setCommandline(cmdl.getCommandline());
		 try {
			 if (process.execute() != 0) {
				 throw new BuildException(""JJDoc failed."");
			 }
		 }
		 catch (IOException e) {
			 throw new BuildException(""Failed to launch JJDoc"", e);
		 }
	 }
	 private String createOutputFileName(File destFile, String optionalOutputFile, boolean plain) {
		 String suffix = DEFAULT_SUFFIX_HTML;
		 String javaccFile = destFile.getAbsolutePath().replace('\\', '/');
		 if (plain) {
			 suffix = DEFAULT_SUFFIX_TEXT;
		 }
		 if ((optionalOutputFile == null) || optionalOutputFile.equals("""")) {
			 int filePos = javaccFile.lastIndexOf(""/"");
			 if (filePos >= 0) {
				 javaccFile = javaccFile.substring(filePos + 1);
			 }
			 int suffixPos = javaccFile.lastIndexOf('.');
			 if (suffixPos == -1) {
				 optionalOutputFile = javaccFile + suffix;
			 }
			 else {
				 String currentSuffix = javaccFile.substring(suffixPos);
				 if (currentSuffix.equals(suffix)) {
					 optionalOutputFile = javaccFile + suffix;
				 }
				 else {
					 optionalOutputFile = javaccFile.substring(0, suffixPos) + suffix;
				 }
			 }
		 }
		 else {
			 optionalOutputFile = optionalOutputFile.replace('\\', '/');
		 }
		 return (getProject().getBaseDir() + ""/"" + optionalOutputFile) .replace('\\', '/');
	 }
}",0,0,0,0
"public class GraphZoomScrollPaneDemo {
	 DirectedSparseGraph<String, Number> graph;
	 VisualizationViewer<String, Number> vv;
	 public GraphZoomScrollPaneDemo() {
		 graph = new DirectedSparseGraph<String, Number>();
		 String[] v = createVertices(10);
		 createEdges(v);
		 ImageIcon sandstoneIcon = null;
		 String imageLocation = ""/images/Sandstone.jpg"";
		 try {
			 sandstoneIcon = new ImageIcon(getClass().getResource(imageLocation));
		 }
		 catch(Exception ex) {
			 System.err.println(""Can't load \""""+imageLocation+""\"""");
		 }
		 final ImageIcon icon = sandstoneIcon;
		 vv = new VisualizationViewer<String,Number>(new KKLayout<String,Number>(graph));
		 if(icon != null) {
			 vv.addPreRenderPaintable(new VisualizationViewer.Paintable(){
				 public void paint(Graphics g) {
					 Dimension d = vv.getSize();
					 g.drawImage(icon.getImage(),0,0,d.width,d.height,vv);
				 }
				 public boolean useTransform() {
					 return false;
				 }
			 }
			);
		 }
		 vv.addPostRenderPaintable(new VisualizationViewer.Paintable(){
			 int x;
			 int y;
			 Font font;
			 FontMetrics metrics;
			 int swidth;
			 int sheight;
			 String str = ""GraphZoomScrollPane Demo"";
			 public void paint(Graphics g) {
				 Dimension d = vv.getSize();
				 if(font == null) {
					 font = new Font(g.getFont().getName(), Font.BOLD, 30);
					 metrics = g.getFontMetrics(font);
					 swidth = metrics.stringWidth(str);
					 sheight = metrics.getMaxAscent()+metrics.getMaxDescent();
					 x = (d.width-swidth)/2;
					 y = (int)(d.height-sheight*1.5);
				 }
				 g.setFont(font);
				 Color oldColor = g.getColor();
				 g.setColor(Color.lightGray);
				 g.drawString(str, x, y);
				 g.setColor(oldColor);
			 }
			 public boolean useTransform() {
				 return false;
			 }
		 }
		);
		 vv.addGraphMouseListener(new TestGraphMouseListener<String>());
		 vv.getRenderer().setVertexRenderer( new GradientVertexRenderer<String,Number>( Color.white, Color.red, Color.white, Color.blue, vv.getPickedVertexState(), false));
		 vv.getRenderContext().setEdgeDrawPaintTransformer(new ConstantTransformer(Color.lightGray));
		 vv.getRenderContext().setArrowFillPaintTransformer(new ConstantTransformer(Color.lightGray));
		 vv.getRenderContext().setArrowDrawPaintTransformer(new ConstantTransformer(Color.lightGray));
		 vv.setVertexToolTipTransformer(new ToStringLabeller<String>());
		 vv.setEdgeToolTipTransformer(new Transformer<Number,String>() {
			public String transform(Number edge) {
				return ""E""+graph.getEndpoints(edge).toString();
			}
		}
		);
		 vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller<String>());
		 vv.getRenderer().getVertexLabelRenderer().setPositioner(new InsidePositioner());
		 vv.getRenderer().getVertexLabelRenderer().setPosition(Renderer.VertexLabel.Position.AUTO);
		 vv.setForeground(Color.lightGray);
		 final JFrame frame = new JFrame();
		 Container content = frame.getContentPane();
		 final GraphZoomScrollPane panel = new GraphZoomScrollPane(vv);
		 content.add(panel);
		 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		 final AbstractModalGraphMouse graphMouse = new DefaultModalGraphMouse<String,Number>();
		 vv.setGraphMouse(graphMouse);
		 vv.addKeyListener(graphMouse.getModeKeyListener());
		 vv.setToolTipText(""<html><center>Type 'p' for Pick mode<p>Type 't' for Transform mode"");
		 final ScalingControl scaler = new CrossoverScalingControl();
		 JButton plus = new JButton(""+"");
		 plus.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 scaler.scale(vv, 1.1f, vv.getCenter());
			 }
		 }
		);
		 JButton minus = new JButton(""-"");
		 minus.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 scaler.scale(vv, 1/1.1f, vv.getCenter());
			 }
		 }
		);
		 JButton reset = new JButton(""reset"");
		 reset.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.LAYOUT).setToIdentity();
				vv.getRenderContext().getMultiLayerTransformer().getTransformer(Layer.VIEW).setToIdentity();
			}
		}
		);
		 JPanel controls = new JPanel();
		 controls.add(plus);
		 controls.add(minus);
		 controls.add(reset);
		 content.add(controls, BorderLayout.SOUTH);
		 frame.pack();
		 frame.setVisible(true);
	 }
	 private String[] createVertices(int count) {
		 String[] v = new String[count];
		 for (int i = 0;
		 i < count;
		 i++) {
			 v[i] = ""V""+i;
			 graph.addVertex(v[i]);
		 }
		 return v;
	 }
	 void createEdges(String[] v) {
		 graph.addEdge(new Double(Math.random()), v[0], v[1], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[0], v[3], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[0], v[4], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[4], v[5], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[3], v[5], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[1], v[2], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[1], v[4], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[8], v[2], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[3], v[8], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[6], v[7], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[7], v[5], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[0], v[9], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[9], v[8], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[7], v[6], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[6], v[5], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[4], v[2], EdgeType.DIRECTED);
		 graph.addEdge(new Double(Math.random()), v[5], v[4], EdgeType.DIRECTED);
	 }
	 static class TestGraphMouseListener<V> implements GraphMouseListener<V> {
		 public void graphClicked(V v, MouseEvent me) {
			 System.err.println(""Vertex ""+v+"" was clicked at (""+me.getX()+"",""+me.getY()+"")"");
		 }
		 public void graphPressed(V v, MouseEvent me) {
			 System.err.println(""Vertex ""+v+"" was pressed at (""+me.getX()+"",""+me.getY()+"")"");
		 }
		 public void graphReleased(V v, MouseEvent me) {
			 System.err.println(""Vertex ""+v+"" was released at (""+me.getX()+"",""+me.getY()+"")"");
		 }
	 }
	 public static void main(String[] args) {
		 new GraphZoomScrollPaneDemo();
	 }
}",0,1,0,0
"public class SQLPredicateVisitor implements PredicateVisitor {
	 private final StringBuilder stringBuilder = new StringBuilder();
	 public void acceptComparisonPredicate(ComparisonPredicate predicate) {
		 String propertyId = predicate.getPropertyId();
		 String propertyCategory = PropertyHelper.getPropertyCategory(propertyId);
		 if (propertyCategory != null) {
			 stringBuilder.append(propertyCategory).append(""."");
		 }
		 stringBuilder.append(PropertyHelper.getPropertyName(propertyId));
		 stringBuilder.append("" "").append(predicate.getOperator()).append("" \"""");
		 stringBuilder.append(predicate.getValue());
		 stringBuilder.append(""\"""");
	 }
	 public void acceptArrayPredicate(ArrayPredicate predicate) {
		 Predicate[] predicates = predicate.getPredicates();
		 if (predicates.length > 0) {
			 stringBuilder.append(""("");
			 for (int i = 0;
			 i < predicates.length;
			 i++) {
				 if (i > 0) {
					 stringBuilder.append("" "").append(predicate.getOperator()).append("" "");
				 }
				 PredicateHelper.visit(predicates[i], this);
			 }
			 stringBuilder.append("")"");
		 }
	 }
	 public void acceptUnaryPredicate(UnaryPredicate predicate) {
		 stringBuilder.append(predicate.getOperator()).append(""("");
		 PredicateHelper.visit(predicate.getPredicate(), this);
		 stringBuilder.append("")"");
	 }
	 public void acceptAlwaysPredicate(AlwaysPredicate predicate) {
		 stringBuilder.append(""TRUE"");
	 }
	 public void acceptCategoryPredicate(CategoryPredicate predicate) {
	 }
	 public String getSQL() {
		 return stringBuilder.toString();
	 }
}",0,0,0,0
"public void connect() throws IOException {
	try {
		int port = _url.getPort();
		String portStr = (port == 80 || port == 443) ? """" : "":"" + port;
		requestHeaders.setValue(""host"", _url.getHost() + portStr);
		Socket sock = KeepAliveConnectionCache.getInstance().getReusableSocket(_url.getHost(), _url.getPort());
		boolean reusing = false;
		if (sock == null) {
			Logger.log(""Creating new socket"");
			this.socket = createSocket();
		}
		 else {
			reusing = true;
			Logger.log(""Reusing existing socket"");
			this.socket = sock;
		}
		OutputStream sockOut = socket.getOutputStream();
		InputStream sockIn = socket.getInputStream();
		String reqLine = ""GET "" + _url.getPathAndQuery() + "" HTTP/1.1"";
		StringBuffer reqBuf = new StringBuffer();
		reqBuf.append(reqLine + ""\r\n"");
		requestHeaders.appendToBuffer(reqBuf);
		reqBuf.append(""\r\n"");
		Logger.log(""Sending request:\n"" + reqBuf);
		sockOut.write(StringUtils.getBytes(reqBuf));
		sockOut.flush();
		statusLine = NetUtils.readLine(sockIn);
		String[] arr = statusLine.split("" "");
		this.statusCode = Integer.parseInt(arr[1].trim());
		if (arr.length > 2) {
			this.statusMessage = arr[2].trim();
		}
		 else {
			this.statusMessage = """";
		}
		Logger.log(statusLine);
		responseHeaders.loadFromStream(sockIn);
		length = NetUtils.getContentLength(responseHeaders);
		in = new FixedRangeInputStream(NetUtils.getInputStream(responseHeaders, socket.getInputStream()), length);
		StringBuffer b2 = new StringBuffer();
		responseHeaders.appendToBuffer(b2);
		if (reusing) {
			Logger.log(""Socket reuse successfull"");
		}
		Logger.log(b2);
		keepAliveSupported = !""close"".equals(responseHeaders.getValue(""connection""));
	}
	 catch (HostUnreachableException e) {
		e.printStackTrace();
		throw new NetworkException(""Unable to connect to server"");
	}
	 catch (Exception e) {
		e.printStackTrace();
		throw new NetworkException(e.getMessage());
	}
}",0,0,1,0
"public class FileObjectFacade implements javax.tools.FileObject {
	 protected FileObject f;
	 public FileObjectFacade(FileObject f) {
		 this.f = f;
	 }
	 public boolean delete() {
		 return f.delete();
	 }
	 public CharSequence getCharContent(boolean arg0) throws IOException {
		 return f.getCharContent(arg0);
	 }
	 public long getLastModified() {
		 return f.getLastModified();
	 }
	 public String getName() {
		 return f.getName();
	 }
	 public InputStream openInputStream() throws IOException {
		 return f.openInputStream();
	 }
	 public OutputStream openOutputStream() throws IOException {
		 return f.openOutputStream();
	 }
	 public Reader openReader(boolean arg0) throws IOException {
		 return f.openReader(arg0);
	 }
	 public Writer openWriter() throws IOException {
		 return f.openWriter();
	 }
	 public URI toUri() {
		 return f.toUri();
	 }
	 public boolean equals(Object obj) {
		 if(obj instanceof FileObjectFacade == false) return false;
		 return f.equals(((FileObjectFacade)obj).f);
	 }
	 public int hashCode() {
		 return f.hashCode();
	 }
	 public String toString() {
		 return f.toString();
	 }
}",0,0,0,0
"public void execute() throws BuildException {
	 File savedFile = file;
	 File savedDestFile = destFile;
	 File savedDestDir = destDir;
	 ResourceCollection savedRc = null;
	 if (file == null && destFile != null && rcs.size() == 1) {
		 savedRc = (ResourceCollection) rcs.elementAt(0);
	 }
	 try {
		 try {
			 validateAttributes();
		 }
		 catch (BuildException e) {
			 if (failonerror || !getMessage(e) .equals(MSG_WHEN_COPYING_EMPTY_RC_TO_FILE)) {
				 throw e;
			 }
			 else {
				 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
				 return;
			 }
		 }
		 copySingleFile();
		 HashMap filesByBasedir = new HashMap();
		 HashMap dirsByBasedir = new HashMap();
		 HashSet baseDirs = new HashSet();
		 ArrayList nonFileResources = new ArrayList();
		 final int size = rcs.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 ResourceCollection rc = (ResourceCollection) rcs.elementAt(i);
			 if (rc instanceof FileSet && rc.isFilesystemOnly()) {
				 FileSet fs = (FileSet) rc;
				 DirectoryScanner ds = null;
				 try {
					 ds = fs.getDirectoryScanner(getProject());
				 }
				 catch (BuildException e) {
					 if (failonerror || !getMessage(e).endsWith(DirectoryScanner .DOES_NOT_EXIST_POSTFIX)) {
						 throw e;
					 }
					 else {
						 if (!quiet) {
							 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
						 }
						 continue;
					 }
				 }
				 File fromDir = fs.getDir(getProject());
				 String[] srcFiles = ds.getIncludedFiles();
				 String[] srcDirs = ds.getIncludedDirectories();
				 if (!flatten && mapperElement == null && ds.isEverythingIncluded() && !fs.hasPatterns()) {
					 completeDirMap.put(fromDir, destDir);
				 }
				 add(fromDir, srcFiles, filesByBasedir);
				 add(fromDir, srcDirs, dirsByBasedir);
				 baseDirs.add(fromDir);
			 }
			 else {
				 if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
					 throw new BuildException( ""Only FileSystem resources are supported."");
				 }
				 Iterator resources = rc.iterator();
				 while (resources.hasNext()) {
					 Resource r = (Resource) resources.next();
					 if (!r.isExists()) {
						 String message = ""Warning: Could not find resource "" + r.toLongString() + "" to copy."";
						 if (!failonerror) {
							 if (!quiet) {
								 log(message, Project.MSG_ERR);
							 }
						 }
						 else {
							 throw new BuildException(message);
						 }
						 continue;
					 }
					 File baseDir = NULL_FILE_PLACEHOLDER;
					 String name = r.getName();
					 FileProvider fp = (FileProvider) r.as(FileProvider.class);
					 if (fp != null) {
						 FileResource fr = ResourceUtils.asFileResource(fp);
						 baseDir = getKeyFile(fr.getBaseDir());
						 if (fr.getBaseDir() == null) {
							 name = fr.getFile().getAbsolutePath();
						 }
					 }
					 if (r.isDirectory() || fp != null) {
						 add(baseDir, name, r.isDirectory() ? dirsByBasedir : filesByBasedir);
						 baseDirs.add(baseDir);
					 }
					 else {
						 nonFileResources.add(r);
					 }
				 }
			 }
		 }
		 iterateOverBaseDirs(baseDirs, dirsByBasedir, filesByBasedir);
		 try {
			 doFileOperations();
		 }
		 catch (BuildException e) {
			 if (!failonerror) {
				 if (!quiet) {
					 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
				 }
			 }
			 else {
				 throw e;
			 }
		 }
		 if (nonFileResources.size() > 0 || singleResource != null) {
			 Resource[] nonFiles = (Resource[]) nonFileResources.toArray(new Resource[nonFileResources.size()]);
			 Map map = scan(nonFiles, destDir);
			 if (singleResource != null) {
				 map.put(singleResource, new String[] {
				 destFile.getAbsolutePath() }
				);
			 }
			 try {
				 doResourceOperations(map);
			 }
			 catch (BuildException e) {
				 if (!failonerror) {
					 if (!quiet) {
						 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
					 }
				 }
				 else {
					 throw e;
				 }
			 }
		 }
	 }
	 finally {
		 singleResource = null;
		 file = savedFile;
		 destFile = savedDestFile;
		 destDir = savedDestDir;
		 if (savedRc != null) {
			 rcs.insertElementAt(savedRc, 0);
		 }
		 fileCopyMap.clear();
		 dirCopyMap.clear();
		 completeDirMap.clear();
	 }
 }",0,0,1,0
"static String replaceOneOccurrence(String oldStr, String searchStr, String newStr, int instanceNumber);",0,0,0,1
"public final String getAjaxRegionMarkupId(){
	String markupId = null;
	for (IBehavior behavior : getBehaviors()){
		if (behavior instanceof IAjaxRegionMarkupIdProvider){
			markupId = ((IAjaxRegionMarkupIdProvider)behavior).getAjaxRegionMarkupId(this);
		}
	}
	if (markupId == null){
		if (this instanceof IAjaxRegionMarkupIdProvider){
			markupId = ((IAjaxRegionMarkupIdProvider)this).getAjaxRegionMarkupId(this);
		}
	}
	if (markupId == null){
		markupId = getMarkupId();
	}
	return markupId;
}",0,0,0,0
"public class RealmTO implements EntityTO, TemplatableTO {
	 private static final long serialVersionUID = 516330662956254391L;
	 private String key;
	 private String name;
	 private String parent;
	 private String fullPath;
	 private String accountPolicy;
	 private String passwordPolicy;
	 private final List<String> actions = new ArrayList<>();
	 private final Map<String, AnyTO> templates = new HashMap<>();
	 private final Set<String> resources = new HashSet<>();
	 public String getKey() {
		 return key;
	 }
	 public void setKey(final String key) {
		 this.key = key;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(final String name) {
		 this.name = name;
	 }
	 public String getParent() {
		 return parent;
	 }
	 public void setParent(final String parent) {
		 this.parent = parent;
	 }
	 public String getFullPath() {
		 return fullPath;
	 }
	 public void setFullPath(final String fullPath) {
		 this.fullPath = fullPath;
	 }
	 public String getAccountPolicy() {
		 return accountPolicy;
	 }
	 public void setAccountPolicy(final String accountPolicy) {
		 this.accountPolicy = accountPolicy;
	 }
	 public String getPasswordPolicy() {
		 return passwordPolicy;
	 }
	 public void setPasswordPolicy(final String passwordPolicy) {
		 this.passwordPolicy = passwordPolicy;
	 }
	 public List<String> getActions() {
		 return actions;
	 }
	 public Map<String, AnyTO> getTemplates() {
		 return templates;
	 }
	 public Set<String> getResources() {
		 return resources;
	 }
}",0,1,0,0
"public void setClasspath(Path classpath) {
	 if (isReference()) {
		 throw tooManyAttributes();
	 }
	 if (this.classpath == null) {
		 this.classpath = classpath;
	 }
	 else {
		 this.classpath.append(classpath);
	 }
 }",0,0,0,0
"public interface DedicatedService extends PluggableService {
	 DedicatePodResponse createDedicatePodResponse(DedicatedResources resource);
	 DedicateClusterResponse createDedicateClusterResponse(DedicatedResources resource);
	 DedicateHostResponse createDedicateHostResponse(DedicatedResources resource);
	 Pair<List<? extends DedicatedResourceVO>, Integer> listDedicatedPods(ListDedicatedPodsCmd cmd);
	 Pair<List<? extends DedicatedResourceVO>, Integer> listDedicatedHosts(ListDedicatedHostsCmd cmd);
	 Pair<List<? extends DedicatedResourceVO>, Integer> listDedicatedClusters(ListDedicatedClustersCmd cmd);
	 boolean releaseDedicatedResource(Long zoneId, Long podId, Long clusterId, Long hostId);
	 DedicateZoneResponse createDedicateZoneResponse(DedicatedResources resource);
	 Pair<List<? extends DedicatedResourceVO>, Integer> listDedicatedZones(ListDedicatedZonesCmd cmd);
	 List<DedicatedResourceVO> dedicateZone(Long zoneId, Long domainId, String accountName);
	 List<DedicatedResourceVO> dedicatePod(Long podId, Long domainId, String accountName);
	 List<DedicatedResourceVO> dedicateCluster(Long clusterId, Long domainId, String accountName);
	 List<DedicatedResourceVO> dedicateHost(Long hostId, Long domainId, String accountName);
}",1,0,0,0
"void setStackMap(StackMapTable_attribute attr) {
	 if (attr == null) {
		 map = null;
		 return;
	 }
	 Method m = classWriter.getMethod();
	 Descriptor d = m.descriptor;
	 String[] args;
	 try {
		 ConstantPool cp = classWriter.getClassFile().constant_pool;
		 String argString = d.getParameterTypes(cp);
		 args = argString.substring(1, argString.length() - 1).split(""[, ]+"");
	 }
	 catch (ConstantPoolException | InvalidDescriptor e) {
		 return;
	 }
	 boolean isStatic = m.access_flags.is(AccessFlags.ACC_STATIC);
	 verification_type_info[] initialLocals = new verification_type_info[(isStatic ? 0 : 1) + args.length];
	 if (!isStatic) initialLocals[0] = new CustomVerificationTypeInfo(""this"");
	 for (int i = 0;
	 i < args.length;
	 i++) {
		 initialLocals[(isStatic ? 0 : 1) + i] = new CustomVerificationTypeInfo(args[i].replace(""."", ""/""));
	 }
	 map = new HashMap<>();
	 StackMapBuilder builder = new StackMapBuilder();
	 int pc = -1;
	 map.put(pc, new StackMap(initialLocals, empty));
	 for (int i = 0;
	 i < attr.entries.length;
	 i++) pc = attr.entries[i].accept(builder, pc);
 }",0,0,1,0
"public class FeedbackMessage implements IClusterable, IDetachable{
	private static final long serialVersionUID = 1L;
	public static final int DEBUG = 100;
	public static final int ERROR = 400;
	public static final int FATAL = 500;
	public static final int INFO = 200;
	public static final int UNDEFINED = 0;
	public static final int WARNING = 300;
	private static final Map<Integer, String> levelStrings = new HashMap<Integer, String>();
	static{
		levelStrings.put(new Integer(0), ""UNDEFINED"");
		levelStrings.put(new Integer(100), ""DEBUG"");
		levelStrings.put(new Integer(200), ""INFO"");
		levelStrings.put(new Integer(300), ""WARNING"");
		levelStrings.put(new Integer(400), ""ERROR"");
		levelStrings.put(new Integer(500), ""FATAL"");
	}
	private final int level;
	private final Serializable message;
	private Component reporter;
	private boolean rendered = false;
	public FeedbackMessage(final Component reporter, final Serializable message, final int level){
		if (message == null){
			throw new IllegalArgumentException(""Parameter message can't be null"");
		}
		this.reporter = reporter;
		this.message = message;
		this.level = level;
	}
	public final boolean isRendered(){
		return rendered;
	}
	public final void markRendered(){
		rendered = true;
	}
	public final int getLevel(){
		return level;
	}
	public String getLevelAsString(){
		return levelStrings.get(new Integer(getLevel()));
	}
	public final Serializable getMessage(){
		return message;
	}
	public final Component getReporter(){
		return reporter;
	}
	public final boolean isDebug(){
		return isLevel(DEBUG);
	}
	public final boolean isError(){
		return isLevel(ERROR);
	}
	public final boolean isFatal(){
		return isLevel(FATAL);
	}
	public final boolean isInfo(){
		return isLevel(INFO);
	}
	public final boolean isLevel(int level){
		return (getLevel() >= level);
	}
	public final boolean isUndefined(){
		return (getLevel() == UNDEFINED);
	}
	public final boolean isWarning(){
		return isLevel(WARNING);
	}
	public String toString(){
		return ""[FeedbackMessage message = \"""" + getMessage() + ""\"", reporter = "" +((getReporter() == null) ? ""null"" : getReporter().getId()) + "", level = "" +getLevelAsString() + ""]"";
	}
	public void detach(){
		reporter = null;
	}
}",0,0,0,0
"public class BeanIOIterator implements Iterator<Object>, Closeable {
	 private BeanReader reader;
	 private transient Object next;
	 private transient Object forceNext;
	 public BeanIOIterator(BeanReader reader) {
		 this.reader = reader;
		 this.next = next();
	 }
	 public void close() throws IOException {
		 if (reader != null) {
			 reader.close();
			 reader = null;
		 }
	 }
	 public boolean hasNext() {
		 return next != null;
	 }
	 public Object next() {
		 Object answer = next;
		 if (answer == null) {
			 answer = reader.read();
			 if (forceNext != null) {
				 answer = forceNext;
				 forceNext = null;
			 }
		 }
		 else {
			 next = reader.read();
			 if (forceNext != null) {
				 next = forceNext;
				 forceNext = null;
			 }
		 }
		 return answer;
	 }
	 public void remove() {
	 }
	 public void setNext(Object next) {
		 this.forceNext = next;
	 }
}",0,1,0,0
"public void setFormat(boolean format) {
	 this.format = format;
 }",0,0,0,0
"public class PTransformReplacements {
	 public static <T> PCollection<T> getSingletonMainInput( AppliedPTransform<? extends PCollection<? extends T>, ?, ?> application) {
		 return getSingletonMainInput( application.getInputs(), application.getTransform().getAdditionalInputs().keySet());
	 }
	 private static <T> PCollection<T> getSingletonMainInput( Map<TupleTag<?>, PValue> inputs, Set<TupleTag<?>> ignoredTags) {
		 PCollection<T> mainInput = null;
		 for (Map.Entry<TupleTag<?>, PValue> input : inputs.entrySet()) {
			 if (!ignoredTags.contains(input.getKey())) {
				 checkArgument( mainInput == null, ""Got multiple inputs that are not additional inputs for a "" + ""singleton main input: %s and %s"", mainInput, input.getValue());
				 checkArgument( input.getValue() instanceof PCollection, ""Unexpected input type %s"", input.getValue().getClass());
				 mainInput = (PCollection<T>) input.getValue();
			 }
		 }
		 checkArgument( mainInput != null, ""No main input found in inputs: Inputs %s, Side Input tags %s"", inputs, ignoredTags);
		 return mainInput;
	 }
	 public static <T> PCollection<T> getSingletonMainOutput( AppliedPTransform<?, PCollection<T>, ? extends PTransform<?, PCollection<T>>> transform) {
		 return (PCollection<T>) Iterables.getOnlyElement(transform.getOutputs().values());
	 }
}",1,0,0,0
"public class JobTracker implements MRConstants, InterTrackerProtocol, JobSubmissionProtocol {
	 static long JOBINIT_SLEEP_INTERVAL = 2000;
	 static long RETIRE_JOB_INTERVAL;
	 static long RETIRE_JOB_CHECK_INTERVAL;
	 static float TASK_ALLOC_EPSILON;
	 static float PAD_FRACTION;
	 static final int MIN_CLUSTER_SIZE_FOR_PADDING = 3;
	 private static NumberFormat idFormat = NumberFormat.getInstance();
	 static {
		 idFormat.setMinimumIntegerDigits(4);
		 idFormat.setGroupingUsed(false);
	 }
	 private int nextJobId = 1;
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.mapred.JobTracker"");
	 private static JobTracker tracker = null;
	 private static boolean runTracker = true;
	 public static void startTracker(Configuration conf) throws IOException {
		 if (tracker != null) throw new IOException(""JobTracker already running."");
		 runTracker = true;
		 while (runTracker) {
			 try {
				 tracker = new JobTracker(conf);
				 break;
			 }
			 catch (IOException e) {
				 LOG.warn(""Starting tracker"", e);
			 }
			 try {
				 Thread.sleep(1000);
			 }
			 catch (InterruptedException e) {
			 }
		 }
		 if (runTracker) {
			 tracker.offerService();
		 }
	 }
	 public static JobTracker getTracker() {
		 return tracker;
	 }
	 public static void stopTracker() throws IOException {
		 if (tracker == null) throw new IOException(""Trying to stop JobTracker that is not running."");
		 runTracker = false;
		 tracker.close();
		 tracker = null;
	 }
	 public long getProtocolVersion(String protocol, long clientVersion) {
		 if (protocol.equals(InterTrackerProtocol.class.getName())) {
			 return InterTrackerProtocol.versionID;
		 }
		 else {
			 return JobSubmissionProtocol.versionID;
		 }
	 }
	 private class ExpireLaunchingTasks implements Runnable {
		 private volatile boolean shouldRun = true;
		 private Map launchingTasks = new LinkedHashMap();
		 public void run() {
			 try {
				 while (shouldRun) {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL/3);
					 long now = System.currentTimeMillis();
					 LOG.debug(""Starting launching task sweep"");
					 synchronized (JobTracker.this) {
						 synchronized (launchingTasks) {
							 Iterator itr = launchingTasks.entrySet().iterator();
							 while (itr.hasNext()) {
								 Map.Entry pair = (Map.Entry) itr.next();
								 String taskId = (String) pair.getKey();
								 long age = now - ((Long) pair.getValue()).longValue();
								 LOG.info(taskId + "" is "" + age + "" ms debug."");
								 if (age > TASKTRACKER_EXPIRY_INTERVAL) {
									 LOG.info(""Launching task "" + taskId + "" timed out."");
									 TaskInProgress tip = null;
									 tip = (TaskInProgress) taskidToTIPMap.get(taskId);
									 if (tip != null) {
										 JobInProgress job = tip.getJob();
										 String trackerName = getAssignedTracker(taskId);
										 TaskTrackerStatus trackerStatus = getTaskTracker(trackerName);
										 job.failedTask(tip, taskId, ""Error launching task"", trackerStatus.getHost(), trackerName, myMetrics);
									 }
									 itr.remove();
								 }
								 else {
									 break;
								 }
							 }
						 }
					 }
				 }
			 }
			 catch (InterruptedException ie) {
			 }
		 }
		 public void addNewTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.put(taskName, new Long(System.currentTimeMillis()));
			 }
		 }
		 public void removeTask(String taskName) {
			 synchronized (launchingTasks) {
				 launchingTasks.remove(taskName);
			 }
		 }
		 public void stop() {
			 shouldRun = false;
		 }
	 }
	 class ExpireTrackers implements Runnable {
		 boolean shouldRun = true;
		 public ExpireTrackers() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(TASKTRACKER_EXPIRY_INTERVAL / 3);
				 }
				 catch (InterruptedException ie) {
				 }
				 synchronized (taskTrackers) {
					 synchronized (trackerExpiryQueue) {
						 long now = System.currentTimeMillis();
						 TaskTrackerStatus leastRecent = null;
						 while ((trackerExpiryQueue.size() > 0) && ((leastRecent = (TaskTrackerStatus) trackerExpiryQueue.first()) != null) && (now - leastRecent.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL)) {
							 trackerExpiryQueue.remove(leastRecent);
							 String trackerName = leastRecent.getTrackerName();
							 TaskTrackerStatus newProfile = (TaskTrackerStatus) taskTrackers.get(leastRecent.getTrackerName());
							 if (newProfile != null) {
								 if (now - newProfile.getLastSeen() > TASKTRACKER_EXPIRY_INTERVAL) {
									 updateTaskTrackerStatus(trackerName, null);
									 lostTaskTracker(leastRecent.getTrackerName(), leastRecent.getHost());
								 }
								 else {
									 trackerExpiryQueue.add(newProfile);
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 public void stopTracker() {
			 shouldRun = false;
		 }
	 }
	 class RetireJobs implements Runnable {
		 boolean shouldRun = true;
		 public RetireJobs() {
		 }
		 public void run() {
			 while (shouldRun) {
				 try {
					 Thread.sleep(RETIRE_JOB_CHECK_INTERVAL);
				 }
				 catch (InterruptedException ie) {
				 }
				 synchronized (jobs) {
					 synchronized (jobsByArrival) {
						 synchronized (jobInitQueue) {
							 for (Iterator it = jobs.keySet().iterator();
							 it.hasNext();
							 ) {
								 String jobid = (String) it.next();
								 JobInProgress job = (JobInProgress) jobs.get(jobid);
								 if (job.getStatus().getRunState() != JobStatus.RUNNING && job.getStatus().getRunState() != JobStatus.PREP && (job.getFinishTime() + RETIRE_JOB_INTERVAL < System.currentTimeMillis())) {
									 it.remove();
									 jobInitQueue.remove(job);
									 jobsByArrival.remove(job);
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 public void stopRetirer() {
			 shouldRun = false;
		 }
	 }
	 class JobInitThread implements Runnable {
		 boolean shouldRun = true;
		 public JobInitThread() {
		 }
		 public void run() {
			 while (shouldRun) {
				 JobInProgress job = null;
				 synchronized (jobInitQueue) {
					 if (jobInitQueue.size() > 0) {
						 job = (JobInProgress) jobInitQueue.elementAt(0);
						 jobInitQueue.remove(job);
					 }
					 else {
						 try {
							 jobInitQueue.wait(JOBINIT_SLEEP_INTERVAL);
						 }
						 catch (InterruptedException iex) {
						 }
					 }
				 }
				 try {
					 if (job != null) {
						 job.initTasks();
					 }
				 }
				 catch (Exception e) {
					 LOG.warn(""job init failed"", e);
					 job.kill();
				 }
			 }
		 }
		 public void stopIniter() {
			 shouldRun = false;
		 }
	 }
	 static class JobTrackerMetrics {
		 private MetricsRecord metricsRecord = null;
		 private long numMapTasksLaunched = 0L;
		 private long numMapTasksCompleted = 0L;
		 private long numReduceTasksLaunched = 0L;
		 private long numReduceTasksCompleted = 0L;
		 private long numJobsSubmitted = 0L;
		 private long numJobsCompleted = 0L;
		 JobTrackerMetrics() {
			 metricsRecord = Metrics.createRecord(""mapred"", ""jobtracker"");
		 }
		 synchronized void launchMap() {
			 Metrics.report(metricsRecord, ""maps-launched"", ++numMapTasksLaunched);
		 }
		 synchronized void completeMap() {
			 Metrics.report(metricsRecord, ""maps-completed"", ++numMapTasksCompleted);
		 }
		 synchronized void launchReduce() {
			 Metrics.report(metricsRecord, ""reduces-launched"", ++numReduceTasksLaunched);
		 }
		 synchronized void completeReduce() {
			 Metrics.report(metricsRecord, ""reduces-completed"", ++numReduceTasksCompleted);
		 }
		 synchronized void submitJob() {
			 Metrics.report(metricsRecord, ""jobs-submitted"", ++numJobsSubmitted);
		 }
		 synchronized void completeJob() {
			 Metrics.report(metricsRecord, ""jobs-completed"", ++numJobsCompleted);
		 }
	 }
	 private JobTrackerMetrics myMetrics = null;
	 int port;
	 String localMachine;
	 long startTime;
	 int totalSubmissions = 0;
	 Random r = new Random();
	 private int maxCurrentTasks;
	 TreeMap jobs = new TreeMap();
	 Vector jobsByArrival = new Vector();
	 TreeMap taskidToTIPMap = new TreeMap();
	 TreeMap taskidToTrackerMap = new TreeMap();
	 TreeMap trackerToTaskMap = new TreeMap();
	 int totalMaps = 0;
	 int totalReduces = 0;
	 private TreeMap taskTrackers = new TreeMap();
	 Vector jobInitQueue = new Vector();
	 ExpireTrackers expireTrackers = new ExpireTrackers();
	 Thread expireTrackersThread = null;
	 RetireJobs retireJobs = new RetireJobs();
	 Thread retireJobsThread = null;
	 JobInitThread initJobs = new JobInitThread();
	 Thread initJobsThread = null;
	 ExpireLaunchingTasks expireLaunchingTasks = new ExpireLaunchingTasks();
	 Thread expireLaunchingTaskThread = new Thread(expireLaunchingTasks);
	 TreeSet trackerExpiryQueue = new TreeSet(new Comparator() {
		 public int compare(Object o1, Object o2) {
			 TaskTrackerStatus p1 = (TaskTrackerStatus) o1;
			 TaskTrackerStatus p2 = (TaskTrackerStatus) o2;
			 if (p1.getLastSeen() < p2.getLastSeen()) {
				 return -1;
			 }
			 else if (p1.getLastSeen() > p2.getLastSeen()) {
				 return 1;
			 }
			 else {
				 return (p1.getTrackerName().compareTo(p2.getTrackerName()));
			 }
		 }
	 }
	);
	 StatusHttpServer infoServer;
	 int infoPort;
	 Server interTrackerServer;
	 static final String SUBDIR = ""jobTracker"";
	 FileSystem fs;
	 Path systemDir;
	 private Configuration conf;
	 JobTracker(Configuration conf) throws IOException {
		 maxCurrentTasks = conf.getInt(""mapred.tasktracker.tasks.maximum"", 2);
		 RETIRE_JOB_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.interval"", 24 * 60 * 60 * 1000);
		 RETIRE_JOB_CHECK_INTERVAL = conf.getLong(""mapred.jobtracker.retirejob.check"", 60 * 1000);
		 TASK_ALLOC_EPSILON = conf.getFloat(""mapred.jobtracker.taskalloc.loadbalance.epsilon"", 0.2f);
		 PAD_FRACTION = conf.getFloat(""mapred.jobtracker.taskalloc.capacitypad"", 0.01f);
		 this.conf = conf;
		 JobConf jobConf = new JobConf(conf);
		 this.systemDir = jobConf.getSystemDir();
		 this.fs = FileSystem.get(conf);
		 fs.delete(systemDir);
		 fs.mkdirs(systemDir);
		 jobConf.deleteLocalFiles(SUBDIR);
		 InetSocketAddress addr = getAddress(conf);
		 this.localMachine = addr.getHostName();
		 this.port = addr.getPort();
		 this.interTrackerServer = RPC.getServer(this, addr.getPort(), 10, false, conf);
		 this.interTrackerServer.start();
		 Properties p = System.getProperties();
		 for (Iterator it = p.keySet().iterator();
		 it.hasNext();
		 ) {
			 String key = (String) it.next();
			 String val = (String) p.getProperty(key);
			 LOG.info(""Property '"" + key + ""' is "" + val);
		 }
		 this.infoPort = conf.getInt(""mapred.job.tracker.info.port"", 50030);
		 this.infoServer = new StatusHttpServer(""job"", infoPort, false);
		 this.infoServer.start();
		 this.startTime = System.currentTimeMillis();
		 myMetrics = new JobTrackerMetrics();
		 this.expireTrackersThread = new Thread(this.expireTrackers);
		 this.expireTrackersThread.start();
		 this.retireJobsThread = new Thread(this.retireJobs);
		 this.retireJobsThread.start();
		 this.initJobsThread = new Thread(this.initJobs);
		 this.initJobsThread.start();
		 expireLaunchingTaskThread.start();
	 }
	 public static InetSocketAddress getAddress(Configuration conf) {
		 String jobTrackerStr = conf.get(""mapred.job.tracker"", ""localhost:8012"");
		 int colon = jobTrackerStr.indexOf("":"");
		 if (colon < 0) {
			 throw new RuntimeException(""Bad mapred.job.tracker: ""+jobTrackerStr);
		 }
		 String jobTrackerName = jobTrackerStr.substring(0, colon);
		 int jobTrackerPort = Integer.parseInt(jobTrackerStr.substring(colon+1));
		 return new InetSocketAddress(jobTrackerName, jobTrackerPort);
	 }
	 public void offerService() {
		 try {
			 this.interTrackerServer.join();
		 }
		 catch (InterruptedException ie) {
		 }
		 LOG.info(""Stopped interTrackerServer"");
	 }
	 void close() throws IOException {
		 if (this.infoServer != null) {
			 LOG.info(""Stopping infoServer"");
			 try {
				 this.infoServer.stop();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.interTrackerServer != null) {
			 LOG.info(""Stopping interTrackerServer"");
			 this.interTrackerServer.stop();
		 }
		 if (this.expireTrackers != null) {
			 LOG.info(""Stopping expireTrackers"");
			 this.expireTrackers.stopTracker();
			 try {
				 this.expireTrackersThread.interrupt();
				 this.expireTrackersThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.retireJobs != null) {
			 LOG.info(""Stopping retirer"");
			 this.retireJobs.stopRetirer();
			 try {
				 this.retireJobsThread.interrupt();
				 this.retireJobsThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.initJobs != null) {
			 LOG.info(""Stopping initer"");
			 this.initJobs.stopIniter();
			 try {
				 this.initJobsThread.interrupt();
				 this.initJobsThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 if (this.expireLaunchingTaskThread != null) {
			 LOG.info(""Stopping expireLaunchingTasks"");
			 this.expireLaunchingTasks.stop();
			 try {
				 this.expireLaunchingTaskThread.interrupt();
				 this.expireLaunchingTaskThread.join();
			 }
			 catch (InterruptedException ex) {
				 ex.printStackTrace();
			 }
		 }
		 LOG.info(""stopped all jobtracker services"");
		 return;
	 }
	 void createTaskEntry(String taskid, String taskTracker, TaskInProgress tip) {
		 LOG.info(""Adding task '"" + taskid + ""' to tip "" + tip.getTIPId() + "", for tracker '"" + taskTracker + ""'"");
		 taskidToTrackerMap.put(taskid, taskTracker);
		 TreeSet taskset = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskset == null) {
			 taskset = new TreeSet();
			 trackerToTaskMap.put(taskTracker, taskset);
		 }
		 taskset.add(taskid);
		 taskidToTIPMap.put(taskid, tip);
	 }
	 void removeTaskEntry(String taskid) {
		 String tracker = (String) taskidToTrackerMap.remove(taskid);
		 TreeSet trackerSet = (TreeSet) trackerToTaskMap.get(tracker);
		 if (trackerSet != null) {
			 trackerSet.remove(taskid);
		 }
		 taskidToTIPMap.remove(taskid);
	 }
	 public int getTotalSubmissions() {
		 return totalSubmissions;
	 }
	 public String getJobTrackerMachine() {
		 return localMachine;
	 }
	 public int getTrackerPort() {
		 return port;
	 }
	 public int getInfoPort() {
		 return infoPort;
	 }
	 public long getStartTime() {
		 return startTime;
	 }
	 public Vector runningJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector failedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.FAILED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Vector completedJobs() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.SUCCEEDED) {
				 v.add(jip);
			 }
		 }
		 return v;
	 }
	 public Collection taskTrackers() {
		 synchronized (taskTrackers) {
			 return taskTrackers.values();
		 }
	 }
	 public TaskTrackerStatus getTaskTracker(String trackerID) {
		 synchronized (taskTrackers) {
			 return (TaskTrackerStatus) taskTrackers.get(trackerID);
		 }
	 }
	 private boolean updateTaskTrackerStatus(String trackerName, TaskTrackerStatus status) {
		 TaskTrackerStatus oldStatus = (TaskTrackerStatus) taskTrackers.get(trackerName);
		 if (oldStatus != null) {
			 totalMaps -= oldStatus.countMapTasks();
			 totalReduces -= oldStatus.countReduceTasks();
			 if (status == null) {
				 taskTrackers.remove(trackerName);
			 }
		 }
		 if (status != null) {
			 totalMaps += status.countMapTasks();
			 totalReduces += status.countReduceTasks();
			 taskTrackers.put(trackerName, status);
		 }
		 return oldStatus != null;
	 }
	 public synchronized int emitHeartbeat(TaskTrackerStatus trackerStatus, boolean initialContact) {
		 String trackerName = trackerStatus.getTrackerName();
		 trackerStatus.setLastSeen(System.currentTimeMillis());
		 synchronized (taskTrackers) {
			 synchronized (trackerExpiryQueue) {
				 boolean seenBefore = updateTaskTrackerStatus(trackerName, trackerStatus);
				 if (initialContact) {
					 if (seenBefore) {
						 lostTaskTracker(trackerName, trackerStatus.getHost());
					 }
				 }
				 else {
					 if (!seenBefore) {
						 return InterTrackerProtocol.UNKNOWN_TASKTRACKER;
					 }
				 }
				 if (initialContact) {
					 trackerExpiryQueue.add(trackerStatus);
				 }
			 }
		 }
		 updateTaskStatuses(trackerStatus);
		 return InterTrackerProtocol.TRACKERS_OK;
	 }
	 public synchronized Task pollForNewTask(String taskTracker) {
		 int remainingReduceLoad = 0;
		 int remainingMapLoad = 0;
		 int numTaskTrackers;
		 TaskTrackerStatus tts;
		 synchronized (taskTrackers) {
			 numTaskTrackers = taskTrackers.size();
			 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
		 }
		 if (tts == null) {
			 LOG.warn(""Unknown task tracker polling;
			 ignoring: "" + taskTracker);
			 return null;
		 }
		 int totalCapacity = numTaskTrackers * maxCurrentTasks;
		 synchronized(jobsByArrival){
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
					 int totalMapTasks = job.desiredMaps();
					 int totalReduceTasks = job.desiredReduces();
					 remainingMapLoad += (totalMapTasks - job.finishedMaps());
					 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
				 }
			 }
		 }
		 int maxMapLoad = 0;
		 int maxReduceLoad = 0;
		 if (numTaskTrackers > 0) {
			 maxMapLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingMapLoad / numTaskTrackers));
			 maxReduceLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingReduceLoad / numTaskTrackers));
		 }
		 int numMaps = tts.countMapTasks();
		 int numReduces = tts.countReduceTasks();
		 synchronized (jobsByArrival) {
			 if (numMaps < maxMapLoad) {
				 int totalNeededMaps = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
						 continue;
					 }
					 Task t = job.obtainNewMapTask(tts, numTaskTrackers);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 myMetrics.launchMap();
						 return t;
					 }
					 totalNeededMaps += job.desiredMaps();
					 int padding = 0;
					 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, (int)(totalNeededMaps * PAD_FRACTION));
					 }
					 if (totalMaps + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
			 if (numReduces < maxReduceLoad) {
				 int totalNeededReduces = 0;
				 for (Iterator it = jobsByArrival.iterator();
				 it.hasNext();
				 ) {
					 JobInProgress job = (JobInProgress) it.next();
					 if (job.getStatus().getRunState() != JobStatus.RUNNING || job.numReduceTasks == 0) {
						 continue;
					 }
					 Task t = job.obtainNewReduceTask(tts, numTaskTrackers);
					 if (t != null) {
						 expireLaunchingTasks.addNewTask(t.getTaskId());
						 myMetrics.launchReduce();
						 return t;
					 }
					 totalNeededReduces += job.desiredReduces();
					 int padding = 0;
					 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
						 padding = Math.min(maxCurrentTasks, (int) (totalNeededReduces * PAD_FRACTION));
					 }
					 if (totalReduces + padding >= totalCapacity) {
						 break;
					 }
				 }
			 }
		 }
		 return null;
	 }
	 public synchronized String[] pollForTaskWithClosedJob(String taskTracker) {
		 TreeSet taskIds = (TreeSet) trackerToTaskMap.get(taskTracker);
		 if (taskIds != null) {
			 ArrayList list = new ArrayList();
			 for (Iterator it = taskIds.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.shouldCloseForClosedJob(taskId)) {
					 list.add(taskId);
				 }
			 }
			 return (String[]) list.toArray(new String[list.size()]);
		 }
		 return null;
	 }
	 public synchronized MapOutputLocation[] locateMapOutputs(String jobId, int[] mapTasksNeeded, int reduce) {
		 ArrayList result = new ArrayList(mapTasksNeeded.length);
		 JobInProgress job = getJob(jobId);
		 for (int i = 0;
		 i < mapTasksNeeded.length;
		 i++) {
			 TaskStatus status = job.findFinishedMap(mapTasksNeeded[i]);
			 if (status != null) {
				 String trackerId = (String) taskidToTrackerMap.get(status.getTaskId());
				 TaskTrackerStatus tracker;
				 synchronized (taskTrackers) {
					 tracker = (TaskTrackerStatus) taskTrackers.get(trackerId);
				 }
				 result.add(new MapOutputLocation(status.getTaskId(), mapTasksNeeded[i], tracker.getHost(), tracker.getHttpPort()));
			 }
		 }
		 return (MapOutputLocation[]) result.toArray(new MapOutputLocation[result.size()]);
	 }
	 public synchronized String getFilesystemName() throws IOException {
		 return fs.getName();
	 }
	 public void reportTaskTrackerError(String taskTracker, String errorClass, String errorMessage) throws IOException {
		 LOG.warn(""Report from "" + taskTracker + "": "" + errorMessage);
	 }
	 public synchronized JobStatus submitJob(String jobFile) throws IOException {
		 totalSubmissions++;
		 JobInProgress job = new JobInProgress(jobFile, this, this.conf);
		 synchronized (jobs) {
			 synchronized (jobsByArrival) {
				 synchronized (jobInitQueue) {
					 jobs.put(job.getProfile().getJobId(), job);
					 jobsByArrival.add(job);
					 jobInitQueue.add(job);
					 jobInitQueue.notifyAll();
				 }
			 }
		 }
		 myMetrics.submitJob();
		 return job.getStatus();
	 }
	 public synchronized ClusterStatus getClusterStatus() {
		 synchronized (taskTrackers) {
			 return new ClusterStatus(taskTrackers.size(), totalMaps, totalReduces, maxCurrentTasks);
		 }
	 }
	 public synchronized void killJob(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 job.kill();
	 }
	 public synchronized JobProfile getJobProfile(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getProfile();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized JobStatus getJobStatus(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job != null) {
			 return job.getStatus();
		 }
		 else {
			 return null;
		 }
	 }
	 public synchronized TaskReport[] getMapTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeMapTasks = job.reportTasksInProgress(true, true);
			 for (Iterator it = completeMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteMapTasks = job.reportTasksInProgress(true, false);
			 for (Iterator it = incompleteMapTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 public synchronized TaskReport[] getReduceTaskReports(String jobid) {
		 JobInProgress job = (JobInProgress) jobs.get(jobid);
		 if (job == null) {
			 return new TaskReport[0];
		 }
		 else {
			 Vector reports = new Vector();
			 Vector completeReduceTasks = job.reportTasksInProgress(false, true);
			 for (Iterator it = completeReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 Vector incompleteReduceTasks = job.reportTasksInProgress(false, false);
			 for (Iterator it = incompleteReduceTasks.iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 reports.add(tip.generateSingleReport());
			 }
			 return (TaskReport[]) reports.toArray(new TaskReport[reports.size()]);
		 }
	 }
	 TaskStatus[] getTaskStatuses(String jobid, String tipid){
		JobInProgress job = (JobInProgress) jobs.get(jobid);
		if (job == null){
			 return new TaskStatus[0];
		}
		TaskInProgress tip = (TaskInProgress) job.getTaskInProgress(tipid);
		if (tip == null){
			 return new TaskStatus[0];
		}
		return tip.getTaskStatuses();
	 }
	 public synchronized String getAssignedTracker(String taskId) {
		 return (String) taskidToTrackerMap.get(taskId);
	 }
	 public JobStatus[] jobsToComplete() {
		 Vector v = new Vector();
		 for (Iterator it = jobs.values().iterator();
		 it.hasNext();
		 ) {
			 JobInProgress jip = (JobInProgress) it.next();
			 JobStatus status = jip.getStatus();
			 if (status.getRunState() == JobStatus.RUNNING || status.getRunState() == JobStatus.PREP) {
				status.setStartTime(jip.getStartTime());
				 status.setUsername(jip.getProfile().getUser());
				 v.add(status);
			 }
		 }
		 return (JobStatus[]) v.toArray(new JobStatus[v.size()]);
	 }
	 public JobInProgress getJob(String jobid) {
		 return (JobInProgress) jobs.get(jobid);
	 }
	 String createUniqueId() {
		 return idFormat.format(nextJobId++);
	 }
	 void updateTaskStatuses(TaskTrackerStatus status) {
		 for (Iterator it = status.taskReports();
		 it.hasNext();
		 ) {
			 TaskStatus report = (TaskStatus) it.next();
			 report.setTaskTracker(status.getTrackerName());
			 String taskId = report.getTaskId();
			 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
			 if (tip == null) {
				 LOG.info(""Serious problem. While updating status, cannot find taskid "" + report.getTaskId());
			 }
			 else {
				 expireLaunchingTasks.removeTask(taskId);
				 tip.getJob().updateTaskStatus(tip, report, myMetrics);
			 }
		 }
	 }
	 void lostTaskTracker(String trackerName, String hostname) {
		 LOG.info(""Lost tracker '"" + trackerName + ""'"");
		 TreeSet lostTasks = (TreeSet) trackerToTaskMap.get(trackerName);
		 trackerToTaskMap.remove(trackerName);
		 if (lostTasks != null) {
			 for (Iterator it = lostTasks.iterator();
			 it.hasNext();
			 ) {
				 String taskId = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) taskidToTIPMap.get(taskId);
				 if (tip.isMapTask() || !tip.isComplete()) {
					 JobInProgress job = tip.getJob();
					 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
						 job.failedTask(tip, taskId, ""Lost task tracker"", hostname, trackerName, myMetrics);
					 }
				 }
			 }
		 }
	 }
	 public static void main(String argv[]) throws IOException, InterruptedException {
		 if (argv.length != 0) {
			 System.out.println(""usage: JobTracker"");
			 System.exit(-1);
		 }
		 Configuration conf=new Configuration();
		 startTracker(conf);
	 }
}",0,0,0,0
")public class CreateZoneDetails {
	 public static class Builder {
		 private String name;
		 public Builder name(String name) {
			 this.name = name;
			 this.__explicitlySet__.add(""name"");
			 return this;
		 }
		 private ZoneType zoneType;
		 public Builder zoneType(ZoneType zoneType) {
			 this.zoneType = zoneType;
			 this.__explicitlySet__.add(""zoneType"");
			 return this;
		 }
		 private String compartmentId;
		 public Builder compartmentId(String compartmentId) {
			 this.compartmentId = compartmentId;
			 this.__explicitlySet__.add(""compartmentId"");
			 return this;
		 }
		 private java.util.Map<String, String> freeformTags;
		 public Builder freeformTags(java.util.Map<String, String> freeformTags) {
			 this.freeformTags = freeformTags;
			 this.__explicitlySet__.add(""freeformTags"");
			 return this;
		 }
		 private java.util.Map<String, java.util.Map<String, Object>> definedTags;
		 public Builder definedTags( java.util.Map<String, java.util.Map<String, Object>> definedTags) {
			 this.definedTags = definedTags;
			 this.__explicitlySet__.add(""definedTags"");
			 return this;
		 }
		 private java.util.List<ExternalMaster> externalMasters;
		 public Builder externalMasters(java.util.List<ExternalMaster> externalMasters) {
			 this.externalMasters = externalMasters;
			 this.__explicitlySet__.add(""externalMasters"");
			 return this;
		 }
		 private final java.util.Set<String> __explicitlySet__ = new java.util.HashSet<String>();
		 public CreateZoneDetails build() {
			 CreateZoneDetails __instance__ = new CreateZoneDetails( name, zoneType, compartmentId, freeformTags, definedTags, externalMasters);
			 __instance__.__explicitlySet__.addAll(__explicitlySet__);
			 return __instance__;
		 }
		 public Builder copy(CreateZoneDetails o) {
			 Builder copiedBuilder = name(o.getName()) .zoneType(o.getZoneType()) .compartmentId(o.getCompartmentId()) .freeformTags(o.getFreeformTags()) .definedTags(o.getDefinedTags()) .externalMasters(o.getExternalMasters());
			 copiedBuilder.__explicitlySet__.retainAll(o.__explicitlySet__);
			 return copiedBuilder;
		 }
	 }
	 public static Builder builder() {
		 return new Builder();
	 }
	 String name;
	 public enum ZoneType {
		 Primary(""PRIMARY""), Secondary(""SECONDARY""), ;
		 private final String value;
		 private static java.util.Map<String, ZoneType> map;
		 static {
			 map = new java.util.HashMap<>();
			 for (ZoneType v : ZoneType.values()) {
				 map.put(v.getValue(), v);
			 }
		 }
		 ZoneType(String value) {
			 this.value = value;
		 }
		 public String getValue() {
			 return value;
		 }
		 public static ZoneType create(String key) {
			 if (map.containsKey(key)) {
				 return map.get(key);
			 }
			 throw new RuntimeException(""Invalid ZoneType: "" + key);
		 }
	 }
	;
	 ZoneType zoneType;
	 String compartmentId;
	 java.util.Map<String, String> freeformTags;
	 java.util.Map<String, java.util.Map<String, Object>> definedTags;
	 java.util.List<ExternalMaster> externalMasters;
	 private final java.util.Set<String> __explicitlySet__ = new java.util.HashSet<String>();
}",1,1,0,0
"static void registerConfigOptions(IConfigManager configManager) {
	 AsterixProperties.registerConfigOptions(configManager);
	 ControllerConfig.Option.DEFAULT_DIR .setDefaultValue(FileUtil.joinPath(System.getProperty(ConfigurationUtil.JAVA_IO_TMPDIR), ""asterixdb""));
	 NCConfig.Option.APP_CLASS.setDefaultValue(NCApplication.class.getName());
	 CCConfig.Option.APP_CLASS.setDefaultValue(CCApplication.class.getName());
	 try {
		 InputStream propertyStream = ApplicationConfigurator.class.getClassLoader().getResourceAsStream(""git.properties"");
		 if (propertyStream != null) {
			 Properties gitProperties = new Properties();
			 gitProperties.load(propertyStream);
			 StringWriter sw = new StringWriter();
			 gitProperties.store(sw, null);
			 configManager.setVersionString(sw.toString());
		 }
	 }
	 catch (IOException e) {
		 throw new IllegalStateException(e);
	 }
 }",0,0,1,0
"public class ModelImplConverter extends AbstractModelConverter {
	 public JavaType doConvert(SwaggerToClassGenerator swaggerToClassGenerator, Object model) {
		 ModelImpl modelImpl = (ModelImpl) model;
		 JavaType javaType = ConverterMgr.findJavaType(modelImpl.getType(), modelImpl.getFormat());
		 if (javaType != null) {
			 return javaType;
		 }
		 if (modelImpl.getReference() != null) {
			 return swaggerToClassGenerator.convertRef(modelImpl.getReference());
		 }
		 if (modelImpl.getAdditionalProperties() != null) {
			 return MapPropertyConverter.findJavaType(swaggerToClassGenerator, modelImpl.getAdditionalProperties());
		 }
		 if (ObjectProperty.TYPE.equals(modelImpl.getType()) && modelImpl.getProperties() == null && modelImpl.getName() == null) {
			 return TypeFactory.defaultInstance().constructType(Object.class);
		 }
		 return getOrCreateType(swaggerToClassGenerator, modelImpl);
	 }
	 protected JavaType getOrCreateType(SwaggerToClassGenerator swaggerToClassGenerator, ModelImpl modelImpl) {
		 String clsName = ClassUtils.getClassName(findVendorExtensions(modelImpl));
		 clsName = ClassUtils.correctClassName(clsName);
		 return getOrCreateType(swaggerToClassGenerator, modelImpl.getProperties(), clsName);
	 }
	 protected JavaType getOrCreateType(SwaggerToClassGenerator swaggerToClassGenerator, Map<String, Property> properties, String clsName) {
		 Class<?> cls = ClassUtils.getClassByName(swaggerToClassGenerator.getClassLoader(), clsName);
		 if (cls != null) {
			 return swaggerToClassGenerator.getTypeFactory().constructType(cls);
		 }
		 CtClass ctClass = getOrCreateCtClass(swaggerToClassGenerator, properties, clsName);
		 return new CtTypeJavaType(new CtType(ctClass));
	 }
	 private CtClass getOrCreateCtClass(SwaggerToClassGenerator swaggerToClassGenerator, Map<String, Property> properties, String clsName) {
		 CtClass ctClass = swaggerToClassGenerator.getClassPool().getOrNull(clsName);
		 if (ctClass != null) {
			 return ctClass;
		 }
		 swaggerToClassGenerator.getClassPool().makeClass(clsName);
		 ClassConfig classConfig = new ClassConfig();
		 classConfig.setClassName(clsName);
		 if (null != properties) {
			 for (Entry<String, Property> entry : properties.entrySet()) {
				 JavaType propertyJavaType = swaggerToClassGenerator.convert(entry.getValue());
				 classConfig.addField(entry.getKey(), propertyJavaType);
			 }
		 }
		 return JavassistUtils.createCtClass(swaggerToClassGenerator.getClassLoader(), classConfig);
	 }
}",0,0,0,0
"public boolean isValidSyntax( Object value ) {
	 String strValue;
	 if ( value == null ) {
		 if ( LOG.isDebugEnabled() ) {
			 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, ""null"" ) );
		 }
		 return false;
	 }
	 if ( value instanceof String ) {
		 strValue = ( String ) value;
	 }
	 else if ( value instanceof byte[] ) {
		 strValue = Strings.utf8ToString( ( byte[] ) value );
	 }
	 else {
		 strValue = value.toString();
	 }
	 if ( strValue.length() < 4 ) {
		 if ( LOG.isDebugEnabled() ) {
			 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );
		 }
		 return false;
	 }
	 if ( ( strValue.charAt( 0 ) != '(' ) || ( strValue.charAt( strValue.length() - 1 ) != ')' ) ) {
		 if ( LOG.isDebugEnabled() ) {
			 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );
		 }
		 return false;
	 }
	 Set<String> keywords = new HashSet<>();
	 int len = strValue.length() - 1;
	 boolean needKeyword = true;
	 for ( int i = 1;
	 i < len;
	 ) {
		 while ( ( i < len ) && ( strValue.charAt( i ) == ' ' ) ) {
			 i++;
		 }
		 int pos = i;
		 while ( ( i < len ) && Chars.isAlphaASCII( strValue, pos ) ) {
			 pos++;
		 }
		 if ( pos == i ) {
			 if ( LOG.isDebugEnabled() ) {
				 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );
			 }
			 return false;
		 }
		 String keyword = strValue.substring( i, pos );
		 i = pos;
		 if ( !DSE_BITS.contains( keyword ) ) {
			 if ( LOG.isDebugEnabled() ) {
				 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );
			 }
			 return false;
		 }
		 if ( keywords.contains( keyword ) ) {
			 if ( LOG.isDebugEnabled() ) {
				 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );
			 }
			 return false;
		 }
		 keywords.add( keyword );
		 needKeyword = false;
		 while ( ( i < len ) && ( strValue.charAt( i ) == ' ' ) ) {
			 i++;
		 }
		 if ( ( i < len ) && ( strValue.charAt( i ) == '$' ) ) {
			 i++;
			 needKeyword = true;
		 }
	 }
	 if ( LOG.isDebugEnabled() ) {
		 if ( needKeyword ) {
			 LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );
		 }
		 else {
			 LOG.debug( I18n.msg( I18n.MSG_13701_SYNTAX_VALID, value ) );
		 }
	 }
	 return !needKeyword;
 }",0,0,1,0
"public void run() {
	 String line;
	 StringTokenizer tokens;
	 try {
		 while (!closed) {
			 line = readClient();
			 if (line == null) {
				 break;
			 }
			 tokens = new StringTokenizer(line);
			 String command = tokens.nextToken();
			 Map<String, String> headers = parseHeaders();
			 String encodedPath = StringUtil.encodePlusSign(tokens.nextToken());
			 String path = URIUtil.decode(encodedPath);
			 String content = getContent(headers.get(""content-length""));
			 setSocketTimeout(headers.get(""keep-alive""));
			 closed = ""close"".equals(headers.get(""connection""));
			 if (""OPTIONS"".equals(command)) {
				 sendOptions();
			 }
			 else if (!headers.containsKey(""authorization"")) {
				 sendUnauthorized();
			 }
			 else {
				 decodeCredentials(headers.get(""authorization""));
				 try {
					 session = ExchangeSessionFactory.getInstance(userName, password);
					 handleRequest(command, path, headers, content);
				 }
				 catch (DavMailAuthenticationException e) {
					 if (Settings.getBooleanProperty(""davmail.enableKerberos"")) {
						 throw new HttpServerErrorException(""Kerberos authentication failed"");
					 }
					 else {
						 sendUnauthorized();
					 }
				 }
			 }
			 os.flush();
			 DavGatewayTray.resetIcon();
		 }
	 }
	 catch (SocketTimeoutException e) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_CLOSE_CONNECTION_ON_TIMEOUT""));
	 }
	 catch (SocketException e) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_CONNECTION_CLOSED""));
	 }
	 catch (Exception e) {
		 if (!(e instanceof HttpNotFoundException)) {
			 DavGatewayTray.log(e);
		 }
		 try {
			 sendErr(e);
		 }
		 catch (IOException e2) {
			 DavGatewayTray.debug(new BundleMessage(""LOG_EXCEPTION_SENDING_ERROR_TO_CLIENT""), e2);
		 }
	 }
	 finally {
		 close();
	 }
	 DavGatewayTray.resetIcon();
 }",0,0,1,0
"public class DOMOutputImpl implements LSOutput {
	 protected Writer fCharStream = null;
	 protected OutputStream fByteStream = null;
	 protected String fSystemId = null;
	 protected String fEncoding = null;
	 public DOMOutputImpl() {
	}
	 public Writer getCharacterStream(){
		 return fCharStream;
	 }
	;
	 public void setCharacterStream(Writer characterStream){
		 fCharStream = characterStream;
	 }
	;
	 public OutputStream getByteStream(){
		 return fByteStream;
	 }
	;
	 public void setByteStream(OutputStream byteStream){
		 fByteStream = byteStream;
	 }
	;
	 public String getSystemId(){
		 return fSystemId;
	 }
	;
	 public void setSystemId(String systemId){
		 fSystemId = systemId;
	 }
	;
	 public String getEncoding(){
		 return fEncoding;
	 }
	;
	 public void setEncoding(String encoding){
		 fEncoding = encoding;
	 }
	;
}",0,1,0,0
"public class BridgeVifDriver extends VifDriverBase {
	 private static final Logger s_logger = Logger.getLogger(BridgeVifDriver.class);
	 private int _timeout;
	 private final Object _vnetBridgeMonitor = new Object();
	 private String _modifyVlanPath;
	 private String _modifyVxlanPath;
	 private String bridgeNameSchema;
	 private Long libvirtVersion;
	 public void configure(Map<String, Object> params) throws ConfigurationException {
		 super.configure(params);
		 getPifs();
		 params.put(""domr.scripts.dir"", ""scripts/network/domr/kvm"");
		 String networkScriptsDir = (String)params.get(""network.scripts.dir"");
		 if (networkScriptsDir == null) {
			 networkScriptsDir = ""scripts/vm/network/vnet"";
		 }
		 bridgeNameSchema = (String)params.get(""network.bridge.name.schema"");
		 String value = (String)params.get(""scripts.timeout"");
		 _timeout = NumbersUtil.parseInt(value, 30 * 60) * 1000;
		 _modifyVlanPath = Script.findScript(networkScriptsDir, ""modifyvlan.sh"");
		 if (_modifyVlanPath == null) {
			 throw new ConfigurationException(""Unable to find modifyvlan.sh"");
		 }
		 _modifyVxlanPath = Script.findScript(networkScriptsDir, ""modifyvxlan.sh"");
		 if (_modifyVxlanPath == null) {
			 throw new ConfigurationException(""Unable to find modifyvxlan.sh"");
		 }
		 libvirtVersion = (Long) params.get(""libvirtVersion"");
		 if (libvirtVersion == null) {
			 libvirtVersion = 0L;
		 }
	 }
	 public void getPifs() {
		 final File dir = new File(""/sys/devices/virtual/net"");
		 final File[] netdevs = dir.listFiles();
		 final List<String> bridges = new ArrayList<String>();
		 for (File netdev : netdevs) {
			 final File isbridge = new File(netdev.getAbsolutePath() + ""/bridge"");
			 final String netdevName = netdev.getName();
			 s_logger.debug(""looking in file "" + netdev.getAbsolutePath() + ""/bridge"");
			 if (isbridge.exists()) {
				 s_logger.debug(""Found bridge "" + netdevName);
				 bridges.add(netdevName);
			 }
		 }
		 String guestBridgeName = _libvirtComputingResource.getGuestBridgeName();
		 String publicBridgeName = _libvirtComputingResource.getPublicBridgeName();
		 for (final String bridge : bridges) {
			 s_logger.debug(""looking for pif for bridge "" + bridge);
			 final String pif = getPif(bridge);
			 if (_libvirtComputingResource.isPublicBridge(bridge)) {
				 _pifs.put(""public"", pif);
			 }
			 if (guestBridgeName != null && bridge.equals(guestBridgeName)) {
				 _pifs.put(""private"", pif);
			 }
			 _pifs.put(bridge, pif);
		 }
		 if (_pifs.get(""private"") == null) {
			 s_logger.debug(""guest(private) traffic label '"" + guestBridgeName + ""' not found as bridge, looking for physical interface"");
			 final File dev = new File(""/sys/class/net/"" + guestBridgeName);
			 if (dev.exists()) {
				 s_logger.debug(""guest(private) traffic label '"" + guestBridgeName + ""' found as a physical device"");
				 _pifs.put(""private"", guestBridgeName);
			 }
		 }
		 if (_pifs.get(""public"") == null) {
			 s_logger.debug(""public traffic label '"" + publicBridgeName+ ""' not found as bridge, looking for physical interface"");
			 final File dev = new File(""/sys/class/net/"" + publicBridgeName);
			 if (dev.exists()) {
				 s_logger.debug(""public traffic label '"" + publicBridgeName + ""' found as a physical device"");
				 _pifs.put(""public"", publicBridgeName);
			 }
		 }
		 s_logger.debug(""done looking for pifs, no more bridges"");
	 }
	 private String getPif(final String bridge) {
		 String pif = matchPifFileInDirectory(bridge);
		 final File vlanfile = new File(""/proc/net/vlan/"" + pif);
		 if (vlanfile.isFile()) {
			 pif = Script.runSimpleBashScript(""grep ^Device\\: /proc/net/vlan/"" + pif + "" | awk {
			'print $2'}
			"");
		 }
		 return pif;
	 }
	 private String matchPifFileInDirectory(final String bridgeName) {
		 final File brif = new File(""/sys/devices/virtual/net/"" + bridgeName + ""/brif"");
		 if (!brif.isDirectory()) {
			 final File pif = new File(""/sys/class/net/"" + bridgeName);
			 if (pif.isDirectory()) {
				 return bridgeName;
			 }
			 s_logger.debug(""failing to get physical interface from bridge "" + bridgeName + "", does "" + brif.getAbsolutePath() + ""exist?"");
			 return """";
		 }
		 final File[] interfaces = brif.listFiles();
		 for (File anInterface : interfaces) {
			 final String fname = anInterface.getName();
			 s_logger.debug(""matchPifFileInDirectory: file name '"" + fname + ""'"");
			 if (LibvirtComputingResource.isInterface(fname)) {
				 return fname;
			 }
		 }
		 s_logger.debug(""failing to get physical interface from bridge "" + bridgeName + "", did not find an eth*, bond*, team*, vlan*, em*, p*p*, ens*, eno*, enp*, or enx* in "" + brif.getAbsolutePath());
		 return """";
	 }
	 protected boolean isBroadcastTypeVlanOrVxlan(final NicTO nic) {
		 return nic != null && (nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan || nic.getBroadcastType() == Networks.BroadcastDomainType.Vxlan);
	 }
	 protected boolean isValidProtocolAndVnetId(final String vNetId, final String protocol) {
		 return vNetId != null && protocol != null && !vNetId.equalsIgnoreCase(""untagged"");
	 }
	 public LibvirtVMDef.InterfaceDef plug(NicTO nic, String guestOsType, String nicAdapter, Map<String, String> extraConfig) throws InternalErrorException, LibvirtException {
		 if (s_logger.isDebugEnabled()) {
			 s_logger.debug(""nic="" + nic);
			 if (nicAdapter != null && !nicAdapter.isEmpty()) {
				 s_logger.debug(""custom nic adapter="" + nicAdapter);
			 }
		 }
		 LibvirtVMDef.InterfaceDef intf = new LibvirtVMDef.InterfaceDef();
		 String vNetId = null;
		 String protocol = null;
		 if (isBroadcastTypeVlanOrVxlan(nic)) {
			 vNetId = Networks.BroadcastDomainType.getValue(nic.getBroadcastUri());
			 protocol = Networks.BroadcastDomainType.getSchemeValue(nic.getBroadcastUri()).scheme();
		 }
		 else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Lswitch) {
			 throw new InternalErrorException(""Nicira NVP Logicalswitches are not supported by the BridgeVifDriver"");
		 }
		 String trafficLabel = nic.getName();
		 Integer networkRateKBps = 0;
		 if (libvirtVersion > ((10 * 1000 + 10))) {
			 networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;
		 }
		 if (nic.getType() == Networks.TrafficType.Guest) {
			 if (isBroadcastTypeVlanOrVxlan(nic) && isValidProtocolAndVnetId(vNetId, protocol)) {
				 if (trafficLabel != null && !trafficLabel.isEmpty()) {
					 s_logger.debug(""creating a vNet dev and bridge for guest traffic per traffic label "" + trafficLabel);
					 String brName = createVnetBr(vNetId, trafficLabel, protocol);
					 intf.defBridgeNet(brName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);
				 }
				 else {
					 String brName = createVnetBr(vNetId, ""private"", protocol);
					 intf.defBridgeNet(brName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);
				 }
			 }
			 else {
				 String brname = """";
				 if (trafficLabel != null && !trafficLabel.isEmpty()) {
					 brname = trafficLabel;
				 }
				 else {
					 brname = _bridges.get(""guest"");
				 }
				 intf.defBridgeNet(brname, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);
			 }
		 }
		 else if (nic.getType() == Networks.TrafficType.Control) {
			 createControlNetwork();
			 intf.defBridgeNet(_bridges.get(""linklocal""), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter));
		 }
		 else if (nic.getType() == Networks.TrafficType.Public) {
			 if (isBroadcastTypeVlanOrVxlan(nic) && isValidProtocolAndVnetId(vNetId, protocol)) {
				 if (trafficLabel != null && !trafficLabel.isEmpty()) {
					 s_logger.debug(""creating a vNet dev and bridge for public traffic per traffic label "" + trafficLabel);
					 String brName = createVnetBr(vNetId, trafficLabel, protocol);
					 intf.defBridgeNet(brName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);
				 }
				 else {
					 String brName = createVnetBr(vNetId, ""public"", protocol);
					 intf.defBridgeNet(brName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);
				 }
			 }
			 else {
				 intf.defBridgeNet(_bridges.get(""public""), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);
			 }
		 }
		 else if (nic.getType() == Networks.TrafficType.Management) {
			 intf.defBridgeNet(_bridges.get(""private""), null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter));
		 }
		 else if (nic.getType() == Networks.TrafficType.Storage) {
			 String storageBrName = nic.getName() == null ? _bridges.get(""private"") : nic.getName();
			 intf.defBridgeNet(storageBrName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter));
		 }
		 if (nic.getPxeDisable()) {
			 intf.setPxeDisable(true);
		 }
		 return intf;
	 }
	 public void unplug(LibvirtVMDef.InterfaceDef iface) {
		 deleteVnetBr(iface.getBrName());
	 }
	 public void attach(LibvirtVMDef.InterfaceDef iface) {
		 Script.runSimpleBashScript(""brctl addif "" + iface.getBrName() + "" "" + iface.getDevName());
	 }
	 public void detach(LibvirtVMDef.InterfaceDef iface) {
		 Script.runSimpleBashScript(""test -d /sys/class/net/"" + iface.getBrName() + ""/brif/"" + iface.getDevName() + "" && brctl delif "" + iface.getBrName() + "" "" + iface.getDevName());
	 }
	 private String generateVnetBrName(String pifName, String vnetId) {
		 return ""br"" + pifName + ""-"" + vnetId;
	 }
	 private String generateVxnetBrName(String pifName, String vnetId) {
		 return ""brvx-"" + vnetId;
	 }
	 private String createVnetBr(String vNetId, String pifKey, String protocol) throws InternalErrorException {
		 String nic = _pifs.get(pifKey);
		 if (nic == null) {
			 File pif = new File(""/sys/class/net/"" + pifKey);
			 if (pif.isDirectory()) {
				 nic = pifKey;
			 }
		 }
		 String brName = """";
		 if (protocol.equals(Networks.BroadcastDomainType.Vxlan.scheme())) {
			 brName = generateVxnetBrName(nic, vNetId);
		 }
		 else {
			 brName = generateVnetBrName(nic, vNetId);
		 }
		 createVnet(vNetId, nic, brName, protocol);
		 return brName;
	 }
	 private void createVnet(String vnetId, String pif, String brName, String protocol) throws InternalErrorException {
		 synchronized (_vnetBridgeMonitor) {
			 String script = _modifyVlanPath;
			 if (protocol.equals(Networks.BroadcastDomainType.Vxlan.scheme())) {
				 script = _modifyVxlanPath;
			 }
			 final Script command = new Script(script, _timeout, s_logger);
			 command.add(""-v"", vnetId);
			 command.add(""-p"", pif);
			 command.add(""-b"", brName);
			 command.add(""-o"", ""add"");
			 final String result = command.execute();
			 if (result != null) {
				 throw new InternalErrorException(""Failed to create vnet "" + vnetId + "": "" + result);
			 }
		 }
	 }
	 private void deleteVnetBr(String brName) {
		 synchronized (_vnetBridgeMonitor) {
			 String cmdout = Script.runSimpleBashScript(""ls /sys/class/net/"" + brName);
			 if (cmdout == null) return;
			 cmdout = Script.runSimpleBashScript(""ls /sys/class/net/"" + brName + ""/brif | tr '\n' ' '"");
			 if (cmdout != null && cmdout.contains(""vnet"")) {
				 return;
			 }
			 Pattern oldStyleBrNameRegex = Pattern.compile(""^cloudVirBr(\\d+)$"");
			 Pattern brNameRegex = Pattern.compile(""^br(\\S+)-(\\d+)$"");
			 Matcher oldStyleBrNameMatcher = oldStyleBrNameRegex.matcher(brName);
			 Matcher brNameMatcher = brNameRegex.matcher(brName);
			 String pName = null;
			 String vNetId = null;
			 if (oldStyleBrNameMatcher.find()) {
				 pName = ""undefined"";
				 vNetId = oldStyleBrNameMatcher.group(1);
			 }
			 else if (brNameMatcher.find()) {
				 if (brNameMatcher.group(1) != null || !brNameMatcher.group(1).isEmpty()) {
					 pName = brNameMatcher.group(1);
				 }
				 else {
					 pName = ""undefined"";
				 }
				 vNetId = brNameMatcher.group(2);
			 }
			 if (vNetId == null || vNetId.isEmpty()) {
				 s_logger.debug(""unable to get a vNet ID from name "" + brName);
				 return;
			 }
			 String scriptPath = null;
			 if (cmdout != null && cmdout.contains(""vxlan"")) {
				 scriptPath = _modifyVxlanPath;
			 }
			 else {
				 scriptPath = _modifyVlanPath;
			 }
			 final Script command = new Script(scriptPath, _timeout, s_logger);
			 command.add(""-o"", ""delete"");
			 command.add(""-v"", vNetId);
			 command.add(""-p"", pName);
			 command.add(""-b"", brName);
			 final String result = command.execute();
			 if (result != null) {
				 s_logger.debug(""Delete bridge "" + brName + "" failed: "" + result);
			 }
		 }
	 }
	 private void deleteExistingLinkLocalRouteTable(String linkLocalBr) {
		 Script command = new Script(""/bin/bash"", _timeout);
		 command.add(""-c"");
		 command.add(""ip route | grep "" + NetUtils.getLinkLocalCIDR());
		 OutputInterpreter.AllLinesParser parser = new OutputInterpreter.AllLinesParser();
		 String result = command.execute(parser);
		 boolean foundLinkLocalBr = false;
		 if (result == null && parser.getLines() != null) {
			 String[] lines = parser.getLines().split(""\\n"");
			 for (String line : lines) {
				 String[] tokens = line.split("" "");
				 if (tokens != null && tokens.length < 2) {
					 continue;
				 }
				 final String device = tokens[2];
				 if (!Strings.isNullOrEmpty(device) && !device.equalsIgnoreCase(linkLocalBr)) {
					 Script.runSimpleBashScript(""ip route del "" + NetUtils.getLinkLocalCIDR() + "" dev "" + tokens[2]);
				 }
				 else {
					 foundLinkLocalBr = true;
				 }
			 }
		 }
		 if (!foundLinkLocalBr) {
			 Script.runSimpleBashScript(""ip address add 169.254.0.1/16 dev "" + linkLocalBr + "";
			"" + ""ip route add "" + NetUtils.getLinkLocalCIDR() + "" dev "" + linkLocalBr + "" src "" + NetUtils.getLinkLocalGateway());
		 }
	 }
	 private void createControlNetwork() {
		 createControlNetwork(_bridges.get(""linklocal""));
	 }
	 public void createControlNetwork(String privBrName) {
		 deleteExistingLinkLocalRouteTable(privBrName);
		 if (!isExistingBridge(privBrName)) {
			 Script.runSimpleBashScript(""brctl addbr "" + privBrName + "";
			 ip link set "" + privBrName + "" up;
			 ip address add 169.254.0.1/16 dev "" + privBrName, _timeout);
		 }
	 }
	 public boolean isExistingBridge(String bridgeName) {
		 File f = new File(""/sys/devices/virtual/net/"" + bridgeName + ""/bridge"");
		 if (f.exists()) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
}",1,0,0,0
"static List<Period> generateSchedule(Calendar startDate,Calendar endDate, Frequency frequency, StubType stubType, Period prototype);",0,0,0,1
abstract ProtocolStack getProtocolStack();,0,0,0,0
"public class PlainSwapTest extends TestCase {
	private List<FixedAccrualPeriod> fixedAccrualPeriods;
	private List<FloatAccrualPeriod> floatAccrualPeriods;
	NotionalSchedule notionalSchedule;
	private AccrualSchedule<FixedAccrualPeriod, MockPayment> fixedSchedule;
	private AccrualSchedule<FloatAccrualPeriod, MockPayment> floatSchedule;
	private int significantDigits = 2;
	public void setUp() throws ParseException, ScheduleException {
		BusinessDayConvention paymentBusinessDayConvention = BusinessDayConvention.MODIFIED_FOLLOWING;
		BusinessDayConvention accrualBusinessDayConvention = BusinessDayConvention.MODIFIED_FOLLOWING;
		BusinessDayConvention fixingBusinessDayConvention = BusinessDayConvention.PRECEDING;
		HolidayCalendar holidayCalendar = HolidayCalendarFactory.newInstance().getHolidayCalendar(""WE"");
		DaycountCalculator fixedDaycountCalculator = DaycountCalculatorFactory.newInstance().getActual360();
		DaycountCalculator floatDaycountCalculator = DaycountCalculatorFactory.newInstance().getActual360();
		int fixingOffset = -2;
		FixingAdjustmentType fixingAdjustmentType = FixingAdjustmentType.BUSINESS_DAYS;
		Iso4217Currency currency = Iso4217Currency.EUR;
		double notional = 1000;
		double fixedRate = .04;
		double floatRate = .02;
		Calendar startDate = ISDADateFormat.parse(""2007/1/16"");
		String maturity = ""10Y"";
		StubType stubType = StubType.NONE;
		Frequency fixedFrequency = Frequency.SEMI_ANNUALLY;
		Frequency floatFrequency = Frequency.QUARTERLY;
		MockPayment paymentPrototype = new MockPayment();
		paymentPrototype.setTestField(""TEST"");
		fixedSchedule = new AccrualSchedule<FixedAccrualPeriod,MockPayment>(paymentPrototype);
		floatSchedule = new AccrualSchedule<FloatAccrualPeriod,MockPayment>(paymentPrototype);
		FixedAccrualPeriod fixedPeriodPrototype = new FixedAccrualPeriod();
		fixedPeriodPrototype.setDaycountCalculator(fixedDaycountCalculator);
		fixedPeriodPrototype.setFixedRate(fixedRate);
		fixedPeriodPrototype.setPaymentBusinessDayConvention(paymentBusinessDayConvention);
		fixedPeriodPrototype.setPaymentHolidayCalendar(holidayCalendar);
		fixedPeriodPrototype.setPaymentType(PaymentType.IN_ARREARS);
		fixedPeriodPrototype.setAccrualHolidayCalendar(holidayCalendar);
		fixedPeriodPrototype.setAccrualBusinessDayConvention(accrualBusinessDayConvention);
		FloatAccrualPeriod floatPeriodPrototype = new FloatAccrualPeriod();
		floatPeriodPrototype.setDaycountCalculator(floatDaycountCalculator);
		floatPeriodPrototype.setFixingBusinessDayConvention(fixingBusinessDayConvention);
		floatPeriodPrototype.setFixingCalendarOffsetAmount(fixingOffset);
		floatPeriodPrototype.setFixingAdjustmentType(fixingAdjustmentType);
		floatPeriodPrototype.setFixingHolidayCalendar(holidayCalendar);
		floatPeriodPrototype.setPaymentBusinessDayConvention(paymentBusinessDayConvention);
		floatPeriodPrototype.setPaymentHolidayCalendar(holidayCalendar);
		floatPeriodPrototype.setPaymentType(PaymentType.IN_ARREARS);
		floatPeriodPrototype.setAccrualHolidayCalendar(holidayCalendar);
		floatPeriodPrototype.setAccrualBusinessDayConvention(accrualBusinessDayConvention);
		floatPeriodPrototype.setFixingRate(floatRate);
		TypedScheduleGenerator<FixedAccrualPeriod> fixedScheduleGenerator = new TypedScheduleGenerator<FixedAccrualPeriod>(fixedPeriodPrototype);
		TypedScheduleGenerator<FloatAccrualPeriod> floatScheduleGenerator = new TypedScheduleGenerator<FloatAccrualPeriod>(floatPeriodPrototype);
		fixedAccrualPeriods = fixedScheduleGenerator.generateSchedule(startDate,maturity,fixedFrequency,stubType);
		floatAccrualPeriods = floatScheduleGenerator.generateSchedule(startDate,maturity,floatFrequency,stubType);
		fixedSchedule.setAccrualPeriods(fixedAccrualPeriods);
		floatSchedule.setAccrualPeriods(floatAccrualPeriods);
		notionalSchedule = new FlatNotionalSchedule(notional,currency);
	}
	public void testScheduleLengths() {
		assertEquals(20,fixedAccrualPeriods.size());
		assertEquals(40,floatAccrualPeriods.size());
	}
	public void testMockPaymentsInitialised() throws Exception {
		List<MockPayment> payments = fixedSchedule.getPayments(notionalSchedule);
		payments.addAll(floatSchedule.getPayments(notionalSchedule));
		for(MockPayment payment: payments) {
			assertEquals(""TEST"",payment.getTestField());
		}
	}
	double[] expectedFixedAmounts = new double[]{
	20.11,20.44,20.22,20.44,20.11,20.67,19.89,20.56,20.22,20.22,20.22,20.44,20.11,20.44,20.11,20.44,20.11,20.67,20.22,20.22}
	;
	public void testFixedSchedulePayment() throws Exception {
		List<MockPayment> payments = fixedSchedule.getNettedPayments(notionalSchedule);
		for(int i=0;
		i<payments.size();
		i++) {
			MockPayment payment = payments.get(i);
			double expectedAmount = expectedFixedAmounts[i];
			double actualAmount = payment.getAmount();
			assertEquals(""Payment for date ""+ISDADateFormat.format(payment.getPaymentCalendar()), formatDouble(expectedAmount),formatDouble(actualAmount));
		}
	}
	public void testFormatDouble() {
		assertEquals(""1.23"",formatDouble(1.23));
		assertEquals(""1.23"",formatDouble(1.234));
		assertEquals(""1.24"",formatDouble(1.235));
	}
	private String formatDouble(double d1) {
		NumberFormat nf = NumberFormat.getInstance();
		nf.setMaximumFractionDigits(significantDigits);
		return nf.format(d1);
	}
	private String[] paymentDates ={
	""""}
	;
}",0,1,0,0
"public boolean readFont(FontFileReader in, String header, String name) throws IOException {
	 initializeFont(in);
	 if (!checkTTC(header, name)) {
		 if (name == null) {
			 throw new IllegalArgumentException( ""For TrueType collection you must specify which font "" + ""to select (-ttcname)"");
		 }
		 else {
			 throw new IOException( ""Name does not exist in the TrueType collection: "" + name);
		 }
	 }
	 readDirTabs();
	 readFontHeader();
	 getNumGlyphs();
	 if (log.isDebugEnabled()) {
		 log.debug(""Number of glyphs in font: "" + numberOfGlyphs);
	 }
	 readHorizontalHeader();
	 readHorizontalMetrics();
	 initAnsiWidths();
	 readPostScript();
	 readOS2();
	 determineAscDesc();
	 readName();
	 boolean pcltFound = readPCLT();
	 boolean valid = readCMAP();
	 if (!valid) {
		 return false;
	 }
	 createCMaps();
	 updateBBoxAndOffset();
	 if (useKerning) {
		 readKerning();
	 }
	 handleCharacterSpacing(in);
	 guessVerticalMetricsFromGlyphBBox();
	 return true;
 }",0,0,1,0
"public class OperatorWrapper {
	 private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(OperatorWrapper.class);
	 private static final DecimalFormat DECIMAL_FORMATTER = new DecimalFormat(""#.##"");
	 private static final String UNKNOWN_OPERATOR = ""UNKNOWN_OPERATOR"";
	 private static final int NO_SPILL_METRIC_INDEX = Integer.MIN_VALUE;
	 private final int major;
	 private final List<ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String>> opsAndHosts;
	 private final OperatorProfile firstProfile;
	 private final CoreOperatorType operatorType;
	 private final String operatorName;
	 private final int size;
	 private final int timeSkewMin;
	 private final double timeSkewRatio;
	 private final int scanWaitMin;
	 private final double waitSkewRatio;
	 public OperatorWrapper(int major, List<ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String>> opsAndHostsList, Map<String, String> phyOperMap, DrillConfig config) {
		 timeSkewMin = config.getInt(ExecConstants.PROFILE_WARNING_TIME_SKEW_MIN);
		 timeSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_PROCESS);
		 scanWaitMin = config.getInt(ExecConstants.PROFILE_WARNING_SCAN_WAIT_MIN);
		 waitSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_WAIT);
		 Preconditions.checkArgument(opsAndHostsList.size() > 0);
		 this.major = major;
		 firstProfile = opsAndHostsList.get(0).getLeft().getLeft();
		 operatorType = CoreOperatorType.valueOf(firstProfile.getOperatorType());
		 String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();
		 String extractedOpName = phyOperMap.get(path);
		 String inferredOpName = operatorType == null ? UNKNOWN_OPERATOR : operatorType.toString();
		 if (extractedOpName == null || inferredOpName.contains(extractedOpName) || extractedOpName.endsWith(""_EXCHANGE"")) {
			 operatorName = inferredOpName;
		 }
		 else {
			 operatorName = extractedOpName;
		 }
		 this.opsAndHosts = opsAndHostsList;
		 size = opsAndHostsList.size();
	 }
	 public String getDisplayName() {
		 final String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();
		 return String.format(""%s - %s"", path, operatorName);
	 }
	 public String getId() {
		 return String.format(""operator-%d-%d"", major, opsAndHosts.get(0).getLeft().getLeft().getOperatorId());
	 }
	 public static final String [] OPERATOR_COLUMNS = {
	 OperatorTblTxt.MINOR_FRAGMENT, OperatorTblTxt.HOSTNAME, OperatorTblTxt.SETUP_TIME, OperatorTblTxt.PROCESS_TIME, OperatorTblTxt.WAIT_TIME, OperatorTblTxt.MAX_BATCHES, OperatorTblTxt.MAX_RECORDS, OperatorTblTxt.PEAK_MEMORY }
	;
	 public static final String [] OPERATOR_COLUMNS_TOOLTIP = {
	 OperatorTblTooltip.MINOR_FRAGMENT, OperatorTblTooltip.HOSTNAME, OperatorTblTooltip.SETUP_TIME, OperatorTblTooltip.PROCESS_TIME, OperatorTblTooltip.WAIT_TIME, OperatorTblTooltip.MAX_BATCHES, OperatorTblTooltip.MAX_RECORDS, OperatorTblTooltip.PEAK_MEMORY }
	;
	 public String getContent() {
		 TableBuilder builder = new TableBuilder(OPERATOR_COLUMNS, OPERATOR_COLUMNS_TOOLTIP, true);
		 Map<String, String> attributeMap = new HashMap<>();
		 for (ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String> ip : opsAndHosts) {
			 int minor = ip.getLeft().getRight();
			 OperatorProfile op = ip.getLeft().getLeft();
			 attributeMap.put(HtmlAttribute.DATA_ORDER, String.valueOf(minor));
			 String path = new OperatorPathBuilder().setMajor(major).setMinor(minor).setOperator(op).build();
			 builder.appendCell(path, attributeMap);
			 builder.appendCell(ip.getRight());
			 builder.appendNanos(op.getSetupNanos());
			 builder.appendNanos(op.getProcessNanos());
			 builder.appendNanos(op.getWaitNanos());
			 long maxBatches = Long.MIN_VALUE;
			 long maxRecords = Long.MIN_VALUE;
			 for (StreamProfile sp : op.getInputProfileList()) {
				 maxBatches = Math.max(sp.getBatches(), maxBatches);
				 maxRecords = Math.max(sp.getRecords(), maxRecords);
			 }
			 builder.appendFormattedInteger(maxBatches);
			 builder.appendFormattedInteger(maxRecords);
			 builder.appendBytes(op.getPeakLocalMemoryAllocated());
		 }
		 return builder.build();
	 }
	 public static final String[] OPERATORS_OVERVIEW_COLUMNS = {
	 OverviewTblTxt.OPERATOR_ID, OverviewTblTxt.TYPE_OF_OPERATOR, OverviewTblTxt.AVG_SETUP_TIME, OverviewTblTxt.MAX_SETUP_TIME, OverviewTblTxt.AVG_PROCESS_TIME, OverviewTblTxt.MAX_PROCESS_TIME, OverviewTblTxt.MIN_WAIT_TIME, OverviewTblTxt.AVG_WAIT_TIME, OverviewTblTxt.MAX_WAIT_TIME, OverviewTblTxt.PERCENT_FRAGMENT_TIME, OverviewTblTxt.PERCENT_QUERY_TIME, OverviewTblTxt.ROWS, OverviewTblTxt.AVG_PEAK_MEMORY, OverviewTblTxt.MAX_PEAK_MEMORY }
	;
	 public static final String[] OPERATORS_OVERVIEW_COLUMNS_TOOLTIP = {
	 OverviewTblTooltip.OPERATOR_ID, OverviewTblTooltip.TYPE_OF_OPERATOR, OverviewTblTooltip.AVG_SETUP_TIME, OverviewTblTooltip.MAX_SETUP_TIME, OverviewTblTooltip.AVG_PROCESS_TIME, OverviewTblTooltip.MAX_PROCESS_TIME, OverviewTblTooltip.MIN_WAIT_TIME, OverviewTblTooltip.AVG_WAIT_TIME, OverviewTblTooltip.MAX_WAIT_TIME, OverviewTblTooltip.PERCENT_FRAGMENT_TIME, OverviewTblTooltip.PERCENT_QUERY_TIME, OverviewTblTooltip.ROWS, OverviewTblTooltip.AVG_PEAK_MEMORY, OverviewTblTooltip.MAX_PEAK_MEMORY }
	;
	 private static final String[] OPERATOR_OVERVIEW_BGCOLOR_PALETTE = {
	""#ffffff"",""#f2f2f2""}
	;
	 public void addSummary(TableBuilder tb, Map<String, Long> majorFragmentBusyTally, long majorFragmentBusyTallyTotal) {
		 String opTblBgColor = OPERATOR_OVERVIEW_BGCOLOR_PALETTE[major%OPERATOR_OVERVIEW_BGCOLOR_PALETTE.length];
		 String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();
		 tb.appendCell(path, opTblBgColor, null);
		 tb.appendCell(operatorName);
		 int spillCycleMetricIndex = getSpillCycleMetricIndex(operatorType);
		 boolean isSpillableOp = (spillCycleMetricIndex != NO_SPILL_METRIC_INDEX);
		 boolean hasSpilledToDisk = false;
		 boolean isScanOp = operatorName.endsWith(""SCAN"");
		 long majorBusyNanos = majorFragmentBusyTally.get(new OperatorPathBuilder().setMajor(major).build());
		 double setupSum = 0.0;
		 double processSum = 0.0;
		 double waitSum = 0.0;
		 double memSum = 0.0;
		 double spillCycleSum = 0.0;
		 long spillCycleMax = 0L;
		 long recordSum = 0L;
		 final List<ImmutablePair<OperatorProfile, Integer>> opList = new ArrayList<>();
		 for (ImmutablePair<ImmutablePair<OperatorProfile, Integer>,String> ip : opsAndHosts) {
			 OperatorProfile profile = ip.getLeft().getLeft();
			 setupSum += profile.getSetupNanos();
			 processSum += profile.getProcessNanos();
			 waitSum += profile.getWaitNanos();
			 memSum += profile.getPeakLocalMemoryAllocated();
			 for (final StreamProfile sp : profile.getInputProfileList()) {
				 recordSum += sp.getRecords();
			 }
			 opList.add(ip.getLeft());
			 if (isSpillableOp) {
				 for (MetricValue metricVal : profile.getMetricList()) {
					 if (metricVal.getMetricId() == spillCycleMetricIndex) {
						 long spillCycles = metricVal.getLongValue();
						 spillCycleMax = Math.max(spillCycles, spillCycleMax);
						 spillCycleSum += spillCycles;
						 hasSpilledToDisk = (spillCycleSum > 0.0);
					 }
				 }
			 }
		 }
		 final ImmutablePair<OperatorProfile, Integer> longSetup = Collections.max(opList, Comparators.setupTime);
		 tb.appendNanos(Math.round(setupSum / size));
		 tb.appendNanos(longSetup.getLeft().getSetupNanos());
		 Map<String, String> timeSkewMap = null;
		 final ImmutablePair<OperatorProfile, Integer> longProcess = Collections.max(opList, Comparators.processTime);
		 long avgProcTime = Math.round(processSum / size);
		 tb.appendNanos(avgProcTime);
		 long maxProcTime = longProcess.getLeft().getProcessNanos();
		 double maxSkew = (avgProcTime > 0) ? maxProcTime/Double.valueOf(avgProcTime) : 0.0d;
		 if (avgProcTime > TimeUnit.SECONDS.toNanos(timeSkewMin) && maxSkew > timeSkewRatio ) {
			 timeSkewMap = new HashMap<>();
			 timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);
			 timeSkewMap.put(HtmlAttribute.TITLE, ""One fragment took "" + DECIMAL_FORMATTER.format(maxSkew) + "" longer than average"");
			 timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
		 }
		 tb.appendNanos(maxProcTime, timeSkewMap);
		 final ImmutablePair<OperatorProfile, Integer> shortWait = Collections.min(opList, Comparators.waitTime);
		 final ImmutablePair<OperatorProfile, Integer> longWait = Collections.max(opList, Comparators.waitTime);
		 tb.appendNanos(shortWait.getLeft().getWaitNanos());
		 long avgWaitTime = Math.round(waitSum / size);
		 Map<String, String> slowScanMap = null;
		 if (isScanOp && (avgWaitTime > TimeUnit.SECONDS.toNanos(scanWaitMin)) && (avgWaitTime > avgProcTime)) {
			 slowScanMap = new HashMap<>();
			 slowScanMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SCAN_WAIT_TAG);
			 slowScanMap.put(HtmlAttribute.TITLE, ""Avg Wait Time &gt;
			 Avg Processing Time"");
			 slowScanMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
		 }
		 tb.appendNanos(avgWaitTime, slowScanMap);
		 long maxWaitTime = longWait.getLeft().getWaitNanos();
		 timeSkewMap = null;
		 maxSkew = (avgWaitTime > 0) ? maxWaitTime/Double.valueOf(avgWaitTime) : 0.0d;
		 if (avgWaitTime > TimeUnit.SECONDS.toNanos(timeSkewMin) && maxSkew > waitSkewRatio) {
			 timeSkewMap = new HashMap<>();
			 timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);
			 timeSkewMap.put(HtmlAttribute.TITLE, ""One fragment waited "" + DECIMAL_FORMATTER.format(maxSkew) + "" longer than average"");
			 timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
		 }
		 tb.appendNanos(maxWaitTime, timeSkewMap);
		 tb.appendPercent(processSum / majorBusyNanos);
		 tb.appendPercent(processSum / majorFragmentBusyTallyTotal);
		 tb.appendFormattedInteger(recordSum);
		 final ImmutablePair<OperatorProfile, Integer> peakMem = Collections.max(opList, Comparators.operatorPeakMemory);
		 Map<String, String> avgSpillMap = null;
		 Map<String, String> maxSpillMap = null;
		 if (hasSpilledToDisk) {
			 avgSpillMap = new HashMap<>();
			 double avgSpillCycle = spillCycleSum/size;
			 avgSpillMap.put(HtmlAttribute.TITLE, DECIMAL_FORMATTER.format(avgSpillCycle) + "" spills on average"");
			 avgSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
			 avgSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG);
			 avgSpillMap.put(HtmlAttribute.SPILLS, DECIMAL_FORMATTER.format(avgSpillCycle));
			 maxSpillMap = new HashMap<>();
			 maxSpillMap.put(HtmlAttribute.TITLE, ""Most # spills: "" + spillCycleMax);
			 maxSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
			 maxSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG);
			 maxSpillMap.put(HtmlAttribute.SPILLS, String.valueOf(spillCycleMax));
		 }
		 tb.appendBytes(Math.round(memSum / size), avgSpillMap);
		 tb.appendBytes(peakMem.getLeft().getPeakLocalMemoryAllocated(), maxSpillMap);
	 }
	 private int getSpillCycleMetricIndex(CoreOperatorType operatorType) {
		 if (operatorType == null) {
			 return NO_SPILL_METRIC_INDEX;
		 }
		 String metricName;
		 switch (operatorType) {
			 case EXTERNAL_SORT: metricName = ""SPILL_COUNT"";
			 break;
			 case HASH_AGGREGATE: case HASH_JOIN: metricName = ""SPILL_CYCLE"";
			 break;
			 default: return NO_SPILL_METRIC_INDEX;
		 }
		 int metricIndex = 0;
		 String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());
		 for (String name : metricNames) {
			 if (name.equalsIgnoreCase(metricName)) {
				 return metricIndex;
			 }
			 metricIndex++;
		 }
		 return NO_SPILL_METRIC_INDEX;
	 }
	 public String getMetricsTable() {
		 if (operatorType == null) {
			 return """";
		 }
		 final String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());
		 if (metricNames == null) {
			 return """";
		 }
		 final String[] metricsTableColumnNames = new String[metricNames.length + 1];
		 metricsTableColumnNames[0] = ""Minor Fragment"";
		 int i = 1;
		 for (final String metricName : metricNames) {
			 metricsTableColumnNames[i++] = metricName;
		 }
		 final TableBuilder builder = new TableBuilder(metricsTableColumnNames, null);
		 for (final ImmutablePair<ImmutablePair<OperatorProfile, Integer>,String> ip : opsAndHosts) {
			 final OperatorProfile op = ip.getLeft().getLeft();
			 builder.appendCell( new OperatorPathBuilder() .setMajor(major) .setMinor(ip.getLeft().getRight()) .setOperator(op) .build());
			 final Number[] values = new Number[metricNames.length];
			 final Set<Integer> unknownMetrics = new TreeSet<>();
			 for (final MetricValue metric : op.getMetricList()) {
				 if (metric.getMetricId() < metricNames.length) {
					 if (metric.hasLongValue()) {
						 values[metric.getMetricId()] = metric.getLongValue();
					 }
					 else if (metric.hasDoubleValue()) {
						 values[metric.getMetricId()] = metric.getDoubleValue();
					 }
				 }
				 else {
					 unknownMetrics.add(metric.getMetricId());
				 }
			 }
			 for (final Number value : values) {
				 if (value != null) {
					 builder.appendFormattedNumber(value);
				 }
				 else {
					 builder.appendCell("""");
				 }
			 }
		 }
		 return builder.build();
	 }
	 private class OperatorTblTxt {
		 static final String MINOR_FRAGMENT = ""Minor Fragment"";
		 static final String HOSTNAME = ""Hostname"";
		 static final String SETUP_TIME = ""Setup Time"";
		 static final String PROCESS_TIME = ""Process Time"";
		 static final String WAIT_TIME = ""Wait Time"";
		 static final String MAX_BATCHES = ""Max Batches"";
		 static final String MAX_RECORDS = ""Max Records"";
		 static final String PEAK_MEMORY = ""Peak Memory"";
	 }
	 private class OperatorTblTooltip {
		 static final String MINOR_FRAGMENT = ""Operator's Minor Fragment"";
		 static final String HOSTNAME = ""Host on which the minor fragment ran"";
		 static final String SETUP_TIME = ""Setup Time for the minor fragment's operator"";
		 static final String PROCESS_TIME = ""Process Time for the minor fragment's operator"";
		 static final String WAIT_TIME = ""Wait Time for the minor fragment's operator"";
		 static final String MAX_BATCHES = ""Max Batches processed by the minor fragment's operator"";
		 static final String MAX_RECORDS = ""Max Records processed by the minor fragment's operator"";
		 static final String PEAK_MEMORY = ""Peak Memory usage by the minor fragment's operator"";
	 }
	 private class OverviewTblTxt {
		 static final String OPERATOR_ID = ""Operator ID"";
		 static final String TYPE_OF_OPERATOR = ""Type"";
		 static final String AVG_SETUP_TIME = ""Avg Setup Time"";
		 static final String MAX_SETUP_TIME = ""Max Setup Time"";
		 static final String AVG_PROCESS_TIME = ""Avg Process Time"";
		 static final String MAX_PROCESS_TIME = ""Max Process Time"";
		 static final String MIN_WAIT_TIME = ""Min Wait Time"";
		 static final String AVG_WAIT_TIME = ""Avg Wait Time"";
		 static final String MAX_WAIT_TIME = ""Max Wait Time"";
		 static final String PERCENT_FRAGMENT_TIME = ""% Fragment Time"";
		 static final String PERCENT_QUERY_TIME = ""% Query Time"";
		 static final String ROWS = ""Rows"";
		 static final String AVG_PEAK_MEMORY = ""Avg Peak Memory"";
		 static final String MAX_PEAK_MEMORY = ""Max Peak Memory"";
	 }
	 private class OverviewTblTooltip {
		 static final String OPERATOR_ID = ""Operator ID"";
		 static final String TYPE_OF_OPERATOR = ""Operator Type"";
		 static final String AVG_SETUP_TIME = ""Average time in setting up fragments"";
		 static final String MAX_SETUP_TIME = ""Longest time a fragment took in setup"";
		 static final String AVG_PROCESS_TIME = ""Average process time for a fragment"";
		 static final String MAX_PROCESS_TIME = ""Longest process time of any fragment"";
		 static final String MIN_WAIT_TIME = ""Shortest time a fragment spent in waiting"";
		 static final String AVG_WAIT_TIME = ""Average wait time for a fragment"";
		 static final String MAX_WAIT_TIME = ""Longest time a fragment spent in waiting"";
		 static final String PERCENT_FRAGMENT_TIME = ""Percentage of the total fragment time that was spent on the operator"";
		 static final String PERCENT_QUERY_TIME = ""Percentage of the total query time that was spent on the operator"";
		 static final String ROWS = ""Rows emitted by scans, or consumed by other operators"";
		 static final String AVG_PEAK_MEMORY = ""Average memory consumption by a fragment"";
		 static final String MAX_PEAK_MEMORY = ""Highest memory consumption by a fragment"";
	 }
}",1,1,0,0
"public final void rule__Action__OperatorAssignment_2_2() throws RecognitionException {
	 int stackSize = keepStackSize();
	 try {
		 {
			 {
				 before(grammarAccess.getActionAccess().getOperatorAlternatives_2_2_0());
				 {
					 pushFollow(FOLLOW_2);
					 rule__Action__OperatorAlternatives_2_2_0();
					 state._fsp--;
				 }
				 after(grammarAccess.getActionAccess().getOperatorAlternatives_2_2_0());
			 }
		 }
	 }
	 catch (RecognitionException re) {
		 reportError(re);
		 recover(input,re);
	 }
	 finally {
		 restoreStackSize(stackSize);
	 }
	 return ;
 }",0,0,1,0
"public class JUnit4TestMethodAdapter implements Test {
	 private final Class testClass;
	 private final String[] methodNames;
	 private final Runner runner;
	 private final Cache cache;
	 public JUnit4TestMethodAdapter(final Class testClass, final String[] methodNames) {
		 if (testClass == null) {
			 throw new IllegalArgumentException(""testClass is <null>"");
		 }
		 if (methodNames == null) {
			 throw new IllegalArgumentException(""methodNames is <null>"");
		 }
		 for (int i = 0;
		 i < methodNames.length;
		 i++) {
			 if (methodNames[i] == null) {
				 throw new IllegalArgumentException(""method name #"" + i + "" is <null>"");
			 }
			 if (methodNames[i].length() == 0) {
				 throw new IllegalArgumentException(""method name #"" + i + "" is empty"");
			 }
		 }
		 this.testClass = testClass;
		 this.methodNames = (String[]) methodNames.clone();
		 this.cache = Cache.instance;
		 Request request;
		 if (methodNames.length == 1) {
			 request = Request.method(testClass, methodNames[0]);
		 }
		 else {
			 request = Request.aClass(testClass).filterWith( new MultipleMethodsFilter(testClass, methodNames));
		 }
		 runner = request.getRunner();
	 }
	 public int countTestCases() {
		 return runner.testCount();
	 }
	 public Description getDescription() {
		 return runner.getDescription();
	 }
	 public List getTests() {
		 return cache.asTestList(getDescription());
	 }
	 public Class getTestClass() {
		 return testClass;
	 }
	 public void run(final TestResult result) {
		 runner.run(cache.getNotifier(result));
	 }
	 public String toString() {
		 String testClassName = testClass.getName();
		 StringBuilder buf = new StringBuilder(testClassName.length() + 12 * methodNames.length) .append(':');
		 if (methodNames.length != 0) {
			 buf.append(methodNames[0]);
			 for (int i = 1;
			 i < methodNames.length;
			 i++) {
				 buf.append(',') .append(methodNames[i]);
			 }
		 }
		 return buf.toString();
	 }
	 private static final class MultipleMethodsFilter extends Filter {
		 private final Description methodsListDescription;
		 private final Class testClass;
		 private final String[] methodNames;
		 private MultipleMethodsFilter(Class testClass, String[] methodNames) {
			 if (testClass == null) {
				 throw new IllegalArgumentException(""testClass is <null>"");
			 }
			 if (methodNames == null) {
				 throw new IllegalArgumentException(""methodNames is <null>"");
			 }
			 methodsListDescription = Description.createSuiteDescription(testClass);
			 for (int i = 0;
			 i < methodNames.length;
			 i++) {
				 methodsListDescription.addChild( Description.createTestDescription(testClass, methodNames[i]));
			 }
			 this.testClass = testClass;
			 this.methodNames = methodNames;
		 }
		 public boolean shouldRun(Description description) {
			 if (methodNames.length == 0) {
				 return false;
			 }
			 if (description.isTest()) {
				 Iterator it = methodsListDescription.getChildren().iterator();
				 while (it.hasNext()) {
					 Description methodDescription = (Description) it.next();
					 if (methodDescription.equals(description)) {
						 return true;
					 }
				 }
			 }
			 else {
				 Iterator it = description.getChildren().iterator();
				 while (it.hasNext()) {
					 Description each = (Description) it.next();
					 if (shouldRun(each)) {
						 return true;
					 }
				 }
			 }
			 return false;
		 }
		 public String describe() {
			 StringBuilder buf = new StringBuilder(40);
			 if (methodNames.length == 0) {
				 buf.append(""No methods"");
			 }
			 else {
				 buf.append(methodNames.length == 1 ? ""Method"" : ""Methods"");
				 buf.append(' ');
				 buf.append(methodNames[0]);
				 for (int i = 1;
				 i < methodNames.length;
				 i++) {
					 buf.append(',').append(methodNames[i]);
				 }
			 }
			 buf.append('(').append(testClass.getName()).append(')');
			 return buf.toString();
		 }
	 }
	 private static final class Cache extends JUnit4TestAdapterCache {
		 private static final long serialVersionUID = 8454901854293461610L;
		private static final Cache instance = new Cache();
		public static JUnit4TestAdapterCache getDefault() {
			 return instance;
		}
		public RunNotifier getNotifier(final TestResult result) {
			 RunNotifier notifier = new RunNotifier();
			 notifier.addListener(new RunListener() {
				 public void testFailure(Failure failure) throws Exception {
					 result.addError(asTest(failure.getDescription()), failure.getException());
				 }
				 public void testFinished(Description description) throws Exception {
					 result.endTest(asTest(description));
				 }
				 public void testStarted(Description description) throws Exception {
					 result.startTest(asTest(description));
				 }
			 }
			);
			 return notifier;
		}
	 }
}",0,0,0,0
"public class AvaticaMonitor extends AbstractMonitor implements MetricsSystem{
	 private static final Logger log = new Logger(AvaticaMonitor.class);
	 private final ConcurrentMap<String, AtomicLong> counters = new ConcurrentHashMap<>();
	 private final ConcurrentMap<String, Gauge<?>> gauges = new ConcurrentHashMap<>();
	 public boolean doMonitor(final ServiceEmitter emitter) {
		 for (final Map.Entry<String, AtomicLong> entry : counters.entrySet()) {
			 final String name = entry.getKey();
			 final long value = entry.getValue().getAndSet(0);
			 emitter.emit(ServiceMetricEvent.builder().build(fullMetricName(name), value));
		 }
		 for (Map.Entry<String, Gauge<?>> entry : gauges.entrySet()) {
			 final String name = entry.getKey();
			 final Object value = entry.getValue().getValue();
			 if (value instanceof Number) {
				 emitter.emit(ServiceMetricEvent.builder().build(fullMetricName(name), (Number) value));
			 }
			 else {
				 log.debug(""Not emitting gauge[%s] since value[%s] type was[%s]."", name, value, value.getClass().getName());
			 }
		 }
		 return true;
	 }
	 public Timer getTimer(final String name) {
		 final AtomicLong counter = makeCounter(name);
		 return new Timer() {
			 public Context start() {
				 final long start = System.currentTimeMillis();
				 final AtomicBoolean closed = new AtomicBoolean();
				 return new Context() {
					 public void close() {
						 if (closed.compareAndSet(false, true)) {
							 counter.addAndGet(System.currentTimeMillis() - start);
						 }
					 }
				 }
				;
			 }
		 }
		;
	 }
	 public Histogram getHistogram(final String name) {
		 return new Histogram() {
			 public void update(int i) {
			 }
			 public void update(long l) {
			 }
		 }
		;
	 }
	 public Meter getMeter(final String name) {
		 final AtomicLong counter = makeCounter(name);
		 return new Meter() {
			 public void mark() {
				 counter.incrementAndGet();
			 }
			 public void mark(long events) {
				 counter.addAndGet(events);
			 }
		 }
		;
	 }
	 public Counter getCounter(final String name) {
		 final AtomicLong counter = makeCounter(name);
		 return new Counter() {
			 public void increment() {
				 counter.incrementAndGet();
			 }
			 public void increment(long n) {
				 counter.addAndGet(n);
			 }
			 public void decrement() {
				 counter.decrementAndGet();
			 }
			 public void decrement(long n) {
				 counter.addAndGet(-n);
			 }
		 }
		;
	 }
	 public <T> void register(final String name, final Gauge<T> gauge) {
		 if (gauges.putIfAbsent(name, gauge) != null) {
			 log.warn(""Ignoring gauge[%s], one with the same name was already registered."", name);
		 }
	 }
	 private AtomicLong makeCounter(final String name) {
		 counters.putIfAbsent(name, new AtomicLong());
		 return counters.get(name);
	 }
	 private String fullMetricName(final String name) {
		 return StringUtils.replace(name, ""org.apache.calcite.avatica"", ""avatica"").replace('.', '/');
	 }
}",0,0,0,0
"public Message getMessage() {
	 DataOutputBuffer dob = new DataOutputBuffer();
	 try {
		 serializer.serialize(this, dob);
	 }
	 catch (IOException e) {
		 throw new IOError(e);
	 }
	 return new Message(FBUtilities.getLocalAddress(), StorageService.Verb.INDEX_SCAN, Arrays.copyOf(dob.getData(), dob.getLength()));
 }",0,0,0,0
"public abstract class DrillScanRelBase extends TableScan implements DrillRelNode {
	 protected GroupScan groupScan;
	 protected final DrillTable drillTable;
	 public DrillScanRelBase(RelOptCluster cluster, RelTraitSet traits, RelOptTable table, final List<SchemaPath> columns) {
		 super(cluster, traits, table);
		 this.drillTable = Utilities.getDrillTable(table);
		 assert drillTable != null;
		 try {
			 this.groupScan = drillTable.getGroupScan().clone(columns);
		 }
		 catch (final IOException e) {
			 throw new DrillRuntimeException(""Failure creating scan."", e);
		 }
	 }
	 public DrillScanRelBase(RelOptCluster cluster, RelTraitSet traits, GroupScan grpScan, RelOptTable table) {
		 super(cluster, traits, table);
		 DrillTable unwrap = table.unwrap(DrillTable.class);
		 if (unwrap == null) {
			 unwrap = table.unwrap(DrillTranslatableTable.class).getDrillTable();
		 }
		 this.drillTable = unwrap;
		 assert drillTable != null;
		 this.groupScan = grpScan;
	 }
	 public DrillTable getDrillTable() {
		 return drillTable;
	 }
	 public GroupScan getGroupScan() {
		 return groupScan;
	 }
	 public double estimateRowCount(RelMetadataQuery mq) {
		 return mq.getRowCount(this);
	 }
	 public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {
		 double dRows = estimateRowCount(mq);
		 double dCpu = dRows + 1;
		 double dIo = 0;
		 return planner.getCostFactory().makeCost(dRows, dCpu, dIo);
	 }
}",0,1,0,0
"public class DefaultJobMasterServiceFactory implements JobMasterServiceFactory {
	private final JobMasterConfiguration jobMasterConfiguration;
	private final SlotPoolFactory slotPoolFactory;
	private final SchedulerFactory schedulerFactory;
	private final RpcService rpcService;
	private final HighAvailabilityServices haServices;
	private final JobManagerSharedServices jobManagerSharedServices;
	private final HeartbeatServices heartbeatServices;
	private final JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory;
	private final FatalErrorHandler fatalErrorHandler;
	public DefaultJobMasterServiceFactory(JobMasterConfiguration jobMasterConfiguration,SlotPoolFactory slotPoolFactory,SchedulerFactory schedulerFactory,RpcService rpcService,HighAvailabilityServices haServices,JobManagerSharedServices jobManagerSharedServices,HeartbeatServices heartbeatServices,JobManagerJobMetricGroupFactory jobManagerJobMetricGroupFactory,FatalErrorHandler fatalErrorHandler) {
		this.jobMasterConfiguration = jobMasterConfiguration;
		this.slotPoolFactory = slotPoolFactory;
		this.schedulerFactory = schedulerFactory;
		this.rpcService = rpcService;
		this.haServices = haServices;
		this.jobManagerSharedServices = jobManagerSharedServices;
		this.heartbeatServices = heartbeatServices;
		this.jobManagerJobMetricGroupFactory = jobManagerJobMetricGroupFactory;
		this.fatalErrorHandler = fatalErrorHandler;
	}
	public JobMaster createJobMasterService(JobGraph jobGraph, OnCompletionActions jobCompletionActions, ClassLoader userCodeClassloader) throws Exception {
		return new JobMaster(rpcService,jobMasterConfiguration,ResourceID.generate(),jobGraph,haServices,slotPoolFactory,schedulerFactory,jobManagerSharedServices,heartbeatServices,jobManagerJobMetricGroupFactory,jobCompletionActions,fatalErrorHandler,userCodeClassloader);
	}
}",1,1,0,0
"private void appendXmlComparison1(SQLBuffer buf, String op, FilterValue lhs, FilterValue rhs) {
	 boolean castrhs = false;
	 Class<T> rc = Filters.wrap(rhs.getType());
	 int type = 0;
	 if (rhs.isConstant()) {
		 type = getJDBCType(JavaTypes.getTypeCode(rc), false);
		 castrhs = true;
	 }
	 appendXmlExists(buf, lhs);
	 buf.append("" "").append(op).append("" "");
	 buf.append(""$"");
	 if (castrhs) buf.append(""Parm"");
	 else rhs.appendTo(buf);
	 buf.append(""]' PASSING "");
	 appendXmlVar(buf, lhs);
	 buf.append("", "");
	 if (castrhs) appendCast(buf, rhs, type);
	 else rhs.appendTo(buf);
	 buf.append("" AS \"""");
	 if (castrhs) buf.append(""Parm"");
	 else rhs.appendTo(buf);
	 buf.append(""\"")"");
 }",0,0,1,0
"public class StoreInfo implements ValueChangeListener, Item, NetworkConnectionListener {
	 Logger mLogger = null;
	 private Store store;
	 private Session mSession;
	 private String storeID;
	 private StoreNode storeNode;
	 private Vector<FolderInfo> children;
	 private boolean connected = false;
	 private boolean available = false;
	 private int mPreferredStatus = FolderInfo.CONNECTED;
	 private boolean popStore = false;
	 private UserProfile defaultProfile;
	 private NetworkConnection connection;
	 private String user;
	 private String password;
	 private String server;
	 private String protocol;
	 private int port;
	 private URLName url;
	 private String sslSetting = ""none"";
	 private ActionThread storeThread;
	 private FolderInfo trashFolder;
	 private boolean useSubscribed = false;
	 private ConnectionListener connectionListener;
	 private AuthenticatorUI mAuthenticator;
	 public StoreInfo(String sid) {
		 setStoreID(sid);
		 configureStore();
	 }
	 public void configureStore() {
		 connected = false;
		 available = false;
		 protocol = Pooka.getProperty(""Store."" + storeID + "".protocol"", """");
		 if (protocol.equalsIgnoreCase(""pop3"")) {
			 user = """";
			 password = """";
			 server = ""localhost"";
			 if (Pooka.getProperty(getStoreProperty() + "".useMaildir"", ""unset"").equalsIgnoreCase(""true"")) protocol = ""maildir"";
			 else protocol = ""mbox"";
			 port = -1;
			 popStore = true;
		 }
		 else {
			 popStore = false;
			 user = Pooka.getProperty(""Store."" + storeID + "".user"", """");
			 password = Pooka.getProperty(""Store."" + storeID + "".password"", """");
			 String portValue = Pooka.getProperty(""Store."" + storeID + "".port"", """");
			 port = -1;
			 if (!portValue.equals("""")) {
				 try {
					 port = Integer.parseInt(portValue);
				 }
				 catch (Exception e) {
				 }
			 }
			 if (!password.equals("""")) password = net.suberic.util.gui.propedit.PasswordEditorPane.descrambleString(password);
			 server = Pooka.getProperty(""Store."" + storeID + "".server"", """");
			 sslSetting = Pooka.getProperty(getStoreProperty() + "".SSL"", ""none"");
			 if (sslSetting.equalsIgnoreCase(""true"")) {
				 Pooka.setProperty(getStoreProperty() + "".SSL"", ""ssl"");
				 sslSetting = ""ssl"";
			 }
			 else if (sslSetting.equalsIgnoreCase(""false"")) {
				 Pooka.setProperty(getStoreProperty() + "".SSL"", ""none"");
				 sslSetting = ""none"";
			 }
			 if (sslSetting.equals(""ssl"")) {
				 if (protocol.equals(""imap"")) protocol = ""imaps"";
			 }
		 }
		 Properties p = loadProperties();
		 if (protocol.equalsIgnoreCase(""maildir"")) {
			 url = new URLName(protocol, server, port, p.getProperty(""mail.store.maildir.baseDir""), user, password);
		 }
		 else {
			 url = new URLName(protocol, server, port, """", user, password);
		 }
		 getLogger().fine(""creating authenticator"");
		 mAuthenticator = Pooka.getUIFactory().createAuthenticatorUI();
		 try {
			 mSession = Session.getInstance(p, mAuthenticator);
			 updateSessionDebug();
			 store = mSession.getStore(url);
			 available=true;
		 }
		 catch (NoSuchProviderException nspe) {
			 Pooka.getUIFactory().showError(Pooka.getProperty(""error.loadingStore"", ""Unable to load Store "") + getStoreID(), nspe);
			 available=false;
		 }
		 if (Pooka.getProperty(""Store."" + storeID + "".folderList"", """").equals("""")) Pooka.setProperty(""Store."" + storeID + "".folderList"", ""INBOX"");
		 useSubscribed = Pooka.getProperty(getStoreProperty() + "".useSubscribed"", ""false"").equalsIgnoreCase(""true"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty());
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".folderList"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".defaultProfile"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".protocol"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".user"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".password"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".server"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".port"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".connection"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".SSL"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".useSubscribed"");
		 Pooka.getResources().addValueChangeListener(this, getStoreProperty() + "".sessionDebug.level"");
		 Pooka.getLogManager().addLogger(getStoreProperty());
		 Pooka.getLogManager().addLogger(getStoreProperty() + "".sessionDebug"");
		 if (available) {
			 connectionListener = new ConnectionListener() {
				 public void disconnected(ConnectionEvent e) {
					 getLogger().log(Level.FINE, ""Store "" + getStoreID() + "" disconnected."");
					 if (isConnected()) {
						 try {
							 if (Pooka.getUIFactory().getMessageNotificationManager() != null) {
								 Pooka.getUIFactory().getMessageNotificationManager().displayMessage(""Disconnected"", ""Disconnected from store "" + getStoreID(), net.suberic.pooka.gui.MessageNotificationManager.WARNING_MESSAGE_TYPE);
							 }
							 disconnectStore();
						 }
						 catch (MessagingException me) {
							 getLogger().log(Level.FINE, ""error disconnecting Store: "" + me.getMessage());
						 }
					 }
				 }
				 public void closed(ConnectionEvent e) {
					 getLogger().log(Level.FINE, ""Store "" + getStoreID() + "" closed."");
					 if (isConnected()) {
						 if (Pooka.getUIFactory().getMessageNotificationManager() != null) {
							 Pooka.getUIFactory().getMessageNotificationManager().displayMessage(""Disconnected"", ""Disconnected from store "" + getStoreID(), net.suberic.pooka.gui.MessageNotificationManager.WARNING_MESSAGE_TYPE);
						 }
						 try {
							 disconnectStore();
						 }
						 catch (MessagingException me) {
							 getLogger().log(Level.FINE, ""error disconnecting Store: "" + me.getMessage());
						 }
					 }
				 }
				 public void opened(ConnectionEvent e) {
					 getLogger().log(Level.FINE, ""Store "" + getStoreID() + "" opened."");
				 }
			 }
			;
			 store.addConnectionListener(connectionListener);
		 }
		 if (storeThread == null) {
			 storeThread = new ActionThread(this.getStoreID() + "" - ActionThread"");
			 storeThread.start();
		 }
		 String defProfileString = Pooka.getProperty(getStoreProperty() + "".defaultProfile"", """");
		 if (defProfileString.length() < 1 || defProfileString.equalsIgnoreCase(UserProfile.S_DEFAULT_PROFILE_KEY)) {
			 defaultProfile = null;
		 }
		 else {
			 defaultProfile = Pooka.getPookaManager().getUserProfileManager().getProfile(defProfileString);
		 }
		 connection = Pooka.getConnectionManager().getConnection(Pooka.getProperty(getStoreProperty() + "".connection"", """"));
		 if (connection == null) {
			 connection = Pooka.getConnectionManager().getDefaultConnection();
		 }
		 if (connection != null) {
			 connection.addConnectionListener(this);
		 }
		 updateChildren();
		 String trashFolderName = Pooka.getProperty(getStoreProperty() + "".trashFolder"", """");
		 if (trashFolderName.length() > 0) {
			 trashFolder = getChild(trashFolderName);
			 if (trashFolder != null) trashFolder.setTrashFolder(true);
		 }
	 }
	 public Properties loadProperties() {
		 Properties p = new Properties(System.getProperties());
		 String realProtocol = Pooka.getProperty(""Store."" + storeID + "".protocol"", """");
		 if (realProtocol.equalsIgnoreCase(""imap"")) {
			 loadImapProperties(p);
		 }
		 else if (realProtocol.equalsIgnoreCase(""pop3"")) {
			 loadPop3Properties(p);
			 String useMaildir = Pooka.getProperty(getStoreProperty() + "".useMaildir"", ""unset"");
			 if (useMaildir.equals(""unset"")) {
				 Pooka.setProperty(getStoreProperty() + "".useMaildir"", ""false"");
				 useMaildir=""false"";
			 }
			 if ( useMaildir.equalsIgnoreCase(""false"")) {
				 loadMboxProperties(p);
			 }
			 else {
				 loadMaildirProperties(p);
			 }
		 }
		 else if (realProtocol.equalsIgnoreCase(""maildir"")) {
			 loadMaildirProperties(p);
		 }
		 else if (realProtocol.equalsIgnoreCase(""mbox"")) {
			 loadMboxProperties(p);
		 }
		 return p;
	 }
	 void loadImapProperties(Properties p) {
		 p.setProperty(""mail.imap.timeout"", Pooka.getProperty(getStoreProperty() + "".timeout"", Pooka.getProperty(""Pooka.timeout"", ""-1"")));
		 p.setProperty(""mail.imap.connectiontimeout"", Pooka.getProperty(getStoreProperty() + "".connectionTimeout"", Pooka.getProperty(""Pooka.connectionTimeout"", ""-1"")));
		 p.setProperty(""mail.imaps.timeout"", Pooka.getProperty(getStoreProperty() + "".timeout"", Pooka.getProperty(""Pooka.timeout"", ""-1"")));
		 p.setProperty(""mail.imaps.connectiontimeout"", Pooka.getProperty(getStoreProperty() + "".connectionTimeout"", Pooka.getProperty(""Pooka.connectionTimeout"", ""-1"")));
		 if (sslSetting.equals(""ssl"")) {
			 p.setProperty(""mail.imaps.socketFactory.fallback"", Pooka.getProperty(getStoreProperty() + "".SSL.fallback"", ""false""));
		 }
		 else if (sslSetting.equals(""tlsrequired"")) {
			 p.setProperty(""mail.imap.starttls.enable"", ""true"");
		 }
		 else if (sslSetting.equals(""tls"")) {
			 p.setProperty(""mail.imap.starttls.enable"", ""true"");
		 }
		 p.setProperty(""mail.imap.separatestoreconnection"", ""true"");
		 p.setProperty(""mail.imaps.separatestoreconnection"", ""true"");
	 }
	 void loadPop3Properties(Properties p) {
		 if (Pooka.getProperty(getStoreProperty() + "".SSL"", ""false"").equalsIgnoreCase(""true"")) {
			 p.setProperty(""mail.pop3s.socketFactory.fallback"", Pooka.getProperty(getStoreProperty() + "".SSL.fallback"", ""false""));
		 }
	 }
	 void loadMaildirProperties(Properties p) {
		 String mailHome = Pooka.getProperty(getStoreProperty() + "".mailDir"", """");
		 if (mailHome.equals("""")) {
			 mailHome = Pooka.getProperty(""Pooka.defaultMailSubDir"", """");
			 if (mailHome.equals("""")) mailHome = Pooka.getPookaManager().getPookaRoot().getAbsolutePath() + java.io.File.separator + "".pooka"";
			 mailHome = mailHome + java.io.File.separator + storeID;
		 }
		 String userHomeName = Pooka.getPookaManager().getResourceManager().translateName(mailHome + java.io.File.separator + Pooka.getProperty(""Pooka.subFolderName"", ""folders""));
		 p.setProperty(""mail.store.maildir.baseDir"", userHomeName);
		 p.setProperty(""mail.store.maildir.autocreatedir"", ""true"");
	 }
	 void loadMboxProperties(Properties p) {
		 String mailHome = Pooka.getProperty(getStoreProperty() + "".mailDir"", """");
		 if (mailHome.equals("""")) {
			 mailHome = Pooka.getProperty(""Pooka.defaultMailSubDir"", """");
			 if (mailHome.equals("""")) mailHome = Pooka.getPookaManager().getPookaRoot().getAbsolutePath() + java.io.File.separator + "".pooka"";
			 mailHome = mailHome + java.io.File.separator + storeID;
		 }
		 mailHome = Pooka.getPookaManager().getResourceManager().translateName(mailHome);
		 String inboxFileName;
		 if (Pooka.getProperty(getStoreProperty() + "".protocol"", ""imap"").equalsIgnoreCase(""pop3"")) {
			 inboxFileName = mailHome + java.io.File.separator + Pooka.getProperty(""Pooka.inboxName"", ""INBOX"");
		 }
		 else {
			 inboxFileName = Pooka.getProperty(getStoreProperty() + "".inboxLocation"", ""/var/spool/mail/"" + System.getProperty(""user.name""));
		 }
		 String userHomeName = mailHome + java.io.File.separator + Pooka.getProperty(""Pooka.subFolderName"", ""folders"");
		 getLogger().log(Level.FINE, ""for store "" + getStoreID() + "", inboxFileName = "" + inboxFileName + "";
		 userhome = "" + userHomeName);
		 p.setProperty(""mail.mbox.inbox"", inboxFileName);
		 p.setProperty(""mail.mbox.userhome"", userHomeName);
	 }
	 public void updateChildren() {
		 Vector<FolderInfo> newChildren = new Vector<FolderInfo>();
		 List<String> newChildNames = Pooka.getResources().getPropertyAsList(getStoreProperty() + "".folderList"", ""INBOX"");
		 for (String newFolderName: newChildNames) {
			 FolderInfo childFolder = getChild(newFolderName);
			 if (childFolder == null) {
				 childFolder = Pooka.getResourceManager().createFolderInfo(this, newFolderName);
			 }
			 newChildren.add(0, childFolder);
		 }
		 children = newChildren;
		 getLogger().log(Level.FINE, getStoreID() + "": in configureStore. children.size() = "" + children.size());
		 if (storeNode != null) storeNode.loadChildren();
	 }
	 public FolderInfo getChild(String childName) {
		 FolderInfo childFolder = null;
		 String folderName = null, subFolderName = null;
		 if (children != null) {
			 int divider = childName.indexOf('/');
			 if (divider > 0) {
				 folderName = childName.substring(0, divider);
				 if (divider < childName.length() - 1) subFolderName = childName.substring(divider + 1);
			 }
			 else folderName = childName;
			 for (int i = 0;
			 i < children.size();
			 i++) if (((FolderInfo)children.elementAt(i)).getFolderName().equals(folderName)) childFolder = (FolderInfo)children.elementAt(i);
		 }
		 if (childFolder != null && subFolderName != null) return childFolder.getChild(subFolderName);
		 else return childFolder;
	 }
	 public FolderInfo getFolderById(String folderID) {
		 FolderInfo childFolder = null;
		 if (children != null) {
			 for (int i = 0;
			 i < children.size();
			 i++) {
				 FolderInfo possibleMatch = ((FolderInfo)children.elementAt(i)).getFolderById(folderID);
				 if (possibleMatch != null) {
					 return possibleMatch;
				 }
			 }
		 }
		 return null;
	 }
	 public void remove() {
		 try {
			 disconnectStore();
		 }
		 catch (Exception e) {
		 }
		 cleanup();
	 }
	 public void cleanup() {
		 Pooka.getResources().removeValueChangeListener(this);
		 Pooka.getLogManager().removeLogger(getStoreProperty());
		 if (children != null && children.size() > 0) {
			 for (int i = 0;
			 i < children.size();
			 i++) ((FolderInfo)children.elementAt(i)).cleanup();
		 }
		 if (store != null) {
			 store.removeConnectionListener(connectionListener);
		 }
		 if (getStoreThread() != null) {
			 getStoreThread().setStop(true);
		 }
	 }
	 public void valueChanged(String pChangedValue) {
		 final String changedValue = pChangedValue;
		 javax.swing.AbstractAction valueChangedAction = new javax.swing.AbstractAction() {
			 public void actionPerformed(java.awt.event.ActionEvent ae) {
				 List<String> storeList = Pooka.getResources().getPropertyAsList(""Store"", """");
				 if (storeList.contains(getStoreID())) {
					 if (changedValue.equals(getStoreProperty() + "".folderList"")) {
						 updateChildren();
					 }
					 else if (changedValue.equals(getStoreProperty() + "".defaultProfile"")) {
						 String defProfileString = Pooka.getProperty(getStoreProperty() + "".defaultProfile"", """");
						 if (defProfileString.length() < 1 || defProfileString.equalsIgnoreCase(UserProfile.S_DEFAULT_PROFILE_KEY)) {
							 defaultProfile = null;
						 }
						 else {
							 defaultProfile = Pooka.getPookaManager().getUserProfileManager().getProfile(defProfileString);
						 }
					 }
					 else if (changedValue.equals(getStoreProperty() + "".protocol"") || changedValue.equals(getStoreProperty() + "".user"") || changedValue.equals(getStoreProperty() + "".password"") || changedValue.equals(getStoreProperty() + "".server"") || changedValue.equals(getStoreProperty() + "".port"") || changedValue.equals(getStoreProperty() + "".SSL"") ) {
						 if (storeNode != null) {
							 Enumeration childEnum = storeNode.children();
							 Vector v = new Vector();
							 while (childEnum.hasMoreElements()) v.add(childEnum.nextElement());
							 storeNode.removeChildren(v);
						 }
						 children = null;
						 try {
							 disconnectStore();
						 }
						 catch (Exception e) {
						 }
						 getLogger().log(Level.FINE, ""calling configureStore()"");
						 configureStore();
					 }
					 else if (changedValue.equals(getStoreProperty() + "".connection"")) {
						 connection.removeConnectionListener(StoreInfo.this);
						 connection = Pooka.getConnectionManager().getConnection(Pooka.getProperty(getStoreProperty() + "".connection"", """"));
						 if (connection == null) {
							 connection = Pooka.getConnectionManager().getDefaultConnection();
						 }
						 if (connection != null) {
							 connection.addConnectionListener(StoreInfo.this);
						 }
					 }
					 else if (changedValue.equals(getStoreProperty() + "".useSubscribed"")) {
						 useSubscribed = Pooka.getProperty(getStoreProperty() + "".useSubscribed"", ""false"").equalsIgnoreCase(""true"");
					 }
					 else if (changedValue.equals(getStoreProperty() + "".sessionDebug.level"")) {
						 updateSessionDebug();
					 }
				 }
			 }
		 }
		;
		 java.awt.event.ActionEvent actionEvent = new java.awt.event.ActionEvent(this, 0, ""value-changed"");
		 if (Thread.currentThread() == getStoreThread()) {
			 valueChangedAction.actionPerformed(actionEvent);
		 }
		 else {
			 getStoreThread().addToQueue(valueChangedAction, actionEvent);
		 }
	 }
	 public void connectionStatusChanged(NetworkConnection connection, int newStatus) {
		 if (! (protocol.equalsIgnoreCase(""mbox"") || protocol.equalsIgnoreCase(""maildir""))) {
			 if (newStatus == NetworkConnection.CONNECTED) {
			 }
			 else if (newStatus == NetworkConnection.DISCONNECTED) {
				 try {
					 disconnectStore();
				 }
				 catch (MessagingException me) {
					 getLogger().log(Level.FINE, ""Caught exception disconnecting Store "" + getStoreID() + "": "" + me);
					 if (getLogger().isLoggable(Level.FINE)) me.printStackTrace();
				 }
			 }
			 else {
				 try {
					 disconnectStore();
				 }
				 catch (MessagingException me) {
					 getLogger().log(Level.FINE, ""Caught exception disconnecting Store "" + getStoreID() + "": "" + me);
					 if (getLogger().isLoggable(Level.FINE)) me.printStackTrace();
				 }
			 }
		 }
	 }
	 void removeFromFolderList(String removeFolderName) {
		 Vector folderNames = Pooka.getResources().getPropertyAsVector(getStoreProperty() + "".folderList"", """");
		 boolean first = true;
		 StringBuffer newValue = new StringBuffer();
		 String folderName;
		 for (int i = 0;
		 i < folderNames.size();
		 i++) {
			 folderName = (String) folderNames.elementAt(i);
			 if (! folderName.equals(removeFolderName)) {
				 if (!first) newValue.append("":"");
				 newValue.append(folderName);
				 first = false;
			 }
		 }
		 Pooka.setProperty(getStoreProperty() + "".folderList"", newValue.toString());
	 }
	 void addToFolderList(String addFolderName) {
		 String folderName;
		 Vector folderNames = Pooka.getResources().getPropertyAsVector(getStoreProperty() + "".folderList"", """");
		 boolean found = false;
		 for (int i = 0;
		 i < folderNames.size();
		 i++) {
			 folderName = (String) folderNames.elementAt(i);
			 if (folderName.equals(addFolderName)) {
				 found=true;
			 }
		 }
		 if (!found) {
			 String currentValue = Pooka.getProperty(getStoreProperty() + "".folderList"");
			 if (currentValue.equals("""")) Pooka.setProperty(getStoreProperty() + "".folderList"", addFolderName);
			 else Pooka.setProperty(getStoreProperty() + "".folderList"", currentValue + "":"" + addFolderName);
		 }
	 }
	 public void createSubFolder(String subFolderName, int type) throws MessagingException {
		 Folder folder = store.getDefaultFolder();
		 if (folder != null) {
			 Folder subFolder = folder.getFolder(subFolderName);
			 if (subFolder == null) {
				 throw new MessagingException(""Store returned null for subfolder "" + subFolderName);
			 }
			 if (! subFolder.exists()) subFolder.create(type);
			 subscribeFolder(subFolderName);
		 }
		 else {
			 throw new MessagingException(""Failed to open store "" + getStoreID() + "" to create subfolder "" + subFolderName);
		 }
	 }
	 public void subscribeFolder(String folderName) {
		 getLogger().log(Level.FINE, ""subscribing folder "" + folderName);
		 String subFolderName = null;
		 String childFolderName = null;
		 int firstSlash = folderName.indexOf('/');
		 while (firstSlash == 0) {
			 folderName = folderName.substring(1);
			 firstSlash = folderName.indexOf('/');
		 }
		 if (firstSlash > 0) {
			 childFolderName = folderName.substring(0, firstSlash);
			 if (firstSlash < folderName.length() -1) subFolderName = folderName.substring(firstSlash +1);
		 }
		 else childFolderName = folderName;
		 getLogger().log(Level.FINE, ""store "" + getStoreID() + "" subscribing folder "" + childFolderName + "";
		 sending "" + subFolderName + "" to child for subscription."");
		 this.addToFolderList(childFolderName);
		 FolderInfo childFolder = getChild(childFolderName);
		 getLogger().log(Level.FINE, ""got child folder '"" + childFolder + ""' for "" + childFolderName);
		 if (childFolder != null && subFolderName != null) {
			 childFolder.subscribeFolder(subFolderName);
		 }
	 }
	 public void connectStore() throws MessagingException, OperationCancelledException {
		 getLogger().log(Level.FINE, ""trying to connect store "" + getStoreID());
		 if (store.isConnected()) {
			 getLogger().log(Level.FINE, ""store "" + getStoreID() + "" is already connected."");
			 connected=true;
			 return;
		 }
		 else {
			 testConnection();
			 executePrecommand();
			 getLogger().log(Level.FINE, ""connect store "" + getStoreID() + "": doing store.connect()"");
			 boolean connectSucceeded = false;
			 while (! connectSucceeded) {
				 try {
					 getLogger().fine(""running store.connect()"");
					 store.connect();
					 connectSucceeded = true;
					 mPreferredStatus = FolderInfo.CONNECTED;
					 getLogger().fine(""done with store.connect()."");
					 mAuthenticator.disposeAuthenticator();
				 }
				 catch (MessagingException me) {
					 getLogger().fine(""caught exception."");
					 if (mAuthenticator.isCancelled()) {
						 getLogger().fine(""operation was cancelled."");
						 mAuthenticator.disposeAuthenticator();
						 mPreferredStatus = FolderInfo.DISCONNECTED;
						 throw new OperationCancelledException();
					 }
					 Exception nextEx = me.getNextException();
					 if (nextEx != null && nextEx instanceof java.io.InterruptedIOException) {
						 getLogger().fine(""retrying--interruptedioexception"");
					 }
					 else {
						 if (nextEx != null && nextEx.toString().contains(""SunCertPathBuilderException"") && ""tls"".equalsIgnoreCase(sslSetting)) {
							 getLogger().fine(""falling back to no tls."");
							 Properties p = mSession.getProperties();
							 p.setProperty(""mail.imap.starttls.enable"", ""false"");
							 store = mSession.getStore(url);
						 }
						 else {
							 if (mAuthenticator.isShowing()) {
								 mAuthenticator.setErrorMessage(me.getMessage(), me);
							 }
							 else {
								 if (nextEx != null) {
									 if (nextEx instanceof java.net.UnknownHostException) {
										 throw new MessagingException(Pooka.getResources().formatMessage(""error.login.unknownHostException"", nextEx.getMessage()), me);
									 }
								 }
								 throw me;
							 }
						 }
					 }
				 }
			 }
			 getLogger().log(Level.FINE, ""connect store "" + getStoreID() + "": connection succeeded;
			 connected = true."");
			 connected=true;
			 if (useSubscribed && protocol.equalsIgnoreCase(""imap"")) {
				 synchSubscribed();
			 }
			 if (Pooka.getProperty(""Pooka.openFoldersOnConnect"", ""true"").equalsIgnoreCase(""true"")) {
				 for (int i = 0;
				 i < children.size();
				 i++) {
					 doOpenFolders((FolderInfo) children.elementAt(i));
				 }
			 }
		 }
	 }
	 private void testConnection() throws MessagingException {
		 if (! (protocol.equalsIgnoreCase(""mbox"") || protocol.equalsIgnoreCase(""maildir""))) {
			 NetworkConnection currentConnection = getConnection();
			 getLogger().log(Level.FINE, ""connect store "" + getStoreID() + "": checking connection."");
			 if (currentConnection != null) {
				 if (currentConnection.getStatus() == NetworkConnection.DISCONNECTED) {
					 getLogger().log(Level.FINE, ""connect store "" + getStoreID() + "": connection not up. trying to connect it.."");
					 currentConnection.connect(true, true);
				 }
				 if (connection.getStatus() != NetworkConnection.CONNECTED) {
					 throw new MessagingException(Pooka.getProperty(""error.connectionDown"", ""Connection down for Store: "") + getItemID());
				 }
				 else {
					 getLogger().log(Level.FINE, ""connect store "" + getStoreID() + "": successfully opened connection."");
				 }
			 }
		 }
	 }
	 private void executePrecommand() {
		 String preCommand = Pooka.getProperty(getStoreProperty() + "".precommand"", """");
		 if (preCommand.length() > 0) {
			 getLogger().log(Level.FINE, ""connect store "" + getStoreID() + "": executing precommand."");
			 try {
				 Process p = Runtime.getRuntime().exec(preCommand);
				 p.waitFor();
			 }
			 catch (Exception ex) {
				 getLogger().log(Level.FINE, ""Could not run precommand:"");
				 ex.printStackTrace();
			 }
		 }
	 }
	 private void doOpenFolders(FolderInfo fi) {
		 if (Pooka.getProperty(""Pooka.openFoldersInBackground"", ""false"").equalsIgnoreCase(""true"")) {
			 final FolderInfo current = fi;
			 javax.swing.AbstractAction openFoldersAction = new javax.swing.AbstractAction() {
				 public void actionPerformed(java.awt.event.ActionEvent e) {
					 current.openAllFolders(Folder.READ_WRITE);
				 }
			 }
			;
			 openFoldersAction.putValue(javax.swing.Action.NAME, ""file-open"");
			 openFoldersAction.putValue(javax.swing.Action.SHORT_DESCRIPTION, ""file-open on folder "" + fi.getFolderID());
			 getStoreThread().addToQueue(openFoldersAction, new java.awt.event.ActionEvent(this, 0, ""open-all""), ActionThread.PRIORITY_LOW);
		 }
		 else {
			 fi.openAllFolders(Folder.READ_WRITE);
		 }
	 }
	 public void openFolders(List<FolderInfo> folderList) {
		 try {
			 connectStore();
			 for (FolderInfo fInfo: folderList) {
				 final FolderNode fNode = fInfo.getFolderNode();
				 fNode.openFolder(false, false);
			 }
		 }
		 catch (MessagingException me) {
			 boolean showError = false;
			 for (FolderInfo fInfo: folderList) {
				 if (fInfo instanceof net.suberic.pooka.cache.CachingFolderInfo) {
					 if (! (((net.suberic.pooka.cache.CachingFolderInfo) fInfo).getCacheHeadersOnly())) {
						 final FolderNode fNode = fInfo.getFolderNode();
						 fNode.openFolder(false, false);
					 }
				 }
				 else {
					 showError = true;
				 }
			 }
			 if (showError) {
				 Pooka.getUIFactory().showError(Pooka.getResources().formatMessage(""error.Store.connecton.failed"", getStoreID()), me);
			 }
		 }
		 catch (OperationCancelledException oce) {
			 for (FolderInfo fInfo: folderList) {
				 if (fInfo instanceof net.suberic.pooka.cache.CachingFolderInfo) {
					 if (! (((net.suberic.pooka.cache.CachingFolderInfo) fInfo).getCacheHeadersOnly())) {
						 final FolderNode fNode = fInfo.getFolderNode();
						 fNode.openFolder(false, false);
					 }
				 }
			 }
		 }
	 }
	 public void disconnectStore() throws MessagingException {
		 getLogger().log(Level.FINE, ""disconnecting store "" + getStoreID());
		 MessagingException storeException = null;
		 if (!(store.isConnected())) {
			 connected=false;
			 closeAllFolders(false, false);
			 return;
		 }
		 else {
			 try {
				 try {
					 closeAllFolders(false, false);
				 }
				 catch (MessagingException folderMe) {
					 storeException = folderMe;
				 }
				 store.close();
			 }
			 catch (MessagingException me) {
				 if (storeException != null) {
					 me.setNextException(storeException);
				 }
				 storeException = me;
				 throw storeException;
			 }
			 finally {
				 connected=false;
			 }
			 if (storeException != null) throw storeException;
		 }
	 }
	 public void closeAllFolders(boolean expunge, boolean shuttingDown) throws MessagingException {
		 if (getStoreThread() != null && ! getStoreThread().getStopped()) {
			 synchronized(getStoreThread().getRunLock()) {
				 getLogger().log(Level.FINE, ""closing all folders of store "" + getStoreID());
				 Vector folders = getChildren();
				 if (folders != null) {
					 for (int i = 0;
					 i < folders.size();
					 i++) {
						 ((FolderInfo) folders.elementAt(i)).closeAllFolders(expunge, shuttingDown);
					 }
				 }
			 }
		 }
	 }
	 public void stopStoreThread() {
		 if (storeThread != null) {
			 storeThread.setStop(true);
		 }
	 }
	 public Vector getAllFolders() {
		 Vector returnValue = new Vector();
		 Vector subFolders = getChildren();
		 for (int i = 0;
		 i < subFolders.size();
		 i++) {
			 returnValue.addAll(((FolderInfo) subFolders.elementAt(i)).getAllFolders());
		 }
		 return returnValue;
	 }
	 public void synchSubscribed() throws MessagingException, OperationCancelledException {
		 boolean foundInbox=false;
		 Folder[] subscribedFolders = store.getDefaultFolder().list();
		 ArrayList subscribedNames = new ArrayList();
		 for (int i = 0;
		 subscribedFolders != null && i < subscribedFolders.length;
		 i++) {
			 String folderName = subscribedFolders[i].getName();
			 if (folderName.equalsIgnoreCase(""inbox"")) {
				 if (!foundInbox) {
					 foundInbox=true;
					 subscribedNames.add(folderName);
				 }
			 }
			 else if (subscribedFolders[i].isSubscribed()) {
				 if (! subscribedNames.contains(folderName)) subscribedNames.add(folderName);
			 }
		 }
		 List tmpChildren = getChildren();
		 if (tmpChildren != null) {
			 Iterator it = tmpChildren.iterator();
			 while (it.hasNext()) {
				 FolderInfo fi = (FolderInfo) it.next();
				 String folderName = fi.getFolderName();
				 if (fi.isNamespace() && ! subscribedNames.contains(folderName)) subscribedNames.add(folderName);
			 }
		 }
		 Collections.sort(subscribedNames);
		 List<String> currentSubscribed = Pooka.getResources().getPropertyAsList(getStoreProperty() + "".folderList"", """");
		 Iterator<String> currentIter = currentSubscribed.iterator();
		 while(currentIter.hasNext()) {
			 String folder = currentIter.next();
			 if (! subscribedNames.contains(folder)) {
				 currentSubscribed.remove(folder);
			 }
			 else {
				 subscribedNames.remove(folder);
			 }
		 }
		 currentSubscribed.addAll(subscribedNames);
		 Pooka.setProperty(getStoreProperty() + "".folderList"", VariableBundle.convertToString(currentSubscribed));
		 for (int i = 0;
		 children != null && i < children.size();
		 i++) {
			 FolderInfo fi = (FolderInfo) children.get(i);
			 fi.synchSubscribed();
		 }
	 }
	 long lastConnectionCheck = 0;
	 public boolean checkConnection() {
		 if (! isConnected()) return false;
		 if (System.currentTimeMillis() - lastConnectionCheck > 20000) {
			 getLogger().log(Level.FINER, ""Checking connection for store "" + getStoreID());
			 Store realStore = getStore();
			 if (realStore != null) {
				 if (! realStore.isConnected()) {
					 getLogger().log(Level.FINER, getStoreID() + "": isConnected() returns false. returning false."");
					 return false;
				 }
				 else {
					 return true;
				 }
			 }
			 else {
				 return false;
			 }
		 }
		 else {
			 return isConnected();
		 }
	 }
	 public void showStatus() {
		 StringBuffer statusBuffer = new StringBuffer();
		 getLogger().log(Level.INFO, ""Status for store "" + getStoreID());
		 statusBuffer.append(""Status for store "" + getStoreID() + ""\r\n"");
		 boolean infoIsConnected = isConnected();
		 getLogger().log(Level.INFO, ""Connected: "" + infoIsConnected);
		 statusBuffer.append(""Connected: "" + infoIsConnected + ""\r\n"");
		 if (storeThread != null) {
			 String currentAction = storeThread.getCurrentActionName();
			 getLogger().log(Level.INFO, ""Current Action: "" + currentAction);
			 statusBuffer.append(""Current Action: "" + currentAction + ""\r\n"");
			 int queueSize = storeThread.getQueueSize();
			 getLogger().log(Level.INFO, ""Action Queue Size: "" + queueSize);
			 statusBuffer.append(""Action Queue Size: "" + queueSize +""\r\n"");
			 if (storeThread.getQueueSize() > 0) {
				 System.out.println(""Queue:"");
				 java.util.List queue = storeThread.getQueue();
				 for (int i = 0;
				 i < queue.size();
				 i++) {
					 net.suberic.util.thread.ActionThread.ActionEventPair current = (net.suberic.util.thread.ActionThread.ActionEventPair) queue.get(i);
					 String queueString = "" queue["" + i + ""]: "";
					 String entryDescription = (String) current.action.getValue(javax.swing.Action.SHORT_DESCRIPTION);
					 if (entryDescription == null) entryDescription = (String) current.action.getValue(javax.swing.Action.NAME);
					 if (entryDescription == null) entryDescription = ""Unknown action"";
					 queueString = queueString + entryDescription;
					 System.out.println(queueString);
					 statusBuffer.append(queueString + ""\r\n"");
				 }
			 }
			 statusBuffer.append(""Stack Trace:\r\n"");
			 StackTraceElement[] stackTrace = storeThread.getStackTrace();
			 for (StackTraceElement stackLine: stackTrace) {
				 statusBuffer.append("" "" + stackLine + ""\r\n"");
			 }
		 }
		 else {
			 getLogger().log(Level.INFO, ""No Action Thread."");
			 StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
			 for (StackTraceElement stackLine: stackTrace) {
				 statusBuffer.append("" "" + stackLine + ""\r\n"");
			 }
		 }
		 Pooka.getUIFactory().showMessage(statusBuffer.toString(), ""Status for "" + getStoreID());
	 }
	 public Store getStore() {
		 return store;
	 }
	 private void setStore(Store newValue) {
		 store=newValue;
	 }
	 public String getStoreID() {
		 return storeID;
	 }
	 public String getItemID() {
		 return getStoreID();
	 }
	 private void setStoreID(String newValue) {
		 storeID=newValue;
	 }
	 public String getStoreProperty() {
		 return ""Store."" + getStoreID();
	 }
	 public String getItemProperty() {
		 return getStoreProperty();
	 }
	 public String getProtocol() {
		 return protocol;
	 }
	 public boolean isPopStore() {
		 return popStore;
	 }
	 public Vector getChildren() {
		 return children;
	 }
	 public StoreNode getStoreNode() {
		 return storeNode;
	 }
	 public void setStoreNode(StoreNode newValue) {
		 storeNode = newValue;
	 }
	 public boolean isConnected() {
		 return connected;
	 }
	 public boolean isAvailable() {
		 return available;
	 }
	 public UserProfile getDefaultProfile() {
		 return defaultProfile;
	 }
	 public NetworkConnection getConnection() {
		 return connection;
	 }
	 public ActionThread getStoreThread() {
		 return storeThread;
	 }
	 public void setStoreThread(ActionThread newValue) {
		 storeThread=newValue;
	 }
	 public FolderInfo getTrashFolder() {
		 return trashFolder;
	 }
	 public int getPreferredStatus() {
		 return mPreferredStatus;
	 }
	 public void setPreferredStatus(int pPreferredStatus) {
		 mPreferredStatus = pPreferredStatus;
	 }
	 public boolean useTrashFolder() {
		 if (getTrashFolder() == null) return false;
		 String prop = Pooka.getProperty(getStoreProperty() + "".useTrashFolder"", """");
		 if (!prop.equals("""")) return (! prop.equalsIgnoreCase(""false""));
		 else return (! Pooka.getProperty(""Pooka.useTrashFolder"", ""true"").equalsIgnoreCase(""true""));
	 }
	 public void setTrashFolder(FolderInfo newValue) {
		 trashFolder = newValue;
	 }
	 public Logger getLogger() {
		 if (mLogger == null) {
			 mLogger = Logger.getLogger(getStoreProperty());
		 }
		 return mLogger;
	 }
	 void updateSessionDebug() {
		 if (Pooka.getProperty(""Pooka.sessionDebug"", ""false"").equalsIgnoreCase(""true"") || (! Pooka.getProperty(getStoreProperty() + "".sessionDebug.logLevel"", ""OFF"").equalsIgnoreCase(""OFF""))) {
			 mSession.setDebug(true);
		 }
		 else {
			 mSession.setDebug(false);
		 }
	 }
}",1,0,0,0
"private class Interleaved {
	 private char[] entries = null;
	 private int size = 0;
	 private long entriesGeneratedAtCount = -1;
	 public void update() {
		 if (count == entriesGeneratedAtCount) {
			 return;
		 }
		 size = ngrams.size();
		 final int numChars = (length+2)*size;
		 if (entries == null || entries.length < numChars) {
			 entries = new char[numChars];
		 }
		 int pos = 0;
		 for (Map.Entry<String, Counter> entry: getSortedNgrams()) {
			 for (int l = 0 ;
			 l < length ;
			 l++) {
				 entries[pos + l] = entry.getKey().charAt(l);
			 }
			 entries[pos + length] = (char)(entry.getValue().count / 65536);
			 entries[pos + length + 1] = (char)(entry.getValue().count % 65536);
			 pos += length + 2;
		 }
		 entriesGeneratedAtCount = count;
	 }
	 public Entry firstEntry() {
		 Entry entry = new Entry();
		 if (size > 0) {
			 entry.update(0);
		 }
		 return entry;
	 }
	 private List<Map.Entry<String, Counter>> getSortedNgrams() {
		 List<Map.Entry<String, Counter>> entries = new ArrayList<Map.Entry<String, Counter>>(ngrams.size());
		 entries.addAll(ngrams.entrySet());
		 Collections.sort(entries, new Comparator<Map.Entry<String, Counter>>() {
			 public int compare(Map.Entry<String, Counter> o1, Map.Entry<String, Counter> o2) {
				 return o1.getKey().compareTo(o2.getKey());
			 }
		 }
		);
		 return entries;
	 }
	 private class Entry implements Comparable<Entry> {
		 char[] ngram = new char[length];
		 int count = 0;
		 int pos = 0;
		 private void update(int pos) {
			 this.pos = pos;
			 if (pos >= size) {
				 return;
			 }
			 final int origo = pos*(length+2);
			 System.arraycopy(entries, origo, ngram, 0, length);
			 count = entries[origo+length] * 65536 + entries[origo+length+1];
		 }
		 public int compareTo(Entry other) {
			 for (int i = 0 ;
			 i < ngram.length ;
			 i++) {
				 if (ngram[i] != other.ngram[i]) {
					 return ngram[i] - other.ngram[i];
				 }
			 }
			 return 0;
		 }
		 public boolean hasNext() {
			 return pos < size-1;
		 }
		 public boolean hasNgram() {
			 return pos < size;
		 }
		 public void next() {
			 update(pos+1);
		 }
		 public String toString() {
			 return new String(ngram) + ""("" + count + "")"";
		 }
	 }
 }",1,0,0,0
"public static class Builder extends com.oracle.bmc.common.RegionalClientBuilder<Builder, MonitoringAsyncClient> {
	 private Builder(com.oracle.bmc.Service service) {
		 super(service);
		 requestSignerFactory = new com.oracle.bmc.http.signing.internal.DefaultRequestSignerFactory( com.oracle.bmc.http.signing.SigningStrategy.STANDARD);
	 }
	 public MonitoringAsyncClient build( com.oracle.bmc.auth.AbstractAuthenticationDetailsProvider authenticationDetailsProvider) {
		 return new MonitoringAsyncClient( authenticationDetailsProvider, configuration, clientConfigurator, requestSignerFactory, additionalClientConfigurators, endpoint);
	 }
 }",0,0,0,0
"class OfflineTransport extends Transport {
	 private static final Status OFFLINE_STATUS = new Status(IStatus.ERROR, Activator.PLUGIN_ID, ""offline"");
	 public IStatus download(URI toDownload, OutputStream target, long startPos, IProgressMonitor monitor) {
		 throw new IllegalStateException(""no download in offline mode"");
	 }
	 public IStatus download(URI toDownload, OutputStream target, IProgressMonitor monitor) {
		 return OFFLINE_STATUS;
	 }
	 public InputStream stream(URI toDownload, IProgressMonitor monitor) throws FileNotFoundException, CoreException, AuthenticationFailedException {
		 throw new IllegalStateException(""no download in offline mode"");
	 }
	 public long getLastModified(URI toDownload, IProgressMonitor monitor) throws CoreException, FileNotFoundException, AuthenticationFailedException {
		 throw new IllegalStateException(""no download in offline mode"");
	 }
}",0,0,0,0
"class AxiomSoap11Fault extends AxiomSoapFault implements Soap11Fault {
	AxiomSoap11Fault(SOAPFault axiomFault, SOAPFactory axiomFactory) {
		super(axiomFault, axiomFactory);
	}
	public QName getFaultCode() {
		return getAxiomFault().getCode().getTextAsQName();
	}
	public String getFaultStringOrReason() {
		if (getAxiomFault().getReason() != null) {
			return getAxiomFault().getReason().getText();
		}
		return null;
	}
	public Locale getFaultStringLocale() {
		if (getAxiomFault().getReason() != null) {
			OMAttribute langAttribute =getAxiomFault().getReason().getAttribute(new QName(""http:if (langAttribute != null) {
				String xmlLangString = langAttribute.getAttributeValue();
				if (xmlLangString != null) {
					return AxiomUtils.toLocale(xmlLangString);
				}
			}
		}
		return null;
	}
}",0,0,0,0
"private static class CertStoreComparator implements Comparator<CertStore> {
	 public int compare(CertStore store1, CertStore store2) {
		 if (store1.getType().equals(""Collection"") || store1.getCertStoreParameters() instanceof CollectionCertStoreParameters) {
			 return -1;
		 }
		 else {
			 return 1;
		 }
	 }
 }",0,0,0,0
"private static class getUnicoreJobSubmission_argsTupleScheme extends TupleScheme<getUnicoreJobSubmission_args> {
	 public void write(org.apache.thrift.protocol.TProtocol prot, getUnicoreJobSubmission_args struct) throws org.apache.thrift.TException {
		 TTupleProtocol oprot = (TTupleProtocol) prot;
		 struct.authzToken.write(oprot);
		 oprot.writeString(struct.jobSubmissionId);
	 }
	 public void read(org.apache.thrift.protocol.TProtocol prot, getUnicoreJobSubmission_args struct) throws org.apache.thrift.TException {
		 TTupleProtocol iprot = (TTupleProtocol) prot;
		 struct.authzToken = new org.apache.airavata.model.security.AuthzToken();
		 struct.authzToken.read(iprot);
		 struct.setAuthzTokenIsSet(true);
		 struct.jobSubmissionId = iprot.readString();
		 struct.setJobSubmissionIdIsSet(true);
	 }
 }",0,0,0,0
"public class XMLDocumentFragmentScannerImpl extends XMLScanner implements XMLDocumentScanner, XMLComponent, XMLEntityHandler {
	 protected static final int SCANNER_STATE_START_OF_MARKUP = 1;
	 protected static final int SCANNER_STATE_COMMENT = 2;
	 protected static final int SCANNER_STATE_PI = 3;
	 protected static final int SCANNER_STATE_DOCTYPE = 4;
	 protected static final int SCANNER_STATE_ROOT_ELEMENT = 6;
	 protected static final int SCANNER_STATE_CONTENT = 7;
	 protected static final int SCANNER_STATE_REFERENCE = 8;
	 protected static final int SCANNER_STATE_END_OF_INPUT = 13;
	 protected static final int SCANNER_STATE_TERMINATED = 14;
	 protected static final int SCANNER_STATE_CDATA = 15;
	 protected static final int SCANNER_STATE_TEXT_DECL = 16;
	 protected static final String NAMESPACES = Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
	 protected static final String NOTIFY_BUILTIN_REFS = Constants.XERCES_FEATURE_PREFIX + Constants.NOTIFY_BUILTIN_REFS_FEATURE;
	 protected static final String ENTITY_RESOLVER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
	 private static final String[] RECOGNIZED_FEATURES = {
	 NAMESPACES, VALIDATION, NOTIFY_BUILTIN_REFS, NOTIFY_CHAR_REFS, }
	;
	 private static final Boolean[] FEATURE_DEFAULTS = {
	 null, null, Boolean.FALSE, Boolean.FALSE, }
	;
	 private static final String[] RECOGNIZED_PROPERTIES = {
	 SYMBOL_TABLE, ERROR_REPORTER, ENTITY_MANAGER, ENTITY_RESOLVER, }
	;
	 private static final Object[] PROPERTY_DEFAULTS = {
	 null, null, null, null, }
	;
	 private static final boolean DEBUG_SCANNER_STATE = false;
	 private static final boolean DEBUG_DISPATCHER = false;
	 protected static final boolean DEBUG_CONTENT_SCANNING = false;
	 protected XMLDocumentHandler fDocumentHandler;
	 protected int[] fEntityStack = new int[4];
	 protected int fMarkupDepth;
	 protected int fScannerState;
	 protected boolean fInScanContent = false;
	 protected boolean fHasExternalDTD;
	 protected boolean fStandalone;
	 protected boolean fIsEntityDeclaredVC;
	 protected ExternalSubsetResolver fExternalSubsetResolver;
	 protected QName fCurrentElement;
	 protected final ElementStack fElementStack = new ElementStack();
	 protected boolean fNotifyBuiltInRefs = false;
	 protected Dispatcher fDispatcher;
	 protected final Dispatcher fContentDispatcher = createContentDispatcher();
	 protected final QName fElementQName = new QName();
	 protected final QName fAttributeQName = new QName();
	 protected final XMLAttributesImpl fAttributes = new XMLAttributesImpl();
	 protected final XMLString fTempString = new XMLString();
	 protected final XMLString fTempString2 = new XMLString();
	 private final String[] fStrings = new String[3];
	 private final XMLStringBuffer fStringBuffer = new XMLStringBuffer();
	 private final XMLStringBuffer fStringBuffer2 = new XMLStringBuffer();
	 private final QName fQName = new QName();
	 private final char[] fSingleChar = new char[1];
	 private boolean fSawSpace;
	 private Augmentations fTempAugmentations = null;
	 public XMLDocumentFragmentScannerImpl() {
	}
	 public void setInputSource(XMLInputSource inputSource) throws IOException {
		 fEntityManager.setEntityHandler(this);
		 fEntityManager.startEntity(""$fragment$"", inputSource, false, true);
	 }
	 public boolean scanDocument(boolean complete) throws IOException, XNIException {
		 fEntityScanner = fEntityManager.getEntityScanner();
		 fEntityManager.setEntityHandler(this);
		 do {
			 if (!fDispatcher.dispatch(complete)) {
				 return false;
			 }
		 }
		 while (complete);
		 return true;
	 }
	 public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {
		 super.reset(componentManager);
		 fAttributes.setNamespaces(fNamespaces);
		 fMarkupDepth = 0;
		 fCurrentElement = null;
		 fElementStack.clear();
		 fHasExternalDTD = false;
		 fStandalone = false;
		 fIsEntityDeclaredVC = false;
		 fInScanContent = false;
		setScannerState(SCANNER_STATE_CONTENT);
		setDispatcher(fContentDispatcher);
		 if (fParserSettings) {
			 try {
				 fNotifyBuiltInRefs = componentManager.getFeature(NOTIFY_BUILTIN_REFS);
			 }
			 catch (XMLConfigurationException e) {
				 fNotifyBuiltInRefs = false;
			 }
			 try {
				 Object resolver = componentManager.getProperty(ENTITY_RESOLVER);
				 fExternalSubsetResolver = (resolver instanceof ExternalSubsetResolver) ? (ExternalSubsetResolver) resolver : null;
			 }
			 catch (XMLConfigurationException e) {
				 fExternalSubsetResolver = null;
			 }
		 }
	 }
	 public String[] getRecognizedFeatures() {
		 return (String[])(RECOGNIZED_FEATURES.clone());
	 }
	 public void setFeature(String featureId, boolean state) throws XMLConfigurationException {
		 super.setFeature(featureId, state);
		 if (featureId.startsWith(Constants.XERCES_FEATURE_PREFIX)) {
			 final int suffixLength = featureId.length() - Constants.XERCES_FEATURE_PREFIX.length();
			 if (suffixLength == Constants.NOTIFY_BUILTIN_REFS_FEATURE.length() && featureId.endsWith(Constants.NOTIFY_BUILTIN_REFS_FEATURE)) {
				 fNotifyBuiltInRefs = state;
			 }
		 }
	 }
	 public String[] getRecognizedProperties() {
		 return (String[])(RECOGNIZED_PROPERTIES.clone());
	 }
	 public void setProperty(String propertyId, Object value) throws XMLConfigurationException {
		 super.setProperty(propertyId, value);
		 if (propertyId.startsWith(Constants.XERCES_PROPERTY_PREFIX)) {
			 final int suffixLength = propertyId.length() - Constants.XERCES_PROPERTY_PREFIX.length();
			 if (suffixLength == Constants.ENTITY_MANAGER_PROPERTY.length() && propertyId.endsWith(Constants.ENTITY_MANAGER_PROPERTY)) {
				 fEntityManager = (XMLEntityManager)value;
				 return;
			 }
			 if (suffixLength == Constants.ENTITY_RESOLVER_PROPERTY.length() && propertyId.endsWith(Constants.ENTITY_RESOLVER_PROPERTY)) {
				 fExternalSubsetResolver = (value instanceof ExternalSubsetResolver) ? (ExternalSubsetResolver) value : null;
				 return;
			 }
		 }
	 }
	 public Boolean getFeatureDefault(String featureId) {
		 for (int i = 0;
		 i < RECOGNIZED_FEATURES.length;
		 i++) {
			 if (RECOGNIZED_FEATURES[i].equals(featureId)) {
				 return FEATURE_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public Object getPropertyDefault(String propertyId) {
		 for (int i = 0;
		 i < RECOGNIZED_PROPERTIES.length;
		 i++) {
			 if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
				 return PROPERTY_DEFAULTS[i];
			 }
		 }
		 return null;
	 }
	 public void setDocumentHandler(XMLDocumentHandler documentHandler) {
		 fDocumentHandler = documentHandler;
	 }
	 public XMLDocumentHandler getDocumentHandler(){
		 return fDocumentHandler;
	 }
	 public void startEntity(String name, XMLResourceIdentifier identifier, String encoding, Augmentations augs) throws XNIException {
		 if (fEntityDepth == fEntityStack.length) {
			 int[] entityarray = new int[fEntityStack.length * 2];
			 System.arraycopy(fEntityStack, 0, entityarray, 0, fEntityStack.length);
			 fEntityStack = entityarray;
		 }
		 fEntityStack[fEntityDepth] = fMarkupDepth;
		 super.startEntity(name, identifier, encoding, augs);
		 if(fStandalone && fEntityManager.isEntityDeclInExternalSubset(name)) {
			 reportFatalError(""MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE"", new Object[]{
			name}
			);
		 }
		 if (fDocumentHandler != null && !fScanningAttribute) {
			 if (!name.equals(""[xml]"")) {
				 fDocumentHandler.startGeneralEntity(name, identifier, encoding, augs);
			 }
		 }
	 }
	 public void endEntity(String name, Augmentations augs) throws XNIException {
		 if (fInScanContent && fStringBuffer.length != 0 && fDocumentHandler != null) {
			 fDocumentHandler.characters(fStringBuffer, null);
			 fStringBuffer.length = 0;
		 }
		 super.endEntity(name, augs);
		 if (fMarkupDepth != fEntityStack[fEntityDepth]) {
			 reportFatalError(""MarkupEntityMismatch"", null);
		 }
		 if (fDocumentHandler != null && !fScanningAttribute) {
			 if (!name.equals(""[xml]"")) {
				 fDocumentHandler.endGeneralEntity(name, augs);
			 }
		 }
	 }
	 protected Dispatcher createContentDispatcher() {
		 return new FragmentContentDispatcher();
	 }
	 protected void scanXMLDeclOrTextDecl(boolean scanningTextDecl) throws IOException, XNIException {
		 super.scanXMLDeclOrTextDecl(scanningTextDecl, fStrings);
		 fMarkupDepth--;
		 String version = fStrings[0];
		 String encoding = fStrings[1];
		 String standalone = fStrings[2];
		 fStandalone = standalone != null && standalone.equals(""yes"");
		 fEntityManager.setStandalone(fStandalone);
		 fEntityScanner.setXMLVersion(version);
		 if (fDocumentHandler != null) {
			 if (scanningTextDecl) {
				 fDocumentHandler.textDecl(version, encoding, null);
			 }
			 else {
				 fDocumentHandler.xmlDecl(version, encoding, standalone, null);
			 }
		 }
		 if (encoding != null && !fEntityScanner.fCurrentEntity.isEncodingExternallySpecified()) {
			 fEntityScanner.setEncoding(encoding);
		 }
	 }
	 protected void scanPIData(String target, XMLString data) throws IOException, XNIException {
		 super.scanPIData(target, data);
		 fMarkupDepth--;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.processingInstruction(target, data, null);
		 }
	 }
	 protected void scanComment() throws IOException, XNIException {
		 scanComment(fStringBuffer);
		 fMarkupDepth--;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.comment(fStringBuffer, null);
		 }
	 }
	 protected boolean scanStartElement() throws IOException, XNIException {
		 if (DEBUG_CONTENT_SCANNING) System.out.println("">>> scanStartElement()"");
		 if (fNamespaces) {
			 fEntityScanner.scanQName(fElementQName);
		 }
		 else {
			 String name = fEntityScanner.scanName();
			 fElementQName.setValues(null, name, name, null);
		 }
		 String rawname = fElementQName.rawname;
		 fCurrentElement = fElementStack.pushElement(fElementQName);
		 boolean empty = false;
		 fAttributes.removeAllAttributes();
		 do {
			 boolean sawSpace = fEntityScanner.skipSpaces();
			 int c = fEntityScanner.peekChar();
			 if (c == '>') {
				 fEntityScanner.scanChar();
				 break;
			 }
			 else if (c == '/') {
				 fEntityScanner.scanChar();
				 if (!fEntityScanner.skipChar('>')) {
					 reportFatalError(""ElementUnterminated"", new Object[]{
					rawname}
					);
				 }
				 empty = true;
				 break;
			 }
			 else if (!isValidNameStartChar(c) || !sawSpace) {
				 if (!isValidNameStartHighSurrogate(c) || !sawSpace) {
					 reportFatalError(""ElementUnterminated"", new Object[] {
					 rawname }
					);
				 }
			 }
			 scanAttribute(fAttributes);
		 }
		 while (true);
		 if (fDocumentHandler != null) {
			 if (empty) {
				 fMarkupDepth--;
				 if (fMarkupDepth < fEntityStack[fEntityDepth - 1]) {
					 reportFatalError(""ElementEntityMismatch"", new Object[]{
					fCurrentElement.rawname}
					);
				 }
				 fDocumentHandler.emptyElement(fElementQName, fAttributes, null);
				 fElementStack.popElement(fElementQName);
			 }
			 else {
				 fDocumentHandler.startElement(fElementQName, fAttributes, null);
			 }
		 }
		 if (DEBUG_CONTENT_SCANNING) System.out.println(""<<< scanStartElement(): ""+empty);
		 return empty;
	 }
	 protected void scanStartElementName () throws IOException, XNIException {
		 if (fNamespaces) {
			 fEntityScanner.scanQName(fElementQName);
		 }
		 else {
			 String name = fEntityScanner.scanName();
			 fElementQName.setValues(null, name, name, null);
		 }
		 fSawSpace = fEntityScanner.skipSpaces();
	 }
	 protected boolean scanStartElementAfterName() throws IOException, XNIException {
		 String rawname = fElementQName.rawname;
		 fCurrentElement = fElementStack.pushElement(fElementQName);
		 boolean empty = false;
		 fAttributes.removeAllAttributes();
		 do {
			 int c = fEntityScanner.peekChar();
			 if (c == '>') {
				 fEntityScanner.scanChar();
				 break;
			 }
			 else if (c == '/') {
				 fEntityScanner.scanChar();
				 if (!fEntityScanner.skipChar('>')) {
					 reportFatalError(""ElementUnterminated"", new Object[]{
					rawname}
					);
				 }
				 empty = true;
				 break;
			 }
			 else if (!isValidNameStartChar(c) || !fSawSpace) {
				 if (!isValidNameStartHighSurrogate(c) || !fSawSpace) {
					 reportFatalError(""ElementUnterminated"", new Object[] {
					 rawname }
					);
				 }
			 }
			 scanAttribute(fAttributes);
			 fSawSpace = fEntityScanner.skipSpaces();
		 }
		 while (true);
		 if (fDocumentHandler != null) {
			 if (empty) {
				 fMarkupDepth--;
				 if (fMarkupDepth < fEntityStack[fEntityDepth - 1]) {
					 reportFatalError(""ElementEntityMismatch"", new Object[]{
					fCurrentElement.rawname}
					);
				 }
				 fDocumentHandler.emptyElement(fElementQName, fAttributes, null);
				 fElementStack.popElement(fElementQName);
			 }
			 else {
				 fDocumentHandler.startElement(fElementQName, fAttributes, null);
			 }
		 }
		 if (DEBUG_CONTENT_SCANNING) System.out.println(""<<< scanStartElementAfterName(): ""+empty);
		 return empty;
	 }
	 protected void scanAttribute(XMLAttributes attributes) throws IOException, XNIException {
		 if (DEBUG_CONTENT_SCANNING) System.out.println("">>> scanAttribute()"");
		 if (fNamespaces) {
			 fEntityScanner.scanQName(fAttributeQName);
		 }
		 else {
			 String name = fEntityScanner.scanName();
			 fAttributeQName.setValues(null, name, name, null);
		 }
		 fEntityScanner.skipSpaces();
		 if (!fEntityScanner.skipChar('=')) {
			 reportFatalError(""EqRequiredInAttribute"", new Object[]{
			fCurrentElement.rawname,fAttributeQName.rawname}
			);
		 }
		 fEntityScanner.skipSpaces();
		 int oldLen = attributes.getLength();
		 int attrIndex = attributes.addAttribute(fAttributeQName, XMLSymbols.fCDATASymbol, null);
		 if (oldLen == attributes.getLength()) {
			 reportFatalError(""AttributeNotUnique"", new Object[]{
			fCurrentElement.rawname, fAttributeQName.rawname}
			);
		 }
		 boolean isSameNormalizedAttr = scanAttributeValue(fTempString, fTempString2, fAttributeQName.rawname, fIsEntityDeclaredVC, fCurrentElement.rawname);
		 attributes.setValue(attrIndex, fTempString.toString());
		 if (!isSameNormalizedAttr) {
			 attributes.setNonNormalizedValue(attrIndex, fTempString2.toString());
		 }
		 attributes.setSpecified(attrIndex, true);
		 if (DEBUG_CONTENT_SCANNING) System.out.println(""<<< scanAttribute()"");
	 }
	 protected int scanContent() throws IOException, XNIException {
		 XMLString content = fTempString;
		 int c = fEntityScanner.scanContent(content);
		 if (c == '\r') {
			 fEntityScanner.scanChar();
			 fStringBuffer.clear();
			 fStringBuffer.append(fTempString);
			 fStringBuffer.append((char)c);
			 content = fStringBuffer;
			 c = -1;
		 }
		 if (fDocumentHandler != null && content.length > 0) {
			 fDocumentHandler.characters(content, null);
		 }
		 if (c == ']' && fTempString.length == 0) {
			 fStringBuffer.clear();
			 fStringBuffer.append((char)fEntityScanner.scanChar());
			 fInScanContent = true;
			 if (fEntityScanner.skipChar(']')) {
				 fStringBuffer.append(']');
				 while (fEntityScanner.skipChar(']')) {
					 fStringBuffer.append(']');
				 }
				 if (fEntityScanner.skipChar('>')) {
					 reportFatalError(""CDEndInContent"", null);
				 }
			 }
			 if (fDocumentHandler != null && fStringBuffer.length != 0) {
				 fDocumentHandler.characters(fStringBuffer, null);
			 }
			 fInScanContent = false;
			 c = -1;
		 }
		 return c;
	 }
	 protected boolean scanCDATASection(boolean complete) throws IOException, XNIException {
		 if (fDocumentHandler != null) {
			 fDocumentHandler.startCDATA(null);
		 }
		 while (true) {
			 fStringBuffer.clear();
			 if (!fEntityScanner.scanData(""]]"", fStringBuffer)) {
				 if (fDocumentHandler != null && fStringBuffer.length > 0) {
					 fDocumentHandler.characters(fStringBuffer, null);
				 }
				 int brackets = 0;
				 while (fEntityScanner.skipChar(']')) {
					 brackets++;
				 }
				 if (fDocumentHandler != null && brackets > 0) {
					 fStringBuffer.clear();
					 if (brackets > XMLEntityManager.DEFAULT_BUFFER_SIZE) {
						 int chunks = brackets / XMLEntityManager.DEFAULT_BUFFER_SIZE;
						 int remainder = brackets % XMLEntityManager.DEFAULT_BUFFER_SIZE;
						 for (int i = 0;
						 i < XMLEntityManager.DEFAULT_BUFFER_SIZE;
						 i++) {
							 fStringBuffer.append(']');
						 }
						 for (int i = 0;
						 i < chunks;
						 i++) {
							 fDocumentHandler.characters(fStringBuffer, null);
						 }
						 if (remainder != 0) {
							 fStringBuffer.length = remainder;
							 fDocumentHandler.characters(fStringBuffer, null);
						 }
					 }
					 else {
						 for (int i = 0;
						 i < brackets;
						 i++) {
							 fStringBuffer.append(']');
						 }
						 fDocumentHandler.characters(fStringBuffer, null);
					 }
				 }
				 if (fEntityScanner.skipChar('>')) {
					 break;
				 }
				 if (fDocumentHandler != null) {
					 fStringBuffer.clear();
					 fStringBuffer.append(""]]"");
					 fDocumentHandler.characters(fStringBuffer, null);
				 }
			 }
			 else {
				 if (fDocumentHandler != null) {
					 fDocumentHandler.characters(fStringBuffer, null);
				 }
				 int c = fEntityScanner.peekChar();
				 if (c != -1 && isInvalidLiteral(c)) {
					 if (XMLChar.isHighSurrogate(c)) {
						 fStringBuffer.clear();
						 scanSurrogates(fStringBuffer);
						 if (fDocumentHandler != null) {
							 fDocumentHandler.characters(fStringBuffer, null);
						 }
					 }
					 else {
						 reportFatalError(""InvalidCharInCDSect"", new Object[]{
						Integer.toString(c,16)}
						);
						 fEntityScanner.scanChar();
					 }
				 }
			 }
		 }
		 fMarkupDepth--;
		 if (fDocumentHandler != null) {
			 fDocumentHandler.endCDATA(null);
		 }
		 return true;
	 }
	 protected int scanEndElement() throws IOException, XNIException {
		 if (DEBUG_CONTENT_SCANNING) System.out.println("">>> scanEndElement()"");
		 fElementStack.popElement(fElementQName) ;
		 if (!fEntityScanner.skipString(fElementQName.rawname)) {
			 reportFatalError(""ETagRequired"", new Object[]{
			fElementQName.rawname}
			);
		 }
		 fEntityScanner.skipSpaces();
		 if (!fEntityScanner.skipChar('>')) {
			 reportFatalError(""ETagUnterminated"", new Object[]{
			fElementQName.rawname}
			);
		 }
		 fMarkupDepth--;
		 fMarkupDepth--;
		 if (fMarkupDepth < fEntityStack[fEntityDepth - 1]) {
			 reportFatalError(""ElementEntityMismatch"", new Object[]{
			fCurrentElement.rawname}
			);
		 }
		 if (fDocumentHandler != null ) {
			 fDocumentHandler.endElement(fElementQName, null);
		 }
		 return fMarkupDepth;
	 }
	 protected void scanCharReference() throws IOException, XNIException {
		 fStringBuffer2.clear();
		 int ch = scanCharReferenceValue(fStringBuffer2, null);
		 fMarkupDepth--;
		 if (ch != -1) {
			 if (fDocumentHandler != null) {
				 if (fNotifyCharRefs) {
					 fDocumentHandler.startGeneralEntity(fCharRefLiteral, null, null, null);
				 }
				 Augmentations augs = null;
				 if (fValidation && ch <= 0x20) {
					 if (fTempAugmentations != null) {
						 fTempAugmentations.removeAllItems();
					 }
					 else {
						 fTempAugmentations = new AugmentationsImpl();
					 }
					 augs = fTempAugmentations;
					 augs.putItem(Constants.CHAR_REF_PROBABLE_WS, Boolean.TRUE);
				 }
				 fDocumentHandler.characters(fStringBuffer2, augs);
				 if (fNotifyCharRefs) {
					 fDocumentHandler.endGeneralEntity(fCharRefLiteral, null);
				 }
			 }
		 }
	 }
	 protected void scanEntityReference() throws IOException, XNIException {
		 String name = fEntityScanner.scanName();
		 if (name == null) {
			 reportFatalError(""NameRequiredInReference"", null);
			 return;
		 }
		 if (!fEntityScanner.skipChar(';
		')) {
			 reportFatalError(""SemicolonRequiredInReference"", new Object []{
			name}
			);
		 }
		 fMarkupDepth--;
		 if (name == fAmpSymbol) {
			 handleCharacter('&', fAmpSymbol);
		 }
		 else if (name == fLtSymbol) {
			 handleCharacter('<', fLtSymbol);
		 }
		 else if (name == fGtSymbol) {
			 handleCharacter('>', fGtSymbol);
		 }
		 else if (name == fQuotSymbol) {
			 handleCharacter('""', fQuotSymbol);
		 }
		 else if (name == fAposSymbol) {
			 handleCharacter('\'', fAposSymbol);
		 }
		 else if (fEntityManager.isUnparsedEntity(name)) {
			 reportFatalError(""ReferenceToUnparsedEntity"", new Object[]{
			name}
			);
		 }
		 else {
			 if (!fEntityManager.isDeclaredEntity(name)) {
				 if (fIsEntityDeclaredVC) {
					 if (fValidation) fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,""EntityNotDeclared"", new Object[]{
					name}
					, XMLErrorReporter.SEVERITY_ERROR);
				 }
				 else {
					 reportFatalError(""EntityNotDeclared"", new Object[]{
					name}
					);
				 }
			 }
			 fEntityManager.startEntity(name, false);
		 }
	 }
	 private void handleCharacter(char c, String entity) throws XNIException {
		 if (fDocumentHandler != null) {
			 if (fNotifyBuiltInRefs) {
				 fDocumentHandler.startGeneralEntity(entity, null, null, null);
			 }
			 fSingleChar[0] = c;
			 fTempString.setValues(fSingleChar, 0, 1);
			 fDocumentHandler.characters(fTempString, null);
			 if (fNotifyBuiltInRefs) {
				 fDocumentHandler.endGeneralEntity(entity, null);
			 }
		 }
	 }
	 protected int handleEndElement(QName element, boolean isEmpty) throws XNIException {
		 fMarkupDepth--;
		 if (fMarkupDepth < fEntityStack[fEntityDepth - 1]) {
			 reportFatalError(""ElementEntityMismatch"", new Object[]{
			fCurrentElement.rawname}
			);
		 }
		 QName startElement = fQName;
		 fElementStack.popElement(startElement);
		 if (element.rawname != startElement.rawname) {
			 reportFatalError(""ETagRequired"", new Object[]{
			startElement.rawname}
			);
		 }
		 if (fNamespaces) {
			 element.uri = startElement.uri;
		 }
		 if (fDocumentHandler != null && !isEmpty) {
			 fDocumentHandler.endElement(element, null);
		 }
		 return fMarkupDepth;
	 }
	 protected final void setScannerState(int state) {
		 fScannerState = state;
		 if (DEBUG_SCANNER_STATE) {
			 System.out.print(""### setScannerState: "");
			 System.out.print(getScannerStateName(state));
			 System.out.println();
		 }
	 }
	 protected final void setDispatcher(Dispatcher dispatcher) {
		 fDispatcher = dispatcher;
		 if (DEBUG_DISPATCHER) {
			 System.out.print(""%%% setDispatcher: "");
			 System.out.print(getDispatcherName(dispatcher));
			 System.out.println();
		 }
	 }
	 protected String getScannerStateName(int state) {
		 switch (state) {
			 case SCANNER_STATE_DOCTYPE: return ""SCANNER_STATE_DOCTYPE"";
			 case SCANNER_STATE_ROOT_ELEMENT: return ""SCANNER_STATE_ROOT_ELEMENT"";
			 case SCANNER_STATE_START_OF_MARKUP: return ""SCANNER_STATE_START_OF_MARKUP"";
			 case SCANNER_STATE_COMMENT: return ""SCANNER_STATE_COMMENT"";
			 case SCANNER_STATE_PI: return ""SCANNER_STATE_PI"";
			 case SCANNER_STATE_CONTENT: return ""SCANNER_STATE_CONTENT"";
			 case SCANNER_STATE_REFERENCE: return ""SCANNER_STATE_REFERENCE"";
			 case SCANNER_STATE_END_OF_INPUT: return ""SCANNER_STATE_END_OF_INPUT"";
			 case SCANNER_STATE_TERMINATED: return ""SCANNER_STATE_TERMINATED"";
			 case SCANNER_STATE_CDATA: return ""SCANNER_STATE_CDATA"";
			 case SCANNER_STATE_TEXT_DECL: return ""SCANNER_STATE_TEXT_DECL"";
		 }
		 return ""??? (""+state+')';
	 }
	 public String getDispatcherName(Dispatcher dispatcher) {
		 if (DEBUG_DISPATCHER) {
			 if (dispatcher != null) {
				 String name = dispatcher.getClass().getName();
				 int index = name.lastIndexOf('.');
				 if (index != -1) {
					 name = name.substring(index + 1);
					 index = name.lastIndexOf('$');
					 if (index != -1) {
						 name = name.substring(index + 1);
					 }
				 }
				 return name;
			 }
		 }
		 return ""null"";
	 }
	 protected static class ElementStack {
		 protected QName[] fElements;
		 protected int fSize;
		 public ElementStack() {
			 fElements = new QName[10];
			 for (int i = 0;
			 i < fElements.length;
			 i++) {
				 fElements[i] = new QName();
			 }
		 }
		 public QName pushElement(QName element) {
			 if (fSize == fElements.length) {
				 QName[] array = new QName[fElements.length * 2];
				 System.arraycopy(fElements, 0, array, 0, fSize);
				 fElements = array;
				 for (int i = fSize;
				 i < fElements.length;
				 i++) {
					 fElements[i] = new QName();
				 }
			 }
			 fElements[fSize].setValues(element);
			 return fElements[fSize++];
		 }
		 public void popElement(QName element) {
			 element.setValues(fElements[--fSize]);
		 }
		 public void clear() {
			 fSize = 0;
		 }
	 }
	 protected interface Dispatcher {
		 public boolean dispatch(boolean complete) throws IOException, XNIException;
	 }
	 protected class FragmentContentDispatcher implements Dispatcher {
		 public boolean dispatch(boolean complete) throws IOException, XNIException {
			 try {
				 boolean again;
				 do {
					 again = false;
					 switch (fScannerState) {
						 case SCANNER_STATE_CONTENT: {
							 if (fEntityScanner.skipChar('<')) {
								 setScannerState(SCANNER_STATE_START_OF_MARKUP);
								 again = true;
							 }
							 else if (fEntityScanner.skipChar('&')) {
								 setScannerState(SCANNER_STATE_REFERENCE);
								 again = true;
							 }
							 else {
								 do {
									 int c = scanContent();
									 if (c == '<') {
										 fEntityScanner.scanChar();
										 setScannerState(SCANNER_STATE_START_OF_MARKUP);
										 break;
									 }
									 else if (c == '&') {
										 fEntityScanner.scanChar();
										 setScannerState(SCANNER_STATE_REFERENCE);
										 break;
									 }
									 else if (c != -1 && isInvalidLiteral(c)) {
										 if (XMLChar.isHighSurrogate(c)) {
											 fStringBuffer.clear();
											 if (scanSurrogates(fStringBuffer)) {
												 if (fDocumentHandler != null) {
													 fDocumentHandler.characters(fStringBuffer, null);
												 }
											 }
										 }
										 else {
											 reportFatalError(""InvalidCharInContent"", new Object[] {
											 Integer.toString(c, 16)}
											);
											 fEntityScanner.scanChar();
										 }
									 }
								 }
								 while (complete);
							 }
							 break;
						 }
						 case SCANNER_STATE_START_OF_MARKUP: {
							 fMarkupDepth++;
							 if (fEntityScanner.skipChar('/')) {
								 if (scanEndElement() == 0) {
									 if (elementDepthIsZeroHook()) {
										 return true;
									 }
								 }
								 setScannerState(SCANNER_STATE_CONTENT);
							 }
							 else if (isValidNameStartChar(fEntityScanner.peekChar())) {
								 scanStartElement();
								 setScannerState(SCANNER_STATE_CONTENT);
							 }
							 else if (fEntityScanner.skipChar('!')) {
								 if (fEntityScanner.skipChar('-')) {
									 if (!fEntityScanner.skipChar('-')) {
										 reportFatalError(""InvalidCommentStart"", null);
									 }
									 setScannerState(SCANNER_STATE_COMMENT);
									 again = true;
								 }
								 else if (fEntityScanner.skipString(""[CDATA["")) {
									 setScannerState(SCANNER_STATE_CDATA);
									 again = true;
								 }
								 else if (!scanForDoctypeHook()) {
									 reportFatalError(""MarkupNotRecognizedInContent"", null);
								 }
							 }
							 else if (fEntityScanner.skipChar('?')) {
								 setScannerState(SCANNER_STATE_PI);
								 again = true;
							 }
							 else if (isValidNameStartHighSurrogate(fEntityScanner.peekChar())) {
								 scanStartElement();
								 setScannerState(SCANNER_STATE_CONTENT);
							 }
							 else {
								 reportFatalError(""MarkupNotRecognizedInContent"", null);
								 setScannerState(SCANNER_STATE_CONTENT);
							 }
							 break;
						 }
						 case SCANNER_STATE_COMMENT: {
							 scanComment();
							 setScannerState(SCANNER_STATE_CONTENT);
							 break;
						 }
						 case SCANNER_STATE_PI: {
							 scanPI();
							 setScannerState(SCANNER_STATE_CONTENT);
							 break;
						 }
						 case SCANNER_STATE_CDATA: {
							 scanCDATASection(complete);
							 setScannerState(SCANNER_STATE_CONTENT);
							 break;
						 }
						 case SCANNER_STATE_REFERENCE: {
							 fMarkupDepth++;
							 setScannerState(SCANNER_STATE_CONTENT);
							 if (fEntityScanner.skipChar('#')) {
								 scanCharReference();
							 }
							 else {
								 scanEntityReference();
							 }
							 break;
						 }
						 case SCANNER_STATE_TEXT_DECL: {
							 if (fEntityScanner.skipString(""<?xml"")) {
								 fMarkupDepth++;
								 if (isValidNameChar(fEntityScanner.peekChar())) {
									 fStringBuffer.clear();
									 fStringBuffer.append(""xml"");
									 if (fNamespaces) {
										 while (isValidNCName(fEntityScanner.peekChar())) {
											 fStringBuffer.append((char)fEntityScanner.scanChar());
										 }
									 }
									 else {
										 while (isValidNameChar(fEntityScanner.peekChar())) {
											 fStringBuffer.append((char)fEntityScanner.scanChar());
										 }
									 }
									 String target = fSymbolTable.addSymbol(fStringBuffer.ch, fStringBuffer.offset, fStringBuffer.length);
									 scanPIData(target, fTempString);
								 }
								 else {
									 scanXMLDeclOrTextDecl(true);
								 }
							 }
							 fEntityManager.fCurrentEntity.mayReadChunks = true;
							 setScannerState(SCANNER_STATE_CONTENT);
							 break;
						 }
						 case SCANNER_STATE_ROOT_ELEMENT: {
							 if (scanRootElementHook()) {
								 return true;
							 }
							 setScannerState(SCANNER_STATE_CONTENT);
							 break;
						 }
						 case SCANNER_STATE_DOCTYPE: {
							 reportFatalError(""DoctypeIllegalInContent"", null);
							 setScannerState(SCANNER_STATE_CONTENT);
						 }
					 }
				 }
				 while (complete || again);
			 }
			 catch (MalformedByteSequenceException e) {
				 fErrorReporter.reportError(e.getDomain(), e.getKey(), e.getArguments(), XMLErrorReporter.SEVERITY_FATAL_ERROR, e);
				 return false;
			 }
			 catch (CharConversionException e) {
				 fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, ""CharConversionFailure"", null, XMLErrorReporter.SEVERITY_FATAL_ERROR, e);
				 return false;
			 }
			 catch (EOFException e) {
				 endOfFileHook(e);
				 return false;
			 }
			 return true;
		 }
		 protected boolean scanForDoctypeHook() throws IOException, XNIException {
			 return false;
		 }
		 protected boolean elementDepthIsZeroHook() throws IOException, XNIException {
			 return false;
		 }
		 protected boolean scanRootElementHook() throws IOException, XNIException {
			 return false;
		 }
		 protected void endOfFileHook(EOFException e) throws IOException, XNIException {
			 if (fMarkupDepth != 0) {
				 reportFatalError(""PrematureEOF"", null);
			 }
		 }
	 }
 }",1,0,0,0
"private Object invoke(String methodName, Object returnValueIfNonExistent, Class<T>[] paramTypes, Object[] params) throws DocletInvokeException {
	 Method meth;
	 try {
		 meth = docletClass.getMethod(methodName, paramTypes);
	 }
	 catch (NoSuchMethodException exc) {
		 if (returnValueIfNonExistent == null) {
			 messager.error(Messager.NOPOS, ""main.doclet_method_not_found"", docletClassName, methodName);
			 throw new DocletInvokeException();
		 }
		 else {
			 return returnValueIfNonExistent;
		 }
	 }
	 catch (SecurityException exc) {
		 messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"", docletClassName, methodName);
		 throw new DocletInvokeException();
	 }
	 if (!Modifier.isStatic(meth.getModifiers())) {
		 messager.error(Messager.NOPOS, ""main.doclet_method_must_be_static"", docletClassName, methodName);
		 throw new DocletInvokeException();
	 }
	 ClassLoader savedCCL = Thread.currentThread().getContextClassLoader();
	 try {
		 if (appClassLoader != null) Thread.currentThread().setContextClassLoader(appClassLoader);
		 return meth.invoke(null , params);
	 }
	 catch (IllegalArgumentException | NullPointerException exc) {
		 messager.error(Messager.NOPOS, ""main.internal_error_exception_thrown"", docletClassName, methodName, exc.toString());
		 throw new DocletInvokeException();
	 }
	 catch (IllegalAccessException exc) {
		 messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"", docletClassName, methodName);
		 throw new DocletInvokeException();
	 }
	 catch (InvocationTargetException exc) {
		 Throwable err = exc.getTargetException();
		 if (apiMode) throw new ClientCodeException(err);
		 if (err instanceof java.lang.OutOfMemoryError) {
			 messager.error(Messager.NOPOS, ""main.out.of.memory"");
		 }
		 else {
			 messager.error(Messager.NOPOS, ""main.exception_thrown"", docletClassName, methodName, exc.toString());
			 exc.getTargetException().printStackTrace(System.err);
		 }
		 throw new DocletInvokeException();
	 }
	 finally {
		 Thread.currentThread().setContextClassLoader(savedCCL);
	 }
 }",0,0,1,0
"public TarEntry getNextEntry() throws IOException {
	 if (this.hasHitEOF) {
		 return null;
	 }
	 if (this.currEntry != null) {
		 long numToSkip = this.entrySize - this.entryOffset;
		 if (this.debug) {
			 System.err.println(""TarInputStream: SKIP currENTRY '"" + this.currEntry.getName() + ""' SZ "" + this.entrySize + "" OFF "" + this.entryOffset + "" skipping "" + numToSkip + "" bytes"");
		 }
		 if (numToSkip > 0) {
			 this.skip(numToSkip);
		 }
		 this.readBuf = null;
	 }
	 byte[] headerBuf = this.buffer.readRecord();
	 if (headerBuf == null) {
		 if (this.debug) {
			 System.err.println(""READ NULL RECORD"");
		 }
		 this.hasHitEOF = true;
	 }
	 else if (this.buffer.isEOFRecord(headerBuf)) {
		 if (this.debug) {
			 System.err.println(""READ EOF RECORD"");
		 }
		 this.hasHitEOF = true;
	 }
	 if (this.hasHitEOF) {
		 this.currEntry = null;
	 }
	 else {
		 this.currEntry = new TarEntry(headerBuf);
		 if (this.debug) {
			 System.err.println(""TarInputStream: SET CURRENTRY '"" + this.currEntry.getName() + ""' size = "" + this.currEntry.getSize());
		 }
		 this.entryOffset = 0;
		 this.entrySize = this.currEntry.getSize();
	 }
	 if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {
		 StringBuffer longName = new StringBuffer();
		 byte[] buf = new byte[SMALL_BUFFER_SIZE];
		 int length = 0;
		 while ((length = read(buf)) >= 0) {
			 longName.append(new String(buf, 0, length));
		 }
		 getNextEntry();
		 if (this.currEntry == null) {
			 return null;
		 }
		 if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {
			 longName.deleteCharAt(longName.length() - 1);
		 }
		 this.currEntry.setName(longName.toString());
	 }
	 return this.currEntry;
 }",0,0,0,0
"public class FileIODecorator extends AbstractFileIO {
	 protected final FileIO delegate;
	 public FileIODecorator(FileIO delegate) {
		 this.delegate = delegate;
	 }
	 public int getFileSystemBlockSize() {
		 return delegate.getFileSystemBlockSize();
	 }
	 public long getSparseSize() {
		 return delegate.getSparseSize();
	 }
	 public int punchHole(long pos, int len) {
		 return delegate.punchHole(pos, len);
	 }
	 public long position() throws IOException {
		 return delegate.position();
	 }
	 public void position(long newPosition) throws IOException {
		 delegate.position(newPosition);
	 }
	 public int read(ByteBuffer destBuf) throws IOException {
		 return delegate.read(destBuf);
	 }
	 public int read(ByteBuffer destBuf, long position) throws IOException {
		 return delegate.read(destBuf, position);
	 }
	 public int read(byte[] buf, int off, int len) throws IOException {
		 return delegate.read(buf, off, len);
	 }
	 public int write(ByteBuffer srcBuf) throws IOException {
		 return delegate.write(srcBuf);
	 }
	 public int write(ByteBuffer srcBuf, long position) throws IOException {
		 return delegate.write(srcBuf, position);
	 }
	 public int write(byte[] buf, int off, int len) throws IOException {
		 return delegate.write(buf, off, len);
	 }
	 public MappedByteBuffer map(int sizeBytes) throws IOException {
		 return delegate.map(sizeBytes);
	 }
	 public void force() throws IOException {
		 delegate.force();
	 }
	 public void force(boolean withMetadata) throws IOException {
		 delegate.force(withMetadata);
	 }
	 public long size() throws IOException {
		 return delegate.size();
	 }
	 public void clear() throws IOException {
		 delegate.clear();
	 }
	 public void close() throws IOException {
		 delegate.close();
	 }
}",1,0,0,0
"public static class Offset implements FileOffset {
	 public long lastSyncPoint;
	 public long recordsSinceLastSync;
	 public long currentRecord;
	 private long currRecordEndOffset;
	 private long prevRecordEndOffset;
	 public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {
		 this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0 );
	 }
	 public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord , long currRecordEndOffset, long prevRecordEndOffset) {
		 this.lastSyncPoint = lastSyncPoint;
		 this.recordsSinceLastSync = recordsSinceLastSync;
		 this.currentRecord = currentRecord;
		 this.prevRecordEndOffset = prevRecordEndOffset;
		 this.currRecordEndOffset = currRecordEndOffset;
	 }
	 public Offset(String offset) {
		 try {
			 if(offset==null) {
				 throw new IllegalArgumentException(""offset cannot be null"");
			 }
			 if(offset.equalsIgnoreCase(""0"")) {
				 this.lastSyncPoint = 0;
				 this.recordsSinceLastSync = 0;
				 this.currentRecord = 0;
				 this.prevRecordEndOffset = 0;
				 this.currRecordEndOffset = 0;
			 }
			 else {
				 String[] parts = offset.split("":"");
				 this.lastSyncPoint = Long.parseLong(parts[0].split(""="")[1]);
				 this.recordsSinceLastSync = Long.parseLong(parts[1].split(""="")[1]);
				 this.currentRecord = Long.parseLong(parts[2].split(""="")[1]);
				 this.prevRecordEndOffset = 0;
				 this.currRecordEndOffset = 0;
			 }
		 }
		 catch (Exception e) {
			 throw new IllegalArgumentException(""'"" + offset + ""' cannot be interpreted. It is not in expected format for SequenceFileReader."" + "" Format e.g. {
			sync=123:afterSync=345:record=67}
			"");
		 }
	 }
	 public String toString() {
		 return '{
		' + ""sync="" + lastSyncPoint + "":afterSync="" + recordsSinceLastSync + "":record="" + currentRecord + "":}
		"";
	 }
	 public boolean isNextOffset(FileOffset rhs) {
		 if(rhs instanceof Offset) {
			 Offset other = ((Offset) rhs);
			 return other.currentRecord > currentRecord+1;
		 }
		 return false;
	 }
	 public int compareTo(FileOffset o) {
		 Offset rhs = ((Offset) o);
		 if(currentRecord<rhs.currentRecord) {
			 return -1;
		 }
		 if(currentRecord==rhs.currentRecord) {
			 return 0;
		 }
		 return 1;
	 }
	 public boolean equals(Object o) {
		 if (this == o) {
			 return true;
		 }
		 if (!(o instanceof Offset)) {
			 return false;
		 }
		 Offset offset = (Offset) o;
		 return currentRecord == offset.currentRecord;
	 }
	 public int hashCode() {
		 return (int) (currentRecord ^ (currentRecord >>> 32));
	 }
	 void increment(boolean syncSeen, long newBytePosition) {
		 if(!syncSeen) {
			 ++recordsSinceLastSync;
		 }
		 else {
			 recordsSinceLastSync = 1;
			 lastSyncPoint = prevRecordEndOffset;
		 }
		 ++currentRecord;
		 prevRecordEndOffset = currRecordEndOffset;
		 currentRecord = newBytePosition;
	 }
	 public Offset clone() {
		 return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);
	 }
 }",1,1,0,0
"public interface WritableFactory {
	 Writable newInstance();
}",0,0,0,0
"public class Quantifier extends EnumeratedAttribute {
	 private static final String[] VALUES = new String[] {
	""all"", ""each"", ""every"", ""any"", ""some"", ""one"", ""majority"", ""most"", ""none""}
	;
	 public static final Quantifier ALL = new Quantifier(""all"");
	 public static final Quantifier ANY = new Quantifier(""any"");
	 public static final Quantifier ONE = new Quantifier(""one"");
	 public static final Quantifier MAJORITY = new Quantifier(""majority"");
	 public static final Quantifier NONE = new Quantifier(""none"");
	 private abstract static class Predicate {
		 abstract boolean eval(int t, int f);
	 }
	 private static final Predicate ALL_PRED = new Predicate() {
		 boolean eval(int t, int f) {
			 return f == 0;
		 }
	 }
	;
	 private static final Predicate ANY_PRED = new Predicate() {
		 boolean eval(int t, int f) {
			 return t > 0;
		 }
	 }
	;
	 private static final Predicate ONE_PRED = new Predicate() {
		 boolean eval(int t, int f) {
			 return t == 1;
		 }
	 }
	;
	 private static final Predicate MAJORITY_PRED = new Predicate() {
		 boolean eval(int t, int f) {
			 return t > f;
		 }
	 }
	;
	 private static final Predicate NONE_PRED = new Predicate() {
		 boolean eval(int t, int f) {
			 return t == 0;
		 }
	 }
	;
	 private static final Predicate[] PREDS = new Predicate[VALUES.length];
	 static {
		 PREDS[0] = ALL_PRED;
		 PREDS[1] = ALL_PRED;
		 PREDS[2] = ALL_PRED;
		 PREDS[3] = ANY_PRED;
		 PREDS[4] = ANY_PRED;
		 PREDS[5] = ONE_PRED;
		 PREDS[6] = MAJORITY_PRED;
		 PREDS[7] = MAJORITY_PRED;
		 PREDS[8] = NONE_PRED;
	 }
	 public Quantifier() {
	 }
	 public Quantifier(String value) {
		 setValue(value);
	 }
	 public String[] getValues() {
		 return VALUES;
	 }
	 public boolean evaluate(boolean[] b) {
		 int t = 0;
		 for (int i = 0;
		 i < b.length;
		 i++) {
			 if (b[i]) {
				 t++;
			 }
		 }
		 return evaluate(t, b.length - t);
	 }
	 public boolean evaluate(int t, int f) {
		 int index = getIndex();
		 if (index == -1) {
			 throw new BuildException(""Quantifier value not set."");
		 }
		 return PREDS[index].eval(t, f);
	 }
}",0,0,0,0
";
 * interface, home interface, and EJB implementation class) and the EJB stubspublic class IPlanetEjbc {
	 private static final String ENTITY_BEAN = ""entity"";
	 private static final String STATELESS_SESSION = ""stateless"";
	 private static final String STATEFUL_SESSION = ""stateful"";
	 private File stdDescriptor;
	 private File iasDescriptor;
	 private File destDirectory;
	 private String classpath;
	 private String[] classpathElements;
	 private boolean retainSource = false;
	 private boolean debugOutput = false;
	 private File iasHomeDir;
	 private SAXParser parser;
	 private EjbcHandler handler = new EjbcHandler();
	 private Hashtable ejbFiles = new Hashtable();
	 private String displayName;
	 public IPlanetEjbc(File stdDescriptor, File iasDescriptor, File destDirectory, String classpath, SAXParser parser) {
		 this.stdDescriptor = stdDescriptor;
		 this.iasDescriptor = iasDescriptor;
		 this.destDirectory = destDirectory;
		 this.classpath = classpath;
		 this.parser = parser;
		 List elements = new ArrayList();
		 if (classpath != null) {
			 StringTokenizer st = new StringTokenizer(classpath, File.pathSeparator);
			 while (st.hasMoreTokens()) {
				 elements.add(st.nextToken());
			 }
			 classpathElements = (String[]) elements.toArray(new String[elements.size()]);
		 }
	 }
	 public void setRetainSource(boolean retainSource) {
		 this.retainSource = retainSource;
	 }
	 public void setDebugOutput(boolean debugOutput) {
		 this.debugOutput = debugOutput;
	 }
	 public void registerDTD(String publicID, String location) {
		 handler.registerDTD(publicID, location);
	 }
	 public void setIasHomeDir(File iasHomeDir) {
		 this.iasHomeDir = iasHomeDir;
	 }
	 public Hashtable getEjbFiles() {
		 return ejbFiles;
	 }
	 public String getDisplayName() {
		 return displayName;
	 }
	 public String[] getCmpDescriptors() {
		 List returnList = new ArrayList();
		 EjbInfo[] ejbs = handler.getEjbs();
		 for (int i = 0;
		 i < ejbs.length;
		 i++) {
			 List descriptors = (List) ejbs[i].getCmpDescriptors();
			 returnList.addAll(descriptors);
		 }
		 return (String[]) returnList.toArray(new String[returnList.size()]);
	 }
	 public static void main(String[] args) {
		 File stdDescriptor;
		 File iasDescriptor;
		 File destDirectory = null;
		 String classpath = null;
		 SAXParser parser = null;
		 boolean debug = false;
		 boolean retainSource = false;
		 IPlanetEjbc ejbc;
		 if ((args.length < 2) || (args.length > 8)) {
			 usage();
			 return;
		 }
		 stdDescriptor = new File(args[args.length - 2]);
		 iasDescriptor = new File(args[args.length - 1]);
		 for (int i = 0;
		 i < args.length - 2;
		 i++) {
			 if (args[i].equals(""-classpath"")) {
				 classpath = args[++i];
			 }
			 else if (args[i].equals(""-d"")) {
				 destDirectory = new File(args[++i]);
			 }
			 else if (args[i].equals(""-debug"")) {
				 debug = true;
			 }
			 else if (args[i].equals(""-keepsource"")) {
				 retainSource = true;
			 }
			 else {
				 usage();
				 return;
			 }
		 }
		 if (classpath == null) {
			 Properties props = System.getProperties();
			 classpath = props.getProperty(""java.class.path"");
		 }
		 if (destDirectory == null) {
			 Properties props = System.getProperties();
			 destDirectory = new File(props.getProperty(""user.dir""));
		 }
		 SAXParserFactory parserFactory = SAXParserFactory.newInstance();
		 parserFactory.setValidating(true);
		 try {
			 parser = parserFactory.newSAXParser();
		 }
		 catch (Exception e) {
			 System.out.println(""An exception was generated while trying to "");
			 System.out.println(""create a new SAXParser."");
			 e.printStackTrace();
			 return;
		 }
		 ejbc = new IPlanetEjbc(stdDescriptor, iasDescriptor, destDirectory, classpath, parser);
		 ejbc.setDebugOutput(debug);
		 ejbc.setRetainSource(retainSource);
		 try {
			 ejbc.execute();
		 }
		 catch (IOException e) {
			 System.out.println(""An IOException has occurred while reading the "" + ""XML descriptors ("" + e.getMessage() + "")."");
			 return;
		 }
		 catch (SAXException e) {
			 System.out.println(""A SAXException has occurred while reading the "" + ""XML descriptors ("" + e.getMessage() + "")."");
			 return;
		 }
		 catch (IPlanetEjbc.EjbcException e) {
			 System.out.println(""An error has occurred while executing the ejbc "" + ""utility ("" + e.getMessage() + "")."");
			 return;
		 }
	 }
	 private static void usage() {
		 System.out.println(""java org.apache.tools.ant.taskdefs.optional.ejb.IPlanetEjbc \\"");
		 System.out.println("" [OPTIONS] [EJB 1.1 descriptor] [iAS EJB descriptor]"");
		 System.out.println("""");
		 System.out.println(""Where OPTIONS are:"");
		 System.out.println("" -debug -- for additional debugging output"");
		 System.out.println("" -keepsource -- to retain Java source files generated"");
		 System.out.println("" -classpath [classpath] -- classpath used for compilation"");
		 System.out.println("" -d [destination directory] -- directory for compiled classes"");
		 System.out.println("""");
		 System.out.println(""If a classpath is not specified, the system classpath"");
		 System.out.println(""will be used. If a destination directory is not specified,"");
		 System.out.println(""the current working directory will be used (classes will"");
		 System.out.println(""still be placed in subfolders which correspond to their"");
		 System.out.println(""package name)."");
		 System.out.println("""");
		 System.out.println(""The EJB home interface, remote interface, and implementation"");
		 System.out.println(""class must be found in the destination directory. In"");
		 System.out.println(""addition, the destination will look for the stubs and skeletons"");
		 System.out.println(""in the destination directory to ensure they are up to date."");
	 }
	 public void execute() throws EjbcException, IOException, SAXException {
		 checkConfiguration();
		 EjbInfo[] ejbs = getEjbs();
		 for (int i = 0;
		 i < ejbs.length;
		 i++) {
			 log(""EJBInfo..."");
			 log(ejbs[i].toString());
		 }
		 for (int i = 0;
		 i < ejbs.length;
		 i++) {
			 EjbInfo ejb = ejbs[i];
			 ejb.checkConfiguration(destDirectory);
			 if (ejb.mustBeRecompiled(destDirectory)) {
				 log(ejb.getName() + "" must be recompiled using ejbc."");
				 String[] arguments = buildArgumentList(ejb);
				 callEjbc(arguments);
			 }
			 else {
				 log(ejb.getName() + "" is up to date."");
			 }
		 }
	 }
	 private void callEjbc(String[] arguments) {
		 StringBuffer args = new StringBuffer();
		 for (int i = 0;
		 i < arguments.length;
		 i++) {
			 args.append(arguments[i]).append("" "");
		 }
		 String command;
		 if (iasHomeDir == null) {
			 command = """";
		 }
		 else {
			 command = iasHomeDir.toString() + File.separator + ""bin"" + File.separator;
		 }
		 command += ""ejbc "";
		 log(command + args);
		 try {
			 Process p = Runtime.getRuntime().exec(command + args);
			 RedirectOutput output = new RedirectOutput(p.getInputStream());
			 RedirectOutput error = new RedirectOutput(p.getErrorStream());
			 output.start();
			 error.start();
			 p.waitFor();
			 p.destroy();
		 }
		 catch (IOException e) {
			 log(""An IOException has occurred while trying to execute ejbc."");
			 e.printStackTrace();
		 }
		 catch (InterruptedException e) {
		 }
	 }
	 protected void checkConfiguration() throws EjbcException {
		 String msg = """";
		 if (stdDescriptor == null) {
			 msg += ""A standard XML descriptor file must be specified. "";
		 }
		 if (iasDescriptor == null) {
			 msg += ""An iAS-specific XML descriptor file must be specified. "";
		 }
		 if (classpath == null) {
			 msg += ""A classpath must be specified. "";
		 }
		 if (parser == null) {
			 msg += ""An XML parser must be specified. "";
		 }
		 if (destDirectory == null) {
			 msg += ""A destination directory must be specified. "";
		 }
		 else if (!destDirectory.exists()) {
			 msg += ""The destination directory specified does not exist. "";
		 }
		 else if (!destDirectory.isDirectory()) {
			 msg += ""The destination specified is not a directory. "";
		 }
		 if (msg.length() > 0) {
			 throw new EjbcException(msg);
		 }
	 }
	 private EjbInfo[] getEjbs() throws IOException, SAXException {
		 EjbInfo[] ejbs = null;
		 parser.parse(stdDescriptor, handler);
		 parser.parse(iasDescriptor, handler);
		 ejbs = handler.getEjbs();
		 return ejbs;
	 }
	 private String[] buildArgumentList(EjbInfo ejb) {
		 List arguments = new ArrayList();
		 if (debugOutput) {
			 arguments.add(""-debug"");
		 }
		 if (ejb.getBeantype().equals(STATELESS_SESSION)) {
			 arguments.add(""-sl"");
		 }
		 else if (ejb.getBeantype().equals(STATEFUL_SESSION)) {
			 arguments.add(""-sf"");
		 }
		 if (ejb.getIiop()) {
			 arguments.add(""-iiop"");
		 }
		 if (ejb.getCmp()) {
			 arguments.add(""-cmp"");
		 }
		 if (retainSource) {
			 arguments.add(""-gs"");
		 }
		 if (ejb.getHasession()) {
			 arguments.add(""-fo"");
		 }
		 arguments.add(""-classpath"");
		 arguments.add(classpath);
		 arguments.add(""-d"");
		 arguments.add(destDirectory.toString());
		 arguments.add(ejb.getHome().getQualifiedClassName());
		 arguments.add(ejb.getRemote().getQualifiedClassName());
		 arguments.add(ejb.getImplementation().getQualifiedClassName());
		 return (String[]) arguments.toArray(new String[arguments.size()]);
	 }
	 private void log(String msg) {
		 if (debugOutput) {
			 System.out.println(msg);
		 }
	 }
	 public class EjbcException extends Exception {
		 public EjbcException(String msg) {
			 super(msg);
		 }
	 }
	 private class EjbcHandler extends HandlerBase {
		 private Map resourceDtds = new HashMap();
		 private Map fileDtds = new HashMap();
		 private Map ejbs = new HashMap();
		 private EjbInfo currentEjb;
		 private boolean iasDescriptor = false;
		 private String currentLoc = """";
		 private String currentText;
		 private String ejbType;
		 public EjbcHandler() {
			 final String PUBLICID_EJB11 = ""- final String PUBLICID_IPLANET_EJB_60 = ""- final String DEFAULT_IAS60_EJB11_DTD_LOCATION = ""ejb-jar_1_1.dtd"";
			 final String DEFAULT_IAS60_DTD_LOCATION = ""IASEjb_jar_1_0.dtd"";
			 registerDTD(PUBLICID_EJB11, DEFAULT_IAS60_EJB11_DTD_LOCATION);
			 registerDTD(PUBLICID_IPLANET_EJB_60, DEFAULT_IAS60_DTD_LOCATION);
		 }
		 public EjbInfo[] getEjbs() {
			 return (EjbInfo[]) ejbs.values().toArray(new EjbInfo[ejbs.size()]);
		 }
		 public String getDisplayName() {
			 return displayName;
		 }
		 public void registerDTD(String publicID, String location) {
			 log(""Registering: "" + location);
			 if ((publicID == null) || (location == null)) {
				 return;
			 }
			 if (ClassLoader.getSystemResource(location) != null) {
				 log(""Found resource: "" + location);
				 resourceDtds.put(publicID, location);
			 }
			 else {
				 File dtdFile = new File(location);
				 if (dtdFile.exists() && dtdFile.isFile()) {
					 log(""Found file: "" + location);
					 fileDtds.put(publicID, location);
				 }
			 }
		 }
		 public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
			 InputStream inputStream = null;
			 try {
				 String location = (String) resourceDtds.get(publicId);
				 if (location != null) {
					 inputStream = ClassLoader.getSystemResource(location).openStream();
				 }
				 else {
					 location = (String) fileDtds.get(publicId);
					 if (location != null) {
						 inputStream = new FileInputStream(location);
					 }
				 }
			 }
			 catch (IOException e) {
				 return super.resolveEntity(publicId, systemId);
			 }
			 if (inputStream == null) {
				 return super.resolveEntity(publicId, systemId);
			 }
			 else {
				 return new InputSource(inputStream);
			 }
		 }
		 public void startElement(String name, AttributeList atts) throws SAXException {
			 currentLoc += ""\\"" + name;
			 currentText = """";
			 if (currentLoc.equals(""\\ejb-jar"")) {
				 iasDescriptor = false;
			 }
			 else if (currentLoc.equals(""\\ias-ejb-jar"")) {
				 iasDescriptor = true;
			 }
			 if ((name.equals(""session"")) || (name.equals(""entity""))) {
				 ejbType = name;
			 }
		 }
		 public void characters(char[] ch, int start, int len) throws SAXException {
			 currentText += new String(ch).substring(start, start + len);
		 }
		 public void endElement(String name) throws SAXException {
			 if (iasDescriptor) {
				 iasCharacters(currentText);
			 }
			 else {
				 stdCharacters(currentText);
			 }
			 int nameLength = name.length() + 1;
			 int locLength = currentLoc.length();
			 currentLoc = currentLoc.substring(0, locLength - nameLength);
		 }
		 private void stdCharacters(String value) {
			 if (currentLoc.equals(""\\ejb-jar\\display-name"")) {
				 displayName = value;
				 return;
			 }
			 String base = ""\\ejb-jar\\enterprise-beans\\"" + ejbType;
			 if (currentLoc.equals(base + ""\\ejb-name"")) {
				 currentEjb = (EjbInfo) ejbs.get(value);
				 if (currentEjb == null) {
					 currentEjb = new EjbInfo(value);
					 ejbs.put(value, currentEjb);
				 }
			 }
			 else if (currentLoc.equals(base + ""\\home"")) {
				 currentEjb.setHome(value);
			 }
			 else if (currentLoc.equals(base + ""\\remote"")) {
				 currentEjb.setRemote(value);
			 }
			 else if (currentLoc.equals(base + ""\\ejb-class"")) {
				 currentEjb.setImplementation(value);
			 }
			 else if (currentLoc.equals(base + ""\\prim-key-class"")) {
				 currentEjb.setPrimaryKey(value);
			 }
			 else if (currentLoc.equals(base + ""\\session-type"")) {
				 currentEjb.setBeantype(value);
			 }
			 else if (currentLoc.equals(base + ""\\persistence-type"")) {
				 currentEjb.setCmp(value);
			 }
		 }
		 private void iasCharacters(String value) {
			 String base = ""\\ias-ejb-jar\\enterprise-beans\\"" + ejbType;
			 if (currentLoc.equals(base + ""\\ejb-name"")) {
				 currentEjb = (EjbInfo) ejbs.get(value);
				 if (currentEjb == null) {
					 currentEjb = new EjbInfo(value);
					 ejbs.put(value, currentEjb);
				 }
			 }
			 else if (currentLoc.equals(base + ""\\iiop"")) {
				 currentEjb.setIiop(value);
			 }
			 else if (currentLoc.equals(base + ""\\failover-required"")) {
				 currentEjb.setHasession(value);
			 }
			 else if (currentLoc.equals(base + ""\\persistence-manager"" + ""\\properties-file-location"")) {
				 currentEjb.addCmpDescriptor(value);
			 }
		 }
	 }
	 private class EjbInfo {
		 private String name;
		 private Classname home;
		 private Classname remote;
		 private Classname implementation;
		 private Classname primaryKey;
		 private String beantype = ""entity"";
		 private boolean cmp = false;
		 private boolean iiop = false;
		 private boolean hasession = false;
		 private List cmpDescriptors = new ArrayList();
		 public EjbInfo(String name) {
			 this.name = name;
		 }
		 public String getName() {
			 if (name == null) {
				 if (implementation == null) {
					 return ""[unnamed]"";
				 }
				 else {
					 return implementation.getClassName();
				 }
			 }
			 return name;
		 }
		 public void setHome(String home) {
			 setHome(new Classname(home));
		 }
		 public void setHome(Classname home) {
			 this.home = home;
		 }
		 public Classname getHome() {
			 return home;
		 }
		 public void setRemote(String remote) {
			 setRemote(new Classname(remote));
		 }
		 public void setRemote(Classname remote) {
			 this.remote = remote;
		 }
		 public Classname getRemote() {
			 return remote;
		 }
		 public void setImplementation(String implementation) {
			 setImplementation(new Classname(implementation));
		 }
		 public void setImplementation(Classname implementation) {
			 this.implementation = implementation;
		 }
		 public Classname getImplementation() {
			 return implementation;
		 }
		 public void setPrimaryKey(String primaryKey) {
			 setPrimaryKey(new Classname(primaryKey));
		 }
		 public void setPrimaryKey(Classname primaryKey) {
			 this.primaryKey = primaryKey;
		 }
		 public Classname getPrimaryKey() {
			 return primaryKey;
		 }
		 public void setBeantype(String beantype) {
			 this.beantype = beantype.toLowerCase();
		 }
		 public String getBeantype() {
			 return beantype;
		 }
		 public void setCmp(boolean cmp) {
			 this.cmp = cmp;
		 }
		 public void setCmp(String cmp) {
			 setCmp(cmp.equals(""Container""));
		 }
		 public boolean getCmp() {
			 return cmp;
		 }
		 public void setIiop(boolean iiop) {
			 this.iiop = iiop;
		 }
		 public void setIiop(String iiop) {
			 setIiop(iiop.equals(""true""));
		 }
		 public boolean getIiop() {
			 return iiop;
		 }
		 public void setHasession(boolean hasession) {
			 this.hasession = hasession;
		 }
		 public void setHasession(String hasession) {
			 setHasession(hasession.equals(""true""));
		 }
		 public boolean getHasession() {
			 return hasession;
		 }
		 public void addCmpDescriptor(String descriptor) {
			 cmpDescriptors.add(descriptor);
		 }
		 public List getCmpDescriptors() {
			 return cmpDescriptors;
		 }
		 private void checkConfiguration(File buildDir) throws EjbcException {
			 if (home == null) {
				 throw new EjbcException(""A home interface was not found "" + ""for the "" + name + "" EJB."");
			 }
			 if (remote == null) {
				 throw new EjbcException(""A remote interface was not found "" + ""for the "" + name + "" EJB."");
			 }
			 if (implementation == null) {
				 throw new EjbcException(""An EJB implementation class was not "" + ""found for the "" + name + "" EJB."");
			 }
			 if ((!beantype.equals(ENTITY_BEAN)) && (!beantype.equals(STATELESS_SESSION)) && (!beantype.equals(STATEFUL_SESSION))) {
				 throw new EjbcException(""The beantype found ("" + beantype + "") "" + ""isn't valid in the "" + name + "" EJB."");
			 }
			 if (cmp && (!beantype.equals(ENTITY_BEAN))) {
				 System.out.println(""CMP stubs and skeletons may not be generated"" + "" for a Session Bean -- the \""cmp\"" attribute will be"" + "" ignoredfor the "" + name + "" EJB."");
			 }
			 if (hasession && (!beantype.equals(STATEFUL_SESSION))) {
				 System.out.println(""Highly available stubs and skeletons may "" + ""only be generated for a Stateful Session Bean -- the "" + ""\""hasession\"" attribute will be ignored for the "" + name + "" EJB."");
			 }
			 if (!remote.getClassFile(buildDir).exists()) {
				 throw new EjbcException(""The remote interface "" + remote.getQualifiedClassName() + "" could not be "" + ""found."");
			 }
			 if (!home.getClassFile(buildDir).exists()) {
				 throw new EjbcException(""The home interface "" + home.getQualifiedClassName() + "" could not be "" + ""found."");
			 }
			 if (!implementation.getClassFile(buildDir).exists()) {
				 throw new EjbcException(""The EJB implementation class "" + implementation.getQualifiedClassName() + "" could "" + ""not be found."");
			 }
		 }
		 public boolean mustBeRecompiled(File destDir) {
			 long sourceModified = sourceClassesModified(destDir);
			 long destModified = destClassesModified(destDir);
			 return (destModified < sourceModified);
		 }
		 private long sourceClassesModified(File buildDir) {
			 long latestModified;
			 long modified;
			 File remoteFile;
			 File homeFile;
			 File implFile;
			 File pkFile;
			 remoteFile = remote.getClassFile(buildDir);
			 modified = remoteFile.lastModified();
			 if (modified == -1) {
				 System.out.println(""The class "" + remote.getQualifiedClassName() + "" couldn't "" + ""be found on the classpath"");
				 return -1;
			 }
			 latestModified = modified;
			 homeFile = home.getClassFile(buildDir);
			 modified = homeFile.lastModified();
			 if (modified == -1) {
				 System.out.println(""The class "" + home.getQualifiedClassName() + "" couldn't be "" + ""found on the classpath"");
				 return -1;
			 }
			 latestModified = Math.max(latestModified, modified);
			 if (primaryKey != null) {
				 pkFile = primaryKey.getClassFile(buildDir);
				 modified = pkFile.lastModified();
				 if (modified == -1) {
					 System.out.println(""The class "" + primaryKey.getQualifiedClassName() + ""couldn't be "" + ""found on the classpath"");
					 return -1;
				 }
				 latestModified = Math.max(latestModified, modified);
			 }
			 else {
				 pkFile = null;
			 }
			 implFile = implementation.getClassFile(buildDir);
			 modified = implFile.lastModified();
			 if (modified == -1) {
				 System.out.println(""The class "" + implementation.getQualifiedClassName() + "" couldn't be found on the classpath"");
				 return -1;
			 }
			 String pathToFile = remote.getQualifiedClassName();
			 pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
			 ejbFiles.put(pathToFile, remoteFile);
			 pathToFile = home.getQualifiedClassName();
			 pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
			 ejbFiles.put(pathToFile, homeFile);
			 pathToFile = implementation.getQualifiedClassName();
			 pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
			 ejbFiles.put(pathToFile, implFile);
			 if (pkFile != null) {
				 pathToFile = primaryKey.getQualifiedClassName();
				 pathToFile = pathToFile.replace('.', File.separatorChar) + "".class"";
				 ejbFiles.put(pathToFile, pkFile);
			 }
			 return latestModified;
		 }
		 private long destClassesModified(File destDir) {
			 String[] classnames = classesToGenerate();
			 long destClassesModified = new Date().getTime();
			 boolean allClassesFound = true;
			 for (int i = 0;
			 i < classnames.length;
			 i++) {
				 String pathToClass = classnames[i].replace('.', File.separatorChar) + "".class"";
				 File classFile = new File(destDir, pathToClass);
				 ejbFiles.put(pathToClass, classFile);
				 allClassesFound = allClassesFound && classFile.exists();
				 if (allClassesFound) {
					 long fileMod = classFile.lastModified();
					 destClassesModified = Math.min(destClassesModified, fileMod);
				 }
			 }
			 return (allClassesFound) ? destClassesModified : -1;
		 }
		 private String[] classesToGenerate() {
			 String[] classnames = (iiop) ? new String[15] : new String[9];
			 final String remotePkg = remote.getPackageName() + ""."";
			 final String remoteClass = remote.getClassName();
			 final String homePkg = home.getPackageName() + ""."";
			 final String homeClass = home.getClassName();
			 final String implPkg = implementation.getPackageName() + ""."";
			 final String implFullClass = implementation.getQualifiedWithUnderscores();
			 int index = 0;
			 classnames[index++] = implPkg + ""ejb_fac_"" + implFullClass;
			 classnames[index++] = implPkg + ""ejb_home_"" + implFullClass;
			 classnames[index++] = implPkg + ""ejb_skel_"" + implFullClass;
			 classnames[index++] = remotePkg + ""ejb_kcp_skel_"" + remoteClass;
			 classnames[index++] = homePkg + ""ejb_kcp_skel_"" + homeClass;
			 classnames[index++] = remotePkg + ""ejb_kcp_stub_"" + remoteClass;
			 classnames[index++] = homePkg + ""ejb_kcp_stub_"" + homeClass;
			 classnames[index++] = remotePkg + ""ejb_stub_"" + remoteClass;
			 classnames[index++] = homePkg + ""ejb_stub_"" + homeClass;
			 if (!iiop) {
				 return classnames;
			 }
			 classnames[index++] = ""org.omg.stub."" + remotePkg + ""_"" + remoteClass + ""_Stub"";
			 classnames[index++] = ""org.omg.stub."" + homePkg + ""_"" + homeClass + ""_Stub"";
			 classnames[index++] = ""org.omg.stub."" + remotePkg + ""_ejb_RmiCorbaBridge_"" + remoteClass + ""_Tie"";
			 classnames[index++] = ""org.omg.stub."" + homePkg + ""_ejb_RmiCorbaBridge_"" + homeClass + ""_Tie"";
			 classnames[index++] = remotePkg + ""ejb_RmiCorbaBridge_"" + remoteClass;
			 classnames[index++] = homePkg + ""ejb_RmiCorbaBridge_"" + homeClass;
			 return classnames;
		 }
		 public String toString() {
			 String s = ""EJB name: "" + name + ""\n\r home: "" + home + ""\n\r remote: "" + remote + ""\n\r impl: "" + implementation + ""\n\r primaryKey: "" + primaryKey + ""\n\r beantype: "" + beantype + ""\n\r cmp: "" + cmp + ""\n\r iiop: "" + iiop + ""\n\r hasession: "" + hasession;
			 Iterator i = cmpDescriptors.iterator();
			 while (i.hasNext()) {
				 s += ""\n\r CMP Descriptor: "" + i.next();
			 }
			 return s;
		 }
	 }
	 private static class Classname {
		 private String qualifiedName;
		 private String packageName;
		 private String className;
		 public Classname(String qualifiedName) {
			 if (qualifiedName == null) {
				 return;
			 }
			 this.qualifiedName = qualifiedName;
			 int index = qualifiedName.lastIndexOf('.');
			 if (index == -1) {
				 className = qualifiedName;
				 packageName = """";
			 }
			 else {
				 packageName = qualifiedName.substring(0, index);
				 className = qualifiedName.substring(index + 1);
			 }
		 }
		 public String getQualifiedClassName() {
			 return qualifiedName;
		 }
		 public String getPackageName() {
			 return packageName;
		 }
		 public String getClassName() {
			 return className;
		 }
		 public String getQualifiedWithUnderscores() {
			 return qualifiedName.replace('.', '_');
		 }
		 public File getClassFile(File directory) {
			 String pathToFile = qualifiedName.replace('.', File.separatorChar) + "".class"";
			 return new File(directory, pathToFile);
		 }
		 public String toString() {
			 return getQualifiedClassName();
		 }
	 }
	 private static class RedirectOutput extends Thread {
		 InputStream stream;
		 public RedirectOutput(InputStream stream) {
			 this.stream = stream;
		 }
		 public void run() {
			 BufferedReader reader = new BufferedReader( new InputStreamReader(stream));
			 String text;
			 try {
				 while ((text = reader.readLine()) != null) {
					 System.out.println(text);
				 }
			 }
			 catch (IOException e) {
				 e.printStackTrace();
			 }
			 finally {
				 try {
					 reader.close();
				 }
				 catch (IOException e) {
				 }
			 }
		 }
	 }
 }",1,0,0,0
"public void setPoint(String p) {
	 point = Integer.parseInt(p);
 }",0,0,0,0
"public class SimpleCustomPartitioner extends Partitioner<PigNullableWritable, Writable> {
	public int getPartition(PigNullableWritable key, Writable value, int numPartitions) {
		if(key.getValueAsPigType() instanceof Integer) {
			int ret = (((Integer)key.getValueAsPigType()).intValue() % numPartitions);
			return ret;
		}
		else {
			return (key.hashCode()) % numPartitions;
		}
	}
}",1,0,0,0
"public class TestSecondarySortTez extends TestSecondarySort {
	 public TestSecondarySortTez() {
		 super();
	 }
	 public MiniGenericCluster getCluster() {
		 return MiniGenericCluster.buildCluster(MiniGenericCluster.EXECTYPE_TEZ);
	 }
	 public SecondaryKeyOptimizer visitSecondaryKeyOptimizer(String query) throws Exception, VisitorException {
		 PhysicalPlan pp = Util.buildPp(pigServer, query);
		 TezCompiler comp = new TezCompiler(pp, pc);
		 TezOperPlan tezPlan = comp.compile();
		 boolean nocombiner = Boolean.parseBoolean(pc.getProperties().getProperty( PigConfiguration.PIG_EXEC_NO_COMBINER, ""false""));
		 if (!nocombiner) {
			 boolean doMapAgg = Boolean.parseBoolean(pc.getProperties() .getProperty(PigConfiguration.PIG_EXEC_MAP_PARTAGG, ""false""));
			 CombinerOptimizer co = new CombinerOptimizer(tezPlan, doMapAgg);
			 co.visit();
		 }
		 SecondaryKeyOptimizerTez skOptimizer = new SecondaryKeyOptimizerTez( tezPlan);
		 skOptimizer.visit();
		 return skOptimizer;
	 }
}",1,0,0,0
"public DVRecord(int validationType, int operator, int errorStyle, boolean emptyCellAllowed,boolean suppressDropDownArrow, boolean isExplicitList,boolean showPromptBox, String promptTitle, String promptText, boolean showErrorBox, String errorTitle, String errorText,Ptg[] formula1, Ptg[] formula2,CellRangeAddressList regions);",0,0,0,1
"public class ZipResource extends ArchiveResource {
	 private String encoding;
	 private ZipExtraField[] extras;
	 private int method;
	 public ZipResource() {
	 }
	 public ZipResource(File z, String enc, ZipEntry e) {
		 super(z, true);
		 setEncoding(enc);
		 setEntry(e);
	 }
	 public void setZipfile(File z) {
		 setArchive(z);
	 }
	 public File getZipfile() {
		 FileProvider fp = (FileProvider) getArchive().as(FileProvider.class);
		 return fp.getFile();
	 }
	 public void addConfigured(ResourceCollection a) {
		 super.addConfigured(a);
		 if (!a.isFilesystemOnly()) {
			 throw new BuildException(""only filesystem resources are supported"");
		 }
	 }
	 public void setEncoding(String enc) {
		 checkAttributesAllowed();
		 encoding = enc;
	 }
	 public String getEncoding() {
		 return isReference() ? ((ZipResource) getCheckedRef()).getEncoding() : encoding;
	 }
	 public void setRefid(Reference r) {
		 if (encoding != null) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 public InputStream getInputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getInputStream();
		 }
		 final ZipFile z = new ZipFile(getZipfile(), getEncoding());
		 ZipEntry ze = z.getEntry(getName());
		 if (ze == null) {
			 z.close();
			 throw new BuildException(""no entry "" + getName() + "" in "" + getArchive());
		 }
		 return new FilterInputStream(z.getInputStream(ze)) {
			 public void close() throws IOException {
				 FileUtils.close(in);
				 z.close();
			 }
			 protected void finalize() throws Throwable {
				 try {
					 close();
				 }
				 finally {
					 super.finalize();
				 }
			 }
		 }
		;
	 }
	 public OutputStream getOutputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getOutputStream();
		 }
		 throw new UnsupportedOperationException( ""Use the zip task for zip output."");
	 }
	 public ZipExtraField[] getExtraFields() {
		 if (isReference()) {
			 return ((ZipResource) getCheckedRef()).getExtraFields();
		 }
		 checkEntry();
		 if (extras == null) {
			 return new ZipExtraField[0];
		 }
		 return extras;
	 }
	 public int getMethod() {
		 return method;
	 }
	 protected void fetchEntry() {
		 ZipFile z = null;
		 try {
			 z = new ZipFile(getZipfile(), getEncoding());
			 setEntry(z.getEntry(getName()));
		 }
		 catch (IOException e) {
			 log(e.getMessage(), Project.MSG_DEBUG);
			 throw new BuildException(e);
		 }
		 finally {
			 ZipFile.closeQuietly(z);
		 }
	 }
	 private void setEntry(ZipEntry e) {
		 if (e == null) {
			 setExists(false);
			 return;
		 }
		 setName(e.getName());
		 setExists(true);
		 setLastModified(e.getTime());
		 setDirectory(e.isDirectory());
		 setSize(e.getSize());
		 setMode(e.getUnixMode());
		 extras = e.getExtraFields(true);
		 method = e.getMethod();
	 }
}",0,0,0,0
"public class BeamIntersectRel extends Intersect implements BeamRelNode {
	 public BeamIntersectRel( RelOptCluster cluster, RelTraitSet traits, List<RelNode> inputs, boolean all) {
		 super(cluster, traits, inputs, all);
	 }
	 public SetOp copy(RelTraitSet traitSet, List<RelNode> inputs, boolean all) {
		 return new BeamIntersectRel(getCluster(), traitSet, inputs, all);
	 }
	 public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {
		 return new BeamSetOperatorRelBase(this, BeamSetOperatorRelBase.OpType.INTERSECT, all);
	 }
}",1,0,0,0
"public abstract class AbstractStoreOutputOperator<T, S extends Connectable> extends BaseOperator{
	 protected S store;
	 public final transient DefaultInputPort<T> input = new DefaultInputPort<T>() {
		 public void process(T t) {
			 processTuple(t);
		 }
	 }
	;
	 public S getStore() {
		 return store;
	 }
	 public void setStore(S store) {
		 this.store = store;
	 }
	 public void setup(OperatorContext context) {
		 try {
			 store.connect();
		 }
		 catch (IOException ex) {
			 throw new RuntimeException(ex);
		 }
	 }
	 public void beginWindow(long windowId) {
	 }
	 public void teardown() {
		 try {
			 store.disconnect();
		 }
		 catch (IOException ex) {
			 throw new RuntimeException(ex);
		 }
	 }
	 public abstract void processTuple(T tuple);
}",0,1,0,0
"public synchronized Object[] pendingTransfers(DatanodeID srcNode, int xmitsInProgress) {
	 synchronized (neededReplications) {
		 Object results[] = null;
		 int scheduledXfers = 0;
		 if (neededReplications.size() > 0) {
			 Vector replicateBlocks = new Vector();
			 Vector replicateTargetSets = new Vector();
			 for (Iterator it = neededReplications.iterator();
			 it.hasNext();
			) {
				 if (scheduledXfers >= this.maxReplicationStreams - xmitsInProgress) {
					 break;
				 }
				 Block block = (Block) it.next();
				 long blockSize = block.getNumBytes();
				 FSDirectory.INode fileINode = dir.getFileByBlock(block);
				 if (fileINode == null) {
					 it.remove();
				 }
				 else {
					 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
					 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get( srcNode.getStorageID() );
					 if (containingNodes.contains(srcNode) && (excessBlocks == null || ! excessBlocks.contains(block))) {
						 DatanodeDescriptor targets[] = chooseTargets( Math.min( fileINode.getReplication() - containingNodes.size(), this.maxReplicationStreams - xmitsInProgress), containingNodes, null, blockSize);
						 if (targets.length > 0) {
							 replicateBlocks.add(block);
							 replicateTargetSets.add(targets);
							 scheduledXfers += targets.length;
						 }
					 }
				 }
			 }
			 if (replicateBlocks.size() > 0) {
				 int i = 0;
				 for (Iterator it = replicateBlocks.iterator();
				 it.hasNext();
				 i++) {
					 Block block = (Block) it.next();
					 DatanodeDescriptor targets[] = (DatanodeDescriptor[]) replicateTargetSets.elementAt(i);
					 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
					 if (containingNodes.size() + targets.length >= dir.getFileByBlock( block).getReplication() ) {
						 neededReplications.remove(block);
						 pendingReplications.add(block);
						 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.pendingTransfer: "" + block.getBlockName() + "" is removed from neededReplications to pendingReplications"");
					 }
					 if (NameNode.stateChangeLog.isInfoEnabled()) {
						 StringBuffer targetList = new StringBuffer(""datanode(s)"");
						 for (int k = 0;
						 k < targets.length;
						 k++) {
							 targetList.append(' ');
							 targetList.append(targets[k].getName());
						 }
						 NameNode.stateChangeLog.info( ""BLOCK* NameSystem.pendingTransfer: "" + ""ask "" + srcNode.getName() + "" to replicate "" + block.getBlockName() + "" to "" + targetList);
					 }
				 }
				 DatanodeDescriptor targetMatrix[][] = new DatanodeDescriptor[replicateTargetSets.size()][];
				 for (i = 0;
				 i < targetMatrix.length;
				 i++) {
					 targetMatrix[i] = (DatanodeDescriptor[]) replicateTargetSets.elementAt(i);
				 }
				 results = new Object[2];
				 results[0] = replicateBlocks.toArray(new Block[replicateBlocks.size()]);
				 results[1] = targetMatrix;
			 }
		 }
		 return results;
	 }
 }",0,0,1,0
"private void renderBucket(Display display, int bx, int by, int threadID, IntersectionState istate) {
	 int x0 = bx * bucketSize;
	 int y0 = by * bucketSize;
	 int bw = Math.min(bucketSize, imageWidth - x0);
	 int bh = Math.min(bucketSize, imageHeight - y0);
	 display.imagePrepare(x0, y0, bw, bh, threadID);
	 Color[] bucketRGB = new Color[bw * bh];
	 int sx0 = x0 * subPixelSize - fs;
	 int sy0 = y0 * subPixelSize - fs;
	 int sbw = bw * subPixelSize + fs * 2;
	 int sbh = bh * subPixelSize + fs * 2;
	 sbw = (sbw + (maxStepSize - 1)) & (~(maxStepSize - 1));
	 sbh = (sbh + (maxStepSize - 1)) & (~(maxStepSize - 1));
	 if (maxStepSize > 1) {
		 sbw++;
		 sbh++;
	 }
	 ImageSample[] samples = new ImageSample[sbw * sbh];
	 float invSubPixelSize = 1.0f / subPixelSize;
	 for (int y = 0, index = 0;
	 y < sbh;
	 y++) {
		 for (int x = 0;
		 x < sbw;
		 x++, index++) {
			 int sx = sx0 + x;
			 int sy = sy0 + y;
			 int j = sx & (sigma.length - 1);
			 int k = sy & (sigma.length - 1);
			 int i = j * sigma.length + sigma[k];
			 float dx = useJitter ? (float) sigma[k] / (float) sigma.length : 0.5f;
			 float dy = useJitter ? (float) sigma[j] / (float) sigma.length : 0.5f;
			 float rx = (sx + dx) * invSubPixelSize;
			 float ry = (sy + dy) * invSubPixelSize;
			 ry = imageHeight - ry - 1;
			 samples[index] = new ImageSample(rx, ry, i);
		 }
	 }
	 for (int x = 0;
	 x < sbw - 1;
	 x += maxStepSize) for (int y = 0;
	 y < sbh - 1;
	 y += maxStepSize) refineSamples(samples, sbw, x, y, maxStepSize, thresh, istate);
	 if (dumpBuckets) {
		 UI.printInfo(Module.BCKT, ""Dumping bucket [%d, %d] to file ..."", bx, by);
		 Bitmap bitmap = new Bitmap(sbw, sbh, true);
		 for (int y = sbh - 1, index = 0;
		 y >= 0;
		 y--) for (int x = 0;
		 x < sbw;
		 x++, index++) bitmap.setPixel(x, y, samples[index].c.copy().toNonLinear());
		 bitmap.save(String.format(""bucket_%04d_%04d.png"", bx, by));
	 }
	 if (displayAA) {
		 float invArea = invSubPixelSize * invSubPixelSize;
		 for (int y = 0, index = 0;
		 y < bh;
		 y++) {
			 for (int x = 0;
			 x < bw;
			 x++, index++) {
				 int sampled = 0;
				 for (int i = 0;
				 i < subPixelSize;
				 i++) {
					 for (int j = 0;
					 j < subPixelSize;
					 j++) {
						 int sx = x * subPixelSize + fs + i;
						 int sy = y * subPixelSize + fs + j;
						 int s = sx + sy * sbw;
						 sampled += samples[s].sampled() ? 1 : 0;
					 }
				 }
				 bucketRGB[index] = new Color(sampled * invArea);
			 }
		 }
	 }
	 else {
		 float cy = imageHeight - 1 - (y0 + 0.5f);
		 for (int y = 0, index = 0;
		 y < bh;
		 y++, cy--) {
			 float cx = x0 + 0.5f;
			 for (int x = 0;
			 x < bw;
			 x++, index++, cx++) {
				 Color c = Color.black();
				 float weight = 0.0f;
				 for (int j = -fs, sy = y * subPixelSize;
				 j <= fs;
				 j++, sy++) {
					 for (int i = -fs, sx = x * subPixelSize, s = sx + sy * sbw;
					 i <= fs;
					 i++, sx++, s++) {
						 float dx = samples[s].rx - cx;
						 if (Math.abs(dx) > fhs) continue;
						 float dy = samples[s].ry - cy;
						 if (Math.abs(dy) > fhs) continue;
						 float f = filter.get(dx, dy);
						 c.madd(f, samples[s].c);
						 weight += f;
					 }
				 }
				 c.mul(1.0f / weight);
				 bucketRGB[index] = c;
			 }
		 }
	 }
	 display.imageUpdate(x0, y0, bw, bh, bucketRGB);
 }",0,0,1,0
"public void save() {
	FileOutputStream fw = null;
	try {
		StringBuilder sb = new StringBuilder();
		if (url == null)throw new NullPointerException(""url is null"");
		sb.append(""type: "" + getType() + ""\n"");
		sb.append(""url: "" + url + ""\n"");
		sb.append(""size: "" + size + ""\n"");
		if (headers != null) {
			Iterator<HttpHeader> headerIterator = headers.getAll();
			while (headerIterator.hasNext()) {
				HttpHeader header = headerIterator.next();
				sb.append(""header: "" + header.getName() + "":"" + header.getValue() + ""\n"");
			}
		}
		if (getType() == XDMConstants.HDS) {
			sb.append(""bitrate: "" + ((HdsMetadata) this).getBitRate() + ""\n"");
		}
		if (getType() == XDMConstants.DASH) {
			sb.append(""url2: "" + ((DashMetadata) this).getUrl2() + ""\n"");
			sb.append(""len1: "" + ((DashMetadata) this).getLen1() + ""\n"");
			sb.append(""len2: "" + ((DashMetadata) this).getLen2() + ""\n"");
			if (((DashMetadata) this).getHeaders2() != null) {
				Iterator<HttpHeader> headerIterator = ((DashMetadata) this).getHeaders2().getAll();
				while (headerIterator.hasNext()) {
					HttpHeader header = headerIterator.next();
					sb.append(""header2: "" + header.getName() + "":"" + header.getValue() + ""\n"");
				}
			}
		}
		if (!StringUtils.isNullOrEmptyOrBlank(ydlUrl)) {
			sb.append(""ydlUrl: "" + ydlUrl);
		}
		File metadataFolder = new File(Config.getInstance().getMetadataFolder());
		if (!metadataFolder.exists()) {
			metadataFolder.mkdirs();
		}
		File file = new File(metadataFolder, id);
		fw = new FileOutputStream(file);
		fw.write(sb.toString().getBytes());
		fw.close();
	}
	 catch (Exception e) {
		Logger.log(e);
		if (fw != null) {
			try {
				fw.close();
			}
			 catch (Exception ex) {
			}
		}
	}
}",0,0,1,0
"public String getEncoding(){
	return encoding;
}",0,0,0,0
"protected void createButtonGroup( Group grpTop ){
	btnAdd = new Button( grpTop, SWT.NONE );
	{
		btnAdd.setText( Messages.getString( ""LineSeriesMarkerSheet.Label.Add"" ) );
		 btnAdd.addSelectionListener( this );
	}
	newMarkerEditor = new MarkerEditorComposite( grpTop,createMarker( ),getContext( ),getDefaultMarker( ) );
	if ( markerTypeSet != null ){
		newMarkerEditor.setSupportedMarkerTypes( markerTypeSet );
	}
	if ( outlineText != null ){
		newMarkerEditor.setOutlineText( outlineText );
	}
	btnRemove = new Button( grpTop, SWT.NONE );
	{
		btnRemove.setText( Messages.getString( ""LineSeriesMarkerSheet.Label.Remove"" ) );
		 btnRemove.addSelectionListener( this );
	}
	btnUp = new Button( grpTop, SWT.ARROW | SWT.UP );
	{
		btnUp.setToolTipText( Messages.getString( ""PaletteEditorComposite.Lbl.Up"" ) );
		 btnUp.addSelectionListener( this );
	}
	btnDown = new Button( grpTop, SWT.ARROW | SWT.DOWN );
	{
		btnDown.setToolTipText( Messages.getString( ""PaletteEditorComposite.Lbl.Down"" ) );
		 btnDown.addSelectionListener( this );
	}
}",0,0,1,0
"private void positionWriterAtCheckpoint() {
	 writerChkptDK = new CheckpointDataKey(jobExecutionImpl.getJobInstance().getInstanceId(), step.getId(), CheckpointType.WRITER);
	 CheckpointData writerData = persistenceManagerService.getCheckpointData(writerChkptDK);
	 try {
		 if (writerData != null) {
			 byte[] writertoken = writerData.getRestartToken();
			 TCCLObjectInputStream writerOIS;
			 try {
				 writerProxy.open((Serializable) dataRepresentationService.toJavaRepresentation(writertoken));
			 }
			 catch (Exception ex) {
				 throw new BatchContainerServiceException(""Cannot read the checkpoint data for ["" + step.getId() + ""]"", ex);
			 }
		 }
		 else {
			 writerData = null;
			 try {
				 writerProxy.open(null);
			 }
			 catch (Exception ex) {
				 throw new BatchContainerServiceException(""Cannot open the step ["" + step.getId() + ""]"", ex);
			 }
		 }
	 }
	 catch (ClassCastException e) {
		 throw new IllegalStateException(""Expected CheckpointData but found"" + writerData);
	 }
 }",0,0,1,0
"public Task obtainNewMapTask(String taskTracker, TaskTrackerStatus tts) {
	 if (! tasksInited) {
		 LOG.info(""Cannot create task split for "" + profile.getJobId());
		 return null;
	 }
	 Task t = null;
	 int cacheTarget = -1;
	 int stdTarget = -1;
	 int specTarget = -1;
	 int failedTarget = -1;
	 double avgProgress = status.mapProgress() / maps.length;
	 ArrayList hostMaps = (ArrayList)hostToMaps.get(tts.getHost());
	 if (hostMaps != null) {
		 Iterator i = hostMaps.iterator();
		 while (i.hasNext()) {
			 TaskInProgress tip = (TaskInProgress)i.next();
			 if (tip.hasTask() && !tip.hasFailedOnMachine(taskTracker)) {
				 LOG.info(""Found task with local split for ""+tts.getHost());
				 cacheTarget = tip.getIdWithinJob();
				 i.remove();
				 break;
			 }
		 }
	 }
	 if (cacheTarget < 0) {
		 for (int i = 0;
		 i < maps.length;
		 i++) {
			 int realIdx = (i + firstMapToTry) % maps.length;
			 if (maps[realIdx].hasTask()) {
				 if (stdTarget < 0) {
					 if (maps[realIdx].hasFailedOnMachine(taskTracker)) {
						 if (failedTarget < 0) {
							 failedTarget = realIdx;
						 }
					 }
					 else {
						 stdTarget = realIdx;
						 break;
					 }
				 }
			 }
		 }
	 }
	 if (cacheTarget < 0 && stdTarget < 0) {
		 for (int i = 0;
		 i < maps.length;
		 i++) {
			 int realIdx = (i + firstMapToTry) % maps.length;
			 if (maps[realIdx].hasSpeculativeTask(avgProgress)) {
				 if (!maps[realIdx].hasFailedOnMachine(taskTracker)) {
					 specTarget = realIdx;
					 break;
				 }
			 }
		 }
	 }
	 if (cacheTarget >= 0) {
		 t = maps[cacheTarget].getTaskToRun(taskTracker, tts, avgProgress);
		 runningMapTasks += 1;
	 }
	 else if (stdTarget >= 0) {
		 t = maps[stdTarget].getTaskToRun(taskTracker, tts, avgProgress);
		 runningMapTasks += 1;
	}
	 else if (specTarget >= 0) {
		 boolean isRunning = maps[specTarget].isRunning();
		 t = maps[specTarget].getTaskToRun(taskTracker, tts, avgProgress);
		 if (!isRunning){
			 runningMapTasks += 1;
		 }
	 }
	 else if (failedTarget >= 0) {
		 boolean isRunning = maps[failedTarget].isRunning();
		 t = maps[failedTarget].getTaskToRun(taskTracker, tts, avgProgress);
		 if (!isRunning) {
			 runningMapTasks += 1;
		 }
	 }
	 return t;
 }",0,0,1,0
"public class BinaryInputArchive implements InputArchive {
	 private DataInput in;
	 static BinaryInputArchive getArchive(InputStream strm) {
		 return new BinaryInputArchive(new DataInputStream(strm));
	 }
	 static private class BinaryIndex implements Index {
		 private int nelems;
		 BinaryIndex(int nelems) {
			 this.nelems = nelems;
		 }
		 public boolean done() {
			 return (nelems <= 0);
		 }
		 public void incr() {
			 nelems--;
		 }
	 }
	 public BinaryInputArchive(DataInput in) {
		 this.in = in;
	 }
	 public byte readByte(String tag) throws IOException {
		 return in.readByte();
	 }
	 public boolean readBool(String tag) throws IOException {
		 return in.readBoolean();
	 }
	 public int readInt(String tag) throws IOException {
		 return Utils.readInt(in);
	 }
	 public long readLong(String tag) throws IOException {
		 return Utils.readLong(in);
	 }
	 public float readFloat(String tag) throws IOException {
		 return in.readFloat();
	 }
	 public double readDouble(String tag) throws IOException {
		 return in.readDouble();
	 }
	 public String readString(String tag) throws IOException {
		 int len = Utils.readInt(in);
		 byte[] chars = new byte[len];
		 in.readFully(chars);
		 return new String(chars, ""UTF-8"");
	 }
	 public ByteArrayOutputStream readBuffer(String tag) throws IOException {
		 int len = Utils.readInt(in);
		 ByteArrayOutputStream buf = new ByteArrayOutputStream(len);
		 byte[] arr = new byte[len];
		 in.readFully(arr);
		 buf.write(arr, 0, len);
		 return buf;
	 }
	 public void readRecord(Record r, String tag) throws IOException {
		 r.deserialize(this, tag);
	 }
	 public void startRecord(String tag) throws IOException {
	}
	 public void endRecord(String tag) throws IOException {
	}
	 public Index startVector(String tag) throws IOException {
		 return new BinaryIndex(Utils.readInt(in));
	 }
	 public void endVector(String tag) throws IOException {
	}
	 public Index startMap(String tag) throws IOException {
		 return new BinaryIndex(Utils.readInt(in));
	 }
	 public void endMap(String tag) throws IOException {
	}
}",0,0,0,0
"public boolean prepare() throws IOException {
	 this.mapOutputFile.removeAll(reduceTask.getTaskId());
	 final int numOutputs = reduceTask.getNumMaps();
	 List neededOutputs = new ArrayList(numOutputs);
	 List knownOutputs = new ArrayList(100);
	 int numInFlight = 0, numCopied = 0;
	 int lowThreshold = numCopiers*2;
	 long bytesTransferred = 0;
	 DecimalFormat mbpsFormat = new DecimalFormat(""0.00"");
	 Random backoff = new Random();
	 final Progress copyPhase = getTask().getProgress().phase();
	 MapCopyLeaseChecker leaseChecker = null;
	 for (int i = 0;
	 i < numOutputs;
	 i++) {
		 neededOutputs.add(new Integer(i));
		 copyPhase.addPhase();
	 }
	 InterTrackerProtocol jobClient = getTracker().getJobClient();
	 copiers = new MapOutputCopier[numCopiers];
	 for (int i=0;
	 i < copiers.length;
	 i++) {
		 copiers[i] = new MapOutputCopier();
		 copiers[i].start();
	 }
	 leaseChecker = new MapCopyLeaseChecker();
	 leaseChecker.start();
	 long startTime = System.currentTimeMillis();
	 long currentTime = startTime;
	 while (!killed && numCopied < numOutputs) {
		 LOG.info(reduceTask.getTaskId() + "" Need "" + (numOutputs-numCopied) + "" map output(s)"");
		 if (!neededOutputs.isEmpty()) {
			 LOG.info(reduceTask.getTaskId() + "" Need "" + neededOutputs.size() + "" map output location(s)"");
			 try {
				 MapOutputLocation[] locs = queryJobTracker(neededOutputs, jobClient);
				 for (int i=0;
				 i < locs.length;
				 i++) {
					 neededOutputs.remove(new Integer(locs[i].getMapId()));
					 knownOutputs.add(locs[i]);
				 }
				 LOG.info(reduceTask.getTaskId() + "" Got "" + (locs == null ? 0 : locs.length) + "" map outputs from jobtracker"");
			 }
			 catch (IOException ie) {
				 LOG.warn(reduceTask.getTaskId() + "" Problem locating map outputs: "" + StringUtils.stringifyException(ie));
			 }
		 }
		 int numKnown = knownOutputs.size(), numScheduled = 0;
		 int numSlow = 0, numDups = 0;
		 LOG.info(reduceTask.getTaskId() + "" Got "" + numKnown + "" known map output location(s);
		 scheduling..."");
		 synchronized (scheduledCopies) {
			 ListIterator locIt = knownOutputs.listIterator();
			 currentTime = System.currentTimeMillis();
			 while (locIt.hasNext()) {
				 MapOutputLocation loc = (MapOutputLocation)locIt.next();
				 Long penaltyEnd = (Long)penaltyBox.get(loc.getHost());
				 boolean penalized = false, duplicate = false;
				 if (penaltyEnd != null && currentTime < penaltyEnd.longValue()) {
					 penalized = true;
					 numSlow++;
				 }
				 if (uniqueHosts.contains(loc.getHost())) {
					 duplicate = true;
					 numDups++;
				 }
				 if (!penalized && !duplicate) {
					 uniqueHosts.add(loc.getHost());
					 scheduledCopies.add(loc);
					 locIt.remove();
					 numInFlight++;
					 numScheduled++;
				 }
			 }
			 scheduledCopies.notifyAll();
		 }
		 LOG.info(reduceTask.getTaskId() + "" Scheduled "" + numScheduled + "" of "" + numKnown + "" known outputs ("" + numSlow + "" slow hosts and "" + numDups + "" dup hosts)"");
		 try {
			 if (numInFlight == 0 && numScheduled == 0) {
				 getTask().reportProgress(getTracker());
				 Thread.sleep(5000);
			 }
		 }
		 catch (InterruptedException e) {
		 }
		 while (!killed && numInFlight > 0) {
			 CopyResult cr = getCopyResult();
			 if (cr != null) {
				 if (cr.getSuccess()) {
					 numCopied++;
					 bytesTransferred += cr.getSize();
					 long secsSinceStart = (System.currentTimeMillis()-startTime)/1000+1;
					 float mbs = ((float)bytesTransferred)/(1024*1024);
					 float transferRate = mbs/secsSinceStart;
					 copyPhase.startNextPhase();
					 copyPhase.setStatus(""copy ("" + numCopied + "" of "" + numOutputs + "" at "" + mbpsFormat.format(transferRate) + "" MB/s)"");
					 getTask().reportProgress(getTracker());
				 }
				 else {
					 neededOutputs.add(new Integer(cr.getMapId()));
					 currentTime = System.currentTimeMillis();
					 long nextContact = currentTime + 60 * 1000 + backoff.nextInt(maxBackoff*1000);
					 penaltyBox.put(cr.getHost(), new Long(nextContact));
					 LOG.warn(reduceTask.getTaskId() + "" adding host "" + cr.getHost() + "" to penalty box, next contact in "" + ((nextContact-currentTime)/1000) + "" seconds"");
				 }
				 uniqueHosts.remove(cr.getHost());
				 numInFlight--;
			 }
			 if (numInFlight < lowThreshold && (numOutputs-numCopied) > PROBE_SAMPLE_SIZE) {
				 break;
			 }
		 }
	 }
	 leaseChecker.interrupt();
	 synchronized (copiers) {
		 synchronized (scheduledCopies) {
			 for (int i=0;
			 i < copiers.length;
			 i++) {
				 copiers[i].interrupt();
				 copiers[i] = null;
			 }
		 }
	 }
	 return numCopied == numOutputs && !killed;
 }",0,0,1,0
"public class TroffAnalyzer extends TextAnalyzer {
	 protected TroffAnalyzer(AnalyzerFactory factory) {
		 super(factory, new JFlexTokenizer(new TroffFullTokenizer( AbstractAnalyzer.DUMMY_READER)));
	 }
	 protected int getSpecializedVersionNo() {
		 return 20180112_00;
	 }
	 public void analyze(Document doc, StreamSource src, Writer xrefOut) throws IOException {
		 this.symbolTokenizer.setReader(getReader(src.getStream()));
		 OGKTextField full = new OGKTextField(QueryBuilder.FULL, symbolTokenizer);
		 doc.add(full);
		 if (xrefOut != null) {
			 try (Reader in = getReader(src.getStream())) {
				 WriteXrefArgs args = new WriteXrefArgs(in, xrefOut);
				 args.setProject(project);
				 Xrefer xref = writeXref(args);
				 addNumLines(doc, xref.getLineNumber());
				 addLOC(doc, xref.getLOC());
			 }
		 }
	 }
	 protected Xrefer newXref(Reader reader) {
		 return new TroffXref(reader);
	 }
}",0,0,0,0
"class JavaMembers{
	 JavaMembers(Scriptable scope, Class cl) {
		 this.members = new Hashtable(23);
		 this.staticMembers = new Hashtable(7);
		 this.cl = cl;
		 reflect(scope);
	 }
	 boolean has(String name, boolean isStatic) {
		 Hashtable ht = isStatic ? staticMembers : members;
		 Object obj = ht.get(name);
		 if (obj != null) {
			 return true;
		 }
		 else {
			 return null != findExplicitFunction(name, isStatic);
		 }
	 }
	 Object get(Scriptable scope, String name, Object javaObject, boolean isStatic) {
		 Hashtable ht = isStatic ? staticMembers : members;
		 Object member = ht.get(name);
		 if (!isStatic && member == null) {
			 member = staticMembers.get(name);
		 }
		 if (member == null) {
			 member = this.getExplicitFunction(scope, name, javaObject, isStatic);
			 if (member == null) return Scriptable.NOT_FOUND;
		 }
		 if (member instanceof Scriptable) {
			 return member;
		 }
		 Context cx = Context.getContext();
		 Object rval;
		 Class type;
		 try {
			 if (member instanceof BeanProperty) {
				 BeanProperty bp = (BeanProperty) member;
				 rval = bp.getter.invoke(javaObject, Context.emptyArgs);
				 type = bp.getter.method().getReturnType();
			 }
			 else {
				 Field field = (Field) member;
				 rval = field.get(isStatic ? null : javaObject);
				 type = field.getType();
			 }
		 }
		 catch (Exception ex) {
			 throw Context.throwAsScriptRuntimeEx(ex);
		 }
		 scope = ScriptableObject.getTopLevelScope(scope);
		 return cx.getWrapFactory().wrap(cx, scope, rval, type);
	 }
	 void put(Scriptable scope, String name, Object javaObject, Object value, boolean isStatic) {
		 Hashtable ht = isStatic ? staticMembers : members;
		 Object member = ht.get(name);
		 if (!isStatic && member == null) {
			 member = staticMembers.get(name);
		 }
		 if (member == null) throw reportMemberNotFound(name);
		 if (member instanceof FieldAndMethods) {
			 FieldAndMethods fam = (FieldAndMethods) ht.get(name);
			 member = fam.field;
		 }
		 if (member instanceof BeanProperty) {
			 BeanProperty bp = (BeanProperty)member;
			 if (bp.setter == null) {
				 throw reportMemberNotFound(name);
			 }
			 if (bp.setters == null || value == null) {
				 Class setType = bp.setter.argTypes[0];
				 Object[] args = {
				 Context.jsToJava(value, setType) }
				;
				 try {
					 bp.setter.invoke(javaObject, args);
				 }
				 catch (Exception ex) {
					 throw Context.throwAsScriptRuntimeEx(ex);
				 }
			 }
			 else {
				 Object[] args = {
				 value }
				;
				 bp.setters.call(Context.getContext(), ScriptableObject.getTopLevelScope(scope), scope, args);
			 }
		 }
		 else {
			 if (!(member instanceof Field)) {
				 String str = (member == null) ? ""msg.java.internal.private"" : ""msg.java.method.assign"";
				 throw Context.reportRuntimeError1(str, name);
			 }
			 Field field = (Field)member;
			 Object javaValue = Context.jsToJava(value, field.getType());
			 try {
				 field.set(javaObject, javaValue);
			 }
			 catch (IllegalAccessException accessEx) {
				 throw new RuntimeException(""unexpected IllegalAccessException ""+ ""accessing Java field"");
			 }
			 catch (IllegalArgumentException argEx) {
				 throw Context.reportRuntimeError3( ""msg.java.internal.field.type"", value.getClass().getName(), field, javaObject.getClass().getName());
			 }
		 }
	 }
	 Object[] getIds(boolean isStatic) {
		 Hashtable ht = isStatic ? staticMembers : members;
		 int len = ht.size();
		 Object[] result = new Object[len];
		 Enumeration keys = ht.keys();
		 for (int i=0;
		 i < len;
		 i++) result[i] = keys.nextElement();
		 return result;
	 }
	 static String javaSignature(Class type) {
		 if (!type.isArray()) {
			 return type.getName();
		 }
		 else {
			 int arrayDimension = 0;
			 do {
				 ++arrayDimension;
				 type = type.getComponentType();
			 }
			 while (type.isArray());
			 String name = type.getName();
			 String suffix = ""[]"";
			 if (arrayDimension == 1) {
				 return name.concat(suffix);
			 }
			 else {
				 int length = name.length() + arrayDimension * suffix.length();
				 StringBuffer sb = new StringBuffer(length);
				 sb.append(name);
				 while (arrayDimension != 0) {
					 --arrayDimension;
					 sb.append(suffix);
				 }
				 return sb.toString();
			 }
		 }
	 }
	 static String liveConnectSignature(Class[] argTypes) {
		 int N = argTypes.length;
		 if (N == 0) {
			 return ""()"";
		 }
		 StringBuffer sb = new StringBuffer();
		 sb.append('(');
		 for (int i = 0;
		 i != N;
		 ++i) {
			 if (i != 0) {
				 sb.append(',');
			 }
			 sb.append(javaSignature(argTypes[i]));
		 }
		 sb.append(')');
		 return sb.toString();
	 }
	 private MemberBox findExplicitFunction(String name, boolean isStatic) {
		 int sigStart = name.indexOf('(');
		 if (sigStart < 0) {
			 return null;
		 }
		 Hashtable ht = isStatic ? staticMembers : members;
		 MemberBox[] methodsOrCtors = null;
		 boolean isCtor = (isStatic && sigStart == 0);
		 if (isCtor) {
			 methodsOrCtors = ctors;
		 }
		 else {
			 String trueName = name.substring(0,sigStart);
			 Object obj = ht.get(trueName);
			 if (!isStatic && obj == null) {
				 obj = staticMembers.get(trueName);
			 }
			 if (obj instanceof NativeJavaMethod) {
				 NativeJavaMethod njm = (NativeJavaMethod)obj;
				 methodsOrCtors = njm.methods;
			 }
		 }
		 if (methodsOrCtors != null) {
			 for (int i = 0;
			 i < methodsOrCtors.length;
			 i++) {
				 Class[] type = methodsOrCtors[i].argTypes;
				 String sig = liveConnectSignature(type);
				 if (sigStart + sig.length() == name.length() && name.regionMatches(sigStart, sig, 0, sig.length())) {
					 return methodsOrCtors[i];
				 }
			 }
		 }
		 return null;
	 }
	 private Object getExplicitFunction(Scriptable scope, String name, Object javaObject, boolean isStatic) {
		 Hashtable ht = isStatic ? staticMembers : members;
		 Object member = null;
		 MemberBox methodOrCtor = findExplicitFunction(name, isStatic);
		 if (methodOrCtor != null) {
			 Scriptable prototype = ScriptableObject.getFunctionPrototype(scope);
			 if (methodOrCtor.isCtor()) {
				 NativeJavaConstructor fun = new NativeJavaConstructor(methodOrCtor);
				 fun.setPrototype(prototype);
				 member = fun;
				 ht.put(name, fun);
			 }
			 else {
				 String trueName = methodOrCtor.getName();
				 member = ht.get(trueName);
				 if (member instanceof NativeJavaMethod && ((NativeJavaMethod)member).methods.length > 1 ) {
					 NativeJavaMethod fun = new NativeJavaMethod(methodOrCtor, name);
					 fun.setPrototype(prototype);
					 ht.put(name, fun);
					 member = fun;
				 }
			 }
		 }
		 return member;
	 }
	 private void reflect(Scriptable scope) {
		 Method[] methods = cl.getMethods();
		 for (int i = 0;
		 i < methods.length;
		 i++) {
			 Method method = methods[i];
			 int mods = method.getModifiers();
			 if (!Modifier.isPublic(mods)) {
				 continue;
			 }
			 boolean isStatic = Modifier.isStatic(mods);
			 Hashtable ht = isStatic ? staticMembers : members;
			 String name = method.getName();
			 Object value = ht.get(name);
			 if (value == null) {
				 ht.put(name, method);
			 }
			 else {
				 ObjArray overloadedMethods;
				 if (value instanceof ObjArray) {
					 overloadedMethods = (ObjArray)value;
				 }
				 else {
					 if (!(value instanceof Method)) Kit.codeBug();
					 overloadedMethods = new ObjArray();
					 overloadedMethods.add(value);
					 ht.put(name, overloadedMethods);
				 }
				 overloadedMethods.add(method);
			 }
		 }
		 for (int tableCursor = 0;
		 tableCursor != 2;
		 ++tableCursor) {
			 boolean isStatic = (tableCursor == 0);
			 Hashtable ht = (isStatic) ? staticMembers : members;
			 Enumeration e = ht.keys();
			 while (e.hasMoreElements()) {
				 String name = (String)e.nextElement();
				 MemberBox[] methodBoxes;
				 Object value = ht.get(name);
				 if (value instanceof Method) {
					 methodBoxes = new MemberBox[1];
					 methodBoxes[0] = new MemberBox((Method)value);
				 }
				 else {
					 ObjArray overloadedMethods = (ObjArray)value;
					 int N = overloadedMethods.size();
					 if (N < 2) Kit.codeBug();
					 methodBoxes = new MemberBox[N];
					 for (int i = 0;
					 i != N;
					 ++i) {
						 Method method = (Method)overloadedMethods.get(i);
						 methodBoxes[i] = new MemberBox(method);
					 }
				 }
				 NativeJavaMethod fun = new NativeJavaMethod(methodBoxes);
				 if (scope != null) {
					 ScriptRuntime.setFunctionProtoAndParent(fun, scope);
				 }
				 ht.put(name, fun);
			 }
		 }
		 Field[] fields = cl.getFields();
		 for (int i = 0;
		 i < fields.length;
		 i++) {
			 Field field = fields[i];
			 int mods = field.getModifiers();
			 if (!Modifier.isPublic(mods)) {
				 continue;
			 }
			 boolean isStatic = Modifier.isStatic(mods);
			 Hashtable ht = isStatic ? staticMembers : members;
			 String name = field.getName();
			 Object member = ht.get(name);
			 if (member == null) {
				 ht.put(name, field);
			 }
			 else if (member instanceof NativeJavaMethod) {
				 NativeJavaMethod method = (NativeJavaMethod) member;
				 FieldAndMethods fam = new FieldAndMethods(scope, method.methods, field);
				 Hashtable fmht = isStatic ? staticFieldAndMethods : fieldAndMethods;
				 if (fmht == null) {
					 fmht = new Hashtable(4);
					 if (isStatic) {
						 staticFieldAndMethods = fmht;
					 }
					 else {
						 fieldAndMethods = fmht;
					 }
				 }
				 fmht.put(name, fam);
				 ht.put(name, fam);
			 }
			 else if (member instanceof Field) {
				 Field oldField = (Field) member;
				 if (oldField.getDeclaringClass(). isAssignableFrom(field.getDeclaringClass())) {
					 ht.put(name, field);
				 }
			 }
			 else {
				 Kit.codeBug();
			 }
		 }
		 for (int tableCursor = 0;
		 tableCursor != 2;
		 ++tableCursor) {
			 boolean isStatic = (tableCursor == 0);
			 Hashtable ht = (isStatic) ? staticMembers : members;
			 Hashtable toAdd = new Hashtable();
			 for (Enumeration e = ht.keys();
			 e.hasMoreElements();
			 ) {
				 String name = (String) e.nextElement();
				 boolean memberIsGetMethod = name.startsWith(""get"");
				 boolean memberIsIsMethod = name.startsWith(""is"");
				 if (memberIsGetMethod || memberIsIsMethod) {
					 String nameComponent = name.substring(memberIsGetMethod ? 3 : 2);
					 if (nameComponent.length() == 0) continue;
					 String beanPropertyName = nameComponent;
					 char ch0 = nameComponent.charAt(0);
					 if (Character.isUpperCase(ch0)) {
						 if (nameComponent.length() == 1) {
							 beanPropertyName = nameComponent.toLowerCase();
						 }
						 else {
							 char ch1 = nameComponent.charAt(1);
							 if (!Character.isUpperCase(ch1)) {
								 beanPropertyName = Character.toLowerCase(ch0) +nameComponent.substring(1);
							 }
						 }
					 }
					 if (ht.containsKey(beanPropertyName)) continue;
					 Object member = ht.get(name);
					 if (!(member instanceof NativeJavaMethod)) continue;
					 NativeJavaMethod njmGet = (NativeJavaMethod)member;
					 MemberBox getter = extractGetMethod(njmGet.methods, isStatic);
					 if (getter != null) {
						 NativeJavaMethod njmSet = null;
						 MemberBox setter = null;
						 NativeJavaMethod setters = null;
						 String setterName = ""set"".concat(nameComponent);
						 if (ht.containsKey(setterName)) {
							 member = ht.get(setterName);
							 if (member instanceof NativeJavaMethod) {
								 njmSet = (NativeJavaMethod)member;
								 Class type = getter.method().getReturnType();
								 setter = extractSetMethod(type, njmSet.methods, isStatic);
								 if (njmSet.methods.length > 1) {
									 setters = njmSet;
								 }
							 }
						 }
						 BeanProperty bp = new BeanProperty(getter, setter, setters);
						 toAdd.put(beanPropertyName, bp);
					 }
				 }
			 }
			 for (Enumeration e = toAdd.keys();
			 e.hasMoreElements();
			) {
				 Object key = e.nextElement();
				 Object value = toAdd.get(key);
				 ht.put(key, value);
			 }
		 }
		 Constructor[] constructors = cl.getConstructors();
		 ctors = new MemberBox[constructors.length];
		 for (int i = 0;
		 i != constructors.length;
		 ++i) {
			 ctors[i] = new MemberBox(constructors[i]);
		 }
	 }
	 private static MemberBox extractGetMethod(MemberBox[] methods, boolean isStatic) {
		 for (int methodIdx = 0;
		 methodIdx < methods.length;
		 methodIdx++) {
			 MemberBox method = methods[methodIdx];
			 if (method.argTypes.length == 0 && (!isStatic || method.isStatic())) {
				 Class type = method.method().getReturnType();
				 if (type != Void.TYPE) {
					 return method;
				 }
				 break;
			 }
		 }
		 return null;
	 }
	 private static MemberBox extractSetMethod(Class type, MemberBox[] methods, boolean isStatic) {
		 for (int pass = 1;
		 pass <= 2;
		 ++pass) {
			 for (int i = 0;
			 i < methods.length;
			 ++i) {
				 MemberBox method = methods[i];
				 if (!isStatic || method.isStatic()) {
					 if (method.method().getReturnType() == Void.TYPE) {
						 Class[] params = method.argTypes;
						 if (params.length == 1) {
							 if (pass == 1) {
								 if (params[0] == type) {
									 return method;
								 }
							 }
							 else {
								 if (pass != 2) Kit.codeBug();
								 if (params[0].isAssignableFrom(type)) {
									 return method;
								 }
							 }
						 }
					 }
				 }
			 }
		 }
		 return null;
	 }
	 Hashtable getFieldAndMethodsObjects(Scriptable scope, Object javaObject, boolean isStatic) {
		 Hashtable ht = isStatic ? staticFieldAndMethods : fieldAndMethods;
		 if (ht == null) return null;
		 int len = ht.size();
		 Hashtable result = new Hashtable(len);
		 Enumeration e = ht.elements();
		 while (len-- > 0) {
			 FieldAndMethods fam = (FieldAndMethods) e.nextElement();
			 FieldAndMethods famNew = new FieldAndMethods(scope, fam.methods, fam.field);
			 famNew.javaObject = javaObject;
			 result.put(fam.field.getName(), famNew);
		 }
		 return result;
	 }
	 static JavaMembers lookupClass(Scriptable scope, Class dynamicType, Class staticType) {
		 JavaMembers members;
		 ClassCache cache = ClassCache.get(scope);
		 Hashtable ct = cache.classTable;
		 Class cl = dynamicType;
		 for (;
		;
		) {
			 members = (JavaMembers)ct.get(cl);
			 if (members != null) {
				 return members;
			 }
			 try {
				 members = new JavaMembers(cache.scope, cl);
				 break;
			 }
			 catch (SecurityException e) {
				 if (staticType != null && staticType.isInterface()) {
					 cl = staticType;
					 staticType = null;
				 }
				 else {
					 Class parent = cl.getSuperclass();
					 if (parent == null) {
						 if (cl.isInterface()) {
							 parent = ScriptRuntime.ObjectClass;
						 }
						 else {
							 throw e;
						 }
					 }
					 cl = parent;
				 }
			 }
		 }
		 if (cache.isCachingEnabled()) ct.put(cl, members);
		 return members;
	 }
	 RuntimeException reportMemberNotFound(String memberName) {
		 return Context.reportRuntimeError2( ""msg.java.member.not.found"", cl.getName(), memberName);
	 }
	 private Class cl;
	 private Hashtable members;
	 private Hashtable fieldAndMethods;
	 private Hashtable staticMembers;
	 private Hashtable staticFieldAndMethods;
	 MemberBox[] ctors;
}
class BeanProperty{
	 BeanProperty(MemberBox getter, MemberBox setter, NativeJavaMethod setters) {
		 this.getter = getter;
		 this.setter = setter;
		 this.setters = setters;
	 }
	 MemberBox getter;
	 MemberBox setter;
	 NativeJavaMethod setters;
}
class FieldAndMethods extends NativeJavaMethod{
	 static final long serialVersionUID = -9222428244284796755L;
	 FieldAndMethods(Scriptable scope, MemberBox[] methods, Field field) {
		 super(methods);
		 this.field = field;
		 setParentScope(scope);
		 setPrototype(ScriptableObject.getFunctionPrototype(scope));
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == ScriptRuntime.FunctionClass) return this;
		 Object rval;
		 Class type;
		 try {
			 rval = field.get(javaObject);
			 type = field.getType();
		 }
		 catch (IllegalAccessException accEx) {
			 throw Context.reportRuntimeError1( ""msg.java.internal.private"", field.getName());
		 }
		 Context cx = Context.getContext();
		 rval = cx.getWrapFactory().wrap(cx, this, rval, type);
		 if (rval instanceof Scriptable) {
			 rval = ((Scriptable) rval).getDefaultValue(hint);
		 }
		 return rval;
	 }
	 Field field;
	 Object javaObject;
}",0,0,0,0
"protected Component newNodeComponent(String id, IModel<Object> model){
	return new LinkIconPanel(id, model, LinkTree.this){
		private static final long serialVersionUID = 1L;
		protected void onNodeLinkClicked(Object node, BaseTree tree, AjaxRequestTarget target){
			super.onNodeLinkClicked(node, tree, target);
			LinkTree.this.onNodeLinkClicked(node, tree, target);
		}
		protected Component newContentComponent(String componentId, BaseTree tree,IModel<Object> model){
			return new Label(componentId, getNodeTextModel(model));
		}
	}
	;
}",0,0,0,0
"public class Draw extends TransformOperation {
	 protected int xloc = 0;
	 protected int yloc = 0;
	 public void setXloc(int x) {
		 xloc = x;
	 }
	 public void setYloc(int y) {
		 yloc = y;
	 }
	 public void addRectangle(Rectangle rect) {
		 instructions.add(rect);
	 }
	 public void addText(Text text) {
		 instructions.add(text);
	 }
	 public void addEllipse(Ellipse elip) {
		 instructions.add(elip);
	 }
	 public void addArc(Arc arc) {
		 instructions.add(arc);
	 }
	 public PlanarImage executeTransformOperation(PlanarImage image) {
		 BufferedImage bi = image.getAsBufferedImage();
		 Graphics2D graphics = (Graphics2D) bi.getGraphics();
		 final int size = instructions.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 ImageOperation instr = ((ImageOperation) instructions.elementAt(i));
			 if (instr instanceof DrawOperation) {
				 PlanarImage op = ((DrawOperation) instr).executeDrawOperation();
				 log(""\tDrawing to x="" + xloc + "" y="" + yloc);
				 graphics.drawImage(op.getAsBufferedImage(), null, xloc, yloc);
			 }
			 else if (instr instanceof TransformOperation) {
				 PlanarImage op = ((TransformOperation) instr).executeTransformOperation(null);
				 BufferedImage child = op.getAsBufferedImage();
				 log(""\tDrawing to x="" + xloc + "" y="" + yloc);
				 graphics.drawImage(child, null, xloc, yloc);
				 PlanarImage.wrapRenderedImage(bi);
			 }
		 }
		 image = PlanarImage.wrapRenderedImage(bi);
		 return image;
	 }
}",0,0,0,0
"public class ObjectRetrievalFailureException extends DataRetrievalFailureException {
	private final Object persistentClass;
	private final Object identifier;
	public ObjectRetrievalFailureException(String msg, Throwable cause) {
		super(msg, cause);
		this.persistentClass = null;
		this.identifier = null;
	}
	public ObjectRetrievalFailureException(Class<?> persistentClass, Object identifier) {
		this(persistentClass, identifier,""Object of class ["" + persistentClass.getName() + ""] with identifier ["" + identifier + ""]: not found"",null);
	}
	public ObjectRetrievalFailureException(Class<?> persistentClass, Object identifier, String msg, Throwable cause) {
		super(msg, cause);
		this.persistentClass = persistentClass;
		this.identifier = identifier;
	}
	public ObjectRetrievalFailureException(String persistentClassName, Object identifier) {
		this(persistentClassName, identifier,""Object of class ["" + persistentClassName + ""] with identifier ["" + identifier + ""]: not found"",null);
	}
	public ObjectRetrievalFailureException(String persistentClassName, Object identifier, String msg, Throwable cause) {
		super(msg, cause);
		this.persistentClass = persistentClassName;
		this.identifier = identifier;
	}
	public Class<?> getPersistentClass() {
		return (this.persistentClass instanceof Class ? (Class<?>) this.persistentClass : null);
	}
	public String getPersistentClassName() {
		if (this.persistentClass instanceof Class) {
			return ((Class<?>) this.persistentClass).getName();
		}
		return (this.persistentClass != null ? this.persistentClass.toString() : null);
	}
	public Object getIdentifier() {
		return this.identifier;
	}
}",0,1,0,0
"int loadFSEdits( FSDirectory fsDir, Configuration conf ) throws IOException {
	 int numEdits = 0;
	 int logVersion = 0;
	 if (editsFile.exists()) {
		 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(editsFile)));
		 in.mark( 4 );
		 if( in.available() > 0 ) {
			 logVersion = in.readByte();
			 in.reset();
			 if( logVersion >= 0 ) logVersion = 0;
			 else logVersion = in.readInt();
			 if( logVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IOException( ""Unexpected version of the file system log file: "" + logVersion + "". Current version = "" + FSConstants.DFS_CURRENT_VERSION + ""."" );
		 }
		 short replication = (short)conf.getInt(""dfs.replication"", 3);
		 try {
			 while (in.available() > 0) {
				 byte opcode = in.readByte();
				 numEdits++;
				 switch (opcode) {
					 case OP_ADD: {
						 UTF8 name = new UTF8();
						 ArrayWritable aw = null;
						 Writable writables[];
						 if( logVersion >= 0 ) name.readFields(in);
						 else {
							 aw = new ArrayWritable(UTF8.class);
							 aw.readFields(in);
							 writables = aw.get();
							 if( writables.length != 2 ) throw new IOException(""Incorrect data fortmat. "" + ""Name & replication pair expected"");
							 name = (UTF8) writables[0];
							 replication = Short.parseShort( ((UTF8)writables[1]).toString());
							 replication = adjustReplication( replication, conf );
						 }
						 aw = new ArrayWritable(Block.class);
						 aw.readFields(in);
						 writables = aw.get();
						 Block blocks[] = new Block[writables.length];
						 System.arraycopy(writables, 0, blocks, 0, blocks.length);
						 fsDir.unprotectedAddFile(name, blocks, replication );
						 break;
					 }
					 case OP_SET_REPLICATION: {
						 UTF8 src = new UTF8();
						 UTF8 repl = new UTF8();
						 src.readFields(in);
						 repl.readFields(in);
						 replication = adjustReplication( fromLogReplication(repl), conf);
						 fsDir.unprotectedSetReplication(src.toString(), replication, null);
						 break;
					 }
					 case OP_RENAME: {
						 UTF8 src = new UTF8();
						 UTF8 dst = new UTF8();
						 src.readFields(in);
						 dst.readFields(in);
						 fsDir.unprotectedRenameTo(src, dst);
						 break;
					 }
					 case OP_DELETE: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedDelete(src);
						 break;
					 }
					 case OP_MKDIR: {
						 UTF8 src = new UTF8();
						 src.readFields(in);
						 fsDir.unprotectedMkdir(src.toString());
						 break;
					 }
					 default: {
						 throw new IOException(""Never seen opcode "" + opcode);
					 }
				 }
			 }
		 }
		 finally {
			 in.close();
		 }
	 }
	 if( logVersion != FSConstants.DFS_CURRENT_VERSION ) numEdits++;
	 return numEdits;
 }",0,0,1,0
"public static void main(String[] args) throws IOException, InterruptedException, ConfigurationException, ParseException {
	 CommandLineParser parser = new PosixParser();
	 ToolCommandLine cmd = null;
	 try {
		 cmd = new ToolCommandLine(parser.parse(options, args));
	 }
	 catch (ParseException p) {
		 badUse(p.getMessage());
	 }
	 String host = cmd.getOptionValue(HOST_OPT.left);
	 int port = DEFAULT_PORT;
	 String portNum = cmd.getOptionValue(PORT_OPT.left);
	 if (portNum != null) {
		 try {
			 port = Integer.parseInt(portNum);
		 }
		 catch (NumberFormatException e) {
			 throw new ParseException(""Port must be a number"");
		 }
	 }
	 String username = cmd.getOptionValue(USERNAME_OPT.left);
	 String password = cmd.getOptionValue(PASSWORD_OPT.left);
	 NodeProbe probe = null;
	 try {
		 probe = username == null ? new NodeProbe(host, port) : new NodeProbe(host, port, username, password);
	 }
	 catch (IOException ioe) {
		 err(ioe, ""Error connection to remote JMX agent!"");
	 }
	 NodeCommand command = null;
	 try {
		 command = cmd.getCommand();
	 }
	 catch (IllegalArgumentException e) {
		 badUse(e.getMessage());
	 }
	 NodeCmd nodeCmd = new NodeCmd(probe);
	 String[] arguments = cmd.getCommandArguments();
	 switch (command) {
		 case RING : nodeCmd.printRing(System.out);
		 break;
		 case INFO : nodeCmd.printInfo(System.out);
		 break;
		 case CFSTATS : nodeCmd.printColumnFamilyStats(System.out);
		 break;
		 case DECOMMISSION : probe.decommission();
		 break;
		 case TPSTATS : nodeCmd.printThreadPoolStats(System.out);
		 break;
		 case VERSION : nodeCmd.printReleaseVersion(System.out);
		 break;
		 case COMPACTIONSTATS : nodeCmd.printCompactionStats(System.out);
		 break;
		 case DISABLEGOSSIP : probe.stopGossiping();
		 break;
		 case ENABLEGOSSIP : probe.startGossiping();
		 break;
		 case DISABLETHRIFT : probe.stopThriftServer();
		 break;
		 case ENABLETHRIFT : probe.startThriftServer();
		 break;
		 case STATUSTHRIFT : nodeCmd.printIsThriftServerRunning(System.out);
		 break;
		 case DRAIN : try {
			 probe.drain();
		 }
		 catch (ExecutionException ee) {
			 err(ee, ""Error occured during flushing"");
		 }
		 break;
		 case NETSTATS : if (arguments.length > 0) {
			 nodeCmd.printNetworkStats(InetAddress.getByName(arguments[0]), System.out);
		 }
		 else {
			 nodeCmd.printNetworkStats(null, System.out);
		 }
		 break;
		 case SNAPSHOT : case CLEARSNAPSHOT : String tag = cmd.getOptionValue(TAG_OPT.left);
		 handleSnapshots(command, tag, arguments, probe);
		 break;
		 case MOVE : if (arguments.length != 1) {
			 badUse(""Missing token argument for move."");
		 }
		 probe.move(arguments[0]);
		 break;
		 case JOIN: if (probe.isJoined()) {
			 System.err.println(""This node has already joined the ring."");
			 System.exit(1);
		 }
		 probe.joinRing();
		 break;
		 case SETCOMPACTIONTHROUGHPUT : if (arguments.length != 1) {
			 badUse(""Missing value argument."");
		 }
		 probe.setCompactionThroughput(Integer.valueOf(arguments[0]));
		 break;
		 case REMOVETOKEN : if (arguments.length != 1) {
			 badUse(""Missing an argument for removetoken (either status, force, or a token)"");
		 }
		 else if (arguments[0].equals(""status"")) {
			 nodeCmd.printRemovalStatus(System.out);
		 }
		 else if (arguments[0].equals(""force"")) {
			 nodeCmd.printRemovalStatus(System.out);
			 probe.forceRemoveCompletion();
		 }
		 else {
			 probe.removeToken(arguments[0]);
		 }
		 break;
		 case CLEANUP : case COMPACT : case REPAIR : case FLUSH : case SCRUB : case INVALIDATEKEYCACHE : case INVALIDATEROWCACHE : optionalKSandCFs(command, arguments, probe);
		 break;
		 case GETCOMPACTIONTHRESHOLD : if (arguments.length != 2) {
			 badUse(""getcompactionthreshold requires ks and cf args."");
		 }
		 probe.getCompactionThreshold(System.out, arguments[0], arguments[1]);
		 break;
		 case CFHISTOGRAMS : if (arguments.length != 2) {
			 badUse(""cfhistograms requires ks and cf args"");
		 }
		 nodeCmd.printCfHistograms(arguments[0], arguments[1], System.out);
		 break;
		 case SETCACHECAPACITY : if (arguments.length != 4) {
			 badUse(""setcachecapacity requires ks, cf, keycachecap, and rowcachecap args."");
		 }
		 probe.setCacheCapacities(arguments[0], arguments[1], Integer.parseInt(arguments[2]), Integer.parseInt(arguments[3]));
		 break;
		 case SETCOMPACTIONTHRESHOLD : if (arguments.length != 4) {
			 badUse(""setcompactionthreshold requires ks, cf, min, and max threshold args."");
		 }
		 int minthreshold = Integer.parseInt(arguments[2]);
		 int maxthreshold = Integer.parseInt(arguments[3]);
		 if ((minthreshold < 0) || (maxthreshold < 0)) {
			 badUse(""Thresholds must be positive integers"");
		 }
		 if (minthreshold > maxthreshold) {
			 badUse(""Min threshold cannot be greater than max."");
		 }
		 if (minthreshold < 2 && maxthreshold != 0) {
			 badUse(""Min threshold must be at least 2"");
		 }
		 probe.setCompactionThreshold(arguments[0], arguments[1], minthreshold, maxthreshold);
		 break;
		 case GETENDPOINTS : if (arguments.length != 3) {
			 badUse(""getendpoints requires ks, cf and key args"");
		 }
		 nodeCmd.printEndPoints(arguments[0], arguments[1], arguments[2], System.out);
		 break;
		 default : throw new RuntimeException(""Unreachable code."");
	 }
	 System.exit(0);
 }",0,0,1,0
"public class AnElementElements extends AbstractParserRuleElementFinder {
	private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.xtext.ui.tests.editor.contentassist.TwoContextsTestLanguage.AnElement"");
	private final Group cGroup = (Group)rule.eContents().get(1);
	private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
	private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
	private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
	private final Keyword cRefersToKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
	private final Assignment cReferredAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
	private final CrossReference cReferredAnElementCrossReference_1_1_0 = (CrossReference)cReferredAssignment_1_1.eContents().get(0);
	private final RuleCall cReferredAnElementIDTerminalRuleCall_1_1_0_1 = (RuleCall)cReferredAnElementCrossReference_1_1_0.eContents().get(1);
	private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
	 public ParserRule getRule() {
		 return rule;
	 }
	public Group getGroup() {
		 return cGroup;
	 }
	public Assignment getNameAssignment_0() {
		 return cNameAssignment_0;
	 }
	public RuleCall getNameIDTerminalRuleCall_0_0() {
		 return cNameIDTerminalRuleCall_0_0;
	 }
	public Group getGroup_1() {
		 return cGroup_1;
	 }
	public Keyword getRefersToKeyword_1_0() {
		 return cRefersToKeyword_1_0;
	 }
	public Assignment getReferredAssignment_1_1() {
		 return cReferredAssignment_1_1;
	 }
	public CrossReference getReferredAnElementCrossReference_1_1_0() {
		 return cReferredAnElementCrossReference_1_1_0;
	 }
	public RuleCall getReferredAnElementIDTerminalRuleCall_1_1_0_1() {
		 return cReferredAnElementIDTerminalRuleCall_1_1_0_1;
	 }
	public Keyword getSemicolonKeyword_2() {
		 return cSemicolonKeyword_2;
	 }
}",1,1,0,0
"public class CompleteGraphextends GeneratedGraph {
	private LongParameter vertexCount = new LongParameter(this, ""vertex_count"").setMinimumValue(MINIMUM_VERTEX_COUNT);
	public String getIdentity() {
		return getName() + "" ("" + vertexCount.getValue() + "")"";
	}
	protected long vertexCount() {
		return vertexCount.getValue();
	}
	public Graph<LongValue, NullValue, NullValue> create(ExecutionEnvironment env) throws Exception {
		return new org.apache.flink.graph.generator.CompleteGraph(env, vertexCount.getValue()).setParallelism(parallelism.getValue().intValue()).generate();
	}
}",0,0,0,0
"public ContextRelationship diff(ByteBuffer left, ByteBuffer right) {
	 ContextRelationship relationship = ContextRelationship.EQUAL;
	 ContextState leftState = new ContextState(left, headerLength(left));
	 ContextState rightState = new ContextState(right, headerLength(right));
	 while (leftState.hasRemaining() && rightState.hasRemaining()) {
		 int compareId = leftState.compareIdTo(rightState);
		 if (compareId == 0) {
			 long leftClock = leftState.getClock();
			 long rightClock = rightState.getClock();
			 long leftCount = leftState.getCount();
			 long rightCount = rightState.getCount();
			 leftState.moveToNext();
			 rightState.moveToNext();
			 if (leftClock == rightClock) {
				 if (leftCount != rightCount) {
					 return ContextRelationship.DISJOINT;
				 }
				 else {
					 continue;
				 }
			 }
			 else if ((leftClock >= 0 && rightClock > 0 && leftClock > rightClock) || (leftClock < 0 && (rightClock > 0 || leftClock < rightClock))) {
				 if (relationship == ContextRelationship.EQUAL) {
					 relationship = ContextRelationship.GREATER_THAN;
				 }
				 else if (relationship == ContextRelationship.GREATER_THAN) {
					 continue;
				 }
				 else {
					 return ContextRelationship.DISJOINT;
				 }
			 }
			 else {
				 if (relationship == ContextRelationship.EQUAL) {
					 relationship = ContextRelationship.LESS_THAN;
				 }
				 else if (relationship == ContextRelationship.GREATER_THAN) {
					 return ContextRelationship.DISJOINT;
				 }
				 else {
					 continue;
				 }
			 }
		 }
		 else if (compareId > 0) {
			 rightState.moveToNext();
			 if (relationship == ContextRelationship.EQUAL) {
				 relationship = ContextRelationship.LESS_THAN;
			 }
			 else if (relationship == ContextRelationship.GREATER_THAN) {
				 return ContextRelationship.DISJOINT;
			 }
			 else {
				 continue;
			 }
		 }
		 else {
			 leftState.moveToNext();
			 if (relationship == ContextRelationship.EQUAL) {
				 relationship = ContextRelationship.GREATER_THAN;
			 }
			 else if (relationship == ContextRelationship.GREATER_THAN) {
				 continue;
			 }
			 else {
				 return ContextRelationship.DISJOINT;
			 }
		 }
	 }
	 if (leftState.hasRemaining()) {
		 if (relationship == ContextRelationship.EQUAL) {
			 return ContextRelationship.GREATER_THAN;
		 }
		 else if (relationship == ContextRelationship.LESS_THAN) {
			 return ContextRelationship.DISJOINT;
		 }
	 }
	 else if (rightState.hasRemaining()) {
		 if (relationship == ContextRelationship.EQUAL) {
			 return ContextRelationship.LESS_THAN;
		 }
		 else if (relationship == ContextRelationship.GREATER_THAN) {
			 return ContextRelationship.DISJOINT;
		 }
	 }
	 return relationship;
 }",0,0,1,0
"public PageList findUsers(Query q) throws Exception {
	LdapContext ctx = null;
	List users = new ArrayList();
	String pageSizeString = (String)OrganizationServiceImpl.properties.get(""ldap.page.size"");
	String pageSleepString = (String)OrganizationServiceImpl.properties.get(""ldap.page.sleep"");
	int pageSize = 100;
	long pageSleep = 0;
	if (pageSizeString != null){
		pageSize = Integer.valueOf(pageSizeString).intValue();
	}
	if (pageSleepString != null){
		pageSleep = Long.valueOf(pageSleepString).longValue();
	}
	int itemCounter = pageSize;
	NamingEnumeration enumer;
	try {
		ctx = ldapService.getLdapContext();
		String filter = null;
		ArrayList list = new ArrayList();
		if (q.getUserName() != null && q.getUserName().length() > 0) {
			list.add(""("" + (String)OrganizationServiceImpl.properties.get(""ldap.user.username.attribute"") + ""="" + q.getUserName() + "")"");
		}
		if (q.getFirstName() != null && q.getFirstName().length() > 0) {
			list.add(""("" + (String)OrganizationServiceImpl.properties.get(""ldap.user.firstname.attribute"") + ""="" + q.getFirstName() + "")"");
		}
		if (q.getLastName() != null && q.getLastName().length() > 0) {
			list.add(""("" + (String)OrganizationServiceImpl.properties.get(""ldap.user.lastname.attribute"") + ""="" + q.getLastName() + "")"");
		}
		if (q.getEmail() != null && q.getEmail().length() > 0) {
			list.add(""("" + (String)OrganizationServiceImpl.properties.get(""ldap.user.mail.attribute"") + ""="" + q.getEmail() + "")"");
		}
		if (list.size() > 0){
			StringBuffer buffer = new StringBuffer();
			buffer.append(""(&"");
			if (list.size() > 1){
				for (int x = 0;
				 x < list.size();
				 x++){
					if (x == (list.size() - 1)){
						buffer.append(list.get(x));
					}
					 else {
						buffer.append(list.get(x)+"" || "");
					}
				}
			}
			 else {
				buffer.append(list.get(0));
			}
			buffer.append("" ("" +(String)OrganizationServiceImpl.properties.get(""ldap.user.objectclass.filter"") + "") )"");
			filter = buffer.toString();
		}
		 else {
			filter = (String)OrganizationServiceImpl.properties.get(""ldap.user.objectclass.filter"");
		}
		String searchBase = (String)OrganizationServiceImpl.properties.get(""ldap.base.url"");
		Control control[] = new Control[2];
		String keys[] = {
		 (String)OrganizationServiceImpl.properties.get(""ldap.user.username.attribute"") }
		;
		SortControl sortControl = new SortControl(keys, false);
		control[0] = sortControl;
		PagedResultsControl pagedResultsControl = new PagedResultsControl(pageSize);
		control[1] = pagedResultsControl;
		ctx.setRequestControls(control);
		while (itemCounter >= pageSize) {
			itemCounter = 0;
			SearchControls constraints = new SearchControls();
			constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);
			enumer = ctx.search(searchBase, filter, constraints);
			while (enumer.hasMore()) {
				itemCounter += 1;
				SearchResult result = (SearchResult) enumer.next();
				Attributes attrs = result.getAttributes();
				User user = new UserImpl();
				user.setUserName(this.getAttribute(attrs, (String)OrganizationServiceImpl.properties.get(""ldap.user.username.attribute"")));
				user.setFirstName(this.getAttribute(attrs, (String)OrganizationServiceImpl.properties.get(""ldap.user.firstname.attribute"")));
				user.setLastName(this.getAttribute(attrs, (String)OrganizationServiceImpl.properties.get(""ldap.user.lasttname.attribute"")));
				user.setEmail(this.getAttribute(attrs, (String)OrganizationServiceImpl.properties.get(""ldap.user.mail.attribute"")));
				user.setCreatedDate(new Date());
				user.setLastLoginTime(new Date());
				user.setPassword(""PASSWORD"");
				users.add(user);
			}
			if (itemCounter >= pageSize) {
				Control[] responseControls = ctx.getResponseControls();
				for (int i = 0;
				 i < responseControls.length;
				 i++) {
					if (responseControls[i] instanceof PagedResultsResponseControl) {
						pagedResultsControl = new PagedResultsControl(pageSize,((PagedResultsResponseControl) responseControls[i]).getCookie(), true);
						ctx.setRequestControls(new Control[] {
						 pagedResultsControl }
						);
					}
				}
			}
			if (pageSleep > 0){
				Thread.sleep(pageSleep);
			}
		}
	}
	 catch (PartialResultException e){
	}
	 finally {
		ctx.close();
	}
	return new ObjectPageList(users, 20);
}",0,0,1,0
"public class IsFileSelected extends AbstractSelectorContainer implements Condition {
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private File file;
	 private File baseDir;
	 public void setFile(File file) {
		 this.file = file;
	 }
	 public void setBaseDir(File baseDir) {
		 this.baseDir = baseDir;
	 }
	 public void validate() {
		 if (selectorCount() != 1) {
			 throw new BuildException(""Only one selector allowed"");
		 }
		 super.validate();
	 }
	 public boolean eval() {
		 if (file == null) {
			 throw new BuildException(""file attribute not set"");
		 }
		 validate();
		 File myBaseDir = baseDir;
		 if (myBaseDir == null) {
			 myBaseDir = getProject().getBaseDir();
		 }
		 FileSelector f = getSelectors(getProject())[0];
		 return f.isSelected( myBaseDir, FILE_UTILS.removeLeadingPath(myBaseDir, file), file);
	 }
}",0,0,0,0
"public interface FlowableRxInvoker extends RxInvoker<Flowable> {
	 Flowable<Response> get();
	 <T> Flowable<T> get(Class<T> responseType);
	 <T> Flowable<T> get(GenericType<T> responseType);
	 Flowable<Response> put(Entity<?> entity);
	 <T> Flowable<T> put(Entity<?> entity, Class<T> clazz);
	 <T> Flowable<T> put(Entity<?> entity, GenericType<T> type);
	 Flowable<Response> post(Entity<?> entity);
	 <T> Flowable<T> post(Entity<?> entity, Class<T> clazz);
	 <T> Flowable<T> post(Entity<?> entity, GenericType<T> type);
	 Flowable<Response> delete();
	 <T> Flowable<T> delete(Class<T> responseType);
	 <T> Flowable<T> delete(GenericType<T> responseType);
	 Flowable<Response> head();
	 Flowable<Response> options();
	 <T> Flowable<T> options(Class<T> responseType);
	 <T> Flowable<T> options(GenericType<T> responseType);
	 Flowable<Response> trace();
	 <T> Flowable<T> trace(Class<T> responseType);
	 <T> Flowable<T> trace(GenericType<T> responseType);
	 Flowable<Response> method(String name);
	 <T> Flowable<T> method(String name, Class<T> responseType);
	 <T> Flowable<T> method(String name, GenericType<T> responseType);
	 Flowable<Response> method(String name, Entity<?> entity);
	 <T> Flowable<T> method(String name, Entity<?> entity, Class<T> responseType);
	 <T> Flowable<T> method(String name, Entity<?> entity, GenericType<T> responseType);
}",1,1,0,0
"public class DepositAccountAssembler {
	 private final PlatformSecurityContext context;
	 private final SavingsAccountTransactionSummaryWrapper savingsAccountTransactionSummaryWrapper;
	 private final SavingsHelper savingsHelper;
	 private final ClientRepositoryWrapper clientRepository;
	 private final GroupRepositoryWrapper groupRepository;
	 private final StaffRepositoryWrapper staffRepository;
	 private final FixedDepositProductRepository fixedDepositProductRepository;
	 private final RecurringDepositProductRepository recurringDepositProductRepository;
	 private final SavingsAccountRepositoryWrapper savingsAccountRepository;
	 private final SavingsAccountChargeAssembler savingsAccountChargeAssembler;
	 private final FromJsonHelper fromApiJsonHelper;
	 private final DepositProductAssembler depositProductAssembler;
	 private final PaymentDetailAssembler paymentDetailAssembler;
	 public DepositAccountAssembler(final SavingsAccountTransactionSummaryWrapper savingsAccountTransactionSummaryWrapper, final ClientRepositoryWrapper clientRepository, final GroupRepositoryWrapper groupRepository, final StaffRepositoryWrapper staffRepository, final FixedDepositProductRepository fixedDepositProductRepository, final SavingsAccountRepositoryWrapper savingsAccountRepository, final SavingsAccountChargeAssembler savingsAccountChargeAssembler, final FromJsonHelper fromApiJsonHelper, final DepositProductAssembler depositProductAssembler, final RecurringDepositProductRepository recurringDepositProductRepository, final AccountTransfersReadPlatformService accountTransfersReadPlatformService, final PlatformSecurityContext context, final PaymentDetailAssembler paymentDetailAssembler) {
		 this.savingsAccountTransactionSummaryWrapper = savingsAccountTransactionSummaryWrapper;
		 this.clientRepository = clientRepository;
		 this.groupRepository = groupRepository;
		 this.staffRepository = staffRepository;
		 this.fixedDepositProductRepository = fixedDepositProductRepository;
		 this.savingsAccountRepository = savingsAccountRepository;
		 this.savingsAccountChargeAssembler = savingsAccountChargeAssembler;
		 this.fromApiJsonHelper = fromApiJsonHelper;
		 this.depositProductAssembler = depositProductAssembler;
		 this.recurringDepositProductRepository = recurringDepositProductRepository;
		 this.savingsHelper = new SavingsHelper(accountTransfersReadPlatformService);
		 this.context = context;
		 this.paymentDetailAssembler = paymentDetailAssembler;
	 }
	 public SavingsAccount assembleFrom(final JsonCommand command, final AppUser submittedBy, final DepositAccountType depositAccountType) {
		 final JsonElement element = command.parsedJson();
		 final String accountNo = this.fromApiJsonHelper.extractStringNamed(accountNoParamName, element);
		 final String externalId = this.fromApiJsonHelper.extractStringNamed(externalIdParamName, element);
		 final Long productId = this.fromApiJsonHelper.extractLongNamed(productIdParamName, element);
		 SavingsProduct product = null;
		 if (depositAccountType.isFixedDeposit()) {
			 product = this.fixedDepositProductRepository.findOne(productId);
			 if (product == null) {
				 throw new FixedDepositProductNotFoundException(productId);
			 }
		 }
		 else if (depositAccountType.isRecurringDeposit()) {
			 product = this.recurringDepositProductRepository.findOne(productId);
			 if (product == null) {
				 throw new RecurringDepositProductNotFoundException(productId);
			 }
		 }
		 if (product == null) {
			 throw new SavingsProductNotFoundException(productId);
		 }
		 Client client = null;
		 Group group = null;
		 Staff fieldOfficer = null;
		 AccountType accountType = AccountType.INVALID;
		 final Long clientId = this.fromApiJsonHelper.extractLongNamed(clientIdParamName, element);
		 if (clientId != null) {
			 final boolean isCalendarInherited = command.booleanPrimitiveValueOfParameterNamed(isCalendarInheritedParamName);
			 client = this.clientRepository.findOneWithNotFoundDetection(clientId, isCalendarInherited);
			 accountType = AccountType.INDIVIDUAL;
			 if (client.isNotActive()) {
				 throw new ClientNotActiveException(clientId);
			 }
		 }
		 final Long groupId = this.fromApiJsonHelper.extractLongNamed(groupIdParamName, element);
		 if (groupId != null) {
			 group = this.groupRepository.findOneWithNotFoundDetection(groupId);
			 accountType = AccountType.GROUP;
		 }
		 if (group != null && client != null) {
			 if (!group.hasClientAsMember(client)) {
				 throw new ClientNotInGroupException(clientId, groupId);
			 }
			 accountType = AccountType.JLG;
			 if (group.isNotActive()) {
				 if (group.isCenter()) {
					 throw new CenterNotActiveException(groupId);
				 }
				 throw new GroupNotActiveException(groupId);
			 }
		 }
		 final Long fieldOfficerId = this.fromApiJsonHelper.extractLongNamed(fieldOfficerIdParamName, element);
		 if (fieldOfficerId != null) {
			 fieldOfficer = this.staffRepository.findOneWithNotFoundDetection(fieldOfficerId);
		 }
		 final LocalDate submittedOnDate = this.fromApiJsonHelper.extractLocalDateNamed(submittedOnDateParamName, element);
		 BigDecimal interestRate = null;
		 if (command.parameterExists(nominalAnnualInterestRateParamName)) {
			 interestRate = command.bigDecimalValueOfParameterNamed(nominalAnnualInterestRateParamName);
		 }
		 else {
			 interestRate = product.nominalAnnualInterestRate();
		 }
		 SavingsCompoundingInterestPeriodType interestCompoundingPeriodType = null;
		 final Integer interestPeriodTypeValue = command.integerValueOfParameterNamed(interestCompoundingPeriodTypeParamName);
		 if (interestPeriodTypeValue != null) {
			 interestCompoundingPeriodType = SavingsCompoundingInterestPeriodType.fromInt(interestPeriodTypeValue);
		 }
		 else {
			 interestCompoundingPeriodType = product.interestCompoundingPeriodType();
		 }
		 SavingsPostingInterestPeriodType interestPostingPeriodType = null;
		 final Integer interestPostingPeriodTypeValue = command.integerValueOfParameterNamed(interestPostingPeriodTypeParamName);
		 if (interestPostingPeriodTypeValue != null) {
			 interestPostingPeriodType = SavingsPostingInterestPeriodType.fromInt(interestPostingPeriodTypeValue);
		 }
		 else {
			 interestPostingPeriodType = product.interestPostingPeriodType();
		 }
		 SavingsInterestCalculationType interestCalculationType = null;
		 final Integer interestCalculationTypeValue = command.integerValueOfParameterNamed(interestCalculationTypeParamName);
		 if (interestCalculationTypeValue != null) {
			 interestCalculationType = SavingsInterestCalculationType.fromInt(interestCalculationTypeValue);
		 }
		 else {
			 interestCalculationType = product.interestCalculationType();
		 }
		 SavingsInterestCalculationDaysInYearType interestCalculationDaysInYearType = null;
		 final Integer interestCalculationDaysInYearTypeValue = command .integerValueOfParameterNamed(interestCalculationDaysInYearTypeParamName);
		 if (interestCalculationDaysInYearTypeValue != null) {
			 interestCalculationDaysInYearType = SavingsInterestCalculationDaysInYearType.fromInt(interestCalculationDaysInYearTypeValue);
		 }
		 else {
			 interestCalculationDaysInYearType = product.interestCalculationDaysInYearType();
		 }
		 BigDecimal minRequiredOpeningBalance = null;
		 if (command.parameterExists(minRequiredOpeningBalanceParamName)) {
			 minRequiredOpeningBalance = command.bigDecimalValueOfParameterNamed(minRequiredOpeningBalanceParamName);
		 }
		 else {
			 minRequiredOpeningBalance = product.minRequiredOpeningBalance();
		 }
		 Integer lockinPeriodFrequency = null;
		 if (command.parameterExists(lockinPeriodFrequencyParamName)) {
			 lockinPeriodFrequency = command.integerValueOfParameterNamed(lockinPeriodFrequencyParamName);
		 }
		 else {
			 lockinPeriodFrequency = product.lockinPeriodFrequency();
		 }
		 SavingsPeriodFrequencyType lockinPeriodFrequencyType = null;
		 if (command.parameterExists(lockinPeriodFrequencyTypeParamName)) {
			 Integer lockinPeriodFrequencyTypeValue = null;
			 lockinPeriodFrequencyTypeValue = command.integerValueOfParameterNamed(lockinPeriodFrequencyTypeParamName);
			 if (lockinPeriodFrequencyTypeValue != null) {
				 lockinPeriodFrequencyType = SavingsPeriodFrequencyType.fromInt(lockinPeriodFrequencyTypeValue);
			 }
		 }
		 else {
			 lockinPeriodFrequencyType = product.lockinPeriodFrequencyType();
		 }
		 boolean iswithdrawalFeeApplicableForTransfer = false;
		 if (command.parameterExists(withdrawalFeeForTransfersParamName)) {
			 iswithdrawalFeeApplicableForTransfer = command.booleanPrimitiveValueOfParameterNamed(withdrawalFeeForTransfersParamName);
		 }
		 final Set<SavingsAccountCharge> charges = this.savingsAccountChargeAssembler.fromParsedJson(element, product.currency().getCode());
		 DepositAccountInterestRateChart accountChart = null;
		 InterestRateChart productChart = null;
		 if (command.parameterExists(chartIdParamName)) {
			 Long chartId = command.longValueOfParameterNamed(chartIdParamName);
			 productChart = product.findChart(chartId);
		 }
		 else {
			 productChart = product.applicableChart(submittedOnDate);
		 }
		 if (productChart != null) {
			 accountChart = DepositAccountInterestRateChart.from(productChart);
		 }
		 boolean withHoldTax = product.withHoldTax();
		 if (command.parameterExists(withHoldTaxParamName)) {
			 withHoldTax = command.booleanPrimitiveValueOfParameterNamed(withHoldTaxParamName);
			 if(withHoldTax && product.getTaxGroup() == null){
				 throw new UnsupportedParameterException(Arrays.asList(withHoldTaxParamName));
			 }
		 }
		 SavingsAccount account = null;
		 if (depositAccountType.isFixedDeposit()) {
			 final DepositProductTermAndPreClosure prodTermAndPreClosure = ((FixedDepositProduct) product).depositProductTermAndPreClosure();
			 final DepositAccountTermAndPreClosure accountTermAndPreClosure = this.assembleAccountTermAndPreClosure(command, prodTermAndPreClosure);
			 FixedDepositAccount fdAccount = FixedDepositAccount.createNewApplicationForSubmittal(client, group, product, fieldOfficer, accountNo, externalId, accountType, submittedOnDate, submittedBy, interestRate, interestCompoundingPeriodType, interestPostingPeriodType, interestCalculationType, interestCalculationDaysInYearType, minRequiredOpeningBalance, lockinPeriodFrequency, lockinPeriodFrequencyType, iswithdrawalFeeApplicableForTransfer, charges, accountTermAndPreClosure, accountChart, withHoldTax);
			 accountTermAndPreClosure.updateAccountReference(fdAccount);
			 fdAccount.validateDomainRules();
			 account = fdAccount;
		 }
		 else if (depositAccountType.isRecurringDeposit()) {
			 final DepositProductTermAndPreClosure prodTermAndPreClosure = ((RecurringDepositProduct) product) .depositProductTermAndPreClosure();
			 final DepositAccountTermAndPreClosure accountTermAndPreClosure = this.assembleAccountTermAndPreClosure(command, prodTermAndPreClosure);
			 final DepositProductRecurringDetail prodRecurringDetail = ((RecurringDepositProduct) product).depositRecurringDetail();
			 final DepositAccountRecurringDetail accountRecurringDetail = this.assembleAccountRecurringDetail(command, prodRecurringDetail.recurringDetail());
			 RecurringDepositAccount rdAccount = RecurringDepositAccount.createNewApplicationForSubmittal(client, group, product, fieldOfficer, accountNo, externalId, accountType, submittedOnDate, submittedBy, interestRate, interestCompoundingPeriodType, interestPostingPeriodType, interestCalculationType, interestCalculationDaysInYearType, minRequiredOpeningBalance, lockinPeriodFrequency, lockinPeriodFrequencyType, iswithdrawalFeeApplicableForTransfer, charges, accountTermAndPreClosure, accountRecurringDetail, accountChart, withHoldTax);
			 accountTermAndPreClosure.updateAccountReference(rdAccount);
			 accountRecurringDetail.updateAccountReference(rdAccount);
			 rdAccount.validateDomainRules();
			 account = rdAccount;
		 }
		 if (account != null) {
			 account.setHelpers(this.savingsAccountTransactionSummaryWrapper, this.savingsHelper);
			 account.validateNewApplicationState(DateUtils.getLocalDateOfTenant(), depositAccountType.resourceName());
		 }
		 return account;
	 }
	 public SavingsAccount assembleFrom(final Long savingsId, DepositAccountType depositAccountType) {
		 final SavingsAccount account = this.savingsAccountRepository.findOneWithNotFoundDetection(savingsId, depositAccountType);
		 account.setHelpers(this.savingsAccountTransactionSummaryWrapper, this.savingsHelper);
		 return account;
	 }
	 public void assignSavingAccountHelpers(final SavingsAccount savingsAccount) {
		 savingsAccount.setHelpers(this.savingsAccountTransactionSummaryWrapper, this.savingsHelper);
	 }
	 public DepositAccountTermAndPreClosure assembleAccountTermAndPreClosure(final JsonCommand command, final DepositProductTermAndPreClosure productTermAndPreclosure) {
		 final DepositPreClosureDetail productPreClosure = (productTermAndPreclosure == null) ? null : productTermAndPreclosure .depositPreClosureDetail();
		 final DepositTermDetail productTerm = (productTermAndPreclosure == null) ? null : productTermAndPreclosure.depositTermDetail();
		 final DepositPreClosureDetail updatedProductPreClosure = this.depositProductAssembler.assemblePreClosureDetail(command, productPreClosure);
		 final DepositTermDetail updatedProductTerm = this.depositProductAssembler.assembleDepositTermDetail(command, productTerm);
		 final BigDecimal depositAmount = command.bigDecimalValueOfParameterNamed(depositAmountParamName);
		 final Integer depositPeriod = command.integerValueOfParameterNamed(depositPeriodParamName);
		 final Integer depositPeriodFrequencyId = command.integerValueOfParameterNamed(depositPeriodFrequencyIdParamName);
		 final SavingsPeriodFrequencyType depositPeriodFrequency = SavingsPeriodFrequencyType.fromInt(depositPeriodFrequencyId);
		 final SavingsAccount account = null;
		 final LocalDate expectedFirstDepositOnDate = command.localDateValueOfParameterNamed(expectedFirstDepositOnDateParamName);
		 final Boolean trasferInterest = command.booleanPrimitiveValueOfParameterNamed(transferInterestToSavingsParamName);
		 final BigDecimal maturityAmount = null;
		 final LocalDate maturityDate = null;
		 final DepositAccountOnClosureType accountOnClosureType = null;
		 return DepositAccountTermAndPreClosure.createNew(updatedProductPreClosure, updatedProductTerm, account, depositAmount, maturityAmount, maturityDate, depositPeriod, depositPeriodFrequency, expectedFirstDepositOnDate, accountOnClosureType, trasferInterest);
	 }
	 public DepositAccountRecurringDetail assembleAccountRecurringDetail(final JsonCommand command, final DepositRecurringDetail prodRecurringDetail) {
		 final BigDecimal recurringDepositAmount = command.bigDecimalValueOfParameterNamed(mandatoryRecommendedDepositAmountParamName);
		 boolean isMandatoryDeposit;
		 boolean allowWithdrawal;
		 boolean adjustAdvanceTowardsFuturePayments;
		 boolean isCalendarInherited;
		 if (command.parameterExists(isMandatoryDepositParamName)) {
			 isMandatoryDeposit = command.booleanObjectValueOfParameterNamed(isMandatoryDepositParamName);
		 }
		 else {
			 isMandatoryDeposit = prodRecurringDetail.isMandatoryDeposit();
		 }
		 if (command.parameterExists(allowWithdrawalParamName)) {
			 allowWithdrawal = command.booleanObjectValueOfParameterNamed(allowWithdrawalParamName);
		 }
		 else {
			 allowWithdrawal = prodRecurringDetail.allowWithdrawal();
		 }
		 if (command.parameterExists(adjustAdvanceTowardsFuturePaymentsParamName)) {
			 adjustAdvanceTowardsFuturePayments = command.booleanObjectValueOfParameterNamed(adjustAdvanceTowardsFuturePaymentsParamName);
		 }
		 else {
			 adjustAdvanceTowardsFuturePayments = prodRecurringDetail.adjustAdvanceTowardsFuturePayments();
		 }
		 if (command.parameterExists(isCalendarInheritedParamName)) {
			 isCalendarInherited = command.booleanObjectValueOfParameterNamed(isCalendarInheritedParamName);
		 }
		 else {
			 isCalendarInherited = false;
		 }
		 final DepositRecurringDetail depositRecurringDetail = DepositRecurringDetail.createFrom(isMandatoryDeposit, allowWithdrawal, adjustAdvanceTowardsFuturePayments);
		 final DepositAccountRecurringDetail depositAccountRecurringDetail = DepositAccountRecurringDetail.createNew(recurringDepositAmount, depositRecurringDetail, null, isCalendarInherited);
		 return depositAccountRecurringDetail;
	 }
	 public Collection<SavingsAccountTransactionDTO> assembleBulkMandatorySavingsAccountTransactionDTOs(final JsonCommand command,final PaymentDetail paymentDetail) {
		 AppUser user = getAppUserIfPresent();
		 final String json = command.json();
		 if (StringUtils.isBlank(json)) {
			 throw new InvalidJsonException();
		 }
		 final JsonElement element = this.fromApiJsonHelper.parse(json);
		 final Collection<SavingsAccountTransactionDTO> savingsAccountTransactions = new ArrayList<>();
		 final LocalDate transactionDate = this.fromApiJsonHelper.extractLocalDateNamed(transactionDateParamName, element);
		 final String dateFormat = this.fromApiJsonHelper.extractDateFormatParameter(element.getAsJsonObject());
		 final JsonObject topLevelJsonElement = element.getAsJsonObject();
		 final Locale locale = this.fromApiJsonHelper.extractLocaleParameter(topLevelJsonElement);
		 final DateTimeFormatter formatter = DateTimeFormat.forPattern(dateFormat).withLocale(locale);
		 if (element.isJsonObject()) {
			 if (topLevelJsonElement.has(bulkSavingsDueTransactionsParamName) && topLevelJsonElement.get(bulkSavingsDueTransactionsParamName).isJsonArray()) {
				 final JsonArray array = topLevelJsonElement.get(bulkSavingsDueTransactionsParamName).getAsJsonArray();
				 for (int i = 0;
				 i < array.size();
				 i++) {
					 final JsonObject savingsTransactionElement = array.get(i).getAsJsonObject();
					 final Long savingsId = this.fromApiJsonHelper.extractLongNamed(savingsIdParamName, savingsTransactionElement);
					 final BigDecimal dueAmount = this.fromApiJsonHelper.extractBigDecimalNamed(transactionAmountParamName, savingsTransactionElement, locale);
					 final Integer depositAccountType = this.fromApiJsonHelper.extractIntegerNamed( CollectionSheetConstants.depositAccountTypeParamName, savingsTransactionElement, locale);
					 PaymentDetail detail = paymentDetail;
					 if (paymentDetail == null) {
						 detail = this.paymentDetailAssembler.fetchPaymentDetail(savingsTransactionElement);
					 }
					 final SavingsAccountTransactionDTO savingsAccountTransactionDTO = new SavingsAccountTransactionDTO(formatter, transactionDate, dueAmount, detail, new Date(), savingsId, user, depositAccountType);
					 savingsAccountTransactions.add(savingsAccountTransactionDTO);
				 }
			 }
		 }
		 return savingsAccountTransactions;
	 }
	 private AppUser getAppUserIfPresent() {
		 AppUser user = null;
		 if (this.context != null) {
			 user = this.context.getAuthenticatedUserIfPresent();
		 }
		 return user;
	 }
}",1,0,0,0
"public class PostgresDatabaseAccessor extends GenericJdbcDatabaseAccessor {
	 protected String addLimitAndOffsetToQuery(String sql, int limit, int offset) {
		 if (offset == 0) {
			 return addLimitToQuery(sql, limit);
		 }
		 else {
			 if (limit == -1) {
				 return sql;
			 }
			 return sql + "" LIMIT "" + limit + "" OFFSET "" + offset;
		 }
	 }
	 protected String addLimitToQuery(String sql, int limit) {
		 if (limit == -1) {
			 return sql;
		 }
		 return sql + "" LIMIT "" + limit;
	 }
}",0,0,0,0
"public GrammerException(int offset, int line, int column, String msg);",0,0,0,1
"public class JPADynRealmMembership extends AbstractGeneratedKeyEntity implements DynRealmMembership {
	 private static final long serialVersionUID = 8157856850557493134L;
	 public static final String TABLE = ""DynRealmMembership"";
	 private JPADynRealm dynRealm;
	 private JPAAnyType anyType;
	 private String fiql;
	 public DynRealm getDynRealm() {
		 return dynRealm;
	 }
	 public void setDynRealm(final DynRealm dynRealm) {
		 checkType(dynRealm, JPADynRealm.class);
		 this.dynRealm = (JPADynRealm) dynRealm;
	 }
	 public AnyType getAnyType() {
		 return anyType;
	 }
	 public void setAnyType(final AnyType anyType) {
		 checkType(anyType, JPAAnyType.class);
		 this.anyType = (JPAAnyType) anyType;
	 }
	 public String getFIQLCond() {
		 return fiql;
	 }
	 public void setFIQLCond(final String fiql) {
		 this.fiql = fiql;
	 }
}",0,1,0,0
"private static class RemoveAppTransition implements SingleArcTransition<RMStateStore, RMStateStoreEvent> {
	 public void transition(RMStateStore store, RMStateStoreEvent event) {
		 if (!(event instanceof RMStateStoreRemoveAppEvent)) {
			 LOG.error(""Illegal event type: "" + event.getClass());
			 return;
		 }
		 ApplicationState appState = ((RMStateStoreRemoveAppEvent) event) .getAppState();
		 ApplicationId appId = appState.getAppId();
		 LOG.info(""Removing info for app: "" + appId);
		 try {
			 store.removeApplicationStateInternal(appState);
		 }
		 catch (Exception e) {
			 LOG.error(""Error removing app: "" + appId, e);
			 store.notifyStoreOperationFailed(e);
		 }
	 }
	;
 }",0,0,0,0
"public class UDFContextTestLoader extends PigStorage {
	 private String[] vals = new String[1];
	 public UDFContextTestLoader(String v1) {
		 vals[0] = v1;
		 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass(), vals);
		 p.setProperty(""key1"", vals[0]);
	 }
	 public Tuple getNext() throws IOException {
		 Tuple t = super.getNext();
		 if (t != null) {
			 if (UDFContext.getUDFContext().getJobConf() == null) {
				 t.append(""JobConf is null!"");
			 }
			 else {
				 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass(), vals);
				 t.append(p.getProperty(""key1""));
			 }
		 }
		 return t;
	 }
}",1,0,0,0
"DatanodeDescriptor[] chooseTargets( int desiredReplicates, Collection<DatanodeDescriptor> forbiddenNodes, UTF8 clientMachine, long blockSize) {
	 if (desiredReplicates > heartbeats.size()) {
		 LOG.warn(""Replication requested of ""+desiredReplicates +"" is larger than cluster size (""+heartbeats.size() +""). Using cluster size."");
		 desiredReplicates = heartbeats.size();
	 }
	 Collection<DatanodeDescriptor> alreadyChosen;
	 alreadyChosen = new TreeSet<DatanodeDescriptor>();
	 Collection<DatanodeDescriptor> targets = new ArrayList<DatanodeDescriptor>();
	 for (int i = 0;
	 i < desiredReplicates;
	 i++) {
		 DatanodeDescriptor target = chooseTarget(forbiddenNodes, alreadyChosen, clientMachine, blockSize);
		 if (target == null) break;
		 targets.add(target);
		 alreadyChosen.add(target);
	 }
	 return (DatanodeDescriptor[]) targets.toArray(new DatanodeDescriptor[targets.size()]);
 }",0,0,0,0
"public class Token{
	 public static final boolean printTrees = false;
	 static final boolean printICode = false;
	 static final boolean printNames = printTrees || printICode;
	 public final static int ERROR = -1, EOF = 0, EOL = 1, FIRST_BYTECODE_TOKEN = 2, ENTERWITH = 2, LEAVEWITH = 3, RETURN = 4, GOTO = 5, IFEQ = 6, IFNE = 7, SETNAME = 8, BITOR = 9, BITXOR = 10, BITAND = 11, EQ = 12, NE = 13, LT = 14, LE = 15, GT = 16, GE = 17, LSH = 18, RSH = 19, URSH = 20, ADD = 21, SUB = 22, MUL = 23, DIV = 24, MOD = 25, NOT = 26, BITNOT = 27, POS = 28, NEG = 29, NEW = 30, DELPROP = 31, TYPEOF = 32, GETPROP = 33, SETPROP = 34, GETELEM = 35, SETELEM = 36, CALL = 37, NAME = 38, NUMBER = 39, STRING = 40, NULL = 41, THIS = 42, FALSE = 43, TRUE = 44, SHEQ = 45, SHNE = 46, REGEXP = 47, BINDNAME = 48, THROW = 49, RETHROW = 50, IN = 51, INSTANCEOF = 52, LOCAL_LOAD = 53, GETVAR = 54, SETVAR = 55, CATCH_SCOPE = 56, ENUM_INIT_KEYS = 57, ENUM_INIT_VALUES = 58, ENUM_NEXT = 59, ENUM_ID = 60, THISFN = 61, RETURN_RESULT = 62, ARRAYLIT = 63, OBJECTLIT = 64, GET_REF = 65, SET_REF = 66, DEL_REF = 67, REF_CALL = 68, REF_SPECIAL = 69, DEFAULTNAMESPACE = 70, ESCXMLATTR = 71, ESCXMLTEXT = 72, REF_MEMBER = 73, REF_NS_MEMBER = 74, REF_NAME = 75, REF_NS_NAME = 76;
	 public final static int LAST_BYTECODE_TOKEN = REF_NS_NAME, TRY = 77, SEMI = 78, LB = 79, RB = 80, LC = 81, RC = 82, LP = 83, RP = 84, COMMA = 85, ASSIGN = 86, ASSIGN_BITOR = 87, ASSIGN_BITXOR = 88, ASSIGN_BITAND = 89, ASSIGN_LSH = 90, ASSIGN_RSH = 91, ASSIGN_URSH = 92, ASSIGN_ADD = 93, ASSIGN_SUB = 94, ASSIGN_MUL = 95, ASSIGN_DIV = 96, ASSIGN_MOD = 97;
	 public final static int FIRST_ASSIGN = ASSIGN, LAST_ASSIGN = ASSIGN_MOD, HOOK = 98, COLON = 99, OR = 100, AND = 101, INC = 102, DEC = 103, DOT = 104, FUNCTION = 105, EXPORT = 106, IMPORT = 107, IF = 108, ELSE = 109, SWITCH = 110, CASE = 111, DEFAULT = 112, WHILE = 113, DO = 114, FOR = 115, BREAK = 116, CONTINUE = 117, VAR = 118, WITH = 119, CATCH = 120, FINALLY = 121, VOID = 122, RESERVED = 123, EMPTY = 124, BLOCK = 125, LABEL = 126, TARGET = 127, LOOP = 128, EXPR_VOID = 129, EXPR_RESULT = 130, JSR = 131, SCRIPT = 132, TYPEOFNAME = 133, USE_STACK = 134, SETPROP_OP = 135, SETELEM_OP = 136, LOCAL_BLOCK = 137, SET_REF_OP = 138, DOTDOT = 139, COLONCOLON = 140, XML = 141, DOTQUERY = 142, XMLATTR = 143, XMLEND = 144, LAST_TOKEN = 144;
	 public static String name(int token) {
		 if (!printNames) {
			 return String.valueOf(token);
		 }
		 if (!(-1 <= token && token <= LAST_TOKEN)) {
			 return String.valueOf(token);
		 }
		 switch (token) {
			 case ERROR: return ""ERROR"";
			 case EOF: return ""EOF"";
			 case EOL: return ""EOL"";
			 case ENTERWITH: return ""ENTERWITH"";
			 case LEAVEWITH: return ""LEAVEWITH"";
			 case RETURN: return ""RETURN"";
			 case GOTO: return ""GOTO"";
			 case IFEQ: return ""IFEQ"";
			 case IFNE: return ""IFNE"";
			 case SETNAME: return ""SETNAME"";
			 case BITOR: return ""BITOR"";
			 case BITXOR: return ""BITXOR"";
			 case BITAND: return ""BITAND"";
			 case EQ: return ""EQ"";
			 case NE: return ""NE"";
			 case LT: return ""LT"";
			 case LE: return ""LE"";
			 case GT: return ""GT"";
			 case GE: return ""GE"";
			 case LSH: return ""LSH"";
			 case RSH: return ""RSH"";
			 case URSH: return ""URSH"";
			 case ADD: return ""ADD"";
			 case SUB: return ""SUB"";
			 case MUL: return ""MUL"";
			 case DIV: return ""DIV"";
			 case MOD: return ""MOD"";
			 case NOT: return ""NOT"";
			 case BITNOT: return ""BITNOT"";
			 case POS: return ""POS"";
			 case NEG: return ""NEG"";
			 case NEW: return ""NEW"";
			 case DELPROP: return ""DELPROP"";
			 case TYPEOF: return ""TYPEOF"";
			 case GETPROP: return ""GETPROP"";
			 case SETPROP: return ""SETPROP"";
			 case GETELEM: return ""GETELEM"";
			 case SETELEM: return ""SETELEM"";
			 case CALL: return ""CALL"";
			 case NAME: return ""NAME"";
			 case NUMBER: return ""NUMBER"";
			 case STRING: return ""STRING"";
			 case NULL: return ""NULL"";
			 case THIS: return ""THIS"";
			 case FALSE: return ""FALSE"";
			 case TRUE: return ""TRUE"";
			 case SHEQ: return ""SHEQ"";
			 case SHNE: return ""SHNE"";
			 case REGEXP: return ""OBJECT"";
			 case BINDNAME: return ""BINDNAME"";
			 case THROW: return ""THROW"";
			 case RETHROW: return ""RETHROW"";
			 case IN: return ""IN"";
			 case INSTANCEOF: return ""INSTANCEOF"";
			 case LOCAL_LOAD: return ""LOCAL_LOAD"";
			 case GETVAR: return ""GETVAR"";
			 case SETVAR: return ""SETVAR"";
			 case CATCH_SCOPE: return ""CATCH_SCOPE"";
			 case ENUM_INIT_KEYS: return ""ENUM_INIT_KEYS"";
			 case ENUM_INIT_VALUES: return ""ENUM_INIT_VALUES"";
			 case ENUM_NEXT: return ""ENUM_NEXT"";
			 case ENUM_ID: return ""ENUM_ID"";
			 case THISFN: return ""THISFN"";
			 case RETURN_RESULT: return ""RETURN_RESULT"";
			 case ARRAYLIT: return ""ARRAYLIT"";
			 case OBJECTLIT: return ""OBJECTLIT"";
			 case GET_REF: return ""GET_REF"";
			 case SET_REF: return ""SET_REF"";
			 case DEL_REF: return ""DEL_REF"";
			 case REF_CALL: return ""REF_CALL"";
			 case REF_SPECIAL: return ""REF_SPECIAL"";
			 case DEFAULTNAMESPACE:return ""DEFAULTNAMESPACE"";
			 case ESCXMLTEXT: return ""ESCXMLTEXT"";
			 case ESCXMLATTR: return ""ESCXMLATTR"";
			 case REF_MEMBER: return ""REF_MEMBER"";
			 case REF_NS_MEMBER: return ""REF_NS_MEMBER"";
			 case REF_NAME: return ""REF_NAME"";
			 case REF_NS_NAME: return ""REF_NS_NAME"";
			 case TRY: return ""TRY"";
			 case SEMI: return ""SEMI"";
			 case LB: return ""LB"";
			 case RB: return ""RB"";
			 case LC: return ""LC"";
			 case RC: return ""RC"";
			 case LP: return ""LP"";
			 case RP: return ""RP"";
			 case COMMA: return ""COMMA"";
			 case ASSIGN: return ""ASSIGN"";
			 case ASSIGN_BITOR: return ""ASSIGN_BITOR"";
			 case ASSIGN_BITXOR: return ""ASSIGN_BITXOR"";
			 case ASSIGN_BITAND: return ""ASSIGN_BITAND"";
			 case ASSIGN_LSH: return ""ASSIGN_LSH"";
			 case ASSIGN_RSH: return ""ASSIGN_RSH"";
			 case ASSIGN_URSH: return ""ASSIGN_URSH"";
			 case ASSIGN_ADD: return ""ASSIGN_ADD"";
			 case ASSIGN_SUB: return ""ASSIGN_SUB"";
			 case ASSIGN_MUL: return ""ASSIGN_MUL"";
			 case ASSIGN_DIV: return ""ASSIGN_DIV"";
			 case ASSIGN_MOD: return ""ASSIGN_MOD"";
			 case HOOK: return ""HOOK"";
			 case COLON: return ""COLON"";
			 case OR: return ""OR"";
			 case AND: return ""AND"";
			 case INC: return ""INC"";
			 case DEC: return ""DEC"";
			 case DOT: return ""DOT"";
			 case FUNCTION: return ""FUNCTION"";
			 case EXPORT: return ""EXPORT"";
			 case IMPORT: return ""IMPORT"";
			 case IF: return ""IF"";
			 case ELSE: return ""ELSE"";
			 case SWITCH: return ""SWITCH"";
			 case CASE: return ""CASE"";
			 case DEFAULT: return ""DEFAULT"";
			 case WHILE: return ""WHILE"";
			 case DO: return ""DO"";
			 case FOR: return ""FOR"";
			 case BREAK: return ""BREAK"";
			 case CONTINUE: return ""CONTINUE"";
			 case VAR: return ""VAR"";
			 case WITH: return ""WITH"";
			 case CATCH: return ""CATCH"";
			 case FINALLY: return ""FINALLY"";
			 case RESERVED: return ""RESERVED"";
			 case EMPTY: return ""EMPTY"";
			 case BLOCK: return ""BLOCK"";
			 case LABEL: return ""LABEL"";
			 case TARGET: return ""TARGET"";
			 case LOOP: return ""LOOP"";
			 case EXPR_VOID: return ""EXPR_VOID"";
			 case EXPR_RESULT: return ""EXPR_RESULT"";
			 case JSR: return ""JSR"";
			 case SCRIPT: return ""SCRIPT"";
			 case TYPEOFNAME: return ""TYPEOFNAME"";
			 case USE_STACK: return ""USE_STACK"";
			 case SETPROP_OP: return ""SETPROP_OP"";
			 case SETELEM_OP: return ""SETELEM_OP"";
			 case LOCAL_BLOCK: return ""LOCAL_BLOCK"";
			 case SET_REF_OP: return ""SET_REF_OP"";
			 case DOTDOT: return ""DOTDOT"";
			 case COLONCOLON: return ""COLONCOLON"";
			 case XML: return ""XML"";
			 case DOTQUERY: return ""DOTQUERY"";
			 case XMLATTR: return ""XMLATTR"";
			 case XMLEND: return ""XMLEND"";
		 }
		 throw new IllegalStateException(String.valueOf(token));
	 }
}",1,0,0,0
"public final class ClassNameSourceProvider implements SourceProvider {
	 public static final String TYPE = ""class"";
	 private final ClassLoader classLoader;
	 public ClassNameSourceProvider(FileSupport fileSupport) {
		 String classPath = System.getProperty(""java.class.path"");
		 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
		 if (classPath != null && !classPath.isEmpty()) {
			 classLoader = systemClassLoader;
		 }
		 else {
			 Path path = Paths.get(""."").toAbsolutePath();
			 classLoader = fileSupport.createClassLoader(path, systemClassLoader);
		 }
	 }
	 public ClassSource findSource(String name0, SearchPath searchPath) {
		 String name = name0;
		 Path path = Paths.get(name);
		 if (ClassSource.pathIsClassFile(path)) {
			 name = ClassSource.makeClassName(path);
		 }
		 try {
			 classLoader.loadClass(name);
			 return new ClassNameSource(name, classLoader);
		 }
		 catch (ClassNotFoundException e) {
			 return null;
		 }
	 }
	 public boolean supports(String type) {
		 return TYPE.equals(type);
	 }
}",0,0,0,0
"public interface ModelCon {
	 Resource getResource(String uri, ResourceF f) ;
	 Property getProperty(String uri) ;
	 Bag getBag(String uri) ;
	 Bag getBag(Resource r) ;
	 Alt getAlt(String uri) ;
	 Alt getAlt(Resource r) ;
	 Seq getSeq(String uri) ;
	 Seq getSeq(Resource r) ;
	 RDFList getList(String uri) ;
	 RDFList getList(Resource r) ;
	 public Resource createResource(Resource type) ;
	 public RDFNode getRDFNode( Node n );
	 public Resource createResource(String uri, Resource type);
	 public Resource createResource(ResourceF f) ;
	 public Resource createResource(String uri, ResourceF f) ;
	 public Property createProperty(String uri) ;
	 public Literal createLiteral( String v );
	 public Literal createTypedLiteral(boolean v) ;
	 public Literal createTypedLiteral(int v) ;
	 public Literal createTypedLiteral(long v) ;
	 public Literal createTypedLiteral(Calendar d);
	 public Literal createTypedLiteral(char v) ;
	 public Literal createTypedLiteral(float v) ;
	 public Literal createTypedLiteral(double v) ;
	 public Literal createTypedLiteral(String v) ;
	 public Literal createTypedLiteral(Object v) ;
	 public Literal createTypedLiteral(String lex, String typeURI) ;
	 public Literal createTypedLiteral(Object value, String typeURI);
	 public Statement createLiteralStatement( Resource s, Property p, boolean o );
	 public Statement createLiteralStatement( Resource s, Property p, float o );
	 public Statement createLiteralStatement( Resource s, Property p, double o );
	 public Statement createLiteralStatement( Resource s, Property p, long o );
	 public Statement createLiteralStatement( Resource s, Property p, int o );
	 public Statement createLiteralStatement( Resource s, Property p, char o );
	 public Statement createLiteralStatement( Resource s, Property p, Object o );
	 public Statement createStatement(Resource s, Property p, String o) ;
	 public Statement createStatement(Resource s, Property p, String o, String l) ;
	 public Statement createStatement(Resource s, Property p, String o, boolean wellFormed) ;
	 public Statement createStatement(Resource s, Property p, String o, String l, boolean wellFormed) ;
	 public Bag createBag() ;
	 public Bag createBag(String uri) ;
	 public Alt createAlt() ;
	 public Alt createAlt(String uri) ;
	 public Seq createSeq() ;
	 public Seq createSeq(String uri) ;
	 Model add(Resource s, Property p, RDFNode o) ;
	 Model addLiteral( Resource s, Property p, boolean o );
	 Model addLiteral( Resource s, Property p, long o );
	 Model addLiteral( Resource s, Property p, int o );
	 Model addLiteral( Resource s, Property p, char o ) ;
	 Model addLiteral( Resource s, Property p, float o );
	 Model addLiteral( Resource s, Property p, double o ) ;
	 Model addLiteral( Resource s, Property p, Object o );
	 Model addLiteral( Resource s, Property p, Literal o );
	 Model add(Resource s, Property p, String o) ;
	 Model add(Resource s, Property p, String lex, RDFDatatype datatype) ;
	 Model add(Resource s, Property p, String o, boolean wellFormed);
	 Model add(Resource s, Property p, String o, String l) ;
	 Model remove( Resource s, Property p, RDFNode o );
	 Model remove(StmtIterator iter) ;
	 Model remove(Model m) ;
	 StmtIterator listLiteralStatements( Resource subject, Property predicate, boolean object );
	 StmtIterator listLiteralStatements( Resource subject, Property predicate, char object );
	 StmtIterator listLiteralStatements(Resource subject, Property predicate, long object );
	 StmtIterator listLiteralStatements(Resource subject, Property predicate, int object );
	 StmtIterator listLiteralStatements( Resource subject, Property predicate, float object );
	 StmtIterator listLiteralStatements(Resource subject, Property predicate, double object );
	 StmtIterator listStatements( Resource subject, Property predicate, String object );
	 StmtIterator listStatements(Resource subject, Property predicate, String object, String lang) ;
	 ResIterator listResourcesWithProperty( Property p, boolean o );
	 ResIterator listResourcesWithProperty( Property p, long o );
	 ResIterator listResourcesWithProperty( Property p, char o );
	 ResIterator listResourcesWithProperty( Property p, float o );
	 ResIterator listResourcesWithProperty( Property p, double o );
	 ResIterator listResourcesWithProperty( Property p, Object o );
	 ResIterator listSubjectsWithProperty( Property p, String o );
	 ResIterator listSubjectsWithProperty( Property p, String o, String l );
	 boolean containsLiteral( Resource s, Property p, boolean o );
	 boolean containsLiteral( Resource s, Property p, long o );
	 boolean containsLiteral( Resource s, Property p, int o );
	 boolean containsLiteral( Resource s, Property p, char o );
	 boolean containsLiteral( Resource s, Property p, float o );
	 boolean containsLiteral( Resource s, Property p, double o );
	 boolean containsLiteral( Resource s, Property p, Object o );
	 boolean contains( Resource s, Property p, String o );
	 boolean contains( Resource s, Property p, String o, String l );
}",1,0,0,0
"public class StringBlob {
	 private byte[] rawBlob;
	 private String string;
	 public StringBlob(byte[] byteArray) {
		 this.rawBlob = ByteArrayUtils.weakIntern(byteArray);
	 }
	 public StringBlob(String inputString) {
		 this.string = StringUtils.intern(inputString);
		 this.rawBlob = null;
	 }
	 public void setString(String str) {
		 this.string = StringUtils.intern(str);
		 this.rawBlob = null;
	 }
	 public String getString() {
		 if (string != null) {
			 return string;
		 }
		 if (rawBlob == null) {
			 return null;
		 }
		 try {
			 DataInputStream dais = new DataInputStream(new ByteArrayInputStream(rawBlob));
			 CompressionCodec codec = CodecFactory.getDeCompressionCodec(dais);
			 if (codec != null) {
				 string = StringUtils.intern(codec.decompressToString(dais));
			 }
			 else {
				 string = StringUtils.intern((new String(rawBlob, CodecFactory.UTF_8_ENCODING)));
			 }
			 dais.close();
		 }
		 catch (IOException ex) {
			 throw new RuntimeException(ex);
		 }
		 rawBlob = null;
		 return string;
	 }
	 public byte[] getRawBlob() {
		 if (rawBlob != null) {
			 return rawBlob;
		 }
		 if (string == null) {
			 return null;
		 }
		 if (CodecFactory.isCompressionEnabled()) {
			 byte[] bytes = CodecFactory.getHeaderBytes();
			 try {
				 rawBlob = ByteArrayUtils.weakIntern(CodecFactory.getCompressionCodec().compressString(bytes, string));
			 }
			 catch (IOException ex) {
				 throw new RuntimeException(ex);
			 }
		 }
		 else {
			 rawBlob = ByteArrayUtils.weakIntern(string.getBytes(Charsets.UTF_8));
		 }
		 return rawBlob;
	 }
}",0,0,0,0
"public class GenRandomData {
	 public static ResourceFieldSchema getRandMapFieldSchema() throws IOException {
		 ResourceFieldSchema bytefs = new ResourceFieldSchema();
		 bytefs.setType(DataType.BYTEARRAY);
		 ResourceSchema mapSchema = new ResourceSchema();
		 mapSchema.setFields(new ResourceFieldSchema[]{
		bytefs}
		);
		 ResourceFieldSchema mapfs = new ResourceFieldSchema();
		 mapfs.setSchema(mapSchema);
		 mapfs.setType(DataType.MAP);
		 return mapfs;
	 }
	 public static Map<String, Object> genRandMap(Random r, int numEnt) {
		 Map<String,Object> ret = new HashMap<String, Object>();
		 if(r==null){
			 ret.put(""random"", ""RANDOM"");
			 return ret;
		 }
		 for(int i=0;
		i<numEnt;
		i++){
			 ret.put(genRandString(r), new DataByteArray(genRandString(r).getBytes()));
		 }
		 return ret;
	 }
	 public static String genRandString(Random r){
		 if(r==null) return ""RANDOM"";
		 char[] chars = new char[10];
		 for(int i=0;
		i<10;
		i++){
			 chars[i] = (char)(r.nextInt(26)+65);
		 }
		 return new String(chars);
	 }
	 public static String genRandLargeString(Random r, int size){
		 if(r==null) return ""RANDOM"";
		 if(size <= 10) return genRandString(r);
		 char[] chars = new char[size];
		 for(int i=0;
		i<size;
		i++){
			 chars[i] = (char)(r.nextInt(26)+65);
		 }
		 return new String(chars);
	 }
	 public static DataByteArray genRandDBA(Random r){
		 if(r==null) return new DataByteArray(""RANDOM"".getBytes());
		 byte[] bytes = new byte[10];
		 r.nextBytes(bytes);
		 return new DataByteArray(bytes);
	 }
	 public static DataByteArray genRandTextDBA(Random r){
		 if(r==null) return new DataByteArray(""RANDOM"".getBytes());
		 return new DataByteArray(genRandString(r).getBytes());
	 }
	 public static ResourceFieldSchema getSmallTupleFieldSchema() throws IOException{
		 ResourceFieldSchema stringfs = new ResourceFieldSchema();
		 stringfs.setType(DataType.CHARARRAY);
		 ResourceFieldSchema intfs = new ResourceFieldSchema();
		 intfs.setType(DataType.INTEGER);
		 ResourceSchema tupleSchema = new ResourceSchema();
		 tupleSchema.setFields(new ResourceFieldSchema[]{
		stringfs, intfs}
		);
		 ResourceFieldSchema tuplefs = new ResourceFieldSchema();
		 tuplefs.setSchema(tupleSchema);
		 tuplefs.setType(DataType.TUPLE);
		 return tuplefs;
	 }
	 public static Tuple genRandSmallTuple(Random r, int limit){
		 if(r==null){
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 return t;
		 }
		 Tuple t = new DefaultTuple();
		 t.append(genRandString(r));
		 t.append(r.nextInt(limit));
		 return t;
	 }
	 public static Tuple genRandSmallTuple(String s, Integer value){
		 Tuple t = new DefaultTuple();
		 t.append(s);
		 t.append(value);
		 return t;
	 }
	 public static DataBag genRandSmallTupDataBagWithNulls(Random r, int num, int limit){
		 if(r==null) {
			 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 db.add(t);
			 return db;
		 }
		 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
		 for(int i=0;
		i<num;
		i++){
			 if(i == 0) {
				 db.add(genRandSmallTuple(r, limit));
				 continue;
			 }
			 else {
				 int rand = r.nextInt(num);
				 if(rand <= (0.2 * num) ) {
					 db.add(genRandSmallTuple((String)null, rand));
				 }
				 else if (rand > (0.2 * num) && rand <= (0.4 * num)) {
					 db.add(genRandSmallTuple(genRandString(r), null));
				 }
				 else if (rand > (0.4 * num) && rand <= (0.6 * num)) {
					 db.add(genRandSmallTuple(null, null));
				 }
				 else {
					 db.add(genRandSmallTuple(r, limit));
				 }
			 }
		 }
		 return db;
	 }
	 public static ResourceFieldSchema getSmallTupDataBagFieldSchema() throws IOException {
		 ResourceFieldSchema tuplefs = getSmallTupleFieldSchema();
		 ResourceSchema bagSchema = new ResourceSchema();
		 bagSchema.setFields(new ResourceFieldSchema[]{
		tuplefs}
		);
		 ResourceFieldSchema bagfs = new ResourceFieldSchema();
		 bagfs.setSchema(bagSchema);
		 bagfs.setType(DataType.BAG);
		 return bagfs;
	 }
	 public static DataBag genRandSmallTupDataBag(Random r, int num, int limit){
		 if(r==null) {
			 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 db.add(t);
			 return db;
		 }
		 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
		 for(int i=0;
		i<num;
		i++){
			 db.add(genRandSmallTuple(r, limit));
		 }
		 return db;
	 }
	 public static Tuple genRandSmallBagTuple(Random r, int num, int limit){
		 if(r==null){
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 return t;
		 }
		 Tuple t = new DefaultTuple();
		 t.append(genRandSmallTupDataBag(r, num, limit));
		 t.append(genRandDBA(r));
		 t.append(genRandString(r));
		 t.append(r.nextDouble());
		 t.append(r.nextFloat());
		 t.append(r.nextInt());
		 t.append(r.nextLong());
		 t.append(genRandMap(r, num));
		 t.append(genRandSmallTuple(r, 100));
		 t.append(new Boolean(r.nextBoolean()));
		 t.append(new DateTime(r.nextLong()));
		 return t;
	 }
	 public static ResourceFieldSchema getSmallBagTextTupleFieldSchema() throws IOException{
		 ResourceFieldSchema dbafs = new ResourceFieldSchema();
		 dbafs.setType(DataType.BYTEARRAY);
		 ResourceFieldSchema stringfs = new ResourceFieldSchema();
		 stringfs.setType(DataType.CHARARRAY);
		 ResourceFieldSchema intfs = new ResourceFieldSchema();
		 intfs.setType(DataType.INTEGER);
		 ResourceFieldSchema bagfs = getSmallTupDataBagFieldSchema();
		 ResourceFieldSchema floatfs = new ResourceFieldSchema();
		 floatfs.setType(DataType.FLOAT);
		 ResourceFieldSchema doublefs = new ResourceFieldSchema();
		 doublefs.setType(DataType.DOUBLE);
		 ResourceFieldSchema longfs = new ResourceFieldSchema();
		 longfs.setType(DataType.LONG);
		 ResourceFieldSchema mapfs = new ResourceFieldSchema();
		 mapfs.setType(DataType.MAP);
		 ResourceFieldSchema tuplefs = getSmallTupleFieldSchema();
		 ResourceFieldSchema boolfs = new ResourceFieldSchema();
		 boolfs.setType(DataType.BOOLEAN);
		 ResourceFieldSchema dtfs = new ResourceFieldSchema();
		 dtfs.setType(DataType.DATETIME);
		 ResourceSchema outSchema = new ResourceSchema();
		 outSchema.setFields(new ResourceFieldSchema[]{
		bagfs, dbafs, stringfs, doublefs, floatfs, intfs, longfs, mapfs, tuplefs, boolfs, dtfs}
		);
		 ResourceFieldSchema outfs = new ResourceFieldSchema();
		 outfs.setSchema(outSchema);
		 outfs.setType(DataType.TUPLE);
		 return outfs;
	 }
	 public static Tuple genRandSmallBagTextTuple(Random r, int num, int limit){
		 if(r==null){
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 return t;
		 }
		 Tuple t = new DefaultTuple();
		 t.append(genRandSmallTupDataBag(r, num, limit));
		 t.append(genRandTextDBA(r));
		 t.append(genRandString(r));
		 t.append(r.nextDouble());
		 t.append(r.nextFloat());
		 t.append(r.nextInt());
		 t.append(r.nextLong());
		 t.append(genRandMap(r, num));
		 t.append(genRandSmallTuple(r, 100));
		 t.append(new Boolean(r.nextBoolean()));
		 t.append(new DateTime(r.nextLong()));
		 return t;
	 }
	 public static DataBag genRandFullTupDataBag(Random r, int num, int limit){
		 if(r==null) {
			 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 db.add(t);
			 return db;
		 }
		 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
		 for(int i=0;
		i<num;
		i++){
			 db.add(genRandSmallBagTuple(r, num, limit));
		 }
		 return db;
	 }
	 public static ResourceFieldSchema getFullTupTextDataBagFieldSchema() throws IOException{
		 ResourceFieldSchema tuplefs = getSmallBagTextTupleFieldSchema();
		 ResourceSchema outBagSchema = new ResourceSchema();
		 outBagSchema.setFields(new ResourceFieldSchema[]{
		tuplefs}
		);
		 ResourceFieldSchema outBagfs = new ResourceFieldSchema();
		 outBagfs.setSchema(outBagSchema);
		 outBagfs.setType(DataType.BAG);
		 return outBagfs;
	 }
	 public static DataBag genRandFullTupTextDataBag(Random r, int num, int limit){
		 if(r==null) {
			 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 db.add(t);
			 return db;
		 }
		 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
		 for(int i=0;
		i<num;
		i++){
			 db.add(genRandSmallBagTextTuple(r, num, limit));
		 }
		 return db;
	 }
	 public static Tuple genRandSmallBagTupleWithNulls(Random r, int num, int limit){
		 if(r==null){
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 return t;
		 }
		 Tuple t = new DefaultTuple();
		 t.append(genRandSmallTupDataBag(r, num, limit));
		 t.append(genRandDBA(r));
		 t.append(genRandString(r));
		 t.append(r.nextDouble());
		 t.append(r.nextFloat());
		 t.append(r.nextInt());
		 t.append(r.nextLong());
		 t.append(genRandMap(r, num));
		 t.append(genRandSmallTuple(r, 100));
		 t.append(new Boolean(r.nextBoolean()));
		 t.append(new DateTime(r.nextLong()));
		 t.append(null);
		 return t;
	 }
	 public static Tuple genRandSmallBagTextTupleWithNulls(Random r, int num, int limit){
		 if(r==null){
			 Tuple t = new DefaultTuple();
			 t.append(""RANDOM"");
			 return t;
		 }
		 Tuple t = new DefaultTuple();
		 t.append(genRandSmallTupDataBag(r, num, limit));
		 t.append(genRandTextDBA(r));
		 t.append(genRandString(r));
		 t.append(r.nextDouble());
		 t.append(r.nextFloat());
		 t.append(r.nextInt());
		 t.append(r.nextLong());
		 t.append(genRandMap(r, num));
		 t.append(genRandSmallTuple(r, 100));
		 t.append(new Boolean(r.nextBoolean()));
		 t.append(new DateTime(r.nextLong()));
		 t.append(null);
		 return t;
	 }
	 public static DataBag genFloatDataBag(Random r, int column, int row) {
		 DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
		 for (int i=0;
		i<row;
		i++) {
			 Tuple t = TupleFactory.getInstance().newTuple();
			 for (int j=0;
			j<column;
			j++) {
				 t.append(r.nextFloat()*1000);
			 }
			 db.add(t);
		 }
		 return db;
	 }
	 public static ResourceFieldSchema getFloatDataBagFieldSchema(int column) throws IOException {
		 ResourceFieldSchema intfs = new ResourceFieldSchema();
		 intfs.setType(DataType.INTEGER);
		 ResourceSchema tupleSchema = new ResourceSchema();
		 ResourceFieldSchema[] fss = new ResourceFieldSchema[column];
		 for (int i=0;
		i<column;
		i++) {
			 fss[i] = intfs;
		 }
		 tupleSchema.setFields(fss);
		 ResourceFieldSchema tuplefs = new ResourceFieldSchema();
		 tuplefs.setSchema(tupleSchema);
		 tuplefs.setType(DataType.TUPLE);
		 ResourceSchema bagSchema = new ResourceSchema();
		 bagSchema.setFields(new ResourceFieldSchema[]{
		tuplefs}
		);
		 ResourceFieldSchema bagfs = new ResourceFieldSchema();
		 bagfs.setSchema(bagSchema);
		 bagfs.setType(DataType.BAG);
		 return bagfs;
	 }
	 public static Tuple genMixedTupleToConvert(Random r) {
		 Tuple t = TupleFactory.getInstance().newTuple();
		 t.append(r.nextInt());
		 t.append(r.nextInt());
		 long l = 0;
		 while (l<=Integer.MAX_VALUE && l>=Integer.MIN_VALUE) l = r.nextLong();
		 t.append(l);
		 t.append(r.nextFloat()*1000);
		 t.append(r.nextDouble()*10000);
		 t.append(genRandString(r));
		 t.append(""K""+genRandString(r));
		 t.append(""K""+genRandString(r));
		 t.append(""K""+genRandString(r));
		 if (r.nextFloat()>0.5) t.append(""true"");
		 else t.append(""false"");
		 t.append(new DateTime(r.nextLong()));
		 return t;
	 }
	 public static ResourceFieldSchema getMixedTupleToConvertFieldSchema() throws IOException {
		 ResourceFieldSchema stringfs = new ResourceFieldSchema();
		 stringfs.setType(DataType.CHARARRAY);
		 ResourceFieldSchema intfs = new ResourceFieldSchema();
		 intfs.setType(DataType.INTEGER);
		 ResourceFieldSchema longfs = new ResourceFieldSchema();
		 longfs.setType(DataType.LONG);
		 ResourceFieldSchema floatfs = new ResourceFieldSchema();
		 floatfs.setType(DataType.FLOAT);
		 ResourceFieldSchema doublefs = new ResourceFieldSchema();
		 doublefs.setType(DataType.DOUBLE);
		 ResourceFieldSchema boolfs = new ResourceFieldSchema();
		 boolfs.setType(DataType.BOOLEAN);
		 ResourceFieldSchema dtfs = new ResourceFieldSchema();
		 dtfs.setType(DataType.DATETIME);
		 ResourceSchema tupleSchema = new ResourceSchema();
		 tupleSchema.setFields(new ResourceFieldSchema[]{
		stringfs, longfs, intfs, doublefs, floatfs, stringfs, intfs, doublefs, floatfs, boolfs, dtfs}
		);
		 ResourceFieldSchema tuplefs = new ResourceFieldSchema();
		 tuplefs.setSchema(tupleSchema);
		 tuplefs.setType(DataType.TUPLE);
		 return tuplefs;
	 }
}",1,0,0,0
"public void read(org.apache.thrift.protocol.TProtocol iprot, alter_table_with_cascade_result struct) throws org.apache.thrift.TException {
	 org.apache.thrift.protocol.TField schemeField;
	 iprot.readStructBegin();
	 while (true) {
		 schemeField = iprot.readFieldBegin();
		 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
			 break;
		 }
		 switch (schemeField.id) {
			 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
				 struct.o1 = new InvalidOperationException();
				 struct.o1.read(iprot);
				 struct.setO1IsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
				 struct.o2 = new MetaException();
				 struct.o2.read(iprot);
				 struct.setO2IsSet(true);
			 }
			 else {
				 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 break;
			 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
		 }
		 iprot.readFieldEnd();
	 }
	 iprot.readStructEnd();
	 struct.validate();
 }",0,0,1,0
"public interface ReactiveHealthIndicator {
	Mono<Health> health();
}",0,0,0,0
"class FSImage {
	 private static final String FS_IMAGE = ""fsimage"";
	 private static final String NEW_FS_IMAGE = ""fsimage.new"";
	 private static final String OLD_FS_IMAGE = ""fsimage.old"";
	 private static final String FS_TIME = ""fstime"";
	 private File[] imageDirs;
	 private FSEditLog editLog;
	 FSImage( File[] fsDirs ) throws IOException {
		 this.imageDirs = new File[fsDirs.length];
		 for (int idx = 0;
		 idx < imageDirs.length;
		 idx++) {
			 imageDirs[idx] = new File(fsDirs[idx], ""image"");
			 if (! imageDirs[idx].exists()) {
				 throw new IOException(""NameNode not formatted: "" + imageDirs[idx]);
			 }
		 }
		 File[] edits = new File[fsDirs.length];
		 for (int idx = 0;
		 idx < edits.length;
		 idx++) {
			 edits[idx] = new File(fsDirs[idx], ""edits"");
		 }
		 this.editLog = new FSEditLog( edits );
	 }
	 FSEditLog getEditLog() {
		 return editLog;
	 }
	 void loadFSImage( Configuration conf ) throws IOException {
		 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
		 FSDirectory fsDir = fsNamesys.dir;
		 for (int idx = 0;
		 idx < imageDirs.length;
		 idx++) {
			 File curFile = new File(imageDirs[idx], FS_IMAGE);
			 File newFile = new File(imageDirs[idx], NEW_FS_IMAGE);
			 File oldFile = new File(imageDirs[idx], OLD_FS_IMAGE);
			 if (oldFile.exists() && curFile.exists()) {
				 oldFile.delete();
				 if (editLog.exists()) {
					 editLog.deleteAll();
				 }
			 }
			 else if (oldFile.exists() && newFile.exists()) {
				 newFile.renameTo(curFile);
				 oldFile.delete();
			 }
			 else if (curFile.exists() && newFile.exists()) {
				 newFile.delete();
			 }
		 }
		 File curFile = null;
		 long maxTimeStamp = Long.MIN_VALUE;
		 for (int idx = 0;
		 idx < imageDirs.length;
		 idx++) {
			 File file = new File(imageDirs[idx], FS_IMAGE);
			 if (file.exists()) {
				 long timeStamp = 0;
				 File timeFile = new File(imageDirs[idx], FS_TIME);
				 if (timeFile.exists() && timeFile.canRead()) {
					 DataInputStream in = new DataInputStream( new FileInputStream(timeFile));
					 try {
						 timeStamp = in.readLong();
					 }
					 finally {
						 in.close();
					 }
				 }
				 if (maxTimeStamp < timeStamp) {
					 maxTimeStamp = timeStamp;
					 curFile = file;
				 }
			 }
		 }
		 boolean needToSave = true;
		 int imgVersion = FSConstants.DFS_CURRENT_VERSION;
		 if (curFile != null) {
			 DataInputStream in = new DataInputStream( new BufferedInputStream( new FileInputStream(curFile)));
			 try {
				 imgVersion = in.readInt();
				 if( imgVersion <= -2 ) fsDir.namespaceID = in.readInt();
				 int numFiles = 0;
				 if( imgVersion >= 0 ) {
					 numFiles = imgVersion;
					 imgVersion = 0;
				 }
				 else numFiles = in.readInt();
				 needToSave = ( imgVersion != FSConstants.DFS_CURRENT_VERSION );
				 if( imgVersion < FSConstants.DFS_CURRENT_VERSION ) throw new IncorrectVersionException(imgVersion, ""file system image"");
				 short replication = (short)conf.getInt(""dfs.replication"", 3);
				 for (int i = 0;
				 i < numFiles;
				 i++) {
					 UTF8 name = new UTF8();
					 name.readFields(in);
					 if( !(imgVersion >= 0) ) {
						 replication = in.readShort();
						 replication = FSEditLog.adjustReplication( replication, conf );
					 }
					 int numBlocks = in.readInt();
					 Block blocks[] = null;
					 if (numBlocks > 0) {
						 blocks = new Block[numBlocks];
						 for (int j = 0;
						 j < numBlocks;
						 j++) {
							 blocks[j] = new Block();
							 blocks[j].readFields(in);
						 }
					 }
					 fsDir.unprotectedAddFile(name, blocks, replication );
				 }
				 this.loadDatanodes( imgVersion, in );
			 }
			 finally {
				 in.close();
			 }
		 }
		 if( fsDir.namespaceID == 0 ) fsDir.namespaceID = newNamespaceID();
		 needToSave |= ( editLog.exists() && editLog.loadFSEdits(conf) > 0 );
		 if( needToSave ) saveFSImage();
	 }
	 void saveFSImage() throws IOException {
		 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
		 FSDirectory fsDir = fsNamesys.dir;
		 for (int idx = 0;
		 idx < imageDirs.length;
		 idx++) {
			 File newFile = new File(imageDirs[idx], NEW_FS_IMAGE);
			 DataOutputStream out = new DataOutputStream( new BufferedOutputStream( new FileOutputStream(newFile)));
			 try {
				 out.writeInt(FSConstants.DFS_CURRENT_VERSION);
				 out.writeInt(fsDir.namespaceID);
				 out.writeInt(fsDir.rootDir.numItemsInTree() - 1);
				 saveImage( """", fsDir.rootDir, out );
				 saveDatanodes( out );
			 }
			 finally {
				 out.close();
			 }
		 }
		 for (int idx = 0;
		 idx < imageDirs.length;
		 idx++) {
			 File curFile = new File(imageDirs[idx], FS_IMAGE);
			 File newFile = new File(imageDirs[idx], NEW_FS_IMAGE);
			 File oldFile = new File(imageDirs[idx], OLD_FS_IMAGE);
			 File timeFile = new File(imageDirs[idx], FS_TIME);
			 curFile.renameTo(oldFile);
			 if (timeFile.exists()) {
				 timeFile.delete();
			 }
			 newFile.renameTo(curFile);
			 DataOutputStream out = new DataOutputStream( new FileOutputStream(timeFile));
			 try {
				 out.writeLong(System.currentTimeMillis());
			 }
			 finally {
				 out.close();
			 }
			 editLog.delete(idx);
			 oldFile.delete();
		 }
	 }
	 private int newNamespaceID() {
		 Random r = new Random();
		 r.setSeed( System.currentTimeMillis() );
		 int newID = 0;
		 while( newID == 0) newID = r.nextInt();
		 return newID;
	 }
	 static void format(File dir) throws IOException {
		 File image = new File(dir, ""image"");
		 File edits = new File(dir, ""edits"");
		 if (!((!image.exists() || FileUtil.fullyDelete(image)) && (!edits.exists() || edits.delete()) && image.mkdirs())) {
			 throw new IOException(""Unable to format: ""+dir);
		 }
	 }
	 void saveImage( String parentPrefix, FSDirectory.INode root, DataOutputStream out ) throws IOException {
		 String fullName = """";
		 if( root.getParent() != null) {
			 fullName = parentPrefix + ""/"" + root.getLocalName();
			 new UTF8(fullName).write(out);
			 out.writeShort( root.getReplication() );
			 if( root.isDir() ) {
				 out.writeInt(0);
			 }
			 else {
				 int nrBlocks = root.getBlocks().length;
				 out.writeInt( nrBlocks );
				 for (int i = 0;
				 i < nrBlocks;
				 i++) root.getBlocks()[i].write(out);
			 }
		 }
		 for(Iterator it = root.getChildren().values().iterator();
		 it.hasNext();
		 ) {
			 INode child = (INode) it.next();
			 saveImage( fullName, child, out );
		 }
	 }
	 void saveDatanodes( DataOutputStream out ) throws IOException {
		 Map datanodeMap = FSNamesystem.getFSNamesystem().datanodeMap;
		 int size = datanodeMap.size();
		 out.writeInt( size );
		 for( Iterator it = datanodeMap.values().iterator();
		 it.hasNext();
		 ) ((DatanodeDescriptor)it.next()).write( out );
	 }
	 void loadDatanodes( int version, DataInputStream in ) throws IOException {
		 if( version > -3 ) return;
		 FSNamesystem fsNamesys = FSNamesystem.getFSNamesystem();
		 int size = in.readInt();
		 for( int i = 0;
		 i < size;
		 i++ ) {
			 DatanodeDescriptor node = new DatanodeDescriptor();
			 node.readFields(in);
			 fsNamesys.unprotectedAddDatanode( node );
		 }
	 }
}",0,0,0,0
"public abstract class IdentifierTypePattern extends TypePattern {
	private Type type;
	IdentifierTypePattern(AST ast, Type type) {
		super(ast);
		this.type = type;
		setTypePatternExpression(generateTypePatternExpression(this.type));
	}
	public Type getType() {
		return type;
	}
	protected String generateTypePatternExpression(Type type) {
		String typeExpression = null;
		if (type instanceof SimpleType) {
			Name name = ((SimpleType) type).getName();
			if (name instanceof SimpleName) {
				typeExpression = ((SimpleName) name).getIdentifier();
			}
		}
		if (typeExpression == null && type != null) {
			typeExpression = type.toString();
		}
		return typeExpression;
	}
	int memSize() {
		int memSize = super.memSize();
		Type type = getType();
		if (type != null) {
			memSize += type.memSize();
		}
		return memSize;
	}
	void accept0(ASTVisitor visitor) {
		if (visitor instanceof AjASTVisitor) {
			AjASTVisitor ajVisitor = (AjASTVisitor) visitor;
			boolean visited = ajVisitor.visit(this);
			Type type = getType();
			if (visited && type != null) {
				ajVisitor.visit(type);
			}
			ajVisitor.endVisit(this);
		}
	}
}",0,0,0,0
"public boolean isClean() {
	 return columnFamilies.isEmpty();
 }",0,0,0,0
"private boolean configureHA(final Long resourceId, final HAResource.ResourceType resourceType, final Boolean enable, final String haProvider) {
	 return Transaction.execute(new TransactionCallback<Boolean>() {
		 public Boolean doInTransaction(TransactionStatus status) {
			 HAConfigVO haConfig = (HAConfigVO) haConfigDao.findHAResource(resourceId, resourceType);
			 if (haConfig == null) {
				 haConfig = new HAConfigVO();
				 if (haProvider != null) {
					 haConfig.setHaProvider(haProvider);
				 }
				 if (enable != null) {
					 haConfig.setEnabled(enable);
					 haConfig.setManagementServerId(ManagementServerNode.getManagementServerId());
				 }
				 haConfig.setResourceId(resourceId);
				 haConfig.setResourceType(resourceType);
				 if (Strings.isNullOrEmpty(haConfig.getHaProvider())) {
					 throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""HAProvider is not provided for the resource, failing configuration."");
				 }
				 if (haConfigDao.persist(haConfig) != null) {
					 return true;
				 }
			 }
			 else {
				 if (enable != null) {
					 haConfig.setEnabled(enable);
				 }
				 if (haProvider != null) {
					 haConfig.setHaProvider(haProvider);
				 }
				 if (Strings.isNullOrEmpty(haConfig.getHaProvider())) {
					 throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""HAProvider is not provided for the resource, failing configuration."");
				 }
				 return haConfigDao.update(haConfig.getId(), haConfig);
			 }
			 return false;
		 }
	 }
	);
 }",0,0,1,0
"public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {
	 private CallableStatement stmt;
	 public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
		 super(conn, holder);
		 this.stmt = (CallableStatement) holder.statement;
	 }
	 public CallableStatement getCallableStatementRaw() {
		 return stmt;
	 }
	 public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {
		 try {
			 stmt.registerOutParameter(parameterIndex, sqlType);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {
		 try {
			 stmt.registerOutParameter(parameterIndex, sqlType, scale);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public boolean wasNull() throws SQLException {
		 try {
			 return stmt.wasNull();
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public String getString(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getString(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public boolean getBoolean(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getBoolean(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public byte getByte(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getByte(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public short getShort(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getShort(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public int getInt(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getInt(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public long getLong(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getLong(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public float getFloat(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getFloat(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public double getDouble(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getDouble(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {
		 try {
			 return stmt.getBigDecimal(parameterIndex, scale);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public byte[] getBytes(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getBytes(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Date getDate(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getDate(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Time getTime(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getTime(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getTimestamp(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Object getObject(int parameterIndex) throws SQLException {
		 try {
			 Object obj = stmt.getObject(parameterIndex);
			 return wrapObject(obj);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 private Object wrapObject(Object obj) {
		 if (obj instanceof ResultSet) {
			 ResultSet rs = (ResultSet) obj;
			 DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
			 addResultSetTrace(poolableResultSet);
			 obj = poolableResultSet;
		 }
		 return obj;
	 }
	 public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getBigDecimal(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Object getObject(int parameterIndex, java.util.Map<String, Class<?>> map) throws SQLException {
		 try {
			 Object obj = stmt.getObject(parameterIndex, map);
			 return wrapObject(obj);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Ref getRef(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getRef(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Blob getBlob(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getBlob(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Clob getClob(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getClob(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Array getArray(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getArray(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Date getDate(int parameterIndex, Calendar cal) throws SQLException {
		 try {
			 return stmt.getDate(parameterIndex, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Time getTime(int parameterIndex, Calendar cal) throws SQLException {
		 try {
			 return stmt.getTime(parameterIndex, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException {
		 try {
			 return stmt.getTimestamp(parameterIndex, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {
		 try {
			 stmt.registerOutParameter(parameterIndex, sqlType, typeName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void registerOutParameter(String parameterName, int sqlType) throws SQLException {
		 try {
			 stmt.registerOutParameter(parameterName, sqlType);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {
		 try {
			 stmt.registerOutParameter(parameterName, sqlType, scale);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {
		 try {
			 stmt.registerOutParameter(parameterName, sqlType, typeName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.net.URL getURL(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getURL(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setURL(String parameterName, java.net.URL val) throws SQLException {
		 try {
			 stmt.setURL(parameterName, val);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNull(String parameterName, int sqlType) throws SQLException {
		 try {
			 stmt.setNull(parameterName, sqlType);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBoolean(String parameterName, boolean x) throws SQLException {
		 try {
			 stmt.setBoolean(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setByte(String parameterName, byte x) throws SQLException {
		 try {
			 stmt.setByte(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setShort(String parameterName, short x) throws SQLException {
		 try {
			 stmt.setShort(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setInt(String parameterName, int x) throws SQLException {
		 try {
			 stmt.setInt(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setLong(String parameterName, long x) throws SQLException {
		 try {
			 stmt.setLong(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setFloat(String parameterName, float x) throws SQLException {
		 try {
			 stmt.setFloat(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setDouble(String parameterName, double x) throws SQLException {
		 try {
			 stmt.setDouble(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {
		 try {
			 stmt.setBigDecimal(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setString(String parameterName, String x) throws SQLException {
		 try {
			 stmt.setString(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBytes(String parameterName, byte x[]) throws SQLException {
		 try {
			 stmt.setBytes(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setDate(String parameterName, java.sql.Date x) throws SQLException {
		 try {
			 stmt.setDate(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setTime(String parameterName, java.sql.Time x) throws SQLException {
		 try {
			 stmt.setTime(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {
		 try {
			 stmt.setTimestamp(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
		 try {
			 stmt.setAsciiStream(parameterName, x, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
		 try {
			 stmt.setBinaryStream(parameterName, x, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {
		 try {
			 stmt.setObject(parameterName, x, targetSqlType, scale);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {
		 try {
			 stmt.setObject(parameterName, x, targetSqlType);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setObject(String parameterName, Object x) throws SQLException {
		 try {
			 stmt.setObject(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {
		 try {
			 stmt.setCharacterStream(parameterName, reader, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {
		 try {
			 stmt.setDate(parameterName, x, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {
		 try {
			 stmt.setTime(parameterName, x, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {
		 try {
			 stmt.setTimestamp(parameterName, x, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {
		 try {
			 stmt.setNull(parameterName, sqlType, typeName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public String getString(String parameterName) throws SQLException {
		 try {
			 return stmt.getString(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public boolean getBoolean(String parameterName) throws SQLException {
		 try {
			 return stmt.getBoolean(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public byte getByte(String parameterName) throws SQLException {
		 try {
			 return stmt.getByte(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public short getShort(String parameterName) throws SQLException {
		 try {
			 return stmt.getShort(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public int getInt(String parameterName) throws SQLException {
		 try {
			 return stmt.getInt(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public long getLong(String parameterName) throws SQLException {
		 try {
			 return stmt.getLong(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public float getFloat(String parameterName) throws SQLException {
		 try {
			 return stmt.getFloat(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public double getDouble(String parameterName) throws SQLException {
		 try {
			 return stmt.getDouble(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public byte[] getBytes(String parameterName) throws SQLException {
		 try {
			 return stmt.getBytes(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Date getDate(String parameterName) throws SQLException {
		 try {
			 return stmt.getDate(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Time getTime(String parameterName) throws SQLException {
		 try {
			 return stmt.getTime(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {
		 try {
			 return stmt.getTimestamp(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Object getObject(String parameterName) throws SQLException {
		 try {
			 Object obj = stmt.getObject(parameterName);
			 return wrapObject(obj);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public BigDecimal getBigDecimal(String parameterName) throws SQLException {
		 try {
			 return stmt.getBigDecimal(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Object getObject(String parameterName, java.util.Map<String, Class<?>> map) throws SQLException {
		 try {
			 Object obj = stmt.getObject(parameterName, map);
			 return wrapObject(obj);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Ref getRef(String parameterName) throws SQLException {
		 try {
			 return stmt.getRef(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Blob getBlob(String parameterName) throws SQLException {
		 try {
			 return stmt.getBlob(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Clob getClob(String parameterName) throws SQLException {
		 try {
			 return stmt.getClob(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public Array getArray(String parameterName) throws SQLException {
		 try {
			 return stmt.getArray(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {
		 try {
			 return stmt.getDate(parameterName, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {
		 try {
			 return stmt.getTime(parameterName, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {
		 try {
			 return stmt.getTimestamp(parameterName, cal);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.net.URL getURL(String parameterName) throws SQLException {
		 try {
			 return stmt.getURL(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public RowId getRowId(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getRowId(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public RowId getRowId(String parameterName) throws SQLException {
		 try {
			 return stmt.getRowId(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setRowId(String parameterName, RowId x) throws SQLException {
		 try {
			 stmt.setRowId(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNString(String parameterName, String value) throws SQLException {
		 try {
			 stmt.setNString(parameterName, value);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {
		 try {
			 stmt.setNCharacterStream(parameterName, value, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNClob(String parameterName, NClob value) throws SQLException {
		 try {
			 stmt.setNClob(parameterName, value);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setClob(String parameterName, Reader reader, long length) throws SQLException {
		 try {
			 stmt.setClob(parameterName, reader, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
		 try {
			 stmt.setBlob(parameterName, inputStream, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNClob(String parameterName, Reader reader, long length) throws SQLException {
		 try {
			 stmt.setNClob(parameterName, reader, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public NClob getNClob(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getNClob(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public NClob getNClob(String parameterName) throws SQLException {
		 try {
			 return stmt.getNClob(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
		 try {
			 stmt.setSQLXML(parameterName, xmlObject);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public SQLXML getSQLXML(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getSQLXML(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public SQLXML getSQLXML(String parameterName) throws SQLException {
		 try {
			 return stmt.getSQLXML(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public String getNString(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getNString(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public String getNString(String parameterName) throws SQLException {
		 try {
			 return stmt.getNString(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getNCharacterStream(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {
		 try {
			 return stmt.getNCharacterStream(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {
		 try {
			 return stmt.getCharacterStream(parameterIndex);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public java.io.Reader getCharacterStream(String parameterName) throws SQLException {
		 try {
			 return stmt.getCharacterStream(parameterName);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBlob(String parameterName, Blob x) throws SQLException {
		 try {
			 stmt.setBlob(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setClob(String parameterName, Clob x) throws SQLException {
		 try {
			 stmt.setClob(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {
		 try {
			 stmt.setAsciiStream(parameterName, x, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {
		 try {
			 stmt.setBinaryStream(parameterName, x, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {
		 try {
			 stmt.setCharacterStream(parameterName, reader, length);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {
		 try {
			 stmt.setAsciiStream(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {
		 try {
			 stmt.setBinaryStream(parameterName, x);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {
		 try {
			 stmt.setCharacterStream(parameterName, reader);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNCharacterStream(String parameterName, Reader value) throws SQLException {
		 try {
			 stmt.setNCharacterStream(parameterName, value);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setClob(String parameterName, Reader reader) throws SQLException {
		 try {
			 stmt.setClob(parameterName, reader);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setBlob(String parameterName, InputStream inputStream) throws SQLException {
		 try {
			 stmt.setBlob(parameterName, inputStream);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public void setNClob(String parameterName, Reader reader) throws SQLException {
		 try {
			 stmt.setNClob(parameterName, reader);
		 }
		 catch (Throwable t) {
			 throw checkException(t);
		 }
	 }
	 public <T> T getObject(int parameterIndex, Class<T> type) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T getObject(String parameterName, Class<T> type) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T unwrap(Class<T> iface) throws SQLException {
		 if (iface == CallableStatement.class || iface == PreparedStatement.class) {
			 if (stmt instanceof CallableStatementProxy) {
				 return stmt.unwrap(iface);
			 }
			 return (T) stmt;
		 }
		 return super.unwrap(iface);
	 }
}",1,1,0,0
"public class GraphTransformer {
	 private List gxf;
	 private TryStacks ts = null;
	 private CodeExceptionGen[] handlers;
	 private CodeExceptionGen [] ceg = null;
	 private InstructionList ilist = null;
	 public GraphTransformer ( List gxf ) {
		 this.gxf = gxf;
	 }
	 private void zapGraphXformer ( GraphXformer gxf, Exception e) {
		 System.err.println(""WARNING: exception in "" + "": transformation will not be applied"" );
		 e.printStackTrace();
		 gxf = null;
	 }
	 public InstructionList xform (ClassGen clazz, MethodGen method ) {
		 if (method == null) {
			 throw new IllegalArgumentException(""null method"");
		 }
		 ControlFlowGraph graph = makeGraph(clazz, method);
		 GraphXformer [] xf = new GraphXformer[ gxf.size() ];
		 for (int i = 0;
		 i < gxf.size();
		 i++) {
			 try {
				 xf[i] = (GraphXformer) ( (gxf.get(i)).getClass().newInstance() );
			 }
			 catch (IllegalAccessException e ) {
				 zapGraphXformer (xf[i], e);
			 }
			 catch (InstantiationException e ) {
				 zapGraphXformer (xf[i], e);
			 }
			 if (xf[i] != null && graph != null) {
				 xf[i].xform(clazz, method, graph);
			 }
		 }
		 if (graph == null) {
			 return null;
		 }
		 BytecodeCollector bc = collapseGraph(graph);
		 ilist = bc.getInstructionList();
		 if (ilist == null) {
			 return null;
		 }
		 if (ts == null) {
			 ceg = null;
		 }
		 else {
			 ceg = bc.getCEGs(ts.getCatchData());
			 if (ceg.length != handlers.length) {
				 System.out.println( ""GraphTransformer.xform WARNING - PROBABLE INTERNAL ERROR:\n method had "" + handlers.length + "" exception handlers, but after graph transformation "" + ceg.length);
			 }
		 }
		 return ilist;
	 }
	 public CodeExceptionGen[] getExceptionHandlers() {
		 if (ilist != null && ceg != null) {
			 return ceg;
		 }
		 else {
			 return new CodeExceptionGen[0];
		 }
	 }
	 final protected ControlFlowGraph makeGraph ( ClassGen clazz, MethodGen method ) {
		 SortedBlocks blox = new SortedBlocks();
		 handlers = method.getExceptionHandlers();
		 ControlFlowGraph cfg = new ControlFlowGraph();
		 ControlFlowGraph currGraph = cfg;
		 Edge e = cfg.getEntry().getEdge();
		 ts = null;
		 boolean startBlock = false;
		 CodeVertex currV = null;
		 LineNumberTable lineTab = method.getLineNumberTable ( clazz.getConstantPool() );
		 if (handlers.length > 0) {
			 ts = new TryStacks (handlers, blox, cfg);
		 }
		 if (blox.exists(0)) {
			 currV = blox.get(0);
		 }
		 else {
			 currV = blox.find (0, currGraph, e);
		 }
		 if (lineTab != null) {
			 currV.setStartLine( lineTab.getSourceLine(0) );
		 }
		 e = currV.getEdge();
		 currGraph = (ControlFlowGraph) currV.getGraph();
		 InstructionList iList = method.getInstructionList();
		 InstructionHandle currHandle = iList.getStart();
		 Instruction inst = currHandle.getInstruction();
		 int pos = currHandle.getPosition();
		 InstructionList vIList = currV.getInstructionList();
		 while (currHandle != null) {
			 if (startBlock) {
				 startBlock = false;
				 if (e == null) {
					 if ( !blox.exists(pos) ) {
						 currV = new CodeVertex (currGraph, pos);
					 }
					 else {
						 currV = blox.get(pos);
					 }
				 }
				 else {
					 currV = blox.find(pos, currGraph, e);
				 }
				 if (lineTab != null) {
					 currV.setStartLine( lineTab.getSourceLine(pos) );
				 }
				 e = currV.getEdge();
				 currGraph = (ControlFlowGraph) currV.getGraph();
				 vIList = currV.getInstructionList();
			 }
			 if (inst instanceof GotoInstruction) {
				 Edge otherEdge = currV.makeBinary();
				 currV.setConnInst(inst);
				 int tpos = ((GotoInstruction)inst).getTarget().getPosition();
				 int endTry;
				 if (ts == null) {
					 endTry = -1;
				 }
				 else {
					 endTry= ts.getEndTry(currGraph);
				 }
				 if (endTry >= 0 && tpos > endTry) {
					 Exit currExit = currGraph.getExit();
					 otherEdge.setTarget(currExit);
					 if (!blox.exists(tpos)) {
						 Vertex vFinal;
						 for (vFinal = currExit;
						 vFinal.getTarget() instanceof Entry;
						 vFinal = vFinal.getTarget()) {
							 ;
						 }
						 blox.add (tpos, vFinal.getEdge());
					 }
				 }
				 else {
					 blox.find (tpos, currGraph, otherEdge);
				 }
				 startBlock = true;
			 }
			 else if (inst instanceof IfInstruction || inst instanceof JSR ) {
				 Edge otherEdge = currV.makeBinary();
				 currV.setConnInst(inst);
				 int tpos = ((BranchInstruction)inst).getTarget().getPosition();
				 blox.find(tpos, currGraph, otherEdge);
				 startBlock = true;
			 }
			 else if (inst instanceof ReturnInstruction || inst instanceof RET) {
				 currV.setConnInst(inst);
				 e = null;
				 startBlock = true;
			 }
			 else if (inst instanceof InvokeInstruction) {
				 currV.setConnInst(inst);
				 startBlock = true;
			 }
			 else if (inst instanceof Select) {
				 InstructionHandle[] targets = ((Select)inst).getTargets();
				 ComplexConnector conn = currV.makeComplex(targets.length);
				 currV.setConnInst(inst);
				 for (int i = 0;
				 i < targets.length;
				 i++) {
					 int tpos = targets[i].getPosition();
					 blox.find(tpos, currGraph, conn.getEdge(i));
				 }
				 InstructionHandle theDefault = ((Select)inst).getTarget();
				 if (theDefault != null) {
					 blox.find ( theDefault.getPosition(), currGraph, conn.getEdge());
				 }
				 e = null;
				 startBlock = true;
			 }
			 else if (inst instanceof ExceptionThrower) {
				 currV.setConnInst(inst);
				 startBlock = true;
			 }
			 else {
				 vIList.append(inst);
			 }
			 InstructionHandle nextHandle = currHandle.getNext();
			 if (nextHandle != null) {
				 if (hasInbound(nextHandle)) {
					 startBlock = true;
				 }
			 }
			 if (startBlock == true) {
				 if (lineTab != null) {
					 currV.setEndLine( lineTab.getSourceLine(0) );
				 }
			 }
			 currHandle = nextHandle;
			 if (currHandle != null) {
				 pos = currHandle.getPosition();
				 inst = currHandle.getInstruction();
			 }
		 }
		 return cfg;
	 }
	 final public static boolean hasInbound (InstructionHandle ih ) {
		 if (ih.hasTargeters()) {
			 InstructionTargeter targeters[] = ih.getTargeters();
			 for (int j = 0;
			 j < targeters.length;
			 j++) {
				 if (targeters[j] instanceof BranchInstruction) {
					 return true;
				 }
				 if (targeters[j] instanceof CodeExceptionGen) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 final protected BytecodeCollector collapseGraph(ControlFlowGraph graph) {
		 BytecodeCollector theMan = new BytecodeCollector();
		 new Walker().visit(graph, theMan);
		 return theMan;
	 }
 }",1,0,0,0
"public class Parser{
	 final static int CLEAR_TI_MASK = 0xFFFF, TI_AFTER_EOL = 1 << 16, TI_CHECK_LABEL = 1 << 17;
	 CompilerEnvirons compilerEnv;
	 private ErrorReporter errorReporter;
	 private String sourceURI;
	 boolean calledByCompileFunction;
	 private TokenStream ts;
	 private int currentFlaggedToken;
	 private int syntaxErrorCount;
	 private IRFactory nf;
	 private int nestingOfFunction;
	 private Decompiler decompiler;
	 private String encodedSource;
	 ScriptOrFnNode currentScriptOrFn;
	 private int nestingOfWith;
	 private Hashtable labelSet;
	 private ObjArray loopSet;
	 private ObjArray loopAndSwitchSet;
	 private boolean hasReturnValue;
	 private int functionEndFlags;
	 private static class ParserException extends RuntimeException {
		 static final long serialVersionUID = 5882582646773765630L;
	 }
	 public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter) {
		 this.compilerEnv = compilerEnv;
		 this.errorReporter = errorReporter;
	 }
	 protected Decompiler createDecompiler(CompilerEnvirons compilerEnv) {
		 return new Decompiler();
	 }
	 void addStrictWarning(String messageId, String messageArg) {
		 if (compilerEnv.isStrictMode()) addWarning(messageId, messageArg);
	 }
	 void addWarning(String messageId, String messageArg) {
		 String message = ScriptRuntime.getMessage1(messageId, messageArg);
		 if (compilerEnv.reportWarningAsError()) {
			 ++syntaxErrorCount;
			 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
		 }
		 else errorReporter.warning(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 void addError(String messageId) {
		 ++syntaxErrorCount;
		 String message = ScriptRuntime.getMessage0(messageId);
		 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 void addError(String messageId, String messageArg) {
		 ++syntaxErrorCount;
		 String message = ScriptRuntime.getMessage1(messageId, messageArg);
		 errorReporter.error(message, sourceURI, ts.getLineno(), ts.getLine(), ts.getOffset());
	 }
	 RuntimeException reportError(String messageId) {
		 addError(messageId);
		 throw new ParserException();
	 }
	 private int peekToken() throws IOException {
		 int tt = currentFlaggedToken;
		 if (tt == Token.EOF) {
			 tt = ts.getToken();
			 if (tt == Token.EOL) {
				 do {
					 tt = ts.getToken();
				 }
				 while (tt == Token.EOL);
				 tt |= TI_AFTER_EOL;
			 }
			 currentFlaggedToken = tt;
		 }
		 return tt & CLEAR_TI_MASK;
	 }
	 private int peekFlaggedToken() throws IOException {
		 peekToken();
		 return currentFlaggedToken;
	 }
	 private void consumeToken() {
		 currentFlaggedToken = Token.EOF;
	 }
	 private int nextToken() throws IOException {
		 int tt = peekToken();
		 consumeToken();
		 return tt;
	 }
	 private int nextFlaggedToken() throws IOException {
		 peekToken();
		 int ttFlagged = currentFlaggedToken;
		 consumeToken();
		 return ttFlagged;
	 }
	 private boolean matchToken(int toMatch) throws IOException {
		 int tt = peekToken();
		 if (tt != toMatch) {
			 return false;
		 }
		 consumeToken();
		 return true;
	 }
	 private int peekTokenOrEOL() throws IOException {
		 int tt = peekToken();
		 if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {
			 tt = Token.EOL;
		 }
		 return tt;
	 }
	 private void setCheckForLabel() {
		 if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME) throw Kit.codeBug();
		 currentFlaggedToken |= TI_CHECK_LABEL;
	 }
	 private void mustMatchToken(int toMatch, String messageId) throws IOException, ParserException {
		 if (!matchToken(toMatch)) {
			 reportError(messageId);
		 }
	 }
	 private void mustHaveXML() {
		 if (!compilerEnv.isXmlAvailable()) {
			 reportError(""msg.XML.not.available"");
		 }
	 }
	 public String getEncodedSource() {
		 return encodedSource;
	 }
	 public boolean eof() {
		 return ts.eof();
	 }
	 boolean insideFunction() {
		 return nestingOfFunction != 0;
	 }
	 private Node enterLoop(Node loopLabel) {
		 Node loop = nf.createLoopNode(loopLabel, ts.getLineno());
		 if (loopSet == null) {
			 loopSet = new ObjArray();
			 if (loopAndSwitchSet == null) {
				 loopAndSwitchSet = new ObjArray();
			 }
		 }
		 loopSet.push(loop);
		 loopAndSwitchSet.push(loop);
		 return loop;
	 }
	 private void exitLoop() {
		 loopSet.pop();
		 loopAndSwitchSet.pop();
	 }
	 private Node enterSwitch(Node switchSelector, int lineno) {
		 Node switchNode = nf.createSwitch(switchSelector, lineno);
		 if (loopAndSwitchSet == null) {
			 loopAndSwitchSet = new ObjArray();
		 }
		 loopAndSwitchSet.push(switchNode);
		 return switchNode;
	 }
	 private void exitSwitch() {
		 loopAndSwitchSet.pop();
	 }
	 public ScriptOrFnNode parse(String sourceString, String sourceURI, int lineno) {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, null, sourceString, lineno);
		 try {
			 return parse();
		 }
		 catch (IOException ex) {
			 throw new IllegalStateException();
		 }
	 }
	 public ScriptOrFnNode parse(Reader sourceReader, String sourceURI, int lineno) throws IOException {
		 this.sourceURI = sourceURI;
		 this.ts = new TokenStream(this, sourceReader, null, lineno);
		 return parse();
	 }
	 private ScriptOrFnNode parse() throws IOException {
		 this.decompiler = createDecompiler(compilerEnv);
		 this.nf = new IRFactory(this);
		 currentScriptOrFn = nf.createScript();
		 int sourceStartOffset = decompiler.getCurrentOffset();
		 this.encodedSource = null;
		 decompiler.addToken(Token.SCRIPT);
		 this.currentFlaggedToken = Token.EOF;
		 this.syntaxErrorCount = 0;
		 int baseLineno = ts.getLineno();
		 Node pn = nf.createLeaf(Token.BLOCK);
		 try {
			 for (;
			;
			) {
				 int tt = peekToken();
				 if (tt <= Token.EOF) {
					 break;
				 }
				 Node n;
				 if (tt == Token.FUNCTION) {
					 consumeToken();
					 try {
						 n = function(calledByCompileFunction ? FunctionNode.FUNCTION_EXPRESSION : FunctionNode.FUNCTION_STATEMENT);
					 }
					 catch (ParserException e) {
						 break;
					 }
				 }
				 else {
					 n = statement();
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (StackOverflowError ex) {
			 String msg = ScriptRuntime.getMessage0( ""msg.too.deep.parser.recursion"");
			 throw Context.reportRuntimeError(msg, sourceURI, ts.getLineno(), null, 0);
		 }
		 if (this.syntaxErrorCount != 0) {
			 String msg = String.valueOf(this.syntaxErrorCount);
			 msg = ScriptRuntime.getMessage1(""msg.got.syntax.errors"", msg);
			 throw errorReporter.runtimeError(msg, sourceURI, baseLineno, null, 0);
		 }
		 currentScriptOrFn.setSourceName(sourceURI);
		 currentScriptOrFn.setBaseLineno(baseLineno);
		 currentScriptOrFn.setEndLineno(ts.getLineno());
		 int sourceEndOffset = decompiler.getCurrentOffset();
		 currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset);
		 nf.initScript(currentScriptOrFn, pn);
		 if (compilerEnv.isGeneratingSource()) {
			 encodedSource = decompiler.getEncodedSource();
		 }
		 this.decompiler = null;
		 return currentScriptOrFn;
	 }
	 private Node parseFunctionBody() throws IOException {
		 ++nestingOfFunction;
		 Node pn = nf.createBlock(ts.getLineno());
		 try {
			 bodyLoop: for (;
			;
			) {
				 Node n;
				 int tt = peekToken();
				 switch (tt) {
					 case Token.ERROR: case Token.EOF: case Token.RC: break bodyLoop;
					 case Token.FUNCTION: consumeToken();
					 n = function(FunctionNode.FUNCTION_STATEMENT);
					 break;
					 default: n = statement();
					 break;
				 }
				 nf.addChildToBack(pn, n);
			 }
		 }
		 catch (ParserException e) {
		 }
		 finally {
			 --nestingOfFunction;
		 }
		 return pn;
	 }
	 private Node function(int functionType) throws IOException, ParserException {
		 int syntheticType = functionType;
		 int baseLineno = ts.getLineno();
		 int functionSourceStart = decompiler.markFunctionStart(functionType);
		 String name;
		 Node memberExprNode = null;
		 if (matchToken(Token.NAME)) {
			 name = ts.getString();
			 decompiler.addName(name);
			 if (!matchToken(Token.LP)) {
				 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
					 Node memberExprHead = nf.createName(name);
					 name = """";
					 memberExprNode = memberExprTail(false, memberExprHead);
				 }
				 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
			 }
		 }
		 else if (matchToken(Token.LP)) {
			 name = """";
		 }
		 else {
			 name = """";
			 if (compilerEnv.isAllowMemberExprAsFunctionName()) {
				 memberExprNode = memberExpr(false);
			 }
			 mustMatchToken(Token.LP, ""msg.no.paren.parms"");
		 }
		 if (memberExprNode != null) {
			 syntheticType = FunctionNode.FUNCTION_EXPRESSION;
		 }
		 boolean nested = insideFunction();
		 FunctionNode fnNode = nf.createFunction(name);
		 if (nested || nestingOfWith > 0) {
			 fnNode.itsIgnoreDynamicScope = true;
		 }
		 int functionIndex = currentScriptOrFn.addFunction(fnNode);
		 int functionSourceEnd;
		 ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;
		 currentScriptOrFn = fnNode;
		 int savedNestingOfWith = nestingOfWith;
		 nestingOfWith = 0;
		 Hashtable savedLabelSet = labelSet;
		 labelSet = null;
		 ObjArray savedLoopSet = loopSet;
		 loopSet = null;
		 ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;
		 loopAndSwitchSet = null;
		 boolean savedHasReturnValue = hasReturnValue;
		 int savedFunctionEndFlags = functionEndFlags;
		 Node body;
		 try {
			 decompiler.addToken(Token.LP);
			 if (!matchToken(Token.RP)) {
				 boolean first = true;
				 do {
					 if (!first) decompiler.addToken(Token.COMMA);
					 first = false;
					 mustMatchToken(Token.NAME, ""msg.no.parm"");
					 String s = ts.getString();
					 if (fnNode.hasParamOrVar(s)) {
						 addWarning(""msg.dup.parms"", s);
					 }
					 fnNode.addParam(s);
					 decompiler.addName(s);
				 }
				 while (matchToken(Token.COMMA));
				 mustMatchToken(Token.RP, ""msg.no.paren.after.parms"");
			 }
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.LC, ""msg.no.brace.body"");
			 decompiler.addEOL(Token.LC);
			 body = parseFunctionBody();
			 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
			 if (compilerEnv.isStrictMode() && !body.hasConsistentReturnUsage()) {
				 String msg = name.length() > 0 ? ""msg.no.return.value"" : ""msg.anon.no.return.value"";
				 addStrictWarning(msg, name);
			 }
			 decompiler.addToken(Token.RC);
			 functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 decompiler.addToken(Token.EOL);
			 }
		 }
		 finally {
			 hasReturnValue = savedHasReturnValue;
			 functionEndFlags = savedFunctionEndFlags;
			 loopAndSwitchSet = savedLoopAndSwitchSet;
			 loopSet = savedLoopSet;
			 labelSet = savedLabelSet;
			 nestingOfWith = savedNestingOfWith;
			 currentScriptOrFn = savedScriptOrFn;
		 }
		 fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);
		 fnNode.setSourceName(sourceURI);
		 fnNode.setBaseLineno(baseLineno);
		 fnNode.setEndLineno(ts.getLineno());
		 if (name != null) {
			 int index = currentScriptOrFn.getParamOrVarIndex(name);
			 if (index >= 0 && index < currentScriptOrFn.getParamCount()) addStrictWarning(""msg.var.hides.arg"", name);
		 }
		 Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
		 if (memberExprNode != null) {
			 pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);
			 if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
				 pn = nf.createExprStatementNoReturn(pn, baseLineno);
			 }
		 }
		 return pn;
	 }
	 private Node statements() throws IOException {
		 Node pn = nf.createBlock(ts.getLineno());
		 int tt;
		 while((tt = peekToken()) > Token.EOF && tt != Token.RC) {
			 nf.addChildToBack(pn, statement());
		 }
		 return pn;
	 }
	 private Node condition() throws IOException, ParserException {
		 mustMatchToken(Token.LP, ""msg.no.paren.cond"");
		 decompiler.addToken(Token.LP);
		 Node pn = expr(false);
		 mustMatchToken(Token.RP, ""msg.no.paren.after.cond"");
		 decompiler.addToken(Token.RP);
		 if (pn.getProp(Node.PARENTHESIZED_PROP) == null && (pn.getType() == Token.SETNAME || pn.getType() == Token.SETPROP || pn.getType() == Token.SETELEM)) {
			 addStrictWarning(""msg.equal.as.assign"", """");
		 }
		 return pn;
	 }
	 private Node matchJumpLabelName() throws IOException, ParserException {
		 Node label = null;
		 int tt = peekTokenOrEOL();
		 if (tt == Token.NAME) {
			 consumeToken();
			 String name = ts.getString();
			 decompiler.addName(name);
			 if (labelSet != null) {
				 label = (Node)labelSet.get(name);
			 }
			 if (label == null) {
				 reportError(""msg.undef.label"");
			 }
		 }
		 return label;
	 }
	 private Node statement() throws IOException {
		 try {
			 Node pn = statementHelper(null);
			 if (pn != null) {
				 if (compilerEnv.isStrictMode() && !pn.hasSideEffects()) addStrictWarning(""msg.no.side.effects"", """");
				 return pn;
			 }
		 }
		 catch (ParserException e) {
		 }
		 int lineno = ts.getLineno();
		 guessingStatementEnd: for (;
		;
		) {
			 int tt = peekTokenOrEOL();
			 consumeToken();
			 switch (tt) {
				 case Token.ERROR: case Token.EOF: case Token.EOL: case Token.SEMI: break guessingStatementEnd;
			 }
		 }
		 return nf.createExprStatement(nf.createName(""error""), lineno);
	 }
	 private Node statementHelper(Node statementLabel) throws IOException, ParserException {
		 Node pn = null;
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.IF: {
				 consumeToken();
				 decompiler.addToken(Token.IF);
				 int lineno = ts.getLineno();
				 Node cond = condition();
				 decompiler.addEOL(Token.LC);
				 Node ifTrue = statement();
				 Node ifFalse = null;
				 if (matchToken(Token.ELSE)) {
					 decompiler.addToken(Token.RC);
					 decompiler.addToken(Token.ELSE);
					 decompiler.addEOL(Token.LC);
					 ifFalse = statement();
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createIf(cond, ifTrue, ifFalse, lineno);
				 return pn;
			 }
			 case Token.SWITCH: {
				 consumeToken();
				 decompiler.addToken(Token.SWITCH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.switch"");
				 decompiler.addToken(Token.LP);
				 pn = enterSwitch(expr(false), lineno);
				 try {
					 mustMatchToken(Token.RP, ""msg.no.paren.after.switch"");
					 decompiler.addToken(Token.RP);
					 mustMatchToken(Token.LC, ""msg.no.brace.switch"");
					 decompiler.addEOL(Token.LC);
					 boolean hasDefault = false;
					 switchLoop: for (;
					;
					) {
						 tt = nextToken();
						 Node caseExpression;
						 switch (tt) {
							 case Token.RC: break switchLoop;
							 case Token.CASE: decompiler.addToken(Token.CASE);
							 caseExpression = expr(false);
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 case Token.DEFAULT: if (hasDefault) {
								 reportError(""msg.double.switch.default"");
							 }
							 decompiler.addToken(Token.DEFAULT);
							 hasDefault = true;
							 caseExpression = null;
							 mustMatchToken(Token.COLON, ""msg.no.colon.case"");
							 decompiler.addEOL(Token.COLON);
							 break;
							 default: reportError(""msg.bad.switch"");
							 break switchLoop;
						 }
						 Node block = nf.createLeaf(Token.BLOCK);
						 while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) {
							 nf.addChildToBack(block, statement());
						 }
						 nf.addSwitchCase(pn, caseExpression, block);
					 }
					 decompiler.addEOL(Token.RC);
					 nf.closeSwitch(pn);
				 }
				 finally {
					 exitSwitch();
				 }
				 return pn;
			 }
			 case Token.WHILE: {
				 consumeToken();
				 decompiler.addToken(Token.WHILE);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node cond = condition();
					 decompiler.addEOL(Token.LC);
					 Node body = statement();
					 decompiler.addEOL(Token.RC);
					 pn = nf.createWhile(loop, cond, body);
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.DO: {
				 consumeToken();
				 decompiler.addToken(Token.DO);
				 decompiler.addEOL(Token.LC);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node body = statement();
					 decompiler.addToken(Token.RC);
					 mustMatchToken(Token.WHILE, ""msg.no.while.do"");
					 decompiler.addToken(Token.WHILE);
					 Node cond = condition();
					 pn = nf.createDoWhile(loop, body, cond);
				 }
				 finally {
					 exitLoop();
				 }
				 matchToken(Token.SEMI);
				 decompiler.addEOL(Token.SEMI);
				 return pn;
			 }
			 case Token.FOR: {
				 consumeToken();
				 boolean isForEach = false;
				 decompiler.addToken(Token.FOR);
				 Node loop = enterLoop(statementLabel);
				 try {
					 Node init;
					 Node cond;
					 Node incr = null;
					 Node body;
					 if (matchToken(Token.NAME)) {
						 decompiler.addName(ts.getString());
						 if (ts.getString().equals(""each"")) {
							 isForEach = true;
						 }
						 else {
							 reportError(""msg.no.paren.for"");
						 }
					 }
					 mustMatchToken(Token.LP, ""msg.no.paren.for"");
					 decompiler.addToken(Token.LP);
					 tt = peekToken();
					 if (tt == Token.SEMI) {
						 init = nf.createLeaf(Token.EMPTY);
					 }
					 else {
						 if (tt == Token.VAR) {
							 consumeToken();
							 init = variables(Token.FOR);
						 }
						 else {
							 init = expr(true);
						 }
					 }
					 if (matchToken(Token.IN)) {
						 decompiler.addToken(Token.IN);
						 cond = expr(false);
					 }
					 else {
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.SEMI) {
							 cond = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 cond = expr(false);
						 }
						 mustMatchToken(Token.SEMI, ""msg.no.semi.for.cond"");
						 decompiler.addToken(Token.SEMI);
						 if (peekToken() == Token.RP) {
							 incr = nf.createLeaf(Token.EMPTY);
						 }
						 else {
							 incr = expr(false);
						 }
					 }
					 mustMatchToken(Token.RP, ""msg.no.paren.for.ctrl"");
					 decompiler.addToken(Token.RP);
					 decompiler.addEOL(Token.LC);
					 body = statement();
					 decompiler.addEOL(Token.RC);
					 if (incr == null) {
						 pn = nf.createForIn(loop, init, cond, body, isForEach);
					 }
					 else {
						 pn = nf.createFor(loop, init, cond, incr, body);
					 }
				 }
				 finally {
					 exitLoop();
				 }
				 return pn;
			 }
			 case Token.TRY: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 Node tryblock;
				 Node catchblocks = null;
				 Node finallyblock = null;
				 decompiler.addToken(Token.TRY);
				 decompiler.addEOL(Token.LC);
				 tryblock = statement();
				 decompiler.addEOL(Token.RC);
				 catchblocks = nf.createLeaf(Token.BLOCK);
				 boolean sawDefaultCatch = false;
				 int peek = peekToken();
				 if (peek == Token.CATCH) {
					 while (matchToken(Token.CATCH)) {
						 if (sawDefaultCatch) {
							 reportError(""msg.catch.unreachable"");
						 }
						 decompiler.addToken(Token.CATCH);
						 mustMatchToken(Token.LP, ""msg.no.paren.catch"");
						 decompiler.addToken(Token.LP);
						 mustMatchToken(Token.NAME, ""msg.bad.catchcond"");
						 String varName = ts.getString();
						 decompiler.addName(varName);
						 Node catchCond = null;
						 if (matchToken(Token.IF)) {
							 decompiler.addToken(Token.IF);
							 catchCond = expr(false);
						 }
						 else {
							 sawDefaultCatch = true;
						 }
						 mustMatchToken(Token.RP, ""msg.bad.catchcond"");
						 decompiler.addToken(Token.RP);
						 mustMatchToken(Token.LC, ""msg.no.brace.catchblock"");
						 decompiler.addEOL(Token.LC);
						 nf.addChildToBack(catchblocks, nf.createCatch(varName, catchCond, statements(), ts.getLineno()));
						 mustMatchToken(Token.RC, ""msg.no.brace.after.body"");
						 decompiler.addEOL(Token.RC);
					 }
				 }
				 else if (peek != Token.FINALLY) {
					 mustMatchToken(Token.FINALLY, ""msg.try.no.catchfinally"");
				 }
				 if (matchToken(Token.FINALLY)) {
					 decompiler.addToken(Token.FINALLY);
					 decompiler.addEOL(Token.LC);
					 finallyblock = statement();
					 decompiler.addEOL(Token.RC);
				 }
				 pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno);
				 return pn;
			 }
			 case Token.THROW: {
				 consumeToken();
				 if (peekTokenOrEOL() == Token.EOL) {
					 reportError(""msg.bad.throw.eol"");
				 }
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.THROW);
				 pn = nf.createThrow(expr(false), lineno);
				 break;
			 }
			 case Token.BREAK: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.BREAK);
				 Node breakStatement = matchJumpLabelName();
				 if (breakStatement == null) {
					 if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {
						 reportError(""msg.bad.break"");
						 return null;
					 }
					 breakStatement = (Node)loopAndSwitchSet.peek();
				 }
				 pn = nf.createBreak(breakStatement, lineno);
				 break;
			 }
			 case Token.CONTINUE: {
				 consumeToken();
				 int lineno = ts.getLineno();
				 decompiler.addToken(Token.CONTINUE);
				 Node loop;
				 Node label = matchJumpLabelName();
				 if (label == null) {
					 if (loopSet == null || loopSet.size() == 0) {
						 reportError(""msg.continue.outside"");
						 return null;
					 }
					 loop = (Node)loopSet.peek();
				 }
				 else {
					 loop = nf.getLabelLoop(label);
					 if (loop == null) {
						 reportError(""msg.continue.nonloop"");
						 return null;
					 }
				 }
				 pn = nf.createContinue(loop, lineno);
				 break;
			 }
			 case Token.WITH: {
				 consumeToken();
				 decompiler.addToken(Token.WITH);
				 int lineno = ts.getLineno();
				 mustMatchToken(Token.LP, ""msg.no.paren.with"");
				 decompiler.addToken(Token.LP);
				 Node obj = expr(false);
				 mustMatchToken(Token.RP, ""msg.no.paren.after.with"");
				 decompiler.addToken(Token.RP);
				 decompiler.addEOL(Token.LC);
				 ++nestingOfWith;
				 Node body;
				 try {
					 body = statement();
				 }
				 finally {
					 --nestingOfWith;
				 }
				 decompiler.addEOL(Token.RC);
				 pn = nf.createWith(obj, body, lineno);
				 return pn;
			 }
			 case Token.CONST: case Token.VAR: {
				 consumeToken();
				 pn = variables(tt);
				 break;
			 }
			 case Token.RETURN: {
				 if (!insideFunction()) {
					 reportError(""msg.bad.return"");
				 }
				 consumeToken();
				 decompiler.addToken(Token.RETURN);
				 int lineno = ts.getLineno();
				 Node retExpr;
				 tt = peekTokenOrEOL();
				 switch (tt) {
					 case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null;
					 break;
					 default: retExpr = expr(false);
					 hasReturnValue = true;
				 }
				 pn = nf.createReturn(retExpr, lineno);
				 if (retExpr == null) {
					 if (functionEndFlags == Node.END_RETURNS_VALUE) addStrictWarning(""msg.return.inconsistent"", """");
					 functionEndFlags |= Node.END_RETURNS;
				 }
				 else {
					 if (functionEndFlags == Node.END_RETURNS) addStrictWarning(""msg.return.inconsistent"", """");
					 functionEndFlags |= Node.END_RETURNS_VALUE;
				 }
				 break;
			 }
			 case Token.LC: consumeToken();
			 if (statementLabel != null) {
				 decompiler.addToken(Token.LC);
			 }
			 pn = statements();
			 mustMatchToken(Token.RC, ""msg.no.brace.block"");
			 if (statementLabel != null) {
				 decompiler.addEOL(Token.RC);
			 }
			 return pn;
			 case Token.ERROR: case Token.SEMI: consumeToken();
			 pn = nf.createLeaf(Token.EMPTY);
			 return pn;
			 case Token.FUNCTION: {
				 consumeToken();
				 pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);
				 return pn;
			 }
			 case Token.DEFAULT : consumeToken();
			 mustHaveXML();
			 decompiler.addToken(Token.DEFAULT);
			 int nsLine = ts.getLineno();
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""xml""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName("" xml"");
			 if (!(matchToken(Token.NAME) && ts.getString().equals(""namespace""))) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addName("" namespace"");
			 if (!matchToken(Token.ASSIGN)) {
				 reportError(""msg.bad.namespace"");
			 }
			 decompiler.addToken(Token.ASSIGN);
			 Node expr = expr(false);
			 pn = nf.createDefaultNamespace(expr, nsLine);
			 break;
			 case Token.NAME: {
				 int lineno = ts.getLineno();
				 String name = ts.getString();
				 setCheckForLabel();
				 pn = expr(false);
				 if (pn.getType() != Token.LABEL) {
					 pn = nf.createExprStatement(pn, lineno);
				 }
				 else {
					 if (peekToken() != Token.COLON) Kit.codeBug();
					 consumeToken();
					 decompiler.addName(name);
					 decompiler.addEOL(Token.COLON);
					 if (labelSet == null) {
						 labelSet = new Hashtable();
					 }
					 else if (labelSet.containsKey(name)) {
						 reportError(""msg.dup.label"");
					 }
					 boolean firstLabel;
					 if (statementLabel == null) {
						 firstLabel = true;
						 statementLabel = pn;
					 }
					 else {
						 firstLabel = false;
					 }
					 labelSet.put(name, statementLabel);
					 try {
						 pn = statementHelper(statementLabel);
					 }
					 finally {
						 labelSet.remove(name);
					 }
					 if (firstLabel) {
						 pn = nf.createLabeledStatement(statementLabel, pn);
					 }
					 return pn;
				 }
				 break;
			 }
			 default: {
				 int lineno = ts.getLineno();
				 pn = expr(false);
				 pn = nf.createExprStatement(pn, lineno);
				 break;
			 }
		 }
		 int ttFlagged = peekFlaggedToken();
		 switch (ttFlagged & CLEAR_TI_MASK) {
			 case Token.SEMI: consumeToken();
			 break;
			 case Token.ERROR: case Token.EOF: case Token.RC: break;
			 default: if ((ttFlagged & TI_AFTER_EOL) == 0) {
				 reportError(""msg.no.semi.stmt"");
			 }
			 break;
		 }
		 decompiler.addEOL(Token.SEMI);
		 return pn;
	 }
	 private Node variables(int context) throws IOException, ParserException {
		 Node pn;
		 boolean first = true;
		 if (context == Token.CONST){
			 pn = nf.createVariables(Token.CONST, ts.getLineno());
			 decompiler.addToken(Token.CONST);
		 }
		 else {
			 pn = nf.createVariables(Token.VAR, ts.getLineno());
			 decompiler.addToken(Token.VAR);
		 }
		 for (;
		;
		) {
			 Node name;
			 Node init;
			 mustMatchToken(Token.NAME, ""msg.bad.var"");
			 String s = ts.getString();
			 if (!first) decompiler.addToken(Token.COMMA);
			 first = false;
			 decompiler.addName(s);
			 if (context == Token.CONST) {
				 if (!currentScriptOrFn.addConst(s)) {
					 if (currentScriptOrFn.addVar(s) != ScriptOrFnNode.DUPLICATE_CONST) addError(""msg.var.redecl"", s);
					 else addError(""msg.const.redecl"", s);
				 }
			 }
			 else {
				 int dupState = currentScriptOrFn.addVar(s);
				 if (dupState == ScriptOrFnNode.DUPLICATE_CONST) addError(""msg.const.redecl"", s);
				 else if (dupState == ScriptOrFnNode.DUPLICATE_PARAMETER) addStrictWarning(""msg.var.hides.arg"", s);
				 else if (dupState == ScriptOrFnNode.DUPLICATE_VAR) addStrictWarning(""msg.var.redecl"", s);
			 }
			 name = nf.createName(s);
			 if (matchToken(Token.ASSIGN)) {
				 decompiler.addToken(Token.ASSIGN);
				 init = assignExpr(context == Token.FOR);
				 nf.addChildToBack(name, init);
			 }
			 nf.addChildToBack(pn, name);
			 if (!matchToken(Token.COMMA)) break;
		 }
		 return pn;
	 }
	 private Node expr(boolean inForInit) throws IOException, ParserException {
		 Node pn = assignExpr(inForInit);
		 while (matchToken(Token.COMMA)) {
			 decompiler.addToken(Token.COMMA);
			 if (compilerEnv.isStrictMode() && !pn.hasSideEffects()) addStrictWarning(""msg.no.side.effects"", """");
			 pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node assignExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = condExpr(inForInit);
		 int tt = peekToken();
		 if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
			 consumeToken();
			 decompiler.addToken(tt);
			 pn = nf.createAssignment(tt, pn, assignExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node condExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = orExpr(inForInit);
		 if (matchToken(Token.HOOK)) {
			 decompiler.addToken(Token.HOOK);
			 Node ifTrue = assignExpr(false);
			 mustMatchToken(Token.COLON, ""msg.no.colon.cond"");
			 decompiler.addToken(Token.COLON);
			 Node ifFalse = assignExpr(inForInit);
			 return nf.createCondExpr(pn, ifTrue, ifFalse);
		 }
		 return pn;
	 }
	 private Node orExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = andExpr(inForInit);
		 if (matchToken(Token.OR)) {
			 decompiler.addToken(Token.OR);
			 pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node andExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitOrExpr(inForInit);
		 if (matchToken(Token.AND)) {
			 decompiler.addToken(Token.AND);
			 pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitOrExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitXorExpr(inForInit);
		 while (matchToken(Token.BITOR)) {
			 decompiler.addToken(Token.BITOR);
			 pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitXorExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = bitAndExpr(inForInit);
		 while (matchToken(Token.BITXOR)) {
			 decompiler.addToken(Token.BITXOR);
			 pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node bitAndExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = eqExpr(inForInit);
		 while (matchToken(Token.BITAND)) {
			 decompiler.addToken(Token.BITAND);
			 pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));
		 }
		 return pn;
	 }
	 private Node eqExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = relExpr(inForInit);
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: consumeToken();
				 int decompilerToken = tt;
				 int parseToken = tt;
				 if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {
					 switch (tt) {
						 case Token.EQ: parseToken = Token.SHEQ;
						 break;
						 case Token.NE: parseToken = Token.SHNE;
						 break;
						 case Token.SHEQ: decompilerToken = Token.EQ;
						 break;
						 case Token.SHNE: decompilerToken = Token.NE;
						 break;
					 }
				 }
				 decompiler.addToken(decompilerToken);
				 pn = nf.createBinary(parseToken, pn, relExpr(inForInit));
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node relExpr(boolean inForInit) throws IOException, ParserException {
		 Node pn = shiftExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.IN: if (inForInit) break;
				 case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, shiftExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node shiftExpr() throws IOException, ParserException {
		 Node pn = addExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.LSH: case Token.URSH: case Token.RSH: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, addExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node addExpr() throws IOException, ParserException {
		 Node pn = mulExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 if (tt == Token.ADD || tt == Token.SUB) {
				 consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, mulExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node mulExpr() throws IOException, ParserException {
		 Node pn = unaryExpr();
		 for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.MUL: case Token.DIV: case Token.MOD: consumeToken();
				 decompiler.addToken(tt);
				 pn = nf.createBinary(tt, pn, unaryExpr());
				 continue;
			 }
			 break;
		 }
		 return pn;
	 }
	 private Node unaryExpr() throws IOException, ParserException {
		 int tt;
		 tt = peekToken();
		 switch(tt) {
			 case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createUnary(tt, unaryExpr());
			 case Token.ADD: consumeToken();
			 decompiler.addToken(Token.POS);
			 return nf.createUnary(Token.POS, unaryExpr());
			 case Token.SUB: consumeToken();
			 decompiler.addToken(Token.NEG);
			 return nf.createUnary(Token.NEG, unaryExpr());
			 case Token.INC: case Token.DEC: consumeToken();
			 decompiler.addToken(tt);
			 return nf.createIncDec(tt, false, memberExpr(true));
			 case Token.DELPROP: consumeToken();
			 decompiler.addToken(Token.DELPROP);
			 return nf.createUnary(Token.DELPROP, unaryExpr());
			 case Token.ERROR: consumeToken();
			 break;
			 case Token.LT: if (compilerEnv.isXmlAvailable()) {
				 consumeToken();
				 Node pn = xmlInitializer();
				 return memberExprTail(true, pn);
			 }
			 default: Node pn = memberExpr(true);
			 tt = peekTokenOrEOL();
			 if (tt == Token.INC || tt == Token.DEC) {
				 consumeToken();
				 decompiler.addToken(tt);
				 return nf.createIncDec(tt, true, pn);
			 }
			 return pn;
		 }
		 return nf.createName(""err"");
	 }
	 private Node xmlInitializer() throws IOException {
		 int tt = ts.getFirstXMLToken();
		 if (tt != Token.XML && tt != Token.XMLEND) {
			 reportError(""msg.syntax"");
			 return null;
		 }
		 Node pnXML = nf.createLeaf(Token.NEW);
		 String xml = ts.getString();
		 boolean fAnonymous = xml.trim().startsWith(""<>"");
		 Node pn = nf.createName(fAnonymous ? ""XMLList"" : ""XML"");
		 nf.addChildToBack(pnXML, pn);
		 pn = null;
		 Node expr;
		 for (;
		;
		tt = ts.getNextXMLToken()) {
			 switch (tt) {
				 case Token.XML: xml = ts.getString();
				 decompiler.addName(xml);
				 mustMatchToken(Token.LC, ""msg.syntax"");
				 decompiler.addToken(Token.LC);
				 expr = (peekToken() == Token.RC) ? nf.createString("""") : expr(false);
				 mustMatchToken(Token.RC, ""msg.syntax"");
				 decompiler.addToken(Token.RC);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 if (ts.isXMLAttribute()) {
					 expr = nf.createUnary(Token.ESCXMLATTR, expr);
					 Node prepend = nf.createBinary(Token.ADD, nf.createString(""\""""), expr);
					 expr = nf.createBinary(Token.ADD, prepend, nf.createString(""\""""));
				 }
				 else {
					 expr = nf.createUnary(Token.ESCXMLTEXT, expr);
				 }
				 pn = nf.createBinary(Token.ADD, pn, expr);
				 break;
				 case Token.XMLEND: xml = ts.getString();
				 decompiler.addName(xml);
				 if (pn == null) {
					 pn = nf.createString(xml);
				 }
				 else {
					 pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));
				 }
				 nf.addChildToBack(pnXML, pn);
				 return pnXML;
				 default: reportError(""msg.syntax"");
				 return null;
			 }
		 }
	 }
	 private void argumentList(Node listNode) throws IOException, ParserException {
		 boolean matched;
		 matched = matchToken(Token.RP);
		 if (!matched) {
			 boolean first = true;
			 do {
				 if (!first) decompiler.addToken(Token.COMMA);
				 first = false;
				 nf.addChildToBack(listNode, assignExpr(false));
			 }
			 while (matchToken(Token.COMMA));
			 mustMatchToken(Token.RP, ""msg.no.paren.arg"");
		 }
		 decompiler.addToken(Token.RP);
	 }
	 private Node memberExpr(boolean allowCallSyntax) throws IOException, ParserException {
		 int tt;
		 Node pn;
		 tt = peekToken();
		 if (tt == Token.NEW) {
			 consumeToken();
			 decompiler.addToken(Token.NEW);
			 pn = nf.createCallOrNew(Token.NEW, memberExpr(false));
			 if (matchToken(Token.LP)) {
				 decompiler.addToken(Token.LP);
				 argumentList(pn);
			 }
			 tt = peekToken();
			 if (tt == Token.LC) {
				 nf.addChildToBack(pn, primaryExpr());
			 }
		 }
		 else {
			 pn = primaryExpr();
		 }
		 return memberExprTail(allowCallSyntax, pn);
	 }
	 private Node memberExprTail(boolean allowCallSyntax, Node pn) throws IOException, ParserException {
		 tailLoop: for (;
		;
		) {
			 int tt = peekToken();
			 switch (tt) {
				 case Token.DOT: case Token.DOTDOT: {
					 int memberTypeFlags;
					 String s;
					 consumeToken();
					 decompiler.addToken(tt);
					 memberTypeFlags = 0;
					 if (tt == Token.DOTDOT) {
						 mustHaveXML();
						 memberTypeFlags = Node.DESCENDANTS_FLAG;
					 }
					 if (!compilerEnv.isXmlAvailable()) {
						 mustMatchToken(Token.NAME, ""msg.no.name.after.dot"");
						 s = ts.getString();
						 decompiler.addName(s);
						 pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);
						 break;
					 }
					 tt = nextToken();
					 switch (tt) {
						 case Token.NAME: s = ts.getString();
						 decompiler.addName(s);
						 pn = propertyName(pn, s, memberTypeFlags);
						 break;
						 case Token.MUL: decompiler.addName(""*"");
						 pn = propertyName(pn, ""*"", memberTypeFlags);
						 break;
						 case Token.XMLATTR: decompiler.addToken(Token.XMLATTR);
						 pn = attributeAccess(pn, memberTypeFlags);
						 break;
						 default: reportError(""msg.no.name.after.dot"");
					 }
				 }
				 break;
				 case Token.DOTQUERY: consumeToken();
				 mustHaveXML();
				 decompiler.addToken(Token.DOTQUERY);
				 pn = nf.createDotQuery(pn, expr(false), ts.getLineno());
				 mustMatchToken(Token.RP, ""msg.no.paren"");
				 decompiler.addToken(Token.RP);
				 break;
				 case Token.LB: consumeToken();
				 decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, null, expr(false), 0);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 break;
				 case Token.LP: if (!allowCallSyntax) {
					 break tailLoop;
				 }
				 consumeToken();
				 decompiler.addToken(Token.LP);
				 pn = nf.createCallOrNew(Token.CALL, pn);
				 argumentList(pn);
				 break;
				 default: break tailLoop;
			 }
		 }
		 return pn;
	 }
	 private Node attributeAccess(Node pn, int memberTypeFlags) throws IOException {
		 memberTypeFlags |= Node.ATTRIBUTE_FLAG;
		 int tt = nextToken();
		 switch (tt) {
			 case Token.NAME: {
				 String s = ts.getString();
				 decompiler.addName(s);
				 pn = propertyName(pn, s, memberTypeFlags);
			 }
			 break;
			 case Token.MUL: decompiler.addName(""*"");
			 pn = propertyName(pn, ""*"", memberTypeFlags);
			 break;
			 case Token.LB: decompiler.addToken(Token.LB);
			 pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);
			 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
			 decompiler.addToken(Token.RB);
			 break;
			 default: reportError(""msg.no.name.after.xmlAttr"");
			 pn = nf.createPropertyGet(pn, null, ""?"", memberTypeFlags);
			 break;
		 }
		 return pn;
	 }
	 private Node propertyName(Node pn, String name, int memberTypeFlags) throws IOException, ParserException {
		 String namespace = null;
		 if (matchToken(Token.COLONCOLON)) {
			 decompiler.addToken(Token.COLONCOLON);
			 namespace = name;
			 int tt = nextToken();
			 switch (tt) {
				 case Token.NAME: name = ts.getString();
				 decompiler.addName(name);
				 break;
				 case Token.MUL: decompiler.addName(""*"");
				 name = ""*"";
				 break;
				 case Token.LB: decompiler.addToken(Token.LB);
				 pn = nf.createElementGet(pn, namespace, expr(false), memberTypeFlags);
				 mustMatchToken(Token.RB, ""msg.no.bracket.index"");
				 decompiler.addToken(Token.RB);
				 return pn;
				 default: reportError(""msg.no.name.after.coloncolon"");
				 name = ""?"";
			 }
		 }
		 pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);
		 return pn;
	 }
	 private Node primaryExpr() throws IOException, ParserException {
		 Node pn;
		 int ttFlagged = nextFlaggedToken();
		 int tt = ttFlagged & CLEAR_TI_MASK;
		 switch(tt) {
			 case Token.FUNCTION: return function(FunctionNode.FUNCTION_EXPRESSION);
			 case Token.LB: {
				 ObjArray elems = new ObjArray();
				 int skipCount = 0;
				 decompiler.addToken(Token.LB);
				 boolean after_lb_or_comma = true;
				 for (;
				;
				) {
					 tt = peekToken();
					 if (tt == Token.COMMA) {
						 consumeToken();
						 decompiler.addToken(Token.COMMA);
						 if (!after_lb_or_comma) {
							 after_lb_or_comma = true;
						 }
						 else {
							 elems.add(null);
							 ++skipCount;
						 }
					 }
					 else if (tt == Token.RB) {
						 consumeToken();
						 decompiler.addToken(Token.RB);
						 break;
					 }
					 else {
						 if (!after_lb_or_comma) {
							 reportError(""msg.no.bracket.arg"");
						 }
						 elems.add(assignExpr(false));
						 after_lb_or_comma = false;
					 }
				 }
				 return nf.createArrayLiteral(elems, skipCount);
			 }
			 case Token.LC: {
				 ObjArray elems = new ObjArray();
				 decompiler.addToken(Token.LC);
				 if (!matchToken(Token.RC)) {
					 boolean first = true;
					 commaloop: do {
						 Object property;
						 if (!first) decompiler.addToken(Token.COMMA);
						 else first = false;
						 tt = peekToken();
						 switch(tt) {
							 case Token.NAME: case Token.STRING: consumeToken();
							 String s = ts.getString();
							 if (tt == Token.NAME) {
								 if (s.equals(""get"") && peekToken() == Token.NAME) {
									 decompiler.addToken(Token.GET);
									 consumeToken();
									 s = ts.getString();
									 decompiler.addName(s);
									 property = ScriptRuntime.getIndexObject(s);
									 if (!getterSetterProperty(elems, property, true)) break commaloop;
									 break;
								 }
								 else if (s.equals(""set"") && peekToken() == Token.NAME) {
									 decompiler.addToken(Token.SET);
									 consumeToken();
									 s = ts.getString();
									 decompiler.addName(s);
									 property = ScriptRuntime.getIndexObject(s);
									 if (!getterSetterProperty(elems, property, false)) break commaloop;
									 break;
								 }
								 decompiler.addName(s);
							 }
							 else {
								 decompiler.addString(s);
							 }
							 property = ScriptRuntime.getIndexObject(s);
							 plainProperty(elems, property);
							 break;
							 case Token.NUMBER: consumeToken();
							 double n = ts.getNumber();
							 decompiler.addNumber(n);
							 property = ScriptRuntime.getIndexObject(n);
							 plainProperty(elems, property);
							 break;
							 case Token.RC: break commaloop;
							 default: reportError(""msg.bad.prop"");
							 break commaloop;
						 }
					 }
					 while (matchToken(Token.COMMA));
					 mustMatchToken(Token.RC, ""msg.no.brace.prop"");
				 }
				 decompiler.addToken(Token.RC);
				 return nf.createObjectLiteral(elems);
			 }
			 case Token.LP: decompiler.addToken(Token.LP);
			 pn = expr(false);
			 pn.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);
			 decompiler.addToken(Token.RP);
			 mustMatchToken(Token.RP, ""msg.no.paren"");
			 return pn;
			 case Token.XMLATTR: mustHaveXML();
			 decompiler.addToken(Token.XMLATTR);
			 pn = attributeAccess(null, 0);
			 return pn;
			 case Token.NAME: {
				 String name = ts.getString();
				 if ((ttFlagged & TI_CHECK_LABEL) != 0) {
					 if (peekToken() == Token.COLON) {
						 return nf.createLabel(ts.getLineno());
					 }
				 }
				 decompiler.addName(name);
				 if (compilerEnv.isXmlAvailable()) {
					 pn = propertyName(null, name, 0);
				 }
				 else {
					 pn = nf.createName(name);
				 }
				 return pn;
			 }
			 case Token.NUMBER: {
				 double n = ts.getNumber();
				 decompiler.addNumber(n);
				 return nf.createNumber(n);
			 }
			 case Token.STRING: {
				 String s = ts.getString();
				 decompiler.addString(s);
				 return nf.createString(s);
			 }
			 case Token.DIV: case Token.ASSIGN_DIV: {
				 ts.readRegExp(tt);
				 String flags = ts.regExpFlags;
				 ts.regExpFlags = null;
				 String re = ts.getString();
				 decompiler.addRegexp(re, flags);
				 int index = currentScriptOrFn.addRegexp(re, flags);
				 return nf.createRegExp(index);
			 }
			 case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: decompiler.addToken(tt);
			 return nf.createLeaf(tt);
			 case Token.RESERVED: reportError(""msg.reserved.id"");
			 break;
			 case Token.ERROR: break;
			 case Token.EOF: reportError(""msg.unexpected.eof"");
			 break;
			 default: reportError(""msg.syntax"");
			 break;
		 }
		 return null;
	 }
	 private void plainProperty(ObjArray elems, Object property) throws IOException {
		 mustMatchToken(Token.COLON, ""msg.no.colon.prop"");
		 decompiler.addToken(Token.OBJECTLIT);
		 elems.add(property);
		 elems.add(assignExpr(false));
	 }
	 private boolean getterSetterProperty(ObjArray elems, Object property, boolean isGetter) throws IOException {
		 Node f = function(FunctionNode.FUNCTION_EXPRESSION);
		 if (f.getType() != Token.FUNCTION) {
			 reportError(""msg.bad.prop"");
			 return false;
		 }
		 int fnIndex = f.getExistingIntProp(Node.FUNCTION_PROP);
		 FunctionNode fn = currentScriptOrFn.getFunctionNode(fnIndex);
		 if (fn.getFunctionName().length() != 0) {
			 reportError(""msg.bad.prop"");
			 return false;
		 }
		 elems.add(property);
		 if (isGetter) {
			 elems.add(nf.createUnary(Token.GET, f));
		 }
		 else {
			 elems.add(nf.createUnary(Token.SET, f));
		 }
		 return true;
	 }
}",1,0,0,0
"class ReportItemThemeState extends ReportElementState{
	protected ReportItemTheme element;
	ReportItemThemeState( ModuleParserHandler handler,DesignElement theContainer, int slot ){
		super( handler, theContainer, slot );
	}
	public DesignElement getElement( ){
		return element;
	}
	public AbstractParseState startElement( String tagName ){
		int tagValue = tagName.toLowerCase( ).hashCode( );
		if ( ParserSchemaConstants.STYLES_TAG == tagValue )return new StylesState( handler, getElement( ),IAbstractThemeModel.STYLES_SLOT );
		return super.startElement( tagName );
	}
	public void parseAttrs( Attributes attrs ) throws XMLParserException{
		element = new ReportItemTheme( );
		String type = getAttrib( attrs, DesignSchemaConstants.TYPE_ATTRIB );
		type = StringUtil.trimString( type );
		if ( !ReportItemTheme.isValidType( type ) ){
			RecoverableError.dealInvalidPropertyValue(handler,new PropertyValueException(element,IReportItemThemeModel.TYPE_PROP,type,PropertyValueException.DESIGN_EXCEPTION_NOT_SUPPORTED_REPORT_ITEM_THEME_TYPE ) );
		}
		setProperty( IReportItemThemeModel.TYPE_PROP, type );
		initElement( attrs, true );
	}
}",0,0,0,0
"public class KaffeRmic extends DefaultRmicAdapter {
	 private static final String[] RMIC_CLASSNAMES = new String[] {
	 ""gnu.classpath.tools.rmi.rmic.RMIC"", ""gnu.java.rmi.rmic.RMIC"", ""kaffe.rmi.rmic.RMIC"", }
	;
	 public static final String COMPILER_NAME = ""kaffe"";
	 public boolean execute() throws BuildException {
		 getRmic().log(""Using Kaffe rmic"", Project.MSG_VERBOSE);
		 Commandline cmd = setupRmicCommand();
		 Class c = getRmicClass();
		 if (c == null) {
			 StringBuffer buf = new StringBuffer(""Cannot use Kaffe rmic, as it"" + "" is not available. None"" + "" of "");
			 for (int i = 0;
			 i < RMIC_CLASSNAMES.length;
			 i++) {
				 if (i != 0) {
					 buf.append("", "");
				 }
				 buf.append(RMIC_CLASSNAMES[i]);
			 }
			 buf.append("" have been found. A common solution is to set the"" + "" environment variable JAVA_HOME or CLASSPATH."");
			 throw new BuildException(buf.toString(), getRmic().getLocation());
		 }
		 cmd.setExecutable(c.getName());
		 if (!c.getName().equals(RMIC_CLASSNAMES[RMIC_CLASSNAMES.length - 1])) {
			 cmd.createArgument().setValue(""-verbose"");
			 getRmic().log(Commandline.describeCommand(cmd));
		 }
		 ExecuteJava ej = new ExecuteJava();
		 ej.setJavaCommand(cmd);
		 return ej.fork(getRmic()) == 0;
	 }
	 public static boolean isAvailable() {
		 return getRmicClass() != null;
	 }
	 private static Class getRmicClass() {
		 for (int i = 0;
		 i < RMIC_CLASSNAMES.length;
		 i++) {
			 try {
				 return Class.forName(RMIC_CLASSNAMES[i]);
			 }
			 catch (ClassNotFoundException cnfe) {
			 }
		 }
		 return null;
	 }
}",0,0,0,0
"public String getCcmProject() {
	 return ccmProject;
 }",0,0,0,0
"final class DOMLocatorImpl implements DOMLocator {
	 private final int fColumnNumber;
	 private final int fLineNumber;
	 private final Node fRelatedNode;
	 private final String fUri;
	 private final int fByteOffset;
	 private final int fUtf16Offset;
	 DOMLocatorImpl(){
		 fColumnNumber = -1;
		 fLineNumber = -1;
		 fRelatedNode = null;
		 fUri = null;
		 fByteOffset = -1;
		 fUtf16Offset = -1;
	 }
	 DOMLocatorImpl (int lineNumber, int columnNumber, String uri ){
		 fLineNumber = lineNumber ;
		 fColumnNumber = columnNumber ;
		 fUri = uri;
		 fRelatedNode = null;
		 fByteOffset = -1;
		 fUtf16Offset = -1;
	 }
	 DOMLocatorImpl (int lineNumber, int columnNumber, int utf16Offset, String uri ){
		 fLineNumber = lineNumber ;
		 fColumnNumber = columnNumber ;
		 fUri = uri;
		 fUtf16Offset = utf16Offset;
		 fRelatedNode = null;
		 fByteOffset = -1;
	 }
	 DOMLocatorImpl (int lineNumber, int columnNumber, int byteoffset, Node relatedData, String uri ){
		 fLineNumber = lineNumber ;
		 fColumnNumber = columnNumber ;
		 fByteOffset = byteoffset ;
		 fRelatedNode = relatedData ;
		 fUri = uri;
		 fUtf16Offset = -1;
	 }
	 DOMLocatorImpl (int lineNumber, int columnNumber, int byteoffset, Node relatedData, String uri, int utf16Offset ){
		 fLineNumber = lineNumber ;
		 fColumnNumber = columnNumber ;
		 fByteOffset = byteoffset ;
		 fRelatedNode = relatedData ;
		 fUri = uri;
		 fUtf16Offset = utf16Offset;
	 }
	 public int getLineNumber(){
		 return fLineNumber;
	 }
	 public int getColumnNumber(){
		 return fColumnNumber;
	 }
	 public String getUri(){
		 return fUri;
	 }
	 public Node getRelatedNode(){
		 return fRelatedNode;
	 }
	 public int getByteOffset(){
		 return fByteOffset;
	 }
	 public int getUtf16Offset(){
		 return fUtf16Offset;
	 }
}",0,1,0,0
"public class IndexWriter {
	 public static long WRITE_LOCK_TIMEOUT = Integer.parseInt(System.getProperty(""org.apache.lucene.writeLockTimeout"", ""1000""));
	 public static long COMMIT_LOCK_TIMEOUT = Integer.parseInt(System.getProperty(""org.apache.lucene.commitLockTimeout"", ""10000""));
	 public static final String WRITE_LOCK_NAME = ""write.lock"";
	 public static final String COMMIT_LOCK_NAME = ""commit.lock"";
	 public static final int DEFAULT_MERGE_FACTOR = Integer.parseInt(System.getProperty(""org.apache.lucene.mergeFactor"", ""10""));
	 public static final int DEFAULT_MIN_MERGE_DOCS = Integer.parseInt(System.getProperty(""org.apache.lucene.minMergeDocs"", ""10""));
	 public static final int DEFAULT_MAX_MERGE_DOCS = Integer.parseInt(System.getProperty(""org.apache.lucene.maxMergeDocs"", String.valueOf(Integer.MAX_VALUE)));
	 public static final int DEFAULT_MAX_FIELD_LENGTH = Integer.parseInt(System.getProperty(""org.apache.lucene.maxFieldLength"", ""10000""));
	 private Directory directory;
	 private Analyzer analyzer;
	 private Similarity similarity = Similarity.getDefault();
	 private SegmentInfos segmentInfos = new SegmentInfos();
	 private final Directory ramDirectory = new RAMDirectory();
	 private Lock writeLock;
	 private boolean useCompoundFile = true;
	 private boolean closeDir;
	 public boolean getUseCompoundFile() {
		 return useCompoundFile;
	 }
	 public void setUseCompoundFile(boolean value) {
		 useCompoundFile = value;
	 }
	 public void setSimilarity(Similarity similarity) {
		 this.similarity = similarity;
	 }
	 public Similarity getSimilarity() {
		 return this.similarity;
	 }
	 public IndexWriter(String path, Analyzer a, boolean create) throws IOException {
		 this(FSDirectory.getDirectory(path, create), a, create, true);
	 }
	 public IndexWriter(File path, Analyzer a, boolean create) throws IOException {
		 this(FSDirectory.getDirectory(path, create), a, create, true);
	 }
	 public IndexWriter(Directory d, Analyzer a, boolean create) throws IOException {
		 this(d, a, create, false);
	 }
	 private IndexWriter(Directory d, Analyzer a, final boolean create, boolean closeDir) throws IOException {
		 this.closeDir = closeDir;
		 directory = d;
		 analyzer = a;
		 Lock writeLock = directory.makeLock(IndexWriter.WRITE_LOCK_NAME);
		 if (!writeLock.obtain(WRITE_LOCK_TIMEOUT)) throw new IOException(""Index locked for write: "" + writeLock);
		 this.writeLock = writeLock;
		 synchronized (directory) {
			 new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), COMMIT_LOCK_TIMEOUT) {
				 public Object doBody() throws IOException {
					 if (create) segmentInfos.write(directory);
					 else segmentInfos.read(directory);
					 return null;
				 }
			 }
			.run();
		 }
	 }
	 public synchronized void close() throws IOException {
		 flushRamSegments();
		 ramDirectory.close();
		 writeLock.release();
		 writeLock = null;
		 if(closeDir) directory.close();
	 }
	 protected void finalize() throws IOException {
		 if (writeLock != null) {
			 writeLock.release();
			 writeLock = null;
		 }
	 }
	 public Analyzer getAnalyzer() {
		 return analyzer;
	 }
	 public synchronized int docCount() {
		 int count = 0;
		 for (int i = 0;
		 i < segmentInfos.size();
		 i++) {
			 SegmentInfo si = segmentInfos.info(i);
			 count += si.docCount;
		 }
		 return count;
	 }
	 public int maxFieldLength = DEFAULT_MAX_FIELD_LENGTH;
	 public void addDocument(Document doc) throws IOException {
		 addDocument(doc, analyzer);
	 }
	 public void addDocument(Document doc, Analyzer analyzer) throws IOException {
		 DocumentWriter dw = new DocumentWriter(ramDirectory, analyzer, similarity, maxFieldLength);
		 String segmentName = newSegmentName();
		 dw.addDocument(segmentName, doc);
		 synchronized (this) {
			 segmentInfos.addElement(new SegmentInfo(segmentName, 1, ramDirectory));
			 maybeMergeSegments();
		 }
	 }
	 final int getSegmentsCounter(){
		 return segmentInfos.counter;
	 }
	 private final synchronized String newSegmentName() {
		 return ""_"" + Integer.toString(segmentInfos.counter++, Character.MAX_RADIX);
	 }
	 public int mergeFactor = DEFAULT_MERGE_FACTOR;
	 public int minMergeDocs = DEFAULT_MIN_MERGE_DOCS;
	 public int maxMergeDocs = DEFAULT_MAX_MERGE_DOCS;
	 public PrintStream infoStream = null;
	 public synchronized void optimize() throws IOException {
		 flushRamSegments();
		 while (segmentInfos.size() > 1 || (segmentInfos.size() == 1 && (SegmentReader.hasDeletions(segmentInfos.info(0)) || segmentInfos.info(0).dir != directory || (useCompoundFile && (!SegmentReader.usesCompoundFile(segmentInfos.info(0)) || SegmentReader.hasSeparateNorms(segmentInfos.info(0))))))) {
			 int minSegment = segmentInfos.size() - mergeFactor;
			 mergeSegments(minSegment < 0 ? 0 : minSegment);
		 }
	 }
	 public synchronized void addIndexes(Directory[] dirs) throws IOException {
		 optimize();
		 for (int i = 0;
		 i < dirs.length;
		 i++) {
			 SegmentInfos sis = new SegmentInfos();
			 sis.read(dirs[i]);
			 for (int j = 0;
			 j < sis.size();
			 j++) {
				 segmentInfos.addElement(sis.info(j));
			 }
		 }
		 optimize();
	 }
	 public synchronized void addIndexes(IndexReader[] readers) throws IOException {
		 optimize();
		 String mergedName = newSegmentName();
		 SegmentMerger merger = new SegmentMerger(directory, mergedName, false);
		 if (segmentInfos.size() == 1) merger.add(new SegmentReader(segmentInfos.info(0)));
		 for (int i = 0;
		 i < readers.length;
		 i++) merger.add(readers[i]);
		 int docCount = merger.merge();
		 segmentInfos.setSize(0);
		 segmentInfos.addElement(new SegmentInfo(mergedName, docCount, directory));
		 synchronized (directory) {
			 new Lock.With(directory.makeLock(""commit.lock""), COMMIT_LOCK_TIMEOUT) {
				 public Object doBody() throws IOException {
					 segmentInfos.write(directory);
					 return null;
				 }
			}
			.run();
		 }
	 }
	 private final void flushRamSegments() throws IOException {
		 int minSegment = segmentInfos.size()-1;
		 int docCount = 0;
		 while (minSegment >= 0 && (segmentInfos.info(minSegment)).dir == ramDirectory) {
			 docCount += segmentInfos.info(minSegment).docCount;
			 minSegment--;
		 }
		 if (minSegment < 0 || (docCount + segmentInfos.info(minSegment).docCount) > mergeFactor || !(segmentInfos.info(segmentInfos.size()-1).dir == ramDirectory)) minSegment++;
		 if (minSegment >= segmentInfos.size()) return;
		 mergeSegments(minSegment);
	 }
	 private final void maybeMergeSegments() throws IOException {
		 long targetMergeDocs = minMergeDocs;
		 while (targetMergeDocs <= maxMergeDocs) {
			 int minSegment = segmentInfos.size();
			 int mergeDocs = 0;
			 while (--minSegment >= 0) {
				 SegmentInfo si = segmentInfos.info(minSegment);
				 if (si.docCount >= targetMergeDocs) break;
				 mergeDocs += si.docCount;
			 }
			 if (mergeDocs >= targetMergeDocs) mergeSegments(minSegment+1);
			 else break;
			 targetMergeDocs *= mergeFactor;
		 }
	 }
	 private final void mergeSegments(int minSegment) throws IOException {
		 String mergedName = newSegmentName();
		 if (infoStream != null) infoStream.print(""merging segments"");
		 SegmentMerger merger = new SegmentMerger(directory, mergedName, useCompoundFile);
		 final Vector segmentsToDelete = new Vector();
		 for (int i = minSegment;
		 i < segmentInfos.size();
		 i++) {
			 SegmentInfo si = segmentInfos.info(i);
			 if (infoStream != null) infoStream.print("" "" + si.name + "" ("" + si.docCount + "" docs)"");
			 IndexReader reader = new SegmentReader(si);
			 merger.add(reader);
			 if ((reader.directory() == this.directory) || (reader.directory() == this.ramDirectory)) segmentsToDelete.addElement(reader);
		 }
		 int mergedDocCount = merger.merge();
		 if (infoStream != null) {
			 infoStream.println("" into ""+mergedName+"" (""+mergedDocCount+"" docs)"");
		 }
		 segmentInfos.setSize(minSegment);
		 segmentInfos.addElement(new SegmentInfo(mergedName, mergedDocCount, directory));
		 merger.closeReaders();
		 synchronized (directory) {
			 new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), COMMIT_LOCK_TIMEOUT) {
				 public Object doBody() throws IOException {
					 segmentInfos.write(directory);
					 deleteSegments(segmentsToDelete);
					 return null;
				 }
			 }
			.run();
		 }
	 }
	 private final void deleteSegments(Vector segments) throws IOException {
		 Vector deletable = new Vector();
		 deleteFiles(readDeleteableFiles(), deletable);
		 for (int i = 0;
		 i < segments.size();
		 i++) {
			 SegmentReader reader = (SegmentReader)segments.elementAt(i);
			 if (reader.directory() == this.directory)deleteFiles(reader.files(), deletable);
			 elsedeleteFiles(reader.files(), reader.directory());
		 }
		 writeDeleteableFiles(deletable);
	 }
	 private final void deleteFiles(Vector files, Directory directory) throws IOException {
		 for (int i = 0;
		 i < files.size();
		 i++) directory.deleteFile((String)files.elementAt(i));
	 }
	 private final void deleteFiles(Vector files, Vector deletable) throws IOException {
		 for (int i = 0;
		 i < files.size();
		 i++) {
			 String file = (String)files.elementAt(i);
			 try {
				 directory.deleteFile(file);
			 }
			 catch (IOException e) {
				 if (directory.fileExists(file)) {
					 if (infoStream != null) infoStream.println(e.getMessage() + "";
					 Will re-try later."");
					 deletable.addElement(file);
				 }
			 }
		 }
	 }
	 private final Vector readDeleteableFiles() throws IOException {
		 Vector result = new Vector();
		 if (!directory.fileExists(""deletable"")) return result;
		 InputStream input = directory.openFile(""deletable"");
		 try {
			 for (int i = input.readInt();
			 i > 0;
			 i--) result.addElement(input.readString());
		 }
		 finally {
			 input.close();
		 }
		 return result;
	 }
	 private final void writeDeleteableFiles(Vector files) throws IOException {
		 OutputStream output = directory.createFile(""deleteable.new"");
		 try {
			 output.writeInt(files.size());
			 for (int i = 0;
			 i < files.size();
			 i++) output.writeString((String)files.elementAt(i));
		 }
		 finally {
			 output.close();
		 }
		 directory.renameFile(""deleteable.new"", ""deletable"");
	 }
}",1,0,0,0
"public class Model<T extends Serializable> implements IModel<T>{
	private static final long serialVersionUID = 1L;
	private T object;
	public Model(){
	}
	public Model(final T object){
		setObject(object);
	}
	public static <K, V> IModel<Map<K, V>> valueOf(final Map<K, V> map){
		return of(map);
	}
	public static <C> IModel<List<? extends C>> valueOf(final List<? extends C> list){
		return of(list);
	}
	public static <C> IModel<List<? extends C>> of(final List<? extends C> list){
		return new WildcardListModel<C>(list);
	}
	public static <C> IModel<List<? extends C>> ofList(final List<? extends C> list){
		return new WildcardListModel<C>(list);
	}
	public static <K, V> IModel<Map<K, V>> of(final Map<K, V> map){
		return new MapModel<K, V>(map);
	}
	public static <K, V> IModel<Map<K, V>> ofMap(final Map<K, V> map){
		return new MapModel<K, V>(map);
	}
	public static <C> IModel<Set<? extends C>> of(final Set<? extends C> set){
		return new WildcardSetModel<C>(set);
	}
	public static <C> IModel<Set<? extends C>> ofSet(final Set<? extends C> set){
		return new WildcardSetModel<C>(set);
	}
	public static <C> IModel<Collection<? extends C>> of(final Collection<? extends C> set){
		return new WildcardCollectionModel<C>(set);
	}
	public static <T extends Serializable> Model<T> of(T object){
		return new Model<T>(object);
	}
	public static <T extends Serializable> Model<T> of(){
		return new Model<T>();
	}
	public T getObject(){
		return object;
	}
	public void setObject(final T object){
		if (object != null){
			if (!(object instanceof Serializable)){
				throw new WicketRuntimeException(""Model object must be Serializable"");
			}
		}
		this.object = object;
	}
	public void detach(){
		if (object instanceof IDetachable){
			((IDetachable)object).detach();
		}
	}
	public String toString(){
		StringBuffer sb = new StringBuffer(""Model:classname=["");
		sb.append(getClass().getName()).append(""]"");
		sb.append("":object=["").append(object).append(""]"");
		return sb.toString();
	}
	public final Object getObject(Component component){
		throw new UnsupportedOperationException();
	}
	public final void setObject(Component component, Object object){
		throw new UnsupportedOperationException();
	}
	public int hashCode(){
		return Objects.hashCode(object);
	}
	public boolean equals(Object obj){
		if (this == obj){
			return true;
		}
		if (!(obj instanceof Model<?>)){
			return false;
		}
		Model<?> that = (Model<?>)obj;
		return Objects.equal(object, that.object);
	}
}",0,0,0,0
"public class SortableASTTransformation extends AbstractASTTransformation {
	 private static final ClassNode MY_TYPE = make(Sortable.class);
	 private static final String MY_TYPE_NAME = ""@"" + MY_TYPE.getNameWithoutPackage();
	 private static final ClassNode COMPARABLE_TYPE = makeClassSafe(Comparable.class);
	 private static final ClassNode COMPARATOR_TYPE = makeClassSafe(Comparator.class);
	 private static final String VALUE = ""value"";
	 private static final String OTHER = ""other"";
	 private static final String THIS_HASH = ""thisHash"";
	 private static final String OTHER_HASH = ""otherHash"";
	 private static final String ARG0 = ""arg0"";
	 private static final String ARG1 = ""arg1"";
	 public void visit(ASTNode[] nodes, SourceUnit source) {
		 init(nodes, source);
		 AnnotationNode annotation = (AnnotationNode) nodes[0];
		 AnnotatedNode parent = (AnnotatedNode) nodes[1];
		 if (parent instanceof ClassNode) {
			 createSortable(annotation, (ClassNode) parent);
		 }
	 }
	 private void createSortable(AnnotationNode anno, ClassNode classNode) {
		 List<String> includes = getMemberStringList(anno, ""includes"");
		 List<String> excludes = getMemberStringList(anno, ""excludes"");
		 boolean reversed = memberHasValue(anno, ""reversed"", true);
		 boolean includeSuperProperties = memberHasValue(anno, ""includeSuperProperties"", true);
		 boolean allNames = memberHasValue(anno, ""allNames"", true);
		 boolean allProperties = !memberHasValue(anno, ""allProperties"", false);
		 if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
		 if (!checkPropertyList(classNode, includes, ""includes"", anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;
		 if (!checkPropertyList(classNode, excludes, ""excludes"", anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;
		 if (classNode.isInterface()) {
			 addError(MY_TYPE_NAME + "" cannot be applied to interface "" + classNode.getName(), anno);
		 }
		 List<PropertyNode> properties = findProperties(anno, classNode, includes, excludes, allProperties, includeSuperProperties, allNames);
		 implementComparable(classNode);
		 addGeneratedMethod(classNode, ""compareTo"", ACC_PUBLIC, ClassHelper.int_TYPE, params(param(newClass(classNode), OTHER)), ClassNode.EMPTY_ARRAY, createCompareToMethodBody(properties, reversed) );
		 for (PropertyNode property : properties) {
			 createComparatorFor(classNode, property, reversed);
		 }
		 new VariableScopeVisitor(sourceUnit, true).visitClass(classNode);
	 }
	 private static void implementComparable(ClassNode classNode) {
		 if (!classNode.implementsInterface(COMPARABLE_TYPE)) {
			 classNode.addInterface(makeClassSafeWithGenerics(Comparable.class, classNode));
		 }
	 }
	 private static Statement createCompareToMethodBody(List<PropertyNode> properties, boolean reversed) {
		 List<Statement> statements = new ArrayList<Statement>();
		 statements.add(ifS(callThisX(""is"", args(OTHER)), returnS(constX(0))));
		 if (properties.isEmpty()) {
			 statements.add(declS(localVarX(THIS_HASH, ClassHelper.Integer_TYPE), callX(varX(""this""), ""hashCode"")));
			 statements.add(declS(localVarX(OTHER_HASH, ClassHelper.Integer_TYPE), callX(varX(OTHER), ""hashCode"")));
			 statements.add(returnS(compareExpr(varX(THIS_HASH), varX(OTHER_HASH), reversed)));
		 }
		 else {
			 statements.add(declS(localVarX(VALUE, ClassHelper.int_TYPE), constX(0)));
			 for (PropertyNode property : properties) {
				 String propName = property.getName();
				 statements.add(assignS(varX(VALUE), compareExpr(propX(varX(""this""), propName), propX(varX(OTHER), propName), reversed)));
				 statements.add(ifS(neX(varX(VALUE), constX(0)), returnS(varX(VALUE))));
			 }
			 statements.add(returnS(constX(0)));
		 }
		 final BlockStatement body = new BlockStatement();
		 body.addStatements(statements);
		 return body;
	 }
	 private static Statement createCompareMethodBody(PropertyNode property, boolean reversed) {
		 String propName = property.getName();
		 return block( ifS(eqX(varX(ARG0), varX(ARG1)), returnS(constX(0))), ifS(andX(notNullX(varX(ARG0)), equalsNullX(varX(ARG1))), returnS(constX(-1))), ifS(andX(equalsNullX(varX(ARG0)), notNullX(varX(ARG1))), returnS(constX(1))), returnS(compareExpr(propX(varX(ARG0), propName), propX(varX(ARG1), propName), reversed)) );
	 }
	 private static void createComparatorFor(ClassNode classNode, PropertyNode property, boolean reversed) {
		 String propName = StringGroovyMethods.capitalize((CharSequence) property.getName());
		 String className = classNode.getName() + ""$"" + propName + ""Comparator"";
		 ClassNode superClass = makeClassSafeWithGenerics(AbstractComparator.class, classNode);
		 InnerClassNode cmpClass = new InnerClassNode(classNode, className, ACC_PRIVATE | ACC_STATIC, superClass);
		 addGeneratedInnerClass(classNode, cmpClass);
		 addGeneratedMethod(cmpClass, ""compare"", ACC_PUBLIC, ClassHelper.int_TYPE, params(param(newClass(classNode), ARG0), param(newClass(classNode), ARG1)), ClassNode.EMPTY_ARRAY, createCompareMethodBody(property, reversed) );
		 String fieldName = ""this$"" + propName + ""Comparator"";
		 FieldNode cmpField = classNode.addField( fieldName, ACC_STATIC | ACC_FINAL | ACC_PRIVATE | ACC_SYNTHETIC, COMPARATOR_TYPE, ctorX(cmpClass));
		 addGeneratedMethod(classNode, ""comparatorBy"" + propName, ACC_PUBLIC | ACC_STATIC, COMPARATOR_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, returnS(fieldX(cmpField)) );
	 }
	 private List<PropertyNode> findProperties(AnnotationNode annotation, final ClassNode classNode, final List<String> includes, final List<String> excludes, final boolean allProperties, final boolean includeSuperProperties, final boolean allNames) {
		 Set<String> names = new HashSet<String>();
		 List<PropertyNode> props = getAllProperties(names, classNode, classNode, true, false, allProperties, false, includeSuperProperties, false, false, allNames, false);
		 List<PropertyNode> properties = new ArrayList<PropertyNode>();
		 for (PropertyNode property : props) {
			 String propertyName = property.getName();
			 if ((excludes != null && excludes.contains(propertyName)) || includes != null && !includes.contains(propertyName)) continue;
			 properties.add(property);
		 }
		 for (PropertyNode pNode : properties) {
			 checkComparable(pNode);
		 }
		 if (includes != null) {
			 Comparator<PropertyNode> includeComparator = new Comparator<PropertyNode>() {
				 public int compare(PropertyNode o1, PropertyNode o2) {
					 return Integer.compare(includes.indexOf(o1.getName()), includes.indexOf(o2.getName()));
				 }
			 }
			;
			 Collections.sort(properties, includeComparator);
		 }
		 return properties;
	 }
	 private void checkComparable(PropertyNode pNode) {
		 if (pNode.getType().implementsInterface(COMPARABLE_TYPE) || isPrimitiveType(pNode.getType()) || hasAnnotation(pNode.getType(), MY_TYPE)) {
			 return;
		 }
		 addError(""Error during "" + MY_TYPE_NAME + "" processing: property '"" + pNode.getName() + ""' must be Comparable"", pNode);
	 }
	 private static BinaryExpression compareExpr(Expression lhv, Expression rhv, boolean reversed) {
		 return (reversed) ? cmpX(rhv, lhv) : cmpX(lhv, rhv);
	 }
}",1,1,0,0
"public class RabbitGatewaySupport implements InitializingBean {
	protected final Log logger = LogFactory.getLog(getClass());
	 private RabbitOperations rabbitOperations;
	public final void setConnectionFactory(ConnectionFactory connectionFactory) {
		this.rabbitOperations = createRabbitTemplate(connectionFactory);
	}
	protected RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) {
		return new RabbitTemplate(connectionFactory);
	}
	public final ConnectionFactory getConnectionFactory() {
		return (this.rabbitOperations != null ? this.rabbitOperations.getConnectionFactory() : null);
	}
	public final void setRabbitOperations(RabbitOperations rabbitOperations) {
		this.rabbitOperations = rabbitOperations;
	}
	public final RabbitOperations getRabbitOperations() {
		return this.rabbitOperations;
	}
	public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
		if (this.rabbitOperations == null) {
			throw new IllegalArgumentException(""'connectionFactory' or 'rabbitTemplate' is required"");
		}
		try {
			initGateway();
		}
		catch (Exception ex) {
			throw new BeanInitializationException(""Initialization of Rabbit gateway failed: "" + ex.getMessage(), ex);
		}
	}
	protected void initGateway() {
	}
}",1,1,0,0
"public String genJavaReadWrapper(String fname, String tag, boolean decl) {
	 String ret = """";
	 if (decl) {
		 ret = "" ""+mWrapper+"" ""+fname+"";
		\n"";
	 }
	 return ret + "" ""+fname+""=new ""+mWrapper+""(a_.read""+mMethodSuffix+""(\""""+tag+""\""));
	\n"";
 }",0,0,0,0
"public final Boolean entryRuleType() throws RecognitionException {
	 Boolean current = false;
	 Boolean iv_ruleType = null;
	 try {
		 {
			 markComposite(elementTypeProvider.getTypeElementType());
			 pushFollow(FOLLOW_1);
			 iv_ruleType=ruleType();
			 state._fsp--;
			 current =iv_ruleType;
			 match(input,EOF,FOLLOW_2);
		 }
	 }
	 catch (RecognitionException re) {
		 reportError(re);
		 recover(input,re);
	 }
	 finally {
	 }
	 return current;
 }",0,0,0,0
"public static class Value {
	 int count = 0;
	 BigInteger txid;
 }",0,1,0,0
"public static class State {
	 public Map<String, String> properties = new HashMap<String, String>();
	 public Map<String, String[]> array_properties = new HashMap<String, String[]>();
 }",0,1,0,0
"public void setFile(File file) {
	 this.src = file;
 }",0,0,0,0
"private BezierPath[] toPath(String str) throws IOException {
	 LinkedList<BezierPath> paths = new LinkedList<BezierPath>();
	 BezierPath path = null;
	 Point2D.Double p = new Point2D.Double();
	 Point2D.Double c1 = new Point2D.Double();
	 Point2D.Double c2 = new Point2D.Double();
	 StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
	 tt.resetSyntax();
	 tt.parseNumbers();
	 tt.parseExponents();
	 tt.parsePlusAsNumber();
	 tt.whitespaceChars(0, ' ');
	 tt.whitespaceChars(',', ',');
	 char nextCommand = 'M';
	 char command = 'M';
	 Commands: while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
		 if (tt.ttype > 0) {
			 command = (char) tt.ttype;
		 }
		 else {
			 command = nextCommand;
			 tt.pushBack();
		 }
		 BezierPath.Node node;
		 switch (command) {
			 case 'M': if (path != null) {
				 paths.add(path);
			 }
			 path = new BezierPath();
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'M' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'M' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.moveTo(p.x, p.y);
			 nextCommand = 'L';
			 break;
			 case 'm': if (path != null) {
				 paths.add(path);
			 }
			 path = new BezierPath();
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 'm' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 'm' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.moveTo(p.x, p.y);
			 nextCommand = 'l';
			 break;
			 case 'Z': case 'z': p.x = path.get(0).x[0];
			 p.y = path.get(0).y[0];
			 if (path.size() > 1) {
				 BezierPath.Node first = path.get(0);
				 BezierPath.Node last = path.get(path.size() - 1);
				 if (first.x[0] == last.x[0] && first.y[0] == last.y[0]) {
					 if ((last.mask & BezierPath.C1_MASK) != 0) {
						 first.mask |= BezierPath.C1_MASK;
						 first.x[1] = last.x[1];
						 first.y[1] = last.y[1];
					 }
					 path.remove(path.size() - 1);
				 }
			 }
			 path.setClosed(true);
			 break;
			 case 'L': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'L' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'L' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.lineTo(p.x, p.y);
			 nextCommand = 'L';
			 break;
			 case 'l': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 'l' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 'l' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.lineTo(p.x, p.y);
			 nextCommand = 'l';
			 break;
			 case 'H': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'H' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 path.lineTo(p.x, p.y);
			 nextCommand = 'H';
			 break;
			 case 'h': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 'h' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 path.lineTo(p.x, p.y);
			 nextCommand = 'h';
			 break;
			 case 'V': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'V' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.lineTo(p.x, p.y);
			 nextCommand = 'V';
			 break;
			 case 'v': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 'v' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.lineTo(p.x, p.y);
			 nextCommand = 'v';
			 break;
			 case 'C': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x1 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y1 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.y = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x2 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y2 coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.y = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'C' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
			 nextCommand = 'C';
			 break;
			 case 'c': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx1 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.x = p.x + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy1 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.y = p.y + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx2 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.x = p.x + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy2 coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.y = p.y + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 'c' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
			 nextCommand = 'c';
			 break;
			 case 'S': node = path.get(path.size() - 1);
			 c1.x = node.x[0] * 2d - node.x[1];
			 c1.y = node.y[0] * 2d - node.y[1];
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x2 coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y2 coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.y = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'S' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
			 nextCommand = 'S';
			 break;
			 case 's': node = path.get(path.size() - 1);
			 c1.x = node.x[0] * 2d - node.x[1];
			 c1.y = node.y[0] * 2d - node.y[1];
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx2 coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.x = p.x + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy2 coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c2.y = p.y + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 's' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
			 nextCommand = 's';
			 break;
			 case 'Q': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x1 coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y1 coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.y = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'Q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.quadTo(c1.x, c1.y, p.x, p.y);
			 nextCommand = 'Q';
			 break;
			 case 'q': if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx1 coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.x = p.x + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy1 coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 c1.y = p.y + tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 'q' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.quadTo(c1.x, c1.y, p.x, p.y);
			 nextCommand = 'q';
			 break;
			 case 'T': node = path.get(path.size() - 1);
			 c1.x = node.x[0] * 2d - node.x[1];
			 c1.y = node.y[0] * 2d - node.y[1];
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""x coordinate missing for 'T' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x = tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""y coordinate missing for 'T' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y = tt.nval;
			 path.quadTo(c1.x, c1.y, p.x, p.y);
			 nextCommand = 'T';
			 break;
			 case 't': node = path.get(path.size() - 1);
			 c1.x = node.x[0] * 2d - node.x[1];
			 c1.y = node.y[0] * 2d - node.y[1];
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dx coordinate missing for 't' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.x += tt.nval;
			 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
				 throw new IOException(""dy coordinate missing for 't' at position "" + tt.getStartPosition() + "" in "" + str);
			 }
			 p.y += tt.nval;
			 path.quadTo(c1.x, c1.y, p.x, p.y);
			 nextCommand = 's';
			 break;
			 case 'A': {
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""rx coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 double rx = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""ry coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 double ry = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x-axis-rotation missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 double xAxisRotation = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""large-arc-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 boolean largeArcFlag = tt.nval != 0;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""sweep-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 boolean sweepFlag = tt.nval != 0;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y = tt.nval;
				 path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
				 nextCommand = 'A';
				 break;
			 }
			 case 'a': {
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""rx coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 double rx = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""ry coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 double ry = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x-axis-rotation missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 double xAxisRotation = tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""large-arc-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 boolean largeArcFlag = tt.nval != 0;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""sweep-flag missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 boolean sweepFlag = tt.nval != 0;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""x coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.x += tt.nval;
				 if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
					 throw new IOException(""y coordinate missing for 'A' at position "" + tt.getStartPosition() + "" in "" + str);
				 }
				 p.y += tt.nval;
				 path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
				 nextCommand = 'a';
				 break;
			 }
			 default: if (DEBUG) {
				 System.out.println(""SVGInputFormat.toPath aborting after illegal path command: "" + command + "" found in path "" + str);
			 }
			 break Commands;
		 }
	 }
	 if (path != null) {
		 paths.add(path);
	 }
	 return paths.toArray(new BezierPath[paths.size()]);
 }",0,0,1,0
"public abstract class JenaResultSet implements ResultSet {
	 private static final int DEFAULT_HOLDABILITY = ResultSet.CLOSE_CURSORS_AT_COMMIT;
	 private SQLWarning warnings;
	 private JenaStatement statement;
	 private boolean wasNull = false;
	 private int holdability = DEFAULT_HOLDABILITY;
	 private int compatibilityLevel = JdbcCompatibility.DEFAULT;
	 public JenaResultSet(JenaStatement statement) throws SQLException {
		 if (statement == null) throw new SQLException(""Statement for a Result Set cannot be null"");
		 this.statement = statement;
		 this.compatibilityLevel = JdbcCompatibility .normalizeLevel(this.statement.getJdbcCompatibilityLevel());
	 }
	 public JenaStatement getJenaStatement() {
		 return this.statement;
	 }
	 public int getJdbcCompatibilityLevel() {
		 return this.compatibilityLevel;
	 }
	 public boolean isWrapperFor(Class<?> iface) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T unwrap(Class<T> iface) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void cancelRowUpdates() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public final void clearWarnings() {
		 this.warnings = null;
	 }
	 public void deleteRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public final int getHoldability() {
		 return this.holdability;
	 }
	 public final int getConcurrency() {
		 return ResultSet.CONCUR_READ_ONLY;
	 }
	 public abstract ResultSetMetaData getMetaData() throws SQLException;
	 protected Node getNode(int columnIndex) throws SQLException {
		 return this.getNode(this.findColumnLabel(columnIndex));
	 }
	 protected abstract String findColumnLabel(int columnIndex) throws SQLException;
	 protected abstract Node getNode(String columnLabel) throws SQLException;
	 public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		 return this.getBigDecimal(this.findColumnLabel(columnIndex));
	 }
	 public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toDecimal(n);
		 }
	 }
	 public boolean getBoolean(int columnIndex) throws SQLException {
		 return this.getBoolean(this.findColumnLabel(columnIndex));
	 }
	 public boolean getBoolean(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return false;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toBoolean(n);
		 }
	 }
	 public byte getByte(int columnIndex) throws SQLException {
		 return this.getByte(this.findColumnLabel(columnIndex));
	 }
	 public byte getByte(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return 0;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toByte(n);
		 }
	 }
	 public Date getDate(int columnIndex) throws SQLException {
		 return this.getDate(this.findColumnLabel(columnIndex));
	 }
	 public Date getDate(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toDate(n);
		 }
	 }
	 public double getDouble(int columnIndex) throws SQLException {
		 return this.getDouble(this.findColumnLabel(columnIndex));
	 }
	 public double getDouble(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return 0;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toDouble(n);
		 }
	 }
	 public float getFloat(int columnIndex) throws SQLException {
		 return this.getFloat(this.findColumnLabel(columnIndex));
	 }
	 public float getFloat(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return 0;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toFloat(n);
		 }
	 }
	 public int getInt(int columnIndex) throws SQLException {
		 return this.getInt(this.findColumnLabel(columnIndex));
	 }
	 public int getInt(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return 0;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toInt(n);
		 }
	 }
	 public long getLong(int columnIndex) throws SQLException {
		 return this.getLong(this.findColumnLabel(columnIndex));
	 }
	 public long getLong(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return 0;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toLong(n);
		 }
	 }
	 public String getNString(int columnIndex) throws SQLException {
		 return this.getNString(this.findColumnLabel(columnIndex));
	 }
	 public String getNString(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toString(n);
		 }
	 }
	 public Object getObject(int columnIndex) throws SQLException {
		 return this.getObject(this.findColumnLabel(columnIndex));
	 }
	 public Object getObject(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 int jdbcType = this.getMetaData().getColumnType(this.findColumn(columnLabel));
			 this.setNull(false);
			 switch (jdbcType) {
				 case Types.ARRAY: case Types.BINARY: case Types.BIT: case Types.BLOB: case Types.CLOB: case Types.DATALINK: case Types.DISTINCT: case Types.LONGNVARCHAR: case Types.LONGVARBINARY: case Types.LONGVARCHAR: case Types.NCHAR: case Types.NCLOB: case Types.NULL: case Types.NUMERIC: case Types.OTHER: case Types.REAL: case Types.REF: case Types.ROWID: case Types.SQLXML: case Types.STRUCT: case Types.VARBINARY: throw new SQLException(""Unable to marhsal a RDF Node to the declared column type "" + jdbcType);
				 case Types.BOOLEAN: return JdbcNodeUtils.toBoolean(n);
				 case Types.BIGINT: return JdbcNodeUtils.toLong(n);
				 case Types.DATE: return JdbcNodeUtils.toDate(n);
				 case Types.DECIMAL: return JdbcNodeUtils.toDecimal(n);
				 case Types.DOUBLE: return JdbcNodeUtils.toDouble(n);
				 case Types.FLOAT: return JdbcNodeUtils.toFloat(n);
				 case Types.INTEGER: return JdbcNodeUtils.toInt(n);
				 case Types.JAVA_OBJECT: return n;
				 case Types.CHAR: case Types.VARCHAR: case Types.NVARCHAR: return JdbcNodeUtils.toString(n);
				 case Types.SMALLINT: return JdbcNodeUtils.toShort(n);
				 case Types.TIME: return JdbcNodeUtils.toTime(n);
				 case Types.TIMESTAMP: return JdbcNodeUtils.toTimestamp(n);
				 case Types.TINYINT: return JdbcNodeUtils.toByte(n);
				 default: throw new SQLException(""Unable to marshal a RDF Node to the declared unknown column type "" + jdbcType);
			 }
		 }
	 }
	 public short getShort(int columnIndex) throws SQLException {
		 return this.getShort(this.findColumnLabel(columnIndex));
	 }
	 public short getShort(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return 0;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toShort(n);
		 }
	 }
	 public String getString(int columnIndex) throws SQLException {
		 return this.getString(this.findColumnLabel(columnIndex));
	 }
	 public String getString(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toString(n);
		 }
	 }
	 public Time getTime(int columnIndex) throws SQLException {
		 return this.getTime(this.findColumnLabel(columnIndex));
	 }
	 public Time getTime(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toTime(n);
		 }
	 }
	 public Timestamp getTimestamp(int columnIndex) throws SQLException {
		 return this.getTimestamp(this.findColumnLabel(columnIndex));
	 }
	 public Timestamp getTimestamp(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toTimestamp(n);
		 }
	 }
	 public URL getURL(int columnIndex) throws SQLException {
		 return this.getURL(this.findColumnLabel(columnIndex));
	 }
	 public URL getURL(String columnLabel) throws SQLException {
		 Node n = this.getNode(columnLabel);
		 if (n == null) {
			 this.setNull(true);
			 return null;
		 }
		 else {
			 this.setNull(false);
			 return JdbcNodeUtils.toURL(n);
		 }
	 }
	 public Array getArray(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Array getArray(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getAsciiStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getAsciiStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getBigDecimal() is supported"");
	 }
	 public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getBigDecimal() is supported"");
	 }
	 public InputStream getBinaryStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getBinaryStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Blob getBlob(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Blob getBlob(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public byte[] getBytes(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public byte[] getBytes(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Reader getCharacterStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Reader getCharacterStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Clob getClob(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Clob getClob(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public String getCursorName() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Date getDate(String columnLabel, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getDate() is supported"");
	 }
	 public Reader getNCharacterStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getDate() is supported"");
	 }
	 public Reader getNCharacterStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public NClob getNClob(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public NClob getNClob(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Object getObject(int columnIndex, Map<String, Class<?>> map) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getObject() is supported"");
	 }
	 public Object getObject(String columnLabel, Map<String, Class<?>> map) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getObject() is supported"");
	 }
	 public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getObject() is supported"");
	 }
	 public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getObject() is supported"");
	 }
	 public Ref getRef(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Ref getRef(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public RowId getRowId(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public RowId getRowId(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLXML getSQLXML(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLXML getSQLXML(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Statement getStatement() {
		 return this.statement;
	 }
	 public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getTime() is supported"");
	 }
	 public Time getTime(String columnLabel, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getTime() is supported"");
	 }
	 public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getTimestamp() is supported"");
	 }
	 public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Only the single argument form of getTimestamp() is supported"");
	 }
	 public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getUnicodeStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public final SQLWarning getWarnings() {
		 return this.warnings;
	 }
	 protected void setWarning(SQLWarning warning) {
		 if (this.warnings == null) {
			 this.warnings = warning;
		 }
		 else {
			 warning.setNextWarning(this.warnings);
			 this.warnings = warning;
		 }
	 }
	 protected void setWarning(String warning) {
		 this.setWarning(new SQLWarning(warning));
	 }
	 protected void setWarning(String warning, Throwable cause) {
		 this.setWarning(new SQLWarning(warning, cause));
	 }
	 public void insertRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void moveToCurrentRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public void moveToInsertRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public boolean previous() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are forward-only"");
	 }
	 public void refreshRow() {
	 }
	 public boolean rowDeleted() {
		 return false;
	 }
	 public boolean rowInserted() {
		 return false;
	 }
	 public boolean rowUpdated() {
		 return false;
	 }
	 public void updateArray(int columnIndex, Array x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateArray(String columnLabel, Array x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBlob(int columnIndex, Blob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBlob(String columnLabel, Blob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBoolean(String columnLabel, boolean x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateByte(int columnIndex, byte x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateByte(String columnLabel, byte x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateBytes(String columnLabel, byte[] x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateCharacterStream(String columnLabel, Reader reader, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateClob(int columnIndex, Clob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateClob(int columnIndex, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateClob(String columnLabel, Clob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateClob(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateDate(int columnIndex, Date x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateDate(String columnLabel, Date x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateDouble(int columnIndex, double x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateDouble(String columnLabel, double x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateFloat(int columnIndex, float x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateFloat(String columnLabel, float x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateInt(int columnIndex, int x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateInt(String columnLabel, int x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateLong(int columnIndex, long x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateLong(String columnLabel, long x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNClob(String columnLabel, NClob nClob) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNClob(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNString(int columnIndex, String nString) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNString(String columnLabel, String nString) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNull(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateNull(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateObject(int columnIndex, Object x, int scaleOrLength) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateObject(int columnIndex, Object x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateObject(String columnLabel, Object x, int scaleOrLength) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateObject(String columnLabel, Object x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateRef(int columnIndex, Ref x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateRef(String columnLabel, Ref x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateRowId(int columnIndex, RowId x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateRowId(String columnLabel, RowId x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateShort(int columnIndex, short x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateShort(String columnLabel, short x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateString(int columnIndex, String x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateString(String columnLabel, String x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateTime(int columnIndex, Time x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateTime(String columnLabel, Time x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC Result Sets are read-only"");
	 }
	 public boolean wasNull() {
		 return this.wasNull;
	 }
	 protected void setNull(boolean wasNull) {
		 this.wasNull = wasNull;
	 }
}",1,0,0,0
"public class CtagsReader {
	 private static final Pattern LAST_UWORD = Pattern.compile( ""(?U)(\\w+)[\\W\\s]*$"");
	 private static final Pattern WORD_CHAR = Pattern.compile(""(?U)\\w"");
	 private static final Logger LOGGER = LoggerFactory.getLogger( CtagsReader.class);
	 private static final int MIN_METHOD_LINE_LENGTH = 6;
	 private static final int MAX_METHOD_LINE_LENGTH = 1030;
	 private static final int MAX_CUT_LENGTH = 2000;
	 private static final int MAX_CUT_LINES = 24;
	 private final EnumMap<tagFields, String> fields = new EnumMap<>( tagFields.class);
	 private final Definitions defs = new Definitions();
	 private Supplier<SourceSplitter> splitterSupplier;
	 private boolean triedSplitterSupplier;
	 private SourceSplitter splitter;
	 private long cutCacheKey;
	 private String cutCacheValue;
	 private int tabSize;
	 public enum tagFields {
		 CLASS(""class""), LINE(""line""), SIGNATURE(""signature"");
		 private final String name;
		 tagFields(String name) {
			 this.name = name;
		 }
		 public static int charCmpEndOffset = 0;
		 public static CtagsReader.tagFields quickValueOf(String fullName) {
			 int i;
			 boolean match;
			 for (tagFields x : tagFields.values()) {
				 match = true;
				 for (i = 0;
				 i <= charCmpEndOffset;
				 i++) {
					 if (x.name.charAt(i) != fullName.charAt(i)) {
						 match = false;
						 break;
					 }
				 }
				 if (match) {
					 return x;
				 }
			 }
			 return null;
		 }
	 }
	 public int getTabSize() {
		 return tabSize;
	 }
	 public void setTabSize(int tabSize) {
		 this.tabSize = tabSize;
	 }
	 public Definitions getDefinitions() {
		 return defs;
	 }
	 public void setSplitterSupplier(Supplier<SourceSplitter> obj) {
		 splitter = null;
		 triedSplitterSupplier = false;
		 splitterSupplier = obj;
	 }
	 public void readLine(String tagLine) {
		 if (tagLine == null) {
			 return;
		 }
		 int p = tagLine.indexOf('\t');
		 if (p <= 0) {
			 return;
		 }
		 String def = tagLine.substring(0, p);
		 int mstart = tagLine.indexOf('\t', p + 1);
		 String kind = null;
		 int lp = tagLine.length();
		 while ((p = tagLine.lastIndexOf('\t', lp - 1)) > 0) {
			 String fld = tagLine.substring(p + 1, lp);
			 lp = p;
			 int sep = fld.indexOf(':');
			 if (sep != -1) {
				 tagFields pos = tagFields.quickValueOf(fld);
				 if (pos != null) {
					 String val = fld.substring(sep + 1);
					 fields.put(pos, val);
				 }
				 else {
				 }
			 }
			 else {
				 kind = fld;
				 break;
			 }
		 }
		 String lnum = fields.get(tagFields.LINE);
		 String signature = fields.get(tagFields.SIGNATURE);
		 String classInher = fields.get(tagFields.CLASS);
		 final String whole;
		 final String match;
		 int mlength = p - mstart;
		 if ((p > 0) && (mlength > MIN_METHOD_LINE_LENGTH)) {
			 whole = cutPattern(tagLine, mstart, p);
			 if (mlength < MAX_METHOD_LINE_LENGTH) {
				 match = whole.replaceAll(""[ \t]+"", "" "");
			 }
			 else {
				 LOGGER.log(Level.FINEST, ""Ctags: stripping method"" + "" body for def {
				0}
				 line {
				1}
				(scopes/highlight"" + "" might break)"", new Object[]{
				def, lnum}
				);
				 match = whole.substring(0, MAX_METHOD_LINE_LENGTH).replaceAll( ""[ \t]+"", "" "");
			 }
		 }
		 else {
			 return;
		 }
		 final String type = classInher == null ? kind : kind + "" in "" + classInher;
		 int lineno;
		 try {
			 lineno = Integer.parseUnsignedInt(lnum);
		 }
		 catch (NumberFormatException e) {
			 lineno = 0;
			 LOGGER.log(Level.WARNING, ""CTags line number parsing problem(but"" + "" I will continue with line # 0) for symbol {
			0}
			"", def);
		 }
		 CpatIndex cidx = bestIndexOfTag(lineno, whole, def);
		 addTag(defs, cidx.lineno, def, type, match, classInher, signature, cidx.lineStart, cidx.lineEnd);
		 String[] args;
		 if (signature != null && !signature.equals(""()"") && !signature.startsWith(""() "") && (args = splitSignature(signature)) != null) {
			 for (String arg : args) {
				 if (arg.contains(""="")) {
					 String[] a = arg.split(""="");
					 arg = a[0];
				 }
				 arg = arg.trim();
				 if (arg.length() < 1) {
					 continue;
				 }
				 cidx = bestIndexOfArg(lineno, whole, arg);
				 String name = null;
				 Matcher mname = LAST_UWORD.matcher(arg);
				 if (mname.find()) {
					 name = mname.group(1);
				 }
				 else if (arg.equals(""..."")) {
					 name = arg;
				 }
				 if (name != null) {
					 addTag(defs, cidx.lineno, name, ""argument"", def.trim() + signature.trim(), null, signature, cidx.lineStart, cidx.lineEnd);
				 }
				 else {
					 if (LOGGER.isLoggable(Level.FINEST)) {
						 LOGGER.log(Level.FINEST, ""Not matched arg:{
						0}
						|sig:{
						1}
						"", new Object[]{
						arg, signature}
						);
					 }
				 }
			 }
		 }
		 fields.clear();
	 }
	 private static String cutPattern(String tagLine, int startTab, int endTab) {
		 String cut = tagLine.substring(startTab + 3, endTab);
		 if (cut.endsWith(""$/;
		\"""")) {
			 cut = cut.substring(0, cut.length() - 4);
		 }
		 else if (cut.endsWith(""/;
		\"""")) {
			 cut = cut.substring(0, cut.length() - 3);
		 }
		 else {
			 cut = cut.substring(0, cut.length() - 4);
		 }
		 return cut.replace(""\\\\"", ""\\"").replace(""\\/"", ""/"");
	 }
	 private void addTag(Definitions defs, int lineno, String symbol, String type, String text, String namespace, String signature, int lineStart, int lineEnd) {
		 defs.addTag(lineno, symbol.trim().intern(), type.trim().intern(), text.trim().intern(), namespace == null ? null : namespace.trim().intern(), signature, lineStart, lineEnd);
	 }
	 private CpatIndex bestIndexOfTag(int lineno, String whole, String str) {
		 if (whole.length() < 1) {
			 return new CpatIndex(lineno, 0, 1, true);
		 }
		 String origWhole = whole;
		 int t = tabSize;
		 int s, e;
		 int woff = strictIndexOf(whole, str);
		 if (woff < 0) {
			 String cut = trySplitterCut(lineno - 1, 1);
			 if (cut == null || !cut.startsWith(whole)) {
				 if (LOGGER.isLoggable(Level.FINE)) {
					 String readablecut = cut != null ? cut : ""null\n"";
					 LOGGER.log(Level.FINE, ""Bad cut:{
					0}
					|versus:{
					1}
					|line {
					2}
					"", new Object[]{
					readablecut, whole, lineno}
					);
				 }
			 }
			 else {
				 whole = cut;
				 woff = strictIndexOf(whole, str);
			 }
			 if (woff < 0) {
				 woff = whole.indexOf(str);
			 }
		 }
		 if (woff >= 0) {
			 s = ExpandTabsReader.translate(whole, woff, t);
			 e = ExpandTabsReader.translate(whole, woff + str.length(), t);
			 return new CpatIndex(lineno, s, e);
		 }
		 s = ExpandTabsReader.translate(origWhole, origWhole.length() - 1, t);
		 e = ExpandTabsReader.translate(origWhole, origWhole.length(), t);
		 return new CpatIndex(lineno, s, e, true);
	 }
	 private CpatIndex bestIndexOfArg(int lineno, String whole, String arg) {
		 if (whole.length() < 1) {
			 return new CpatIndex(lineno, 0, 1, true);
		 }
		 int t = tabSize;
		 int s, e;
		 int woff = strictIndexOf(whole, arg);
		 if (woff < 0) {
			 woff = whole.indexOf(arg);
		 }
		 if (woff >= 0) {
			 s = ExpandTabsReader.translate(whole, woff, t);
			 e = ExpandTabsReader.translate(whole, woff + arg.length(), t);
			 return new CpatIndex(lineno, s, e);
		 }
		 StringBuilder bld = new StringBuilder();
		 int spos = 0;
		 boolean lastWhitespace = false;
		 boolean firstNonWhitespace = false;
		 for (int i = 0;
		 i < arg.length();
		 ++i) {
			 char c = arg.charAt(i);
			 if (Character.isWhitespace(c)) {
				 if (!firstNonWhitespace) {
					 ++spos;
				 }
				 else if (!lastWhitespace) {
					 lastWhitespace = true;
					 if (spos < i) {
						 bld.append(Pattern.quote(arg.substring(spos, i)));
					 }
					 bld.append(""\\s*"");
				 }
			 }
			 else {
				 firstNonWhitespace = true;
				 if (lastWhitespace) {
					 lastWhitespace = false;
					 spos = i;
				 }
			 }
		 }
		 if (spos < arg.length()) {
			 bld.append(Pattern.quote(arg.substring(spos)));
		 }
		 if (bld.length() < 1) {
			 if (LOGGER.isLoggable(Level.FINE)) {
				 LOGGER.log(Level.FINE, ""Odd arg:{
				0}
				|versus:{
				1}
				|line {
				2}
				"", new Object[]{
				arg, whole, lineno}
				);
			 }
			 return new CpatIndex(lineno, 0, 1, true);
		 }
		 Pattern argpat = Pattern.compile(bld.toString());
		 PatResult pr = bestMatch(whole, arg, argpat);
		 if (pr.start >= 0) {
			 s = ExpandTabsReader.translate(whole, pr.start, t);
			 e = ExpandTabsReader.translate(whole, pr.end, t);
			 return new CpatIndex(lineno, s, e);
		 }
		 String cut = trySplitterCut(lineno - 1, MAX_CUT_LINES);
		 if (cut == null || !cut.startsWith(whole)) {
			 if (LOGGER.isLoggable(Level.FINE)) {
				 String readablecut = cut != null ? cut : ""null\n"";
				 LOGGER.log(Level.FINE, ""Bad cut:{
				0}
				|versus:{
				1}
				|line {
				2}
				"", new Object[]{
				readablecut, whole, lineno}
				);
			 }
		 }
		 else {
			 pr = bestMatch(cut, arg, argpat);
			 if (pr.start >= 0) {
				 return bestLineOfMatch(lineno, pr, cut);
			 }
		 }
		 s = ExpandTabsReader.translate(whole, whole.length() - 1, t);
		 e = ExpandTabsReader.translate(whole, whole.length(), t);
		 return new CpatIndex(lineno, s, e, true);
	 }
	 private PatResult bestMatch(String whole, String arg, Pattern argpat) {
		 PatResult m = strictMatch(whole, arg, argpat);
		 if (m.start >= 0) {
			 return m;
		 }
		 Matcher marg = argpat.matcher(whole);
		 if (marg.find()) {
			 return new PatResult(marg.start(), marg.end(), marg.group());
		 }
		 return m;
	 }
	 private int strictIndexOf(String whole, String substr) {
		 boolean strictLeft = substr.length() > 0 && WORD_CHAR.matcher( String.valueOf(substr.charAt(0))).matches();
		 boolean strictRight = substr.length() > 0 && WORD_CHAR.matcher( String.valueOf(substr.charAt(substr.length() - 1))).matches();
		 int spos = 0;
		 do {
			 int woff = whole.indexOf(substr, spos);
			 if (woff < 0) {
				 return -1;
			 }
			 spos = woff + 1;
			 String onechar;
			 if (strictLeft && woff > 0) {
				 onechar = String.valueOf(whole.charAt(woff - 1));
				 if (WORD_CHAR.matcher(onechar).matches()) {
					 continue;
				 }
			 }
			 if (strictRight && woff + substr.length() < whole.length()) {
				 onechar = String.valueOf(whole.charAt(woff + substr.length()));
				 if (WORD_CHAR.matcher(onechar).matches()) {
					 continue;
				 }
			 }
			 return woff;
		 }
		 while (spos < whole.length());
		 return -1;
	 }
	 private PatResult strictMatch(String whole, String substr, Pattern pat) {
		 boolean strictLeft = substr.length() > 0 && WORD_CHAR.matcher( String.valueOf(substr.charAt(0))).matches();
		 boolean strictRight = substr.length() > 0 && WORD_CHAR.matcher( String.valueOf(substr.charAt(substr.length() - 1))).matches();
		 Matcher m = pat.matcher(whole);
		 while (m.find()) {
			 String onechar;
			 if (strictLeft && m.start() > 0) {
				 onechar = String.valueOf(whole.charAt(m.start() - 1));
				 if (WORD_CHAR.matcher(onechar).matches()) {
					 continue;
				 }
			 }
			 if (strictRight && m.end() < whole.length()) {
				 onechar = String.valueOf(whole.charAt(m.end()));
				 if (WORD_CHAR.matcher(onechar).matches()) {
					 continue;
				 }
			 }
			 return new PatResult(m.start(), m.end(), m.group());
		 }
		 return new PatResult(-1, -1, null);
	 }
	 private CpatIndex bestLineOfMatch(int lineno, PatResult pr, String cut) {
		 int lpos = splitter.getPosition(lineno - 1);
		 int mpos = lpos + pr.start;
		 int moff = splitter.findLineOffset(mpos);
		 int zpos = lpos + pr.end - 1;
		 int zoff = splitter.findLineOffset(zpos);
		 int t = tabSize;
		 int resoff = moff;
		 int contentLength = 0;
		 String whole = """";
		 int s = 0;
		 int e = 1;
		 for (int ioff = moff;
		 ioff <= zoff;
		 ++ioff) {
			 String iwhole = splitter.getLine(ioff);
			 int ioffpos = splitter.getPosition(ioff);
			 int iendpos = ioffpos + iwhole.length();
			 int i_s = pr.start + lpos < ioffpos ? ioffpos : pr.start + lpos;
			 int i_e = pr.end + lpos > iendpos ? iendpos : pr.end + lpos;
			 if (i_e - i_s > contentLength) {
				 contentLength = i_e - i_s;
				 resoff = ioff;
				 whole = iwhole;
				 s = i_s - ioffpos;
				 e = i_e - ioffpos;
			 }
		 }
		 if (s >= 0 && s < whole.length() && e >= 0 && e <= whole.length()) {
			 s = ExpandTabsReader.translate(whole, s, t);
			 e = ExpandTabsReader.translate(whole, e, t);
			 return new CpatIndex(resoff + 1, s, e);
		 }
		 if (LOGGER.isLoggable(Level.FINE)) {
			 LOGGER.log(Level.FINE, ""Bad fuzzy:{
			0}
			|versus:{
			1}
			|line {
			2}
			 pos {
			3}
			-{
			4}
			|{
			5}
			|"", new Object[]{
			pr.capture, cut, lineno, s, e, whole}
			);
		 }
		 return new CpatIndex(lineno, 0, 1, true);
	 }
	 private static String[] splitSignature(String signature) {
		 int off0 = 0;
		 int offz = signature.length();
		 int soff = off0;
		 int eoff = offz;
		 if (soff >= eoff) {
			 return null;
		 }
		 while (soff < signature.length() && (signature.charAt(soff) == '(' || signature.charAt(soff) == '{
			')) {
				 ++soff;
			 }
		 while (eoff - 1 > soff && (signature.charAt(eoff - 1) == ')' || signature.charAt(eoff - 1) == '}
		')) {
			 --eoff;
		 }
		 if (soff > off0 || eoff < offz) {
			 signature = signature.substring(soff, eoff);
		 }
		 return signature.split("","");
	 }
	 private String trySplitterCut(int lineOffset, int maxLines) {
		 if (splitter == null) {
			 if (splitterSupplier == null || triedSplitterSupplier) {
				 return null;
			 }
			 triedSplitterSupplier = true;
			 splitter = splitterSupplier.get();
			 if (splitter == null) {
				 return null;
			 }
		 }
		 long newCutCacheKey = ((long)lineOffset << 32) | maxLines;
		 if (cutCacheKey == newCutCacheKey) {
			 return cutCacheValue;
		 }
		 StringBuilder cutbld = new StringBuilder();
		 for (int i = lineOffset;
		 i < lineOffset + maxLines && i < splitter.count() && cutbld.length() < MAX_CUT_LENGTH;
		 ++i) {
			 cutbld.append(splitter.getLine(i));
		 }
		 if (cutbld.length() > MAX_CUT_LENGTH) {
			 cutbld.setLength(MAX_CUT_LENGTH);
		 }
		 cutCacheValue = cutbld.toString();
		 cutCacheKey = newCutCacheKey;
		 return cutCacheValue;
	 }
	 private static class CpatIndex {
		 public final int lineno;
		 public final int lineStart;
		 public final int lineEnd;
		 public final boolean imprecise;
		 CpatIndex(int lineno, int lineStart, int lineEnd) {
			 this.lineno = lineno;
			 this.lineStart = lineStart;
			 this.lineEnd = lineEnd;
			 this.imprecise = false;
		 }
		 CpatIndex(int lineno, int lineStart, int lineEnd, boolean imprecise) {
			 this.lineno = lineno;
			 this.lineStart = lineStart;
			 this.lineEnd = lineEnd;
			 this.imprecise = imprecise;
		 }
	 }
	 private static class PatResult {
		 public final int start;
		 public final int end;
		 public final String capture;
		 PatResult(int start, int end, String capture) {
			 this.start = start;
			 this.end = end;
			 this.capture = capture;
		 }
	 }
}",1,0,0,0
"private void createNetwork(int inputNum, Vector<Integer> inputSets, int outNum) {
	this.setNetworkType(NeuralNetworkType.NEURO_FUZZY_REASONER);
	NeuronProperties neuronProperties = new NeuronProperties();
	Layer inLayer = LayerFactory.createLayer(inputNum, neuronProperties);
	this.addLayer(inLayer);
	neuronProperties.setProperty(""transferFunction"",TransferFunctionType.TRAPEZOID);
	Enumeration<Integer> e = inputSets.elements();
	int fuzzySetsNum = 0;
	while (e.hasMoreElements()) {
		Integer i = e.nextElement();
		fuzzySetsNum = fuzzySetsNum + i.intValue();
	}
	Layer setLayer = LayerFactory.createLayer(fuzzySetsNum, neuronProperties);
	this.addLayer(setLayer);
	Enumeration<Integer> en;
	int c = 0;
	 for(Neuron cell : setLayer.getNeurons()) {
		 Trapezoid tf = (Trapezoid) cell.getTransferFunction();
	}
	int s = 0;
	 for (int i = 0;
	 i < inputNum;
	 i++) {
		 Neuron from = inLayer.getNeuronAt(i);
		int jmax = inputSets.elementAt(i).intValue();
		for (int j = 0;
		 j < jmax;
		 j++) {
			Neuron to = setLayer.getNeuronAt(s);
			ConnectionFactory.createConnection(from, to, 1);
			s++;
		}
	}
	neuronProperties.setProperty(""inputFunction"", Min.class);
	neuronProperties.setProperty(""transferFunction"",Linear.class);
	en = inputSets.elements();
	int fuzzyAntNum = 1;
	while (en.hasMoreElements()) {
		Integer i = en.nextElement();
		fuzzyAntNum = fuzzyAntNum * i.intValue();
	}
	Layer ruleLayer = LayerFactory.createLayer(fuzzyAntNum, neuronProperties);
	this.addLayer(ruleLayer);
	int scIdx = 0;
	 for (int i = 0;
	 i < inputNum;
	 i++) {
		 int setsNum = inputSets.elementAt(i).intValue();
		for (int si = 0;
		 si < setsNum;
		 si++) {
			 if (i == 0) {
				Neuron from = setLayer.getNeuronAt(si);
				int connPerCell = fuzzyAntNum / setsNum;
				scIdx = si;
				for (int k = 0;
				 k < connPerCell;
				 k++) {
					 Neuron to = ruleLayer.getNeuronAt(si * connPerCell + k);
					ConnectionFactory.createConnection(from, to, 1);
				}
			 }
			 else {
				scIdx++;
				Neuron from = setLayer.getNeuronAt(scIdx);
				int connPerCell = fuzzyAntNum / setsNum;
				for (int k = 0;
				 k < connPerCell;
				 k++) {
					 int toIdx = si + k * setsNum;
					Neuron to = ruleLayer.getNeuronAt(toIdx);
					ConnectionFactory.createConnection(from, to, 1);
				}
			 }
		 }
	 }
	 neuronProperties = new NeuronProperties();
	neuronProperties.setProperty(""transferFunction"", TransferFunctionType.STEP);
	Layer outLayer = LayerFactory.createLayer(outNum, neuronProperties);
	this.addLayer(outLayer);
	ConnectionFactory.fullConnect(ruleLayer, outLayer);
	NeuralNetworkFactory.setDefaultIO(this);
	this.setLearningRule(new LMS());
}",0,0,1,0
"public class AccountListenerConfig {
	 private String accountName ;
	 private String server ;
	 private String protocol ;
	 public String getAccountName() {
		 return accountName;
	 }
	 public void setAccountName(String accountName) {
		 this.accountName = accountName;
	 }
	 public String getProtocol() {
		 return protocol;
	 }
	 public void setProtocol(String protocol) {
		 this.protocol = protocol;
	 }
	 public String getServer() {
		 return server;
	 }
	 public void setServer(String server) {
		 this.server = server;
	 }
}",0,1,0,0
"public static void connect(String server, int port) {
	 TSocket socket = new TSocket(server, port);
	 if (transport != null) transport.close();
	 if (sessionState.framed) {
		 transport = new TFramedTransport(socket);
	 }
	 else {
		 transport = socket;
	 }
	 TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, true, true);
	 Cassandra.Client cassandraClient = new Cassandra.Client(binaryProtocol);
	 try {
		 transport.open();
	 }
	 catch (Exception e) {
		 if (sessionState.debug) e.printStackTrace();
		 String error = (e.getCause() == null) ? e.getMessage() : e.getCause().getMessage();
		 throw new RuntimeException(""Exception connecting to "" + server + ""/"" + port + "". Reason: "" + error + ""."");
	 }
	 thriftClient = cassandraClient;
	 cliClient = new CliClient(sessionState, thriftClient);
	 if ((sessionState.username != null) && (sessionState.password != null)) {
		 Map<String, String> credentials = new HashMap<String, String>();
		 credentials.put(SimpleAuthenticator.USERNAME_KEY, sessionState.username);
		 credentials.put(SimpleAuthenticator.PASSWORD_KEY, sessionState.password);
		 AuthenticationRequest authRequest = new AuthenticationRequest(credentials);
		 try {
			 thriftClient.login(authRequest);
			 cliClient.setUsername(sessionState.username);
		 }
		 catch (AuthenticationException e) {
			 thriftClient = null;
			 sessionState.err.println(""Exception during authentication to the cassandra node, "" + ""Verify the keyspace exists, and that you are using the correct credentials."");
			 return;
		 }
		 catch (AuthorizationException e) {
			 thriftClient = null;
			 sessionState.err.println(""You are not authorized to use keyspace: "" + sessionState.keyspace);
			 return;
		 }
		 catch (TException e) {
			 thriftClient = null;
			 sessionState.err.println(""Login failure. Did you specify 'keyspace', 'username' and 'password'?"");
			 return;
		 }
	 }
	 if (sessionState.keyspace != null) {
		 try {
			 sessionState.keyspace = CliCompiler.getKeySpace(sessionState.keyspace, thriftClient.describe_keyspaces());
			;
			 thriftClient.set_keyspace(sessionState.keyspace);
			 cliClient.setKeySpace(sessionState.keyspace);
			 updateCompletor(CliUtils.getCfNamesByKeySpace(cliClient.getKSMetaData(sessionState.keyspace)));
		 }
		 catch (InvalidRequestException e) {
			 sessionState.err.println(""Keyspace "" + sessionState.keyspace + "" not found"");
			 return;
		 }
		 catch (TException e) {
			 sessionState.err.println(""Did you specify 'keyspace'?"");
			 return;
		 }
		 catch (NotFoundException e) {
			 sessionState.err.println(""Keyspace "" + sessionState.keyspace + "" not found"");
			 return;
		 }
	 }
	 String clusterName;
	 try {
		 clusterName = thriftClient.describe_cluster_name();
	 }
	 catch (Exception e) {
		 sessionState.err.println(""Exception retrieving information about the cassandra node, check you have connected to the thrift port."");
		 if (sessionState.debug) e.printStackTrace();
		 return;
	 }
	 sessionState.out.printf(""Connected to: \""%s\"" on %s/%d%n"", clusterName, server, port);
 }",0,0,1,0
"public static class Undertow {
	private DataSize maxHttpPostSize = DataSize.ofBytes(-1);
	private DataSize bufferSize;
	private Integer ioThreads;
	private Integer workerThreads;
	private Boolean directBuffers;
	private boolean eagerFilterInit = true;
	private final Accesslog accesslog = new Accesslog();
	public DataSize getMaxHttpPostSize() {
		return this.maxHttpPostSize;
	}
	public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
		this.maxHttpPostSize = maxHttpPostSize;
	}
	public DataSize getBufferSize() {
		return this.bufferSize;
	}
	public void setBufferSize(DataSize bufferSize) {
		this.bufferSize = bufferSize;
	}
	public Integer getIoThreads() {
		return this.ioThreads;
	}
	public void setIoThreads(Integer ioThreads) {
		this.ioThreads = ioThreads;
	}
	public Integer getWorkerThreads() {
		return this.workerThreads;
	}
	public void setWorkerThreads(Integer workerThreads) {
		this.workerThreads = workerThreads;
	}
	public Boolean getDirectBuffers() {
		return this.directBuffers;
	}
	public void setDirectBuffers(Boolean directBuffers) {
		this.directBuffers = directBuffers;
	}
	public boolean isEagerFilterInit() {
		return this.eagerFilterInit;
	}
	public void setEagerFilterInit(boolean eagerFilterInit) {
		this.eagerFilterInit = eagerFilterInit;
	}
	public Accesslog getAccesslog() {
		return this.accesslog;
	}
	public static class Accesslog {
		private boolean enabled = false;
		private String pattern = ""common"";
		protected String prefix = ""access_log."";
		private String suffix = ""log"";
		private File dir = new File(""logs"");
		private boolean rotate = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String getPattern() {
			return this.pattern;
		}
		public void setPattern(String pattern) {
			this.pattern = pattern;
		}
		public String getPrefix() {
			return this.prefix;
		}
		public void setPrefix(String prefix) {
			this.prefix = prefix;
		}
		public String getSuffix() {
			return this.suffix;
		}
		public void setSuffix(String suffix) {
			this.suffix = suffix;
		}
		public File getDir() {
			return this.dir;
		}
		public void setDir(File dir) {
			this.dir = dir;
		}
		public boolean isRotate() {
			return this.rotate;
		}
		public void setRotate(boolean rotate) {
			this.rotate = rotate;
		}
	}
}",1,1,0,0
"public String toString() {
	 return ""ExecInfo{
	"" + ""id='"" + id + '\'' + "", container="" + container + "", processConfig="" + processConfig + "", openStdout='"" + openStdout + '\'' + "", openStderr='"" + openStderr + '\'' + "", openStdin='"" + openStdin + '\'' + "", running='"" + running + '\'' + "", exitCode='"" + exitCode + '\'' + '}
	';
 }",0,0,1,0
"protected boolean isUnreachableException(Throwable ex) {
	 if (super.isUnreachableException(ex)) {
		 return true;
	 }
	 if (ex instanceof SocketTimeoutException) return true;
	 List<String> exceptionList = new ArrayList<>();
	 exceptionList.add(ex.getClass().getName());
	 Throwable t = ex.getCause();
	 int depth = 0;
	 while (t != null && depth < 5) {
		 exceptionList.add(t.getClass().getName());
		 depth++;
		 if (t instanceof ConnectException) {
			 return true;
		 }
		 t = t.getCause();
	 }
	 logger.trace(""Not an unreachable exception with causes {
	}
	"", exceptionList);
	 return false;
 }",0,0,1,0
"public void setForceReadOnly(boolean f) {
	 force = f;
 }",0,0,0,0
"public abstract class Arguments {
	 private final StringBuilder query;
	 private final Set<String> arguments = new HashSet<>();
	 private boolean firstArgument;
	 protected Arguments(StringBuilder query, boolean firstArgument) {
		 this.query = query;
		 this.firstArgument = firstArgument;
	 }
	 public static void end(Arguments arguments) {
		 if (!arguments.firstArgument) {
			 arguments.query.append(')');
		 }
	 }
	 protected void startArgument(String name) {
		 if (!arguments.add(name)) {
			 throw new RuntimeException(""Already specified argument "" + name);
		 }
		 if (firstArgument) {
			 firstArgument = false;
			 query.append('(');
		 }
		 else {
			 query.append(',');
		 }
		 query.append(name);
		 query.append(':');
	 }
}",0,0,0,0
"private static Class<T> stringToClass(String klass) throws FrontendException {
	 if (""string"".equalsIgnoreCase(klass)) {
		 return String.class;
	 }
	 else if (""int"".equalsIgnoreCase(klass)) {
		 return Integer.TYPE;
	 }
	 else if (""double"".equalsIgnoreCase(klass)) {
		 return Double.TYPE;
	 }
	 else if (""float"".equalsIgnoreCase(klass)){
		 return Float.TYPE;
	 }
	 else if (""long"".equalsIgnoreCase(klass)) {
		 return Long.TYPE;
	 }
	 else if (""double[]"".equalsIgnoreCase(klass)) {
		 return DOUBLE_ARRAY_CLASS;
	 }
	 else if (""int[]"".equalsIgnoreCase(klass)) {
		 return INT_ARRAY_CLASS;
	 }
	 else if (""long[]"".equalsIgnoreCase(klass)) {
		 return LONG_ARRAY_CLASS;
	 }
	 else if (""float[]"".equalsIgnoreCase(klass)) {
		 return FLOAT_ARRAY_CLASS;
	 }
	 else if (""string[]"".equalsIgnoreCase(klass)) {
		 return STRING_ARRAY_CLASS;
	 }
	 else {
		 throw new FrontendException(""unable to find matching class for "" + klass);
	 }
 }",0,0,1,0
"protected final String parsePublicId(char quoteChar, String errorMsg) throws XMLStreamException {
	 char[] buf = getNameBuffer(-1);
	 int ptr = 0;
	 boolean spaceToAdd = false;
	 while (true) {
		 char c = (mInputPtr < mInputEnd) ? mInputBuffer[mInputPtr++] : getNextChar(errorMsg);
		 if (c == quoteChar) {
			 break;
		 }
		 if (c == '\n') {
			 markLF();
			 spaceToAdd = true;
			 continue;
		 }
		 else if (c == '\r') {
			 if (peekNext() == '\n') {
				 ++mInputPtr;
			 }
			 spaceToAdd = true;
			 continue;
		 }
		 else if (c == CHAR_SPACE) {
			 spaceToAdd = true;
			 continue;
		 }
		 else {
			 if ((c >= VALID_PUBID_CHAR_COUNT) || sPubidValidity[c] != PUBID_CHAR_VALID_B) {
				 throwUnexpectedChar(c, "" in public identifier"");
			 }
		 }
		 if (ptr >= buf.length) {
			 buf = expandBy50Pct(buf);
		 }
		 if (spaceToAdd) {
			 if (c == CHAR_SPACE) {
				 continue;
			 }
			 spaceToAdd = false;
			 if (ptr > 0) {
				 buf[ptr++] = CHAR_SPACE;
				 if (ptr >= buf.length) {
					 buf = expandBy50Pct(buf);
				 }
			 }
		 }
		 buf[ptr++] = c;
	 }
	 return (ptr == 0) ? """" : new String(buf, 0, ptr);
 }",0,0,1,0
"public class InverseMapper extends MapReduceBase implements Mapper {
	 public void map(WritableComparable key, Writable value, OutputCollector output, Reporter reporter) throws IOException {
		 output.collect((WritableComparable)value, key);
	 }
}",0,0,0,0
"XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias, XSLTElementDef[] elements, XSLTAttributeDef[] attributes, XSLTElementProcessor contentHandler, Class classObject, boolean has_order, int order, boolean multiAllowed);",0,0,0,1
"public final void write(DataOutput out) throws IOException {
	 out.writeInt(VERSION);
	 Text.writeString(out, url);
	 Text.writeString(out, base);
	 out.writeInt(content.length);
	 out.write(content);
	 Text.writeString(out, contentType);
	 metadata.write(out);
 }",0,0,0,0
"public Iterator getHelpers() {
	 return new ConstructingIterator(helpers.iterator());
 }",0,0,0,0
"public Proxy(InetAddress local, int local_port, InetAddress remote, int remote_port, boolean verbose, boolean debug);",0,0,0,1
"public class DeploymentPlannersResponse extends BaseResponse {
	 private String name;
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
}",0,1,0,0
"public class DefaultItemReuseStrategy implements IItemReuseStrategy{
	private static final long serialVersionUID = 1L;
	private static final IItemReuseStrategy instance = new DefaultItemReuseStrategy();
	public static IItemReuseStrategy getInstance(){
		return instance;
	}
	public <T> Iterator<Item<T>> getItems(final IItemFactory<T> factory,final Iterator<IModel<T>> newModels, Iterator<Item<T>> existingItems){
		return new Iterator<Item<T>>(){
			private int index = 0;
			public void remove(){
				throw new UnsupportedOperationException();
			}
			public boolean hasNext(){
				return newModels.hasNext();
			}
			public Item<T> next(){
				IModel<T> model = newModels.next();
				Item<T> item = factory.newItem(index, model);
				index++;
				return item;
			}
		}
		;
	}
}",0,0,0,0
"private File makeAbsolute(File f) {
	 if (isAbsolute(f)) {
		 return f;
	 }
	 else {
		 return new File(workingDir, f.getPath());
	 }
 }",0,0,0,0
"public class TriplesOrQuadsReader extends AbstractRdfReader<Quad, QuadWritable> {
	 protected RecordReader<LongWritable, QuadWritable> selectRecordReader(Lang lang) throws IOException {
		 if (!RDFLanguages.isQuads(lang) && !RDFLanguages.isTriples(lang)) throw new IOException(lang.getLabel() + "" is not a RDF triples/quads format"");
		 if (HadoopRdfIORegistry.hasQuadReader(lang)) {
			 return HadoopRdfIORegistry.createQuadReader(lang);
		 }
		 else {
			 return new TriplesToQuadsReader(HadoopRdfIORegistry.createTripleReader(lang));
		 }
	 }
	 protected Node getGraphNode() {
		 return Quad.defaultGraphNodeGenerated;
	 }
}",1,0,0,0
"public class AccumulatorBagCount extends EvalFunc<Integer> implements Accumulator<Integer> {
	 int count = 0;
	 public AccumulatorBagCount() {
	 }
	 public void accumulate(Tuple tuple) throws IOException {
		 DataBag databag = (DataBag)tuple.get(0);
		 if(databag == null) return;
		 Iterator<Tuple> iterator = databag.iterator();
		 while(iterator.hasNext()) {
			 iterator.next();
			 count++;
		 }
	 }
	 public Integer getValue() {
		 return new Integer(count);
	 }
	 public void cleanup() {
		 count = 0;
	 }
	 public Integer exec(Tuple tuple) throws IOException {
		 throw new IOException(""exec() should not be called."");
	 }
}",1,0,0,0
"private synchronized void checkHealth() {
	 CalculatedStatus status = calculateStatus();
	 boolean healthy = status.isHealthy();
	 long now = System.currentTimeMillis();
	 if (healthy) {
		 stateLastGood.set(now);
		 if (lastPublished == LastPublished.FAILED) {
			 if (currentRecoveryStartTime == null) {
				 LOG.info(""{
				}
				 check for {
				}
				, now recovering: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
				 currentRecoveryStartTime = now;
				 schedulePublish();
			 }
			 else {
				 if (LOG.isTraceEnabled()) LOG.trace(""{
				}
				 check for {
				}
				, continuing recovering: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
			 }
		 }
		 else {
			 if (currentFailureStartTime != null) {
				 LOG.info(""{
				}
				 check for {
				}
				, now healthy: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
				 currentFailureStartTime = null;
			 }
			 else {
				 if (LOG.isTraceEnabled()) LOG.trace(""{
				}
				 check for {
				}
				, still healthy: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
			 }
		 }
	 }
	 else {
		 stateLastFail.set(now);
		 if (lastPublished != LastPublished.FAILED) {
			 if (currentFailureStartTime == null) {
				 LOG.info(""{
				}
				 check for {
				}
				, now failing: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
				 currentFailureStartTime = now;
				 schedulePublish();
			 }
			 else {
				 if (LOG.isTraceEnabled()) LOG.trace(""{
				}
				 check for {
				}
				, continuing failing: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
			 }
		 }
		 else {
			 if (currentRecoveryStartTime != null) {
				 LOG.info(""{
				}
				 check for {
				}
				, now failing: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
				 currentRecoveryStartTime = null;
			 }
			 else {
				 if (LOG.isTraceEnabled()) LOG.trace(""{
				}
				 check for {
				}
				, still failed: {
				}
				"", new Object[] {
				this, entity, getDescription(status)}
				);
			 }
		 }
	 }
 }",0,0,1,0
"public RExecSubTask createRead() {
	 RExecSubTask task = (RExecSubTask) new RExecRead();
	 rexecTasks.addElement(task);
	 return task;
 }",0,0,0,0
"public void updateModel(){
	if (getModel() != null){
		super.updateModel();
	}
}",0,0,0,0
"public class SpiderWebPlot extends Plot implements Cloneable, Serializable {
	 private static final long serialVersionUID = -5376340422031599463L;
	 public static final double DEFAULT_HEAD = 0.01;
	 public static final double DEFAULT_AXIS_LABEL_GAP = 0.10;
	 public static final double DEFAULT_INTERIOR_GAP = 0.25;
	 public static final double MAX_INTERIOR_GAP = 0.40;
	 public static final double DEFAULT_START_ANGLE = 90.0;
	 public static final Font DEFAULT_LABEL_FONT = new Font(""SansSerif"", Font.PLAIN, 10);
	 public static final Paint DEFAULT_LABEL_PAINT = Color.black;
	 public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255, 255, 192);
	 public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black;
	 public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke(0.5f);
	 public static final Paint DEFAULT_LABEL_SHADOW_PAINT = Color.lightGray;
	 public static final double DEFAULT_MAX_VALUE = -1.0;
	 protected double headPercent;
	 private double interiorGap;
	 private double axisLabelGap;
	 private transient Paint axisLinePaint;
	 private transient Stroke axisLineStroke;
	 private CategoryDataset dataset;
	 private double maxValue;
	 private TableOrder dataExtractOrder;
	 private double startAngle;
	 private Rotation direction;
	 private transient Shape legendItemShape;
	 private transient Paint seriesPaint;
	 private PaintList seriesPaintList;
	 private transient Paint baseSeriesPaint;
	 private transient Paint seriesOutlinePaint;
	 private PaintList seriesOutlinePaintList;
	 private transient Paint baseSeriesOutlinePaint;
	 private transient Stroke seriesOutlineStroke;
	 private StrokeList seriesOutlineStrokeList;
	 private transient Stroke baseSeriesOutlineStroke;
	 private Font labelFont;
	 private transient Paint labelPaint;
	 private CategoryItemLabelGenerator labelGenerator;
	 private boolean webFilled = true;
	 private CategoryToolTipGenerator toolTipGenerator;
	 private CategoryURLGenerator urlGenerator;
	 public SpiderWebPlot() {
		 this(null);
	 }
	 public SpiderWebPlot(CategoryDataset dataset) {
		 this(dataset, TableOrder.BY_ROW);
	 }
	 public SpiderWebPlot(CategoryDataset dataset, TableOrder extract) {
		 super();
		 if (extract == null) {
			 throw new IllegalArgumentException(""Null 'extract' argument."");
		 }
		 this.dataset = dataset;
		 if (dataset != null) {
			 dataset.addChangeListener(this);
		 }
		 this.dataExtractOrder = extract;
		 this.headPercent = DEFAULT_HEAD;
		 this.axisLabelGap = DEFAULT_AXIS_LABEL_GAP;
		 this.axisLinePaint = Color.black;
		 this.axisLineStroke = new BasicStroke(1.0f);
		 this.interiorGap = DEFAULT_INTERIOR_GAP;
		 this.startAngle = DEFAULT_START_ANGLE;
		 this.direction = Rotation.CLOCKWISE;
		 this.maxValue = DEFAULT_MAX_VALUE;
		 this.seriesPaint = null;
		 this.seriesPaintList = new PaintList();
		 this.baseSeriesPaint = null;
		 this.seriesOutlinePaint = null;
		 this.seriesOutlinePaintList = new PaintList();
		 this.baseSeriesOutlinePaint = DEFAULT_OUTLINE_PAINT;
		 this.seriesOutlineStroke = null;
		 this.seriesOutlineStrokeList = new StrokeList();
		 this.baseSeriesOutlineStroke = DEFAULT_OUTLINE_STROKE;
		 this.labelFont = DEFAULT_LABEL_FONT;
		 this.labelPaint = DEFAULT_LABEL_PAINT;
		 this.labelGenerator = new StandardCategoryItemLabelGenerator();
		 this.legendItemShape = DEFAULT_LEGEND_ITEM_CIRCLE;
	 }
	 public String getPlotType() {
		 return (""Spider Web Plot"");
	 }
	 public CategoryDataset getDataset() {
		 return this.dataset;
	 }
	 public void setDataset(CategoryDataset dataset) {
		 if (this.dataset != null) {
			 this.dataset.removeChangeListener(this);
		 }
		 this.dataset = dataset;
		 if (dataset != null) {
			 setDatasetGroup(dataset.getGroup());
			 dataset.addChangeListener(this);
		 }
		 datasetChanged(new DatasetChangeEvent(this, dataset));
	 }
	 public boolean isWebFilled() {
		 return this.webFilled;
	 }
	 public void setWebFilled(boolean flag) {
		 this.webFilled = flag;
		 fireChangeEvent();
	 }
	 public TableOrder getDataExtractOrder() {
		 return this.dataExtractOrder;
	 }
	 public void setDataExtractOrder(TableOrder order) {
		 if (order == null) {
			 throw new IllegalArgumentException(""Null 'order' argument"");
		 }
		 this.dataExtractOrder = order;
		 fireChangeEvent();
	 }
	 public double getHeadPercent() {
		 return this.headPercent;
	 }
	 public void setHeadPercent(double percent) {
		 this.headPercent = percent;
		 fireChangeEvent();
	 }
	 public double getStartAngle() {
		 return this.startAngle;
	 }
	 public void setStartAngle(double angle) {
		 this.startAngle = angle;
		 fireChangeEvent();
	 }
	 public double getMaxValue() {
		 return this.maxValue;
	 }
	 public void setMaxValue(double value) {
		 this.maxValue = value;
		 fireChangeEvent();
	 }
	 public Rotation getDirection() {
		 return this.direction;
	 }
	 public void setDirection(Rotation direction) {
		 if (direction == null) {
			 throw new IllegalArgumentException(""Null 'direction' argument."");
		 }
		 this.direction = direction;
		 fireChangeEvent();
	 }
	 public double getInteriorGap() {
		 return this.interiorGap;
	 }
	 public void setInteriorGap(double percent) {
		 if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {
			 throw new IllegalArgumentException( ""Percentage outside valid range."");
		 }
		 if (this.interiorGap != percent) {
			 this.interiorGap = percent;
			 fireChangeEvent();
		 }
	 }
	 public double getAxisLabelGap() {
		 return this.axisLabelGap;
	 }
	 public void setAxisLabelGap(double gap) {
		 this.axisLabelGap = gap;
		 fireChangeEvent();
	 }
	 public Paint getAxisLinePaint() {
		 return this.axisLinePaint;
	 }
	 public void setAxisLinePaint(Paint paint) {
		 if (paint == null) {
			 throw new IllegalArgumentException(""Null 'paint' argument."");
		 }
		 this.axisLinePaint = paint;
		 fireChangeEvent();
	 }
	 public Stroke getAxisLineStroke() {
		 return this.axisLineStroke;
	 }
	 public void setAxisLineStroke(Stroke stroke) {
		 if (stroke == null) {
			 throw new IllegalArgumentException(""Null 'stroke' argument."");
		 }
		 this.axisLineStroke = stroke;
		 fireChangeEvent();
	 }
	 public Paint getSeriesPaint() {
		 return this.seriesPaint;
	 }
	 public void setSeriesPaint(Paint paint) {
		 this.seriesPaint = paint;
		 fireChangeEvent();
	 }
	 public Paint getSeriesPaint(int series) {
		 if (this.seriesPaint != null) {
			 return this.seriesPaint;
		 }
		 Paint result = this.seriesPaintList.getPaint(series);
		 if (result == null) {
			 DrawingSupplier supplier = getDrawingSupplier();
			 if (supplier != null) {
				 Paint p = supplier.getNextPaint();
				 this.seriesPaintList.setPaint(series, p);
				 result = p;
			 }
			 else {
				 result = this.baseSeriesPaint;
			 }
		 }
		 return result;
	 }
	 public void setSeriesPaint(int series, Paint paint) {
		 this.seriesPaintList.setPaint(series, paint);
		 fireChangeEvent();
	 }
	 public Paint getBaseSeriesPaint() {
		 return this.baseSeriesPaint;
	 }
	 public void setBaseSeriesPaint(Paint paint) {
		 if (paint == null) {
			 throw new IllegalArgumentException(""Null 'paint' argument."");
		 }
		 this.baseSeriesPaint = paint;
		 fireChangeEvent();
	 }
	 public Paint getSeriesOutlinePaint() {
		 return this.seriesOutlinePaint;
	 }
	 public void setSeriesOutlinePaint(Paint paint) {
		 this.seriesOutlinePaint = paint;
		 fireChangeEvent();
	 }
	 public Paint getSeriesOutlinePaint(int series) {
		 if (this.seriesOutlinePaint != null) {
			 return this.seriesOutlinePaint;
		 }
		 Paint result = this.seriesOutlinePaintList.getPaint(series);
		 if (result == null) {
			 result = this.baseSeriesOutlinePaint;
		 }
		 return result;
	 }
	 public void setSeriesOutlinePaint(int series, Paint paint) {
		 this.seriesOutlinePaintList.setPaint(series, paint);
		 fireChangeEvent();
	 }
	 public Paint getBaseSeriesOutlinePaint() {
		 return this.baseSeriesOutlinePaint;
	 }
	 public void setBaseSeriesOutlinePaint(Paint paint) {
		 if (paint == null) {
			 throw new IllegalArgumentException(""Null 'paint' argument."");
		 }
		 this.baseSeriesOutlinePaint = paint;
		 fireChangeEvent();
	 }
	 public Stroke getSeriesOutlineStroke() {
		 return this.seriesOutlineStroke;
	 }
	 public void setSeriesOutlineStroke(Stroke stroke) {
		 this.seriesOutlineStroke = stroke;
		 fireChangeEvent();
	 }
	 public Stroke getSeriesOutlineStroke(int series) {
		 if (this.seriesOutlineStroke != null) {
			 return this.seriesOutlineStroke;
		 }
		 Stroke result = this.seriesOutlineStrokeList.getStroke(series);
		 if (result == null) {
			 result = this.baseSeriesOutlineStroke;
		 }
		 return result;
	 }
	 public void setSeriesOutlineStroke(int series, Stroke stroke) {
		 this.seriesOutlineStrokeList.setStroke(series, stroke);
		 fireChangeEvent();
	 }
	 public Stroke getBaseSeriesOutlineStroke() {
		 return this.baseSeriesOutlineStroke;
	 }
	 public void setBaseSeriesOutlineStroke(Stroke stroke) {
		 if (stroke == null) {
			 throw new IllegalArgumentException(""Null 'stroke' argument."");
		 }
		 this.baseSeriesOutlineStroke = stroke;
		 fireChangeEvent();
	 }
	 public Shape getLegendItemShape() {
		 return this.legendItemShape;
	 }
	 public void setLegendItemShape(Shape shape) {
		 if (shape == null) {
			 throw new IllegalArgumentException(""Null 'shape' argument."");
		 }
		 this.legendItemShape = shape;
		 fireChangeEvent();
	 }
	 public Font getLabelFont() {
		 return this.labelFont;
	 }
	 public void setLabelFont(Font font) {
		 if (font == null) {
			 throw new IllegalArgumentException(""Null 'font' argument."");
		 }
		 this.labelFont = font;
		 fireChangeEvent();
	 }
	 public Paint getLabelPaint() {
		 return this.labelPaint;
	 }
	 public void setLabelPaint(Paint paint) {
		 if (paint == null) {
			 throw new IllegalArgumentException(""Null 'paint' argument."");
		 }
		 this.labelPaint = paint;
		 fireChangeEvent();
	 }
	 public CategoryItemLabelGenerator getLabelGenerator() {
		 return this.labelGenerator;
	 }
	 public void setLabelGenerator(CategoryItemLabelGenerator generator) {
		 if (generator == null) {
			 throw new IllegalArgumentException(""Null 'generator' argument."");
		 }
		 this.labelGenerator = generator;
	 }
	 public CategoryToolTipGenerator getToolTipGenerator() {
		 return this.toolTipGenerator;
	 }
	 public void setToolTipGenerator(CategoryToolTipGenerator generator) {
		 this.toolTipGenerator = generator;
		 fireChangeEvent();
	 }
	 public CategoryURLGenerator getURLGenerator() {
		 return this.urlGenerator;
	 }
	 public void setURLGenerator(CategoryURLGenerator generator) {
		 this.urlGenerator = generator;
		 fireChangeEvent();
	 }
	 public LegendItemCollection getLegendItems() {
		 LegendItemCollection result = new LegendItemCollection();
		 if (getDataset() == null) {
			 return result;
		 }
		 List keys = null;
		 if (this.dataExtractOrder == TableOrder.BY_ROW) {
			 keys = this.dataset.getRowKeys();
		 }
		 else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {
			 keys = this.dataset.getColumnKeys();
		 }
		 if (keys != null) {
			 int series = 0;
			 Iterator iterator = keys.iterator();
			 Shape shape = getLegendItemShape();
			 while (iterator.hasNext()) {
				 String label = iterator.next().toString();
				 String description = label;
				 Paint paint = getSeriesPaint(series);
				 Paint outlinePaint = getSeriesOutlinePaint(series);
				 Stroke stroke = getSeriesOutlineStroke(series);
				 LegendItem item = new LegendItem(label, description, null, null, shape, paint, stroke, outlinePaint);
				 item.setDataset(getDataset());
				 result.add(item);
				 series++;
			 }
		 }
		 return result;
	 }
	 protected Point2D getWebPoint(Rectangle2D bounds, double angle, double length) {
		 double angrad = Math.toRadians(angle);
		 double x = Math.cos(angrad) * length * bounds.getWidth() / 2;
		 double y = -Math.sin(angrad) * length * bounds.getHeight() / 2;
		 return new Point2D.Double(bounds.getX() + x + bounds.getWidth() / 2, bounds.getY() + y + bounds.getHeight() / 2);
	 }
	 public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {
		 RectangleInsets insets = getInsets();
		 insets.trim(area);
		 if (info != null) {
			 info.setPlotArea(area);
			 info.setDataArea(area);
		 }
		 drawBackground(g2, area);
		 drawOutline(g2, area);
		 Shape savedClip = g2.getClip();
		 g2.clip(area);
		 Composite originalComposite = g2.getComposite();
		 g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha()));
		 if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {
			 int seriesCount = 0, catCount = 0;
			 if (this.dataExtractOrder == TableOrder.BY_ROW) {
				 seriesCount = this.dataset.getRowCount();
				 catCount = this.dataset.getColumnCount();
			 }
			 else {
				 seriesCount = this.dataset.getColumnCount();
				 catCount = this.dataset.getRowCount();
			 }
			 if (this.maxValue == DEFAULT_MAX_VALUE) calculateMaxValue(seriesCount, catCount);
			 double gapHorizontal = area.getWidth() * getInteriorGap();
			 double gapVertical = area.getHeight() * getInteriorGap();
			 double X = area.getX() + gapHorizontal / 2;
			 double Y = area.getY() + gapVertical / 2;
			 double W = area.getWidth() - gapHorizontal;
			 double H = area.getHeight() - gapVertical;
			 double headW = area.getWidth() * this.headPercent;
			 double headH = area.getHeight() * this.headPercent;
			 double min = Math.min(W, H) / 2;
			 X = (X + X + W) / 2 - min;
			 Y = (Y + Y + H) / 2 - min;
			 W = 2 * min;
			 H = 2 * min;
			 Point2D centre = new Point2D.Double(X + W / 2, Y + H / 2);
			 Rectangle2D radarArea = new Rectangle2D.Double(X, Y, W, H);
			 for (int cat = 0;
			 cat < catCount;
			 cat++) {
				 double angle = getStartAngle() + (getDirection().getFactor() * cat * 360 / catCount);
				 Point2D endPoint = getWebPoint(radarArea, angle, 1);
				 Line2D line = new Line2D.Double(centre, endPoint);
				 g2.setPaint(this.axisLinePaint);
				 g2.setStroke(this.axisLineStroke);
				 g2.draw(line);
				 drawLabel(g2, radarArea, 0.0, cat, angle, 360.0 / catCount);
			 }
			 for (int series = 0;
			 series < seriesCount;
			 series++) {
				 drawRadarPoly(g2, radarArea, centre, info, series, catCount, headH, headW);
			 }
		 }
		 else {
			 drawNoDataMessage(g2, area);
		 }
		 g2.setClip(savedClip);
		 g2.setComposite(originalComposite);
		 drawOutline(g2, area);
	 }
	 private void calculateMaxValue(int seriesCount, int catCount) {
		 double v = 0;
		 Number nV = null;
		 for (int seriesIndex = 0;
		 seriesIndex < seriesCount;
		 seriesIndex++) {
			 for (int catIndex = 0;
			 catIndex < catCount;
			 catIndex++) {
				 nV = getPlotValue(seriesIndex, catIndex);
				 if (nV != null) {
					 v = nV.doubleValue();
					 if (v > this.maxValue) {
						 this.maxValue = v;
					 }
				 }
			 }
		 }
	 }
	 protected void drawRadarPoly(Graphics2D g2, Rectangle2D plotArea, Point2D centre, PlotRenderingInfo info, int series, int catCount, double headH, double headW) {
		 Polygon polygon = new Polygon();
		 EntityCollection entities = null;
		 if (info != null) {
			 entities = info.getOwner().getEntityCollection();
		 }
		 for (int cat = 0;
		 cat < catCount;
		 cat++) {
			 Number dataValue = getPlotValue(series, cat);
			 if (dataValue != null) {
				 double value = dataValue.doubleValue();
				 if (value >= 0) {
					 double angle = getStartAngle() + (getDirection().getFactor() * cat * 360 / catCount);
					 Point2D point = getWebPoint(plotArea, angle, value / this.maxValue);
					 polygon.addPoint((int) point.getX(), (int) point.getY());
					 Paint paint = getSeriesPaint(series);
					 Paint outlinePaint = getSeriesOutlinePaint(series);
					 Stroke outlineStroke = getSeriesOutlineStroke(series);
					 Ellipse2D head = new Ellipse2D.Double(point.getX() - headW / 2, point.getY() - headH / 2, headW, headH);
					 g2.setPaint(paint);
					 g2.fill(head);
					 g2.setStroke(outlineStroke);
					 g2.setPaint(outlinePaint);
					 g2.draw(head);
					 if (entities != null) {
						 int row = 0;
						 int col = 0;
						 if (this.dataExtractOrder == TableOrder.BY_ROW) {
							 row = series;
							 col = cat;
						 }
						 else {
							 row = cat;
							 col = series;
						 }
						 String tip = null;
						 if (this.toolTipGenerator != null) {
							 tip = this.toolTipGenerator.generateToolTip( this.dataset, row, col);
						 }
						 String url = null;
						 if (this.urlGenerator != null) {
							 url = this.urlGenerator.generateURL(this.dataset, row, col);
						 }
						 Shape area = new Rectangle( (int) (point.getX() - headW), (int) (point.getY() - headH), (int) (headW * 2), (int) (headH * 2));
						 CategoryItemEntity entity = new CategoryItemEntity( area, tip, url, this.dataset, this.dataset.getRowKey(row), this.dataset.getColumnKey(col));
						 entities.add(entity);
					 }
				 }
			 }
		 }
		 Paint paint = getSeriesPaint(series);
		 g2.setPaint(paint);
		 g2.setStroke(getSeriesOutlineStroke(series));
		 g2.draw(polygon);
		 if (this.webFilled) {
			 g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.1f));
			 g2.fill(polygon);
			 g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha()));
		 }
	 }
	 protected Number getPlotValue(int series, int cat) {
		 Number value = null;
		 if (this.dataExtractOrder == TableOrder.BY_ROW) {
			 value = this.dataset.getValue(series, cat);
		 }
		 else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {
			 value = this.dataset.getValue(cat, series);
		 }
		 return value;
	 }
	 protected void drawLabel(Graphics2D g2, Rectangle2D plotArea, double value, int cat, double startAngle, double extent) {
		 FontRenderContext frc = g2.getFontRenderContext();
		 String label = null;
		 if (this.dataExtractOrder == TableOrder.BY_ROW) {
			 label = this.labelGenerator.generateColumnLabel(this.dataset, cat);
		 }
		 else {
			 label = this.labelGenerator.generateRowLabel(this.dataset, cat);
		 }
		 Rectangle2D labelBounds = getLabelFont().getStringBounds(label, frc);
		 LineMetrics lm = getLabelFont().getLineMetrics(label, frc);
		 double ascent = lm.getAscent();
		 Point2D labelLocation = calculateLabelLocation(labelBounds, ascent, plotArea, startAngle);
		 Composite saveComposite = g2.getComposite();
		 g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));
		 g2.setPaint(getLabelPaint());
		 g2.setFont(getLabelFont());
		 g2.drawString(label, (float) labelLocation.getX(), (float) labelLocation.getY());
		 g2.setComposite(saveComposite);
	 }
	 protected Point2D calculateLabelLocation(Rectangle2D labelBounds, double ascent, Rectangle2D plotArea, double startAngle) {
		 Arc2D arc1 = new Arc2D.Double(plotArea, startAngle, 0, Arc2D.OPEN);
		 Point2D point1 = arc1.getEndPoint();
		 double deltaX = -(point1.getX() - plotArea.getCenterX()) double deltaY = -(point1.getY() - plotArea.getCenterY()) double labelX = point1.getX() - deltaX;
		 double labelY = point1.getY() - deltaY;
		 if (labelX < plotArea.getCenterX()) {
			 labelX -= labelBounds.getWidth();
		 }
		 if (labelX == plotArea.getCenterX()) {
			 labelX -= labelBounds.getWidth() / 2;
		 }
		 if (labelY > plotArea.getCenterY()) {
			 labelY += ascent;
		 }
		 return new Point2D.Double(labelX, labelY);
	 }
	 public boolean equals(Object obj) {
		 if (obj == this) {
			 return true;
		 }
		 if (!(obj instanceof SpiderWebPlot)) {
			 return false;
		 }
		 if (!super.equals(obj)) {
			 return false;
		 }
		 SpiderWebPlot that = (SpiderWebPlot) obj;
		 if (!this.dataExtractOrder.equals(that.dataExtractOrder)) {
			 return false;
		 }
		 if (this.headPercent != that.headPercent) {
			 return false;
		 }
		 if (this.interiorGap != that.interiorGap) {
			 return false;
		 }
		 if (this.startAngle != that.startAngle) {
			 return false;
		 }
		 if (!this.direction.equals(that.direction)) {
			 return false;
		 }
		 if (this.maxValue != that.maxValue) {
			 return false;
		 }
		 if (this.webFilled != that.webFilled) {
			 return false;
		 }
		 if (this.axisLabelGap != that.axisLabelGap) {
			 return false;
		 }
		 if (!PaintUtilities.equal(this.axisLinePaint, that.axisLinePaint)) {
			 return false;
		 }
		 if (!this.axisLineStroke.equals(that.axisLineStroke)) {
			 return false;
		 }
		 if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {
			 return false;
		 }
		 if (!PaintUtilities.equal(this.seriesPaint, that.seriesPaint)) {
			 return false;
		 }
		 if (!this.seriesPaintList.equals(that.seriesPaintList)) {
			 return false;
		 }
		 if (!PaintUtilities.equal(this.baseSeriesPaint, that.baseSeriesPaint)) {
			 return false;
		 }
		 if (!PaintUtilities.equal(this.seriesOutlinePaint, that.seriesOutlinePaint)) {
			 return false;
		 }
		 if (!this.seriesOutlinePaintList.equals(that.seriesOutlinePaintList)) {
			 return false;
		 }
		 if (!PaintUtilities.equal(this.baseSeriesOutlinePaint, that.baseSeriesOutlinePaint)) {
			 return false;
		 }
		 if (!ObjectUtilities.equal(this.seriesOutlineStroke, that.seriesOutlineStroke)) {
			 return false;
		 }
		 if (!this.seriesOutlineStrokeList.equals( that.seriesOutlineStrokeList)) {
			 return false;
		 }
		 if (!this.baseSeriesOutlineStroke.equals( that.baseSeriesOutlineStroke)) {
			 return false;
		 }
		 if (!this.labelFont.equals(that.labelFont)) {
			 return false;
		 }
		 if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {
			 return false;
		 }
		 if (!this.labelGenerator.equals(that.labelGenerator)) {
			 return false;
		 }
		 if (!ObjectUtilities.equal(this.toolTipGenerator, that.toolTipGenerator)) {
			 return false;
		 }
		 if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {
			 return false;
		 }
		 return true;
	 }
	 public Object clone() throws CloneNotSupportedException {
		 SpiderWebPlot clone = (SpiderWebPlot) super.clone();
		 clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);
		 clone.seriesPaintList = (PaintList) this.seriesPaintList.clone();
		 clone.seriesOutlinePaintList = (PaintList) this.seriesOutlinePaintList.clone();
		 clone.seriesOutlineStrokeList = (StrokeList) this.seriesOutlineStrokeList.clone();
		 return clone;
	 }
	 private void writeObject(ObjectOutputStream stream) throws IOException {
		 stream.defaultWriteObject();
		 SerialUtilities.writeShape(this.legendItemShape, stream);
		 SerialUtilities.writePaint(this.seriesPaint, stream);
		 SerialUtilities.writePaint(this.baseSeriesPaint, stream);
		 SerialUtilities.writePaint(this.seriesOutlinePaint, stream);
		 SerialUtilities.writePaint(this.baseSeriesOutlinePaint, stream);
		 SerialUtilities.writeStroke(this.seriesOutlineStroke, stream);
		 SerialUtilities.writeStroke(this.baseSeriesOutlineStroke, stream);
		 SerialUtilities.writePaint(this.labelPaint, stream);
		 SerialUtilities.writePaint(this.axisLinePaint, stream);
		 SerialUtilities.writeStroke(this.axisLineStroke, stream);
	 }
	 private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
		 stream.defaultReadObject();
		 this.legendItemShape = SerialUtilities.readShape(stream);
		 this.seriesPaint = SerialUtilities.readPaint(stream);
		 this.baseSeriesPaint = SerialUtilities.readPaint(stream);
		 this.seriesOutlinePaint = SerialUtilities.readPaint(stream);
		 this.baseSeriesOutlinePaint = SerialUtilities.readPaint(stream);
		 this.seriesOutlineStroke = SerialUtilities.readStroke(stream);
		 this.baseSeriesOutlineStroke = SerialUtilities.readStroke(stream);
		 this.labelPaint = SerialUtilities.readPaint(stream);
		 this.axisLinePaint = SerialUtilities.readPaint(stream);
		 this.axisLineStroke = SerialUtilities.readStroke(stream);
		 if (this.dataset != null) {
			 this.dataset.addChangeListener(this);
		 }
	 }
}",1,0,0,0
"public static boolean isOid( String oidString ) {
	 try {
		 Oid.fromString( oidString );
		 return true;
	 }
	 catch ( DecoderException e ) {
		 return false;
	 }
 }",0,0,0,0
"public class NodeTransformer{
	 public NodeTransformer() {
	 }
	 public final void transform(ScriptOrFnNode tree) {
		 transformCompilationUnit(tree);
		 for (int i = 0;
		 i != tree.getFunctionCount();
		 ++i) {
			 FunctionNode fn = tree.getFunctionNode(i);
			 transform(fn);
		 }
	 }
	 private void transformCompilationUnit(ScriptOrFnNode tree) {
		 loops = new ObjArray();
		 loopEnds = new ObjArray();
		 hasFinally = false;
		 transformCompilationUnit_r(tree, tree);
	 }
	 private void transformCompilationUnit_r(final ScriptOrFnNode tree, final Node parent) {
		 Node node = null;
		 siblingLoop: for (;
		;
		) {
			 Node previous = null;
			 if (node == null) {
				 node = parent.getFirstChild();
			 }
			 else {
				 previous = node;
				 node = node.getNext();
			 }
			 if (node == null) {
				 break;
			 }
			 int type = node.getType();
			 switch (type) {
				 case Token.LABEL: case Token.SWITCH: case Token.LOOP: loops.push(node);
				 loopEnds.push(((Node.Jump)node).target);
				 break;
				 case Token.WITH: {
					 loops.push(node);
					 Node leave = node.getNext();
					 if (leave.getType() != Token.LEAVEWITH) {
						 Kit.codeBug();
					 }
					 loopEnds.push(leave);
					 break;
				 }
				 case Token.TRY: {
					 Node.Jump jump = (Node.Jump)node;
					 Node finallytarget = jump.getFinally();
					 if (finallytarget != null) {
						 hasFinally = true;
						 loops.push(node);
						 loopEnds.push(finallytarget);
					 }
					 break;
				 }
				 case Token.TARGET: case Token.LEAVEWITH: if (!loopEnds.isEmpty() && loopEnds.peek() == node) {
					 loopEnds.pop();
					 loops.pop();
				 }
				 break;
				 case Token.RETURN: {
					 if (!hasFinally) break;
					 Node unwindBlock = null;
					 for (int i=loops.size()-1;
					 i >= 0;
					 i--) {
						 Node n = (Node) loops.get(i);
						 int elemtype = n.getType();
						 if (elemtype == Token.TRY || elemtype == Token.WITH) {
							 Node unwind;
							 if (elemtype == Token.TRY) {
								 Node.Jump jsrnode = new Node.Jump(Token.JSR);
								 Node jsrtarget = ((Node.Jump)n).getFinally();
								 jsrnode.target = jsrtarget;
								 unwind = jsrnode;
							 }
							 else {
								 unwind = new Node(Token.LEAVEWITH);
							 }
							 if (unwindBlock == null) {
								 unwindBlock = new Node(Token.BLOCK, node.getLineno());
							 }
							 unwindBlock.addChildToBack(unwind);
						 }
					 }
					 if (unwindBlock != null) {
						 Node returnNode = node;
						 Node returnExpr = returnNode.getFirstChild();
						 node = replaceCurrent(parent, previous, node, unwindBlock);
						 if (returnExpr == null) {
							 unwindBlock.addChildToBack(returnNode);
						 }
						 else {
							 Node store = new Node(Token.EXPR_RESULT, returnExpr);
							 unwindBlock.addChildToFront(store);
							 returnNode = new Node(Token.RETURN_RESULT);
							 unwindBlock.addChildToBack(returnNode);
							 transformCompilationUnit_r(tree, store);
						 }
						 continue siblingLoop;
					 }
					 break;
				 }
				 case Token.BREAK: case Token.CONTINUE: {
					 Node.Jump jump = (Node.Jump)node;
					 Node.Jump jumpStatement = jump.getJumpStatement();
					 if (jumpStatement == null) Kit.codeBug();
					 for (int i = loops.size();
					 ;
					) {
						 if (i == 0) {
							 throw Kit.codeBug();
						 }
						 --i;
						 Node n = (Node) loops.get(i);
						 if (n == jumpStatement) {
							 break;
						 }
						 int elemtype = n.getType();
						 if (elemtype == Token.WITH) {
							 Node leave = new Node(Token.LEAVEWITH);
							 previous = addBeforeCurrent(parent, previous, node, leave);
						 }
						 else if (elemtype == Token.TRY) {
							 Node.Jump tryNode = (Node.Jump)n;
							 Node.Jump jsrFinally = new Node.Jump(Token.JSR);
							 jsrFinally.target = tryNode.getFinally();
							 previous = addBeforeCurrent(parent, previous, node, jsrFinally);
						 }
					 }
					 if (type == Token.BREAK) {
						 jump.target = jumpStatement.target;
					 }
					 else {
						 jump.target = jumpStatement.getContinue();
					 }
					 jump.setType(Token.GOTO);
					 break;
				 }
				 case Token.CALL: visitCall(node, tree);
				 break;
				 case Token.NEW: visitNew(node, tree);
				 break;
				 case Token.CONST: case Token.VAR: {
					 Node result = new Node(Token.BLOCK);
					 for (Node cursor = node.getFirstChild();
					 cursor != null;
					) {
						 Node n = cursor;
						 if (n.getType() != Token.NAME) Kit.codeBug();
						 cursor = cursor.getNext();
						 if (!n.hasChildren()) continue;
						 Node init = n.getFirstChild();
						 n.removeChild(init);
						 n.setType(Token.BINDNAME);
						 n = new Node(type == Token.VAR ? Token.SETNAME : Token.SETCONST, n, init);
						 Node pop = new Node(Token.EXPR_VOID, n, node.getLineno());
						 result.addChildToBack(pop);
					 }
					 node = replaceCurrent(parent, previous, node, result);
					 break;
				 }
				 case Token.NAME: case Token.SETNAME: case Token.SETCONST: case Token.DELPROP: {
					 if (tree.getType() != Token.FUNCTION || ((FunctionNode)tree).requiresActivation()) {
						 break;
					 }
					 Node nameSource;
					 if (type == Token.NAME) {
						 nameSource = node;
					 }
					 else {
						 nameSource = node.getFirstChild();
						 if (nameSource.getType() != Token.BINDNAME) {
							 if (type == Token.DELPROP) {
								 break;
							 }
							 throw Kit.codeBug();
						 }
					 }
					 String name = nameSource.getString();
					 if (tree.hasParamOrVar(name)) {
						 if (type == Token.NAME) {
							 node.setType(Token.GETVAR);
						 }
						 else if (type == Token.SETNAME) {
							 node.setType(Token.SETVAR);
							 nameSource.setType(Token.STRING);
						 }
						 else if (type == Token.SETCONST) {
							 node.setType(Token.SETCONSTVAR);
							 nameSource.setType(Token.STRING);
						 }
						 else if (type == Token.DELPROP) {
							 Node n = new Node(Token.FALSE);
							 node = replaceCurrent(parent, previous, node, n);
						 }
						 else {
							 throw Kit.codeBug();
						 }
					 }
					 break;
				 }
			 }
			 transformCompilationUnit_r(tree, node);
		 }
	 }
	 protected void visitNew(Node node, ScriptOrFnNode tree) {
	 }
	 protected void visitCall(Node node, ScriptOrFnNode tree) {
	 }
	 private static Node addBeforeCurrent(Node parent, Node previous, Node current, Node toAdd) {
		 if (previous == null) {
			 if (!(current == parent.getFirstChild())) Kit.codeBug();
			 parent.addChildToFront(toAdd);
		 }
		 else {
			 if (!(current == previous.getNext())) Kit.codeBug();
			 parent.addChildAfter(toAdd, previous);
		 }
		 return toAdd;
	 }
	 private static Node replaceCurrent(Node parent, Node previous, Node current, Node replacement) {
		 if (previous == null) {
			 if (!(current == parent.getFirstChild())) Kit.codeBug();
			 parent.replaceChild(current, replacement);
		 }
		 else if (previous.next == current) {
			 parent.replaceChildAfter(previous, replacement);
		 }
		 else {
			 parent.replaceChild(current, replacement);
		 }
		 return replacement;
	 }
	 private ObjArray loops;
	 private ObjArray loopEnds;
	 private boolean hasFinally;
}",0,0,0,0
"public void setBufferSize(int size) {
	 bufferSize = size;
 }",0,0,0,0
"private void joinInternal(Address mbr, boolean joinWithStateTransfer,boolean useFlushIfPresent);",0,0,0,0
"public class OpenBitSet implements Serializable {
	 private final long[][] bits;
	 private int wlen;
	 private final int pageCount;
	 private static final int PAGE_SIZE = 4096;
	 public OpenBitSet(long numBits) {
		 wlen = bits2words(numBits);
		 int lastPageSize = wlen % PAGE_SIZE;
		 int fullPageCount = wlen / PAGE_SIZE;
		 pageCount = fullPageCount + (lastPageSize == 0 ? 0 : 1);
		 bits = new long[pageCount][];
		 for (int i = 0;
		 i < fullPageCount;
		 ++i) bits[i] = new long[PAGE_SIZE];
		 if (lastPageSize != 0) bits[bits.length - 1] = new long[lastPageSize];
	 }
	 public OpenBitSet() {
		 this(64);
	 }
	 public int getPageSize() {
		 return PAGE_SIZE;
	 }
	 public int getPageCount() {
		 return pageCount;
	 }
	 public long[] getPage(int pageIdx) {
		 return bits[pageIdx];
	 }
	 public OpenBitSet(BitSet bits) {
		 this(bits.length());
	 }
	 public long capacity() {
		 return ((long)wlen) << 6;
	 }
	 public long size() {
		 return capacity();
	 }
	 public long length() {
		 return capacity();
	 }
	 public boolean isEmpty() {
		 return cardinality()==0;
	 }
	 public int getNumWords() {
		 return wlen;
	 }
	 public boolean get(int index) {
		 int i = index >> 6;
		 int bit = index & 0x3f;
		 long bitmask = 1L << bit;
		 return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
	 }
	 public boolean get(long index) {
		 int i = (int)(index >> 6);
		 int bit = (int)index & 0x3f;
		 long bitmask = 1L << bit;
		 return (bits[i / PAGE_SIZE][i % PAGE_SIZE ] & bitmask) != 0;
	 }
	 public int getBit(int index) {
		 int i = index >> 6;
		 int bit = index & 0x3f;
		 return ((int)(bits[i / PAGE_SIZE][i % PAGE_SIZE ]>>>bit)) & 0x01;
	 }
	 public void set(long index) {
		 int wordNum = (int)(index >> 6);
		 int bit = (int)index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
	 }
	 public void set(int index) {
		 int wordNum = index >> 6;
		 int bit = index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[ wordNum / PAGE_SIZE ][ wordNum % PAGE_SIZE ] |= bitmask;
	 }
	 public void clear(int index) {
		 int wordNum = index >> 6;
		 int bit = index & 0x03f;
		 long bitmask = 1L << bit;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
	 }
	 public void clear(long index) {
		 int wordNum = (int)(index >> 6);
		 int bit = (int)index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] &= ~bitmask;
	 }
	 public void clear(int startIndex, int endIndex) {
		 if (endIndex <= startIndex) return;
		 int startWord = (startIndex>>6);
		 if (startWord >= wlen) return;
		 int endWord = ((endIndex-1)>>6);
		 long startmask = -1L << startIndex;
		 long endmask = -1L >>> -endIndex;
		 startmask = ~startmask;
		 endmask = ~endmask;
		 if (startWord == endWord) {
			 bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= (startmask | endmask);
			 return;
		 }
		 bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= startmask;
		 int middle = Math.min(wlen, endWord);
		 if (startWord / PAGE_SIZE == middle / PAGE_SIZE) {
			 Arrays.fill(bits[startWord/PAGE_SIZE], (startWord+1) % PAGE_SIZE, middle % PAGE_SIZE, 0L);
		 }
		 else {
			 while (++startWord<middle) bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] = 0L;
		 }
		 if (endWord < wlen) {
			 bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] &= endmask;
		 }
	 }
	 public void clear(long startIndex, long endIndex) {
		 if (endIndex <= startIndex) return;
		 int startWord = (int)(startIndex>>6);
		 if (startWord >= wlen) return;
		 int endWord = (int)((endIndex-1)>>6);
		 long startmask = -1L << startIndex;
		 long endmask = -1L >>> -endIndex;
		 startmask = ~startmask;
		 endmask = ~endmask;
		 if (startWord == endWord) {
			 bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= (startmask | endmask);
			 return;
		 }
		 bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] &= startmask;
		 int middle = Math.min(wlen, endWord);
		 if (startWord / PAGE_SIZE == middle / PAGE_SIZE) {
			 Arrays.fill(bits[startWord/PAGE_SIZE], (startWord+1) % PAGE_SIZE, middle % PAGE_SIZE, 0L);
		 }
		 else {
			 while (++startWord<middle) bits[startWord / PAGE_SIZE][startWord % PAGE_SIZE] = 0L;
		 }
		 if (endWord < wlen) {
			 bits[endWord / PAGE_SIZE][endWord % PAGE_SIZE] &= endmask;
		 }
	 }
	 public boolean getAndSet(int index) {
		 int wordNum = index >> 6;
		 int bit = index & 0x3f;
		 long bitmask = 1L << bit;
		 boolean val = (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] |= bitmask;
		 return val;
	 }
	 public boolean getAndSet(long index) {
		 int wordNum = (int)(index >> 6);
		 int bit = (int)index & 0x3f;
		 long bitmask = 1L << bit;
		 boolean val = (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] |= bitmask;
		 return val;
	 }
	 public void flip(int index) {
		 int wordNum = index >> 6;
		 int bit = index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
	 }
	 public void flip(long index) {
		 int wordNum = (int)(index >> 6);
		 int bit = (int)index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
	 }
	 public boolean flipAndGet(int index) {
		 int wordNum = index >> 6;
		 int bit = index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
		 return (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
	 }
	 public boolean flipAndGet(long index) {
		 int wordNum = (int)(index >> 6);
		 int bit = (int)index & 0x3f;
		 long bitmask = 1L << bit;
		 bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] ^= bitmask;
		 return (bits[wordNum / PAGE_SIZE][wordNum % PAGE_SIZE] & bitmask) != 0;
	 }
	 public long cardinality() {
		 long bitCount = 0L;
		 for (int i=getPageCount();
		i-->0;
		) bitCount+=BitUtil.pop_array(bits[i],0,wlen);
		 return bitCount;
	 }
	 public int nextSetBit(int index) {
		 int i = index>>6;
		 if (i>=wlen) return -1;
		 int subIndex = index & 0x3f;
		 long word = bits[i / PAGE_SIZE][ i % PAGE_SIZE] >> subIndex;
		 if (word!=0) {
			 return (i<<6) + subIndex + BitUtil.ntz(word);
		 }
		 while(++i < wlen) {
			 word = bits[i / PAGE_SIZE][i % PAGE_SIZE];
			 if (word!=0) return (i<<6) + BitUtil.ntz(word);
		 }
		 return -1;
	 }
	 public long nextSetBit(long index) {
		 int i = (int)(index>>>6);
		 if (i>=wlen) return -1;
		 int subIndex = (int)index & 0x3f;
		 long word = bits[i / PAGE_SIZE][i % PAGE_SIZE] >>> subIndex;
		 if (word!=0) {
			 return (((long)i)<<6) + (subIndex + BitUtil.ntz(word));
		 }
		 while(++i < wlen) {
			 word = bits[i / PAGE_SIZE][i % PAGE_SIZE];
			 if (word!=0) return (((long)i)<<6) + BitUtil.ntz(word);
		 }
		 return -1;
	 }
	 public void intersect(OpenBitSet other) {
		 int newLen= Math.min(this.wlen,other.wlen);
		 long[][] thisArr = this.bits;
		 long[][] otherArr = other.bits;
		 int thisPageSize = this.PAGE_SIZE;
		 int otherPageSize = other.PAGE_SIZE;
		 int pos=newLen;
		 while(--pos>=0) {
			 thisArr[pos / thisPageSize][ pos % thisPageSize] &= otherArr[pos / otherPageSize][pos % otherPageSize];
		 }
		 if (this.wlen > newLen) {
			 for (pos=wlen;
			pos-->newLen;
			) thisArr[pos / thisPageSize][ pos % thisPageSize] =0;
		 }
		 this.wlen = newLen;
	 }
	 / public void and(OpenBitSet other) {
		 intersect(other);
	 }
	 public void trimTrailingZeros() {
		 int idx = wlen-1;
		 while (idx>=0 && bits[idx / PAGE_SIZE][idx % PAGE_SIZE]==0) idx--;
		 wlen = idx+1;
	 }
	 public static int bits2words(long numBits) {
		 return (int)(((numBits-1)>>>6)+1);
	 }
	 public boolean equals(Object o) {
		 if (this == o) return true;
		 if (!(o instanceof OpenBitSet)) return false;
		 OpenBitSet a;
		 OpenBitSet b = (OpenBitSet)o;
		 if (b.wlen > this.wlen) {
			 a = b;
			 b=this;
		 }
		 else {
			 a=this;
		 }
		 int aPageSize = this.PAGE_SIZE;
		 int bPageSize = b.PAGE_SIZE;
		 for (int i=a.wlen-1;
		 i>=b.wlen;
		 i--) {
			 if (a.bits[i/aPageSize][i % aPageSize]!=0) return false;
		 }
		 for (int i=b.wlen-1;
		 i>=0;
		 i--) {
			 if (a.bits[i/aPageSize][i % aPageSize] != b.bits[i/bPageSize][i % bPageSize]) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 long h = 0;
		 for (int i = wlen;
		 --i>=0;
		) {
			 h ^= bits[i / PAGE_SIZE][i % PAGE_SIZE];
			 h = (h << 1) | (h >>> 63);
		 }
		 return (int)((h>>32) ^ h) + 0x98761234;
	 }
}",0,0,0,0
"public class AbortMultipartUploadRequest extends com.oracle.bmc.requests.BmcRequest {
	 private String namespaceName;
	 private String bucketName;
	 private String objectName;
	 private String uploadId;
	 private String opcClientRequestId;
	 public static class Builder {
		 private com.oracle.bmc.util.internal.Consumer<javax.ws.rs.client.Invocation.Builder> invocationCallback = null;
		 public Builder invocationCallback( com.oracle.bmc.util.internal.Consumer<javax.ws.rs.client.Invocation.Builder> invocationCallback) {
			 this.invocationCallback = invocationCallback;
			 return this;
		 }
		 public Builder copy(AbortMultipartUploadRequest o) {
			 namespaceName(o.getNamespaceName());
			 bucketName(o.getBucketName());
			 objectName(o.getObjectName());
			 uploadId(o.getUploadId());
			 opcClientRequestId(o.getOpcClientRequestId());
			 invocationCallback(o.getInvocationCallback());
			 return this;
		 }
		 public AbortMultipartUploadRequest build() {
			 AbortMultipartUploadRequest request = buildWithoutInvocationCallback();
			 request.setInvocationCallback(invocationCallback);
			 return request;
		 }
	 }
}",0,0,0,0
"public JFreeChartEntity(Shape area, JFreeChart chart, String toolTipText);",0,0,0,0
"public int uncompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset) throws IOException {
	 Inflater inf = inflater.get();
	 inf.reset();
	 inf.setInput(input, inputOffset, inputLength);
	 if (inf.needsInput()) return 0;
	 try {
		 return inf.inflate(output, outputOffset, output.length - outputOffset);
	 }
	 catch (DataFormatException e) {
		 throw new IOException(e);
	 }
 }",0,0,0,0
"public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException {
	 ensureObj(obj);
	 if (isFinal) {
		 throwFinalFieldIllegalAccessException(value);
	 }
	 if (value == null) {
		 throwSetIllegalArgumentException(value);
	 }
	 if (value instanceof Byte) {
		 unsafe.putInt(obj, fieldOffset, ((Byte) value).byteValue());
		 return;
	 }
	 if (value instanceof Short) {
		 unsafe.putInt(obj, fieldOffset, ((Short) value).shortValue());
		 return;
	 }
	 if (value instanceof Character) {
		 unsafe.putInt(obj, fieldOffset, ((Character) value).charValue());
		 return;
	 }
	 if (value instanceof Integer) {
		 unsafe.putInt(obj, fieldOffset, ((Integer) value).intValue());
		 return;
	 }
	 throwSetIllegalArgumentException(value);
 }",0,0,1,0
"private V1SelfSubjectAccessReview prepareSelfSubjectAccessReview( Operation operation, Resource resource, String resourceName, Scope scope, String namespaceName) {
	 LOGGER.entering();
	 V1SelfSubjectAccessReviewSpec subjectAccessReviewSpec = new V1SelfSubjectAccessReviewSpec();
	 subjectAccessReviewSpec.setResourceAttributes( prepareResourceAttributes(operation, resource, resourceName, scope, namespaceName));
	 V1SelfSubjectAccessReview subjectAccessReview = new V1SelfSubjectAccessReview();
	 subjectAccessReview.setApiVersion(""authorization.k8s.io/v1"");
	 subjectAccessReview.setKind(""SelfSubjectAccessReview"");
	 subjectAccessReview.setMetadata(new V1ObjectMeta());
	 subjectAccessReview.setSpec(subjectAccessReviewSpec);
	 LOGGER.exiting(subjectAccessReview);
	 return subjectAccessReview;
 }",0,0,1,0
"abstract static class Sync extends AbstractQueuedSynchronizer {
	 private static final long serialVersionUID = 6317671515068378041L;
	 static final int SHARED_SHIFT = 16;
	 static final int SHARED_UNIT = (1 << SHARED_SHIFT);
	 static final int MAX_COUNT = (1 << SHARED_SHIFT) - 1;
	 static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
	 static int sharedCount(int c) {
		 return c >>> SHARED_SHIFT;
	 }
	 static int exclusiveCount(int c) {
		 return c & EXCLUSIVE_MASK;
	 }
	 static final class HoldCounter {
		 int count;
		 final long tid = getThreadId(Thread.currentThread());
	 }
	 static final class ThreadLocalHoldCounter extends ThreadLocal<HoldCounter> {
		 public HoldCounter initialValue() {
			 return new HoldCounter();
		 }
	 }
	 private transient ThreadLocalHoldCounter readHolds;
	 private transient HoldCounter cachedHoldCounter;
	 private transient Thread firstReader;
	 private transient int firstReaderHoldCount;
	 Sync() {
		 readHolds = new ThreadLocalHoldCounter();
		 setState(getState());
	 }
	 abstract boolean readerShouldBlock();
	 abstract boolean writerShouldBlock();
	 protected final boolean tryRelease(int releases) {
		 if (!isHeldExclusively()) throw new IllegalMonitorStateException();
		 int nextc = getState() - releases;
		 boolean free = exclusiveCount(nextc) == 0;
		 if (free) setExclusiveOwnerThread(null);
		 setState(nextc);
		 return free;
	 }
	 protected final boolean tryAcquire(int acquires) {
		 Thread current = Thread.currentThread();
		 int c = getState();
		 int w = exclusiveCount(c);
		 if (c != 0) {
			 if (w == 0 || current != getExclusiveOwnerThread()) return false;
			 if (w + exclusiveCount(acquires) > MAX_COUNT) throw new Error(""Maximum lock count exceeded"");
			 setState(c + acquires);
			 return true;
		 }
		 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false;
		 setExclusiveOwnerThread(current);
		 return true;
	 }
	 protected final boolean tryReleaseShared(int unused) {
		 Thread current = Thread.currentThread();
		 if (firstReader == current) {
			 if (firstReaderHoldCount == 1) firstReader = null;
			 else firstReaderHoldCount--;
		 }
		 else {
			 HoldCounter rh = cachedHoldCounter;
			 boolean cachedCounterIsLocal = true;
			 if (rh == null || rh.tid != getThreadId(current)) {
				 rh = readHolds.get();
				 cachedCounterIsLocal = false;
			 }
			 int count = rh.count;
			 if (count <= 1) {
				 if (cachedCounterIsLocal) {
					 cachedHoldCounter = null;
				 }
				 readHolds.remove();
				 if (count <= 0) throw unmatchedUnlockException();
			 }
			 --rh.count;
		 }
		 for (;
		;
		) {
			 int c = getState();
			 int nextc = c - SHARED_UNIT;
			 if (compareAndSetState(c, nextc)) return nextc == 0;
		 }
	 }
	 private IllegalMonitorStateException unmatchedUnlockException() {
		 return new IllegalMonitorStateException( ""attempt to unlock read lock, not locked by current thread"");
	 }
	 protected final int tryAcquireShared(int unused) {
		 Thread current = Thread.currentThread();
		 int c = getState();
		 if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) return -1;
		 int r = sharedCount(c);
		 if (!readerShouldBlock() && r < MAX_COUNT && compareAndSetState(c, c + SHARED_UNIT)) {
			 if (r == 0) {
				 firstReader = current;
				 firstReaderHoldCount = 1;
			 }
			 else if (firstReader == current) {
				 firstReaderHoldCount++;
			 }
			 else {
				 HoldCounter rh = cachedHoldCounter;
				 if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get();
				 else if (rh.count == 0) readHolds.set(rh);
				 rh.count++;
			 }
			 return 1;
		 }
		 return fullTryAcquireShared(current);
	 }
	 final int fullTryAcquireShared(Thread current) {
		 HoldCounter rh = null;
		 for (;
		;
		) {
			 int c = getState();
			 if (exclusiveCount(c) != 0) {
				 if (getExclusiveOwnerThread() != current) return -1;
			 }
			 else if (readerShouldBlock()) {
				 if (firstReader == current) {
				 }
				 else {
					 if (rh == null) {
						 rh = cachedHoldCounter;
						 if (rh == null || rh.tid != getThreadId(current)) {
							 rh = readHolds.get();
							 if (rh.count == 0) readHolds.remove();
						 }
					 }
					 if (rh.count == 0) return -1;
				 }
			 }
			 if (sharedCount(c) == MAX_COUNT) throw new Error(""Maximum lock count exceeded"");
			 if (compareAndSetState(c, c + SHARED_UNIT)) {
				 if (sharedCount(c) == 0) {
					 firstReader = current;
					 firstReaderHoldCount = 1;
				 }
				 else if (firstReader == current) {
					 firstReaderHoldCount++;
				 }
				 else {
					 if (rh == null) rh = cachedHoldCounter;
					 if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get();
					 else if (rh.count == 0) readHolds.set(rh);
					 rh.count++;
					 cachedHoldCounter = rh;
				 }
				 return 1;
			 }
		 }
	 }
	 final boolean tryWriteLock() {
		 Thread current = Thread.currentThread();
		 int c = getState();
		 if (c != 0) {
			 int w = exclusiveCount(c);
			 if (w == 0 || current != getExclusiveOwnerThread()) return false;
			 if (w == MAX_COUNT) throw new Error(""Maximum lock count exceeded"");
		 }
		 if (!compareAndSetState(c, c + 1)) return false;
		 setExclusiveOwnerThread(current);
		 return true;
	 }
	 final boolean tryReadLock() {
		 Thread current = Thread.currentThread();
		 for (;
		;
		) {
			 int c = getState();
			 if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) return false;
			 int r = sharedCount(c);
			 if (r == MAX_COUNT) throw new Error(""Maximum lock count exceeded"");
			 if (compareAndSetState(c, c + SHARED_UNIT)) {
				 if (r == 0) {
					 firstReader = current;
					 firstReaderHoldCount = 1;
				 }
				 else if (firstReader == current) {
					 firstReaderHoldCount++;
				 }
				 else {
					 HoldCounter rh = cachedHoldCounter;
					 if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get();
					 else if (rh.count == 0) readHolds.set(rh);
					 rh.count++;
				 }
				 return true;
			 }
		 }
	 }
	 protected final boolean isHeldExclusively() {
		 return getExclusiveOwnerThread() == Thread.currentThread();
	 }
	 final ConditionObject newCondition() {
		 return new ConditionObject();
	 }
	 final Thread getOwner() {
		 return ((exclusiveCount(getState()) == 0) ? null : getExclusiveOwnerThread());
	 }
	 final int getReadLockCount() {
		 return sharedCount(getState());
	 }
	 final boolean isWriteLocked() {
		 return exclusiveCount(getState()) != 0;
	 }
	 final int getWriteHoldCount() {
		 return isHeldExclusively() ? exclusiveCount(getState()) : 0;
	 }
	 final int getReadHoldCount() {
		 if (getReadLockCount() == 0) return 0;
		 Thread current = Thread.currentThread();
		 if (firstReader == current) return firstReaderHoldCount;
		 HoldCounter rh = cachedHoldCounter;
		 if (rh != null && rh.tid == getThreadId(current)) return rh.count;
		 int count = readHolds.get().count;
		 if (count == 0) readHolds.remove();
		 return count;
	 }
	 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
		 s.defaultReadObject();
		 readHolds = new ThreadLocalHoldCounter();
		 setState(0);
	 }
	 final int getCount() {
		 return getState();
	 }
 }",1,0,0,0
"protected Folder buildFolder(MultiStatusResponse entity) throws IOException {
	 String href = URIUtil.decode(entity.getHref());
	 Folder folder = new Folder();
	 DavPropertySet properties = entity.getProperties(HttpStatus.SC_OK);
	 folder.displayName = getPropertyIfExists(properties, ""displayname"");
	 folder.folderClass = getPropertyIfExists(properties, ""folderclass"");
	 folder.hasChildren = ""1"".equals(getPropertyIfExists(properties, ""hassubs""));
	 folder.noInferiors = ""1"".equals(getPropertyIfExists(properties, ""nosubs""));
	 folder.count = getIntPropertyIfExists(properties, ""count"");
	 folder.unreadCount = getIntPropertyIfExists(properties, ""unreadcount"");
	 folder.recent = folder.unreadCount;
	 folder.ctag = getPropertyIfExists(properties, ""contenttag"");
	 folder.etag = getPropertyIfExists(properties, ""lastmodified"");
	 folder.uidNext = getIntPropertyIfExists(properties, ""uidNext"");
	 if (inboxUrl != null && href.startsWith(inboxUrl)) {
		 folder.folderPath = href.replaceFirst(inboxUrl, INBOX);
	 }
	 else if (sentitemsUrl != null && href.startsWith(sentitemsUrl)) {
		 folder.folderPath = href.replaceFirst(sentitemsUrl, SENT);
	 }
	 else if (draftsUrl != null && href.startsWith(draftsUrl)) {
		 folder.folderPath = href.replaceFirst(draftsUrl, DRAFTS);
	 }
	 else if (deleteditemsUrl != null && href.startsWith(deleteditemsUrl)) {
		 folder.folderPath = href.replaceFirst(deleteditemsUrl, TRASH);
	 }
	 else if (calendarUrl != null && href.startsWith(calendarUrl)) {
		 folder.folderPath = href.replaceFirst(calendarUrl, CALENDAR);
	 }
	 else if (contactsUrl != null && href.startsWith(contactsUrl)) {
		 folder.folderPath = href.replaceFirst(contactsUrl, CONTACTS);
	 }
	 else {
		 int index = href.indexOf(mailPath.substring(0, mailPath.length() - 1));
		 if (index >= 0) {
			 if (index + mailPath.length() > href.length()) {
				 folder.folderPath = """";
			 }
			 else {
				 folder.folderPath = href.substring(index + mailPath.length());
			 }
		 }
		 else {
			 try {
				 URI folderURI = new URI(href, false);
				 folder.folderPath = folderURI.getPath();
				 if (folder.folderPath == null) {
					 throw new URIException();
				 }
			 }
			 catch (URIException e) {
				 throw new DavMailException(""EXCEPTION_INVALID_FOLDER_URL"", href);
			 }
		 }
	 }
	 if (folder.folderPath.endsWith(""/"")) {
		 folder.folderPath = folder.folderPath.substring(0, folder.folderPath.length() - 1);
	 }
	 return folder;
 }",0,0,1,0
"public class TextAndButtonSection extends Section{
	public TextAndButtonSection( String labelText, Composite parent,boolean isFormStyle ){
		super( labelText, parent, isFormStyle );
	}
	protected int width = -1;
	protected boolean fillText = false;
	protected TextPropertyDescriptor textField;
	public void createSection( ){
		if ( selectList == null )selectList = new ArrayList( );
		getLabelControl( parent );
		getTextControl( parent );
		getButtonControl( parent );
		getGridPlaceholder( parent );
	}
	public void layout( ){
		GridData gd = (GridData) textField.getControl( ).getLayoutData( );
		if ( getLayoutNum( ) > 0 )gd.horizontalSpan = getLayoutNum( ) - 2 - placeholder;
		elsegd.horizontalSpan = ( (GridLayout) parent.getLayout( ) ).numColumns- 2- placeholder;
		if ( width > -1 ){
			gd.widthHint = width;
			gd.grabExcessHorizontalSpace = false;
		}
		elsegd.grabExcessHorizontalSpace = fillText;
		gd = (GridData) button.getLayoutData( );
		if ( buttonWidth > -1 ){
			if ( !isComputeSize )gd.widthHint = Math.max( button.computeSize( -1, -1 ).x,buttonWidth );
			elsegd.widthHint = button.computeSize( -1, -1 ).x;
		}
	}
	public TextPropertyDescriptor getTextControl( ){
		return textField;
	}
	protected TextPropertyDescriptor getTextControl( Composite parent ){
		if ( textField == null ){
			textField = DescriptorToolkit.createTextPropertyDescriptor( true );
			if ( getProvider( ) != null )textField.setDescriptorProvider( getProvider( ) );
			textField.createControl( parent );
			textField.getControl( ).setLayoutData( new GridData( ) );
			textField.getControl( ).addDisposeListener( new DisposeListener( ) {
				public void widgetDisposed( DisposeEvent event ){
					textField = null;
				}
			}
			 );
		}
		else{
			checkParent( textField.getControl( ), parent );
		}
		return textField;
	}
	protected Button button;
	public Button getButtonControl( ){
		return button;
	}
	protected Button getButtonControl( Composite parent ){
		if ( button == null ){
			button = FormWidgetFactory.getInstance( ).createButton( parent,SWT.PUSH,isFormStyle );
			button.setFont( parent.getFont( ) );
			button.setLayoutData( new GridData( ) );
			String text = getButtonText( );
			if ( text != null ){
				button.setText( text );
			}
			text = getButtonTooltipText( );
			if ( text != null ){
				button.setToolTipText( text );
			}
			button.addDisposeListener( new DisposeListener( ) {
				public void widgetDisposed( DisposeEvent event ){
					button = null;
				}
			}
			 );
			if ( !selectList.isEmpty( ) )button.addSelectionListener( (SelectionListener) selectList.get( 0 ) );
			else{
				SelectionListener listener = new SelectionAdapter( ) {
					public void widgetSelected( SelectionEvent e ){
						onClickButton( );
					}
				}
				;
				selectList.add( listener );
			}
		}
		else{
			checkParent( button, parent );
		}
		return button;
	}
	private String buttonText;
	IDescriptorProvider provider;
	public IDescriptorProvider getProvider( ){
		return provider;
	}
	public void setProvider( IDescriptorProvider provider ){
		this.provider = provider;
		if ( textField != null )textField.setDescriptorProvider( provider );
	}
	protected List selectList = new ArrayList( );
	public void addSelectionListener( SelectionListener listener ){
		if ( !selectList.contains( listener ) ){
			if ( !selectList.isEmpty( ) )removeSelectionListener( (SelectionListener) selectList.get( 0 ) );
			selectList.add( listener );
			if ( button != null )button.addSelectionListener( listener );
		}
	}
	public void removeSelectionListener( SelectionListener listener ){
		if ( selectList.contains( listener ) ){
			selectList.remove( listener );
			if ( button != null )button.removeSelectionListener( listener );
		}
	}
	protected void onClickButton( ){
	}
	;
	public void forceFocus( ){
		textField.getControl( ).forceFocus( );
	}
	public void setInput( Object input ){
		textField.setInput( input );
	}
	public void load( ){
		if ( textField != null && !textField.getControl( ).isDisposed( ) )textField.load( );
		if ( button != null && !button.isDisposed( ) )button.setEnabled( !isReadOnly( ) );
	}
	protected int buttonWidth = 60;
	public void setButtonWidth( int buttonWidth ){
		this.buttonWidth = buttonWidth;
		if ( button != null ){
			GridData data = new GridData( );
			data.widthHint = Math.max( button.computeSize( -1, -1 ).x,buttonWidth );
			;
			data.grabExcessHorizontalSpace = false;
			button.setLayoutData( data );
		}
	}
	protected boolean isComputeSize = false;
	public int getWidth( ){
		return width;
	}
	public void setWidth( int width ){
		this.width = width;
	}
	public int getButtonWidth( ){
		return buttonWidth;
	}
	private String oldValue;
	public void setStringValue( String value ){
		if ( textField != null ){
			if ( value == null ){
				value = """";
			}
			oldValue = textField.getText( );
			if ( !oldValue.equals( value ) ){
				textField.setText( value );
			}
		}
	}
	public boolean isFillText( ){
		return fillText;
	}
	public void setFillText( boolean fillText ){
		this.fillText = fillText;
	}
	public void setHidden( boolean isHidden ){
		if ( displayLabel != null )WidgetUtil.setExcludeGridData( displayLabel, isHidden );
		if ( textField != null )textField.setHidden( isHidden );
		if ( button != null )WidgetUtil.setExcludeGridData( button, isHidden );
		if ( placeholderLabel != null )WidgetUtil.setExcludeGridData( placeholderLabel, isHidden );
	}
	public void setVisible( boolean isVisible ){
		if ( displayLabel != null )displayLabel.setVisible( isVisible );
		if ( textField != null )textField.setVisible( isVisible );
		if ( button != null )button.setVisible( isVisible );
		if ( placeholderLabel != null )placeholderLabel.setVisible( isVisible );
	}
	private String buttonTooltipText;
	public void setButtonTooltipText( String string ){
		this.buttonTooltipText = string;
		if ( button != null )button.setText( buttonTooltipText );
	}
	public String getButtonText( ){
		return buttonText;
	}
	public void setButtonText( String buttonText ){
		this.buttonText = buttonText;
		if ( button != null )button.setText( buttonText );
	}
	public String getButtonTooltipText( ){
		return buttonTooltipText;
	}
	public boolean buttonIsComputeSize( ){
		return isComputeSize;
	}
	public void setButtonIsComputeSize( boolean isComputeSize ){
		this.isComputeSize = isComputeSize;
	}
}",1,1,0,0
"public static class getAppModuleDeployedResources<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, getAppModuleDeployedResources_args, List<String>> {
	 public getAppModuleDeployedResources() {
		 super(""getAppModuleDeployedResources"");
	 }
	 public getAppModuleDeployedResources_args getEmptyArgsInstance() {
		 return new getAppModuleDeployedResources_args();
	 }
	 public AsyncMethodCallback<List<String>> getResultHandler(final AsyncFrameBuffer fb, final int seqid) {
		 final org.apache.thrift.AsyncProcessFunction fcall = this;
		 return new AsyncMethodCallback<List<String>>() {
			 public void onComplete(List<String> o) {
				 getAppModuleDeployedResources_result result = new getAppModuleDeployedResources_result();
				 result.success = o;
				 try {
					 fcall.sendResponse(fb,result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
					 return;
				 }
				 catch (Exception e) {
					 LOGGER.error(""Exception writing to internal frame buffer"", e);
				 }
				 fb.close();
			 }
			 public void onError(Exception e) {
				 byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
				 org.apache.thrift.TBase msg;
				 getAppModuleDeployedResources_result result = new getAppModuleDeployedResources_result();
				 if (e instanceof org.apache.airavata.model.error.InvalidRequestException) {
					 result.ire = (org.apache.airavata.model.error.InvalidRequestException) e;
					 result.setIreIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.airavata.model.error.AiravataClientException) {
					 result.ace = (org.apache.airavata.model.error.AiravataClientException) e;
					 result.setAceIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.airavata.model.error.AiravataSystemException) {
					 result.ase = (org.apache.airavata.model.error.AiravataSystemException) e;
					 result.setAseIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.airavata.model.error.AuthorizationException) {
					 result.ae = (org.apache.airavata.model.error.AuthorizationException) e;
					 result.setAeIsSet(true);
					 msg = result;
				 }
				 else {
					 msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
					 msg = (org.apache.thrift.TBase)new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
				 }
				 try {
					 fcall.sendResponse(fb,msg,msgType,seqid);
					 return;
				 }
				 catch (Exception ex) {
					 LOGGER.error(""Exception writing to internal frame buffer"", ex);
				 }
				 fb.close();
			 }
		 }
		;
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public void start(I iface, getAppModuleDeployedResources_args args, org.apache.thrift.async.AsyncMethodCallback<List<String>> resultHandler) throws TException {
		 iface.getAppModuleDeployedResources(args.authzToken, args.appModuleId,resultHandler);
	 }
 }",0,0,0,0
"void logEdit(byte op, Writable w1, Writable w2) {
	 synchronized (editsStream) {
		 try {
			 editsStream.write(op);
			 if (w1 != null) {
				 w1.write(editsStream);
			 }
			 if (w2 != null) {
				 w2.write(editsStream);
			 }
		 }
		 catch (IOException ie) {
		 }
	 }
 }",0,0,0,0
"public void setReverse(boolean r) {
	 if (r) {
		 cmd.createArgument().setValue(""-R"");
	 }
 }",0,0,0,0
"void propagateRay(Ray r, OctreeNode node, RTObject first, double dist, MaterialMapping material, MaterialMapping prevMaterial, Mat4 currentMatTrans, Mat4 prevMatTrans, RGBColor color, int treeDepth, double totalDist, boolean caustic, boolean scattered) {
	 MaterialSpec matSpec = r.rt.matSpec;
	 Vec3 v = r.rt.ray[treeDepth+1].origin, origin = r.origin, direction = r.direction;
	 double x = 0.0, newx, dx, distToScreen = rt.theCamera.getDistToScreen(), step;
	 double origx, origy, origz, dirx, diry, dirz;
	 v.set(origin);
	 currentMatTrans.transform(v);
	 origx = v.x;
	 origy = v.y;
	 origz = v.z;
	 v.set(direction);
	 currentMatTrans.transformDirection(v);
	 dirx = v.x;
	 diry = v.y;
	 dirz = v.z;
	 step = rt.stepSize*material.getStepSize();
	 do {
		 dx = step*(1.5*r.rt.random.nextDouble());
		 if (this.rt.adaptive && totalDist > distToScreen) dx *= totalDist/distToScreen;
		 newx = x+dx;
		 if (newx > dist) {
			 dx = dist-x;
			 x = dist;
		 }
		 else x = newx;
		 totalDist += dx;
		 v.set(origx+dirx*x, origy+diry*x, origz+dirz*x);
		 material.getMaterialSpec(v, matSpec, dx, this.rt.time);
		 RGBColor trans = matSpec.transparency;
		 RGBColor scat = matSpec.scattering;
		 float rt, gt, bt;
		 if (trans.getRed() == 1.0f) rt = 1.0f;
		 else rt = (float) Math.pow(trans.getRed(), dx);
		 if (trans.getGreen() == 1.0f) gt = 1.0f;
		 else gt = (float) Math.pow(trans.getGreen(), dx);
		 if (trans.getBlue() == 1.0f) bt = 1.0f;
		 else bt = (float) Math.pow(trans.getBlue(), dx);
		 float averageTrans = (rt+gt+bt)/3.0f;
		 if (random.nextFloat() < averageTrans) {
			 color.multiply(rt/averageTrans, gt/averageTrans, bt/averageTrans);
			 continue;
		 }
		 float scatProb = (scat.getRed()+scat.getGreen()+scat.getBlue())/3.0f;
		 if (scatProb > 0.98f) scatProb = 0.98f;
		 if (random.nextFloat() < scatProb && treeDepth < this.rt.maxRayDepth-1) {
			 if (treeDepth < this.rt.maxRayDepth-1) {
				 RGBColor rayIntensity = r.rt.rayIntensity[treeDepth+1];
				 rayIntensity.copy(color);
				 rayIntensity.multiply(matSpec.scattering);
				 rayIntensity.scale(1.0f/scatProb);
				 if (rayIntensity.getMaxComponent() > this.rt.minRayIntensity) {
					 v.set(origin.x+direction.x*x, origin.y+direction.y*x, origin.z+direction.z*x);
					 while (node != null && !node.contains(v)) {
						 OctreeNode nextNode = node.findNextNode(r);
						 node = nextNode;
					 }
					 if (node == null) break;
					 double g = matSpec.eccentricity;
					 Vec3 newdir = r.rt.ray[treeDepth+1].getDirection();
					 if (g > 0.01 || g < -0.01) {
						 double theta = Math.acos((1.0+g*g-Math.pow((1-g*g)/(1-g+2*g*random.nextDouble()), 2.0))/Math.abs(2*g));
						 double phi = 2*Math.PI*random.nextDouble();
						 newdir.set(Math.sin(theta)*Math.cos(phi), Math.sin(theta)*Math.sin(phi), Math.cos(theta));
						 Mat4 m = Mat4.objectTransform(new Vec3(), direction, Math.abs(direction.y) > 0.9 ? Vec3.vx() : Vec3.vy());
						 m.transformDirection(newdir);
					 }
					 else {
						 newdir.set(0.0, 0.0, 0.0);
						 randomizePoint(newdir, 1.0);
						 newdir.normalize();
					 }
					 tracePhoton(r.rt.ray[treeDepth+1], rayIntensity, treeDepth+1, node, first, material, prevMaterial, currentMatTrans, prevMatTrans, totalDist, true, caustic);
				 }
			 }
			 color.setRGB(0.0, 0.0, 0.0);
			 break;
		 }
		 color.scale(1.0/(1.0-scatProb));
		 if ((includeDirect || scattered) && color.getMaxComponent() > this.rt.minRayIntensity) addPhoton(v, direction, color);
		 color.setRGB(0.0, 0.0, 0.0);
		 break;
	 }
	 while (x < dist);
 }",0,0,1,0
"public class NamedChannel extends Channel {
	private final String name;
	public NamedChannel(String name, PlanNode sourceNode) {
		super(sourceNode);
		this.name = name;
	}
	public NamedChannel(String name, PlanNode sourceNode, TempMode tempMode) {
		super(sourceNode, tempMode);
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
}",0,0,0,0
"public SerializerOptions(boolean format, boolean validateConcreteSyntax) {
	super();
	this.formatting = format;
	this.validateConcreteSyntax = validateConcreteSyntax;
}",0,0,0,0
"public class ScriptRuntime {
	 protected ScriptRuntime() {
	 }
	 public final static Class BooleanClass = Kit.classOrNull(""java.lang.Boolean""), ByteClass = Kit.classOrNull(""java.lang.Byte""), CharacterClass = Kit.classOrNull(""java.lang.Character""), ClassClass = Kit.classOrNull(""java.lang.Class""), DoubleClass = Kit.classOrNull(""java.lang.Double""), FloatClass = Kit.classOrNull(""java.lang.Float""), IntegerClass = Kit.classOrNull(""java.lang.Integer""), LongClass = Kit.classOrNull(""java.lang.Long""), NumberClass = Kit.classOrNull(""java.lang.Number""), ObjectClass = Kit.classOrNull(""java.lang.Object""), ShortClass = Kit.classOrNull(""java.lang.Short""), StringClass = Kit.classOrNull(""java.lang.String""), DateClass = Kit.classOrNull(""java.util.Date"");
	 public final static Class ContextClass = Kit.classOrNull(""org.mozilla.javascript.Context""), ContextFactoryClass = Kit.classOrNull(""org.mozilla.javascript.ContextFactory""), FunctionClass = Kit.classOrNull(""org.mozilla.javascript.Function""), ScriptableClass = Kit.classOrNull(""org.mozilla.javascript.Scriptable""), ScriptableObjectClass = Kit.classOrNull(""org.mozilla.javascript.ScriptableObject"");
	 private static final String XML_INIT_CLASS = ""org.mozilla.javascript.xmlimpl.XMLLibImpl"";
	 private static final String[] lazilyNames = {
	 ""RegExp"", ""org.mozilla.javascript.regexp.NativeRegExp"", ""Packages"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""java"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""getClass"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""JavaAdapter"", ""org.mozilla.javascript.JavaAdapter"", ""JavaImporter"", ""org.mozilla.javascript.ImporterTopLevel"", ""XML"", XML_INIT_CLASS, ""XMLList"", XML_INIT_CLASS, ""Namespace"", XML_INIT_CLASS, ""QName"", XML_INIT_CLASS, }
	;
	 private static final Object LIBRARY_SCOPE_KEY = new Object();
	 public static boolean isRhinoRuntimeType(Class cl) {
		 if (cl.isPrimitive()) {
			 return (cl != Character.TYPE);
		 }
		 else {
			 return (cl == StringClass || cl == BooleanClass || NumberClass.isAssignableFrom(cl) || ScriptableClass.isAssignableFrom(cl));
		 }
	 }
	 public static ScriptableObject initStandardObjects(Context cx, ScriptableObject scope, boolean sealed) {
		 if (scope == null) {
			 scope = new NativeObject();
		 }
		 scope.associateValue(LIBRARY_SCOPE_KEY, scope);
		 (new ClassCache()).associate(scope);
		 BaseFunction.init(scope, sealed);
		 NativeObject.init(scope, sealed);
		 Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
		 Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);
		 functionProto.setPrototype(objectProto);
		 if (scope.getPrototype() == null) scope.setPrototype(objectProto);
		 NativeError.init(scope, sealed);
		 NativeGlobal.init(cx, scope, sealed);
		 NativeArray.init(scope, sealed);
		 NativeString.init(scope, sealed);
		 NativeBoolean.init(scope, sealed);
		 NativeNumber.init(scope, sealed);
		 NativeDate.init(scope, sealed);
		 NativeMath.init(scope, sealed);
		 NativeWith.init(scope, sealed);
		 NativeCall.init(scope, sealed);
		 NativeScript.init(scope, sealed);
		 boolean withXml = cx.hasFeature(Context.FEATURE_E4X);
		 for (int i = 0;
		 i != lazilyNames.length;
		 i += 2) {
			 String topProperty = lazilyNames[i];
			 String className = lazilyNames[i + 1];
			 if (!withXml && className == XML_INIT_CLASS) {
				 continue;
			 }
			 new LazilyLoadedCtor(scope, topProperty, className, sealed);
		 }
		 Continuation.init(scope, sealed);
		 return scope;
	 }
	 public static ScriptableObject getLibraryScopeOrNull(Scriptable scope) {
		 ScriptableObject libScope;
		 libScope = (ScriptableObject)ScriptableObject. getTopScopeValue(scope, LIBRARY_SCOPE_KEY);
		 return libScope;
	 }
	 public static boolean isJSLineTerminator(int c) {
		 if ((c & 0xDFD0) != 0) {
			 return false;
		 }
		 return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
	 }
	 public static Boolean wrapBoolean(boolean b) {
		 return b ? Boolean.TRUE : Boolean.FALSE;
	 }
	 public static Integer wrapInt(int i) {
		 return new Integer(i);
	 }
	 public static Number wrapNumber(double x) {
		 if (x != x) {
			 return ScriptRuntime.NaNobj;
		 }
		 return new Double(x);
	 }
	 public static boolean toBoolean(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue();
			 if (val == null || val == Undefined.instance) return false;
			 if (val instanceof String) return ((String) val).length() != 0;
			 if (val instanceof Number) {
				 double d = ((Number) val).doubleValue();
				 return (d == d && d != 0.0);
			 }
			 if (val instanceof Scriptable) {
				 if (Context.getContext().isVersionECMA1()) {
					 return true;
				 }
				 val = ((Scriptable) val).getDefaultValue(BooleanClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return true;
		 }
	 }
	 public static boolean toBoolean(Object[] args, int index) {
		 return (index < args.length) ? toBoolean(args[index]) : false;
	 }
	 public static double toNumber(Object val) {
		 for (;
		;
		) {
			 if (val instanceof Number) return ((Number) val).doubleValue();
			 if (val == null) return +0.0;
			 if (val == Undefined.instance) return NaN;
			 if (val instanceof String) return toNumber((String) val);
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue() ? 1 : +0.0;
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(NumberClass);
				 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
				 continue;
			 }
			 warnAboutNonJSObject(val);
			 return NaN;
		 }
	 }
	 public static double toNumber(Object[] args, int index) {
		 return (index < args.length) ? toNumber(args[index]) : NaN;
	 }
	 public static final double NaN = Double.longBitsToDouble(0x7ff8000000000000L);
	 public static final double negativeZero = Double.longBitsToDouble(0x8000000000000000L);
	 public static final Double NaNobj = new Double(NaN);
	 static double stringToNumber(String s, int start, int radix) {
		 char digitMax = '9';
		 char lowerCaseBound = 'a';
		 char upperCaseBound = 'A';
		 int len = s.length();
		 if (radix < 10) {
			 digitMax = (char) ('0' + radix - 1);
		 }
		 if (radix > 10) {
			 lowerCaseBound = (char) ('a' + radix - 10);
			 upperCaseBound = (char) ('A' + radix - 10);
		 }
		 int end;
		 double sum = 0.0;
		 for (end=start;
		 end < len;
		 end++) {
			 char c = s.charAt(end);
			 int newDigit;
			 if ('0' <= c && c <= digitMax) newDigit = c - '0';
			 else if ('a' <= c && c < lowerCaseBound) newDigit = c - 'a' + 10;
			 else if ('A' <= c && c < upperCaseBound) newDigit = c - 'A' + 10;
			 else break;
			 sum = sum*radix + newDigit;
		 }
		 if (start == end) {
			 return NaN;
		 }
		 if (sum >= 9007199254740992.0) {
			 if (radix == 10) {
				 try {
					 return Double.valueOf(s.substring(start, end)).doubleValue();
				 }
				 catch (NumberFormatException nfe) {
					 return NaN;
				 }
			 }
			 else if (radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32) {
				 int bitShiftInChar = 1;
				 int digit = 0;
				 final int SKIP_LEADING_ZEROS = 0;
				 final int FIRST_EXACT_53_BITS = 1;
				 final int AFTER_BIT_53 = 2;
				 final int ZEROS_AFTER_54 = 3;
				 final int MIXED_AFTER_54 = 4;
				 int state = SKIP_LEADING_ZEROS;
				 int exactBitsLimit = 53;
				 double factor = 0.0;
				 boolean bit53 = false;
				 boolean bit54 = false;
				 for (;
				;
				) {
					 if (bitShiftInChar == 1) {
						 if (start == end) break;
						 digit = s.charAt(start++);
						 if ('0' <= digit && digit <= '9') digit -= '0';
						 else if ('a' <= digit && digit <= 'z') digit -= 'a' - 10;
						 else digit -= 'A' - 10;
						 bitShiftInChar = radix;
					 }
					 bitShiftInChar >>= 1;
					 boolean bit = (digit & bitShiftInChar) != 0;
					 switch (state) {
						 case SKIP_LEADING_ZEROS: if (bit) {
							 --exactBitsLimit;
							 sum = 1.0;
							 state = FIRST_EXACT_53_BITS;
						 }
						 break;
						 case FIRST_EXACT_53_BITS: sum *= 2.0;
						 if (bit) sum += 1.0;
						 --exactBitsLimit;
						 if (exactBitsLimit == 0) {
							 bit53 = bit;
							 state = AFTER_BIT_53;
						 }
						 break;
						 case AFTER_BIT_53: bit54 = bit;
						 factor = 2.0;
						 state = ZEROS_AFTER_54;
						 break;
						 case ZEROS_AFTER_54: if (bit) {
							 state = MIXED_AFTER_54;
						 }
						 case MIXED_AFTER_54: factor *= 2;
						 break;
					 }
				 }
				 switch (state) {
					 case SKIP_LEADING_ZEROS: sum = 0.0;
					 break;
					 case FIRST_EXACT_53_BITS: case AFTER_BIT_53: break;
					 case ZEROS_AFTER_54: if (bit54 & bit53) sum += 1.0;
					 sum *= factor;
					 break;
					 case MIXED_AFTER_54: if (bit54) sum += 1.0;
					 sum *= factor;
					 break;
				 }
			 }
		 }
		 return sum;
	 }
	 public static double toNumber(String s) {
		 int len = s.length();
		 int start = 0;
		 char startChar;
		 for (;
		;
		) {
			 if (start == len) {
				 return +0.0;
			 }
			 startChar = s.charAt(start);
			 if (!Character.isWhitespace(startChar)) break;
			 start++;
		 }
		 if (startChar == '0') {
			 if (start + 2 < len) {
				 int c1 = s.charAt(start + 1);
				 if (c1 == 'x' || c1 == 'X') {
					 return stringToNumber(s, start + 2, 16);
				 }
			 }
		 }
		 else if (startChar == '+' || startChar == '-') {
			 if (start + 3 < len && s.charAt(start + 1) == '0') {
				 int c2 = s.charAt(start + 2);
				 if (c2 == 'x' || c2 == 'X') {
					 double val = stringToNumber(s, start + 3, 16);
					 return startChar == '-' ? -val : val;
				 }
			 }
		 }
		 int end = len - 1;
		 char endChar;
		 while (Character.isWhitespace(endChar = s.charAt(end))) end--;
		 if (endChar == 'y') {
			 if (startChar == '+' || startChar == '-') start++;
			 if (start + 7 == end && s.regionMatches(start, ""Infinity"", 0, 8)) return startChar == '-' ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
			 return NaN;
		 }
		 String sub = s.substring(start, end+1);
		 if (MSJVM_BUG_WORKAROUNDS) {
			 for (int i=sub.length()-1;
			 i >= 0;
			 i--) {
				 char c = sub.charAt(i);
				 if (('0' <= c && c <= '9') || c == '.' || c == 'e' || c == 'E' || c == '+' || c == '-') continue;
				 return NaN;
			 }
		 }
		 try {
			 return Double.valueOf(sub).doubleValue();
		 }
		 catch (NumberFormatException ex) {
			 return NaN;
		 }
	 }
	 public static Object[] padArguments(Object[] args, int count) {
		 if (count < args.length) return args;
		 int i;
		 Object[] result = new Object[count];
		 for (i = 0;
		 i < args.length;
		 i++) {
			 result[i] = args[i];
		 }
		 for (;
		 i < count;
		 i++) {
			 result[i] = Undefined.instance;
		 }
		 return result;
	 }
	 private final static boolean MSJVM_BUG_WORKAROUNDS = true;
	 public static String escapeString(String s) {
		 return escapeString(s, '""');
	 }
	 public static String escapeString(String s, char escapeQuote) {
		 if (!(escapeQuote == '""' || escapeQuote == '\'')) Kit.codeBug();
		 StringBuffer sb = null;
		 for(int i = 0, L = s.length();
		 i != L;
		 ++i) {
			 int c = s.charAt(i);
			 if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\') {
				 if (sb != null) {
					 sb.append((char)c);
				 }
				 continue;
			 }
			 if (sb == null) {
				 sb = new StringBuffer(L + 3);
				 sb.append(s);
				 sb.setLength(i);
			 }
			 int escape = -1;
			 switch (c) {
				 case '\b': escape = 'b';
				 break;
				 case '\f': escape = 'f';
				 break;
				 case '\n': escape = 'n';
				 break;
				 case '\r': escape = 'r';
				 break;
				 case '\t': escape = 't';
				 break;
				 case 0xb: escape = 'v';
				 break;
				 case ' ': escape = ' ';
				 break;
				 case '\\': escape = '\\';
				 break;
			 }
			 if (escape >= 0) {
				 sb.append('\\');
				 sb.append((char)escape);
			 }
			 else if (c == escapeQuote) {
				 sb.append('\\');
				 sb.append(escapeQuote);
			 }
			 else {
				 int hexSize;
				 if (c < 256) {
					 sb.append(""\\x"");
					 hexSize = 2;
				 }
				 else {
					 sb.append(""\\u"");
					 hexSize = 4;
				 }
				 for (int shift = (hexSize - 1) * 4;
				 shift >= 0;
				 shift -= 4) {
					 int digit = 0xf & (c >> shift);
					 int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
					 sb.append((char)hc);
				 }
			 }
		 }
		 return (sb == null) ? s : sb.toString();
	 }
	 static boolean isValidIdentifierName(String s) {
		 int L = s.length();
		 if (L == 0) return false;
		 if (!Character.isJavaIdentifierStart(s.charAt(0))) return false;
		 for (int i = 1;
		 i != L;
		 ++i) {
			 if (!Character.isJavaIdentifierPart(s.charAt(i))) return false;
		 }
		 return !TokenStream.isKeyword(s);
	 }
	 public static String toString(Object val) {
		 for (;
		;
		) {
			 if (val == null) {
				 return ""null"";
			 }
			 if (val == Undefined.instance) {
				 return ""undefined"";
			 }
			 if (val instanceof String) {
				 return (String)val;
			 }
			 if (val instanceof Number) {
				 return numberToString(((Number)val).doubleValue(), 10);
			 }
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(StringClass);
				 if (val instanceof Scriptable) {
					 throw errorWithClassName(""msg.primitive.expected"", val);
				 }
				 continue;
			 }
			 return val.toString();
		 }
	 }
	 static String defaultObjectToString(Scriptable obj) {
		 return ""[object "" + obj.getClassName() + ']';
	 }
	 public static String toString(Object[] args, int index) {
		 return (index < args.length) ? toString(args[index]) : ""undefined"";
	 }
	 public static String toString(double val) {
		 return numberToString(val, 10);
	 }
	 public static String numberToString(double d, int base) {
		 if (d != d) return ""NaN"";
		 if (d == Double.POSITIVE_INFINITY) return ""Infinity"";
		 if (d == Double.NEGATIVE_INFINITY) return ""-Infinity"";
		 if (d == 0.0) return ""0"";
		 if ((base < 2) || (base > 36)) {
			 throw Context.reportRuntimeError1( ""msg.bad.radix"", Integer.toString(base));
		 }
		 if (base != 10) {
			 return DToA.JS_dtobasestr(base, d);
		 }
		 else {
			 StringBuffer result = new StringBuffer();
			 DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);
			 return result.toString();
		 }
	 }
	 static String uneval(Context cx, Scriptable scope, Object value) {
		 if (value == null) {
			 return ""null"";
		 }
		 if (value == Undefined.instance) {
			 return ""undefined"";
		 }
		 if (value instanceof String) {
			 String escaped = escapeString((String)value);
			 StringBuffer sb = new StringBuffer(escaped.length() + 2);
			 sb.append('\""');
			 sb.append(escaped);
			 sb.append('\""');
			 return sb.toString();
		 }
		 if (value instanceof Number) {
			 double d = ((Number)value).doubleValue();
			 if (d == 0 && 1 / d < 0) {
				 return ""-0"";
			 }
			 return toString(d);
		 }
		 if (value instanceof Boolean) {
			 return toString(value);
		 }
		 if (value instanceof Scriptable) {
			 Scriptable obj = (Scriptable)value;
			 Object v = ScriptableObject.getProperty(obj, ""toSource"");
			 if (v instanceof Function) {
				 Function f = (Function)v;
				 return toString(f.call(cx, scope, obj, emptyArgs));
			 }
			 return toString(value);
		 }
		 warnAboutNonJSObject(value);
		 return value.toString();
	 }
	 static String defaultObjectToSource(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 StringBuffer result = new StringBuffer(128);
		 if (toplevel) {
			 result.append(""("");
		 }
		 result.append('{
			');
			 try {
				 if (!iterating) {
					 cx.iterating.intern(thisObj);
					 Object[] ids = thisObj.getIds();
					 for(int i=0;
					 i < ids.length;
					 i++) {
						 if (i > 0) result.append("", "");
						 Object id = ids[i];
						 Object value;
						 if (id instanceof Integer) {
							 int intId = ((Integer)id).intValue();
							 value = thisObj.get(intId, thisObj);
							 result.append(intId);
						 }
						 else {
							 String strId = (String)id;
							 value = thisObj.get(strId, thisObj);
							 if (ScriptRuntime.isValidIdentifierName(strId)) {
								 result.append(strId);
							 }
							 else {
								 result.append('\'');
								 result.append( ScriptRuntime.escapeString(strId, '\''));
								 result.append('\'');
							 }
						 }
						 result.append(':');
						 result.append(ScriptRuntime.uneval(cx, scope, value));
					 }
				 }
			 }
			 finally {
				 if (toplevel) {
					 cx.iterating = null;
				 }
			 }
		 result.append('}
		');
		 if (toplevel) {
			 result.append(')');
		 }
		 return result.toString();
	 }
	 public static Scriptable toObject(Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObjectOrNull(Context cx, Object obj) {
		 if (obj instanceof Scriptable) {
			 return (Scriptable)obj;
		 }
		 else if (obj != null && obj != Undefined.instance) {
			 return toObject(cx, getTopCallScope(cx), obj);
		 }
		 return null;
	 }
	 public static Scriptable toObject(Scriptable scope, Object val, Class staticClass) {
		 if (val instanceof Scriptable) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 return (Scriptable) val;
		 }
		 if (val == null) {
			 throw typeError0(""msg.null.to.object"");
		 }
		 if (val == Undefined.instance) {
			 throw typeError0(""msg.undef.to.object"");
		 }
		 String className = val instanceof String ? ""String"" : val instanceof Number ? ""Number"" : val instanceof Boolean ? ""Boolean"" : null;
		 if (className != null) {
			 Object[] args = {
			 val }
			;
			 scope = ScriptableObject.getTopLevelScope(scope);
			 return newObject(cx, scope, className, args);
		 }
		 Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);
		 if (wrapped instanceof Scriptable) return (Scriptable) wrapped;
		 throw errorWithClassName(""msg.invalid.type"", val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val, Class staticClass) {
		 return toObject(cx, scope, val);
	 }
	 public static Object call(Context cx, Object fun, Object thisArg, Object[] args, Scriptable scope) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(toString(fun));
		 }
		 Function function = (Function)fun;
		 Scriptable thisObj = toObjectOrNull(cx, thisArg);
		 if (thisObj == null) {
			 throw undefCallError(thisObj, ""function"");
		 }
		 return function.call(cx, scope, thisObj, args);
	 }
	 public static Scriptable newObject(Context cx, Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = getExistingCtor(cx, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(cx, scope, args);
	 }
	 public static double toInteger(Object val) {
		 return toInteger(toNumber(val));
	 }
	 public static double toInteger(double d) {
		 if (d != d) return +0.0;
		 if (d == 0.0 || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) return d;
		 if (d > 0.0) return Math.floor(d);
		 else return Math.ceil(d);
	 }
	 public static double toInteger(Object[] args, int index) {
		 return (index < args.length) ? toInteger(args[index]) : +0.0;
	 }
	 public static int toInt32(Object val) {
		 if (val instanceof Integer) return ((Integer)val).intValue();
		 return toInt32(toNumber(val));
	 }
	 public static int toInt32(Object[] args, int index) {
		 return (index < args.length) ? toInt32(args[index]) : 0;
	 }
	 public static int toInt32(double d) {
		 int id = (int)d;
		 if (id == d) {
			 return id;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 d = Math.IEEEremainder(d, two32);
		 long l = (long)d;
		 return (int)l;
	 }
	 public static long toUint32(double d) {
		 long l = (long)d;
		 if (l == d) {
			 return l & 0xffffffffL;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 l = (long)Math.IEEEremainder(d, two32);
		 return l & 0xffffffffL;
	 }
	 public static long toUint32(Object val) {
		 return toUint32(toNumber(val));
	 }
	 public static char toUint16(Object val) {
		 double d = toNumber(val);
		 int i = (int)d;
		 if (i == d) {
			 return (char)i;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 int int16 = 0x10000;
		 i = (int)Math.IEEEremainder(d, int16);
		 return (char)i;
	 }
	 private static final String DEFAULT_NS_TAG = ""__default_namespace__"";
	 public static Object setDefaultNamespace(Object namespace, Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 XMLLib xmlLib = currentXMLLib(cx);
		 Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);
		 if (!scope.has(DEFAULT_NS_TAG, scope)) {
			 ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns, ScriptableObject.PERMANENT | ScriptableObject.DONTENUM);
		 }
		 else {
			 scope.put(DEFAULT_NS_TAG, scope, ns);
		 }
		 return Undefined.instance;
	 }
	 public static Object searchDefaultNamespace(Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 Object nsObject;
		 for (;
		;
		) {
			 Scriptable parent = scope.getParentScope();
			 if (parent == null) {
				 nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);
				 if (nsObject == Scriptable.NOT_FOUND) {
					 return null;
				 }
				 break;
			 }
			 nsObject = scope.get(DEFAULT_NS_TAG, scope);
			 if (nsObject != Scriptable.NOT_FOUND) {
				 break;
			 }
			 scope = parent;
		 }
		 return nsObject;
	 }
	 public static Object getTopLevelProp(Scriptable scope, String id) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 return ScriptableObject.getProperty(scope, id);
	 }
	 static Function getExistingCtor(Context cx, Scriptable scope, String constructorName) {
		 Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
		 if (ctorVal instanceof Function) {
			 return (Function)ctorVal;
		 }
		 if (ctorVal == Scriptable.NOT_FOUND) {
			 throw Context.reportRuntimeError1( ""msg.ctor.not.found"", constructorName);
		 }
		 else {
			 throw Context.reportRuntimeError1( ""msg.not.ctor"", constructorName);
		 }
	 }
	 private static long indexFromString(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (len > 0) {
			 int i = 0;
			 boolean negate = false;
			 int c = str.charAt(0);
			 if (c == '-') {
				 if (len > 1) {
					 c = str.charAt(1);
					 i = 1;
					 negate = true;
				 }
			 }
			 c -= '0';
			 if (0 <= c && c <= 9 && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH)) {
				 int index = -c;
				 int oldIndex = 0;
				 i++;
				 if (index != 0) {
					 while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9) {
						 oldIndex = index;
						 index = 10 * index - c;
						 i++;
					 }
				 }
				 if (i == len && (oldIndex > (Integer.MIN_VALUE / 10) || (oldIndex == (Integer.MIN_VALUE / 10) && c <= (negate ? -(Integer.MIN_VALUE % 10) : (Integer.MAX_VALUE % 10))))) {
					 return 0xFFFFFFFFL & (negate ? index : -index);
				 }
			 }
		 }
		 return -1L;
	 }
	 public static long testUint32String(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (1 <= len && len <= MAX_VALUE_LENGTH) {
			 int c = str.charAt(0);
			 c -= '0';
			 if (c == 0) {
				 return (len == 1) ? 0L : -1L;
			 }
			 if (1 <= c && c <= 9) {
				 long v = c;
				 for (int i = 1;
				 i != len;
				 ++i) {
					 c = str.charAt(i) - '0';
					 if (!(0 <= c && c <= 9)) {
						 return -1;
					 }
					 v = 10 * v + c;
				 }
				 if ((v >>> 32) == 0) {
					 return v;
				 }
			 }
		 }
		 return -1;
	 }
	 static Object getIndexObject(String s) {
		 long indexTest = indexFromString(s);
		 if (indexTest >= 0) {
			 return new Integer((int)indexTest);
		 }
		 return s;
	 }
	 static Object getIndexObject(double d) {
		 int i = (int)d;
		 if ((double)i == d) {
			 return new Integer((int)i);
		 }
		 return toString(d);
	 }
	 static String toStringIdOrIndex(Context cx, Object id) {
		 if (id instanceof Number) {
			 double d = ((Number)id).doubleValue();
			 int index = (int)d;
			 if (((double)index) == d) {
				 storeIndexResult(cx, index);
				 return null;
			 }
			 return toString(id);
		 }
		 else {
			 String s;
			 if (id instanceof String) {
				 s = (String)id;
			 }
			 else {
				 s = toString(id);
			 }
			 long indexTest = indexFromString(s);
			 if (indexTest >= 0) {
				 storeIndexResult(cx, (int)indexTest);
				 return null;
			 }
			 return s;
		 }
	 }
	 public static Object getObjectElem(Object obj, Object elem, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, elem);
		 }
		 return getObjectElem(sobj, elem, cx);
	 }
	 public static Object getObjectElem(Scriptable obj, Object elem, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, elem);
		 }
		 Object result;
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = ScriptableObject.getProperty(obj, index);
		 }
		 else {
			 result = ScriptableObject.getProperty(obj, s);
		 }
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectProp(Object obj, String property, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, property);
		 }
		 return getObjectProp(sobj, property, cx);
	 }
	 public static Object getObjectProp(Scriptable obj, String property, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, property);
		 }
		 Object result = ScriptableObject.getProperty(obj, property);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectIndex(Object obj, double dblIndex, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, toString(dblIndex));
		 }
		 int index = (int)dblIndex;
		 if ((double)index == dblIndex) {
			 return getObjectIndex(sobj, index, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return getObjectProp(sobj, s, cx);
		 }
	 }
	 public static Object getObjectIndex(Scriptable obj, int index, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, new Integer(index));
		 }
		 Object result = ScriptableObject.getProperty(obj, index);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object setObjectElem(Object obj, Object elem, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, elem, value);
		 }
		 return setObjectElem(sobj, elem, value, cx);
	 }
	 public static Object setObjectElem(Scriptable obj, Object elem, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, elem, value);
			 return value;
		 }
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, s, value);
		 }
		 return value;
	 }
	 public static Object setObjectProp(Object obj, String property, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, property, value);
		 }
		 return setObjectProp(sobj, property, value, cx);
	 }
	 public static Object setObjectProp(Scriptable obj, String property, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, property, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, property, value);
		 }
		 return value;
	 }
	 public static Object setObjectIndex(Object obj, double dblIndex, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, String.valueOf(dblIndex), value);
		 }
		 int index = (int)dblIndex;
		 if ((double)index == dblIndex) {
			 return setObjectIndex(sobj, index, value, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return setObjectProp(sobj, s, value, cx);
		 }
	 }
	 public static Object setObjectIndex(Scriptable obj, int index, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, new Integer(index), value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 return value;
	 }
	 public static boolean deleteObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaDelete(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.deleteProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.deleteProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static boolean hasObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaHas(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.hasProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.hasProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static Object refGet(Ref ref, Context cx) {
		 return ref.get(cx);
	 }
	 public static Object refSet(Ref ref, Object value, Context cx) {
		 return ref.set(cx, value);
	 }
	 public static Object refDel(Ref ref, Context cx) {
		 return wrapBoolean(ref.delete(cx));
	 }
	 static boolean isSpecialProperty(String s) {
		 return s.equals(""__proto__"") || s.equals(""__parent__"");
	 }
	 public static Ref specialRef(Object obj, String specialProperty, Context cx) {
		 return SpecialRef.createSpecial(cx, obj, specialProperty);
	 }
	 public static Object delete(Object obj, Object id, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 String idStr = (id == null) ? ""null"" : id.toString();
			 throw typeError2(""msg.undef.prop.delete"", toString(obj), idStr);
		 }
		 boolean result = deleteObjectElem(sobj, id, cx);
		 return wrapBoolean(result);
	 }
	 public static Object name(Context cx, Scriptable scope, String name) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (result == Scriptable.NOT_FOUND) {
				 throw notFoundError(scope, name);
			 }
			 return result;
		 }
		 return nameOrFunction(cx, scope, parent, name, false);
	 }
	 private static Object nameOrFunction(Context cx, Scriptable scope, Scriptable parentScope, String name, boolean asFunctionCall) {
		 Object result;
		 Scriptable thisObj = scope;
		 XMLObject firstXMLObject = null;
		 for (;
		;
		) {
			 if (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObj = (XMLObject)withObj;
					 if (xmlObj.ecmaHas(cx, name)) {
						 thisObj = xmlObj;
						 result = xmlObj.ecmaGet(cx, name);
						 break;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObj;
					 }
				 }
				 else {
					 result = ScriptableObject.getProperty(withObj, name);
					 if (result != Scriptable.NOT_FOUND) {
						 thisObj = withObj;
						 break;
					 }
				 }
			 }
			 else if (scope instanceof NativeCall) {
				 result = scope.get(name, scope);
				 if (result != Scriptable.NOT_FOUND) {
					 if (asFunctionCall) {
						 thisObj = ScriptableObject. getTopLevelScope(parentScope);
					 }
					 break;
				 }
			 }
			 else {
				 result = ScriptableObject.getProperty(scope, name);
				 if (result != Scriptable.NOT_FOUND) {
					 thisObj = scope;
					 break;
				 }
			 }
			 scope = parentScope;
			 parentScope = parentScope.getParentScope();
			 if (parentScope == null) {
				 result = topScopeName(cx, scope, name);
				 if (result == Scriptable.NOT_FOUND) {
					 if (firstXMLObject == null || asFunctionCall) {
						 throw notFoundError(scope, name);
					 }
					 result = firstXMLObject.ecmaGet(cx, name);
				 }
				 thisObj = scope;
				 break;
			 }
		 }
		 if (asFunctionCall) {
			 if (!(result instanceof Callable)) {
				 throw notFunctionError(result, name);
			 }
			 storeScriptable(cx, thisObj);
		 }
		 return result;
	 }
	 private static Object topScopeName(Context cx, Scriptable scope, String name) {
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 return ScriptableObject.getProperty(scope, name);
	 }
	 public static Scriptable bind(Context cx, Scriptable scope, String id) {
		 Scriptable firstXMLObject = null;
		 Scriptable parent = scope.getParentScope();
		 childScopesChecks: if (parent != null) {
			 while (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObject = (XMLObject)withObj;
					 if (xmlObject.ecmaHas(cx, id)) {
						 return xmlObject;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObject;
					 }
				 }
				 else {
					 if (ScriptableObject.hasProperty(withObj, id)) {
						 return withObj;
					 }
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
			 for (;
			;
			) {
				 if (ScriptableObject.hasProperty(scope, id)) {
					 return scope;
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
		 }
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 if (ScriptableObject.hasProperty(scope, id)) {
			 return scope;
		 }
		 return firstXMLObject;
	 }
	 public static Object setName(Scriptable bound, Object value, Context cx, Scriptable scope, String id) {
		 if (bound != null) {
			 if (bound instanceof XMLObject) {
				 XMLObject xmlObject = (XMLObject)bound;
				 xmlObject.ecmaPut(cx, id, value);
			 }
			 else {
				 ScriptableObject.putProperty(bound, id, value);
			 }
		 }
		 else {
			 if (cx.hasFeature(Context.FEATURE_STRICT_VARS)) {
				 throw Context.reportRuntimeError1(""msg.assn.create.strict"", id);
			 }
			 bound = ScriptableObject.getTopLevelScope(scope);
			 if (cx.useDynamicScope) {
				 bound = checkDynamicScope(cx.topCallScope, bound);
			 }
			 bound.put(id, bound, value);
		 }
		 return value;
	 }
	 private static class IdEnumeration {
		 Scriptable obj;
		 Object[] ids;
		 int index;
		 ObjToIntMap used;
		 String currentId;
		 boolean enumValues;
	 }
	 public static Object enumInit(Object value, Context cx, boolean enumValues) {
		 IdEnumeration x = new IdEnumeration();
		 x.obj = toObjectOrNull(cx, value);
		 if (x.obj != null) {
			 x.enumValues = enumValues;
			 enumChangeObject(x);
		 }
		 return x;
	 }
	 public static Boolean enumNext(Object enumObj) {
		 boolean result;
		 IdEnumeration x = (IdEnumeration)enumObj;
		 for (;
		;
		) {
			 if (x.obj == null) {
				 result = false;
				 break;
			 }
			 if (x.index == x.ids.length) {
				 x.obj = x.obj.getPrototype();
				 enumChangeObject(x);
				 continue;
			 }
			 Object id = x.ids[x.index++];
			 if (x.used != null && x.used.has(id)) {
				 continue;
			 }
			 if (id instanceof String) {
				 String strId = (String)id;
				 if (!x.obj.has(strId, x.obj)) continue;
				 x.currentId = strId;
			 }
			 else {
				 int intId = ((Number)id).intValue();
				 if (!x.obj.has(intId, x.obj)) continue;
				 x.currentId = String.valueOf(intId);
			 }
			 result = true;
			 break;
		 }
		 return wrapBoolean(result);
	 }
	 public static Object enumId(Object enumObj, Context cx) {
		 IdEnumeration x = (IdEnumeration)enumObj;
		 if (!x.enumValues) return x.currentId;
		 Object result;
		 String s = toStringIdOrIndex(cx, x.currentId);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = x.obj.get(index, x.obj);
		 }
		 else {
			 result = x.obj.get(s, x.obj);
		 }
		 return result;
	 }
	 private static void enumChangeObject(IdEnumeration x) {
		 Object[] ids = null;
		 while (x.obj != null) {
			 ids = x.obj.getIds();
			 if (ids.length != 0) {
				 break;
			 }
			 x.obj = x.obj.getPrototype();
		 }
		 if (x.obj != null && x.ids != null) {
			 Object[] previous = x.ids;
			 int L = previous.length;
			 if (x.used == null) {
				 x.used = new ObjToIntMap(L);
			 }
			 for (int i = 0;
			 i != L;
			 ++i) {
				 x.used.intern(previous[i]);
			 }
		 }
		 x.ids = ids;
		 x.index = 0;
	 }
	 public static Callable getNameFunctionAndThis(String name, Context cx, Scriptable scope) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (!(result instanceof Callable)) {
				 if (result == Scriptable.NOT_FOUND) {
					 throw notFoundError(scope, name);
				 }
				 else {
					 throw notFunctionError(result, name);
				 }
			 }
			 Scriptable thisObj = scope;
			 storeScriptable(cx, thisObj);
			 return (Callable)result;
		 }
		 return (Callable)nameOrFunction(cx, scope, parent, name, true);
	 }
	 public static Callable getElemFunctionAndThis(Object obj, Object elem, Context cx) {
		 String s = toStringIdOrIndex(cx, elem);
		 if (s != null) {
			 return getPropFunctionAndThis(obj, s, cx);
		 }
		 int index = lastIndexResult(cx);
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, String.valueOf(index));
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, index);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, elem);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getPropFunctionAndThis(Object obj, String property, Context cx) {
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, property);
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, property);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value, property);
		 }
		 storeScriptable(cx, thisObj);
		 return (Callable)value;
	 }
	 public static Callable getValueFunctionAndThis(Object value, Context cx) {
		 if (!(value instanceof Callable)) {
			 throw notFunctionError(value);
		 }
		 Callable f = (Callable)value;
		 Scriptable thisObj;
		 if (f instanceof Scriptable) {
			 thisObj = ((Scriptable)f).getParentScope();
		 }
		 else {
			 if (cx.topCallScope == null) throw new IllegalStateException();
			 thisObj = cx.topCallScope;
		 }
		 if (thisObj.getParentScope() != null) {
			 if (thisObj instanceof NativeWith) {
			 }
			 else if (thisObj instanceof NativeCall) {
				 thisObj = ScriptableObject.getTopLevelScope(thisObj);
			 }
		 }
		 storeScriptable(cx, thisObj);
		 return f;
	 }
	 public static Ref callRef(Callable function, Scriptable thisObj, Object[] args, Context cx) {
		 if (function instanceof RefCallable) {
			 RefCallable rfunction = (RefCallable)function;
			 Ref ref = rfunction.refCall(cx, thisObj, args);
			 if (ref == null) {
				 throw new IllegalStateException(rfunction.getClass().getName()+"".refCall() returned null"");
			 }
			 return ref;
		 }
		 String msg = getMessage1(""msg.no.ref.from.function"", toString(function));
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static Scriptable newObject(Object fun, Context cx, Scriptable scope, Object[] args) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(fun);
		 }
		 Function function = (Function)fun;
		 return function.construct(cx, scope, args);
	 }
	 public static Object callSpecial(Context cx, Callable fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String filename, int lineNumber) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 return evalSpecial(cx, scope, callerThis, args, filename, lineNumber);
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 throw Context.reportRuntimeError1(""msg.only.from.new"", ""With"");
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return fun.call(cx, scope, thisObj, args);
	 }
	 public static Object newSpecial(Context cx, Object fun, Object[] args, Scriptable scope, int callType) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 throw typeError1(""msg.not.ctor"", ""eval"");
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 return NativeWith.newWithSpecial(cx, scope, args);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return newObject(fun, cx, scope, args);
	 }
	 public static Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 int L = args.length;
		 Callable function;
		 if (thisObj instanceof Callable) {
			 function = (Callable)thisObj;
		 }
		 else {
			 Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);
			 if (!(value instanceof Callable)) {
				 throw ScriptRuntime.notFunctionError(value, thisObj);
			 }
			 function = (Callable)value;
		 }
		 Scriptable callThis = null;
		 if (L != 0) {
			 callThis = toObjectOrNull(cx, args[0]);
		 }
		 if (callThis == null) {
			 callThis = getTopCallScope(cx);
		 }
		 Object[] callArgs;
		 if (isApply) {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 Object arg1 = args[1];
				 if (arg1 == null || arg1 == Undefined.instance) {
					 callArgs = ScriptRuntime.emptyArgs;
				 }
				 else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {
					 callArgs = cx.getElements((Scriptable) arg1);
				 }
				 else {
					 throw ScriptRuntime.typeError0(""msg.arg.isnt.array"");
				 }
			 }
		 }
		 else {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 callArgs = new Object[L - 1];
				 System.arraycopy(args, 1, callArgs, 0, L - 1);
			 }
		 }
		 return function.call(cx, scope, callThis, callArgs);
	 }
	 public static Object evalSpecial(Context cx, Scriptable scope, Object thisArg, Object[] args, String filename, int lineNumber) {
		 if (args.length < 1) return Undefined.instance;
		 Object x = args[0];
		 if (!(x instanceof String)) {
			 if (cx.hasFeature(Context.FEATURE_STRICT_EVAL)) {
				 throw Context.reportRuntimeError0(""msg.eval.nonstring.strict"");
			 }
			 String message = ScriptRuntime.getMessage0(""msg.eval.nonstring"");
			 Context.reportWarning(message);
			 return x;
		 }
		 if (filename == null) {
			 int[] linep = new int[1];
			 filename = Context.getSourcePositionFromStack(linep);
			 if (filename != null) {
				 lineNumber = linep[0];
			 }
			 else {
				 filename = """";
			 }
		 }
		 String sourceName = ScriptRuntime. makeUrlForGeneratedScript(true, filename, lineNumber);
		 ErrorReporter reporter;
		 reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());
		 Script script = cx.compileString((String)x, new Interpreter(), reporter, sourceName, 1, null);
		 ((InterpretedFunction)script).idata.evalScriptFlag = true;
		 Callable c = (Callable)script;
		 return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);
	 }
	 public static String typeof(Object value) {
		 if (value == null) return ""object"";
		 if (value == Undefined.instance) return ""undefined"";
		 if (value instanceof Scriptable) {
			 if (value instanceof XMLObject) return ""xml"";
			 return (value instanceof Callable) ? ""function"" : ""object"";
		 }
		 if (value instanceof String) return ""string"";
		 if (value instanceof Number) return ""number"";
		 if (value instanceof Boolean) return ""boolean"";
		 throw errorWithClassName(""msg.invalid.type"", value);
	 }
	 public static String typeofName(Scriptable scope, String id) {
		 Context cx = Context.getContext();
		 Scriptable val = bind(cx, scope, id);
		 if (val == null) return ""undefined"";
		 return typeof(getObjectProp(val, id, cx));
	 }
	 public static Object add(Object val1, Object val2, Context cx) {
		 if(val1 instanceof Number && val2 instanceof Number) {
			 return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 }
		 if (val1 instanceof XMLObject) {
			 Object test = ((XMLObject)val1).addValues(cx, true, val2);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val2 instanceof XMLObject) {
			 Object test = ((XMLObject)val2).addValues(cx, false, val1);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(null);
		 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(null);
		 if (!(val1 instanceof String) && !(val2 instanceof String)) if ((val1 instanceof Number) && (val2 instanceof Number)) return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 else return wrapNumber(toNumber(val1) + toNumber(val2));
		 return toString(val1).concat(toString(val2));
	 }
	 public static Object nameIncrDecr(Scriptable scopeChain, String id, int incrDecrMask) {
		 Scriptable target;
		 Object value;
		 search: {
			 do {
				 target = scopeChain;
				 do {
					 value = target.get(id, scopeChain);
					 if (value != Scriptable.NOT_FOUND) {
						 break search;
					 }
					 target = target.getPrototype();
				 }
				 while (target != null);
				 scopeChain = scopeChain.getParentScope();
			 }
			 while (scopeChain != null);
			 throw notFoundError(scopeChain, id);
		 }
		 return doScriptableIncrDecr(target, id, scopeChain, value, incrDecrMask);
	 }
	 public static Object propIncrDecr(Object obj, String id, Context cx, int incrDecrMask) {
		 Scriptable start = toObjectOrNull(cx, obj);
		 if (start == null) {
			 throw undefReadError(obj, id);
		 }
		 Scriptable target = start;
		 Object value;
		 search: {
			 do {
				 value = target.get(id, start);
				 if (value != Scriptable.NOT_FOUND) {
					 break search;
				 }
				 target = target.getPrototype();
			 }
			 while (target != null);
			 start.put(id, start, NaNobj);
			 return NaNobj;
		 }
		 return doScriptableIncrDecr(target, id, start, value, incrDecrMask);
	 }
	 private static Object doScriptableIncrDecr(Scriptable target, String id, Scriptable protoChainStart, Object value, int incrDecrMask) {
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 target.put(id, protoChainStart, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object elemIncrDecr(Object obj, Object index, Context cx, int incrDecrMask) {
		 Object value = getObjectElem(obj, index, cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 setObjectElem(obj, index, result, cx);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object refIncrDecr(Ref ref, Context cx, int incrDecrMask) {
		 Object value = ref.get(cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 ref.set(cx, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 private static Object toPrimitive(Object val) {
		 if (!(val instanceof Scriptable)) {
			 return val;
		 }
		 Scriptable s = (Scriptable)val;
		 Object result = s.getDefaultValue(null);
		 if (result instanceof Scriptable) throw typeError0(""msg.bad.default.value"");
		 return result;
	 }
	 public static boolean eq(Object x, Object y) {
		 if (x == null || x == Undefined.instance) {
			 if (y == null || y == Undefined.instance) {
				 return true;
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return false;
		 }
		 else if (x instanceof Number) {
			 return eqNumber(((Number)x).doubleValue(), y);
		 }
		 else if (x instanceof String) {
			 return eqString((String)x, y);
		 }
		 else if (x instanceof Boolean) {
			 boolean b = ((Boolean)x).booleanValue();
			 if (y instanceof Boolean) {
				 return b == ((Boolean)y).booleanValue();
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return eqNumber(b ? 1.0 : 0.0, y);
		 }
		 else if (x instanceof Scriptable) {
			 if (y instanceof Scriptable) {
				 if (x == y) {
					 return true;
				 }
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (x instanceof Wrapper && y instanceof Wrapper) {
					 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
				 }
				 return false;
			 }
			 else if (y instanceof Boolean) {
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;
				 return eqNumber(d, x);
			 }
			 else if (y instanceof Number) {
				 return eqNumber(((Number)y).doubleValue(), x);
			 }
			 else if (y instanceof String) {
				 return eqString((String)y, x);
			 }
			 return false;
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
	 }
	 static boolean eqNumber(double x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof Number) {
				 return x == ((Number)y).doubleValue();
			 }
			 else if (y instanceof String) {
				 return x == toNumber(y);
			 }
			 else if (y instanceof Boolean) {
				 return x == (((Boolean)y).booleanValue() ? 1.0 : +0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object xval = wrapNumber(x);
					 Object test = ((ScriptableObject)y).equivalentValues(xval);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 private static boolean eqString(String x, Object y) {
		 for (;
		;
		) {
			 if (y == null || y == Undefined.instance) {
				 return false;
			 }
			 else if (y instanceof String) {
				 return x.equals(y);
			 }
			 else if (y instanceof Number) {
				 return toNumber(x) == ((Number)y).doubleValue();
			 }
			 else if (y instanceof Boolean) {
				 return toNumber(x) == (((Boolean)y).booleanValue() ? 1.0 : 0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
				 continue;
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 public static boolean shallowEq(Object x, Object y) {
		 if (x == y) {
			 if (!(x instanceof Number)) {
				 return true;
			 }
			 double d = ((Number)x).doubleValue();
			 return d == d;
		 }
		 if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 if (y instanceof Number) {
				 return ((Number)x).doubleValue() == ((Number)y).doubleValue();
			 }
		 }
		 else if (x instanceof String) {
			 if (y instanceof String) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Boolean) {
			 if (y instanceof Boolean) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Scriptable) {
			 if (x instanceof Wrapper && y instanceof Wrapper) {
				 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
			 }
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
		 return false;
	 }
	 public static boolean instanceOf(Object a, Object b, Context cx) {
		 if (! (b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 if (! (a instanceof Scriptable)) return false;
		 return ((Scriptable)b).hasInstance((Scriptable)a);
	 }
	 protected static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
		 Scriptable proto = lhs.getPrototype();
		 while (proto != null) {
			 if (proto.equals(rhs)) return true;
			 proto = proto.getPrototype();
		 }
		 return false;
	 }
	 public static boolean in(Object a, Object b, Context cx) {
		 if (!(b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 return hasObjectElem((Scriptable)b, a, cx);
	 }
	 public static boolean cmp_LT(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) < 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 < d2;
	 }
	 public static boolean cmp_LE(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) <= 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 <= d2;
	 }
	 public static ScriptableObject getGlobal(Context cx) {
		 final String GLOBAL_CLASS = ""org.mozilla.javascript.tools.shell.Global"";
		 Class globalClass = Kit.classOrNull(GLOBAL_CLASS);
		 if (globalClass != null) {
			 try {
				 Class[] parm = {
				 ScriptRuntime.ContextClass }
				;
				 Constructor globalClassCtor = globalClass.getConstructor(parm);
				 Object[] arg = {
				 cx }
				;
				 return (ScriptableObject) globalClassCtor.newInstance(arg);
			 }
			 catch (Exception e) {
			 }
		 }
		 return new ImporterTopLevel(cx);
	 }
	 public static boolean hasTopCall(Context cx) {
		 return (cx.topCallScope != null);
	 }
	 public static Scriptable getTopCallScope(Context cx) {
		 Scriptable scope = cx.topCallScope;
		 if (scope == null) {
			 throw new IllegalStateException();
		 }
		 return scope;
	 }
	 public static Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (scope == null) throw new IllegalArgumentException();
		 if (cx.topCallScope != null) throw new IllegalStateException();
		 Object result;
		 cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
		 cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
		 ContextFactory f = cx.getFactory();
		 try {
			 result = f.doTopCall(callable, cx, scope, thisObj, args);
		 }
		 finally {
			 cx.topCallScope = null;
			 cx.cachedXMLLib = null;
			 if (cx.currentActivationCall != null) {
				 throw new IllegalStateException();
			 }
		 }
		 return result;
	 }
	 static Scriptable checkDynamicScope(Scriptable possibleDynamicScope, Scriptable staticTopScope) {
		 if (possibleDynamicScope == staticTopScope) {
			 return possibleDynamicScope;
		 }
		 Scriptable proto = possibleDynamicScope;
		 for (;
		;
		) {
			 proto = proto.getPrototype();
			 if (proto == staticTopScope) {
				 return possibleDynamicScope;
			 }
			 if (proto == null) {
				 return staticTopScope;
			 }
		 }
	 }
	 public static void initScript(NativeFunction funObj, Scriptable thisObj, Context cx, Scriptable scope, boolean evalScript) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 int varCount = funObj.getParamAndVarCount();
		 if (varCount != 0) {
			 Scriptable varScope = scope;
			 while (varScope instanceof NativeWith) {
				 varScope = varScope.getParentScope();
			 }
			 for (int i = varCount;
			 i-- != 0;
			) {
				 String name = funObj.getParamOrVarName(i);
				 if (!ScriptableObject.hasProperty(scope, name)) {
					 if (!evalScript) {
						 ScriptableObject.defineProperty( varScope, name, Undefined.instance, ScriptableObject.PERMANENT);
					 }
					 else {
						 varScope.put(name, varScope, Undefined.instance);
					 }
				 }
			 }
		 }
	 }
	 public static Scriptable createFunctionActivation(NativeFunction funObj, Scriptable scope, Object[] args) {
		 return new NativeCall(funObj, scope, args);
	 }
	 public static void enterActivationFunction(Context cx, Scriptable activation) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 NativeCall call = (NativeCall)activation;
		 call.parentActivationCall = cx.currentActivationCall;
		 cx.currentActivationCall = call;
	 }
	 public static void exitActivationFunction(Context cx) {
		 NativeCall call = cx.currentActivationCall;
		 cx.currentActivationCall = call.parentActivationCall;
		 call.parentActivationCall = null;
	 }
	 static NativeCall findFunctionActivation(Context cx, Function f) {
		 NativeCall call = cx.currentActivationCall;
		 while (call != null) {
			 if (call.function == f) return call;
			 call = call.parentActivationCall;
		 }
		 return null;
	 }
	 public static Scriptable newCatchScope(Throwable t, Scriptable lastCatchScope, String exceptionName, Context cx, Scriptable scope) {
		 Object obj;
		 boolean cacheObj;
		 getObj: if (t instanceof JavaScriptException) {
			 cacheObj = false;
			 obj = ((JavaScriptException)t).getValue();
		 }
		 else {
			 cacheObj = true;
			 if (lastCatchScope != null) {
				 NativeObject last = (NativeObject)lastCatchScope;
				 obj = last.getAssociatedValue(t);
				 if (obj == null) Kit.codeBug();
				 break getObj;
			 }
			 RhinoException re;
			 String errorName;
			 String errorMsg;
			 Throwable javaException = null;
			 if (t instanceof EcmaError) {
				 EcmaError ee = (EcmaError)t;
				 re = ee;
				 errorName = ee.getName();
				 errorMsg = ee.getErrorMessage();
			 }
			 else if (t instanceof WrappedException) {
				 WrappedException we = (WrappedException)t;
				 re = we;
				 javaException = we.getWrappedException();
				 errorName = ""JavaException"";
				 errorMsg = javaException.getClass().getName() +"": ""+javaException.getMessage();
			 }
			 else if (t instanceof EvaluatorException) {
				 EvaluatorException ee = (EvaluatorException)t;
				 re = ee;
				 errorName = ""InternalError"";
				 errorMsg = ee.getMessage();
			 }
			 else {
				 throw Kit.codeBug();
			 }
			 String sourceUri = re.sourceName();
			 if (sourceUri == null) {
				 sourceUri = """";
			 }
			 int line = re.lineNumber();
			 Object args[];
			 if (line > 0) {
				 args = new Object[] {
				 errorMsg, sourceUri, new Integer(line) }
				;
			 }
			 else {
				 args = new Object[] {
				 errorMsg, sourceUri }
				;
			 }
			 Scriptable errorObject = cx.newObject(scope, errorName, args);
			 ScriptableObject.putProperty(errorObject, ""name"", errorName);
			 if (javaException != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException, null);
				 ScriptableObject.defineProperty( errorObject, ""javaException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 if (re != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, re, null);
				 ScriptableObject.defineProperty( errorObject, ""rhinoException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 obj = errorObject;
		 }
		 NativeObject catchScopeObject = new NativeObject();
		 catchScopeObject.defineProperty( exceptionName, obj, ScriptableObject.PERMANENT);
		 if (cacheObj) {
			 catchScopeObject.associateValue(t, obj);
		 }
		 return catchScopeObject;
	 }
	 public static Scriptable enterWith(Object obj, Context cx, Scriptable scope) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw typeError1(""msg.undef.with"", toString(obj));
		 }
		 if (sobj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)sobj;
			 return xmlObject.enterWith(scope);
		 }
		 return new NativeWith(scope, sobj);
	 }
	 public static Scriptable leaveWith(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static Scriptable enterDotQuery(Object value, Scriptable scope) {
		 if (!(value instanceof XMLObject)) {
			 throw notXmlError(value);
		 }
		 XMLObject object = (XMLObject)value;
		 return object.enterDotQuery(scope);
	 }
	 public static Object updateDotQuery(boolean value, Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.updateDotQuery(value);
	 }
	 public static Scriptable leaveDotQuery(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static void setFunctionProtoAndParent(BaseFunction fn, Scriptable scope) {
		 fn.setParentScope(scope);
		 fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
	 }
	 public static void setObjectProtoAndParent(ScriptableObject object, Scriptable scope) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 object.setParentScope(scope);
		 Scriptable proto = ScriptableObject.getClassPrototype(scope, object.getClassName());
		 object.setPrototype(proto);
	 }
	 public static void initFunction(Context cx, Scriptable scope, NativeFunction function, int type, boolean fromEvalCode) {
		 if (type == FunctionNode.FUNCTION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 if (!fromEvalCode) {
					 ScriptableObject.defineProperty (scope, name, function, ScriptableObject.PERMANENT);
				 }
				 else {
					 scope.put(name, scope, function);
				 }
			 }
		 }
		 else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
			 String name = function.getFunctionName();
			 if (name != null && name.length() != 0) {
				 while (scope instanceof NativeWith) {
					 scope = scope.getParentScope();
				 }
				 scope.put(name, scope, function);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
	 }
	 public static Scriptable newArrayLiteral(Object[] objects, int[] skipIndexces, Context cx, Scriptable scope) {
		 int count = objects.length;
		 int skipCount = 0;
		 if (skipIndexces != null) {
			 skipCount = skipIndexces.length;
		 }
		 int length = count + skipCount;
		 Integer lengthObj = new Integer(length);
		 Scriptable arrayObj;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 arrayObj = cx.newObject(scope, ""Array"", ScriptRuntime.emptyArgs);
			 ScriptableObject.putProperty(arrayObj, ""length"", lengthObj);
		 }
		 else {
			 arrayObj = cx.newObject(scope, ""Array"", new Object[] {
			 lengthObj }
			);
		 }
		 int skip = 0;
		 for (int i = 0, j = 0;
		 i != length;
		 ++i) {
			 if (skip != skipCount && skipIndexces[skip] == i) {
				 ++skip;
				 continue;
			 }
			 ScriptableObject.putProperty(arrayObj, i, objects[j]);
			 ++j;
		 }
		 return arrayObj;
	 }
	 public static Scriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, Context cx, Scriptable scope) {
		 Scriptable object = cx.newObject(scope);
		 for (int i = 0, end = propertyIds.length;
		 i != end;
		 ++i) {
			 Object id = propertyIds[i];
			 Object value = propertyValues[i];
			 if (id instanceof String) {
				 ScriptableObject.putProperty(object, (String)id, value);
			 }
			 else {
				 int index = ((Integer)id).intValue();
				 ScriptableObject.putProperty(object, index, value);
			 }
		 }
		 return object;
	 }
	 public static boolean isArrayObject(Object obj) {
		 return obj instanceof NativeArray || obj instanceof Arguments;
	 }
	 public static Object[] getArrayElements(Scriptable object) {
		 Context cx = Context.getContext();
		 long longLen = NativeArray.getLengthProperty(cx, object);
		 if (longLen > Integer.MAX_VALUE) {
			 throw new IllegalArgumentException();
		 }
		 int len = (int) longLen;
		 if (len == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 else {
			 Object[] result = new Object[len];
			 for (int i=0;
			 i < len;
			 i++) {
				 Object elem = ScriptableObject.getProperty(object, i);
				 result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance : elem;
			 }
			 return result;
		 }
	 }
	 static void checkDeprecated(Context cx, String name) {
		 int version = cx.getLanguageVersion();
		 if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
			 String msg = getMessage1(""msg.deprec.ctor"", name);
			 if (version == Context.VERSION_DEFAULT) Context.reportWarning(msg);
			 else throw Context.reportRuntimeError(msg);
		 }
	 }
	 public static String getMessage0(String messageId) {
		 return getMessage(messageId, null);
	 }
	 public static String getMessage1(String messageId, Object arg1) {
		 Object[] arguments = {
		arg1}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage2( String messageId, Object arg1, Object arg2) {
		 Object[] arguments = {
		arg1, arg2}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage3( String messageId, Object arg1, Object arg2, Object arg3) {
		 Object[] arguments = {
		arg1, arg2, arg3}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage4( String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 Object[] arguments = {
		arg1, arg2, arg3, arg4}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage(String messageId, Object[] arguments) {
		 final String defaultResource = ""org.mozilla.javascript.resources.Messages"";
		 Context cx = Context.getCurrentContext();
		 Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();
		 ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);
		 String formatString;
		 try {
			 formatString = rb.getString(messageId);
		 }
		 catch (java.util.MissingResourceException mre) {
			 throw new RuntimeException (""no message resource found for message property ""+ messageId);
		 }
		 MessageFormat formatter = new MessageFormat(formatString);
		 return formatter.format(arguments);
	 }
	 public static EcmaError constructError(String error, String message) {
		 int[] linep = new int[1];
		 String filename = Context.getSourcePositionFromStack(linep);
		 return constructError(error, message, filename, linep[0], null, 0);
	 }
	 public static EcmaError constructError(String error, String message, String sourceName, int lineNumber, String lineSource, int columnNumber) {
		 return new EcmaError(error, message, sourceName, lineNumber, lineSource, columnNumber);
	 }
	 public static EcmaError typeError(String message) {
		 return constructError(""TypeError"", message);
	 }
	 public static EcmaError typeError0(String messageId) {
		 String msg = getMessage0(messageId);
		 return typeError(msg);
	 }
	 public static EcmaError typeError1(String messageId, String arg1) {
		 String msg = getMessage1(messageId, arg1);
		 return typeError(msg);
	 }
	 public static EcmaError typeError2(String messageId, String arg1, String arg2) {
		 String msg = getMessage2(messageId, arg1, arg2);
		 return typeError(msg);
	 }
	 public static EcmaError typeError3(String messageId, String arg1, String arg2, String arg3) {
		 String msg = getMessage3(messageId, arg1, arg2, arg3);
		 return typeError(msg);
	 }
	 public static RuntimeException undefReadError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.prop.read"", toString(object), idStr);
	 }
	 public static RuntimeException undefCallError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.method.call"", toString(object), idStr);
	 }
	 public static RuntimeException undefWriteError(Object object, Object id, Object value) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 String valueStr = (value instanceof Scriptable) ? value.toString() : toString(value);
		 return typeError3(""msg.undef.prop.write"", toString(object), idStr, valueStr);
	 }
	 public static RuntimeException notFoundError(Scriptable object, String property) {
		 String msg = getMessage1(""msg.is.not.defined"", property);
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static RuntimeException notFunctionError(Object value) {
		 return notFunctionError(value, value);
	 }
	 public static RuntimeException notFunctionError(Object value, Object messageHelper) {
		 String msg = (messageHelper == null) ? ""null"" : messageHelper.toString();
		 if (value == Scriptable.NOT_FOUND) {
			 return typeError1(""msg.function.not.found"", msg);
		 }
		 return typeError2(""msg.isnt.function"", msg, value == null ? ""null"" : value.getClass().getName());
	 }
	 private static RuntimeException notXmlError(Object value) {
		 throw typeError1(""msg.isnt.xml.object"", ScriptRuntime.toString(value));
	 }
	 private static void warnAboutNonJSObject(Object nonJSObject) {
		 String message =""RHINO USAGE WARNING: Missed Context.javaToJS() conversion:\n""+""Rhino runtime detected object ""+nonJSObject+"" of class ""+nonJSObject.getClass().getName()+"" where it expected String, Number, Boolean or Scriptable instance. Please check your code for missig Context.javaToJS() call."";
		 Context.reportWarning(message);
		 System.err.println(message);
	 }
	 public static RegExpProxy getRegExpProxy(Context cx) {
		 return cx.getRegExpProxy();
	 }
	 public static void setRegExpProxy(Context cx, RegExpProxy proxy) {
		 if (proxy == null) throw new IllegalArgumentException();
		 cx.regExpProxy = proxy;
	 }
	 public static RegExpProxy checkRegExpProxy(Context cx) {
		 RegExpProxy result = getRegExpProxy(cx);
		 if (result == null) {
			 throw Context.reportRuntimeError0(""msg.no.regexp"");
		 }
		 return result;
	 }
	 private static XMLLib currentXMLLib(Context cx) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 XMLLib xmlLib = cx.cachedXMLLib;
		 if (xmlLib == null) {
			 xmlLib = XMLLib.extractFromScope(cx.topCallScope);
			 if (xmlLib == null) throw new IllegalStateException();
			 cx.cachedXMLLib = xmlLib;
		 }
		 return xmlLib;
	 }
	 public static String escapeAttributeValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeAttributeValue(value);
	 }
	 public static String escapeTextValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeTextValue(value);
	 }
	 public static Ref memberRef(Object obj, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, elem, memberTypeFlags);
	 }
	 public static Ref memberRef(Object obj, Object namespace, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);
	 }
	 public static Ref nameRef(Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, name, scope, memberTypeFlags);
	 }
	 public static Ref nameRef(Object namespace, Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);
	 }
	 private static void storeIndexResult(Context cx, int index) {
		 cx.scratchIndex = index;
	 }
	 static int lastIndexResult(Context cx) {
		 return cx.scratchIndex;
	 }
	 public static void storeUint32Result(Context cx, long value) {
		 if ((value >>> 32) != 0) throw new IllegalArgumentException();
		 cx.scratchUint32 = value;
	 }
	 public static long lastUint32Result(Context cx) {
		 long value = cx.scratchUint32;
		 if ((value >>> 32) != 0) throw new IllegalStateException();
		 return value;
	 }
	 private static void storeScriptable(Context cx, Scriptable value) {
		 if (cx.scratchScriptable != null) throw new IllegalStateException();
		 cx.scratchScriptable = value;
	 }
	 public static Scriptable lastStoredScriptable(Context cx) {
		 Scriptable result = cx.scratchScriptable;
		 cx.scratchScriptable = null;
		 return result;
	 }
	 static String makeUrlForGeneratedScript (boolean isEval, String masterScriptUrl, int masterScriptLine) {
		 if (isEval) {
			 return masterScriptUrl+'#'+masterScriptLine+""(eval)"";
		 }
		 else {
			 return masterScriptUrl+'#'+masterScriptLine+""(Function)"";
		 }
	 }
	 static boolean isGeneratedScript(String sourceUrl) {
		 return sourceUrl.indexOf(""(eval)"") >= 0 || sourceUrl.indexOf(""(Function)"") >= 0;
	 }
	 private static RuntimeException errorWithClassName(String msg, Object val) {
		 return Context.reportRuntimeError1(msg, val.getClass().getName());
	 }
	 public static final Object[] emptyArgs = new Object[0];
	 public static final String[] emptyStrings = new String[0];
}",1,0,0,0
"public abstract class JobStoreSupport implements JobStore, Constants {
	 protected static final String LOCK_TRIGGER_ACCESS = ""TRIGGER_ACCESS"";
	 protected static final String LOCK_JOB_ACCESS = ""JOB_ACCESS"";
	 protected static final String LOCK_CALENDAR_ACCESS = ""CALENDAR_ACCESS"";
	 protected static final String LOCK_STATE_ACCESS = ""STATE_ACCESS"";
	 protected static final String LOCK_MISFIRE_ACCESS = ""MISFIRE_ACCESS"";
	 protected String dsName;
	 protected String tablePrefix = DEFAULT_TABLE_PREFIX;
	 protected boolean useProperties = false;
	 protected String instanceId;
	 protected String instanceName;
	 protected String delegateClassName;
	 protected Class delegateClass = StdJDBCDelegate.class;
	 protected HashMap calendarCache = new HashMap();
	 private DriverDelegate delegate;
	 private long misfireThreshold = 60000L;
	 private boolean dontSetAutoCommitFalse = false;
	 private boolean isClustered = false;
	 private boolean useDBLocks = false;
	 private boolean lockOnInsert = true;
	 private Semaphore lockHandler = null;
	 private String selectWithLockSQL = null;
	 private long clusterCheckinInterval = 7500L;
	 private ClusterManager clusterManagementThread = null;
	 private MisfireHandler misfireHandler = null;
	 private ClassLoadHelper classLoadHelper;
	 private SchedulerSignaler schedSignaler;
	 protected int maxToRecoverAtATime = 20;
	 private boolean setTxIsolationLevelSequential = false;
	 private boolean acquireTriggersWithinLock = false;
	 private long dbRetryInterval = 10000;
	 private boolean makeThreadsDaemons = false;
	 private boolean threadsInheritInitializersClassLoadContext = false;
	 private ClassLoader initializersLoader = null;
	 private boolean doubleCheckLockMisfireHandler = true;
	 private final Logger log = LoggerFactory.getLogger(getClass());
	 public void setDataSource(String dsName) {
		 this.dsName = dsName;
	 }
	 public String getDataSource() {
		 return dsName;
	 }
	 public void setTablePrefix(String prefix) {
		 if (prefix == null) {
			 prefix = """";
		 }
		 this.tablePrefix = prefix;
	 }
	 public String getTablePrefix() {
		 return tablePrefix;
	 }
	 public void setUseProperties(String useProp) {
		 if (useProp == null) {
			 useProp = ""false"";
		 }
		 this.useProperties = Boolean.valueOf(useProp).booleanValue();
	 }
	 public boolean canUseProperties() {
		 return useProperties;
	 }
	 public void setInstanceId(String instanceId) {
		 this.instanceId = instanceId;
	 }
	 public String getInstanceId() {
		 return instanceId;
	 }
	 public void setInstanceName(String instanceName) {
		 this.instanceName = instanceName;
	 }
	 public String getInstanceName() {
		 return instanceName;
	 }
	 public long getEstimatedTimeToReleaseAndAcquireTrigger() {
		 return 70;
	 }
	 public void setIsClustered(boolean isClustered) {
		 this.isClustered = isClustered;
	 }
	 public boolean isClustered() {
		 return isClustered;
	 }
	 public long getClusterCheckinInterval() {
		 return clusterCheckinInterval;
	 }
	 public void setClusterCheckinInterval(long l) {
		 clusterCheckinInterval = l;
	 }
	 public int getMaxMisfiresToHandleAtATime() {
		 return maxToRecoverAtATime;
	 }
	 public void setMaxMisfiresToHandleAtATime(int maxToRecoverAtATime) {
		 this.maxToRecoverAtATime = maxToRecoverAtATime;
	 }
	 public long getDbRetryInterval() {
		 return dbRetryInterval;
	 }
	 public void setDbRetryInterval(long dbRetryInterval) {
		 this.dbRetryInterval = dbRetryInterval;
	 }
	 public void setUseDBLocks(boolean useDBLocks) {
		 this.useDBLocks = useDBLocks;
	 }
	 public boolean getUseDBLocks() {
		 return useDBLocks;
	 }
	 public boolean isLockOnInsert() {
		 return lockOnInsert;
	 }
	 public void setLockOnInsert(boolean lockOnInsert) {
		 this.lockOnInsert = lockOnInsert;
	 }
	 public long getMisfireThreshold() {
		 return misfireThreshold;
	 }
	 public void setMisfireThreshold(long misfireThreshold) {
		 if (misfireThreshold < 1) {
			 throw new IllegalArgumentException( ""Misfirethreshold must be larger than 0"");
		 }
		 this.misfireThreshold = misfireThreshold;
	 }
	 public boolean isDontSetAutoCommitFalse() {
		 return dontSetAutoCommitFalse;
	 }
	 public void setDontSetAutoCommitFalse(boolean b) {
		 dontSetAutoCommitFalse = b;
	 }
	 public boolean isTxIsolationLevelSerializable() {
		 return setTxIsolationLevelSequential;
	 }
	 public void setTxIsolationLevelSerializable(boolean b) {
		 setTxIsolationLevelSequential = b;
	 }
	 public boolean isAcquireTriggersWithinLock() {
		return acquireTriggersWithinLock;
	}
	public void setAcquireTriggersWithinLock(boolean acquireTriggersWithinLock) {
		this.acquireTriggersWithinLock = acquireTriggersWithinLock;
	}
	 public void setDriverDelegateClass(String delegateClassName) throws InvalidConfigurationException {
		 this.delegateClassName = delegateClassName;
	 }
	 public String getDriverDelegateClass() {
		 return delegateClassName;
	 }
	 public String getSelectWithLockSQL() {
		 return selectWithLockSQL;
	 }
	 public void setSelectWithLockSQL(String string) {
		 selectWithLockSQL = string;
	 }
	 protected ClassLoadHelper getClassLoadHelper() {
		 return classLoadHelper;
	 }
	 public boolean getMakeThreadsDaemons() {
		 return makeThreadsDaemons;
	 }
	 public void setMakeThreadsDaemons(boolean makeThreadsDaemons) {
		 this.makeThreadsDaemons = makeThreadsDaemons;
	 }
	 public boolean isThreadsInheritInitializersClassLoadContext() {
		return threadsInheritInitializersClassLoadContext;
	}
	public void setThreadsInheritInitializersClassLoadContext(boolean threadsInheritInitializersClassLoadContext) {
		this.threadsInheritInitializersClassLoadContext = threadsInheritInitializersClassLoadContext;
	}
	 public boolean getDoubleCheckLockMisfireHandler() {
		 return doubleCheckLockMisfireHandler;
	 }
	 public void setDoubleCheckLockMisfireHandler( boolean doubleCheckLockMisfireHandler) {
		 this.doubleCheckLockMisfireHandler = doubleCheckLockMisfireHandler;
	 }
	 protected Logger getLog() {
		 return log;
	 }
	 public void initialize(ClassLoadHelper loadHelper, SchedulerSignaler signaler) throws SchedulerConfigException {
		 if (dsName == null) {
			 throw new SchedulerConfigException(""DataSource name not set."");
		 }
		 classLoadHelper = loadHelper;
		 if(isThreadsInheritInitializersClassLoadContext()) {
			 log.info(""JDBCJobStore threads will inherit ContextClassLoader of thread: "" + Thread.currentThread().getName());
			 initializersLoader = Thread.currentThread().getContextClassLoader();
		 }
		 this.schedSignaler = signaler;
		 if (getLockHandler() == null) {
			 if (isClustered()) {
				 setUseDBLocks(true);
			 }
			 if (getUseDBLocks()) {
				 getLog().info( ""Using db table-based data access locking (synchronization)."");
				 setLockHandler( new StdRowLockSemaphore(getTablePrefix(), getSelectWithLockSQL()));
			 }
			 else {
				 getLog().info( ""Using thread monitor-based data access locking (synchronization)."");
				 setLockHandler(new SimpleSemaphore());
			 }
		 }
		 if (!isClustered()) {
			 try {
				 cleanVolatileTriggerAndJobs();
			 }
			 catch (SchedulerException se) {
				 throw new SchedulerConfigException( ""Failure occured during job recovery."", se);
			 }
		 }
	 }
	 public void schedulerStarted() throws SchedulerException {
		 if (isClustered()) {
			 clusterManagementThread = new ClusterManager();
			 if(initializersLoader != null) clusterManagementThread.setContextClassLoader(initializersLoader);
			 clusterManagementThread.initialize();
		 }
		 else {
			 try {
				 recoverJobs();
			 }
			 catch (SchedulerException se) {
				 throw new SchedulerConfigException( ""Failure occured during job recovery."", se);
			 }
		 }
		 misfireHandler = new MisfireHandler();
		 if(initializersLoader != null) misfireHandler.setContextClassLoader(initializersLoader);
		 misfireHandler.initialize();
	 }
	 public void shutdown() {
		 if (clusterManagementThread != null) {
			 clusterManagementThread.shutdown();
		 }
		 if (misfireHandler != null) {
			 misfireHandler.shutdown();
		 }
		 try {
			 DBConnectionManager.getInstance().shutdown(getDataSource());
		 }
		 catch (SQLException sqle) {
			 getLog().warn(""Database connection shutdown unsuccessful."", sqle);
		 }
	 }
	 public boolean supportsPersistence() {
		 return true;
	 }
	 protected abstract Connection getNonManagedTXConnection() throws JobPersistenceException;
	 protected Connection getAttributeRestoringConnection(Connection conn) {
		 return (Connection)Proxy.newProxyInstance( Thread.currentThread().getContextClassLoader(), new Class[] {
		 Connection.class }
		, new AttributeRestoringConnectionInvocationHandler(conn));
	 }
	 protected Connection getConnection() throws JobPersistenceException {
		 Connection conn = null;
		 try {
			 conn = DBConnectionManager.getInstance().getConnection( getDataSource());
		 }
		 catch (SQLException sqle) {
			 throw new JobPersistenceException( ""Failed to obtain DB connection from data source '"" + getDataSource() + ""': "" + sqle.toString(), sqle);
		 }
		 catch (Throwable e) {
			 throw new JobPersistenceException( ""Failed to obtain DB connection from data source '"" + getDataSource() + ""': "" + e.toString(), e, JobPersistenceException.ERR_PERSISTENCE_CRITICAL_FAILURE);
		 }
		 if (conn == null) {
			 throw new JobPersistenceException( ""Could not get connection from DataSource '"" + getDataSource() + ""'"");
		 }
		 conn = getAttributeRestoringConnection(conn);
		 try {
			 if (!isDontSetAutoCommitFalse()) {
				 conn.setAutoCommit(false);
			 }
			 if(isTxIsolationLevelSerializable()) {
				 conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
			 }
		 }
		 catch (SQLException sqle) {
			 getLog().warn(""Failed to override connection auto commit/transaction isolation."", sqle);
		 }
		 catch (Throwable e) {
			 try {
				 conn.close();
			 }
			 catch(Throwable tt) {
			}
			 throw new JobPersistenceException( ""Failure setting up connection."", e);
		 }
		 return conn;
	 }
	 protected void releaseLock(Connection conn, String lockName, boolean doIt) {
		 if (doIt && conn != null) {
			 try {
				 getLockHandler().releaseLock(conn, lockName);
			 }
			 catch (LockException le) {
				 getLog().error(""Error returning lock: "" + le.getMessage(), le);
			 }
		 }
	 }
	 protected void cleanVolatileTriggerAndJobs() throws JobPersistenceException {
		 executeInNonManagedTXLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 cleanVolatileTriggerAndJobs(conn);
			 }
		 }
		);
	 }
	 protected void cleanVolatileTriggerAndJobs(Connection conn) throws JobPersistenceException {
		 try {
			 Key[] volatileTriggers = getDelegate().selectVolatileTriggers(conn);
			 Key[] volatileJobs = getDelegate().selectVolatileJobs(conn);
			 for (int i = 0;
			 i < volatileTriggers.length;
			 i++) {
				 removeTrigger(conn, null, volatileTriggers[i].getName(), volatileTriggers[i].getGroup());
			 }
			 getLog().info( ""Removed "" + volatileTriggers.length + "" Volatile Trigger(s)."");
			 for (int i = 0;
			 i < volatileJobs.length;
			 i++) {
				 removeJob(conn, null, volatileJobs[i].getName(), volatileJobs[i].getGroup(), true);
			 }
			 getLog().info( ""Removed "" + volatileJobs.length + "" Volatile Job(s)."");
			 getDelegate().deleteVolatileFiredTriggers(conn);
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException(""Couldn't clean volatile data: "" + e.getMessage(), e);
		 }
	 }
	 protected void recoverJobs() throws JobPersistenceException {
		 executeInNonManagedTXLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 recoverJobs(conn);
			 }
		 }
		);
	 }
	 protected void recoverJobs(Connection conn) throws JobPersistenceException {
		 try {
			 int rows = getDelegate().updateTriggerStatesFromOtherStates(conn, STATE_WAITING, STATE_ACQUIRED, STATE_BLOCKED);
			 rows += getDelegate().updateTriggerStatesFromOtherStates(conn, STATE_PAUSED, STATE_PAUSED_BLOCKED, STATE_PAUSED_BLOCKED);
			 getLog().info( ""Freed "" + rows + "" triggers from 'acquired' / 'blocked' state."");
			 recoverMisfiredJobs(conn, true);
			 Trigger[] recoveringJobTriggers = getDelegate() .selectTriggersForRecoveringJobs(conn);
			 getLog() .info( ""Recovering "" + recoveringJobTriggers.length + "" jobs that were in-progress at the time of the last shut-down."");
			 for (int i = 0;
			 i < recoveringJobTriggers.length;
			 ++i) {
				 if (jobExists(conn, recoveringJobTriggers[i].getJobName(), recoveringJobTriggers[i].getJobGroup())) {
					 recoveringJobTriggers[i].computeFirstFireTime(null);
					 storeTrigger(conn, null, recoveringJobTriggers[i], null, false, STATE_WAITING, false, true);
				 }
			 }
			 getLog().info(""Recovery complete."");
			 Key[] ct = getDelegate().selectTriggersInState(conn, STATE_COMPLETE);
			 for(int i=0;
			 ct != null && i < ct.length;
			 i++) {
				 removeTrigger(conn, null, ct[i].getName(), ct[i].getGroup());
			 }
			 getLog().info( ""Removed "" + (ct != null ? ct.length : 0) + "" 'complete' triggers."");
			 int n = getDelegate().deleteFiredTriggers(conn);
			 getLog().info(""Removed "" + n + "" stale fired job entries."");
		 }
		 catch (JobPersistenceException e) {
			 throw e;
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException(""Couldn't recover jobs: "" + e.getMessage(), e);
		 }
	 }
	 protected long getMisfireTime() {
		 long misfireTime = System.currentTimeMillis();
		 if (getMisfireThreshold() > 0) {
			 misfireTime -= getMisfireThreshold();
		 }
		 return (misfireTime > 0) ? misfireTime : 0;
	 }
	 protected static class RecoverMisfiredJobsResult {
		 public static final RecoverMisfiredJobsResult NO_OP = new RecoverMisfiredJobsResult(false, 0, Long.MAX_VALUE);
		 private boolean _hasMoreMisfiredTriggers;
		 private int _processedMisfiredTriggerCount;
		 private long _earliestNewTime;
		 public RecoverMisfiredJobsResult( boolean hasMoreMisfiredTriggers, int processedMisfiredTriggerCount, long earliestNewTime) {
			 _hasMoreMisfiredTriggers = hasMoreMisfiredTriggers;
			 _processedMisfiredTriggerCount = processedMisfiredTriggerCount;
			 _earliestNewTime = earliestNewTime;
		 }
		 public boolean hasMoreMisfiredTriggers() {
			 return _hasMoreMisfiredTriggers;
		 }
		 public int getProcessedMisfiredTriggerCount() {
			 return _processedMisfiredTriggerCount;
		 }
		 public long getEarliestNewTime() {
			 return _earliestNewTime;
		 }
	 }
	 protected RecoverMisfiredJobsResult recoverMisfiredJobs( Connection conn, boolean recovering) throws JobPersistenceException, SQLException {
		 int maxMisfiresToHandleAtATime = (recovering) ? -1 : getMaxMisfiresToHandleAtATime();
		 List misfiredTriggers = new ArrayList();
		 long earliestNewTime = Long.MAX_VALUE;
		 boolean hasMoreMisfiredTriggers = getDelegate().selectMisfiredTriggersInStates( conn, STATE_MISFIRED, STATE_WAITING, getMisfireTime(), maxMisfiresToHandleAtATime, misfiredTriggers);
		 if (hasMoreMisfiredTriggers) {
			 getLog().info( ""Handling the first "" + misfiredTriggers.size() + "" triggers that missed their scheduled fire-time. "" + ""More misfired triggers remain to be processed."");
		 }
		 else if (misfiredTriggers.size() > 0) {
			 getLog().info( ""Handling "" + misfiredTriggers.size() + "" trigger(s) that missed their scheduled fire-time."");
		 }
		 else {
			 getLog().debug( ""Found 0 triggers that missed their scheduled fire-time."");
			 return RecoverMisfiredJobsResult.NO_OP;
		 }
		 for (Iterator misfiredTriggerIter = misfiredTriggers.iterator();
		 misfiredTriggerIter.hasNext();
		) {
			 Key triggerKey = (Key) misfiredTriggerIter.next();
			 Trigger trig = retrieveTrigger(conn, triggerKey.getName(), triggerKey.getGroup());
			 if (trig == null) {
				 continue;
			 }
			 doUpdateOfMisfiredTrigger(conn, null, trig, false, STATE_WAITING, recovering);
			 if(trig.getNextFireTime() != null && trig.getNextFireTime().getTime() < earliestNewTime) earliestNewTime = trig.getNextFireTime().getTime();
		 }
		 return new RecoverMisfiredJobsResult( hasMoreMisfiredTriggers, misfiredTriggers.size(), earliestNewTime);
	 }
	 protected boolean updateMisfiredTrigger(Connection conn, SchedulingContext ctxt, String triggerName, String groupName, String newStateIfNotComplete, boolean forceState) throws JobPersistenceException {
		 try {
			 Trigger trig = retrieveTrigger(conn, triggerName, groupName);
			 long misfireTime = System.currentTimeMillis();
			 if (getMisfireThreshold() > 0) {
				 misfireTime -= getMisfireThreshold();
			 }
			 if (trig.getNextFireTime().getTime() > misfireTime) {
				 return false;
			 }
			 doUpdateOfMisfiredTrigger(conn, ctxt, trig, forceState, newStateIfNotComplete, false);
			 schedSignaler.notifySchedulerListenersFinalized(trig);
			 return true;
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException( ""Couldn't update misfired trigger '"" + groupName + ""."" + triggerName + ""': "" + e.getMessage(), e);
		 }
	 }
	 private void doUpdateOfMisfiredTrigger(Connection conn, SchedulingContext ctxt, Trigger trig, boolean forceState, String newStateIfNotComplete, boolean recovering) throws JobPersistenceException {
		 Calendar cal = null;
		 if (trig.getCalendarName() != null) {
			 cal = retrieveCalendar(conn, ctxt, trig.getCalendarName());
		 }
		 schedSignaler.notifyTriggerListenersMisfired(trig);
		 trig.updateAfterMisfire(cal);
		 if (trig.getNextFireTime() == null) {
			 storeTrigger(conn, ctxt, trig, null, true, STATE_COMPLETE, forceState, recovering);
		 }
		 else {
			 storeTrigger(conn, ctxt, trig, null, true, newStateIfNotComplete, forceState, false);
		 }
	 }
	 public void storeJobAndTrigger(final SchedulingContext ctxt, final JobDetail newJob, final Trigger newTrigger) throws ObjectAlreadyExistsException, JobPersistenceException {
		 executeInLock( (isLockOnInsert()) ? LOCK_TRIGGER_ACCESS : null, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 if (newJob.isVolatile() && !newTrigger.isVolatile()) {
					 JobPersistenceException jpe = new JobPersistenceException( ""Cannot associate non-volatile trigger with a volatile job!"");
					 jpe.setErrorCode(SchedulerException.ERR_CLIENT_ERROR);
					 throw jpe;
				 }
				 storeJob(conn, ctxt, newJob, false);
				 storeTrigger(conn, ctxt, newTrigger, newJob, false, Constants.STATE_WAITING, false, false);
			 }
		 }
		);
	 }
	 public void storeJob(final SchedulingContext ctxt, final JobDetail newJob, final boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
		 executeInLock( (isLockOnInsert() || replaceExisting) ? LOCK_TRIGGER_ACCESS : null, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 storeJob(conn, ctxt, newJob, replaceExisting);
			 }
		 }
		);
	 }
	 protected void storeJob(Connection conn, SchedulingContext ctxt, JobDetail newJob, boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
		 if (newJob.isVolatile() && isClustered()) {
			 getLog().info( ""note: volatile jobs are effectively non-volatile in a clustered environment."");
		 }
		 boolean existingJob = jobExists(conn, newJob.getName(), newJob .getGroup());
		 try {
			 if (existingJob) {
				 if (!replaceExisting) {
					 throw new ObjectAlreadyExistsException(newJob);
				 }
				 getDelegate().updateJobDetail(conn, newJob);
			 }
			 else {
				 getDelegate().insertJobDetail(conn, newJob);
			 }
		 }
		 catch (IOException e) {
			 throw new JobPersistenceException(""Couldn't store job: "" + e.getMessage(), e);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't store job: "" + e.getMessage(), e);
		 }
	 }
	 protected boolean jobExists(Connection conn, String jobName, String groupName) throws JobPersistenceException {
		 try {
			 return getDelegate().jobExists(conn, jobName, groupName);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't determine job existence ("" + groupName + ""."" + jobName + ""): "" + e.getMessage(), e);
		 }
	 }
	 public void storeTrigger(final SchedulingContext ctxt, final Trigger newTrigger, final boolean replaceExisting) throws ObjectAlreadyExistsException, JobPersistenceException {
		 executeInLock( (isLockOnInsert() || replaceExisting) ? LOCK_TRIGGER_ACCESS : null, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 storeTrigger(conn, ctxt, newTrigger, null, replaceExisting, STATE_WAITING, false, false);
			 }
		 }
		);
	 }
	 protected void storeTrigger(Connection conn, SchedulingContext ctxt, Trigger newTrigger, JobDetail job, boolean replaceExisting, String state, boolean forceState, boolean recovering) throws ObjectAlreadyExistsException, JobPersistenceException {
		 if (newTrigger.isVolatile() && isClustered()) {
			 getLog().info( ""note: volatile triggers are effectively non-volatile in a clustered environment."");
		 }
		 boolean existingTrigger = triggerExists(conn, newTrigger.getName(), newTrigger.getGroup());
		 if ((existingTrigger) && (!replaceExisting)) {
			 throw new ObjectAlreadyExistsException(newTrigger);
		 }
		 try {
			 boolean shouldBepaused = false;
			 if (!forceState) {
				 shouldBepaused = getDelegate().isTriggerGroupPaused( conn, newTrigger.getGroup());
				 if(!shouldBepaused) {
					 shouldBepaused = getDelegate().isTriggerGroupPaused(conn, ALL_GROUPS_PAUSED);
					 if (shouldBepaused) {
						 getDelegate().insertPausedTriggerGroup(conn, newTrigger.getGroup());
					 }
				 }
				 if (shouldBepaused && (state.equals(STATE_WAITING) || state.equals(STATE_ACQUIRED))) {
					 state = STATE_PAUSED;
				 }
			 }
			 if(job == null) {
				 job = getDelegate().selectJobDetail(conn, newTrigger.getJobName(), newTrigger.getJobGroup(), getClassLoadHelper());
			 }
			 if (job == null) {
				 throw new JobPersistenceException(""The job ("" + newTrigger.getFullJobName() + "") referenced by the trigger does not exist."");
			 }
			 if (job.isVolatile() && !newTrigger.isVolatile()) {
				 throw new JobPersistenceException( ""It does not make sense to "" + ""associate a non-volatile Trigger with a volatile Job!"");
			 }
			 if (job.isStateful() && !recovering) {
				 state = checkBlockedState(conn, ctxt, job.getName(), job.getGroup(), state);
			 }
			 if (existingTrigger) {
				 if (newTrigger instanceof SimpleTrigger && ((SimpleTrigger)newTrigger).hasAdditionalProperties() == false ) {
					 getDelegate().updateSimpleTrigger(conn, (SimpleTrigger) newTrigger);
				 }
				 else if (newTrigger instanceof CronTrigger && ((CronTrigger)newTrigger).hasAdditionalProperties() == false ) {
					 getDelegate().updateCronTrigger(conn, (CronTrigger) newTrigger);
				 }
				 else {
					 getDelegate().updateBlobTrigger(conn, newTrigger);
				 }
				 getDelegate().updateTrigger(conn, newTrigger, state, job);
			 }
			 else {
				 getDelegate().insertTrigger(conn, newTrigger, state, job);
				 if (newTrigger instanceof SimpleTrigger && ((SimpleTrigger)newTrigger).hasAdditionalProperties() == false ) {
					 getDelegate().insertSimpleTrigger(conn, (SimpleTrigger) newTrigger);
				 }
				 else if (newTrigger instanceof CronTrigger && ((CronTrigger)newTrigger).hasAdditionalProperties() == false ) {
					 getDelegate().insertCronTrigger(conn, (CronTrigger) newTrigger);
				 }
				 else {
					 getDelegate().insertBlobTrigger(conn, newTrigger);
				 }
			 }
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException(""Couldn't store trigger '"" + newTrigger.getName() + ""' for '"" + newTrigger.getJobName() + ""' job:"" + e.getMessage(), e);
		 }
	 }
	 protected boolean triggerExists(Connection conn, String triggerName, String groupName) throws JobPersistenceException {
		 try {
			 return getDelegate().triggerExists(conn, triggerName, groupName);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't determine trigger existence ("" + groupName + ""."" + triggerName + ""): "" + e.getMessage(), e);
		 }
	 }
	 public boolean removeJob(final SchedulingContext ctxt, final String jobName, final String groupName) throws JobPersistenceException {
		 return ((Boolean)executeInLock( LOCK_TRIGGER_ACCESS, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return removeJob(conn, ctxt, jobName, groupName, true) ? Boolean.TRUE : Boolean.FALSE;
			 }
		 }
		)).booleanValue();
	 }
	 protected boolean removeJob(Connection conn, SchedulingContext ctxt, String jobName, String groupName, boolean activeDeleteSafe) throws JobPersistenceException {
		 try {
			 Key[] jobTriggers = getDelegate().selectTriggerNamesForJob(conn, jobName, groupName);
			 for (int i = 0;
			 i < jobTriggers.length;
			 ++i) {
				 deleteTriggerAndChildren( conn, jobTriggers[i].getName(), jobTriggers[i].getGroup());
			 }
			 return deleteJobAndChildren(conn, ctxt, jobName, groupName);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't remove job: "" + e.getMessage(), e);
		 }
	 }
	 private boolean deleteJobAndChildren(Connection conn, SchedulingContext ctxt, String jobName, String groupName) throws NoSuchDelegateException, SQLException {
		 getDelegate().deleteJobListeners(conn, jobName, groupName);
		 return (getDelegate().deleteJobDetail(conn, jobName, groupName) > 0);
	 }
	 private boolean deleteTriggerAndChildren( Connection conn, String triggerName, String triggerGroupName) throws SQLException, NoSuchDelegateException {
		 DriverDelegate delegate = getDelegate();
		 if ((delegate.deleteSimpleTrigger(conn, triggerName, triggerGroupName) == 0) && (delegate.deleteCronTrigger(conn, triggerName, triggerGroupName) == 0)) {
			 delegate.deleteBlobTrigger(conn, triggerName, triggerGroupName);
		 }
		 delegate.deleteTriggerListeners(conn, triggerName, triggerGroupName);
		 return (delegate.deleteTrigger(conn, triggerName, triggerGroupName) > 0);
	 }
	 public JobDetail retrieveJob(final SchedulingContext ctxt, final String jobName, final String groupName) throws JobPersistenceException {
		 return (JobDetail)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return retrieveJob(conn, ctxt, jobName, groupName);
			 }
		 }
		);
	 }
	 protected JobDetail retrieveJob(Connection conn, SchedulingContext ctxt, String jobName, String groupName) throws JobPersistenceException {
		 try {
			 JobDetail job = getDelegate().selectJobDetail(conn, jobName, groupName, getClassLoadHelper());
			 if (job != null) {
				 String[] listeners = getDelegate().selectJobListeners(conn, jobName, groupName);
				 for (int i = 0;
				 i < listeners.length;
				 ++i) {
					 job.addJobListener(listeners[i]);
				 }
			 }
			 return job;
		 }
		 catch (ClassNotFoundException e) {
			 throw new JobPersistenceException( ""Couldn't retrieve job because a required class was not found: "" + e.getMessage(), e, SchedulerException.ERR_PERSISTENCE_JOB_DOES_NOT_EXIST);
		 }
		 catch (IOException e) {
			 throw new JobPersistenceException( ""Couldn't retrieve job because the BLOB couldn't be deserialized: "" + e.getMessage(), e, SchedulerException.ERR_PERSISTENCE_JOB_DOES_NOT_EXIST);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't retrieve job: "" + e.getMessage(), e);
		 }
	 }
	 public boolean removeTrigger(final SchedulingContext ctxt, final String triggerName, final String groupName) throws JobPersistenceException {
		 return ((Boolean)executeInLock( LOCK_TRIGGER_ACCESS, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return removeTrigger(conn, ctxt, triggerName, groupName) ? Boolean.TRUE : Boolean.FALSE;
			 }
		 }
		)).booleanValue();
	 }
	 protected boolean removeTrigger(Connection conn, SchedulingContext ctxt, String triggerName, String groupName) throws JobPersistenceException {
		 boolean removedTrigger = false;
		 try {
			 JobDetail job = getDelegate().selectJobForTrigger(conn, triggerName, groupName, getClassLoadHelper());
			 removedTrigger = deleteTriggerAndChildren(conn, triggerName, groupName);
			 if (null != job && !job.isDurable()) {
				 int numTriggers = getDelegate().selectNumTriggersForJob(conn, job.getName(), job.getGroup());
				 if (numTriggers == 0) {
					 deleteJobAndChildren(conn, ctxt, job.getName(), job.getGroup());
				 }
			 }
		 }
		 catch (ClassNotFoundException e) {
			 throw new JobPersistenceException(""Couldn't remove trigger: "" + e.getMessage(), e);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't remove trigger: "" + e.getMessage(), e);
		 }
		 return removedTrigger;
	 }
	 public boolean replaceTrigger(final SchedulingContext ctxt, final String triggerName, final String groupName, final Trigger newTrigger) throws JobPersistenceException {
		 return ((Boolean)executeInLock( LOCK_TRIGGER_ACCESS, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return replaceTrigger(conn, ctxt, triggerName, groupName, newTrigger) ? Boolean.TRUE : Boolean.FALSE;
			 }
		 }
		)).booleanValue();
	 }
	 protected boolean replaceTrigger(Connection conn, SchedulingContext ctxt, String triggerName, String groupName, Trigger newTrigger) throws JobPersistenceException {
		 try {
			 JobDetail job = getDelegate().selectJobForTrigger(conn, triggerName, groupName, getClassLoadHelper());
			 if (job == null) {
				 return false;
			 }
			 if (!newTrigger.getJobName().equals(job.getName()) || !newTrigger.getJobGroup().equals(job.getGroup())) {
				 throw new JobPersistenceException(""New trigger is not related to the same job as the old trigger."");
			 }
			 boolean removedTrigger = deleteTriggerAndChildren(conn, triggerName, groupName);
			 storeTrigger(conn, ctxt, newTrigger, job, false, STATE_WAITING, false, false);
			 return removedTrigger;
		 }
		 catch (ClassNotFoundException e) {
			 throw new JobPersistenceException(""Couldn't remove trigger: "" + e.getMessage(), e);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't remove trigger: "" + e.getMessage(), e);
		 }
	 }
	 public Trigger retrieveTrigger(final SchedulingContext ctxt, final String triggerName, final String groupName) throws JobPersistenceException {
		 return (Trigger)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return retrieveTrigger(conn, ctxt, triggerName, groupName);
			 }
		 }
		);
	 }
	 protected Trigger retrieveTrigger(Connection conn, SchedulingContext ctxt, String triggerName, String groupName) throws JobPersistenceException {
		 return retrieveTrigger(conn, triggerName, groupName);
	 }
	 protected Trigger retrieveTrigger(Connection conn, String triggerName, String groupName) throws JobPersistenceException {
		 try {
			 Trigger trigger = getDelegate().selectTrigger(conn, triggerName, groupName);
			 if (trigger == null) {
				 return null;
			 }
			 trigger.clearAllTriggerListeners();
			 String[] listeners = getDelegate().selectTriggerListeners(conn, triggerName, groupName);
			 for (int i = 0;
			 i < listeners.length;
			 ++i) {
				 trigger.addTriggerListener(listeners[i]);
			 }
			 return trigger;
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException(""Couldn't retrieve trigger: "" + e.getMessage(), e);
		 }
	 }
	 public int getTriggerState(final SchedulingContext ctxt, final String triggerName, final String groupName) throws JobPersistenceException {
		 return ((Integer)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return new Integer(getTriggerState(conn, ctxt, triggerName, groupName));
			 }
		 }
		)).intValue();
	 }
	 public int getTriggerState(Connection conn, SchedulingContext ctxt, String triggerName, String groupName) throws JobPersistenceException {
		 try {
			 String ts = getDelegate().selectTriggerState(conn, triggerName, groupName);
			 if (ts == null) {
				 return Trigger.STATE_NONE;
			 }
			 if (ts.equals(STATE_DELETED)) {
				 return Trigger.STATE_NONE;
			 }
			 if (ts.equals(STATE_COMPLETE)) {
				 return Trigger.STATE_COMPLETE;
			 }
			 if (ts.equals(STATE_PAUSED)) {
				 return Trigger.STATE_PAUSED;
			 }
			 if (ts.equals(STATE_PAUSED_BLOCKED)) {
				 return Trigger.STATE_PAUSED;
			 }
			 if (ts.equals(STATE_ERROR)) {
				 return Trigger.STATE_ERROR;
			 }
			 if (ts.equals(STATE_BLOCKED)) {
				 return Trigger.STATE_BLOCKED;
			 }
			 return Trigger.STATE_NORMAL;
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't determine state of trigger ("" + groupName + ""."" + triggerName + ""): "" + e.getMessage(), e);
		 }
	 }
	 public void storeCalendar(final SchedulingContext ctxt, final String calName, final Calendar calendar, final boolean replaceExisting, final boolean updateTriggers) throws ObjectAlreadyExistsException, JobPersistenceException {
		 executeInLock( (isLockOnInsert() || updateTriggers) ? LOCK_TRIGGER_ACCESS : null, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 storeCalendar(conn, ctxt, calName, calendar, replaceExisting, updateTriggers);
			 }
		 }
		);
	 }
	 protected void storeCalendar(Connection conn, SchedulingContext ctxt, String calName, Calendar calendar, boolean replaceExisting, boolean updateTriggers) throws ObjectAlreadyExistsException, JobPersistenceException {
		 try {
			 boolean existingCal = calendarExists(conn, calName);
			 if (existingCal && !replaceExisting) {
				 throw new ObjectAlreadyExistsException( ""Calendar with name '"" + calName + ""' already exists."");
			 }
			 if (existingCal) {
				 if (getDelegate().updateCalendar(conn, calName, calendar) < 1) {
					 throw new JobPersistenceException( ""Couldn't store calendar. Update failed."");
				 }
				 if(updateTriggers) {
					 Trigger[] trigs = getDelegate().selectTriggersForCalendar(conn, calName);
					 for(int i=0;
					 i < trigs.length;
					 i++) {
						 trigs[i].updateWithNewCalendar(calendar, getMisfireThreshold());
						 storeTrigger(conn, ctxt, trigs[i], null, true, STATE_WAITING, false, false);
					 }
				 }
			 }
			 else {
				 if (getDelegate().insertCalendar(conn, calName, calendar) < 1) {
					 throw new JobPersistenceException( ""Couldn't store calendar. Insert failed."");
				 }
			 }
			 if (isClustered == false) {
				 calendarCache.put(calName, calendar);
			 }
		 }
		 catch (IOException e) {
			 throw new JobPersistenceException( ""Couldn't store calendar because the BLOB couldn't be serialized: "" + e.getMessage(), e);
		 }
		 catch (ClassNotFoundException e) {
			 throw new JobPersistenceException(""Couldn't store calendar: "" + e.getMessage(), e);
		 }
		catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't store calendar: "" + e.getMessage(), e);
		 }
	 }
	 protected boolean calendarExists(Connection conn, String calName) throws JobPersistenceException {
		 try {
			 return getDelegate().calendarExists(conn, calName);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't determine calendar existence ("" + calName + ""): "" + e.getMessage(), e);
		 }
	 }
	 public boolean removeCalendar(final SchedulingContext ctxt, final String calName) throws JobPersistenceException {
		 return ((Boolean)executeInLock( LOCK_TRIGGER_ACCESS, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return removeCalendar(conn, ctxt, calName) ? Boolean.TRUE : Boolean.FALSE;
			 }
		 }
		)).booleanValue();
	 }
	 protected boolean removeCalendar(Connection conn, SchedulingContext ctxt, String calName) throws JobPersistenceException {
		 try {
			 if (getDelegate().calendarIsReferenced(conn, calName)) {
				 throw new JobPersistenceException( ""Calender cannot be removed if it referenced by a trigger!"");
			 }
			 if (isClustered == false) {
				 calendarCache.remove(calName);
			 }
			 return (getDelegate().deleteCalendar(conn, calName) > 0);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't remove calendar: "" + e.getMessage(), e);
		 }
	 }
	 public Calendar retrieveCalendar(final SchedulingContext ctxt, final String calName) throws JobPersistenceException {
		 return (Calendar)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return retrieveCalendar(conn, ctxt, calName);
			 }
		 }
		);
	 }
	 protected Calendar retrieveCalendar(Connection conn, SchedulingContext ctxt, String calName) throws JobPersistenceException {
		 Calendar cal = (isClustered) ? null : (Calendar) calendarCache.get(calName);
		 if (cal != null) {
			 return cal;
		 }
		 try {
			 cal = getDelegate().selectCalendar(conn, calName);
			 if (isClustered == false) {
				 calendarCache.put(calName, cal);
			 }
			 return cal;
		 }
		 catch (ClassNotFoundException e) {
			 throw new JobPersistenceException( ""Couldn't retrieve calendar because a required class was not found: "" + e.getMessage(), e);
		 }
		 catch (IOException e) {
			 throw new JobPersistenceException( ""Couldn't retrieve calendar because the BLOB couldn't be deserialized: "" + e.getMessage(), e);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't retrieve calendar: "" + e.getMessage(), e);
		 }
	 }
	 public int getNumberOfJobs(final SchedulingContext ctxt) throws JobPersistenceException {
		 return ((Integer)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return new Integer(getNumberOfJobs(conn, ctxt));
			 }
		 }
		)).intValue();
	 }
	 protected int getNumberOfJobs(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 try {
			 return getDelegate().selectNumJobs(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't obtain number of jobs: "" + e.getMessage(), e);
		 }
	 }
	 public int getNumberOfTriggers(final SchedulingContext ctxt) throws JobPersistenceException {
		 return ((Integer)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return new Integer(getNumberOfTriggers(conn, ctxt));
			 }
		 }
		)).intValue();
	 }
	 protected int getNumberOfTriggers(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 try {
			 return getDelegate().selectNumTriggers(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't obtain number of triggers: "" + e.getMessage(), e);
		 }
	 }
	 public int getNumberOfCalendars(final SchedulingContext ctxt) throws JobPersistenceException {
		 return ((Integer)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return new Integer(getNumberOfCalendars(conn, ctxt));
			 }
		 }
		)).intValue();
	 }
	 protected int getNumberOfCalendars(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 try {
			 return getDelegate().selectNumCalendars(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't obtain number of calendars: "" + e.getMessage(), e);
		 }
	 }
	 public String[] getJobNames(final SchedulingContext ctxt, final String groupName) throws JobPersistenceException {
		 return (String[])executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getJobNames(conn, ctxt, groupName);
			 }
		 }
		);
	 }
	 protected String[] getJobNames(Connection conn, SchedulingContext ctxt, String groupName) throws JobPersistenceException {
		 String[] jobNames = null;
		 try {
			 jobNames = getDelegate().selectJobsInGroup(conn, groupName);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't obtain job names: "" + e.getMessage(), e);
		 }
		 return jobNames;
	 }
	 public String[] getTriggerNames(final SchedulingContext ctxt, final String groupName) throws JobPersistenceException {
		 return (String[])executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getTriggerNames(conn, ctxt, groupName);
			 }
		 }
		);
	 }
	 protected String[] getTriggerNames(Connection conn, SchedulingContext ctxt, String groupName) throws JobPersistenceException {
		 String[] trigNames = null;
		 try {
			 trigNames = getDelegate().selectTriggersInGroup(conn, groupName);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't obtain trigger names: "" + e.getMessage(), e);
		 }
		 return trigNames;
	 }
	 public String[] getJobGroupNames(final SchedulingContext ctxt) throws JobPersistenceException {
		 return (String[])executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getJobGroupNames(conn, ctxt);
			 }
		 }
		);
	 }
	 protected String[] getJobGroupNames(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 String[] groupNames = null;
		 try {
			 groupNames = getDelegate().selectJobGroups(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't obtain job groups: "" + e.getMessage(), e);
		 }
		 return groupNames;
	 }
	 public String[] getTriggerGroupNames(final SchedulingContext ctxt) throws JobPersistenceException {
		 return (String[])executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getTriggerGroupNames(conn, ctxt);
			 }
		 }
		);
	 }
	 protected String[] getTriggerGroupNames(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 String[] groupNames = null;
		 try {
			 groupNames = getDelegate().selectTriggerGroups(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't obtain trigger groups: "" + e.getMessage(), e);
		 }
		 return groupNames;
	 }
	 public String[] getCalendarNames(final SchedulingContext ctxt) throws JobPersistenceException {
		 return (String[])executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getCalendarNames(conn, ctxt);
			 }
		 }
		);
	 }
	 protected String[] getCalendarNames(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 try {
			 return getDelegate().selectCalendars(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't obtain trigger groups: "" + e.getMessage(), e);
		 }
	 }
	 public Trigger[] getTriggersForJob(final SchedulingContext ctxt, final String jobName, final String groupName) throws JobPersistenceException {
		 return (Trigger[])executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getTriggersForJob(conn, ctxt, jobName, groupName);
			 }
		 }
		);
	 }
	 protected Trigger[] getTriggersForJob(Connection conn, SchedulingContext ctxt, String jobName, String groupName) throws JobPersistenceException {
		 Trigger[] array = null;
		 try {
			 array = getDelegate() .selectTriggersForJob(conn, jobName, groupName);
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException( ""Couldn't obtain triggers for job: "" + e.getMessage(), e);
		 }
		 return array;
	 }
	 public void pauseTrigger(final SchedulingContext ctxt, final String triggerName, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 pauseTrigger(conn, ctxt, triggerName, groupName);
			 }
		 }
		);
	 }
	 public void pauseTrigger(Connection conn, SchedulingContext ctxt, String triggerName, String groupName) throws JobPersistenceException {
		 try {
			 String oldState = getDelegate().selectTriggerState(conn, triggerName, groupName);
			 if (oldState.equals(STATE_WAITING) || oldState.equals(STATE_ACQUIRED)) {
				 getDelegate().updateTriggerState(conn, triggerName, groupName, STATE_PAUSED);
			 }
			 else if (oldState.equals(STATE_BLOCKED)) {
				 getDelegate().updateTriggerState(conn, triggerName, groupName, STATE_PAUSED_BLOCKED);
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't pause trigger '"" + groupName + ""."" + triggerName + ""': "" + e.getMessage(), e);
		 }
	 }
	 public void pauseJob(final SchedulingContext ctxt, final String jobName, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 Trigger[] triggers = getTriggersForJob(conn, ctxt, jobName, groupName);
				 for (int j = 0;
				 j < triggers.length;
				 j++) {
					 pauseTrigger(conn, ctxt, triggers[j].getName(), triggers[j].getGroup());
				 }
			 }
		 }
		);
	 }
	 public void pauseJobGroup(final SchedulingContext ctxt, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 String[] jobNames = getJobNames(conn, ctxt, groupName);
				 for (int i = 0;
				 i < jobNames.length;
				 i++) {
					 Trigger[] triggers = getTriggersForJob(conn, ctxt, jobNames[i], groupName);
					 for (int j = 0;
					 j < triggers.length;
					 j++) {
						 pauseTrigger(conn, ctxt, triggers[j].getName(), triggers[j].getGroup());
					 }
				 }
			 }
		 }
		);
	 }
	 protected String checkBlockedState( Connection conn, SchedulingContext ctxt, String jobName, String jobGroupName, String currentState) throws JobPersistenceException {
		 if ((currentState.equals(STATE_WAITING) == false) && (currentState.equals(STATE_PAUSED) == false)) {
			 return currentState;
		 }
		 try {
			 List lst = getDelegate().selectFiredTriggerRecordsByJob(conn, jobName, jobGroupName);
			 if (lst.size() > 0) {
				 FiredTriggerRecord rec = (FiredTriggerRecord) lst.get(0);
				 if (rec.isJobIsStateful()) {
					 return (STATE_PAUSED.equals(currentState)) ? STATE_PAUSED_BLOCKED : STATE_BLOCKED;
				 }
			 }
			 return currentState;
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't determine if trigger should be in a blocked state '"" + jobGroupName + ""."" + jobName + ""': "" + e.getMessage(), e);
		 }
	 }
	 public void resumeTrigger(final SchedulingContext ctxt, final String triggerName, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 resumeTrigger(conn, ctxt, triggerName, groupName);
			 }
		 }
		);
	 }
	 public void resumeTrigger(Connection conn, SchedulingContext ctxt, String triggerName, String groupName) throws JobPersistenceException {
		 try {
			 TriggerStatus status = getDelegate().selectTriggerStatus(conn, triggerName, groupName);
			 if (status == null || status.getNextFireTime() == null) {
				 return;
			 }
			 boolean blocked = false;
			 if(STATE_PAUSED_BLOCKED.equals(status.getStatus())) {
				 blocked = true;
			 }
			 String newState = checkBlockedState(conn, ctxt, status.getJobKey().getName(), status.getJobKey().getGroup(), STATE_WAITING);
			 boolean misfired = false;
			 if (status.getNextFireTime().before(new Date())) {
				 misfired = updateMisfiredTrigger(conn, ctxt, triggerName, groupName, newState, true);
			 }
			 if(!misfired) {
				 if(blocked) {
					 getDelegate().updateTriggerStateFromOtherState(conn, triggerName, groupName, newState, STATE_PAUSED_BLOCKED);
				 }
				 else {
					 getDelegate().updateTriggerStateFromOtherState(conn, triggerName, groupName, newState, STATE_PAUSED);
				 }
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't resume trigger '"" + groupName + ""."" + triggerName + ""': "" + e.getMessage(), e);
		 }
	 }
	 public void resumeJob(final SchedulingContext ctxt, final String jobName, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 Trigger[] triggers = getTriggersForJob(conn, ctxt, jobName, groupName);
				 for (int j = 0;
				 j < triggers.length;
				 j++) {
					 resumeTrigger(conn, ctxt, triggers[j].getName(), triggers[j].getGroup());
				 }
			 }
		 }
		);
	 }
	 public void resumeJobGroup(final SchedulingContext ctxt, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 String[] jobNames = getJobNames(conn, ctxt, groupName);
				 for (int i = 0;
				 i < jobNames.length;
				 i++) {
					 Trigger[] triggers = getTriggersForJob(conn, ctxt, jobNames[i], groupName);
					 for (int j = 0;
					 j < triggers.length;
					 j++) {
						 resumeTrigger(conn, ctxt, triggers[j].getName(), triggers[j].getGroup());
					 }
				 }
			 }
		 }
		);
	 }
	 public void pauseTriggerGroup(final SchedulingContext ctxt, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 pauseTriggerGroup(conn, ctxt, groupName);
			 }
		 }
		);
	 }
	 public void pauseTriggerGroup(Connection conn, SchedulingContext ctxt, String groupName) throws JobPersistenceException {
		 try {
			 getDelegate().updateTriggerGroupStateFromOtherStates( conn, groupName, STATE_PAUSED, STATE_ACQUIRED, STATE_WAITING, STATE_WAITING);
			 getDelegate().updateTriggerGroupStateFromOtherState( conn, groupName, STATE_PAUSED_BLOCKED, STATE_BLOCKED);
			 if (!getDelegate().isTriggerGroupPaused(conn, groupName)) {
				 getDelegate().insertPausedTriggerGroup(conn, groupName);
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't pause trigger group '"" + groupName + ""': "" + e.getMessage(), e);
		 }
	 }
	 public Set getPausedTriggerGroups(final SchedulingContext ctxt) throws JobPersistenceException {
		 return (Set)executeWithoutLock( new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 return getPausedTriggerGroups(conn, ctxt);
			 }
		 }
		);
	 }
	 public Set getPausedTriggerGroups(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 try {
			 return getDelegate().selectPausedTriggerGroups(conn);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't determine paused trigger groups: "" + e.getMessage(), e);
		 }
	 }
	 public void resumeTriggerGroup(final SchedulingContext ctxt, final String groupName) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 resumeTriggerGroup(conn, ctxt, groupName);
			 }
		 }
		);
	 }
	 public void resumeTriggerGroup(Connection conn, SchedulingContext ctxt, String groupName) throws JobPersistenceException {
		 try {
			 getDelegate().deletePausedTriggerGroup(conn, groupName);
			 String[] trigNames = getDelegate().selectTriggersInGroup(conn, groupName);
			 for (int i = 0;
			 i < trigNames.length;
			 i++) {
				 resumeTrigger(conn, ctxt, trigNames[i], groupName);
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't pause trigger group '"" + groupName + ""': "" + e.getMessage(), e);
		 }
	 }
	 public void pauseAll(final SchedulingContext ctxt) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 pauseAll(conn, ctxt);
			 }
		 }
		);
	 }
	 public void pauseAll(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 String[] names = getTriggerGroupNames(conn, ctxt);
		 for (int i = 0;
		 i < names.length;
		 i++) {
			 pauseTriggerGroup(conn, ctxt, names[i]);
		 }
		 try {
			 if (!getDelegate().isTriggerGroupPaused(conn, ALL_GROUPS_PAUSED)) {
				 getDelegate().insertPausedTriggerGroup(conn, ALL_GROUPS_PAUSED);
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't pause all trigger groups: "" + e.getMessage(), e);
		 }
	 }
	 public void resumeAll(final SchedulingContext ctxt) throws JobPersistenceException {
		 executeInLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 resumeAll(conn, ctxt);
			 }
		 }
		);
	 }
	 public void resumeAll(Connection conn, SchedulingContext ctxt) throws JobPersistenceException {
		 String[] names = getTriggerGroupNames(conn, ctxt);
		 for (int i = 0;
		 i < names.length;
		 i++) {
			 resumeTriggerGroup(conn, ctxt, names[i]);
		 }
		 try {
			 getDelegate().deletePausedTriggerGroup(conn, ALL_GROUPS_PAUSED);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't resume all trigger groups: "" + e.getMessage(), e);
		 }
	 }
	 private static long ftrCtr = System.currentTimeMillis();
	 protected synchronized String getFiredTriggerRecordId() {
		 return getInstanceId() + ftrCtr++;
	 }
	 public Trigger acquireNextTrigger(final SchedulingContext ctxt, final long noLaterThan) throws JobPersistenceException {
		 if(isAcquireTriggersWithinLock()) {
			 return (Trigger)executeInNonManagedTXLock( LOCK_TRIGGER_ACCESS, new TransactionCallback() {
				 public Object execute(Connection conn) throws JobPersistenceException {
					 return acquireNextTrigger(conn, ctxt, noLaterThan);
				 }
			 }
			);
		 }
		 else {
			 return (Trigger)executeInNonManagedTXLock( null, new TransactionCallback() {
				 public Object execute(Connection conn) throws JobPersistenceException {
					 return acquireNextTrigger(conn, ctxt, noLaterThan);
				 }
			 }
			);
		 }
	 }
	 protected Trigger acquireNextTrigger(Connection conn, SchedulingContext ctxt, long noLaterThan) throws JobPersistenceException {
		 do {
			 try {
				 Trigger nextTrigger = null;
				 List keys = getDelegate().selectTriggerToAcquire(conn, noLaterThan, getMisfireTime());
				 if (keys == null || keys.size() == 0) return null;
				 Iterator itr = keys.iterator();
				 while(itr.hasNext()) {
					 Key triggerKey = (Key) itr.next();
					 int rowsUpdated = getDelegate().updateTriggerStateFromOtherState( conn, triggerKey.getName(), triggerKey.getGroup(), STATE_ACQUIRED, STATE_WAITING);
					 if (rowsUpdated <= 0) {
						 continue;
					 }
					 nextTrigger = retrieveTrigger(conn, ctxt, triggerKey.getName(), triggerKey.getGroup());
					 if(nextTrigger == null) {
						 continue;
					 }
					 break;
				 }
				 if(nextTrigger == null) {
					 continue;
				 }
				 nextTrigger.setFireInstanceId(getFiredTriggerRecordId());
				 getDelegate().insertFiredTrigger(conn, nextTrigger, STATE_ACQUIRED, null);
				 return nextTrigger;
			 }
			 catch (Exception e) {
				 throw new JobPersistenceException( ""Couldn't acquire next trigger: "" + e.getMessage(), e);
			 }
		 }
		 while (true);
	 }
	 public void releaseAcquiredTrigger(final SchedulingContext ctxt, final Trigger trigger) throws JobPersistenceException {
		 executeInNonManagedTXLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 releaseAcquiredTrigger(conn, ctxt, trigger);
			 }
		 }
		);
	 }
	 protected void releaseAcquiredTrigger(Connection conn, SchedulingContext ctxt, Trigger trigger) throws JobPersistenceException {
		 try {
			 getDelegate().updateTriggerStateFromOtherState(conn, trigger.getName(), trigger.getGroup(), STATE_WAITING, STATE_ACQUIRED);
			 getDelegate().deleteFiredTrigger(conn, trigger.getFireInstanceId());
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't release acquired trigger: "" + e.getMessage(), e);
		 }
	 }
	 public TriggerFiredBundle triggerFired( final SchedulingContext ctxt, final Trigger trigger) throws JobPersistenceException {
		 return (TriggerFiredBundle)executeInNonManagedTXLock( LOCK_TRIGGER_ACCESS, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 try {
					 return triggerFired(conn, ctxt, trigger);
				 }
				 catch (JobPersistenceException jpe) {
					 if (jpe.getErrorCode() == SchedulerException.ERR_PERSISTENCE_JOB_DOES_NOT_EXIST) {
						 return null;
					 }
					 else {
						 throw jpe;
					 }
				 }
			 }
		 }
		);
	 }
	 protected TriggerFiredBundle triggerFired(Connection conn, SchedulingContext ctxt, Trigger trigger) throws JobPersistenceException {
		 JobDetail job = null;
		 Calendar cal = null;
		 try {
			 String state = getDelegate().selectTriggerState(conn, trigger.getName(), trigger.getGroup());
			 if (!state.equals(STATE_ACQUIRED)) {
				 return null;
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't select trigger state: "" + e.getMessage(), e);
		 }
		 try {
			 job = retrieveJob(conn, ctxt, trigger.getJobName(), trigger .getJobGroup());
			 if (job == null) {
				 return null;
			 }
		 }
		 catch (JobPersistenceException jpe) {
			 try {
				 getLog().error(""Error retrieving job, setting trigger state to ERROR."", jpe);
				 getDelegate().updateTriggerState(conn, trigger.getName(), trigger.getGroup(), STATE_ERROR);
			 }
			 catch (SQLException sqle) {
				 getLog().error(""Unable to set trigger state to ERROR."", sqle);
			 }
			 throw jpe;
		 }
		 if (trigger.getCalendarName() != null) {
			 cal = retrieveCalendar(conn, ctxt, trigger.getCalendarName());
			 if (cal == null) {
				 return null;
			 }
		 }
		 try {
			 getDelegate().deleteFiredTrigger(conn, trigger.getFireInstanceId());
			 getDelegate().insertFiredTrigger(conn, trigger, STATE_EXECUTING, job);
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't insert fired trigger: "" + e.getMessage(), e);
		 }
		 Date prevFireTime = trigger.getPreviousFireTime();
		 trigger.triggered(cal);
		 String state = STATE_WAITING;
		 boolean force = true;
		 if (job.isStateful()) {
			 state = STATE_BLOCKED;
			 force = false;
			 try {
				 getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getName(), job.getGroup(), STATE_BLOCKED, STATE_WAITING);
				 getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getName(), job.getGroup(), STATE_BLOCKED, STATE_ACQUIRED);
				 getDelegate().updateTriggerStatesForJobFromOtherState(conn, job.getName(), job.getGroup(), STATE_PAUSED_BLOCKED, STATE_PAUSED);
			 }
			 catch (SQLException e) {
				 throw new JobPersistenceException( ""Couldn't update states of blocked triggers: "" + e.getMessage(), e);
			 }
		 }
		 if (trigger.getNextFireTime() == null) {
			 state = STATE_COMPLETE;
			 force = true;
		 }
		 storeTrigger(conn, ctxt, trigger, job, true, state, force, false);
		 job.getJobDataMap().clearDirtyFlag();
		 return new TriggerFiredBundle(job, trigger, cal, trigger.getGroup() .equals(Scheduler.DEFAULT_RECOVERY_GROUP), new Date(), trigger .getPreviousFireTime(), prevFireTime, trigger.getNextFireTime());
	 }
	 public void triggeredJobComplete(final SchedulingContext ctxt, final Trigger trigger, final JobDetail jobDetail, final int triggerInstCode) throws JobPersistenceException {
		 executeInNonManagedTXLock( LOCK_TRIGGER_ACCESS, new VoidTransactionCallback() {
			 public void execute(Connection conn) throws JobPersistenceException {
				 triggeredJobComplete(conn, ctxt, trigger, jobDetail,triggerInstCode);
			 }
		 }
		);
	 }
	 protected void triggeredJobComplete(Connection conn, SchedulingContext ctxt, Trigger trigger, JobDetail jobDetail, int triggerInstCode) throws JobPersistenceException {
		 try {
			 if (triggerInstCode == Trigger.INSTRUCTION_DELETE_TRIGGER) {
				 if(trigger.getNextFireTime() == null) {
					 TriggerStatus stat = getDelegate().selectTriggerStatus( conn, trigger.getName(), trigger.getGroup());
					 if(stat != null && stat.getNextFireTime() == null) {
						 removeTrigger(conn, ctxt, trigger.getName(), trigger.getGroup());
					 }
				 }
				 else{
					 removeTrigger(conn, ctxt, trigger.getName(), trigger.getGroup());
					 signalSchedulingChangeOnTxCompletion(0L);
				 }
			 }
			 else if (triggerInstCode == Trigger.INSTRUCTION_SET_TRIGGER_COMPLETE) {
				 getDelegate().updateTriggerState(conn, trigger.getName(), trigger.getGroup(), STATE_COMPLETE);
				 signalSchedulingChangeOnTxCompletion(0L);
			 }
			 else if (triggerInstCode == Trigger.INSTRUCTION_SET_TRIGGER_ERROR) {
				 getLog().info(""Trigger "" + trigger.getFullName() + "" set to ERROR state."");
				 getDelegate().updateTriggerState(conn, trigger.getName(), trigger.getGroup(), STATE_ERROR);
				 signalSchedulingChangeOnTxCompletion(0L);
			 }
			 else if (triggerInstCode == Trigger.INSTRUCTION_SET_ALL_JOB_TRIGGERS_COMPLETE) {
				 getDelegate().updateTriggerStatesForJob(conn, trigger.getJobName(), trigger.getJobGroup(), STATE_COMPLETE);
				 signalSchedulingChangeOnTxCompletion(0L);
			 }
			 else if (triggerInstCode == Trigger.INSTRUCTION_SET_ALL_JOB_TRIGGERS_ERROR) {
				 getLog().info(""All triggers of Job "" + trigger.getFullJobName() + "" set to ERROR state."");
				 getDelegate().updateTriggerStatesForJob(conn, trigger.getJobName(), trigger.getJobGroup(), STATE_ERROR);
				 signalSchedulingChangeOnTxCompletion(0L);
			 }
			 if (jobDetail.isStateful()) {
				 getDelegate().updateTriggerStatesForJobFromOtherState(conn, jobDetail.getName(), jobDetail.getGroup(), STATE_WAITING, STATE_BLOCKED);
				 getDelegate().updateTriggerStatesForJobFromOtherState(conn, jobDetail.getName(), jobDetail.getGroup(), STATE_PAUSED, STATE_PAUSED_BLOCKED);
				 signalSchedulingChangeOnTxCompletion(0L);
				 try {
					 if (jobDetail.getJobDataMap().isDirty()) {
						 getDelegate().updateJobData(conn, jobDetail);
					 }
				 }
				 catch (IOException e) {
					 throw new JobPersistenceException( ""Couldn't serialize job data: "" + e.getMessage(), e);
				 }
				 catch (SQLException e) {
					 throw new JobPersistenceException( ""Couldn't update job data: "" + e.getMessage(), e);
				 }
			 }
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException( ""Couldn't update trigger state(s): "" + e.getMessage(), e);
		 }
		 try {
			 getDelegate().deleteFiredTrigger(conn, trigger.getFireInstanceId());
		 }
		 catch (SQLException e) {
			 throw new JobPersistenceException(""Couldn't delete fired trigger: "" + e.getMessage(), e);
		 }
	 }
	 protected DriverDelegate getDelegate() throws NoSuchDelegateException {
		 if (null == delegate) {
			 try {
				 if(delegateClassName != null) {
					 delegateClass = getClassLoadHelper().loadClass(delegateClassName);
				 }
				 Constructor ctor = null;
				 Object[] ctorParams = null;
				 if (canUseProperties()) {
					 Class[] ctorParamTypes = new Class[]{
					 Logger.class, String.class, String.class, Boolean.class}
					;
					 ctor = delegateClass.getConstructor(ctorParamTypes);
					 ctorParams = new Object[]{
					 getLog(), tablePrefix, instanceId, new Boolean(canUseProperties())}
					;
				 }
				 else {
					 Class[] ctorParamTypes = new Class[]{
					 Logger.class, String.class, String.class}
					;
					 ctor = delegateClass.getConstructor(ctorParamTypes);
					 ctorParams = new Object[]{
					getLog(), tablePrefix, instanceId}
					;
				 }
				 delegate = (DriverDelegate) ctor.newInstance(ctorParams);
			 }
			 catch (NoSuchMethodException e) {
				 throw new NoSuchDelegateException( ""Couldn't find delegate constructor: "" + e.getMessage());
			 }
			 catch (InstantiationException e) {
				 throw new NoSuchDelegateException(""Couldn't create delegate: "" + e.getMessage());
			 }
			 catch (IllegalAccessException e) {
				 throw new NoSuchDelegateException(""Couldn't create delegate: "" + e.getMessage());
			 }
			 catch (InvocationTargetException e) {
				 throw new NoSuchDelegateException(""Couldn't create delegate: "" + e.getMessage());
			 }
			 catch (ClassNotFoundException e) {
				 throw new NoSuchDelegateException(""Couldn't load delegate class: "" + e.getMessage());
			 }
		 }
		 return delegate;
	 }
	 protected Semaphore getLockHandler() {
		 return lockHandler;
	 }
	 public void setLockHandler(Semaphore lockHandler) {
		 this.lockHandler = lockHandler;
	 }
	 protected RecoverMisfiredJobsResult doRecoverMisfires() throws JobPersistenceException {
		 boolean transOwner = false;
		 Connection conn = getNonManagedTXConnection();
		 try {
			 RecoverMisfiredJobsResult result = RecoverMisfiredJobsResult.NO_OP;
			 int misfireCount = (getDoubleCheckLockMisfireHandler()) ? getDelegate().countMisfiredTriggersInStates( conn, STATE_MISFIRED, STATE_WAITING, getMisfireTime()) : Integer.MAX_VALUE;
			 if (misfireCount == 0) {
				 getLog().debug( ""Found 0 triggers that missed their scheduled fire-time."");
			 }
			 else {
				 transOwner = getLockHandler().obtainLock(conn, LOCK_TRIGGER_ACCESS);
				 result = recoverMisfiredJobs(conn, false);
			 }
			 commitConnection(conn);
			 return result;
		 }
		 catch (JobPersistenceException e) {
			 rollbackConnection(conn);
			 throw e;
		 }
		 catch (SQLException e) {
			 rollbackConnection(conn);
			 throw new JobPersistenceException(""Database error recovering from misfires."", e);
		 }
		 catch (RuntimeException e) {
			 rollbackConnection(conn);
			 throw new JobPersistenceException(""Unexpected runtime exception: "" + e.getMessage(), e);
		 }
		 finally {
			 try {
				 releaseLock(conn, LOCK_TRIGGER_ACCESS, transOwner);
			 }
			 finally {
				 cleanupConnection(conn);
			 }
		 }
	 }
	 protected ThreadLocal<Long> sigChangeForTxCompletion = new ThreadLocal<Long>();
	 protected void signalSchedulingChangeOnTxCompletion(long candidateNewNextFireTime) {
		 Long sigTime = sigChangeForTxCompletion.get();
		 if(sigTime == null && candidateNewNextFireTime >= 0L) sigChangeForTxCompletion.set(candidateNewNextFireTime);
		 else {
			 if(candidateNewNextFireTime < sigTime) sigChangeForTxCompletion.set(candidateNewNextFireTime);
		 }
	 }
	 protected Long clearAndGetSignalSchedulingChangeOnTxCompletion() {
		 Long t = sigChangeForTxCompletion.get();
		 sigChangeForTxCompletion.set(null);
		 return t;
	 }
	 protected void signalSchedulingChangeImmediately(long candidateNewNextFireTime) {
		 schedSignaler.signalSchedulingChange(candidateNewNextFireTime);
	 }
	 protected boolean firstCheckIn = true;
	 protected long lastCheckin = System.currentTimeMillis();
	 protected boolean doCheckin() throws JobPersistenceException {
		 boolean transOwner = false;
		 boolean transStateOwner = false;
		 boolean recovered = false;
		 Connection conn = getNonManagedTXConnection();
		 try {
			 List failedRecords = null;
			 if (firstCheckIn == false) {
				 failedRecords = clusterCheckIn(conn);
				 commitConnection(conn);
			 }
			 if (firstCheckIn || (failedRecords.size() > 0)) {
				 getLockHandler().obtainLock(conn, LOCK_STATE_ACCESS);
				 transStateOwner = true;
				 failedRecords = (firstCheckIn) ? clusterCheckIn(conn) : findFailedInstances(conn);
				 if (failedRecords.size() > 0) {
					 getLockHandler().obtainLock(conn, LOCK_TRIGGER_ACCESS);
					 transOwner = true;
					 clusterRecover(conn, failedRecords);
					 recovered = true;
				 }
			 }
			 commitConnection(conn);
		 }
		 catch (JobPersistenceException e) {
			 rollbackConnection(conn);
			 throw e;
		 }
		 finally {
			 try {
				 releaseLock(conn, LOCK_TRIGGER_ACCESS, transOwner);
			 }
			 finally {
				 try {
					 releaseLock(conn, LOCK_STATE_ACCESS, transStateOwner);
				 }
				 finally {
					 cleanupConnection(conn);
				 }
			 }
		 }
		 firstCheckIn = false;
		 return recovered;
	 }
	 protected List findFailedInstances(Connection conn) throws JobPersistenceException {
		 try {
			 List failedInstances = new LinkedList();
			 boolean foundThisScheduler = false;
			 long timeNow = System.currentTimeMillis();
			 List states = getDelegate().selectSchedulerStateRecords(conn, null);
			 for (Iterator itr = states.iterator();
			 itr.hasNext();
			) {
				 SchedulerStateRecord rec = (SchedulerStateRecord) itr.next();
				 if (rec.getSchedulerInstanceId().equals(getInstanceId())) {
					 foundThisScheduler = true;
					 if (firstCheckIn) {
						 failedInstances.add(rec);
					 }
				 }
				 else {
					 if (calcFailedIfAfter(rec) < timeNow) {
						 failedInstances.add(rec);
					 }
				 }
			 }
			 if (firstCheckIn) {
				 failedInstances.addAll(findOrphanedFailedInstances(conn, states));
			 }
			 if ((foundThisScheduler == false) && (firstCheckIn == false)) {
				 getLog().warn( ""This scheduler instance ("" + getInstanceId() + "") is still "" + ""active but was recovered by another instance in the cluster. "" + ""This may cause inconsistent behavior."");
			 }
			 return failedInstances;
		 }
		 catch (Exception e) {
			 lastCheckin = System.currentTimeMillis();
			 throw new JobPersistenceException(""Failure identifying failed instances when checking-in: "" + e.getMessage(), e);
		 }
	 }
	 private List findOrphanedFailedInstances( Connection conn, List schedulerStateRecords) throws SQLException, NoSuchDelegateException {
		 List orphanedInstances = new ArrayList();
		 Set allFiredTriggerInstanceNames = getDelegate().selectFiredTriggerInstanceNames(conn);
		 if (allFiredTriggerInstanceNames.isEmpty() == false) {
			 for (Iterator schedulerStateIter = schedulerStateRecords.iterator();
			 schedulerStateIter.hasNext();
			) {
				 SchedulerStateRecord rec = (SchedulerStateRecord)schedulerStateIter.next();
				 allFiredTriggerInstanceNames.remove(rec.getSchedulerInstanceId());
			 }
			 for (Iterator orphanIter = allFiredTriggerInstanceNames.iterator();
			 orphanIter.hasNext();
			) {
				 SchedulerStateRecord orphanedInstance = new SchedulerStateRecord();
				 orphanedInstance.setSchedulerInstanceId((String)orphanIter.next());
				 orphanedInstances.add(orphanedInstance);
				 getLog().warn( ""Found orphaned fired triggers for instance: "" + orphanedInstance.getSchedulerInstanceId());
			 }
		 }
		 return orphanedInstances;
	 }
	 protected long calcFailedIfAfter(SchedulerStateRecord rec) {
		 return rec.getCheckinTimestamp() + Math.max(rec.getCheckinInterval(), (System.currentTimeMillis() - lastCheckin)) + 7500L;
	 }
	 protected List clusterCheckIn(Connection conn) throws JobPersistenceException {
		 List failedInstances = findFailedInstances(conn);
		 try {
			 lastCheckin = System.currentTimeMillis();
			 if(getDelegate().updateSchedulerState(conn, getInstanceId(), lastCheckin) == 0) {
				 getDelegate().insertSchedulerState(conn, getInstanceId(), lastCheckin, getClusterCheckinInterval());
			 }
		 }
		 catch (Exception e) {
			 throw new JobPersistenceException(""Failure updating scheduler state when checking-in: "" + e.getMessage(), e);
		 }
		 return failedInstances;
	 }
	 protected void clusterRecover(Connection conn, List failedInstances) throws JobPersistenceException {
		 if (failedInstances.size() > 0) {
			 long recoverIds = System.currentTimeMillis();
			 logWarnIfNonZero(failedInstances.size(), ""ClusterManager: detected "" + failedInstances.size() + "" failed or restarted instances."");
			 try {
				 Iterator itr = failedInstances.iterator();
				 while (itr.hasNext()) {
					 SchedulerStateRecord rec = (SchedulerStateRecord) itr .next();
					 getLog().info( ""ClusterManager: Scanning for instance \"""" + rec.getSchedulerInstanceId() + ""\""'s failed in-progress jobs."");
					 List firedTriggerRecs = getDelegate() .selectInstancesFiredTriggerRecords(conn, rec.getSchedulerInstanceId());
					 int acquiredCount = 0;
					 int recoveredCount = 0;
					 int otherCount = 0;
					 Set triggerKeys = new HashSet();
					 Iterator ftItr = firedTriggerRecs.iterator();
					 while (ftItr.hasNext()) {
						 FiredTriggerRecord ftRec = (FiredTriggerRecord) ftItr .next();
						 Key tKey = ftRec.getTriggerKey();
						 Key jKey = ftRec.getJobKey();
						 triggerKeys.add(tKey);
						 if (ftRec.getFireInstanceState().equals(STATE_BLOCKED)) {
							 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_WAITING, STATE_BLOCKED);
						 }
						 else if (ftRec.getFireInstanceState().equals(STATE_PAUSED_BLOCKED)) {
							 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_PAUSED, STATE_PAUSED_BLOCKED);
						 }
						 if (ftRec.getFireInstanceState().equals(STATE_ACQUIRED)) {
							 getDelegate().updateTriggerStateFromOtherState( conn, tKey.getName(), tKey.getGroup(), STATE_WAITING, STATE_ACQUIRED);
							 acquiredCount++;
						 }
						 else if (ftRec.isJobRequestsRecovery()) {
							 if (jobExists(conn, jKey.getName(), jKey.getGroup())) {
								 SimpleTrigger rcvryTrig = new SimpleTrigger( ""recover_"" + rec.getSchedulerInstanceId() + ""_"" + String.valueOf(recoverIds++), Scheduler.DEFAULT_RECOVERY_GROUP, new Date(ftRec.getFireTimestamp()));
								 rcvryTrig.setVolatility(ftRec.isTriggerIsVolatile());
								 rcvryTrig.setJobName(jKey.getName());
								 rcvryTrig.setJobGroup(jKey.getGroup());
								 rcvryTrig.setMisfireInstruction(SimpleTrigger.MISFIRE_INSTRUCTION_FIRE_NOW);
								 rcvryTrig.setPriority(ftRec.getPriority());
								 JobDataMap jd = getDelegate().selectTriggerJobDataMap(conn, tKey.getName(), tKey.getGroup());
								 jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_NAME, tKey.getName());
								 jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_GROUP, tKey.getGroup());
								 jd.put(Scheduler.FAILED_JOB_ORIGINAL_TRIGGER_FIRETIME_IN_MILLISECONDS, String.valueOf(ftRec.getFireTimestamp()));
								 rcvryTrig.setJobDataMap(jd);
								 rcvryTrig.computeFirstFireTime(null);
								 storeTrigger(conn, null, rcvryTrig, null, false, STATE_WAITING, false, true);
								 recoveredCount++;
							 }
							 else {
								 getLog() .warn( ""ClusterManager: failed job '"" + jKey + ""' no longer exists, cannot schedule recovery."");
								 otherCount++;
							 }
						 }
						 else {
							 otherCount++;
						 }
						 if (ftRec.isJobIsStateful()) {
							 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_WAITING, STATE_BLOCKED);
							 getDelegate() .updateTriggerStatesForJobFromOtherState( conn, jKey.getName(), jKey.getGroup(), STATE_PAUSED, STATE_PAUSED_BLOCKED);
						 }
					 }
					 getDelegate().deleteFiredTriggers(conn, rec.getSchedulerInstanceId());
					 int completeCount = 0;
					 for (Iterator triggerKeyIter = triggerKeys.iterator();
					 triggerKeyIter.hasNext();
					) {
						 Key triggerKey = (Key)triggerKeyIter.next();
						 if (getDelegate().selectTriggerState(conn, triggerKey.getName(), triggerKey.getGroup()). equals(STATE_COMPLETE)) {
							 List firedTriggers = getDelegate().selectFiredTriggerRecords(conn, triggerKey.getName(), triggerKey.getGroup());
							 if (firedTriggers.isEmpty()) {
								 SchedulingContext schedulingContext = new SchedulingContext();
								 schedulingContext.setInstanceId(instanceId);
								 if (removeTrigger(conn, schedulingContext, triggerKey.getName(), triggerKey.getGroup())) {
									 completeCount++;
								 }
							 }
						 }
					 }
					 logWarnIfNonZero(acquiredCount, ""ClusterManager: ......Freed "" + acquiredCount + "" acquired trigger(s)."");
					 logWarnIfNonZero(completeCount, ""ClusterManager: ......Deleted "" + completeCount + "" complete triggers(s)."");
					 logWarnIfNonZero(recoveredCount, ""ClusterManager: ......Scheduled "" + recoveredCount + "" recoverable job(s) for recovery."");
					 logWarnIfNonZero(otherCount, ""ClusterManager: ......Cleaned-up "" + otherCount + "" other failed job(s)."");
					 if (rec.getSchedulerInstanceId().equals(getInstanceId()) == false) {
						 getDelegate().deleteSchedulerState(conn, rec.getSchedulerInstanceId());
					 }
				 }
			 }
			 catch (Exception e) {
				 throw new JobPersistenceException(""Failure recovering jobs: "" + e.getMessage(), e);
			 }
		 }
	 }
	 protected void logWarnIfNonZero(int val, String warning) {
		 if (val > 0) {
			 getLog().info(warning);
		 }
		 else {
			 getLog().debug(warning);
		 }
	 }
	 protected void cleanupConnection(Connection conn) {
		 if (conn != null) {
			 if (conn instanceof Proxy) {
				 Proxy connProxy = (Proxy)conn;
				 InvocationHandler invocationHandler = Proxy.getInvocationHandler(connProxy);
				 if (invocationHandler instanceof AttributeRestoringConnectionInvocationHandler) {
					 AttributeRestoringConnectionInvocationHandler connHandler = (AttributeRestoringConnectionInvocationHandler)invocationHandler;
					 connHandler.restoreOriginalAtributes();
					 closeConnection(connHandler.getWrappedConnection());
					 return;
				 }
			 }
			 closeConnection(conn);
		 }
	 }
	 protected void closeConnection(Connection conn) {
		 if (conn != null) {
			 try {
				 conn.close();
			 }
			 catch (SQLException e) {
				 getLog().error(""Failed to close Connection"", e);
			 }
			 catch (Throwable e) {
				 getLog().error( ""Unexpected exception closing Connection."" + "" This is often due to a Connection being returned after or during shutdown."", e);
			 }
		 }
	 }
	 protected void rollbackConnection(Connection conn) {
		 if (conn != null) {
			 try {
				 conn.rollback();
			 }
			 catch (SQLException e) {
				 getLog().error( ""Couldn't rollback jdbc connection. ""+e.getMessage(), e);
			 }
		 }
	 }
	 protected void commitConnection(Connection conn) throws JobPersistenceException {
		 if (conn != null) {
			 try {
				 conn.commit();
			 }
			 catch (SQLException e) {
				 throw new JobPersistenceException( ""Couldn't commit jdbc connection. ""+e.getMessage(), e);
			 }
		 }
	 }
	 protected interface TransactionCallback {
		 Object execute(Connection conn) throws JobPersistenceException;
	 }
	 protected interface VoidTransactionCallback {
		 void execute(Connection conn) throws JobPersistenceException;
	 }
	 public Object executeWithoutLock( TransactionCallback txCallback) throws JobPersistenceException {
		 return executeInLock(null, txCallback);
	 }
	 protected void executeInLock( final String lockName, final VoidTransactionCallback txCallback) throws JobPersistenceException {
		 executeInLock( lockName, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 txCallback.execute(conn);
				 return null;
			 }
		 }
		);
	 }
	 protected abstract Object executeInLock( String lockName, TransactionCallback txCallback) throws JobPersistenceException;
	 protected void executeInNonManagedTXLock( final String lockName, final VoidTransactionCallback txCallback) throws JobPersistenceException {
		 executeInNonManagedTXLock( lockName, new TransactionCallback() {
			 public Object execute(Connection conn) throws JobPersistenceException {
				 txCallback.execute(conn);
				 return null;
			 }
		 }
		);
	 }
	 protected Object executeInNonManagedTXLock( String lockName, TransactionCallback txCallback) throws JobPersistenceException {
		 boolean transOwner = false;
		 Connection conn = null;
		 try {
			 if (lockName != null) {
				 if (getLockHandler().requiresConnection()) {
					 conn = getNonManagedTXConnection();
				 }
				 transOwner = getLockHandler().obtainLock(conn, lockName);
			 }
			 if (conn == null) {
				 conn = getNonManagedTXConnection();
			 }
			 Object result = txCallback.execute(conn);
			 commitConnection(conn);
			 Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();
			 if(sigTime != null && sigTime >= 0) {
				 signalSchedulingChangeImmediately(sigTime);
			 }
			 return result;
		 }
		 catch (JobPersistenceException e) {
			 rollbackConnection(conn);
			 throw e;
		 }
		 catch (RuntimeException e) {
			 rollbackConnection(conn);
			 throw new JobPersistenceException(""Unexpected runtime exception: "" + e.getMessage(), e);
		 }
		 finally {
			 try {
				 releaseLock(conn, lockName, transOwner);
			 }
			 finally {
				 cleanupConnection(conn);
			 }
		 }
	 }
	 class ClusterManager extends Thread {
		 private boolean shutdown = false;
		 private int numFails = 0;
		 ClusterManager() {
			 this.setPriority(Thread.NORM_PRIORITY + 2);
			 this.setName(""QuartzScheduler_"" + instanceName + ""-"" + instanceId + ""_ClusterManager"");
			 this.setDaemon(getMakeThreadsDaemons());
		 }
		 public void initialize() {
			 this.manage();
			 this.start();
		 }
		 public void shutdown() {
			 shutdown = true;
			 this.interrupt();
		 }
		 private boolean manage() {
			 boolean res = false;
			 try {
				 res = doCheckin();
				 numFails = 0;
				 getLog().debug(""ClusterManager: Check-in complete."");
			 }
			 catch (Exception e) {
				 if(numFails % 4 == 0) {
					 getLog().error( ""ClusterManager: Error managing cluster: "" + e.getMessage(), e);
				 }
				 numFails++;
			 }
			 return res;
		 }
		 public void run() {
			 while (!shutdown) {
				 if (!shutdown) {
					 long timeToSleep = getClusterCheckinInterval();
					 long transpiredTime = (System.currentTimeMillis() - lastCheckin);
					 timeToSleep = timeToSleep - transpiredTime;
					 if (timeToSleep <= 0) {
						 timeToSleep = 100L;
					 }
					 if(numFails > 0) {
						 timeToSleep = Math.max(getDbRetryInterval(), timeToSleep);
					 }
					 try {
						 Thread.sleep(timeToSleep);
					 }
					 catch (Exception ignore) {
					 }
				 }
				 if (!shutdown && this.manage()) {
					 signalSchedulingChangeImmediately(0L);
				 }
			 }
		 }
	 }
	 class MisfireHandler extends Thread {
		 private boolean shutdown = false;
		 private int numFails = 0;
		 MisfireHandler() {
			 this.setName(""QuartzScheduler_"" + instanceName + ""-"" + instanceId + ""_MisfireHandler"");
			 this.setDaemon(getMakeThreadsDaemons());
		 }
		 public void initialize() {
			 this.start();
		 }
		 public void shutdown() {
			 shutdown = true;
			 this.interrupt();
		 }
		 private RecoverMisfiredJobsResult manage() {
			 try {
				 getLog().debug(""MisfireHandler: scanning for misfires..."");
				 RecoverMisfiredJobsResult res = doRecoverMisfires();
				 numFails = 0;
				 return res;
			 }
			 catch (Exception e) {
				 if(numFails % 4 == 0) {
					 getLog().error( ""MisfireHandler: Error handling misfires: "" + e.getMessage(), e);
				 }
				 numFails++;
			 }
			 return RecoverMisfiredJobsResult.NO_OP;
		 }
		 public void run() {
			 while (!shutdown) {
				 long sTime = System.currentTimeMillis();
				 RecoverMisfiredJobsResult recoverMisfiredJobsResult = manage();
				 if (recoverMisfiredJobsResult.getProcessedMisfiredTriggerCount() > 0) {
					 signalSchedulingChangeImmediately(recoverMisfiredJobsResult.getEarliestNewTime());
				 }
				 if (!shutdown) {
					 long timeToSleep = 50l;
					 if (!recoverMisfiredJobsResult.hasMoreMisfiredTriggers()) {
						 timeToSleep = getMisfireThreshold() - (System.currentTimeMillis() - sTime);
						 if (timeToSleep <= 0) {
							 timeToSleep = 50l;
						 }
						 if(numFails > 0) {
							 timeToSleep = Math.max(getDbRetryInterval(), timeToSleep);
						 }
					 }
					 try {
						 Thread.sleep(timeToSleep);
					 }
					 catch (Exception ignore) {
					 }
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class BooleanQuantizer extends StatelessQuantizer {
	 public final float read(ByteBuffer stream, int position) {
		 return 1.0f;
	 }
	 public final void write(ByteBuffer stream, float value) {
	}
	 public String getKey() {
		 return ""boolean"";
	 }
	 public final int size() {
		 return 0;
	 }
 }",0,1,0,0
"class DFA93 extends DFA {
	 public DFA93(BaseRecognizer recognizer) {
		 this.recognizer = recognizer;
		 this.decisionNumber = 93;
		 this.eot = dfa_20;
		 this.eof = dfa_59;
		 this.min = dfa_60;
		 this.max = dfa_61;
		 this.accept = dfa_62;
		 this.special = dfa_63;
		 this.transition = dfa_64;
	 }
	 public String getDescription() {
		 return ""5464:3: ( ( 'extends' | 'static' | 'import' | 'extension' | '!' | '-' | '+' | 'new' | '{
			' | 'switch' | 'synchronized' | '<' | 'super' | '#' | '[' | 'false' | 'true' | 'null' | 'typeof' | 'if' | 'for' | 'while' | 'do' | 'throw' | 'return' | 'try' | '(' | RULE_ID | RULE_HEX | RULE_INT | RULE_DECIMAL | RULE_STRING )=> (lv_expression_2_0= ruleXExpression ) )?"";
		 }
		 public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
			 TokenStream input = (TokenStream)_input;
			 int _s = s;
			 switch ( s ) {
				 case 0 : int LA93_1 = input.LA(1);
				 int index93_1 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_1);
				 if ( s>=0 ) return s;
				 break;
				 case 1 : int LA93_2 = input.LA(1);
				 int index93_2 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_2);
				 if ( s>=0 ) return s;
				 break;
				 case 2 : int LA93_3 = input.LA(1);
				 int index93_3 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_3);
				 if ( s>=0 ) return s;
				 break;
				 case 3 : int LA93_4 = input.LA(1);
				 int index93_4 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_4);
				 if ( s>=0 ) return s;
				 break;
				 case 4 : int LA93_5 = input.LA(1);
				 int index93_5 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_5);
				 if ( s>=0 ) return s;
				 break;
				 case 5 : int LA93_6 = input.LA(1);
				 int index93_6 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_6);
				 if ( s>=0 ) return s;
				 break;
				 case 6 : int LA93_7 = input.LA(1);
				 int index93_7 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_7);
				 if ( s>=0 ) return s;
				 break;
				 case 7 : int LA93_8 = input.LA(1);
				 int index93_8 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_8);
				 if ( s>=0 ) return s;
				 break;
				 case 8 : int LA93_9 = input.LA(1);
				 int index93_9 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_9);
				 if ( s>=0 ) return s;
				 break;
				 case 9 : int LA93_10 = input.LA(1);
				 int index93_10 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_10);
				 if ( s>=0 ) return s;
				 break;
				 case 10 : int LA93_11 = input.LA(1);
				 int index93_11 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_11);
				 if ( s>=0 ) return s;
				 break;
				 case 11 : int LA93_12 = input.LA(1);
				 int index93_12 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_12);
				 if ( s>=0 ) return s;
				 break;
				 case 12 : int LA93_13 = input.LA(1);
				 int index93_13 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_13);
				 if ( s>=0 ) return s;
				 break;
				 case 13 : int LA93_14 = input.LA(1);
				 int index93_14 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_14);
				 if ( s>=0 ) return s;
				 break;
				 case 14 : int LA93_15 = input.LA(1);
				 int index93_15 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_15);
				 if ( s>=0 ) return s;
				 break;
				 case 15 : int LA93_16 = input.LA(1);
				 int index93_16 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_16);
				 if ( s>=0 ) return s;
				 break;
				 case 16 : int LA93_17 = input.LA(1);
				 int index93_17 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_17);
				 if ( s>=0 ) return s;
				 break;
				 case 17 : int LA93_18 = input.LA(1);
				 int index93_18 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_18);
				 if ( s>=0 ) return s;
				 break;
				 case 18 : int LA93_19 = input.LA(1);
				 int index93_19 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_19);
				 if ( s>=0 ) return s;
				 break;
				 case 19 : int LA93_20 = input.LA(1);
				 int index93_20 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_20);
				 if ( s>=0 ) return s;
				 break;
				 case 20 : int LA93_21 = input.LA(1);
				 int index93_21 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_21);
				 if ( s>=0 ) return s;
				 break;
				 case 21 : int LA93_22 = input.LA(1);
				 int index93_22 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_22);
				 if ( s>=0 ) return s;
				 break;
				 case 22 : int LA93_23 = input.LA(1);
				 int index93_23 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_23);
				 if ( s>=0 ) return s;
				 break;
				 case 23 : int LA93_24 = input.LA(1);
				 int index93_24 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_24);
				 if ( s>=0 ) return s;
				 break;
				 case 24 : int LA93_25 = input.LA(1);
				 int index93_25 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_25);
				 if ( s>=0 ) return s;
				 break;
				 case 25 : int LA93_26 = input.LA(1);
				 int index93_26 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_26);
				 if ( s>=0 ) return s;
				 break;
				 case 26 : int LA93_27 = input.LA(1);
				 int index93_27 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_27);
				 if ( s>=0 ) return s;
				 break;
				 case 27 : int LA93_28 = input.LA(1);
				 int index93_28 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_28);
				 if ( s>=0 ) return s;
				 break;
				 case 28 : int LA93_29 = input.LA(1);
				 int index93_29 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_29);
				 if ( s>=0 ) return s;
				 break;
				 case 29 : int LA93_30 = input.LA(1);
				 int index93_30 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_30);
				 if ( s>=0 ) return s;
				 break;
				 case 30 : int LA93_31 = input.LA(1);
				 int index93_31 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_31);
				 if ( s>=0 ) return s;
				 break;
				 case 31 : int LA93_32 = input.LA(1);
				 int index93_32 = input.index();
				 input.rewind();
				 s = -1;
				 if ( (synpred37_InternalEntities()) ) {
					s = 77;
				}
				 else if ( (true) ) {
					s = 33;
				}
				 input.seek(index93_32);
				 if ( s>=0 ) return s;
				 break;
			 }
			 if (state.backtracking>0) {
				state.failed=true;
				 return -1;
			}
			 NoViableAltException nvae = new NoViableAltException(getDescription(), 93, _s, input);
			 error(nvae);
			 throw nvae;
		 }
	 }",0,0,0,0
"public abstract class ProjectComponent implements Cloneable {
	 protected Project project;
	 protected Location location = Location.UNKNOWN_LOCATION;
	 protected String description;
	 public ProjectComponent() {
	 }
	 public void setProject(Project project) {
		 this.project = project;
	 }
	 public Project getProject() {
		 return project;
	 }
	 public Location getLocation() {
		 return location;
	 }
	 public void setLocation(Location location) {
		 this.location = location;
	 }
	 public void setDescription(String desc) {
		 description = desc;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public void log(String msg) {
		 log(msg, Project.MSG_INFO);
	 }
	 public void log(String msg, int msgLevel) {
		 if (getProject() != null) {
			 getProject().log(msg, msgLevel);
		 }
		 else {
			 if (msgLevel <= Project.MSG_INFO) {
				 System.err.println(msg);
			 }
		 }
	 }
	 public Object clone() throws CloneNotSupportedException {
		 ProjectComponent pc = (ProjectComponent) super.clone();
		 pc.setLocation(getLocation());
		 pc.setProject(getProject());
		 return pc;
	 }
}",0,0,0,0
"public DirectWriteRolloverStrategy build() {
	 int maxIndex = Integer.MAX_VALUE;
	 if (maxFiles != null) {
		 maxIndex = Integer.parseInt(maxFiles);
		 if (maxIndex < 0) {
			 maxIndex = Integer.MAX_VALUE;
		 }
		 else if (maxIndex < 2) {
			 LOGGER.error(""Maximum files too small. Limited to "" + DEFAULT_MAX_FILES);
			 maxIndex = DEFAULT_MAX_FILES;
		 }
	 }
	 final int compressionLevel = Integers.parseInt(compressionLevelStr, Deflater.DEFAULT_COMPRESSION);
	 return new DirectWriteRolloverStrategy(maxIndex, compressionLevel, config.getStrSubstitutor(), customActions, stopCustomActionsOnError, tempCompressedFilePattern);
 }",0,0,1,0
"public class MetricNames {
	 public static final String METRICS_REPORTER_ID_PROP = FluoConfiguration.FLUO_PREFIX + "".metrics.reporter.id"";
	 public static final String CLASS_PREFIX = FluoConfiguration.FLUO_PREFIX + "".class"";
	 public static final String SYSTEM_PREFIX = FluoConfiguration.FLUO_PREFIX + "".system"";
	 public static final String APPLICATION_PREFIX = FluoConfiguration.FLUO_PREFIX + "".app"";
	 private final String txLockWaitTime;
	 private final String txExecTime;
	 private final String txWithCollision;
	 private final String txCollisions;
	 private final String txEntriesSet;
	 private final String txEntriesRead;
	 private final String txLocksTimedOut;
	 private final String txLocksDead;
	 private final String txStatusPrefix;
	 private final String txCommitting;
	 private final String notificationsQueued;
	 private final String oracleResponseTime;
	 private final String oracleClientStamps;
	 private final String oracleServerStamps;
	 public MetricNames(String metricsReporterId, String appName) {
		 Preconditions.checkArgument(!appName.contains("".""), ""Fluo App name should not contain '.': "" + appName);
		 Preconditions.checkArgument(!metricsReporterId.contains("".""), ""Metrics Reporter ID should not contain '.': "" + metricsReporterId);
		 final String classMetric = CLASS_PREFIX + ""."" + appName + ""."" + metricsReporterId + ""."";
		 txLockWaitTime = classMetric + ""tx_lock_wait_time"";
		 txExecTime = classMetric + ""tx_execution_time"";
		 txWithCollision = classMetric + ""tx_with_collision"";
		 txCollisions = classMetric + ""tx_collisions"";
		 txEntriesSet = classMetric + ""tx_entries_set"";
		 txEntriesRead = classMetric + ""tx_entries_read"";
		 txLocksTimedOut = classMetric + ""tx_locks_timedout"";
		 txLocksDead = classMetric + ""tx_locks_dead"";
		 txStatusPrefix = classMetric + ""tx_status_"";
		 final String systemMetric = SYSTEM_PREFIX + ""."" + appName + ""."" + metricsReporterId + ""."";
		 txCommitting = systemMetric + ""transactor_committing"";
		 notificationsQueued = systemMetric + ""worker_notifications_queued"";
		 oracleResponseTime = systemMetric + ""oracle_response_time"";
		 oracleClientStamps = systemMetric + ""oracle_client_stamps"";
		 oracleServerStamps = systemMetric + ""oracle_server_stamps"";
	 }
	 public String getTxLockWaitTime(String className) {
		 return txLockWaitTime + ""."" + className;
	 }
	 public String getTxExecTime(String className) {
		 return txExecTime + ""."" + className;
	 }
	 public String getTxWithCollision(String className) {
		 return txWithCollision + ""."" + className;
	 }
	 public String getTxCollisions(String className) {
		 return txCollisions + ""."" + className;
	 }
	 public String getTxEntriesSet(String className) {
		 return txEntriesSet + ""."" + className;
	 }
	 public String getTxEntriesRead(String className) {
		 return txEntriesRead + ""."" + className;
	 }
	 public String getTxLocksTimedout(String className) {
		 return txLocksTimedOut + ""."" + className;
	 }
	 public String getTxLocksDead(String className) {
		 return txLocksDead + ""."" + className;
	 }
	 public String getTxStatus(String status, String className) {
		 return txStatusPrefix + status + ""."" + className;
	 }
	 public String getNotificationQueued() {
		 return notificationsQueued;
	 }
	 public String getOracleResponseTime() {
		 return oracleResponseTime;
	 }
	 public String getOracleClientStamps() {
		 return oracleClientStamps;
	 }
	 public String getOracleServerStamps() {
		 return oracleServerStamps;
	 }
	 public String getCommitsProcessing() {
		 return txCommitting;
	 }
}",0,0,0,0
"public class OutboundTcpConnection extends Thread{
	 private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);
	 private static final Message CLOSE_SENTINEL = new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.INTERNAL_RESPONSE, ArrayUtils.EMPTY_BYTE_ARRAY, MessagingService.version_);
	 private static final int OPEN_RETRY_DELAY = 100;
	 private volatile BlockingQueue<Entry> backlog = new LinkedBlockingQueue<Entry>();
	 private volatile BlockingQueue<Entry> active = new LinkedBlockingQueue<Entry>();
	 private final OutboundTcpConnectionPool poolReference;
	 private DataOutputStream out;
	 private Socket socket;
	 private volatile long completed;
	 private final AtomicLong dropped = new AtomicLong();
	 public OutboundTcpConnection(OutboundTcpConnectionPool pool) {
		 super(""WRITE-"" + pool.endPoint());
		 this.poolReference = pool;
	 }
	 public void enqueue(Message message, String id) {
		 expireMessages();
		 try {
			 backlog.put(new Entry(message, id, System.currentTimeMillis()));
		 }
		 catch (InterruptedException e) {
			 throw new AssertionError(e);
		 }
	 }
	 void closeSocket() {
		 active.clear();
		 backlog.clear();
		 enqueue(CLOSE_SENTINEL, null);
	 }
	 void softCloseSocket() {
		 enqueue(CLOSE_SENTINEL, null);
	 }
	 public void run() {
		 while (true) {
			 Entry entry = active.poll();
			 if (entry == null) {
				 try {
					 entry = backlog.take();
				 }
				 catch (InterruptedException e) {
					 throw new AssertionError(e);
				 }
				 BlockingQueue<Entry> tmp = backlog;
				 backlog = active;
				 active = tmp;
			 }
			 Message m = entry.message;
			 String id = entry.id;
			 if (m == CLOSE_SENTINEL) {
				 disconnect();
				 continue;
			 }
			 if (entry.timestamp < System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout()) dropped.incrementAndGet();
			 else if (socket != null || connect()) writeConnected(m, id);
			 else active.clear();
		 }
	 }
	 public int getPendingMessages() {
		 return active.size() + backlog.size();
	 }
	 public long getCompletedMesssages() {
		 return completed;
	 }
	 public long getDroppedMessages() {
		 return dropped.get();
	 }
	 private void writeConnected(Message message, String id) {
		 try {
			 write(message, id, out);
			 completed++;
			 if (active.peek() == null) {
				 out.flush();
			 }
		 }
		 catch (Exception e) {
			 if (!(e instanceof IOException)) logger.error(""error writing to "" + poolReference.endPoint(), e);
			 else if (logger.isDebugEnabled()) logger.debug(""error writing to "" + poolReference.endPoint(), e);
			 disconnect();
		 }
	 }
	 public static void write(Message message, String id, DataOutputStream out) throws IOException {
		 int header = 0;
		 header |= MessagingService.serializerType_.ordinal();
		 if (false) header |= 4;
		 header |= (message.getVersion() << 8);
		 out.writeInt(MessagingService.PROTOCOL_MAGIC);
		 out.writeInt(header);
		 byte[] bytes = message.getMessageBody();
		 int total = messageLength(message.header_, id, bytes);
		 out.writeInt(total);
		 out.writeUTF(id);
		 Header.serializer().serialize(message.header_, out, message.getVersion());
		 out.writeInt(bytes.length);
		 out.write(bytes);
	 }
	 public static int messageLength(Header header, String id, byte[] bytes) {
		 return 2 + FBUtilities.encodedUTF8Length(id) + header.serializedSize() + 4 + bytes.length;
	 }
	 private void disconnect() {
		 if (socket != null) {
			 try {
				 socket.close();
			 }
			 catch (IOException e) {
				 if (logger.isDebugEnabled()) logger.debug(""exception closing connection to "" + poolReference.endPoint(), e);
			 }
			 out = null;
			 socket = null;
		 }
	 }
	 private boolean connect() {
		 if (logger.isDebugEnabled()) logger.debug(""attempting to connect to "" + poolReference.endPoint());
		 long start = System.currentTimeMillis();
		 while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout()) {
			 try {
				 socket = poolReference.newSocket();
				 socket.setKeepAlive(true);
				 socket.setTcpNoDelay(true);
				 out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));
				 return true;
			 }
			 catch (IOException e) {
				 socket = null;
				 if (logger.isTraceEnabled()) logger.trace(""unable to connect to "" + poolReference.endPoint(), e);
				 try {
					 Thread.sleep(OPEN_RETRY_DELAY);
				 }
				 catch (InterruptedException e1) {
					 throw new AssertionError(e1);
				 }
			 }
		 }
		 return false;
	 }
	 private void expireMessages() {
		 while (true) {
			 Entry entry = backlog.peek();
			 if (entry == null || entry.timestamp >= System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout()) break;
			 Entry entry2 = backlog.poll();
			 if (entry2 != entry) {
				 if (entry2 != null) active.add(entry2);
				 break;
			 }
			 dropped.incrementAndGet();
		 }
	 }
	 private static class Entry {
		 final Message message;
		 final String id;
		 final long timestamp;
		 Entry(Message message, String id, long timestamp) {
			 this.message = message;
			 this.id = id;
			 this.timestamp = timestamp;
		 }
	 }
}",0,0,0,0
"public class JobStatusChangedEvent implements HistoryEvent {
	 private JobStatusChanged datum = new JobStatusChanged();
	 public JobStatusChangedEvent(JobID id, String jobStatus) {
		 datum.jobid = new Utf8(id.toString());
		 datum.jobStatus = new Utf8(jobStatus);
	 }
	 JobStatusChangedEvent() {
	}
	 public Object getDatum() {
		 return datum;
	 }
	 public void setDatum(Object datum) {
		 this.datum = (JobStatusChanged)datum;
	 }
	 public JobID getJobId() {
		 return JobID.forName(datum.jobid.toString());
	 }
	 public String getStatus() {
		 return datum.jobStatus.toString();
	 }
	 public EventType getEventType() {
		 return EventType.JOB_STATUS_CHANGED;
	 }
}",0,1,0,0
"private boolean initOrUpdateSegments() {
	try {
		F4MManifest mf = new F4MManifest(metadata.getUrl(),new File(folder, manifestSegment.getId()).getAbsolutePath());
		mf.setSelectedBitRate(metadata.getBitRate());
		this.totalDuration = mf.getDuration();
		Logger.log(""Total duration "" + totalDuration);
		ArrayList<String> urls = mf.getMediaUrls();
		if (urls.size() < 1) {
			Logger.log(""Manifest contains no media"");
			return false;
		}
		if (urlList.size() > 0 && urlList.size() != urls.size()) {
			Logger.log(""Manifest media count mismatch- expected: "" + urlList.size() + "" got: "" + urls.size());
			return false;
		}
		if (urlList.size() > 0) {
			urlList.clear();
		}
		urlList.addAll(urls);
		String newExtension = null;
		if (chunks.size() < 1) {
			for (int i = 0;
			 i < urlList.size();
			 i++) {
				if (newExtension == null && outputFormat == 0) {
					newExtension = findExtension(urlList.get(i));
					Logger.log(""HDS: found new extension: "" + newExtension);
					if (newExtension != null) {
						this.newFileName = getOutputFileName(false).replace("".flv"", newExtension);
					}
					 else {
						newExtension = "".flv"";
					}
				}
				Logger.log(""HDS: Newfile name: "" + this.newFileName);
				Segment s2 = new SegmentImpl(this, folder);
				s2.setTag(""HLS"");
				s2.setLength(-1);
				Logger.log(""Adding chunk: "" + s2);
				chunks.add(s2);
			}
		}
		return true;
	}
	 catch (Exception e) {
		Logger.log(e);
		return false;
	}
}",0,0,1,0
"public class Scp extends SSHBase {
	 private static final String[] FROM_ATTRS = {
	 ""file"", ""localfile"", ""remotefile"" }
	;
	 private static final String[] TO_ATTRS = {
	 ""todir"", ""localtodir"", ""remotetodir"", ""localtofile"", ""remotetofile"" }
	;
	 private String fromUri;
	 private String toUri;
	 private boolean preserveLastModified = false;
	 private List fileSets = null;
	 private boolean isFromRemote, isToRemote;
	 private boolean isSftp = false;
	 public void setFile(String aFromUri) {
		 setFromUri(aFromUri);
		 this.isFromRemote = isRemoteUri(this.fromUri);
	 }
	 public void setTodir(String aToUri) {
		 setToUri(aToUri);
		 this.isToRemote = isRemoteUri(this.toUri);
	 }
	 public void setLocalFile(String aFromUri) {
		 setFromUri(aFromUri);
		 this.isFromRemote = false;
	 }
	 public void setRemoteFile(String aFromUri) {
		 validateRemoteUri(""remoteFile"", aFromUri);
		 setFromUri(aFromUri);
		 this.isFromRemote = true;
	 }
	 public void setLocalTodir(String aToUri) {
		 setToUri(aToUri);
		 this.isToRemote = false;
	 }
	 public void setPreservelastmodified(boolean yesOrNo) {
		 this.preserveLastModified = yesOrNo;
	 }
	 public void setRemoteTodir(String aToUri) {
		 validateRemoteUri(""remoteToDir"", aToUri);
		 setToUri(aToUri);
		 this.isToRemote = true;
	 }
	 private static void validateRemoteUri(String type, String aToUri) {
		 if (!isRemoteUri(aToUri)) {
			 throw new BuildException(type + "" '"" + aToUri + ""' is invalid. "" + ""The 'remoteToDir' attribute must "" + ""have syntax like the "" + ""following: user:password:/path"" + "" - the :password part is optional"");
		 }
	 }
	 public void setLocalTofile(String aToUri) {
		 setToUri(aToUri);
		 this.isToRemote = false;
	 }
	 public void setRemoteTofile(String aToUri) {
		 validateRemoteUri(""remoteToFile"", aToUri);
		 setToUri(aToUri);
		 this.isToRemote = true;
	 }
	 public void setSftp(boolean yesOrNo) {
		 isSftp = yesOrNo;
	 }
	 public void addFileset(FileSet set) {
		 if (fileSets == null) {
			 fileSets = new LinkedList();
		 }
		 fileSets.add(set);
	 }
	 public void init() throws BuildException {
		 super.init();
		 this.toUri = null;
		 this.fromUri = null;
		 this.fileSets = null;
	 }
	 public void execute() throws BuildException {
		 if (toUri == null) {
			 throw exactlyOne(TO_ATTRS);
		 }
		 if (fromUri == null && fileSets == null) {
			 throw exactlyOne(FROM_ATTRS, ""one or more nested filesets"");
		 }
		 try {
			 if (isFromRemote && !isToRemote) {
				 download(fromUri, toUri);
			 }
			 else if (!isFromRemote && isToRemote) {
				 if (fileSets != null) {
					 upload(fileSets, toUri);
				 }
				 else {
					 upload(fromUri, toUri);
				 }
			 }
			 else if (isFromRemote && isToRemote) {
				 throw new BuildException( ""Copying from a remote server to a remote server is not supported."");
			 }
			 else {
				 throw new BuildException(""'todir' and 'file' attributes "" + ""must have syntax like the following: "" + ""user:password:/path"");
			 }
		 }
		 catch (Exception e) {
			 if (getFailonerror()) {
				 if(e instanceof BuildException) {
					 BuildException be = (BuildException) e;
					 if(be.getLocation() == null) {
						 be.setLocation(getLocation());
					 }
					 throw be;
				 }
				 else {
					 throw new BuildException(e);
				 }
			 }
			 else {
				 log(""Caught exception: "" + e.getMessage(), Project.MSG_ERR);
			 }
		 }
	 }
	 private void download(String fromSshUri, String toPath) throws JSchException, IOException {
		 String file = parseUri(fromSshUri);
		 Session session = null;
		 try {
			 session = openSession();
			 ScpFromMessage message = null;
			 if (!isSftp) {
				 message = new ScpFromMessage(getVerbose(), session, file, getProject().resolveFile(toPath), fromSshUri.endsWith(""*""), preserveLastModified);
			 }
			 else {
				 message = new ScpFromMessageBySftp(getVerbose(), session, file, getProject().resolveFile(toPath), fromSshUri.endsWith(""*""), preserveLastModified);
			 }
			 log(""Receiving file: "" + file);
			 message.setLogListener(this);
			 message.execute();
		 }
		 finally {
			 if (session != null) {
				 session.disconnect();
			 }
		 }
	 }
	 private void upload(List fileSet, String toSshUri) throws IOException, JSchException {
		 String file = parseUri(toSshUri);
		 Session session = null;
		 try {
			 List list = new ArrayList(fileSet.size());
			 for (Iterator i = fileSet.iterator();
			 i.hasNext();
			) {
				 FileSet set = (FileSet) i.next();
				 Directory d = createDirectory(set);
				 if (d != null) {
					 list.add(d);
				 }
			 }
			 if (!list.isEmpty()) {
				 session = openSession();
				 ScpToMessage message = null;
				 if (!isSftp) {
					 message = new ScpToMessage(getVerbose(), session, list, file);
				 }
				 else {
					 message = new ScpToMessageBySftp(getVerbose(), session, list, file);
				 }
				 message.setLogListener(this);
				 message.execute();
			 }
		 }
		 finally {
			 if (session != null) {
				 session.disconnect();
			 }
		 }
	 }
	 private void upload(String fromPath, String toSshUri) throws IOException, JSchException {
		 String file = parseUri(toSshUri);
		 Session session = null;
		 try {
			 session = openSession();
			 ScpToMessage message = null;
			 if (!isSftp) {
				 message = new ScpToMessage(getVerbose(), session, getProject().resolveFile(fromPath), file);
			 }
			 else {
				 message = new ScpToMessageBySftp(getVerbose(), session, getProject().resolveFile(fromPath), file);
			 }
			 message.setLogListener(this);
			 message.execute();
		 }
		 finally {
			 if (session != null) {
				 session.disconnect();
			 }
		 }
	 }
	 private String parseUri(String uri) {
		 int indexOfAt = uri.indexOf('@');
		 int indexOfColon = uri.indexOf(':');
		 if (indexOfColon > -1 && indexOfColon < indexOfAt) {
			 int indexOfCurrentAt = indexOfAt;
			 int indexOfLastColon = uri.lastIndexOf(':');
			 while (indexOfCurrentAt > -1 && indexOfCurrentAt < indexOfLastColon) {
				 indexOfAt = indexOfCurrentAt;
				 indexOfCurrentAt = uri.indexOf('@', indexOfCurrentAt + 1);
			 }
			 setUsername(uri.substring(0, indexOfColon));
			 setPassword(uri.substring(indexOfColon + 1, indexOfAt));
		 }
		 else if (indexOfAt > -1) {
			 setUsername(uri.substring(0, indexOfAt));
		 }
		 else {
			 throw new BuildException(""no username was given. Can't authenticate."");
		 }
		 if (getUserInfo().getPassword() == null && getUserInfo().getKeyfile() == null) {
			 throw new BuildException(""neither password nor keyfile for user "" + getUserInfo().getName() + "" has been "" + ""given. Can't authenticate."");
		 }
		 int indexOfPath = uri.indexOf(':', indexOfAt + 1);
		 if (indexOfPath == -1) {
			 throw new BuildException(""no remote path in "" + uri);
		 }
		 setHost(uri.substring(indexOfAt + 1, indexOfPath));
		 String remotePath = uri.substring(indexOfPath + 1);
		 if (remotePath.equals("""")) {
			 remotePath = ""."";
		 }
		 return remotePath;
	 }
	 private static boolean isRemoteUri(String uri) {
		 boolean isRemote = true;
		 int indexOfAt = uri.indexOf('@');
		 if (indexOfAt < 0) {
			 isRemote = false;
		 }
		 return isRemote;
	 }
	 private Directory createDirectory(FileSet set) {
		 DirectoryScanner scanner = set.getDirectoryScanner(getProject());
		 Directory root = new Directory(scanner.getBasedir());
		 String[] files = scanner.getIncludedFiles();
		 if (files.length != 0) {
			 for (int j = 0;
			 j < files.length;
			 j++) {
				 String[] path = Directory.getPath(files[j]);
				 Directory current = root;
				 File currentParent = scanner.getBasedir();
				 for (int i = 0;
				 i < path.length;
				 i++) {
					 File file = new File(currentParent, path[i]);
					 if (file.isDirectory()) {
						 current.addDirectory(new Directory(file));
						 current = current.getChild(file);
						 currentParent = current.getDirectory();
					 }
					 else if (file.isFile()) {
						 current.addFile(file);
					 }
				 }
			 }
		 }
		 else {
			 root = null;
		 }
		 return root;
	 }
	 private void setFromUri(String fromUri) {
		 if (this.fromUri != null) {
			 throw exactlyOne(FROM_ATTRS);
		 }
		 this.fromUri = fromUri;
	 }
	 private void setToUri(String toUri) {
		 if (this.toUri != null) {
			 throw exactlyOne(TO_ATTRS);
		 }
		 this.toUri = toUri;
	 }
	 private BuildException exactlyOne(String[] attrs) {
		 return exactlyOne(attrs, null);
	 }
	 private BuildException exactlyOne(String[] attrs, String alt) {
		 StringBuffer buf = new StringBuffer(""Exactly one of "").append( '[').append(attrs[0]);
		 for (int i = 1;
		 i < attrs.length;
		 i++) {
			 buf.append('|').append(attrs[i]);
		 }
		 buf.append(']');
		 if (alt != null) {
			 buf.append("" or "").append(alt);
		 }
		 return new BuildException(buf.append("" is required."").toString());
	 }
}",0,0,0,0
"public class Customer1208 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer1208() {
	}
	public Customer1208(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer1208[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,0,0,0
"public class First extends SizeLimitCollection {
	 protected Collection getCollection() {
		 int ct = getValidCount();
		 Iterator iter = getResourceCollection().iterator();
		 ArrayList al = new ArrayList(ct);
		 for (int i = 0;
		 i < ct && iter.hasNext();
		 i++) {
			 al.add(iter.next());
		 }
		 return al;
	 }
}",0,0,0,0
public void processPatterns(Hashtable keys);,0,0,0,0
"static class ComparerHolder {
	 static final String UNSAFE_COMPARER_NAME = ComparerHolder.class.getName() + ""$UnsafeComparer"";
	 static final Comparer BEST_COMPARER = getBestComparer();
	 static Comparer getBestComparer() {
		 try {
			 Class<?> theClass = Class.forName(UNSAFE_COMPARER_NAME);
			 Comparer comparer = (Comparer) theClass.getConstructor().newInstance();
			 return comparer;
		 }
		 catch (Throwable t) {
			 return PureJavaComparer.INSTANCE;
		 }
	 }
	 static final class PureJavaComparer extends Comparer {
		 static final PureJavaComparer INSTANCE = new PureJavaComparer();
		 private PureJavaComparer() {
		}
		 public int compareTo(byte [] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {
			 int end1 = o1 + l1;
			 int end2 = o2 + l2;
			 for (int i = o1, j = o2;
			 i < end1 && j < end2;
			 i++, j++) {
				 int a = buf1[i] & 0xFF;
				 int b = buf2.get(j) & 0xFF;
				 if (a != b) {
					 return a - b;
				 }
			 }
			 return l1 - l2;
		 }
		 public int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {
			 int end1 = o1 + l1;
			 int end2 = o2 + l2;
			 for (int i = o1, j = o2;
			 i < end1 && j < end2;
			 i++, j++) {
				 int a = buf1.get(i) & 0xFF;
				 int b = buf2.get(j) & 0xFF;
				 if (a != b) {
					 return a - b;
				 }
			 }
			 return l1 - l2;
		 }
	 }
	 static final class UnsafeComparer extends Comparer {
		 public UnsafeComparer() {
		}
		 static {
			 if(!UNSAFE_UNALIGNED) {
				 throw new Error();
			 }
		 }
		 public int compareTo(byte[] buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {
			 long offset2Adj;
			 Object refObj2 = null;
			 if (buf2.isDirect()) {
				 offset2Adj = o2 + ((DirectBuffer)buf2).address();
			 }
			 else {
				 offset2Adj = o2 + buf2.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;
				 refObj2 = buf2.array();
			 }
			 return compareToUnsafe(buf1, o1 + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET, l1, refObj2, offset2Adj, l2);
		 }
		 public int compareTo(ByteBuffer buf1, int o1, int l1, ByteBuffer buf2, int o2, int l2) {
			 long offset1Adj, offset2Adj;
			 Object refObj1 = null, refObj2 = null;
			 if (buf1.isDirect()) {
				 offset1Adj = o1 + ((DirectBuffer) buf1).address();
			 }
			 else {
				 offset1Adj = o1 + buf1.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;
				 refObj1 = buf1.array();
			 }
			 if (buf2.isDirect()) {
				 offset2Adj = o2 + ((DirectBuffer) buf2).address();
			 }
			 else {
				 offset2Adj = o2 + buf2.arrayOffset() + UnsafeAccess.BYTE_ARRAY_BASE_OFFSET;
				 refObj2 = buf2.array();
			 }
			 return compareToUnsafe(refObj1, offset1Adj, l1, refObj2, offset2Adj, l2);
		 }
	 }
 }",1,1,0,0
"public class ForeignKeyInfo implements Serializable {
	 public class ForeignKeyCol {
		 public String parentTableName;
		 public String parentDatabaseName;
		 public String parentColName;
		 public String childColName;
		 public Integer position;
		 public ForeignKeyCol(String parentTableName, String parentDatabaseName, String parentColName, String childColName, Integer position) {
			 this.parentTableName = parentTableName;
			 this.parentDatabaseName = parentDatabaseName;
			 this.parentColName = parentColName;
			 this.childColName = childColName;
			 this.position = position;
		 }
	 }
	 Map<String, List<ForeignKeyCol>> foreignKeys;
	 String childTableName;
	 String childDatabaseName;
	 public ForeignKeyInfo() {
	}
	 public ForeignKeyInfo(List<SQLForeignKey> fks, String childTableName, String childDatabaseName) {
		 this.childTableName = childTableName;
		 this.childDatabaseName = childDatabaseName;
		 foreignKeys = new TreeMap<String, List<ForeignKeyCol>>();
		 if (fks == null) {
			 return;
		 }
		 for (SQLForeignKey fk : fks) {
			 if (fk.getFktable_db().equalsIgnoreCase(childDatabaseName) && fk.getFktable_name().equalsIgnoreCase(childTableName)) {
				 ForeignKeyCol currCol = new ForeignKeyCol(fk.getPktable_name(), fk.getPktable_db(), fk.getPkcolumn_name(), fk.getFkcolumn_name(), fk.getKey_seq());
				 String constraintName = fk.getFk_name();
				 if (foreignKeys.containsKey(constraintName)) {
					 foreignKeys.get(constraintName).add(currCol);
				 }
				 else {
					 List<ForeignKeyCol> currList = new ArrayList<ForeignKeyCol>();
					 currList.add(currCol);
					 foreignKeys.put(constraintName, currList);
				 }
			 }
		 }
	 }
	 public String getChildTableName() {
		 return childTableName;
	 }
	 public String getChildDatabaseName() {
		 return childDatabaseName;
	 }
	 public Map<String, List<ForeignKeyCol>> getForeignKeys() {
		 return foreignKeys;
	 }
	 public void setChildTableName(String tableName) {
		 this.childTableName = tableName;
	 }
	 public void setChildDatabaseName(String databaseName) {
		 this.childDatabaseName = databaseName;
	 }
	 public void setForeignKeys(Map<String, List<ForeignKeyCol>> foreignKeys) {
		 this.foreignKeys = foreignKeys;
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 sb.append(""Foreign Keys for "" + childDatabaseName+"".""+childTableName+"":"");
		 sb.append(""["");
		 if (foreignKeys != null && foreignKeys.size() > 0) {
			 for (Map.Entry<String, List<ForeignKeyCol>> me : foreignKeys.entrySet()) {
				 sb.append("" {
					Constraint Name: "" + me.getKey() + "","");
					 List<ForeignKeyCol> currCol = me.getValue();
					 if (currCol != null && currCol.size() > 0) {
						 for (ForeignKeyCol fkc : currCol) {
							 sb.append ("" (Parent Column Name: "" + fkc.parentDatabaseName + "".""+ fkc.parentTableName + ""."" + fkc.parentColName + "", Column Name: "" + fkc.childColName + "", Key Sequence: "" + fkc.position+ ""),"");
						 }
						 sb.setLength(sb.length()-1);
					 }
				 sb.append(""}
				,"");
			 }
			 sb.setLength(sb.length()-1);
		 }
		 sb.append(""]"");
		 return sb.toString();
	 }
}",1,1,0,0
"private class DescendingIterator implements Iterator<E> {
	 private final ListItr itr = new ListItr(size());
	 public boolean hasNext() {
		 return itr.hasPrevious();
	 }
	 public E next() {
		 return itr.previous();
	 }
	 public void remove() {
		 itr.remove();
	 }
 }",0,0,0,0
"public void execute() throws BuildException {
	 File savedFile = file;
	 File savedDestFile = destFile;
	 File savedDestDir = destDir;
	 ResourceCollection savedRc = null;
	 if (file == null && destFile != null && rcs.size() == 1) {
		 savedRc = (ResourceCollection) rcs.elementAt(0);
	 }
	 validateAttributes();
	 try {
		 copySingleFile();
		 HashMap filesByBasedir = new HashMap();
		 HashMap dirsByBasedir = new HashMap();
		 HashSet baseDirs = new HashSet();
		 ArrayList nonFileResources = new ArrayList();
		 for (int i = 0;
		 i < rcs.size();
		 i++) {
			 ResourceCollection rc = (ResourceCollection) rcs.elementAt(i);
			 if (rc instanceof FileSet && rc.isFilesystemOnly()) {
				 FileSet fs = (FileSet) rc;
				 DirectoryScanner ds = null;
				 try {
					 ds = fs.getDirectoryScanner(getProject());
				 }
				 catch (BuildException e) {
					 if (failonerror || !getMessage(e).endsWith("" not found."")) {
						 throw e;
					 }
					 else {
						 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
						 continue;
					 }
				 }
				 File fromDir = fs.getDir(getProject());
				 String[] srcFiles = ds.getIncludedFiles();
				 String[] srcDirs = ds.getIncludedDirectories();
				 if (!flatten && mapperElement == null && ds.isEverythingIncluded() && !fs.hasPatterns()) {
					 completeDirMap.put(fromDir, destDir);
				 }
				 add(fromDir, srcFiles, filesByBasedir);
				 add(fromDir, srcDirs, dirsByBasedir);
				 baseDirs.add(fromDir);
			 }
			 else {
				 if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
					 throw new BuildException( ""Only FileSystem resources are supported."");
				 }
				 Iterator resources = rc.iterator();
				 while (resources.hasNext()) {
					 Resource r = (Resource) resources.next();
					 if (!r.isExists()) {
						 continue;
					 }
					 File baseDir = NULL_FILE_PLACEHOLDER;
					 String name = r.getName();
					 if (r instanceof FileResource) {
						 FileResource fr = (FileResource) r;
						 baseDir = getKeyFile(fr.getBaseDir());
						 if (fr.getBaseDir() == null) {
							 name = fr.getFile().getAbsolutePath();
						 }
					 }
					 if (r.isDirectory() || r instanceof FileResource) {
						 add(baseDir, name, r.isDirectory() ? dirsByBasedir : filesByBasedir);
						 baseDirs.add(baseDir);
					 }
					 else {
						 nonFileResources.add(r);
					 }
				 }
			 }
		 }
		 iterateOverBaseDirs(baseDirs, dirsByBasedir, filesByBasedir);
		 try {
			 doFileOperations();
		 }
		 catch (BuildException e) {
			 if (!failonerror) {
				 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
			 }
			 else {
				 throw e;
			 }
		 }
		 if (nonFileResources.size() > 0) {
			 Resource[] nonFiles = (Resource[]) nonFileResources.toArray(new Resource[nonFileResources.size()]);
			 Map map = scan(nonFiles, destDir);
			 try {
				 doResourceOperations(map);
			 }
			 catch (BuildException e) {
				 if (!failonerror) {
					 log(""Warning: "" + getMessage(e), Project.MSG_ERR);
				 }
				 else {
					 throw e;
				 }
			 }
		 }
	 }
	 finally {
		 file = savedFile;
		 destFile = savedDestFile;
		 destDir = savedDestDir;
		 if (savedRc != null) {
			 rcs.insertElementAt(savedRc, 0);
		 }
		 fileCopyMap.clear();
		 dirCopyMap.clear();
		 completeDirMap.clear();
	 }
 }",0,0,1,0
"public class Equals implements Condition {
	 private String arg1, arg2;
	 private boolean trim = false;
	 private boolean caseSensitive = true;
	 public void setArg1(String a1) {
		 arg1 = a1;
	 }
	 public void setArg2(String a2) {
		 arg2 = a2;
	 }
	 public void setTrim(boolean b) {
		 trim = b;
	 }
	 public void setCasesensitive(boolean b) {
		 caseSensitive = b;
	 }
	 public boolean eval() throws BuildException {
		 if (arg1 == null || arg2 == null) {
			 throw new BuildException(""both arg1 and arg2 are required in "" + ""equals"");
		 }
		 if (trim) {
			 arg1 = arg1.trim();
			 arg2 = arg2.trim();
		 }
		 return caseSensitive ? arg1.equals(arg2) : arg1.equalsIgnoreCase(arg2);
	 }
}",0,0,0,0
"public synchronized void mark(final int limit) {
	 try {
		 in.mark(limit);
	 }
	 catch (IOException ioe) {
		 throw new RuntimeException(ioe.getMessage());
	 }
 }",0,0,0,0
"public static void main(String args[]) throws Exception {
	 if (args.length == 0) {
		 usage();
		 return;
	 }
	 FileInputStream is = new FileInputStream(args[0]);
	 SlideShow ppt = new SlideShow(is);
	 is.close();
	 SoundData[] sound = ppt.getSoundData();
	 for (int i = 0;
	 i < sound.length;
	 i++) {
		 String type = sound[i].getSoundType();
		 String name = sound[i].getSoundName();
		 byte[] data = sound[i].getData();
		 FileOutputStream out = new FileOutputStream(name + type);
		 out.write(data);
		 out.close();
	 }
	 Slide[] slide = ppt.getSlides();
	 for (int i = 0;
	 i < slide.length;
	 i++) {
		 Shape[] shape = slide[i].getShapes();
		 for (int j = 0;
		 j < shape.length;
		 j++) {
			 if (shape[j] instanceof OLEShape) {
				 OLEShape ole = (OLEShape) shape[j];
				 ObjectData data = ole.getObjectData();
				 String name = ole.getInstanceName();
				 if (""Worksheet"".equals(name)) {
					 HSSFWorkbook wb = new HSSFWorkbook(data.getData());
				 }
				 else if (""Document"".equals(name)) {
					 HWPFDocument doc = new HWPFDocument(data.getData());
					 Range r = doc.getRange();
					 for(int k = 0;
					 k < r.numParagraphs();
					 k++) {
						 Paragraph p = r.getParagraph(k);
						 System.out.println(p.text());
					 }
					 FileOutputStream out = new FileOutputStream(name + ""-(""+(j)+"").doc"");
					 doc.write(out);
					 out.close();
				 }
				 else {
					 FileOutputStream out = new FileOutputStream(ole.getProgID() + ""-""+(j+1)+"".dat"");
					 InputStream dis = data.getData();
					 byte[] chunk = new byte[2048];
					 int count;
					 while ((count = dis.read(chunk)) >= 0) {
						 out.write(chunk,0,count);
					 }
					 is.close();
					 out.close();
				 }
			 }
		 }
	 }
	 for (int i = 0;
	 i < slide.length;
	 i++) {
		 Shape[] shape = slide[i].getShapes();
		 for (int j = 0;
		 j < shape.length;
		 j++) {
			 if (shape[j] instanceof Picture) {
				 Picture p = (Picture) shape[j];
				 PictureData data = p.getPictureData();
				 String name = p.getPictureName();
				 int type = data.getType();
				 String ext;
				 switch (type) {
					 case Picture.JPEG: ext = "".jpg"";
					 break;
					 case Picture.PNG: ext = "".png"";
					 break;
					 case Picture.WMF: ext = "".wmf"";
					 break;
					 case Picture.EMF: ext = "".emf"";
					 break;
					 case Picture.PICT: ext = "".pict"";
					 break;
					 case Picture.DIB: ext = "".dib"";
					 break;
					 default: continue;
				 }
				 FileOutputStream out = new FileOutputStream(""pict-"" + j + ext);
				 out.write(data.getData());
				 out.close();
			 }
		 }
	 }
 }",0,0,1,0
"public class Expression implements Cloneable {
	 public static final int LEFT = 0;
	 public static final int RIGHT = 1;
	 public static final int UNARY = 1;
	 public static final int BINARY = 2;
	 static final Expression[] emptyArray = new Expression[]{
	}
	;
	 static final Expression EXPR_TRUE = new ExpressionLogical(true);
	 static final Expression EXPR_FALSE = new ExpressionLogical(false);
	 static final OrderedIntHashSet aggregateFunctionSet = new OrderedIntHashSet();
	 static {
		 aggregateFunctionSet.add(OpTypes.COUNT);
		 aggregateFunctionSet.add(OpTypes.SUM);
		 aggregateFunctionSet.add(OpTypes.MIN);
		 aggregateFunctionSet.add(OpTypes.MAX);
		 aggregateFunctionSet.add(OpTypes.AVG);
		 aggregateFunctionSet.add(OpTypes.EVERY);
		 aggregateFunctionSet.add(OpTypes.SOME);
		 aggregateFunctionSet.add(OpTypes.STDDEV_POP);
		 aggregateFunctionSet.add(OpTypes.STDDEV_SAMP);
		 aggregateFunctionSet.add(OpTypes.VAR_POP);
		 aggregateFunctionSet.add(OpTypes.VAR_SAMP);
		 aggregateFunctionSet.add(OpTypes.USER_AGGREGATE);
	 }
	 static final OrderedIntHashSet columnExpressionSet = new OrderedIntHashSet();
	 static {
		 columnExpressionSet.add(OpTypes.COLUMN);
	 }
	 static final OrderedIntHashSet subqueryExpressionSet = new OrderedIntHashSet();
	 static {
		 subqueryExpressionSet.add(OpTypes.ROW_SUBQUERY);
		 subqueryExpressionSet.add(OpTypes.TABLE_SUBQUERY);
	 }
	 static final OrderedIntHashSet subqueryAggregateExpressionSet = new OrderedIntHashSet();
	 static {
		 subqueryAggregateExpressionSet.add(OpTypes.COUNT);
		 subqueryAggregateExpressionSet.add(OpTypes.SUM);
		 subqueryAggregateExpressionSet.add(OpTypes.MIN);
		 subqueryAggregateExpressionSet.add(OpTypes.MAX);
		 subqueryAggregateExpressionSet.add(OpTypes.AVG);
		 subqueryAggregateExpressionSet.add(OpTypes.EVERY);
		 subqueryAggregateExpressionSet.add(OpTypes.SOME);
		 subqueryAggregateExpressionSet.add(OpTypes.STDDEV_POP);
		 subqueryAggregateExpressionSet.add(OpTypes.STDDEV_SAMP);
		 subqueryAggregateExpressionSet.add(OpTypes.VAR_POP);
		 subqueryAggregateExpressionSet.add(OpTypes.VAR_SAMP);
		 subqueryAggregateExpressionSet.add(OpTypes.USER_AGGREGATE);
		 subqueryAggregateExpressionSet.add(OpTypes.TABLE_SUBQUERY);
		 subqueryAggregateExpressionSet.add(OpTypes.ROW_SUBQUERY);
	 }
	 static final OrderedIntHashSet functionExpressionSet = new OrderedIntHashSet();
	 static {
		 functionExpressionSet.add(OpTypes.SQL_FUNCTION);
		 functionExpressionSet.add(OpTypes.FUNCTION);
	 }
	 static final OrderedIntHashSet emptyExpressionSet = new OrderedIntHashSet();
	 protected int opType;
	 protected int exprSubType;
	 SimpleName alias;
	 private boolean isAggregate;
	 protected Object valueData;
	 protected Expression[] nodes;
	 Type[] nodeDataTypes;
	 SubQuery subQuery;
	 boolean isCorrelated;
	 int columnIndex = -1;
	 protected Type dataType;
	 int queryTableColumnIndex = -1;
	 int parameterIndex = -1;
	 int rangePosition = -1;
	 boolean isColumnEqual;
	 Expression(int type) {
		 opType = type;
		 nodes = emptyArray;
	 }
	 Expression(int type, SubQuery sq) {
		 switch (type) {
			 case OpTypes.ARRAY : opType = OpTypes.ARRAY;
			 break;
			 case OpTypes.ARRAY_SUBQUERY : opType = OpTypes.ARRAY_SUBQUERY;
			 break;
			 case OpTypes.TABLE_SUBQUERY : opType = OpTypes.TABLE_SUBQUERY;
			 break;
			 case OpTypes.ROW_SUBQUERY : case OpTypes.SCALAR_SUBQUERY : opType = OpTypes.ROW_SUBQUERY;
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
		 }
		 nodes = emptyArray;
		 subQuery = sq;
	 }
	 Expression(int type, Expression[] list) {
		 this(type);
		 this.nodes = list;
	 }
	 static String getContextSQL(Expression expression) {
		 if (expression == null) {
			 return null;
		 }
		 String ddl = expression.getSQL();
		 switch (expression.opType) {
			 case OpTypes.VALUE : case OpTypes.COLUMN : case OpTypes.ROW : case OpTypes.FUNCTION : case OpTypes.SQL_FUNCTION : case OpTypes.ALTERNATIVE : case OpTypes.CASEWHEN : case OpTypes.CAST : return ddl;
		 }
		 StringBuffer sb = new StringBuffer();
		 ddl = sb.append('(').append(ddl).append(')').toString();
		 return ddl;
	 }
	 public String getSQL() {
		 StringBuffer sb = new StringBuffer(64);
		 switch (opType) {
			 case OpTypes.VALUE : if (valueData == null) {
				 return Tokens.T_NULL;
			 }
			 return dataType.convertToSQLString(valueData);
			 case OpTypes.ROW : sb.append('(');
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (i > 0) {
					 sb.append(',');
				 }
				 sb.append(nodes[i].getSQL());
			 }
			 sb.append(')');
			 return sb.toString();
			 case OpTypes.TABLE : for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (i > 0) {
					 sb.append(',');
				 }
				 sb.append(nodes[i].getSQL());
			 }
			 return sb.toString();
		 }
		 switch (opType) {
			 case OpTypes.ARRAY : sb.append(Tokens.T_ARRAY).append('[');
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (i > 0) {
					 sb.append(',');
				 }
				 sb.append(nodes[i].getSQL());
			 }
			 sb.append(']');
			 break;
			 case OpTypes.ARRAY_SUBQUERY : case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : sb.append('(');
			 sb.append(')');
			 break;
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
		 }
		 return sb.toString();
	 }
	 protected String describe(Session session, int blanks) {
		 StringBuffer sb = new StringBuffer(64);
		 sb.append('\n');
		 for (int i = 0;
		 i < blanks;
		 i++) {
			 sb.append(' ');
		 }
		 switch (opType) {
			 case OpTypes.VALUE : sb.append(""VALUE = "").append(valueData);
			 sb.append("", TYPE = "").append(dataType.getNameString());
			 return sb.toString();
			 case OpTypes.ARRAY : sb.append(""ARRAY "");
			 return sb.toString();
			 case OpTypes.ARRAY_SUBQUERY : sb.append(""ARRAY SUBQUERY"");
			 return sb.toString();
			 case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : sb.append(""QUERY "");
			 sb.append(subQuery.queryExpression.describe(session, blanks));
			 return sb.toString();
			 case OpTypes.ROW : sb.append(""ROW = "");
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 sb.append(nodes[i].describe(session, blanks + 1));
				 sb.append(' ');
			 }
			 break;
			 case OpTypes.TABLE : sb.append(""VALUELIST "");
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 sb.append(nodes[i].describe(session, blanks + 1));
				 sb.append(' ');
			 }
			 break;
		 }
		 return sb.toString();
	 }
	 void setDataType(Session session, Type type) {
		 if (opType == OpTypes.VALUE) {
			 valueData = type.convertToType(session, valueData, dataType);
		 }
		 dataType = type;
	 }
	 public boolean equals(Expression other) {
		 if (other == this) {
			 return true;
		 }
		 if (other == null) {
			 return false;
		 }
		 if (opType != other.opType || exprSubType != other.exprSubType || !equals(dataType, other.dataType)) {
			 return false;
		 }
		 switch (opType) {
			 case OpTypes.SIMPLE_COLUMN : return this.columnIndex == other.columnIndex;
			 case OpTypes.VALUE : return equals(valueData, other.valueData);
			 case OpTypes.ARRAY : case OpTypes.ARRAY_SUBQUERY : case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : return (subQuery.queryExpression.isEquivalent( other.subQuery.queryExpression));
			 default : return equals(nodes, other.nodes) && equals(subQuery, other.subQuery);
		 }
	 }
	 public boolean equals(Object other) {
		 if (other == this) {
			 return true;
		 }
		 if (other instanceof Expression) {
			 return equals((Expression) other);
		 }
		 return false;
	 }
	 public int hashCode() {
		 int val = opType + exprSubType;
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 val += nodes[i].hashCode();
			 }
		 }
		 return val;
	 }
	 static boolean equals(Object o1, Object o2) {
		 if (o1 == o2) {
			 return true;
		 }
		 return (o1 == null) ? o2 == null : o1.equals(o2);
	 }
	 static boolean equals(Expression[] row1, Expression[] row2) {
		 if (row1 == row2) {
			 return true;
		 }
		 if (row1.length != row2.length) {
			 return false;
		 }
		 int len = row1.length;
		 for (int i = 0;
		 i < len;
		 i++) {
			 Expression e1 = row1[i];
			 Expression e2 = row2[i];
			 boolean equals = (e1 == null) ? e2 == null : e1.equals(e2);
			 if (!equals) {
				 return false;
			 }
		 }
		 return true;
	 }
	 boolean isComposedOf(Expression exprList[], int start, int end, OrderedIntHashSet excludeSet) {
		 if (opType == OpTypes.VALUE) {
			 return true;
		 }
		 if (excludeSet.contains(opType)) {
			 return true;
		 }
		 for (int i = start;
		 i < end;
		 i++) {
			 if (equals(exprList[i])) {
				 return true;
			 }
		 }
		 switch (opType) {
			 case OpTypes.LIKE : case OpTypes.MATCH_SIMPLE : case OpTypes.MATCH_PARTIAL : case OpTypes.MATCH_FULL : case OpTypes.MATCH_UNIQUE_SIMPLE : case OpTypes.MATCH_UNIQUE_PARTIAL : case OpTypes.MATCH_UNIQUE_FULL : case OpTypes.UNIQUE : case OpTypes.EXISTS : case OpTypes.ARRAY : case OpTypes.ARRAY_SUBQUERY : case OpTypes.TABLE_SUBQUERY : case OpTypes.ROW_SUBQUERY : case OpTypes.COUNT : case OpTypes.SUM : case OpTypes.MIN : case OpTypes.MAX : case OpTypes.AVG : case OpTypes.EVERY : case OpTypes.SOME : case OpTypes.STDDEV_POP : case OpTypes.STDDEV_SAMP : case OpTypes.VAR_POP : case OpTypes.VAR_SAMP : return false;
		 }
		 if (nodes.length == 0) {
			 return false;
		 }
		 boolean result = true;
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 result &= (nodes[i] == null || nodes[i].isComposedOf(exprList, start, end, excludeSet));
		 }
		 return result;
	 }
	 boolean isComposedOf(OrderedHashSet expressions, OrderedIntHashSet excludeSet) {
		 if (opType == OpTypes.VALUE || opType == OpTypes.DYNAMIC_PARAM || opType == OpTypes.PARAMETER || opType == OpTypes.VARIABLE) {
			 return true;
		 }
		 if (excludeSet.contains(opType)) {
			 return true;
		 }
		 for (int i = 0;
		 i < expressions.size();
		 i++) {
			 if (equals(expressions.get(i))) {
				 return true;
			 }
		 }
		 switch (opType) {
			 case OpTypes.COUNT : case OpTypes.SUM : case OpTypes.MIN : case OpTypes.MAX : case OpTypes.AVG : case OpTypes.EVERY : case OpTypes.SOME : case OpTypes.STDDEV_POP : case OpTypes.STDDEV_SAMP : case OpTypes.VAR_POP : case OpTypes.VAR_SAMP : return false;
		 }
		 if (nodes.length == 0) {
			 return false;
		 }
		 boolean result = true;
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 result &= (nodes[i] == null || nodes[i].isComposedOf(expressions, excludeSet));
		 }
		 return result;
	 }
	 Expression replaceColumnReferences(RangeVariable range, Expression[] list) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 nodes[i] = nodes[i].replaceColumnReferences(range, list);
		 }
		 if (subQuery != null && subQuery.queryExpression != null) {
			 subQuery.queryExpression.replaceColumnReference(range, list);
		 }
		 return this;
	 }
	 void replaceRangeVariables(RangeVariable[] ranges, RangeVariable[] newRanges) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 nodes[i].replaceRangeVariables(ranges, newRanges);
		 }
		 if (subQuery != null && subQuery.queryExpression != null) {
			 subQuery.queryExpression.replaceRangeVariables(ranges, newRanges);
		 }
	 }
	 void resetColumnReferences() {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 nodes[i].resetColumnReferences();
		 }
	 }
	 void convertToSimpleColumn(OrderedHashSet expressions, OrderedHashSet replacements) {
		 if (opType == OpTypes.VALUE) {
			 return;
		 }
		 int index = expressions.getIndex(this);
		 if (index != -1) {
			 Expression e = (Expression) replacements.get(index);
			 nodes = emptyArray;
			 opType = OpTypes.SIMPLE_COLUMN;
			 columnIndex = e.columnIndex;
			 rangePosition = e.rangePosition;
			 return;
		 }
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 nodes[i].convertToSimpleColumn(expressions, replacements);
		 }
	 }
	 boolean isAggregate() {
		 return isAggregate;
	 }
	 void setAggregate() {
		 isAggregate = true;
	 }
	 boolean isSelfAggregate() {
		 return false;
	 }
	 void setAlias(SimpleName name) {
		 alias = name;
	 }
	 String getAlias() {
		 if (alias != null) {
			 return alias.name;
		 }
		 return """";
	 }
	 SimpleName getSimpleName() {
		 if (alias != null) {
			 return alias;
		 }
		 return null;
	 }
	 public int getType() {
		 return opType;
	 }
	 Expression getLeftNode() {
		 return nodes.length > 0 ? nodes[LEFT] : null;
	 }
	 Expression getRightNode() {
		 return nodes.length > 1 ? nodes[RIGHT] : null;
	 }
	 void setLeftNode(Expression e) {
		 nodes[LEFT] = e;
	 }
	 void setRightNode(Expression e) {
		 nodes[RIGHT] = e;
	 }
	 void setSubType(int i) {
		 exprSubType = i;
	 }
	 RangeVariable getRangeVariable() {
		 return null;
	 }
	 Expression replaceAliasInOrderBy(Expression[] columns, int length) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 nodes[i] = nodes[i].replaceAliasInOrderBy(columns, length);
		 }
		 return this;
	 }
	 int findMatchingRangeVariableIndex(RangeVariable[] rangeVarArray) {
		 return -1;
	 }
	 void collectRangeVariables(RangeVariable[] rangeVariables, Set set) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 nodes[i].collectRangeVariables(rangeVariables, set);
			 }
		 }
		 if (subQuery != null && subQuery.queryExpression != null) {
			 HsqlList unresolvedExpressions = subQuery.queryExpression.getUnresolvedExpressions();
			 if (unresolvedExpressions != null) {
				 for (int i = 0;
				 i < unresolvedExpressions.size();
				 i++) {
					 Expression e = (Expression) unresolvedExpressions.get(i);
					 e.collectRangeVariables(rangeVariables, set);
				 }
			 }
		 }
	 }
	 void collectObjectNames(Set set) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 nodes[i].collectObjectNames(set);
			 }
		 }
		 if (subQuery != null) {
			 if (subQuery.queryExpression != null) {
				 subQuery.queryExpression.collectObjectNames(set);
			 }
		 }
	 }
	 boolean hasReference(RangeVariable range) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 if (nodes[i].hasReference(range)) {
					 return true;
				 }
			 }
		 }
		 if (subQuery != null && subQuery.queryExpression != null) {
			 if (subQuery.queryExpression.hasReference(range)) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public HsqlList resolveColumnReferences(RangeVariable[] rangeVarArray, HsqlList unresolvedSet) {
		 return resolveColumnReferences(rangeVarArray, rangeVarArray.length, unresolvedSet, true);
	 }
	 public HsqlList resolveColumnReferences(RangeVariable[] rangeVarArray, int rangeCount, HsqlList unresolvedSet, boolean acceptsSequences) {
		 if (opType == OpTypes.VALUE) {
			 return unresolvedSet;
		 }
		 switch (opType) {
			 case OpTypes.CASEWHEN : acceptsSequences = false;
			 break;
			 case OpTypes.TABLE : {
				 HsqlList localSet = null;
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 if (nodes[i] == null) {
						 continue;
					 }
					 localSet = nodes[i].resolveColumnReferences( RangeVariable.emptyArray, localSet);
				 }
				 if (localSet != null) {
					 isCorrelated = true;
					 if (subQuery != null) {
						 subQuery.setCorrelated();
					 }
					 for (int i = 0;
					 i < localSet.size();
					 i++) {
						 Expression e = (Expression) localSet.get(i);
						 unresolvedSet = e.resolveColumnReferences(rangeVarArray, unresolvedSet);
					 }
					 unresolvedSet = Expression.resolveColumnSet(rangeVarArray, rangeVarArray.length, localSet, unresolvedSet);
				 }
				 return unresolvedSet;
			 }
		 }
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 unresolvedSet = nodes[i].resolveColumnReferences(rangeVarArray, rangeCount, unresolvedSet, acceptsSequences);
		 }
		 switch (opType) {
			 case OpTypes.ARRAY : break;
			 case OpTypes.ARRAY_SUBQUERY : case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : {
				 QueryExpression queryExpression = subQuery.queryExpression;
				 if (!queryExpression.areColumnsResolved()) {
					 isCorrelated = true;
					 subQuery.setCorrelated();
					 if (unresolvedSet == null) {
						 unresolvedSet = new ArrayListIdentity();
					 }
					 unresolvedSet.addAll( queryExpression.getUnresolvedExpressions());
				 }
				 break;
			 }
		 default : }
		 return unresolvedSet;
	 }
	 public OrderedHashSet getUnkeyedColumns(OrderedHashSet unresolvedSet) {
		 if (opType == OpTypes.VALUE) {
			 return unresolvedSet;
		 }
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == null) {
				 continue;
			 }
			 unresolvedSet = nodes[i].getUnkeyedColumns(unresolvedSet);
		 }
		 switch (opType) {
			 case OpTypes.ARRAY : case OpTypes.ARRAY_SUBQUERY : case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : if (subQuery != null) {
				 if (unresolvedSet == null) {
					 unresolvedSet = new OrderedHashSet();
				 }
				 unresolvedSet.add(this);
			 }
			 break;
		 }
		 return unresolvedSet;
	 }
	 public void resolveTypes(Session session, Expression parent) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 nodes[i].resolveTypes(session, this);
			 }
		 }
		 switch (opType) {
			 case OpTypes.VALUE : break;
			 case OpTypes.TABLE : break;
			 case OpTypes.ROW : nodeDataTypes = new Type[nodes.length];
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (nodes[i] != null) {
					 nodeDataTypes[i] = nodes[i].dataType;
				 }
			 }
			 break;
			 case OpTypes.ARRAY : {
				 boolean hasUndefined = false;
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 if (nodes[i].dataType == null) {
						 hasUndefined = true;
					 }
					 else {
						 dataType = Type.getAggregateType(dataType, nodes[i].dataType);
					 }
				 }
				 if (hasUndefined) {
					 for (int i = 0;
					 i < nodes.length;
					 i++) {
						 if (nodes[i].dataType == null) {
							 nodes[i].dataType = dataType;
						 }
					 }
				 }
				 dataType = new ArrayType(dataType, nodes.length);
				 return;
			 }
			 case OpTypes.ARRAY_SUBQUERY : {
				 QueryExpression queryExpression = subQuery.queryExpression;
				 queryExpression.resolveTypes(session);
				 subQuery.prepareTable(session);
				 nodeDataTypes = queryExpression.getColumnTypes();
				 dataType = nodeDataTypes[0];
				 if (nodeDataTypes.length > 1) {
					 throw Error.error(ErrorCode.X_42564);
				 }
				 dataType = new ArrayType(dataType, nodes.length);
				 break;
			 }
			 case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : {
				 QueryExpression queryExpression = subQuery.queryExpression;
				 queryExpression.resolveTypes(session);
				 subQuery.prepareTable(session);
				 nodeDataTypes = queryExpression.getColumnTypes();
				 dataType = nodeDataTypes[0];
				 break;
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
		 }
	 }
	 void setAsConstantValue(Session session) {
		 valueData = getValue(session);
		 opType = OpTypes.VALUE;
		 nodes = emptyArray;
	 }
	 void setAsConstantValue(Object value) {
		 valueData = value;
		 opType = OpTypes.VALUE;
		 nodes = emptyArray;
	 }
	 void prepareTable(Session session, Expression row, int degree) {
		 if (nodeDataTypes != null) {
			 return;
		 }
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 Expression e = nodes[i];
			 if (e.opType == OpTypes.ROW) {
				 if (degree != e.nodes.length) {
					 throw Error.error(ErrorCode.X_42564);
				 }
			 }
			 else if (degree == 1) {
				 nodes[i] = new Expression(OpTypes.ROW);
				 nodes[i].nodes = new Expression[]{
				 e }
				;
			 }
			 else {
				 throw Error.error(ErrorCode.X_42564);
			 }
		 }
		 nodeDataTypes = new Type[degree];
		 for (int j = 0;
		 j < degree;
		 j++) {
			 Type type = row == null ? null : row.nodes[j].dataType;
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 type = Type.getAggregateType(nodes[i].nodes[j].dataType, type);
			 }
			 if (type == null) {
				 throw Error.error(ErrorCode.X_42567);
			 }
			 nodeDataTypes[j] = type;
			 if (row != null && row.nodes[j].isUnresolvedParam()) {
				 row.nodes[j].dataType = type;
			 }
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (nodes[i].nodes[j].isUnresolvedParam()) {
					 nodes[i].nodes[j].dataType = nodeDataTypes[j];
					 continue;
				 }
				 if (nodes[i].nodes[j].opType == OpTypes.VALUE) {
					 if (nodes[i].nodes[j].valueData == null) {
						 nodes[i].nodes[j].dataType = nodeDataTypes[j];
					 }
				 }
			 }
			 if (nodeDataTypes[j].isCharacterType() && !((CharacterType) nodeDataTypes[j]) .isEqualIdentical()) {
			 }
		 }
	 }
	 void insertValuesIntoSubqueryTable(Session session, PersistentStore store) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 Object[] data = nodes[i].getRowValue(session);
			 for (int j = 0;
			 j < nodeDataTypes.length;
			 j++) {
				 data[j] = nodeDataTypes[j].convertToType(session, data[j], nodes[i].nodes[j].dataType);
			 }
			 Row row = (Row) store.getNewCachedObject(session, data);
			 try {
				 store.indexRow(session, row);
			 }
			 catch (HsqlException e) {
			}
		 }
	 }
	 String getColumnName() {
		 return getAlias();
	 }
	 ColumnSchema getColumn() {
		 return null;
	 }
	 int getColumnIndex() {
		 return columnIndex;
	 }
	 Type getDataType() {
		 return dataType;
	 }
	 Type getNodeDataType(int i) {
		 if (nodeDataTypes == null) {
			 if (i > 0) {
				 throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
			 }
			 return dataType;
		 }
		 else {
			 return nodeDataTypes[i];
		 }
	 }
	 Type[] getNodeDataTypes() {
		 if (nodeDataTypes == null) {
			 return new Type[]{
			 dataType }
			;
		 }
		 else {
			 return nodeDataTypes;
		 }
	 }
	 int getDegree() {
		 switch (opType) {
			 case OpTypes.ROW : return nodes.length;
			 case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : if (subQuery == null) {
			 }
			 return subQuery.queryExpression.getColumnCount();
			 default : return 1;
		 }
	 }
	 public Table getTable() {
		 return subQuery == null ? null : subQuery.getTable();
	 }
	 public void materialise(Session session) {
		 if (subQuery == null) {
			 return;
		 }
		 if (subQuery.isCorrelated()) {
			 subQuery.materialiseCorrelated(session);
		 }
		 else {
			 subQuery.materialise(session);
		 }
	 }
	 Object getValue(Session session, Type type) {
		 Object o = getValue(session);
		 if (o == null || dataType == type) {
			 return o;
		 }
		 return type.convertToType(session, o, dataType);
	 }
	 public Object getConstantValueNoCheck(Session session) {
		 try {
			 return getValue(session);
		 }
		 catch (HsqlException e) {
			 return null;
		 }
	 }
	 public Object[] getRowValue(Session session) {
		 switch (opType) {
			 case OpTypes.ROW : {
				 Object[] data = new Object[nodes.length];
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 data[i] = nodes[i].getValue(session);
				 }
				 return data;
			 }
			 case OpTypes.ROW_SUBQUERY : case OpTypes.TABLE_SUBQUERY : {
				 return subQuery.queryExpression.getValues(session);
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
		 }
	 }
	 public Object getValue(Session session) {
		 switch (opType) {
			 case OpTypes.VALUE : return valueData;
			 case OpTypes.SIMPLE_COLUMN : {
				 Object[] data = session.sessionContext.rangeIterators[rangePosition] .getCurrent();
				 return data[columnIndex];
			 }
			 case OpTypes.ROW : {
				 if (nodes.length == 1) {
					 return nodes[0].getValue(session);
				 }
				 Object[] row = new Object[nodes.length];
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 row[i] = nodes[i].getValue(session);
				 }
				 return row;
			 }
			 case OpTypes.ARRAY : {
				 Object[] array = new Object[nodes.length];
				 for (int i = 0;
				 i < nodes.length;
				 i++) {
					 array[i] = nodes[i].getValue(session);
				 }
				 return array;
			 }
			 case OpTypes.ARRAY_SUBQUERY : {
				 subQuery.materialiseCorrelated(session);
				 RowSetNavigatorData nav = subQuery.getNavigator(session);
				 int size = nav.getSize();
				 Object[] array = new Object[size];
				 nav.beforeFirst();
				 for (int i = 0;
				 nav.hasNext();
				 i++) {
					 Object[] data = nav.getNextRowData();
					 array[i] = data[0];
				 }
				 return array;
			 }
			 case OpTypes.TABLE_SUBQUERY : case OpTypes.ROW_SUBQUERY : {
				 subQuery.materialiseCorrelated(session);
				 Object[] value = subQuery.getValues(session);
				 if (value.length == 1) {
					 return ((Object[]) value)[0];
				 }
				 return value;
			 }
			 default : throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
		 }
	 }
	 public Result getResult(Session session) {
		 switch (opType) {
			 case OpTypes.ARRAY : {
				 RowSetNavigatorData navigator = subQuery.getNavigator(session);
				 Object[] array = new Object[navigator.getSize()];
				 navigator.beforeFirst();
				 for (int i = 0;
				 navigator.hasNext();
				 i++) {
					 Object[] data = navigator.getNext();
					 array[i] = data[0];
				 }
				 return Result.newPSMResult(array);
			 }
			 case OpTypes.TABLE_SUBQUERY : {
				 subQuery.materialiseCorrelated(session);
				 RowSetNavigatorData navigator = subQuery.getNavigator(session);
				 Result result = Result.newResult(navigator);
				 result.metaData = subQuery.queryExpression.getMetaData();
				 return result;
			 }
			 default : {
				 Object value = getValue(session);
				 return Result.newPSMResult(value);
			 }
		 }
	 }
	 boolean testCondition(Session session) {
		 return Boolean.TRUE.equals(getValue(session));
	 }
	 static int countNulls(Object[] a) {
		 int nulls = 0;
		 for (int i = 0;
		 i < a.length;
		 i++) {
			 if (a[i] == null) {
				 nulls++;
			 }
		 }
		 return nulls;
	 }
	 public boolean isIndexable(RangeVariable range) {
		 return false;
	 }
	 static void convertToType(Session session, Object[] data, Type[] dataType, Type[] newType) {
		 for (int i = 0;
		 i < data.length;
		 i++) {
			 data[i] = newType[i].convertToType(session, data[i], dataType[i]);
		 }
	 }
	 static QuerySpecification getCheckSelect(Session session, Table t, Expression e) {
		 CompileContext compileContext = new CompileContext(session, null);
		 QuerySpecification s = new QuerySpecification(compileContext);
		 RangeVariable[] ranges = new RangeVariable[]{
		 new RangeVariable(t, null, null, null, compileContext) }
		;
		 e.resolveCheckOrGenExpression(session, ranges, true);
		 s.exprColumns = new Expression[1];
		 s.exprColumns[0] = EXPR_TRUE;
		 s.rangeVariables = ranges;
		 if (Type.SQL_BOOLEAN != e.getDataType()) {
			 throw Error.error(ErrorCode.X_42568);
		 }
		 Expression condition = new ExpressionLogical(OpTypes.NOT, e);
		 s.queryCondition = condition;
		 s.resolveReferences(session);
		 s.resolveTypes(session);
		 return s;
	 }
	 public void resolveCheckOrGenExpression(Session session, RangeVariable[] ranges, boolean isCheck) {
		 boolean nonDeterministic = false;
		 OrderedHashSet set = new OrderedHashSet();
		 HsqlList unresolved = resolveColumnReferences(ranges, null);
		 ExpressionColumn.checkColumnsResolved(unresolved);
		 resolveTypes(session, null);
		 collectAllExpressions(set, Expression.subqueryAggregateExpressionSet, Expression.emptyExpressionSet);
		 if (!set.isEmpty()) {
			 throw Error.error(ErrorCode.X_42512);
		 }
		 collectAllExpressions(set, Expression.functionExpressionSet, Expression.emptyExpressionSet);
		 for (int i = 0;
		 i < set.size();
		 i++) {
			 Expression current = (Expression) set.get(i);
			 if (current.opType == OpTypes.FUNCTION) {
				 if (!((FunctionSQLInvoked) current).isDeterministic()) {
					 throw Error.error(ErrorCode.X_42512);
				 }
			 }
			 if (current.opType == OpTypes.SQL_FUNCTION) {
				 if (!((FunctionSQL) current).isDeterministic()) {
					 if (isCheck) {
						 nonDeterministic = true;
						 continue;
					 }
					 throw Error.error(ErrorCode.X_42512);
				 }
			 }
		 }
		 if (isCheck && nonDeterministic) {
			 HsqlArrayList list = new HsqlArrayList();
			 RangeVariableResolver.decomposeAndConditions(this, list);
			 for (int i = 0;
			 i < list.size();
			 i++) {
				 nonDeterministic = true;
				 Expression e = (Expression) list.get(i);
				 Expression e1;
				 if (e instanceof ExpressionLogical) {
					 boolean b = ((ExpressionLogical) e).convertToSmaller();
					 if (!b) {
						 break;
					 }
					 e1 = e.getRightNode();
					 e = e.getLeftNode();
					 if (!e.dataType.isDateTimeType()) {
						 nonDeterministic = true;
						 break;
					 }
					 if (e.hasNonDeterministicFunction()) {
						 nonDeterministic = true;
						 break;
					 }
					 if (e1 instanceof ExpressionArithmetic) {
						 if (opType == OpTypes.ADD) {
							 if (e1.getRightNode() .hasNonDeterministicFunction()) {
								 e1.swapLeftAndRightNodes();
							 }
						 }
						 else if (opType == OpTypes.SUBTRACT) {
						}
						 else {
							 break;
						 }
						 if (e1.getRightNode().hasNonDeterministicFunction()) {
							 break;
						 }
						 e1 = e1.getLeftNode();
					 }
					 if (e1.opType == OpTypes.SQL_FUNCTION) {
						 FunctionSQL function = (FunctionSQL) e1;
						 switch (function.funcType) {
							 case FunctionSQL.FUNC_CURRENT_DATE : case FunctionSQL.FUNC_CURRENT_TIMESTAMP : case FunctionSQL.FUNC_LOCALTIMESTAMP : nonDeterministic = false;
							 continue;
							 default : break;
						 }
						 break;
					 }
					 break;
				 }
				 else {
					 break;
				 }
			 }
			 if (nonDeterministic) {
				 throw Error.error(ErrorCode.X_42512);
			 }
		 }
		 set.clear();
		 collectObjectNames(set);
		 for (int i = 0;
		 i < set.size();
		 i++) {
			 HsqlName name = (HsqlName) set.get(i);
			 switch (name.type) {
				 case SchemaObject.COLUMN : {
					 if (isCheck) {
						 break;
					 }
					 int colIndex = ranges[0].rangeTable.findColumn(name.name);
					 ColumnSchema column = ranges[0].rangeTable.getColumn(colIndex);
					 if (column.isGenerated()) {
						 throw Error.error(ErrorCode.X_42512);
					 }
					 break;
				 }
				 case SchemaObject.SEQUENCE : {
					 throw Error.error(ErrorCode.X_42512);
				 }
				 case SchemaObject.SPECIFIC_ROUTINE : {
					 Routine routine = (Routine) session.database.schemaManager .getSchemaObject(name);
					 if (!routine.isDeterministic()) {
						 throw Error.error(ErrorCode.X_42512);
					 }
					 int impact = routine.getDataImpact();
					 if (impact == Routine.READS_SQL || impact == Routine.MODIFIES_SQL) {
						 throw Error.error(ErrorCode.X_42512);
					 }
				 }
			 }
		 }
		 set.clear();
	 }
	 boolean isUnresolvedParam() {
		 return false;
	 }
	 boolean isDynamicParam() {
		 return false;
	 }
	 boolean hasNonDeterministicFunction() {
		 OrderedHashSet list = null;
		 list = collectAllExpressions(list, Expression.functionExpressionSet, Expression.emptyExpressionSet);
		 if (list == null) {
			 return false;
		 }
		 for (int j = 0;
		 j < list.size();
		 j++) {
			 Expression current = (Expression) list.get(j);
			 if (current.opType == OpTypes.FUNCTION) {
				 if (!((FunctionSQLInvoked) current).isDeterministic()) {
					 return true;
				 }
			 }
			 else if (current.opType == OpTypes.SQL_FUNCTION) {
				 if (!((FunctionSQL) current).isDeterministic()) {
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 void swapLeftAndRightNodes() {
		 Expression temp = nodes[LEFT];
		 nodes[LEFT] = nodes[RIGHT];
		 nodes[RIGHT] = temp;
	 }
	 void setAttributesAsColumn(ColumnSchema column, boolean isWritable) {
		 throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
	 }
	 String getValueClassName() {
		 Type type = dataType == null ? NullType.getNullType() : dataType;
		 return type.getJDBCClassName();
	 }
	 OrderedHashSet collectAllExpressions(OrderedHashSet set, OrderedIntHashSet typeSet, OrderedIntHashSet stopAtTypeSet) {
		 if (stopAtTypeSet.contains(opType)) {
			 return set;
		 }
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 set = nodes[i].collectAllExpressions(set, typeSet, stopAtTypeSet);
			 }
		 }
		 if (typeSet.contains(opType)) {
			 if (set == null) {
				 set = new OrderedHashSet();
			 }
			 set.add(this);
		 }
		 if (subQuery != null && subQuery.queryExpression != null) {
			 set = subQuery.queryExpression.collectAllExpressions(set, typeSet, stopAtTypeSet);
		 }
		 return set;
	 }
	 public OrderedHashSet getSubqueries() {
		 return collectAllSubqueries(null);
	 }
	 OrderedHashSet collectAllSubqueries(OrderedHashSet set) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] != null) {
				 set = nodes[i].collectAllSubqueries(set);
			 }
		 }
		 if (subQuery != null) {
			 if (set == null) {
				 set = new OrderedHashSet();
			 }
			 set.add(subQuery);
			 if (subQuery.queryExpression != null) {
				 OrderedHashSet tempSet = subQuery.queryExpression.getSubqueries();
				 set = OrderedHashSet.addAll(set, tempSet);
			 }
		 }
		 return set;
	 }
	 public boolean isCorrelated() {
		 if (subQuery == null) {
			 return false;
		 }
		 return subQuery.isCorrelated();
	 }
	 public void checkValidCheckConstraint() {
		 OrderedHashSet set = null;
		 set = collectAllExpressions(set, subqueryAggregateExpressionSet, emptyExpressionSet);
		 if (set != null && !set.isEmpty()) {
			 throw Error.error(ErrorCode.X_0A000, ""subquery in check constraint"");
		 }
	 }
	 static HsqlList resolveColumnSet(RangeVariable[] rangeVars, int rangeCount, HsqlList sourceSet, HsqlList targetSet) {
		 if (sourceSet == null) {
			 return targetSet;
		 }
		 for (int i = 0;
		 i < sourceSet.size();
		 i++) {
			 Expression e = (Expression) sourceSet.get(i);
			 targetSet = e.resolveColumnReferences(rangeVars, rangeCount, targetSet, true);
		 }
		 return targetSet;
	 }
	 Expression getIndexableExpression(RangeVariable rangeVar) {
		 return null;
	 }
	 public Expression duplicate() {
		 Expression e = null;
		 try {
			 e = (Expression) super.clone();
			 e.nodes = nodes.clone();
			 for (int i = 0;
			 i < nodes.length;
			 i++) {
				 if (nodes[i] != null) {
					 e.nodes[i] = nodes[i].duplicate();
				 }
			 }
		 }
		 catch (CloneNotSupportedException ex) {
			 throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
		 }
		 return e;
	 }
	 void replaceNode(Expression existing, Expression replacement) {
		 for (int i = 0;
		 i < nodes.length;
		 i++) {
			 if (nodes[i] == existing) {
				 replacement.alias = nodes[i].alias;
				 nodes[i] = replacement;
				 return;
			 }
		 }
		 throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
	 }
	 public Object updateAggregatingValue(Session session, Object currValue) {
		 throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
	 }
	 public Object getAggregatedValue(Session session, Object currValue) {
		 throw Error.runtimeError(ErrorCode.U_S0500, ""Expression"");
	 }
}",1,0,0,0
"public String vmExecutablePath(Vm vm) {
	 File homeDir = vmHomeDir(vm);
	 for (String extension : EXECUTABLE_EXTENSIONS) {
		 for (String dir : EXECUTABLE_DIRS) {
			 File file = new File(homeDir, dir + vm.executable() + extension);
			 if (file.isFile()) {
				 return file.getAbsolutePath();
			 }
		 }
	 }
	 throw new VirtualMachineException( String.format( ""VM executable %s for VM %s not found under home dir %s"", vm.executable(), vm, homeDir));
 }",0,0,1,0
"public IHeaderResponse getHeaderResponse(){
	if (headerResponse == null){
		headerResponse = getApplication().decorateHeaderResponse(newHeaderResponse());
	}
	return headerResponse;
}",0,0,0,0
"public class NotificationHubListener implements NotificationListener {
	 private ObjectName name;
	 private int numCounter = 0;
	 protected NotificationHubListener(ObjectName name) {
		 this.name = name;
	 }
	 public int incNumCounter() {
		 return ++numCounter;
	 }
	 public int decNumCounter() {
		 return --numCounter;
	 }
	 public int getNumCounter() {
		 return this.numCounter;
	 }
	 public void handleNotification(Notification notification, Object handback) {
		 NotificationKey key = new NotificationKey(name);
		 notification.setUserData(memberSource);
		 repo.putEntryInLocalNotificationRegion(key, notification);
	 }
 }",0,0,0,0
"private static class ConvertToBinaryBlockFunction implements PairFlatMapFunction<Iterator<Tuple2<Double,Long>>,MatrixIndexes,MatrixBlock> {
	private static final long serialVersionUID = 5000298196472931653L;
	private long _rlen = -1;
	private int _brlen = -1;
	public ConvertToBinaryBlockFunction(long rlen, int brlen){
		_rlen = rlen;
		_brlen = brlen;
	}
	public Iterator<Tuple2<MatrixIndexes, MatrixBlock>> call(Iterator<Tuple2<Double,Long>> arg0) throws Exception {
		ArrayList<Tuple2<MatrixIndexes,MatrixBlock>> ret = new ArrayList<>();
		MatrixIndexes ix = null;
		MatrixBlock mb = null;
		while( arg0.hasNext() ) {
			Tuple2<Double,Long> val = arg0.next();
			long valix = val._2 + 1;
			long rix = UtilFunctions.computeBlockIndex(valix, _brlen);
			int pos = UtilFunctions.computeCellInBlock(valix, _brlen);
			if( ix == null || ix.getRowIndex() != rix ){
				if( ix !=null )ret.add(new Tuple2<>(ix,mb));
				long len = UtilFunctions.computeBlockSize(_rlen, rix, _brlen);
				ix = new MatrixIndexes(rix,1);
				mb = new MatrixBlock((int)len, 1, false);
			}
			mb.quickSetValue(pos, 0, val._1);
		}
		if( mb!=null && mb.getNonZeros() != 0 )ret.add(new Tuple2<>(ix,mb));
		return ret.iterator();
	}
}",1,0,0,0
"final class DocumentsWriterDeleteQueue implements Accountable {
	 private volatile Node<?> tail;
	 private final DeleteSlice globalSlice;
	 private final BufferedUpdates globalBufferedUpdates;
	 final ReentrantLock globalBufferLock = new ReentrantLock();
	 final long generation;
	 private final AtomicLong nextSeqNo;
	 private final InfoStream infoStream;
	 long maxSeqNo = Long.MAX_VALUE;
	 DocumentsWriterDeleteQueue(InfoStream infoStream) {
		 this(infoStream, 0, 1);
	 }
	 DocumentsWriterDeleteQueue(InfoStream infoStream, long generation, long startSeqNo) {
		 this(infoStream, new BufferedUpdates(""global""), generation, startSeqNo);
	 }
	 DocumentsWriterDeleteQueue(InfoStream infoStream, BufferedUpdates globalBufferedUpdates, long generation, long startSeqNo) {
		 this.infoStream = infoStream;
		 this.globalBufferedUpdates = globalBufferedUpdates;
		 this.generation = generation;
		 this.nextSeqNo = new AtomicLong(startSeqNo);
		 tail = new Node<>(null);
		 globalSlice = new DeleteSlice(tail);
	 }
	 long addDelete(Query... queries) {
		 long seqNo = add(new QueryArrayNode(queries));
		 tryApplyGlobalSlice();
		 return seqNo;
	 }
	 long addDelete(Term... terms) {
		 long seqNo = add(new TermArrayNode(terms));
		 tryApplyGlobalSlice();
		 return seqNo;
	 }
	 long addDocValuesUpdates(DocValuesUpdate... updates) {
		 long seqNo = add(new DocValuesUpdatesNode(updates));
		 tryApplyGlobalSlice();
		 return seqNo;
	 }
	 static Node<Term> newNode(Term term) {
		 return new TermNode(term);
	 }
	 static Node<DocValuesUpdate[]> newNode(DocValuesUpdate... updates) {
		 return new DocValuesUpdatesNode(updates);
	 }
	 long add(Node<?> deleteNode, DeleteSlice slice) {
		 long seqNo = add(deleteNode);
		 slice.sliceTail = deleteNode;
		 assert slice.sliceHead != slice.sliceTail : ""slice head and tail must differ after add"";
		 tryApplyGlobalSlice();
		 return seqNo;
	 }
	 synchronized long add(Node<?> newNode) {
		 tail.next = newNode;
		 this.tail = newNode;
		 return getNextSequenceNumber();
	 }
	 boolean anyChanges() {
		 globalBufferLock.lock();
		 try {
			 return globalBufferedUpdates.any() || !globalSlice.isEmpty() || globalSlice.sliceTail != tail || tail.next != null;
		 }
		 finally {
			 globalBufferLock.unlock();
		 }
	 }
	 void tryApplyGlobalSlice() {
		 if (globalBufferLock.tryLock()) {
			 try {
				 if (updateSliceNoSeqNo(globalSlice)) {
					 globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
				 }
			 }
			 finally {
				 globalBufferLock.unlock();
			 }
		 }
	 }
	 FrozenBufferedUpdates freezeGlobalBuffer(DeleteSlice callerSlice) throws IOException {
		 globalBufferLock.lock();
		 final Node<?> currentTail = tail;
		 if (callerSlice != null) {
			 callerSlice.sliceTail = currentTail;
		 }
		 try {
			 if (globalSlice.sliceTail != currentTail) {
				 globalSlice.sliceTail = currentTail;
				 globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
			 }
			 if (globalBufferedUpdates.any()) {
				 final FrozenBufferedUpdates packet = new FrozenBufferedUpdates(infoStream, globalBufferedUpdates, null);
				 globalBufferedUpdates.clear();
				 return packet;
			 }
			 else {
				 return null;
			 }
		 }
		 finally {
			 globalBufferLock.unlock();
		 }
	 }
	 DeleteSlice newSlice() {
		 return new DeleteSlice(tail);
	 }
	 synchronized long updateSlice(DeleteSlice slice) {
		 long seqNo = getNextSequenceNumber();
		 if (slice.sliceTail != tail) {
			 slice.sliceTail = tail;
			 seqNo = -seqNo;
		 }
		 return seqNo;
	 }
	 boolean updateSliceNoSeqNo(DeleteSlice slice) {
		 if (slice.sliceTail != tail) {
			 slice.sliceTail = tail;
			 return true;
		 }
		 return false;
	 }
	 static class DeleteSlice {
		 Node<?> sliceHead;
		 Node<?> sliceTail;
		 DeleteSlice(Node<?> currentTail) {
			 assert currentTail != null;
			 sliceHead = sliceTail = currentTail;
		 }
		 void apply(BufferedUpdates del, int docIDUpto) {
			 if (sliceHead == sliceTail) {
				 return;
			 }
			 Node<?> current = sliceHead;
			 do {
				 current = current.next;
				 assert current != null : ""slice property violated between the head on the tail must not be a null node"";
				 current.apply(del, docIDUpto);
			 }
			 while (current != sliceTail);
			 reset();
		 }
		 void reset() {
			 sliceHead = sliceTail;
		 }
		 boolean isTail(Node<?> node) {
			 return sliceTail == node;
		 }
		 boolean isTailItem(Object object) {
			 return sliceTail.item == object;
		 }
		 boolean isEmpty() {
			 return sliceHead == sliceTail;
		 }
	 }
	 public int numGlobalTermDeletes() {
		 return globalBufferedUpdates.numTermDeletes.get();
	 }
	 void clear() {
		 globalBufferLock.lock();
		 try {
			 final Node<?> currentTail = tail;
			 globalSlice.sliceHead = globalSlice.sliceTail = currentTail;
			 globalBufferedUpdates.clear();
		 }
		 finally {
			 globalBufferLock.unlock();
		 }
	 }
	 static class Node<T> {
		 volatile Node<?> next;
		 final T item;
		 Node(T item) {
			 this.item = item;
		 }
		 void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {
			 throw new IllegalStateException(""sentinel item must never be applied"");
		 }
		 boolean isDelete() {
			 return true;
		 }
	 }
	 private static final class TermNode extends Node<Term> {
		 TermNode(Term term) {
			 super(term);
		 }
		 void apply(BufferedUpdates bufferedDeletes, int docIDUpto) {
			 bufferedDeletes.addTerm(item, docIDUpto);
		 }
		 public String toString() {
			 return ""del="" + item;
		 }
	 }
	 private static final class QueryArrayNode extends Node<Query[]> {
		 QueryArrayNode(Query[] query) {
			 super(query);
		 }
		 void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
			 for (Query query : item) {
				 bufferedUpdates.addQuery(query, docIDUpto);
			 }
		 }
	 }
	 private static final class TermArrayNode extends Node<Term[]> {
		 TermArrayNode(Term[] term) {
			 super(term);
		 }
		 void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
			 for (Term term : item) {
				 bufferedUpdates.addTerm(term, docIDUpto);
			 }
		 }
		 public String toString() {
			 return ""dels="" + Arrays.toString(item);
		 }
	 }
	 private static final class DocValuesUpdatesNode extends Node<DocValuesUpdate[]> {
		 DocValuesUpdatesNode(DocValuesUpdate... updates) {
			 super(updates);
		 }
		 void apply(BufferedUpdates bufferedUpdates, int docIDUpto) {
			 for (DocValuesUpdate update : item) {
				 switch (update.type) {
					 case NUMERIC: bufferedUpdates.addNumericUpdate((NumericDocValuesUpdate) update, docIDUpto);
					 break;
					 case BINARY: bufferedUpdates.addBinaryUpdate((BinaryDocValuesUpdate) update, docIDUpto);
					 break;
					 default: throw new IllegalArgumentException(update.type + "" DocValues updates not supported yet!"");
				 }
			 }
		 }
		 boolean isDelete() {
			 return false;
		 }
		 public String toString() {
			 StringBuilder sb = new StringBuilder();
			 sb.append(""docValuesUpdates: "");
			 if (item.length > 0) {
				 sb.append(""term="").append(item[0].term).append("";
				 updates: ["");
				 for (DocValuesUpdate update : item) {
					 sb.append(update.field).append(':').append(update.valueToString()).append(',');
				 }
				 sb.setCharAt(sb.length()-1, ']');
			 }
			 return sb.toString();
		 }
	 }
	 private boolean forceApplyGlobalSlice() {
		 globalBufferLock.lock();
		 final Node<?> currentTail = tail;
		 try {
			 if (globalSlice.sliceTail != currentTail) {
				 globalSlice.sliceTail = currentTail;
				 globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);
			 }
			 return globalBufferedUpdates.any();
		 }
		 finally {
			 globalBufferLock.unlock();
		 }
	 }
	 public int getBufferedUpdatesTermsSize() {
		 globalBufferLock.lock();
		 try {
			 forceApplyGlobalSlice();
			 return globalBufferedUpdates.deleteTerms.size();
		 }
		 finally {
			 globalBufferLock.unlock();
		 }
	 }
	 public long ramBytesUsed() {
		 return globalBufferedUpdates.ramBytesUsed();
	 }
	 public String toString() {
		 return ""DWDQ: [ generation: "" + generation + "" ]"";
	 }
	 public long getNextSequenceNumber() {
		 long seqNo = nextSeqNo.getAndIncrement();
		 assert seqNo < maxSeqNo: ""seqNo="" + seqNo + "" vs maxSeqNo="" + maxSeqNo;
		 return seqNo;
	 }
	 public long getLastSequenceNumber() {
		 return nextSeqNo.get()-1;
	 }
	 public void skipSequenceNumbers(long jump) {
		 nextSeqNo.addAndGet(jump);
	 }
 }",1,0,0,0
"public class CollectionUtils {
	 public static boolean equals(Vector v1, Vector v2) {
		 if (v1 == v2) {
			 return true;
		 }
		 if (v1 == null || v2 == null) {
			 return false;
		 }
		 return v1.equals(v2);
	 }
	 public static boolean equals(Dictionary d1, Dictionary d2) {
		 if (d1 == d2) {
			 return true;
		 }
		 if (d1 == null || d2 == null) {
			 return false;
		 }
		 if (d1.size() != d2.size()) {
			 return false;
		 }
		 Enumeration e1 = d1.keys();
		 while (e1.hasMoreElements()) {
			 Object key = e1.nextElement();
			 Object value1 = d1.get(key);
			 Object value2 = d2.get(key);
			 if (value2 == null || !value1.equals(value2)) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public static void putAll(Dictionary m1, Dictionary m2) {
		 for (Enumeration it = m2.keys();
		 it.hasMoreElements();
		) {
			 Object key = it.nextElement();
			 m1.put(key, m2.get(key));
		 }
	 }
	 public static final class EmptyEnumeration implements Enumeration {
		 public EmptyEnumeration() {
		 }
		 public boolean hasMoreElements() {
			 return false;
		 }
		 public Object nextElement() throws NoSuchElementException {
			 throw new NoSuchElementException();
		 }
	 }
	 public static Enumeration append(Enumeration e1, Enumeration e2) {
		 return new CompoundEnumeration(e1, e2);
	 }
	 public static Enumeration asEnumeration(final Iterator iter) {
		 return new Enumeration() {
			 public boolean hasMoreElements() {
				 return iter.hasNext();
			 }
			 public Object nextElement() {
				 return iter.next();
			 }
		 }
		;
	 }
	 public static Iterator asIterator(final Enumeration e) {
		 return new Iterator() {
			 public boolean hasNext() {
				 return e.hasMoreElements();
			 }
			 public Object next() {
				 return e.nextElement();
			 }
			 public void remove() {
				 throw new UnsupportedOperationException();
			 }
		 }
		;
	 }
	 private static final class CompoundEnumeration implements Enumeration {
		 private final Enumeration e1, e2;
		 public CompoundEnumeration(Enumeration e1, Enumeration e2) {
			 this.e1 = e1;
			 this.e2 = e2;
		 }
		 public boolean hasMoreElements() {
			 return e1.hasMoreElements() || e2.hasMoreElements();
		 }
		 public Object nextElement() throws NoSuchElementException {
			 if (e1.hasMoreElements()) {
				 return e1.nextElement();
			 }
			 else {
				 return e2.nextElement();
			 }
		 }
	 }
}",0,0,0,0
"public class CreateSplineMeshTool extends EditingTool{
	 static int counter = 1;
	 static final int FLAT = 0;
	 static final int CYLINDER = 1;
	 static final int TORUS = 2;
	 boolean shiftDown;
	 Point clickPoint;
	 int usize = 5, vsize = 5, shape = FLAT, smoothing = Mesh.APPROXIMATING;
	 double thickness = 0.5;
	 public CreateSplineMeshTool(LayoutWindow fr) {
		 super(fr);
		 initButton(""splineMesh"");
	 }
	 public void activate() {
		 super.activate();
		 setHelpText();
	 }
	 private void setHelpText() {
		 String shapeDesc, smoothingDesc;
		 if (shape == FLAT) shapeDesc = ""flat"";
		 else if (shape == CYLINDER) shapeDesc = ""cylindrical"";
		 else shapeDesc = ""toroidal"";
		 if (smoothing == Mesh.INTERPOLATING) smoothingDesc = ""interpolating"";
		 else smoothingDesc = ""approximating"";
		 theWindow.setHelpText(Translate.text(""createSplineMeshTool.helpText"", new Object [] {
		Integer.toString(usize), Integer.toString(vsize), Translate.text(""createSplineMeshTool.""+shapeDesc).toLowerCase(), Translate.text(""menu.""+smoothingDesc).toLowerCase()}
		));
	 }
	 public int whichClicks() {
		 return ALL_CLICKS;
	 }
	 public String getToolTipText() {
		 return Translate.text(""createSplineMeshTool.tipText"");
	 }
	 public void mousePressed(WidgetMouseEvent e, ViewerCanvas view) {
		 clickPoint = e.getPoint();
		 shiftDown = e.isShiftDown();
		 ((SceneViewer) view).beginDraggingBox(clickPoint, shiftDown);
	 }
	 public void mouseReleased(WidgetMouseEvent e, ViewerCanvas view) {
		 Scene theScene = ((LayoutWindow) theWindow).getScene();
		 Camera cam = view.getCamera();
		 Point dragPoint = e.getPoint();
		 Vec3 v1, v2, v3, orig, xdir, ydir, zdir;
		 double xsize, ysize;
		 int i;
		 if (shiftDown) {
			if (Math.abs(dragPoint.x-clickPoint.x) > Math.abs(dragPoint.y-clickPoint.y)) {
				 if (dragPoint.y < clickPoint.y) dragPoint.y = clickPoint.y - Math.abs(dragPoint.x-clickPoint.x);
				 else dragPoint.y = clickPoint.y + Math.abs(dragPoint.x-clickPoint.x);
			 }
			 else {
				 if (dragPoint.x < clickPoint.x) dragPoint.x = clickPoint.x - Math.abs(dragPoint.y-clickPoint.y);
				 else dragPoint.x = clickPoint.x + Math.abs(dragPoint.y-clickPoint.y);
			 }
		 }
		 if (dragPoint.x == clickPoint.x || dragPoint.y == clickPoint.y) {
			 ((SceneViewer) view).repaint();
			 return;
		 }
		 v1 = cam.convertScreenToWorld(clickPoint, Camera.DEFAULT_DISTANCE_TO_SCREEN);
		 v2 = cam.convertScreenToWorld(new Point(dragPoint.x, clickPoint.y), Camera.DEFAULT_DISTANCE_TO_SCREEN);
		 v3 = cam.convertScreenToWorld(dragPoint, Camera.DEFAULT_DISTANCE_TO_SCREEN);
		 orig = v1.plus(v3).times(0.5);
		 if (dragPoint.x < clickPoint.x) xdir = v1.minus(v2);
		 else xdir = v2.minus(v1);
		 if (dragPoint.y < clickPoint.y) ydir = v3.minus(v2);
		 else ydir = v2.minus(v3);
		 xsize = xdir.length();
		 ysize = ydir.length();
		 xdir = xdir.times(1.0/xsize);
		 ydir = ydir.times(1.0/ysize);
		 zdir = xdir.cross(ydir);
		 Vec3 v[][] = getMeshPoints(xsize, ysize);
		 float usmoothness[] = new float [usize], vsmoothness[] = new float [vsize];
		 for (i = 0;
		 i < usize;
		 i++) usmoothness[i] = 1.0f;
		 for (i = 0;
		 i < vsize;
		 i++) vsmoothness[i] = 1.0f;
		 SplineMesh obj = new SplineMesh(v, usmoothness, vsmoothness, smoothing, shape != FLAT, shape == TORUS);
		 ObjectInfo info = new ObjectInfo(obj, new CoordinateSystem(orig, zdir, ydir), ""Spline Mesh ""+(counter++));
		 info.addTrack(new PositionTrack(info), 0);
		 info.addTrack(new RotationTrack(info), 1);
		 UndoRecord undo = new UndoRecord(theWindow, false);
		 int sel[] = ((LayoutWindow) theWindow).getSelectedIndices();
		 ((LayoutWindow) theWindow).addObject(info, undo);
		 undo.addCommand(UndoRecord.SET_SCENE_SELECTION, new Object [] {
		sel}
		);
		 theWindow.setUndoRecord(undo);
		 ((LayoutWindow) theWindow).setSelection(theScene.getNumObjects()-1);
		 theWindow.updateImage();
	 }
	 private Vec3 [][] getMeshPoints(double xsize, double ysize) {
		 Vec3 v[][] = new Vec3 [usize][vsize];
		 int i, j;
		 if (shape == FLAT) {
			 double xmin = -xsize*0.5, ymin = -ysize*0.5;
			 double uscale = 1.0/(usize-1), vscale = 1.0/(vsize-1);
			 for (i = 0;
			 i < usize;
			 i++) for (j = 0;
			 j < vsize;
			 j++) v[i][j] = new Vec3(xsize*i*uscale+xmin, ysize*j*vscale+ymin, 0.0);
		 }
		 else if (shape == CYLINDER) {
			 double rad = xsize*0.5, ymin = -ysize*0.5;
			 double uscale = 2.0*Math.PI/usize, vscale = 1.0/(vsize-1);
			 for (i = 0;
			 i < usize;
			 i++) for (j = 0;
			 j < vsize;
			 j++) v[i][j] = new Vec3(rad*Math.sin(uscale*i), ysize*j*vscale+ymin, rad*Math.cos(uscale*i));
		 }
		 else {
			 double rad = Math.min(xsize, ysize)*0.25*thickness;
			 double radx = xsize*0.5 - rad, rady = ysize*0.5 - rad;
			 double uscale = 2.0*Math.PI/usize, vscale = 2.0*Math.PI/vsize;
			 Vec3 vr = new Vec3(), vc = new Vec3();
			 for (i = 0;
			 i < usize;
			 i++) {
				 vc.set(radx*Math.cos(uscale*i), rady*Math.sin(uscale*i), 0.0);
				 vr.set(rad*Math.cos(uscale*i), rad*Math.sin(uscale*i), 0.0);
				 for (j = 0;
				 j < vsize;
				 j++) v[i][j] = new Vec3(vc.x+vr.x*Math.cos(vscale*j), vc.y+vr.y*Math.cos(vscale*j), rad*Math.sin(vscale*j));
			 }
		 }
		 return v;
	 }
	 public void iconDoubleClicked() {
		 final ValueSlider thicknessSlider = new ValueSlider(0.0, 1.0, 100, thickness);
		 int i, minu, minv;
		 thicknessSlider.setEnabled(shape == TORUS);
		 ValueField usizeField = new ValueField((double) usize, ValueField.POSITIVE+ValueField.INTEGER);
		 ValueField vsizeField = new ValueField((double) vsize, ValueField.POSITIVE+ValueField.INTEGER);
		 BComboBox smoothingChoice = new BComboBox(new String [] {
		 Translate.text(""Interpolating""), Translate.text(""Approximating"") }
		);
		 if (smoothing == Mesh.INTERPOLATING) smoothingChoice.setSelectedIndex(0);
		 else smoothingChoice.setSelectedIndex(1);
		 final BComboBox shapeChoice = new BComboBox(new String [] {
		 Translate.text(""Flat""), Translate.text(""Cylinder""), Translate.text(""Torus"") }
		);
		 if (shape == FLAT) shapeChoice.setSelectedIndex(0);
		 else if (shape == CYLINDER) shapeChoice.setSelectedIndex(1);
		 else shapeChoice.setSelectedIndex(2);
		 shapeChoice.addEventLink(ValueChangedEvent.class, new Object() {
			 void processEvent() {
				 thicknessSlider.setEnabled(shapeChoice.getSelectedIndex() == 2);
			 }
		 }
		);
		 ComponentsDialog dlg = new ComponentsDialog(theFrame, Translate.text(""selectMeshSizeShape""), new Widget [] {
		usizeField, vsizeField, shapeChoice, smoothingChoice, thicknessSlider}
		, new String [] {
		Translate.text(""uSize""), Translate.text(""vSize""), Translate.text(""Shape""), Translate.text(""Smoothing Method""), Translate.text(""Thickness"")}
		);
		 if (!dlg.clickedOk()) return;
		 minu = shapeChoice.getSelectedIndex() == 0 ? 2 : 3;
		 minv = shapeChoice.getSelectedIndex() == 2 ? 3 : 2;
		 if (usizeField.getValue() < minu) {
			 new BStandardDialog("""", Translate.text(""uSizeTooSmall"", Integer.toString(minu)), BStandardDialog.ERROR).showMessageDialog(theFrame);
			 return;
		 }
		 if (vsizeField.getValue() < minv) {
			 new BStandardDialog("""", Translate.text(""vSizeTooSmall"", Integer.toString(minv)), BStandardDialog.ERROR).showMessageDialog(theFrame);
			 return;
		 }
		 usize = (int) usizeField.getValue();
		 vsize = (int) vsizeField.getValue();
		 i = smoothingChoice.getSelectedIndex();
		 if (i == 0) smoothing = Mesh.INTERPOLATING;
		 else smoothing = Mesh.APPROXIMATING;
		 i = shapeChoice.getSelectedIndex();
		 if (i == 0) shape = FLAT;
		 else if (i == 1) shape = CYLINDER;
		 else shape = TORUS;
		 thickness = thicknessSlider.getValue();
		 setHelpText();
	 }
}",1,0,0,0
"public final class LiveSignalEnforcement extends AbstractEnforcement<Signal> {
	 private static final int CACHE_TIMEOUT_SECONDS = 2 * 60;
	 private final EnforcerRetriever enforcerRetriever;
	 private final Cache<String, ActorRef> responseReceivers;
	 private LiveSignalEnforcement(final Context context, final Cache<EntityId, Entry<EntityId>> thingIdCache, final Cache<EntityId, Entry<Enforcer>> policyEnforcerCache, final Cache<EntityId, Entry<Enforcer>> aclEnforcerCache) {
		 super(context);
		 requireNonNull(thingIdCache);
		 requireNonNull(policyEnforcerCache);
		 requireNonNull(aclEnforcerCache);
		 enforcerRetriever = PolicyOrAclEnforcerRetrieverFactory.create(thingIdCache, policyEnforcerCache, aclEnforcerCache);
		 final Caffeine<Object, Object> caffeine = Caffeine.newBuilder() .expireAfterWrite(CACHE_TIMEOUT_SECONDS, TimeUnit.SECONDS);
		 responseReceivers = CaffeineCache.of(caffeine);
	 }
	 public static final class Provider implements EnforcementProvider<Signal> {
		 private final Cache<EntityId, Entry<EntityId>> thingIdCache;
		 private final Cache<EntityId, Entry<Enforcer>> policyEnforcerCache;
		 private final Cache<EntityId, Entry<Enforcer>> aclEnforcerCache;
		 public Provider(final Cache<EntityId, Entry<EntityId>> thingIdCache, final Cache<EntityId, Entry<Enforcer>> policyEnforcerCache, final Cache<EntityId, Entry<Enforcer>> aclEnforcerCache) {
			 this.thingIdCache = requireNonNull(thingIdCache);
			 this.policyEnforcerCache = requireNonNull(policyEnforcerCache);
			 this.aclEnforcerCache = requireNonNull(aclEnforcerCache);
		 }
		 public Class<Signal> getCommandClass() {
			 return Signal.class;
		 }
		 public boolean isApplicable(final Signal signal) {
			 return LiveSignalEnforcement.isLiveSignal(signal);
		 }
		 public AbstractEnforcement<Signal> createEnforcement(final Context context) {
			 return new LiveSignalEnforcement(context, thingIdCache, policyEnforcerCache, aclEnforcerCache);
		 }
	 }
	 public CompletionStage<Void> enforce(final Signal signal, final ActorRef sender, final DiagnosticLoggingAdapter log) {
		 LogUtil.enhanceLogWithCorrelationIdOrRandom(signal);
		 return enforcerRetriever.retrieve(entityId(), (enforcerKeyEntry, enforcerEntry) -> {
			 if (enforcerEntry.exists()) {
				 final Enforcer enforcer = enforcerEntry.getValue();
				 final String correlationId = signal.getDittoHeaders().getCorrelationId().get();
				 if (signal instanceof SendClaimMessage) {
					 publishMessageCommand((SendClaimMessage) signal, enforcer, sender);
					 if (signal.getDittoHeaders().isResponseRequired()) {
						 responseReceivers.put(correlationId, sender);
					 }
				 }
				 else if (signal instanceof CommandResponse) {
					 final Optional<ActorRef> responseReceiver = responseReceivers.getBlocking(correlationId);
					 if (responseReceiver.isPresent()) {
						 responseReceiver.get().tell(signal, sender);
						 responseReceivers.invalidate(correlationId);
					 }
					 else {
						 log(signal).warning(""No outstanding responses receiver for CommandResponse <{
						}
						>"", signal.getType());
					 }
				 }
				 else if (signal instanceof Command) {
					 if (signal instanceof MessageCommand) {
						 final boolean wasPublished = enforceMessageCommand((MessageCommand) signal, enforcer, sender);
						 if (wasPublished && signal.getDittoHeaders().isResponseRequired()) {
							 responseReceivers.put(correlationId, sender);
						 }
					 }
					 else if (signal instanceof ThingCommand) {
						 final boolean authorized;
						 if (enforcer instanceof AclEnforcer) {
							 authorized = ThingCommandEnforcement.authorizeByAcl(enforcer, (ThingCommand<?>) signal) .isPresent();
						 }
						 else {
							 authorized = ThingCommandEnforcement.authorizeByPolicy(enforcer, (ThingCommand<?>) signal) .isPresent();
						 }
						 if (authorized) {
							 final Command<?> withReadSubjects = addReadSubjectsToThingSignal((Command<?>) signal, enforcer);
							 log(withReadSubjects).info(""Live Command was authorized: <{
							}
							>"", withReadSubjects);
							 publishToMediator(withReadSubjects, StreamingType.LIVE_COMMANDS.getDistributedPubSubTopic(), sender);
							 if (signal.getDittoHeaders().isResponseRequired()) {
								 responseReceivers.put(correlationId, sender);
							 }
						 }
						 else {
							 log(signal).info(""Live Command was NOT authorized: <{
							}
							>"", signal);
							 ThingCommandEnforcement.respondWithError((ThingCommand) signal, sender, self());
						 }
					 }
					 else {
						 log(signal).error(""Ignoring unsupported live signal: <{
						}
						>"", signal);
					 }
				 }
				 else if (signal instanceof ThingEvent) {
					 final boolean authorized = enforcer.hasUnrestrictedPermissions( PoliciesResourceType.thingResource(""/""), signal.getDittoHeaders().getAuthorizationContext(), WRITE);
					 if (authorized) {
						 log(signal).info(""Live Event was authorized: <{
						}
						>"", signal);
						 final Event<?> withReadSubjects = addReadSubjectsToThingSignal((Event<?>) signal, enforcer);
						 publishToMediator(withReadSubjects, StreamingType.LIVE_EVENTS.getDistributedPubSubTopic(), sender);
					 }
					 else {
						 final EventSendNotAllowedException eventSendNotAllowedException = EventSendNotAllowedException.newBuilder(((ThingEvent) signal).getThingId()) .dittoHeaders(signal.getDittoHeaders()) .build();
						 log(signal).info(""Live Event was NOT authorized: <{
						}
						>"", signal);
						 replyToSender(eventSendNotAllowedException, sender);
					 }
				 }
			 }
			 else {
				 log(signal).info(""Command of type <{
				}
				> with ID <{
				}
				> could not be dispatched as no enforcer could be"" + "" looked up! Answering with ThingNotAccessibleException."", signal.getType(), signal.getId());
				 final ThingNotAccessibleException error = ThingNotAccessibleException.newBuilder(entityId().getId()) .dittoHeaders(signal.getDittoHeaders()) .build();
				 replyToSender(error, sender);
			 }
		 }
		);
	 }
	 static boolean isLiveSignal(final Signal signal) {
		 return signal.getDittoHeaders().getChannel().filter(TopicPath.Channel.LIVE.getName()::equals).isPresent();
	 }
	 private boolean enforceMessageCommand(final MessageCommand command, final Enforcer enforcer, final ActorRef sender) {
		 if (isAuthorized(command, enforcer)) {
			 publishMessageCommand(command, enforcer, sender);
			 return true;
		 }
		 else {
			 rejectMessageCommand(command, sender);
			 return false;
		 }
	 }
	 private void publishMessageCommand(final MessageCommand command, final Enforcer enforcer, final ActorRef sender) {
		 final ResourceKey resourceKey = ResourceKey.newInstance(MessageCommand.RESOURCE_TYPE, command.getResourcePath());
		 final Set<String> messageReaders = enforcer.getSubjectIdsWithPermission(resourceKey, Permission.READ) .getGranted();
		 final DittoHeaders headersWithReadSubjects = command.getDittoHeaders() .toBuilder() .readSubjects(messageReaders) .build();
		 final MessageCommand commandWithReadSubjects = command.setDittoHeaders(headersWithReadSubjects);
		 publishToMediator(commandWithReadSubjects, commandWithReadSubjects.getTypePrefix(), sender);
		 getResponseForFireAndForgetMessage(commandWithReadSubjects) .ifPresent(response -> replyToSender(response, sender));
	 }
	 private void rejectMessageCommand(final MessageCommand command, final ActorRef sender) {
		 final MessageSendNotAllowedException error = MessageSendNotAllowedException.newBuilder(command.getThingId()) .dittoHeaders(command.getDittoHeaders()) .build();
		 log(command).info( ""The command <{
		}
		> was not forwarded due to insufficient rights {
		}
		: {
		}
		 - AuthorizationSubjects: {
		}
		"", command.getType(), error.getClass().getSimpleName(), error.getMessage(), command.getDittoHeaders().getAuthorizationSubjects());
		 replyToSender(error, sender);
	 }
	 private void publishToMediator(final Signal<?> command, final String pubSubTopic, final ActorRef sender) {
		 log(command).debug(""Publish message to pub-sub: <{
		}
		>"", pubSubTopic);
		 final DistributedPubSubMediator.Publish publishMessage = new DistributedPubSubMediator.Publish(pubSubTopic, command, true);
		 pubSubMediator().tell(publishMessage, sender);
	 }
	 private static boolean isAuthorized(final MessageCommand command, final Enforcer enforcer) {
		 return enforcer.hasUnrestrictedPermissions( PoliciesResourceType.messageResource(command.getResourcePath()), command.getDittoHeaders().getAuthorizationContext(), WRITE);
	 }
	 private static Optional<SendMessageAcceptedResponse> getResponseForFireAndForgetMessage( final MessageCommand<?, ?> command) {
		 if (isFireAndForgetMessage(command)) {
			 return Optional.of( SendMessageAcceptedResponse.newInstance(command.getThingId(), command.getMessage().getHeaders(), command.getDittoHeaders()));
		 }
		 else {
			 return Optional.empty();
		 }
	 }
	 private static boolean isFireAndForgetMessage(final MessageCommand<?, ?> command) {
		 return command.getMessage() .getTimeout() .map(Duration::isZero) .orElseGet(() -> !command.getDittoHeaders().isResponseRequired());
	 }
}",1,0,0,0
"private static void applyMigrationOnStage(final Migration m) throws InvalidRequestException {
	 Future f = StageManager.getStage(Stage.MIGRATION).submit(new Callable() {
		 public Object call() throws Exception {
			 m.apply();
			 m.announce();
			 return null;
		 }
	 }
	);
	 try {
		 f.get();
	 }
	 catch (InterruptedException e) {
		 throw new RuntimeException(e);
	 }
	 catch (ExecutionException e) {
		 if (e.getCause() != null) {
			 throw newInvalidRequestException(e.getCause());
		 }
		 else {
			 throw newInvalidRequestException(e);
		 }
	 }
 }",0,0,0,0
"public class MyUDFWithoutParameter extends EvalFunc<Integer> {
	private int count = 0;
	public Integer exec(Tuple input) throws IOException {
		return ++count;
	}
}",1,0,0,0
"public void initialize(BSFManager mgr, String lang,Vector declaredBeans) throws BSFException {
	 super.initialize(mgr, lang, declaredBeans);
	 mgrfuncs = new BSFFunctions (mgr, this);
 }",0,0,0,0
"public void from(String from) throws IOException {
	 sendFrom(from);
	 this.from = from;
 }",0,0,0,0
"public static class School extends KeyedObject {
	 private String _schoolName;
	 private boolean _isGrammarSchool;
	 public School( String schoolName, boolean isGrammarSchool ) {
		 _schoolName = schoolName;
		 _isGrammarSchool = isGrammarSchool;
	 }
	 public String getSchoolName() {
		 return _schoolName;
	 }
	 public boolean isGrammarSchool() {
		 return _isGrammarSchool;
	 }
	 protected void createMinion( Database database ) throws SQLException {
		 Connection conn = database.getConnection();
		 PreparedStatement ps = Utils.prepare ( conn, ""insert into School( schoolName ) values ( ? )"" );
		 ps.setString( 1, _schoolName );
		 ps.execute();
		 Utils.close( ps );
	 }
	 protected PreparedStatement getKeyFinder( Database database ) throws SQLException {
		 Connection conn = database.getConnection();
		 PreparedStatement ps = Utils.prepare ( conn, ""select schoolID from School where schoolName = ?"" );
		 ps.setString( 1, _schoolName );
		 return ps;
	 }
 }",0,0,0,0
"class CsvInputArchive implements InputArchive {
	 private PushbackReader stream;
	 private class CsvIndex implements Index {
		 public boolean done() {
			 char c = '\0';
			 try {
				 c = (char) stream.read();
				 stream.unread(c);
			 }
			 catch (IOException ex) {
			 }
		 return (c == '}
		') ? true : false;
	 }
	 public void incr() {
	}
 }
 private void throwExceptionOnError(String tag) throws IOException {
	 throw new IOException(""Error deserializing ""+tag);
 }
 private String readField(String tag) throws IOException {
	 try {
		 StringBuffer buf = new StringBuffer();
		 while (true) {
			 char c = (char) stream.read();
			 switch (c) {
				 case ',': return buf.toString();
			 case '}
			': case '\n': case '\r': stream.unread(c);
			 return buf.toString();
			 default: buf.append(c);
		 }
	 }
 }
 catch (IOException ex) {
	 throw new IOException(""Error reading ""+tag);
 }
 }
 static CsvInputArchive getArchive(InputStream strm) throws UnsupportedEncodingException {
 return new CsvInputArchive(strm);
 }
 public CsvInputArchive(InputStream in) throws UnsupportedEncodingException {
 stream = new PushbackReader(new InputStreamReader(in, ""UTF-8""));
 }
 public byte readByte(String tag) throws IOException {
 return (byte) readLong(tag);
 }
 public boolean readBool(String tag) throws IOException {
 String sval = readField(tag);
 return ""T"".equals(sval) ? true : false;
 }
 public int readInt(String tag) throws IOException {
 return (int) readLong(tag);
 }
 public long readLong(String tag) throws IOException {
 String sval = readField(tag);
 try {
	 long lval = Long.parseLong(sval);
	 return lval;
 }
 catch (NumberFormatException ex) {
	 throw new IOException(""Error deserializing ""+tag);
 }
 }
 public float readFloat(String tag) throws IOException {
 return (float) readDouble(tag);
 }
 public double readDouble(String tag) throws IOException {
 String sval = readField(tag);
 try {
	 double dval = Double.parseDouble(sval);
	 return dval;
 }
 catch (NumberFormatException ex) {
	 throw new IOException(""Error deserializing ""+tag);
 }
 }
 public Text readString(String tag) throws IOException {
 String sval = readField(tag);
 return Utils.fromCSVString(sval);
 }
 public ByteArrayOutputStream readBuffer(String tag) throws IOException {
 String sval = readField(tag);
 return Utils.fromCSVBuffer(sval);
 }
 public void readRecord(Record r, String tag) throws IOException {
 r.deserialize(this, tag);
 }
 public void startRecord(String tag) throws IOException {
 if (tag != null && !"""".equals(tag)) {
	 char c1 = (char) stream.read();
	 char c2 = (char) stream.read();
	 if (c1 != 's' || c2 != '{
		') {
			 throw new IOException(""Error deserializing ""+tag);
		 }
	 }
 }
 public void endRecord(String tag) throws IOException {
	 char c = (char) stream.read();
	 if (tag == null || """".equals(tag)) {
		 if (c != '\n' && c != '\r') {
			 throw new IOException(""Error deserializing record."");
		 }
		 else {
			 return;
		 }
	 }
 if (c != '}
') {
	 throw new IOException(""Error deserializing ""+tag);
 }
 c = (char) stream.read();
 if (c != ',') {
	 stream.unread(c);
 }
 return;
 }
 public Index startVector(String tag) throws IOException {
 char c1 = (char) stream.read();
 char c2 = (char) stream.read();
 if (c1 != 'v' || c2 != '{
	') {
		 throw new IOException(""Error deserializing ""+tag);
	 }
	 return new CsvIndex();
 }
 public void endVector(String tag) throws IOException {
	 char c = (char) stream.read();
 if (c != '}
') {
	 throw new IOException(""Error deserializing ""+tag);
 }
 c = (char) stream.read();
 if (c != ',') {
	 stream.unread(c);
 }
 return;
 }
 public Index startMap(String tag) throws IOException {
 char c1 = (char) stream.read();
 char c2 = (char) stream.read();
 if (c1 != 'm' || c2 != '{
	') {
		 throw new IOException(""Error deserializing ""+tag);
	 }
	 return new CsvIndex();
 }
 public void endMap(String tag) throws IOException {
	 char c = (char) stream.read();
 if (c != '}
') {
	 throw new IOException(""Error deserializing ""+tag);
 }
 c = (char) stream.read();
 if (c != ',') {
	 stream.unread(c);
 }
 return;
 }
}",0,0,0,0
"public class AsciiType extends AbstractType<String>{
	 public static final AsciiType instance = new AsciiType();
	 AsciiType() {
	}
	 public String getString(ByteBuffer bytes) {
		 try {
			 return JdbcAscii.instance.getString(bytes);
		 }
		 catch (org.apache.cassandra.cql.jdbc.MarshalException e) {
			 throw new MarshalException(e.getMessage());
		 }
	 }
	 public int compare(ByteBuffer o1, ByteBuffer o2) {
		 return BytesType.bytesCompare(o1, o2);
	 }
	 public String compose(ByteBuffer bytes) {
		 return JdbcAscii.instance.getString(bytes);
	 }
	 public ByteBuffer decompose(String value) {
		 return JdbcAscii.instance.decompose(value);
	 }
	 public ByteBuffer fromString(String source) {
		 return decompose(source);
	 }
	 public void validate(ByteBuffer bytes) throws MarshalException {
		 for (int i = bytes.position();
		 i < bytes.limit();
		 i++) {
			 byte b = bytes.get(i);
			 if (b < 0 || b > 127) throw new MarshalException(""Invalid byte for ascii: "" + Byte.toString(b));
		 }
	 }
}",0,0,0,0
"public class MetricsSystemImpl extends MetricsSystem implements MetricsSource {
	 static final Log LOG = LogFactory.getLog(MetricsSystemImpl.class);
	 static final String MS_NAME = ""MetricsSystem"";
	 static final String MS_STATS_NAME = MS_NAME +"",sub=Stats"";
	 static final String MS_STATS_DESC = ""Metrics system metrics"";
	 static final String MS_CONTROL_NAME = MS_NAME +"",sub=Control"";
	 static final String MS_INIT_MODE_KEY = ""hadoop.metrics.init.mode"";
	 enum InitMode {
	 NORMAL, STANDBY }
	 private final Map<String, MetricsSourceAdapter> sources;
	 private final Map<String, MetricsSource> allSources;
	 private final Map<String, MetricsSinkAdapter> sinks;
	 private final Map<String, MetricsSink> allSinks;
	 private final List<Callback> callbacks;
	 private final MetricsCollectorImpl collector;
	 private final MetricsRegistry registry = new MetricsRegistry(MS_NAME);
	 MutableStat snapshotStat;
	 MutableStat publishStat;
	 MutableCounterLong droppedPubAll;
	 private final List<MetricsTag> injectedTags;
	 private String prefix;
	 private MetricsFilter sourceFilter;
	 private MetricsConfig config;
	 private Map<String, MetricsConfig> sourceConfigs, sinkConfigs;
	 private boolean monitoring = false;
	 private Timer timer;
	 private int period;
	 private long logicalTime;
	 private ObjectName mbeanName;
	 private boolean publishSelfMetrics = true;
	 private MetricsSourceAdapter sysSource;
	 private int refCount = 0;
	 public MetricsSystemImpl(String prefix) {
		 this.prefix = prefix;
		 allSources = Maps.newHashMap();
		 sources = Maps.newLinkedHashMap();
		 allSinks = Maps.newHashMap();
		 sinks = Maps.newLinkedHashMap();
		 sourceConfigs = Maps.newHashMap();
		 sinkConfigs = Maps.newHashMap();
		 callbacks = Lists.newArrayList();
		 injectedTags = Lists.newArrayList();
		 collector = new MetricsCollectorImpl();
		 if (prefix != null) {
			 initSystemMBean();
		 }
	 }
	 public MetricsSystemImpl() {
		 this(null);
	 }
	 public synchronized MetricsSystem init(String prefix) {
		 if (monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
			 LOG.warn(this.prefix +"" metrics system already initialized!"");
			 return this;
		 }
		 this.prefix = checkNotNull(prefix, ""prefix"");
		 ++refCount;
		 if (monitoring) {
			 LOG.info(this.prefix +"" metrics system started (again)"");
			 return this;
		 }
		 switch (initMode()) {
			 case NORMAL: try {
				 start();
			 }
			 catch (MetricsConfigException e) {
				 LOG.warn(""Metrics system not started: ""+ e.getMessage());
				 LOG.debug(""Stacktrace: "", e);
			 }
			 break;
			 case STANDBY: LOG.info(prefix +"" metrics system started in standby mode"");
		 }
		 initSystemMBean();
		 return this;
	 }
	 public synchronized void start() {
		 checkNotNull(prefix, ""prefix"");
		 if (monitoring) {
			 LOG.warn(prefix +"" metrics system already started!"", new MetricsException(""Illegal start""));
			 return;
		 }
		 for (Callback cb : callbacks) cb.preStart();
		 configure(prefix);
		 startTimer();
		 monitoring = true;
		 LOG.info(prefix +"" metrics system started"");
		 for (Callback cb : callbacks) cb.postStart();
	 }
	 public synchronized void stop() {
		 if (!monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
			 LOG.warn(prefix +"" metrics system not yet started!"", new MetricsException(""Illegal stop""));
			 return;
		 }
		 if (!monitoring) {
			 LOG.info(prefix +"" metrics system stopped (again)"");
			 return;
		 }
		 for (Callback cb : callbacks) cb.preStop();
		 LOG.info(""Stopping ""+ prefix +"" metrics system..."");
		 stopTimer();
		 stopSources();
		 stopSinks();
		 clearConfigs();
		 monitoring = false;
		 LOG.info(prefix +"" metrics system stopped."");
		 for (Callback cb : callbacks) cb.postStop();
	 }
	 public synchronized <T> T register(String name, String desc, T source) {
		 MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);
		 final MetricsSource s = sb.build();
		 MetricsInfo si = sb.info();
		 String name2 = name == null ? si.name() : name;
		 final String finalDesc = desc == null ? si.description() : desc;
		 final String finalName = DefaultMetricsSystem.sourceName(name2, !monitoring);
		 allSources.put(finalName, s);
		 LOG.debug(finalName +"", ""+ finalDesc);
		 if (monitoring) {
			 registerSource(finalName, finalDesc, s);
		 }
		 register(new AbstractCallback() {
			 public void postStart() {
				 registerSource(finalName, finalDesc, s);
			 }
		 }
		);
		 return source;
	 }
	 public synchronized void unregisterSource(String name) {
		 if (sources.containsKey(name)) {
			 sources.get(name).stop();
			 sources.remove(name);
		 }
		 if (allSources.containsKey(name)) {
			 allSources.remove(name);
		 }
	 }
	 synchronized void registerSource(String name, String desc, MetricsSource source) {
		 checkNotNull(config, ""config"");
		 MetricsConfig conf = sourceConfigs.get(name);
		 MetricsSourceAdapter sa = new MetricsSourceAdapter(prefix, name, desc, source, injectedTags, period, conf != null ? conf : config.subset(SOURCE_KEY));
		 sources.put(name, sa);
		 sa.start();
		 LOG.debug(""Registered source ""+ name);
	 }
	 public synchronized <T extends MetricsSink> T register(final String name, final String description, final T sink) {
		 LOG.debug(name +"", ""+ description);
		 if (allSinks.containsKey(name)) {
			 LOG.warn(""Sink ""+ name +"" already exists!"");
			 return sink;
		 }
		 allSinks.put(name, sink);
		 if (config != null) {
			 registerSink(name, description, sink);
		 }
		 register(new AbstractCallback() {
			 public void postStart() {
				 register(name, description, sink);
			 }
		 }
		);
		 return sink;
	 }
	 synchronized void registerSink(String name, String desc, MetricsSink sink) {
		 checkNotNull(config, ""config"");
		 MetricsConfig conf = sinkConfigs.get(name);
		 MetricsSinkAdapter sa = conf != null ? newSink(name, desc, sink, conf) : newSink(name, desc, sink, config.subset(SINK_KEY));
		 sinks.put(name, sa);
		 sa.start();
		 LOG.info(""Registered sink ""+ name);
	 }
	 public synchronized void register(final Callback callback) {
		 callbacks.add((Callback) Proxy.newProxyInstance( callback.getClass().getClassLoader(), new Class<?>[] {
		 Callback.class }
		, new InvocationHandler() {
			 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				 try {
					 return method.invoke(callback, args);
				 }
				 catch (Exception e) {
					 LOG.warn(""Caught exception in callback ""+ method.getName(), e);
				 }
				 return null;
			 }
		 }
		));
	 }
	 public synchronized void startMetricsMBeans() {
		 for (MetricsSourceAdapter sa : sources.values()) {
			 sa.startMBeans();
		 }
	 }
	 public synchronized void stopMetricsMBeans() {
		 for (MetricsSourceAdapter sa : sources.values()) {
			 sa.stopMBeans();
		 }
	 }
	 public synchronized String currentConfig() {
		 PropertiesConfiguration saver = new PropertiesConfiguration();
		 StringWriter writer = new StringWriter();
		 saver.copy(config);
		 try {
			 saver.save(writer);
		 }
		 catch (Exception e) {
			 throw new MetricsConfigException(""Error stringify config"", e);
		 }
		 return writer.toString();
	 }
	 private synchronized void startTimer() {
		 if (timer != null) {
			 LOG.warn(prefix +"" metrics system timer already started!"");
			 return;
		 }
		 logicalTime = 0;
		 long millis = period * 1000;
		 timer = new Timer(""Timer for '""+ prefix +""' metrics system"", true);
		 timer.scheduleAtFixedRate(new TimerTask() {
			 public void run() {
				 try {
					 onTimerEvent();
				 }
				 catch (Exception e) {
					 LOG.warn(e);
				 }
			 }
		 }
		, millis, millis);
		 LOG.info(""Scheduled snapshot period at ""+ period +"" second(s)."");
	 }
	 synchronized void onTimerEvent() {
		 logicalTime += period;
		 if (sinks.size() > 0) {
			 publishMetrics(sampleMetrics(), false);
		 }
	 }
	 public void publishMetricsNow() {
		 if (sinks.size() > 0) {
			 publishMetrics(sampleMetrics(), true);
		 }
	 }
	 synchronized MetricsBuffer sampleMetrics() {
		 collector.clear();
		 MetricsBufferBuilder bufferBuilder = new MetricsBufferBuilder();
		 for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
			 if (sourceFilter == null || sourceFilter.accepts(entry.getKey())) {
				 snapshotMetrics(entry.getValue(), bufferBuilder);
			 }
		 }
		 if (publishSelfMetrics) {
			 snapshotMetrics(sysSource, bufferBuilder);
		 }
		 MetricsBuffer buffer = bufferBuilder.get();
		 return buffer;
	 }
	 private void snapshotMetrics(MetricsSourceAdapter sa, MetricsBufferBuilder bufferBuilder) {
		 long startTime = Time.now();
		 bufferBuilder.add(sa.name(), sa.getMetrics(collector, true));
		 collector.clear();
		 snapshotStat.add(Time.now() - startTime);
		 LOG.debug(""Snapshotted source ""+ sa.name());
	 }
	 synchronized void publishMetrics(MetricsBuffer buffer, boolean immediate) {
		 int dropped = 0;
		 for (MetricsSinkAdapter sa : sinks.values()) {
			 long startTime = Time.now();
			 boolean result;
			 if (immediate) {
				 result = sa.putMetricsImmediate(buffer);
			 }
			 else {
				 result = sa.putMetrics(buffer, logicalTime);
			 }
			 dropped += result ? 0 : 1;
			 publishStat.add(Time.now() - startTime);
		 }
		 droppedPubAll.incr(dropped);
	 }
	 private synchronized void stopTimer() {
		 if (timer == null) {
			 LOG.warn(prefix +"" metrics system timer already stopped!"");
			 return;
		 }
		 timer.cancel();
		 timer = null;
	 }
	 private synchronized void stopSources() {
		 for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
			 MetricsSourceAdapter sa = entry.getValue();
			 LOG.debug(""Stopping metrics source ""+ entry.getKey() + "": class="" + sa.source().getClass());
			 sa.stop();
		 }
		 sysSource.stop();
		 sources.clear();
	 }
	 private synchronized void stopSinks() {
		 for (Entry<String, MetricsSinkAdapter> entry : sinks.entrySet()) {
			 MetricsSinkAdapter sa = entry.getValue();
			 LOG.debug(""Stopping metrics sink ""+ entry.getKey() + "": class="" + sa.sink().getClass());
			 sa.stop();
		 }
		 sinks.clear();
	 }
	 private synchronized void configure(String prefix) {
		 config = MetricsConfig.create(prefix);
		 configureSinks();
		 configureSources();
		 configureSystem();
	 }
	 private synchronized void configureSystem() {
		 injectedTags.add(Interns.tag(MsInfo.Hostname, getHostname()));
	 }
	 private synchronized void configureSinks() {
		 sinkConfigs = config.getInstanceConfigs(SINK_KEY);
		 int confPeriod = 0;
		 for (Entry<String, MetricsConfig> entry : sinkConfigs.entrySet()) {
			 MetricsConfig conf = entry.getValue();
			 int sinkPeriod = conf.getInt(PERIOD_KEY, PERIOD_DEFAULT);
			 confPeriod = confPeriod == 0 ? sinkPeriod : ArithmeticUtils.gcd(confPeriod, sinkPeriod);
			 String clsName = conf.getClassName("""");
			 if (clsName == null) continue;
			 String sinkName = entry.getKey();
			 try {
				 MetricsSinkAdapter sa = newSink(sinkName, conf.getString(DESC_KEY, sinkName), conf);
				 sa.start();
				 sinks.put(sinkName, sa);
			 }
			 catch (Exception e) {
				 LOG.warn(""Error creating sink '""+ sinkName +""'"", e);
			 }
		 }
		 period = confPeriod > 0 ? confPeriod : config.getInt(PERIOD_KEY, PERIOD_DEFAULT);
	 }
	 static MetricsSinkAdapter newSink(String name, String desc, MetricsSink sink, MetricsConfig conf) {
		 return new MetricsSinkAdapter(name, desc, sink, conf.getString(CONTEXT_KEY), conf.getFilter(SOURCE_FILTER_KEY), conf.getFilter(RECORD_FILTER_KEY), conf.getFilter(METRIC_FILTER_KEY), conf.getInt(PERIOD_KEY, PERIOD_DEFAULT), conf.getInt(QUEUE_CAPACITY_KEY, QUEUE_CAPACITY_DEFAULT), conf.getInt(RETRY_DELAY_KEY, RETRY_DELAY_DEFAULT), conf.getFloat(RETRY_BACKOFF_KEY, RETRY_BACKOFF_DEFAULT), conf.getInt(RETRY_COUNT_KEY, RETRY_COUNT_DEFAULT));
	 }
	 static MetricsSinkAdapter newSink(String name, String desc, MetricsConfig conf) {
		 return newSink(name, desc, (MetricsSink) conf.getPlugin(""""), conf);
	 }
	 private void configureSources() {
		 sourceFilter = config.getFilter(PREFIX_DEFAULT + SOURCE_FILTER_KEY);
		 sourceConfigs = config.getInstanceConfigs(SOURCE_KEY);
		 registerSystemSource();
	 }
	 private void clearConfigs() {
		 sinkConfigs.clear();
		 sourceConfigs.clear();
		 injectedTags.clear();
		 config = null;
	 }
	 static String getHostname() {
		 try {
			 return InetAddress.getLocalHost().getHostName();
		 }
		 catch (Exception e) {
			 LOG.error(""Error getting localhost name. Using 'localhost'..."", e);
		 }
		 return ""localhost"";
	 }
	 private void registerSystemSource() {
		 MetricsConfig sysConf = sourceConfigs.get(MS_NAME);
		 sysSource = new MetricsSourceAdapter(prefix, MS_STATS_NAME, MS_STATS_DESC, MetricsAnnotations.makeSource(this), injectedTags, period, sysConf == null ? config.subset(SOURCE_KEY) : sysConf);
		 sysSource.start();
	 }
	 public synchronized void getMetrics(MetricsCollector builder, boolean all) {
		 MetricsRecordBuilder rb = builder.addRecord(MS_NAME) .addGauge(MsInfo.NumActiveSources, sources.size()) .addGauge(MsInfo.NumAllSources, allSources.size()) .addGauge(MsInfo.NumActiveSinks, sinks.size()) .addGauge(MsInfo.NumAllSinks, allSinks.size());
		 for (MetricsSinkAdapter sa : sinks.values()) {
			 sa.snapshot(rb, all);
		 }
		 registry.snapshot(rb, all);
	 }
	 private void initSystemMBean() {
		 checkNotNull(prefix, ""prefix should not be null here!"");
		 if (mbeanName == null) {
			 mbeanName = MBeans.register(prefix, MS_CONTROL_NAME, this);
		 }
	 }
	 public synchronized boolean shutdown() {
		 LOG.debug(""refCount=""+ refCount);
		 if (refCount <= 0) {
			 LOG.debug(""Redundant shutdown"", new Throwable());
			 return true;
		 }
		 if (--refCount > 0) return false;
		 if (monitoring) {
			 try {
				 stop();
			 }
			 catch (Exception e) {
				 LOG.warn(""Error stopping the metrics system"", e);
			 }
		 }
		 allSources.clear();
		 allSinks.clear();
		 callbacks.clear();
		 if (mbeanName != null) {
			 MBeans.unregister(mbeanName);
			 mbeanName = null;
		 }
		 LOG.info(prefix +"" metrics system shutdown complete."");
		 return true;
	 }
	 public MetricsSource getSource(String name) {
		 return allSources.get(name);
	 }
	 MetricsSourceAdapter getSourceAdapter(String name) {
		 return sources.get(name);
	 }
	 private InitMode initMode() {
		 LOG.debug(""from system property: ""+ System.getProperty(MS_INIT_MODE_KEY));
		 LOG.debug(""from environment variable: ""+ System.getenv(MS_INIT_MODE_KEY));
		 String m = System.getProperty(MS_INIT_MODE_KEY);
		 String m2 = m == null ? System.getenv(MS_INIT_MODE_KEY) : m;
		 return InitMode.valueOf((m2 == null ? InitMode.NORMAL.name() : m2) .toUpperCase(Locale.US));
	 }
}",1,0,0,0
"public class FileRunner {
	 public String input;
	 public Parse tables;
	 public Fixture fixture = new Fixture();
	 public PrintWriter output;
	 public static void main(String argv[]) {
		 try {
			 new FileRunner().run(argv);
		}
		 catch (Exception e) {
			System.err.println(e.getMessage());
			System.exit(-1);
		}
	 }
	 public void run(String argv[]) throws IOException {
		 args(argv);
		 process();
		 exit();
	 }
	 public void process() {
		 try {
			 if (input.indexOf(""<wiki>"") >= 0) {
				 tables = new Parse(input, new String[]{
				""wiki"", ""table"", ""tr"", ""td""}
				);
				 fixture.doTables(tables.parts);
			 }
			 else {
				 tables = new Parse(input, new String[]{
				""table"", ""tr"", ""td""}
				);
				 fixture.doTables(tables);
			 }
		 }
		 catch (Exception e) {
			 exception(e);
		 }
		 tables.print(output);
	 }
	 public void args(String[] argv) throws IOException {
		 if (argv.length != 2) {
			 System.err.println(""usage: java fit.FileRunner input-file output-file"");
			 System.exit(-1);
		 }
		 File in = new File(argv[0]);
		 File out = new File(argv[1]);
		 fixture.summary.put(""input file"", in.getAbsolutePath());
		 fixture.summary.put(""input update"", new Date(in.lastModified()));
		 fixture.summary.put(""output file"", out.getAbsolutePath());
		 input = read(in);
		 output = new PrintWriter(new BufferedWriter(new FileWriter(out)));
	 }
	 protected String read(File input) throws IOException {
		 char chars[] = new char[(int) (input.length())];
		 FileReader in = new FileReader(input);
		 in.read(chars);
		 in.close();
		 return new String(chars);
	 }
	 protected void exception(Exception e) {
		 tables = new Parse(""body"", ""Unable to parse input. Input ignored."", null, null);
		 fixture.exception(tables, e);
	 }
	 protected void exit() {
		 output.close();
		 System.err.println(fixture.counts());
		 System.exit(fixture.counts.wrong + fixture.counts.exceptions);
	 }
}",0,0,0,0
"public class SetOrderReferenceDetailsRequest extends DelegateRequest<SetOrderReferenceDetailsRequest> implements Serializable {
	 protected SetOrderReferenceDetailsRequest getThis() {
		 return this;
	 }
	 private String amazonOrderReferenceId;
	 private String orderAmount;
	 private CurrencyCode orderCurrencyCode;
	 private String platformId;
	 private String sellerNote;
	 private String sellerOrderId;
	 private String storeName;
	 private String supplementaryData;
	 private String customInformation;
	 private Boolean requestPaymentAuthorization;
	 public SetOrderReferenceDetailsRequest(String amazonOrderReferenceId, String orderAmount) {
		 this.amazonOrderReferenceId = amazonOrderReferenceId;
		 this.orderAmount = orderAmount;
	 }
	 public SetOrderReferenceDetailsRequest setOrderCurrencyCode(CurrencyCode currencyCode) {
		 this.orderCurrencyCode = currencyCode;
		 return this;
	 }
	 public SetOrderReferenceDetailsRequest setPlatformId(String platformId) {
		 this.platformId = platformId;
		 return this;
	 }
	 public SetOrderReferenceDetailsRequest setSellerNote(String sellerNote) {
		 this.sellerNote = sellerNote;
		 return this;
	 }
	 public SetOrderReferenceDetailsRequest setSellerOrderId(String sellerOrderId) {
		 this.sellerOrderId = sellerOrderId;
		 return this;
	 }
	 public SetOrderReferenceDetailsRequest setStoreName(String storeName) {
		 this.storeName = storeName;
		 return this;
	 }
	 public SetOrderReferenceDetailsRequest setSupplementaryData(final String supplementaryData) {
		 this.supplementaryData = supplementaryData;
		 return this;
	 }
	 public SetOrderReferenceDetailsRequest setCustomInformation(String customInformation) {
		 this.customInformation = customInformation;
		 return this;
	 }
	 public String getAmazonOrderReferenceId() {
		 return amazonOrderReferenceId;
	 }
	 public String getOrderAmount() {
		 return orderAmount;
	 }
	 public CurrencyCode getOrderCurrencyCode() {
		 return orderCurrencyCode;
	 }
	 public String getPlatformId() {
		 return platformId;
	 }
	 public String getSellerNote() {
		 return sellerNote;
	 }
	 public String getSellerOrderId() {
		 return sellerOrderId;
	 }
	 public String getStoreName() {
		 return storeName;
	 }
	 public String getSupplementaryData() {
		 return supplementaryData;
	 }
	 public String getCustomInformation() {
		 return customInformation;
	 }
	 public Boolean getRequestPaymentAuthorization() {
		 return requestPaymentAuthorization;
	 }
	 public SetOrderReferenceDetailsRequest setRequestPaymentAuthorization(Boolean requestPaymentAuthorization) {
		 this.requestPaymentAuthorization = requestPaymentAuthorization;
		 return this;
	 }
	 public String toString() {
		 return ""SetOrderReferenceDetailsRequest{
		"" + ""amazonOrderReferenceId="" + amazonOrderReferenceId + "", orderAmount="" + orderAmount + "", orderCurrencyCode="" + orderCurrencyCode + "", platformId="" + platformId + "", sellerNote="" + sellerNote + "", sellerOrderId="" + sellerOrderId + "", storeName="" + storeName + "", supplementaryData="" + supplementaryData + "", customInformation="" + customInformation + "", mwsAuthToken="" + getMwsAuthToken() + '}
		';
	 }
}",1,1,0,0
"public class ListWorkRequestErrorsConverter {
	 private static final com.oracle.bmc.http.internal.ResponseConversionFunctionFactory RESPONSE_CONVERSION_FACTORY = new com.oracle.bmc.http.internal.ResponseConversionFunctionFactory();
	 public static ListWorkRequestErrorsRequest interceptRequest( ListWorkRequestErrorsRequest request) {
		 return request;
	 }
	 public static com.oracle.bmc.http.internal.WrappedInvocationBuilder fromRequest( com.oracle.bmc.http.internal.RestClient client, ListWorkRequestErrorsRequest request) {
		 Validate.notNull(request, ""request instance is required"");
		 Validate.notBlank(request.getWorkRequestId(), ""workRequestId must not be blank"");
		 com.oracle.bmc.http.internal.WrappedWebTarget target = client.getBaseTarget() .path(""/"") .path(""workRequests"") .path( com.oracle.bmc.util.internal.HttpUtils.encodePathSegment( request.getWorkRequestId())) .path(""errors"");
		 if (request.getPage() != null) {
			 target = target.queryParam( ""page"", com.oracle.bmc.util.internal.HttpUtils.attemptEncodeQueryParam( request.getPage()));
		 }
		 if (request.getLimit() != null) {
			 target = target.queryParam( ""limit"", com.oracle.bmc.util.internal.HttpUtils.attemptEncodeQueryParam( request.getLimit()));
		 }
		 com.oracle.bmc.http.internal.WrappedInvocationBuilder ib = target.request();
		 ib.accept(javax.ws.rs.core.MediaType.APPLICATION_JSON);
		 if (request.getOpcClientRequestId() != null) {
			 ib.header(""opc-client-request-id"", request.getOpcClientRequestId());
		 }
		 return ib;
	 }
	 public static com.google.common.base.Function< javax.ws.rs.core.Response, ListWorkRequestErrorsResponse> fromResponse() {
		 final com.google.common.base.Function< javax.ws.rs.core.Response, ListWorkRequestErrorsResponse> transformer = new com.google.common.base.Function< javax.ws.rs.core.Response, ListWorkRequestErrorsResponse>() {
			 public ListWorkRequestErrorsResponse apply( javax.ws.rs.core.Response rawResponse) {
				 LOG.trace( ""Transform function invoked for ListWorkRequestErrorsResponse"");
				 com.google.common.base.Function< javax.ws.rs.core.Response, com.oracle.bmc.http.internal.WithHeaders< java.util.List<WorkRequestError>>> responseFn = RESPONSE_CONVERSION_FACTORY.create( new javax.ws.rs.core.GenericType< java.util.List< WorkRequestError>>() {
				}
				);
				 com.oracle.bmc.http.internal.WithHeaders< java.util.List<WorkRequestError>> response = responseFn.apply(rawResponse);
				 javax.ws.rs.core.MultivaluedMap<String, String> headers = response.getHeaders();
				 ListWorkRequestErrorsResponse.Builder builder = ListWorkRequestErrorsResponse.builder();
				 builder.items(response.getItem());
				 com.google.common.base.Optional<java.util.List<String>> opcRequestIdHeader = com.oracle.bmc.http.internal.HeaderUtils.get( headers, ""opc-request-id"");
				 if (opcRequestIdHeader.isPresent()) {
					 builder.opcRequestId( com.oracle.bmc.http.internal.HeaderUtils.toValue( ""opc-request-id"", opcRequestIdHeader.get().get(0), String.class));
				 }
				 com.google.common.base.Optional<java.util.List<String>> opcNextPageHeader = com.oracle.bmc.http.internal.HeaderUtils.get( headers, ""opc-next-page"");
				 if (opcNextPageHeader.isPresent()) {
					 builder.opcNextPage( com.oracle.bmc.http.internal.HeaderUtils.toValue( ""opc-next-page"", opcNextPageHeader.get().get(0), String.class));
				 }
				 com.google.common.base.Optional<java.util.List<String>> opcClientRequestIdHeader = com.oracle.bmc.http.internal.HeaderUtils.get( headers, ""opc-client-request-id"");
				 if (opcClientRequestIdHeader.isPresent()) {
					 builder.opcClientRequestId( com.oracle.bmc.http.internal.HeaderUtils.toValue( ""opc-client-request-id"", opcClientRequestIdHeader.get().get(0), String.class));
				 }
				 ListWorkRequestErrorsResponse responseWrapper = builder.build();
				 return responseWrapper;
			 }
		 }
		;
		 return transformer;
	 }
}",0,0,0,0
"public class VMBridge_jdk11 extends VMBridge{
	 private Hashtable threadsWithContext = new Hashtable();
	 protected Object getThreadContextHelper() {
		 return Thread.currentThread();
	 }
	 protected Context getContext(Object contextHelper) {
		 Thread t = (Thread)contextHelper;
		 return (Context)threadsWithContext.get(t);
	 }
	 protected void setContext(Object contextHelper, Context cx) {
		 Thread t = (Thread)contextHelper;
		 if (cx == null) {
			 threadsWithContext.remove(t);
		 }
		 else {
			 threadsWithContext.put(t, cx);
		 }
	 }
	 protected ClassLoader getCurrentThreadClassLoader() {
		 return null;
	 }
	 protected boolean tryToMakeAccessible(Object accessibleObject) {
		 return false;
	 }
}",0,0,0,0
