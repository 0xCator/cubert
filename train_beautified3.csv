code,godclass,dataclass,longmethod,longparamlist
"public static double[] calculateMaxByColumns(DataSet dataSet) {
	int inputSize = dataSet.getInputSize();
	double[] maxColumnElements = new double[inputSize];
	for (int i = 0;
	 i < inputSize;
	 i++) {
		maxColumnElements[i] = Double.MIN_VALUE;
	}
	for (DataSetRow dataSetRow : dataSet.getRows()) {
		double[] input = dataSetRow.getInput();
		for (int i = 0;
		 i < inputSize;
		 i++) {
			maxColumnElements[i] = Math.max(maxColumnElements[i], input[i]);
		}
	}
	return maxColumnElements;
}",0,0,0,0
"public long getLength(Path f) throws IOException {
	 if (f instanceof DfsPath) {
		 return ((DfsPath)f).length();
	 }
	 DFSFileInfo info[] = dfs.listPaths(getPath(f));
	 return (info == null) ? 0 : info[0].getLen();
 }",0,0,0,0
"public abstract class EndpointDiscoverer<E extends ExposableEndpoint<O>, O extends Operation>implements EndpointsSupplier<E> {
	private final ApplicationContext applicationContext;
	private final Collection<EndpointFilter<E>> filters;
	private final DiscoveredOperationsFactory<O> operationsFactory;
	private final Map<EndpointBean, E> filterEndpoints = new ConcurrentHashMap<>();
	private volatile Collection<E> endpoints;
	public EndpointDiscoverer(ApplicationContext applicationContext,ParameterValueMapper parameterValueMapper,Collection<OperationInvokerAdvisor> invokerAdvisors,Collection<EndpointFilter<E>> filters) {
		Assert.notNull(applicationContext, ""ApplicationContext must not be null"");
		Assert.notNull(parameterValueMapper, ""ParameterValueMapper must not be null"");
		Assert.notNull(invokerAdvisors, ""InvokerAdvisors must not be null"");
		Assert.notNull(filters, ""Filters must not be null"");
		this.applicationContext = applicationContext;
		this.filters = Collections.unmodifiableCollection(filters);
		this.operationsFactory = getOperationsFactory(parameterValueMapper,invokerAdvisors);
	}
	private DiscoveredOperationsFactory<O> getOperationsFactory(ParameterValueMapper parameterValueMapper,Collection<OperationInvokerAdvisor> invokerAdvisors) {
		return new DiscoveredOperationsFactory<O>(parameterValueMapper, invokerAdvisors) {
			protected O createOperation(EndpointId endpointId,DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
				return EndpointDiscoverer.this.createOperation(endpointId,operationMethod, invoker);
			}
		}
		;
	}
	public final Collection<E> getEndpoints() {
		if (this.endpoints == null) {
			this.endpoints = discoverEndpoints();
		}
		return this.endpoints;
	}
	private Collection<E> discoverEndpoints() {
		Collection<EndpointBean> endpointBeans = createEndpointBeans();
		addExtensionBeans(endpointBeans);
		return convertToEndpoints(endpointBeans);
	}
	private Collection<EndpointBean> createEndpointBeans() {
		Map<EndpointId, EndpointBean> byId = new LinkedHashMap<>();
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(this.applicationContext, Endpoint.class);
		for (String beanName : beanNames) {
			if (!ScopedProxyUtils.isScopedTarget(beanName)) {
				EndpointBean endpointBean = createEndpointBean(beanName);
				EndpointBean previous = byId.putIfAbsent(endpointBean.getId(),endpointBean);
				Assert.state(previous == null,() -> ""Found two endpoints with the id '"" + endpointBean.getId()+ ""': '"" + endpointBean.getBeanName() + ""' and '""+ previous.getBeanName() + ""'"");
			}
		}
		return byId.values();
	}
	private EndpointBean createEndpointBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new EndpointBean(beanName, bean);
	}
	private void addExtensionBeans(Collection<EndpointBean> endpointBeans) {
		Map<EndpointId, EndpointBean> byId = endpointBeans.stream().collect(Collectors.toMap(EndpointBean::getId, Function.identity()));
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(this.applicationContext, EndpointExtension.class);
		for (String beanName : beanNames) {
			ExtensionBean extensionBean = createExtensionBean(beanName);
			EndpointBean endpointBean = byId.get(extensionBean.getEndpointId());
			Assert.state(endpointBean != null,() -> (""Invalid extension '"" + extensionBean.getBeanName()+ ""': no endpoint found with id '""+ extensionBean.getEndpointId() + ""'""));
			addExtensionBean(endpointBean, extensionBean);
		}
	}
	private ExtensionBean createExtensionBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new ExtensionBean(beanName, bean);
	}
	private void addExtensionBean(EndpointBean endpointBean,ExtensionBean extensionBean) {
		if (isExtensionExposed(endpointBean, extensionBean)) {
			Assert.state(isEndpointExposed(endpointBean) || isEndpointFiltered(endpointBean),() -> ""Endpoint bean '"" + endpointBean.getBeanName()+ ""' cannot support the extension bean '""+ extensionBean.getBeanName() + ""'"");
			endpointBean.addExtension(extensionBean);
		}
	}
	private Collection<E> convertToEndpoints(Collection<EndpointBean> endpointBeans) {
		Set<E> endpoints = new LinkedHashSet<>();
		for (EndpointBean endpointBean : endpointBeans) {
			if (isEndpointExposed(endpointBean)) {
				endpoints.add(convertToEndpoint(endpointBean));
			}
		}
		return Collections.unmodifiableSet(endpoints);
	}
	private E convertToEndpoint(EndpointBean endpointBean) {
		MultiValueMap<OperationKey, O> indexed = new LinkedMultiValueMap<>();
		EndpointId id = endpointBean.getId();
		addOperations(indexed, id, endpointBean.getBean(), false);
		if (endpointBean.getExtensions().size() > 1) {
			String extensionBeans = endpointBean.getExtensions().stream().map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(""Found multiple extensions for the endpoint bean ""+ endpointBean.getBeanName() + "" ("" + extensionBeans + "")"");
		}
		for (ExtensionBean extensionBean : endpointBean.getExtensions()) {
			addOperations(indexed, id, extensionBean.getBean(), true);
		}
		assertNoDuplicateOperations(endpointBean, indexed);
		List<O> operations = indexed.values().stream().map(this::getLast).filter(Objects::nonNull).collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));
		return createEndpoint(endpointBean.getBean(), id,endpointBean.isEnabledByDefault(), operations);
	}
	private void addOperations(MultiValueMap<OperationKey, O> indexed, EndpointId id,Object target, boolean replaceLast) {
		Set<OperationKey> replacedLast = new HashSet<>();
		Collection<O> operations = this.operationsFactory.createOperations(id, target);
		for (O operation : operations) {
			OperationKey key = createOperationKey(operation);
			O last = getLast(indexed.get(key));
			if (replaceLast && replacedLast.add(key) && last != null) {
				indexed.get(key).remove(last);
			}
			indexed.add(key, operation);
		}
	}
	private <T> T getLast(List<T> list) {
		return CollectionUtils.isEmpty(list) ? null : list.get(list.size() - 1);
	}
	private void assertNoDuplicateOperations(EndpointBean endpointBean,MultiValueMap<OperationKey, O> indexed) {
		List<OperationKey> duplicates = indexed.entrySet().stream().filter((entry) -> entry.getValue().size() > 1).map(Map.Entry::getKey).collect(Collectors.toList());
		if (!duplicates.isEmpty()) {
			Set<ExtensionBean> extensions = endpointBean.getExtensions();
			String extensionBeanNames = extensions.stream().map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(""Unable to map duplicate endpoint operations: ""+ duplicates.toString() + "" to "" + endpointBean.getBeanName()+ (extensions.isEmpty() ? """": "" ("" + extensionBeanNames + "")""));
		}
	}
	private boolean isExtensionExposed(EndpointBean endpointBean,ExtensionBean extensionBean) {
		return isFilterMatch(extensionBean.getFilter(), endpointBean)&& isExtensionExposed(extensionBean.getBean());
	}
	protected boolean isExtensionExposed(Object extensionBean) {
		return true;
	}
	private boolean isEndpointExposed(EndpointBean endpointBean) {
		return isFilterMatch(endpointBean.getFilter(), endpointBean)&& !isEndpointFiltered(endpointBean)&& isEndpointExposed(endpointBean.getBean());
	}
	protected boolean isEndpointExposed(Object endpointBean) {
		return true;
	}
	private boolean isEndpointFiltered(EndpointBean endpointBean) {
		for (EndpointFilter<E> filter : this.filters) {
			if (!isFilterMatch(filter, endpointBean)) {
				return true;
			}
		}
		return false;
	}
	private boolean isFilterMatch(Class<?> filter, EndpointBean endpointBean) {
		if (!isEndpointExposed(endpointBean.getBean())) {
			return false;
		}
		if (filter == null) {
			return true;
		}
		E endpoint = getFilterEndpoint(endpointBean);
		Class<?> generic = ResolvableType.forClass(EndpointFilter.class, filter).resolveGeneric(0);
		if (generic == null || generic.isInstance(endpoint)) {
			EndpointFilter<E> instance = (EndpointFilter<E>) BeanUtils.instantiateClass(filter);
			return isFilterMatch(instance, endpoint);
		}
		return false;
	}
	private boolean isFilterMatch(EndpointFilter<E> filter, EndpointBean endpointBean) {
		return isFilterMatch(filter, getFilterEndpoint(endpointBean));
	}
	private boolean isFilterMatch(EndpointFilter<E> filter, E endpoint) {
		return LambdaSafe.callback(EndpointFilter.class, filter, endpoint).withLogger(EndpointDiscoverer.class).invokeAnd((f) -> f.match(endpoint)).get();
	}
	private E getFilterEndpoint(EndpointBean endpointBean) {
		E endpoint = this.filterEndpoints.get(endpointBean);
		if (endpoint == null) {
			endpoint = createEndpoint(endpointBean.getBean(), endpointBean.getId(),endpointBean.isEnabledByDefault(), Collections.emptySet());
			this.filterEndpoints.put(endpointBean, endpoint);
		}
		return endpoint;
	}
	protected Class<? extends E> getEndpointType() {
		return (Class<? extends E>) ResolvableType.forClass(EndpointDiscoverer.class, getClass()).resolveGeneric(0);
	}
	protected abstract E createEndpoint(Object endpointBean, EndpointId id,boolean enabledByDefault, Collection<O> operations);
	protected abstract O createOperation(EndpointId endpointId,DiscoveredOperationMethod operationMethod, OperationInvoker invoker);
	protected abstract OperationKey createOperationKey(O operation);
	protected static final class OperationKey {
		private final Object key;
		private final Supplier<String> description;
		public OperationKey(Object key, Supplier<String> description) {
			Assert.notNull(key, ""Key must not be null"");
			Assert.notNull(description, ""Description must not be null"");
			this.key = key;
			this.description = description;
		}
		public boolean equals(Object obj) {
			if (obj == this) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.key.equals(((OperationKey) obj).key);
		}
		public int hashCode() {
			return this.key.hashCode();
		}
		public String toString() {
			return this.description.get();
		}
	}
	private static class EndpointBean {
		private final String beanName;
		private final Object bean;
		private final EndpointId id;
		private boolean enabledByDefault;
		private final Class<?> filter;
		private Set<ExtensionBean> extensions = new LinkedHashSet<>();
		EndpointBean(String beanName, Object bean) {
			AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(bean.getClass(), Endpoint.class, true,true);
			String id = attributes.getString(""id"");
			Assert.state(StringUtils.hasText(id),() -> ""No id attribute specified for ""+ bean.getClass().getName());
			this.beanName = beanName;
			this.bean = bean;
			this.id = EndpointId.of(id);
			this.enabledByDefault = (Boolean) attributes.get(""enableByDefault"");
			this.filter = getFilter(this.bean.getClass());
		}
		public void addExtension(ExtensionBean extensionBean) {
			this.extensions.add(extensionBean);
		}
		public Set<ExtensionBean> getExtensions() {
			return this.extensions;
		}
		private Class<?> getFilter(Class<?> type) {
			AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(type, FilteredEndpoint.class);
			if (attributes == null) {
				return null;
			}
			return attributes.getClass(""value"");
		}
		public String getBeanName() {
			return this.beanName;
		}
		public Object getBean() {
			return this.bean;
		}
		public EndpointId getId() {
			return this.id;
		}
		public boolean isEnabledByDefault() {
			return this.enabledByDefault;
		}
		public Class<?> getFilter() {
			return this.filter;
		}
	}
	private static class ExtensionBean {
		private final String beanName;
		private final Object bean;
		private final EndpointId endpointId;
		private final Class<?> filter;
		ExtensionBean(String beanName, Object bean) {
			this.bean = bean;
			this.beanName = beanName;
			AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(bean.getClass(),EndpointExtension.class);
			Class<?> endpointType = attributes.getClass(""endpoint"");
			AnnotationAttributes endpointAttributes = AnnotatedElementUtils.findMergedAnnotationAttributes(endpointType, Endpoint.class, true,true);
			Assert.state(endpointAttributes != null, () -> ""Extension ""+ endpointType.getName() + "" does not specify an endpoint"");
			this.endpointId = EndpointId.of(endpointAttributes.getString(""id""));
			this.filter = attributes.getClass(""filter"");
		}
		public String getBeanName() {
			return this.beanName;
		}
		public Object getBean() {
			return this.bean;
		}
		public EndpointId getEndpointId() {
			return this.endpointId;
		}
		public Class<?> getFilter() {
			return this.filter;
		}
	}
}",1,0,0,0
public void startTransaction(String name);,0,0,0,0
"public boolean getStripJavascriptCommentsAndWhitespace(){
	return stripJavascriptCommentsAndWhitespace;
}",0,0,0,0
"public final class ComputeFibonacciContinuationExample {
	 public static void main(String[] args) throws IgniteException {
		 try (Ignite ignite = Ignition.start(""examples/config/example-ignite.xml"")) {
			 System.out.println();
			 System.out.println(""Compute Fibonacci continuation example started."");
			 long N = 100;
			 final UUID exampleNodeId = ignite.cluster().localNode().id();
			 final IgnitePredicate<ClusterNode> nodeFilter = new IgnitePredicate<ClusterNode>() {
				 public boolean apply(ClusterNode n) {
					 return ignite.cluster().forRemotes().nodes().isEmpty() || !n.id().equals(exampleNodeId);
				 }
			 }
			;
			 long start = System.currentTimeMillis();
			 BigInteger fib = ignite.compute(ignite.cluster().forPredicate(nodeFilter)).apply( new ContinuationFibonacciClosure(nodeFilter), N);
			 long duration = System.currentTimeMillis() - start;
			 System.out.println();
			 System.out.println("">>> Finished executing Fibonacci for '"" + N + ""' in "" + duration + "" ms."");
			 System.out.println("">>> Fibonacci sequence for input number '"" + N + ""' is '"" + fib + ""'."");
			 System.out.println("">>> If you re-run this example w/o stopping remote nodes - the performance will"");
			 System.out.println("">>> increase since intermediate results are pre-cache on remote nodes."");
			 System.out.println("">>> You should see prints out every recursive Fibonacci execution on cluster nodes."");
			 System.out.println("">>> Check remote nodes for output."");
		 }
	 }
	 private static class ContinuationFibonacciClosure implements IgniteClosure<Long, BigInteger> {
		 private IgniteFuture<BigInteger> fut1;
		 private IgniteFuture<BigInteger> fut2;
		 private ComputeJobContext jobCtx;
		 private Ignite ignite;
		 private final IgnitePredicate<ClusterNode> nodeFilter;
		 ContinuationFibonacciClosure(IgnitePredicate<ClusterNode> nodeFilter) {
			 this.nodeFilter = nodeFilter;
		 }
		 public BigInteger apply(Long n) {
			 if (fut1 == null || fut2 == null) {
				 System.out.println();
				 System.out.println("">>> Starting fibonacci execution for number: "" + n);
				 n = Math.abs(n);
				 if (n <= 2) return n == 0 ? BigInteger.ZERO : BigInteger.ONE;
				 ConcurrentMap<Long, IgniteFuture<BigInteger>> locMap = ignite.cluster().nodeLocalMap();
				 fut1 = locMap.get(n - 1);
				 fut2 = locMap.get(n - 2);
				 ClusterGroup p = ignite.cluster().forPredicate(nodeFilter);
				 IgniteCompute compute = ignite.compute(p);
				 if (fut1 == null) {
					 IgniteFuture<BigInteger> futVal = compute.applyAsync( new ContinuationFibonacciClosure(nodeFilter), n - 1);
					 fut1 = locMap.putIfAbsent(n - 1, futVal);
					 if (fut1 == null) fut1 = futVal;
				 }
				 if (fut2 == null) {
					 IgniteFuture<BigInteger> futVal = compute.applyAsync( new ContinuationFibonacciClosure(nodeFilter), n - 2);
					 fut2 = locMap.putIfAbsent(n - 2, futVal);
					 if (fut2 == null) fut2 = futVal;
				 }
				 if (!fut1.isDone() || !fut2.isDone()) {
					 IgniteInClosure<IgniteFuture<BigInteger>> lsnr = new IgniteInClosure<IgniteFuture<BigInteger>>() {
						 public void apply(IgniteFuture<BigInteger> f) {
							 if (fut1.isDone() && fut2.isDone()) jobCtx.callcc();
						 }
					 }
					;
					 jobCtx.holdcc();
					 fut1.listen(lsnr);
					 fut2.listen(lsnr);
					 return null;
				 }
			 }
			 assert fut1.isDone() && fut2.isDone();
			 return fut1.get().add(fut2.get());
		 }
	 }
}",0,0,0,0
"public interface Profile{
	 public String NAMESPACE();
	 public Resource CLASS();
	 public Resource RESTRICTION();
	 public Resource THING();
	 public Resource NOTHING();
	 public Resource PROPERTY();
	 public Resource OBJECT_PROPERTY();
	 public Resource DATATYPE_PROPERTY();
	 public Resource TRANSITIVE_PROPERTY();
	 public Resource SYMMETRIC_PROPERTY();
	 public Resource FUNCTIONAL_PROPERTY();
	 public Resource INVERSE_FUNCTIONAL_PROPERTY();
	 public Resource ALL_DIFFERENT();
	 public Resource ONTOLOGY();
	 public Resource DEPRECATED_CLASS();
	 public Resource DEPRECATED_PROPERTY();
	 public Resource ANNOTATION_PROPERTY();
	 public Resource ONTOLOGY_PROPERTY();
	 public Resource DATARANGE();
	 public Property EQUIVALENT_PROPERTY();
	 public Property EQUIVALENT_CLASS();
	 public Property DISJOINT_WITH();
	 public Property SAME_INDIVIDUAL_AS();
	 public Property SAME_AS();
	 public Property DIFFERENT_FROM();
	 public Property DISTINCT_MEMBERS();
	 public Property UNION_OF();
	 public Property INTERSECTION_OF();
	 public Property COMPLEMENT_OF();
	 public Property ONE_OF();
	 public Property ON_PROPERTY();
	 public Property ALL_VALUES_FROM();
	 public Property HAS_VALUE();
	 public Property SOME_VALUES_FROM();
	 public Property MIN_CARDINALITY();
	 public Property MAX_CARDINALITY();
	 public Property CARDINALITY();
	 public Property MIN_CARDINALITY_Q();
	 public Property MAX_CARDINALITY_Q();
	 public Property CARDINALITY_Q();
	 public Property HAS_CLASS_Q();
	 public Property INVERSE_OF();
	 public Property IMPORTS();
	 public Property VERSION_INFO();
	 public Property PRIOR_VERSION();
	 public Property BACKWARD_COMPATIBLE_WITH();
	 public Property INCOMPATIBLE_WITH();
	 public Property SUB_CLASS_OF();
	 public Property SUB_PROPERTY_OF();
	 public Property DOMAIN();
	 public Property RANGE();
	 public Property LABEL();
	 public Property COMMENT();
	 public Property SEE_ALSO();
	 public Property IS_DEFINED_BY();
	 public Property FIRST();
	 public Property REST();
	 public Resource LIST();
	 public Resource NIL();
	 public Iterator<Resource> getAxiomTypes();
	 public Iterator<Resource> getAnnotationProperties();
	 public Iterator<Resource> getClassDescriptionTypes();
	 public boolean hasAliasFor( Resource res );
	 public Resource getAliasFor( Resource res );
	 public Iterator<Resource> listAliasesFor( Resource res );
	 public <T> boolean isSupported( Node n, EnhGraph g, Class<T> type );
	 public String getLabel();
}",1,0,0,0
"public Session lookup(Request request){
	String sessionId = getSessionId(request, false);
	if (sessionId != null){
		WebRequest webRequest = toWebRequest(request);
		return (Session)getAttribute(webRequest, Session.SESSION_ATTRIBUTE_NAME);
	}
	return null;
}",0,0,0,0
"public TestGenerator(int access_flags, Type return_type, Type[] arg_types, String[] arg_names, String method_name, String class_name, InstructionList il, ConstantPoolGen cp);",0,0,0,1
"public class ListEditDistanceSearchModifierFactory implements IInvertedIndexSearchModifierFactory {
	 private static final long serialVersionUID = 1L;
	 private final int edThresh;
	 public ListEditDistanceSearchModifierFactory(int edThresh) {
		 this.edThresh = edThresh;
	 }
	 public IInvertedIndexSearchModifier createSearchModifier() {
		 return new ListEditDistanceSearchModifier(edThresh);
	 }
}",0,0,0,0
"public static class deleteTable_args implements org.apache.thrift.TBase<deleteTable_args, deleteTable_args._Fields>, java.io.Serializable, Cloneable, Comparable<deleteTable_args> {
	 private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct(""deleteTable_args"");
	 private static final org.apache.thrift.protocol.TField LOGIN_FIELD_DESC = new org.apache.thrift.protocol.TField(""login"", org.apache.thrift.protocol.TType.STRING, (short)1);
	 private static final org.apache.thrift.protocol.TField TABLE_NAME_FIELD_DESC = new org.apache.thrift.protocol.TField(""tableName"", org.apache.thrift.protocol.TType.STRING, (short)2);
	 private static final org.apache.thrift.scheme.SchemeFactory STANDARD_SCHEME_FACTORY = new deleteTable_argsStandardSchemeFactory();
	 private static final org.apache.thrift.scheme.SchemeFactory TUPLE_SCHEME_FACTORY = new deleteTable_argsTupleSchemeFactory();
	 public java.nio.ByteBuffer login;
	 public java.lang.String tableName;
	 public enum _Fields implements org.apache.thrift.TFieldIdEnum {
		 LOGIN((short)1, ""login""), TABLE_NAME((short)2, ""tableName"");
		 private static final java.util.Map<java.lang.String, _Fields> byName = new java.util.HashMap<java.lang.String, _Fields>();
		 static {
			 for (_Fields field : java.util.EnumSet.allOf(_Fields.class)) {
				 byName.put(field.getFieldName(), field);
			 }
		 }
		 public static _Fields findByThriftId(int fieldId) {
			 switch(fieldId) {
				 case 1: return LOGIN;
				 case 2: return TABLE_NAME;
				 default: return null;
			 }
		 }
		 public static _Fields findByThriftIdOrThrow(int fieldId) {
			 _Fields fields = findByThriftId(fieldId);
			 if (fields == null) throw new java.lang.IllegalArgumentException(""Field "" + fieldId + "" doesn't exist!"");
			 return fields;
		 }
		 public static _Fields findByName(java.lang.String name) {
			 return byName.get(name);
		 }
		 private final short _thriftId;
		 private final java.lang.String _fieldName;
		 _Fields(short thriftId, java.lang.String fieldName) {
			 _thriftId = thriftId;
			 _fieldName = fieldName;
		 }
		 public short getThriftFieldId() {
			 return _thriftId;
		 }
		 public java.lang.String getFieldName() {
			 return _fieldName;
		 }
	 }
	 public static final java.util.Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
	 static {
		 java.util.Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new java.util.EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
		 tmpMap.put(_Fields.LOGIN, new org.apache.thrift.meta_data.FieldMetaData(""login"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING , true)));
		 tmpMap.put(_Fields.TABLE_NAME, new org.apache.thrift.meta_data.FieldMetaData(""tableName"", org.apache.thrift.TFieldRequirementType.DEFAULT, new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
		 metaDataMap = java.util.Collections.unmodifiableMap(tmpMap);
		 org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(deleteTable_args.class, metaDataMap);
	 }
	 public deleteTable_args() {
	 }
	 public deleteTable_args( java.nio.ByteBuffer login, java.lang.String tableName) {
		 this();
		 this.login = org.apache.thrift.TBaseHelper.copyBinary(login);
		 this.tableName = tableName;
	 }
	 public deleteTable_args(deleteTable_args other) {
		 if (other.isSetLogin()) {
			 this.login = org.apache.thrift.TBaseHelper.copyBinary(other.login);
		 }
		 if (other.isSetTableName()) {
			 this.tableName = other.tableName;
		 }
	 }
	 public deleteTable_args deepCopy() {
		 return new deleteTable_args(this);
	 }
	 public void clear() {
		 this.login = null;
		 this.tableName = null;
	 }
	 public byte[] getLogin() {
		 setLogin(org.apache.thrift.TBaseHelper.rightSize(login));
		 return login == null ? null : login.array();
	 }
	 public java.nio.ByteBuffer bufferForLogin() {
		 return org.apache.thrift.TBaseHelper.copyBinary(login);
	 }
	 public deleteTable_args setLogin(byte[] login) {
		 this.login = login == null ? (java.nio.ByteBuffer)null : java.nio.ByteBuffer.wrap(login.clone());
		 return this;
	 }
	 public deleteTable_args setLogin( java.nio.ByteBuffer login) {
		 this.login = org.apache.thrift.TBaseHelper.copyBinary(login);
		 return this;
	 }
	 public void unsetLogin() {
		 this.login = null;
	 }
	 public boolean isSetLogin() {
		 return this.login != null;
	 }
	 public void setLoginIsSet(boolean value) {
		 if (!value) {
			 this.login = null;
		 }
	 }
	 public java.lang.String getTableName() {
		 return this.tableName;
	 }
	 public deleteTable_args setTableName( java.lang.String tableName) {
		 this.tableName = tableName;
		 return this;
	 }
	 public void unsetTableName() {
		 this.tableName = null;
	 }
	 public boolean isSetTableName() {
		 return this.tableName != null;
	 }
	 public void setTableNameIsSet(boolean value) {
		 if (!value) {
			 this.tableName = null;
		 }
	 }
	 public void setFieldValue(_Fields field, java.lang.Object value) {
		 switch (field) {
			 case LOGIN: if (value == null) {
				 unsetLogin();
			 }
			 else {
				 if (value instanceof byte[]) {
					 setLogin((byte[])value);
				 }
				 else {
					 setLogin((java.nio.ByteBuffer)value);
				 }
			 }
			 break;
			 case TABLE_NAME: if (value == null) {
				 unsetTableName();
			 }
			 else {
				 setTableName((java.lang.String)value);
			 }
			 break;
		 }
	 }
	 public java.lang.Object getFieldValue(_Fields field) {
		 switch (field) {
			 case LOGIN: return getLogin();
			 case TABLE_NAME: return getTableName();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean isSet(_Fields field) {
		 if (field == null) {
			 throw new java.lang.IllegalArgumentException();
		 }
		 switch (field) {
			 case LOGIN: return isSetLogin();
			 case TABLE_NAME: return isSetTableName();
		 }
		 throw new java.lang.IllegalStateException();
	 }
	 public boolean equals(java.lang.Object that) {
		 if (that == null) return false;
		 if (that instanceof deleteTable_args) return this.equals((deleteTable_args)that);
		 return false;
	 }
	 public boolean equals(deleteTable_args that) {
		 if (that == null) return false;
		 if (this == that) return true;
		 boolean this_present_login = true && this.isSetLogin();
		 boolean that_present_login = true && that.isSetLogin();
		 if (this_present_login || that_present_login) {
			 if (!(this_present_login && that_present_login)) return false;
			 if (!this.login.equals(that.login)) return false;
		 }
		 boolean this_present_tableName = true && this.isSetTableName();
		 boolean that_present_tableName = true && that.isSetTableName();
		 if (this_present_tableName || that_present_tableName) {
			 if (!(this_present_tableName && that_present_tableName)) return false;
			 if (!this.tableName.equals(that.tableName)) return false;
		 }
		 return true;
	 }
	 public int hashCode() {
		 int hashCode = 1;
		 hashCode = hashCode * 8191 + ((isSetLogin()) ? 131071 : 524287);
		 if (isSetLogin()) hashCode = hashCode * 8191 + login.hashCode();
		 hashCode = hashCode * 8191 + ((isSetTableName()) ? 131071 : 524287);
		 if (isSetTableName()) hashCode = hashCode * 8191 + tableName.hashCode();
		 return hashCode;
	 }
	 public int compareTo(deleteTable_args other) {
		 if (!getClass().equals(other.getClass())) {
			 return getClass().getName().compareTo(other.getClass().getName());
		 }
		 int lastComparison = 0;
		 lastComparison = java.lang.Boolean.valueOf(isSetLogin()).compareTo(other.isSetLogin());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetLogin()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.login, other.login);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 lastComparison = java.lang.Boolean.valueOf(isSetTableName()).compareTo(other.isSetTableName());
		 if (lastComparison != 0) {
			 return lastComparison;
		 }
		 if (isSetTableName()) {
			 lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.tableName, other.tableName);
			 if (lastComparison != 0) {
				 return lastComparison;
			 }
		 }
		 return 0;
	 }
	 public _Fields fieldForId(int fieldId) {
		 return _Fields.findByThriftId(fieldId);
	 }
	 public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
		 scheme(iprot).read(iprot, this);
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
		 scheme(oprot).write(oprot, this);
	 }
	 public java.lang.String toString() {
		 java.lang.StringBuilder sb = new java.lang.StringBuilder(""deleteTable_args("");
		 boolean first = true;
		 sb.append(""login:"");
		 if (this.login == null) {
			 sb.append(""null"");
		 }
		 else {
			 org.apache.thrift.TBaseHelper.toString(this.login, sb);
		 }
		 first = false;
		 if (!first) sb.append("", "");
		 sb.append(""tableName:"");
		 if (this.tableName == null) {
			 sb.append(""null"");
		 }
		 else {
			 sb.append(this.tableName);
		 }
		 first = false;
		 sb.append("")"");
		 return sb.toString();
	 }
	 public void validate() throws org.apache.thrift.TException {
	 }
	 private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
		 try {
			 write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {
		 try {
			 read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
		 }
		 catch (org.apache.thrift.TException te) {
			 throw new java.io.IOException(te);
		 }
	 }
	 private static class deleteTable_argsStandardSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
		 public deleteTable_argsStandardScheme getScheme() {
			 return new deleteTable_argsStandardScheme();
		 }
	 }
	 private static class deleteTable_argsStandardScheme extends org.apache.thrift.scheme.StandardScheme<deleteTable_args> {
		 public void read(org.apache.thrift.protocol.TProtocol iprot, deleteTable_args struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TField schemeField;
			 iprot.readStructBegin();
			 while (true) {
				 schemeField = iprot.readFieldBegin();
				 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
					 break;
				 }
				 switch (schemeField.id) {
					 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						 struct.login = iprot.readBinary();
						 struct.setLoginIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
						 struct.tableName = iprot.readString();
						 struct.setTableNameIsSet(true);
					 }
					 else {
						 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					 }
					 break;
					 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 iprot.readFieldEnd();
			 }
			 iprot.readStructEnd();
			 struct.validate();
		 }
		 public void write(org.apache.thrift.protocol.TProtocol oprot, deleteTable_args struct) throws org.apache.thrift.TException {
			 struct.validate();
			 oprot.writeStructBegin(STRUCT_DESC);
			 if (struct.login != null) {
				 oprot.writeFieldBegin(LOGIN_FIELD_DESC);
				 oprot.writeBinary(struct.login);
				 oprot.writeFieldEnd();
			 }
			 if (struct.tableName != null) {
				 oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
				 oprot.writeString(struct.tableName);
				 oprot.writeFieldEnd();
			 }
			 oprot.writeFieldStop();
			 oprot.writeStructEnd();
		 }
	 }
	 private static class deleteTable_argsTupleSchemeFactory implements org.apache.thrift.scheme.SchemeFactory {
		 public deleteTable_argsTupleScheme getScheme() {
			 return new deleteTable_argsTupleScheme();
		 }
	 }
	 private static class deleteTable_argsTupleScheme extends org.apache.thrift.scheme.TupleScheme<deleteTable_args> {
		 public void write(org.apache.thrift.protocol.TProtocol prot, deleteTable_args struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TTupleProtocol oprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
			 java.util.BitSet optionals = new java.util.BitSet();
			 if (struct.isSetLogin()) {
				 optionals.set(0);
			 }
			 if (struct.isSetTableName()) {
				 optionals.set(1);
			 }
			 oprot.writeBitSet(optionals, 2);
			 if (struct.isSetLogin()) {
				 oprot.writeBinary(struct.login);
			 }
			 if (struct.isSetTableName()) {
				 oprot.writeString(struct.tableName);
			 }
		 }
		 public void read(org.apache.thrift.protocol.TProtocol prot, deleteTable_args struct) throws org.apache.thrift.TException {
			 org.apache.thrift.protocol.TTupleProtocol iprot = (org.apache.thrift.protocol.TTupleProtocol) prot;
			 java.util.BitSet incoming = iprot.readBitSet(2);
			 if (incoming.get(0)) {
				 struct.login = iprot.readBinary();
				 struct.setLoginIsSet(true);
			 }
			 if (incoming.get(1)) {
				 struct.tableName = iprot.readString();
				 struct.setTableNameIsSet(true);
			 }
		 }
	 }
	 private static <S extends org.apache.thrift.scheme.IScheme> S scheme(org.apache.thrift.protocol.TProtocol proto) {
		 return (org.apache.thrift.scheme.StandardScheme.class.equals(proto.getScheme()) ? STANDARD_SCHEME_FACTORY : TUPLE_SCHEME_FACTORY).getScheme();
	 }
 }",1,1,0,0
"final class NativeDate extends IdScriptableObject{
	 private static final Object DATE_TAG = new Object();
	 private static final String js_NaN_date_str = ""Invalid Date"";
	 static void init(Context cx, Scriptable scope, boolean sealed) {
		 NativeDate obj = new NativeDate();
		 obj.date = ScriptRuntime.NaN;
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeDate() {
		 if (thisTimeZone == null) {
			 thisTimeZone = java.util.TimeZone.getDefault();
			 LocalTZA = thisTimeZone.getRawOffset();
		 }
	 }
	 public String getClassName() {
		 return ""Date"";
	 }
	 public Object getDefaultValue(Class typeHint) {
		 if (typeHint == null) typeHint = ScriptRuntime.StringClass;
		 return super.getDefaultValue(typeHint);
	 }
	 double getJSTimeValue() {
		 return date;
	 }
	 protected void fillConstructorProperties(IdFunctionObject ctor) {
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_now, ""now"", 0);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_parse, ""parse"", 1);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_UTC, ""UTC"", 1);
		 super.fillConstructorProperties(ctor);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toTimeString: arity=0;
			 s=""toTimeString"";
			 break;
			 case Id_toDateString: arity=0;
			 s=""toDateString"";
			 break;
			 case Id_toLocaleString: arity=0;
			 s=""toLocaleString"";
			 break;
			 case Id_toLocaleTimeString: arity=0;
			 s=""toLocaleTimeString"";
			 break;
			 case Id_toLocaleDateString: arity=0;
			 s=""toLocaleDateString"";
			 break;
			 case Id_toUTCString: arity=0;
			 s=""toUTCString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_valueOf: arity=0;
			 s=""valueOf"";
			 break;
			 case Id_getTime: arity=0;
			 s=""getTime"";
			 break;
			 case Id_getYear: arity=0;
			 s=""getYear"";
			 break;
			 case Id_getFullYear: arity=0;
			 s=""getFullYear"";
			 break;
			 case Id_getUTCFullYear: arity=0;
			 s=""getUTCFullYear"";
			 break;
			 case Id_getMonth: arity=0;
			 s=""getMonth"";
			 break;
			 case Id_getUTCMonth: arity=0;
			 s=""getUTCMonth"";
			 break;
			 case Id_getDate: arity=0;
			 s=""getDate"";
			 break;
			 case Id_getUTCDate: arity=0;
			 s=""getUTCDate"";
			 break;
			 case Id_getDay: arity=0;
			 s=""getDay"";
			 break;
			 case Id_getUTCDay: arity=0;
			 s=""getUTCDay"";
			 break;
			 case Id_getHours: arity=0;
			 s=""getHours"";
			 break;
			 case Id_getUTCHours: arity=0;
			 s=""getUTCHours"";
			 break;
			 case Id_getMinutes: arity=0;
			 s=""getMinutes"";
			 break;
			 case Id_getUTCMinutes: arity=0;
			 s=""getUTCMinutes"";
			 break;
			 case Id_getSeconds: arity=0;
			 s=""getSeconds"";
			 break;
			 case Id_getUTCSeconds: arity=0;
			 s=""getUTCSeconds"";
			 break;
			 case Id_getMilliseconds: arity=0;
			 s=""getMilliseconds"";
			 break;
			 case Id_getUTCMilliseconds: arity=0;
			 s=""getUTCMilliseconds"";
			 break;
			 case Id_getTimezoneOffset: arity=0;
			 s=""getTimezoneOffset"";
			 break;
			 case Id_setTime: arity=1;
			 s=""setTime"";
			 break;
			 case Id_setMilliseconds: arity=1;
			 s=""setMilliseconds"";
			 break;
			 case Id_setUTCMilliseconds: arity=1;
			 s=""setUTCMilliseconds"";
			 break;
			 case Id_setSeconds: arity=2;
			 s=""setSeconds"";
			 break;
			 case Id_setUTCSeconds: arity=2;
			 s=""setUTCSeconds"";
			 break;
			 case Id_setMinutes: arity=3;
			 s=""setMinutes"";
			 break;
			 case Id_setUTCMinutes: arity=3;
			 s=""setUTCMinutes"";
			 break;
			 case Id_setHours: arity=4;
			 s=""setHours"";
			 break;
			 case Id_setUTCHours: arity=4;
			 s=""setUTCHours"";
			 break;
			 case Id_setDate: arity=1;
			 s=""setDate"";
			 break;
			 case Id_setUTCDate: arity=1;
			 s=""setUTCDate"";
			 break;
			 case Id_setMonth: arity=2;
			 s=""setMonth"";
			 break;
			 case Id_setUTCMonth: arity=2;
			 s=""setUTCMonth"";
			 break;
			 case Id_setFullYear: arity=3;
			 s=""setFullYear"";
			 break;
			 case Id_setUTCFullYear: arity=3;
			 s=""setUTCFullYear"";
			 break;
			 case Id_setYear: arity=1;
			 s=""setYear"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(DATE_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(DATE_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case ConstructorId_now: return ScriptRuntime.wrapNumber(now());
			 case ConstructorId_parse: {
				 String dataStr = ScriptRuntime.toString(args, 0);
				 return ScriptRuntime.wrapNumber(date_parseString(dataStr));
			 }
			 case ConstructorId_UTC: return ScriptRuntime.wrapNumber(jsStaticFunction_UTC(args));
			 case Id_constructor: {
				 if (thisObj != null) return date_format(now(), Id_toString);
				 return jsConstructor(args);
			 }
		 }
		 if (!(thisObj instanceof NativeDate)) throw incompatibleCallError(f);
		 NativeDate realThis = (NativeDate)thisObj;
		 double t = realThis.date;
		 switch (id) {
			 case Id_toString: case Id_toTimeString: case Id_toDateString: if (t == t) {
				 return date_format(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toLocaleString: case Id_toLocaleTimeString: case Id_toLocaleDateString: if (t == t) {
				 return toLocale_helper(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toUTCString: if (t == t) {
				 return js_toUTCString(t);
			 }
			 return js_NaN_date_str;
			 case Id_toSource: return ""(new Date(""+ScriptRuntime.toString(t)+""))"";
			 case Id_valueOf: case Id_getTime: return ScriptRuntime.wrapNumber(t);
			 case Id_getYear: case Id_getFullYear: case Id_getUTCFullYear: if (t == t) {
				 if (id != Id_getUTCFullYear) t = LocalTime(t);
				 t = YearFromTime(t);
				 if (id == Id_getYear) {
					 if (cx.hasFeature(Context.FEATURE_NON_ECMA_GET_YEAR)) {
						 if (1900 <= t && t < 2000) {
							 t -= 1900;
						 }
					 }
					 else {
						 t -= 1900;
					 }
				 }
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMonth: case Id_getUTCMonth: if (t == t) {
				 if (id == Id_getMonth) t = LocalTime(t);
				 t = MonthFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDate: case Id_getUTCDate: if (t == t) {
				 if (id == Id_getDate) t = LocalTime(t);
				 t = DateFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDay: case Id_getUTCDay: if (t == t) {
				 if (id == Id_getDay) t = LocalTime(t);
				 t = WeekDay(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getHours: case Id_getUTCHours: if (t == t) {
				 if (id == Id_getHours) t = LocalTime(t);
				 t = HourFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMinutes: case Id_getUTCMinutes: if (t == t) {
				 if (id == Id_getMinutes) t = LocalTime(t);
				 t = MinFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getSeconds: case Id_getUTCSeconds: if (t == t) {
				 if (id == Id_getSeconds) t = LocalTime(t);
				 t = SecFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMilliseconds: case Id_getUTCMilliseconds: if (t == t) {
				 if (id == Id_getMilliseconds) t = LocalTime(t);
				 t = msFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getTimezoneOffset: if (t == t) {
				 t = (t - LocalTime(t)) / msPerMinute;
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setTime: t = TimeClip(ScriptRuntime.toNumber(args, 0));
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setMilliseconds: case Id_setUTCMilliseconds: case Id_setSeconds: case Id_setUTCSeconds: case Id_setMinutes: case Id_setUTCMinutes: case Id_setHours: case Id_setUTCHours: t = makeTime(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setDate: case Id_setUTCDate: case Id_setMonth: case Id_setUTCMonth: case Id_setFullYear: case Id_setUTCFullYear: t = makeDate(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setYear: {
				 double year = ScriptRuntime.toNumber(args, 0);
				 if (year != year || Double.isInfinite(year)) {
					 t = ScriptRuntime.NaN;
				 }
				 else {
					 if (t != t) {
						 t = 0;
					 }
					 else {
						 t = LocalTime(t);
					 }
					 if (year >= 0 && year <= 99) year += 1900;
					 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
					 t = MakeDate(day, TimeWithinDay(t));
					 t = internalUTC(t);
					 t = TimeClip(t);
				 }
			 }
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
	 }
	 private static final double HalfTimeDomain = 8.64e15;
	 private static final double HoursPerDay = 24.0;
	 private static final double MinutesPerHour = 60.0;
	 private static final double SecondsPerMinute = 60.0;
	 private static final double msPerSecond = 1000.0;
	 private static final double MinutesPerDay = (HoursPerDay * MinutesPerHour);
	 private static final double SecondsPerDay = (MinutesPerDay * SecondsPerMinute);
	 private static final double SecondsPerHour = (MinutesPerHour * SecondsPerMinute);
	 private static final double msPerDay = (SecondsPerDay * msPerSecond);
	 private static final double msPerHour = (SecondsPerHour * msPerSecond);
	 private static final double msPerMinute = (SecondsPerMinute * msPerSecond);
	 private static double Day(double t) {
		 return Math.floor(t / msPerDay);
	 }
	 private static double TimeWithinDay(double t) {
		 double result;
		 result = t % msPerDay;
		 if (result < 0) result += msPerDay;
		 return result;
	 }
	 private static boolean IsLeapYear(int year) {
		 return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
	 }
	 private static double DayFromYear(double y) {
		 return ((365 * ((y)-1970) + Math.floor(((y)-1969)/4.0) - Math.floor(((y)-1901)/100.0) + Math.floor(((y)-1601)/400.0)));
	 }
	 private static double TimeFromYear(double y) {
		 return DayFromYear(y) * msPerDay;
	 }
	 private static int YearFromTime(double t) {
		 int lo = (int) Math.floor((t / msPerDay) / 366) + 1970;
		 int hi = (int) Math.floor((t / msPerDay) / 365) + 1970;
		 int mid;
		 if (hi < lo) {
			 int temp = lo;
			 lo = hi;
			 hi = temp;
		 }
		 while (hi > lo) {
			 mid = (hi + lo) / 2;
			 if (TimeFromYear(mid) > t) {
				 hi = mid - 1;
			 }
			 else {
				 lo = mid + 1;
				 if (TimeFromYear(lo) > t) {
					 return mid;
				 }
			 }
		 }
		 return lo;
	 }
	 private static boolean InLeapYear(double t) {
		 return IsLeapYear(YearFromTime(t));
	 }
	 private static double DayFromMonth(int m, int year) {
		 int day = m * 30;
		 if (m >= 7) {
			 day += m / 2 - 1;
		 }
		 else if (m >= 2) {
			 day += (m - 1) / 2 - 1;
		 }
		 else {
			 day += m;
		 }
		 if (m >= 2 && IsLeapYear(year)) {
			 ++day;
		 }
		 return day;
	 }
	 private static int MonthFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? 0 : 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 1;
			 --d;
		 }
		 int estimate = d / 30;
		 int mstart;
		 switch (estimate) {
			 case 0: return 2;
			 case 1: mstart = 31;
			 break;
			 case 2: mstart = 31+30;
			 break;
			 case 3: mstart = 31+30+31;
			 break;
			 case 4: mstart = 31+30+31+30;
			 break;
			 case 5: mstart = 31+30+31+30+31;
			 break;
			 case 6: mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return 11;
			 default: throw Kit.codeBug();
		 }
		 return (d >= mstart) ? estimate + 2 : estimate + 1;
	 }
	 private static int DateFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? d + 31 + 28 + 1 : d + 28 + 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 29;
			 --d;
		 }
		 int mdays, mstart;
		 switch (d / 30) {
			 case 0: return d + 1;
			 case 1: mdays = 31;
			 mstart = 31;
			 break;
			 case 2: mdays = 30;
			 mstart = 31+30;
			 break;
			 case 3: mdays = 31;
			 mstart = 31+30+31;
			 break;
			 case 4: mdays = 30;
			 mstart = 31+30+31+30;
			 break;
			 case 5: mdays = 31;
			 mstart = 31+30+31+30+31;
			 break;
			 case 6: mdays = 31;
			 mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mdays = 30;
			 mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mdays = 31;
			 mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mdays = 30;
			 mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return d - (31+30+31+30+31+31+30+31+30) + 1;
			 default: throw Kit.codeBug();
		 }
		 d -= mstart;
		 if (d < 0) {
			 d += mdays;
		 }
		 return d + 1;
	 }
	 private static int WeekDay(double t) {
		 double result;
		 result = Day(t) + 4;
		 result = result % 7;
		 if (result < 0) result += 7;
		 return (int) result;
	 }
	 private static double now() {
		 return (double) System.currentTimeMillis();
	 }
	 private final static boolean TZO_WORKAROUND = false;
	 private static double DaylightSavingTA(double t) {
		 if (t < 0.0 || t > 2145916800000.0) {
			 int year = EquivalentYear(YearFromTime(t));
			 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
			 t = MakeDate(day, TimeWithinDay(t));
		 }
		 if (!TZO_WORKAROUND) {
			 Date date = new Date((long) t);
			 if (thisTimeZone.inDaylightTime(date)) return msPerHour;
			 else return 0;
		 }
		 else {
			 t += LocalTZA + (HourFromTime(t) <= 2 ? msPerHour : 0);
			 int year = YearFromTime(t);
			 double offset = thisTimeZone.getOffset(year > 0 ? 1 : 0, year, MonthFromTime(t), DateFromTime(t), WeekDay(t), (int)TimeWithinDay(t));
			 if ((offset - LocalTZA) != 0) return msPerHour;
			 else return 0;
		 }
	 }
	 private static int EquivalentYear(int year) {
		 int day = (int) DayFromYear(year) + 4;
		 day = day % 7;
		 if (day < 0) day += 7;
		 if (IsLeapYear(year)) {
			 switch (day) {
				 case 0: return 1984;
				 case 1: return 1996;
				 case 2: return 1980;
				 case 3: return 1992;
				 case 4: return 1976;
				 case 5: return 1988;
				 case 6: return 1972;
			 }
		 }
		 else {
			 switch (day) {
				 case 0: return 1978;
				 case 1: return 1973;
				 case 2: return 1974;
				 case 3: return 1975;
				 case 4: return 1981;
				 case 5: return 1971;
				 case 6: return 1977;
			 }
		 }
		 throw Kit.codeBug();
	 }
	 private static double LocalTime(double t) {
		 return t + LocalTZA + DaylightSavingTA(t);
	 }
	 private static double internalUTC(double t) {
		 return t - LocalTZA - DaylightSavingTA(t - LocalTZA);
	 }
	 private static int HourFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerHour) % HoursPerDay;
		 if (result < 0) result += HoursPerDay;
		 return (int) result;
	 }
	 private static int MinFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerMinute) % MinutesPerHour;
		 if (result < 0) result += MinutesPerHour;
		 return (int) result;
	 }
	 private static int SecFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerSecond) % SecondsPerMinute;
		 if (result < 0) result += SecondsPerMinute;
		 return (int) result;
	 }
	 private static int msFromTime(double t) {
		 double result;
		 result = t % msPerSecond;
		 if (result < 0) result += msPerSecond;
		 return (int) result;
	 }
	 private static double MakeTime(double hour, double min, double sec, double ms) {
	 return ((hour * MinutesPerHour + min) * SecondsPerMinute + sec) }
	 private static double MakeDay(double year, double month, double date) {
		 year += Math.floor(month / 12);
		 month = month % 12;
		 if (month < 0) month += 12;
		 double yearday = Math.floor(TimeFromYear(year) / msPerDay);
		 double monthday = DayFromMonth((int)month, (int)year);
		 return yearday + monthday + date - 1;
	 }
	 private static double MakeDate(double day, double time) {
		 return day * msPerDay + time;
	 }
	 private static double TimeClip(double d) {
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY || Math.abs(d) > HalfTimeDomain) {
			 return ScriptRuntime.NaN;
		 }
		 if (d > 0.0) return Math.floor(d + 0.);
		 else return Math.ceil(d + 0.);
	 }
	 private static double date_msecFromDate(double year, double mon, double mday, double hour, double min, double sec, double msec) {
		 double day;
		 double time;
		 double result;
		 day = MakeDay(year, mon, mday);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(day, time);
		 return result;
	 }
	 private static final int MAXARGS = 7;
	 private static double jsStaticFunction_UTC(Object[] args) {
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 return ScriptRuntime.NaN;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 array[loop] = 0;
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 if (array[2] < 1) array[2] = 1;
		 d = date_msecFromDate(array[0], array[1], array[2], array[3], array[4], array[5], array[6]);
		 d = TimeClip(d);
		 return d;
	 }
	 private static double date_parseString(String s) {
		 int year = -1;
		 int mon = -1;
		 int mday = -1;
		 int hour = -1;
		 int min = -1;
		 int sec = -1;
		 char c = 0;
		 char si = 0;
		 int i = 0;
		 int n = -1;
		 double tzoffset = -1;
		 char prevc = 0;
		 int limit = 0;
		 boolean seenplusminus = false;
		 limit = s.length();
		 while (i < limit) {
			 c = s.charAt(i);
			 i++;
			 if (c <= ' ' || c == ',' || c == '-') {
				 if (i < limit) {
					 si = s.charAt(i);
					 if (c == '-' && '0' <= si && si <= '9') {
						 prevc = c;
					 }
				 }
				 continue;
			 }
			 if (c == '(') {
				 int depth = 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 i++;
					 if (c == '(') depth++;
					 else if (c == ')') if (--depth <= 0) break;
				 }
				 continue;
			 }
			 if ('0' <= c && c <= '9') {
				 n = c - '0';
				 while (i < limit && '0' <= (c = s.charAt(i)) && c <= '9') {
					 n = n * 10 + c - '0';
					 i++;
				 }
				 if ((prevc == '+' || prevc == '-')) {
					 seenplusminus = true;
					 if (n < 24) n = n * 60;
					 else n = n % 100 + n / 100 * 60;
					 if (prevc == '+') n = -n;
					 if (tzoffset != 0 && tzoffset != -1) return ScriptRuntime.NaN;
					 tzoffset = n;
				 }
				 else if (n >= 70 || (prevc == '/' && mon >= 0 && mday >= 0 && year < 0)) {
					 if (year >= 0) return ScriptRuntime.NaN;
					 else if (c <= ' ' || c == ',' || c == '/' || i >= limit) year = n < 100 ? n + 1900 : n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == ':') {
					 if (hour < 0) hour = n;
					 else if (min < 0) min = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == '/') {
					 if (mon < 0) mon = n-1;
					 else if (mday < 0) mday = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (i < limit && c != ',' && c > ' ' && c != '-') {
					 return ScriptRuntime.NaN;
				 }
				 else if (seenplusminus && n < 60) {
					 if (tzoffset < 0) tzoffset -= n;
					 else tzoffset += n;
				 }
				 else if (hour >= 0 && min < 0) {
					 min = n;
				 }
				 else if (min >= 0 && sec < 0) {
					 sec = n;
				 }
				 else if (mday < 0) {
					 mday = n;
				 }
				 else {
					 return ScriptRuntime.NaN;
				 }
				 prevc = 0;
			 }
			 else if (c == '/' || c == ':' || c == '+' || c == '-') {
				 prevc = c;
			 }
			 else {
				 int st = i - 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 if (!(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))) break;
					 i++;
				 }
				 int letterCount = i - st;
				 if (letterCount < 2) return ScriptRuntime.NaN;
				 String wtb = ""am;
				pm;
				"" +""monday;
				tuesday;
				wednesday;
				thursday;
				friday;
				"" +""saturday;
				sunday;
				"" +""january;
				february;
				march;
				april;
				may;
				june;
				"" +""july;
				august;
				september;
				october;
				november;
				december;
				"" +""gmt;
				ut;
				utc;
				est;
				edt;
				cst;
				cdt;
				mst;
				mdt;
				pst;
				pdt;
				"";
				 int index = 0;
				 for (int wtbOffset = 0;
				 ;
				) {
					 int wtbNext = wtb.indexOf(';
					', wtbOffset);
					 if (wtbNext < 0) return ScriptRuntime.NaN;
					 if (wtb.regionMatches(true, wtbOffset, s, st, letterCount)) break;
					 wtbOffset = wtbNext + 1;
					 ++index;
				 }
				 if (index < 2) {
					 if (hour > 12 || hour < 0) {
						 return ScriptRuntime.NaN;
					 }
					 else if (index == 0) {
						 if (hour == 12) hour = 0;
					 }
					 else {
						 if (hour != 12) hour += 12;
					 }
				 }
				 else if ((index -= 2) < 7) {
				 }
				 else if ((index -= 7) < 12) {
					 if (mon < 0) {
						 mon = index;
					 }
					 else {
						 return ScriptRuntime.NaN;
					 }
				 }
				 else {
					 index -= 12;
					 switch (index) {
						 case 0 : tzoffset = 0;
						 break;
						 case 1 : tzoffset = 0;
						 break;
						 case 2 : tzoffset = 0;
						 break;
						 case 3 : tzoffset = 5 * 60;
						 break;
						 case 4 : tzoffset = 4 * 60;
						 break;
						 case 5 : tzoffset = 6 * 60;
						 break;
						 case 6 : tzoffset = 5 * 60;
						 break;
						 case 7 : tzoffset = 7 * 60;
						 break;
						 case 8 : tzoffset = 6 * 60;
						 break;
						 case 9 : tzoffset = 8 * 60;
						 break;
						 case 10 :tzoffset = 7 * 60;
						 break;
						 default: Kit.codeBug();
					 }
				 }
			 }
		 }
		 if (year < 0 || mon < 0 || mday < 0) return ScriptRuntime.NaN;
		 if (sec < 0) sec = 0;
		 if (min < 0) min = 0;
		 if (hour < 0) hour = 0;
		 double msec = date_msecFromDate(year, mon, mday, hour, min, sec, 0);
		 if (tzoffset == -1) {
			 return internalUTC(msec);
		 }
		 else {
			 return msec + tzoffset * msPerMinute;
		 }
	 }
	 private static String date_format(double t, int methodId) {
		 StringBuffer result = new StringBuffer(60);
		 double local = LocalTime(t);
		 if (methodId != Id_toTimeString) {
			 appendWeekDayName(result, WeekDay(local));
			 result.append(' ');
			 appendMonthName(result, MonthFromTime(local));
			 result.append(' ');
			 append0PaddedUint(result, DateFromTime(local), 2);
			 result.append(' ');
			 int year = YearFromTime(local);
			 if (year < 0) {
				 result.append('-');
				 year = -year;
			 }
			 append0PaddedUint(result, year, 4);
			 if (methodId != Id_toDateString) result.append(' ');
		 }
		 if (methodId != Id_toDateString) {
			 append0PaddedUint(result, HourFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, MinFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, SecFromTime(local), 2);
			 int minutes = (int) Math.floor((LocalTZA + DaylightSavingTA(t)) / msPerMinute);
			 int offset = (minutes / 60) * 100 + minutes % 60;
			 if (offset > 0) {
				 result.append("" GMT+"");
			 }
			 else {
				 result.append("" GMT-"");
				 offset = -offset;
			 }
			 append0PaddedUint(result, offset, 4);
			 if (timeZoneFormatter == null) timeZoneFormatter = new java.text.SimpleDateFormat(""zzz"");
			 if (t < 0.0 || t > 2145916800000.0) {
				 int equiv = EquivalentYear(YearFromTime(local));
				 double day = MakeDay(equiv, MonthFromTime(t), DateFromTime(t));
				 t = MakeDate(day, TimeWithinDay(t));
			 }
			 result.append("" ("");
			 java.util.Date date = new Date((long) t);
			 result.append(timeZoneFormatter.format(date));
			 result.append(')');
		 }
		 return result.toString();
	 }
	 private static Object jsConstructor(Object[] args) {
		 NativeDate obj = new NativeDate();
		 if (args.length == 0) {
			 obj.date = now();
			 return obj;
		 }
		 if (args.length == 1) {
			 Object arg0 = args[0];
			 if (arg0 instanceof Scriptable) arg0 = ((Scriptable) arg0).getDefaultValue(null);
			 double date;
			 if (arg0 instanceof String) {
				 date = date_parseString((String)arg0);
			 }
			 else {
				 date = ScriptRuntime.toNumber(arg0);
			 }
			 obj.date = TimeClip(date);
			 return obj;
		 }
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 obj.date = ScriptRuntime.NaN;
					 return obj;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 array[loop] = 0;
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 if (array[2] < 1) array[2] = 1;
		 double day = MakeDay(array[0], array[1], array[2]);
		 double time = MakeTime(array[3], array[4], array[5], array[6]);
		 time = MakeDate(day, time);
		 time = internalUTC(time);
		 obj.date = TimeClip(time);
		 return obj;
	 }
	 private static String toLocale_helper(double t, int methodId) {
		 java.text.DateFormat formatter;
		 switch (methodId) {
			 case Id_toLocaleString: if (localeDateTimeFormatter == null) {
				 localeDateTimeFormatter = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
			 }
			 formatter = localeDateTimeFormatter;
			 break;
			 case Id_toLocaleTimeString: if (localeTimeFormatter == null) {
				 localeTimeFormatter = DateFormat.getTimeInstance(DateFormat.LONG);
			 }
			 formatter = localeTimeFormatter;
			 break;
			 case Id_toLocaleDateString: if (localeDateFormatter == null) {
				 localeDateFormatter = DateFormat.getDateInstance(DateFormat.LONG);
			 }
			 formatter = localeDateFormatter;
			 break;
			 default: formatter = null;
		 }
		 return formatter.format(new Date((long) t));
	 }
	 private static String js_toUTCString(double date) {
		 StringBuffer result = new StringBuffer(60);
		 appendWeekDayName(result, WeekDay(date));
		 result.append("", "");
		 append0PaddedUint(result, DateFromTime(date), 2);
		 result.append(' ');
		 appendMonthName(result, MonthFromTime(date));
		 result.append(' ');
		 int year = YearFromTime(date);
		 if (year < 0) {
			 result.append('-');
			 year = -year;
		 }
		 append0PaddedUint(result, year, 4);
		 result.append(' ');
		 append0PaddedUint(result, HourFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, MinFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, SecFromTime(date), 2);
		 result.append("" GMT"");
		 return result.toString();
	 }
	 private static void append0PaddedUint(StringBuffer sb, int i, int minWidth) {
		 if (i < 0) Kit.codeBug();
		 int scale = 1;
		 --minWidth;
		 if (i >= 10) {
			 if (i < 1000 * 1000 * 1000) {
				 for (;
				;
				) {
					 int newScale = scale * 10;
					 if (i < newScale) {
						 break;
					 }
					 --minWidth;
					 scale = newScale;
				 }
			 }
			 else {
				 minWidth -= 9;
				 scale = 1000 * 1000 * 1000;
			 }
		 }
		 while (minWidth > 0) {
			 sb.append('0');
			 --minWidth;
		 }
		 while (scale != 1) {
			 sb.append((char)('0' + (i / scale)));
			 i %= scale;
			 scale /= 10;
		 }
		 sb.append((char)('0' + i));
	 }
	 private static void appendMonthName(StringBuffer sb, int index) {
		 String months = ""Jan""+""Feb""+""Mar""+""Apr""+""May""+""Jun"" +""Jul""+""Aug""+""Sep""+""Oct""+""Nov""+""Dec"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(months.charAt(index + i));
		 }
	 }
	 private static void appendWeekDayName(StringBuffer sb, int index) {
		 String days = ""Sun""+""Mon""+""Tue""+""Wed""+""Thu""+""Fri""+""Sat"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(days.charAt(index + i));
		 }
	 }
	 private static double makeTime(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCMilliseconds: local = false;
			 case Id_setMilliseconds: maxargs = 1;
			 break;
			 case Id_setUTCSeconds: local = false;
			 case Id_setSeconds: maxargs = 2;
			 break;
			 case Id_setUTCMinutes: local = false;
			 case Id_setMinutes: maxargs = 3;
			 break;
			 case Id_setUTCHours: local = false;
			 case Id_setHours: maxargs = 4;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[4];
		 double hour, min, sec, msec;
		 double lorutime;
		 double time;
		 double result;
		 if (date != date) return date;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (local) lorutime = LocalTime(date);
		 else lorutime = date;
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 4 && i < stop) hour = conv[i++];
		 else hour = HourFromTime(lorutime);
		 if (maxargs >= 3 && i < stop) min = conv[i++];
		 else min = MinFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) sec = conv[i++];
		 else sec = SecFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) msec = conv[i++];
		 else msec = msFromTime(lorutime);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(Day(lorutime), time);
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 private static double makeDate(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCDate: local = false;
			 case Id_setDate: maxargs = 1;
			 break;
			 case Id_setUTCMonth: local = false;
			 case Id_setMonth: maxargs = 2;
			 break;
			 case Id_setUTCFullYear: local = false;
			 case Id_setFullYear: maxargs = 3;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[3];
		 double year, month, day;
		 double lorutime;
		 double result;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (date != date) {
			 if (args.length < 3) {
				 return ScriptRuntime.NaN;
			 }
			 else {
				 lorutime = 0;
			 }
		 }
		 else {
			 if (local) lorutime = LocalTime(date);
			 else lorutime = date;
		 }
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 3 && i < stop) year = conv[i++];
		 else year = YearFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) month = conv[i++];
		 else month = MonthFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) day = conv[i++];
		 else day = DateFromTime(lorutime);
		 day = MakeDay(year, month, day);
		 result = MakeDate(day, TimeWithinDay(lorutime));
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 6: X=""getDay"";
				id=Id_getDay;
				 break L;
				 case 7: switch (s.charAt(3)) {
					 case 'D': c=s.charAt(0);
					 if (c=='g') {
						 X=""getDate"";
						id=Id_getDate;
					 }
					 else if (c=='s') {
						 X=""setDate"";
						id=Id_setDate;
					 }
					 break L;
					 case 'T': c=s.charAt(0);
					 if (c=='g') {
						 X=""getTime"";
						id=Id_getTime;
					 }
					 else if (c=='s') {
						 X=""setTime"";
						id=Id_setTime;
					 }
					 break L;
					 case 'Y': c=s.charAt(0);
					 if (c=='g') {
						 X=""getYear"";
						id=Id_getYear;
					 }
					 else if (c=='s') {
						 X=""setYear"";
						id=Id_setYear;
					 }
					 break L;
					 case 'u': X=""valueOf"";
					id=Id_valueOf;
					 break L;
				 }
				 break L;
				 case 8: switch (s.charAt(3)) {
					 case 'H': c=s.charAt(0);
					 if (c=='g') {
						 X=""getHours"";
						id=Id_getHours;
					 }
					 else if (c=='s') {
						 X=""setHours"";
						id=Id_setHours;
					 }
					 break L;
					 case 'M': c=s.charAt(0);
					 if (c=='g') {
						 X=""getMonth"";
						id=Id_getMonth;
					 }
					 else if (c=='s') {
						 X=""setMonth"";
						id=Id_setMonth;
					 }
					 break L;
					 case 'o': X=""toSource"";
					id=Id_toSource;
					 break L;
					 case 't': X=""toString"";
					id=Id_toString;
					 break L;
				 }
				 break L;
				 case 9: X=""getUTCDay"";
				id=Id_getUTCDay;
				 break L;
				 case 10: c=s.charAt(3);
				 if (c=='M') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getMinutes"";
						id=Id_getMinutes;
					 }
					 else if (c=='s') {
						 X=""setMinutes"";
						id=Id_setMinutes;
					 }
				 }
				 else if (c=='S') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getSeconds"";
						id=Id_getSeconds;
					 }
					 else if (c=='s') {
						 X=""setSeconds"";
						id=Id_setSeconds;
					 }
				 }
				 else if (c=='U') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getUTCDate"";
						id=Id_getUTCDate;
					 }
					 else if (c=='s') {
						 X=""setUTCDate"";
						id=Id_setUTCDate;
					 }
				 }
				 break L;
				 case 11: switch (s.charAt(3)) {
					 case 'F': c=s.charAt(0);
					 if (c=='g') {
						 X=""getFullYear"";
						id=Id_getFullYear;
					 }
					 else if (c=='s') {
						 X=""setFullYear"";
						id=Id_setFullYear;
					 }
					 break L;
					 case 'M': X=""toGMTString"";
					id=Id_toGMTString;
					 break L;
					 case 'T': X=""toUTCString"";
					id=Id_toUTCString;
					 break L;
					 case 'U': c=s.charAt(0);
					 if (c=='g') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""getUTCHours"";
							id=Id_getUTCHours;
						 }
						 else if (c=='t') {
							 X=""getUTCMonth"";
							id=Id_getUTCMonth;
						 }
					 }
					 else if (c=='s') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""setUTCHours"";
							id=Id_setUTCHours;
						 }
						 else if (c=='t') {
							 X=""setUTCMonth"";
							id=Id_setUTCMonth;
						 }
					 }
					 break L;
					 case 's': X=""constructor"";
					id=Id_constructor;
					 break L;
				 }
				 break L;
				 case 12: c=s.charAt(2);
				 if (c=='D') {
					 X=""toDateString"";
					id=Id_toDateString;
				 }
				 else if (c=='T') {
					 X=""toTimeString"";
					id=Id_toTimeString;
				 }
				 break L;
				 case 13: c=s.charAt(0);
				 if (c=='g') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""getUTCMinutes"";
						id=Id_getUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""getUTCSeconds"";
						id=Id_getUTCSeconds;
					 }
				 }
				 else if (c=='s') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""setUTCMinutes"";
						id=Id_setUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""setUTCSeconds"";
						id=Id_setUTCSeconds;
					 }
				 }
				 break L;
				 case 14: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCFullYear"";
					id=Id_getUTCFullYear;
				 }
				 else if (c=='s') {
					 X=""setUTCFullYear"";
					id=Id_setUTCFullYear;
				 }
				 else if (c=='t') {
					 X=""toLocaleString"";
					id=Id_toLocaleString;
				 }
				 break L;
				 case 15: c=s.charAt(0);
				 if (c=='g') {
					 X=""getMilliseconds"";
					id=Id_getMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setMilliseconds"";
					id=Id_setMilliseconds;
				 }
				 break L;
				 case 17: X=""getTimezoneOffset"";
				id=Id_getTimezoneOffset;
				 break L;
				 case 18: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCMilliseconds"";
					id=Id_getUTCMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setUTCMilliseconds"";
					id=Id_setUTCMilliseconds;
				 }
				 else if (c=='t') {
					 c=s.charAt(8);
					 if (c=='D') {
						 X=""toLocaleDateString"";
						id=Id_toLocaleDateString;
					 }
					 else if (c=='T') {
						 X=""toLocaleTimeString"";
						id=Id_toLocaleTimeString;
					 }
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int ConstructorId_now = -3, ConstructorId_parse = -2, ConstructorId_UTC = -1, Id_constructor = 1, Id_toString = 2, Id_toTimeString = 3, Id_toDateString = 4, Id_toLocaleString = 5, Id_toLocaleTimeString = 6, Id_toLocaleDateString = 7, Id_toUTCString = 8, Id_toSource = 9, Id_valueOf = 10, Id_getTime = 11, Id_getYear = 12, Id_getFullYear = 13, Id_getUTCFullYear = 14, Id_getMonth = 15, Id_getUTCMonth = 16, Id_getDate = 17, Id_getUTCDate = 18, Id_getDay = 19, Id_getUTCDay = 20, Id_getHours = 21, Id_getUTCHours = 22, Id_getMinutes = 23, Id_getUTCMinutes = 24, Id_getSeconds = 25, Id_getUTCSeconds = 26, Id_getMilliseconds = 27, Id_getUTCMilliseconds = 28, Id_getTimezoneOffset = 29, Id_setTime = 30, Id_setMilliseconds = 31, Id_setUTCMilliseconds = 32, Id_setSeconds = 33, Id_setUTCSeconds = 34, Id_setMinutes = 35, Id_setUTCMinutes = 36, Id_setHours = 37, Id_setUTCHours = 38, Id_setDate = 39, Id_setUTCDate = 40, Id_setMonth = 41, Id_setUTCMonth = 42, Id_setFullYear = 43, Id_setUTCFullYear = 44, Id_setYear = 45, MAX_PROTOTYPE_ID = 45;
	 private static final int Id_toGMTString = Id_toUTCString;
	 private static java.util.TimeZone thisTimeZone;
	 private static double LocalTZA;
	 private static java.text.DateFormat timeZoneFormatter;
	 private static java.text.DateFormat localeDateTimeFormatter;
	 private static java.text.DateFormat localeDateFormatter;
	 private static java.text.DateFormat localeTimeFormatter;
	 private double date;
}",1,0,0,0
"public float getOutlinkScore() {
	 return (numOutlinks > 0) ? inlinkScore / numOutlinks : inlinkScore;
 }",0,0,0,0
"public float computeTableUnit(PercentBaseContext percentBaseContext, int contentAreaIPD) {
	 int sumCols = 0;
	 float factors = 0;
	 float unit = 0;
	 for (Object colWidth1 : colWidths) {
		 Length colWidth = (Length) colWidth1;
		 if (colWidth != null) {
			 sumCols += colWidth.getValue(percentBaseContext);
			 if (colWidth instanceof RelativeNumericProperty) {
				 factors += ((RelativeNumericProperty) colWidth).getTableUnits();
			 }
			 else if (colWidth instanceof TableColLength) {
				 factors += ((TableColLength) colWidth).getTableUnits();
			 }
		 }
	 }
	 if (factors > 0) {
		 if (sumCols < contentAreaIPD) {
			 unit = (contentAreaIPD - sumCols) / factors;
		 }
		 else {
			 log.warn(""No space remaining to distribute over columns."");
		 }
	 }
	 return unit;
 }",0,0,1,0
"public boolean preservesOrder() {
	 return true;
 }",0,0,0,0
"public class ScriptRuntime {
	 protected ScriptRuntime() {
	 }
	 public final static Class BooleanClass = Kit.classOrNull(""java.lang.Boolean""), ByteClass = Kit.classOrNull(""java.lang.Byte""), CharacterClass = Kit.classOrNull(""java.lang.Character""), ClassClass = Kit.classOrNull(""java.lang.Class""), DoubleClass = Kit.classOrNull(""java.lang.Double""), FloatClass = Kit.classOrNull(""java.lang.Float""), IntegerClass = Kit.classOrNull(""java.lang.Integer""), LongClass = Kit.classOrNull(""java.lang.Long""), NumberClass = Kit.classOrNull(""java.lang.Number""), ObjectClass = Kit.classOrNull(""java.lang.Object""), ShortClass = Kit.classOrNull(""java.lang.Short""), StringClass = Kit.classOrNull(""java.lang.String""), SerializableClass = Kit.classOrNull(""java.io.Serializable""), DateClass = Kit.classOrNull(""java.util.Date"");
	 public final static Class ContextClass = Kit.classOrNull(""org.mozilla.javascript.Context""), FunctionClass = Kit.classOrNull(""org.mozilla.javascript.Function""), ScriptableClass = Kit.classOrNull(""org.mozilla.javascript.Scriptable""), ScriptableObjectClass = Kit.classOrNull(""org.mozilla.javascript.ScriptableObject""), UndefinedClass = Kit.classOrNull(""org.mozilla.javascript.Undefined"");
	 private static final String XML_INIT_CLASS = ""org.mozilla.javascript.xmlimpl.XMLLibImpl"";
	 private static final String[] lazilyNames = {
	 ""RegExp"", ""org.mozilla.javascript.regexp.NativeRegExp"", ""Packages"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""java"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""getClass"", ""org.mozilla.javascript.NativeJavaTopPackage"", ""JavaAdapter"", ""org.mozilla.javascript.JavaAdapter"", ""JavaImporter"", ""org.mozilla.javascript.ImporterTopLevel"", ""XML"", XML_INIT_CLASS, ""XMLList"", XML_INIT_CLASS, ""Namespace"", XML_INIT_CLASS, ""QName"", XML_INIT_CLASS, }
	;
	 private static final Object LIBRARY_SCOPE_KEY = new Object();
	 private static final Object CONTEXT_FACTORY_KEY = new Object();
	 public static ScriptableObject initStandardObjects(Context cx, ScriptableObject scope, boolean sealed) {
		 if (scope == null) {
			 scope = new NativeObject();
		 }
		 scope.associateValue(LIBRARY_SCOPE_KEY, scope);
		 ContextFactory factory = cx.getFactory();
		 if (factory == null) {
			 factory = ContextFactory.getGlobal();
		 }
		 scope.associateValue(CONTEXT_FACTORY_KEY, factory);
		 (new ClassCache()).associate(scope);
		 BaseFunction.init(cx, scope, sealed);
		 NativeObject.init(cx, scope, sealed);
		 Scriptable objectProto = ScriptableObject.getObjectPrototype(scope);
		 Scriptable functionProto = ScriptableObject.getFunctionPrototype(scope);
		 functionProto.setPrototype(objectProto);
		 if (scope.getPrototype() == null) scope.setPrototype(objectProto);
		 NativeError.init(cx, scope, sealed);
		 NativeGlobal.init(cx, scope, sealed);
		 NativeArray.init(cx, scope, sealed);
		 NativeString.init(cx, scope, sealed);
		 NativeBoolean.init(cx, scope, sealed);
		 NativeNumber.init(cx, scope, sealed);
		 NativeDate.init(cx, scope, sealed);
		 NativeMath.init(cx, scope, sealed);
		 NativeWith.init(cx, scope, sealed);
		 NativeCall.init(cx, scope, sealed);
		 NativeScript.init(cx, scope, sealed);
		 boolean withXml = cx.hasFeature(Context.FEATURE_E4X);
		 for (int i = 0;
		 i != lazilyNames.length;
		 i += 2) {
			 String topProperty = lazilyNames[i];
			 String className = lazilyNames[i + 1];
			 if (!withXml && className == XML_INIT_CLASS) {
				 continue;
			 }
			 new LazilyLoadedCtor(scope, topProperty, className, sealed);
		 }
		 Continuation.init(cx, scope, sealed);
		 return scope;
	 }
	 public static ScriptableObject getLibraryScopeOrNull(Scriptable scope) {
		 ScriptableObject libScope;
		 libScope = (ScriptableObject)ScriptableObject. getTopScopeValue(scope, LIBRARY_SCOPE_KEY);
		 return libScope;
	 }
	 public static ContextFactory getContextFactory(Scriptable scope) {
		 ContextFactory factory;
		 factory = (ContextFactory)ScriptableObject. getTopScopeValue(scope, CONTEXT_FACTORY_KEY);
		 if (factory == null) {
			 throw new IllegalStateException(""Failed to find ContextFactory"");
		 }
		 return factory;
	 }
	 public static boolean isJSLineTerminator(int c) {
		 if ((c & 0xDFD0) != 0) {
			 return false;
		 }
		 return c == '\n' || c == '\r' || c == 0x2028 || c == 0x2029;
	 }
	 public static Boolean wrapBoolean(boolean b) {
		 return b ? Boolean.TRUE : Boolean.FALSE;
	 }
	 public static Integer wrapInt(int i) {
		 return new Integer(i);
	 }
	 public static Number wrapNumber(double x) {
		 if (x != x) {
			 return ScriptRuntime.NaNobj;
		 }
		 return new Double(x);
	 }
	 public static boolean toBoolean(Object val) {
		 if (val == null) return false;
		 if (val instanceof Boolean) return ((Boolean) val).booleanValue();
		 if (val instanceof Scriptable) {
			 if (Context.getContext().isVersionECMA1()) {
				 return val != Undefined.instance;
			 }
			 val = ((Scriptable) val).getDefaultValue(BooleanClass);
			 if (val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
			 if (val instanceof Boolean) return ((Boolean) val).booleanValue();
		 }
		 if (val instanceof String) return ((String) val).length() != 0;
		 if (val instanceof Number) {
			 double d = ((Number) val).doubleValue();
			 return (d == d && d != 0.0);
		 }
		 warnAboutNonJSObject(val);
		 return true;
	 }
	 public static boolean toBoolean(Object[] args, int index) {
		 return (index < args.length) ? toBoolean(args[index]) : false;
	 }
	 public static double toNumber(Object val) {
		 if (val instanceof Number) return ((Number) val).doubleValue();
		 if (val == null) return +0.0;
		 if (val instanceof Scriptable) {
			 val = ((Scriptable) val).getDefaultValue(NumberClass);
			 if (val != null && val instanceof Scriptable) throw errorWithClassName(""msg.primitive.expected"", val);
			 if (val instanceof Number) return ((Number) val).doubleValue();
		 }
		 if (val instanceof String) return toNumber((String) val);
		 if (val instanceof Boolean) return ((Boolean) val).booleanValue() ? 1 : +0.0;
		 warnAboutNonJSObject(val);
		 return NaN;
	 }
	 public static double toNumber(Object[] args, int index) {
		 return (index < args.length) ? toNumber(args[index]) : NaN;
	 }
	 public static final double NaN = Double.longBitsToDouble(0x7ff8000000000000L);
	 public static final double negativeZero = Double.longBitsToDouble(0x8000000000000000L);
	 public static final Double NaNobj = new Double(NaN);
	 static double stringToNumber(String s, int start, int radix) {
		 char digitMax = '9';
		 char lowerCaseBound = 'a';
		 char upperCaseBound = 'A';
		 int len = s.length();
		 if (radix < 10) {
			 digitMax = (char) ('0' + radix - 1);
		 }
		 if (radix > 10) {
			 lowerCaseBound = (char) ('a' + radix - 10);
			 upperCaseBound = (char) ('A' + radix - 10);
		 }
		 int end;
		 double sum = 0.0;
		 for (end=start;
		 end < len;
		 end++) {
			 char c = s.charAt(end);
			 int newDigit;
			 if ('0' <= c && c <= digitMax) newDigit = c - '0';
			 else if ('a' <= c && c < lowerCaseBound) newDigit = c - 'a' + 10;
			 else if ('A' <= c && c < upperCaseBound) newDigit = c - 'A' + 10;
			 else break;
			 sum = sum*radix + newDigit;
		 }
		 if (start == end) {
			 return NaN;
		 }
		 if (sum >= 9007199254740992.0) {
			 if (radix == 10) {
				 try {
					 return Double.valueOf(s.substring(start, end)).doubleValue();
				 }
				 catch (NumberFormatException nfe) {
					 return NaN;
				 }
			 }
			 else if (radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32) {
				 int bitShiftInChar = 1;
				 int digit = 0;
				 final int SKIP_LEADING_ZEROS = 0;
				 final int FIRST_EXACT_53_BITS = 1;
				 final int AFTER_BIT_53 = 2;
				 final int ZEROS_AFTER_54 = 3;
				 final int MIXED_AFTER_54 = 4;
				 int state = SKIP_LEADING_ZEROS;
				 int exactBitsLimit = 53;
				 double factor = 0.0;
				 boolean bit53 = false;
				 boolean bit54 = false;
				 for (;
				;
				) {
					 if (bitShiftInChar == 1) {
						 if (start == end) break;
						 digit = s.charAt(start++);
						 if ('0' <= digit && digit <= '9') digit -= '0';
						 else if ('a' <= digit && digit <= 'z') digit -= 'a' - 10;
						 else digit -= 'A' - 10;
						 bitShiftInChar = radix;
					 }
					 bitShiftInChar >>= 1;
					 boolean bit = (digit & bitShiftInChar) != 0;
					 switch (state) {
						 case SKIP_LEADING_ZEROS: if (bit) {
							 --exactBitsLimit;
							 sum = 1.0;
							 state = FIRST_EXACT_53_BITS;
						 }
						 break;
						 case FIRST_EXACT_53_BITS: sum *= 2.0;
						 if (bit) sum += 1.0;
						 --exactBitsLimit;
						 if (exactBitsLimit == 0) {
							 bit53 = bit;
							 state = AFTER_BIT_53;
						 }
						 break;
						 case AFTER_BIT_53: bit54 = bit;
						 factor = 2.0;
						 state = ZEROS_AFTER_54;
						 break;
						 case ZEROS_AFTER_54: if (bit) {
							 state = MIXED_AFTER_54;
						 }
						 case MIXED_AFTER_54: factor *= 2;
						 break;
					 }
				 }
				 switch (state) {
					 case SKIP_LEADING_ZEROS: sum = 0.0;
					 break;
					 case FIRST_EXACT_53_BITS: case AFTER_BIT_53: break;
					 case ZEROS_AFTER_54: if (bit54 & bit53) sum += 1.0;
					 sum *= factor;
					 break;
					 case MIXED_AFTER_54: if (bit54) sum += 1.0;
					 sum *= factor;
					 break;
				 }
			 }
		 }
		 return sum;
	 }
	 public static double toNumber(String s) {
		 int len = s.length();
		 int start = 0;
		 char startChar;
		 for (;
		;
		) {
			 if (start == len) {
				 return +0.0;
			 }
			 startChar = s.charAt(start);
			 if (!Character.isWhitespace(startChar)) break;
			 start++;
		 }
		 if (startChar == '0') {
			 if (start + 2 < len) {
				 int c1 = s.charAt(start + 1);
				 if (c1 == 'x' || c1 == 'X') {
					 return stringToNumber(s, start + 2, 16);
				 }
			 }
		 }
		 else if (startChar == '+' || startChar == '-') {
			 if (start + 3 < len && s.charAt(start + 1) == '0') {
				 int c2 = s.charAt(start + 2);
				 if (c2 == 'x' || c2 == 'X') {
					 double val = stringToNumber(s, start + 3, 16);
					 return startChar == '-' ? -val : val;
				 }
			 }
		 }
		 int end = len - 1;
		 char endChar;
		 while (Character.isWhitespace(endChar = s.charAt(end))) end--;
		 if (endChar == 'y') {
			 if (startChar == '+' || startChar == '-') start++;
			 if (start + 7 == end && s.regionMatches(start, ""Infinity"", 0, 8)) return startChar == '-' ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
			 return NaN;
		 }
		 String sub = s.substring(start, end+1);
		 if (MSJVM_BUG_WORKAROUNDS) {
			 for (int i=sub.length()-1;
			 i >= 0;
			 i--) {
				 char c = sub.charAt(i);
				 if (('0' <= c && c <= '9') || c == '.' || c == 'e' || c == 'E' || c == '+' || c == '-') continue;
				 return NaN;
			 }
		 }
		 try {
			 return Double.valueOf(sub).doubleValue();
		 }
		 catch (NumberFormatException ex) {
			 return NaN;
		 }
	 }
	 public static Object[] padArguments(Object[] args, int count) {
		 if (count < args.length) return args;
		 int i;
		 Object[] result = new Object[count];
		 for (i = 0;
		 i < args.length;
		 i++) {
			 result[i] = args[i];
		 }
		 for (;
		 i < count;
		 i++) {
			 result[i] = Undefined.instance;
		 }
		 return result;
	 }
	 private final static boolean MSJVM_BUG_WORKAROUNDS = true;
	 public static String escapeString(String s) {
		 return escapeString(s, '""');
	 }
	 public static String escapeString(String s, char escapeQuote) {
		 if (!(escapeQuote == '""' || escapeQuote == '\'')) Kit.codeBug();
		 StringBuffer sb = null;
		 for(int i = 0, L = s.length();
		 i != L;
		 ++i) {
			 int c = s.charAt(i);
			 if (' ' <= c && c <= '~' && c != escapeQuote && c != '\\') {
				 if (sb != null) {
					 sb.append((char)c);
				 }
				 continue;
			 }
			 if (sb == null) {
				 sb = new StringBuffer(L + 3);
				 sb.append(s);
				 sb.setLength(i);
			 }
			 int escape = -1;
			 switch (c) {
				 case '\b': escape = 'b';
				 break;
				 case '\f': escape = 'f';
				 break;
				 case '\n': escape = 'n';
				 break;
				 case '\r': escape = 'r';
				 break;
				 case '\t': escape = 't';
				 break;
				 case 0xb: escape = 'v';
				 break;
				 case ' ': escape = ' ';
				 break;
				 case '\\': escape = '\\';
				 break;
			 }
			 if (escape >= 0) {
				 sb.append('\\');
				 sb.append((char)escape);
			 }
			 else if (c == escapeQuote) {
				 sb.append('\\');
				 sb.append(escapeQuote);
			 }
			 else {
				 int hexSize;
				 if (c < 256) {
					 sb.append(""\\x"");
					 hexSize = 2;
				 }
				 else {
					 sb.append(""\\u"");
					 hexSize = 4;
				 }
				 for (int shift = (hexSize - 1) * 4;
				 shift >= 0;
				 shift -= 4) {
					 int digit = 0xf & (c >> shift);
					 int hc = (digit < 10) ? '0' + digit : 'a' - 10 + digit;
					 sb.append((char)hc);
				 }
			 }
		 }
		 return (sb == null) ? s : sb.toString();
	 }
	 static boolean isValidIdentifierName(String s) {
		 int L = s.length();
		 if (L == 0) return false;
		 if (!Character.isJavaIdentifierStart(s.charAt(0))) return false;
		 for (int i = 1;
		 i != L;
		 ++i) {
			 if (!Character.isJavaIdentifierPart(s.charAt(i))) return false;
		 }
		 return !TokenStream.isKeyword(s);
	 }
	 public static String toString(Object val) {
		 for (;
		;
		) {
			 if (val == null) return ""null"";
			 if (val instanceof Scriptable) {
				 val = ((Scriptable) val).getDefaultValue(StringClass);
				 if (val != Undefined.instance && val instanceof Scriptable) {
					 throw errorWithClassName(""msg.primitive.expected"", val);
				 }
				 continue;
			 }
			 if (val instanceof Number) {
				 return numberToString(((Number) val).doubleValue(), 10);
			 }
			 return val.toString();
		 }
	 }
	 static String defaultObjectToString(Scriptable obj) {
		 return ""[object "" + obj.getClassName() + ""]"";
	 }
	 public static String toString(Object[] args, int index) {
		 return (index < args.length) ? toString(args[index]) : ""undefined"";
	 }
	 public static String toString(double val) {
		 return numberToString(val, 10);
	 }
	 public static String numberToString(double d, int base) {
		 if (d != d) return ""NaN"";
		 if (d == Double.POSITIVE_INFINITY) return ""Infinity"";
		 if (d == Double.NEGATIVE_INFINITY) return ""-Infinity"";
		 if (d == 0.0) return ""0"";
		 if ((base < 2) || (base > 36)) {
			 throw Context.reportRuntimeError1( ""msg.bad.radix"", Integer.toString(base));
		 }
		 if (base != 10) {
			 return DToA.JS_dtobasestr(base, d);
		 }
		 else {
			 StringBuffer result = new StringBuffer();
			 DToA.JS_dtostr(result, DToA.DTOSTR_STANDARD, 0, d);
			 return result.toString();
		 }
	 }
	 static String uneval(Context cx, Scriptable scope, Object value) {
		 if (value == null) {
			 return ""null"";
		 }
		 if (value instanceof String) {
			 String escaped = escapeString((String)value);
			 StringBuffer sb = new StringBuffer(escaped.length() + 2);
			 sb.append('\""');
			 sb.append(escaped);
			 sb.append('\""');
			 return sb.toString();
		 }
		 if (value instanceof Number) {
			 double d = ((Number)value).doubleValue();
			 if (d == 0 && 1 / d < 0) {
				 return ""-0"";
			 }
			 return toString(d);
		 }
		 if (value instanceof Boolean) {
			 return toString(value);
		 }
		 if (value == Undefined.instance) {
			 return ""undefined"";
		 }
		 if (value instanceof Scriptable) {
			 Scriptable obj = (Scriptable)value;
			 Object v = ScriptableObject.getProperty(obj, ""toSource"");
			 if (v instanceof Function) {
				 Function f = (Function)v;
				 return toString(f.call(cx, scope, obj, emptyArgs));
			 }
			 return toString(value);
		 }
		 warnAboutNonJSObject(value);
		 return value.toString();
	 }
	 static String defaultObjectToSource(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 StringBuffer result = new StringBuffer(128);
		 if (toplevel) {
			 result.append(""("");
		 }
		 result.append('{
			');
			 try {
				 if (!iterating) {
					 cx.iterating.intern(thisObj);
					 Object[] ids = thisObj.getIds();
					 for(int i=0;
					 i < ids.length;
					 i++) {
						 if (i > 0) result.append("", "");
						 Object id = ids[i];
						 Object value;
						 if (id instanceof Integer) {
							 int intId = ((Integer)id).intValue();
							 value = thisObj.get(intId, thisObj);
							 result.append(intId);
						 }
						 else {
							 String strId = (String)id;
							 value = thisObj.get(strId, thisObj);
							 if (ScriptRuntime.isValidIdentifierName(strId)) {
								 result.append(strId);
							 }
							 else {
								 result.append('\'');
								 result.append( ScriptRuntime.escapeString(strId, '\''));
								 result.append('\'');
							 }
						 }
						 result.append(':');
						 result.append(ScriptRuntime.uneval(cx, scope, value));
					 }
				 }
			 }
			 finally {
				 if (toplevel) {
					 cx.iterating = null;
				 }
			 }
		 result.append('}
		');
		 if (toplevel) {
			 result.append(')');
		 }
		 return result.toString();
	 }
	 public static Scriptable toObject(Scriptable scope, Object val) {
		 if (val instanceof Scriptable && val != Undefined.instance) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObjectOrNull(Context cx, Object obj) {
		 if (obj instanceof Scriptable) {
			 Scriptable sobj = (Scriptable)obj;
			 if (sobj != Undefined.instance) {
				 return sobj;
			 }
		 }
		 else if (obj != null) {
			 return toObject(cx, getTopCallScope(cx), obj);
		 }
		 return null;
	 }
	 public static Scriptable toObject(Scriptable scope, Object val, Class staticClass) {
		 if (val instanceof Scriptable && val != Undefined.instance) {
			 return (Scriptable)val;
		 }
		 return toObject(Context.getContext(), scope, val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val) {
		 if (val instanceof Scriptable) {
			 if (val == Undefined.instance) {
				 throw typeError0(""msg.undef.to.object"");
			 }
			 return (Scriptable) val;
		 }
		 if (val == null) {
			 throw typeError0(""msg.null.to.object"");
		 }
		 String className = val instanceof String ? ""String"" : val instanceof Number ? ""Number"" : val instanceof Boolean ? ""Boolean"" : null;
		 if (className != null) {
			 Object[] args = {
			 val }
			;
			 scope = ScriptableObject.getTopLevelScope(scope);
			 return newObject(cx, scope, className, args);
		 }
		 Object wrapped = cx.getWrapFactory().wrap(cx, scope, val, null);
		 if (wrapped instanceof Scriptable) return (Scriptable) wrapped;
		 throw errorWithClassName(""msg.invalid.type"", val);
	 }
	 public static Scriptable toObject(Context cx, Scriptable scope, Object val, Class staticClass) {
		 return toObject(cx, scope, val);
	 }
	 public static Object call(Context cx, Object fun, Object thisArg, Object[] args, Scriptable scope) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(toString(fun));
		 }
		 Function function = (Function)fun;
		 Scriptable thisObj = toObjectOrNull(cx, thisArg);
		 if (thisObj == null) {
			 throw undefCallError(thisObj, ""function"");
		 }
		 return function.call(cx, scope, thisObj, args);
	 }
	 public static Scriptable newObject(Context cx, Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = getExistingCtor(cx, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(cx, scope, args);
	 }
	 public static double toInteger(Object val) {
		 return toInteger(toNumber(val));
	 }
	 public static double toInteger(double d) {
		 if (d != d) return +0.0;
		 if (d == 0.0 || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) return d;
		 if (d > 0.0) return Math.floor(d);
		 else return Math.ceil(d);
	 }
	 public static double toInteger(Object[] args, int index) {
		 return (index < args.length) ? toInteger(args[index]) : +0.0;
	 }
	 public static int toInt32(Object val) {
		 if (val instanceof Integer) return ((Integer)val).intValue();
		 return toInt32(toNumber(val));
	 }
	 public static int toInt32(Object[] args, int index) {
		 return (index < args.length) ? toInt32(args[index]) : 0;
	 }
	 public static int toInt32(double d) {
		 int id = (int)d;
		 if (id == d) {
			 return id;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 d = Math.IEEEremainder(d, two32);
		 long l = (long)d;
		 return (int)l;
	 }
	 public static long toUint32(double d) {
		 long l = (long)d;
		 if (l == d) {
			 return l & 0xffffffffL;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 double two32 = 4294967296.0;
		 l = (long)Math.IEEEremainder(d, two32);
		 return l & 0xffffffffL;
	 }
	 public static long toUint32(Object val) {
		 return toUint32(toNumber(val));
	 }
	 public static char toUint16(Object val) {
		 double d = toNumber(val);
		 int i = (int)d;
		 if (i == d) {
			 return (char)i;
		 }
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY) {
			 return 0;
		 }
		 d = (d >= 0) ? Math.floor(d) : Math.ceil(d);
		 int int16 = 0x10000;
		 i = (int)Math.IEEEremainder(d, int16);
		 return (char)i;
	 }
	 private static final String DEFAULT_NS_TAG = ""__default_namespace__"";
	 public static Object setDefaultNamespace(Object namespace, Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 XMLLib xmlLib = currentXMLLib(cx);
		 Object ns = xmlLib.toDefaultXmlNamespace(cx, namespace);
		 if (!scope.has(DEFAULT_NS_TAG, scope)) {
			 ScriptableObject.defineProperty(scope, DEFAULT_NS_TAG, ns, ScriptableObject.PERMANENT | ScriptableObject.DONTENUM);
		 }
		 else {
			 scope.put(DEFAULT_NS_TAG, scope, ns);
		 }
		 return Undefined.instance;
	 }
	 public static Object searchDefaultNamespace(Context cx) {
		 Scriptable scope = cx.currentActivationCall;
		 if (scope == null) {
			 scope = getTopCallScope(cx);
		 }
		 Object nsObject;
		 for (;
		;
		) {
			 Scriptable parent = scope.getParentScope();
			 if (parent == null) {
				 nsObject = ScriptableObject.getProperty(scope, DEFAULT_NS_TAG);
				 if (nsObject == Scriptable.NOT_FOUND) {
					 return null;
				 }
				 break;
			 }
			 nsObject = scope.get(DEFAULT_NS_TAG, scope);
			 if (nsObject != Scriptable.NOT_FOUND) {
				 break;
			 }
			 scope = parent;
		 }
		 return nsObject;
	 }
	 public static Object getTopLevelProp(Scriptable scope, String id) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 return ScriptableObject.getProperty(scope, id);
	 }
	 static Function getExistingCtor(Context cx, Scriptable scope, String constructorName) {
		 Object ctorVal = ScriptableObject.getProperty(scope, constructorName);
		 if (ctorVal instanceof Function) {
			 return (Function)ctorVal;
		 }
		 if (ctorVal == Scriptable.NOT_FOUND) {
			 throw cx.reportRuntimeError1(""msg.ctor.not.found"", constructorName);
		 }
		 else {
			 throw cx.reportRuntimeError1(""msg.not.ctor"", constructorName);
		 }
	 }
	 private static long indexFromString(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (len > 0) {
			 int i = 0;
			 boolean negate = false;
			 int c = str.charAt(0);
			 if (c == '-') {
				 if (len > 1) {
					 c = str.charAt(1);
					 i = 1;
					 negate = true;
				 }
			 }
			 c -= '0';
			 if (0 <= c && c <= 9 && len <= (negate ? MAX_VALUE_LENGTH + 1 : MAX_VALUE_LENGTH)) {
				 int index = -c;
				 int oldIndex = 0;
				 i++;
				 if (index != 0) {
					 while (i != len && 0 <= (c = str.charAt(i) - '0') && c <= 9) {
						 oldIndex = index;
						 index = 10 * index - c;
						 i++;
					 }
				 }
				 if (i == len && (oldIndex > (Integer.MIN_VALUE / 10) || (oldIndex == (Integer.MIN_VALUE / 10) && c <= (negate ? -(Integer.MIN_VALUE % 10) : (Integer.MAX_VALUE % 10))))) {
					 return 0xFFFFFFFFL & (negate ? index : -index);
				 }
			 }
		 }
		 return -1L;
	 }
	 public static long testUint32String(String str) {
		 final int MAX_VALUE_LENGTH = 10;
		 int len = str.length();
		 if (1 <= len && len <= MAX_VALUE_LENGTH) {
			 int c = str.charAt(0);
			 c -= '0';
			 if (c == 0) {
				 return (len == 1) ? 0L : -1L;
			 }
			 if (1 <= c && c <= 9) {
				 long v = c;
				 for (int i = 1;
				 i != len;
				 ++i) {
					 c = str.charAt(i) - '0';
					 if (!(0 <= c && c <= 9)) {
						 return -1;
					 }
					 v = 10 * v + c;
				 }
				 if ((v >>> 32) == 0) {
					 return v;
				 }
			 }
		 }
		 return -1;
	 }
	 static Object getIndexObject(String s) {
		 long indexTest = indexFromString(s);
		 if (indexTest >= 0) {
			 return new Integer((int)indexTest);
		 }
		 return s;
	 }
	 static Object getIndexObject(double d) {
		 int i = (int)d;
		 if ((double)i == d) {
			 return new Integer((int)i);
		 }
		 return toString(d);
	 }
	 static String toStringIdOrIndex(Context cx, Object id) {
		 if (id instanceof Number) {
			 double d = ((Number)id).doubleValue();
			 int index = (int)d;
			 if (((double)index) == d) {
				 storeIndexResult(cx, index);
				 return null;
			 }
			 return toString(id);
		 }
		 else {
			 String s;
			 if (id instanceof String) {
				 s = (String)id;
			 }
			 else {
				 s = toString(id);
			 }
			 long indexTest = indexFromString(s);
			 if (indexTest >= 0) {
				 storeIndexResult(cx, (int)indexTest);
				 return null;
			 }
			 return s;
		 }
	 }
	 public static Object getObjectElem(Object obj, Object elem, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, elem);
		 }
		 return getObjectElem(sobj, elem, cx);
	 }
	 public static Object getObjectElem(Scriptable obj, Object elem, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, elem);
		 }
		 Object result;
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = ScriptableObject.getProperty(obj, index);
		 }
		 else {
			 result = ScriptableObject.getProperty(obj, s);
		 }
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectProp(Object obj, String property, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, property);
		 }
		 return getObjectProp(sobj, property, cx);
	 }
	 public static Object getObjectProp(Scriptable obj, String property, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, property);
		 }
		 Object result = ScriptableObject.getProperty(obj, property);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object getObjectIndex(Object obj, double dblIndex, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefReadError(obj, toString(dblIndex));
		 }
		 int index = (int)dblIndex;
		 if ((double)index == dblIndex) {
			 return getObjectIndex(sobj, index, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return getObjectProp(sobj, s, cx);
		 }
	 }
	 public static Object getObjectIndex(Scriptable obj, int index, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 return xmlObject.ecmaGet(cx, new Integer(index));
		 }
		 Object result = ScriptableObject.getProperty(obj, index);
		 if (result == Scriptable.NOT_FOUND) {
			 result = Undefined.instance;
		 }
		 return result;
	 }
	 public static Object setObjectElem(Object obj, Object elem, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, elem, value);
		 }
		 return setObjectElem(sobj, elem, value, cx);
	 }
	 public static Object setObjectElem(Scriptable obj, Object elem, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, elem, value);
			 return value;
		 }
		 String s = toStringIdOrIndex(cx, elem);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, s, value);
		 }
		 return value;
	 }
	 public static Object setObjectProp(Object obj, String property, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, property, value);
		 }
		 return setObjectProp(sobj, property, value, cx);
	 }
	 public static Object setObjectProp(Scriptable obj, String property, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, property, value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, property, value);
		 }
		 return value;
	 }
	 public static Object setObjectIndex(Object obj, double dblIndex, Object value, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw undefWriteError(obj, String.valueOf(dblIndex), value);
		 }
		 int index = (int)dblIndex;
		 if ((double)index == dblIndex) {
			 return setObjectIndex(sobj, index, value, cx);
		 }
		 else {
			 String s = toString(dblIndex);
			 return setObjectProp(sobj, s, value, cx);
		 }
	 }
	 public static Object setObjectIndex(Scriptable obj, int index, Object value, Context cx) {
		 if (obj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)obj;
			 xmlObject.ecmaPut(cx, new Integer(index), value);
		 }
		 else {
			 ScriptableObject.putProperty(obj, index, value);
		 }
		 return value;
	 }
	 public static boolean deleteObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaDelete(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.deleteProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.deleteProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static boolean hasObjectElem(Scriptable target, Object elem, Context cx) {
		 boolean result;
		 if (target instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)target;
			 result = xmlObject.ecmaHas(cx, elem);
		 }
		 else {
			 String s = toStringIdOrIndex(cx, elem);
			 if (s == null) {
				 int index = lastIndexResult(cx);
				 result = ScriptableObject.hasProperty(target, index);
			 }
			 else {
				 result = ScriptableObject.hasProperty(target, s);
			 }
		 }
		 return result;
	 }
	 public static Object refGet(Ref ref, Scriptable target, Context cx) {
		 return ref.get(cx, target);
	 }
	 public static Object refSet(Ref ref, Scriptable target, Object value, Context cx) {
		 return ref.set(cx, target, value);
	 }
	 public static Object refDel(Ref ref, Scriptable target, Context cx) {
		 return wrapBoolean(ref.delete(cx, target));
	 }
	 static boolean isSpecialProperty(String s) {
		 return s.equals(""__proto__"") || s.equals(""__parent__"");
	 }
	 public static Ref specialRef(Object obj, String specialProperty, Context cx) {
		 return SpecialRef.createSpecial(cx, obj, specialProperty);
	 }
	 public static Object delete(Object obj, Object id, Context cx) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 String idStr = (id == null) ? ""null"" : id.toString();
			 throw typeError2(""msg.undef.prop.delete"", toString(obj), idStr);
		 }
		 boolean result = deleteObjectElem(sobj, id, cx);
		 return wrapBoolean(result);
	 }
	 public static Object name(Context cx, Scriptable scope, String name) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (result == Scriptable.NOT_FOUND) {
				 throw notFoundError(scope, name);
			 }
			 return result;
		 }
		 return nameOrFunction(cx, scope, parent, name, false);
	 }
	 private static Object nameOrFunction(Context cx, Scriptable scope, Scriptable parentScope, String name, boolean asFunctionCall) {
		 Object result;
		 Scriptable thisObj = scope;
		 XMLObject firstXMLObject = null;
		 for (;
		;
		) {
			 if (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObj = (XMLObject)withObj;
					 if (xmlObj.ecmaHas(cx, name)) {
						 thisObj = xmlObj;
						 result = xmlObj.ecmaGet(cx, name);
						 break;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObj;
					 }
				 }
				 else {
					 result = ScriptableObject.getProperty(withObj, name);
					 if (result != Scriptable.NOT_FOUND) {
						 thisObj = withObj;
						 break;
					 }
				 }
			 }
			 else if (scope instanceof NativeCall) {
				 result = scope.get(name, scope);
				 if (result != Scriptable.NOT_FOUND) {
					 if (asFunctionCall) {
						 thisObj = ScriptableObject. getTopLevelScope(parentScope);
					 }
					 break;
				 }
			 }
			 else {
				 result = ScriptableObject.getProperty(scope, name);
				 if (result != Scriptable.NOT_FOUND) {
					 thisObj = scope;
					 break;
				 }
			 }
			 scope = parentScope;
			 parentScope = parentScope.getParentScope();
			 if (parentScope == null) {
				 result = topScopeName(cx, scope, name);
				 if (result == Scriptable.NOT_FOUND) {
					 if (firstXMLObject == null || asFunctionCall) {
						 throw notFoundError(scope, name);
					 }
					 result = firstXMLObject.ecmaGet(cx, name);
				 }
				 thisObj = scope;
				 break;
			 }
		 }
		 if (asFunctionCall) {
			 if (!(result instanceof Function)) {
				 throw notFunctionError(result, name);
			 }
			 storeScriptable(cx, thisObj);
		 }
		 return result;
	 }
	 private static Object topScopeName(Context cx, Scriptable scope, String name) {
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 return ScriptableObject.getProperty(scope, name);
	 }
	 public static Scriptable bind(Context cx, Scriptable scope, String id) {
		 Scriptable firstXMLObject = null;
		 Scriptable parent = scope.getParentScope();
		 childScopesChecks: if (parent != null) {
			 while (scope instanceof NativeWith) {
				 Scriptable withObj = scope.getPrototype();
				 if (withObj instanceof XMLObject) {
					 XMLObject xmlObject = (XMLObject)withObj;
					 if (xmlObject.ecmaHas(cx, id)) {
						 return xmlObject;
					 }
					 if (firstXMLObject == null) {
						 firstXMLObject = xmlObject;
					 }
				 }
				 else {
					 if (ScriptableObject.hasProperty(withObj, id)) {
						 return withObj;
					 }
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
			 for (;
			;
			) {
				 if (ScriptableObject.hasProperty(scope, id)) {
					 return scope;
				 }
				 scope = parent;
				 parent = parent.getParentScope();
				 if (parent == null) {
					 break childScopesChecks;
				 }
			 }
		 }
		 if (cx.useDynamicScope) {
			 scope = checkDynamicScope(cx.topCallScope, scope);
		 }
		 if (ScriptableObject.hasProperty(scope, id)) {
			 return scope;
		 }
		 return firstXMLObject;
	 }
	 public static Object setName(Scriptable bound, Object value, Context cx, Scriptable scope, String id) {
		 if (bound != null) {
			 if (bound instanceof XMLObject) {
				 XMLObject xmlObject = (XMLObject)bound;
				 xmlObject.ecmaPut(cx, id, value);
			 }
			 else {
				 ScriptableObject.putProperty(bound, id, value);
			 }
		 }
		 else {
			 if (cx.hasFeature(Context.FEATURE_STRICT_VARS)) {
				 throw Context.reportRuntimeError1(""msg.assn.create.strict"", id);
			 }
			 bound = ScriptableObject.getTopLevelScope(scope);
			 if (cx.useDynamicScope) {
				 bound = checkDynamicScope(cx.topCallScope, bound);
			 }
			 bound.put(id, bound, value);
		 }
		 return value;
	 }
	 private static class IdEnumeration {
		 Scriptable obj;
		 Object[] ids;
		 int index;
		 ObjToIntMap used;
		 String currentId;
		 boolean enumValues;
	 }
	 public static Object enumInit(Object value, Context cx, boolean enumValues) {
		 IdEnumeration x = new IdEnumeration();
		 x.obj = toObjectOrNull(cx, value);
		 if (x.obj != null) {
			 x.enumValues = enumValues;
			 enumChangeObject(x);
		 }
		 return x;
	 }
	 public static Boolean enumNext(Object enumObj) {
		 boolean result;
		 IdEnumeration x = (IdEnumeration)enumObj;
		 for (;
		;
		) {
			 if (x.obj == null) {
				 result = false;
				 break;
			 }
			 if (x.index == x.ids.length) {
				 x.obj = x.obj.getPrototype();
				 enumChangeObject(x);
				 continue;
			 }
			 Object id = x.ids[x.index++];
			 if (x.used != null && x.used.has(id)) {
				 continue;
			 }
			 if (id instanceof String) {
				 String strId = (String)id;
				 if (!x.obj.has(strId, x.obj)) continue;
				 x.currentId = strId;
			 }
			 else {
				 int intId = ((Number)id).intValue();
				 if (!x.obj.has(intId, x.obj)) continue;
				 x.currentId = String.valueOf(intId);
			 }
			 result = true;
			 break;
		 }
		 return wrapBoolean(result);
	 }
	 public static Object enumId(Object enumObj, Context cx) {
		 IdEnumeration x = (IdEnumeration)enumObj;
		 if (!x.enumValues) return x.currentId;
		 Object result;
		 String s = toStringIdOrIndex(cx, x.currentId);
		 if (s == null) {
			 int index = lastIndexResult(cx);
			 result = x.obj.get(index, x.obj);
		 }
		 else {
			 result = x.obj.get(s, x.obj);
		 }
		 return result;
	 }
	 private static void enumChangeObject(IdEnumeration x) {
		 Object[] ids = null;
		 while (x.obj != null) {
			 ids = x.obj.getIds();
			 if (ids.length != 0) {
				 break;
			 }
			 x.obj = x.obj.getPrototype();
		 }
		 if (x.obj != null && x.ids != null) {
			 Object[] previous = x.ids;
			 int L = previous.length;
			 if (x.used == null) {
				 x.used = new ObjToIntMap(L);
			 }
			 for (int i = 0;
			 i != L;
			 ++i) {
				 x.used.intern(previous[i]);
			 }
		 }
		 x.ids = ids;
		 x.index = 0;
	 }
	 public static Function getNameFunctionAndThis(String name, Context cx, Scriptable scope) {
		 Scriptable parent = scope.getParentScope();
		 if (parent == null) {
			 Object result = topScopeName(cx, scope, name);
			 if (!(result instanceof Function)) {
				 if (result == Scriptable.NOT_FOUND) {
					 throw notFoundError(scope, name);
				 }
				 else {
					 throw notFunctionError(result, name);
				 }
			 }
			 Scriptable thisObj = scope;
			 storeScriptable(cx, thisObj);
			 return (Function)result;
		 }
		 return (Function)nameOrFunction(cx, scope, parent, name, true);
	 }
	 public static Function getElemFunctionAndThis(Object obj, Object elem, Context cx) {
		 String s = toStringIdOrIndex(cx, elem);
		 if (s != null) {
			 return getPropFunctionAndThis(obj, s, cx);
		 }
		 int index = lastIndexResult(cx);
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, String.valueOf(index));
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, index);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Function)) {
			 throw notFunctionError(value, elem);
		 }
		 storeScriptable(cx, thisObj);
		 return (Function)value;
	 }
	 public static Function getPropFunctionAndThis(Object obj, String property, Context cx) {
		 Scriptable thisObj = toObjectOrNull(cx, obj);
		 if (thisObj == null) {
			 throw undefCallError(obj, property);
		 }
		 Object value;
		 for (;
		;
		) {
			 value = ScriptableObject.getProperty(thisObj, property);
			 if (value != Scriptable.NOT_FOUND) {
				 break;
			 }
			 if (!(thisObj instanceof XMLObject)) {
				 break;
			 }
			 XMLObject xmlObject = (XMLObject)thisObj;
			 Scriptable extra = xmlObject.getExtraMethodSource(cx);
			 if (extra == null) {
				 break;
			 }
			 thisObj = extra;
		 }
		 if (!(value instanceof Function)) {
			 throw notFunctionError(value, property);
		 }
		 storeScriptable(cx, thisObj);
		 return (Function)value;
	 }
	 public static Function getValueFunctionAndThis(Object value, Context cx) {
		 if (!(value instanceof Function)) {
			 throw notFunctionError(value);
		 }
		 Function f = (Function)value;
		 Scriptable thisObj = f.getParentScope();
		 if (thisObj.getParentScope() != null) {
			 if (thisObj instanceof NativeWith) {
			 }
			 else if (thisObj instanceof NativeCall) {
				 thisObj = ScriptableObject.getTopLevelScope(thisObj);
			 }
		 }
		 storeScriptable(cx, thisObj);
		 return f;
	 }
	 public static Object callRef(Function function, Scriptable thisObj, Object[] args, Context cx, Scriptable scope) {
		 if (function instanceof BaseFunction) {
			 BaseFunction bf = (BaseFunction)function;
			 Ref ref = bf.callRef(cx, scope, thisObj, args);
			 if (ref != null) {
				 storeScriptable(cx, thisObj);
				 return ref;
			 }
		 }
		 String msg = getMessage1(""msg.no.ref.from.function"", toString(function));
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static Scriptable newObject(Object fun, Context cx, Scriptable scope, Object[] args) {
		 if (!(fun instanceof Function)) {
			 throw notFunctionError(fun);
		 }
		 Function function = (Function)fun;
		 return function.construct(cx, scope, args);
	 }
	 public static Object callSpecial(Context cx, Function fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String filename, int lineNumber) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 return evalSpecial(cx, scope, callerThis, args, filename, lineNumber);
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 throw Context.reportRuntimeError1(""msg.only.from.new"", ""With"");
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return fun.call(cx, scope, thisObj, args);
	 }
	 public static Object newSpecial(Context cx, Object fun, Object[] args, Scriptable scope, int callType) {
		 if (callType == Node.SPECIALCALL_EVAL) {
			 if (NativeGlobal.isEvalFunction(fun)) {
				 throw typeError1(""msg.not.ctor"", ""eval"");
			 }
		 }
		 else if (callType == Node.SPECIALCALL_WITH) {
			 if (NativeWith.isWithFunction(fun)) {
				 return NativeWith.newWithSpecial(cx, scope, args);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
		 return newObject(fun, cx, scope, args);
	 }
	 public static Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 int L = args.length;
		 Function function;
		 if (thisObj instanceof Function) {
			 function = (Function)thisObj;
		 }
		 else {
			 Object value = thisObj.getDefaultValue(ScriptRuntime.FunctionClass);
			 if (!(value instanceof Function)) {
				 throw ScriptRuntime.notFunctionError(value, thisObj);
			 }
			 function = (Function)value;
		 }
		 Scriptable callThis = null;
		 if (L != 0) {
			 callThis = toObjectOrNull(cx, args[0]);
		 }
		 if (callThis == null) {
			 callThis = getTopCallScope(cx);
		 }
		 Object[] callArgs;
		 if (isApply) {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 Object arg1 = args[1];
				 if (arg1 == null || arg1 == Undefined.instance) {
					 callArgs = ScriptRuntime.emptyArgs;
				 }
				 else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {
					 callArgs = cx.getElements((Scriptable) arg1);
				 }
				 else {
					 throw ScriptRuntime.typeError0(""msg.arg.isnt.array"");
				 }
			 }
		 }
		 else {
			 if (L <= 1) {
				 callArgs = ScriptRuntime.emptyArgs;
			 }
			 else {
				 callArgs = new Object[L - 1];
				 System.arraycopy(args, 1, callArgs, 0, L - 1);
			 }
		 }
		 return function.call(cx, scope, callThis, callArgs);
	 }
	 public static Object evalSpecial(Context cx, Scriptable scope, Object thisArg, Object[] args, String filename, int lineNumber) {
		 if (args.length < 1) return Undefined.instance;
		 Object x = args[0];
		 if (!(x instanceof String)) {
			 if (cx.hasFeature(Context.FEATURE_STRICT_EVAL)) {
				 throw Context.reportRuntimeError0(""msg.eval.nonstring.strict"");
			 }
			 String message = ScriptRuntime.getMessage0(""msg.eval.nonstring"");
			 Context.reportWarning(message);
			 return x;
		 }
		 if (filename == null) {
			 int[] linep = new int[1];
			 filename = Context.getSourcePositionFromStack(linep);
			 if (filename != null) {
				 lineNumber = linep[0];
			 }
			 else {
				 filename = """";
			 }
		 }
		 String sourceName = ScriptRuntime. makeUrlForGeneratedScript(true, filename, lineNumber);
		 ErrorReporter reporter;
		 reporter = DefaultErrorReporter.forEval(cx.getErrorReporter());
		 Script script = cx.compileString((String)x, new Interpreter(), reporter, sourceName, 1, null);
		 ((InterpretedFunction)script).idata.evalScriptFlag = true;
		 if (script == null) {
			 String message = ScriptRuntime.getMessage0(""msg.syntax"");
			 throw new EvaluatorException(message, filename, lineNumber, null, 0);
		 }
		 Callable c = (Callable)script;
		 return c.call(cx, scope, (Scriptable)thisArg, ScriptRuntime.emptyArgs);
	 }
	 public static String typeof(Object value) {
		 if (value == Undefined.instance) return ""undefined"";
		 if (value == null) return ""object"";
		 if (value instanceof Scriptable) {
			 if (value instanceof XMLObject) return ""xml"";
			 return (value instanceof Function) ? ""function"" : ""object"";
		 }
		 if (value instanceof String) return ""string"";
		 if (value instanceof Number) return ""number"";
		 if (value instanceof Boolean) return ""boolean"";
		 throw errorWithClassName(""msg.invalid.type"", value);
	 }
	 public static String typeofName(Scriptable scope, String id) {
		 Context cx = Context.getContext();
		 Scriptable val = bind(cx, scope, id);
		 if (val == null) return ""undefined"";
		 return typeof(getObjectProp(val, id, cx));
	 }
	 public static Object add(Object val1, Object val2, Context cx) {
		 if(val1 instanceof Number && val2 instanceof Number) {
			 return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 }
		 if (val1 instanceof XMLObject) {
			 Object test = ((XMLObject)val1).addValues(cx, true, val2);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val2 instanceof XMLObject) {
			 Object test = ((XMLObject)val2).addValues(cx, false, val1);
			 if (test != Scriptable.NOT_FOUND) {
				 return test;
			 }
		 }
		 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(null);
		 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(null);
		 if (!(val1 instanceof String) && !(val2 instanceof String)) if ((val1 instanceof Number) && (val2 instanceof Number)) return wrapNumber(((Number)val1).doubleValue() + ((Number)val2).doubleValue());
		 else return wrapNumber(toNumber(val1) + toNumber(val2));
		 return toString(val1).concat(toString(val2));
	 }
	 public static Object nameIncrDecr(Scriptable scopeChain, String id, int incrDecrMask) {
		 Scriptable target;
		 Object value;
		 search: {
			 do {
				 target = scopeChain;
				 do {
					 value = target.get(id, scopeChain);
					 if (value != Scriptable.NOT_FOUND) {
						 break search;
					 }
					 target = target.getPrototype();
				 }
				 while (target != null);
				 scopeChain = scopeChain.getParentScope();
			 }
			 while (scopeChain != null);
			 throw notFoundError(scopeChain, id);
		 }
		 return doScriptableIncrDecr(target, id, scopeChain, value, incrDecrMask);
	 }
	 public static Object propIncrDecr(Object obj, String id, Context cx, int incrDecrMask) {
		 Scriptable start = toObjectOrNull(cx, obj);
		 if (start == null) {
			 throw undefReadError(obj, id);
		 }
		 Scriptable target = start;
		 Object value;
		 search: {
			 do {
				 value = target.get(id, start);
				 if (value != Scriptable.NOT_FOUND) {
					 break search;
				 }
				 target = target.getPrototype();
			 }
			 while (target != null);
			 start.put(id, start, NaNobj);
			 return NaNobj;
		 }
		 return doScriptableIncrDecr(target, id, start, value, incrDecrMask);
	 }
	 private static Object doScriptableIncrDecr(Scriptable target, String id, Scriptable protoChainStart, Object value, int incrDecrMask) {
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 target.put(id, protoChainStart, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object elemIncrDecr(Object obj, Object index, Context cx, int incrDecrMask) {
		 Object value = getObjectElem(obj, index, cx);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 setObjectElem(obj, index, result, cx);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object refIncrDecr(Ref ref, Scriptable target, Context cx, int incrDecrMask) {
		 Object value = ref.get(cx, target);
		 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
		 double number;
		 if (value instanceof Number) {
			 number = ((Number)value).doubleValue();
		 }
		 else {
			 number = toNumber(value);
			 if (post) {
				 value = wrapNumber(number);
			 }
		 }
		 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
			 ++number;
		 }
		 else {
			 --number;
		 }
		 Number result = wrapNumber(number);
		 ref.set(cx, target, result);
		 if (post) {
			 return value;
		 }
		 else {
			 return result;
		 }
	 }
	 public static Object toPrimitive(Object val) {
		 if (val == null || !(val instanceof Scriptable)) {
			 return val;
		 }
		 Scriptable s = (Scriptable)val;
		 Object result = s.getDefaultValue(null);
		 if (result instanceof Scriptable) throw typeError0(""msg.bad.default.value"");
		 return result;
	 }
	 public static boolean eq(Object x, Object y) {
		 if (x == null || x == Undefined.instance) {
			 if (y == null || y == Undefined.instance) {
				 return true;
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return false;
		 }
		 else if (x instanceof Number) {
			 return eqNumber(((Number)x).doubleValue(), y);
		 }
		 else if (x instanceof String) {
			 return eqString((String)x, y);
		 }
		 else if (x instanceof Boolean) {
			 boolean b = ((Boolean)x).booleanValue();
			 if (y instanceof Boolean) {
				 return b == ((Boolean)y).booleanValue();
			 }
			 if (y instanceof ScriptableObject) {
				 Object test = ((ScriptableObject)y).equivalentValues(x);
				 if (test != Scriptable.NOT_FOUND) {
					 return ((Boolean)test).booleanValue();
				 }
			 }
			 return eqNumber(b ? 1.0 : 0.0, y);
		 }
		 else if (x instanceof Scriptable) {
			 if (y instanceof Scriptable) {
				 if (x == y) {
					 return true;
				 }
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 if (x instanceof Wrapper && y instanceof Wrapper) {
					 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
				 }
				 return false;
			 }
			 else if (y instanceof Boolean) {
				 if (x instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)x).equivalentValues(y);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 double d = ((Boolean)y).booleanValue() ? 1.0 : 0.0;
				 return eqNumber(d, x);
			 }
			 else if (y instanceof Number) {
				 return eqNumber(((Number)y).doubleValue(), x);
			 }
			 else if (y instanceof String) {
				 return eqString((String)y, x);
			 }
			 return false;
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
	 }
	 static boolean eqNumber(double x, Object y) {
		 for (;
		;
		) {
			 if (y == null) {
				 return false;
			 }
			 else if (y instanceof Number) {
				 return x == ((Number)y).doubleValue();
			 }
			 else if (y instanceof String) {
				 return x == toNumber(y);
			 }
			 else if (y instanceof Boolean) {
				 return x == (((Boolean)y).booleanValue() ? 1.0 : +0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y == Undefined.instance) {
					 return false;
				 }
				 if (y instanceof ScriptableObject) {
					 Object xval = wrapNumber(x);
					 Object test = ((ScriptableObject)y).equivalentValues(xval);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 private static boolean eqString(String x, Object y) {
		 for (;
		;
		) {
			 if (y == null) {
				 return false;
			 }
			 else if (y instanceof String) {
				 return x.equals(y);
			 }
			 else if (y instanceof Number) {
				 return toNumber(x) == ((Number)y).doubleValue();
			 }
			 else if (y instanceof Boolean) {
				 return toNumber(x) == (((Boolean)y).booleanValue() ? 1.0 : 0.0);
			 }
			 else if (y instanceof Scriptable) {
				 if (y == Undefined.instance) {
					 return false;
				 }
				 if (y instanceof ScriptableObject) {
					 Object test = ((ScriptableObject)y).equivalentValues(x);
					 if (test != Scriptable.NOT_FOUND) {
						 return ((Boolean)test).booleanValue();
					 }
				 }
				 y = toPrimitive(y);
				 continue;
			 }
			 else {
				 warnAboutNonJSObject(y);
				 return false;
			 }
		 }
	 }
	 public static boolean shallowEq(Object x, Object y) {
		 if (x == y) {
			 if (!(x instanceof Number)) {
				 return true;
			 }
			 double d = ((Number)x).doubleValue();
			 return d == d;
		 }
		 if (x == null) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 if (y instanceof Number) {
				 return ((Number)x).doubleValue() == ((Number)y).doubleValue();
			 }
		 }
		 else if (x instanceof String) {
			 if (y instanceof String) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Boolean) {
			 if (y instanceof Boolean) {
				 return x.equals(y);
			 }
		 }
		 else if (x instanceof Scriptable) {
			 if (x instanceof Wrapper && y instanceof Wrapper) {
				 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
			 }
		 }
		 else {
			 warnAboutNonJSObject(x);
			 return x == y;
		 }
		 return false;
	 }
	 public static boolean instanceOf(Object a, Object b, Context cx, Scriptable scope) {
		 if (! (b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 if (! (a instanceof Scriptable)) return false;
		 return ((Scriptable)b).hasInstance((Scriptable)a);
	 }
	 protected static boolean jsDelegatesTo(Scriptable lhs, Scriptable rhs) {
		 Scriptable proto = lhs.getPrototype();
		 while (proto != null) {
			 if (proto.equals(rhs)) return true;
			 proto = proto.getPrototype();
		 }
		 return false;
	 }
	 public static boolean in(Object a, Object b, Context cx, Scriptable scope) {
		 if (!(b instanceof Scriptable)) {
			 throw typeError0(""msg.instanceof.not.object"");
		 }
		 return hasObjectElem((Scriptable)b, a, cx);
	 }
	 public static boolean cmp_LT(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) < 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 < d2;
	 }
	 public static boolean cmp_LE(Object val1, Object val2) {
		 double d1, d2;
		 if (val1 instanceof Number && val2 instanceof Number) {
			 d1 = ((Number)val1).doubleValue();
			 d2 = ((Number)val2).doubleValue();
		 }
		 else {
			 if (val1 instanceof Scriptable) val1 = ((Scriptable) val1).getDefaultValue(NumberClass);
			 if (val2 instanceof Scriptable) val2 = ((Scriptable) val2).getDefaultValue(NumberClass);
			 if (val1 instanceof String && val2 instanceof String) {
				 return ((String)val1).compareTo((String)val2) <= 0;
			 }
			 d1 = toNumber(val1);
			 d2 = toNumber(val2);
		 }
		 return d1 <= d2;
	 }
	 public static ScriptableObject getGlobal(Context cx) {
		 final String GLOBAL_CLASS = ""org.mozilla.javascript.tools.shell.Global"";
		 Class globalClass = Kit.classOrNull(GLOBAL_CLASS);
		 if (globalClass != null) {
			 try {
				 Class[] parm = {
				 ScriptRuntime.ContextClass }
				;
				 Constructor globalClassCtor = globalClass.getConstructor(parm);
				 Object[] arg = {
				 cx }
				;
				 return (ScriptableObject) globalClassCtor.newInstance(arg);
			 }
			 catch (NoSuchMethodException e) {
			 }
			 catch (InvocationTargetException e) {
			 }
			 catch (IllegalAccessException e) {
			 }
			 catch (InstantiationException e) {
			 }
		 }
		 return new ImporterTopLevel(cx);
	 }
	 public static boolean hasTopCall(Context cx) {
		 return (cx.topCallScope != null);
	 }
	 public static Scriptable getTopCallScope(Context cx) {
		 Scriptable scope = cx.topCallScope;
		 if (scope == null) {
			 throw new IllegalStateException();
		 }
		 return scope;
	 }
	 public static Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (scope == null) throw new IllegalArgumentException();
		 if (cx.topCallScope != null) throw new IllegalStateException();
		 Object result;
		 cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
		 cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
		 ContextFactory f = cx.getFactory();
		 try {
			 result = f.doTopCall(callable, cx, scope, thisObj, args);
		 }
		 finally {
			 cx.topCallScope = null;
			 cx.cachedXMLLib = null;
			 if (cx.currentActivationCall != null) {
				 throw new IllegalStateException();
			 }
		 }
		 return result;
	 }
	 static Scriptable checkDynamicScope(Scriptable possibleDynamicScope, Scriptable staticTopScope) {
		 if (possibleDynamicScope == staticTopScope) {
			 return possibleDynamicScope;
		 }
		 Scriptable proto = possibleDynamicScope;
		 for (;
		;
		) {
			 proto = proto.getPrototype();
			 if (proto == staticTopScope) {
				 return possibleDynamicScope;
			 }
			 if (proto == null) {
				 return staticTopScope;
			 }
		 }
	 }
	 public static void initScript(NativeFunction funObj, Scriptable thisObj, Context cx, Scriptable scope, boolean evalScript) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 int varCount = funObj.getParamAndVarCount();
		 if (varCount != 0) {
			 Scriptable varScope = scope;
			 while (varScope instanceof NativeWith) {
				 varScope = varScope.getParentScope();
			 }
			 for (int i = varCount;
			 i-- != 0;
			) {
				 String name = funObj.getParamOrVarName(i);
				 if (!ScriptableObject.hasProperty(scope, name)) {
					 if (!evalScript) {
						 ScriptableObject.defineProperty( varScope, name, Undefined.instance, ScriptableObject.PERMANENT);
					 }
					 else {
						 varScope.put(name, varScope, Undefined.instance);
					 }
				 }
			 }
		 }
	 }
	 public static Scriptable createFunctionActivation(NativeFunction funObj, Scriptable scope, Object[] args) {
		 return new NativeCall(funObj, scope, args);
	 }
	 public static void enterActivationFunction(Context cx, Scriptable activation) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 NativeCall call = (NativeCall)activation;
		 call.parentActivationCall = cx.currentActivationCall;
		 cx.currentActivationCall = call;
	 }
	 public static void exitActivationFunction(Context cx) {
		 NativeCall call = cx.currentActivationCall;
		 cx.currentActivationCall = call.parentActivationCall;
		 call.parentActivationCall = null;
	 }
	 static NativeCall findFunctionActivation(Context cx, Function f) {
		 NativeCall call = cx.currentActivationCall;
		 while (call != null) {
			 if (call.function == f) return call;
			 call = call.parentActivationCall;
		 }
		 return null;
	 }
	 public static Scriptable newCatchScope(Throwable t, Scriptable lastCatchScope, String exceptionName, Context cx, Scriptable scope) {
		 Object obj;
		 boolean cacheObj;
		 getObj: if (t instanceof JavaScriptException) {
			 cacheObj = false;
			 obj = ((JavaScriptException)t).getValue();
		 }
		 else {
			 cacheObj = true;
			 if (lastCatchScope != null) {
				 NativeObject last = (NativeObject)lastCatchScope;
				 obj = last.getAssociatedValue(t);
				 if (obj == null) Kit.codeBug();
				 break getObj;
			 }
			 RhinoException re;
			 String errorName;
			 String errorMsg;
			 Throwable javaException = null;
			 if (t instanceof EcmaError) {
				 EcmaError ee = (EcmaError)t;
				 re = ee;
				 errorName = ee.getName();
				 errorMsg = ee.getErrorMessage();
			 }
			 else if (t instanceof WrappedException) {
				 WrappedException we = (WrappedException)t;
				 re = we;
				 javaException = we.getWrappedException();
				 errorName = ""JavaException"";
				 errorMsg = javaException.getClass().getName() +"": ""+javaException.getMessage();
			 }
			 else if (t instanceof EvaluatorException) {
				 EvaluatorException ee = (EvaluatorException)t;
				 re = ee;
				 errorName = ""InternalError"";
				 errorMsg = ee.getMessage();
			 }
			 else {
				 throw Kit.codeBug();
			 }
			 String sourceUri = re.sourceName();
			 if (sourceUri == null) {
				 sourceUri = """";
			 }
			 int line = re.lineNumber();
			 Object args[];
			 if (line > 0) {
				 args = new Object[] {
				 errorMsg, sourceUri, new Integer(line) }
				;
			 }
			 else {
				 args = new Object[] {
				 errorMsg, sourceUri }
				;
			 }
			 Scriptable errorObject = cx.newObject(scope, errorName, args);
			 ScriptableObject.putProperty(errorObject, ""name"", errorName);
			 if (javaException != null) {
				 Object wrap = cx.getWrapFactory().wrap(cx, scope, javaException, null);
				 ScriptableObject.defineProperty( errorObject, ""javaException"", wrap, ScriptableObject.PERMANENT | ScriptableObject.READONLY);
			 }
			 obj = errorObject;
		 }
		 NativeObject catchScopeObject = new NativeObject();
		 catchScopeObject.defineProperty( exceptionName, obj, ScriptableObject.PERMANENT);
		 if (cacheObj) {
			 catchScopeObject.associateValue(t, obj);
		 }
		 return catchScopeObject;
	 }
	 public static Scriptable enterWith(Object obj, Context cx, Scriptable scope) {
		 Scriptable sobj = toObjectOrNull(cx, obj);
		 if (sobj == null) {
			 throw typeError1(""msg.undef.with"", toString(obj));
		 }
		 if (sobj instanceof XMLObject) {
			 XMLObject xmlObject = (XMLObject)sobj;
			 return xmlObject.enterWith(scope);
		 }
		 return new NativeWith(scope, sobj);
	 }
	 public static Scriptable leaveWith(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static Scriptable enterDotQuery(Object value, Scriptable scope) {
		 if (!(value instanceof XMLObject)) {
			 throw notXmlError(value);
		 }
		 XMLObject object = (XMLObject)value;
		 return object.enterDotQuery(scope);
	 }
	 public static Object updateDotQuery(boolean value, Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.updateDotQuery(value);
	 }
	 public static Scriptable leaveDotQuery(Scriptable scope) {
		 NativeWith nw = (NativeWith)scope;
		 return nw.getParentScope();
	 }
	 public static void setFunctionProtoAndParent(BaseFunction fn, Scriptable scope) {
		 fn.setParentScope(scope);
		 fn.setPrototype(ScriptableObject.getFunctionPrototype(scope));
	 }
	 public static void setObjectProtoAndParent(ScriptableObject object, Scriptable scope) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 object.setParentScope(scope);
		 Scriptable proto = ScriptableObject.getClassPrototype(scope, object.getClassName());
		 object.setPrototype(proto);
	 }
	 public static void initFunction(Context cx, Scriptable scope, NativeFunction function, int type, boolean fromEvalCode) {
		 if (type == FunctionNode.FUNCTION_STATEMENT) {
			 String name = function.functionName;
			 if (name != null && name.length() != 0) {
				 if (!fromEvalCode) {
					 ScriptableObject.defineProperty (scope, name, function, ScriptableObject.PERMANENT);
				 }
				 else {
					 scope.put(name, scope, function);
				 }
			 }
		 }
		 else if (type == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
			 String name = function.functionName;
			 if (name != null && name.length() != 0) {
				 while (scope instanceof NativeWith) {
					 scope = scope.getParentScope();
				 }
				 scope.put(name, scope, function);
			 }
		 }
		 else {
			 throw Kit.codeBug();
		 }
	 }
	 public static Scriptable newArrayLiteral(Object[] objects, int[] skipIndexces, Context cx, Scriptable scope) {
		 int count = objects.length;
		 int skipCount = 0;
		 if (skipIndexces != null) {
			 skipCount = skipIndexces.length;
		 }
		 int length = count + skipCount;
		 Integer lengthObj = new Integer(length);
		 Scriptable arrayObj;
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 arrayObj = cx.newObject(scope, ""Array"", ScriptRuntime.emptyArgs);
			 ScriptableObject.putProperty(arrayObj, ""length"", lengthObj);
		 }
		 else {
			 arrayObj = cx.newObject(scope, ""Array"", new Object[] {
			 lengthObj }
			);
		 }
		 int skip = 0;
		 for (int i = 0, j = 0;
		 i != length;
		 ++i) {
			 if (skip != skipCount && skipIndexces[skip] == i) {
				 ++skip;
				 continue;
			 }
			 ScriptableObject.putProperty(arrayObj, i, objects[j]);
			 ++j;
		 }
		 return arrayObj;
	 }
	 public static Scriptable newObjectLiteral(Object[] propertyIds, Object[] propertyValues, Context cx, Scriptable scope) {
		 Scriptable object = cx.newObject(scope);
		 for (int i = 0, end = propertyIds.length;
		 i != end;
		 ++i) {
			 Object id = propertyIds[i];
			 Object value = propertyValues[i];
			 if (id instanceof String) {
				 ScriptableObject.putProperty(object, (String)id, value);
			 }
			 else {
				 int index = ((Integer)id).intValue();
				 ScriptableObject.putProperty(object, index, value);
			 }
		 }
		 return object;
	 }
	 public static boolean isArrayObject(Object obj) {
		 return obj instanceof NativeArray || obj instanceof Arguments;
	 }
	 public static Object[] getArrayElements(Scriptable object) {
		 Context cx = Context.getContext();
		 long longLen = NativeArray.getLengthProperty(cx, object);
		 if (longLen > Integer.MAX_VALUE) {
			 throw new IllegalArgumentException();
		 }
		 int len = (int) longLen;
		 if (len == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 else {
			 Object[] result = new Object[len];
			 for (int i=0;
			 i < len;
			 i++) {
				 Object elem = ScriptableObject.getProperty(object, i);
				 result[i] = (elem == Scriptable.NOT_FOUND) ? Undefined.instance : elem;
			 }
			 return result;
		 }
	 }
	 static void checkDeprecated(Context cx, String name) {
		 int version = cx.getLanguageVersion();
		 if (version >= Context.VERSION_1_4 || version == Context.VERSION_DEFAULT) {
			 String msg = getMessage1(""msg.deprec.ctor"", name);
			 if (version == Context.VERSION_DEFAULT) Context.reportWarning(msg);
			 else throw Context.reportRuntimeError(msg);
		 }
	 }
	 public static String getMessage0(String messageId) {
		 return getMessage(messageId, null);
	 }
	 public static String getMessage1(String messageId, Object arg1) {
		 Object[] arguments = {
		arg1}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage2( String messageId, Object arg1, Object arg2) {
		 Object[] arguments = {
		arg1, arg2}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage3( String messageId, Object arg1, Object arg2, Object arg3) {
		 Object[] arguments = {
		arg1, arg2, arg3}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage4( String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 Object[] arguments = {
		arg1, arg2, arg3, arg4}
		;
		 return getMessage(messageId, arguments);
	 }
	 public static String getMessage(String messageId, Object[] arguments) {
		 final String defaultResource = ""org.mozilla.javascript.resources.Messages"";
		 Context cx = Context.getCurrentContext();
		 Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();
		 ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);
		 String formatString;
		 try {
			 formatString = rb.getString(messageId);
		 }
		 catch (java.util.MissingResourceException mre) {
			 throw new RuntimeException (""no message resource found for message property ""+ messageId);
		 }
		 MessageFormat formatter = new MessageFormat(formatString);
		 return formatter.format(arguments);
	 }
	 public static EcmaError constructError(String error, String message) {
		 int line = 0;
		 String filename = null;
		 Context cx = Context.getCurrentContext();
		 if (cx != null) {
			 int[] linep = new int[1];
			 filename = cx.getSourcePositionFromStack(linep);
			 line = linep[0];
		 }
		 return constructError(error, message, filename, line, null, 0);
	 }
	 public static EcmaError constructError(String error, String message, String sourceName, int lineNumber, String lineSource, int columnNumber) {
		 return new EcmaError(error, message, sourceName, lineNumber, lineSource, columnNumber);
	 }
	 public static EcmaError typeError(String message) {
		 return constructError(""TypeError"", message);
	 }
	 public static EcmaError typeError0(String messageId) {
		 String msg = getMessage0(messageId);
		 return typeError(msg);
	 }
	 public static EcmaError typeError1(String messageId, String arg1) {
		 String msg = getMessage1(messageId, arg1);
		 return typeError(msg);
	 }
	 public static EcmaError typeError2(String messageId, String arg1, String arg2) {
		 String msg = getMessage2(messageId, arg1, arg2);
		 return typeError(msg);
	 }
	 public static EcmaError typeError3(String messageId, String arg1, String arg2, String arg3) {
		 String msg = getMessage3(messageId, arg1, arg2, arg3);
		 return typeError(msg);
	 }
	 public static RuntimeException undefReadError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.prop.read"", toString(object), idStr);
	 }
	 public static RuntimeException undefCallError(Object object, Object id) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 return typeError2(""msg.undef.method.call"", toString(object), idStr);
	 }
	 public static RuntimeException undefWriteError(Object object, Object id, Object value) {
		 String idStr = (id == null) ? ""null"" : id.toString();
		 String valueStr = (value instanceof Scriptable) ? value.toString() : toString(value);
		 return typeError3(""msg.undef.prop.write"", toString(object), idStr, valueStr);
	 }
	 public static RuntimeException notFoundError(Scriptable object, String property) {
		 String msg = getMessage1(""msg.is.not.defined"", property);
		 throw constructError(""ReferenceError"", msg);
	 }
	 public static RuntimeException notFunctionError(Object value) {
		 return notFunctionError(value, value);
	 }
	 public static RuntimeException notFunctionError(Object value, Object messageHelper) {
		 String msg = (messageHelper == null) ? ""null"" : messageHelper.toString();
		 return typeError1(""msg.isnt.function"", msg);
	 }
	 private static RuntimeException notXmlError(Object value) {
		 throw typeError1(""msg.isnt.xml.object"", ScriptRuntime.toString(value));
	 }
	 private static void warnAboutNonJSObject(Object nonJSObject) {
		 String message =""RHINO USAGE WARNING: Missed Context.javaToJS() conversion:\n""+""Rhino runtime detected object ""+nonJSObject+"" of class ""+nonJSObject.getClass().getName()+"" where it expected String, Number, Boolean or Scriptable instance. Please check your code for missig Context.javaToJS() call."";
		 Context.reportWarning(message);
		 System.err.println(message);
	 }
	 public static RegExpProxy getRegExpProxy(Context cx) {
		 return cx.getRegExpProxy();
	 }
	 public static RegExpProxy checkRegExpProxy(Context cx) {
		 RegExpProxy result = getRegExpProxy(cx);
		 if (result == null) {
			 throw cx.reportRuntimeError0(""msg.no.regexp"");
		 }
		 return result;
	 }
	 private static XMLLib currentXMLLib(Context cx) {
		 if (cx.topCallScope == null) throw new IllegalStateException();
		 XMLLib xmlLib = cx.cachedXMLLib;
		 if (xmlLib == null) {
			 xmlLib = XMLLib.extractFromScope(cx.topCallScope);
			 if (xmlLib == null) throw new IllegalStateException();
			 cx.cachedXMLLib = xmlLib;
		 }
		 return xmlLib;
	 }
	 public static String escapeAttributeValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeAttributeValue(value);
	 }
	 public static String escapeTextValue(Object value, Context cx) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.escapeTextValue(value);
	 }
	 public static Ref memberRef(Object obj, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, elem, memberTypeFlags);
	 }
	 public static Ref memberRef(Object obj, Object namespace, Object elem, Context cx, int memberTypeFlags) {
		 if (!(obj instanceof XMLObject)) {
			 throw notXmlError(obj);
		 }
		 XMLObject xmlObject = (XMLObject)obj;
		 return xmlObject.memberRef(cx, namespace, elem, memberTypeFlags);
	 }
	 public static Ref nameRef(Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, name, scope, memberTypeFlags);
	 }
	 public static Ref nameRef(Object namespace, Object name, Context cx, Scriptable scope, int memberTypeFlags) {
		 XMLLib xmlLib = currentXMLLib(cx);
		 return xmlLib.nameRef(cx, namespace, name, scope, memberTypeFlags);
	 }
	 private static void storeIndexResult(Context cx, int index) {
		 cx.scratchIndex = index;
	 }
	 static int lastIndexResult(Context cx) {
		 return cx.scratchIndex;
	 }
	 public static void storeUint32Result(Context cx, long value) {
		 if ((value >>> 32) != 0) throw new IllegalArgumentException();
		 cx.scratchUint32 = value;
	 }
	 public static long lastUint32Result(Context cx) {
		 long value = cx.scratchUint32;
		 if ((value >>> 32) != 0) throw new IllegalStateException();
		 return value;
	 }
	 private static void storeScriptable(Context cx, Scriptable value) {
		 if (cx.scratchScriptable != null) throw new IllegalStateException();
		 cx.scratchScriptable = value;
	 }
	 public static Scriptable lastStoredScriptable(Context cx) {
		 Scriptable result = cx.scratchScriptable;
		 cx.scratchScriptable = null;
		 return result;
	 }
	 static String makeUrlForGeneratedScript (boolean isEval, String masterScriptUrl, int masterScriptLine) {
		 if (isEval) {
			 return masterScriptUrl+'#'+masterScriptLine+""(eval)"";
		 }
		 else {
			 return masterScriptUrl+'#'+masterScriptLine+""(Function)"";
		 }
	 }
	 static boolean isGeneratedScript(String sourceUrl) {
		 return sourceUrl.indexOf(""(eval)"") >= 0 || sourceUrl.indexOf(""(Function)"") >= 0;
	 }
	 private static RuntimeException errorWithClassName(String msg, Object val) {
		 return Context.reportRuntimeError1(msg, val.getClass().getName());
	 }
	 public static final Object[] emptyArgs = new Object[0];
	 public static final String[] emptyStrings = new String[0];
}",1,0,0,0
"public final void treeNodesInserted(TreeModelEvent e){
	if (dirtyAll){
		return;
	}
	Object parentNode = e.getTreePath().getLastPathComponent();
	TreeItem parentItem = nodeToItemMap.get(parentNode);
	if (parentItem != null && isNodeVisible(parentNode)){
		List<T> eventChildren = Arrays.asList(e.getChildren());
		boolean wasLeaf = true;
		int nodeChildCount = getChildCount(parentNode);
		for (int i = 0;
		 wasLeaf && i < nodeChildCount;
		 i++){
			wasLeaf = eventChildren.contains(getChildAt(parentNode, i));
		}
		boolean addingToHiddedRoot = parentItem.getParentItem() == null && isRootLess();
		if (wasLeaf && !addingToHiddedRoot){
			Object grandparentNode = getParentNode(parentNode);
			boolean addingToHiddedRootSon = grandparentNode != null &&getParentNode(grandparentNode) == null && isRootLess();
			if (grandparentNode != null && !addingToHiddedRootSon){
				invalidateNodeWithChildren(grandparentNode);
			}
			else{
				invalidateNode(parentNode, true);
			}
			getTreeState().expandNode(parentNode);
		}
		else{
			if (isNodeExpanded(parentNode)){
				List<TreeItem> itemChildren = parentItem.getChildren();
				int childLevel = parentItem.getLevel() + 1;
				final int[] childIndices = e.getChildIndices();
				for (int i = 0;
				 i < eventChildren.size();
				 ++i){
					TreeItem item = newTreeItem(parentItem, eventChildren.get(i), childLevel);
					itemContainer.add(item);
					if (itemChildren != null){
						itemChildren.add(childIndices[i], item);
						markTheLastButOneChildDirty(parentItem, item);
					}
					if (!dirtyItems.contains(item)){
						dirtyItems.add(item);
					}
					if (!dirtyItemsCreateDOM.contains(item) &&!item.hasParentWithChildrenMarkedToRecreation()){
						dirtyItemsCreateDOM.add(item);
					}
				}
			}
		}
	}
}",0,0,0,0
"public int run( String argv[] ) throws Exception {
	 if (argv.length < 1) {
		 printUsage("""");
		 return -1;
	 }
	 int exitCode = -1;
	 int i = 0;
	 String cmd = argv[i++];
	 if (""-put"".equals(cmd) || ""-get"".equals(cmd) || ""-copyFromLocal"".equals(cmd) || ""-moveFromLocal"".equals(cmd) || ""-copyToLocal"".equals(cmd) || ""-moveToLocal"".equals(cmd)) {
		 if (argv.length != 3) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 else if (""-mv"".equals(cmd) || ""-cp"".equals(cmd)) {
		 if (argv.length < 3) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 else if (""-rm"".equals(cmd) || ""-rmr"".equals(cmd) || ""-cat"".equals(cmd) || ""-mkdir"".equals(cmd)) {
		 if (argv.length < 2) {
			 printUsage(cmd);
			 return exitCode;
		 }
	 }
	 try {
		 init();
	 }
	 catch (RPC.VersionMismatch v) {
		 System.err.println(""Version Mismatch between client and server"" + ""... command aborted."");
		 return exitCode;
	 }
	 catch (IOException e) {
		 System.err.println(""Bad connection to DFS... command aborted."");
		 return exitCode;
	 }
	 exitCode = 0;
	 try {
		 if (""-put"".equals(cmd) || ""-copyFromLocal"".equals(cmd)) {
			 copyFromLocal(new Path(argv[i++]), argv[i++]);
		 }
		 else if (""-moveFromLocal"".equals(cmd)) {
			 moveFromLocal(new Path(argv[i++]), argv[i++]);
		 }
		 else if (""-get"".equals(cmd) || ""-copyToLocal"".equals(cmd)) {
			 copyToLocal(argv[i++], argv[i++]);
		 }
		 else if (""-getmerge"".equals(cmd)) {
			 if(argv.length>i+2) copyMergeToLocal(argv[i++], new Path(argv[i++]), Boolean.parseBoolean(argv[i++]));
			 else copyMergeToLocal(argv[i++], new Path(argv[i++]));
		 }
		 else if (""-cat"".equals(cmd)) {
			 exitCode = doall(cmd, argv, conf, i);
		 }
		 else if (""-moveToLocal"".equals(cmd)) {
			 moveToLocal(argv[i++], new Path(argv[i++]));
		 }
		 else if (""-setrep"".equals(cmd)) {
			 setReplication(argv, i);
		 }
		 else if (""-ls"".equals(cmd)) {
			 if (i < argv.length) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else {
				 ls("""", false);
			 }
		 }
		 else if (""-lsr"".equals(cmd)) {
			 if (i < argv.length) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else {
				 ls("""", true);
			 }
		 }
		 else if (""-mv"".equals(cmd)) {
			 exitCode = rename(argv, conf);
		 }
		 else if (""-cp"".equals(cmd)) {
			 exitCode = copy(argv, conf);
		 }
		 else if (""-rm"".equals(cmd)) {
			 exitCode = doall(cmd, argv, conf, i);
		 }
		 else if (""-rmr"".equals(cmd)) {
			 exitCode = doall(cmd, argv, conf, i);
		 }
		 else if (""-du"".equals(cmd)) {
			 if (i < argv.length) {
				 exitCode = doall(cmd, argv, conf, i);
			 }
			 else {
				 du("""");
			 }
		 }
		 else if (""-mkdir"".equals(cmd)) {
			 exitCode = doall(cmd, argv, conf, i);
		 }
		 else {
			 exitCode = -1;
			 System.err.println(cmd.substring(1) + "": Unknown command"");
			 printUsage("""");
		 }
	 }
	 catch (RemoteException e) {
		 exitCode = -1;
		 try {
			 String[] content;
			 content = e.getLocalizedMessage().split(""\n"");
			 System.err.println(cmd.substring(1) + "": "" + content[0]);
		 }
		 catch (Exception ex) {
			 System.err.println(cmd.substring(1) + "": "" + ex.getLocalizedMessage());
		 }
	 }
	 catch (IOException e ) {
		 exitCode = -1;
		 System.err.println(cmd.substring(1) + "": "" + e.getLocalizedMessage());
	 }
	 finally {
		 fs.close();
	 }
	 return exitCode;
 }",0,0,1,0
"public int available() throws IOException {
	 if (entrySize - entryOffset > Integer.MAX_VALUE) {
		 return Integer.MAX_VALUE;
	 }
	 return (int) (entrySize - entryOffset);
 }",0,0,0,0
"class WindowedProcessorBolt extends BaseWindowedBolt implements StreamBolt {
	 private static final Logger LOG = LoggerFactory.getLogger(WindowedProcessorBolt.class);
	 private final ProcessorBoltDelegate delegate;
	 private final Window<?, ?> window;
	 WindowedProcessorBolt(String id, DirectedGraph<Node, Edge> graph, List<ProcessorNode> nodes, Window<?, ?> window) {
		 delegate = new ProcessorBoltDelegate(id, graph, nodes);
		 this.window = window;
		 setWindowConfig();
	 }
	 public void prepare(Map<String, Object> topoConf, TopologyContext context, OutputCollector collector) {
		 delegate.prepare(topoConf, context, collector);
	 }
	 public void execute(TupleWindow inputWindow) {
		 LOG.trace(""Window triggered at {
		}
		, inputWindow {
		}
		"", new Date(), inputWindow);
		 if (delegate.isEventTimestamp()) {
			 delegate.setEventTimestamp(inputWindow.getEndTimestamp());
		 }
		 for (Tuple tuple : inputWindow.get()) {
			 Pair<Object, String> valueAndStream = delegate.getValueAndStream(tuple);
			 if (!StreamUtil.isPunctuation(valueAndStream.getFirst())) {
				 delegate.process(valueAndStream.getFirst(), valueAndStream.getSecond());
			 }
		 }
		 for (String stream : delegate.getInitialStreams()) {
			 delegate.process(PUNCTUATION, stream);
		 }
	 }
	 public void declareOutputFields(OutputFieldsDeclarer declarer) {
		 delegate.declareOutputFields(declarer);
	 }
	 public void setTimestampField(String fieldName) {
		 delegate.setTimestampField(fieldName);
	 }
	 public String getId() {
		 return delegate.getId();
	 }
	 private void setWindowConfig() {
		 if (window instanceof SlidingWindows) {
			 setSlidingWindowParams(window.getWindowLength(), window.getSlidingInterval());
		 }
		 else if (window instanceof TumblingWindows) {
			 setTumblingWindowParams(window.getWindowLength());
		 }
		 if (window.getTimestampField() != null) {
			 withTimestampField(window.getTimestampField());
		 }
		 if (window.getLag() != null) {
			 withLag(window.getLag());
		 }
		 if (window.getLateTupleStream() != null) {
			 withLateTupleStream(window.getLateTupleStream());
		 }
	 }
	 private void setSlidingWindowParams(Object windowLength, Object slidingInterval) {
		 if (windowLength instanceof Count) {
			 if (slidingInterval instanceof Count) {
				 withWindow((Count) windowLength, (Count) slidingInterval);
			 }
			 else if (slidingInterval instanceof Duration) {
				 withWindow((Count) windowLength, (Duration) slidingInterval);
			 }
		 }
		 else if (windowLength instanceof Duration) {
			 if (slidingInterval instanceof Count) {
				 withWindow((Duration) windowLength, (Count) slidingInterval);
			 }
			 else if (slidingInterval instanceof Duration) {
				 withWindow((Duration) windowLength, (Duration) slidingInterval);
			 }
		 }
	 }
	 private void setTumblingWindowParams(Object windowLength) {
		 if (windowLength instanceof Count) {
			 withTumblingWindow((Count) windowLength);
		 }
		 else if (windowLength instanceof Duration) {
			 withTumblingWindow((Duration) windowLength);
		 }
	 }
	 void setStreamToInitialProcessors(Multimap<String, ProcessorNode> streamToInitialProcessors) {
		 delegate.setStreamToInitialProcessors(streamToInitialProcessors);
	 }
}",0,0,0,0
"public void addStripLineBreaks(final StripLineBreaks stripLineBreaks) {
	 if (isReference()) {
		 throw noChildrenAllowed();
	 }
	 setChecked(false);
	 filterReaders.addElement(stripLineBreaks);
 }",0,0,0,0
"public interface DocumentEntityPrePersist {
	 DocumentEntity getEntity();
	 static DocumentEntityPrePersist of(DocumentEntity entity) {
		 Objects.requireNonNull(entity, ""Entity is required"");
		 return new DefaultDocumentEntityPrePersist(entity);
	 }
}",0,0,0,0
"public static class TimeHash implements DrillSimpleFunc {
	 TimeHolder in;
	 BigIntHolder seed;
	 BigIntHolder out;
	 public void setup() {
	 }
	 public void eval() {
		 out.value = org.apache.drill.exec.expr.fn.impl.HashHelper.hash64(in.value, seed.value);
	 }
 }",0,0,0,0
"private static class update_partition_column_statistics_resultTupleSchemeFactory implements SchemeFactory {
	 public update_partition_column_statistics_resultTupleScheme getScheme() {
		 return new update_partition_column_statistics_resultTupleScheme();
	 }
 }",0,0,0,0
"protected void writeTransactionResponse(ResponseCode response, String explanation) throws IOException {
	 HttpCommunicationsSession commSession = (HttpCommunicationsSession) peer.getCommunicationsSession();
	 if(TransferDirection.RECEIVE.equals(direction)){
		 switch (response) {
			 case CONFIRM_TRANSACTION: logger.debug(""{
			}
			 Confirming transaction. checksum={
			}
			"", this, explanation);
			 commSession.setChecksum(explanation);
			 break;
			 case TRANSACTION_FINISHED: logger.debug(""{
			}
			 Finishing transaction."", this);
			 break;
			 case CANCEL_TRANSACTION: logger.debug(""{
			}
			 Canceling transaction. explanation={
			}
			"", this, explanation);
			 TransactionResultEntity resultEntity = apiClient.commitReceivingFlowFiles(transactionUrl, ResponseCode.CANCEL_TRANSACTION, null);
			 ResponseCode cancelResponse = ResponseCode.fromCode(resultEntity.getResponseCode());
			 switch (cancelResponse) {
				 case CANCEL_TRANSACTION: logger.debug(""{
				}
				 CANCEL_TRANSACTION, The transaction is canceled on server properly."", this);
				 break;
				 default: logger.warn(""{
				}
				 CANCEL_TRANSACTION, Expected the transaction is canceled on server, but received {
				}
				."", this, cancelResponse);
				 break;
			 }
			 break;
		 }
	 }
	 else {
		 switch (response) {
			 case FINISH_TRANSACTION: logger.debug(""{
			}
			 Finished sending flow files."", this);
			 break;
			 case BAD_CHECKSUM: {
				 TransactionResultEntity resultEntity = apiClient.commitTransferFlowFiles(transactionUrl, ResponseCode.BAD_CHECKSUM);
				 ResponseCode badChecksumCancelResponse = ResponseCode.fromCode(resultEntity.getResponseCode());
				 switch (badChecksumCancelResponse) {
					 case CANCEL_TRANSACTION: logger.debug(""{
					}
					 BAD_CHECKSUM, The transaction is canceled on server properly."", this);
					 break;
					 default: logger.warn(""{
					}
					 BAD_CHECKSUM, Expected the transaction is canceled on server, but received {
					}
					."", this, badChecksumCancelResponse);
					 break;
				 }
			 }
			 break;
			 case CONFIRM_TRANSACTION: logger.debug(""{
			}
			 Transaction is confirmed."", this);
			 break;
			 case CANCEL_TRANSACTION: {
				 logger.debug(""{
				}
				 Canceling transaction."", this);
				 TransactionResultEntity resultEntity = apiClient.commitTransferFlowFiles(transactionUrl, ResponseCode.CANCEL_TRANSACTION);
				 ResponseCode cancelResponse = ResponseCode.fromCode(resultEntity.getResponseCode());
				 switch (cancelResponse) {
					 case CANCEL_TRANSACTION: logger.debug(""{
					}
					 CANCEL_TRANSACTION, The transaction is canceled on server properly."", this);
					 break;
					 default: logger.warn(""{
					}
					 CANCEL_TRANSACTION, Expected the transaction is canceled on server, but received {
					}
					."", this, cancelResponse);
					 break;
				 }
			 }
			 break;
		 }
	 }
 }",0,0,1,0
"public class ReportingUDF extends EvalFunc<Integer> {
	 public Integer exec(Tuple input) throws IOException {
		 try {
			 Thread.sleep(7500);
			 PigStatusReporter reporter = PigStatusReporter.getInstance();
			 reporter.progress();
			 Thread.sleep(7500);
		 }
		 catch (InterruptedException e) {
		 }
		 return 100;
	 }
}",1,0,0,0
"public int compareTo(FactPartition o) {
	 int colComp = this.partCol.compareTo(o.partCol);
	 if (colComp == 0) {
		 int partComp = 0;
		 if (this.partSpec != null) {
			 if (o.partSpec == null) {
				 partComp = 1;
			 }
			 else {
				 partComp = this.partSpec.compareTo(o.partSpec);
			 }
		 }
		 else {
			 if (o.partSpec != null) {
				 partComp = -1;
			 }
			 else {
				 partComp = 0;
			 }
		 }
		 if (partComp == 0) {
			 int upComp = 0;
			 if (this.period != null && o.period != null) {
				 upComp = this.period.compareTo(o.period);
			 }
			 else if (this.period == null && o.period == null) {
				 upComp = 0;
			 }
			 else if (this.period == null) {
				 upComp = -1;
			 }
			 else {
				 upComp = 1;
			 }
			 if (upComp == 0) {
				 if (this.containingPart != null) {
					 if (o.containingPart == null) {
						 return 1;
					 }
					 return this.containingPart.compareTo(o.containingPart);
				 }
				 else {
					 if (o.containingPart != null) {
						 return -1;
					 }
					 else {
						 return 0;
					 }
				 }
			 }
			 return upComp;
		 }
		 return partComp;
	 }
	 return colComp;
 }",0,0,1,0
"public class InvalidPackaging extends ArchetypeException{
	 public InvalidPackaging() {
	 }
	 public InvalidPackaging( String msg ) {
		 super( msg );
	 }
	 public InvalidPackaging( Throwable cause ) {
		 super( cause );
	 }
	 public InvalidPackaging( String msg, Throwable cause ) {
		 super( msg, cause );
	 }
}",0,0,0,0
"public static HttpMetadata load(String id) {
	Logger.log(""loading metadata: ""+id);
	BufferedReader br = null;
	HttpMetadata metadata = null;
	int type;
	try {
		br = new BufferedReader(new FileReader(new File(Config.getInstance().getMetadataFolder(), id)));
		String ln = br.readLine();
		if (ln == null) {
			Logger.log(""invalid metadata, file is empty"");
			return null;
		}
		int index = ln.indexOf("":"");
		if (index < 0) {
			Logger.log(""invalid metadata file starting with: "" + ln);
			return null;
		}
		String key = ln.substring(0, index).trim().toLowerCase();
		String val = ln.substring(index + 1).trim();
		if (key.equals(""type"")) {
			type = Integer.parseInt(val);
			if (type == XDMConstants.HTTP) {
				metadata = new HttpMetadata(id);
			}
			 else if (type == XDMConstants.HLS) {
				metadata = new HlsMetadata(id);
			}
			 else if (type == XDMConstants.HDS) {
				metadata = new HdsMetadata(id);
			}
			 else if (type == XDMConstants.DASH) {
				metadata = new DashMetadata(id);
			}
		}
		 else {
			Logger.log(""invalid metadata file starting with: "" + ln);
			return null;
		}
		while (true) {
			ln = br.readLine();
			if (ln == null)break;
			index = ln.indexOf("":"");
			if (index < 0)continue;
			key = ln.substring(0, index).trim().toLowerCase();
			val = ln.substring(index + 1).trim();
			if (key.equals(""url"")) {
				metadata.setUrl(val);
			}
			if (key.equals(""size"")) {
				metadata.setSize(Long.parseLong(val));
			}
			if (key.equals(""header"")) {
				int index2 = val.indexOf("":"");
				if (index2 < 0) {
					continue;
				}
				String key1 = val.substring(0, index2).trim();
				String val1 = val.substring(index2 + 1).trim();
				metadata.headers.addHeader(key1, val1);
			}
			if (key.equals(""header2"")) {
				int index2 = val.indexOf("":"");
				if (index2 < 0) {
					continue;
				}
				String key1 = val.substring(0, index2).trim();
				String val1 = val.substring(index2 + 1).trim();
				((DashMetadata) metadata).getHeaders2().addHeader(key1, val1);
			}
			if (key.equals(""url2"")) {
				((DashMetadata) metadata).setUrl2(val);
			}
			if (key.equals(""len1"")) {
				((DashMetadata) metadata).setLen1(Long.parseLong(val));
			}
			if (key.equals(""len2"")) {
				((DashMetadata) metadata).setLen2(Long.parseLong(val));
			}
			if (key.equals(""bitrate"")) {
				((HdsMetadata) metadata).setBitRate(Integer.parseInt(val));
			}
			if (key.equals(""ydlurl"")) {
				Logger.log(""ydurl: ""+val);
				metadata.ydlUrl = val;
			}
		}
		br.close();
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	 finally {
		if (br != null) {
			try {
				br.close();
			}
			 catch (Exception ex) {
			}
		}
	}
	return metadata;
}",0,0,1,0
"public abstract class BaseObject {
	public String type;
	public BaseObject() {
		type = this.getClass().getCanonicalName();
	}
	public BaseObject(String type) {
		this.type = type;
	}
	public String getType() {
		return type;
	}
}",0,1,0,0
"public final class IntermediateModel {
	 private final Metadata metadata;
	 private final Map<String, OperationModel> operations;
	 private final Map<String, ShapeModel> shapes;
	 private final CustomizationConfig customizationConfig;
	 private final ServiceExamples examples;
	 private final Map<String, AuthorizerModel> customAuthorizers;
	 private final Optional<OperationModel> endpointOperation;
	 private final Map<String, PaginatorDefinition> paginators;
	 private final NamingStrategy namingStrategy;
	 public IntermediateModel( Metadata metadata, Map<String, OperationModel> operations, Map<String, ShapeModel> shapes, CustomizationConfig customizationConfig, ServiceExamples examples) {
		 this(metadata, operations, shapes, customizationConfig, examples, null, Collections.emptyMap(), Collections.emptyMap(), null);
	 }
	 public IntermediateModel( Metadata metadata, Map<String, OperationModel> operations, Map<String, ShapeModel> shapes, CustomizationConfig customizationConfig, ServiceExamples examples, OperationModel endpointOperation, Map<String, AuthorizerModel> customAuthorizers, Map<String, PaginatorDefinition> paginators, NamingStrategy namingStrategy) {
		 this.metadata = metadata;
		 this.operations = operations;
		 this.shapes = shapes;
		 this.customizationConfig = customizationConfig;
		 this.examples = examples;
		 this.endpointOperation = Optional.ofNullable(endpointOperation);
		 this.customAuthorizers = customAuthorizers;
		 this.paginators = paginators;
		 this.namingStrategy = namingStrategy;
	 }
	 public Metadata getMetadata() {
		 return metadata;
	 }
	 public Map<String, OperationModel> getOperations() {
		 return operations;
	 }
	 public OperationModel getOperation(String operationName) {
		 return getOperations().get(operationName);
	 }
	 public Map<String, ShapeModel> getShapes() {
		 return shapes;
	 }
	 public ShapeModel getShapeByC2jName(String c2jName) {
		 return Utils.findShapeModelByC2jName(this, c2jName);
	 }
	 public CustomizationConfig getCustomizationConfig() {
		 return customizationConfig;
	 }
	 public ServiceExamples getExamples() {
		 return examples;
	 }
	 public Map<String, PaginatorDefinition> getPaginators() {
		 return paginators;
	 }
	 public NamingStrategy getNamingStrategy() {
		 return namingStrategy;
	 }
	 public String getCustomRetryPolicy() {
		 return customizationConfig.getCustomRetryPolicy();
	 }
	 public String getSdkModeledExceptionBaseFqcn() {
		 return String.format(""%s.%s"", metadata.getFullModelPackageName(), getSdkModeledExceptionBaseClassName());
	 }
	 public String getSdkModeledExceptionBaseClassName() {
		 if (customizationConfig.getSdkModeledExceptionBaseClassName() != null) {
			 return customizationConfig.getSdkModeledExceptionBaseClassName();
		 }
		 else {
			 return metadata.getBaseExceptionName();
		 }
	 }
	 public String getSdkRequestBaseClassName() {
		 if (customizationConfig.getSdkRequestBaseClassName() != null) {
			 return customizationConfig.getSdkRequestBaseClassName();
		 }
		 else {
			 return metadata.getBaseRequestName();
		 }
	 }
	 public String getSdkResponseBaseClassName() {
		 if (customizationConfig.getSdkResponseBaseClassName() != null) {
			 return customizationConfig.getSdkResponseBaseClassName();
		 }
		 else {
			 return metadata.getBaseResponseName();
		 }
	 }
	 public String getFileHeader() throws IOException {
		 return loadDefaultFileHeader();
	 }
	 private String loadDefaultFileHeader() throws IOException {
		 try (InputStream inputStream = getClass() .getResourceAsStream(""/software/amazon/awssdk/codegen/DefaultFileHeader.txt"")) {
			 return IoUtils.toUtf8String(inputStream) .replaceFirst(""%COPYRIGHT_DATE_RANGE%"", getCopyrightDateRange());
		 }
	 }
	 private String getCopyrightDateRange() {
		 int currentYear = ZonedDateTime.now().getYear();
		 int copyrightStartYear = currentYear - 5;
		 return String.format(""%d-%d"", copyrightStartYear, currentYear);
	 }
	 public String getSdkBaseResponseFqcn() {
		 if (metadata.getProtocol() == Protocol.API_GATEWAY) {
			 return ""software.amazon.awssdk.opensdk.BaseResult"";
		 }
		 else {
			 return String.format(""%s<%s>"", AwsResponse.class.getName(), getResponseMetadataClassName());
		 }
	 }
	 private String getResponseMetadataClassName() {
		 return AwsResponseMetadata.class.getName();
	 }
	 public List<OperationModel> simpleMethodsRequiringTesting() {
		 return getOperations().values().stream() .filter(v -> v.getInputShape().isSimpleMethod()) .collect(Collectors.toList());
	 }
	 public Map<String, AuthorizerModel> getCustomAuthorizers() {
		 return customAuthorizers;
	 }
	 public Optional<OperationModel> getEndpointOperation() {
		 return endpointOperation;
	 }
	 public boolean hasPaginators() {
		 return paginators.size() > 0;
	 }
	 public boolean containsRequestSigners() {
		 return getShapes().values().stream() .filter(ShapeModel::isRequestSignerAware) .findAny() .isPresent();
	 }
	 public boolean containsRequestEventStreams() {
		 return getOperations().values().stream() .filter(opModel -> opModel.hasEventStreamInput()) .findAny() .isPresent();
	 }
}",1,1,0,0
"public class QIF implements FileFormat {
	 static NumberFormat number = NumberFormat.getInstance(Locale.US);
	 static Calendar calendar = Calendar.getInstance(Locale.US);
	 MainFrame mainFrame;
	 AccountChooser accountChooser;
	 public QIF(MainFrame parent, AccountChooser ac) {
		 mainFrame = parent;
		 accountChooser = ac;
		 number.setMinimumFractionDigits(2);
		 number.setMaximumFractionDigits(2);
	 }
	 public FileFilter fileFilter() {
		 return new QifFileFilter();
	 }
	 public void importFile(Session session, File qifFile) {
		 try {
			 BufferedReader buffer = new BufferedReader(new FileReader(qifFile));
			 String header = buffer.readLine();
			 if (header.startsWith(""!Type:Bank"") || header.startsWith(""!Type:Cash"") || header.startsWith(""!Type:Bar"") || header.startsWith(""!Type:CCard"") || header.startsWith(""!Type:Oth A"") || header.startsWith(""!Type:Oth L"")) {
				 String info = Constants.LANGUAGE.getString(""QIF.chooseAccount"") + "" \"""" + qifFile.getName() + ""\""."";
				 int s = accountChooser.showDialog( session.getAccounts(), info, true);
				 if (s == Constants.OK) {
					 importAccount( session, accountChooser.getSelectedAccount(), buffer);
				 }
				 else if (s == Constants.NEW) {
					 String name = qifFile.getName();
					 if (name.endsWith("".qif"")) name = name.substring(0, name.length() - 4);
					 importAccount( session, getNewAccount(session, name), buffer);
				 }
			 }
			 else if (header.equals(""!Type:Invst"")) {
				 System.err.println( ""QIF: Import of investment accounts is not suported."");
			 }
			 else if (header.equals(""!Account"")) {
				 System.err.println( ""QIF: Import of account lists is not supported."");
			 }
			 else if (header.equals(""!Type:Cat"")) {
				 System.err.println( ""QIF: Import of category lists is not supported."");
			 }
			 else if (header.equals(""!Type:Class"")) {
				 System.err.println( ""QIF: Import of class lists is not supported."");
			 }
			 else if (header.equals(""!Type:Memorized"")) {
				 System.err.println( ""QIF: Import of memorized transaction lists is not supported."");
			 }
		 }
		 catch (IOException e) {
			 mainFrame.fileReadError(qifFile);
		 }
		 catch (CanceledException e) {
		}
	 }
	 private void importAccount( Session session, Account account, BufferedReader buffer) throws IOException, CanceledException {
		 session.modified();
		 String line;
		 Accounts accounts = new Accounts();
		 while (true) {
			 Entry entry = new Entry();
			 while (true) {
				 line = buffer.readLine();
				 if (line == null || line.equals(""^"")) break;
				 char firstChar = line.charAt(0);
				 switch (firstChar) {
					 case 'D' : entry.setDate(parseDate(line));
					 break;
					 case 'T' : extractAmount( entry, line, account.getCurrency().getScaleFactor());
					 break;
					 case 'C' : extractStatus(entry, line);
					 break;
					 case 'N' : entry.setCheck(line.substring(1));
					 break;
					 case 'P' : entry.setDescription(line.substring(1));
					 break;
					 case 'L' : entry = extractCategory( session, accounts, account, entry, line);
					 break;
					 case 'M' : entry.setMemo(line.substring(1));
					 break;
					 case 'S' : entry = extractSplittedCategory( session, accounts, account, entry, line);
					 break;
					 case 'E' : entry = extractSplittedDescription(entry, line);
					 break;
					 case '$' : entry = extractSplittedAmount( entry, line, account.getCurrency().getScaleFactor());
					 break;
					 default : break;
				 }
			 }
			 if (line == null) break;
			 account.addEntry(entry);
			 removeSimilarTransfer(account, entry);
		 }
		 account.setEntries(account.getEntries());
	 }
	 private SplittedEntry extractSplittedCategory( Session session, Accounts accounts, Account account, Entry entry, String line) throws CanceledException {
		 if (entry instanceof DoubleEntry) {
			 DoubleEntry de = (DoubleEntry) entry;
			 Account other = (Account) de.getCategory();
			 other.getEntries().removeElement(de.getOther());
		 }
		 SplittedEntry se = entry.toSplittedEntry();
		 se.setCategory( (Category) session.getCategories().getSplitNode().getUserObject());
		 se.addEntry( extractCategory(session, accounts, account, new Entry(), line));
		 return se;
	 }
	 private SplittedEntry extractSplittedDescription( Entry entry, String line) {
		 SplittedEntry se = toSplittedEntry(entry);
		 ((Entry) se.getEntries().lastElement()).setDescription( line.substring(1));
		 return se;
	 }
	 private SplittedEntry extractSplittedAmount( Entry entry, String line, short factor) throws CanceledException {
		 SplittedEntry se = toSplittedEntry(entry);
		 Entry e = (Entry) se.getEntries().lastElement();
		 extractAmount(e, line, factor);
		 if (e instanceof DoubleEntry) ((DoubleEntry) e).getOther().setAmount(-e.getAmount());
		 return se;
	 }
	 private SplittedEntry toSplittedEntry(Entry entry) {
		 SplittedEntry se;
		 if (entry instanceof SplittedEntry) {
			 se = (SplittedEntry) entry;
		 }
		 else {
			 se = entry.toSplittedEntry();
			 se.addEntry(new Entry());
		 }
		 return se;
	 }
	 private void extractAmount(Entry entry, String line, short factor) {
		 Number n = number.parse(line, new ParsePosition(1));
		 entry.setAmount(n == null ? 0 : Math.round(n.doubleValue() * factor));
	 }
	 private void extractStatus(Entry entry, String line) {
		 char c = line.charAt(1);
		 if (c == 'x' || c == 'X') entry.setStatus(Entry.CLEARED);
		 else if (c == '*') entry.setStatus(Entry.RECONCILING);
	 }
	 private Entry extractCategory( Session session, Accounts accounts, Account account, Entry entry, String line) throws CanceledException {
		 if (line.charAt(1) == '[') {
			 String accountName = line.substring(2, line.length() - 1);
			 Account other = accounts.getAccount(accountName, session);
			 if (account != other) {
				 DoubleEntry doubleEntry = entry.toDoubleEntry();
				 doubleEntry.setCategory(other);
				 doubleEntry.getOther().setCategory(account);
				 entry = doubleEntry;
				 other.addEntry(doubleEntry.getOther());
			 }
		 }
		 else {
			 int colon;
			 for (colon = 1;
			 colon < line.length();
			 colon++) if (line.charAt(colon) == ':') break;
			 if (colon == line.length()) {
				 String categoryName = line.substring(1);
				 entry.setCategory(getCategory(categoryName, session));
			 }
			 else {
				 String categoryName = line.substring(1, colon);
				 String subcategoryName = line.substring(colon + 1);
				 SimpleCategory category = getCategory(categoryName, session);
				 entry.setCategory( getSubcategory(subcategoryName, category, session));
			 }
		 }
		 return entry;
	 }
	 public void exportAccount(Session session, Account account, File file) {
		 try {
			 BufferedWriter writer = new BufferedWriter(new FileWriter(file));
			 Vector entries = account.getEntries();
			 writeln(writer, ""!Type:Bank"");
			 if (entries.size() > 0) {
				 Entry entry = (Entry) entries.elementAt(0);
				 String dateString = formatDate(entry.getDate());
				 if (dateString != null) writeln(writer, dateString);
			 }
			 writeln( writer, ""T"" + formatAmount(account.getStartBalance(), account));
			 writeln(writer, ""CX"");
			 writeln(writer, ""POpening Balance"");
			 writeln(writer, ""L["" + account.getName() + ""]"");
			 writeln(writer, ""^"");
			 for (int i = 0;
			 i < entries.size();
			 i++) {
				 Entry entry = (Entry) entries.elementAt(i);
				 String dateString = formatDate(entry.getDate());
				 if (dateString != null) writeln(writer, dateString);
				 if (entry.getMemo() != null) writeln(writer, ""M"" + entry.getMemo());
				 if (entry.getStatus() == Entry.RECONCILING) writeln(writer, ""C*"");
				 else if (entry.getStatus() == Entry.CLEARED) writeln(writer, ""CX"");
				 writeln(writer, ""T"" + formatAmount(entry.getAmount(), account));
				 if (entry.getCheck() != null) writeln(writer, ""N"" + entry.getCheck());
				 if (entry.getDescription() != null) writeln(writer, ""P"" + entry.getDescription());
				 Category category = entry.getCategory();
				 if (category != null) {
					 if (category instanceof Account) writeln( writer, ""L["" + category.getCategoryName() + ""]"");
					 else {
						 writeln(writer, ""L"" + category.getFullCategoryName());
					 }
				 }
				 writeln(writer, ""^"");
			 }
			 writer.close();
		 }
		 catch (IOException e) {
			 mainFrame.fileWriteError(file);
		 }
	 }
	 private String formatAmount(long amount, Account account) {
		 return number.format( ((double) amount) / account.getCurrency().getScaleFactor());
	 }
	 private Date parseDate(String line) {
		 try {
			 StringTokenizer st = new StringTokenizer(line, ""D/\'"");
			 int month = Integer.parseInt(st.nextToken().trim());
			 int day = Integer.parseInt(st.nextToken().trim());
			 int year = Integer.parseInt(st.nextToken().trim());
			 if (year < 100) {
				 if (line.indexOf(""'"") < 0) year = year + 1900;
				 else year = year + 2000;
			 }
			 calendar.clear();
			 calendar.set(year, month - 1, day);
			 return calendar.getTime();
		 }
		 catch (Exception e) {
			 e.printStackTrace();
		 }
		 return null;
	 }
	 private String formatDate(Date date) {
		 if (date == null) return null;
		 calendar.setTime(date);
		 int month = calendar.get(Calendar.MONTH) + 1;
		 int day = calendar.get(Calendar.DAY_OF_MONTH);
		 int year = calendar.get(Calendar.YEAR);
		 if ((year >= 1900) && (year < 2000)) return ""D"" + month + ""/"" + day + ""/"" + (year - 1900);
		 if ((year >= 2000) && (year < 2010)) return ""D"" + month + ""/"" + day + ""\'0"" + (year - 2000);
		 else if ((year >= 2010) && (year < 2100)) return ""D"" + month + ""/"" + day + ""\'"" + (year - 2000);
		 else return null;
	 }
	 private Account getNewAccount(Session session, String accountName) {
		 Account account = session.getNewAccount(accountName);
		 return account;
	 }
	 private SimpleCategory getCategory(String categoryName, Session session) {
		 SimpleCategory category = searchCategory(categoryName, session.getCategories().getRootNode());
		 if (category == null) {
			 category = new SimpleCategory(categoryName);
			 session.getCategories().insertNodeInto( category.getCategoryNode(), session.getCategories().getRootNode(), 0);
		 }
		 return category;
	 }
	 private SimpleCategory getSubcategory( String name, SimpleCategory category, Session session) {
		 SimpleCategory subcategory = searchCategory(name, category.getCategoryNode());
		 if (subcategory == null) {
			 subcategory = new SimpleCategory(name);
			 session.getCategories().insertNodeInto( subcategory.getCategoryNode(), category.getCategoryNode(), 0);
		 }
		 return subcategory;
	 }
	 private void removeSimilarTransfer(Account a1, Entry newEntry) {
		 if (newEntry instanceof SplittedEntry) {
			 SplittedEntry se = (SplittedEntry) newEntry;
			 for (int i = 0;
			 i < se.getEntries().size();
			 i++) {
				 Entry subEntry = (Entry) se.getEntries().elementAt(i);
				 if (subEntry instanceof DoubleEntry) {
					 DoubleEntry newDe1 = (DoubleEntry) subEntry;
					 DoubleEntry newDe2 = newDe1.getOther();
					 Account a2 = (Account) newDe1.getCategory();
					 for (int j = 0;
					 j < a2.getEntries().size();
					 j++) {
						 Entry oldE2 = (Entry) a2.getEntries().elementAt(j);
						 if ((newDe2 != oldE2) && (oldE2 instanceof DoubleEntry) && (newDe2.getAmount() == oldE2.getAmount()) && equals(newDe2.getDate(), oldE2.getDate()) && equals( newDe2.getCategory(), oldE2.getCategory())) {
							 DoubleEntry oldDe2 = (DoubleEntry) oldE2;
							 a1.getEntries().removeElement(oldDe2.getOther());
							 a2.getEntries().removeElement(oldDe2);
						 }
					 }
				 }
			 }
		 }
		 else if (newEntry instanceof DoubleEntry) {
			 DoubleEntry newDe = (DoubleEntry) newEntry;
			 for (int i = 0;
			 i < a1.getEntries().size();
			 i++) {
				 Entry e = (Entry) a1.getEntries().elementAt(i);
				 if ((newDe != e) && (e instanceof DoubleEntry) && equals(newDe.getCategory(), e.getCategory()) && (newDe.getAmount() == e.getAmount()) && equals(newDe.getDate(), e.getDate()) && equals(newDe.getCheck(), e.getCheck()) && equals(newDe.getDescription(), e.getDescription()) && equals(newDe.getMemo(), e.getMemo())) newDe.remove();
			 }
		 }
	 }
	 private boolean equals(Object obj1, Object obj2) {
		 if (obj1 == null && obj2 == null) return true;
		 if (obj1 == null || obj2 == null) return false;
		 return obj1.equals(obj2);
	 }
	 private SimpleCategory searchCategory(String name, CategoryNode root) {
		 for (Enumeration e = root.children();
		 e.hasMoreElements();
		) {
			 CategoryNode node = (CategoryNode) e.nextElement();
			 Object obj = node.getUserObject();
			 if (obj instanceof SimpleCategory) {
				 SimpleCategory category = (SimpleCategory) obj;
				 if (category.getCategoryName().equals(name)) return category;
			 }
		 }
		 return null;
	 }
	 private void writeln(BufferedWriter writer, String line) throws IOException {
		 writer.write(line);
		 writer.newLine();
	 }
	 class Accounts {
		 Vector names = new Vector(10);
		 Vector accounts = new Vector(10);
		 Account getAccount(String accountName, Session session) throws CanceledException {
			 Account account;
			 int index;
			 for (index = 0;
			 index < names.size();
			 index++) {
				 String name = (String) names.get(index);
				 if (name.equals(accountName)) break;
			 }
			 if (index == names.size()) {
				 String info = Constants.LANGUAGE.getString(""QIF.chooseTransferAccount"") + "" \"""" + accountName + ""\""."";
				 int status = accountChooser.showDialog( session.getAccounts(), info, true);
				 if (status == Constants.OK) account = accountChooser.getSelectedAccount();
				 else if (status == Constants.NEW) account = getNewAccount(session, accountName);
				 else throw new CanceledException(""QIF import canceled."");
				 names.add(accountName);
				 accounts.add(account);
			 }
			 else {
				 account = (Account) accounts.get(index);
			 }
			 return account;
		 }
	 }
	 public class CanceledException extends Exception {
		 public CanceledException() {
			 super();
		 }
		 public CanceledException(String s) {
			 super(s);
		 }
	 }
	 public static class QifFileFilter extends FileFilter {
		 public boolean accept(File f) {
			 if (f == null) return false;
			 if (f.isDirectory()) return true;
			 return f.getName().toLowerCase().endsWith("".qif"");
		 }
		 public String getDescription() {
			 return ""Quicken Interchange Format (*.qif)"";
		 }
	 }
}",1,0,0,0
"public class AnnotationViewerMain extends JFrame {
	 private static final long serialVersionUID = -3201723535833938833L;
	 private static final String HELP_MESSAGE = ""Instructions for using Annotation Viewer:\n\n"" + ""1) In the \""Input Directory\"" field, either type or use the browse\n"" + ""button to select a directory containing the analyzed documents\n "" + ""(in XMI or XCAS format) that you want to view.\n\n"" + ""2) In the \""TypeSystem or AE Descriptor File\"" field, either type or use the browse\n"" + ""button to select the TypeSystem or AE descriptor for the AE that generated the\n"" + ""XMI or XCAS files. (This is needed for type system infornation only.\n"" + ""Analysis will not be redone.)\n\n"" + ""3) Click the \""View\"" button at the buttom of the window.\n\n"" + ""A list of the analyzed documents will be displayed.\n\n\n"" + ""4) Select the view type -- either the Java annotation viewer, HTML,\n"" + ""or XML. The Java annotation viewer is recommended.\n\n"" + ""5) Double-click on a document to view it.\n"";
	 private File uimaHomeDir;
	 private FileSelector inputFileSelector;
	 private FileSelector taeDescriptorFileSelector;
	 private JButton viewButton;
	 private JDialog aboutDialog;
	 private Preferences prefs = Preferences.userRoot().node(""org/apache/uima/tools/AnnotationViewer"");
	 public AnnotationViewerMain() {
		 super(""Annotation Viewer"");
		 uimaHomeDir = new File(System.getProperty(""uima.home"", ""C:/Program Files/apache-uima""));
		 try {
			 UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
		 }
		 catch (Exception e) {
			 System.err.println(""Could not set look and feel: "" + e.getMessage());
		 }
		 try {
			 this.setIconImage(Images.getImage(Images.MICROSCOPE));
		 }
		 catch (IOException e) {
			 System.err.println(""Image could not be loaded: "" + e.getMessage());
		 }
		 this.getContentPane().setBackground(Color.WHITE);
		 aboutDialog = new AboutDialog(this, ""About Annotation Viewer"");
		 JMenuBar menuBar = new JMenuBar();
		 setJMenuBar(menuBar);
		 JMenu fileMenu = new JMenu(""File"");
		 JMenu helpMenu = new JMenu(""Help"");
		 JMenuItem aboutMenuItem = new JMenuItem(""About"");
		 JMenuItem helpMenuItem = new JMenuItem(""Help"");
		 JMenuItem exitMenuItem = new JMenuItem(""Exit"");
		 fileMenu.add(exitMenuItem);
		 helpMenu.add(aboutMenuItem);
		 helpMenu.add(helpMenuItem);
		 menuBar.add(fileMenu);
		 menuBar.add(helpMenu);
		 final Caption labelInputDir = new Caption(""Input Directory: "");
		 final Caption labelStyleMapFile = new Caption(""TypeSystem or AE Descriptor File: "");
		 JPanel controlPanel = new JPanel();
		 controlPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));
		 controlPanel.setLayout(new SpringLayout());
		 File inputDir = new File(uimaHomeDir, ""examples/data/processed"");
		 inputFileSelector = new FileSelector("""", ""Input Directory"", JFileChooser.DIRECTORIES_ONLY, inputDir);
		 inputFileSelector.setSelected(inputDir.getAbsolutePath());
		 taeDescriptorFileSelector = new FileSelector("""", ""TAE Descriptor File"", JFileChooser.FILES_ONLY, uimaHomeDir);
		 File descriptorFile = new File(uimaHomeDir, ""examples/descriptors/analysis_engine/PersonTitleAnnotator.xml"");
		 taeDescriptorFileSelector.setSelected(descriptorFile.getAbsolutePath());
		 controlPanel.add(labelInputDir);
		 controlPanel.add(inputFileSelector);
		 controlPanel.add(labelStyleMapFile);
		 controlPanel.add(taeDescriptorFileSelector);
		 SpringUtilities.makeCompactGrid(controlPanel, 2, 2, 4, 4, 4, 4);
		 exitMenuItem.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent ae) {
				 savePreferences();
				 System.exit(0);
			 }
		 }
		);
		 aboutMenuItem.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent ae) {
				 aboutDialog.setVisible(true);
			 }
		 }
		);
		 helpMenuItem.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent ae) {
				 JOptionPane.showMessageDialog(AnnotationViewerMain.this, HELP_MESSAGE, ""Annotation Viewer Help"", JOptionPane.PLAIN_MESSAGE);
			 }
		 }
		);
		 Container contentPanel = getContentPane();
		 contentPanel.add(controlPanel, BorderLayout.CENTER);
		 JLabel banner = new JLabel(Images.getImageIcon(Images.BANNER));
		 contentPanel.add(banner, BorderLayout.NORTH);
		 viewButton = new JButton(""View"");
		 JPanel lowerButtonsPanel = new JPanel();
		 lowerButtonsPanel.add(viewButton);
		 contentPanel.add(lowerButtonsPanel, BorderLayout.SOUTH);
		 setContentPane(contentPanel);
		 viewButton.addActionListener(new ActionListener() {
			 public void actionPerformed(ActionEvent ee) {
				 try {
					 viewDocuments();
				 }
				 catch (Exception e) {
					 displayError(e);
				 }
			 }
		 }
		);
		 if (System.getProperty(""uima.noprefs"") == null) {
			 restorePreferences();
		 }
	 }
	 public void viewDocuments() throws InvalidXMLException, IOException, ResourceInitializationException {
		 File descriptorFile = new File(taeDescriptorFileSelector.getSelected());
		 if (!descriptorFile.exists() || descriptorFile.isDirectory()) {
			 displayError(""Descriptor File \"""" + descriptorFile.getPath() + ""\"" does not exist."");
			 return;
		 }
		 File inputDir = new File(inputFileSelector.getSelected());
		 if (!inputDir.exists() || !inputDir.isDirectory()) {
			 displayError(""Input Directory \"""" + inputDir.getPath() + ""\"" does not exist."");
			 return;
		 }
		 Object descriptor = UIMAFramework.getXMLParser().parse(new XMLInputSource(descriptorFile));
		 CAS cas;
		 File styleMapFile;
		 if (descriptor instanceof AnalysisEngineDescription) {
			 cas = CasCreationUtils.createCas((AnalysisEngineDescription) descriptor);
			 styleMapFile = getStyleMapFile((AnalysisEngineDescription) descriptor, descriptorFile .getPath());
		 }
		 else if (descriptor instanceof TypeSystemDescription) {
			 TypeSystemDescription tsDesc = (TypeSystemDescription) descriptor;
			 tsDesc.resolveImports();
			 cas = CasCreationUtils.createCas(tsDesc, null, new FsIndexDescription[0]);
			 styleMapFile = getStyleMapFile((TypeSystemDescription) descriptor, descriptorFile.getPath());
		 }
		 else {
			 displayError(""Invalid Descriptor File \"""" + descriptorFile.getPath() + ""\"""" + ""Must be either an AnalysisEngine or TypeSystem descriptor."");
			 return;
		 }
		 PrefsMediator prefsMed = new PrefsMediator();
		 prefsMed.setOutputDir(inputDir.toString());
		 AnnotationViewerDialog viewerDialog = new AnnotationViewerDialog(this, ""Analyzed Documents"", prefsMed, styleMapFile, null, cas.getTypeSystem(), null, false, cas);
		 viewerDialog.pack();
		 viewerDialog.setModal(true);
		 viewerDialog.setVisible(true);
	 }
	 private File getStyleMapFile(AnalysisEngineDescription tad, String descFileName) throws IOException {
		 File styleMapFile = getStyleMapFileName(descFileName);
		 if (!styleMapFile.exists()) {
			 String xml = AnnotationViewGenerator.autoGenerateStyleMap(tad.getAnalysisEngineMetaData());
			 PrintWriter writer;
			 writer = new PrintWriter(new BufferedWriter(new FileWriter(styleMapFile)));
			 writer.println(xml);
			 writer.close();
		 }
		 return styleMapFile;
	 }
	 private File getStyleMapFile(TypeSystemDescription tsd, String descFileName) throws IOException {
		 File styleMapFile = getStyleMapFileName(descFileName);
		 if (!styleMapFile.exists()) {
			 String xml = AnnotationViewGenerator.autoGenerateStyleMap(tsd);
			 PrintWriter writer;
			 writer = new PrintWriter(new BufferedWriter(new FileWriter(styleMapFile)));
			 writer.println(xml);
			 writer.close();
		 }
		 return styleMapFile;
	 }
	 public File getStyleMapFileName(String aDescriptorFileName) {
		 String baseName;
		 int index = aDescriptorFileName.lastIndexOf(""."");
		 if (index > 0) {
			 baseName = aDescriptorFileName.substring(0, index);
		 }
		 else {
			 baseName = aDescriptorFileName;
		 }
		 return new File(baseName + ""StyleMap.xml"");
	 }
	 public static void main(String[] args) {
		 final AnnotationViewerMain frame = new AnnotationViewerMain();
		 frame.addWindowListener(new WindowAdapter() {
			 public void windowClosing(WindowEvent e) {
				 frame.savePreferences();
				 System.exit(0);
			 }
		 }
		);
		 frame.pack();
		 frame.setVisible(true);
	 }
	 public void savePreferences() {
		 prefs.put(""inDir"", inputFileSelector.getSelected());
		 prefs.put(""taeDescriptorFile"", taeDescriptorFileSelector.getSelected());
	 }
	 public void restorePreferences() {
		 File defaultInputDir = new File(uimaHomeDir, ""examples/data/processed"");
		 File defaultTaeDescriptorFile = new File(uimaHomeDir, ""examples/descriptors/analysis_engine/PersonTitleAnnotator.xml"");
		 inputFileSelector.setSelected(prefs.get(""inDir"", defaultInputDir.toString()));
		 taeDescriptorFileSelector.setSelected(prefs.get(""taeDescriptorFile"", defaultTaeDescriptorFile .toString()));
	 }
	 public void displayError(String aErrorString) {
		 StringBuffer buf = new StringBuffer(aErrorString.length());
		 final int CHARS_PER_LINE = 80;
		 int charCount = 0;
		 StringTokenizer tokenizer = new StringTokenizer(aErrorString, "" \n"", true);
		 while (tokenizer.hasMoreTokens()) {
			 String tok = tokenizer.nextToken();
			 if (tok.equals(""\n"")) {
				 buf.append(""\n"");
				 charCount = 0;
			 }
			 else if ((charCount > 0) && ((charCount + tok.length()) > CHARS_PER_LINE)) {
				 buf.append(""\n"").append(tok);
				 charCount = tok.length();
			 }
			 else {
				 buf.append(tok);
				 charCount += tok.length();
			 }
		 }
		 JOptionPane.showMessageDialog(AnnotationViewerMain.this, buf.toString(), ""Error"", JOptionPane.ERROR_MESSAGE);
	 }
	 public void displayError(Throwable aThrowable) {
		 aThrowable.printStackTrace();
		 String message = aThrowable.toString();
		 while ((aThrowable instanceof UIMAException) || (aThrowable instanceof UIMARuntimeException)) {
			 if (aThrowable instanceof UIMAException) {
				 aThrowable = ((UIMAException) aThrowable).getCause();
			 }
			 else if (aThrowable instanceof UIMARuntimeException) {
				 aThrowable = ((UIMARuntimeException) aThrowable).getCause();
			 }
			 if (aThrowable != null) {
				 message += (""\nCausedBy: "" + aThrowable.toString());
			 }
		 }
		 displayError(message);
	 }
	 public Dimension getPreferredSize() {
		 return new Dimension(640, 200);
	 }
 }",1,0,0,0
"public class URLPARSE extends EvalFunc<Map<String, Object> > {
	 public Map<String, Object> exec(Tuple input) throws IOException {
		 if (input == null || input.size() == 0) return null;
		 String url;
		 try{
			 url = (String)input.get(0);
		 }
		 catch(Exception e){
			 System.out.println(""Can't convert field to a string;
			 error = "" + e.getMessage());
			 return null;
		 }
		 HashMap<String, Object> output = new HashMap<String, Object>();
		 if(url == null) {
			 return null;
		 }
		 String[] s = url.split("","");
		 output.put(""url"", s[0]);
		 output.put(""name"", s[1]);
		 return output;
	 }
	 public Schema outputSchema(Schema input) {
		 return new Schema(new Schema.FieldSchema(getSchemaName(""urlparse"", input), DataType.MAP));
	 }
}",1,0,0,0
"private class DiscoveryListener implements GridLocalEventListener, HighPriorityListener {
	 public void onEvent(Event evt) {
		 assert evt instanceof DiscoveryEvent;
		 assert evt.type() == EVT_NODE_LEFT || evt.type() == EVT_NODE_FAILED;
		 UUID nodeId = ((DiscoveryEvent)evt).eventNode().id();
		 if (discoProtoVer == 2) {
			 routinesInfo.onNodeFail(nodeId);
			 for (StartFuture fut : startFuts.values()) fut.onNodeFail(nodeId);
		 }
		 clientInfos.remove(nodeId);
		 for (Map.Entry<UUID, RemoteRoutineInfo> e : rmtInfos.entrySet()) {
			 UUID routineId = e.getKey();
			 RemoteRoutineInfo info = e.getValue();
			 if (nodeId.equals(info.nodeId)) {
				 if (info.autoUnsubscribe) unregisterRemote(routineId);
				 if (info.hnd.isQuery()) info.hnd.onNodeLeft();
			 }
		 }
		 for (Map.Entry<IgniteUuid, SyncMessageAckFuture> e : syncMsgFuts.entrySet()) {
			 SyncMessageAckFuture fut = e.getValue();
			 if (fut.nodeId().equals(nodeId)) {
				 SyncMessageAckFuture fut0 = syncMsgFuts.remove(e.getKey());
				 if (fut0 != null) {
					 ClusterTopologyCheckedException err = new ClusterTopologyCheckedException( ""Node left grid while sending message to: "" + nodeId);
					 fut0.onDone(err);
				 }
			 }
		 }
	 }
	 public int order() {
		 return 1;
	 }
 }",0,0,0,0
"public class PlanModifierUtil {
	 private static final Logger LOG = LoggerFactory.getLogger(PlanModifierUtil.class);
	 protected static void fixTopOBSchema(final RelNode rootRel, Pair<RelNode, RelNode> topSelparentPair, List<FieldSchema> resultSchema, boolean replaceProject) throws CalciteSemanticException {
		 if (!(topSelparentPair.getKey() instanceof Sort) || !HiveCalciteUtil.orderRelNode(topSelparentPair.getKey())) {
			 return;
		 }
		 HiveSortLimit obRel = (HiveSortLimit) topSelparentPair.getKey();
		 Project obChild = (Project) topSelparentPair.getValue();
		 if (obChild.getRowType().getFieldCount() <= resultSchema.size()) {
			 return;
		 }
		 RelDataType rt = obChild.getRowType();
		 Set<Integer> collationInputRefs = new HashSet( RelCollations.ordinals(obRel.getCollation()));
		 ImmutableMap.Builder<Integer, RexNode> inputRefToCallMapBldr = ImmutableMap.builder();
		 for (int i = resultSchema.size();
		 i < rt.getFieldCount();
		 i++) {
			 if (collationInputRefs.contains(i)) {
				 RexNode obyExpr = obChild.getChildExps().get(i);
				 if (obyExpr instanceof RexCall) {
					 LOG.debug(""Old RexCall : "" + obyExpr);
					 obyExpr = adjustOBSchema((RexCall) obyExpr, obChild, resultSchema);
					 LOG.debug(""New RexCall : "" + obyExpr);
				 }
				 inputRefToCallMapBldr.put(i, obyExpr);
			 }
		 }
		 ImmutableMap<Integer, RexNode> inputRefToCallMap = inputRefToCallMapBldr.build();
		 if ((obChild.getRowType().getFieldCount() - inputRefToCallMap.size()) != resultSchema.size()) {
			 LOG.error(generateInvalidSchemaMessage(obChild, resultSchema, inputRefToCallMap.size()));
			 throw new CalciteSemanticException(""Result Schema didn't match Optimized Op Tree Schema"");
		 }
		 if (replaceProject) {
			 HiveProject replacementProjectRel = HiveProject.create(obChild.getInput(), obChild .getChildExps().subList(0, resultSchema.size()), obChild.getRowType().getFieldNames() .subList(0, resultSchema.size()));
			 obRel.replaceInput(0, replacementProjectRel);
		 }
		 obRel.setInputRefToCallMap(inputRefToCallMap);
	 }
	 private static RexCall adjustOBSchema(RexCall obyExpr, Project obChild, List<FieldSchema> resultSchema) {
		 int a = -1;
		 List<RexNode> operands = new ArrayList<>();
		 for (int k = 0;
		 k < obyExpr.operands.size();
		 k++) {
			 RexNode rn = obyExpr.operands.get(k);
			 for (int j = 0;
			 j < resultSchema.size();
			 j++) {
				 if( obChild.getChildExps().get(j).toString().equals(rn.toString())) {
					 a = j;
					 break;
				 }
			 }
			 if (a != -1) {
				 operands.add(new RexInputRef(a, rn.getType()));
			 }
			 else {
				 if (rn instanceof RexCall) {
					 operands.add(adjustOBSchema((RexCall)rn, obChild, resultSchema));
				 }
				 else {
					 operands.add(rn);
				 }
			 }
			 a = -1;
		 }
		 return (RexCall) obChild.getCluster().getRexBuilder().makeCall( obyExpr.getType(), obyExpr.getOperator(), operands);
	 }
	 protected static String generateInvalidSchemaMessage(Project topLevelProj, List<FieldSchema> resultSchema, int fieldsForOB) {
		 String errorDesc = ""Result Schema didn't match Calcite Optimized Op Tree;
		 schema: "";
		 for (FieldSchema fs : resultSchema) {
			 errorDesc += ""["" + fs.getName() + "":"" + fs.getType() + ""], "";
		 }
		 errorDesc += "" projection fields: "";
		 for (RexNode exp : topLevelProj.getChildExps()) {
			 errorDesc += ""["" + exp.toString() + "":"" + exp.getType() + ""], "";
		 }
		 if (fieldsForOB != 0) {
			 errorDesc += fieldsForOB + "" fields removed due to ORDER BY "";
		 }
		 return errorDesc.substring(0, errorDesc.length() - 2);
	 }
}",1,0,0,0
"public class CCMkdir extends ClearCase {
	 private String mComment = null;
	 private String mCfile = null;
	 private boolean mNoco = false;
	 public void execute() throws BuildException {
		 Commandline commandLine = new Commandline();
		 Project aProj = getProject();
		 int result = 0;
		 if (getViewPath() == null) {
			 setViewPath(aProj.getBaseDir().getPath());
		 }
		 commandLine.setExecutable(getClearToolCommand());
		 commandLine.createArgument().setValue(COMMAND_MKDIR);
		 checkOptions(commandLine);
		 if (!getFailOnErr()) {
			 getProject().log(""Ignoring any errors that occur for: "" + getViewPathBasename(), Project.MSG_VERBOSE);
		 }
		 result = run(commandLine);
		 if (Execute.isFailure(result) && getFailOnErr()) {
			 String msg = ""Failed executing: "" + commandLine.toString();
			 throw new BuildException(msg, getLocation());
		 }
	 }
	 private void checkOptions(Commandline cmd) {
		 if (getComment() != null) {
			 getCommentCommand(cmd);
		 }
		 else {
			 if (getCommentFile() != null) {
				 getCommentFileCommand(cmd);
			 }
			 else {
				 cmd.createArgument().setValue(FLAG_NOCOMMENT);
			 }
		 }
		 if (getNoCheckout()) {
			 cmd.createArgument().setValue(FLAG_NOCHECKOUT);
		 }
		 cmd.createArgument().setValue(getViewPath());
	 }
	 public void setComment(String comment) {
		 mComment = comment;
	 }
	 public String getComment() {
		 return mComment;
	 }
	 public void setCommentFile(String cfile) {
		 mCfile = cfile;
	 }
	 public String getCommentFile() {
		 return mCfile;
	 }
	 public void setNoCheckout(boolean co) {
		 mNoco = co;
	 }
	 public boolean getNoCheckout() {
		 return mNoco;
	 }
	 private void getCommentCommand(Commandline cmd) {
		 if (getComment() != null) {
			 cmd.createArgument().setValue(FLAG_COMMENT);
			 cmd.createArgument().setValue(getComment());
		 }
	 }
	 private void getCommentFileCommand(Commandline cmd) {
		 if (getCommentFile() != null) {
			 cmd.createArgument().setValue(FLAG_COMMENTFILE);
			 cmd.createArgument().setValue(getCommentFile());
		 }
	 }
	 public static final String FLAG_COMMENT = ""-c"";
	 public static final String FLAG_COMMENTFILE = ""-cfile"";
	 public static final String FLAG_NOCOMMENT = ""-nc"";
	 public static final String FLAG_NOCHECKOUT = ""-nco"";
}",0,0,0,0
"public void log(int level, Object obj1, Object obj2, Object obj3, Object obj4, Object obj5, Object obj6, Object obj7, final Throwable exception);",0,0,0,1
"public Token getNextToken() {
	 int kind;
	 Token specialToken = null;
	 Token matchedToken;
	 int curPos = 0;
	 EOFLoop : for (;
	;
	) {
		 try {
			 curChar = input_stream.BeginToken();
		 }
		 catch(java.io.IOException e) {
			 jjmatchedKind = 0;
			 matchedToken = jjFillToken();
			 matchedToken.specialToken = specialToken;
			 return matchedToken;
		 }
		 image = null;
		 jjimageLen = 0;
		 for (;
		;
		) {
			 switch(curLexState) {
				 case 0: try {
					 input_stream.backup(0);
					 while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L) curChar = input_stream.BeginToken();
				 }
				 catch (java.io.IOException e1) {
					 continue EOFLoop;
				 }
				 jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_0();
				 break;
				 case 1: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_1();
				 if (jjmatchedPos == 0 && jjmatchedKind > 7) {
					 jjmatchedKind = 7;
				 }
				 break;
				 case 2: jjmatchedKind = 0x7fffffff;
				 jjmatchedPos = 0;
				 curPos = jjMoveStringLiteralDfa0_2();
				 if (jjmatchedPos == 0 && jjmatchedKind > 10) {
					 jjmatchedKind = 10;
				 }
				 break;
			 }
			 if (jjmatchedKind != 0x7fffffff) {
				 if (jjmatchedPos + 1 < curPos) input_stream.backup(curPos - jjmatchedPos - 1);
				 if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
					 matchedToken = jjFillToken();
					 matchedToken.specialToken = specialToken;
					 if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind];
					 return matchedToken;
				 }
				 else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
					 if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						 matchedToken = jjFillToken();
						 if (specialToken == null) specialToken = matchedToken;
						 else {
							 matchedToken.specialToken = specialToken;
							 specialToken = (specialToken.next = matchedToken);
						 }
						 SkipLexicalActions(matchedToken);
					 }
					 else SkipLexicalActions(null);
					 if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind];
					 continue EOFLoop;
				 }
				 jjimageLen += jjmatchedPos + 1;
				 if (jjnewLexState[jjmatchedKind] != -1) curLexState = jjnewLexState[jjmatchedKind];
				 curPos = 0;
				 jjmatchedKind = 0x7fffffff;
				 try {
					 curChar = input_stream.readChar();
					 continue;
				 }
				 catch (java.io.IOException e1) {
				 }
			 }
			 int error_line = input_stream.getEndLine();
			 int error_column = input_stream.getEndColumn();
			 String error_after = null;
			 boolean EOFSeen = false;
			 try {
				 input_stream.readChar();
				 input_stream.backup(1);
			 }
			 catch (java.io.IOException e1) {
				 EOFSeen = true;
				 error_after = curPos <= 1 ? """" : input_stream.GetImage();
				 if (curChar == '\n' || curChar == '\r') {
					 error_line++;
					 error_column = 0;
				 }
				 else error_column++;
			 }
			 if (!EOFSeen) {
				 input_stream.backup(1);
				 error_after = curPos <= 1 ? """" : input_stream.GetImage();
			 }
			 throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
		 }
	 }
}",0,0,1,0
"public class Description extends DataType {
	 public void addText(String text) {
		 ProjectHelper ph = ProjectHelper.getProjectHelper();
		 if (!(ph instanceof ProjectHelperImpl)) {
			 return;
		 }
		 String currentDescription = getProject().getDescription();
		 if (currentDescription == null) {
			 getProject().setDescription(text);
		 }
		 else {
			 getProject().setDescription(currentDescription + text);
		 }
	 }
	 public static String getDescription(Project project) {
		 Vector targets = (Vector) project.getReference(ProjectHelper2.REFID_TARGETS);
		 if (targets == null) {
			 return null;
		 }
		 StringBuffer description = new StringBuffer();
		 for (int i = 0;
		 i < targets.size();
		 i++) {
			 Target t = (Target) targets.elementAt(i);
			 concatDescriptions(project, t, description);
		 }
		 return description.toString();
	 }
	 private static void concatDescriptions(Project project, Target t, StringBuffer description) {
		 if (t == null) {
			 return;
		 }
		 Vector tasks = findElementInTarget(project, t, ""description"");
		 if (tasks == null) {
			 return;
		 }
		 for (int i = 0;
		 i < tasks.size();
		 i++) {
			 Task task = (Task) tasks.elementAt(i);
			 if (!(task instanceof UnknownElement)) {
				 continue;
			 }
			 UnknownElement ue = ((UnknownElement) task);
			 String descComp = ue.getWrapper().getText().toString();
			 if (descComp != null) {
				 description.append(project.replaceProperties(descComp));
			 }
		 }
	 }
	 private static Vector findElementInTarget(Project project, Target t, String name) {
		 Task[] tasks = t.getTasks();
		 Vector elems = new Vector();
		 for (int i = 0;
		 i < tasks.length;
		 i++) {
			 if (name.equals(tasks[i].getTaskName())) {
				 elems.addElement(tasks[i]);
			 }
		 }
		 return elems;
	 }
}",0,0,0,0
"public final class SwitchStmt extends LabeledStatement {
	 private static final long serialVersionUID = -7284973291082281855L;
	 public SwitchStmt( FilePosition pos, String label, List<? extends ParseTreeNode> children) {
		 super(pos, label, ParseTreeNode.class);
		 createMutation().appendChildren(children).execute();
	 }
	 public SwitchStmt( FilePosition pos, String label, Expression valueExpr, List<SwitchCase> cases) {
		 super(pos, label, ParseTreeNode.class);
		 createMutation().appendChild(valueExpr).appendChildren(cases).execute();
	 }
	 protected void childrenChanged() {
		 super.childrenChanged();
		 List<? extends ParseTreeNode> children = children();
		 ParseTreeNode valueExpr = children.get(0);
		 if (!(valueExpr instanceof Expression)) {
			 throw new ClassCastException( ""Expected "" + Expression.class.getName() + "" not "" + valueExpr.getClass().getName());
		 }
		 for (ParseTreeNode node : children.subList(1, children.size())) {
			 if (!(node instanceof SwitchCase)) {
				 throw new ClassCastException( ""Expected "" + SwitchCase.class.getName() + "" not "" + (node != null ? node.getClass().getName() : ""<null>""));
			 }
		 }
	 }
	 public void continues(Map<String, List<ContinueStmt>> contsReaching) {
		 for (ParseTreeNode child : children()) {
			 if (child instanceof Statement) {
				 ((Statement) child).continues(contsReaching);
			 }
		 }
	 }
	 public boolean isTargetForContinue() {
		 return false;
	 }
	 public void render(RenderContext rc) {
		 TokenConsumer out = rc.getOut();
		 out.mark(getFilePosition());
		 String label = getRenderedLabel();
		 if (null != label) {
			 out.consume(label);
			 out.consume("":"");
		 }
		 Iterator<? extends ParseTreeNode> it = children().iterator();
		 out.consume(""switch"");
		 out.consume(""("");
		 it.next().render(rc);
		 out.consume("")"");
		 out.consume(""{
			"");
			 while (it.hasNext()) {
				 SwitchCase caseStmt = (SwitchCase) it.next();
				 caseStmt.render(rc);
			 }
			 out.mark(FilePosition.endOfOrNull(getFilePosition()));
		 out.consume(""}
		"");
	 }
	 public boolean isTerminal() {
		 return true;
	 }
	 public boolean hasHangingConditional() {
		 return false;
	 }
}",0,0,0,0
"public class TimingEvent {
	 public static class LauncherTimings {
		 public static final String FULL_JOB_EXECUTION = ""FullJobExecutionTimer"";
		 public static final String WORK_UNITS_CREATION = ""WorkUnitsCreationTimer"";
		 public static final String WORK_UNITS_PREPARATION = ""WorkUnitsPreparationTimer"";
		 public static final String JOB_ORCHESTRATED = ""JobOrchestrated"";
		 public static final String JOB_PREPARE = ""JobPrepareTimer"";
		 public static final String JOB_START = ""JobStartTimer"";
		 public static final String JOB_RUN = ""JobRunTimer"";
		 public static final String JOB_COMMIT = ""JobCommitTimer"";
		 public static final String JOB_CLEANUP = ""JobCleanupTimer"";
		 public static final String JOB_CANCEL = ""JobCancelTimer"";
		 public static final String JOB_COMPLETE = ""JobCompleteTimer"";
		 public static final String JOB_FAILED = ""JobFailedTimer"";
		 public static final String JOB_SUCCEEDED = ""JobSucceededTimer"";
	 }
	 public static class RunJobTimings {
		 public static final String JOB_LOCAL_SETUP = ""JobLocalSetupTimer"";
		 public static final String WORK_UNITS_RUN = ""WorkUnitsRunTimer"";
		 public static final String WORK_UNITS_PREPARATION = ""WorkUnitsPreparationTimer"";
		 public static final String MR_STAGING_DATA_CLEAN = ""JobMrStagingDataCleanTimer"";
		 public static final String MR_DISTRIBUTED_CACHE_SETUP = ""JobMrDistributedCacheSetupTimer"";
		 public static final String MR_JOB_SETUP = ""JobMrSetupTimer"";
		 public static final String MR_JOB_RUN = ""JobMrRunTimer"";
		 public static final String HELIX_JOB_SUBMISSION= ""JobHelixSubmissionTimer"";
		 public static final String HELIX_JOB_RUN = ""JobHelixRunTimer"";
	 }
	 public static class FlowTimings {
		 public static final String FLOW_COMPILED = ""FlowCompiled"";
		 public static final String FLOW_COMPILE_FAILED = ""FlowCompileFailed"";
	 }
	 public static class FlowEventConstants {
		 public static final String FLOW_NAME_FIELD = ""flowName"";
		 public static final String FLOW_GROUP_FIELD = ""flowGroup"";
		 public static final String FLOW_EXECUTION_ID_FIELD = ""flowExecutionId"";
		 public static final String JOB_NAME_FIELD = ""jobName"";
		 public static final String JOB_GROUP_FIELD = ""jobGroup"";
		 public static final String JOB_EXECUTION_ID_FIELD = ""jobExecutionId"";
		 public static final String SPEC_EXECUTOR_FIELD = ""specExecutor"";
		 public static final String LOW_WATERMARK_FIELD = ""lowWatermark"";
		 public static final String HIGH_WATERMARK_FIELD = ""highWatermark"";
		 public static final String PROCESSED_COUNT_FIELD = ""processedCount"";
	 }
	 public static final String METADATA_START_TIME = ""startTime"";
	 public static final String METADATA_END_TIME = ""endTime"";
	 public static final String METADATA_DURATION = ""durationMillis"";
	 public static final String METADATA_TIMING_EVENT = ""timingEvent"";
	 public static final String METADATA_MESSAGE = ""message"";
	 private final String name;
	 private final Long startTime;
	 private final EventSubmitter submitter;
	 private boolean stopped;
	 public TimingEvent(EventSubmitter submitter, String name) {
		 this.stopped = false;
		 this.name = name;
		 this.submitter = submitter;
		 this.startTime = System.currentTimeMillis();
	 }
	 public void stop() {
		 stop(Maps.<String, String> newHashMap());
	 }
	 public void stop(Map<String, String> additionalMetadata) {
		 if (this.stopped) {
			 return;
		 }
		 this.stopped = true;
		 long endTime = System.currentTimeMillis();
		 long duration = endTime - this.startTime;
		 Map<String, String> finalMetadata = Maps.newHashMap();
		 finalMetadata.putAll(additionalMetadata);
		 finalMetadata.put(EventSubmitter.EVENT_TYPE, METADATA_TIMING_EVENT);
		 finalMetadata.put(METADATA_START_TIME, Long.toString(this.startTime));
		 finalMetadata.put(METADATA_END_TIME, Long.toString(endTime));
		 finalMetadata.put(METADATA_DURATION, Long.toString(duration));
		 this.submitter.submit(this.name, finalMetadata);
	 }
}",1,1,0,0
"public static class Context {
	 private final MapTask mapTask;
	 private final JobConf jobConf;
	 private final TaskReporter reporter;
	 public Context(MapTask mapTask, JobConf jobConf, TaskReporter reporter) {
		 this.mapTask = mapTask;
		 this.jobConf = jobConf;
		 this.reporter = reporter;
	 }
	 public MapTask getMapTask() {
		 return mapTask;
	 }
	 public JobConf getJobConf() {
		 return jobConf;
	 }
	 public TaskReporter getReporter() {
		 return reporter;
	 }
 }",0,1,0,0
"public static String chooseRepr(String src, String dst, boolean temp) {
	 URL srcUrl;
	 URL dstUrl;
	 try {
		 srcUrl = new URL(src);
		 dstUrl = new URL(dst);
	 }
	 catch (MalformedURLException e) {
		 return dst;
	 }
	 String srcDomain = URLUtil.getDomainName(srcUrl);
	 String dstDomain = URLUtil.getDomainName(dstUrl);
	 String srcHost = srcUrl.getHost();
	 String dstHost = dstUrl.getHost();
	 String srcFile = srcUrl.getFile();
	 String dstFile = dstUrl.getFile();
	 boolean srcRoot = (srcFile.equals(""/"") || srcFile.length() == 0);
	 boolean destRoot = (dstFile.equals(""/"") || dstFile.length() == 0);
	 if (!srcDomain.equals(dstDomain)) {
		 return dst;
	 }
	 if (!temp) {
		 if (srcRoot) {
			 return src;
		 }
		 else {
			 return dst;
		 }
	 }
	 else {
		 if (srcRoot && !destRoot) {
			 return src;
		 }
		 else if (!srcRoot && destRoot) {
			 return dst;
		 }
		 else if (!srcRoot && !destRoot && (srcHost.equals(dstHost))) {
			 int numSrcPaths = srcFile.split(""/"").length;
			 int numDstPaths = dstFile.split(""/"").length;
			 if (numSrcPaths != numDstPaths) {
				 return (numDstPaths < numSrcPaths ? dst : src);
			 }
			 else {
				 int srcPathLength = srcFile.length();
				 int dstPathLength = dstFile.length();
				 return (dstPathLength < srcPathLength ? dst : src);
			 }
		 }
		 else {
			 int numSrcSubs = srcHost.split(""\\."").length;
			 int numDstSubs = dstHost.split(""\\."").length;
			 return (numDstSubs < numSrcSubs ? dst : src);
		 }
	 }
 }",0,0,1,0
"public ByteBuf encodeHeader(ByteBufAllocator allocator) {
	 ByteBuf buffer = allocator.buffer(31);
	 buffer.writeInt((int) getTTL());
	 CodecUtils.encodeTrace(getTracing(), buffer);
	 CodecUtils.encodeString(getWhy(), buffer);
	 return buffer;
 }",0,0,0,0
"public BufferedImage processImage(BufferedImage image) {
	 double variance = sigma*sigma;
	 originalImage = image;
	 int width = originalImage.getWidth();
	 int height = originalImage.getHeight();
	 filteredImage = new BufferedImage(width, height, originalImage.getType());
	 double a = 0.0;
	 double b = 0.0;
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 while (a == 0.0) a = Math.random();
			 b = Math.random();
			 double x = Math.sqrt(-2*Math.log(a)) * Math.cos(2*Math.PI*b);
			 double noise = mean + Math.sqrt(variance) * x;
			 int gray = new Color(originalImage.getRGB(i, j)).getRed();
			 int alpha = new Color(originalImage.getRGB(i, j)).getAlpha();
			 double color = gray + noise;
			 if (color > 255) color = 255;
			 if (color < 0) color = 0;
			 int newColor = (int) Math.round(color);
			 int rgb = ImageUtilities.colorToRGB(alpha, newColor, newColor, newColor);
			 filteredImage.setRGB(i, j, rgb);
		 }
	 }
	 return filteredImage;
 }",0,0,1,0
"public class RandomDataSourceSelector implements DataSourceSelector {
	 private final static Log LOG = LogFactory.getLog(RandomDataSourceSelector.class);
	 private Random random = new Random();
	 private List<DataSource> blacklist = new CopyOnWriteArrayList<DataSource>();
	 private HighAvailableDataSource highAvailableDataSource;
	 private RandomDataSourceValidateThread validateThread;
	 private RandomDataSourceRecoverThread recoverThread;
	 public RandomDataSourceSelector(HighAvailableDataSource highAvailableDataSource) {
		 this.highAvailableDataSource = highAvailableDataSource;
		 if (!highAvailableDataSource.isTestOnBorrow() && !highAvailableDataSource.isTestOnReturn()) {
			 validateThread = new RandomDataSourceValidateThread(this);
			 recoverThread = new RandomDataSourceRecoverThread(this);
			 new Thread(validateThread, ""RandomDataSourceSelector-validate-thread"").start();
			 new Thread(recoverThread, ""RandomDataSourceSelector-recover-thread"").start();
		 }
		 else {
			 LOG.info(""testOnBorrow or testOnReturn has been set to true, ignore validateThread"");
		 }
	 }
	 public boolean isSame(String name) {
		 return getName().equalsIgnoreCase(name);
	 }
	 public String getName() {
		 return ""random"";
	 }
	 public DataSource get() {
		 Map<String, DataSource> dataSourceMap = getDataSourceMap();
		 if (dataSourceMap == null || dataSourceMap.isEmpty()) {
			 return null;
		 }
		 Collection<DataSource> targetDataSourceSet;
		 if (blacklist == null || blacklist.isEmpty() || blacklist.size() >= dataSourceMap.size()) {
			 targetDataSourceSet = dataSourceMap.values();
		 }
		 else {
			 targetDataSourceSet = new HashSet<DataSource>(dataSourceMap.values());
			 for (DataSource b : blacklist) {
				 targetDataSourceSet.remove(b);
			 }
		 }
		 DataSource[] dataSources = targetDataSourceSet.toArray(new DataSource[] {
		}
		);
		 if (dataSources != null && dataSources.length > 0) {
			 return dataSources[random.nextInt(targetDataSourceSet.size())];
		 }
		 return null;
	 }
	 public void setTarget(String name) {
	 }
	 public Map<String, DataSource> getDataSourceMap() {
		 if (highAvailableDataSource != null) {
			 return highAvailableDataSource.getDataSourceMap();
		 }
		 return new HashMap<String, DataSource>();
	 }
	 public List<DataSource> getBlacklist() {
		 return blacklist;
	 }
	 public void addBlacklist(DataSource dataSource) {
		 if (dataSource != null && !blacklist.contains(dataSource)) {
			 blacklist.add(dataSource);
			 if (dataSource instanceof DruidDataSource) {
				 ((DruidDataSource) dataSource).setTestOnReturn(true);
			 }
		 }
	 }
	 public void removeBlacklist(DataSource dataSource) {
		 if (dataSource != null && blacklist.contains(dataSource)) {
			 blacklist.remove(dataSource);
			 if (dataSource instanceof DruidDataSource) {
				 ((DruidDataSource) dataSource).setTestOnReturn(highAvailableDataSource.isTestOnReturn());
			 }
		 }
	 }
	 public RandomDataSourceValidateThread getValidateThread() {
		 return validateThread;
	 }
	 public RandomDataSourceRecoverThread getRecoverThread() {
		 return recoverThread;
	 }
}",0,0,0,0
"public class IteratorTestCaseFinder {
	 private static final Logger log = LoggerFactory.getLogger(IteratorTestCaseFinder.class);
	 public static List<IteratorTestCase> findAllTestCases() {
		 log.info(""Searching {
		}
		"", IteratorTestCase.class.getPackage().getName());
		 ClassPath cp;
		 try {
			 cp = ClassPath.from(IteratorTestCaseFinder.class.getClassLoader());
		 }
		 catch (IOException e) {
			 throw new RuntimeException(e);
		 }
		 ImmutableSet<ClassInfo> classes = cp .getTopLevelClasses(IteratorTestCase.class.getPackage().getName());
		 final List<IteratorTestCase> testCases = new ArrayList<>();
		 for (ClassInfo classInfo : classes) {
			 Class<?> clz;
			 try {
				 clz = Class.forName(classInfo.getName());
			 }
			 catch (Exception e) {
				 log.warn(""Could not get class for "" + classInfo.getName(), e);
				 continue;
			 }
			 if (clz.isInterface() || Modifier.isAbstract(clz.getModifiers()) || !IteratorTestCase.class.isAssignableFrom(clz)) {
				 log.debug(""Skipping "" + clz);
				 continue;
			 }
			 try {
				 testCases.add((IteratorTestCase) clz.newInstance());
			 }
			 catch (IllegalAccessException | InstantiationException e) {
				 log.warn(""Could not instantiate {
				}
				"", clz, e);
			 }
		 }
		 return testCases;
	 }
}",1,0,0,0
"public class JavaLexer extends antlr.CharScanner implements JavaTokenTypes, TokenStream {
	public JavaLexer(InputStream in) {
		this(new ByteBuffer(in));
	}
	public JavaLexer(Reader in) {
		this(new CharBuffer(in));
	}
	public JavaLexer(InputBuffer ib) {
		this(new LexerSharedInputState(ib));
	}
	public JavaLexer(LexerSharedInputState state) {
		super(state);
		caseSensitiveLiterals = true;
		setCaseSensitive(true);
		literals = new Hashtable();
		literals.put(new ANTLRHashString(""byte"", this), new Integer(71));
		literals.put(new ANTLRHashString(""public"", this), new Integer(46));
		literals.put(new ANTLRHashString(""case"", this), new Integer(91));
		literals.put(new ANTLRHashString(""short"", this), new Integer(73));
		literals.put(new ANTLRHashString(""break"", this), new Integer(85));
		literals.put(new ANTLRHashString(""while"", this), new Integer(83));
		literals.put(new ANTLRHashString(""new"", this), new Integer(136));
		literals.put(new ANTLRHashString(""instanceof"", this), new Integer(119));
		literals.put(new ANTLRHashString(""implements"", this), new Integer(59));
		literals.put(new ANTLRHashString(""synchronized"", this), new Integer(51));
		literals.put(new ANTLRHashString(""const"", this), new Integer(141));
		literals.put(new ANTLRHashString(""float"", this), new Integer(75));
		literals.put(new ANTLRHashString(""package"", this), new Integer(40));
		literals.put(new ANTLRHashString(""return"", this), new Integer(87));
		literals.put(new ANTLRHashString(""throw"", this), new Integer(89));
		literals.put(new ANTLRHashString(""null"", this), new Integer(135));
		literals.put(new ANTLRHashString(""protected"", this), new Integer(48));
		literals.put(new ANTLRHashString(""class"", this), new Integer(57));
		literals.put(new ANTLRHashString(""throws"", this), new Integer(66));
		literals.put(new ANTLRHashString(""do"", this), new Integer(84));
		literals.put(new ANTLRHashString(""strictfp"", this), new Integer(56));
		literals.put(new ANTLRHashString(""super"", this), new Integer(132));
		literals.put(new ANTLRHashString(""transient"", this), new Integer(53));
		literals.put(new ANTLRHashString(""native"", this), new Integer(54));
		literals.put(new ANTLRHashString(""interface"", this), new Integer(61));
		literals.put(new ANTLRHashString(""final"", this), new Integer(50));
		literals.put(new ANTLRHashString(""if"", this), new Integer(80));
		literals.put(new ANTLRHashString(""double"", this), new Integer(77));
		literals.put(new ANTLRHashString(""volatile"", this), new Integer(52));
		literals.put(new ANTLRHashString(""assert"", this), new Integer(90));
		literals.put(new ANTLRHashString(""catch"", this), new Integer(95));
		literals.put(new ANTLRHashString(""try"", this), new Integer(93));
		literals.put(new ANTLRHashString(""goto"", this), new Integer(142));
		literals.put(new ANTLRHashString(""int"", this), new Integer(74));
		literals.put(new ANTLRHashString(""for"", this), new Integer(82));
		literals.put(new ANTLRHashString(""extends"", this), new Integer(58));
		literals.put(new ANTLRHashString(""boolean"", this), new Integer(70));
		literals.put(new ANTLRHashString(""char"", this), new Integer(72));
		literals.put(new ANTLRHashString(""private"", this), new Integer(47));
		literals.put(new ANTLRHashString(""default"", this), new Integer(92));
		literals.put(new ANTLRHashString(""false"", this), new Integer(134));
		literals.put(new ANTLRHashString(""this"", this), new Integer(131));
		literals.put(new ANTLRHashString(""static"", this), new Integer(49));
		literals.put(new ANTLRHashString(""abstract"", this), new Integer(55));
		literals.put(new ANTLRHashString(""continue"", this), new Integer(86));
		literals.put(new ANTLRHashString(""finally"", this), new Integer(94));
		literals.put(new ANTLRHashString(""else"", this), new Integer(81));
		literals.put(new ANTLRHashString(""import"", this), new Integer(42));
		literals.put(new ANTLRHashString(""void"", this), new Integer(69));
		literals.put(new ANTLRHashString(""switch"", this), new Integer(88));
		literals.put(new ANTLRHashString(""true"", this), new Integer(133));
		literals.put(new ANTLRHashString(""long"", this), new Integer(76));
	}
	public Token nextToken() throws TokenStreamException {
		Token theRetToken=null;
		tryAgain:for (;
		;
		) {
			Token _token = null;
			int _ttype = Token.INVALID_TYPE;
			resetText();
			try {
				 try {
					 switch ( LA(1)) {
						case '?':{
							mQUESTION(true);
							theRetToken=_returnToken;
							break;
						}
						case '(':{
							mLPAREN(true);
							theRetToken=_returnToken;
							break;
						}
						case ')':{
							mRPAREN(true);
							theRetToken=_returnToken;
							break;
						}
						case '[':{
							mLBRACK(true);
							theRetToken=_returnToken;
							break;
						}
						case ']':{
							mRBRACK(true);
							theRetToken=_returnToken;
							break;
						}
						case '{
							':{
								mLCURLY(true);
								theRetToken=_returnToken;
								break;
							}
						case '}
						':{
							mRCURLY(true);
							theRetToken=_returnToken;
							break;
						}
						case ':':{
							mCOLON(true);
							theRetToken=_returnToken;
							break;
						}
						case ',':{
							mCOMMA(true);
							theRetToken=_returnToken;
							break;
						}
						case '~':{
							mBNOT(true);
							theRetToken=_returnToken;
							break;
						}
						case ';
						':{
							mSEMI(true);
							theRetToken=_returnToken;
							break;
						}
						case '\t': case '\n': case '\u000c': case '\r':case ' ':{
							mWS(true);
							theRetToken=_returnToken;
							break;
						}
						case '\'':{
							mCHAR_LITERAL(true);
							theRetToken=_returnToken;
							break;
						}
						case '""':{
							mSTRING_LITERAL(true);
							theRetToken=_returnToken;
							break;
						}
						case '$': case 'A': case 'B': case 'C':case 'D': case 'E': case 'F': case 'G':case 'H': case 'I': case 'J': case 'K':case 'L': case 'M': case 'N': case 'O':case 'P': case 'Q': case 'R': case 'S':case 'T': case 'U': case 'V': case 'W':case 'X': case 'Y': case 'Z': case '_':case 'a': case 'b': case 'c': case 'd':case 'e': case 'f': case 'g': case 'h':case 'i': case 'j': case 'k': case 'l':case 'm': case 'n': case 'o': case 'p':case 'q': case 'r': case 's': case 't':case 'u': case 'v': case 'w': case 'x':case 'y': case 'z':{
							mIDENT(true);
							theRetToken=_returnToken;
							break;
						}
						case '.': case '0': case '1': case '2':case '3': case '4': case '5': case '6':case '7': case '8': case '9':{
							mNUM_INT(true);
							theRetToken=_returnToken;
							break;
						}
						default:if ((LA(1)=='>') && (LA(2)=='>') && (LA(3)=='>') && (LA(4)=='=')) {
							mBSR_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='>') && (LA(2)=='>') && (LA(3)=='=')) {
							mSR_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='>') && (LA(2)=='>') && (LA(3)=='>') && (true)) {
							mBSR(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='<') && (LA(2)=='<') && (LA(3)=='=')) {
							mSL_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='=') && (LA(2)=='=')) {
							mEQUAL(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='!') && (LA(2)=='=')) {
							mNOT_EQUAL(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='/') && (LA(2)=='=')) {
							mDIV_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='+') && (LA(2)=='=')) {
							mPLUS_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='+') && (LA(2)=='+')) {
							mINC(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='-') && (LA(2)=='=')) {
							mMINUS_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='-') && (LA(2)=='-')) {
							mDEC(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='*') && (LA(2)=='=')) {
							mSTAR_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='%') && (LA(2)=='=')) {
							mMOD_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='>') && (LA(2)=='>') && (true)) {
							mSR(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='>') && (LA(2)=='=')) {
							mGE(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='<') && (LA(2)=='<') && (true)) {
							mSL(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='<') && (LA(2)=='=')) {
							mLE(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='^') && (LA(2)=='=')) {
							mBXOR_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='|') && (LA(2)=='=')) {
							mBOR_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='|') && (LA(2)=='|')) {
							mLOR(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='&') && (LA(2)=='=')) {
							mBAND_ASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='&') && (LA(2)=='&')) {
							mLAND(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='/') && (LA(2)=='/')) {
							mSL_COMMENT(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='/') && (LA(2)=='*')) {
							mML_COMMENT(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='=') && (true)) {
							mASSIGN(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='!') && (true)) {
							mLNOT(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='/') && (true)) {
							mDIV(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='+') && (true)) {
							mPLUS(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='-') && (true)) {
							mMINUS(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='*') && (true)) {
							mSTAR(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='%') && (true)) {
							mMOD(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='>') && (true)) {
							mGT(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='<') && (true)) {
							mLT(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='^') && (true)) {
							mBXOR(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='|') && (true)) {
							mBOR(true);
							theRetToken=_returnToken;
						}
						else if ((LA(1)=='&') && (true)) {
							mBAND(true);
							theRetToken=_returnToken;
						}
						else {
							if (LA(1)==EOF_CHAR) {
								uponEOF();
								 _returnToken = makeToken(Token.EOF_TYPE);
							}
							else {
								throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
							}
						}
					}
					if ( _returnToken==null ) continue tryAgain;
					 _ttype = _returnToken.getType();
					_returnToken.setType(_ttype);
					return _returnToken;
				}
				catch (RecognitionException e) {
					throw new TokenStreamRecognitionException(e);
				}
			}
			catch (CharStreamException cse) {
				if ( cse instanceof CharStreamIOException ) {
					throw new TokenStreamIOException(((CharStreamIOException)cse).io);
				}
				else {
					throw new TokenStreamException(cse.getMessage());
				}
			}
		}
	}
	public final void mQUESTION(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = QUESTION;
		int _saveIndex;
		match('?');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLPAREN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LPAREN;
		int _saveIndex;
		match('(');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mRPAREN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = RPAREN;
		int _saveIndex;
		match(')');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLBRACK(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LBRACK;
		int _saveIndex;
		match('[');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mRBRACK(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = RBRACK;
		int _saveIndex;
		match(']');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLCURLY(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LCURLY;
		int _saveIndex;
		match('{
			');
			if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
				_token = makeToken(_ttype);
				_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
			}
			_returnToken = _token;
		}
		public final void mRCURLY(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
			int _ttype;
			 Token _token=null;
			 int _begin=text.length();
			_ttype = RCURLY;
			int _saveIndex;
		match('}
		');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mCOLON(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = COLON;
		int _saveIndex;
		match(':');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mCOMMA(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = COMMA;
		int _saveIndex;
		match(',');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = ASSIGN;
		int _saveIndex;
		match('=');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mEQUAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = EQUAL;
		int _saveIndex;
		match(""=="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLNOT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LNOT;
		int _saveIndex;
		match('!');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBNOT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BNOT;
		int _saveIndex;
		match('~');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mNOT_EQUAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = NOT_EQUAL;
		int _saveIndex;
		match(""!="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mDIV(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = DIV;
		int _saveIndex;
		match('/');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mDIV_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = DIV_ASSIGN;
		int _saveIndex;
		match(""/="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mPLUS(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = PLUS;
		int _saveIndex;
		match('+');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mPLUS_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = PLUS_ASSIGN;
		int _saveIndex;
		match(""+="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mINC(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = INC;
		int _saveIndex;
		match(""++"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mMINUS(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = MINUS;
		int _saveIndex;
		match('-');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mMINUS_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = MINUS_ASSIGN;
		int _saveIndex;
		match(""-="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mDEC(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = DEC;
		int _saveIndex;
		match(""--"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSTAR(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = STAR;
		int _saveIndex;
		match('*');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSTAR_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = STAR_ASSIGN;
		int _saveIndex;
		match(""*="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mMOD(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = MOD;
		int _saveIndex;
		match('%');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mMOD_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = MOD_ASSIGN;
		int _saveIndex;
		match(""%="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSR(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = SR;
		int _saveIndex;
		match("">>"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSR_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = SR_ASSIGN;
		int _saveIndex;
		match("">>="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBSR(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BSR;
		int _saveIndex;
		match("">>>"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBSR_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BSR_ASSIGN;
		int _saveIndex;
		match("">>>="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mGE(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = GE;
		int _saveIndex;
		match("">="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mGT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = GT;
		int _saveIndex;
		match("">"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = SL;
		int _saveIndex;
		match(""<<"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSL_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = SL_ASSIGN;
		int _saveIndex;
		match(""<<="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLE(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LE;
		int _saveIndex;
		match(""<="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LT;
		int _saveIndex;
		match('<');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBXOR(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BXOR;
		int _saveIndex;
		match('^');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBXOR_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BXOR_ASSIGN;
		int _saveIndex;
		match(""^="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBOR(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BOR;
		int _saveIndex;
		match('|');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBOR_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BOR_ASSIGN;
		int _saveIndex;
		match(""|="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLOR(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LOR;
		int _saveIndex;
		match(""||"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBAND(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BAND;
		int _saveIndex;
		match('&');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mBAND_ASSIGN(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = BAND_ASSIGN;
		int _saveIndex;
		match(""&="");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mLAND(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = LAND;
		int _saveIndex;
		match(""&&"");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSEMI(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = SEMI;
		int _saveIndex;
		match(';
		');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mWS(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = WS;
		int _saveIndex;
		{
			int _cnt226=0;
			_loop226:do {
				switch ( LA(1)) {
					case ' ':{
						match(' ');
						break;
					}
					case '\t':{
						match('\t');
						break;
					}
					case '\u000c':{
						match('\f');
						break;
					}
					case '\n': case '\r':{
						{
							if ((LA(1)=='\r') && (LA(2)=='\n') && (true) && (true)) {
								match(""\r\n"");
							}
							else if ((LA(1)=='\r') && (true) && (true) && (true)) {
								match('\r');
							}
							else if ((LA(1)=='\n')) {
								match('\n');
							}
							else {
								throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
							}
						}
						if ( inputState.guessing==0 ) {
							newline();
						}
						break;
					}
					default:{
						if ( _cnt226>=1 ) {
							 break _loop226;
						 }
						 else {
							throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
						}
					}
				}
				_cnt226++;
			}
			 while (true);
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSL_COMMENT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = SL_COMMENT;
		int _saveIndex;
		match(""{
			_loop230:do {
				if ((_tokenSet_0.member(LA(1)))) {
					{
						match(_tokenSet_0);
					}
				}
				else {
					break _loop230;
				}
			}
			 while (true);
		}
		{
			switch ( LA(1)) {
				case '\n':{
					match('\n');
					break;
				}
				case '\r':{
					match('\r');
					{
						if ((LA(1)=='\n')) {
							match('\n');
						}
						else {
						}
					}
					break;
				}
				default:{
				}
			}
		}
		if ( inputState.guessing==0 ) {
			newline();
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mML_COMMENT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = ML_COMMENT;
		int _saveIndex;
		match("""");
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mCHAR_LITERAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = CHAR_LITERAL;
		int _saveIndex;
		match('\'');
		{
			if ((LA(1)=='\\')) {
				mESC(false);
			}
			else if ((_tokenSet_2.member(LA(1)))) {
				{
					match(_tokenSet_2);
				}
			}
			else {
				throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
			}
		}
		match('\'');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	protected final void mESC(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = ESC;
		int _saveIndex;
		match('\\');
		{
			switch ( LA(1)) {
				case 'n':{
					match('n');
					break;
				}
				case 'r':{
					match('r');
					break;
				}
				case 't':{
					match('t');
					break;
				}
				case 'b':{
					match('b');
					break;
				}
				case 'f':{
					match('f');
					break;
				}
				case '""':{
					match('""');
					break;
				}
				case '\'':{
					match('\'');
					break;
				}
				case '\\':{
					match('\\');
					break;
				}
				case 'u':{
					{
						int _cnt247=0;
						_loop247:do {
							if ((LA(1)=='u')) {
								match('u');
							}
							else {
								if ( _cnt247>=1 ) {
									 break _loop247;
								 }
								 else {
									throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
								}
							}
							_cnt247++;
						}
						 while (true);
					}
					mHEX_DIGIT(false);
					mHEX_DIGIT(false);
					mHEX_DIGIT(false);
					mHEX_DIGIT(false);
					break;
				}
				case '0': case '1': case '2': case '3':{
					matchRange('0','3');
					{
						if (((LA(1) >= '0' && LA(1) <= '7')) && (_tokenSet_0.member(LA(2))) && (true) && (true)) {
							matchRange('0','7');
							{
								if (((LA(1) >= '0' && LA(1) <= '7')) && (_tokenSet_0.member(LA(2))) && (true) && (true)) {
									matchRange('0','7');
								}
								else if ((_tokenSet_0.member(LA(1))) && (true) && (true) && (true)) {
								}
								else {
									throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
								}
							}
						}
						else if ((_tokenSet_0.member(LA(1))) && (true) && (true) && (true)) {
						}
						else {
							throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
						}
					}
					break;
				}
				case '4': case '5': case '6': case '7':{
					matchRange('4','7');
					{
						if (((LA(1) >= '0' && LA(1) <= '7')) && (_tokenSet_0.member(LA(2))) && (true) && (true)) {
							matchRange('0','7');
						}
						else if ((_tokenSet_0.member(LA(1))) && (true) && (true) && (true)) {
						}
						else {
							throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
						}
					}
					break;
				}
				default:{
					throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
				}
			}
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mSTRING_LITERAL(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = STRING_LITERAL;
		int _saveIndex;
		match('""');
		{
			_loop243:do {
				if ((LA(1)=='\\')) {
					mESC(false);
				}
				else if ((_tokenSet_3.member(LA(1)))) {
					{
						match(_tokenSet_3);
					}
				}
				else {
					break _loop243;
				}
			}
			 while (true);
		}
		match('""');
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	protected final void mHEX_DIGIT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = HEX_DIGIT;
		int _saveIndex;
		{
			switch ( LA(1)) {
				case '0': case '1': case '2': case '3':case '4': case '5': case '6': case '7':case '8': case '9':{
					matchRange('0','9');
					break;
				}
				case 'A': case 'B': case 'C': case 'D':case 'E': case 'F':{
					matchRange('A','F');
					break;
				}
				case 'a': case 'b': case 'c': case 'd':case 'e': case 'f':{
					matchRange('a','f');
					break;
				}
				default:{
					throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
				}
			}
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mIDENT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = IDENT;
		int _saveIndex;
		{
			switch ( LA(1)) {
				case 'a': case 'b': case 'c': case 'd':case 'e': case 'f': case 'g': case 'h':case 'i': case 'j': case 'k': case 'l':case 'm': case 'n': case 'o': case 'p':case 'q': case 'r': case 's': case 't':case 'u': case 'v': case 'w': case 'x':case 'y': case 'z':{
					matchRange('a','z');
					break;
				}
				case 'A': case 'B': case 'C': case 'D':case 'E': case 'F': case 'G': case 'H':case 'I': case 'J': case 'K': case 'L':case 'M': case 'N': case 'O': case 'P':case 'Q': case 'R': case 'S': case 'T':case 'U': case 'V': case 'W': case 'X':case 'Y': case 'Z':{
					matchRange('A','Z');
					break;
				}
				case '_':{
					match('_');
					break;
				}
				case '$':{
					match('$');
					break;
				}
				default:{
					throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
				}
			}
		}
		{
			_loop256:do {
				switch ( LA(1)) {
					case 'a': case 'b': case 'c': case 'd':case 'e': case 'f': case 'g': case 'h':case 'i': case 'j': case 'k': case 'l':case 'm': case 'n': case 'o': case 'p':case 'q': case 'r': case 's': case 't':case 'u': case 'v': case 'w': case 'x':case 'y': case 'z':{
						matchRange('a','z');
						break;
					}
					case 'A': case 'B': case 'C': case 'D':case 'E': case 'F': case 'G': case 'H':case 'I': case 'J': case 'K': case 'L':case 'M': case 'N': case 'O': case 'P':case 'Q': case 'R': case 'S': case 'T':case 'U': case 'V': case 'W': case 'X':case 'Y': case 'Z':{
						matchRange('A','Z');
						break;
					}
					case '_':{
						match('_');
						break;
					}
					case '0': case '1': case '2': case '3':case '4': case '5': case '6': case '7':case '8': case '9':{
						matchRange('0','9');
						break;
					}
					case '$':{
						match('$');
						break;
					}
					default:{
						break _loop256;
					}
				}
			}
			 while (true);
		}
		_ttype = testLiteralsTable(_ttype);
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	public final void mNUM_INT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = NUM_INT;
		int _saveIndex;
		boolean isDecimal=false;
		switch ( LA(1)) {
			case '.':{
				match('.');
				if ( inputState.guessing==0 ) {
					_ttype = DOT;
				}
				{
					if (((LA(1) >= '0' && LA(1) <= '9'))) {
						{
							int _cnt260=0;
							_loop260:do {
								if (((LA(1) >= '0' && LA(1) <= '9'))) {
									matchRange('0','9');
								}
								else {
									if ( _cnt260>=1 ) {
										 break _loop260;
									 }
									 else {
										throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
									}
								}
								_cnt260++;
							}
							 while (true);
						}
						{
							if ((LA(1)=='E'||LA(1)=='e')) {
								mEXPONENT(false);
							}
							else {
							}
						}
						{
							if ((LA(1)=='D'||LA(1)=='F'||LA(1)=='d'||LA(1)=='f')) {
								mFLOAT_SUFFIX(false);
							}
							else {
							}
						}
						if ( inputState.guessing==0 ) {
							_ttype = NUM_FLOAT;
						}
					}
					else {
					}
				}
				break;
			}
			case '0': case '1': case '2': case '3':case '4': case '5': case '6': case '7':case '8': case '9':{
				{
					switch ( LA(1)) {
						case '0':{
							match('0');
							if ( inputState.guessing==0 ) {
								isDecimal = true;
							}
							{
								if ((LA(1)=='X'||LA(1)=='x')) {
									{
										switch ( LA(1)) {
											case 'x':{
												match('x');
												break;
											}
											case 'X':{
												match('X');
												break;
											}
											default:{
												throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
											}
										}
									}
									{
										int _cnt267=0;
										_loop267:do {
											if ((_tokenSet_4.member(LA(1))) && (true) && (true) && (true)) {
												mHEX_DIGIT(false);
											}
											else {
												if ( _cnt267>=1 ) {
													 break _loop267;
												 }
												 else {
													throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
												}
											}
											_cnt267++;
										}
										 while (true);
									}
								}
								else {
									boolean synPredMatched272 = false;
									if ((((LA(1) >= '0' && LA(1) <= '9')) && (true) && (true) && (true))) {
										int _m272 = mark();
										synPredMatched272 = true;
										inputState.guessing++;
										try {
											{
												{
													int _cnt270=0;
													_loop270:do {
														if (((LA(1) >= '0' && LA(1) <= '9'))) {
															matchRange('0','9');
														}
														else {
															if ( _cnt270>=1 ) {
																 break _loop270;
															 }
															 else {
																throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
															}
														}
														_cnt270++;
													}
													 while (true);
												}
												{
													switch ( LA(1)) {
														case '.':{
															match('.');
															break;
														}
														case 'E': case 'e':{
															mEXPONENT(false);
															break;
														}
														case 'D': case 'F': case 'd': case 'f':{
															mFLOAT_SUFFIX(false);
															break;
														}
														default:{
															throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
														}
													}
												}
											}
										}
										catch (RecognitionException pe) {
											synPredMatched272 = false;
										}
										rewind(_m272);
										inputState.guessing--;
									}
									if ( synPredMatched272 ) {
										{
											int _cnt274=0;
											_loop274:do {
												if (((LA(1) >= '0' && LA(1) <= '9'))) {
													matchRange('0','9');
												}
												else {
													if ( _cnt274>=1 ) {
														 break _loop274;
													 }
													 else {
														throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
													}
												}
												_cnt274++;
											}
											 while (true);
										}
									}
									else if (((LA(1) >= '0' && LA(1) <= '7')) && (true) && (true) && (true)) {
										{
											int _cnt276=0;
											_loop276:do {
												if (((LA(1) >= '0' && LA(1) <= '7'))) {
													matchRange('0','7');
												}
												else {
													if ( _cnt276>=1 ) {
														 break _loop276;
													 }
													 else {
														throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
													}
												}
												_cnt276++;
											}
											 while (true);
										}
									}
									else {
									}
								}
							}
							break;
						}
						case '1': case '2': case '3': case '4':case '5': case '6': case '7': case '8':case '9':{
							{
								matchRange('1','9');
							}
							{
								_loop279:do {
									if (((LA(1) >= '0' && LA(1) <= '9'))) {
										matchRange('0','9');
									}
									else {
										break _loop279;
									}
								}
								 while (true);
							}
							if ( inputState.guessing==0 ) {
								isDecimal=true;
							}
							break;
						}
						default:{
							throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
						}
					}
				}
				{
					if ((LA(1)=='L'||LA(1)=='l')) {
						{
							switch ( LA(1)) {
								case 'l':{
									match('l');
									break;
								}
								case 'L':{
									match('L');
									break;
								}
								default:{
									throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
								}
							}
						}
					}
					else if (((LA(1)=='.'||LA(1)=='D'||LA(1)=='E'||LA(1)=='F'||LA(1)=='d'||LA(1)=='e'||LA(1)=='f'))&&(isDecimal)) {
						{
							switch ( LA(1)) {
								case '.':{
									match('.');
									{
										_loop284:do {
											if (((LA(1) >= '0' && LA(1) <= '9'))) {
												matchRange('0','9');
											}
											else {
												break _loop284;
											}
										}
										 while (true);
									}
									{
										if ((LA(1)=='E'||LA(1)=='e')) {
											mEXPONENT(false);
										}
										else {
										}
									}
									{
										if ((LA(1)=='D'||LA(1)=='F'||LA(1)=='d'||LA(1)=='f')) {
											mFLOAT_SUFFIX(false);
										}
										else {
										}
									}
									break;
								}
								case 'E': case 'e':{
									mEXPONENT(false);
									{
										if ((LA(1)=='D'||LA(1)=='F'||LA(1)=='d'||LA(1)=='f')) {
											mFLOAT_SUFFIX(false);
										}
										else {
										}
									}
									break;
								}
								case 'D': case 'F': case 'd': case 'f':{
									mFLOAT_SUFFIX(false);
									break;
								}
								default:{
									throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
								}
							}
						}
						if ( inputState.guessing==0 ) {
							_ttype = NUM_FLOAT;
						}
					}
					else {
					}
				}
				break;
			}
			default:{
				throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
			}
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	protected final void mEXPONENT(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = EXPONENT;
		int _saveIndex;
		{
			switch ( LA(1)) {
				case 'e':{
					match('e');
					break;
				}
				case 'E':{
					match('E');
					break;
				}
				default:{
					throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
				}
			}
		}
		{
			switch ( LA(1)) {
				case '+':{
					match('+');
					break;
				}
				case '-':{
					match('-');
					break;
				}
				case '0': case '1': case '2': case '3':case '4': case '5': case '6': case '7':case '8': case '9':{
					break;
				}
				default:{
					throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
				}
			}
		}
		{
			int _cnt292=0;
			_loop292:do {
				if (((LA(1) >= '0' && LA(1) <= '9'))) {
					matchRange('0','9');
				}
				else {
					if ( _cnt292>=1 ) {
						 break _loop292;
					 }
					 else {
						throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
					}
				}
				_cnt292++;
			}
			 while (true);
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	protected final void mFLOAT_SUFFIX(boolean _createToken) throws RecognitionException, CharStreamException, TokenStreamException {
		int _ttype;
		 Token _token=null;
		 int _begin=text.length();
		_ttype = FLOAT_SUFFIX;
		int _saveIndex;
		switch ( LA(1)) {
			case 'f':{
				match('f');
				break;
			}
			case 'F':{
				match('F');
				break;
			}
			case 'd':{
				match('d');
				break;
			}
			case 'D':{
				match('D');
				break;
			}
			default:{
				throw new NoViableAltForCharException((char)LA(1), getFilename(), getLine(), getColumn());
			}
		}
		if ( _createToken && _token==null && _ttype!=Token.SKIP ) {
			_token = makeToken(_ttype);
			_token.setText(new String(text.getBuffer(), _begin, text.length()-_begin));
		}
		_returnToken = _token;
	}
	private static final long[] mk_tokenSet_0() {
		long[] data = new long[1024];
		data[0]=-9224L;
		for (int i = 1;
		 i<=510;
		 i++) {
			 data[i]=-1L;
		 }
		data[511]=9223372036854775807L;
		return data;
	}
	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
	private static final long[] mk_tokenSet_1() {
		long[] data = new long[1024];
		data[0]=-4398046520328L;
		for (int i = 1;
		 i<=510;
		 i++) {
			 data[i]=-1L;
		 }
		data[511]=9223372036854775807L;
		return data;
	}
	public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
	private static final long[] mk_tokenSet_2() {
		long[] data = new long[1024];
		data[0]=-549755823112L;
		data[1]=-268435457L;
		for (int i = 2;
		 i<=510;
		 i++) {
			 data[i]=-1L;
		 }
		data[511]=9223372036854775807L;
		return data;
	}
	public static final BitSet _tokenSet_2 = new BitSet(mk_tokenSet_2());
	private static final long[] mk_tokenSet_3() {
		long[] data = new long[1024];
		data[0]=-17179878408L;
		data[1]=-268435457L;
		for (int i = 2;
		 i<=510;
		 i++) {
			 data[i]=-1L;
		 }
		data[511]=9223372036854775807L;
		return data;
	}
	public static final BitSet _tokenSet_3 = new BitSet(mk_tokenSet_3());
	private static final long[] mk_tokenSet_4() {
		long[] data = new long[513];
		data[0]=287948901175001088L;
		data[1]=541165879422L;
		return data;
	}
	public static final BitSet _tokenSet_4 = new BitSet(mk_tokenSet_4());
}",1,0,0,0
"public RowMutation makeReplicationMutation() throws IOException {
	 List<ReadCommand> readCommands = new LinkedList<ReadCommand>();
	 for (ColumnFamily columnFamily : rowMutation.getColumnFamilies()) {
		 if (!columnFamily.metadata().getReplicateOnWrite()) continue;
		 addReadCommandFromColumnFamily(rowMutation.getTable(), rowMutation.key(), columnFamily, readCommands);
	 }
	 RowMutation replicationMutation = new RowMutation(rowMutation.getTable(), rowMutation.key());
	 for (ReadCommand readCommand : readCommands) {
		 Table table = Table.open(readCommand.table);
		 Row row = readCommand.getRow(table);
		 if (row == null || row.cf == null) continue;
		 ColumnFamily cf = row.cf;
		 if (cf.isSuper()) cf.retainAll(rowMutation.getColumnFamily(cf.metadata().cfId));
		 replicationMutation.add(cf);
	 }
	 return replicationMutation;
 }",0,0,0,0
"private void initUI() {
	setUndecorated(true);
	try {
		if (GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().isWindowTranslucencySupported(WindowTranslucency.TRANSLUCENT)) {
			setOpacity(0.85f);
		}
	}
	 catch (Exception e) {
		Logger.log(e);
	}
	setIconImage(ImageResource.get(""icon.png"").getImage());
	setSize(400, 210);
	setLocationRelativeTo(null);
	setAlwaysOnTop(true);
	getContentPane().setLayout(null);
	getContentPane().setBackground(ColorResource.getDarkestBgColor());
	JPanel titlePanel = new TitlePanel(null, this);
	titlePanel.setOpaque(false);
	titlePanel.setBounds(0, 0, 400, 50);
	JButton closeBtn = new CustomButton();
	closeBtn.setBounds(365, 5, 30, 30);
	closeBtn.setBackground(ColorResource.getDarkestBgColor());
	closeBtn.setBorderPainted(false);
	closeBtn.setFocusPainted(false);
	closeBtn.setName(""CLOSE"");
	closeBtn.setIcon(ImageResource.get(""close_btn.png""));
	closeBtn.addActionListener(this);
	titlePanel.add(closeBtn);
	JLabel titleLbl = new JLabel(StringResource.get(""VID_TITLE""));
	titleLbl.setFont(FontResource.getBiggerFont());
	titleLbl.setForeground(ColorResource.getSelectionColor());
	titleLbl.setBounds(25, 15, 200, 30);
	titlePanel.add(titleLbl);
	JLabel lineLbl = new JLabel();
	lineLbl.setBackground(ColorResource.getSelectionColor());
	lineLbl.setBounds(0, 55, 400, 1);
	lineLbl.setOpaque(true);
	add(lineLbl);
	txtFile = new JTextField();
	txtFile.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	txtFile.setBackground(ColorResource.getDarkestBgColor());
	txtFile.setForeground(Color.WHITE);
	txtFile.setBounds(77, 79, 241, 20);
	txtFile.setCaretColor(ColorResource.getSelectionColor());
	add(txtFile);
	JButton browse = new CustomButton(""..."");
	browse.setName(""BROWSE_FOLDER"");
	browse.setMargin(new Insets(0, 0, 0, 0));
	browse.setBounds(325, 79, 40, 20);
	browse.setFocusPainted(false);
	browse.setBackground(ColorResource.getDarkestBgColor());
	browse.setBorder(new LineBorder(ColorResource.getSelectionColor(), 1));
	browse.setForeground(Color.WHITE);
	browse.addActionListener(this);
	browse.setFont(FontResource.getItemFont());
	add(browse);
	add(titlePanel);
	JLabel lblFile = new JLabel(StringResource.get(""ND_FILE""), JLabel.RIGHT);
	lblFile.setFont(FontResource.getNormalFont());
	lblFile.setForeground(Color.WHITE);
	lblFile.setBounds(10, 79, 61, 23);
	add(lblFile);
	formatListModel = new DefaultComboBoxModel<MediaFormat>(MediaFormats.getSupportedFormats());
	JLabel lblStream = new JLabel(StringResource.get(""O_STM_FTM""), JLabel.RIGHT);
	lblStream.setFont(FontResource.getNormalFont());
	lblStream.setForeground(Color.WHITE);
	lblStream.setBounds(10, 111, 61, 20);
	add(lblStream);
	cmbStmAction = new JComboBox<String>(new String[] {
	 StringResource.get(""VID_FMT_BOTH""),StringResource.get(""VID_FMT_AUDIO""), StringResource.get(""VID_FMT_VIDEO"") }
	);
	cmbStmAction.addActionListener(this);
	cmbStmAction.setOpaque(true);
	cmbStmAction.setBounds(77, 111, 291, 20);
	cmbStmAction.setName(""STREAM"");
	add(cmbStmAction);
	JPanel panel = new JPanel(null);
	panel.setBounds(0, 155, 400, 55);
	panel.setBackground(Color.DARK_GRAY);
	add(panel);
	btnMore = new CustomButton(StringResource.get(""ND_MORE""));
	btnDN = new CustomButton(StringResource.get(""ND_DOWNLOAD_NOW""));
	btnCN = new CustomButton(StringResource.get(""ND_CANCEL""));
	btnMore.setBounds(0, 1, 120, 55);
	btnMore.setName(""BTN_MORE"");
	styleButton(btnMore);
	panel.add(btnMore);
	btnDN.setBounds(121, 1, 160, 55);
	btnDN.setName(""DOWNLOAD_NOW"");
	styleButton(btnDN);
	panel.add(btnDN);
	btnCN.setBounds(282, 1, 120, 55);
	btnCN.setName(""CLOSE"");
	styleButton(btnCN);
	panel.add(btnCN);
	Logger.log(""Dash metadata? "" + (metadata instanceof DashMetadata));
	cmbStmAction.setEnabled(metadata != null && metadata instanceof DashMetadata);
}",0,0,1,0
"public class StringResource extends Resource {
	 private static final int STRING_MAGIC = Resource.getMagicNumber(""StringResource"".getBytes());
	 private String encoding = null;
	 public StringResource() {
	 }
	 public StringResource(String value) {
		 this(null, value);
	 }
	 public StringResource(Project project, String value) {
		 setProject(project);
		 setValue(project == null ? value : project.replaceProperties(value));
	 }
	 public synchronized void setName(String s) {
		 if (getName() != null) {
			 throw new BuildException(new ImmutableResourceException());
		 }
		 super.setName(s);
	 }
	 public synchronized void setValue(String s) {
		 setName(s);
	 }
	 public synchronized String getName() {
		 return super.getName();
	 }
	 public synchronized String getValue() {
		 return getName();
	 }
	 public boolean isExists() {
		 return getValue() != null;
	 }
	 public void addText(String text) {
		 checkChildrenAllowed();
		 setValue(getProject().replaceProperties(text));
	 }
	 public synchronized void setEncoding(String s) {
		 checkAttributesAllowed();
		 encoding = s;
	 }
	 public synchronized String getEncoding() {
		 return encoding;
	 }
	 public synchronized long getSize() {
		 return isReference() ? ((Resource) getCheckedRef()).getSize() : getContent().length();
	 }
	 public synchronized int hashCode() {
		 if (isReference()) {
			 return getCheckedRef().hashCode();
		 }
		 return super.hashCode() * STRING_MAGIC;
	 }
	 public String toString() {
		 return String.valueOf(getContent());
	 }
	 public synchronized InputStream getInputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getInputStream();
		 }
		 String content = getContent();
		 if (content == null) {
			 throw new IllegalStateException(""unset string value"");
		 }
		 return new ByteArrayInputStream(encoding == null ? content.getBytes() : content.getBytes(encoding));
	 }
	 public synchronized OutputStream getOutputStream() throws IOException {
		 if (isReference()) {
			 return ((Resource) getCheckedRef()).getOutputStream();
		 }
		 if (getValue() != null) {
			 throw new ImmutableResourceException();
		 }
		 return new StringResourceFilterOutputStream();
	 }
	 public void setRefid(Reference r) {
		 if (encoding != null) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 protected synchronized String getContent() {
		 return getValue();
	 }
	 private void setValueFromOutputStream(String output) {
		 String value;
		 if (getProject() != null) {
			 value = getProject().replaceProperties(output);
		 }
		 else {
			 value = output;
		 }
		 setValue(value);
	 }
	 private class StringResourceFilterOutputStream extends FilterOutputStream {
		 private final ByteArrayOutputStream baos;
		 public StringResourceFilterOutputStream() {
			 super(new ByteArrayOutputStream());
			 baos = (ByteArrayOutputStream) out;
		 }
		 public void close() throws IOException {
			 super.close();
			 String result = encoding == null ? baos.toString() : baos.toString(encoding);
			 StringResource.this.setValueFromOutputStream(result);
		 }
	 }
}",0,0,0,0
"public static class DAOAttachment {
	 private final AttachmentId attachmentId;
	 private final BlobId blobId;
	 private final String type;
	 private final long size;
	 private DAOAttachment(AttachmentId attachmentId, BlobId blobId, String type, long size) {
		 this.attachmentId = attachmentId;
		 this.blobId = blobId;
		 this.type = type;
		 this.size = size;
	 }
	 public AttachmentId getAttachmentId() {
		 return attachmentId;
	 }
	 public BlobId getBlobId() {
		 return blobId;
	 }
	 public String getType() {
		 return type;
	 }
	 public long getSize() {
		 return size;
	 }
	 public Attachment toAttachment(byte[] data) {
		 return Attachment.builder() .attachmentId(attachmentId) .type(type) .bytes(data) .build();
	 }
	 public final boolean equals(Object o) {
		 if (o instanceof DAOAttachment) {
			 DAOAttachment that = (DAOAttachment) o;
			 return Objects.equals(this.size, that.size) && Objects.equals(this.attachmentId, that.attachmentId) && Objects.equals(this.blobId, that.blobId) && Objects.equals(this.type, that.type);
		 }
		 return false;
	 }
	 public final int hashCode() {
		 return Objects.hash(attachmentId, blobId, type, size);
	 }
 }",0,1,0,0
"public class JspHelper {
	 static FSNamesystem fsn = null;
	 static InetSocketAddress nameNodeAddr;
	 static Configuration conf = new Configuration();
	 static int defaultChunkSizeToView = conf.getInt(""dfs.default.chunk.view.size"",2 * 1024);
	 static Random rand = new Random();
	 public JspHelper() {
		 if (DataNode.getDataNode() != null) {
			 nameNodeAddr = DataNode.getDataNode().getNameNodeAddr();
		 }
		 else {
			 fsn = FSNamesystem.getFSNamesystem();
			 nameNodeAddr = new InetSocketAddress(fsn.getDFSNameNodeMachine(), fsn.getDFSNameNodePort());
		 }
	 }
	 public DatanodeInfo bestNode(LocatedBlock blk) throws IOException {
		 TreeSet deadNodes = new TreeSet();
		 DatanodeInfo chosenNode = null;
		 int failures = 0;
		 Socket s = null;
		 DatanodeInfo [] nodes = blk.getLocations();
		 if (nodes == null || nodes.length == 0) {
			 throw new IOException(""No nodes contain this block"");
		 }
		 while (s == null) {
			 if (chosenNode == null) {
				 do {
					 chosenNode = nodes[rand.nextInt(nodes.length)];
				 }
				 while (deadNodes.contains(chosenNode));
			 }
			 int index = rand.nextInt(nodes.length);
			 chosenNode = nodes[index];
			 InetSocketAddress targetAddr = DataNode.createSocketAddr(chosenNode.getHost() + "":"" + chosenNode.getInfoPort());
			 try {
				 s = new Socket();
				 s.connect(targetAddr, FSConstants.READ_TIMEOUT);
				 s.setSoTimeout(FSConstants.READ_TIMEOUT);
			 }
			 catch (IOException e) {
				 deadNodes.add(chosenNode);
				 s.close();
				 s = null;
				 failures++;
			 }
			 if (failures == nodes.length) throw new IOException(""Could not reach the block containing the data. Please try again"");
		 }
		 s.close();
		 return chosenNode;
	 }
	 public void streamBlockInAscii(InetSocketAddress addr, long blockId, long blockSize, long offsetIntoBlock, long chunkSizeToView, JspWriter out) throws IOException {
		 if (chunkSizeToView == 0) return;
		 Socket s = new Socket();
		 s.connect(addr, FSConstants.READ_TIMEOUT);
		 s.setSoTimeout(FSConstants.READ_TIMEOUT);
		 DataOutputStream os = new DataOutputStream(new BufferedOutputStream(s.getOutputStream()));
		 os.write(FSConstants.OP_READSKIP_BLOCK);
		 new Block(blockId, blockSize).write(os);
		 os.writeLong(offsetIntoBlock);
		 os.flush();
		 DataInputStream in = new DataInputStream(new BufferedInputStream(s.getInputStream()));
		 long curBlockSize = in.readLong();
		 long amtSkipped = in.readLong();
		 if (curBlockSize != blockSize) {
			 throw new IOException(""Recorded block size is "" + blockSize + "", but datanode reports size of "" + curBlockSize);
		 }
		 if (amtSkipped != offsetIntoBlock) {
			 throw new IOException(""Asked for offset of "" + offsetIntoBlock + "", but only received offset of "" + amtSkipped);
		 }
		 long amtToRead = chunkSizeToView;
		 if (amtToRead + offsetIntoBlock > blockSize) amtToRead = blockSize - offsetIntoBlock;
		 byte[] buf = new byte[(int)amtToRead];
		 int readOffset = 0;
		 int retries = 2;
		 while (true) {
			 int numRead;
			 try {
				 numRead = in.read(buf, readOffset, (int)amtToRead);
			 }
			 catch (IOException e) {
				 retries--;
				 if (retries == 0) throw new IOException(""Could not read data from datanode"");
				 continue;
			 }
			 amtToRead -= numRead;
			 readOffset += numRead;
			 if (amtToRead == 0) break;
		 }
		 s.close();
		 in.close();
		 out.print(new String(buf));
	 }
	 public void DFSNodesStatus(Vector live, Vector dead) {
		 if (fsn == null) return;
		 TreeMap nodesSortedByName = new TreeMap();
		 fsn.DFSNodesStatus(live, dead);
		 for (int num = 0;
		 num < live.size();
		 num++) {
			 DatanodeInfo d = (DatanodeInfo)live.elementAt(num);
			 nodesSortedByName.put(d.getName(), d);
		 }
		 live.clear();
		 live.addAll(nodesSortedByName.values());
	 }
	 public void addTableHeader(JspWriter out) throws IOException {
		 out.print(""<table border=\""1\""""+ "" cellpadding=\""2\"" cellspacing=\""2\"">"");
		 out.print(""<tbody>"");
	 }
	 public void addTableRow(JspWriter out, String[] columns) throws IOException {
		 out.print(""<tr>"");
		 for (int i = 0;
		 i < columns.length;
		 i++) {
			 out.print(""<td style=\""vertical-align: top;
			\""><B>""+columns[i]+""</B><br></td>"");
		 }
		 out.print(""</tr>"");
	 }
	 public void addTableFooter(JspWriter out) throws IOException {
		 out.print(""</tbody></table>"");
	 }
	 public String getSafeModeText() {
		 if( ! fsn.isInSafeMode() ) return """";
		 return ""Safe mode is ON. <em>"" + fsn.getSafeModeTip() + ""<em>"";
	 }
}",0,0,0,0
"public class TimeComparison extends EnumeratedAttribute {
	 private static final String[] VALUES = new String[] {
	""before"", ""after"", ""equal""}
	;
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 public static final TimeComparison BEFORE = new TimeComparison(""before"");
	 public static final TimeComparison AFTER = new TimeComparison(""after"");
	 public static final TimeComparison EQUAL = new TimeComparison(""equal"");
	 public TimeComparison() {
	 }
	 public TimeComparison(String value) {
		 setValue(value);
	 }
	 public String[] getValues() {
		 return VALUES;
	 }
	 public boolean evaluate(long t1, long t2) {
		 return evaluate(t1, t2, FILE_UTILS.getFileTimestampGranularity());
	 }
	 public boolean evaluate(long t1, long t2, long g) {
		 int cmp = getIndex();
		 if (cmp == -1) {
			 throw new BuildException(""TimeComparison value not set."");
		 }
		 if (cmp == 0) {
			 return t1 - g < t2;
		 }
		 if (cmp == 1) {
			 return t1 + g > t2;
		 }
		 return Math.abs(t1 - t2) <= g;
	 }
	 public static int compare(long t1, long t2) {
		 return compare(t1, t2, FILE_UTILS.getFileTimestampGranularity());
	 }
	 public static int compare(long t1, long t2, long g) {
		 long diff = t1 - t2;
		 long abs = Math.abs(diff);
		 return abs > Math.abs(g) ? (int) (diff / abs) : 0;
	 }
}",0,0,0,0
"public void inject(Path crawlDb, Path urlDir) throws IOException {
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""Injector: starting"");
		 LOG.info(""Injector: crawlDb: "" + crawlDb);
		 LOG.info(""Injector: urlDir: "" + urlDir);
	 }
	 Path tempDir = new Path(getConf().get(""mapred.temp.dir"", ""."") + ""/inject-temp-""+ Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""Injector: Converting injected urls to crawl db entries."");
	 }
	 JobConf sortJob = new NutchJob(getConf());
	 sortJob.setJobName(""inject "" + urlDir);
	 sortJob.setInputPath(urlDir);
	 sortJob.setMapperClass(InjectMapper.class);
	 sortJob.setOutputPath(tempDir);
	 sortJob.setOutputFormat(SequenceFileOutputFormat.class);
	 sortJob.setOutputKeyClass(Text.class);
	 sortJob.setOutputValueClass(CrawlDatum.class);
	 sortJob.setLong(""injector.current.time"", System.currentTimeMillis());
	 JobClient.runJob(sortJob);
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""Injector: Merging injected urls into crawl db."");
	 }
	 JobConf mergeJob = CrawlDb.createJob(getConf(), crawlDb);
	 mergeJob.addInputPath(tempDir);
	 mergeJob.setReducerClass(InjectReducer.class);
	 JobClient.runJob(mergeJob);
	 CrawlDb.install(mergeJob, crawlDb);
	 FileSystem fs = new JobClient(getConf()).getFs();
	 fs.delete(tempDir);
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""Injector: done"");
	 }
 }",0,0,0,0
"public void prepend(final String string){
	add(0, string);
}",0,0,0,0
"public final void mRULE_STRING() throws RecognitionException {
	 try {
		 int _type = RULE_STRING;
		 int _channel = DEFAULT_TOKEN_CHANNEL;
		 {
			 int alt15=2;
			 int LA15_0 = input.LA(1);
			 if ( (LA15_0=='\""') ) {
				 alt15=1;
			 }
			 else if ( (LA15_0=='\'') ) {
				 alt15=2;
			 }
			 else {
				 NoViableAltException nvae = new NoViableAltException("""", 15, 0, input);
				 throw nvae;
			 }
			 switch (alt15) {
				 case 1 : {
					 match('\""');
					 loop11: do {
						 int alt11=3;
						 int LA11_0 = input.LA(1);
						 if ( (LA11_0=='\\') ) {
							 alt11=1;
						 }
						 else if ( ((LA11_0>='\u0000' && LA11_0<='!')||(LA11_0>='#' && LA11_0<='[')||(LA11_0>=']' && LA11_0<='\uFFFF')) ) {
							 alt11=2;
						 }
						 switch (alt11) {
							 case 1 : {
								 match('\\');
								 matchAny();
							 }
							 break;
							 case 2 : {
								 if ( (input.LA(1)>='\u0000' && input.LA(1)<='!')||(input.LA(1)>='#' && input.LA(1)<='[')||(input.LA(1)>=']' && input.LA(1)<='\uFFFF') ) {
									 input.consume();
								 }
								 else {
									 MismatchedSetException mse = new MismatchedSetException(null,input);
									 recover(mse);
									 throw mse;
								}
							 }
							 break;
							 default : break loop11;
						 }
					 }
					 while (true);
					 int alt12=2;
					 int LA12_0 = input.LA(1);
					 if ( (LA12_0=='\""') ) {
						 alt12=1;
					 }
					 switch (alt12) {
						 case 1 : {
							 match('\""');
						 }
						 break;
					 }
				 }
				 break;
				 case 2 : {
					 match('\'');
					 loop13: do {
						 int alt13=3;
						 int LA13_0 = input.LA(1);
						 if ( (LA13_0=='\\') ) {
							 alt13=1;
						 }
						 else if ( ((LA13_0>='\u0000' && LA13_0<='&')||(LA13_0>='(' && LA13_0<='[')||(LA13_0>=']' && LA13_0<='\uFFFF')) ) {
							 alt13=2;
						 }
						 switch (alt13) {
							 case 1 : {
								 match('\\');
								 matchAny();
							 }
							 break;
							 case 2 : {
								 if ( (input.LA(1)>='\u0000' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='[')||(input.LA(1)>=']' && input.LA(1)<='\uFFFF') ) {
									 input.consume();
								 }
								 else {
									 MismatchedSetException mse = new MismatchedSetException(null,input);
									 recover(mse);
									 throw mse;
								}
							 }
							 break;
							 default : break loop13;
						 }
					 }
					 while (true);
					 int alt14=2;
					 int LA14_0 = input.LA(1);
					 if ( (LA14_0=='\'') ) {
						 alt14=1;
					 }
					 switch (alt14) {
						 case 1 : {
							 match('\'');
						 }
						 break;
					 }
				 }
				 break;
			 }
		 }
		 state.type = _type;
		 state.channel = _channel;
	 }
	 finally {
	 }
 }",0,0,1,0
"public interface JsonSerializable extends org.eclipse.che.ide.dto.JsonSerializable {
	 JSONValue toJsonElement();
}",0,0,0,0
"public class StreamPumper implements Runnable {
	 private static final int SMALL_BUFFER_SIZE = 128;
	 private InputStream is;
	 private OutputStream os;
	 private volatile boolean finish;
	 private volatile boolean finished;
	 private boolean closeWhenExhausted;
	 private boolean autoflush = false;
	 private Exception exception = null;
	 private int bufferSize = SMALL_BUFFER_SIZE;
	 private boolean started = false;
	 public StreamPumper(InputStream is, OutputStream os, boolean closeWhenExhausted) {
		 this.is = is;
		 this.os = os;
		 this.closeWhenExhausted = closeWhenExhausted;
	 }
	 public StreamPumper(InputStream is, OutputStream os) {
		 this(is, os, false);
	 }
	 void setAutoflush(boolean autoflush) {
		 this.autoflush = autoflush;
	 }
	 public void run() {
		 synchronized (this) {
			 started = true;
		 }
		 finished = false;
		 finish = false;
		 final byte[] buf = new byte[bufferSize];
		 int length;
		 try {
			 while ((length = is.read(buf)) > 0 && !finish) {
				 os.write(buf, 0, length);
				 if (autoflush) {
					 os.flush();
				 }
			 }
			 os.flush();
		 }
		 catch (Exception e) {
			 synchronized (this) {
				 exception = e;
			 }
		 }
		 finally {
			 if (closeWhenExhausted) {
				 try {
					 os.close();
				 }
				 catch (IOException e) {
				 }
			 }
			 finished = true;
			 synchronized (this) {
				 notifyAll();
			 }
		 }
	 }
	 public boolean isFinished() {
		 return finished;
	 }
	 public synchronized void waitFor() throws InterruptedException {
		 while (!isFinished()) {
			 wait();
		 }
	 }
	 public synchronized void setBufferSize(int bufferSize) {
		 if (started) {
			 throw new IllegalStateException(""Cannot set buffer size on a running StreamPumper"");
		 }
		 this.bufferSize = bufferSize;
	 }
	 public synchronized int getBufferSize() {
		 return bufferSize;
	 }
	 public synchronized Exception getException() {
		 return exception;
	 }
	 synchronized void stop() {
		 finish = true;
		 notifyAll();
	 }
}",0,0,0,0
"public class UnorderedPartitionedKVWriter extends BaseUnorderedPartitionedKVWriter {
	 private static final Logger LOG = LoggerFactory.getLogger(UnorderedPartitionedKVWriter.class);
	 private static final int INT_SIZE = 4;
	 private static final int NUM_META = 3;
	 private static final int INDEX_KEYLEN = 0;
	 private static final int INDEX_VALLEN = 1;
	 private static final int INDEX_NEXT = 2;
	 private static final int META_SIZE = NUM_META * INT_SIZE;
	 private final static int APPROX_HEADER_LENGTH = 150;
	 private final String destNameTrimmed;
	 private final long availableMemory;
	 final WrappedBuffer[] buffers;
	 final BlockingQueue<WrappedBuffer> availableBuffers;
	 private final ByteArrayOutputStream baos;
	 private final NonSyncDataOutputStream dos;
	 WrappedBuffer currentBuffer;
	 private final FileSystem rfs;
	 final List<SpillInfo> spillInfoList = Collections.synchronizedList(new ArrayList<SpillInfo>());
	 private final ListeningExecutorService spillExecutor;
	 private final int[] numRecordsPerPartition;
	 private long localOutputRecordBytesCounter;
	 private long localOutputBytesWithOverheadCounter;
	 private long localOutputRecordsCounter;
	 private static final int NOTIFY_THRESHOLD = 1000;
	 private final long[] sizePerPartition;
	 private volatile long spilledSize = 0;
	 static final ThreadLocal<Deflater> deflater = new ThreadLocal<Deflater>() {
		 public Deflater initialValue() {
			 return TezCommonUtils.newBestCompressionDeflater();
		 }
		 public Deflater get() {
			 Deflater deflater = super.get();
			 deflater.reset();
			 return deflater;
		 }
	 }
	;
	 private final Semaphore availableSlots;
	 protected final TezCounter outputLargeRecordsCounter;
	 int numBuffers;
	 int sizePerBuffer;
	 int lastBufferSize;
	 int numInitializedBuffers;
	 int spillLimit;
	 private Throwable spillException;
	 private AtomicBoolean isShutdown = new AtomicBoolean(false);
	 final AtomicInteger numSpills = new AtomicInteger(0);
	 private final AtomicInteger pendingSpillCount = new AtomicInteger(0);
	 Path finalIndexPath;
	 Path finalOutPath;
	 private final IFile.Writer writer;
	 final boolean skipBuffers;
	 private final ReentrantLock spillLock = new ReentrantLock();
	 private final Condition spillInProgress = spillLock.newCondition();
	 private final boolean pipelinedShuffle;
	 private final boolean isFinalMergeEnabled;
	 private final List<Event> finalEvents;
	 final ReportPartitionStats reportPartitionStats;
	 private final long indexFileSizeEstimate;
	 private List<WrappedBuffer> filledBuffers = new ArrayList<>();
	 public UnorderedPartitionedKVWriter(OutputContext outputContext, Configuration conf, int numOutputs, long availableMemoryBytes) throws IOException {
		 super(outputContext, conf, numOutputs);
		 Preconditions.checkArgument(availableMemoryBytes >= 0, ""availableMemory should be >= 0 bytes"");
		 this.destNameTrimmed = TezUtilsInternal.cleanVertexName(outputContext.getDestinationVertexName());
		 boolean pipelinedShuffleConf = this.conf.getBoolean(TezRuntimeConfiguration .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED, TezRuntimeConfiguration .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED_DEFAULT);
		 this.isFinalMergeEnabled = conf.getBoolean( TezRuntimeConfiguration.TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT, TezRuntimeConfiguration.TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT_DEFAULT);
		 this.pipelinedShuffle = pipelinedShuffleConf && !isFinalMergeEnabled;
		 this.finalEvents = Lists.newLinkedList();
		 if (availableMemoryBytes == 0) {
			 Preconditions.checkArgument(((numPartitions == 1) && !pipelinedShuffle), ""availableMemory "" + ""can be set to 0 only when numPartitions=1 and "" + TezRuntimeConfiguration .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED + "" is disabled. current numPartitions="" + numPartitions + "", "" + TezRuntimeConfiguration.TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED + ""="" + pipelinedShuffle);
		 }
		 availableMemory = availableMemoryBytes;
		 int maxSingleBufferSizeBytes = conf.getInt( TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_MAX_PER_BUFFER_SIZE_BYTES, Integer.MAX_VALUE);
		 computeNumBuffersAndSize(maxSingleBufferSizeBytes);
		 availableBuffers = new LinkedBlockingQueue<WrappedBuffer>();
		 buffers = new WrappedBuffer[numBuffers];
		 buffers[0] = new WrappedBuffer(numOutputs, sizePerBuffer);
		 numInitializedBuffers = 1;
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(destNameTrimmed + "": "" + ""Initializing Buffer #"" + numInitializedBuffers + "" with size="" + sizePerBuffer);
		 }
		 currentBuffer = buffers[0];
		 baos = new ByteArrayOutputStream();
		 dos = new NonSyncDataOutputStream(baos);
		 keySerializer.open(dos);
		 valSerializer.open(dos);
		 rfs = ((LocalFileSystem) FileSystem.getLocal(this.conf)).getRaw();
		 int maxThreads = Math.max(2, numBuffers/2);
		 ExecutorService executor = new ThreadPoolExecutor(1, maxThreads, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), new ThreadFactoryBuilder() .setDaemon(true) .setNameFormat( ""UnorderedOutSpiller {
		"" + TezUtilsInternal.cleanVertexName( outputContext.getDestinationVertexName()) + ""}
		 #%d"") .build() );
		 availableSlots = new Semaphore(maxThreads - 1, true);
		 spillExecutor = MoreExecutors.listeningDecorator(executor);
		 numRecordsPerPartition = new int[numPartitions];
		 reportPartitionStats = ReportPartitionStats.fromString( conf.get(TezRuntimeConfiguration.TEZ_RUNTIME_REPORT_PARTITION_STATS, TezRuntimeConfiguration.TEZ_RUNTIME_REPORT_PARTITION_STATS_DEFAULT));
		 sizePerPartition = (reportPartitionStats.isEnabled()) ? new long[numPartitions] : null;
		 outputLargeRecordsCounter = outputContext.getCounters().findCounter( TaskCounter.OUTPUT_LARGE_RECORDS);
		 indexFileSizeEstimate = numPartitions * Constants.MAP_OUTPUT_INDEX_RECORD_LENGTH;
		 if (numPartitions == 1 && !pipelinedShuffle) {
			 finalOutPath = outputFileHandler.getOutputFileForWrite();
			 finalIndexPath = outputFileHandler.getOutputIndexFileForWrite(indexFileSizeEstimate);
			 skipBuffers = true;
			 writer = new IFile.Writer(conf, rfs, finalOutPath, keyClass, valClass, codec, outputRecordsCounter, outputRecordBytesCounter);
		 }
		 else {
			 skipBuffers = false;
			 writer = null;
		 }
		 LOG.info(destNameTrimmed + "": "" + ""numBuffers="" + numBuffers + "", sizePerBuffer="" + sizePerBuffer + "", skipBuffers="" + skipBuffers + "", numPartitions="" + numPartitions + "", availableMemory="" + availableMemory + "", maxSingleBufferSizeBytes="" + maxSingleBufferSizeBytes + "", pipelinedShuffle="" + pipelinedShuffle + "", isFinalMergeEnabled="" + isFinalMergeEnabled + "", numPartitions="" + numPartitions + "", reportPartitionStats="" + reportPartitionStats);
	 }
	 private static final int ALLOC_OVERHEAD = 64;
	 private void computeNumBuffersAndSize(int bufferLimit) {
		 numBuffers = (int)(availableMemory / bufferLimit);
		 if (numBuffers >= 2) {
			 sizePerBuffer = bufferLimit - ALLOC_OVERHEAD;
			 lastBufferSize = (int)(availableMemory % bufferLimit);
			 if (lastBufferSize > bufferLimit / 2) {
				 numBuffers += 1;
			 }
			 else {
				 if (lastBufferSize > 0) {
					 LOG.warn(""Underallocating memory. Unused memory size: {
					}
					."", lastBufferSize);
				 }
				 lastBufferSize = sizePerBuffer;
			 }
		 }
		 else {
			 numBuffers = 2;
			 if (availableMemory / numBuffers > Integer.MAX_VALUE) {
				 sizePerBuffer = Integer.MAX_VALUE;
			 }
			 else {
				 sizePerBuffer = (int)(availableMemory / numBuffers);
			 }
			 lastBufferSize = sizePerBuffer;
		 }
		 sizePerBuffer = sizePerBuffer - (sizePerBuffer % INT_SIZE);
		 lastBufferSize = lastBufferSize - (lastBufferSize % INT_SIZE);
		 int mergePercent = conf.getInt( TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_PARTITIONED_KVWRITER_BUFFER_MERGE_PERCENT, TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_PARTITIONED_KVWRITER_BUFFER_MERGE_PERCENT_DEFAULT);
		 spillLimit = numBuffers * mergePercent / 100;
		 if (spillLimit < 1) {
			 spillLimit = 1;
		 }
		 if (spillLimit > numBuffers) {
			 spillLimit = numBuffers;
		 }
	 }
	 public void write(Object key, Object value) throws IOException {
		 if (isShutdown.get()) {
			 throw new RuntimeException(""Writer already closed"");
		 }
		 if (spillException != null) {
			 throw new IOException(""Exception during spill"", new IOException(spillException));
		 }
		 if (skipBuffers) {
			 writer.append(key, value);
			 outputContext.notifyProgress();
		 }
		 else {
			 int partition = partitioner.getPartition(key, value, numPartitions);
			 write(key, value, partition);
		 }
	 }
	 private void write(Object key, Object value, int partition) throws IOException {
		 int mod = currentBuffer.nextPosition % INT_SIZE;
		 int metaSkip = mod == 0 ? 0 : (INT_SIZE - mod);
		 if ((currentBuffer.availableSize < (META_SIZE + metaSkip)) || (currentBuffer.full)) {
			 metaSkip = 0;
			 setupNextBuffer();
		 }
		 currentBuffer.nextPosition += metaSkip;
		 int metaStart = currentBuffer.nextPosition;
		 currentBuffer.availableSize -= (META_SIZE + metaSkip);
		 currentBuffer.nextPosition += META_SIZE;
		 keySerializer.serialize(key);
		 if (currentBuffer.full) {
			 if (metaStart == 0) {
				 currentBuffer.reset();
				 writeLargeRecord(key, value, partition);
				 return;
			 }
			 else {
				 setupNextBuffer();
				 write(key, value, partition);
				 return;
			 }
		 }
		 int valStart = currentBuffer.nextPosition;
		 valSerializer.serialize(value);
		 if (currentBuffer.full) {
			 if (metaStart == 0) {
				 currentBuffer.reset();
				 writeLargeRecord(key, value, partition);
				 return;
			 }
			 else {
				 setupNextBuffer();
				 write(key, value, partition);
				 return;
			 }
		 }
		 int metaIndex = metaStart / INT_SIZE;
		 int indexNext = currentBuffer.partitionPositions[partition];
		 currentBuffer.metaBuffer.put(metaIndex + INDEX_KEYLEN, (valStart - (metaStart + META_SIZE)));
		 currentBuffer.metaBuffer.put(metaIndex + INDEX_VALLEN, (currentBuffer.nextPosition - valStart));
		 currentBuffer.metaBuffer.put(metaIndex + INDEX_NEXT, indexNext);
		 currentBuffer.skipSize += metaSkip;
		 localOutputRecordBytesCounter += (currentBuffer.nextPosition - (metaStart + META_SIZE));
		 localOutputBytesWithOverheadCounter += ((currentBuffer.nextPosition - metaStart) + metaSkip);
		 localOutputRecordsCounter++;
		 if (localOutputRecordBytesCounter % NOTIFY_THRESHOLD == 0) {
			 updateTezCountersAndNotify();
		 }
		 currentBuffer.partitionPositions[partition] = metaStart;
		 currentBuffer.recordsPerPartition[partition]++;
		 currentBuffer.sizePerPartition[partition] += currentBuffer.nextPosition - (metaStart + META_SIZE);
		 currentBuffer.numRecords++;
	 }
	 private void updateTezCountersAndNotify() {
		 outputRecordBytesCounter.increment(localOutputRecordBytesCounter);
		 outputBytesWithOverheadCounter.increment(localOutputBytesWithOverheadCounter);
		 outputRecordsCounter.increment(localOutputRecordsCounter);
		 outputContext.notifyProgress();
		 localOutputRecordBytesCounter = 0;
		 localOutputBytesWithOverheadCounter = 0;
		 localOutputRecordsCounter = 0;
	 }
	 private void setupNextBuffer() throws IOException {
		 if (currentBuffer.numRecords == 0) {
			 currentBuffer.reset();
		 }
		 else {
			 final int filledBufferCount = filledBuffers.size();
			 if (LOG.isDebugEnabled() || (filledBufferCount % 10) == 0) {
				 LOG.info(destNameTrimmed + "": "" + ""Moving to next buffer. Total filled buffers: "" + filledBufferCount);
			 }
			 updateGlobalStats(currentBuffer);
			 filledBuffers.add(currentBuffer);
			 mayBeSpill(false);
			 currentBuffer = getNextAvailableBuffer();
			 mayBeSpill(false);
		 }
	 }
	 private void mayBeSpill(boolean shouldBlock) throws IOException {
		 if (filledBuffers.size() >= spillLimit) {
			 scheduleSpill(shouldBlock);
		 }
	 }
	 private boolean scheduleSpill(boolean block) throws IOException {
		 if (filledBuffers.isEmpty()) {
			 return false;
		 }
		 try {
			 if (block) {
				 availableSlots.acquire();
			 }
			 else {
				 if (!availableSlots.tryAcquire()) {
					 return false;
				 }
			 }
			 final int filledBufferCount = filledBuffers.size();
			 if (LOG.isDebugEnabled() || (filledBufferCount % 10) == 0) {
				 LOG.info(destNameTrimmed + "": triggering spill. filledBuffers.size="" + filledBufferCount);
			 }
			 pendingSpillCount.incrementAndGet();
			 int spillNumber = numSpills.getAndIncrement();
			 ListenableFuture<SpillResult> future = spillExecutor.submit(new SpillCallable( new ArrayList<WrappedBuffer>(filledBuffers), codec, spilledRecordsCounter, spillNumber));
			 filledBuffers.clear();
			 Futures.addCallback(future, new SpillCallback(spillNumber));
			 updateTezCountersAndNotify();
			 return true;
		 }
		 catch(InterruptedException ie) {
			 Thread.currentThread().interrupt();
		 }
		 return false;
	 }
	 private boolean reportPartitionStats() {
		 return (sizePerPartition != null);
	 }
	 private void updateGlobalStats(WrappedBuffer buffer) {
		 for (int i = 0;
		 i < numPartitions;
		 i++) {
			 numRecordsPerPartition[i] += buffer.recordsPerPartition[i];
			 if (reportPartitionStats()) {
				 sizePerPartition[i] += buffer.sizePerPartition[i];
			 }
		 }
	 }
	 private WrappedBuffer getNextAvailableBuffer() throws IOException {
		 if (availableBuffers.peek() == null) {
			 if (numInitializedBuffers < numBuffers) {
				 buffers[numInitializedBuffers] = new WrappedBuffer(numPartitions, numInitializedBuffers == numBuffers - 1 ? lastBufferSize : sizePerBuffer);
				 numInitializedBuffers++;
				 return buffers[numInitializedBuffers - 1];
			 }
			 else {
				 try {
					 mayBeSpill(true);
					 return availableBuffers.take();
				 }
				 catch (InterruptedException e) {
					 Thread.currentThread().interrupt();
					 throw new IOInterruptedException(""Interrupted while waiting for next buffer"", e);
				 }
			 }
		 }
		 else {
			 return availableBuffers.poll();
		 }
	 }
	 private class SpillCallable extends CallableWithNdc<SpillResult> {
		 private final List<WrappedBuffer> filledBuffers;
		 private final CompressionCodec codec;
		 private final TezCounter numRecordsCounter;
		 private int spillIndex;
		 private SpillPathDetails spillPathDetails;
		 private int spillNumber;
		 public SpillCallable(List<WrappedBuffer> filledBuffers, CompressionCodec codec, TezCounter numRecordsCounter, SpillPathDetails spillPathDetails) {
			 this(filledBuffers, codec, numRecordsCounter, spillPathDetails.spillIndex);
			 Preconditions.checkArgument(spillPathDetails.outputFilePath != null, ""Spill output file "" + ""path can not be null"");
			 this.spillPathDetails = spillPathDetails;
		 }
		 public SpillCallable(List<WrappedBuffer> filledBuffers, CompressionCodec codec, TezCounter numRecordsCounter, int spillNumber) {
			 this.filledBuffers = filledBuffers;
			 this.codec = codec;
			 this.numRecordsCounter = numRecordsCounter;
			 this.spillNumber = spillNumber;
		 }
		 protected SpillResult callInternal() throws IOException {
			 SpillResult spillResult = null;
			 if (spillPathDetails == null) {
				 this.spillPathDetails = getSpillPathDetails(false, -1, spillNumber);
				 this.spillIndex = spillPathDetails.spillIndex;
			 }
			 LOG.info(""Writing spill "" + spillNumber + "" to "" + spillPathDetails.outputFilePath.toString());
			 FSDataOutputStream out = rfs.create(spillPathDetails.outputFilePath);
			 if (!SPILL_FILE_PERMS.equals(SPILL_FILE_PERMS.applyUMask(FsPermission.getUMask(conf)))) {
				 rfs.setPermission(spillPathDetails.outputFilePath, SPILL_FILE_PERMS);
			 }
			 TezSpillRecord spillRecord = new TezSpillRecord(numPartitions);
			 DataInputBuffer key = new DataInputBuffer();
			 DataInputBuffer val = new DataInputBuffer();
			 long compressedLength = 0;
			 for (int i = 0;
			 i < numPartitions;
			 i++) {
				 IFile.Writer writer = null;
				 try {
					 long segmentStart = out.getPos();
					 long numRecords = 0;
					 for (WrappedBuffer buffer : filledBuffers) {
						 outputContext.notifyProgress();
						 if (buffer.partitionPositions[i] == WrappedBuffer.PARTITION_ABSENT_POSITION) {
							 continue;
						 }
						 if (writer == null) {
							 writer = new Writer(conf, out, keyClass, valClass, codec, null, null);
						 }
						 numRecords += writePartition(buffer.partitionPositions[i], buffer, writer, key, val);
					 }
					 if (writer != null) {
						 if (numRecordsCounter != null) {
							 synchronized (numRecordsCounter) {
								 numRecordsCounter.increment(numRecords);
							 }
						 }
						 writer.close();
						 compressedLength += writer.getCompressedLength();
						 TezIndexRecord indexRecord = new TezIndexRecord(segmentStart, writer.getRawLength(), writer.getCompressedLength());
						 spillRecord.putIndex(indexRecord, i);
						 writer = null;
					 }
				 }
				 finally {
					 if (writer != null) {
						 writer.close();
					 }
				 }
			 }
			 key.close();
			 val.close();
			 spillResult = new SpillResult(compressedLength, this.filledBuffers);
			 handleSpillIndex(spillPathDetails, spillRecord);
			 LOG.info(destNameTrimmed + "": "" + ""Finished spill "" + spillIndex);
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(destNameTrimmed + "": "" + ""Spill="" + spillIndex + "", indexPath="" + spillPathDetails.indexFilePath + "", outputPath="" + spillPathDetails.outputFilePath);
			 }
			 return spillResult;
		 }
	 }
	 private long writePartition(int pos, WrappedBuffer wrappedBuffer, Writer writer, DataInputBuffer keyBuffer, DataInputBuffer valBuffer) throws IOException {
		 long numRecords = 0;
		 while (pos != WrappedBuffer.PARTITION_ABSENT_POSITION) {
			 int metaIndex = pos / INT_SIZE;
			 int keyLength = wrappedBuffer.metaBuffer.get(metaIndex + INDEX_KEYLEN);
			 int valLength = wrappedBuffer.metaBuffer.get(metaIndex + INDEX_VALLEN);
			 keyBuffer.reset(wrappedBuffer.buffer, pos + META_SIZE, keyLength);
			 valBuffer.reset(wrappedBuffer.buffer, pos + META_SIZE + keyLength, valLength);
			 writer.append(keyBuffer, valBuffer);
			 numRecords++;
			 pos = wrappedBuffer.metaBuffer.get(metaIndex + INDEX_NEXT);
		 }
		 return numRecords;
	 }
	 public static long getInitialMemoryRequirement(Configuration conf, long maxAvailableTaskMemory) {
		 long initialMemRequestMb = conf.getInt( TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB, TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB_DEFAULT);
		 Preconditions.checkArgument(initialMemRequestMb != 0, TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB + "" should be larger than 0"");
		 long reqBytes = initialMemRequestMb << 20;
		 LOG.info(""Requested BufferSize ("" + TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_BUFFER_SIZE_MB + "") : "" + initialMemRequestMb);
		 return reqBytes;
	 }
	 public List<Event> close() throws IOException, InterruptedException {
		 scheduleSpill(true);
		 List<Event> eventList = Lists.newLinkedList();
		 isShutdown.set(true);
		 spillLock.lock();
		 try {
			 LOG.info(destNameTrimmed + "": "" + ""Waiting for all spills to complete : Pending : "" + pendingSpillCount.get());
			 while (pendingSpillCount.get() != 0 && spillException == null) {
				 spillInProgress.await();
			 }
		 }
		 finally {
			 spillLock.unlock();
		 }
		 if (spillException != null) {
			 LOG.error(destNameTrimmed + "": "" + ""Error during spill, throwing"");
			 cleanup();
			 currentBuffer.cleanup();
			 currentBuffer = null;
			 if (spillException instanceof IOException) {
				 throw (IOException) spillException;
			 }
			 else {
				 throw new IOException(spillException);
			 }
		 }
		 else {
			 LOG.info(destNameTrimmed + "": "" + ""All spills complete"");
			 cleanup();
			 List<Event> events = Lists.newLinkedList();
			 if (!pipelinedShuffle) {
				 if (skipBuffers) {
					 writer.close();
					 long rawLen = writer.getRawLength();
					 long compLen = writer.getCompressedLength();
					 TezIndexRecord rec = new TezIndexRecord(0, rawLen, compLen);
					 TezSpillRecord sr = new TezSpillRecord(1);
					 sr.putIndex(rec, 0);
					 sr.writeToFile(finalIndexPath, conf);
					 BitSet emptyPartitions = new BitSet();
					 if (outputRecordsCounter.getValue() == 0) {
						 emptyPartitions.set(0);
					 }
					 if (reportPartitionStats()) {
						 if (outputRecordsCounter.getValue() > 0) {
							 sizePerPartition[0] = rawLen;
						 }
					 }
					 cleanupCurrentBuffer();
					 if (outputRecordsCounter.getValue() > 0) {
						 outputBytesWithOverheadCounter.increment(rawLen);
						 fileOutputBytesCounter.increment(compLen + indexFileSizeEstimate);
					 }
					 eventList.add(generateVMEvent());
					 eventList.add(generateDMEvent(false, -1, false, outputContext .getUniqueIdentifier(), emptyPartitions));
					 return eventList;
				 }
				 if (isFinalMergeEnabled) {
					 if (numSpills.get() > 0) {
						 mergeAll();
					 }
					 else {
						 finalSpill();
					 }
					 updateTezCountersAndNotify();
					 eventList.add(generateVMEvent());
					 eventList.add(generateDMEvent());
				 }
				 else {
					 SpillResult result = finalSpill();
					 if (result != null) {
						 updateTezCountersAndNotify();
						 finalEvents.add(generateVMEvent());
						 int spillNum = numSpills.get() - 1;
						 SpillCallback callback = new SpillCallback(spillNum);
						 callback.computePartitionStats(result);
						 BitSet emptyPartitions = getEmptyPartitions(callback.getRecordsPerPartition());
						 String pathComponent = generatePathComponent(outputContext.getUniqueIdentifier(), spillNum);
						 Event finalEvent = generateDMEvent(true, spillNum, true, pathComponent, emptyPartitions);
						 finalEvents.add(finalEvent);
					 }
					 eventList.addAll(finalEvents);
				 }
				 cleanupCurrentBuffer();
				 return eventList;
			 }
			 if (finalSpill() != null) {
				 mayBeSendEventsForSpill(currentBuffer.recordsPerPartition, sizePerPartition, numSpills.get() - 1, true);
			 }
			 updateTezCountersAndNotify();
			 cleanupCurrentBuffer();
			 return events;
		 }
	 }
	 private BitSet getEmptyPartitions(int[] recordsPerPartition) {
		 Preconditions.checkArgument(recordsPerPartition != null, ""records per partition can not be null"");
		 BitSet emptyPartitions = new BitSet();
		 for (int i = 0;
		 i < numPartitions;
		 i++) {
			 if (recordsPerPartition[i] == 0 ) {
				 emptyPartitions.set(i);
			 }
		 }
		 return emptyPartitions;
	 }
	 public boolean reportDetailedPartitionStats() {
		 return reportPartitionStats.isPrecise();
	 }
	 private Event generateVMEvent() throws IOException {
		 return ShuffleUtils.generateVMEvent(outputContext, this.sizePerPartition, this.reportDetailedPartitionStats(), deflater.get());
	 }
	 private Event generateDMEvent() throws IOException {
		 BitSet emptyPartitions = getEmptyPartitions(numRecordsPerPartition);
		 return generateDMEvent(false, -1, false, outputContext.getUniqueIdentifier(), emptyPartitions);
	 }
	 private Event generateDMEvent(boolean addSpillDetails, int spillId, boolean isLastSpill, String pathComponent, BitSet emptyPartitions) throws IOException {
		 outputContext.notifyProgress();
		 DataMovementEventPayloadProto.Builder payloadBuilder = DataMovementEventPayloadProto .newBuilder();
		 String host = getHost();
		 if (emptyPartitions.cardinality() != 0) {
			 ByteString emptyPartitionsByteString = TezCommonUtils.compressByteArrayToByteString(TezUtilsInternal.toByteArray (emptyPartitions), deflater.get());
			 payloadBuilder.setEmptyPartitions(emptyPartitionsByteString);
		 }
		 if (emptyPartitions.cardinality() != numPartitions) {
			 payloadBuilder.setHost(host);
			 payloadBuilder.setPort(getShufflePort());
			 payloadBuilder.setPathComponent(pathComponent);
		 }
		 if (addSpillDetails) {
			 payloadBuilder.setSpillId(spillId);
			 payloadBuilder.setLastEvent(isLastSpill);
		 }
		 ByteBuffer payload = payloadBuilder.build().toByteString().asReadOnlyByteBuffer();
		 return CompositeDataMovementEvent.create(0, numPartitions, payload);
	 }
	 private void cleanupCurrentBuffer() {
		 currentBuffer.cleanup();
		 currentBuffer = null;
	 }
	 private void cleanup() {
		 if (spillExecutor != null) {
			 spillExecutor.shutdownNow();
		 }
		 for (int i = 0;
		 i < buffers.length;
		 i++) {
			 if (buffers[i] != null && buffers[i] != currentBuffer) {
				 buffers[i].cleanup();
				 buffers[i] = null;
			 }
		 }
		 availableBuffers.clear();
	 }
	 private SpillResult finalSpill() throws IOException {
		 if (currentBuffer.nextPosition == 0) {
			 if (pipelinedShuffle || !isFinalMergeEnabled) {
				 List<Event> eventList = Lists.newLinkedList();
				 eventList.add(ShuffleUtils.generateVMEvent(outputContext, reportPartitionStats() ? new long[numPartitions] : null, reportDetailedPartitionStats(), deflater.get()));
				 if (localOutputRecordsCounter == 0 && outputLargeRecordsCounter.getValue() == 0) {
					 BitSet emptyPartitions = new BitSet(numPartitions);
					 emptyPartitions.flip(0, numPartitions);
					 eventList.add(generateDMEvent(true, numSpills.get(), true, null, emptyPartitions));
				 }
				 if (pipelinedShuffle) {
					 outputContext.sendEvents(eventList);
				 }
				 else if (!isFinalMergeEnabled) {
					 finalEvents.addAll(0, eventList);
				 }
			 }
			 return null;
		 }
		 else {
			 updateGlobalStats(currentBuffer);
			 filledBuffers.add(currentBuffer);
			 SpillPathDetails spillPathDetails = getSpillPathDetails(true, -1);
			 SpillCallable spillCallable = new SpillCallable(filledBuffers, codec, null, spillPathDetails);
			 try {
				 SpillResult spillResult = spillCallable.call();
				 fileOutputBytesCounter.increment(spillResult.spillSize);
				 fileOutputBytesCounter.increment(indexFileSizeEstimate);
				 return spillResult;
			 }
			 catch (Exception ex) {
				 throw (ex instanceof IOException) ? (IOException)ex : new IOException(ex);
			 }
		 }
	 }
	 private SpillPathDetails getSpillPathDetails(boolean isFinalSpill, long expectedSpillSize) throws IOException {
		 int spillNumber = numSpills.getAndIncrement();
		 return getSpillPathDetails(isFinalSpill, expectedSpillSize, spillNumber);
	 }
	 private SpillPathDetails getSpillPathDetails(boolean isFinalSpill, long expectedSpillSize, int spillNumber) throws IOException {
		 long spillSize = (expectedSpillSize < 0) ? (currentBuffer.nextPosition + numPartitions * APPROX_HEADER_LENGTH) : expectedSpillSize;
		 Path outputFilePath = null;
		 Path indexFilePath = null;
		 if (!pipelinedShuffle && isFinalMergeEnabled) {
			 if (isFinalSpill) {
				 outputFilePath = outputFileHandler.getOutputFileForWrite(spillSize);
				 indexFilePath = outputFileHandler.getOutputIndexFileForWrite(indexFileSizeEstimate);
				 finalOutPath = outputFilePath;
				 finalIndexPath = indexFilePath;
			 }
			 else {
				 outputFilePath = outputFileHandler.getSpillFileForWrite(spillNumber, spillSize);
			 }
		 }
		 else {
			 outputFilePath = outputFileHandler.getSpillFileForWrite(spillNumber, spillSize);
			 indexFilePath = outputFileHandler.getSpillIndexFileForWrite(spillNumber, indexFileSizeEstimate);
		 }
		 return new SpillPathDetails(outputFilePath, indexFilePath, spillNumber);
	 }
	 private void mergeAll() throws IOException {
		 long expectedSize = spilledSize;
		 if (currentBuffer.nextPosition != 0) {
			 expectedSize += currentBuffer.nextPosition - (currentBuffer.numRecords * META_SIZE) - currentBuffer.skipSize + numPartitions * APPROX_HEADER_LENGTH;
			 updateGlobalStats(currentBuffer);
		 }
		 SpillPathDetails spillPathDetails = getSpillPathDetails(true, expectedSize);
		 finalIndexPath = spillPathDetails.indexFilePath;
		 finalOutPath = spillPathDetails.outputFilePath;
		 TezSpillRecord finalSpillRecord = new TezSpillRecord(numPartitions);
		 DataInputBuffer keyBuffer = new DataInputBuffer();
		 DataInputBuffer valBuffer = new DataInputBuffer();
		 DataInputBuffer keyBufferIFile = new DataInputBuffer();
		 DataInputBuffer valBufferIFile = new DataInputBuffer();
		 FSDataOutputStream out = null;
		 try {
			 out = rfs.create(finalOutPath);
			 if (!SPILL_FILE_PERMS.equals(SPILL_FILE_PERMS.applyUMask(FsPermission.getUMask(conf)))) {
				 rfs.setPermission(finalOutPath, SPILL_FILE_PERMS);
			 }
			 Writer writer = null;
			 for (int i = 0;
			 i < numPartitions;
			 i++) {
				 long segmentStart = out.getPos();
				 if (numRecordsPerPartition[i] == 0) {
					 LOG.info(destNameTrimmed + "": "" + ""Skipping partition: "" + i + "" in final merge since it has no records"");
					 continue;
				 }
				 writer = new Writer(conf, out, keyClass, valClass, codec, null, null);
				 try {
					 if (currentBuffer.nextPosition != 0 && currentBuffer.partitionPositions[i] != WrappedBuffer.PARTITION_ABSENT_POSITION) {
						 writePartition(currentBuffer.partitionPositions[i], currentBuffer, writer, keyBuffer, valBuffer);
					 }
					 synchronized (spillInfoList) {
						 for (SpillInfo spillInfo : spillInfoList) {
							 TezIndexRecord indexRecord = spillInfo.spillRecord.getIndex(i);
							 if (indexRecord.getPartLength() == 0) {
								 continue;
							 }
							 FSDataInputStream in = rfs.open(spillInfo.outPath);
							 in.seek(indexRecord.getStartOffset());
							 IFile.Reader reader = new IFile.Reader(in, indexRecord.getPartLength(), codec, null, additionalSpillBytesReadCounter, ifileReadAhead, ifileReadAheadLength, ifileBufferSize);
							 while (reader.nextRawKey(keyBufferIFile)) {
								 reader.nextRawValue(valBufferIFile);
								 writer.append(keyBufferIFile, valBufferIFile);
							 }
							 reader.close();
						 }
					 }
					 writer.close();
					 fileOutputBytesCounter.increment(writer.getCompressedLength());
					 TezIndexRecord indexRecord = new TezIndexRecord(segmentStart, writer.getRawLength(), writer.getCompressedLength());
					 writer = null;
					 finalSpillRecord.putIndex(indexRecord, i);
					 outputContext.notifyProgress();
				 }
				 finally {
					 if (writer != null) {
						 writer.close();
					 }
				 }
			 }
		 }
		 finally {
			 if (out != null) {
				 out.close();
			 }
			 deleteIntermediateSpills();
		 }
		 finalSpillRecord.writeToFile(finalIndexPath, conf);
		 fileOutputBytesCounter.increment(indexFileSizeEstimate);
		 LOG.info(destNameTrimmed + "": "" + ""Finished final spill after merging : "" + numSpills.get() + "" spills"");
	 }
	 private void deleteIntermediateSpills() {
		 synchronized (spillInfoList) {
			 for (SpillInfo spill : spillInfoList) {
				 try {
					 rfs.delete(spill.outPath, false);
				 }
				 catch (IOException e) {
					 LOG.warn(""Unable to delete intermediate spill "" + spill.outPath, e);
				 }
			 }
		 }
	 }
	 private void writeLargeRecord(final Object key, final Object value, final int partition) throws IOException {
		 numAdditionalSpillsCounter.increment(1);
		 long size = sizePerBuffer - (currentBuffer.numRecords * META_SIZE) - currentBuffer.skipSize + numPartitions * APPROX_HEADER_LENGTH;
		 SpillPathDetails spillPathDetails = getSpillPathDetails(false, size);
		 int spillIndex = spillPathDetails.spillIndex;
		 FSDataOutputStream out = null;
		 long outSize = 0;
		 try {
			 final TezSpillRecord spillRecord = new TezSpillRecord(numPartitions);
			 final Path outPath = spillPathDetails.outputFilePath;
			 out = rfs.create(outPath);
			 if (!SPILL_FILE_PERMS.equals(SPILL_FILE_PERMS.applyUMask(FsPermission.getUMask(conf)))) {
				 rfs.setPermission(outPath, SPILL_FILE_PERMS);
			 }
			 BitSet emptyPartitions = null;
			 if (pipelinedShuffle || !isFinalMergeEnabled) {
				 emptyPartitions = new BitSet(numPartitions);
			 }
			 for (int i = 0;
			 i < numPartitions;
			 i++) {
				 final long recordStart = out.getPos();
				 if (i == partition) {
					 spilledRecordsCounter.increment(1);
					 Writer writer = null;
					 try {
						 writer = new IFile.Writer(conf, out, keyClass, valClass, codec, null, null);
						 writer.append(key, value);
						 outputLargeRecordsCounter.increment(1);
						 numRecordsPerPartition[i]++;
						 if (reportPartitionStats()) {
							 sizePerPartition[i] += writer.getRawLength();
						 }
						 writer.close();
						 synchronized (additionalSpillBytesWritternCounter) {
							 additionalSpillBytesWritternCounter.increment(writer.getCompressedLength());
						 }
						 TezIndexRecord indexRecord = new TezIndexRecord(recordStart, writer.getRawLength(), writer.getCompressedLength());
						 spillRecord.putIndex(indexRecord, i);
						 outSize = writer.getCompressedLength();
						 writer = null;
					 }
					 finally {
						 if (writer != null) {
							 writer.close();
						 }
					 }
				 }
				 else {
					 if (emptyPartitions != null) {
						 emptyPartitions.set(i);
					 }
				 }
			 }
			 handleSpillIndex(spillPathDetails, spillRecord);
			 mayBeSendEventsForSpill(emptyPartitions, sizePerPartition, spillIndex, false);
			 LOG.info(destNameTrimmed + "": "" + ""Finished writing large record of size "" + outSize + "" to spill file "" + spillIndex);
			 if (LOG.isDebugEnabled()) {
				 LOG.debug(destNameTrimmed + "": "" + ""LargeRecord Spill="" + spillIndex + "", indexPath="" + spillPathDetails.indexFilePath + "", outputPath="" + spillPathDetails.outputFilePath);
			 }
		 }
		 finally {
			 if (out != null) {
				 out.close();
			 }
		 }
	 }
	 private void handleSpillIndex(SpillPathDetails spillPathDetails, TezSpillRecord spillRecord) throws IOException {
		 if (spillPathDetails.indexFilePath != null) {
			 spillRecord.writeToFile(spillPathDetails.indexFilePath, conf);
		 }
		 else {
			 SpillInfo spillInfo = new SpillInfo(spillRecord, spillPathDetails.outputFilePath);
			 spillInfoList.add(spillInfo);
			 numAdditionalSpillsCounter.increment(1);
		 }
	 }
	 private class ByteArrayOutputStream extends OutputStream {
		 private final byte[] scratch = new byte[1];
		 public void write(int v) throws IOException {
			 scratch[0] = (byte) v;
			 write(scratch, 0, 1);
		 }
		 public void write(byte[] b, int off, int len) throws IOException {
			 if (currentBuffer.full) {
			 }
			 else if (len > currentBuffer.availableSize) {
				 currentBuffer.full = true;
			 }
			 else {
				 System.arraycopy(b, off, currentBuffer.buffer, currentBuffer.nextPosition, len);
				 currentBuffer.nextPosition += len;
				 currentBuffer.availableSize -= len;
			 }
		 }
	 }
	 private static class WrappedBuffer {
		 private static final int PARTITION_ABSENT_POSITION = -1;
		 private final int[] partitionPositions;
		 private final int[] recordsPerPartition;
		 private final long[] sizePerPartition;
		 private final int numPartitions;
		 private final int size;
		 private byte[] buffer;
		 private IntBuffer metaBuffer;
		 private int numRecords = 0;
		 private int skipSize = 0;
		 private int nextPosition = 0;
		 private int availableSize;
		 private boolean full = false;
		 WrappedBuffer(int numPartitions, int size) {
			 this.partitionPositions = new int[numPartitions];
			 this.recordsPerPartition = new int[numPartitions];
			 this.sizePerPartition = new long[numPartitions];
			 this.numPartitions = numPartitions;
			 for (int i = 0;
			 i < numPartitions;
			 i++) {
				 this.partitionPositions[i] = PARTITION_ABSENT_POSITION;
				 this.recordsPerPartition[i] = 0;
				 this.sizePerPartition[i] = 0;
			 }
			 size = size - (size % INT_SIZE);
			 this.size = size;
			 this.buffer = new byte[size];
			 this.metaBuffer = ByteBuffer.wrap(buffer).order(ByteOrder.nativeOrder()).asIntBuffer();
			 availableSize = size;
		 }
		 void reset() {
			 for (int i = 0;
			 i < numPartitions;
			 i++) {
				 this.partitionPositions[i] = PARTITION_ABSENT_POSITION;
				 this.recordsPerPartition[i] = 0;
				 this.sizePerPartition[i] = 0;
			 }
			 numRecords = 0;
			 nextPosition = 0;
			 skipSize = 0;
			 availableSize = size;
			 full = false;
		 }
		 void cleanup() {
			 buffer = null;
			 metaBuffer = null;
		 }
	 }
	 private String generatePathComponent(String uniqueId, int spillNumber) {
		 return (uniqueId + ""_"" + spillNumber);
	 }
	 private List<Event> generateEventForSpill(BitSet emptyPartitions, long[] sizePerPartition, int spillNumber, boolean isFinalUpdate) throws IOException {
		 List<Event> eventList = Lists.newLinkedList();
		 String pathComponent = generatePathComponent(outputContext.getUniqueIdentifier(), spillNumber);
		 if (isFinalUpdate) {
			 eventList.add(ShuffleUtils.generateVMEvent(outputContext, sizePerPartition, reportDetailedPartitionStats(), deflater.get()));
		 }
		 Event compEvent = generateDMEvent(true, spillNumber, isFinalUpdate, pathComponent, emptyPartitions);
		 eventList.add(compEvent);
		 return eventList;
	 }
	 private void mayBeSendEventsForSpill( BitSet emptyPartitions, long[] sizePerPartition, int spillNumber, boolean isFinalUpdate) {
		 if (!pipelinedShuffle) {
			 if (isFinalMergeEnabled) {
				 return;
			 }
		 }
		 List<Event> events = null;
		 try {
			 events = generateEventForSpill(emptyPartitions, sizePerPartition, spillNumber, isFinalUpdate);
			 LOG.info(destNameTrimmed + "": "" + ""Adding spill event for spill"" + "" (final update="" + isFinalUpdate + ""), spillId="" + spillNumber);
			 if (pipelinedShuffle) {
				 outputContext.sendEvents(events);
			 }
			 else if (!isFinalMergeEnabled) {
				 this.finalEvents.addAll(events);
			 }
		 }
		 catch (IOException e) {
			 LOG.error(destNameTrimmed + "": "" + ""Error in sending pipelined events"", e);
			 outputContext.reportFailure(TaskFailureType.NON_FATAL, e, ""Error in sending events."");
		 }
	 }
	 private void mayBeSendEventsForSpill(int[] recordsPerPartition, long[] sizePerPartition, int spillNumber, boolean isFinalUpdate) {
		 BitSet emptyPartitions = getEmptyPartitions(recordsPerPartition);
		 mayBeSendEventsForSpill(emptyPartitions, sizePerPartition, spillNumber, isFinalUpdate);
	 }
	 private class SpillCallback implements FutureCallback<SpillResult> {
		 private final int spillNumber;
		 private int recordsPerPartition[];
		 private long sizePerPartition[];
		 SpillCallback(int spillNumber) {
			 this.spillNumber = spillNumber;
		 }
		 void computePartitionStats(SpillResult result) {
			 if (result.filledBuffers.size() == 1) {
				 recordsPerPartition = result.filledBuffers.get(0).recordsPerPartition;
				 sizePerPartition = result.filledBuffers.get(0).sizePerPartition;
			 }
			 else {
				 recordsPerPartition = new int[numPartitions];
				 sizePerPartition = new long[numPartitions];
				 for (WrappedBuffer buffer : result.filledBuffers) {
					 for (int i = 0;
					 i < numPartitions;
					 ++i) {
						 recordsPerPartition[i] += buffer.recordsPerPartition[i];
						 sizePerPartition[i] += buffer.sizePerPartition[i];
					 }
				 }
			 }
		 }
		 int[] getRecordsPerPartition() {
			 return recordsPerPartition;
		 }
		 public void onSuccess(SpillResult result) {
			 synchronized (UnorderedPartitionedKVWriter.this) {
				 spilledSize += result.spillSize;
			 }
			 computePartitionStats(result);
			 mayBeSendEventsForSpill(recordsPerPartition, sizePerPartition, spillNumber, false);
			 try {
				 for (WrappedBuffer buffer : result.filledBuffers) {
					 buffer.reset();
					 availableBuffers.add(buffer);
				 }
			 }
			 catch (Throwable e) {
				 LOG.error(destNameTrimmed + "": Failure while attempting to reset buffer after spill"", e);
				 outputContext.reportFailure(TaskFailureType.NON_FATAL, e, ""Failure while attempting to reset buffer after spill"");
			 }
			 if (!pipelinedShuffle && isFinalMergeEnabled) {
				 synchronized(additionalSpillBytesWritternCounter) {
					 additionalSpillBytesWritternCounter.increment(result.spillSize);
				 }
			 }
			 else {
				 synchronized(fileOutputBytesCounter) {
					 fileOutputBytesCounter.increment(indexFileSizeEstimate);
					 fileOutputBytesCounter.increment(result.spillSize);
				 }
			 }
			 spillLock.lock();
			 try {
				 if (pendingSpillCount.decrementAndGet() == 0) {
					 spillInProgress.signal();
				 }
			 }
			 finally {
				 spillLock.unlock();
				 availableSlots.release();
			 }
		 }
		 public void onFailure(Throwable t) {
			 LOG.error(destNameTrimmed + "": "" + ""Failure while spilling to disk"", t);
			 spillException = t;
			 outputContext.reportFailure(TaskFailureType.NON_FATAL, t, ""Failure while spilling to disk"");
			 spillLock.lock();
			 try {
				 spillInProgress.signal();
			 }
			 finally {
				 spillLock.unlock();
				 availableSlots.release();
			 }
		 }
	 }
	 private static class SpillResult {
		 final long spillSize;
		 final List<WrappedBuffer> filledBuffers;
		 SpillResult(long size, List<WrappedBuffer> filledBuffers) {
			 this.spillSize = size;
			 this.filledBuffers = filledBuffers;
		 }
	 }
	 static class SpillInfo {
		 final TezSpillRecord spillRecord;
		 final Path outPath;
		 SpillInfo(TezSpillRecord spillRecord, Path outPath) {
			 this.spillRecord = spillRecord;
			 this.outPath = outPath;
		 }
	 }
	 String getHost() {
		 return outputContext.getExecutionContext().getHostName();
	 }
	 int getShufflePort() throws IOException {
		 String auxiliaryService = conf.get(TezConfiguration.TEZ_AM_SHUFFLE_AUXILIARY_SERVICE_ID, TezConfiguration.TEZ_AM_SHUFFLE_AUXILIARY_SERVICE_ID_DEFAULT);
		 ByteBuffer shuffleMetadata = outputContext .getServiceProviderMetaData(auxiliaryService);
		 int shufflePort = ShuffleUtils.deserializeShuffleProviderMetaData(shuffleMetadata);
		 return shufflePort;
	 }
	 static class SpillPathDetails {
		 final Path indexFilePath;
		 final Path outputFilePath;
		 final int spillIndex;
		 SpillPathDetails(Path outputFilePath, Path indexFilePath, int spillIndex) {
			 this.outputFilePath = outputFilePath;
			 this.indexFilePath = indexFilePath;
			 this.spillIndex = spillIndex;
		 }
	 }
}",1,1,0,0
"public class DistributedFileSystem extends FileSystem {
	 private Path workingDir = new Path(""/user"", System.getProperty(""user.name""));
	 private String name;
	 private FileSystem localFs;
	 DFSClient dfs;
	 public DistributedFileSystem(InetSocketAddress namenode, Configuration conf) throws IOException {
		 super(conf);
		 this.dfs = new DFSClient(namenode, conf);
		 this.name = namenode.getHostName() + "":"" + namenode.getPort();
		 this.localFs = getNamed(""local"", conf);
	 }
	 public String getName() {
		 return name;
	 }
	 public Path getWorkingDirectory() {
		 return workingDir;
	 }
	 private Path makeAbsolute(Path f) {
		 if (f.isAbsolute()) {
			 return f;
		 }
		 else {
			 return new Path(workingDir, f);
		 }
	 }
	 public void setWorkingDirectory(Path dir) {
		 workingDir = makeAbsolute(dir);
	 }
	 private UTF8 getPath(Path file) {
		 return new UTF8(makeAbsolute(file).toString());
	 }
	 public String[][] getFileCacheHints(Path f, long start, long len) throws IOException {
		 return dfs.getHints(getPath(f), start, len);
	 }
	 public FSInputStream openRaw(Path f) throws IOException {
		 return dfs.open(getPath(f));
	 }
	 public FSOutputStream createRaw(Path f, boolean overwrite, short replication) throws IOException {
		 return dfs.create(getPath(f), overwrite, replication);
	 }
	 public boolean setReplicationRaw( Path src, short replication ) throws IOException {
		 return dfs.setReplication(getPath(src), replication);
	 }
	 public boolean renameRaw(Path src, Path dst) throws IOException {
		 return dfs.rename(getPath(src), getPath(dst));
	 }
	 public boolean deleteRaw(Path f) throws IOException {
		 return dfs.delete(getPath(f));
	 }
	 public boolean exists(Path f) throws IOException {
		 return dfs.exists(getPath(f));
	 }
	 public boolean isDirectory(Path f) throws IOException {
		 if (f instanceof DfsPath) {
			 return ((DfsPath)f).isDirectory();
		 }
		 return dfs.isDirectory(getPath(f));
	 }
	 public long getLength(Path f) throws IOException {
		 if (f instanceof DfsPath) {
			 return ((DfsPath)f).length();
		 }
		 DFSFileInfo info[] = dfs.listPaths(getPath(f));
		 return info[0].getLen();
	 }
	 public short getReplication(Path f) throws IOException {
		 if (f instanceof DfsPath) {
			 return ((DfsPath)f).getReplication();
		 }
		 DFSFileInfo info[] = dfs.listPaths(getPath(f));
		 return info[0].getReplication();
	 }
	 public Path[] listPathsRaw(Path f) throws IOException {
		 DFSFileInfo info[] = dfs.listPaths(getPath(f));
		 if (info == null) {
			 return new Path[0];
		 }
		 else {
			 Path results[] = new DfsPath[info.length];
			 for (int i = 0;
			 i < info.length;
			 i++) {
				 results[i] = new DfsPath(info[i]);
			 }
			 return results;
		 }
	 }
	 public boolean mkdirs(Path f) throws IOException {
		 return dfs.mkdirs(getPath(f));
	 }
	 public void lock(Path f, boolean shared) throws IOException {
		 dfs.lock(getPath(f), ! shared);
	 }
	 public void release(Path f) throws IOException {
		 dfs.release(getPath(f));
	 }
	 public void moveFromLocalFile(Path src, Path dst) throws IOException {
		 FileUtil.copy(localFs, src, this, dst, true, getConf());
	 }
	 public void copyFromLocalFile(Path src, Path dst) throws IOException {
		 FileUtil.copy(localFs, src, this, dst, false, getConf());
	 }
	 public void copyToLocalFile(Path src, Path dst) throws IOException {
		 FileUtil.copy(this, src, localFs, dst, false, getConf());
	 }
	 public Path startLocalOutput(Path fsOutputFile, Path tmpLocalFile) throws IOException {
		 return tmpLocalFile;
	 }
	 public void completeLocalOutput(Path fsOutputFile, Path tmpLocalFile) throws IOException {
		 moveFromLocalFile(tmpLocalFile, fsOutputFile);
	 }
	 public void close() throws IOException {
		 dfs.close();
	 }
	 public String toString() {
		 return ""DFS["" + dfs + ""]"";
	 }
	 DFSClient getClient() {
		 return dfs;
	 }
	 public void reportChecksumFailure(Path f, FSInputStream in, long start, long length, int crc) {
	 }
	 public long getBlockSize() {
		 return FSConstants.BLOCK_SIZE;
	 }
	 public long getRawCapacity() throws IOException{
		 return dfs.totalRawCapacity();
	 }
	 public long getRawUsed() throws IOException{
		 return dfs.totalRawUsed();
	 }
	 public long getUsed()throws IOException{
		 long used = 0;
		 DFSFileInfo dfsFiles[] = dfs.listPaths(getPath(new Path(""/"")));
		 for(int i=0;
		i<dfsFiles.length;
		i++){
			 used += dfsFiles[i].getContentsLen();
		 }
		 return used;
	 }
	 public DataNodeReport[] getDataNodeStats() throws IOException {
		 DatanodeInfo[] dnReport = dfs.datanodeReport();
		 DataNodeReport[] reports = new DataNodeReport[dnReport.length];
		 for (int i = 0;
		 i < dnReport.length;
		 i++) {
			 reports[i] = new DataNodeReport();
			 reports[i].name = dnReport[i].getName().toString();
			 reports[i].host = dnReport[i].getHost().toString();
			 reports[i].capacity = dnReport[i].getCapacity();
			 reports[i].remaining = dnReport[i].getRemaining();
			 reports[i].lastUpdate = dnReport[i].lastUpdate();
		 }
		 return reports;
	 }
}",0,0,0,0
"public void endTestSuite(JUnitTest suite) throws BuildException {
	 rootElement.setAttribute(ATTR_TESTS, """" + suite.runCount());
	 rootElement.setAttribute(ATTR_FAILURES, """" + suite.failureCount());
	 rootElement.setAttribute(ATTR_ERRORS, """" + suite.errorCount());
	 rootElement.setAttribute( ATTR_TIME, """" + (suite.getRunTime() / ONE_SECOND));
	 if (out != null) {
		 Writer wri = null;
		 try {
			 wri = new BufferedWriter(new OutputStreamWriter(out, ""UTF8""));
			 wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n"");
			 (new DOMElementWriter()).write(rootElement, wri, 0, "" "");
		 }
		 catch (IOException exc) {
			 throw new BuildException(""Unable to write log file"", exc);
		 }
		 finally {
			 if (wri != null) {
				 try {
					 wri.flush();
				 }
				 catch (IOException ex) {
				 }
			 }
			 if (out != System.out && out != System.err) {
				 FileUtils.close(wri);
			 }
		 }
	 }
 }",0,0,0,0
"public static File getSerializedRowCachePath(String ksName, String cfName) {
	 return new File(conf.saved_caches_directory + File.separator + ksName + ""-"" + cfName + ""-RowCache"");
 }",0,0,0,0
"public class CBZip2OutputStream extends OutputStream implements BZip2Constants {
	 public static final int MIN_BLOCKSIZE = 1;
	 public static final int MAX_BLOCKSIZE = 9;
	 protected static final int SETMASK = (1 << 21);
	 protected static final int CLEARMASK = (~SETMASK);
	 protected static final int GREATER_ICOST = 15;
	 protected static final int LESSER_ICOST = 0;
	 protected static final int SMALL_THRESH = 20;
	 protected static final int DEPTH_THRESH = 10;
	 protected static final int WORK_FACTOR = 30;
	 protected static final int QSORT_STACK_SIZE = 1000;
	 private static final int[] INCS = {
	 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }
	;
	 protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) {
		 final int[] heap = new int[MAX_ALPHA_SIZE * 2];
		 final int[] weight = new int[MAX_ALPHA_SIZE * 2];
		 final int[] parent = new int[MAX_ALPHA_SIZE * 2];
		 for (int i = alphaSize;
		 --i >= 0;
		) {
			 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
		 }
		 for (boolean tooLong = true;
		 tooLong;
		) {
			 tooLong = false;
			 int nNodes = alphaSize;
			 int nHeap = 0;
			 heap[0] = 0;
			 weight[0] = 0;
			 parent[0] = -2;
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 parent[i] = -1;
				 nHeap++;
				 heap[nHeap] = i;
				 int zz = nHeap;
				 int tmp = heap[zz];
				 while (weight[tmp] < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 while (nHeap > 1) {
				 int n1 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 int yy = 0;
				 int zz = 1;
				 int tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 int n2 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 yy = 0;
				 zz = 1;
				 tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 nNodes++;
				 parent[n1] = parent[n2] = nNodes;
				 final int weight_n1 = weight[n1];
				 final int weight_n2 = weight[n2];
				 weight[nNodes] = (((weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)) | (1 + (((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)) ? (weight_n1 & 0x000000ff) : (weight_n2 & 0x000000ff))));
				 parent[nNodes] = -1;
				 nHeap++;
				 heap[nHeap] = nNodes;
				 tmp = 0;
				 zz = nHeap;
				 tmp = heap[zz];
				 final int weight_tmp = weight[tmp];
				 while (weight_tmp < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 int j = 0;
				 int k = i;
				 for (int parent_k;
				 (parent_k = parent[k]) >= 0;
				) {
					 k = parent_k;
					 j++;
				 }
				 len[i - 1] = (char) j;
				 if (j > maxLen) {
					 tooLong = true;
				 }
			 }
			 if (tooLong) {
				 for (int i = 1;
				 i < alphaSize;
				 i++) {
					 int j = weight[i] >> 8;
					 j = 1 + (j >> 1);
					 weight[i] = j << 8;
				 }
			 }
		 }
	 }
	 private static void hbMakeCodeLengths(final byte[] len, final int[] freq, final Data dat, final int alphaSize, final int maxLen) {
		 final int[] heap = dat.heap;
		 final int[] weight = dat.weight;
		 final int[] parent = dat.parent;
		 for (int i = alphaSize;
		 --i >= 0;
		) {
			 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
		 }
		 for (boolean tooLong = true;
		 tooLong;
		) {
			 tooLong = false;
			 int nNodes = alphaSize;
			 int nHeap = 0;
			 heap[0] = 0;
			 weight[0] = 0;
			 parent[0] = -2;
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 parent[i] = -1;
				 nHeap++;
				 heap[nHeap] = i;
				 int zz = nHeap;
				 int tmp = heap[zz];
				 while (weight[tmp] < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 while (nHeap > 1) {
				 int n1 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 int yy = 0;
				 int zz = 1;
				 int tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 int n2 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 yy = 0;
				 zz = 1;
				 tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 nNodes++;
				 parent[n1] = parent[n2] = nNodes;
				 final int weight_n1 = weight[n1];
				 final int weight_n2 = weight[n2];
				 weight[nNodes] = ((weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)) | (1 + (((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)) ? (weight_n1 & 0x000000ff) : (weight_n2 & 0x000000ff)));
				 parent[nNodes] = -1;
				 nHeap++;
				 heap[nHeap] = nNodes;
				 tmp = 0;
				 zz = nHeap;
				 tmp = heap[zz];
				 final int weight_tmp = weight[tmp];
				 while (weight_tmp < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 int j = 0;
				 int k = i;
				 for (int parent_k;
				 (parent_k = parent[k]) >= 0;
				) {
					 k = parent_k;
					 j++;
				 }
				 len[i - 1] = (byte) j;
				 if (j > maxLen) {
					 tooLong = true;
				 }
			 }
			 if (tooLong) {
				 for (int i = 1;
				 i < alphaSize;
				 i++) {
					 int j = weight[i] >> 8;
					 j = 1 + (j >> 1);
					 weight[i] = j << 8;
				 }
			 }
		 }
	 }
	 private int last;
	 private int origPtr;
	 private final int blockSize100k;
	 private boolean blockRandomised;
	 private int bsBuff;
	 private int bsLive;
	 private final CRC crc = new CRC();
	 private int nInUse;
	 private int nMTF;
	 private int workDone;
	 private int workLimit;
	 private boolean firstAttempt;
	 private int currentChar = -1;
	 private int runLength = 0;
	 private int blockCRC;
	 private int combinedCRC;
	 private int allowableBlockSize;
	 private CBZip2OutputStream.Data data;
	 private OutputStream out;
	 public static int chooseBlockSize(long inputLength) {
		 return (inputLength > 0) ? (int) Math.min((inputLength / 132000) + 1, 9) : MAX_BLOCKSIZE;
	 }
	 public CBZip2OutputStream(final OutputStream out) throws IOException {
		 this(out, MAX_BLOCKSIZE);
	 }
	 public CBZip2OutputStream(final OutputStream out, final int blockSize) throws IOException {
		 super();
		 if (blockSize < 1) {
			 throw new IllegalArgumentException(""blockSize("" + blockSize + "") < 1"");
		 }
		 if (blockSize > 9) {
			 throw new IllegalArgumentException(""blockSize("" + blockSize + "") > 9"");
		 }
		 this.blockSize100k = blockSize;
		 this.out = out;
		 init();
	 }
	 public void write(final int b) throws IOException {
		 if (this.out != null) {
			 write0(b);
		 }
		 else {
			 throw new IOException(""closed"");
		 }
	 }
	 private void writeRun() throws IOException {
		 final int lastShadow = this.last;
		 if (lastShadow < this.allowableBlockSize) {
			 final int currentCharShadow = this.currentChar;
			 final Data dataShadow = this.data;
			 dataShadow.inUse[currentCharShadow] = true;
			 final byte ch = (byte) currentCharShadow;
			 int runLengthShadow = this.runLength;
			 this.crc.updateCRC(currentCharShadow, runLengthShadow);
			 switch (runLengthShadow) {
				 case 1: dataShadow.block[lastShadow + 2] = ch;
				 this.last = lastShadow + 1;
				 break;
				 case 2: dataShadow.block[lastShadow + 2] = ch;
				 dataShadow.block[lastShadow + 3] = ch;
				 this.last = lastShadow + 2;
				 break;
				 case 3: {
					 final byte[] block = dataShadow.block;
					 block[lastShadow + 2] = ch;
					 block[lastShadow + 3] = ch;
					 block[lastShadow + 4] = ch;
					 this.last = lastShadow + 3;
				 }
				 break;
				 default: {
					 runLengthShadow -= 4;
					 dataShadow.inUse[runLengthShadow] = true;
					 final byte[] block = dataShadow.block;
					 block[lastShadow + 2] = ch;
					 block[lastShadow + 3] = ch;
					 block[lastShadow + 4] = ch;
					 block[lastShadow + 5] = ch;
					 block[lastShadow + 6] = (byte) runLengthShadow;
					 this.last = lastShadow + 5;
				 }
				 break;
			 }
		 }
		 else {
			 endBlock();
			 initBlock();
			 writeRun();
		 }
	 }
	 protected void finalize() throws Throwable {
		 close();
		 super.finalize();
	 }
	 public void close() throws IOException {
		 OutputStream outShadow = this.out;
		 if (outShadow != null) {
			 try {
				 if (this.runLength > 0) {
					 writeRun();
				 }
				 this.currentChar = -1;
				 endBlock();
				 endCompression();
				 outShadow.close();
			 }
			 finally {
				 this.out = null;
				 this.data = null;
			 }
		 }
	 }
	 public void flush() throws IOException {
		 OutputStream outShadow = this.out;
		 if (outShadow != null) {
			 outShadow.flush();
		 }
	 }
	 private void init() throws IOException {
		 this.data = new Data(this.blockSize100k);
		 bsPutUByte('h');
		 bsPutUByte('0' + this.blockSize100k);
		 this.combinedCRC = 0;
		 initBlock();
	 }
	 private void initBlock() {
		 this.crc.initialiseCRC();
		 this.last = -1;
		 boolean[] inUse = this.data.inUse;
		 for (int i = 256;
		 --i >= 0;
		) {
			 inUse[i] = false;
		 }
		 this.allowableBlockSize = (this.blockSize100k * BZip2Constants.baseBlockSize) - 20;
	 }
	 private void endBlock() throws IOException {
		 this.blockCRC = this.crc.getFinalCRC();
		 this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);
		 this.combinedCRC ^= this.blockCRC;
		 if (this.last == -1) {
			 return;
		 }
		 blockSort();
		 bsPutUByte(0x31);
		 bsPutUByte(0x41);
		 bsPutUByte(0x59);
		 bsPutUByte(0x26);
		 bsPutUByte(0x53);
		 bsPutUByte(0x59);
		 bsPutInt(this.blockCRC);
		 if (this.blockRandomised) {
			 bsW(1, 1);
		 }
		 else {
			 bsW(1, 0);
		 }
		 moveToFrontCodeAndSend();
	 }
	 private void endCompression() throws IOException {
		 bsPutUByte(0x17);
		 bsPutUByte(0x72);
		 bsPutUByte(0x45);
		 bsPutUByte(0x38);
		 bsPutUByte(0x50);
		 bsPutUByte(0x90);
		 bsPutInt(this.combinedCRC);
		 bsFinishedWithStream();
	 }
	 public final int getBlockSize() {
		 return this.blockSize100k;
	 }
	 public void write(final byte[] buf, int offs, final int len) throws IOException {
		 if (offs < 0) {
			 throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
		 }
		 if (len < 0) {
			 throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
		 }
		 if (offs + len > buf.length) {
			 throw new IndexOutOfBoundsException(""offs("" + offs + "") + len("" + len + "") > buf.length("" + buf.length + "")."");
		 }
		 if (this.out == null) {
			 throw new IOException(""stream closed"");
		 }
		 for (int hi = offs + len;
		 offs < hi;
		) {
			 write0(buf[offs++]);
		 }
	 }
	 private void write0(int b) throws IOException {
		 if (this.currentChar != -1) {
			 b &= 0xff;
			 if (this.currentChar == b) {
				 if (++this.runLength > 254) {
					 writeRun();
					 this.currentChar = -1;
					 this.runLength = 0;
				 }
			 }
			 else {
				 writeRun();
				 this.runLength = 1;
				 this.currentChar = b;
			 }
		 }
		 else {
			 this.currentChar = b & 0xff;
			 this.runLength++;
		 }
	 }
	 private static void hbAssignCodes(final int[] code, final byte[] length, final int minLen, final int maxLen, final int alphaSize) {
		 int vec = 0;
		 for (int n = minLen;
		 n <= maxLen;
		 n++) {
			 for (int i = 0;
			 i < alphaSize;
			 i++) {
				 if ((length[i] & 0xff) == n) {
					 code[i] = vec;
					 vec++;
				 }
			 }
			 vec <<= 1;
		 }
	 }
	 private void bsFinishedWithStream() throws IOException {
		 while (this.bsLive > 0) {
			 int ch = this.bsBuff >> 24;
			 this.out.write(ch);
			 this.bsBuff <<= 8;
			 this.bsLive -= 8;
		 }
	 }
	 private void bsW(final int n, final int v) throws IOException {
		 final OutputStream outShadow = this.out;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 while (bsLiveShadow >= 8) {
			 outShadow.write(bsBuffShadow >> 24);
			 bsBuffShadow <<= 8;
			 bsLiveShadow -= 8;
		 }
		 this.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));
		 this.bsLive = bsLiveShadow + n;
	 }
	 private void bsPutUByte(final int c) throws IOException {
		 bsW(8, c);
	 }
	 private void bsPutInt(final int u) throws IOException {
		 bsW(8, (u >> 24) & 0xff);
		 bsW(8, (u >> 16) & 0xff);
		 bsW(8, (u >> 8) & 0xff);
		 bsW(8, u & 0xff);
	 }
	 private void sendMTFValues() throws IOException {
		 final byte[][] len = this.data.sendMTFValues_len;
		 final int alphaSize = this.nInUse + 2;
		 for (int t = N_GROUPS;
		 --t >= 0;
		) {
			 byte[] len_t = len[t];
			 for (int v = alphaSize;
			 --v >= 0;
			) {
				 len_t[v] = GREATER_ICOST;
			 }
		 }
		 final int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3 : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
		 sendMTFValues0(nGroups, alphaSize);
		 final int nSelectors = sendMTFValues1(nGroups, alphaSize);
		 sendMTFValues2(nGroups, nSelectors);
		 sendMTFValues3(nGroups, alphaSize);
		 sendMTFValues4();
		 sendMTFValues5(nGroups, nSelectors);
		 sendMTFValues6(nGroups, alphaSize);
		 sendMTFValues7(nSelectors);
	 }
	 private void sendMTFValues0(final int nGroups, final int alphaSize) {
		 final byte[][] len = this.data.sendMTFValues_len;
		 final int[] mtfFreq = this.data.mtfFreq;
		 int remF = this.nMTF;
		 int gs = 0;
		 for (int nPart = nGroups;
		 nPart > 0;
		 nPart--) {
			 final int tFreq = remF / nPart;
			 int ge = gs - 1;
			 int aFreq = 0;
			 for (final int a = alphaSize - 1;
			 (aFreq < tFreq) && (ge < a);
			) {
				 aFreq += mtfFreq[++ge];
			 }
			 if ((ge > gs) && (nPart != nGroups) && (nPart != 1) && (((nGroups - nPart) & 1) != 0)) {
				 aFreq -= mtfFreq[ge--];
			 }
			 final byte[] len_np = len[nPart - 1];
			 for (int v = alphaSize;
			 --v >= 0;
			) {
				 if ((v >= gs) && (v <= ge)) {
					 len_np[v] = LESSER_ICOST;
				 }
				 else {
					 len_np[v] = GREATER_ICOST;
				 }
			 }
			 gs = ge + 1;
			 remF -= aFreq;
		 }
	 }
	 private int sendMTFValues1(final int nGroups, final int alphaSize) {
		 final Data dataShadow = this.data;
		 final int[][] rfreq = dataShadow.sendMTFValues_rfreq;
		 final int[] fave = dataShadow.sendMTFValues_fave;
		 final short[] cost = dataShadow.sendMTFValues_cost;
		 final char[] sfmap = dataShadow.sfmap;
		 final byte[] selector = dataShadow.selector;
		 final byte[][] len = dataShadow.sendMTFValues_len;
		 final byte[] len_0 = len[0];
		 final byte[] len_1 = len[1];
		 final byte[] len_2 = len[2];
		 final byte[] len_3 = len[3];
		 final byte[] len_4 = len[4];
		 final byte[] len_5 = len[5];
		 final int nMTFShadow = this.nMTF;
		 int nSelectors = 0;
		 for (int iter = 0;
		 iter < N_ITERS;
		 iter++) {
			 for (int t = nGroups;
			 --t >= 0;
			) {
				 fave[t] = 0;
				 int[] rfreqt = rfreq[t];
				 for (int i = alphaSize;
				 --i >= 0;
				) {
					 rfreqt[i] = 0;
				 }
			 }
			 nSelectors = 0;
			 for (int gs = 0;
			 gs < this.nMTF;
			) {
				 final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
				 if (nGroups == N_GROUPS) {
					 short cost0 = 0;
					 short cost1 = 0;
					 short cost2 = 0;
					 short cost3 = 0;
					 short cost4 = 0;
					 short cost5 = 0;
					 for (int i = gs;
					 i <= ge;
					 i++) {
						 final int icv = sfmap[i];
						 cost0 += len_0[icv] & 0xff;
						 cost1 += len_1[icv] & 0xff;
						 cost2 += len_2[icv] & 0xff;
						 cost3 += len_3[icv] & 0xff;
						 cost4 += len_4[icv] & 0xff;
						 cost5 += len_5[icv] & 0xff;
					 }
					 cost[0] = cost0;
					 cost[1] = cost1;
					 cost[2] = cost2;
					 cost[3] = cost3;
					 cost[4] = cost4;
					 cost[5] = cost5;
				 }
				 else {
					 for (int t = nGroups;
					 --t >= 0;
					) {
						 cost[t] = 0;
					 }
					 for (int i = gs;
					 i <= ge;
					 i++) {
						 final int icv = sfmap[i];
						 for (int t = nGroups;
						 --t >= 0;
						) {
							 cost[t] += len[t][icv] & 0xff;
						 }
					 }
				 }
				 int bt = -1;
				 for (int t = nGroups, bc = 999999999;
				 --t >= 0;
				) {
					 final int cost_t = cost[t];
					 if (cost_t < bc) {
						 bc = cost_t;
						 bt = t;
					 }
				 }
				 fave[bt]++;
				 selector[nSelectors] = (byte) bt;
				 nSelectors++;
				 final int[] rfreq_bt = rfreq[bt];
				 for (int i = gs;
				 i <= ge;
				 i++) {
					 rfreq_bt[sfmap[i]]++;
				 }
				 gs = ge + 1;
			 }
			 for (int t = 0;
			 t < nGroups;
			 t++) {
				 hbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);
			 }
		 }
		 return nSelectors;
	 }
	 private void sendMTFValues2(final int nGroups, final int nSelectors) {
		 final Data dataShadow = this.data;
		 byte[] pos = dataShadow.sendMTFValues2_pos;
		 for (int i = nGroups;
		 --i >= 0;
		) {
			 pos[i] = (byte) i;
		 }
		 for (int i = 0;
		 i < nSelectors;
		 i++) {
			 final byte ll_i = dataShadow.selector[i];
			 byte tmp = pos[0];
			 int j = 0;
			 while (ll_i != tmp) {
				 j++;
				 byte tmp2 = tmp;
				 tmp = pos[j];
				 pos[j] = tmp2;
			 }
			 pos[0] = tmp;
			 dataShadow.selectorMtf[i] = (byte) j;
		 }
	 }
	 private void sendMTFValues3(final int nGroups, final int alphaSize) {
		 int[][] code = this.data.sendMTFValues_code;
		 byte[][] len = this.data.sendMTFValues_len;
		 for (int t = 0;
		 t < nGroups;
		 t++) {
			 int minLen = 32;
			 int maxLen = 0;
			 final byte[] len_t = len[t];
			 for (int i = alphaSize;
			 --i >= 0;
			) {
				 final int l = len_t[i] & 0xff;
				 if (l > maxLen) {
					 maxLen = l;
				 }
				 if (l < minLen) {
					 minLen = l;
				 }
			 }
			 hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);
		 }
	 }
	 private void sendMTFValues4() throws IOException {
		 final boolean[] inUse = this.data.inUse;
		 final boolean[] inUse16 = this.data.sentMTFValues4_inUse16;
		 for (int i = 16;
		 --i >= 0;
		) {
			 inUse16[i] = false;
			 final int i16 = i * 16;
			 for (int j = 16;
			 --j >= 0;
			) {
				 if (inUse[i16 + j]) {
					 inUse16[i] = true;
				 }
			 }
		 }
		 for (int i = 0;
		 i < 16;
		 i++) {
			 bsW(1, inUse16[i] ? 1 : 0);
		 }
		 final OutputStream outShadow = this.out;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int i = 0;
		 i < 16;
		 i++) {
			 if (inUse16[i]) {
				 final int i16 = i * 16;
				 for (int j = 0;
				 j < 16;
				 j++) {
					 while (bsLiveShadow >= 8) {
						 outShadow.write(bsBuffShadow >> 24);
						 bsBuffShadow <<= 8;
						 bsLiveShadow -= 8;
					 }
					 if (inUse[i16 + j]) {
						 bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
					 }
					 bsLiveShadow++;
				 }
			 }
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void sendMTFValues5(final int nGroups, final int nSelectors) throws IOException {
		 bsW(3, nGroups);
		 bsW(15, nSelectors);
		 final OutputStream outShadow = this.out;
		 final byte[] selectorMtf = this.data.selectorMtf;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int i = 0;
		 i < nSelectors;
		 i++) {
			 for (int j = 0, hj = selectorMtf[i] & 0xff;
			 j < hj;
			 j++) {
				 while (bsLiveShadow >= 8) {
					 outShadow.write(bsBuffShadow >> 24);
					 bsBuffShadow <<= 8;
					 bsLiveShadow -= 8;
				 }
				 bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
				 bsLiveShadow++;
			 }
			 while (bsLiveShadow >= 8) {
				 outShadow.write(bsBuffShadow >> 24);
				 bsBuffShadow <<= 8;
				 bsLiveShadow -= 8;
			 }
			 bsLiveShadow++;
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void sendMTFValues6(final int nGroups, final int alphaSize) throws IOException {
		 final byte[][] len = this.data.sendMTFValues_len;
		 final OutputStream outShadow = this.out;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int t = 0;
		 t < nGroups;
		 t++) {
			 byte[] len_t = len[t];
			 int curr = len_t[0] & 0xff;
			 while (bsLiveShadow >= 8) {
				 outShadow.write(bsBuffShadow >> 24);
				 bsBuffShadow <<= 8;
				 bsLiveShadow -= 8;
			 }
			 bsBuffShadow |= curr << (32 - bsLiveShadow - 5);
			 bsLiveShadow += 5;
			 for (int i = 0;
			 i < alphaSize;
			 i++) {
				 int lti = len_t[i] & 0xff;
				 while (curr < lti) {
					 while (bsLiveShadow >= 8) {
						 outShadow.write(bsBuffShadow >> 24);
						 bsBuffShadow <<= 8;
						 bsLiveShadow -= 8;
					 }
					 bsBuffShadow |= 2 << (32 - bsLiveShadow - 2);
					 bsLiveShadow += 2;
					 curr++;
				 }
				 while (curr > lti) {
					 while (bsLiveShadow >= 8) {
						 outShadow.write(bsBuffShadow >> 24);
						 bsBuffShadow <<= 8;
						 bsLiveShadow -= 8;
					 }
					 bsBuffShadow |= 3 << (32 - bsLiveShadow - 2);
					 bsLiveShadow += 2;
					 curr--;
				 }
				 while (bsLiveShadow >= 8) {
					 outShadow.write(bsBuffShadow >> 24);
					 bsBuffShadow <<= 8;
					 bsLiveShadow -= 8;
				 }
				 bsLiveShadow++;
			 }
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void sendMTFValues7(final int nSelectors) throws IOException {
		 final Data dataShadow = this.data;
		 final byte[][] len = dataShadow.sendMTFValues_len;
		 final int[][] code = dataShadow.sendMTFValues_code;
		 final OutputStream outShadow = this.out;
		 final byte[] selector = dataShadow.selector;
		 final char[] sfmap = dataShadow.sfmap;
		 final int nMTFShadow = this.nMTF;
		 int selCtr = 0;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int gs = 0;
		 gs < nMTFShadow;
		) {
			 final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
			 final int selector_selCtr = selector[selCtr] & 0xff;
			 final int[] code_selCtr = code[selector_selCtr];
			 final byte[] len_selCtr = len[selector_selCtr];
			 while (gs <= ge) {
				 final int sfmap_i = sfmap[gs];
				 while (bsLiveShadow >= 8) {
					 outShadow.write(bsBuffShadow >> 24);
					 bsBuffShadow <<= 8;
					 bsLiveShadow -= 8;
				 }
				 final int n = len_selCtr[sfmap_i] & 0xFF;
				 bsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);
				 bsLiveShadow += n;
				 gs++;
			 }
			 gs = ge + 1;
			 selCtr++;
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void moveToFrontCodeAndSend() throws IOException {
		 bsW(24, this.origPtr);
		 generateMTFValues();
		 sendMTFValues();
	 }
	 private boolean mainSimpleSort(final Data dataShadow, final int lo, final int hi, final int d) {
		 final int bigN = hi - lo + 1;
		 if (bigN < 2) {
			 return this.firstAttempt && (this.workDone > this.workLimit);
		 }
		 int hp = 0;
		 while (INCS[hp] < bigN) {
			 hp++;
		 }
		 final int[] fmap = dataShadow.fmap;
		 final char[] quadrant = dataShadow.quadrant;
		 final byte[] block = dataShadow.block;
		 final int lastShadow = this.last;
		 final int lastPlus1 = lastShadow + 1;
		 final boolean firstAttemptShadow = this.firstAttempt;
		 final int workLimitShadow = this.workLimit;
		 int workDoneShadow = this.workDone;
		 HP: while (--hp >= 0) {
			 final int h = INCS[hp];
			 final int mj = lo + h - 1;
			 for (int i = lo + h;
			 i <= hi;
			) {
				 for (int k = 3;
				 (i <= hi) && (--k >= 0);
				 i++) {
					 final int v = fmap[i];
					 final int vd = v + d;
					 int j = i;
					 boolean onceRunned = false;
					 int a = 0;
					 HAMMER: while (true) {
						 if (onceRunned) {
							 fmap[j] = a;
							 if ((j -= h) <= mj) {
								 break HAMMER;
							 }
						 }
						 else {
							 onceRunned = true;
						 }
						 a = fmap[j - h];
						 int i1 = a + d;
						 int i2 = vd;
						 if (block[i1 + 1] == block[i2 + 1]) {
							 if (block[i1 + 2] == block[i2 + 2]) {
								 if (block[i1 + 3] == block[i2 + 3]) {
									 if (block[i1 + 4] == block[i2 + 4]) {
										 if (block[i1 + 5] == block[i2 + 5]) {
											 if (block[(i1 += 6)] == block[(i2 += 6)]) {
												 int x = lastShadow;
												 X: while (x > 0) {
													 x -= 4;
													 if (block[i1 + 1] == block[i2 + 1]) {
														 if (quadrant[i1] == quadrant[i2]) {
															 if (block[i1 + 2] == block[i2 + 2]) {
																 if (quadrant[i1 + 1] == quadrant[i2 + 1]) {
																	 if (block[i1 + 3] == block[i2 + 3]) {
																		 if (quadrant[i1 + 2] == quadrant[i2 + 2]) {
																			 if (block[i1 + 4] == block[i2 + 4]) {
																				 if (quadrant[i1 + 3] == quadrant[i2 + 3]) {
																					 if ((i1 += 4) >= lastPlus1) {
																						 i1 -= lastPlus1;
																					 }
																					 if ((i2 += 4) >= lastPlus1) {
																						 i2 -= lastPlus1;
																					 }
																					 workDoneShadow++;
																					 continue X;
																				 }
																				 else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {
																					 continue HAMMER;
																				 }
																				 else {
																					 break HAMMER;
																				 }
																			 }
																			 else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
																				 continue HAMMER;
																			 }
																			 else {
																				 break HAMMER;
																			 }
																		 }
																		 else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {
																			 continue HAMMER;
																		 }
																		 else {
																			 break HAMMER;
																		 }
																	 }
																	 else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
																		 continue HAMMER;
																	 }
																	 else {
																		 break HAMMER;
																	 }
																 }
																 else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {
																	 continue HAMMER;
																 }
																 else {
																	 break HAMMER;
																 }
															 }
															 else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
																 continue HAMMER;
															 }
															 else {
																 break HAMMER;
															 }
														 }
														 else if ((quadrant[i1] > quadrant[i2])) {
															 continue HAMMER;
														 }
														 else {
															 break HAMMER;
														 }
													 }
													 else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
														 continue HAMMER;
													 }
													 else {
														 break HAMMER;
													 }
												 }
												 break HAMMER;
											 }
											 else {
												 if ((block[i1] & 0xff) > (block[i2] & 0xff)) {
													 continue HAMMER;
												 }
												 else {
													 break HAMMER;
												 }
											 }
										 }
										 else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {
											 continue HAMMER;
										 }
										 else {
											 break HAMMER;
										 }
									 }
									 else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
										 continue HAMMER;
									 }
									 else {
										 break HAMMER;
									 }
								 }
								 else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
									 continue HAMMER;
								 }
								 else {
									 break HAMMER;
								 }
							 }
							 else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
								 continue HAMMER;
							 }
							 else {
								 break HAMMER;
							 }
						 }
						 else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
							 continue HAMMER;
						 }
						 else {
							 break HAMMER;
						 }
					 }
					 fmap[j] = v;
				 }
				 if (firstAttemptShadow && (i <= hi) && (workDoneShadow > workLimitShadow)) {
					 break HP;
				 }
			 }
		 }
		 this.workDone = workDoneShadow;
		 return firstAttemptShadow && (workDoneShadow > workLimitShadow);
	 }
	 private static void vswap(int[] fmap, int p1, int p2, int n) {
		 n += p1;
		 while (p1 < n) {
			 int t = fmap[p1];
			 fmap[p1++] = fmap[p2];
			 fmap[p2++] = t;
		 }
	 }
	 private static byte med3(byte a, byte b, byte c) {
		 return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c : a);
	 }
	 private void blockSort() {
		 this.workLimit = WORK_FACTOR * this.last;
		 this.workDone = 0;
		 this.blockRandomised = false;
		 this.firstAttempt = true;
		 mainSort();
		 if (this.firstAttempt && (this.workDone > this.workLimit)) {
			 randomiseBlock();
			 this.workLimit = this.workDone = 0;
			 this.firstAttempt = false;
			 mainSort();
		 }
		 int[] fmap = this.data.fmap;
		 this.origPtr = -1;
		 for (int i = 0, lastShadow = this.last;
		 i <= lastShadow;
		 i++) {
			 if (fmap[i] == 0) {
				 this.origPtr = i;
				 break;
			 }
		 }
	 }
	 private void mainQSort3(final Data dataShadow, final int loSt, final int hiSt, final int dSt) {
		 final int[] stack_ll = dataShadow.stack_ll;
		 final int[] stack_hh = dataShadow.stack_hh;
		 final int[] stack_dd = dataShadow.stack_dd;
		 final int[] fmap = dataShadow.fmap;
		 final byte[] block = dataShadow.block;
		 stack_ll[0] = loSt;
		 stack_hh[0] = hiSt;
		 stack_dd[0] = dSt;
		 for (int sp = 1;
		 --sp >= 0;
		) {
			 final int lo = stack_ll[sp];
			 final int hi = stack_hh[sp];
			 final int d = stack_dd[sp];
			 if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {
				 if (mainSimpleSort(dataShadow, lo, hi, d)) {
					 return;
				 }
			 }
			 else {
				 final int d1 = d + 1;
				 final int med = med3(block[fmap[lo] + d1], block[fmap[hi ] + d1], block[fmap[(lo + hi) >> 1] + d1]) & 0xff;
				 int unLo = lo;
				 int unHi = hi;
				 int ltLo = lo;
				 int gtHi = hi;
				 while (true) {
					 while (unLo <= unHi) {
						 final int n = ((int) block[fmap[unLo] + d1] & 0xff) - med;
						 if (n == 0) {
							 final int temp = fmap[unLo];
							 fmap[unLo++] = fmap[ltLo];
							 fmap[ltLo++] = temp;
						 }
						 else if (n < 0) {
							 unLo++;
						 }
						 else {
							 break;
						 }
					 }
					 while (unLo <= unHi) {
						 final int n = ((int) block[fmap[unHi] + d1] & 0xff) - med;
						 if (n == 0) {
							 final int temp = fmap[unHi];
							 fmap[unHi--] = fmap[gtHi];
							 fmap[gtHi--] = temp;
						 }
						 else if (n > 0) {
							 unHi--;
						 }
						 else {
							 break;
						 }
					 }
					 if (unLo <= unHi) {
						 final int temp = fmap[unLo];
						 fmap[unLo++] = fmap[unHi];
						 fmap[unHi--] = temp;
					 }
					 else {
						 break;
					 }
				 }
				 if (gtHi < ltLo) {
					 stack_ll[sp] = lo;
					 stack_hh[sp] = hi;
					 stack_dd[sp] = d1;
					 sp++;
				 }
				 else {
					 int n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
					 vswap(fmap, lo, unLo - n, n);
					 int m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
					 vswap(fmap, unLo, hi - m + 1, m);
					 n = lo + unLo - ltLo - 1;
					 m = hi - (gtHi - unHi) + 1;
					 stack_ll[sp] = lo;
					 stack_hh[sp] = n;
					 stack_dd[sp] = d;
					 sp++;
					 stack_ll[sp] = n + 1;
					 stack_hh[sp] = m - 1;
					 stack_dd[sp] = d1;
					 sp++;
					 stack_ll[sp] = m;
					 stack_hh[sp] = hi;
					 stack_dd[sp] = d;
					 sp++;
				 }
			 }
		 }
	 }
	 private void mainSort() {
		 final Data dataShadow = this.data;
		 final int[] runningOrder = dataShadow.mainSort_runningOrder;
		 final int[] copy = dataShadow.mainSort_copy;
		 final boolean[] bigDone = dataShadow.mainSort_bigDone;
		 final int[] ftab = dataShadow.ftab;
		 final byte[] block = dataShadow.block;
		 final int[] fmap = dataShadow.fmap;
		 final char[] quadrant = dataShadow.quadrant;
		 final int lastShadow = this.last;
		 final int workLimitShadow = this.workLimit;
		 final boolean firstAttemptShadow = this.firstAttempt;
		 for (int i = 65537;
		 --i >= 0;
		) {
			 ftab[i] = 0;
		 }
		 for (int i = 0;
		 i < NUM_OVERSHOOT_BYTES;
		 i++) {
			 block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];
		 }
		 for (int i = lastShadow + NUM_OVERSHOOT_BYTES;
		 --i >= 0;
		) {
			 quadrant[i] = 0;
		 }
		 block[0] = block[lastShadow + 1];
		 int c1 = block[0] & 0xff;
		 for (int i = 0;
		 i <= lastShadow;
		 i++) {
			 final int c2 = block[i + 1] & 0xff;
			 ftab[(c1 << 8) + c2]++;
			 c1 = c2;
		 }
		 for (int i = 1;
		 i <= 65536;
		 i++) ftab[i] += ftab[i - 1];
		 c1 = block[1] & 0xff;
		 for (int i = 0;
		 i < lastShadow;
		 i++) {
			 final int c2 = block[i + 2] & 0xff;
			 fmap[--ftab[(c1 << 8) + c2]] = i;
			 c1 = c2;
		 }
		 fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;
		 for (int i = 256;
		 --i >= 0;
		) {
			 bigDone[i] = false;
			 runningOrder[i] = i;
		 }
		 for (int h = 364;
		 h != 1;
		) {
			 h /= 3;
			 for (int i = h;
			 i <= 255;
			 i++) {
				 final int vv = runningOrder[i];
				 final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
				 final int b = h - 1;
				 int j = i;
				 for (int ro = runningOrder[j - h];
				 (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a;
				 ro = runningOrder[j - h]) {
					 runningOrder[j] = ro;
					 j -= h;
					 if (j <= b) {
						 break;
					 }
				 }
				 runningOrder[j] = vv;
			 }
		 }
		 for (int i = 0;
		 i <= 255;
		 i++) {
			 final int ss = runningOrder[i];
			 for (int j = 0;
			 j <= 255;
			 j++) {
				 final int sb = (ss << 8) + j;
				 final int ftab_sb = ftab[sb];
				 if ((ftab_sb & SETMASK) != SETMASK) {
					 final int lo = ftab_sb & CLEARMASK;
					 final int hi = (ftab[sb + 1] & CLEARMASK) - 1;
					 if (hi > lo) {
						 mainQSort3(dataShadow, lo, hi, 2);
						 if (firstAttemptShadow && (this.workDone > workLimitShadow)) {
							 return;
						 }
					 }
					 ftab[sb] = ftab_sb | SETMASK;
				 }
			 }
			 for (int j = 0;
			 j <= 255;
			 j++) {
				 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
			 }
			 for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK);
			 j < hj;
			 j++) {
				 final int fmap_j = fmap[j];
				 c1 = block[fmap_j] & 0xff;
				 if (!bigDone[c1]) {
					 fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);
					 copy[c1]++;
				 }
			 }
			 for (int j = 256;
			 --j >= 0;
			) ftab[(j << 8) + ss] |= SETMASK;
			 bigDone[ss] = true;
			 if (i < 255) {
				 final int bbStart = ftab[ss << 8] & CLEARMASK;
				 final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
				 int shifts = 0;
				 while ((bbSize >> shifts) > 65534) {
					 shifts++;
				 }
				 for (int j = 0;
				 j < bbSize;
				 j++) {
					 final int a2update = fmap[bbStart + j];
					 final char qVal = (char) (j >> shifts);
					 quadrant[a2update] = qVal;
					 if (a2update < NUM_OVERSHOOT_BYTES) {
						 quadrant[a2update + lastShadow + 1] = qVal;
					 }
				 }
			 }
		 }
	 }
	 private void randomiseBlock() {
		 final boolean[] inUse = this.data.inUse;
		 final byte[] block = this.data.block;
		 final int lastShadow = this.last;
		 for (int i = 256;
		 --i >= 0;
		) inUse[i] = false;
		 int rNToGo = 0;
		 int rTPos = 0;
		 for (int i = 0, j = 1;
		 i <= lastShadow;
		 i = j, j++) {
			 if (rNToGo == 0) {
				 rNToGo = (char) BZip2Constants.rNums[rTPos];
				 if (++rTPos == 512) {
					 rTPos = 0;
				 }
			 }
			 rNToGo--;
			 block[j] ^= ((rNToGo == 1) ? 1 : 0);
			 inUse[block[j] & 0xff] = true;
		 }
		 this.blockRandomised = true;
	 }
	 private void generateMTFValues() {
		 final int lastShadow = this.last;
		 final Data dataShadow = this.data;
		 final boolean[] inUse = dataShadow.inUse;
		 final byte[] block = dataShadow.block;
		 final int[] fmap = dataShadow.fmap;
		 final char[] sfmap = dataShadow.sfmap;
		 final int[] mtfFreq = dataShadow.mtfFreq;
		 final byte[] unseqToSeq = dataShadow.unseqToSeq;
		 final byte[] yy = dataShadow.generateMTFValues_yy;
		 int nInUseShadow = 0;
		 for (int i = 0;
		 i < 256;
		 i++) {
			 if (inUse[i]) {
				 unseqToSeq[i] = (byte) nInUseShadow;
				 nInUseShadow++;
			 }
		 }
		 this.nInUse = nInUseShadow;
		 final int eob = nInUseShadow + 1;
		 for (int i = eob;
		 i >= 0;
		 i--) {
			 mtfFreq[i] = 0;
		 }
		 for (int i = nInUseShadow;
		 --i >= 0;
		) {
			 yy[i] = (byte) i;
		 }
		 int wr = 0;
		 int zPend = 0;
		 for (int i = 0;
		 i <= lastShadow;
		 i++) {
			 final byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];
			 byte tmp = yy[0];
			 int j = 0;
			 while (ll_i != tmp) {
				 j++;
				 byte tmp2 = tmp;
				 tmp = yy[j];
				 yy[j] = tmp2;
			 }
			 yy[0] = tmp;
			 if (j == 0) {
				 zPend++;
			 }
			 else {
				 if (zPend > 0) {
					 zPend--;
					 while (true) {
						 if ((zPend & 1) == 0) {
							 sfmap[wr] = RUNA;
							 wr++;
							 mtfFreq[RUNA]++;
						 }
						 else {
							 sfmap[wr] = RUNB;
							 wr++;
							 mtfFreq[RUNB]++;
						 }
						 if (zPend >= 2) {
							 zPend = (zPend - 2) >> 1;
						 }
						 else {
							 break;
						 }
					 }
					 zPend = 0;
				 }
				 sfmap[wr] = (char) (j + 1);
				 wr++;
				 mtfFreq[j + 1]++;
			 }
		 }
		 if (zPend > 0) {
			 zPend--;
			 while (true) {
				 if ((zPend & 1) == 0) {
					 sfmap[wr] = RUNA;
					 wr++;
					 mtfFreq[RUNA]++;
				 }
				 else {
					 sfmap[wr] = RUNB;
					 wr++;
					 mtfFreq[RUNB]++;
				 }
				 if (zPend >= 2) {
					 zPend = (zPend - 2) >> 1;
				 }
				 else {
					 break;
				 }
			 }
		 }
		 sfmap[wr] = (char) eob;
		 mtfFreq[eob]++;
		 this.nMTF = wr + 1;
	 }
	 private static final class Data extends Object {
		 final boolean[] inUse = new boolean[256];
		 final byte[] unseqToSeq = new byte[256];
		 final int[] mtfFreq = new int[MAX_ALPHA_SIZE];
		 final byte[] selector = new byte[MAX_SELECTORS];
		 final byte[] selectorMtf = new byte[MAX_SELECTORS];
		 final byte[] generateMTFValues_yy = new byte[256];
		 final byte[][] sendMTFValues_len = new byte[N_GROUPS][MAX_ALPHA_SIZE];
		 final int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 final int[] sendMTFValues_fave = new int[N_GROUPS];
		 final short[] sendMTFValues_cost = new short[N_GROUPS];
		 final int[][] sendMTFValues_code = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 final byte[] sendMTFValues2_pos = new byte[N_GROUPS];
		 final boolean[] sentMTFValues4_inUse16 = new boolean[16];
		 final int[] stack_ll = new int[QSORT_STACK_SIZE];
		 final int[] stack_hh = new int[QSORT_STACK_SIZE];
		 final int[] stack_dd = new int[QSORT_STACK_SIZE];
		 final int[] mainSort_runningOrder = new int[256];
		 final int[] mainSort_copy = new int[256];
		 final boolean[] mainSort_bigDone = new boolean[256];
		 final int[] heap = new int[MAX_ALPHA_SIZE + 2];
		 final int[] weight = new int[MAX_ALPHA_SIZE * 2];
		 final int[] parent = new int[MAX_ALPHA_SIZE * 2];
		 final int[] ftab = new int[65537];
		 final byte[] block;
		 final int[] fmap;
		 final char[] sfmap;
		 final char[] quadrant;
		 Data(int blockSize100k) {
			 super();
			 final int n = blockSize100k * BZip2Constants.baseBlockSize;
			 this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];
			 this.fmap = new int[n];
			 this.sfmap = new char[2 * n];
			 this.quadrant = this.sfmap;
		 }
	 }
}",1,0,0,0
"private static int trimLockdown(BufferedImage img, int y1) {
	 for (int j = y1 + 1;
	 j < img.getHeight();
	 j++) {
		 int counterWhite = 0;
		 for (int i = 0;
		 i < img.getWidth();
		 i++) {
			 if (img.getRGB(i, j) == -1) {
				 counterWhite++;
			 }
		 }
		 if (counterWhite == img.getWidth()) {
			 if (j > (img.getHeight() / 2)) {
				 return j;
			 }
		 }
		 if (j == img.getHeight() - 1) {
			 return j + 1;
		 }
	 }
	 return 0;
 }",0,0,0,0
"public class Bug301935TestLanguageSyntaxHighlighterFactory extends SingleLazyInstanceSyntaxHighlighterFactory {
	 protected SyntaxHighlighter createHighlighter() {
		 return Bug301935TestLanguageLanguage.INSTANCE.getInstance(SyntaxHighlighter.class);
	 }
}",0,0,0,0
"public void setHaltonerror(boolean haltonerror) {
	 this.haltonerror = haltonerror;
 }",0,0,0,0
"public boolean equals(TListSentryPrivilegesRequest that) {
	 if (that == null) return false;
	 boolean this_present_protocol_version = true;
	 boolean that_present_protocol_version = true;
	 if (this_present_protocol_version || that_present_protocol_version) {
		 if (!(this_present_protocol_version && that_present_protocol_version)) return false;
		 if (this.protocol_version != that.protocol_version) return false;
	 }
	 boolean this_present_requestorUserName = true && this.isSetRequestorUserName();
	 boolean that_present_requestorUserName = true && that.isSetRequestorUserName();
	 if (this_present_requestorUserName || that_present_requestorUserName) {
		 if (!(this_present_requestorUserName && that_present_requestorUserName)) return false;
		 if (!this.requestorUserName.equals(that.requestorUserName)) return false;
	 }
	 boolean this_present_roleName = true && this.isSetRoleName();
	 boolean that_present_roleName = true && that.isSetRoleName();
	 if (this_present_roleName || that_present_roleName) {
		 if (!(this_present_roleName && that_present_roleName)) return false;
		 if (!this.roleName.equals(that.roleName)) return false;
	 }
	 boolean this_present_authorizableHierarchy = true && this.isSetAuthorizableHierarchy();
	 boolean that_present_authorizableHierarchy = true && that.isSetAuthorizableHierarchy();
	 if (this_present_authorizableHierarchy || that_present_authorizableHierarchy) {
		 if (!(this_present_authorizableHierarchy && that_present_authorizableHierarchy)) return false;
		 if (!this.authorizableHierarchy.equals(that.authorizableHierarchy)) return false;
	 }
	 return true;
 }",0,0,1,0
"public void execute() throws BuildException {
	 if (defaultSetDefined || defaultSet.getDir(getProject()) == null) {
		 try {
			 super.execute();
		 }
		 finally {
			 if (defaultSetDefined && defaultSet.getDir(getProject()) != null) {
				 filesets.removeElement(defaultSet);
			 }
		 }
	 }
	 else if (isValidOs()) {
		 Execute execute = prepareExec();
		 Commandline cloned = (Commandline) cmdl.clone();
		 cloned.createArgument().setValue(defaultSet.getDir(getProject()) .getPath());
		 try {
			 execute.setCommandline(cloned.getCommandline());
			 runExecute(execute);
		 }
		 catch (IOException e) {
			 throw new BuildException(""Execute failed: "" + e, e, getLocation());
		 }
		 finally {
			 logFlush();
		 }
	 }
 }",0,0,0,0
"public class ContextFactory{
	 private static volatile boolean hasCustomGlobal;
	 private static ContextFactory global = new ContextFactory();
	 private volatile boolean sealed;
	 private final Object listenersLock = new Object();
	 private volatile Object listeners;
	 private boolean disabledListening;
	 public interface Listener {
		 public void contextCreated(Context cx);
		 public void contextReleased(Context cx);
	 }
	 public static ContextFactory getGlobal() {
		 return global;
	 }
	 public static boolean hasExplicitGlobal() {
		 return hasCustomGlobal;
	 }
	 public static void initGlobal(ContextFactory factory) {
		 if (factory == null) {
			 throw new IllegalArgumentException();
		 }
		 if (hasCustomGlobal) {
			 throw new IllegalStateException();
		 }
		 hasCustomGlobal = true;
		 global = factory;
	 }
	 protected Context makeContext() {
		 return new Context();
	 }
	 protected boolean hasFeature(Context cx, int featureIndex) {
		 int version;
		 switch (featureIndex) {
			 case Context.FEATURE_NON_ECMA_GET_YEAR: version = cx.getLanguageVersion();
			 return (version == Context.VERSION_1_0 || version == Context.VERSION_1_1 || version == Context.VERSION_1_2);
			 case Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME: return false;
			 case Context.FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER: return false;
			 case Context.FEATURE_TO_STRING_AS_SOURCE: version = cx.getLanguageVersion();
			 return version == Context.VERSION_1_2;
			 case Context.FEATURE_PARENT_PROTO_PROPRTIES: return true;
			 case Context.FEATURE_E4X: version = cx.getLanguageVersion();
			 return (version == Context.VERSION_DEFAULT || version >= Context.VERSION_1_6);
			 case Context.FEATURE_DYNAMIC_SCOPE: return false;
			 case Context.FEATURE_STRICT_VARS: return false;
			 case Context.FEATURE_STRICT_EVAL: return false;
		 }
		 throw new IllegalArgumentException(String.valueOf(featureIndex));
	 }
	 protected GeneratedClassLoader createClassLoader(ClassLoader parent) {
		 return new DefiningClassLoader(parent);
	 }
	 protected Object doTopCall(Callable callable, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 return callable.call(cx, scope, thisObj, args);
	 }
	 protected void observeInstructionCount(Context cx, int instructionCount) {
	 }
	 protected void onContextCreated(Context cx) {
		 Object listeners = this.listeners;
		 for (int i = 0;
		 ;
		 ++i) {
			 Listener l = (Listener)Kit.getListener(listeners, i);
			 if (l == null) break;
			 l.contextCreated(cx);
		 }
	 }
	 protected void onContextReleased(Context cx) {
		 Object listeners = this.listeners;
		 for (int i = 0;
		 ;
		 ++i) {
			 Listener l = (Listener)Kit.getListener(listeners, i);
			 if (l == null) break;
			 l.contextReleased(cx);
		 }
	 }
	 public final void addListener(Listener listener) {
		 checkNotSealed();
		 synchronized (listenersLock) {
			 if (disabledListening) {
				 throw new IllegalStateException();
			 }
			 listeners = Kit.addListener(listeners, listener);
		 }
	 }
	 public final void removeListener(Listener listener) {
		 checkNotSealed();
		 synchronized (listenersLock) {
			 if (disabledListening) {
				 throw new IllegalStateException();
			 }
			 listeners = Kit.removeListener(listeners, listener);
		 }
	 }
	 final void disableContextListening() {
		 checkNotSealed();
		 synchronized (listenersLock) {
			 disabledListening = true;
			 listeners = null;
		 }
	 }
	 public final boolean isSealed() {
		 return sealed;
	 }
	 public final void seal() {
		 checkNotSealed();
		 sealed = true;
	 }
	 protected final void checkNotSealed() {
		 if (sealed) throw new IllegalStateException();
	 }
	 public final Object call(ContextAction action) {
		 return Context.call(this, action);
	 }
}",0,0,0,0
"private void parseSegAndFragTable() {
	Logger.log(""parseSegAndFragTable called"");
	if ((segTable.size() == 0) || (fragTable.size() == 0)) {
		System.out.println(""return as zero "" + segTable.size() + "" "" + fragTable.size());
		return;
	}
	Segment firstSegment = segTable.get(0);
	Segment lastSegment = segTable.get(segTable.size() - 1);
	Fragment firstFragment = fragTable.get(0);
	Fragment lastFragment = fragTable.get(fragTable.size() - 1);
	if ((lastFragment.fragmentDuration == 0) && (lastFragment.discontinuityIndicator == 0)) {
		live = false;
		if (fragTable.size() > 0)fragTable.remove(fragTable.size() - 1);
		if (fragTable.size() > 0)lastFragment = fragTable.get(fragTable.size() - 1);
	}
	boolean invalidFragCount = false;
	Segment prev = segTable.get(0);
	fragCount = prev.fragmentsPerSegment;
	for (int i = 0;
	 i < segTable.size();
	 i++) {
		Segment current = segTable.get(i);
		fragCount += (current.firstSegment - prev.firstSegment - 1) * prev.fragmentsPerSegment;
		fragCount += current.fragmentsPerSegment;
		prev = current;
	}
	if ((fragCount & 0x80000000) == 0)fragCount += firstFragment.firstFragment - 1;
	if ((fragCount & 0x80000000) != 0) {
		fragCount = 0;
		invalidFragCount = true;
	}
	if (fragCount < lastFragment.firstFragment)fragCount = lastFragment.firstFragment;
	if (segStart < 0) {
		if (live)segStart = lastSegment.firstSegment;
		elsesegStart = firstSegment.firstSegment;
		if (segStart < 1)segStart = 1;
	}
	if (fragStart < 0) {
		if (live && !invalidFragCount)fragStart = fragCount - 2;
		elsefragStart = firstFragment.firstFragment - 1;
		if (fragStart < 0)fragStart = 0;
	}
}",0,0,1,0
"public static class DiscoverAnnotatedBeans implements DynamicDeployer {
	 public AppModule deploy(AppModule appModule) throws OpenEJBException {
		 for (EjbModule ejbModule : appModule.getEjbModules()) {
			 ejbModule.initAppModule(appModule);
			 setModule(ejbModule);
			 try {
				 deploy(ejbModule);
			 }
			 finally {
				 removeModule();
			 }
		 }
		 for (ClientModule clientModule : appModule.getClientModules()) {
			 clientModule.initAppModule(appModule);
			 setModule(clientModule);
			 try {
				 deploy(clientModule);
			 }
			 finally {
				 removeModule();
			 }
		 }
		 for (ConnectorModule connectorModule : appModule.getConnectorModules()) {
			 connectorModule.initAppModule(appModule);
			 setModule(connectorModule);
			 try {
				 deploy(connectorModule);
			 }
			 finally {
				 removeModule();
			 }
		 }
		 for (WebModule webModule : appModule.getWebModules()) {
			 webModule.initAppModule(appModule);
			 setModule(webModule);
			 try {
				 deploy(webModule);
			 }
			 finally {
				 removeModule();
			 }
		 }
		 final AdditionalBeanDiscoverer discoverer = SystemInstance.get().getComponent(AdditionalBeanDiscoverer.class);
		 if (discoverer != null) {
			 appModule = discoverer.discover(appModule);
		 }
		 return appModule;
	 }
	 public ClientModule deploy(ClientModule clientModule) throws OpenEJBException {
		 if (clientModule.getApplicationClient() == null){
			 clientModule.setApplicationClient(new ApplicationClient());
		 }
		 if (clientModule.getFinder() == null && clientModule.getAltDDs().containsKey(""application-client.xml"")) if (clientModule.getApplicationClient() != null && clientModule.getApplicationClient().isMetadataComplete()) return clientModule;
		 IAnnotationFinder finder = clientModule.getFinder();
		 if (finder == null) {
			 try {
				 finder = FinderFactory.createFinder(clientModule);
			 }
			 catch (MalformedURLException e) {
				 startupLogger.warning(""startup.scrapeFailedForClientModule.url"", clientModule.getJarLocation());
				 return clientModule;
			 }
			 catch (Exception e) {
				 startupLogger.warning(""startup.scrapeFailedForClientModule"", e, clientModule.getJarLocation());
				 return clientModule;
			 }
		 }
		 for (Annotated<Class<?>> clazz : finder.findMetaAnnotatedClasses(LocalClient.class)) {
			 clientModule.getLocalClients().add(clazz.get().getName());
		 }
		 for (Annotated<Class<?>> clazz : finder.findMetaAnnotatedClasses(RemoteClient.class)) {
			 clientModule.getRemoteClients().add(clazz.get().getName());
		 }
		 if (clientModule.getApplicationClient() == null){
			 if (clientModule.getRemoteClients().size() > 0 || clientModule.getLocalClients().size() > 0) {
				 clientModule.setApplicationClient(new ApplicationClient());
			 }
		 }
		 return clientModule;
	 }
	 public ConnectorModule deploy(ConnectorModule connectorModule) throws OpenEJBException {
		 org.apache.openejb.jee.Connector connector = connectorModule.getConnector();
		 if (connector == null) {
			 connector = new org.apache.openejb.jee.Connector();
		 }
		 float specVersion = 0;
		 try {
			 specVersion = Float.parseFloat(connector.getVersion());
		 }
		 catch (Exception e) {
		 }
		if (specVersion < 1.6 || Boolean.TRUE.equals(connector.isMetadataComplete())) {
			return connectorModule;
		}
		 IAnnotationFinder finder = connectorModule.getFinder();
		 if (finder == null) {
			 try {
				 finder = FinderFactory.createFinder(connectorModule);
				connectorModule.setFinder(finder);
			}
			 catch (Exception e) {
				return connectorModule;
			}
		 }
		 List<Class<?>> connectorClasses = finder.findAnnotatedClasses(Connector.class);
		 if (connector.getResourceAdapter() == null || connector.getResourceAdapter().getResourceAdapterClass() == null || connector.getResourceAdapter().getResourceAdapterClass().length() == 0) {
			 if (connectorClasses.size() == 0) {
			 }
			 if (connectorClasses.size() > 1) {
			 }
		 }
		 Class<?> connectorClass = null;
		 if (connectorClasses.size() == 1) {
			 connectorClass = connectorClasses.get(0);
		 }
		 if (connectorClasses.size() > 1) {
			 for (Class<?> cls : connectorClasses) {
				 if (cls.getName().equals(connector.getResourceAdapter().getResourceAdapterClass())) {
					 connectorClass = cls;
					 break;
				 }
			 }
		 }
		 if (connectorClass != null) {
			 if (connector.getResourceAdapter() == null) {
				 connector.setResourceAdapter(new ResourceAdapter());
			 }
			 if (connector.getResourceAdapter().getResourceAdapterClass() == null || connector.getResourceAdapter().getResourceAdapterClass().length() == 0) {
				 connector.getResourceAdapter().setResourceAdapterClass(connectorClass.getName());
			 }
			 Connector connectorAnnotation = connectorClass.getAnnotation(Connector.class);
			 connector.setDisplayNames(getTexts(connector.getDisplayNames(), connectorAnnotation.displayName()));
			 connector.setDescriptions(getTexts(connector.getDescriptions(), connectorAnnotation.description()));
			 connector.setEisType(getString(connector.getEisType(), connectorAnnotation.eisType()));
			 connector.setVendorName(getString(connector.getVendorName(), connectorAnnotation.vendorName()));
			 connector.setResourceAdapterVersion(getString(connector.getResourceAdapterVersion(), connectorAnnotation.version()));
			 if (connector.getIcons().isEmpty()) {
				 int smallIcons = connectorAnnotation.smallIcon().length;
				 int largeIcons = connectorAnnotation.largeIcon().length;
				 for (int i = 0;
				 i < smallIcons && i < largeIcons;
				 i++) {
					 Icon icon = new Icon();
					 icon.setLang(Locale.getDefault().getLanguage());
					 if (i < smallIcons) {
						 icon.setSmallIcon(connectorAnnotation.smallIcon()[i]);
					 }
					 if (i < largeIcons) {
						 icon.setLargeIcon(connectorAnnotation.largeIcon()[i]);
					 }
					 connector.getIcons().add(icon);
				 }
			 }
			 if (connector.getLicense() == null) {
				 License license = new License();
				connector.setLicense(license);
				license.setLicenseRequired(connectorAnnotation.licenseRequired());
			 }
			 connector.getLicense().setDescriptions(getTexts(connector.getLicense().getDescriptions(), connectorAnnotation.licenseDescription()));
			 SecurityPermission[] annotationSecurityPermissions = connectorAnnotation.securityPermissions();
			List<org.apache.openejb.jee.SecurityPermission> securityPermission = connector.getResourceAdapter().getSecurityPermission();
			if (securityPermission == null || securityPermission.size() == 0) {
				for (SecurityPermission sp : annotationSecurityPermissions) {
					org.apache.openejb.jee.SecurityPermission permission = new org.apache.openejb.jee.SecurityPermission();
					permission.setSecurityPermissionSpec(sp.permissionSpec());
					permission.setDescriptions(stringsToTexts(sp.description()));
					securityPermission.add(permission);
				}
			}
			Class<? extends WorkContext>[] annotationRequiredWorkContexts = connectorAnnotation.requiredWorkContexts();
			List<String> requiredWorkContext = connector.getRequiredWorkContext();
			if (requiredWorkContext.size() == 0) {
				for (Class<? extends WorkContext> cls : annotationRequiredWorkContexts) {
					requiredWorkContext.add(cls.getName());
				}
			}
			OutboundResourceAdapter outboundResourceAdapter = connector.getResourceAdapter().getOutboundResourceAdapter();
			if (outboundResourceAdapter == null) {
				outboundResourceAdapter = new OutboundResourceAdapter();
				connector.getResourceAdapter().setOutboundResourceAdapter(outboundResourceAdapter);
			}
			List<AuthenticationMechanism> authenticationMechanisms = outboundResourceAdapter.getAuthenticationMechanism();
			javax.resource.spi.AuthenticationMechanism[] authMechanisms = connectorAnnotation.authMechanisms();
			if (authenticationMechanisms.size() == 0) {
				for (javax.resource.spi.AuthenticationMechanism am : authMechanisms) {
					AuthenticationMechanism authMechanism = new AuthenticationMechanism();
					authMechanism.setAuthenticationMechanismType(am.authMechanism());
					authMechanism.setCredentialInterface(am.credentialInterface().toString());
					authMechanism.setDescriptions(stringsToTexts(am.description()));
					authenticationMechanisms.add(authMechanism);
				}
			}
			if (outboundResourceAdapter.getTransactionSupport() == null) {
				outboundResourceAdapter.setTransactionSupport(TransactionSupportType.fromValue(connectorAnnotation.transactionSupport().toString()));
			}
			if (outboundResourceAdapter.isReauthenticationSupport() == null) {
				outboundResourceAdapter.setReauthenticationSupport(connectorAnnotation.reauthenticationSupport());
			}
		 }
		 else {
		 }
		 List<Class<?>> classes = finder.findAnnotatedClasses(ConnectionDefinitions.class);
		 for (Class<?> cls : classes) {
			ConnectionDefinitions connectionDefinitionsAnnotation = cls.getAnnotation(ConnectionDefinitions.class);
			ConnectionDefinition[] definitions = connectionDefinitionsAnnotation.value();
			for (ConnectionDefinition definition : definitions) {
				processConnectionDescription(connector.getResourceAdapter(), definition, cls);
			}
		}
		 classes = finder.findAnnotatedClasses(ConnectionDefinition.class);
		 for (Class<?> cls : classes) {
			ConnectionDefinition connectionDefinitionAnnotation = cls.getAnnotation(ConnectionDefinition.class);
			processConnectionDescription(connector.getResourceAdapter(), connectionDefinitionAnnotation, cls);
		}
		 InboundResourceadapter inboundResourceAdapter = connector.getResourceAdapter().getInboundResourceAdapter();
		 if (inboundResourceAdapter == null) {
			 inboundResourceAdapter = new InboundResourceadapter();
			 connector.getResourceAdapter().setInboundResourceAdapter(inboundResourceAdapter);
		 }
		 MessageAdapter messageAdapter = inboundResourceAdapter.getMessageAdapter();
		 if (messageAdapter == null) {
			 messageAdapter = new MessageAdapter();
			 inboundResourceAdapter.setMessageAdapter(messageAdapter);
		 }
		 classes = finder.findAnnotatedClasses(Activation.class);
		 for (Class<?> cls : classes) {
			 MessageListener messageListener = null;
			 Activation activationAnnotation = cls.getAnnotation(Activation.class);
			 List<MessageListener> messageListeners = messageAdapter.getMessageListener();
			for (MessageListener ml : messageListeners) {
				if (cls.getName().equals(ml.getActivationSpec().getActivationSpecClass())) {
					messageListener = ml;
					break;
				}
			}
			if (messageListener == null) {
				Class<?>[] listeners = activationAnnotation.messageListeners();
				for (Class<?> listener : listeners) {
					messageAdapter.addMessageListener(new MessageListener(listener.getName(), cls.getName()));
				}
			}
		}
		 classes = finder.findAnnotatedClasses(AdministeredObject.class);
		 List<AdminObject> adminObjects = connector.getResourceAdapter().getAdminObject();
		 for (Class<?> cls : classes) {
			AdministeredObject administeredObjectAnnotation = cls.getAnnotation(AdministeredObject.class);
			Class[] adminObjectInterfaces = administeredObjectAnnotation.adminObjectInterfaces();
			AdminObject adminObject = null;
			for (AdminObject admObj : adminObjects) {
				if (admObj.getAdminObjectClass().equals(cls.getName())) {
					adminObject = admObj;
				}
			}
			if (adminObject == null) {
				for (Class iface : adminObjectInterfaces) {
					AdminObject newAdminObject = new AdminObject();
					newAdminObject.setAdminObjectClass(cls.getName());
					newAdminObject.setAdminObjectInterface(iface.getName());
					adminObjects.add(newAdminObject);
				}
			}
		}
		 String raCls = connector.getResourceAdapter().getResourceAdapterClass();
		 process(connectorModule.getClassLoader(), raCls, connector.getResourceAdapter());
		 if (connector.getResourceAdapter() != null && connector.getResourceAdapter().getOutboundResourceAdapter() != null) {
			 List<org.apache.openejb.jee.ConnectionDefinition> connectionDefinitions = connector.getResourceAdapter().getOutboundResourceAdapter().getConnectionDefinition();
			 for (org.apache.openejb.jee.ConnectionDefinition connectionDefinition : connectionDefinitions) {
				 process(connectorModule.getClassLoader(), connectionDefinition.getManagedConnectionFactoryClass(), connectionDefinition);
			}
		 }
		 if (connector.getResourceAdapter() != null) {
			 List<AdminObject> raAdminObjects = connector.getResourceAdapter().getAdminObject();
			 for (AdminObject raAdminObject : raAdminObjects) {
				process(connectorModule.getClassLoader(), raAdminObject.getAdminObjectClass(), raAdminObject);
			}
		 }
		 if (connector.getResourceAdapter() != null && connector.getResourceAdapter().getInboundResourceAdapter() != null && connector.getResourceAdapter().getInboundResourceAdapter().getMessageAdapter() != null) {
			 List<MessageListener> messageListeners = connector.getResourceAdapter().getInboundResourceAdapter().getMessageAdapter().getMessageListener();
			 for (MessageListener messageListener : messageListeners) {
				ActivationSpec activationSpec = messageListener.getActivationSpec();
				process(connectorModule.getClassLoader(), activationSpec.getActivationSpecClass(), activationSpec);
			}
		 }
		 return connectorModule;
	 }
	void process(ClassLoader cl, String cls, Object object) {
		List<ConfigProperty> configProperties = null;
		try {
			configProperties = (List<ConfigProperty>) object.getClass().getDeclaredMethod(""getConfigProperty"").invoke(object);
		}
		 catch (Exception e) {
		}
		if (configProperties == null) {
			return;
		}
		ClassLoader classLoader = cl;
		if (classLoader == null) {
			classLoader = Thread.currentThread().getContextClassLoader();
		}
		final List<String> allowedTypes = Arrays.asList(new String[] {
		 Boolean.class.getName(), String.class.getName(), Integer.class.getName(), Double.class.getName(), Byte.class.getName(), Short.class.getName(), Long.class.getName(), Float.class.getName(), Character.class.getName()}
		);
		try {
			Class<?> clazz = classLoader.loadClass(realClassName(cls));
			Object o = clazz.newInstance();
			BeanInfo beanInfo = Introspector.getBeanInfo(clazz);
			PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();
			for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
				String name = propertyDescriptor.getName();
				Class<?> type = propertyDescriptor.getPropertyType();
				 if (type == null) {
					 continue;
				 }
				if (type.isPrimitive()) {
					type = getWrapper(type.getName());
				}
				if (! allowedTypes.contains(type.getName())) {
					continue;
				}
				if (! containsConfigProperty(configProperties, name)) {
					if (type != null) {
						ConfigProperty configProperty = new ConfigProperty();
						configProperties.add(configProperty);
						Object value = null;
						try {
							value = propertyDescriptor.getReadMethod().invoke(o);
						}
						 catch (Exception e) {
						}
						javax.resource.spi.ConfigProperty annotation = propertyDescriptor.getWriteMethod().getAnnotation(javax.resource.spi.ConfigProperty.class);
						 if (annotation == null) {
							 try {
								 annotation = clazz.getDeclaredField(name).getAnnotation(javax.resource.spi.ConfigProperty.class);
							 }
							 catch (Exception ignored) {
							 }
						 }
						configProperty.setConfigPropertyName(name);
						configProperty.setConfigPropertyType(getConfigPropertyType(annotation, type));
						if (value != null) {
							configProperty.setConfigPropertyValue(value.toString());
						}
						if (annotation != null) {
							if (annotation.defaultValue() != null && annotation.defaultValue().length() > 0) {
								configProperty.setConfigPropertyValue(annotation.defaultValue());
							}
							configProperty.setConfigPropertyConfidential(annotation.confidential());
							configProperty.setConfigPropertyIgnore(annotation.ignore());
							configProperty.setConfigPropertySupportsDynamicUpdates(annotation.supportsDynamicUpdates());
							configProperty.setDescriptions(stringsToTexts(annotation.description()));
						}
					}
				}
			}
			Field[] declaredFields = clazz.getDeclaredFields();
			for (Field field : declaredFields) {
				javax.resource.spi.ConfigProperty annotation = field.getAnnotation(javax.resource.spi.ConfigProperty.class);
				String name = field.getName();
				Object value = null;
				try {
					value = field.get(o);
				}
				 catch (Exception e) {
				}
				if (! containsConfigProperty(configProperties, name)) {
					String type = getConfigPropertyType(annotation, field.getType());
					if (type != null) {
						ConfigProperty configProperty = new ConfigProperty();
						configProperties.add(configProperty);
						configProperty.setConfigPropertyName(name);
						configProperty.setConfigPropertyType(type);
						if (value != null) {
							configProperty.setConfigPropertyValue(value.toString());
						}
						if (annotation != null) {
							if (annotation.defaultValue() != null) {
								configProperty.setConfigPropertyValue(annotation.defaultValue());
							}
							configProperty.setConfigPropertyConfidential(annotation.confidential());
							configProperty.setConfigPropertyIgnore(annotation.ignore());
							configProperty.setConfigPropertySupportsDynamicUpdates(annotation.supportsDynamicUpdates());
						}
					}
				}
			}
		}
		 catch (Exception e) {
			e.printStackTrace();
		}
	}
	private String getConfigPropertyType(javax.resource.spi.ConfigProperty annotation, Class<?> type) {
		Class<?> t = (annotation == null) ? null : annotation.type();
		 if (t == null && type != null) {
			 return type.getName();
		 }
		 else if (t == null) {
			 return null;
		 }
		if (t.equals(Object.class)) {
			t = type;
		}
		 if (t == null) {
			 return null;
		 }
		if (t.isPrimitive()) {
			t = getWrapper(t.getName());
		}
		return t.getName();
	}
	private boolean containsConfigProperty(List<ConfigProperty> configProperties, String name) {
		for (ConfigProperty configProperty : configProperties) {
			if (configProperty.getConfigPropertyName().equals(name)) {
				return true;
			}
		}
		return false;
	}
	private Class<?> getWrapper(String primitiveType) {
		final Map<String,Class<?>> builtInMap = new HashMap<String,Class<?>>();
		{
			 builtInMap.put(""int"", Integer.class);
			 builtInMap.put(""long"", Long.class);
			 builtInMap.put(""double"", Double.class);
			 builtInMap.put(""float"", Float.class);
			 builtInMap.put(""boolean"", Boolean.class);
			 builtInMap.put(""char"", Character.class);
			 builtInMap.put(""byte"", Byte.class);
			 builtInMap.put(""void"", Void.class);
			 builtInMap.put(""short"", Short.class);
		}
		return builtInMap.get(primitiveType);
	}
	private void processConnectionDescription(ResourceAdapter resourceAdapter, ConnectionDefinition connectionDefinitionAnnotation, Class<?> cls) {
		OutboundResourceAdapter outboundResourceAdapter = resourceAdapter.getOutboundResourceAdapter();
		if (outboundResourceAdapter == null) {
			outboundResourceAdapter = new OutboundResourceAdapter();
			resourceAdapter.setOutboundResourceAdapter(outboundResourceAdapter);
		}
		List<org.apache.openejb.jee.ConnectionDefinition> connectionDefinition = outboundResourceAdapter.getConnectionDefinition();
		org.apache.openejb.jee.ConnectionDefinition definition = null;
		for (org.apache.openejb.jee.ConnectionDefinition cd : connectionDefinition) {
			if (cd.getManagedConnectionFactoryClass().equals(cls.getName())) {
				definition = cd;
				break;
			}
		}
		if (definition == null) {
			definition = new org.apache.openejb.jee.ConnectionDefinition();
			outboundResourceAdapter.getConnectionDefinition().add(definition);
		}
		if (definition.getManagedConnectionFactoryClass() == null) {
			definition.setManagedConnectionFactoryClass(cls.getName());
		}
		if (definition.getConnectionInterface() == null) {
			definition.setConnectionInterface(connectionDefinitionAnnotation.connection().getName());
		}
		if (definition.getConnectionImplClass() == null) {
			definition.setConnectionImplClass(connectionDefinitionAnnotation.connectionImpl().getName());
		}
		if (definition.getConnectionFactoryInterface() == null) {
			definition.setConnectionFactoryInterface(connectionDefinitionAnnotation.connectionFactory().getName());
		}
		if (definition.getConnectionFactoryImplClass() == null) {
			definition.setConnectionFactoryImplClass(connectionDefinitionAnnotation.connectionFactoryImpl().getName());
		}
	}
	private Text[] stringsToTexts(String[] strings) {
		if (strings == null) {
			return null;
		}
		Text[] result = new Text[strings.length];
		for (int i = 0;
		 i < result.length;
		 i++) {
			result[i] = new Text();
			result[i].setValue(strings[i]);
		}
		return result;
	}
	private String getString(String descriptorString, String annotationString) {
		if (descriptorString != null && descriptorString.length() > 0) {
			return descriptorString;
		}
		if (annotationString != null && annotationString.length() > 0) {
			return annotationString;
		}
		return null;
	}
	private Text[] getTexts(Text[] originalTexts, String[] newStrings) {
		if (newStrings != null && newStrings.length > 0 && (originalTexts == null || originalTexts.length == 0)) {
			Text[] texts = new Text[newStrings.length];
			for (int i = 0;
			 i < newStrings.length;
			 i++) {
				texts[i] = new Text(null, newStrings[i]);
			}
			return texts;
		}
		 else {
			return originalTexts;
		}
	}
	 public WebModule deploy(WebModule webModule) throws OpenEJBException {
		 WebApp webApp = webModule.getWebApp();
		 if (webApp != null && (webApp.isMetadataComplete())) return webModule;
		 try {
			 if (webModule.getFinder() == null) {
				 webModule.setFinder(FinderFactory.createFinder(webModule));
			 }
		 }
		 catch (Exception e) {
			 startupLogger.warning(""Unable to scrape for or annotations. AnnotationFinder failed."", e);
			 return webModule;
		 }
		 if (webApp == null) {
			 webApp = new WebApp();
			 webModule.setWebApp(webApp);
		 }
		 List<String> existingServlets = new ArrayList<String>();
		 for (Servlet servlet : webApp.getServlet()) {
			 if (servlet.getServletClass() != null) {
				 existingServlets.add(servlet.getServletClass());
			 }
		 }
		 IAnnotationFinder finder = webModule.getFinder();
		 List<Class> classes = new ArrayList<Class>();
		 classes.addAll(finder.findAnnotatedClasses(WebService.class));
		 classes.addAll(finder.findAnnotatedClasses(WebServiceProvider.class));
		 for (Class<?> webServiceClass : classes) {
			 if (webServiceClass.isAnnotationPresent(Singleton.class) || webServiceClass.isAnnotationPresent(Stateless.class)) {
				 webModule.getEjbWebServices().add(webServiceClass.getName());
				 continue;
			 }
			 int modifiers = webServiceClass.getModifiers();
			 if (!Modifier.isPublic(modifiers) || Modifier.isFinal(modifiers) || isAbstract(modifiers)) {
				 continue;
			 }
			 if (existingServlets.contains(webServiceClass.getName())) continue;
			 Servlet servlet = new Servlet();
			 servlet.setServletName(webServiceClass.getName());
			 servlet.setServletClass(webServiceClass.getName());
			 webApp.getServlet().add(servlet);
		 }
		 webModule.getRestClasses().addAll(findRestClasses(webModule, finder));
		 addJaxRsProviders(finder, webModule.getJaxrsProviders(), Provider.class);
		 List<Class<? extends Application>> applications = finder.findSubclasses(Application.class);
		 for (Class<? extends Application> app : applications) {
			 addRestApplicationIfPossible(webModule, app);
		 }
		 List<Annotated<Class<?>>> applicationsByAnnotation = finder.findMetaAnnotatedClasses(ApplicationPath.class);
		 for (Annotated<Class<?>> annotatedApp : applicationsByAnnotation) {
			 final Class<?> app = annotatedApp.get();
			 if (!Application.class.isAssignableFrom(app)) {
				 logger.error(""class '"" + app.getName() + ""' is annotated with but doesn't implement "" + Application.class.getName());
				 continue;
			 }
			 addRestApplicationIfPossible(webModule, (Class<? extends Application>) app);
		 }
		 final ClassLoader classLoader = webModule.getClassLoader();
		 for (String jsfClass : JSF_CLASSES) {
			 final Class<? extends Annotation> clazz;
			 try {
				 clazz = (Class<? extends Annotation>) classLoader.loadClass(jsfClass);
			 }
			 catch (ClassNotFoundException e) {
				 continue;
			 }
			 final List<Annotated<Class<?>>> found = finder.findMetaAnnotatedClasses(clazz);
			 final Set<String> convertedClasses = new HashSet<String>(found.size());
			 for (Annotated<Class<?>> annotated : found) {
				 convertedClasses.add(annotated.get().getName());
			 }
			 webModule.getJsfAnnotatedClasses().put(jsfClass, convertedClasses);
		 }
		 Map<String, String> urlByClasses = null;
		 for (String apiClassName : WEB_CLASSES) {
			 final Class<? extends Annotation> clazz;
			 try {
				 clazz = (Class<? extends Annotation>) classLoader.loadClass(apiClassName);
			 }
			 catch (ClassNotFoundException e) {
				 continue;
			 }
			 if (urlByClasses == null) {
				 if (finder instanceof FinderFactory.ModuleLimitedFinder) {
					 final IAnnotationFinder limitedFinder = ((FinderFactory.ModuleLimitedFinder) finder).getDelegate();
					 if (limitedFinder instanceof AnnotationFinder) {
						 final Archive archive = ((AnnotationFinder) limitedFinder).getArchive();
						 if (archive instanceof WebappAggregatedArchive) {
							 final Map<URL, List<String>> index = ((WebappAggregatedArchive) archive).getClassesMap();
							 urlByClasses = new HashMap<String, String>();
							 for (Map.Entry<URL, List<String>> entry : index.entrySet()) {
								 final String url = entry.getKey().toExternalForm();
								 for (String current : entry.getValue()) {
									 urlByClasses.put(current, url);
								 }
							 }
						 }
					 }
				 }
			 }
			 final List<Annotated<Class<?>>> found = finder.findMetaAnnotatedClasses(clazz);
			 addWebAnnotatedClassInfo(urlByClasses, webModule.getWebAnnotatedClasses(), found);
		 }
		 if (urlByClasses != null) {
			 urlByClasses.clear();
		 }
		 return webModule;
	 }
	 private void addJaxRsProviders(final IAnnotationFinder finder, final Collection<String> set, final Class<? extends Annotation> annotation) {
		 for (Annotated<Class<?>> provider : finder.findMetaAnnotatedClasses(annotation)) {
			 set.add(provider.get().getName());
		 }
	 }
	 private static void addRestApplicationIfPossible(final WebModule webModule, final Class<? extends Application> app) {
		 if (app.getConstructors().length == 0) {
			 webModule.getRestApplications().add(app.getName());
		 }
		 else {
			 for (Constructor<?> ctr : app.getConstructors()) {
				 if (ctr.getParameterTypes().length == 0) {
					 webModule.getRestApplications().add(app.getName());
					 break;
				 }
			 }
		 }
	 }
	 public EjbModule deploy(EjbModule ejbModule) throws OpenEJBException {
		 if (ejbModule.getEjbJar() != null && ejbModule.getEjbJar().isMetadataComplete()) return ejbModule;
		 try {
			 if (ejbModule.getFinder() == null) {
				 ejbModule.setFinder(FinderFactory.createFinder(ejbModule));
			 }
		 }
		 catch (MalformedURLException e) {
			 startupLogger.warning(""startup.scrapeFailedForModule"", ejbModule.getJarLocation());
			 return ejbModule;
		 }
		 catch (Exception e) {
			 startupLogger.warning(""Unable to scrape for , , or annotations. AnnotationFinder failed."", e);
			 return ejbModule;
		 }
		 IAnnotationFinder finder = ejbModule.getFinder();
		 final List<String> managedClasses;
		 {
			 final Beans beans = ejbModule.getBeans();
			 if (beans != null) {
				 managedClasses = beans.getManagedClasses();
				 final List<String> classNames = getBeanClasses(finder);
				 for (String rawClassName : classNames) {
					 final String className = realClassName(rawClassName);
					 try {
						 final ClassLoader loader = ejbModule.getClassLoader();
						 final Class<?> clazz = loader.loadClass(className);
						 if (clazz.getEnclosingClass() != null && !Modifier.isStatic(clazz.getModifiers())) continue;
						 if (Extension.class.isAssignableFrom(clazz)) continue;
						 managedClasses.add(className);
					 }
					 catch (ClassNotFoundException e) {
					 }
					 catch (java.lang.NoClassDefFoundError e) {
					 }
				 }
				 String id = ejbModule.getModuleId();
				 if (ejbModule.getJarLocation() != null && ejbModule.getJarLocation().contains(ejbModule.getModuleId() + ""/target/test-classes"".replace(""/"", File.separator))) {
					 id += ""_test"";
				 }
				 final String name = BeanContext.Comp.openejbCompName(id);
				 final org.apache.openejb.jee.ManagedBean managedBean = new CompManagedBean(name, BeanContext.Comp.class);
				 managedBean.setTransactionType(TransactionType.BEAN);
				 ejbModule.getEjbJar().addEnterpriseBean(managedBean);
			 }
			 else {
				 managedClasses = new ArrayList<String>();
			 }
		 }
		 final Set<Class<?>> specializingClasses = new HashSet<Class<?>>();
		 for (EnterpriseBean bean : ejbModule.getEjbJar().getEnterpriseBeans()) {
			 if (!(bean instanceof SessionBean)) continue;
			 SessionBean sessionBean = (SessionBean) bean;
			 if (sessionBean.getSessionType() != null) continue;
			 try {
				 final Class<?> clazz = ejbModule.getClassLoader().loadClass(bean.getEjbClass());
				 sessionBean.setSessionType(getSessionType(clazz));
			 }
			 catch (Throwable handledInValidation) {
			 }
		 }
		 for (EnterpriseBean bean : ejbModule.getEjbJar().getEnterpriseBeans()) {
			 if (bean.getEjbClass() == null) continue;
			 if (bean.getEjbName() == null || bean.getEjbName().startsWith(""@"")) {
				 ejbModule.getEjbJar().removeEnterpriseBean(bean.getEjbName());
				 try {
					 final Class<?> clazz = ejbModule.getClassLoader().loadClass(bean.getEjbClass());
					 final String ejbName = getEjbName(bean, clazz);
					 bean.setEjbName(ejbName);
				 }
				 catch (Throwable handledInValidation) {
				 }
				 ejbModule.getEjbJar().addEnterpriseBean(bean);
			 }
		 }
		 EjbJar ejbJar = ejbModule.getEjbJar();
		 for (Annotated<Class<?>> beanClass : finder.findMetaAnnotatedClasses(Singleton.class)) {
			 if (beanClass.isAnnotationPresent(Specializes.class)) {
				 managedClasses.remove(beanClass.get().getName());
				 specializingClasses.add(beanClass.get());
				 continue;
			 }
			 Singleton singleton = beanClass.getAnnotation(Singleton.class);
			 String ejbName = getEjbName(singleton, beanClass.get());
			 if (!isValidEjbAnnotationUsage(Singleton.class, beanClass, ejbName, ejbModule)) continue;
			 EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);
			 if (enterpriseBean == null) {
				 enterpriseBean = new SingletonBean(ejbName, beanClass.get());
				 ejbJar.addEnterpriseBean(enterpriseBean);
			 }
			 if (enterpriseBean.getEjbClass() == null) {
				 enterpriseBean.setEjbClass(beanClass.get());
			 }
			 if (enterpriseBean instanceof SessionBean) {
				 SessionBean sessionBean = (SessionBean) enterpriseBean;
				 sessionBean.setSessionType(SessionType.SINGLETON);
				 if (singleton.mappedName() != null) {
					 sessionBean.setMappedName(singleton.mappedName());
				 }
			 }
			 LegacyProcessor.process(beanClass.get(), enterpriseBean);
		 }
		 for (Annotated<Class<?>> beanClass : finder.findMetaAnnotatedClasses(Stateless.class)) {
			 if (beanClass.isAnnotationPresent(Specializes.class)) {
				 managedClasses.remove(beanClass.get().getName());
				 specializingClasses.add(beanClass.get());
				 continue;
			 }
			 Stateless stateless = beanClass.getAnnotation(Stateless.class);
			 String ejbName = getEjbName(stateless, beanClass.get());
			 if (!isValidEjbAnnotationUsage(Stateless.class, beanClass, ejbName, ejbModule)) continue;
			 EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);
			 if (enterpriseBean == null) {
				 enterpriseBean = new StatelessBean(ejbName, beanClass.get());
				 ejbJar.addEnterpriseBean(enterpriseBean);
			 }
			 if (enterpriseBean.getEjbClass() == null) {
				 enterpriseBean.setEjbClass(beanClass.get());
			 }
			 if (enterpriseBean instanceof SessionBean) {
				 SessionBean sessionBean = (SessionBean) enterpriseBean;
				 sessionBean.setSessionType(SessionType.STATELESS);
				 if (stateless.mappedName() != null) {
					 sessionBean.setMappedName(stateless.mappedName());
				 }
			 }
			 LegacyProcessor.process(beanClass.get(), enterpriseBean);
		 }
		 for (Annotated<Class<?>> beanClass : finder.findMetaAnnotatedClasses(Stateful.class)) {
			 if (beanClass.isAnnotationPresent(Specializes.class)) {
				 managedClasses.remove(beanClass.get().getName());
				 specializingClasses.add(beanClass.get());
				 continue;
			 }
			 Stateful stateful = beanClass.getAnnotation(Stateful.class);
			 String ejbName = getEjbName(stateful, beanClass.get());
			 if (!isValidEjbAnnotationUsage(Stateful.class, beanClass, ejbName, ejbModule)) continue;
			 EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);
			 if (enterpriseBean == null) {
				 enterpriseBean = new StatefulBean(ejbName, beanClass.get());
				 ejbJar.addEnterpriseBean(enterpriseBean);
			 }
			 if (enterpriseBean.getEjbClass() == null) {
				 enterpriseBean.setEjbClass(beanClass.get());
			 }
			 if (enterpriseBean instanceof SessionBean) {
				 SessionBean sessionBean = (SessionBean) enterpriseBean;
				 sessionBean.setSessionType(SessionType.STATEFUL);
				 if (stateful.mappedName() != null) {
					 sessionBean.setMappedName(stateful.mappedName());
				 }
			 }
			 LegacyProcessor.process(beanClass.get(), enterpriseBean);
		 }
		 for (Annotated<Class<?>> beanClass : finder.findMetaAnnotatedClasses(ManagedBean.class)) {
			 if (beanClass.isAnnotationPresent(Specializes.class)) {
				 managedClasses.remove(beanClass.get().getName());
				 specializingClasses.add(beanClass.get());
				 continue;
			 }
			 ManagedBean managed = beanClass.getAnnotation(ManagedBean.class);
			 String ejbName = getEjbName(managed, beanClass.get());
			 if (!isValidEjbAnnotationUsage(ManagedBean.class, beanClass, ejbName, ejbModule)) continue;
			 EnterpriseBean enterpriseBean = ejbJar.getEnterpriseBean(ejbName);
			 if (enterpriseBean == null) {
				 enterpriseBean = new org.apache.openejb.jee.ManagedBean(ejbName, beanClass.get());
				 ejbJar.addEnterpriseBean(enterpriseBean);
			 }
			 if (enterpriseBean.getEjbClass() == null) {
				 enterpriseBean.setEjbClass(beanClass.get());
			 }
			 if (enterpriseBean instanceof SessionBean) {
				 SessionBean sessionBean = (SessionBean) enterpriseBean;
				 sessionBean.setSessionType(SessionType.MANAGED);
				 final TransactionType transactionType = sessionBean.getTransactionType();
				 if (transactionType == null) sessionBean.setTransactionType(TransactionType.BEAN);
			 }
		 }
		 for (Annotated<Class<?>> beanClass : finder.findMetaAnnotatedClasses(MessageDriven.class)) {
			 if (beanClass.isAnnotationPresent(Specializes.class)) {
				 managedClasses.remove(beanClass.get().getName());
				 specializingClasses.add(beanClass.get());
				 continue;
			 }
			 MessageDriven mdb = beanClass.getAnnotation(MessageDriven.class);
			 String ejbName = getEjbName(mdb, beanClass.get());
			 if (!isValidEjbAnnotationUsage(MessageDriven.class, beanClass, ejbName, ejbModule)) continue;
			 MessageDrivenBean messageBean = (MessageDrivenBean) ejbJar.getEnterpriseBean(ejbName);
			 if (messageBean == null) {
				 messageBean = new MessageDrivenBean(ejbName);
				 ejbJar.addEnterpriseBean(messageBean);
			 }
			 if (messageBean.getEjbClass() == null) {
				 messageBean.setEjbClass(beanClass.get());
			 }
			 LegacyProcessor.process(beanClass.get(), messageBean);
		 }
		 for (Class<?> specializingClass : sortClassesParentFirst(new ArrayList<Class<?>>(specializingClasses))) {
			 final Class<?> parent = specializingClass.getSuperclass();
			 if (parent == null || parent.equals(Object.class)) {
				 ejbModule.getValidation().fail(specializingClass.getSimpleName(), ""specializes.extendsNothing"", specializingClass.getName());
			 }
			 boolean found = false;
			 for (EnterpriseBean enterpriseBean : ejbJar.getEnterpriseBeans()) {
				 final String ejbClass = enterpriseBean.getEjbClass();
				 if (ejbClass != null && ejbClass.equals(parent.getName())) {
					 managedClasses.remove(ejbClass);
					 enterpriseBean.setEjbClass(specializingClass.getName());
					 found = true;
				 }
			 }
			 if (!found) {
				 ejbModule.getValidation().fail(specializingClass.getSimpleName(), ""specializes.extendsSimpleBean"", specializingClass.getName());
			 }
		 }
		 AssemblyDescriptor assemblyDescriptor = ejbModule.getEjbJar().getAssemblyDescriptor();
		 if (assemblyDescriptor == null) {
			 assemblyDescriptor = new AssemblyDescriptor();
			 ejbModule.getEjbJar().setAssemblyDescriptor(assemblyDescriptor);
		 }
		 startupLogger.debug(""Searching for annotated application exceptions (see OPENEJB-980)"");
		 List<Class<?>> appExceptions = finder.findAnnotatedClasses(ApplicationException.class);
		 for (Class<?> exceptionClass : appExceptions) {
			 startupLogger.debug(""...handling "" + exceptionClass);
			 ApplicationException annotation = exceptionClass.getAnnotation(ApplicationException.class);
			 if (assemblyDescriptor.getApplicationException(exceptionClass) == null) {
				 startupLogger.debug(""...adding "" + exceptionClass + "" with rollback="" + annotation.rollback());
				 assemblyDescriptor.addApplicationException(exceptionClass, annotation.rollback(), annotation.inherited());
			 }
			 else {
				 mergeApplicationExceptionAnnotation(assemblyDescriptor, exceptionClass, annotation);
			 }
		 }
		 if (ejbModule.getAppModule() != null) {
			 addJaxRsProviders(finder, ejbModule.getAppModule().getJaxRsProviders(), Provider.class);
		 }
		 if (ejbModule.getAppModule() != null) {
			 for (PersistenceModule pm : ejbModule.getAppModule().getPersistenceModules()) {
				 for (org.apache.openejb.jee.jpa.unit.PersistenceUnit pu : pm.getPersistence().getPersistenceUnit()) {
					 if ((pu.isExcludeUnlistedClasses() == null || !pu.isExcludeUnlistedClasses()) && ""true"".equalsIgnoreCase(pu.getProperties().getProperty(OPENEJB_JPA_AUTO_SCAN))) {
						 final String packageName = pu.getProperties().getProperty(OPENEJB_JPA_AUTO_SCAN_PACKAGE);
						 final List<Class<?>> classes = new ArrayList<Class<?>>();
						 classes.addAll(finder.findAnnotatedClasses(Entity.class));
						 classes.addAll(finder.findAnnotatedClasses(Embeddable.class));
						 classes.addAll(finder.findAnnotatedClasses(MappedSuperclass.class));
						 final List<String> existingClasses = pu.getClazz();
						 for (Class<?> clazz : classes) {
							 final String name = clazz.getName();
							 if ((packageName == null || name.startsWith(packageName)) && !existingClasses.contains(name)) {
								 pu.getClazz().add(name);
							 }
						 }
						 pu.setScanned(true);
					 }
				 }
			 }
		 }
		 return ejbModule;
	 }
	 private SessionType getSessionType(Class<?> clazz) {
		 if (clazz.isAnnotationPresent(Stateful.class)) return SessionType.STATEFUL;
		 if (clazz.isAnnotationPresent(Stateless.class)) return SessionType.STATELESS;
		 if (clazz.isAnnotationPresent(Singleton.class)) return SessionType.SINGLETON;
		 if (clazz.isAnnotationPresent(ManagedBean.class)) return SessionType.MANAGED;
		 return null;
	 }
	 private String getEjbName(EnterpriseBean bean, Class<?> clazz) {
		 if (bean instanceof SessionBean) {
			 SessionBean sessionBean = (SessionBean) bean;
			 switch (sessionBean.getSessionType()) {
				 case STATEFUL: {
					 final Stateful annotation = clazz.getAnnotation(Stateful.class);
					 if (annotation != null && specified(annotation.name())) {
						 return annotation.name();
					 }
				 }
				 case STATELESS: {
					 final Stateless annotation = clazz.getAnnotation(Stateless.class);
					 if (annotation != null && specified(annotation.name())) {
						 return annotation.name();
					 }
				 }
				 case SINGLETON: {
					 final Singleton annotation = clazz.getAnnotation(Singleton.class);
					 if (annotation != null && specified(annotation.name())) {
						 return annotation.name();
					 }
				 }
			 }
		 }
		 if (bean instanceof MessageDrivenBean) {
			 final MessageDriven annotation = clazz.getAnnotation(MessageDriven.class);
			 if (annotation != null && specified(annotation.name())) {
				 return annotation.name();
			 }
		 }
		 return clazz.getSimpleName();
	 }
	 private static boolean specified(final String name) {
		 return name != null && name.length() != 0;
	 }
	 private List<String> getBeanClasses(IAnnotationFinder finder) {
		 if (!(finder instanceof FinderFactory.ModuleLimitedFinder)) return finder.getAnnotatedClassNames();
		 final IAnnotationFinder delegate = ((FinderFactory.ModuleLimitedFinder) finder).getDelegate();
		 if (!(delegate instanceof AnnotationFinder)) return finder.getAnnotatedClassNames();
		 final AnnotationFinder annotationFinder = (AnnotationFinder) delegate;
		 final Archive archive = annotationFinder.getArchive();
		 if (!(archive instanceof WebappAggregatedArchive)) return finder.getAnnotatedClassNames();
		 final List<String> classes = new ArrayList<String>();
		 final WebappAggregatedArchive aggregatedArchive = (WebappAggregatedArchive) archive;
		 final Map<URL, List<String>> map = aggregatedArchive.getClassesMap();
		 for (Map.Entry<URL, List<String>> entry : map.entrySet()) {
			 if (hasBeansXml(entry.getKey())) classes.addAll(entry.getValue());
		 }
		 return classes;
	 }
	 public static boolean hasBeansXml(URL url) {
		 if (url.getPath().endsWith(""WEB-INF/classes/"")) return true;
		 if (url.getPath().endsWith(""!/META-INF/beans.xml"")) return true;
		 try {
			 final URLClassLoader loader = new URLClassLoader(new URL[]{
			 url }
			 , new EmptyResourcesClassLoader());
			 String[] paths = {
			 ""META-INF/beans.xml"", ""WEB-INF/beans.xml"", ""/WEB-INF/beans.xml"", ""/META-INF/beans.xml"", }
			;
			 for (String path : paths) {
				 if (loader.findResource(path) != null) return true;
			 }
		 }
		 catch (Exception e) {
		 }
		 return false;
	 }
	 private String getEjbName(MessageDriven mdb, Class<?> beanClass) {
		 return (mdb.name().isEmpty() ? beanClass.getSimpleName() : mdb.name());
	 }
	 private String getEjbName(Stateful stateful, Class<?> beanClass) {
		 return (stateful.name().isEmpty() ? beanClass.getSimpleName() : stateful.name());
	 }
	 private String getEjbName(Stateless stateless, Class<?> beanClass) {
		 return (stateless.name().isEmpty() ? beanClass.getSimpleName() : stateless.name());
	 }
	 private String getEjbName(Singleton singleton, Class<?> beanClass) {
		 return (singleton.name().isEmpty() ? beanClass.getSimpleName() : singleton.name());
	 }
	 private String getEjbName(ManagedBean managed, Class<?> beanClass) {
		 return (managed.value().isEmpty() ? beanClass.getSimpleName() : managed.value());
	 }
	 private boolean isValidEjbAnnotationUsage(Class annotationClass, Annotated<Class<?>> beanClass, String ejbName, EjbModule ejbModule) {
		 List<Class<? extends Annotation>> annotations = new ArrayList(asList(Singleton.class, Stateless.class, Stateful.class, MessageDriven.class));
		 annotations.remove(annotationClass);
		 boolean b = true;
		 for (Class<? extends Annotation> secondAnnotation : annotations) {
			 Annotation annotation = beanClass.getAnnotation(secondAnnotation);
			 if (annotation == null) continue;
			 String secondEjbName = null;
			 if (annotation instanceof Stateful) {
				 secondEjbName = getEjbName((Stateful) annotation, beanClass.get());
			 }
			 else if (annotation instanceof Stateless) {
				 secondEjbName = getEjbName((Stateless) annotation, beanClass.get());
			 }
			 else if (annotation instanceof Singleton) {
				 secondEjbName = getEjbName((Singleton) annotation, beanClass.get());
			 }
			 else if (annotation instanceof MessageDriven) {
				 secondEjbName = getEjbName((MessageDriven) annotation, beanClass.get());
			 }
			 if (ejbName.equals(secondEjbName)) {
				 ejbModule.getValidation().fail(ejbName, ""multiplyAnnotatedAsBean"", annotationClass.getSimpleName(), secondAnnotation.getSimpleName(), ejbName, beanClass.get().getName());
			 }
		 }
		 if (beanClass.getAnnotation(PersistenceContext.class) == null && beanClass.getAnnotation(Proxy.class) == null && beanClass.get().isInterface()) {
			 ejbModule.getValidation().fail(ejbName, ""interfaceAnnotatedAsBean"", annotationClass.getSimpleName(), beanClass.get().getName());
			 return false;
		 }
		 if (!beanClass.get().isInterface() && isAbstract(beanClass.get().getModifiers())) {
			 ejbModule.getValidation().fail(ejbName, ""abstractAnnotatedAsBean"", annotationClass.getSimpleName(), beanClass.get().getName());
			 return false;
		 }
		 return b;
	 }
 }",1,0,0,0
"public class XMLResultAggregator extends Task implements XMLConstants {
	 protected Vector filesets = new Vector();
	 protected String toFile;
	 protected File toDir;
	 protected Vector transformers = new Vector();
	 public static final String DEFAULT_DIR = ""."";
	 public static final String DEFAULT_FILENAME = ""TESTS-TestSuites.xml"";
	 protected int generatedId = 0;
	 static final String WARNING_IS_POSSIBLY_CORRUPTED = "" is not a valid XML document. It is possibly corrupted."";
	 static final String WARNING_INVALID_ROOT_ELEMENT = "" is not a valid testsuite XML document"";
	 static final String WARNING_EMPTY_FILE = "" is empty.\nThis can be caused by the test JVM exiting unexpectedly"";
	 public AggregateTransformer createReport() {
		 AggregateTransformer transformer = new AggregateTransformer(this);
		 transformers.addElement(transformer);
		 return transformer;
	 }
	 public void setTofile(String value) {
		 toFile = value;
	 }
	 public void setTodir(File value) {
		 toDir = value;
	 }
	 public void addFileSet(FileSet fs) {
		 filesets.addElement(fs);
	 }
	 public void execute() throws BuildException {
		 Element rootElement = createDocument();
		 File destFile = getDestinationFile();
		 try {
			 writeDOMTree(rootElement.getOwnerDocument(), destFile);
		 }
		 catch (IOException e) {
			 throw new BuildException(""Unable to write test aggregate to '"" + destFile + ""'"", e);
		 }
		 Enumeration e = transformers.elements();
		 while (e.hasMoreElements()) {
			 AggregateTransformer transformer = (AggregateTransformer) e.nextElement();
			 transformer.setXmlDocument(rootElement.getOwnerDocument());
			 transformer.transform();
		 }
	 }
	 public File getDestinationFile() {
		 if (toFile == null) {
			 toFile = DEFAULT_FILENAME;
		 }
		 if (toDir == null) {
			 toDir = getProject().resolveFile(DEFAULT_DIR);
		 }
		 return new File(toDir, toFile);
	 }
	 protected File[] getFiles() {
		 Vector v = new Vector();
		 final int size = filesets.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 FileSet fs = (FileSet) filesets.elementAt(i);
			 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
			 ds.scan();
			 String[] f = ds.getIncludedFiles();
			 for (int j = 0;
			 j < f.length;
			 j++) {
				 String pathname = f[j];
				 if (pathname.endsWith("".xml"")) {
					 File file = new File(ds.getBasedir(), pathname);
					 file = getProject().resolveFile(file.getPath());
					 v.addElement(file);
				 }
			 }
		 }
		 File[] files = new File[v.size()];
		 v.copyInto(files);
		 return files;
	 }
	 protected void writeDOMTree(Document doc, File file) throws IOException {
		 OutputStream out = null;
		 PrintWriter wri = null;
		 try {
			 out = new BufferedOutputStream(new FileOutputStream(file));
			 wri = new PrintWriter(new OutputStreamWriter(out, ""UTF8""));
			 wri.write(""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n"");
			 (new DOMElementWriter()).write(doc.getDocumentElement(), wri, 0, "" "");
			 wri.flush();
			 if (wri.checkError()) {
				 throw new IOException(""Error while writing DOM content"");
			 }
		 }
		 finally {
			 FileUtils.close(wri);
			 FileUtils.close(out);
		 }
	 }
	 protected Element createDocument() {
		 DocumentBuilder builder = getDocumentBuilder();
		 Document doc = builder.newDocument();
		 Element rootElement = doc.createElement(TESTSUITES);
		 doc.appendChild(rootElement);
		 generatedId = 0;
		 File[] files = getFiles();
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 File file = files[i];
			 try {
				 log(""Parsing file: '"" + file + ""'"", Project.MSG_VERBOSE);
				 if (file.length() > 0) {
					 Document testsuiteDoc = builder.parse( FileUtils.getFileUtils().toURI(files[i].getAbsolutePath()));
					 Element elem = testsuiteDoc.getDocumentElement();
					 if (TESTSUITE.equals(elem.getNodeName())) {
						 addTestSuite(rootElement, elem);
						 generatedId++;
					 }
					 else {
						 log(""the file "" + file + WARNING_INVALID_ROOT_ELEMENT, Project.MSG_WARN);
					 }
				 }
				 else {
					 log(""the file "" + file + WARNING_EMPTY_FILE, Project.MSG_WARN);
				 }
			 }
			 catch (SAXException e) {
				 log(""The file "" + file + WARNING_IS_POSSIBLY_CORRUPTED, Project.MSG_WARN);
				 log(StringUtils.getStackTrace(e), Project.MSG_DEBUG);
			 }
			 catch (IOException e) {
				 log(""Error while accessing file "" + file + "": "" + e.getMessage(), Project.MSG_ERR);
				 log(""Error while accessing file "" + file + "": "" + e.getMessage(), e, Project.MSG_VERBOSE);
			 }
		 }
		 return rootElement;
	 }
	 protected void addTestSuite(Element root, Element testsuite) {
		 String fullclassname = testsuite.getAttribute(ATTR_NAME);
		 int pos = fullclassname.lastIndexOf('.');
		 String pkgName = (pos == -1) ? """" : fullclassname.substring(0, pos);
		 String classname = (pos == -1) ? fullclassname : fullclassname.substring(pos + 1);
		 Element copy = (Element) DOMUtil.importNode(root, testsuite);
		 copy.setAttribute(ATTR_NAME, classname);
		 copy.setAttribute(ATTR_PACKAGE, pkgName);
		 copy.setAttribute(ATTR_ID, Integer.toString(generatedId));
	 }
	 private static DocumentBuilder getDocumentBuilder() {
		 try {
			 return DocumentBuilderFactory.newInstance().newDocumentBuilder();
		 }
		 catch (Exception exc) {
			 throw new ExceptionInInitializerError(exc);
		 }
	 }
}",0,0,0,0
"public static class ruleDoubleLiteral_return extends ParserRuleReturnScope {
 }
;",0,0,0,0
"public class RStringLiteral extends RegularExpression {
	 public String image;
	 public RStringLiteral() {
	 }
	 public RStringLiteral(Token t, String image) {
		 this.setLine(t.beginLine);
		 this.setColumn(t.beginColumn);
		 this.image = image;
	 }
	 private static int maxStrKind = 0;
	 private static int maxLen = 0;
	 private static int charCnt = 0;
	 private static List charPosKind = new ArrayList();
	 private static int[] maxLenForActive = new int[100];
	 public static String[] allImages;
	 private static int[][] intermediateKinds;
	 private static int[][] intermediateMatchedPos;
	 private static int startStateCnt = 0;
	 private static boolean subString[];
	 private static boolean subStringAtPos[];
	 private static Hashtable[] statesForPos;
	 public static void ReInit() {
		 maxStrKind = 0;
		 maxLen = 0;
		 charPosKind = new ArrayList();
		 maxLenForActive = new int[100];
		 intermediateKinds = null;
		 intermediateMatchedPos = null;
		 startStateCnt = 0;
		 subString = null;
		 subStringAtPos = null;
		 statesForPos = null;
	 }
	 public static void DumpStrLiteralImages(java.io.PrintWriter ostr) {
		 String image;
		 int i;
		 charCnt = 0;
		 ostr.println("""");
		 ostr.println("""");
		 ostr.println(""public static final String[] jjstrLiteralImages = {
			"");
			 if (allImages == null || allImages.length == 0) {
			 ostr.println(""}
			;
			"");
			 return;
		 }
		 allImages[0] = """";
		 for (i = 0;
		 i < allImages.length;
		 i++) {
			 if ((image = allImages[i]) == null || ((LexGen.toSkip[i / 64] & (1L << (i % 64))) == 0L && (LexGen.toMore[i / 64] & (1L << (i % 64))) == 0L && (LexGen.toToken[i / 64] & (1L << (i % 64))) == 0L) || (LexGen.toSkip[i / 64] & (1L << (i % 64))) != 0L || (LexGen.toMore[i / 64] & (1L << (i % 64))) != 0L || LexGen.canReachOnMore[LexGen.lexStates[i]] || ((Options.getIgnoreCase() || LexGen.ignoreCase[i]) && (!image.equals(image.toLowerCase()) || !image.equals(image.toUpperCase())))) {
				 allImages[i] = null;
				 if ((charCnt += 6) > 80) {
					 ostr.println("""");
					 charCnt = 0;
				 }
				 ostr.print(""null, "");
				 continue;
			 }
			 String toPrint = ""\"""";
			 for (int j = 0;
			 j < image.length();
			 j++) {
				 if (image.charAt(j) <= 0xff) toPrint += (""\\"" + Integer.toOctalString((int)image.charAt(j)));
				 else {
					 String hexVal = Integer.toHexString((int)image.charAt(j));
					 if (hexVal.length() == 3) hexVal = ""0"" + hexVal;
					 toPrint += (""\\u"" + hexVal);
				 }
			 }
			 toPrint += (""\"", "");
			 if ((charCnt += toPrint.length()) >= 80) {
				 ostr.println("""");
				 charCnt = 0;
			 }
			 ostr.print(toPrint);
		 }
		 while (++i < LexGen.maxOrdinal) {
			 if ((charCnt += 6) > 80) {
				 ostr.println("""");
				 charCnt = 0;
			 }
			 ostr.print(""null, "");
			 continue;
		 }
	 ostr.println(""}
	;
	"");
 }
 public void GenerateDfa(java.io.PrintWriter ostr, int kind) {
	 String s;
	 Hashtable temp;
	 KindInfo info;
	 int len;
	 if (maxStrKind <= ordinal) maxStrKind = ordinal + 1;
	 if ((len = image.length()) > maxLen) maxLen = len;
	 char c;
	 for (int i = 0;
	 i < len;
	 i++) {
		 if (Options.getIgnoreCase()) s = ("""" + (c = image.charAt(i))).toLowerCase();
		 else s = """" + (c = image.charAt(i));
		 if (!NfaState.unicodeWarningGiven && c > 0xff && !Options.getJavaUnicodeEscape() && !Options.getUserCharStream()) {
			 NfaState.unicodeWarningGiven = true;
			 JavaCCErrors.warning(LexGen.curRE, ""Non-ASCII characters used in regular expression."" + ""Please make sure you use the correct Reader when you create the parser, "" + ""one that can handle your character set."");
		 }
		 if (i >= charPosKind.size()) charPosKind.add(temp = new Hashtable());
		 else temp = (Hashtable)charPosKind.get(i);
		 if ((info = (KindInfo)temp.get(s)) == null) temp.put(s, info = new KindInfo(LexGen.maxOrdinal));
		 if (i + 1 == len) info.InsertFinalKind(ordinal);
		 else info.InsertValidKind(ordinal);
		 if (!Options.getIgnoreCase() && LexGen.ignoreCase[ordinal] && c != Character.toLowerCase(c)) {
			 s = ("""" + image.charAt(i)).toLowerCase();
			 if (i >= charPosKind.size()) charPosKind.add(temp = new Hashtable());
			 else temp = (Hashtable)charPosKind.get(i);
			 if ((info = (KindInfo)temp.get(s)) == null) temp.put(s, info = new KindInfo(LexGen.maxOrdinal));
			 if (i + 1 == len) info.InsertFinalKind(ordinal);
			 else info.InsertValidKind(ordinal);
		 }
		 if (!Options.getIgnoreCase() && LexGen.ignoreCase[ordinal] && c != Character.toUpperCase(c)) {
			 s = ("""" + image.charAt(i)).toUpperCase();
			 if (i >= charPosKind.size()) charPosKind.add(temp = new Hashtable());
			 else temp = (Hashtable)charPosKind.get(i);
			 if ((info = (KindInfo)temp.get(s)) == null) temp.put(s, info = new KindInfo(LexGen.maxOrdinal));
			 if (i + 1 == len) info.InsertFinalKind(ordinal);
			 else info.InsertValidKind(ordinal);
		 }
	 }
	 maxLenForActive[ordinal / 64] = Math.max(maxLenForActive[ordinal / 64], len -1);
	 allImages[ordinal] = image;
 }
 public Nfa GenerateNfa(boolean ignoreCase) {
	 if (image.length() == 1) {
		 RCharacterList temp = new RCharacterList(image.charAt(0));
		 return temp.GenerateNfa(ignoreCase);
	 }
	 NfaState startState = new NfaState();
	 NfaState theStartState = startState;
	 NfaState finalState = null;
	 if (image.length() == 0) return new Nfa(theStartState, theStartState);
	 int i;
	 for (i = 0;
	 i < image.length();
	 i++) {
		 finalState = new NfaState();
		 startState.charMoves = new char[1];
		 startState.AddChar(image.charAt(i));
		 if (Options.getIgnoreCase() || ignoreCase) {
			 startState.AddChar(Character.toLowerCase(image.charAt(i)));
			 startState.AddChar(Character.toUpperCase(image.charAt(i)));
		 }
		 startState.next = finalState;
		 startState = finalState;
	 }
	 return new Nfa(theStartState, finalState);
 }
 static void DumpNullStrLiterals(java.io.PrintWriter ostr) {
	 ostr.println(""{
		"");
		 if (NfaState.generatedStates != 0) ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", 0);
		"");
		 else ostr.println("" return 1;
		"");
	 ostr.println(""}
	"");
 }
 private static int GetStateSetForKind(int pos, int kind) {
	 if (LexGen.mixed[LexGen.lexStateIndex] || NfaState.generatedStates == 0) return -1;
	 Hashtable allStateSets = statesForPos[pos];
	 if (allStateSets == null) return -1;
	 Enumeration e = allStateSets.keys();
	 while (e.hasMoreElements()) {
		 String s = (String)e.nextElement();
		 long[] actives = (long[])allStateSets.get(s);
		 s = s.substring(s.indexOf("", "") + 2);
		 s = s.substring(s.indexOf("", "") + 2);
		 if (s.equals(""null;
		"")) continue;
		 if (actives != null && (actives[kind / 64] & (1L << (kind % 64))) != 0L) {
			 return NfaState.AddStartStateSet(s);
		 }
	 }
	 return -1;
 }
 static String GetLabel(int kind) {
	 RegularExpression re = LexGen.rexprs[kind];
	 if (re instanceof RStringLiteral) return "" \"""" + JavaCCGlobals.add_escapes(((RStringLiteral)re).image) + ""\"""";
	 else if (!re.label.equals("""")) return "" <"" + re.label + "">"";
	 else return "" <token of kind "" + kind + "">"";
 }
 static int GetLine(int kind) {
	 return LexGen.rexprs[kind].getLine();
 }
 static int GetColumn(int kind) {
	 return LexGen.rexprs[kind].getColumn();
 }
 static private boolean StartsWithIgnoreCase(String s1, String s2) {
	 if (s1.length() < s2.length()) return false;
	 for (int i = 0;
	 i < s2.length();
	 i++) {
		 char c1 = s1.charAt(i), c2 = s2.charAt(i);
		 if (c1 != c2 && Character.toLowerCase(c2) != c1 && Character.toUpperCase(c2) != c1) return false;
	 }
	 return true;
 }
 static void FillSubString() {
	 String image;
	 subString = new boolean[maxStrKind + 1];
	 subStringAtPos = new boolean[maxLen];
	 for (int i = 0;
	 i < maxStrKind;
	 i++) {
		 subString[i] = false;
		 if ((image = allImages[i]) == null || LexGen.lexStates[i] != LexGen.lexStateIndex) continue;
		 if (LexGen.mixed[LexGen.lexStateIndex]) {
			 subString[i] = true;
			 subStringAtPos[image.length() - 1] = true;
			 continue;
		 }
		 for (int j = 0;
		 j < maxStrKind;
		 j++) {
			 if (j != i && LexGen.lexStates[j] == LexGen.lexStateIndex && ((String)allImages[j]) != null) {
				 if (((String)allImages[j]).indexOf(image) == 0) {
					 subString[i] = true;
					 subStringAtPos[image.length() - 1] = true;
					 break;
				 }
				 else if (Options.getIgnoreCase() && StartsWithIgnoreCase((String)allImages[j], image)) {
					 subString[i] = true;
					 subStringAtPos[image.length() - 1] = true;
					 break;
				 }
			 }
		 }
	 }
 }
 static void DumpStartWithStates(java.io.PrintWriter ostr) {
	 ostr.println((Options.getStatic() ? ""static "" : """") + ""private int "" + ""jjStartNfaWithStates"" + LexGen.lexStateSuffix + ""(int pos, int kind, int state)"");
	 ostr.println(""{
		"");
		 ostr.println("" jjmatchedKind = kind;
		"");
		 ostr.println("" jjmatchedPos = pos;
		"");
		 if (Options.getDebugTokenManager()) {
			 ostr.println("" debugStream.println(\"" No more string literal token matches are possible.\"");
			"");
			 ostr.println("" debugStream.println(\"" Currently matched the first \"" "" + ""+ (jjmatchedPos + 1) + \"" characters as a \"" + tokenImage[jjmatchedKind] + \"" token.\"");
			"");
		 }
		 ostr.println("" try {
			 curChar = input_stream.readChar();
		 }
		"");
		 ostr.println("" catch(java.io.IOException e) {
			 return pos + 1;
		 }
		"");
		 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println("" + (LexGen.maxLexStates > 1 ? ""\""<\"" + lexStateNames[curLexState] + \"">\"" + "" : """") + ""\""Current character : \"" + "" + ""TokenMgrError.addEscapes(String.valueOf(curChar)) + \"" (\"" + (int)curChar + \"") "" + ""at line \"" + input_stream.getEndLine() + \"" column \"" + input_stream.getEndColumn());
		"");
		 ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""(state, pos + 1);
		"");
	 ostr.println(""}
	"");
 }
 private static boolean boilerPlateDumped = false;
 static void DumpBoilerPlate(java.io.PrintWriter ostr) {
	 ostr.println((Options.getStatic() ? ""static "" : """") + ""private int "" + ""jjStopAtPos(int pos, int kind)"");
	 ostr.println(""{
		"");
		 ostr.println("" jjmatchedKind = kind;
		"");
		 ostr.println("" jjmatchedPos = pos;
		"");
		 if (Options.getDebugTokenManager()) {
			 ostr.println("" debugStream.println(\"" No more string literal token matches are possible.\"");
			"");
			 ostr.println("" debugStream.println(\"" Currently matched the first \"" + (jjmatchedPos + 1) + "" + ""\"" characters as a \"" + tokenImage[jjmatchedKind] + \"" token.\"");
			"");
		 }
		 ostr.println("" return pos + 1;
		"");
	 ostr.println(""}
	"");
 }
 static String[] ReArrange(Hashtable tab) {
	 String[] ret = new String[tab.size()];
	 Enumeration e = tab.keys();
	 int cnt = 0;
	 while (e.hasMoreElements()) {
		 int i = 0, j;
		 String s;
		 char c = (s = (String)e.nextElement()).charAt(0);
		 while (i < cnt && ret[i].charAt(0) < c) i++;
		 if (i < cnt) for (j = cnt - 1;
		 j >= i;
		 j--) ret[j + 1] = ret[j];
		 ret[i] = s;
		 cnt++;
	 }
	 return ret;
 }
 static void DumpDfaCode(java.io.PrintWriter ostr) {
	 Hashtable tab;
	 String key;
	 KindInfo info;
	 int maxLongsReqd = maxStrKind / 64 + 1;
	 int i, j, k;
	 boolean ifGenerated;
	 LexGen.maxLongsReqd[LexGen.lexStateIndex] = maxLongsReqd;
	 if (maxLen == 0) {
		 ostr.println((Options.getStatic() ? ""static "" : """") + ""private int "" + ""jjMoveStringLiteralDfa0"" + LexGen.lexStateSuffix + ""()"");
		 DumpNullStrLiterals(ostr);
		 return;
	 }
	 if (!boilerPlateDumped) {
		 DumpBoilerPlate(ostr);
		 boilerPlateDumped = true;
	 }
	 boolean createStartNfa = false;
	;
	 for (i = 0;
	 i < maxLen;
	 i++) {
		 boolean atLeastOne = false;
		 boolean startNfaNeeded = false;
		 tab = (Hashtable)charPosKind.get(i);
		 String[] keys = ReArrange(tab);
		 ostr.print((Options.getStatic() ? ""static "" : """") + ""private int "" + ""jjMoveStringLiteralDfa"" + i + LexGen.lexStateSuffix + ""("");
		 if (i != 0) {
			 if (i == 1) {
				 for (j = 0;
				 j < maxLongsReqd - 1;
				 j++) if (i <= maxLenForActive[j]) {
					 if (atLeastOne) ostr.print("", "");
					 else atLeastOne = true;
					 ostr.print(""long active"" + j);
				 }
				 if (i <= maxLenForActive[j]) {
					 if (atLeastOne) ostr.print("", "");
					 ostr.print(""long active"" + j);
				 }
			 }
			 else {
				 for (j = 0;
				 j < maxLongsReqd - 1;
				 j++) if (i <= maxLenForActive[j] + 1) {
					 if (atLeastOne) ostr.print("", "");
					 else atLeastOne = true;
					 ostr.print(""long old"" + j + "", long active"" + j);
				 }
				 if (i <= maxLenForActive[j] + 1) {
					 if (atLeastOne) ostr.print("", "");
					 ostr.print(""long old"" + j + "", long active"" + j);
				 }
			 }
		 }
		 ostr.println("")"");
		 ostr.println(""{
			"");
			 if (i != 0) {
				 if (i > 1) {
					 atLeastOne = false;
					 ostr.print("" if (("");
					 for (j = 0;
					 j < maxLongsReqd - 1;
					 j++) if (i <= maxLenForActive[j] + 1) {
						 if (atLeastOne) ostr.print("" | "");
						 else atLeastOne = true;
						 ostr.print(""(active"" + j + "" &= old"" + j + "")"");
					 }
					 if (i <= maxLenForActive[j] + 1) {
						 if (atLeastOne) ostr.print("" | "");
						 ostr.print(""(active"" + j + "" &= old"" + j + "")"");
					 }
					 ostr.println("") == 0L)"");
					 if (!LexGen.mixed[LexGen.lexStateIndex] && NfaState.generatedStates != 0) {
						 ostr.print("" return jjStartNfa"" + LexGen.lexStateSuffix + ""("" + (i - 2) + "", "");
						 for (j = 0;
						 j < maxLongsReqd - 1;
						 j++) if (i <= maxLenForActive[j] + 1) ostr.print(""old"" + j + "", "");
						 else ostr.print(""0L, "");
						 if (i <= maxLenForActive[j] + 1) ostr.println(""old"" + j + "");
						"");
						 else ostr.println(""0L);
						"");
					 }
					 else if (NfaState.generatedStates != 0) ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", "" + (i - 1) + "");
					"");
					 else ostr.println("" return "" + i + "";
					"");
				 }
				 if (i != 0 && Options.getDebugTokenManager()) {
					 ostr.println("" if (jjmatchedKind != 0 && jjmatchedKind != 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "")"");
					 ostr.println("" debugStream.println(\"" Currently matched the first \"" + "" + ""(jjmatchedPos + 1) + \"" characters as a \"" + tokenImage[jjmatchedKind] + \"" token.\"");
					"");
					 ostr.println("" debugStream.println(\"" Possible string literal matches : {
						 \"""");
						 for (int vecs = 0;
						 vecs < maxStrKind / 64 + 1;
						 vecs++) {
							 if (i <= maxLenForActive[vecs]) {
								 ostr.println("" +"");
								 ostr.print("" jjKindsForBitVector("" + vecs + "", "");
								 ostr.print(""active"" + vecs + "") "");
							 }
						 }
					 ostr.println("" + \"" }
					 \"");
					"");
				 }
				 ostr.println("" try {
					 curChar = input_stream.readChar();
				 }
				"");
				 ostr.println("" catch(java.io.IOException e) {
					"");
					 if (!LexGen.mixed[LexGen.lexStateIndex] && NfaState.generatedStates != 0) {
						 ostr.print("" jjStopStringLiteralDfa"" + LexGen.lexStateSuffix + ""("" + (i - 1) + "", "");
						 for (k = 0;
						 k < maxLongsReqd - 1;
						 k++) if (i <= maxLenForActive[k]) ostr.print(""active"" + k + "", "");
						 else ostr.print(""0L, "");
						 if (i <= maxLenForActive[k]) ostr.println(""active"" + k + "");
						"");
						 else ostr.println(""0L);
						"");
						 if (i != 0 && Options.getDebugTokenManager()) {
							 ostr.println("" if (jjmatchedKind != 0 && jjmatchedKind != 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "")"");
							 ostr.println("" debugStream.println(\"" Currently matched the first \"" + "" + ""(jjmatchedPos + 1) + \"" characters as a \"" + tokenImage[jjmatchedKind] + \"" token.\"");
							"");
						 }
						 ostr.println("" return "" + i + "";
						"");
					 }
					 else if (NfaState.generatedStates != 0) ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", "" + (i - 1) + "");
					"");
					 else ostr.println("" return "" + i + "";
					"");
				 ostr.println("" }
				"");
			 }
			 if (i != 0 && Options.getDebugTokenManager()) ostr.println("" debugStream.println("" + (LexGen.maxLexStates > 1 ? ""\""<\"" + lexStateNames[curLexState] + \"">\"" + "" : """") + ""\""Current character : \"" + "" + ""TokenMgrError.addEscapes(String.valueOf(curChar)) + \"" (\"" + (int)curChar + \"") "" + ""at line \"" + input_stream.getEndLine() + \"" column \"" + input_stream.getEndColumn());
			"");
			 ostr.println("" switch(curChar)"");
			 ostr.println("" {
				"");
				 CaseLoop: for (int q = 0;
				 q < keys.length;
				 q++) {
					 key = keys[q];
					 info = (KindInfo)tab.get(key);
					 ifGenerated = false;
					 char c = key.charAt(0);
					 if (i == 0 && c < 128 && info.finalKindCnt != 0 && (NfaState.generatedStates == 0 || !NfaState.CanStartNfaUsingAscii(c))) {
						 int kind;
						 for (j = 0;
						 j < maxLongsReqd;
						 j++) if (info.finalKinds[j] != 0L) break;
						 for (k = 0;
						 k < 64;
						 k++) if ((info.finalKinds[j] & (1L << k)) != 0L && !subString[kind = (j * 64 + k)]) {
							 if ((intermediateKinds != null && intermediateKinds[(j * 64 + k)] != null && intermediateKinds[(j * 64 + k)][i] < (j * 64 + k) && intermediateMatchedPos != null && intermediateMatchedPos[(j * 64 + k)][i] == i) || (LexGen.canMatchAnyChar[LexGen.lexStateIndex] >= 0 && LexGen.canMatchAnyChar[LexGen.lexStateIndex] < (j * 64 + k))) break;
							 else if ((LexGen.toSkip[kind / 64] & (1L << (kind % 64))) != 0L && (LexGen.toSpecial[kind / 64] & (1L << (kind % 64))) == 0L && LexGen.actions[kind] == null && LexGen.newLexState[kind] == null) {
								 LexGen.AddCharToSkip(c, kind);
								 if (Options.getIgnoreCase()) {
									 if (c != Character.toUpperCase(c)) LexGen.AddCharToSkip(Character.toUpperCase(c), kind);
									 if (c != Character.toLowerCase(c)) LexGen.AddCharToSkip(Character.toLowerCase(c), kind);
								 }
								 continue CaseLoop;
							 }
						 }
					 }
					 if (Options.getIgnoreCase()) {
						 if (c != Character.toUpperCase(c)) ostr.println("" case "" + (int)Character.toUpperCase(c) + "":"");
						 if (c != Character.toLowerCase(c)) ostr.println("" case "" + (int)Character.toLowerCase(c) + "":"");
					 }
					 ostr.println("" case "" + (int)c + "":"");
					 long matchedKind;
					 String prefix = (i == 0) ? "" "" : "" "";
					 if (info.finalKindCnt != 0) {
						 for (j = 0;
						 j < maxLongsReqd;
						 j++) {
							 if ((matchedKind = info.finalKinds[j]) == 0L) continue;
							 for (k = 0;
							 k < 64;
							 k++) {
								 if ((matchedKind & (1L << k)) == 0L) continue;
								 if (ifGenerated) {
									 ostr.print("" else if "");
								 }
								 else if (i != 0) ostr.print("" if "");
								 ifGenerated = true;
								 int kindToPrint;
								 if (i != 0) {
									 ostr.println(""((active"" + j + "" & 0x"" + Long.toHexString(1L << k) + ""L) != 0L)"");
								 }
								 if (intermediateKinds != null && intermediateKinds[(j * 64 + k)] != null && intermediateKinds[(j * 64 + k)][i] < (j * 64 + k) && intermediateMatchedPos != null && intermediateMatchedPos[(j * 64 + k)][i] == i) {
									 JavaCCErrors.warning("" \"""" + JavaCCGlobals.add_escapes(allImages[j * 64 + k]) + ""\"" cannot be matched as a string literal token "" + ""at line "" + GetLine(j * 64 + k) + "", column "" + GetColumn(j * 64 + k) + "". It will be matched as "" + GetLabel(intermediateKinds[(j * 64 + k)][i]) + ""."");
									 kindToPrint = intermediateKinds[(j * 64 + k)][i];
								 }
								 else if (i == 0 && LexGen.canMatchAnyChar[LexGen.lexStateIndex] >= 0 && LexGen.canMatchAnyChar[LexGen.lexStateIndex] < (j * 64 + k)) {
									 JavaCCErrors.warning("" \"""" + JavaCCGlobals.add_escapes(allImages[j * 64 + k]) + ""\"" cannot be matched as a string literal token "" + ""at line "" + GetLine(j * 64 + k) + "", column "" + GetColumn(j * 64 + k) + "". It will be matched as "" + GetLabel(LexGen.canMatchAnyChar[LexGen.lexStateIndex]) + ""."");
									 kindToPrint = LexGen.canMatchAnyChar[LexGen.lexStateIndex];
								 }
								 else kindToPrint = j * 64 + k;
								 if (!subString[(j * 64 + k)]) {
									 int stateSetName = GetStateSetForKind(i, j * 64 + k);
									 if (stateSetName != -1) {
										 createStartNfa = true;
										 ostr.println(prefix + ""return jjStartNfaWithStates"" + LexGen.lexStateSuffix + ""("" + i + "", "" + kindToPrint + "", "" + stateSetName + "");
										"");
									 }
									 else ostr.println(prefix + ""return jjStopAtPos"" + ""("" + i + "", "" + kindToPrint + "");
									"");
								 }
								 else {
									 if ((LexGen.initMatch[LexGen.lexStateIndex] != 0 && LexGen.initMatch[LexGen.lexStateIndex] != Integer.MAX_VALUE) || i != 0) {
										 ostr.println("" {
											"");
											 ostr.println(prefix + ""jjmatchedKind = "" + kindToPrint + "";
											"");
											 ostr.println(prefix + ""jjmatchedPos = "" + i + "";
											"");
										 ostr.println("" }
										"");
									 }
									 else ostr.println(prefix + ""jjmatchedKind = "" + kindToPrint + "";
									"");
								 }
							 }
						 }
					 }
					 if (info.validKindCnt != 0) {
						 atLeastOne = false;
						 if (i == 0) {
							 ostr.print("" return "");
							 ostr.print(""jjMoveStringLiteralDfa"" + (i + 1) + LexGen.lexStateSuffix + ""("");
							 for (j = 0;
							 j < maxLongsReqd - 1;
							 j++) if ((i + 1) <= maxLenForActive[j]) {
								 if (atLeastOne) ostr.print("", "");
								 else atLeastOne = true;
								 ostr.print(""0x"" + Long.toHexString(info.validKinds[j]) + ""L"");
							 }
							 if ((i + 1) <= maxLenForActive[j]) {
								 if (atLeastOne) ostr.print("", "");
								 ostr.print(""0x"" + Long.toHexString(info.validKinds[j]) + ""L"");
							 }
							 ostr.println("");
							"");
						 }
						 else {
							 ostr.print("" return "");
							 ostr.print(""jjMoveStringLiteralDfa"" + (i + 1) + LexGen.lexStateSuffix + ""("");
							 for (j = 0;
							 j < maxLongsReqd - 1;
							 j++) if ((i + 1) <= maxLenForActive[j] + 1) {
								 if (atLeastOne) ostr.print("", "");
								 else atLeastOne = true;
								 if (info.validKinds[j] != 0L) ostr.print(""active"" + j + "", 0x"" + Long.toHexString(info.validKinds[j]) + ""L"");
								 else ostr.print(""active"" + j + "", 0L"");
							 }
							 if ((i + 1) <= maxLenForActive[j] + 1) {
								 if (atLeastOne) ostr.print("", "");
								 if (info.validKinds[j] != 0L) ostr.print(""active"" + j + "", 0x"" + Long.toHexString(info.validKinds[j]) + ""L"");
								 else ostr.print(""active"" + j + "", 0L"");
							 }
							 ostr.println("");
							"");
						 }
					 }
					 else {
						 if (i == 0 && LexGen.mixed[LexGen.lexStateIndex]) {
							 if (NfaState.generatedStates != 0) ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", 0);
							"");
							 else ostr.println("" return 1;
							"");
						 }
						 else if (i != 0) {
							 ostr.println("" break;
							"");
							 startNfaNeeded = true;
						 }
					 }
				 }
				 ostr.println("" default :"");
				 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println(\"" No string literal matches possible.\"");
				"");
				 if (NfaState.generatedStates != 0) {
					 if (i == 0) {
						 ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", 0);
						"");
					 }
					 else {
						 ostr.println("" break;
						"");
						 startNfaNeeded = true;
					 }
				 }
				 else {
					 ostr.println("" return "" + (i + 1) + "";
					"");
				 }
			 ostr.println("" }
			"");
			 if (i != 0) {
				 if (startNfaNeeded) {
					 if (!LexGen.mixed[LexGen.lexStateIndex] && NfaState.generatedStates != 0) {
						 ostr.print("" return jjStartNfa"" + LexGen.lexStateSuffix + ""("" + (i - 1) + "", "");
						 for (k = 0;
						 k < maxLongsReqd - 1;
						 k++) if (i <= maxLenForActive[k]) ostr.print(""active"" + k + "", "");
						 else ostr.print(""0L, "");
						 if (i <= maxLenForActive[k]) ostr.println(""active"" + k + "");
						"");
						 else ostr.println(""0L);
						"");
					 }
					 else if (NfaState.generatedStates != 0) ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", "" + i + "");
					"");
					 else ostr.println("" return "" + (i + 1) + "";
					"");
				 }
			 }
		 ostr.println(""}
		"");
	 }
	 if (!LexGen.mixed[LexGen.lexStateIndex] && NfaState.generatedStates != 0 && createStartNfa) DumpStartWithStates(ostr);
 }
 static final int GetStrKind(String str) {
	 for (int i = 0;
	 i < maxStrKind;
	 i++) {
		 if (LexGen.lexStates[i] != LexGen.lexStateIndex) continue;
		 String image = allImages[i];
		 if (image != null && image.equals(str)) return i;
	 }
	 return Integer.MAX_VALUE;
 }
 static void GenerateNfaStartStates(java.io.PrintWriter ostr, NfaState initialState) {
	 boolean[] seen = new boolean[NfaState.generatedStates];
	 Hashtable stateSets = new Hashtable();
	 String stateSetString = """";
	 int i, j, kind, jjmatchedPos = 0;
	 int maxKindsReqd = maxStrKind / 64 + 1;
	 long[] actives;
	 List newStates = new ArrayList();
	 List oldStates = null, jjtmpStates;
	 statesForPos = new Hashtable[maxLen];
	 intermediateKinds = new int[maxStrKind + 1][];
	 intermediateMatchedPos = new int[maxStrKind + 1][];
	 for (i = 0;
	 i < maxStrKind;
	 i++) {
		 if (LexGen.lexStates[i] != LexGen.lexStateIndex) continue;
		 String image = allImages[i];
		 if (image == null || image.length() < 1) continue;
		 try {
			 if ((oldStates = (List)initialState.epsilonMoves.clone()) == null || oldStates.size() == 0) {
				 DumpNfaStartStatesCode(statesForPos, ostr);
				 return;
			 }
		 }
		 catch(Exception e) {
			 JavaCCErrors.semantic_error(""Error cloning state vector"");
		 }
		 intermediateKinds[i] = new int[image.length()];
		 intermediateMatchedPos[i] = new int[image.length()];
		 jjmatchedPos = 0;
		 kind = Integer.MAX_VALUE;
		 for (j = 0;
		 j < image.length();
		 j++) {
			 if (oldStates == null || oldStates.size() <= 0) {
				 kind = intermediateKinds[i][j] = intermediateKinds[i][j - 1];
				 jjmatchedPos = intermediateMatchedPos[i][j] = intermediateMatchedPos[i][j - 1];
			 }
			 else {
				 kind = NfaState.MoveFromSet(image.charAt(j), oldStates, newStates);
				 oldStates.clear();
				 if (j == 0 && kind != Integer.MAX_VALUE && LexGen.canMatchAnyChar[LexGen.lexStateIndex] != -1 && kind > LexGen.canMatchAnyChar[LexGen.lexStateIndex]) kind = LexGen.canMatchAnyChar[LexGen.lexStateIndex];
				 if (GetStrKind(image.substring(0, j + 1)) < kind) {
					 intermediateKinds[i][j] = kind = Integer.MAX_VALUE;
					 jjmatchedPos = 0;
				 }
				 else if (kind != Integer.MAX_VALUE) {
					 intermediateKinds[i][j] = kind;
					 jjmatchedPos = intermediateMatchedPos[i][j] = j;
				 }
				 else if (j == 0) kind = intermediateKinds[i][j] = Integer.MAX_VALUE;
				 else {
					 kind = intermediateKinds[i][j] = intermediateKinds[i][j - 1];
					 jjmatchedPos = intermediateMatchedPos[i][j] = intermediateMatchedPos[i][j - 1];
				 }
				 stateSetString = NfaState.GetStateSetString(newStates);
			 }
			 if (kind == Integer.MAX_VALUE && (newStates == null || newStates.size() == 0)) continue;
			 int p;
			 if (stateSets.get(stateSetString) == null) {
				 stateSets.put(stateSetString, stateSetString);
				 for (p = 0;
				 p < newStates.size();
				 p++) {
					 if (seen[((NfaState)newStates.get(p)).stateName]) ((NfaState)newStates.get(p)).inNextOf++;
					 else seen[((NfaState)newStates.get(p)).stateName] = true;
				 }
			 }
			 else {
				 for (p = 0;
				 p < newStates.size();
				 p++) seen[((NfaState)newStates.get(p)).stateName] = true;
			 }
			 jjtmpStates = oldStates;
			 oldStates = newStates;
			 (newStates = jjtmpStates).clear();
			 if (statesForPos[j] == null) statesForPos[j] = new Hashtable();
			 if ((actives = ((long[])statesForPos[j].get(kind + "", "" + jjmatchedPos + "", "" + stateSetString))) == null) {
				 actives = new long[maxKindsReqd];
				 statesForPos[j].put(kind + "", "" + jjmatchedPos + "", "" + stateSetString, actives);
			 }
			 actives[i / 64] |= 1L << (i % 64);
		 }
	 }
	 DumpNfaStartStatesCode(statesForPos, ostr);
 }
 static void DumpNfaStartStatesCode(Hashtable[] statesForPos, java.io.PrintWriter ostr) {
	 if (maxStrKind == 0) {
		 return;
	 }
	 int i, maxKindsReqd = maxStrKind / 64 + 1;
	 boolean condGenerated = false;
	 int ind = 0;
	 ostr.print(""private"" + (Options.getStatic() ? "" static"" : """") + "" final int jjStopStringLiteralDfa"" + LexGen.lexStateSuffix + ""(int pos, "");
	 for (i = 0;
	 i < maxKindsReqd - 1;
	 i++) ostr.print(""long active"" + i + "", "");
	 ostr.println(""long active"" + i + "")\n{
		"");
		 if (Options.getDebugTokenManager()) ostr.println("" debugStream.println(\"" No more string literal token matches are possible.\"");
		"");
		 ostr.println("" switch (pos)\n {
			"");
			 for (i = 0;
			 i < maxLen - 1;
			 i++) {
				 if (statesForPos[i] == null) continue;
				 ostr.println("" case "" + i + "":"");
				 Enumeration e = statesForPos[i].keys();
				 while (e.hasMoreElements()) {
					 String stateSetString = (String)e.nextElement();
					 long[] actives = (long[])statesForPos[i].get(stateSetString);
					 for (int j = 0;
					 j < maxKindsReqd;
					 j++) {
						 if (actives[j] == 0L) continue;
						 if (condGenerated) ostr.print("" || "");
						 else ostr.print("" if ("");
						 condGenerated = true;
						 ostr.print(""(active"" + j + "" & 0x"" + Long.toHexString(actives[j]) + ""L) != 0L"");
					 }
					 if (condGenerated) {
						 ostr.println("")"");
						 String kindStr = stateSetString.substring(0, ind = stateSetString.indexOf("", ""));
						 String afterKind = stateSetString.substring(ind + 2);
						 int jjmatchedPos = Integer.parseInt( afterKind.substring(0, afterKind.indexOf("", "")));
						 if (!kindStr.equals(String.valueOf(Integer.MAX_VALUE))) ostr.println("" {
							"");
							 if (!kindStr.equals(String.valueOf(Integer.MAX_VALUE))) {
								 if (i == 0) {
									 ostr.println("" jjmatchedKind = "" + kindStr + "";
									"");
									 if ((LexGen.initMatch[LexGen.lexStateIndex] != 0 && LexGen.initMatch[LexGen.lexStateIndex] != Integer.MAX_VALUE)) ostr.println("" jjmatchedPos = 0;
									"");
								 }
								 else if (i == jjmatchedPos) {
									 if (subStringAtPos[i]) {
										 ostr.println("" if (jjmatchedPos != "" + i + "")"");
										 ostr.println("" {
											"");
											 ostr.println("" jjmatchedKind = "" + kindStr + "";
											"");
											 ostr.println("" jjmatchedPos = "" + i + "";
											"");
										 ostr.println("" }
										"");
									 }
									 else {
										 ostr.println("" jjmatchedKind = "" + kindStr + "";
										"");
										 ostr.println("" jjmatchedPos = "" + i + "";
										"");
									 }
								 }
								 else {
									 if (jjmatchedPos > 0) ostr.println("" if (jjmatchedPos < "" + jjmatchedPos + "")"");
									 else ostr.println("" if (jjmatchedPos == 0)"");
									 ostr.println("" {
										"");
										 ostr.println("" jjmatchedKind = "" + kindStr + "";
										"");
										 ostr.println("" jjmatchedPos = "" + jjmatchedPos + "";
										"");
									 ostr.println("" }
									"");
								 }
							 }
							 kindStr = stateSetString.substring(0, ind = stateSetString.indexOf("", ""));
							 afterKind = stateSetString.substring(ind + 2);
							 stateSetString = afterKind.substring( afterKind.indexOf("", "") + 2);
							 if (stateSetString.equals(""null;
							"")) ostr.println("" return -1;
							"");
							 else ostr.println("" return "" + NfaState.AddStartStateSet(stateSetString) + "";
							"");
						 if (!kindStr.equals(String.valueOf(Integer.MAX_VALUE))) ostr.println("" }
						"");
						 condGenerated = false;
					 }
				 }
				 ostr.println("" return -1;
				"");
			 }
			 ostr.println("" default :"");
			 ostr.println("" return -1;
			"");
		 ostr.println("" }
		"");
	 ostr.println(""}
	"");
	 ostr.print(""private"" + (Options.getStatic() ? "" static"" : """") + "" final int jjStartNfa"" + LexGen.lexStateSuffix + ""(int pos, "");
	 for (i = 0;
	 i < maxKindsReqd - 1;
	 i++) ostr.print(""long active"" + i + "", "");
	 ostr.println(""long active"" + i + "")\n{
		"");
		 if (LexGen.mixed[LexGen.lexStateIndex]) {
			 if (NfaState.generatedStates != 0) ostr.println("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + NfaState.InitStateName() + "", pos + 1);
			"");
			 else ostr.println("" return pos + 1;
			"");
		 ostr.println(""}
		"");
		 return;
	 }
	 ostr.print("" return jjMoveNfa"" + LexGen.lexStateSuffix + ""("" + ""jjStopStringLiteralDfa"" + LexGen.lexStateSuffix + ""(pos, "");
	 for (i = 0;
	 i < maxKindsReqd - 1;
	 i++) ostr.print(""active"" + i + "", "");
	 ostr.print(""active"" + i + "")"");
	 ostr.println("", pos + 1);
	"");
 ostr.println(""}
"");
 }
 public static void reInit() {
 ReInit();
 charCnt = 0;
 allImages = null;
 boilerPlateDumped = false;
 }
 public StringBuffer dump(int indent, Set alreadyDumped) {
 StringBuffer sb = super.dump(indent, alreadyDumped).append(' ').append(image);
 return sb;
 }
 public String toString() {
 return super.toString() + "" - "" + image;
 }
}",1,0,0,0
"protected void setOutputStream(OutputStream outputStream) {
	 this.outputStream = outputStream;
 }",0,0,0,0
"public String dirtyString() {
	 StringBuilder sb = new StringBuilder();
	 for (Integer cfId : cfLastWrite.keySet()) {
		 CFMetaData m = Schema.instance.getCFMetaData(cfId);
		 sb.append(m == null ? ""<deleted>"" : m.cfName).append("" ("").append(cfId).append(""), "");
	 }
	 return sb.toString();
 }",0,0,0,0
"public String toString() {
	StringBuffer strEditor = new StringBuffer();
	strEditor.append(""<div>"");
	String encodedValue = escapeXml(value);
	setInputName(inputName);
	if (Compatibility.isCompatibleBrowser(request)) {
		strEditor.append(createInputForVariable(instanceName, inputName,encodedValue));
		String configStr = fckConfig.getUrlParams();
		if (Utils.isNotEmpty(configStr))strEditor.append(createInputForVariable(instanceName.concat(""___Config""), null, configStr));
		StringBuffer editorLink = new StringBuffer(request.getContextPath());
		editorLink.append(basePath);
		editorLink.append(""/editor/fckeditor.html?InstanceName="").append(instanceName);
		if (Utils.isNotEmpty(toolbarSet))editorLink.append(""&amp;
		Toolbar="").append(toolbarSet);
		XHtmlTagTool iframeTag = new XHtmlTagTool(""iframe"",XHtmlTagTool.SPACE);
		iframeTag.addAttribute(""id"", instanceName.concat(""___Frame""));
		iframeTag.addAttribute(""src"", editorLink.toString());
		iframeTag.addAttribute(""width"", width);
		iframeTag.addAttribute(""height"", height);
		iframeTag.addAttribute(""frameborder"", ""0"");
		iframeTag.addAttribute(""scrolling"", ""no"");
		strEditor.append(iframeTag);
	}
	 else {
		XHtmlTagTool textareaTag = new XHtmlTagTool(""textarea"",encodedValue);
		textareaTag.addAttribute(""name"", inputName);
		textareaTag.addAttribute(""rows"", ""4"");
		textareaTag.addAttribute(""cols"", ""40"");
		textareaTag.addAttribute(""wrap"", ""virtual"");
		textareaTag.addAttribute(""style"", ""width: "".concat(width).concat("";
		 height: "").concat(height));
	}
	strEditor.append(""</div>"");
	return strEditor.toString();
}",0,0,1,0
"public static class Builder {
	 private String destination;
	 public Builder destination(String destination) {
		 this.destination = destination;
		 this.__explicitlySet__.add(""destination"");
		 return this;
	 }
	 private DestinationType destinationType;
	 public Builder destinationType(DestinationType destinationType) {
		 this.destinationType = destinationType;
		 this.__explicitlySet__.add(""destinationType"");
		 return this;
	 }
	 private IcmpOptions icmpOptions;
	 public Builder icmpOptions(IcmpOptions icmpOptions) {
		 this.icmpOptions = icmpOptions;
		 this.__explicitlySet__.add(""icmpOptions"");
		 return this;
	 }
	 private Boolean isStateless;
	 public Builder isStateless(Boolean isStateless) {
		 this.isStateless = isStateless;
		 this.__explicitlySet__.add(""isStateless"");
		 return this;
	 }
	 private String protocol;
	 public Builder protocol(String protocol) {
		 this.protocol = protocol;
		 this.__explicitlySet__.add(""protocol"");
		 return this;
	 }
	 private TcpOptions tcpOptions;
	 public Builder tcpOptions(TcpOptions tcpOptions) {
		 this.tcpOptions = tcpOptions;
		 this.__explicitlySet__.add(""tcpOptions"");
		 return this;
	 }
	 private UdpOptions udpOptions;
	 public Builder udpOptions(UdpOptions udpOptions) {
		 this.udpOptions = udpOptions;
		 this.__explicitlySet__.add(""udpOptions"");
		 return this;
	 }
	 private final java.util.Set<String> __explicitlySet__ = new java.util.HashSet<String>();
	 public EgressSecurityRule build() {
		 EgressSecurityRule __instance__ = new EgressSecurityRule( destination, destinationType, icmpOptions, isStateless, protocol, tcpOptions, udpOptions);
		 __instance__.__explicitlySet__.addAll(__explicitlySet__);
		 return __instance__;
	 }
	 public Builder copy(EgressSecurityRule o) {
		 Builder copiedBuilder = destination(o.getDestination()) .destinationType(o.getDestinationType()) .icmpOptions(o.getIcmpOptions()) .isStateless(o.getIsStateless()) .protocol(o.getProtocol()) .tcpOptions(o.getTcpOptions()) .udpOptions(o.getUdpOptions());
		 copiedBuilder.__explicitlySet__.retainAll(o.__explicitlySet__);
		 return copiedBuilder;
	 }
 }",0,0,0,0
"static Scanner partialScanner(char[] content, int offset, int length, int columnNumber, int lineNumber) throws ParsingException;",0,0,0,1
"protected static class OnheapDecodedCell implements ExtendedCell {
	 private static final long FIXED_OVERHEAD = ClassSize.align(ClassSize.OBJECT + (3 * ClassSize.REFERENCE) + (2 * Bytes.SIZEOF_LONG) + (7 * Bytes.SIZEOF_INT) + (Bytes.SIZEOF_SHORT) + (2 * Bytes.SIZEOF_BYTE) + (3 * ClassSize.ARRAY));
	 private byte[] keyOnlyBuffer;
	 private short rowLength;
	 private int familyOffset;
	 private byte familyLength;
	 private int qualifierOffset;
	 private int qualifierLength;
	 private long timestamp;
	 private byte typeByte;
	 private byte[] valueBuffer;
	 private int valueOffset;
	 private int valueLength;
	 private byte[] tagsBuffer;
	 private int tagsOffset;
	 private int tagsLength;
	 private long seqId;
	 protected OnheapDecodedCell(byte[] keyBuffer, short rowLength, int familyOffset, byte familyLength, int qualOffset, int qualLength, long timeStamp, byte typeByte, byte[] valueBuffer, int valueOffset, int valueLen, long seqId, byte[] tagsBuffer, int tagsOffset, int tagsLength) {
		 this.keyOnlyBuffer = keyBuffer;
		 this.rowLength = rowLength;
		 this.familyOffset = familyOffset;
		 this.familyLength = familyLength;
		 this.qualifierOffset = qualOffset;
		 this.qualifierLength = qualLength;
		 this.timestamp = timeStamp;
		 this.typeByte = typeByte;
		 this.valueBuffer = valueBuffer;
		 this.valueOffset = valueOffset;
		 this.valueLength = valueLen;
		 this.tagsBuffer = tagsBuffer;
		 this.tagsOffset = tagsOffset;
		 this.tagsLength = tagsLength;
		 setSequenceId(seqId);
	 }
	 public byte[] getRowArray() {
		 return keyOnlyBuffer;
	 }
	 public byte[] getFamilyArray() {
		 return keyOnlyBuffer;
	 }
	 public byte[] getQualifierArray() {
		 return keyOnlyBuffer;
	 }
	 public int getRowOffset() {
		 return Bytes.SIZEOF_SHORT;
	 }
	 public short getRowLength() {
		 return rowLength;
	 }
	 public int getFamilyOffset() {
		 return familyOffset;
	 }
	 public byte getFamilyLength() {
		 return familyLength;
	 }
	 public int getQualifierOffset() {
		 return qualifierOffset;
	 }
	 public int getQualifierLength() {
		 return qualifierLength;
	 }
	 public long getTimestamp() {
		 return timestamp;
	 }
	 public byte getTypeByte() {
		 return typeByte;
	 }
	 public long getSequenceId() {
		 return seqId;
	 }
	 public byte[] getValueArray() {
		 return this.valueBuffer;
	 }
	 public int getValueOffset() {
		 return valueOffset;
	 }
	 public int getValueLength() {
		 return valueLength;
	 }
	 public byte[] getTagsArray() {
		 return this.tagsBuffer;
	 }
	 public int getTagsOffset() {
		 return this.tagsOffset;
	 }
	 public int getTagsLength() {
		 return tagsLength;
	 }
	 public String toString() {
		 return KeyValue.keyToString(this.keyOnlyBuffer, 0, KeyValueUtil.keyLength(this)) + ""/vlen="" + getValueLength() + ""/seqid="" + seqId;
	 }
	 public void setSequenceId(long seqId) {
		 this.seqId = seqId;
	 }
	 public long heapSize() {
		 return FIXED_OVERHEAD + rowLength + familyLength + qualifierLength + valueLength + tagsLength;
	 }
	 public int write(OutputStream out, boolean withTags) throws IOException {
		 int lenToWrite = getSerializedSize(withTags);
		 ByteBufferUtils.putInt(out, keyOnlyBuffer.length);
		 ByteBufferUtils.putInt(out, valueLength);
		 out.write(keyOnlyBuffer);
		 out.write(this.valueBuffer, this.valueOffset, this.valueLength);
		 if (withTags && this.tagsLength > 0) {
			 out.write((byte) (0xff & (this.tagsLength >> 8)));
			 out.write((byte) (0xff & this.tagsLength));
			 out.write(this.tagsBuffer, this.tagsOffset, this.tagsLength);
		 }
		 return lenToWrite;
	 }
	 public int getSerializedSize(boolean withTags) {
		 return KeyValueUtil.length(rowLength, familyLength, qualifierLength, valueLength, tagsLength, withTags);
	 }
	 public void write(ByteBuffer buf, int offset) {
		 throw new UnsupportedOperationException();
	 }
	 public void setTimestamp(long ts) throws IOException {
		 throw new UnsupportedOperationException();
	 }
	 public void setTimestamp(byte[] ts) throws IOException {
		 throw new UnsupportedOperationException();
	 }
	 public ExtendedCell deepClone() {
		 throw new UnsupportedOperationException();
	 }
 }",1,1,0,0
"public class ImportsAwareClipboardAction extends TextEditorAction {
	public static class Factory implements IClipboardActionFactory {
		private MembersInjector<ImportsAwareClipboardAction> injector;
		public TextEditorAction create(ResourceBundle bundle, String prefix, ITextEditor editor, int operationCode) {
			ImportsAwareClipboardAction action = new ImportsAwareClipboardAction(bundle, prefix, editor, operationCode);
			injector.injectMembers(action);
			return action;
		}
	}
	private static final XbaseClipboardTransfer TRANSFER_INSTANCE = new XbaseClipboardTransfer();
	private final int operationCode;
	private ITextOperationTarget textOperationTarget;
	private ImportsUtil importsUtil;
	public ImportsAwareClipboardAction(ResourceBundle bundle, String prefix, ITextEditor editor,final int operationCode) {
		super(bundle, prefix, editor);
		this.operationCode = operationCode;
		if (operationCode == ITextOperationTarget.CUT) {
			setHelpContextId(IAbstractTextEditorHelpContextIds.CUT_ACTION);
			setActionDefinitionId(IWorkbenchCommandConstants.EDIT_CUT);
		}
		 else if (operationCode == ITextOperationTarget.COPY) {
			setHelpContextId(IAbstractTextEditorHelpContextIds.COPY_ACTION);
			setActionDefinitionId(IWorkbenchCommandConstants.EDIT_COPY);
		}
		 else if (operationCode == ITextOperationTarget.PASTE) {
			setHelpContextId(IAbstractTextEditorHelpContextIds.PASTE_ACTION);
			setActionDefinitionId(IWorkbenchCommandConstants.EDIT_PASTE);
		}
		 else {
			Assert.isTrue(false, ""Invalid operation code"");
		 }
		update();
	}
	protected void internalDoOperation() {
		if (operationCode == ITextOperationTarget.PASTE) {
			doPasteWithImportsOperation();
		}
		 else {
			doCutCopyWithImportsOperation();
		}
	}
	private void doCutCopyWithImportsOperation() {
		try {
			final XbaseClipboardData cbData = createClipboardData();
			if (cbData != null ) {
				ClipboardUtil.clipboardOperation(new Function<Clipboard, Boolean>() {
					public Boolean apply(Clipboard clipboard) {
						Map<Object,Transfer> payload = newLinkedHashMap();
						payload.put(cbData, TRANSFER_INSTANCE);
						TextTransfer textTransfer = TextTransfer.getInstance();
						String textData = (String) clipboard.getContents(textTransfer);
						if (textData == null || textData.isEmpty()) {
							return Boolean.FALSE;
						}
						payload.put(textData, textTransfer);
						RTFTransfer rtfTransfer = RTFTransfer.getInstance();
						String rtfData = (String) clipboard.getContents(rtfTransfer);
						if (rtfData != null && !rtfData.isEmpty()) {
							payload.put(rtfData, rtfTransfer);
						}
						List<Object> datas = newArrayList();
						List<Transfer> dataTypes = newArrayList();
						for (Entry<Object, Transfer> entry : payload.entrySet()) {
							datas.add(entry.getKey());
							dataTypes.add(entry.getValue());
						}
						try {
							clipboard.setContents(datas.toArray(), dataTypes.toArray(new Transfer[] {
							}
							));
							return Boolean.TRUE;
						}
						 catch (SWTError e) {
							if (e.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {
								throw e;
							}
							if (MessageDialog.openQuestion(getShell(), ActionMessages.CopyQualifiedNameAction_ErrorTitle, ActionMessages.CopyQualifiedNameAction_ErrorDescription)) {
								clipboard.setContents(datas.toArray(), dataTypes.toArray(new Transfer[] {
								}
								));
								return Boolean.TRUE;
							}
							return Boolean.FALSE;
						}
					}
				}
				);
			}
		}
		 finally {
			textOperationTarget.doOperation(operationCode);
		}
	}
	private void doPasteWithImportsOperation() {
		XbaseClipboardData xbaseClipboardData = ClipboardUtil.clipboardOperation(new Function<Clipboard, XbaseClipboardData>() {
			public XbaseClipboardData apply(Clipboard input) {
				Object content = input.getContents(TRANSFER_INSTANCE);
				if (content instanceof XbaseClipboardData) {
					return (XbaseClipboardData) content;
				}
				return null;
			}
		}
		);
		JavaImportData javaImportsContent = ClipboardUtil.getJavaImportsContent();
		String textFromClipboard = ClipboardUtil.getTextFromClipboard();
		XtextEditor xtextEditor = EditorUtils.getXtextEditor(getTextEditor());
		boolean addImports = shouldAddImports(xtextEditor.getDocument(), caretOffset(xtextEditor));
		if (xbaseClipboardData != null && !sameTarget(xbaseClipboardData)) {
			doPasteXbaseCode(xbaseClipboardData, addImports);
		}
		 else if (javaImportsContent != null) {
			doPasteJavaCode(textFromClipboard, javaImportsContent, addImports);
		}
		 else {
			textOperationTarget.doOperation(operationCode);
		}
	}
	protected boolean shouldAddImports(IDocument document, int caretOffset) {
		if (caretOffset == 0) {
			return true;
		}
		String typeRight = IDocument.DEFAULT_CONTENT_TYPE;
		String typeLeft = IDocument.DEFAULT_CONTENT_TYPE;
		try {
			typeRight = TextUtilities.getContentType(document, IDocumentExtension3.DEFAULT_PARTITIONING, caretOffset,false);
			typeLeft = TextUtilities.getContentType(document, IDocumentExtension3.DEFAULT_PARTITIONING,caretOffset > 0 ? caretOffset - 1 : caretOffset, false);
		}
		 catch (BadLocationException exception) {
		}
		if (COMMENT_PARTITION.equals(typeRight) || STRING_LITERAL_PARTITION.equals(typeRight)|| SL_COMMENT_PARTITION.equals(typeRight) || ""__rich_string"".equals(typeRight)) {
			if (typeLeft.equals(typeRight))return false;
		}
		return true;
	}
	private int caretOffset(final XtextEditor xtextEditor) {
		ISourceViewer sourceViewer = xtextEditor.getInternalSourceViewer();
		int caretOffset = sourceViewer.getTextWidget().getCaretOffset();
		if (sourceViewer instanceof ITextViewerExtension5) {
			ITextViewerExtension5 extension = (ITextViewerExtension5) sourceViewer;
			caretOffset = extension.widgetOffset2ModelOffset(caretOffset);
		}
		return caretOffset;
	}
	private void doPasteXbaseCode(XbaseClipboardData xbaseClipboardData, boolean withImports) {
		IRewriteTarget target = getTextEditor().getAdapter(IRewriteTarget.class);
		if (target != null) {
			target.beginCompoundChange();
		}
		try {
			textOperationTarget.doOperation(operationCode);
			if (withImports) {
				importsUtil.addImports(xbaseClipboardData.getImports(), xbaseClipboardData.getStaticImports(),xbaseClipboardData.getExtensionImports(), getXtextDocument());
			}
		}
		 catch (Exception e) {
			XbaseActivator.getInstance().getLog().log(new Status(IStatus.ERROR,XbaseActivator.getInstance().getBundle().getSymbolicName(), ""Unexpected internal error: "", e));
		}
		 finally {
			if (target != null) {
				target.endCompoundChange();
			}
		}
	}
	private void doPasteJavaCode(String textFromClipboard, JavaImportData javaImportsContent, boolean withImports) {
		IRewriteTarget target = getTextEditor().getAdapter(IRewriteTarget.class);
		if (target != null) {
			target.beginCompoundChange();
		}
		try {
			textOperationTarget.doOperation(operationCode);
			if (withImports) {
				importsUtil.addImports(javaImportsContent.getImports(), javaImportsContent.getStaticImports(),new String[] {
				}
				, getXtextDocument());
			}
		}
		 catch (Exception e) {
			XbaseActivator.getInstance().getLog().log(new Status(IStatus.ERROR,XbaseActivator.getInstance().getBundle().getSymbolicName(), ""Unexpected internal error: "", e));
		}
		 finally {
			if (target != null) {
				target.endCompoundChange();
			}
		}
	}
	private boolean sameTarget(XbaseClipboardData xbaseClipboardData) {
		IEditorInput editorInput = getTextEditor().getEditorInput();
		if (editorInput == null) {
			return false;
		}
		return xbaseClipboardData.getSourceIndentifier().equals(editorInput.toString());
	}
	private XbaseClipboardData createClipboardData() {
		try {
			IEditorInput editorInput = getTextEditor().getEditorInput();
			final String sourceIdentifier = editorInput != null ? editorInput.toString() : ""nullEditorInput"";
			IXtextDocument document = getXtextDocument();
			final ISelection selection = getTextEditor().getSelectionProvider().getSelection();
			if (selection instanceof ITextSelection && !selection.isEmpty()) {
				final ITextSelection textSelection = (ITextSelection) selection;
				return document.readOnly(new IUnitOfWork<XbaseClipboardData, XtextResource>() {
					public XbaseClipboardData exec(XtextResource state) throws Exception {
						ITextRegion region = new TextRegion(textSelection.getOffset(), textSelection.getLength() - 1);
						Triple<Set<String>, Set<String>, Set<String>> imports = importsUtil.collectImports(state,region);
						XbaseClipboardData clipboardData = new XbaseClipboardData(sourceIdentifier,Iterables.toArray(imports.getFirst(), String.class),Iterables.toArray(imports.getSecond(), String.class),Iterables.toArray(imports.getThird(), String.class));
						return clipboardData;
					}
				}
				);
			}
		}
		 catch (Exception e) {
			return null;
		}
		return null;
	}
	private IXtextDocument getXtextDocument() {
		XtextEditor xtextEditor = EditorUtils.getXtextEditor(getTextEditor());
		IXtextDocument document = xtextEditor.getDocument();
		return document;
	}
	public void update() {
		super.update();
		if (isModifyOperation() && !canModifyEditor()) {
			setEnabled(false);
			return;
		}
		ITextEditor editor = getTextEditor();
		if (textOperationTarget == null && editor != null)textOperationTarget = editor.getAdapter(ITextOperationTarget.class);
		boolean isEnabled = (textOperationTarget != null && textOperationTarget.canDoOperation(getOperationCode()));
		setEnabled(isEnabled);
	}
	private int getOperationCode() {
		return operationCode;
	}
	public void run() {
		if (textOperationTarget == null)return;
		ITextEditor editor = getTextEditor();
		if (editor == null)return;
		if (isModifyOperation() && !validateEditorInputState())return;
		BusyIndicator.showWhile(getDisplay(), new Runnable() {
			public void run() {
				internalDoOperation();
			}
		}
		);
	}
	private boolean isModifyOperation() {
		return operationCode != ITextOperationTarget.COPY;
	}
	private Shell getShell() {
		ITextEditor editor = getTextEditor();
		if (editor != null) {
			IWorkbenchPartSite site = editor.getSite();
			Shell shell = site.getShell();
			if (shell != null && !shell.isDisposed()) {
				return shell;
			}
		}
		return null;
	}
	private Display getDisplay() {
		Shell shell = getShell();
		if (shell != null) {
			return shell.getDisplay();
		}
		return null;
	}
	public void setEditor(ITextEditor editor) {
		super.setEditor(editor);
		this.textOperationTarget = null;
	}
	public static final class XbaseClipboardData {
		private String sourceIndentifier;
		private String[] imports;
		private String[] staticImports;
		private String[] extensionImports;
		public XbaseClipboardData(String sourceIndentifier, String[] imports, String[] staticImports,String[] extensionImports) {
			this.sourceIndentifier = sourceIndentifier;
			this.imports = imports;
			this.staticImports = staticImports;
			this.extensionImports = extensionImports;
		}
		public XbaseClipboardData(byte[] bytes) throws IOException {
			DataInputStream dataIn = new DataInputStream(new ByteArrayInputStream(bytes));
			try {
				sourceIndentifier = dataIn.readUTF();
				imports = readArray(dataIn);
				staticImports = readArray(dataIn);
				extensionImports = readArray(dataIn);
			}
			 finally {
				dataIn.close();
			}
		}
		protected final String[] readArray(DataInputStream dataIn) throws IOException {
			int count = dataIn.readInt();
			String[] array = new String[count];
			for (int i = 0;
			 i < count;
			 i++) {
				array[i] = dataIn.readUTF();
			}
			return array;
		}
		public byte[] serialize() throws IOException {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			DataOutputStream dataOut = new DataOutputStream(out);
			try {
				dataOut.writeUTF(sourceIndentifier);
				writeArray(dataOut, imports);
				writeArray(dataOut, staticImports);
				writeArray(dataOut, extensionImports);
			}
			 finally {
				dataOut.close();
				out.close();
			}
			return out.toByteArray();
		}
		protected final void writeArray(DataOutputStream dataOut, String[] array) throws IOException {
			dataOut.writeInt(array.length);
			for (int i = 0;
			 i < array.length;
			 i++) {
				dataOut.writeUTF(array[i]);
			}
		}
		public String getSourceIndentifier() {
			return sourceIndentifier;
		}
		public String[] getImports() {
			return imports;
		}
		public String[] getStaticImports() {
			return staticImports;
		}
		public String[] getExtensionImports() {
			return extensionImports;
		}
	}
	private static class XbaseClipboardTransfer extends ByteArrayTransfer {
		private static final String TYPE_NAME = ""xbase-source-with-imports-transfer-format"";
		private static final int TYPEID = registerType(TYPE_NAME);
		protected int[] getTypeIds() {
			return new int[] {
			 TYPEID }
			;
		}
		protected String[] getTypeNames() {
			return new String[] {
			 TYPE_NAME }
			;
		}
		protected void javaToNative(Object data, TransferData transferData) {
			if (data instanceof XbaseClipboardData) {
				try {
					super.javaToNative(((XbaseClipboardData) data).serialize(), transferData);
				}
				 catch (IOException e) {
				}
			}
		}
		protected Object nativeToJava(TransferData transferData) {
			byte[] bytes = (byte[]) super.nativeToJava(transferData);
			if (bytes != null) {
				try {
					return new XbaseClipboardData(bytes);
				}
				 catch (IOException e) {
				}
			}
			return null;
		}
	}
}",1,0,0,0
"public Iterator<Row> getRows(Session ses, SearchRow first, SearchRow last) {
	 List<Row> rows = new ArrayList<>();
	 Collection<ClusterNode> nodes;
	 SqlSystemViewColumnCondition idCond = conditionForColumn(""NODE_ID"", first, last);
	 if (idCond.isEquality()) {
		 try {
			 UUID nodeId = uuidFromValue(idCond.valueForEquality());
			 ClusterNode node = nodeId == null ? null : ctx.discovery().node(nodeId);
			 if (node != null) nodes = Collections.singleton(node);
			 else nodes = Collections.emptySet();
		 }
		 catch (Exception e) {
			 nodes = Collections.emptySet();
		 }
	 }
	 else nodes = F.concat(false, ctx.discovery().allNodes(), ctx.discovery().daemonNodes());
	 for (ClusterNode node : nodes) {
		 if (node != null) {
			 ClusterMetrics metrics = node.metrics();
			 rows.add( createRow( ses, node.id(), valueTimestampFromMillis(metrics.getLastUpdateTime()), metrics.getMaximumActiveJobs(), metrics.getCurrentActiveJobs(), metrics.getAverageActiveJobs(), metrics.getMaximumWaitingJobs(), metrics.getCurrentWaitingJobs(), metrics.getAverageWaitingJobs(), metrics.getMaximumRejectedJobs(), metrics.getCurrentRejectedJobs(), metrics.getAverageRejectedJobs(), metrics.getTotalRejectedJobs(), metrics.getMaximumCancelledJobs(), metrics.getCurrentCancelledJobs(), metrics.getAverageCancelledJobs(), metrics.getTotalCancelledJobs(), metrics.getMaximumJobWaitTime(), metrics.getCurrentJobWaitTime(), (long)metrics.getAverageJobWaitTime(), metrics.getMaximumJobExecuteTime(), metrics.getCurrentJobExecuteTime(), (long)metrics.getAverageJobExecuteTime(), metrics.getTotalJobsExecutionTime(), metrics.getTotalExecutedJobs(), metrics.getTotalExecutedTasks(), metrics.getTotalBusyTime(), metrics.getTotalIdleTime(), metrics.getCurrentIdleTime(), metrics.getBusyTimePercentage(), metrics.getIdleTimePercentage(), metrics.getTotalCpus(), metrics.getCurrentCpuLoad(), metrics.getAverageCpuLoad(), metrics.getCurrentGcCpuLoad(), metrics.getHeapMemoryInitialized(), metrics.getHeapMemoryUsed(), metrics.getHeapMemoryCommitted(), metrics.getHeapMemoryMaximum(), metrics.getHeapMemoryTotal(), metrics.getNonHeapMemoryInitialized(), metrics.getNonHeapMemoryUsed(), metrics.getNonHeapMemoryCommitted(), metrics.getNonHeapMemoryMaximum(), metrics.getNonHeapMemoryTotal(), metrics.getUpTime(), valueTimestampFromMillis(metrics.getStartTime()), valueTimestampFromMillis(metrics.getNodeStartTime()), metrics.getLastDataVersion(), metrics.getCurrentThreadCount(), metrics.getMaximumThreadCount(), metrics.getTotalStartedThreadCount(), metrics.getCurrentDaemonThreadCount(), metrics.getSentMessagesCount(), metrics.getSentBytesCount(), metrics.getReceivedMessagesCount(), metrics.getReceivedBytesCount(), metrics.getOutboundMessagesQueueSize() ) );
		 }
	 }
	 return rows.iterator();
 }",0,0,1,0
"public abstract class AbstractFileSet extends DataType implements Cloneable, SelectorContainer {
	 private PatternSet defaultPatterns = new PatternSet();
	 private Vector additionalPatterns = new Vector();
	 private Vector selectors = new Vector();
	 private File dir;
	 private boolean useDefaultExcludes = true;
	 private boolean caseSensitive = true;
	 private boolean followSymlinks = true;
	 private boolean errorOnMissingDir = true;
	 private int maxLevelsOfSymlinks = DirectoryScanner.MAX_LEVELS_OF_SYMLINKS;
	 private DirectoryScanner directoryScanner = null;
	 public AbstractFileSet() {
		 super();
	 }
	 protected AbstractFileSet(AbstractFileSet fileset) {
		 this.dir = fileset.dir;
		 this.defaultPatterns = fileset.defaultPatterns;
		 this.additionalPatterns = fileset.additionalPatterns;
		 this.selectors = fileset.selectors;
		 this.useDefaultExcludes = fileset.useDefaultExcludes;
		 this.caseSensitive = fileset.caseSensitive;
		 this.followSymlinks = fileset.followSymlinks;
		 this.errorOnMissingDir = fileset.errorOnMissingDir;
		 this.maxLevelsOfSymlinks = fileset.maxLevelsOfSymlinks;
		 setProject(fileset.getProject());
	 }
	 public void setRefid(Reference r) throws BuildException {
		 if (dir != null || defaultPatterns.hasPatterns(getProject())) {
			 throw tooManyAttributes();
		 }
		 if (!additionalPatterns.isEmpty()) {
			 throw noChildrenAllowed();
		 }
		 if (!selectors.isEmpty()) {
			 throw noChildrenAllowed();
		 }
		 super.setRefid(r);
	 }
	 public synchronized void setDir(File dir) throws BuildException {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.dir = dir;
		 directoryScanner = null;
	 }
	 public File getDir() {
		 return getDir(getProject());
	 }
	 public synchronized File getDir(Project p) {
		 if (isReference()) {
			 return getRef(p).getDir(p);
		 }
		 dieOnCircularReference();
		 return dir;
	 }
	 public synchronized PatternSet createPatternSet() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 PatternSet patterns = new PatternSet();
		 additionalPatterns.addElement(patterns);
		 directoryScanner = null;
		 return patterns;
	 }
	 public synchronized PatternSet.NameEntry createInclude() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 directoryScanner = null;
		 return defaultPatterns.createInclude();
	 }
	 public synchronized PatternSet.NameEntry createIncludesFile() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 directoryScanner = null;
		 return defaultPatterns.createIncludesFile();
	 }
	 public synchronized PatternSet.NameEntry createExclude() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 directoryScanner = null;
		 return defaultPatterns.createExclude();
	 }
	 public synchronized PatternSet.NameEntry createExcludesFile() {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 directoryScanner = null;
		 return defaultPatterns.createExcludesFile();
	 }
	 public synchronized void setFile(File file) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 setDir(file.getParentFile());
		 createInclude().setName(file.getName());
	 }
	 public synchronized void setIncludes(String includes) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 defaultPatterns.setIncludes(includes);
		 directoryScanner = null;
	 }
	 public synchronized void appendIncludes(String[] includes) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (includes != null) {
			 for (int i = 0;
			 i < includes.length;
			 i++) {
				 defaultPatterns.createInclude().setName(includes[i]);
			 }
			 directoryScanner = null;
		 }
	 }
	 public synchronized void setExcludes(String excludes) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 defaultPatterns.setExcludes(excludes);
		 directoryScanner = null;
	 }
	 public synchronized void appendExcludes(String[] excludes) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 if (excludes != null) {
			 for (int i = 0;
			 i < excludes.length;
			 i++) {
				 defaultPatterns.createExclude().setName(excludes[i]);
			 }
			 directoryScanner = null;
		 }
	 }
	 public synchronized void setIncludesfile(File incl) throws BuildException {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 defaultPatterns.setIncludesfile(incl);
		 directoryScanner = null;
	 }
	 public synchronized void setExcludesfile(File excl) throws BuildException {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 defaultPatterns.setExcludesfile(excl);
		 directoryScanner = null;
	 }
	 public synchronized void setDefaultexcludes(boolean useDefaultExcludes) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.useDefaultExcludes = useDefaultExcludes;
		 directoryScanner = null;
	 }
	 public synchronized boolean getDefaultexcludes() {
		 if (isReference()) {
			 return getRef(getProject()).getDefaultexcludes();
		 }
		 dieOnCircularReference();
		 return useDefaultExcludes;
	 }
	 public synchronized void setCaseSensitive(boolean caseSensitive) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.caseSensitive = caseSensitive;
		 directoryScanner = null;
	 }
	 public synchronized boolean isCaseSensitive() {
		 if (isReference()) {
			 return getRef(getProject()).isCaseSensitive();
		 }
		 dieOnCircularReference();
		 return caseSensitive;
	 }
	 public synchronized void setFollowSymlinks(boolean followSymlinks) {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 this.followSymlinks = followSymlinks;
		 directoryScanner = null;
	 }
	 public synchronized boolean isFollowSymlinks() {
		 if (isReference()) {
			 return getRef(getProject()).isCaseSensitive();
		 }
		 dieOnCircularReference();
		 return followSymlinks;
	 }
	 public void setMaxLevelsOfSymlinks(int max) {
		 maxLevelsOfSymlinks = max;
	 }
	 public int getMaxLevelsOfSymlinks() {
		 return maxLevelsOfSymlinks;
	 }
	 public void setErrorOnMissingDir(boolean errorOnMissingDir) {
		 this.errorOnMissingDir = errorOnMissingDir;
	 }
	 public boolean getErrorOnMissingDir() {
		 return errorOnMissingDir;
	 }
	 public DirectoryScanner getDirectoryScanner() {
		 return getDirectoryScanner(getProject());
	 }
	 public DirectoryScanner getDirectoryScanner(Project p) {
		 if (isReference()) {
			 return getRef(p).getDirectoryScanner(p);
		 }
		 dieOnCircularReference();
		 DirectoryScanner ds = null;
		 synchronized (this) {
			 if (directoryScanner != null && p == getProject()) {
				 ds = directoryScanner;
			 }
			 else {
				 if (dir == null) {
					 throw new BuildException(""No directory specified for "" + getDataTypeName() + ""."");
				 }
				 if (!dir.exists() && errorOnMissingDir) {
					 throw new BuildException(dir.getAbsolutePath() + DirectoryScanner .DOES_NOT_EXIST_POSTFIX);
				 }
				 if (!dir.isDirectory() && dir.exists()) {
					 throw new BuildException(dir.getAbsolutePath() + "" is not a directory."");
				 }
				 ds = new DirectoryScanner();
				 setupDirectoryScanner(ds, p);
				 ds.setFollowSymlinks(followSymlinks);
				 ds.setErrorOnMissingDir(errorOnMissingDir);
				 ds.setMaxLevelsOfSymlinks(maxLevelsOfSymlinks);
				 directoryScanner = (p == getProject()) ? ds : directoryScanner;
			 }
		 }
		 ds.scan();
		 return ds;
	 }
	 public void setupDirectoryScanner(FileScanner ds) {
		 setupDirectoryScanner(ds, getProject());
	 }
	 public synchronized void setupDirectoryScanner(FileScanner ds, Project p) {
		 if (isReference()) {
			 getRef(p).setupDirectoryScanner(ds, p);
			 return;
		 }
		 dieOnCircularReference(p);
		 if (ds == null) {
			 throw new IllegalArgumentException(""ds cannot be null"");
		 }
		 ds.setBasedir(dir);
		 PatternSet ps = mergePatterns(p);
		 p.log(getDataTypeName() + "": Setup scanner in dir "" + dir + "" with "" + ps, Project.MSG_DEBUG);
		 ds.setIncludes(ps.getIncludePatterns(p));
		 ds.setExcludes(ps.getExcludePatterns(p));
		 if (ds instanceof SelectorScanner) {
			 SelectorScanner ss = (SelectorScanner) ds;
			 ss.setSelectors(getSelectors(p));
		 }
		 if (useDefaultExcludes) {
			 ds.addDefaultExcludes();
		 }
		 ds.setCaseSensitive(caseSensitive);
	 }
	 protected AbstractFileSet getRef(Project p) {
		 return (AbstractFileSet) getCheckedRef(p);
	 }
	 public synchronized boolean hasSelectors() {
		 if (isReference()) {
			 return getRef(getProject()).hasSelectors();
		 }
		 dieOnCircularReference();
		 return !(selectors.isEmpty());
	 }
	 public synchronized boolean hasPatterns() {
		 if (isReference() && getProject() != null) {
			 return getRef(getProject()).hasPatterns();
		 }
		 dieOnCircularReference();
		 if (defaultPatterns.hasPatterns(getProject())) {
			 return true;
		 }
		 Enumeration e = additionalPatterns.elements();
		 while (e.hasMoreElements()) {
			 PatternSet ps = (PatternSet) e.nextElement();
			 if (ps.hasPatterns(getProject())) {
				 return true;
			 }
		 }
		 return false;
	 }
	 public synchronized int selectorCount() {
		 if (isReference()) {
			 return getRef(getProject()).selectorCount();
		 }
		 dieOnCircularReference();
		 return selectors.size();
	 }
	 public synchronized FileSelector[] getSelectors(Project p) {
		 if (isReference()) {
			 return getRef(getProject()).getSelectors(p);
		 }
		 dieOnCircularReference(p);
		 return (FileSelector[]) (selectors.toArray( new FileSelector[selectors.size()]));
	 }
	 public synchronized Enumeration selectorElements() {
		 if (isReference()) {
			 return getRef(getProject()).selectorElements();
		 }
		 dieOnCircularReference();
		 return selectors.elements();
	 }
	 public synchronized void appendSelector(FileSelector selector) {
		 if (isReference()) {
			 throw noChildrenAllowed();
		 }
		 selectors.addElement(selector);
		 directoryScanner = null;
		 setChecked(false);
	 }
	 public void addSelector(SelectSelector selector) {
		 appendSelector(selector);
	 }
	 public void addAnd(AndSelector selector) {
		 appendSelector(selector);
	 }
	 public void addOr(OrSelector selector) {
		 appendSelector(selector);
	 }
	 public void addNot(NotSelector selector) {
		 appendSelector(selector);
	 }
	 public void addNone(NoneSelector selector) {
		 appendSelector(selector);
	 }
	 public void addMajority(MajoritySelector selector) {
		 appendSelector(selector);
	 }
	 public void addDate(DateSelector selector) {
		 appendSelector(selector);
	 }
	 public void addSize(SizeSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDifferent(DifferentSelector selector) {
		 appendSelector(selector);
	 }
	 public void addFilename(FilenameSelector selector) {
		 appendSelector(selector);
	 }
	 public void addType(TypeSelector selector) {
		 appendSelector(selector);
	 }
	 public void addCustom(ExtendSelector selector) {
		 appendSelector(selector);
	 }
	 public void addContains(ContainsSelector selector) {
		 appendSelector(selector);
	 }
	 public void addPresent(PresentSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDepth(DepthSelector selector) {
		 appendSelector(selector);
	 }
	 public void addDepend(DependSelector selector) {
		 appendSelector(selector);
	 }
	 public void addContainsRegexp(ContainsRegexpSelector selector) {
		 appendSelector(selector);
	 }
	 public void addModified(ModifiedSelector selector) {
		 appendSelector(selector);
	 }
	 public void addReadable(ReadableSelector r) {
		 appendSelector(r);
	 }
	 public void addWritable(WritableSelector w) {
		 appendSelector(w);
	 }
	 public void add(FileSelector selector) {
		 appendSelector(selector);
	 }
	 public String toString() {
		 if (isReference()) {
			 return getRef(getProject()).toString();
		 }
		 dieOnCircularReference();
		 DirectoryScanner ds = getDirectoryScanner(getProject());
		 String[] files = ds.getIncludedFiles();
		 StringBuffer sb = new StringBuffer();
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 if (i > 0) {
				 sb.append(';
				');
			 }
			 sb.append(files[i]);
		 }
		 return sb.toString();
	 }
	 public synchronized Object clone() {
		 if (isReference()) {
			 return (getRef(getProject())).clone();
		 }
		 else {
			 try {
				 AbstractFileSet fs = (AbstractFileSet) super.clone();
				 fs.defaultPatterns = (PatternSet) defaultPatterns.clone();
				 fs.additionalPatterns = new Vector(additionalPatterns.size());
				 Enumeration e = additionalPatterns.elements();
				 while (e.hasMoreElements()) {
					 fs.additionalPatterns .addElement(((PatternSet) e.nextElement()).clone());
				 }
				 fs.selectors = new Vector(selectors);
				 return fs;
			 }
			 catch (CloneNotSupportedException e) {
				 throw new BuildException(e);
			 }
		 }
	 }
	 public String[] mergeIncludes(Project p) {
		 return mergePatterns(p).getIncludePatterns(p);
	 }
	 public String[] mergeExcludes(Project p) {
		 return mergePatterns(p).getExcludePatterns(p);
	 }
	 public synchronized PatternSet mergePatterns(Project p) {
		 if (isReference()) {
			 return getRef(p).mergePatterns(p);
		 }
		 dieOnCircularReference();
		 PatternSet ps = (PatternSet) defaultPatterns.clone();
		 final int count = additionalPatterns.size();
		 for (int i = 0;
		 i < count;
		 i++) {
			 Object o = additionalPatterns.elementAt(i);
			 ps.append((PatternSet) o, p);
		 }
		 return ps;
	 }
	 protected synchronized void dieOnCircularReference(Stack stk, Project p) throws BuildException {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 for (Iterator i = selectors.iterator();
			 i.hasNext();
			 ) {
				 Object o = i.next();
				 if (o instanceof DataType) {
					 pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);
				 }
			 }
			 for (Iterator i = additionalPatterns.iterator();
			 i.hasNext();
			 ) {
				 PatternSet ps = (PatternSet) i.next();
				 pushAndInvokeCircularReferenceCheck(ps, stk, p);
			 }
			 setChecked(true);
		 }
	 }
}",0,0,0,0
"protected Connection getConnection() {
	 if (conn == null) {
		 conn = super.getConnection();
		 if (!isValidRdbms(conn)) {
			 conn = null;
		 }
	 }
	 return conn;
 }",0,0,0,0
"public class RemoteProcessGroupDTO extends ComponentDTO {
	 private String targetUri;
	 private String targetUris;
	 private Boolean targetSecure;
	 private String name;
	 private String comments;
	 private String communicationsTimeout;
	 private String yieldDuration;
	 private String transportProtocol;
	 private String localNetworkInterface;
	 private String proxyHost;
	 private Integer proxyPort;
	 private String proxyUser;
	 private String proxyPassword;
	 private Collection<String> authorizationIssues;
	 private Collection<String> validationErrors;
	 private Boolean transmitting;
	 private Integer inputPortCount;
	 private Integer outputPortCount;
	 private Integer activeRemoteInputPortCount;
	 private Integer inactiveRemoteInputPortCount;
	 private Integer activeRemoteOutputPortCount;
	 private Integer inactiveRemoteOutputPortCount;
	 private Date flowRefreshed;
	 private RemoteProcessGroupContentsDTO contents;
	 public RemoteProcessGroupDTO() {
		 super();
	 }
	 public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {
		 setId(toCopy.getId());
		 setPosition(toCopy.getPosition());
		 targetUri = toCopy.getTargetUri();
		 name = toCopy.getName();
	 }
	 public void setTargetUri(final String targetUri) {
		 this.targetUri = targetUri;
	 }
	 public String getTargetUri() {
		 if (targetUri == null || targetUri.length() == 0) {
			 synchronized (this) {
				 if (targetUri == null || targetUri.length() == 0) {
					 if (targetUris != null && targetUris.length() > 0) {
						 if (targetUris.indexOf(',') > -1) {
							 targetUri = targetUris.substring(0, targetUris.indexOf(','));
						 }
						 else {
							 targetUri = targetUris;
						 }
					 }
				 }
			 }
		 }
		 return this.targetUri;
	 }
	 public void setTargetUris(String targetUris) {
		 this.targetUris = targetUris;
	 }
	 public String getTargetUris() {
		 if (targetUris == null || targetUris.length() == 0) {
			 synchronized (this) {
				 if (targetUris == null || targetUris.length() == 0) {
					 targetUris = targetUri;
				 }
			 }
		 }
		 return this.targetUris;
	 }
	 public void setName(final String name) {
		 this.name = name;
	 }
	 public String getName() {
		 return this.name;
	 }
	 public String getComments() {
		 return comments;
	 }
	 public void setComments(String comments) {
		 this.comments = comments;
	 }
	 public Collection<String> getAuthorizationIssues() {
		 return authorizationIssues;
	 }
	 public void setAuthorizationIssues(Collection<String> authorizationIssues) {
		 this.authorizationIssues = authorizationIssues;
	 }
	 public Boolean isTransmitting() {
		 return transmitting;
	 }
	 public void setTransmitting(Boolean transmitting) {
		 this.transmitting = transmitting;
	 }
	 public Boolean isTargetSecure() {
		 return targetSecure;
	 }
	 public void setTargetSecure(Boolean targetSecure) {
		 this.targetSecure = targetSecure;
	 }
	 public String getCommunicationsTimeout() {
		 return communicationsTimeout;
	 }
	 public void setCommunicationsTimeout(String communicationsTimeout) {
		 this.communicationsTimeout = communicationsTimeout;
	 }
	 public String getYieldDuration() {
		 return yieldDuration;
	 }
	 public void setYieldDuration(String yieldDuration) {
		 this.yieldDuration = yieldDuration;
	 }
	 public Integer getActiveRemoteInputPortCount() {
		 return activeRemoteInputPortCount;
	 }
	 public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {
		 this.activeRemoteInputPortCount = activeRemoteInputPortCount;
	 }
	 public Integer getInactiveRemoteInputPortCount() {
		 return inactiveRemoteInputPortCount;
	 }
	 public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {
		 this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;
	 }
	 public Integer getActiveRemoteOutputPortCount() {
		 return activeRemoteOutputPortCount;
	 }
	 public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {
		 this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;
	 }
	 public Integer getInactiveRemoteOutputPortCount() {
		 return inactiveRemoteOutputPortCount;
	 }
	 public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {
		 this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;
	 }
	 public Integer getInputPortCount() {
		 return inputPortCount;
	 }
	 public void setInputPortCount(Integer inputPortCount) {
		 this.inputPortCount = inputPortCount;
	 }
	 public Integer getOutputPortCount() {
		 return outputPortCount;
	 }
	 public void setOutputPortCount(Integer outputPortCount) {
		 this.outputPortCount = outputPortCount;
	 }
	 public RemoteProcessGroupContentsDTO getContents() {
		 return contents;
	 }
	 public void setContents(RemoteProcessGroupContentsDTO contents) {
		 this.contents = contents;
	 }
	 public Date getFlowRefreshed() {
		 return flowRefreshed;
	 }
	 public void setFlowRefreshed(Date flowRefreshed) {
		 this.flowRefreshed = flowRefreshed;
	 }
	 public String getTransportProtocol() {
		 return transportProtocol;
	 }
	 public void setTransportProtocol(String transportProtocol) {
		 this.transportProtocol = transportProtocol;
	 }
	 public String getLocalNetworkInterface() {
		 return localNetworkInterface;
	 }
	 public void setLocalNetworkInterface(String localNetworkInterface) {
		 this.localNetworkInterface = localNetworkInterface;
	 }
	 public Collection<String> getValidationErrors() {
		 return validationErrors;
	 }
	 public void setValidationErrors(Collection<String> validationErrors) {
		 this.validationErrors = validationErrors;
	 }
	 public String getProxyHost() {
		 return proxyHost;
	 }
	 public void setProxyHost(String proxyHost) {
		 this.proxyHost = proxyHost;
	 }
	 public Integer getProxyPort() {
		 return proxyPort;
	 }
	 public void setProxyPort(Integer proxyPort) {
		 this.proxyPort = proxyPort;
	 }
	 public String getProxyUser() {
		 return proxyUser;
	 }
	 public void setProxyUser(String proxyUser) {
		 this.proxyUser = proxyUser;
	 }
	 public String getProxyPassword() {
		 return proxyPassword;
	 }
	 public void setProxyPassword(String proxyPassword) {
		 this.proxyPassword = proxyPassword;
	 }
}",1,1,0,0
"public Map<Long, List<BiologicalDataItem>> loadBookmarkItemsByBookmarkIds(Collection<Long> bookmarkIds) {
	 if (bookmarkIds == null || bookmarkIds.isEmpty()) {
		 return Collections.emptyMap();
	 }
	 Long listId = daoHelper.createTempLongList(bookmarkIds);
	 Map<Long, List<BiologicalDataItem>> itemsMap = new HashMap<>();
	 getJdbcTemplate().query(loadBookmarksItemsQuery, rs -> {
		 BiologicalDataItem dataItem = BiologicalDataItemDao.BiologicalDataItemParameters.getRowMapper() .mapRow(rs, 0);
		 long bookmarkId = rs.getLong(BookmarkItemParameters.BOOKMARK_ID.name());
		 if (!itemsMap.containsKey(bookmarkId)) {
			 itemsMap.put(bookmarkId, new ArrayList<>());
		 }
		 itemsMap.get(bookmarkId).add(dataItem);
	 }
	, listId);
	 daoHelper.clearTempList(listId);
	 return itemsMap;
 }",0,0,1,0
"public abstract class AbstractPmdReport extends AbstractMavenReport{
	 protected File targetDirectory;
	 protected File outputDirectory;
	 private Renderer siteRenderer;
	 protected MavenProject project;
	 protected String format = ""xml"";
	 private boolean linkXRef;
	 private File xrefLocation;
	 private File xrefTestLocation;
	 private List<String> excludes;
	 private List<String> includes;
	 private List<String> compileSourceRoots;
	 private List<String> testSourceRoots;
	 private File[] excludeRoots;
	 protected boolean includeTests;
	 protected boolean aggregate;
	 private String sourceEncoding;
	 private String outputEncoding;
	 protected List<MavenProject> reactorProjects;
	 protected boolean includeXmlInSite;
	 protected boolean skipEmptyReport;
	 protected String excludeFromFailureFile;
	 protected Map<File, PmdFileInfo> filesToProcess;
	 protected MavenProject getProject() {
		 return project;
	 }
	 protected Renderer getSiteRenderer() {
		 return siteRenderer;
	 }
	 protected String constructXRefLocation( boolean test ) {
		 String location = null;
		 if ( linkXRef ) {
			 File xrefLoc = test ? xrefTestLocation : xrefLocation;
			 String relativePath = PathTool.getRelativePath( outputDirectory.getAbsolutePath(), xrefLoc.getAbsolutePath() );
			 if ( StringUtils.isEmpty( relativePath ) ) {
				 relativePath = ""."";
			 }
			 relativePath = relativePath + ""/"" + xrefLoc.getName();
			 if ( xrefLoc.exists() ) {
				 location = relativePath;
			 }
			 else {
				 List<ReportPlugin> reportPlugins = project.getReportPlugins();
				 for ( ReportPlugin plugin : reportPlugins ) {
					 String artifactId = plugin.getArtifactId();
					 if ( ""maven-jxr-plugin"".equals( artifactId ) || ""jxr-maven-plugin"".equals( artifactId ) ) {
						 location = relativePath;
					 }
				 }
			 }
			 if ( location == null ) {
				 getLog().warn( ""Unable to locate Source XRef to link to - DISABLED"" );
			 }
		 }
		 return location;
	 }
	 protected Map<File, PmdFileInfo> getFilesToProcess() throws IOException {
		 if ( aggregate && !project.isExecutionRoot() ) {
			 return Collections.emptyMap();
		 }
		 if ( excludeRoots == null ) {
			 excludeRoots = new File[0];
		 }
		 Collection<File> excludeRootFiles = new HashSet<>( excludeRoots.length );
		 for ( File file : excludeRoots ) {
			 if ( file.isDirectory() ) {
				 excludeRootFiles.add( file );
			 }
		 }
		 List<PmdFileInfo> directories = new ArrayList<>();
		 if ( null == compileSourceRoots ) {
			 compileSourceRoots = project.getCompileSourceRoots();
		 }
		 if ( compileSourceRoots != null ) {
			 for ( String root : compileSourceRoots ) {
				 File sroot = new File( root );
				 if ( sroot.exists() ) {
					 String sourceXref = constructXRefLocation( false );
					 directories.add( new PmdFileInfo( project, sroot, sourceXref ) );
				 }
			 }
		 }
		 if ( null == testSourceRoots ) {
			 testSourceRoots = project.getTestCompileSourceRoots();
		 }
		 if ( includeTests ) {
			 if ( testSourceRoots != null ) {
				 for ( String root : testSourceRoots ) {
					 File sroot = new File( root );
					 if ( sroot.exists() ) {
						 String testXref = constructXRefLocation( true );
						 directories.add( new PmdFileInfo( project, sroot, testXref ) );
					 }
				 }
			 }
		 }
		 if ( aggregate ) {
			 for ( MavenProject localProject : reactorProjects ) {
				 List<String> localCompileSourceRoots = localProject.getCompileSourceRoots();
				 for ( String root : localCompileSourceRoots ) {
					 File sroot = new File( root );
					 if ( sroot.exists() ) {
						 String sourceXref = constructXRefLocation( false );
						 directories.add( new PmdFileInfo( localProject, sroot, sourceXref ) );
					 }
				 }
				 if ( includeTests ) {
					 List<String> localTestCompileSourceRoots = localProject.getTestCompileSourceRoots();
					 for ( String root : localTestCompileSourceRoots ) {
						 File sroot = new File( root );
						 if ( sroot.exists() ) {
							 String testXref = constructXRefLocation( true );
							 directories.add( new PmdFileInfo( localProject, sroot, testXref ) );
						 }
					 }
				 }
			 }
		 }
		 String excluding = getExcludes();
		 getLog().debug( ""Exclusions: "" + excluding );
		 String including = getIncludes();
		 getLog().debug( ""Inclusions: "" + including );
		 Map<File, PmdFileInfo> files = new TreeMap<>();
		 for ( PmdFileInfo finfo : directories ) {
			 getLog().debug( ""Searching for files in directory "" + finfo.getSourceDirectory().toString() );
			 File sourceDirectory = finfo.getSourceDirectory();
			 if ( sourceDirectory.isDirectory() && !isDirectoryExcluded( excludeRootFiles, sourceDirectory ) ) {
				 List<File> newfiles = FileUtils.getFiles( sourceDirectory, including, excluding );
				 for ( File newfile : newfiles ) {
					 files.put( newfile.getCanonicalFile(), finfo );
				 }
			 }
		 }
		 return files;
	 }
	 private boolean isDirectoryExcluded( Collection<File> excludeRootFiles, File sourceDirectoryToCheck ) {
		 boolean returnVal = false;
		 for ( File excludeDir : excludeRootFiles ) {
			 try {
				 if ( sourceDirectoryToCheck.getCanonicalPath().startsWith( excludeDir.getCanonicalPath() ) ) {
					 getLog().debug( ""Directory "" + sourceDirectoryToCheck.getAbsolutePath() + "" has been excluded as it matches excludeRoot "" + excludeDir.getAbsolutePath() );
					 returnVal = true;
					 break;
				 }
			 }
			 catch ( IOException e ) {
				 getLog().warn( ""Error while checking "" + sourceDirectoryToCheck + "" whether it should be excluded."", e );
			 }
		 }
		 return returnVal;
	 }
	 private String getIncludes() {
		 Collection<String> patterns = new LinkedHashSet<>();
		 if ( includes != null ) {
			 patterns.addAll( includes );
		 }
		 if ( patterns.isEmpty() ) {
			 patterns.add( ""** private String getExcludes() {
				 Collection<String> patterns = new LinkedHashSet<>( FileUtils.getDefaultExcludesAsList() );
				 if ( excludes != null ) {
					 patterns.addAll( excludes );
				 }
				 return StringUtils.join( patterns.iterator(), "","" );
			 }
			 protected boolean isHtml() {
				 return ""html"".equals( format );
			 }
			 protected boolean isXml() {
				 return ""xml"".equals( format );
			 }
			 public boolean canGenerateReport() {
				 if ( aggregate && !project.isExecutionRoot() ) {
					 return false;
				 }
				 if ( ""pom"".equals( project.getPackaging() ) && !aggregate ) {
					 return false;
				 }
				 if ( isXml() ) {
					 return true;
				 }
				 try {
					 filesToProcess = getFilesToProcess();
					 if ( filesToProcess.isEmpty() ) {
						 return false;
					 }
				 }
				 catch ( IOException e ) {
					 getLog().error( e );
				 }
				 return true;
			 }
			 protected String getOutputDirectory() {
				 return outputDirectory.getAbsolutePath();
			 }
			 protected String getSourceEncoding() {
				 return sourceEncoding;
			 }
			 protected String getOutputEncoding() {
				 return ( outputEncoding != null ) ? outputEncoding : ReaderFactory.UTF_8;
			 }
			 static String getPmdVersion() {
				 try {
					 return (String) PMD.class.getField( ""VERSION"" ).get( null );
				 }
				 catch ( IllegalAccessException e ) {
					 throw new RuntimeException( ""PMD VERSION field not accessible"", e );
				 }
				 catch ( NoSuchFieldException e ) {
					 throw new RuntimeException( ""PMD VERSION field not found"", e );
				 }
			 }
		}",1,1,0,0
"public class GangliaSink30 extends AbstractGangliaSink {
	 public final Logger LOG = LoggerFactory.getLogger(this.getClass());
	 private static final String TAGS_FOR_PREFIX_PROPERTY_PREFIX = ""tagsForPrefix."";
	 private MetricsCache metricsCache = new MetricsCache();
	 private Map<String,Set<String>> useTagsMap = new HashMap<String,Set<String>>();
	 public void init(SubsetConfiguration conf) {
		 super.init(conf);
		 conf.setListDelimiterHandler(new DefaultListDelimiterHandler(','));
		 Iterator<String> it = (Iterator<String>) conf.getKeys();
		 while (it.hasNext()) {
			 String propertyName = it.next();
			 if (propertyName.startsWith(TAGS_FOR_PREFIX_PROPERTY_PREFIX)) {
				 String contextName = propertyName.substring(TAGS_FOR_PREFIX_PROPERTY_PREFIX.length());
				 String[] tags = conf.getStringArray(propertyName);
				 boolean useAllTags = false;
				 Set<String> set = new HashSet<>();
				 for (String tag : tags) {
					 tag = tag.trim();
					 useAllTags |= tag.equals(""*"");
					 if (tag.length() > 0) {
						 set.add(tag);
					 }
				 }
				 if (useAllTags) {
					 set = null;
				 }
				 useTagsMap.put(contextName, set);
			 }
		 }
	 }
	 public void appendPrefix(MetricsRecord record, StringBuilder sb) {
		 String contextName = record.context();
		 Collection<MetricsTag> tags = record.tags();
		 if (useTagsMap.containsKey(contextName)) {
			 Set<String> useTags = useTagsMap.get(contextName);
			 for (MetricsTag t : tags) {
				 if (useTags == null || useTags.contains(t.name())) {
					 if (t.info() != MsInfo.Context && t.info() != MsInfo.Hostname && t.value() != null) {
						 sb.append('.').append(t.name()).append('=').append(t.value());
					 }
				 }
			 }
		 }
	 }
	 public void putMetrics(MetricsRecord record) {
		 try {
			 String recordName = record.name();
			 String contextName = record.context();
			 StringBuilder sb = new StringBuilder();
			 sb.append(contextName);
			 sb.append('.');
			 sb.append(recordName);
			 appendPrefix(record, sb);
			 String groupName = sb.toString();
			 sb.append('.');
			 int sbBaseLen = sb.length();
			 String type = null;
			 GangliaSlope slopeFromMetric = null;
			 GangliaSlope calculatedSlope = null;
			 Record cachedMetrics = null;
			 resetBuffer();
			 if (!isSupportSparseMetrics()) {
				 cachedMetrics = metricsCache.update(record);
				 if (cachedMetrics != null && cachedMetrics.metricsEntrySet() != null) {
					 for (Map.Entry<String, AbstractMetric> entry : cachedMetrics .metricsEntrySet()) {
						 AbstractMetric metric = entry.getValue();
						 sb.append(metric.name());
						 String name = sb.toString();
						 metric.visit(gangliaMetricVisitor);
						 type = gangliaMetricVisitor.getType();
						 slopeFromMetric = gangliaMetricVisitor.getSlope();
						 GangliaConf gConf = getGangliaConfForMetric(name);
						 calculatedSlope = calculateSlope(gConf, slopeFromMetric);
						 emitMetric(groupName, name, type, metric.value().toString(), gConf, calculatedSlope);
						 sb.setLength(sbBaseLen);
					 }
				 }
			 }
			 else {
				 Collection<AbstractMetric> metrics = (Collection<AbstractMetric>) record .metrics();
				 if (metrics.size() > 0) {
					 for (AbstractMetric metric : record.metrics()) {
						 sb.append(metric.name());
						 String name = sb.toString();
						 metric.visit(gangliaMetricVisitor);
						 type = gangliaMetricVisitor.getType();
						 slopeFromMetric = gangliaMetricVisitor.getSlope();
						 GangliaConf gConf = getGangliaConfForMetric(name);
						 calculatedSlope = calculateSlope(gConf, slopeFromMetric);
						 emitMetric(groupName, name, type, metric.value().toString(), gConf, calculatedSlope);
						 sb.setLength(sbBaseLen);
					 }
				 }
			 }
		 }
		 catch (IOException io) {
			 throw new MetricsException(""Failed to putMetrics"", io);
		 }
	 }
	 private GangliaSlope calculateSlope(GangliaConf gConf, GangliaSlope slopeFromMetric) {
		 if (gConf.getSlope() != null) {
			 return gConf.getSlope();
		 }
		 else if (slopeFromMetric != null) {
			 return slopeFromMetric;
		 }
		 else {
			 return DEFAULT_SLOPE;
		 }
	 }
	 protected void emitMetric(String groupName, String name, String type, String value, GangliaConf gConf, GangliaSlope gSlope) throws IOException {
		 if (name == null) {
			 LOG.warn(""Metric was emitted with no name."");
			 return;
		 }
		 else if (value == null) {
			 LOG.warn(""Metric name "" + name + "" was emitted with a null value."");
			 return;
		 }
		 else if (type == null) {
			 LOG.warn(""Metric name "" + name + "", value "" + value + "" has no type."");
			 return;
		 }
		 if (LOG.isDebugEnabled()) {
			 LOG.debug(""Emitting metric "" + name + "", type "" + type + "", value "" + value + "", slope "" + gSlope.name() + "" from hostname "" + getHostName());
		 }
		 xdr_int(0);
		 xdr_string(type);
		 xdr_string(name);
		 xdr_string(value);
		 xdr_string(gConf.getUnits());
		 xdr_int(gSlope.ordinal());
		 xdr_int(gConf.getTmax());
		 xdr_int(gConf.getDmax());
		 emitToGangliaHosts();
	 }
}",0,0,0,0
"private static void printUsage() {
	 HelpFormatter hf = new HelpFormatter();
	 StringBuilder header = new StringBuilder();
	 header.append(""\nAvailable commands:\n"");
	 addCmdHelp(header, ""ring"", ""Print informations on the token ring"");
	 addCmdHelp(header, ""join"", ""Join the ring"");
	 addCmdHelp(header, ""info"", ""Print node informations (uptime, load, ...)"");
	 addCmdHelp(header, ""cfstats"", ""Print statistics on column families"");
	 addCmdHelp(header, ""version"", ""Print cassandra version"");
	 addCmdHelp(header, ""tpstats"", ""Print usage statistics of thread pools"");
	 addCmdHelp(header, ""drain"", ""Drain the node (stop accepting writes and flush all column families)"");
	 addCmdHelp(header, ""decommission"", ""Decommission the node"");
	 addCmdHelp(header, ""compactionstats"", ""Print statistics on compactions"");
	 addCmdHelp(header, ""disablegossip"", ""Disable gossip (effectively marking the node dead)"");
	 addCmdHelp(header, ""enablegossip"", ""Reenable gossip"");
	 addCmdHelp(header, ""disablethrift"", ""Disable thrift server"");
	 addCmdHelp(header, ""enablethrift"", ""Reenable thrift server"");
	 addCmdHelp(header, ""statusthrift"", ""Status of thrift server"");
	 addCmdHelp(header, ""gossipinfo"", ""Shows the gossip information for the cluster"");
	 addCmdHelp(header, ""invalidatekeycache"", ""Invalidate the key cache"");
	 addCmdHelp(header, ""invalidaterowcache"", ""Invalidate the row cache"");
	 addCmdHelp(header, ""resetlocalschema"", ""Reset node's local schema and resync"");
	 addCmdHelp(header, ""netstats [host]"", ""Print network information on provided host (connecting node by default)"");
	 addCmdHelp(header, ""move <new token>"", ""Move node on the token ring to a new token"");
	 addCmdHelp(header, ""removetoken status|force|<token>"", ""Show status of current token removal, force completion of pending removal or remove providen token"");
	 addCmdHelp(header, ""setcompactionthroughput <value_in_mb>"", ""Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling."");
	 addCmdHelp(header, ""setstreamthroughput <value_in_mb>"", ""Set the MB/s throughput cap for streaming in the system, or 0 to disable throttling."");
	 addCmdHelp(header, ""describering [keyspace]"", ""Shows the token ranges info of a given keyspace."");
	 addCmdHelp(header, ""rangekeysample"", ""Shows the sampled keys held across all keyspaces."");
	 addCmdHelp(header, ""rebuild [src-dc-name]"", ""Rebuild data by streaming from other nodes (similarly to bootstrap)"");
	 addCmdHelp(header, ""snapshot [keyspaces...] -t [snapshotName]"", ""Take a snapshot of the specified keyspaces using optional name snapshotName"");
	 addCmdHelp(header, ""clearsnapshot [keyspaces...] -t [snapshotName]"", ""Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name."");
	 addCmdHelp(header, ""flush [keyspace] [cfnames]"", ""Flush one or more column family"");
	 addCmdHelp(header, ""repair [keyspace] [cfnames]"", ""Repair one or more column family (use -pr to repair only the first range returned by the partitioner)"");
	 addCmdHelp(header, ""cleanup [keyspace] [cfnames]"", ""Run cleanup on one or more column family"");
	 addCmdHelp(header, ""compact [keyspace] [cfnames]"", ""Force a (major) compaction on one or more column family"");
	 addCmdHelp(header, ""scrub [keyspace] [cfnames]"", ""Scrub (rebuild sstables for) one or more column family"");
	 addCmdHelp(header, ""upgradesstables [keyspace] [cfnames]"", ""Scrub (rebuild sstables for) one or more column family"");
	 addCmdHelp(header, ""getcompactionthreshold <keyspace> <cfname>"", ""Print min and max compaction thresholds for a given column family"");
	 addCmdHelp(header, ""cfhistograms <keyspace> <cfname>"", ""Print statistic histograms for a given column family"");
	 addCmdHelp(header, ""refresh <keyspace> <cf-name>"", ""Load newly placed SSTables to the system without restart."");
	 addCmdHelp(header, ""rebuild_index <keyspace> <cf-name> <idx1,idx1>"", ""a full rebuilds of native secondry index for a given column family. IndexNameExample: Standard3.IdxName,Standard3.IdxName1"");
	 addCmdHelp(header, ""getendpoints <keyspace> <cf> <key>"", ""Print the end points that owns the key"");
	 addCmdHelp(header, ""setcachecapacity <keyspace> <cfname> <keycachecapacity> <rowcachecapacity>"", ""Set the key and row cache capacities of a given column family"");
	 addCmdHelp(header, ""setcompactionthreshold <keyspace> <cfname> <minthreshold> <maxthreshold>"", ""Set the min and max compaction thresholds for a given column family"");
	 addCmdHelp(header, ""stop <compaction_type>"", ""Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, INDEX_BUILD"");
	 String usage = String.format(""java %s --host <arg> <command>%n"", NodeCmd.class.getName());
	 hf.printHelp(usage, """", options, """");
	 System.out.println(header.toString());
 }",0,0,0,0
"public String getTaskId() {
	 return taskId;
 }",0,0,0,0
"public class ProjectClasspathChangeListener implements IElementChangedListener {
	private final static Logger log = Logger.getLogger(ProjectClasspathChangeListener.class);
	private IWorkspace workspace;
	private org.eclipse.xtext.builder.impl.BuildScheduler buildManager;
	private IDirtyStateManager dirtyStateManager;
	private JavaProjectClasspathChangeAnalyzer javaProjectClasspathChangeAnalyzer;
	public void elementChanged(ElementChangedEvent event) {
		if (workspace != null && workspace.isAutoBuilding()) {
			try {
				if (event.getDelta() != null) {
					Set<IJavaProject> javaProjects = getJavaProjectsWithClasspathChange(event.getDelta());
					if (!javaProjects.isEmpty()) {
						Set<IProject> projects = FluentIterable.from(javaProjects).filter(Predicates.notNull()).transform(IJavaProject::getProject).toSet();
						dirtyStateManager.notifyListeners(new CoarseGrainedChangeEvent());
						scheduleBuildIfNecessary(projects);
					}
				}
			}
			 catch (WrappedException e) {
				log.error(e.getCause().getMessage(), e.getCause());
			}
			 catch (RuntimeException e) {
				log.error(e.getMessage(), e);
			}
		}
	}
	private void scheduleBuildIfNecessary(Set<IProject> projects) {
		buildManager.scheduleBuildIfNecessary(projects, IBuildFlag.FORGET_BUILD_STATE_ONLY);
	}
	protected Set<IJavaProject> getJavaProjectsWithClasspathChange(IJavaElementDelta delta) {
		return javaProjectClasspathChangeAnalyzer.getJavaProjectsWithClasspathChange(delta);
	}
}",0,0,0,0
"abstract class AbstractFuzzyHashProcessor extends AbstractProcessor {
	 final protected static String ssdeep = ""ssdeep"";
	 final protected static String tlsh = ""tlsh"";
	 public static final AllowableValue allowableValueSSDEEP = new AllowableValue( ssdeep, ssdeep, ""Uses ssdeep / SpamSum 'context triggered piecewise hash'."");
	 public static final AllowableValue allowableValueTLSH = new AllowableValue( tlsh, tlsh, ""Uses TLSH (Trend 'Locality Sensitive Hash'). Note: FlowFile Content must be at least 512 characters long"");
	 public static final PropertyDescriptor ATTRIBUTE_NAME = new PropertyDescriptor.Builder() .name(""ATTRIBUTE_NAME"") .displayName(""Hash Attribute Name"") .description(""The name of the FlowFile Attribute that should hold the Fuzzy Hash Value"") .required(true) .addValidator(StandardValidators.NON_EMPTY_VALIDATOR) .defaultValue(""fuzzyhash.value"") .build();
	 public static final PropertyDescriptor HASH_ALGORITHM = new PropertyDescriptor.Builder() .name(""HASH_ALGORITHM"") .displayName(""Hashing Algorithm"") .description(""The hashing algorithm utilised"") .allowableValues(allowableValueSSDEEP, allowableValueTLSH) .required(true) .addValidator(StandardValidators.NON_EMPTY_VALIDATOR) .build();
	 protected List<PropertyDescriptor> descriptors;
	 protected Set<Relationship> relationships;
	 protected boolean checkMinimumAlgorithmRequirements(String algorithm, FlowFile flowFile) {
		 if (algorithm.equals(tlsh) && flowFile.getSize() < 512 ) {
			 return false;
		 }
		 else {
			 return true;
		 }
	 }
	 protected String generateHash(String algorithm, String content) {
		 switch (algorithm) {
			 case tlsh: return new TLSH(content).hash();
			 case ssdeep: return new SpamSum().HashString(content);
			 default: return null;
		 }
	 }
}",0,0,0,0
"public class MP3FileExtractor extends AbstractFileExtractor {
	 private Logger logger = LoggerFactory.getLogger(MP3FileExtractor.class);
	 protected void performExtraction(URI arg0, File arg1, Charset arg2, String arg3, RDFContainer result) throws ExtractorException {
		 try {
			 Mp3File mp3File = new Mp3File(arg1.toString());
			 ID3v1 id3v1 = mp3File.getId3v1Tag();
			 ID3v2 id3v2 = mp3File.getId3v2Tag();
			 ID3Wrapper wrapper = new ID3Wrapper(id3v1,id3v2);
			 addId3Fields(wrapper,result);
			 result.add(RDF.type, NID3.ID3Audio);
		 }
		 catch (UnsupportedTagException e) {
			 throw new ExtractorException(e);
		 }
		 catch (InvalidDataException e) {
			 throw new ExtractorException(e);
		 }
		 catch (IOException e) {
			 throw new ExtractorException(e);
		 }
	 }
	 private void addId3Fields(ID3Wrapper wrapper, RDFContainer result) {
		 String value = null;
		 if ((value = wrapper.getAlbum()) != null) {
			 result.add(NID3.albumTitle,value);
		 }
		 if ((value = wrapper.getArtist()) != null) {
			 addSimpleContact(NID3.originalArtist,value,result);
		 }
		 if ((value = wrapper.getComment()) != null) {
			 result.add(NID3.comments,value);
		 }
		 if ((value = wrapper.getComposer())!= null) {
			 addSimpleContact(NID3.composer,value,result);
		 }
		 if ((value = wrapper.getCopyright()) != null) {
			 result.add(NID3.copyrightMessage,value);
		 }
		 if ((value = wrapper.getEncoder()) != null) {
			 addSimpleContact(NID3.encodedBy, value,result);
		 }
		 if ((value = wrapper.getGenreDescription()) != null) {
			 result.add(NID3.contentType,value);
		 }
		 if ((value = wrapper.getTitle()) != null) {
			 result.add(NID3.title,value);
		 }
		 if ((value = wrapper.getOriginalArtist()) != null) {
			 addSimpleContact(NID3.originalArtist,value,result);
		 }
		 if ((value = wrapper.getTrack()) != null) {
			 addSimpleContact(NID3.trackNumber,value,result);
		 }
		 if ((value = wrapper.getYear()) != null) {
			 try {
				 int year = Integer.parseInt(value);
				 result.add(NID3.recordingYear,year);
			 }
			 catch(NumberFormatException e) {
			}
		 }
	 }
	 protected void addSimpleContact(URI property, String fullname, RDFContainer container) {
		 Model model = container.getModel();
		 RDFTerm resource = ModelUtil.generateRandomResource(model);
		 model.addStatement(resource, RDF.type, NCO.Contact);
		 model.addStatement(resource, NCO.fullname, fullname);
		 model.addStatement(container.getDescribedUri(), property, resource);
	}
}",0,0,0,0
"public static void main(String argv[]) throws FileNotFoundException, IOException {
	 if (argv.length < 2) {
		 System.out.println(""Usage: java org.apache.nutch.db.DistributedWebDBReader (-local | -ndfs <namenode:port>) <root> [-pageurl url] | [-pagemd5 md5] | [-dumppageurl] | [-dumppagemd5] | [-toppages <k>] | [-linkurl url] | [-linkmd5 md5] | [-dumplinks] | [-stats]"");
		 return;
	 }
	 int i = 0;
	 NutchFileSystem nfs = NutchFileSystem.parseArgs(argv, i);
	 File root = new File(argv[i++]);
	 DistributedWebDBReader reader = new DistributedWebDBReader(nfs, root);
	 try {
		 String cmd = argv[i++];
		 if (""-pageurl"".equals(cmd)) {
			 String url = argv[i++];
			 System.out.println(reader.getPage(url.trim()));
		 }
		 else if (""-pagemd5"".equals(cmd)) {
			 MD5Hash md5 = new MD5Hash(argv[i++]);
			 Page pages[] = reader.getPages(md5);
			 System.out.println(""Found "" + pages.length + "" pages."");
			 for (int j = 0;
			 j < pages.length;
			 j++) {
				 System.out.println(""Page "" + j + "": "" + pages[j]);
			 }
		 }
		 else if (""-dumppageurl"".equals(cmd)) {
			 int j = 1;
			 for (Enumeration e = reader.pages();
			 e.hasMoreElements();
			 j++) {
				 Page page = (Page) e.nextElement();
				 System.out.println(""Page "" + j + "": "" + page);
				 System.out.println();
			 }
		 }
		 else if (""-dumppagemd5"".equals(cmd)) {
			 int j = 1;
			 for (Enumeration e = reader.pagesByMD5();
			 e.hasMoreElements();
			 j++) {
				 Page page = (Page) e.nextElement();
				 System.out.println(""Page "" + j + "": "" + page);
				 System.out.println();
			 }
		 }
		 else if (""-toppages"".equals(cmd)) {
			 int topSize = Integer.parseInt(argv[i++]);
			 SortedSet topSet = new TreeSet(new Comparator() {
				 public int compare(Object o1, Object o2) {
					 Page p1 = (Page) o1;
					 Page p2 = (Page) o2;
					 if (p1.getScore() < p2.getScore()) {
						 return -1;
					 }
					 else if (p1.getScore() == p2.getScore()) {
						 return p1.compareTo(p2);
					 }
					 else {
						 return 1;
					 }
				 }
			 }
			 );
			 Page lowestPage = null;
			 for (Enumeration e = reader.pages();
			 e.hasMoreElements();
			 ) {
				 Page curPage = (Page) e.nextElement();
				 if (topSet.size() < topSize) {
					 topSet.add(curPage);
					 lowestPage = (Page) topSet.first();
				 }
				 else if (lowestPage.getScore() < curPage.getScore()) {
					 topSet.remove(lowestPage);
					 topSet.add(curPage);
					 lowestPage = (Page) topSet.first();
				 }
			 }
			 int j = 0;
			 for (Iterator it = topSet.iterator();
			 it.hasNext();
			 j++) {
				 System.out.println(""Page "" + j + "": "" + (Page) it.next());
				 System.out.println();
			 }
		 }
		 else if (""-linkurl"".equals(cmd)) {
			 String url = argv[i++];
			 Link links[] = reader.getLinks(new UTF8(url.trim()));
			 System.out.println(""Found "" + links.length + "" links."");
			 for (int j = 0;
			 j < links.length;
			 j++) {
				 System.out.println(""Link "" + j + "": "" + links[j]);
			 }
		 }
		 else if (""-linkmd5"".equals(cmd)) {
			 MD5Hash fromID = new MD5Hash(argv[i++]);
			 Link links[] = reader.getLinks(fromID);
			 System.out.println(""Found "" + links.length + "" links."");
			 for (int j = 0;
			 j < links.length;
			 j++) {
				 System.out.println(""Link "" + j + "": "" + links[j]);
			 }
		 }
		 else if (""-dumplinks"".equals(cmd)) {
			 int j = 1;
			 for (Enumeration e = reader.links();
			 e.hasMoreElements();
			 j++) {
				 Link link = (Link) e.nextElement();
				 System.out.println(""Link "" + j + "": "" + link);
				 System.out.println();
			 }
		 }
		 else if (""-stats"".equals(cmd)) {
			 System.out.println(""Stats for "" + reader);
			 System.out.println(""-------------------------------"");
			 System.out.println(""Number of pages: "" + reader.numPages());
			 System.out.println(""Number of links: "" + reader.numLinks());
			 System.out.println(""Number of machines (sections): "" + reader.numMachines());
		 }
		 else {
			 System.out.println(""Sorry, no command with name "" + cmd);
		 }
	 }
	 finally {
		 reader.close();
	 }
 }",0,0,1,0
"public class JarModule {
	 private ModuleRevisionId mrid;
	 private File jar;
	 public JarModule(ModuleRevisionId mrid, File jar) {
		 this.mrid = mrid;
		 this.jar = jar;
	 }
	 public File getJar() {
		 return jar;
	 }
	 public ModuleRevisionId getMrid() {
		 return mrid;
	 }
	 public String toString() {
		 return jar + "" "" + mrid;
	 }
}",0,1,0,0
"class DFA28 extends DFA {
	 public DFA28(BaseRecognizer recognizer) {
		 this.recognizer = recognizer;
		 this.decisionNumber = 28;
		 this.eot = dfa_9;
		 this.eof = dfa_21;
		 this.min = dfa_10;
		 this.max = dfa_11;
		 this.accept = dfa_12;
		 this.special = dfa_13;
		 this.transition = dfa_14;
	 }
	 public String getDescription() {
		 return ""4005:2: ( rule__Object__UnorderedGroup_5__5 )?"";
	 }
	 public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
		 TokenStream input = (TokenStream)_input;
		 int _s = s;
		 switch ( s ) {
			 case 0 : int LA28_0 = input.LA(1);
			 int index28_0 = input.index();
			 input.rewind();
			 s = -1;
			 if ( LA28_0 == 19 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 0) ) {
				s = 1;
			}
			 else if ( LA28_0 == 20 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 1) ) {
				s = 2;
			}
			 else if ( LA28_0 == 21 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 2) ) {
				s = 3;
			}
			 else if ( LA28_0 == 33 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 3) ) {
				s = 4;
			}
			 else if ( LA28_0 == 26 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 4) ) {
				s = 5;
			}
			 else if ( LA28_0 == 27 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 4) ) {
				s = 6;
			}
			 else if ( LA28_0 == 22 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 5) ) {
				s = 7;
			}
			 else if ( LA28_0 == 24 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 6) ) {
				s = 8;
			}
			 else if ( LA28_0 == 25 && getUnorderedGroupHelper().canSelect(grammarAccess.getObjectAccess().getUnorderedGroup_5(), 7) ) {
				s = 9;
			}
			 else if ( (LA28_0==EOF||LA28_0==17) ) {
				s = 10;
			}
			 input.seek(index28_0);
			 if ( s>=0 ) return s;
			 break;
		 }
		 if (state.backtracking>0) {
			state.failed=true;
			 return -1;
		}
		 NoViableAltException nvae = new NoViableAltException(getDescription(), 28, _s, input);
		 error(nvae);
		 throw nvae;
	 }
 }",1,0,0,0
"public synchronized Task pollForNewTask(String taskTracker) {
	 int avgMaps = 0;
	 int avgReduces = 0;
	 int remainingReduceLoad = 0;
	 int remainingMapLoad = 0;
	 int numTaskTrackers;
	 TaskTrackerStatus tts;
	 int avgMapLoad = 0;
	 int avgReduceLoad = 0;
	 synchronized (taskTrackers) {
		 numTaskTrackers = taskTrackers.size();
		 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
	 }
	 synchronized(jobsByArrival){
		 for (Iterator it = jobsByArrival.iterator();
		 it.hasNext();
		 ) {
			 JobInProgress job = (JobInProgress) it.next();
			 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
				 int totalMapTasks = job.desiredMaps();
				 int totalReduceTasks = job.desiredReduces();
				 remainingMapLoad += (totalMapTasks - job.finishedMaps());
				 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
			 }
		 }
	 }
	 if (numTaskTrackers > 0) {
		 avgMaps = totalMaps / numTaskTrackers;
		 avgReduces = totalReduces / numTaskTrackers;
		 avgMapLoad = remainingMapLoad / numTaskTrackers;
		 avgReduceLoad = remainingReduceLoad / numTaskTrackers;
	 }
	 int totalCapacity = numTaskTrackers * maxCurrentTasks;
	 if (tts == null) {
		 LOG.warn(""Unknown task tracker polling;
		 ignoring: "" + taskTracker);
		 return null;
	 }
	 int numMaps = tts.countMapTasks();
	 int numReduces = tts.countReduceTasks();
	 synchronized (jobsByArrival) {
		 if ((numMaps < maxCurrentTasks) && (numMaps <= avgMapLoad + 1 + TASK_ALLOC_EPSILON)) {
			 int totalNeededMaps = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewMapTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 return t;
				 }
				 totalNeededMaps += job.desiredMaps();
				 double padding = 0;
				 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, totalNeededMaps * PAD_FRACTION);
				 }
				 if (totalNeededMaps + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
		 if ((numReduces < maxCurrentTasks) && (numReduces <= avgReduceLoad + 1 + TASK_ALLOC_EPSILON)) {
			 int totalNeededReduces = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewReduceTask(taskTracker, tts);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 return t;
				 }
				 totalNeededReduces += job.desiredReduces();
				 double padding = 0;
				 if (totalCapacity > MIN_SLOTS_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, totalNeededReduces * PAD_FRACTION);
				 }
				 if (totalNeededReduces + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public abstract static class SystemTimerTask extends TimerTask {
	 protected static final Logger logger = LogService.getLogger();
	 public abstract void run2();
	 public void run() {
		 final boolean isDebugEnabled = logger.isTraceEnabled();
		 if (isDebugEnabled) {
			 logger.trace(""SystemTimer.MyTask: starting {
			}
			"", this);
		 }
		 try {
			 this.run2();
		 }
		 catch (CancelException ignore) {
		 }
		 catch (VirtualMachineError e) {
			 SystemFailure.initiateFailure(e);
			 throw e;
		 }
		 catch (Throwable t) {
			 SystemFailure.checkFailure();
			 logger.warn(String.format(""Timer task <%s> encountered exception"", this), t);
		 }
		 if (isDebugEnabled) {
			 logger.trace(""SystemTimer.MyTask: finished {
			}
			"", this);
		 }
	 }
 }",0,0,0,0
"public class PackageCoverage{
	private double branchCount;
	private double lineCount;
	private double branchCoverage;
	private double lineCoverage;
	public double getBranchCount(){
		return branchCount;
	}
	public void addBranchCount(double branchCount){
		this.branchCount += branchCount;
	}
	public double getLineCount(){
		return lineCount;
	}
	public void addLineCount(double lineCount){
		this.lineCount += lineCount;
	}
	public double getBranchCoverage(){
		return branchCoverage;
	}
	public void addBranchCoverage(double branchCoverage){
		this.branchCoverage += branchCoverage;
	}
	public double getLineCoverage(){
		return lineCoverage;
	}
	public void addLineCoverage(double lineCoverage){
		this.lineCoverage += lineCoverage;
	}
}",0,1,0,0
"static String lookUpFactoryClassName(String factoryId, String propertiesFilename, String fallbackClassName);",0,0,0,1
"public class TestLanguageIdeModule extends AbstractTestLanguageIdeModule {
	 public Class<? extends ILanguageServerExtension> bindLanguageServerExtension() {
		 return TestLangLSPExtension.class;
	 }
	 public Class<? extends ICodeLensResolver> bindICodeLensResolver() {
		 return CodeLensService.class;
	 }
	 public Class<? extends ICodeLensService> bindICodeLensService() {
		 return CodeLensService.class;
	 }
	 public Class<? extends ICodeActionService> bindICodeActionService() {
		 return CodeActionService.class;
	 }
	 public Class<? extends IExecutableCommandService> bindIExecutableCommandService() {
		 return TestLanguageExecutableCommandService.class;
	 }
	 public Class<? extends IdeContentProposalCreator> bindIdeContentProposalCreator() {
		 return TestLanguageProposalCreator.class;
	 }
	 public Class<? extends IdeContentProposalProvider> bindIdeContentProposalProvider() {
		 return TestLanguageIdeContentProposalProvider.class;
	 }
}",0,0,0,0
"public class CBZip2OutputStream extends OutputStream implements BZip2Constants {
	 public static final int MIN_BLOCKSIZE = 1;
	 public static final int MAX_BLOCKSIZE = 9;
	 protected static final int SETMASK = (1 << 21);
	 protected static final int CLEARMASK = (~SETMASK);
	 protected static final int GREATER_ICOST = 15;
	 protected static final int LESSER_ICOST = 0;
	 protected static final int SMALL_THRESH = 20;
	 protected static final int DEPTH_THRESH = 10;
	 protected static final int WORK_FACTOR = 30;
	 protected static final int QSORT_STACK_SIZE = 1000;
	 private static final int[] INCS = {
	 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }
	;
	 protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) {
		 final int[] heap = new int[MAX_ALPHA_SIZE * 2];
		 final int[] weight = new int[MAX_ALPHA_SIZE * 2];
		 final int[] parent = new int[MAX_ALPHA_SIZE * 2];
		 for (int i = alphaSize;
		 --i >= 0;
		) {
			 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
		 }
		 for (boolean tooLong = true;
		 tooLong;
		) {
			 tooLong = false;
			 int nNodes = alphaSize;
			 int nHeap = 0;
			 heap[0] = 0;
			 weight[0] = 0;
			 parent[0] = -2;
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 parent[i] = -1;
				 nHeap++;
				 heap[nHeap] = i;
				 int zz = nHeap;
				 int tmp = heap[zz];
				 while (weight[tmp] < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 while (nHeap > 1) {
				 int n1 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 int yy = 0;
				 int zz = 1;
				 int tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 int n2 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 yy = 0;
				 zz = 1;
				 tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 nNodes++;
				 parent[n1] = parent[n2] = nNodes;
				 final int weight_n1 = weight[n1];
				 final int weight_n2 = weight[n2];
				 weight[nNodes] = (((weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)) | (1 + (((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)) ? (weight_n1 & 0x000000ff) : (weight_n2 & 0x000000ff)) ));
				 parent[nNodes] = -1;
				 nHeap++;
				 heap[nHeap] = nNodes;
				 tmp = 0;
				 zz = nHeap;
				 tmp = heap[zz];
				 final int weight_tmp = weight[tmp];
				 while (weight_tmp < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 int j = 0;
				 int k = i;
				 for (int parent_k;
				 (parent_k = parent[k]) >= 0;
				) {
					 k = parent_k;
					 j++;
				 }
				 len[i - 1] = (char) j;
				 if (j > maxLen) {
					 tooLong = true;
				 }
			 }
			 if (tooLong) {
				 for (int i = 1;
				 i < alphaSize;
				 i++) {
					 int j = weight[i] >> 8;
					 j = 1 + (j >> 1);
					 weight[i] = j << 8;
				 }
			 }
		 }
	 }
	 private static void hbMakeCodeLengths(final byte[] len, final int[] freq, final Data dat, final int alphaSize, final int maxLen) {
		 final int[] heap = dat.heap;
		 final int[] weight = dat.weight;
		 final int[] parent = dat.parent;
		 for (int i = alphaSize;
		 --i >= 0;
		) {
			 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
		 }
		 for (boolean tooLong = true;
		 tooLong;
		) {
			 tooLong = false;
			 int nNodes = alphaSize;
			 int nHeap = 0;
			 heap[0] = 0;
			 weight[0] = 0;
			 parent[0] = -2;
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 parent[i] = -1;
				 nHeap++;
				 heap[nHeap] = i;
				 int zz = nHeap;
				 int tmp = heap[zz];
				 while (weight[tmp] < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 while (nHeap > 1) {
				 int n1 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 int yy = 0;
				 int zz = 1;
				 int tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 int n2 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 yy = 0;
				 zz = 1;
				 tmp = heap[1];
				 while (true) {
					 yy = zz << 1;
					 if (yy > nHeap) {
						 break;
					 }
					 if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) {
						 yy++;
					 }
					 if (weight[tmp] < weight[heap[yy]]) {
						 break;
					 }
					 heap[zz] = heap[yy];
					 zz = yy;
				 }
				 heap[zz] = tmp;
				 nNodes++;
				 parent[n1] = parent[n2] = nNodes;
				 final int weight_n1 = weight[n1];
				 final int weight_n2 = weight[n2];
				 weight[nNodes] = ((weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)) | (1 + (((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)) ? (weight_n1 & 0x000000ff) : (weight_n2 & 0x000000ff)));
				 parent[nNodes] = -1;
				 nHeap++;
				 heap[nHeap] = nNodes;
				 tmp = 0;
				 zz = nHeap;
				 tmp = heap[zz];
				 final int weight_tmp = weight[tmp];
				 while (weight_tmp < weight[heap[zz >> 1]]) {
					 heap[zz] = heap[zz >> 1];
					 zz >>= 1;
				 }
				 heap[zz] = tmp;
			 }
			 for (int i = 1;
			 i <= alphaSize;
			 i++) {
				 int j = 0;
				 int k = i;
				 for (int parent_k;
				 (parent_k = parent[k]) >= 0;
				) {
					 k = parent_k;
					 j++;
				 }
				 len[i - 1] = (byte) j;
				 if (j > maxLen) {
					 tooLong = true;
				 }
			 }
			 if (tooLong) {
				 for (int i = 1;
				 i < alphaSize;
				 i++) {
					 int j = weight[i] >> 8;
					 j = 1 + (j >> 1);
					 weight[i] = j << 8;
				 }
			 }
		 }
	 }
	 private int last;
	 private int origPtr;
	 private final int blockSize100k;
	 private boolean blockRandomised;
	 private int bsBuff;
	 private int bsLive;
	 private final CRC crc = new CRC();
	 private int nInUse;
	 private int nMTF;
	 private int workDone;
	 private int workLimit;
	 private boolean firstAttempt;
	 private int currentChar = -1;
	 private int runLength = 0;
	 private int blockCRC;
	 private int combinedCRC;
	 private int allowableBlockSize;
	 private CBZip2OutputStream.Data data;
	 private OutputStream out;
	 public static int chooseBlockSize(long inputLength) {
		 return (inputLength > 0) ? (int) Math .min((inputLength / 132000) + 1, 9) : MAX_BLOCKSIZE;
	 }
	 public CBZip2OutputStream(final OutputStream out) throws IOException {
		 this(out, MAX_BLOCKSIZE);
	 }
	 public CBZip2OutputStream(final OutputStream out, final int blockSize) throws IOException {
		 super();
		 if (blockSize < 1) {
			 throw new IllegalArgumentException(""blockSize("" + blockSize + "") < 1"");
		 }
		 if (blockSize > 9) {
			 throw new IllegalArgumentException(""blockSize("" + blockSize + "") > 9"");
		 }
		 this.blockSize100k = blockSize;
		 this.out = out;
		 init();
	 }
	 public void write(final int b) throws IOException {
		 if (this.out != null) {
			 write0(b);
		 }
		 else {
			 throw new IOException(""closed"");
		 }
	 }
	 private void writeRun() throws IOException {
		 final int lastShadow = this.last;
		 if (lastShadow < this.allowableBlockSize) {
			 final int currentCharShadow = this.currentChar;
			 final Data dataShadow = this.data;
			 dataShadow.inUse[currentCharShadow] = true;
			 final byte ch = (byte) currentCharShadow;
			 int runLengthShadow = this.runLength;
			 this.crc.updateCRC(currentCharShadow, runLengthShadow);
			 switch (runLengthShadow) {
				 case 1: dataShadow.block[lastShadow + 2] = ch;
				 this.last = lastShadow + 1;
				 break;
				 case 2: dataShadow.block[lastShadow + 2] = ch;
				 dataShadow.block[lastShadow + 3] = ch;
				 this.last = lastShadow + 2;
				 break;
				 case 3: {
					 final byte[] block = dataShadow.block;
					 block[lastShadow + 2] = ch;
					 block[lastShadow + 3] = ch;
					 block[lastShadow + 4] = ch;
					 this.last = lastShadow + 3;
				 }
				 break;
				 default: {
					 runLengthShadow -= 4;
					 dataShadow.inUse[runLengthShadow] = true;
					 final byte[] block = dataShadow.block;
					 block[lastShadow + 2] = ch;
					 block[lastShadow + 3] = ch;
					 block[lastShadow + 4] = ch;
					 block[lastShadow + 5] = ch;
					 block[lastShadow + 6] = (byte) runLengthShadow;
					 this.last = lastShadow + 5;
				 }
				 break;
			 }
		 }
		 else {
			 endBlock();
			 initBlock();
			 writeRun();
		 }
	 }
	 protected void finalize() throws Throwable {
		 finish();
		 super.finalize();
	 }
	 public void finish() throws IOException {
		 if (out != null) {
			 try {
				 if (this.runLength > 0) {
					 writeRun();
				 }
				 this.currentChar = -1;
				 endBlock();
				 endCompression();
			 }
			 finally {
				 this.out = null;
				 this.data = null;
			 }
		 }
	 }
	 public void close() throws IOException {
		 if (out != null) {
			 OutputStream outShadow = this.out;
			 finish();
			 outShadow.close();
		 }
	 }
	 public void flush() throws IOException {
		 OutputStream outShadow = this.out;
		 if (outShadow != null) {
			 outShadow.flush();
		 }
	 }
	 private void init() throws IOException {
		 this.data = new Data(this.blockSize100k);
		 bsPutUByte('h');
		 bsPutUByte('0' + this.blockSize100k);
		 this.combinedCRC = 0;
		 initBlock();
	 }
	 private void initBlock() {
		 this.crc.initialiseCRC();
		 this.last = -1;
		 boolean[] inUse = this.data.inUse;
		 for (int i = 256;
		 --i >= 0;
		) {
			 inUse[i] = false;
		 }
		 this.allowableBlockSize = (this.blockSize100k * BZip2Constants.baseBlockSize) - 20;
	 }
	 private void endBlock() throws IOException {
		 this.blockCRC = this.crc.getFinalCRC();
		 this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);
		 this.combinedCRC ^= this.blockCRC;
		 if (this.last == -1) {
			 return;
		 }
		 blockSort();
		 bsPutUByte(0x31);
		 bsPutUByte(0x41);
		 bsPutUByte(0x59);
		 bsPutUByte(0x26);
		 bsPutUByte(0x53);
		 bsPutUByte(0x59);
		 bsPutInt(this.blockCRC);
		 if (this.blockRandomised) {
			 bsW(1, 1);
		 }
		 else {
			 bsW(1, 0);
		 }
		 moveToFrontCodeAndSend();
	 }
	 private void endCompression() throws IOException {
		 bsPutUByte(0x17);
		 bsPutUByte(0x72);
		 bsPutUByte(0x45);
		 bsPutUByte(0x38);
		 bsPutUByte(0x50);
		 bsPutUByte(0x90);
		 bsPutInt(this.combinedCRC);
		 bsFinishedWithStream();
	 }
	 public final int getBlockSize() {
		 return this.blockSize100k;
	 }
	 public void write(final byte[] buf, int offs, final int len) throws IOException {
		 if (offs < 0) {
			 throw new IndexOutOfBoundsException(""offs("" + offs + "") < 0."");
		 }
		 if (len < 0) {
			 throw new IndexOutOfBoundsException(""len("" + len + "") < 0."");
		 }
		 if (offs + len > buf.length) {
			 throw new IndexOutOfBoundsException(""offs("" + offs + "") + len("" + len + "") > buf.length("" + buf.length + "")."");
		 }
		 if (this.out == null) {
			 throw new IOException(""stream closed"");
		 }
		 for (int hi = offs + len;
		 offs < hi;
		) {
			 write0(buf[offs++]);
		 }
	 }
	 private void write0(int b) throws IOException {
		 if (this.currentChar != -1) {
			 b &= 0xff;
			 if (this.currentChar == b) {
				 if (++this.runLength > 254) {
					 writeRun();
					 this.currentChar = -1;
					 this.runLength = 0;
				 }
			 }
			 else {
				 writeRun();
				 this.runLength = 1;
				 this.currentChar = b;
			 }
		 }
		 else {
			 this.currentChar = b & 0xff;
			 this.runLength++;
		 }
	 }
	 private static void hbAssignCodes(final int[] code, final byte[] length, final int minLen, final int maxLen, final int alphaSize) {
		 int vec = 0;
		 for (int n = minLen;
		 n <= maxLen;
		 n++) {
			 for (int i = 0;
			 i < alphaSize;
			 i++) {
				 if ((length[i] & 0xff) == n) {
					 code[i] = vec;
					 vec++;
				 }
			 }
			 vec <<= 1;
		 }
	 }
	 private void bsFinishedWithStream() throws IOException {
		 while (this.bsLive > 0) {
			 int ch = this.bsBuff >> 24;
			 this.out.write(ch);
			 this.bsBuff <<= 8;
			 this.bsLive -= 8;
		 }
	 }
	 private void bsW(final int n, final int v) throws IOException {
		 final OutputStream outShadow = this.out;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 while (bsLiveShadow >= 8) {
			 outShadow.write(bsBuffShadow >> 24);
			 bsBuffShadow <<= 8;
			 bsLiveShadow -= 8;
		 }
		 this.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));
		 this.bsLive = bsLiveShadow + n;
	 }
	 private void bsPutUByte(final int c) throws IOException {
		 bsW(8, c);
	 }
	 private void bsPutInt(final int u) throws IOException {
		 bsW(8, (u >> 24) & 0xff);
		 bsW(8, (u >> 16) & 0xff);
		 bsW(8, (u >> 8) & 0xff);
		 bsW(8, u & 0xff);
	 }
	 private void sendMTFValues() throws IOException {
		 final byte[][] len = this.data.sendMTFValues_len;
		 final int alphaSize = this.nInUse + 2;
		 for (int t = N_GROUPS;
		 --t >= 0;
		) {
			 byte[] len_t = len[t];
			 for (int v = alphaSize;
			 --v >= 0;
			) {
				 len_t[v] = GREATER_ICOST;
			 }
		 }
		 final int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3 : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
		 sendMTFValues0(nGroups, alphaSize);
		 final int nSelectors = sendMTFValues1(nGroups, alphaSize);
		 sendMTFValues2(nGroups, nSelectors);
		 sendMTFValues3(nGroups, alphaSize);
		 sendMTFValues4();
		 sendMTFValues5(nGroups, nSelectors);
		 sendMTFValues6(nGroups, alphaSize);
		 sendMTFValues7(nSelectors);
	 }
	 private void sendMTFValues0(final int nGroups, final int alphaSize) {
		 final byte[][] len = this.data.sendMTFValues_len;
		 final int[] mtfFreq = this.data.mtfFreq;
		 int remF = this.nMTF;
		 int gs = 0;
		 for (int nPart = nGroups;
		 nPart > 0;
		 nPart--) {
			 final int tFreq = remF / nPart;
			 int ge = gs - 1;
			 int aFreq = 0;
			 for (final int a = alphaSize - 1;
			 (aFreq < tFreq) && (ge < a);
			) {
				 aFreq += mtfFreq[++ge];
			 }
			 if ((ge > gs) && (nPart != nGroups) && (nPart != 1) && (((nGroups - nPart) & 1) != 0)) {
				 aFreq -= mtfFreq[ge--];
			 }
			 final byte[] len_np = len[nPart - 1];
			 for (int v = alphaSize;
			 --v >= 0;
			) {
				 if ((v >= gs) && (v <= ge)) {
					 len_np[v] = LESSER_ICOST;
				 }
				 else {
					 len_np[v] = GREATER_ICOST;
				 }
			 }
			 gs = ge + 1;
			 remF -= aFreq;
		 }
	 }
	 private int sendMTFValues1(final int nGroups, final int alphaSize) {
		 final Data dataShadow = this.data;
		 final int[][] rfreq = dataShadow.sendMTFValues_rfreq;
		 final int[] fave = dataShadow.sendMTFValues_fave;
		 final short[] cost = dataShadow.sendMTFValues_cost;
		 final char[] sfmap = dataShadow.sfmap;
		 final byte[] selector = dataShadow.selector;
		 final byte[][] len = dataShadow.sendMTFValues_len;
		 final byte[] len_0 = len[0];
		 final byte[] len_1 = len[1];
		 final byte[] len_2 = len[2];
		 final byte[] len_3 = len[3];
		 final byte[] len_4 = len[4];
		 final byte[] len_5 = len[5];
		 final int nMTFShadow = this.nMTF;
		 int nSelectors = 0;
		 for (int iter = 0;
		 iter < N_ITERS;
		 iter++) {
			 for (int t = nGroups;
			 --t >= 0;
			) {
				 fave[t] = 0;
				 int[] rfreqt = rfreq[t];
				 for (int i = alphaSize;
				 --i >= 0;
				) {
					 rfreqt[i] = 0;
				 }
			 }
			 nSelectors = 0;
			 for (int gs = 0;
			 gs < this.nMTF;
			) {
				 final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
				 if (nGroups == N_GROUPS) {
					 short cost0 = 0;
					 short cost1 = 0;
					 short cost2 = 0;
					 short cost3 = 0;
					 short cost4 = 0;
					 short cost5 = 0;
					 for (int i = gs;
					 i <= ge;
					 i++) {
						 final int icv = sfmap[i];
						 cost0 += len_0[icv] & 0xff;
						 cost1 += len_1[icv] & 0xff;
						 cost2 += len_2[icv] & 0xff;
						 cost3 += len_3[icv] & 0xff;
						 cost4 += len_4[icv] & 0xff;
						 cost5 += len_5[icv] & 0xff;
					 }
					 cost[0] = cost0;
					 cost[1] = cost1;
					 cost[2] = cost2;
					 cost[3] = cost3;
					 cost[4] = cost4;
					 cost[5] = cost5;
				 }
				 else {
					 for (int t = nGroups;
					 --t >= 0;
					) {
						 cost[t] = 0;
					 }
					 for (int i = gs;
					 i <= ge;
					 i++) {
						 final int icv = sfmap[i];
						 for (int t = nGroups;
						 --t >= 0;
						) {
							 cost[t] += len[t][icv] & 0xff;
						 }
					 }
				 }
				 int bt = -1;
				 for (int t = nGroups, bc = 999999999;
				 --t >= 0;
				) {
					 final int cost_t = cost[t];
					 if (cost_t < bc) {
						 bc = cost_t;
						 bt = t;
					 }
				 }
				 fave[bt]++;
				 selector[nSelectors] = (byte) bt;
				 nSelectors++;
				 final int[] rfreq_bt = rfreq[bt];
				 for (int i = gs;
				 i <= ge;
				 i++) {
					 rfreq_bt[sfmap[i]]++;
				 }
				 gs = ge + 1;
			 }
			 for (int t = 0;
			 t < nGroups;
			 t++) {
				 hbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);
			 }
		 }
		 return nSelectors;
	 }
	 private void sendMTFValues2(final int nGroups, final int nSelectors) {
		 final Data dataShadow = this.data;
		 byte[] pos = dataShadow.sendMTFValues2_pos;
		 for (int i = nGroups;
		 --i >= 0;
		) {
			 pos[i] = (byte) i;
		 }
		 for (int i = 0;
		 i < nSelectors;
		 i++) {
			 final byte ll_i = dataShadow.selector[i];
			 byte tmp = pos[0];
			 int j = 0;
			 while (ll_i != tmp) {
				 j++;
				 byte tmp2 = tmp;
				 tmp = pos[j];
				 pos[j] = tmp2;
			 }
			 pos[0] = tmp;
			 dataShadow.selectorMtf[i] = (byte) j;
		 }
	 }
	 private void sendMTFValues3(final int nGroups, final int alphaSize) {
		 int[][] code = this.data.sendMTFValues_code;
		 byte[][] len = this.data.sendMTFValues_len;
		 for (int t = 0;
		 t < nGroups;
		 t++) {
			 int minLen = 32;
			 int maxLen = 0;
			 final byte[] len_t = len[t];
			 for (int i = alphaSize;
			 --i >= 0;
			) {
				 final int l = len_t[i] & 0xff;
				 if (l > maxLen) {
					 maxLen = l;
				 }
				 if (l < minLen) {
					 minLen = l;
				 }
			 }
			 hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);
		 }
	 }
	 private void sendMTFValues4() throws IOException {
		 final boolean[] inUse = this.data.inUse;
		 final boolean[] inUse16 = this.data.sentMTFValues4_inUse16;
		 for (int i = 16;
		 --i >= 0;
		) {
			 inUse16[i] = false;
			 final int i16 = i * 16;
			 for (int j = 16;
			 --j >= 0;
			) {
				 if (inUse[i16 + j]) {
					 inUse16[i] = true;
				 }
			 }
		 }
		 for (int i = 0;
		 i < 16;
		 i++) {
			 bsW(1, inUse16[i] ? 1 : 0);
		 }
		 final OutputStream outShadow = this.out;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int i = 0;
		 i < 16;
		 i++) {
			 if (inUse16[i]) {
				 final int i16 = i * 16;
				 for (int j = 0;
				 j < 16;
				 j++) {
					 while (bsLiveShadow >= 8) {
						 outShadow.write(bsBuffShadow >> 24);
						 bsBuffShadow <<= 8;
						 bsLiveShadow -= 8;
					 }
					 if (inUse[i16 + j]) {
						 bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
					 }
					 bsLiveShadow++;
				 }
			 }
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void sendMTFValues5(final int nGroups, final int nSelectors) throws IOException {
		 bsW(3, nGroups);
		 bsW(15, nSelectors);
		 final OutputStream outShadow = this.out;
		 final byte[] selectorMtf = this.data.selectorMtf;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int i = 0;
		 i < nSelectors;
		 i++) {
			 for (int j = 0, hj = selectorMtf[i] & 0xff;
			 j < hj;
			 j++) {
				 while (bsLiveShadow >= 8) {
					 outShadow.write(bsBuffShadow >> 24);
					 bsBuffShadow <<= 8;
					 bsLiveShadow -= 8;
				 }
				 bsBuffShadow |= 1 << (32 - bsLiveShadow - 1);
				 bsLiveShadow++;
			 }
			 while (bsLiveShadow >= 8) {
				 outShadow.write(bsBuffShadow >> 24);
				 bsBuffShadow <<= 8;
				 bsLiveShadow -= 8;
			 }
			 bsLiveShadow++;
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void sendMTFValues6(final int nGroups, final int alphaSize) throws IOException {
		 final byte[][] len = this.data.sendMTFValues_len;
		 final OutputStream outShadow = this.out;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int t = 0;
		 t < nGroups;
		 t++) {
			 byte[] len_t = len[t];
			 int curr = len_t[0] & 0xff;
			 while (bsLiveShadow >= 8) {
				 outShadow.write(bsBuffShadow >> 24);
				 bsBuffShadow <<= 8;
				 bsLiveShadow -= 8;
			 }
			 bsBuffShadow |= curr << (32 - bsLiveShadow - 5);
			 bsLiveShadow += 5;
			 for (int i = 0;
			 i < alphaSize;
			 i++) {
				 int lti = len_t[i] & 0xff;
				 while (curr < lti) {
					 while (bsLiveShadow >= 8) {
						 outShadow.write(bsBuffShadow >> 24);
						 bsBuffShadow <<= 8;
						 bsLiveShadow -= 8;
					 }
					 bsBuffShadow |= 2 << (32 - bsLiveShadow - 2);
					 bsLiveShadow += 2;
					 curr++;
				 }
				 while (curr > lti) {
					 while (bsLiveShadow >= 8) {
						 outShadow.write(bsBuffShadow >> 24);
						 bsBuffShadow <<= 8;
						 bsLiveShadow -= 8;
					 }
					 bsBuffShadow |= 3 << (32 - bsLiveShadow - 2);
					 bsLiveShadow += 2;
					 curr--;
				 }
				 while (bsLiveShadow >= 8) {
					 outShadow.write(bsBuffShadow >> 24);
					 bsBuffShadow <<= 8;
					 bsLiveShadow -= 8;
				 }
				 bsLiveShadow++;
			 }
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void sendMTFValues7(final int nSelectors) throws IOException {
		 final Data dataShadow = this.data;
		 final byte[][] len = dataShadow.sendMTFValues_len;
		 final int[][] code = dataShadow.sendMTFValues_code;
		 final OutputStream outShadow = this.out;
		 final byte[] selector = dataShadow.selector;
		 final char[] sfmap = dataShadow.sfmap;
		 final int nMTFShadow = this.nMTF;
		 int selCtr = 0;
		 int bsLiveShadow = this.bsLive;
		 int bsBuffShadow = this.bsBuff;
		 for (int gs = 0;
		 gs < nMTFShadow;
		) {
			 final int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);
			 final int selector_selCtr = selector[selCtr] & 0xff;
			 final int[] code_selCtr = code[selector_selCtr];
			 final byte[] len_selCtr = len[selector_selCtr];
			 while (gs <= ge) {
				 final int sfmap_i = sfmap[gs];
				 while (bsLiveShadow >= 8) {
					 outShadow.write(bsBuffShadow >> 24);
					 bsBuffShadow <<= 8;
					 bsLiveShadow -= 8;
				 }
				 final int n = len_selCtr[sfmap_i] & 0xFF;
				 bsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);
				 bsLiveShadow += n;
				 gs++;
			 }
			 gs = ge + 1;
			 selCtr++;
		 }
		 this.bsBuff = bsBuffShadow;
		 this.bsLive = bsLiveShadow;
	 }
	 private void moveToFrontCodeAndSend() throws IOException {
		 bsW(24, this.origPtr);
		 generateMTFValues();
		 sendMTFValues();
	 }
	 private boolean mainSimpleSort(final Data dataShadow, final int lo, final int hi, final int d) {
		 final int bigN = hi - lo + 1;
		 if (bigN < 2) {
			 return this.firstAttempt && (this.workDone > this.workLimit);
		 }
		 int hp = 0;
		 while (INCS[hp] < bigN) {
			 hp++;
		 }
		 final int[] fmap = dataShadow.fmap;
		 final char[] quadrant = dataShadow.quadrant;
		 final byte[] block = dataShadow.block;
		 final int lastShadow = this.last;
		 final int lastPlus1 = lastShadow + 1;
		 final boolean firstAttemptShadow = this.firstAttempt;
		 final int workLimitShadow = this.workLimit;
		 int workDoneShadow = this.workDone;
		 HP: while (--hp >= 0) {
			 final int h = INCS[hp];
			 final int mj = lo + h - 1;
			 for (int i = lo + h;
			 i <= hi;
			) {
				 for (int k = 3;
				 (i <= hi) && (--k >= 0);
				 i++) {
					 final int v = fmap[i];
					 final int vd = v + d;
					 int j = i;
					 boolean onceRunned = false;
					 int a = 0;
					 HAMMER: while (true) {
						 if (onceRunned) {
							 fmap[j] = a;
							 if ((j -= h) <= mj) {
								 break HAMMER;
							 }
						 }
						 else {
							 onceRunned = true;
						 }
						 a = fmap[j - h];
						 int i1 = a + d;
						 int i2 = vd;
						 if (block[i1 + 1] == block[i2 + 1]) {
							 if (block[i1 + 2] == block[i2 + 2]) {
								 if (block[i1 + 3] == block[i2 + 3]) {
									 if (block[i1 + 4] == block[i2 + 4]) {
										 if (block[i1 + 5] == block[i2 + 5]) {
											 if (block[(i1 += 6)] == block[(i2 += 6)]) {
												 int x = lastShadow;
												 X: while (x > 0) {
													 x -= 4;
													 if (block[i1 + 1] == block[i2 + 1]) {
														 if (quadrant[i1] == quadrant[i2]) {
															 if (block[i1 + 2] == block[i2 + 2]) {
																 if (quadrant[i1 + 1] == quadrant[i2 + 1]) {
																	 if (block[i1 + 3] == block[i2 + 3]) {
																		 if (quadrant[i1 + 2] == quadrant[i2 + 2]) {
																			 if (block[i1 + 4] == block[i2 + 4]) {
																				 if (quadrant[i1 + 3] == quadrant[i2 + 3]) {
																					 if ((i1 += 4) >= lastPlus1) {
																						 i1 -= lastPlus1;
																					 }
																					 if ((i2 += 4) >= lastPlus1) {
																						 i2 -= lastPlus1;
																					 }
																					 workDoneShadow++;
																					 continue X;
																				 }
																				 else if ((quadrant[i1 + 3] > quadrant[i2 + 3])) {
																					 continue HAMMER;
																				 }
																				 else {
																					 break HAMMER;
																				 }
																			 }
																			 else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
																				 continue HAMMER;
																			 }
																			 else {
																				 break HAMMER;
																			 }
																		 }
																		 else if ((quadrant[i1 + 2] > quadrant[i2 + 2])) {
																			 continue HAMMER;
																		 }
																		 else {
																			 break HAMMER;
																		 }
																	 }
																	 else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
																		 continue HAMMER;
																	 }
																	 else {
																		 break HAMMER;
																	 }
																 }
																 else if ((quadrant[i1 + 1] > quadrant[i2 + 1])) {
																	 continue HAMMER;
																 }
																 else {
																	 break HAMMER;
																 }
															 }
															 else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
																 continue HAMMER;
															 }
															 else {
																 break HAMMER;
															 }
														 }
														 else if ((quadrant[i1] > quadrant[i2])) {
															 continue HAMMER;
														 }
														 else {
															 break HAMMER;
														 }
													 }
													 else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
														 continue HAMMER;
													 }
													 else {
														 break HAMMER;
													 }
												 }
												 break HAMMER;
											 }
											 else {
												 if ((block[i1] & 0xff) > (block[i2] & 0xff)) {
													 continue HAMMER;
												 }
												 else {
													 break HAMMER;
												 }
											 }
										 }
										 else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff)) {
											 continue HAMMER;
										 }
										 else {
											 break HAMMER;
										 }
									 }
									 else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff)) {
										 continue HAMMER;
									 }
									 else {
										 break HAMMER;
									 }
								 }
								 else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff)) {
									 continue HAMMER;
								 }
								 else {
									 break HAMMER;
								 }
							 }
							 else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff)) {
								 continue HAMMER;
							 }
							 else {
								 break HAMMER;
							 }
						 }
						 else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff)) {
							 continue HAMMER;
						 }
						 else {
							 break HAMMER;
						 }
					 }
					 fmap[j] = v;
				 }
				 if (firstAttemptShadow && (i <= hi) && (workDoneShadow > workLimitShadow)) {
					 break HP;
				 }
			 }
		 }
		 this.workDone = workDoneShadow;
		 return firstAttemptShadow && (workDoneShadow > workLimitShadow);
	 }
	 private static void vswap(int[] fmap, int p1, int p2, int n) {
		 n += p1;
		 while (p1 < n) {
			 int t = fmap[p1];
			 fmap[p1++] = fmap[p2];
			 fmap[p2++] = t;
		 }
	 }
	 private static byte med3(byte a, byte b, byte c) {
		 return (a < b) ? (b < c ? b : a < c ? c : a) : (b > c ? b : a > c ? c : a);
	 }
	 private void blockSort() {
		 this.workLimit = WORK_FACTOR * this.last;
		 this.workDone = 0;
		 this.blockRandomised = false;
		 this.firstAttempt = true;
		 mainSort();
		 if (this.firstAttempt && (this.workDone > this.workLimit)) {
			 randomiseBlock();
			 this.workLimit = this.workDone = 0;
			 this.firstAttempt = false;
			 mainSort();
		 }
		 int[] fmap = this.data.fmap;
		 this.origPtr = -1;
		 for (int i = 0, lastShadow = this.last;
		 i <= lastShadow;
		 i++) {
			 if (fmap[i] == 0) {
				 this.origPtr = i;
				 break;
			 }
		 }
	 }
	 private void mainQSort3(final Data dataShadow, final int loSt, final int hiSt, final int dSt) {
		 final int[] stack_ll = dataShadow.stack_ll;
		 final int[] stack_hh = dataShadow.stack_hh;
		 final int[] stack_dd = dataShadow.stack_dd;
		 final int[] fmap = dataShadow.fmap;
		 final byte[] block = dataShadow.block;
		 stack_ll[0] = loSt;
		 stack_hh[0] = hiSt;
		 stack_dd[0] = dSt;
		 for (int sp = 1;
		 --sp >= 0;
		) {
			 final int lo = stack_ll[sp];
			 final int hi = stack_hh[sp];
			 final int d = stack_dd[sp];
			 if ((hi - lo < SMALL_THRESH) || (d > DEPTH_THRESH)) {
				 if (mainSimpleSort(dataShadow, lo, hi, d)) {
					 return;
				 }
			 }
			 else {
				 final int d1 = d + 1;
				 final int med = med3(block[fmap[lo] + d1], block[fmap[hi] + d1], block[fmap[(lo + hi) >>> 1] + d1]) & 0xff;
				 int unLo = lo;
				 int unHi = hi;
				 int ltLo = lo;
				 int gtHi = hi;
				 while (true) {
					 while (unLo <= unHi) {
						 final int n = ((int) block[fmap[unLo] + d1] & 0xff) - med;
						 if (n == 0) {
							 final int temp = fmap[unLo];
							 fmap[unLo++] = fmap[ltLo];
							 fmap[ltLo++] = temp;
						 }
						 else if (n < 0) {
							 unLo++;
						 }
						 else {
							 break;
						 }
					 }
					 while (unLo <= unHi) {
						 final int n = ((int) block[fmap[unHi] + d1] & 0xff) - med;
						 if (n == 0) {
							 final int temp = fmap[unHi];
							 fmap[unHi--] = fmap[gtHi];
							 fmap[gtHi--] = temp;
						 }
						 else if (n > 0) {
							 unHi--;
						 }
						 else {
							 break;
						 }
					 }
					 if (unLo <= unHi) {
						 final int temp = fmap[unLo];
						 fmap[unLo++] = fmap[unHi];
						 fmap[unHi--] = temp;
					 }
					 else {
						 break;
					 }
				 }
				 if (gtHi < ltLo) {
					 stack_ll[sp] = lo;
					 stack_hh[sp] = hi;
					 stack_dd[sp] = d1;
					 sp++;
				 }
				 else {
					 int n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
					 vswap(fmap, lo, unLo - n, n);
					 int m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
					 vswap(fmap, unLo, hi - m + 1, m);
					 n = lo + unLo - ltLo - 1;
					 m = hi - (gtHi - unHi) + 1;
					 stack_ll[sp] = lo;
					 stack_hh[sp] = n;
					 stack_dd[sp] = d;
					 sp++;
					 stack_ll[sp] = n + 1;
					 stack_hh[sp] = m - 1;
					 stack_dd[sp] = d1;
					 sp++;
					 stack_ll[sp] = m;
					 stack_hh[sp] = hi;
					 stack_dd[sp] = d;
					 sp++;
				 }
			 }
		 }
	 }
	 private void mainSort() {
		 final Data dataShadow = this.data;
		 final int[] runningOrder = dataShadow.mainSort_runningOrder;
		 final int[] copy = dataShadow.mainSort_copy;
		 final boolean[] bigDone = dataShadow.mainSort_bigDone;
		 final int[] ftab = dataShadow.ftab;
		 final byte[] block = dataShadow.block;
		 final int[] fmap = dataShadow.fmap;
		 final char[] quadrant = dataShadow.quadrant;
		 final int lastShadow = this.last;
		 final int workLimitShadow = this.workLimit;
		 final boolean firstAttemptShadow = this.firstAttempt;
		 for (int i = 65537;
		 --i >= 0;
		) {
			 ftab[i] = 0;
		 }
		 for (int i = 0;
		 i < NUM_OVERSHOOT_BYTES;
		 i++) {
			 block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];
		 }
		 for (int i = lastShadow + NUM_OVERSHOOT_BYTES +1;
		 --i >= 0;
		) {
			 quadrant[i] = 0;
		 }
		 block[0] = block[lastShadow + 1];
		 int c1 = block[0] & 0xff;
		 for (int i = 0;
		 i <= lastShadow;
		 i++) {
			 final int c2 = block[i + 1] & 0xff;
			 ftab[(c1 << 8) + c2]++;
			 c1 = c2;
		 }
		 for (int i = 1;
		 i <= 65536;
		 i++) ftab[i] += ftab[i - 1];
		 c1 = block[1] & 0xff;
		 for (int i = 0;
		 i < lastShadow;
		 i++) {
			 final int c2 = block[i + 2] & 0xff;
			 fmap[--ftab[(c1 << 8) + c2]] = i;
			 c1 = c2;
		 }
		 fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;
		 for (int i = 256;
		 --i >= 0;
		) {
			 bigDone[i] = false;
			 runningOrder[i] = i;
		 }
		 for (int h = 364;
		 h != 1;
		) {
			 h /= 3;
			 for (int i = h;
			 i <= 255;
			 i++) {
				 final int vv = runningOrder[i];
				 final int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
				 final int b = h - 1;
				 int j = i;
				 for (int ro = runningOrder[j - h];
				 (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a;
				 ro = runningOrder[j - h]) {
					 runningOrder[j] = ro;
					 j -= h;
					 if (j <= b) {
						 break;
					 }
				 }
				 runningOrder[j] = vv;
			 }
		 }
		 for (int i = 0;
		 i <= 255;
		 i++) {
			 final int ss = runningOrder[i];
			 for (int j = 0;
			 j <= 255;
			 j++) {
				 final int sb = (ss << 8) + j;
				 final int ftab_sb = ftab[sb];
				 if ((ftab_sb & SETMASK) != SETMASK) {
					 final int lo = ftab_sb & CLEARMASK;
					 final int hi = (ftab[sb + 1] & CLEARMASK) - 1;
					 if (hi > lo) {
						 mainQSort3(dataShadow, lo, hi, 2);
						 if (firstAttemptShadow && (this.workDone > workLimitShadow)) {
							 return;
						 }
					 }
					 ftab[sb] = ftab_sb | SETMASK;
				 }
			 }
			 for (int j = 0;
			 j <= 255;
			 j++) {
				 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
			 }
			 for (int j = ftab[ss << 8] & CLEARMASK, hj = (ftab[(ss + 1) << 8] & CLEARMASK);
			 j < hj;
			 j++) {
				 final int fmap_j = fmap[j];
				 c1 = block[fmap_j] & 0xff;
				 if (!bigDone[c1]) {
					 fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);
					 copy[c1]++;
				 }
			 }
			 for (int j = 256;
			 --j >= 0;
			) ftab[(j << 8) + ss] |= SETMASK;
			 bigDone[ss] = true;
			 if (i < 255) {
				 final int bbStart = ftab[ss << 8] & CLEARMASK;
				 final int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
				 int shifts = 0;
				 while ((bbSize >> shifts) > 65534) {
					 shifts++;
				 }
				 for (int j = 0;
				 j < bbSize;
				 j++) {
					 final int a2update = fmap[bbStart + j];
					 final char qVal = (char) (j >> shifts);
					 quadrant[a2update] = qVal;
					 if (a2update < NUM_OVERSHOOT_BYTES) {
						 quadrant[a2update + lastShadow + 1] = qVal;
					 }
				 }
			 }
		 }
	 }
	 private void randomiseBlock() {
		 final boolean[] inUse = this.data.inUse;
		 final byte[] block = this.data.block;
		 final int lastShadow = this.last;
		 for (int i = 256;
		 --i >= 0;
		) inUse[i] = false;
		 int rNToGo = 0;
		 int rTPos = 0;
		 for (int i = 0, j = 1;
		 i <= lastShadow;
		 i = j, j++) {
			 if (rNToGo == 0) {
				 rNToGo = (char) BZip2Constants.rNums[rTPos];
				 if (++rTPos == 512) {
					 rTPos = 0;
				 }
			 }
			 rNToGo--;
			 block[j] ^= ((rNToGo == 1) ? 1 : 0);
			 inUse[block[j] & 0xff] = true;
		 }
		 this.blockRandomised = true;
	 }
	 private void generateMTFValues() {
		 final int lastShadow = this.last;
		 final Data dataShadow = this.data;
		 final boolean[] inUse = dataShadow.inUse;
		 final byte[] block = dataShadow.block;
		 final int[] fmap = dataShadow.fmap;
		 final char[] sfmap = dataShadow.sfmap;
		 final int[] mtfFreq = dataShadow.mtfFreq;
		 final byte[] unseqToSeq = dataShadow.unseqToSeq;
		 final byte[] yy = dataShadow.generateMTFValues_yy;
		 int nInUseShadow = 0;
		 for (int i = 0;
		 i < 256;
		 i++) {
			 if (inUse[i]) {
				 unseqToSeq[i] = (byte) nInUseShadow;
				 nInUseShadow++;
			 }
		 }
		 this.nInUse = nInUseShadow;
		 final int eob = nInUseShadow + 1;
		 for (int i = eob;
		 i >= 0;
		 i--) {
			 mtfFreq[i] = 0;
		 }
		 for (int i = nInUseShadow;
		 --i >= 0;
		) {
			 yy[i] = (byte) i;
		 }
		 int wr = 0;
		 int zPend = 0;
		 for (int i = 0;
		 i <= lastShadow;
		 i++) {
			 final byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];
			 byte tmp = yy[0];
			 int j = 0;
			 while (ll_i != tmp) {
				 j++;
				 byte tmp2 = tmp;
				 tmp = yy[j];
				 yy[j] = tmp2;
			 }
			 yy[0] = tmp;
			 if (j == 0) {
				 zPend++;
			 }
			 else {
				 if (zPend > 0) {
					 zPend--;
					 while (true) {
						 if ((zPend & 1) == 0) {
							 sfmap[wr] = RUNA;
							 wr++;
							 mtfFreq[RUNA]++;
						 }
						 else {
							 sfmap[wr] = RUNB;
							 wr++;
							 mtfFreq[RUNB]++;
						 }
						 if (zPend >= 2) {
							 zPend = (zPend - 2) >> 1;
						 }
						 else {
							 break;
						 }
					 }
					 zPend = 0;
				 }
				 sfmap[wr] = (char) (j + 1);
				 wr++;
				 mtfFreq[j + 1]++;
			 }
		 }
		 if (zPend > 0) {
			 zPend--;
			 while (true) {
				 if ((zPend & 1) == 0) {
					 sfmap[wr] = RUNA;
					 wr++;
					 mtfFreq[RUNA]++;
				 }
				 else {
					 sfmap[wr] = RUNB;
					 wr++;
					 mtfFreq[RUNB]++;
				 }
				 if (zPend >= 2) {
					 zPend = (zPend - 2) >> 1;
				 }
				 else {
					 break;
				 }
			 }
		 }
		 sfmap[wr] = (char) eob;
		 mtfFreq[eob]++;
		 this.nMTF = wr + 1;
	 }
	 private static final class Data extends Object {
		 final boolean[] inUse = new boolean[256];
		 final byte[] unseqToSeq = new byte[256];
		 final int[] mtfFreq = new int[MAX_ALPHA_SIZE];
		 final byte[] selector = new byte[MAX_SELECTORS];
		 final byte[] selectorMtf = new byte[MAX_SELECTORS];
		 final byte[] generateMTFValues_yy = new byte[256];
		 final byte[][] sendMTFValues_len = new byte[N_GROUPS][MAX_ALPHA_SIZE];
		 final int[][] sendMTFValues_rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 final int[] sendMTFValues_fave = new int[N_GROUPS];
		 final short[] sendMTFValues_cost = new short[N_GROUPS];
		 final int[][] sendMTFValues_code = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 final byte[] sendMTFValues2_pos = new byte[N_GROUPS];
		 final boolean[] sentMTFValues4_inUse16 = new boolean[16];
		 final int[] stack_ll = new int[QSORT_STACK_SIZE];
		 final int[] stack_hh = new int[QSORT_STACK_SIZE];
		 final int[] stack_dd = new int[QSORT_STACK_SIZE];
		 final int[] mainSort_runningOrder = new int[256];
		 final int[] mainSort_copy = new int[256];
		 final boolean[] mainSort_bigDone = new boolean[256];
		 final int[] heap = new int[MAX_ALPHA_SIZE + 2];
		 final int[] weight = new int[MAX_ALPHA_SIZE * 2];
		 final int[] parent = new int[MAX_ALPHA_SIZE * 2];
		 final int[] ftab = new int[65537];
		 final byte[] block;
		 final int[] fmap;
		 final char[] sfmap;
		 final char[] quadrant;
		 Data(int blockSize100k) {
			 super();
			 final int n = blockSize100k * BZip2Constants.baseBlockSize;
			 this.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];
			 this.fmap = new int[n];
			 this.sfmap = new char[2 * n];
			 this.quadrant = this.sfmap;
		 }
	 }
}",1,0,0,0
"private static class create_type_argsStandardSchemeFactory implements SchemeFactory {
	 public create_type_argsStandardScheme getScheme() {
		 return new create_type_argsStandardScheme();
	 }
 }",0,0,0,0
"public class SimpleVersion implements Comparable<SimpleVersion> {
	 private static final Pattern VERSION_PATTERN = Pattern.compile(""^(\\d+)[\\.\\-\\_]+(\\d+).*$"");
	 private final int _major;
	 private final int _minor;
	 public SimpleVersion(String version) {
		 Matcher m = VERSION_PATTERN.matcher(version);
		 int maj = -1;
		 int min = -1;
		 if (!m.matches()) {
			 if (!""Unknown"".equals(version)) {
				 throw new IllegalArgumentException(""Cannot parse '"" + version + ""'"");
			 }
		 }
		 else {
			 maj = Integer.valueOf(m.group(1));
			 min = Integer.valueOf(m.group(2));
		 }
		 _major = maj;
		 _minor = min;
	 }
	 public int getMajor() {
		 return _major;
	 }
	 public int getMinor() {
		 return _minor;
	 }
	 public int hashCode() {
		 return (Integer.hashCode(_major) * 17) & Integer.hashCode(_minor);
	 }
	 public boolean equals(Object o) {
		 if (o == this) {
			 return true;
		 }
		 if (!(o instanceof SimpleVersion)) {
			 return false;
		 }
		 return compareTo((SimpleVersion) o) == 0;
	 }
	 public int compareTo(SimpleVersion o) {
		 int ret = Integer.compare(_major, o._major);
		 if (ret == 0) {
			 ret = Integer.compare(_minor, o._minor);
		 }
		 return ret;
	 }
	 public String toString() {
		 return _major + ""."" + _minor;
	 }
}",0,0,0,0
"public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {
	 Map<String, String> dm = new HashMap();
	 dm.put(ApiConstants.S3_ACCESS_KEY, getAccessKey());
	 dm.put(ApiConstants.S3_SECRET_KEY, getSecretKey());
	 dm.put(ApiConstants.S3_END_POINT, getEndPoint());
	 dm.put(ApiConstants.S3_BUCKET_NAME, getBucketName());
	 if (getSigner() != null && (getSigner().equals(ApiConstants.S3_V3_SIGNER) || getSigner().equals(ApiConstants.S3_V4_SIGNER))) {
		 dm.put(ApiConstants.S3_SIGNER, getSigner());
	 }
	 if (isHttps() != null) {
		 dm.put(ApiConstants.S3_HTTPS_FLAG, isHttps().toString());
	 }
	 if (getConnectionTimeout() != null) {
		 dm.put(ApiConstants.S3_CONNECTION_TIMEOUT, getConnectionTimeout().toString());
	 }
	 if (getMaxErrorRetry() != null) {
		 dm.put(ApiConstants.S3_MAX_ERROR_RETRY, getMaxErrorRetry().toString());
	 }
	 if (getSocketTimeout() != null) {
		 dm.put(ApiConstants.S3_SOCKET_TIMEOUT, getSocketTimeout().toString());
	 }
	 if (getConnectionTtl() != null) {
		 dm.put(ApiConstants.S3_CONNECTION_TTL, getConnectionTtl().toString());
	 }
	 if (getUseTCPKeepAlive() != null) {
		 dm.put(ApiConstants.S3_USE_TCP_KEEPALIVE, getUseTCPKeepAlive().toString());
	 }
	 try{
		 ImageStore result = _storageService.discoverImageStore(null, null, ""S3"", null, dm);
		 ImageStoreResponse storeResponse;
		 if (result != null) {
			 storeResponse = _responseGenerator.createImageStoreResponse(result);
			 storeResponse.setResponseName(getCommandName());
			 storeResponse.setObjectName(""imagestore"");
			 setResponseObject(storeResponse);
		 }
		 else {
			 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to add S3 Image Store."");
		 }
	 }
	 catch (DiscoveryException ex) {
		 s_logger.warn(""Exception: "", ex);
		 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());
	 }
 }",0,0,1,0
"public static PrintStream getWarnStream(final Log logger) {
	 return getLogStream(logger, WARN);
 }",0,0,0,0
"private void notifyConflict() {
	 final Shell parentShell = ShellUtils.getWorkbenchShell();
	 UIHelpers.runOnUIThread(true, new Runnable() {
		 public void run() {
			 MessageDialog.openWarning( parentShell, Messages.getString(""EclipseConnectionConflictHandler.ConnectionExistsDialogTitle""), Messages.getString(""EclipseConnectionConflictHandler.ConnectionExistsDialogText""));
		 }
	 }
	);
 }",0,0,0,0
"class UMLStereotypeTagDefinitionListModel extends UMLModelElementListModel2 {
	 public UMLStereotypeTagDefinitionListModel() {
		 super(""definedTag"");
	 }
	 protected void buildModelList() {
		 if (getTarget() != null) {
			 setAllElements(Model.getFacade().getTagDefinitions(getTarget()));
		 }
	 }
	 protected boolean isValidElement(Object element) {
		 return Model.getFacade().isATagDefinition(element) && Model.getFacade().getTagDefinitions(getTarget()) .contains(element);
	 }
}",0,0,0,0
"public class PlusExpression implements MemoryExpressionElement {
	 private final List<MemoryExpressionElement> children;
	 public PlusExpression(final List<MemoryExpressionElement> children) {
		 this.children = children;
	 }
	 public List<MemoryExpressionElement> getChildren() {
		 return new ArrayList<>(children);
	 }
	 public String toString() {
		 final StringBuilder ret = new StringBuilder();
		 for (final MemoryExpressionElement child : children) {
			 ret.append(child.toString());
			 if (child != Iterables.getLast(children)) {
				 ret.append('+');
			 }
		 }
		 return ret.toString();
	 }
	 public void visit(final MemoryExpressionVisitor visitor) {
		 visitor.visit(this);
	 }
}",0,0,0,0
"public class KuraUnmatchedMessage extends KuraMessage<KuraUnmatchedChannel, KuraUnmatchedPayload> implements DeviceMessage<KuraUnmatchedChannel, KuraUnmatchedPayload> {
	 public KuraUnmatchedMessage() {
		 super();
	 }
	 public KuraUnmatchedMessage(KuraUnmatchedChannel channel, Date timestamp, KuraUnmatchedPayload payload) {
		 super(channel, timestamp, payload);
	 }
}",0,0,0,0
"public class LocalSeekableInputStream extends SeekableInputStream {
	 protected RandomAccessFile file;
	 protected long curMark;
	 public LocalSeekableInputStream(File file) throws FileNotFoundException {
		 this.file = new RandomAccessFile(file, ""r"");
		 this.curMark = 0;
	 }
	 public void seek(long offset, FLAGS whence) throws IOException {
		 long targetPos;
		 switch (whence) {
			 case SEEK_SET: {
				 targetPos = offset;
				 break;
			 }
			 case SEEK_CUR: {
				 targetPos = this.file.getFilePointer() + offset;
				 break;
			 }
			 case SEEK_END: {
				 targetPos = this.file.length() + offset;
				 break;
			 }
			 default: {
				 throw new IOException(""Invalid seek option: "" + whence);
			 }
		 }
		 this.file.seek(targetPos);
	 }
	 public long tell() throws IOException {
		 return this.file.getFilePointer();
	 }
	 public int read() throws IOException {
		 return this.file.read();
	 }
	 public int read(byte[] b) throws IOException {
		 return this.file.read(b);
	 }
	 public int read(byte[] b, int off, int len ) throws IOException {
		 return this.file.read(b, off, len);
	 }
	 public int available() throws IOException {
		 return (int)( this.file.length() - this.file.getFilePointer() );
	 }
	 public long skip(long n) throws IOException {
		 long skipped = 0;
		 if (n > 0) {
			 skipped = this.file.length() - tell();
			 seek(n, FLAGS.SEEK_CUR);
		 }
		 return skipped;
	 }
	 public void close() throws IOException {
		 this.file.close();
	 }
	 public void mark(int readlimit) {
		 try {
			 this.curMark = tell();
		 }
		 catch (IOException e) {
			 ;
		 }
	 }
	 public void reset() throws IOException {
		 seek(this.curMark, FLAGS.SEEK_SET);
	 }
	 public boolean markSupported() {
		 return true;
	 }
}",1,0,0,0
"public class ProcessorUtils{
	 public static final String AVAILABLE_PROCESSORS = ""JETTY_AVAILABLE_PROCESSORS"";
	 private static int __availableProcessors = init();
	 static int init() {
		 String processors = System.getProperty(AVAILABLE_PROCESSORS, System.getenv(AVAILABLE_PROCESSORS));
		 if (processors != null) {
			 try {
				 return Integer.parseInt( processors );
			 }
			 catch (NumberFormatException ignored) {
			 }
		 }
		 return Runtime.getRuntime().availableProcessors();
	 }
	 public static int availableProcessors() {
		 return __availableProcessors;
	 }
	 public static void setAvailableProcessors(int processors) {
		 if (processors < 1) throw new IllegalArgumentException(""Invalid number of processors: "" + processors);
		 __availableProcessors = processors;
	 }
}",0,1,0,0
"protected File getFile () {
	 FileProvider fp = (FileProvider) src.as(FileProvider.class);
	 return fp != null ? fp.getFile() : null;
 }",0,0,0,0
"public final class TestEscherSplitMenuColorsRecord {
	 public void testSerialize() {
		 EscherSplitMenuColorsRecord r = createRecord();
		 byte[] data = new byte[24];
		 int bytesWritten = r.serialize( 0, data, new NullEscherSerializationListener() );
		 assertEquals( 24, bytesWritten );
		 assertEquals( ""[40, 00, "" + ""1E, F1, "" + ""10, 00, 00, 00, "" + ""02, 04, 00, 00, "" + ""02, 00, 00, 00, "" + ""02, 00, 00, 00, "" + ""01, 00, 00, 00]"", HexDump.toHex( data ) );
	 }
	 public void testFillFields() {
		 String hexData = ""40 00 "" + ""1E F1 "" + ""10 00 00 00 "" + ""02 04 00 00 "" + ""02 00 00 00 "" + ""02 00 00 00 "" + ""01 00 00 00 "";
		 byte[] data = HexRead.readFromString( hexData );
		 EscherSplitMenuColorsRecord r = new EscherSplitMenuColorsRecord();
		 int bytesWritten = r.fillFields( data, new DefaultEscherRecordFactory() );
		 assertEquals( 24, bytesWritten );
		 assertEquals( 0x0402, r.getColor1() );
		 assertEquals( 0x02, r.getColor2() );
		 assertEquals( 0x02, r.getColor3() );
		 assertEquals( 0x01, r.getColor4() );
	 }
	 public void testToString() {
		 String nl = System.getProperty(""line.separator"");
		 String expected = ""org.apache.poi.ddf.EscherSplitMenuColorsRecord (SplitMenuColors):"" + nl + "" RecordId: 0xF11E"" + nl + "" Version: 0x0000"" + nl + "" Instance: 0x0004"" + nl + "" Options: 0x0040"" + nl + "" Record Size: 24"" + nl + "" Color1: 0x00000402"" + nl + "" Color2: 0x00000002"" + nl + "" Color3: 0x00000002"" + nl + "" Color4: 0x00000001"";
		 assertEquals( expected, createRecord().toString() );
	 }
	 private static EscherSplitMenuColorsRecord createRecord() {
		 EscherSplitMenuColorsRecord r = new EscherSplitMenuColorsRecord();
		 r.setOptions( (short) 0x0040 );
		 r.setRecordId( EscherSplitMenuColorsRecord.RECORD_ID );
		 r.setColor1( 0x402 );
		 r.setColor2( 0x2 );
		 r.setColor3( 0x2 );
		 r.setColor4( 0x1 );
		 return r;
	 }
}",0,0,0,0
"private static void setProjectHelperProps(String prefix, String prefixSep, boolean inIncludeMode) {
	 ProjectHelper.setCurrentTargetPrefix(prefix);
	 ProjectHelper.setCurrentPrefixSeparator(prefixSep);
	 ProjectHelper.setInIncludeMode(inIncludeMode);
 }",0,0,0,0
"public class NativeArray extends IdScriptableObject{
	 static final long serialVersionUID = 7331366857676127338L;
	 private static final Object ARRAY_TAG = new Object();
	 private static final Integer NEGATIVE_ONE = new Integer(-1);
	 static void init(Scriptable scope, boolean sealed) {
		 NativeArray obj = new NativeArray();
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeArray() {
		 dense = null;
		 this.length = 0;
	 }
	 public NativeArray(long length) {
		 int intLength = (int) length;
		 if (intLength == length && intLength > 0) {
			 if (intLength > maximumDenseLength) intLength = maximumDenseLength;
			 dense = new Object[intLength];
			 for (int i=0;
			 i < intLength;
			 i++) dense[i] = NOT_FOUND;
		 }
		 this.length = length;
	 }
	 public NativeArray(Object[] array) {
		 dense = array;
		 this.length = array.length;
	 }
	 public String getClassName() {
		 return ""Array"";
	 }
	 private static final int Id_length = 1, MAX_INSTANCE_ID = 1;
	 protected int getMaxInstanceId() {
		 return MAX_INSTANCE_ID;
	 }
	 protected int findInstanceIdInfo(String s) {
		 if (s.equals(""length"")) {
			 return instanceIdInfo(DONTENUM | PERMANENT, Id_length);
		 }
		 return super.findInstanceIdInfo(s);
	 }
	 protected String getInstanceIdName(int id) {
		 if (id == Id_length) {
			 return ""length"";
		 }
		 return super.getInstanceIdName(id);
	 }
	 protected Object getInstanceIdValue(int id) {
		 if (id == Id_length) {
			 return ScriptRuntime.wrapNumber(length);
		 }
		 return super.getInstanceIdValue(id);
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 if (id == Id_length) {
			 setLength(value);
			 return;
		 }
		 super.setInstanceIdValue(id, value);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toLocaleString: arity=1;
			 s=""toLocaleString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_join: arity=1;
			 s=""join"";
			 break;
			 case Id_reverse: arity=0;
			 s=""reverse"";
			 break;
			 case Id_sort: arity=1;
			 s=""sort"";
			 break;
			 case Id_push: arity=1;
			 s=""push"";
			 break;
			 case Id_pop: arity=1;
			 s=""pop"";
			 break;
			 case Id_shift: arity=1;
			 s=""shift"";
			 break;
			 case Id_unshift: arity=1;
			 s=""unshift"";
			 break;
			 case Id_splice: arity=1;
			 s=""splice"";
			 break;
			 case Id_concat: arity=1;
			 s=""concat"";
			 break;
			 case Id_slice: arity=1;
			 s=""slice"";
			 break;
			 case Id_indexOf: arity=1;
			 s=""indexOf"";
			 break;
			 case Id_lastIndexOf: arity=1;
			 s=""lastIndexOf"";
			 break;
			 case Id_every: arity=1;
			 s=""every"";
			 break;
			 case Id_filter: arity=1;
			 s=""filter"";
			 break;
			 case Id_forEach: arity=1;
			 s=""forEach"";
			 break;
			 case Id_map: arity=1;
			 s=""map"";
			 break;
			 case Id_some: arity=1;
			 s=""some"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(ARRAY_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(ARRAY_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case Id_constructor: {
				 boolean inNewExpr = (thisObj == null);
				 if (!inNewExpr) {
					 return f.construct(cx, scope, args);
				 }
				 return jsConstructor(cx, scope, args);
			 }
			 case Id_toString: return toStringHelper(cx, scope, thisObj, cx.hasFeature(Context.FEATURE_TO_STRING_AS_SOURCE), false);
			 case Id_toLocaleString: return toStringHelper(cx, scope, thisObj, false, true);
			 case Id_toSource: return toStringHelper(cx, scope, thisObj, true, false);
			 case Id_join: return js_join(cx, thisObj, args);
			 case Id_reverse: return js_reverse(cx, thisObj, args);
			 case Id_sort: return js_sort(cx, scope, thisObj, args);
			 case Id_push: return js_push(cx, thisObj, args);
			 case Id_pop: return js_pop(cx, thisObj, args);
			 case Id_shift: return js_shift(cx, thisObj, args);
			 case Id_unshift: return js_unshift(cx, thisObj, args);
			 case Id_splice: return js_splice(cx, scope, thisObj, args);
			 case Id_concat: return js_concat(cx, scope, thisObj, args);
			 case Id_slice: return js_slice(cx, thisObj, args);
			 case Id_indexOf: return indexOfHelper(cx, thisObj, args, false);
			 case Id_lastIndexOf: return indexOfHelper(cx, thisObj, args, true);
			 case Id_every: case Id_filter: case Id_forEach: case Id_map: case Id_some: return iterativeMethod(cx, id, scope, thisObj, args);
		 }
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 public Object get(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index];
		 return super.get(index, start);
	 }
	 public boolean has(int index, Scriptable start) {
		 if (dense != null && 0 <= index && index < dense.length) return dense[index] != NOT_FOUND;
		 return super.has(index, start);
	 }
	 private static long toArrayIndex(String id) {
		 double d = ScriptRuntime.toNumber(id);
		 if (d == d) {
			 long index = ScriptRuntime.toUint32(d);
			 if (index == d && index != 4294967295L) {
				 if (Long.toString(index).equals(id)) {
					 return index;
				 }
			 }
		 }
		 return -1;
	 }
	 public void put(String id, Scriptable start, Object value) {
		 super.put(id, start, value);
		 if (start == this) {
			 long index = toArrayIndex(id);
			 if (index >= length) {
				 length = index + 1;
			 }
		 }
	 }
	 public void put(int index, Scriptable start, Object value) {
		 if (start == this && !isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = value;
		 }
		 else {
			 super.put(index, start, value);
		 }
		 if (start == this) {
			 if (this.length <= index) {
				 this.length = (long)index + 1;
			 }
		 }
	 }
	 public void delete(int index) {
		 if (!isSealed() && dense != null && 0 <= index && index < dense.length) {
			 dense[index] = NOT_FOUND;
		 }
		 else {
			 super.delete(index);
		 }
	 }
	 public Object[] getIds() {
		 Object[] superIds = super.getIds();
		 if (dense == null) {
			 return superIds;
		 }
		 int N = dense.length;
		 long currentLength = length;
		 if (N > currentLength) {
			 N = (int)currentLength;
		 }
		 if (N == 0) {
			 return superIds;
		 }
		 int superLength = superIds.length;
		 Object[] ids = new Object[N + superLength];
		 System.arraycopy(dense, 0, ids, 0, N);
		 int presentCount = 0;
		 for (int i = 0;
		 i != N;
		 ++i) {
			 if (ids[i] != NOT_FOUND) {
				 ids[presentCount] = new Integer(i);
				 ++presentCount;
			 }
		 }
		 if (presentCount != N) {
			 Object[] tmp = new Object[presentCount + superLength];
			 System.arraycopy(ids, 0, tmp, 0, presentCount);
			 ids = tmp;
		 }
		 System.arraycopy(superIds, 0, ids, presentCount, superLength);
		 return ids;
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == ScriptRuntime.NumberClass) {
			 Context cx = Context.getContext();
			 if (cx.getLanguageVersion() == Context.VERSION_1_2) return new Long(length);
		 }
		 return super.getDefaultValue(hint);
	 }
	 private static Object jsConstructor(Context cx, Scriptable scope, Object[] args) {
		 if (args.length == 0) return new NativeArray();
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) {
			 return new NativeArray(args);
		 }
		 else {
			 Object arg0 = args[0];
			 if (args.length > 1 || !(arg0 instanceof Number)) {
				 return new NativeArray(args);
			 }
			 else {
				 long len = ScriptRuntime.toUint32(arg0);
				 if (len != ((Number)arg0).doubleValue()) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
				 return new NativeArray(len);
			 }
		 }
	 }
	 public long getLength() {
		 return length;
	 }
	 public long jsGet_length() {
		 return getLength();
	 }
	 private void setLength(Object val) {
		 double d = ScriptRuntime.toNumber(val);
		 long longVal = ScriptRuntime.toUint32(d);
		 if (longVal != d) throw Context.reportRuntimeError0(""msg.arraylength.bad"");
		 if (longVal < length) {
			 if (length - longVal > 0x1000) {
				 Object[] e = getIds();
				 for (int i=0;
				 i < e.length;
				 i++) {
					 Object id = e[i];
					 if (id instanceof String) {
						 String strId = (String)id;
						 long index = toArrayIndex(strId);
						 if (index >= longVal) delete(strId);
					 }
					 else {
						 int index = ((Integer)id).intValue();
						 if (index >= longVal) delete(index);
					 }
				 }
			 }
			 else {
				 for (long i = longVal;
				 i < length;
				 i++) {
					 deleteElem(this, i);
				 }
			 }
		 }
		 length = longVal;
	 }
	 static long getLengthProperty(Context cx, Scriptable obj) {
		 if (obj instanceof NativeString) {
			 return ((NativeString)obj).getLength();
		 }
		 else if (obj instanceof NativeArray) {
			 return ((NativeArray)obj).getLength();
		 }
		 else if (!(obj instanceof Scriptable)) {
			 return 0;
		 }
		 return ScriptRuntime.toUint32( ScriptRuntime.getObjectProp(obj, ""length"", cx));
	 }
	 private static Object setLengthProperty(Context cx, Scriptable target, long length) {
		 return ScriptRuntime.setObjectProp( target, ""length"", ScriptRuntime.wrapNumber(length), cx);
	 }
	 private static void deleteElem(Scriptable target, long index) {
		 int i = (int)index;
		 if (i == index) {
			 target.delete(i);
		 }
		 else {
			 target.delete(Long.toString(index));
		 }
	 }
	 private static Object getElem(Context cx, Scriptable target, long index) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 return ScriptRuntime.getObjectProp(target, id, cx);
		 }
		 else {
			 return ScriptRuntime.getObjectIndex(target, (int)index, cx);
		 }
	 }
	 private static void setElem(Context cx, Scriptable target, long index, Object value) {
		 if (index > Integer.MAX_VALUE) {
			 String id = Long.toString(index);
			 ScriptRuntime.setObjectProp(target, id, value, cx);
		 }
		 else {
			 ScriptRuntime.setObjectIndex(target, (int)index, value, cx);
		 }
	 }
	 private static String toStringHelper(Context cx, Scriptable scope, Scriptable thisObj, boolean toSource, boolean toLocale) {
		 long length = getLengthProperty(cx, thisObj);
		 StringBuffer result = new StringBuffer(256);
		 String separator;
		 if (toSource) {
			 result.append('[');
			 separator = "", "";
		 }
		 else {
			 separator = "","";
		 }
		 boolean haslast = false;
		 long i = 0;
		 boolean toplevel, iterating;
		 if (cx.iterating == null) {
			 toplevel = true;
			 iterating = false;
			 cx.iterating = new ObjToIntMap(31);
		 }
		 else {
			 toplevel = false;
			 iterating = cx.iterating.has(thisObj);
		 }
		 try {
			 if (!iterating) {
				 cx.iterating.put(thisObj, 0);
				 for (i = 0;
				 i < length;
				 i++) {
					 if (i > 0) result.append(separator);
					 Object elem = getElem(cx, thisObj, i);
					 if (elem == null || elem == Undefined.instance) {
						 haslast = false;
						 continue;
					 }
					 haslast = true;
					 if (toSource) {
						 result.append(ScriptRuntime.uneval(cx, scope, elem));
					 }
					 else if (elem instanceof String) {
						 String s = (String)elem;
						 if (toSource) {
							 result.append('\""');
							 result.append(ScriptRuntime.escapeString(s));
							 result.append('\""');
						 }
						 else {
							 result.append(s);
						 }
					 }
					 else {
						 if (toLocale && elem != Undefined.instance && elem != null) {
							 Callable fun;
							 Scriptable funThis;
							 fun = ScriptRuntime.getPropFunctionAndThis( elem, ""toLocaleString"", cx);
							 funThis = ScriptRuntime.lastStoredScriptable(cx);
							 elem = fun.call(cx, scope, funThis, ScriptRuntime.emptyArgs);
						 }
						 result.append(ScriptRuntime.toString(elem));
					 }
				 }
			 }
		 }
		 finally {
			 if (toplevel) {
				 cx.iterating = null;
			 }
		 }
		 if (toSource) {
			 if (!haslast && i > 0) result.append("", ]"");
			 else result.append(']');
		 }
		 return result.toString();
	 }
	 private static String js_join(Context cx, Scriptable thisObj, Object[] args) {
		 String separator;
		 long llength = getLengthProperty(cx, thisObj);
		 int length = (int)llength;
		 if (llength != length) {
			 throw Context.reportRuntimeError1( ""msg.arraylength.too.big"", String.valueOf(llength));
		 }
		 if (args.length < 1 || args[0] == Undefined.instance) {
			 separator = "","";
		 }
		 else {
			 separator = ScriptRuntime.toString(args[0]);
		 }
		 if (length == 0) {
			 return """";
		 }
		 String[] buf = new String[length];
		 int total_size = 0;
		 for (int i = 0;
		 i != length;
		 i++) {
			 Object temp = getElem(cx, thisObj, i);
			 if (temp != null && temp != Undefined.instance) {
				 String str = ScriptRuntime.toString(temp);
				 total_size += str.length();
				 buf[i] = str;
			 }
		 }
		 total_size += (length - 1) * separator.length();
		 StringBuffer sb = new StringBuffer(total_size);
		 for (int i = 0;
		 i != length;
		 i++) {
			 if (i != 0) {
				 sb.append(separator);
			 }
			 String str = buf[i];
			 if (str != null) {
				 sb.append(str);
			 }
		 }
		 return sb.toString();
	 }
	 private static Scriptable js_reverse(Context cx, Scriptable thisObj, Object[] args) {
		 long len = getLengthProperty(cx, thisObj);
		 long half = len / 2;
		 for(long i=0;
		 i < half;
		 i++) {
			 long j = len - i - 1;
			 Object temp1 = getElem(cx, thisObj, i);
			 Object temp2 = getElem(cx, thisObj, j);
			 setElem(cx, thisObj, i, temp2);
			 setElem(cx, thisObj, j, temp1);
		 }
		 return thisObj;
	 }
	 private static Scriptable js_sort(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 if (length <= 1) {
			 return thisObj;
		 }
		 Object compare;
		 Object[] cmpBuf;
		 if (args.length > 0 && Undefined.instance != args[0]) {
			 compare = args[0];
			 cmpBuf = new Object[2];
		 }
		 else {
			 compare = null;
			 cmpBuf = null;
		 }
		 if (length >= Integer.MAX_VALUE) {
			 heapsort_extended(cx, scope, thisObj, length, compare, cmpBuf);
		 }
		 else {
			 int ilength = (int)length;
			 Object[] working = new Object[ilength];
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 working[i] = getElem(cx, thisObj, i);
			 }
			 heapsort(cx, scope, working, ilength, compare, cmpBuf);
			 for (int i = 0;
			 i != ilength;
			 ++i) {
				 setElem(cx, thisObj, i, working[i]);
			 }
		 }
		 return thisObj;
	 }
	 private static boolean isBigger(Context cx, Scriptable scope, Object x, Object y, Object cmp, Object[] cmpBuf) {
		 if (cmp == null) {
			 if (cmpBuf != null) Kit.codeBug();
		 }
		 else {
			 if (cmpBuf == null || cmpBuf.length != 2) Kit.codeBug();
		 }
		 Object undef = Undefined.instance;
		 if (undef == y) {
			 return false;
		 }
		 else if (undef == x) {
			 return true;
		 }
		 if (cmp == null) {
			 String a = ScriptRuntime.toString(x);
			 String b = ScriptRuntime.toString(y);
			 return a.compareTo(b) > 0;
		 }
		 else {
			 cmpBuf[0] = x;
			 cmpBuf[1] = y;
			 Callable fun = ScriptRuntime.getValueFunctionAndThis(cmp, cx);
			 Scriptable funThis = ScriptRuntime.lastStoredScriptable(cx);
			 Object ret = fun.call(cx, scope, funThis, cmpBuf);
			 double d = ScriptRuntime.toNumber(ret);
			 return d > 0;
		 }
	 }
	 private static void heapsort(Context cx, Scriptable scope, Object[] array, int length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (int i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = array[i];
			 heapify(cx, scope, pivot, array, i, length, cmp, cmpBuf);
		 }
		 for (int i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = array[i];
			 array[i] = array[0];
			 heapify(cx, scope, pivot, array, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify(Context cx, Scriptable scope, Object pivot, Object[] array, int i, int end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 int child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = array[child];
			 if (child + 1 < end) {
				 Object nextVal = array[child + 1];
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 array[i] = childVal;
			 i = child;
		 }
		 array[i] = pivot;
	 }
	 private static void heapsort_extended(Context cx, Scriptable scope, Scriptable target, long length, Object cmp, Object[] cmpBuf) {
		 if (length <= 1) Kit.codeBug();
		 for (long i = length / 2;
		 i != 0;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 heapify_extended(cx, scope, pivot, target, i, length, cmp, cmpBuf);
		 }
		 for (long i = length;
		 i != 1;
		) {
			 --i;
			 Object pivot = getElem(cx, target, i);
			 setElem(cx, target, i, getElem(cx, target, 0));
			 heapify_extended(cx, scope, pivot, target, 0, i, cmp, cmpBuf);
		 }
	 }
	 private static void heapify_extended(Context cx, Scriptable scope, Object pivot, Scriptable target, long i, long end, Object cmp, Object[] cmpBuf) {
		 for (;
		;
		) {
			 long child = i * 2 + 1;
			 if (child >= end) {
				 break;
			 }
			 Object childVal = getElem(cx, target, child);
			 if (child + 1 < end) {
				 Object nextVal = getElem(cx, target, child + 1);
				 if (isBigger(cx, scope, nextVal, childVal, cmp, cmpBuf)) {
					 ++child;
					 childVal = nextVal;
				 }
			 }
			 if (!isBigger(cx, scope, childVal, pivot, cmp, cmpBuf)) {
				 break;
			 }
			 setElem(cx, target, i, childVal);
			 i = child;
		 }
		 setElem(cx, target, i, pivot);
	 }
	 private static Object js_push(Context cx, Scriptable thisObj, Object[] args) {
		 long length = getLengthProperty(cx, thisObj);
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 setElem(cx, thisObj, length + i, args[i]);
		 }
		 length += args.length;
		 Object lengthObj = setLengthProperty(cx, thisObj, length);
		 if (cx.getLanguageVersion() == Context.VERSION_1_2) return args.length == 0 ? Undefined.instance : args[args.length - 1];
		 else return lengthObj;
	 }
	 private static Object js_pop(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 length--;
			 result = getElem(cx, thisObj, length);
		 }
		 else {
			 result = Undefined.instance;
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_shift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 if (length > 0) {
			 long i = 0;
			 length--;
			 result = getElem(cx, thisObj, i);
			 if (length > 0) {
				 for (i = 1;
				 i <= length;
				 i++) {
					 Object temp = getElem(cx, thisObj, i);
					 setElem(cx, thisObj, i - 1, temp);
				 }
			 }
		 }
		 else {
			 result = Undefined.instance;
		 }
		 setLengthProperty(cx, thisObj, length);
		 return result;
	 }
	 private static Object js_unshift(Context cx, Scriptable thisObj, Object[] args) {
		 Object result;
		 long length = getLengthProperty(cx, thisObj);
		 int argc = args.length;
		 if (args.length > 0) {
			 if (length > 0) {
				 for (long last = length - 1;
				 last >= 0;
				 last--) {
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, thisObj, last + argc, temp);
				 }
			 }
			 for (int i = 0;
			 i < args.length;
			 i++) {
				 setElem(cx, thisObj, i, args[i]);
			 }
			 length += args.length;
			 return setLengthProperty(cx, thisObj, length);
		 }
		 return ScriptRuntime.wrapNumber(length);
	 }
	 private static Object js_splice(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Object result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 int argc = args.length;
		 if (argc == 0) return result;
		 long length = getLengthProperty(cx, thisObj);
		 long begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
		 argc--;
		 long count;
		 if (args.length == 1) {
			 count = length - begin;
		 }
		 else {
			 double dcount = ScriptRuntime.toInteger(args[1]);
			 if (dcount < 0) {
				 count = 0;
			 }
			 else if (dcount > (length - begin)) {
				 count = length - begin;
			 }
			 else {
				 count = (long)dcount;
			 }
			 argc--;
		 }
		 long end = begin + count;
		 if (count != 0) {
			 if (count == 1 && (cx.getLanguageVersion() == Context.VERSION_1_2)) {
				 result = getElem(cx, thisObj, begin);
			 }
			 else {
				 for (long last = begin;
				 last != end;
				 last++) {
					 Scriptable resultArray = (Scriptable)result;
					 Object temp = getElem(cx, thisObj, last);
					 setElem(cx, resultArray, last - begin, temp);
				 }
			 }
		 }
		 else if (count == 0 && cx.getLanguageVersion() == Context.VERSION_1_2) {
			 result = Undefined.instance;
		 }
		 long delta = argc - count;
		 if (delta > 0) {
			 for (long last = length - 1;
			 last >= end;
			 last--) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 else if (delta < 0) {
			 for (long last = end;
			 last < length;
			 last++) {
				 Object temp = getElem(cx, thisObj, last);
				 setElem(cx, thisObj, last + delta, temp);
			 }
		 }
		 int argoffset = args.length - argc;
		 for (int i = 0;
		 i < argc;
		 i++) {
			 setElem(cx, thisObj, begin + i, args[i + argoffset]);
		 }
		 setLengthProperty(cx, thisObj, length + delta);
		 return result;
	 }
	 private static Scriptable js_concat(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 scope = getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(cx, scope, ""Array"");
		 Scriptable result = ctor.construct(cx, scope, ScriptRuntime.emptyArgs);
		 long length;
		 long slot = 0;
		 if (ScriptRuntime.instanceOf(thisObj, ctor, cx)) {
			 length = getLengthProperty(cx, thisObj);
			 for (slot = 0;
			 slot < length;
			 slot++) {
				 Object temp = getElem(cx, thisObj, slot);
				 setElem(cx, result, slot, temp);
			 }
		 }
		 else {
			 setElem(cx, result, slot++, thisObj);
		 }
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 if (ScriptRuntime.instanceOf(args[i], ctor, cx)) {
				 Scriptable arg = (Scriptable)args[i];
				 length = getLengthProperty(cx, arg);
				 for (long j = 0;
				 j < length;
				 j++, slot++) {
					 Object temp = getElem(cx, arg, j);
					 setElem(cx, result, slot, temp);
				 }
			 }
			 else {
				 setElem(cx, result, slot++, args[i]);
			 }
		 }
		 return result;
	 }
	 private Scriptable js_slice(Context cx, Scriptable thisObj, Object[] args) {
		 Scriptable scope = getTopLevelScope(this);
		 Scriptable result = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 long length = getLengthProperty(cx, thisObj);
		 long begin, end;
		 if (args.length == 0) {
			 begin = 0;
			 end = length;
		 }
		 else {
			 begin = toSliceIndex(ScriptRuntime.toInteger(args[0]), length);
			 if (args.length == 1) {
				 end = length;
			 }
			 else {
				 end = toSliceIndex(ScriptRuntime.toInteger(args[1]), length);
			 }
		 }
		 for (long slot = begin;
		 slot < end;
		 slot++) {
			 Object temp = getElem(cx, thisObj, slot);
			 setElem(cx, result, slot - begin, temp);
		 }
		 return result;
	 }
	 private static long toSliceIndex(double value, long length) {
		 long result;
		 if (value < 0.0) {
			 if (value + length < 0.0) {
				 result = 0;
			 }
			 else {
				 result = (long)(value + length);
			 }
		 }
		 else if (value > length) {
			 result = length;
		 }
		 else {
			 result = (long)value;
		 }
		 return result;
	 }
	 private Object indexOfHelper(Context cx, Scriptable thisObj, Object[] args, boolean isLast) {
		 Object compareTo = args.length > 0 ? args[0] : Undefined.instance;
		 long length = getLengthProperty(cx, thisObj);
		 long start = args.length > 1 ? ScriptRuntime.toInt32(ScriptRuntime.toNumber(args[1])) : (isLast ? length : 0);
		 if (start < 0) {
			 start += length;
			 if (start < 0) start = 0;
		 }
		 if (isLast) {
			 for (long i=start;
			 i >= 0 ;
			 i--) {
				 if (ScriptRuntime.shallowEq(getElem(cx, thisObj, i), compareTo)) {
					 return new Long(i);
				 }
			 }
		 }
		 else {
			 for (long i=start;
			 i < length;
			 i++) {
				 if (ScriptRuntime.shallowEq(getElem(cx, thisObj, i), compareTo)) {
					 return new Long(i);
				 }
			 }
		 }
		 return NEGATIVE_ONE;
	 }
	 private Object iterativeMethod(Context cx, int id, Scriptable scope, Scriptable thisObj, Object[] args) {
		 Object callbackArg = args.length > 0 ? args[0] : Undefined.instance;
		 if (callbackArg == null || !(callbackArg instanceof Function)) {
			 throw ScriptRuntime.notFunctionError( ScriptRuntime.toString(callbackArg));
		 }
		 Function f = (Function) callbackArg;
		 Scriptable parent = ScriptableObject.getTopLevelScope(f);
		 Scriptable thisArg = args.length > 1 && args[1] instanceof Scriptable ? (Scriptable) args[1] : parent;
		 long length = getLengthProperty(cx, thisObj);
		 Scriptable array = null;
		 if (id == Id_filter) {
			 array = ScriptRuntime.newObject(cx, scope, ""Array"", null);
		 }
		 else if (id == Id_map) {
			 Object[] ctorArgs = {
			 new Long(length) }
			;
			 array = ScriptRuntime.newObject(cx, scope, ""Array"", ctorArgs);
		 }
		 Object[] innerArgs = new Object[3];
		 long j=0;
		 for (long i=0;
		 i < length;
		 i++) {
			 innerArgs[0] = getElem(cx, thisObj, i);
			 innerArgs[1] = new Long(i);
			 innerArgs[2] = thisObj;
			 Object result = f.call(cx, parent, thisArg, innerArgs);
			 switch (id) {
				 case Id_every: if (!ScriptRuntime.toBoolean(result)) return Boolean.FALSE;
				 break;
				 case Id_filter: if (ScriptRuntime.toBoolean(result)) setElem(cx, array, j++, innerArgs[0]);
				 break;
				 case Id_forEach: break;
				 case Id_map: setElem(cx, array, j++, result);
				 break;
				 case Id_some: if (ScriptRuntime.toBoolean(result)) return Boolean.TRUE;
				 break;
			 }
		 }
		 switch (id) {
			 case Id_every: return Boolean.TRUE;
			 case Id_filter: case Id_map: return array;
			 case Id_some: return Boolean.FALSE;
			 case Id_forEach: default: return Undefined.instance;
		 }
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 3: c=s.charAt(0);
				 if (c=='m') {
					 if (s.charAt(2)=='p' && s.charAt(1)=='a') {
						id=Id_map;
						 break L0;
					}
				 }
				 else if (c=='p') {
					 if (s.charAt(2)=='p' && s.charAt(1)=='o') {
						id=Id_pop;
						 break L0;
					}
				 }
				 break L;
				 case 4: switch (s.charAt(2)) {
					 case 'i': X=""join"";
					id=Id_join;
					 break L;
					 case 'm': X=""some"";
					id=Id_some;
					 break L;
					 case 'r': X=""sort"";
					id=Id_sort;
					 break L;
					 case 's': X=""push"";
					id=Id_push;
					 break L;
				 }
				 break L;
				 case 5: c=s.charAt(1);
				 if (c=='h') {
					 X=""shift"";
					id=Id_shift;
				 }
				 else if (c=='l') {
					 X=""slice"";
					id=Id_slice;
				 }
				 else if (c=='v') {
					 X=""every"";
					id=Id_every;
				 }
				 break L;
				 case 6: c=s.charAt(0);
				 if (c=='c') {
					 X=""concat"";
					id=Id_concat;
				 }
				 else if (c=='f') {
					 X=""filter"";
					id=Id_filter;
				 }
				 else if (c=='s') {
					 X=""splice"";
					id=Id_splice;
				 }
				 break L;
				 case 7: switch (s.charAt(0)) {
					 case 'f': X=""forEach"";
					id=Id_forEach;
					 break L;
					 case 'i': X=""indexOf"";
					id=Id_indexOf;
					 break L;
					 case 'r': X=""reverse"";
					id=Id_reverse;
					 break L;
					 case 'u': X=""unshift"";
					id=Id_unshift;
					 break L;
				 }
				 break L;
				 case 8: c=s.charAt(3);
				 if (c=='o') {
					 X=""toSource"";
					id=Id_toSource;
				 }
				 else if (c=='t') {
					 X=""toString"";
					id=Id_toString;
				 }
				 break L;
				 case 11: c=s.charAt(0);
				 if (c=='c') {
					 X=""constructor"";
					id=Id_constructor;
				 }
				 else if (c=='l') {
					 X=""lastIndexOf"";
					id=Id_lastIndexOf;
				 }
				 break L;
				 case 14: X=""toLocaleString"";
				id=Id_toLocaleString;
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int Id_constructor = 1, Id_toString = 2, Id_toLocaleString = 3, Id_toSource = 4, Id_join = 5, Id_reverse = 6, Id_sort = 7, Id_push = 8, Id_pop = 9, Id_shift = 10, Id_unshift = 11, Id_splice = 12, Id_concat = 13, Id_slice = 14, Id_indexOf = 15, Id_lastIndexOf = 16, Id_every = 17, Id_filter = 18, Id_forEach = 19, Id_map = 20, Id_some = 21, MAX_PROTOTYPE_ID = 21;
	 private long length;
	 private Object[] dense;
	 private static final int maximumDenseLength = 10000;
}",1,0,0,0
"public abstract class AbstractRecordsInspector {
	 private int processedRecordCount;
	 public boolean isBatchFull() {
		 return processedRecordCount >= HiveAbstractReader.TARGET_RECORD_COUNT;
	 }
	 public int getProcessedRecordCount() {
		 return processedRecordCount;
	 }
	 public void incrementProcessedRecordCount() {
		 processedRecordCount++;
	 }
	 public void reset() {
		 processedRecordCount = 0;
	 }
	 public abstract Object getValueHolder();
	 public abstract Object getNextValue();
}",0,0,0,0
"public class DOMLocatorImpl implements DOMLocator {
	 public int fColumnNumber = -1;
	 public int fLineNumber = -1;
	 public Node fRelatedNode = null;
	 public String fUri = null;
	 public int fByteOffset = -1;
	 public int fUtf16Offset = -1;
	 public DOMLocatorImpl(){
	 }
	 public DOMLocatorImpl (int lineNumber, int columnNumber, String uri ){
		fLineNumber = lineNumber ;
		fColumnNumber = columnNumber ;
		fUri = uri;
	 }
	 public DOMLocatorImpl (int lineNumber, int columnNumber, int utf16Offset, String uri ){
		fLineNumber = lineNumber ;
		fColumnNumber = columnNumber ;
		fUri = uri;
		fUtf16Offset = utf16Offset;
	 }
	 public DOMLocatorImpl (int lineNumber, int columnNumber, int byteoffset, Node relatedData, String uri ){
		fLineNumber = lineNumber ;
		fColumnNumber = columnNumber ;
		fByteOffset = byteoffset ;
		fRelatedNode = relatedData ;
		fUri = uri;
	 }
	 public DOMLocatorImpl (int lineNumber, int columnNumber, int byteoffset, Node relatedData, String uri, int utf16Offset ){
		fLineNumber = lineNumber ;
		fColumnNumber = columnNumber ;
		fByteOffset = byteoffset ;
		fRelatedNode = relatedData ;
		fUri = uri;
		fUtf16Offset = utf16Offset;
	 }
	 public int getLineNumber(){
		 return fLineNumber;
	 }
	 public int getColumnNumber(){
		return fColumnNumber;
	 }
	 public String getUri(){
		return fUri;
	 }
	 public Node getRelatedNode(){
		 return fRelatedNode;
	 }
	 public int getByteOffset(){
		return fByteOffset;
	 }
	 public int getUtf16Offset(){
		return fUtf16Offset;
	 }
}",0,1,0,0
"public final void setLocale(Locale locale){
	this.locale = locale;
	invalidate();
}",0,0,0,0
"private static class getUserComputeResourcePreference_argsStandardScheme extends StandardScheme<getUserComputeResourcePreference_args> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, getUserComputeResourcePreference_args struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 1: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
					 struct.userId = iprot.readString();
					 struct.setUserIdIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 2: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
					 struct.gatewayID = iprot.readString();
					 struct.setGatewayIDIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 case 3: if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
					 struct.userComputeResourceId = iprot.readString();
					 struct.setUserComputeResourceIdIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, getUserComputeResourcePreference_args struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.userId != null) {
			 oprot.writeFieldBegin(USER_ID_FIELD_DESC);
			 oprot.writeString(struct.userId);
			 oprot.writeFieldEnd();
		 }
		 if (struct.gatewayID != null) {
			 oprot.writeFieldBegin(GATEWAY_ID_FIELD_DESC);
			 oprot.writeString(struct.gatewayID);
			 oprot.writeFieldEnd();
		 }
		 if (struct.userComputeResourceId != null) {
			 oprot.writeFieldBegin(USER_COMPUTE_RESOURCE_ID_FIELD_DESC);
			 oprot.writeString(struct.userComputeResourceId);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
public void setAuthValue(String auth_value);,0,0,0,0
"public void genJavaCode() throws IOException {
	 String pkg = getJavaPackage();
	 String pkgpath = pkg.replaceAll(""\\."", ""/"");
	 File pkgdir = new File(pkgpath);
	 if (!pkgdir.exists()) {
		 boolean ret = pkgdir.mkdirs();
		 if (!ret) {
			 System.out.println(""Cannnot create directory: ""+pkgpath);
			 System.exit(1);
		 }
	 }
	 else if (!pkgdir.isDirectory()) {
		 System.out.println(pkgpath+"" is not a directory."");
		 System.exit(1);
	 }
	 File jfile = new File(pkgdir, getName()+"".java"");
	 FileWriter jj = new FileWriter(jfile);
	 jj.write("" jj.write(""package ""+getJavaPackage()+"";
	\n\n"");
	 jj.write(""public class ""+getName()+"" implements org.apache.hadoop.record.Record, org.apache.hadoop.io.WritableComparable {
		\n"");
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaDecl());
		 }
		 jj.write("" private java.util.BitSet bs_;
		\n"");
		 jj.write("" public ""+getName()+""() {
			\n"");
			 jj.write("" bs_ = new java.util.BitSet(""+(mFields.size()+1)+"");
			\n"");
			 jj.write("" bs_.set(""+mFields.size()+"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public ""+getName()+""(\n"");
		 int fIdx = 0;
		 int fLen = mFields.size();
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaConstructorParam(fIdx));
			 jj.write((fLen-1 == fIdx)?"""":"",\n"");
		 }
		 jj.write("") {
			\n"");
			 jj.write("" bs_ = new java.util.BitSet(""+(mFields.size()+1)+"");
			\n"");
			 jj.write("" bs_.set(""+mFields.size()+"");
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaConstructorSet(fIdx));
			 }
		 jj.write("" }
		\n"");
		 fIdx = 0;
		 for (Iterator i = mFields.iterator();
		 i.hasNext();
		 fIdx++) {
			 JField jf = (JField) i.next();
			 jj.write(jf.genJavaGetSet(fIdx));
		 }
		 jj.write("" public void serialize(org.apache.hadoop.record.OutputArchive a_, String tag) throws java.io.IOException {
			\n"");
			 jj.write("" if (!validate()) throw new java.io.IOException(\""All fields not set:\"");
			\n"");
			 jj.write("" a_.startRecord(this,tag);
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaWriteMethodName());
				 jj.write("" bs_.clear(""+fIdx+"");
				\n"");
			 }
			 jj.write("" a_.endRecord(this,tag);
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void deserialize(org.apache.hadoop.record.InputArchive a_, String tag) throws java.io.IOException {
			\n"");
			 jj.write("" a_.startRecord(tag);
			\n"");
			 fIdx = 0;
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaReadMethodName());
				 jj.write("" bs_.set(""+fIdx+"");
				\n"");
			 }
			 jj.write("" a_.endRecord(tag);
			\n"");
		 jj.write(""}
		\n"");
		 jj.write("" public String toString() {
			\n"");
			 jj.write("" try {
				\n"");
				 jj.write("" java.io.ByteArrayOutputStream s =\n"");
				 jj.write("" new java.io.ByteArrayOutputStream();
				\n"");
				 jj.write("" org.apache.hadoop.record.CsvOutputArchive a_ = \n"");
				 jj.write("" new org.apache.hadoop.record.CsvOutputArchive(s);
				\n"");
				 jj.write("" a_.startRecord(this,\""\"");
				\n"");
				 fIdx = 0;
				 for (Iterator i = mFields.iterator();
				 i.hasNext();
				 fIdx++) {
					 JField jf = (JField) i.next();
					 jj.write(jf.genJavaWriteMethodName());
				 }
				 jj.write("" a_.endRecord(this,\""\"");
				\n"");
				 jj.write("" return new String(s.toByteArray(), \""UTF-8\"");
				\n"");
			 jj.write("" }
			 catch (Throwable ex) {
				\n"");
				 jj.write("" ex.printStackTrace();
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" return \""ERROR\"";
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void write(java.io.DataOutput out) throws java.io.IOException {
			\n"");
			 jj.write("" org.apache.hadoop.record.BinaryOutputArchive archive = new org.apache.hadoop.record.BinaryOutputArchive(out);
			\n"");
			 jj.write("" serialize(archive, \""\"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public void readFields(java.io.DataInput in) throws java.io.IOException {
			\n"");
			 jj.write("" org.apache.hadoop.record.BinaryInputArchive archive = new org.apache.hadoop.record.BinaryInputArchive(in);
			\n"");
			 jj.write("" deserialize(archive, \""\"");
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public boolean validate() {
			\n"");
			 jj.write("" if (bs_.cardinality() != bs_.length()) return false;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 JType type = jf.getType();
				 if (type instanceof JRecord) {
					 jj.write("" if (!""+jf.getName()+"".validate()) return false;
					\n"");
				 }
			 }
			 jj.write("" return true;
			\n"");
		 jj.write(""}
		\n"");
		 jj.write("" public int compareTo (Object peer_) throws ClassCastException {
			\n"");
			 jj.write("" if (!(peer_ instanceof ""+getName()+"")) {
				\n"");
				 jj.write("" throw new ClassCastException(\""Comparing different types of records.\"");
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" ""+getName()+"" peer = (""+getName()+"") peer_;
			\n"");
			 jj.write("" int ret = 0;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaCompareTo());
				 jj.write("" if (ret != 0) return ret;
				\n"");
			 }
			 jj.write("" return ret;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public boolean equals(Object peer_) {
			\n"");
			 jj.write("" if (!(peer_ instanceof ""+getName()+"")) {
				\n"");
				 jj.write("" return false;
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" if (peer_ == this) {
				\n"");
				 jj.write("" return true;
				\n"");
			 jj.write("" }
			\n"");
			 jj.write("" ""+getName()+"" peer = (""+getName()+"") peer_;
			\n"");
			 jj.write("" boolean ret = false;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaEquals());
				 jj.write("" if (!ret) return ret;
				\n"");
			 }
			 jj.write("" return ret;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public int hashCode() {
			\n"");
			 jj.write("" int result = 17;
			\n"");
			 jj.write("" int ret;
			\n"");
			 for (Iterator i = mFields.iterator();
			 i.hasNext();
			 fIdx++) {
				 JField jf = (JField) i.next();
				 jj.write(jf.genJavaHashCode());
				 jj.write("" result = 37*result + ret;
				\n"");
			 }
			 jj.write("" return result;
			\n"");
		 jj.write("" }
		\n"");
		 jj.write("" public static String signature() {
			\n"");
			 jj.write("" return \""""+getSignature()+""\"";
			\n"");
		 jj.write("" }
		\n"");
	 jj.write(""}
	\n"");
	 jj.close();
 }",0,0,1,0
"public void loadWaitingMessages() {
	 int updateCounter = 0;
	 int loadedMessageCount = 0;
	 MessageProxy mp;
	 int queueSize = getQueueSize();
	 int totalMessageCount = queueSize;
	 if (! stopped && queueSize > 0) {
		 folderInfo.getLogger().log(java.util.logging.Level.FINE, folderInfo.getFolderID() + "" loading "" + queueSize + "" messages."");
		 MessageLoadedListener display = getFolderInfo().getFolderDisplayUI();
		 if (display != null)this.addMessageLoadedListener(display);
		 fireMessageLoadedEvent(MessageLoadedEvent.LOADING_STARTING, 0, totalMessageCount);
		 int fetchBatchSize = 50;
		 int loadBatchSize = 25;
		 try {
			fetchBatchSize = Integer.parseInt(Pooka.getProperty(""Pooka.fetchBatchSize"", ""50""));
		 }
		 catch (NumberFormatException nfe) {
		 }
		 try {
			loadBatchSize = Integer.parseInt(Pooka.getProperty(""Pooka.loadBatchSize"", ""25""));
		 }
		 catch (NumberFormatException nfe) {
		 }
		 FetchProfile fetchProfile = getFolderInfo().getFetchProfile();
		 for (List messages = retrieveNextBatch(fetchBatchSize);
		 ! stopped && messages != null;
		 messages=retrieveNextBatch(fetchBatchSize)) {
			totalMessageCount = messages.size() + getQueueSize() + loadedMessageCount;
			if (Pooka.getProperty(""Pooka.openFoldersInBackGround"", ""false"").equalsIgnoreCase(""true"")) {
				 synchronized(folderInfo.getFolderThread().getRunLock()) {
					 try {
						 folderInfo.getFolderThread().setCurrentActionName(""Loading messages."");
						 for (int batchCount = 0;
						 ! stopped && batchCount < messages.size();
						 batchCount++) {
							mp=(MessageProxy)messages.get(batchCount);
							if (! mp.getMessageInfo().hasBeenFetched()) {
								 try {
									 List fetchList = new ArrayList();
									 for (int j = batchCount;
									 fetchList.size() < fetchBatchSize && j < messages.size();
									 j++) {
										 MessageInfo fetchInfo = ((MessageProxy) messages.get(j)).getMessageInfo();
										 if (! fetchInfo.hasBeenFetched()) {
											fetchList.add(fetchInfo);
										 }
									 }
									 MessageInfo[] toFetch = new MessageInfo[fetchList.size()];
									 toFetch = (MessageInfo[]) fetchList.toArray(toFetch);
									 getFolderInfo().fetch(toFetch, fetchProfile);
								 }
								 catch(MessagingException me) {
									 if (folderInfo.getLogger().isLoggable(java.util.logging.Level.WARNING)) {
										 System.out.println(""caught error while fetching for folder "" + getFolderInfo().getFolderID() + "": "" + me);
										 me.printStackTrace();
									 }
								 }
							}
							try {
								 if (! mp.isLoaded()) mp.loadTableInfo();
								 if (mp.needsRefresh()) mp.refreshMessage();
								 else if (! mp.matchedFilters()) {
									 mp.matchFilters();
								}
							}
							 catch (Exception e) {
								 if (folderInfo.getLogger().isLoggable(java.util.logging.Level.WARNING)) {
									 e.printStackTrace();
								 }
							}
							loadedMessageCount++;
							if (++updateCounter >= getUpdateMessagesCount()) {
								 fireMessageLoadedEvent(MessageLoadedEvent.MESSAGES_LOADED, loadedMessageCount, totalMessageCount);
								 updateCounter = 0;
							 }
						 }
					 }
					 finally {
						 folderInfo.getFolderThread().setCurrentActionName("""");
					 }
				 }
			 }
			 else {
				 for (int batchCount = 0;
				 ! stopped && batchCount < messages.size();
				 batchCount++) {
					 mp=(MessageProxy)messages.get(batchCount);
					 if (! mp.getMessageInfo().hasBeenFetched()) {
						 try {
							List fetchList = new ArrayList();
							for (int j = batchCount;
							 fetchList.size() < fetchBatchSize && j < messages.size();
							 j++) {
								 MessageInfo fetchInfo = ((MessageProxy) messages.get(j)).getMessageInfo();
								 if (! fetchInfo.hasBeenFetched()) {
									 fetchList.add(fetchInfo);
								 }
							}
							MessageInfo[] toFetch = new MessageInfo[fetchList.size()];
							toFetch = (MessageInfo[]) fetchList.toArray(toFetch);
							synchronized(folderInfo.getFolderThread().getRunLock()) {
								 folderInfo.getFolderThread().setCurrentActionName(""Loading messages."");
								 getFolderInfo().fetch(toFetch, fetchProfile);
								 folderInfo.getFolderThread().setCurrentActionName("""");
							}
						 }
						 catch(MessagingException me) {
							if (getFolderInfo().getLogger().isLoggable(java.util.logging.Level.WARNING)) {
								 System.out.println(""caught error while fetching for folder "" + getFolderInfo().getFolderID() + "": "" + me);
								 me.printStackTrace();
							}
						 }
					 }
					 try {
						 synchronized(folderInfo.getFolderThread().getRunLock()) {
							try {
								 folderInfo.getFolderThread().setCurrentActionName(""Loading messages."");
								 if (! mp.isLoaded()) mp.loadTableInfo();
								 if (mp.needsRefresh()) mp.refreshMessage();
								 else if (! mp.matchedFilters()) {
									 mp.matchFilters();
								 }
							}
							 finally {
								 folderInfo.getFolderThread().setCurrentActionName("""");
							}
						 }
					 }
					 catch (Exception e) {
						 if (folderInfo.getLogger().isLoggable(java.util.logging.Level.WARNING)) {
							e.printStackTrace();
						 }
					 }
					 loadedMessageCount++;
					 if (++updateCounter >= getUpdateMessagesCount()) {
						 fireMessageLoadedEvent(MessageLoadedEvent.MESSAGES_LOADED, loadedMessageCount, totalMessageCount);
						 updateCounter = 0;
					 }
				 }
			}
		 }
		 if (updateCounter > 0)fireMessageLoadedEvent(MessageLoadedEvent.MESSAGES_LOADED, loadedMessageCount, totalMessageCount);
		 fireMessageLoadedEvent(MessageLoadedEvent.LOADING_COMPLETE, loadedMessageCount, totalMessageCount);
		 if (display != null)removeMessageLoadedListener(display);
	 }
 }",0,0,1,0
"public class ArchivaMetadataCreationConsumer extends AbstractMonitoredConsumer implements KnownRepositoryContentConsumer, RegistryListener{
	 private String id = ""create-archiva-metadata"";
	 private String description = ""Create basic metadata for Archiva to be able to reference the artifact"";
	 private ArchivaConfiguration configuration;
	 private FileTypes filetypes;
	 private Date whenGathered;
	 private List<String> includes = new ArrayList<>( 0 );
	 private RepositorySessionFactory repositorySessionFactory;
	 private RepositoryStorage repositoryStorage;
	 private static final Logger log = LoggerFactory.getLogger( ArchivaMetadataCreationConsumer.class );
	 private String repoId;
	 public String getId() {
		 return this.id;
	 }
	 public String getDescription() {
		 return this.description;
	 }
	 public List<String> getExcludes() {
		 return getDefaultArtifactExclusions();
	 }
	 public List<String> getIncludes() {
		 return this.includes;
	 }
	 public void beginScan( ManagedRepository repo, Date whenGathered ) throws ConsumerException {
		 repoId = repo.getId();
		 this.whenGathered = whenGathered;
	 }
	 public void beginScan( ManagedRepository repository, Date whenGathered, boolean executeOnEntireRepo ) throws ConsumerException {
		 beginScan( repository, whenGathered );
	 }
	 public void processFile( String path ) throws ConsumerException {
		 RepositorySession repositorySession = repositorySessionFactory.createSession();
		 try {
			 ArtifactMetadata artifact = repositoryStorage.readArtifactMetadataFromPath( repoId, path );
			 ProjectMetadata project = new ProjectMetadata();
			 project.setNamespace( artifact.getNamespace() );
			 project.setId( artifact.getProject() );
			 String projectVersion = VersionUtil.getBaseVersion( artifact.getVersion() );
			 MetadataRepository metadataRepository = repositorySession.getRepository();
			 boolean createVersionMetadata = false;
			 ProjectVersionMetadata versionMetadata = null;
			 try {
				 ReadMetadataRequest readMetadataRequest = new ReadMetadataRequest().repositoryId( repoId ).namespace( artifact.getNamespace() ).projectId( artifact.getProject() ).projectVersion( projectVersion );
				 versionMetadata = repositoryStorage.readProjectVersionMetadata( readMetadataRequest );
				 createVersionMetadata = true;
			 }
			 catch ( RepositoryStorageMetadataNotFoundException e ) {
				 log.warn( ""Missing or invalid POM for artifact:{
				}
				 (repository:{
				}
				);
				 creating empty metadata"", path, repoId );
				 versionMetadata = new ProjectVersionMetadata();
				 versionMetadata.setId( projectVersion );
				 versionMetadata.setIncomplete( true );
				 createVersionMetadata = true;
			 }
			 catch ( RepositoryStorageMetadataInvalidException e ) {
				 log.warn( ""Error occurred resolving POM for artifact:{
				}
				 (repository:{
				}
				);
				 message: {
				}
				"", new Object[]{
				 path, repoId, e.getMessage() }
				 );
			 }
			 artifact.setWhenGathered( whenGathered );
			 metadataRepository.updateArtifact( repoId, project.getNamespace(), project.getId(), projectVersion, artifact );
			 if ( createVersionMetadata ) {
				 metadataRepository.updateProjectVersion( repoId, project.getNamespace(), project.getId(), versionMetadata );
			 }
			 metadataRepository.updateProject( repoId, project );
			 repositorySession.save();
		 }
		 catch ( MetadataRepositoryException e ) {
			 log.warn( ""Error occurred persisting metadata for artifact:{
			}
			 (repository:{
			}
			);
			 message: {
			}
			"" , path, repoId, e.getMessage(), e );
			 repositorySession.revert();
		 }
		 catch ( RepositoryStorageRuntimeException e ) {
			 log.warn( ""Error occurred persisting metadata for artifact:{
			}
			 (repository:{
			}
			);
			 message: {
			}
			"", path, repoId, e.getMessage(), e );
			 repositorySession.revert();
		 }
		 finally {
			 repositorySession.close();
		 }
	 }
	 public void processFile( String path, boolean executeOnEntireRepo ) throws ConsumerException {
		 processFile( path );
	 }
	 public void completeScan() {
	 }
	 public void completeScan( boolean executeOnEntireRepo ) {
		 completeScan();
	 }
	 public void afterConfigurationChange( Registry registry, String propertyName, Object propertyValue ) {
		 if ( ConfigurationNames.isRepositoryScanning( propertyName ) ) {
			 initIncludes();
		 }
	 }
	 public void beforeConfigurationChange( Registry registry, String propertyName, Object propertyValue ) {
	 }
	 private void initIncludes() {
		 includes = new ArrayList<String>( filetypes.getFileTypePatterns( FileTypes.ARTIFACTS ) );
	 }
	 public void initialize() {
		 configuration.addChangeListener( this );
		 initIncludes();
	 }
}",1,0,0,0
"public class XmpMMSchema extends XmpSchema {
	private static final long serialVersionUID = 1408509596611634862L;
	public static final String DEFAULT_XPATH_ID = ""xmpMM"";
	public static final String DEFAULT_XPATH_URI = ""http:public static final String DERIVEDFROM = ""xmpMM:DerivedFrom"";
	 public static final String DOCUMENTID = ""xmpMM:DocumentID"";
	public static final String HISTORY = ""xmpMM:History"";
	public static final String MANAGEDFROM = ""xmpMM:ManagedFrom"";
	public static final String MANAGER = ""xmpMM:Manager"";
	public static final String MANAGETO = ""xmpMM:ManageTo"";
	public static final String MANAGEUI = ""xmpMM:ManageUI"";
	public static final String MANAGERVARIANT = ""xmpMM:ManagerVariant"";
	public static final String RENDITIONCLASS = ""xmpMM:RenditionClass"";
	public static final String RENDITIONPARAMS = ""xmpMM:RenditionParams"";
	public static final String VERSIONID = ""xmpMM:VersionID"";
	public static final String VERSIONS = ""xmpMM:Versions"";
	public XmpMMSchema() {
		super(""xmlns:"" + DEFAULT_XPATH_ID + ""=\"""" + DEFAULT_XPATH_URI + ""\"""");
	}
}",0,0,0,0
"public class GrammerException extends ParsingException {
	public GrammerException(int offset, String msg) {
		super(offset, msg);
	}
	public GrammerException(int offset, int line, int column, String msg) {
		super(offset, line, column, msg);
	}
	public GrammerException(String msg, Exception e) {
		super(msg, e);
	}
	public GrammerException(int line, int column, String msg) {
		super(line, column, msg);
	}
}",0,0,0,0
"public abstract class ScriptableObject implements Scriptable, Serializable, DebuggableObject{
	 public static final int EMPTY = 0x00;
	 public static final int READONLY = 0x01;
	 public static final int DONTENUM = 0x02;
	 public static final int PERMANENT = 0x04;
	 static void checkValidAttributes(int attributes) {
		 final int mask = READONLY | DONTENUM | PERMANENT;
		 if ((attributes & ~mask) != 0) {
			 throw new IllegalArgumentException(String.valueOf(attributes));
		 }
	 }
	 public ScriptableObject() {
	 }
	 public ScriptableObject(Scriptable scope, Scriptable prototype) {
		 if (scope == null) throw new IllegalArgumentException();
		 parentScopeObject = scope;
		 prototypeObject = prototype;
	 }
	 public abstract String getClassName();
	 public boolean has(String name, Scriptable start) {
		 return null != getNamedSlot(name);
	 }
	 public boolean has(int index, Scriptable start) {
		 return null != getSlot(null, index);
	 }
	 public Object get(String name, Scriptable start) {
		 Slot slot = getNamedSlot(name);
		 if (slot == null) {
			 return Scriptable.NOT_FOUND;
		 }
		 if (slot instanceof GetterSlot) {
			 GetterSlot gslot = (GetterSlot)slot;
			 if (gslot.getter != null) {
				 return getByGetter(gslot, start);
			 }
		 }
		 return slot.value;
	 }
	 public Object get(int index, Scriptable start) {
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 return Scriptable.NOT_FOUND;
		 }
		 return slot.value;
	 }
	 public void put(String name, Scriptable start, Object value) {
		 Slot slot = lastAccess;
		 if (name != slot.stringKey || slot.wasDeleted != 0) {
			 int hash = name.hashCode();
			 slot = getSlot(name, hash);
			 if (slot == null) {
				 if (start != this) {
					 start.put(name, start, value);
					 return;
				 }
				 slot = addSlot(name, hash, null);
			 }
		 }
		 if (start == this && isSealed()) {
			 throw Context.reportRuntimeError1(""msg.modify.sealed"", name);
		 }
		 if ((slot.attributes & ScriptableObject.READONLY) != 0) {
			 return;
		 }
		 if (slot instanceof GetterSlot) {
			 GetterSlot gslot = (GetterSlot)slot;
			 if (gslot.setter != null) {
				 setBySetter(gslot, start, value);
			 }
			 return;
		 }
		 if (this == start) {
			 slot.value = value;
		 }
		 else {
			 start.put(name, start, value);
		 }
	 }
	 public void put(int index, Scriptable start, Object value) {
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 if (start != this) {
				 start.put(index, start, value);
				 return;
			 }
			 slot = addSlot(null, index, null);
		 }
		 if (start == this && isSealed()) {
			 throw Context.reportRuntimeError1(""msg.modify.sealed"", Integer.toString(index));
		 }
		 if ((slot.attributes & ScriptableObject.READONLY) != 0) {
			 return;
		 }
		 if (this == start) {
			 slot.value = value;
		 }
		 else {
			 start.put(index, start, value);
		 }
	 }
	 public void delete(String name) {
		 removeSlot(name, name.hashCode());
	 }
	 public void delete(int index) {
		 removeSlot(null, index);
	 }
	 public final int getAttributes(String name, Scriptable start) {
		 return getAttributes(name);
	 }
	 public final int getAttributes(int index, Scriptable start) {
		 return getAttributes(index);
	 }
	 public final void setAttributes(String name, Scriptable start, int attributes) {
		 setAttributes(name, attributes);
	 }
	 public void setAttributes(int index, Scriptable start, int attributes) {
		 setAttributes(index, attributes);
	 }
	 public int getAttributes(String name) {
		 Slot slot = getNamedSlot(name);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", name);
		 }
		 return slot.attributes;
	 }
	 public int getAttributes(int index) {
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", String.valueOf(index));
		 }
		 return slot.attributes;
	 }
	 public void setAttributes(String name, int attributes) {
		 checkValidAttributes(attributes);
		 Slot slot = getNamedSlot(name);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", name);
		 }
		 slot.attributes = (short) attributes;
	 }
	 public void setAttributes(int index, int attributes) {
		 checkValidAttributes(attributes);
		 Slot slot = getSlot(null, index);
		 if (slot == null) {
			 throw Context.reportRuntimeError1(""msg.prop.not.found"", String.valueOf(index));
		 }
		 slot.attributes = (short) attributes;
	 }
	 public Scriptable getPrototype() {
		 return prototypeObject;
	 }
	 public void setPrototype(Scriptable m) {
		 prototypeObject = m;
	 }
	 public Scriptable getParentScope() {
		 return parentScopeObject;
	 }
	 public void setParentScope(Scriptable m) {
		 parentScopeObject = m;
	 }
	 public Object[] getIds() {
		 return getIds(false);
	 }
	 public Object[] getAllIds() {
		 return getIds(true);
	 }
	 public Object getDefaultValue(Class typeHint) {
		 Context cx = null;
		 for (int i=0;
		 i < 2;
		 i++) {
			 boolean tryToString;
			 if (typeHint == ScriptRuntime.StringClass) {
				 tryToString = (i == 0);
			 }
			 else {
				 tryToString = (i == 1);
			 }
			 String methodName;
			 Object[] args;
			 if (tryToString) {
				 methodName = ""toString"";
				 args = ScriptRuntime.emptyArgs;
			 }
			 else {
				 methodName = ""valueOf"";
				 args = new Object[1];
				 String hint;
				 if (typeHint == null) {
					 hint = ""undefined"";
				 }
				 else if (typeHint == ScriptRuntime.StringClass) {
					 hint = ""string"";
				 }
				 else if (typeHint == ScriptRuntime.ScriptableClass) {
					 hint = ""object"";
				 }
				 else if (typeHint == ScriptRuntime.FunctionClass) {
					 hint = ""function"";
				 }
				 else if (typeHint == ScriptRuntime.BooleanClass || typeHint == Boolean.TYPE) {
					 hint = ""boolean"";
				 }
				 else if (typeHint == ScriptRuntime.NumberClass || typeHint == ScriptRuntime.ByteClass || typeHint == Byte.TYPE || typeHint == ScriptRuntime.ShortClass || typeHint == Short.TYPE || typeHint == ScriptRuntime.IntegerClass || typeHint == Integer.TYPE || typeHint == ScriptRuntime.FloatClass || typeHint == Float.TYPE || typeHint == ScriptRuntime.DoubleClass || typeHint == Double.TYPE) {
					 hint = ""number"";
				 }
				 else {
					 throw Context.reportRuntimeError1( ""msg.invalid.type"", typeHint.toString());
				 }
				 args[0] = hint;
			 }
			 Object v = getProperty(this, methodName);
			 if (!(v instanceof Function)) continue;
			 Function fun = (Function) v;
			 if (cx == null) cx = Context.getContext();
			 v = fun.call(cx, fun.getParentScope(), this, args);
			 if (v != null) {
				 if (!(v instanceof Scriptable)) {
					 return v;
				 }
				 if (v == Undefined.instance || typeHint == ScriptRuntime.ScriptableClass || typeHint == ScriptRuntime.FunctionClass) {
					 return v;
				 }
				 if (tryToString && v instanceof Wrapper) {
					 Object u = ((Wrapper)v).unwrap();
					 if (u instanceof String) return u;
				 }
			 }
		 }
		 String arg = (typeHint == null) ? ""undefined"" : typeHint.getName();
		 throw ScriptRuntime.typeError1(""msg.default.value"", arg);
	 }
	 public boolean hasInstance(Scriptable instance) {
		 return ScriptRuntime.jsDelegatesTo(instance, this);
	 }
	 protected Object equivalentValues(Object value) {
		 return (this == value) ? Boolean.TRUE : Scriptable.NOT_FOUND;
	 }
	 public static void defineClass(Scriptable scope, Class clazz) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 defineClass(scope, clazz, false);
	 }
	 public static void defineClass(Scriptable scope, Class clazz, boolean sealed) throws IllegalAccessException, InstantiationException, InvocationTargetException {
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 for (int i=0;
		 i < methods.length;
		 i++) {
			 Method method = methods[i];
			 if (!method.getName().equals(""init"")) continue;
			 Class[] parmTypes = method.getParameterTypes();
			 if (parmTypes.length == 3 && parmTypes[0] == ScriptRuntime.ContextClass && parmTypes[1] == ScriptRuntime.ScriptableClass && parmTypes[2] == Boolean.TYPE && Modifier.isStatic(method.getModifiers())) {
				 Object args[] = {
				 Context.getContext(), scope, sealed ? Boolean.TRUE : Boolean.FALSE }
				;
				 method.invoke(null, args);
				 return;
			 }
			 if (parmTypes.length == 1 && parmTypes[0] == ScriptRuntime.ScriptableClass && Modifier.isStatic(method.getModifiers())) {
				 Object args[] = {
				 scope }
				;
				 method.invoke(null, args);
				 return;
			 }
		 }
		 Constructor[] ctors = clazz.getConstructors();
		 Constructor protoCtor = null;
		 for (int i=0;
		 i < ctors.length;
		 i++) {
			 if (ctors[i].getParameterTypes().length == 0) {
				 protoCtor = ctors[i];
				 break;
			 }
		 }
		 if (protoCtor == null) {
			 throw Context.reportRuntimeError1( ""msg.zero.arg.ctor"", clazz.getName());
		 }
		 Scriptable proto = (Scriptable) protoCtor.newInstance(ScriptRuntime.emptyArgs);
		 proto.setPrototype(getObjectPrototype(scope));
		 String className = proto.getClassName();
		 final String functionPrefix = ""jsFunction_"";
		 final String staticFunctionPrefix = ""jsStaticFunction_"";
		 final String getterPrefix = ""jsGet_"";
		 final String setterPrefix = ""jsSet_"";
		 final String ctorName = ""jsConstructor"";
		 Member ctorMember = FunctionObject.findSingleMethod(methods, ctorName);
		 if (ctorMember == null) {
			 if (ctors.length == 1) {
				 ctorMember = ctors[0];
			 }
			 else if (ctors.length == 2) {
				 if (ctors[0].getParameterTypes().length == 0) ctorMember = ctors[1];
				 else if (ctors[1].getParameterTypes().length == 0) ctorMember = ctors[0];
			 }
			 if (ctorMember == null) {
				 throw Context.reportRuntimeError1( ""msg.ctor.multiple.parms"", clazz.getName());
			 }
		 }
		 FunctionObject ctor = new FunctionObject(className, ctorMember, scope);
		 if (ctor.isVarArgsMethod()) {
			 throw Context.reportRuntimeError1 (""msg.varargs.ctor"", ctorMember.getName());
		 }
		 ctor.addAsConstructor(scope, proto);
		 Method finishInit = null;
		 for (int i=0;
		 i < methods.length;
		 i++) {
			 if (methods[i] == ctorMember) {
				 continue;
			 }
			 String name = methods[i].getName();
			 if (name.equals(""finishInit"")) {
				 Class[] parmTypes = methods[i].getParameterTypes();
				 if (parmTypes.length == 3 && parmTypes[0] == ScriptRuntime.ScriptableClass && parmTypes[1] == FunctionObject.class && parmTypes[2] == ScriptRuntime.ScriptableClass && Modifier.isStatic(methods[i].getModifiers())) {
					 finishInit = methods[i];
					 continue;
				 }
			 }
			 if (name.indexOf('$') != -1) continue;
			 if (name.equals(ctorName)) continue;
			 String prefix = null;
			 if (name.startsWith(functionPrefix)) {
				 prefix = functionPrefix;
			 }
			 else if (name.startsWith(staticFunctionPrefix)) {
				 prefix = staticFunctionPrefix;
				 if (!Modifier.isStatic(methods[i].getModifiers())) {
					 throw Context.reportRuntimeError( ""jsStaticFunction must be used with static method."");
				 }
			 }
			 else if (name.startsWith(getterPrefix)) {
				 prefix = getterPrefix;
			 }
			 else if (name.startsWith(setterPrefix)) {
				 prefix = setterPrefix;
			 }
			 else {
				 continue;
			 }
			 name = name.substring(prefix.length());
			 if (prefix == setterPrefix) continue;
			 if (prefix == getterPrefix) {
				 if (!(proto instanceof ScriptableObject)) {
					 throw Context.reportRuntimeError2( ""msg.extend.scriptable"", proto.getClass().toString(), name);
				 }
				 Method setter = FunctionObject.findSingleMethod( methods, setterPrefix + name);
				 int attr = ScriptableObject.PERMANENT | ScriptableObject.DONTENUM | (setter != null ? 0 : ScriptableObject.READONLY);
				 ((ScriptableObject) proto).defineProperty(name, null, methods[i], setter, attr);
				 continue;
			 }
			 FunctionObject f = new FunctionObject(name, methods[i], proto);
			 if (f.isVarArgsConstructor()) {
				 throw Context.reportRuntimeError1 (""msg.varargs.fun"", ctorMember.getName());
			 }
			 Scriptable dest = prefix == staticFunctionPrefix ? ctor : proto;
			 defineProperty(dest, name, f, DONTENUM);
			 if (sealed) {
				 f.sealObject();
			 }
		 }
		 if (finishInit != null) {
			 Object[] finishArgs = {
			 scope, ctor, proto }
			;
			 finishInit.invoke(null, finishArgs);
		 }
		 if (sealed) {
			 ctor.sealObject();
			 if (proto instanceof ScriptableObject) {
				 ((ScriptableObject) proto).sealObject();
			 }
		 }
	 }
	 public void defineProperty(String propertyName, Object value, int attributes) {
		 put(propertyName, this, value);
		 setAttributes(propertyName, attributes);
	 }
	 public static void defineProperty(Scriptable destination, String propertyName, Object value, int attributes) {
		 if (!(destination instanceof ScriptableObject)) {
			 destination.put(propertyName, destination, value);
			 return;
		 }
		 ScriptableObject so = (ScriptableObject)destination;
		 so.defineProperty(propertyName, value, attributes);
	 }
	 public void defineProperty(String propertyName, Class clazz, int attributes) {
		 int length = propertyName.length();
		 if (length == 0) throw new IllegalArgumentException();
		 char[] buf = new char[3 + length];
		 propertyName.getChars(0, length, buf, 3);
		 buf[3] = Character.toUpperCase(buf[3]);
		 buf[0] = 'g';
		 buf[1] = 'e';
		 buf[2] = 't';
		 String getterName = new String(buf);
		 buf[0] = 's';
		 String setterName = new String(buf);
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 Method getter = FunctionObject.findSingleMethod(methods, getterName);
		 Method setter = FunctionObject.findSingleMethod(methods, setterName);
		 if (setter == null) attributes |= ScriptableObject.READONLY;
		 defineProperty(propertyName, null, getter, setter == null ? null : setter, attributes);
	 }
	 public void defineProperty(String propertyName, Object delegateTo, Method getter, Method setter, int attributes) {
		 if (delegateTo == null && (Modifier.isStatic(getter.getModifiers()))) delegateTo = HAS_STATIC_ACCESSORS;
		 Class[] parmTypes = getter.getParameterTypes();
		 if (parmTypes.length != 0) {
			 if (parmTypes.length != 1 || parmTypes[0] != ScriptRuntime.ScriptableObjectClass) {
				 throw Context.reportRuntimeError1( ""msg.bad.getter.parms"", getter.toString());
			 }
		 }
		 else if (delegateTo != null) {
			 throw Context.reportRuntimeError1( ""msg.obj.getter.parms"", getter.toString());
		 }
		 if (setter != null) {
			 if ((delegateTo == HAS_STATIC_ACCESSORS) != (Modifier.isStatic(setter.getModifiers()))) {
				 throw Context.reportRuntimeError0(""msg.getter.static"");
			 }
			 parmTypes = setter.getParameterTypes();
			 if (parmTypes.length == 2) {
				 if (parmTypes[0] != ScriptRuntime.ScriptableObjectClass) {
					 throw Context.reportRuntimeError0(""msg.setter2.parms"");
				 }
				 if (delegateTo == null) {
					 throw Context.reportRuntimeError1( ""msg.setter1.parms"", setter.toString());
				 }
			 }
			 else if (parmTypes.length == 1) {
				 if (delegateTo != null) {
					 throw Context.reportRuntimeError1( ""msg.setter2.expected"", setter.toString());
				 }
			 }
			 else {
				 throw Context.reportRuntimeError0(""msg.setter.parms"");
			 }
			 Class setterType = parmTypes[parmTypes.length - 1];
			 int setterTypeTag = FunctionObject.getTypeTag(setterType);
			 if (setterTypeTag == FunctionObject.JAVA_UNSUPPORTED_TYPE) {
				 throw Context.reportRuntimeError2( ""msg.setter2.expected"", setterType.getName(), setter.toString());
			 }
		 }
		 ClassCache cache = ClassCache.get(this);
		 GetterSlot gslot = new GetterSlot();
		 gslot.delegateTo = delegateTo;
		 gslot.getter = new MemberBox(getter, cache);
		 gslot.getter.prepareInvokerOptimization();
		 if (setter != null) {
			 gslot.setter = new MemberBox(setter, cache);
			 gslot.setter.prepareInvokerOptimization();
		 }
		 gslot.attributes = (short) attributes;
		 Slot inserted = addSlot(propertyName, propertyName.hashCode(), gslot);
		 if (inserted != gslot) {
			 throw new RuntimeException(""Property already exists"");
		 }
	 }
	 public void defineFunctionProperties(String[] names, Class clazz, int attributes) {
		 Method[] methods = FunctionObject.getMethodList(clazz);
		 for (int i=0;
		 i < names.length;
		 i++) {
			 String name = names[i];
			 Method m = FunctionObject.findSingleMethod(methods, name);
			 if (m == null) {
				 throw Context.reportRuntimeError2( ""msg.method.not.found"", name, clazz.getName());
			 }
			 FunctionObject f = new FunctionObject(name, m, this);
			 defineProperty(name, f, attributes);
		 }
	 }
	 public static Scriptable getObjectPrototype(Scriptable scope) {
		 return getClassPrototype(scope, ""Object"");
	 }
	 public static Scriptable getFunctionPrototype(Scriptable scope) {
		 return getClassPrototype(scope, ""Function"");
	 }
	 public static Scriptable getClassPrototype(Scriptable scope, String className) {
		 scope = getTopLevelScope(scope);
		 Object ctor = getProperty(scope, className);
		 Object proto;
		 if (ctor instanceof BaseFunction) {
			 proto = ((BaseFunction)ctor).getPrototypeProperty();
		 }
		 else if (ctor instanceof Scriptable) {
			 Scriptable ctorObj = (Scriptable)ctor;
			 proto = ctorObj.get(""prototype"", ctorObj);
		 }
		 else {
			 return null;
		 }
		 if (proto instanceof Scriptable) {
			 return (Scriptable)proto;
		 }
		 return null;
	 }
	 public static Scriptable getTopLevelScope(Scriptable obj) {
		 for (;
		;
		) {
			 Scriptable parent = obj.getParentScope();
			 if (parent == null) {
				 return obj;
			 }
			 obj = parent;
		 }
	 }
	 public synchronized void sealObject() {
		 if (count >= 0) {
			 count = -1 - count;
		 }
	 }
	 public final boolean isSealed() {
		 return count < 0;
	 }
	 public static Object getProperty(Scriptable obj, String name) {
		 Scriptable start = obj;
		 Object result;
		 do {
			 result = obj.get(name, start);
			 if (result != Scriptable.NOT_FOUND) break;
			 obj = obj.getPrototype();
		 }
		 while (obj != null);
		 return result;
	 }
	 public static Object getProperty(Scriptable obj, int index) {
		 Scriptable start = obj;
		 Object result;
		 do {
			 result = obj.get(index, start);
			 if (result != Scriptable.NOT_FOUND) break;
			 obj = obj.getPrototype();
		 }
		 while (obj != null);
		 return result;
	 }
	 public static boolean hasProperty(Scriptable obj, String name) {
		 return null != getBase(obj, name);
	 }
	 public static boolean hasProperty(Scriptable obj, int index) {
		 return null != getBase(obj, index);
	 }
	 public static void putProperty(Scriptable obj, String name, Object value) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) base = obj;
		 base.put(name, obj, value);
	 }
	 public static void putProperty(Scriptable obj, int index, Object value) {
		 Scriptable base = getBase(obj, index);
		 if (base == null) base = obj;
		 base.put(index, obj, value);
	 }
	 public static boolean deleteProperty(Scriptable obj, String name) {
		 Scriptable base = getBase(obj, name);
		 if (base == null) return true;
		 base.delete(name);
		 return !base.has(name, obj);
	 }
	 public static boolean deleteProperty(Scriptable obj, int index) {
		 Scriptable base = getBase(obj, index);
		 if (base == null) return true;
		 base.delete(index);
		 return !base.has(index, obj);
	 }
	 public static Object[] getPropertyIds(Scriptable obj) {
		 if (obj == null) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] result = obj.getIds();
		 ObjToIntMap map = null;
		 for (;
		;
		) {
			 obj = obj.getPrototype();
			 if (obj == null) {
				 break;
			 }
			 Object[] ids = obj.getIds();
			 if (ids.length == 0) {
				 continue;
			 }
			 if (map == null) {
				 if (result.length == 0) {
					 result = ids;
					 continue;
				 }
				 map = new ObjToIntMap(result.length + ids.length);
				 for (int i = 0;
				 i != result.length;
				 ++i) {
					 map.intern(result[i]);
				 }
				 result = null;
			 }
			 for (int i = 0;
			 i != ids.length;
			 ++i) {
				 map.intern(ids[i]);
			 }
		 }
		 if (map != null) {
			 result = map.getKeys();
		 }
		 return result;
	 }
	 public static Object callMethod(Scriptable obj, String methodName, Object[] args) {
		 return callMethod(null, obj, methodName, args);
	 }
	 public static Object callMethod(Context cx, Scriptable obj, String methodName, Object[] args) {
		 Object funObj = getProperty(obj, methodName);
		 if (!(funObj instanceof Function)) {
			 throw ScriptRuntime.notFunctionError(obj, methodName);
		 }
		 Function fun = (Function)funObj;
		 Scriptable scope = ScriptableObject.getTopLevelScope(obj);
		 if (cx != null) {
			 return fun.call(cx, scope, obj, args);
		 }
		 else {
			 return Context.call(null, fun, scope, obj, args);
		 }
	 }
	 private static Scriptable getBase(Scriptable obj, String name) {
		 do {
			 if (obj.has(name, obj)) break;
			 obj = obj.getPrototype();
		 }
		 while(obj != null);
		 return obj;
	 }
	 private static Scriptable getBase(Scriptable obj, int index) {
		 do {
			 if (obj.has(index, obj)) break;
			 obj = obj.getPrototype();
		 }
		 while(obj != null);
		 return obj;
	 }
	 public final Object getAssociatedValue(Object key) {
		 Hashtable h = associatedValues;
		 if (h == null) return null;
		 return h.get(key);
	 }
	 public static Object getTopScopeValue(Scriptable scope, Object key) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 for (;
		;
		) {
			 if (scope instanceof ScriptableObject) {
				 ScriptableObject so = (ScriptableObject)scope;
				 Object value = so.getAssociatedValue(key);
				 if (value != null) {
					 return value;
				 }
			 }
			 scope = scope.getPrototype();
			 if (scope == null) {
				 return null;
			 }
		 }
	 }
	 public final Object associateValue(Object key, Object value) {
		 if (value == null) throw new IllegalArgumentException();
		 Hashtable h = associatedValues;
		 if (h == null) {
			 synchronized (this) {
				 h = associatedValues;
				 if (h == null) {
					 h = new Hashtable();
					 associatedValues = h;
				 }
			 }
		 }
		 return Kit.initHash(h, key, value);
	 }
	 private Object getByGetter(GetterSlot slot, Scriptable start) {
		 Object getterThis;
		 Object[] args;
		 if (slot.delegateTo == null) {
			 if (start != this) {
				 Class clazz = slot.getter.getDeclaringClass();
				 while (!clazz.isInstance(start)) {
					 start = start.getPrototype();
					 if (start == this) {
						 break;
					 }
					 if (start == null) {
						 start = this;
						 break;
					 }
				 }
			 }
			 getterThis = start;
			 args = ScriptRuntime.emptyArgs;
		 }
		 else {
			 getterThis = slot.delegateTo;
			 args = new Object[] {
			 this }
			;
		 }
		 return slot.getter.invoke(getterThis, args);
	 }
	 private void setBySetter(GetterSlot slot, Scriptable start, Object value) {
		 if (start != this) {
			 if (slot.delegateTo != null || !slot.setter.getDeclaringClass().isInstance(start)) {
				 start.put(slot.stringKey, start, value);
				 return;
			 }
		 }
		 Object setterThis;
		 Object[] args;
		 Object setterResult;
		 Context cx = Context.getContext();
		 Class pTypes[] = slot.setter.argTypes;
		 Class desired = pTypes[pTypes.length - 1];
		 int tag = FunctionObject.getTypeTag(desired);
		 Object actualArg = FunctionObject.convertArg(cx, start, value, tag);
		 if (slot.delegateTo == null) {
			 setterThis = start;
			 args = new Object[] {
			 actualArg }
			;
		 }
		 else {
			 if (start != this) Kit.codeBug();
			 setterThis = slot.delegateTo;
			 args = new Object[] {
			 this, actualArg }
			;
		 }
		 if (((ScriptableObject)start).isSealed()) {
			 throw Context.reportRuntimeError1(""msg.modify.sealed"", slot.stringKey);
		 }
		 setterResult = slot.setter.invoke(setterThis, args);
		 if (slot.setter.method().getReturnType() != Void.TYPE) {
			 Slot replacement = new Slot();
			 replacement.intKey = slot.intKey;
			 replacement.stringKey = slot.stringKey;
			 replacement.attributes = slot.attributes;
			 replacement.value = setterResult;
			 synchronized (this) {
				 int i = getSlotPosition(slots, slot.stringKey, slot.intKey);
				 if (i >= 0 && slots[i] == slot) {
					 slots[i] = replacement;
					 lastAccess = replacement;
				 }
			 }
		 }
	 }
	 private Slot getNamedSlot(String name) {
		 Slot slot = lastAccess;
		 if (name == slot.stringKey && slot.wasDeleted == 0) {
			 return slot;
		 }
		 int hash = name.hashCode();
		 Slot[] slots = this.slots;
		 int i = getSlotPosition(slots, name, hash);
		 if (i < 0) {
			 return null;
		 }
		 slot = slots[i];
		 slot.stringKey = name;
		 lastAccess = slot;
		 return slot;
	 }
	 private Slot getSlot(String id, int index) {
		 Slot[] slots = this.slots;
		 int i = getSlotPosition(slots, id, index);
		 return (i < 0) ? null : slots[i];
	 }
	 private static int getSlotPosition(Slot[] slots, String id, int index) {
		 if (slots != null) {
			 int start = (index & 0x7fffffff) % slots.length;
			 int i = start;
			 do {
				 Slot slot = slots[i];
				 if (slot == null) break;
				 if (slot != REMOVED && slot.intKey == index && (slot.stringKey == id || (id != null && id.equals(slot.stringKey)))) {
					 return i;
				 }
				 if (++i == slots.length) i = 0;
			 }
			 while (i != start);
		 }
		 return -1;
	 }
	 private synchronized Slot addSlot(String id, int index, Slot newSlot) {
		 if (isSealed()) {
			 String str = (id != null) ? id : Integer.toString(index);
			 throw Context.reportRuntimeError1(""msg.add.sealed"", str);
		 }
		 if (slots == null) {
			 slots = new Slot[5];
		 }
		 return addSlotImpl(id, index, newSlot);
	 }
	 private Slot addSlotImpl(String id, int index, Slot newSlot) {
		 int start = (index & 0x7fffffff) % slots.length;
		 int i = start;
		 for (;
		;
		) {
			 Slot slot = slots[i];
			 if (slot == null || slot == REMOVED) {
				 if ((4 * (count + 1)) > (3 * slots.length)) {
					 grow();
					 return addSlotImpl(id, index, newSlot);
				 }
				 slot = (newSlot == null) ? new Slot() : newSlot;
				 slot.stringKey = id;
				 slot.intKey = index;
				 slots[i] = slot;
				 count++;
				 return slot;
			 }
			 if (slot.intKey == index && (slot.stringKey == id || (id != null && id.equals(slot.stringKey)))) {
				 return slot;
			 }
			 if (++i == slots.length) i = 0;
			 if (i == start) {
				 throw new IllegalStateException();
			 }
		 }
	 }
	 private synchronized void removeSlot(String name, int index) {
		 if (isSealed()) {
			 String str = (name != null) ? name : Integer.toString(index);
			 throw Context.reportRuntimeError1(""msg.remove.sealed"", str);
		 }
		 int i = getSlotPosition(slots, name, index);
		 if (i >= 0) {
			 Slot slot = slots[i];
			 if ((slot.attributes & PERMANENT) == 0) {
				 slot.wasDeleted = (byte)1;
				 if (slot == lastAccess) {
					 lastAccess = REMOVED;
				 }
				 count--;
				 if (count != 0) {
					 slots[i] = REMOVED;
				 }
				 else {
					 slots[i] = null;
				 }
			 }
		 }
	 }
	 private void grow() {
		 Slot[] newSlots = new Slot[slots.length*2 + 1];
		 for (int j=slots.length-1;
		 j >= 0 ;
		 j--) {
			 Slot slot = slots[j];
			 if (slot == null || slot == REMOVED) continue;
			 int k = (slot.intKey & 0x7fffffff) % newSlots.length;
			 while (newSlots[k] != null) if (++k == newSlots.length) k = 0;
			 newSlots[k] = slot;
		 }
		 slots = newSlots;
	 }
	 Object[] getIds(boolean getAll) {
		 Slot[] s = slots;
		 Object[] a = ScriptRuntime.emptyArgs;
		 if (s == null) return a;
		 int c = 0;
		 for (int i=0;
		 i < s.length;
		 i++) {
			 Slot slot = s[i];
			 if (slot == null || slot == REMOVED) continue;
			 if (getAll || (slot.attributes & DONTENUM) == 0) {
				 if (c == 0) a = new Object[s.length - i];
				 a[c++] = slot.stringKey != null ? (Object) slot.stringKey : new Integer(slot.intKey);
			 }
		 }
		 if (c == a.length) return a;
		 Object[] result = new Object[c];
		 System.arraycopy(a, 0, result, 0, c);
		 return result;
	 }
	 private synchronized void writeObject(ObjectOutputStream out) throws IOException {
		 out.defaultWriteObject();
		 int N = count;
		 if (N < 0) {
			 N = -1 - count;
		 }
		 Slot[] s = slots;
		 if (s == null) {
			 if (N != 0) Kit.codeBug();
			 out.writeInt(0);
		 }
		 else {
			 out.writeInt(s.length);
			 for (int i = 0;
			 N != 0;
			 ++i) {
				 Slot slot = s[i];
				 if (slot != null && slot != REMOVED) {
					 --N;
					 out.writeObject(slot);
				 }
			 }
		 }
	 }
	 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
		 in.defaultReadObject();
		 lastAccess = REMOVED;
		 int capacity = in.readInt();
		 if (capacity != 0) {
			 slots = new Slot[capacity];
			 int N = count;
			 boolean wasSealed = false;
			 if (N < 0) {
				 N = -1 - N;
				 wasSealed = true;
			 }
			 count = 0;
			 for (int i = 0;
			 i != N;
			 ++i) {
				 Slot s = (Slot)in.readObject();
				 addSlotImpl(s.stringKey, s.intKey, s);
			 }
			 if (wasSealed) {
				 count = - 1 - count;
			 }
		 }
	 }
	 private Scriptable prototypeObject;
	 private Scriptable parentScopeObject;
	 private static final Object HAS_STATIC_ACCESSORS = Void.TYPE;
	 private static final Slot REMOVED = new Slot();
	 private transient Slot[] slots;
	 private int count;
	 private transient Slot lastAccess = REMOVED;
	 private transient volatile Hashtable associatedValues;
	 private static class Slot implements Serializable {
		 private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
			 in.defaultReadObject();
			 if (stringKey != null) {
				 intKey = stringKey.hashCode();
			 }
		 }
		 int intKey;
		 String stringKey;
		 Object value;
		 short attributes;
		 transient byte wasDeleted;
	 }
	 private static final class GetterSlot extends Slot {
		 Object delegateTo;
		 MemberBox getter;
		 MemberBox setter;
	 }
}",1,0,0,0
"public class Table extends Fixture {
	 public static Parse table;
	 public void doRows(Parse rows) {
		 Table.table = new Parse (""table"", null, copy(rows), null);
		 (new Fixture()).doTables(Table.table);
	 }
	 static Parse copy(Parse tree) {
		 return (tree == null) ? null : new Parse(tree.tag, tree.body, copy(tree.parts), copy(tree.more));
	 }
}",0,0,0,0
"public class MetaResultSet implements ResultSet {
	 private int currRow = -1;
	 private boolean wasNull = false, closed = false;
	 private ColumnInfo[] columns;
	 private Object[][] rows;
	 private ResultSetMetaData metadata;
	 public MetaResultSet(ColumnInfo[] columns) throws SQLException {
		 this(columns, new Object[0][0]);
	 }
	 public MetaResultSet(ColumnInfo[] columns, Object[][] rows) throws SQLException {
		 if (columns == null) throw new SQLException(""Column information cannot be null"");
		 if (rows == null) throw new SQLException(""Row data cannot be null"");
		 this.columns = columns;
		 this.rows = rows;
		 this.metadata = new MetaResultSetMetadata(this, this.columns);
		 for (int i = 0;
		 i < rows.length;
		 i++) {
			 if (rows[i].length != this.columns.length) throw new SQLException(""Row "" + (i+1) + "" does not have the expected number of columns"");
		 }
	 }
	 public boolean isWrapperFor(Class<?> arg0) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T unwrap(Class<T> arg0) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public boolean absolute(int row) throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else if (row == 0) {
			 return true;
		 }
		 else if (row == 1) {
			 return this.first();
		 }
		 else if (row == -1) {
			 return this.last();
		 }
		 else if (row > 0) {
			 if (row >= this.rows.length) {
				 this.currRow = this.rows.length;
				 return false;
			 }
			 else {
				 this.currRow = row;
				 return true;
			 }
		 }
		 else {
			 int pos = rows.length + row;
			 if (pos < 1) {
				 this.currRow = -1;
				 return false;
			 }
			 else {
				 this.currRow = pos;
				 return true;
			 }
		 }
	 }
	 public void afterLast() throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else {
			 this.currRow = this.rows.length;
		 }
	 }
	 public void beforeFirst() throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else {
			 this.currRow = -1;
		 }
	 }
	 public void cancelRowUpdates() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void clearWarnings() {
	 }
	 public void close() {
		 this.closed = true;
	 }
	 public void deleteRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public int findColumn(String columnLabel) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Result set is closed"");
		 for (int i = 0;
		 i < this.columns.length;
		 i++) {
			 if (this.columns[i].getLabel().equals(columnLabel)) {
				 return i + 1;
			 }
		 }
		 throw new SQLException(""The given column does not exist in this result set"");
	 }
	 public boolean first() throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else {
			 this.currRow = 0;
			 return true;
		 }
	 }
	 private Object getValue(int columnIndex, int expectedType, Class<?> targetType, Object nullValue) throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Result set is closed"");
		 if (this.currRow < 0 || this.currRow >= this.rows.length) throw new SQLException(""Not currently at a row"");
		 if (columnIndex >= 1 && columnIndex <= this.columns.length) {
			 ColumnInfo info = this.columns[columnIndex - 1];
			 Object obj = this.rows[this.currRow][columnIndex - 1];
			 this.wasNull = (obj == null);
			 if (this.wasNull) return nullValue;
			 if (info.getType() == expectedType) {
				 if (targetType.isAssignableFrom(obj.getClass())) {
					 try {
						 Object temp = targetType.cast(obj);
						 return temp;
					 }
					 catch (ClassCastException e) {
						 throw new SQLException(""Value for this column (Row "" + (currRow+1) + "" Column "" + columnIndex + "") is not valid for the columns declared type"", e);
					 }
				 }
				 else {
					 throw new SQLException(""Value for this column (Row "" + (currRow+1) + "" Column "" + columnIndex + "") is not valid for the columns declared type"");
				 }
			 }
			 else {
				 throw new SQLException(""Given column (Row "" + (currRow+1) + "" Column "" + columnIndex + "") does not contain appropriately typed values. Column type declared as "" + info.getType() + "" but expected type for this lookup is "" + expectedType);
			 }
		 }
		 else {
			 throw new SQLException(""Column index is out of bounds"");
		 }
	 }
	 public Array getArray(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Array getArray(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getAsciiStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getAsciiStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		 return (BigDecimal) this.getValue(columnIndex, Types.DECIMAL, BigDecimal.class, null);
	 }
	 public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
		 return this.getBigDecimal(this.findColumn(columnLabel));
	 }
	 public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public BigDecimal getBigDecimal(String columnLabel, int scale) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getBinaryStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getBinaryStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Blob getBlob(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Blob getBlob(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public boolean getBoolean(int columnIndex) throws SQLException {
		 return (Boolean) this.getValue(columnIndex, Types.BOOLEAN, Boolean.class, false);
	 }
	 public boolean getBoolean(String columnLabel) throws SQLException {
		 return this.getBoolean(this.findColumn(columnLabel));
	 }
	 public byte getByte(int columnIndex) throws SQLException {
		 return (Byte) this.getValue(columnIndex, Types.TINYINT, Byte.class, (byte)0x0);
	 }
	 public byte getByte(String columnLabel) throws SQLException {
		 return this.getByte(this.findColumn(columnLabel));
	 }
	 public byte[] getBytes(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public byte[] getBytes(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Reader getCharacterStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Reader getCharacterStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Clob getClob(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Clob getClob(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public int getConcurrency() {
		 return ResultSet.CONCUR_READ_ONLY;
	 }
	 public String getCursorName() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Date getDate(int columnIndex) throws SQLException {
		 return (Date) this.getValue(columnIndex, Types.DATE, Date.class, null);
	 }
	 public Date getDate(String columnLabel) throws SQLException {
		 return this.getDate(this.findColumn(columnLabel));
	 }
	 public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Date getDate(String columnLabel, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public double getDouble(int columnIndex) throws SQLException {
		 return (Double) this.getValue(columnIndex, Types.DOUBLE, Double.class, 0d);
	 }
	 public double getDouble(String columnLabel) throws SQLException {
		 return this.getDouble(this.findColumn(columnLabel));
	 }
	 public int getFetchDirection() {
		 return ResultSet.FETCH_FORWARD;
	 }
	 public int getFetchSize() {
		 return 0;
	 }
	 public float getFloat(int columnIndex) throws SQLException {
		 return (Float) this.getValue(columnIndex, Types.FLOAT, Float.class, 0f);
	 }
	 public float getFloat(String columnLabel) throws SQLException {
		 return this.getFloat(this.findColumn(columnLabel));
	 }
	 public int getHoldability() {
		 return ResultSet.HOLD_CURSORS_OVER_COMMIT;
	 }
	 public int getInt(int columnIndex) throws SQLException {
		 return (Integer) this.getValue(columnIndex, Types.INTEGER, Integer.class, 0);
	 }
	 public int getInt(String columnLabel) throws SQLException {
		 return this.getInt(this.findColumn(columnLabel));
	 }
	 public long getLong(int columnIndex) throws SQLException {
		 return (Long) this.getValue(columnIndex, Types.BIGINT, Long.class, 0l);
	 }
	 public long getLong(String columnLabel) throws SQLException {
		 return this.getLong(this.findColumn(columnLabel));
	 }
	 public ResultSetMetaData getMetaData() {
		 return this.metadata;
	 }
	 public Reader getNCharacterStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Reader getNCharacterStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public NClob getNClob(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public NClob getNClob(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public String getNString(int columnIndex) throws SQLException {
		 return (String) this.getValue(columnIndex, Types.NVARCHAR, String.class, null);
	 }
	 public String getNString(String columnLabel) throws SQLException {
		 return this.getNString(this.findColumn(columnLabel));
	 }
	 public Object getObject(int columnIndex) {
		 return null;
	 }
	 public Object getObject(String columnLabel) throws SQLException {
		 return this.getObject(this.findColumn(columnLabel));
	 }
	 public Object getObject(int columnIndex, Map<String, Class<?>> map) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Object getObject(String columnLabel, Map<String, Class<?>> map) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Ref getRef(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Ref getRef(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public int getRow() {
		 if (this.currRow >= 0 && this.currRow < this.rows.length) {
			 return this.currRow + 1;
		 }
		 else {
			 return 0;
		 }
	 }
	 public RowId getRowId(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public RowId getRowId(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLXML getSQLXML(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLXML getSQLXML(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public short getShort(int columnIndex) throws SQLException {
		 return (Short) this.getValue(columnIndex, Types.SMALLINT, Short.class, (short) 0);
	 }
	 public short getShort(String columnLabel) throws SQLException {
		 return this.getShort(this.findColumn(columnLabel));
	 }
	 public Statement getStatement() {
		 return null;
	 }
	 public String getString(int columnIndex) throws SQLException {
		 return (String) this.getValue(columnIndex, Types.NVARCHAR, String.class, null);
	 }
	 public String getString(String columnLabel) throws SQLException {
		 return this.getString(this.findColumn(columnLabel));
	 }
	 public Time getTime(int columnIndex) throws SQLException {
		 return (Time) this.getValue(columnIndex, Types.TIME, Time.class, null);
	 }
	 public Time getTime(String columnLabel) throws SQLException {
		 return this.getTime(this.findColumn(columnLabel));
	 }
	 public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Time getTime(String columnLabel, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Timestamp getTimestamp(int columnIndex) throws SQLException {
		 return (Timestamp) this.getValue(columnIndex, Types.TIMESTAMP, Timestamp.class, null);
	 }
	 public Timestamp getTimestamp(String columnLabel) throws SQLException {
		 return this.getTimestamp(this.findColumn(columnLabel));
	 }
	 public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public Timestamp getTimestamp(String columnLabel, Calendar cal) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public int getType() {
		 return ResultSet.TYPE_SCROLL_INSENSITIVE;
	 }
	 public URL getURL(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public URL getURL(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public InputStream getUnicodeStream(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public SQLWarning getWarnings() {
		 return null;
	 }
	 public void insertRow() {
	 }
	 public boolean isAfterLast() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Result set is closed"");
		 return this.currRow == this.rows.length;
	 }
	 public boolean isBeforeFirst() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Result set is closed"");
		 return this.currRow == -1;
	 }
	 public boolean isClosed() {
		 return this.closed;
	 }
	 public boolean isFirst() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Result set is closed"");
		 return this.currRow == 0;
	 }
	 public boolean isLast() throws SQLException {
		 if (this.isClosed()) throw new SQLException(""Result set is closed"");
		 return this.currRow == this.rows.length - 1;
	 }
	 public boolean last() throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else {
			 this.currRow = this.rows.length - 1;
			 return true;
		 }
	 }
	 public void moveToCurrentRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void moveToInsertRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public boolean next() throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else if (this.currRow == this.rows.length) {
			 return false;
		 }
		 else {
			 this.currRow++;
			 return (this.currRow < this.rows.length);
		 }
	 }
	 public boolean previous() throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else if (this.currRow == -1) {
			 return false;
		 }
		 else {
			 this.currRow--;
			 return (this.currRow > -1);
		 }
	 }
	 public void refreshRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public boolean relative(int rows) throws SQLException {
		 if (this.isClosed()) {
			 throw new SQLException(""Cannot move to a row after the result set is closed"");
		 }
		 else if (rows == 0) {
			 return true;
		 }
		 else if (rows > 0) {
			 if (this.currRow + rows >= this.rows.length) {
				 this.currRow = this.rows.length;
				 return false;
			 }
			 else {
				 this.currRow += rows;
				 return true;
			 }
		 }
		 else {
			 int pos = this.currRow + rows;
			 if (pos < 1) {
				 this.currRow = -1;
				 return false;
			 }
			 else {
				 this.currRow = pos;
				 return true;
			 }
		 }
	 }
	 public boolean rowDeleted() {
		 return false;
	 }
	 public boolean rowInserted() {
		 return false;
	 }
	 public boolean rowUpdated() {
		 return false;
	 }
	 public void setFetchDirection(int direction) {
	 }
	 public void setFetchSize(int rows) {
	 }
	 public void updateArray(int columnIndex, Array x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateArray(String columnLabel, Array x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateAsciiStream(int columnIndex, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateAsciiStream(String columnLabel, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBigDecimal(String columnLabel, BigDecimal x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBinaryStream(int columnIndex, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBinaryStream(String columnLabel, InputStream x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBlob(int columnIndex, Blob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBlob(String columnLabel, Blob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBoolean(String columnLabel, boolean x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateByte(int columnIndex, byte x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateByte(String columnLabel, byte x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateBytes(String columnLabel, byte[] x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateCharacterStream(int columnIndex, Reader x, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateCharacterStream(String columnLabel, Reader reader, int length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateClob(int columnIndex, Clob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateClob(String columnLabel, Clob x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateClob(int columnIndex, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateClob(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateDate(int columnIndex, Date x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateDate(String columnLabel, Date x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateDouble(int columnIndex, double x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateDouble(String columnLabel, double x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateFloat(int columnIndex, float x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateFloat(String columnLabel, float x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateInt(int columnIndex, int x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateInt(String columnLabel, int x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateLong(int columnIndex, long x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateLong(String columnLabel, long x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNClob(String columnLabel, NClob nClob) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNClob(String columnLabel, Reader reader) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNString(int columnIndex, String nString) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNString(String columnLabel, String nString) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNull(int columnIndex) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateNull(String columnLabel) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateObject(int columnIndex, Object x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateObject(String columnLabel, Object x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateObject(int columnIndex, Object x, int scaleOrLength) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateObject(String columnLabel, Object x, int scaleOrLength) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateRef(int columnIndex, Ref x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateRef(String columnLabel, Ref x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateRow() throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateRowId(int columnIndex, RowId x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateRowId(String columnLabel, RowId x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateShort(int columnIndex, short x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateShort(String columnLabel, short x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateString(int columnIndex, String x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateString(String columnLabel, String x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateTime(int columnIndex, Time x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateTime(String columnLabel, Time x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateTimestamp(int columnIndex, Timestamp x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public void updateTimestamp(String columnLabel, Timestamp x) throws SQLException {
		 throw new SQLFeatureNotSupportedException(""Jena JDBC metadata is read-only"");
	 }
	 public boolean wasNull() {
		 return this.wasNull;
	 }
}",1,0,0,0
"public void initialize(){
	cookies.clear();
	headers.clear();
	code = HttpServletResponse.SC_OK;
	errorMessage = null;
	redirectLocation = null;
	status = HttpServletResponse.SC_OK;
	characterEncoding = ""UTF-8"";
	locale = null;
	byteStream = new ByteArrayOutputStream();
	servletStream = new ServletOutputStream(){
		public void write(int b){
			byteStream.write(b);
		}
	}
	;
	stringWriter = new StringWriter();
	printWriter = new PrintWriter(stringWriter){
		public void close(){
		}
		public void flush(){
		}
	}
	;
	mode = MODE_NONE;
}",0,0,0,0
"public class NMNullStateStoreService extends NMStateStoreService {
	 public NMNullStateStoreService() {
		 super(NMNullStateStoreService.class.getName());
	 }
	 public boolean canRecover() {
		 return false;
	 }
	 public RecoveredApplicationsState loadApplicationsState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeApplication(ApplicationId appId, ContainerManagerApplicationProto p) throws IOException {
	 }
	 public void removeApplication(ApplicationId appId) throws IOException {
	 }
	 public RecoveryIterator<RecoveredContainerState> getContainerStateIterator() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeContainer(ContainerId containerId, int version, long startTime, StartContainerRequest startRequest) {
	 }
	 public void storeContainerQueued(ContainerId containerId) throws IOException {
	 }
	 public void storeContainerPaused(ContainerId containerId) throws IOException {
	 }
	 public void removeContainerPaused(ContainerId containerId) throws IOException {
	 }
	 public void storeContainerDiagnostics(ContainerId containerId, StringBuilder diagnostics) throws IOException {
	 }
	 public void storeContainerLaunched(ContainerId containerId) throws IOException {
	 }
	 public void storeContainerUpdateToken(ContainerId containerId, ContainerTokenIdentifier containerTokenIdentifier) throws IOException {
	 }
	 public void storeContainerKilled(ContainerId containerId) throws IOException {
	 }
	 public void storeContainerCompleted(ContainerId containerId, int exitCode) throws IOException {
	 }
	 public void storeContainerRemainingRetryAttempts(ContainerId containerId, int remainingRetryAttempts) throws IOException {
	 }
	 public void storeContainerRestartTimes(ContainerId containerId, List<Long> restartTimes) throws IOException {
	 }
	 public void storeContainerWorkDir(ContainerId containerId, String workDir) throws IOException {
	 }
	 public void storeContainerLogDir(ContainerId containerId, String logDir) throws IOException {
	 }
	 public void removeContainer(ContainerId containerId) throws IOException {
	 }
	 public RecoveredLocalizationState loadLocalizationState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void startResourceLocalization(String user, ApplicationId appId, LocalResourceProto proto, Path localPath) throws IOException {
	 }
	 public void finishResourceLocalization(String user, ApplicationId appId, LocalizedResourceProto proto) throws IOException {
	 }
	 public void removeLocalizedResource(String user, ApplicationId appId, Path localPath) throws IOException {
	 }
	 public RecoveredDeletionServiceState loadDeletionServiceState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeDeletionTask(int taskId, DeletionServiceDeleteTaskProto taskProto) throws IOException {
	 }
	 public void removeDeletionTask(int taskId) throws IOException {
	 }
	 public RecoveredNMTokensState loadNMTokensState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeNMTokenCurrentMasterKey(MasterKey key) throws IOException {
	 }
	 public void storeNMTokenPreviousMasterKey(MasterKey key) throws IOException {
	 }
	 public void storeNMTokenApplicationMasterKey(ApplicationAttemptId attempt, MasterKey key) throws IOException {
	 }
	 public void removeNMTokenApplicationMasterKey(ApplicationAttemptId attempt) throws IOException {
	 }
	 public RecoveredContainerTokensState loadContainerTokensState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeContainerTokenCurrentMasterKey(MasterKey key) throws IOException {
	 }
	 public void storeContainerTokenPreviousMasterKey(MasterKey key) throws IOException {
	 }
	 public void storeContainerToken(ContainerId containerId, Long expirationTime) throws IOException {
	 }
	 public void removeContainerToken(ContainerId containerId) throws IOException {
	 }
	 public RecoveredLogDeleterState loadLogDeleterState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeLogDeleter(ApplicationId appId, LogDeleterProto proto) throws IOException {
	 }
	 public void removeLogDeleter(ApplicationId appId) throws IOException {
	 }
	 public RecoveredAMRMProxyState loadAMRMProxyState() throws IOException {
		 throw new UnsupportedOperationException( ""Recovery not supported by this state store"");
	 }
	 public void storeAMRMProxyCurrentMasterKey(MasterKey key) throws IOException {
	 }
	 public void storeAMRMProxyNextMasterKey(MasterKey key) throws IOException {
	 }
	 public void storeAMRMProxyAppContextEntry(ApplicationAttemptId attempt, String key, byte[] data) throws IOException {
	 }
	 public void removeAMRMProxyAppContextEntry(ApplicationAttemptId attempt, String key) throws IOException {
	 }
	 public void removeAMRMProxyAppContext(ApplicationAttemptId attempt) throws IOException {
	 }
	 public void storeAssignedResources(Container container, String resourceType, List<Serializable> assignedResources) throws IOException {
		 updateContainerResourceMapping(container, resourceType, assignedResources);
	 }
	 protected void initStorage(Configuration conf) throws IOException {
	 }
	 protected void startStorage() throws IOException {
	 }
	 protected void closeStorage() throws IOException {
	 }
}",0,0,0,0
"public boolean isDescendent(TarEntry desc) {
	 return desc.getName().startsWith(this.getName());
 }",0,0,0,0
"public void execute() {
	 Message savedMessage = message;
	 try {
		 Mailer mailer = null;
		 boolean autoFound = false;
		 if (encoding.equals(MIME) || (encoding.equals(AUTO) && !autoFound)) {
			 try {
				 mailer = (Mailer) ClasspathUtils.newInstance( ""org.apache.tools.ant.taskdefs.email.MimeMailer"", EmailTask.class.getClassLoader(), Mailer.class);
				 autoFound = true;
				 log(""Using MIME mail"", Project.MSG_VERBOSE);
			 }
			 catch (BuildException e) {
				 logBuildException(""Failed to initialise MIME mail: "", e);
				 return;
			 }
		 }
		 if (!autoFound && ((user != null) || (password != null)) && (encoding.equals(UU) || encoding.equals(PLAIN))) {
			 throw new BuildException(""SMTP auth only possible with MIME mail"");
		 }
		 if (!autoFound && (ssl) && (encoding.equals(UU) || encoding.equals(PLAIN))) {
			 throw new BuildException(""SSL only possible with MIME mail"");
		 }
		 if (encoding.equals(UU) || (encoding.equals(AUTO) && !autoFound)) {
			 try {
				 mailer = (Mailer) ClasspathUtils.newInstance( ""org.apache.tools.ant.taskdefs.email.UUMailer"", EmailTask.class.getClassLoader(), Mailer.class);
				 autoFound = true;
				 log(""Using UU mail"", Project.MSG_VERBOSE);
			 }
			 catch (BuildException e) {
				 logBuildException(""Failed to initialise UU mail: "", e);
				 return;
			 }
		 }
		 if (encoding.equals(PLAIN) || (encoding.equals(AUTO) && !autoFound)) {
			 mailer = new PlainMailer();
			 autoFound = true;
			 log(""Using plain mail"", Project.MSG_VERBOSE);
		 }
		 if (mailer == null) {
			 throw new BuildException(""Failed to initialise encoding: "" + encoding);
		 }
		 if (message == null) {
			 message = new Message();
			 message.setProject(getProject());
		 }
		 if (from == null || from.getAddress() == null) {
			 throw new BuildException(""A from element is required"");
		 }
		 if (toList.isEmpty() && ccList.isEmpty() && bccList.isEmpty()) {
			 throw new BuildException(""At least one of to, cc or bcc must "" + ""be supplied"");
		 }
		 if (messageMimeType != null) {
			 if (message.isMimeTypeSpecified()) {
				 throw new BuildException(""The mime type can only be "" + ""specified in one location"");
			 }
			 message.setMimeType(messageMimeType);
		 }
		 if (charset != null) {
			 if (message.getCharset() != null) {
				 throw new BuildException(""The charset can only be "" + ""specified in one location"");
			 }
			 message.setCharset(charset);
		 }
		 Vector files = new Vector();
		 if (attachments != null) {
			 Iterator iter = attachments.iterator();
			 while (iter.hasNext()) {
				 FileResource fr = (FileResource) iter.next();
				 files.addElement(fr.getFile());
			 }
		 }
		 log(""Sending email: "" + subject, Project.MSG_INFO);
		 log(""From "" + from, Project.MSG_VERBOSE);
		 log(""ReplyTo "" + replyToList, Project.MSG_VERBOSE);
		 log(""To "" + toList, Project.MSG_VERBOSE);
		 log(""Cc "" + ccList, Project.MSG_VERBOSE);
		 log(""Bcc "" + bccList, Project.MSG_VERBOSE);
		 mailer.setHost(host);
		 mailer.setPort(port);
		 mailer.setUser(user);
		 mailer.setPassword(password);
		 mailer.setSSL(ssl);
		 mailer.setMessage(message);
		 mailer.setFrom(from);
		 mailer.setReplyToList(replyToList);
		 mailer.setToList(toList);
		 mailer.setCcList(ccList);
		 mailer.setBccList(bccList);
		 mailer.setFiles(files);
		 mailer.setSubject(subject);
		 mailer.setTask(this);
		 mailer.setIncludeFileNames(includeFileNames);
		 mailer.setHeaders(headers);
		 mailer.send();
		 int count = files.size();
		 log(""Sent email with "" + count + "" attachment"" + (count == 1 ? """" : ""s""), Project.MSG_INFO);
	 }
	 catch (BuildException e) {
		 logBuildException(""Failed to send email: "", e);
		 if (failOnError) {
			 throw e;
		 }
	 }
	 catch (Exception e) {
		 log(""Failed to send email: "" + e.getMessage(), Project.MSG_WARN);
		 if (failOnError) {
			 throw new BuildException(e);
		 }
	 }
	 finally {
		 message = savedMessage;
	 }
 }",0,0,1,0
"private static boolean handleAspectAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {
	AnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);
	if (aspect != null) {
		boolean extendsAspect = false;
		if (!""java.lang.Object"".equals(struct.enclosingType.getSuperclass().getName())) {
			if (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {
				reportError(""cannot extend a concrete aspect"", struct);
				return false;
			}
			extendsAspect = struct.enclosingType.getSuperclass().isAspect();
		}
		NameValuePair aspectPerClause = getAnnotationElement(aspect, VALUE);
		final PerClause perClause;
		if (aspectPerClause == null) {
			if (!extendsAspect) {
				perClause = new PerSingleton();
			}
			 else {
				perClause = new PerFromSuper(struct.enclosingType.getSuperclass().getPerClause().getKind());
			}
		}
		 else {
			String perX = aspectPerClause.getValue().stringifyValue();
			if (perX == null || perX.length() <= 0) {
				perClause = new PerSingleton();
			}
			 else {
				perClause = parsePerClausePointcut(perX, struct);
			}
		}
		if (perClause == null) {
			return false;
		}
		 else {
			perClause.setLocation(struct.context, -1, -1);
			AjAttribute.Aspect aspectAttribute = new AjAttribute.Aspect(perClause);
			struct.ajAttributes.add(aspectAttribute);
			FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
			final IScope binding;
			binding = new BindingScope(struct.enclosingType, struct.context, bindings);
			aspectAttribute.setResolutionScope(binding);
			return true;
		}
	}
	return false;
}",0,0,1,0
"public static class ConvertFromJsonNullableInput implements DrillSimpleFunc {
	 NullableVarBinaryHolder in;
	 DrillBuf buffer;
	 org.apache.drill.exec.vector.complex.fn.JsonReader jsonReader;
	 ComplexWriter writer;
	 public void setup() {
		 jsonReader = new org.apache.drill.exec.vector.complex.fn.JsonReader.Builder(buffer) .defaultSchemaPathColumns() .build();
	 }
	 public void eval() {
		 if (in.isSet == 0) {
			 org.apache.drill.exec.vector.complex.writer.BaseWriter.MapWriter mapWriter = writer.rootAsMap();
			 mapWriter.start();
			 mapWriter.end();
			 return;
		 }
		 try {
			 jsonReader.setSource(in.start, in.end, in.buffer);
			 jsonReader.write(writer);
			 buffer = jsonReader.getWorkBuf();
		 }
		 catch (Exception e) {
			 throw new org.apache.drill.common.exceptions.DrillRuntimeException(""Error while converting from JSON. "", e);
		 }
	 }
 }",0,0,0,0
"public class JdbcFloat extends AbstractJdbcType<Float>{
	 public static final JdbcFloat instance = new JdbcFloat();
	 JdbcFloat() {
	}
	 public boolean isCaseSensitive() {
		 return false;
	 }
	 public int getScale(Float obj) {
		 return 40;
	 }
	 public int getPrecision(Float obj) {
		 return 7;
	 }
	 public boolean isCurrency() {
		 return false;
	 }
	 public boolean isSigned() {
		 return true;
	 }
	 public String toString(Float obj) {
		 return obj.toString();
	 }
	 public boolean needsQuotes() {
		 return false;
	 }
	 public String getString(ByteBuffer bytes) {
		 if (bytes.remaining() == 0) {
			 return """";
		 }
		 if (bytes.remaining() != 4) {
			 throw new MarshalException(""A float is exactly 4 bytes : ""+bytes.remaining());
		 }
		 return ((Float)ByteBufferUtil.toFloat(bytes)).toString();
	 }
	 public Class<Float> getType() {
		 return Float.class;
	 }
	 public int getJdbcType() {
		 return Types.FLOAT;
	 }
	 public Float compose(ByteBuffer bytes) {
		 return ByteBufferUtil.toFloat(bytes);
	 }
	 public ByteBuffer decompose(Float value) {
		 return (value==null) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : ByteBufferUtil.bytes(value);
	 }
}",0,0,0,0
"public class LockMode extends TypesafeEnum {
	 private LockMode(final int value) {
		 super(value);
	 }
	 public static final LockMode NONE = new LockMode(0);
	 public static final LockMode WAIT_FOREVER = new LockMode(1);
	 public static final LockMode NO_WAIT = new LockMode(2);
}",0,1,0,0
"public class MultiLevelDerivedUDF3 extends MultiLevelDerivedUDF2 {
}",1,0,0,0
"public class Raster implements Renderer, Runnable{
	 private ObjectInfo light[];
	 private FormContainer configPanel;
	 private BCheckBox transparentBox, adaptiveBox, hideBackfaceBox, hdrBox;
	 private BComboBox shadeChoice, aliasChoice, sampleChoice;
	 private ValueField errorField, smoothField;
	 private int imagePixel[], width, height, envMode, imageWidth, imageHeight;
	 private int shadingMode = PHONG, samplesPerPixel = 1, subsample = 1;
	 private Fragment fragment[];
	 private long updateTime;
	 private MemoryImageSource imageSource;
	 private Scene theScene;
	 private Camera theCamera;
	 private RenderListener listener;
	 private Image img;
	 private Thread renderThread;
	 private RGBColor ambColor, envColor, fogColor;
	 private TextureMapping envMapping;
	 private ThreadLocal threadRasterContext, threadCompositingContext;
	 private RowLock lock[];
	 private double envParamValue[];
	 private double time, smoothing = 1.0, smoothScale, focalDist, surfaceError = 0.02, fogDist;
	 private boolean fog, transparentBackground = false, adaptive = true, hideBackfaces = true, generateHDR = false, positionNeeded, depthNeeded, needCopyToUI = true;
	 public static final int GOURAUD = 0;
	 public static final int HYBRID = 1;
	 public static final int PHONG = 2;
	 public static final double TOL = 1e-12;
	 public static final float INTENSITY_CUTOFF = 0.005f;
	 public static final Fragment BACKGROUND_FRAGMENT = new OpaqueFragment(0, Float.MAX_VALUE);
	 private static final int WHITE_ERGB = new RGBColor(1.0f, 1.0f, 1.0f).getERGB();
	 public Raster() {
		 threadRasterContext = new ThreadLocal() {
			 protected Object initialValue() {
				 return new RasterContext(theCamera, width);
			 }
		 }
		;
		 threadCompositingContext = new ThreadLocal() {
			 protected Object initialValue() {
				 return new CompositingContext(theCamera);
			 }
		 }
		;
	 }
	 public String getName() {
		 return ""Raster"";
	 }
	 public synchronized void renderScene(Scene theScene, Camera camera, RenderListener rl, SceneCamera sceneCamera) {
		 Dimension dim = camera.getSize();
		 listener = rl;
		 this.theScene = theScene;
		 theCamera = camera.duplicate();
		 if (sceneCamera == null) {
			 sceneCamera = new SceneCamera();
			 sceneCamera.setDepthOfField(0.0);
			 sceneCamera.setFocalDistance(theCamera.getDistToScreen());
		 }
		 focalDist = sceneCamera.getFocalDistance();
		 depthNeeded = ((sceneCamera.getComponentsForFilters()&ComplexImage.DEPTH) != 0);
		 time = theScene.getTime();
		 if (imagePixel == null || imageWidth != dim.width || imageHeight != dim.height) {
			 imageWidth = dim.width;
			 imageHeight = dim.height;
			 imagePixel = new int [imageWidth*imageHeight];
			 imageSource = new MemoryImageSource(imageWidth, imageHeight, imagePixel, 0, imageWidth);
			 imageSource.setAnimated(true);
			 img = Toolkit.getDefaultToolkit().createImage(imageSource);
		 }
		 width = imageWidth*samplesPerPixel;
		 height = imageHeight*samplesPerPixel;
		 fragment = new Fragment [width*height];
		 Arrays.fill(fragment, BACKGROUND_FRAGMENT);
		 theCamera.setScreenTransform(sceneCamera.getScreenTransform(width, height), width, height);
		 lock = new RowLock[height];
		 for (int i = 0;
		 i < lock.length;
		 i++) lock[i] = new RowLock();
		 renderThread = new Thread(this, ""Raster Renderer Main Thread"");
		 renderThread.start();
	 }
	 public synchronized void cancelRendering(Scene sc) {
		 Thread t = renderThread;
		 RenderListener rl = listener;
		 if (theScene != sc) return;
		 renderThread = null;
		 if (t == null) return;
		 try {
			 while (t.isAlive()) {
				 Thread.sleep(100);
			 }
		 }
		 catch (InterruptedException ex) {
		 }
		 finish(null);
		 rl.renderingCanceled();
	 }
	 public Widget getConfigPanel() {
		 if (configPanel == null) {
			 configPanel = new FormContainer(3, 5);
			 LayoutInfo leftLayout = new LayoutInfo(LayoutInfo.EAST, LayoutInfo.NONE, new Insets(0, 0, 0, 5), null);
			 LayoutInfo rightLayout = new LayoutInfo(LayoutInfo.WEST, LayoutInfo.NONE, null, null);
			 configPanel.add(Translate.label(""surfaceAccuracy""), 0, 0, leftLayout);
			 configPanel.add(Translate.label(""shadingMethod""), 0, 1, leftLayout);
			 configPanel.add(Translate.label(""supersampling""), 0, 2, leftLayout);
			 configPanel.add(errorField = new ValueField(surfaceError, ValueField.POSITIVE, 6), 1, 0, rightLayout);
			 configPanel.add(shadeChoice = new BComboBox(new String [] {
			 Translate.text(""gouraud""), Translate.text(""hybrid""), Translate.text(""phong"") }
			), 1, 1, rightLayout);
			 configPanel.add(aliasChoice = new BComboBox(new String [] {
			 Translate.text(""none""), Translate.text(""Edges""), Translate.text(""Everything"") }
			), 1, 2, rightLayout);
			 configPanel.add(sampleChoice = new BComboBox(new String [] {
			""2x2"", ""3x3""}
			), 2, 2, rightLayout);
			 sampleChoice.setEnabled(false);
			 configPanel.add(transparentBox = new BCheckBox(Translate.text(""transparentBackground""), transparentBackground), 0, 3, 3, 1);
			 configPanel.add(Translate.button(""advanced"", this, ""showAdvancedWindow""), 0, 4, 3, 1);
			 smoothField = new ValueField(smoothing, ValueField.NONNEGATIVE);
			 adaptiveBox = new BCheckBox(Translate.text(""reduceAccuracyForDistant""), adaptive);
			 hideBackfaceBox = new BCheckBox(Translate.text(""eliminateBackfaces""), hideBackfaces);
			 hdrBox = new BCheckBox(Translate.text(""generateHDR""), generateHDR);
			 aliasChoice.addEventLink(ValueChangedEvent.class, new Object() {
				 void processEvent() {
					 sampleChoice.setEnabled(aliasChoice.getSelectedIndex() > 0);
				 }
			 }
			);
		 }
		 if (needCopyToUI) copyConfigurationToUI();
		 return configPanel;
	 }
	 private void showAdvancedWindow(WidgetEvent ev) {
		 smoothing = smoothField.getValue();
		 adaptive = adaptiveBox.getState();
		 hideBackfaces = hideBackfaceBox.getState();
		 generateHDR = hdrBox.getState();
		 WindowWidget parent = UIUtilities.findWindow(ev.getWidget());
		 ComponentsDialog dlg = new ComponentsDialog(parent, Translate.text(""advancedOptions""), new Widget [] {
		smoothField, adaptiveBox, hideBackfaceBox, hdrBox}
		, new String [] {
		Translate.text(""texSmoothing""), null, null, null}
		);
		 if (!dlg.clickedOk()) {
			 smoothField.setValue(smoothing);
			 adaptiveBox.setState(adaptive);
			 hideBackfaceBox.setState(hideBackfaces);
			 hdrBox.setState(generateHDR);
		 }
	 }
	 private void copyConfigurationToUI() {
		 needCopyToUI = false;
		 if (configPanel == null) getConfigPanel();
		 smoothField.setValue(smoothing);
		 adaptiveBox.setState(adaptive);
		 hideBackfaceBox.setState(hideBackfaces);
		 hdrBox.setState(generateHDR);
		 errorField.setValue(surfaceError);
		 shadeChoice.setSelectedIndex(shadingMode);
		 transparentBox.setState(transparentBackground);
		 if (samplesPerPixel == 1) {
			 aliasChoice.setSelectedIndex(0);
		 }
		 else if (subsample == 1) {
			 aliasChoice.setSelectedIndex(2);
			 sampleChoice.setSelectedIndex(samplesPerPixel-2);
		 }
		 else {
			 aliasChoice.setSelectedIndex(1);
			 sampleChoice.setSelectedIndex(samplesPerPixel-2);
		 }
		 sampleChoice.setEnabled(aliasChoice.getSelectedIndex() > 0);
	 }
	 public boolean recordConfiguration() {
		 smoothing = smoothField.getValue();
		 adaptive = adaptiveBox.getState();
		 hideBackfaces = hideBackfaceBox.getState();
		 generateHDR = hdrBox.getState();
		 surfaceError = errorField.getValue();
		 shadingMode = shadeChoice.getSelectedIndex();
		 transparentBackground = transparentBox.getState();
		 if (aliasChoice.getSelectedIndex() == 0) samplesPerPixel = subsample = 1;
		 else if (aliasChoice.getSelectedIndex() == 1) samplesPerPixel = subsample = sampleChoice.getSelectedIndex()+2;
		 else {
			 samplesPerPixel = sampleChoice.getSelectedIndex()+2;
			 subsample = 1;
		 }
		 return true;
	 }
	 public Map<String, Object> getConfiguration() {
		 HashMap<String, Object> map = new HashMap<String, Object>();
		 map.put(""textureSmoothing"", smoothing);
		 map.put(""reduceAccuracyForDistant"", adaptive);
		 map.put(""hideBackfaces"", hideBackfaces);
		 map.put(""highDynamicRange"", generateHDR);
		 map.put(""maxSurfaceError"", surfaceError);
		 map.put(""shadingMethod"", shadingMode);
		 map.put(""transparentBackground"", transparentBackground);
		 int antialiasLevel = 0;
		 if (samplesPerPixel == 2) antialiasLevel = subsample;
		 else if (samplesPerPixel == 3) antialiasLevel = (subsample == 1 ? 3 : 4);
		 map.put(""antialiasing"", antialiasLevel);
		 return map;
	 }
	 public void setConfiguration(String property, Object value) {
		 needCopyToUI = true;
		 if (""textureSmoothing"".equals(property)) smoothing = ((Number) value).doubleValue();
		 else if (""reduceAccuracyForDistant"".equals(property)) adaptive = (Boolean) value;
		 else if (""hideBackfaces"".equals(property)) hideBackfaces = (Boolean) value;
		 else if (""highDynamicRange"".equals(property)) generateHDR = (Boolean) value;
		 else if (""maxSurfaceError"".equals(property)) surfaceError = ((Number) value).doubleValue();
		 else if (""shadingMethod"".equals(property)) shadingMode = (Integer) value;
		 else if (""transparentBackground"".equals(property)) transparentBackground = (Boolean) value;
		 else if (""antialiasing"".equals(property)) {
			 int antialiasLevel = (Integer) value;
			 switch (antialiasLevel) {
				 case 0: samplesPerPixel = subsample = 1;
				 break;
				 case 1: samplesPerPixel = 2;
				 subsample = 1;
				 break;
				 case 2: samplesPerPixel = 2;
				 subsample = 2;
				 break;
				 case 3: samplesPerPixel = 3;
				 subsample = 1;
				 break;
				 case 4: samplesPerPixel = 3;
				 subsample = 3;
				 break;
			 }
		 }
	 }
	 public void configurePreview() {
		 if (needCopyToUI) copyConfigurationToUI();
		 transparentBackground = false;
		 smoothing = 1.0;
		 adaptive = hideBackfaces = true;
		 generateHDR = false;
		 surfaceError = 0.02;
		 shadingMode = HYBRID;
		 samplesPerPixel = subsample = 1;
	 }
	 void findLights() {
		 Vector<ObjectInfo> lt = new Vector<ObjectInfo>();
		 int i;
		 positionNeeded = false;
		 for (i = 0;
		 i < theScene.getNumObjects();
		 i++) {
			 ObjectInfo info = theScene.getObject(i);
			 if (info.getObject() instanceof Light && info.isVisible()) lt.addElement(info);
		 }
		 light = new ObjectInfo [lt.size()];
		 for (i = 0;
		 i < light.length;
		 i++) {
			 light[i] = lt.elementAt(i);
			 if (!(light[i].getObject() instanceof DirectionalLight)) positionNeeded = true;
		 }
	 }
	 public void run() {
		 final Thread thisThread = Thread.currentThread();
		 if (renderThread != thisThread) return;
		 updateTime = System.currentTimeMillis();
		 findLights();
		 ambColor = theScene.getAmbientColor();
		 envColor = theScene.getEnvironmentColor();
		 envMapping = theScene.getEnvironmentMapping();
		 envMode = theScene.getEnvironmentMode();
		 fogColor = theScene.getFogColor();
		 fog = theScene.getFogState();
		 fogDist = theScene.getFogDistance();
		 ParameterValue envParam[] = theScene.getEnvironmentParameterValues();
		 envParamValue = new double [envParam.length];
		 for (int i = 0;
		 i < envParamValue.length;
		 i++) envParamValue[i] = envParam[i].getAverageValue();
		 final Vec3 viewdir = theCamera.getViewToWorld().timesDirection(Vec3.vz());
		 Point p = new Point(width/2, height/2);
		 final Vec3 orig = theCamera.getCameraCoordinates().getOrigin();
		 Vec3 center = theCamera.convertScreenToWorld(p, focalDist);
		 p.x++;
		 Vec3 hvec = theCamera.convertScreenToWorld(p, focalDist).minus(center);
		 p.x--;
		 p.y++;
		 Vec3 vvec = theCamera.convertScreenToWorld(p, focalDist).minus(center);
		 p.y--;
		 smoothScale = smoothing*hvec.length()/focalDist;
		 final ObjectInfo sortedObjects[] = sortObjects();
		 ThreadManager threads = new ThreadManager(sortedObjects.length, new ThreadManager.Task() {
			 public void execute(int index) {
				 RasterContext context = (RasterContext) threadRasterContext.get();
				 ObjectInfo obj = sortedObjects[index];
				 context.camera.setObjectTransform(obj.getCoords().fromLocal());
				 renderObject(obj, orig, viewdir, obj.getCoords().toLocal(), context, thisThread);
				 if (thisThread != renderThread) return;
				 if (System.currentTimeMillis()-updateTime > 5000) updateImage();
			 }
			 public void cleanup() {
				 ((RasterContext) threadRasterContext.get()).cleanup();
			 }
		 }
		);
		 threads.run();
		 threads.finish();
		 finish(createFinalImage(center, orig, hvec, vvec));
	 }
	 private ObjectInfo[] sortObjects() {
		 class SortRecord implements Comparable {
			 public ObjectInfo object;
			 public double depth;
			 public boolean isTransparent;
			 SortRecord(ObjectInfo object) {
				 this.object = object;
				 depth = theCamera.getObjectToView().times(object.getBounds().getCenter()).z;
				 if (object.getObject().getTexture() != null) isTransparent = (object.getObject().getTexture().hasComponent(Texture.TRANSPARENT_COLOR_COMPONENT));
			 }
			 public int compareTo(Object o) {
				 SortRecord other = (SortRecord) o;
				 if (isTransparent == other.isTransparent) {
					 if (depth < other.depth) return -1;
					 if (depth == other.depth) return 0;
					 return 1;
				 }
				 if (isTransparent) return 1;
				 return -1;
			 }
		 }
		 ArrayList<SortRecord> objects = new ArrayList<SortRecord>();
		 for (int i = 0;
		 i < theScene.getNumObjects();
		 i++) {
			 ObjectInfo obj = theScene.getObject(i);
			 theCamera.setObjectTransform(obj.getCoords().fromLocal());
			 objects.add(new SortRecord(obj));
		 }
		 Collections.sort(objects);
		 ObjectInfo result[] = new ObjectInfo[objects.size()];
		 for (int i = 0;
		 i < result.length;
		 i++) result[i] = objects.get(i).object;
		 return result;
	 }
	 private synchronized void updateImage() {
		 if (System.currentTimeMillis()-updateTime < 5000) return;
		 RGBColor frontColor = new RGBColor();
		 for (int i1 = 0, i2 = 0;
		 i1 < imageHeight;
		 i1++, i2 += samplesPerPixel) for (int j1 = 0, j2 = 0;
		 j1 < imageWidth;
		 j1++, j2 += samplesPerPixel) {
			 fragment[i2*width+j2].getAdditiveColor(frontColor);
			 imagePixel[i1*imageWidth+j1] = frontColor.getARGB();
		 }
		 imageSource.newPixels();
		 listener.imageUpdated(img);
		 updateTime = System.currentTimeMillis();
	 }
	 private synchronized void updateFinalImage() {
		 if (System.currentTimeMillis()-updateTime < 5000) return;
		 imageSource.newPixels();
		 listener.imageUpdated(img);
		 updateTime = System.currentTimeMillis();
	 }
	 private ComplexImage createFinalImage(final Vec3 center, final Vec3 orig, final Vec3 hvec, final Vec3 vvec) {
		 final Thread thisThread = Thread.currentThread();
		 if (renderThread != thisThread) return null;
		 final int n = samplesPerPixel*samplesPerPixel;
		 final float hdrImage[][] = (generateHDR ? new float[3][imageWidth*imageHeight] : null);
		 ThreadManager threads = new ThreadManager(imageHeight, new ThreadManager.Task() {
			 public void execute(int i1) {
				 CompositingContext context = (CompositingContext) threadCompositingContext.get();
				 Vec3 dir = context.tempVec[1];
				 RGBColor totalColor = context.totalColor;
				 RGBColor totalTransparency = context.totalTransparency;
				 RGBColor addColor = context.addColor;
				 RGBColor multColor = context.multColor;
				 RGBColor subpixelColor = context.subpixelColor;
				 RGBColor subpixelMult = context.subpixelMult;
				 ArrayList<ObjectMaterialInfo> materialStack = context.materialStack;
				 TextureSpec surfSpec = context.surfSpec;
				 int i2 = i1*samplesPerPixel;
				 for (int j1 = 0, j2 = 0;
				 j1 < imageWidth;
				 j1++, j2 += samplesPerPixel) {
					 totalColor.setRGB(0.0f, 0.0f, 0.0f);
					 totalTransparency.setRGB(0.0f, 0.0f, 0.0f);
					 for (int k = 0;
					 k < samplesPerPixel;
					 k++) {
						 int base = width*(i2+k)+j2;
						 for (int m = 0;
						 m < samplesPerPixel;
						 m++) {
							 subpixelColor.setRGB(0.0f, 0.0f, 0.0f);
							 subpixelMult.setRGB(1.0f, 1.0f, 1.0f);
							 Fragment f = fragment[base+m];
							 float lastDepth = 0;
							 while (true) {
								 ObjectMaterialInfo fragmentMaterial = f.getMaterialMapping();
								 ObjectMaterialInfo currentMaterial = null;
								 if (materialStack.size() > 0) currentMaterial = materialStack.get(materialStack.size()-1);
								 adjustColorsForMaterial(currentMaterial, j2+m, i2+k, lastDepth, f.getDepth(), addColor, context.multColor, context);
								 addColor.multiply(subpixelMult);
								 subpixelColor.add(addColor);
								 subpixelMult.multiply(multColor);
								 if (fragmentMaterial != null) {
									 if (f.isEntering()) materialStack.add(fragmentMaterial);
									 else materialStack.remove(fragmentMaterial);
								 }
								 lastDepth = f.getDepth();
								 if (f == BACKGROUND_FRAGMENT) {
									 if (transparentBackground) {
										 addColor.setRGB(0.0f, 0.0f, 0.0f);
									 }
									 else if (envMode == Scene.ENVIRON_SOLID) addColor.copy(envColor);
									 else {
										 double h = j2+k-width/2.0, v = i2+m-height/2.0;
										 dir.x = center.x + h*hvec.x + v*vvec.x;
										 dir.y = center.y + h*hvec.y + v*vvec.y;
										 dir.z = center.z + h*hvec.z + v*vvec.z;
										 dir.subtract(orig);
										 dir.normalize();
										 envMapping.getTextureSpec(dir, surfSpec, 1.0, smoothScale, time, envParamValue);
										 if (envMode == Scene.ENVIRON_DIFFUSE) addColor.copy(surfSpec.diffuse);
										 else addColor.copy(surfSpec.emissive);
									 }
								 }
								 else f.getAdditiveColor(addColor);
								 addColor.multiply(subpixelMult);
								 subpixelColor.add(addColor);
								 if (f.isOpaque()) {
									 if (f != BACKGROUND_FRAGMENT || !transparentBackground) subpixelMult.setRGB(0.0f, 0.0f, 0.0f);
									 break;
								 }
								 f.getMultiplicativeColor(multColor);
								 subpixelMult.multiply(multColor);
								 f = f.getNextFragment();
							 }
							 totalColor.add(subpixelColor);
							 totalTransparency.add(subpixelMult);
							 materialStack.clear();
						 }
					 }
					 totalColor.scale(1.0f/n);
					 totalTransparency.scale(1.0f/n);
					 imagePixel[i1*imageWidth+j1] = calcARGB(totalColor, totalTransparency);
					 if (generateHDR) {
						 hdrImage[0][i1*imageWidth+j1] = totalColor.getRed();
						 hdrImage[1][i1*imageWidth+j1] = totalColor.getGreen();
						 hdrImage[2][i1*imageWidth+j1] = totalColor.getBlue();
					 }
				 }
				 if (renderThread != thisThread) return;
				 if (System.currentTimeMillis()-updateTime > 5000) updateFinalImage();
			 }
			 public void cleanup() {
				 ((CompositingContext) threadCompositingContext.get()).cleanup();
			 }
		 }
		);
		 threads.run();
		 threads.finish();
		 imageSource.newPixels();
		 ComplexImage image = new ComplexImage(img);
		 if (generateHDR) {
			 image.setComponentValues(ComplexImage.RED, hdrImage[0]);
			 image.setComponentValues(ComplexImage.GREEN, hdrImage[1]);
			 image.setComponentValues(ComplexImage.BLUE, hdrImage[2]);
		 }
		 if (depthNeeded) {
			 float imageZbuffer[] = new float [imageWidth*imageHeight];
			 for (int i1 = 0, i2 = 0;
			 i1 < imageHeight;
			 i1++, i2 += samplesPerPixel) for (int j1 = 0, j2 = 0;
			 j1 < imageWidth;
			 j1++, j2 += samplesPerPixel) {
				 float minDepth = Float.MAX_VALUE;
				 for (int k = 0;
				 k < samplesPerPixel;
				 k++) {
					 int base = width*(i2+k)+j2;
					 for (int m = 0;
					 m < samplesPerPixel;
					 m++) {
						 float z = fragment[base+m].getDepth();
						 if (z < minDepth) minDepth = z;
					 }
				 }
				 imageZbuffer[i1*imageWidth+j1] = minDepth;
			 }
			 image.setComponentValues(ComplexImage.DEPTH, imageZbuffer);
		 }
		 return image;
	 }
	 private void adjustColorsForMaterial(ObjectMaterialInfo material, int x, int y, float startDepth, float endDepth, RGBColor addColor, RGBColor multColor, CompositingContext context) {
		 if (material == null) {
			 if (fog) {
				 float fract1 = (float) Math.exp((startDepth-endDepth)/fogDist), fract2 = 1.0f-fract1;
				 multColor.setRGB(fract1, fract1, fract1);
				 addColor.setRGB(fract1*addColor.getRed() + fract2*fogColor.getRed(), fract1*addColor.getGreen() + fract2*fogColor.getGreen(), fract1*addColor.getBlue() + fract2*fogColor.getBlue());
			 }
			 else {
				 addColor.setRGB(0.0f, 0.0f, 0.0f);
				 multColor.setRGB(1.0f, 1.0f, 1.0f);
			 }
			 return;
		 }
		 if (material.getMapping() instanceof UniformMaterialMapping) {
			 material.getMapping().getMaterialSpec(context.tempVec[0], context.matSpec, 0.0, time);
			 RGBColor trans = context.matSpec.transparency, blend = context.matSpec.color;
			 double dist = endDepth-startDepth;
			 float rs = (float) Math.pow(trans.getRed(), dist);
			 float gs = (float) Math.pow(trans.getGreen(), dist);
			 float bs = (float) Math.pow(trans.getBlue(), dist);
			 multColor.setRGB(rs, gs, bs);
			 addColor.setRGB(rs*addColor.getRed() + (1.0f-rs)*blend.getRed(), gs*addColor.getGreen() + (1.0f-gs)*blend.getGreen(), bs*addColor.getBlue() + (1.0f-bs)*blend.getBlue());
			 return;
		 }
		 Vec2 imagePos = new Vec2(x, y);
		 Vec3 startPoint = context.camera.convertScreenToWorld(imagePos, startDepth, false);
		 Vec3 endPoint = context.camera.convertScreenToWorld(imagePos, endDepth, false);
		 double distToPoint = context.camera.getCameraCoordinates().getOrigin().distance(startPoint);
		 material.getToLocal().transform(startPoint);
		 material.getToLocal().transform(endPoint);
		 double dist = startPoint.distance(endPoint);
		 double stepSize = material.getMapping().getStepSize();
		 double distToScreen = context.camera.getDistToScreen();
		 if (distToPoint > distToScreen) stepSize *= distToPoint/distToScreen;
		 int steps = FastMath.ceil(dist/stepSize);
		 stepSize = dist/steps;
		 multColor.setRGB(1.0f, 1.0f, 1.0f);
		 addColor.setRGB(0.0f, 0.0f, 0.0f);
		 for (int i = 0;
		 i < steps;
		 i++) {
			 double fract2 = (0.5+i)/steps, fract1 = 1.0-fract2;
			 context.tempVec[0].set(fract1*startPoint.x+fract2*endPoint.x, fract1*startPoint.y+fract2*endPoint.y, fract1*startPoint.z+fract2*endPoint.z);
			 material.getMapping().getMaterialSpec(context.tempVec[0], context.matSpec, stepSize, time);
			 RGBColor trans = context.matSpec.transparency, blend = context.matSpec.color;
			 float rs = (float) Math.pow(trans.getRed(), stepSize);
			 float gs = (float) Math.pow(trans.getGreen(), stepSize);
			 float bs = (float) Math.pow(trans.getBlue(), stepSize);
			 multColor.multiply(rs, gs, bs);
			 addColor.setRGB(multColor.getRed()*addColor.getRed() + (1.0f-multColor.getRed())*blend.getRed(), multColor.getGreen()*addColor.getGreen() + (1.0f-multColor.getGreen())*blend.getGreen(), multColor.getBlue()*addColor.getBlue() + (1.0f-multColor.getBlue())*blend.getBlue());
			 if (multColor.getMaxComponent() < INTENSITY_CUTOFF) {
				 multColor.setRGB(0.0f, 0.0f, 0.0f);
				 return;
			 }
		 }
	 }
	 private void finish(ComplexImage finalImage) {
		 light = null;
		 theScene = null;
		 theCamera = null;
		 envMapping = null;
		 img = null;
		 imagePixel = null;
		 fragment = null;
		 RenderListener rl = listener;
		 listener = null;
		 renderThread = null;
		 if (rl != null && finalImage != null) rl.imageComplete(finalImage);
	 }
	 private int calcARGB(RGBColor color, RGBColor transparency) {
		 double t = (transparency.getRed()+transparency.getGreen()+transparency.getBlue())/3.0;
		 if (!transparentBackground || t <= 0.0) return color.getARGB();
		 if (t >= 1.0) return 0;
		 double scale = 255.0/(1.0-t);
		 int a, r, g, b;
		 a = (int) (255.0*(1.0-t));
		 r = (int) (color.getRed()*scale);
		 g = (int) (color.getGreen()*scale);
		 b = (int) (color.getBlue()*scale);
		 if (r < 0) r = 0;
		 if (r > 255) r = 255;
		 if (g < 0) g = 0;
		 if (g > 255) g = 255;
		 if (b < 0) b = 0;
		 if (b > 255) b = 255;
		 return (a<<24) + (r<<16) + (g<<8) + b;
	 }
	 private void renderObject(ObjectInfo obj, Vec3 orig, Vec3 viewdir, Mat4 toLocal, RasterContext context, Thread mainThread) {
		 RenderingMesh mesh;
		 Object3D theObject;
		 double tol;
		 int i;
		 if (mainThread != renderThread) return;
		 if (!obj.isVisible()) return;
		 theObject = obj.getObject();
		 if (context.camera.visibility(obj.getBounds()) == Camera.NOT_VISIBLE) return;
		 while (theObject instanceof ObjectWrapper) theObject = ((ObjectWrapper) theObject).getWrappedObject();
		 if (theObject instanceof ObjectCollection) {
			 Enumeration objects = ((ObjectCollection) theObject).getObjects(obj, false, theScene);
			 Mat4 fromLocal = context.camera.getObjectToWorld();
			 while (objects.hasMoreElements()) {
				 ObjectInfo elem = (ObjectInfo) objects.nextElement();
				 CoordinateSystem coords = elem.getCoords().duplicate();
				 coords.transformCoordinates(fromLocal);
				 context.camera.setObjectTransform(coords.fromLocal());
				 renderObject(elem, orig, viewdir, coords.toLocal(), context, mainThread);
			 }
			 return;
		 }
		 if (adaptive) {
			 double dist = obj.getBounds().distanceToPoint(toLocal.times(orig));
			 double distToScreen = context.camera.getDistToScreen();
			 if (dist < distToScreen) tol = surfaceError;
			 else tol = surfaceError*dist/distToScreen;
		 }
		 else tol = surfaceError;
		 mesh = obj.getRenderingMesh(tol);
		 if (mesh == null) return;
		 if (mainThread != renderThread) return;
		 viewdir = toLocal.timesDirection(viewdir);
		 if (context.lightPosition == null) {
			 context.lightPosition = new Vec3 [light.length];
			 context.lightDirection = new Vec3 [light.length];
		 }
		 for (i = light.length-1;
		 i >= 0;
		 i--) {
			 context.lightPosition[i] = toLocal.times(light[i].getCoords().getOrigin());
			 if (!(light[i].getObject() instanceof PointLight)) context.lightDirection[i] = toLocal.timesDirection(light[i].getCoords().getZDirection());
		 }
		 boolean bumpMap = theObject.getTexture().hasComponent(Texture.BUMP_COMPONENT);
		 boolean cullBackfaces = (hideBackfaces && theObject.isClosed() && !theObject.getTexture().hasComponent(Texture.TRANSPARENT_COLOR_COMPONENT));
		 ObjectMaterialInfo material = null;
		 if (theObject.getMaterialMapping() != null) material = new ObjectMaterialInfo(theObject.getMaterialMapping(), toLocal);
		 if (theObject.getTexture().hasComponent(Texture.DISPLACEMENT_COMPONENT)) renderMeshDisplaced(mesh, viewdir, tol, cullBackfaces, bumpMap, material, context);
		 else if (shadingMode == GOURAUD) renderMeshGouraud(mesh, viewdir, cullBackfaces, material, context);
		 else if (shadingMode == HYBRID && !bumpMap) renderMeshHybrid(mesh, viewdir, cullBackfaces, material, context);
		 else renderMeshPhong(mesh, viewdir, cullBackfaces, bumpMap, material, context);
	 }
	 private void calcLight(Vec3 pos, Vec3 norm, Vec3 viewdir, Vec3 faceNorm, double roughness, RGBColor diffuse, RGBColor specular, RGBColor highlight, RasterContext context) {
		 Vec3 reflectDir = context.tempVec[0], lightDir = context.tempVec[1];
		 double viewDot = viewdir.dot(norm), faceDot = viewdir.dot(faceNorm);
		 RGBColor outputColor = context.tempColor[0];
		 if (diffuse != null) diffuse.copy(ambColor);
		 if (highlight != null) highlight.setRGB(0.0f, 0.0f, 0.0f);
		 if (specular != null) {
			 if (envMode == Scene.ENVIRON_SOLID) specular.copy(envColor);
			 else {
				 reflectDir.set(norm);
				 reflectDir.scale(-2.0*viewDot);
				 reflectDir.add(viewdir);
				 context.camera.getViewToWorld().transformDirection(reflectDir);
				 envMapping.getTextureSpec(reflectDir, context.surfSpec2, 1.0, smoothScale, time, envParamValue);
				 if (envMode == Scene.ENVIRON_DIFFUSE) specular.copy(context.surfSpec2.diffuse);
				 else specular.copy(context.surfSpec2.emissive);
			 }
		 }
		 if (viewDot < 0.0 && faceDot > 0.0) viewDot = TOL;
		 else if (viewDot > 0.0 && faceDot < 0.0) viewDot = -TOL;
		 for (int i = light.length-1;
		 i >= 0;
		 i--) {
			 Light lt = (Light) light[i].getObject();
			 Vec3 lightPos = context.lightPosition[i];
			 double distToLight, lightDot;
			 if (lt instanceof PointLight) {
				 lightDir.set(pos);
				 lightDir.subtract(lightPos);
				 distToLight = lightDir.length();
				 lightDir.scale(1.0/distToLight);
			 }
			 else if (lt instanceof SpotLight) {
				 lightDir.set(pos);
				 lightDir.subtract(lightPos);
				 distToLight = lightDir.length();
				 lightDir.scale(1.0/distToLight);
			 }
			 else if (lt instanceof DirectionalLight) lightDir.set(context.lightDirection[i]);
			 lt.getLight(outputColor, light[i].getCoords().toLocal().times(pos));
			 if (lt.getType() == Light.TYPE_AMBIENT) {
				 if (diffuse != null) diffuse.add(outputColor.getRed(), outputColor.getGreen(), outputColor.getBlue());
				 continue;
			 }
			 lightDot = lightDir.dot(norm);
			 if ((lightDot >= 0.0 && viewDot <= 0.0) || (lightDot <= 0.0 && viewDot >= 0.0)) continue;
			 if (diffuse != null) {
				 float dot = (float) (lightDot < 0.0 ? -lightDot : lightDot);
				 diffuse.add(outputColor.getRed()*dot, outputColor.getGreen()*dot, outputColor.getBlue()*dot);
			 }
			 if (highlight != null) {
				 lightDir.add(viewdir);
				 lightDir.normalize();
				 double dot = lightDir.dot(norm);
				 dot = (dot < 0.0 ? -dot : dot);
				 outputColor.scale(FastMath.pow(dot, (int) ((1.0-roughness)*128.0)+1));
				 highlight.add(outputColor);
			 }
		 }
	 }
	 private Fragment createFragment(int addColor, int multColor, float depth, ObjectMaterialInfo material, boolean isBackface) {
		 if (multColor == 0) {
			 return new OpaqueFragment(addColor, depth);
		 }
		 else if (addColor == 0 && multColor == WHITE_ERGB && material == null) return null;
		 else {
			 if (material == null) return new TransparentFragment(addColor, multColor, depth, BACKGROUND_FRAGMENT);
			 return new MaterialFragment(addColor, multColor, depth, BACKGROUND_FRAGMENT, material, !isBackface);
		 }
	 }
	 private void recordRow(int row, int xstart, int xend, RasterContext context) {
		 Fragment source[] = context.fragment;
		 int indexBase = row*width;
		 synchronized (lock[row]) {
			 for (int x = xstart;
			 x < xend;
			 x++) {
				 Fragment f = source[x];
				 if (f == null) continue;
				 int index = indexBase+x;
				 Fragment current = fragment[index];
				 if (f.getDepth() < current.getDepth()) fragment[index] = f.insertNextFragment(current);
				 else fragment[index] = current.insertNextFragment(f);
			 }
		 }
	 }
	 private Vec3 [] clipTriangle(Vec3 v1, Vec3 v2, Vec3 v3, float z1, float z2, float z3, float newz[], double newu[], double newv[], RasterContext context) {
		 double clip = context.camera.getClipDistance();
		 boolean c1 = z1 < clip, c2 = z2 < clip, c3 = z3 < clip;
		 Vec3 u1, u2, u3, u4;
		 int clipCount = 0;
		 if (c1) clipCount++;
		 if (c2) clipCount++;
		 if (c3) clipCount++;
		 if (clipCount == 2) {
			 if (!c1) {
				 u1 = v1;
				 newz[0] = z1;
				 newu[0] = 1.0;
				 newv[0] = 0.0;
				 double f2 = (z1-clip)/(z1-z2), f1 = 1.0-f2;
				 u2 = new Vec3(f1*v1.x+f2*v2.x, f1*v1.y+f2*v2.y, f1*v1.z+f2*v2.z);
				 newz[1] = (float) (f1*z1 + f2*z2);
				 newu[1] = f1;
				 newv[1] = f2;
				 f2 = (z1-clip)/(z1-z3);
				 f1 = 1.0-f2;
				 u3 = new Vec3(f1*v1.x+f2*v3.x, f1*v1.y+f2*v3.y, f1*v1.z+f2*v3.z);
				 newz[2] = (float) (f1*z1 + f2*z3);
				 newu[2] = f1;
				 newv[2] = 0.0;
			 }
			 else if (!c2) {
				 u2 = v2;
				 newz[1] = z2;
				 newu[1] = 0.0;
				 newv[1] = 1.0;
				 double f2 = (z2-clip)/(z2-z3), f1 = 1.0-f2;
				 u3 = new Vec3(f1*v2.x+f2*v3.x, f1*v2.y+f2*v3.y, f1*v2.z+f2*v3.z);
				 newz[2] = (float) (f1*z2 + f2*z3);
				 newu[2] = 0.0;
				 newv[2] = f1;
				 f2 = (z2-clip)/(z2-z1);
				 f1 = 1.0-f2;
				 u1 = new Vec3(f1*v2.x+f2*v1.x, f1*v2.y+f2*v1.y, f1*v2.z+f2*v1.z);
				 newz[0] = (float) (f1*z2 + f2*z1);
				 newu[0] = f2;
				 newv[0] = f1;
			 }
			 else {
				 u3 = v3;
				 newz[2] = z3;
				 newu[2] = 0.0;
				 newv[2] = 0.0;
				 double f2 = (z3-clip)/(z3-z1), f1 = 1.0-f2;
				 u1 = new Vec3(f1*v3.x+f2*v1.x, f1*v3.y+f2*v1.y, f1*v3.z+f2*v1.z);
				 newz[0] = (float) (f1*z3 + f2*z1);
				 newu[0] = f2;
				 newv[0] = 0.0;
				 f2 = (z3-clip)/(z3-z2);
				 f1 = 1.0-f2;
				 u2 = new Vec3(f1*v3.x+f2*v2.x, f1*v3.y+f2*v2.y, f1*v3.z+f2*v2.z);
				 newz[1] = (float) (f1*z3 + f2*z2);
				 newu[1] = 0.0;
				 newv[1] = f2;
			 }
			 return new Vec3 [] {
			u1, u2, u3}
			;
		 }
		 if (c1) {
			 u1 = v2;
			 newz[0] = z2;
			 newu[0] = 0.0;
			 newv[0] = 1.0;
			 u2 = v3;
			 newz[1] = z3;
			 newu[1] = 0.0;
			 newv[1] = 0.0;
			 double f1 = (z2-clip)/(z2-z1), f2 = 1.0-f1;
			 u3 = new Vec3(f1*v1.x+f2*v2.x, f1*v1.y+f2*v2.y, f1*v1.z+f2*v2.z);
			 newz[2] = (float) (f1*z1 + f2*z2);
			 newu[2] = f1;
			 newv[2] = f2;
			 f1 = (z3-clip)/(z3-z1);
			 f2 = 1.0-f1;
			 u4 = new Vec3(f1*v1.x+f2*v3.x, f1*v1.y+f2*v3.y, f1*v1.z+f2*v3.z);
			 newz[3] = (float) (f1*z1 + f2*z3);
			 newu[3] = f1;
			 newv[3] = 0.0;
		 }
		 else if (c2) {
			 u1 = v3;
			 newz[0] = z3;
			 newu[0] = 0.0;
			 newv[0] = 0.0;
			 u2 = v1;
			 newz[1] = z1;
			 newu[1] = 1.0;
			 newv[1] = 0.0;
			 double f1 = (z3-clip)/(z3-z2), f2 = 1.0-f1;
			 u3 = new Vec3(f1*v2.x+f2*v3.x, f1*v2.y+f2*v3.y, f1*v2.z+f2*v3.z);
			 newz[2] = (float) (f1*z2 + f2*z3);
			 newu[2] = 0.0;
			 newv[2] = f1;
			 f1 = (z1-clip)/(z1-z2);
			 f2 = 1.0-f1;
			 u4 = new Vec3(f1*v2.x+f2*v1.x, f1*v2.y+f2*v1.y, f1*v2.z+f2*v1.z);
			 newz[3] = (float) (f1*z2 + f2*z1);
			 newu[3] = f2;
			 newv[3] = f1;
		 }
		 else {
			 u1 = v1;
			 newz[0] = z1;
			 newu[0] = 1.0;
			 newv[0] = 0.0;
			 u2 = v2;
			 newz[1] = z2;
			 newu[1] = 0.0;
			 newv[1] = 1.0;
			 double f1 = (z1-clip)/(z1-z3), f2 = 1.0-f1;
			 u3 = new Vec3(f1*v3.x+f2*v1.x, f1*v3.y+f2*v1.y, f1*v3.z+f2*v1.z);
			 newz[2] = (float) (f1*z3 + f2*z1);
			 newu[2] = f2;
			 newv[2] = 0.0;
			 f1 = (z2-clip)/(z2-z3);
			 f2 = 1.0-f1;
			 u4 = new Vec3(f1*v3.x+f2*v2.x, f1*v3.y+f2*v2.y, f1*v3.z+f2*v2.z);
			 newz[3] = (float) (f1*z3 + f2*z2);
			 newu[3] = 0.0;
			 newv[3] = f2;
		 }
		 return new Vec3 [] {
		u1, u2, u3, u4}
		;
	 }
	 private void renderMeshGouraud(RenderingMesh mesh, Vec3 viewdir, boolean cullBackfaces, ObjectMaterialInfo material, RasterContext context) {
		 Vec3 vert[] = mesh.vert, norm[] = mesh.norm;
		 Vec2 pos[] = new Vec2 [vert.length];
		 float z[] = new float [vert.length], clip = (float) context.camera.getClipDistance(), clipz[] = new float [4];
		 double clipu[] = new double [4], clipv[] = new double [4];
		 double distToScreen = context.camera.getDistToScreen(), tol = smoothScale;
		 RGBColor diffuse[] = new RGBColor [4], specular[] = new RGBColor [4], highlight[] = new RGBColor [4];
		 Mat4 toView = context.camera.getObjectToView(), toScreen = context.camera.getObjectToScreen();
		 RenderingTriangle tri;
		 int i, v1, v2, v3, n1, n2, n3;
		 boolean backface;
		 for (i = 0;
		 i < 4;
		 i++) {
			 diffuse[i] = new RGBColor();
			 specular[i] = new RGBColor();
			 highlight[i] = new RGBColor();
		 }
		 for (i = vert.length-1;
		 i >= 0;
		 i--) {
			 pos[i] = toScreen.timesXY(vert[i]);
			 z[i] = (float) toView.timesZ(vert[i]);
		 }
		 for (i = mesh.triangle.length-1;
		 i >= 0;
		 i--) {
			 tri = mesh.triangle[i];
			 v1 = tri.v1;
			 v2 = tri.v2;
			 v3 = tri.v3;
			 n1 = tri.n1;
			 n2 = tri.n2;
			 n3 = tri.n3;
			 if (z[v1] < clip && z[v2] < clip && z[v3] < clip) continue;
			 backface = ((pos[v2].x-pos[v1].x)*(pos[v3].y-pos[v1].y) - (pos[v2].y-pos[v1].y)*(pos[v3].x-pos[v1].x) > 0.0);
			 double viewdot = viewdir.dot(mesh.faceNorm[i]);
			 if (z[v1] < clip || z[v2] < clip || z[v3] < clip) {
				 Vec3 clipPos[] = clipTriangle(vert[v1], vert[v2], vert[v3], z[v1], z[v2], z[v3], clipz, clipu, clipv, context);
				 Vec2 clipPos2D[] = new Vec2 [clipPos.length];
				 for (int j = clipPos.length-1;
				 j >= 0;
				 j--) {
					 clipPos2D[j] = toScreen.timesXY(clipPos[j]);
					 double u = clipu[j], v = clipv[j], w = 1.0-u-v;
					 tri.getTextureSpec(context.surfSpec, viewdot, u, v, 1.0-u-v, tol, time);
					 context.tempVec[2].set(norm[n1].x*u + norm[n2].x*v + norm[n3].x*w, norm[n1].y*u + norm[n2].y*v + norm[n3].y*w, norm[n1].z*u + norm[n2].z*v + norm[n3].z*w);
					 context.tempVec[2].normalize();
					 calcLight(clipPos[j], context.tempVec[2], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[j], specular[j], highlight[j], context);
					 specular[j].add(highlight[j]);
				 }
				 renderTriangleGouraud(clipPos2D[0], clipz[0], clipu[0], clipv[0], diffuse[0], specular[0], clipPos2D[1], clipz[1], clipu[1], clipv[1], diffuse[1], specular[1], clipPos2D[2], clipz[2], clipu[2], clipv[2], diffuse[2], specular[2], tri, clip, viewdot, backface, material, context);
				 if (clipPos.length == 4) renderTriangleGouraud(clipPos2D[1], clipz[1], clipu[1], clipv[1], diffuse[1], specular[1], clipPos2D[2], clipz[2], clipu[2], clipv[2], diffuse[2], specular[2], clipPos2D[3], clipz[3], clipu[3], clipv[3], diffuse[3], specular[3], tri, clip, viewdot, backface, material, context);
			 }
			 else {
				 if (cullBackfaces && backface) continue;
				 if (z[v1] > distToScreen) tol = smoothScale*z[v1];
				 tri.getTextureSpec(context.surfSpec, viewdot, 1.0, 0.0, 0.0, tol, time);
				 calcLight(vert[v1], norm[n1], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[0], specular[0], highlight[0], context);
				 specular[0].add(highlight[0]);
				 if (z[v2] > distToScreen) tol = smoothScale*z[v2];
				 tri.getTextureSpec(context.surfSpec, viewdot, 0.0, 1.0, 0.0, tol, time);
				 calcLight(vert[v2], norm[n2], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[1], specular[1], highlight[1], context);
				 specular[1].add(highlight[1]);
				 if (z[v3] > distToScreen) tol = smoothScale*z[v3];
				 tri.getTextureSpec(context.surfSpec, viewdot, 0.0, 0.0, 1.0, tol, time);
				 calcLight(vert[v3], norm[n3], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[2], specular[2], highlight[2], context);
				 specular[2].add(highlight[2]);
				 renderTriangleGouraud(pos[v1], z[v1], 1.0, 0.0, diffuse[0], specular[0], pos[v2], z[v2], 0.0, 1.0, diffuse[1], specular[1], pos[v3], z[v3], 0.0, 0.0, diffuse[2], specular[2], tri, clip, viewdot, backface, material, context);
			 }
		 }
	 }
	 private void renderTriangleGouraud(Vec2 pos1, float zf1, double uf1, double vf1, RGBColor diffuse1, RGBColor specular1, Vec2 pos2, float zf2, double uf2, double vf2, RGBColor diffuse2, RGBColor specular2, Vec2 pos3, float zf3, double uf3, double vf3, RGBColor diffuse3, RGBColor specular3, RenderingTriangle tri, double clip, double viewdot, boolean isBackface, ObjectMaterialInfo material, RasterContext context) {
		 double x1, x2, x3, y1, y2, y3;
		 double dx1, dx2, dy1, dy2, mx1, mx2;
		 double xstart, xend;
		 float z1, z2, z3, dz1, dz2, mz1, mz2, zstart, zend, z, zl, dz;
		 double u1, u2, u3, v1, v2, v3, du1, du2, dv1, dv2, mu1, mu2, mv1, mv2;
		 double ustart, uend, vstart, vend, u, v, ul, vl, wl, du, dv;
		 RGBColor dif1, dif2, dif3, spec1, spec2, spec3;
		 float ddifred1, ddifred2, ddifgreen1, ddifgreen2, ddifblue1, ddifblue2;
		 float mdifred1, mdifred2, mdifgreen1, mdifgreen2, mdifblue1, mdifblue2;
		 float dspecred1, dspecred2, dspecgreen1, dspecgreen2, dspecblue1, dspecblue2;
		 float mspecred1, mspecred2, mspecgreen1, mspecgreen2, mspecblue1, mspecblue2;
		 float difredstart, difredend, difgreenstart, difgreenend, difbluestart, difblueend;
		 float specredstart, specredend, specgreenstart, specgreenend, specbluestart, specblueend;
		 float difred, difgreen, difblue, ddifred, ddifgreen, ddifblue;
		 float specred, specgreen, specblue, dspecred, dspecgreen, dspecblue;
		 float denom;
		 int left, right, i, index, yend, y, lastAddColor = 0, lastMultColor = 0;
		 boolean doSubsample = (subsample > 1), repeat;
		 TextureSpec surfSpec = context.surfSpec;
		 if (pos1.y <= pos2.y && pos1.y <= pos3.y) {
			 x1 = pos1.x;
			 y1 = pos1.y;
			 z1 = zf1;
			 u1 = uf1;
			 v1 = vf1;
			 dif1 = diffuse1;
			 spec1 = specular1;
			 if (pos2.y < pos3.y) {
				 x2 = pos2.x;
				 y2 = pos2.y;
				 z2 = zf2;
				 u2 = uf2;
				 v2 = vf2;
				 dif2 = diffuse2;
				 spec2 = specular2;
				 x3 = pos3.x;
				 y3 = pos3.y;
				 z3 = zf3;
				 u3 = uf3;
				 v3 = vf3;
				 dif3 = diffuse3;
				 spec3 = specular3;
			 }
			 else {
				 x2 = pos3.x;
				 y2 = pos3.y;
				 z2 = zf3;
				 u2 = uf3;
				 v2 = vf3;
				 dif2 = diffuse3;
				 spec2 = specular3;
				 x3 = pos2.x;
				 y3 = pos2.y;
				 z3 = zf2;
				 u3 = uf2;
				 v3 = vf2;
				 dif3 = diffuse2;
				 spec3 = specular2;
			 }
		 }
		 else if (pos2.y <= pos1.y && pos2.y <= pos3.y) {
			 x1 = pos2.x;
			 y1 = pos2.y;
			 z1 = zf2;
			 u1 = uf2;
			 v1 = vf2;
			 dif1 = diffuse2;
			 spec1 = specular2;
			 if (pos1.y < pos3.y) {
				 x2 = pos1.x;
				 y2 = pos1.y;
				 z2 = zf1;
				 u2 = uf1;
				 v2 = vf1;
				 dif2 = diffuse1;
				 spec2 = specular1;
				 x3 = pos3.x;
				 y3 = pos3.y;
				 z3 = zf3;
				 u3 = uf3;
				 v3 = vf3;
				 dif3 = diffuse3;
				 spec3 = specular3;
			 }
			 else {
				 x2 = pos3.x;
				 y2 = pos3.y;
				 z2 = zf3;
				 u2 = uf3;
				 v2 = vf3;
				 dif2 = diffuse3;
				 spec2 = specular3;
				 x3 = pos1.x;
				 y3 = pos1.y;
				 z3 = zf1;
				 u3 = uf1;
				 v3 = vf1;
				 dif3 = diffuse1;
				 spec3 = specular1;
			 }
		 }
		 else {
			 x1 = pos3.x;
			 y1 = pos3.y;
			 z1 = zf3;
			 u1 = uf3;
			 v1 = vf3;
			 dif1 = diffuse3;
			 spec1 = specular3;
			 if (pos1.y < pos2.y) {
				 x2 = pos1.x;
				 y2 = pos1.y;
				 z2 = zf1;
				 u2 = uf1;
				 v2 = vf1;
				 dif2 = diffuse1;
				 spec2 = specular1;
				 x3 = pos2.x;
				 y3 = pos2.y;
				 z3 = zf2;
				 u3 = uf2;
				 v3 = vf2;
				 dif3 = diffuse2;
				 spec3 = specular2;
			 }
			 else {
				 x2 = pos2.x;
				 y2 = pos2.y;
				 z2 = zf2;
				 u2 = uf2;
				 v2 = vf2;
				 dif2 = diffuse2;
				 spec2 = specular2;
				 x3 = pos1.x;
				 y3 = pos1.y;
				 z3 = zf1;
				 u3 = uf1;
				 v3 = vf1;
				 dif3 = diffuse1;
				 spec3 = specular1;
			 }
		 }
		 x1 = FastMath.round(x1);
		 y1 = FastMath.round(y1);
		 x2 = FastMath.round(x2);
		 y2 = FastMath.round(y2);
		 x3 = FastMath.round(x3);
		 y3 = FastMath.round(y3);
		 z1 = 1.0f/z1;
		 u1 *= z1;
		 v1 *= z1;
		 z2 = 1.0f/z2;
		 u2 *= z2;
		 v2 *= z2;
		 z3 = 1.0f/z3;
		 u3 *= z3;
		 v3 *= z3;
		 dx1 = x3-x1;
		 dy1 = y3-y1;
		 dz1 = z3-z1;
		 if (dy1 == 0) return;
		 du1 = u3-u1;
		 dv1 = v3-v1;
		 ddifred1 = dif3.getRed()-dif1.getRed();
		 ddifgreen1 = dif3.getGreen()-dif1.getGreen();
		 ddifblue1 = dif3.getBlue()-dif1.getBlue();
		 dspecred1 = spec3.getRed()-spec1.getRed();
		 dspecgreen1 = spec3.getGreen()-spec1.getGreen();
		 dspecblue1 = spec3.getBlue()-spec1.getBlue();
		 dx2 = x2-x1;
		 dy2 = y2-y1;
		 dz2 = z2-z1;
		 du2 = u2-u1;
		 dv2 = v2-v1;
		 ddifred2 = dif2.getRed()-dif1.getRed();
		 ddifgreen2 = dif2.getGreen()-dif1.getGreen();
		 ddifblue2 = dif2.getBlue()-dif1.getBlue();
		 dspecred2 = spec2.getRed()-spec1.getRed();
		 dspecgreen2 = spec2.getGreen()-spec1.getGreen();
		 dspecblue2 = spec2.getBlue()-spec1.getBlue();
		 denom = (float) (1.0/dy1);
		 mx1 = dx1*denom;
		 mz1 = dz1*denom;
		 mu1 = du1*denom;
		 mv1 = dv1*denom;
		 mdifred1 = ddifred1*denom;
		 mdifgreen1 = ddifgreen1*denom;
		 mdifblue1 = ddifblue1*denom;
		 mspecred1 = dspecred1*denom;
		 mspecgreen1 = dspecgreen1*denom;
		 mspecblue1 = dspecblue1*denom;
		 xstart = xend = x1;
		 zstart = zend = z1;
		 ustart = uend = u1;
		 vstart = vend = v1;
		 difredstart = difredend = dif1.getRed();
		 difgreenstart = difgreenend = dif1.getGreen();
		 difbluestart = difblueend = dif1.getBlue();
		 specredstart = specredend = spec1.getRed();
		 specgreenstart = specgreenend = spec1.getGreen();
		 specbluestart = specblueend = spec1.getBlue();
		 y = FastMath.round(y1);
		 if (dy2 > 0.0) {
			 denom = (float) (1.0/dy2);
			 mx2 = dx2*denom;
			 mz2 = dz2*denom;
			 mu2 = du2*denom;
			 mv2 = dv2*denom;
			 mdifred2 = ddifred2*denom;
			 mdifgreen2 = ddifgreen2*denom;
			 mdifblue2 = ddifblue2*denom;
			 mspecred2 = dspecred2*denom;
			 mspecgreen2 = dspecgreen2*denom;
			 mspecblue2 = dspecblue2*denom;
			 if (y2 < 0) {
				 xstart += mx1*dy2;
				 xend += mx2*dy2;
				 zstart += mz1*dy2;
				 zend += mz2*dy2;
				 ustart += mu1*dy2;
				 uend += mu2*dy2;
				 vstart += mv1*dy2;
				 vend += mv2*dy2;
				 difredstart += mdifred1*dy2;
				 difredend += mdifred2*dy2;
				 difgreenstart += mdifgreen1*dy2;
				 difgreenend += mdifgreen2*dy2;
				 difbluestart += mdifblue1*dy2;
				 difblueend += mdifblue2*dy2;
				 specredstart += mspecred1*dy2;
				 specredend += mspecred2*dy2;
				 specgreenstart += mspecgreen1*dy2;
				 specgreenend += mspecgreen2*dy2;
				 specbluestart += mspecblue1*dy2;
				 specblueend += mspecblue2*dy2;
				 y = FastMath.round(y2);
			 }
			 else if (y < 0) {
				 xstart -= mx1*y;
				 xend -= mx2*y;
				 zstart -= mz1*y;
				 zend -= mz2*y;
				 ustart -= mu1*y;
				 uend -= mu2*y;
				 vstart -= mv1*y;
				 vend -= mv2*y;
				 difredstart -= mdifred1*y;
				 difredend -= mdifred2*y;
				 difgreenstart -= mdifgreen1*y;
				 difgreenend -= mdifgreen2*y;
				 difbluestart -= mdifblue1*y;
				 difblueend -= mdifblue2*y;
				 specredstart -= mspecred1*y;
				 specredend -= mspecred2*y;
				 specgreenstart -= mspecgreen1*y;
				 specgreenend -= mspecgreen2*y;
				 specbluestart -= mspecblue1*y;
				 specblueend -= mspecblue2*y;
				 y = 0;
			 }
			 yend = FastMath.round(y2);
			 if (yend > height) yend = height;
			 index = y*width;
			 while (y < yend) {
				 if (xstart < xend) {
					 left = FastMath.round(xstart);
					 right = FastMath.round(xend);
					 z = zstart;
					 dz = zend-zstart;
					 u = ustart;
					 du = uend-ustart;
					 v = vstart;
					 dv = vend-vstart;
					 difred = difredstart;
					 ddifred = difredend-difredstart;
					 difgreen = difgreenstart;
					 ddifgreen = difgreenend-difgreenstart;
					 difblue = difbluestart;
					 ddifblue = difblueend-difbluestart;
					 specred = specredstart;
					 dspecred = specredend-specredstart;
					 specgreen = specgreenstart;
					 dspecgreen = specgreenend-specgreenstart;
					 specblue = specbluestart;
					 dspecblue = specblueend-specbluestart;
				 }
				 else {
					 left = FastMath.round(xend);
					 right = FastMath.round(xstart);
					 z = zend;
					 dz = zstart-zend;
					 u = uend;
					 du = ustart-uend;
					 v = vend;
					 dv = vstart-vend;
					 difred = difredend;
					 ddifred = difredstart-difredend;
					 difgreen = difgreenend;
					 ddifgreen = difgreenstart-difgreenend;
					 difblue = difblueend;
					 ddifblue = difbluestart-difblueend;
					 specred = specredend;
					 dspecred = specredstart-specredend;
					 specgreen = specgreenend;
					 dspecgreen = specgreenstart-specgreenend;
					 specblue = specblueend;
					 dspecblue = specbluestart-specblueend;
				 }
				 if (left != right) {
					 if (xend == xstart) denom = 1.0f;
					 else if (xend > xstart) denom = (float) (1.0/(xend-xstart));
					 else denom = (float) (1.0/(xstart-xend));
					 dz *= denom;
					 du *= denom;
					 dv *= denom;
					 ddifred *= denom;
					 ddifgreen *= denom;
					 ddifblue *= denom;
					 dspecred *= denom;
					 dspecgreen *= denom;
					 dspecblue *= denom;
					 if (left < 0) {
						 z -= dz*left;
						 u -= du*left;
						 v -= dv*left;
						 difred -= ddifred*left;
						 difgreen -= ddifgreen*left;
						 difblue -= ddifblue*left;
						 specred -= dspecred*left;
						 specgreen -= dspecgreen*left;
						 specblue -= dspecblue*left;
						 left = 0;
					 }
					 if (right > width) right = width;
					 repeat = false;
					 for (i = left;
					 i < right;
					 i++) {
						 zl = 1.0f/z;
						 if (zl < fragment[index+i].getOpaqueDepth() && zl > clip) {
							 if (!repeat || (i%subsample == 0)) {
								 ul = u*zl;
								 vl = v*zl;
								 wl = 1.0-ul-vl;
								 tri.getTextureSpec(surfSpec, viewdot, ul, vl, wl, smoothScale*z, time);
								 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*difred + surfSpec.hilight.getRed()*specred + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*difgreen + surfSpec.hilight.getGreen()*specgreen + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*difblue + surfSpec.hilight.getBlue()*specblue + surfSpec.emissive.getBlue());
								 lastAddColor = context.tempColor[0].getERGB();
								 lastMultColor = surfSpec.transparent.getERGB();
							 }
							 context.fragment[i] = createFragment(lastAddColor, lastMultColor, zl, material, isBackface);
							 repeat = doSubsample;
						 }
						 else {
							 context.fragment[i] = null;
							 repeat = false;
						 }
						 z += dz;
						 u += du;
						 v += dv;
						 difred += ddifred;
						 difgreen += ddifgreen;
						 difblue += ddifblue;
						 specred += dspecred;
						 specgreen += dspecgreen;
						 specblue += dspecblue;
					 }
					 recordRow(y, left, right, context);
				 }
				 xstart += mx1;
				 zstart += mz1;
				 ustart += mu1;
				 vstart += mv1;
				 difredstart += mdifred1;
				 difgreenstart += mdifgreen1;
				 difbluestart += mdifblue1;
				 specredstart += mspecred1;
				 specgreenstart += mspecgreen1;
				 specbluestart += mspecblue1;
				 xend += mx2;
				 zend += mz2;
				 uend += mu2;
				 vend += mv2;
				 difredend += mdifred2;
				 difgreenend += mdifgreen2;
				 difblueend += mdifblue2;
				 specredend += mspecred2;
				 specgreenend += mspecgreen2;
				 specblueend += mspecblue2;
				 index += width;
				 y++;
			 }
		 }
		 dx2 = x3-x2;
		 dy2 = y3-y2;
		 dz2 = z3-z2;
		 du2 = u3-u2;
		 dv2 = v3-v2;
		 ddifred2 = dif3.getRed()-dif2.getRed();
		 ddifgreen2 = dif3.getGreen()-dif2.getGreen();
		 ddifblue2 = dif3.getBlue()-dif2.getBlue();
		 dspecred2 = spec3.getRed()-spec2.getRed();
		 dspecgreen2 = spec3.getGreen()-spec2.getGreen();
		 dspecblue2 = spec3.getBlue()-spec2.getBlue();
		 if (dy2 > 0.0) {
			 denom = (float) (1.0/dy2);
			 mx2 = dx2*denom;
			 mz2 = dz2*denom;
			 mu2 = du2*denom;
			 mv2 = dv2*denom;
			 mdifred2 = ddifred2*denom;
			 mdifgreen2 = ddifgreen2*denom;
			 mdifblue2 = ddifblue2*denom;
			 mspecred2 = dspecred2*denom;
			 mspecgreen2 = dspecgreen2*denom;
			 mspecblue2 = dspecblue2*denom;
			 xend = x2;
			 zend = z2;
			 uend = u2;
			 vend = v2;
			 difredend = dif2.getRed();
			 difgreenend = dif2.getGreen();
			 difblueend = dif2.getBlue();
			 specredend = spec2.getRed();
			 specgreenend = spec2.getGreen();
			 specblueend = spec2.getBlue();
			 if (y < 0) {
				 xstart -= mx1*y;
				 xend -= mx2*y;
				 zstart -= mz1*y;
				 zend -= mz2*y;
				 ustart -= mu1*y;
				 uend -= mu2*y;
				 vstart -= mv1*y;
				 vend -= mv2*y;
				 difredstart -= mdifred1*y;
				 difredend -= mdifred2*y;
				 difgreenstart -= mdifgreen1*y;
				 difgreenend -= mdifgreen2*y;
				 difbluestart -= mdifblue1*y;
				 difblueend -= mdifblue2*y;
				 specredstart -= mspecred1*y;
				 specredend -= mspecred2*y;
				 specgreenstart -= mspecgreen1*y;
				 specgreenend -= mspecgreen2*y;
				 specbluestart -= mspecblue1*y;
				 specblueend -= mspecblue2*y;
				 y = 0;
			 }
			 yend = FastMath.round(y3 < height ? y3 : height);
			 index = y*width;
			 while (y < yend) {
				 if (xstart < xend) {
					 left = FastMath.round(xstart);
					 right = FastMath.round(xend);
					 z = zstart;
					 dz = zend-zstart;
					 u = ustart;
					 du = uend-ustart;
					 v = vstart;
					 dv = vend-vstart;
					 difred = difredstart;
					 ddifred = difredend-difredstart;
					 difgreen = difgreenstart;
					 ddifgreen = difgreenend-difgreenstart;
					 difblue = difbluestart;
					 ddifblue = difblueend-difbluestart;
					 specred = specredstart;
					 dspecred = specredend-specredstart;
					 specgreen = specgreenstart;
					 dspecgreen = specgreenend-specgreenstart;
					 specblue = specbluestart;
					 dspecblue = specblueend-specbluestart;
				 }
				 else {
					 left = FastMath.round(xend);
					 right = FastMath.round(xstart);
					 z = zend;
					 dz = zstart-zend;
					 u = uend;
					 du = ustart-uend;
					 v = vend;
					 dv = vstart-vend;
					 difred = difredend;
					 ddifred = difredstart-difredend;
					 difgreen = difgreenend;
					 ddifgreen = difgreenstart-difgreenend;
					 difblue = difblueend;
					 ddifblue = difbluestart-difblueend;
					 specred = specredend;
					 dspecred = specredstart-specredend;
					 specgreen = specgreenend;
					 dspecgreen = specgreenstart-specgreenend;
					 specblue = specblueend;
					 dspecblue = specbluestart-specblueend;
				 }
				 if (left != right) {
					 if (xend == xstart) denom = 1.0f;
					 else if (xend > xstart) denom = (float) (1.0/(xend-xstart));
					 else denom = (float) (1.0/(xstart-xend));
					 dz *= denom;
					 du *= denom;
					 dv *= denom;
					 ddifred *= denom;
					 ddifgreen *= denom;
					 ddifblue *= denom;
					 dspecred *= denom;
					 dspecgreen *= denom;
					 dspecblue *= denom;
					 if (left < 0) {
						 z -= dz*left;
						 u -= du*left;
						 v -= dv*left;
						 difred -= ddifred*left;
						 difgreen -= ddifgreen*left;
						 difblue -= ddifblue*left;
						 specred -= dspecred*left;
						 specgreen -= dspecgreen*left;
						 specblue -= dspecblue*left;
						 left = 0;
					 }
					 if (right > width) right = width;
					 repeat = false;
					 for (i = left;
					 i < right;
					 i++) {
						 zl = 1.0f/z;
						 if (zl < fragment[index+i].getOpaqueDepth() && zl > clip) {
							 if (!repeat || (i%subsample == 0)) {
								 ul = u*zl;
								 vl = v*zl;
								 wl = 1.0-ul-vl;
								 tri.getTextureSpec(surfSpec, viewdot, ul, vl, wl, smoothScale*z, time);
								 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*difred + surfSpec.hilight.getRed()*specred + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*difgreen + surfSpec.hilight.getGreen()*specgreen + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*difblue + surfSpec.hilight.getBlue()*specblue + surfSpec.emissive.getBlue());
								 lastAddColor = context.tempColor[0].getERGB();
								 lastMultColor = surfSpec.transparent.getERGB();
							 }
							 context.fragment[i] = createFragment(lastAddColor, lastMultColor, zl, material, isBackface);
							 repeat = doSubsample;
						 }
						 else {
							 context.fragment[i] = null;
							 repeat = false;
						 }
						 z += dz;
						 u += du;
						 v += dv;
						 difred += ddifred;
						 difgreen += ddifgreen;
						 difblue += ddifblue;
						 specred += dspecred;
						 specgreen += dspecgreen;
						 specblue += dspecblue;
					 }
					 recordRow(y, left, right, context);
				 }
				 xstart += mx1;
				 zstart += mz1;
				 ustart += mu1;
				 vstart += mv1;
				 difredstart += mdifred1;
				 difgreenstart += mdifgreen1;
				 difbluestart += mdifblue1;
				 specredstart += mspecred1;
				 specgreenstart += mspecgreen1;
				 specbluestart += mspecblue1;
				 xend += mx2;
				 zend += mz2;
				 uend += mu2;
				 vend += mv2;
				 difredend += mdifred2;
				 difgreenend += mdifgreen2;
				 difblueend += mdifblue2;
				 specredend += mspecred2;
				 specgreenend += mspecgreen2;
				 specblueend += mspecblue2;
				 index += width;
				 y++;
			 }
		 }
	 }
	 private void renderMeshHybrid(RenderingMesh mesh, Vec3 viewdir, boolean cullBackfaces, ObjectMaterialInfo material, RasterContext context) {
		 Vec3 vert[] = mesh.vert, norm[] = mesh.norm, clipNorm[] = new Vec3 [4];
		 Vec2 pos[] = new Vec2 [vert.length];
		 float z[] = new float [vert.length], clip = (float) context.camera.getClipDistance(), clipz[] = new float [4];
		 double clipu[] = new double [4], clipv[] = new double [4];
		 double distToScreen = context.camera.getDistToScreen(), tol = smoothScale;
		 RGBColor diffuse[] = new RGBColor [4];
		 Mat4 toView = context.camera.getObjectToView(), toScreen = context.camera.getObjectToScreen();
		 RenderingTriangle tri;
		 int i, v1, v2, v3, n1, n2, n3;
		 boolean backface;
		 for (i = 0;
		 i < 4;
		 i++) {
			 diffuse[i] = new RGBColor();
			 clipNorm[i] = new Vec3();
		 }
		 for (i = vert.length-1;
		 i >= 0;
		 i--) {
			 pos[i] = toScreen.timesXY(vert[i]);
			 z[i] = (float) toView.timesZ(vert[i]);
		 }
		 for (i = mesh.triangle.length-1;
		 i >= 0;
		 i--) {
			 tri = mesh.triangle[i];
			 v1 = tri.v1;
			 v2 = tri.v2;
			 v3 = tri.v3;
			 n1 = tri.n1;
			 n2 = tri.n2;
			 n3 = tri.n3;
			 if (z[v1] < clip && z[v2] < clip && z[v3] < clip) continue;
			 backface = ((pos[v2].x-pos[v1].x)*(pos[v3].y-pos[v1].y) - (pos[v2].y-pos[v1].y)*(pos[v3].x-pos[v1].x) > 0.0);
			 double viewdot = viewdir.dot(mesh.faceNorm[i]);
			 if (z[v1] < clip || z[v2] < clip || z[v3] < clip) {
				 Vec3 clipPos[] = clipTriangle(vert[v1], vert[v2], vert[v3], z[v1], z[v2], z[v3], clipz, clipu, clipv, context);
				 Vec2 clipPos2D[] = new Vec2 [clipPos.length];
				 for (int j = clipPos.length-1;
				 j >= 0;
				 j--) {
					 clipPos2D[j] = toScreen.timesXY(clipPos[j]);
					 double u = clipu[j], v = clipv[j], w = 1.0-u-v;
					 tri.getTextureSpec(context.surfSpec, viewdot, u, v, 1.0-u-v, tol, time);
					 clipNorm[j].set(norm[n1].x*u + norm[n2].x*v + norm[n3].x*w, norm[n1].y*u + norm[n2].y*v + norm[n3].y*w, norm[n1].z*u + norm[n2].z*v + norm[n3].z*w);
					 clipNorm[j].normalize();
					 calcLight(clipPos[j], context.tempVec[2], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[j], null, null, context);
				 }
				 renderTriangleHybrid(clipPos2D[0], clipz[0], clipPos[0], clipNorm[0], clipu[0], clipv[0], diffuse[0], clipPos2D[1], clipz[1], clipPos[1], clipNorm[1], clipu[1], clipv[1], diffuse[1], clipPos2D[2], clipz[2], clipPos[2], clipNorm[2], clipu[2], clipv[2], diffuse[2], tri, viewdir, mesh.faceNorm[i], clip, viewdot, backface, material, context);
				 if (clipPos.length == 4) renderTriangleHybrid(clipPos2D[1], clipz[1], clipPos[1], clipNorm[1], clipu[1], clipv[1], diffuse[1], clipPos2D[2], clipz[2], clipPos[2], clipNorm[2], clipu[2], clipv[2], diffuse[2], clipPos2D[3], clipz[3], clipPos[3], clipNorm[3], clipu[3], clipv[3], diffuse[3], tri, viewdir, mesh.faceNorm[i], clip, viewdot, backface, material, context);
			 }
			 else {
				 if (cullBackfaces && backface) continue;
				 if (z[v1] > distToScreen) tol = smoothScale*z[v1];
				 tri.getTextureSpec(context.surfSpec, viewdot, 1.0, 0.0, 0.0, tol, time);
				 calcLight(vert[v1], norm[n1], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[0], null, null, context);
				 if (z[v2] > distToScreen) tol = smoothScale*z[v2];
				 tri.getTextureSpec(context.surfSpec, viewdot, 0.0, 1.0, 0.0, tol, time);
				 calcLight(vert[v2], norm[n2], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[1], null, null, context);
				 if (z[v3] > distToScreen) tol = smoothScale*z[v3];
				 tri.getTextureSpec(context.surfSpec, viewdot, 0.0, 0.0, 1.0, tol, time);
				 calcLight(vert[v3], norm[n3], viewdir, mesh.faceNorm[i], context.surfSpec.roughness, diffuse[2], null, null, context);
				 renderTriangleHybrid(pos[v1], z[v1], vert[v1], norm[n1], 1.0, 0.0, diffuse[0], pos[v2], z[v2], vert[v2], norm[n2], 0.0, 1.0, diffuse[1], pos[v3], z[v3], vert[v3], norm[n3], 0.0, 0.0, diffuse[2], tri, viewdir, mesh.faceNorm[i], clip, viewdot, backface, material, context);
			 }
		 }
	 }
	 private void renderTriangleHybrid(Vec2 pos1, float zf1, Vec3 vert1, Vec3 normf1, double uf1, double vf1, RGBColor diffuse1, Vec2 pos2, float zf2, Vec3 vert2, Vec3 normf2, double uf2, double vf2, RGBColor diffuse2, Vec2 pos3, float zf3, Vec3 vert3, Vec3 normf3, double uf3, double vf3, RGBColor diffuse3, RenderingTriangle tri, Vec3 viewdir, Vec3 faceNorm, double clip, double viewdot, boolean isBackface, ObjectMaterialInfo material, RasterContext context) {
		 double x1, x2, x3, y1, y2, y3;
		 double dx1, dx2, dy1, dy2, mx1, mx2;
		 double xstart, xend;
		 float z1, z2, z3, dz1, dz2, mz1, mz2, zstart, zend, z, zl, dz;
		 double u1, u2, u3, v1, v2, v3, du1, du2, dv1, dv2, mu1, mu2, mv1, mv2;
		 double ustart, uend, vstart, vend, u, v, ul, vl, wl, du, dv;
		 RGBColor dif1, dif2, dif3, specular = context.tempColor[1], highlight = context.tempColor[2];
		 Vec3 norm1, norm2, norm3;
		 float ddifred1, ddifred2, ddifgreen1, ddifgreen2, ddifblue1, ddifblue2;
		 float mdifred1, mdifred2, mdifgreen1, mdifgreen2, mdifblue1, mdifblue2;
		 double dnormx1, dnormx2, dnormy1, dnormy2, dnormz1, dnormz2;
		 double mnormx1, mnormx2, mnormy1, mnormy2, mnormz1, mnormz2;
		 float difredstart, difredend, difgreenstart, difgreenend, difbluestart, difblueend;
		 double normxstart, normxend, normystart, normyend, normzstart, normzend;
		 float difred, difgreen, difblue, ddifred, ddifgreen, ddifblue;
		 double normx, normy, normz, dnormx, dnormy, dnormz;
		 float denom;
		 int left, right, i, index, yend, y, lastAddColor = 0, lastMultColor = 0;
		 boolean doSubsample = (subsample > 1), repeat;
		 TextureSpec surfSpec = context.surfSpec;
		 if (pos1.y <= pos2.y && pos1.y <= pos3.y) {
			 x1 = pos1.x;
			 y1 = pos1.y;
			 z1 = zf1;
			 u1 = uf1;
			 v1 = vf1;
			 dif1 = diffuse1;
			 norm1 = normf1;
			 if (pos2.y < pos3.y) {
				 x2 = pos2.x;
				 y2 = pos2.y;
				 z2 = zf2;
				 u2 = uf2;
				 v2 = vf2;
				 dif2 = diffuse2;
				 norm2 = normf2;
				 x3 = pos3.x;
				 y3 = pos3.y;
				 z3 = zf3;
				 u3 = uf3;
				 v3 = vf3;
				 dif3 = diffuse3;
				 norm3 = normf3;
			 }
			 else {
				 x2 = pos3.x;
				 y2 = pos3.y;
				 z2 = zf3;
				 u2 = uf3;
				 v2 = vf3;
				 dif2 = diffuse3;
				 norm2 = normf3;
				 x3 = pos2.x;
				 y3 = pos2.y;
				 z3 = zf2;
				 u3 = uf2;
				 v3 = vf2;
				 dif3 = diffuse2;
				 norm3 = normf2;
			 }
		 }
		 else if (pos2.y <= pos1.y && pos2.y <= pos3.y) {
			 x1 = pos2.x;
			 y1 = pos2.y;
			 z1 = zf2;
			 u1 = uf2;
			 v1 = vf2;
			 dif1 = diffuse2;
			 norm1 = normf2;
			 if (pos1.y < pos3.y) {
				 x2 = pos1.x;
				 y2 = pos1.y;
				 z2 = zf1;
				 u2 = uf1;
				 v2 = vf1;
				 dif2 = diffuse1;
				 norm2 = normf1;
				 x3 = pos3.x;
				 y3 = pos3.y;
				 z3 = zf3;
				 u3 = uf3;
				 v3 = vf3;
				 dif3 = diffuse3;
				 norm3 = normf3;
			 }
			 else {
				 x2 = pos3.x;
				 y2 = pos3.y;
				 z2 = zf3;
				 u2 = uf3;
				 v2 = vf3;
				 dif2 = diffuse3;
				 norm2 = normf3;
				 x3 = pos1.x;
				 y3 = pos1.y;
				 z3 = zf1;
				 u3 = uf1;
				 v3 = vf1;
				 dif3 = diffuse1;
				 norm3 = normf1;
			 }
		 }
		 else {
			 x1 = pos3.x;
			 y1 = pos3.y;
			 z1 = zf3;
			 u1 = uf3;
			 v1 = vf3;
			 dif1 = diffuse3;
			 norm1 = normf3;
			 if (pos1.y < pos2.y) {
				 x2 = pos1.x;
				 y2 = pos1.y;
				 z2 = zf1;
				 u2 = uf1;
				 v2 = vf1;
				 dif2 = diffuse1;
				 norm2 = normf1;
				 x3 = pos2.x;
				 y3 = pos2.y;
				 z3 = zf2;
				 u3 = uf2;
				 v3 = vf2;
				 dif3 = diffuse2;
				 norm3 = normf2;
			 }
			 else {
				 x2 = pos2.x;
				 y2 = pos2.y;
				 z2 = zf2;
				 u2 = uf2;
				 v2 = vf2;
				 dif2 = diffuse2;
				 norm2 = normf2;
				 x3 = pos1.x;
				 y3 = pos1.y;
				 z3 = zf1;
				 u3 = uf1;
				 v3 = vf1;
				 dif3 = diffuse1;
				 norm3 = normf1;
			 }
		 }
		 x1 = FastMath.round(x1);
		 y1 = FastMath.round(y1);
		 x2 = FastMath.round(x2);
		 y2 = FastMath.round(y2);
		 x3 = FastMath.round(x3);
		 y3 = FastMath.round(y3);
		 z1 = 1.0f/z1;
		 u1 *= z1;
		 v1 *= z1;
		 z2 = 1.0f/z2;
		 u2 *= z2;
		 v2 *= z2;
		 z3 = 1.0f/z3;
		 u3 *= z3;
		 v3 *= z3;
		 dx1 = x3-x1;
		 dy1 = y3-y1;
		 dz1 = z3-z1;
		 if (dy1 == 0) return;
		 du1 = u3-u1;
		 dv1 = v3-v1;
		 ddifred1 = dif3.getRed()-dif1.getRed();
		 ddifgreen1 = dif3.getGreen()-dif1.getGreen();
		 ddifblue1 = dif3.getBlue()-dif1.getBlue();
		 dnormx1 = norm3.x-norm1.x;
		 dnormy1 = norm3.y-norm1.y;
		 dnormz1 = norm3.z-norm1.z;
		 dx2 = x2-x1;
		 dy2 = y2-y1;
		 dz2 = z2-z1;
		 du2 = u2-u1;
		 dv2 = v2-v1;
		 ddifred2 = dif2.getRed()-dif1.getRed();
		 ddifgreen2 = dif2.getGreen()-dif1.getGreen();
		 ddifblue2 = dif2.getBlue()-dif1.getBlue();
		 dnormx2 = norm2.x-norm1.x;
		 dnormy2 = norm2.y-norm1.y;
		 dnormz2 = norm2.z-norm1.z;
		 denom = (float) (1.0/dy1);
		 mx1 = dx1*denom;
		 mz1 = dz1*denom;
		 mu1 = du1*denom;
		 mv1 = dv1*denom;
		 mdifred1 = ddifred1*denom;
		 mdifgreen1 = ddifgreen1*denom;
		 mdifblue1 = ddifblue1*denom;
		 mnormx1 = dnormx1*denom;
		 mnormy1 = dnormy1*denom;
		 mnormz1 = dnormz1*denom;
		 xstart = xend = x1;
		 zstart = zend = z1;
		 ustart = uend = u1;
		 vstart = vend = v1;
		 difredstart = difredend = dif1.getRed();
		 difgreenstart = difgreenend = dif1.getGreen();
		 difbluestart = difblueend = dif1.getBlue();
		 normxstart = normxend = norm1.x;
		 normystart = normyend = norm1.y;
		 normzstart = normzend = norm1.z;
		 y = FastMath.round(y1);
		 if (dy2 > 0.0) {
			 denom = (float) (1.0/dy2);
			 mx2 = dx2*denom;
			 mz2 = dz2*denom;
			 mu2 = du2*denom;
			 mv2 = dv2*denom;
			 mdifred2 = ddifred2*denom;
			 mdifgreen2 = ddifgreen2*denom;
			 mdifblue2 = ddifblue2*denom;
			 mnormx2 = dnormx2*denom;
			 mnormy2 = dnormy2*denom;
			 mnormz2 = dnormz2*denom;
			 if (y2 < 0) {
				 xstart += mx1*dy2;
				 xend += mx2*dy2;
				 zstart += mz1*dy2;
				 zend += mz2*dy2;
				 ustart += mu1*dy2;
				 uend += mu2*dy2;
				 vstart += mv1*dy2;
				 vend += mv2*dy2;
				 difredstart += mdifred1*dy2;
				 difredend += mdifred2*dy2;
				 difgreenstart += mdifgreen1*dy2;
				 difgreenend += mdifgreen2*dy2;
				 difbluestart += mdifblue1*dy2;
				 difblueend += mdifblue2*dy2;
				 normxstart += mnormx1*dy2;
				 normxend += mnormx2*dy2;
				 normystart += mnormy1*dy2;
				 normyend += mnormy2*dy2;
				 normzstart += mnormz1*dy2;
				 normzend += mnormz2*dy2;
				 y = FastMath.round(y2);
			 }
			 else if (y < 0) {
				 xstart -= mx1*y;
				 xend -= mx2*y;
				 zstart -= mz1*y;
				 zend -= mz2*y;
				 ustart -= mu1*y;
				 uend -= mu2*y;
				 vstart -= mv1*y;
				 vend -= mv2*y;
				 difredstart -= mdifred1*y;
				 difredend -= mdifred2*y;
				 difgreenstart -= mdifgreen1*y;
				 difgreenend -= mdifgreen2*y;
				 difbluestart -= mdifblue1*y;
				 difblueend -= mdifblue2*y;
				 normxstart -= mnormx1*y;
				 normxend -= mnormx2*y;
				 normystart -= mnormy1*y;
				 normyend -= mnormy2*y;
				 normzstart -= mnormz1*y;
				 normzend -= mnormz2*y;
				 y = 0;
			 }
			 yend = FastMath.round(y2);
			 if (yend > height) yend = height;
			 index = y*width;
			 while (y < yend) {
				 if (xstart < xend) {
					 left = FastMath.round(xstart);
					 right = FastMath.round(xend);
					 z = zstart;
					 dz = zend-zstart;
					 u = ustart;
					 du = uend-ustart;
					 v = vstart;
					 dv = vend-vstart;
					 difred = difredstart;
					 ddifred = difredend-difredstart;
					 difgreen = difgreenstart;
					 ddifgreen = difgreenend-difgreenstart;
					 difblue = difbluestart;
					 ddifblue = difblueend-difbluestart;
					 normx = normxstart;
					 dnormx = normxend-normxstart;
					 normy = normystart;
					 dnormy = normyend-normystart;
					 normz = normzstart;
					 dnormz = normzend-normzstart;
				 }
				 else {
					 left = FastMath.round(xend);
					 right = FastMath.round(xstart);
					 z = zend;
					 dz = zstart-zend;
					 u = uend;
					 du = ustart-uend;
					 v = vend;
					 dv = vstart-vend;
					 difred = difredend;
					 ddifred = difredstart-difredend;
					 difgreen = difgreenend;
					 ddifgreen = difgreenstart-difgreenend;
					 difblue = difblueend;
					 ddifblue = difbluestart-difblueend;
					 normx = normxend;
					 dnormx = normxstart-normxend;
					 normy = normyend;
					 dnormy = normystart-normyend;
					 normz = normzend;
					 dnormz = normzstart-normzend;
				 }
				 if (left != right) {
					 if (xend == xstart) denom = 1.0f;
					 else if (xend > xstart) denom = (float) (1.0/(xend-xstart));
					 else denom = (float) (1.0/(xstart-xend));
					 dz *= denom;
					 du *= denom;
					 dv *= denom;
					 ddifred *= denom;
					 ddifgreen *= denom;
					 ddifblue *= denom;
					 dnormx *= denom;
					 dnormy *= denom;
					 dnormz *= denom;
					 if (left < 0) {
						 z -= dz*left;
						 u -= du*left;
						 v -= dv*left;
						 difred -= ddifred*left;
						 difgreen -= ddifgreen*left;
						 difblue -= ddifblue*left;
						 normx -= dnormx*left;
						 normy -= dnormy*left;
						 normz -= dnormz*left;
						 left = 0;
					 }
					 if (right > width) right = width;
					 repeat = false;
					 for (i = left;
					 i < right;
					 i++) {
						 zl = 1.0f/z;
						 if (zl < fragment[index+i].getOpaqueDepth() && zl > clip) {
							 if (!repeat || (i%subsample == 0)) {
								 ul = u*zl;
								 vl = v*zl;
								 wl = 1.0-ul-vl;
								 tri.getTextureSpec(surfSpec, viewdot, ul, vl, wl, smoothScale*z, time);
								 if (surfSpec.hilight.getRed() == 0.0f && surfSpec.hilight.getGreen() == 0.0f && surfSpec.hilight.getBlue() == 0.0f && surfSpec.specular.getRed() == 0.0f && surfSpec.specular.getGreen() == 0.0f && surfSpec.specular.getBlue() == 0.0f) context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*difred + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*difgreen + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*difblue + surfSpec.emissive.getBlue());
								 else {
									 if (positionNeeded) context.tempVec[2].set(ul*vert1.x+vl*vert2.x+wl*vert3.x, ul*vert1.y+vl*vert2.y+wl*vert3.y, ul*vert1.z+vl*vert2.z+wl*vert3.z);
									 context.tempVec[3].set(normx, normy, normz);
									 context.tempVec[3].normalize();
									 calcLight(context.tempVec[2], context.tempVec[3], viewdir, faceNorm, surfSpec.roughness, null, specular, highlight, context);
									 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*difred + surfSpec.hilight.getRed()*highlight.getRed() + surfSpec.specular.getRed()*specular.getRed() + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*difgreen + surfSpec.hilight.getGreen()*highlight.getGreen() + surfSpec.specular.getGreen()*specular.getGreen() + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*difblue + surfSpec.hilight.getBlue()*highlight.getBlue() + surfSpec.specular.getBlue()*specular.getBlue() + surfSpec.emissive.getBlue());
								 }
								 lastAddColor = context.tempColor[0].getERGB();
								 lastMultColor = surfSpec.transparent.getERGB();
							 }
							 context.fragment[i] = createFragment(lastAddColor, lastMultColor, zl, material, isBackface);
							 repeat = doSubsample;
						 }
						 else {
							 context.fragment[i] = null;
							 repeat = false;
						 }
						 z += dz;
						 u += du;
						 v += dv;
						 difred += ddifred;
						 difgreen += ddifgreen;
						 difblue += ddifblue;
						 normx += dnormx;
						 normy += dnormy;
						 normz += dnormz;
					 }
					 recordRow(y, left, right, context);
				 }
				 xstart += mx1;
				 zstart += mz1;
				 ustart += mu1;
				 vstart += mv1;
				 difredstart += mdifred1;
				 difgreenstart += mdifgreen1;
				 difbluestart += mdifblue1;
				 normxstart += mnormx1;
				 normystart += mnormy1;
				 normzstart += mnormz1;
				 xend += mx2;
				 zend += mz2;
				 uend += mu2;
				 vend += mv2;
				 difredend += mdifred2;
				 difgreenend += mdifgreen2;
				 difblueend += mdifblue2;
				 normxend += mnormx2;
				 normyend += mnormy2;
				 normzend += mnormz2;
				 index += width;
				 y++;
			 }
		 }
		 dx2 = x3-x2;
		 dy2 = y3-y2;
		 dz2 = z3-z2;
		 du2 = u3-u2;
		 dv2 = v3-v2;
		 ddifred2 = dif3.getRed()-dif2.getRed();
		 ddifgreen2 = dif3.getGreen()-dif2.getGreen();
		 ddifblue2 = dif3.getBlue()-dif2.getBlue();
		 dnormx2 = norm3.x-norm2.x;
		 dnormy2 = norm3.y-norm2.y;
		 dnormz2 = norm3.z-norm2.z;
		 if (dy2 > 0.0) {
			 denom = (float) (1.0/dy2);
			 mx2 = dx2*denom;
			 mz2 = dz2*denom;
			 mu2 = du2*denom;
			 mv2 = dv2*denom;
			 mdifred2 = ddifred2*denom;
			 mdifgreen2 = ddifgreen2*denom;
			 mdifblue2 = ddifblue2*denom;
			 mnormx2 = dnormx2*denom;
			 mnormy2 = dnormy2*denom;
			 mnormz2 = dnormz2*denom;
			 xend = x2;
			 zend = z2;
			 uend = u2;
			 vend = v2;
			 difredend = dif2.getRed();
			 difgreenend = dif2.getGreen();
			 difblueend = dif2.getBlue();
			 normxend = norm2.x;
			 normyend = norm2.y;
			 normzend = norm2.z;
			 if (y < 0) {
				 xstart -= mx1*y;
				 xend -= mx2*y;
				 zstart -= mz1*y;
				 zend -= mz2*y;
				 ustart -= mu1*y;
				 uend -= mu2*y;
				 vstart -= mv1*y;
				 vend -= mv2*y;
				 difredstart -= mdifred1*y;
				 difredend -= mdifred2*y;
				 difgreenstart -= mdifgreen1*y;
				 difgreenend -= mdifgreen2*y;
				 difbluestart -= mdifblue1*y;
				 difblueend -= mdifblue2*y;
				 normxstart -= mnormx1*y;
				 normxend -= mnormx2*y;
				 normystart -= mnormy1*y;
				 normyend -= mnormy2*y;
				 normzstart -= mnormz1*y;
				 normzend -= mnormz2*y;
				 y = 0;
			 }
			 yend = FastMath.round(y3 < height ? y3 : height);
			 index = y*width;
			 while (y < yend) {
				 if (xstart < xend) {
					 left = FastMath.round(xstart);
					 right = FastMath.round(xend);
					 z = zstart;
					 dz = zend-zstart;
					 u = ustart;
					 du = uend-ustart;
					 v = vstart;
					 dv = vend-vstart;
					 difred = difredstart;
					 ddifred = difredend-difredstart;
					 difgreen = difgreenstart;
					 ddifgreen = difgreenend-difgreenstart;
					 difblue = difbluestart;
					 ddifblue = difblueend-difbluestart;
					 normx = normxstart;
					 dnormx = normxend-normxstart;
					 normy = normystart;
					 dnormy = normyend-normystart;
					 normz = normzstart;
					 dnormz = normzend-normzstart;
				 }
				 else {
					 left = FastMath.round(xend);
					 right = FastMath.round(xstart);
					 z = zend;
					 dz = zstart-zend;
					 u = uend;
					 du = ustart-uend;
					 v = vend;
					 dv = vstart-vend;
					 difred = difredend;
					 ddifred = difredstart-difredend;
					 difgreen = difgreenend;
					 ddifgreen = difgreenstart-difgreenend;
					 difblue = difblueend;
					 ddifblue = difbluestart-difblueend;
					 normx = normxend;
					 dnormx = normxstart-normxend;
					 normy = normyend;
					 dnormy = normystart-normyend;
					 normz = normzend;
					 dnormz = normzstart-normzend;
				 }
				 if (left != right) {
					 if (xend == xstart) denom = 1.0f;
					 else if (xend > xstart) denom = (float) (1.0/(xend-xstart));
					 else denom = (float) (1.0/(xstart-xend));
					 dz *= denom;
					 du *= denom;
					 dv *= denom;
					 ddifred *= denom;
					 ddifgreen *= denom;
					 ddifblue *= denom;
					 dnormx *= denom;
					 dnormy *= denom;
					 dnormz *= denom;
					 if (left < 0) {
						 z -= dz*left;
						 u -= du*left;
						 v -= dv*left;
						 difred -= ddifred*left;
						 difgreen -= ddifgreen*left;
						 difblue -= ddifblue*left;
						 normx -= dnormx*left;
						 normy -= dnormy*left;
						 normz -= dnormz*left;
						 left = 0;
					 }
					 if (right > width) right = width;
					 repeat = false;
					 for (i = left;
					 i < right;
					 i++) {
						 zl = 1.0f/z;
						 if (zl < fragment[index+i].getOpaqueDepth() && zl > clip) {
							 if (!repeat || (i%subsample == 0)) {
								 ul = u*zl;
								 vl = v*zl;
								 wl = 1.0-ul-vl;
								 tri.getTextureSpec(surfSpec, viewdot, ul, vl, wl, smoothScale*z, time);
								 if (surfSpec.hilight.getRed() == 0.0f && surfSpec.hilight.getGreen() == 0.0f && surfSpec.hilight.getBlue() == 0.0f && surfSpec.specular.getRed() == 0.0f && surfSpec.specular.getGreen() == 0.0f && surfSpec.specular.getBlue() == 0.0f) context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*difred + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*difgreen + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*difblue + surfSpec.emissive.getBlue());
								 else {
									 if (positionNeeded) context.tempVec[2].set(ul*vert1.x+vl*vert2.x+wl*vert3.x, ul*vert1.y+vl*vert2.y+wl*vert3.y, ul*vert1.z+vl*vert2.z+wl*vert3.z);
									 context.tempVec[3].set(normx, normy, normz);
									 context.tempVec[3].normalize();
									 calcLight(context.tempVec[2], context.tempVec[3], viewdir, faceNorm, surfSpec.roughness, null, specular, highlight, context);
									 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*difred + surfSpec.hilight.getRed()*highlight.getRed() + surfSpec.specular.getRed()*specular.getRed() + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*difgreen + surfSpec.hilight.getGreen()*highlight.getGreen() + surfSpec.specular.getGreen()*specular.getGreen() + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*difblue + surfSpec.hilight.getBlue()*highlight.getBlue() + surfSpec.specular.getBlue()*specular.getBlue() + surfSpec.emissive.getBlue());
								 }
								 lastAddColor = context.tempColor[0].getERGB();
								 lastMultColor = surfSpec.transparent.getERGB();
							 }
							 context.fragment[i] = createFragment(lastAddColor, lastMultColor, zl, material, isBackface);
							 repeat = doSubsample;
						 }
						 else {
							 context.fragment[i] = null;
							 repeat = false;
						 }
						 z += dz;
						 u += du;
						 v += dv;
						 difred += ddifred;
						 difgreen += ddifgreen;
						 difblue += ddifblue;
						 normx += dnormx;
						 normy += dnormy;
						 normz += dnormz;
					 }
					 recordRow(y, left, right, context);
				 }
				 xstart += mx1;
				 zstart += mz1;
				 ustart += mu1;
				 vstart += mv1;
				 difredstart += mdifred1;
				 difgreenstart += mdifgreen1;
				 difbluestart += mdifblue1;
				 normxstart += mnormx1;
				 normystart += mnormy1;
				 normzstart += mnormz1;
				 xend += mx2;
				 zend += mz2;
				 uend += mu2;
				 vend += mv2;
				 difredend += mdifred2;
				 difgreenend += mdifgreen2;
				 difblueend += mdifblue2;
				 normxend += mnormx2;
				 normyend += mnormy2;
				 normzend += mnormz2;
				 index += width;
				 y++;
			 }
		 }
	 }
	 private void renderMeshPhong(RenderingMesh mesh, Vec3 viewdir, boolean cullBackfaces, boolean bumpMap, ObjectMaterialInfo material, RasterContext context) {
		 Vec3 vert[] = mesh.vert, norm[] = mesh.norm, clipNorm[] = new Vec3 [4];
		 Vec2 pos[] = new Vec2 [vert.length];
		 float z[] = new float [vert.length], clip = (float) context.camera.getClipDistance(), clipz[] = new float [4];
		 double clipu[] = new double [4], clipv[] = new double [4];
		 Mat4 toView = context.camera.getObjectToView(), toScreen = context.camera.getObjectToScreen();
		 RenderingTriangle tri;
		 int i, v1, v2, v3, n1, n2, n3;
		 boolean backface;
		 for (i = 0;
		 i < 4;
		 i++) clipNorm[i] = new Vec3();
		 for (i = vert.length-1;
		 i >= 0;
		 i--) {
			 pos[i] = toScreen.timesXY(vert[i]);
			 z[i] = (float) toView.timesZ(vert[i]);
		 }
		 for (i = mesh.triangle.length-1;
		 i >= 0;
		 i--) {
			 tri = mesh.triangle[i];
			 v1 = tri.v1;
			 v2 = tri.v2;
			 v3 = tri.v3;
			 n1 = tri.n1;
			 n2 = tri.n2;
			 n3 = tri.n3;
			 if (z[v1] < clip && z[v2] < clip && z[v3] < clip) continue;
			 backface = ((pos[v2].x-pos[v1].x)*(pos[v3].y-pos[v1].y) - (pos[v2].y-pos[v1].y)*(pos[v3].x-pos[v1].x) > 0.0);
			 if (z[v1] < clip || z[v2] < clip || z[v3] < clip) {
				 Vec3 clipPos[] = clipTriangle(vert[v1], vert[v2], vert[v3], z[v1], z[v2], z[v3], clipz, clipu, clipv, context);
				 Vec2 clipPos2D[] = new Vec2 [clipPos.length];
				 for (int j = clipPos.length-1;
				 j >= 0;
				 j--) {
					 clipPos2D[j] = toScreen.timesXY(clipPos[j]);
					 double u = clipu[j], v = clipv[j], w = 1.0-u-v;
					 clipNorm[j].set(norm[n1].x*u + norm[n2].x*v + norm[n3].x*w, norm[n1].y*u + norm[n2].y*v + norm[n3].y*w, norm[n1].z*u + norm[n2].z*v + norm[n3].z*w);
					 clipNorm[j].normalize();
				 }
				 renderTrianglePhong(clipPos2D[0], clipz[0], clipPos[0], clipNorm[0], clipu[0], clipv[0], clipPos2D[1], clipz[1], clipPos[1], clipNorm[1], clipu[1], clipv[1], clipPos2D[2], clipz[2], clipPos[2], clipNorm[2], clipu[2], clipv[2], tri, viewdir, mesh.faceNorm[i], clip, bumpMap, backface, material, context);
				 if (clipPos.length == 4) renderTrianglePhong(clipPos2D[1], clipz[1], clipPos[1], clipNorm[1], clipu[1], clipv[1], clipPos2D[2], clipz[2], clipPos[2], clipNorm[2], clipu[2], clipv[2], clipPos2D[3], clipz[3], clipPos[3], clipNorm[3], clipu[3], clipv[3], tri, viewdir, mesh.faceNorm[i], clip, bumpMap, backface, material, context);
			 }
			 else {
				 if (cullBackfaces && backface) continue;
				 renderTrianglePhong(pos[v1], z[v1], vert[v1], norm[n1], 1.0, 0.0, pos[v2], z[v2], vert[v2], norm[n2], 0.0, 1.0, pos[v3], z[v3], vert[v3], norm[n3], 0.0, 0.0, tri, viewdir, mesh.faceNorm[i], clip, bumpMap, backface, material, context);
			 }
		 }
	 }
	 private void renderTrianglePhong(Vec2 pos1, float zf1, Vec3 vert1, Vec3 normf1, double uf1, double vf1, Vec2 pos2, float zf2, Vec3 vert2, Vec3 normf2, double uf2, double vf2, Vec2 pos3, float zf3, Vec3 vert3, Vec3 normf3, double uf3, double vf3, RenderingTriangle tri, Vec3 viewdir, Vec3 faceNorm, double clip, boolean bumpMap, boolean isBackface, ObjectMaterialInfo material, RasterContext context) {
		 double x1, x2, x3, y1, y2, y3;
		 double dx1, dx2, dy1, dy2, mx1, mx2;
		 double xstart, xend;
		 float z1, z2, z3, dz1, dz2, mz1, mz2, zstart, zend, z, zl, dz;
		 double u1, u2, u3, v1, v2, v3, du1, du2, dv1, dv2, mu1, mu2, mv1, mv2;
		 double ustart, uend, vstart, vend, u, v, ul, vl, wl, du, dv;
		 RGBColor diffuse = context.tempColor[1], specular = context.tempColor[2], highlight = context.tempColor[3];
		 Vec3 norm1, norm2, norm3, normal = context.tempVec[3];
		 double dnormx1, dnormx2, dnormy1, dnormy2, dnormz1, dnormz2;
		 double mnormx1, mnormx2, mnormy1, mnormy2, mnormz1, mnormz2;
		 double normxstart, normxend, normystart, normyend, normzstart, normzend;
		 double normx, normy, normz, dnormx, dnormy, dnormz;
		 float denom;
		 int left, right, i, index, yend, y, lastAddColor = 0, lastMultColor = 0;
		 boolean doSubsample = (subsample > 1), repeat;
		 TextureSpec surfSpec = context.surfSpec;
		 if (pos1.y <= pos2.y && pos1.y <= pos3.y) {
			 x1 = pos1.x;
			 y1 = pos1.y;
			 z1 = zf1;
			 u1 = uf1;
			 v1 = vf1;
			 norm1 = normf1;
			 if (pos2.y < pos3.y) {
				 x2 = pos2.x;
				 y2 = pos2.y;
				 z2 = zf2;
				 u2 = uf2;
				 v2 = vf2;
				 norm2 = normf2;
				 x3 = pos3.x;
				 y3 = pos3.y;
				 z3 = zf3;
				 u3 = uf3;
				 v3 = vf3;
				 norm3 = normf3;
			 }
			 else {
				 x2 = pos3.x;
				 y2 = pos3.y;
				 z2 = zf3;
				 u2 = uf3;
				 v2 = vf3;
				 norm2 = normf3;
				 x3 = pos2.x;
				 y3 = pos2.y;
				 z3 = zf2;
				 u3 = uf2;
				 v3 = vf2;
				 norm3 = normf2;
			 }
		 }
		 else if (pos2.y <= pos1.y && pos2.y <= pos3.y) {
			 x1 = pos2.x;
			 y1 = pos2.y;
			 z1 = zf2;
			 u1 = uf2;
			 v1 = vf2;
			 norm1 = normf2;
			 if (pos1.y < pos3.y) {
				 x2 = pos1.x;
				 y2 = pos1.y;
				 z2 = zf1;
				 u2 = uf1;
				 v2 = vf1;
				 norm2 = normf1;
				 x3 = pos3.x;
				 y3 = pos3.y;
				 z3 = zf3;
				 u3 = uf3;
				 v3 = vf3;
				 norm3 = normf3;
			 }
			 else {
				 x2 = pos3.x;
				 y2 = pos3.y;
				 z2 = zf3;
				 u2 = uf3;
				 v2 = vf3;
				 norm2 = normf3;
				 x3 = pos1.x;
				 y3 = pos1.y;
				 z3 = zf1;
				 u3 = uf1;
				 v3 = vf1;
				 norm3 = normf1;
			 }
		 }
		 else {
			 x1 = pos3.x;
			 y1 = pos3.y;
			 z1 = zf3;
			 u1 = uf3;
			 v1 = vf3;
			 norm1 = normf3;
			 if (pos1.y < pos2.y) {
				 x2 = pos1.x;
				 y2 = pos1.y;
				 z2 = zf1;
				 u2 = uf1;
				 v2 = vf1;
				 norm2 = normf1;
				 x3 = pos2.x;
				 y3 = pos2.y;
				 z3 = zf2;
				 u3 = uf2;
				 v3 = vf2;
				 norm3 = normf2;
			 }
			 else {
				 x2 = pos2.x;
				 y2 = pos2.y;
				 z2 = zf2;
				 u2 = uf2;
				 v2 = vf2;
				 norm2 = normf2;
				 x3 = pos1.x;
				 y3 = pos1.y;
				 z3 = zf1;
				 u3 = uf1;
				 v3 = vf1;
				 norm3 = normf1;
			 }
		 }
		 x1 = FastMath.round(x1);
		 y1 = FastMath.round(y1);
		 x2 = FastMath.round(x2);
		 y2 = FastMath.round(y2);
		 x3 = FastMath.round(x3);
		 y3 = FastMath.round(y3);
		 z1 = 1.0f/z1;
		 u1 *= z1;
		 v1 *= z1;
		 z2 = 1.0f/z2;
		 u2 *= z2;
		 v2 *= z2;
		 z3 = 1.0f/z3;
		 u3 *= z3;
		 v3 *= z3;
		 dx1 = x3-x1;
		 dy1 = y3-y1;
		 dz1 = z3-z1;
		 if (dy1 == 0) return;
		 du1 = u3-u1;
		 dv1 = v3-v1;
		 dnormx1 = norm3.x-norm1.x;
		 dnormy1 = norm3.y-norm1.y;
		 dnormz1 = norm3.z-norm1.z;
		 dx2 = x2-x1;
		 dy2 = y2-y1;
		 dz2 = z2-z1;
		 du2 = u2-u1;
		 dv2 = v2-v1;
		 dnormx2 = norm2.x-norm1.x;
		 dnormy2 = norm2.y-norm1.y;
		 dnormz2 = norm2.z-norm1.z;
		 denom = (float) (1.0/dy1);
		 mx1 = dx1*denom;
		 mz1 = dz1*denom;
		 mu1 = du1*denom;
		 mv1 = dv1*denom;
		 mnormx1 = dnormx1*denom;
		 mnormy1 = dnormy1*denom;
		 mnormz1 = dnormz1*denom;
		 xstart = xend = x1;
		 zstart = zend = z1;
		 ustart = uend = u1;
		 vstart = vend = v1;
		 normxstart = normxend = norm1.x;
		 normystart = normyend = norm1.y;
		 normzstart = normzend = norm1.z;
		 y = FastMath.round(y1);
		 if (dy2 > 0.0) {
			 denom = (float) (1.0/dy2);
			 mx2 = dx2*denom;
			 mz2 = dz2*denom;
			 mu2 = du2*denom;
			 mv2 = dv2*denom;
			 mnormx2 = dnormx2*denom;
			 mnormy2 = dnormy2*denom;
			 mnormz2 = dnormz2*denom;
			 if (y2 < 0) {
				 xstart += mx1*dy2;
				 xend += mx2*dy2;
				 zstart += mz1*dy2;
				 zend += mz2*dy2;
				 ustart += mu1*dy2;
				 uend += mu2*dy2;
				 vstart += mv1*dy2;
				 vend += mv2*dy2;
				 normxstart += mnormx1*dy2;
				 normxend += mnormx2*dy2;
				 normystart += mnormy1*dy2;
				 normyend += mnormy2*dy2;
				 normzstart += mnormz1*dy2;
				 normzend += mnormz2*dy2;
				 y = FastMath.round(y2);
			 }
			 else if (y < 0) {
				 xstart -= mx1*y;
				 xend -= mx2*y;
				 zstart -= mz1*y;
				 zend -= mz2*y;
				 ustart -= mu1*y;
				 uend -= mu2*y;
				 vstart -= mv1*y;
				 vend -= mv2*y;
				 normxstart -= mnormx1*y;
				 normxend -= mnormx2*y;
				 normystart -= mnormy1*y;
				 normyend -= mnormy2*y;
				 normzstart -= mnormz1*y;
				 normzend -= mnormz2*y;
				 y = 0;
			 }
			 yend = FastMath.round(y2);
			 if (yend > height) yend = height;
			 index = y*width;
			 while (y < yend) {
				 if (xstart < xend) {
					 left = FastMath.round(xstart);
					 right = FastMath.round(xend);
					 z = zstart;
					 dz = zend-zstart;
					 u = ustart;
					 du = uend-ustart;
					 v = vstart;
					 dv = vend-vstart;
					 normx = normxstart;
					 dnormx = normxend-normxstart;
					 normy = normystart;
					 dnormy = normyend-normystart;
					 normz = normzstart;
					 dnormz = normzend-normzstart;
				 }
				 else {
					 left = FastMath.round(xend);
					 right = FastMath.round(xstart);
					 z = zend;
					 dz = zstart-zend;
					 u = uend;
					 du = ustart-uend;
					 v = vend;
					 dv = vstart-vend;
					 normx = normxend;
					 dnormx = normxstart-normxend;
					 normy = normyend;
					 dnormy = normystart-normyend;
					 normz = normzend;
					 dnormz = normzstart-normzend;
				 }
				 if (left != right) {
					 if (xend == xstart) denom = 1.0f;
					 else if (xend > xstart) denom = (float) (1.0/(xend-xstart));
					 else denom = (float) (1.0/(xstart-xend));
					 dz *= denom;
					 du *= denom;
					 dv *= denom;
					 dnormx *= denom;
					 dnormy *= denom;
					 dnormz *= denom;
					 if (left < 0) {
						 z -= dz*left;
						 u -= du*left;
						 v -= dv*left;
						 normx -= dnormx*left;
						 normy -= dnormy*left;
						 normz -= dnormz*left;
						 left = 0;
					 }
					 if (right > width) right = width;
					 repeat = false;
					 for (i = left;
					 i < right;
					 i++) {
						 zl = 1.0f/z;
						 if (zl < fragment[index+i].getOpaqueDepth() && zl > clip) {
							 if (!repeat || (i%subsample == 0)) {
								 ul = u*zl;
								 vl = v*zl;
								 wl = 1.0-ul-vl;
								 if (positionNeeded) context.tempVec[2].set(ul*vert1.x+vl*vert2.x+wl*vert3.x, ul*vert1.y+vl*vert2.y+wl*vert3.y, ul*vert1.z+vl*vert2.z+wl*vert3.z);
								 normal.set(normx, normy, normz);
								 normal.normalize();
								 tri.getTextureSpec(surfSpec, viewdir.dot(normal), ul, vl, wl, smoothScale*z, time);
								 if (bumpMap) {
									 normal.scale(surfSpec.bumpGrad.dot(normal)+1.0);
									 normal.subtract(surfSpec.bumpGrad);
									 normal.normalize();
								 }
								 if (surfSpec.hilight.getRed() == 0.0f && surfSpec.hilight.getGreen() == 0.0f && surfSpec.hilight.getBlue() == 0.0f && surfSpec.specular.getRed() == 0.0f && surfSpec.specular.getGreen() == 0.0f && surfSpec.specular.getBlue() == 0.0f) {
									 calcLight(context.tempVec[2], normal, viewdir, faceNorm, surfSpec.roughness, diffuse, null, null, context);
									 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*diffuse.getRed() + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*diffuse.getGreen() + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*diffuse.getBlue() + surfSpec.emissive.getBlue());
								 }
								 else {
									 calcLight(context.tempVec[2], normal, viewdir, faceNorm, surfSpec.roughness, diffuse, specular, highlight, context);
									 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*diffuse.getRed() + surfSpec.hilight.getRed()*highlight.getRed() + surfSpec.specular.getRed()*specular.getRed() + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*diffuse.getGreen() + surfSpec.hilight.getGreen()*highlight.getGreen() + surfSpec.specular.getGreen()*specular.getGreen() + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*diffuse.getBlue() + surfSpec.hilight.getBlue()*highlight.getBlue() + surfSpec.specular.getBlue()*specular.getBlue() + surfSpec.emissive.getBlue());
								 }
								 lastAddColor = context.tempColor[0].getERGB();
								 lastMultColor = surfSpec.transparent.getERGB();
							 }
							 context.fragment[i] = createFragment(lastAddColor, lastMultColor, zl, material, isBackface);
							 repeat = doSubsample;
						 }
						 else {
							 context.fragment[i] = null;
							 repeat = false;
						 }
						 z += dz;
						 u += du;
						 v += dv;
						 normx += dnormx;
						 normy += dnormy;
						 normz += dnormz;
					 }
					 recordRow(y, left, right, context);
				 }
				 xstart += mx1;
				 zstart += mz1;
				 ustart += mu1;
				 vstart += mv1;
				 normxstart += mnormx1;
				 normystart += mnormy1;
				 normzstart += mnormz1;
				 xend += mx2;
				 zend += mz2;
				 uend += mu2;
				 vend += mv2;
				 normxend += mnormx2;
				 normyend += mnormy2;
				 normzend += mnormz2;
				 index += width;
				 y++;
			 }
		 }
		 dx2 = x3-x2;
		 dy2 = y3-y2;
		 dz2 = z3-z2;
		 du2 = u3-u2;
		 dv2 = v3-v2;
		 dnormx2 = norm3.x-norm2.x;
		 dnormy2 = norm3.y-norm2.y;
		 dnormz2 = norm3.z-norm2.z;
		 if (dy2 > 0.0) {
			 denom = (float) (1.0/dy2);
			 mx2 = dx2*denom;
			 mz2 = dz2*denom;
			 mu2 = du2*denom;
			 mv2 = dv2*denom;
			 mnormx2 = dnormx2*denom;
			 mnormy2 = dnormy2*denom;
			 mnormz2 = dnormz2*denom;
			 xend = x2;
			 zend = z2;
			 uend = u2;
			 vend = v2;
			 normxend = norm2.x;
			 normyend = norm2.y;
			 normzend = norm2.z;
			 if (y < 0) {
				 xstart -= mx1*y;
				 xend -= mx2*y;
				 zstart -= mz1*y;
				 zend -= mz2*y;
				 ustart -= mu1*y;
				 uend -= mu2*y;
				 vstart -= mv1*y;
				 vend -= mv2*y;
				 normxstart -= mnormx1*y;
				 normxend -= mnormx2*y;
				 normystart -= mnormy1*y;
				 normyend -= mnormy2*y;
				 normzstart -= mnormz1*y;
				 normzend -= mnormz2*y;
				 y = 0;
			 }
			 yend = FastMath.round(y3 < height ? y3 : height);
			 index = y*width;
			 while (y < yend) {
				 if (xstart < xend) {
					 left = FastMath.round(xstart);
					 right = FastMath.round(xend);
					 z = zstart;
					 dz = zend-zstart;
					 u = ustart;
					 du = uend-ustart;
					 v = vstart;
					 dv = vend-vstart;
					 normx = normxstart;
					 dnormx = normxend-normxstart;
					 normy = normystart;
					 dnormy = normyend-normystart;
					 normz = normzstart;
					 dnormz = normzend-normzstart;
				 }
				 else {
					 left = FastMath.round(xend);
					 right = FastMath.round(xstart);
					 z = zend;
					 dz = zstart-zend;
					 u = uend;
					 du = ustart-uend;
					 v = vend;
					 dv = vstart-vend;
					 normx = normxend;
					 dnormx = normxstart-normxend;
					 normy = normyend;
					 dnormy = normystart-normyend;
					 normz = normzend;
					 dnormz = normzstart-normzend;
				 }
				 if (left != right) {
					 if (xend == xstart) denom = 1.0f;
					 else if (xend > xstart) denom = (float) (1.0/(xend-xstart));
					 else denom = (float) (1.0/(xstart-xend));
					 dz *= denom;
					 du *= denom;
					 dv *= denom;
					 dnormx *= denom;
					 dnormy *= denom;
					 dnormz *= denom;
					 if (left < 0) {
						 z -= dz*left;
						 u -= du*left;
						 v -= dv*left;
						 normx -= dnormx*left;
						 normy -= dnormy*left;
						 normz -= dnormz*left;
						 left = 0;
					 }
					 if (right > width) right = width;
					 repeat = false;
					 for (i = left;
					 i < right;
					 i++) {
						 zl = 1.0f/z;
						 if (zl < fragment[index+i].getOpaqueDepth() && zl > clip) {
							 if (!repeat || (i%subsample == 0)) {
								 ul = u*zl;
								 vl = v*zl;
								 wl = 1.0-ul-vl;
								 if (positionNeeded) context.tempVec[2].set(ul*vert1.x+vl*vert2.x+wl*vert3.x, ul*vert1.y+vl*vert2.y+wl*vert3.y, ul*vert1.z+vl*vert2.z+wl*vert3.z);
								 normal.set(normx, normy, normz);
								 normal.normalize();
								 tri.getTextureSpec(surfSpec, viewdir.dot(normal), ul, vl, wl, smoothScale*z, time);
								 if (bumpMap) {
									 normal.scale(surfSpec.bumpGrad.dot(normal)+1.0);
									 normal.subtract(surfSpec.bumpGrad);
									 normal.normalize();
								 }
								 if (surfSpec.hilight.getRed() == 0.0f && surfSpec.hilight.getGreen() == 0.0f && surfSpec.hilight.getBlue() == 0.0f && surfSpec.specular.getRed() == 0.0f && surfSpec.specular.getGreen() == 0.0f && surfSpec.specular.getBlue() == 0.0f) {
									 calcLight(context.tempVec[2], normal, viewdir, faceNorm, surfSpec.roughness, diffuse, null, null, context);
									 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*diffuse.getRed() + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*diffuse.getGreen() + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*diffuse.getBlue() + surfSpec.emissive.getBlue());
								 }
								 else {
									 calcLight(context.tempVec[2], normal, viewdir, faceNorm, surfSpec.roughness, diffuse, specular, highlight, context);
									 context.tempColor[0].setRGB(surfSpec.diffuse.getRed()*diffuse.getRed() + surfSpec.hilight.getRed()*highlight.getRed() + surfSpec.specular.getRed()*specular.getRed() + surfSpec.emissive.getRed(), surfSpec.diffuse.getGreen()*diffuse.getGreen() + surfSpec.hilight.getGreen()*highlight.getGreen() + surfSpec.specular.getGreen()*specular.getGreen() + surfSpec.emissive.getGreen(), surfSpec.diffuse.getBlue()*diffuse.getBlue() + surfSpec.hilight.getBlue()*highlight.getBlue() + surfSpec.specular.getBlue()*specular.getBlue() + surfSpec.emissive.getBlue());
								 }
								 lastAddColor = context.tempColor[0].getERGB();
								 lastMultColor = surfSpec.transparent.getERGB();
							 }
							 context.fragment[i] = createFragment(lastAddColor, lastMultColor, zl, material, isBackface);
							 repeat = doSubsample;
						 }
						 else {
							 context.fragment[i] = null;
							 repeat = false;
						 }
						 z += dz;
						 u += du;
						 v += dv;
						 normx += dnormx;
						 normy += dnormy;
						 normz += dnormz;
					 }
					 recordRow(y, left, right, context);
				 }
				 xstart += mx1;
				 zstart += mz1;
				 ustart += mu1;
				 vstart += mv1;
				 normxstart += mnormx1;
				 normystart += mnormy1;
				 normzstart += mnormz1;
				 xend += mx2;
				 zend += mz2;
				 uend += mu2;
				 vend += mv2;
				 normxend += mnormx2;
				 normyend += mnormy2;
				 normzend += mnormz2;
				 index += width;
				 y++;
			 }
		 }
	 }
	 private void renderMeshDisplaced(RenderingMesh mesh, Vec3 viewdir, double tol, boolean cullBackfaces, boolean bumpMap, ObjectMaterialInfo material, RasterContext context) {
		 Vec3 vert[] = mesh.vert, norm[] = mesh.norm;
		 Mat4 toView = context.camera.getObjectToView(), toScreen = context.camera.getObjectToScreen();
		 int v1, v2, v3, n1, n2, n3;
		 double dist1, dist2, dist3;
		 RenderingTriangle tri;
		 for (int i = mesh.triangle.length-1;
		 i >= 0;
		 i--) {
			 tri = mesh.triangle[i];
			 v1 = tri.v1;
			 v2 = tri.v2;
			 v3 = tri.v3;
			 n1 = tri.n1;
			 n2 = tri.n2;
			 n3 = tri.n3;
			 dist1 = vert[v1].distance(vert[v2]);
			 dist2 = vert[v2].distance(vert[v3]);
			 dist3 = vert[v3].distance(vert[v1]);
			 context.tempVec[0].set(vert[v1].x-vert[v3].x, vert[v1].y-vert[v3].y, vert[v1].z-vert[v3].z);
			 context.tempVec[1].set(vert[v3].x-vert[v2].x, vert[v3].y-vert[v2].y, vert[v3].z-vert[v2].z);
			 Vec3 vgrad = context.tempVec[0].cross(mesh.faceNorm[i]);
			 Vec3 ugrad = context.tempVec[1].cross(mesh.faceNorm[i]);
			 vgrad.scale(-1.0/vgrad.dot(context.tempVec[1]));
			 ugrad.scale(1.0/ugrad.dot(context.tempVec[0]));
			 DisplacedVertex dv1 = new DisplacedVertex(tri, vert[v1], norm[n1], 1.0, 0.0, toView, toScreen, context);
			 DisplacedVertex dv2 = new DisplacedVertex(tri, vert[v2], norm[n2], 0.0, 1.0, toView, toScreen, context);
			 DisplacedVertex dv3 = new DisplacedVertex(tri, vert[v3], norm[n3], 0.0, 0.0, toView, toScreen, context);
			 renderDisplacedTriangle(tri, dv1, dist1, dv2, dist2, dv3, dist3, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
		 }
	 }
	 private void renderDisplacedTriangle(RenderingTriangle tri, DisplacedVertex dv1, double dist1, DisplacedVertex dv2, double dist2, DisplacedVertex dv3, double dist3, Vec3 viewdir, Vec3 ugrad, Vec3 vgrad, double tol, boolean cullBackfaces, boolean bumpMap, ObjectMaterialInfo material, RasterContext context) {
		 Mat4 toView = context.camera.getObjectToView(), toScreen = context.camera.getObjectToScreen();
		 DisplacedVertex midv1 = null, midv2 = null, midv3 = null;
		 double halfdist1 = 0, halfdist2 = 0, halfdist3 = 0;
		 boolean split1 = dist1 > tol, split2 = dist2 > tol, split3 = dist3 > tol;
		 int shading = (bumpMap ? PHONG : shadingMode), count = 0;
		 if (split1) {
			 midv1 = new DisplacedVertex(tri, new Vec3(0.5*(dv1.vert.x+dv2.vert.x), 0.5*(dv1.vert.y+dv2.vert.y), 0.5*(dv1.vert.z+dv2.vert.z)), new Vec3(0.5*(dv1.norm.x+dv2.norm.x), 0.5*(dv1.norm.y+dv2.norm.y), 0.5*(dv1.norm.z+dv2.norm.z)), 0.5*(dv1.u+dv2.u), 0.5*(dv1.v+dv2.v), toView, toScreen, context);
			 halfdist1 = 0.5*dist1;
			 count++;
		 }
		 if (split2) {
			 midv2 = new DisplacedVertex(tri, new Vec3(0.5*(dv2.vert.x+dv3.vert.x), 0.5*(dv2.vert.y+dv3.vert.y), 0.5*(dv2.vert.z+dv3.vert.z)), new Vec3(0.5*(dv2.norm.x+dv3.norm.x), 0.5*(dv2.norm.y+dv3.norm.y), 0.5*(dv2.norm.z+dv3.norm.z)), 0.5*(dv2.u+dv3.u), 0.5*(dv2.v+dv3.v), toView, toScreen, context);
			 halfdist2 = 0.5*dist2;
			 count++;
		 }
		 if (split3) {
			 midv3 = new DisplacedVertex(tri, new Vec3(0.5*(dv3.vert.x+dv1.vert.x), 0.5*(dv3.vert.y+dv1.vert.y), 0.5*(dv3.vert.z+dv1.vert.z)), new Vec3(0.5*(dv3.norm.x+dv1.norm.x), 0.5*(dv3.norm.y+dv1.norm.y), 0.5*(dv3.norm.z+dv1.norm.z)), 0.5*(dv3.u+dv1.u), 0.5*(dv3.v+dv1.v), toView, toScreen, context);
			 halfdist3 = 0.5*dist3;
			 count++;
		 }
		 if (count == 1) {
			 if (split1) {
				 double d = dv3.vert.distance(midv1.vert);
				 renderDisplacedTriangle(tri, dv1, halfdist1, midv1, d, dv3, dist3, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, midv1, halfdist1, dv2, dist2, dv3, d, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 }
			 else if (split2) {
				 double d = dv1.vert.distance(midv2.vert);
				 renderDisplacedTriangle(tri, dv2, halfdist2, midv2, d, dv1, dist1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, midv2, halfdist2, dv3, dist3, dv1, d, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 }
			 else {
				 double d = dv1.vert.distance(midv3.vert);
				 renderDisplacedTriangle(tri, dv3, halfdist3, midv3, d, dv2, dist2, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, midv3, halfdist3, dv1, dist1, dv2, d, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 }
			 return;
		 }
		 if (count == 2) {
			 if (!split1) {
				 double d1 = midv2.vert.distance(dv1.vert), d2 = midv2.vert.distance(midv3.vert);
				 renderDisplacedTriangle(tri, dv1, dist1, dv2, halfdist2, midv2, d1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, dv1, d1, midv2, d2, midv3, halfdist3, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, dv3, halfdist3, midv3, d2, midv2, halfdist2, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 }
			 else if (!split2) {
				 double d1 = midv3.vert.distance(dv2.vert), d2 = midv3.vert.distance(midv1.vert);
				 renderDisplacedTriangle(tri, dv2, dist2, dv3, halfdist3, midv3, d1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, dv2, d1, midv3, d2, midv1, halfdist1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, dv1, halfdist1, midv1, d2, midv3, halfdist3, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 }
			 else {
				 double d1 = midv1.vert.distance(dv3.vert), d2 = midv1.vert.distance(midv2.vert);
				 renderDisplacedTriangle(tri, dv3, dist3, dv1, halfdist1, midv1, d1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, dv3, d1, midv1, d2, midv2, halfdist2, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
				 renderDisplacedTriangle(tri, dv2, halfdist2, midv2, d2, midv1, halfdist1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 }
			 return;
		 }
		 if (count == 3) {
			 double d1 = midv1.vert.distance(midv2.vert), d2 = midv2.vert.distance(midv3.vert), d3 = midv3.vert.distance(midv1.vert);
			 renderDisplacedTriangle(tri, dv1, halfdist1, midv1, d3, midv3, halfdist3, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 renderDisplacedTriangle(tri, dv2, halfdist2, midv2, d1, midv1, halfdist1, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 renderDisplacedTriangle(tri, dv3, halfdist3, midv3, d2, midv2, halfdist2, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 renderDisplacedTriangle(tri, midv1, d1, midv2, d2, midv3, d3, viewdir, ugrad, vgrad, tol, cullBackfaces, bumpMap, material, context);
			 return;
		 }
		 float clip = (float) context.camera.getClipDistance();
		 if (dv1.z < clip && dv2.z < clip && dv3.z < clip) return;
		 if (dv1.z <= 0.0f || dv2.z < 0.0f || dv3.z < 0.0f) return;
		 boolean backface = ((dv2.pos.x-dv1.pos.x)*(dv3.pos.y-dv1.pos.y) - (dv2.pos.y-dv1.pos.y)*(dv3.pos.x-dv1.pos.x) > 0.0);
		 if (cullBackfaces && backface) return;
		 if (dv1.dispnorm == null) dv1.prepareToRender(tri, viewdir, ugrad, vgrad, shading, context);
		 if (dv2.dispnorm == null) dv2.prepareToRender(tri, viewdir, ugrad, vgrad, shading, context);
		 if (dv3.dispnorm == null) dv3.prepareToRender(tri, viewdir, ugrad, vgrad, shading, context);
		 Vec3 closestNorm;
		 if (dv1.z < dv2.z && dv1.z < dv3.z) closestNorm = dv1.dispnorm;
		 else if (dv2.z < dv1.z && dv2.z < dv3.z) closestNorm = dv2.dispnorm;
		 else closestNorm = dv3.dispnorm;
		 if (shading == GOURAUD) renderTriangleGouraud(dv1.pos, dv1.z, dv1.u, dv1.v, dv1.diffuse, dv1.specular, dv2.pos, dv2.z, dv2.u, dv2.v, dv2.diffuse, dv2.specular, dv3.pos, dv3.z, dv3.u, dv3.v, dv3.diffuse, dv3.specular, tri, clip, viewdir.dot(closestNorm), backface, material, context);
		 else if (shading == HYBRID) renderTriangleHybrid(dv1.pos, dv1.z, dv1.dispvert, dv1.dispnorm, dv1.u, dv1.v, dv1.diffuse, dv2.pos, dv2.z, dv2.dispvert, dv2.dispnorm, dv2.u, dv2.v, dv2.diffuse, dv3.pos, dv3.z, dv3.dispvert, dv3.dispnorm, dv3.u, dv3.v, dv3.diffuse, tri, viewdir, closestNorm, clip, viewdir.dot(closestNorm), backface, material, context);
		 else renderTrianglePhong(dv1.pos, dv1.z, dv1.dispvert, dv1.dispnorm, dv1.u, dv1.v, dv2.pos, dv2.z, dv2.dispvert, dv2.dispnorm, dv2.u, dv2.v, dv3.pos, dv3.z, dv3.dispvert, dv3.dispnorm, dv3.u, dv3.v, tri, viewdir, closestNorm, clip, bumpMap, backface, material, context);
	 }
	 private class DisplacedVertex {
		 public Vec3 vert, norm, dispvert, dispnorm;
		 public Vec2 pos;
		 public double u, v, disp, tol;
		 public float z, basez;
		 public RGBColor diffuse, specular, highlight;
		 public DisplacedVertex(RenderingTriangle tri, Vec3 vert, Vec3 norm, double u, double v, Mat4 toView, Mat4 toScreen, RasterContext context) {
			 this.vert = vert;
			 this.norm = norm;
			 this.u = u;
			 this.v = v;
			 basez = (float) toView.timesZ(vert);
			 tol = (basez > context.camera.getDistToScreen()) ? smoothScale*basez : smoothScale;
			 disp = tri.getDisplacement(u, v, 1.0-u-v, tol, 0.0);
			 dispvert = new Vec3(vert.x+disp*norm.x, vert.y+disp*norm.y, vert.z+disp*norm.z);
			 z = (float) toView.timesZ(dispvert);
			 pos = toScreen.timesXY(dispvert);
		 }
		 public final void prepareToRender(RenderingTriangle tri, Vec3 viewdir, Vec3 ugrad, Vec3 vgrad, int shading, RasterContext context) {
			 double w = 1.0-u-v;
			 double dhdu = (tri.getDisplacement(u+(1e-5), v, w-(1e-5), tol, 0.0)-disp)*1e5;
			 double dhdv = (tri.getDisplacement(u, v+(1e-5), w-(1e-5), tol, 0.0)-disp)*1e5;
			 dispnorm = new Vec3(norm);
			 context.tempVec[0].set(dhdu*ugrad.x+dhdv*vgrad.x, dhdu*ugrad.y+dhdv*vgrad.y, dhdu*ugrad.z+dhdv*vgrad.z);
			 dispnorm.scale(context.tempVec[0].dot(dispnorm)+1.0);
			 dispnorm.subtract(context.tempVec[0]);
			 dispnorm.normalize();
			 tol = (z > context.camera.getDistToScreen()) ? smoothScale*z : smoothScale;
			 if (shading == GOURAUD) {
				 specular = new RGBColor();
				 highlight = new RGBColor();
			 }
			 if (shading != PHONG) {
				 diffuse = new RGBColor();
				 tri.getTextureSpec(context.surfSpec, viewdir.dot(dispnorm), u, v, w, tol, time);
				 calcLight(dispvert, dispnorm, viewdir, dispnorm, context.surfSpec.roughness, diffuse, specular, highlight, context);
				 if (specular != null) specular.add(highlight);
			 }
		 }
	 }
	 private static class RowLock {
	 }
}",1,0,0,0
"public void offerService() throws Exception {
	 long wakeups = 0;
	 long lastHeartbeat = 0, lastBlockReport = 0;
	 long sendStart = System.currentTimeMillis();
	 int heartbeatsSent = 0;
	 LOG.info(""using BLOCKREPORT_INTERVAL of "" + blockReportInterval + ""msec"");
	 while (shouldRun) {
		 long now = System.currentTimeMillis();
		 synchronized (receivedBlockList) {
			 if (now - lastHeartbeat > HEARTBEAT_INTERVAL) {
				 namenode.sendHeartbeat(localName, data.getCapacity(), data.getRemaining());
				 lastHeartbeat = now;
			}
			if (now - lastBlockReport > blockReportInterval) {
				 Block toDelete[] = namenode.blockReport(localName, data.getBlockReport());
				 data.invalidate(toDelete);
				 lastBlockReport = now;
				 continue;
			}
			if (receivedBlockList.size() > 0) {
				 Block blockArray[] = (Block[]) receivedBlockList.toArray(new Block[receivedBlockList.size()]);
				 receivedBlockList.removeAllElements();
				 namenode.blockReceived(localName, blockArray);
			 }
			if (now - sendStart > datanodeStartupPeriod) {
				 BlockCommand cmd = namenode.getBlockwork(localName, xmitsInProgress);
				 if (cmd != null && cmd.transferBlocks()) {
					Block blocks[] = cmd.getBlocks();
					DatanodeInfo xferTargets[][] = cmd.getTargets();
					for (int i = 0;
					 i < blocks.length;
					 i++) {
						 if (!data.isValidBlock(blocks[i])) {
							String errStr = ""Can't send invalid block "" + blocks[i];
							LOG.info(errStr);
							namenode.errorReport(localName, errStr);
							break;
						 }
						 else {
							if (xferTargets[i].length > 0) {
								 LOG.info(""Starting thread to transfer block "" + blocks[i] + "" to "" + xferTargets[i]);
								 new Daemon(new DataTransfer(xferTargets[i], blocks[i])).start();
							}
						 }
					}
				 }
				 else if (cmd != null && cmd.invalidateBlocks()) {
					 data.invalidate(cmd.getBlocks());
				 }
			 }
			 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
			 if (waitTime > 0 && receivedBlockList.size() == 0) {
				 try {
					 receivedBlockList.wait(waitTime);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
 }",0,0,1,0
"public class POCast extends ExpressionOperator {
	 private final static Log log = LogFactory.getLog(POCast.class);
	 private static final String unknownByteArrayErrorMessage = ""Received a bytearray from the UDF or Union from two different Loaders. Cannot determine how to convert the bytearray to "";
	 private FuncSpec funcSpec = null;
	 transient private LoadCaster caster;
	 private boolean castNotNeeded = false;
	 private Byte realType = null;
	 private transient List<ExpressionOperator> child;
	 private ResourceFieldSchema fieldSchema = null;
	 private static final long serialVersionUID = 1L;
	 public POCast(OperatorKey k) {
		 super(k);
	 }
	 public POCast(OperatorKey k, int rp) {
		 super(k, rp);
	 }
	 private void instantiateFunc() throws IOException {
		 if (caster != null) return;
		 if (funcSpec != null) {
			 Object obj = PigContext .instantiateFuncFromSpec(funcSpec);
			 if (obj instanceof LoadFunc) {
				 caster = ((LoadFunc)obj).getLoadCaster();
			 }
			 else if (obj instanceof StreamToPig) {
				 caster = ((StreamToPig)obj).getLoadCaster();
			 }
			 else if (obj instanceof EvalFunc) {
				 caster = ((EvalFunc)obj).getLoadCaster();
			 }
			 else {
				 throw new IOException(""Invalid class type "" + funcSpec.getClassName());
			 }
		 }
	 }
	 private Result error() {
		 Result res = new Result();
		 res.returnStatus = POStatus.STATUS_ERR;
		 return res;
	 }
	 public void setFuncSpec(FuncSpec lf) throws IOException {
		 this.funcSpec = lf;
		 instantiateFunc();
	 }
	 public void visit(PhyPlanVisitor v) throws VisitorException {
		 v.visitCast(this);
	 }
	 public String name() {
		 if (DataType.isSchemaType(resultType)) return ""Cast"" + ""["" + DataType.findTypeName(resultType)+"":"" + fieldSchema.calcCastString() + ""]"" + "" - "" + mKey.toString();
		 else return ""Cast"" + ""["" + DataType.findTypeName(resultType) + ""]"" + "" - "" + mKey.toString();
	 }
	 public boolean supportsMultipleInputs() {
		 return false;
	 }
	 public Result getNextBigInteger() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: case DataType.DATETIME: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) {
							 realType = DataType.findType(res.result);
						 }
						 try {
							 res.result = DataType.toBigInteger(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toBigInteger(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToBigInteger(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""BigInteger for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to BigInteger"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = BigInteger.ONE;
					 }
					 else {
						 res.result = BigInteger.ZERO;
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigInteger.valueOf(((Integer) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigInteger.valueOf(((Double) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigInteger.valueOf(((Long) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigInteger.valueOf(((Float) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new BigInteger((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 return in.getNextBigInteger();
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((BigDecimal)res.result).toBigInteger();
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextBigDecimal() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: case DataType.DATETIME: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toBigDecimal(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toBigDecimal(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToBigDecimal(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""BigDecimal for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to BigDecimal"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = BigDecimal.ONE;
					 }
					 else {
						 res.result = BigDecimal.ZERO;
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigDecimal.valueOf(((Integer) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigDecimal.valueOf(((Double) res.result).doubleValue());
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigDecimal.valueOf(((Long) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = BigDecimal.valueOf(((Float) res.result).doubleValue());
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new BigDecimal((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new BigDecimal((BigInteger)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: return in.getNextBigDecimal();
		 }
		 return error();
	 }
	 public Result getNextBoolean() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: case DataType.DATETIME: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toBoolean(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toBoolean(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToBoolean(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""boolean for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Boolean"");
					 }
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = CastUtils.stringToBoolean((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: return in.getNextBoolean();
			 case DataType.INTEGER: {
				 Integer i = null;
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Boolean.valueOf(((Integer) res.result).intValue() != 0);
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Boolean.valueOf(((Long) res.result).longValue() != 0L);
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Boolean.valueOf(((Float) res.result).floatValue() != 0.0F);
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Boolean.valueOf(((Double) res.result).doubleValue() != 0.0);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 BigInteger bi = null;
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Boolean.valueOf(!BigInteger.ZERO.equals((BigInteger)res.result));
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 BigDecimal bd = null;
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Boolean.valueOf(((BigDecimal)res.result).signum() != 0);
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextInteger() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toInteger(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toInteger(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToInteger(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""int for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Integer"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = Integer.valueOf(1);
					 }
					 else {
						 res.result = Integer.valueOf(0);
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Double d = null;
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Integer.valueOf(((Double) res.result).intValue());
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Integer.valueOf(((Long) res.result).intValue());
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Integer.valueOf(((Float) res.result).intValue());
				 }
				 return res;
			 }
			 case DataType.DATETIME: {
				 Result res = in.getNextDateTime();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Integer.valueOf(Long.valueOf(((DateTime) res.result).getMillis()).intValue());
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = CastUtils.stringToInteger((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Integer.valueOf(((BigInteger)res.result).intValue());
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Integer.valueOf(((BigDecimal)res.result).intValue());
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextLong() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toLong(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toLong(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToLong(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""long for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Long"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = Long.valueOf(1);
					 }
					 else {
						 res.result = Long.valueOf(0);
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Long.valueOf(((Integer) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Long.valueOf(((Double) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.LONG: return in.getNextLong();
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Long.valueOf(((Float) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.DATETIME: {
				 Result res = in.getNextDateTime();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Long.valueOf(((DateTime) res.result).getMillis());
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = CastUtils.stringToLong((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Long.valueOf(((BigInteger)res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Long.valueOf(((BigDecimal)res.result).longValue());
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextDouble() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toDouble(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toDouble(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToDouble(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""double for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Double"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = new Double(1);
					 }
					 else {
						 res.result = new Double(0);
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Double(((Integer) res.result).doubleValue());
				 }
				 return res;
			 }
			 case DataType.DOUBLE: return in.getNextDouble();
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Double(((Long) res.result).doubleValue());
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Double(((Float) res.result).doubleValue());
				 }
				 return res;
			 }
			 case DataType.DATETIME: {
				 Result res = in.getNextDateTime();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Double(Long.valueOf(((DateTime) res.result).getMillis()).doubleValue());
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = CastUtils.stringToDouble((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Double.valueOf(((BigInteger)res.result).doubleValue());
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Double.valueOf(((BigDecimal)res.result).doubleValue());
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextFloat() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toFloat(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toFloat(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToFloat(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""float for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Float"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = new Float(1);
					 }
					 else {
						 res.result = new Float(0);
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Float(((Integer) res.result).floatValue());
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Float(((Double) res.result).floatValue());
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Float(((Long) res.result).floatValue());
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 return in.getNextFloat();
			 }
			 case DataType.DATETIME: {
				 DateTime dt = null;
				 Result res = in.getNextDateTime();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new Float(Long.valueOf(((DateTime) res.result).getMillis()).floatValue());
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = CastUtils.stringToFloat((String)res.result);
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Float.valueOf(((BigInteger)res.result).floatValue());
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = Float.valueOf(((BigDecimal)res.result).floatValue());
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextDateTime() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) {
							 realType = DataType.findType(res.result);
						 }
						 try {
							 res.result = DataType.toDateTime(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toDateTime(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToDateTime(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""datetime for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to DateTime"");
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new DateTime(((Integer) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new DateTime(((Double) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new DateTime(((Long) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new DateTime(((Float) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.BIGINTEGER: {
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new DateTime(((BigInteger) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = new DateTime(((BigDecimal) res.result).longValue());
				 }
				 return res;
			 }
			 case DataType.DATETIME: return in.getNextDateTime();
			 case DataType.CHARARRAY: {
				 Result res = in.getNextString();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ToDate.extractDateTime((String) res.result);
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextString() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: case DataType.TUPLE: case DataType.MAP: return error();
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (realType == null) realType = DataType.findType(res.result);
						 try {
							 res.result = DataType.toString(res.result, realType);
						 }
						 catch (ClassCastException cce) {
							 realType = DataType.findType(res.result);
							 res.result = DataType.toString(res.result, realType);
						 }
						 return res;
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToCharArray(dba.get());
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""string for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log .error(""Error while casting from ByteArray to CharArray"");
					 }
				 }
				 return res;
			 }
			 case DataType.BOOLEAN: {
				 Result res = in.getNextBoolean();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if ((Boolean) res.result) {
						 res.result = Boolean.TRUE.toString();
					 }
					 else {
						 res.result = Boolean.FALSE.toString();
					 }
				 }
				 return res;
			 }
			 case DataType.INTEGER: {
				 Result res = in.getNextInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((Integer) res.result).toString();
				 }
				 return res;
			 }
			 case DataType.DOUBLE: {
				 Result res = in.getNextDouble();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((Double) res.result).toString();
				 }
				 return res;
			 }
			 case DataType.LONG: {
				 Result res = in.getNextLong();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((Long) res.result).toString();
				 }
				 return res;
			 }
			 case DataType.FLOAT: {
				 Result res = in.getNextFloat();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((Float) res.result).toString();
				 }
				 return res;
			 }
			 case DataType.DATETIME: {
				 Result res = in.getNextDateTime();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((DateTime) res.result).toString();
				 }
				 return res;
			 }
			 case DataType.CHARARRAY: return in.getNextString();
			 case DataType.BIGINTEGER: {
				 BigInteger bi = null;
				 Result res = in.getNextBigInteger();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((BigInteger)res.result).toString();
				 }
				 return res;
			 }
			 case DataType.BIGDECIMAL: {
				 Result res = in.getNextBigDecimal();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 res.result = ((BigDecimal)res.result).toString();
				 }
				 return res;
			 }
		 }
		 return error();
	 }
	 public Result getNextTuple() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte castToType = DataType.TUPLE;
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.TUPLE: {
				 Result res = in.getNextTuple();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 res.result = convertWithSchema(res.result, fieldSchema);
					 }
					 catch (IOException e) {
						 LogUtils.warn(this, ""Unable to interpret value "" + res.result + "" in field being "" + ""converted to type tuple, caught ParseException <"" + e.getMessage() + ""> field discarded"", PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, log);
						 res.result = null;
					 }
				 }
				 return res;
			 }
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if (castNotNeeded) {
						 return res;
					 }
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (DataType.findType(res.result) == castToType) {
							 castNotNeeded = true;
							 return res;
						 }
						 else {
							 int errCode = 1081;
							 String msg = ""Cannot cast to tuple. Expected bytearray but received: "" + DataType.findTypeName(res.result);
							 throw new ExecException(msg, errCode, PigException.INPUT, e);
						 }
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToTuple(dba.get(), fieldSchema);
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""tuple for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Tuple"");
					 }
				 }
				 return res;
			 }
			 case DataType.BAG: case DataType.MAP: case DataType.INTEGER: case DataType.DOUBLE: case DataType.LONG: case DataType.FLOAT: case DataType.CHARARRAY: case DataType.BOOLEAN: case DataType.BIGINTEGER: case DataType.BIGDECIMAL: case DataType.DATETIME: return error();
		 }
		 return error();
	 }
	 private Object convertWithSchema(Object obj, ResourceFieldSchema fs) throws IOException {
		 Object result = null;
		 if (fs == null) {
			 return obj;
		 }
		 if (obj == null) {
			 return null;
		 }
		 switch (fs.getType()) {
			 case DataType.BAG: if (obj instanceof DataBag) {
				 DataBag db = (DataBag)obj;
				 if (fs.getSchema()!=null) {
					 ResourceFieldSchema tupleFs = fs.getSchema().getFields()[0];
					 Iterator<Tuple> iter = db.iterator();
					 while (iter.hasNext()) {
						 Tuple t = iter.next();
						 convertWithSchema(t, tupleFs);
					 }
				 }
				 result = db;
			 }
			 else if (obj instanceof DataByteArray) {
				 if (null != caster) {
					 result = caster.bytesToBag(((DataByteArray)obj).get(), fs);
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""bag for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
			 }
			 else {
				 throw new ExecException(""Cannot cast "" + obj + "" to bag."", 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.TUPLE: if (obj instanceof Tuple) {
				 try {
					 Tuple t = (Tuple)obj;
					 ResourceSchema innerSchema = fs.getSchema();
					 if (innerSchema==null) return t;
					 if (innerSchema.getFields().length!=t.size()) return null;
					 int i=0;
					 for (ResourceFieldSchema fieldSchema : innerSchema.getFields()) {
						 Object field = convertWithSchema(t.get(i), fieldSchema);
						 t.set(i, field);
						 i++;
					 }
					 result = t;
				 }
				 catch (Exception e) {
					 throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs);
				 }
			 }
			 else if (obj instanceof DataByteArray) {
				 if (null != caster) {
					 result = caster.bytesToTuple(((DataByteArray)obj).get(), fs);
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""tuple for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
			 }
			 else {
				 throw new ExecException(""Cannot cast "" + obj + "" to tuple."", 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.MAP: if (obj instanceof Map) {
				 if (fs!=null && fs.getSchema()!=null) {
					 ResourceFieldSchema innerFieldSchema = fs.getSchema().getFields()[0];
					 Map m = (Map)obj;
					 for (Object entry : m.entrySet()) {
						 Object newValue = convertWithSchema(((Map.Entry)entry).getValue(), innerFieldSchema);
						 m.put(((Map.Entry)entry).getKey(), newValue);
					 }
					 result = m;
				 }
				 else result = obj;
			 }
			 else if (obj instanceof DataByteArray) {
				 if (null != caster) {
					 result = caster.bytesToMap(((DataByteArray)obj).get(), fs);
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""tuple for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
			 }
			 else {
				 throw new ExecException(""Cannot cast "" + obj + "" to map."", 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.BOOLEAN: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToBoolean(((DataByteArray) obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""int for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: result = obj;
				 break;
				 case DataType.INTEGER: result = Boolean.valueOf(((Integer) obj).intValue() != 0);
				;
				 break;
				 case DataType.DOUBLE: result = Boolean.valueOf(((Double) obj).doubleValue() != 0.0D);
				 break;
				 case DataType.LONG: result = Boolean.valueOf(((Long) obj).longValue() != 0L);
				 break;
				 case DataType.FLOAT: result = Boolean.valueOf(((Float) obj).floatValue() != 0.0F);
				 break;
				 case DataType.CHARARRAY: result = CastUtils.stringToBoolean((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = Boolean.valueOf(!BigInteger.ZERO.equals((BigInteger)obj));
				 break;
				 case DataType.BIGDECIMAL: result = Boolean.valueOf(((BigDecimal)obj).signum() != 0);
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.INTEGER: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToInteger(((DataByteArray) obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""int for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = Integer.valueOf(1);
				 }
				 else {
					 result = Integer.valueOf(0);
				 }
				 break;
				 case DataType.INTEGER: result = obj;
				 break;
				 case DataType.DOUBLE: result = Integer.valueOf(((Double)obj).intValue());
				 break;
				 case DataType.LONG: result = Integer.valueOf(((Long)obj).intValue());
				 break;
				 case DataType.FLOAT: result = Integer.valueOf(((Float)obj).intValue());
				 break;
				 case DataType.DATETIME: result = Integer.valueOf(Long.valueOf(((DateTime)obj).getMillis()).intValue());
				 break;
				 case DataType.CHARARRAY: result = CastUtils.stringToInteger((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = Integer.valueOf(((BigInteger)obj).intValue());
				 break;
				 case DataType.BIGDECIMAL: result = Integer.valueOf(((BigDecimal)obj).intValue());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.DOUBLE: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToDouble(((DataByteArray) obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""double for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = new Double(1);
				 }
				 else {
					 result = new Double(1);
				 }
				 break;
				 case DataType.INTEGER: result = new Double(((Integer)obj).doubleValue());
				 break;
				 case DataType.DOUBLE: result = (Double)obj;
				 break;
				 case DataType.LONG: result = new Double(((Long)obj).doubleValue());
				 break;
				 case DataType.FLOAT: result = new Double(((Float)obj).doubleValue());
				 break;
				 case DataType.DATETIME: result = new Double(Long.valueOf(((DateTime)obj).getMillis()).doubleValue());
				 break;
				 case DataType.CHARARRAY: result = CastUtils.stringToDouble((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = Double.valueOf(((BigInteger)obj).doubleValue());
				 break;
				 case DataType.BIGDECIMAL: result = Double.valueOf(((BigDecimal)obj).doubleValue());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.LONG: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToLong(((DataByteArray)obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""long for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = Long.valueOf(1);
				 }
				 else {
					 result = Long.valueOf(0);
				 }
				 break;
				 case DataType.INTEGER: result = Long.valueOf(((Integer)obj).longValue());
				 break;
				 case DataType.DOUBLE: result = Long.valueOf(((Double)obj).longValue());
				 break;
				 case DataType.LONG: result = (Long)obj;
				 break;
				 case DataType.FLOAT: result = Long.valueOf(((Float)obj).longValue());
				 break;
				 case DataType.DATETIME: result = Long.valueOf(((DateTime)obj).getMillis());
				 break;
				 case DataType.CHARARRAY: result = CastUtils.stringToLong((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = Long.valueOf(((BigInteger)obj).longValue());
				 break;
				 case DataType.BIGDECIMAL: result = Long.valueOf(((BigDecimal)obj).longValue());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.FLOAT: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToFloat(((DataByteArray)obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""float for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = new Float(1);
				 }
				 else {
					 result = new Float(0);
				 }
				 break;
				 case DataType.INTEGER: result = new Float(((Integer) obj).floatValue());
				 break;
				 case DataType.DOUBLE: result = new Float(((Double)obj).floatValue());
				 break;
				 case DataType.LONG: result = new Float(((Long)obj).floatValue());
				 break;
				 case DataType.FLOAT: result = obj;
				 break;
				 case DataType.DATETIME: result = new Float(Long.valueOf(((DateTime)obj).getMillis()).floatValue());
				 break;
				 case DataType.CHARARRAY: result = CastUtils.stringToFloat((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = Float.valueOf(((BigInteger)obj).floatValue());
				 break;
				 case DataType.BIGDECIMAL: result = Float.valueOf(((BigDecimal)obj).floatValue());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.DATETIME: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToDateTime(((DataByteArray)obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""datetime for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.INTEGER: result = new DateTime(((Integer)obj).longValue());
				 break;
				 case DataType.DOUBLE: result = new DateTime(((Double)obj).longValue());
				 break;
				 case DataType.LONG: result = new DateTime(((Long)obj).longValue());
				 break;
				 case DataType.FLOAT: result = new DateTime(((Float)obj).longValue());
				 break;
				 case DataType.DATETIME: result = (DateTime)obj;
				 break;
				 case DataType.CHARARRAY: result = ToDate.extractDateTime((String) obj);
				 break;
				 case DataType.BIGINTEGER: result = new DateTime(((BigInteger)obj).longValue());
				 break;
				 case DataType.BIGDECIMAL: result = new DateTime(((BigDecimal)obj).longValue());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.CHARARRAY: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToCharArray(((DataByteArray)obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""float for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = Boolean.TRUE.toString();
				 }
				 else {
					 result = Boolean.FALSE.toString();
				 }
				 break;
				 case DataType.INTEGER: result = ((Integer) obj).toString();
				 break;
				 case DataType.DOUBLE: result = ((Double) obj).toString();
				 break;
				 case DataType.LONG: result = ((Long) obj).toString();
				 break;
				 case DataType.FLOAT: result = ((Float) obj).toString();
				 break;
				 case DataType.DATETIME: result = ((DateTime)obj).toString();
				 break;
				 case DataType.CHARARRAY: result = obj;
				 break;
				 case DataType.BIGINTEGER: result = ((BigInteger)obj).toString();
				 break;
				 case DataType.BIGDECIMAL: result = ((BigDecimal)obj).toString();
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 break;
			 case DataType.BIGINTEGER: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToBigInteger(((DataByteArray)obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""BigInteger for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = BigInteger.ONE;
				 }
				 else {
					 result = BigInteger.ZERO;
				 }
				 break;
				 case DataType.INTEGER: result = BigInteger.valueOf(((Integer)obj).longValue());
				 break;
				 case DataType.DOUBLE: result = BigInteger.valueOf(((Double)obj).longValue());
				 break;
				 case DataType.LONG: result = BigInteger.valueOf(((Long)obj).longValue());
				 break;
				 case DataType.FLOAT: result = BigInteger.valueOf(((Float)obj).longValue());
				 break;
				 case DataType.CHARARRAY: result = new BigInteger((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = (BigInteger)obj;
				 break;
				 case DataType.BIGDECIMAL: result = ((BigDecimal)obj).toBigInteger();
				 break;
				 case DataType.DATETIME: result = BigInteger.valueOf(((DateTime)obj).getMillis());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 case DataType.BIGDECIMAL: switch (DataType.findType(obj)) {
				 case DataType.BYTEARRAY: if (null != caster) {
					 result = caster.bytesToBigDecimal(((DataByteArray)obj).get());
				 }
				 else {
					 int errCode = 1075;
					 String msg = unknownByteArrayErrorMessage + ""BigDecimal for "" + this.getOriginalLocations();
					 throw new ExecException(msg, errCode, PigException.INPUT);
				 }
				 break;
				 case DataType.BOOLEAN: if ((Boolean) obj) {
					 result = BigDecimal.ONE;
				 }
				 else {
					 result = BigDecimal.ZERO;
				 }
				 break;
				 case DataType.INTEGER: result = BigDecimal.valueOf(((Integer)obj).longValue());
				 break;
				 case DataType.DOUBLE: result = BigDecimal.valueOf(((Double)obj).doubleValue());
				 break;
				 case DataType.LONG: result = BigDecimal.valueOf(((Long)obj).longValue());
				 break;
				 case DataType.FLOAT: result = BigDecimal.valueOf(((Float)obj).doubleValue());
				 break;
				 case DataType.CHARARRAY: result = new BigDecimal((String)obj);
				 break;
				 case DataType.BIGINTEGER: result = new BigDecimal((BigInteger)obj);
				 break;
				 case DataType.BIGDECIMAL: result = (BigDecimal)obj;
				 break;
				 case DataType.DATETIME: result = BigDecimal.valueOf(((DateTime)obj).getMillis());
				 break;
				 default: throw new ExecException(""Cannot convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
			 }
			 case DataType.BYTEARRAY: result = obj;
			 break;
			 default: throw new ExecException(""Don't know how to convert ""+ obj + "" to "" + fs, 1120, PigException.INPUT);
		 }
		 return result;
	 }
	 public Result getNextDataBag() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte castToType = DataType.BAG;
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.BAG: {
				 res = in.getNextDataBag();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 res.result = convertWithSchema(res.result, fieldSchema);
					 }
					 catch (IOException e) {
						 LogUtils.warn(this, ""Unable to interpret value "" + res.result + "" in field being "" + ""converted to type bag, caught ParseException <"" + e.getMessage() + ""> field discarded"", PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, log);
						 res.result = null;
					 }
				 }
				 return res;
			 }
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if (castNotNeeded) {
						 return res;
					 }
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (DataType.findType(res.result) == castToType) {
							 castNotNeeded = true;
							 return res;
						 }
						 else {
							 int errCode = 1081;
							 String msg = ""Cannot cast to bag. Expected bytearray but received: "" + DataType.findTypeName(res.result);
							 throw new ExecException(msg, errCode, PigException.INPUT, e);
						 }
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToBag(dba.get(), fieldSchema);
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""bag for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to DataBag"");
					 }
				 }
				 return res;
			 }
			 case DataType.TUPLE: case DataType.MAP: case DataType.INTEGER: case DataType.DOUBLE: case DataType.LONG: case DataType.FLOAT: case DataType.DATETIME: case DataType.CHARARRAY: case DataType.BOOLEAN: case DataType.BIGINTEGER: case DataType.BIGDECIMAL: return error();
		 }
		 return error();
	 }
	 public Result getNextMap() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte castToType = DataType.MAP;
		 Byte resultType = in.getResultType();
		 switch (resultType) {
			 case DataType.MAP: {
				 Result res = in.getNextMap();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 try {
						 res.result = convertWithSchema(res.result, fieldSchema);
					 }
					 catch (IOException e) {
						 LogUtils.warn(this, ""Unable to interpret value "" + res.result + "" in field being "" + ""converted to type map, caught ParseException <"" + e.getMessage() + ""> field discarded"", PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, log);
						 res.result = null;
					 }
				 }
				 return res;
			 }
			 case DataType.BYTEARRAY: {
				 DataByteArray dba;
				 Result res = in.getNextDataByteArray();
				 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
					 if (castNotNeeded) {
						 return res;
					 }
					 try {
						 dba = (DataByteArray) res.result;
					 }
					 catch (ClassCastException e) {
						 if (DataType.findType(res.result) == castToType) {
							 castNotNeeded = true;
							 return res;
						 }
						 else {
							 int errCode = 1081;
							 String msg = ""Cannot cast to map. Expected bytearray but received: "" + DataType.findTypeName(res.result);
							 throw new ExecException(msg, errCode, PigException.INPUT, e);
						 }
					 }
					 try {
						 if (null != caster) {
							 res.result = caster.bytesToMap(dba.get(), fieldSchema);
						 }
						 else {
							 int errCode = 1075;
							 String msg = unknownByteArrayErrorMessage + ""map for "" + this.getOriginalLocations();
							 throw new ExecException(msg, errCode, PigException.INPUT);
						 }
					 }
					 catch (ExecException ee) {
						 throw ee;
					 }
					 catch (IOException e) {
						 log.error(""Error while casting from ByteArray to Map"");
					 }
				 }
				 return res;
			 }
			 case DataType.TUPLE: case DataType.BAG: case DataType.INTEGER: case DataType.DOUBLE: case DataType.LONG: case DataType.DATETIME: case DataType.FLOAT: case DataType.CHARARRAY: case DataType.BOOLEAN: case DataType.BIGINTEGER: case DataType.BIGDECIMAL: return error();
		 }
		 return error();
	 }
	 public Result getNextDataByteArray() throws ExecException {
		 PhysicalOperator in = inputs.get(0);
		 Byte resultType = in.getResultType();
		 if (resultType != DataType.BYTEARRAY) return error();
		 DataByteArray dba = null;
		 Result res = in.getNextDataByteArray();
		 if (res.returnStatus == POStatus.STATUS_OK && res.result != null) {
			 try {
				 dba = (DataByteArray) res.result;
			 }
			 catch (ClassCastException e) {
				 return error();
			 }
			 if (dba != null) return res;
		 }
		 return res;
	 }
	 private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException {
		 is.defaultReadObject();
		 instantiateFunc();
	 }
	 public POCast clone() throws CloneNotSupportedException {
		 POCast clone = new POCast(new OperatorKey(mKey.scope, NodeIdGenerator .getGenerator().getNextNodeId(mKey.scope)));
		 clone.cloneHelper(this);
		 clone.funcSpec = funcSpec;
		 clone.fieldSchema = fieldSchema;
		 try {
			 clone.instantiateFunc();
		 }
		 catch (IOException e) {
			 CloneNotSupportedException cnse = new CloneNotSupportedException();
			 cnse.initCause(e);
			 throw cnse;
		 }
		 return clone;
	 }
	 public List<ExpressionOperator> getChildExpressions() {
		 if (child == null) {
			 child = new ArrayList<ExpressionOperator>();
			 if (inputs.get(0) instanceof ExpressionOperator) {
				 child.add( (ExpressionOperator)inputs.get(0));
			 }
		 }
		 return child;
	 }
	 public void setFieldSchema(ResourceFieldSchema s) {
		 fieldSchema = s;
	 }
	 public FuncSpec getFuncSpec() {
		 return funcSpec;
	 }
	 public Tuple illustratorMarkup(Object in, Object out, int eqClassIndex) {
		 return (Tuple) out;
	 }
}",1,0,0,0
"protected void chore() {
	 if (this.bulkAssign) return;
	 synchronized (regionsInTransition) {
		 long now = System.currentTimeMillis();
		 for (RegionState regionState : regionsInTransition.values()) {
			 if(regionState.getStamp() + timeout <= now) {
				 HRegionInfo regionInfo = regionState.getRegion();
				 LOG.info(""Regions in transition timed out: "" + regionState);
				 switch (regionState.getState()) {
					 case CLOSED: LOG.info(""Region "" + regionInfo.getEncodedName() + "" has been CLOSED for too long, waiting on queued "" + ""ClosedRegionHandler to run or server shutdown"");
					 synchronized(regionState) {
						 regionState.update(regionState.getState());
					 }
					 break;
					 case OFFLINE: LOG.info(""Region has been OFFLINE for too long, "" + ""reassigning "" + regionInfo.getRegionNameAsString() + "" to a random server"");
					 assign(regionState.getRegion(), false);
					 break;
					 case PENDING_OPEN: LOG.info(""Region has been PENDING_OPEN for too "" + ""long, reassigning region="" + regionInfo.getRegionNameAsString());
					 assign(regionState.getRegion(), false, true);
					 break;
					 case OPENING: LOG.info(""Region has been OPENING for too "" + ""long, reassigning region="" + regionInfo.getRegionNameAsString());
					 try {
						 String node = ZKAssign.getNodeName(watcher, regionInfo.getEncodedName());
						 Stat stat = new Stat();
						 RegionTransitionData data = ZKAssign.getDataNoWatch(watcher, node, stat);
						 if (data.getEventType() == EventType.RS_ZK_REGION_OPENED) {
							 LOG.debug(""Region has transitioned to OPENED, allowing "" + ""watched event handlers to process"");
							 break;
						 }
						 else if (data.getEventType() != EventType.RS_ZK_REGION_OPENING) {
							 LOG.warn(""While timing out a region in state OPENING, "" + ""found ZK node in unexpected state: "" + data.getEventType());
							 break;
						 }
						 try {
							 data = new RegionTransitionData( EventType.M_ZK_REGION_OFFLINE, regionInfo.getRegionName(), master.getServerName());
							 if (ZKUtil.setData(watcher, node, data.getBytes(), stat.getVersion())) {
								 ZKUtil.getDataAndWatch(watcher, node);
								 LOG.info(""Successfully transitioned region="" + regionInfo.getRegionNameAsString() + "" into OFFLINE"" + "" and forcing a new assignment"");
								 assign(regionState, false, true);
							 }
						 }
						 catch (KeeperException.NoNodeException nne) {
						 }
					 }
					 catch (KeeperException ke) {
						 LOG.error(""Unexpected ZK exception timing out CLOSING region"", ke);
						 break;
					 }
					 break;
					 case OPEN: LOG.error(""Region has been OPEN for too long, "" + ""we don't know where region was opened so can't do anything"");
					 break;
					 case PENDING_CLOSE: LOG.info(""Region has been PENDING_CLOSE for too "" + ""long, running forced unassign again on region="" + regionInfo.getRegionNameAsString());
					 try {
						 if (!ZKUtil.watchAndCheckExists(watcher, ZKAssign.getNodeName(watcher, regionInfo.getEncodedName()))) {
							 unassign(regionInfo, true);
						 }
					 }
					 catch (NoNodeException e) {
						 LOG.debug(""Node no longer existed so not forcing another "" + ""unassignment"");
					 }
					 catch (KeeperException e) {
						 LOG.warn(""Unexpected ZK exception timing out a region "" + ""close"", e);
					 }
					 break;
					 case CLOSING: LOG.info(""Region has been CLOSING for too "" + ""long, this should eventually complete or the server will "" + ""expire, doing nothing"");
					 break;
				 }
			 }
		 }
	 }
 }",0,0,1,0
"public final class JUnitHelper {
	 public static final String JUNIT_PARAMETERS = ""org.apache.chemistry.opencmis.tck.junit.parameters"";
	 private JUnitHelper() {
	 }
	 public static void run(CmisTest test) throws Exception {
		 run(new WrapperCmisTestGroup(test));
	 }
	 public static void run(CmisTestGroup group) throws Exception {
		 JUnitRunner runner = new JUnitRunner();
		 String parametersFile = System.getProperty(JUNIT_PARAMETERS);
		 if (parametersFile == null) {
			 runner.setParameters(null);
		 }
		 else {
			 runner.loadParameters(new File(parametersFile));
		 }
		 runner.addGroup(group);
		 runner.run(new JUnitProgressMonitor());
		 CmisTestReport report = new TextReport();
		 report.createReport(runner.getParameters(), runner.getGroups(), new PrintWriter(System.out));
		 checkForFailures(runner);
	 }
	 private static void checkForFailures(JUnitRunner runner) {
		 for (CmisTestGroup group : runner.getGroups()) {
			 for (CmisTest test : group.getTests()) {
				 for (CmisTestResult result : test.getResults()) {
					 if (result.getStatus().getLevel() >= CmisTestResultStatus.FAILURE.getLevel()) {
						 Assert.fail(result.getMessage());
					 }
				 }
			 }
		 }
	 }
	 private static class JUnitRunner extends AbstractRunner {
	 }
	 private static class JUnitProgressMonitor implements CmisTestProgressMonitor {
		 public void startGroup(CmisTestGroup group) {
			 System.out.println(group.getName() + "" ("" + group.getTests().size() + "" tests)"");
		 }
		 public void endGroup(CmisTestGroup group) {
		 }
		 public void startTest(CmisTest test) {
			 System.out.println("" "" + test.getName());
		 }
		 public void endTest(CmisTest test) {
		 }
		 public void message(String msg) {
			 System.out.println(msg);
		 }
	 }
}",0,0,0,0
"public void setHeader(String name, String value){
	if (isMimeResponse && !committed){
		ArrayList<String> headerList = getHeaderList(name, true);
		headerList.clear();
		headerList.add(value);
	}
}",0,0,0,0
"private String headFilter(String line) {
	 linesRead++;
	 if (skip > 0) {
		 if ((linesRead - 1) < skip) {
			 return null;
		 }
	 }
	 if (lines > 0) {
		 if (linesRead > (lines + skip)) {
			 return null;
		 }
	 }
	 return line;
 }",0,0,0,0
"public static class list_sentry_privileges_for_provider<I extends Iface> extends org.apache.thrift.ProcessFunction<I, list_sentry_privileges_for_provider_args> {
	 public list_sentry_privileges_for_provider() {
		 super(""list_sentry_privileges_for_provider"");
	 }
	 public list_sentry_privileges_for_provider_args getEmptyArgsInstance() {
		 return new list_sentry_privileges_for_provider_args();
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public list_sentry_privileges_for_provider_result getResult(I iface, list_sentry_privileges_for_provider_args args) throws org.apache.thrift.TException {
		 list_sentry_privileges_for_provider_result result = new list_sentry_privileges_for_provider_result();
		 result.success = iface.list_sentry_privileges_for_provider(args.request);
		 return result;
	 }
 }",0,0,0,0
"public static int getOctalBytes(long value, byte[] buf, int offset, int length) {
	 int idx = length - 1;
	 buf[offset + idx] = 0;
	 --idx;
	 buf[offset + idx] = (byte) ' ';
	 --idx;
	 if (value == 0) {
		 buf[offset + idx] = (byte) '0';
		 --idx;
	 }
	 else {
		 for (long val = value;
		 idx >= 0 && val > 0;
		 --idx) {
			 buf[offset + idx] = (byte) ((byte) '0' + (byte) (val & 7));
			 val = val >> 3;
		 }
	 }
	 for (;
	 idx >= 0;
	 --idx) {
		 buf[offset + idx] = (byte) ' ';
	 }
	 return offset + length;
 }",0,0,0,0
"public void Blit(SurfaceData src, SurfaceData dst, Composite comp, Region clip, int srcx, int srcy, int dstx, int dsty, int w, int h) {
	 Raster srcRast = src.getRaster(srcx, srcy, w, h);
	 IntegerComponentRaster icr = (IntegerComponentRaster) srcRast;
	 int[] srcPix = icr.getDataStorage();
	 WritableRaster dstRast = (WritableRaster) dst.getRaster(dstx, dsty, w, h);
	 ColorModel dstCM = dst.getColorModel();
	 Region roi = CustomComponent.getRegionOfInterest(src, dst, clip, srcx, srcy, dstx, dsty, w, h);
	 SpanIterator si = roi.getSpanIterator();
	 Object dstPix = null;
	 int srcScan = icr.getScanlineStride();
	 srcx -= dstx;
	 srcy -= dsty;
	 int[] span = new int[4];
	 while (si.nextSpan(span)) {
		 int rowoff = (icr.getDataOffset(0) + (srcy + span[1]) * srcScan + (srcx + span[0]));
		 for (int y = span[1];
		 y < span[3];
		 y++) {
			 int off = rowoff;
			 for (int x = span[0];
			 x < span[2];
			 x++) {
				 dstPix = dstCM.getDataElements(srcPix[off++], dstPix);
				 dstRast.setDataElements(x, y, dstPix);
			 }
			 rowoff += srcScan;
		 }
	 }
 }",0,0,1,0
"public void execute() {
	 Message savedMessage = message;
	 try {
		 Mailer mailer = null;
		 boolean autoFound = false;
		 if (encoding.equals(MIME) || (encoding.equals(AUTO) && !autoFound)) {
			 try {
				 Class.forName(""javax.activation.DataHandler"");
				 Class.forName(""javax.mail.internet.MimeMessage"");
				 mailer = (Mailer) ClasspathUtils.newInstance( ""org.apache.tools.ant.taskdefs.email.MimeMailer"", EmailTask.class.getClassLoader(), Mailer.class);
				 autoFound = true;
				 log(""Using MIME mail"", Project.MSG_VERBOSE);
			 }
			 catch (BuildException e) {
				 logBuildException(""Failed to initialise MIME mail: "", e);
			 }
		 }
		 if (!autoFound && ((user != null) || (password != null)) && (encoding.equals(UU) || encoding.equals(PLAIN))) {
			 throw new BuildException(""SMTP auth only possible with MIME mail"");
		 }
		 if (!autoFound && (ssl || starttls) && (encoding.equals(UU) || encoding.equals(PLAIN))) {
			 throw new BuildException(""SSL and STARTTLS only possible with"" + "" MIME mail"");
		 }
		 if (encoding.equals(UU) || (encoding.equals(AUTO) && !autoFound)) {
			 try {
				 mailer = (Mailer) ClasspathUtils.newInstance( ""org.apache.tools.ant.taskdefs.email.UUMailer"", EmailTask.class.getClassLoader(), Mailer.class);
				 autoFound = true;
				 log(""Using UU mail"", Project.MSG_VERBOSE);
			 }
			 catch (BuildException e) {
				 logBuildException(""Failed to initialise UU mail: "", e);
			 }
		 }
		 if (encoding.equals(PLAIN) || (encoding.equals(AUTO) && !autoFound)) {
			 mailer = new PlainMailer();
			 autoFound = true;
			 log(""Using plain mail"", Project.MSG_VERBOSE);
		 }
		 if (mailer == null) {
			 throw new BuildException(""Failed to initialise encoding: "" + encoding);
		 }
		 if (message == null) {
			 message = new Message();
			 message.setProject(getProject());
		 }
		 if (from == null || from.getAddress() == null) {
			 throw new BuildException(""A from element is required"");
		 }
		 if (toList.isEmpty() && ccList.isEmpty() && bccList.isEmpty()) {
			 throw new BuildException(""At least one of to, cc or bcc must "" + ""be supplied"");
		 }
		 if (messageMimeType != null) {
			 if (message.isMimeTypeSpecified()) {
				 throw new BuildException(""The mime type can only be "" + ""specified in one location"");
			 }
			 message.setMimeType(messageMimeType);
		 }
		 if (charset != null) {
			 if (message.getCharset() != null) {
				 throw new BuildException(""The charset can only be "" + ""specified in one location"");
			 }
			 message.setCharset(charset);
		 }
		 Vector files = new Vector();
		 if (attachments != null) {
			 Iterator iter = attachments.iterator();
			 while (iter.hasNext()) {
				 Resource r = (Resource) iter.next();
				 files.addElement(((FileProvider) r.as(FileProvider.class)) .getFile());
			 }
		 }
		 log(""Sending email: "" + subject, Project.MSG_INFO);
		 log(""From "" + from, Project.MSG_VERBOSE);
		 log(""ReplyTo "" + replyToList, Project.MSG_VERBOSE);
		 log(""To "" + toList, Project.MSG_VERBOSE);
		 log(""Cc "" + ccList, Project.MSG_VERBOSE);
		 log(""Bcc "" + bccList, Project.MSG_VERBOSE);
		 mailer.setHost(host);
		 if (port != null) {
			 mailer.setPort(port.intValue());
			 mailer.setPortExplicitlySpecified(true);
		 }
		 else {
			 mailer.setPort(SMTP_PORT);
			 mailer.setPortExplicitlySpecified(false);
		 }
		 mailer.setUser(user);
		 mailer.setPassword(password);
		 mailer.setSSL(ssl);
		 mailer.setEnableStartTLS(starttls);
		 mailer.setMessage(message);
		 mailer.setFrom(from);
		 mailer.setReplyToList(replyToList);
		 mailer.setToList(toList);
		 mailer.setCcList(ccList);
		 mailer.setBccList(bccList);
		 mailer.setFiles(files);
		 mailer.setSubject(subject);
		 mailer.setTask(this);
		 mailer.setIncludeFileNames(includeFileNames);
		 mailer.setHeaders(headers);
		 mailer.setIgnoreInvalidRecipients(ignoreInvalidRecipients);
		 mailer.send();
		 int count = files.size();
		 log(""Sent email with "" + count + "" attachment"" + (count == 1 ? """" : ""s""), Project.MSG_INFO);
	 }
	 catch (BuildException e) {
		 logBuildException(""Failed to send email: "", e);
		 if (failOnError) {
			 throw e;
		 }
	 }
	 catch (Exception e) {
		 log(""Failed to send email: "" + e.getMessage(), Project.MSG_WARN);
		 if (failOnError) {
			 throw new BuildException(e);
		 }
	 }
	 finally {
		 message = savedMessage;
	 }
 }",0,0,1,0
"public static ParsedHookData parse(byte[] b) throws UnsupportedEncodingException {
	ParsedHookData data = new ParsedHookData();
	data.requestHeaders = new HeaderCollection();
	data.responseHeaders = new HeaderCollection();
	String strBuf = new String(b, ""utf-8"");
	String[] arr = strBuf.split(""\r\n"");
	for (int i = 0;
	 i < arr.length;
	 i++) {
		String str = arr[i];
		if (!str.contains(""="")) {
			continue;
		}
		String ln = str;
		int index = ln.indexOf(""="");
		String key = ln.substring(0, index).trim().toLowerCase();
		String val = ln.substring(index + 1).trim();
		if (key.equals(""url"")) {
			data.setUrl(val);
		}
		 else if (key.equals(""file"")) {
			val = XDMUtils.getFileName(val);
			data.setFile(val);
		}
		 else if (key.equals(""req"")) {
			index = val.indexOf("":"");
			if (index > 0) {
				String headerName = val.substring(0, index).trim().toLowerCase();
				String headerValue = val.substring(index + 1).trim();
				if (headerName.equals(""range"") && (!headerValue.startsWith(""bytes=0-""))) {
					data.setPartialResponse(true);
				}
				if (!isBlockedHeader(headerName)) {
					data.requestHeaders.addHeader(headerName, headerValue);
				}
				System.out.println(ln);
			}
		}
		 else if (key.equals(""res"")) {
			index = val.indexOf("":"");
			if (index > 0) {
				String headerName = val.substring(0, index).trim().toLowerCase();
				String headerValue = val.substring(index + 1).trim();
				data.responseHeaders.addHeader(headerName, headerValue);
			}
		}
	}
	if (data.responseHeaders.containsHeader(""content-length"")|| data.responseHeaders.containsHeader(""content-range"")) {
		data.contentLength = NetUtils.getContentLength(data.responseHeaders);
	}
	if (data.responseHeaders.containsHeader(""content-type"")) {
		data.contentType = NetUtils.getCleanContentType(data.responseHeaders.getValue(""content-type""));
	}
	try {
		data.setExt(XDMUtils.getExtension(XDMUtils.getFileName(data.getUrl())));
	}
	 catch (Exception e) {
	}
	return data;
}",0,0,1,0
"public void markCompacted(Collection<SSTableReader> sstables) {
	 replace(sstables, Collections.<SSTableReader>emptyList());
 }",0,0,0,0
"public void write(DataOutput out) throws IOException {
	 out.writeLong(buffer.getLength());
	 out.write(buffer.getData(), 0, buffer.getLength());
 }",0,0,0,0
"public class WicketServlet extends HttpServlet{
	private static final long serialVersionUID = 1L;
	private static final Logger log = LoggerFactory.getLogger(WicketServlet.class);
	protected WicketFilter wicketFilter;
	public final void doGet(final HttpServletRequest servletRequest,final HttpServletResponse servletResponse) throws ServletException, IOException{
		if (wicketFilter.doGet(servletRequest, servletResponse) == false){
			fallback(servletRequest, servletResponse);
		}
	}
	public final void doPost(final HttpServletRequest servletRequest,final HttpServletResponse servletResponse) throws ServletException, IOException{
		if (wicketFilter.doGet(servletRequest, servletResponse) == false){
			fallback(servletRequest, servletResponse);
		}
	}
	private void fallback(HttpServletRequest request, HttpServletResponse response)throws IOException{
		ServletWebRequest req = new ServletWebRequest(request);
		String url = req.getURL();
		if (url.indexOf('?') != -1){
			url = Strings.beforeFirst(url, '?');
		}
		if ((url.length() > 0 && url.charAt(0) != '/') || url.length() == 0){
			url = '/' + url;
		}
		InputStream stream = getServletContext().getResourceAsStream(url);
		String mimeType = getServletContext().getMimeType(url);
		if (stream == null){
			response.sendError(HttpServletResponse.SC_NOT_FOUND);
		}
		else{
			if (mimeType != null){
				response.setContentType(mimeType);
			}
			try{
				Streams.copy(stream, response.getOutputStream());
			}
			finally{
				stream.close();
			}
		}
	}
	public void init() throws ServletException{
		wicketFilter = newWicketFilter();
		wicketFilter.init(new FilterConfig(){
			public ServletContext getServletContext(){
				return WicketServlet.this.getServletContext();
			}
			public Enumeration<String> getInitParameterNames(){
				return WicketServlet.this.getInitParameterNames();
			}
			public String getInitParameter(String name){
				if (WicketFilter.FILTER_MAPPING_PARAM.equals(name)){
					return WicketFilter.SERVLET_PATH_HOLDER;
				}
				return WicketServlet.this.getInitParameter(name);
			}
			public String getFilterName(){
				return WicketServlet.this.getServletName();
			}
		}
		);
	}
	protected WicketFilter newWicketFilter(){
		return new WicketFilter();
	}
	public void destroy(){
		wicketFilter.destroy();
		wicketFilter = null;
	}
	protected long getLastModified(final HttpServletRequest servletRequest){
		return wicketFilter.getLastModified(servletRequest);
	}
}",0,0,0,0
"public class DnsMetrics {
	 public enum PublishStatus {
	 ACCEPTED, REJECTED }
	 public enum CommitStatus {
	 SUCCESS, FAILURE }
	 public enum ActionStatus {
	 SUCCESS, COMMIT_FAILURE, LOCK_FAILURE, BAD_WRITER, BAD_LOCK_INDEX }
	 private static final ImmutableSet<LabelDescriptor> LABEL_DESCRIPTORS_FOR_PUBLISH_REQUESTS = ImmutableSet.of( LabelDescriptor.create(""tld"", ""TLD""), LabelDescriptor.create( ""status"", ""Whether the publish request was accepted or rejected.""));
	 private static final ImmutableSet<LabelDescriptor> LABEL_DESCRIPTORS_FOR_COMMIT = ImmutableSet.of( LabelDescriptor.create(""tld"", ""TLD""), LabelDescriptor.create(""status"", ""Whether writer.commit() succeeded or failed.""), LabelDescriptor.create(""dnsWriter"", ""The DnsWriter used.""));
	 private static final ImmutableSet<LabelDescriptor> LABEL_DESCRIPTORS_FOR_LATENCY = ImmutableSet.of( LabelDescriptor.create(""tld"", ""TLD""), LabelDescriptor.create(""status"", ""Whether the publish succeeded, or why it failed.""), LabelDescriptor.create(""dnsWriter"", ""The DnsWriter used.""));
	 private static final DistributionFitter EXPONENTIAL_FITTER = ExponentialFitter.create(20, 2.0, 100.0);
	 private static final DistributionFitter FIBONACCI_FITTER = FibonacciFitter.create(10946);
	 private static final IncrementableMetric publishDomainRequests = MetricRegistryImpl.getDefault() .newIncrementableMetric( ""/dns/publish_domain_requests"", ""count of publishDomain requests"", ""count"", LABEL_DESCRIPTORS_FOR_PUBLISH_REQUESTS);
	 private static final IncrementableMetric publishHostRequests = MetricRegistryImpl.getDefault() .newIncrementableMetric( ""/dns/publish_host_requests"", ""count of publishHost requests"", ""count"", LABEL_DESCRIPTORS_FOR_PUBLISH_REQUESTS);
	 private static final IncrementableMetric commitCount = MetricRegistryImpl.getDefault() .newIncrementableMetric( ""/dns/commit_requests"", ""Count of writer.commit() calls"", ""count"", LABEL_DESCRIPTORS_FOR_COMMIT);
	 private static final IncrementableMetric domainsCommittedCount = MetricRegistryImpl.getDefault() .newIncrementableMetric( ""/dns/domains_committed"", ""Count of domains committed"", ""count"", LABEL_DESCRIPTORS_FOR_COMMIT);
	 private static final IncrementableMetric hostsCommittedCount = MetricRegistryImpl.getDefault() .newIncrementableMetric( ""/dns/hosts_committed"", ""Count of hosts committed"", ""count"", LABEL_DESCRIPTORS_FOR_COMMIT);
	 private static final EventMetric processingTimePerCommitDist = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/per_batch/processing_time"", ""publishDnsUpdates Processing Time"", ""milliseconds"", LABEL_DESCRIPTORS_FOR_COMMIT, EXPONENTIAL_FITTER);
	 private static final EventMetric normalizedProcessingTimePerCommitDist = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/per_batch/processing_time_per_dns_update"", ""publishDnsUpdates Processing Time, divided by the batch size"", ""milliseconds"", LABEL_DESCRIPTORS_FOR_COMMIT, EXPONENTIAL_FITTER);
	 private static final EventMetric totalBatchSizePerCommitDist = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/per_batch/batch_size"", ""Number of hosts and domains committed in each publishDnsUpdates"", ""count"", LABEL_DESCRIPTORS_FOR_COMMIT, FIBONACCI_FITTER);
	 private static final EventMetric processingTimePerItemDist = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/per_item/processing_time"", ""publishDnsUpdates Processing Time"", ""milliseconds"", LABEL_DESCRIPTORS_FOR_COMMIT, EXPONENTIAL_FITTER);
	 private static final EventMetric normalizedProcessingTimePerItemDist = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/per_item/processing_time_per_dns_update"", ""publishDnsUpdates Processing Time, divided by the batch size"", ""milliseconds"", LABEL_DESCRIPTORS_FOR_COMMIT, EXPONENTIAL_FITTER);
	 private static final EventMetric totalBatchSizePerItemDist = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/per_item/batch_size"", ""Batch sizes for hosts and domains"", ""count"", LABEL_DESCRIPTORS_FOR_COMMIT, FIBONACCI_FITTER);
	 private static final EventMetric updateRequestLatency = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/update_latency"", ""Time elapsed since refresh request was created until it was published"", ""milliseconds"", LABEL_DESCRIPTORS_FOR_LATENCY, EXPONENTIAL_FITTER);
	 private static final EventMetric publishQueueDelay = MetricRegistryImpl.getDefault() .newEventMetric( ""/dns/publish_queue_delay"", ""Time elapsed since the publishDnsUpdates action was created until it was executed"", ""milliseconds"", LABEL_DESCRIPTORS_FOR_LATENCY, EXPONENTIAL_FITTER);
	 RegistryEnvironment registryEnvironment;
	 DnsMetrics() {
	}
	 public void incrementPublishDomainRequests(String tld, long numRequests, PublishStatus status) {
		 if (numRequests > 0) {
			 publishDomainRequests.incrementBy(numRequests, tld, status.name());
		 }
	 }
	 public void incrementPublishHostRequests(String tld, long numRequests, PublishStatus status) {
		 if (numRequests > 0) {
			 publishHostRequests.incrementBy(numRequests, tld, status.name());
		 }
	 }
	 void recordCommit( String tld, String dnsWriter, CommitStatus status, Duration processingDuration, int numberOfDomains, int numberOfHosts) {
		 if (registryEnvironment == RegistryEnvironment.PRODUCTION) {
			 return;
		 }
		 int batchSize = numberOfDomains + numberOfHosts;
		 processingTimePerCommitDist.record( processingDuration.getMillis(), tld, status.name(), dnsWriter);
		 processingTimePerItemDist.record( processingDuration.getMillis(), batchSize, tld, status.name(), dnsWriter);
		 if (batchSize > 0) {
			 normalizedProcessingTimePerCommitDist.record( (double) processingDuration.getMillis() / batchSize, tld, status.name(), dnsWriter);
			 normalizedProcessingTimePerItemDist.record( (double) processingDuration.getMillis() / batchSize, batchSize, tld, status.name(), dnsWriter);
		 }
		 totalBatchSizePerCommitDist.record(batchSize, tld, status.name(), dnsWriter);
		 totalBatchSizePerItemDist.record(batchSize, batchSize, tld, status.name(), dnsWriter);
		 commitCount.increment(tld, status.name(), dnsWriter);
		 domainsCommittedCount.incrementBy(numberOfDomains, tld, status.name(), dnsWriter);
		 hostsCommittedCount.incrementBy(numberOfHosts, tld, status.name(), dnsWriter);
	 }
	 void recordActionResult( String tld, String dnsWriter, ActionStatus status, int numberOfItems, Duration timeSinceUpdateRequest, Duration timeSinceActionEnqueued) {
		 updateRequestLatency.record( timeSinceUpdateRequest.getMillis(), numberOfItems, tld, status.name(), dnsWriter);
		 publishQueueDelay.record(timeSinceActionEnqueued.getMillis(), tld, status.name(), dnsWriter);
	 }
}",0,0,0,0
"public String getRemovalStatus() {
	 return ssProxy.getRemovalStatus();
 }",0,0,0,0
"protected void createCuts(ElementWrapper[] wrappers, int elementOffsetX, int elementOffsetY, boolean createXCuts);",0,0,0,0
"public class VectorMapJoinOptimizedLongHashMultiSet extends VectorMapJoinOptimizedHashMultiSet implements VectorMapJoinLongHashMultiSet {
	 private VectorMapJoinOptimizedLongCommon longCommon;
	 public boolean useMinMax() {
		 return longCommon.useMinMax();
	 }
	 public long min() {
		 return longCommon.min();
	 }
	 public long max() {
		 return longCommon.max();
	 }
	 public JoinResult contains(long key, VectorMapJoinHashMultiSetResult hashMultiSetResult) throws IOException {
		 SerializedBytes serializedBytes = longCommon.serialize(key);
		 return super.contains(serializedBytes.bytes, serializedBytes.offset, serializedBytes.length, hashMultiSetResult);
	 }
	 public VectorMapJoinOptimizedLongHashMultiSet( boolean minMaxEnabled, boolean isOuterJoin, HashTableKeyType hashTableKeyType, MapJoinTableContainer originalTableContainer, ReusableGetAdaptor hashMapRowGetter) {
		 super(originalTableContainer, hashMapRowGetter);
		 longCommon = new VectorMapJoinOptimizedLongCommon(minMaxEnabled, isOuterJoin, hashTableKeyType);
	 }
}",0,0,0,0
"public void addCookie(final Cookie cookie){
	if (httpServletResponse != null){
		httpServletResponse.addCookie(cookie);
	}
}",0,0,0,0
"public class JextEvent{
	 public static final int PROPERTIES_CHANGED = 0;
	 public static final int SYNTAX_MODE_CHANGED = 1;
	 public static final int CHANGED_UPDATE = 2;
	 public static final int INSERT_UPDATE = 3;
	 public static final int REMOVE_UPDATE = 4;
	 public static final int FILE_OPENED = 10;
	 public static final int FILE_CLEARED = 11;
	 public static final int BATCH_MODE_SET = 20;
	 public static final int BATCH_MODE_UNSET = 21;
	 public static final int TEXT_AREA_FOCUS_GAINED = 76;
	 public static final int TEXT_AREA_SELECTED = 77;
	 public static final int TEXT_AREA_OPENED = 78;
	 public static final int TEXT_AREA_CLOSED = 79;
	 public static final int OPENING_WINDOW = 98;
	 public static final int CLOSING_WINDOW = 99;
	 public static final int KILLING_JEXT = 101;
	 private int event;
	 private JextFrame parent;
	 private JextTextArea textArea;
	 public JextEvent(JextFrame parent, int eventType) {
		 this.parent = parent;
		 this.textArea = parent.getTextArea();
		 this.event = eventType;
	 }
	 public JextEvent(JextFrame parent, JextTextArea textArea, int eventType) {
		 this.parent = parent;
		 this.textArea = textArea;
		 this.event = eventType;
	 }
	 public int getWhat() {
		 return event;
	 }
	 public JextFrame getJextFrame() {
		 return parent;
	 }
	 public JextTextArea getTextArea() {
		 return textArea;
	 }
}",0,1,0,0
"private void createP2() {
	remove(prgCircle);
	remove(lblSpeed);
	remove(lblStat);
	remove(segProgress);
	remove(lblDet);
	remove(lblETA);
	remove(this.panel);
	titlePanel.remove(closeBtn);
	titlePanel.remove(minBtn);
	JPanel p2 = new JPanel(null);
	p2.setBounds(0, 60, 350, 190);
	p2.setBackground(ColorResource.getDarkestBgColor());
	txtError = new JTextArea(this.errMsg);
	txtError.setFont(FontResource.getBigFont());
	txtError.setEditable(false);
	txtError.setCaretPosition(0);
	txtError.setWrapStyleWord(true);
	txtError.setLineWrap(true);
	txtError.setBackground(ColorResource.getDarkestBgColor());
	txtError.setForeground(Color.WHITE);
	JScrollPane jsp = new JScrollPane(txtError);
	jsp.setBounds(25, 20, 300, 100);
	jsp.setBorder(null);
	CustomButton exitBtn = new CustomButton();
	exitBtn.setText(StringResource.get(""MSG_OK""));
	applyStyle(exitBtn);
	exitBtn.setBounds(0, 1, 350, 50);
	exitBtn.setName(""EXIT"");
	JPanel panel2 = new JPanel(null);
	panel2.setBounds(0, 140, 350, 50);
	panel2.setBackground(Color.DARK_GRAY);
	panel2.add(exitBtn);
	p2.add(jsp);
	p2.add(panel2);
	add(p2);
	titleLbl.setText(StringResource.get(""MSG_FAILED""));
	invalidate();
	repaint();
}",0,0,1,0
"public boolean isDirectory(UTF8 src) throws IOException {
	 return namenode.isDir(src.toString());
 }",0,0,0,0
"public class Context{
	 public static final int VERSION_UNKNOWN = -1;
	 public static final int VERSION_DEFAULT = 0;
	 public static final int VERSION_1_0 = 100;
	 public static final int VERSION_1_1 = 110;
	 public static final int VERSION_1_2 = 120;
	 public static final int VERSION_1_3 = 130;
	 public static final int VERSION_1_4 = 140;
	 public static final int VERSION_1_5 = 150;
	 public static final int VERSION_1_6 = 160;
	 public static final int FEATURE_NON_ECMA_GET_YEAR = 1;
	 public static final int FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME = 2;
	 public static final int FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER = 3;
	 public static final int FEATURE_TO_STRING_AS_SOURCE = 4;
	 public static final int FEATURE_PARENT_PROTO_PROPRTIES = 5;
	 public static final int FEATURE_E4X = 6;
	 public static final int FEATURE_DYNAMIC_SCOPE = 7;
	 public static final int FEATURE_STRICT_VARS = 8;
	 public static final int FEATURE_STRICT_EVAL = 9;
	 public static final String languageVersionProperty = ""language version"";
	 public static final String errorReporterProperty = ""error reporter"";
	 public static final Object[] emptyArgs = ScriptRuntime.emptyArgs;
	 public Context() {
		 setLanguageVersion(VERSION_DEFAULT);
		 optimizationLevel = codegenClass != null ? 0 : -1;
	 }
	 public static Context enter() {
		 return enter(null);
	 }
	 public static Context enter(Context cx) {
		 Context[] storage = getThreadContextStorage();
		 Context old;
		 if (storage != null) {
			 old = storage[0];
		 }
		 else {
			 old = getCurrentContext_jdk11();
		 }
		 if (old != null) {
			 if (cx != null && cx != old && cx.enterCount != 0) {
				 throw new IllegalArgumentException( ""Cannot enter Context active on another thread"");
			 }
			 if (old.factory != null) {
				 return old;
			 }
			 if (old.sealed) onSealedMutation();
			 cx = old;
		 }
		 else {
			 if (cx == null) {
				 cx = ContextFactory.getGlobal().makeContext();
			 }
			 else {
				 if (cx.sealed) onSealedMutation();
			 }
			 if (cx.enterCount != 0 || cx.factory != null) {
				 throw new IllegalStateException();
			 }
			 if (!cx.creationEventWasSent) {
				 cx.creationEventWasSent = true;
				 ContextFactory.getGlobal().onContextCreated(cx);
			 }
		 }
		 if (old == null) {
			 if (storage != null) {
				 storage[0] = cx;
			 }
			 else {
				 setThreadContext_jdk11(cx);
			 }
		 }
		 ++cx.enterCount;
		 return cx;
	 }
	 public static void exit() {
		 Context[] storage = getThreadContextStorage();
		 Context cx;
		 if (storage != null) {
			 cx = storage[0];
		 }
		 else {
			 cx = getCurrentContext_jdk11();
		 }
		 if (cx == null) {
			 throw new IllegalStateException( ""Calling Context.exit without previous Context.enter"");
		 }
		 if (cx.factory != null) {
			 return;
		 }
		 if (cx.enterCount < 1) Kit.codeBug();
		 if (cx.sealed) onSealedMutation();
		 --cx.enterCount;
		 if (cx.enterCount == 0) {
			 if (storage != null) {
				 storage[0] = null;
			 }
			 else {
				 setThreadContext_jdk11(null);
			 }
		 }
		 if (cx.enterCount == 0) {
			 ContextFactory.getGlobal().onContextReleased(cx);
		 }
	 }
	 public static Object call(ContextAction action) {
		 return call(ContextFactory.getGlobal(), action);
	 }
	 public static Object call(ContextFactory factory, Callable callable, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (factory == null) {
			 factory = ScriptRuntime.getContextFactory(scope);
		 }
		 Context[] storage = getThreadContextStorage();
		 Context cx;
		 if (storage != null) {
			 cx = storage[0];
		 }
		 else {
			 cx = getCurrentContext_jdk11();
		 }
		 if (cx != null) {
			 if (cx.factory != null) {
				 return callable.call(cx, scope, thisObj, args);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 return callable.call(cx, scope, thisObj, args);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
		 }
		 cx = prepareNewContext(factory, storage);
		 try {
			 return callable.call(cx, scope, thisObj, args);
		 }
		 finally {
			 releaseContext(storage, cx);
		 }
	 }
	 static Object call(ContextFactory factory, ContextAction action) {
		 Context[] storage = getThreadContextStorage();
		 Context cx;
		 if (storage != null) {
			 cx = storage[0];
		 }
		 else {
			 cx = getCurrentContext_jdk11();
		 }
		 if (cx != null) {
			 if (cx.factory != null) {
				 return action.run(cx);
			 }
			 else {
				 cx.factory = factory;
				 try {
					 return action.run(cx);
				 }
				 finally {
					 cx.factory = null;
				 }
			 }
		 }
		 cx = prepareNewContext(factory, storage);
		 try {
			 return action.run(cx);
		 }
		 finally {
			 releaseContext(storage, cx);
		 }
	 }
	 private static Context prepareNewContext(ContextFactory factory, Context[] storage) {
		 Context cx = factory.makeContext();
		 if (cx.factory != null || cx.enterCount != 0) {
			 throw new IllegalStateException(""factory.makeContext() returned Context instance already associated with some thread"");
		 }
		 cx.factory = factory;
		 factory.onContextCreated(cx);
		 if (factory.isSealed() && !cx.isSealed()) {
			 cx.seal(null);
		 }
		 if (storage != null) {
			 storage[0] = cx;
		 }
		 else {
			 setThreadContext_jdk11(cx);
		 }
		 return cx;
	 }
	 private static void releaseContext(Context[] storage, Context cx) {
		 if (storage != null) {
			 storage[0] = null;
		 }
		 else {
			 setThreadContext_jdk11(null);
		 }
		 try {
			 cx.factory.onContextReleased(cx);
		 }
		 finally {
			 cx.factory = null;
		 }
	 }
	 public static void addContextListener(ContextListener listener) {
		 String DBG = ""org.mozilla.javascript.tools.debugger.Main"";
		 if (DBG.equals(listener.getClass().getName())) {
			 Class cl = listener.getClass();
			 Class factoryClass = Kit.classOrNull( ""org.mozilla.javascript.ContextFactory"");
			 Class[] sig = {
			 factoryClass }
			;
			 Object[] args = {
			 ContextFactory.getGlobal() }
			;
			 try {
				 Method m = cl.getMethod(""attachTo"", sig);
				 m.invoke(listener, args);
			 }
			 catch (Exception ex) {
				 RuntimeException rex = new RuntimeException();
				 Kit.initCause(rex, ex);
				 throw rex;
			 }
			 return;
		 }
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public static void removeContextListener(ContextListener listener) {
		 ContextFactory.getGlobal().addListener(listener);
	 }
	 public static void disableStaticContextListening() {
		 ContextFactory.getGlobal().disableContextListening();
	 }
	 public static Context getCurrentContext() {
		 Context[] storage = getThreadContextStorage();
		 if (storage != null) {
			 return storage[0];
		 }
		 return getCurrentContext_jdk11();
	 }
	 private static Context[] getThreadContextStorage() {
		 if (threadLocalCx != null) {
			 try {
				 Context[] storage = (Context[])threadLocalGet.invoke(threadLocalCx, null);
				 if (storage == null) {
					 storage = new Context[1];
					 threadLocalSet.invoke(threadLocalCx, new Object[] {
					 storage }
					);
				 }
				 return storage;
			 }
			 catch (Exception ex) {
			 }
		 }
		 return null;
	 }
	 private static Context getCurrentContext_jdk11() {
		 Thread t = Thread.currentThread();
		 return (Context) threadContexts.get(t);
	 }
	 private static void setThreadContext_jdk11(Context cx) {
		 Thread t = Thread.currentThread();
		 if (cx != null) {
			 threadContexts.put(t, cx);
		 }
		 else {
			 threadContexts.remove(t);
		 }
	 }
	 public final ContextFactory getFactory() {
		 ContextFactory result = factory;
		 if (result == null) {
			 result = ContextFactory.getGlobal();
		 }
		 return result;
	 }
	 public final boolean isSealed() {
		 return sealed;
	 }
	 public final void seal(Object sealKey) {
		 if (sealed) onSealedMutation();
		 sealed = true;
		 this.sealKey = sealKey;
	 }
	 public final void unseal(Object sealKey) {
		 if (sealKey == null) throw new IllegalArgumentException();
		 if (this.sealKey != sealKey) throw new IllegalArgumentException();
		 if (!sealed) throw new IllegalStateException();
		 sealed = false;
		 this.sealKey = null;
	 }
	 static void onSealedMutation() {
		 throw new IllegalStateException();
	 }
	 public final int getLanguageVersion() {
		 return version;
	 }
	 public void setLanguageVersion(int version) {
		 if (sealed) onSealedMutation();
		 checkLanguageVersion(version);
		 Object listeners = propertyListeners;
		 if (listeners != null && version != this.version) {
			 firePropertyChangeImpl(listeners, languageVersionProperty, new Integer(this.version), new Integer(version));
		 }
		 this.version = version;
	 }
	 public static boolean isValidLanguageVersion(int version) {
		 switch (version) {
			 case VERSION_DEFAULT: case VERSION_1_0: case VERSION_1_1: case VERSION_1_2: case VERSION_1_3: case VERSION_1_4: case VERSION_1_5: case VERSION_1_6: return true;
		 }
		 return false;
	 }
	 public static void checkLanguageVersion(int version) {
		 if (isValidLanguageVersion(version)) {
			 return;
		 }
		 throw new IllegalArgumentException(""Bad language version: ""+version);
	 }
	 public final String getImplementationVersion() {
		 if (implementationVersion == null) {
			 implementationVersion = ScriptRuntime.getMessage0(""implementation.version"");
		 }
		 return implementationVersion;
	 }
	 public final ErrorReporter getErrorReporter() {
		 if (errorReporter == null) {
			 return DefaultErrorReporter.instance;
		 }
		 return errorReporter;
	 }
	 public final ErrorReporter setErrorReporter(ErrorReporter reporter) {
		 if (sealed) onSealedMutation();
		 if (reporter == null) throw new IllegalArgumentException();
		 ErrorReporter old = getErrorReporter();
		 if (reporter == old) {
			 return old;
		 }
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, errorReporterProperty, old, reporter);
		 }
		 this.errorReporter = reporter;
		 return old;
	 }
	 public final Locale getLocale() {
		 if (locale == null) locale = Locale.getDefault();
		 return locale;
	 }
	 public final Locale setLocale(Locale loc) {
		 if (sealed) onSealedMutation();
		 Locale result = locale;
		 locale = loc;
		 return result;
	 }
	 public final void addPropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.addListener(propertyListeners, l);
	 }
	 public final void removePropertyChangeListener(PropertyChangeListener l) {
		 if (sealed) onSealedMutation();
		 propertyListeners = Kit.removeListener(propertyListeners, l);
	 }
	 final void firePropertyChange(String property, Object oldValue, Object newValue) {
		 Object listeners = propertyListeners;
		 if (listeners != null) {
			 firePropertyChangeImpl(listeners, property, oldValue, newValue);
		 }
	 }
	 private void firePropertyChangeImpl(Object listeners, String property, Object oldValue, Object newValue) {
		 for (int i = 0;
		 ;
		 ++i) {
			 Object l = Kit.getListener(listeners, i);
			 if (l == null) break;
			 if (l instanceof PropertyChangeListener) {
				 PropertyChangeListener pcl = (PropertyChangeListener)l;
				 pcl.propertyChange(new PropertyChangeEvent( this, property, oldValue, newValue));
			 }
		 }
	 }
	 public static void reportWarning(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = Context.getContext();
		 cx.getErrorReporter().warning(message, sourceName, lineno, lineSource, lineOffset);
	 }
	 public static void reportWarning(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportWarning(message, filename, linep[0], null, 0);
	 }
	 public static void reportError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 cx.getErrorReporter().error(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 public static void reportError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 Context.reportError(message, filename, linep[0], null, 0);
	 }
	 public static EvaluatorException reportRuntimeError(String message, String sourceName, int lineno, String lineSource, int lineOffset) {
		 Context cx = getCurrentContext();
		 if (cx != null) {
			 return cx.getErrorReporter(). runtimeError(message, sourceName, lineno, lineSource, lineOffset);
		 }
		 else {
			 throw new EvaluatorException(message, sourceName, lineno, lineSource, lineOffset);
		 }
	 }
	 static EvaluatorException reportRuntimeError0(String messageId) {
		 String msg = ScriptRuntime.getMessage0(messageId);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError1(String messageId, Object arg1) {
		 String msg = ScriptRuntime.getMessage1(messageId, arg1);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError2(String messageId, Object arg1, Object arg2) {
		 String msg = ScriptRuntime.getMessage2(messageId, arg1, arg2);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError3(String messageId, Object arg1, Object arg2, Object arg3) {
		 String msg = ScriptRuntime.getMessage3(messageId, arg1, arg2, arg3);
		 return reportRuntimeError(msg);
	 }
	 static EvaluatorException reportRuntimeError4(String messageId, Object arg1, Object arg2, Object arg3, Object arg4) {
		 String msg = ScriptRuntime.getMessage4(messageId, arg1, arg2, arg3, arg4);
		 return reportRuntimeError(msg);
	 }
	 public static EvaluatorException reportRuntimeError(String message) {
		 int[] linep = {
		 0 }
		;
		 String filename = getSourcePositionFromStack(linep);
		 return Context.reportRuntimeError(message, filename, linep[0], null, 0);
	 }
	 public final ScriptableObject initStandardObjects() {
		 return initStandardObjects(null, false);
	 }
	 public final Scriptable initStandardObjects(ScriptableObject scope) {
		 return initStandardObjects(scope, false);
	 }
	 public ScriptableObject initStandardObjects(ScriptableObject scope, boolean sealed) {
		 return ScriptRuntime.initStandardObjects(this, scope, sealed);
	 }
	 public static Object getUndefinedValue() {
		 return Undefined.instance;
	 }
	 public final Object evaluateString(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 Script script = compileString(source, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final Object evaluateReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 Script script = compileReader(scope, in, sourceName, lineno, securityDomain);
		 if (script != null) {
			 return script.exec(this, scope);
		 }
		 else {
			 return null;
		 }
	 }
	 public final boolean stringIsCompilableUnit(String source) {
		 boolean errorseen = false;
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 compilerEnv.setGeneratingSource(false);
		 Parser p = new Parser(compilerEnv, DefaultErrorReporter.instance);
		 try {
			 p.parse(source, null, 1);
		 }
		 catch (EvaluatorException ee) {
			 errorseen = true;
		 }
		 if (errorseen && p.eof()) return false;
		 else return true;
	 }
	 public final Script compileReader(Scriptable scope, Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 return compileReader(in, sourceName, lineno, securityDomain);
	 }
	 public final Script compileReader(Reader in, String sourceName, int lineno, Object securityDomain) throws IOException {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return (Script) compileImpl(null, in, null, sourceName, lineno, securityDomain, false, null, null);
	 }
	 public final Script compileString(String source, String sourceName, int lineno, Object securityDomain) {
		 if (lineno < 0) {
			 lineno = 0;
		 }
		 return compileString(source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Script compileString(String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Script) compileImpl(null, null, source, sourceName, lineno, securityDomain, false, compiler, compilationErrorReporter);
		 }
		 catch (IOException ex) {
			 throw new RuntimeException();
		 }
	 }
	 public final Function compileFunction(Scriptable scope, String source, String sourceName, int lineno, Object securityDomain) {
		 return compileFunction(scope, source, null, null, sourceName, lineno, securityDomain);
	 }
	 final Function compileFunction(Scriptable scope, String source, Interpreter compiler, ErrorReporter compilationErrorReporter, String sourceName, int lineno, Object securityDomain) {
		 try {
			 return (Function) compileImpl(scope, null, source, sourceName, lineno, securityDomain, true, compiler, compilationErrorReporter);
		 }
		 catch (IOException ioe) {
			 throw new RuntimeException();
		 }
	 }
	 public final String decompileScript(Script script, Scriptable scope, int indent) {
		 return decompileScript(script, indent);
	 }
	 public final String decompileScript(Script script, int indent) {
		 NativeFunction scriptImpl = (NativeFunction) script;
		 return scriptImpl.decompile(indent, 0);
	 }
	 public final String decompileFunction(Function fun, int indent) {
		 if (fun instanceof BaseFunction) return ((BaseFunction)fun).decompile(indent, 0);
		 else return ""function "" + fun.getClassName() + ""() {
		\n\t[native code]\n}
		\n"";
	 }
	 public final String decompileFunctionBody(Function fun, int indent) {
		 if (fun instanceof BaseFunction) {
			 BaseFunction bf = (BaseFunction)fun;
			 return bf.decompile(indent, Decompiler.ONLY_BODY_FLAG);
		 }
		 return ""[native code]\n"";
	 }
	 public final Scriptable newObject(Scriptable scope) {
		 return newObject(scope, ""Object"", ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName) {
		 return newObject(scope, constructorName, ScriptRuntime.emptyArgs);
	 }
	 public final Scriptable newObject(Scriptable scope, String constructorName, Object[] args) {
		 scope = ScriptableObject.getTopLevelScope(scope);
		 Function ctor = ScriptRuntime.getExistingCtor(this, scope, constructorName);
		 if (args == null) {
			 args = ScriptRuntime.emptyArgs;
		 }
		 return ctor.construct(this, scope, args);
	 }
	 public final Scriptable newArray(Scriptable scope, int length) {
		 NativeArray result = new NativeArray(length);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Scriptable newArray(Scriptable scope, Object[] elements) {
		 if (elements.getClass().getComponentType() != ScriptRuntime.ObjectClass) throw new IllegalArgumentException();
		 NativeArray result = new NativeArray(elements);
		 ScriptRuntime.setObjectProtoAndParent(result, scope);
		 return result;
	 }
	 public final Object[] getElements(Scriptable object) {
		 return ScriptRuntime.getArrayElements(object);
	 }
	 public static boolean toBoolean(Object value) {
		 return ScriptRuntime.toBoolean(value);
	 }
	 public static double toNumber(Object value) {
		 return ScriptRuntime.toNumber(value);
	 }
	 public static String toString(Object value) {
		 return ScriptRuntime.toString(value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Scriptable toObject(Object value, Scriptable scope, Class staticType) {
		 return ScriptRuntime.toObject(scope, value);
	 }
	 public static Object javaToJS(Object value, Scriptable scope) {
		 if (value instanceof String || value instanceof Number || value instanceof Boolean || value instanceof Scriptable) {
			 return value;
		 }
		 else if (value instanceof Character) {
			 return String.valueOf(((Character)value).charValue());
		 }
		 else {
			 Context cx = Context.getContext();
			 return cx.getWrapFactory().wrap(cx, scope, value, null);
		 }
	 }
	 public static Object toType(Object value, Class desiredType) throws IllegalArgumentException {
		 return NativeJavaObject.coerceType(desiredType, value, false);
	 }
	 public static RuntimeException throwAsScriptRuntimeEx(Throwable e) {
		 while ((e instanceof InvocationTargetException)) {
			 e = ((InvocationTargetException) e).getTargetException();
		 }
		 if (e instanceof Error) {
			 throw (Error)e;
		 }
		 if (e instanceof EvaluatorException) {
			 throw (EvaluatorException)e;
		 }
		 if (e instanceof EcmaError) {
			 throw (EcmaError)e;
		 }
		 throw new WrappedException(e);
	 }
	 public final boolean isGeneratingDebug() {
		 return generatingDebug;
	 }
	 public final void setGeneratingDebug(boolean generatingDebug) {
		 if (sealed) onSealedMutation();
		 generatingDebugChanged = true;
		 if (generatingDebug && getOptimizationLevel() > 0) setOptimizationLevel(0);
		 this.generatingDebug = generatingDebug;
	 }
	 public final boolean isGeneratingSource() {
		 return generatingSource;
	 }
	 public final void setGeneratingSource(boolean generatingSource) {
		 if (sealed) onSealedMutation();
		 this.generatingSource = generatingSource;
	 }
	 public final int getOptimizationLevel() {
		 return optimizationLevel;
	 }
	 public final void setOptimizationLevel(int optimizationLevel) {
		 if (sealed) onSealedMutation();
		 if (optimizationLevel == -2) {
			 optimizationLevel = -1;
		 }
		 checkOptimizationLevel(optimizationLevel);
		 if (codegenClass == null) optimizationLevel = -1;
		 this.optimizationLevel = optimizationLevel;
	 }
	 public static boolean isValidOptimizationLevel(int optimizationLevel) {
		 return -1 <= optimizationLevel && optimizationLevel <= 9;
	 }
	 public static void checkOptimizationLevel(int optimizationLevel) {
		 if (isValidOptimizationLevel(optimizationLevel)) {
			 return;
		 }
		 throw new IllegalArgumentException( ""Optimization level outside [-1..9]: ""+optimizationLevel);
	 }
	 public final void setSecurityController(SecurityController controller) {
		 if (sealed) onSealedMutation();
		 if (controller == null) throw new IllegalArgumentException();
		 if (securityController != null) {
			 throw new SecurityException(""Can not overwrite existing SecurityController object"");
		 }
		 if (SecurityController.hasGlobal()) {
			 throw new SecurityException(""Can not overwrite existing global SecurityController object"");
		 }
		 securityController = controller;
	 }
	 public final void setClassShutter(ClassShutter shutter) {
		 if (sealed) onSealedMutation();
		 if (shutter == null) throw new IllegalArgumentException();
		 if (classShutter != null) {
			 throw new SecurityException(""Cannot overwrite existing "" + ""ClassShutter object"");
		 }
		 classShutter = shutter;
	 }
	 final ClassShutter getClassShutter() {
		 return classShutter;
	 }
	 public final Object getThreadLocal(Object key) {
		 if (hashtable == null) return null;
		 return hashtable.get(key);
	 }
	 public final void putThreadLocal(Object key, Object value) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) hashtable = new Hashtable();
		 hashtable.put(key, value);
	 }
	 public final void removeThreadLocal(Object key) {
		 if (sealed) onSealedMutation();
		 if (hashtable == null) return;
		 hashtable.remove(key);
	 }
	 public final boolean hasCompileFunctionsWithDynamicScope() {
		 return compileFunctionsWithDynamicScopeFlag;
	 }
	 public final void setCompileFunctionsWithDynamicScope(boolean flag) {
		 if (sealed) onSealedMutation();
		 compileFunctionsWithDynamicScopeFlag = flag;
	 }
	 public static void setCachingEnabled(boolean cachingEnabled) {
	 }
	 private static class WrapHandlerProxy extends WrapFactory {
		 WrapHandler _handler;
		 WrapHandlerProxy(WrapHandler handler) {
			 _handler = handler;
		 }
		 public Object wrap(Context cx, Scriptable scope, Object obj, Class staticType) {
			 if (obj == null) {
				 return obj;
			 }
			 Object result = _handler.wrap(scope, obj, staticType);
			 if (result == null) {
				 result = super.wrap(cx, scope, obj, staticType);
			 }
			 return result;
		 }
		 public Scriptable wrapNewObject(Context cx, Scriptable scope, Object obj) {
			 Object wrap = _handler.wrap(scope, obj, obj.getClass());
			 if (wrap instanceof Scriptable) {
				 return (Scriptable)wrap;
			 }
			 if (wrap == null) {
				 return super.wrapNewObject(cx, scope, obj);
			 }
			 throw new RuntimeException (""Please upgrade from WrapHandler to WrapFactory"");
		 }
	 }
	 public final void setWrapHandler(WrapHandler wrapHandler) {
		 if (sealed) onSealedMutation();
		 if (wrapHandler == null) {
			 setWrapFactory(new WrapFactory());
		 }
		 else {
			 setWrapFactory(new WrapHandlerProxy(wrapHandler));
		 }
	 }
	 public final WrapHandler getWrapHandler() {
		 WrapFactory f = getWrapFactory();
		 if (f instanceof WrapHandlerProxy) {
			 return ((WrapHandlerProxy)f)._handler;
		 }
		 return null;
	 }
	 public final void setWrapFactory(WrapFactory wrapFactory) {
		 if (sealed) onSealedMutation();
		 if (wrapFactory == null) throw new IllegalArgumentException();
		 this.wrapFactory = wrapFactory;
	 }
	 public final WrapFactory getWrapFactory() {
		 if (wrapFactory == null) {
			 wrapFactory = new WrapFactory();
		 }
		 return wrapFactory;
	 }
	 public final Debugger getDebugger() {
		 return debugger;
	 }
	 public final Object getDebuggerContextData() {
		 return debuggerData;
	 }
	 public final void setDebugger(Debugger debugger, Object contextData) {
		 if (sealed) onSealedMutation();
		 this.debugger = debugger;
		 debuggerData = contextData;
	 }
	 public static DebuggableScript getDebuggableView(Script script) {
		 if (script instanceof NativeFunction) {
			 return ((NativeFunction)script).getDebuggableView();
		 }
		 return null;
	 }
	 public boolean hasFeature(int featureIndex) {
		 ContextFactory f = getFactory();
		 return f.hasFeature(this, featureIndex);
	 }
	 public final int getInstructionObserverThreshold() {
		 return instructionThreshold;
	 }
	 public final void setInstructionObserverThreshold(int threshold) {
		 if (sealed) onSealedMutation();
		 if (threshold < 0) throw new IllegalArgumentException();
		 instructionThreshold = threshold;
	 }
	 protected void observeInstructionCount(int instructionCount) {
		 ContextFactory f = getFactory();
		 f.observeInstructionCount(this, instructionCount);
	 }
	 public GeneratedClassLoader createClassLoader(ClassLoader parent) {
		 ContextFactory f = getFactory();
		 return f.createClassLoader(parent);
	 }
	 public final ClassLoader getApplicationClassLoader() {
		 if (applicationClassLoader == null) {
			 Class cxClass = this.getClass();
			 ClassLoader loader = cxClass.getClassLoader();
			 if (method_getContextClassLoader != null) {
				 Thread thread = Thread.currentThread();
				 ClassLoader threadLoader = null;
				 try {
					 threadLoader = (ClassLoader)method_getContextClassLoader. invoke(thread, ScriptRuntime.emptyArgs);
				 }
				 catch (Exception ex) {
				 }
				 if (threadLoader != null && threadLoader != loader) {
					 if (testIfCanUseLoader(threadLoader, cxClass)) {
						 return threadLoader;
					 }
				 }
			 }
			 applicationClassLoader = loader;
		 }
		 return applicationClassLoader;
	 }
	 public final void setApplicationClassLoader(ClassLoader loader) {
		 if (sealed) onSealedMutation();
		 if (loader == null) {
			 applicationClassLoader = null;
			 return;
		 }
		 if (!testIfCanUseLoader(loader, this.getClass())) {
			 throw new IllegalArgumentException( ""Loader can not resolve Rhino classes"");
		 }
		 applicationClassLoader = loader;
	 }
	 private static boolean testIfCanUseLoader(ClassLoader loader, Class cxClass) {
		 Class x = Kit.classOrNull(loader, cxClass.getName());
		 if (x != cxClass) {
			 return false;
		 }
		 return true;
	 }
	 static Context getContext() {
		 Context cx = getCurrentContext();
		 if (cx == null) {
			 throw new RuntimeException( ""No Context associated with current Thread"");
		 }
		 return cx;
	 }
	 private Object compileImpl(Scriptable scope, Reader sourceReader, String sourceString, String sourceName, int lineno, Object securityDomain, boolean returnFunction, Interpreter compiler, ErrorReporter compilationErrorReporter) throws IOException {
		 if (securityDomain != null && securityController == null) {
			 throw new IllegalArgumentException( ""securityDomain should be null if setSecurityController() was never called"");
		 }
		 if (!(sourceReader == null ^ sourceString == null)) Kit.codeBug();
		 if (!(scope == null ^ returnFunction)) Kit.codeBug();
		 CompilerEnvirons compilerEnv = new CompilerEnvirons();
		 compilerEnv.initFromContext(this);
		 if (compilationErrorReporter == null) {
			 compilationErrorReporter = compilerEnv.getErrorReporter();
		 }
		 if (debugger != null) {
			 if (sourceReader != null) {
				 sourceString = Kit.readReader(sourceReader);
				 sourceReader = null;
			 }
		 }
		 Parser p = new Parser(compilerEnv, compilationErrorReporter);
		 ScriptOrFnNode tree;
		 if (sourceString != null) {
			 tree = p.parse(sourceString, sourceName, lineno);
		 }
		 else {
			 tree = p.parse(sourceReader, sourceName, lineno);
		 }
		 if (returnFunction) {
			 if (!(tree.getFunctionCount() == 1 && tree.getFirstChild() != null && tree.getFirstChild().getType() == Token.FUNCTION)) {
				 throw new IllegalArgumentException( ""compileFunction only accepts source with single JS function: ""+sourceString);
			 }
		 }
		 if (compiler == null) {
			 compiler = createCompiler();
		 }
		 String encodedSource = p.getEncodedSource();
		 Object bytecode = compiler.compile(compilerEnv, tree, encodedSource, returnFunction);
		 if (debugger != null) {
			 if (sourceString == null) Kit.codeBug();
			 if (bytecode instanceof DebuggableScript) {
				 DebuggableScript dscript = (DebuggableScript)bytecode;
				 notifyDebugger_r(this, dscript, sourceString);
			 }
			 else {
				 throw new RuntimeException(""NOT SUPPORTED"");
			 }
		 }
		 Object result;
		 if (returnFunction) {
			 result = compiler.createFunctionObject(this, scope, bytecode, securityDomain);
		 }
		 else {
			 result = compiler.createScriptObject(bytecode, securityDomain);
		 }
		 return result;
	 }
	 private static void notifyDebugger_r(Context cx, DebuggableScript dscript, String debugSource) {
		 cx.debugger.handleCompilationDone(cx, dscript, debugSource);
		 for (int i = 0;
		 i != dscript.getFunctionCount();
		 ++i) {
			 notifyDebugger_r(cx, dscript.getFunction(i), debugSource);
		 }
	 }
	 private static Class codegenClass = Kit.classOrNull( ""org.mozilla.javascript.optimizer.Codegen"");
	 private Interpreter createCompiler() {
		 Interpreter result = null;
		 if (optimizationLevel >= 0 && codegenClass != null) {
			 result = (Interpreter)Kit.newInstanceOrNull(codegenClass);
		 }
		 if (result == null) {
			 result = new Interpreter();
		 }
		 return result;
	 }
	 static String getSourcePositionFromStack(int[] linep) {
		 Context cx = getCurrentContext();
		 if (cx == null) return null;
		 if (cx.interpreterLineCounting != null) {
			 return Interpreter.getSourcePositionFromStack(cx, linep);
		 }
		 CharArrayWriter writer = new CharArrayWriter();
		 RuntimeException re = new RuntimeException();
		 re.printStackTrace(new PrintWriter(writer));
		 String s = writer.toString();
		 int open = -1;
		 int close = -1;
		 int colon = -1;
		 for (int i=0;
		 i < s.length();
		 i++) {
			 char c = s.charAt(i);
			 if (c == ':') colon = i;
			 else if (c == '(') open = i;
			 else if (c == ')') close = i;
			 else if (c == '\n' && open != -1 && close != -1 && colon != -1 && open < colon && colon < close) {
				 String fileStr = s.substring(open + 1, colon);
				 if (!fileStr.endsWith("".java"")) {
					 String lineStr = s.substring(colon + 1, close);
					 try {
						 linep[0] = Integer.parseInt(lineStr);
						 if (linep[0] < 0) {
							 linep[0] = 0;
						 }
						 return fileStr;
					 }
					 catch (NumberFormatException e) {
					 }
				 }
				 open = close = colon = -1;
			 }
		 }
		 return null;
	 }
	 RegExpProxy getRegExpProxy() {
		 if (regExpProxy == null) {
			 Class cl = Kit.classOrNull( ""org.mozilla.javascript.regexp.RegExpImpl"");
			 if (cl != null) {
				 regExpProxy = (RegExpProxy)Kit.newInstanceOrNull(cl);
			 }
		 }
		 return regExpProxy;
	 }
	 final boolean isVersionECMA1() {
		 return version == VERSION_DEFAULT || version >= VERSION_1_3;
	 }
	 SecurityController getSecurityController() {
		 SecurityController global = SecurityController.global();
		 if (global != null) {
			 return global;
		 }
		 return securityController;
	 }
	 public final boolean isGeneratingDebugChanged() {
		 return generatingDebugChanged;
	 }
	 public void addActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames == null) activationNames = new Hashtable(5);
		 activationNames.put(name, name);
	 }
	 public final boolean isActivationNeeded(String name) {
		 return activationNames != null && activationNames.containsKey(name);
	 }
	 public void removeActivationName(String name) {
		 if (sealed) onSealedMutation();
		 if (activationNames != null) activationNames.remove(name);
	 }
	 private static Hashtable threadContexts = new Hashtable(11);
	 private static Object threadLocalCx;
	 private static Method threadLocalGet;
	 private static Method threadLocalSet;
	 static {
		 Class cl = Kit.classOrNull(""java.lang.ThreadLocal"");
		 if (cl != null) {
			 try {
				 threadLocalGet = cl.getMethod(""get"", null);
				 threadLocalSet = cl.getMethod(""set"", new Class[] {
				 ScriptRuntime.ObjectClass }
				);
				 threadLocalCx = cl.newInstance();
			 }
			 catch (Exception ex) {
			 }
		 }
	 }
	 private static Method method_getContextClassLoader;
	 static {
		 Class threadClass = Kit.classOrNull(""java.lang.Thread"");
		 if (threadClass != null) {
			 try {
				 method_getContextClassLoader = threadClass.getDeclaredMethod(""getContextClassLoader"", new Class[0]);
			 }
			 catch (Exception ex) {
			 }
		 }
	 }
	 private static String implementationVersion;
	 private ContextFactory factory;
	 private boolean sealed;
	 private Object sealKey;
	 Scriptable topCallScope;
	 NativeCall currentActivationCall;
	 XMLLib cachedXMLLib;
	 ObjToIntMap iterating;
	 Object interpreterSecurityDomain;
	 int version;
	 private SecurityController securityController;
	 private ClassShutter classShutter;
	 private ErrorReporter errorReporter;
	 private RegExpProxy regExpProxy;
	 private Locale locale;
	 private boolean generatingDebug;
	 private boolean generatingDebugChanged;
	 private boolean generatingSource=true;
	 boolean compileFunctionsWithDynamicScopeFlag;
	 boolean useDynamicScope;
	 private int optimizationLevel;
	 private WrapFactory wrapFactory;
	 Debugger debugger;
	 private Object debuggerData;
	 private int enterCount;
	 private Object propertyListeners;
	 private Hashtable hashtable;
	 private ClassLoader applicationClassLoader;
	 private boolean creationEventWasSent;
	 Hashtable activationNames;
	 Object interpreterLineCounting;
	 int instructionCount;
	 int instructionThreshold;
	 int scratchIndex;
	 long scratchUint32;
	 Scriptable scratchScriptable;
	 Scriptable scratchRefTarget;
}",1,0,0,0
"public boolean accept(Class<T> scope, String path){
	IPackageResourceGuard guard = Application.get().getResourceSettings().getPackageResourceGuard();
	return guard.accept(scope, path);
}",0,0,0,0
"public boolean hasMoreTokens() {
	 if (lookahead != null) {
		 return true;
	 }
	 return tokenizer.hasMoreTokens();
 }",0,0,0,0
"interface Failover {
	 String PREFIX = HdfsClientConfigKeys.PREFIX + ""failover."";
	 String PROXY_PROVIDER_KEY_PREFIX = PREFIX + ""proxy.provider"";
	 String MAX_ATTEMPTS_KEY = PREFIX + ""max.attempts"";
	 int MAX_ATTEMPTS_DEFAULT = 15;
	 String SLEEPTIME_BASE_KEY = PREFIX + ""sleep.base.millis"";
	 int SLEEPTIME_BASE_DEFAULT = 500;
	 String SLEEPTIME_MAX_KEY = PREFIX + ""sleep.max.millis"";
	 int SLEEPTIME_MAX_DEFAULT = 15000;
	 String CONNECTION_RETRIES_KEY = PREFIX + ""connection.retries"";
	 int CONNECTION_RETRIES_DEFAULT = 0;
	 String CONNECTION_RETRIES_ON_SOCKET_TIMEOUTS_KEY = PREFIX + ""connection.retries.on.timeouts"";
	 int CONNECTION_RETRIES_ON_SOCKET_TIMEOUTS_DEFAULT = 0;
	 String RANDOM_ORDER = PREFIX + ""random.order"";
	 boolean RANDOM_ORDER_DEFAULT = false;
	 String RESOLVE_ADDRESS_NEEDED_KEY = PREFIX + ""resolve-needed"";
	 boolean RESOLVE_ADDRESS_NEEDED_DEFAULT = false;
	 String RESOLVE_SERVICE_KEY = PREFIX + ""resolver.impl"";
 }",0,1,0,0
"public class JFile {
	 private String mName;
	 private ArrayList mInclFiles;
	 private ArrayList mRecords;
	 public JFile(String name, ArrayList inclFiles, ArrayList recList) {
		 mName = name;
		 mInclFiles = inclFiles;
		 mRecords = recList;
	 }
	 String getName() {
		 int idx = mName.lastIndexOf('/');
		 return (idx > 0) ? mName.substring(idx) : mName;
	 }
	 public void genCode(String language) throws IOException {
		 if (""c++"".equals(language)) {
			 CppGenerator gen = new CppGenerator(mName, mInclFiles, mRecords);
			 gen.genCode();
		 }
		 else if (""java"".equals(language)) {
			 JavaGenerator gen = new JavaGenerator(mName, mInclFiles, mRecords);
			 gen.genCode();
		 }
		 else {
			 System.out.println(""Cannnot recognize language:""+language);
			 System.exit(1);
		 }
	 }
}",0,0,0,0
"public static class BaseColumnInfo implements Serializable {
	 private static final long serialVersionUID = 1L;
	 private TableAliasInfo tabAlias;
	 private FieldSchema column;
	 public TableAliasInfo getTabAlias() {
		 return tabAlias;
	 }
	 public void setTabAlias(TableAliasInfo tabAlias) {
		 this.tabAlias = tabAlias;
	 }
	 public FieldSchema getColumn() {
		 return column;
	 }
	 public void setColumn(FieldSchema column) {
		 this.column = column;
	 }
	 public String toString() {
		 return tabAlias + "":"" + column;
	 }
	 public int hashCode() {
		 return (column != null ? column.hashCode() : 7) + (tabAlias != null ? tabAlias.hashCode() : 11);
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) {
			 return true;
		 }
		 if (!(obj instanceof BaseColumnInfo)) {
			 return false;
		 }
		 BaseColumnInfo ci = (BaseColumnInfo) obj;
		 return (column == null ? ci.column == null : column.equals(ci.column)) && (tabAlias == null ? ci.tabAlias == null : tabAlias.equals(ci.tabAlias));
	 }
 }",0,1,0,0
"public class CBZip2OutputStream extends OutputStream implements BZip2Constants {
	 protected static final int SETMASK = (1 << 21);
	 protected static final int CLEARMASK = (~SETMASK);
	 protected static final int GREATER_ICOST = 15;
	 protected static final int LESSER_ICOST = 0;
	 protected static final int SMALL_THRESH = 20;
	 protected static final int DEPTH_THRESH = 10;
	 protected static final int QSORT_STACK_SIZE = 1000;
	 private static void panic() {
		 System.out.println(""panic"");
	 }
	 private void makeMaps() {
		 int i;
		 nInUse = 0;
		 for (i = 0;
		 i < 256;
		 i++) {
			 if (inUse[i]) {
				 seqToUnseq[nInUse] = (char) i;
				 unseqToSeq[i] = (char) nInUse;
				 nInUse++;
			 }
		 }
	 }
	 protected static void hbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen) {
		 int nNodes, nHeap, n1, n2, i, j, k;
		 boolean tooLong;
		 int[] heap = new int[MAX_ALPHA_SIZE + 2];
		 int[] weight = new int[MAX_ALPHA_SIZE * 2];
		 int[] parent = new int[MAX_ALPHA_SIZE * 2];
		 for (i = 0;
		 i < alphaSize;
		 i++) {
			 weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
		 }
		 while (true) {
			 nNodes = alphaSize;
			 nHeap = 0;
			 heap[0] = 0;
			 weight[0] = 0;
			 parent[0] = -2;
			 for (i = 1;
			 i <= alphaSize;
			 i++) {
				 parent[i] = -1;
				 nHeap++;
				 heap[nHeap] = i;
				 {
					 int zz, tmp;
					 zz = nHeap;
					 tmp = heap[zz];
					 while (weight[tmp] < weight[heap[zz >> 1]]) {
						 heap[zz] = heap[zz >> 1];
						 zz >>= 1;
					 }
					 heap[zz] = tmp;
				 }
			 }
			 if (!(nHeap < (MAX_ALPHA_SIZE + 2))) {
				 panic();
			 }
			 while (nHeap > 1) {
				 n1 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 {
					 int zz = 0, yy = 0, tmp = 0;
					 zz = 1;
					 tmp = heap[zz];
					 while (true) {
						 yy = zz << 1;
						 if (yy > nHeap) {
							 break;
						 }
						 if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {
							 yy++;
						 }
						 if (weight[tmp] < weight[heap[yy]]) {
							 break;
						 }
						 heap[zz] = heap[yy];
						 zz = yy;
					 }
					 heap[zz] = tmp;
				 }
				 n2 = heap[1];
				 heap[1] = heap[nHeap];
				 nHeap--;
				 {
					 int zz = 0, yy = 0, tmp = 0;
					 zz = 1;
					 tmp = heap[zz];
					 while (true) {
						 yy = zz << 1;
						 if (yy > nHeap) {
							 break;
						 }
						 if (yy < nHeap && weight[heap[yy + 1]] < weight[heap[yy]]) {
							 yy++;
						 }
						 if (weight[tmp] < weight[heap[yy]]) {
							 break;
						 }
						 heap[zz] = heap[yy];
						 zz = yy;
					 }
					 heap[zz] = tmp;
				 }
				 nNodes++;
				 parent[n1] = parent[n2] = nNodes;
				 weight[nNodes] = ((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) | (1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));
				 parent[nNodes] = -1;
				 nHeap++;
				 heap[nHeap] = nNodes;
				 {
					 int zz = 0, tmp = 0;
					 zz = nHeap;
					 tmp = heap[zz];
					 while (weight[tmp] < weight[heap[zz >> 1]]) {
						 heap[zz] = heap[zz >> 1];
						 zz >>= 1;
					 }
					 heap[zz] = tmp;
				 }
			 }
			 if (!(nNodes < (MAX_ALPHA_SIZE * 2))) {
				 panic();
			 }
			 tooLong = false;
			 for (i = 1;
			 i <= alphaSize;
			 i++) {
				 j = 0;
				 k = i;
				 while (parent[k] >= 0) {
					 k = parent[k];
					 j++;
				 }
				 len[i - 1] = (char) j;
				 if (j > maxLen) {
					 tooLong = true;
				 }
			 }
			 if (!tooLong) {
				 break;
			 }
			 for (i = 1;
			 i < alphaSize;
			 i++) {
				 j = weight[i] >> 8;
				 j = 1 + (j / 2);
				 weight[i] = j << 8;
			 }
		 }
	 }
	 int last;
	 int origPtr;
	 int blockSize100k;
	 boolean blockRandomised;
	 int bytesIn;
	 int bytesOut;
	 int bsBuff;
	 int bsLive;
	 CRC mCrc = new CRC();
	 private boolean[] inUse = new boolean[256];
	 private int nInUse;
	 private char[] seqToUnseq = new char[256];
	 private char[] unseqToSeq = new char[256];
	 private char[] selector = new char[MAX_SELECTORS];
	 private char[] selectorMtf = new char[MAX_SELECTORS];
	 private char[] block;
	 private int[] quadrant;
	 private int[] zptr;
	 private short[] szptr;
	 private int[] ftab;
	 private int nMTF;
	 private int[] mtfFreq = new int[MAX_ALPHA_SIZE];
	 private int workFactor;
	 private int workDone;
	 private int workLimit;
	 private boolean firstAttempt;
	 private int nBlocksRandomised;
	 private int currentChar = -1;
	 private int runLength = 0;
	 public CBZip2OutputStream(OutputStream inStream) throws IOException {
		 this(inStream, 9);
	 }
	 public CBZip2OutputStream(OutputStream inStream, int inBlockSize) throws IOException {
		 block = null;
		 quadrant = null;
		 zptr = null;
		 ftab = null;
		 bsSetStream(inStream);
		 workFactor = 50;
		 if (inBlockSize > 9) {
			 inBlockSize = 9;
		 }
		 if (inBlockSize < 1) {
			 inBlockSize = 1;
		 }
		 blockSize100k = inBlockSize;
		 allocateCompressStructures();
		 initialize();
		 initBlock();
	 }
	 public void write(int bv) throws IOException {
		 int b = (256 + bv) % 256;
		 if (currentChar != -1) {
			 if (currentChar == b) {
				 runLength++;
				 if (runLength > 254) {
					 writeRun();
					 currentChar = -1;
					 runLength = 0;
				 }
			 }
			 else {
				 writeRun();
				 runLength = 1;
				 currentChar = b;
			 }
		 }
		 else {
			 currentChar = b;
			 runLength++;
		 }
	 }
	 private void writeRun() throws IOException {
		 if (last < allowableBlockSize) {
			 inUse[currentChar] = true;
			 for (int i = 0;
			 i < runLength;
			 i++) {
				 mCrc.updateCRC((char) currentChar);
			 }
			 switch (runLength) {
				 case 1: last++;
				 block[last + 1] = (char) currentChar;
				 break;
				 case 2: last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 break;
				 case 3: last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 break;
				 default: inUse[runLength - 4] = true;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) currentChar;
				 last++;
				 block[last + 1] = (char) (runLength - 4);
				 break;
			 }
		 }
		 else {
			 endBlock();
			 initBlock();
			 writeRun();
		 }
	 }
	 boolean closed = false;
	 public void finalize() throws Throwable {
		 close();
	 }
	 public void close() throws IOException {
		 if (closed) {
			 return;
		 }
		 if (runLength > 0) {
			 writeRun();
		 }
		 currentChar = -1;
		 endBlock();
		 endCompression();
		 closed = true;
		 super.close();
		 bsStream.close();
	 }
	 public void flush() throws IOException {
		 super.flush();
		 bsStream.flush();
	 }
	 private int blockCRC, combinedCRC;
	 private void initialize() throws IOException {
		 bytesIn = 0;
		 bytesOut = 0;
		 nBlocksRandomised = 0;
		 bsPutUChar('h');
		 bsPutUChar('0' + blockSize100k);
		 combinedCRC = 0;
	 }
	 private int allowableBlockSize;
	 private void initBlock() {
		 mCrc.initialiseCRC();
		 last = -1;
		 for (int i = 0;
		 i < 256;
		 i++) {
			 inUse[i] = false;
		 }
		 allowableBlockSize = baseBlockSize * blockSize100k - 20;
	 }
	 private void endBlock() throws IOException {
		 blockCRC = mCrc.getFinalCRC();
		 combinedCRC = (combinedCRC << 1) | (combinedCRC >>> 31);
		 combinedCRC ^= blockCRC;
		 doReversibleTransformation();
		 bsPutUChar(0x31);
		 bsPutUChar(0x41);
		 bsPutUChar(0x59);
		 bsPutUChar(0x26);
		 bsPutUChar(0x53);
		 bsPutUChar(0x59);
		 bsPutint(blockCRC);
		 if (blockRandomised) {
			 bsW(1, 1);
			 nBlocksRandomised++;
		 }
		 else {
			 bsW(1, 0);
		 }
		 moveToFrontCodeAndSend();
	 }
	 private void endCompression() throws IOException {
		 bsPutUChar(0x17);
		 bsPutUChar(0x72);
		 bsPutUChar(0x45);
		 bsPutUChar(0x38);
		 bsPutUChar(0x50);
		 bsPutUChar(0x90);
		 bsPutint(combinedCRC);
		 bsFinishedWithStream();
	 }
	 private void hbAssignCodes (int[] code, char[] length, int minLen, int maxLen, int alphaSize) {
		 int n, vec, i;
		 vec = 0;
		 for (n = minLen;
		 n <= maxLen;
		 n++) {
			 for (i = 0;
			 i < alphaSize;
			 i++) {
				 if (length[i] == n) {
					 code[i] = vec;
					 vec++;
				 }
			 }
			;
			 vec <<= 1;
		 }
	 }
	 private void bsSetStream(OutputStream f) {
		 bsStream = f;
		 bsLive = 0;
		 bsBuff = 0;
		 bytesOut = 0;
		 bytesIn = 0;
	 }
	 private void bsFinishedWithStream() throws IOException {
		 while (bsLive > 0) {
			 int ch = (bsBuff >> 24);
			 try {
				 bsStream.write(ch);
			 }
			 catch (IOException e) {
				 throw e;
			 }
			 bsBuff <<= 8;
			 bsLive -= 8;
			 bytesOut++;
		 }
	 }
	 private void bsW(int n, int v) throws IOException {
		 while (bsLive >= 8) {
			 int ch = (bsBuff >> 24);
			 try {
				 bsStream.write(ch);
			 }
			 catch (IOException e) {
				 throw e;
			 }
			 bsBuff <<= 8;
			 bsLive -= 8;
			 bytesOut++;
		 }
		 bsBuff |= (v << (32 - bsLive - n));
		 bsLive += n;
	 }
	 private void bsPutUChar(int c) throws IOException {
		 bsW(8, c);
	 }
	 private void bsPutint(int u) throws IOException {
		 bsW(8, (u >> 24) & 0xff);
		 bsW(8, (u >> 16) & 0xff);
		 bsW(8, (u >> 8) & 0xff);
		 bsW(8, u & 0xff);
	 }
	 private void bsPutIntVS(int numBits, int c) throws IOException {
		 bsW(numBits, c);
	 }
	 private void sendMTFValues() throws IOException {
		 char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];
		 int v, t, i, j, gs, ge, totc, bt, bc, iter;
		 int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;
		 int nGroups, nBytes;
		 alphaSize = nInUse + 2;
		 for (t = 0;
		 t < N_GROUPS;
		 t++) {
			 for (v = 0;
			 v < alphaSize;
			 v++) {
				 len[t][v] = (char) GREATER_ICOST;
			 }
		 }
		 if (nMTF <= 0) {
			 panic();
		 }
		 if (nMTF < 200) {
			 nGroups = 2;
		 }
		 else if (nMTF < 600) {
			 nGroups = 3;
		 }
		 else if (nMTF < 1200) {
			 nGroups = 4;
		 }
		 else if (nMTF < 2400) {
			 nGroups = 5;
		 }
		 else {
			 nGroups = 6;
		 }
		 {
			 int nPart, remF, tFreq, aFreq;
			 nPart = nGroups;
			 remF = nMTF;
			 gs = 0;
			 while (nPart > 0) {
				 tFreq = remF / nPart;
				 ge = gs - 1;
				 aFreq = 0;
				 while (aFreq < tFreq && ge < alphaSize - 1) {
					 ge++;
					 aFreq += mtfFreq[ge];
				 }
				 if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {
					 aFreq -= mtfFreq[ge];
					 ge--;
				 }
				 for (v = 0;
				 v < alphaSize;
				 v++) {
					 if (v >= gs && v <= ge) {
						 len[nPart - 1][v] = (char) LESSER_ICOST;
					 }
					 else {
						 len[nPart - 1][v] = (char) GREATER_ICOST;
					 }
				 }
				 nPart--;
				 gs = ge + 1;
				 remF -= aFreq;
			 }
		 }
		 int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 int[] fave = new int[N_GROUPS];
		 short[] cost = new short[N_GROUPS];
		 for (iter = 0;
		 iter < N_ITERS;
		 iter++) {
			 for (t = 0;
			 t < nGroups;
			 t++) {
				 fave[t] = 0;
			 }
			 for (t = 0;
			 t < nGroups;
			 t++) {
				 for (v = 0;
				 v < alphaSize;
				 v++) {
					 rfreq[t][v] = 0;
				 }
			 }
			 nSelectors = 0;
			 totc = 0;
			 gs = 0;
			 while (true) {
				 if (gs >= nMTF) {
					 break;
				 }
				 ge = gs + G_SIZE - 1;
				 if (ge >= nMTF) {
					 ge = nMTF - 1;
				 }
				 for (t = 0;
				 t < nGroups;
				 t++) {
					 cost[t] = 0;
				 }
				 if (nGroups == 6) {
					 short cost0, cost1, cost2, cost3, cost4, cost5;
					 cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;
					 for (i = gs;
					 i <= ge;
					 i++) {
						 short icv = szptr[i];
						 cost0 += len[0][icv];
						 cost1 += len[1][icv];
						 cost2 += len[2][icv];
						 cost3 += len[3][icv];
						 cost4 += len[4][icv];
						 cost5 += len[5][icv];
					 }
					 cost[0] = cost0;
					 cost[1] = cost1;
					 cost[2] = cost2;
					 cost[3] = cost3;
					 cost[4] = cost4;
					 cost[5] = cost5;
				 }
				 else {
					 for (i = gs;
					 i <= ge;
					 i++) {
						 short icv = szptr[i];
						 for (t = 0;
						 t < nGroups;
						 t++) {
							 cost[t] += len[t][icv];
						 }
					 }
				 }
				 bc = 999999999;
				 bt = -1;
				 for (t = 0;
				 t < nGroups;
				 t++) {
					 if (cost[t] < bc) {
						 bc = cost[t];
						 bt = t;
					 }
				 }
				;
				 totc += bc;
				 fave[bt]++;
				 selector[nSelectors] = (char) bt;
				 nSelectors++;
				 for (i = gs;
				 i <= ge;
				 i++) {
					 rfreq[bt][szptr[i]]++;
				 }
				 gs = ge + 1;
			 }
			 for (t = 0;
			 t < nGroups;
			 t++) {
				 hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);
			 }
		 }
		 rfreq = null;
		 fave = null;
		 cost = null;
		 if (!(nGroups < 8)) {
			 panic();
		 }
		 if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {
			 panic();
		 }
		 {
			 char[] pos = new char[N_GROUPS];
			 char ll_i, tmp2, tmp;
			 for (i = 0;
			 i < nGroups;
			 i++) {
				 pos[i] = (char) i;
			 }
			 for (i = 0;
			 i < nSelectors;
			 i++) {
				 ll_i = selector[i];
				 j = 0;
				 tmp = pos[j];
				 while (ll_i != tmp) {
					 j++;
					 tmp2 = tmp;
					 tmp = pos[j];
					 pos[j] = tmp2;
				 }
				 pos[0] = tmp;
				 selectorMtf[i] = (char) j;
			 }
		 }
		 int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];
		 for (t = 0;
		 t < nGroups;
		 t++) {
			 minLen = 32;
			 maxLen = 0;
			 for (i = 0;
			 i < alphaSize;
			 i++) {
				 if (len[t][i] > maxLen) {
					 maxLen = len[t][i];
				 }
				 if (len[t][i] < minLen) {
					 minLen = len[t][i];
				 }
			 }
			 if (maxLen > 20) {
				 panic();
			 }
			 if (minLen < 1) {
				 panic();
			 }
			 hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);
		 }
		 {
			 boolean[] inUse16 = new boolean[16];
			 for (i = 0;
			 i < 16;
			 i++) {
				 inUse16[i] = false;
				 for (j = 0;
				 j < 16;
				 j++) {
					 if (inUse[i * 16 + j]) {
						 inUse16[i] = true;
					 }
				 }
			 }
			 nBytes = bytesOut;
			 for (i = 0;
			 i < 16;
			 i++) {
				 if (inUse16[i]) {
					 bsW(1, 1);
				 }
				 else {
					 bsW(1, 0);
				 }
			 }
			 for (i = 0;
			 i < 16;
			 i++) {
				 if (inUse16[i]) {
					 for (j = 0;
					 j < 16;
					 j++) {
						 if (inUse[i * 16 + j]) {
							 bsW(1, 1);
						 }
						 else {
							 bsW(1, 0);
						 }
					 }
				 }
			 }
		 }
		 nBytes = bytesOut;
		 bsW (3, nGroups);
		 bsW (15, nSelectors);
		 for (i = 0;
		 i < nSelectors;
		 i++) {
			 for (j = 0;
			 j < selectorMtf[i];
			 j++) {
				 bsW(1, 1);
			 }
			 bsW(1, 0);
		 }
		 nBytes = bytesOut;
		 for (t = 0;
		 t < nGroups;
		 t++) {
			 int curr = len[t][0];
			 bsW(5, curr);
			 for (i = 0;
			 i < alphaSize;
			 i++) {
				 while (curr < len[t][i]) {
					 bsW(2, 2);
					 curr++;
				 }
				 while (curr > len[t][i]) {
					 bsW(2, 3);
					 curr--;
				 }
				 bsW (1, 0);
			 }
		 }
		 nBytes = bytesOut;
		 selCtr = 0;
		 gs = 0;
		 while (true) {
			 if (gs >= nMTF) {
				 break;
			 }
			 ge = gs + G_SIZE - 1;
			 if (ge >= nMTF) {
				 ge = nMTF - 1;
			 }
			 for (i = gs;
			 i <= ge;
			 i++) {
				 bsW(len[selector[selCtr]][szptr[i]], code[selector[selCtr]][szptr[i]]);
			 }
			 gs = ge + 1;
			 selCtr++;
		 }
		 if (!(selCtr == nSelectors)) {
			 panic();
		 }
	 }
	 private void moveToFrontCodeAndSend () throws IOException {
		 bsPutIntVS(24, origPtr);
		 generateMTFValues();
		 sendMTFValues();
	 }
	 private OutputStream bsStream;
	 private void simpleSort(int lo, int hi, int d) {
		 int i, j, h, bigN, hp;
		 int v;
		 bigN = hi - lo + 1;
		 if (bigN < 2) {
			 return;
		 }
		 hp = 0;
		 while (incs[hp] < bigN) {
			 hp++;
		 }
		 hp--;
		 for (;
		 hp >= 0;
		 hp--) {
			 h = incs[hp];
			 i = lo + h;
			 while (true) {
				 if (i > hi) {
					 break;
				 }
				 v = zptr[i];
				 j = i;
				 while (fullGtU(zptr[j - h] + d, v + d)) {
					 zptr[j] = zptr[j - h];
					 j = j - h;
					 if (j <= (lo + h - 1)) {
						 break;
					 }
				 }
				 zptr[j] = v;
				 i++;
				 if (i > hi) {
					 break;
				 }
				 v = zptr[i];
				 j = i;
				 while (fullGtU(zptr[j - h] + d, v + d)) {
					 zptr[j] = zptr[j - h];
					 j = j - h;
					 if (j <= (lo + h - 1)) {
						 break;
					 }
				 }
				 zptr[j] = v;
				 i++;
				 if (i > hi) {
					 break;
				 }
				 v = zptr[i];
				 j = i;
				 while (fullGtU(zptr[j - h] + d, v + d)) {
					 zptr[j] = zptr[j - h];
					 j = j - h;
					 if (j <= (lo + h - 1)) {
						 break;
					 }
				 }
				 zptr[j] = v;
				 i++;
				 if (workDone > workLimit && firstAttempt) {
					 return;
				 }
			 }
		 }
	 }
	 private void vswap(int p1, int p2, int n) {
		 int temp = 0;
		 while (n > 0) {
			 temp = zptr[p1];
			 zptr[p1] = zptr[p2];
			 zptr[p2] = temp;
			 p1++;
			 p2++;
			 n--;
		 }
	 }
	 private char med3(char a, char b, char c) {
		 char t;
		 if (a > b) {
			 t = a;
			 a = b;
			 b = t;
		 }
		 if (b > c) {
			 t = b;
			 b = c;
			 c = t;
		 }
		 if (a > b) {
			 b = a;
		 }
		 return b;
	 }
	 private class StackElem {
		 int ll;
		 int hh;
		 int dd;
	 }
	 private void qSort3(int loSt, int hiSt, int dSt) {
		 int unLo, unHi, ltLo, gtHi, med, n, m;
		 int sp, lo, hi, d;
		 StackElem[] stack = new StackElem[QSORT_STACK_SIZE];
		 for (int count = 0;
		 count < QSORT_STACK_SIZE;
		 count++) {
			 stack[count] = new StackElem();
		 }
		 sp = 0;
		 stack[sp].ll = loSt;
		 stack[sp].hh = hiSt;
		 stack[sp].dd = dSt;
		 sp++;
		 while (sp > 0) {
			 if (sp >= QSORT_STACK_SIZE) {
				 panic();
			 }
			 sp--;
			 lo = stack[sp].ll;
			 hi = stack[sp].hh;
			 d = stack[sp].dd;
			 if (hi - lo < SMALL_THRESH || d > DEPTH_THRESH) {
				 simpleSort(lo, hi, d);
				 if (workDone > workLimit && firstAttempt) {
					 return;
				 }
				 continue;
			 }
			 med = med3(block[zptr[lo] + d + 1], block[zptr[hi ] + d + 1], block[zptr[(lo + hi) >> 1] + d + 1]);
			 unLo = ltLo = lo;
			 unHi = gtHi = hi;
			 while (true) {
				 while (true) {
					 if (unLo > unHi) {
						 break;
					 }
					 n = ((int) block[zptr[unLo] + d + 1]) - med;
					 if (n == 0) {
						 int temp = 0;
						 temp = zptr[unLo];
						 zptr[unLo] = zptr[ltLo];
						 zptr[ltLo] = temp;
						 ltLo++;
						 unLo++;
						 continue;
					 }
					;
					 if (n > 0) {
						 break;
					 }
					 unLo++;
				 }
				 while (true) {
					 if (unLo > unHi) {
						 break;
					 }
					 n = ((int) block[zptr[unHi] + d + 1]) - med;
					 if (n == 0) {
						 int temp = 0;
						 temp = zptr[unHi];
						 zptr[unHi] = zptr[gtHi];
						 zptr[gtHi] = temp;
						 gtHi--;
						 unHi--;
						 continue;
					 }
					;
					 if (n < 0) {
						 break;
					 }
					 unHi--;
				 }
				 if (unLo > unHi) {
					 break;
				 }
				 int temp = 0;
				 temp = zptr[unLo];
				 zptr[unLo] = zptr[unHi];
				 zptr[unHi] = temp;
				 unLo++;
				 unHi--;
			 }
			 if (gtHi < ltLo) {
				 stack[sp].ll = lo;
				 stack[sp].hh = hi;
				 stack[sp].dd = d + 1;
				 sp++;
				 continue;
			 }
			 n = ((ltLo - lo) < (unLo - ltLo)) ? (ltLo - lo) : (unLo - ltLo);
			 vswap(lo, unLo - n, n);
			 m = ((hi - gtHi) < (gtHi - unHi)) ? (hi - gtHi) : (gtHi - unHi);
			 vswap(unLo, hi - m + 1, m);
			 n = lo + unLo - ltLo - 1;
			 m = hi - (gtHi - unHi) + 1;
			 stack[sp].ll = lo;
			 stack[sp].hh = n;
			 stack[sp].dd = d;
			 sp++;
			 stack[sp].ll = n + 1;
			 stack[sp].hh = m - 1;
			 stack[sp].dd = d + 1;
			 sp++;
			 stack[sp].ll = m;
			 stack[sp].hh = hi;
			 stack[sp].dd = d;
			 sp++;
		 }
	 }
	 private void mainSort() {
		 int i, j, ss, sb;
		 int[] runningOrder = new int[256];
		 int[] copy = new int[256];
		 boolean[] bigDone = new boolean[256];
		 int c1, c2;
		 int numQSorted;
		 for (i = 0;
		 i < NUM_OVERSHOOT_BYTES;
		 i++) {
			 block[last + i + 2] = block[(i % (last + 1)) + 1];
		 }
		 for (i = 0;
		 i <= last + NUM_OVERSHOOT_BYTES;
		 i++) {
			 quadrant[i] = 0;
		 }
		 block[0] = (char) (block[last + 1]);
		 if (last < 4000) {
			 for (i = 0;
			 i <= last;
			 i++) {
				 zptr[i] = i;
			 }
			 firstAttempt = false;
			 workDone = workLimit = 0;
			 simpleSort(0, last, 0);
		 }
		 else {
			 numQSorted = 0;
			 for (i = 0;
			 i <= 255;
			 i++) {
				 bigDone[i] = false;
			 }
			 for (i = 0;
			 i <= 65536;
			 i++) {
				 ftab[i] = 0;
			 }
			 c1 = block[0];
			 for (i = 0;
			 i <= last;
			 i++) {
				 c2 = block[i + 1];
				 ftab[(c1 << 8) + c2]++;
				 c1 = c2;
			 }
			 for (i = 1;
			 i <= 65536;
			 i++) {
				 ftab[i] += ftab[i - 1];
			 }
			 c1 = block[1];
			 for (i = 0;
			 i < last;
			 i++) {
				 c2 = block[i + 2];
				 j = (c1 << 8) + c2;
				 c1 = c2;
				 ftab[j]--;
				 zptr[ftab[j]] = i;
			 }
			 j = ((block[last + 1]) << 8) + (block[1]);
			 ftab[j]--;
			 zptr[ftab[j]] = last;
			 for (i = 0;
			 i <= 255;
			 i++) {
				 runningOrder[i] = i;
			 }
			 {
				 int vv;
				 int h = 1;
				 do {
					 h = 3 * h + 1;
				 }
				 while (h <= 256);
				 do {
					 h = h / 3;
					 for (i = h;
					 i <= 255;
					 i++) {
						 vv = runningOrder[i];
						 j = i;
						 while ((ftab[((runningOrder[j - h]) + 1) << 8] - ftab[(runningOrder[j - h]) << 8]) > (ftab[((vv) + 1) << 8] - ftab[(vv) << 8])) {
							 runningOrder[j] = runningOrder[j - h];
							 j = j - h;
							 if (j <= (h - 1)) {
								 break;
							 }
						 }
						 runningOrder[j] = vv;
					 }
				 }
				 while (h != 1);
			 }
			 for (i = 0;
			 i <= 255;
			 i++) {
				 ss = runningOrder[i];
				 for (j = 0;
				 j <= 255;
				 j++) {
					 sb = (ss << 8) + j;
					 if (!((ftab[sb] & SETMASK) == SETMASK)) {
						 int lo = ftab[sb] & CLEARMASK;
						 int hi = (ftab[sb + 1] & CLEARMASK) - 1;
						 if (hi > lo) {
							 qSort3(lo, hi, 2);
							 numQSorted += (hi - lo + 1);
							 if (workDone > workLimit && firstAttempt) {
								 return;
							 }
						 }
						 ftab[sb] |= SETMASK;
					 }
				 }
				 bigDone[ss] = true;
				 if (i < 255) {
					 int bbStart = ftab[ss << 8] & CLEARMASK;
					 int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
					 int shifts = 0;
					 while ((bbSize >> shifts) > 65534) {
						 shifts++;
					 }
					 for (j = 0;
					 j < bbSize;
					 j++) {
						 int a2update = zptr[bbStart + j];
						 int qVal = (j >> shifts);
						 quadrant[a2update] = qVal;
						 if (a2update < NUM_OVERSHOOT_BYTES) {
							 quadrant[a2update + last + 1] = qVal;
						 }
					 }
					 if (!(((bbSize - 1) >> shifts) <= 65535)) {
						 panic();
					 }
				 }
				 for (j = 0;
				 j <= 255;
				 j++) {
					 copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
				 }
				 for (j = ftab[ss << 8] & CLEARMASK;
				 j < (ftab[(ss + 1) << 8] & CLEARMASK);
				 j++) {
					 c1 = block[zptr[j]];
					 if (!bigDone[c1]) {
						 zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;
						 copy[c1]++;
					 }
				 }
				 for (j = 0;
				 j <= 255;
				 j++) {
					 ftab[(j << 8) + ss] |= SETMASK;
				 }
			 }
		 }
	 }
	 private void randomiseBlock() {
		 int i;
		 int rNToGo = 0;
		 int rTPos = 0;
		 for (i = 0;
		 i < 256;
		 i++) {
			 inUse[i] = false;
		 }
		 for (i = 0;
		 i <= last;
		 i++) {
			 if (rNToGo == 0) {
				 rNToGo = (char) rNums[rTPos];
				 rTPos++;
				 if (rTPos == 512) {
					 rTPos = 0;
				 }
			 }
			 rNToGo--;
			 block[i + 1] ^= ((rNToGo == 1) ? 1 : 0);
			 block[i + 1] &= 0xFF;
			 inUse[block[i + 1]] = true;
		 }
	 }
	 private void doReversibleTransformation() {
		 int i;
		 workLimit = workFactor * last;
		 workDone = 0;
		 blockRandomised = false;
		 firstAttempt = true;
		 mainSort();
		 if (workDone > workLimit && firstAttempt) {
			 randomiseBlock();
			 workLimit = workDone = 0;
			 blockRandomised = true;
			 firstAttempt = false;
			 mainSort();
		 }
		 origPtr = -1;
		 for (i = 0;
		 i <= last;
		 i++) {
			 if (zptr[i] == 0) {
				 origPtr = i;
				 break;
			 }
		 }
		;
		 if (origPtr == -1) {
			 panic();
		 }
	 }
	 private boolean fullGtU(int i1, int i2) {
		 int k;
		 char c1, c2;
		 int s1, s2;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 c1 = block[i1 + 1];
		 c2 = block[i2 + 1];
		 if (c1 != c2) {
			 return (c1 > c2);
		 }
		 i1++;
		 i2++;
		 k = last + 1;
		 do {
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 c1 = block[i1 + 1];
			 c2 = block[i2 + 1];
			 if (c1 != c2) {
				 return (c1 > c2);
			 }
			 s1 = quadrant[i1];
			 s2 = quadrant[i2];
			 if (s1 != s2) {
				 return (s1 > s2);
			 }
			 i1++;
			 i2++;
			 if (i1 > last) {
				 i1 -= last;
				 i1--;
			 }
			;
			 if (i2 > last) {
				 i2 -= last;
				 i2--;
			 }
			;
			 k -= 4;
			 workDone++;
		 }
		 while (k >= 0);
		 return false;
	 }
	 private int[] incs = {
	 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484 }
	;
	 private void allocateCompressStructures () {
		 int n = baseBlockSize * blockSize100k;
		 block = new char[(n + 1 + NUM_OVERSHOOT_BYTES)];
		 quadrant = new int[(n + NUM_OVERSHOOT_BYTES)];
		 zptr = new int[n];
		 ftab = new int[65537];
		 if (block == null || quadrant == null || zptr == null || ftab == null) {
		 }
		 szptr = new short[2 * n];
	 }
	 private void generateMTFValues() {
		 char[] yy = new char[256];
		 int i, j;
		 char tmp;
		 char tmp2;
		 int zPend;
		 int wr;
		 int EOB;
		 makeMaps();
		 EOB = nInUse + 1;
		 for (i = 0;
		 i <= EOB;
		 i++) {
			 mtfFreq[i] = 0;
		 }
		 wr = 0;
		 zPend = 0;
		 for (i = 0;
		 i < nInUse;
		 i++) {
			 yy[i] = (char) i;
		 }
		 for (i = 0;
		 i <= last;
		 i++) {
			 char ll_i;
			 ll_i = unseqToSeq[block[zptr[i]]];
			 j = 0;
			 tmp = yy[j];
			 while (ll_i != tmp) {
				 j++;
				 tmp2 = tmp;
				 tmp = yy[j];
				 yy[j] = tmp2;
			 }
			;
			 yy[0] = tmp;
			 if (j == 0) {
				 zPend++;
			 }
			 else {
				 if (zPend > 0) {
					 zPend--;
					 while (true) {
						 switch (zPend % 2) {
							 case 0: szptr[wr] = (short) RUNA;
							 wr++;
							 mtfFreq[RUNA]++;
							 break;
							 case 1: szptr[wr] = (short) RUNB;
							 wr++;
							 mtfFreq[RUNB]++;
							 break;
						 }
						;
						 if (zPend < 2) {
							 break;
						 }
						 zPend = (zPend - 2) / 2;
					 }
					;
					 zPend = 0;
				 }
				 szptr[wr] = (short) (j + 1);
				 wr++;
				 mtfFreq[j + 1]++;
			 }
		 }
		 if (zPend > 0) {
			 zPend--;
			 while (true) {
				 switch (zPend % 2) {
					 case 0: szptr[wr] = (short) RUNA;
					 wr++;
					 mtfFreq[RUNA]++;
					 break;
					 case 1: szptr[wr] = (short) RUNB;
					 wr++;
					 mtfFreq[RUNB]++;
					 break;
				 }
				 if (zPend < 2) {
					 break;
				 }
				 zPend = (zPend - 2) / 2;
			 }
		 }
		 szptr[wr] = (short) EOB;
		 wr++;
		 mtfFreq[EOB]++;
		 nMTF = wr;
	 }
}",1,0,0,0
"public class BufferedDynamicImageResource extends DynamicImageResource{
	private static final long serialVersionUID = 1L;
	private byte[] imageData;
	public BufferedDynamicImageResource(){
	}
	public BufferedDynamicImageResource(Locale locale){
		super(locale);
	}
	public BufferedDynamicImageResource(String format, Locale locale){
		super(format, locale);
	}
	public BufferedDynamicImageResource(String format){
		super(format);
	}
	public synchronized void setImage(final BufferedImage image){
		imageData = toImageData(image);
	}
	protected byte[] getImageData(){
		return imageData;
	}
}",0,0,0,0
public int tokenType();,0,0,0,0
"public class BlockMissingException extends IOException {
	 private static final long serialVersionUID = 1L;
	 private String filename;
	 private long offset;
	 public BlockMissingException(String filename, String description, long offset) {
		 super(description);
		 this.filename = filename;
		 this.offset = offset;
	 }
	 public String getFile() {
		 return filename;
	 }
	 public long getOffset() {
		 return offset;
	 }
}",0,1,0,0
"public abstract class JenaMetadata implements DatabaseMetaData {
	 public static final String CATALOG_TERM = ""RDF Store"";
	 public static final String SCHEMA_TERM = ""Dataset"";
	 public static final String DEFAULT_CATALOG = ""RDF"";
	 public static final String DEFAULT_SCHEMA = ""Dataset"";
	 protected static final int NO_LIMIT = 0;
	 protected static final int UNKNOWN_LIMIT = 0;
	 protected static final String[] SPARQL_KEYWORDS = new String[] {
	 ""BASE"", ""PREFIX"", ""SELECT"", ""DISTINCT"", ""REDUCED"", ""AS"", ""CONSTRUCT"", ""DESCRIBE"", ""ASK"", ""FROM"", ""NAMED"", ""WHERE"", ""GROUP"", ""BY"", ""HAVING"", ""ORDER"", ""ASC"", ""DESC"", ""LIMIT"", ""OFFSET"", ""VALUES"", ""LOAD"", ""SILENT"", ""INTO"", ""GRAPH"", ""CLEAR"", ""DROP"", ""CREATE"", ""ADD"", ""MOVE"", ""COPY"", ""INSERT DATA"", ""DELETE DATA"", ""DELETE WHERE"", ""WITH"", ""INSERT"", ""USING"", ""DEFAULT"", ""ALL"", ""OPTIONAL"", ""SERVICE"", ""BIND"", ""UNION"", ""UNDEF"", ""MINUS"", ""EXISTS"", ""NOT EXISTS"", ""FILTER"", ""a"", ""IN"", ""NOT IN"", ""STR"", ""LANG"", ""LANGMATCHES"", ""DATATYPE"", ""BOUND"", ""IRI"", ""URI"", ""BNODE"", ""RAND"", ""ABS"", ""CEIL"", ""FLOOR"", ""ROUND"", ""CONCAT"", ""STRLEN"", ""UCASE"", ""LCASE"", ""ENCODE_FOR_URI"", ""CONTAINS"", ""STRSTARTS"", ""STRENDS"", ""STRBEFORE"", ""STRAFTER"", ""YEAR"", ""MONTH"", ""DAY"", ""HOURS"", ""MINUTES"", ""SECONDS"", ""TIMEZONE"", ""TZ"", ""NOW"", ""UUID"", ""STRUUID"", ""MD5"", ""SHA1"", ""SHA256"", ""SHA384"", ""SHA512"", ""COALESCE"", ""IF"", ""STRLANG"", ""STRDT"", ""SAMETERM"", ""ISIRI"", ""ISURI"", ""ISBLANK"", ""REGEX"", ""SUBSTR"", ""REPLACE"", ""COUNT"", ""SUM"", ""MIN"", ""MAX"", ""AVG"", ""SAMPLE"", ""GROUP_CONCAT"", ""SEPARATOR"", ""true"", ""false"" }
	;
	 protected static final String[] SPARQL_NUMERIC_FUNCTIONS = new String[] {
	 ""ABS"", ""CEIL"", ""FLOOR"", ""RAND"", ""ROUND"" }
	;
	 protected static final String[] SPARQL_STR_FUNCTIONS = new String[] {
	 ""STR"", ""LANG"", ""LANGMATCHES"", ""CONCAT"", ""STRLEN"", ""UCASE"", ""LCASE"", ""ENCODE_FOR_URI"", ""CONTAINS"", ""STRSTARTS"", ""STRENDS"", ""STRBEFORE"", ""STRAFTER"", ""REGEX"", ""SUBSTR"", ""REPLACE"" }
	;
	 protected static final String[] SPARQL_DATETIME_FUNCTIONS = new String[] {
	 ""YEAR"", ""MONTH"", ""DAY"", ""HOURS"", ""MINUTES"", ""SECONDS"", ""TIMEZONE"", ""TZ"", ""NOW"" }
	;
	 private JenaConnection connection;
	 public JenaMetadata(JenaConnection connection) throws SQLException {
		 if (connection == null) throw new SQLException(""Connection cannot be null"");
		 this.connection = connection;
	 }
	 public JenaConnection getJenaConnection() {
		 return this.connection;
	 }
	 public boolean isWrapperFor(Class<?> arg0) throws SQLFeatureNotSupportedException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public <T> T unwrap(Class<T> arg0) throws SQLFeatureNotSupportedException {
		 throw new SQLFeatureNotSupportedException();
	 }
	 public boolean allProceduresAreCallable() {
		 return false;
	 }
	 public boolean allTablesAreSelectable() {
		 return true;
	 }
	 public boolean autoCommitFailureClosesAllResultSets() {
		 return false;
	 }
	 public boolean dataDefinitionCausesTransactionCommit() {
		 return true;
	 }
	 public boolean dataDefinitionIgnoredInTransactions() {
		 return false;
	 }
	 public boolean deletesAreDetected(int arg0) {
		 return true;
	 }
	 public boolean doesMaxRowSizeIncludeBlobs() {
		 return true;
	 }
	 public ResultSet getAttributes(String arg0, String arg1, String arg2, String arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getAttributeColumns());
	 }
	 public ResultSet getBestRowIdentifier(String arg0, String arg1, String arg2, int arg3, boolean arg4) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getBestRowIdentifierColumns());
	 }
	 public String getCatalogSeparator() {
		 return """";
	 }
	 public String getCatalogTerm() {
		 return CATALOG_TERM;
	 }
	 public ResultSet getCatalogs() throws SQLException {
		 return new MetaResultSet(MetadataSchema.getCatalogsColumns(), new Object[][] {
			 {
			 DEFAULT_CATALOG }
		 }
		);
	 }
	 public ResultSet getClientInfoProperties() throws SQLException {
		 return new MetaResultSet(MetadataSchema.getClientInfoPropertyColumns());
	 }
	 public ResultSet getColumnPrivileges(String arg0, String arg1, String arg2, String arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getColumnPrivilegeColumns());
	 }
	 public ResultSet getColumns(String arg0, String arg1, String arg2, String arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getColumnColumns());
	 }
	 public final Connection getConnection() {
		 return this.connection;
	 }
	 public ResultSet getCrossReference(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getCrossReferenceColumns());
	 }
	 public abstract int getDatabaseMajorVersion();
	 public abstract int getDatabaseMinorVersion();
	 public abstract String getDatabaseProductName();
	 public abstract String getDatabaseProductVersion();
	 public int getDefaultTransactionIsolation() {
		 return Connection.TRANSACTION_NONE;
	 }
	 public abstract int getDriverMajorVersion();
	 public abstract int getDriverMinorVersion();
	 public abstract String getDriverName();
	 public abstract String getDriverVersion();
	 public ResultSet getExportedKeys(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getExportedKeyColumns());
	 }
	 public String getExtraNameCharacters() {
		 return """";
	 }
	 public ResultSet getFunctionColumns(String arg0, String arg1, String arg2, String arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getFunctionColumnColumns());
	 }
	 public ResultSet getFunctions(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getFunctionColumns());
	 }
	 public String getIdentifierQuoteString() {
		 return "" "";
	 }
	 public ResultSet getImportedKeys(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getImportedKeyColumns());
	 }
	 public ResultSet getIndexInfo(String arg0, String arg1, String arg2, boolean arg3, boolean arg4) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getIndexInfoColumns());
	 }
	 public final int getJDBCMajorVersion() {
		 return 4;
	 }
	 public final int getJDBCMinorVersion() {
		 return 0;
	 }
	 public int getMaxBinaryLiteralLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxCatalogNameLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxCharLiteralLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxColumnNameLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxColumnsInGroupBy() {
		 return NO_LIMIT;
	 }
	 public int getMaxColumnsInIndex() {
		 return 4;
	 }
	 public int getMaxColumnsInOrderBy() {
		 return NO_LIMIT;
	 }
	 public int getMaxColumnsInSelect() {
		 return NO_LIMIT;
	 }
	 public int getMaxColumnsInTable() {
		 return 4;
	 }
	 public int getMaxConnections() {
		 return NO_LIMIT;
	 }
	 public int getMaxCursorNameLength() {
		 return UNKNOWN_LIMIT;
	 }
	 public int getMaxIndexLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxProcedureNameLength() {
		 return UNKNOWN_LIMIT;
	 }
	 public int getMaxRowSize() {
		 return NO_LIMIT;
	 }
	 public int getMaxSchemaNameLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxStatementLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxStatements() {
		 return NO_LIMIT;
	 }
	 public int getMaxTableNameLength() {
		 return NO_LIMIT;
	 }
	 public int getMaxTablesInSelect() {
		 return NO_LIMIT;
	 }
	 public int getMaxUserNameLength() {
		 return UNKNOWN_LIMIT;
	 }
	 public String getNumericFunctions() {
		 return String.join("","", SPARQL_NUMERIC_FUNCTIONS);
	 }
	 public ResultSet getPrimaryKeys(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getPrimaryKeyColumns());
	 }
	 public ResultSet getProcedureColumns(String arg0, String arg1, String arg2, String arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getProcedureColumnColumns());
	 }
	 public String getProcedureTerm() {
		 return null;
	 }
	 public ResultSet getProcedures(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getProcedureColumns());
	 }
	 public int getResultSetHoldability() {
		 return JenaConnection.DEFAULT_HOLDABILITY;
	 }
	 public RowIdLifetime getRowIdLifetime() {
		 return RowIdLifetime.ROWID_UNSUPPORTED;
	 }
	 public String getSQLKeywords() {
		 return String.join("","", SPARQL_KEYWORDS);
	 }
	 public int getSQLStateType() {
		 return sqlStateXOpen;
	 }
	 public String getSchemaTerm() {
		 return SCHEMA_TERM;
	 }
	 public ResultSet getSchemas() throws SQLException {
		 return new MetaResultSet(MetadataSchema.getSchemaColumns(), new Object[][] {
			 {
			 DEFAULT_SCHEMA, DEFAULT_CATALOG }
		 }
		);
	 }
	 public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {
		 if (DEFAULT_CATALOG.equals(catalog)) {
			 if (schemaPattern == null || DEFAULT_SCHEMA.equals(schemaPattern)) {
				 return this.getSchemas();
			 }
			 else {
				 return new MetaResultSet(MetadataSchema.getSchemaColumns());
			 }
		 }
		 else {
			 return new MetaResultSet(MetadataSchema.getSchemaColumns());
		 }
	 }
	 public String getSearchStringEscape() {
		 return """";
	 }
	 public String getStringFunctions() {
		 return String.join("","", SPARQL_STR_FUNCTIONS);
	 }
	 public ResultSet getSuperTables(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getSuperTableColumns());
	 }
	 public ResultSet getSuperTypes(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getSuperTypeColumns());
	 }
	 public String getSystemFunctions() {
		 return """";
	 }
	 public ResultSet getTablePrivileges(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getTablePrivilegeColumns());
	 }
	 public ResultSet getTableTypes() throws SQLException {
		 return new MetaResultSet(MetadataSchema.getTableTypeColumns());
	 }
	 public ResultSet getTables(String arg0, String arg1, String arg2, String[] arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getTableColumns());
	 }
	 public String getTimeDateFunctions() {
		 return String.join("","", SPARQL_DATETIME_FUNCTIONS);
	 }
	 public ResultSet getTypeInfo() throws SQLException {
		 return new MetaResultSet(MetadataSchema.getTypeInfoColumns(), new Object[][] {
			 {
			 XSD.xboolean.toString(), Types.BOOLEAN, 0, null, null, null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 0 }
			, {
			 XSD.xbyte.toString(), Types.TINYINT, Byte.toString(Byte.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 0 }
			, {
			 XSD.date.toString(), Types.DATE, 0, ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 0 }
			, {
			 XSD.dateTime.toString(), Types.DATE, 0, ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 0 }
			, {
			 XSD.decimal.toString(), Types.DECIMAL, 16, null, null, null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 16, 0, 0, 10 }
			, {
			 XSD.xdouble.toString(), Types.DOUBLE, 16, null, null, null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 16, 0, 0, 10 }
			, {
			 XSD.xfloat.toString(), Types.FLOAT, 15, ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 7, 0, 0, 10 }
			, {
			 XSD.xshort.toString(), Types.INTEGER, Integer.toString(Integer.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.integer.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), null, null, null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.xlong.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.xint.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.negativeInteger.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.nonNegativeInteger.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, true, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.nonPositiveInteger.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.positiveInteger.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, true, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.unsignedByte.toString(), Types.TINYINT, Byte.toString(Byte.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, true, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.unsignedInt.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, true, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.unsignedLong.toString(), Types.BIGINT, Long.toString(Long.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, true, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.unsignedShort.toString(), Types.INTEGER, Integer.toString(Integer.MAX_VALUE).length(), ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, true, false, false, null, (short) 0, (short) 0, 0, 0, 10 }
			, {
			 XSD.xstring.toString(), Types.NVARCHAR, 0, ""\"""", ""\"""", null, (short) typeNullable, true, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 0 }
			, {
			 XSD.time.toString(), Types.TIME, 0, ""\"""", ""\"""", null, (short) typeNullable, false, (short) typeSearchable, false, false, false, null, (short) 0, (short) 0, 0, 0, 0 }
		, }
		);
	 }
	 public ResultSet getUDTs(String arg0, String arg1, String arg2, int[] arg3) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getUdtColumns());
	 }
	 public abstract String getURL();
	 public String getUserName() {
		 return null;
	 }
	 public ResultSet getVersionColumns(String arg0, String arg1, String arg2) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getVersionColumns());
	 }
	 public boolean insertsAreDetected(int arg0) {
		 return false;
	 }
	 public boolean isCatalogAtStart() {
		 return true;
	 }
	 public boolean isReadOnly() throws SQLException {
		 return this.connection.isReadOnly();
	 }
	 public boolean locatorsUpdateCopy() {
		 return false;
	 }
	 public boolean nullPlusNonNullIsNull() {
		 return true;
	 }
	 public boolean nullsAreSortedAtEnd() {
		 return false;
	 }
	 public boolean nullsAreSortedAtStart() {
		 return true;
	 }
	 public boolean nullsAreSortedHigh() {
		 return false;
	 }
	 public boolean nullsAreSortedLow() {
		 return true;
	 }
	 public boolean othersDeletesAreVisible(int arg0) {
		 return true;
	 }
	 public boolean othersInsertsAreVisible(int arg0) {
		 return true;
	 }
	 public boolean othersUpdatesAreVisible(int arg0) {
		 return true;
	 }
	 public boolean ownDeletesAreVisible(int arg0) {
		 return true;
	 }
	 public boolean ownInsertsAreVisible(int arg0) {
		 return true;
	 }
	 public boolean ownUpdatesAreVisible(int arg0) {
		 return true;
	 }
	 public boolean storesLowerCaseIdentifiers() {
		 return false;
	 }
	 public boolean storesLowerCaseQuotedIdentifiers() {
		 return false;
	 }
	 public boolean storesMixedCaseIdentifiers() {
		 return false;
	 }
	 public boolean storesMixedCaseQuotedIdentifiers() {
		 return false;
	 }
	 public boolean storesUpperCaseIdentifiers() {
		 return false;
	 }
	 public boolean storesUpperCaseQuotedIdentifiers() {
		 return false;
	 }
	 public boolean supportsANSI92EntryLevelSQL() {
		 return false;
	 }
	 public boolean supportsANSI92FullSQL() {
		 return false;
	 }
	 public boolean supportsANSI92IntermediateSQL() {
		 return false;
	 }
	 public boolean supportsAlterTableWithAddColumn() {
		 return false;
	 }
	 public boolean supportsAlterTableWithDropColumn() {
		 return false;
	 }
	 public boolean supportsBatchUpdates() {
		 return true;
	 }
	 public boolean supportsCatalogsInDataManipulation() {
		 return false;
	 }
	 public boolean supportsCatalogsInIndexDefinitions() {
		 return false;
	 }
	 public boolean supportsCatalogsInPrivilegeDefinitions() {
		 return false;
	 }
	 public boolean supportsCatalogsInProcedureCalls() {
		 return false;
	 }
	 public boolean supportsCatalogsInTableDefinitions() {
		 return false;
	 }
	 public boolean supportsColumnAliasing() {
		 return true;
	 }
	 public boolean supportsConvert() {
		 return false;
	 }
	 public boolean supportsConvert(int arg0, int arg1) {
		 return false;
	 }
	 public boolean supportsCoreSQLGrammar() {
		 return false;
	 }
	 public boolean supportsCorrelatedSubqueries() {
		 return true;
	 }
	 public boolean supportsDataDefinitionAndDataManipulationTransactions() {
		 return true;
	 }
	 public boolean supportsDataManipulationTransactionsOnly() {
		 return true;
	 }
	 public boolean supportsDifferentTableCorrelationNames() {
		 return false;
	 }
	 public boolean supportsExpressionsInOrderBy() {
		 return true;
	 }
	 public boolean supportsExtendedSQLGrammar() {
		 return false;
	 }
	 public boolean supportsFullOuterJoins() {
		 return true;
	 }
	 public boolean supportsGetGeneratedKeys() {
		 return false;
	 }
	 public boolean supportsGroupBy() {
		 return true;
	 }
	 public boolean supportsGroupByBeyondSelect() {
		 return true;
	 }
	 public boolean supportsGroupByUnrelated() {
		 return true;
	 }
	 public boolean supportsIntegrityEnhancementFacility() {
		 return false;
	 }
	 public boolean supportsLikeEscapeClause() {
		 return false;
	 }
	 public boolean supportsLimitedOuterJoins() {
		 return true;
	 }
	 public boolean supportsMinimumSQLGrammar() {
		 return false;
	 }
	 public boolean supportsMixedCaseIdentifiers() {
		 return false;
	 }
	 public boolean supportsMixedCaseQuotedIdentifiers() {
		 return false;
	 }
	 public boolean supportsMultipleOpenResults() {
		 return true;
	 }
	 public boolean supportsMultipleResultSets() {
		 return false;
	 }
	 public boolean supportsMultipleTransactions() {
		 return true;
	 }
	 public boolean supportsNamedParameters() {
		 return false;
	 }
	 public boolean supportsNonNullableColumns() {
		 return true;
	 }
	 public boolean supportsOpenCursorsAcrossCommit() {
		 return false;
	 }
	 public boolean supportsOpenCursorsAcrossRollback() {
		 return false;
	 }
	 public boolean supportsOpenStatementsAcrossCommit() {
		 return true;
	 }
	 public boolean supportsOpenStatementsAcrossRollback() {
		 return true;
	 }
	 public boolean supportsOrderByUnrelated() {
		 return true;
	 }
	 public boolean supportsOuterJoins() {
		 return true;
	 }
	 public boolean supportsPositionedDelete() {
		 return false;
	 }
	 public boolean supportsPositionedUpdate() {
		 return false;
	 }
	 public boolean supportsResultSetConcurrency(int type, int concurrency) {
		 if (concurrency != ResultSet.CONCUR_READ_ONLY) return false;
		 return supportsResultSetType(type);
	 }
	 public boolean supportsResultSetHoldability(int holdability) {
		 return true;
	 }
	 public boolean supportsResultSetType(int type) {
		 switch (type) {
			 case ResultSet.TYPE_FORWARD_ONLY: case ResultSet.TYPE_SCROLL_INSENSITIVE: return true;
			 default: return false;
		 }
	 }
	 public boolean supportsSavepoints() {
		 return false;
	 }
	 public boolean supportsSchemasInDataManipulation() {
		 return false;
	 }
	 public boolean supportsSchemasInIndexDefinitions() {
		 return false;
	 }
	 public boolean supportsSchemasInPrivilegeDefinitions() {
		 return false;
	 }
	 public boolean supportsSchemasInProcedureCalls() {
		 return false;
	 }
	 public boolean supportsSchemasInTableDefinitions() {
		 return false;
	 }
	 public boolean supportsSelectForUpdate() {
		 return false;
	 }
	 public boolean supportsStatementPooling() {
		 return false;
	 }
	 public boolean supportsStoredFunctionsUsingCallSyntax() {
		 return false;
	 }
	 public boolean supportsStoredProcedures() {
		 return false;
	 }
	 public boolean supportsSubqueriesInComparisons() {
		 return false;
	 }
	 public boolean supportsSubqueriesInExists() {
		 return true;
	 }
	 public boolean supportsSubqueriesInIns() {
		 return false;
	 }
	 public boolean supportsSubqueriesInQuantifieds() {
		 return false;
	 }
	 public boolean supportsTableCorrelationNames() {
		 return false;
	 }
	 public boolean supportsTransactionIsolationLevel(int arg0) {
		 switch (arg0) {
			 case Connection.TRANSACTION_NONE: case Connection.TRANSACTION_SERIALIZABLE: return true;
			 default: return false;
		 }
	 }
	 public boolean supportsTransactions() {
		 return false;
	 }
	 public boolean supportsUnion() {
		 return true;
	 }
	 public boolean supportsUnionAll() {
		 return false;
	 }
	 public boolean updatesAreDetected(int arg0) {
		 return false;
	 }
	 public abstract boolean usesLocalFilePerTable();
	 public abstract boolean usesLocalFiles();
	 public ResultSet getPseudoColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {
		 return new MetaResultSet(MetadataSchema.getPsuedoColumnColumns());
	 }
	 public boolean generatedKeyAlwaysReturned() {
		 return false;
	 }
}",1,0,0,0
"public class DatabaseDescriptor{
	 private static Logger logger = LoggerFactory.getLogger(DatabaseDescriptor.class);
	 private static IEndpointSnitch snitch;
	 private static InetAddress listenAddress;
	 private static InetAddress rpcAddress;
	 private static SeedProvider seedProvider;
	 private static int currentIndex = 0;
	 static Map<String, KSMetaData> tables = new HashMap<String, KSMetaData>();
	 private static IPartitioner partitioner;
	 private static Config.DiskAccessMode indexAccessMode;
	 private static Config conf;
	 private static IAuthenticator authenticator = new AllowAllAuthenticator();
	 private static IAuthority authority = new AllowAllAuthority();
	 private final static String DEFAULT_CONFIGURATION = ""cassandra.yaml"";
	 private static IRequestScheduler requestScheduler;
	 private static RequestSchedulerId requestSchedulerId;
	 private static RequestSchedulerOptions requestSchedulerOptions;
	 public static final UUID INITIAL_VERSION = new UUID(4096, 0);
	 private static volatile UUID defsVersion = INITIAL_VERSION;
	 static URL getStorageConfigURL() throws ConfigurationException {
		 String configUrl = System.getProperty(""cassandra.config"");
		 if (configUrl == null) configUrl = DEFAULT_CONFIGURATION;
		 URL url;
		 try {
			 url = new URL(configUrl);
			 url.openStream().close();
		 }
		 catch (Exception e) {
			 ClassLoader loader = DatabaseDescriptor.class.getClassLoader();
			 url = loader.getResource(configUrl);
			 if (url == null) throw new ConfigurationException(""Cannot locate "" + configUrl);
		 }
		 return url;
	 }
	 static {
		 try {
			 URL url = getStorageConfigURL();
			 logger.info(""Loading settings from "" + url);
			 InputStream input = null;
			 try {
				 input = url.openStream();
			 }
			 catch (IOException e) {
				 throw new AssertionError(e);
			 }
			 org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);
			 TypeDescription seedDesc = new TypeDescription(SeedProviderDef.class);
			 seedDesc.putMapPropertyType(""parameters"", String.class, String.class);
			 constructor.addTypeDescription(seedDesc);
			 Yaml yaml = new Yaml(new Loader(constructor));
			 conf = (Config)yaml.load(input);
			 if (conf.commitlog_sync == null) {
				 throw new ConfigurationException(""Missing required directive CommitLogSync"");
			 }
			 if (conf.commitlog_sync == Config.CommitLogSync.batch) {
				 if (conf.commitlog_sync_batch_window_in_ms == null) {
					 throw new ConfigurationException(""Missing value for commitlog_sync_batch_window_in_ms: Double expected."");
				 }
				 else if (conf.commitlog_sync_period_in_ms != null) {
					 throw new ConfigurationException(""Batch sync specified, but commitlog_sync_period_in_ms found. Only specify commitlog_sync_batch_window_in_ms when using batch sync"");
				 }
				 logger.debug(""Syncing log with a batch window of "" + conf.commitlog_sync_batch_window_in_ms);
			 }
			 else {
				 if (conf.commitlog_sync_period_in_ms == null) {
					 throw new ConfigurationException(""Missing value for commitlog_sync_period_in_ms: Integer expected"");
				 }
				 else if (conf.commitlog_sync_batch_window_in_ms != null) {
					 throw new ConfigurationException(""commitlog_sync_period_in_ms specified, but commitlog_sync_batch_window_in_ms found. Only specify commitlog_sync_period_in_ms when using periodic sync."");
				 }
				 logger.debug(""Syncing log with a period of "" + conf.commitlog_sync_period_in_ms);
			 }
			 if (conf.disk_access_mode == Config.DiskAccessMode.auto) {
				 conf.disk_access_mode = System.getProperty(""os.arch"").contains(""64"") ? Config.DiskAccessMode.mmap : Config.DiskAccessMode.standard;
				 indexAccessMode = conf.disk_access_mode;
				 logger.info(""DiskAccessMode 'auto' determined to be "" + conf.disk_access_mode + "", indexAccessMode is "" + indexAccessMode );
			 }
			 else if (conf.disk_access_mode == Config.DiskAccessMode.mmap_index_only) {
				 conf.disk_access_mode = Config.DiskAccessMode.standard;
				 indexAccessMode = Config.DiskAccessMode.mmap;
				 logger.info(""DiskAccessMode is "" + conf.disk_access_mode + "", indexAccessMode is "" + indexAccessMode );
			 }
			 else {
				 indexAccessMode = conf.disk_access_mode;
				 logger.info(""DiskAccessMode is "" + conf.disk_access_mode + "", indexAccessMode is "" + indexAccessMode );
			 }
			 if (conf.authenticator != null) authenticator = FBUtilities.<IAuthenticator>construct(conf.authenticator, ""authenticator"");
			 if (conf.authority != null) authority = FBUtilities.<IAuthority>construct(conf.authority, ""authority"");
			 authenticator.validateConfiguration();
			 authority.validateConfiguration();
			 if (conf.partitioner == null) {
				 throw new ConfigurationException(""Missing directive: partitioner"");
			 }
			 try {
				 partitioner = FBUtilities.newPartitioner(conf.partitioner);
			 }
			 catch (Exception e) {
				 throw new ConfigurationException(""Invalid partitioner class "" + conf.partitioner);
			 }
			 if (conf.phi_convict_threshold < 5 || conf.phi_convict_threshold > 16) {
				 throw new ConfigurationException(""phi_convict_threshold must be between 5 and 16"");
			 }
			 if (conf.concurrent_reads != null && conf.concurrent_reads < 2) {
				 throw new ConfigurationException(""concurrent_reads must be at least 2"");
			 }
			 if (conf.concurrent_writes != null && conf.concurrent_writes < 2) {
				 throw new ConfigurationException(""concurrent_writes must be at least 2"");
			 }
			 if (conf.concurrent_replicates != null && conf.concurrent_replicates < 2) {
				 throw new ConfigurationException(""conf.concurrent_replicates must be at least 2"");
			 }
			 if (conf.memtable_total_space_in_mb == null) conf.memtable_total_space_in_mb = (int) (Runtime.getRuntime().maxMemory() / (3 * 1048576));
			 if (conf.memtable_flush_writers != null && conf.memtable_flush_writers < 1) {
				 throw new ConfigurationException(""memtable_flush_writers must be at least 1"");
			 }
			 else if (conf.memtable_flush_writers == null) {
				 conf.memtable_flush_writers = conf.data_file_directories.length;
			 }
			 if (conf.listen_address != null) {
				 if (conf.listen_address.equals(""0.0.0.0"")) {
				 throw new ConfigurationException(""listen_address must be a single interface. See http: }
				 try {
					 listenAddress = InetAddress.getByName(conf.listen_address);
				 }
				 catch (UnknownHostException e) {
					 throw new ConfigurationException(""Unknown listen_address '"" + conf.listen_address + ""'"");
				 }
			 }
			 if (conf.rpc_address != null) {
				 try {
					 rpcAddress = InetAddress.getByName(conf.rpc_address);
				 }
				 catch (UnknownHostException e) {
					 throw new ConfigurationException(""Unknown host in rpc_address "" + conf.rpc_address);
				 }
			 }
			 if (conf.thrift_framed_transport_size_in_mb <= 0) throw new ConfigurationException(""thrift_framed_transport_size_in_mb must be positive"");
			 if (conf.thrift_framed_transport_size_in_mb > 0 && conf.thrift_max_message_length_in_mb < conf.thrift_framed_transport_size_in_mb) {
				 throw new ConfigurationException(""thrift_max_message_length_in_mb must be greater than thrift_framed_transport_size_in_mb when using TFramedTransport"");
			 }
			 if (conf.compaction_thread_priority < Thread.MIN_PRIORITY || conf.compaction_thread_priority > Thread.NORM_PRIORITY) {
				 throw new ConfigurationException(""compaction_thread_priority must be between 1 and 5"");
			 }
			 if (conf.endpoint_snitch == null) {
				 throw new ConfigurationException(""Missing endpoint_snitch directive"");
			 }
			 snitch = createEndpointSnitch(conf.endpoint_snitch);
			 EndpointSnitchInfo.create();
			 requestSchedulerOptions = conf.request_scheduler_options;
			 if (conf.request_scheduler != null) {
				 try {
					 if (requestSchedulerOptions == null) {
						 requestSchedulerOptions = new RequestSchedulerOptions();
					 }
					 Class cls = Class.forName(conf.request_scheduler);
					 requestScheduler = (IRequestScheduler) cls.getConstructor(RequestSchedulerOptions.class).newInstance(requestSchedulerOptions);
				 }
				 catch (ClassNotFoundException e) {
					 throw new ConfigurationException(""Invalid Request Scheduler class "" + conf.request_scheduler);
				 }
				 catch (Exception e) {
					 throw new ConfigurationException(""Unable to instantiate request scheduler"", e);
				 }
			 }
			 else {
				 requestScheduler = new NoScheduler();
			 }
			 if (conf.request_scheduler_id == RequestSchedulerId.keyspace) {
				 requestSchedulerId = conf.request_scheduler_id;
			 }
			 else {
				 requestSchedulerId = RequestSchedulerId.keyspace;
			 }
			 if (logger.isDebugEnabled() && conf.auto_bootstrap != null) {
				 logger.debug(""setting auto_bootstrap to "" + conf.auto_bootstrap);
			 }
			 if (conf.in_memory_compaction_limit_in_mb != null && conf.in_memory_compaction_limit_in_mb <= 0) {
				 throw new ConfigurationException(""in_memory_compaction_limit_in_mb must be a positive integer"");
			 }
			 if (conf.concurrent_compactors == null) conf.concurrent_compactors = Runtime.getRuntime().availableProcessors();
			 if (conf.concurrent_compactors <= 0) throw new ConfigurationException(""concurrent_compactors should be strictly greater than 0"");
			 if (conf.compaction_throughput_mb_per_sec == null) conf.compaction_throughput_mb_per_sec = 16;
			 if (!CassandraDaemon.rpc_server_types.contains(conf.rpc_server_type.toLowerCase())) throw new ConfigurationException(""Unknown rpc_server_type: "" + conf.rpc_server_type);
			 if (conf.commitlog_directory != null && conf.data_file_directories != null && conf.saved_caches_directory != null) {
				 for (String datadir : conf.data_file_directories) {
					 if (datadir.equals(conf.commitlog_directory)) throw new ConfigurationException(""commitlog_directory must not be the same as any data_file_directories"");
					 if (datadir.equals(conf.saved_caches_directory)) throw new ConfigurationException(""saved_caches_directory must not be the same as any data_file_directories"");
				 }
				 if (conf.commitlog_directory.equals(conf.saved_caches_directory)) throw new ConfigurationException(""saved_caches_directory must not be the same as the commitlog_directory"");
			 }
			 else {
				 if (conf.commitlog_directory == null) throw new ConfigurationException(""commitlog_directory missing"");
				 if (conf.data_file_directories == null) throw new ConfigurationException(""data_file_directories missing;
				 at least one data directory must be specified"");
				 if (conf.saved_caches_directory == null) throw new ConfigurationException(""saved_caches_directory missing"");
			 }
			 if (conf.initial_token != null) partitioner.getTokenFactory().validate(conf.initial_token);
			 KSMetaData systemMeta = new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, KSMetaData.optsWithRF(1), CFMetaData.StatusCf, CFMetaData.HintsCf, CFMetaData.MigrationsCf, CFMetaData.SchemaCf, CFMetaData.IndexCf, CFMetaData.NodeIdCf);
			 CFMetaData.map(CFMetaData.StatusCf);
			 CFMetaData.map(CFMetaData.HintsCf);
			 CFMetaData.map(CFMetaData.MigrationsCf);
			 CFMetaData.map(CFMetaData.SchemaCf);
			 CFMetaData.map(CFMetaData.IndexCf);
			 CFMetaData.map(CFMetaData.NodeIdCf);
			 tables.put(Table.SYSTEM_TABLE, systemMeta);
			 if (conf.seed_provider == null) {
				 throw new ConfigurationException(""seeds configuration is missing;
				 a minimum of one seed is required."");
			 }
			 try {
				 Class seedProviderClass = Class.forName(conf.seed_provider.class_name);
				 seedProvider = (SeedProvider)seedProviderClass.getConstructor(Map.class).newInstance(conf.seed_provider.parameters);
			 }
			 catch (Exception e) {
				 logger.error(""Fatal configuration error"", e);
				 System.err.println(e.getMessage() + ""\nFatal configuration error;
				 unable to start server. See log for stacktrace."");
				 System.exit(1);
			 }
			 if (seedProvider.getSeeds().size() == 0) throw new ConfigurationException(""The seed provider lists no seeds."");
		 }
		 catch (ConfigurationException e) {
			 logger.error(""Fatal configuration error"", e);
			 System.err.println(e.getMessage() + ""\nFatal configuration error;
			 unable to start server. See log for stacktrace."");
			 System.exit(1);
		 }
		 catch (YAMLException e) {
			 logger.error(""Fatal configuration error error"", e);
			 System.err.println(e.getMessage() + ""\nInvalid yaml;
			 unable to start server. See log for stacktrace."");
			 System.exit(1);
		 }
	 }
	 private static IEndpointSnitch createEndpointSnitch(String endpointSnitchClassName) throws ConfigurationException {
		 IEndpointSnitch snitch = FBUtilities.construct(endpointSnitchClassName, ""snitch"");
		 return conf.dynamic_snitch ? new DynamicEndpointSnitch(snitch) : snitch;
	 }
	 public static void loadSchemas() throws IOException {
		 UUID uuid = Migration.getLastMigrationId();
		 if (uuid == null) {
			 logger.info(""Couldn't detect any schema definitions in local storage."");
			 boolean hasExistingTables = false;
			 for (String dataDir : DatabaseDescriptor.getAllDataFileLocations()) {
				 File dataPath = new File(dataDir);
				 if (dataPath.exists() && dataPath.isDirectory()) {
					 int dirCount = dataPath.listFiles(new FileFilter() {
						 public boolean accept(File pathname) {
							 return pathname.isDirectory();
						 }
					 }
					).length;
					 if (dirCount > 0) hasExistingTables = true;
				 }
				 if (hasExistingTables) {
					 break;
				 }
			 }
			 if (hasExistingTables) logger.info(""Found table data in data directories. Consider using the CLI to define your schema."");
			 else logger.info(""To create keyspaces and column families, see 'help create keyspace' in the CLI, or set up a schema using the thrift system_* calls."");
		 }
		 else {
			 logger.info(""Loading schema version "" + uuid.toString());
			 Collection<KSMetaData> tableDefs = DefsTable.loadFromStorage(uuid);
			 for (KSMetaData def : tableDefs) {
				 if (!def.name.matches(Migration.NAME_VALIDATOR_REGEX)) throw new RuntimeException(""invalid keyspace name: "" + def.name);
				 for (CFMetaData cfm : def.cfMetaData().values()) {
					 if (!cfm.cfName.matches(Migration.NAME_VALIDATOR_REGEX)) throw new RuntimeException(""invalid column family name: "" + cfm.cfName);
					 try {
						 CFMetaData.map(cfm);
					 }
					 catch (ConfigurationException ex) {
						 throw new IOError(ex);
					 }
				 }
				 DatabaseDescriptor.setTableDefinition(def, uuid);
			 }
			 if (tableDefs.size() == 0) {
				 logger.warn(""No schema definitions were found in local storage."");
				 defsVersion = uuid;
			 }
		 }
		 CFMetaData.fixMaxId();
	 }
	 public static IAuthenticator getAuthenticator() {
		 return authenticator;
	 }
	 public static IAuthority getAuthority() {
		 return authority;
	 }
	 public static int getThriftMaxMessageLength() {
		 return conf.thrift_max_message_length_in_mb * 1024 * 1024;
	 }
	 public static int getThriftFramedTransportSize() {
		 return conf.thrift_framed_transport_size_in_mb * 1024 * 1024;
	 }
	 public static void createAllDirectories() throws IOException {
		 try {
			 if (conf.data_file_directories.length == 0) {
				 throw new ConfigurationException(""At least one DataFileDirectory must be specified"");
			 }
			 for ( String dataFileDirectory : conf.data_file_directories ) FileUtils.createDirectory(dataFileDirectory);
			 if (conf.commitlog_directory == null) {
				 throw new ConfigurationException(""commitlog_directory must be specified"");
			 }
			 FileUtils.createDirectory(conf.commitlog_directory);
			 if (conf.saved_caches_directory == null) {
				 throw new ConfigurationException(""saved_caches_directory must be specified"");
			 }
			 FileUtils.createDirectory(conf.saved_caches_directory);
		 }
		 catch (ConfigurationException ex) {
			 logger.error(""Fatal error: "" + ex.getMessage());
			 System.err.println(""Bad configuration;
			 unable to start server"");
			 System.exit(1);
		 }
	 }
	 public static IPartitioner getPartitioner() {
		 return partitioner;
	 }
	 public static IEndpointSnitch getEndpointSnitch() {
		 return snitch;
	 }
	 public static void setEndpointSnitch(IEndpointSnitch eps) {
		 snitch = eps;
	 }
	 public static IRequestScheduler getRequestScheduler() {
		 return requestScheduler;
	 }
	 public static RequestSchedulerOptions getRequestSchedulerOptions() {
		 return requestSchedulerOptions;
	 }
	 public static RequestSchedulerId getRequestSchedulerId() {
		 return requestSchedulerId;
	 }
	 public static KSMetaData getKSMetaData(String table) {
		 assert table != null;
		 return tables.get(table);
	 }
	 public static String getJobTrackerAddress() {
		 return conf.job_tracker_host;
	 }
	 public static int getColumnIndexSize() {
		 return conf.column_index_size_in_kb * 1024;
	 }
	 public static String getInitialToken() {
		 return System.getProperty(""cassandra.initial_token"", conf.initial_token);
	 }
	 public static String getClusterName() {
		 return conf.cluster_name;
	 }
	 public static String getJobJarLocation() {
		 return conf.job_jar_file_location;
	 }
	 public static Map<String, CFMetaData> getTableMetaData(String tableName) {
		 assert tableName != null;
		 KSMetaData ksm = tables.get(tableName);
		 assert ksm != null;
		 return ksm.cfMetaData();
	 }
	 public static CFMetaData getCFMetaData(String tableName, String cfName) {
		 assert tableName != null;
		 KSMetaData ksm = tables.get(tableName);
		 if (ksm == null) return null;
		 return ksm.cfMetaData().get(cfName);
	 }
	 public static CFMetaData getCFMetaData(Integer cfId) {
		 Pair<String,String> cf = CFMetaData.getCF(cfId);
		 if (cf == null) return null;
		 return getCFMetaData(cf.left, cf.right);
	 }
	 public static ColumnFamilyType getColumnFamilyType(String tableName, String cfName) {
		 assert tableName != null && cfName != null;
		 CFMetaData cfMetaData = getCFMetaData(tableName, cfName);
		 if (cfMetaData == null) return null;
		 return cfMetaData.cfType;
	 }
	 public static Set<String> getTables() {
		 return tables.keySet();
	 }
	 public static List<String> getNonSystemTables() {
		 List<String> tableslist = new ArrayList<String>(tables.keySet());
		 tableslist.remove(Table.SYSTEM_TABLE);
		 return Collections.unmodifiableList(tableslist);
	 }
	 public static int getStoragePort() {
		 return Integer.parseInt(System.getProperty(""cassandra.storage_port"", conf.storage_port.toString()));
	 }
	 public static int getRpcPort() {
		 return Integer.parseInt(System.getProperty(""cassandra.rpc_port"", conf.rpc_port.toString()));
	 }
	 public static long getRpcTimeout() {
		 return conf.rpc_timeout_in_ms;
	 }
	 public static int getPhiConvictThreshold() {
		 return conf.phi_convict_threshold;
	 }
	 public static int getConcurrentReaders() {
		 return conf.concurrent_reads;
	 }
	 public static int getConcurrentWriters() {
		 return conf.concurrent_writes;
	 }
	 public static int getConcurrentReplicators() {
		 return conf.concurrent_replicates;
	 }
	 public static int getFlushWriters() {
		 return conf.memtable_flush_writers;
	 }
	 public static int getInMemoryCompactionLimit() {
		 return conf.in_memory_compaction_limit_in_mb * 1024 * 1024;
	 }
	 public static int getConcurrentCompactors() {
		 return conf.concurrent_compactors;
	 }
	 public static int getCompactionThroughputMbPerSec() {
		 return conf.compaction_throughput_mb_per_sec;
	 }
	 public static void setCompactionThroughputMbPerSec(int value) {
		 conf.compaction_throughput_mb_per_sec = value;
	 }
	 public static String[] getAllDataFileLocations() {
		 return conf.data_file_directories;
	 }
	 public static String[] getAllDataFileLocationsForTable(String table) {
		 String[] tableLocations = new String[conf.data_file_directories.length];
		 for (int i = 0;
		 i < conf.data_file_directories.length;
		 i++) {
			 tableLocations[i] = conf.data_file_directories[i] + File.separator + table;
		 }
		 return tableLocations;
	 }
	 public synchronized static String getNextAvailableDataLocation() {
		 String dataFileDirectory = conf.data_file_directories[currentIndex];
		 currentIndex = (currentIndex + 1) % conf.data_file_directories.length;
		 return dataFileDirectory;
	 }
	 public static int getCommitLogSegmentSize() {
		 return conf.commitlog_rotation_threshold_in_mb != null ? conf.commitlog_rotation_threshold_in_mb * 1024 * 1024 : 128*1024*1024;
	 }
	 public static String getCommitLogLocation() {
		 return conf.commitlog_directory;
	 }
	 public static String getSavedCachesLocation() {
		 return conf.saved_caches_directory;
	 }
	 public static Set<InetAddress> getSeeds() {
		 return Collections.unmodifiableSet(new HashSet(seedProvider.getSeeds()));
	 }
	 public static String getDataFileLocationForTable(String table, long expectedCompactedFileSize) {
		 long maxFreeDisk = 0;
		 int maxDiskIndex = 0;
		 String dataFileDirectory = null;
		 String[] dataDirectoryForTable = getAllDataFileLocationsForTable(table);
		 for ( int i = 0 ;
		 i < dataDirectoryForTable.length ;
		 i++ ) {
			 File f = new File(dataDirectoryForTable[i]);
			 if( maxFreeDisk < f.getUsableSpace()) {
				 maxFreeDisk = f.getUsableSpace();
				 maxDiskIndex = i;
			 }
		 }
		 logger.debug(""expected data files size is {
		}
		;
		 largest free partition has {
		}
		 bytes free"", expectedCompactedFileSize, maxFreeDisk);
		 maxFreeDisk = (long)(0.9 * maxFreeDisk);
		 if( expectedCompactedFileSize < maxFreeDisk ) {
			 dataFileDirectory = dataDirectoryForTable[maxDiskIndex];
			 currentIndex = (maxDiskIndex + 1 )%dataDirectoryForTable.length ;
		 }
		 else {
			 currentIndex = maxDiskIndex;
		 }
		 return dataFileDirectory;
	 }
	 public static AbstractType getComparator(String ksName, String cfName) {
		 assert ksName != null;
		 CFMetaData cfmd = getCFMetaData(ksName, cfName);
		 if (cfmd == null) throw new IllegalArgumentException(""Unknown ColumnFamily "" + cfName + "" in keyspace "" + ksName);
		 return cfmd.comparator;
	 }
	 public static AbstractType getSubComparator(String tableName, String cfName) {
		 assert tableName != null;
		 return getCFMetaData(tableName, cfName).subcolumnComparator;
	 }
	 public static KSMetaData getTableDefinition(String table) {
		 return tables.get(table);
	 }
	 public static void setTableDefinition(KSMetaData ksm, UUID newVersion) {
		 if (ksm != null) tables.put(ksm.name, ksm);
		 DatabaseDescriptor.defsVersion = newVersion;
	 }
	 public static void clearTableDefinition(KSMetaData ksm, UUID newVersion) {
		 tables.remove(ksm.name);
		 DatabaseDescriptor.defsVersion = newVersion;
	 }
	 public static UUID getDefsVersion() {
		 return defsVersion;
	 }
	 public static InetAddress getListenAddress() {
		 return listenAddress;
	 }
	 public static InetAddress getRpcAddress() {
		 return rpcAddress;
	 }
	 public static String getRpcServerType() {
		 return conf.rpc_server_type;
	 }
	 public static boolean getRpcKeepAlive() {
		 return conf.rpc_keepalive;
	 }
	 public static Integer getRpcMinThreads() {
		 return conf.rpc_min_threads;
	 }
	 public static Integer getRpcMaxThreads() {
		 return conf.rpc_max_threads;
	 }
	 public static Integer getRpcSendBufferSize() {
		 return conf.rpc_send_buff_size_in_bytes;
	 }
	 public static Integer getRpcRecvBufferSize() {
		 return conf.rpc_recv_buff_size_in_bytes;
	 }
	 public static double getCommitLogSyncBatchWindow() {
		 return conf.commitlog_sync_batch_window_in_ms;
	 }
	 public static int getCommitLogSyncPeriod() {
		 return conf.commitlog_sync_period_in_ms;
	 }
	 public static Config.CommitLogSync getCommitLogSync() {
		 return conf.commitlog_sync;
	 }
	 public static Config.DiskAccessMode getDiskAccessMode() {
		 return conf.disk_access_mode;
	 }
	 public static Config.DiskAccessMode getIndexAccessMode() {
		 return indexAccessMode;
	 }
	 public static int getIndexedReadBufferSizeInKB() {
		 return conf.column_index_size_in_kb;
	 }
	 public static int getSlicedReadBufferSizeInKB() {
		 return conf.sliced_buffer_size_in_kb;
	 }
	 public static int getBMTThreshold() {
		 return conf.binary_memtable_throughput_in_mb;
	 }
	 public static int getCompactionThreadPriority() {
		 return conf.compaction_thread_priority;
	 }
	 public static boolean isSnapshotBeforeCompaction() {
		 return conf.snapshot_before_compaction;
	 }
	 public static boolean isAutoBootstrap() {
		 return conf.auto_bootstrap;
	 }
	 public static boolean hintedHandoffEnabled() {
		 return conf.hinted_handoff_enabled;
	 }
	 public static int getMaxHintWindow() {
		 return conf.max_hint_window_in_ms;
	 }
	 public static AbstractType getValueValidator(String keyspace, String cf, ByteBuffer column) {
		 return getCFMetaData(keyspace, cf).getValueValidator(column);
	 }
	 public static CFMetaData getCFMetaData(Descriptor desc) {
		 return getCFMetaData(desc.ksname, desc.cfname);
	 }
	 public static Integer getIndexInterval() {
		 return conf.index_interval;
	 }
	 public static File getSerializedCachePath(String ksName, String cfName, ColumnFamilyStore.CacheType cacheType) {
		 return new File(conf.saved_caches_directory + File.separator + ksName + ""-"" + cfName + ""-"" + cacheType);
	 }
	 public static int getDynamicUpdateInterval() {
		 return conf.dynamic_snitch_update_interval_in_ms;
	 }
	 public static void setDynamicUpdateInterval(Integer dynamicUpdateInterval) {
		 conf.dynamic_snitch_update_interval_in_ms = dynamicUpdateInterval;
	 }
	 public static int getDynamicResetInterval() {
		 return conf.dynamic_snitch_reset_interval_in_ms;
	 }
	 public static void setDynamicResetInterval(Integer dynamicResetInterval) {
		 conf.dynamic_snitch_reset_interval_in_ms = dynamicResetInterval;
	 }
	 public static double getDynamicBadnessThreshold() {
		 return conf.dynamic_snitch_badness_threshold;
	 }
	 public static void setDynamicBadnessThreshold(Double dynamicBadnessThreshold) {
		 conf.dynamic_snitch_badness_threshold = dynamicBadnessThreshold;
	 }
	 public static EncryptionOptions getEncryptionOptions() {
		 return conf.encryption_options;
	 }
	 public static double getFlushLargestMemtablesAt() {
		 return conf.flush_largest_memtables_at;
	 }
	 public static double getReduceCacheSizesAt() {
		 return conf.reduce_cache_sizes_at;
	 }
	 public static double getReduceCacheCapacityTo() {
		 return conf.reduce_cache_capacity_to;
	 }
	 public static int getHintedHandoffThrottleDelay() {
		 return conf.hinted_handoff_throttle_delay_in_ms;
	 }
	 public static boolean getPreheatKeyCache() {
		 return conf.compaction_preheat_key_cache;
	 }
	 public static void validateMemtableThroughput(int sizeInMB) throws ConfigurationException {
		 if (sizeInMB <= 0) throw new ConfigurationException(""memtable_throughput_in_mb must be greater than 0."");
	 }
	 public static void validateMemtableOperations(double operationsInMillions) throws ConfigurationException {
		 if (operationsInMillions <= 0) throw new ConfigurationException(""memtable_operations_in_millions must be greater than 0.0."");
		 if (operationsInMillions > Long.MAX_VALUE / 1024 * 1024) throw new ConfigurationException(""memtable_operations_in_millions must be less than "" + Long.MAX_VALUE / 1024 * 1024);
	 }
	 public static void validateMemtableFlushPeriod(int minutes) throws ConfigurationException {
		 if (minutes <= 0) throw new ConfigurationException(""memtable_flush_after_mins must be greater than 0."");
	 }
	 public static boolean incrementalBackupsEnabled() {
		 return conf.incremental_backups;
	 }
	 public static int getFlushQueueSize() {
		 return conf.memtable_flush_queue_size;
	 }
	 public static int getTotalMemtableSpaceInMB() {
		 assert conf.memtable_total_space_in_mb > 0;
		 return conf.memtable_total_space_in_mb;
	 }
	 public static boolean estimatesRealMemtableSize() {
		 return conf.memtable_total_space_in_mb > 0;
	 }
}",0,0,0,0
"public abstract class OutputFormatBase implements OutputFormat {
	 public abstract RecordWriter getRecordWriter(FileSystem fs, JobConf job, String name) throws IOException;
	 public void checkOutputSpecs(FileSystem fs, JobConf job) throws IOException {
		 Path outDir = job.getOutputPath();
		 if (outDir == null && job.getNumReduceTasks() != 0) {
			 throw new IOException(""Output directory not set in JobConf."");
		 }
		 if (outDir != null && fs.exists(outDir)) {
			 throw new IOException(""Output directory "" + outDir + "" already exists."");
		 }
	 }
}",0,0,0,0
"public class RichMediaActivation extends PdfDictionary {
	public RichMediaActivation() {
		super(PdfName.RICHMEDIAACTIVATION);
	}
	public void setCondition(PdfName condition) {
		put(PdfName.CONDITION, condition);
	}
	public void setAnimation(RichMediaAnimation animation) {
		put(PdfName.ANIMATION, animation);
	}
	public void setView(PdfIndirectReference view) {
		put(PdfName.VIEW, view);
	}
	public void setConfiguration(PdfIndirectReference configuration) {
		put(PdfName.CONFIGURATION, configuration);
	}
	public void setPresentation(RichMediaPresentation richMediaPresentation) {
		put(PdfName.PRESENTATION, richMediaPresentation);
	}
	public void setScripts(PdfArray scripts) {
		put(PdfName.SCRIPTS, scripts);
	}
}",0,0,0,0
"public class BindableSolrParameter {
	private final int index;
	private final Object value;
	private float boost;
	public BindableSolrParameter(int index, Object value) {
		super();
		this.index = index;
		this.value = value;
	}
	public float getBoost() {
		return boost;
	}
	public void setBoost(float boost) {
		this.boost = boost;
	}
	public int getIndex() {
		return index;
	}
	public Object getValue() {
		return value;
	}
}",0,1,0,0
"public synchronized boolean isFollowSymlinks() {
	 return followSymlinks;
 }",0,0,0,0
"public class DescriptorHandler extends org.xml.sax.HandlerBase {
	 private static final int DEFAULT_HASH_TABLE_SIZE = 10;
	 private static final int STATE_LOOKING_EJBJAR = 1;
	 private static final int STATE_IN_EJBJAR = 2;
	 private static final int STATE_IN_BEANS = 3;
	 private static final int STATE_IN_SESSION = 4;
	 private static final int STATE_IN_ENTITY = 5;
	 private static final int STATE_IN_MESSAGE = 6;
	 private Task owningTask;
	 private String publicId = null;
	 private static final String EJB_REF = ""ejb-ref"";
	 private static final String EJB_LOCAL_REF = ""ejb-local-ref"";
	 private static final String HOME_INTERFACE = ""home"";
	 private static final String REMOTE_INTERFACE = ""remote"";
	 private static final String LOCAL_HOME_INTERFACE = ""local-home"";
	 private static final String LOCAL_INTERFACE = ""local"";
	 private static final String BEAN_CLASS = ""ejb-class"";
	 private static final String PK_CLASS = ""prim-key-class"";
	 private static final String EJB_NAME = ""ejb-name"";
	 private static final String EJB_JAR = ""ejb-jar"";
	 private static final String ENTERPRISE_BEANS = ""enterprise-beans"";
	 private static final String ENTITY_BEAN = ""entity"";
	 private static final String SESSION_BEAN = ""session"";
	 private static final String MESSAGE_BEAN = ""message-driven"";
	 private int parseState = STATE_LOOKING_EJBJAR;
	 protected String currentElement = null;
	 protected String currentText = null;
	 protected Hashtable ejbFiles = null;
	 protected String ejbName = null;
	 private Hashtable fileDTDs = new Hashtable();
	 private Hashtable resourceDTDs = new Hashtable();
	 private boolean inEJBRef = false;
	 private Hashtable urlDTDs = new Hashtable();
	 private File srcDir;
	 public DescriptorHandler(Task task, File srcDir) {
		 this.owningTask = task;
		 this.srcDir = srcDir;
	 }
	 public void registerDTD(String publicId, String location) {
		 if (location == null) {
			 return;
		 }
		 File fileDTD = new File(location);
		 if (!fileDTD.exists()) {
			 fileDTD = owningTask.getProject().resolveFile(location);
		 }
		 if (fileDTD.exists()) {
			 if (publicId != null) {
				 fileDTDs.put(publicId, fileDTD);
				 owningTask.log(""Mapped publicId "" + publicId + "" to file "" + fileDTD, Project.MSG_VERBOSE);
			 }
			 return;
		 }
		 if (getClass().getResource(location) != null) {
			 if (publicId != null) {
				 resourceDTDs.put(publicId, location);
				 owningTask.log(""Mapped publicId "" + publicId + "" to resource "" + location, Project.MSG_VERBOSE);
			 }
		 }
		 try {
			 if (publicId != null) {
				 URL urldtd = new URL(location);
				 urlDTDs.put(publicId, urldtd);
			 }
		 }
		 catch (java.net.MalformedURLException e) {
		 }
	 }
	 public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
		 this.publicId = publicId;
		 File dtdFile = (File) fileDTDs.get(publicId);
		 if (dtdFile != null) {
			 try {
				 owningTask.log(""Resolved "" + publicId + "" to local file "" + dtdFile, Project.MSG_VERBOSE);
				 return new InputSource(new FileInputStream(dtdFile));
			 }
			 catch (FileNotFoundException ex) {
			 }
		 }
		 String dtdResourceName = (String) resourceDTDs.get(publicId);
		 if (dtdResourceName != null) {
			 InputStream is = this.getClass().getResourceAsStream(dtdResourceName);
			 if (is != null) {
				 owningTask.log(""Resolved "" + publicId + "" to local resource "" + dtdResourceName, Project.MSG_VERBOSE);
				 return new InputSource(is);
			 }
		 }
		 URL dtdUrl = (URL) urlDTDs.get(publicId);
		 if (dtdUrl != null) {
			 try {
				 InputStream is = dtdUrl.openStream();
				 owningTask.log(""Resolved "" + publicId + "" to url "" + dtdUrl, Project.MSG_VERBOSE);
				 return new InputSource(is);
			 }
			 catch (IOException ioe) {
			 }
		 }
		 owningTask.log(""Could not resolve ( publicId: "" + publicId + "", systemId: "" + systemId + "") to a local entity"", Project.MSG_INFO);
		 return null;
	 }
	 public Hashtable getFiles() {
		 return (ejbFiles == null) ? new Hashtable() : ejbFiles;
	 }
	 public String getPublicId() {
		 return publicId;
	 }
	 public String getEjbName() {
		 return ejbName;
	 }
	 public void startDocument() throws SAXException {
		 this.ejbFiles = new Hashtable(DEFAULT_HASH_TABLE_SIZE, 1);
		 this.currentElement = null;
		 inEJBRef = false;
	 }
	 public void startElement(String name, AttributeList attrs) throws SAXException {
		 this.currentElement = name;
		 currentText = """";
		 if (name.equals(EJB_REF) || name.equals(EJB_LOCAL_REF)) {
			 inEJBRef = true;
		 }
		 else if (parseState == STATE_LOOKING_EJBJAR && name.equals(EJB_JAR)) {
			 parseState = STATE_IN_EJBJAR;
		 }
		 else if (parseState == STATE_IN_EJBJAR && name.equals(ENTERPRISE_BEANS)) {
			 parseState = STATE_IN_BEANS;
		 }
		 else if (parseState == STATE_IN_BEANS && name.equals(SESSION_BEAN)) {
			 parseState = STATE_IN_SESSION;
		 }
		 else if (parseState == STATE_IN_BEANS && name.equals(ENTITY_BEAN)) {
			 parseState = STATE_IN_ENTITY;
		 }
		 else if (parseState == STATE_IN_BEANS && name.equals(MESSAGE_BEAN)) {
			 parseState = STATE_IN_MESSAGE;
		 }
	 }
	 public void endElement(String name) throws SAXException {
		 processElement();
		 currentText = """";
		 this.currentElement = """";
		 if (name.equals(EJB_REF) || name.equals(EJB_LOCAL_REF)) {
			 inEJBRef = false;
		 }
		 else if (parseState == STATE_IN_ENTITY && name.equals(ENTITY_BEAN)) {
			 parseState = STATE_IN_BEANS;
		 }
		 else if (parseState == STATE_IN_SESSION && name.equals(SESSION_BEAN)) {
			 parseState = STATE_IN_BEANS;
		 }
		 else if (parseState == STATE_IN_MESSAGE && name.equals(MESSAGE_BEAN)) {
			 parseState = STATE_IN_BEANS;
		 }
		 else if (parseState == STATE_IN_BEANS && name.equals(ENTERPRISE_BEANS)) {
			 parseState = STATE_IN_EJBJAR;
		 }
		 else if (parseState == STATE_IN_EJBJAR && name.equals(EJB_JAR)) {
			 parseState = STATE_LOOKING_EJBJAR;
		 }
	 }
	 public void characters(char[] ch, int start, int length) throws SAXException {
		 currentText += new String(ch, start, length);
	 }
	 protected void processElement() {
		 if (inEJBRef || (parseState != STATE_IN_ENTITY && parseState != STATE_IN_SESSION && parseState != STATE_IN_MESSAGE)) {
			 return;
		 }
		 if (currentElement.equals(HOME_INTERFACE) || currentElement.equals(REMOTE_INTERFACE) || currentElement.equals(LOCAL_INTERFACE) || currentElement.equals(LOCAL_HOME_INTERFACE) || currentElement.equals(BEAN_CLASS) || currentElement.equals(PK_CLASS)) {
			 File classFile = null;
			 String className = currentText.trim();
			 if (!className.startsWith(""java."") && !className.startsWith(""javax."")) {
				 className = className.replace('.', File.separatorChar);
				 className += "".class"";
				 classFile = new File(srcDir, className);
				 ejbFiles.put(className, classFile);
			 }
		 }
		 if (currentElement.equals(EJB_NAME)) {
			 if (ejbName == null) {
				 ejbName = currentText.trim();
			 }
		 }
	 }
}",0,0,0,0
"public interface AclEntry{
	 public boolean addPermission(Permission permission);
	 public boolean checkPermission(Permission permission);
	 public Principal getPrincipal();
	 public Enumeration permissions();
	 public boolean removePermission(Permission permission);
	 public boolean setPrincipal(Principal user);
	 public String toString();
}",0,1,0,0
"public static long pop_andnot(long A[], long B[], int wordOffset, int numWords) {
	 int n = wordOffset+numWords;
	 long tot=0, tot8=0;
	 long ones=0, twos=0, fours=0;
	 int i;
	 for (i = wordOffset;
	 i <= n - 8;
	 i+=8) {
		 long twosA,twosB,foursA,foursB,eights;
		 {
			 long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
			 long u=ones ^ b;
			 twosA=(ones & b)|( u & c);
			 ones=u^c;
		 }
		 {
			 long b=(A[i+2] & ~B[i+2]), c=(A[i+3] & ~B[i+3]);
			 long u=ones^b;
			 twosB =(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursA=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 {
			 long b=(A[i+4] & ~B[i+4]), c=(A[i+5] & ~B[i+5]);
			 long u=ones^b;
			 twosA=(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long b=(A[i+6] & ~B[i+6]), c=(A[i+7] & ~B[i+7]);
			 long u=ones^b;
			 twosB=(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursB=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 {
			 long u=fours^foursA;
			 eights=(fours&foursA)|(u&foursB);
			 fours=u^foursB;
		 }
		 tot8 += pop(eights);
	 }
	 if (i<=n-4) {
		 long twosA, twosB, foursA, eights;
		 {
			 long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
			 long u=ones ^ b;
			 twosA=(ones & b)|( u & c);
			 ones=u^c;
		 }
		 {
			 long b=(A[i+2] & ~B[i+2]), c=(A[i+3] & ~B[i+3]);
			 long u=ones^b;
			 twosB =(ones&b)|(u&c);
			 ones=u^c;
		 }
		 {
			 long u=twos^twosA;
			 foursA=(twos&twosA)|(u&twosB);
			 twos=u^twosB;
		 }
		 eights=fours&foursA;
		 fours=fours^foursA;
		 tot8 += pop(eights);
		 i+=4;
	 }
	 if (i<=n-2) {
		 long b=(A[i] & ~B[i]), c=(A[i+1] & ~B[i+1]);
		 long u=ones ^ b;
		 long twosA=(ones & b)|( u & c);
		 ones=u^c;
		 long foursA=twos&twosA;
		 twos=twos^twosA;
		 long eights=fours&foursA;
		 fours=fours^foursA;
		 tot8 += pop(eights);
		 i+=2;
	 }
	 if (i<n) {
		 tot += pop((A[i] & ~B[i]));
	 }
	 tot += (pop(fours)<<2) + (pop(twos)<<1) + pop(ones) + (tot8<<3);
	 return tot;
 }",0,0,1,0
"public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea, ValueAxis domainAxis, ValueAxis rangeAxis, int rendererIndex, PlotRenderingInfo info);",0,0,0,1
"UploadResponse doPost(final HttpServletRequest request) {
	logger.debug(""Entering Dispatcher#doPost"");
	Context context = ThreadLocalData.getContext();
	context.logBaseParameters();
	UploadResponse uploadResponse = null;
	if (!RequestCycleHandler.isFileUploadEnabled(request))uploadResponse = UploadResponse.getFileUploadDisabledError();
	else if (!Command.isValidForPost(context.getCommandStr()))uploadResponse = UploadResponse.getInvalidCommandError();
	else if (!ResourceType.isValidType(context.getTypeStr()))uploadResponse = UploadResponse.getInvalidResourceTypeError();
	else if (!UtilsFile.isValidPath(context.getCurrentFolderStr()))uploadResponse = UploadResponse.getInvalidCurrentFolderError();
	else {
		ResourceType type = context.getDefaultResourceType();
		FileItemFactory factory = new DiskFileItemFactory();
		ServletFileUpload upload = new ServletFileUpload(factory);
		try {
			List<FileItem> items = upload.parseRequest(request);
			FileItem uplFile = items.get(0);
			String fileName = FilenameUtils.getName(uplFile.getName());
			logger.debug(""Parameter NewFile: {
			}
			"", fileName);
			if (type.isDeniedExtension(FilenameUtils.getExtension(fileName)))uploadResponse = UploadResponse.getInvalidFileTypeError();
			else if (type.equals(ResourceType.IMAGE)&& PropertiesLoader.isSecureImageUploads()&& !UtilsFile.isImage(uplFile.getInputStream())) {
				uploadResponse = UploadResponse.getInvalidFileTypeError();
			}
			 else {
				String sanitizedFileName = UtilsFile.sanitizeFileName(fileName);
				logger.debug(""Parameter NewFile (sanitized): {
				}
				"",sanitizedFileName);
				String newFileName = connector.fileUpload(type, context.getCurrentFolderStr(), sanitizedFileName, uplFile.getInputStream());
				String fileUrl = UtilsResponse.fileUrl(RequestCycleHandler.getUserFilesPath(request), type, context.getCurrentFolderStr(), newFileName);
				if (sanitizedFileName.equals(newFileName))uploadResponse = UploadResponse.getOK(fileUrl);
				else {
					uploadResponse = UploadResponse.getFileRenamedWarning(fileUrl, newFileName);
					logger.debug(""Parameter NewFile (renamed): {
					}
					"",newFileName);
				}
			}
			uplFile.delete();
		}
		 catch (InvalidCurrentFolderException e) {
			uploadResponse = UploadResponse.getInvalidCurrentFolderError();
		}
		 catch (WriteException e) {
			uploadResponse = UploadResponse.getFileUploadWriteError();
		}
		 catch (IOException e) {
			uploadResponse = UploadResponse.getFileUploadWriteError();
		}
		 catch (FileUploadException e) {
			uploadResponse = UploadResponse.getFileUploadWriteError();
		}
	}
	logger.debug(""Exiting Dispatcher#doPost"");
	return uploadResponse;
}",0,0,1,0
"public Object processNode (Node node, String prefix, Object container) {
	 Object addedPath = null;
	 String id = null;
	 if (node.hasAttributes()) {
		 NamedNodeMap nodeAttributes = node.getAttributes();
		 Node idNode = nodeAttributes.getNamedItem(ID);
		 id = semanticAttributes && idNode != null ? idNode.getNodeValue() : null;
		 for (int i = 0;
		 i < nodeAttributes.getLength();
		 i++) {
			 Node attributeNode = nodeAttributes.item(i);
			 if (!semanticAttributes) {
				 String attributeName = getAttributeName(attributeNode);
				 String attributeValue = getAttributeValue(attributeNode);
				 addProperty(prefix + attributeName, attributeValue, null);
			 }
			 else {
				 String nodeName = attributeNode.getNodeName();
				 String attributeValue = getAttributeValue(attributeNode);
				 Path containingPath = ((container != null) && (container instanceof Path)) ? (Path) container : null;
				 if (nodeName.equals(ID)) {
					 continue;
				 }
				 if (containingPath != null && nodeName.equals(PATH)) {
					 containingPath.setPath(attributeValue);
				 }
				 else if (container instanceof Path && nodeName.equals(REF_ID)) {
					 containingPath.setPath(attributeValue);
				 }
				 else if (container instanceof Path && nodeName.equals(LOCATION)) {
					 containingPath.setLocation(resolveFile(attributeValue));
				 }
				 else if (nodeName.equals(PATHID)) {
					 if (container != null) {
						 throw new BuildException(""XmlProperty does not support nested paths"");
					 }
					 addedPath = new Path(getProject());
					 getProject().addReference(attributeValue, addedPath);
				 }
				 else {
					 String attributeName = getAttributeName(attributeNode);
					 addProperty(prefix + attributeName, attributeValue, id);
				 }
			 }
		 }
	 }
	 String nodeText = null;
	 boolean emptyNode = false;
	 boolean semanticEmptyOverride = false;
	 if (node.getNodeType() == Node.ELEMENT_NODE && semanticAttributes && node.hasAttributes() && (node.getAttributes().getNamedItem(VALUE) != null || node.getAttributes().getNamedItem(LOCATION) != null || node.getAttributes().getNamedItem(REF_ID) != null || node.getAttributes().getNamedItem(PATH) != null || node.getAttributes() .getNamedItem(PATHID) != null)) {
		 semanticEmptyOverride = true;
	 }
	 if (node.getNodeType() == Node.TEXT_NODE) {
		 nodeText = getAttributeValue(node);
	 }
	 else if (node.getNodeType() == Node.ELEMENT_NODE && node.getChildNodes().getLength() == 1 && node.getFirstChild().getNodeType() == Node.CDATA_SECTION_NODE) {
		 nodeText = node.getFirstChild().getNodeValue();
		 if ("""".equals(nodeText) && !semanticEmptyOverride) {
			 emptyNode = true;
		 }
	 }
	 else if (node.getNodeType() == Node.ELEMENT_NODE && node.getChildNodes().getLength() == 0 && !semanticEmptyOverride) {
		 nodeText = """";
		 emptyNode = true;
	 }
	 else if (node.getNodeType() == Node.ELEMENT_NODE && node.getChildNodes().getLength() == 1 && node.getFirstChild().getNodeType() == Node.TEXT_NODE && """".equals(node.getFirstChild().getNodeValue()) && !semanticEmptyOverride) {
		 nodeText = """";
		 emptyNode = true;
	 }
	 if (nodeText != null) {
		 if (semanticAttributes && id == null && container instanceof String) {
			 id = (String) container;
		 }
		 if (nodeText.trim().length() != 0 || emptyNode) {
			 addProperty(prefix, nodeText, id);
		 }
	 }
	 return (addedPath != null ? addedPath : id);
 }",0,0,1,0
"public class WicketLinkResolver implements IComponentResolver{
	private static final long serialVersionUID = 1L;
	public boolean resolve(final MarkupContainer container, final MarkupStream markupStream,final ComponentTag tag){
		if (tag instanceof WicketTag){
			WicketTag wtag = (WicketTag)tag;
			if (wtag.isLinkTag() && (wtag.getNamespace() != null)){
				final String id = tag.getId() + container.getPage().getAutoIndex();
				final Component component = new WebMarkupContainer(id){
					private static final long serialVersionUID = 1L;
					public boolean isTransparentResolver(){
						return true;
					}
				}
				;
				container.autoAdd(component, markupStream);
				return true;
			}
		}
		return false;
	}
}",0,0,0,0
"public class JdbcUTF8 extends AbstractJdbcType<String>{
	 public static final JdbcUTF8 instance = new JdbcUTF8();
	 public JdbcUTF8() {
	}
	 public boolean isCaseSensitive() {
		 return true;
	 }
	 public int getScale(String obj) {
		 return -1;
	 }
	 public int getPrecision(String obj) {
		 return -1;
	 }
	 public boolean isCurrency() {
		 return false;
	 }
	 public boolean isSigned() {
		 return false;
	 }
	 public String toString(String obj) {
		 return obj;
	 }
	 public boolean needsQuotes() {
		 return true;
	 }
	 public String getString(ByteBuffer bytes) {
		 try {
			 return ByteBufferUtil.string(bytes);
		 }
		 catch (CharacterCodingException e) {
			 throw new MarshalException(""invalid UTF8 bytes "" + ByteBufferUtil.bytesToHex(bytes));
		 }
	 }
	 public Class<String> getType() {
		 return String.class;
	 }
	 public int getJdbcType() {
		 return Types.VARCHAR;
	 }
	 public String compose(ByteBuffer bytes) {
		 return getString(bytes);
	 }
	 public ByteBuffer decompose(String value) {
		 return ByteBufferUtil.bytes(value, Charsets.UTF_8);
	 }
}",0,0,0,0
"public class Status {
	private StatusCode code;
	private String message;
	private String detail;
	public StatusCode getCode() {
		return code;
	}
	public Status setCode(StatusCode code) {
		this.code = code;
		return this;
	}
	public String getMessage() {
		return message;
	}
	public Status setMessage(String message) {
		this.message = message;
		return this;
	}
	public String getDetail() {
		return detail;
	}
	public Status setDetail(String detail) {
		this.detail = detail;
		return this;
	}
}",0,1,0,0
"public void processRecord(Record record) {
	int thisRow = -1;
	int thisColumn = -1;
	String thisStr = null;
	switch (record.getSid()){
		case BoundSheetRecord.sid:boundSheetRecords.add(record);
		break;
		case BOFRecord.sid:BOFRecord br = (BOFRecord)record;
		if(br.getType() == BOFRecord.TYPE_WORKSHEET) {
			if(workbookBuildingListener != null && stubWorkbook == null) {
				stubWorkbook = workbookBuildingListener.getStubHSSFWorkbook();
			}
			sheetIndex++;
			if(orderedBSRs == null) {
				orderedBSRs = BoundSheetRecord.orderByBofPosition(boundSheetRecords);
			}
			output.println();
			output.println( orderedBSRs[sheetIndex].getSheetname() +"" ["" + (sheetIndex+1) + ""]:"");
		}
		break;
		case SSTRecord.sid:sstRecord = (SSTRecord) record;
		break;
		case BlankRecord.sid:BlankRecord brec = (BlankRecord) record;
		thisRow = brec.getRow();
		thisColumn = brec.getColumn();
		thisStr = """";
		break;
		case BoolErrRecord.sid:BoolErrRecord berec = (BoolErrRecord) record;
		thisRow = berec.getRow();
		thisColumn = berec.getColumn();
		thisStr = """";
		break;
		case FormulaRecord.sid:FormulaRecord frec = (FormulaRecord) record;
		thisRow = frec.getRow();
		thisColumn = frec.getColumn();
		if(outputFormulaValues) {
			if(Double.isNaN( frec.getValue() )) {
				outputNextStringRecord = true;
				nextRow = frec.getRow();
				nextColumn = frec.getColumn();
			}
			 else {
				thisStr = formatListener.formatNumberDateCell(frec);
			}
		}
		 else {
			thisStr = '""' +HSSFFormulaParser.toFormulaString(stubWorkbook, frec.getParsedExpression()) + '""';
		}
		break;
		case StringRecord.sid:if(outputNextStringRecord) {
			StringRecord srec = (StringRecord)record;
			thisStr = srec.getString();
			thisRow = nextRow;
			thisColumn = nextColumn;
			outputNextStringRecord = false;
		}
		break;
		case LabelRecord.sid:LabelRecord lrec = (LabelRecord) record;
		thisRow = lrec.getRow();
		thisColumn = lrec.getColumn();
		thisStr = '""' + lrec.getValue() + '""';
		break;
		case LabelSSTRecord.sid:LabelSSTRecord lsrec = (LabelSSTRecord) record;
		thisRow = lsrec.getRow();
		thisColumn = lsrec.getColumn();
		if(sstRecord == null) {
			thisStr = '""' + ""(No SST Record, can't identify string)"" + '""';
		}
		 else {
			thisStr = '""' + sstRecord.getString(lsrec.getSSTIndex()).toString() + '""';
		}
		break;
		case NoteRecord.sid:NoteRecord nrec = (NoteRecord) record;
		thisRow = nrec.getRow();
		thisColumn = nrec.getColumn();
		thisStr = '""' + ""(TODO)"" + '""';
		break;
		case NumberRecord.sid:NumberRecord numrec = (NumberRecord) record;
		thisRow = numrec.getRow();
		thisColumn = numrec.getColumn();
		thisStr = formatListener.formatNumberDateCell(numrec);
		break;
		case RKRecord.sid:RKRecord rkrec = (RKRecord) record;
		thisRow = rkrec.getRow();
		thisColumn = rkrec.getColumn();
		thisStr = '""' + ""(TODO)"" + '""';
		break;
		default:break;
	}
	if(thisRow != -1 && thisRow != lastRowNumber) {
		lastColumnNumber = -1;
	}
	if(record instanceof MissingCellDummyRecord) {
		MissingCellDummyRecord mc = (MissingCellDummyRecord)record;
		thisRow = mc.getRow();
		thisColumn = mc.getColumn();
		thisStr = """";
	}
	if(thisStr != null) {
		if(thisColumn > 0) {
			output.print(',');
		}
		output.print(thisStr);
	}
	if(thisRow > -1)lastRowNumber = thisRow;
	if(thisColumn > -1)lastColumnNumber = thisColumn;
	if(record instanceof LastCellOfRowDummyRecord) {
		if(minColumns > 0) {
			if(lastColumnNumber == -1) {
				 lastColumnNumber = 0;
			 }
			for(int i=lastColumnNumber;
			 i<(minColumns);
			 i++) {
				output.print(',');
			}
		}
		lastColumnNumber = -1;
		output.println();
	}
}",0,0,1,0
"public class SftpFileSystemInitializationContext {
	 private final String id;
	 private final URI uri;
	 private final Map<String, ?> environment;
	 private String host;
	 private int port;
	 private BasicCredentialsProvider credentials;
	 private PropertyResolver propertyResolver;
	 private long maxConnectTime;
	 private long maxAuthTime;
	 public SftpFileSystemInitializationContext(String id, URI uri, Map<String, ?> env) {
		 this.id = id;
		 this.uri = uri;
		 this.environment = env;
	 }
	 public String getId() {
		 return id;
	 }
	 public URI getUri() {
		 return uri;
	 }
	 public Map<String, ?> getEnvironment() {
		 return environment;
	 }
	 public String getHost() {
		 return host;
	 }
	 public void setHost(String host) {
		 this.host = host;
	 }
	 public int getPort() {
		 return port;
	 }
	 public void setPort(int port) {
		 this.port = port;
	 }
	 public BasicCredentialsProvider getCredentials() {
		 return credentials;
	 }
	 public void setCredentials(BasicCredentialsProvider credentials) {
		 this.credentials = credentials;
	 }
	 public PropertyResolver getPropertyResolver() {
		 return propertyResolver;
	 }
	 public void setPropertyResolver(PropertyResolver propertyResolver) {
		 this.propertyResolver = propertyResolver;
	 }
	 public long getMaxConnectTime() {
		 return maxConnectTime;
	 }
	 public void setMaxConnectTime(long maxConnectTime) {
		 this.maxConnectTime = maxConnectTime;
	 }
	 public long getMaxAuthTime() {
		 return maxAuthTime;
	 }
	 public void setMaxAuthTime(long maxAuthTime) {
		 this.maxAuthTime = maxAuthTime;
	 }
	 public String toString() {
		 return getClass().getSimpleName() + ""["" + getId() + ""]"";
	 }
}",1,1,0,0
"public class CayenneGeneratorMojo extends AbstractMojo {
	 public static final File[] NO_FILES = new File[0];
	private File additionalMaps;
	private Boolean client;
	private File defaultDir;
	private File destDir;
	private String encoding;
	private String excludeEntities;
	private String includeEntities;
	private String excludeEmbeddables;
	private Boolean makePairs;
	private File map;
	private String mode;
	private String outputPattern;
	private Boolean overwrite;
	private String superPkg;
	private String superTemplate;
	private String template;
	private String embeddableSuperTemplate;
	private String embeddableTemplate;
	private Boolean usePkgPath;
	 private Boolean createPropertyNames;
	private boolean force;
	private String queryTemplate;
	private String querySuperTemplate;
	 private Boolean createPKProperties;
	 private transient Injector injector;
	 private static final Logger logger = LoggerFactory.getLogger(CayenneGeneratorMojo.class);
	 private boolean useConfigFromDataMap;
	public void execute() throws MojoExecutionException, MojoFailureException {
		injector = new ToolsInjectorBuilder().addModule(new ToolsModule(LoggerFactory.getLogger(CayenneGeneratorMojo.class))).create();
		Logger logger = new MavenLogger(this);
		CayenneGeneratorMapLoaderAction loaderAction = new CayenneGeneratorMapLoaderAction(injector);
		loaderAction.setMainDataMapFile(map);
		try {
			loaderAction.setAdditionalDataMapFiles(convertAdditionalDataMaps());
			DataMap dataMap = loaderAction.getMainDataMap();
			ClassGenerationAction generator = createGenerator(dataMap);
			CayenneGeneratorEntityFilterAction filterEntityAction = new CayenneGeneratorEntityFilterAction();
			filterEntityAction.setNameFilter(NamePatternMatcher.build(logger, includeEntities, excludeEntities));
			CayenneGeneratorEmbeddableFilterAction filterEmbeddableAction = new CayenneGeneratorEmbeddableFilterAction();
			filterEmbeddableAction.setNameFilter(NamePatternMatcher.build(logger, null, excludeEmbeddables));
			filterEntityAction.setClient(generator.getCgenConfiguration().isClient());
			generator.setLogger(logger);
			if(force) {
				generator.getCgenConfiguration().setForce(true);
			}
			generator.getCgenConfiguration().setTimestamp(map.lastModified());
			if(!hasConfig() && useConfigFromDataMap) {
				generator.prepareArtifacts();
			}
			 else {
				generator.addEntities(filterEntityAction.getFilteredEntities(dataMap));
				generator.addEmbeddables(filterEmbeddableAction.getFilteredEmbeddables(dataMap));
				generator.addQueries(dataMap.getQueryDescriptors());
			}
			generator.execute();
		}
		 catch (Exception e) {
			throw new MojoExecutionException(""Error generating classes: "", e);
		}
	}
	protected File[] convertAdditionalDataMaps() throws Exception {
		if (additionalMaps == null) {
			return NO_FILES;
		}
		if (!additionalMaps.isDirectory()) {
			throw new MojoFailureException(""'additionalMaps' must be a directory."");
		}
		 return additionalMaps.listFiles( (dir, name) -> name != null && name.toLowerCase().endsWith("".map.xml""));
	}
	private boolean hasConfig() {
		return destDir != null || encoding != null || client != null || excludeEntities != null || excludeEmbeddables != null || includeEntities != null ||makePairs != null || mode != null || outputPattern != null || overwrite != null || superPkg != null ||superTemplate != null || template != null || embeddableTemplate != null || embeddableSuperTemplate != null ||usePkgPath != null || createPropertyNames != null || force || queryTemplate != null ||querySuperTemplate != null || createPKProperties != null;
	}
	private ClassGenerationAction createGenerator(DataMap dataMap) {
		CgenConfiguration cgenConfiguration = buildConfiguration(dataMap);
		return injector.getInstance(ClassGenerationActionFactory.class).createAction(cgenConfiguration);
	}
	private CgenConfiguration buildConfiguration(DataMap dataMap) {
		CgenConfiguration cgenConfiguration = injector.getInstance(DataChannelMetaData.class).get(dataMap, CgenConfiguration.class);
		if(hasConfig()) {
			logger.info(""Using cgen config from pom.xml"");
			return cgenConfigFromPom(dataMap);
		}
		 else if(cgenConfiguration != null) {
			logger.info(""Using cgen config from "" + cgenConfiguration.getDataMap().getName());
			useConfigFromDataMap = true;
			return cgenConfiguration;
		}
		 else {
			logger.info(""Using default cgen config."");
			cgenConfiguration = new CgenConfiguration();
			cgenConfiguration.setDataMap(dataMap);
			cgenConfiguration.setRelPath(defaultDir.getPath());
			return cgenConfiguration;
		}
	}
	private CgenConfiguration cgenConfigFromPom(DataMap dataMap){
		CgenConfiguration cgenConfiguration = new CgenConfiguration();
		cgenConfiguration.setDataMap(dataMap);
		cgenConfiguration.setRelPath(destDir != null ? destDir.getPath() : defaultDir.getPath());
		cgenConfiguration.setEncoding(encoding != null ? encoding : cgenConfiguration.getEncoding());
		cgenConfiguration.setMakePairs(makePairs != null ? makePairs : cgenConfiguration.isMakePairs());
		if(mode != null && mode.equals(""datamap"")) {
			replaceDatamapGenerationMode();
		}
		cgenConfiguration.setArtifactsGenerationMode(mode != null ? mode : cgenConfiguration.getArtifactsGenerationMode());
		cgenConfiguration.setOutputPattern(outputPattern != null ? outputPattern : cgenConfiguration.getOutputPattern());
		cgenConfiguration.setOverwrite(overwrite != null ? overwrite : cgenConfiguration.isOverwrite());
		cgenConfiguration.setSuperPkg(superPkg != null ? superPkg : cgenConfiguration.getSuperPkg());
		cgenConfiguration.setSuperTemplate(superTemplate != null ? superTemplate : cgenConfiguration.getSuperTemplate());
		cgenConfiguration.setTemplate(template != null ? template : cgenConfiguration.getTemplate());
		cgenConfiguration.setEmbeddableSuperTemplate(embeddableSuperTemplate != null ? embeddableSuperTemplate : cgenConfiguration.getEmbeddableSuperTemplate());
		cgenConfiguration.setEmbeddableTemplate(embeddableTemplate != null ? embeddableTemplate : cgenConfiguration.getEmbeddableTemplate());
		cgenConfiguration.setUsePkgPath(usePkgPath != null ? usePkgPath : cgenConfiguration.isUsePkgPath());
		cgenConfiguration.setCreatePropertyNames(createPropertyNames != null ? createPropertyNames : cgenConfiguration.isCreatePropertyNames());
		cgenConfiguration.setQueryTemplate(queryTemplate != null ? queryTemplate : cgenConfiguration.getQueryTemplate());
		cgenConfiguration.setQuerySuperTemplate(querySuperTemplate != null ? querySuperTemplate : cgenConfiguration.getQuerySuperTemplate());
		cgenConfiguration.setCreatePKProperties(createPKProperties != null ? createPKProperties : cgenConfiguration.isCreatePKProperties());
		cgenConfiguration.setClient(client != null ? client : cgenConfiguration.isClient());
		if(!cgenConfiguration.isMakePairs()) {
			if(template == null) {
				cgenConfiguration.setTemplate(cgenConfiguration.isClient() ? ClientClassGenerationAction.SINGLE_CLASS_TEMPLATE : ClassGenerationAction.SINGLE_CLASS_TEMPLATE);
			}
			if(embeddableTemplate == null) {
				cgenConfiguration.setEmbeddableTemplate(ClassGenerationAction.EMBEDDABLE_SINGLE_CLASS_TEMPLATE);
			}
			if(queryTemplate == null) {
				cgenConfiguration.setQueryTemplate(cgenConfiguration.isClient() ? ClientClassGenerationAction.DATAMAP_SINGLE_CLASS_TEMPLATE : ClassGenerationAction.DATAMAP_SINGLE_CLASS_TEMPLATE);
			}
		}
		return cgenConfiguration;
	}
	private void replaceDatamapGenerationMode() {
		this.mode = ArtifactsGenerationMode.ALL.getLabel();
		this.excludeEntities = ""*"";
		this.excludeEmbeddables = ""*"";
		this.includeEntities = """";
	}
}",1,0,0,0
"public class TemporaryResultSetFactory {
	 public ResultSet getSortedResultSet(SortKeyExtractor extractor, boolean reverse) {
		 return new SortedResultSetImpl(extractor, reverse);
	 }
	 public ResultBag getSortedResultBag(SortKeyExtractor extractor, boolean reverse) {
		 return new SortedResultBagImpl(extractor, reverse);
	 }
	 public ResultSet getUnsortedResultSet(boolean reverse) {
		 return new SortedResultSetImpl(null, reverse);
	 }
	 public ResultList getResultList() {
		 return new ResultListImpl();
	 }
}",0,0,0,0
"public class Customer230 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer230() {
	}
	public Customer230(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer230[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"public class Codegen extends Interpreter{
	 public Object compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, String encodedSource, boolean returnFunction) {
		 int serial;
		 synchronized (globalLock) {
			 serial = ++globalSerialClassCounter;
		 }
		 String mainClassName = ""org.mozilla.javascript.gen.c""+serial;
		 byte[] mainClassBytes = compileToClassFile(compilerEnv, mainClassName, tree, encodedSource, returnFunction);
		 return new Object[] {
		 mainClassName, mainClassBytes }
		;
	 }
	 public Script createScriptObject(Object bytecode, Object staticSecurityDomain) {
		 Class cl = defineClass(bytecode, staticSecurityDomain);
		 Script script;
		 try {
			 script = (Script)cl.newInstance();
		 }
		 catch (Exception ex) {
			 throw new RuntimeException (""Unable to instantiate compiled class:""+ex.toString());
		 }
		 return script;
	 }
	 public Function createFunctionObject(Context cx, Scriptable scope, Object bytecode, Object staticSecurityDomain) {
		 Class cl = defineClass(bytecode, staticSecurityDomain);
		 NativeFunction f;
		 try {
			 Constructor ctor = cl.getConstructors()[0];
			 Object[] initArgs = {
			 scope, cx, new Integer(0) }
			;
			 f = (NativeFunction)ctor.newInstance(initArgs);
		 }
		 catch (Exception ex) {
			 throw new RuntimeException (""Unable to instantiate compiled class:""+ex.toString());
		 }
		 return f;
	 }
	 private Class defineClass(Object bytecode, Object staticSecurityDomain) {
		 Object[] nameBytesPair = (Object[])bytecode;
		 String className = (String)nameBytesPair[0];
		 byte[] classBytes = (byte[])nameBytesPair[1];
		 ClassLoader rhinoLoader = getClass().getClassLoader();
		 GeneratedClassLoader loader;
		 loader = SecurityController.createLoader(rhinoLoader, staticSecurityDomain);
		 Exception e;
		 try {
			 Class cl = loader.defineClass(className, classBytes);
			 loader.linkClass(cl);
			 return cl;
		 }
		 catch (SecurityException x) {
			 e = x;
		 }
		 catch (IllegalArgumentException x) {
			 e = x;
		 }
		 throw new RuntimeException(""Malformed optimizer package "" + e);
	 }
	 byte[] compileToClassFile(CompilerEnvirons compilerEnv, String mainClassName, ScriptOrFnNode scriptOrFn, String encodedSource, boolean returnFunction) {
		 this.compilerEnv = compilerEnv;
		 transform(scriptOrFn);
		 if (Token.printTrees) {
			 System.out.println(scriptOrFn.toStringTree(scriptOrFn));
		 }
		 if (returnFunction) {
			 scriptOrFn = scriptOrFn.getFunctionNode(0);
		 }
		 initScriptOrFnNodesData(scriptOrFn);
		 this.mainClassName = mainClassName;
		 mainClassSignature = ClassFileWriter.classNameToSignature(mainClassName);
		 return generateCode(encodedSource);
	 }
	 private void transform(ScriptOrFnNode tree) {
		 initOptFunctions_r(tree);
		 int optLevel = compilerEnv.getOptimizationLevel();
		 Hashtable possibleDirectCalls = null;
		 if (optLevel > 0) {
			 if (tree.getType() == Token.SCRIPT) {
				 int functionCount = tree.getFunctionCount();
				 for (int i = 0;
				 i != functionCount;
				 ++i) {
					 OptFunctionNode ofn = OptFunctionNode.get(tree, i);
					 if (ofn.fnode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {
						 String name = ofn.fnode.getFunctionName();
						 if (name.length() != 0) {
							 if (possibleDirectCalls == null) {
								 possibleDirectCalls = new Hashtable();
							 }
							 possibleDirectCalls.put(name, ofn);
						 }
					 }
				 }
			 }
		 }
		 if (possibleDirectCalls != null) {
			 directCallTargets = new ObjArray();
		 }
		 OptTransformer ot = new OptTransformer(possibleDirectCalls, directCallTargets);
		 ot.transform(tree);
		 if (optLevel > 0) {
			 (new Optimizer()).optimize(tree);
		 }
	 }
	 private static void initOptFunctions_r(ScriptOrFnNode scriptOrFn) {
		 for (int i = 0, N = scriptOrFn.getFunctionCount();
		 i != N;
		 ++i) {
			 FunctionNode fn = scriptOrFn.getFunctionNode(i);
			 new OptFunctionNode(fn);
			 initOptFunctions_r(fn);
		 }
	 }
	 private void initScriptOrFnNodesData(ScriptOrFnNode scriptOrFn) {
		 ObjArray x = new ObjArray();
		 collectScriptOrFnNodes_r(scriptOrFn, x);
		 int count = x.size();
		 scriptOrFnNodes = new ScriptOrFnNode[count];
		 x.toArray(scriptOrFnNodes);
		 scriptOrFnIndexes = new ObjToIntMap(count);
		 for (int i = 0;
		 i != count;
		 ++i) {
			 scriptOrFnIndexes.put(scriptOrFnNodes[i], i);
		 }
	 }
	 private static void collectScriptOrFnNodes_r(ScriptOrFnNode n, ObjArray x) {
		 x.add(n);
		 int nestedCount = n.getFunctionCount();
		 for (int i = 0;
		 i != nestedCount;
		 ++i) {
			 collectScriptOrFnNodes_r(n.getFunctionNode(i), x);
		 }
	 }
	 private byte[] generateCode(String encodedSource) {
		 boolean hasScript = (scriptOrFnNodes[0].getType() == Token.SCRIPT);
		 boolean hasFunctions = (scriptOrFnNodes.length > 1 || !hasScript);
		 String sourceFile = null;
		 if (compilerEnv.isGenerateDebugInfo()) {
			 sourceFile = scriptOrFnNodes[0].getSourceName();
		 }
		 ClassFileWriter cfw = new ClassFileWriter(mainClassName, SUPER_CLASS_NAME, sourceFile);
		 cfw.addField(ID_FIELD_NAME, ""I"", ClassFileWriter.ACC_PRIVATE);
		 cfw.addField(DIRECT_CALL_PARENT_FIELD, mainClassSignature, ClassFileWriter.ACC_PRIVATE);
		 cfw.addField(REGEXP_ARRAY_FIELD_NAME, REGEXP_ARRAY_FIELD_TYPE, ClassFileWriter.ACC_PRIVATE);
		 if (hasFunctions) {
			 generateFunctionConstructor(cfw);
		 }
		 if (hasScript) {
			 cfw.addInterface(""org/mozilla/javascript/Script"");
			 generateScriptCtor(cfw);
			 generateMain(cfw);
			 generateExecute(cfw);
		 }
		 generateCallMethod(cfw);
		 generateNativeFunctionOverrides(cfw, encodedSource);
		 int count = scriptOrFnNodes.length;
		 for (int i = 0;
		 i != count;
		 ++i) {
			 ScriptOrFnNode n = scriptOrFnNodes[i];
			 BodyCodegen bodygen = new BodyCodegen();
			 bodygen.cfw = cfw;
			 bodygen.codegen = this;
			 bodygen.compilerEnv = compilerEnv;
			 bodygen.scriptOrFn = n;
			 bodygen.generateBodyCode();
			 if (n.getType() == Token.FUNCTION) {
				 OptFunctionNode ofn = OptFunctionNode.get(n);
				 generateFunctionInit(cfw, ofn);
				 if (ofn.isTargetOfDirectCall()) {
					 emitDirectConstructor(cfw, ofn);
				 }
			 }
		 }
		 if (directCallTargets != null) {
			 int N = directCallTargets.size();
			 for (int j = 0;
			 j != N;
			 ++j) {
				 cfw.addField(getDirectTargetFieldName(j), mainClassSignature, ClassFileWriter.ACC_PRIVATE);
			 }
		 }
		 emitRegExpInit(cfw);
		 emitConstantDudeInitializers(cfw);
		 return cfw.toByteArray();
	 }
	 private void emitDirectConstructor(ClassFileWriter cfw, OptFunctionNode ofn) {
		 cfw.startMethod(getDirectCtorName(ofn.fnode), getBodyMethodSignature(ofn.fnode), (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE));
		 int argCount = ofn.fnode.getParamCount();
		 int firstLocal = (4 + argCount * 3) + 1;
		 cfw.addALoad(0);
		 cfw.addALoad(1);
		 cfw.addALoad(2);
		 cfw.addInvoke(ByteCode.INVOKEVIRTUAL, ""org/mozilla/javascript/BaseFunction"", ""createObject"", ""(Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.addAStore(firstLocal);
		 cfw.addALoad(0);
		 cfw.addALoad(1);
		 cfw.addALoad(2);
		 cfw.addALoad(firstLocal);
		 for (int i = 0;
		 i < argCount;
		 i++) {
			 cfw.addALoad(4 + (i * 3));
			 cfw.addDLoad(5 + (i * 3));
		 }
		 cfw.addALoad(4 + argCount * 3);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, mainClassName, getBodyMethodName(ofn.fnode), getBodyMethodSignature(ofn.fnode));
		 int exitLabel = cfw.acquireLabel();
		 cfw.add(ByteCode.DUP);
		 cfw.add(ByteCode.INSTANCEOF, ""org/mozilla/javascript/Scriptable"");
		 cfw.add(ByteCode.IFEQ, exitLabel);
		 cfw.add(ByteCode.CHECKCAST, ""org/mozilla/javascript/Scriptable"");
		 cfw.add(ByteCode.ARETURN);
		 cfw.markLabel(exitLabel);
		 cfw.addALoad(firstLocal);
		 cfw.add(ByteCode.ARETURN);
		 cfw.stopMethod((short)(firstLocal + 1));
	 }
	 private void generateCallMethod(ClassFileWriter cfw) {
		 cfw.startMethod(""call"", ""(Lorg/mozilla/javascript/Context;
		"" + ""Lorg/mozilla/javascript/Scriptable;
		"" + ""Lorg/mozilla/javascript/Scriptable;
		"" + ""[Ljava/lang/Object;
		)Ljava/lang/Object;
		"", (short)(ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_FINAL));
		 int nonTopCallLabel = cfw.acquireLabel();
		 cfw.addALoad(1);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""hasTopCall"", ""(Lorg/mozilla/javascript/Context;
		"" +"")Z"");
		 cfw.add(ByteCode.IFNE, nonTopCallLabel);
		 cfw.addALoad(0);
		 cfw.addALoad(1);
		 cfw.addALoad(2);
		 cfw.addALoad(3);
		 cfw.addALoad(4);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""doTopCall"", ""(Lorg/mozilla/javascript/Callable;
		"" +""Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""[Ljava/lang/Object;
		"" +"")Ljava/lang/Object;
		"");
		 cfw.add(ByteCode.ARETURN);
		 cfw.markLabel(nonTopCallLabel);
		 cfw.addALoad(0);
		 cfw.addALoad(1);
		 cfw.addALoad(2);
		 cfw.addALoad(3);
		 cfw.addALoad(4);
		 int end = scriptOrFnNodes.length;
		 boolean generateSwitch = (2 <= end);
		 int switchStart = 0;
		 int switchStackTop = 0;
		 if (generateSwitch) {
			 cfw.addLoadThis();
			 cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, ""I"");
			 switchStart = cfw.addTableSwitch(1, end - 1);
		 }
		 for (int i = 0;
		 i != end;
		 ++i) {
			 ScriptOrFnNode n = scriptOrFnNodes[i];
			 if (generateSwitch) {
				 if (i == 0) {
					 cfw.markTableSwitchDefault(switchStart);
					 switchStackTop = cfw.getStackTop();
				 }
				 else {
					 cfw.markTableSwitchCase(switchStart, i - 1, switchStackTop);
				 }
			 }
			 if (n.getType() == Token.FUNCTION) {
				 OptFunctionNode ofn = OptFunctionNode.get(n);
				 if (ofn.isTargetOfDirectCall()) {
					 int pcount = ofn.fnode.getParamCount();
					 if (pcount != 0) {
						 for (int p = 0;
						 p != pcount;
						 ++p) {
							 cfw.add(ByteCode.ARRAYLENGTH);
							 cfw.addPush(p);
							 int undefArg = cfw.acquireLabel();
							 int beyond = cfw.acquireLabel();
							 cfw.add(ByteCode.IF_ICMPLE, undefArg);
							 cfw.addALoad(4);
							 cfw.addPush(p);
							 cfw.add(ByteCode.AALOAD);
							 cfw.add(ByteCode.GOTO, beyond);
							 cfw.markLabel(undefArg);
							 pushUndefined(cfw);
							 cfw.markLabel(beyond);
							 cfw.adjustStackTop(-1);
							 cfw.addPush(0.0);
							 cfw.addALoad(4);
						 }
					 }
				 }
			 }
			 cfw.addInvoke(ByteCode.INVOKESTATIC, mainClassName, getBodyMethodName(n), getBodyMethodSignature(n));
			 cfw.add(ByteCode.ARETURN);
		 }
		 cfw.stopMethod((short)5);
	 }
	 private void generateMain(ClassFileWriter cfw) {
		 cfw.startMethod(""main"", ""([Ljava/lang/String;
		)V"", (short)(ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_STATIC));
		 cfw.add(ByteCode.NEW, cfw.getClassName());
		 cfw.add(ByteCode.DUP);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, cfw.getClassName(), ""<init>"", ""()V"");
		 cfw.add(ByteCode.ALOAD_0);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, mainMethodClass, ""main"", ""(Lorg/mozilla/javascript/Script;
		[Ljava/lang/String;
		)V"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)1);
	 }
	 private void generateExecute(ClassFileWriter cfw) {
		 cfw.startMethod(""exec"", ""(Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")Ljava/lang/Object;
		"", (short)(ClassFileWriter.ACC_PUBLIC | ClassFileWriter.ACC_FINAL));
		 final int CONTEXT_ARG = 1;
		 final int SCOPE_ARG = 2;
		 cfw.addLoadThis();
		 cfw.addALoad(CONTEXT_ARG);
		 cfw.addALoad(SCOPE_ARG);
		 cfw.add(ByteCode.DUP);
		 cfw.add(ByteCode.ACONST_NULL);
		 cfw.addInvoke(ByteCode.INVOKEVIRTUAL, cfw.getClassName(), ""call"", ""(Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""[Ljava/lang/Object;
		"" +"")Ljava/lang/Object;
		"");
		 cfw.add(ByteCode.ARETURN);
		 cfw.stopMethod((short)3);
	 }
	 private void generateScriptCtor(ClassFileWriter cfw) {
		 cfw.startMethod(""<init>"", ""()V"", ClassFileWriter.ACC_PUBLIC);
		 cfw.addLoadThis();
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, SUPER_CLASS_NAME, ""<init>"", ""()V"");
		 cfw.addLoadThis();
		 cfw.addPush(0);
		 cfw.add(ByteCode.PUTFIELD, cfw.getClassName(), ID_FIELD_NAME, ""I"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)1);
	 }
	 private void generateFunctionConstructor(ClassFileWriter cfw) {
		 final int SCOPE_ARG = 1;
		 final int CONTEXT_ARG = 2;
		 final int ID_ARG = 3;
		 cfw.startMethod(""<init>"", FUNCTION_CONSTRUCTOR_SIGNATURE, ClassFileWriter.ACC_PUBLIC);
		 cfw.addALoad(0);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, SUPER_CLASS_NAME, ""<init>"", ""()V"");
		 cfw.addLoadThis();
		 cfw.addILoad(ID_ARG);
		 cfw.add(ByteCode.PUTFIELD, cfw.getClassName(), ID_FIELD_NAME, ""I"");
		 cfw.addLoadThis();
		 cfw.addALoad(CONTEXT_ARG);
		 cfw.addALoad(SCOPE_ARG);
		 int start = (scriptOrFnNodes[0].getType() == Token.SCRIPT) ? 1 : 0;
		 int end = scriptOrFnNodes.length;
		 if (start == end) throw badTree();
		 boolean generateSwitch = (2 <= end - start);
		 int switchStart = 0;
		 int switchStackTop = 0;
		 if (generateSwitch) {
			 cfw.addILoad(ID_ARG);
			 switchStart = cfw.addTableSwitch(start + 1, end - 1);
		 }
		 for (int i = start;
		 i != end;
		 ++i) {
			 if (generateSwitch) {
				 if (i == start) {
					 cfw.markTableSwitchDefault(switchStart);
					 switchStackTop = cfw.getStackTop();
				 }
				 else {
					 cfw.markTableSwitchCase(switchStart, i - 1 - start, switchStackTop);
				 }
			 }
			 OptFunctionNode ofn = OptFunctionNode.get(scriptOrFnNodes[i]);
			 cfw.addInvoke(ByteCode.INVOKEVIRTUAL, mainClassName, getFunctionInitMethodName(ofn), FUNCTION_INIT_SIGNATURE);
			 cfw.add(ByteCode.RETURN);
		 }
		 cfw.stopMethod((short)4);
	 }
	 private void generateFunctionInit(ClassFileWriter cfw, OptFunctionNode ofn) {
		 final int CONTEXT_ARG = 1;
		 final int SCOPE_ARG = 2;
		 cfw.startMethod(getFunctionInitMethodName(ofn), FUNCTION_INIT_SIGNATURE, (short)(ClassFileWriter.ACC_PRIVATE | ClassFileWriter.ACC_FINAL));
		 cfw.addLoadThis();
		 cfw.addALoad(CONTEXT_ARG);
		 cfw.addALoad(SCOPE_ARG);
		 cfw.addInvoke(ByteCode.INVOKEVIRTUAL, ""org/mozilla/javascript/NativeFunction"", ""initScriptFunction"", ""(Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")V"");
		 int regexpCount = ofn.fnode.getRegexpCount();
		 if (regexpCount != 0) {
			 cfw.addLoadThis();
			 pushRegExpArray(cfw, ofn.fnode, CONTEXT_ARG, SCOPE_ARG);
			 cfw.add(ByteCode.PUTFIELD, mainClassName, REGEXP_ARRAY_FIELD_NAME, REGEXP_ARRAY_FIELD_TYPE);
		 }
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)3);
	 }
	 private void generateNativeFunctionOverrides(ClassFileWriter cfw, String encodedSource) {
		 cfw.startMethod(""getLanguageVersion"", ""()I"", ClassFileWriter.ACC_PUBLIC);
		 cfw.addPush(compilerEnv.getLanguageVersion());
		 cfw.add(ByteCode.IRETURN);
		 cfw.stopMethod((short)1);
		 final int Do_getFunctionName = 0;
		 final int Do_getParamCount = 1;
		 final int Do_getParamAndVarCount = 2;
		 final int Do_getParamOrVarName = 3;
		 final int Do_getEncodedSource = 4;
		 final int Do_getParamOrVarConst = 5;
		 final int SWITCH_COUNT = 6;
		 for (int methodIndex = 0;
		 methodIndex != SWITCH_COUNT;
		 ++methodIndex) {
			 if (methodIndex == Do_getEncodedSource && encodedSource == null) {
				 continue;
			 }
			 short metodLocals;
			 switch (methodIndex) {
				 case Do_getFunctionName: metodLocals = 1;
				 cfw.startMethod(""getFunctionName"", ""()Ljava/lang/String;
				"", ClassFileWriter.ACC_PUBLIC);
				 break;
				 case Do_getParamCount: metodLocals = 1;
				 cfw.startMethod(""getParamCount"", ""()I"", ClassFileWriter.ACC_PUBLIC);
				 break;
				 case Do_getParamAndVarCount: metodLocals = 1;
				 cfw.startMethod(""getParamAndVarCount"", ""()I"", ClassFileWriter.ACC_PUBLIC);
				 break;
				 case Do_getParamOrVarName: metodLocals = 1 + 1;
				 cfw.startMethod(""getParamOrVarName"", ""(I)Ljava/lang/String;
				"", ClassFileWriter.ACC_PUBLIC);
				 break;
				 case Do_getParamOrVarConst: metodLocals = 1 + 1 + 1;
				 cfw.startMethod(""getParamOrVarConst"", ""(I)Z"", ClassFileWriter.ACC_PUBLIC);
				 break;
				 case Do_getEncodedSource: metodLocals = 1;
				 cfw.startMethod(""getEncodedSource"", ""()Ljava/lang/String;
				"", ClassFileWriter.ACC_PUBLIC);
				 cfw.addPush(encodedSource);
				 break;
				 default: throw Kit.codeBug();
			 }
			 int count = scriptOrFnNodes.length;
			 int switchStart = 0;
			 int switchStackTop = 0;
			 if (count > 1) {
				 cfw.addLoadThis();
				 cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, ""I"");
				 switchStart = cfw.addTableSwitch(1, count - 1);
			 }
			 for (int i = 0;
			 i != count;
			 ++i) {
				 ScriptOrFnNode n = scriptOrFnNodes[i];
				 if (i == 0) {
					 if (count > 1) {
						 cfw.markTableSwitchDefault(switchStart);
						 switchStackTop = cfw.getStackTop();
					 }
				 }
				 else {
					 cfw.markTableSwitchCase(switchStart, i - 1, switchStackTop);
				 }
				 switch (methodIndex) {
					 case Do_getFunctionName: if (n.getType() == Token.SCRIPT) {
						 cfw.addPush("""");
					 }
					 else {
						 String name = ((FunctionNode)n).getFunctionName();
						 cfw.addPush(name);
					 }
					 cfw.add(ByteCode.ARETURN);
					 break;
					 case Do_getParamCount: cfw.addPush(n.getParamCount());
					 cfw.add(ByteCode.IRETURN);
					 break;
					 case Do_getParamAndVarCount: cfw.addPush(n.getParamAndVarCount());
					 cfw.add(ByteCode.IRETURN);
					 break;
					 case Do_getParamOrVarName: int paramAndVarCount = n.getParamAndVarCount();
					 if (paramAndVarCount == 0) {
						 cfw.add(ByteCode.ACONST_NULL);
						 cfw.add(ByteCode.ARETURN);
					 }
					 else if (paramAndVarCount == 1) {
						 cfw.addPush(n.getParamOrVarName(0));
						 cfw.add(ByteCode.ARETURN);
					 }
					 else {
						 cfw.addILoad(1);
						 int paramSwitchStart = cfw.addTableSwitch( 1, paramAndVarCount - 1);
						 for (int j = 0;
						 j != paramAndVarCount;
						 ++j) {
							 if (cfw.getStackTop() != 0) Kit.codeBug();
							 String s = n.getParamOrVarName(j);
							 if (j == 0) {
								 cfw.markTableSwitchDefault(paramSwitchStart);
							 }
							 else {
								 cfw.markTableSwitchCase(paramSwitchStart, j - 1, 0);
							 }
							 cfw.addPush(s);
							 cfw.add(ByteCode.ARETURN);
						 }
					 }
					 break;
					 case Do_getParamOrVarConst: paramAndVarCount = n.getParamAndVarCount();
					 boolean [] constness = n.getParamAndVarConst();
					 if (paramAndVarCount == 0) {
						 cfw.add(ByteCode.ICONST_0);
						 cfw.add(ByteCode.IRETURN);
					 }
					 else if (paramAndVarCount == 1) {
						 cfw.addPush(constness[0]);
						 cfw.add(ByteCode.IRETURN);
					 }
					 else {
						 cfw.addILoad(1);
						 int paramSwitchStart = cfw.addTableSwitch( 1, paramAndVarCount - 1);
						 for (int j = 0;
						 j != paramAndVarCount;
						 ++j) {
							 if (cfw.getStackTop() != 0) Kit.codeBug();
							 if (j == 0) {
								 cfw.markTableSwitchDefault(paramSwitchStart);
							 }
							 else {
								 cfw.markTableSwitchCase(paramSwitchStart, j - 1, 0);
							 }
							 cfw.addPush(constness[j]);
							 cfw.add(ByteCode.IRETURN);
						 }
					 }
					 break;
					 case Do_getEncodedSource: cfw.addPush(n.getEncodedSourceStart());
					 cfw.addPush(n.getEncodedSourceEnd());
					 cfw.addInvoke(ByteCode.INVOKEVIRTUAL, ""java/lang/String"", ""substring"", ""(II)Ljava/lang/String;
					"");
					 cfw.add(ByteCode.ARETURN);
					 break;
					 default: throw Kit.codeBug();
				 }
			 }
			 cfw.stopMethod(metodLocals);
		 }
	 }
	 private void emitRegExpInit(ClassFileWriter cfw) {
		 int totalRegCount = 0;
		 for (int i = 0;
		 i != scriptOrFnNodes.length;
		 ++i) {
			 totalRegCount += scriptOrFnNodes[i].getRegexpCount();
		 }
		 if (totalRegCount == 0) {
			 return;
		 }
		 cfw.startMethod(REGEXP_INIT_METHOD_NAME, REGEXP_INIT_METHOD_SIGNATURE, (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE | ClassFileWriter.ACC_SYNCHRONIZED));
		 cfw.addField(""_reInitDone"", ""Z"", (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE));
		 cfw.add(ByteCode.GETSTATIC, mainClassName, ""_reInitDone"", ""Z"");
		 int doInit = cfw.acquireLabel();
		 cfw.add(ByteCode.IFEQ, doInit);
		 cfw.add(ByteCode.RETURN);
		 cfw.markLabel(doInit);
		 for (int i = 0;
		 i != scriptOrFnNodes.length;
		 ++i) {
			 ScriptOrFnNode n = scriptOrFnNodes[i];
			 int regCount = n.getRegexpCount();
			 for (int j = 0;
			 j != regCount;
			 ++j) {
				 String reFieldName = getCompiledRegexpName(n, j);
				 String reFieldType = ""Ljava/lang/Object;
				"";
				 String reString = n.getRegexpString(j);
				 String reFlags = n.getRegexpFlags(j);
				 cfw.addField(reFieldName, reFieldType, (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE));
				 cfw.addALoad(0);
				 cfw.addALoad(1);
				 cfw.addPush(reString);
				 if (reFlags == null) {
					 cfw.add(ByteCode.ACONST_NULL);
				 }
				 else {
					 cfw.addPush(reFlags);
				 }
				 cfw.addInvoke(ByteCode.INVOKEINTERFACE, ""org/mozilla/javascript/RegExpProxy"", ""compileRegExp"", ""(Lorg/mozilla/javascript/Context;
				"" +""Ljava/lang/String;
				Ljava/lang/String;
				"" +"")Ljava/lang/Object;
				"");
				 cfw.add(ByteCode.PUTSTATIC, mainClassName, reFieldName, reFieldType);
			 }
		 }
		 cfw.addPush(1);
		 cfw.add(ByteCode.PUTSTATIC, mainClassName, ""_reInitDone"", ""Z"");
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)2);
	 }
	 private void emitConstantDudeInitializers(ClassFileWriter cfw) {
		 int N = itsConstantListSize;
		 if (N == 0) return;
		 cfw.startMethod(""<clinit>"", ""()V"", (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_FINAL));
		 double[] array = itsConstantList;
		 for (int i = 0;
		 i != N;
		 ++i) {
			 double num = array[i];
			 String constantName = ""_k"" + i;
			 String constantType = getStaticConstantWrapperType(num);
			 cfw.addField(constantName, constantType, (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE));
			 int inum = (int)num;
			 if (inum == num) {
				 cfw.add(ByteCode.NEW, ""java/lang/Integer"");
				 cfw.add(ByteCode.DUP);
				 cfw.addPush(inum);
				 cfw.addInvoke(ByteCode.INVOKESPECIAL, ""java/lang/Integer"", ""<init>"", ""(I)V"");
			 }
			 else {
				 cfw.addPush(num);
				 addDoubleWrap(cfw);
			 }
			 cfw.add(ByteCode.PUTSTATIC, mainClassName, constantName, constantType);
		 }
		 cfw.add(ByteCode.RETURN);
		 cfw.stopMethod((short)0);
	 }
	 void pushRegExpArray(ClassFileWriter cfw, ScriptOrFnNode n, int contextArg, int scopeArg) {
		 int regexpCount = n.getRegexpCount();
		 if (regexpCount == 0) throw badTree();
		 cfw.addPush(regexpCount);
		 cfw.add(ByteCode.ANEWARRAY, ""java/lang/Object"");
		 cfw.addALoad(contextArg);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""checkRegExpProxy"", ""(Lorg/mozilla/javascript/Context;
		"" +"")Lorg/mozilla/javascript/RegExpProxy;
		"");
		 cfw.add(ByteCode.DUP);
		 cfw.addALoad(contextArg);
		 cfw.addInvoke(ByteCode.INVOKESTATIC, mainClassName, REGEXP_INIT_METHOD_NAME, REGEXP_INIT_METHOD_SIGNATURE);
		 for (int i = 0;
		 i != regexpCount;
		 ++i) {
			 cfw.add(ByteCode.DUP2);
			 cfw.addALoad(contextArg);
			 cfw.addALoad(scopeArg);
			 cfw.add(ByteCode.GETSTATIC, mainClassName, getCompiledRegexpName(n, i), ""Ljava/lang/Object;
			"");
			 cfw.addInvoke(ByteCode.INVOKEINTERFACE, ""org/mozilla/javascript/RegExpProxy"", ""wrapRegExp"", ""(Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""Ljava/lang/Object;
			"" +"")Lorg/mozilla/javascript/Scriptable;
			"");
			 cfw.addPush(i);
			 cfw.add(ByteCode.SWAP);
			 cfw.add(ByteCode.AASTORE);
		 }
		 cfw.add(ByteCode.POP);
	 }
	 void pushNumberAsObject(ClassFileWriter cfw, double num) {
		 if (num == 0.0) {
			 if (1 / num > 0) {
				 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/optimizer/OptRuntime"", ""zeroObj"", ""Ljava/lang/Double;
				"");
			 }
			 else {
				 cfw.addPush(num);
				 addDoubleWrap(cfw);
			 }
		 }
		 else if (num == 1.0) {
			 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/optimizer/OptRuntime"", ""oneObj"", ""Ljava/lang/Double;
			"");
			 return;
		 }
		 else if (num == -1.0) {
			 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/optimizer/OptRuntime"", ""minusOneObj"", ""Ljava/lang/Double;
			"");
		 }
		 else if (num != num) {
			 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""NaNobj"", ""Ljava/lang/Double;
			"");
		 }
		 else if (itsConstantListSize >= 2000) {
			 cfw.addPush(num);
			 addDoubleWrap(cfw);
		 }
		 else {
			 int N = itsConstantListSize;
			 int index = 0;
			 if (N == 0) {
				 itsConstantList = new double[64];
			 }
			 else {
				 double[] array = itsConstantList;
				 while (index != N && array[index] != num) {
					 ++index;
				 }
				 if (N == array.length) {
					 array = new double[N * 2];
					 System.arraycopy(itsConstantList, 0, array, 0, N);
					 itsConstantList = array;
				 }
			 }
			 if (index == N) {
				 itsConstantList[N] = num;
				 itsConstantListSize = N + 1;
			 }
			 String constantName = ""_k"" + index;
			 String constantType = getStaticConstantWrapperType(num);
			 cfw.add(ByteCode.GETSTATIC, mainClassName, constantName, constantType);
		 }
	 }
	 private static void addDoubleWrap(ClassFileWriter cfw) {
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/optimizer/OptRuntime"", ""wrapDouble"", ""(D)Ljava/lang/Double;
		"");
	 }
	 private static String getStaticConstantWrapperType(double num) {
		 int inum = (int)num;
		 if (inum == num) {
			 return ""Ljava/lang/Integer;
			"";
		 }
		 else {
			 return ""Ljava/lang/Double;
			"";
		 }
	 }
	 static void pushUndefined(ClassFileWriter cfw) {
		 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/Undefined"", ""instance"", ""Ljava/lang/Object;
		"");
	 }
	 int getIndex(ScriptOrFnNode n) {
		 return scriptOrFnIndexes.getExisting(n);
	 }
	 static String getDirectTargetFieldName(int i) {
		 return ""_dt"" + i;
	 }
	 String getDirectCtorName(ScriptOrFnNode n) {
		 return ""_n""+getIndex(n);
	 }
	 String getBodyMethodName(ScriptOrFnNode n) {
		 return ""_c""+getIndex(n);
	 }
	 String getBodyMethodSignature(ScriptOrFnNode n) {
		 StringBuffer sb = new StringBuffer();
		 sb.append('(');
		 sb.append(mainClassSignature);
		 sb.append(""Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"");
		 if (n.getType() == Token.FUNCTION) {
			 OptFunctionNode ofn = OptFunctionNode.get(n);
			 if (ofn.isTargetOfDirectCall()) {
				 int pCount = ofn.fnode.getParamCount();
				 for (int i = 0;
				 i != pCount;
				 i++) {
					 sb.append(""Ljava/lang/Object;
					D"");
				 }
			 }
		 }
		 sb.append(""[Ljava/lang/Object;
		)Ljava/lang/Object;
		"");
		 return sb.toString();
	 }
	 String getFunctionInitMethodName(OptFunctionNode ofn) {
		 return ""_i""+getIndex(ofn.fnode);
	 }
	 String getCompiledRegexpName(ScriptOrFnNode n, int regexpIndex) {
		 return ""_re""+getIndex(n)+""_""+regexpIndex;
	 }
	 static RuntimeException badTree() {
		 throw new RuntimeException(""Bad tree in codegen"");
	 }
	 void setMainMethodClass(String className) {
		 mainMethodClass = className;
	 }
	 static final String DEFAULT_MAIN_METHOD_CLASS = ""org.mozilla.javascript.optimizer.OptRuntime"";
	 private static final String SUPER_CLASS_NAME = ""org.mozilla.javascript.NativeFunction"";
	 static final String DIRECT_CALL_PARENT_FIELD = ""_dcp"";
	 private static final String ID_FIELD_NAME = ""_id"";
	 private static final String REGEXP_INIT_METHOD_NAME = ""_reInit"";
	 private static final String REGEXP_INIT_METHOD_SIGNATURE = ""(Lorg/mozilla/javascript/RegExpProxy;
	"" +""Lorg/mozilla/javascript/Context;
	"" +"")V"";
	 static final String REGEXP_ARRAY_FIELD_NAME = ""_re"";
	 static final String REGEXP_ARRAY_FIELD_TYPE = ""[Ljava/lang/Object;
	"";
	 static final String FUNCTION_INIT_SIGNATURE = ""(Lorg/mozilla/javascript/Context;
	"" +""Lorg/mozilla/javascript/Scriptable;
	"" +"")V"";
	 static final String FUNCTION_CONSTRUCTOR_SIGNATURE = ""(Lorg/mozilla/javascript/Scriptable;
	"" +""Lorg/mozilla/javascript/Context;
	I)V"";
	 private static final Object globalLock = new Object();
	 private static int globalSerialClassCounter;
	 private CompilerEnvirons compilerEnv;
	 private ObjArray directCallTargets;
	 ScriptOrFnNode[] scriptOrFnNodes;
	 private ObjToIntMap scriptOrFnIndexes;
	 private String mainMethodClass = DEFAULT_MAIN_METHOD_CLASS;
	 String mainClassName;
	 String mainClassSignature;
	 private double[] itsConstantList;
	 private int itsConstantListSize;
}
class BodyCodegen{
	 void generateBodyCode() {
		 initBodyGeneration();
		 cfw.startMethod(codegen.getBodyMethodName(scriptOrFn), codegen.getBodyMethodSignature(scriptOrFn), (short)(ClassFileWriter.ACC_STATIC | ClassFileWriter.ACC_PRIVATE));
		 generatePrologue();
		 Node treeTop;
		 if (fnCurrent != null) {
			 treeTop = scriptOrFn.getLastChild();
		 }
		 else {
			 treeTop = scriptOrFn;
		 }
		 generateStatement(treeTop);
		 generateEpilogue();
		 cfw.stopMethod((short)(localsMax + 1));
	 }
	 private void initBodyGeneration() {
		 isTopLevel = (scriptOrFn == codegen.scriptOrFnNodes[0]);
		 varRegisters = null;
		 if (scriptOrFn.getType() == Token.FUNCTION) {
			 fnCurrent = OptFunctionNode.get(scriptOrFn);
			 hasVarsInRegs = !fnCurrent.fnode.requiresActivation();
			 if (hasVarsInRegs) {
				 int n = fnCurrent.fnode.getParamAndVarCount();
				 if (n != 0) {
					 varRegisters = new short[n];
				 }
			 }
			 inDirectCallFunction = fnCurrent.isTargetOfDirectCall();
			 if (inDirectCallFunction && !hasVarsInRegs) Codegen.badTree();
		 }
		 else {
			 fnCurrent = null;
			 hasVarsInRegs = false;
			 inDirectCallFunction = false;
		 }
		 locals = new boolean[MAX_LOCALS];
		 funObjLocal = 0;
		 contextLocal = 1;
		 variableObjectLocal = 2;
		 thisObjLocal = 3;
		 localsMax = (short) 4;
		 firstFreeLocal = 4;
		 popvLocal = -1;
		 argsLocal = -1;
		 itsZeroArgArray = -1;
		 itsOneArgArray = -1;
		 scriptRegexpLocal = -1;
		 epilogueLabel = -1;
		 enterAreaStartLabel = -1;
	 }
	 private void generatePrologue() {
		 if (inDirectCallFunction) {
			 int directParameterCount = scriptOrFn.getParamCount();
			 if (firstFreeLocal != 4) Kit.codeBug();
			 for (int i = 0;
			 i != directParameterCount;
			 ++i) {
				 varRegisters[i] = firstFreeLocal;
				 firstFreeLocal += 3;
			 }
			 if (!fnCurrent.getParameterNumberContext()) {
				 itsForcedObjectParameters = true;
				 for (int i = 0;
				 i != directParameterCount;
				 ++i) {
					 short reg = varRegisters[i];
					 cfw.addALoad(reg);
					 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
					"");
					 int isObjectLabel = cfw.acquireLabel();
					 cfw.add(ByteCode.IF_ACMPNE, isObjectLabel);
					 cfw.addDLoad(reg + 1);
					 addDoubleWrap();
					 cfw.addAStore(reg);
					 cfw.markLabel(isObjectLabel);
				 }
			 }
		 }
		 if (fnCurrent != null && !inDirectCallFunction && (!compilerEnv.isUseDynamicScope() || fnCurrent.fnode.getIgnoreDynamicScope())) {
			 cfw.addALoad(funObjLocal);
			 cfw.addInvoke(ByteCode.INVOKEINTERFACE, ""org/mozilla/javascript/Scriptable"", ""getParentScope"", ""()Lorg/mozilla/javascript/Scriptable;
			"");
			 cfw.addAStore(variableObjectLocal);
		 }
		 argsLocal = firstFreeLocal++;
		 localsMax = firstFreeLocal;
		 if (fnCurrent == null) {
			 if (scriptOrFn.getRegexpCount() != 0) {
				 scriptRegexpLocal = getNewWordLocal();
				 codegen.pushRegExpArray(cfw, scriptOrFn, contextLocal, variableObjectLocal);
				 cfw.addAStore(scriptRegexpLocal);
			 }
		 }
		 if (hasVarsInRegs) {
			 int parmCount = scriptOrFn.getParamCount();
			 if (parmCount > 0 && !inDirectCallFunction) {
				 cfw.addALoad(argsLocal);
				 cfw.add(ByteCode.ARRAYLENGTH);
				 cfw.addPush(parmCount);
				 int label = cfw.acquireLabel();
				 cfw.add(ByteCode.IF_ICMPGE, label);
				 cfw.addALoad(argsLocal);
				 cfw.addPush(parmCount);
				 addScriptRuntimeInvoke(""padArguments"", ""([Ljava/lang/Object;
				I"" +"")[Ljava/lang/Object;
				"");
				 cfw.addAStore(argsLocal);
				 cfw.markLabel(label);
			 }
			 int paramCount = fnCurrent.fnode.getParamCount();
			 int varCount = fnCurrent.fnode.getParamAndVarCount();
			 boolean [] constDeclarations = fnCurrent.fnode.getParamAndVarConst();
			 short firstUndefVar = -1;
			 for (int i = 0;
			 i != varCount;
			 ++i) {
				 short reg = -1;
				 if (i < paramCount) {
					 if (!inDirectCallFunction) {
						 reg = getNewWordLocal();
						 cfw.addALoad(argsLocal);
						 cfw.addPush(i);
						 cfw.add(ByteCode.AALOAD);
						 cfw.addAStore(reg);
					 }
				 }
				 else if (fnCurrent.isNumberVar(i)) {
					 reg = getNewWordPairLocal(constDeclarations[i]);
					 cfw.addPush(0.0);
					 cfw.addDStore(reg);
				 }
				 else {
					 reg = getNewWordLocal(constDeclarations[i]);
					 if (firstUndefVar == -1) {
						 Codegen.pushUndefined(cfw);
						 firstUndefVar = reg;
					 }
					 else {
						 cfw.addALoad(firstUndefVar);
					 }
					 cfw.addAStore(reg);
				 }
				 if (reg >= 0) {
					 if (constDeclarations[i]) {
						 cfw.addPush(0);
						 cfw.addIStore(reg + (fnCurrent.isNumberVar(i) ? 2 : 1));
					 }
					 varRegisters[i] = reg;
				 }
				 if (compilerEnv.isGenerateDebugInfo()) {
					 String name = fnCurrent.fnode.getParamOrVarName(i);
					 String type = fnCurrent.isNumberVar(i) ? ""D"" : ""Ljava/lang/Object;
					"";
					 int startPC = cfw.getCurrentCodeOffset();
					 if (reg < 0) {
						 reg = varRegisters[i];
					 }
					 cfw.addVariableDescriptor(name, type, startPC, reg);
				 }
			 }
			 return;
		 }
		 String debugVariableName;
		 if (fnCurrent != null) {
			 debugVariableName = ""activation"";
			 cfw.addALoad(funObjLocal);
			 cfw.addALoad(variableObjectLocal);
			 cfw.addALoad(argsLocal);
			 addScriptRuntimeInvoke(""createFunctionActivation"", ""(Lorg/mozilla/javascript/NativeFunction;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""[Ljava/lang/Object;
			"" +"")Lorg/mozilla/javascript/Scriptable;
			"");
			 cfw.addAStore(variableObjectLocal);
			 cfw.addALoad(contextLocal);
			 cfw.addALoad(variableObjectLocal);
			 addScriptRuntimeInvoke(""enterActivationFunction"", ""(Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +"")V"");
		 }
		 else {
			 debugVariableName = ""global"";
			 cfw.addALoad(funObjLocal);
			 cfw.addALoad(thisObjLocal);
			 cfw.addALoad(contextLocal);
			 cfw.addALoad(variableObjectLocal);
			 cfw.addPush(0);
			 addScriptRuntimeInvoke(""initScript"", ""(Lorg/mozilla/javascript/NativeFunction;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""Z"" +"")V"");
		 }
		 enterAreaStartLabel = cfw.acquireLabel();
		 epilogueLabel = cfw.acquireLabel();
		 cfw.markLabel(enterAreaStartLabel);
		 int functionCount = scriptOrFn.getFunctionCount();
		 for (int i = 0;
		 i != functionCount;
		 i++) {
			 OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, i);
			 if (ofn.fnode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {
				 visitFunction(ofn, FunctionNode.FUNCTION_STATEMENT);
			 }
		 }
		 if (compilerEnv.isGenerateDebugInfo()) {
			 cfw.addVariableDescriptor(debugVariableName, ""Lorg/mozilla/javascript/Scriptable;
			"", cfw.getCurrentCodeOffset(), variableObjectLocal);
		 }
		 if (fnCurrent == null) {
			 popvLocal = getNewWordLocal();
			 Codegen.pushUndefined(cfw);
			 cfw.addAStore(popvLocal);
			 int linenum = scriptOrFn.getEndLineno();
			 if (linenum != -1) cfw.addLineNumberEntry((short)linenum);
		 }
		 else {
			 if (fnCurrent.itsContainsCalls0) {
				 itsZeroArgArray = getNewWordLocal();
				 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""emptyArgs"", ""[Ljava/lang/Object;
				"");
				 cfw.addAStore(itsZeroArgArray);
			 }
			 if (fnCurrent.itsContainsCalls1) {
				 itsOneArgArray = getNewWordLocal();
				 cfw.addPush(1);
				 cfw.add(ByteCode.ANEWARRAY, ""java/lang/Object"");
				 cfw.addAStore(itsOneArgArray);
			 }
		 }
	 }
	 private void generateEpilogue() {
		 if (hasVarsInRegs) {
			 if (epilogueLabel != -1) {
				 cfw.markLabel(epilogueLabel);
			 }
			 cfw.add(ByteCode.ARETURN);
			 return;
		 }
		 cfw.markLabel(epilogueLabel);
		 if (fnCurrent == null) {
			 cfw.addALoad(popvLocal);
			 cfw.add(ByteCode.ARETURN);
		 }
		 else {
			 generateActivationExit();
			 cfw.add(ByteCode.ARETURN);
			 int finallyHandler = cfw.acquireLabel();
			 cfw.markHandler(finallyHandler);
			 short exceptionObject = getNewWordLocal();
			 cfw.addAStore(exceptionObject);
			 generateActivationExit();
			 cfw.addALoad(exceptionObject);
			 releaseWordLocal(exceptionObject);
			 cfw.add(ByteCode.ATHROW);
			 cfw.addExceptionHandler(enterAreaStartLabel, epilogueLabel, finallyHandler, null);
		 }
	 }
	 private void generateActivationExit() {
		 if (fnCurrent == null || hasVarsInRegs) throw Kit.codeBug();
		 cfw.addALoad(contextLocal);
		 addScriptRuntimeInvoke(""exitActivationFunction"", ""(Lorg/mozilla/javascript/Context;
		)V"");
	 }
	 private void generateStatement(Node node) {
		 updateLineNumber(node);
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.LOOP: case Token.LABEL: case Token.WITH: case Token.SCRIPT: case Token.BLOCK: case Token.EMPTY: while (child != null) {
				 generateStatement(child);
				 child = child.getNext();
			 }
			 break;
			 case Token.LOCAL_BLOCK: {
				 int local = getNewWordLocal();
				 node.putIntProp(Node.LOCAL_PROP, local);
				 while (child != null) {
					 generateStatement(child);
					 child = child.getNext();
				 }
				 releaseWordLocal((short)local);
				 node.removeProp(Node.LOCAL_PROP);
				 break;
			 }
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex);
				 int t = ofn.fnode.getFunctionType();
				 if (t == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 visitFunction(ofn, t);
				 }
				 else {
					 if (t != FunctionNode.FUNCTION_STATEMENT) {
						 throw Codegen.badTree();
					 }
				 }
				 break;
			 }
			 case Token.TRY: visitTryCatchFinally((Node.Jump)node, child);
			 break;
			 case Token.CATCH_SCOPE: {
				 int local = getLocalBlockRegister(node);
				 int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);
				 String name = child.getString();
				 child = child.getNext();
				 generateExpression(child, node);
				 if (scopeIndex == 0) {
					 cfw.add(ByteCode.ACONST_NULL);
				 }
				 else {
					 cfw.addALoad(local);
				 }
				 cfw.addPush(name);
				 cfw.addALoad(contextLocal);
				 cfw.addALoad(variableObjectLocal);
				 addScriptRuntimeInvoke( ""newCatchScope"", ""(Ljava/lang/Throwable;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Lorg/mozilla/javascript/Scriptable;
				"");
				 cfw.addAStore(local);
			 }
			 break;
			 case Token.THROW: generateExpression(child, node);
			 cfw.add(ByteCode.NEW, ""org/mozilla/javascript/JavaScriptException"");
			 cfw.add(ByteCode.DUP_X1);
			 cfw.add(ByteCode.SWAP);
			 cfw.addPush(scriptOrFn.getSourceName());
			 cfw.addPush(itsLineNumber);
			 cfw.addInvoke( ByteCode.INVOKESPECIAL, ""org/mozilla/javascript/JavaScriptException"", ""<init>"", ""(Ljava/lang/Object;
			Ljava/lang/String;
			I)V"");
			 cfw.add(ByteCode.ATHROW);
			 break;
			 case Token.RETHROW: cfw.addALoad(getLocalBlockRegister(node));
			 cfw.add(ByteCode.ATHROW);
			 break;
			 case Token.RETURN_RESULT: case Token.RETURN: if (child != null) {
				 generateExpression(child, node);
			 }
			 else if (type == Token.RETURN) {
				 Codegen.pushUndefined(cfw);
			 }
			 else {
				 if (popvLocal < 0) throw Codegen.badTree();
				 cfw.addALoad(popvLocal);
			 }
			 if (epilogueLabel == -1) {
				 if (!hasVarsInRegs) throw Codegen.badTree();
				 epilogueLabel = cfw.acquireLabel();
			 }
			 cfw.add(ByteCode.GOTO, epilogueLabel);
			 break;
			 case Token.SWITCH: visitSwitch((Node.Jump)node, child);
			 break;
			 case Token.ENTERWITH: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 cfw.addALoad(variableObjectLocal);
			 addScriptRuntimeInvoke( ""enterWith"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +"")Lorg/mozilla/javascript/Scriptable;
			"");
			 cfw.addAStore(variableObjectLocal);
			 break;
			 case Token.LEAVEWITH: cfw.addALoad(variableObjectLocal);
			 addScriptRuntimeInvoke( ""leaveWith"", ""(Lorg/mozilla/javascript/Scriptable;
			"" +"")Lorg/mozilla/javascript/Scriptable;
			"");
			 cfw.addAStore(variableObjectLocal);
			 break;
			 case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 cfw.addPush(type == Token.ENUM_INIT_VALUES);
			 addScriptRuntimeInvoke(""enumInit"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +""Z"" +"")Ljava/lang/Object;
			"");
			 cfw.addAStore(getLocalBlockRegister(node));
			 break;
			 case Token.EXPR_VOID: if (child.getType() == Token.SETVAR) {
				 visitSetVar(child, child.getFirstChild(), false);
			 }
			 else if (child.getType() == Token.SETCONSTVAR) {
				 visitSetConstVar(child, child.getFirstChild(), false);
			 }
			 else {
				 generateExpression(child, node);
				 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) cfw.add(ByteCode.POP2);
				 else cfw.add(ByteCode.POP);
			 }
			 break;
			 case Token.EXPR_RESULT: generateExpression(child, node);
			 if (popvLocal < 0) {
				 popvLocal = getNewWordLocal();
			 }
			 cfw.addAStore(popvLocal);
			 break;
			 case Token.TARGET: {
				 int label = getTargetLabel(node);
				 cfw.markLabel(label);
			 }
			 break;
			 case Token.JSR: case Token.GOTO: case Token.IFEQ: case Token.IFNE: visitGOTO((Node.Jump)node, type, child);
			 break;
			 case Token.FINALLY: {
				 int finallyRegister = getNewWordLocal();
				 cfw.addAStore(finallyRegister);
				 while (child != null) {
					 generateStatement(child);
					 child = child.getNext();
				 }
				 cfw.add(ByteCode.RET, finallyRegister);
				 releaseWordLocal((short)finallyRegister);
			 }
			 break;
			 default: throw Codegen.badTree();
		 }
	 }
	 private void generateExpression(Node node, Node parent) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.USE_STACK: break;
			 case Token.FUNCTION: if (fnCurrent != null || parent.getType() != Token.SCRIPT) {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex);
				 int t = ofn.fnode.getFunctionType();
				 if (t != FunctionNode.FUNCTION_EXPRESSION) {
					 throw Codegen.badTree();
				 }
				 visitFunction(ofn, t);
			 }
			 break;
			 case Token.NAME: {
				 cfw.addALoad(contextLocal);
				 cfw.addALoad(variableObjectLocal);
				 cfw.addPush(node.getString());
				 addScriptRuntimeInvoke( ""name"", ""(Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""Ljava/lang/String;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 break;
			 case Token.CALL: case Token.NEW: {
				 int specialType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL);
				 if (specialType == Node.NON_SPECIALCALL) {
					 OptFunctionNode target;
					 target = (OptFunctionNode)node.getProp( Node.DIRECTCALL_PROP);
					 if (target != null) {
						 visitOptimizedCall(node, target, type, child);
					 }
					 else if (type == Token.CALL) {
						 visitStandardCall(node, child);
					 }
					 else {
						 visitStandardNew(node, child);
					 }
				 }
				 else {
					 visitSpecialCall(node, type, specialType, child);
				 }
			 }
			 break;
			 case Token.REF_CALL: generateFunctionAndThisObj(child, node);
			 child = child.getNext();
			 generateCallArgArray(node, child, false);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke( ""callRef"", ""(Lorg/mozilla/javascript/Callable;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""[Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Lorg/mozilla/javascript/Ref;
			"");
			 break;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
					 cfw.addPush(num);
				 }
				 else {
					 codegen.pushNumberAsObject(cfw, num);
				 }
			 }
			 break;
			 case Token.STRING: cfw.addPush(node.getString());
			 break;
			 case Token.THIS: cfw.addALoad(thisObjLocal);
			 break;
			 case Token.THISFN: cfw.add(ByteCode.ALOAD_0);
			 break;
			 case Token.NULL: cfw.add(ByteCode.ACONST_NULL);
			 break;
			 case Token.TRUE: cfw.add(ByteCode.GETSTATIC, ""java/lang/Boolean"", ""TRUE"", ""Ljava/lang/Boolean;
			"");
			 break;
			 case Token.FALSE: cfw.add(ByteCode.GETSTATIC, ""java/lang/Boolean"", ""FALSE"", ""Ljava/lang/Boolean;
			"");
			 break;
			 case Token.REGEXP: {
				 int i = node.getExistingIntProp(Node.REGEXP_PROP);
				 if (fnCurrent == null) {
					 cfw.addALoad(scriptRegexpLocal);
				 }
				 else {
					 cfw.addALoad(funObjLocal);
					 cfw.add(ByteCode.GETFIELD, codegen.mainClassName, Codegen.REGEXP_ARRAY_FIELD_NAME, Codegen.REGEXP_ARRAY_FIELD_TYPE);
				 }
				 cfw.addPush(i);
				 cfw.add(ByteCode.AALOAD);
			 }
			 break;
			 case Token.COMMA: {
				 Node next = child.getNext();
				 while (next != null) {
					 generateExpression(child, node);
					 cfw.add(ByteCode.POP);
					 child = next;
					 next = next.getNext();
				 }
				 generateExpression(child, node);
				 break;
			 }
			 case Token.ENUM_NEXT: case Token.ENUM_ID: {
				 int local = getLocalBlockRegister(node);
				 cfw.addALoad(local);
				 if (type == Token.ENUM_NEXT) {
					 addScriptRuntimeInvoke( ""enumNext"", ""(Ljava/lang/Object;
					)Ljava/lang/Boolean;
					"");
				 }
				 else {
					 cfw.addALoad(contextLocal);
					 addScriptRuntimeInvoke(""enumId"", ""(Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +"")Ljava/lang/Object;
					"");
				 }
				 break;
			 }
			 case Token.ARRAYLIT: visitArrayLiteral(node, child);
			 break;
			 case Token.OBJECTLIT: visitObjectLiteral(node, child);
			 break;
			 case Token.NOT: {
				 int trueTarget = cfw.acquireLabel();
				 int falseTarget = cfw.acquireLabel();
				 int beyond = cfw.acquireLabel();
				 generateIfJump(child, node, trueTarget, falseTarget);
				 cfw.markLabel(trueTarget);
				 cfw.add(ByteCode.GETSTATIC, ""java/lang/Boolean"", ""FALSE"", ""Ljava/lang/Boolean;
				"");
				 cfw.add(ByteCode.GOTO, beyond);
				 cfw.markLabel(falseTarget);
				 cfw.add(ByteCode.GETSTATIC, ""java/lang/Boolean"", ""TRUE"", ""Ljava/lang/Boolean;
				"");
				 cfw.markLabel(beyond);
				 cfw.adjustStackTop(-1);
				 break;
			 }
			 case Token.BITNOT: generateExpression(child, node);
			 addScriptRuntimeInvoke(""toInt32"", ""(Ljava/lang/Object;
			)I"");
			 cfw.addPush(-1);
			 cfw.add(ByteCode.IXOR);
			 cfw.add(ByteCode.I2D);
			 addDoubleWrap();
			 break;
			 case Token.VOID: generateExpression(child, node);
			 cfw.add(ByteCode.POP);
			 Codegen.pushUndefined(cfw);
			 break;
			 case Token.TYPEOF: generateExpression(child, node);
			 addScriptRuntimeInvoke(""typeof"", ""(Ljava/lang/Object;
			"" +"")Ljava/lang/String;
			"");
			 break;
			 case Token.TYPEOFNAME: visitTypeofname(node);
			 break;
			 case Token.INC: case Token.DEC: visitIncDec(node);
			 break;
			 case Token.OR: case Token.AND: {
				 generateExpression(child, node);
				 cfw.add(ByteCode.DUP);
				 addScriptRuntimeInvoke(""toBoolean"", ""(Ljava/lang/Object;
				)Z"");
				 int falseTarget = cfw.acquireLabel();
				 if (type == Token.AND) cfw.add(ByteCode.IFEQ, falseTarget);
				 else cfw.add(ByteCode.IFNE, falseTarget);
				 cfw.add(ByteCode.POP);
				 generateExpression(child.getNext(), node);
				 cfw.markLabel(falseTarget);
			 }
			 break;
			 case Token.HOOK : {
				 Node ifThen = child.getNext();
				 Node ifElse = ifThen.getNext();
				 generateExpression(child, node);
				 addScriptRuntimeInvoke(""toBoolean"", ""(Ljava/lang/Object;
				)Z"");
				 int elseTarget = cfw.acquireLabel();
				 cfw.add(ByteCode.IFEQ, elseTarget);
				 short stack = cfw.getStackTop();
				 generateExpression(ifThen, node);
				 int afterHook = cfw.acquireLabel();
				 cfw.add(ByteCode.GOTO, afterHook);
				 cfw.markLabel(elseTarget, stack);
				 generateExpression(ifElse, node);
				 cfw.markLabel(afterHook);
			 }
			 break;
			 case Token.ADD: {
				 generateExpression(child, node);
				 generateExpression(child.getNext(), node);
				 switch (node.getIntProp(Node.ISNUMBER_PROP, -1)) {
					 case Node.BOTH: cfw.add(ByteCode.DADD);
					 break;
					 case Node.LEFT: addOptRuntimeInvoke(""add"", ""(DLjava/lang/Object;
					)Ljava/lang/Object;
					"");
					 break;
					 case Node.RIGHT: addOptRuntimeInvoke(""add"", ""(Ljava/lang/Object;
					D)Ljava/lang/Object;
					"");
					 break;
					 default: cfw.addALoad(contextLocal);
					 addScriptRuntimeInvoke(""add"", ""(Ljava/lang/Object;
					"" +""Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +"")Ljava/lang/Object;
					"");
				 }
			 }
			 break;
			 case Token.MUL: visitArithmetic(node, ByteCode.DMUL, child, parent);
			 break;
			 case Token.SUB: visitArithmetic(node, ByteCode.DSUB, child, parent);
			 break;
			 case Token.DIV: case Token.MOD: visitArithmetic(node, type == Token.DIV ? ByteCode.DDIV : ByteCode.DREM, child, parent);
			 break;
			 case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.LSH: case Token.RSH: case Token.URSH: visitBitOp(node, type, child);
			 break;
			 case Token.POS: case Token.NEG: generateExpression(child, node);
			 addObjectToDouble();
			 if (type == Token.NEG) {
				 cfw.add(ByteCode.DNEG);
			 }
			 addDoubleWrap();
			 break;
			 case Token.TO_DOUBLE: generateExpression(child, node);
			 addObjectToDouble();
			 break;
			 case Token.TO_OBJECT: {
				 int prop = -1;
				 if (child.getType() == Token.NUMBER) {
					 prop = child.getIntProp(Node.ISNUMBER_PROP, -1);
				 }
				 if (prop != -1) {
					 child.removeProp(Node.ISNUMBER_PROP);
					 generateExpression(child, node);
					 child.putIntProp(Node.ISNUMBER_PROP, prop);
				 }
				 else {
					 generateExpression(child, node);
					 addDoubleWrap();
				 }
				 break;
			 }
			 case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: {
				 int trueGOTO = cfw.acquireLabel();
				 int falseGOTO = cfw.acquireLabel();
				 visitIfJumpRelOp(node, child, trueGOTO, falseGOTO);
				 addJumpedBooleanWrap(trueGOTO, falseGOTO);
				 break;
			 }
			 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: {
				 int trueGOTO = cfw.acquireLabel();
				 int falseGOTO = cfw.acquireLabel();
				 visitIfJumpEqOp(node, child, trueGOTO, falseGOTO);
				 addJumpedBooleanWrap(trueGOTO, falseGOTO);
				 break;
			 }
			 case Token.GETPROP: visitGetProp(node, child);
			 break;
			 case Token.GETELEM: generateExpression(child, node);
			 generateExpression(child.getNext(), node);
			 cfw.addALoad(contextLocal);
			 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
				 addScriptRuntimeInvoke( ""getObjectIndex"", ""(Ljava/lang/Object;
				D"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 else {
				 addScriptRuntimeInvoke( ""getObjectElem"", ""(Ljava/lang/Object;
				"" +""Ljava/lang/Object;
				"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 break;
			 case Token.GET_REF: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke( ""refGet"", ""(Lorg/mozilla/javascript/Ref;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
			 break;
			 case Token.GETVAR: visitGetVar(node);
			 break;
			 case Token.SETVAR: visitSetVar(node, child, true);
			 break;
			 case Token.SETNAME: visitSetName(node, child);
			 break;
			 case Token.SETCONST: visitSetConst(node, child);
			 break;
			 case Token.SETCONSTVAR: visitSetConstVar(node, child, true);
			 break;
			 case Token.SETPROP: case Token.SETPROP_OP: visitSetProp(type, node, child);
			 break;
			 case Token.SETELEM: case Token.SETELEM_OP: visitSetElem(type, node, child);
			 break;
			 case Token.SET_REF: case Token.SET_REF_OP: {
				 generateExpression(child, node);
				 child = child.getNext();
				 if (type == Token.SET_REF_OP) {
					 cfw.add(ByteCode.DUP);
					 cfw.addALoad(contextLocal);
					 addScriptRuntimeInvoke( ""refGet"", ""(Lorg/mozilla/javascript/Ref;
					"" +""Lorg/mozilla/javascript/Context;
					"" +"")Ljava/lang/Object;
					"");
				 }
				 generateExpression(child, node);
				 cfw.addALoad(contextLocal);
				 addScriptRuntimeInvoke( ""refSet"", ""(Lorg/mozilla/javascript/Ref;
				"" +""Ljava/lang/Object;
				"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 break;
			 case Token.DEL_REF: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke(""refDel"", ""(Lorg/mozilla/javascript/Ref;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
			 break;
			 case Token.DELPROP: generateExpression(child, node);
			 child = child.getNext();
			 generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke(""delete"", ""(Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
			 break;
			 case Token.BINDNAME: {
				 while (child != null) {
					 generateExpression(child, node);
					 child = child.getNext();
				 }
				 cfw.addALoad(contextLocal);
				 cfw.addALoad(variableObjectLocal);
				 cfw.addPush(node.getString());
				 addScriptRuntimeInvoke( ""bind"", ""(Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""Ljava/lang/String;
				"" +"")Lorg/mozilla/javascript/Scriptable;
				"");
			 }
			 break;
			 case Token.LOCAL_LOAD: cfw.addALoad(getLocalBlockRegister(node));
			 break;
			 case Token.REF_SPECIAL: {
				 String special = (String)node.getProp(Node.NAME_PROP);
				 generateExpression(child, node);
				 cfw.addPush(special);
				 cfw.addALoad(contextLocal);
				 addScriptRuntimeInvoke( ""specialRef"", ""(Ljava/lang/Object;
				"" +""Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +"")Lorg/mozilla/javascript/Ref;
				"");
			 }
			 break;
			 case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: {
				 int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);
				 do {
					 generateExpression(child, node);
					 child = child.getNext();
				 }
				 while (child != null);
				 cfw.addALoad(contextLocal);
				 String methodName, signature;
				 switch (type) {
					 case Token.REF_MEMBER: methodName = ""memberRef"";
					 signature = ""(Ljava/lang/Object;
					"" +""Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +""I"" +"")Lorg/mozilla/javascript/Ref;
					"";
					 break;
					 case Token.REF_NS_MEMBER: methodName = ""memberRef"";
					 signature = ""(Ljava/lang/Object;
					"" +""Ljava/lang/Object;
					"" +""Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +""I"" +"")Lorg/mozilla/javascript/Ref;
					"";
					 break;
					 case Token.REF_NAME: methodName = ""nameRef"";
					 signature = ""(Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +""Lorg/mozilla/javascript/Scriptable;
					"" +""I"" +"")Lorg/mozilla/javascript/Ref;
					"";
					 cfw.addALoad(variableObjectLocal);
					 break;
					 case Token.REF_NS_NAME: methodName = ""nameRef"";
					 signature = ""(Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +""Lorg/mozilla/javascript/Scriptable;
					"" +""I"" +"")Lorg/mozilla/javascript/Ref;
					"";
					 cfw.addALoad(variableObjectLocal);
					 break;
					 default: throw Kit.codeBug();
				 }
				 cfw.addPush(memberTypeFlags);
				 addScriptRuntimeInvoke(methodName, signature);
			 }
			 break;
			 case Token.DOTQUERY: visitDotQuery(node, child);
			 break;
			 case Token.ESCXMLATTR: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke(""escapeAttributeValue"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/String;
			"");
			 break;
			 case Token.ESCXMLTEXT: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke(""escapeTextValue"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/String;
			"");
			 break;
			 case Token.DEFAULTNAMESPACE: generateExpression(child, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke(""setDefaultNamespace"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
			 break;
			 default: throw new RuntimeException(""Unexpected node type ""+type);
		 }
	 }
	 private void generateIfJump(Node node, Node parent, int trueLabel, int falseLabel) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.NOT: generateIfJump(child, node, falseLabel, trueLabel);
			 break;
			 case Token.OR: case Token.AND: {
				 int interLabel = cfw.acquireLabel();
				 if (type == Token.AND) {
					 generateIfJump(child, node, interLabel, falseLabel);
				 }
				 else {
					 generateIfJump(child, node, trueLabel, interLabel);
				 }
				 cfw.markLabel(interLabel);
				 child = child.getNext();
				 generateIfJump(child, node, trueLabel, falseLabel);
				 break;
			 }
			 case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitIfJumpRelOp(node, child, trueLabel, falseLabel);
			 break;
			 case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: visitIfJumpEqOp(node, child, trueLabel, falseLabel);
			 break;
			 default: generateExpression(node, parent);
			 addScriptRuntimeInvoke(""toBoolean"", ""(Ljava/lang/Object;
			)Z"");
			 cfw.add(ByteCode.IFNE, trueLabel);
			 cfw.add(ByteCode.GOTO, falseLabel);
		 }
	 }
	 private void visitFunction(OptFunctionNode ofn, int functionType) {
		 int fnIndex = codegen.getIndex(ofn.fnode);
		 cfw.add(ByteCode.NEW, codegen.mainClassName);
		 cfw.add(ByteCode.DUP);
		 cfw.addALoad(variableObjectLocal);
		 cfw.addALoad(contextLocal);
		 cfw.addPush(fnIndex);
		 cfw.addInvoke(ByteCode.INVOKESPECIAL, codegen.mainClassName, ""<init>"", Codegen.FUNCTION_CONSTRUCTOR_SIGNATURE);
		 cfw.add(ByteCode.DUP);
		 if (isTopLevel) {
			 cfw.add(ByteCode.ALOAD_0);
		 }
		 else {
			 cfw.add(ByteCode.ALOAD_0);
			 cfw.add(ByteCode.GETFIELD, codegen.mainClassName, Codegen.DIRECT_CALL_PARENT_FIELD, codegen.mainClassSignature);
		 }
		 cfw.add(ByteCode.PUTFIELD, codegen.mainClassName, Codegen.DIRECT_CALL_PARENT_FIELD, codegen.mainClassSignature);
		 int directTargetIndex = ofn.getDirectTargetIndex();
		 if (directTargetIndex >= 0) {
			 cfw.add(ByteCode.DUP);
			 if (isTopLevel) {
				 cfw.add(ByteCode.ALOAD_0);
			 }
			 else {
				 cfw.add(ByteCode.ALOAD_0);
				 cfw.add(ByteCode.GETFIELD, codegen.mainClassName, Codegen.DIRECT_CALL_PARENT_FIELD, codegen.mainClassSignature);
			 }
			 cfw.add(ByteCode.SWAP);
			 cfw.add(ByteCode.PUTFIELD, codegen.mainClassName, Codegen.getDirectTargetFieldName(directTargetIndex), codegen.mainClassSignature);
		 }
		 if (functionType == FunctionNode.FUNCTION_EXPRESSION) {
			 return;
		 }
		 cfw.addPush(functionType);
		 cfw.addALoad(variableObjectLocal);
		 cfw.addALoad(contextLocal);
		 addOptRuntimeInvoke(""initFunction"", ""(Lorg/mozilla/javascript/NativeFunction;
		"" +""I"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Lorg/mozilla/javascript/Context;
		"" +"")V"");
	 }
	 private int getTargetLabel(Node target) {
		 int labelId = target.labelId();
		 if (labelId == -1) {
			 labelId = cfw.acquireLabel();
			 target.labelId(labelId);
		 }
		 return labelId;
	 }
	 private void visitGOTO(Node.Jump node, int type, Node child) {
		 Node target = node.target;
		 if (type == Token.IFEQ || type == Token.IFNE) {
			 if (child == null) throw Codegen.badTree();
			 int targetLabel = getTargetLabel(target);
			 int fallThruLabel = cfw.acquireLabel();
			 if (type == Token.IFEQ) generateIfJump(child, node, targetLabel, fallThruLabel);
			 else generateIfJump(child, node, fallThruLabel, targetLabel);
			 cfw.markLabel(fallThruLabel);
		 }
		 else {
			 if (type == Token.JSR) addGoto(target, ByteCode.JSR);
			 else addGoto(target, ByteCode.GOTO);
		 }
	 }
	 private void visitArrayLiteral(Node node, Node child) {
		 int count = 0;
		 for (Node cursor = child;
		 cursor != null;
		 cursor = cursor.getNext()) {
			 ++count;
		 }
		 addNewObjectArray(count);
		 for (int i = 0;
		 i != count;
		 ++i) {
			 cfw.add(ByteCode.DUP);
			 cfw.addPush(i);
			 generateExpression(child, node);
			 cfw.add(ByteCode.AASTORE);
			 child = child.getNext();
		 }
		 int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);
		 if (skipIndexes == null) {
			 cfw.add(ByteCode.ACONST_NULL);
			 cfw.add(ByteCode.ICONST_0);
		 }
		 else {
			 cfw.addPush(OptRuntime.encodeIntArray(skipIndexes));
			 cfw.addPush(skipIndexes.length);
		 }
		 cfw.addALoad(contextLocal);
		 cfw.addALoad(variableObjectLocal);
		 addOptRuntimeInvoke(""newArrayLiteral"", ""([Ljava/lang/Object;
		"" +""Ljava/lang/String;
		"" +""I"" +""Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
	 }
	 private void visitObjectLiteral(Node node, Node child) {
		 Object[] properties = (Object[])node.getProp(Node.OBJECT_IDS_PROP);
		 int count = properties.length;
		 addNewObjectArray(count);
		 for (int i = 0;
		 i != count;
		 ++i) {
			 cfw.add(ByteCode.DUP);
			 cfw.addPush(i);
			 Object id = properties[i];
			 if (id instanceof String) {
				 cfw.addPush((String)id);
			 }
			 else {
				 cfw.addPush(((Integer)id).intValue());
				 addScriptRuntimeInvoke(""wrapInt"", ""(I)Ljava/lang/Integer;
				"");
			 }
			 cfw.add(ByteCode.AASTORE);
		 }
		 addNewObjectArray(count);
		 Node child2 = child;
		 for (int i = 0;
		 i != count;
		 ++i) {
			 cfw.add(ByteCode.DUP);
			 cfw.addPush(i);
			 int childType = child.getType();
			 if (childType == Token.GET) {
				 generateExpression(child.getFirstChild(), node);
			 }
			 else if (childType == Token.SET) {
				 generateExpression(child.getFirstChild(), node);
			 }
			 else {
				 generateExpression(child, node);
			 }
			 cfw.add(ByteCode.AASTORE);
			 child = child.getNext();
		 }
		 cfw.addPush(count);
		 cfw.add(ByteCode.NEWARRAY, ByteCode.T_INT);
		 for (int i = 0;
		 i != count;
		 ++i) {
			 cfw.add(ByteCode.DUP);
			 cfw.addPush(i);
			 int childType = child2.getType();
			 if (childType == Token.GET) {
				 cfw.add(ByteCode.ICONST_M1);
			 }
			 else if (childType == Token.SET) {
				 cfw.add(ByteCode.ICONST_1);
			 }
			 else {
				 cfw.add(ByteCode.ICONST_0);
			 }
			 cfw.add(ByteCode.IASTORE);
			 child2 = child2.getNext();
		 }
		 cfw.addALoad(contextLocal);
		 cfw.addALoad(variableObjectLocal);
		 addScriptRuntimeInvoke(""newObjectLiteral"", ""([Ljava/lang/Object;
		"" +""[Ljava/lang/Object;
		"" +""[I"" +""Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
	 }
	 private void visitSpecialCall(Node node, int type, int specialType, Node child) {
		 cfw.addALoad(contextLocal);
		 if (type == Token.NEW) {
			 generateExpression(child, node);
		 }
		 else {
			 generateFunctionAndThisObj(child, node);
		 }
		 child = child.getNext();
		 generateCallArgArray(node, child, false);
		 String methodName;
		 String callSignature;
		 if (type == Token.NEW) {
			 methodName = ""newObjectSpecial"";
			 callSignature = ""(Lorg/mozilla/javascript/Context;
			"" +""Ljava/lang/Object;
			"" +""[Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""I"" +"")Ljava/lang/Object;
			"";
			 cfw.addALoad(variableObjectLocal);
			 cfw.addALoad(thisObjLocal);
			 cfw.addPush(specialType);
		 }
		 else {
			 methodName = ""callSpecial"";
			 callSignature = ""(Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Callable;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""[Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""I"" +""Ljava/lang/String;
			I"" +"")Ljava/lang/Object;
			"";
			 cfw.addALoad(variableObjectLocal);
			 cfw.addALoad(thisObjLocal);
			 cfw.addPush(specialType);
			 String sourceName = scriptOrFn.getSourceName();
			 cfw.addPush(sourceName == null ? """" : sourceName);
			 cfw.addPush(itsLineNumber);
		 }
		 addOptRuntimeInvoke(methodName, callSignature);
	 }
	 private void visitStandardCall(Node node, Node child) {
		 if (node.getType() != Token.CALL) throw Codegen.badTree();
		 Node firstArgChild = child.getNext();
		 int childType = child.getType();
		 String methodName;
		 String signature;
		 if (firstArgChild == null) {
			 if (childType == Token.NAME) {
				 String name = child.getString();
				 cfw.addPush(name);
				 methodName = ""callName0"";
				 signature = ""(Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Ljava/lang/Object;
				"";
			 }
			 else if (childType == Token.GETPROP) {
				 Node propTarget = child.getFirstChild();
				 generateExpression(propTarget, node);
				 Node id = propTarget.getNext();
				 String property = id.getString();
				 cfw.addPush(property);
				 methodName = ""callProp0"";
				 signature = ""(Ljava/lang/Object;
				"" +""Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Ljava/lang/Object;
				"";
			 }
			 else {
				 generateFunctionAndThisObj(child, node);
				 methodName = ""call0"";
				 signature = ""(Lorg/mozilla/javascript/Callable;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Ljava/lang/Object;
				"";
			 }
		 }
		 else if (childType == Token.NAME) {
			 String name = child.getString();
			 generateCallArgArray(node, firstArgChild, false);
			 cfw.addPush(name);
			 methodName = ""callName"";
			 signature = ""([Ljava/lang/Object;
			"" +""Ljava/lang/String;
			"" +""Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +"")Ljava/lang/Object;
			"";
		 }
		 else {
			 int argCount = 0;
			 for (Node arg = firstArgChild;
			 arg != null;
			 arg = arg.getNext()) {
				 ++argCount;
			 }
			 generateFunctionAndThisObj(child, node);
			 if (argCount == 1) {
				 generateExpression(firstArgChild, node);
				 methodName = ""call1"";
				 signature = ""(Lorg/mozilla/javascript/Callable;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""Ljava/lang/Object;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Ljava/lang/Object;
				"";
			 }
			 else if (argCount == 2) {
				 generateExpression(firstArgChild, node);
				 generateExpression(firstArgChild.getNext(), node);
				 methodName = ""call2"";
				 signature = ""(Lorg/mozilla/javascript/Callable;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""Ljava/lang/Object;
				"" +""Ljava/lang/Object;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Ljava/lang/Object;
				"";
			 }
			 else {
				 generateCallArgArray(node, firstArgChild, false);
				 methodName = ""callN"";
				 signature = ""(Lorg/mozilla/javascript/Callable;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +""[Ljava/lang/Object;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Ljava/lang/Object;
				"";
			 }
		 }
		 cfw.addALoad(contextLocal);
		 cfw.addALoad(variableObjectLocal);
		 addOptRuntimeInvoke(methodName, signature);
	 }
	 private void visitStandardNew(Node node, Node child) {
		 if (node.getType() != Token.NEW) throw Codegen.badTree();
		 Node firstArgChild = child.getNext();
		 generateExpression(child, node);
		 cfw.addALoad(contextLocal);
		 cfw.addALoad(variableObjectLocal);
		 generateCallArgArray(node, firstArgChild, false);
		 addScriptRuntimeInvoke( ""newObject"", ""(Ljava/lang/Object;
		"" +""Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""[Ljava/lang/Object;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
	 }
	 private void visitOptimizedCall(Node node, OptFunctionNode target, int type, Node child) {
		 Node firstArgChild = child.getNext();
		 short thisObjLocal = 0;
		 if (type == Token.NEW) {
			 generateExpression(child, node);
		 }
		 else {
			 generateFunctionAndThisObj(child, node);
			 thisObjLocal = getNewWordLocal();
			 cfw.addAStore(thisObjLocal);
		 }
		 int beyond = cfw.acquireLabel();
		 int directTargetIndex = target.getDirectTargetIndex();
		 if (isTopLevel) {
			 cfw.add(ByteCode.ALOAD_0);
		 }
		 else {
			 cfw.add(ByteCode.ALOAD_0);
			 cfw.add(ByteCode.GETFIELD, codegen.mainClassName, Codegen.DIRECT_CALL_PARENT_FIELD, codegen.mainClassSignature);
		 }
		 cfw.add(ByteCode.GETFIELD, codegen.mainClassName, Codegen.getDirectTargetFieldName(directTargetIndex), codegen.mainClassSignature);
		 cfw.add(ByteCode.DUP2);
		 int regularCall = cfw.acquireLabel();
		 cfw.add(ByteCode.IF_ACMPNE, regularCall);
		 short stackHeight = cfw.getStackTop();
		 cfw.add(ByteCode.SWAP);
		 cfw.add(ByteCode.POP);
		 if (compilerEnv.isUseDynamicScope()) {
			 cfw.addALoad(contextLocal);
			 cfw.addALoad(variableObjectLocal);
		 }
		 else {
			 cfw.add(ByteCode.DUP);
			 cfw.addInvoke(ByteCode.INVOKEINTERFACE, ""org/mozilla/javascript/Scriptable"", ""getParentScope"", ""()Lorg/mozilla/javascript/Scriptable;
			"");
			 cfw.addALoad(contextLocal);
			 cfw.add(ByteCode.SWAP);
		 }
		 if (type == Token.NEW) {
			 cfw.add(ByteCode.ACONST_NULL);
		 }
		 else {
			 cfw.addALoad(thisObjLocal);
		 }
		 Node argChild = firstArgChild;
		 while (argChild != null) {
			 int dcp_register = nodeIsDirectCallParameter(argChild);
			 if (dcp_register >= 0) {
				 cfw.addALoad(dcp_register);
				 cfw.addDLoad(dcp_register + 1);
			 }
			 else if (argChild.getIntProp(Node.ISNUMBER_PROP, -1) == Node.BOTH) {
				 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
				"");
				 generateExpression(argChild, node);
			 }
			 else {
				 generateExpression(argChild, node);
				 cfw.addPush(0.0);
			 }
			 argChild = argChild.getNext();
		 }
		 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""emptyArgs"", ""[Ljava/lang/Object;
		"");
		 cfw.addInvoke(ByteCode.INVOKESTATIC, codegen.mainClassName, (type == Token.NEW) ? codegen.getDirectCtorName(target.fnode) : codegen.getBodyMethodName(target.fnode), codegen.getBodyMethodSignature(target.fnode));
		 cfw.add(ByteCode.GOTO, beyond);
		 cfw.markLabel(regularCall, stackHeight);
		 cfw.add(ByteCode.POP);
		 cfw.addALoad(contextLocal);
		 cfw.addALoad(variableObjectLocal);
		 if (type != Token.NEW) {
			 cfw.addALoad(thisObjLocal);
			 releaseWordLocal(thisObjLocal);
		 }
		 generateCallArgArray(node, firstArgChild, true);
		 if (type == Token.NEW) {
			 addScriptRuntimeInvoke( ""newObject"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""[Ljava/lang/Object;
			"" +"")Lorg/mozilla/javascript/Scriptable;
			"");
		 }
		 else {
			 cfw.addInvoke(ByteCode.INVOKEINTERFACE, ""org/mozilla/javascript/Callable"", ""call"", ""(Lorg/mozilla/javascript/Context;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""Lorg/mozilla/javascript/Scriptable;
			"" +""[Ljava/lang/Object;
			"" +"")Ljava/lang/Object;
			"");
		 }
		 cfw.markLabel(beyond);
	 }
	 private void generateCallArgArray(Node node, Node argChild, boolean directCall) {
		 int argCount = 0;
		 for (Node child = argChild;
		 child != null;
		 child = child.getNext()) {
			 ++argCount;
		 }
		 if (argCount == 1 && itsOneArgArray >= 0) {
			 cfw.addALoad(itsOneArgArray);
		 }
		 else {
			 addNewObjectArray(argCount);
		 }
		 for (int i = 0;
		 i != argCount;
		 ++i) {
			 cfw.add(ByteCode.DUP);
			 cfw.addPush(i);
			 if (!directCall) {
				 generateExpression(argChild, node);
			 }
			 else {
				 int dcp_register = nodeIsDirectCallParameter(argChild);
				 if (dcp_register >= 0) {
					 dcpLoadAsObject(dcp_register);
				 }
				 else {
					 generateExpression(argChild, node);
					 int childNumberFlag = argChild.getIntProp(Node.ISNUMBER_PROP, -1);
					 if (childNumberFlag == Node.BOTH) {
						 addDoubleWrap();
					 }
				 }
			 }
			 cfw.add(ByteCode.AASTORE);
			 argChild = argChild.getNext();
		 }
	 }
	 private void generateFunctionAndThisObj(Node node, Node parent) {
		 int type = node.getType();
		 switch (node.getType()) {
			 case Token.GETPROP: case Token.GETELEM: {
				 Node target = node.getFirstChild();
				 generateExpression(target, node);
				 Node id = target.getNext();
				 if (type == Token.GETPROP) {
					 String property = id.getString();
					 cfw.addPush(property);
					 cfw.addALoad(contextLocal);
					 addScriptRuntimeInvoke( ""getPropFunctionAndThis"", ""(Ljava/lang/Object;
					"" +""Ljava/lang/String;
					"" +""Lorg/mozilla/javascript/Context;
					"" +"")Lorg/mozilla/javascript/Callable;
					"");
				 }
				 else {
					 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) throw Codegen.badTree();
					 generateExpression(id, node);
					 cfw.addALoad(contextLocal);
					 addScriptRuntimeInvoke( ""getElemFunctionAndThis"", ""(Ljava/lang/Object;
					"" +""Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +"")Lorg/mozilla/javascript/Callable;
					"");
				 }
				 break;
			 }
			 case Token.NAME: {
				 String name = node.getString();
				 cfw.addPush(name);
				 cfw.addALoad(contextLocal);
				 cfw.addALoad(variableObjectLocal);
				 addScriptRuntimeInvoke( ""getNameFunctionAndThis"", ""(Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""Lorg/mozilla/javascript/Scriptable;
				"" +"")Lorg/mozilla/javascript/Callable;
				"");
				 break;
			 }
			 default: generateExpression(node, parent);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke( ""getValueFunctionAndThis"", ""(Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Lorg/mozilla/javascript/Callable;
			"");
			 break;
		 }
		 cfw.addALoad(contextLocal);
		 addScriptRuntimeInvoke( ""lastStoredScriptable"", ""(Lorg/mozilla/javascript/Context;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
	 }
	 private void updateLineNumber(Node node) {
		 itsLineNumber = node.getLineno();
		 if (itsLineNumber == -1) return;
		 cfw.addLineNumberEntry((short)itsLineNumber);
	 }
	 private void visitTryCatchFinally(Node.Jump node, Node child) {
		 short savedVariableObject = getNewWordLocal();
		 cfw.addALoad(variableObjectLocal);
		 cfw.addAStore(savedVariableObject);
		 int startLabel = cfw.acquireLabel();
		 cfw.markLabel(startLabel, (short)1);
		 while (child != null) {
			 generateStatement(child);
			 child = child.getNext();
		 }
		 Node catchTarget = node.target;
		 Node finallyTarget = node.getFinally();
		 int realEnd = cfw.acquireLabel();
		 cfw.add(ByteCode.GOTO, realEnd);
		 int exceptionLocal = getLocalBlockRegister(node);
		 if (catchTarget != null) {
			 int catchLabel = catchTarget.labelId();
			 generateCatchBlock(JAVASCRIPT_EXCEPTION, savedVariableObject, catchLabel, startLabel, exceptionLocal);
			 generateCatchBlock(EVALUATOR_EXCEPTION, savedVariableObject, catchLabel, startLabel, exceptionLocal);
			 generateCatchBlock(ECMAERROR_EXCEPTION, savedVariableObject, catchLabel, startLabel, exceptionLocal);
		 }
		 if (finallyTarget != null) {
			 int finallyHandler = cfw.acquireLabel();
			 cfw.markHandler(finallyHandler);
			 cfw.addAStore(exceptionLocal);
			 cfw.addALoad(savedVariableObject);
			 cfw.addAStore(variableObjectLocal);
			 int finallyLabel = finallyTarget.labelId();
			 cfw.add(ByteCode.JSR, finallyLabel);
			 cfw.addALoad(exceptionLocal);
			 cfw.add(ByteCode.ATHROW);
			 cfw.addExceptionHandler(startLabel, finallyLabel, finallyHandler, null);
		 }
		 releaseWordLocal(savedVariableObject);
		 cfw.markLabel(realEnd);
	 }
	 private static final int JAVASCRIPT_EXCEPTION = 0;
	 private static final int EVALUATOR_EXCEPTION = 1;
	 private static final int ECMAERROR_EXCEPTION = 2;
	 private void generateCatchBlock(int exceptionType, short savedVariableObject, int catchLabel, int startLabel, int exceptionLocal) {
		 int handler = cfw.acquireLabel();
		 cfw.markHandler(handler);
		 cfw.addAStore(exceptionLocal);
		 cfw.addALoad(savedVariableObject);
		 cfw.addAStore(variableObjectLocal);
		 String exceptionName;
		 if (exceptionType == JAVASCRIPT_EXCEPTION) {
			 exceptionName = ""org/mozilla/javascript/JavaScriptException"";
		 }
		 else if (exceptionType == EVALUATOR_EXCEPTION) {
			 exceptionName = ""org/mozilla/javascript/EvaluatorException"";
		 }
		 else {
			 if (exceptionType != ECMAERROR_EXCEPTION) Kit.codeBug();
			 exceptionName = ""org/mozilla/javascript/EcmaError"";
		 }
		 cfw.addExceptionHandler(startLabel, catchLabel, handler, exceptionName);
		 cfw.add(ByteCode.GOTO, catchLabel);
	 }
	 private void visitSwitch(Node.Jump switchNode, Node child) {
		 generateExpression(child, switchNode);
		 short selector = getNewWordLocal();
		 cfw.addAStore(selector);
		 for (Node.Jump caseNode = (Node.Jump)child.getNext();
		 caseNode != null;
		 caseNode = (Node.Jump)caseNode.getNext()) {
			 if (caseNode.getType() != Token.CASE) throw Codegen.badTree();
			 Node test = caseNode.getFirstChild();
			 generateExpression(test, caseNode);
			 cfw.addALoad(selector);
			 addScriptRuntimeInvoke(""shallowEq"", ""(Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +"")Z"");
			 addGoto(caseNode.target, ByteCode.IFNE);
		 }
		 releaseWordLocal(selector);
	 }
	 private void visitTypeofname(Node node) {
		 String name = node.getString();
		 if (hasVarsInRegs) {
			 int varIndex = fnCurrent.fnode.getParamOrVarIndex(name);
			 if (varIndex >= 0) {
				 if (fnCurrent.isNumberVar(varIndex)) {
					 cfw.addPush(""number"");
				 }
				 else if (varIsDirectCallParameter(varIndex)) {
					 int dcp_register = varRegisters[varIndex];
					 cfw.addALoad(dcp_register);
					 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
					"");
					 int isNumberLabel = cfw.acquireLabel();
					 cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);
					 short stack = cfw.getStackTop();
					 cfw.addALoad(dcp_register);
					 addScriptRuntimeInvoke(""typeof"", ""(Ljava/lang/Object;
					"" +"")Ljava/lang/String;
					"");
					 int beyond = cfw.acquireLabel();
					 cfw.add(ByteCode.GOTO, beyond);
					 cfw.markLabel(isNumberLabel, stack);
					 cfw.addPush(""number"");
					 cfw.markLabel(beyond);
				 }
				 else {
					 cfw.addALoad(varRegisters[varIndex]);
					 addScriptRuntimeInvoke(""typeof"", ""(Ljava/lang/Object;
					"" +"")Ljava/lang/String;
					"");
				 }
				 return;
			 }
		 }
		 cfw.addALoad(variableObjectLocal);
		 cfw.addPush(name);
		 addScriptRuntimeInvoke(""typeofName"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/String;
		"" +"")Ljava/lang/String;
		"");
	 }
	 private void visitIncDec(Node node) {
		 int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);
		 Node child = node.getFirstChild();
		 switch (child.getType()) {
			 case Token.GETVAR: if (!hasVarsInRegs) Kit.codeBug();
			 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
				 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
				 int varIndex = fnCurrent.getVarIndex(child);
				 short reg = varRegisters[varIndex];
				 int offset = varIsDirectCallParameter(varIndex) ? 1 : 0;
				 cfw.addDLoad(reg + offset);
				 if (post) {
					 cfw.add(ByteCode.DUP2);
				 }
				 cfw.addPush(1.0);
				 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
					 cfw.add(ByteCode.DADD);
				 }
				 else {
					 cfw.add(ByteCode.DSUB);
				 }
				 if (!post) {
					 cfw.add(ByteCode.DUP2);
				 }
				 cfw.addDStore(reg + offset);
			 }
			 else {
				 boolean post = ((incrDecrMask & Node.POST_FLAG) != 0);
				 int varIndex = fnCurrent.getVarIndex(child);
				 short reg = varRegisters[varIndex];
				 cfw.addALoad(reg);
				 if (post) {
					 cfw.add(ByteCode.DUP);
				 }
				 addObjectToDouble();
				 cfw.addPush(1.0);
				 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
					 cfw.add(ByteCode.DADD);
				 }
				 else {
					 cfw.add(ByteCode.DSUB);
				 }
				 addDoubleWrap();
				 if (!post) {
					 cfw.add(ByteCode.DUP);
				 }
				 cfw.addAStore(reg);
				 break;
			 }
			 break;
			 case Token.NAME: cfw.addALoad(variableObjectLocal);
			 cfw.addPush(child.getString());
			 cfw.addALoad(contextLocal);
			 cfw.addPush(incrDecrMask);
			 addScriptRuntimeInvoke(""nameIncrDecr"", ""(Lorg/mozilla/javascript/Scriptable;
			"" +""Ljava/lang/String;
			"" +""Lorg/mozilla/javascript/Context;
			"" +""I)Ljava/lang/Object;
			"");
			 break;
			 case Token.GETPROP: {
				 Node getPropChild = child.getFirstChild();
				 generateExpression(getPropChild, node);
				 generateExpression(getPropChild.getNext(), node);
				 cfw.addALoad(contextLocal);
				 cfw.addPush(incrDecrMask);
				 addScriptRuntimeInvoke(""propIncrDecr"", ""(Ljava/lang/Object;
				"" +""Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""I)Ljava/lang/Object;
				"");
				 break;
			 }
			 case Token.GETELEM: {
				 Node elemChild = child.getFirstChild();
				 generateExpression(elemChild, node);
				 generateExpression(elemChild.getNext(), node);
				 cfw.addALoad(contextLocal);
				 cfw.addPush(incrDecrMask);
				 if (elemChild.getNext().getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
					 addOptRuntimeInvoke(""elemIncrDecr"", ""(Ljava/lang/Object;
					"" +""D"" +""Lorg/mozilla/javascript/Context;
					"" +""I"" +"")Ljava/lang/Object;
					"");
				 }
				 else {
					 addScriptRuntimeInvoke(""elemIncrDecr"", ""(Ljava/lang/Object;
					"" +""Ljava/lang/Object;
					"" +""Lorg/mozilla/javascript/Context;
					"" +""I"" +"")Ljava/lang/Object;
					"");
				 }
				 break;
			 }
			 case Token.GET_REF: {
				 Node refChild = child.getFirstChild();
				 generateExpression(refChild, node);
				 cfw.addALoad(contextLocal);
				 cfw.addPush(incrDecrMask);
				 addScriptRuntimeInvoke( ""refIncrDecr"", ""(Lorg/mozilla/javascript/Ref;
				"" +""Lorg/mozilla/javascript/Context;
				"" +""I)Ljava/lang/Object;
				"");
				 break;
			 }
			 default: Codegen.badTree();
		 }
	 }
	 private static boolean isArithmeticNode(Node node) {
		 int type = node.getType();
		 return (type == Token.SUB) || (type == Token.MOD) || (type == Token.DIV) || (type == Token.MUL);
	 }
	 private void visitArithmetic(Node node, int opCode, Node child, Node parent) {
		 int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
		 if (childNumberFlag != -1) {
			 generateExpression(child, node);
			 generateExpression(child.getNext(), node);
			 cfw.add(opCode);
		 }
		 else {
			 boolean childOfArithmetic = isArithmeticNode(parent);
			 generateExpression(child, node);
			 if (!isArithmeticNode(child)) addObjectToDouble();
			 generateExpression(child.getNext(), node);
			 if (!isArithmeticNode(child.getNext())) addObjectToDouble();
			 cfw.add(opCode);
			 if (!childOfArithmetic) {
				 addDoubleWrap();
			 }
		 }
	 }
	 private void visitBitOp(Node node, int type, Node child) {
		 int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
		 generateExpression(child, node);
		 if (type == Token.URSH) {
			 addScriptRuntimeInvoke(""toUint32"", ""(Ljava/lang/Object;
			)J"");
			 generateExpression(child.getNext(), node);
			 addScriptRuntimeInvoke(""toInt32"", ""(Ljava/lang/Object;
			)I"");
			 cfw.addPush(31);
			 cfw.add(ByteCode.IAND);
			 cfw.add(ByteCode.LUSHR);
			 cfw.add(ByteCode.L2D);
			 addDoubleWrap();
			 return;
		 }
		 if (childNumberFlag == -1) {
			 addScriptRuntimeInvoke(""toInt32"", ""(Ljava/lang/Object;
			)I"");
			 generateExpression(child.getNext(), node);
			 addScriptRuntimeInvoke(""toInt32"", ""(Ljava/lang/Object;
			)I"");
		 }
		 else {
			 addScriptRuntimeInvoke(""toInt32"", ""(D)I"");
			 generateExpression(child.getNext(), node);
			 addScriptRuntimeInvoke(""toInt32"", ""(D)I"");
		 }
		 switch (type) {
			 case Token.BITOR: cfw.add(ByteCode.IOR);
			 break;
			 case Token.BITXOR: cfw.add(ByteCode.IXOR);
			 break;
			 case Token.BITAND: cfw.add(ByteCode.IAND);
			 break;
			 case Token.RSH: cfw.add(ByteCode.ISHR);
			 break;
			 case Token.LSH: cfw.add(ByteCode.ISHL);
			 break;
			 default: throw Codegen.badTree();
		 }
		 cfw.add(ByteCode.I2D);
		 if (childNumberFlag == -1) {
			 addDoubleWrap();
		 }
	 }
	 private int nodeIsDirectCallParameter(Node node) {
		 if (node.getType() == Token.GETVAR && inDirectCallFunction && !itsForcedObjectParameters) {
			 int varIndex = fnCurrent.getVarIndex(node);
			 if (fnCurrent.isParameter(varIndex)) {
				 return varRegisters[varIndex];
			 }
		 }
		 return -1;
	 }
	 private boolean varIsDirectCallParameter(int varIndex) {
		 return fnCurrent.isParameter(varIndex) && inDirectCallFunction && !itsForcedObjectParameters;
	 }
	 private void genSimpleCompare(int type, int trueGOTO, int falseGOTO) {
		 if (trueGOTO == -1) throw Codegen.badTree();
		 switch (type) {
			 case Token.LE : cfw.add(ByteCode.DCMPG);
			 cfw.add(ByteCode.IFLE, trueGOTO);
			 break;
			 case Token.GE : cfw.add(ByteCode.DCMPL);
			 cfw.add(ByteCode.IFGE, trueGOTO);
			 break;
			 case Token.LT : cfw.add(ByteCode.DCMPG);
			 cfw.add(ByteCode.IFLT, trueGOTO);
			 break;
			 case Token.GT : cfw.add(ByteCode.DCMPL);
			 cfw.add(ByteCode.IFGT, trueGOTO);
			 break;
			 default : throw Codegen.badTree();
		 }
		 if (falseGOTO != -1) cfw.add(ByteCode.GOTO, falseGOTO);
	 }
	 private void visitIfJumpRelOp(Node node, Node child, int trueGOTO, int falseGOTO) {
		 if (trueGOTO == -1 || falseGOTO == -1) throw Codegen.badTree();
		 int type = node.getType();
		 Node rChild = child.getNext();
		 if (type == Token.INSTANCEOF || type == Token.IN) {
			 generateExpression(child, node);
			 generateExpression(rChild, node);
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke( (type == Token.INSTANCEOF) ? ""instanceOf"" : ""in"", ""(Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Z"");
			 cfw.add(ByteCode.IFNE, trueGOTO);
			 cfw.add(ByteCode.GOTO, falseGOTO);
			 return;
		 }
		 int childNumberFlag = node.getIntProp(Node.ISNUMBER_PROP, -1);
		 int left_dcp_register = nodeIsDirectCallParameter(child);
		 int right_dcp_register = nodeIsDirectCallParameter(rChild);
		 if (childNumberFlag != -1) {
			 if (childNumberFlag != Node.RIGHT) {
				 generateExpression(child, node);
			 }
			 else if (left_dcp_register != -1) {
				 dcpLoadAsNumber(left_dcp_register);
			 }
			 else {
				 generateExpression(child, node);
				 addObjectToDouble();
			 }
			 if (childNumberFlag != Node.LEFT) {
				 generateExpression(rChild, node);
			 }
			 else if (right_dcp_register != -1) {
				 dcpLoadAsNumber(right_dcp_register);
			 }
			 else {
				 generateExpression(rChild, node);
				 addObjectToDouble();
			 }
			 genSimpleCompare(type, trueGOTO, falseGOTO);
		 }
		 else {
			 if (left_dcp_register != -1 && right_dcp_register != -1) {
				 short stack = cfw.getStackTop();
				 int leftIsNotNumber = cfw.acquireLabel();
				 cfw.addALoad(left_dcp_register);
				 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
				"");
				 cfw.add(ByteCode.IF_ACMPNE, leftIsNotNumber);
				 cfw.addDLoad(left_dcp_register + 1);
				 dcpLoadAsNumber(right_dcp_register);
				 genSimpleCompare(type, trueGOTO, falseGOTO);
				 if (stack != cfw.getStackTop()) throw Codegen.badTree();
				 cfw.markLabel(leftIsNotNumber);
				 int rightIsNotNumber = cfw.acquireLabel();
				 cfw.addALoad(right_dcp_register);
				 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
				"");
				 cfw.add(ByteCode.IF_ACMPNE, rightIsNotNumber);
				 cfw.addALoad(left_dcp_register);
				 addObjectToDouble();
				 cfw.addDLoad(right_dcp_register + 1);
				 genSimpleCompare(type, trueGOTO, falseGOTO);
				 if (stack != cfw.getStackTop()) throw Codegen.badTree();
				 cfw.markLabel(rightIsNotNumber);
				 cfw.addALoad(left_dcp_register);
				 cfw.addALoad(right_dcp_register);
			 }
			 else {
				 generateExpression(child, node);
				 generateExpression(rChild, node);
			 }
			 if (type == Token.GE || type == Token.GT) {
				 cfw.add(ByteCode.SWAP);
			 }
			 String routine = ((type == Token.LT) || (type == Token.GT)) ? ""cmp_LT"" : ""cmp_LE"";
			 addScriptRuntimeInvoke(routine, ""(Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +"")Z"");
			 cfw.add(ByteCode.IFNE, trueGOTO);
			 cfw.add(ByteCode.GOTO, falseGOTO);
		 }
	 }
	 private void visitIfJumpEqOp(Node node, Node child, int trueGOTO, int falseGOTO) {
		 if (trueGOTO == -1 || falseGOTO == -1) throw Codegen.badTree();
		 short stackInitial = cfw.getStackTop();
		 int type = node.getType();
		 Node rChild = child.getNext();
		 if (child.getType() == Token.NULL || rChild.getType() == Token.NULL) {
			 if (child.getType() == Token.NULL) {
				 child = rChild;
			 }
			 generateExpression(child, node);
			 if (type == Token.SHEQ || type == Token.SHNE) {
				 int testCode = (type == Token.SHEQ) ? ByteCode.IFNULL : ByteCode.IFNONNULL;
				 cfw.add(testCode, trueGOTO);
			 }
			 else {
				 if (type != Token.EQ) {
					 if (type != Token.NE) throw Codegen.badTree();
					 int tmp = trueGOTO;
					 trueGOTO = falseGOTO;
					 falseGOTO = tmp;
				 }
				 cfw.add(ByteCode.DUP);
				 int undefCheckLabel = cfw.acquireLabel();
				 cfw.add(ByteCode.IFNONNULL, undefCheckLabel);
				 short stack = cfw.getStackTop();
				 cfw.add(ByteCode.POP);
				 cfw.add(ByteCode.GOTO, trueGOTO);
				 cfw.markLabel(undefCheckLabel, stack);
				 Codegen.pushUndefined(cfw);
				 cfw.add(ByteCode.IF_ACMPEQ, trueGOTO);
			 }
			 cfw.add(ByteCode.GOTO, falseGOTO);
		 }
		 else {
			 int child_dcp_register = nodeIsDirectCallParameter(child);
			 if (child_dcp_register != -1 && rChild.getType() == Token.TO_OBJECT) {
				 Node convertChild = rChild.getFirstChild();
				 if (convertChild.getType() == Token.NUMBER) {
					 cfw.addALoad(child_dcp_register);
					 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
					"");
					 int notNumbersLabel = cfw.acquireLabel();
					 cfw.add(ByteCode.IF_ACMPNE, notNumbersLabel);
					 cfw.addDLoad(child_dcp_register + 1);
					 cfw.addPush(convertChild.getDouble());
					 cfw.add(ByteCode.DCMPL);
					 if (type == Token.EQ) cfw.add(ByteCode.IFEQ, trueGOTO);
					 else cfw.add(ByteCode.IFNE, trueGOTO);
					 cfw.add(ByteCode.GOTO, falseGOTO);
					 cfw.markLabel(notNumbersLabel);
				 }
			 }
			 generateExpression(child, node);
			 generateExpression(rChild, node);
			 String name;
			 int testCode;
			 switch (type) {
				 case Token.EQ: name = ""eq"";
				 testCode = ByteCode.IFNE;
				 break;
				 case Token.NE: name = ""eq"";
				 testCode = ByteCode.IFEQ;
				 break;
				 case Token.SHEQ: name = ""shallowEq"";
				 testCode = ByteCode.IFNE;
				 break;
				 case Token.SHNE: name = ""shallowEq"";
				 testCode = ByteCode.IFEQ;
				 break;
				 default: throw Codegen.badTree();
			 }
			 addScriptRuntimeInvoke(name, ""(Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +"")Z"");
			 cfw.add(testCode, trueGOTO);
			 cfw.add(ByteCode.GOTO, falseGOTO);
		 }
		 if (stackInitial != cfw.getStackTop()) throw Codegen.badTree();
	 }
	 private void visitSetName(Node node, Node child) {
		 String name = node.getFirstChild().getString();
		 while (child != null) {
			 generateExpression(child, node);
			 child = child.getNext();
		 }
		 cfw.addALoad(contextLocal);
		 cfw.addALoad(variableObjectLocal);
		 cfw.addPush(name);
		 addScriptRuntimeInvoke( ""setName"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/Object;
		"" +""Lorg/mozilla/javascript/Context;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/String;
		"" +"")Ljava/lang/Object;
		"");
	 }
	 private void visitSetConst(Node node, Node child) {
		 String name = node.getFirstChild().getString();
		 while (child != null) {
			 generateExpression(child, node);
			 child = child.getNext();
		 }
		 cfw.addALoad(contextLocal);
		 cfw.addPush(name);
		 addScriptRuntimeInvoke( ""setConst"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +""Ljava/lang/Object;
		"" +""Lorg/mozilla/javascript/Context;
		"" +""Ljava/lang/String;
		"" +"")Ljava/lang/Object;
		"");
	 }
	 private void visitGetVar(Node node) {
		 if (!hasVarsInRegs) Kit.codeBug();
		 int varIndex = fnCurrent.getVarIndex(node);
		 short reg = varRegisters[varIndex];
		 if (varIsDirectCallParameter(varIndex)) {
			 if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) {
				 dcpLoadAsNumber(reg);
			 }
			 else {
				 dcpLoadAsObject(reg);
			 }
		 }
		 else if (fnCurrent.isNumberVar(varIndex)) {
			 cfw.addDLoad(reg);
		 }
		 else {
			 cfw.addALoad(reg);
		 }
	 }
	 private void visitSetVar(Node node, Node child, boolean needValue) {
		 if (!hasVarsInRegs) Kit.codeBug();
		 int varIndex = fnCurrent.getVarIndex(node);
		 generateExpression(child.getNext(), node);
		 boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);
		 short reg = varRegisters[varIndex];
		 boolean [] constDeclarations = fnCurrent.fnode.getParamAndVarConst();
		 if (constDeclarations[varIndex]) {
			 if (!needValue) {
				 if (isNumber) cfw.add(ByteCode.POP2);
				 else cfw.add(ByteCode.POP);
			 }
		 }
		 else if (varIsDirectCallParameter(varIndex)) {
			 if (isNumber) {
				 if (needValue) cfw.add(ByteCode.DUP2);
				 cfw.addALoad(reg);
				 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
				"");
				 int isNumberLabel = cfw.acquireLabel();
				 int beyond = cfw.acquireLabel();
				 cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);
				 short stack = cfw.getStackTop();
				 addDoubleWrap();
				 cfw.addAStore(reg);
				 cfw.add(ByteCode.GOTO, beyond);
				 cfw.markLabel(isNumberLabel, stack);
				 cfw.addDStore(reg + 1);
				 cfw.markLabel(beyond);
			 }
			 else {
				 if (needValue) cfw.add(ByteCode.DUP);
				 cfw.addAStore(reg);
			 }
		 }
		 else {
			 if (isNumber) {
				 cfw.addDStore(reg);
				 if (needValue) cfw.addDLoad(reg);
			 }
			 else {
				 cfw.addAStore(reg);
				 if (needValue) cfw.addALoad(reg);
			 }
		 }
	 }
	 private void visitSetConstVar(Node node, Node child, boolean needValue) {
		 if (!hasVarsInRegs) Kit.codeBug();
		 int varIndex = fnCurrent.getVarIndex(node);
		 generateExpression(child.getNext(), node);
		 boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);
		 short reg = varRegisters[varIndex];
		 int beyond = cfw.acquireLabel();
		 int noAssign = cfw.acquireLabel();
		 if (isNumber) {
			 cfw.addILoad(reg + 2);
			 cfw.add(ByteCode.IFNE, noAssign);
			 short stack = cfw.getStackTop();
			 cfw.addPush(1);
			 cfw.addIStore(reg + 2);
			 cfw.addDStore(reg);
			 if (needValue) {
				 cfw.addDLoad(reg);
				 cfw.markLabel(noAssign, stack);
			 }
			 else {
				 cfw.add(ByteCode.GOTO, beyond);
				 cfw.markLabel(noAssign, stack);
				 cfw.add(ByteCode.POP2);
			 }
		 }
		 else {
			 cfw.addILoad(reg + 1);
			 cfw.add(ByteCode.IFNE, noAssign);
			 short stack = cfw.getStackTop();
			 cfw.addPush(1);
			 cfw.addIStore(reg + 1);
			 cfw.addAStore(reg);
			 if (needValue) {
				 cfw.addALoad(reg);
				 cfw.markLabel(noAssign, stack);
			 }
			 else {
				 cfw.add(ByteCode.GOTO, beyond);
				 cfw.markLabel(noAssign, stack);
				 cfw.add(ByteCode.POP);
			 }
		 }
		 cfw.markLabel(beyond);
	 }
	 private void visitGetProp(Node node, Node child) {
		 generateExpression(child, node);
		 Node nameChild = child.getNext();
		 generateExpression(nameChild, node);
		 int childType = child.getType();
		 if (childType == Token.THIS && nameChild.getType() == Token.STRING) {
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke( ""getObjectProp"", ""(Lorg/mozilla/javascript/Scriptable;
			"" +""Ljava/lang/String;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
		 }
		 else {
			 cfw.addALoad(contextLocal);
			 addScriptRuntimeInvoke( ""getObjectProp"", ""(Ljava/lang/Object;
			"" +""Ljava/lang/String;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
		 }
	 }
	 private void visitSetProp(int type, Node node, Node child) {
		 Node objectChild = child;
		 generateExpression(child, node);
		 child = child.getNext();
		 if (type == Token.SETPROP_OP) {
			 cfw.add(ByteCode.DUP);
		 }
		 Node nameChild = child;
		 generateExpression(child, node);
		 child = child.getNext();
		 if (type == Token.SETPROP_OP) {
			 cfw.add(ByteCode.DUP_X1);
			 if (objectChild.getType() == Token.THIS && nameChild.getType() == Token.STRING) {
				 cfw.addALoad(contextLocal);
				 addScriptRuntimeInvoke( ""getObjectProp"", ""(Lorg/mozilla/javascript/Scriptable;
				"" +""Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 else {
				 cfw.addALoad(contextLocal);
				 addScriptRuntimeInvoke( ""getObjectProp"", ""(Ljava/lang/Object;
				"" +""Ljava/lang/String;
				"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
		 }
		 generateExpression(child, node);
		 cfw.addALoad(contextLocal);
		 addScriptRuntimeInvoke( ""setObjectProp"", ""(Ljava/lang/Object;
		"" +""Ljava/lang/String;
		"" +""Ljava/lang/Object;
		"" +""Lorg/mozilla/javascript/Context;
		"" +"")Ljava/lang/Object;
		"");
	 }
	 private void visitSetElem(int type, Node node, Node child) {
		 generateExpression(child, node);
		 child = child.getNext();
		 if (type == Token.SETELEM_OP) {
			 cfw.add(ByteCode.DUP);
		 }
		 generateExpression(child, node);
		 child = child.getNext();
		 boolean indexIsNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1);
		 if (type == Token.SETELEM_OP) {
			 if (indexIsNumber) {
				 cfw.add(ByteCode.DUP2_X1);
				 cfw.addALoad(contextLocal);
				 addOptRuntimeInvoke( ""getObjectIndex"", ""(Ljava/lang/Object;
				D"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
			 else {
				 cfw.add(ByteCode.DUP_X1);
				 cfw.addALoad(contextLocal);
				 addScriptRuntimeInvoke( ""getObjectElem"", ""(Ljava/lang/Object;
				"" +""Ljava/lang/Object;
				"" +""Lorg/mozilla/javascript/Context;
				"" +"")Ljava/lang/Object;
				"");
			 }
		 }
		 generateExpression(child, node);
		 cfw.addALoad(contextLocal);
		 if (indexIsNumber) {
			 addScriptRuntimeInvoke( ""setObjectIndex"", ""(Ljava/lang/Object;
			"" +""D"" +""Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
		 }
		 else {
			 addScriptRuntimeInvoke( ""setObjectElem"", ""(Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +""Ljava/lang/Object;
			"" +""Lorg/mozilla/javascript/Context;
			"" +"")Ljava/lang/Object;
			"");
		 }
	 }
	 private void visitDotQuery(Node node, Node child) {
		 updateLineNumber(node);
		 generateExpression(child, node);
		 cfw.addALoad(variableObjectLocal);
		 addScriptRuntimeInvoke(""enterDotQuery"", ""(Ljava/lang/Object;
		"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.addAStore(variableObjectLocal);
		 cfw.add(ByteCode.ACONST_NULL);
		 int queryLoopStart = cfw.acquireLabel();
		 cfw.markLabel(queryLoopStart);
		 cfw.add(ByteCode.POP);
		 generateExpression(child.getNext(), node);
		 addScriptRuntimeInvoke(""toBoolean"", ""(Ljava/lang/Object;
		)Z"");
		 cfw.addALoad(variableObjectLocal);
		 addScriptRuntimeInvoke(""updateDotQuery"", ""(Z"" +""Lorg/mozilla/javascript/Scriptable;
		"" +"")Ljava/lang/Object;
		"");
		 cfw.add(ByteCode.DUP);
		 cfw.add(ByteCode.IFNULL, queryLoopStart);
		 cfw.addALoad(variableObjectLocal);
		 addScriptRuntimeInvoke(""leaveDotQuery"", ""(Lorg/mozilla/javascript/Scriptable;
		"" +"")Lorg/mozilla/javascript/Scriptable;
		"");
		 cfw.addAStore(variableObjectLocal);
	 }
	 private int getLocalBlockRegister(Node node) {
		 Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
		 int localSlot = localBlock.getExistingIntProp(Node.LOCAL_PROP);
		 return localSlot;
	 }
	 private void dcpLoadAsNumber(int dcp_register) {
		 cfw.addALoad(dcp_register);
		 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
		"");
		 int isNumberLabel = cfw.acquireLabel();
		 cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);
		 short stack = cfw.getStackTop();
		 cfw.addALoad(dcp_register);
		 addObjectToDouble();
		 int beyond = cfw.acquireLabel();
		 cfw.add(ByteCode.GOTO, beyond);
		 cfw.markLabel(isNumberLabel, stack);
		 cfw.addDLoad(dcp_register + 1);
		 cfw.markLabel(beyond);
	 }
	 private void dcpLoadAsObject(int dcp_register) {
		 cfw.addALoad(dcp_register);
		 cfw.add(ByteCode.GETSTATIC, ""java/lang/Void"", ""TYPE"", ""Ljava/lang/Class;
		"");
		 int isNumberLabel = cfw.acquireLabel();
		 cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel);
		 short stack = cfw.getStackTop();
		 cfw.addALoad(dcp_register);
		 int beyond = cfw.acquireLabel();
		 cfw.add(ByteCode.GOTO, beyond);
		 cfw.markLabel(isNumberLabel, stack);
		 cfw.addDLoad(dcp_register + 1);
		 addDoubleWrap();
		 cfw.markLabel(beyond);
	 }
	 private void addGoto(Node target, int jumpcode) {
		 int targetLabel = getTargetLabel(target);
		 cfw.add(jumpcode, targetLabel);
	 }
	 private void addObjectToDouble() {
		 addScriptRuntimeInvoke(""toNumber"", ""(Ljava/lang/Object;
		)D"");
	 }
	 private void addNewObjectArray(int size) {
		 if (size == 0) {
			 if (itsZeroArgArray >= 0) {
				 cfw.addALoad(itsZeroArgArray);
			 }
			 else {
				 cfw.add(ByteCode.GETSTATIC, ""org/mozilla/javascript/ScriptRuntime"", ""emptyArgs"", ""[Ljava/lang/Object;
				"");
			 }
		 }
		 else {
			 cfw.addPush(size);
			 cfw.add(ByteCode.ANEWARRAY, ""java/lang/Object"");
		 }
	 }
	 private void addScriptRuntimeInvoke(String methodName, String methodSignature) {
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org.mozilla.javascript.ScriptRuntime"", methodName, methodSignature);
	 }
	 private void addOptRuntimeInvoke(String methodName, String methodSignature) {
		 cfw.addInvoke(ByteCode.INVOKESTATIC, ""org/mozilla/javascript/optimizer/OptRuntime"", methodName, methodSignature);
	 }
	 private void addJumpedBooleanWrap(int trueLabel, int falseLabel) {
		 cfw.markLabel(falseLabel);
		 int skip = cfw.acquireLabel();
		 cfw.add(ByteCode.GETSTATIC, ""java/lang/Boolean"", ""FALSE"", ""Ljava/lang/Boolean;
		"");
		 cfw.add(ByteCode.GOTO, skip);
		 cfw.markLabel(trueLabel);
		 cfw.add(ByteCode.GETSTATIC, ""java/lang/Boolean"", ""TRUE"", ""Ljava/lang/Boolean;
		"");
		 cfw.markLabel(skip);
		 cfw.adjustStackTop(-1);
	 }
	 private void addDoubleWrap() {
		 addOptRuntimeInvoke(""wrapDouble"", ""(D)Ljava/lang/Double;
		"");
	 }
	 private short getNewWordPairLocal(boolean isConst) {
		 short result = getConsecutiveSlots(2, isConst);
		 if (result < (MAX_LOCALS - 1)) {
			 locals[result] = true;
			 locals[result + 1] = true;
			 if (isConst) locals[result + 2] = true;
			 if (result == firstFreeLocal) {
				 for (int i = firstFreeLocal + 2;
				 i < MAX_LOCALS;
				 i++) {
					 if (!locals[i]) {
						 firstFreeLocal = (short) i;
						 if (localsMax < firstFreeLocal) localsMax = firstFreeLocal;
						 return result;
					 }
				 }
			 }
			 else {
				 return result;
			 }
		 }
		 throw Context.reportRuntimeError(""Program too complex "" + ""(out of locals)"");
	 }
	 private short getNewWordLocal(boolean isConst) {
		 short result = getConsecutiveSlots(1, isConst);
		 if (result < (MAX_LOCALS - 1)) {
			 locals[result] = true;
			 if (isConst) locals[result + 1] = true;
			 if (result == firstFreeLocal) {
				 for (int i = firstFreeLocal + 1;
				 i < MAX_LOCALS;
				 i++) {
					 if (!locals[i]) {
						 firstFreeLocal = (short) i;
						 if (localsMax < firstFreeLocal) localsMax = firstFreeLocal;
						 return result;
					 }
				 }
			 }
			 else {
				 return result;
			 }
		 }
		 throw Context.reportRuntimeError(""Program too complex "" + ""(out of locals)"");
	 }
	 private short getNewWordLocal() {
		 short result = firstFreeLocal;
		 locals[result] = true;
		 for (int i = firstFreeLocal + 1;
		 i < MAX_LOCALS;
		 i++) {
			 if (!locals[i]) {
				 firstFreeLocal = (short) i;
				 if (localsMax < firstFreeLocal) localsMax = firstFreeLocal;
				 return result;
			 }
		 }
		 throw Context.reportRuntimeError(""Program too complex "" + ""(out of locals)"");
	 }
	 private short getConsecutiveSlots(int count, boolean isConst) {
		 if (isConst) count++;
		 short result = firstFreeLocal;
		 while (true) {
			 if (result >= (MAX_LOCALS - 1)) break;
			 int i;
			 for (i = 0;
			 i < count;
			 i++) if (locals[result + i]) break;
			 if (i >= count) break;
			 result++;
		 }
		 return result;
	 }
	 private void releaseWordLocal(short local) {
		 if (local < firstFreeLocal) firstFreeLocal = local;
		 locals[local] = false;
	 }
	 ClassFileWriter cfw;
	 Codegen codegen;
	 CompilerEnvirons compilerEnv;
	 ScriptOrFnNode scriptOrFn;
	 private OptFunctionNode fnCurrent;
	 private boolean isTopLevel;
	 private static final int MAX_LOCALS = 256;
	 private boolean[] locals;
	 private short firstFreeLocal;
	 private short localsMax;
	 private int itsLineNumber;
	 private boolean hasVarsInRegs;
	 private short[] varRegisters;
	 private boolean inDirectCallFunction;
	 private boolean itsForcedObjectParameters;
	 private int enterAreaStartLabel;
	 private int epilogueLabel;
	 private short variableObjectLocal;
	 private short popvLocal;
	 private short contextLocal;
	 private short argsLocal;
	 private short thisObjLocal;
	 private short funObjLocal;
	 private short itsZeroArgArray;
	 private short itsOneArgArray;
	 private short scriptRegexpLocal;
}",0,0,0,0
"Base class for native object implementation that uses IdFunctionObject to export its methods to script via <class-name>.prototype object.Any descendant should implement at least the following methods: findInstanceIdInfo getInstanceIdName execIdCall methodArityTo define non-function properties, the descendant should override getInstanceIdValue setInstanceIdValueto get/set property value and provide its default attributes.To customize initializition of constructor and protype objects, descendantmay override scopeInit or fillConstructorProperties methods.public abstract class IdScriptableObject extends ScriptableObject implements IdFunctionCall{
	 private transient volatile PrototypeValues prototypeValues;
	 private static final class PrototypeValues implements Serializable {
		 static final long serialVersionUID = 3038645279153854371L;
		 private static final int VALUE_SLOT = 0;
		 private static final int NAME_SLOT = 1;
		 private static final int SLOT_SPAN = 2;
		 private IdScriptableObject obj;
		 private Object tag;
		 private int maxId;
		 private volatile Object[] valueArray;
		 private volatile short[] attributeArray;
		 private volatile int lastFoundId = 1;
		 int constructorId;
		 private IdFunctionObject constructor;
		 private short constructorAttrs;
		 PrototypeValues(IdScriptableObject obj, int maxId) {
			 if (obj == null) throw new IllegalArgumentException();
			 if (maxId < 1) throw new IllegalArgumentException();
			 this.obj = obj;
			 this.maxId = maxId;
		 }
		 final int getMaxId() {
			 return maxId;
		 }
		 final void initValue(int id, String name, Object value, int attributes) {
			 if (!(1 <= id && id <= maxId)) throw new IllegalArgumentException();
			 if (name == null) throw new IllegalArgumentException();
			 if (value == NOT_FOUND) throw new IllegalArgumentException();
			 ScriptableObject.checkValidAttributes(attributes);
			 if (obj.findPrototypeId(name) != id) throw new IllegalArgumentException(name);
			 if (id == constructorId) {
				 if (!(value instanceof IdFunctionObject)) {
					 throw new IllegalArgumentException(""consructor should be initialized with IdFunctionObject"");
				 }
				 constructor = (IdFunctionObject)value;
				 constructorAttrs = (short)attributes;
				 return;
			 }
			 initSlot(id, name, value, attributes);
		 }
		 private void initSlot(int id, String name, Object value, int attributes) {
			 Object[] array = valueArray;
			 if (array == null) throw new IllegalStateException();
			 if (value == null) {
				 value = UniqueTag.NULL_VALUE;
			 }
			 int index = (id - 1) * SLOT_SPAN;
			 synchronized (this) {
				 Object value2 = array[index + VALUE_SLOT];
				 if (value2 == null) {
					 array[index + VALUE_SLOT] = value;
					 array[index + NAME_SLOT] = name;
					 attributeArray[id - 1] = (short)attributes;
				 }
				 else {
					 if (!name.equals(array[index + NAME_SLOT])) throw new IllegalStateException();
				 }
			 }
		 }
		 final IdFunctionObject createPrecachedConstructor() {
			 if (constructorId != 0) throw new IllegalStateException();
			 constructorId = obj.findPrototypeId(""constructor"");
			 if (constructorId == 0) {
				 throw new IllegalStateException( ""No id for constructor property"");
			 }
			 obj.initPrototypeId(constructorId);
			 if (constructor == null) {
				 throw new IllegalStateException( obj.getClass().getName()+"".initPrototypeId() did not "" +""initialize id=""+constructorId);
			 }
			 constructor.initFunction(obj.getClassName(), ScriptableObject.getTopLevelScope(obj));
			 constructor.markAsConstructor(obj);
			 return constructor;
		 }
		 final int findId(String name) {
			 Object[] array = valueArray;
			 if (array == null) {
				 return obj.findPrototypeId(name);
			 }
			 int id = lastFoundId;
			 if (name == array[(id - 1) * SLOT_SPAN + NAME_SLOT]) {
				 return id;
			 }
			 id = obj.findPrototypeId(name);
			 if (id != 0) {
				 int nameSlot = (id - 1) * SLOT_SPAN + NAME_SLOT;
				 array[nameSlot] = name;
				 lastFoundId = id;
			 }
			 return id;
		 }
		 final boolean has(int id) {
			 Object[] array = valueArray;
			 if (array == null) {
				 return true;
			 }
			 int valueSlot = (id - 1) * SLOT_SPAN + VALUE_SLOT;
			 Object value = array[valueSlot];
			 if (value == null) {
				 return true;
			 }
			 return value != NOT_FOUND;
		 }
		 final Object get(int id) {
			 Object value = ensureId(id);
			 if (value == UniqueTag.NULL_VALUE) {
				 value = null;
			 }
			 return value;
		 }
		 final void set(int id, Scriptable start, Object value) {
			 if (value == NOT_FOUND) throw new IllegalArgumentException();
			 ensureId(id);
			 int attr = attributeArray[id - 1];
			 if ((attr & READONLY) == 0) {
				 if (start == obj) {
					 if (value == null) {
						 value = UniqueTag.NULL_VALUE;
					 }
					 int valueSlot = (id - 1) * SLOT_SPAN + VALUE_SLOT;
					 synchronized (this) {
						 valueArray[valueSlot] = value;
					 }
				 }
				 else {
					 int nameSlot = (id - 1) * SLOT_SPAN + NAME_SLOT;
					 String name = (String)valueArray[nameSlot];
					 start.put(name, start, value);
				 }
			 }
		 }
		 final void delete(int id) {
			 ensureId(id);
			 int attr = attributeArray[id - 1];
			 if ((attr & PERMANENT) == 0) {
				 int valueSlot = (id - 1) * SLOT_SPAN + VALUE_SLOT;
				 synchronized (this) {
					 valueArray[valueSlot] = NOT_FOUND;
					 attributeArray[id - 1] = EMPTY;
				 }
			 }
		 }
		 final int getAttributes(int id) {
			 ensureId(id);
			 return attributeArray[id - 1];
		 }
		 final void setAttributes(int id, int attributes) {
			 ScriptableObject.checkValidAttributes(attributes);
			 ensureId(id);
			 synchronized (this) {
				 attributeArray[id - 1] = (short)attributes;
			 }
		 }
		 final Object[] getNames(boolean getAll, Object[] extraEntries) {
			 Object[] names = null;
			 int count = 0;
			 for (int id = 1;
			 id <= maxId;
			 ++id) {
				 Object value = ensureId(id);
				 if (getAll || (attributeArray[id - 1] & DONTENUM) == 0) {
					 if (value != NOT_FOUND) {
						 int nameSlot = (id - 1) * SLOT_SPAN + NAME_SLOT;
						 String name = (String)valueArray[nameSlot];
						 if (names == null) {
							 names = new Object[maxId];
						 }
						 names[count++] = name;
					 }
				 }
			 }
			 if (count == 0) {
				 return extraEntries;
			 }
			 else if (extraEntries == null || extraEntries.length == 0) {
				 if (count != names.length) {
					 Object[] tmp = new Object[count];
					 System.arraycopy(names, 0, tmp, 0, count);
					 names = tmp;
				 }
				 return names;
			 }
			 else {
				 int extra = extraEntries.length;
				 Object[] tmp = new Object[extra + count];
				 System.arraycopy(extraEntries, 0, tmp, 0, extra);
				 System.arraycopy(names, 0, tmp, extra, count);
				 return tmp;
			 }
		 }
		 private Object ensureId(int id) {
			 Object[] array = valueArray;
			 if (array == null) {
				 synchronized (this) {
					 array = valueArray;
					 if (array == null) {
						 array = new Object[maxId * SLOT_SPAN];
						 valueArray = array;
						 attributeArray = new short[maxId];
					 }
				 }
			 }
			 int valueSlot = (id - 1) * SLOT_SPAN + VALUE_SLOT;
			 Object value = array[valueSlot];
			 if (value == null) {
				 if (id == constructorId) {
					 initSlot(constructorId, ""constructor"", constructor, constructorAttrs);
					 constructor = null;
				 }
				 else {
					 obj.initPrototypeId(id);
				 }
				 value = array[valueSlot];
				 if (value == null) {
					 throw new IllegalStateException( obj.getClass().getName()+"".initPrototypeId(int id) "" +""did not initialize id=""+id);
				 }
			 }
			 return value;
		 }
	 }
	 public IdScriptableObject() {
	 }
	 public IdScriptableObject(Scriptable scope, Scriptable prototype) {
		 super(scope, prototype);
	 }
	 protected final Object defaultGet(String name) {
		 return super.get(name, this);
	 }
	 protected final void defaultPut(String name, Object value) {
		 super.put(name, this, value);
	 }
	 public boolean has(String name, Scriptable start) {
		 int info = findInstanceIdInfo(name);
		 if (info != 0) {
			 int attr = (info >>> 16);
			 if ((attr & PERMANENT) != 0) {
				 return true;
			 }
			 int id = (info & 0xFFFF);
			 return NOT_FOUND != getInstanceIdValue(id);
		 }
		 if (prototypeValues != null) {
			 int id = prototypeValues.findId(name);
			 if (id != 0) {
				 return prototypeValues.has(id);
			 }
		 }
		 return super.has(name, start);
	 }
	 public Object get(String name, Scriptable start) {
		 int info = findInstanceIdInfo(name);
		 if (info != 0) {
			 int id = (info & 0xFFFF);
			 return getInstanceIdValue(id);
		 }
		 if (prototypeValues != null) {
			 int id = prototypeValues.findId(name);
			 if (id != 0) {
				 return prototypeValues.get(id);
			 }
		 }
		 return super.get(name, start);
	 }
	 public void put(String name, Scriptable start, Object value) {
		 int info = findInstanceIdInfo(name);
		 if (info != 0) {
			 if (start == this && isSealed()) {
				 throw Context.reportRuntimeError1(""msg.modify.sealed"", name);
			 }
			 int attr = (info >>> 16);
			 if ((attr & READONLY) == 0) {
				 if (start == this) {
					 int id = (info & 0xFFFF);
					 setInstanceIdValue(id, value);
				 }
				 else {
					 start.put(name, start, value);
				 }
			 }
			 return;
		 }
		 if (prototypeValues != null) {
			 int id = prototypeValues.findId(name);
			 if (id != 0) {
				 if (start == this && isSealed()) {
					 throw Context.reportRuntimeError1(""msg.modify.sealed"", name);
				 }
				 prototypeValues.set(id, start, value);
				 return;
			 }
		 }
		 super.put(name, start, value);
	 }
	 public void delete(String name) {
		 int info = findInstanceIdInfo(name);
		 if (info != 0) {
			 if (!isSealed()) {
				 int attr = (info >>> 16);
				 if ((attr & PERMANENT) == 0) {
					 int id = (info & 0xFFFF);
					 setInstanceIdValue(id, NOT_FOUND);
				 }
				 return;
			 }
		 }
		 if (prototypeValues != null) {
			 int id = prototypeValues.findId(name);
			 if (id != 0) {
				 if (!isSealed()) {
					 prototypeValues.delete(id);
				 }
				 return;
			 }
		 }
		 super.delete(name);
	 }
	 public int getAttributes(String name) {
		 int info = findInstanceIdInfo(name);
		 if (info != 0) {
			 int attr = (info >>> 16);
			 return attr;
		 }
		 if (prototypeValues != null) {
			 int id = prototypeValues.findId(name);
			 if (id != 0) {
				 return prototypeValues.getAttributes(id);
			 }
		 }
		 return super.getAttributes(name);
	 }
	 public void setAttributes(String name, int attributes) {
		 ScriptableObject.checkValidAttributes(attributes);
		 int info = findInstanceIdInfo(name);
		 if (info != 0) {
			 int currentAttributes = (info >>> 16);
			 if (attributes != currentAttributes) {
				 throw new RuntimeException( ""Change of attributes for this id is not supported"");
			 }
			 return;
		 }
		 if (prototypeValues != null) {
			 int id = prototypeValues.findId(name);
			 if (id != 0) {
				 prototypeValues.setAttributes(id, attributes);
				 return;
			 }
		 }
		 super.setAttributes(name, attributes);
	 }
	 Object[] getIds(boolean getAll) {
		 Object[] result = super.getIds(getAll);
		 if (prototypeValues != null) {
			 result = prototypeValues.getNames(getAll, result);
		 }
		 int maxInstanceId = getMaxInstanceId();
		 if (maxInstanceId != 0) {
			 Object[] ids = null;
			 int count = 0;
			 for (int id = maxInstanceId;
			 id != 0;
			 --id) {
				 String name = getInstanceIdName(id);
				 int info = findInstanceIdInfo(name);
				 if (info != 0) {
					 int attr = (info >>> 16);
					 if ((attr & PERMANENT) == 0) {
						 if (NOT_FOUND == getInstanceIdValue(id)) {
							 continue;
						 }
					 }
					 if (getAll || (attr & DONTENUM) == 0) {
						 if (count == 0) {
							 ids = new Object[id];
						 }
						 ids[count++] = name;
					 }
				 }
			 }
			 if (count != 0) {
				 if (result.length == 0 && ids.length == count) {
					 result = ids;
				 }
				 else {
					 Object[] tmp = new Object[result.length + count];
					 System.arraycopy(result, 0, tmp, 0, result.length);
					 System.arraycopy(ids, 0, tmp, result.length, count);
					 result = tmp;
				 }
			 }
		 }
		 return result;
	 }
	 protected int getMaxInstanceId() {
		 return 0;
	 }
	 protected static int instanceIdInfo(int attributes, int id) {
		 return (attributes << 16) | id;
	 }
	 protected int findInstanceIdInfo(String name) {
		 return 0;
	 }
	 protected String getInstanceIdName(int id) {
		 throw new IllegalArgumentException(String.valueOf(id));
	 }
	 protected Object getInstanceIdValue(int id) {
		 throw new IllegalStateException(String.valueOf(id));
	 }
	 protected void setInstanceIdValue(int id, Object value) {
		 throw new IllegalStateException(String.valueOf(id));
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 throw f.unknown();
	 }
	 public final IdFunctionObject exportAsJSClass(int maxPrototypeId, Scriptable scope, boolean sealed) {
		 if (scope != this && scope != null) {
			 setParentScope(scope);
			 setPrototype(getObjectPrototype(scope));
		 }
		 activatePrototypeMap(maxPrototypeId);
		 IdFunctionObject ctor = prototypeValues.createPrecachedConstructor();
		 if (sealed) {
			 sealObject();
		 }
		 fillConstructorProperties(ctor);
		 if (sealed) {
			 ctor.sealObject();
		 }
		 ctor.exportAsScopeProperty();
		 return ctor;
	 }
	 public final boolean hasPrototypeMap() {
		 return prototypeValues != null;
	 }
	 public final void activatePrototypeMap(int maxPrototypeId) {
		 PrototypeValues values = new PrototypeValues(this, maxPrototypeId);
		 synchronized (this) {
			 if (prototypeValues != null) throw new IllegalStateException();
			 prototypeValues = values;
		 }
	 }
	 public final void initPrototypeMethod(Object tag, int id, String name, int arity) {
		 Scriptable scope = ScriptableObject.getTopLevelScope(this);
		 IdFunctionObject f = newIdFunction(tag, id, name, arity, scope);
		 prototypeValues.initValue(id, name, f, DONTENUM);
	 }
	 public final void initPrototypeConstructor(IdFunctionObject f) {
		 int id = prototypeValues.constructorId;
		 if (id == 0) throw new IllegalStateException();
		 if (f.methodId() != id) throw new IllegalArgumentException();
		 if (isSealed()) {
			 f.sealObject();
		 }
		 prototypeValues.initValue(id, ""constructor"", f, DONTENUM);
	 }
	 public final void initPrototypeValue(int id, String name, Object value, int attributes) {
		 prototypeValues.initValue(id, name, value, attributes);
	 }
	 protected void initPrototypeId(int id) {
		 throw new IllegalStateException(String.valueOf(id));
	 }
	 protected int findPrototypeId(String name) {
		 throw new IllegalStateException(name);
	 }
	 protected void fillConstructorProperties(IdFunctionObject ctor) {
	 }
	 protected void addIdFunctionProperty(Scriptable obj, Object tag, int id, String name, int arity) {
		 Scriptable scope = ScriptableObject.getTopLevelScope(obj);
		 IdFunctionObject f = newIdFunction(tag, id, name, arity, scope);
		 f.addAsProperty(obj);
	 }
	 protected static EcmaError incompatibleCallError(IdFunctionObject f) {
		 throw ScriptRuntime.typeError1(""msg.incompat.call"", f.getFunctionName());
	 }
	 private IdFunctionObject newIdFunction(Object tag, int id, String name, int arity, Scriptable scope) {
		 IdFunctionObject f = new IdFunctionObject(this, tag, id, name, arity, scope);
		 if (isSealed()) {
			 f.sealObject();
		 }
		 return f;
	 }
	 private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
		 stream.defaultReadObject();
		 int maxPrototypeId = stream.readInt();
		 if (maxPrototypeId != 0) {
			 activatePrototypeMap(maxPrototypeId);
		 }
	 }
	 private void writeObject(ObjectOutputStream stream) throws IOException {
		 stream.defaultWriteObject();
		 int maxPrototypeId = 0;
		 if (prototypeValues != null) {
			 maxPrototypeId = prototypeValues.getMaxId();
		 }
		 stream.writeInt(maxPrototypeId);
	 }
}",0,0,0,0
"public XYItemRendererState initialise(Graphics2D g2, Rectangle2D dataArea, XYPlot plot, XYDataset data, PlotRenderingInfo info);",0,0,0,1
"public class TransactionRecord {
	 private long offset;
	 private String producerGroup;
	 public long getOffset() {
		 return offset;
	 }
	 public void setOffset(long offset) {
		 this.offset = offset;
	 }
	 public String getProducerGroup() {
		 return producerGroup;
	 }
	 public void setProducerGroup(String producerGroup) {
		 this.producerGroup = producerGroup;
	 }
}",0,1,0,0
"public abstract class AbstractRecipientRewriteTable implements RecipientRewriteTable, Configurable {
	 private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRecipientRewriteTable.class);
	 private int mappingLimit = 10;
	 private boolean recursive = true;
	 private DomainList domainList;
	 public void setDomainList(DomainList domainList) {
		 this.domainList = domainList;
	 }
	 public void configure(HierarchicalConfiguration config) throws ConfigurationException {
		 setRecursiveMapping(config.getBoolean(""recursiveMapping"", true));
		 try {
			 setMappingLimit(config.getInt(""mappingLimit"", 10));
		 }
		 catch (IllegalArgumentException e) {
			 throw new ConfigurationException(e.getMessage());
		 }
		 doConfigure(config);
	 }
	 protected void doConfigure(HierarchicalConfiguration conf) throws ConfigurationException {
	 }
	 public void setRecursiveMapping(boolean recursive) {
		 this.recursive = recursive;
	 }
	 public void setMappingLimit(int mappingLimit) throws IllegalArgumentException {
		 if (mappingLimit < 1) {
			 throw new IllegalArgumentException(""The minimum mappingLimit is 1"");
		 }
		 this.mappingLimit = mappingLimit;
	 }
	 public Mappings getResolvedMappings(String user, Domain domain) throws ErrorMappingException, RecipientRewriteTableException {
		 return getMappings(User.fromLocalPartWithDomain(user, domain), mappingLimit);
	 }
	 private Mappings getMappings(User user, int mappingLimit) throws ErrorMappingException, RecipientRewriteTableException {
		 if (mappingLimit == 0) {
			 throw new TooManyMappingException(""554 Too many mappings to process"");
		 }
		 Mappings targetMappings = mapAddress(user.getLocalPart(), user.getDomainPart().get());
		 try {
			 return MappingsImpl.fromMappings( targetMappings.asStream() .flatMap(Throwing.function((Mapping target) -> convertAndRecurseMapping(user, target, mappingLimit)).sneakyThrow()));
		 }
		 catch (SkipMappingProcessingException e) {
			 return MappingsImpl.empty();
		 }
	 }
	 private Stream<Mapping> convertAndRecurseMapping(User originalUser, Mapping associatedMapping, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException, SkipMappingProcessingException, AddressException {
		 Function<User, Stream<Mapping>> convertAndRecurseMapping = Throwing .function((User rewrittenUser) -> convertAndRecurseMapping(associatedMapping, originalUser, rewrittenUser, remainingLoops)) .sneakyThrow();
		 return associatedMapping.rewriteUser(originalUser) .map(rewrittenUser -> rewrittenUser.withDefaultDomainFromUser(originalUser)) .map(convertAndRecurseMapping) .orElse(Stream.empty());
	 }
	 private Stream<Mapping> convertAndRecurseMapping(Mapping mapping, User originalUser, User rewrittenUser, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException {
		 LOGGER.debug(""Valid virtual user mapping {
		}
		 to {
		}
		"", originalUser.asString(), rewrittenUser.asString());
		 Stream<Mapping> nonRecursiveResult = Stream.of(toMapping(rewrittenUser, mapping.getType()));
		 if (!recursive) {
			 return nonRecursiveResult;
		 }
		 if (originalUser.equals(rewrittenUser)) {
			 return mapping.handleIdentity(nonRecursiveResult);
		 }
		 else {
			 return recurseMapping(nonRecursiveResult, rewrittenUser, remainingLoops);
		 }
	 }
	 private Stream<Mapping> recurseMapping(Stream<Mapping> nonRecursiveResult, User targetUser, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException {
		 Mappings childMappings = getMappings(targetUser, remainingLoops - 1);
		 if (childMappings.isEmpty()) {
			 return nonRecursiveResult;
		 }
		 else {
			 return childMappings.asStream();
		 }
	 }
	 private Mapping toMapping(User rewrittenUser, Type type) {
		 switch (type) {
			 case Forward: case Group: case Alias: return Mapping.of(type, rewrittenUser.asString());
			 case Regex: case Domain: case Error: case Address: return Mapping.address(rewrittenUser.asString());
		 }
		 throw new IllegalArgumentException(""unhandled enum type"");
	 }
	 public void addRegexMapping(MappingSource source, String regex) throws RecipientRewriteTableException {
		 try {
			 Pattern.compile(regex);
		 }
		 catch (PatternSyntaxException e) {
			 throw new RecipientRewriteTableException(""Invalid regex: "" + regex, e);
		 }
		 Mapping mapping = Mapping.regex(regex);
		 checkDuplicateMapping(source, mapping);
		 LOGGER.info(""Add regex mapping => {
		}
		 for source {
		}
		"", regex, source.asString());
		 addMapping(source, mapping);
	 }
	 public void removeRegexMapping(MappingSource source, String regex) throws RecipientRewriteTableException {
		 LOGGER.info(""Remove regex mapping => {
		}
		 for source: {
		}
		"", regex, source.asString());
		 removeMapping(source, Mapping.regex(regex));
	 }
	 public void addAddressMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.address(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 checkHasValidAddress(mapping);
		 checkDuplicateMapping(source, mapping);
		 LOGGER.info(""Add address mapping => {
		}
		 for source: {
		}
		"", mapping.asString(), source.asString());
		 addMapping(source, mapping);
	 }
	 private Domain defaultDomain() throws RecipientRewriteTableException {
		 try {
			 return domainList.getDefaultDomain();
		 }
		 catch (DomainListException e) {
			 throw new RecipientRewriteTableException(""Unable to retrieve default domain"", e);
		 }
	 }
	 private void checkHasValidAddress(Mapping mapping) throws RecipientRewriteTableException {
		 if (!mapping.asMailAddress().isPresent()) {
			 throw new RecipientRewriteTableException(""Invalid emailAddress: "" + mapping.asString());
		 }
	 }
	 public void removeAddressMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.address(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 LOGGER.info(""Remove address mapping => {
		}
		 for source: {
		}
		"", mapping.asString(), source.asString());
		 removeMapping(source, mapping);
	 }
	 public void addErrorMapping(MappingSource source, String error) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.error(error);
		 checkDuplicateMapping(source, mapping);
		 LOGGER.info(""Add error mapping => {
		}
		 for source: {
		}
		"", error, source.asString());
		 addMapping(source, mapping);
	 }
	 public void removeErrorMapping(MappingSource source, String error) throws RecipientRewriteTableException {
		 LOGGER.info(""Remove error mapping => {
		}
		 for source: {
		}
		"", error, source.asString());
		 removeMapping(source, Mapping.error(error));
	 }
	 public void addAliasDomainMapping(MappingSource source, Domain realDomain) throws RecipientRewriteTableException {
		 LOGGER.info(""Add domain mapping: {
		}
		 => {
		}
		"", source.asDomain().map(Domain::asString).orElse(""null""), realDomain);
		 addMapping(source, Mapping.domain(realDomain));
	 }
	 public void removeAliasDomainMapping(MappingSource source, Domain realDomain) throws RecipientRewriteTableException {
		 LOGGER.info(""Remove domain mapping: {
		}
		 => {
		}
		"", source.asDomain().map(Domain::asString).orElse(""null""), realDomain);
		 removeMapping(source, Mapping.domain(realDomain));
	 }
	 public void addForwardMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.forward(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 checkHasValidAddress(mapping);
		 checkDuplicateMapping(source, mapping);
		 LOGGER.info(""Add forward mapping => {
		}
		 for source: {
		}
		"", mapping.asString(), source.asString());
		 addMapping(source, mapping);
	 }
	 public void removeForwardMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.forward(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 LOGGER.info(""Remove forward mapping => {
		}
		 for source: {
		}
		"", mapping.asString(), source.asString());
		 removeMapping(source, mapping);
	 }
	 public void addGroupMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.group(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 checkHasValidAddress(mapping);
		 checkDuplicateMapping(source, mapping);
		 LOGGER.info(""Add group mapping => {
		}
		 for source: {
		}
		"", mapping.asString(), source.asString());
		 addMapping(source, mapping);
	 }
	 public void removeGroupMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.group(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 LOGGER.info(""Remove group mapping => {
		}
		 for source: {
		}
		"", mapping.asString(), source.asString());
		 removeMapping(source, mapping);
	 }
	 public void addAliasMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.alias(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 checkHasValidAddress(mapping);
		 checkDuplicateMapping(source, mapping);
		 checkNotSameSourceAndDestination(source, address);
		 LOGGER.info(""Add alias source => {
		}
		 for destination mapping: {
		}
		"", source.asString(), mapping.asString());
		 addMapping(source, mapping);
	 }
	 public void removeAliasMapping(MappingSource source, String address) throws RecipientRewriteTableException {
		 Mapping mapping = Mapping.alias(address) .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);
		 LOGGER.info(""Remove alias source => {
		}
		 for destination mapping: {
		}
		"", source.asString(), mapping.asString());
		 removeMapping(source, mapping);
	 }
	 public abstract Map<MappingSource, Mappings> getAllMappings() throws RecipientRewriteTableException;
	 protected abstract Mappings mapAddress(String user, Domain domain) throws RecipientRewriteTableException;
	 private void checkDuplicateMapping(MappingSource source, Mapping mapping) throws RecipientRewriteTableException {
		 Mappings mappings = getStoredMappings(source);
		 if (mappings.contains(mapping)) {
			 throw new MappingAlreadyExistsException(""Mapping "" + mapping.asString() + "" for "" + source.asString() + "" already exist!"");
		 }
	 }
	 private void checkNotSameSourceAndDestination(MappingSource source, String address) throws RecipientRewriteTableException {
		 if (source.asMailAddress().map(mailAddress -> mailAddress.asString().equals(address)).orElse(false)) {
			 throw new SameSourceAndDestinationException(""Source and destination can't be the same!"");
		 }
	 }
}",1,1,0,0
"public boolean isSelected(Resource r) {
	 boolean none = true;
	 for (Iterator i = getSelectors();
	 none && i.hasNext();
	) {
		 none = !((ResourceSelector) i.next()).isSelected(r);
	 }
	 return none;
 }",0,0,0,0
"private void addUTF8Region(StructurePointer clazz, String slotName,String additionalInfo, AbstractPointer utf8String)throws CorruptDataException {
	long offset = utf8String.getAddress() - clazz.getAddress();
	long clazzSize = ((J9ROMClassPointer) clazz).romSize().longValue();
	if ((offset > 0) && (offset < clazzSize)) {
		if (utf8String.notNull()) {
			long UTF8Length = getUTF8Length(J9UTF8Pointer.cast(utf8String));
			if (utf8String.getAddress() < firstJ9_ROM_UTF8) {
				firstJ9_ROM_UTF8 = utf8String.getAddress();
			}
			if ((utf8String.getAddress() + UTF8Length) > lastJ9_ROM_UTF8) {
				lastJ9_ROM_UTF8 = utf8String.getAddress() + UTF8Length;
			}
			classRegions.add(new J9ClassRegion(utf8String,SlotType.J9_ROM_UTF8, slotName, additionalInfo,UTF8Length, offset, true));
		}
	}
}",0,0,1,0
"public MimeType forName(String name) {
	 try {
		 return this.mimeTypes.forName(name);
	 }
	 catch (MimeTypeException e) {
		 LOG.error(""Exception getting mime type by name: ["" + name + ""]: Message: "" + e.getMessage());
		 return null;
	 }
 }",0,0,0,0
"public class OffsetCompiler {
	 private static final ParseNodeFactory NODE_FACTORY = new ParseNodeFactory();
	 public static final PDatum OFFSET_DATUM = new PDatum() {
		 public boolean isNullable() {
			 return false;
		 }
		 public PDataType getDataType() {
			 return PInteger.INSTANCE;
		 }
		 public Integer getMaxLength() {
			 return null;
		 }
		 public Integer getScale() {
			 return null;
		 }
		 public SortOrder getSortOrder() {
			 return SortOrder.getDefault();
		 }
	 }
	;
	 private OffsetCompiler() {
	}
	 public static Integer compile(StatementContext context, FilterableStatement statement) throws SQLException {
		 OffsetNode offsetNode = statement.getOffset();
		 if (offsetNode == null) {
			 return null;
		 }
		 OffsetParseNodeVisitor visitor = new OffsetParseNodeVisitor(context);
		 offsetNode.getOffsetParseNode().accept(visitor);
		 return visitor.getOffset();
	 }
	 private static class OffsetParseNodeVisitor extends TraverseNoParseNodeVisitor<Void> {
		 private final StatementContext context;
		 private Integer offset;
		 public OffsetParseNodeVisitor(StatementContext context) {
			 this.context = context;
		 }
		 public Integer getOffset() {
			 return offset;
		 }
		 public Void visit(LiteralParseNode node) throws SQLException {
			 Object offsetValue = node.getValue();
			 if (offsetValue != null) {
				 Integer offset = (Integer)OFFSET_DATUM.getDataType().toObject(offsetValue, node.getType());
				 if (offset.intValue() >= 0) {
					 this.offset = offset;
				 }
			 }
			 return null;
		 }
		 public Void visit(BindParseNode node) throws SQLException {
			 if (context == null) return null;
			 Object value = context.getBindManager().getBindValue(node);
			 context.getBindManager().addParamMetaData(node, OFFSET_DATUM);
			 visit(NODE_FACTORY.literal(value, OFFSET_DATUM.getDataType()));
			 return null;
		 }
	 }
}",0,0,0,0
"public class DefaultCipherService{
	 private static final Charset UTF_8 = Charset.forName(""UTF-8"");
	 private static final String HASH_ALGORITHM = ""SHA-256"";
	 private static final String CIPHER_ALGORITHM = ""AES"";
	 public String setMasterHash(String masterPassword, String masterSalt, boolean overwrite) throws IOException {
		 File masterFile = getMasterFile();
		 if (!masterFile.getParentFile().exists()) {
			 if (!masterFile.getParentFile().mkdirs()) {
				 throw new IOException(""Can not create directory "" + masterFile.getParent());
			 }
		 }
		 String saltHash = byteToHex(secureHash(masterSalt));
		 String saltKey = byteToHex(secureHash(saltHash));
		 String encrypted = byteToHex(aesEncrypt(byteToHex(secureHash(masterPassword)), saltHash));
		 Properties keys = new Properties();
		 if (masterFile.exists()) {
			 keys = loadProperties(masterFile.toURI().toURL());
		 }
		 if (keys.get(saltKey) != null && !overwrite) {
			 throw new IllegalStateException(""MasterKey for hash "" + saltKey + "" already exists. Forced overwrite option needed"");
		 }
		 keys.put(saltKey, encrypted);
		 keys.store(new FileOutputStream(masterFile), null);
		 return saltKey;
	 }
	 protected String getMasterKey(String masterSalt) {
		 File masterFile = getMasterFile();
		 if (!masterFile.exists()) {
			 throw new IllegalStateException(""Could not find master.hash file. Create a master password first!"");
		 }
		 try {
			 String saltHash = byteToHex(secureHash(masterSalt));
			 String saltKey = byteToHex(secureHash(saltHash));
			 Properties keys = loadProperties(masterFile.toURI().toURL());
			 String encryptedMasterKey = (String) keys.get(saltKey);
			 if (encryptedMasterKey == null) {
				 throw new IllegalStateException(""Could not find master key for hash "" + saltKey + "". Create a master password first!"");
			 }
			 return aesDecrypt(hexToByte(encryptedMasterKey), saltHash);
		 }
		 catch (MalformedURLException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public String encrypt(String cleartext, String masterSalt) {
		 return byteToHex(aesEncrypt(cleartext, getMasterKey(masterSalt)));
	 }
	 public String decrypt(String encryptedValue, String masterSalt) {
		 return aesDecrypt(hexToByte(encryptedValue), getMasterKey(masterSalt));
	 }
	 protected File getMasterFile() {
		 String userHome = System.getProperty(""user.home"");
		 if (userHome == null || userHome.isEmpty()) {
			 throw new IllegalStateException(""Can not determine user home directory"");
		 }
		 return new File(userHome, "".deltaspike/master.hash"");
	 }
	 protected byte[] secureHash(String value) {
		 try {
			 MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);
			 return md.digest(value.getBytes(UTF_8));
		 }
		 catch (NoSuchAlgorithmException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public byte[] aesEncrypt(String valueToEncrypt, String key) {
		 try {
			 SecretKeySpec secretKeySpec = getSecretKeySpec(key);
			 Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
			 cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
			 return cipher.doFinal(valueToEncrypt.getBytes(UTF_8));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public String aesDecrypt(byte[] encryptedValue, String key) {
		 try {
			 SecretKeySpec secretKeySpec = getSecretKeySpec(key);
			 Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
			 cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
			 return new String(cipher.doFinal(encryptedValue), UTF_8);
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 private SecretKeySpec getSecretKeySpec(String password) {
		 byte[] pwdHash = secureHash(password);
		 byte[] key = Arrays.copyOf(pwdHash, 16);
		 return new SecretKeySpec(key, ""AES"");
	 }
	 protected String byteToHex(final byte[] hash) {
		 StringBuilder sb = new StringBuilder(hash.length * 2);
		 for (byte b : hash) {
			 sb.append(Character.forDigit(b >> 4 & 0x0f, 16));
			 sb.append(Character.forDigit(b & 0x0f, 16));
		 }
		 return sb.toString();
	 }
	 protected byte[] hexToByte(String hexString) {
		 if (hexString == null || hexString.length() == 0) {
			 return new byte[0];
		 }
		 hexString = hexString.trim();
		 if (hexString.length() % 2 != 0) {
			 throw new IllegalArgumentException(""not a valid hex string "" + hexString);
		 }
		 byte[] bytes = new byte[hexString.length() / 2];
		 for (int i = 0;
		 i < hexString.length() / 2;
		 i++) {
			 int val = (Character.digit(hexString.charAt(i * 2), 16) << 4) + (Character.digit(hexString.charAt( (i * 2) + 1), 16));
			 bytes[i] = (byte) val;
		 }
		 return bytes;
	 }
	 private Properties loadProperties(URL url) {
		 Properties props = new Properties();
		 InputStream inputStream = null;
		 try {
			 inputStream = url.openStream();
			 if (inputStream != null) {
				 props.load(inputStream);
			 }
		 }
		 catch (IOException e) {
			 throw new IllegalStateException(e);
		 }
		 finally {
			 try {
				 if (inputStream != null) {
					 inputStream.close();
				 }
			 }
			 catch (IOException e) {
			 }
		 }
		 return props;
	 }
}",0,0,0,0
"public int getIncludedDirsCount() {
	 return 0;
 }",0,0,0,0
"public synchronized void invalidate(){
	imageData = null;
}",0,0,0,0
"public class ClassConfigurator {
	 public static final String MAGIC_NUMBER_FILE = ""jg-magic-map.xml"";
	 public static final String PROTOCOL_ID_FILE = ""jg-protocol-ids.xml"";
	 private static final short MIN_CUSTOM_MAGIC_NUMBER=1024;
	 private static final short MIN_CUSTOM_PROTOCOL_ID=512;
	 private static final Map<Class,Short> classMap=new ConcurrentHashMap<Class,Short>();
	 private static final Map<Short,Class> magicMap=new ConcurrentHashMap<Short,Class>();
	 private static final Map<Class,Short> protocol_ids=new ConcurrentHashMap<Class,Short>();
	 private static final Map<Short,Class> protocol_names=new ConcurrentHashMap<Short,Class>();
	 protected static final Log log=LogFactory.getLog(ClassConfigurator.class);
	 static {
		 try {
			 init();
		 }
		 catch(Exception e) {
			 throw new ExceptionInInitializerError(e);
		 }
	 }
	 public ClassConfigurator() {
	 }
	 protected static void init() throws ChannelException {
		 try {
			 Util.loadClass(""javax.xml.parsers.DocumentBuilderFactory"", ClassConfigurator.class);
			 String magic_number_file=null, protocol_id_file=null;
			 try {
				 magic_number_file=Util.getProperty(new String[]{
				Global.MAGIC_NUMBER_FILE, ""org.jgroups.conf.magicNumberFile""}
				, null, null, false, MAGIC_NUMBER_FILE);
				 protocol_id_file=Util.getProperty(new String[]{
				Global.PROTOCOL_ID_FILE, ""org.jgroups.conf.protocolIDFile""}
				, null, null, false, PROTOCOL_ID_FILE);
				 if(log.isDebugEnabled()) log.debug(""Using "" + magic_number_file + "" as magic number file and "" + protocol_id_file + "" for protocol IDs"");
			 }
			 catch (SecurityException ex){
			 }
			 List<Tuple<Short,String>> mapping=readMappings(magic_number_file);
			 for(Tuple<Short,String> tuple: mapping) {
				 short m=tuple.getVal1();
				 try {
					 Class clazz=Util.loadClass(tuple.getVal2(), ClassConfigurator.class);
					 if(magicMap.containsKey(m)) throw new ChannelException(""key "" + m + "" ("" + clazz.getName() + ')' + "" is already in magic map;
					 please make sure that all keys are unique"");
					 magicMap.put(m, clazz);
					 classMap.put(clazz, m);
				 }
				 catch(ClassNotFoundException cnf) {
					 throw new ChannelException(""failed loading class"", cnf);
				 }
			 }
			 mapping=readMappings(protocol_id_file);
			 for(Tuple<Short,String> tuple: mapping) {
				 short m=tuple.getVal1();
				 try {
					 Class clazz=Util.loadClass(tuple.getVal2(), ClassConfigurator.class);
					 if(protocol_ids.containsKey(clazz)) throw new ChannelException(""ID "" + m + "" ("" + clazz.getName() + ')' + "" is already in protocol-ID map;
					 please make sure that all protocol IDs are unique"");
					 protocol_ids.put(clazz, m);
					 protocol_names.put(m, clazz);
				 }
				 catch(ClassNotFoundException cnf) {
					 throw new ChannelException(""failed loading class"", cnf);
				 }
			 }
		 }
		 catch(ChannelException ex) {
			 throw ex;
		 }
		 catch(Throwable x) {
			 throw new ChannelException(""failed reading the magic number mapping file"", x);
		 }
	 }
	 public static void add(short magic, Class clazz) throws IllegalArgumentException {
		 if(magic <= MIN_CUSTOM_MAGIC_NUMBER) throw new IllegalArgumentException(""magic number ("" + magic + "") needs to be greater than "" + MIN_CUSTOM_MAGIC_NUMBER);
		 if(magicMap.containsKey(magic) || classMap.containsKey(clazz)) throw new IllegalArgumentException(""magic number "" + magic + "" for class "" + clazz.getName() + "" is already present"");
		 magicMap.put(magic, clazz);
		 classMap.put(clazz, magic);
	 }
	 public static void addProtocol(short id, Class protocol) {
		 if(id <= MIN_CUSTOM_PROTOCOL_ID) throw new IllegalArgumentException(""protocol ID ("" + id + "") needs to be greater than "" + MIN_CUSTOM_PROTOCOL_ID);
		 if(protocol_ids.containsKey(protocol)) throw new IllegalArgumentException(""Protocol "" + protocol + "" is already present"");
		 protocol_ids.put(protocol, id);
	 }
	 public static Class get(short magic) {
		 return magicMap.get(magic);
	 }
	 public static Class get(String clazzname) {
		 try {
			 return Util.loadClass(clazzname, ClassConfigurator.class);
		 }
		 catch(Exception x) {
			 if(log.isErrorEnabled()) log.error(""failed loading class "" + clazzname, x);
		 }
		 return null;
	 }
	 public static short getMagicNumber(Class clazz) {
		 Short i=classMap.get(clazz);
		 if(i == null) return -1;
		 else return i;
	 }
	 public static short getProtocolId(Class protocol) {
		 Short retval=protocol_ids.get(protocol);
		 if(retval != null) return retval;
		 return 0;
	 }
	 public static Class getProtocol(short id) {
		 return protocol_names.get(id);
	 }
	 public String toString() {
		 return printMagicMap();
	 }
	 public static String printMagicMap() {
		 StringBuilder sb=new StringBuilder();
		 SortedSet<Short> keys=new TreeSet<Short>(magicMap.keySet());
		 for(Short key: keys) {
			 sb.append(key).append("":\t"").append(magicMap.get(key)).append('\n');
		 }
		 return sb.toString();
	 }
	 public static String printClassMap() {
		 StringBuilder sb=new StringBuilder();
		 Map.Entry entry;
		 for(Iterator it=classMap.entrySet().iterator();
		 it.hasNext();
		) {
			 entry=(Map.Entry)it.next();
			 sb.append(entry.getKey()).append("": "").append(entry.getValue()).append('\n');
		 }
		 return sb.toString();
	 }
	 protected static List<Tuple<Short,String>> readMappings(String name) throws Exception {
		 InputStream stream;
		 try {
			 stream=Util.getResourceAsStream(name, ClassConfigurator.class);
			 if(stream == null) {
				 if(log.isTraceEnabled()) log.trace(""Could not read "" + name + "" from the CLASSPATH, will try to read it from file"");
				 stream=new FileInputStream(name);
			 }
		 }
		 catch(Exception x) {
			 throw new ChannelException(name + "" not found. Please make sure it is on the classpath"", x);
		 }
		 return parse(stream);
	 }
	 protected static List<Tuple<Short,String>> parse(InputStream stream) throws Exception {
		 DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();
		 factory.setValidating(false);
		 DocumentBuilder builder=factory.newDocumentBuilder();
		 Document document=builder.parse(stream);
		 NodeList class_list=document.getElementsByTagName(""class"");
		 List<Tuple<Short,String>> list=new LinkedList<Tuple<Short,String>>();
		 for(int i=0;
		 i < class_list.getLength();
		 i++) {
			 if(class_list.item(i).getNodeType() == Node.ELEMENT_NODE) {
				 list.add(parseClassData(class_list.item(i)));
			 }
		 }
		 return list;
	 }
	 protected static Tuple<Short,String> parseClassData(Node protocol) throws java.io.IOException {
		 try {
			 protocol.normalize();
			 NamedNodeMap attrs=protocol.getAttributes();
			 String clazzname;
			 String magicnumber;
			 magicnumber=attrs.getNamedItem(""id"").getNodeValue();
			 clazzname=attrs.getNamedItem(""name"").getNodeValue();
			 return new Tuple<Short,String>(Short.valueOf(magicnumber), clazzname);
		 }
		 catch(Exception x) {
			 IOException tmp=new IOException();
			 tmp.initCause(x);
			 throw tmp;
		 }
	 }
}",1,0,0,0
"public String[][] getFileCacheHints(Path f, long start, long len) throws IOException {
	 return dfs.getHints(getPath(f), start, len);
 }",0,0,0,0
"public class Cab extends MatchingTask {
	 private static final int DEFAULT_RESULT = -99;
	 private File cabFile;
	 private File baseDir;
	 private Vector filesets = new Vector();
	 private boolean doCompress = true;
	 private boolean doVerbose = false;
	 private String cmdOptions;
	 protected String archiveType = ""cab"";
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 public void setCabfile(File cabFile) {
		 this.cabFile = cabFile;
	 }
	 public void setBasedir(File baseDir) {
		 this.baseDir = baseDir;
	 }
	 public void setCompress(boolean compress) {
		 doCompress = compress;
	 }
	 public void setVerbose(boolean verbose) {
		 doVerbose = verbose;
	 }
	 public void setOptions(String options) {
		 cmdOptions = options;
	 }
	 public void addFileset(FileSet set) {
		 if (filesets.size() > 0) {
			 throw new BuildException(""Only one nested fileset allowed"");
		 }
		 filesets.addElement(set);
	 }
	 protected void checkConfiguration() throws BuildException {
		 if (baseDir == null && filesets.size() == 0) {
			 throw new BuildException(""basedir attribute or one "" + ""nested fileset is required!"", getLocation());
		 }
		 if (baseDir != null && !baseDir.exists()) {
			 throw new BuildException(""basedir does not exist!"", getLocation());
		 }
		 if (baseDir != null && filesets.size() > 0) {
			 throw new BuildException( ""Both basedir attribute and a nested fileset is not allowed"");
		 }
		 if (cabFile == null) {
			 throw new BuildException(""cabfile attribute must be set!"", getLocation());
		 }
	 }
	 protected ExecTask createExec() throws BuildException {
		 ExecTask exec = new ExecTask(this);
		 return exec;
	 }
	 protected boolean isUpToDate(Vector files) {
		 boolean upToDate = true;
		 for (int i = 0;
		 i < files.size() && upToDate;
		 i++) {
			 String file = files.elementAt(i).toString();
			 if (FILE_UTILS.resolveFile(baseDir, file).lastModified() > cabFile.lastModified()) {
				 upToDate = false;
			 }
		 }
		 return upToDate;
	 }
	 protected File createListFile(Vector files) throws IOException {
		 File listFile = FILE_UTILS.createTempFile(""ant"", """", null, true, true);
		 PrintWriter writer = new PrintWriter(new FileOutputStream(listFile));
		 int size = files.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 writer.println('\""' + files.elementAt(i).toString() + '\""');
		 }
		 writer.close();
		 return listFile;
	 }
	 protected void appendFiles(Vector files, DirectoryScanner ds) {
		 String[] dsfiles = ds.getIncludedFiles();
		 for (int i = 0;
		 i < dsfiles.length;
		 i++) {
			 files.addElement(dsfiles[i]);
		 }
	 }
	 protected Vector getFileList() throws BuildException {
		 Vector files = new Vector();
		 if (baseDir != null) {
			 appendFiles(files, super.getDirectoryScanner(baseDir));
		 }
		 else {
			 FileSet fs = (FileSet) filesets.elementAt(0);
			 baseDir = fs.getDir();
			 appendFiles(files, fs.getDirectoryScanner(getProject()));
		 }
		 return files;
	 }
	 public void execute() throws BuildException {
		 checkConfiguration();
		 Vector files = getFileList();
		 if (isUpToDate(files)) {
			 return;
		 }
		 log(""Building "" + archiveType + "": "" + cabFile.getAbsolutePath());
		 if (!Os.isFamily(""windows"")) {
			 log(""Using listcab/libcabinet"", Project.MSG_VERBOSE);
			 StringBuffer sb = new StringBuffer();
			 Enumeration fileEnum = files.elements();
			 while (fileEnum.hasMoreElements()) {
				 sb.append(fileEnum.nextElement()).append(""\n"");
			 }
			 sb.append(""\n"").append(cabFile.getAbsolutePath()).append(""\n"");
			 try {
				 Process p = Execute.launch(getProject(), new String[] {
				""listcab""}
				, null, baseDir != null ? baseDir : getProject().getBaseDir(), true);
				 OutputStream out = p.getOutputStream();
				 LogOutputStream outLog = new LogOutputStream(this, Project.MSG_VERBOSE);
				 LogOutputStream errLog = new LogOutputStream(this, Project.MSG_ERR);
				 StreamPumper outPump = new StreamPumper(p.getInputStream(), outLog);
				 StreamPumper errPump = new StreamPumper(p.getErrorStream(), errLog);
				 (new Thread(outPump)).start();
				 (new Thread(errPump)).start();
				 out.write(sb.toString().getBytes());
				 out.flush();
				 out.close();
				 int result = DEFAULT_RESULT;
				 try {
					 result = p.waitFor();
					 outPump.waitFor();
					 outLog.close();
					 errPump.waitFor();
					 errLog.close();
				 }
				 catch (InterruptedException ie) {
					 log(""Thread interrupted: "" + ie);
				 }
				 if (Execute.isFailure(result)) {
					 log(""Error executing listcab;
					 error code: "" + result);
				 }
			 }
			 catch (IOException ex) {
				 String msg = ""Problem creating "" + cabFile + "" "" + ex.getMessage();
				 throw new BuildException(msg, getLocation());
			 }
		 }
		 else {
			 try {
				 File listFile = createListFile(files);
				 ExecTask exec = createExec();
				 File outFile = null;
				 exec.setFailonerror(true);
				 exec.setDir(baseDir);
				 if (!doVerbose) {
					 outFile = FILE_UTILS.createTempFile(""ant"", """", null, true, true);
					 exec.setOutput(outFile);
				 }
				 exec.setExecutable(""cabarc"");
				 exec.createArg().setValue(""-r"");
				 exec.createArg().setValue(""-p"");
				 if (!doCompress) {
					 exec.createArg().setValue(""-m"");
					 exec.createArg().setValue(""none"");
				 }
				 if (cmdOptions != null) {
					 exec.createArg().setLine(cmdOptions);
				 }
				 exec.createArg().setValue(""n"");
				 exec.createArg().setFile(cabFile);
				 exec.createArg().setValue(""@"" + listFile.getAbsolutePath());
				 exec.execute();
				 if (outFile != null) {
					 outFile.delete();
				 }
				 listFile.delete();
			 }
			 catch (IOException ioe) {
				 String msg = ""Problem creating "" + cabFile + "" "" + ioe.getMessage();
				 throw new BuildException(msg, getLocation());
			 }
		 }
	 }
}",0,0,0,0
"private RowIterator processFromTree(FromNode from, Database db) throws AxionException {
	 TableIdentifier temp = null;
	 RowIterator leftiter = null;
	 RowIterator rightiter = null;
	 RowIterator literaliter = null;
	 RowIterator row = null;
	 int iterCount = 0;
	 int lcolpos = -1;
	 int rcolcount = -1;
	 ColumnIdentifier rcol = null;
	 ColumnIdentifier lcol = null;
	 if (from != null) {
		 WhereNode condition = from.getCondition();
		 if (from.getTableCount() > 1 && (from.getType() == FromNode.TYPE_INNER || from.getType() == FromNode.TYPE_LEFT)) {
			 if (from.getRight() instanceof TableIdentifier && condition != null && condition instanceof LeafWhereNode) {
				 TableIdentifier tid = (TableIdentifier) from.getRight();
				 lcol = (ColumnIdentifier) ((LeafWhereNode) condition).getLeft();
				 rcol = (ColumnIdentifier) ((LeafWhereNode) condition).getRight();
				 if (lcol.equals(rcol) == false) {
					 if (tid.equals(lcol.getTableIdentifier())) {
						 ColumnIdentifier tempcid = lcol;
						 lcol = rcol;
						 rcol = tempcid;
					 }
				 }
				 Table table = db.getTable(tid);
				 if (table.getIndexForColumn(table.getColumn(rcol.getName())) == null) {
					 lcol = null;
					 rcol = null;
				 }
			 }
		 }
		 if (condition != null) {
			 _applyWhereNodesAfterJoin = true;
		 }
	 }
	 if (from != null && from.getLeft() != null) {
		 Object leftChild = from.getLeft();
		 if (leftChild instanceof FromNode) {
			 leftiter = processFromTree((FromNode) leftChild, db);
			 if (lcol != null) {
				 lcolpos = ((Integer)_colIdToFieldMap.get(lcol)).intValue();
			 }
		 }
		 else if (leftChild instanceof TableIdentifier) {
			 temp = (TableIdentifier) from.getLeft();
			 Table left = db.getTable(temp);
			 if (left == null) {
				 throw new AxionException(""Table "" + temp + "" not found."");
			 }
			 if (lcol != null) {
				 lcolpos = left.getColumnIndex(lcol.getName());
			 }
			 leftiter = processTable(temp, db, lcol, 0);
		 }
		 else {
			 throw new AxionException(""From clause is badly formed"");
		 }
		 iterCount++;
	 }
	 if (from != null && from.getRight() != null) {
		 Object rightChild = from.getRight();
		 if (rightChild instanceof FromNode) {
			 rightiter = processFromTree((FromNode) rightChild, db);
		 }
		 else if (rightChild instanceof TableIdentifier) {
			 temp = (TableIdentifier) from.getRight();
			 Table right = db.getTable(temp);
			 if (right == null) {
				 throw new AxionException(""Table "" + temp + "" not found."");
			 }
			 rightiter = processTable(temp, db, rcol, 1);
			 rcolcount = right.getColumnCount();
		 }
		 else {
			 throw new AxionException(""From clause is badly formed"");
		 }
		 iterCount++;
	 }
	 if(null != _literals) {
		 Row litrow = new SimpleRow(_literals.size());
		 Iterator iter = _literals.iterator();
		 for(int i=0;
		iter.hasNext();
		i++) {
			 Literal literal = (Literal)iter.next();
			 _colIdToFieldMap.put(literal,new Integer(_indexOffset+i));
		 }
		 _indexOffset += _literals.size();
		 literaliter = new SingleRowIterator(litrow);
		 iterCount++;
		 _literals = null;
	 }
	 if (iterCount > 1) {
		 if (literaliter == null && rightiter instanceof ChangingIndexedRowIterator && from.getType() != FromNode.TYPE_RIGHT) {
			 IndexJoinedRowIterator joinedrow = new IndexJoinedRowIterator(lcolpos, rcolcount);
			 joinedrow.addRowIterator(leftiter);
			 joinedrow.addRowIterator(rightiter);
			 joinedrow.setJoinType(from.getType());
			 joinedrow.setJoinCondition(new RowDecorator(_colIdToFieldMap), from.getCondition());
			 row = joinedrow;
		 }
		 else {
			 SimpleJoinedRowIterator joinedrow = new SimpleJoinedRowIterator();
			 if (from.getType() == FromNode.TYPE_RIGHT) {
				 joinedrow.addRowIterator(rightiter);
				 joinedrow.addRowIterator(leftiter);
			 }
			 else {
				 if (leftiter != null) {
					 joinedrow.addRowIterator(leftiter);
				 }
				 if (rightiter != null) {
					 joinedrow.addRowIterator(rightiter);
				 }
			 }
			 if (literaliter != null) {
				 joinedrow.addRowIterator(literaliter);
			 }
			 joinedrow.setJoinType(from.getType());
			 if (rightiter != null && leftiter != null && from.getCondition() != null) {
				 joinedrow.setJoinCondition(new RowDecorator(_colIdToFieldMap), from.getCondition());
			 }
			 row = joinedrow;
		 }
	 }
	 else {
		 if (leftiter != null) {
			 row = leftiter;
		 }
		 if (literaliter != null) {
			 row = literaliter;
		 }
	 }
	 return (row);
 }",0,0,1,0
"public class PrintVisitor {
	private static final String INDENT = ""\t"";
	private final int level;
	public PrintVisitor() {
		this(0);
	}
	public PrintVisitor(PrintVisitor parent) {
		this(parent.level + 2);
	}
	public PrintVisitor(int level) {
		this.level = level;
	}
	protected void println(String s) {
		println(this.level, s);
	}
	protected void printlnIndent(String s) {
		println(this.level + 1, s);
	}
	private void println(int level, String s) {
		for (int i = 0;
		 i < level;
		 i++) {
			System.out.print(INDENT);
		}
		System.out.println(s);
	}
}",0,0,0,0
"static class FlattenWithoutDuplicateInputs<T> extends PTransform<PCollectionList<T>, PCollection<T>> {
	 public PCollection<T> expand(PCollectionList<T> input) {
		 Map<PCollection<T>, Integer> instances = new HashMap<>();
		 for (PCollection<T> pCollection : input.getAll()) {
			 int existing = instances.get(pCollection) == null ? 0 : instances.get(pCollection);
			 instances.put(pCollection, existing + 1);
		 }
		 PCollectionList<T> output = PCollectionList.empty(input.getPipeline());
		 for (Map.Entry<PCollection<T>, Integer> instanceEntry : instances.entrySet()) {
			 if (instanceEntry.getValue().equals(1)) {
				 output = output.and(instanceEntry.getKey());
			 }
			 else {
				 String duplicationName = String.format(""Multiply %s"", instanceEntry.getKey().getName());
				 PCollection<T> duplicated = instanceEntry .getKey() .apply(duplicationName, ParDo.of(new DuplicateFn<>(instanceEntry.getValue())));
				 output = output.and(duplicated);
			 }
		 }
		 return output.apply(Flatten.pCollections());
	 }
 }",0,0,0,0
"final class NativeDate extends IdScriptableObject{
	 static final long serialVersionUID = -8307438915861678966L;
	 private static final Object DATE_TAG = new Object();
	 private static final String js_NaN_date_str = ""Invalid Date"";
	 static void init(Scriptable scope, boolean sealed) {
		 NativeDate obj = new NativeDate();
		 obj.date = ScriptRuntime.NaN;
		 obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
	 }
	 private NativeDate() {
		 if (thisTimeZone == null) {
			 thisTimeZone = java.util.TimeZone.getDefault();
			 LocalTZA = thisTimeZone.getRawOffset();
		 }
	 }
	 public String getClassName() {
		 return ""Date"";
	 }
	 public Object getDefaultValue(Class typeHint) {
		 if (typeHint == null) typeHint = ScriptRuntime.StringClass;
		 return super.getDefaultValue(typeHint);
	 }
	 double getJSTimeValue() {
		 return date;
	 }
	 protected void fillConstructorProperties(IdFunctionObject ctor) {
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_now, ""now"", 0);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_parse, ""parse"", 1);
		 addIdFunctionProperty(ctor, DATE_TAG, ConstructorId_UTC, ""UTC"", 1);
		 super.fillConstructorProperties(ctor);
	 }
	 protected void initPrototypeId(int id) {
		 String s;
		 int arity;
		 switch (id) {
			 case Id_constructor: arity=1;
			 s=""constructor"";
			 break;
			 case Id_toString: arity=0;
			 s=""toString"";
			 break;
			 case Id_toTimeString: arity=0;
			 s=""toTimeString"";
			 break;
			 case Id_toDateString: arity=0;
			 s=""toDateString"";
			 break;
			 case Id_toLocaleString: arity=0;
			 s=""toLocaleString"";
			 break;
			 case Id_toLocaleTimeString: arity=0;
			 s=""toLocaleTimeString"";
			 break;
			 case Id_toLocaleDateString: arity=0;
			 s=""toLocaleDateString"";
			 break;
			 case Id_toUTCString: arity=0;
			 s=""toUTCString"";
			 break;
			 case Id_toSource: arity=0;
			 s=""toSource"";
			 break;
			 case Id_valueOf: arity=0;
			 s=""valueOf"";
			 break;
			 case Id_getTime: arity=0;
			 s=""getTime"";
			 break;
			 case Id_getYear: arity=0;
			 s=""getYear"";
			 break;
			 case Id_getFullYear: arity=0;
			 s=""getFullYear"";
			 break;
			 case Id_getUTCFullYear: arity=0;
			 s=""getUTCFullYear"";
			 break;
			 case Id_getMonth: arity=0;
			 s=""getMonth"";
			 break;
			 case Id_getUTCMonth: arity=0;
			 s=""getUTCMonth"";
			 break;
			 case Id_getDate: arity=0;
			 s=""getDate"";
			 break;
			 case Id_getUTCDate: arity=0;
			 s=""getUTCDate"";
			 break;
			 case Id_getDay: arity=0;
			 s=""getDay"";
			 break;
			 case Id_getUTCDay: arity=0;
			 s=""getUTCDay"";
			 break;
			 case Id_getHours: arity=0;
			 s=""getHours"";
			 break;
			 case Id_getUTCHours: arity=0;
			 s=""getUTCHours"";
			 break;
			 case Id_getMinutes: arity=0;
			 s=""getMinutes"";
			 break;
			 case Id_getUTCMinutes: arity=0;
			 s=""getUTCMinutes"";
			 break;
			 case Id_getSeconds: arity=0;
			 s=""getSeconds"";
			 break;
			 case Id_getUTCSeconds: arity=0;
			 s=""getUTCSeconds"";
			 break;
			 case Id_getMilliseconds: arity=0;
			 s=""getMilliseconds"";
			 break;
			 case Id_getUTCMilliseconds: arity=0;
			 s=""getUTCMilliseconds"";
			 break;
			 case Id_getTimezoneOffset: arity=0;
			 s=""getTimezoneOffset"";
			 break;
			 case Id_setTime: arity=1;
			 s=""setTime"";
			 break;
			 case Id_setMilliseconds: arity=1;
			 s=""setMilliseconds"";
			 break;
			 case Id_setUTCMilliseconds: arity=1;
			 s=""setUTCMilliseconds"";
			 break;
			 case Id_setSeconds: arity=2;
			 s=""setSeconds"";
			 break;
			 case Id_setUTCSeconds: arity=2;
			 s=""setUTCSeconds"";
			 break;
			 case Id_setMinutes: arity=3;
			 s=""setMinutes"";
			 break;
			 case Id_setUTCMinutes: arity=3;
			 s=""setUTCMinutes"";
			 break;
			 case Id_setHours: arity=4;
			 s=""setHours"";
			 break;
			 case Id_setUTCHours: arity=4;
			 s=""setUTCHours"";
			 break;
			 case Id_setDate: arity=1;
			 s=""setDate"";
			 break;
			 case Id_setUTCDate: arity=1;
			 s=""setUTCDate"";
			 break;
			 case Id_setMonth: arity=2;
			 s=""setMonth"";
			 break;
			 case Id_setUTCMonth: arity=2;
			 s=""setUTCMonth"";
			 break;
			 case Id_setFullYear: arity=3;
			 s=""setFullYear"";
			 break;
			 case Id_setUTCFullYear: arity=3;
			 s=""setUTCFullYear"";
			 break;
			 case Id_setYear: arity=1;
			 s=""setYear"";
			 break;
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
		 initPrototypeMethod(DATE_TAG, id, s, arity);
	 }
	 public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!f.hasTag(DATE_TAG)) {
			 return super.execIdCall(f, cx, scope, thisObj, args);
		 }
		 int id = f.methodId();
		 switch (id) {
			 case ConstructorId_now: return ScriptRuntime.wrapNumber(now());
			 case ConstructorId_parse: {
				 String dataStr = ScriptRuntime.toString(args, 0);
				 return ScriptRuntime.wrapNumber(date_parseString(dataStr));
			 }
			 case ConstructorId_UTC: return ScriptRuntime.wrapNumber(jsStaticFunction_UTC(args));
			 case Id_constructor: {
				 if (thisObj != null) return date_format(now(), Id_toString);
				 return jsConstructor(args);
			 }
		 }
		 if (!(thisObj instanceof NativeDate)) throw incompatibleCallError(f);
		 NativeDate realThis = (NativeDate)thisObj;
		 double t = realThis.date;
		 switch (id) {
			 case Id_toString: case Id_toTimeString: case Id_toDateString: if (t == t) {
				 return date_format(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toLocaleString: case Id_toLocaleTimeString: case Id_toLocaleDateString: if (t == t) {
				 return toLocale_helper(t, id);
			 }
			 return js_NaN_date_str;
			 case Id_toUTCString: if (t == t) {
				 return js_toUTCString(t);
			 }
			 return js_NaN_date_str;
			 case Id_toSource: return ""(new Date(""+ScriptRuntime.toString(t)+""))"";
			 case Id_valueOf: case Id_getTime: return ScriptRuntime.wrapNumber(t);
			 case Id_getYear: case Id_getFullYear: case Id_getUTCFullYear: if (t == t) {
				 if (id != Id_getUTCFullYear) t = LocalTime(t);
				 t = YearFromTime(t);
				 if (id == Id_getYear) {
					 if (cx.hasFeature(Context.FEATURE_NON_ECMA_GET_YEAR)) {
						 if (1900 <= t && t < 2000) {
							 t -= 1900;
						 }
					 }
					 else {
						 t -= 1900;
					 }
				 }
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMonth: case Id_getUTCMonth: if (t == t) {
				 if (id == Id_getMonth) t = LocalTime(t);
				 t = MonthFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDate: case Id_getUTCDate: if (t == t) {
				 if (id == Id_getDate) t = LocalTime(t);
				 t = DateFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getDay: case Id_getUTCDay: if (t == t) {
				 if (id == Id_getDay) t = LocalTime(t);
				 t = WeekDay(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getHours: case Id_getUTCHours: if (t == t) {
				 if (id == Id_getHours) t = LocalTime(t);
				 t = HourFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMinutes: case Id_getUTCMinutes: if (t == t) {
				 if (id == Id_getMinutes) t = LocalTime(t);
				 t = MinFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getSeconds: case Id_getUTCSeconds: if (t == t) {
				 if (id == Id_getSeconds) t = LocalTime(t);
				 t = SecFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getMilliseconds: case Id_getUTCMilliseconds: if (t == t) {
				 if (id == Id_getMilliseconds) t = LocalTime(t);
				 t = msFromTime(t);
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_getTimezoneOffset: if (t == t) {
				 t = (t - LocalTime(t)) / msPerMinute;
			 }
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setTime: t = TimeClip(ScriptRuntime.toNumber(args, 0));
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setMilliseconds: case Id_setUTCMilliseconds: case Id_setSeconds: case Id_setUTCSeconds: case Id_setMinutes: case Id_setUTCMinutes: case Id_setHours: case Id_setUTCHours: t = makeTime(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setDate: case Id_setUTCDate: case Id_setMonth: case Id_setUTCMonth: case Id_setFullYear: case Id_setUTCFullYear: t = makeDate(t, args, id);
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 case Id_setYear: {
				 double year = ScriptRuntime.toNumber(args, 0);
				 if (year != year || Double.isInfinite(year)) {
					 t = ScriptRuntime.NaN;
				 }
				 else {
					 if (t != t) {
						 t = 0;
					 }
					 else {
						 t = LocalTime(t);
					 }
					 if (year >= 0 && year <= 99) year += 1900;
					 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
					 t = MakeDate(day, TimeWithinDay(t));
					 t = internalUTC(t);
					 t = TimeClip(t);
				 }
			 }
			 realThis.date = t;
			 return ScriptRuntime.wrapNumber(t);
			 default: throw new IllegalArgumentException(String.valueOf(id));
		 }
	 }
	 private static final double HalfTimeDomain = 8.64e15;
	 private static final double HoursPerDay = 24.0;
	 private static final double MinutesPerHour = 60.0;
	 private static final double SecondsPerMinute = 60.0;
	 private static final double msPerSecond = 1000.0;
	 private static final double MinutesPerDay = (HoursPerDay * MinutesPerHour);
	 private static final double SecondsPerDay = (MinutesPerDay * SecondsPerMinute);
	 private static final double SecondsPerHour = (MinutesPerHour * SecondsPerMinute);
	 private static final double msPerDay = (SecondsPerDay * msPerSecond);
	 private static final double msPerHour = (SecondsPerHour * msPerSecond);
	 private static final double msPerMinute = (SecondsPerMinute * msPerSecond);
	 private static double Day(double t) {
		 return Math.floor(t / msPerDay);
	 }
	 private static double TimeWithinDay(double t) {
		 double result;
		 result = t % msPerDay;
		 if (result < 0) result += msPerDay;
		 return result;
	 }
	 private static boolean IsLeapYear(int year) {
		 return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
	 }
	 private static double DayFromYear(double y) {
		 return ((365 * ((y)-1970) + Math.floor(((y)-1969)/4.0) - Math.floor(((y)-1901)/100.0) + Math.floor(((y)-1601)/400.0)));
	 }
	 private static double TimeFromYear(double y) {
		 return DayFromYear(y) * msPerDay;
	 }
	 private static int YearFromTime(double t) {
		 int lo = (int) Math.floor((t / msPerDay) / 366) + 1970;
		 int hi = (int) Math.floor((t / msPerDay) / 365) + 1970;
		 int mid;
		 if (hi < lo) {
			 int temp = lo;
			 lo = hi;
			 hi = temp;
		 }
		 while (hi > lo) {
			 mid = (hi + lo) / 2;
			 if (TimeFromYear(mid) > t) {
				 hi = mid - 1;
			 }
			 else {
				 lo = mid + 1;
				 if (TimeFromYear(lo) > t) {
					 return mid;
				 }
			 }
		 }
		 return lo;
	 }
	 private static double DayFromMonth(int m, int year) {
		 int day = m * 30;
		 if (m >= 7) {
			 day += m / 2 - 1;
		 }
		 else if (m >= 2) {
			 day += (m - 1) / 2 - 1;
		 }
		 else {
			 day += m;
		 }
		 if (m >= 2 && IsLeapYear(year)) {
			 ++day;
		 }
		 return day;
	 }
	 private static int MonthFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? 0 : 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 1;
			 --d;
		 }
		 int estimate = d / 30;
		 int mstart;
		 switch (estimate) {
			 case 0: return 2;
			 case 1: mstart = 31;
			 break;
			 case 2: mstart = 31+30;
			 break;
			 case 3: mstart = 31+30+31;
			 break;
			 case 4: mstart = 31+30+31+30;
			 break;
			 case 5: mstart = 31+30+31+30+31;
			 break;
			 case 6: mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return 11;
			 default: throw Kit.codeBug();
		 }
		 return (d >= mstart) ? estimate + 2 : estimate + 1;
	 }
	 private static int DateFromTime(double t) {
		 int year = YearFromTime(t);
		 int d = (int)(Day(t) - DayFromYear(year));
		 d -= 31 + 28;
		 if (d < 0) {
			 return (d < -28) ? d + 31 + 28 + 1 : d + 28 + 1;
		 }
		 if (IsLeapYear(year)) {
			 if (d == 0) return 29;
			 --d;
		 }
		 int mdays, mstart;
		 switch (d / 30) {
			 case 0: return d + 1;
			 case 1: mdays = 31;
			 mstart = 31;
			 break;
			 case 2: mdays = 30;
			 mstart = 31+30;
			 break;
			 case 3: mdays = 31;
			 mstart = 31+30+31;
			 break;
			 case 4: mdays = 30;
			 mstart = 31+30+31+30;
			 break;
			 case 5: mdays = 31;
			 mstart = 31+30+31+30+31;
			 break;
			 case 6: mdays = 31;
			 mstart = 31+30+31+30+31+31;
			 break;
			 case 7: mdays = 30;
			 mstart = 31+30+31+30+31+31+30;
			 break;
			 case 8: mdays = 31;
			 mstart = 31+30+31+30+31+31+30+31;
			 break;
			 case 9: mdays = 30;
			 mstart = 31+30+31+30+31+31+30+31+30;
			 break;
			 case 10: return d - (31+30+31+30+31+31+30+31+30) + 1;
			 default: throw Kit.codeBug();
		 }
		 d -= mstart;
		 if (d < 0) {
			 d += mdays;
		 }
		 return d + 1;
	 }
	 private static int WeekDay(double t) {
		 double result;
		 result = Day(t) + 4;
		 result = result % 7;
		 if (result < 0) result += 7;
		 return (int) result;
	 }
	 private static double now() {
		 return System.currentTimeMillis();
	 }
	 private final static boolean TZO_WORKAROUND = false;
	 private static double DaylightSavingTA(double t) {
		 if (t < 0.0 || t > 2145916800000.0) {
			 int year = EquivalentYear(YearFromTime(t));
			 double day = MakeDay(year, MonthFromTime(t), DateFromTime(t));
			 t = MakeDate(day, TimeWithinDay(t));
		 }
		 if (!TZO_WORKAROUND) {
			 Date date = new Date((long) t);
			 if (thisTimeZone.inDaylightTime(date)) return msPerHour;
			 else return 0;
		 }
		 else {
			 t += LocalTZA + (HourFromTime(t) <= 2 ? msPerHour : 0);
			 int year = YearFromTime(t);
			 double offset = thisTimeZone.getOffset(year > 0 ? 1 : 0, year, MonthFromTime(t), DateFromTime(t), WeekDay(t), (int)TimeWithinDay(t));
			 if ((offset - LocalTZA) != 0) return msPerHour;
			 else return 0;
		 }
	 }
	 private static int EquivalentYear(int year) {
		 int day = (int) DayFromYear(year) + 4;
		 day = day % 7;
		 if (day < 0) day += 7;
		 if (IsLeapYear(year)) {
			 switch (day) {
				 case 0: return 1984;
				 case 1: return 1996;
				 case 2: return 1980;
				 case 3: return 1992;
				 case 4: return 1976;
				 case 5: return 1988;
				 case 6: return 1972;
			 }
		 }
		 else {
			 switch (day) {
				 case 0: return 1978;
				 case 1: return 1973;
				 case 2: return 1974;
				 case 3: return 1975;
				 case 4: return 1981;
				 case 5: return 1971;
				 case 6: return 1977;
			 }
		 }
		 throw Kit.codeBug();
	 }
	 private static double LocalTime(double t) {
		 return t + LocalTZA + DaylightSavingTA(t);
	 }
	 private static double internalUTC(double t) {
		 return t - LocalTZA - DaylightSavingTA(t - LocalTZA);
	 }
	 private static int HourFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerHour) % HoursPerDay;
		 if (result < 0) result += HoursPerDay;
		 return (int) result;
	 }
	 private static int MinFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerMinute) % MinutesPerHour;
		 if (result < 0) result += MinutesPerHour;
		 return (int) result;
	 }
	 private static int SecFromTime(double t) {
		 double result;
		 result = Math.floor(t / msPerSecond) % SecondsPerMinute;
		 if (result < 0) result += SecondsPerMinute;
		 return (int) result;
	 }
	 private static int msFromTime(double t) {
		 double result;
		 result = t % msPerSecond;
		 if (result < 0) result += msPerSecond;
		 return (int) result;
	 }
	 private static double MakeTime(double hour, double min, double sec, double ms) {
	 return ((hour * MinutesPerHour + min) * SecondsPerMinute + sec) }
	 private static double MakeDay(double year, double month, double date) {
		 year += Math.floor(month / 12);
		 month = month % 12;
		 if (month < 0) month += 12;
		 double yearday = Math.floor(TimeFromYear(year) / msPerDay);
		 double monthday = DayFromMonth((int)month, (int)year);
		 return yearday + monthday + date - 1;
	 }
	 private static double MakeDate(double day, double time) {
		 return day * msPerDay + time;
	 }
	 private static double TimeClip(double d) {
		 if (d != d || d == Double.POSITIVE_INFINITY || d == Double.NEGATIVE_INFINITY || Math.abs(d) > HalfTimeDomain) {
			 return ScriptRuntime.NaN;
		 }
		 if (d > 0.0) return Math.floor(d + 0.);
		 else return Math.ceil(d + 0.);
	 }
	 private static double date_msecFromDate(double year, double mon, double mday, double hour, double min, double sec, double msec) {
		 double day;
		 double time;
		 double result;
		 day = MakeDay(year, mon, mday);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(day, time);
		 return result;
	 }
	 private static final int MAXARGS = 7;
	 private static double jsStaticFunction_UTC(Object[] args) {
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 return ScriptRuntime.NaN;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 array[loop] = 0;
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 if (array[2] < 1) array[2] = 1;
		 d = date_msecFromDate(array[0], array[1], array[2], array[3], array[4], array[5], array[6]);
		 d = TimeClip(d);
		 return d;
	 }
	 private static double date_parseString(String s) {
		 int year = -1;
		 int mon = -1;
		 int mday = -1;
		 int hour = -1;
		 int min = -1;
		 int sec = -1;
		 char c = 0;
		 char si = 0;
		 int i = 0;
		 int n = -1;
		 double tzoffset = -1;
		 char prevc = 0;
		 int limit = 0;
		 boolean seenplusminus = false;
		 limit = s.length();
		 while (i < limit) {
			 c = s.charAt(i);
			 i++;
			 if (c <= ' ' || c == ',' || c == '-') {
				 if (i < limit) {
					 si = s.charAt(i);
					 if (c == '-' && '0' <= si && si <= '9') {
						 prevc = c;
					 }
				 }
				 continue;
			 }
			 if (c == '(') {
				 int depth = 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 i++;
					 if (c == '(') depth++;
					 else if (c == ')') if (--depth <= 0) break;
				 }
				 continue;
			 }
			 if ('0' <= c && c <= '9') {
				 n = c - '0';
				 while (i < limit && '0' <= (c = s.charAt(i)) && c <= '9') {
					 n = n * 10 + c - '0';
					 i++;
				 }
				 if ((prevc == '+' || prevc == '-')) {
					 seenplusminus = true;
					 if (n < 24) n = n * 60;
					 else n = n % 100 + n / 100 * 60;
					 if (prevc == '+') n = -n;
					 if (tzoffset != 0 && tzoffset != -1) return ScriptRuntime.NaN;
					 tzoffset = n;
				 }
				 else if (n >= 70 || (prevc == '/' && mon >= 0 && mday >= 0 && year < 0)) {
					 if (year >= 0) return ScriptRuntime.NaN;
					 else if (c <= ' ' || c == ',' || c == '/' || i >= limit) year = n < 100 ? n + 1900 : n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == ':') {
					 if (hour < 0) hour = n;
					 else if (min < 0) min = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (c == '/') {
					 if (mon < 0) mon = n-1;
					 else if (mday < 0) mday = n;
					 else return ScriptRuntime.NaN;
				 }
				 else if (i < limit && c != ',' && c > ' ' && c != '-') {
					 return ScriptRuntime.NaN;
				 }
				 else if (seenplusminus && n < 60) {
					 if (tzoffset < 0) tzoffset -= n;
					 else tzoffset += n;
				 }
				 else if (hour >= 0 && min < 0) {
					 min = n;
				 }
				 else if (min >= 0 && sec < 0) {
					 sec = n;
				 }
				 else if (mday < 0) {
					 mday = n;
				 }
				 else {
					 return ScriptRuntime.NaN;
				 }
				 prevc = 0;
			 }
			 else if (c == '/' || c == ':' || c == '+' || c == '-') {
				 prevc = c;
			 }
			 else {
				 int st = i - 1;
				 while (i < limit) {
					 c = s.charAt(i);
					 if (!(('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))) break;
					 i++;
				 }
				 int letterCount = i - st;
				 if (letterCount < 2) return ScriptRuntime.NaN;
				 String wtb = ""am;
				pm;
				"" +""monday;
				tuesday;
				wednesday;
				thursday;
				friday;
				"" +""saturday;
				sunday;
				"" +""january;
				february;
				march;
				april;
				may;
				june;
				"" +""july;
				august;
				september;
				october;
				november;
				december;
				"" +""gmt;
				ut;
				utc;
				est;
				edt;
				cst;
				cdt;
				mst;
				mdt;
				pst;
				pdt;
				"";
				 int index = 0;
				 for (int wtbOffset = 0;
				 ;
				) {
					 int wtbNext = wtb.indexOf(';
					', wtbOffset);
					 if (wtbNext < 0) return ScriptRuntime.NaN;
					 if (wtb.regionMatches(true, wtbOffset, s, st, letterCount)) break;
					 wtbOffset = wtbNext + 1;
					 ++index;
				 }
				 if (index < 2) {
					 if (hour > 12 || hour < 0) {
						 return ScriptRuntime.NaN;
					 }
					 else if (index == 0) {
						 if (hour == 12) hour = 0;
					 }
					 else {
						 if (hour != 12) hour += 12;
					 }
				 }
				 else if ((index -= 2) < 7) {
				 }
				 else if ((index -= 7) < 12) {
					 if (mon < 0) {
						 mon = index;
					 }
					 else {
						 return ScriptRuntime.NaN;
					 }
				 }
				 else {
					 index -= 12;
					 switch (index) {
						 case 0 : tzoffset = 0;
						 break;
						 case 1 : tzoffset = 0;
						 break;
						 case 2 : tzoffset = 0;
						 break;
						 case 3 : tzoffset = 5 * 60;
						 break;
						 case 4 : tzoffset = 4 * 60;
						 break;
						 case 5 : tzoffset = 6 * 60;
						 break;
						 case 6 : tzoffset = 5 * 60;
						 break;
						 case 7 : tzoffset = 7 * 60;
						 break;
						 case 8 : tzoffset = 6 * 60;
						 break;
						 case 9 : tzoffset = 8 * 60;
						 break;
						 case 10 :tzoffset = 7 * 60;
						 break;
						 default: Kit.codeBug();
					 }
				 }
			 }
		 }
		 if (year < 0 || mon < 0 || mday < 0) return ScriptRuntime.NaN;
		 if (sec < 0) sec = 0;
		 if (min < 0) min = 0;
		 if (hour < 0) hour = 0;
		 double msec = date_msecFromDate(year, mon, mday, hour, min, sec, 0);
		 if (tzoffset == -1) {
			 return internalUTC(msec);
		 }
		 else {
			 return msec + tzoffset * msPerMinute;
		 }
	 }
	 private static String date_format(double t, int methodId) {
		 StringBuffer result = new StringBuffer(60);
		 double local = LocalTime(t);
		 if (methodId != Id_toTimeString) {
			 appendWeekDayName(result, WeekDay(local));
			 result.append(' ');
			 appendMonthName(result, MonthFromTime(local));
			 result.append(' ');
			 append0PaddedUint(result, DateFromTime(local), 2);
			 result.append(' ');
			 int year = YearFromTime(local);
			 if (year < 0) {
				 result.append('-');
				 year = -year;
			 }
			 append0PaddedUint(result, year, 4);
			 if (methodId != Id_toDateString) result.append(' ');
		 }
		 if (methodId != Id_toDateString) {
			 append0PaddedUint(result, HourFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, MinFromTime(local), 2);
			 result.append(':');
			 append0PaddedUint(result, SecFromTime(local), 2);
			 int minutes = (int) Math.floor((LocalTZA + DaylightSavingTA(t)) / msPerMinute);
			 int offset = (minutes / 60) * 100 + minutes % 60;
			 if (offset > 0) {
				 result.append("" GMT+"");
			 }
			 else {
				 result.append("" GMT-"");
				 offset = -offset;
			 }
			 append0PaddedUint(result, offset, 4);
			 if (timeZoneFormatter == null) timeZoneFormatter = new java.text.SimpleDateFormat(""zzz"");
			 if (t < 0.0 || t > 2145916800000.0) {
				 int equiv = EquivalentYear(YearFromTime(local));
				 double day = MakeDay(equiv, MonthFromTime(t), DateFromTime(t));
				 t = MakeDate(day, TimeWithinDay(t));
			 }
			 result.append("" ("");
			 java.util.Date date = new Date((long) t);
			 result.append(timeZoneFormatter.format(date));
			 result.append(')');
		 }
		 return result.toString();
	 }
	 private static Object jsConstructor(Object[] args) {
		 NativeDate obj = new NativeDate();
		 if (args.length == 0) {
			 obj.date = now();
			 return obj;
		 }
		 if (args.length == 1) {
			 Object arg0 = args[0];
			 if (arg0 instanceof Scriptable) arg0 = ((Scriptable) arg0).getDefaultValue(null);
			 double date;
			 if (arg0 instanceof String) {
				 date = date_parseString((String)arg0);
			 }
			 else {
				 date = ScriptRuntime.toNumber(arg0);
			 }
			 obj.date = TimeClip(date);
			 return obj;
		 }
		 double array[] = new double[MAXARGS];
		 int loop;
		 double d;
		 for (loop = 0;
		 loop < MAXARGS;
		 loop++) {
			 if (loop < args.length) {
				 d = ScriptRuntime.toNumber(args[loop]);
				 if (d != d || Double.isInfinite(d)) {
					 obj.date = ScriptRuntime.NaN;
					 return obj;
				 }
				 array[loop] = ScriptRuntime.toInteger(args[loop]);
			 }
			 else {
				 array[loop] = 0;
			 }
		 }
		 if (array[0] >= 0 && array[0] <= 99) array[0] += 1900;
		 if (array[2] < 1) array[2] = 1;
		 double day = MakeDay(array[0], array[1], array[2]);
		 double time = MakeTime(array[3], array[4], array[5], array[6]);
		 time = MakeDate(day, time);
		 time = internalUTC(time);
		 obj.date = TimeClip(time);
		 return obj;
	 }
	 private static String toLocale_helper(double t, int methodId) {
		 java.text.DateFormat formatter;
		 switch (methodId) {
			 case Id_toLocaleString: if (localeDateTimeFormatter == null) {
				 localeDateTimeFormatter = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
			 }
			 formatter = localeDateTimeFormatter;
			 break;
			 case Id_toLocaleTimeString: if (localeTimeFormatter == null) {
				 localeTimeFormatter = DateFormat.getTimeInstance(DateFormat.LONG);
			 }
			 formatter = localeTimeFormatter;
			 break;
			 case Id_toLocaleDateString: if (localeDateFormatter == null) {
				 localeDateFormatter = DateFormat.getDateInstance(DateFormat.LONG);
			 }
			 formatter = localeDateFormatter;
			 break;
			 default: formatter = null;
		 }
		 return formatter.format(new Date((long) t));
	 }
	 private static String js_toUTCString(double date) {
		 StringBuffer result = new StringBuffer(60);
		 appendWeekDayName(result, WeekDay(date));
		 result.append("", "");
		 append0PaddedUint(result, DateFromTime(date), 2);
		 result.append(' ');
		 appendMonthName(result, MonthFromTime(date));
		 result.append(' ');
		 int year = YearFromTime(date);
		 if (year < 0) {
			 result.append('-');
			 year = -year;
		 }
		 append0PaddedUint(result, year, 4);
		 result.append(' ');
		 append0PaddedUint(result, HourFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, MinFromTime(date), 2);
		 result.append(':');
		 append0PaddedUint(result, SecFromTime(date), 2);
		 result.append("" GMT"");
		 return result.toString();
	 }
	 private static void append0PaddedUint(StringBuffer sb, int i, int minWidth) {
		 if (i < 0) Kit.codeBug();
		 int scale = 1;
		 --minWidth;
		 if (i >= 10) {
			 if (i < 1000 * 1000 * 1000) {
				 for (;
				;
				) {
					 int newScale = scale * 10;
					 if (i < newScale) {
						 break;
					 }
					 --minWidth;
					 scale = newScale;
				 }
			 }
			 else {
				 minWidth -= 9;
				 scale = 1000 * 1000 * 1000;
			 }
		 }
		 while (minWidth > 0) {
			 sb.append('0');
			 --minWidth;
		 }
		 while (scale != 1) {
			 sb.append((char)('0' + (i / scale)));
			 i %= scale;
			 scale /= 10;
		 }
		 sb.append((char)('0' + i));
	 }
	 private static void appendMonthName(StringBuffer sb, int index) {
		 String months = ""Jan""+""Feb""+""Mar""+""Apr""+""May""+""Jun"" +""Jul""+""Aug""+""Sep""+""Oct""+""Nov""+""Dec"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(months.charAt(index + i));
		 }
	 }
	 private static void appendWeekDayName(StringBuffer sb, int index) {
		 String days = ""Sun""+""Mon""+""Tue""+""Wed""+""Thu""+""Fri""+""Sat"";
		 index *= 3;
		 for (int i = 0;
		 i != 3;
		 ++i) {
			 sb.append(days.charAt(index + i));
		 }
	 }
	 private static double makeTime(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCMilliseconds: local = false;
			 case Id_setMilliseconds: maxargs = 1;
			 break;
			 case Id_setUTCSeconds: local = false;
			 case Id_setSeconds: maxargs = 2;
			 break;
			 case Id_setUTCMinutes: local = false;
			 case Id_setMinutes: maxargs = 3;
			 break;
			 case Id_setUTCHours: local = false;
			 case Id_setHours: maxargs = 4;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[4];
		 double hour, min, sec, msec;
		 double lorutime;
		 double time;
		 double result;
		 if (date != date) return date;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (local) lorutime = LocalTime(date);
		 else lorutime = date;
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 4 && i < stop) hour = conv[i++];
		 else hour = HourFromTime(lorutime);
		 if (maxargs >= 3 && i < stop) min = conv[i++];
		 else min = MinFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) sec = conv[i++];
		 else sec = SecFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) msec = conv[i++];
		 else msec = msFromTime(lorutime);
		 time = MakeTime(hour, min, sec, msec);
		 result = MakeDate(Day(lorutime), time);
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 private static double makeDate(double date, Object[] args, int methodId) {
		 int maxargs;
		 boolean local = true;
		 switch (methodId) {
			 case Id_setUTCDate: local = false;
			 case Id_setDate: maxargs = 1;
			 break;
			 case Id_setUTCMonth: local = false;
			 case Id_setMonth: maxargs = 2;
			 break;
			 case Id_setUTCFullYear: local = false;
			 case Id_setFullYear: maxargs = 3;
			 break;
			 default: Kit.codeBug();
			 maxargs = 0;
		 }
		 int i;
		 double conv[] = new double[3];
		 double year, month, day;
		 double lorutime;
		 double result;
		 if (args.length == 0) args = ScriptRuntime.padArguments(args, 1);
		 for (i = 0;
		 i < args.length && i < maxargs;
		 i++) {
			 conv[i] = ScriptRuntime.toNumber(args[i]);
			 if (conv[i] != conv[i] || Double.isInfinite(conv[i])) {
				 return ScriptRuntime.NaN;
			 }
			 conv[i] = ScriptRuntime.toInteger(conv[i]);
		 }
		 if (date != date) {
			 if (args.length < 3) {
				 return ScriptRuntime.NaN;
			 }
			 else {
				 lorutime = 0;
			 }
		 }
		 else {
			 if (local) lorutime = LocalTime(date);
			 else lorutime = date;
		 }
		 i = 0;
		 int stop = args.length;
		 if (maxargs >= 3 && i < stop) year = conv[i++];
		 else year = YearFromTime(lorutime);
		 if (maxargs >= 2 && i < stop) month = conv[i++];
		 else month = MonthFromTime(lorutime);
		 if (maxargs >= 1 && i < stop) day = conv[i++];
		 else day = DateFromTime(lorutime);
		 day = MakeDay(year, month, day);
		 result = MakeDate(day, TimeWithinDay(lorutime));
		 if (local) result = internalUTC(result);
		 date = TimeClip(result);
		 return date;
	 }
	 protected int findPrototypeId(String s) {
		 int id;
		 L0: {
			 id = 0;
			 String X = null;
			 int c;
			 L: switch (s.length()) {
				 case 6: X=""getDay"";
				id=Id_getDay;
				 break L;
				 case 7: switch (s.charAt(3)) {
					 case 'D': c=s.charAt(0);
					 if (c=='g') {
						 X=""getDate"";
						id=Id_getDate;
					 }
					 else if (c=='s') {
						 X=""setDate"";
						id=Id_setDate;
					 }
					 break L;
					 case 'T': c=s.charAt(0);
					 if (c=='g') {
						 X=""getTime"";
						id=Id_getTime;
					 }
					 else if (c=='s') {
						 X=""setTime"";
						id=Id_setTime;
					 }
					 break L;
					 case 'Y': c=s.charAt(0);
					 if (c=='g') {
						 X=""getYear"";
						id=Id_getYear;
					 }
					 else if (c=='s') {
						 X=""setYear"";
						id=Id_setYear;
					 }
					 break L;
					 case 'u': X=""valueOf"";
					id=Id_valueOf;
					 break L;
				 }
				 break L;
				 case 8: switch (s.charAt(3)) {
					 case 'H': c=s.charAt(0);
					 if (c=='g') {
						 X=""getHours"";
						id=Id_getHours;
					 }
					 else if (c=='s') {
						 X=""setHours"";
						id=Id_setHours;
					 }
					 break L;
					 case 'M': c=s.charAt(0);
					 if (c=='g') {
						 X=""getMonth"";
						id=Id_getMonth;
					 }
					 else if (c=='s') {
						 X=""setMonth"";
						id=Id_setMonth;
					 }
					 break L;
					 case 'o': X=""toSource"";
					id=Id_toSource;
					 break L;
					 case 't': X=""toString"";
					id=Id_toString;
					 break L;
				 }
				 break L;
				 case 9: X=""getUTCDay"";
				id=Id_getUTCDay;
				 break L;
				 case 10: c=s.charAt(3);
				 if (c=='M') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getMinutes"";
						id=Id_getMinutes;
					 }
					 else if (c=='s') {
						 X=""setMinutes"";
						id=Id_setMinutes;
					 }
				 }
				 else if (c=='S') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getSeconds"";
						id=Id_getSeconds;
					 }
					 else if (c=='s') {
						 X=""setSeconds"";
						id=Id_setSeconds;
					 }
				 }
				 else if (c=='U') {
					 c=s.charAt(0);
					 if (c=='g') {
						 X=""getUTCDate"";
						id=Id_getUTCDate;
					 }
					 else if (c=='s') {
						 X=""setUTCDate"";
						id=Id_setUTCDate;
					 }
				 }
				 break L;
				 case 11: switch (s.charAt(3)) {
					 case 'F': c=s.charAt(0);
					 if (c=='g') {
						 X=""getFullYear"";
						id=Id_getFullYear;
					 }
					 else if (c=='s') {
						 X=""setFullYear"";
						id=Id_setFullYear;
					 }
					 break L;
					 case 'M': X=""toGMTString"";
					id=Id_toGMTString;
					 break L;
					 case 'T': X=""toUTCString"";
					id=Id_toUTCString;
					 break L;
					 case 'U': c=s.charAt(0);
					 if (c=='g') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""getUTCHours"";
							id=Id_getUTCHours;
						 }
						 else if (c=='t') {
							 X=""getUTCMonth"";
							id=Id_getUTCMonth;
						 }
					 }
					 else if (c=='s') {
						 c=s.charAt(9);
						 if (c=='r') {
							 X=""setUTCHours"";
							id=Id_setUTCHours;
						 }
						 else if (c=='t') {
							 X=""setUTCMonth"";
							id=Id_setUTCMonth;
						 }
					 }
					 break L;
					 case 's': X=""constructor"";
					id=Id_constructor;
					 break L;
				 }
				 break L;
				 case 12: c=s.charAt(2);
				 if (c=='D') {
					 X=""toDateString"";
					id=Id_toDateString;
				 }
				 else if (c=='T') {
					 X=""toTimeString"";
					id=Id_toTimeString;
				 }
				 break L;
				 case 13: c=s.charAt(0);
				 if (c=='g') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""getUTCMinutes"";
						id=Id_getUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""getUTCSeconds"";
						id=Id_getUTCSeconds;
					 }
				 }
				 else if (c=='s') {
					 c=s.charAt(6);
					 if (c=='M') {
						 X=""setUTCMinutes"";
						id=Id_setUTCMinutes;
					 }
					 else if (c=='S') {
						 X=""setUTCSeconds"";
						id=Id_setUTCSeconds;
					 }
				 }
				 break L;
				 case 14: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCFullYear"";
					id=Id_getUTCFullYear;
				 }
				 else if (c=='s') {
					 X=""setUTCFullYear"";
					id=Id_setUTCFullYear;
				 }
				 else if (c=='t') {
					 X=""toLocaleString"";
					id=Id_toLocaleString;
				 }
				 break L;
				 case 15: c=s.charAt(0);
				 if (c=='g') {
					 X=""getMilliseconds"";
					id=Id_getMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setMilliseconds"";
					id=Id_setMilliseconds;
				 }
				 break L;
				 case 17: X=""getTimezoneOffset"";
				id=Id_getTimezoneOffset;
				 break L;
				 case 18: c=s.charAt(0);
				 if (c=='g') {
					 X=""getUTCMilliseconds"";
					id=Id_getUTCMilliseconds;
				 }
				 else if (c=='s') {
					 X=""setUTCMilliseconds"";
					id=Id_setUTCMilliseconds;
				 }
				 else if (c=='t') {
					 c=s.charAt(8);
					 if (c=='D') {
						 X=""toLocaleDateString"";
						id=Id_toLocaleDateString;
					 }
					 else if (c=='T') {
						 X=""toLocaleTimeString"";
						id=Id_toLocaleTimeString;
					 }
				 }
				 break L;
			 }
			 if (X!=null && X!=s && !X.equals(s)) id = 0;
		 }
		 return id;
	 }
	 private static final int ConstructorId_now = -3, ConstructorId_parse = -2, ConstructorId_UTC = -1, Id_constructor = 1, Id_toString = 2, Id_toTimeString = 3, Id_toDateString = 4, Id_toLocaleString = 5, Id_toLocaleTimeString = 6, Id_toLocaleDateString = 7, Id_toUTCString = 8, Id_toSource = 9, Id_valueOf = 10, Id_getTime = 11, Id_getYear = 12, Id_getFullYear = 13, Id_getUTCFullYear = 14, Id_getMonth = 15, Id_getUTCMonth = 16, Id_getDate = 17, Id_getUTCDate = 18, Id_getDay = 19, Id_getUTCDay = 20, Id_getHours = 21, Id_getUTCHours = 22, Id_getMinutes = 23, Id_getUTCMinutes = 24, Id_getSeconds = 25, Id_getUTCSeconds = 26, Id_getMilliseconds = 27, Id_getUTCMilliseconds = 28, Id_getTimezoneOffset = 29, Id_setTime = 30, Id_setMilliseconds = 31, Id_setUTCMilliseconds = 32, Id_setSeconds = 33, Id_setUTCSeconds = 34, Id_setMinutes = 35, Id_setUTCMinutes = 36, Id_setHours = 37, Id_setUTCHours = 38, Id_setDate = 39, Id_setUTCDate = 40, Id_setMonth = 41, Id_setUTCMonth = 42, Id_setFullYear = 43, Id_setUTCFullYear = 44, Id_setYear = 45, MAX_PROTOTYPE_ID = 45;
	 private static final int Id_toGMTString = Id_toUTCString;
	 private static java.util.TimeZone thisTimeZone;
	 private static double LocalTZA;
	 private static java.text.DateFormat timeZoneFormatter;
	 private static java.text.DateFormat localeDateTimeFormatter;
	 private static java.text.DateFormat localeDateFormatter;
	 private static java.text.DateFormat localeTimeFormatter;
	 private double date;
}",1,0,0,0
"private ICompletionProposal[] getRelevantProposals( ITextViewer viewer,int offset ) throws BadLocationException{
	if ( lastProposals != null ){
		ArrayList relevantProposals = new ArrayList( 10 );
		String word = ( findWord( viewer, offset - 1 ) ).toLowerCase( );
		for ( int n = 0;
		 n < lastProposals.length;
		 n++ ){
			if ( stripQuotes( lastProposals[n].getDisplayString( ).toLowerCase( ) ).startsWith( word ) ){
				CompletionProposal proposal = new CompletionProposal( lastProposals[n].getDisplayString( ),offset - word.length( ),word.length( ),lastProposals[n].getDisplayString( ).length( ) );
				relevantProposals.add( proposal );
			}
		}
		if ( relevantProposals.size( ) > 0 ){
			return (ICompletionProposal[]) relevantProposals.toArray( new ICompletionProposal[]{
			}
			 );
		}
	}
	return null;
}",0,0,1,0
"public class UnsuitableDocumentException extends RatDocumentAnalysisException {
	 private static final long serialVersionUID = 4202800209654402733L;
	 public UnsuitableDocumentException() {
		 super(""This document is unsuitable for analysis"");
	 }
	 public UnsuitableDocumentException(String msg, Throwable cause) {
		 super(msg, cause);
	 }
	 public UnsuitableDocumentException(String msg) {
		 super(msg);
	 }
	 public UnsuitableDocumentException(Throwable cause) {
		 super(cause);
	 }
}",0,0,0,0
"public static File tryGetManifest(ColumnFamilyStore cfs) {
	 return cfs.directories.tryGetLeveledManifest();
 }",0,0,0,0
"protected HttpMethod submitLanguageSelectionForm(HttpMethod logonMethod) throws IOException {
	 PostMethod postLanguageFormMethod;
	 HtmlCleaner cleaner = new HtmlCleaner();
	 try {
		 TagNode node = cleaner.clean(logonMethod.getResponseBodyAsStream());
		 List forms = node.getElementListByName(""form"", true);
		 TagNode languageForm;
		 if (forms.size() == 1) {
			 languageForm = (TagNode) forms.get(0);
		 }
		 else {
			 throw new IOException(""Form not found"");
		 }
		 String languageMethodPath = languageForm.getAttributeByName(""action"");
		 postLanguageFormMethod = new PostMethod(getAbsoluteUri(logonMethod, languageMethodPath));
		 List inputList = languageForm.getElementListByName(""input"", true);
		 for (Object input : inputList) {
			 String name = ((TagNode) input).getAttributeByName(""name"");
			 String value = ((TagNode) input).getAttributeByName(""value"");
			 if (name != null && value != null) {
				 postLanguageFormMethod.addParameter(name, value);
			 }
		 }
		 List selectList = languageForm.getElementListByName(""select"", true);
		 for (Object select : selectList) {
			 String name = ((TagNode) select).getAttributeByName(""name"");
			 List optionList = ((TagNode) select).getElementListByName(""option"", true);
			 String value = null;
			 for (Object option : optionList) {
				 if (((TagNode) option).getAttributeByName(""selected"") != null) {
					 value = ((TagNode) option).getAttributeByName(""value"");
					 break;
				 }
			 }
			 if (name != null && value != null) {
				 postLanguageFormMethod.addParameter(name, value);
			 }
		 }
	 }
	 catch (IOException e) {
		 String errorMessage = ""Error parsing language selection form at "" + logonMethod.getURI();
		 LOGGER.error(errorMessage);
		 throw new IOException(errorMessage);
	 }
	 finally {
		 logonMethod.releaseConnection();
	 }
	 return DavGatewayHttpClientFacade.executeFollowRedirects(httpClient, postLanguageFormMethod);
 }",0,0,1,0
"public class WebClientOutput {
	 private final int statusCode;
	 private final String content;
	 private final Boolean isSuccessStatusCode;
	 private final Exception clientSideException;
	 public WebClientOutput(int statusCode, String content, Boolean isSuccessStatusCode) {
		 this(statusCode, content, isSuccessStatusCode, null);
	 }
	 public WebClientOutput(int statusCode, String content, Boolean isSuccessStatusCode, Exception clientSideException) {
		 this.statusCode = statusCode;
		 this.content = content;
		 this.isSuccessStatusCode = isSuccessStatusCode;
		 this.clientSideException = clientSideException;
	 }
	 public int getStatusCode() {
		 return statusCode;
	 }
	 public String getContent() {
		 return content;
	 }
	 public Boolean isSuccessStatusCode() {
		 return isSuccessStatusCode;
	 }
	 public Exception getClientSideException() {
		 return clientSideException;
	 }
	 public String toString() {
		 return String.format( ""HttpStatusCode: %2$s%1$sContent: %3$s%1$sIsSuccessStatusCode: %4$s%1$sClientSideException: %5$s"", ""\n"", statusCode, content, isSuccessStatusCode, clientSideException);
	 }
}",0,0,0,0
"public int summarize() {
	 System.out.println(Integer.toString(errorCount) + "" inconsistencies detected."");
	 if (errorCount == 0) {
		 System.out.println(""Status: OK"");
		 return 0;
	 }
	 else {
		 System.out.println(""Status: INCONSISTENT"");
		 return -1;
	 }
 }",0,0,0,0
"public class Customer1131 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer1131() {
	}
	public Customer1131(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer1131[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"public class jlink {
	 private static final int BUFFER_SIZE = 8192;
	 private static final int VECTOR_INIT_SIZE = 10;
	 private String outfile = null;
	 private Vector mergefiles = new Vector(VECTOR_INIT_SIZE);
	 private Vector addfiles = new Vector(VECTOR_INIT_SIZE);
	 private boolean compression = false;
	 byte[] buffer = new byte[BUFFER_SIZE];
	 public void setOutfile(String outfile) {
		 if (outfile == null) {
			 return;
		 }
		 this.outfile = outfile;
	 }
	 public void addMergeFile(String fileToMerge) {
		 if (fileToMerge == null) {
			 return;
		 }
		 mergefiles.addElement(fileToMerge);
	 }
	 public void addAddFile(String fileToAdd) {
		 if (fileToAdd == null) {
			 return;
		 }
		 addfiles.addElement(fileToAdd);
	 }
	 public void addMergeFiles(String[] filesToMerge) {
		 if (filesToMerge == null) {
			 return;
		 }
		 for (int i = 0;
		 i < filesToMerge.length;
		 i++) {
			 addMergeFile(filesToMerge[i]);
		 }
	 }
	 public void addAddFiles(String[] filesToAdd) {
		 if (filesToAdd == null) {
			 return;
		 }
		 for (int i = 0;
		 i < filesToAdd.length;
		 i++) {
			 addAddFile(filesToAdd[i]);
		 }
	 }
	 public void setCompression(boolean compress) {
		 this.compression = compress;
	 }
	 public void link() throws Exception {
		 ZipOutputStream output = new ZipOutputStream(new FileOutputStream(outfile));
		 if (compression) {
			 output.setMethod(ZipOutputStream.DEFLATED);
			 output.setLevel(Deflater.DEFAULT_COMPRESSION);
		 }
		 else {
			 output.setMethod(ZipOutputStream.STORED);
		 }
		 Enumeration merges = mergefiles.elements();
		 while (merges.hasMoreElements()) {
			 String path = (String) merges.nextElement();
			 File f = new File(path);
			 if (f.getName().endsWith("".jar"") || f.getName().endsWith("".zip"")) {
				 mergeZipJarContents(output, f);
			 }
			 else {
				 addAddFile(path);
			 }
		 }
		 Enumeration adds = addfiles.elements();
		 while (adds.hasMoreElements()) {
			 String name = (String) adds.nextElement();
			 File f = new File(name);
			 if (f.isDirectory()) {
				 addDirContents(output, f, f.getName() + '/', compression);
			 }
			 else {
				 addFile(output, f, """", compression);
			 }
		 }
		 FileUtils.close(output);
	 }
	 public static void main(String[] args) {
		 if (args.length < 2) {
			 System.out.println(""usage: jlink output input1 ... inputN"");
			 System.exit(1);
		 }
		 jlink linker = new jlink();
		 linker.setOutfile(args[0]);
		 for (int i = 1;
		 i < args.length;
		 i++) {
			 linker.addMergeFile(args[i]);
		 }
		 try {
			 linker.link();
		 }
		 catch (Exception ex) {
			 System.err.print(ex.getMessage());
		 }
	 }
	 private void mergeZipJarContents(ZipOutputStream output, File f) throws IOException {
		 if (!f.exists()) {
			 return;
		 }
		 ZipFile zipf = new ZipFile(f);
		 Enumeration entries = zipf.entries();
		 while (entries.hasMoreElements()) {
			 ZipEntry inputEntry = (ZipEntry) entries.nextElement();
			 String inputEntryName = inputEntry.getName();
			 int index = inputEntryName.indexOf(""META-INF"");
			 if (index < 0) {
				 try {
					 output.putNextEntry(processEntry(zipf, inputEntry));
				 }
				 catch (ZipException ex) {
					 String mess = ex.getMessage();
					 if (mess.indexOf(""duplicate"") >= 0) {
						 continue;
					 }
					 else {
						 throw ex;
					 }
				 }
				 InputStream in = zipf.getInputStream(inputEntry);
				 int len = buffer.length;
				 int count = -1;
				 while ((count = in.read(buffer, 0, len)) > 0) {
					 output.write(buffer, 0, count);
				 }
				 in.close();
				 output.closeEntry();
			 }
		 }
		 zipf.close();
	 }
	 private void addDirContents(ZipOutputStream output, File dir, String prefix, boolean compress) throws IOException {
		 String[] contents = dir.list();
		 for (int i = 0;
		 i < contents.length;
		 ++i) {
			 String name = contents[i];
			 File file = new File(dir, name);
			 if (file.isDirectory()) {
				 addDirContents(output, file, prefix + name + '/', compress);
			 }
			 else {
				 addFile(output, file, prefix, compress);
			 }
		 }
	 }
	 private String getEntryName(File file, String prefix) {
		 String name = file.getName();
		 if (!name.endsWith("".class"")) {
			 InputStream input = null;
			 try {
				 input = new FileInputStream(file);
				 String className = ClassNameReader.getClassName(input);
				 if (className != null) {
					 return className.replace('.', '/') + "".class"";
				 }
			 }
			 catch (IOException ioe) {
			 }
			 finally {
				 if (input != null) {
					 try {
						 input.close();
					 }
					 catch (IOException e) {
					 }
				 }
			 }
		 }
		 System.out.println(""From "" + file.getPath() + "" and prefix "" + prefix + "", creating entry "" + prefix + name);
		 return (prefix + name);
	 }
	 private void addFile(ZipOutputStream output, File file, String prefix, boolean compress) throws IOException {
		 if (!file.exists()) {
			 return;
		 }
		 ZipEntry entry = new ZipEntry(getEntryName(file, prefix));
		 entry.setTime(file.lastModified());
		 entry.setSize(file.length());
		 if (!compress) {
			 entry.setCrc(calcChecksum(file));
		 }
		 FileInputStream input = new FileInputStream(file);
		 addToOutputStream(output, input, entry);
	 }
	 private void addToOutputStream(ZipOutputStream output, InputStream input, ZipEntry ze) throws IOException {
		 try {
			 output.putNextEntry(ze);
		 }
		 catch (ZipException zipEx) {
			 input.close();
			 return;
		 }
		 int numBytes = -1;
		 while ((numBytes = input.read(buffer)) > 0) {
			 output.write(buffer, 0, numBytes);
		 }
		 output.closeEntry();
		 input.close();
	 }
	 private ZipEntry processEntry(ZipFile zip, ZipEntry inputEntry) {
		 String name = inputEntry.getName();
		 if (!(inputEntry.isDirectory() || name.endsWith("".class""))) {
			 try {
				 InputStream input = zip.getInputStream(zip.getEntry(name));
				 String className = ClassNameReader.getClassName(input);
				 input.close();
				 if (className != null) {
					 name = className.replace('.', '/') + "".class"";
				 }
			 }
			 catch (IOException ioe) {
			 }
		 }
		 ZipEntry outputEntry = new ZipEntry(name);
		 outputEntry.setTime(inputEntry.getTime());
		 outputEntry.setExtra(inputEntry.getExtra());
		 outputEntry.setComment(inputEntry.getComment());
		 outputEntry.setTime(inputEntry.getTime());
		 if (compression) {
			 outputEntry.setMethod(ZipEntry.DEFLATED);
		 }
		 else {
			 outputEntry.setMethod(ZipEntry.STORED);
			 outputEntry.setCrc(inputEntry.getCrc());
			 outputEntry.setSize(inputEntry.getSize());
		 }
		 return outputEntry;
	 }
	 private long calcChecksum(File f) throws IOException {
		 BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));
		 return calcChecksum(in);
	 }
	 private long calcChecksum(InputStream in) throws IOException {
		 CRC32 crc = new CRC32();
		 int len = buffer.length;
		 int count = -1;
		 int haveRead = 0;
		 while ((count = in.read(buffer, 0, len)) > 0) {
			 haveRead += count;
			 crc.update(buffer, 0, count);
		 }
		 in.close();
		 return crc.getValue();
	 }
}",0,0,0,0
"public abstract class ContextualView extends JPanel {
	public abstract JComponent getMainFrame();
	public abstract String getViewTitle();
	public Action getConfigureAction(Frame owner) {
		return null;
	}
	public void initView() {
		setLayout(new BorderLayout());
		add(getMainFrame(), CENTER);
		setName(getViewTitle());
	}
	public abstract void refreshView();
	public abstract int getPreferredPosition();
	public static String getTextFromDepth(String kind, Integer depth) {
		String labelText = ""The last prediction said the "" + kind;
		if (depth == null) {
			labelText += "" would not transmit a value"";
		}
		 else if (depth == -1) {
			labelText += "" was invalid/unpredicted"";
		}
		 else if (depth == 0) {
			labelText += "" would carry a single value"";
		}
		 else {
			labelText += "" would carry a list of depth "" + depth;
		}
		return labelText;
	}
}",0,0,0,0
"private static class registerApplicationInterface_resultTupleSchemeFactory implements SchemeFactory {
	 public registerApplicationInterface_resultTupleScheme getScheme() {
		 return new registerApplicationInterface_resultTupleScheme();
	 }
 }",0,0,0,0
"static public String makeProperties(File basedir, JSmoothModelBean obj) {
	StringBuffer out = new StringBuffer();
	addPair(""arguments"", obj.getArguments(), out);
	addPair(""mainclassname"", obj.getMainClassName(), out);
	addPair(""jvmsearch"", makePathConc(obj.getJVMSearchPath()), out);
	addPair(""minversion"", obj.getMinimumVersion(), out);
	addPair(""maxversion"", obj.getMaximumVersion(), out);
	addPair(""currentdir"", obj.getCurrentDirectory(), out);
	if (obj.getEmbeddedJar() && (obj.getJarLocation().trim().length() > 0)) {
		addPair(""embedjar"", ""true"", out);
	 }
	else {
		addPair(""embedjar"", ""false"", out);
	 }
	if (obj.getMaximumMemoryHeap() > 1) {
		addPair(""maxheap"", Integer.toString(obj.getMaximumMemoryHeap()), out);
	 }
	if (obj.getInitialMemoryHeap() > 1) {
		addPair(""initialheap"", Integer.toString(obj.getInitialMemoryHeap()), out);
	 }
	File curdir = new File(obj.getExecutableName()).getParentFile();
	if (curdir == null) curdir = basedir.getAbsoluteFile();
	if (curdir.isAbsolute() == false) {
		curdir = new File(basedir, curdir.toString());
	 }
	if (obj.getCurrentDirectory() != null) {
		File newcurdir = new File(obj.getCurrentDirectory());
		if ( ! ""${
		EXECUTABLEPATH}
		"".equalsIgnoreCase(obj.getCurrentDirectory())) {
			if (newcurdir.isAbsolute() == false) {
				curdir = new File(curdir, newcurdir.toString());
			 }
			else curdir = newcurdir;
		 }
	 }
	if (obj.getBundledJVMPath() != null) addPair(""bundledvm"", getRenormalizedPathIfNeeded(obj.getBundledJVMPath(), basedir, curdir), out);
	 if (obj.getClassPath() != null) {
		 String[] relcp = new String[obj.getClassPath().length];
		 for (int i=0;
		 i<relcp.length;
		 i++) {
			 relcp[i] = getRenormalizedPathIfNeeded(obj.getClassPath()[i], basedir, curdir);
		 }
		 addPair(""classpath"", makePathConc(relcp), out);
	 }
	if (obj.getSkeletonProperties() != null) {
		for (int i=0;
		 i<obj.getSkeletonProperties().length;
		 i++) {
			JSmoothModelBean.Property prop = obj.getSkeletonProperties()[i];
			if (prop.getKey() != null) {
				String val = prop.getValue();
				if (val == null) val = """";
				addPair(""skel_"" + prop.getKey(), val, out);
			 }
		 }
	 }
	JavaPropertyPair[] javapairs = obj.getJavaProperties();
	 if (javapairs != null) {
		 addPair(""javapropertiescount"", new Integer(javapairs.length).toString(), out);
		 for (int i=0;
		 i<javapairs.length;
		 i++) {
			 addPair(""javaproperty_name_"" + i, javapairs[i].getName(), out);
			 addPair(""javaproperty_value_"" + i, javapairs[i].getValue(), out);
		 }
	 }
	return out.toString();
 }",0,0,1,0
"public abstract class AbstractCompendiumHandler extends ServiceTracker implements MBeanHandler {
	 protected final JMXAgentContext agentContext;
	 protected StandardMBean mbean;
	 protected final AtomicLong trackedId = new AtomicLong();
	 protected AbstractCompendiumHandler(JMXAgentContext agentContext, Filter filter) {
		 super(agentContext.getBundleContext(), filter, null);
		 this.agentContext = agentContext;
	 }
	 protected AbstractCompendiumHandler(JMXAgentContext agentContext, String clazz) {
		 super(agentContext.getBundleContext(), clazz, null);
		 this.agentContext = agentContext;
	 }
	 public Object addingService(ServiceReference reference) {
		 Logger logger = agentContext.getLogger();
		 Object trackedService = null;
		 long serviceId = (Long) reference.getProperty(Constants.SERVICE_ID);
		 if (trackedId.compareAndSet(0, serviceId)) {
			 logger.log(LogService.LOG_INFO, ""Registering MBean with ObjectName ["" + getName() + ""] for service with "" + Constants.SERVICE_ID + "" ["" + serviceId + ""]"");
			 trackedService = context.getService(reference);
			 mbean = constructInjectMBean(trackedService);
			 agentContext.registerMBean(AbstractCompendiumHandler.this);
		 }
		 else {
			 String serviceDescription = getServiceDescription(reference);
			 logger.log(LogService.LOG_WARNING, ""Detected secondary ServiceReference for ["" + serviceDescription + ""] with "" + Constants.SERVICE_ID + "" ["" + serviceId + ""] Only 1 instance will be JMX managed"");
		 }
		 return trackedService;
	 }
	 public void removedService(ServiceReference reference, Object service) {
		 Logger logger = agentContext.getLogger();
		 long serviceID = (Long) reference.getProperty(Constants.SERVICE_ID);
		 if (trackedId.compareAndSet(serviceID, 0)) {
			 logger.log(LogService.LOG_INFO, ""Unregistering MBean with ObjectName ["" + getName() + ""] for service with "" + Constants.SERVICE_ID + "" ["" + serviceID + ""]"");
			 agentContext.unregisterMBean(AbstractCompendiumHandler.this);
			 context.ungetService(reference);
		 }
		 else {
			 String serviceDescription = getServiceDescription(reference);
			 logger.log(LogService.LOG_WARNING, ""ServiceReference for ["" + serviceDescription + ""] with "" + Constants.SERVICE_ID + "" ["" + serviceID + ""] is not currently JMX managed"");
		 }
	 }
	 private String getServiceDescription(ServiceReference reference) {
		 String serviceDescription = (String) reference.getProperty(Constants.SERVICE_DESCRIPTION);
		 if (serviceDescription == null) {
			 Object obj = reference.getProperty(Constants.OBJECTCLASS);
			 if (obj instanceof String[]) {
				 StringBuilder sb = new StringBuilder();
				 for (String s : (String[]) obj) {
					 if (sb.length() > 0) {
						 sb.append("", "");
					 }
					 sb.append(s);
				 }
				 serviceDescription = sb.toString();
			 }
			 else {
				 serviceDescription = obj.toString();
			 }
		 }
		 return serviceDescription;
	 }
	 public StandardMBean getMbean() {
		 return mbean;
	 }
	 protected abstract StandardMBean constructInjectMBean(Object targetService);
	 protected abstract String getBaseName();
	 public String getName() {
		 return ObjectNameUtils.createFullObjectName(context, getBaseName());
	 }
}",1,0,0,0
"private static class createJob_resultStandardScheme extends StandardScheme<createJob_result> {
	 public void read(org.apache.thrift.protocol.TProtocol iprot, createJob_result struct) throws org.apache.thrift.TException {
		 org.apache.thrift.protocol.TField schemeField;
		 iprot.readStructBegin();
		 while (true) {
			 schemeField = iprot.readFieldBegin();
			 if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {
				 break;
			 }
			 switch (schemeField.id) {
				 case 0: if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
					 struct.success = new Response();
					 struct.success.read(iprot);
					 struct.setSuccessIsSet(true);
				 }
				 else {
					 org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
				 }
				 break;
				 default: org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
			 }
			 iprot.readFieldEnd();
		 }
		 iprot.readStructEnd();
		 struct.validate();
	 }
	 public void write(org.apache.thrift.protocol.TProtocol oprot, createJob_result struct) throws org.apache.thrift.TException {
		 struct.validate();
		 oprot.writeStructBegin(STRUCT_DESC);
		 if (struct.success != null) {
			 oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
			 struct.success.write(oprot);
			 oprot.writeFieldEnd();
		 }
		 oprot.writeFieldStop();
		 oprot.writeStructEnd();
	 }
 }",1,0,0,0
"public class LayoutContext {
	public static final String LAYOUT_ALGORITHM_PROPERTY = ""layoutAlgorithm"";
	private ObjectProperty<ILayoutAlgorithm> layoutAlgorithmProperty = new SimpleObjectProperty<>(this, LAYOUT_ALGORITHM_PROPERTY);
	private Graph graph;
	private final List<Runnable> postLayoutPass = new ArrayList<>();
	private final List<Runnable> preLayoutPass = new ArrayList<>();
	private final List<ILayoutFilter> layoutFilters = new ArrayList<>();
	public void addLayoutFilter(ILayoutFilter layoutFilter) {
		layoutFilters.add(layoutFilter);
	}
	public void applyLayout(boolean clear) {
		ILayoutAlgorithm layoutAlgorithm = layoutAlgorithmProperty.get();
		if (layoutAlgorithm != null) {
			preLayout();
			layoutAlgorithm.applyLayout(this, clear);
			postLayout();
		}
	}
	public void postLayout() {
		for (Runnable r : new ArrayList<>(postLayoutPass)) {
			r.run();
		}
	}
	public void preLayout() {
		for (Runnable r : preLayoutPass) {
			r.run();
		}
	}
	public Graph getGraph() {
		return graph;
	}
	public void setGraph(Graph graph) {
		if (graph == null) {
			graph = new Graph();
		}
		this.graph = graph;
	}
	public Node[] getNodes() {
		ObservableList<Node> nodes = graph.getNodes();
		List<Node> layoutRelevantNodes = new ArrayList<>();
		for (Node n : nodes) {
			if (!isLayoutIrrelevant(n)) {
				layoutRelevantNodes.add(n);
			}
		}
		return layoutRelevantNodes.toArray(new Node[] {
		}
		);
	}
	public Edge[] getEdges() {
		ObservableList<Edge> edges = graph.getEdges();
		List<Edge> layoutRelevantEdges = new ArrayList<>();
		for (Edge e : edges) {
			if (!isLayoutIrrelevant(e)) {
				layoutRelevantEdges.add(e);
			}
		}
		return layoutRelevantEdges.toArray(new Edge[] {
		}
		);
	}
	public ILayoutAlgorithm getLayoutAlgorithm() {
		return layoutAlgorithmProperty.get();
	}
	public boolean isLayoutIrrelevant(Edge edge) {
		for (ILayoutFilter filter : layoutFilters) {
			if (filter.isLayoutIrrelevant(edge)) {
				return true;
			}
		}
		return false;
	}
	public boolean isLayoutIrrelevant(Node nodeLayout) {
		for (ILayoutFilter filter : layoutFilters) {
			if (filter.isLayoutIrrelevant(nodeLayout)) {
				return true;
			}
		}
		return false;
	}
	public ObjectProperty<ILayoutAlgorithm> layoutAlgorithmProperty() {
		return layoutAlgorithmProperty;
	}
	;
	public void removeLayoutFilter(ILayoutFilter layoutFilter) {
		layoutFilters.remove(layoutFilter);
	}
	public void schedulePostLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (!postLayoutPass.contains(runnable)) {
			postLayoutPass.add(runnable);
		}
	}
	public void schedulePreLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (!preLayoutPass.contains(runnable)) {
			preLayoutPass.add(runnable);
		}
	}
	public void setLayoutAlgorithm(ILayoutAlgorithm algorithm) {
		layoutAlgorithmProperty.set(algorithm);
	}
	public void unschedulePostLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (postLayoutPass.contains(runnable)) {
			postLayoutPass.remove(runnable);
		}
	}
	public void unschedulePreLayoutPass(Runnable runnable) {
		if (runnable == null) {
			throw new IllegalArgumentException(""Runnable may not be null."");
		}
		if (preLayoutPass.contains(runnable)) {
			preLayoutPass.remove(runnable);
		}
	}
}",1,0,0,0
"class Whitespace implements Text {
	 private String text;
	 public Whitespace(String text) {
		 this.text = text;
	 }
	 public String getText() {
		 return text;
	 }
 }",0,1,0,0
"public void send() {
	 try {
		 Properties props = new Properties();
		 props.put(""mail.smtp.host"", host);
		 props.put(""mail.smtp.port"", String.valueOf(port));
		 Session sesh;
		 Authenticator auth = null;
		 if (SSL) {
			 try {
				 Provider p = (Provider) Class.forName( ""com.sun.net.ssl.internal.ssl.Provider"").newInstance();
				 Security.addProvider(p);
			 }
			 catch (Exception e) {
				 throw new BuildException(""could not instantiate ssl "" + ""security provider, check that you have JSSE in "" + ""your classpath"");
			 }
			 props.put(""mail.smtp.socketFactory.class"", SSL_FACTORY);
			 props.put(""mail.smtp.socketFactory.fallback"", ""false"");
			 if (isPortExplicitlySpecified()) {
				 props.put(""mail.smtp.socketFactory.port"", String.valueOf(port));
			 }
		 }
		 if (user != null || password != null) {
			 props.put(""mail.smtp.auth"", ""true"");
			 auth = new SimpleAuthenticator(user, password);
		 }
		 if (isStartTLSEnabled()) {
			 props.put(""mail.smtp.starttls.enable"", ""true"");
		 }
		 sesh = Session.getInstance(props, auth);
		 MimeMessage msg = new MimeMessage(sesh);
		 MimeMultipart attachments = new MimeMultipart();
		 if (from.getName() == null) {
			 msg.setFrom(new InternetAddress(from.getAddress()));
		 }
		 else {
			 msg.setFrom(new InternetAddress(from.getAddress(), from.getName()));
		 }
		 msg.setReplyTo(internetAddresses(replyToList));
		 msg.setRecipients(Message.RecipientType.TO, internetAddresses(toList));
		 msg.setRecipients(Message.RecipientType.CC, internetAddresses(ccList));
		 msg.setRecipients(Message.RecipientType.BCC, internetAddresses(bccList));
		 String charset = parseCharSetFromMimeType(message.getMimeType());
		 if (charset != null) {
			 message.setCharset(charset);
		 }
		 else {
			 charset = message.getCharset();
			 if (charset == null) {
				 charset = DEFAULT_CHARSET;
				 message.setCharset(charset);
			 }
		 }
		 StringDataSource sds = new StringDataSource();
		 sds.setContentType(message.getMimeType());
		 sds.setCharset(charset);
		 if (subject != null) {
			 msg.setSubject(subject, charset);
		 }
		 msg.addHeader(""Date"", getDate());
		 if (headers != null) {
			 for (Iterator iter = headers.iterator();
			 iter.hasNext();
			) {
				 Header h = (Header) iter.next();
				 msg.addHeader(h.getName(), h.getValue());
			 }
		 }
		 PrintStream out = new PrintStream(sds.getOutputStream());
		 message.print(out);
		 out.close();
		 MimeBodyPart textbody = new MimeBodyPart();
		 textbody.setDataHandler(new DataHandler(sds));
		 attachments.addBodyPart(textbody);
		 Enumeration e = files.elements();
		 while (e.hasMoreElements()) {
			 File file = (File) e.nextElement();
			 MimeBodyPart body;
			 body = new MimeBodyPart();
			 if (!file.exists() || !file.canRead()) {
				 throw new BuildException(""File \"""" + file.getAbsolutePath() + ""\"" does not exist or is not "" + ""readable."");
			 }
			 FileDataSource fileData = new FileDataSource(file);
			 DataHandler fileDataHandler = new DataHandler(fileData);
			 body.setDataHandler(fileDataHandler);
			 body.setFileName(file.getName());
			 attachments.addBodyPart(body);
		 }
		 msg.setContent(attachments);
		 try {
			 Transport transport = sesh.getTransport(SSL ? ""smtps"" : ""smtp"");
			 transport.connect(host, user, password);
			 transport.sendMessage(msg, msg.getAllRecipients());
		 }
		 catch (SendFailedException sfe) {
			 if (!shouldIgnoreInvalidRecipients()) {
				 throw new BuildException(GENERIC_ERROR, sfe);
			 }
			 else if (sfe.getValidSentAddresses() == null || sfe.getValidSentAddresses().length == 0) {
				 throw new BuildException(""Couldn't reach any recipient"", sfe);
			 }
			 else {
				 Address[] invalid = sfe.getInvalidAddresses();
				 if (invalid == null) {
					 invalid = new Address[0];
				 }
				 for (int i = 0;
				 i < invalid.length;
				 i++) {
					 didntReach(invalid[i], ""invalid"", sfe);
				 }
				 Address[] validUnsent = sfe.getValidUnsentAddresses();
				 if (validUnsent == null) {
					 validUnsent = new Address[0];
				 }
				 for (int i = 0;
				 i < validUnsent.length;
				 i++) {
					 didntReach(validUnsent[i], ""valid"", sfe);
				 }
			 }
		 }
	 }
	 catch (MessagingException e) {
		 throw new BuildException(GENERIC_ERROR, e);
	 }
	 catch (IOException e) {
		 throw new BuildException(GENERIC_ERROR, e);
	 }
 }",0,0,1,0
"private void proccessOverReplicatedBlock( Block block, short replication ) {
	 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
	 if( containingNodes == null ) return;
	 Vector nonExcess = new Vector();
	 for (Iterator it = containingNodes.iterator();
	 it.hasNext();
	 ) {
		 DatanodeInfo cur = (DatanodeInfo) it.next();
		 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get(cur.getStorageID());
		 if (excessBlocks == null || ! excessBlocks.contains(block)) {
			 nonExcess.add(cur);
		 }
	 }
	 chooseExcessReplicates(nonExcess, block, replication);
 }",0,0,0,0
"public class XPathConstants {
	 private XPathConstants() {
	 }
 public static final QName NUMBER = new QName(""http: public static final QName STRING = new QName(""http: public static final QName BOOLEAN = new QName(""http: public static final QName NODESET = new QName(""http: public static final QName NODE = new QName(""http: public static final String DOM_OBJECT_MODEL = ""http:}",0,1,0,0
"public InetAddress getFrom() {
	 return from;
 }",0,0,0,0
"public interface IResultSet{
	public IEdgeAxis getRowEdgeResult( );
	public IEdgeAxis getColumnEdgeResult( );
	public IEdgeAxis getPageEdgeResult( );
	public IEdgeAxis[] getMeasureResult( );
	public IEdgeAxis getMeasureResult( String name ) throws DataException;
}",0,0,0,0
"public Boolean compose(ByteBuffer bytes) {
	 return JdbcBoolean.instance.compose(bytes);
 }",0,0,0,0
"public final class PropertyResolver{
	private final static int RETURN_NULL = 0;
	private final static int CREATE_NEW_VALUE = 1;
	private final static int RESOLVE_CLASS = 2;
	private final static Map<Object, IClassCache> applicationToClassesToGetAndSetters = Generics.newConcurrentHashMap(2);
	private static final Logger log = LoggerFactory.getLogger(PropertyResolver.class);
	private static final String GET = ""get"";
	private static final String IS = ""is"";
	private static final String SET = ""set"";
	public final static Object getValue(final String expression, final Object object){
		if (expression == null || expression.equals("""") || object == null){
			return object;
		}
		ObjectAndGetSetter getter = getObjectAndGetSetter(expression, object, RETURN_NULL);
		if (getter == null){
			return null;
		}
		return getter.getValue();
	}
	public final static void setValue(final String expression, final Object object,final Object value, final PropertyResolverConverter converter){
		if (expression == null || expression.equals("""")){
			throw new WicketRuntimeException(""Empty expression setting value: "" + value +"" on object: "" + object);
		}
		if (object == null){
			throw new WicketRuntimeException(""Attempted to set property value on a null object. Property expression: "" +expression + "" Value: "" + value);
		}
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, CREATE_NEW_VALUE);
		if (setter == null){
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +"" for setting value: "" + value + "" on: "" + object);
		}
		setter.setValue(value, converter == null ? new PropertyResolverConverter(Application.get().getConverterLocator(), Session.get().getLocale()) : converter);
	}
	public final static Class<?> getPropertyClass(final String expression, final Object object){
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
		if (setter == null){
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +"" for getting the target classs of: "" + object);
		}
		return setter.getTargetClass();
	}
	public static <T> Class<T> getPropertyClass(final String expression, final Class<?> clz){
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, null, RESOLVE_CLASS, clz);
		if (setter == null){
			throw new WicketRuntimeException(""No Class returned for expression: "" + expression +"" for getting the target classs of: "" + clz);
		}
		return (Class<T>)setter.getTargetClass();
	}
	public final static Field getPropertyField(final String expression, final Object object){
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
		if (setter == null){
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +"" for getting the target classs of: "" + object);
		}
		return setter.getField();
	}
	public final static Method getPropertyGetter(final String expression, final Object object){
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
		if (setter == null){
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +"" for getting the target classs of: "" + object);
		}
		return setter.getGetter();
	}
	public final static Method getPropertySetter(final String expression, final Object object){
		ObjectAndGetSetter setter = getObjectAndGetSetter(expression, object, RESOLVE_CLASS);
		if (setter == null){
			throw new WicketRuntimeException(""Null object returned for expression: "" + expression +"" for getting the target classs of: "" + object);
		}
		return setter.getSetter();
	}
	private static ObjectAndGetSetter getObjectAndGetSetter(final String expression,final Object object, int tryToCreateNull){
		return getObjectAndGetSetter(expression, object, tryToCreateNull, object.getClass());
	}
	private static ObjectAndGetSetter getObjectAndGetSetter(final String expression,final Object object, final int tryToCreateNull, Class<?> clz){
		String expressionBracketsSeperated = Strings.replaceAll(expression, ""["", "".["").toString();
		int index = getNextDotIndex(expressionBracketsSeperated, 0);
		while (index == 0 && expressionBracketsSeperated.startsWith(""."")){
			expressionBracketsSeperated = expressionBracketsSeperated.substring(1);
			index = getNextDotIndex(expressionBracketsSeperated, 0);
		}
		int lastIndex = 0;
		Object value = object;
		String exp = expressionBracketsSeperated;
		while (index != -1){
			exp = expressionBracketsSeperated.substring(lastIndex, index);
			if (exp.length() == 0){
				exp = expressionBracketsSeperated.substring(index + 1);
				break;
			}
			IGetAndSet getAndSetter = null;
			try{
				getAndSetter = getGetAndSetter(exp, clz);
			}
			catch (WicketRuntimeException ex){
				index = getNextDotIndex(expressionBracketsSeperated, index + 1);
				if (index != -1){
					String indexExpression = expressionBracketsSeperated.substring(lastIndex, index);
					getAndSetter = getGetAndSetter(indexExpression, clz);
				}
				else{
					exp = expressionBracketsSeperated.substring(lastIndex);
					break;
				}
			}
			Object newValue = null;
			if (value != null){
				newValue = getAndSetter.getValue(value);
			}
			if (newValue == null){
				if (tryToCreateNull == CREATE_NEW_VALUE){
					newValue = getAndSetter.newValue(value);
					if (newValue == null){
						return null;
					}
				}
				else if (tryToCreateNull == RESOLVE_CLASS){
					clz = getAndSetter.getTargetClass();
				}
				else{
					return null;
				}
			}
			value = newValue;
			if (value != null){
				clz = value.getClass();
			}
			lastIndex = index + 1;
			index = getNextDotIndex(expressionBracketsSeperated, lastIndex);
			if (index == -1){
				exp = expressionBracketsSeperated.substring(lastIndex);
				break;
			}
		}
		IGetAndSet getAndSetter = getGetAndSetter(exp, clz);
		return new ObjectAndGetSetter(getAndSetter, value);
	}
	private static int getNextDotIndex(final String expression, final int start){
		boolean insideBracket = false;
		for (int i = start;
		 i < expression.length();
		 i++){
			char ch = expression.charAt(i);
			if (ch == '.' && !insideBracket){
				return i;
			}
			else if (ch == '['){
				insideBracket = true;
			}
			else if (ch == ']'){
				insideBracket = false;
			}
		}
		return -1;
	}
	private final static IGetAndSet getGetAndSetter(String exp, final Class<?> clz){
		IClassCache classesToGetAndSetters = getClassesToGetAndSetters();
		Map<String, IGetAndSet> getAndSetters = classesToGetAndSetters.get(clz);
		if (getAndSetters == null){
			getAndSetters = new ConcurrentHashMap<String, IGetAndSet>(8);
			classesToGetAndSetters.put(clz, getAndSetters);
		}
		IGetAndSet getAndSetter = getAndSetters.get(exp);
		if (getAndSetter == null){
			Method method = null;
			Field field = null;
			if (exp.startsWith(""["")){
				exp = exp.substring(1, exp.length() - 1);
			}
			else if (exp.endsWith(""()"")){
				method = findMethod(clz, exp);
			}
			else{
				method = findGetter(clz, exp);
			}
			if (method == null){
				if (List.class.isAssignableFrom(clz)){
					try{
						int index = Integer.parseInt(exp);
						getAndSetter = new ListGetSet(index);
					}
					catch (NumberFormatException ex){
						method = findMethod(clz, exp);
						if (method != null){
							getAndSetter = new MethodGetAndSet(method, MethodGetAndSet.findSetter(method, clz), null);
						}
						else{
							field = findField(clz, exp);
							if (field != null){
								getAndSetter = new FieldGetAndSetter(field);
							}
							else{
								throw new WicketRuntimeException(""The expression '"" +exp +""' is neither an index nor is it a method or field for the list "" +clz);
							}
						}
					}
				}
				else if (Map.class.isAssignableFrom(clz)){
					getAndSetter = new MapGetSet(exp);
				}
				else if (clz.isArray()){
					try{
						int index = Integer.parseInt(exp);
						getAndSetter = new ArrayGetSet(clz.getComponentType(), index);
					}
					catch (NumberFormatException ex){
						if (exp.equals(""length"") || exp.equals(""size"")){
							getAndSetter = new ArrayLengthGetSet();
						}
						else{
							throw new WicketRuntimeException(""Can't parse the expression '"" + exp +""' as an index for an array lookup"");
						}
					}
				}
				else{
					field = findField(clz, exp);
					if (field == null){
						method = findMethod(clz, exp);
						if (method == null){
							int index = exp.indexOf('.');
							if (index != -1){
								String propertyName = exp.substring(0, index);
								String propertyIndex = exp.substring(index + 1);
								try{
									int parsedIndex = Integer.parseInt(propertyIndex);
									String name = Character.toUpperCase(propertyName.charAt(0)) +propertyName.substring(1);
									method = clz.getMethod(GET + name, new Class[] {
									 int.class }
									);
									getAndSetter = new ArrayPropertyGetSet(method, parsedIndex);
								}
								catch (Exception e){
									throw new WicketRuntimeException(""No get method defined for class: "" + clz +"" expression: "" + propertyName);
								}
							}
							else{
								throw new WicketRuntimeException(""No get method defined for class: "" + clz + "" expression: "" +exp);
							}
						}
						else{
							getAndSetter = new MethodGetAndSet(method, MethodGetAndSet.findSetter(method, clz), field);
						}
					}
					else{
						getAndSetter = new FieldGetAndSetter(field);
					}
				}
			}
			else{
				field = findField(clz, exp);
				getAndSetter = new MethodGetAndSet(method, MethodGetAndSet.findSetter(method, clz),field);
			}
			getAndSetters.put(exp, getAndSetter);
		}
		return getAndSetter;
	}
	private static Field findField(final Class<?> clz, final String expression){
		Field field = null;
		try{
			field = clz.getField(expression);
		}
		catch (Exception e){
			Class<?> tmp = clz;
			while (tmp != null && tmp != Object.class){
				Field[] fields = tmp.getDeclaredFields();
				for (int i = 0;
				 i < fields.length;
				 i++){
					if (fields[i].getName().equals(expression)){
						fields[i].setAccessible(true);
						return fields[i];
					}
				}
				tmp = tmp.getSuperclass();
			}
			log.debug(""Cannot find field "" + clz + ""."" + expression);
		}
		return field;
	}
	private final static Method findGetter(final Class<?> clz, final String expression){
		String name = Character.toUpperCase(expression.charAt(0)) + expression.substring(1);
		Method method = null;
		try{
			method = clz.getMethod(GET + name, (Class[])null);
		}
		catch (Exception e){
		}
		if (method == null){
			try{
				method = clz.getMethod(IS + name, (Class[])null);
			}
			catch (Exception e){
				log.debug(""Cannot find getter "" + clz + ""."" + expression);
			}
		}
		return method;
	}
	private final static Method findMethod(final Class<?> clz, String expression){
		if (expression.endsWith(""()"")){
			expression = expression.substring(0, expression.length() - 2);
		}
		Method method = null;
		try{
			method = clz.getMethod(expression, (Class[])null);
		}
		catch (Exception e){
			log.debug(""Cannot find method "" + clz + ""."" + expression);
		}
		return method;
	}
	private PropertyResolver(){
	}
	private final static class ObjectAndGetSetter{
		private final IGetAndSet getAndSetter;
		private final Object value;
		public ObjectAndGetSetter(IGetAndSet getAndSetter, Object value){
			this.getAndSetter = getAndSetter;
			this.value = value;
		}
		public void setValue(Object value, PropertyResolverConverter converter){
			getAndSetter.setValue(this.value, value, converter);
		}
		public Object getValue(){
			return getAndSetter.getValue(value);
		}
		public Class<?> getTargetClass(){
			return getAndSetter.getTargetClass();
		}
		public Field getField(){
			return getAndSetter.getField();
		}
		public Method getGetter(){
			return getAndSetter.getGetter();
		}
		public Method getSetter(){
			return getAndSetter.getSetter();
		}
	}
	public static interface IGetAndSet{
		public Object getValue(final Object object);
		public Class<?> getTargetClass();
		public Object newValue(Object object);
		public void setValue(final Object object, final Object value,PropertyResolverConverter converter);
		public Field getField();
		public Method getGetter();
		public Method getSetter();
	}
	private static abstract class AbstractGetAndSet implements IGetAndSet{
		public Field getField(){
			return null;
		}
		public Method getGetter(){
			return null;
		}
		public Method getSetter(){
			return null;
		}
		public Class<?> getTargetClass(){
			return null;
		}
	}
	private static final class MapGetSet extends AbstractGetAndSet{
		private final String key;
		MapGetSet(String key){
			this.key = key;
		}
		public Object getValue(final Object object){
			return ((Map<?, ?>)object).get(key);
		}
		public void setValue(final Object object, final Object value,final PropertyResolverConverter converter){
			((Map<String, Object>)object).put(key, value);
		}
		public Object newValue(final Object object){
			return null;
		}
	}
	private static final class ListGetSet extends AbstractGetAndSet{
		final private int index;
		ListGetSet(int index){
			this.index = index;
		}
		public Object getValue(final Object object){
			if (((List<?>)object).size() <= index){
				return null;
			}
			return ((List<?>)object).get(index);
		}
		public void setValue(final Object object, final Object value,final PropertyResolverConverter converter){
			List<Object> lst = (List<Object>)object;
			if (lst.size() > index){
				lst.set(index, value);
			}
			else if (lst.size() == index){
				lst.add(value);
			}
			else{
				while (lst.size() < index){
					lst.add(null);
				}
				lst.add(value);
			}
		}
		public Object newValue(Object object){
			return null;
		}
	}
	private static final class ArrayGetSet extends AbstractGetAndSet{
		private final int index;
		private final Class<?> clzComponentType;
		ArrayGetSet(Class<?> clzComponentType, int index){
			this.clzComponentType = clzComponentType;
			this.index = index;
		}
		public Object getValue(Object object){
			if (Array.getLength(object) > index){
				return Array.get(object, index);
			}
			return null;
		}
		public void setValue(Object object, Object value, PropertyResolverConverter converter){
			value = converter.convert(value, clzComponentType);
			Array.set(object, index, value);
		}
		public Object newValue(Object object){
			Object value = null;
			try{
				value = clzComponentType.newInstance();
				Array.set(object, index, value);
			}
			catch (Exception e){
				log.warn(""Cannot set new value "" + value + "" at index "" + index +"" for array holding elements of class "" + clzComponentType, e);
			}
			return value;
		}
		public Class<?> getTargetClass(){
			return clzComponentType;
		}
	}
	private static final class ArrayLengthGetSet extends AbstractGetAndSet{
		ArrayLengthGetSet(){
		}
		public Object getValue(final Object object){
			return new Integer(Array.getLength(object));
		}
		public void setValue(final Object object, final Object value,final PropertyResolverConverter converter){
			throw new WicketRuntimeException(""You can't set the length on an array:"" + object);
		}
		public Object newValue(final Object object){
			throw new WicketRuntimeException(""Can't get a new value from a length of an array: "" +object);
		}
		public Class<?> getTargetClass(){
			return int.class;
		}
	}
	private static final class ArrayPropertyGetSet extends AbstractGetAndSet{
		final private Integer index;
		final private Method getMethod;
		private Method setMethod;
		ArrayPropertyGetSet(final Method method, final int index){
			this.index = new Integer(index);
			getMethod = method;
			getMethod.setAccessible(true);
		}
		private final static Method findSetter(final Method getMethod, final Class<?> clz){
			String name = getMethod.getName();
			name = SET + name.substring(3);
			try{
				return clz.getMethod(name, new Class[] {
				 int.class, getMethod.getReturnType() }
				);
			}
			catch (Exception e){
				log.debug(""Can't find setter method corresponding to "" + getMethod);
			}
			return null;
		}
		public Object getValue(Object object){
			Object ret = null;
			try{
				ret = getMethod.invoke(object, new Object[] {
				 index }
				);
			}
			catch (InvocationTargetException ex){
				throw new WicketRuntimeException(""Error calling index property method: "" +getMethod + "" on object: "" + object, ex.getCause());
			}
			catch (Exception ex){
				throw new WicketRuntimeException(""Error calling index property method: "" +getMethod + "" on object: "" + object, ex);
			}
			return ret;
		}
		public void setValue(final Object object, final Object value,final PropertyResolverConverter converter){
			if (setMethod == null){
				setMethod = findSetter(getMethod, object.getClass());
			}
			if (setMethod != null){
				setMethod.setAccessible(true);
				Object converted = converter.convert(value, getMethod.getReturnType());
				if (converted == null && value != null){
					throw new ConversionException(""Can't convert value: "" + value + "" to class: "" +getMethod.getReturnType() + "" for setting it on "" + object);
				}
				try{
					setMethod.invoke(object, new Object[] {
					 index, converted }
					);
				}
				catch (InvocationTargetException ex){
					throw new WicketRuntimeException(""Error index property calling method: "" +setMethod + "" on object: "" + object, ex.getCause());
				}
				catch (Exception ex){
					throw new WicketRuntimeException(""Error index property calling method: "" +setMethod + "" on object: "" + object, ex);
				}
			}
			else{
				throw new WicketRuntimeException(""No set method defined for value: "" + value +"" on object: "" + object);
			}
		}
		public Class<?> getTargetClass(){
			return getMethod.getReturnType();
		}
		public Object newValue(Object object){
			if (setMethod == null){
				setMethod = findSetter(getMethod, object.getClass());
			}
			if (setMethod == null){
				log.warn(""Null setMethod"");
				return null;
			}
			Class<?> clz = getMethod.getReturnType();
			Object value = null;
			try{
				value = clz.newInstance();
				setMethod.invoke(object, new Object[] {
				 index, value }
				);
			}
			catch (Exception e){
				log.warn(""Cannot set new value "" + value + "" at index "" + index, e);
			}
			return value;
		}
	}
	private static final class MethodGetAndSet extends AbstractGetAndSet{
		private final Method getMethod;
		private final Method setMethod;
		private final Field field;
		MethodGetAndSet(Method getMethod, Method setMethod, Field field){
			this.getMethod = getMethod;
			this.getMethod.setAccessible(true);
			this.field = field;
			this.setMethod = setMethod;
		}
		public final Object getValue(final Object object){
			Object ret = null;
			try{
				ret = getMethod.invoke(object, (Object[])null);
			}
			catch (InvocationTargetException ex){
				throw new WicketRuntimeException(""Error calling method: "" + getMethod +"" on object: "" + object, ex.getCause());
			}
			catch (Exception ex){
				throw new WicketRuntimeException(""Error calling method: "" + getMethod +"" on object: "" + object, ex);
			}
			return ret;
		}
		public final void setValue(final Object object, final Object value,PropertyResolverConverter converter){
			Class type = null;
			if (setMethod != null){
				type = getMethod.getReturnType();
			}
			else if (field != null){
				type = field.getType();
			}
			Object converted = null;
			if (type != null){
				converted = converter.convert(value, type);
				if (converted == null){
					if (value != null){
						throw new ConversionException(""Method ["" + getMethod +""]. Can't convert value: "" + value + "" to class: "" +getMethod.getReturnType() + "" for setting it on "" + object);
					}
					else if (getMethod.getReturnType().isPrimitive()){
						throw new ConversionException(""Method ["" + getMethod +""]. Can't convert null value to a primitive class: "" +getMethod.getReturnType() + "" for setting it on "" + object);
					}
				}
			}
			if (setMethod != null){
				try{
					setMethod.invoke(object, new Object[] {
					 converted }
					);
				}
				catch (InvocationTargetException ex){
					throw new WicketRuntimeException(""Error calling method: "" + setMethod +"" on object: "" + object, ex.getCause());
				}
				catch (Exception ex){
					throw new WicketRuntimeException(""Error calling method: "" + setMethod +"" on object: "" + object, ex);
				}
			}
			else if (field != null){
				try{
					field.set(object, converted);
				}
				catch (Exception ex){
					throw new WicketRuntimeException(""Error setting field: "" + field +"" on object: "" + object, ex);
				}
			}
			else{
				throw new WicketRuntimeException(""no set method defined for value: "" + value +"" on object: "" + object + "" while respective getMethod being "" +getMethod.getName());
			}
		}
		private final static Method findSetter(Method getMethod, Class<?> clz){
			String name = getMethod.getName();
			if (name.startsWith(GET)){
				name = SET + name.substring(3);
			}
			else{
				name = SET + name.substring(2);
			}
			try{
				Method method = clz.getMethod(name, new Class[] {
				 getMethod.getReturnType() }
				);
				if (method != null){
					method.setAccessible(true);
				}
				return method;
			}
			catch (NoSuchMethodException e){
				Method[] methods = clz.getMethods();
				for (int i = 0;
				 i < methods.length;
				 i++){
					if (methods[i].getName().equals(name)){
						Class<?>[] parameterTypes = methods[i].getParameterTypes();
						if (parameterTypes.length == 1){
							if (parameterTypes[0].isAssignableFrom(getMethod.getReturnType())){
								return methods[i];
							}
						}
					}
				}
				log.debug(""Cannot find setter corresponding to "" + getMethod);
			}
			catch (Exception e){
				log.debug(""Cannot find setter corresponding to "" + getMethod);
			}
			return null;
		}
		public Object newValue(Object object){
			if (setMethod == null){
				log.warn(""Null setMethod"");
				return null;
			}
			Class<?> clz = getMethod.getReturnType();
			Object value = null;
			try{
				value = clz.newInstance();
				setMethod.invoke(object, new Object[] {
				 value }
				);
			}
			catch (Exception e){
				log.warn(""Cannot set new value "" + value, e);
			}
			return value;
		}
		public Class<?> getTargetClass(){
			return getMethod.getReturnType();
		}
		public Method getGetter(){
			return getMethod;
		}
		public Method getSetter(){
			return setMethod;
		}
		public Field getField(){
			return field;
		}
	}
	private static class FieldGetAndSetter extends AbstractGetAndSet{
		private final Field field;
		public FieldGetAndSetter(final Field field){
			super();
			this.field = field;
			this.field.setAccessible(true);
		}
		public Object getValue(final Object object){
			try{
				return field.get(object);
			}
			catch (Exception ex){
				throw new WicketRuntimeException(""Error getting field value of field "" + field +"" from object "" + object, ex);
			}
		}
		public Object newValue(final Object object){
			Class<?> clz = field.getType();
			Object value = null;
			try{
				value = clz.newInstance();
				field.set(object, value);
			}
			catch (Exception e){
				log.warn(""Cannot set field "" + field + "" to "" + value, e);
			}
			return value;
		}
		public void setValue(final Object object, Object value,final PropertyResolverConverter converter){
			value = converter.convert(value, field.getType());
			try{
				field.set(object, value);
			}
			catch (Exception ex){
				throw new WicketRuntimeException(""Error setting field value of field "" + field +"" on object "" + object + "", value "" + value, ex);
			}
		}
		public Class<?> getTargetClass(){
			return field.getType();
		}
		public Field getField(){
			return field;
		}
	}
	private static IClassCache getClassesToGetAndSetters(){
		Object key = null;
		if (Application.exists()){
			key = Application.get();
		}
		else{
			key = PropertyResolver.class;
		}
		IClassCache result = applicationToClassesToGetAndSetters.get(key);
		if (result == null){
			applicationToClassesToGetAndSetters.put(key, result = new DefaultClassCache());
		}
		return result;
	}
	public static void destroy(Application application){
		applicationToClassesToGetAndSetters.remove(application);
	}
	public static void setClassCache(final Application application, final IClassCache classCache){
		if (application != null){
			applicationToClassesToGetAndSetters.put(application, classCache);
		}
		else{
			applicationToClassesToGetAndSetters.put(PropertyResolver.class, classCache);
		}
	}
	public static interface IClassCache{
		void put(Class<?> clz, Map<String, IGetAndSet> values);
		Map<String, IGetAndSet> get(Class<?> clz);
	}
	private static class DefaultClassCache implements IClassCache{
		private final ConcurrentHashMap<Class<?>, Map<String, IGetAndSet>> map = Generics.newConcurrentHashMap(16);
		public Map<String, IGetAndSet> get(Class<?> clz){
			return map.get(clz);
		}
		public void put(Class<?> clz, Map<String, IGetAndSet> values){
			map.put(clz, values);
		}
	}
}",0,0,0,0
"public class ClassFileWriter {
	 public ClassFileWriter(String className, String superClassName, String sourceFileName) {
		 generatedClassName = className;
		 itsConstantPool = new ConstantPool(this);
		 itsThisClassIndex = itsConstantPool.addClass(className);
		 itsSuperClassIndex = itsConstantPool.addClass(superClassName);
		 if (sourceFileName != null) itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);
		 itsFlags = ACC_PUBLIC;
	 }
	 public final String getClassName() {
		 return generatedClassName;
	 }
	 public void addInterface(String interfaceName) {
		 short interfaceIndex = itsConstantPool.addClass(interfaceName);
		 itsInterfaces.add(new Short(interfaceIndex));
	 }
	 public static final short ACC_PUBLIC = 0x0001, ACC_PRIVATE = 0x0002, ACC_PROTECTED = 0x0004, ACC_STATIC = 0x0008, ACC_FINAL = 0x0010, ACC_SYNCHRONIZED = 0x0020, ACC_VOLATILE = 0x0040, ACC_TRANSIENT = 0x0080, ACC_NATIVE = 0x0100, ACC_ABSTRACT = 0x0400;
	 public void setFlags(short flags) {
		 itsFlags = flags;
	 }
	 static String getSlashedForm(String name) {
		 return name.replace('.', '/');
	 }
	 public static String classNameToSignature(String name) {
		 int nameLength = name.length();
		 int colonPos = 1 + nameLength;
		 char[] buf = new char[colonPos + 1];
		 buf[0] = 'L';
		 buf[colonPos] = ';
		';
		 name.getChars(0, nameLength, buf, 1);
		 for (int i = 1;
		 i != colonPos;
		 ++i) {
			 if (buf[i] == '.') {
				 buf[i] = '/';
			 }
		 }
		 return new String(buf, 0, colonPos + 1);
	 }
	 public void addField(String fieldName, String type, short flags) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));
	 }
	 public void addField(String fieldName, String type, short flags, int value) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex, flags);
		 field.setAttributes(itsConstantPool.addUtf8(""ConstantValue""), (short)0, (short)0, itsConstantPool.addConstant(value));
		 itsFields.add(field);
	 }
	 public void addField(String fieldName, String type, short flags, long value) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex, flags);
		 field.setAttributes(itsConstantPool.addUtf8(""ConstantValue""), (short)0, (short)2, itsConstantPool.addConstant(value));
		 itsFields.add(field);
	 }
	 public void addField(String fieldName, String type, short flags, double value) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex, flags);
		 field.setAttributes(itsConstantPool.addUtf8(""ConstantValue""), (short)0, (short)2, itsConstantPool.addConstant(value));
		 itsFields.add(field);
	 }
	 public void addVariableDescriptor(String name, String type, int startPC, int register) {
		 int nameIndex = itsConstantPool.addUtf8(name);
		 int descriptorIndex = itsConstantPool.addUtf8(type);
		 int [] chunk = {
		 nameIndex, descriptorIndex, startPC, register }
		;
		 if (itsVarDescriptors == null) {
			 itsVarDescriptors = new ObjArray();
		 }
		 itsVarDescriptors.add(chunk);
	 }
	 public void startMethod(String methodName, String type, short flags) {
		 short methodNameIndex = itsConstantPool.addUtf8(methodName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 itsCurrentMethod = new ClassFileMethod(methodNameIndex, typeIndex, flags);
		 itsMethods.add(itsCurrentMethod);
	 }
	 public void stopMethod(short maxLocals) {
		 if (itsCurrentMethod == null) throw new IllegalStateException(""No method to stop"");
		 fixLabelGotos();
		 itsMaxLocals = maxLocals;
		 int lineNumberTableLength = 0;
		 if (itsLineNumberTable != null) {
			 lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);
		 }
		 int variableTableLength = 0;
		 if (itsVarDescriptors != null) {
			 variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);
		 }
		 int attrLength = 2 + 4 + 2 + 2 + 4 + itsCodeBufferTop + 2 + (itsExceptionTableTop * 8) + 2 + lineNumberTableLength + variableTableLength;
		 byte[] codeAttribute = new byte[attrLength];
		 int index = 0;
		 int codeAttrIndex = itsConstantPool.addUtf8(""Code"");
		 index = putInt16(codeAttrIndex, codeAttribute, index);
		 attrLength -= 6;
		 index = putInt32(attrLength, codeAttribute, index);
		 index = putInt16(itsMaxStack, codeAttribute, index);
		 index = putInt16(itsMaxLocals, codeAttribute, index);
		 index = putInt32(itsCodeBufferTop, codeAttribute, index);
		 System.arraycopy(itsCodeBuffer, 0, codeAttribute, index, itsCodeBufferTop);
		 index += itsCodeBufferTop;
		 if (itsExceptionTableTop > 0) {
			 index = putInt16(itsExceptionTableTop, codeAttribute, index);
			 for (int i = 0;
			 i < itsExceptionTableTop;
			 i++) {
				 ExceptionTableEntry ete = itsExceptionTable[i];
				 short startPC = (short)getLabelPC(ete.itsStartLabel);
				 short endPC = (short)getLabelPC(ete.itsEndLabel);
				 short handlerPC = (short)getLabelPC(ete.itsHandlerLabel);
				 short catchType = ete.itsCatchType;
				 if (startPC == -1) throw new IllegalStateException(""start label not defined"");
				 if (endPC == -1) throw new IllegalStateException(""end label not defined"");
				 if (handlerPC == -1) throw new IllegalStateException( ""handler label not defined"");
				 index = putInt16(startPC, codeAttribute, index);
				 index = putInt16(endPC, codeAttribute, index);
				 index = putInt16(handlerPC, codeAttribute, index);
				 index = putInt16(catchType, codeAttribute, index);
			 }
		 }
		 else {
			 index = putInt16(0, codeAttribute, index);
		 }
		 int attributeCount = 0;
		 if (itsLineNumberTable != null) attributeCount++;
		 if (itsVarDescriptors != null) attributeCount++;
		 index = putInt16(attributeCount, codeAttribute, index);
		 if (itsLineNumberTable != null) {
			 int lineNumberTableAttrIndex = itsConstantPool.addUtf8(""LineNumberTable"");
			 index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);
			 int tableAttrLength = 2 + (itsLineNumberTableTop * 4);
			 index = putInt32(tableAttrLength, codeAttribute, index);
			 index = putInt16(itsLineNumberTableTop, codeAttribute, index);
			 for (int i = 0;
			 i < itsLineNumberTableTop;
			 i++) {
				 index = putInt32(itsLineNumberTable[i], codeAttribute, index);
			 }
		 }
		 if (itsVarDescriptors != null) {
			 int variableTableAttrIndex = itsConstantPool.addUtf8(""LocalVariableTable"");
			 index = putInt16(variableTableAttrIndex, codeAttribute, index);
			 int varCount = itsVarDescriptors.size();
			 int tableAttrLength = 2 + (varCount * 10);
			 index = putInt32(tableAttrLength, codeAttribute, index);
			 index = putInt16(varCount, codeAttribute, index);
			 for (int i = 0;
			 i < varCount;
			 i++) {
				 int[] chunk = (int[])itsVarDescriptors.get(i);
				 int nameIndex = chunk[0];
				 int descriptorIndex = chunk[1];
				 int startPC = chunk[2];
				 int register = chunk[3];
				 int length = itsCodeBufferTop - startPC;
				 index = putInt16(startPC, codeAttribute, index);
				 index = putInt16(length, codeAttribute, index);
				 index = putInt16(nameIndex, codeAttribute, index);
				 index = putInt16(descriptorIndex, codeAttribute, index);
				 index = putInt16(register, codeAttribute, index);
			 }
		 }
		 itsCurrentMethod.setCodeAttribute(codeAttribute);
		 itsExceptionTable = null;
		 itsExceptionTableTop = 0;
		 itsLineNumberTableTop = 0;
		 itsCodeBufferTop = 0;
		 itsCurrentMethod = null;
		 itsMaxStack = 0;
		 itsStackTop = 0;
		 itsLabelTableTop = 0;
		 itsFixupTableTop = 0;
		 itsVarDescriptors = null;
	 }
	 public void add(int theOpCode) {
		 if (opcodeCount(theOpCode) != 0) throw new IllegalArgumentException(""Unexpected operands"");
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 if (DEBUGCODE) System.out.println(""Add "" + bytecodeStr(theOpCode));
		 addToCodeBuffer(theOpCode);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void add(int theOpCode, int theOperand) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+Integer.toHexString(theOperand));
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 switch (theOpCode) {
			 case ByteCode.GOTO : case ByteCode.IFEQ : case ByteCode.IFNE : case ByteCode.IFLT : case ByteCode.IFGE : case ByteCode.IFGT : case ByteCode.IFLE : case ByteCode.IF_ICMPEQ : case ByteCode.IF_ICMPNE : case ByteCode.IF_ICMPLT : case ByteCode.IF_ICMPGE : case ByteCode.IF_ICMPGT : case ByteCode.IF_ICMPLE : case ByteCode.IF_ACMPEQ : case ByteCode.IF_ACMPNE : case ByteCode.JSR : case ByteCode.IFNULL : case ByteCode.IFNONNULL : {
				 if ((theOperand & 0x80000000) != 0x80000000) {
					 if ((theOperand < 0) || (theOperand > 65535)) throw new IllegalArgumentException( ""Bad label for branch"");
				 }
				 int branchPC = itsCodeBufferTop;
				 addToCodeBuffer(theOpCode);
				 if ((theOperand & 0x80000000) != 0x80000000) {
					 addToCodeInt16(theOperand);
				 }
				 else {
					 int targetPC = getLabelPC(theOperand);
					 if (DEBUGLABELS) {
						 int theLabel = theOperand & 0x7FFFFFFF;
						 System.out.println(""Fixing branch to "" + theLabel + "" at "" + targetPC + "" from "" + branchPC);
					 }
					 if (targetPC != -1) {
						 int offset = targetPC - branchPC;
						 addToCodeInt16(offset);
					 }
					 else {
						 addLabelFixup(theOperand, branchPC + 1);
						 addToCodeInt16(0);
					 }
				 }
			 }
			 break;
			 case ByteCode.BIPUSH : if ((byte)theOperand != theOperand) throw new IllegalArgumentException(""out of range byte"");
			 addToCodeBuffer(theOpCode);
			 addToCodeBuffer((byte)theOperand);
			 break;
			 case ByteCode.SIPUSH : if ((short)theOperand != theOperand) throw new IllegalArgumentException(""out of range short"");
			 addToCodeBuffer(theOpCode);
			 addToCodeInt16(theOperand);
			 break;
			 case ByteCode.NEWARRAY : if (!(0 <= theOperand && theOperand < 256)) throw new IllegalArgumentException(""out of range index"");
			 addToCodeBuffer(theOpCode);
			 addToCodeBuffer(theOperand);
			 break;
			 case ByteCode.GETFIELD : case ByteCode.PUTFIELD : if (!(0 <= theOperand && theOperand < 65536)) throw new IllegalArgumentException(""out of range field"");
			 addToCodeBuffer(theOpCode);
			 addToCodeInt16(theOperand);
			 break;
			 case ByteCode.LDC : case ByteCode.LDC_W : case ByteCode.LDC2_W : if (!(0 <= theOperand && theOperand < 65536)) throw new IllegalArgumentException(""out of range index"");
			 if (theOperand >= 256 || theOpCode == ByteCode.LDC_W || theOpCode == ByteCode.LDC2_W) {
				 if (theOpCode == ByteCode.LDC) {
					 addToCodeBuffer(ByteCode.LDC_W);
				 }
				 else {
					 addToCodeBuffer(theOpCode);
				 }
				 addToCodeInt16(theOperand);
			 }
			 else {
				 addToCodeBuffer(theOpCode);
				 addToCodeBuffer(theOperand);
			 }
			 break;
			 case ByteCode.RET : case ByteCode.ILOAD : case ByteCode.LLOAD : case ByteCode.FLOAD : case ByteCode.DLOAD : case ByteCode.ALOAD : case ByteCode.ISTORE : case ByteCode.LSTORE : case ByteCode.FSTORE : case ByteCode.DSTORE : case ByteCode.ASTORE : if (!(0 <= theOperand && theOperand < 65536)) throw new IllegalArgumentException(""out of range variable"");
			 if (theOperand >= 256) {
				 addToCodeBuffer(ByteCode.WIDE);
				 addToCodeBuffer(theOpCode);
				 addToCodeInt16(theOperand);
			 }
			 else {
				 addToCodeBuffer(theOpCode);
				 addToCodeBuffer(theOperand);
			 }
			 break;
			 default : throw new IllegalArgumentException( ""Unexpected opcode for 1 operand"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void addLoadConstant(int k) {
		 add(ByteCode.LDC, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(long k) {
		 add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(float k) {
		 add(ByteCode.LDC, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(double k) {
		 add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(String k) {
		 add(ByteCode.LDC, itsConstantPool.addConstant(k));
	 }
	 public void add(int theOpCode, int theOperand1, int theOperand2) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+Integer.toHexString(theOperand1) +"", ""+Integer.toHexString(theOperand2));
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 if (theOpCode == ByteCode.IINC) {
			 if (!(0 <= theOperand1 && theOperand1 < 65536)) throw new IllegalArgumentException(""out of range variable"");
			 if (!(0 <= theOperand2 && theOperand2 < 65536)) throw new IllegalArgumentException(""out of range increment"");
			 if (theOperand1 > 255 || theOperand2 < -128 || theOperand2 > 127) {
				 addToCodeBuffer(ByteCode.WIDE);
				 addToCodeBuffer(ByteCode.IINC);
				 addToCodeInt16(theOperand1);
				 addToCodeInt16(theOperand2);
			 }
			 else {
				 addToCodeBuffer(ByteCode.WIDE);
				 addToCodeBuffer(ByteCode.IINC);
				 addToCodeBuffer(theOperand1);
				 addToCodeBuffer(theOperand2);
			 }
		 }
		 else if (theOpCode == ByteCode.MULTIANEWARRAY) {
			 if (!(0 <= theOperand1 && theOperand1 < 65536)) throw new IllegalArgumentException(""out of range index"");
			 if (!(0 <= theOperand2 && theOperand2 < 256)) throw new IllegalArgumentException(""out of range dimensions"");
			 addToCodeBuffer(ByteCode.MULTIANEWARRAY);
			 addToCodeInt16(theOperand1);
			 addToCodeBuffer(theOperand2);
		 }
		 else {
			 throw new IllegalArgumentException( ""Unexpected opcode for 2 operands"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void add(int theOpCode, String className) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+className);
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 switch (theOpCode) {
			 case ByteCode.NEW : case ByteCode.ANEWARRAY : case ByteCode.CHECKCAST : case ByteCode.INSTANCEOF : {
				 short classIndex = itsConstantPool.addClass(className);
				 addToCodeBuffer(theOpCode);
				 addToCodeInt16(classIndex);
			 }
			 break;
			 default : throw new IllegalArgumentException( ""bad opcode for class reference"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void add(int theOpCode, String className, String fieldName, String fieldType) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+className+"", ""+fieldName+"", ""+fieldType);
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 char fieldTypeChar = fieldType.charAt(0);
		 int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D') ? 2 : 1;
		 switch (theOpCode) {
			 case ByteCode.GETFIELD : case ByteCode.GETSTATIC : newStack += fieldSize;
			 break;
			 case ByteCode.PUTSTATIC : case ByteCode.PUTFIELD : newStack -= fieldSize;
			 break;
			 default : throw new IllegalArgumentException( ""bad opcode for field reference"");
		 }
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 short fieldRefIndex = itsConstantPool.addFieldRef(className, fieldName, fieldType);
		 addToCodeBuffer(theOpCode);
		 addToCodeInt16(fieldRefIndex);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void addInvoke(int theOpCode, String className, String methodName, String methodType) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+className+"", ""+methodName+"", "" +methodType);
		 }
		 int parameterInfo = sizeOfParameters(methodType);
		 int parameterCount = parameterInfo >>> 16;
		 int stackDiff = (short)parameterInfo;
		 int newStack = itsStackTop + stackDiff;
		 newStack += stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 switch (theOpCode) {
			 case ByteCode.INVOKEVIRTUAL : case ByteCode.INVOKESPECIAL : case ByteCode.INVOKESTATIC : case ByteCode.INVOKEINTERFACE : {
				 addToCodeBuffer(theOpCode);
				 if (theOpCode == ByteCode.INVOKEINTERFACE) {
					 short ifMethodRefIndex = itsConstantPool.addInterfaceMethodRef( className, methodName, methodType);
					 addToCodeInt16(ifMethodRefIndex);
					 addToCodeBuffer(parameterCount + 1);
					 addToCodeBuffer(0);
				 }
				 else {
					 short methodRefIndex = itsConstantPool.addMethodRef( className, methodName, methodType);
					 addToCodeInt16(methodRefIndex);
				 }
			 }
			 break;
			 default : throw new IllegalArgumentException( ""bad opcode for method reference"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void addPush(int k) {
		 if ((byte)k == k) {
			 if (k == -1) {
				 add(ByteCode.ICONST_M1);
			 }
			 else if (0 <= k && k <= 5) {
				 add((byte)(ByteCode.ICONST_0 + k));
			 }
			 else {
				 add(ByteCode.BIPUSH, (byte)k);
			 }
		 }
		 else if ((short)k == k) {
			 add(ByteCode.SIPUSH, (short)k);
		 }
		 else {
			 addLoadConstant(k);
		 }
	 }
	 public void addPush(boolean k) {
		 add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);
	 }
	 public void addPush(long k) {
		 int ik = (int)k;
		 if (ik == k) {
			 addPush(ik);
			 add(ByteCode.I2L);
		 }
		 else {
			 addLoadConstant(k);
		 }
	 }
	 public void addPush(double k) {
		 if (k == 0.0) {
			 add(ByteCode.DCONST_0);
			 if (1.0 / k < 0) {
				 add(ByteCode.DNEG);
			 }
		 }
		 else if (k == 1.0 || k == -1.0) {
			 add(ByteCode.DCONST_1);
			 if (k < 0) {
				 add(ByteCode.DNEG);
			 }
		 }
		 else {
			 addLoadConstant(k);
		 }
	 }
	 public void addPush(String k) {
		 int length = k.length();
		 int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);
		 if (limit == length) {
			 addLoadConstant(k);
			 return;
		 }
		 final String SB = ""java/lang/StringBuffer"";
		 add(ByteCode.NEW, SB);
		 add(ByteCode.DUP);
		 addPush(length);
		 addInvoke(ByteCode.INVOKESPECIAL, SB, ""<init>"", ""(I)V"");
		 int cursor = 0;
		 for (;
		;
		) {
			 add(ByteCode.DUP);
			 String s = k.substring(cursor, limit);
			 addLoadConstant(s);
			 addInvoke(ByteCode.INVOKEVIRTUAL, SB, ""append"", ""(Ljava/lang/String;
			)Ljava/lang/StringBuffer;
			"");
			 add(ByteCode.POP);
			 if (limit == length) {
				 break;
			 }
			 cursor = limit;
			 limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);
		 }
		 addInvoke(ByteCode.INVOKEVIRTUAL, SB, ""toString"", ""()Ljava/lang/String;
		"");
	 }
	 public boolean isUnderStringSizeLimit(String k) {
		 return itsConstantPool.isUnderUtfEncodingLimit(k);
	 }
	 public void addIStore(int local) {
		 xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);
	 }
	 public void addLStore(int local) {
		 xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);
	 }
	 public void addFStore(int local) {
		 xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);
	 }
	 public void addDStore(int local) {
		 xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);
	 }
	 public void addAStore(int local) {
		 xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);
	 }
	 public void addILoad(int local) {
		 xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);
	 }
	 public void addLLoad(int local) {
		 xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);
	 }
	 public void addFLoad(int local) {
		 xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);
	 }
	 public void addDLoad(int local) {
		 xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);
	 }
	 public void addALoad(int local) {
		 xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);
	 }
	 public void addLoadThis() {
		 add(ByteCode.ALOAD_0);
	 }
	 private void xop(int shortOp, int op, int local) {
		 switch (local) {
			 case 0: add(shortOp);
			 break;
			 case 1: add(shortOp + 1);
			 break;
			 case 2: add(shortOp + 2);
			 break;
			 case 3: add(shortOp + 3);
			 break;
			 default: add(op, local);
		 }
	 }
	 public int addTableSwitch(int low, int high) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(ByteCode.TABLESWITCH) +"" ""+low+"" ""+high);
		 }
		 if (low > high) throw new IllegalArgumentException(""Bad bounds: ""+low+' '+ high);
		 int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 int entryCount = high - low + 1;
		 int padSize = 3 & ~itsCodeBufferTop;
		 int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));
		 int switchStart = N;
		 itsCodeBuffer[N++] = (byte)ByteCode.TABLESWITCH;
		 while (padSize != 0) {
			 itsCodeBuffer[N++] = 0;
			 --padSize;
		 }
		 N += 4;
		 N = putInt32(low, itsCodeBuffer, N);
		 putInt32(high, itsCodeBuffer, N);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(ByteCode.TABLESWITCH) +"" stack = ""+itsStackTop);
		 }
		 return switchStart;
	 }
	 public final void markTableSwitchDefault(int switchStart) {
		 setTableSwitchJump(switchStart, -1, itsCodeBufferTop);
	 }
	 public final void markTableSwitchCase(int switchStart, int caseIndex) {
		 setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
	 }
	 public final void markTableSwitchCase(int switchStart, int caseIndex, int stackTop) {
		 if (!(0 <= stackTop && stackTop <= itsMaxStack)) throw new IllegalArgumentException(""Bad stack index: ""+stackTop);
		 itsStackTop = (short)stackTop;
		 setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
	 }
	 public void setTableSwitchJump(int switchStart, int caseIndex, int jumpTarget) {
		 if (!(0 <= jumpTarget && jumpTarget <= itsCodeBufferTop)) throw new IllegalArgumentException(""Bad jump target: ""+jumpTarget);
		 if (!(caseIndex >= -1)) throw new IllegalArgumentException(""Bad case index: ""+caseIndex);
		 int padSize = 3 & ~switchStart;
		 int caseOffset;
		 if (caseIndex < 0) {
			 caseOffset = switchStart + 1 + padSize;
		 }
		 else {
			 caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);
		 }
		 if (!(0 <= switchStart && switchStart <= itsCodeBufferTop - 4 * 4 - padSize - 1)) {
			 throw new IllegalArgumentException( switchStart+"" is outside a possible range of tableswitch"" +"" in already generated code"");
		 }
		 if ((0xFF & itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {
			 throw new IllegalArgumentException( switchStart+"" is not offset of tableswitch statement"");
		 }
		 if (!(0 <= caseOffset && caseOffset + 4 <= itsCodeBufferTop)) {
			 throw new IllegalArgumentException( ""Too big case index: ""+caseIndex);
		 }
		 putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);
	 }
	 public int acquireLabel() {
		 int top = itsLabelTableTop;
		 if (itsLabelTable == null || top == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, top);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = top + 1;
		 itsLabelTable[top] = -1;
		 return top | 0x80000000;
	 }
	 public void markLabel(int label) {
		 if (!(label < 0)) throw new IllegalArgumentException(""Bad label, no biscuit"");
		 label &= 0x7FFFFFFF;
		 if (label > itsLabelTableTop) throw new IllegalArgumentException(""Bad label"");
		 if (itsLabelTable[label] != -1) {
			 throw new IllegalStateException(""Can only mark label once"");
		 }
		 itsLabelTable[label] = itsCodeBufferTop;
	 }
	 public void markLabel(int label, short stackTop) {
		 markLabel(label);
		 itsStackTop = stackTop;
	 }
	 public void markHandler(int theLabel) {
		 itsStackTop = 1;
		 markLabel(theLabel);
	 }
	 private int getLabelPC(int label) {
		 if (!(label < 0)) throw new IllegalArgumentException(""Bad label, no biscuit"");
		 label &= 0x7FFFFFFF;
		 if (!(label < itsLabelTableTop)) throw new IllegalArgumentException(""Bad label"");
		 return itsLabelTable[label];
	 }
	 private void addLabelFixup(int label, int fixupSite) {
		 if (!(label < 0)) throw new IllegalArgumentException(""Bad label, no biscuit"");
		 label &= 0x7FFFFFFF;
		 if (!(label < itsLabelTableTop)) throw new IllegalArgumentException(""Bad label"");
		 int top = itsFixupTableTop;
		 if (itsFixupTable == null || top == itsFixupTable.length) {
			 if (itsFixupTable == null) {
				 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
			 }
			else {
				 long[] tmp = new long[itsFixupTable.length * 2];
				 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
				 itsFixupTable = tmp;
			 }
		 }
		 itsFixupTableTop = top + 1;
		 itsFixupTable[top] = ((long)label << 32) | fixupSite;
	 }
	 private void fixLabelGotos() {
		 byte[] codeBuffer = itsCodeBuffer;
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int fixupSite = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw new RuntimeException();
			 }
			 int offset = pc - (fixupSite - 1);
			 if ((short)offset != offset) {
				 throw new RuntimeException (""Program too complex: too big jump offset"");
			 }
			 codeBuffer[fixupSite] = (byte)(offset >> 8);
			 codeBuffer[fixupSite + 1] = (byte)offset;
		 }
		 itsFixupTableTop = 0;
	 }
	 public int getCurrentCodeOffset() {
		 return itsCodeBufferTop;
	 }
	 public short getStackTop() {
		 return itsStackTop;
	 }
	 public void adjustStackTop(int delta) {
		 int newStack = itsStackTop + delta;
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+""adjustStackTop(""+delta+"")"" +"" stack = ""+itsStackTop);
		 }
	 }
	 private void addToCodeBuffer(int b) {
		 int N = addReservedCodeSpace(1);
		 itsCodeBuffer[N] = (byte)b;
	 }
	 private void addToCodeInt16(int value) {
		 int N = addReservedCodeSpace(2);
		 putInt16(value, itsCodeBuffer, N);
	 }
	 private int addReservedCodeSpace(int size) {
		 if (itsCurrentMethod == null) throw new IllegalArgumentException(""No method to add to"");
		 int oldTop = itsCodeBufferTop;
		 int newTop = oldTop + size;
		 if (newTop > itsCodeBuffer.length) {
			 int newSize = itsCodeBuffer.length * 2;
			 if (newTop > newSize) {
				 newSize = newTop;
			 }
			 byte[] tmp = new byte[newSize];
			 System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);
			 itsCodeBuffer = tmp;
		 }
		 itsCodeBufferTop = newTop;
		 return oldTop;
	 }
	 public void addExceptionHandler(int startLabel, int endLabel, int handlerLabel, String catchClassName) {
		 if ((startLabel & 0x80000000) != 0x80000000) throw new IllegalArgumentException(""Bad startLabel"");
		 if ((endLabel & 0x80000000) != 0x80000000) throw new IllegalArgumentException(""Bad endLabel"");
		 if ((handlerLabel & 0x80000000) != 0x80000000) throw new IllegalArgumentException(""Bad handlerLabel"");
		 short catch_type_index = (catchClassName == null) ? 0 : itsConstantPool.addClass(catchClassName);
		 ExceptionTableEntry newEntry = new ExceptionTableEntry( startLabel, endLabel, handlerLabel, catch_type_index);
		 int N = itsExceptionTableTop;
		 if (N == 0) {
			 itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];
		 }
		 else if (N == itsExceptionTable.length) {
			 ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];
			 System.arraycopy(itsExceptionTable, 0, tmp, 0, N);
			 itsExceptionTable = tmp;
		 }
		 itsExceptionTable[N] = newEntry;
		 itsExceptionTableTop = N + 1;
	 }
	 public void addLineNumberEntry(short lineNumber) {
		 if (itsCurrentMethod == null) throw new IllegalArgumentException(""No method to stop"");
		 int N = itsLineNumberTableTop;
		 if (N == 0) {
			 itsLineNumberTable = new int[LineNumberTableSize];
		 }
		 else if (N == itsLineNumberTable.length) {
			 int[] tmp = new int[N * 2];
			 System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);
			 itsLineNumberTable = tmp;
		 }
		 itsLineNumberTable[N] = (itsCodeBufferTop << 16) + lineNumber;
		 itsLineNumberTableTop = N + 1;
	 }
	 public void write(OutputStream oStream) throws IOException {
		 byte[] array = toByteArray();
		 oStream.write(array);
	 }
	 private int getWriteSize() {
		 int size = 0;
		 if (itsSourceFileNameIndex != 0) {
			 itsConstantPool.addUtf8(""SourceFile"");
		 }
		 size += 8;
		 size += itsConstantPool.getWriteSize();
		 size += 2;
		 size += 2;
		 size += 2;
		 size += 2;
		 size += 2 * itsInterfaces.size();
		 size += 2;
		 for (int i = 0;
		 i < itsFields.size();
		 i++) {
			 size += ((ClassFileField)(itsFields.get(i))).getWriteSize();
		 }
		 size += 2;
		 for (int i = 0;
		 i < itsMethods.size();
		 i++) {
			 size += ((ClassFileMethod)(itsMethods.get(i))).getWriteSize();
		 }
		 if (itsSourceFileNameIndex != 0) {
			 size += 2;
			 size += 2;
			 size += 4;
			 size += 2;
		 }
		else {
			 size += 2;
		 }
		 return size;
	 }
	 public byte[] toByteArray() {
		 int dataSize = getWriteSize();
		 byte[] data = new byte[dataSize];
		 int offset = 0;
		 short sourceFileAttributeNameIndex = 0;
		 if (itsSourceFileNameIndex != 0) {
			 sourceFileAttributeNameIndex = itsConstantPool.addUtf8( ""SourceFile"");
		 }
		 offset = putInt64(FileHeaderConstant, data, offset);
		 offset = itsConstantPool.write(data, offset);
		 offset = putInt16(itsFlags, data, offset);
		 offset = putInt16(itsThisClassIndex, data, offset);
		 offset = putInt16(itsSuperClassIndex, data, offset);
		 offset = putInt16(itsInterfaces.size(), data, offset);
		 for (int i = 0;
		 i < itsInterfaces.size();
		 i++) {
			 int interfaceIndex = ((Short)(itsInterfaces.get(i))).shortValue();
			 offset = putInt16(interfaceIndex, data, offset);
		 }
		 offset = putInt16(itsFields.size(), data, offset);
		 for (int i = 0;
		 i < itsFields.size();
		 i++) {
			 ClassFileField field = (ClassFileField)itsFields.get(i);
			 offset = field.write(data, offset);
		 }
		 offset = putInt16(itsMethods.size(), data, offset);
		 for (int i = 0;
		 i < itsMethods.size();
		 i++) {
			 ClassFileMethod method = (ClassFileMethod)itsMethods.get(i);
			 offset = method.write(data, offset);
		 }
		 if (itsSourceFileNameIndex != 0) {
			 offset = putInt16(1, data, offset);
			 offset = putInt16(sourceFileAttributeNameIndex, data, offset);
			 offset = putInt32(2, data, offset);
			 offset = putInt16(itsSourceFileNameIndex, data, offset);
		 }
		 else {
			 offset = putInt16(0, data, offset);
		 }
		 if (offset != dataSize) {
			 throw new RuntimeException();
		 }
		 return data;
	 }
	 static int putInt64(long value, byte[] array, int offset) {
		 offset = putInt32((int)(value >>> 32), array, offset);
		 return putInt32((int)value, array, offset);
	 }
	 private static void badStack(int value) {
		 String s;
		 if (value < 0) {
			 s = ""Stack underflow: ""+value;
		 }
		 else {
			 s = ""Too big stack: ""+value;
		 }
		 throw new IllegalStateException(s);
	 }
	 private static int sizeOfParameters(String pString) {
		 int length = pString.length();
		 int rightParenthesis = pString.lastIndexOf(')');
		 if (3 <= length && pString.charAt(0) == '(' && 1 <= rightParenthesis && rightParenthesis + 1 < length) {
			 boolean ok = true;
			 int index = 1;
			 int stackDiff = 0;
			 int count = 0;
			 stringLoop: while (index != rightParenthesis) {
				 switch (pString.charAt(index)) {
					 default: ok = false;
					 break stringLoop;
					 case 'J' : case 'D' : --stackDiff;
					 case 'B' : case 'S' : case 'C' : case 'I' : case 'Z' : case 'F' : --stackDiff;
					 ++count;
					 ++index;
					 continue;
					 case '[' : ++index;
					 int c = pString.charAt(index);
					 while (c == '[') {
						 ++index;
						 c = pString.charAt(index);
					 }
					 switch (c) {
						 default: ok = false;
						 break stringLoop;
						 case 'J' : case 'D' : case 'B' : case 'S' : case 'C' : case 'I' : case 'Z' : case 'F' : --stackDiff;
						 ++count;
						 ++index;
						 continue;
					 case 'L': }
					 case 'L' : {
						 --stackDiff;
						 ++count;
						 ++index;
						 int semicolon = pString.indexOf(';
						', index);
						 if (!(index + 1 <= semicolon && semicolon < rightParenthesis)) {
							 ok = false;
							 break stringLoop;
						 }
						 index = semicolon + 1;
						 continue;
					 }
				 }
			 }
			 if (ok) {
				 switch (pString.charAt(rightParenthesis + 1)) {
					 default: ok = false;
					 break;
					 case 'J' : case 'D' : ++stackDiff;
					 case 'B' : case 'S' : case 'C' : case 'I' : case 'Z' : case 'F' : case 'L' : case '[' : ++stackDiff;
					 case 'V' : break;
				 }
				 if (ok) {
					 return ((count << 16) | (0xFFFF & stackDiff));
				 }
			 }
		 }
		 throw new IllegalArgumentException( ""Bad parameter signature: ""+pString);
	 }
	 static int putInt16(int value, byte[] array, int offset) {
		 array[offset + 0] = (byte)(value >>> 8);
		 array[offset + 1] = (byte)value;
		 return offset + 2;
	 }
	 static int putInt32(int value, byte[] array, int offset) {
		 array[offset + 0] = (byte)(value >>> 24);
		 array[offset + 1] = (byte)(value >>> 16);
		 array[offset + 2] = (byte)(value >>> 8);
		 array[offset + 3] = (byte)value;
		 return offset + 4;
	 }
	 static int opcodeCount(int opcode) {
		 switch (opcode) {
			 case ByteCode.AALOAD: case ByteCode.AASTORE: case ByteCode.ACONST_NULL: case ByteCode.ALOAD_0: case ByteCode.ALOAD_1: case ByteCode.ALOAD_2: case ByteCode.ALOAD_3: case ByteCode.ARETURN: case ByteCode.ARRAYLENGTH: case ByteCode.ASTORE_0: case ByteCode.ASTORE_1: case ByteCode.ASTORE_2: case ByteCode.ASTORE_3: case ByteCode.ATHROW: case ByteCode.BALOAD: case ByteCode.BASTORE: case ByteCode.BREAKPOINT: case ByteCode.CALOAD: case ByteCode.CASTORE: case ByteCode.D2F: case ByteCode.D2I: case ByteCode.D2L: case ByteCode.DADD: case ByteCode.DALOAD: case ByteCode.DASTORE: case ByteCode.DCMPG: case ByteCode.DCMPL: case ByteCode.DCONST_0: case ByteCode.DCONST_1: case ByteCode.DDIV: case ByteCode.DLOAD_0: case ByteCode.DLOAD_1: case ByteCode.DLOAD_2: case ByteCode.DLOAD_3: case ByteCode.DMUL: case ByteCode.DNEG: case ByteCode.DREM: case ByteCode.DRETURN: case ByteCode.DSTORE_0: case ByteCode.DSTORE_1: case ByteCode.DSTORE_2: case ByteCode.DSTORE_3: case ByteCode.DSUB: case ByteCode.DUP: case ByteCode.DUP2: case ByteCode.DUP2_X1: case ByteCode.DUP2_X2: case ByteCode.DUP_X1: case ByteCode.DUP_X2: case ByteCode.F2D: case ByteCode.F2I: case ByteCode.F2L: case ByteCode.FADD: case ByteCode.FALOAD: case ByteCode.FASTORE: case ByteCode.FCMPG: case ByteCode.FCMPL: case ByteCode.FCONST_0: case ByteCode.FCONST_1: case ByteCode.FCONST_2: case ByteCode.FDIV: case ByteCode.FLOAD_0: case ByteCode.FLOAD_1: case ByteCode.FLOAD_2: case ByteCode.FLOAD_3: case ByteCode.FMUL: case ByteCode.FNEG: case ByteCode.FREM: case ByteCode.FRETURN: case ByteCode.FSTORE_0: case ByteCode.FSTORE_1: case ByteCode.FSTORE_2: case ByteCode.FSTORE_3: case ByteCode.FSUB: case ByteCode.I2B: case ByteCode.I2C: case ByteCode.I2D: case ByteCode.I2F: case ByteCode.I2L: case ByteCode.I2S: case ByteCode.IADD: case ByteCode.IALOAD: case ByteCode.IAND: case ByteCode.IASTORE: case ByteCode.ICONST_0: case ByteCode.ICONST_1: case ByteCode.ICONST_2: case ByteCode.ICONST_3: case ByteCode.ICONST_4: case ByteCode.ICONST_5: case ByteCode.ICONST_M1: case ByteCode.IDIV: case ByteCode.ILOAD_0: case ByteCode.ILOAD_1: case ByteCode.ILOAD_2: case ByteCode.ILOAD_3: case ByteCode.IMPDEP1: case ByteCode.IMPDEP2: case ByteCode.IMUL: case ByteCode.INEG: case ByteCode.IOR: case ByteCode.IREM: case ByteCode.IRETURN: case ByteCode.ISHL: case ByteCode.ISHR: case ByteCode.ISTORE_0: case ByteCode.ISTORE_1: case ByteCode.ISTORE_2: case ByteCode.ISTORE_3: case ByteCode.ISUB: case ByteCode.IUSHR: case ByteCode.IXOR: case ByteCode.L2D: case ByteCode.L2F: case ByteCode.L2I: case ByteCode.LADD: case ByteCode.LALOAD: case ByteCode.LAND: case ByteCode.LASTORE: case ByteCode.LCMP: case ByteCode.LCONST_0: case ByteCode.LCONST_1: case ByteCode.LDIV: case ByteCode.LLOAD_0: case ByteCode.LLOAD_1: case ByteCode.LLOAD_2: case ByteCode.LLOAD_3: case ByteCode.LMUL: case ByteCode.LNEG: case ByteCode.LOR: case ByteCode.LREM: case ByteCode.LRETURN: case ByteCode.LSHL: case ByteCode.LSHR: case ByteCode.LSTORE_0: case ByteCode.LSTORE_1: case ByteCode.LSTORE_2: case ByteCode.LSTORE_3: case ByteCode.LSUB: case ByteCode.LUSHR: case ByteCode.LXOR: case ByteCode.MONITORENTER: case ByteCode.MONITOREXIT: case ByteCode.NOP: case ByteCode.POP: case ByteCode.POP2: case ByteCode.RETURN: case ByteCode.SALOAD: case ByteCode.SASTORE: case ByteCode.SWAP: case ByteCode.WIDE: return 0;
			 case ByteCode.ALOAD: case ByteCode.ANEWARRAY: case ByteCode.ASTORE: case ByteCode.BIPUSH: case ByteCode.CHECKCAST: case ByteCode.DLOAD: case ByteCode.DSTORE: case ByteCode.FLOAD: case ByteCode.FSTORE: case ByteCode.GETFIELD: case ByteCode.GETSTATIC: case ByteCode.GOTO: case ByteCode.GOTO_W: case ByteCode.IFEQ: case ByteCode.IFGE: case ByteCode.IFGT: case ByteCode.IFLE: case ByteCode.IFLT: case ByteCode.IFNE: case ByteCode.IFNONNULL: case ByteCode.IFNULL: case ByteCode.IF_ACMPEQ: case ByteCode.IF_ACMPNE: case ByteCode.IF_ICMPEQ: case ByteCode.IF_ICMPGE: case ByteCode.IF_ICMPGT: case ByteCode.IF_ICMPLE: case ByteCode.IF_ICMPLT: case ByteCode.IF_ICMPNE: case ByteCode.ILOAD: case ByteCode.INSTANCEOF: case ByteCode.INVOKEINTERFACE: case ByteCode.INVOKESPECIAL: case ByteCode.INVOKESTATIC: case ByteCode.INVOKEVIRTUAL: case ByteCode.ISTORE: case ByteCode.JSR: case ByteCode.JSR_W: case ByteCode.LDC: case ByteCode.LDC2_W: case ByteCode.LDC_W: case ByteCode.LLOAD: case ByteCode.LSTORE: case ByteCode.NEW: case ByteCode.NEWARRAY: case ByteCode.PUTFIELD: case ByteCode.PUTSTATIC: case ByteCode.RET: case ByteCode.SIPUSH: return 1;
			 case ByteCode.IINC: case ByteCode.MULTIANEWARRAY: return 2;
			 case ByteCode.LOOKUPSWITCH: case ByteCode.TABLESWITCH: return -1;
		 }
		 throw new IllegalArgumentException(""Bad opcode: ""+opcode);
	 }
	 static int stackChange(int opcode) {
		 switch (opcode) {
			 case ByteCode.DASTORE: case ByteCode.LASTORE: return -4;
			 case ByteCode.AASTORE: case ByteCode.BASTORE: case ByteCode.CASTORE: case ByteCode.DCMPG: case ByteCode.DCMPL: case ByteCode.FASTORE: case ByteCode.IASTORE: case ByteCode.LCMP: case ByteCode.SASTORE: return -3;
			 case ByteCode.DADD: case ByteCode.DDIV: case ByteCode.DMUL: case ByteCode.DREM: case ByteCode.DRETURN: case ByteCode.DSTORE: case ByteCode.DSTORE_0: case ByteCode.DSTORE_1: case ByteCode.DSTORE_2: case ByteCode.DSTORE_3: case ByteCode.DSUB: case ByteCode.IF_ACMPEQ: case ByteCode.IF_ACMPNE: case ByteCode.IF_ICMPEQ: case ByteCode.IF_ICMPGE: case ByteCode.IF_ICMPGT: case ByteCode.IF_ICMPLE: case ByteCode.IF_ICMPLT: case ByteCode.IF_ICMPNE: case ByteCode.LADD: case ByteCode.LAND: case ByteCode.LDIV: case ByteCode.LMUL: case ByteCode.LOR: case ByteCode.LREM: case ByteCode.LRETURN: case ByteCode.LSTORE: case ByteCode.LSTORE_0: case ByteCode.LSTORE_1: case ByteCode.LSTORE_2: case ByteCode.LSTORE_3: case ByteCode.LSUB: case ByteCode.LXOR: case ByteCode.POP2: return -2;
			 case ByteCode.AALOAD: case ByteCode.ARETURN: case ByteCode.ASTORE: case ByteCode.ASTORE_0: case ByteCode.ASTORE_1: case ByteCode.ASTORE_2: case ByteCode.ASTORE_3: case ByteCode.ATHROW: case ByteCode.BALOAD: case ByteCode.CALOAD: case ByteCode.D2F: case ByteCode.D2I: case ByteCode.FADD: case ByteCode.FALOAD: case ByteCode.FCMPG: case ByteCode.FCMPL: case ByteCode.FDIV: case ByteCode.FMUL: case ByteCode.FREM: case ByteCode.FRETURN: case ByteCode.FSTORE: case ByteCode.FSTORE_0: case ByteCode.FSTORE_1: case ByteCode.FSTORE_2: case ByteCode.FSTORE_3: case ByteCode.FSUB: case ByteCode.GETFIELD: case ByteCode.IADD: case ByteCode.IALOAD: case ByteCode.IAND: case ByteCode.IDIV: case ByteCode.IFEQ: case ByteCode.IFGE: case ByteCode.IFGT: case ByteCode.IFLE: case ByteCode.IFLT: case ByteCode.IFNE: case ByteCode.IFNONNULL: case ByteCode.IFNULL: case ByteCode.IMUL: case ByteCode.INVOKEINTERFACE: case ByteCode.INVOKESPECIAL: case ByteCode.INVOKEVIRTUAL: case ByteCode.IOR: case ByteCode.IREM: case ByteCode.IRETURN: case ByteCode.ISHL: case ByteCode.ISHR: case ByteCode.ISTORE: case ByteCode.ISTORE_0: case ByteCode.ISTORE_1: case ByteCode.ISTORE_2: case ByteCode.ISTORE_3: case ByteCode.ISUB: case ByteCode.IUSHR: case ByteCode.IXOR: case ByteCode.L2F: case ByteCode.L2I: case ByteCode.LOOKUPSWITCH: case ByteCode.LSHL: case ByteCode.LSHR: case ByteCode.LUSHR: case ByteCode.MONITORENTER: case ByteCode.MONITOREXIT: case ByteCode.POP: case ByteCode.PUTFIELD: case ByteCode.SALOAD: case ByteCode.TABLESWITCH: return -1;
			 case ByteCode.ANEWARRAY: case ByteCode.ARRAYLENGTH: case ByteCode.BREAKPOINT: case ByteCode.CHECKCAST: case ByteCode.D2L: case ByteCode.DALOAD: case ByteCode.DNEG: case ByteCode.F2I: case ByteCode.FNEG: case ByteCode.GETSTATIC: case ByteCode.GOTO: case ByteCode.GOTO_W: case ByteCode.I2B: case ByteCode.I2C: case ByteCode.I2F: case ByteCode.I2S: case ByteCode.IINC: case ByteCode.IMPDEP1: case ByteCode.IMPDEP2: case ByteCode.INEG: case ByteCode.INSTANCEOF: case ByteCode.INVOKESTATIC: case ByteCode.L2D: case ByteCode.LALOAD: case ByteCode.LNEG: case ByteCode.NEWARRAY: case ByteCode.NOP: case ByteCode.PUTSTATIC: case ByteCode.RET: case ByteCode.RETURN: case ByteCode.SWAP: case ByteCode.WIDE: return 0;
			 case ByteCode.ACONST_NULL: case ByteCode.ALOAD: case ByteCode.ALOAD_0: case ByteCode.ALOAD_1: case ByteCode.ALOAD_2: case ByteCode.ALOAD_3: case ByteCode.BIPUSH: case ByteCode.DUP: case ByteCode.DUP_X1: case ByteCode.DUP_X2: case ByteCode.F2D: case ByteCode.F2L: case ByteCode.FCONST_0: case ByteCode.FCONST_1: case ByteCode.FCONST_2: case ByteCode.FLOAD: case ByteCode.FLOAD_0: case ByteCode.FLOAD_1: case ByteCode.FLOAD_2: case ByteCode.FLOAD_3: case ByteCode.I2D: case ByteCode.I2L: case ByteCode.ICONST_0: case ByteCode.ICONST_1: case ByteCode.ICONST_2: case ByteCode.ICONST_3: case ByteCode.ICONST_4: case ByteCode.ICONST_5: case ByteCode.ICONST_M1: case ByteCode.ILOAD: case ByteCode.ILOAD_0: case ByteCode.ILOAD_1: case ByteCode.ILOAD_2: case ByteCode.ILOAD_3: case ByteCode.JSR: case ByteCode.JSR_W: case ByteCode.LDC: case ByteCode.LDC_W: case ByteCode.MULTIANEWARRAY: case ByteCode.NEW: case ByteCode.SIPUSH: return 1;
			 case ByteCode.DCONST_0: case ByteCode.DCONST_1: case ByteCode.DLOAD: case ByteCode.DLOAD_0: case ByteCode.DLOAD_1: case ByteCode.DLOAD_2: case ByteCode.DLOAD_3: case ByteCode.DUP2: case ByteCode.DUP2_X1: case ByteCode.DUP2_X2: case ByteCode.LCONST_0: case ByteCode.LCONST_1: case ByteCode.LDC2_W: case ByteCode.LLOAD: case ByteCode.LLOAD_0: case ByteCode.LLOAD_1: case ByteCode.LLOAD_2: case ByteCode.LLOAD_3: return 2;
		 }
		 throw new IllegalArgumentException(""Bad opcode: ""+opcode);
	 }
	 private static String bytecodeStr(int code) {
		 if (DEBUGSTACK || DEBUGCODE) {
			 switch (code) {
				 case ByteCode.NOP: return ""nop"";
				 case ByteCode.ACONST_NULL: return ""aconst_null"";
				 case ByteCode.ICONST_M1: return ""iconst_m1"";
				 case ByteCode.ICONST_0: return ""iconst_0"";
				 case ByteCode.ICONST_1: return ""iconst_1"";
				 case ByteCode.ICONST_2: return ""iconst_2"";
				 case ByteCode.ICONST_3: return ""iconst_3"";
				 case ByteCode.ICONST_4: return ""iconst_4"";
				 case ByteCode.ICONST_5: return ""iconst_5"";
				 case ByteCode.LCONST_0: return ""lconst_0"";
				 case ByteCode.LCONST_1: return ""lconst_1"";
				 case ByteCode.FCONST_0: return ""fconst_0"";
				 case ByteCode.FCONST_1: return ""fconst_1"";
				 case ByteCode.FCONST_2: return ""fconst_2"";
				 case ByteCode.DCONST_0: return ""dconst_0"";
				 case ByteCode.DCONST_1: return ""dconst_1"";
				 case ByteCode.BIPUSH: return ""bipush"";
				 case ByteCode.SIPUSH: return ""sipush"";
				 case ByteCode.LDC: return ""ldc"";
				 case ByteCode.LDC_W: return ""ldc_w"";
				 case ByteCode.LDC2_W: return ""ldc2_w"";
				 case ByteCode.ILOAD: return ""iload"";
				 case ByteCode.LLOAD: return ""lload"";
				 case ByteCode.FLOAD: return ""fload"";
				 case ByteCode.DLOAD: return ""dload"";
				 case ByteCode.ALOAD: return ""aload"";
				 case ByteCode.ILOAD_0: return ""iload_0"";
				 case ByteCode.ILOAD_1: return ""iload_1"";
				 case ByteCode.ILOAD_2: return ""iload_2"";
				 case ByteCode.ILOAD_3: return ""iload_3"";
				 case ByteCode.LLOAD_0: return ""lload_0"";
				 case ByteCode.LLOAD_1: return ""lload_1"";
				 case ByteCode.LLOAD_2: return ""lload_2"";
				 case ByteCode.LLOAD_3: return ""lload_3"";
				 case ByteCode.FLOAD_0: return ""fload_0"";
				 case ByteCode.FLOAD_1: return ""fload_1"";
				 case ByteCode.FLOAD_2: return ""fload_2"";
				 case ByteCode.FLOAD_3: return ""fload_3"";
				 case ByteCode.DLOAD_0: return ""dload_0"";
				 case ByteCode.DLOAD_1: return ""dload_1"";
				 case ByteCode.DLOAD_2: return ""dload_2"";
				 case ByteCode.DLOAD_3: return ""dload_3"";
				 case ByteCode.ALOAD_0: return ""aload_0"";
				 case ByteCode.ALOAD_1: return ""aload_1"";
				 case ByteCode.ALOAD_2: return ""aload_2"";
				 case ByteCode.ALOAD_3: return ""aload_3"";
				 case ByteCode.IALOAD: return ""iaload"";
				 case ByteCode.LALOAD: return ""laload"";
				 case ByteCode.FALOAD: return ""faload"";
				 case ByteCode.DALOAD: return ""daload"";
				 case ByteCode.AALOAD: return ""aaload"";
				 case ByteCode.BALOAD: return ""baload"";
				 case ByteCode.CALOAD: return ""caload"";
				 case ByteCode.SALOAD: return ""saload"";
				 case ByteCode.ISTORE: return ""istore"";
				 case ByteCode.LSTORE: return ""lstore"";
				 case ByteCode.FSTORE: return ""fstore"";
				 case ByteCode.DSTORE: return ""dstore"";
				 case ByteCode.ASTORE: return ""astore"";
				 case ByteCode.ISTORE_0: return ""istore_0"";
				 case ByteCode.ISTORE_1: return ""istore_1"";
				 case ByteCode.ISTORE_2: return ""istore_2"";
				 case ByteCode.ISTORE_3: return ""istore_3"";
				 case ByteCode.LSTORE_0: return ""lstore_0"";
				 case ByteCode.LSTORE_1: return ""lstore_1"";
				 case ByteCode.LSTORE_2: return ""lstore_2"";
				 case ByteCode.LSTORE_3: return ""lstore_3"";
				 case ByteCode.FSTORE_0: return ""fstore_0"";
				 case ByteCode.FSTORE_1: return ""fstore_1"";
				 case ByteCode.FSTORE_2: return ""fstore_2"";
				 case ByteCode.FSTORE_3: return ""fstore_3"";
				 case ByteCode.DSTORE_0: return ""dstore_0"";
				 case ByteCode.DSTORE_1: return ""dstore_1"";
				 case ByteCode.DSTORE_2: return ""dstore_2"";
				 case ByteCode.DSTORE_3: return ""dstore_3"";
				 case ByteCode.ASTORE_0: return ""astore_0"";
				 case ByteCode.ASTORE_1: return ""astore_1"";
				 case ByteCode.ASTORE_2: return ""astore_2"";
				 case ByteCode.ASTORE_3: return ""astore_3"";
				 case ByteCode.IASTORE: return ""iastore"";
				 case ByteCode.LASTORE: return ""lastore"";
				 case ByteCode.FASTORE: return ""fastore"";
				 case ByteCode.DASTORE: return ""dastore"";
				 case ByteCode.AASTORE: return ""aastore"";
				 case ByteCode.BASTORE: return ""bastore"";
				 case ByteCode.CASTORE: return ""castore"";
				 case ByteCode.SASTORE: return ""sastore"";
				 case ByteCode.POP: return ""pop"";
				 case ByteCode.POP2: return ""pop2"";
				 case ByteCode.DUP: return ""dup"";
				 case ByteCode.DUP_X1: return ""dup_x1"";
				 case ByteCode.DUP_X2: return ""dup_x2"";
				 case ByteCode.DUP2: return ""dup2"";
				 case ByteCode.DUP2_X1: return ""dup2_x1"";
				 case ByteCode.DUP2_X2: return ""dup2_x2"";
				 case ByteCode.SWAP: return ""swap"";
				 case ByteCode.IADD: return ""iadd"";
				 case ByteCode.LADD: return ""ladd"";
				 case ByteCode.FADD: return ""fadd"";
				 case ByteCode.DADD: return ""dadd"";
				 case ByteCode.ISUB: return ""isub"";
				 case ByteCode.LSUB: return ""lsub"";
				 case ByteCode.FSUB: return ""fsub"";
				 case ByteCode.DSUB: return ""dsub"";
				 case ByteCode.IMUL: return ""imul"";
				 case ByteCode.LMUL: return ""lmul"";
				 case ByteCode.FMUL: return ""fmul"";
				 case ByteCode.DMUL: return ""dmul"";
				 case ByteCode.IDIV: return ""idiv"";
				 case ByteCode.LDIV: return ""ldiv"";
				 case ByteCode.FDIV: return ""fdiv"";
				 case ByteCode.DDIV: return ""ddiv"";
				 case ByteCode.IREM: return ""irem"";
				 case ByteCode.LREM: return ""lrem"";
				 case ByteCode.FREM: return ""frem"";
				 case ByteCode.DREM: return ""drem"";
				 case ByteCode.INEG: return ""ineg"";
				 case ByteCode.LNEG: return ""lneg"";
				 case ByteCode.FNEG: return ""fneg"";
				 case ByteCode.DNEG: return ""dneg"";
				 case ByteCode.ISHL: return ""ishl"";
				 case ByteCode.LSHL: return ""lshl"";
				 case ByteCode.ISHR: return ""ishr"";
				 case ByteCode.LSHR: return ""lshr"";
				 case ByteCode.IUSHR: return ""iushr"";
				 case ByteCode.LUSHR: return ""lushr"";
				 case ByteCode.IAND: return ""iand"";
				 case ByteCode.LAND: return ""land"";
				 case ByteCode.IOR: return ""ior"";
				 case ByteCode.LOR: return ""lor"";
				 case ByteCode.IXOR: return ""ixor"";
				 case ByteCode.LXOR: return ""lxor"";
				 case ByteCode.IINC: return ""iinc"";
				 case ByteCode.I2L: return ""i2l"";
				 case ByteCode.I2F: return ""i2f"";
				 case ByteCode.I2D: return ""i2d"";
				 case ByteCode.L2I: return ""l2i"";
				 case ByteCode.L2F: return ""l2f"";
				 case ByteCode.L2D: return ""l2d"";
				 case ByteCode.F2I: return ""f2i"";
				 case ByteCode.F2L: return ""f2l"";
				 case ByteCode.F2D: return ""f2d"";
				 case ByteCode.D2I: return ""d2i"";
				 case ByteCode.D2L: return ""d2l"";
				 case ByteCode.D2F: return ""d2f"";
				 case ByteCode.I2B: return ""i2b"";
				 case ByteCode.I2C: return ""i2c"";
				 case ByteCode.I2S: return ""i2s"";
				 case ByteCode.LCMP: return ""lcmp"";
				 case ByteCode.FCMPL: return ""fcmpl"";
				 case ByteCode.FCMPG: return ""fcmpg"";
				 case ByteCode.DCMPL: return ""dcmpl"";
				 case ByteCode.DCMPG: return ""dcmpg"";
				 case ByteCode.IFEQ: return ""ifeq"";
				 case ByteCode.IFNE: return ""ifne"";
				 case ByteCode.IFLT: return ""iflt"";
				 case ByteCode.IFGE: return ""ifge"";
				 case ByteCode.IFGT: return ""ifgt"";
				 case ByteCode.IFLE: return ""ifle"";
				 case ByteCode.IF_ICMPEQ: return ""if_icmpeq"";
				 case ByteCode.IF_ICMPNE: return ""if_icmpne"";
				 case ByteCode.IF_ICMPLT: return ""if_icmplt"";
				 case ByteCode.IF_ICMPGE: return ""if_icmpge"";
				 case ByteCode.IF_ICMPGT: return ""if_icmpgt"";
				 case ByteCode.IF_ICMPLE: return ""if_icmple"";
				 case ByteCode.IF_ACMPEQ: return ""if_acmpeq"";
				 case ByteCode.IF_ACMPNE: return ""if_acmpne"";
				 case ByteCode.GOTO: return ""goto"";
				 case ByteCode.JSR: return ""jsr"";
				 case ByteCode.RET: return ""ret"";
				 case ByteCode.TABLESWITCH: return ""tableswitch"";
				 case ByteCode.LOOKUPSWITCH: return ""lookupswitch"";
				 case ByteCode.IRETURN: return ""ireturn"";
				 case ByteCode.LRETURN: return ""lreturn"";
				 case ByteCode.FRETURN: return ""freturn"";
				 case ByteCode.DRETURN: return ""dreturn"";
				 case ByteCode.ARETURN: return ""areturn"";
				 case ByteCode.RETURN: return ""return"";
				 case ByteCode.GETSTATIC: return ""getstatic"";
				 case ByteCode.PUTSTATIC: return ""putstatic"";
				 case ByteCode.GETFIELD: return ""getfield"";
				 case ByteCode.PUTFIELD: return ""putfield"";
				 case ByteCode.INVOKEVIRTUAL: return ""invokevirtual"";
				 case ByteCode.INVOKESPECIAL: return ""invokespecial"";
				 case ByteCode.INVOKESTATIC: return ""invokestatic"";
				 case ByteCode.INVOKEINTERFACE: return ""invokeinterface"";
				 case ByteCode.NEW: return ""new"";
				 case ByteCode.NEWARRAY: return ""newarray"";
				 case ByteCode.ANEWARRAY: return ""anewarray"";
				 case ByteCode.ARRAYLENGTH: return ""arraylength"";
				 case ByteCode.ATHROW: return ""athrow"";
				 case ByteCode.CHECKCAST: return ""checkcast"";
				 case ByteCode.INSTANCEOF: return ""instanceof"";
				 case ByteCode.MONITORENTER: return ""monitorenter"";
				 case ByteCode.MONITOREXIT: return ""monitorexit"";
				 case ByteCode.WIDE: return ""wide"";
				 case ByteCode.MULTIANEWARRAY: return ""multianewarray"";
				 case ByteCode.IFNULL: return ""ifnull"";
				 case ByteCode.IFNONNULL: return ""ifnonnull"";
				 case ByteCode.GOTO_W: return ""goto_w"";
				 case ByteCode.JSR_W: return ""jsr_w"";
				 case ByteCode.BREAKPOINT: return ""breakpoint"";
				 case ByteCode.IMPDEP1: return ""impdep1"";
				 case ByteCode.IMPDEP2: return ""impdep2"";
			 }
		 }
		 return """";
	 }
	 final char[] getCharBuffer(int minimalSize) {
		 if (minimalSize > tmpCharBuffer.length) {
			 int newSize = tmpCharBuffer.length * 2;
			 if (minimalSize > newSize) {
				 newSize = minimalSize;
			 }
			 tmpCharBuffer = new char[newSize];
		 }
		 return tmpCharBuffer;
	 }
	 private static final int LineNumberTableSize = 16;
	 private static final int ExceptionTableSize = 4;
	 private final static long FileHeaderConstant = 0xCAFEBABE0003002DL;
	 private static final boolean DEBUGSTACK = false;
	 private static final boolean DEBUGLABELS = false;
	 private static final boolean DEBUGCODE = false;
	 private static final int CodeBufferSize = 128;
	 private String generatedClassName;
	 private ExceptionTableEntry itsExceptionTable[];
	 private int itsExceptionTableTop;
	 private int itsLineNumberTable[];
	 private int itsLineNumberTableTop;
	 private byte[] itsCodeBuffer = new byte[256];
	 private int itsCodeBufferTop;
	 private ConstantPool itsConstantPool;
	 private short itsSourceFileAttributeIndex;
	 private ClassFileMethod itsCurrentMethod;
	 private short itsStackTop;
	 private short itsMaxStack;
	 private short itsMaxLocals;
	 private ObjArray itsMethods = new ObjArray();
	 private ObjArray itsFields = new ObjArray();
	 private ObjArray itsInterfaces = new ObjArray();
	 private short itsFlags;
	 private short itsThisClassIndex;
	 private short itsSuperClassIndex;
	 private short itsSourceFileNameIndex;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsVarDescriptors;
	 private char[] tmpCharBuffer = new char[64];
}
final class ExceptionTableEntry{
	 ExceptionTableEntry(int startLabel, int endLabel, int handlerLabel, short catchType) {
		 itsStartLabel = startLabel;
		 itsEndLabel = endLabel;
		 itsHandlerLabel = handlerLabel;
		 itsCatchType = catchType;
	 }
	 int itsStartLabel;
	 int itsEndLabel;
	 int itsHandlerLabel;
	 short itsCatchType;
}
final class ClassFileField{
	 ClassFileField(short nameIndex, short typeIndex, short flags) {
		 itsNameIndex = nameIndex;
		 itsTypeIndex = typeIndex;
		 itsFlags = flags;
		 itsHasAttributes = false;
	 }
	 void setAttributes(short attr1, short attr2, short attr3, int index) {
		 itsHasAttributes = true;
		 itsAttr1 = attr1;
		 itsAttr2 = attr2;
		 itsAttr3 = attr3;
		 itsIndex = index;
	 }
	 int write(byte[] data, int offset) {
		 offset = ClassFileWriter.putInt16(itsFlags, data, offset);
		 offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);
		 offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);
		 if (!itsHasAttributes) {
			 offset = ClassFileWriter.putInt16(0, data, offset);
		 }
		 else {
			 offset = ClassFileWriter.putInt16(1, data, offset);
			 offset = ClassFileWriter.putInt16(itsAttr1, data, offset);
			 offset = ClassFileWriter.putInt16(itsAttr2, data, offset);
			 offset = ClassFileWriter.putInt16(itsAttr3, data, offset);
			 offset = ClassFileWriter.putInt16(itsIndex, data, offset);
		 }
		 return offset;
	 }
	 int getWriteSize() {
		 int size = 2 * 3;
		 if (!itsHasAttributes) {
			 size += 2;
		 }
		 else {
			 size += 2 + 2 * 4;
		 }
		 return size;
	 }
	 private short itsNameIndex;
	 private short itsTypeIndex;
	 private short itsFlags;
	 private boolean itsHasAttributes;
	 private short itsAttr1, itsAttr2, itsAttr3;
	 private int itsIndex;
}
final class ClassFileMethod{
	 ClassFileMethod(short nameIndex, short typeIndex, short flags) {
		 itsNameIndex = nameIndex;
		 itsTypeIndex = typeIndex;
		 itsFlags = flags;
	 }
	 void setCodeAttribute(byte codeAttribute[]) {
		 itsCodeAttribute = codeAttribute;
	 }
	 int write(byte[] data, int offset) {
		 offset = ClassFileWriter.putInt16(itsFlags, data, offset);
		 offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);
		 offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);
		 offset = ClassFileWriter.putInt16(1, data, offset);
		 System.arraycopy(itsCodeAttribute, 0, data, offset, itsCodeAttribute.length);
		 offset += itsCodeAttribute.length;
		 return offset;
	 }
	 int getWriteSize() {
		 return 2 * 4 + itsCodeAttribute.length;
	 }
	 private short itsNameIndex;
	 private short itsTypeIndex;
	 private short itsFlags;
	 private byte[] itsCodeAttribute;
}
final class ConstantPool{
	 ConstantPool(ClassFileWriter cfw) {
		 this.cfw = cfw;
		 itsTopIndex = 1;
		 itsPool = new byte[ConstantPoolSize];
		 itsTop = 0;
	 }
	 private static final int ConstantPoolSize = 256;
	 private static final byte CONSTANT_Class = 7, CONSTANT_Fieldref = 9, CONSTANT_Methodref = 10, CONSTANT_InterfaceMethodref = 11, CONSTANT_String = 8, CONSTANT_Integer = 3, CONSTANT_Float = 4, CONSTANT_Long = 5, CONSTANT_Double = 6, CONSTANT_NameAndType = 12, CONSTANT_Utf8 = 1;
	 int write(byte[] data, int offset) {
		 offset = ClassFileWriter.putInt16((short)itsTopIndex, data, offset);
		 System.arraycopy(itsPool, 0, data, offset, itsTop);
		 offset += itsTop;
		 return offset;
	 }
	 int getWriteSize() {
		 return 2 + itsTop;
	 }
	 int addConstant(int k) {
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_Integer;
		 itsTop = ClassFileWriter.putInt32(k, itsPool, itsTop);
		 return (short)(itsTopIndex++);
	 }
	 int addConstant(long k) {
		 ensure(9);
		 itsPool[itsTop++] = CONSTANT_Long;
		 itsTop = ClassFileWriter.putInt64(k, itsPool, itsTop);
		 int index = itsTopIndex;
		 itsTopIndex += 2;
		 return index;
	 }
	 int addConstant(float k) {
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_Float;
		 int bits = Float.floatToIntBits(k);
		 itsTop = ClassFileWriter.putInt32(bits, itsPool, itsTop);
		 return itsTopIndex++;
	 }
	 int addConstant(double k) {
		 ensure(9);
		 itsPool[itsTop++] = CONSTANT_Double;
		 long bits = Double.doubleToLongBits(k);
		 itsTop = ClassFileWriter.putInt64(bits, itsPool, itsTop);
		 int index = itsTopIndex;
		 itsTopIndex += 2;
		 return index;
	 }
	 int addConstant(String k) {
		 int utf8Index = 0xFFFF & addUtf8(k);
		 int theIndex = itsStringConstHash.getInt(utf8Index, -1);
		 if (theIndex == -1) {
			 theIndex = itsTopIndex++;
			 ensure(3);
			 itsPool[itsTop++] = CONSTANT_String;
			 itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);
			 itsStringConstHash.put(utf8Index, theIndex);
		 }
		 return theIndex;
	 }
	 boolean isUnderUtfEncodingLimit(String s) {
		 int strLen = s.length();
		 if (strLen * 3 <= MAX_UTF_ENCODING_SIZE) {
			 return true;
		 }
		 else if (strLen > MAX_UTF_ENCODING_SIZE) {
			 return false;
		 }
		 return strLen == getUtfEncodingLimit(s, 0, strLen);
	 }
	 int getUtfEncodingLimit(String s, int start, int end) {
		 if ((end - start) * 3 <= MAX_UTF_ENCODING_SIZE) {
			 return end;
		 }
		 int limit = MAX_UTF_ENCODING_SIZE;
		 for (int i = start;
		 i != end;
		 i++) {
			 int c = s.charAt(i);
			 if (0 != c && c <= 0x7F) {
				 --limit;
			 }
			 else if (c < 0x7FF) {
				 limit -= 2;
			 }
			 else {
				 limit -= 3;
			 }
			 if (limit < 0) {
				 return i;
			 }
		 }
		 return end;
	 }
	 short addUtf8(String k) {
		 int theIndex = itsUtf8Hash.get(k, -1);
		 if (theIndex == -1) {
			 int strLen = k.length();
			 boolean tooBigString;
			 if (strLen > MAX_UTF_ENCODING_SIZE) {
				 tooBigString = true;
			 }
			 else {
				 tooBigString = false;
				 ensure(1 + 2 + strLen * 3);
				 int top = itsTop;
				 itsPool[top++] = CONSTANT_Utf8;
				 top += 2;
				 char[] chars = cfw.getCharBuffer(strLen);
				 k.getChars(0, strLen, chars, 0);
				 for (int i = 0;
				 i != strLen;
				 i++) {
					 int c = chars[i];
					 if (c != 0 && c <= 0x7F) {
						 itsPool[top++] = (byte)c;
					 }
					 else if (c > 0x7FF) {
						 itsPool[top++] = (byte)(0xE0 | (c >> 12));
						 itsPool[top++] = (byte)(0x80 | ((c >> 6) & 0x3F));
						 itsPool[top++] = (byte)(0x80 | (c & 0x3F));
					 }
					 else {
						 itsPool[top++] = (byte)(0xC0 | (c >> 6));
						 itsPool[top++] = (byte)(0x80 | (c & 0x3F));
					 }
				 }
				 int utfLen = top - (itsTop + 1 + 2);
				 if (utfLen > MAX_UTF_ENCODING_SIZE) {
					 tooBigString = true;
				 }
				 else {
					 itsPool[itsTop + 1] = (byte)(utfLen >>> 8);
					 itsPool[itsTop + 2] = (byte)utfLen;
					 itsTop = top;
					 theIndex = itsTopIndex++;
					 itsUtf8Hash.put(k, theIndex);
				 }
			 }
			 if (tooBigString) {
				 throw new IllegalArgumentException(""Too big string"");
			 }
		 }
		 return (short)theIndex;
	 }
	 private short addNameAndType(String name, String type) {
		 short nameIndex = addUtf8(name);
		 short typeIndex = addUtf8(type);
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_NameAndType;
		 itsTop = ClassFileWriter.putInt16(nameIndex, itsPool, itsTop);
		 itsTop = ClassFileWriter.putInt16(typeIndex, itsPool, itsTop);
		 return (short)(itsTopIndex++);
	 }
	 short addClass(String className) {
		 int theIndex = itsClassHash.get(className, -1);
		 if (theIndex == -1) {
			 String slashed = className;
			 if (className.indexOf('.') > 0) {
				 slashed = ClassFileWriter.getSlashedForm(className);
				 theIndex = itsClassHash.get(slashed, -1);
				 if (theIndex != -1) {
					 itsClassHash.put(className, theIndex);
				 }
			 }
			 if (theIndex == -1) {
				 int utf8Index = addUtf8(slashed);
				 ensure(3);
				 itsPool[itsTop++] = CONSTANT_Class;
				 itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);
				 theIndex = itsTopIndex++;
				 itsClassHash.put(slashed, theIndex);
				 if (className != slashed) {
					 itsClassHash.put(className, theIndex);
				 }
			 }
		 }
		 return (short)theIndex;
	 }
	 short addFieldRef(String className, String fieldName, String fieldType) {
		 FieldOrMethodRef ref = new FieldOrMethodRef(className, fieldName, fieldType);
		 int theIndex = itsFieldRefHash.get(ref, -1);
		 if (theIndex == -1) {
			 short ntIndex = addNameAndType(fieldName, fieldType);
			 short classIndex = addClass(className);
			 ensure(5);
			 itsPool[itsTop++] = CONSTANT_Fieldref;
			 itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);
			 itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);
			 theIndex = itsTopIndex++;
			 itsFieldRefHash.put(ref, theIndex);
		 }
		 return (short)theIndex;
	 }
	 short addMethodRef(String className, String methodName, String methodType) {
		 FieldOrMethodRef ref = new FieldOrMethodRef(className, methodName, methodType);
		 int theIndex = itsMethodRefHash.get(ref, -1);
		 if (theIndex == -1) {
			 short ntIndex = addNameAndType(methodName, methodType);
			 short classIndex = addClass(className);
			 ensure(5);
			 itsPool[itsTop++] = CONSTANT_Methodref;
			 itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);
			 itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);
			 theIndex = itsTopIndex++;
			 itsMethodRefHash.put(ref, theIndex);
		 }
		 return (short)theIndex;
	 }
	 short addInterfaceMethodRef(String className, String methodName, String methodType) {
		 short ntIndex = addNameAndType(methodName, methodType);
		 short classIndex = addClass(className);
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_InterfaceMethodref;
		 itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);
		 itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);
		 return (short)(itsTopIndex++);
	 }
	 void ensure(int howMuch) {
		 if (itsTop + howMuch > itsPool.length) {
			 int newCapacity = itsPool.length * 2;
			 if (itsTop + howMuch > newCapacity) {
				 newCapacity = itsTop + howMuch;
			 }
			 byte[] tmp = new byte[newCapacity];
			 System.arraycopy(itsPool, 0, tmp, 0, itsTop);
			 itsPool = tmp;
		 }
	 }
	 private ClassFileWriter cfw;
	 private static final int MAX_UTF_ENCODING_SIZE = 65535;
	 private UintMap itsStringConstHash = new UintMap();
	 private ObjToIntMap itsUtf8Hash = new ObjToIntMap();
	 private ObjToIntMap itsFieldRefHash = new ObjToIntMap();
	 private ObjToIntMap itsMethodRefHash = new ObjToIntMap();
	 private UintMap nameAndTypeHash = new UintMap();
	 private ObjToIntMap itsClassHash = new ObjToIntMap();
	 private int itsTop;
	 private int itsTopIndex;
	 private byte itsPool[];
}
final class FieldOrMethodRef{
	 FieldOrMethodRef(String className, String name, String type) {
		 this.className = className;
		 this.name = name;
		 this.type = type;
	 }
	 public boolean equals(Object obj) {
		 if (!(obj instanceof FieldOrMethodRef)) {
			 return false;
		 }
		 FieldOrMethodRef x = (FieldOrMethodRef)obj;
		 return className.equals(x.className) && name.equals(x.name) && type.equals(x.type);
	 }
	 public int hashCode() {
		 if (hashCode == -1) {
			 int h1 = className.hashCode();
			 int h2 = name.hashCode();
			 int h3 = type.hashCode();
			 hashCode = h1 ^ h2 ^ h3;
		 }
		 return hashCode;
	 }
	 private String className;
	 private String name;
	 private String type;
	 private int hashCode = -1;
}",1,0,0,0
"public final class TemplateConfiguration extends Configurable implements ParserConfiguration {
	 private boolean parentConfigurationSet;
	 private Integer tagSyntax;
	 private Integer interpolationSyntax;
	 private Integer namingConvention;
	 private Boolean whitespaceStripping;
	 private Boolean strictSyntaxMode;
	 private Integer autoEscapingPolicy;
	 private Boolean recognizeStandardFileExtensions;
	 private OutputFormat outputFormat;
	 private String encoding;
	 private Integer tabSize;
	 public TemplateConfiguration() {
		 super(Configuration.getDefaultConfiguration());
	 }
	 void setParent(Configurable cfg) {
		 NullArgumentException.check(""cfg"", cfg);
		 if (!(cfg instanceof Configuration)) {
			 throw new IllegalArgumentException(""The parent of a TemplateConfiguration can only be a Configuration"");
		 }
		 if (parentConfigurationSet) {
			 if (getParent() != cfg) {
				 throw new IllegalStateException( ""This TemplateConfiguration is already associated with a different Configuration instance."");
			 }
			 return;
		 }
		 if (((Configuration) cfg).getIncompatibleImprovements().intValue() < _TemplateAPI.VERSION_INT_2_3_22 && hasAnyConfigurableSet()) {
			 throw new IllegalStateException( ""This TemplateConfiguration can't be associated to a Configuration that has "" + ""incompatibleImprovements less than 2.3.22, because it changes non-parser settings."");
		 }
		 super.setParent(cfg);
		 parentConfigurationSet = true;
	 }
	 public void setParentConfiguration(Configuration cfg) {
		 setParent(cfg);
	 }
	 public Configuration getParentConfiguration() {
		 return parentConfigurationSet ? (Configuration) getParent() : null;
	 }
	 private Configuration getNonNullParentConfiguration() {
		 checkParentConfigurationSet();
		 return (Configuration) getParent();
	 }
	 public void merge(TemplateConfiguration tc) {
		 if (tc.isAPIBuiltinEnabledSet()) {
			 setAPIBuiltinEnabled(tc.isAPIBuiltinEnabled());
		 }
		 if (tc.isArithmeticEngineSet()) {
			 setArithmeticEngine(tc.getArithmeticEngine());
		 }
		 if (tc.isAutoEscapingPolicySet()) {
			 setAutoEscapingPolicy(tc.getAutoEscapingPolicy());
		 }
		 if (tc.isAutoFlushSet()) {
			 setAutoFlush(tc.getAutoFlush());
		 }
		 if (tc.isBooleanFormatSet()) {
			 setBooleanFormat(tc.getBooleanFormat());
		 }
		 if (tc.isClassicCompatibleSet()) {
			 setClassicCompatibleAsInt(tc.getClassicCompatibleAsInt());
		 }
		 if (tc.isCustomDateFormatsSet()) {
			 setCustomDateFormats(mergeMaps(getCustomDateFormats(), tc.getCustomDateFormats(), false));
		 }
		 if (tc.isCustomNumberFormatsSet()) {
			 setCustomNumberFormats(mergeMaps(getCustomNumberFormats(), tc.getCustomNumberFormats(), false));
		 }
		 if (tc.isDateFormatSet()) {
			 setDateFormat(tc.getDateFormat());
		 }
		 if (tc.isDateTimeFormatSet()) {
			 setDateTimeFormat(tc.getDateTimeFormat());
		 }
		 if (tc.isEncodingSet()) {
			 setEncoding(tc.getEncoding());
		 }
		 if (tc.isLocaleSet()) {
			 setLocale(tc.getLocale());
		 }
		 if (tc.isLogTemplateExceptionsSet()) {
			 setLogTemplateExceptions(tc.getLogTemplateExceptions());
		 }
		 if (tc.isWrapUncheckedExceptionsSet()) {
			 setWrapUncheckedExceptions(tc.getWrapUncheckedExceptions());
		 }
		 if (tc.isNamingConventionSet()) {
			 setNamingConvention(tc.getNamingConvention());
		 }
		 if (tc.isNewBuiltinClassResolverSet()) {
			 setNewBuiltinClassResolver(tc.getNewBuiltinClassResolver());
		 }
		 if (tc.isTruncateBuiltinAlgorithmSet()) {
			 setTruncateBuiltinAlgorithm(tc.getTruncateBuiltinAlgorithm());
		 }
		 if (tc.isNumberFormatSet()) {
			 setNumberFormat(tc.getNumberFormat());
		 }
		 if (tc.isObjectWrapperSet()) {
			 setObjectWrapper(tc.getObjectWrapper());
		 }
		 if (tc.isOutputEncodingSet()) {
			 setOutputEncoding(tc.getOutputEncoding());
		 }
		 if (tc.isOutputFormatSet()) {
			 setOutputFormat(tc.getOutputFormat());
		 }
		 if (tc.isRecognizeStandardFileExtensionsSet()) {
			 setRecognizeStandardFileExtensions(tc.getRecognizeStandardFileExtensions());
		 }
		 if (tc.isShowErrorTipsSet()) {
			 setShowErrorTips(tc.getShowErrorTips());
		 }
		 if (tc.isSQLDateAndTimeTimeZoneSet()) {
			 setSQLDateAndTimeTimeZone(tc.getSQLDateAndTimeTimeZone());
		 }
		 if (tc.isStrictSyntaxModeSet()) {
			 setStrictSyntaxMode(tc.getStrictSyntaxMode());
		 }
		 if (tc.isTagSyntaxSet()) {
			 setTagSyntax(tc.getTagSyntax());
		 }
		 if (tc.isInterpolationSyntaxSet()) {
			 setInterpolationSyntax(tc.getInterpolationSyntax());
		 }
		 if (tc.isTemplateExceptionHandlerSet()) {
			 setTemplateExceptionHandler(tc.getTemplateExceptionHandler());
		 }
		 if (tc.isAttemptExceptionReporterSet()) {
			 setAttemptExceptionReporter(tc.getAttemptExceptionReporter());
		 }
		 if (tc.isTimeFormatSet()) {
			 setTimeFormat(tc.getTimeFormat());
		 }
		 if (tc.isTimeZoneSet()) {
			 setTimeZone(tc.getTimeZone());
		 }
		 if (tc.isURLEscapingCharsetSet()) {
			 setURLEscapingCharset(tc.getURLEscapingCharset());
		 }
		 if (tc.isWhitespaceStrippingSet()) {
			 setWhitespaceStripping(tc.getWhitespaceStripping());
		 }
		 if (tc.isTabSizeSet()) {
			 setTabSize(tc.getTabSize());
		 }
		 if (tc.isLazyImportsSet()) {
			 setLazyImports(tc.getLazyImports());
		 }
		 if (tc.isLazyAutoImportsSet()) {
			 setLazyAutoImports(tc.getLazyAutoImports());
		 }
		 if (tc.isAutoImportsSet()) {
			 setAutoImports(mergeMaps(getAutoImportsWithoutFallback(), tc.getAutoImportsWithoutFallback(), true));
		 }
		 if (tc.isAutoIncludesSet()) {
			 setAutoIncludes(mergeLists(getAutoIncludesWithoutFallback(), tc.getAutoIncludesWithoutFallback()));
		 }
		 tc.copyDirectCustomAttributes(this, true);
	 }
	 public void apply(Template template) {
		 Configuration cfg = getNonNullParentConfiguration();
		 if (template.getConfiguration() != cfg) {
			 throw new IllegalArgumentException( ""The argument Template doesn't belong to the same Configuration as the TemplateConfiguration"");
		 }
		 if (isAPIBuiltinEnabledSet() && !template.isAPIBuiltinEnabledSet()) {
			 template.setAPIBuiltinEnabled(isAPIBuiltinEnabled());
		 }
		 if (isArithmeticEngineSet() && !template.isArithmeticEngineSet()) {
			 template.setArithmeticEngine(getArithmeticEngine());
		 }
		 if (isAutoFlushSet() && !template.isAutoFlushSet()) {
			 template.setAutoFlush(getAutoFlush());
		 }
		 if (isBooleanFormatSet() && !template.isBooleanFormatSet()) {
			 template.setBooleanFormat(getBooleanFormat());
		 }
		 if (isClassicCompatibleSet() && !template.isClassicCompatibleSet()) {
			 template.setClassicCompatibleAsInt(getClassicCompatibleAsInt());
		 }
		 if (isCustomDateFormatsSet()) {
			 template.setCustomDateFormats( mergeMaps(getCustomDateFormats(), template.getCustomDateFormatsWithoutFallback(), false));
		 }
		 if (isCustomNumberFormatsSet()) {
			 template.setCustomNumberFormats( mergeMaps(getCustomNumberFormats(), template.getCustomNumberFormatsWithoutFallback(), false));
		 }
		 if (isDateFormatSet() && !template.isDateFormatSet()) {
			 template.setDateFormat(getDateFormat());
		 }
		 if (isDateTimeFormatSet() && !template.isDateTimeFormatSet()) {
			 template.setDateTimeFormat(getDateTimeFormat());
		 }
		 if (isEncodingSet() && template.getEncoding() == null) {
			 template.setEncoding(getEncoding());
		 }
		 if (isLocaleSet() && !template.isLocaleSet()) {
			 template.setLocale(getLocale());
		 }
		 if (isLogTemplateExceptionsSet() && !template.isLogTemplateExceptionsSet()) {
			 template.setLogTemplateExceptions(getLogTemplateExceptions());
		 }
		 if (isWrapUncheckedExceptionsSet() && !template.isWrapUncheckedExceptionsSet()) {
			 template.setWrapUncheckedExceptions(getWrapUncheckedExceptions());
		 }
		 if (isNewBuiltinClassResolverSet() && !template.isNewBuiltinClassResolverSet()) {
			 template.setNewBuiltinClassResolver(getNewBuiltinClassResolver());
		 }
		 if (isTruncateBuiltinAlgorithmSet() && !template.isTruncateBuiltinAlgorithmSet()) {
			 template.setTruncateBuiltinAlgorithm(getTruncateBuiltinAlgorithm());
		 }
		 if (isNumberFormatSet() && !template.isNumberFormatSet()) {
			 template.setNumberFormat(getNumberFormat());
		 }
		 if (isObjectWrapperSet() && !template.isObjectWrapperSet()) {
			 template.setObjectWrapper(getObjectWrapper());
		 }
		 if (isOutputEncodingSet() && !template.isOutputEncodingSet()) {
			 template.setOutputEncoding(getOutputEncoding());
		 }
		 if (isShowErrorTipsSet() && !template.isShowErrorTipsSet()) {
			 template.setShowErrorTips(getShowErrorTips());
		 }
		 if (isSQLDateAndTimeTimeZoneSet() && !template.isSQLDateAndTimeTimeZoneSet()) {
			 template.setSQLDateAndTimeTimeZone(getSQLDateAndTimeTimeZone());
		 }
		 if (isTemplateExceptionHandlerSet() && !template.isTemplateExceptionHandlerSet()) {
			 template.setTemplateExceptionHandler(getTemplateExceptionHandler());
		 }
		 if (isAttemptExceptionReporterSet() && !template.isAttemptExceptionReporterSet()) {
			 template.setAttemptExceptionReporter(getAttemptExceptionReporter());
		 }
		 if (isTimeFormatSet() && !template.isTimeFormatSet()) {
			 template.setTimeFormat(getTimeFormat());
		 }
		 if (isTimeZoneSet() && !template.isTimeZoneSet()) {
			 template.setTimeZone(getTimeZone());
		 }
		 if (isURLEscapingCharsetSet() && !template.isURLEscapingCharsetSet()) {
			 template.setURLEscapingCharset(getURLEscapingCharset());
		 }
		 if (isLazyImportsSet() && !template.isLazyImportsSet()) {
			 template.setLazyImports(getLazyImports());
		 }
		 if (isLazyAutoImportsSet() && !template.isLazyAutoImportsSet()) {
			 template.setLazyAutoImports(getLazyAutoImports());
		 }
		 if (isAutoImportsSet()) {
			 template.setAutoImports(mergeMaps(getAutoImports(), template.getAutoImportsWithoutFallback(), true));
		 }
		 if (isAutoIncludesSet()) {
			 template.setAutoIncludes(mergeLists(getAutoIncludes(), template.getAutoIncludesWithoutFallback()));
		 }
		 copyDirectCustomAttributes(template, false);
	 }
	 public void setTagSyntax(int tagSyntax) {
		 _TemplateAPI.valideTagSyntaxValue(tagSyntax);
		 this.tagSyntax = Integer.valueOf(tagSyntax);
	 }
	 public int getTagSyntax() {
		 return tagSyntax != null ? tagSyntax.intValue() : getNonNullParentConfiguration().getTagSyntax();
	 }
	 public boolean isTagSyntaxSet() {
		 return tagSyntax != null;
	 }
	 public void setInterpolationSyntax(int interpolationSyntax) {
		 _TemplateAPI.valideInterpolationSyntaxValue(interpolationSyntax);
		 this.interpolationSyntax = Integer.valueOf(interpolationSyntax);
	 }
	 public int getInterpolationSyntax() {
		 return interpolationSyntax != null ? interpolationSyntax.intValue() : getNonNullParentConfiguration().getInterpolationSyntax();
	 }
	 public boolean isInterpolationSyntaxSet() {
		 return interpolationSyntax != null;
	 }
	 public void setNamingConvention(int namingConvention) {
		 _TemplateAPI.validateNamingConventionValue(namingConvention);
		 this.namingConvention = Integer.valueOf(namingConvention);
	 }
	 public int getNamingConvention() {
		 return namingConvention != null ? namingConvention.intValue() : getNonNullParentConfiguration().getNamingConvention();
	 }
	 public boolean isNamingConventionSet() {
		 return namingConvention != null;
	 }
	 public void setWhitespaceStripping(boolean whitespaceStripping) {
		 this.whitespaceStripping = Boolean.valueOf(whitespaceStripping);
	 }
	 public boolean getWhitespaceStripping() {
		 return whitespaceStripping != null ? whitespaceStripping.booleanValue() : getNonNullParentConfiguration().getWhitespaceStripping();
	 }
	 public boolean isWhitespaceStrippingSet() {
		 return whitespaceStripping != null;
	 }
	 public void setAutoEscapingPolicy(int autoEscapingPolicy) {
		 _TemplateAPI.validateAutoEscapingPolicyValue(autoEscapingPolicy);
		 this.autoEscapingPolicy = Integer.valueOf(autoEscapingPolicy);
	 }
	 public int getAutoEscapingPolicy() {
		 return autoEscapingPolicy != null ? autoEscapingPolicy.intValue() : getNonNullParentConfiguration().getAutoEscapingPolicy();
	 }
	 public boolean isAutoEscapingPolicySet() {
		 return autoEscapingPolicy != null;
	 }
	 public void setOutputFormat(OutputFormat outputFormat) {
		 NullArgumentException.check(""outputFormat"", outputFormat);
		 this.outputFormat = outputFormat;
	 }
	 public OutputFormat getOutputFormat() {
		 return outputFormat != null ? outputFormat : getNonNullParentConfiguration().getOutputFormat();
	 }
	 public boolean isOutputFormatSet() {
		 return outputFormat != null;
	 }
	 public void setRecognizeStandardFileExtensions(boolean recognizeStandardFileExtensions) {
		 this.recognizeStandardFileExtensions = Boolean.valueOf(recognizeStandardFileExtensions);
	 }
	 public boolean getRecognizeStandardFileExtensions() {
		 return recognizeStandardFileExtensions != null ? recognizeStandardFileExtensions.booleanValue() : getNonNullParentConfiguration().getRecognizeStandardFileExtensions();
	 }
	 public boolean isRecognizeStandardFileExtensionsSet() {
		 return recognizeStandardFileExtensions != null;
	 }
	 public void setStrictSyntaxMode(boolean strictSyntaxMode) {
		 this.strictSyntaxMode = Boolean.valueOf(strictSyntaxMode);
	 }
	 public boolean getStrictSyntaxMode() {
		 return strictSyntaxMode != null ? strictSyntaxMode.booleanValue() : getNonNullParentConfiguration().getStrictSyntaxMode();
	 }
	 public boolean isStrictSyntaxModeSet() {
		 return strictSyntaxMode != null;
	 }
	 public void setStrictBeanModels(boolean strict) {
		 throw new UnsupportedOperationException( ""Setting strictBeanModels on "" + TemplateConfiguration.class.getSimpleName() + "" level isn't supported."");
	 }
	 public String getEncoding() {
		 return encoding != null ? encoding : getNonNullParentConfiguration().getDefaultEncoding();
	 }
	 public void setEncoding(String encoding) {
		 NullArgumentException.check(""encoding"", encoding);
		 this.encoding = encoding;
	 }
	 public boolean isEncodingSet() {
		 return encoding != null;
	 }
	 public void setTabSize(int tabSize) {
		 this.tabSize = Integer.valueOf(tabSize);
	 }
	 public int getTabSize() {
		 return tabSize != null ? tabSize.intValue() : getNonNullParentConfiguration().getTabSize();
	 }
	 public boolean isTabSizeSet() {
		 return tabSize != null;
	 }
	 public Version getIncompatibleImprovements() {
		 return getNonNullParentConfiguration().getIncompatibleImprovements();
	 }
	 private void checkParentConfigurationSet() {
		 if (!parentConfigurationSet) {
			 throw new IllegalStateException(""The TemplateConfiguration wasn't associated with a Configuration yet."");
		 }
	 }
	 private boolean hasAnyConfigurableSet() {
		 return isAPIBuiltinEnabledSet() || isArithmeticEngineSet() || isAutoFlushSet() || isAutoImportsSet() || isAutoIncludesSet() || isBooleanFormatSet() || isClassicCompatibleSet() || isCustomDateFormatsSet() || isCustomNumberFormatsSet() || isDateFormatSet() || isDateTimeFormatSet() || isLazyImportsSet() || isLazyAutoImportsSet() || isLocaleSet() || isLogTemplateExceptionsSet() || isWrapUncheckedExceptionsSet() || isNewBuiltinClassResolverSet() || isTruncateBuiltinAlgorithmSet() || isNumberFormatSet() || isObjectWrapperSet() || isOutputEncodingSet() || isShowErrorTipsSet() || isSQLDateAndTimeTimeZoneSet() || isTemplateExceptionHandlerSet() || isAttemptExceptionReporterSet() || isTimeFormatSet() || isTimeZoneSet() || isURLEscapingCharsetSet();
	 }
	 private Map mergeMaps(Map m1, Map m2, boolean overwriteUpdatesOrder) {
		 if (m1 == null) return m2;
		 if (m2 == null) return m1;
		 if (m1.isEmpty()) return m2;
		 if (m2.isEmpty()) return m1;
		 LinkedHashMap mergedM = new LinkedHashMap((m1.size() + m2.size()) * 4 / 3 + 1, 0.75f);
		 mergedM.putAll(m1);
		 for (Object m2Key : m2.keySet()) {
			 mergedM.remove(m2Key);
		 }
		 mergedM.putAll(m2);
		 return mergedM;
	 }
	 private List<String> mergeLists(List<String> list1, List<String> list2) {
		 if (list1 == null) return list2;
		 if (list2 == null) return list1;
		 if (list1.isEmpty()) return list2;
		 if (list2.isEmpty()) return list1;
		 ArrayList<String> mergedList = new ArrayList<String>(list1.size() + list2.size());
		 mergedList.addAll(list1);
		 mergedList.addAll(list2);
		 return mergedList;
	 }
}",1,1,0,0
"public class ReplaceRecord<L> extends PageDeltaRecord {
	 private BPlusIO<L> io;
	 private byte[] rowBytes;
	 private int idx;
	 public ReplaceRecord(int grpId, long pageId, BPlusIO<L> io, byte[] rowBytes, int idx) {
		 super(grpId, pageId);
		 this.io = io;
		 this.rowBytes = rowBytes;
		 this.idx = idx;
	 }
	 public void applyDelta(PageMemory pageMem, long pageAddr) throws IgniteCheckedException {
		 if (io.getCount(pageAddr) < idx) throw new DeltaApplicationException(""Index is greater than count: "" + idx);
		 io.store(pageAddr, idx, null, rowBytes, false);
	 }
	 public RecordType type() {
		 return RecordType.BTREE_PAGE_REPLACE;
	 }
	 public BPlusIO<L> io() {
		 return io;
	 }
	 public int index() {
		 return idx;
	 }
	 public byte[] rowBytes() {
		 return rowBytes;
	 }
	 public String toString() {
		 return S.toString(ReplaceRecord.class, this, ""super"", super.toString());
	 }
}",0,0,0,0
"public class StructuredMenuItemHolder {
	private JMenuItem menuItem;
	private Action action;
	private MenuItemEnabledListener enabledListener;
	private MenuItemSelectedListener selectionListener;
	public StructuredMenuItemHolder() {
	}
	public Action getAction() {
		return action;
	}
	public void setAction(Action action) {
		this.action = action;
		if (action instanceof MenuItemEnabledListener) {
			MenuItemEnabledListener listener = (MenuItemEnabledListener) action;
			setEnabledListener(listener);
		}
		if (action instanceof MenuItemSelectedListener) {
			MenuItemSelectedListener listener = (MenuItemSelectedListener) action;
			setSelectedListener(listener);
		}
	}
	public MenuItemEnabledListener getEnabledListener() {
		return enabledListener;
	}
	public void setEnabledListener(MenuItemEnabledListener enabledListener) {
		this.enabledListener = enabledListener;
	}
	public JMenuItem getMenuItem() {
		return menuItem;
	}
	public void setMenuItem(JMenuItem menuItem) {
		this.menuItem = menuItem;
	}
	public MenuItemSelectedListener getSelectionListener() {
		return selectionListener;
	}
	public void setSelectedListener(MenuItemSelectedListener selectionListener) {
		this.selectionListener = selectionListener;
	}
}",0,1,0,0
"public class ListKeysResult extends com.ibm.cloud.objectstorage.AmazonWebServiceResult<com.ibm.cloud.objectstorage.ResponseMetadata> implements Serializable, Cloneable {
	 private com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry> keys;
	 private String nextMarker;
	 private Boolean truncated;
	 public java.util.List<KeyListEntry> getKeys() {
		 if (keys == null) {
			 keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>();
		 }
		 return keys;
	 }
	 public void setKeys(java.util.Collection<KeyListEntry> keys) {
		 if (keys == null) {
			 this.keys = null;
			 return;
		 }
		 this.keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>(keys);
	 }
	 public ListKeysResult withKeys(KeyListEntry... keys) {
		 if (this.keys == null) {
			 setKeys(new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>(keys.length));
		 }
		 for (KeyListEntry ele : keys) {
			 this.keys.add(ele);
		 }
		 return this;
	 }
	 public ListKeysResult withKeys(java.util.Collection<KeyListEntry> keys) {
		 setKeys(keys);
		 return this;
	 }
	 public void setNextMarker(String nextMarker) {
		 this.nextMarker = nextMarker;
	 }
	 public String getNextMarker() {
		 return this.nextMarker;
	 }
	 public ListKeysResult withNextMarker(String nextMarker) {
		 setNextMarker(nextMarker);
		 return this;
	 }
	 public void setTruncated(Boolean truncated) {
		 this.truncated = truncated;
	 }
	 public Boolean getTruncated() {
		 return this.truncated;
	 }
	 public ListKeysResult withTruncated(Boolean truncated) {
		 setTruncated(truncated);
		 return this;
	 }
	 public Boolean isTruncated() {
		 return this.truncated;
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 sb.append(""{
			"");
			 if (getKeys() != null) sb.append(""Keys: "").append(getKeys()).append("","");
			 if (getNextMarker() != null) sb.append(""NextMarker: "").append(getNextMarker()).append("","");
			 if (getTruncated() != null) sb.append(""Truncated: "").append(getTruncated());
		 sb.append(""}
		"");
		 return sb.toString();
	 }
	 public boolean equals(Object obj) {
		 if (this == obj) return true;
		 if (obj == null) return false;
		 if (obj instanceof ListKeysResult == false) return false;
		 ListKeysResult other = (ListKeysResult) obj;
		 if (other.getKeys() == null ^ this.getKeys() == null) return false;
		 if (other.getKeys() != null && other.getKeys().equals(this.getKeys()) == false) return false;
		 if (other.getNextMarker() == null ^ this.getNextMarker() == null) return false;
		 if (other.getNextMarker() != null && other.getNextMarker().equals(this.getNextMarker()) == false) return false;
		 if (other.getTruncated() == null ^ this.getTruncated() == null) return false;
		 if (other.getTruncated() != null && other.getTruncated().equals(this.getTruncated()) == false) return false;
		 return true;
	 }
	 public int hashCode() {
		 final int prime = 31;
		 int hashCode = 1;
		 hashCode = prime * hashCode + ((getKeys() == null) ? 0 : getKeys().hashCode());
		 hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode());
		 hashCode = prime * hashCode + ((getTruncated() == null) ? 0 : getTruncated().hashCode());
		 return hashCode;
	 }
	 public ListKeysResult clone() {
		 try {
			 return (ListKeysResult) super.clone();
		 }
		 catch (CloneNotSupportedException e) {
			 throw new IllegalStateException(""Got a CloneNotSupportedException from Object.clone() "" + ""even though we're Cloneable!"", e);
		 }
	 }
}",1,1,0,0
"public class PageExtractor{
	 private PDDocument sourceDocument;
	 private int startPage = 1;
	 private int endPage = 0;
	 public PageExtractor(PDDocument sourceDocument) {
		 this.sourceDocument = sourceDocument;
		 endPage = sourceDocument.getNumberOfPages();
	 }
	 public PageExtractor(PDDocument sourceDocument, int startPage, int endPage) {
		 this(sourceDocument);
		 this.startPage = startPage;
		 this.endPage = endPage;
	 }
	 public PDDocument extract() throws IOException {
		 PDDocument extractedDocument = new PDDocument();
		 extractedDocument.setDocumentInformation(sourceDocument.getDocumentInformation());
		 extractedDocument.getDocumentCatalog().setViewerPreferences( sourceDocument.getDocumentCatalog().getViewerPreferences());
		 for (int i = startPage;
		 i <= endPage;
		 i++) {
			 PDPage page = sourceDocument.getPage(i - 1);
			 PDPage imported = extractedDocument.importPage(page);
			 imported.setCropBox(page.getCropBox());
			 imported.setMediaBox(page.getMediaBox());
			 imported.setResources(page.getResources());
			 imported.setRotation(page.getRotation());
		 }
		 return extractedDocument;
	 }
	 public int getStartPage() {
		 return startPage;
	 }
	 public void setStartPage(int startPage) {
		 this.startPage = startPage;
	 }
	 public int getEndPage() {
		 return endPage;
	 }
	 public void setEndPage(int endPage) {
		 this.endPage = endPage;
	 }
}",1,1,0,0
"public class Tower extends Item {
	 private Fit fit;
	 private String tubing;
	 public static enum Fit {
	 Custom, Exact, Universal }
	 public Fit getFit() {
		 return fit;
	 }
	 public void setFit(Fit fit) {
		 this.fit = fit;
	 }
	 public String getTubing() {
		 return tubing;
	 }
	 public void setTubing(String tubing) {
		 this.tubing = tubing;
	 }
	 ;
}",0,1,0,0
"public void testBug56655a() throws IOException {
	 try (Workbook wb = _testDataProvider.createWorkbook()) {
		 Sheet sheet = wb.createSheet();
		 setCellFormula(sheet, 0, 0, ""B1*C1"");
		 sheet.getRow(0).createCell(1).setCellValue(""A"");
		 setCellFormula(sheet, 1, 0, ""B1*C1"");
		 sheet.getRow(1).createCell(1).setCellValue(""A"");
		 setCellFormula(sheet, 0, 3, ""SUMIFS(A:A,A:A,A2)"");
		 wb.getCreationHelper().createFormulaEvaluator().evaluateAll();
		 assertEquals(CellType.ERROR, getCell(sheet, 0, 0).getCachedFormulaResultType());
		 assertEquals(FormulaError.VALUE.getCode(), getCell(sheet, 0, 0).getErrorCellValue());
		 assertEquals(CellType.ERROR, getCell(sheet, 1, 0).getCachedFormulaResultType());
		 assertEquals(FormulaError.VALUE.getCode(), getCell(sheet, 1, 0).getErrorCellValue());
		 assertEquals(CellType.ERROR, getCell(sheet, 0, 3).getCachedFormulaResultType());
		 assertEquals(FormulaError.VALUE.getCode(), getCell(sheet, 0, 3).getErrorCellValue());
	 }
 }",0,0,1,0
private void updateDate();,0,0,0,0
"public class ConnectionPool {
	final SQLAuthenticator authenticator;
	final DbProperties dbProps;
	 final PoolElement pool[];
	 volatile int p = 0, idCnt=0;
	 public ConnectionPool (SQLAuthenticator authenticator, DbProperties dbProps) {
		 this.authenticator = authenticator;
		 this.dbProps = dbProps;
		 pool = new PoolElement[dbProps.poolsize];
		 if (Server.TRACE_CREATE_AND_FINALIZE) {
			 Server.log (this, ""++++++++++++++++++++++++++++++++++++++++CREATE"", Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
		 }
	 }
	 public void shutdown () {
		 synchronized (this.pool) {
			 for (int i = 0;
			 i < pool.length;
			 i++) {
				 if (pool[i] == null) {
					 continue;
				 }
				 pool[i].cleanup ();
				 pool[i]=null;
			 }
		 }
	 }
	 private PoolElement createPoolElement () throws Exception {
		 idCnt++;
		 if (idCnt == Integer.MAX_VALUE) {
			 idCnt = 0;
		 }
		 Connection con = DriverManager.getConnection (dbProps.url, dbProps.conProps);
		 return new PoolElement (this, con, dbProps, idCnt);
	 }
	 public PoolElement getPoolElement (int retrys, ConnectionBuffer cb) throws Exception {
		 for (int i = 0;
		 i<retrys;
		 i++) {
			 if ((cb != null && !cb.isValid()) || Thread.currentThread().isInterrupted()) throw new CanceledRequestException (""ConnectionBuffer has been invalidated"");
			 PoolElement el=null;
			 try {
				 el = this.getPoolElement(cb);
				 if (el!=null) return el;
			 }
			 catch (CanceledRequestException cre) {
				 throw cre;
			 }
			 catch (Exception e) {
				 Server.debug(Thread.currentThread() , this.toString() + ""getPoolElement: "", e, Server.MSG_AUTH, Server.LVL_MAJOR);
				 el = null;
			 }
		 }
		 if (Server.srv.isRunning()) throw new Exception (""Unable to get available PoolElement"");
		 else throw new Exception (""Unable to get available PoolElement - Server shutting down"");
	 }
	 private PoolElement getPoolElement (ConnectionBuffer cb) throws Exception {
		 for (int i = 0;
		 i < dbProps.poolsize;
		 i++) {
			 if ((cb != null && !cb.isValid()) || Thread.currentThread().isInterrupted()) throw new CanceledRequestException (""ConnectionBuffer has been invalidated"");
			 if (!Server.srv.isRunning()) {
				 StringBuffer sb = new StringBuffer(""Created no new Connetion - Server shutting down"");
				 Server.log (""ConnectionPool"", sb.toString(), Server.MSG_AUTH, Server.LVL_VERBOSE);
				 return null;
			 }
			 p++;
			 if (p > dbProps.poolsize - 1) p=0;
			 synchronized (this.pool) {
				 if (pool[p]==null) {
					 pool[p] = createPoolElement();
				 }
				 switch (pool[p].grab()) {
					 case PoolElement.INVALID: pool[p].cleanup();
					 pool[p]=createPoolElement();
					 case PoolElement.IDLE: return pool[p];
					 case PoolElement.ACTIVE: continue;
				 }
			 }
		 }
		 return null;
	 }
	 public int size() {
		 return pool.length;
	 }
	 public void finalize() {
		 if (Server.TRACE_CREATE_AND_FINALIZE) Server.log(this, ""----------------------------------------FINALIZED"", Server.MSG_STATE, Server.LVL_VERY_VERBOSE);
	 }
	 private ConnectionPool() throws Exception {
		 throw new Exception (""not instatiable without arguments"");
	 }
}",0,0,0,0
"private void initComponents() {
	 java.awt.GridBagConstraints gridBagConstraints;
	 m_fileChooser = new javax.swing.JFileChooser();
	 m_popupMenu = new javax.swing.JPopupMenu();
	 m_menuAddItem = new javax.swing.JMenuItem();
	 m_menuRemoveItem = new javax.swing.JMenuItem();
	 jSeparator3 = new javax.swing.JSeparator();
	 m_menuItemUp = new javax.swing.JMenuItem();
	 jPanel1 = new javax.swing.JPanel();
	 jLabel5 = new javax.swing.JLabel();
	 m_exeName = new javax.swing.JTextField();
	 m_labelName = new javax.swing.JLabel();
	 m_name = new javax.swing.JTextField();
	 jLabel1 = new javax.swing.JLabel();
	 jScrollPane1 = new javax.swing.JScrollPane();
	 m_description = new javax.swing.JEditorPane();
	 jLabel2 = new javax.swing.JLabel();
	 m_categoryName = new javax.swing.JTextField();
	 jLabel3 = new javax.swing.JLabel();
	 m_jarId = new javax.swing.JTextField();
	 jLabel4 = new javax.swing.JLabel();
	 m_propsId = new javax.swing.JTextField();
	 m_cbDebug = new javax.swing.JCheckBox();
	 m_tablescrollpane = new javax.swing.JScrollPane();
	 m_propTable = new javax.swing.JTable();
	 jMenuBar1 = new javax.swing.JMenuBar();
	 jMenu1 = new javax.swing.JMenu();
	 m_menuNew = new javax.swing.JMenuItem();
	 m_menuLoadKBML = new javax.swing.JMenuItem();
	 m_menuLoad = new javax.swing.JMenuItem();
	 jSeparator1 = new javax.swing.JSeparator();
	 m_menuSaveKbml = new javax.swing.JMenuItem();
	 m_menuSave = new javax.swing.JMenuItem();
	 jSeparator2 = new javax.swing.JSeparator();
	 m_menuExit = new javax.swing.JMenuItem();
	 m_fileChooser.setCurrentDirectory(new java.io.File(""c:\\""));
	 m_fileChooser.setFileFilter(new javax.swing.filechooser.FileFilter() {
		 public boolean accept(File f) {
			 if (f.toString().endsWith("".skel"")) return true;
			 if (f.isDirectory()) return true;
			 return false;
		 }
		 public String getDescription() {
			 return ""JSmooth Skeletons (*.skel)"";
		 }
	 }
	);
	 m_fileChooser.setFileSelectionMode(javax.swing.JFileChooser.FILES_AND_DIRECTORIES);
	 m_menuAddItem.setText(""Add item"");
	 m_menuAddItem.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuAddItemActionPerformed(evt);
		 }
	 }
	);
	 m_popupMenu.add(m_menuAddItem);
	 m_menuRemoveItem.setText(""RemoveItems"");
	 m_menuRemoveItem.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuRemoveItemActionPerformed(evt);
		 }
	 }
	);
	 m_popupMenu.add(m_menuRemoveItem);
	 m_popupMenu.add(jSeparator3);
	 m_menuItemUp.setText(""Item Up"");
	 m_menuItemUp.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuItemUpActionPerformed(evt);
		 }
	 }
	);
	 m_popupMenu.add(m_menuItemUp);
	 getContentPane().setLayout(new java.awt.GridBagLayout());
	 setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
	 setTitle(""JSmooth Skeleton Editor"");
	 addWindowListener(new java.awt.event.WindowAdapter() {
		 public void windowClosing(java.awt.event.WindowEvent evt) {
			 exitForm(evt);
		 }
	 }
	);
	 jPanel1.setLayout(new java.awt.GridBagLayout());
	 jPanel1.setBorder(new javax.swing.border.EtchedBorder());
	 jLabel5.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
	 jLabel5.setText(""Executable Name"");
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
	 jPanel1.add(jLabel5, gridBagConstraints);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 0.5;
	 jPanel1.add(m_exeName, gridBagConstraints);
	 m_labelName.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
	 m_labelName.setText(""Short Name"");
	 m_labelName.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridy = 1;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
	 jPanel1.add(m_labelName, gridBagConstraints);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridy = 1;
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 0.5;
	 jPanel1.add(m_name, gridBagConstraints);
	 jLabel1.setText(""Description"");
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
	 jPanel1.add(jLabel1, gridBagConstraints);
	 jScrollPane1.setViewportView(m_description);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 0.5;
	 gridBagConstraints.weighty = 0.5;
	 jPanel1.add(jScrollPane1, gridBagConstraints);
	 jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
	 jLabel2.setText(""Category Name"");
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
	 jPanel1.add(jLabel2, gridBagConstraints);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 0.5;
	 jPanel1.add(m_categoryName, gridBagConstraints);
	 jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
	 jLabel3.setText(""Resource Id for JAR"");
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
	 jPanel1.add(jLabel3, gridBagConstraints);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 jPanel1.add(m_jarId, gridBagConstraints);
	 jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
	 jLabel4.setText(""Resource Id for Properties"");
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
	 jPanel1.add(jLabel4, gridBagConstraints);
	 m_propsId.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 m_propsIdActionPerformed(evt);
		 }
	 }
	);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 jPanel1.add(m_propsId, gridBagConstraints);
	 m_cbDebug.setText(""Mark this wrapper for debugging only"");
	 m_cbDebug.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 jPanel1.add(m_cbDebug, gridBagConstraints);
	 m_tablescrollpane.addMouseListener(new java.awt.event.MouseAdapter() {
		 public void mousePressed(java.awt.event.MouseEvent evt) {
			 tablescrollpaneMousePressed(evt);
		 }
		 public void mouseReleased(java.awt.event.MouseEvent evt) {
			 tablescrollpaneMouseReleased(evt);
		 }
	 }
	);
	 m_propTable.setModel(new javax.swing.table.DefaultTableModel( new Object [][] {
		 {
		null, null, null, null, null}
		, {
		null, null, null, null, null}
		, {
		null, null, null, null, null}
		, {
		null, null, null, null, null}
	 }
	, new String [] {
	 ""Id"", ""Label"", ""Description"", ""Type"", ""Value"" }
	 ));
	 m_propTable.addMouseListener(new java.awt.event.MouseAdapter() {
		 public void mouseClicked(java.awt.event.MouseEvent evt) {
			 propTableMouseClicked(evt);
		 }
		 public void mousePressed(java.awt.event.MouseEvent evt) {
			 propTableMousePressed(evt);
		 }
		 public void mouseReleased(java.awt.event.MouseEvent evt) {
			 propTableMouseReleased(evt);
		 }
	 }
	);
	 m_tablescrollpane.setViewportView(m_propTable);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 1.0;
	 gridBagConstraints.weighty = 1.0;
	 jPanel1.add(m_tablescrollpane, gridBagConstraints);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridx = 1;
	 gridBagConstraints.gridy = 1;
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 0.9;
	 gridBagConstraints.weighty = 0.9;
	 getContentPane().add(jPanel1, gridBagConstraints);
	 jMenu1.setText(""System"");
	 m_menuNew.setText(""New"");
	 m_menuNew.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuNewActionPerformed(evt);
		 }
	 }
	);
	 jMenu1.add(m_menuNew);
	 m_menuLoadKBML.setText(""Load"");
	 m_menuLoadKBML.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuLoadKBMLActionPerformed(evt);
		 }
	 }
	);
	 jMenu1.add(m_menuLoadKBML);
	 m_menuLoad.setText(""Load (deprecated)"");
	 m_menuLoad.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuLoadActionPerformed(evt);
		 }
	 }
	);
	 jMenu1.add(m_menuLoad);
	 jMenu1.add(jSeparator1);
	 m_menuSaveKbml.setText(""Save"");
	 m_menuSaveKbml.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 saveKbmlActionPerformed(evt);
		 }
	 }
	);
	 jMenu1.add(m_menuSaveKbml);
	 m_menuSave.setText(""Save (deprecated)"");
	 m_menuSave.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 menuSaveActionPerformed(evt);
		 }
	 }
	);
	 jMenu1.add(m_menuSave);
	 jMenu1.add(jSeparator2);
	 m_menuExit.setText(""Exit"");
	 jMenu1.add(m_menuExit);
	 jMenuBar1.add(jMenu1);
	 setJMenuBar(jMenuBar1);
	 java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
	 setBounds((screenSize.width-400)/2, (screenSize.height-254)/2, 400, 254);
 }",0,0,1,0
"public void validate() {
	 Enumeration e = selectorElements();
	 while (e.hasMoreElements()) {
		 Object o = e.nextElement();
		 if (o instanceof BaseSelector) {
			 ((BaseSelector) o).validate();
		 }
	 }
 }",0,0,0,0
"public List<PropertyType> fromProps(Map<String, Object> m) {
	 List<PropertyType> props = new ArrayList<PropertyType>();
	 for (Map.Entry<String, Object> entry : m.entrySet()) {
		 String key = entry.getKey();
		 Object val = entry.getValue();
		 PropertyType propEl = new PropertyType();
		 propEl.setName(key);
		 ObjectFactory factory = new ObjectFactory();
		 if (val.getClass().isArray()) {
			 ArrayType arrayEl = new ArrayType();
			 propEl.getContent().add(factory.createArray(arrayEl));
			 for (Object o : normalizeArray(val)) {
				 setValueType(propEl, o);
				 ValueType valueType = new ValueType();
				 valueType.getContent().add(o.toString());
				 arrayEl.getValue().add(valueType);
			 }
		 }
		 else if (val instanceof List) {
			 ArrayType listEl = new ArrayType();
			 propEl.getContent().add(factory.createList(listEl));
			 handleCollectionValue((Collection<T>) val, propEl, listEl);
		 }
		 else if (val instanceof Set) {
			 ArrayType setEl = new ArrayType();
			 propEl.getContent().add(factory.createSet(setEl));
			 handleCollectionValue((Collection<T>) val, propEl, setEl);
		 }
		 else if (val instanceof String || val instanceof Character || val instanceof Boolean || val instanceof Byte) {
			 setValueType(propEl, val);
			 propEl.setValue(val.toString());
		 }
		 else if (val instanceof Long || val instanceof Double || val instanceof Float || val instanceof Integer || val instanceof Short) {
			 setValueType(propEl, val);
			 propEl.setValue(val.toString());
		 }
		 else {
			 continue;
		 }
		 props.add(propEl);
	 }
	 return props;
 }",0,0,1,0
"public SettingsFrame() {
	 setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
	 setTitle(BundleMessage.format(""UI_DAVMAIL_SETTINGS""));
	 try {
		 setIconImage(DavGatewayTray.getFrameIcon());
	 }
	 catch (NoSuchMethodError error) {
		 DavGatewayTray.debug(new BundleMessage(""LOG_UNABLE_TO_SET_ICON_IMAGE""));
	 }
	 JTabbedPane tabbedPane = new JTabbedPane();
	 tabbedPane.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(KeyStroke.getKeyStroke(""F1""), ""help"");
	 tabbedPane.getActionMap().put(""help"", new AbstractAction() {
		 public void actionPerformed(ActionEvent e) {
		 DesktopBrowser.browse(""http: }
	 }
	);
	 tabbedPane.addChangeListener(new ChangeListener() {
		 public void stateChanged(ChangeEvent e) {
			 boolean isSslEnabled = isSslEnabled();
			 popNoSSLCheckBox.setEnabled(Settings.getProperty(""davmail.popPort"") != null && isSslEnabled);
			 imapNoSSLCheckBox.setEnabled(imapPortCheckBox.isSelected() && isSslEnabled);
			 smtpNoSSLCheckBox.setEnabled(smtpPortCheckBox.isSelected() && isSslEnabled);
			 caldavNoSSLCheckBox.setEnabled(caldavPortCheckBox.isSelected() && isSslEnabled);
			 ldapNoSSLCheckBox.setEnabled(ldapPortCheckBox.isSelected() && isSslEnabled);
		 }
	 }
	);
	 JPanel mainPanel = new JPanel();
	 mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
	 mainPanel.add(getSettingsPanel());
	 mainPanel.add(getDelaysPanel());
	 mainPanel.add(Box.createVerticalGlue());
	 tabbedPane.add(BundleMessage.format(""UI_TAB_MAIN""), mainPanel);
	 JPanel proxyPanel = new JPanel();
	 proxyPanel.setLayout(new BoxLayout(proxyPanel, BoxLayout.Y_AXIS));
	 proxyPanel.add(getProxyPanel());
	 proxyPanel.add(getNetworkSettingsPanel());
	 tabbedPane.add(BundleMessage.format(""UI_TAB_NETWORK""), proxyPanel);
	 JPanel encryptionPanel = new JPanel();
	 encryptionPanel.setLayout(new BoxLayout(encryptionPanel, BoxLayout.Y_AXIS));
	 encryptionPanel.add(getKeystorePanel());
	 encryptionPanel.add(getSmartCardPanel());
	 encryptionPanel.add(new JPanel());
	 tabbedPane.add(BundleMessage.format(""UI_TAB_ENCRYPTION""), encryptionPanel);
	 JPanel loggingPanel = new JPanel();
	 loggingPanel.setLayout(new BoxLayout(loggingPanel, BoxLayout.Y_AXIS));
	 loggingPanel.add(getLoggingSettingsPanel());
	 loggingPanel.add(new JPanel());
	 tabbedPane.add(BundleMessage.format(""UI_TAB_LOGGING""), loggingPanel);
	 JPanel advancedPanel = new JPanel();
	 advancedPanel.setLayout(new BoxLayout(advancedPanel, BoxLayout.Y_AXIS));
	 advancedPanel.add(getOtherSettingsPanel());
	 advancedPanel.add(new JPanel());
	 tabbedPane.add(BundleMessage.format(""UI_TAB_ADVANCED""), advancedPanel);
	 if (OSXInfoPlist.isOSX()) {
		 JPanel osxPanel = new JPanel();
		 osxPanel.setLayout(new BoxLayout(osxPanel, BoxLayout.Y_AXIS));
		 osxPanel.add(getOSXPanel());
		 osxPanel.add(new JPanel());
		 tabbedPane.add(BundleMessage.format(""UI_TAB_OSX""), osxPanel);
	 }
	 add(BorderLayout.CENTER, tabbedPane);
	 JPanel buttonPanel = new JPanel();
	 JButton cancel = new JButton(BundleMessage.format(""UI_BUTTON_CANCEL""));
	 JButton ok = new JButton(BundleMessage.format(""UI_BUTTON_SAVE""));
	 JButton help = new JButton(BundleMessage.format(""UI_BUTTON_HELP""));
	 ActionListener save = new ActionListener() {
		 public void actionPerformed(ActionEvent evt) {
			 Settings.setProperty(""davmail.url"", urlField.getText());
			 Settings.setProperty(""davmail.popPort"", popPortCheckBox.isSelected() ? popPortField.getText() : """");
			 Settings.setProperty(""davmail.ssl.nosecurepop"", String.valueOf(popNoSSLCheckBox.isSelected()));
			 Settings.setProperty(""davmail.imapPort"", imapPortCheckBox.isSelected() ? imapPortField.getText() : """");
			 Settings.setProperty(""davmail.ssl.nosecureimap"", String.valueOf(imapNoSSLCheckBox.isSelected()));
			 Settings.setProperty(""davmail.smtpPort"", smtpPortCheckBox.isSelected() ? smtpPortField.getText() : """");
			 Settings.setProperty(""davmail.ssl.nosecuresmtp"", String.valueOf(smtpNoSSLCheckBox.isSelected()));
			 Settings.setProperty(""davmail.caldavPort"", caldavPortCheckBox.isSelected() ? caldavPortField.getText() : """");
			 Settings.setProperty(""davmail.ssl.nosecurecaldav"", String.valueOf(caldavNoSSLCheckBox.isSelected()));
			 Settings.setProperty(""davmail.ldapPort"", ldapPortCheckBox.isSelected() ? ldapPortField.getText() : """");
			 Settings.setProperty(""davmail.ssl.nosecureldap"", String.valueOf(ldapNoSSLCheckBox.isSelected()));
			 Settings.setProperty(""davmail.keepDelay"", keepDelayField.getText());
			 Settings.setProperty(""davmail.sentKeepDelay"", sentKeepDelayField.getText());
			 Settings.setProperty(""davmail.caldavPastDelay"", caldavPastDelayField.getText());
			 Settings.setProperty(""davmail.imapIdleDelay"", imapIdleDelayField.getText());
			 Settings.setProperty(""davmail.useSystemProxies"", String.valueOf(useSystemProxiesField.isSelected()));
			 Settings.setProperty(""davmail.enableProxy"", String.valueOf(enableProxyField.isSelected()));
			 Settings.setProperty(""davmail.proxyHost"", httpProxyField.getText());
			 Settings.setProperty(""davmail.proxyPort"", httpProxyPortField.getText());
			 Settings.setProperty(""davmail.proxyUser"", httpProxyUserField.getText());
			 Settings.setProperty(""davmail.proxyPassword"", httpProxyPasswordField.getText());
			 Settings.setProperty(""davmail.noProxyFor"", noProxyForField.getText());
			 Settings.setProperty(""davmail.bindAddress"", bindAddressField.getText());
			 Settings.setProperty(""davmail.clientSoTimeout"", String.valueOf(clientSoTimeoutField.getText()));
			 Settings.setProperty(""davmail.allowRemote"", String.valueOf(allowRemoteField.isSelected()));
			 Settings.setProperty(""davmail.server.certificate.hash"", certHashField.getText());
			 Settings.setProperty(""davmail.disableUpdateCheck"", String.valueOf(disableUpdateCheck.isSelected()));
			 Settings.setProperty(""davmail.caldavEditNotifications"", String.valueOf(caldavEditNotificationsField.isSelected()));
			 Settings.setProperty(""davmail.caldavAlarmSound"", String.valueOf(caldavAlarmSoundField.getText()));
			 Settings.setProperty(""davmail.forceActiveSyncUpdate"", String.valueOf(forceActiveSyncUpdateCheckBox.isSelected()));
			 Settings.setProperty(""davmail.defaultDomain"", String.valueOf(defaultDomainField.getText()));
			 Settings.setProperty(""davmail.showStartupBanner"", String.valueOf(showStartupBannerCheckBox.isSelected()));
			 Settings.setProperty(""davmail.disableGuiNotifications"", String.valueOf(disableGuiNotificationsCheckBox.isSelected()));
			 Settings.setProperty(""davmail.imapAutoExpunge"", String.valueOf(imapAutoExpungeCheckBox.isSelected()));
			 Settings.setProperty(""davmail.enableKeepAlive"", String.valueOf(enableKeepAliveCheckBox.isSelected()));
			 Settings.setProperty(""davmail.popMarkReadOnRetr"", String.valueOf(popMarkReadOnRetrCheckBox.isSelected()));
			 String selectedEwsMode = (String) enableEwsComboBox.getSelectedItem();
			 String enableEws;
			 if (EWS.equals(selectedEwsMode)) {
				 enableEws = ""true"";
			 }
			 else if (WEBDAV.equals(selectedEwsMode)) {
				 enableEws = ""false"";
			 }
			 else {
				 enableEws = ""auto"";
			 }
			 Settings.setProperty(""davmail.enableEws"", enableEws);
			 Settings.setProperty(""davmail.enableKerberos"", String.valueOf(enableKerberosCheckBox.isSelected()));
			 Settings.setProperty(""davmail.folderSizeLimit"", folderSizeLimitField.getText());
			 Settings.setProperty(""davmail.smtpSaveInSent"", String.valueOf(smtpSaveInSentCheckBox.isSelected()));
			 Settings.setProperty(""davmail.ssl.keystoreType"", (String) keystoreTypeCombo.getSelectedItem());
			 Settings.setProperty(""davmail.ssl.keystoreFile"", keystoreFileField.getText());
			 Settings.setProperty(""davmail.ssl.keystorePass"", String.valueOf(keystorePassField.getPassword()));
			 Settings.setProperty(""davmail.ssl.keyPass"", String.valueOf(keyPassField.getPassword()));
			 Settings.setProperty(""davmail.ssl.clientKeystoreType"", (String) clientKeystoreTypeCombo.getSelectedItem());
			 Settings.setProperty(""davmail.ssl.clientKeystoreFile"", clientKeystoreFileField.getText());
			 Settings.setProperty(""davmail.ssl.clientKeystorePass"", String.valueOf(clientKeystorePassField.getPassword()));
			 Settings.setProperty(""davmail.ssl.pkcs11Library"", pkcs11LibraryField.getText());
			 Settings.setProperty(""davmail.ssl.pkcs11Config"", pkcs11ConfigField.getText());
			 Settings.setLoggingLevel(""rootLogger"", (Level) rootLoggingLevelField.getSelectedItem());
			 Settings.setLoggingLevel(""davmail"", (Level) davmailLoggingLevelField.getSelectedItem());
			 Settings.setLoggingLevel(""org.apache.commons.httpclient"", (Level) httpclientLoggingLevelField.getSelectedItem());
			 Settings.setLoggingLevel(""httpclient.wire"", (Level) wireLoggingLevelField.getSelectedItem());
			 Settings.setProperty(""davmail.logFilePath"", logFilePathField.getText());
			 Settings.setProperty(""davmail.logFileSize"", logFileSizeField.getText());
			 setVisible(false);
			 Settings.save();
			 if (osxHideFromDockCheckBox != null) {
				 OSXInfoPlist.setOSXHideFromDock(osxHideFromDockCheckBox.isSelected());
			 }
			 DavGateway.restart();
		 }
	 }
	;
	 ok.addActionListener(save);
	 cancel.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent evt) {
			 reload();
			 setVisible(false);
		 }
	 }
	);
	 help.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent e) {
		 DesktopBrowser.browse(""http: }
	 }
	);
	 buttonPanel.add(ok);
	 buttonPanel.add(cancel);
	 buttonPanel.add(help);
	 add(BorderLayout.SOUTH, buttonPanel);
	 pack();
	 setLocation(getToolkit().getScreenSize().width / 2 - getSize().width / 2, getToolkit().getScreenSize().height / 2 - getSize().height / 2);
	 urlField.requestFocus();
 }",0,0,1,0
"public class ClassFileWriter {
	 public ClassFileWriter(String className, String superClassName, String sourceFileName) {
		 generatedClassName = className;
		 itsConstantPool = new ConstantPool(this);
		 itsThisClassIndex = itsConstantPool.addClass(className);
		 itsSuperClassIndex = itsConstantPool.addClass(superClassName);
		 if (sourceFileName != null) itsSourceFileNameIndex = itsConstantPool.addUtf8(sourceFileName);
		 itsFlags = ACC_PUBLIC;
	 }
	 public final String getClassName() {
		 return generatedClassName;
	 }
	 public void addInterface(String interfaceName) {
		 short interfaceIndex = itsConstantPool.addClass(interfaceName);
		 itsInterfaces.add(new Short(interfaceIndex));
	 }
	 public static final short ACC_PUBLIC = 0x0001, ACC_PRIVATE = 0x0002, ACC_PROTECTED = 0x0004, ACC_STATIC = 0x0008, ACC_FINAL = 0x0010, ACC_SYNCHRONIZED = 0x0020, ACC_VOLATILE = 0x0040, ACC_TRANSIENT = 0x0080, ACC_NATIVE = 0x0100, ACC_ABSTRACT = 0x0400;
	 public void setFlags(short flags) {
		 itsFlags = flags;
	 }
	 static String getSlashedForm(String name) {
		 return name.replace('.', '/');
	 }
	 public static String classNameToSignature(String name) {
		 int nameLength = name.length();
		 int colonPos = 1 + nameLength;
		 char[] buf = new char[colonPos + 1];
		 buf[0] = 'L';
		 buf[colonPos] = ';
		';
		 name.getChars(0, nameLength, buf, 1);
		 for (int i = 1;
		 i != colonPos;
		 ++i) {
			 if (buf[i] == '.') {
				 buf[i] = '/';
			 }
		 }
		 return new String(buf, 0, colonPos + 1);
	 }
	 public void addField(String fieldName, String type, short flags) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 itsFields.add(new ClassFileField(fieldNameIndex, typeIndex, flags));
	 }
	 public void addField(String fieldName, String type, short flags, int value) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex, flags);
		 field.setAttributes(itsConstantPool.addUtf8(""ConstantValue""), (short)0, (short)0, itsConstantPool.addConstant(value));
		 itsFields.add(field);
	 }
	 public void addField(String fieldName, String type, short flags, long value) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex, flags);
		 field.setAttributes(itsConstantPool.addUtf8(""ConstantValue""), (short)0, (short)2, itsConstantPool.addConstant(value));
		 itsFields.add(field);
	 }
	 public void addField(String fieldName, String type, short flags, double value) {
		 short fieldNameIndex = itsConstantPool.addUtf8(fieldName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 ClassFileField field = new ClassFileField(fieldNameIndex, typeIndex, flags);
		 field.setAttributes(itsConstantPool.addUtf8(""ConstantValue""), (short)0, (short)2, itsConstantPool.addConstant(value));
		 itsFields.add(field);
	 }
	 public void addVariableDescriptor(String name, String type, int startPC, int register) {
		 int nameIndex = itsConstantPool.addUtf8(name);
		 int descriptorIndex = itsConstantPool.addUtf8(type);
		 int [] chunk = {
		 nameIndex, descriptorIndex, startPC, register }
		;
		 if (itsVarDescriptors == null) {
			 itsVarDescriptors = new ObjArray();
		 }
		 itsVarDescriptors.add(chunk);
	 }
	 public void startMethod(String methodName, String type, short flags) {
		 short methodNameIndex = itsConstantPool.addUtf8(methodName);
		 short typeIndex = itsConstantPool.addUtf8(type);
		 itsCurrentMethod = new ClassFileMethod(methodNameIndex, typeIndex, flags);
		 itsMethods.add(itsCurrentMethod);
	 }
	 public void stopMethod(short maxLocals) {
		 if (itsCurrentMethod == null) throw new IllegalStateException(""No method to stop"");
		 fixLabelGotos();
		 itsMaxLocals = maxLocals;
		 int lineNumberTableLength = 0;
		 if (itsLineNumberTable != null) {
			 lineNumberTableLength = 6 + 2 + (itsLineNumberTableTop * 4);
		 }
		 int variableTableLength = 0;
		 if (itsVarDescriptors != null) {
			 variableTableLength = 6 + 2 + (itsVarDescriptors.size() * 10);
		 }
		 int attrLength = 2 + 4 + 2 + 2 + 4 + itsCodeBufferTop + 2 + (itsExceptionTableTop * 8) + 2 + lineNumberTableLength + variableTableLength;
		 byte[] codeAttribute = new byte[attrLength];
		 int index = 0;
		 int codeAttrIndex = itsConstantPool.addUtf8(""Code"");
		 index = putInt16(codeAttrIndex, codeAttribute, index);
		 attrLength -= 6;
		 index = putInt32(attrLength, codeAttribute, index);
		 index = putInt16(itsMaxStack, codeAttribute, index);
		 index = putInt16(itsMaxLocals, codeAttribute, index);
		 index = putInt32(itsCodeBufferTop, codeAttribute, index);
		 System.arraycopy(itsCodeBuffer, 0, codeAttribute, index, itsCodeBufferTop);
		 index += itsCodeBufferTop;
		 if (itsExceptionTableTop > 0) {
			 index = putInt16(itsExceptionTableTop, codeAttribute, index);
			 for (int i = 0;
			 i < itsExceptionTableTop;
			 i++) {
				 ExceptionTableEntry ete = itsExceptionTable[i];
				 short startPC = (short)getLabelPC(ete.itsStartLabel);
				 short endPC = (short)getLabelPC(ete.itsEndLabel);
				 short handlerPC = (short)getLabelPC(ete.itsHandlerLabel);
				 short catchType = ete.itsCatchType;
				 if (startPC == -1) throw new IllegalStateException(""start label not defined"");
				 if (endPC == -1) throw new IllegalStateException(""end label not defined"");
				 if (handlerPC == -1) throw new IllegalStateException( ""handler label not defined"");
				 index = putInt16(startPC, codeAttribute, index);
				 index = putInt16(endPC, codeAttribute, index);
				 index = putInt16(handlerPC, codeAttribute, index);
				 index = putInt16(catchType, codeAttribute, index);
			 }
		 }
		 else {
			 index = putInt16(0, codeAttribute, index);
		 }
		 int attributeCount = 0;
		 if (itsLineNumberTable != null) attributeCount++;
		 if (itsVarDescriptors != null) attributeCount++;
		 index = putInt16(attributeCount, codeAttribute, index);
		 if (itsLineNumberTable != null) {
			 int lineNumberTableAttrIndex = itsConstantPool.addUtf8(""LineNumberTable"");
			 index = putInt16(lineNumberTableAttrIndex, codeAttribute, index);
			 int tableAttrLength = 2 + (itsLineNumberTableTop * 4);
			 index = putInt32(tableAttrLength, codeAttribute, index);
			 index = putInt16(itsLineNumberTableTop, codeAttribute, index);
			 for (int i = 0;
			 i < itsLineNumberTableTop;
			 i++) {
				 index = putInt32(itsLineNumberTable[i], codeAttribute, index);
			 }
		 }
		 if (itsVarDescriptors != null) {
			 int variableTableAttrIndex = itsConstantPool.addUtf8(""LocalVariableTable"");
			 index = putInt16(variableTableAttrIndex, codeAttribute, index);
			 int varCount = itsVarDescriptors.size();
			 int tableAttrLength = 2 + (varCount * 10);
			 index = putInt32(tableAttrLength, codeAttribute, index);
			 index = putInt16(varCount, codeAttribute, index);
			 for (int i = 0;
			 i < varCount;
			 i++) {
				 int[] chunk = (int[])itsVarDescriptors.get(i);
				 int nameIndex = chunk[0];
				 int descriptorIndex = chunk[1];
				 int startPC = chunk[2];
				 int register = chunk[3];
				 int length = itsCodeBufferTop - startPC;
				 index = putInt16(startPC, codeAttribute, index);
				 index = putInt16(length, codeAttribute, index);
				 index = putInt16(nameIndex, codeAttribute, index);
				 index = putInt16(descriptorIndex, codeAttribute, index);
				 index = putInt16(register, codeAttribute, index);
			 }
		 }
		 itsCurrentMethod.setCodeAttribute(codeAttribute);
		 itsExceptionTable = null;
		 itsExceptionTableTop = 0;
		 itsLineNumberTableTop = 0;
		 itsCodeBufferTop = 0;
		 itsCurrentMethod = null;
		 itsMaxStack = 0;
		 itsStackTop = 0;
		 itsLabelTableTop = 0;
		 itsFixupTableTop = 0;
		 itsVarDescriptors = null;
	 }
	 public void add(int theOpCode) {
		 if (opcodeCount(theOpCode) != 0) throw new IllegalArgumentException(""Unexpected operands"");
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 if (DEBUGCODE) System.out.println(""Add "" + bytecodeStr(theOpCode));
		 addToCodeBuffer(theOpCode);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void add(int theOpCode, int theOperand) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+Integer.toHexString(theOperand));
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 switch (theOpCode) {
			 case ByteCode.GOTO : case ByteCode.IFEQ : case ByteCode.IFNE : case ByteCode.IFLT : case ByteCode.IFGE : case ByteCode.IFGT : case ByteCode.IFLE : case ByteCode.IF_ICMPEQ : case ByteCode.IF_ICMPNE : case ByteCode.IF_ICMPLT : case ByteCode.IF_ICMPGE : case ByteCode.IF_ICMPGT : case ByteCode.IF_ICMPLE : case ByteCode.IF_ACMPEQ : case ByteCode.IF_ACMPNE : case ByteCode.JSR : case ByteCode.IFNULL : case ByteCode.IFNONNULL : {
				 if ((theOperand & 0x80000000) != 0x80000000) {
					 if ((theOperand < 0) || (theOperand > 65535)) throw new IllegalArgumentException( ""Bad label for branch"");
				 }
				 int branchPC = itsCodeBufferTop;
				 addToCodeBuffer(theOpCode);
				 if ((theOperand & 0x80000000) != 0x80000000) {
					 addToCodeInt16(theOperand);
				 }
				 else {
					 int targetPC = getLabelPC(theOperand);
					 if (DEBUGLABELS) {
						 int theLabel = theOperand & 0x7FFFFFFF;
						 System.out.println(""Fixing branch to "" + theLabel + "" at "" + targetPC + "" from "" + branchPC);
					 }
					 if (targetPC != -1) {
						 int offset = targetPC - branchPC;
						 addToCodeInt16(offset);
					 }
					 else {
						 addLabelFixup(theOperand, branchPC + 1);
						 addToCodeInt16(0);
					 }
				 }
			 }
			 break;
			 case ByteCode.BIPUSH : if ((byte)theOperand != theOperand) throw new IllegalArgumentException(""out of range byte"");
			 addToCodeBuffer(theOpCode);
			 addToCodeBuffer((byte)theOperand);
			 break;
			 case ByteCode.SIPUSH : if ((short)theOperand != theOperand) throw new IllegalArgumentException(""out of range short"");
			 addToCodeBuffer(theOpCode);
			 addToCodeInt16(theOperand);
			 break;
			 case ByteCode.NEWARRAY : if (!(0 <= theOperand && theOperand < 256)) throw new IllegalArgumentException(""out of range index"");
			 addToCodeBuffer(theOpCode);
			 addToCodeBuffer(theOperand);
			 break;
			 case ByteCode.GETFIELD : case ByteCode.PUTFIELD : if (!(0 <= theOperand && theOperand < 65536)) throw new IllegalArgumentException(""out of range field"");
			 addToCodeBuffer(theOpCode);
			 addToCodeInt16(theOperand);
			 break;
			 case ByteCode.LDC : case ByteCode.LDC_W : case ByteCode.LDC2_W : if (!(0 <= theOperand && theOperand < 65536)) throw new IllegalArgumentException(""out of range index"");
			 if (theOperand >= 256 || theOpCode == ByteCode.LDC_W || theOpCode == ByteCode.LDC2_W) {
				 if (theOpCode == ByteCode.LDC) {
					 addToCodeBuffer(ByteCode.LDC_W);
				 }
				 else {
					 addToCodeBuffer(theOpCode);
				 }
				 addToCodeInt16(theOperand);
			 }
			 else {
				 addToCodeBuffer(theOpCode);
				 addToCodeBuffer(theOperand);
			 }
			 break;
			 case ByteCode.RET : case ByteCode.ILOAD : case ByteCode.LLOAD : case ByteCode.FLOAD : case ByteCode.DLOAD : case ByteCode.ALOAD : case ByteCode.ISTORE : case ByteCode.LSTORE : case ByteCode.FSTORE : case ByteCode.DSTORE : case ByteCode.ASTORE : if (!(0 <= theOperand && theOperand < 65536)) throw new IllegalArgumentException(""out of range variable"");
			 if (theOperand >= 256) {
				 addToCodeBuffer(ByteCode.WIDE);
				 addToCodeBuffer(theOpCode);
				 addToCodeInt16(theOperand);
			 }
			 else {
				 addToCodeBuffer(theOpCode);
				 addToCodeBuffer(theOperand);
			 }
			 break;
			 default : throw new IllegalArgumentException( ""Unexpected opcode for 1 operand"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void addLoadConstant(int k) {
		 add(ByteCode.LDC, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(long k) {
		 add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(float k) {
		 add(ByteCode.LDC, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(double k) {
		 add(ByteCode.LDC2_W, itsConstantPool.addConstant(k));
	 }
	 public void addLoadConstant(String k) {
		 add(ByteCode.LDC, itsConstantPool.addConstant(k));
	 }
	 public void add(int theOpCode, int theOperand1, int theOperand2) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+Integer.toHexString(theOperand1) +"", ""+Integer.toHexString(theOperand2));
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 if (theOpCode == ByteCode.IINC) {
			 if (!(0 <= theOperand1 && theOperand1 < 65536)) throw new IllegalArgumentException(""out of range variable"");
			 if (!(0 <= theOperand2 && theOperand2 < 65536)) throw new IllegalArgumentException(""out of range increment"");
			 if (theOperand1 > 255 || theOperand2 < -128 || theOperand2 > 127) {
				 addToCodeBuffer(ByteCode.WIDE);
				 addToCodeBuffer(ByteCode.IINC);
				 addToCodeInt16(theOperand1);
				 addToCodeInt16(theOperand2);
			 }
			 else {
				 addToCodeBuffer(ByteCode.WIDE);
				 addToCodeBuffer(ByteCode.IINC);
				 addToCodeBuffer(theOperand1);
				 addToCodeBuffer(theOperand2);
			 }
		 }
		 else if (theOpCode == ByteCode.MULTIANEWARRAY) {
			 if (!(0 <= theOperand1 && theOperand1 < 65536)) throw new IllegalArgumentException(""out of range index"");
			 if (!(0 <= theOperand2 && theOperand2 < 256)) throw new IllegalArgumentException(""out of range dimensions"");
			 addToCodeBuffer(ByteCode.MULTIANEWARRAY);
			 addToCodeInt16(theOperand1);
			 addToCodeBuffer(theOperand2);
		 }
		 else {
			 throw new IllegalArgumentException( ""Unexpected opcode for 2 operands"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void add(int theOpCode, String className) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+className);
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 switch (theOpCode) {
			 case ByteCode.NEW : case ByteCode.ANEWARRAY : case ByteCode.CHECKCAST : case ByteCode.INSTANCEOF : {
				 short classIndex = itsConstantPool.addClass(className);
				 addToCodeBuffer(theOpCode);
				 addToCodeInt16(classIndex);
			 }
			 break;
			 default : throw new IllegalArgumentException( ""bad opcode for class reference"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void add(int theOpCode, String className, String fieldName, String fieldType) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+className+"", ""+fieldName+"", ""+fieldType);
		 }
		 int newStack = itsStackTop + stackChange(theOpCode);
		 char fieldTypeChar = fieldType.charAt(0);
		 int fieldSize = (fieldTypeChar == 'J' || fieldTypeChar == 'D') ? 2 : 1;
		 switch (theOpCode) {
			 case ByteCode.GETFIELD : case ByteCode.GETSTATIC : newStack += fieldSize;
			 break;
			 case ByteCode.PUTSTATIC : case ByteCode.PUTFIELD : newStack -= fieldSize;
			 break;
			 default : throw new IllegalArgumentException( ""bad opcode for field reference"");
		 }
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 short fieldRefIndex = itsConstantPool.addFieldRef(className, fieldName, fieldType);
		 addToCodeBuffer(theOpCode);
		 addToCodeInt16(fieldRefIndex);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void addInvoke(int theOpCode, String className, String methodName, String methodType) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(theOpCode) +"", ""+className+"", ""+methodName+"", "" +methodType);
		 }
		 int parameterInfo = sizeOfParameters(methodType);
		 int parameterCount = parameterInfo >>> 16;
		 int stackDiff = (short)parameterInfo;
		 int newStack = itsStackTop + stackDiff;
		 newStack += stackChange(theOpCode);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 switch (theOpCode) {
			 case ByteCode.INVOKEVIRTUAL : case ByteCode.INVOKESPECIAL : case ByteCode.INVOKESTATIC : case ByteCode.INVOKEINTERFACE : {
				 addToCodeBuffer(theOpCode);
				 if (theOpCode == ByteCode.INVOKEINTERFACE) {
					 short ifMethodRefIndex = itsConstantPool.addInterfaceMethodRef( className, methodName, methodType);
					 addToCodeInt16(ifMethodRefIndex);
					 addToCodeBuffer(parameterCount + 1);
					 addToCodeBuffer(0);
				 }
				 else {
					 short methodRefIndex = itsConstantPool.addMethodRef( className, methodName, methodType);
					 addToCodeInt16(methodRefIndex);
				 }
			 }
			 break;
			 default : throw new IllegalArgumentException( ""bad opcode for method reference"");
		 }
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(theOpCode) +"" stack = ""+itsStackTop);
		 }
	 }
	 public void addPush(int k) {
		 if ((byte)k == k) {
			 if (k == -1) {
				 add(ByteCode.ICONST_M1);
			 }
			 else if (0 <= k && k <= 5) {
				 add((byte)(ByteCode.ICONST_0 + k));
			 }
			 else {
				 add(ByteCode.BIPUSH, (byte)k);
			 }
		 }
		 else if ((short)k == k) {
			 add(ByteCode.SIPUSH, (short)k);
		 }
		 else {
			 addLoadConstant(k);
		 }
	 }
	 public void addPush(boolean k) {
		 add(k ? ByteCode.ICONST_1 : ByteCode.ICONST_0);
	 }
	 public void addPush(long k) {
		 int ik = (int)k;
		 if (ik == k) {
			 addPush(ik);
			 add(ByteCode.I2L);
		 }
		 else {
			 addLoadConstant(k);
		 }
	 }
	 public void addPush(double k) {
		 if (k == 0.0) {
			 add(ByteCode.DCONST_0);
			 if (1.0 / k < 0) {
				 add(ByteCode.DNEG);
			 }
		 }
		 else if (k == 1.0 || k == -1.0) {
			 add(ByteCode.DCONST_1);
			 if (k < 0) {
				 add(ByteCode.DNEG);
			 }
		 }
		 else {
			 addLoadConstant(k);
		 }
	 }
	 public void addPush(String k) {
		 int length = k.length();
		 int limit = itsConstantPool.getUtfEncodingLimit(k, 0, length);
		 if (limit == length) {
			 addLoadConstant(k);
			 return;
		 }
		 final String SB = ""java/lang/StringBuffer"";
		 add(ByteCode.NEW, SB);
		 add(ByteCode.DUP);
		 addPush(length);
		 addInvoke(ByteCode.INVOKESPECIAL, SB, ""<init>"", ""(I)V"");
		 int cursor = 0;
		 for (;
		;
		) {
			 add(ByteCode.DUP);
			 String s = k.substring(cursor, limit);
			 addLoadConstant(s);
			 addInvoke(ByteCode.INVOKEVIRTUAL, SB, ""append"", ""(Ljava/lang/String;
			)Ljava/lang/StringBuffer;
			"");
			 add(ByteCode.POP);
			 if (limit == length) {
				 break;
			 }
			 cursor = limit;
			 limit = itsConstantPool.getUtfEncodingLimit(k, limit, length);
		 }
		 addInvoke(ByteCode.INVOKEVIRTUAL, SB, ""toString"", ""()Ljava/lang/String;
		"");
	 }
	 public boolean isUnderStringSizeLimit(String k) {
		 return itsConstantPool.isUnderUtfEncodingLimit(k);
	 }
	 public void addIStore(int local) {
		 xop(ByteCode.ISTORE_0, ByteCode.ISTORE, local);
	 }
	 public void addLStore(int local) {
		 xop(ByteCode.LSTORE_0, ByteCode.LSTORE, local);
	 }
	 public void addFStore(int local) {
		 xop(ByteCode.FSTORE_0, ByteCode.FSTORE, local);
	 }
	 public void addDStore(int local) {
		 xop(ByteCode.DSTORE_0, ByteCode.DSTORE, local);
	 }
	 public void addAStore(int local) {
		 xop(ByteCode.ASTORE_0, ByteCode.ASTORE, local);
	 }
	 public void addILoad(int local) {
		 xop(ByteCode.ILOAD_0, ByteCode.ILOAD, local);
	 }
	 public void addLLoad(int local) {
		 xop(ByteCode.LLOAD_0, ByteCode.LLOAD, local);
	 }
	 public void addFLoad(int local) {
		 xop(ByteCode.FLOAD_0, ByteCode.FLOAD, local);
	 }
	 public void addDLoad(int local) {
		 xop(ByteCode.DLOAD_0, ByteCode.DLOAD, local);
	 }
	 public void addALoad(int local) {
		 xop(ByteCode.ALOAD_0, ByteCode.ALOAD, local);
	 }
	 public void addLoadThis() {
		 add(ByteCode.ALOAD_0);
	 }
	 private void xop(int shortOp, int op, int local) {
		 switch (local) {
			 case 0: add(shortOp);
			 break;
			 case 1: add(shortOp + 1);
			 break;
			 case 2: add(shortOp + 2);
			 break;
			 case 3: add(shortOp + 3);
			 break;
			 default: add(op, local);
		 }
	 }
	 public int addTableSwitch(int low, int high) {
		 if (DEBUGCODE) {
			 System.out.println(""Add ""+bytecodeStr(ByteCode.TABLESWITCH) +"" ""+low+"" ""+high);
		 }
		 if (low > high) throw new IllegalArgumentException(""Bad bounds: ""+low+' '+ high);
		 int newStack = itsStackTop + stackChange(ByteCode.TABLESWITCH);
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 int entryCount = high - low + 1;
		 int padSize = 3 & ~itsCodeBufferTop;
		 int N = addReservedCodeSpace(1 + padSize + 4 * (1 + 2 + entryCount));
		 int switchStart = N;
		 itsCodeBuffer[N++] = (byte)ByteCode.TABLESWITCH;
		 while (padSize != 0) {
			 itsCodeBuffer[N++] = 0;
			 --padSize;
		 }
		 N += 4;
		 N = putInt32(low, itsCodeBuffer, N);
		 putInt32(high, itsCodeBuffer, N);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+bytecodeStr(ByteCode.TABLESWITCH) +"" stack = ""+itsStackTop);
		 }
		 return switchStart;
	 }
	 public final void markTableSwitchDefault(int switchStart) {
		 setTableSwitchJump(switchStart, -1, itsCodeBufferTop);
	 }
	 public final void markTableSwitchCase(int switchStart, int caseIndex) {
		 setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
	 }
	 public final void markTableSwitchCase(int switchStart, int caseIndex, int stackTop) {
		 if (!(0 <= stackTop && stackTop <= itsMaxStack)) throw new IllegalArgumentException(""Bad stack index: ""+stackTop);
		 itsStackTop = (short)stackTop;
		 setTableSwitchJump(switchStart, caseIndex, itsCodeBufferTop);
	 }
	 public void setTableSwitchJump(int switchStart, int caseIndex, int jumpTarget) {
		 if (!(0 <= jumpTarget && jumpTarget <= itsCodeBufferTop)) throw new IllegalArgumentException(""Bad jump target: ""+jumpTarget);
		 if (!(caseIndex >= -1)) throw new IllegalArgumentException(""Bad case index: ""+caseIndex);
		 int padSize = 3 & ~switchStart;
		 int caseOffset;
		 if (caseIndex < 0) {
			 caseOffset = switchStart + 1 + padSize;
		 }
		 else {
			 caseOffset = switchStart + 1 + padSize + 4 * (3 + caseIndex);
		 }
		 if (!(0 <= switchStart && switchStart <= itsCodeBufferTop - 4 * 4 - padSize - 1)) {
			 throw new IllegalArgumentException( switchStart+"" is outside a possible range of tableswitch"" +"" in already generated code"");
		 }
		 if ((0xFF & itsCodeBuffer[switchStart]) != ByteCode.TABLESWITCH) {
			 throw new IllegalArgumentException( switchStart+"" is not offset of tableswitch statement"");
		 }
		 if (!(0 <= caseOffset && caseOffset + 4 <= itsCodeBufferTop)) {
			 throw new IllegalArgumentException( ""Too big case index: ""+caseIndex);
		 }
		 putInt32(jumpTarget - switchStart, itsCodeBuffer, caseOffset);
	 }
	 public int acquireLabel() {
		 int top = itsLabelTableTop;
		 if (itsLabelTable == null || top == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, top);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = top + 1;
		 itsLabelTable[top] = -1;
		 return top | 0x80000000;
	 }
	 public void markLabel(int label) {
		 if (!(label < 0)) throw new IllegalArgumentException(""Bad label, no biscuit"");
		 label &= 0x7FFFFFFF;
		 if (label > itsLabelTableTop) throw new IllegalArgumentException(""Bad label"");
		 if (itsLabelTable[label] != -1) {
			 throw new IllegalStateException(""Can only mark label once"");
		 }
		 itsLabelTable[label] = itsCodeBufferTop;
	 }
	 public void markLabel(int label, short stackTop) {
		 markLabel(label);
		 itsStackTop = stackTop;
	 }
	 public void markHandler(int theLabel) {
		 itsStackTop = 1;
		 markLabel(theLabel);
	 }
	 private int getLabelPC(int label) {
		 if (!(label < 0)) throw new IllegalArgumentException(""Bad label, no biscuit"");
		 label &= 0x7FFFFFFF;
		 if (!(label < itsLabelTableTop)) throw new IllegalArgumentException(""Bad label"");
		 return itsLabelTable[label];
	 }
	 private void addLabelFixup(int label, int fixupSite) {
		 if (!(label < 0)) throw new IllegalArgumentException(""Bad label, no biscuit"");
		 label &= 0x7FFFFFFF;
		 if (!(label < itsLabelTableTop)) throw new IllegalArgumentException(""Bad label"");
		 int top = itsFixupTableTop;
		 if (itsFixupTable == null || top == itsFixupTable.length) {
			 if (itsFixupTable == null) {
				 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
			 }
			else {
				 long[] tmp = new long[itsFixupTable.length * 2];
				 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
				 itsFixupTable = tmp;
			 }
		 }
		 itsFixupTableTop = top + 1;
		 itsFixupTable[top] = ((long)label << 32) | fixupSite;
	 }
	 private void fixLabelGotos() {
		 byte[] codeBuffer = itsCodeBuffer;
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int fixupSite = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw new RuntimeException();
			 }
			 int offset = pc - (fixupSite - 1);
			 if ((short)offset != offset) {
				 throw new RuntimeException (""Program too complex: too big jump offset"");
			 }
			 codeBuffer[fixupSite] = (byte)(offset >> 8);
			 codeBuffer[fixupSite + 1] = (byte)offset;
		 }
		 itsFixupTableTop = 0;
	 }
	 public int getCurrentCodeOffset() {
		 return itsCodeBufferTop;
	 }
	 public short getStackTop() {
		 return itsStackTop;
	 }
	 public void adjustStackTop(int delta) {
		 int newStack = itsStackTop + delta;
		 if (newStack < 0 || Short.MAX_VALUE < newStack) badStack(newStack);
		 itsStackTop = (short)newStack;
		 if (newStack > itsMaxStack) itsMaxStack = (short)newStack;
		 if (DEBUGSTACK) {
			 System.out.println(""After ""+""adjustStackTop(""+delta+"")"" +"" stack = ""+itsStackTop);
		 }
	 }
	 private void addToCodeBuffer(int b) {
		 int N = addReservedCodeSpace(1);
		 itsCodeBuffer[N] = (byte)b;
	 }
	 private void addToCodeInt16(int value) {
		 int N = addReservedCodeSpace(2);
		 putInt16(value, itsCodeBuffer, N);
	 }
	 private int addReservedCodeSpace(int size) {
		 if (itsCurrentMethod == null) throw new IllegalArgumentException(""No method to add to"");
		 int oldTop = itsCodeBufferTop;
		 int newTop = oldTop + size;
		 if (newTop > itsCodeBuffer.length) {
			 int newSize = itsCodeBuffer.length * 2;
			 if (newTop > newSize) {
				 newSize = newTop;
			 }
			 byte[] tmp = new byte[newSize];
			 System.arraycopy(itsCodeBuffer, 0, tmp, 0, oldTop);
			 itsCodeBuffer = tmp;
		 }
		 itsCodeBufferTop = newTop;
		 return oldTop;
	 }
	 public void addExceptionHandler(int startLabel, int endLabel, int handlerLabel, String catchClassName) {
		 if ((startLabel & 0x80000000) != 0x80000000) throw new IllegalArgumentException(""Bad startLabel"");
		 if ((endLabel & 0x80000000) != 0x80000000) throw new IllegalArgumentException(""Bad endLabel"");
		 if ((handlerLabel & 0x80000000) != 0x80000000) throw new IllegalArgumentException(""Bad handlerLabel"");
		 short catch_type_index = (catchClassName == null) ? 0 : itsConstantPool.addClass(catchClassName);
		 ExceptionTableEntry newEntry = new ExceptionTableEntry( startLabel, endLabel, handlerLabel, catch_type_index);
		 int N = itsExceptionTableTop;
		 if (N == 0) {
			 itsExceptionTable = new ExceptionTableEntry[ExceptionTableSize];
		 }
		 else if (N == itsExceptionTable.length) {
			 ExceptionTableEntry[] tmp = new ExceptionTableEntry[N * 2];
			 System.arraycopy(itsExceptionTable, 0, tmp, 0, N);
			 itsExceptionTable = tmp;
		 }
		 itsExceptionTable[N] = newEntry;
		 itsExceptionTableTop = N + 1;
	 }
	 public void addLineNumberEntry(short lineNumber) {
		 if (itsCurrentMethod == null) throw new IllegalArgumentException(""No method to stop"");
		 int N = itsLineNumberTableTop;
		 if (N == 0) {
			 itsLineNumberTable = new int[LineNumberTableSize];
		 }
		 else if (N == itsLineNumberTable.length) {
			 int[] tmp = new int[N * 2];
			 System.arraycopy(itsLineNumberTable, 0, tmp, 0, N);
			 itsLineNumberTable = tmp;
		 }
		 itsLineNumberTable[N] = (itsCodeBufferTop << 16) + lineNumber;
		 itsLineNumberTableTop = N + 1;
	 }
	 public void write(OutputStream oStream) throws IOException {
		 byte[] array = toByteArray();
		 oStream.write(array);
	 }
	 private int getWriteSize() {
		 int size = 0;
		 if (itsSourceFileNameIndex != 0) {
			 itsConstantPool.addUtf8(""SourceFile"");
		 }
		 size += 8;
		 size += itsConstantPool.getWriteSize();
		 size += 2;
		 size += 2;
		 size += 2;
		 size += 2;
		 size += 2 * itsInterfaces.size();
		 size += 2;
		 for (int i = 0;
		 i < itsFields.size();
		 i++) {
			 size += ((ClassFileField)(itsFields.get(i))).getWriteSize();
		 }
		 size += 2;
		 for (int i = 0;
		 i < itsMethods.size();
		 i++) {
			 size += ((ClassFileMethod)(itsMethods.get(i))).getWriteSize();
		 }
		 if (itsSourceFileNameIndex != 0) {
			 size += 2;
			 size += 2;
			 size += 4;
			 size += 2;
		 }
		else {
			 size += 2;
		 }
		 return size;
	 }
	 public byte[] toByteArray() {
		 int dataSize = getWriteSize();
		 byte[] data = new byte[dataSize];
		 int offset = 0;
		 short sourceFileAttributeNameIndex = 0;
		 if (itsSourceFileNameIndex != 0) {
			 sourceFileAttributeNameIndex = itsConstantPool.addUtf8( ""SourceFile"");
		 }
		 offset = putInt64(FileHeaderConstant, data, offset);
		 offset = itsConstantPool.write(data, offset);
		 offset = putInt16(itsFlags, data, offset);
		 offset = putInt16(itsThisClassIndex, data, offset);
		 offset = putInt16(itsSuperClassIndex, data, offset);
		 offset = putInt16(itsInterfaces.size(), data, offset);
		 for (int i = 0;
		 i < itsInterfaces.size();
		 i++) {
			 int interfaceIndex = ((Short)(itsInterfaces.get(i))).shortValue();
			 offset = putInt16(interfaceIndex, data, offset);
		 }
		 offset = putInt16(itsFields.size(), data, offset);
		 for (int i = 0;
		 i < itsFields.size();
		 i++) {
			 ClassFileField field = (ClassFileField)itsFields.get(i);
			 offset = field.write(data, offset);
		 }
		 offset = putInt16(itsMethods.size(), data, offset);
		 for (int i = 0;
		 i < itsMethods.size();
		 i++) {
			 ClassFileMethod method = (ClassFileMethod)itsMethods.get(i);
			 offset = method.write(data, offset);
		 }
		 if (itsSourceFileNameIndex != 0) {
			 offset = putInt16(1, data, offset);
			 offset = putInt16(sourceFileAttributeNameIndex, data, offset);
			 offset = putInt32(2, data, offset);
			 offset = putInt16(itsSourceFileNameIndex, data, offset);
		 }
		 else {
			 offset = putInt16(0, data, offset);
		 }
		 if (offset != dataSize) {
			 throw new RuntimeException();
		 }
		 return data;
	 }
	 static int putInt64(long value, byte[] array, int offset) {
		 offset = putInt32((int)(value >>> 32), array, offset);
		 return putInt32((int)value, array, offset);
	 }
	 private static void badStack(int value) {
		 String s;
		 if (value < 0) {
			 s = ""Stack underflow: ""+value;
		 }
		 else {
			 s = ""Too big stack: ""+value;
		 }
		 throw new IllegalStateException(s);
	 }
	 private static int sizeOfParameters(String pString) {
		 int length = pString.length();
		 int rightParenthesis = pString.lastIndexOf(')');
		 if (3 <= length && pString.charAt(0) == '(' && 1 <= rightParenthesis && rightParenthesis + 1 < length) {
			 boolean ok = true;
			 int index = 1;
			 int stackDiff = 0;
			 int count = 0;
			 stringLoop: while (index != rightParenthesis) {
				 switch (pString.charAt(index)) {
					 default: ok = false;
					 break stringLoop;
					 case 'J' : case 'D' : --stackDiff;
					 case 'B' : case 'S' : case 'C' : case 'I' : case 'Z' : case 'F' : --stackDiff;
					 ++count;
					 ++index;
					 continue;
					 case '[' : ++index;
					 int c = pString.charAt(index);
					 while (c == '[') {
						 ++index;
						 c = pString.charAt(index);
					 }
					 switch (c) {
						 default: ok = false;
						 break stringLoop;
						 case 'J' : case 'D' : case 'B' : case 'S' : case 'C' : case 'I' : case 'Z' : case 'F' : --stackDiff;
						 ++count;
						 ++index;
						 continue;
					 case 'L': }
					 case 'L' : {
						 --stackDiff;
						 ++count;
						 ++index;
						 int semicolon = pString.indexOf(';
						', index);
						 if (!(index + 1 <= semicolon && semicolon < rightParenthesis)) {
							 ok = false;
							 break stringLoop;
						 }
						 index = semicolon + 1;
						 continue;
					 }
				 }
			 }
			 if (ok) {
				 switch (pString.charAt(rightParenthesis + 1)) {
					 default: ok = false;
					 break;
					 case 'J' : case 'D' : ++stackDiff;
					 case 'B' : case 'S' : case 'C' : case 'I' : case 'Z' : case 'F' : case 'L' : case '[' : ++stackDiff;
					 case 'V' : break;
				 }
				 if (ok) {
					 return ((count << 16) | (0xFFFF & stackDiff));
				 }
			 }
		 }
		 throw new IllegalArgumentException( ""Bad parameter signature: ""+pString);
	 }
	 static int putInt16(int value, byte[] array, int offset) {
		 array[offset + 0] = (byte)(value >>> 8);
		 array[offset + 1] = (byte)value;
		 return offset + 2;
	 }
	 static int putInt32(int value, byte[] array, int offset) {
		 array[offset + 0] = (byte)(value >>> 24);
		 array[offset + 1] = (byte)(value >>> 16);
		 array[offset + 2] = (byte)(value >>> 8);
		 array[offset + 3] = (byte)value;
		 return offset + 4;
	 }
	 static int opcodeCount(int opcode) {
		 switch (opcode) {
			 case ByteCode.AALOAD: case ByteCode.AASTORE: case ByteCode.ACONST_NULL: case ByteCode.ALOAD_0: case ByteCode.ALOAD_1: case ByteCode.ALOAD_2: case ByteCode.ALOAD_3: case ByteCode.ARETURN: case ByteCode.ARRAYLENGTH: case ByteCode.ASTORE_0: case ByteCode.ASTORE_1: case ByteCode.ASTORE_2: case ByteCode.ASTORE_3: case ByteCode.ATHROW: case ByteCode.BALOAD: case ByteCode.BASTORE: case ByteCode.BREAKPOINT: case ByteCode.CALOAD: case ByteCode.CASTORE: case ByteCode.D2F: case ByteCode.D2I: case ByteCode.D2L: case ByteCode.DADD: case ByteCode.DALOAD: case ByteCode.DASTORE: case ByteCode.DCMPG: case ByteCode.DCMPL: case ByteCode.DCONST_0: case ByteCode.DCONST_1: case ByteCode.DDIV: case ByteCode.DLOAD_0: case ByteCode.DLOAD_1: case ByteCode.DLOAD_2: case ByteCode.DLOAD_3: case ByteCode.DMUL: case ByteCode.DNEG: case ByteCode.DREM: case ByteCode.DRETURN: case ByteCode.DSTORE_0: case ByteCode.DSTORE_1: case ByteCode.DSTORE_2: case ByteCode.DSTORE_3: case ByteCode.DSUB: case ByteCode.DUP: case ByteCode.DUP2: case ByteCode.DUP2_X1: case ByteCode.DUP2_X2: case ByteCode.DUP_X1: case ByteCode.DUP_X2: case ByteCode.F2D: case ByteCode.F2I: case ByteCode.F2L: case ByteCode.FADD: case ByteCode.FALOAD: case ByteCode.FASTORE: case ByteCode.FCMPG: case ByteCode.FCMPL: case ByteCode.FCONST_0: case ByteCode.FCONST_1: case ByteCode.FCONST_2: case ByteCode.FDIV: case ByteCode.FLOAD_0: case ByteCode.FLOAD_1: case ByteCode.FLOAD_2: case ByteCode.FLOAD_3: case ByteCode.FMUL: case ByteCode.FNEG: case ByteCode.FREM: case ByteCode.FRETURN: case ByteCode.FSTORE_0: case ByteCode.FSTORE_1: case ByteCode.FSTORE_2: case ByteCode.FSTORE_3: case ByteCode.FSUB: case ByteCode.I2B: case ByteCode.I2C: case ByteCode.I2D: case ByteCode.I2F: case ByteCode.I2L: case ByteCode.I2S: case ByteCode.IADD: case ByteCode.IALOAD: case ByteCode.IAND: case ByteCode.IASTORE: case ByteCode.ICONST_0: case ByteCode.ICONST_1: case ByteCode.ICONST_2: case ByteCode.ICONST_3: case ByteCode.ICONST_4: case ByteCode.ICONST_5: case ByteCode.ICONST_M1: case ByteCode.IDIV: case ByteCode.ILOAD_0: case ByteCode.ILOAD_1: case ByteCode.ILOAD_2: case ByteCode.ILOAD_3: case ByteCode.IMPDEP1: case ByteCode.IMPDEP2: case ByteCode.IMUL: case ByteCode.INEG: case ByteCode.IOR: case ByteCode.IREM: case ByteCode.IRETURN: case ByteCode.ISHL: case ByteCode.ISHR: case ByteCode.ISTORE_0: case ByteCode.ISTORE_1: case ByteCode.ISTORE_2: case ByteCode.ISTORE_3: case ByteCode.ISUB: case ByteCode.IUSHR: case ByteCode.IXOR: case ByteCode.L2D: case ByteCode.L2F: case ByteCode.L2I: case ByteCode.LADD: case ByteCode.LALOAD: case ByteCode.LAND: case ByteCode.LASTORE: case ByteCode.LCMP: case ByteCode.LCONST_0: case ByteCode.LCONST_1: case ByteCode.LDIV: case ByteCode.LLOAD_0: case ByteCode.LLOAD_1: case ByteCode.LLOAD_2: case ByteCode.LLOAD_3: case ByteCode.LMUL: case ByteCode.LNEG: case ByteCode.LOR: case ByteCode.LREM: case ByteCode.LRETURN: case ByteCode.LSHL: case ByteCode.LSHR: case ByteCode.LSTORE_0: case ByteCode.LSTORE_1: case ByteCode.LSTORE_2: case ByteCode.LSTORE_3: case ByteCode.LSUB: case ByteCode.LUSHR: case ByteCode.LXOR: case ByteCode.MONITORENTER: case ByteCode.MONITOREXIT: case ByteCode.NOP: case ByteCode.POP: case ByteCode.POP2: case ByteCode.RETURN: case ByteCode.SALOAD: case ByteCode.SASTORE: case ByteCode.SWAP: case ByteCode.WIDE: return 0;
			 case ByteCode.ALOAD: case ByteCode.ANEWARRAY: case ByteCode.ASTORE: case ByteCode.BIPUSH: case ByteCode.CHECKCAST: case ByteCode.DLOAD: case ByteCode.DSTORE: case ByteCode.FLOAD: case ByteCode.FSTORE: case ByteCode.GETFIELD: case ByteCode.GETSTATIC: case ByteCode.GOTO: case ByteCode.GOTO_W: case ByteCode.IFEQ: case ByteCode.IFGE: case ByteCode.IFGT: case ByteCode.IFLE: case ByteCode.IFLT: case ByteCode.IFNE: case ByteCode.IFNONNULL: case ByteCode.IFNULL: case ByteCode.IF_ACMPEQ: case ByteCode.IF_ACMPNE: case ByteCode.IF_ICMPEQ: case ByteCode.IF_ICMPGE: case ByteCode.IF_ICMPGT: case ByteCode.IF_ICMPLE: case ByteCode.IF_ICMPLT: case ByteCode.IF_ICMPNE: case ByteCode.ILOAD: case ByteCode.INSTANCEOF: case ByteCode.INVOKEINTERFACE: case ByteCode.INVOKESPECIAL: case ByteCode.INVOKESTATIC: case ByteCode.INVOKEVIRTUAL: case ByteCode.ISTORE: case ByteCode.JSR: case ByteCode.JSR_W: case ByteCode.LDC: case ByteCode.LDC2_W: case ByteCode.LDC_W: case ByteCode.LLOAD: case ByteCode.LSTORE: case ByteCode.NEW: case ByteCode.NEWARRAY: case ByteCode.PUTFIELD: case ByteCode.PUTSTATIC: case ByteCode.RET: case ByteCode.SIPUSH: return 1;
			 case ByteCode.IINC: case ByteCode.MULTIANEWARRAY: return 2;
			 case ByteCode.LOOKUPSWITCH: case ByteCode.TABLESWITCH: return -1;
		 }
		 throw new IllegalArgumentException(""Bad opcode: ""+opcode);
	 }
	 static int stackChange(int opcode) {
		 switch (opcode) {
			 case ByteCode.DASTORE: case ByteCode.LASTORE: return -4;
			 case ByteCode.AASTORE: case ByteCode.BASTORE: case ByteCode.CASTORE: case ByteCode.DCMPG: case ByteCode.DCMPL: case ByteCode.FASTORE: case ByteCode.IASTORE: case ByteCode.LCMP: case ByteCode.SASTORE: return -3;
			 case ByteCode.DADD: case ByteCode.DDIV: case ByteCode.DMUL: case ByteCode.DREM: case ByteCode.DRETURN: case ByteCode.DSTORE: case ByteCode.DSTORE_0: case ByteCode.DSTORE_1: case ByteCode.DSTORE_2: case ByteCode.DSTORE_3: case ByteCode.DSUB: case ByteCode.IF_ACMPEQ: case ByteCode.IF_ACMPNE: case ByteCode.IF_ICMPEQ: case ByteCode.IF_ICMPGE: case ByteCode.IF_ICMPGT: case ByteCode.IF_ICMPLE: case ByteCode.IF_ICMPLT: case ByteCode.IF_ICMPNE: case ByteCode.LADD: case ByteCode.LAND: case ByteCode.LDIV: case ByteCode.LMUL: case ByteCode.LOR: case ByteCode.LREM: case ByteCode.LRETURN: case ByteCode.LSTORE: case ByteCode.LSTORE_0: case ByteCode.LSTORE_1: case ByteCode.LSTORE_2: case ByteCode.LSTORE_3: case ByteCode.LSUB: case ByteCode.LXOR: case ByteCode.POP2: return -2;
			 case ByteCode.AALOAD: case ByteCode.ARETURN: case ByteCode.ASTORE: case ByteCode.ASTORE_0: case ByteCode.ASTORE_1: case ByteCode.ASTORE_2: case ByteCode.ASTORE_3: case ByteCode.ATHROW: case ByteCode.BALOAD: case ByteCode.CALOAD: case ByteCode.D2F: case ByteCode.D2I: case ByteCode.FADD: case ByteCode.FALOAD: case ByteCode.FCMPG: case ByteCode.FCMPL: case ByteCode.FDIV: case ByteCode.FMUL: case ByteCode.FREM: case ByteCode.FRETURN: case ByteCode.FSTORE: case ByteCode.FSTORE_0: case ByteCode.FSTORE_1: case ByteCode.FSTORE_2: case ByteCode.FSTORE_3: case ByteCode.FSUB: case ByteCode.GETFIELD: case ByteCode.IADD: case ByteCode.IALOAD: case ByteCode.IAND: case ByteCode.IDIV: case ByteCode.IFEQ: case ByteCode.IFGE: case ByteCode.IFGT: case ByteCode.IFLE: case ByteCode.IFLT: case ByteCode.IFNE: case ByteCode.IFNONNULL: case ByteCode.IFNULL: case ByteCode.IMUL: case ByteCode.INVOKEINTERFACE: case ByteCode.INVOKESPECIAL: case ByteCode.INVOKEVIRTUAL: case ByteCode.IOR: case ByteCode.IREM: case ByteCode.IRETURN: case ByteCode.ISHL: case ByteCode.ISHR: case ByteCode.ISTORE: case ByteCode.ISTORE_0: case ByteCode.ISTORE_1: case ByteCode.ISTORE_2: case ByteCode.ISTORE_3: case ByteCode.ISUB: case ByteCode.IUSHR: case ByteCode.IXOR: case ByteCode.L2F: case ByteCode.L2I: case ByteCode.LOOKUPSWITCH: case ByteCode.LSHL: case ByteCode.LSHR: case ByteCode.LUSHR: case ByteCode.MONITORENTER: case ByteCode.MONITOREXIT: case ByteCode.POP: case ByteCode.PUTFIELD: case ByteCode.SALOAD: case ByteCode.TABLESWITCH: return -1;
			 case ByteCode.ANEWARRAY: case ByteCode.ARRAYLENGTH: case ByteCode.BREAKPOINT: case ByteCode.CHECKCAST: case ByteCode.D2L: case ByteCode.DALOAD: case ByteCode.DNEG: case ByteCode.F2I: case ByteCode.FNEG: case ByteCode.GETSTATIC: case ByteCode.GOTO: case ByteCode.GOTO_W: case ByteCode.I2B: case ByteCode.I2C: case ByteCode.I2F: case ByteCode.I2S: case ByteCode.IINC: case ByteCode.IMPDEP1: case ByteCode.IMPDEP2: case ByteCode.INEG: case ByteCode.INSTANCEOF: case ByteCode.INVOKESTATIC: case ByteCode.L2D: case ByteCode.LALOAD: case ByteCode.LNEG: case ByteCode.NEWARRAY: case ByteCode.NOP: case ByteCode.PUTSTATIC: case ByteCode.RET: case ByteCode.RETURN: case ByteCode.SWAP: case ByteCode.WIDE: return 0;
			 case ByteCode.ACONST_NULL: case ByteCode.ALOAD: case ByteCode.ALOAD_0: case ByteCode.ALOAD_1: case ByteCode.ALOAD_2: case ByteCode.ALOAD_3: case ByteCode.BIPUSH: case ByteCode.DUP: case ByteCode.DUP_X1: case ByteCode.DUP_X2: case ByteCode.F2D: case ByteCode.F2L: case ByteCode.FCONST_0: case ByteCode.FCONST_1: case ByteCode.FCONST_2: case ByteCode.FLOAD: case ByteCode.FLOAD_0: case ByteCode.FLOAD_1: case ByteCode.FLOAD_2: case ByteCode.FLOAD_3: case ByteCode.I2D: case ByteCode.I2L: case ByteCode.ICONST_0: case ByteCode.ICONST_1: case ByteCode.ICONST_2: case ByteCode.ICONST_3: case ByteCode.ICONST_4: case ByteCode.ICONST_5: case ByteCode.ICONST_M1: case ByteCode.ILOAD: case ByteCode.ILOAD_0: case ByteCode.ILOAD_1: case ByteCode.ILOAD_2: case ByteCode.ILOAD_3: case ByteCode.JSR: case ByteCode.JSR_W: case ByteCode.LDC: case ByteCode.LDC_W: case ByteCode.MULTIANEWARRAY: case ByteCode.NEW: case ByteCode.SIPUSH: return 1;
			 case ByteCode.DCONST_0: case ByteCode.DCONST_1: case ByteCode.DLOAD: case ByteCode.DLOAD_0: case ByteCode.DLOAD_1: case ByteCode.DLOAD_2: case ByteCode.DLOAD_3: case ByteCode.DUP2: case ByteCode.DUP2_X1: case ByteCode.DUP2_X2: case ByteCode.LCONST_0: case ByteCode.LCONST_1: case ByteCode.LDC2_W: case ByteCode.LLOAD: case ByteCode.LLOAD_0: case ByteCode.LLOAD_1: case ByteCode.LLOAD_2: case ByteCode.LLOAD_3: return 2;
		 }
		 throw new IllegalArgumentException(""Bad opcode: ""+opcode);
	 }
	 private static String bytecodeStr(int code) {
		 if (DEBUGSTACK || DEBUGCODE) {
			 switch (code) {
				 case ByteCode.NOP: return ""nop"";
				 case ByteCode.ACONST_NULL: return ""aconst_null"";
				 case ByteCode.ICONST_M1: return ""iconst_m1"";
				 case ByteCode.ICONST_0: return ""iconst_0"";
				 case ByteCode.ICONST_1: return ""iconst_1"";
				 case ByteCode.ICONST_2: return ""iconst_2"";
				 case ByteCode.ICONST_3: return ""iconst_3"";
				 case ByteCode.ICONST_4: return ""iconst_4"";
				 case ByteCode.ICONST_5: return ""iconst_5"";
				 case ByteCode.LCONST_0: return ""lconst_0"";
				 case ByteCode.LCONST_1: return ""lconst_1"";
				 case ByteCode.FCONST_0: return ""fconst_0"";
				 case ByteCode.FCONST_1: return ""fconst_1"";
				 case ByteCode.FCONST_2: return ""fconst_2"";
				 case ByteCode.DCONST_0: return ""dconst_0"";
				 case ByteCode.DCONST_1: return ""dconst_1"";
				 case ByteCode.BIPUSH: return ""bipush"";
				 case ByteCode.SIPUSH: return ""sipush"";
				 case ByteCode.LDC: return ""ldc"";
				 case ByteCode.LDC_W: return ""ldc_w"";
				 case ByteCode.LDC2_W: return ""ldc2_w"";
				 case ByteCode.ILOAD: return ""iload"";
				 case ByteCode.LLOAD: return ""lload"";
				 case ByteCode.FLOAD: return ""fload"";
				 case ByteCode.DLOAD: return ""dload"";
				 case ByteCode.ALOAD: return ""aload"";
				 case ByteCode.ILOAD_0: return ""iload_0"";
				 case ByteCode.ILOAD_1: return ""iload_1"";
				 case ByteCode.ILOAD_2: return ""iload_2"";
				 case ByteCode.ILOAD_3: return ""iload_3"";
				 case ByteCode.LLOAD_0: return ""lload_0"";
				 case ByteCode.LLOAD_1: return ""lload_1"";
				 case ByteCode.LLOAD_2: return ""lload_2"";
				 case ByteCode.LLOAD_3: return ""lload_3"";
				 case ByteCode.FLOAD_0: return ""fload_0"";
				 case ByteCode.FLOAD_1: return ""fload_1"";
				 case ByteCode.FLOAD_2: return ""fload_2"";
				 case ByteCode.FLOAD_3: return ""fload_3"";
				 case ByteCode.DLOAD_0: return ""dload_0"";
				 case ByteCode.DLOAD_1: return ""dload_1"";
				 case ByteCode.DLOAD_2: return ""dload_2"";
				 case ByteCode.DLOAD_3: return ""dload_3"";
				 case ByteCode.ALOAD_0: return ""aload_0"";
				 case ByteCode.ALOAD_1: return ""aload_1"";
				 case ByteCode.ALOAD_2: return ""aload_2"";
				 case ByteCode.ALOAD_3: return ""aload_3"";
				 case ByteCode.IALOAD: return ""iaload"";
				 case ByteCode.LALOAD: return ""laload"";
				 case ByteCode.FALOAD: return ""faload"";
				 case ByteCode.DALOAD: return ""daload"";
				 case ByteCode.AALOAD: return ""aaload"";
				 case ByteCode.BALOAD: return ""baload"";
				 case ByteCode.CALOAD: return ""caload"";
				 case ByteCode.SALOAD: return ""saload"";
				 case ByteCode.ISTORE: return ""istore"";
				 case ByteCode.LSTORE: return ""lstore"";
				 case ByteCode.FSTORE: return ""fstore"";
				 case ByteCode.DSTORE: return ""dstore"";
				 case ByteCode.ASTORE: return ""astore"";
				 case ByteCode.ISTORE_0: return ""istore_0"";
				 case ByteCode.ISTORE_1: return ""istore_1"";
				 case ByteCode.ISTORE_2: return ""istore_2"";
				 case ByteCode.ISTORE_3: return ""istore_3"";
				 case ByteCode.LSTORE_0: return ""lstore_0"";
				 case ByteCode.LSTORE_1: return ""lstore_1"";
				 case ByteCode.LSTORE_2: return ""lstore_2"";
				 case ByteCode.LSTORE_3: return ""lstore_3"";
				 case ByteCode.FSTORE_0: return ""fstore_0"";
				 case ByteCode.FSTORE_1: return ""fstore_1"";
				 case ByteCode.FSTORE_2: return ""fstore_2"";
				 case ByteCode.FSTORE_3: return ""fstore_3"";
				 case ByteCode.DSTORE_0: return ""dstore_0"";
				 case ByteCode.DSTORE_1: return ""dstore_1"";
				 case ByteCode.DSTORE_2: return ""dstore_2"";
				 case ByteCode.DSTORE_3: return ""dstore_3"";
				 case ByteCode.ASTORE_0: return ""astore_0"";
				 case ByteCode.ASTORE_1: return ""astore_1"";
				 case ByteCode.ASTORE_2: return ""astore_2"";
				 case ByteCode.ASTORE_3: return ""astore_3"";
				 case ByteCode.IASTORE: return ""iastore"";
				 case ByteCode.LASTORE: return ""lastore"";
				 case ByteCode.FASTORE: return ""fastore"";
				 case ByteCode.DASTORE: return ""dastore"";
				 case ByteCode.AASTORE: return ""aastore"";
				 case ByteCode.BASTORE: return ""bastore"";
				 case ByteCode.CASTORE: return ""castore"";
				 case ByteCode.SASTORE: return ""sastore"";
				 case ByteCode.POP: return ""pop"";
				 case ByteCode.POP2: return ""pop2"";
				 case ByteCode.DUP: return ""dup"";
				 case ByteCode.DUP_X1: return ""dup_x1"";
				 case ByteCode.DUP_X2: return ""dup_x2"";
				 case ByteCode.DUP2: return ""dup2"";
				 case ByteCode.DUP2_X1: return ""dup2_x1"";
				 case ByteCode.DUP2_X2: return ""dup2_x2"";
				 case ByteCode.SWAP: return ""swap"";
				 case ByteCode.IADD: return ""iadd"";
				 case ByteCode.LADD: return ""ladd"";
				 case ByteCode.FADD: return ""fadd"";
				 case ByteCode.DADD: return ""dadd"";
				 case ByteCode.ISUB: return ""isub"";
				 case ByteCode.LSUB: return ""lsub"";
				 case ByteCode.FSUB: return ""fsub"";
				 case ByteCode.DSUB: return ""dsub"";
				 case ByteCode.IMUL: return ""imul"";
				 case ByteCode.LMUL: return ""lmul"";
				 case ByteCode.FMUL: return ""fmul"";
				 case ByteCode.DMUL: return ""dmul"";
				 case ByteCode.IDIV: return ""idiv"";
				 case ByteCode.LDIV: return ""ldiv"";
				 case ByteCode.FDIV: return ""fdiv"";
				 case ByteCode.DDIV: return ""ddiv"";
				 case ByteCode.IREM: return ""irem"";
				 case ByteCode.LREM: return ""lrem"";
				 case ByteCode.FREM: return ""frem"";
				 case ByteCode.DREM: return ""drem"";
				 case ByteCode.INEG: return ""ineg"";
				 case ByteCode.LNEG: return ""lneg"";
				 case ByteCode.FNEG: return ""fneg"";
				 case ByteCode.DNEG: return ""dneg"";
				 case ByteCode.ISHL: return ""ishl"";
				 case ByteCode.LSHL: return ""lshl"";
				 case ByteCode.ISHR: return ""ishr"";
				 case ByteCode.LSHR: return ""lshr"";
				 case ByteCode.IUSHR: return ""iushr"";
				 case ByteCode.LUSHR: return ""lushr"";
				 case ByteCode.IAND: return ""iand"";
				 case ByteCode.LAND: return ""land"";
				 case ByteCode.IOR: return ""ior"";
				 case ByteCode.LOR: return ""lor"";
				 case ByteCode.IXOR: return ""ixor"";
				 case ByteCode.LXOR: return ""lxor"";
				 case ByteCode.IINC: return ""iinc"";
				 case ByteCode.I2L: return ""i2l"";
				 case ByteCode.I2F: return ""i2f"";
				 case ByteCode.I2D: return ""i2d"";
				 case ByteCode.L2I: return ""l2i"";
				 case ByteCode.L2F: return ""l2f"";
				 case ByteCode.L2D: return ""l2d"";
				 case ByteCode.F2I: return ""f2i"";
				 case ByteCode.F2L: return ""f2l"";
				 case ByteCode.F2D: return ""f2d"";
				 case ByteCode.D2I: return ""d2i"";
				 case ByteCode.D2L: return ""d2l"";
				 case ByteCode.D2F: return ""d2f"";
				 case ByteCode.I2B: return ""i2b"";
				 case ByteCode.I2C: return ""i2c"";
				 case ByteCode.I2S: return ""i2s"";
				 case ByteCode.LCMP: return ""lcmp"";
				 case ByteCode.FCMPL: return ""fcmpl"";
				 case ByteCode.FCMPG: return ""fcmpg"";
				 case ByteCode.DCMPL: return ""dcmpl"";
				 case ByteCode.DCMPG: return ""dcmpg"";
				 case ByteCode.IFEQ: return ""ifeq"";
				 case ByteCode.IFNE: return ""ifne"";
				 case ByteCode.IFLT: return ""iflt"";
				 case ByteCode.IFGE: return ""ifge"";
				 case ByteCode.IFGT: return ""ifgt"";
				 case ByteCode.IFLE: return ""ifle"";
				 case ByteCode.IF_ICMPEQ: return ""if_icmpeq"";
				 case ByteCode.IF_ICMPNE: return ""if_icmpne"";
				 case ByteCode.IF_ICMPLT: return ""if_icmplt"";
				 case ByteCode.IF_ICMPGE: return ""if_icmpge"";
				 case ByteCode.IF_ICMPGT: return ""if_icmpgt"";
				 case ByteCode.IF_ICMPLE: return ""if_icmple"";
				 case ByteCode.IF_ACMPEQ: return ""if_acmpeq"";
				 case ByteCode.IF_ACMPNE: return ""if_acmpne"";
				 case ByteCode.GOTO: return ""goto"";
				 case ByteCode.JSR: return ""jsr"";
				 case ByteCode.RET: return ""ret"";
				 case ByteCode.TABLESWITCH: return ""tableswitch"";
				 case ByteCode.LOOKUPSWITCH: return ""lookupswitch"";
				 case ByteCode.IRETURN: return ""ireturn"";
				 case ByteCode.LRETURN: return ""lreturn"";
				 case ByteCode.FRETURN: return ""freturn"";
				 case ByteCode.DRETURN: return ""dreturn"";
				 case ByteCode.ARETURN: return ""areturn"";
				 case ByteCode.RETURN: return ""return"";
				 case ByteCode.GETSTATIC: return ""getstatic"";
				 case ByteCode.PUTSTATIC: return ""putstatic"";
				 case ByteCode.GETFIELD: return ""getfield"";
				 case ByteCode.PUTFIELD: return ""putfield"";
				 case ByteCode.INVOKEVIRTUAL: return ""invokevirtual"";
				 case ByteCode.INVOKESPECIAL: return ""invokespecial"";
				 case ByteCode.INVOKESTATIC: return ""invokestatic"";
				 case ByteCode.INVOKEINTERFACE: return ""invokeinterface"";
				 case ByteCode.NEW: return ""new"";
				 case ByteCode.NEWARRAY: return ""newarray"";
				 case ByteCode.ANEWARRAY: return ""anewarray"";
				 case ByteCode.ARRAYLENGTH: return ""arraylength"";
				 case ByteCode.ATHROW: return ""athrow"";
				 case ByteCode.CHECKCAST: return ""checkcast"";
				 case ByteCode.INSTANCEOF: return ""instanceof"";
				 case ByteCode.MONITORENTER: return ""monitorenter"";
				 case ByteCode.MONITOREXIT: return ""monitorexit"";
				 case ByteCode.WIDE: return ""wide"";
				 case ByteCode.MULTIANEWARRAY: return ""multianewarray"";
				 case ByteCode.IFNULL: return ""ifnull"";
				 case ByteCode.IFNONNULL: return ""ifnonnull"";
				 case ByteCode.GOTO_W: return ""goto_w"";
				 case ByteCode.JSR_W: return ""jsr_w"";
				 case ByteCode.BREAKPOINT: return ""breakpoint"";
				 case ByteCode.IMPDEP1: return ""impdep1"";
				 case ByteCode.IMPDEP2: return ""impdep2"";
			 }
		 }
		 return """";
	 }
	 final char[] getCharBuffer(int minimalSize) {
		 if (minimalSize > tmpCharBuffer.length) {
			 int newSize = tmpCharBuffer.length * 2;
			 if (minimalSize > newSize) {
				 newSize = minimalSize;
			 }
			 tmpCharBuffer = new char[newSize];
		 }
		 return tmpCharBuffer;
	 }
	 private static final int LineNumberTableSize = 16;
	 private static final int ExceptionTableSize = 4;
	 private final static long FileHeaderConstant = 0xCAFEBABE0003002DL;
	 private static final boolean DEBUGSTACK = false;
	 private static final boolean DEBUGLABELS = false;
	 private static final boolean DEBUGCODE = false;
	 private String generatedClassName;
	 private ExceptionTableEntry itsExceptionTable[];
	 private int itsExceptionTableTop;
	 private int itsLineNumberTable[];
	 private int itsLineNumberTableTop;
	 private byte[] itsCodeBuffer = new byte[256];
	 private int itsCodeBufferTop;
	 private ConstantPool itsConstantPool;
	 private ClassFileMethod itsCurrentMethod;
	 private short itsStackTop;
	 private short itsMaxStack;
	 private short itsMaxLocals;
	 private ObjArray itsMethods = new ObjArray();
	 private ObjArray itsFields = new ObjArray();
	 private ObjArray itsInterfaces = new ObjArray();
	 private short itsFlags;
	 private short itsThisClassIndex;
	 private short itsSuperClassIndex;
	 private short itsSourceFileNameIndex;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsVarDescriptors;
	 private char[] tmpCharBuffer = new char[64];
}
final class ExceptionTableEntry{
	 ExceptionTableEntry(int startLabel, int endLabel, int handlerLabel, short catchType) {
		 itsStartLabel = startLabel;
		 itsEndLabel = endLabel;
		 itsHandlerLabel = handlerLabel;
		 itsCatchType = catchType;
	 }
	 int itsStartLabel;
	 int itsEndLabel;
	 int itsHandlerLabel;
	 short itsCatchType;
}
final class ClassFileField{
	 ClassFileField(short nameIndex, short typeIndex, short flags) {
		 itsNameIndex = nameIndex;
		 itsTypeIndex = typeIndex;
		 itsFlags = flags;
		 itsHasAttributes = false;
	 }
	 void setAttributes(short attr1, short attr2, short attr3, int index) {
		 itsHasAttributes = true;
		 itsAttr1 = attr1;
		 itsAttr2 = attr2;
		 itsAttr3 = attr3;
		 itsIndex = index;
	 }
	 int write(byte[] data, int offset) {
		 offset = ClassFileWriter.putInt16(itsFlags, data, offset);
		 offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);
		 offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);
		 if (!itsHasAttributes) {
			 offset = ClassFileWriter.putInt16(0, data, offset);
		 }
		 else {
			 offset = ClassFileWriter.putInt16(1, data, offset);
			 offset = ClassFileWriter.putInt16(itsAttr1, data, offset);
			 offset = ClassFileWriter.putInt16(itsAttr2, data, offset);
			 offset = ClassFileWriter.putInt16(itsAttr3, data, offset);
			 offset = ClassFileWriter.putInt16(itsIndex, data, offset);
		 }
		 return offset;
	 }
	 int getWriteSize() {
		 int size = 2 * 3;
		 if (!itsHasAttributes) {
			 size += 2;
		 }
		 else {
			 size += 2 + 2 * 4;
		 }
		 return size;
	 }
	 private short itsNameIndex;
	 private short itsTypeIndex;
	 private short itsFlags;
	 private boolean itsHasAttributes;
	 private short itsAttr1, itsAttr2, itsAttr3;
	 private int itsIndex;
}
final class ClassFileMethod{
	 ClassFileMethod(short nameIndex, short typeIndex, short flags) {
		 itsNameIndex = nameIndex;
		 itsTypeIndex = typeIndex;
		 itsFlags = flags;
	 }
	 void setCodeAttribute(byte codeAttribute[]) {
		 itsCodeAttribute = codeAttribute;
	 }
	 int write(byte[] data, int offset) {
		 offset = ClassFileWriter.putInt16(itsFlags, data, offset);
		 offset = ClassFileWriter.putInt16(itsNameIndex, data, offset);
		 offset = ClassFileWriter.putInt16(itsTypeIndex, data, offset);
		 offset = ClassFileWriter.putInt16(1, data, offset);
		 System.arraycopy(itsCodeAttribute, 0, data, offset, itsCodeAttribute.length);
		 offset += itsCodeAttribute.length;
		 return offset;
	 }
	 int getWriteSize() {
		 return 2 * 4 + itsCodeAttribute.length;
	 }
	 private short itsNameIndex;
	 private short itsTypeIndex;
	 private short itsFlags;
	 private byte[] itsCodeAttribute;
}
final class ConstantPool{
	 ConstantPool(ClassFileWriter cfw) {
		 this.cfw = cfw;
		 itsTopIndex = 1;
		 itsPool = new byte[ConstantPoolSize];
		 itsTop = 0;
	 }
	 private static final int ConstantPoolSize = 256;
	 private static final byte CONSTANT_Class = 7, CONSTANT_Fieldref = 9, CONSTANT_Methodref = 10, CONSTANT_InterfaceMethodref = 11, CONSTANT_String = 8, CONSTANT_Integer = 3, CONSTANT_Float = 4, CONSTANT_Long = 5, CONSTANT_Double = 6, CONSTANT_NameAndType = 12, CONSTANT_Utf8 = 1;
	 int write(byte[] data, int offset) {
		 offset = ClassFileWriter.putInt16((short)itsTopIndex, data, offset);
		 System.arraycopy(itsPool, 0, data, offset, itsTop);
		 offset += itsTop;
		 return offset;
	 }
	 int getWriteSize() {
		 return 2 + itsTop;
	 }
	 int addConstant(int k) {
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_Integer;
		 itsTop = ClassFileWriter.putInt32(k, itsPool, itsTop);
		 return (short)(itsTopIndex++);
	 }
	 int addConstant(long k) {
		 ensure(9);
		 itsPool[itsTop++] = CONSTANT_Long;
		 itsTop = ClassFileWriter.putInt64(k, itsPool, itsTop);
		 int index = itsTopIndex;
		 itsTopIndex += 2;
		 return index;
	 }
	 int addConstant(float k) {
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_Float;
		 int bits = Float.floatToIntBits(k);
		 itsTop = ClassFileWriter.putInt32(bits, itsPool, itsTop);
		 return itsTopIndex++;
	 }
	 int addConstant(double k) {
		 ensure(9);
		 itsPool[itsTop++] = CONSTANT_Double;
		 long bits = Double.doubleToLongBits(k);
		 itsTop = ClassFileWriter.putInt64(bits, itsPool, itsTop);
		 int index = itsTopIndex;
		 itsTopIndex += 2;
		 return index;
	 }
	 int addConstant(String k) {
		 int utf8Index = 0xFFFF & addUtf8(k);
		 int theIndex = itsStringConstHash.getInt(utf8Index, -1);
		 if (theIndex == -1) {
			 theIndex = itsTopIndex++;
			 ensure(3);
			 itsPool[itsTop++] = CONSTANT_String;
			 itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);
			 itsStringConstHash.put(utf8Index, theIndex);
		 }
		 return theIndex;
	 }
	 boolean isUnderUtfEncodingLimit(String s) {
		 int strLen = s.length();
		 if (strLen * 3 <= MAX_UTF_ENCODING_SIZE) {
			 return true;
		 }
		 else if (strLen > MAX_UTF_ENCODING_SIZE) {
			 return false;
		 }
		 return strLen == getUtfEncodingLimit(s, 0, strLen);
	 }
	 int getUtfEncodingLimit(String s, int start, int end) {
		 if ((end - start) * 3 <= MAX_UTF_ENCODING_SIZE) {
			 return end;
		 }
		 int limit = MAX_UTF_ENCODING_SIZE;
		 for (int i = start;
		 i != end;
		 i++) {
			 int c = s.charAt(i);
			 if (0 != c && c <= 0x7F) {
				 --limit;
			 }
			 else if (c < 0x7FF) {
				 limit -= 2;
			 }
			 else {
				 limit -= 3;
			 }
			 if (limit < 0) {
				 return i;
			 }
		 }
		 return end;
	 }
	 short addUtf8(String k) {
		 int theIndex = itsUtf8Hash.get(k, -1);
		 if (theIndex == -1) {
			 int strLen = k.length();
			 boolean tooBigString;
			 if (strLen > MAX_UTF_ENCODING_SIZE) {
				 tooBigString = true;
			 }
			 else {
				 tooBigString = false;
				 ensure(1 + 2 + strLen * 3);
				 int top = itsTop;
				 itsPool[top++] = CONSTANT_Utf8;
				 top += 2;
				 char[] chars = cfw.getCharBuffer(strLen);
				 k.getChars(0, strLen, chars, 0);
				 for (int i = 0;
				 i != strLen;
				 i++) {
					 int c = chars[i];
					 if (c != 0 && c <= 0x7F) {
						 itsPool[top++] = (byte)c;
					 }
					 else if (c > 0x7FF) {
						 itsPool[top++] = (byte)(0xE0 | (c >> 12));
						 itsPool[top++] = (byte)(0x80 | ((c >> 6) & 0x3F));
						 itsPool[top++] = (byte)(0x80 | (c & 0x3F));
					 }
					 else {
						 itsPool[top++] = (byte)(0xC0 | (c >> 6));
						 itsPool[top++] = (byte)(0x80 | (c & 0x3F));
					 }
				 }
				 int utfLen = top - (itsTop + 1 + 2);
				 if (utfLen > MAX_UTF_ENCODING_SIZE) {
					 tooBigString = true;
				 }
				 else {
					 itsPool[itsTop + 1] = (byte)(utfLen >>> 8);
					 itsPool[itsTop + 2] = (byte)utfLen;
					 itsTop = top;
					 theIndex = itsTopIndex++;
					 itsUtf8Hash.put(k, theIndex);
				 }
			 }
			 if (tooBigString) {
				 throw new IllegalArgumentException(""Too big string"");
			 }
		 }
		 return (short)theIndex;
	 }
	 private short addNameAndType(String name, String type) {
		 short nameIndex = addUtf8(name);
		 short typeIndex = addUtf8(type);
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_NameAndType;
		 itsTop = ClassFileWriter.putInt16(nameIndex, itsPool, itsTop);
		 itsTop = ClassFileWriter.putInt16(typeIndex, itsPool, itsTop);
		 return (short)(itsTopIndex++);
	 }
	 short addClass(String className) {
		 int theIndex = itsClassHash.get(className, -1);
		 if (theIndex == -1) {
			 String slashed = className;
			 if (className.indexOf('.') > 0) {
				 slashed = ClassFileWriter.getSlashedForm(className);
				 theIndex = itsClassHash.get(slashed, -1);
				 if (theIndex != -1) {
					 itsClassHash.put(className, theIndex);
				 }
			 }
			 if (theIndex == -1) {
				 int utf8Index = addUtf8(slashed);
				 ensure(3);
				 itsPool[itsTop++] = CONSTANT_Class;
				 itsTop = ClassFileWriter.putInt16(utf8Index, itsPool, itsTop);
				 theIndex = itsTopIndex++;
				 itsClassHash.put(slashed, theIndex);
				 if (className != slashed) {
					 itsClassHash.put(className, theIndex);
				 }
			 }
		 }
		 return (short)theIndex;
	 }
	 short addFieldRef(String className, String fieldName, String fieldType) {
		 FieldOrMethodRef ref = new FieldOrMethodRef(className, fieldName, fieldType);
		 int theIndex = itsFieldRefHash.get(ref, -1);
		 if (theIndex == -1) {
			 short ntIndex = addNameAndType(fieldName, fieldType);
			 short classIndex = addClass(className);
			 ensure(5);
			 itsPool[itsTop++] = CONSTANT_Fieldref;
			 itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);
			 itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);
			 theIndex = itsTopIndex++;
			 itsFieldRefHash.put(ref, theIndex);
		 }
		 return (short)theIndex;
	 }
	 short addMethodRef(String className, String methodName, String methodType) {
		 FieldOrMethodRef ref = new FieldOrMethodRef(className, methodName, methodType);
		 int theIndex = itsMethodRefHash.get(ref, -1);
		 if (theIndex == -1) {
			 short ntIndex = addNameAndType(methodName, methodType);
			 short classIndex = addClass(className);
			 ensure(5);
			 itsPool[itsTop++] = CONSTANT_Methodref;
			 itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);
			 itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);
			 theIndex = itsTopIndex++;
			 itsMethodRefHash.put(ref, theIndex);
		 }
		 return (short)theIndex;
	 }
	 short addInterfaceMethodRef(String className, String methodName, String methodType) {
		 short ntIndex = addNameAndType(methodName, methodType);
		 short classIndex = addClass(className);
		 ensure(5);
		 itsPool[itsTop++] = CONSTANT_InterfaceMethodref;
		 itsTop = ClassFileWriter.putInt16(classIndex, itsPool, itsTop);
		 itsTop = ClassFileWriter.putInt16(ntIndex, itsPool, itsTop);
		 return (short)(itsTopIndex++);
	 }
	 void ensure(int howMuch) {
		 if (itsTop + howMuch > itsPool.length) {
			 int newCapacity = itsPool.length * 2;
			 if (itsTop + howMuch > newCapacity) {
				 newCapacity = itsTop + howMuch;
			 }
			 byte[] tmp = new byte[newCapacity];
			 System.arraycopy(itsPool, 0, tmp, 0, itsTop);
			 itsPool = tmp;
		 }
	 }
	 private ClassFileWriter cfw;
	 private static final int MAX_UTF_ENCODING_SIZE = 65535;
	 private UintMap itsStringConstHash = new UintMap();
	 private ObjToIntMap itsUtf8Hash = new ObjToIntMap();
	 private ObjToIntMap itsFieldRefHash = new ObjToIntMap();
	 private ObjToIntMap itsMethodRefHash = new ObjToIntMap();
	 private ObjToIntMap itsClassHash = new ObjToIntMap();
	 private int itsTop;
	 private int itsTopIndex;
	 private byte itsPool[];
}
final class FieldOrMethodRef{
	 FieldOrMethodRef(String className, String name, String type) {
		 this.className = className;
		 this.name = name;
		 this.type = type;
	 }
	 public boolean equals(Object obj) {
		 if (!(obj instanceof FieldOrMethodRef)) {
			 return false;
		 }
		 FieldOrMethodRef x = (FieldOrMethodRef)obj;
		 return className.equals(x.className) && name.equals(x.name) && type.equals(x.type);
	 }
	 public int hashCode() {
		 if (hashCode == -1) {
			 int h1 = className.hashCode();
			 int h2 = name.hashCode();
			 int h3 = type.hashCode();
			 hashCode = h1 ^ h2 ^ h3;
		 }
		 return hashCode;
	 }
	 private String className;
	 private String name;
	 private String type;
	 private int hashCode = -1;
}",1,0,0,0
"private static class Success<V> extends Try<V> {
	 private V value;
	 public Success(V value) {
		 super();
		 this.value = value;
	 }
	 public Boolean isSuccess() {
		 return true;
	 }
	 public Boolean isFailure() {
		 return false;
	 }
	 public void throwException() {
	 }
	 public V get() {
		 return value;
	 }
	 public Throwable getError() {
		 return null;
	 }
 }",0,1,0,0
"public Component getNextComponent(final Container container, final Component component, final FocusTraversalDirection direction) {
	 Utils.checkNull(container, ""container"");
	 Utils.checkNull(direction, ""direction"");
	 Component nextComponent = null;
	 int n = container.getLength();
	 if (n > 0) {
		 switch (direction) {
			 case FORWARD: if (component == null) {
				 nextComponent = container.get(0);
			 }
			 else {
				 int index = container.indexOf(component);
				 if (index == -1) {
					 throw new IllegalArgumentException(""Component is not a child of the container."");
				 }
				 if (index < n - 1) {
					 nextComponent = container.get(index + 1);
				 }
				 else {
					 if (wrap) {
						 nextComponent = container.get(0);
					 }
				 }
			 }
			 break;
			 case BACKWARD: if (component == null) {
				 nextComponent = container.get(n - 1);
			 }
			 else {
				 int index = container.indexOf(component);
				 if (index == -1) {
					 throw new IllegalArgumentException(""Component is not a child of the container."");
				 }
				 if (index > 0) {
					 nextComponent = container.get(index - 1);
				 }
				 else {
					 if (wrap) {
						 nextComponent = container.get(n - 1);
					 }
				 }
			 }
			 break;
			 default: break;
		 }
	 }
	 return nextComponent;
 }",0,0,1,0
"public String diagnoseCreationFailure(String componentName, String type) {
	 StringWriter errorText = new StringWriter();
	 PrintWriter out = new PrintWriter(errorText);
	 out.println(""Problem: failed to create "" + type + "" "" + componentName);
	 boolean lowlevel = false;
	 boolean jars = false;
	 boolean definitions = false;
	 boolean antTask;
	 String home = System.getProperty(Launcher.USER_HOMEDIR);
	 File libDir = new File(home, Launcher.USER_LIBDIR);
	 String antHomeLib;
	 boolean probablyIDE = false;
	 String anthome = System.getProperty(MagicNames.ANT_HOME);
	 if (anthome != null) {
		 File antHomeLibDir = new File(anthome, ""lib"");
		 antHomeLib = antHomeLibDir.getAbsolutePath();
	 }
	 else {
		 probablyIDE = true;
		 antHomeLib = ""ANT_HOME"" + File.separatorChar + ""lib"";
	 }
	 StringBuffer dirListingText = new StringBuffer();
	 final String tab = "" -"";
	 dirListingText.append(tab);
	 dirListingText.append(antHomeLib);
	 dirListingText.append('\n');
	 if (probablyIDE) {
		 dirListingText.append(tab);
		 dirListingText.append(""the IDE Ant configuration dialogs"");
	 }
	 else {
		 dirListingText.append(tab);
		 dirListingText.append(libDir);
		 dirListingText.append('\n');
		 dirListingText.append(tab);
		 dirListingText.append(""a directory added on the command line with the -lib argument"");
	 }
	 String dirListing = dirListingText.toString();
	 AntTypeDefinition def = getDefinition(componentName);
	 if (def == null) {
		 printUnknownDefinition(out, componentName, dirListing);
		 definitions = true;
	 }
	 else {
		 final String classname = def.getClassName();
		 antTask = classname.startsWith(""org.apache.tools.ant."");
		 boolean optional = classname.startsWith(""org.apache.tools.ant.taskdefs.optional"");
		 optional |= classname.startsWith(""org.apache.tools.ant.types.optional"");
		 Class clazz = null;
		 try {
			 clazz = def.innerGetTypeClass();
		 }
		 catch (ClassNotFoundException e) {
			 jars = true;
			 if (!optional) {
				 definitions = true;
			 }
			 printClassNotFound(out, classname, optional, dirListing);
		 }
		 catch (NoClassDefFoundError ncdfe) {
			 jars = true;
			 printNotLoadDependentClass(out, optional, ncdfe, dirListing);
		 }
		 if (clazz != null) {
			 try {
				 def.innerCreateAndSet(clazz, project);
				 out.println(""The component could be instantiated."");
			 }
			 catch (NoSuchMethodException e) {
				 lowlevel = true;
				 out.println(""Cause: The class "" + classname + "" has no compatible constructor."");
			 }
			 catch (InstantiationException e) {
				 lowlevel = true;
				 out.println(""Cause: The class "" + classname + "" is abstract and cannot be instantiated."");
			 }
			 catch (IllegalAccessException e) {
				 lowlevel = true;
				 out.println(""Cause: The constructor for "" + classname + "" is private and cannot be invoked."");
			 }
			 catch (InvocationTargetException ex) {
				 lowlevel = true;
				 Throwable t = ex.getTargetException();
				 out.println(""Cause: The constructor threw the exception"");
				 out.println(t.toString());
				 t.printStackTrace(out);
			 }
			 catch (NoClassDefFoundError ncdfe) {
				 jars = true;
				 out.println(""Cause: A class needed by class "" + classname + "" cannot be found: "");
				 out.println("" "" + ncdfe.getMessage());
				 out.println(""Action: Determine what extra JAR files are"" + "" needed, and place them in:"");
				 out.println(dirListing);
			 }
		 }
		 out.println();
		 out.println(""Do not panic, this is a common problem."");
		 if (definitions) {
			 out.println(""It may just be a typographical error in the build file "" + ""or the task/type declaration."");
		 }
		 if (jars) {
			 out.println(""The commonest cause is a missing JAR."");
		 }
		 if (lowlevel) {
			 out.println(""This is quite a low level problem, which may need "" + ""consultation with the author of the task."");
			 if (antTask) {
				 out.println(""This may be the Ant team. Please file a "" + ""defect or contact the developer team."");
			 }
			 else {
				 out.println(""This does not appear to be a task bundled with Ant."");
				 out.println(""Please take it up with the supplier of the third-party "" + type + ""."");
				 out.println(""If you have written it yourself, you probably have a bug to fix."");
			 }
		 }
		 else {
			 out.println();
			 out.println(""This is not a bug;
			 it is a configuration problem"");
		 }
	 }
	 out.flush();
	 out.close();
	 return errorText.toString();
 }",0,0,1,0
"public class DOMSerializerImpl implements LSSerializer, DOMConfiguration {
	 private XMLSerializer serializer;
	 private XML11Serializer xml11Serializer;
	 private DOMStringList fRecognizedParameters;
	 protected short features = 0;
	 protected final static short NAMESPACES = 0x1<<0;
	 protected final static short WELLFORMED = 0x1<<1;
	 protected final static short ENTITIES = 0x1<<2;
	 protected final static short CDATA = 0x1<<3;
	 protected final static short SPLITCDATA = 0x1<<4;
	 protected final static short COMMENTS = 0x1<<5;
	 protected final static short DISCARDDEFAULT = 0x1<<6;
	 protected final static short INFOSET = 0x1<<7;
	 protected final static short XMLDECL = 0x1<<8;
	 protected final static short NSDECL = 0x1<<9;
	 protected final static short DOM_ELEMENT_CONTENT_WHITESPACE = 0x1<<10;
	 protected final static short PRETTY_PRINT = 0x1<<11;
	 private DOMErrorHandler fErrorHandler = null;
	 private final DOMErrorImpl fError = new DOMErrorImpl();
	 private final DOMLocatorImpl fLocator = new DOMLocatorImpl();
	 public DOMSerializerImpl() {
		 features |= NAMESPACES;
		 features |= ENTITIES;
		 features |= COMMENTS;
		 features |= CDATA;
		 features |= SPLITCDATA;
		 features |= WELLFORMED;
		 features |= NSDECL;
		 features |= DOM_ELEMENT_CONTENT_WHITESPACE;
		 features |= DISCARDDEFAULT;
		 features |= XMLDECL;
		 serializer = new XMLSerializer();
		 initSerializer(serializer);
	 }
	 public DOMConfiguration getDomConfig(){
		 return this;
	 }
	 public void setParameter(String name, Object value) throws DOMException {
		 if (value instanceof Boolean) {
			 boolean state = ((Boolean) value).booleanValue();
			 if (name.equalsIgnoreCase(Constants.DOM_INFOSET)){
				 if (state){
					 features &= ~ENTITIES;
					 features &= ~CDATA;
					 features |= NAMESPACES;
					 features |= NSDECL;
					 features |= WELLFORMED;
					 features |= COMMENTS;
				 }
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_XMLDECL)) {
				 features = (short) (state ? features | XMLDECL : features & ~XMLDECL);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)) {
				 features = (short) (state ? features | NAMESPACES : features & ~NAMESPACES);
				 serializer.fNamespaces = state;
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)) {
				 features = (short) (state ? features | SPLITCDATA : features & ~SPLITCDATA);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_DISCARD_DEFAULT_CONTENT)) {
				 features = (short) (state ? features | DISCARDDEFAULT : features & ~DISCARDDEFAULT);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_WELLFORMED)) {
				 features = (short) (state ? features | WELLFORMED : features & ~WELLFORMED);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_ENTITIES)){
				 features = (short) (state ? features | ENTITIES : features & ~ENTITIES);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)){
				 features = (short) (state ? features | CDATA : features & ~CDATA);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)){
				 features = (short) (state ? features | COMMENTS : features & ~COMMENTS);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_FORMAT_PRETTY_PRINT)) {
				 features = (short) (state ? features | PRETTY_PRINT : features & ~PRETTY_PRINT);
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM) || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(Constants.DOM_VALIDATE) || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION) || name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION) || name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)) {
				 if (state) {
					 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_SUPPORTED"", new Object[] {
					 name }
					);
					 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
				 }
			 }
			else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {
				features =(short) (state? features | NSDECL: features & ~NSDECL);
				serializer.fNamespacePrefixes = state;
			 }
			 else if (name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE) || name.equalsIgnoreCase(Constants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {
				 if (!state) {
					 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_SUPPORTED"", new Object[] {
					 name }
					);
					 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
				 }
			 }
			 else {
				 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_FOUND"", new Object[] {
				 name }
				);
				 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
			 }
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
			 if (value == null || value instanceof DOMErrorHandler) {
				 fErrorHandler = (DOMErrorHandler)value;
			 }
			 else {
				 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""TYPE_MISMATCH_ERR"", new Object[] {
				 name }
				);
				 throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
			 }
		 }
		 else if ( name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER) || name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION) || name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE) && value != null) {
			 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_SUPPORTED"", new Object[] {
			 name }
			);
			 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
		 }
		 else {
			 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_FOUND"", new Object[] {
			 name }
			);
			 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
		 }
	 }
	public boolean canSetParameter(String name, Object state) {
		if (state == null){
			return true;
		}
		if (state instanceof Boolean){
			boolean value = ((Boolean)state).booleanValue();
			if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)|| name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)|| name.equalsIgnoreCase(Constants.DOM_DISCARD_DEFAULT_CONTENT)|| name.equalsIgnoreCase(Constants.DOM_XMLDECL) || name.equalsIgnoreCase(Constants.DOM_WELLFORMED) || name.equalsIgnoreCase(Constants.DOM_INFOSET) || name.equalsIgnoreCase(Constants.DOM_ENTITIES) || name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS) || name.equalsIgnoreCase(Constants.DOM_COMMENTS) || name.equalsIgnoreCase(Constants.DOM_FORMAT_PRETTY_PRINT) || name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)){
				return true;
			}
			else if (name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM) || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(Constants.DOM_VALIDATE) || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION) || name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION) || name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)) {
				return !value;
			}
			else if (name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE) || name.equalsIgnoreCase(Constants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {
				return value;
			 }
		}
		else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER) &&state == null || state instanceof DOMErrorHandler){
			return true;
		}
		 return false;
	 }
	 public DOMStringList getParameterNames() {
		 if (fRecognizedParameters == null){
			ArrayList parameters = new ArrayList();
			parameters.add(Constants.DOM_NAMESPACES);
			parameters.add(Constants.DOM_SPLIT_CDATA);
			parameters.add(Constants.DOM_DISCARD_DEFAULT_CONTENT);
			parameters.add(Constants.DOM_XMLDECL);
			parameters.add(Constants.DOM_CANONICAL_FORM);
			parameters.add(Constants.DOM_VALIDATE_IF_SCHEMA);
			parameters.add(Constants.DOM_VALIDATE);
			parameters.add(Constants.DOM_CHECK_CHAR_NORMALIZATION);
			parameters.add(Constants.DOM_DATATYPE_NORMALIZATION);
			parameters.add(Constants.DOM_FORMAT_PRETTY_PRINT);
			parameters.add(Constants.DOM_NORMALIZE_CHARACTERS);
			parameters.add(Constants.DOM_WELLFORMED);
			parameters.add(Constants.DOM_INFOSET);
			parameters.add(Constants.DOM_NAMESPACE_DECLARATIONS);
			parameters.add(Constants.DOM_ELEMENT_CONTENT_WHITESPACE);
			parameters.add(Constants.DOM_ENTITIES);
			parameters.add(Constants.DOM_CDATA_SECTIONS);
			parameters.add(Constants.DOM_COMMENTS);
			parameters.add(Constants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS);
			parameters.add(Constants.DOM_ERROR_HANDLER);
			fRecognizedParameters = new DOMStringListImpl(parameters);
		 }
		 return fRecognizedParameters;
	 }
	 public Object getParameter(String name) throws DOMException {
		 if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)) {
			 return ((features & COMMENTS) != 0) ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)) {
			 return (features & NAMESPACES) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_XMLDECL)) {
			 return (features & XMLDECL) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)) {
			 return (features & CDATA) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_ENTITIES)) {
			 return (features & ENTITIES) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)) {
			 return (features & SPLITCDATA) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_WELLFORMED)) {
			 return (features & WELLFORMED) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {
			 return (features & NSDECL) != 0 ? Boolean.TRUE : Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE) || name.equalsIgnoreCase(Constants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {
			 return Boolean.TRUE;
		 }
		else if (name.equalsIgnoreCase(Constants.DOM_DISCARD_DEFAULT_CONTENT)){
			 return ((features & DISCARDDEFAULT)!=0)?Boolean.TRUE:Boolean.FALSE;
		 }
		else if (name.equalsIgnoreCase(Constants.DOM_FORMAT_PRETTY_PRINT)){
			 return ((features & PRETTY_PRINT)!=0)?Boolean.TRUE:Boolean.FALSE;
		 }
		else if (name.equalsIgnoreCase(Constants.DOM_INFOSET)){
			 if ((features & ENTITIES) == 0 && (features & CDATA) == 0 && (features & NAMESPACES) != 0 && (features & NSDECL) != 0 && (features & WELLFORMED) != 0 && (features & COMMENTS) != 0) {
				 return Boolean.TRUE;
			 }
			 return Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS) || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM) || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION) || name.equalsIgnoreCase(Constants.DOM_VALIDATE) || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA) || name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)) {
			 return Boolean.FALSE;
		 }
		 else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
			 return fErrorHandler;
		 }
		 else if ( name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER) || name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION) || name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
			 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_SUPPORTED"", new Object[] {
			 name }
			);
			 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
		 }
		 else {
			 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""FEATURE_NOT_FOUND"", new Object[] {
			 name }
			);
			 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
		 }
	 }
	 public String writeToString(Node wnode) throws DOMException, LSException {
		 XMLSerializer ser = null;
		 String ver = _getXmlVersion(wnode);
		 if (ver != null && ver.equals(""1.1"")) {
			 if(xml11Serializer == null) {
				 xml11Serializer = new XML11Serializer();
				 initSerializer(xml11Serializer);
			 }
			 copySettings(serializer, xml11Serializer);
			 ser = xml11Serializer;
		 }
		 else {
			 ser = serializer;
		 }
		 StringWriter destination = new StringWriter();
		 try {
			 prepareForSerialization(ser, wnode);
			 ser._format.setEncoding(""UTF-16"");
			 ser.setOutputCharStream(destination);
			 if (wnode.getNodeType() == Node.DOCUMENT_NODE) {
				 ser.serialize((Document)wnode);
			 }
			 else if (wnode.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE) {
				 ser.serialize((DocumentFragment)wnode);
			 }
			 else if (wnode.getNodeType() == Node.ELEMENT_NODE) {
				 ser.serialize((Element)wnode);
			 }
			 else {
				 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.SERIALIZER_DOMAIN, ""unable-to-serialize-node"", null);
				 if (ser.fDOMErrorHandler != null) {
					 DOMErrorImpl error = new DOMErrorImpl();
					 error.fType = ""unable-to-serialize-node"";
					 error.fMessage = msg;
					 error.fSeverity = DOMError.SEVERITY_FATAL_ERROR;
					 ser.fDOMErrorHandler.handleError(error);
				 }
				 throw new LSException(LSException.SERIALIZE_ERR, msg);
			 }
		 }
		 catch (LSException lse) {
			 throw lse;
		 }
		 catch (RuntimeException e) {
			 if (e == DOMNormalizer.abort){
				 return null;
			 }
			 throw (LSException) DOMUtil.createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();
		 }
		 catch (IOException ioe) {
			 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""STRING_TOO_LONG"", new Object[] {
			 ioe.getMessage()}
			);
			 throw new DOMException(DOMException.DOMSTRING_SIZE_ERR,msg);
		 }
		 finally {
			 ser.clearDocumentState();
		 }
		 return destination.toString();
	 }
	 public void setNewLine(String newLine) {
		 serializer._format.setLineSeparator(newLine);
	 }
	 public String getNewLine() {
		 return serializer._format.getLineSeparator();
	 }
	 public LSSerializerFilter getFilter(){
		 return serializer.fDOMFilter;
	 }
	 public void setFilter(LSSerializerFilter filter){
		 serializer.fDOMFilter = filter;
	 }
	 private void initSerializer(XMLSerializer ser) {
		 ser.fNSBinder = new NamespaceSupport();
		 ser.fLocalNSBinder = new NamespaceSupport();
		 ser.fSymbolTable = new SymbolTable();
	 }
	 private void copySettings(XMLSerializer src, XMLSerializer dest) {
		 dest.fDOMErrorHandler = fErrorHandler;
		 dest._format.setEncoding(src._format.getEncoding());
		 dest._format.setLineSeparator(src._format.getLineSeparator());
		 dest.fDOMFilter = src.fDOMFilter;
	 }
	 public boolean write(Node node, LSOutput destination) throws LSException{
		 if (node == null) return false;
		 XMLSerializer ser = null;
		 String ver = _getXmlVersion(node);
		 if (ver != null && ver.equals(""1.1"")) {
			 if (xml11Serializer == null) {
				 xml11Serializer = new XML11Serializer();
				 initSerializer(xml11Serializer);
			 }
			 copySettings(serializer, xml11Serializer);
			 ser = xml11Serializer;
		 }
		 else {
			 ser = serializer;
		 }
		 String encoding = null;
		 if ((encoding = destination.getEncoding()) == null) {
			 encoding = _getInputEncoding(node);
			 if (encoding == null) {
				 encoding = _getXmlEncoding(node);
				 if (encoding == null) {
					 encoding = ""UTF-8"";
				 }
			 }
		 }
		 try {
			 prepareForSerialization(ser, node);
			 ser._format.setEncoding(encoding);
			 OutputStream outputStream = destination.getByteStream();
			 Writer writer = destination.getCharacterStream();
			 String uri = destination.getSystemId();
			 if (writer == null) {
				 if (outputStream == null) {
					 if (uri == null) {
						 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.SERIALIZER_DOMAIN, ""no-output-specified"", null);
						 if (ser.fDOMErrorHandler != null) {
							 DOMErrorImpl error = new DOMErrorImpl();
							 error.fType = ""no-output-specified"";
							 error.fMessage = msg;
							 error.fSeverity = DOMError.SEVERITY_FATAL_ERROR;
							 ser.fDOMErrorHandler.handleError(error);
						 }
						 throw new LSException(LSException.SERIALIZE_ERR, msg);
					 }
					 else {
						 ser.setOutputByteStream(XMLEntityManager.createOutputStream(uri));
					 }
				 }
				 else {
					 ser.setOutputByteStream(outputStream);
				 }
			 }
			 else {
				 ser.setOutputCharStream(writer);
			 }
			 if (node.getNodeType() == Node.DOCUMENT_NODE) ser.serialize((Document) node);
			 else if (node.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE) ser.serialize((DocumentFragment) node);
			 else if (node.getNodeType() == Node.ELEMENT_NODE) ser.serialize((Element) node);
			 else return false;
		 }
		 catch( UnsupportedEncodingException ue) {
			 if (ser.fDOMErrorHandler != null) {
				 DOMErrorImpl error = new DOMErrorImpl();
				 error.fException = ue;
				error.fType = ""unsupported-encoding"";
				 error.fMessage = ue.getMessage();
				error.fSeverity = DOMError.SEVERITY_FATAL_ERROR;
				 ser.fDOMErrorHandler.handleError(error);
			}
			 throw new LSException(LSException.SERIALIZE_ERR, DOMMessageFormatter.formatMessage( DOMMessageFormatter.SERIALIZER_DOMAIN, ""unsupported-encoding"", null));
		 }
		 catch (LSException lse) {
			 throw lse;
		 }
		 catch (RuntimeException e) {
			 if (e == DOMNormalizer.abort){
				 return false;
			 }
			 throw (LSException) DOMUtil.createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();
		 }
		 catch (Exception e) {
			 if (ser.fDOMErrorHandler != null) {
				 DOMErrorImpl error = new DOMErrorImpl();
				 error.fException = e;
				 error.fMessage = e.getMessage();
				 error.fSeverity = DOMError.SEVERITY_ERROR;
				 ser.fDOMErrorHandler.handleError(error);
			 }
			 throw (LSException) DOMUtil.createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();
		 }
		 finally {
			 ser.clearDocumentState();
		 }
		 return true;
	 }
	 public boolean writeToURI(Node node, String URI) throws LSException{
		 if (node == null){
			 return false;
		 }
		 XMLSerializer ser = null;
		 String ver = _getXmlVersion(node);
		 if (ver != null && ver.equals(""1.1"")) {
			 if (xml11Serializer == null) {
				 xml11Serializer = new XML11Serializer();
				 initSerializer(xml11Serializer);
			 }
			 copySettings(serializer, xml11Serializer);
			 ser = xml11Serializer;
		 }
		 else {
			 ser = serializer;
		 }
		 String encoding = _getInputEncoding(node);
		 if (encoding == null) {
			 encoding = _getXmlEncoding(node);
			 if (encoding == null) {
				 encoding = ""UTF-8"";
			 }
		 }
		 try {
			 prepareForSerialization(ser, node);
			 ser._format.setEncoding(encoding);
			 ser.setOutputByteStream(XMLEntityManager.createOutputStream(URI));
			 if (node.getNodeType() == Node.DOCUMENT_NODE) ser.serialize((Document) node);
			 else if (node.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE) ser.serialize((DocumentFragment) node);
			 else if (node.getNodeType() == Node.ELEMENT_NODE) ser.serialize((Element) node);
			 else return false;
		 }
		 catch (LSException lse) {
			 throw lse;
		 }
		 catch (RuntimeException e) {
			 if (e == DOMNormalizer.abort){
				 return false;
			 }
			 throw (LSException) DOMUtil.createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();
		 }
		 catch (Exception e) {
			 if (ser.fDOMErrorHandler != null) {
				 DOMErrorImpl error = new DOMErrorImpl();
				 error.fException = e;
				 error.fMessage = e.getMessage();
				 error.fSeverity = DOMError.SEVERITY_ERROR;
				 ser.fDOMErrorHandler.handleError(error);
			 }
			 throw (LSException) DOMUtil.createLSException(LSException.SERIALIZE_ERR, e).fillInStackTrace();
		 }
		 finally {
			 ser.clearDocumentState();
		 }
		 return true;
	 }
	 private void prepareForSerialization(XMLSerializer ser, Node node) {
		 ser.reset();
		 ser.features = features;
		 ser.fDOMErrorHandler = fErrorHandler;
		 ser.fNamespaces = (features & NAMESPACES) != 0;
		 ser.fNamespacePrefixes = (features & NSDECL) != 0;
		 ser._format.setIndenting((features & PRETTY_PRINT) != 0);
		 ser._format.setOmitComments((features & COMMENTS)==0);
		 ser._format.setOmitXMLDeclaration((features & XMLDECL) == 0);
		 if ((features & WELLFORMED) != 0) {
			 Node next, root;
			 root = node;
			 Method versionChanged;
			 boolean verifyNames = true;
			 Document document =(node.getNodeType() == Node.DOCUMENT_NODE) ? (Document) node : node.getOwnerDocument();
			 try {
				 versionChanged = document.getClass().getMethod(""isXMLVersionChanged()"", new Class[] {
				}
				);
				 if (versionChanged != null) {
					 verifyNames = ((Boolean)versionChanged.invoke(document, (Object[]) null)).booleanValue();
				 }
			 }
			 catch (Exception e) {
			 }
			 if (node.getFirstChild() != null) {
				 while (node != null) {
					 verify(node, verifyNames, false);
					 next = node.getFirstChild();
					 while (next == null) {
						 next = node.getNextSibling();
						 if (next == null) {
							 node = node.getParentNode();
							 if (root == node){
								 next = null;
								 break;
							 }
							 next = node.getNextSibling();
						 }
					 }
					 node = next;
				 }
			 }
			 else {
				 verify(node, verifyNames, false);
			 }
		 }
	 }
	 private void verify (Node node, boolean verifyNames, boolean xml11Version){
		 int type = node.getNodeType();
		 fLocator.fRelatedNode = node;
		 boolean wellformed;
		 switch (type) {
			 case Node.DOCUMENT_NODE:{
				 break;
			 }
			 case Node.DOCUMENT_TYPE_NODE:{
				 break;
			 }
			 case Node.ELEMENT_NODE:{
				 if (verifyNames){
					 if((features & NAMESPACES) != 0){
						 wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), xml11Version) ;
					 }
					 else{
						 wellformed = CoreDocumentImpl.isXMLName(node.getNodeName() , xml11Version);
					 }
					 if (!wellformed){
						 if (fErrorHandler != null) {
							 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""wf-invalid-character-in-node-name"", new Object[]{
							""Element"", node.getNodeName()}
							);
							 DOMNormalizer.reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR, ""wf-invalid-character-in-node-name"");
						 }
					 }
				 }
				 NamedNodeMap attributes = (node.hasAttributes()) ? node.getAttributes() : null;
				 if (attributes != null) {
					 for (int i = 0;
					 i < attributes.getLength();
					 ++i) {
						 Attr attr = (Attr) attributes.item(i);
						 fLocator.fRelatedNode = attr;
						 DOMNormalizer.isAttrValueWF( fErrorHandler, fError, fLocator, attributes, attr, attr.getValue(), xml11Version);
						 if (verifyNames) {
							 wellformed = CoreDocumentImpl.isXMLName( attr.getNodeName(), xml11Version);
							 if (!wellformed) {
								 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""wf-invalid-character-in-node-name"", new Object[] {
								 ""Attr"", node.getNodeName()}
								);
								 DOMNormalizer.reportDOMError( fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR, ""wf-invalid-character-in-node-name"");
							 }
						 }
					 }
				 }
				 break;
			 }
			 case Node.COMMENT_NODE: {
				 if ((features & COMMENTS) != 0) DOMNormalizer.isCommentWF(fErrorHandler, fError, fLocator, ((Comment)node).getData(), xml11Version);
				 break;
			 }
			 case Node.ENTITY_REFERENCE_NODE: {
				 if (verifyNames && (features & ENTITIES) != 0){
					 CoreDocumentImpl.isXMLName(node.getNodeName() , xml11Version);
				 }
				 break;
			 }
			 case Node.CDATA_SECTION_NODE: {
				 DOMNormalizer.isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), xml11Version);
				 break;
			 }
			 case Node.TEXT_NODE:{
				 DOMNormalizer.isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), xml11Version);
				 break;
			 }
			 case Node.PROCESSING_INSTRUCTION_NODE:{
				 ProcessingInstruction pinode = (ProcessingInstruction)node ;
				 String target = pinode.getTarget();
				 if (verifyNames) {
					 if (xml11Version) {
						 wellformed = XML11Char.isXML11ValidName(target);
					 }
					 else {
						 wellformed = XMLChar.isValidName(target);
					 }
					 if (!wellformed) {
						 String msg = DOMMessageFormatter.formatMessage( DOMMessageFormatter.DOM_DOMAIN, ""wf-invalid-character-in-node-name"", new Object[] {
						 ""Element"", node.getNodeName()}
						);
						 DOMNormalizer.reportDOMError( fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR, ""wf-invalid-character-in-node-name"");
					 }
				 }
				 DOMNormalizer.isXMLCharWF(fErrorHandler, fError, fLocator, pinode.getData(), xml11Version);
				 break;
			 }
		 }
		 fLocator.fRelatedNode = null;
	 }
	 private String _getXmlVersion(Node node) {
		 Document doc = (node.getNodeType() == Node.DOCUMENT_NODE) ? (Document) node : node.getOwnerDocument();
		 if (doc != null && DocumentMethods.fgDocumentMethodsAvailable) {
			 try {
				 return (String) DocumentMethods.fgDocumentGetXmlVersionMethod.invoke(doc, (Object[]) null);
			 }
			 catch (VirtualMachineError vme) {
				 throw vme;
			 }
			 catch (ThreadDeath td) {
				 throw td;
			 }
			 catch (Throwable t) {
			}
		 }
		 return null;
	 }
	 private String _getInputEncoding(Node node) {
		 Document doc = (node.getNodeType() == Node.DOCUMENT_NODE) ? (Document) node : node.getOwnerDocument();
		 if (doc != null && DocumentMethods.fgDocumentMethodsAvailable) {
			 try {
				 return (String) DocumentMethods.fgDocumentGetInputEncodingMethod.invoke(doc, (Object[]) null);
			 }
			 catch (VirtualMachineError vme) {
				 throw vme;
			 }
			 catch (ThreadDeath td) {
				 throw td;
			 }
			 catch (Throwable t) {
			}
		 }
		 return null;
	 }
	 private String _getXmlEncoding(Node node) {
		 Document doc = (node.getNodeType() == Node.DOCUMENT_NODE) ? (Document) node : node.getOwnerDocument();
		 if (doc != null && DocumentMethods.fgDocumentMethodsAvailable) {
			 try {
				 return (String) DocumentMethods.fgDocumentGetXmlEncodingMethod.invoke(doc, (Object[]) null);
			 }
			 catch (VirtualMachineError vme) {
				 throw vme;
			 }
			 catch (ThreadDeath td) {
				 throw td;
			 }
			 catch (Throwable t) {
			}
		 }
		 return null;
	 }
	 static class DocumentMethods {
		 private static java.lang.reflect.Method fgDocumentGetXmlVersionMethod = null;
		 private static java.lang.reflect.Method fgDocumentGetInputEncodingMethod = null;
		 private static java.lang.reflect.Method fgDocumentGetXmlEncodingMethod = null;
		 private static boolean fgDocumentMethodsAvailable = false;
		 private DocumentMethods() {
		}
		 static {
			 try {
				 fgDocumentGetXmlVersionMethod = Document.class.getMethod(""getXmlVersion"", new Class [] {
				}
				);
				 fgDocumentGetInputEncodingMethod = Document.class.getMethod(""getInputEncoding"", new Class [] {
				}
				);
				 fgDocumentGetXmlEncodingMethod = Document.class.getMethod(""getXmlEncoding"", new Class [] {
				}
				);
				 fgDocumentMethodsAvailable = true;
			 }
			 catch (Exception exc) {
				 fgDocumentGetXmlVersionMethod = null;
				 fgDocumentGetInputEncodingMethod = null;
				 fgDocumentGetXmlEncodingMethod = null;
				 fgDocumentMethodsAvailable = false;
			 }
		 }
	 }
}",1,0,0,0
"protected void buildContent( ){
	IDescriptorProvider nameProvider = new TextPropertyDescriptorProvider( IDesignElementModel.NAME_PROP,ReportDesignConstants.VARIABLE_ELEMENT );
	TextSection nameSection = new TextSection( nameProvider.getDisplayName( ),container,true );
	nameSection.setProvider( nameProvider );
	nameSection.setLayoutNum( 6 );
	nameSection.setWidth( 500 );
	addSection( PageSectionId.VARIABLE_NAME, nameSection );
	 ComboPropertyDescriptorProvider variableTypeProvider = new ComboPropertyDescriptorProvider( IVariableElementModel.TYPE_PROP,ReportDesignConstants.VARIABLE_ELEMENT );
	variableTypeProvider.enableReset( true );
	ComboSection variableTypeSection = new ComboSection( variableTypeProvider.getDisplayName( ),container,true );
	variableTypeSection.setProvider( variableTypeProvider );
	variableTypeSection.setLayoutNum( 6 );
	variableTypeSection.setWidth( 500 );
	addSection( PageSectionId.VARIABLE_TYPE, variableTypeSection );
	ExpressionPropertyDescriptorProvider variableValueProvider = new ExpressionPropertyDescriptorProvider( IVariableElementModel.VALUE_PROP,ReportDesignConstants.VARIABLE_ELEMENT );
	ExpressionSection variableValueSection = new ExpressionSection( variableValueProvider.getDisplayName( ),container,true );
	variableValueSection.setMulti(false);
	variableValueSection.setProvider( variableValueProvider );
	variableValueSection.setWidth( 500 );
	variableValueSection.setLayoutNum( 6 );
	addSection( PageSectionId.VARIABLE_VALUE, variableValueSection );
}",0,0,1,0
"public interface ModelFactory extends EFactory{
	ModelFactory eINSTANCE = org.eclipse.birt.report.model.adapter.oda.model.impl.ModelFactoryImpl.init();
	DataSetParameter createDataSetParameter();
	DataSetParameters createDataSetParameters();
	DesignValues createDesignValues();
	DocumentRoot createDocumentRoot();
	DynamicList createDynamicList();
	ModelPackage getModelPackage();
}",0,0,0,0
"public void writeRead() throws IOException {
	 try (XSSFWorkbook workbook = XSSFTestDataSamples.openSampleWorkbook(""WithVariousData.xlsx"")) {
		 XSSFSheet sheet1 = workbook.getSheetAt(0);
		 XSSFSheet sheet2 = workbook.getSheetAt(1);
		 assertTrue(sheet1.hasComments());
		 assertFalse(sheet2.hasComments());
		 Row r5 = sheet1.getRow(4);
		 Comment cc5 = r5.getCell(2).getCellComment();
		 cc5.setAuthor(""Apache POI"");
		 cc5.setString(new XSSFRichTextString(""Hello!""));
		 Row r2s2 = sheet2.createRow(2);
		 Cell c1r2s2 = r2s2.createCell(1);
		 assertNull(c1r2s2.getCellComment());
		 Drawing<T> dg = sheet2.createDrawingPatriarch();
		 Comment cc2 = dg.createCellComment(new XSSFClientAnchor());
		 cc2.setAuthor(""Also POI"");
		 cc2.setString(new XSSFRichTextString(""A new comment""));
		 c1r2s2.setCellComment(cc2);
		 try (XSSFWorkbook workbookBack = XSSFTestDataSamples.writeOutAndReadBack(workbook)) {
			 sheet1 = workbookBack.getSheetAt(0);
			 sheet2 = workbookBack.getSheetAt(1);
			 assertNotNull(sheet1.getRow(4).getCell(2).getCellComment());
			 assertNotNull(sheet1.getRow(6).getCell(2).getCellComment());
			 assertNotNull(sheet2.getRow(2).getCell(1).getCellComment());
			 assertEquals(""Apache POI"", sheet1.getRow(4).getCell(2).getCellComment().getAuthor());
			 assertEquals(""Nick Burch"", sheet1.getRow(6).getCell(2).getCellComment().getAuthor());
			 assertEquals(""Also POI"", sheet2.getRow(2).getCell(1).getCellComment().getAuthor());
			 assertEquals(""Hello!"", sheet1.getRow(4).getCell(2).getCellComment().getString().getString());
		 }
	 }
 }",0,0,1,0
"public interface SystemOffNormalAlarmType extends OffNormalAlarmType {
}",0,0,0,0
"public class StandardWrapper extends ContainerBase implements ServletConfig, Wrapper, NotificationEmitter {
	 private static final Log log = LogFactory.getLog( StandardWrapper.class );
	 protected static final String[] DEFAULT_SERVLET_METHODS = new String[] {
	 ""GET"", ""HEAD"", ""POST"" }
	;
	 public StandardWrapper() {
		 super();
		 swValve=new StandardWrapperValve();
		 pipeline.setBasic(swValve);
		 broadcaster = new NotificationBroadcasterSupport();
	 }
	 protected long available = 0L;
	 protected NotificationBroadcasterSupport broadcaster = null;
	 protected AtomicInteger countAllocated = new AtomicInteger(0);
	 protected StandardWrapperFacade facade = new StandardWrapperFacade(this);
	 protected static final String info = ""org.apache.catalina.core.StandardWrapper/1.0"";
	 protected volatile Servlet instance = null;
	 protected volatile boolean instanceInitialized = false;
	 protected InstanceSupport instanceSupport = new InstanceSupport(this);
	 protected String jspFile = null;
	 protected int loadOnStartup = -1;
	 protected ArrayList<String> mappings = new ArrayList<String>();
	 protected HashMap<String, String> parameters = new HashMap<String, String>();
	 protected HashMap<String, String> references = new HashMap<String, String>();
	 protected String runAs = null;
	 protected long sequenceNumber = 0;
	 protected String servletClass = null;
	 protected boolean singleThreadModel = false;
	 protected boolean unloading = false;
	 protected int maxInstances = 20;
	 protected int nInstances = 0;
	 protected Stack<Servlet> instancePool = null;
	 protected long unloadDelay = 2000;
	 protected boolean isJspServlet;
	 protected ObjectName jspMonitorON;
	 protected boolean swallowOutput = false;
	 protected StandardWrapperValve swValve;
	 protected long loadTime=0;
	 protected int classLoadTime=0;
	 protected MultipartConfigElement multipartConfigElement = null;
	 protected boolean asyncSupported = false;
	 protected boolean enabled = true;
	 protected static Class<?>[] classType = new Class[]{
	ServletConfig.class}
	;
	 protected static Class<?>[] classTypeUsedInService = new Class[]{
	 ServletRequest.class, ServletResponse.class}
	;
	 public long getAvailable() {
		 return (this.available);
	 }
	 public void setAvailable(long available) {
		 long oldAvailable = this.available;
		 if (available > System.currentTimeMillis()) this.available = available;
		 else this.available = 0L;
		 support.firePropertyChange(""available"", new Long(oldAvailable), new Long(this.available));
	 }
	 public int getCountAllocated() {
		 return (this.countAllocated.get());
	 }
	 public String getInfo() {
		 return (info);
	 }
	 public InstanceSupport getInstanceSupport() {
		 return (this.instanceSupport);
	 }
	 public String getJspFile() {
		 return (this.jspFile);
	 }
	 public void setJspFile(String jspFile) {
		 String oldJspFile = this.jspFile;
		 this.jspFile = jspFile;
		 support.firePropertyChange(""jspFile"", oldJspFile, this.jspFile);
		 isJspServlet = true;
	 }
	 public int getLoadOnStartup() {
		 if (isJspServlet && loadOnStartup < 0) {
			 return Integer.MAX_VALUE;
		 }
		 else {
			 return (this.loadOnStartup);
		 }
	 }
	 public void setLoadOnStartup(int value) {
		 int oldLoadOnStartup = this.loadOnStartup;
		 this.loadOnStartup = value;
		 support.firePropertyChange(""loadOnStartup"", new Integer(oldLoadOnStartup), new Integer(this.loadOnStartup));
	 }
	 public void setLoadOnStartupString(String value) {
		 try {
			 setLoadOnStartup(Integer.parseInt(value));
		 }
		 catch (NumberFormatException e) {
			 setLoadOnStartup(0);
		 }
	 }
	 public String getLoadOnStartupString() {
		 return Integer.toString( getLoadOnStartup());
	 }
	 public int getMaxInstances() {
		 return (this.maxInstances);
	 }
	 public void setMaxInstances(int maxInstances) {
		 int oldMaxInstances = this.maxInstances;
		 this.maxInstances = maxInstances;
		 support.firePropertyChange(""maxInstances"", oldMaxInstances, this.maxInstances);
	 }
	 public void setParent(Container container) {
		 if ((container != null) && !(container instanceof Context)) throw new IllegalArgumentException (sm.getString(""standardWrapper.notContext""));
		 if (container instanceof StandardContext) {
			 swallowOutput = ((StandardContext)container).getSwallowOutput();
			 unloadDelay = ((StandardContext)container).getUnloadDelay();
		 }
		 super.setParent(container);
	 }
	 public String getRunAs() {
		 return (this.runAs);
	 }
	 public void setRunAs(String runAs) {
		 String oldRunAs = this.runAs;
		 this.runAs = runAs;
		 support.firePropertyChange(""runAs"", oldRunAs, this.runAs);
	 }
	 public String getServletClass() {
		 return (this.servletClass);
	 }
	 public void setServletClass(String servletClass) {
		 String oldServletClass = this.servletClass;
		 this.servletClass = servletClass;
		 support.firePropertyChange(""servletClass"", oldServletClass, this.servletClass);
		 if (Constants.JSP_SERVLET_CLASS.equals(servletClass)) {
			 isJspServlet = true;
		 }
	 }
	 public void setServletName(String name) {
		 setName(name);
	 }
	 public boolean isSingleThreadModel() {
		 try {
			 loadServlet();
		 }
		 catch (Throwable t) {
			 ExceptionUtils.handleThrowable(t);
		 }
		 return (singleThreadModel);
	 }
	 public boolean isUnavailable() {
		 if (!isEnabled()) return true;
		 else if (available == 0L) return false;
		 else if (available <= System.currentTimeMillis()) {
			 available = 0L;
			 return false;
		 }
		 else return true;
	 }
	 public String[] getServletMethods() throws ServletException {
		 Class<? extends Servlet> servletClazz = loadServlet().getClass();
		 if (!javax.servlet.http.HttpServlet.class.isAssignableFrom( servletClazz)) {
			 return DEFAULT_SERVLET_METHODS;
		 }
		 HashSet<String> allow = new HashSet<String>();
		 allow.add(""TRACE"");
		 allow.add(""OPTIONS"");
		 Method[] methods = getAllDeclaredMethods(servletClazz);
		 for (int i=0;
		 methods != null && i<methods.length;
		 i++) {
			 Method m = methods[i];
			 if (m.getName().equals(""doGet"")) {
				 allow.add(""GET"");
				 allow.add(""HEAD"");
			 }
			 else if (m.getName().equals(""doPost"")) {
				 allow.add(""POST"");
			 }
			 else if (m.getName().equals(""doPut"")) {
				 allow.add(""PUT"");
			 }
			 else if (m.getName().equals(""doDelete"")) {
				 allow.add(""DELETE"");
			 }
		 }
		 String[] methodNames = new String[allow.size()];
		 return allow.toArray(methodNames);
	 }
	 public Servlet getServlet() {
		 return instance;
	 }
	 public void setServlet(Servlet servlet) {
		 instance = servlet;
	 }
	 public void backgroundProcess() {
		 super.backgroundProcess();
		 if (!getState().isAvailable()) return;
		 if (getServlet() != null && (getServlet() instanceof PeriodicEventListener)) {
			 ((PeriodicEventListener) getServlet()).periodicEvent();
		 }
	 }
	 public static Throwable getRootCause(ServletException e) {
		 Throwable rootCause = e;
		 Throwable rootCauseCheck = null;
		 int loops = 0;
		 do {
			 loops++;
			 rootCauseCheck = rootCause.getCause();
			 if (rootCauseCheck != null) rootCause = rootCauseCheck;
		 }
		 while (rootCauseCheck != null && (loops < 20));
		 return rootCause;
	 }
	 public void addChild(Container child) {
		 throw new IllegalStateException (sm.getString(""standardWrapper.notChild""));
	 }
	 public void addInitParameter(String name, String value) {
		 synchronized (parameters) {
			 parameters.put(name, value);
		 }
		 fireContainerEvent(""addInitParameter"", name);
	 }
	 public void addInstanceListener(InstanceListener listener) {
		 instanceSupport.addInstanceListener(listener);
	 }
	 public void addMapping(String mapping) {
		 synchronized (mappings) {
			 mappings.add(mapping);
		 }
		 fireContainerEvent(ADD_MAPPING_EVENT, mapping);
	 }
	 public void addSecurityReference(String name, String link) {
		 synchronized (references) {
			 references.put(name, link);
		 }
		 fireContainerEvent(""addSecurityReference"", name);
	 }
	 public Servlet allocate() throws ServletException {
		 if (unloading) throw new ServletException (sm.getString(""standardWrapper.unloading"", getName()));
		 boolean newInstance = false;
		 if (!singleThreadModel) {
			 if (instance == null) {
				 synchronized (this) {
					 if (instance == null) {
						 try {
							 if (log.isDebugEnabled()) log.debug(""Allocating non-STM instance"");
							 instance = loadServlet();
							 if (!singleThreadModel) {
								 newInstance = true;
								 countAllocated.incrementAndGet();
							 }
						 }
						 catch (ServletException e) {
							 throw e;
						 }
						 catch (Throwable e) {
							 throw new ServletException (sm.getString(""standardWrapper.allocate""), e);
						 }
					 }
				 }
			 }
			 if (!instanceInitialized) {
				 initServlet(instance);
			 }
			 if (!singleThreadModel) {
				 if (log.isTraceEnabled()) log.trace("" Returning non-STM instance"");
				 if (!newInstance) {
					 countAllocated.incrementAndGet();
				 }
				 return (instance);
			 }
		 }
		 synchronized (instancePool) {
			 while (countAllocated.get() >= nInstances) {
				 if (nInstances < maxInstances) {
					 try {
						 instancePool.push(loadServlet());
						 nInstances++;
					 }
					 catch (ServletException e) {
						 throw e;
					 }
					 catch (Throwable e) {
						 throw new ServletException (sm.getString(""standardWrapper.allocate""), e);
					 }
				 }
				 else {
					 try {
						 instancePool.wait();
					 }
					 catch (InterruptedException e) {
					 }
				 }
			 }
			 if (log.isTraceEnabled()) log.trace("" Returning allocated STM instance"");
			 countAllocated.incrementAndGet();
			 return instancePool.pop();
		 }
	 }
	 public void deallocate(Servlet servlet) throws ServletException {
		 if (!singleThreadModel) {
			 countAllocated.decrementAndGet();
			 return;
		 }
		 synchronized (instancePool) {
			 countAllocated.decrementAndGet();
			 instancePool.push(servlet);
			 instancePool.notify();
		 }
	 }
	 public String findInitParameter(String name) {
		 synchronized (parameters) {
			 return parameters.get(name);
		 }
	 }
	 public String[] findInitParameters() {
		 synchronized (parameters) {
			 String results[] = new String[parameters.size()];
			 return parameters.keySet().toArray(results);
		 }
	 }
	 public String[] findMappings() {
		 synchronized (mappings) {
			 return mappings.toArray(new String[mappings.size()]);
		 }
	 }
	 public String findSecurityReference(String name) {
		 synchronized (references) {
			 return references.get(name);
		 }
	 }
	 public String[] findSecurityReferences() {
		 synchronized (references) {
			 String results[] = new String[references.size()];
			 return references.keySet().toArray(results);
		 }
	 }
	 public Wrapper findMappingObject() {
		 return (Wrapper) getMappingObject();
	 }
	 public synchronized void load() throws ServletException {
		 instance = loadServlet();
		 if (isJspServlet) {
			 StringBuilder oname = new StringBuilder(MBeanUtils.getDomain(getParent()));
			 oname.append("":type=JspMonitor,name="");
			 oname.append(getName());
			 oname.append(getWebModuleKeyProperties());
			 try {
				 jspMonitorON = new ObjectName(oname.toString());
				 Registry.getRegistry(null, null) .registerComponent(instance, jspMonitorON, null);
			 }
			 catch( Exception ex ) {
				 log.info(""Error registering JSP monitoring with jmx "" + instance);
			 }
		 }
	 }
	 public synchronized Servlet loadServlet() throws ServletException {
		 if (!singleThreadModel && (instance != null)) return instance;
		 PrintStream out = System.out;
		 if (swallowOutput) {
			 SystemLogHandler.startCapture();
		 }
		 Servlet servlet;
		 try {
			 long t1=System.currentTimeMillis();
			 String actualClass = servletClass;
			 if ((actualClass == null) && (jspFile != null)) {
				 Wrapper jspWrapper = (Wrapper) ((Context) getParent()).findChild(Constants.JSP_SERVLET_NAME);
				 if (jspWrapper != null) {
					 actualClass = jspWrapper.getServletClass();
					 String paramNames[] = jspWrapper.findInitParameters();
					 for (int i = 0;
					 i < paramNames.length;
					 i++) {
						 if (parameters.get(paramNames[i]) == null) {
							 parameters.put (paramNames[i], jspWrapper.findInitParameter(paramNames[i]));
						 }
					 }
				 }
			 }
			 if (actualClass == null) {
				 unavailable(null);
				 throw new ServletException (sm.getString(""standardWrapper.notClass"", getName()));
			 }
			 InstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();
			 try {
				 servlet = (Servlet) instanceManager.newInstance(actualClass);
			 }
			 catch (ClassCastException e) {
				 unavailable(null);
				 throw new ServletException (sm.getString(""standardWrapper.notServlet"", actualClass), e);
			 }
			 catch (Throwable e) {
				 unavailable(null);
				 if(log.isDebugEnabled()) {
					 log.debug(sm.getString(""standardWrapper.instantiate"", actualClass), e);
				 }
				 throw new ServletException (sm.getString(""standardWrapper.instantiate"", actualClass), e);
			 }
			 if (multipartConfigElement == null) {
				 MultipartConfig annotation = servlet.getClass().getAnnotation(MultipartConfig.class);
				 if (annotation != null) {
					 multipartConfigElement = new MultipartConfigElement(annotation);
				 }
			 }
			 if ((servlet instanceof ContainerServlet) && (isContainerProvidedServlet(actualClass) || ((Context)getParent()).getPrivileged() )) {
				 ((ContainerServlet) servlet).setWrapper(this);
			 }
			 classLoadTime=(int) (System.currentTimeMillis() -t1);
			 initServlet(servlet);
			 singleThreadModel = servlet instanceof SingleThreadModel;
			 if (singleThreadModel) {
				 if (instancePool == null) instancePool = new Stack<Servlet>();
			 }
			 fireContainerEvent(""load"", this);
			 loadTime=System.currentTimeMillis() -t1;
		 }
		 finally {
			 if (swallowOutput) {
				 String log = SystemLogHandler.stopCapture();
				 if (log != null && log.length() > 0) {
					 if (getServletContext() != null) {
						 getServletContext().log(log);
					 }
					 else {
						 out.println(log);
					 }
				 }
			 }
		 }
		 return servlet;
	 }
	 private synchronized void initServlet(Servlet servlet) throws ServletException {
		 if (instanceInitialized) return;
		 try {
			 instanceSupport.fireInstanceEvent(InstanceEvent.BEFORE_INIT_EVENT, servlet);
			 if( Globals.IS_SECURITY_ENABLED) {
				 Object[] args = new Object[]{
				(facade)}
				;
				 SecurityUtil.doAsPrivilege(""init"", servlet, classType, args);
				 args = null;
			 }
			 else {
				 servlet.init(facade);
			 }
			 if ((loadOnStartup >= 0) && (jspFile != null)) {
				 DummyRequest req = new DummyRequest();
				 req.setServletPath(jspFile);
				 req.setQueryString(Constants.PRECOMPILE + ""=true"");
				 DummyResponse res = new DummyResponse();
				 if( Globals.IS_SECURITY_ENABLED) {
					 Object[] args = new Object[]{
					req, res}
					;
					 SecurityUtil.doAsPrivilege(""service"", servlet, classTypeUsedInService, args);
					 args = null;
				 }
				 else {
					 servlet.service(req, res);
				 }
			 }
			 instanceInitialized = true;
			 instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet);
		 }
		 catch (UnavailableException f) {
			 instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet, f);
			 unavailable(f);
			 throw f;
		 }
		 catch (ServletException f) {
			 instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet, f);
			 throw f;
		 }
		 catch (Throwable f) {
			 getServletContext().log(""StandardWrapper.Throwable"", f );
			 instanceSupport.fireInstanceEvent(InstanceEvent.AFTER_INIT_EVENT, servlet, f);
			 throw new ServletException (sm.getString(""standardWrapper.initException"", getName()), f);
		 }
	 }
	 public void removeInitParameter(String name) {
		 synchronized (parameters) {
			 parameters.remove(name);
		 }
		 fireContainerEvent(""removeInitParameter"", name);
	 }
	 public void removeInstanceListener(InstanceListener listener) {
		 instanceSupport.removeInstanceListener(listener);
	 }
	 public void removeMapping(String mapping) {
		 synchronized (mappings) {
			 mappings.remove(mapping);
		 }
		 fireContainerEvent(REMOVE_MAPPING_EVENT, mapping);
	 }
	 public void removeSecurityReference(String name) {
		 synchronized (references) {
			 references.remove(name);
		 }
		 fireContainerEvent(""removeSecurityReference"", name);
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder();
		 if (getParent() != null) {
			 sb.append(getParent().toString());
			 sb.append(""."");
		 }
		 sb.append(""StandardWrapper["");
		 sb.append(getName());
		 sb.append(""]"");
		 return (sb.toString());
	 }
	 public void unavailable(UnavailableException unavailable) {
		 getServletContext().log(sm.getString(""standardWrapper.unavailable"", getName()));
		 if (unavailable == null) setAvailable(Long.MAX_VALUE);
		 else if (unavailable.isPermanent()) setAvailable(Long.MAX_VALUE);
		 else {
			 int unavailableSeconds = unavailable.getUnavailableSeconds();
			 if (unavailableSeconds <= 0) unavailableSeconds = 60;
			 setAvailable(System.currentTimeMillis() + (unavailableSeconds * 1000L));
		 }
	 }
	 public synchronized void unload() throws ServletException {
		 if (!singleThreadModel && (instance == null)) return;
		 unloading = true;
		 if (countAllocated.get() > 0) {
			 int nRetries = 0;
			 long delay = unloadDelay / 20;
			 while ((nRetries < 21) && (countAllocated.get() > 0)) {
				 if ((nRetries % 10) == 0) {
					 log.info(sm.getString(""standardWrapper.waiting"", countAllocated.toString()));
				 }
				 try {
					 Thread.sleep(delay);
				 }
				 catch (InterruptedException e) {
				 }
				 nRetries++;
			 }
		 }
		 PrintStream out = System.out;
		 if (swallowOutput) {
			 SystemLogHandler.startCapture();
		 }
		 try {
			 instanceSupport.fireInstanceEvent (InstanceEvent.BEFORE_DESTROY_EVENT, instance);
			 if( Globals.IS_SECURITY_ENABLED) {
				 SecurityUtil.doAsPrivilege(""destroy"", instance);
				 SecurityUtil.remove(instance);
			 }
			 else {
				 instance.destroy();
			 }
			 instanceSupport.fireInstanceEvent (InstanceEvent.AFTER_DESTROY_EVENT, instance);
			 if (!((Context) getParent()).getIgnoreAnnotations()) {
				 ((StandardContext)getParent()).getInstanceManager().destroyInstance(instance);
			 }
		 }
		 catch (Throwable t) {
			 instanceSupport.fireInstanceEvent (InstanceEvent.AFTER_DESTROY_EVENT, instance, t);
			 instance = null;
			 instancePool = null;
			 nInstances = 0;
			 fireContainerEvent(""unload"", this);
			 unloading = false;
			 throw new ServletException (sm.getString(""standardWrapper.destroyException"", getName()), t);
		 }
		 finally {
			 if (swallowOutput) {
				 String log = SystemLogHandler.stopCapture();
				 if (log != null && log.length() > 0) {
					 if (getServletContext() != null) {
						 getServletContext().log(log);
					 }
					 else {
						 out.println(log);
					 }
				 }
			 }
		 }
		 instance = null;
		 if (isJspServlet && jspMonitorON != null ) {
			 Registry.getRegistry(null, null).unregisterComponent(jspMonitorON);
		 }
		 if (singleThreadModel && (instancePool != null)) {
			 try {
				 while (!instancePool.isEmpty()) {
					 Servlet s = instancePool.pop();
					 if (Globals.IS_SECURITY_ENABLED) {
						 SecurityUtil.doAsPrivilege(""destroy"", s);
						 SecurityUtil.remove(instance);
					 }
					 else {
						 s.destroy();
					 }
					 if (!((Context) getParent()).getIgnoreAnnotations()) {
						 ((StandardContext)getParent()).getInstanceManager().destroyInstance(s);
					 }
				 }
			 }
			 catch (Throwable t) {
				 instancePool = null;
				 nInstances = 0;
				 unloading = false;
				 fireContainerEvent(""unload"", this);
				 throw new ServletException (sm.getString(""standardWrapper.destroyException"", getName()), t);
			 }
			 instancePool = null;
			 nInstances = 0;
		 }
		 singleThreadModel = false;
		 unloading = false;
		 fireContainerEvent(""unload"", this);
	 }
	 public String getInitParameter(String name) {
		 return (findInitParameter(name));
	 }
	 public Enumeration<String> getInitParameterNames() {
		 synchronized (parameters) {
			 return (new Enumerator<String>(parameters.keySet()));
		 }
	 }
	 public ServletContext getServletContext() {
		 if (parent == null) return (null);
		 else if (!(parent instanceof Context)) return (null);
		 else return (((Context) parent).getServletContext());
	 }
	 public String getServletName() {
		 return (getName());
	 }
	 public long getProcessingTime() {
		 return swValve.getProcessingTime();
	 }
	 public void setProcessingTime(long processingTime) {
		 swValve.setProcessingTime(processingTime);
	 }
	 public long getMaxTime() {
		 return swValve.getMaxTime();
	 }
	 public void setMaxTime(long maxTime) {
		 swValve.setMaxTime(maxTime);
	 }
	 public long getMinTime() {
		 return swValve.getMinTime();
	 }
	 public void setMinTime(long minTime) {
		 swValve.setMinTime(minTime);
	 }
	 public int getRequestCount() {
		 return swValve.getRequestCount();
	 }
	 public void setRequestCount(int requestCount) {
		 swValve.setRequestCount(requestCount);
	 }
	 public int getErrorCount() {
		 return swValve.getErrorCount();
	 }
	 public void setErrorCount(int errorCount) {
		 swValve.setErrorCount(errorCount);
	 }
	 public void incrementErrorCount(){
		 swValve.setErrorCount(swValve.getErrorCount() + 1);
	 }
	 public long getLoadTime() {
		 return loadTime;
	 }
	 public void setLoadTime(long loadTime) {
		 this.loadTime = loadTime;
	 }
	 public int getClassLoadTime() {
		 return classLoadTime;
	 }
	 public MultipartConfigElement getMultipartConfigElement() {
		 return multipartConfigElement;
	 }
	 public void setMultipartConfigElement( MultipartConfigElement multipartConfigElement) {
		 this.multipartConfigElement = multipartConfigElement;
	 }
	 public boolean isAsyncSupported() {
		 return asyncSupported;
	 }
	 public void setAsyncSupported(boolean asyncSupported) {
		 this.asyncSupported = asyncSupported;
	 }
	 public boolean isEnabled() {
		 return enabled;
	 }
	 public void setEnabled(boolean enabled) {
		 this.enabled = enabled;
	 }
	 protected void addDefaultMapper( String mapperClass) {
	 }
	 protected boolean isContainerProvidedServlet(String classname) {
		 if (classname.startsWith(""org.apache.catalina."")) {
			 return (true);
		 }
		 try {
			 Class<?> clazz = this.getClass().getClassLoader().loadClass(classname);
			 return (ContainerServlet.class.isAssignableFrom(clazz));
		 }
		 catch (Throwable t) {
			 return (false);
		 }
	 }
	 protected Method[] getAllDeclaredMethods(Class<?> c) {
		 if (c.equals(javax.servlet.http.HttpServlet.class)) {
			 return null;
		 }
		 Method[] parentMethods = getAllDeclaredMethods(c.getSuperclass());
		 Method[] thisMethods = c.getDeclaredMethods();
		 if (thisMethods == null) {
			 return parentMethods;
		 }
		 if ((parentMethods != null) && (parentMethods.length > 0)) {
			 Method[] allMethods = new Method[parentMethods.length + thisMethods.length];
			 System.arraycopy(parentMethods, 0, allMethods, 0, parentMethods.length);
			 System.arraycopy(thisMethods, 0, allMethods, parentMethods.length, thisMethods.length);
			 thisMethods = allMethods;
		}
		return thisMethods;
	 }
	 protected synchronized void startInternal() throws LifecycleException {
		 if (this.getObjectName() != null) {
			 Notification notification = new Notification(""j2ee.state.starting"", this.getObjectName(), sequenceNumber++);
			 broadcaster.sendNotification(notification);
		 }
		 super.startInternal();
		 setAvailable(0L);
		 if (this.getObjectName() != null) {
			 Notification notification = new Notification(""j2ee.state.running"", this.getObjectName(), sequenceNumber++);
			 broadcaster.sendNotification(notification);
		 }
	 }
	 protected synchronized void stopInternal() throws LifecycleException {
		 setAvailable(Long.MAX_VALUE);
		 if (this.getObjectName() != null) {
			 Notification notification = new Notification(""j2ee.state.stopping"", this.getObjectName(), sequenceNumber++);
			 broadcaster.sendNotification(notification);
		 }
		 try {
			 unload();
		 }
		 catch (ServletException e) {
			 getServletContext().log(sm.getString (""standardWrapper.unloadException"", getName()), e);
		 }
		 super.stopInternal();
		 if (this.getObjectName() != null) {
			 Notification notification = new Notification(""j2ee.state.stopped"", this.getObjectName(), sequenceNumber++);
			 broadcaster.sendNotification(notification);
		 }
		 Notification notification = new Notification(""j2ee.object.deleted"", this.getObjectName(), sequenceNumber++);
		 broadcaster.sendNotification(notification);
	 }
	 protected String getObjectNameKeyProperties() {
		 StringBuilder keyProperties = new StringBuilder(""j2eeType=Servlet,name="");
		 keyProperties.append(getName());
		 keyProperties.append(getWebModuleKeyProperties());
		 return keyProperties.toString();
	 }
	 private String getWebModuleKeyProperties() {
		 StringBuilder keyProperties = new StringBuilder("",WebModule="");
		 String hostName = getParent().getParent().getName();
		 if (hostName == null) {
			 keyProperties.append(""DEFAULT"");
		 }
		 else {
			 keyProperties.append(hostName);
		 }
		 String pathName = ((Context) getParent()).getPath();
		 if ("""".equals(pathName)) {
			 keyProperties.append('/');
		 }
		 else {
			 keyProperties.append(pathName);
		 }
		 StandardContext ctx = null;
		 if (parent instanceof StandardContext) {
			 ctx = (StandardContext) getParent();
		 }
		 keyProperties.append("",J2EEApplication="");
		 if (ctx == null) {
			 keyProperties.append(""none"");
		 }
		 else {
			 keyProperties.append(ctx.getJ2EEApplication());
		 }
		 keyProperties.append("",J2EEServer="");
		 if (ctx == null) {
			 keyProperties.append(""none"");
		 }
		 else {
			 keyProperties.append(ctx.getJ2EEServer());
		 }
		 return keyProperties.toString();
	 }
	 public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object object) throws ListenerNotFoundException {
		 broadcaster.removeNotificationListener(listener,filter,object);
	 }
	 protected MBeanNotificationInfo[] notificationInfo;
	 public MBeanNotificationInfo[] getNotificationInfo() {
		 if(notificationInfo == null) {
			 notificationInfo = new MBeanNotificationInfo[]{
				 new MBeanNotificationInfo(new String[] {
				 ""j2ee.object.created""}
				,Notification.class.getName(),""servlet is created"" ), new MBeanNotificationInfo(new String[] {
				""j2ee.state.starting""}
				,Notification.class.getName(),""servlet is starting""),new MBeanNotificationInfo(new String[] {
				""j2ee.state.running""}
				,Notification.class.getName(),""servlet is running""),new MBeanNotificationInfo(new String[] {
				""j2ee.state.stopped""}
				,Notification.class.getName(),""servlet start to stopped""),new MBeanNotificationInfo(new String[] {
				""j2ee.object.stopped""}
				,Notification.class.getName(),""servlet is stopped""),new MBeanNotificationInfo(new String[] {
				""j2ee.object.deleted""}
			,Notification.class.getName(),""servlet is deleted"") }
			;
		 }
		 return notificationInfo;
	 }
	 public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object object) throws IllegalArgumentException {
		 broadcaster.addNotificationListener(listener,filter,object);
	 }
	 public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
		 broadcaster.removeNotificationListener(listener);
	 }
	 public boolean isEventProvider() {
		 return false;
	 }
	 public boolean isStateManageable() {
		 return false;
	 }
	 public boolean isStatisticsProvider() {
		 return false;
	 }
}",1,0,0,0
"public UTF8 getName() {
	 return name;
 }",0,0,0,0
"public static class RequireCapability {
	 private final String namespace;
	 private final String filter;
	 private final String effective;
	 public RequireCapability ( final String namespace, final String filter, final String effective ) {
		 this.namespace = namespace;
		 this.filter = filter;
		 this.effective = effective;
	 }
	 public String getNamespace () {
		 return this.namespace;
	 }
	 public String getFilter () {
		 return this.filter;
	 }
	 public String getEffective () {
		 return this.effective;
	 }
 }",0,1,0,0
"public static void logOpenException(Descriptor descriptor, IOException e) {
	 if (e instanceof FileNotFoundException) logger.error(""Missing sstable component in "" + descriptor + "";
	 skipped because of "" + e.getMessage());
	 else logger.error(""Corrupt sstable "" + descriptor + "";
	 skipped"", e);
 }",0,0,0,0
"public class Main implements AntMain {
	 private static final Set LAUNCH_COMMANDS = new HashSet();
	 static {
		 LAUNCH_COMMANDS.add(""-lib"");
		 LAUNCH_COMMANDS.add(""-cp"");
		 LAUNCH_COMMANDS.add(""-noclasspath"");
		 LAUNCH_COMMANDS.add(""--noclasspath"");
		 LAUNCH_COMMANDS.add(""-nouserlib"");
		 LAUNCH_COMMANDS.add(""-main"");
	 }
	 public static final String DEFAULT_BUILD_FILENAME = ""build.xml"";
	 private int msgOutputLevel = Project.MSG_INFO;
	 private File buildFile;
	 private static PrintStream out = System.out;
	 private static PrintStream err = System.err;
	 private Vector targets = new Vector();
	 private Properties definedProps = new Properties();
	 private Vector listeners = new Vector(1);
	 private Vector propertyFiles = new Vector(1);
	 private boolean allowInput = true;
	 private boolean keepGoingMode = false;
	 private String loggerClassname = null;
	 private String inputHandlerClassname = null;
	 private boolean emacsMode = false;
	 private boolean readyToRun = false;
	 private boolean projectHelp = false;
	 private static boolean isLogFileUsed = false;
	 private Integer threadPriority = null;
	 private boolean proxy = false;
	 private static void printMessage(Throwable t) {
		 String message = t.getMessage();
		 if (message != null) {
			 System.err.println(message);
		 }
	 }
	 public static void start(String[] args, Properties additionalUserProperties, ClassLoader coreLoader) {
		 Main m = new Main();
		 m.startAnt(args, additionalUserProperties, coreLoader);
	 }
	 public void startAnt(String[] args, Properties additionalUserProperties, ClassLoader coreLoader) {
		 try {
			 Diagnostics.validateVersion();
			 processArgs(args);
		 }
		 catch (Throwable exc) {
			 handleLogfile();
			 printMessage(exc);
			 exit(1);
			 return;
		 }
		 if (additionalUserProperties != null) {
			 for (Enumeration e = additionalUserProperties.keys();
			 e.hasMoreElements();
			) {
				 String key = (String) e.nextElement();
				 String property = additionalUserProperties.getProperty(key);
				 definedProps.put(key, property);
			 }
		 }
		 int exitCode = 1;
		 try {
			 try {
				 runBuild(coreLoader);
				 exitCode = 0;
			 }
			 catch (ExitStatusException ese) {
				 exitCode = ese.getStatus();
				 if (exitCode != 0) {
					 throw ese;
				 }
			 }
		 }
		 catch (BuildException be) {
			 if (err != System.err) {
				 printMessage(be);
			 }
		 }
		 catch (Throwable exc) {
			 exc.printStackTrace();
			 printMessage(exc);
		 }
		 finally {
			 handleLogfile();
		 }
		 exit(exitCode);
	 }
	 protected void exit(int exitCode) {
		 System.exit(exitCode);
	 }
	 private static void handleLogfile() {
		 if (isLogFileUsed) {
			 FileUtils.close(out);
			 FileUtils.close(err);
		 }
	 }
	 public static void main(String[] args) {
		 start(args, null, null);
	 }
	 public Main() {
	 }
	 protected Main(String[] args) throws BuildException {
		 processArgs(args);
	 }
	 private void processArgs(String[] args) {
		 String searchForThis = null;
		 PrintStream logTo = null;
		 for (int i = 0;
		 i < args.length;
		 i++) {
			 String arg = args[i];
			 if (arg.equals(""-help"") || arg.equals(""-h"")) {
				 printUsage();
				 return;
			 }
			 else if (arg.equals(""-version"")) {
				 printVersion();
				 return;
			 }
			 else if (arg.equals(""-diagnostics"")) {
				 Diagnostics.doReport(System.out);
				 return;
			 }
			 else if (arg.equals(""-quiet"") || arg.equals(""-q"")) {
				 msgOutputLevel = Project.MSG_WARN;
			 }
			 else if (arg.equals(""-verbose"") || arg.equals(""-v"")) {
				 printVersion();
				 msgOutputLevel = Project.MSG_VERBOSE;
			 }
			 else if (arg.equals(""-debug"") || arg.equals(""-d"")) {
				 printVersion();
				 msgOutputLevel = Project.MSG_DEBUG;
			 }
			 else if (arg.equals(""-noinput"")) {
				 allowInput = false;
			 }
			 else if (arg.equals(""-logfile"") || arg.equals(""-l"")) {
				 try {
					 File logFile = new File(args[i + 1]);
					 i++;
					 logTo = new PrintStream(new FileOutputStream(logFile));
					 isLogFileUsed = true;
				 }
				 catch (IOException ioe) {
					 String msg = ""Cannot write on the specified log file. "" + ""Make sure the path exists and you have write "" + ""permissions."";
					 throw new BuildException(msg);
				 }
				 catch (ArrayIndexOutOfBoundsException aioobe) {
					 String msg = ""You must specify a log file when "" + ""using the -log argument"";
					 throw new BuildException(msg);
				 }
			 }
			 else if (arg.equals(""-buildfile"") || arg.equals(""-file"") || arg.equals(""-f"")) {
				 i = handleArgBuildFile(args, i);
			 }
			 else if (arg.equals(""-listener"")) {
				 i = handleArgListener(args, i);
			 }
			 else if (arg.startsWith(""-D"")) {
				 i = handleArgDefine(args, i);
			 }
			 else if (arg.equals(""-logger"")) {
				 i = handleArgLogger(args, i);
			 }
			 else if (arg.equals(""-inputhandler"")) {
				 i = handleArgInputHandler(args, i);
			 }
			 else if (arg.equals(""-emacs"") || arg.equals(""-e"")) {
				 emacsMode = true;
			 }
			 else if (arg.equals(""-projecthelp"") || arg.equals(""-p"")) {
				 projectHelp = true;
			 }
			 else if (arg.equals(""-find"") || arg.equals(""-s"")) {
				 if (i < args.length - 1) {
					 searchForThis = args[++i];
				 }
				 else {
					 searchForThis = DEFAULT_BUILD_FILENAME;
				 }
			 }
			 else if (arg.startsWith(""-propertyfile"")) {
				 i = handleArgPropertyFile(args, i);
			 }
			 else if (arg.equals(""-k"") || arg.equals(""-keep-going"")) {
				 keepGoingMode = true;
			 }
			 else if (arg.equals(""-nice"")) {
				 i = handleArgNice(args, i);
			 }
			 else if (LAUNCH_COMMANDS.contains(arg)) {
				 String msg = ""Ant's Main method is being handed "" + ""an option "" + arg + "" that is only for the launcher class."" + ""\nThis can be caused by a version mismatch between "" + ""the ant script/.bat file and Ant itself."";
				 throw new BuildException(msg);
			 }
			 else if (arg.equals(""-autoproxy"")) {
				 proxy = true;
			 }
			 else if (arg.startsWith(""-"")) {
				 String msg = ""Unknown argument: "" + arg;
				 System.err.println(msg);
				 printUsage();
				 throw new BuildException("""");
			 }
			 else {
				 targets.addElement(arg);
			 }
		 }
		 if (buildFile == null) {
			 if (searchForThis != null) {
				 buildFile = findBuildFile(System.getProperty(""user.dir""), searchForThis);
			 }
			 else {
				 buildFile = new File(DEFAULT_BUILD_FILENAME);
			 }
		 }
		 if (!buildFile.exists()) {
			 System.out.println(""Buildfile: "" + buildFile + "" does not exist!"");
			 throw new BuildException(""Build failed"");
		 }
		 if (buildFile.isDirectory()) {
			 System.out.println(""What? Buildfile: "" + buildFile + "" is a dir!"");
			 throw new BuildException(""Build failed"");
		 }
		 loadPropertyFiles();
		 if (msgOutputLevel >= Project.MSG_INFO) {
			 System.out.println(""Buildfile: "" + buildFile);
		 }
		 if (logTo != null) {
			 out = logTo;
			 err = logTo;
			 System.setOut(out);
			 System.setErr(err);
		 }
		 readyToRun = true;
	 }
	 private int handleArgBuildFile(String[] args, int pos) {
		 try {
			 buildFile = new File( args[++pos].replace('/', File.separatorChar));
		 }
		 catch (ArrayIndexOutOfBoundsException aioobe) {
			 throw new BuildException( ""You must specify a buildfile when using the -buildfile argument"");
		 }
		 return pos;
	 }
	 private int handleArgListener(String[] args, int pos) {
		 try {
			 listeners.addElement(args[pos + 1]);
			 pos++;
		 }
		 catch (ArrayIndexOutOfBoundsException aioobe) {
			 String msg = ""You must specify a classname when "" + ""using the -listener argument"";
			 throw new BuildException(msg);
		 }
		 return pos;
	 }
	 private int handleArgDefine(String[] args, int argPos) {
		 String arg = args[argPos];
		 String name = arg.substring(2, arg.length());
		 String value = null;
		 int posEq = name.indexOf(""="");
		 if (posEq > 0) {
			 value = name.substring(posEq + 1);
			 name = name.substring(0, posEq);
		 }
		 else if (argPos < args.length - 1) {
			 value = args[++argPos];
		 }
		 else {
			 throw new BuildException(""Missing value for property "" + name);
		 }
		 definedProps.put(name, value);
		 return argPos;
	 }
	 private int handleArgLogger(String[] args, int pos) {
		 if (loggerClassname != null) {
			 throw new BuildException( ""Only one logger class may be specified."");
		 }
		 try {
			 loggerClassname = args[++pos];
		 }
		 catch (ArrayIndexOutOfBoundsException aioobe) {
			 throw new BuildException( ""You must specify a classname when using the -logger argument"");
		 }
		 return pos;
	 }
	 private int handleArgInputHandler(String[] args, int pos) {
		 if (inputHandlerClassname != null) {
			 throw new BuildException(""Only one input handler class may "" + ""be specified."");
		 }
		 try {
			 inputHandlerClassname = args[++pos];
		 }
		 catch (ArrayIndexOutOfBoundsException aioobe) {
			 throw new BuildException(""You must specify a classname when"" + "" using the -inputhandler"" + "" argument"");
		 }
		 return pos;
	 }
	 private int handleArgPropertyFile(String[] args, int pos) {
		 try {
			 propertyFiles.addElement(args[++pos]);
		 }
		 catch (ArrayIndexOutOfBoundsException aioobe) {
			 String msg = ""You must specify a property filename when "" + ""using the -propertyfile argument"";
			 throw new BuildException(msg);
		 }
		 return pos;
	 }
	 private int handleArgNice(String[] args, int pos) {
		 try {
			 threadPriority = Integer.decode(args[++pos]);
		 }
		 catch (ArrayIndexOutOfBoundsException aioobe) {
			 throw new BuildException( ""You must supply a niceness value (1-10)"" + "" after the -nice option"");
		 }
		 catch (NumberFormatException e) {
			 throw new BuildException(""Unrecognized niceness value: "" + args[pos]);
		 }
		 if (threadPriority.intValue() < Thread.MIN_PRIORITY || threadPriority.intValue() > Thread.MAX_PRIORITY) {
			 throw new BuildException( ""Niceness value is out of the range 1-10"");
		 }
		 return pos;
	 }
	 private void loadPropertyFiles() {
		 for (int propertyFileIndex = 0;
		 propertyFileIndex < propertyFiles.size();
		 propertyFileIndex++) {
			 String filename = (String) propertyFiles.elementAt(propertyFileIndex);
			 Properties props = new Properties();
			 FileInputStream fis = null;
			 try {
				 fis = new FileInputStream(filename);
				 props.load(fis);
			 }
			 catch (IOException e) {
				 System.out.println(""Could not load property file "" + filename + "": "" + e.getMessage());
			 }
			 finally {
				 FileUtils.close(fis);
			 }
			 Enumeration propertyNames = props.propertyNames();
			 while (propertyNames.hasMoreElements()) {
				 String name = (String) propertyNames.nextElement();
				 if (definedProps.getProperty(name) == null) {
					 definedProps.put(name, props.getProperty(name));
				 }
			 }
		 }
	 }
	 private File getParentFile(File file) {
		 File parent = file.getParentFile();
		 if (parent != null && msgOutputLevel >= Project.MSG_VERBOSE) {
			 System.out.println(""Searching in "" + parent.getAbsolutePath());
		 }
		 return parent;
	 }
	 private File findBuildFile(String start, String suffix) throws BuildException {
		 if (msgOutputLevel >= Project.MSG_INFO) {
			 System.out.println(""Searching for "" + suffix + "" ..."");
		 }
		 File parent = new File(new File(start).getAbsolutePath());
		 File file = new File(parent, suffix);
		 while (!file.exists()) {
			 parent = getParentFile(parent);
			 if (parent == null) {
				 throw new BuildException(""Could not locate a build file!"");
			 }
			 file = new File(parent, suffix);
		 }
		 return file;
	 }
	 private void runBuild(ClassLoader coreLoader) throws BuildException {
		 if (!readyToRun) {
			 return;
		 }
		 final Project project = new Project();
		 project.setCoreLoader(coreLoader);
		 Throwable error = null;
		 try {
			 addBuildListeners(project);
			 addInputHandler(project);
			 PrintStream savedErr = System.err;
			 PrintStream savedOut = System.out;
			 InputStream savedIn = System.in;
			 SecurityManager oldsm = null;
			 oldsm = System.getSecurityManager();
			 try {
				 if (allowInput) {
					 project.setDefaultInputStream(System.in);
				 }
				 System.setIn(new DemuxInputStream(project));
				 System.setOut(new PrintStream(new DemuxOutputStream(project, false)));
				 System.setErr(new PrintStream(new DemuxOutputStream(project, true)));
				 if (!projectHelp) {
					 project.fireBuildStarted();
				 }
				 if (threadPriority != null) {
					 try {
						 project.log(""Setting Ant's thread priority to "" + threadPriority, Project.MSG_VERBOSE);
						 Thread.currentThread().setPriority(threadPriority.intValue());
					 }
					 catch (SecurityException swallowed) {
						 project.log(""A security manager refused to set the -nice value"");
					 }
				 }
				 project.init();
				 Enumeration e = definedProps.keys();
				 while (e.hasMoreElements()) {
					 String arg = (String) e.nextElement();
					 String value = (String) definedProps.get(arg);
					 project.setUserProperty(arg, value);
				 }
				 project.setUserProperty(MagicNames.ANT_FILE, buildFile.getAbsolutePath());
				 project.setKeepGoingMode(keepGoingMode);
				 if (proxy) {
					 ProxySetup proxySetup = new ProxySetup(project);
					 proxySetup.enableProxies();
				 }
				 ProjectHelper.configureProject(project, buildFile);
				 if (projectHelp) {
					 printDescription(project);
					 printTargets(project, msgOutputLevel > Project.MSG_INFO);
					 return;
				 }
				 if (targets.size() == 0) {
					 if (project.getDefaultTarget() != null) {
						 targets.addElement(project.getDefaultTarget());
					 }
				 }
				 project.executeTargets(targets);
			 }
			 finally {
				 if (oldsm != null) {
					 System.setSecurityManager(oldsm);
				 }
				 System.setOut(savedOut);
				 System.setErr(savedErr);
				 System.setIn(savedIn);
			 }
		 }
		 catch (RuntimeException exc) {
			 error = exc;
			 throw exc;
		 }
		 catch (Error e) {
			 error = e;
			 throw e;
		 }
		 finally {
			 if (!projectHelp) {
				 project.fireBuildFinished(error);
			 }
			 else if (error != null) {
				 project.log(error.toString(), Project.MSG_ERR);
			 }
		 }
	 }
	 protected void addBuildListeners(Project project) {
		 project.addBuildListener(createLogger());
		 for (int i = 0;
		 i < listeners.size();
		 i++) {
			 String className = (String) listeners.elementAt(i);
			 BuildListener listener = (BuildListener) ClasspathUtils.newInstance(className, Main.class.getClassLoader(), BuildListener.class);
			 project.setProjectReference(listener);
			 project.addBuildListener(listener);
		 }
	 }
	 private void addInputHandler(Project project) throws BuildException {
		 InputHandler handler = null;
		 if (inputHandlerClassname == null) {
			 handler = new DefaultInputHandler();
		 }
		 else {
			 handler = (InputHandler) ClasspathUtils.newInstance( inputHandlerClassname, Main.class.getClassLoader(), InputHandler.class);
			 project.setProjectReference(handler);
		 }
		 project.setInputHandler(handler);
	 }
	 private BuildLogger createLogger() {
		 BuildLogger logger = null;
		 if (loggerClassname != null) {
			 try {
				 logger = (BuildLogger) ClasspathUtils.newInstance( loggerClassname, Main.class.getClassLoader(), BuildLogger.class);
			 }
			 catch (BuildException e) {
				 System.err.println(""The specified logger class "" + loggerClassname + "" could not be used because "" + e.getMessage());
				 throw new RuntimeException();
			 }
		 }
		 else {
			 logger = new DefaultLogger();
		 }
		 logger.setMessageOutputLevel(msgOutputLevel);
		 logger.setOutputPrintStream(out);
		 logger.setErrorPrintStream(err);
		 logger.setEmacsMode(emacsMode);
		 return logger;
	 }
	 private static void printUsage() {
		 String lSep = System.getProperty(""line.separator"");
		 StringBuffer msg = new StringBuffer();
		 msg.append(""ant [options] [target [target2 [target3] ...]]"" + lSep);
		 msg.append(""Options: "" + lSep);
		 msg.append("" -help, -h print this message"" + lSep);
		 msg.append("" -projecthelp, -p print project help information"" + lSep);
		 msg.append("" -version print the version information and exit"" + lSep);
		 msg.append("" -diagnostics print information that might be helpful to"" + lSep);
		 msg.append("" diagnose or report problems."" + lSep);
		 msg.append("" -quiet, -q be extra quiet"" + lSep);
		 msg.append("" -verbose, -v be extra verbose"" + lSep);
		 msg.append("" -debug, -d print debugging information"" + lSep);
		 msg.append("" -emacs, -e produce logging information without adornments"" + lSep);
		 msg.append("" -lib <path> specifies a path to search for jars and classes"" + lSep);
		 msg.append("" -logfile <file> use given file for log"" + lSep);
		 msg.append("" -l <file> ''"" + lSep);
		 msg.append("" -logger <classname> the class which is to perform logging"" + lSep);
		 msg.append("" -listener <classname> add an instance of class as a project listener"" + lSep);
		 msg.append("" -noinput do not allow interactive input"" + lSep);
		 msg.append("" -buildfile <file> use given buildfile"" + lSep);
		 msg.append("" -file <file> ''"" + lSep);
		 msg.append("" -f <file> ''"" + lSep);
		 msg.append("" -D<property>=<value> use value for given property"" + lSep);
		 msg.append("" -keep-going, -k execute all targets that do not depend"" + lSep);
		 msg.append("" on failed target(s)"" + lSep);
		 msg.append("" -propertyfile <name> load all properties from file with -D"" + lSep);
		 msg.append("" properties taking precedence"" + lSep);
		 msg.append("" -inputhandler <class> the class which will handle input requests"" + lSep);
		 msg.append("" -find <file> (s)earch for buildfile towards the root of"" + lSep);
		 msg.append("" -s <file> the filesystem and use it"" + lSep);
		 msg.append("" -nice number A niceness value for the main thread:"" + lSep + "" 1 (lowest) to 10 (highest);
		 5 is the default"" + lSep);
		 msg.append("" -nouserlib Run ant without using the jar files from"" + lSep + "" ${
		user.home}
		/.ant/lib"" + lSep);
		 msg.append("" -noclasspath Run ant without using CLASSPATH"" + lSep);
		 msg.append("" -autoproxy Java1.5+: use the OS proxy settings"" + lSep);
		 msg.append("" -main <class> override Ant's normal entry point"");
		 System.out.println(msg.toString());
	 }
	 private static void printVersion() throws BuildException {
		 System.out.println(getAntVersion());
	 }
	 private static String antVersion = null;
	 public static synchronized String getAntVersion() throws BuildException {
		 if (antVersion == null) {
			 try {
				 Properties props = new Properties();
				 InputStream in = Main.class.getResourceAsStream(""/org/apache/tools/ant/version.txt"");
				 props.load(in);
				 in.close();
				 StringBuffer msg = new StringBuffer();
				 msg.append(""Apache Ant version "");
				 msg.append(props.getProperty(""VERSION""));
				 msg.append("" compiled on "");
				 msg.append(props.getProperty(""DATE""));
				 antVersion = msg.toString();
			 }
			 catch (IOException ioe) {
				 throw new BuildException(""Could not load the version information:"" + ioe.getMessage());
			 }
			 catch (NullPointerException npe) {
				 throw new BuildException(""Could not load the version information."");
			 }
		 }
		 return antVersion;
	 }
	 private static void printDescription(Project project) {
		 if (project.getDescription() != null) {
			 project.log(project.getDescription());
		 }
	 }
	 private static Map removeDuplicateTargets(Map targets) {
		 Map locationMap = new HashMap();
		 for (Iterator i = targets.entrySet().iterator();
		 i.hasNext();
		) {
			 Map.Entry entry = (Map.Entry) i.next();
			 String name = (String) entry.getKey();
			 Target target = (Target) entry.getValue();
			 Target otherTarget = (Target) locationMap.get(target.getLocation());
			 if (otherTarget == null || otherTarget.getName().length() > name.length()) {
				 locationMap.put( target.getLocation(), target);
			 }
		 }
		 Map ret = new HashMap();
		 for (Iterator i = locationMap.values().iterator();
		 i.hasNext();
		) {
			 Target target = (Target) i.next();
			 ret.put(target.getName(), target);
		 }
		 return ret;
	 }
	 private static void printTargets(Project project, boolean printSubTargets) {
		 int maxLength = 0;
		 Map ptargets = removeDuplicateTargets(project.getTargets());
		 String targetName;
		 String targetDescription;
		 Target currentTarget;
		 Vector topNames = new Vector();
		 Vector topDescriptions = new Vector();
		 Vector subNames = new Vector();
		 for (Iterator i = ptargets.values().iterator();
		 i.hasNext();
		) {
			 currentTarget = (Target) i.next();
			 targetName = currentTarget.getName();
			 if (targetName.equals("""")) {
				 continue;
			 }
			 targetDescription = currentTarget.getDescription();
			 if (targetDescription == null) {
				 int pos = findTargetPosition(subNames, targetName);
				 subNames.insertElementAt(targetName, pos);
			 }
			 else {
				 int pos = findTargetPosition(topNames, targetName);
				 topNames.insertElementAt(targetName, pos);
				 topDescriptions.insertElementAt(targetDescription, pos);
				 if (targetName.length() > maxLength) {
					 maxLength = targetName.length();
				 }
			 }
		 }
		 printTargets(project, topNames, topDescriptions, ""Main targets:"", maxLength);
		 if (topNames.size() == 0) {
			 printSubTargets = true;
		 }
		 if (printSubTargets) {
			 printTargets(project, subNames, null, ""Other targets:"", 0);
		 }
		 String defaultTarget = project.getDefaultTarget();
		 if (defaultTarget != null && !"""".equals(defaultTarget)) {
			 project.log(""Default target: "" + defaultTarget);
		 }
	 }
	 private static int findTargetPosition(Vector names, String name) {
		 int res = names.size();
		 for (int i = 0;
		 i < names.size() && res == names.size();
		 i++) {
			 if (name.compareTo((String) names.elementAt(i)) < 0) {
				 res = i;
			 }
		 }
		 return res;
	 }
	 private static void printTargets(Project project, Vector names, Vector descriptions, String heading, int maxlen) {
		 String lSep = System.getProperty(""line.separator"");
		 String spaces = "" "";
		 while (spaces.length() <= maxlen) {
			 spaces += spaces;
		 }
		 StringBuffer msg = new StringBuffer();
		 msg.append(heading + lSep + lSep);
		 for (int i = 0;
		 i < names.size();
		 i++) {
			 msg.append("" "");
			 msg.append(names.elementAt(i));
			 if (descriptions != null) {
				 msg.append( spaces.substring(0, maxlen - ((String) names.elementAt(i)).length() + 2));
				 msg.append(descriptions.elementAt(i));
			 }
			 msg.append(lSep);
		 }
		 project.log(msg.toString(), Project.MSG_WARN);
	 }
}",0,0,0,0
"public class MiniClusterRunner {
	 public static void main(String[] args) {
		 System.setProperty(""hadoop.log.dir"", ""/tmp/pigunit"");
		 MiniGenericCluster.buildCluster();
	 }
}",1,0,0,0
"public class HolidayCalendarFactoryImpl extends HolidayCalendarFactory{
	public HolidayCalendar getHolidayCalendar(String cityIdentifier)throws HolidayCalendarException{
		return getHolidayCalendar(cityIdentifier,Period.class);
	}
	public <T extends Period> HolidayCalendar<T> getHolidayCalendar(String cityIdentifier, Class<T> c) {
		if (cityIdentifier.equals(""WE"")){
			return new WeekendHolidayCalendar<T>();
		}
		 else{
			throw new HolidayCalendarException(""Unknown holiday city \""""+ cityIdentifier+ ""\"", HolidayCalendarFactoryImpl only accepts \""WE\"" (Weekend Holiday Calendar)."");
		}
	}
	public String[] getAvailableLocales() {
		return new String[]{
		""WE""}
		;
	}
}",0,0,0,0
"public int getNumRecords() {
	 return numRecords;
 }",0,0,0,0
"private void paintClouds(Graphics2D g, Graphics2D gstroke, double x0,double y0,double x1,double y1, double distanceToConvexHull);",0,0,0,1
"public int readInt() throws JMSException {
	 if (ActiveMQRALogger.LOGGER.isTraceEnabled()) {
		 ActiveMQRALogger.LOGGER.trace(""readInt()"");
	 }
	 return ((BytesMessage) message).readInt();
 }",0,0,0,0
"public class Target implements TaskContainer {
	 private String name;
	 private String ifCondition = """";
	 private String unlessCondition = """";
	 private List dependencies = null;
	 private List children = new ArrayList();
	 private Location location = Location.UNKNOWN_LOCATION;
	 private Project project;
	 private String description = null;
	 public Target() {
	 }
	 public Target(Target other) {
		 this.name = other.name;
		 this.ifCondition = other.ifCondition;
		 this.unlessCondition = other.unlessCondition;
		 this.dependencies = other.dependencies;
		 this.location = other.location;
		 this.project = other.project;
		 this.description = other.description;
		 this.children = other.children;
	 }
	 public void setProject(Project project) {
		 this.project = project;
	 }
	 public Project getProject() {
		 return project;
	 }
	 public void setLocation(Location location) {
		 this.location = location;
	 }
	 public Location getLocation() {
		 return location;
	 }
	 public void setDepends(String depS) {
		 for (Iterator iter = parseDepends(depS, getName(), ""depends"").iterator();
		 iter.hasNext();
		 ) {
			 addDependency((String) iter.next());
		 }
	 }
	 public static List parseDepends(String depends, String targetName, String attributeName) {
		 ArrayList list = new ArrayList();
		 if (depends.length() > 0) {
			 StringTokenizer tok = new StringTokenizer(depends, "","", true);
			 while (tok.hasMoreTokens()) {
				 String token = tok.nextToken().trim();
				 if ("""".equals(token) || "","".equals(token)) {
					 throw new BuildException(""Syntax Error: "" + attributeName + "" attribute of target \"""" + targetName + ""\"" contains an empty string."");
				 }
				 list.add(token);
				 if (tok.hasMoreTokens()) {
					 token = tok.nextToken();
					 if (!tok.hasMoreTokens() || !"","".equals(token)) {
						 throw new BuildException(""Syntax Error: "" + attributeName + "" attribute for target \"""" + targetName + ""\"" ends with a \"",\"" "" + ""character"");
					 }
				 }
			 }
		 }
		 return list;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
	 public String getName() {
		 return name;
	 }
	 public void addTask(Task task) {
		 children.add(task);
	 }
	 public void addDataType(RuntimeConfigurable r) {
		 children.add(r);
	 }
	 public Task[] getTasks() {
		 List tasks = new ArrayList(children.size());
		 Iterator it = children.iterator();
		 while (it.hasNext()) {
			 Object o = it.next();
			 if (o instanceof Task) {
				 tasks.add(o);
			 }
		 }
		 return (Task[]) tasks.toArray(new Task[tasks.size()]);
	 }
	 public void addDependency(String dependency) {
		 if (dependencies == null) {
			 dependencies = new ArrayList(2);
		 }
		 dependencies.add(dependency);
	 }
	 public Enumeration getDependencies() {
		 return Collections .enumeration(dependencies == null ? Collections.EMPTY_LIST : dependencies);
	 }
	 public boolean dependsOn(String other) {
		 Project p = getProject();
		 Hashtable t = p == null ? null : p.getTargets();
		 return p != null && p.topoSort(getName(), t, false).contains(t.get(other));
	 }
	 public void setIf(String property) {
		 ifCondition = property == null ? """" : property;
	 }
	 public String getIf() {
		 return """".equals(ifCondition) ? null : ifCondition;
	 }
	 public void setUnless(String property) {
		 unlessCondition = property == null ? """" : property;
	 }
	 public String getUnless() {
		 return """".equals(unlessCondition) ? null : unlessCondition;
	 }
	 public void setDescription(String description) {
		 this.description = description;
	 }
	 public String getDescription() {
		 return description;
	 }
	 public String toString() {
		 return name;
	 }
	 public void execute() throws BuildException {
		 if (!testIfAllows()) {
			 project.log(this, ""Skipped because property '"" + project.replaceProperties(ifCondition) + ""' not set."", Project.MSG_VERBOSE);
			 return;
		 }
		 if (!testUnlessAllows()) {
			 project.log(this, ""Skipped because property '"" + project.replaceProperties(unlessCondition) + ""' set."", Project.MSG_VERBOSE);
			 return;
		 }
		 LocalProperties localProperties = LocalProperties.get(getProject());
		 localProperties.enterScope();
		 try {
			 for (int i = 0;
			 i < children.size();
			 i++) {
				 Object o = children.get(i);
				 if (o instanceof Task) {
					 Task task = (Task) o;
					 task.perform();
				 }
				 else {
					 ((RuntimeConfigurable) o).maybeConfigure(project);
				 }
			 }
		 }
		 finally {
			 localProperties.exitScope();
		 }
	 }
	 public final void performTasks() {
		 RuntimeException thrown = null;
		 project.fireTargetStarted(this);
		 try {
			 execute();
		 }
		 catch (RuntimeException exc) {
			 thrown = exc;
			 throw exc;
		 }
		 finally {
			 project.fireTargetFinished(this, thrown);
		 }
	 }
	 void replaceChild(Task el, RuntimeConfigurable o) {
		 int index;
		 while ((index = children.indexOf(el)) >= 0) {
			 children.set(index, o);
		 }
	 }
	 void replaceChild(Task el, Task o) {
		 int index;
		 while ((index = children.indexOf(el)) >= 0) {
			 children.set(index, o);
		 }
	 }
	 private boolean testIfAllows() {
		 PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(getProject());
		 Object o = propertyHelper.parseProperties(ifCondition);
		 return propertyHelper.testIfCondition(o);
	 }
	 private boolean testUnlessAllows() {
		 PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(getProject());
		 Object o = propertyHelper.parseProperties(unlessCondition);
		 return propertyHelper.testUnlessCondition(o);
	 }
}",0,0,0,0
"public class SchedulerInfo {
	 private String type;
	 private double capacity;
	 private double usedCapacity;
	 private double maxCapacity;
	 private String queueName;
	 private Queues queues;
	 public Queues getQueues() {
		 return queues;
	 }
	 public void setQueues(Queues queues) {
		 this.queues = queues;
	 }
	 public double getUsedCapacity() {
		 return usedCapacity;
	 }
	 public void setUsedCapacity(double usedCapacity) {
		 this.usedCapacity = usedCapacity;
	 }
	 public String getType() {
		 return type;
	 }
	 public void setType(String type) {
		 this.type = type;
	 }
	 public double getCapacity() {
		 return capacity;
	 }
	 public void setCapacity(double capacity) {
		 this.capacity = capacity;
	 }
	 public double getMaxCapacity() {
		 return maxCapacity;
	 }
	 public void setMaxCapacity(double maxCapacity) {
		 this.maxCapacity = maxCapacity;
	 }
	 public String getQueueName() {
		 return queueName;
	 }
	 public void setQueueName(String queueName) {
		 this.queueName = queueName;
	 }
}",0,1,0,0
"private static void migrateSnapshots(File ksDir) {
	 File snapshotDir = new File(ksDir, SNAPSHOT_SUBDIR);
	 if (!snapshotDir.exists()) return;
	 for (File snapshot : snapshotDir.listFiles()) {
		 if (!snapshot.isDirectory()) continue;
		 for (File f : snapshot.listFiles()) migrateFile(f, ksDir, join(SNAPSHOT_SUBDIR, snapshot.getName()));
		 if (!snapshot.delete()) logger.info(""Old snapsot directory {
		}
		 not deleted by migraation as it is not empty"", snapshot);
	 }
	 if (!snapshotDir.delete()) logger.info(""Old directory {
	}
	 not deleted by migration as it is not empty"", snapshotDir);
 }",0,0,0,0
"public abstract class SegmentedFile{
	 public final String path;
	 public final long length;
	 SegmentedFile(String path, long length) {
		 this.path = path;
		 this.length = length;
	 }
	 public static Builder getBuilder(Config.DiskAccessMode mode) {
		 return mode == Config.DiskAccessMode.mmap ? new MmappedSegmentedFile.Builder() : new BufferedSegmentedFile.Builder();
	 }
	 public abstract FileDataInput getSegment(long position, int bufferSize);
	 public Iterator<FileDataInput> iterator(long position, int bufferSize) {
		 return new SegmentIterator(position, bufferSize);
	 }
	 public static abstract class Builder {
		 public abstract void addPotentialBoundary(long boundary);
		 public abstract SegmentedFile complete(String path);
	 }
	 static final class Segment extends Pair<Long, MappedByteBuffer> implements Comparable<Segment> {
		 public Segment(long offset, MappedByteBuffer segment) {
			 super(offset, segment);
		 }
		 public final int compareTo(Segment that) {
			 return (int)Math.signum(this.left - that.left);
		 }
	 }
	 final class SegmentIterator implements Iterator<FileDataInput> {
		 private long nextpos;
		 private final int bufferSize;
		 public SegmentIterator(long position, int bufferSize) {
			 this.nextpos = position;
			 this.bufferSize = bufferSize;
		 }
		 public boolean hasNext() {
			 return nextpos < length;
		 }
		 public FileDataInput next() {
			 long position = nextpos;
			 if (position >= length) throw new NoSuchElementException();
			 FileDataInput segment = getSegment(nextpos, bufferSize);
			 try {
				 nextpos = nextpos + segment.bytesRemaining();
			 }
			 catch (IOException e) {
				 throw new IOError(e);
			 }
			 return segment;
		 }
		 public void remove() {
			 throw new UnsupportedOperationException();
		 }
	 }
	 public String toString() {
		 return getClass().getSimpleName() + ""(path='"" + path + ""'"" + "", length="" + length + "")"";
	}
}",0,0,0,0
"public class ExtractTemplateCmd extends BaseAsyncCmd {
	 public static final Logger s_logger = Logger.getLogger(ExtractTemplateCmd.class.getName());
	 private static final String s_name = ""extracttemplateresponse"";
	 private Long id;
	 private String url;
	 private Long zoneId;
	 private String mode;
	 public Long getId() {
		 return id;
	 }
	 public String getUrl() {
		 return url;
	 }
	 public Long getZoneId() {
		 return zoneId;
	 }
	 public String getMode() {
		 return mode;
	 }
	 public String getCommandName() {
		 return s_name;
	 }
	 public static String getStaticName() {
		 return s_name;
	 }
	 public long getEntityOwnerId() {
		 VirtualMachineTemplate template = _entityMgr.findById(VirtualMachineTemplate.class, getId());
		 if (template != null) {
			 return template.getAccountId();
		 }
		 return Account.ACCOUNT_ID_SYSTEM;
	 }
	 public String getEventType() {
		 return EventTypes.EVENT_TEMPLATE_EXTRACT;
	 }
	 public String getEventDescription() {
		 return ""extracting template: "" + this._uuidMgr.getUuid(VirtualMachineTemplate.class, getId()) + ((getZoneId() != null) ? "" from zone: "" + this._uuidMgr.getUuid(DataCenter.class, getZoneId()) : """");
	 }
	 public ApiCommandJobType getInstanceType() {
		 return ApiCommandJobType.Template;
	 }
	 public Long getInstanceId() {
		 return getId();
	 }
	 public void execute() {
		 try {
			 CallContext.current().setEventDetails(getEventDescription());
			 String uploadUrl = _templateService.extract(this);
			 if (uploadUrl != null) {
				 ExtractResponse response = _responseGenerator.createExtractResponse(id, zoneId, getEntityOwnerId(), mode, uploadUrl);
				 response.setResponseName(getCommandName());
				 this.setResponseObject(response);
			 }
			 else {
				 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to extract template"");
			 }
		 }
		 catch (InternalErrorException ex) {
			 s_logger.warn(""Exception: "", ex);
			 throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());
		 }
	 }
}",1,1,0,0
"public class SchemaValidate extends XMLValidateTask {
	 private HashMap schemaLocations = new HashMap();
	 private boolean fullChecking = true;
	 private boolean disableDTD = false;
	 private SchemaLocation anonymousSchema;
	 public static final String ERROR_SAX_1 = ""SAX1 parsers are not supported"";
	 public static final String ERROR_NO_XSD_SUPPORT = ""Parser does not support Xerces or JAXP schema features"";
	 public static final String ERROR_TOO_MANY_DEFAULT_SCHEMAS = ""Only one of defaultSchemaFile and defaultSchemaURL allowed"";
	 public static final String ERROR_PARSER_CREATION_FAILURE = ""Could not create parser"";
	 public static final String MESSAGE_ADDING_SCHEMA = ""Adding schema "";
	 public static final String ERROR_DUPLICATE_SCHEMA = ""Duplicate declaration of schema "";
	 public void init() throws BuildException {
		 super.init();
		 setLenient(false);
	 }
	 public boolean enableXercesSchemaValidation() {
		 try {
			 setFeature(XmlConstants.FEATURE_XSD, true);
			 setNoNamespaceSchemaProperty(XmlConstants.PROPERTY_NO_NAMESPACE_SCHEMA_LOCATION);
		 }
		 catch (BuildException e) {
			 log(e.toString(), Project.MSG_VERBOSE);
			 return false;
		 }
		 return true;
	 }
	 private void setNoNamespaceSchemaProperty(String property) {
		 String anonSchema = getNoNamespaceSchemaURL();
		 if (anonSchema != null) {
			 setProperty(property, anonSchema);
		 }
	 }
	 public boolean enableJAXP12SchemaValidation() {
		 try {
			 setProperty(XmlConstants.FEATURE_JAXP12_SCHEMA_LANGUAGE, XmlConstants.URI_XSD);
			 setNoNamespaceSchemaProperty(XmlConstants.FEATURE_JAXP12_SCHEMA_SOURCE);
		 }
		 catch (BuildException e) {
			 log(e.toString(), Project.MSG_VERBOSE);
			 return false;
		 }
		 return true;
	 }
	 public void addConfiguredSchema(SchemaLocation location) {
		 log(""adding schema "" + location, Project.MSG_DEBUG);
		 location.validateNamespace();
		 SchemaLocation old = (SchemaLocation) schemaLocations.get(location.getNamespace());
		 if (old != null && !old.equals(location)) {
			 throw new BuildException(ERROR_DUPLICATE_SCHEMA + location);
		 }
		 schemaLocations.put(location.getNamespace(), location);
	 }
	 public void setFullChecking(boolean fullChecking) {
		 this.fullChecking = fullChecking;
	 }
	 protected void createAnonymousSchema() {
		 if (anonymousSchema == null) {
			 anonymousSchema = new SchemaLocation();
		 }
		 anonymousSchema.setNamespace(""(no namespace)"");
	 }
	 public void setNoNamespaceURL(String defaultSchemaURL) {
		 createAnonymousSchema();
		 this.anonymousSchema.setUrl(defaultSchemaURL);
	 }
	 public void setNoNamespaceFile(File defaultSchemaFile) {
		 createAnonymousSchema();
		 this.anonymousSchema.setFile(defaultSchemaFile);
	 }
	 public void setDisableDTD(boolean disableDTD) {
		 this.disableDTD = disableDTD;
	 }
	 protected void initValidator() {
		 super.initValidator();
		 if (isSax1Parser()) {
			 throw new BuildException(ERROR_SAX_1);
		 }
		 setFeature(XmlConstants.FEATURE_NAMESPACES, true);
		 if (!enableXercesSchemaValidation() && !enableJAXP12SchemaValidation()) {
			 throw new BuildException(ERROR_NO_XSD_SUPPORT);
		 }
		 setFeature(XmlConstants.FEATURE_XSD_FULL_VALIDATION, fullChecking);
		 setFeatureIfSupported(XmlConstants.FEATURE_DISALLOW_DTD, disableDTD);
		 addSchemaLocations();
	 }
	 protected XMLReader createDefaultReader() {
		 SAXParserFactory factory = SAXParserFactory.newInstance();
		 factory.setValidating(true);
		 factory.setNamespaceAware(true);
		 XMLReader reader = null;
		 try {
			 SAXParser saxParser = factory.newSAXParser();
			 reader = saxParser.getXMLReader();
		 }
		 catch (ParserConfigurationException e) {
			 throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
		 }
		 catch (SAXException e) {
			 throw new BuildException(ERROR_PARSER_CREATION_FAILURE, e);
		 }
		 return reader;
	 }
	 protected void addSchemaLocations() {
		 Iterator it = schemaLocations.values().iterator();
		 StringBuffer buffer = new StringBuffer();
		 int count = 0;
		 while (it.hasNext()) {
			 if (count > 0) {
				 buffer.append(' ');
			 }
			 SchemaLocation schemaLocation = (SchemaLocation) it.next();
			 String tuple = schemaLocation.getURIandLocation();
			 buffer.append(tuple);
			 log(""Adding schema "" + tuple, Project.MSG_VERBOSE);
			 count++;
		 }
		 if (count > 0) {
			 setProperty(XmlConstants.PROPERTY_SCHEMA_LOCATION, buffer.toString());
		 }
	 }
	 protected String getNoNamespaceSchemaURL() {
		 if (anonymousSchema == null) {
			 return null;
		 }
		 else {
			 return anonymousSchema.getSchemaLocationURL();
		 }
	 }
	 protected void setFeatureIfSupported(String feature, boolean value) {
		 try {
			 getXmlReader().setFeature(feature, value);
		 }
		 catch (SAXNotRecognizedException e) {
			 log(""Not recognizied: "" + feature, Project.MSG_VERBOSE);
		 }
		 catch (SAXNotSupportedException e) {
			 log(""Not supported: "" + feature, Project.MSG_VERBOSE);
		 }
	 }
	 protected void onSuccessfulValidation(int fileProcessed) {
		 log(fileProcessed + MESSAGE_FILES_VALIDATED, Project.MSG_VERBOSE);
	 }
	 public static class SchemaLocation {
		 private String namespace;
		 private File file;
		 private String url;
		 public static final String ERROR_NO_URI = ""No namespace URI"";
		 public static final String ERROR_TWO_LOCATIONS = ""Both URL and File were given for schema "";
		 public static final String ERROR_NO_FILE = ""File not found: "";
		 public static final String ERROR_NO_URL_REPRESENTATION = ""Cannot make a URL of "";
		 public static final String ERROR_NO_LOCATION = ""No file or URL supplied for the schema "";
		 public SchemaLocation() {
		 }
		 public String getNamespace() {
			 return namespace;
		 }
		 public void setNamespace(String namespace) {
			 this.namespace = namespace;
		 }
		 public File getFile() {
			 return file;
		 }
		 public void setFile(File file) {
			 this.file = file;
		 }
		 public String getUrl() {
			 return url;
		 }
		 public void setUrl(String url) {
			 this.url = url;
		 }
		 public String getSchemaLocationURL() {
			 boolean hasFile = file != null;
			 boolean hasURL = isSet(url);
			 if (!hasFile && !hasURL) {
				 throw new BuildException(ERROR_NO_LOCATION + namespace);
			 }
			 if (hasFile && hasURL) {
				 throw new BuildException(ERROR_TWO_LOCATIONS + namespace);
			 }
			 String schema = url;
			 if (hasFile) {
				 if (!file.exists()) {
					 throw new BuildException(ERROR_NO_FILE + file);
				 }
				 try {
					 schema = FileUtils.getFileUtils().getFileURL(file).toString();
				 }
				 catch (MalformedURLException e) {
					 throw new BuildException(ERROR_NO_URL_REPRESENTATION + file, e);
				 }
			 }
			 return schema;
		 }
		 public String getURIandLocation() throws BuildException {
			 validateNamespace();
			 StringBuffer buffer = new StringBuffer();
			 buffer.append(namespace);
			 buffer.append(' ');
			 buffer.append(getSchemaLocationURL());
			 return new String(buffer);
		 }
		 public void validateNamespace() {
			 if (!isSet(getNamespace())) {
				 throw new BuildException(ERROR_NO_URI);
			 }
		 }
		 private boolean isSet(String property) {
			 return property != null && property.length() != 0;
		 }
		 public boolean equals(Object o) {
			 if (this == o) {
				 return true;
			 }
			 if (!(o instanceof SchemaLocation)) {
				 return false;
			 }
			 final SchemaLocation schemaLocation = (SchemaLocation) o;
			 if (file != null ? !file.equals(schemaLocation.file) : schemaLocation.file != null) {
				 return false;
			 }
			 if (namespace != null ? !namespace.equals(schemaLocation.namespace) : schemaLocation.namespace != null) {
				 return false;
			 }
			 if (url != null ? !url.equals(schemaLocation.url) : schemaLocation.url != null) {
				 return false;
			 }
			 return true;
		 }
		 public int hashCode() {
			 int result;
			 result = (namespace != null ? namespace.hashCode() : 0);
			 result = 29 * result + (file != null ? file.hashCode() : 0);
			 result = 29 * result + (url != null ? url.hashCode() : 0);
			 return result;
		 }
		 public String toString() {
			 StringBuffer buffer = new StringBuffer();
			 buffer.append(namespace != null ? namespace : ""(anonymous)"");
			 buffer.append(' ');
			 buffer.append(url != null ? (url + "" "") : """");
			 buffer.append(file != null ? file.getAbsolutePath() : """");
			 return buffer.toString();
		 }
	 }
 }",0,0,0,0
"private static class ModelFactory {
	public static IGrammarAwareElementType createModelElementType() {
		return new IGrammarAwareElementType(""Model_ELEMENT_TYPE"", Bug299237TestLanguageLanguage.INSTANCE, GRAMMAR_ACCESS.getModelRule());
	}
	public static IGrammarAwareElementType createModel_GroupElementType() {
		return new IGrammarAwareElementType(""Model_Group_ELEMENT_TYPE"", Bug299237TestLanguageLanguage.INSTANCE, GRAMMAR_ACCESS.getModelAccess().getGroup());
	}
	public static IGrammarAwareElementType createModel_ModelKeyword_0ElementType() {
		return new IGrammarAwareElementType(""Model_ModelKeyword_0_ELEMENT_TYPE"", Bug299237TestLanguageLanguage.INSTANCE, GRAMMAR_ACCESS.getModelAccess().getModelKeyword_0());
	}
	public static IGrammarAwareElementType createModel_NameAssignment_1ElementType() {
		return new IGrammarAwareElementType(""Model_NameAssignment_1_ELEMENT_TYPE"", Bug299237TestLanguageLanguage.INSTANCE, GRAMMAR_ACCESS.getModelAccess().getNameAssignment_1());
	}
	public static IGrammarAwareElementType createModel_NameIDTerminalRuleCall_1_0ElementType() {
		return new IGrammarAwareElementType(""Model_NameIDTerminalRuleCall_1_0_ELEMENT_TYPE"", Bug299237TestLanguageLanguage.INSTANCE, GRAMMAR_ACCESS.getModelAccess().getNameIDTerminalRuleCall_1_0());
	}
	public static IGrammarAwareElementType createModel_SemicolonKeyword_2ElementType() {
		return new IGrammarAwareElementType(""Model_SemicolonKeyword_2_ELEMENT_TYPE"", Bug299237TestLanguageLanguage.INSTANCE, GRAMMAR_ACCESS.getModelAccess().getSemicolonKeyword_2());
	}
}",0,0,0,0
"public abstract class AbstractEntitiesRuntimeModule extends DefaultXbaseRuntimeModule {
	protected Properties properties = null;
	public void configure(Binder binder) {
		properties = tryBindProperties(binder, ""org/eclipse/xtext/idea/example/entities/Entities.properties"");
		super.configure(binder);
	}
	public void configureLanguageName(Binder binder) {
		binder.bind(String.class).annotatedWith(Names.named(Constants.LANGUAGE_NAME)).toInstance(""org.eclipse.xtext.idea.example.entities.Entities"");
	}
	public void configureFileExtensions(Binder binder) {
		if (properties == null || properties.getProperty(Constants.FILE_EXTENSIONS) == null)binder.bind(String.class).annotatedWith(Names.named(Constants.FILE_EXTENSIONS)).toInstance(""entities"");
	}
	public ClassLoader bindClassLoaderToInstance() {
		return getClass().getClassLoader();
	}
	public Class<? extends IGrammarAccess> bindIGrammarAccess() {
		return EntitiesGrammarAccess.class;
	}
	public Class<? extends ISemanticSequencer> bindISemanticSequencer() {
		return EntitiesSemanticSequencer.class;
	}
	public Class<? extends ISyntacticSequencer> bindISyntacticSequencer() {
		return EntitiesSyntacticSequencer.class;
	}
	public Class<? extends ISerializer> bindISerializer() {
		return Serializer.class;
	}
	public Class<? extends IParser> bindIParser() {
		return EntitiesParser.class;
	}
	public Class<? extends ITokenToStringConverter> bindITokenToStringConverter() {
		return AntlrTokenToStringConverter.class;
	}
	public Class<? extends IAntlrTokenFileProvider> bindIAntlrTokenFileProvider() {
		return EntitiesAntlrTokenFileProvider.class;
	}
	public Class<? extends Lexer> bindLexer() {
		return InternalEntitiesLexer.class;
	}
	public Class<? extends ITokenDefProvider> bindITokenDefProvider() {
		return AntlrTokenDefProvider.class;
	}
	public Provider<InternalEntitiesLexer> provideInternalEntitiesLexer() {
		return LexerProvider.create(InternalEntitiesLexer.class);
	}
	public void configureRuntimeLexer(Binder binder) {
		binder.bind(Lexer.class).annotatedWith(Names.named(LexerBindings.RUNTIME)).to(InternalEntitiesLexer.class);
	}
	public Class<? extends EntitiesValidator> bindEntitiesValidator() {
		return EntitiesValidator.class;
	}
	public Class<? extends IBatchScopeProvider> bindIBatchScopeProvider() {
		return EntitiesScopeProvider.class;
	}
	public void configureIScopeProviderDelegate(Binder binder) {
		binder.bind(IScopeProvider.class).annotatedWith(Names.named(AbstractDeclarativeScopeProvider.NAMED_DELEGATE)).to(XImportSectionNamespaceScopeProvider.class);
	}
	public void configureIgnoreCaseLinking(Binder binder) {
		binder.bindConstant().annotatedWith(IgnoreCaseLinking.class).to(false);
	}
	public Class<? extends IContainer.Manager> bindIContainer$Manager() {
		return StateBasedContainerManager.class;
	}
	public Class<? extends IAllContainersState.Provider> bindIAllContainersState$Provider() {
		return ResourceSetBasedAllContainersStateProvider.class;
	}
	public void configureIResourceDescriptions(Binder binder) {
		binder.bind(IResourceDescriptions.class).to(ResourceSetBasedResourceDescriptions.class);
	}
	public void configureIResourceDescriptionsPersisted(Binder binder) {
		binder.bind(IResourceDescriptions.class).annotatedWith(Names.named(ResourceDescriptionsProvider.PERSISTED_DESCRIPTIONS)).to(ResourceSetBasedResourceDescriptions.class);
	}
	public Class<? extends IFormatter2> bindIFormatter2() {
		return EntitiesFormatter.class;
	}
	public void configureFormatterPreferences(Binder binder) {
		binder.bind(IPreferenceValuesProvider.class).annotatedWith(FormatterPreferences.class).to(FormatterPreferenceValuesProvider.class);
	}
	public Class<? extends IQualifiedNameProvider> bindIQualifiedNameProvider() {
		return XbaseQualifiedNameProvider.class;
	}
	public Class<? extends ILocationInFileProvider> bindILocationInFileProvider() {
		return JvmLocationInFileProvider.class;
	}
	public Class<? extends IGlobalScopeProvider> bindIGlobalScopeProvider() {
		return TypesAwareDefaultGlobalScopeProvider.class;
	}
	public Class<? extends FeatureNameValidator> bindFeatureNameValidator() {
		return LogicalContainerAwareFeatureNameValidator.class;
	}
	public Class<? extends DefaultBatchTypeResolver> bindDefaultBatchTypeResolver() {
		return LogicalContainerAwareBatchTypeResolver.class;
	}
	public Class<? extends DefaultReentrantTypeResolver> bindDefaultReentrantTypeResolver() {
		return LogicalContainerAwareReentrantTypeResolver.class;
	}
	public Class<? extends IResourceValidator> bindIResourceValidator() {
		return DerivedStateAwareResourceValidator.class;
	}
	public Class<? extends IJvmModelInferrer> bindIJvmModelInferrer() {
		return EntitiesJvmModelInferrer.class;
	}
}",1,0,0,0
"public class SignedSelector extends DataType implements FileSelector {
	 private IsSigned isSigned = new IsSigned();
	 public void setName(String name) {
		 isSigned.setName(name);
	 }
	 public boolean isSelected(File basedir, String filename, File file) {
		 if (file.isDirectory()) {
			 return false;
		 }
		 isSigned.setProject(getProject());
		 isSigned.setFile(file);
		 return isSigned.eval();
	 }
}",0,0,0,0
"public class RSLSettings{
	 public static class RSLAndPolicyFileURLPair {
		 public RSLAndPolicyFileURLPair(String rslURL, String policyFileURL) {
			 this.rslURL = rslURL;
			 this.policyFileURL = policyFileURL;
		 }
		 private String rslURL;
		 private String policyFileURL;
		 public String getRSLURL() {
			 return rslURL;
		 }
		 public String getPolicyFileURL() {
			 return policyFileURL;
		 }
	 }
	 private static final String SIGNED_RSL_URL_EXTENSION = ""swz"";
	 private static final String SIGNED_RSL_URL_DOT_EXTENSION = ""."" + SIGNED_RSL_URL_EXTENSION;
	 public static boolean isSignedRSL(String url) {
		 if (url == null) return false;
		 return url.endsWith(SIGNED_RSL_URL_DOT_EXTENSION);
	 }
	 RSLSettings(IFileSpecification libraryFile) {
		 if (libraryFile == null) throw new NullPointerException(""libraryFile may not be null"");
		 this.libraryFile = new File(libraryFile.getPath());
		 rslURLs = new ArrayList<RSLAndPolicyFileURLPair>();
		 setApplicationDomain(ApplicationDomainTarget.DEFAULT);
		 setVerifyDigest(true);
	 }
	 public RSLSettings(File libraryFile) {
		 if (libraryFile == null) throw new NullPointerException(""libraryFile may not be null"");
		 this.libraryFile = libraryFile;
		 rslURLs = new ArrayList<RSLAndPolicyFileURLPair>();
		 setApplicationDomain(ApplicationDomainTarget.DEFAULT);
		 setVerifyDigest(true);
	 }
	 private File libraryFile;
	 private List<RSLAndPolicyFileURLPair> rslURLs;
	 private ApplicationDomainTarget applicationDomain;
	 private boolean verifyDigest;
	 private boolean forceLoad;
	 public boolean isForceLoad() {
		 return forceLoad;
	 }
	 public void setForceLoad(boolean forceLoad) {
		 this.forceLoad = forceLoad;
	 }
	 public List<RSLAndPolicyFileURLPair> getRSLURLs() {
		 return rslURLs;
	 }
	 public void addRSLURLAndPolicyFileURL(String rslURL, String policyFileURL) {
		 if (rslURL == null) throw new NullPointerException(""rslURL may not be null"");
		 rslURLs.add(new RSLAndPolicyFileURLPair(rslURL, policyFileURL));
	 }
	 public File getLibraryFile() {
		 return libraryFile;
	 }
	 public void setApplicationDomain(ApplicationDomainTarget applicationDomain) {
		 this.applicationDomain = applicationDomain;
	 }
	 public ApplicationDomainTarget getApplicationDomain() {
		 return applicationDomain;
	 }
	 public void setVerifyDigest(boolean verifyDigest) {
		 this.verifyDigest = verifyDigest;
	 }
	 public boolean getVerifyDigest() {
		 return verifyDigest;
	 }
}",1,1,0,0
"private void initComponents() {
	 canvas = new BufferedImage(320, 320, BufferedImage.TYPE_BYTE_GRAY);
	 buttonGroup1 = new ButtonGroup();
	 buttonGroup2 = new ButtonGroup();
	 jPanel4 = new JPanel();
	 jSlider2 = new JSlider();
	 jLabel1 = new JLabel();
	 jPanel2 = new JPanel(new GridBagLayout());
	 JLabel canvasLabel = new JLabel(new ImageIcon(canvas));
	 jPanel2.add(canvasLabel, null);
	 jPanel3 = new JPanel();
	 jRadioButton3 = new JRadioButton();
	 jRadioButton4 = new JRadioButton();
	 jRadioButton5 = new JRadioButton();
	 jRadioButton6 = new JRadioButton();
	 jRadioButton7 = new JRadioButton();
	 jRadioButton8 = new JRadioButton();
	 jButton1 = new JButton();
	 setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
	 setTitle(""FuNet1 --- powered by Neuroph"");
	 jPanel4.setBorder(BorderFactory.createTitledBorder(""Line thickness""));
	 jSlider2.setMajorTickSpacing(10);
	 jSlider2.setMaximum(51);
	 jSlider2.setMinimum(1);
	 jSlider2.setMinorTickSpacing(5);
	 jSlider2.setPaintTicks(true);
	 jSlider2.addChangeListener(new ChangeListener() {
		 public void stateChanged(ChangeEvent evt) {
			 jSlider2StateChanged(evt);
		 }
	 }
	);
	 GroupLayout jPanel4Layout = new GroupLayout(jPanel4);
	 jPanel4.setLayout(jPanel4Layout);
	 jPanel4Layout.setHorizontalGroup( jPanel4Layout.createParallelGroup(GroupLayout.Alignment.LEADING) .addGroup(jPanel4Layout.createSequentialGroup() .addContainerGap() .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.LEADING)) .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, 51, Short.MAX_VALUE) .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.TRAILING) .addComponent(jLabel1) .addComponent(jSlider2, GroupLayout.PREFERRED_SIZE, 150, GroupLayout.PREFERRED_SIZE)) .addContainerGap()) );
	 label = new JLabel("""");
	 Font labelFont = label.getFont();
	 label.setFont(new Font(labelFont.getName(), Font.PLAIN, 30));
	 jPanel4Layout.setVerticalGroup( jPanel4Layout.createParallelGroup(GroupLayout.Alignment.LEADING) .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.TRAILING) .addComponent(jSlider2, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE) .addGroup(jPanel4Layout.createSequentialGroup() .addGroup(jPanel4Layout.createParallelGroup(GroupLayout.Alignment.BASELINE) .addComponent(jLabel1)) .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED)) ));
	 jPanel2.setBackground(new Color(0, 0, 0));
	 jPanel2.setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));
	 canvasLabel.addMouseListener(new MouseAdapter() {
		 public void mousePressed(MouseEvent evt) {
			 jPanel2MousePressed(evt);
		 }
		 public void mouseReleased(MouseEvent evt) {
			 jPanel2MouseReleased(evt);
		 }
	 }
	);
	 canvasLabel.addMouseMotionListener(new MouseMotionAdapter() {
		 public void mouseDragged(MouseEvent evt) {
			 jPanel2MouseDragged(evt);
		 }
	 }
	);
	 jButton1.setText(""Clear"");
	 jButton1.addActionListener(new ActionListener() {
		 public void actionPerformed(ActionEvent evt) {
			 jButton1ActionPerformed(evt);
		 }
	 }
	);
	 GroupLayout layout = new GroupLayout(getContentPane());
	 getContentPane().setLayout(layout);
	 layout.setHorizontalGroup( layout.createParallelGroup(GroupLayout.Alignment.LEADING) .addGroup(layout.createSequentialGroup() .addContainerGap() .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) .addComponent(jPanel2, GroupLayout.Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addGroup(layout.createSequentialGroup() .addComponent(jPanel4, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE) .addPreferredGap(LayoutStyle.ComponentPlacement.UNRELATED) .addComponent(jPanel3, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE) .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED) .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING) .addComponent(jButton1, GroupLayout.DEFAULT_SIZE, 112, Short.MAX_VALUE) .addComponent(label, GroupLayout.DEFAULT_SIZE, 112, Short.MAX_VALUE)))) .addContainerGap()) );
	 layout.setVerticalGroup( layout.createParallelGroup(GroupLayout.Alignment.LEADING) .addGroup(layout.createSequentialGroup() .addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING, false) .addGroup(layout.createSequentialGroup() .addGap(4, 4, 4) .addComponent(jButton1, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE) .addComponent(label, GroupLayout.PREFERRED_SIZE, 30, GroupLayout.PREFERRED_SIZE) .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED)) .addComponent(jPanel4, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addComponent(jPanel3, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)) .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED) .addComponent(jPanel2, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) .addContainerGap()) );
	 Graphics g = canvas.getGraphics();
	 g.setColor(Color.WHITE);
	 g.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());
	 repaint();
	 pack();
 }",0,0,1,0
"public class Interpreter{
	 private static final int Icode_DUP = -1, Icode_DUP2 = -2, Icode_SWAP = -3, Icode_POP = -4, Icode_POP_RESULT = -5, Icode_IFEQ_POP = -6, Icode_VAR_INC_DEC = -7, Icode_NAME_INC_DEC = -8, Icode_PROP_INC_DEC = -9, Icode_ELEM_INC_DEC = -10, Icode_REF_INC_DEC = -11, Icode_SCOPE_LOAD = -12, Icode_SCOPE_SAVE = -13, Icode_TYPEOFNAME = -14, Icode_NAME_AND_THIS = -15, Icode_PROP_AND_THIS = -16, Icode_ELEM_AND_THIS = -17, Icode_VALUE_AND_THIS = -18, Icode_CLOSURE_EXPR = -19, Icode_CLOSURE_STMT = -20, Icode_CALLSPECIAL = -21, Icode_RETUNDEF = -22, Icode_GOSUB = -23, Icode_STARTSUB = -24, Icode_RETSUB = -25, Icode_LINE = -26, Icode_SHORTNUMBER = -27, Icode_INTNUMBER = -28, Icode_LITERAL_NEW = -29, Icode_LITERAL_SET = -30, Icode_SPARE_ARRAYLIT = -31, Icode_REG_IND_C0 = -32, Icode_REG_IND_C1 = -33, Icode_REG_IND_C2 = -34, Icode_REG_IND_C3 = -35, Icode_REG_IND_C4 = -36, Icode_REG_IND_C5 = -37, Icode_REG_IND1 = -38, Icode_REG_IND2 = -39, Icode_REG_IND4 = -40, Icode_REG_STR_C0 = -41, Icode_REG_STR_C1 = -42, Icode_REG_STR_C2 = -43, Icode_REG_STR_C3 = -44, Icode_REG_STR1 = -45, Icode_REG_STR2 = -46, Icode_REG_STR4 = -47, Icode_GETVAR1 = -48, Icode_SETVAR1 = -49, Icode_UNDEF = -50, Icode_ZERO = -51, Icode_ONE = -52, Icode_ENTERDQ = -53, Icode_LEAVEDQ = -54, Icode_TAIL_CALL = -55, Icode_LOCAL_CLEAR = -56, MIN_ICODE = -56;
	 private CompilerEnvirons compilerEnv;
	 private boolean itsInFunctionFlag;
	 private InterpreterData itsData;
	 private ScriptOrFnNode scriptOrFn;
	 private int itsICodeTop;
	 private int itsStackDepth;
	 private int itsLineNumber;
	 private int itsDoubleTableTop;
	 private ObjToIntMap itsStrings = new ObjToIntMap(20);
	 private int itsLocalTop;
	 private static final int MIN_LABEL_TABLE_SIZE = 32;
	 private static final int MIN_FIXUP_TABLE_SIZE = 40;
	 private int[] itsLabelTable;
	 private int itsLabelTableTop;
	 private long[] itsFixupTable;
	 private int itsFixupTableTop;
	 private ObjArray itsLiteralIds = new ObjArray();
	 private int itsExceptionTableTop;
	 private static final int EXCEPTION_TRY_START_SLOT = 0;
	 private static final int EXCEPTION_TRY_END_SLOT = 1;
	 private static final int EXCEPTION_HANDLER_SLOT = 2;
	 private static final int EXCEPTION_TYPE_SLOT = 3;
	 private static final int EXCEPTION_LOCAL_SLOT = 4;
	 private static final int EXCEPTION_SCOPE_SLOT = 5;
	 private static final int EXCEPTION_SLOT_SIZE = 6;
	 private static final int ECF_TAIL = 1 << 0;
	 private static class CallFrame implements Cloneable, Serializable {
		 static final long serialVersionUID = -2843792508994958978L;
		 CallFrame parentFrame;
		 int frameIndex;
		 boolean frozen;
		 InterpretedFunction fnOrScript;
		 InterpreterData idata;
		 Object[] stack;
		 double[] sDbl;
		 CallFrame varSource;
		 int localShift;
		 int emptyStackTop;
		 DebugFrame debuggerFrame;
		 boolean useActivation;
		 Scriptable thisObj;
		 Scriptable[] scriptRegExps;
		 Object result;
		 double resultDbl;
		 int pc;
		 int pcPrevBranch;
		 int pcSourceLineStart;
		 Scriptable scope;
		 int savedStackTop;
		 int savedCallOp;
		 CallFrame cloneFrozen() {
			 if (!frozen) Kit.codeBug();
			 CallFrame copy;
			 try {
				 copy = (CallFrame)clone();
			 }
			 catch (CloneNotSupportedException ex) {
				 throw new IllegalStateException();
			 }
			 copy.stack = (Object[])stack.clone();
			 copy.sDbl = (double[])sDbl.clone();
			 copy.frozen = false;
			 return copy;
		 }
	 }
	 private static final class ContinuationJump implements Serializable {
		 static final long serialVersionUID = 7687739156004308247L;
		 CallFrame capturedFrame;
		 CallFrame branchFrame;
		 Object result;
		 double resultDbl;
		 ContinuationJump(Continuation c, CallFrame current) {
			 this.capturedFrame = (CallFrame)c.getImplementation();
			 if (this.capturedFrame == null || current == null) {
				 this.branchFrame = null;
			 }
			 else {
				 CallFrame chain1 = this.capturedFrame;
				 CallFrame chain2 = current;
				 int diff = chain1.frameIndex - chain2.frameIndex;
				 if (diff != 0) {
					 if (diff < 0) {
						 chain1 = current;
						 chain2 = this.capturedFrame;
						 diff = -diff;
					 }
					 do {
						 chain1 = chain1.parentFrame;
					 }
					 while (--diff != 0);
					 if (chain1.frameIndex != chain2.frameIndex) Kit.codeBug();
				 }
				 while (chain1 != chain2 && chain1 != null) {
					 chain1 = chain1.parentFrame;
					 chain2 = chain2.parentFrame;
				 }
				 this.branchFrame = chain1;
				 if (this.branchFrame != null && !this.branchFrame.frozen) Kit.codeBug();
			 }
		 }
	 }
	 static {
		 if (Token.LAST_BYTECODE_TOKEN > 127) {
			 String str = ""Violation of Token.LAST_BYTECODE_TOKEN <= 127"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
		 if (MIN_ICODE < -128) {
			 String str = ""Violation of Interpreter.MIN_ICODE >= -128"";
			 System.err.println(str);
			 throw new IllegalStateException(str);
		 }
	 }
	 private static String bytecodeName(int bytecode) {
		 if (!validBytecode(bytecode)) {
			 throw new IllegalArgumentException(String.valueOf(bytecode));
		 }
		 if (!Token.printICode) {
			 return String.valueOf(bytecode);
		 }
		 if (validTokenCode(bytecode)) {
			 return Token.name(bytecode);
		 }
		 switch (bytecode) {
			 case Icode_DUP: return ""DUP"";
			 case Icode_DUP2: return ""DUP2"";
			 case Icode_SWAP: return ""SWAP"";
			 case Icode_POP: return ""POP"";
			 case Icode_POP_RESULT: return ""POP_RESULT"";
			 case Icode_IFEQ_POP: return ""IFEQ_POP"";
			 case Icode_VAR_INC_DEC: return ""VAR_INC_DEC"";
			 case Icode_NAME_INC_DEC: return ""NAME_INC_DEC"";
			 case Icode_PROP_INC_DEC: return ""PROP_INC_DEC"";
			 case Icode_ELEM_INC_DEC: return ""ELEM_INC_DEC"";
			 case Icode_REF_INC_DEC: return ""REF_INC_DEC"";
			 case Icode_SCOPE_LOAD: return ""SCOPE_LOAD"";
			 case Icode_SCOPE_SAVE: return ""SCOPE_SAVE"";
			 case Icode_TYPEOFNAME: return ""TYPEOFNAME"";
			 case Icode_NAME_AND_THIS: return ""NAME_AND_THIS"";
			 case Icode_PROP_AND_THIS: return ""PROP_AND_THIS"";
			 case Icode_ELEM_AND_THIS: return ""ELEM_AND_THIS"";
			 case Icode_VALUE_AND_THIS: return ""VALUE_AND_THIS"";
			 case Icode_CLOSURE_EXPR: return ""CLOSURE_EXPR"";
			 case Icode_CLOSURE_STMT: return ""CLOSURE_STMT"";
			 case Icode_CALLSPECIAL: return ""CALLSPECIAL"";
			 case Icode_RETUNDEF: return ""RETUNDEF"";
			 case Icode_GOSUB: return ""GOSUB"";
			 case Icode_STARTSUB: return ""STARTSUB"";
			 case Icode_RETSUB: return ""RETSUB"";
			 case Icode_LINE: return ""LINE"";
			 case Icode_SHORTNUMBER: return ""SHORTNUMBER"";
			 case Icode_INTNUMBER: return ""INTNUMBER"";
			 case Icode_LITERAL_NEW: return ""LITERAL_NEW"";
			 case Icode_LITERAL_SET: return ""LITERAL_SET"";
			 case Icode_SPARE_ARRAYLIT: return ""SPARE_ARRAYLIT"";
			 case Icode_REG_IND_C0: return ""REG_IND_C0"";
			 case Icode_REG_IND_C1: return ""REG_IND_C1"";
			 case Icode_REG_IND_C2: return ""REG_IND_C2"";
			 case Icode_REG_IND_C3: return ""REG_IND_C3"";
			 case Icode_REG_IND_C4: return ""REG_IND_C4"";
			 case Icode_REG_IND_C5: return ""REG_IND_C5"";
			 case Icode_REG_IND1: return ""LOAD_IND1"";
			 case Icode_REG_IND2: return ""LOAD_IND2"";
			 case Icode_REG_IND4: return ""LOAD_IND4"";
			 case Icode_REG_STR_C0: return ""REG_STR_C0"";
			 case Icode_REG_STR_C1: return ""REG_STR_C1"";
			 case Icode_REG_STR_C2: return ""REG_STR_C2"";
			 case Icode_REG_STR_C3: return ""REG_STR_C3"";
			 case Icode_REG_STR1: return ""LOAD_STR1"";
			 case Icode_REG_STR2: return ""LOAD_STR2"";
			 case Icode_REG_STR4: return ""LOAD_STR4"";
			 case Icode_GETVAR1: return ""GETVAR1"";
			 case Icode_SETVAR1: return ""SETVAR1"";
			 case Icode_UNDEF: return ""UNDEF"";
			 case Icode_ZERO: return ""ZERO"";
			 case Icode_ONE: return ""ONE"";
			 case Icode_ENTERDQ: return ""ENTERDQ"";
			 case Icode_LEAVEDQ: return ""LEAVEDQ"";
			 case Icode_TAIL_CALL: return ""TAIL_CALL"";
			 case Icode_LOCAL_CLEAR: return ""LOCAL_CLEAR"";
		 }
		 throw new IllegalStateException(String.valueOf(bytecode));
	 }
	 private static boolean validIcode(int icode) {
		 return MIN_ICODE <= icode && icode <= -1;
	 }
	 private static boolean validTokenCode(int token) {
		 return Token.FIRST_BYTECODE_TOKEN <= token && token <= Token.LAST_BYTECODE_TOKEN;
	 }
	 private static boolean validBytecode(int bytecode) {
		 return validIcode(bytecode) || validTokenCode(bytecode);
	 }
	 public Object compile(CompilerEnvirons compilerEnv, ScriptOrFnNode tree, String encodedSource, boolean returnFunction) {
		 this.compilerEnv = compilerEnv;
		 new NodeTransformer().transform(tree);
		 if (Token.printTrees) {
			 System.out.println(tree.toStringTree(tree));
		 }
		 if (returnFunction) {
			 tree = tree.getFunctionNode(0);
		 }
		 scriptOrFn = tree;
		 itsData = new InterpreterData(compilerEnv.getLanguageVersion(), scriptOrFn.getSourceName(), encodedSource);
		 itsData.topLevel = true;
		 if (returnFunction) {
			 generateFunctionICode();
		 }
		 else {
			 generateICodeFromTree(scriptOrFn);
		 }
		 return itsData;
	 }
	 public Script createScriptObject(Object bytecode, Object staticSecurityDomain) {
		 if(bytecode != itsData) {
			 Kit.codeBug();
		 }
		 return InterpretedFunction.createScript(itsData, staticSecurityDomain);
	 }
	 public Function createFunctionObject(Context cx, Scriptable scope, Object bytecode, Object staticSecurityDomain) {
		 if(bytecode != itsData) {
			 Kit.codeBug();
		 }
		 return InterpretedFunction.createFunction(cx, scope, itsData, staticSecurityDomain);
	 }
	 private void generateFunctionICode() {
		 itsInFunctionFlag = true;
		 FunctionNode theFunction = (FunctionNode)scriptOrFn;
		 itsData.itsFunctionType = theFunction.getFunctionType();
		 itsData.itsNeedsActivation = theFunction.requiresActivation();
		 itsData.itsName = theFunction.getFunctionName();
		 if (!theFunction.getIgnoreDynamicScope()) {
			 if (compilerEnv.isUseDynamicScope()) {
				 itsData.useDynamicScope = true;
			 }
		 }
		 generateICodeFromTree(theFunction.getLastChild());
	 }
	 private void generateICodeFromTree(Node tree) {
		 generateNestedFunctions();
		 generateRegExpLiterals();
		 visitStatement(tree);
		 fixLabelGotos();
		 if (itsData.itsFunctionType == 0) {
			 addToken(Token.RETURN_RESULT);
		 }
		 if (itsData.itsICode.length != itsICodeTop) {
			 byte[] tmp = new byte[itsICodeTop];
			 System.arraycopy(itsData.itsICode, 0, tmp, 0, itsICodeTop);
			 itsData.itsICode = tmp;
		 }
		 if (itsStrings.size() == 0) {
			 itsData.itsStringTable = null;
		 }
		 else {
			 itsData.itsStringTable = new String[itsStrings.size()];
			 ObjToIntMap.Iterator iter = itsStrings.newIterator();
			 for (iter.start();
			 !iter.done();
			 iter.next()) {
				 String str = (String)iter.getKey();
				 int index = iter.getValue();
				 if (itsData.itsStringTable[index] != null) Kit.codeBug();
				 itsData.itsStringTable[index] = str;
			 }
		 }
		 if (itsDoubleTableTop == 0) {
			 itsData.itsDoubleTable = null;
		 }
		 else if (itsData.itsDoubleTable.length != itsDoubleTableTop) {
			 double[] tmp = new double[itsDoubleTableTop];
			 System.arraycopy(itsData.itsDoubleTable, 0, tmp, 0, itsDoubleTableTop);
			 itsData.itsDoubleTable = tmp;
		 }
		 if (itsExceptionTableTop != 0 && itsData.itsExceptionTable.length != itsExceptionTableTop) {
			 int[] tmp = new int[itsExceptionTableTop];
			 System.arraycopy(itsData.itsExceptionTable, 0, tmp, 0, itsExceptionTableTop);
			 itsData.itsExceptionTable = tmp;
		 }
		 itsData.itsMaxVars = scriptOrFn.getParamAndVarCount();
		 itsData.itsMaxFrameArray = itsData.itsMaxVars + itsData.itsMaxLocals + itsData.itsMaxStack;
		 itsData.argNames = scriptOrFn.getParamAndVarNames();
		 itsData.argCount = scriptOrFn.getParamCount();
		 itsData.encodedSourceStart = scriptOrFn.getEncodedSourceStart();
		 itsData.encodedSourceEnd = scriptOrFn.getEncodedSourceEnd();
		 if (itsLiteralIds.size() != 0) {
			 itsData.literalIds = itsLiteralIds.toArray();
		 }
		 if (Token.printICode) dumpICode(itsData);
	 }
	 private void generateNestedFunctions() {
		 int functionCount = scriptOrFn.getFunctionCount();
		 if (functionCount == 0) return;
		 InterpreterData[] array = new InterpreterData[functionCount];
		 for (int i = 0;
		 i != functionCount;
		 i++) {
			 FunctionNode def = scriptOrFn.getFunctionNode(i);
			 Interpreter jsi = new Interpreter();
			 jsi.compilerEnv = compilerEnv;
			 jsi.scriptOrFn = def;
			 jsi.itsData = new InterpreterData(itsData);
			 jsi.generateFunctionICode();
			 array[i] = jsi.itsData;
		 }
		 itsData.itsNestedFunctions = array;
	 }
	 private void generateRegExpLiterals() {
		 int N = scriptOrFn.getRegexpCount();
		 if (N == 0) return;
		 Context cx = Context.getContext();
		 RegExpProxy rep = ScriptRuntime.checkRegExpProxy(cx);
		 Object[] array = new Object[N];
		 for (int i = 0;
		 i != N;
		 i++) {
			 String string = scriptOrFn.getRegexpString(i);
			 String flags = scriptOrFn.getRegexpFlags(i);
			 array[i] = rep.compileRegExp(cx, string, flags);
		 }
		 itsData.itsRegExpLiterals = array;
	 }
	 private void updateLineNumber(Node node) {
		 int lineno = node.getLineno();
		 if (lineno != itsLineNumber && lineno >= 0) {
			 if (itsData.firstLinePC < 0) {
				 itsData.firstLinePC = lineno;
			 }
			 itsLineNumber = lineno;
			 addIcode(Icode_LINE);
			 addUint16(lineno & 0xFFFF);
		 }
	 }
	 private RuntimeException badTree(Node node) {
		 throw new RuntimeException(node.toString());
	 }
	 private void visitStatement(Node node) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 int fnType = scriptOrFn.getFunctionNode(fnIndex). getFunctionType();
				 if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {
					 addIndexOp(Icode_CLOSURE_STMT, fnIndex);
				 }
				 else {
					 if (fnType != FunctionNode.FUNCTION_STATEMENT) {
						 throw Kit.codeBug();
					 }
				 }
			 }
			 break;
			 case Token.SCRIPT: case Token.LABEL: case Token.LOOP: case Token.BLOCK: case Token.EMPTY: case Token.WITH: updateLineNumber(node);
			 while (child != null) {
				 visitStatement(child);
				 child = child.getNext();
			 }
			 break;
			 case Token.ENTERWITH: visitExpression(child, 0);
			 addToken(Token.ENTERWITH);
			 stackChange(-1);
			 break;
			 case Token.LEAVEWITH: addToken(Token.LEAVEWITH);
			 break;
			 case Token.LOCAL_BLOCK: {
				 int local = allocLocal();
				 node.putIntProp(Node.LOCAL_PROP, local);
				 updateLineNumber(node);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, local);
				 releaseLocal(local);
			 }
			 break;
			 case Token.SWITCH: updateLineNumber(node);
			 {
				 visitExpression(child, 0);
				 for (Node.Jump caseNode = (Node.Jump)child.getNext();
				 caseNode != null;
				 caseNode = (Node.Jump)caseNode.getNext()) {
					 if (caseNode.getType() != Token.CASE) throw badTree(caseNode);
					 Node test = caseNode.getFirstChild();
					 addIcode(Icode_DUP);
					 stackChange(1);
					 visitExpression(test, 0);
					 addToken(Token.SHEQ);
					 stackChange(-1);
					 addGoto(caseNode.target, Icode_IFEQ_POP);
					 stackChange(-1);
				 }
				 addIcode(Icode_POP);
				 stackChange(-1);
			 }
			 break;
			 case Token.TARGET: markTargetLabel(node);
			 break;
			 case Token.IFEQ : case Token.IFNE : {
				 Node target = ((Node.Jump)node).target;
				 visitExpression(child, 0);
				 addGoto(target, type);
				 stackChange(-1);
			 }
			 break;
			 case Token.GOTO: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, type);
			 }
			 break;
			 case Token.JSR: {
				 Node target = ((Node.Jump)node).target;
				 addGoto(target, Icode_GOSUB);
			 }
			 break;
			 case Token.FINALLY: {
				 stackChange(1);
				 int finallyRegister = getLocalBlockRef(node);
				 addIndexOp(Icode_STARTSUB, finallyRegister);
				 stackChange(-1);
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 addIndexOp(Icode_RETSUB, finallyRegister);
			 }
			 break;
			 case Token.EXPR_VOID: case Token.EXPR_RESULT: updateLineNumber(node);
			 visitExpression(child, 0);
			 addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);
			 stackChange(-1);
			 break;
			 case Token.TRY: {
				 Node.Jump tryNode = (Node.Jump)node;
				 int exceptionObjectLocal = getLocalBlockRef(tryNode);
				 int scopeLocal = allocLocal();
				 addIndexOp(Icode_SCOPE_SAVE, scopeLocal);
				 int tryStart = itsICodeTop;
				 while (child != null) {
					 visitStatement(child);
					 child = child.getNext();
				 }
				 Node catchTarget = tryNode.target;
				 if (catchTarget != null) {
					 int catchStartPC = itsLabelTable[getTargetLabel(catchTarget)];
					 addExceptionHandler( tryStart, catchStartPC, catchStartPC, false, exceptionObjectLocal, scopeLocal);
				 }
				 Node finallyTarget = tryNode.getFinally();
				 if (finallyTarget != null) {
					 int finallyStartPC = itsLabelTable[getTargetLabel(finallyTarget)];
					 addExceptionHandler( tryStart, finallyStartPC, finallyStartPC, true, exceptionObjectLocal, scopeLocal);
				 }
				 addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);
				 releaseLocal(scopeLocal);
			 }
			 break;
			 case Token.CATCH_SCOPE: {
				 int localIndex = getLocalBlockRef(node);
				 int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringPrefix(name);
				 addIndexPrefix(localIndex);
				 addToken(Token.CATCH_SCOPE);
				 addUint8(scopeIndex != 0 ? 1 : 0);
				 stackChange(-1);
			 }
			 break;
			 case Token.THROW: updateLineNumber(node);
			 visitExpression(child, 0);
			 addToken(Token.THROW);
			 addUint16(itsLineNumber & 0xFFFF);
			 stackChange(-1);
			 break;
			 case Token.RETHROW: updateLineNumber(node);
			 addIndexOp(Token.RETHROW, getLocalBlockRef(node));
			 break;
			 case Token.RETURN: updateLineNumber(node);
			 if (child != null) {
				 visitExpression(child, ECF_TAIL);
				 addToken(Token.RETURN);
				 stackChange(-1);
			 }
			 else {
				 addIcode(Icode_RETUNDEF);
			 }
			 break;
			 case Token.RETURN_RESULT: updateLineNumber(node);
			 addToken(Token.RETURN_RESULT);
			 break;
			 case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES : visitExpression(child, 0);
			 addIndexOp(type, getLocalBlockRef(node));
			 stackChange(-1);
			 break;
			 default: throw badTree(node);
		 }
		 if (itsStackDepth != 0) {
			 throw Kit.codeBug();
		 }
	 }
	 private void visitExpression(Node node, int contextFlags) {
		 int type = node.getType();
		 Node child = node.getFirstChild();
		 int savedStackDepth = itsStackDepth;
		 switch (type) {
			 case Token.FUNCTION: {
				 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
				 FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);
				 if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {
					 throw Kit.codeBug();
				 }
				 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.LOCAL_LOAD: {
				 int localIndex = getLocalBlockRef(node);
				 addIndexOp(Token.LOCAL_LOAD, localIndex);
				 stackChange(1);
			 }
			 break;
			 case Token.COMMA: {
				 Node lastChild = node.getLastChild();
				 while (child != lastChild) {
					 visitExpression(child, 0);
					 addIcode(Icode_POP);
					 stackChange(-1);
					 child = child.getNext();
				 }
				 visitExpression(child, contextFlags & ECF_TAIL);
			 }
			 break;
			 case Token.USE_STACK: stackChange(1);
			 break;
			 case Token.REF_CALL: case Token.CALL: case Token.NEW: {
				 if (type == Token.NEW) {
					 visitExpression(child, 0);
				 }
				 else {
					 generateCallFunAndThis(child);
				 }
				 int argCount = 0;
				 while ((child = child.getNext()) != null) {
					 visitExpression(child, 0);
					 ++argCount;
				 }
				 int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL);
				 if (callType != Node.NON_SPECIALCALL) {
					 addIndexOp(Icode_CALLSPECIAL, argCount);
					 addUint8(callType);
					 addUint8(type == Token.NEW ? 1 : 0);
					 addUint16(itsLineNumber & 0xFFFF);
				 }
				 else {
					 if (type == Token.CALL) {
						 if ((contextFlags & ECF_TAIL) != 0) {
							 type = Icode_TAIL_CALL;
						 }
					 }
					 addIndexOp(type, argCount);
				 }
				 if (type == Token.NEW) {
					 stackChange(-argCount);
				 }
				 else {
					 stackChange(-1 - argCount);
				 }
				 if (argCount > itsData.itsMaxCalleeArgs) {
					 itsData.itsMaxCalleeArgs = argCount;
				 }
			 }
			 break;
			 case Token.AND: case Token.OR: {
				 visitExpression(child, 0);
				 addIcode(Icode_DUP);
				 stackChange(1);
				 int afterSecondJumpStart = itsICodeTop;
				 int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;
				 addGotoOp(jump);
				 stackChange(-1);
				 addIcode(Icode_POP);
				 stackChange(-1);
				 child = child.getNext();
				 visitExpression(child, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterSecondJumpStart);
			 }
			 break;
			 case Token.HOOK: {
				 Node ifThen = child.getNext();
				 Node ifElse = ifThen.getNext();
				 visitExpression(child, 0);
				 int elseJumpStart = itsICodeTop;
				 addGotoOp(Token.IFNE);
				 stackChange(-1);
				 visitExpression(ifThen, contextFlags & ECF_TAIL);
				 int afterElseJumpStart = itsICodeTop;
				 addGotoOp(Token.GOTO);
				 resolveForwardGoto(elseJumpStart);
				 itsStackDepth = savedStackDepth;
				 visitExpression(ifElse, contextFlags & ECF_TAIL);
				 resolveForwardGoto(afterElseJumpStart);
			 }
			 break;
			 case Token.GETPROP: visitExpression(child, 0);
			 child = child.getNext();
			 addStringOp(Token.GETPROP, child.getString());
			 break;
			 case Token.GETELEM: case Token.DELPROP: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 addToken(type);
			 stackChange(-1);
			 break;
			 case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0);
			 if (type == Token.VOID) {
				 addIcode(Icode_POP);
				 addIcode(Icode_UNDEF);
			 }
			 else {
				 addToken(type);
			 }
			 break;
			 case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0);
			 addToken(type);
			 break;
			 case Token.SETPROP: case Token.SETPROP_OP: {
				 visitExpression(child, 0);
				 child = child.getNext();
				 String property = child.getString();
				 child = child.getNext();
				 if (type == Token.SETPROP_OP) {
					 addIcode(Icode_DUP);
					 stackChange(1);
					 addStringOp(Token.GETPROP, property);
					 stackChange(-1);
				 }
				 visitExpression(child, 0);
				 addStringOp(Token.SETPROP, property);
				 stackChange(-1);
			 }
			 break;
			 case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0);
			 child = child.getNext();
			 visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SETELEM_OP) {
				 addIcode(Icode_DUP2);
				 stackChange(2);
				 addToken(Token.GETELEM);
				 stackChange(-1);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SETELEM);
			 stackChange(-2);
			 break;
			 case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0);
			 child = child.getNext();
			 if (type == Token.SET_REF_OP) {
				 addIcode(Icode_DUP);
				 stackChange(1);
				 addToken(Token.GET_REF);
				 stackChange(-1);
			 }
			 visitExpression(child, 0);
			 addToken(Token.SET_REF);
			 stackChange(-1);
			 break;
			 case Token.SETNAME: {
				 String name = child.getString();
				 visitExpression(child, 0);
				 child = child.getNext();
				 visitExpression(child, 0);
				 addStringOp(Token.SETNAME, name);
				 stackChange(-1);
			 }
			 break;
			 case Token.TYPEOFNAME: {
				 String name = node.getString();
				 int index = -1;
				 if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getParamOrVarIndex(name);
				 if (index == -1) {
					 addStringOp(Icode_TYPEOFNAME, name);
					 stackChange(1);
				 }
				 else {
					 addVarOp(Token.GETVAR, index);
					 stackChange(1);
					 addToken(Token.TYPEOF);
				 }
			 }
			 break;
			 case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString());
			 stackChange(1);
			 break;
			 case Token.INC: case Token.DEC: visitIncDec(node, child);
			 break;
			 case Token.NUMBER: {
				 double num = node.getDouble();
				 int inum = (int)num;
				 if (inum == num) {
					 if (inum == 0) {
						 addIcode(Icode_ZERO);
						 if (1.0 / num < 0.0) {
							 addToken(Token.NEG);
						 }
					 }
					 else if (inum == 1) {
						 addIcode(Icode_ONE);
					 }
					 else if ((short)inum == inum) {
						 addIcode(Icode_SHORTNUMBER);
						 addUint16(inum & 0xFFFF);
					 }
					 else {
						 addIcode(Icode_INTNUMBER);
						 addInt(inum);
					 }
				 }
				 else {
					 int index = getDoubleIndex(num);
					 addIndexOp(Token.NUMBER, index);
				 }
				 stackChange(1);
			 }
			 break;
			 case Token.GETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = node.getString();
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.GETVAR, index);
				 stackChange(1);
			 }
			 break;
			 case Token.SETVAR: {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 child = child.getNext();
				 visitExpression(child, 0);
				 int index = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Token.SETVAR, index);
			 }
			 break;
			 case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type);
			 stackChange(1);
			 break;
			 case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node));
			 stackChange(1);
			 break;
			 case Token.REGEXP: {
				 int index = node.getExistingIntProp(Node.REGEXP_PROP);
				 addIndexOp(Token.REGEXP, index);
				 stackChange(1);
			 }
			 break;
			 case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child);
			 break;
			 case Token.REF_SPECIAL: visitExpression(child, 0);
			 addStringOp(type, (String)node.getProp(Node.NAME_PROP));
			 break;
			 case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: {
				 int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);
				 int childCount = 0;
				 do {
					 visitExpression(child, 0);
					 ++childCount;
					 child = child.getNext();
				 }
				 while (child != null);
				 addIndexOp(type, memberTypeFlags);
				 stackChange(1 - childCount);
			 }
			 break;
			 case Token.DOTQUERY: {
				 int queryPC;
				 updateLineNumber(node);
				 visitExpression(child, 0);
				 addIcode(Icode_ENTERDQ);
				 stackChange(-1);
				 queryPC = itsICodeTop;
				 visitExpression(child.getNext(), 0);
				 addBackwardGoto(Icode_LEAVEDQ, queryPC);
			 }
			 break;
			 case Token.DEFAULTNAMESPACE : case Token.ESCXMLATTR : case Token.ESCXMLTEXT : visitExpression(child, 0);
			 addToken(type);
			 break;
			 default: throw badTree(node);
		 }
		 if (savedStackDepth + 1 != itsStackDepth) {
			 Kit.codeBug();
		 }
	 }
	 private void generateCallFunAndThis(Node left) {
		 int type = left.getType();
		 switch (type) {
			 case Token.NAME: {
				 String name = left.getString();
				 addStringOp(Icode_NAME_AND_THIS, name);
				 stackChange(2);
				 break;
			 }
			 case Token.GETPROP: case Token.GETELEM: {
				 Node target = left.getFirstChild();
				 visitExpression(target, 0);
				 Node id = target.getNext();
				 if (type == Token.GETPROP) {
					 String property = id.getString();
					 addStringOp(Icode_PROP_AND_THIS, property);
					 stackChange(1);
				 }
				 else {
					 visitExpression(id, 0);
					 addIcode(Icode_ELEM_AND_THIS);
				 }
				 break;
			 }
			 default: visitExpression(left, 0);
			 addIcode(Icode_VALUE_AND_THIS);
			 stackChange(1);
			 break;
		 }
	 }
	 private void visitIncDec(Node node, Node child) {
		 int incrDecrMask = node.getExistingIntProp(Node.INCRDECR_PROP);
		 int childType = child.getType();
		 switch (childType) {
			 case Token.GETVAR : {
				 if (itsData.itsNeedsActivation) Kit.codeBug();
				 String name = child.getString();
				 int i = scriptOrFn.getParamOrVarIndex(name);
				 addVarOp(Icode_VAR_INC_DEC, i);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.NAME : {
				 String name = child.getString();
				 addStringOp(Icode_NAME_INC_DEC, name);
				 addUint8(incrDecrMask);
				 stackChange(1);
				 break;
			 }
			 case Token.GETPROP : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 String property = object.getNext().getString();
				 addStringOp(Icode_PROP_INC_DEC, property);
				 addUint8(incrDecrMask);
				 break;
			 }
			 case Token.GETELEM : {
				 Node object = child.getFirstChild();
				 visitExpression(object, 0);
				 Node index = object.getNext();
				 visitExpression(index, 0);
				 addIcode(Icode_ELEM_INC_DEC);
				 addUint8(incrDecrMask);
				 stackChange(-1);
				 break;
			 }
			 case Token.GET_REF : {
				 Node ref = child.getFirstChild();
				 visitExpression(ref, 0);
				 addIcode(Icode_REF_INC_DEC);
				 addUint8(incrDecrMask);
				 break;
			 }
			 default : {
				 throw badTree(node);
			 }
		 }
	 }
	 private void visitLiteral(Node node, Node child) {
		 int type = node.getType();
		 int count;
		 Object[] propertyIds = null;
		 if (type == Token.ARRAYLIT) {
			 count = 0;
			 for (Node n = child;
			 n != null;
			 n = n.getNext()) {
				 ++count;
			 }
		 }
		 else if (type == Token.OBJECTLIT) {
			 propertyIds = (Object[])node.getProp(Node.OBJECT_IDS_PROP);
			 count = propertyIds.length;
		 }
		 else {
			 throw badTree(node);
		 }
		 addIndexOp(Icode_LITERAL_NEW, count);
		 stackChange(1);
		 while (child != null) {
			 visitExpression(child, 0);
			 addIcode(Icode_LITERAL_SET);
			 stackChange(-1);
			 child = child.getNext();
		 }
		 if (type == Token.ARRAYLIT) {
			 int[] skipIndexes = (int[])node.getProp(Node.SKIP_INDEXES_PROP);
			 if (skipIndexes == null) {
				 addToken(Token.ARRAYLIT);
			 }
			 else {
				 int index = itsLiteralIds.size();
				 itsLiteralIds.add(skipIndexes);
				 addIndexOp(Icode_SPARE_ARRAYLIT, index);
			 }
		 }
		 else {
			 int index = itsLiteralIds.size();
			 itsLiteralIds.add(propertyIds);
			 addIndexOp(Token.OBJECTLIT, index);
		 }
	 }
	 private int getLocalBlockRef(Node node) {
		 Node localBlock = (Node)node.getProp(Node.LOCAL_BLOCK_PROP);
		 return localBlock.getExistingIntProp(Node.LOCAL_PROP);
	 }
	 private int getTargetLabel(Node target) {
		 int label = target.labelId();
		 if (label != -1) {
			 return label;
		 }
		 label = itsLabelTableTop;
		 if (itsLabelTable == null || label == itsLabelTable.length) {
			 if (itsLabelTable == null) {
				 itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];
			 }
			else {
				 int[] tmp = new int[itsLabelTable.length * 2];
				 System.arraycopy(itsLabelTable, 0, tmp, 0, label);
				 itsLabelTable = tmp;
			 }
		 }
		 itsLabelTableTop = label + 1;
		 itsLabelTable[label] = -1;
		 target.labelId(label);
		 return label;
	 }
	 private void markTargetLabel(Node target) {
		 int label = getTargetLabel(target);
		 if (itsLabelTable[label] != -1) {
			 Kit.codeBug();
		 }
		 itsLabelTable[label] = itsICodeTop;
	 }
	 private void addGoto(Node target, int gotoOp) {
		 int label = getTargetLabel(target);
		 if (!(label < itsLabelTableTop)) Kit.codeBug();
		 int targetPC = itsLabelTable[label];
		 if (targetPC != -1) {
			 addBackwardGoto(gotoOp, targetPC);
		 }
		 else {
			 int gotoPC = itsICodeTop;
			 addGotoOp(gotoOp);
			 int top = itsFixupTableTop;
			 if (itsFixupTable == null || top == itsFixupTable.length) {
				 if (itsFixupTable == null) {
					 itsFixupTable = new long[MIN_FIXUP_TABLE_SIZE];
				 }
				 else {
					 long[] tmp = new long[itsFixupTable.length * 2];
					 System.arraycopy(itsFixupTable, 0, tmp, 0, top);
					 itsFixupTable = tmp;
				 }
			 }
			 itsFixupTableTop = top + 1;
			 itsFixupTable[top] = ((long)label << 32) | gotoPC;
		 }
	 }
	 private void fixLabelGotos() {
		 for (int i = 0;
		 i < itsFixupTableTop;
		 i++) {
			 long fixup = itsFixupTable[i];
			 int label = (int)(fixup >> 32);
			 int jumpSource = (int)fixup;
			 int pc = itsLabelTable[label];
			 if (pc == -1) {
				 throw Kit.codeBug();
			 }
			 resolveGoto(jumpSource, pc);
		 }
		 itsFixupTableTop = 0;
	 }
	 private void addBackwardGoto(int gotoOp, int jumpPC) {
		 int fromPC = itsICodeTop;
		 if (fromPC <= jumpPC) throw Kit.codeBug();
		 addGotoOp(gotoOp);
		 resolveGoto(fromPC, jumpPC);
	 }
	 private void resolveForwardGoto(int fromPC) {
		 if (itsICodeTop < fromPC + 3) throw Kit.codeBug();
		 resolveGoto(fromPC, itsICodeTop);
	 }
	 private void resolveGoto(int fromPC, int jumpPC) {
		 int offset = jumpPC - fromPC;
		 if (0 <= offset && offset <= 2) throw Kit.codeBug();
		 int offsetSite = fromPC + 1;
		 if (offset != (short)offset) {
			 if (itsData.longJumps == null) {
				 itsData.longJumps = new UintMap();
			 }
			 itsData.longJumps.put(offsetSite, jumpPC);
			 offset = 0;
		 }
		 byte[] array = itsData.itsICode;
		 array[offsetSite] = (byte)(offset >> 8);
		 array[offsetSite + 1] = (byte)offset;
	 }
	 private void addToken(int token) {
		 if (!validTokenCode(token)) throw Kit.codeBug();
		 addUint8(token);
	 }
	 private void addIcode(int icode) {
		 if (!validIcode(icode)) throw Kit.codeBug();
		 addUint8(icode & 0xFF);
	 }
	 private void addUint8(int value) {
		 if ((value & ~0xFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top == array.length) {
			 array = increaseICodeCapasity(1);
		 }
		 array[top] = (byte)value;
		 itsICodeTop = top + 1;
	 }
	 private void addUint16(int value) {
		 if ((value & ~0xFFFF) != 0) throw Kit.codeBug();
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 2 > array.length) {
			 array = increaseICodeCapasity(2);
		 }
		 array[top] = (byte)(value >>> 8);
		 array[top + 1] = (byte)value;
		 itsICodeTop = top + 2;
	 }
	 private void addInt(int i) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 4 > array.length) {
			 array = increaseICodeCapasity(4);
		 }
		 array[top] = (byte)(i >>> 24);
		 array[top + 1] = (byte)(i >>> 16);
		 array[top + 2] = (byte)(i >>> 8);
		 array[top + 3] = (byte)i;
		 itsICodeTop = top + 4;
	 }
	 private int getDoubleIndex(double num) {
		 int index = itsDoubleTableTop;
		 if (index == 0) {
			 itsData.itsDoubleTable = new double[64];
		 }
		 else if (itsData.itsDoubleTable.length == index) {
			 double[] na = new double[index * 2];
			 System.arraycopy(itsData.itsDoubleTable, 0, na, 0, index);
			 itsData.itsDoubleTable = na;
		 }
		 itsData.itsDoubleTable[index] = num;
		 itsDoubleTableTop = index + 1;
		 return index;
	 }
	 private void addGotoOp(int gotoOp) {
		 byte[] array = itsData.itsICode;
		 int top = itsICodeTop;
		 if (top + 3 > array.length) {
			 array = increaseICodeCapasity(3);
		 }
		 array[top] = (byte)gotoOp;
		 itsICodeTop = top + 1 + 2;
	 }
	 private void addVarOp(int op, int varIndex) {
		 switch (op) {
			 case Token.GETVAR: case Token.SETVAR: if (varIndex < 128) {
				 addIcode(op == Token.GETVAR ? Icode_GETVAR1 : Icode_SETVAR1);
				 addUint8(varIndex);
				 return;
			 }
			 case Icode_VAR_INC_DEC: addIndexOp(op, varIndex);
			 return;
		 }
		 throw Kit.codeBug();
	 }
	 private void addStringOp(int op, String str) {
		 addStringPrefix(str);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addIndexOp(int op, int index) {
		 addIndexPrefix(index);
		 if (validIcode(op)) {
			 addIcode(op);
		 }
		 else {
			 addToken(op);
		 }
	 }
	 private void addStringPrefix(String str) {
		 int index = itsStrings.get(str, -1);
		 if (index == -1) {
			 index = itsStrings.size();
			 itsStrings.put(str, index);
		 }
		 if (index < 4) {
			 addIcode(Icode_REG_STR_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_STR1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_STR2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_STR4);
			 addInt(index);
		 }
	 }
	 private void addIndexPrefix(int index) {
		 if (index < 0) Kit.codeBug();
		 if (index < 6) {
			 addIcode(Icode_REG_IND_C0 - index);
		 }
		 else if (index <= 0xFF) {
			 addIcode(Icode_REG_IND1);
			 addUint8(index);
		 }
		 else if (index <= 0xFFFF) {
			 addIcode(Icode_REG_IND2);
			 addUint16(index);
		 }
		 else {
			 addIcode(Icode_REG_IND4);
			 addInt(index);
		 }
	 }
	 private void addExceptionHandler(int icodeStart, int icodeEnd, int handlerStart, boolean isFinally, int exceptionObjectLocal, int scopeLocal) {
		 int top = itsExceptionTableTop;
		 int[] table = itsData.itsExceptionTable;
		 if (table == null) {
			 if (top != 0) Kit.codeBug();
			 table = new int[EXCEPTION_SLOT_SIZE * 2];
			 itsData.itsExceptionTable = table;
		 }
		 else if (table.length == top) {
			 table = new int[table.length * 2];
			 System.arraycopy(itsData.itsExceptionTable, 0, table, 0, top);
			 itsData.itsExceptionTable = table;
		 }
		 table[top + EXCEPTION_TRY_START_SLOT] = icodeStart;
		 table[top + EXCEPTION_TRY_END_SLOT] = icodeEnd;
		 table[top + EXCEPTION_HANDLER_SLOT] = handlerStart;
		 table[top + EXCEPTION_TYPE_SLOT] = isFinally ? 1 : 0;
		 table[top + EXCEPTION_LOCAL_SLOT] = exceptionObjectLocal;
		 table[top + EXCEPTION_SCOPE_SLOT] = scopeLocal;
		 itsExceptionTableTop = top + EXCEPTION_SLOT_SIZE;
	 }
	 private byte[] increaseICodeCapasity(int extraSize) {
		 int capacity = itsData.itsICode.length;
		 int top = itsICodeTop;
		 if (top + extraSize <= capacity) throw Kit.codeBug();
		 capacity *= 2;
		 if (top + extraSize > capacity) {
			 capacity = top + extraSize;
		 }
		 byte[] array = new byte[capacity];
		 System.arraycopy(itsData.itsICode, 0, array, 0, top);
		 itsData.itsICode = array;
		 return array;
	 }
	 private void stackChange(int change) {
		 if (change <= 0) {
			 itsStackDepth += change;
		 }
		 else {
			 int newDepth = itsStackDepth + change;
			 if (newDepth > itsData.itsMaxStack) {
				 itsData.itsMaxStack = newDepth;
			 }
			 itsStackDepth = newDepth;
		 }
	 }
	 private int allocLocal() {
		 int localSlot = itsLocalTop;
		 ++itsLocalTop;
		 if (itsLocalTop > itsData.itsMaxLocals) {
			 itsData.itsMaxLocals = itsLocalTop;
		 }
		 return localSlot;
	 }
	 private void releaseLocal(int localSlot) {
		 --itsLocalTop;
		 if (localSlot != itsLocalTop) Kit.codeBug();
	 }
	 private static int getShort(byte[] iCode, int pc) {
		 return (iCode[pc] << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getIndex(byte[] iCode, int pc) {
		 return ((iCode[pc] & 0xFF) << 8) | (iCode[pc + 1] & 0xFF);
	 }
	 private static int getInt(byte[] iCode, int pc) {
		 return (iCode[pc] << 24) | ((iCode[pc + 1] & 0xFF) << 16) | ((iCode[pc + 2] & 0xFF) << 8) | (iCode[pc + 3] & 0xFF);
	 }
	 private static int getExceptionHandler(CallFrame frame, boolean onlyFinally) {
		 int[] exceptionTable = frame.idata.itsExceptionTable;
		 if (exceptionTable == null) {
			 return -1;
		 }
		 int pc = frame.pc - 1;
		 int best = -1, bestStart = 0, bestEnd = 0;
		 for (int i = 0;
		 i != exceptionTable.length;
		 i += EXCEPTION_SLOT_SIZE) {
			 int start = exceptionTable[i + EXCEPTION_TRY_START_SLOT];
			 int end = exceptionTable[i + EXCEPTION_TRY_END_SLOT];
			 if (!(start <= pc && pc < end)) {
				 continue;
			 }
			 if (onlyFinally && exceptionTable[i + EXCEPTION_TYPE_SLOT] != 1) {
				 continue;
			 }
			 if (best >= 0) {
				 if (bestEnd < end) {
					 continue;
				 }
				 if (bestStart > start) Kit.codeBug();
				 if (bestEnd == end) Kit.codeBug();
			 }
			 best = i;
			 bestStart = start;
			 bestEnd = end;
		 }
		 return best;
	 }
	 private static void dumpICode(InterpreterData idata) {
		 if (!Token.printICode) {
			 return;
		 }
		 byte iCode[] = idata.itsICode;
		 int iCodeLength = iCode.length;
		 String[] strings = idata.itsStringTable;
		 PrintStream out = System.out;
		 out.println(""ICode dump, for "" + idata.itsName + "", length = "" + iCodeLength);
		 out.println(""MaxStack = "" + idata.itsMaxStack);
		 int indexReg = 0;
		 for (int pc = 0;
		 pc < iCodeLength;
		 ) {
			 out.flush();
			 out.print("" ["" + pc + ""] "");
			 int token = iCode[pc];
			 int icodeLength = bytecodeSpan(token);
			 String tname = bytecodeName(token);
			 int old_pc = pc;
			 ++pc;
			 switch (token) {
				 default: if (icodeLength != 1) Kit.codeBug();
				 out.println(tname);
				 break;
				 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : {
					 int newPC = pc + getShort(iCode, pc) - 1;
					 out.println(tname + "" "" + newPC);
					 pc += 2;
					 break;
				 }
				 case Icode_VAR_INC_DEC : case Icode_NAME_INC_DEC : case Icode_PROP_INC_DEC : case Icode_ELEM_INC_DEC : case Icode_REF_INC_DEC: {
					 int incrDecrType = iCode[pc];
					 out.println(tname + "" "" + incrDecrType);
					 ++pc;
					 break;
				 }
				 case Icode_CALLSPECIAL : {
					 int callType = iCode[pc] & 0xFF;
					 boolean isNew = (iCode[pc + 1] != 0);
					 int line = getIndex(iCode, pc+2);
					 out.println(tname+"" ""+callType+"" ""+isNew+"" ""+indexReg+"" ""+line);
					 pc += 4;
					 break;
				 }
				 case Token.CATCH_SCOPE: {
					 boolean afterFisrtFlag = (iCode[pc] != 0);
					 out.println(tname+"" ""+afterFisrtFlag);
					 ++pc;
				 }
				 break;
				 case Token.REGEXP : out.println(tname+"" ""+idata.itsRegExpLiterals[indexReg]);
				 break;
				 case Token.OBJECTLIT : case Icode_SPARE_ARRAYLIT : out.println(tname+"" ""+idata.literalIds[indexReg]);
				 break;
				 case Icode_CLOSURE_EXPR : case Icode_CLOSURE_STMT : out.println(tname+"" ""+idata.itsNestedFunctions[indexReg]);
				 break;
				 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : case Token.NEW : out.println(tname+' '+indexReg);
				 break;
				 case Token.THROW : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_SHORTNUMBER : {
					 int value = getShort(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_INTNUMBER : {
					 int value = getInt(iCode, pc);
					 out.println(tname + "" "" + value);
					 pc += 4;
					 break;
				 }
				 case Token.NUMBER : {
					 double value = idata.itsDoubleTable[indexReg];
					 out.println(tname + "" "" + value);
					 pc += 2;
					 break;
				 }
				 case Icode_LINE : {
					 int line = getIndex(iCode, pc);
					 out.println(tname + "" : "" + line);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR1: {
					 String str = strings[0xFF & iCode[pc]];
					 out.println(tname + "" \"""" + str + '""');
					 ++pc;
					 break;
				 }
				 case Icode_REG_STR2: {
					 String str = strings[getIndex(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 2;
					 break;
				 }
				 case Icode_REG_STR4: {
					 String str = strings[getInt(iCode, pc)];
					 out.println(tname + "" \"""" + str + '""');
					 pc += 4;
					 break;
				 }
				 case Icode_REG_IND1: {
					 indexReg = 0xFF & iCode[pc];
					 out.println(tname+"" ""+indexReg);
					 ++pc;
					 break;
				 }
				 case Icode_REG_IND2: {
					 indexReg = getIndex(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 2;
					 break;
				 }
				 case Icode_REG_IND4: {
					 indexReg = getInt(iCode, pc);
					 out.println(tname+"" ""+indexReg);
					 pc += 4;
					 break;
				 }
				 case Icode_GETVAR1: case Icode_SETVAR1: indexReg = iCode[pc];
				 out.println(tname+"" ""+indexReg);
				 ++pc;
				 break;
			 }
			 if (old_pc + icodeLength != pc) Kit.codeBug();
		 }
		 int[] table = idata.itsExceptionTable;
		 if (table != null) {
			 out.println(""Exception handlers: "" +table.length / EXCEPTION_SLOT_SIZE);
			 for (int i = 0;
			 i != table.length;
			 i += EXCEPTION_SLOT_SIZE) {
				 int tryStart = table[i + EXCEPTION_TRY_START_SLOT];
				 int tryEnd = table[i + EXCEPTION_TRY_END_SLOT];
				 int handlerStart = table[i + EXCEPTION_HANDLER_SLOT];
				 int type = table[i + EXCEPTION_TYPE_SLOT];
				 int exceptionLocal = table[i + EXCEPTION_LOCAL_SLOT];
				 int scopeLocal = table[i + EXCEPTION_SCOPE_SLOT];
				 out.println("" tryStart=""+tryStart+"" tryEnd=""+tryEnd +"" handlerStart=""+handlerStart +"" type=""+(type == 0 ? ""catch"" : ""finally"") +"" exceptionLocal=""+exceptionLocal);
			 }
		 }
		 out.flush();
	 }
	 private static int bytecodeSpan(int bytecode) {
		 switch (bytecode) {
			 case Token.THROW : return 1 + 2;
			 case Icode_GOSUB : case Token.GOTO : case Token.IFEQ : case Token.IFNE : case Icode_IFEQ_POP : case Icode_LEAVEDQ : return 1 + 2;
			 case Icode_CALLSPECIAL : return 1 + 1 + 1 + 2;
			 case Token.CATCH_SCOPE: return 1 + 1;
			 case Icode_VAR_INC_DEC: case Icode_NAME_INC_DEC: case Icode_PROP_INC_DEC: case Icode_ELEM_INC_DEC: case Icode_REF_INC_DEC: return 1 + 1;
			 case Icode_SHORTNUMBER : return 1 + 2;
			 case Icode_INTNUMBER : return 1 + 4;
			 case Icode_REG_IND1: return 1 + 1;
			 case Icode_REG_IND2: return 1 + 2;
			 case Icode_REG_IND4: return 1 + 4;
			 case Icode_REG_STR1: return 1 + 1;
			 case Icode_REG_STR2: return 1 + 2;
			 case Icode_REG_STR4: return 1 + 4;
			 case Icode_GETVAR1: case Icode_SETVAR1: return 1 + 1;
			 case Icode_LINE : return 1 + 2;
		 }
		 if (!validBytecode(bytecode)) throw Kit.codeBug();
		 return 1;
	 }
	 static int[] getLineNumbers(InterpreterData data) {
		 UintMap presentLines = new UintMap();
		 byte[] iCode = data.itsICode;
		 int iCodeLength = iCode.length;
		 for (int pc = 0;
		 pc != iCodeLength;
		) {
			 int bytecode = iCode[pc];
			 int span = bytecodeSpan(bytecode);
			 if (bytecode == Icode_LINE) {
				 if (span != 3) Kit.codeBug();
				 int line = getIndex(iCode, pc + 1);
				 presentLines.put(line, 0);
			 }
			 pc += span;
		 }
		 return presentLines.getKeys();
	 }
	 static void captureInterpreterStackInfo(RhinoException ex) {
		 Context cx = Context.getCurrentContext();
		 if (cx == null || cx.lastInterpreterFrame == null) {
			 ex.interpreterStackInfo = null;
			 ex.interpreterLineData = null;
			 return;
		 }
		 CallFrame[] array;
		 if (cx.previousInterpreterInvocations == null || cx.previousInterpreterInvocations.size() == 0) {
			 array = new CallFrame[1];
		 }
		 else {
			 int previousCount = cx.previousInterpreterInvocations.size();
			 if (cx.previousInterpreterInvocations.peek() == cx.lastInterpreterFrame) {
				 --previousCount;
			 }
			 array = new CallFrame[previousCount + 1];
			 cx.previousInterpreterInvocations.toArray(array);
		 }
		 array[array.length - 1] = (CallFrame)cx.lastInterpreterFrame;
		 int interpreterFrameCount = 0;
		 for (int i = 0;
		 i != array.length;
		 ++i) {
			 interpreterFrameCount += 1 + array[i].frameIndex;
		 }
		 int[] linePC = new int[interpreterFrameCount];
		 int linePCIndex = interpreterFrameCount;
		 for (int i = array.length;
		 i != 0;
		) {
			 --i;
			 CallFrame frame = array[i];
			 while (frame != null) {
				 --linePCIndex;
				 linePC[linePCIndex] = frame.pcSourceLineStart;
				 frame = frame.parentFrame;
			 }
		 }
		 if (linePCIndex != 0) Kit.codeBug();
		 ex.interpreterStackInfo = array;
		 ex.interpreterLineData = linePC;
	 }
	 static String getSourcePositionFromStack(Context cx, int[] linep) {
		 CallFrame frame = (CallFrame)cx.lastInterpreterFrame;
		 InterpreterData idata = frame.idata;
		 if (frame.pcSourceLineStart >= 0) {
			 linep[0] = getIndex(idata.itsICode, frame.pcSourceLineStart);
		 }
		 else {
			 linep[0] = 0;
		 }
		 return idata.itsSourceFile;
	 }
	 static String getPatchedStack(RhinoException ex, String nativeStackTrace) {
		 String tag = ""org.mozilla.javascript.Interpreter.interpretLoop"";
		 StringBuffer sb = new StringBuffer(nativeStackTrace.length() + 1000);
		 String lineSeparator = System.getProperty(""line.separator"");
		 CallFrame[] array = (CallFrame[])ex.interpreterStackInfo;
		 int[] linePC = ex.interpreterLineData;
		 int arrayIndex = array.length;
		 int linePCIndex = linePC.length;
		 int offset = 0;
		 while (arrayIndex != 0) {
			 --arrayIndex;
			 int pos = nativeStackTrace.indexOf(tag, offset);
			 if (pos < 0) {
				 break;
			 }
			 pos += tag.length();
			 for (;
			 pos != nativeStackTrace.length();
			 ++pos) {
				 char c = nativeStackTrace.charAt(pos);
				 if (c == '\n' || c == '\r') {
					 break;
				 }
			 }
			 sb.append(nativeStackTrace.substring(offset, pos));
			 offset = pos;
			 CallFrame frame = array[arrayIndex];
			 while (frame != null) {
				 if (linePCIndex == 0) Kit.codeBug();
				 --linePCIndex;
				 InterpreterData idata = frame.idata;
				 sb.append(lineSeparator);
				 sb.append(""\tat script"");
				 if (idata.itsName != null && idata.itsName.length() != 0) {
					 sb.append('.');
					 sb.append(idata.itsName);
				 }
				 sb.append('(');
				 sb.append(idata.itsSourceFile);
				 int pc = linePC[linePCIndex];
				 if (pc >= 0) {
					 sb.append(':');
					 sb.append(getIndex(idata.itsICode, pc));
				 }
				 sb.append(')');
				 frame = frame.parentFrame;
			 }
		 }
		 sb.append(nativeStackTrace.substring(offset));
		 return sb.toString();
	 }
	 static String getEncodedSource(InterpreterData idata) {
		 if (idata.encodedSource == null) {
			 return null;
		 }
		 return idata.encodedSource.substring(idata.encodedSourceStart, idata.encodedSourceEnd);
	 }
	 private static void initFunction(Context cx, Scriptable scope, InterpretedFunction parent, int index) {
		 InterpretedFunction fn;
		 fn = InterpretedFunction.createFunction(cx, scope, parent, index);
		 ScriptRuntime.initFunction(cx, scope, fn, fn.idata.itsFunctionType, parent.idata.evalScriptFlag);
	 }
	 static Object interpret(InterpretedFunction ifun, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) Kit.codeBug();
		 if (cx.interpreterSecurityDomain != ifun.securityDomain) {
			 Object savedDomain = cx.interpreterSecurityDomain;
			 cx.interpreterSecurityDomain = ifun.securityDomain;
			 try {
				 return ifun.securityController.callWithDomain( ifun.securityDomain, cx, ifun, scope, thisObj, args);
			 }
			 finally {
				 cx.interpreterSecurityDomain = savedDomain;
			 }
		 }
		 CallFrame frame = new CallFrame();
		 initFrame(cx, scope, thisObj, args, null, 0, args.length, ifun, null, frame);
		 return interpretLoop(cx, frame, null);
	 }
	 public static Object restartContinuation(Continuation c, Context cx, Scriptable scope, Object[] args) {
		 if (!ScriptRuntime.hasTopCall(cx)) {
			 return ScriptRuntime.doTopCall(c, cx, scope, null, args);
		 }
		 Object arg;
		 if (args.length == 0) {
			 arg = Undefined.instance;
		 }
		 else {
			 arg = args[0];
		 }
		 CallFrame capturedFrame = (CallFrame)c.getImplementation();
		 if (capturedFrame == null) {
			 return arg;
		 }
		 ContinuationJump cjump = new ContinuationJump(c, null);
		 cjump.result = arg;
		 return interpretLoop(cx, null, cjump);
	 }
	 private static Object interpretLoop(Context cx, CallFrame frame, Object throwable) {
		 final Object DBL_MRK = UniqueTag.DOUBLE_MARK;
		 final Object undefined = Undefined.instance;
		 final boolean instructionCounting = (cx.instructionThreshold != 0);
		 final int INVOCATION_COST = 100;
		 final int EXCEPTION_COST = 100;
		 String stringReg = null;
		 int indexReg = -1;
		 if (cx.lastInterpreterFrame != null) {
			 if (cx.previousInterpreterInvocations == null) {
				 cx.previousInterpreterInvocations = new ObjArray();
			 }
			 cx.previousInterpreterInvocations.push(cx.lastInterpreterFrame);
		 }
		 if (throwable != null) {
			 if (!(throwable instanceof ContinuationJump)) {
				 Kit.codeBug();
			 }
		 }
		 Object interpreterResult = null;
		 double interpreterResultDbl = 0.0;
		 StateLoop: for (;
		;
		) {
			 withoutExceptions: try {
				 if (throwable != null) {
					 if (indexReg >= 0) {
						 if (frame.frozen) {
							 frame = frame.cloneFrozen();
						 }
						 int[] table = frame.idata.itsExceptionTable;
						 frame.pc = table[indexReg + EXCEPTION_HANDLER_SLOT];
						 if (instructionCounting) {
							 frame.pcPrevBranch = frame.pc;
						 }
						 frame.savedStackTop = frame.emptyStackTop;
						 int scopeLocal = frame.localShift + table[indexReg + EXCEPTION_SCOPE_SLOT];
						 int exLocal = frame.localShift + table[indexReg + EXCEPTION_LOCAL_SLOT];
						 frame.scope = (Scriptable)frame.stack[scopeLocal];
						 frame.stack[exLocal] = throwable;
						 throwable = null;
					 }
					 else {
						 ContinuationJump cjump = (ContinuationJump)throwable;
						 throwable = null;
						 if (cjump.branchFrame != frame) Kit.codeBug();
						 if (cjump.capturedFrame == null) Kit.codeBug();
						 int rewindCount = cjump.capturedFrame.frameIndex + 1;
						 if (cjump.branchFrame != null) {
							 rewindCount -= cjump.branchFrame.frameIndex;
						 }
						 int enterCount = 0;
						 CallFrame[] enterFrames = null;
						 CallFrame x = cjump.capturedFrame;
						 for (int i = 0;
						 i != rewindCount;
						 ++i) {
							 if (!x.frozen) Kit.codeBug();
							 if (isFrameEnterExitRequired(x)) {
								 if (enterFrames == null) {
									 enterFrames = new CallFrame[rewindCount - i];
								 }
								 enterFrames[enterCount] = x;
								 ++enterCount;
							 }
							 x = x.parentFrame;
						 }
						 while (enterCount != 0) {
							 --enterCount;
							 x = enterFrames[enterCount];
							 enterFrame(cx, x, ScriptRuntime.emptyArgs);
						 }
						 frame = cjump.capturedFrame.cloneFrozen();
						 setCallResult(frame, cjump.result, cjump.resultDbl);
					 }
				 }
				 else {
					 if (frame.frozen) Kit.codeBug();
				 }
				 Object[] stack = frame.stack;
				 double[] sDbl = frame.sDbl;
				 Object[] vars = frame.varSource.stack;
				 double[] varDbls = frame.varSource.sDbl;
				 byte[] iCode = frame.idata.itsICode;
				 String[] strings = frame.idata.itsStringTable;
				 int stackTop = frame.savedStackTop;
				 cx.lastInterpreterFrame = frame;
				 Loop: for (;
				;
				) {
					 int op = iCode[frame.pc++];
					 jumplessRun: {
						switch (op) {
							 case Token.THROW: {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int sourceLine = getIndex(iCode, frame.pc);
								 throwable = new JavaScriptException(value, frame.idata.itsSourceFile, sourceLine);
								 break withoutExceptions;
							 }
							 case Token.RETHROW: {
								 indexReg += frame.localShift;
								 throwable = stack[indexReg];
								 break withoutExceptions;
							 }
							 case Token.GE : case Token.LE : case Token.GT : case Token.LT : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 object_compare: {
									 number_compare: {
										 double rDbl, lDbl;
										 if (rhs == DBL_MRK) {
											 rDbl = sDbl[stackTop + 1];
											 lDbl = stack_double(frame, stackTop);
										 }
										 else if (lhs == DBL_MRK) {
											 rDbl = ScriptRuntime.toNumber(rhs);
											 lDbl = sDbl[stackTop];
										 }
										 else {
											 break number_compare;
										 }
										 switch (op) {
											 case Token.GE: valBln = (lDbl >= rDbl);
											 break object_compare;
											 case Token.LE: valBln = (lDbl <= rDbl);
											 break object_compare;
											 case Token.GT: valBln = (lDbl > rDbl);
											 break object_compare;
											 case Token.LT: valBln = (lDbl < rDbl);
											 break object_compare;
											 default: throw Kit.codeBug();
										 }
									 }
									 switch (op) {
										 case Token.GE: valBln = ScriptRuntime.cmp_LE(rhs, lhs);
										 break;
										 case Token.LE: valBln = ScriptRuntime.cmp_LE(lhs, rhs);
										 break;
										 case Token.GT: valBln = ScriptRuntime.cmp_LT(rhs, lhs);
										 break;
										 case Token.LT: valBln = ScriptRuntime.cmp_LT(lhs, rhs);
										 break;
										 default: throw Kit.codeBug();
									 }
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IN : case Token.INSTANCEOF : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 boolean valBln;
								 if (op == Token.IN) {
									 valBln = ScriptRuntime.in(lhs, rhs, cx);
								 }
								 else {
									 valBln = ScriptRuntime.instanceOf(lhs, rhs, cx);
								 }
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.EQ : case Token.NE : {
								 --stackTop;
								 boolean valBln;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 if (rhs == DBL_MRK) {
									 if (lhs == DBL_MRK) {
										 valBln = (sDbl[stackTop] == sDbl[stackTop + 1]);
									 }
									 else {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop + 1], lhs);
									 }
								 }
								 else {
									 if (lhs == DBL_MRK) {
										 valBln = ScriptRuntime.eqNumber(sDbl[stackTop], rhs);
									 }
									 else {
										 valBln = ScriptRuntime.eq(lhs, rhs);
									 }
								 }
								 valBln ^= (op == Token.NE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.SHEQ : case Token.SHNE : {
								 --stackTop;
								 Object rhs = stack[stackTop + 1];
								 Object lhs = stack[stackTop];
								 boolean valBln;
								 shallow_compare: {
									 double rdbl, ldbl;
									 if (rhs == DBL_MRK) {
										 rdbl = sDbl[stackTop + 1];
										 if (lhs == DBL_MRK) {
											 ldbl = sDbl[stackTop];
										 }
										 else if (lhs instanceof Number) {
											 ldbl = ((Number)lhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else if (lhs == DBL_MRK) {
										 ldbl = sDbl[stackTop];
										 if (rhs == DBL_MRK) {
											 rdbl = sDbl[stackTop + 1];
										 }
										 else if (rhs instanceof Number) {
											 rdbl = ((Number)rhs).doubleValue();
										 }
										 else {
											 valBln = false;
											 break shallow_compare;
										 }
									 }
									 else {
										 valBln = ScriptRuntime.shallowEq(lhs, rhs);
										 break shallow_compare;
									 }
									 valBln = (ldbl == rdbl);
								 }
								 valBln ^= (op == Token.SHNE);
								 stack[stackTop] = ScriptRuntime.wrapBoolean(valBln);
								 continue Loop;
							 }
							 case Token.IFNE : if (stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Token.IFEQ : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 break jumplessRun;
							 case Icode_IFEQ_POP : if (!stack_boolean(frame, stackTop--)) {
								 frame.pc += 2;
								 continue Loop;
							 }
							 stack[stackTop--] = null;
							 break jumplessRun;
							 case Token.GOTO : break jumplessRun;
							 case Icode_GOSUB : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.pc + 2;
							 break jumplessRun;
							 case Icode_STARTSUB : if (stackTop == frame.emptyStackTop + 1) {
								 indexReg += frame.localShift;
								 stack[indexReg] = stack[stackTop];
								 sDbl[indexReg] = sDbl[stackTop];
								 --stackTop;
							 }
							 else {
								 if (stackTop != frame.emptyStackTop) Kit.codeBug();
							 }
							 continue Loop;
							 case Icode_RETSUB : {
								 if (instructionCounting) {
									 addInstructionCount(cx, frame, 0);
								 }
								 indexReg += frame.localShift;
								 Object value = stack[indexReg];
								 if (value != DBL_MRK) {
									 throwable = value;
									 break withoutExceptions;
								 }
								 frame.pc = (int)sDbl[indexReg];
								 if (instructionCounting) {
									 frame.pcPrevBranch = frame.pc;
								 }
								 continue Loop;
							 }
							 case Icode_POP : stack[stackTop] = null;
							 stackTop--;
							 continue Loop;
							 case Icode_POP_RESULT : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 stack[stackTop] = null;
							 --stackTop;
							 continue Loop;
							 case Icode_DUP : stack[stackTop + 1] = stack[stackTop];
							 sDbl[stackTop + 1] = sDbl[stackTop];
							 stackTop++;
							 continue Loop;
							 case Icode_DUP2 : stack[stackTop + 1] = stack[stackTop - 1];
							 sDbl[stackTop + 1] = sDbl[stackTop - 1];
							 stack[stackTop + 2] = stack[stackTop];
							 sDbl[stackTop + 2] = sDbl[stackTop];
							 stackTop += 2;
							 continue Loop;
							 case Icode_SWAP : {
								 Object o = stack[stackTop];
								 stack[stackTop] = stack[stackTop - 1];
								 stack[stackTop - 1] = o;
								 double d = sDbl[stackTop];
								 sDbl[stackTop] = sDbl[stackTop - 1];
								 sDbl[stackTop - 1] = d;
								 continue Loop;
							 }
							 case Token.RETURN : frame.result = stack[stackTop];
							 frame.resultDbl = sDbl[stackTop];
							 --stackTop;
							 break Loop;
							 case Token.RETURN_RESULT : break Loop;
							 case Icode_RETUNDEF : frame.result = undefined;
							 break Loop;
							 case Token.BITNOT : {
								 int rIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ~rIntValue;
								 continue Loop;
							 }
							 case Token.BITAND : case Token.BITOR : case Token.BITXOR : case Token.LSH : case Token.RSH : {
								 int rIntValue = stack_int32(frame, stackTop);
								 --stackTop;
								 int lIntValue = stack_int32(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.BITAND: lIntValue &= rIntValue;
									 break;
									 case Token.BITOR: lIntValue |= rIntValue;
									 break;
									 case Token.BITXOR: lIntValue ^= rIntValue;
									 break;
									 case Token.LSH: lIntValue <<= rIntValue;
									 break;
									 case Token.RSH: lIntValue >>= rIntValue;
									 break;
								 }
								 sDbl[stackTop] = lIntValue;
								 continue Loop;
							 }
							 case Token.URSH : {
								 int rIntValue = stack_int32(frame, stackTop) & 0x1F;
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 sDbl[stackTop] = ScriptRuntime.toUint32(lDbl) >>> rIntValue;
								 continue Loop;
							 }
							 case Token.NEG : case Token.POS : {
								 double rDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 if (op == Token.NEG) {
									 rDbl = -rDbl;
								 }
								 sDbl[stackTop] = rDbl;
								 continue Loop;
							 }
							 case Token.ADD : --stackTop;
							 do_add(stack, sDbl, stackTop, cx);
							 continue Loop;
							 case Token.SUB : case Token.MUL : case Token.DIV : case Token.MOD : {
								 double rDbl = stack_double(frame, stackTop);
								 --stackTop;
								 double lDbl = stack_double(frame, stackTop);
								 stack[stackTop] = DBL_MRK;
								 switch (op) {
									 case Token.SUB: lDbl -= rDbl;
									 break;
									 case Token.MUL: lDbl *= rDbl;
									 break;
									 case Token.DIV: lDbl /= rDbl;
									 break;
									 case Token.MOD: lDbl %= rDbl;
									 break;
								 }
								 sDbl[stackTop] = lDbl;
								 continue Loop;
							 }
							 case Token.NOT : stack[stackTop] = ScriptRuntime.wrapBoolean( !stack_boolean(frame, stackTop));
							 continue Loop;
							 case Token.BINDNAME : stack[++stackTop] = ScriptRuntime.bind(cx, frame.scope, stringReg);
							 continue Loop;
							 case Token.SETNAME : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Scriptable lhs = (Scriptable)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.setName(lhs, rhs, cx, frame.scope, stringReg);
								 continue Loop;
							 }
							 case Token.DELPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.delete(lhs, rhs, cx);
								 continue Loop;
							 }
							 case Token.GETPROP : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getObjectProp(lhs, stringReg, cx);
								 continue Loop;
							 }
							 case Token.SETPROP : {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setObjectProp(lhs, stringReg, rhs, cx);
								 continue Loop;
							 }
							 case Icode_PROP_INC_DEC : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.propIncrDecr(lhs, stringReg, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GETELEM : {
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.getObjectElem(lhs, id, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.getObjectIndex(lhs, d, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Token.SETELEM : {
								 stackTop -= 2;
								 Object rhs = stack[stackTop + 2];
								 if (rhs == DBL_MRK) {
									 rhs = ScriptRuntime.wrapNumber(sDbl[stackTop + 2]);
								 }
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) {
									 lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 }
								 Object value;
								 Object id = stack[stackTop + 1];
								 if (id != DBL_MRK) {
									 value = ScriptRuntime.setObjectElem(lhs, id, rhs, cx);
								 }
								 else {
									 double d = sDbl[stackTop + 1];
									 value = ScriptRuntime.setObjectIndex(lhs, d, rhs, cx);
								 }
								 stack[stackTop] = value;
								 continue Loop;
							 }
							 case Icode_ELEM_INC_DEC: {
								 Object rhs = stack[stackTop];
								 if (rhs == DBL_MRK) rhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.elemIncrDecr(lhs, rhs, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.GET_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refGet(ref, cx);
								 continue Loop;
							 }
							 case Token.SET_REF : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refSet(ref, value, cx);
								 continue Loop;
							 }
							 case Token.DEL_REF : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refDel(ref, cx);
								 continue Loop;
							 }
							 case Icode_REF_INC_DEC : {
								 Ref ref = (Ref)stack[stackTop];
								 stack[stackTop] = ScriptRuntime.refIncrDecr(ref, cx, iCode[frame.pc]);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.LOCAL_LOAD : ++stackTop;
							 indexReg += frame.localShift;
							 stack[stackTop] = stack[indexReg];
							 sDbl[stackTop] = sDbl[indexReg];
							 continue Loop;
							 case Icode_LOCAL_CLEAR : indexReg += frame.localShift;
							 stack[indexReg] = null;
							 continue Loop;
							 case Icode_NAME_AND_THIS : ++stackTop;
							 stack[stackTop] = ScriptRuntime.getNameFunctionAndThis(stringReg, cx, frame.scope);
							 ++stackTop;
							 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
							 continue Loop;
							 case Icode_PROP_AND_THIS: {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getPropFunctionAndThis(obj, stringReg, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_ELEM_AND_THIS: {
								 Object obj = stack[stackTop - 1];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop - 1]);
								 Object id = stack[stackTop];
								 if (id == DBL_MRK) id = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop - 1] = ScriptRuntime.getElemFunctionAndThis(obj, id, cx);
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_VALUE_AND_THIS : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.getValueFunctionAndThis(value, cx);
								 ++stackTop;
								 stack[stackTop] = ScriptRuntime.lastStoredScriptable(cx);
								 continue Loop;
							 }
							 case Icode_CALLSPECIAL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 int callType = iCode[frame.pc] & 0xFF;
								 boolean isNew = (iCode[frame.pc + 1] != 0);
								 int sourceLine = getIndex(iCode, frame.pc + 2);
								 if (isNew) {
									 stackTop -= indexReg;
									 Object function = stack[stackTop];
									 if (function == DBL_MRK) function = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 1, indexReg);
									 stack[stackTop] = ScriptRuntime.newSpecial( cx, function, outArgs, frame.scope, callType);
								 }
								 else {
									 stackTop -= 1 + indexReg;
									 Scriptable functionThis = (Scriptable)stack[stackTop + 1];
									 Callable function = (Callable)stack[stackTop];
									 Object[] outArgs = getArgsArray( stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callSpecial( cx, function, functionThis, outArgs, frame.scope, frame.thisObj, callType, frame.idata.itsSourceFile, sourceLine);
								 }
								 frame.pc += 4;
								 continue Loop;
							 }
							 case Token.CALL : case Icode_TAIL_CALL : case Token.REF_CALL : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= 1 + indexReg;
								 Callable fun = (Callable)stack[stackTop];
								 Scriptable funThisObj = (Scriptable)stack[stackTop + 1];
								 if (op == Token.REF_CALL) {
									 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
									 stack[stackTop] = ScriptRuntime.callRef(fun, funThisObj, outArgs, cx);
									 continue Loop;
								 }
								 Scriptable calleeScope = frame.scope;
								 if (frame.useActivation) {
									 calleeScope = ScriptableObject.getTopLevelScope(frame.scope);
								 }
								 if (fun instanceof InterpretedFunction) {
									 InterpretedFunction ifun = (InterpretedFunction)fun;
									 if (frame.fnOrScript.securityDomain == ifun.securityDomain) {
										 CallFrame callParentFrame = frame;
										 CallFrame calleeFrame = new CallFrame();
										 if (op == Icode_TAIL_CALL) {
											 callParentFrame = frame.parentFrame;
										 }
										 initFrame(cx, calleeScope, funThisObj, stack, sDbl, stackTop + 2, indexReg, ifun, callParentFrame, calleeFrame);
										 if (op == Icode_TAIL_CALL) {
											 exitFrame(cx, frame, null);
										 }
										 else {
											 frame.savedStackTop = stackTop;
											 frame.savedCallOp = op;
										 }
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (fun instanceof Continuation) {
									 ContinuationJump cjump;
									 cjump = new ContinuationJump((Continuation)fun, frame);
									 if (indexReg == 0) {
										 cjump.result = undefined;
									 }
									 else {
										 cjump.result = stack[stackTop + 2];
										 cjump.resultDbl = sDbl[stackTop + 2];
									 }
									 throwable = cjump;
									 break withoutExceptions;
								 }
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 2, indexReg);
								 stack[stackTop] = fun.call(cx, calleeScope, funThisObj, outArgs);
								 continue Loop;
							 }
							 case Token.NEW : {
								 if (instructionCounting) {
									 cx.instructionCount += INVOCATION_COST;
								 }
								 stackTop -= indexReg;
								 Object lhs = stack[stackTop];
								 if (lhs instanceof InterpretedFunction) {
									 InterpretedFunction f = (InterpretedFunction)lhs;
									 if (frame.fnOrScript.securityDomain == f.securityDomain) {
										 Scriptable newInstance = f.createObject(cx, frame.scope);
										 CallFrame calleeFrame = new CallFrame();
										 initFrame(cx, frame.scope, newInstance, stack, sDbl, stackTop + 1, indexReg, f, frame, calleeFrame);
										 stack[stackTop] = newInstance;
										 frame.savedStackTop = stackTop;
										 frame.savedCallOp = op;
										 frame = calleeFrame;
										 continue StateLoop;
									 }
								 }
								 if (!(lhs instanceof Function)) {
									 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
									 throw ScriptRuntime.notFunctionError(lhs);
								 }
								 Function fun = (Function)lhs;
								 if (fun instanceof IdFunctionObject) {
									 IdFunctionObject ifun = (IdFunctionObject)fun;
									 if (Continuation.isContinuationConstructor(ifun)) {
										 captureContinuation(cx, frame, stackTop);
										 continue Loop;
									 }
								 }
								 Object[] outArgs = getArgsArray(stack, sDbl, stackTop + 1, indexReg);
								 stack[stackTop] = fun.construct(cx, frame.scope, outArgs);
								 continue Loop;
							 }
							 case Token.TYPEOF : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.typeof(lhs);
								 continue Loop;
							 }
							 case Icode_TYPEOFNAME : stack[++stackTop] = ScriptRuntime.typeofName(frame.scope, stringReg);
							 continue Loop;
							 case Token.STRING : stack[++stackTop] = stringReg;
							 continue Loop;
							 case Icode_SHORTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getShort(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_INTNUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Token.NUMBER : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = frame.idata.itsDoubleTable[indexReg];
							 continue Loop;
							 case Token.NAME : stack[++stackTop] = ScriptRuntime.name(cx, frame.scope, stringReg);
							 continue Loop;
							 case Icode_NAME_INC_DEC : stack[++stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, stringReg, iCode[frame.pc]);
							 ++frame.pc;
							 continue Loop;
							 case Icode_SETVAR1: indexReg = iCode[frame.pc++];
							 case Token.SETVAR : if (!frame.useActivation) {
								 vars[indexReg] = stack[stackTop];
								 varDbls[indexReg] = sDbl[stackTop];
							 }
							 else {
								 Object val = stack[stackTop];
								 if (val == DBL_MRK) val = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stringReg = frame.idata.argNames[indexReg];
								 frame.scope.put(stringReg, frame.scope, val);
							 }
							 continue Loop;
							 case Icode_GETVAR1: indexReg = iCode[frame.pc++];
							 case Token.GETVAR : ++stackTop;
							 if (!frame.useActivation) {
								 stack[stackTop] = vars[indexReg];
								 sDbl[stackTop] = varDbls[indexReg];
							 }
							 else {
								 stringReg = frame.idata.argNames[indexReg];
								 stack[stackTop] = frame.scope.get(stringReg, frame.scope);
							 }
							 continue Loop;
							 case Icode_VAR_INC_DEC : {
								 ++stackTop;
								 int incrDecrMask = iCode[frame.pc];
								 if (!frame.useActivation) {
									 stack[stackTop] = DBL_MRK;
									 Object varValue = vars[indexReg];
									 double d;
									 if (varValue == DBL_MRK) {
										 d = varDbls[indexReg];
									 }
									 else {
										 d = ScriptRuntime.toNumber(varValue);
										 vars[indexReg] = DBL_MRK;
									 }
									 double d2 = ((incrDecrMask & Node.DECR_FLAG) == 0) ? d + 1.0 : d - 1.0;
									 varDbls[indexReg] = d2;
									 sDbl[stackTop] = ((incrDecrMask & Node.POST_FLAG) == 0) ? d2 : d;
								 }
								 else {
									 String varName = frame.idata.argNames[indexReg];
									 stack[stackTop] = ScriptRuntime.nameIncrDecr(frame.scope, varName, incrDecrMask);
								 }
								 ++frame.pc;
								 continue Loop;
							 }
							 case Icode_ZERO : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_ONE : ++stackTop;
							 stack[stackTop] = DBL_MRK;
							 sDbl[stackTop] = 1;
							 continue Loop;
							 case Token.NULL : stack[++stackTop] = null;
							 continue Loop;
							 case Token.THIS : stack[++stackTop] = frame.thisObj;
							 continue Loop;
							 case Token.THISFN : stack[++stackTop] = frame.fnOrScript;
							 continue Loop;
							 case Token.FALSE : stack[++stackTop] = Boolean.FALSE;
							 continue Loop;
							 case Token.TRUE : stack[++stackTop] = Boolean.TRUE;
							 continue Loop;
							 case Icode_UNDEF : stack[++stackTop] = undefined;
							 continue Loop;
							 case Token.ENTERWITH : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterWith(lhs, cx, frame.scope);
								 continue Loop;
							 }
							 case Token.LEAVEWITH : frame.scope = ScriptRuntime.leaveWith(frame.scope);
							 continue Loop;
							 case Token.CATCH_SCOPE : {
								 --stackTop;
								 indexReg += frame.localShift;
								 boolean afterFirstScope = (frame.idata.itsICode[frame.pc] != 0);
								 Throwable caughtException = (Throwable)stack[stackTop + 1];
								 Scriptable lastCatchScope;
								 if (!afterFirstScope) {
									 lastCatchScope = null;
								 }
								 else {
									 lastCatchScope = (Scriptable)stack[indexReg];
								 }
								 stack[indexReg] = ScriptRuntime.newCatchScope(caughtException, lastCatchScope, stringReg, cx, frame.scope);
								 ++frame.pc;
								 continue Loop;
							 }
							 case Token.ENUM_INIT_KEYS : case Token.ENUM_INIT_VALUES : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 indexReg += frame.localShift;
								 stack[indexReg] = ScriptRuntime.enumInit( lhs, cx, (op == Token.ENUM_INIT_VALUES));
								 continue Loop;
							 }
							 case Token.ENUM_NEXT : case Token.ENUM_ID : {
								 indexReg += frame.localShift;
								 Object val = stack[indexReg];
								 ++stackTop;
								 stack[stackTop] = (op == Token.ENUM_NEXT) ? (Object)ScriptRuntime.enumNext(val) : (Object)ScriptRuntime.enumId(val, cx);
								 continue Loop;
							 }
							 case Token.REF_SPECIAL : {
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.specialRef(obj, stringReg, cx);
								 continue Loop;
							 }
							 case Token.REF_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_MEMBER: {
								 Object elem = stack[stackTop];
								 if (elem == DBL_MRK) elem = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object obj = stack[stackTop];
								 if (obj == DBL_MRK) obj = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.memberRef(obj, ns, elem, cx, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Token.REF_NS_NAME: {
								 Object name = stack[stackTop];
								 if (name == DBL_MRK) name = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 Object ns = stack[stackTop];
								 if (ns == DBL_MRK) ns = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.nameRef(ns, name, cx, frame.scope, indexReg);
								 continue Loop;
							 }
							 case Icode_SCOPE_LOAD : indexReg += frame.localShift;
							 frame.scope = (Scriptable)stack[indexReg];
							 continue Loop;
							 case Icode_SCOPE_SAVE : indexReg += frame.localShift;
							 stack[indexReg] = frame.scope;
							 continue Loop;
							 case Icode_CLOSURE_EXPR : stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Icode_CLOSURE_STMT : initFunction(cx, frame.scope, frame.fnOrScript, indexReg);
							 continue Loop;
							 case Token.REGEXP : stack[++stackTop] = frame.scriptRegExps[indexReg];
							 continue Loop;
							 case Icode_LITERAL_NEW : ++stackTop;
							 stack[stackTop] = new Object[indexReg];
							 sDbl[stackTop] = 0;
							 continue Loop;
							 case Icode_LITERAL_SET : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 int i = (int)sDbl[stackTop];
								 ((Object[])stack[stackTop])[i] = value;
								 sDbl[stackTop] = i + 1;
								 continue Loop;
							 }
							 case Token.ARRAYLIT : case Icode_SPARE_ARRAYLIT : case Token.OBJECTLIT : {
								 Object[] data = (Object[])stack[stackTop];
								 Object val;
								 if (op == Token.OBJECTLIT) {
									 Object[] ids = (Object[])frame.idata.literalIds[indexReg];
									 val = ScriptRuntime.newObjectLiteral(ids, data, cx, frame.scope);
								 }
								 else {
									 int[] skipIndexces = null;
									 if (op == Icode_SPARE_ARRAYLIT) {
										 skipIndexces = (int[])frame.idata.literalIds[indexReg];
									 }
									 val = ScriptRuntime.newArrayLiteral(data, skipIndexces, cx, frame.scope);
								 }
								 stack[stackTop] = val;
								 continue Loop;
							 }
							 case Icode_ENTERDQ : {
								 Object lhs = stack[stackTop];
								 if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 --stackTop;
								 frame.scope = ScriptRuntime.enterDotQuery(lhs, frame.scope);
								 continue Loop;
							 }
							 case Icode_LEAVEDQ : {
								 boolean valBln = stack_boolean(frame, stackTop);
								 Object x = ScriptRuntime.updateDotQuery(valBln, frame.scope);
								 if (x != null) {
									 stack[stackTop] = x;
									 frame.scope = ScriptRuntime.leaveDotQuery(frame.scope);
									 frame.pc += 2;
									 continue Loop;
								 }
								 --stackTop;
								 break jumplessRun;
							 }
							 case Token.DEFAULTNAMESPACE : {
								 Object value = stack[stackTop];
								 if (value == DBL_MRK) value = ScriptRuntime.wrapNumber(sDbl[stackTop]);
								 stack[stackTop] = ScriptRuntime.setDefaultNamespace(value, cx);
								 continue Loop;
							 }
							 case Token.ESCXMLATTR : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeAttributeValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Token.ESCXMLTEXT : {
								 Object value = stack[stackTop];
								 if (value != DBL_MRK) {
									 stack[stackTop] = ScriptRuntime.escapeTextValue(value, cx);
								 }
								 continue Loop;
							 }
							 case Icode_LINE : frame.pcSourceLineStart = frame.pc;
							 if (frame.debuggerFrame != null) {
								 int line = getIndex(iCode, frame.pc);
								 frame.debuggerFrame.onLineChange(cx, line);
							 }
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND_C0: indexReg = 0;
							 continue Loop;
							 case Icode_REG_IND_C1: indexReg = 1;
							 continue Loop;
							 case Icode_REG_IND_C2: indexReg = 2;
							 continue Loop;
							 case Icode_REG_IND_C3: indexReg = 3;
							 continue Loop;
							 case Icode_REG_IND_C4: indexReg = 4;
							 continue Loop;
							 case Icode_REG_IND_C5: indexReg = 5;
							 continue Loop;
							 case Icode_REG_IND1: indexReg = 0xFF & iCode[frame.pc];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_IND2: indexReg = getIndex(iCode, frame.pc);
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_IND4: indexReg = getInt(iCode, frame.pc);
							 frame.pc += 4;
							 continue Loop;
							 case Icode_REG_STR_C0: stringReg = strings[0];
							 continue Loop;
							 case Icode_REG_STR_C1: stringReg = strings[1];
							 continue Loop;
							 case Icode_REG_STR_C2: stringReg = strings[2];
							 continue Loop;
							 case Icode_REG_STR_C3: stringReg = strings[3];
							 continue Loop;
							 case Icode_REG_STR1: stringReg = strings[0xFF & iCode[frame.pc]];
							 ++frame.pc;
							 continue Loop;
							 case Icode_REG_STR2: stringReg = strings[getIndex(iCode, frame.pc)];
							 frame.pc += 2;
							 continue Loop;
							 case Icode_REG_STR4: stringReg = strings[getInt(iCode, frame.pc)];
							 frame.pc += 4;
							 continue Loop;
							 default : dumpICode(frame.idata);
							 throw new RuntimeException( ""Unknown icode : ""+op+"" @ pc : ""+(frame.pc-1));
						}
					 }
					 if (instructionCounting) {
						 addInstructionCount(cx, frame, 2);
					 }
					 int offset = getShort(iCode, frame.pc);
					 if (offset != 0) {
						 frame.pc += offset - 1;
					 }
					 else {
						 frame.pc = frame.idata.longJumps. getExistingInt(frame.pc);
					 }
					 if (instructionCounting) {
						 frame.pcPrevBranch = frame.pc;
					 }
					 continue Loop;
				 }
				 exitFrame(cx, frame, null);
				 interpreterResult = frame.result;
				 interpreterResultDbl = frame.resultDbl;
				 if (frame.parentFrame != null) {
					 frame = frame.parentFrame;
					 if (frame.frozen) {
						 frame = frame.cloneFrozen();
					 }
					 setCallResult( frame, interpreterResult, interpreterResultDbl);
					 interpreterResult = null;
					 continue StateLoop;
				 }
				 break StateLoop;
			 }
			 catch (Throwable ex) {
				 if (throwable != null) {
					 ex.printStackTrace(System.err);
					 throw new IllegalStateException();
				 }
				 throwable = ex;
			 }
			 if (throwable == null) Kit.codeBug();
			 final int EX_CATCH_STATE = 2;
			 final int EX_FINALLY_STATE = 1;
			 final int EX_NO_JS_STATE = 0;
			 int exState;
			 ContinuationJump cjump = null;
			 if (throwable instanceof JavaScriptException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EcmaError) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof EvaluatorException) {
				 exState = EX_CATCH_STATE;
			 }
			 else if (throwable instanceof RuntimeException) {
				 exState = EX_FINALLY_STATE;
			 }
			 else if (throwable instanceof Error) {
				 exState = EX_NO_JS_STATE;
			 }
			 else {
				 exState = EX_FINALLY_STATE;
				 cjump = (ContinuationJump)throwable;
			 }
			 if (instructionCounting) {
				 try {
					 addInstructionCount(cx, frame, EXCEPTION_COST);
				 }
				 catch (RuntimeException ex) {
					 throwable = ex;
					 exState = EX_FINALLY_STATE;
				 }
				 catch (Error ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 if (frame.debuggerFrame != null && throwable instanceof RuntimeException) {
				 RuntimeException rex = (RuntimeException)throwable;
				 try {
					 frame.debuggerFrame.onExceptionThrown(cx, rex);
				 }
				 catch (Throwable ex) {
					 throwable = ex;
					 cjump = null;
					 exState = EX_NO_JS_STATE;
				 }
			 }
			 for (;
			;
			) {
				 if (exState != EX_NO_JS_STATE) {
					 boolean onlyFinally = (exState != EX_CATCH_STATE);
					 indexReg = getExceptionHandler(frame, onlyFinally);
					 if (indexReg >= 0) {
						 continue StateLoop;
					 }
				 }
				 exitFrame(cx, frame, throwable);
				 frame = frame.parentFrame;
				 if (frame == null) {
					 break;
				 }
				 if (cjump != null && cjump.branchFrame == frame) {
					 indexReg = -1;
					 continue StateLoop;
				 }
			 }
			 if (cjump != null) {
				 if (cjump.branchFrame != null) {
					 Kit.codeBug();
				 }
				 if (cjump.capturedFrame != null) {
					 indexReg = -1;
					 continue StateLoop;
				 }
				 interpreterResult = cjump.result;
				 interpreterResultDbl = cjump.resultDbl;
				 throwable = null;
			 }
			 break StateLoop;
		 }
		 if (cx.previousInterpreterInvocations != null && cx.previousInterpreterInvocations.size() != 0) {
			 cx.lastInterpreterFrame = cx.previousInterpreterInvocations.pop();
		 }
		 else {
			 cx.lastInterpreterFrame = null;
			 cx.previousInterpreterInvocations = null;
		 }
		 if (throwable != null) {
			 if (throwable instanceof RuntimeException) {
				 throw (RuntimeException)throwable;
			 }
			 else {
				 throw (Error)throwable;
			 }
		 }
		 return (interpreterResult != DBL_MRK) ? interpreterResult : ScriptRuntime.wrapNumber(interpreterResultDbl);
	 }
	 private static void initFrame(Context cx, Scriptable callerScope, Scriptable thisObj, Object[] args, double[] argsDbl, int argShift, int argCount, InterpretedFunction fnOrScript, CallFrame parentFrame, CallFrame frame) {
		 InterpreterData idata = fnOrScript.idata;
		 boolean useActivation = idata.itsNeedsActivation;
		 DebugFrame debuggerFrame = null;
		 if (cx.debugger != null) {
			 debuggerFrame = cx.debugger.getFrame(cx, idata);
			 if (debuggerFrame != null) {
				 useActivation = true;
			 }
		 }
		 if (useActivation) {
			 if (argsDbl != null) {
				 args = getArgsArray(args, argsDbl, argShift, argCount);
			 }
			 argShift = 0;
			 argsDbl = null;
		 }
		 Scriptable scope;
		 if (idata.itsFunctionType != 0) {
			 if (!idata.useDynamicScope) {
				 scope = fnOrScript.getParentScope();
			 }
			 else {
				 scope = callerScope;
			 }
			 if (useActivation) {
				 scope = ScriptRuntime.createFunctionActivation( fnOrScript, scope, args);
			 }
		 }
		 else {
			 scope = callerScope;
			 ScriptRuntime.initScript(fnOrScript, thisObj, cx, scope, fnOrScript.idata.evalScriptFlag);
		 }
		 if (idata.itsNestedFunctions != null) {
			 if (idata.itsFunctionType != 0 && !idata.itsNeedsActivation) Kit.codeBug();
			 for (int i = 0;
			 i < idata.itsNestedFunctions.length;
			 i++) {
				 InterpreterData fdata = idata.itsNestedFunctions[i];
				 if (fdata.itsFunctionType == FunctionNode.FUNCTION_STATEMENT) {
					 initFunction(cx, scope, fnOrScript, i);
				 }
			 }
		 }
		 Scriptable[] scriptRegExps = null;
		 if (idata.itsRegExpLiterals != null) {
			 if (idata.itsFunctionType != 0) {
				 scriptRegExps = fnOrScript.functionRegExps;
			 }
			 else {
				 scriptRegExps = fnOrScript.createRegExpWraps(cx, scope);
			 }
		 }
		 int emptyStackTop = idata.itsMaxVars + idata.itsMaxLocals - 1;
		 int maxFrameArray = idata.itsMaxFrameArray;
		 if (maxFrameArray != emptyStackTop + idata.itsMaxStack + 1) Kit.codeBug();
		 Object[] stack;
		 double[] sDbl;
		 boolean stackReuse;
		 if (frame.stack != null && maxFrameArray <= frame.stack.length) {
			 stackReuse = true;
			 stack = frame.stack;
			 sDbl = frame.sDbl;
		 }
		 else {
			 stackReuse = false;
			 stack = new Object[maxFrameArray];
			 sDbl = new double[maxFrameArray];
		 }
		 int definedArgs = idata.argCount;
		 if (definedArgs > argCount) {
			 definedArgs = argCount;
		 }
		 frame.parentFrame = parentFrame;
		 frame.frameIndex = (parentFrame == null) ? 0 : parentFrame.frameIndex + 1;
		 if(frame.frameIndex > cx.getMaximumInterpreterStackDepth()) {
			 throw Context.reportRuntimeError(""Exceeded maximum stack depth"");
		 }
		 frame.frozen = false;
		 frame.fnOrScript = fnOrScript;
		 frame.idata = idata;
		 frame.stack = stack;
		 frame.sDbl = sDbl;
		 frame.varSource = frame;
		 frame.localShift = idata.itsMaxVars;
		 frame.emptyStackTop = emptyStackTop;
		 frame.debuggerFrame = debuggerFrame;
		 frame.useActivation = useActivation;
		 frame.thisObj = thisObj;
		 frame.scriptRegExps = scriptRegExps;
		 frame.result = Undefined.instance;
		 frame.pc = 0;
		 frame.pcPrevBranch = 0;
		 frame.pcSourceLineStart = idata.firstLinePC;
		 frame.scope = scope;
		 frame.savedStackTop = emptyStackTop;
		 frame.savedCallOp = 0;
		 System.arraycopy(args, argShift, stack, 0, definedArgs);
		 if (argsDbl != null) {
			 System.arraycopy(argsDbl, argShift, sDbl, 0, definedArgs);
		 }
		 for (int i = definedArgs;
		 i != idata.itsMaxVars;
		 ++i) {
			 stack[i] = Undefined.instance;
		 }
		 if (stackReuse) {
			 for (int i = emptyStackTop + 1;
			 i != stack.length;
			 ++i) {
				 stack[i] = null;
			 }
		 }
		 enterFrame(cx, frame, args);
	 }
	 private static boolean isFrameEnterExitRequired(CallFrame frame) {
		 return frame.debuggerFrame != null || frame.idata.itsNeedsActivation;
	 }
	 private static void enterFrame(Context cx, CallFrame frame, Object[] args) {
		 if (frame.debuggerFrame != null) {
			 frame.debuggerFrame.onEnter(cx, frame.scope, frame.thisObj, args);
		 }
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.enterActivationFunction(cx, frame.scope);
		 }
	 }
	 private static void exitFrame(Context cx, CallFrame frame, Object throwable) {
		 if (frame.idata.itsNeedsActivation) {
			 ScriptRuntime.exitActivationFunction(cx);
		 }
		 if (frame.debuggerFrame != null) {
			 try {
				 if (throwable instanceof Throwable) {
					 frame.debuggerFrame.onExit(cx, true, throwable);
				 }
				 else {
					 Object result;
					 ContinuationJump cjump = (ContinuationJump)throwable;
					 if (cjump == null) {
						 result = frame.result;
					 }
					 else {
						 result = cjump.result;
					 }
					 if (result == UniqueTag.DOUBLE_MARK) {
						 double resultDbl;
						 if (cjump == null) {
							 resultDbl = frame.resultDbl;
						 }
						 else {
							 resultDbl = cjump.resultDbl;
						 }
						 result = ScriptRuntime.wrapNumber(resultDbl);
					 }
					 frame.debuggerFrame.onExit(cx, false, result);
				 }
			 }
			 catch (Throwable ex) {
				 System.err.println(""RHINO USAGE WARNING: onExit terminated with exception"");
				 ex.printStackTrace(System.err);
			 }
		 }
	 }
	 private static void setCallResult(CallFrame frame, Object callResult, double callResultDbl) {
		 if (frame.savedCallOp == Token.CALL) {
			 frame.stack[frame.savedStackTop] = callResult;
			 frame.sDbl[frame.savedStackTop] = callResultDbl;
		 }
		 else if (frame.savedCallOp == Token.NEW) {
			 if (callResult instanceof Scriptable) {
				 frame.stack[frame.savedStackTop] = callResult;
			 }
		 }
		 else {
			 Kit.codeBug();
		 }
		 frame.savedCallOp = 0;
	 }
	 private static void captureContinuation(Context cx, CallFrame frame, int stackTop) {
		 Continuation c = new Continuation();
		 ScriptRuntime.setObjectProtoAndParent( c, ScriptRuntime.getTopCallScope(cx));
		 CallFrame x = frame.parentFrame;
		 while (x != null && !x.frozen) {
			 x.frozen = true;
			 for (int i = x.savedStackTop + 1;
			 i != x.stack.length;
			 ++i) {
				 x.stack[i] = null;
			 }
			 if (x.savedCallOp == Token.CALL) {
				 x.stack[x.savedStackTop] = null;
			 }
			 else {
				 if (x.savedCallOp != Token.NEW) Kit.codeBug();
			 }
			 x = x.parentFrame;
		 }
		 c.initImplementation(frame.parentFrame);
		 frame.stack[stackTop] = c;
	 }
	 private static int stack_int32(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 double value;
		 if (x == UniqueTag.DOUBLE_MARK) {
			 value = frame.sDbl[i];
		 }
		 else {
			 value = ScriptRuntime.toNumber(x);
		 }
		 return ScriptRuntime.toInt32(value);
	 }
	 private static double stack_double(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x != UniqueTag.DOUBLE_MARK) {
			 return ScriptRuntime.toNumber(x);
		 }
		 else {
			 return frame.sDbl[i];
		 }
	 }
	 private static boolean stack_boolean(CallFrame frame, int i) {
		 Object x = frame.stack[i];
		 if (x == Boolean.TRUE) {
			 return true;
		 }
		 else if (x == Boolean.FALSE) {
			 return false;
		 }
		 else if (x == UniqueTag.DOUBLE_MARK) {
			 double d = frame.sDbl[i];
			 return d == d && d != 0.0;
		 }
		 else if (x == null || x == Undefined.instance) {
			 return false;
		 }
		 else if (x instanceof Number) {
			 double d = ((Number)x).doubleValue();
			 return (d == d && d != 0.0);
		 }
		 else if (x instanceof Boolean) {
			 return ((Boolean)x).booleanValue();
		 }
		 else {
			 return ScriptRuntime.toBoolean(x);
		 }
	 }
	 private static void do_add(Object[] stack, double[] sDbl, int stackTop, Context cx) {
		 Object rhs = stack[stackTop + 1];
		 Object lhs = stack[stackTop];
		 double d;
		 boolean leftRightOrder;
		 if (rhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop + 1];
			 if (lhs == UniqueTag.DOUBLE_MARK) {
				 sDbl[stackTop] += d;
				 return;
			 }
			 leftRightOrder = true;
		 }
		 else if (lhs == UniqueTag.DOUBLE_MARK) {
			 d = sDbl[stackTop];
			 lhs = rhs;
			 leftRightOrder = false;
		 }
		 else {
			 if (lhs instanceof Scriptable || rhs instanceof Scriptable) {
				 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
			 }
			 else if (lhs instanceof String) {
				 String lstr = (String)lhs;
				 String rstr = ScriptRuntime.toString(rhs);
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else if (rhs instanceof String) {
				 String lstr = ScriptRuntime.toString(lhs);
				 String rstr = (String)rhs;
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
				 double rDbl = (rhs instanceof Number) ? ((Number)rhs).doubleValue() : ScriptRuntime.toNumber(rhs);
				 stack[stackTop] = UniqueTag.DOUBLE_MARK;
				 sDbl[stackTop] = lDbl + rDbl;
			 }
			 return;
		 }
		 if (lhs instanceof Scriptable) {
			 rhs = ScriptRuntime.wrapNumber(d);
			 if (!leftRightOrder) {
				 Object tmp = lhs;
				 lhs = rhs;
				 rhs = tmp;
			 }
			 stack[stackTop] = ScriptRuntime.add(lhs, rhs, cx);
		 }
		 else if (lhs instanceof String) {
			 String lstr = (String)lhs;
			 String rstr = ScriptRuntime.toString(d);
			 if (leftRightOrder) {
				 stack[stackTop] = lstr.concat(rstr);
			 }
			 else {
				 stack[stackTop] = rstr.concat(lstr);
			 }
		 }
		 else {
			 double lDbl = (lhs instanceof Number) ? ((Number)lhs).doubleValue() : ScriptRuntime.toNumber(lhs);
			 stack[stackTop] = UniqueTag.DOUBLE_MARK;
			 sDbl[stackTop] = lDbl + d;
		 }
	 }
	 private static Object[] getArgsArray(Object[] stack, double[] sDbl, int shift, int count) {
		 if (count == 0) {
			 return ScriptRuntime.emptyArgs;
		 }
		 Object[] args = new Object[count];
		 for (int i = 0;
		 i != count;
		 ++i, ++shift) {
			 Object val = stack[shift];
			 if (val == UniqueTag.DOUBLE_MARK) {
				 val = ScriptRuntime.wrapNumber(sDbl[shift]);
			 }
			 args[i] = val;
		 }
		 return args;
	 }
	 private static void addInstructionCount(Context cx, CallFrame frame, int extra) {
		 cx.instructionCount += frame.pc - frame.pcPrevBranch + extra;
		 if (cx.instructionCount > cx.instructionThreshold) {
			 cx.observeInstructionCount(cx.instructionCount);
			 cx.instructionCount = 0;
		 }
	 }
}",1,0,0,0
"public class BehaviorsUtil{
	public static <M extends IBehavior> List<IBehavior> getBehaviors(Component component,Class<M> type){
		List<IBehavior> behaviors = component.getBehaviors();
		if (behaviors == null){
			return Collections.emptyList();
		}
		List<IBehavior> subset = new ArrayList<IBehavior>(behaviors.size());
		for (IBehavior behavior : behaviors){
			if (behavior != null){
				if (type == null){
					subset.add(behavior);
				}
				else if (type.isAssignableFrom(behavior.getClass())){
					subset.add(type.cast(behavior));
				}
			}
		}
		return Collections.unmodifiableList(subset);
	}
}",0,0,0,0
"public boolean rename(File src, File dst) throws IOException {
	 if (isDirectory(src)) {
		 return renameRaw(src, dst);
	 }
	 else {
		 boolean value = renameRaw(src, dst);
		 File checkFile = getChecksumFile(src);
		 if (exists(checkFile)) renameRaw(checkFile, getChecksumFile(dst));
		 return value;
	 }
 }",0,0,0,0
"public NeuronProperties(TransferFunctionType transferFunctionType, boolean useBias) {
	 initKeys();
	 this.setProperty(""inputFunction"", WeightedSum.class);
	 this.setProperty(""transferFunction"", transferFunctionType.getTypeClass());
	 this.setProperty(""useBias"", useBias);
	 this.setProperty(""neuronType"", Neuron.class);
 }",0,0,0,0
"public class PropertyListRecord extends SimpleRecord{
	private final DesignElement element;
	private final ElementPropertyDefn propDefn;
	private final StructureContext context;
	private final List<Object> list;
	private final Object value;
	protected final boolean isAdd;
	private final int posn;
	public PropertyListRecord( DesignElement element, StructureContext context, int posn ){
		this.element = element;
		this.isAdd = false;
		this.context = context;
		this.propDefn = context.getElementProp( );
		assert element == context.getElement( );
		Object valueContainer = context.getValueContainer( );
		if ( valueContainer instanceof Structure )list = (List) ( (Structure) valueContainer ).getLocalProperty(null, (PropertyDefn) context.getPropDefn( ) );
		elselist = (List) ( (DesignElement) valueContainer ).getLocalProperty(null, (ElementPropertyDefn) context.getPropDefn( ) );
		this.posn = posn;
		this.value = list.get( posn );
		label = CommandLabelFactory.getCommandLabel(MessageConstants.CHANGE_PROPERTY_MESSAGE, new String[]{
		context.getElementProp( ).getDisplayName( )}
		 );
	}
	public PropertyListRecord( DesignElement element, StructureContext context,Object toAdd, int posn ){
		this.element = element;
		this.isAdd = true;
		this.context = context;
		this.value = toAdd;
		this.propDefn = (ElementPropertyDefn) context.getElementProp( );
		assert element == context.getElement( );
		Object valueContainer = context.getValueContainer( );
		if ( valueContainer instanceof Structure )list = (List) ( (Structure) valueContainer ).getLocalProperty(null, (PropertyDefn) context.getPropDefn( ) );
		elselist = (List) ( (DesignElement) valueContainer ).getLocalProperty(null, (ElementPropertyDefn) context.getPropDefn( ) );
		this.posn = posn;
		label = CommandLabelFactory.getCommandLabel(MessageConstants.CHANGE_PROPERTY_MESSAGE, new String[]{
		context.getElementProp( ).getDisplayName( )}
		 );
	}
	public PropertyListRecord( DesignElement element,ElementPropertyDefn propDefn, List theList, Object toAdd, int posn ){
		this.element = element;
		this.isAdd = true;
		this.value = toAdd;
		this.list = theList;
		this.context = null;
		this.propDefn = propDefn;
		this.posn = posn;
		label = CommandLabelFactory.getCommandLabel(MessageConstants.CHANGE_PROPERTY_MESSAGE, new String[]{
		propDefn.getDisplayName( )}
		 );
	}
	public PropertyListRecord( DesignElement element,ElementPropertyDefn propDefn, List theList, int posn ){
		this.element = element;
		this.isAdd = false;
		this.list = theList;
		this.posn = posn;
		this.value = list.get( posn );
		this.context = new StructureContext( element, propDefn, null );
		this.propDefn = propDefn;
		label = CommandLabelFactory.getCommandLabel(MessageConstants.CHANGE_PROPERTY_MESSAGE, new String[]{
		propDefn.getDisplayName( )}
		 );
	}
	protected void perform( boolean undo ){
		boolean doAdd = ( undo && !isAdd || !undo && isAdd );
		if ( doAdd ){
			if ( !( value instanceof Structure ) ){
				list.add( posn, value );
				return;
			}
			context.add( posn, (Structure) value );
		}
		else{
			if ( !( value instanceof Structure ) ){
				list.remove( posn );
				return;
			}
			context.remove( posn );
			Object localValue = context.getLocalValue( element.getRoot( ) );
			if ( localValue instanceof List ){
				List listValue = (List) localValue;
				if ( listValue.isEmpty( ) )context.clearValue( );
			}
		}
	}
	public DesignElement getTarget( ){
		if ( eventTarget != null )return eventTarget.getElement( );
		return element;
	}
	public NotificationEvent getEvent( ){
		if ( eventTarget != null )return new PropertyEvent( eventTarget.getElement( ), eventTarget.getPropName( ) );
		return new PropertyEvent( element, propDefn.getName( ) );
	}
	protected List<RecordTask> getPostTasks( ){
		List<RecordTask> retList = new ArrayList<RecordTask>( );
		retList.addAll( super.getPostTasks( ) );
		retList.add( new NotificationRecordTask( element, getEvent( ) ) );
		if ( value != null && value instanceof IStructure&& ( (IStructure) value ).isReferencable( ) ){
			ReferencableStructure refValue = (ReferencableStructure) value;
			retList.add( new NotificationRecordTask( refValue, getEvent( ) ) );
		}
		return retList;
	}
}",0,0,0,0
"public static void createMultiThreadedHttpConnectionManager(HttpClient httpClient) {
	 MultiThreadedHttpConnectionManager connectionManager = new MultiThreadedHttpConnectionManager();
	 connectionManager.getParams().setDefaultMaxConnectionsPerHost(Settings.getIntProperty(""davmail.exchange.maxConnections"",100));
	 connectionManager.getParams().setConnectionTimeout(10000);
	 connectionManager.getParams().setSoTimeout(120000);
	 synchronized (LOCK) {
		 httpConnectionManagerThread.addConnectionManager(connectionManager);
	 }
	 httpClient.setHttpConnectionManager(connectionManager);
 }",0,0,0,0
"private boolean isLengthAndPrefixCorrect(String creditCardNumber){
	if (creditCardNumber != null){
		creditCardNumber = creditCardNumber.replaceAll(""[ -]"", """");
	}
	if (creditCardNumber != null && creditCardNumber.length() >= 12 &&creditCardNumber.length() <= 19){
		if (isAmericanExpress(creditCardNumber)){
			return true;
		}
		else if (isChinaUnionPay(creditCardNumber)){
			return true;
		}
		else if (isDinersClubCarteBlanche(creditCardNumber)){
			return true;
		}
		else if (isDinersClubInternational(creditCardNumber)){
			return true;
		}
		else if (isDinersClubUsAndCanada(creditCardNumber)){
			return true;
		}
		else if (isDiscoverCard(creditCardNumber)){
			return true;
		}
		else if (isJCB(creditCardNumber)){
			return true;
		}
		else if (isLaser(creditCardNumber)){
			return true;
		}
		else if (isMaestro(creditCardNumber)){
			return true;
		}
		else if (isMastercard(creditCardNumber)){
			return true;
		}
		else if (isSolo(creditCardNumber)){
			return true;
		}
		else if (isSwitch(creditCardNumber)){
			return true;
		}
		else if (isVisa(creditCardNumber)){
			return true;
		}
		else if (isVisaElectron(creditCardNumber)){
			return true;
		}
		else if (isUnknown(creditCardNumber)){
			return true;
		}
	}
	return false;
}",0,0,0,0
"public void setIncludes(String includes) {
	 fileset.setIncludes(includes);
 }",0,0,0,0
"public class Book {
	 private int id;
	 private String name;
	 public Book() {
	}
	 public Book(int bookId, String name) {
		 this.id = bookId;
		 this.name = name;
	 }
	 public int getId() {
		 return id;
	 }
	 public void setId(int id) {
		 this.id = id;
	 }
	 public String getName() {
		 return name;
	 }
	 public void setName(String name) {
		 this.name = name;
	 }
}",0,1,0,0
"public CommitLogSegment.CommitLogContext write(RowMutation rowMutation, Object serializedRow) throws IOException {
	 long currentPosition = -1L;
	 try {
		 currentPosition = logWriter.getFilePointer();
		 CommitLogSegment.CommitLogContext cLogCtx = new CommitLogSegment.CommitLogContext(currentPosition);
		 for (ColumnFamily columnFamily : rowMutation.getColumnFamilies()) {
			 CFMetaData cfm = DatabaseDescriptor.getCFMetaData(columnFamily.id());
			 if (cfm == null) {
				 logger.error(""Attempted to write commit log entry for unrecognized column family: "" + columnFamily.id());
			 }
			 else {
				 Integer id = cfm.cfId;
				 if (!header.isDirty(id)) {
					 header.turnOn(id, logWriter.getFilePointer());
					 writeHeader();
				 }
			 }
		 }
		 byte[] bytes;
		 Checksum checksum = new CRC32();
		 if (serializedRow instanceof DataOutputBuffer) {
			 bytes = ((DataOutputBuffer) serializedRow).getData();
		 }
		 else {
			 assert serializedRow instanceof byte[];
			 bytes = (byte[]) serializedRow;
		 }
		 checksum.update(bytes.length);
		 logWriter.writeInt(bytes.length);
		 logWriter.writeLong(checksum.getValue());
		 logWriter.write(bytes);
		 checksum.update(bytes, 0, bytes.length);
		 logWriter.writeLong(checksum.getValue());
		 return cLogCtx;
	 }
	 catch (IOException e) {
		 if (currentPosition != -1) logWriter.seek(currentPosition);
		 throw e;
	 }
 }",0,0,0,0
"public final Element getDocumentElement() {
	 int dochandle=dtm.getDocument();
	 int elementhandle=DTM.NULL;
	 for(int kidhandle=dtm.getFirstChild(dochandle);
	 kidhandle!=DTM.NULL;
	 kidhandle=dtm.getNextSibling(kidhandle)) {
		 switch(dtm.getNodeType(kidhandle)) {
			 case Node.ELEMENT_NODE: if(elementhandle!=DTM.NULL) {
				 elementhandle=DTM.NULL;
				 kidhandle=dtm.getLastChild(dochandle);
			 }
			 else elementhandle=kidhandle;
			 break;
			 case Node.COMMENT_NODE: case Node.PROCESSING_INSTRUCTION_NODE: case Node.DOCUMENT_TYPE_NODE: break;
			 default: elementhandle=DTM.NULL;
			 kidhandle=dtm.getLastChild(dochandle);
			 break;
		 }
	 }
	 if(elementhandle==DTM.NULL) throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
	 else return (Element)(dtm.getNode(elementhandle));
 }",0,0,1,0
"public class XmlParser {
	 private final static boolean USE_CHEATS = true;
	 public XmlParser () {
	 }
	 public void setHandler (XmlHandler handler) {
		 this.handler = handler;
	 }
	 public void parse (String systemId, String publicId, String encoding) throws java.lang.Exception {
		 doParse(systemId, publicId, null, null, encoding);
	 }
	 public void parse (String systemId, String publicId, InputStream stream, String encoding) throws java.lang.Exception {
		 doParse(systemId, publicId, null, stream, encoding);
	 }
	 public void parse (String systemId, String publicId, Reader reader) throws java.lang.Exception {
		 doParse(systemId, publicId, reader, null, null);
	 }
	 private synchronized void doParse (String systemId, String publicId, Reader reader, InputStream stream, String encoding) throws java.lang.Exception {
		 basePublicId = publicId;
		 baseURI = systemId;
		 baseReader = reader;
		 baseInputStream = stream;
		 initializeVariables();
		 setInternalEntity(intern(""amp""), ""&#38;
		"");
		 setInternalEntity(intern(""lt""), ""&#60;
		"");
		 setInternalEntity(intern(""gt""), ""&#62;
		"");
		 setInternalEntity(intern(""apos""), ""&#39;
		"");
		 setInternalEntity(intern(""quot""), ""&#34;
		"");
		 if (handler != null) {
			 handler.startDocument();
		 }
		 pushURL(""[document]"", basePublicId, baseURI, baseReader, baseInputStream, encoding);
		 parseDocument();
		 if (handler != null) {
			 handler.endDocument();
		 }
		 cleanupVariables();
	 }
	 public final static int CONTENT_UNDECLARED = 0;
	 public final static int CONTENT_ANY = 1;
	 public final static int CONTENT_EMPTY = 2;
	 public final static int CONTENT_MIXED = 3;
	 public final static int CONTENT_ELEMENTS = 4;
	 public final static int ENTITY_UNDECLARED = 0;
	 public final static int ENTITY_INTERNAL = 1;
	 public final static int ENTITY_NDATA = 2;
	 public final static int ENTITY_TEXT = 3;
	 public final static int ATTRIBUTE_UNDECLARED = 0;
	 public final static int ATTRIBUTE_CDATA = 1;
	 public final static int ATTRIBUTE_ID = 2;
	 public final static int ATTRIBUTE_IDREF = 3;
	 public final static int ATTRIBUTE_IDREFS = 4;
	 public final static int ATTRIBUTE_ENTITY = 5;
	 public final static int ATTRIBUTE_ENTITIES = 6;
	 public final static int ATTRIBUTE_NMTOKEN = 7;
	 public final static int ATTRIBUTE_NMTOKENS = 8;
	 public final static int ATTRIBUTE_ENUMERATED = 9;
	 public final static int ATTRIBUTE_NOTATION = 10;
	 private static Hashtable attributeTypeHash;
	 static {
		 attributeTypeHash = new Hashtable();
		 attributeTypeHash.put(""CDATA"", new Integer(ATTRIBUTE_CDATA));
		 attributeTypeHash.put(""ID"", new Integer(ATTRIBUTE_ID));
		 attributeTypeHash.put(""IDREF"", new Integer(ATTRIBUTE_IDREF));
		 attributeTypeHash.put(""IDREFS"", new Integer(ATTRIBUTE_IDREFS));
		 attributeTypeHash.put(""ENTITY"", new Integer(ATTRIBUTE_ENTITY));
		 attributeTypeHash.put(""ENTITIES"", new Integer(ATTRIBUTE_ENTITIES));
		 attributeTypeHash.put(""NMTOKEN"", new Integer(ATTRIBUTE_NMTOKEN));
		 attributeTypeHash.put(""NMTOKENS"", new Integer(ATTRIBUTE_NMTOKENS));
		 attributeTypeHash.put(""NOTATION"", new Integer(ATTRIBUTE_NOTATION));
	 }
	 private final static int ENCODING_UTF_8 = 1;
	 private final static int ENCODING_ISO_8859_1 = 2;
	 private final static int ENCODING_UCS_2_12 = 3;
	 private final static int ENCODING_UCS_2_21 = 4;
	 private final static int ENCODING_UCS_4_1234 = 5;
	 private final static int ENCODING_UCS_4_4321 = 6;
	 private final static int ENCODING_UCS_4_2143 = 7;
	 private final static int ENCODING_UCS_4_3412 = 8;
	 public final static int ATTRIBUTE_DEFAULT_UNDECLARED = 0;
	 public final static int ATTRIBUTE_DEFAULT_SPECIFIED = 1;
	 public final static int ATTRIBUTE_DEFAULT_IMPLIED = 2;
	 public final static int ATTRIBUTE_DEFAULT_REQUIRED = 3;
	 public final static int ATTRIBUTE_DEFAULT_FIXED = 4;
	 private final static int INPUT_NONE = 0;
	 private final static int INPUT_INTERNAL = 1;
	 private final static int INPUT_EXTERNAL = 2;
	 private final static int INPUT_STREAM = 3;
	 private final static int INPUT_BUFFER = 4;
	 private final static int INPUT_READER = 5;
	 private final static int LIT_CHAR_REF = 1;
	 private final static int LIT_ENTITY_REF = 2;
	 private final static int LIT_PE_REF = 4;
	 private final static int LIT_NORMALIZE = 8;
	 private final static int CONTEXT_NONE = 0;
	 private final static int CONTEXT_DTD = 1;
	 private final static int CONTEXT_ENTITYVALUE = 2;
	 private final static int CONTEXT_ATTRIBUTEVALUE = 3;
	 void error (String message, String textFound, String textExpected) throws java.lang.Exception {
		 errorCount++;
		 if (textFound != null) {
			 message = message + "" (found \"""" + textFound + ""\"")"";
		 }
		 if (textExpected != null) {
			 message = message + "" (expected \"""" + textExpected + ""\"")"";
		 }
		 if (handler != null) {
			 String uri = null;
			 if (externalEntity != null) {
				uri = externalEntity.getURL().toString();
			 }
			 handler.error(message, uri, line, column);
		 }
	 }
	 void error (String message, char textFound, String textExpected) throws java.lang.Exception {
		 error(message, new Character(textFound).toString(), textExpected);
	 }
	 void parseDocument () throws java.lang.Exception {
		 char c;
		 parseProlog();
		 require('<');
		 parseElement();
		 try {
			 parseMisc();
			 c=readCh();
			 error(""unexpected characters after document end"",c,null);
		 }
		 catch (EOFException e) {
			return;
		}
	 }
	 void parseComment () throws java.lang.Exception {
		 skipUntil(""-->"");
	 }
	 void parsePI () throws java.lang.Exception {
		 String name;
		 name = readNmtoken(true);
		 if (!tryRead(""?>"")) {
			 requireWhitespace();
			 parseUntil(""?>"");
		 }
		 if (handler != null) {
			 handler.processingInstruction(name, dataBufferToString());
		 }
	 }
	 void parseCDSect () throws java.lang.Exception {
		 parseUntil(""]]>"");
	 }
	 void parseProlog () throws java.lang.Exception {
		 parseMisc();
		 if (tryRead(""<!DOCTYPE"")) {
			 parseDoctypedecl();
			 parseMisc();
		 }
	 }
	 void parseXMLDecl (boolean ignoreEncoding) throws java.lang.Exception {
		 String version;
		 String encodingName = null;
		 String standalone = null;
		 require(""version"");
		 parseEq();
		 version = readLiteral(0);
		 if (!version.equals(""1.0"")) {
			 error(""unsupported XML version"", version, ""1.0"");
		 }
		 skipWhitespace();
		 if (tryRead(""encoding"")) {
			 parseEq();
			 encodingName = readLiteral(0);
			 checkEncoding(encodingName, ignoreEncoding);
		 }
		 skipWhitespace();
		 if (tryRead(""standalone"")) {
			 parseEq();
			 standalone = readLiteral(0);
		 }
		 skipWhitespace();
		 require(""?>"");
	 }
	 void parseTextDecl (boolean ignoreEncoding) throws java.lang.Exception {
		 String encodingName = null;
		 if (tryRead(""version"")) {
			 String version;
			 parseEq();
			 version = readLiteral(0);
			 if (!version.equals(""1.0"")) {
				error(""unsupported XML version"", version, ""1.0"");
			 }
			 requireWhitespace();
		 }
		 require(""encoding"");
		 parseEq();
		 encodingName = readLiteral(0);
		 checkEncoding(encodingName, ignoreEncoding);
		 skipWhitespace();
		 require(""?>"");
	 }
	 void checkEncoding (String encodingName, boolean ignoreEncoding) throws java.lang.Exception {
		 encodingName = encodingName.toUpperCase();
		 if (ignoreEncoding) {
			 return;
		 }
		 switch (encoding) {
			 case ENCODING_UTF_8: if (encodingName.equals(""ISO-8859-1"")) {
				encoding = ENCODING_ISO_8859_1;
			 }
			 else if (!encodingName.equals(""UTF-8"")) {
				error(""unsupported 8-bit encoding"", encodingName, ""UTF-8 or ISO-8859-1"");
			 }
			 break;
			 case ENCODING_UCS_2_12: case ENCODING_UCS_2_21: if (!encodingName.equals(""ISO-10646-UCS-2"") && !encodingName.equals(""UTF-16"")) {
				error(""unsupported 16-bit encoding"", encodingName, ""ISO-10646-UCS-2"");
			 }
			 break;
			 case ENCODING_UCS_4_1234: case ENCODING_UCS_4_4321: case ENCODING_UCS_4_2143: case ENCODING_UCS_4_3412: if (!encodingName.equals(""ISO-10646-UCS-4"")) {
				error(""unsupported 32-bit encoding"", encodingName, ""ISO-10646-UCS-4"");
			 }
		 }
	 }
	 void parseMisc () throws java.lang.Exception {
		 while (true) {
			 skipWhitespace();
			 if (tryRead(""<?"")) {
				parsePI();
			}
			 else if (tryRead(""<!--"")) {
				parseComment();
			}
			 else {
				return;
			}
		 }
	 }
	 void parseDoctypedecl () throws java.lang.Exception {
		 char c;
		 String doctypeName, ids[];
		 requireWhitespace();
		 doctypeName = readNmtoken(true);
		 skipWhitespace();
		 ids = readExternalIds(false);
		 skipWhitespace();
		 if (tryRead('[')) {
			 while (true) {
				context = CONTEXT_DTD;
				skipWhitespace();
				context = CONTEXT_NONE;
				if (tryRead(']')) {
					 break;
				}
				 else {
					 context = CONTEXT_DTD;
					 parseMarkupdecl();
					 context = CONTEXT_NONE;
				}
			 }
		 }
		 if (ids[1] != null) {
			 pushURL(""[external subset]"", ids[0], ids[1], null, null, null);
			 while (true) {
				context = CONTEXT_DTD;
				skipWhitespace();
				context = CONTEXT_NONE;
				if (tryRead('>')) {
					 break;
				}
				 else {
					 context = CONTEXT_DTD;
					 parseMarkupdecl();
					 context = CONTEXT_NONE;
				}
			 }
		 }
		 else {
			 skipWhitespace();
			 require('>');
		 }
		 if (handler != null) {
			 handler.doctypeDecl(doctypeName, ids[0], ids[1]);
		 }
	 }
	 void parseMarkupdecl () throws java.lang.Exception {
		 if (tryRead(""<!ELEMENT"")) {
			 parseElementdecl();
		 }
		 else if (tryRead(""<!ATTLIST"")) {
			 parseAttlistDecl();
		 }
		 else if (tryRead(""<!ENTITY"")) {
			 parseEntityDecl();
		 }
		 else if (tryRead(""<!NOTATION"")) {
			 parseNotationDecl();
		 }
		 else if (tryRead(""<?"")) {
			 parsePI();
		 }
		 else if (tryRead(""<!--"")) {
			 parseComment();
		 }
		 else if (tryRead(""<!["")) {
			 parseConditionalSect();
		 }
		 else {
			 error(""expected markup declaration"", null, null);
		 }
	 }
	 void parseElement () throws java.lang.Exception {
		 String gi;
		 char c;
		 int oldElementContent = currentElementContent;
		 String oldElement = currentElement;
		 tagAttributePos = 0;
		 gi = readNmtoken(true);
		 currentElement = gi;
		 currentElementContent = getElementContentType(gi);
		 if (currentElementContent == CONTENT_UNDECLARED) {
			 currentElementContent = CONTENT_ANY;
		 }
		 skipWhitespace();
		 c = readCh();
		 while (c != '/' && c != '>') {
			 unread(c);
			 parseAttribute(gi);
			 skipWhitespace();
			 c = readCh();
		 }
		 unread(c);
		 Enumeration atts = declaredAttributes(gi);
		 if (atts != null) {
			 String aname;
			 loop: while (atts.hasMoreElements()) {
				 aname = (String)atts.nextElement();
				 for (int i = 0;
				 i < tagAttributePos;
				 i++) {
					if (tagAttributes[i] == aname) {
						 continue loop;
					}
				 }
				 if (handler != null) {
					handler.attribute(aname, getAttributeExpandedValue(gi, aname), false);
				 }
			 }
		 }
		 c = readCh();
		 switch (c) {
			 case '>': if (handler != null) {
				handler.startElement(gi);
			 }
			 parseContent();
			 break;
			 case '/': require('>');
			 if (handler != null) {
				handler.startElement(gi);
				handler.endElement(gi);
			 }
			 break;
		 }
		 currentElement = oldElement;
		 currentElementContent = oldElementContent;
	 }
	 void parseAttribute (String name) throws java.lang.Exception {
		 String aname;
		 int type;
		 String value;
		 aname = readNmtoken(true).intern();
		 type = getAttributeDefaultValueType(name, aname);
		 parseEq();
		 if (type == ATTRIBUTE_CDATA || type == ATTRIBUTE_UNDECLARED) {
			 value = readLiteral(LIT_CHAR_REF | LIT_ENTITY_REF);
		 }
		 else {
			 value = readLiteral(LIT_CHAR_REF | LIT_ENTITY_REF | LIT_NORMALIZE);
		 }
		 if (handler != null) {
			 handler.attribute(aname, value, true);
		 }
		 dataBufferPos = 0;
		 if (tagAttributePos == tagAttributes.length) {
			 String newAttrib[] = new String[tagAttributes.length * 2];
			 System.arraycopy(tagAttributes, 0, newAttrib, 0, tagAttributePos);
			 tagAttributes = newAttrib;
		 }
		 tagAttributes[tagAttributePos++] = aname;
	 }
	 void parseEq () throws java.lang.Exception {
		 skipWhitespace();
		 require('=');
		 skipWhitespace();
	 }
	 void parseETag () throws java.lang.Exception {
		 String name;
		 name = readNmtoken(true);
		 if (name != currentElement) {
			 error(""mismatched end tag"", name, currentElement);
		 }
		 skipWhitespace();
		 require('>');
		 if (handler != null) {
			 handler.endElement(name);
		 }
	 }
	 void parseContent () throws java.lang.Exception {
		 String data;
		 char c;
		 while (true) {
			 switch (currentElementContent) {
				 case CONTENT_ANY: case CONTENT_MIXED:parsePCData();
				break;
				 case CONTENT_ELEMENTS:parseWhitespace();
				break;
			 }
			 c = readCh();
			 switch (c) {
				 case '&':c = readCh();
				if (c == '#') {
					 parseCharRef();
				}
				 else {
					 unread(c);
					 parseEntityRef(true);
				}
				break;
				 case '<':c = readCh();
				switch (c) {
					case '!': c = readCh();
					 switch (c) {
						 case '-': require('-');
						 parseComment();
						 break;
						 case '[': require(""CDATA["");
						 parseCDSect();
						 break;
						 default: error(""expected comment or CDATA section"", c, null);
						 break;
					 }
					 break;
					case '?': dataBufferFlush();
					 parsePI();
					 break;
					case '/': dataBufferFlush();
					 parseETag();
					 return;
					default: dataBufferFlush();
					 unread(c);
					 parseElement();
					 break;
				}
			 }
		 }
	 }
	 void parseElementdecl () throws java.lang.Exception {
		 String name;
		 requireWhitespace();
		 name = readNmtoken(true);
		 requireWhitespace();
		 parseContentspec(name);
		 skipWhitespace();
		 require('>');
	 }
	 void parseContentspec (String name) throws java.lang.Exception {
		 if (tryRead(""EMPTY"")) {
			 setElement(name, CONTENT_EMPTY, null, null);
			 return;
		 }
		 else if (tryRead(""ANY"")) {
			 setElement(name, CONTENT_ANY, null, null);
			 return;
		 }
		 else {
			 require('(');
			 dataBufferAppend('(');
			 skipWhitespace();
			 if (tryRead(""#PCDATA"")) {
				dataBufferAppend(""#PCDATA"");
				parseMixed();
				setElement(name, CONTENT_MIXED, dataBufferToString(), null);
			 }
			 else {
				parseElements();
				setElement(name, CONTENT_ELEMENTS, dataBufferToString(), null);
			 }
		 }
	 }
	 void parseElements () throws java.lang.Exception {
		 char c;
		 char sep;
		 skipWhitespace();
		 parseCp();
		 skipWhitespace();
		 c = readCh();
		 switch (c) {
			 case ')': dataBufferAppend(')');
			 c = readCh();
			 switch (c) {
				 case '*': case '+': case '?':dataBufferAppend(c);
				break;
				 default:unread(c);
			 }
			 return;
			 case ',': case '|': sep = c;
			 dataBufferAppend(c);
			 break;
			 default: error(""bad separator in content model"", c, null);
			 return;
		 }
		 while (true) {
			 skipWhitespace();
			 parseCp();
			 skipWhitespace();
			 c = readCh();
			 if (c == ')') {
				dataBufferAppend(')');
				break;
			 }
			 else if (c != sep) {
				error(""bad separator in content model"", c, null);
				return;
			 }
			 else {
				dataBufferAppend(c);
			 }
		 }
		 c = readCh();
		 switch (c) {
			 case '?': case '*': case '+': dataBufferAppend(c);
			 return;
			 default: unread(c);
			 return;
		 }
	 }
	 void parseCp () throws java.lang.Exception {
		 char c;
		 if (tryRead('(')) {
			 dataBufferAppend('(');
			 parseElements();
		 }
		 else {
			 dataBufferAppend(readNmtoken(true));
			 c = readCh();
			 switch (c) {
				 case '?': case '*': case '+':dataBufferAppend(c);
				break;
				 default:unread(c);
				break;
			 }
		 }
	 }
	 void parseMixed () throws java.lang.Exception {
		 char c;
		 skipWhitespace();
		 if (tryRead(')')) {
			 dataBufferAppend("")*"");
			 tryRead('*');
			 return;
		 }
		 skipWhitespace();
		 while (!tryRead("")*"")) {
			 require('|');
			 dataBufferAppend('|');
			 skipWhitespace();
			 dataBufferAppend(readNmtoken(true));
			 skipWhitespace();
		 }
		 dataBufferAppend("")*"");
	 }
	 void parseAttlistDecl () throws java.lang.Exception {
		 String elementName;
		 requireWhitespace();
		 elementName = readNmtoken(true);
		 requireWhitespace();
		 while (!tryRead('>')) {
			 parseAttDef(elementName);
			 skipWhitespace();
		 }
	 }
	 void parseAttDef (String elementName) throws java.lang.Exception {
		 String name;
		 int type;
		 String enumeration = null;
		 name = readNmtoken(true);
		 requireWhitespace();
		 type = readAttType();
		 if (type == ATTRIBUTE_ENUMERATED || type == ATTRIBUTE_NOTATION) {
			 enumeration = dataBufferToString();
		 }
		 requireWhitespace();
		 parseDefault(elementName, name, type, enumeration);
	 }
	 int readAttType () throws java.lang.Exception {
		 String typeString;
		 Integer type;
		 if (tryRead('(')) {
			 parseEnumeration();
			 return ATTRIBUTE_ENUMERATED;
		 }
		 else {
			 typeString = readNmtoken(true);
			 if (typeString.equals(""NOTATION"")) {
				parseNotationType();
			 }
			 type = (Integer)attributeTypeHash.get(typeString);
			 if (type == null) {
				error(""illegal attribute type"", typeString, null);
				return ATTRIBUTE_UNDECLARED;
			 }
			 else {
				return type.intValue();
			 }
		 }
	 }
	 void parseEnumeration () throws java.lang.Exception {
		 char c;
		 dataBufferAppend('(');
		 skipWhitespace();
		 dataBufferAppend(readNmtoken(true));
		 skipWhitespace();
		 while (!tryRead(')')) {
			 require('|');
			 dataBufferAppend('|');
			 skipWhitespace();
			 dataBufferAppend(readNmtoken(true));
			 skipWhitespace();
		 }
		 dataBufferAppend(')');
	 }
	 void parseNotationType () throws java.lang.Exception {
		 requireWhitespace();
		 require('(');
		 parseEnumeration();
	 }
	 void parseDefault (String elementName, String name, int type, String enumeration) throws java.lang.Exception {
		 int valueType = ATTRIBUTE_DEFAULT_SPECIFIED;
		 String value = null;
		 boolean normalizeWSFlag;
		 if (tryRead('#')) {
			 if (tryRead(""FIXED"")) {
				valueType = ATTRIBUTE_DEFAULT_FIXED;
				requireWhitespace();
				context = CONTEXT_ATTRIBUTEVALUE;
				value = readLiteral(LIT_CHAR_REF);
				context = CONTEXT_DTD;
			 }
			 else if (tryRead(""REQUIRED"")) {
				valueType = ATTRIBUTE_DEFAULT_REQUIRED;
			 }
			 else if (tryRead(""IMPLIED"")) {
				valueType = ATTRIBUTE_DEFAULT_IMPLIED;
			 }
			 else {
				error(""illegal keyword for attribute default value"", null, null);
			 }
		 }
		 else {
			 context = CONTEXT_ATTRIBUTEVALUE;
			 value = readLiteral(LIT_CHAR_REF);
			 context = CONTEXT_DTD;
		 }
		 setAttribute(elementName, name, type, enumeration, value, valueType);
	 }
	 void parseConditionalSect () throws java.lang.Exception {
		 skipWhitespace();
		 if (tryRead(""INCLUDE"")) {
			 skipWhitespace();
			 require('[');
			 skipWhitespace();
			 while (!tryRead(""]]>"")) {
				parseMarkupdecl();
				skipWhitespace();
			 }
		 }
		 else if (tryRead(""IGNORE"")) {
			 skipWhitespace();
			 require('[');
			 int nesting = 1;
			 char c;
			 for (int nest = 1;
			 nest > 0;
			 ) {
				c = readCh();
				switch (c) {
					case '<': if (tryRead(""!["")) {
						 nest++;
					 }
					case ']': if (tryRead(""]>"")) {
						 nest--;
					 }
				}
			 }
		 }
		 else {
			 error(""conditional section must begin with INCLUDE or IGNORE"", null, null);
		 }
	 }
	 void parseCharRef () throws java.lang.Exception {
		 int value = 0;
		 char c;
		 if (tryRead('x')) {
			 loop1: while (true) {
				c = readCh();
				switch (c) {
					case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case 'a':case 'A':case 'b':case 'B':case 'c':case 'C':case 'd':case 'D':case 'e':case 'E':case 'f':case 'F': value *= 16;
					 value += Integer.parseInt(new Character(c).toString(), 16);
					 break;
					case ';
					': break loop1;
					default: error(""illegal character in character reference"", c, null);
					 break loop1;
				}
			 }
		 }
		 else {
			 loop2: while (true) {
				c = readCh();
				switch (c) {
					case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9': value *= 10;
					 value += Integer.parseInt(new Character(c).toString(), 10);
					 break;
					case ';
					': break loop2;
					default: error(""illegal character in character reference"", c, null);
					 break loop2;
				}
			 }
		 }
		 if (value <= 0x0000ffff) {
			 dataBufferAppend((char)value);
		 }
		 else if (value <= 0x000fffff) {
			 dataBufferAppend((char)(0xd8 | ((value & 0x000ffc00) >> 10)));
			 dataBufferAppend((char)(0xdc | (value & 0x0003ff)));
		 }
		 else {
			 error(""character reference "" + value + "" is too large for UTF-16"", new Integer(value).toString(), null);
		 }
	 }
	 void parseEntityRef (boolean externalAllowed) throws java.lang.Exception {
		 String name;
		 name = readNmtoken(true);
		 require(';
		');
		 switch (getEntityType(name)) {
			 case ENTITY_UNDECLARED: error(""reference to undeclared entity"", name, null);
			 break;
			 case ENTITY_INTERNAL: pushString(name, getEntityValue(name));
			 break;
			 case ENTITY_TEXT: if (externalAllowed) {
				pushURL(name, getEntityPublicId(name),getEntitySystemId(name),null, null, null);
			 }
			 else {
				error(""reference to external entity in attribute value."", name, null);
			 }
			 break;
			 case ENTITY_NDATA: if (externalAllowed) {
				error(""data entity reference in content"", name, null);
			 }
			 else {
				error(""reference to external entity in attribute value."", name, null);
			 }
			 break;
		 }
	 }
	 void parsePEReference (boolean isEntityValue) throws java.lang.Exception {
		 String name;
		 name = ""%"" + readNmtoken(true);
		 require(';
		');
		 switch (getEntityType(name)) {
			 case ENTITY_UNDECLARED: error(""reference to undeclared parameter entity"", name, null);
			 break;
			 case ENTITY_INTERNAL: if (isEntityValue) {
				pushString(name, getEntityValue(name));
			 }
			 else {
				pushString(name, "" "" + getEntityValue(name) + ' ');
			 }
			 break;
			 case ENTITY_TEXT: if (isEntityValue) {
				pushString(null, "" "");
			 }
			 pushURL(name, getEntityPublicId(name), getEntitySystemId(name), null, null, null);
			 if (isEntityValue) {
				pushString(null, "" "");
			 }
			 break;
		 }
	 }
	 void parseEntityDecl () throws java.lang.Exception {
		 char c;
		 boolean peFlag = false;
		 String name, value, notationName, ids[];
		 requireWhitespace();
		 if (tryRead('%')) {
			 peFlag = true;
			 requireWhitespace();
		 }
		 name = readNmtoken(true);
		 if (peFlag) {
			 name = ""%"" + name;
		 }
		 requireWhitespace();
		 c = readCh();
		 unread(c);
		 if (c == '""' || c == '\'') {
			 context = CONTEXT_ENTITYVALUE;
			 value = readLiteral(LIT_CHAR_REF|LIT_PE_REF);
			 context = CONTEXT_DTD;
			 setInternalEntity(name,value);
		 }
		 else {
			 ids = readExternalIds(false);
			 if (ids[1] == null) {
				error(""system identifer missing"", name, null);
			 }
			 skipWhitespace();
			 if (tryRead(""NDATA"")) {
				requireWhitespace();
				notationName = readNmtoken(true);
				setExternalDataEntity(name, ids[0], ids[1], notationName);
			 }
			 else {
				setExternalTextEntity(name, ids[0], ids[1]);
			 }
		 }
		 skipWhitespace();
		 require('>');
	 }
	 void parseNotationDecl () throws java.lang.Exception {
		 String nname, ids[];
		 requireWhitespace();
		 nname = readNmtoken(true);
		 requireWhitespace();
		 ids = readExternalIds(true);
		 if (ids[0] == null && ids[1] == null) {
			 error(""external identifer missing"", nname, null);
		 }
		 setNotation(nname, ids[0], ids[1]);
		 skipWhitespace();
		 require('>');
	 }
	 void parsePCData () throws java.lang.Exception {
		 char c;
		 if (USE_CHEATS) {
			 int lineAugment = 0;
			 int columnAugment = 0;
			 loop: for (int i = readBufferPos;
			 i < readBufferLength;
			 i++) {
				switch (readBuffer[i]) {
					case '\n': lineAugment++;
					 columnAugment = 0;
					 break;
					case '&':case '<': int start = readBufferPos;
					 columnAugment++;
					 readBufferPos = i;
					 if (lineAugment > 0) {
						 line += lineAugment;
						 column = columnAugment;
					 }
					 else {
						 column += columnAugment;
					 }
					 dataBufferAppend(readBuffer, start, i-start);
					 return;
					default: columnAugment++;
				}
			 }
		 }
		 while (true) {
			 c = readCh();
			 switch (c) {
				 case '<': case '&':unread(c);
				return;
				 default:dataBufferAppend(c);
				break;
			 }
		 }
	 }
	 void requireWhitespace () throws java.lang.Exception {
		 char c = readCh();
		 if (isWhitespace(c)) {
			 skipWhitespace();
		 }
		 else {
			 error(""whitespace expected"", c, null);
		 }
	 }
	 void parseWhitespace () throws java.lang.Exception {
		 char c = readCh();
		 while (isWhitespace(c)) {
			 dataBufferAppend(c);
			 c = readCh();
		 }
		 unread(c);
	 }
	 void skipWhitespace () throws java.lang.Exception {
		 if (USE_CHEATS) {
			 int lineAugment = 0;
			 int columnAugment = 0;
			 loop: for (int i = readBufferPos;
			 i < readBufferLength;
			 i++) {
				switch (readBuffer[i]) {
					case ' ':case '\t':case '\r': columnAugment++;
					 break;
					case '\n': lineAugment++;
					 columnAugment = 0;
					 break;
					case '%': if (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) {
						 break loop;
					 }
					 default: readBufferPos = i;
					 if (lineAugment > 0) {
						 line += lineAugment;
						 column = columnAugment;
					 }
					 else {
						 column += columnAugment;
					 }
					 return;
				}
			 }
		 }
		 char c = readCh();
		 while (isWhitespace(c)) {
			 c = readCh();
		 }
		 unread(c);
	 }
	 String readNmtoken (boolean isName) throws java.lang.Exception {
		 char c;
		 if (USE_CHEATS) {
			 loop: for (int i = readBufferPos;
			 i < readBufferLength;
			 i++) {
				switch (readBuffer[i]) {
					case '%': if (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) {
						 break loop;
					 }
					 case '<':case '>':case '&':case ',':case '|':case '*':case '+':case '?':case ')':case '=':case '\'':case '""':case '[':case ' ':case '\t':case '\r':case '\n':case ';
					':case '/':case '#': int start = readBufferPos;
					 if (i == start) {
						 error(""name expected"", readBuffer[i], null);
					 }
					 readBufferPos = i;
					 return intern(readBuffer, start, i - start);
				}
			 }
		 }
		 nameBufferPos = 0;
		 loop: while (true) {
			 c = readCh();
			 switch (c) {
				 case '%': case '<': case '>': case '&': case ',': case '|': case '*': case '+': case '?': case ')': case '=': case '\'': case '""': case '[': case ' ': case '\t': case '\n': case '\r': case ';
				': case '/':unread(c);
				if (nameBufferPos == 0) {
					 error(""name expected"", null, null);
				}
				String s = intern(nameBuffer,0,nameBufferPos);
				nameBufferPos = 0;
				return s;
				 default:nameBuffer = (char[])extendArray(nameBuffer, nameBuffer.length, nameBufferPos);
				nameBuffer[nameBufferPos++] = c;
			 }
		 }
	 }
	 String readLiteral (int flags) throws java.lang.Exception {
		 char delim, c;
		 int startLine = line;
		 delim = readCh();
		 if (delim != '""' && delim != '\'' && delim != (char)0) {
			 error(""expected '\""' or \""'\"""", delim, null);
			 return null;
		 }
		 try {
			 c = readCh();
			 loop: while (c != delim) {
				 switch (c) {
					 case '\n': case '\r':c = ' ';
					break;
					 case '&':if ((flags & LIT_CHAR_REF) > 0) {
						 c = readCh();
						 if (c == '#') {
							 parseCharRef();
							 c = readCh();
							 continue loop;
						 }
						 else if ((flags & LIT_ENTITY_REF) > 0) {
							 unread(c);
							 parseEntityRef(false);
							 c = readCh();
							 continue loop;
						 }
						 else {
							 dataBufferAppend('&');
						 }
					}
					break;
					 default:break;
				 }
				 dataBufferAppend(c);
				 c = readCh();
			 }
		 }
		 catch (EOFException e) {
			 error(""end of input while looking for delimiter (started on line "" + startLine + ')', null, new Character(delim).toString());
		 }
		 if ((flags & LIT_NORMALIZE) > 0) {
			 dataBufferNormalize();
		 }
		 return dataBufferToString();
	 }
	 String[] readExternalIds (boolean inNotation) throws java.lang.Exception {
		 char c;
		 String ids[] = new String[2];
		 if (tryRead(""PUBLIC"")) {
			 requireWhitespace();
			 ids[0] = readLiteral(LIT_NORMALIZE);
			 if (inNotation) {
				skipWhitespace();
				if (tryRead('""') || tryRead('\'')) {
					 ids[1] = readLiteral(0);
				}
			 }
			 else {
				requireWhitespace();
				ids[1] = readLiteral(0);
			 }
		 }
		 else if (tryRead(""SYSTEM"")) {
			 requireWhitespace();
			 ids[1] = readLiteral(0);
		 }
		 return ids;
	 }
	 final boolean isWhitespace (char c) {
		 switch ((int)c) {
			 case 0x20: case 0x09: case 0x0d: case 0x0a: return true;
			 default: return false;
		 }
	 }
	 void dataBufferAppend (char c) {
		 dataBuffer = (char[])extendArray(dataBuffer, dataBuffer.length, dataBufferPos);
		 dataBuffer[dataBufferPos++] = c;
	 }
	 void dataBufferAppend (String s) {
		 dataBufferAppend(s.toCharArray(), 0, s.length());
	 }
	 void dataBufferAppend (char ch[], int start, int length) {
		 dataBuffer = (char[])extendArray(dataBuffer, dataBuffer.length, dataBufferPos + length);
		 System.arraycopy((Object)ch, start, (Object)dataBuffer, dataBufferPos, length);
		 dataBufferPos += length;
	 }
	 void dataBufferNormalize () {
		 int i = 0;
		 int j = 0;
		 int end = dataBufferPos;
		 while (j < end && isWhitespace(dataBuffer[j])) {
			 j++;
		 }
		 while (end > j && isWhitespace(dataBuffer[end - 1])) {
			 end --;
		 }
		 while (j < end) {
			 char c = dataBuffer[j++];
			 if (isWhitespace(c)) {
				while (j < end && isWhitespace(dataBuffer[j++])) {
				}
				dataBuffer[i++] = ' ';
				dataBuffer[i++] = dataBuffer[j-1];
			 }
			 else {
				dataBuffer[i++] = c;
			 }
		 }
		 dataBufferPos = i;
	 }
	 String dataBufferToString () {
		 String s = new String(dataBuffer, 0, dataBufferPos);
		 dataBufferPos = 0;
		 return s;
	 }
	 void dataBufferFlush () throws java.lang.Exception {
		 if (dataBufferPos > 0) {
			 switch (currentElementContent) {
				 case CONTENT_UNDECLARED: case CONTENT_EMPTY:break;
				 case CONTENT_MIXED: case CONTENT_ANY:if (handler != null) {
					 handler.charData(dataBuffer, 0, dataBufferPos);
				}
				break;
				 case CONTENT_ELEMENTS:if (handler != null) {
					 handler.ignorableWhitespace(dataBuffer, 0, dataBufferPos);
				}
				break;
			 }
			 dataBufferPos = 0;
		 }
	 }
	 void require (String delim) throws java.lang.Exception {
		 char ch[] = delim.toCharArray();
		 for (int i = 0;
		 i < ch.length;
		 i++) {
			 require(ch[i]);
		 }
	 }
	 void require (char delim) throws java.lang.Exception {
		 char c = readCh();
		 if (c != delim) {
			 error(""expected character"", c, new Character(delim).toString());
		 }
	 }
	 public String intern (String s) {
		 char ch[] = s.toCharArray();
		 return intern(ch, 0, ch.length);
	 }
	 public String intern (char ch[], int start, int length) {
		 int index;
		 int hash = 0;
		 for (int i = start;
		 i < start + length;
		 i++) {
			 hash = ((hash << 1) & 0xffffff) + (int)ch[i];
		 }
		 hash = hash % SYMBOL_TABLE_LENGTH;
		 Object bucket[] = (Object[])symbolTable[hash];
		 if (bucket == null) {
			 symbolTable[hash] = bucket = new Object[8];
		 }
		 for (index = 0;
		 index < bucket.length;
		 index += 2) {
			 char chFound[] = (char[])bucket[index];
			 if (chFound == null) {
				break;
			 }
			 if (chFound.length == length) {
				for (int i = 0;
				 i < chFound.length;
				 i++) {
					 if (ch[start+i] != chFound[i]) {
						 break;
					 }
					 else if (i == length-1) {
						 return (String)bucket[index+1];
					 }
				}
			 }
		 }
		 bucket = (Object[])extendArray(bucket, bucket.length, index);
		 String s = new String(ch, start, length);
		 bucket[index] = s.toCharArray();
		 bucket[index+1] = s;
		 symbolTable[hash] = bucket;
		 return s;
	 }
	 Object extendArray (Object array, int currentSize, int requiredSize) {
		 if (requiredSize < currentSize) {
			 return array;
		 }
		 else {
			 Object newArray = null;
			 int newSize = currentSize * 2;
			 if (newSize <= requiredSize) {
				newSize = requiredSize + 1;
			 }
			 if (array instanceof char[]) {
				newArray = new char[newSize];
			 }
			 else if (array instanceof Object[]) {
				newArray = new Object[newSize];
			 }
			 System.arraycopy(array, 0, newArray, 0, currentSize);
			 return newArray;
		 }
	 }
	 public Enumeration declaredElements () {
		 return elementInfo.keys();
	 }
	 public int getElementContentType (String name) {
		 Object element[] = (Object[])elementInfo.get(name);
		 if (element == null) {
			 return CONTENT_UNDECLARED;
		 }
		 else {
			 return ((Integer)element[0]).intValue();
		 }
	 }
	 public String getElementContentModel (String name) {
		 Object element[] = (Object[])elementInfo.get(name);
		 if (element == null) {
			 return null;
		 }
		 else {
			 return (String)element[1];
		 }
	 }
	 void setElement (String name, int contentType, String contentModel, Hashtable attributes) throws java.lang.Exception {
		 Object element[];
		 element = (Object[])elementInfo.get(name);
		 if (element == null) {
			 element = new Object[3];
			 element[0] = new Integer(CONTENT_UNDECLARED);
			 element[1] = null;
			 element[2] = null;
		 }
		 else if (contentType != CONTENT_UNDECLARED && ((Integer)element[0]).intValue() != CONTENT_UNDECLARED) {
			 error(""multiple declarations for element type"", name, null);
			 return;
		 }
		 if (contentType != CONTENT_UNDECLARED) {
			 element[0] = new Integer(contentType);
		 }
		 if (contentModel != null) {
			 element[1] = contentModel;
		 }
		 if (attributes != null) {
			 element[2] =attributes;
		 }
		 elementInfo.put(name,element);
	 }
	 Hashtable getElementAttributes (String name) {
		 Object element[] = (Object[])elementInfo.get(name);
		 if (element == null) {
			 return null;
		 }
		 else {
			 return (Hashtable)element[2];
		 }
	 }
	 public Enumeration declaredAttributes (String elname) {
		 Hashtable attlist = getElementAttributes(elname);
		 if (attlist == null) {
			 return null;
		 }
		 else {
			 return attlist.keys();
		 }
	 }
	 public int getAttributeType (String name, String aname) {
		 Object attribute[] = getAttribute(name, aname);
		 if (attribute == null) {
			 return ATTRIBUTE_UNDECLARED;
		 }
		 else {
			 return ((Integer)attribute[0]).intValue();
		 }
	 }
	 public String getAttributeEnumeration (String name, String aname) {
		 Object attribute[] = getAttribute(name, aname);
		 if (attribute == null) {
			 return null;
		 }
		 else {
			 return (String)attribute[3];
		 }
	 }
	 public String getAttributeDefaultValue (String name, String aname) {
		 Object attribute[] = getAttribute(name, aname);
		 if (attribute == null) {
			 return null;
		 }
		 else {
			 return (String)attribute[1];
		 }
	 }
	 public String getAttributeExpandedValue (String name, String aname) {
		 Object attribute[] = getAttribute(name, aname);
		 if (attribute == null) {
			 return null;
		 }
		 else if (attribute[4] == null && attribute[1] != null) {
			 try {
				pushString(null, (char)0 + (String)attribute[1] + (char)0);
				attribute[4] = readLiteral(LIT_NORMALIZE | LIT_CHAR_REF | LIT_ENTITY_REF);
			 }
			 catch (Exception e) {
			}
		 }
		 return (String)attribute[4];
	 }
	 public int getAttributeDefaultValueType (String name, String aname) {
		 Object attribute[] = getAttribute(name, aname);
		 if (attribute == null) {
			 return ATTRIBUTE_DEFAULT_UNDECLARED;
		 }
		 else {
			 return ((Integer)attribute[2]).intValue();
		 }
	 }
	 void setAttribute (String elName, String name, int type, String enumeration, String value, int valueType) throws java.lang.Exception {
		 Hashtable attlist;
		 Object attribute[];
		 attlist = getElementAttributes(elName);
		 if (attlist == null) {
			 attlist = new Hashtable();
		 }
		 if (attlist.get(name) != null) {
			 return;
		 }
		 else {
			 attribute = new Object[5];
			 attribute[0] = new Integer(type);
			 attribute[1] = value;
			 attribute[2] = new Integer(valueType);
			 attribute[3] = enumeration;
			 attribute[4] = null;
			 attlist.put(name.intern(), attribute);
			 setElement(elName,CONTENT_UNDECLARED, null, attlist);
		 }
	 }
	 Object[] getAttribute (String elName, String name) {
		 Hashtable attlist;
		 Object attribute[];
		 attlist = getElementAttributes(elName);
		 if (attlist == null) {
			 return null;
		 }
		 attribute = (Object[])attlist.get(name);
		 return attribute;
	 }
	 public Enumeration declaredEntities () {
		 return entityInfo.keys();
	 }
	 public int getEntityType (String ename) {
		 Object entity[] = (Object[])entityInfo.get(ename);
		 if (entity == null) {
			 return ENTITY_UNDECLARED;
		 }
		 else {
			 return ((Integer)entity[0]).intValue();
		 }
	 }
	 public String getEntityPublicId (String ename) {
		 Object entity[] = (Object[])entityInfo.get(ename);
		 if (entity == null) {
			 return null;
		 }
		 else {
			 return (String)entity[1];
		 }
	 }
	 public String getEntitySystemId (String ename) {
		 Object entity[] = (Object[])entityInfo.get(ename);
		 if (entity == null) {
			 return null;
		 }
		 else {
			 return (String)entity[2];
		 }
	 }
	 public String getEntityValue (String ename) {
		 Object entity[] = (Object[])entityInfo.get(ename);
		 if (entity == null) {
			 return null;
		 }
		 else {
			 return (String)entity[3];
		 }
	 }
	 public String getEntityNotationName (String eName) {
		 Object entity[] = (Object[])entityInfo.get(eName);
		 if (entity == null) {
			 return null;
		 }
		 else {
			 return (String)entity[4];
		 }
	 }
	 void setInternalEntity (String eName, String value) {
		 setEntity(eName, ENTITY_INTERNAL, null, null, value, null);
	 }
	 void setExternalDataEntity (String eName, String pubid, String sysid, String nName) {
		 setEntity(eName, ENTITY_NDATA, pubid, sysid, null, nName);
	 }
	 void setExternalTextEntity (String eName, String pubid, String sysid) {
		 setEntity(eName, ENTITY_TEXT, pubid, sysid, null, null);
	 }
	 void setEntity (String eName, int eClass, String pubid, String sysid, String value, String nName) {
		 Object entity[];
		 if (entityInfo.get(eName) == null) {
			 entity = new Object[5];
			 entity[0] = new Integer(eClass);
			 entity[1] = pubid;
			 entity[2] = sysid;
			 entity[3] = value;
			 entity[4] = nName;
			 entityInfo.put(eName,entity);
		 }
	 }
	 public Enumeration declaredNotations () {
		 return notationInfo.keys();
	 }
	 public String getNotationPublicId (String nname) {
		 Object notation[] = (Object[])notationInfo.get(nname);
		 if (notation == null) {
			 return null;
		 }
		 else {
			 return (String)notation[0];
		 }
	 }
	 public String getNotationSystemId (String nname) {
		 Object notation[] = (Object[])notationInfo.get(nname);
		 if (notation == null) {
			 return null;
		 }
		 else {
			 return (String)notation[1];
		 }
	 }
	 void setNotation (String nname, String pubid, String sysid) throws java.lang.Exception {
		 Object notation[];
		 if (notationInfo.get(nname) == null) {
			 notation = new Object[2];
			 notation[0] = pubid;
			 notation[1] = sysid;
			 notationInfo.put(nname,notation);
		 }
		 else {
			 error(""multiple declarations of notation"", nname, null);
		 }
	 }
	 public int getLineNumber () {
		 return line;
	 }
	 public int getColumnNumber () {
		 return column;
	 }
	 char readCh () throws java.lang.Exception {
		 char c;
		 while (readBufferPos >= readBufferLength) {
			 switch (sourceType) {
				 case INPUT_READER: case INPUT_EXTERNAL: case INPUT_STREAM: readDataChunk();
				 while (readBufferLength < 1) {
					 popInput();
					 if (readBufferLength <1) {
						 readDataChunk();
					 }
				 }
				 break;
				 default: popInput();
				 break;
			 }
		 }
		 c = readBuffer[readBufferPos++];
		 if ( c == '%' && (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) ) {
			 char c2 = readCh();
			 unread(c2);
			 if (!isWhitespace(c2)) {
				 parsePEReference(context == CONTEXT_ENTITYVALUE);
				 return readCh();
			 }
		 }
		 if (c == '\n') {
			 line++;
			 column = 0;
		 }
		 else {
			 column++;
		 }
		 return c;
	 }
	 void unread (char c) throws java.lang.Exception {
		 if (c == '\n') {
			 line--;
			 column = -1;
		 }
		 if (readBufferPos > 0) {
			 readBuffer[--readBufferPos] = c;
		 }
		 else {
			 pushString(null, new Character(c).toString());
		 }
	 }
	 void unread (char ch[], int length) throws java.lang.Exception {
		 for (int i = 0;
		 i < length;
		 i++) {
			 if (ch[i] == '\n') {
				line--;
				column = -1;
			}
		 }
		 if (length < readBufferPos) {
			readBufferPos -= length;
		}
		 else {
			 pushCharArray(null, ch, 0, length);
			 sourceType = INPUT_BUFFER;
		 }
	 }
	 void pushURL (String ename, String publicId, String systemId,Reader reader, InputStream stream, String encoding) throws java.lang.Exception {
		 URL url;
		 boolean ignoreEncoding = false;
		 pushInput(ename);
		 readBuffer = new char[READ_BUFFER_MAX+4];
		 readBufferPos = 0;
		 readBufferLength = 0;
		 readBufferOverflow = -1;
		 is = null;
		 line = 1;
		 currentByteCount = 0;
		 dataBufferFlush();
		 if (systemId != null && externalEntity != null) {
			 systemId = new URL(externalEntity.getURL(), systemId).toString();
		 }
		 else if (baseURI != null) {
			 try {
				systemId = new URL(new URL(baseURI), systemId).toString();
			 }
			 catch (Exception e) {
			}
		 }
		 if (systemId != null && handler != null) {
			 Object input = handler.resolveEntity(publicId, systemId);
			 if (input != null) {
				if (input instanceof String) {
					 systemId = (String)input;
				}
				 else if (input instanceof InputStream) {
					 stream = (InputStream)input;
				}
				 else if (input instanceof Reader) {
					 reader = (Reader)input;
				}
			 }
		 }
		 if (handler != null) {
			 if (systemId != null) {
				handler.startExternalEntity(systemId);
			 }
			 else {
				handler.startExternalEntity(""[external stream]"");
			 }
		 }
		 if (reader != null) {
			 sourceType = INPUT_READER;
			 this.reader = reader;
			 tryEncodingDecl(true);
			 return;
		 }
		 else if (stream != null) {
			 sourceType = INPUT_STREAM;
			 is = stream;
		 }
		 else {
			 sourceType = INPUT_EXTERNAL;
			 url = new URL(systemId);
			 externalEntity = url.openConnection();
			 externalEntity.connect();
			 is = externalEntity.getInputStream();
		 }
		 if (!is.markSupported()) {
			 is = new BufferedInputStream(is);
		 }
		 if (encoding == null && externalEntity != null) {
			 encoding = externalEntity.getContentEncoding();
		 }
		 if (encoding != null) {
			 checkEncoding(encoding, false);
			 ignoreEncoding = true;
		 }
		 else {
			 detectEncoding();
			 ignoreEncoding = false;
		 }
		 tryEncodingDecl(ignoreEncoding);
	 }
	 void tryEncodingDecl (boolean ignoreEncoding) throws java.lang.Exception {
		 if (tryRead(""<?xml"")) {
			 if (tryWhitespace()) {
				if (inputStack.size() > 0) {
					 parseTextDecl(ignoreEncoding);
				}
				 else {
					 parseXMLDecl(ignoreEncoding);
				}
			 }
			 else {
				unread(""xml"".toCharArray(), 3);
				parsePI();
			 }
		 }
	 }
	 void detectEncoding () throws java.lang.Exception {
		 byte signature[] = new byte[4];
		 is.mark(4);
		 is.read(signature);
		 is.reset();
		 if (tryEncoding(signature, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x3c)) {
			 encoding = ENCODING_UCS_4_1234;
		 }
		 else if (tryEncoding(signature, (byte)0x3c, (byte)0x00, (byte)0x00, (byte)0x00)) {
			 encoding = ENCODING_UCS_4_4321;
		 }
		 else if (tryEncoding(signature, (byte)0x00, (byte)0x00, (byte)0x3c, (byte)0x00)) {
			 encoding = ENCODING_UCS_4_2143;
		 }
		 else if (tryEncoding(signature, (byte)0x00, (byte)0x3c, (byte)0x00, (byte)0x00)) {
			 encoding = ENCODING_UCS_4_3412;
		 }
		 else if (tryEncoding(signature, (byte)0xfe, (byte)0xff)) {
			 encoding = ENCODING_UCS_2_12;
			 is.read();
			 is.read();
		 }
		 else if (tryEncoding(signature, (byte)0xff, (byte)0xfe)) {
			 encoding = ENCODING_UCS_2_21;
			 is.read();
			 is.read();
		 }
		 else if (tryEncoding(signature, (byte)0x00, (byte)0x3c, (byte)0x00, (byte)0x3f)) {
			 encoding = ENCODING_UCS_2_12;
			 error(""no byte-order mark for UCS-2 entity"", null, null);
		 }
		 else if (tryEncoding(signature, (byte)0x3c, (byte)0x00, (byte)0x3f, (byte)0x00)) {
			 encoding = ENCODING_UCS_2_21;
			 error(""no byte-order mark for UCS-2 entity"", null, null);
		 }
		 else if (tryEncoding(signature, (byte)0x3c, (byte)0x3f, (byte)0x78, (byte)0x6d)) {
			 encoding = ENCODING_UTF_8;
			 read8bitEncodingDeclaration();
		 }
		 else {
			 encoding = ENCODING_UTF_8;
		 }
	 }
	 boolean tryEncoding (byte sig[], byte b1, byte b2, byte b3, byte b4) {
		 return (sig[0] == b1 && sig[1] == b2 && sig[2] == b3 && sig[3] == b4);
	 }
	 boolean tryEncoding (byte sig[], byte b1, byte b2) {
		 return ((sig[0] == b1) && (sig[1] == b2));
	 }
	 void pushString (String ename, String s) throws java.lang.Exception {
		 char ch[] = s.toCharArray();
		 pushCharArray(ename, ch, 0, ch.length);
	 }
	 void pushCharArray (String ename, char ch[], int start, int length) throws java.lang.Exception {
		 pushInput(ename);
		 sourceType = INPUT_INTERNAL;
		 readBuffer = ch;
		 readBufferPos = start;
		 readBufferLength = length;
		 readBufferOverflow = -1;
	 }
	 void pushInput (String ename) throws java.lang.Exception {
		 Object input[] = new Object[12];
		 if (ename != null) {
			 Enumeration entities = entityStack.elements();
			 while (entities.hasMoreElements()) {
				String e = (String)entities.nextElement();
				if (e == ename) {
					 error(""recursive reference to entity"", ename, null);
				}
			 }
		 }
		 entityStack.push(ename);
		 if (sourceType == INPUT_NONE) {
			 return;
		 }
		 input[0] = new Integer(sourceType);
		 input[1] = externalEntity;
		 input[2] = readBuffer;
		 input[3] = new Integer(readBufferPos);
		 input[4] = new Integer(readBufferLength);
		 input[5] = new Integer(line);
		 input[6] = new Integer(encoding);
		 input[7] = new Integer(readBufferOverflow);
		 input[8] = is;
		 input[9] = new Integer(currentByteCount);
		 input[10] = new Integer(column);
		 input[11] = reader;
		 inputStack.push(input);
	 }
	 void popInput () throws java.lang.Exception {
		 Object input[];
		 switch (sourceType) {
			 case INPUT_EXTERNAL: dataBufferFlush();
			 if (handler != null && externalEntity != null) {
				handler.endExternalEntity(externalEntity.getURL().toString());
			 }
			 break;
			 case INPUT_STREAM: dataBufferFlush();
			 if (baseURI != null) {
				if (handler != null) {
					 handler.endExternalEntity(baseURI);
				}
			 }
			 break;
			 case INPUT_READER: dataBufferFlush();
			 if (baseURI != null) {
				if (handler != null) {
					 handler.endExternalEntity(baseURI);
				}
			 }
			 break;
		 }
		 if (inputStack.isEmpty()) {
			 throw new EOFException();
		 }
		 else {
			 String s;
			 input = (Object[])inputStack.pop();
			 s = (String)entityStack.pop();
		 }
		 sourceType = ((Integer)input[0]).intValue();
		 externalEntity = (URLConnection)input[1];
		 readBuffer = (char[])input[2];
		 readBufferPos = ((Integer)input[3]).intValue();
		 readBufferLength = ((Integer)input[4]).intValue();
		 line = ((Integer)input[5]).intValue();
		 encoding = ((Integer)input[6]).intValue();
		 readBufferOverflow = ((Integer)input[7]).intValue();
		 is = (InputStream)input[8];
		 currentByteCount = ((Integer)input[9]).intValue();
		 column = ((Integer)input[10]).intValue();
		 reader = (Reader)input[11];
	 }
	 boolean tryRead (char delim) throws java.lang.Exception {
		 char c;
		 c = readCh();
		 if (c == delim) {
			 return true;
		 }
		 else {
			 unread(c);
			 return false;
		 }
	 }
	 boolean tryRead (String delim) throws java.lang.Exception {
		 char ch[] = delim.toCharArray();
		 char c;
		 for (int i = 0;
		 i < ch.length;
		 i++) {
			 c=readCh();
			 if (c!=ch[i]) {
				 unread(c);
				 if (i!=0) {
					unread(ch,i);
				}
				 return false;
			 }
		 }
		 return true;
	 }
	 boolean tryWhitespace () throws java.lang.Exception {
		 char c;
		 c = readCh();
		 if (isWhitespace(c)) {
			 skipWhitespace();
			 return true;
		 }
		 else {
			 unread(c);
			 return false;
		 }
	 }
	 void parseUntil (String delim) throws java.lang.Exception {
		 char c;
		 int startLine = line;
		 try {
			 while (!tryRead(delim)) {
				c = readCh();
				dataBufferAppend(c);
			 }
		 }
		 catch (EOFException e) {
			 error(""end of input while looking for delimiter (started on line "" + startLine + ')', null, delim);
		 }
	 }
	 void skipUntil (String delim) throws java.lang.Exception {
		 while (!tryRead(delim)) {
			 readCh();
		 }
	 }
	 void read8bitEncodingDeclaration () throws java.lang.Exception {
		 int ch;
		 readBufferPos = readBufferLength = 0;
		 while (true) {
			 ch = is.read();
			 readBuffer[readBufferLength++] = (char)ch;
			 switch (ch) {
				 case (int)'>':return;
				 case -1:error(""end of file before end of XML or encoding declaration."", null, ""?>"");
				return;
			 }
			 if (readBuffer.length == readBufferLength) {
				error(""unfinished XML or encoding declaration"", null, null);
			 }
		 }
	 }
	 void readDataChunk () throws java.lang.Exception {
		 int count, i, j;
		 if (readBufferOverflow > -1) {
			 readBuffer[0] = (char)readBufferOverflow;
			 readBufferOverflow = -1;
			 readBufferPos = 1;
			 sawCR = true;
		 }
		 else {
			 readBufferPos = 0;
			 sawCR = false;
		 }
		 if (sourceType == INPUT_READER) {
			 count = reader.read(readBuffer, readBufferPos, READ_BUFFER_MAX-1);
			 if (count < 0) {
				readBufferLength = -1;
			}
			 else {
				 readBufferLength = readBufferPos+count;
				 filterCR();
				 sawCR = false;
			 }
			 return;
		 }
		 count = is.read(rawReadBuffer, 0, READ_BUFFER_MAX);
		 switch (encoding) {
			 case ENCODING_UTF_8: copyUtf8ReadBuffer(count);
			 break;
			 case ENCODING_ISO_8859_1: copyIso8859_1ReadBuffer(count);
			 break;
			 case ENCODING_UCS_2_12: copyUcs2ReadBuffer(count, 8, 0);
			 break;
			 case ENCODING_UCS_2_21: copyUcs2ReadBuffer(count, 0, 8);
			 break;
			 case ENCODING_UCS_4_1234: copyUcs4ReadBuffer(count, 24, 16, 8, 0);
			 break;
			 case ENCODING_UCS_4_4321: copyUcs4ReadBuffer(count, 0, 8, 16, 24);
			 break;
			 case ENCODING_UCS_4_2143: copyUcs4ReadBuffer(count, 16, 24, 0, 8);
			 break;
			 case ENCODING_UCS_4_3412: copyUcs4ReadBuffer(count, 8, 0, 24, 16);
			 break;
		 }
		 if (sawCR) {
			 filterCR();
			 sawCR = false;
		 }
		 readBufferPos = 0;
		 currentByteCount += count;
	 }
	 void filterCR () {
		 int i, j;
		 readBufferOverflow = -1;
		 loop: for (i = 0, j = 0;
		 j < readBufferLength;
		 i++, j++) {
			 switch (readBuffer[j]) {
				 case '\r': if (j == readBufferLength - 1) {
					 readBufferOverflow = '\r';
					 readBufferLength--;
					 break loop;
				 }
				 else if (readBuffer[j+1] == '\n') {
					j++;
				}
				 readBuffer[i] = '\n';
				 break;
				 case '\n': default: readBuffer[i] = readBuffer[j];
				 break;
			 }
		 }
		 readBufferLength = i;
	 }
	 void copyUtf8ReadBuffer (int count) throws java.lang.Exception {
		 int i = 0;
		 int j = readBufferPos;
		 int b1;
		 boolean isSurrogate = false;
		 while (i < count) {
			 b1 = rawReadBuffer[i++];
			 isSurrogate = false;
			 if ((b1 & 0x80) == 0) {
				readBuffer[j++] = (char)b1;
			 }
			 else if ((b1 & 0xe0) == 0xc0) {
				readBuffer[j++] = (char)(((b1 & 0x1f) << 6) | getNextUtf8Byte(i++, count));
			 }
			 else if ((b1 & 0xf0) == 0xe0) {
				readBuffer[j++] = (char)(((b1 & 0x0f) << 12) | (getNextUtf8Byte(i++, count) << 6) | getNextUtf8Byte(i++, count));
			 }
			 else if ((b1 & 0xf8) == 0xf0) {
				isSurrogate = true;
				int b2 = getNextUtf8Byte(i++, count);
				int b3 = getNextUtf8Byte(i++, count);
				int b4 = getNextUtf8Byte(i++, count);
				readBuffer[j++] = (char)(0xd800 | ((((b1 & 0x07) << 2) | ((b2 & 0x30) >> 4) - 1) << 6) | ((b2 & 0x0f) << 2) | ((b3 & 0x30) >> 4));
				readBuffer[j++] = (char)(0xdc | ((b3 & 0x0f) << 6) | b4);
			 }
			 else {
				encodingError(""bad start for UTF-8 multi-byte sequence"", b1, i);
			 }
			 if (readBuffer[j-1] == '\r') {
				sawCR = true;
			 }
		 }
		 readBufferLength = j;
	 }
	 int getNextUtf8Byte (int pos, int count) throws java.lang.Exception {
		 int val;
		 if (pos < count) {
			 val = rawReadBuffer[pos];
		 }
		 else {
			 val = is.read();
			 if (val == -1) {
				encodingError(""unfinished multi-byte UTF-8 sequence at EOF"", -1, pos);
			 }
		 }
		 if ((val & 0xc0) != 0x80) {
			 encodingError(""bad continuation of multi-byte UTF-8 sequence"", val, pos + 1);
		 }
		 return (val & 0x3f);
	 }
	 void copyIso8859_1ReadBuffer (int count) {
		 int i, j;
		 for (i = 0, j = readBufferPos;
		 i < count;
		 i++, j++) {
			 readBuffer[j] = (char)(rawReadBuffer[i] & 0xff);
			 if (readBuffer[j] == '\r') {
				sawCR = true;
			 }
		 }
		 readBufferLength = j;
	 }
	 void copyUcs2ReadBuffer (int count, int shift1, int shift2) throws java.lang.Exception {
		 int j = readBufferPos;
		 if (count > 0 && (count % 2) != 0) {
			 encodingError(""odd number of bytes in UCS-2 encoding"", -1, count);
		 }
		 for (int i = 0;
		 i < count;
		 i+=2) {
			 readBuffer[j++] =(char)(((rawReadBuffer[i] & 0xff) << shift1) | ((rawReadBuffer[i+1] & 0xff) << shift2));
			 if (readBuffer[j-1] == '\r') {
				sawCR = true;
			 }
		 }
		 readBufferLength = j;
	 }
	 void copyUcs4ReadBuffer (int count, int shift1, int shift2, int shift3, int shift4) throws java.lang.Exception {
		 int j = readBufferPos;
		 int value;
		 if (count > 0 && (count % 4) != 0) {
			 encodingError(""number of bytes in UCS-4 encoding not divisible by 4"", -1, count);
		 }
		 for (int i = 0;
		 i < count;
		 i+=4) {
			 value = (((rawReadBuffer[i] & 0xff) << shift1) | ((rawReadBuffer[i+1] & 0xff) << shift2) | ((rawReadBuffer[i+2] & 0xff) << shift3) | ((rawReadBuffer[i+3] & 0xff) << shift4));
			 if (value < 0x0000ffff) {
				readBuffer[j++] = (char)value;
				if (value == (int)'\r') {
					 sawCR = true;
				}
			 }
			 else if (value < 0x000fffff) {
				readBuffer[j++] = (char)(0xd8 | ((value & 0x000ffc00) >> 10));
				readBuffer[j++] = (char)(0xdc | (value & 0x0003ff));
			 }
			 else {
				encodingError(""value cannot be represented in UTF-16"", value, i);
			 }
		 }
		 readBufferLength = j;
	 }
	 void encodingError (String message, int value, int offset) throws java.lang.Exception {
		 String uri;
		 if (value >= 0) {
			 message = message + "" (byte value: 0x"" +Integer.toHexString(value) + ')';
		 }
		 if (externalEntity != null) {
			 uri = externalEntity.getURL().toString();
		 }
		 else {
			 uri = baseURI;
		 }
		 handler.error(message, uri, -1, offset + currentByteCount);
	 }
	 void initializeVariables () {
		 errorCount = 0;
		 line = 1;
		 column = 0;
		 dataBufferPos = 0;
		 dataBuffer = new char[DATA_BUFFER_INITIAL];
		 nameBufferPos = 0;
		 nameBuffer = new char[NAME_BUFFER_INITIAL];
		 elementInfo = new Hashtable();
		 entityInfo = new Hashtable();
		 notationInfo = new Hashtable();
		 currentElement = null;
		 currentElementContent = CONTENT_UNDECLARED;
		 sourceType = INPUT_NONE;
		 inputStack = new Stack();
		 entityStack = new Stack();
		 externalEntity = null;
		 tagAttributePos = 0;
		 tagAttributes = new String[100];
		 rawReadBuffer = new byte[READ_BUFFER_MAX];
		 readBufferOverflow = -1;
		 context = CONTEXT_NONE;
		 symbolTable = new Object[SYMBOL_TABLE_LENGTH];
	 }
	 void cleanupVariables () {
		 errorCount = -1;
		 line = -1;
		 column = -1;
		 dataBuffer = null;
		 nameBuffer = null;
		 currentElement = null;
		 currentElementContent = CONTENT_UNDECLARED;
		 sourceType = INPUT_NONE;
		 inputStack = null;
		 externalEntity = null;
		 entityStack = null;
	 }
	 XmlHandler handler;
	 private Reader reader;
	 private InputStream is;
	 private int line;
	 private int column;
	 private int sourceType;
	 private Stack inputStack;
	 private URLConnection externalEntity;
	 private int encoding;
	 private int currentByteCount;
	 private int errorCount;
	 private final static int READ_BUFFER_MAX = 16384;
	 private char readBuffer[];
	 private int readBufferPos;
	 private int readBufferLength;
	 private int readBufferOverflow;
	 private byte rawReadBuffer[];
	 private static int DATA_BUFFER_INITIAL = 4096;
	 private char dataBuffer[];
	 private int dataBufferPos;
	 private static int NAME_BUFFER_INITIAL = 1024;
	 private char nameBuffer[];
	 private int nameBufferPos;
	 private Hashtable elementInfo;
	 private Hashtable entityInfo;
	 private Hashtable notationInfo;
	 private String currentElement;
	 private int currentElementContent;
	 private String basePublicId;
	 private String baseURI;
	 private int baseEncoding;
	 private Reader baseReader;
	 private InputStream baseInputStream;
	 private char baseInputBuffer[];
	 private int baseInputBufferStart;
	 private int baseInputBufferLength;
	 private Stack entityStack;
	 private int context;
	 private Object symbolTable[];
	 private final static int SYMBOL_TABLE_LENGTH = 1087;
	 private String tagAttributes[];
	 private int tagAttributePos;
	 private boolean sawCR;
}",1,0,0,0
"protected void createTextCell(final JRPrintText textElement, final JRExporterGridCell gridCell, final int colIndex, final int rowIndex, final JRStyledText styledText, final StyleInfo baseStyle, final short forecolor) throws JRException;",0,0,0,1
"public class Equals extends PrimitiveFixture {
	 Parse heads;
	 TypeAdapter type;
	 Object x, y;
	 public void doRows (Parse rows) {
		 heads = rows.parts;
		 super.doRows(rows.more);
	 }
	 public void doCell (Parse cell, int col) {
		 try {
			 char head = heads.at(col).text().charAt(0);
			 switch (head) {
				 case 't': type = type(cell.text());
				 break;
				 case 'x': x = type.parse(cell.text());
				 break;
				 case 'y': y = type.parse(cell.text());
				 break;
				 case '=': check(cell, type.equals(x, y));
				 break;
				 case '?': cell.addToBody(info(""x: "" + print(x) + "" y: "" + print(y)));
				 break;
				 default: throw new Exception(""don't do "" + head);
			 }
		 }
		 catch (Exception e) {
			 exception(cell, e);
		 }
	 }
	 static private Integer [] IntegerArray = {
	}
	;
	 static private Boolean [] BooleanArray = {
	}
	;
	 static private String [] StringArray = {
	}
	;
	 TypeAdapter type(String name) {
		 Class type = name.equals(""boolean"") ? Boolean.class : name.equals(""integer"") ? Integer.class : name.equals(""real"") ? Float.class : name.equals(""string"") ? String.class : name.equals(""date"") ? Date.class : name.equals(""money"") ? Money.class : name.equals(""scientific"") ? ScientificDouble.class : name.equals(""integers"") ? IntegerArray.getClass(): name.equals(""booleans"") ? BooleanArray.getClass(): name.equals(""strings"") ? StringArray.getClass(): null ;
		 if (type == null) throw new RuntimeException(""Unimplemented choice ""+name);
		 return TypeAdapter.on(this, type);
	 }
	 public Object parse (String s, Class type) throws Exception {
		 if (type.equals(Money.class)) return new Money(s);
		 if (type.equals(Boolean.class)) return parseCustomBoolean(s);
		 return super.parse(s, type);
	 }
	 Boolean parseCustomBoolean(String s) {
		 if (true) throw new RuntimeException(""boolean"");
		 return s.startsWith(""y"") ? Boolean.TRUE : s.startsWith(""n"") ? Boolean.FALSE : s.startsWith(""t"") ? Boolean.TRUE : s.startsWith(""f"") ? Boolean.FALSE : null ;
	 }
	 String print (Object value) {
		 return type.toString(value);
	 }
}",0,0,0,0
"public class PropertySet extends DataType implements ResourceCollection {
	 private boolean dynamic = true;
	 private boolean negate = false;
	 private Set cachedNames;
	 private Vector ptyRefs = new Vector();
	 private Vector setRefs = new Vector();
	 private Mapper mapper;
	 public static class PropertyRef {
		 private int count;
		 private String name;
		 private String regex;
		 private String prefix;
		 private String builtin;
		 public void setName(String name) {
			 assertValid(""name"", name);
			 this.name = name;
		 }
		 public void setRegex(String regex) {
			 assertValid(""regex"", regex);
			 this.regex = regex;
		 }
		 public void setPrefix(String prefix) {
			 assertValid(""prefix"", prefix);
			 this.prefix = prefix;
		 }
		 public void setBuiltin(BuiltinPropertySetName b) {
			 String pBuiltIn = b.getValue();
			 assertValid(""builtin"", pBuiltIn);
			 this.builtin = pBuiltIn;
		 }
		 private void assertValid(String attr, String value) {
			 if (value == null || value.length() < 1) {
				 throw new BuildException(""Invalid attribute: "" + attr);
			 }
			 if (++count != 1) {
				 throw new BuildException(""Attributes name, regex, and "" + ""prefix are mutually exclusive"");
			 }
		 }
		 public String toString() {
			 return ""name="" + name + "", regex="" + regex + "", prefix="" + prefix + "", builtin="" + builtin;
		 }
	 }
	 public void appendName(String name) {
		 PropertyRef r = new PropertyRef();
		 r.setName(name);
		 addPropertyref(r);
	 }
	 public void appendRegex(String regex) {
		 PropertyRef r = new PropertyRef();
		 r.setRegex(regex);
		 addPropertyref(r);
	 }
	 public void appendPrefix(String prefix) {
		 PropertyRef r = new PropertyRef();
		 r.setPrefix(prefix);
		 addPropertyref(r);
	 }
	 public void appendBuiltin(BuiltinPropertySetName b) {
		 PropertyRef r = new PropertyRef();
		 r.setBuiltin(b);
		 addPropertyref(r);
	 }
	 public void setMapper(String type, String from, String to) {
		 Mapper m = createMapper();
		 Mapper.MapperType mapperType = new Mapper.MapperType();
		 mapperType.setValue(type);
		 m.setType(mapperType);
		 m.setFrom(from);
		 m.setTo(to);
	 }
	 public void addPropertyref(PropertyRef ref) {
		 assertNotReference();
		 setChecked(false);
		 ptyRefs.addElement(ref);
	 }
	 public void addPropertyset(PropertySet ref) {
		 assertNotReference();
		 setChecked(false);
		 setRefs.addElement(ref);
	 }
	 public Mapper createMapper() {
		 assertNotReference();
		 if (mapper != null) {
			 throw new BuildException(""Too many <mapper>s!"");
		 }
		 mapper = new Mapper(getProject());
		 setChecked(false);
		 return mapper;
	 }
	 public void add(FileNameMapper fileNameMapper) {
		 createMapper().add(fileNameMapper);
	 }
	 public void setDynamic(boolean dynamic) {
		 assertNotReference();
		 this.dynamic = dynamic;
	 }
	 public void setNegate(boolean negate) {
		 assertNotReference();
		 this.negate = negate;
	 }
	 public boolean getDynamic() {
		 if (isReference()) {
			 return getRef().dynamic;
		 }
		 dieOnCircularReference();
		 return dynamic;
	 }
	 public Mapper getMapper() {
		 if (isReference()) {
			 return getRef().mapper;
		 }
		 dieOnCircularReference();
		 return mapper;
	 }
	 private Hashtable getAllSystemProperties() {
		 Hashtable ret = new Hashtable();
		 for (Enumeration e = System.getProperties().propertyNames();
		 e.hasMoreElements();
		) {
			 String name = (String) e.nextElement();
			 ret.put(name, System.getProperties().getProperty(name));
		 }
		 return ret;
	 }
	 public Properties getProperties() {
		 if (isReference()) {
			 return getRef().getProperties();
		 }
		 dieOnCircularReference();
		 Hashtable props = getEffectiveProperties();
		 Set names = getPropertyNames(props);
		 FileNameMapper m = null;
		 Mapper myMapper = getMapper();
		 if (myMapper != null) {
			 m = myMapper.getImplementation();
		 }
		 Properties properties = new Properties();
		 for (Iterator iter = names.iterator();
		 iter.hasNext();
		) {
			 String name = (String) iter.next();
			 String value = (String) props.get(name);
			 if (value != null) {
				 if (m != null) {
					 String[] newname = m.mapFileName(name);
					 if (newname != null) {
						 name = newname[0];
					 }
				 }
				 properties.setProperty(name, value);
			 }
		 }
		 return properties;
	 }
	 private Hashtable getEffectiveProperties() {
		 Project prj = getProject();
		 Hashtable result = prj == null ? getAllSystemProperties() : prj.getProperties();
		 for (Enumeration e = setRefs.elements();
		 e.hasMoreElements();
		) {
			 PropertySet set = (PropertySet) e.nextElement();
			 result.putAll(set.getProperties());
		 }
		 return result;
	 }
	 private Set getPropertyNames(Hashtable props) {
		 Set names;
		 if (getDynamic() || cachedNames == null) {
			 names = new HashSet();
			 addPropertyNames(names, props);
			 for (Enumeration e = setRefs.elements();
			 e.hasMoreElements();
			) {
				 PropertySet set = (PropertySet) e.nextElement();
				 names.addAll(set.getProperties().keySet());
			 }
			 if (negate) {
				 HashSet complement = new HashSet(props.keySet());
				 complement.removeAll(names);
				 names = complement;
			 }
			 if (!getDynamic()) {
				 cachedNames = names;
			 }
		 }
		 else {
			 names = cachedNames;
		 }
		 return names;
	 }
	 private void addPropertyNames(Set names, Hashtable properties) {
		 if (isReference()) {
			 getRef().addPropertyNames(names, properties);
		 }
		 dieOnCircularReference();
		 for (Enumeration e = ptyRefs.elements();
		 e.hasMoreElements();
		) {
			 PropertyRef r = (PropertyRef) e.nextElement();
			 if (r.name != null) {
				 if (properties.get(r.name) != null) {
					 names.add(r.name);
				 }
			 }
			 else if (r.prefix != null) {
				 for (Enumeration p = properties.keys();
				 p.hasMoreElements();
				) {
					 String name = (String) p.nextElement();
					 if (name.startsWith(r.prefix)) {
						 names.add(name);
					 }
				 }
			 }
			 else if (r.regex != null) {
				 RegexpMatcherFactory matchMaker = new RegexpMatcherFactory();
				 RegexpMatcher matcher = matchMaker.newRegexpMatcher();
				 matcher.setPattern(r.regex);
				 for (Enumeration p = properties.keys();
				 p.hasMoreElements();
				) {
					 String name = (String) p.nextElement();
					 if (matcher.matches(name)) {
						 names.add(name);
					 }
				 }
			 }
			 else if (r.builtin != null) {
				 if (r.builtin.equals(BuiltinPropertySetName.ALL)) {
					 names.addAll(properties.keySet());
				 }
				 else if (r.builtin.equals(BuiltinPropertySetName.SYSTEM)) {
					 names.addAll(System.getProperties().keySet());
				 }
				 else if (r.builtin.equals(BuiltinPropertySetName .COMMANDLINE)) {
					 names.addAll(getProject().getUserProperties().keySet());
				 }
				 else {
					 throw new BuildException(""Impossible: Invalid builtin "" + ""attribute!"");
				 }
			 }
			 else {
				 throw new BuildException(""Impossible: Invalid PropertyRef!"");
			 }
		 }
	 }
	 protected PropertySet getRef() {
		 return (PropertySet) getCheckedRef(PropertySet.class, ""propertyset"");
	 }
	 public final void setRefid(Reference r) {
		 if (!noAttributeSet) {
			 throw tooManyAttributes();
		 }
		 super.setRefid(r);
	 }
	 protected final void assertNotReference() {
		 if (isReference()) {
			 throw tooManyAttributes();
		 }
		 noAttributeSet = false;
	 }
	 private boolean noAttributeSet = true;
	 public static class BuiltinPropertySetName extends EnumeratedAttribute {
		 static final String ALL = ""all"";
		 static final String SYSTEM = ""system"";
		 static final String COMMANDLINE = ""commandline"";
		 public String[] getValues() {
			 return new String[] {
			ALL, SYSTEM, COMMANDLINE}
			;
		 }
	 }
	 public String toString() {
		 if (isReference()) {
			 return getRef().toString();
		 }
		 dieOnCircularReference();
		 StringBuffer b = new StringBuffer();
		 TreeMap sorted = new TreeMap(getProperties());
		 for (Iterator i = sorted.entrySet().iterator();
		 i.hasNext();
		) {
			 Map.Entry e = (Map.Entry) i.next();
			 if (b.length() != 0) {
				 b.append("", "");
			 }
			 b.append(e.getKey().toString());
			 b.append(""="");
			 b.append(e.getValue().toString());
		 }
		 return b.toString();
	 }
	 public Iterator iterator() {
		 if (isReference()) {
			 return getRef().iterator();
		 }
		 dieOnCircularReference();
		 Hashtable props = getEffectiveProperties();
		 Set names = getPropertyNames(props);
		 Mapper myMapper = getMapper();
		 final FileNameMapper m = myMapper == null ? null : myMapper.getImplementation();
		 final Iterator iter = names.iterator();
		 return new Iterator() {
			 public boolean hasNext() {
				 return iter.hasNext();
			 }
			 public Object next() {
				 PropertyResource p = new PropertyResource(getProject(), (String) iter.next());
				 return m == null ? (Resource) p : new MappedResource(p, m);
			 }
			 public void remove() {
				 throw new UnsupportedOperationException();
			 }
		 }
		;
	 }
	 public int size() {
		 return isReference() ? getRef().size() : getProperties().size();
	 }
	 public boolean isFilesystemOnly() {
		 if (isReference()) {
			 return getRef().isFilesystemOnly();
		 }
		 dieOnCircularReference();
		 return false;
	 }
	 protected synchronized void dieOnCircularReference(Stack stk, Project p) throws BuildException {
		 if (isChecked()) {
			 return;
		 }
		 if (isReference()) {
			 super.dieOnCircularReference(stk, p);
		 }
		 else {
			 if (mapper != null) {
				 pushAndInvokeCircularReferenceCheck(mapper, stk, p);
			 }
			 for (Iterator i = setRefs.iterator();
			 i.hasNext();
			 ) {
				 pushAndInvokeCircularReferenceCheck((PropertySet) i.next(), stk, p);
			 }
			 setChecked(true);
		 }
	 }
}",0,0,0,0
"protected static void initialize() {
	 STRAM.setChildren(Sets.newHashSet(APPLICATION, TEMPLATE));
	 APPLICATION.setChildren(Sets.newHashSet(GATEWAY, OPERATOR, STREAM));
	 OPERATOR.setChildren(Sets.newHashSet(PORT));
	 PORT.setChildren(Sets.newHashSet(UNIFIER));
	 STRAM_ELEMENT_TO_CONF_ELEMENT.clear();
	 for (ConfElement confElement: ConfElement.values()) {
		 STRAM_ELEMENT_TO_CONF_ELEMENT.put(confElement.getStramElement(), confElement);
		 for (StramElement sElement: confElement.getAllRelatedElements()) {
			 STRAM_ELEMENT_TO_CONF_ELEMENT.put(sElement, confElement);
		 }
	 }
	 for (ConfElement confElement: ConfElement.values()) {
		 if (confElement.getParent() == null) {
			 continue;
		 }
		 setAmbiguousAttributes(confElement);
	 }
	 CONTEXT_TO_CONF_ELEMENT.clear();
	 for (ConfElement confElement: ConfElement.values()) {
		 CONTEXT_TO_CONF_ELEMENT.put(confElement.getContextClass(), confElement);
	 }
	 Set<Class<? extends Context>> confElementContextClasses = Sets.newHashSet();
	 for (ConfElement confElement: ConfElement.values()) {
		 if (confElement.getContextClass() == null) {
			 continue;
		 }
		 confElementContextClasses.add(confElement.getContextClass());
	 }
	 if (!ContextUtils.CONTEXT_CLASSES.equals(confElementContextClasses)) {
		 throw new IllegalStateException(""All the context classes "" + ContextUtils.CONTEXT_CLASSES + "" found in "" + Context.class + "" are not used by ConfElements "" + confElementContextClasses);
	 }
 }",0,0,1,0
"public class UDFContextTestEvalFunc3 extends EvalFunc<String> {
	 public UDFContextTestEvalFunc3() {
		 Properties p = UDFContext.getUDFContext().getUDFProperties(this.getClass());
		 if (p.getProperty(""key1"") == null) {
			 String name = Thread.currentThread().getName();
			 p.setProperty(""key1"", name);
		 }
	 }
	 public String exec(Tuple input) throws IOException {
		 if (UDFContext.getUDFContext().getJobConf() == null) return ""JobConf is null!"";
		 else return UDFContext.getUDFContext().getUDFProperties(this.getClass()).getProperty(""key1"");
	 }
}",1,0,0,0
"public class OpenTracingConfigurationProperties {
	 private Set<String> excludePatterns;
	 private Boolean encoding;
	 public Set<String> getExcludePatterns() {
		 return excludePatterns;
	 }
	 public void setExcludePatterns(Set<String> excludePatterns) {
		 this.excludePatterns = excludePatterns;
	 }
	 public Boolean getEncoding() {
		 return encoding;
	 }
	 public void setEncoding(Boolean encoding) {
		 this.encoding = encoding;
	 }
}",0,1,0,0
"public class DependScanner extends DirectoryScanner {
	 public static final String DEFAULT_ANALYZER_CLASS = ""org.apache.tools.ant.util.depend.bcel.FullAnalyzer"";
	 private Vector rootClasses;
	 private Vector included;
	 private Vector additionalBaseDirs = new Vector();
	 private DirectoryScanner parentScanner;
	 public DependScanner(DirectoryScanner parentScanner) {
		 this.parentScanner = parentScanner;
	 }
	 public synchronized void setRootClasses(Vector rootClasses) {
		 this.rootClasses = rootClasses;
	 }
	 public String[] getIncludedFiles() {
		 String[] files = new String[getIncludedFilesCount()];
		 for (int i = 0;
		 i < files.length;
		 i++) {
			 files[i] = (String) included.elementAt(i);
		 }
		 return files;
	 }
	 public synchronized int getIncludedFilesCount() {
		 if (included == null) {
			 throw new IllegalStateException();
		 }
		 return included.size();
	 }
	 public synchronized void scan() throws IllegalStateException {
		 included = new Vector();
		 String analyzerClassName = DEFAULT_ANALYZER_CLASS;
		 DependencyAnalyzer analyzer = null;
		 try {
			 Class analyzerClass = Class.forName(analyzerClassName);
			 analyzer = (DependencyAnalyzer) analyzerClass.newInstance();
		 }
		 catch (Exception e) {
			 throw new BuildException(""Unable to load dependency analyzer: "" + analyzerClassName, e);
		 }
		 analyzer.addClassPath(new Path(null, basedir.getPath()));
		 for (Enumeration e = additionalBaseDirs.elements();
		 e.hasMoreElements();
		) {
			 File additionalBaseDir = (File) e.nextElement();
			 analyzer.addClassPath(new Path(null, additionalBaseDir.getPath()));
		 }
		 for (Enumeration e = rootClasses.elements();
		 e.hasMoreElements();
		) {
			 String rootClass = (String) e.nextElement();
			 analyzer.addRootClass(rootClass);
		 }
		 Enumeration e = analyzer.getClassDependencies();
		 String[] parentFiles = parentScanner.getIncludedFiles();
		 Hashtable parentSet = new Hashtable();
		 for (int i = 0;
		 i < parentFiles.length;
		 ++i) {
			 parentSet.put(parentFiles[i], parentFiles[i]);
		 }
		 while (e.hasMoreElements()) {
			 String classname = (String) e.nextElement();
			 String filename = classname.replace('.', File.separatorChar);
			 filename = filename + "".class"";
			 File depFile = new File(basedir, filename);
			 if (depFile.exists() && parentSet.containsKey(filename)) {
				 included.addElement(filename);
			 }
		 }
	 }
	 public void addDefaultExcludes() {
	 }
	 public String[] getExcludedDirectories() {
		 return null;
	 }
	 public String[] getExcludedFiles() {
		 return null;
	 }
	 public String[] getIncludedDirectories() {
		 return new String[0];
	 }
	 public int getIncludedDirsCount() {
		 return 0;
	 }
	 public String[] getNotIncludedDirectories() {
		 return null;
	 }
	 public String[] getNotIncludedFiles() {
		 return null;
	 }
	 public void setExcludes(String[] excludes) {
	 }
	 public void setIncludes(String[] includes) {
	 }
	 public void setCaseSensitive(boolean isCaseSensitive) {
	 }
	 public void addBasedir(File baseDir) {
		 additionalBaseDirs.addElement(baseDir);
	 }
}",0,0,0,0
"public class JcloudsBlobStoreBasedObjectStore implements PersistenceObjectStore {
	 private static final Logger log = LoggerFactory.getLogger(JcloudsBlobStoreBasedObjectStore.class);
	 private final String containerNameFirstPart;
	 private final String containerSubPath;
	 private String locationSpec;
	 private JcloudsLocation location;
	 private BlobStoreContext context;
	 private ManagementContext mgmt;
	 public JcloudsBlobStoreBasedObjectStore(String locationSpec, String containerName) {
		 this.locationSpec = locationSpec;
		 String[] segments = splitOnce(containerName);
		 this.containerNameFirstPart = segments[0];
		 this.containerSubPath = segments[1];
	 }
	 private String[] splitOnce(String path) {
		 String separator = subPathSeparator();
		 int index = path.indexOf(separator);
		 if (index<0) return new String[] {
		 path, """" }
		;
		 return new String[] {
		 path.substring(0, index), path.substring(index+separator.length()) }
		;
	 }
	 public JcloudsBlobStoreBasedObjectStore(JcloudsLocation location, String containerName) {
		 this.location = location;
		 String[] segments = splitOnce(containerName);
		 this.containerNameFirstPart = segments[0];
		 this.containerSubPath = segments[1];
		 getBlobStoreContext();
	 }
	 public String getSummaryName() {
		 return (locationSpec!=null ? locationSpec : location)+"":""+getContainerNameFull();
	 }
	 public synchronized BlobStoreContext getBlobStoreContext() {
		 if (context==null) {
			 if (location==null) {
				 Preconditions.checkNotNull(locationSpec, ""locationSpec required for remote object store when location is null"");
				 Preconditions.checkNotNull(mgmt, ""mgmt not injected / object store not prepared"");
				 location = (JcloudsLocation) mgmt.getLocationRegistry().resolve(locationSpec);
			 }
			 String identity = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_IDENTITY), ""identity must not be null"");
			 String credential = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_CREDENTIAL), ""credential must not be null"");
			 String provider = checkNotNull(location.getConfig(LocationConfigKeys.CLOUD_PROVIDER), ""provider must not be null"");
			 String endpoint = location.getConfig(CloudLocationConfig.CLOUD_ENDPOINT);
			 context = JcloudsUtil.newBlobstoreContext(provider, endpoint, identity, credential);
			 context.getBlobStore().createContainerInLocation(null, getContainerNameFirstPart());
		 }
		 return context;
	 }
	 public void prepareForMasterUse() {
	 }
	 public String getContainerName() {
		 return getContainerNameFull();
	 }
	 protected String getContainerNameFull() {
		 return mergePaths(containerNameFirstPart, containerSubPath);
	 }
	 protected String getContainerNameFirstPart() {
		 return containerNameFirstPart;
	 }
	 protected String getItemInContainerSubPath(String path) {
		 if (Strings.isBlank(containerSubPath)) return path;
		 return mergePaths(containerSubPath, path);
	 }
	 public void createSubPath(String subPath) {
	 }
	 protected void checkPrepared() {
		 if (context==null) throw new IllegalStateException(""object store not prepared"");
	 }
	 public StoreObjectAccessor newAccessor(String path) {
		 checkPrepared();
		 return new JcloudsStoreObjectAccessor(context.getBlobStore(), getContainerNameFirstPart(), getItemInContainerSubPath(path));
	 }
	 protected String mergePaths(String basePath, String ...subPaths) {
		 StringBuilder result = new StringBuilder(basePath);
		 for (String subPath: subPaths) {
			 if (result.length()>0 && subPath.length()>0) {
				 result.append(subPathSeparator());
				 result.append(subPath);
			 }
		 }
		 return result.toString();
	 }
	 protected String subPathSeparator() {
		 return ""/"";
	 }
	 public List<String> listContentsWithSubPath(final String parentSubPath) {
		 checkPrepared();
		 return FluentIterable.from(context.getBlobStore().list(getContainerNameFirstPart(), ListContainerOptions.Builder.inDirectory(getItemInContainerSubPath(parentSubPath)))) .transform(new Function<StorageMetadata, String>() {
			 public String apply( StorageMetadata input) {
				 String result = input.getName();
				 result = Strings.removeFromStart(result, containerSubPath);
				 result = Strings.removeFromStart(result, ""/"");
				 return result;
			 }
		 }
		).toList();
	 }
	 public void close() {
		 if (context!=null) context.close();
	 }
	 public String toString() {
		 return Objects.toStringHelper(this) .add(""blobStoreContext"", context) .add(""basedir"", containerNameFirstPart) .toString();
	 }
	 public void injectManagementContext(ManagementContext mgmt) {
		 if (this.mgmt!=null && !this.mgmt.equals(mgmt)) throw new IllegalStateException(""Cannot change mgmt context of ""+this);
		 this.mgmt = mgmt;
	 }
	 public void prepareForSharedUse( PersistMode persistMode, HighAvailabilityMode haMode) {
		 if (mgmt==null) throw new NullPointerException(""Must inject ManagementContext before preparing ""+this);
		 getBlobStoreContext();
		 if (persistMode==null || persistMode==PersistMode.DISABLED) {
			 log.warn(""Should not be using ""+this+"" when persistMode is ""+persistMode);
			 return;
		 }
		 Boolean backups = mgmt.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_REQUIRED);
		 if (Boolean.TRUE.equals(backups)) {
			 log.warn(""Using legacy backup for ""+this+"";
			 functionality will be removed in future versions, in favor of promotion/demotion-specific backups to a configurable backup location."");
			 throw new FatalConfigurationRuntimeException(""Backups not supported for object store (""+this+"")"");
		 }
	 }
	 public void deleteCompletely() {
		 if (Strings.isBlank(containerSubPath)) getBlobStoreContext().getBlobStore().deleteContainer(containerNameFirstPart);
		 else newAccessor(containerSubPath).delete();
	 }
}",1,0,0,0
"protected void setInternalDate(final String date) {
	 this.date = date;
 }",0,0,0,0
"public class ZooInspectorPanel extends JPanel implements NodeViewersChangeListener {
	 private final IconResource iconResource;
	 private final Toolbar toolbar;
	 private final ZooInspectorNodeViewersPanel nodeViewersPanel;
	 private final ZooInspectorTreeViewer treeViewer;
	 private final ZooInspectorManager zooInspectorManager;
	 private final List<NodeViewersChangeListener> listeners = new ArrayList<NodeViewersChangeListener>();
	 {
		 listeners.add(this);
	 }
	 public ZooInspectorPanel(final ZooInspectorManager zooInspectorManager, final IconResource iconResource) {
		 this.zooInspectorManager = zooInspectorManager;
		 this.iconResource = iconResource;
		 toolbar = new Toolbar(iconResource);
		 final List<ZooInspectorNodeViewer> nodeViewers = new ArrayList<ZooInspectorNodeViewer>();
		 try {
			 List<String> defaultNodeViewersClassNames = this.zooInspectorManager .getDefaultNodeViewerConfiguration();
			 for (String className : defaultNodeViewersClassNames) {
				 nodeViewers.add((ZooInspectorNodeViewer) Class.forName( className).newInstance());
			 }
		 }
		 catch (Exception ex) {
			 LoggerFactory.getLogger().error( ""Error loading default node viewers."", ex);
			 JOptionPane.showMessageDialog(ZooInspectorPanel.this, ""Error loading default node viewers: "" + ex.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
		 }
		 nodeViewersPanel = new ZooInspectorNodeViewersPanel( zooInspectorManager, nodeViewers);
		 treeViewer = new ZooInspectorTreeViewer(zooInspectorManager, nodeViewersPanel, iconResource);
		 this.setLayout(new BorderLayout());
		 toolbar.addActionListener(Toolbar.Button.connect, new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 ZooInspectorConnectionPropertiesDialog zicpd = new ZooInspectorConnectionPropertiesDialog( zooInspectorManager.getLastConnectionProps(), zooInspectorManager.getConnectionPropertiesTemplate(), ZooInspectorPanel.this);
				 zicpd.setVisible(true);
			 }
		 }
		);
		 toolbar.addActionListener(Toolbar.Button.disconnect, new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 disconnect();
			 }
		 }
		);
		 toolbar.addActionListener(Toolbar.Button.refresh, new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 treeViewer.refreshView();
			 }
		 }
		);
		 toolbar.addActionListener(Toolbar.Button.addNode, new AddNodeAction(this, treeViewer, zooInspectorManager));
		 toolbar.addActionListener(Toolbar.Button.deleteNode, new DeleteNodeAction(this, treeViewer, zooInspectorManager));
		 toolbar.addActionListener(Toolbar.Button.nodeViewers, new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 ZooInspectorNodeViewersDialog nvd = new ZooInspectorNodeViewersDialog( JOptionPane.getRootFrame(), nodeViewers, listeners, zooInspectorManager, iconResource);
				 nvd.setVisible(true);
			 }
		 }
		);
		 toolbar.addActionListener(Toolbar.Button.about, new ActionListener() {
			 public void actionPerformed(ActionEvent e) {
				 ZooInspectorAboutDialog zicpd = new ZooInspectorAboutDialog( JOptionPane.getRootFrame(), iconResource);
				 zicpd.setVisible(true);
			 }
		 }
		);
		 JScrollPane treeScroller = new JScrollPane(treeViewer);
		 JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, treeScroller, nodeViewersPanel);
		 splitPane.setResizeWeight(0.25);
		 this.add(splitPane, BorderLayout.CENTER);
		 this.add(toolbar.getJToolBar(), BorderLayout.NORTH);
	 }
	 public void connect(final Properties connectionProps) {
		 SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {
			 protected Boolean doInBackground() throws Exception {
				 zooInspectorManager.setLastConnectionProps(connectionProps);
				 return zooInspectorManager.connect(connectionProps);
			 }
			 protected void done() {
				 try {
					 if (get()) {
						 treeViewer.refreshView();
						 toolbar.toggleButtons(true);
					 }
					 else {
						 JOptionPane.showMessageDialog(ZooInspectorPanel.this, ""Unable to connect to zookeeper"", ""Error"", JOptionPane.ERROR_MESSAGE);
					 }
				 }
				 catch (InterruptedException e) {
					 LoggerFactory .getLogger() .error( ""Error occurred while connecting to ZooKeeper server"", e);
				 }
				 catch (ExecutionException e) {
					 LoggerFactory .getLogger() .error( ""Error occurred while connecting to ZooKeeper server"", e);
				 }
			 }
		 }
		;
		 worker.execute();
	 }
	 public void disconnect() {
		 disconnect(false);
	 }
	 public void disconnect(boolean wait) {
		 SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {
			 protected Boolean doInBackground() throws Exception {
				 return ZooInspectorPanel.this.zooInspectorManager.disconnect();
			 }
			 protected void done() {
				 try {
					 if (get()) {
						 treeViewer.clearView();
						 toolbar.toggleButtons(false);
					 }
				 }
				 catch (InterruptedException e) {
					 LoggerFactory .getLogger() .error( ""Error occurred while disconnecting from ZooKeeper server"", e);
				 }
				 catch (ExecutionException e) {
					 LoggerFactory .getLogger() .error( ""Error occurred while disconnecting from ZooKeeper server"", e);
				 }
			 }
		 }
		;
		 worker.execute();
		 if (wait) {
			 while (!worker.isDone()) {
				 try {
					 Thread.sleep(100);
				 }
				 catch (InterruptedException e) {
					 LoggerFactory .getLogger() .error( ""Error occurred while disconnecting from ZooKeeper server"", e);
				 }
			 }
		 }
	 }
	 public void nodeViewersChanged(List<ZooInspectorNodeViewer> newViewers) {
		 this.nodeViewersPanel.setNodeViewers(newViewers);
	 }
	 public void setdefaultConnectionProps(Properties connectionProps) throws IOException {
		 this.zooInspectorManager.saveDefaultConnectionFile(connectionProps);
	 }
}",1,0,0,0
"class LexerQuery extends AbsLexer implements org.apache.jena.iri.ViolationCodes, org.apache.jena.iri.IRIComponents, Lexer {
	 private static final int YYEOF = -1;
	 private static final int ZZ_BUFFERSIZE = 2048;
	 public static final int YYINITIAL = 0;
	 private static final int ZZ_LEXSTATE[] = {
	 0, 1 }
	;
	 private static final String ZZ_CMAP_PACKED = ""\11\14\1\13\1\13\2\14\1\13\22\14\1\12\1\4\1\17\1\0""+ ""\1\4\1\5\7\4\2\3\1\1\1\7\1\10\1\6\7\10\1\2""+ ""\1\4\1\17\1\4\1\17\1\1\1\2\6\10\24\3\1\0\1\17""+ ""\1\0\1\17\1\3\1\17\1\11\5\11\24\3\3\17\1\3\6\16""+ ""\1\15\32\16\ud760\22\u0400\20\u0400\21\u2000\22"";
	 private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
	 private static final int [] ZZ_ACTION = zzUnpackAction();
	 private static final String ZZ_ACTION_PACKED_0 = ""\2\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7""+ ""\1\10\1\11\1\12\1\13\1\14\2\15\1\16\1\17""+ ""\3\0\1\20\1\21\1\22\1\23\1\24"";
	 private static int [] zzUnpackAction() {
		 int [] result = new int[26];
		 int offset = 0;
		 offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAction(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
	 private static final String ZZ_ROWMAP_PACKED_0 = ""\0\0\0\23\0\46\0\46\0\46\0\46\0\46\0\71""+ ""\0\114\0\46\0\46\0\46\0\46\0\46\0\137\0\46""+ ""\0\46\0\114\0\162\0\205\0\230\0\46\0\46\0\46""+ ""\0\46\0\46"";
	 private static int [] zzUnpackRowMap() {
		 int [] result = new int[26];
		 int offset = 0;
		 offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackRowMap(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int high = packed.charAt(i++) << 16;
			 result[j++] = high | packed.charAt(i++);
		 }
		 return j;
	 }
	 private static final int [] ZZ_TRANS = zzUnpackTrans();
	 private static final String ZZ_TRANS_PACKED_0 = ""\1\3\1\4\1\5\1\6\1\7\1\10\4\6\1\11""+ ""\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21""+ ""\1\3\1\4\1\5\1\6\1\7\1\10\4\6\1\22""+ ""\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21""+ ""\31\0\1\23\2\24\1\25\23\0\1\26\31\0\1\27""+ ""\7\0\1\30\1\31\1\30\1\32\17\0\3\30\1\32""+ ""\17\0\4\32\11\0"";
	 private static int [] zzUnpackTrans() {
		 int [] result = new int[171];
		 int offset = 0;
		 offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackTrans(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 value--;
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private static final int ZZ_UNKNOWN_ERROR = 0;
	 private static final int ZZ_NO_MATCH = 1;
	 private static final int ZZ_PUSHBACK_2BIG = 2;
	 private static final String ZZ_ERROR_MSG[] = {
	 ""Unkown internal scanner error"", ""Error: could not match input"", ""Error: pushback value was too large"" }
	;
	 private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
	 private static final String ZZ_ATTRIBUTE_PACKED_0 = ""\2\0\5\11\2\1\5\11\1\1\2\11\1\1\3\0""+ ""\5\11"";
	 private static int [] zzUnpackAttribute() {
		 int [] result = new int[26];
		 int offset = 0;
		 offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
		 return result;
	 }
	 private static int zzUnpackAttribute(String packed, int offset, int [] result) {
		 int i = 0;
		 int j = offset;
		 int l = packed.length();
		 while (i < l) {
			 int count = packed.charAt(i++);
			 int value = packed.charAt(i++);
			 do result[j++] = value;
			 while (--count > 0);
		 }
		 return j;
	 }
	 private java.io.Reader zzReader;
	 private int zzState;
	 private int zzLexicalState = YYINITIAL;
	 private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
	 private int zzMarkedPos;
	 private int zzCurrentPos;
	 private int zzStartRead;
	 private int zzEndRead;
	 private int yyline;
	 private int yychar;
	 private int yycolumn;
	 private boolean zzAtBOL = true;
	 private boolean zzAtEOF;
	 private boolean zzEOFDone;
	 private int lastChar;
	 char[] zzBuffer() {
		 yyreset(null);
		 this.zzAtEOF = true;
		 int length = parser.end(range)-parser.start(range);
		 lastChar = length - 1;
		 zzEndRead = length;
		 while (length > zzBuffer.length) zzBuffer = new char[zzBuffer.length*2];
		 return zzBuffer;
	 }
	 LexerQuery(java.io.Reader in) {
		 this.zzReader = in;
	 }
	 LexerQuery(java.io.InputStream in) {
		 this(new java.io.InputStreamReader(in));
	 }
	 private static char [] zzUnpackCMap(String packed) {
		 char [] map = new char[0x10000];
		 int i = 0;
		 int j = 0;
		 while (i < 92) {
			 int count = packed.charAt(i++);
			 char value = packed.charAt(i++);
			 do map[j++] = value;
			 while (--count > 0);
		 }
		 return map;
	 }
	 private boolean zzRefill() throws java.io.IOException {
		 if (zzStartRead > 0) {
			 System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead);
			 zzEndRead-= zzStartRead;
			 zzCurrentPos-= zzStartRead;
			 zzMarkedPos-= zzStartRead;
			 zzStartRead = 0;
		 }
		 if (zzCurrentPos >= zzBuffer.length) {
			 char newBuffer[] = new char[zzCurrentPos*2];
			 System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
			 zzBuffer = newBuffer;
		 }
		 int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length-zzEndRead);
		 if (numRead > 0) {
			 zzEndRead+= numRead;
			 return false;
		 }
		 if (numRead == 0) {
			 int c = zzReader.read();
			 if (c == -1) {
				 return true;
			 }
			 else {
				 zzBuffer[zzEndRead++] = (char) c;
				 return false;
			 }
		 }
		 return true;
	 }
	 private final void yyclose() throws java.io.IOException {
		 zzAtEOF = true;
		 zzEndRead = zzStartRead;
		 if (zzReader != null) zzReader.close();
	 }
	 private final void yyreset(java.io.Reader reader) {
		 zzReader = reader;
		 zzAtBOL = true;
		 zzAtEOF = false;
		 zzEOFDone = false;
		 zzEndRead = zzStartRead = 0;
		 zzCurrentPos = zzMarkedPos = 0;
		 yyline = yychar = yycolumn = 0;
		 zzLexicalState = YYINITIAL;
	 }
	 private final int yystate() {
		 return zzLexicalState;
	 }
	 private final void yybegin(int newState) {
		 zzLexicalState = newState;
	 }
	 final String yytext() {
		 return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
	 }
	 private final char yycharat(int pos) {
		 return zzBuffer[zzStartRead+pos];
	 }
	 private final int yylength() {
		 return zzMarkedPos-zzStartRead;
	 }
	 private void zzScanError(int errorCode) {
		 String message;
		 try {
			 message = ZZ_ERROR_MSG[errorCode];
		 }
		 catch (ArrayIndexOutOfBoundsException e) {
			 message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
		 }
		 throw new Error(message);
	 }
	 public void yypushback(int number) {
		 if ( number > yylength() ) zzScanError(ZZ_PUSHBACK_2BIG);
		 zzMarkedPos -= number;
	 }
	public int yylex() throws java.io.IOException {
		 int zzInput;
		 int zzAction;
		 int zzCurrentPosL;
		 int zzMarkedPosL;
		 int zzEndReadL = zzEndRead;
		 char [] zzBufferL = zzBuffer;
		 char [] zzCMapL = ZZ_CMAP;
		 int [] zzTransL = ZZ_TRANS;
		 int [] zzRowMapL = ZZ_ROWMAP;
		 int [] zzAttrL = ZZ_ATTRIBUTE;
		 while (true) {
			 zzMarkedPosL = zzMarkedPos;
			 yychar+= zzMarkedPosL-zzStartRead;
			 if (zzMarkedPosL > zzStartRead) {
				 switch (zzBufferL[zzMarkedPosL-1]) {
					 case '\n': case '\u000B': case '\u000C': case '\u0085': case '\u2028': case '\u2029': zzAtBOL = true;
					 break;
					 case '\r': if (zzMarkedPosL < zzEndReadL) zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 else if (zzAtEOF) zzAtBOL = false;
					 else {
						 boolean eof = zzRefill();
						 zzMarkedPosL = zzMarkedPos;
						 zzEndReadL = zzEndRead;
						 zzBufferL = zzBuffer;
						 if (eof) zzAtBOL = false;
						 else zzAtBOL = zzBufferL[zzMarkedPosL] != '\n';
					 }
					 break;
					 default: zzAtBOL = false;
				 }
			 }
			 zzAction = -1;
			 zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
			 if (zzAtBOL) zzState = ZZ_LEXSTATE[zzLexicalState+1];
			 else zzState = ZZ_LEXSTATE[zzLexicalState];
			 zzForAction: {
				 while (true) {
					 if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++];
					 else if (zzAtEOF) {
						 zzInput = YYEOF;
						 break zzForAction;
					 }
					 else {
						 zzCurrentPos = zzCurrentPosL;
						 zzMarkedPos = zzMarkedPosL;
						 boolean eof = zzRefill();
						 zzCurrentPosL = zzCurrentPos;
						 zzMarkedPosL = zzMarkedPos;
						 zzBufferL = zzBuffer;
						 zzEndReadL = zzEndRead;
						 if (eof) {
							 zzInput = YYEOF;
							 break zzForAction;
						 }
						 else {
							 zzInput = zzBufferL[zzCurrentPosL++];
						 }
					 }
					 int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
					 if (zzNext == -1) break zzForAction;
					 zzState = zzNext;
					 int zzAttributes = zzAttrL[zzState];
					 if ( (zzAttributes & 1) == 1 ) {
						 zzAction = zzState;
						 zzMarkedPosL = zzCurrentPosL;
						 if ( (zzAttributes & 8) == 8 ) break zzForAction;
					 }
				 }
			 }
			 zzMarkedPos = zzMarkedPosL;
			 switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
				 case 16: {
					 rule(-70);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 21: break;
				 case 11: {
					 rule(-115);
					 error(DISCOURAGED_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 22: break;
				 case 14: {
					 rule(-150);
					 difficultChar();
				 }
				 case 23: break;
				 case 2: {
					 rule(1);
				 }
				 case 24: break;
				 case 17: {
					 rule(-130);
					 surrogatePair();
				 }
				 case 25: break;
				 case 18: {
					 rule(-40);
					 error(PERCENT);
				 }
				 case 26: break;
				 case 13: {
					 rule(-140);
					 error(LONE_SURROGATE);
					 difficultChar();
				 }
				 case 27: break;
				 case 15: {
					 rule(-80);
					 error(DOUBLE_WHITESPACE);
				 }
				 case 28: break;
				 case 20: {
					 rule(-50);
					 error(PERCENT);
					 error(PERCENT_ENCODING_SHOULD_BE_UPPERCASE);
				 }
				 case 29: break;
				 case 7: {
					 rule(-90);
					 if (yychar==lastChar) error(DOUBLE_WHITESPACE);
					 else error(WHITESPACE);
				 }
				 case 30: break;
				 case 12: {
					 rule(-120);
					 error(UNWISE_CHARACTER);
				 }
				 case 31: break;
				 case 10: {
					 rule(-113);
					 error(CONTROL_CHARACTER);
				 }
				 case 32: break;
				 case 4: {
					 rule(-10);
				 }
				 case 33: break;
				 case 3: {
					 rule(2);
				 }
				 case 34: break;
				 case 19: {
					 rule(-30);
					 error(PERCENT_20);
				 }
				 case 35: break;
				 case 6: {
					 rule(-60);
					 error(ILLEGAL_PERCENT_ENCODING);
				 }
				 case 36: break;
				 case 5: {
					 rule(-20);
				 }
				 case 37: break;
				 case 8: {
					 rule(-100);
					 error(CONTROL_CHARACTER);
					 error(NOT_XML_SCHEMA_WHITESPACE);
				 }
				 case 38: break;
				 case 1: {
					 rule(-160);
					 error(ILLEGAL_CHARACTER);
				 }
				 case 39: break;
				 case 9: {
					 rule(-110);
					 error(NON_XML_CHARACTER);
					 error(CONTROL_CHARACTER);
				 }
				 case 40: break;
				 default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
					 zzAtEOF = true;
					 return YYEOF;
				 }
				 else {
					 zzScanError(ZZ_NO_MATCH);
				 }
			 }
		 }
	 }
}",1,0,0,0
"public class XelatexRunner extends LatexRunner {
	 public XelatexRunner() {
		 super();
	 }
	 protected String getWindowsProgramName() {
		 return ""xelatex.exe"";
	 }
	 protected String getUnixProgramName() {
		 return ""xelatex"";
	 }
	 public String getDescription() {
		 return ""XeLatex program"";
	 }
	 public String getDefaultArguments() {
		 return ""-synctex=1 ""+super.getDefaultArguments();
	 }
	 public String getOutputFormat() {
		 return TexlipseProperties.OUTPUT_FORMAT_PDF;
	 }
}",0,1,0,0
"public static String getNamespaceURI(Node node) {
	 if (node instanceof Document) {
		 node = ((Document) node).getDocumentElement();
	 }
	 Element element = (Element) node;
	 String uri = element.getNamespaceURI();
	 if (uri == null) {
		 String prefix = getPrefix(node);
		 String qname = prefix == null ? ""xmlns"" : ""xmlns:"" + prefix;
		 Node aNode = node;
		 while (aNode != null) {
			 if (aNode.getNodeType() == Node.ELEMENT_NODE) {
				 Attr attr = ((Element) aNode).getAttributeNode(qname);
				 if (attr != null) {
					 uri = attr.getValue();
					 break;
				 }
			 }
			 aNode = aNode.getParentNode();
		 }
	 }
	 return """".equals(uri) ? null : uri;
 }",0,0,1,0
"public RelOptCost getCost(HiveJoin join) {
	 final RelMetadataQuery mq = join.getCluster().getMetadataQuery();
	 final Double leftRCount = mq.getRowCount(join.getLeft());
	 final Double rightRCount = mq.getRowCount(join.getRight());
	 if (leftRCount == null || rightRCount == null) {
		 return null;
	 }
	 final double rCount = leftRCount + rightRCount;
	 ImmutableList<Double> cardinalities = new ImmutableList.Builder<Double>(). add(leftRCount). add(rightRCount). build();
	 ImmutableBitSet.Builder streamingBuilder = ImmutableBitSet.builder();
	 switch (join.getStreamingSide()) {
		 case LEFT_RELATION: streamingBuilder.set(0);
		 break;
		 case RIGHT_RELATION: streamingBuilder.set(1);
		 break;
		 default: return null;
	 }
	 ImmutableBitSet streaming = streamingBuilder.build();
	 final double cpuCost = algoUtils.computeBucketMapJoinCPUCost(cardinalities, streaming);
	 final Double leftRAverageSize = mq.getAverageRowSize(join.getLeft());
	 final Double rightRAverageSize = mq.getAverageRowSize(join.getRight());
	 if (leftRAverageSize == null || rightRAverageSize == null) {
		 return null;
	 }
	 ImmutableList<Pair<Double,Double>> relationInfos = new ImmutableList.Builder<Pair<Double,Double>>(). add(new Pair<Double,Double>(leftRCount,leftRAverageSize)). add(new Pair<Double,Double>(rightRCount,rightRAverageSize)). build();
	 JoinAlgorithm oldAlgo = join.getJoinAlgorithm();
	 join.setJoinAlgorithm(TezBucketJoinAlgorithm.INSTANCE);
	 final int parallelism = mq.splitCount(join) == null ? 1 : mq.splitCount(join);
	 join.setJoinAlgorithm(oldAlgo);
	 final double ioCost = algoUtils.computeBucketMapJoinIOCost(relationInfos, streaming, parallelism);
	 return HiveCost.FACTORY.makeCost(rCount, cpuCost, ioCost);
 }",0,0,1,0
"public synchronized Task pollForNewTask(String taskTracker) {
	 int remainingReduceLoad = 0;
	 int remainingMapLoad = 0;
	 int numTaskTrackers;
	 TaskTrackerStatus tts;
	 synchronized (taskTrackers) {
		 numTaskTrackers = taskTrackers.size();
		 tts = (TaskTrackerStatus) taskTrackers.get(taskTracker);
	 }
	 if (tts == null) {
		 LOG.warn(""Unknown task tracker polling;
		 ignoring: "" + taskTracker);
		 return null;
	 }
	 int totalCapacity = numTaskTrackers * maxCurrentTasks;
	 synchronized(jobsByArrival){
		 for (Iterator it = jobsByArrival.iterator();
		 it.hasNext();
		 ) {
			 JobInProgress job = (JobInProgress) it.next();
			 if (job.getStatus().getRunState() == JobStatus.RUNNING) {
				 int totalMapTasks = job.desiredMaps();
				 int totalReduceTasks = job.desiredReduces();
				 remainingMapLoad += (totalMapTasks - job.finishedMaps());
				 remainingReduceLoad += (totalReduceTasks - job.finishedReduces());
			 }
		 }
	 }
	 int maxMapLoad = 0;
	 int maxReduceLoad = 0;
	 if (numTaskTrackers > 0) {
		 maxMapLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingMapLoad / numTaskTrackers));
		 maxReduceLoad = Math.min(maxCurrentTasks, (int) Math.ceil((double) remainingReduceLoad / numTaskTrackers));
	 }
	 int numMaps = tts.countMapTasks();
	 int numReduces = tts.countReduceTasks();
	 synchronized (jobsByArrival) {
		 if (numMaps < maxMapLoad) {
			 int totalNeededMaps = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING) {
					 continue;
				 }
				 Task t = job.obtainNewMapTask(tts, numTaskTrackers);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 myMetrics.launchMap();
					 return t;
				 }
				 totalNeededMaps += job.desiredMaps();
				 int padding = 0;
				 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, (int)(totalNeededMaps * PAD_FRACTION));
				 }
				 if (totalMaps + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
		 if (numReduces < maxReduceLoad) {
			 int totalNeededReduces = 0;
			 for (Iterator it = jobsByArrival.iterator();
			 it.hasNext();
			 ) {
				 JobInProgress job = (JobInProgress) it.next();
				 if (job.getStatus().getRunState() != JobStatus.RUNNING || job.numReduceTasks == 0) {
					 continue;
				 }
				 Task t = job.obtainNewReduceTask(tts, numTaskTrackers);
				 if (t != null) {
					 expireLaunchingTasks.addNewTask(t.getTaskId());
					 myMetrics.launchReduce();
					 return t;
				 }
				 totalNeededReduces += job.desiredReduces();
				 int padding = 0;
				 if (numTaskTrackers > MIN_CLUSTER_SIZE_FOR_PADDING) {
					 padding = Math.min(maxCurrentTasks, (int) (totalNeededReduces * PAD_FRACTION));
				 }
				 if (totalReduces + padding >= totalCapacity) {
					 break;
				 }
			 }
		 }
	 }
	 return null;
 }",0,0,1,0
"public void thiningIteration(int iter) {
	 int[][] marker = new int[width][height];
	 for (int i = 1;
	 i < width - 1;
	 i++) {
		 for (int j = 1;
		 j < height - 1;
		 j++) {
			 int p2 = imageM[i - 1][j];
			 int p3 = imageM[i - 1][j + 1];
			 int p4 = imageM[i][j + 1];
			 int p5 = imageM[i + 1][j + 1];
			 int p6 = imageM[i + 1][j];
			 int p7 = imageM[i + 1][j - 1];
			 int p8 = imageM[i][j - 1];
			 int p9 = imageM[i - 1][j - 1];
			 int c1 = 0;
			 int c2 = 0;
			 int c3 = 0;
			 int c4 = 0;
			 int c5 = 0;
			 int c6 = 0;
			 int c7 = 0;
			 int c8 = 0;
			 if (p2 == 0 && p3 == 1) {
				 c1 = 1;
			 }
			 if (p3 == 0 && p4 == 1) {
				 c2 = 1;
			 }
			 if (p4 == 0 && p5 == 1) {
				 c3 = 1;
			 }
			 if (p5 == 0 && p6 == 1) {
				 c4 = 1;
			 }
			 if (p6 == 0 && p7 == 1) {
				 c5 = 1;
			 }
			 if (p7 == 0 && p8 == 1) {
				 c6 = 1;
			 }
			 if (p8 == 0 && p9 == 1) {
				 c7 = 1;
			 }
			 if (p9 == 0 && p2 == 1) {
				 c8 = 1;
			 }
			 int A = c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8;
			 int B = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9;
			 int m1 = iter == 0 ? (p2 * p4 * p6) : (p2 * p4 * p8);
			 int m2 = iter == 0 ? (p4 * p6 * p8) : (p2 * p6 * p8);
			 if (A == 1 && (B >= 2 && B <= 6) && m1 == 0 && m2 == 0) {
				 marker[i][j] = 1;
			 }
		 }
	 }
	 for (int i = 0;
	 i < width;
	 i++) {
		 for (int j = 0;
		 j < height;
		 j++) {
			 int tmp = 1 - marker[i][j];
			 if (imageM[i][j] == tmp && imageM[i][j] == 1) {
				 imageM[i][j] = 1;
			 }
			 else {
				 imageM[i][j] = 0;
			 }
		 }
	 }
 }",0,0,1,0
"public interface LINK extends Attrs, _Child {
	 LINK $href(String uri);
	 LINK $hreflang(String cdata);
	 LINK $type(String cdata);
	 LINK $rel(EnumSet<LinkType> linkTypes);
	 LINK $rel(String linkTypes);
	 LINK $media(EnumSet<Media> mediaTypes);
	 LINK $media(String mediaTypes);
 }",0,1,0,0
"public Map<String, ConsumerGroupRollBackStat> resetOffset(ResetOffsetRequest resetOffsetRequest) {
	 Map<String, ConsumerGroupRollBackStat> groupRollbackStats = Maps.newHashMap();
	 for (String consumerGroup : resetOffsetRequest.getConsumerGroupList()) {
		 try {
			 Map<MessageQueue, Long> rollbackStatsMap = mqAdminExt.resetOffsetByTimestamp(resetOffsetRequest.getTopic(), consumerGroup, resetOffsetRequest.getResetTime(), resetOffsetRequest.isForce());
			 ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
			 List<RollbackStats> rollbackStatsList = consumerGroupRollBackStat.getRollbackStatsList();
			 for (Map.Entry<MessageQueue, Long> rollbackStatsEntty : rollbackStatsMap.entrySet()) {
				 RollbackStats rollbackStats = new RollbackStats();
				 rollbackStats.setRollbackOffset(rollbackStatsEntty.getValue());
				 rollbackStats.setQueueId(rollbackStatsEntty.getKey().getQueueId());
				 rollbackStats.setBrokerName(rollbackStatsEntty.getKey().getBrokerName());
				 rollbackStatsList.add(rollbackStats);
			 }
			 groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
		 }
		 catch (MQClientException e) {
			 if (ResponseCode.CONSUMER_NOT_ONLINE == e.getResponseCode()) {
				 try {
					 ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
					 List<RollbackStats> rollbackStatsList = mqAdminExt.resetOffsetByTimestampOld(consumerGroup, resetOffsetRequest.getTopic(), resetOffsetRequest.getResetTime(), true);
					 consumerGroupRollBackStat.setRollbackStatsList(rollbackStatsList);
					 groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
					 continue;
				 }
				 catch (Exception err) {
					 logger.error(""op=resetOffset_which_not_online_error"", err);
				 }
			 }
			 else {
				 logger.error(""op=resetOffset_error"", e);
			 }
			 groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
		 }
		 catch (Exception e) {
			 logger.error(""op=resetOffset_error"", e);
			 groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
		 }
	 }
	 return groupRollbackStats;
 }",0,0,1,0
"public abstract class ShareContent<P extends ShareContent, E extends ShareContent.Builder> implements ShareModel {
	 private final Uri contentUrl;
	 private final List<String> peopleIds;
	 private final String placeId;
	 private final String pageId;
	 private final String ref;
	 private final ShareHashtag hashtag;
	 protected ShareContent(final Builder builder) {
		 super();
		 this.contentUrl = builder.contentUrl;
		 this.peopleIds = builder.peopleIds;
		 this.placeId = builder.placeId;
		 this.pageId = builder.pageId;
		 this.ref = builder.ref;
		 this.hashtag = builder.hashtag;
	 }
	 protected ShareContent(final Parcel in) {
		 this.contentUrl = in.readParcelable(Uri.class.getClassLoader());
		 this.peopleIds = readUnmodifiableStringList(in);
		 this.placeId = in.readString();
		 this.pageId = in.readString();
		 this.ref = in.readString();
		 this.hashtag = new ShareHashtag.Builder().readFrom(in).build();
	 }
	 public Uri getContentUrl() {
		 return this.contentUrl;
	 }
	 public List<String> getPeopleIds() {
		 return this.peopleIds;
	 }
	 public String getPlaceId() {
		 return this.placeId;
	 }
	 public String getPageId() {
		 return this.pageId;
	 }
	 public String getRef() {
		 return this.ref;
	 }
	 public ShareHashtag getShareHashtag() {
		 return this.hashtag;
	 }
	 public int describeContents() {
		 return 0;
	 }
	 public void writeToParcel(final Parcel out, final int flags) {
		 out.writeParcelable(this.contentUrl, 0);
		 out.writeStringList(this.peopleIds);
		 out.writeString(this.placeId);
		 out.writeString(this.pageId);
		 out.writeString(this.ref);
		 out.writeParcelable(this.hashtag, 0);
	 }
	 private List<String> readUnmodifiableStringList(final Parcel in) {
		 final List<String> list = new ArrayList<String>();
		 in.readStringList(list);
		 return (list.size() == 0 ? null : Collections.unmodifiableList(list));
	 }
	 public abstract static class Builder<P extends ShareContent, E extends Builder> implements ShareModelBuilder<P, E> {
		 private Uri contentUrl;
		 private List<String> peopleIds;
		 private String placeId;
		 private String pageId;
		 private String ref;
		 private ShareHashtag hashtag;
		 public E setContentUrl( final Uri contentUrl) {
			 this.contentUrl = contentUrl;
			 return (E) this;
		 }
		 public E setPeopleIds( final List<String> peopleIds) {
			 this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));
			 return (E) this;
		 }
		 public E setPlaceId( final String placeId) {
			 this.placeId = placeId;
			 return (E) this;
		 }
		 public E setPageId( final String pageId) {
			 this.pageId = pageId;
			 return (E) this;
		 }
		 public E setRef( final String ref) {
			 this.ref = ref;
			 return (E) this;
		 }
		 public E setShareHashtag( final ShareHashtag shareHashtag) {
			 this.hashtag = shareHashtag;
			 return (E) this;
		 }
		 public E readFrom(final P content) {
			 if (content == null) {
				 return (E) this;
			 }
			 return (E) this .setContentUrl(content.getContentUrl()) .setPeopleIds(content.getPeopleIds()) .setPlaceId(content.getPlaceId()) .setPageId(content.getPageId()) .setRef(content.getRef());
		 }
	 }
}",1,1,0,0
"static public Object postUpdate(String itemName, String stateString) {
	 ItemRegistry registry = ScriptServiceUtil.getItemRegistry();
	 EventPublisher publisher = ScriptServiceUtil.getEventPublisher();
	 if (publisher != null && registry != null) {
		 try {
			 Item item = registry.getItem(itemName);
			 State state = TypeParser.parseState(item.getAcceptedDataTypes(), stateString);
			 if (state != null) {
				 publisher.post(ItemEventFactory.createStateEvent(itemName, state));
			 }
			 else {
				 LoggerFactory.getLogger(BusEvent.class).warn( ""Cannot convert '{
				}
				' to a state type which item '{
				}
				' accepts: {
				}
				."", stateString, itemName, getAcceptedDataTypeNames(item));
			 }
		 }
		 catch (ItemNotFoundException e) {
			 LoggerFactory.getLogger(BusEvent.class).warn(""Item '{
			}
			' does not exist."", itemName);
		 }
	 }
	 return null;
 }",0,0,1,0
"public class TestTypedLiterals extends TestCase {
	 private Model m = ModelFactory.createDefaultModel();
	 public TestTypedLiterals( String name ) {
		 super( name );
	 }
	 public static TestSuite suite() {
		 return new TestSuite( TestTypedLiterals.class );
	 }
	 public void testUnknown() {
		 String typeURI = ""urn:x-hp-dt:unknown"";
		 String typeURI2 = ""urn:x-hp-dt:unknown2"";
		 boolean originalFlag = JenaParameters.enableSilentAcceptanceOfUnknownDatatypes;
		 JenaParameters.enableSilentAcceptanceOfUnknownDatatypes = true;
		 Literal l1 = m.createTypedLiteral(""foo"", typeURI);
		 Literal l3 = m.createTypedLiteral(""15"", typeURI);
		 Literal l5 = m.createTypedLiteral(""foo"", typeURI2);
		 Literal l6 = m.createLiteral(""foo"", ""lang1"");
		 JenaParameters.enableSilentAcceptanceOfUnknownDatatypes = originalFlag;
		 assertNotNull(l1);
		 assertNotNull(l3);
		 assertNotNull(l5);
		 assertDiffer(""datatype sensitive"", l1, l5);
		 assertDiffer(""value sensitive"", l1, l3);
		 assertDiffer(""typed and plain differ"", l1, l6);
		 try {
			 l3.getInt();
			 assertTrue(""Allowed int conversion"", false);
		 }
		 catch (DatatypeFormatException e) {
		}
		 assertEquals(""Extract value"", l1.getValue(), new BaseDatatype.TypedValue(""foo"", typeURI));
		 assertEquals(""Extract xml tag"", l1.isWellFormedXML(), false);
		 JenaParameters.enableSilentAcceptanceOfUnknownDatatypes = false;
		 boolean foundException = false;
		 try {
			 m.createTypedLiteral(""food"", typeURI+""3"");
		 }
		 catch (DatatypeFormatException e2) {
			 foundException = true;
		 }
		 JenaParameters.enableSilentAcceptanceOfUnknownDatatypes = originalFlag;
		 assertTrue(""Detected unknown datatype"", foundException);
		 Object foo = new java.sql.Date(123456l);
		 LiteralLabel ll = LiteralLabelFactory.createTypedLiteral(foo);
		 assertEquals(ll.getLexicalForm(), foo.toString());
	 }
	 public void testUserDef() {
		 RDFDatatype rtype = RationalType.theRationalType;
		 TypeMapper.getInstance().registerDatatype(rtype);
		 Literal l1 = m.createTypedLiteral(""3/5"", rtype);
		 Literal l3 = m.createTypedLiteral(""7/5"", rtype);
		 assertNotNull(l1);
		 assertNotNull(l3);
		 assertDiffer(""values should be tested!"", l1, l3);
		 assertSame(""Datatype incorrect"", l1.getDatatype(), rtype);
		 assertEquals(""Datatype uri incorrect"", l1.getDatatypeURI(), RationalType.theTypeURI);
		 Object val = l1.getValue();
		 assertTrue(""Value space check"", val instanceof Rational);
		 assertTrue(""Value check"", ((Rational)val).getNumerator() == 3);
		 assertTrue(""Value check"", ((Rational)val).getDenominator() == 5);
		 try {
			 l1.getInt();
			 assertTrue(""Allowed int conversion"", false);
		 }
		 catch (DatatypeFormatException e) {
		}
		 assertEquals(""Extract xml tag"", l1.isWellFormedXML(), false);
	 }
	 public void testXMLLiteral() {
		 Literal ll2 = m.createTypedLiteral(""<good></good>"",XMLLiteralType.theXMLLiteralType);
		assertTrue(""Well-formed XMLLiteral."",((EnhNode)ll2).asNode().getLiteralIsXML());
	 }
	 public void testRDFLangString_1() {
		 RDFDatatype dt = TypeMapper.getInstance().getTypeByName(RDF.langString.getURI()) ;
		 assertEquals(RDF.dtLangString, dt) ;
		 assertTrue(RDF.dtLangString == dt) ;
	 }
	 public void testRDFLangString_2() {
		 Literal ll1 = m.createTypedLiteral(""abc"", RDFLangString.rdfLangString) ;
		 assertEquals("""", ll1.getLanguage()) ;
		 Literal ll2 = m.createLiteral(""xyz"", ""en"") ;
		 if ( JenaRuntime.isRDF11 ) assertTrue(ll1.getDatatype() == ll2.getDatatype()) ;
		 else assertTrue(ll1.getDatatype() != ll2.getDatatype()) ;
	 }
	 public void testXSDbasics() {
		 String xsdIntURI = ""http: Literal l1 = m.createTypedLiteral(42);
		 Literal l2 = m.createTypedLiteral(""42"", XSDDatatype.XSDint);
		 Literal l4 = m.createTypedLiteral(""63"");
		 assertSameValueAs(""Default map failed"", l1, l2);
		 assertEquals(""Value wrong"", l1.getValue(), Integer.valueOf(42));
		 assertEquals(""class wrong"", l1.getValue().getClass(), Integer.class);
		 assertEquals(""Value accessor problem"", l1.getInt(), 42);
		 assertEquals(""wrong type name"", l2.getDatatypeURI(), xsdIntURI);
		 assertEquals(""wrong type"", l2.getDatatype(), XSDDatatype.XSDint);
		 assertDiffer(""Not value sensitive"", l1, l4);
		 checkIllegalLiteral(""zap"", XSDDatatype.XSDint);
		 checkIllegalLiteral(""42.1"", XSDDatatype.XSDint);
		 Literal l5 = m.createTypedLiteral(""42"", XSDDatatype.XSDnonNegativeInteger);
		 assertSameValueAs(""type coercion"", l2, l5);
		 l1 = m.createTypedLiteral(42.42);
		 l2 = m.createTypedLiteral(""42.42"", XSDDatatype.XSDfloat);
		 Literal l3 = m.createTypedLiteral(""42.42"", XSDDatatype.XSDdouble);
		 assertEquals(""class wrong"", l1.getValue().getClass(), Double.class);
		 assertFloatEquals(""value wrong"", ((Double)(l1.getValue())).floatValue(), 42.42);
		 assertEquals(""class wrong"", l2.getValue().getClass(), Float.class);
		 assertFloatEquals(""value wrong"", ((Float)(l2.getValue())).floatValue(), 42.42);
		 assertFloatEquals(""Value accessor problem"", l1.getFloat(), 42.42);
		 assertEquals(""wrong type"", l2.getDatatype(), XSDDatatype.XSDfloat);
		 assertSameValueAs(""equality fn"", l1, l3);
		 checkLegalLiteral(""12345"", XSDDatatype.XSDlong, Integer.class, 12345 );
		 checkLegalLiteral(""-12345"", XSDDatatype.XSDlong, Integer.class, -12345 );
		 checkIllegalLiteral(""2.3"", XSDDatatype.XSDlong);
		 checkLegalLiteral(""1234"", XSDDatatype.XSDshort, Integer.class, (int) (short) 1234 );
		 checkLegalLiteral(""-1234"", XSDDatatype.XSDshort, Integer.class, (int) (short) -1234 );
		 checkLegalLiteral(""32767"", XSDDatatype.XSDshort, Integer.class, (int) (short) 32767 );
		 checkLegalLiteral(""-32768"", XSDDatatype.XSDshort, Integer.class, (int) (short) -32768 );
		 checkIllegalLiteral(""32769"", XSDDatatype.XSDshort);
		 checkIllegalLiteral(""2.3"", XSDDatatype.XSDshort);
		 checkLegalLiteral(""42"", XSDDatatype.XSDbyte, Integer.class, (int) (byte) 42 );
		 checkLegalLiteral(""-42"", XSDDatatype.XSDbyte, Integer.class, (int) (byte) -42 );
		 checkLegalLiteral(""127"", XSDDatatype.XSDbyte, Integer.class, (int) (byte) 127 );
		 checkLegalLiteral(""-128"", XSDDatatype.XSDbyte, Integer.class, (int) (byte) -128 );
		 checkIllegalLiteral(""32769"", XSDDatatype.XSDbyte);
		 checkIllegalLiteral(""128"", XSDDatatype.XSDbyte);
		 checkIllegalLiteral(""2.3"", XSDDatatype.XSDbyte);
		 checkLegalLiteral(""12345"", XSDDatatype.XSDunsignedLong, Integer.class, 12345 );
		 checkLegalLiteral(""+12345"", XSDDatatype.XSDunsignedLong, Integer.class, 12345 );
		 checkLegalLiteral(""9223372036854775808"", XSDDatatype.XSDunsignedLong, BigInteger.class, new BigInteger(""9223372036854775808""));
		 checkIllegalLiteral(""-12345"", XSDDatatype.XSDunsignedLong);
		 checkLegalLiteral(""12345"", XSDDatatype.XSDunsignedInt, Integer.class, 12345 );
		 checkLegalLiteral(""2147483648"", XSDDatatype.XSDunsignedInt, Long.class, 2147483648l );
		 checkIllegalLiteral(""-12345"", XSDDatatype.XSDunsignedInt);
		 checkLegalLiteral(""1234"", XSDDatatype.XSDunsignedShort, Integer.class, 1234 );
		 checkLegalLiteral(""32679"", XSDDatatype.XSDunsignedShort, Integer.class, 32679 );
		 checkIllegalLiteral(""-12345"", XSDDatatype.XSDunsignedShort);
		 checkLegalLiteral(""123"", XSDDatatype.XSDunsignedByte, Integer.class, (int) (short) 123 );
		 checkLegalLiteral(""129"", XSDDatatype.XSDunsignedByte, Integer.class, (int) (short) 129 );
		 checkIllegalLiteral(""-123"", XSDDatatype.XSDunsignedByte);
		 checkLegalLiteral(""12345"", XSDDatatype.XSDinteger, Integer.class, 12345 );
		 checkLegalLiteral(""0"", XSDDatatype.XSDinteger, Integer.class, 0 );
		 checkLegalLiteral(""-12345"", XSDDatatype.XSDinteger, Integer.class, -12345 );
		 checkLegalLiteral(""9223372036854775808"", XSDDatatype.XSDinteger, BigInteger.class, new BigInteger(""9223372036854775808""));
		 checkLegalLiteral(""12345"", XSDDatatype.XSDpositiveInteger, Integer.class, 12345 );
		 checkIllegalLiteral(""0"", XSDDatatype.XSDpositiveInteger);
		 checkIllegalLiteral(""-12345"", XSDDatatype.XSDpositiveInteger);
		 checkLegalLiteral(""9223372036854775808"", XSDDatatype.XSDpositiveInteger, BigInteger.class, new BigInteger(""9223372036854775808""));
		 checkLegalLiteral(""12345"", XSDDatatype.XSDnonNegativeInteger, Integer.class, 12345 );
		 checkLegalLiteral(""0"", XSDDatatype.XSDnonNegativeInteger, Integer.class, 0 );
		 checkIllegalLiteral(""-12345"", XSDDatatype.XSDnonNegativeInteger);
		 checkLegalLiteral(""9223372036854775808"", XSDDatatype.XSDnonNegativeInteger, BigInteger.class, new BigInteger(""9223372036854775808""));
		 checkLegalLiteral(""-12345"", XSDDatatype.XSDnegativeInteger, Integer.class, -12345 );
		 checkIllegalLiteral(""0"", XSDDatatype.XSDnegativeInteger);
		 checkIllegalLiteral(""12345"", XSDDatatype.XSDnegativeInteger);
		 checkLegalLiteral(""-9223372036854775808"", XSDDatatype.XSDnegativeInteger, BigInteger.class, new BigInteger(""-9223372036854775808""));
		 checkLegalLiteral(""-12345"", XSDDatatype.XSDnonPositiveInteger, Integer.class, -12345 );
		 checkLegalLiteral(""0"", XSDDatatype.XSDnonPositiveInteger, Integer.class, 0 );
		 checkIllegalLiteral(""12345"", XSDDatatype.XSDnonPositiveInteger);
		 checkLegalLiteral(""-9223372036854775808"", XSDDatatype.XSDnonPositiveInteger, BigInteger.class, new BigInteger(""-9223372036854775808""));
		 checkLegalLiteral(""12345"", XSDDatatype.XSDdecimal, Integer.class, Integer.valueOf(""12345""));
		 checkLegalLiteral(""0.0"", XSDDatatype.XSDdecimal, Integer.class, Integer.valueOf(""0""));
		 checkLegalLiteral(""42.45"", XSDDatatype.XSDdecimal, BigDecimal.class, new BigDecimal(""42.45""));
		 checkLegalLiteral(""9223372036854775808.1234"", XSDDatatype.XSDdecimal, BigDecimal.class, new BigDecimal(""9223372036854775808.1234""));
		 checkLegalLiteral(""123.4"", XSDDatatype.XSDdecimal, BigDecimal.class, new BigDecimal(""123.4""));
		 checkIllegalLiteral(""123,4"", XSDDatatype.XSDdecimal);
		 checkLegalLiteral(""true"", XSDDatatype.XSDboolean, Boolean.class, true );
		 checkLegalLiteral(""false"", XSDDatatype.XSDboolean, Boolean.class, false );
		 l1 = m.createTypedLiteral(true);
		 assertEquals(""boolean mapping"", XSDDatatype.XSDboolean, l1.getDatatype());
		 checkLegalLiteral(""hello world"", XSDDatatype.XSDstring, String.class, ""hello world"");
		 l1 = m.createTypedLiteral(""foo bar"");
		 assertEquals(""string mapping"", XSDDatatype.XSDstring, l1.getDatatype());
	 }
	 public void testMiscEquality() {
		 Literal l1 = m.createTypedLiteral(""10"", ""http: Literal l3 = m.createTypedLiteral(""010"", ""http: assertSameValueAs(""Int lex form"", l1, l3);
		 l1 = m.createTypedLiteral(""1"", XSDDatatype.XSDint);
		 l3 = m.createTypedLiteral(""1"", XSDDatatype.XSDnonNegativeInteger);
		 assertSameValueAs(""numeric comparisons"", l1, l3);
	 }
	 public void testOverloads() {
		 boolean old = JenaParameters.enableEagerLiteralValidation;
		 try {
			 JenaParameters.enableEagerLiteralValidation = true;
			 boolean test1 = false;
			 try {
			 m.createTypedLiteral(""foo"", ""http: }
			 catch (DatatypeFormatException e1 ) {
				 test1 = true;
			 }
			 assertTrue(""detected illegal string, direct"", test1);
			 boolean test2 = false;
			 try {
				 Object foo = ""foo"";
			 m.createTypedLiteral(foo, ""http: }
			 catch (DatatypeFormatException e2 ) {
				 test2 = true;
			 }
			 assertTrue(""detected illegal string, overloaded"", test2);
			 Calendar testCal = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
			 testCal.set(1999, 4, 30, 15, 9, 32);
			 testCal.set(Calendar.MILLISECOND, 0);
			 Literal lc = m.createTypedLiteral((Object)testCal);
			 assertEquals(""calendar overloading test"", m.createTypedLiteral(""1999-05-30T15:09:32Z"", XSDDatatype.XSDdateTime), lc );
		 }
		 finally {
			 JenaParameters.enableEagerLiteralValidation = old;
		 }
	 }
	 public void testPlainSameValueAs() {
		 Literal lString = m.createTypedLiteral(""10"", XSDDatatype.XSDstring );
		 Literal lPlain = m.createTypedLiteral(""10"", (RDFDatatype)null );
		 Literal lPlain3 = m.createTypedLiteral(""10"", (String)null );
		 Literal lPlain2 = m.createLiteral(""10"");
		 Literal lInt = m.createTypedLiteral(""10"", XSDDatatype.XSDint );
		 assertSameValueAs(""Null type = plain literal"", lPlain, lPlain2);
		 assertSameValueAs(""Null type = plain literal"", lPlain, lPlain3);
		 assertSameValueAs(""Null type = plain literal"", lPlain2, lPlain3);
		 assertTrue(""null type"", lPlain3.getDatatype() == null);
		 assertDiffer(""String != int"", lString, lInt);
		 assertDiffer(""Plain != int"", lPlain, lInt);
		 assertDiffer(""Plain != int"", lPlain2, lInt);
		 if (JenaParameters.enablePlainLiteralSameAsString) {
			 assertSameValueAs(""String != plain??"", lString, lPlain);
			 assertSameValueAs(""String != plain??"", lString, lPlain2);
		 }
		 else {
			 assertDiffer(""String != plain??"", lString, lPlain);
			 assertDiffer(""String != plain??"", lString, lPlain2);
		 }
	 }
	 public void testNumberSameValueAs() {
		 Literal lDouble = m.createTypedLiteral(""5"", XSDDatatype.XSDdouble);
		 Literal lDouble2 = m.createTypedLiteral(""5.5"", XSDDatatype.XSDdouble);
		 Literal lDouble3 = m.createTypedLiteral(""5.5"", XSDDatatype.XSDdouble);
		 Literal lDouble4 = m.createTypedLiteral(""5.6"", XSDDatatype.XSDdouble);
		 Literal lFloat = m.createTypedLiteral(""5"", XSDDatatype.XSDfloat);
		 Literal lint = m.createTypedLiteral(""5"", XSDDatatype.XSDint);
		 Literal linteger = m.createTypedLiteral(""5"", XSDDatatype.XSDinteger);
		 Literal lbyte = m.createTypedLiteral(""5"", XSDDatatype.XSDbyte);
		 assertSameValueAs(""integer subclasses equal"", lint, linteger);
		 assertSameValueAs(""integer subclasses equal"", lint, lbyte);
		 assertSameValueAs(""integer subclasses equal"", linteger, lbyte);
		 assertSameValueAs(""double equality"", lDouble2, lDouble3);
		 assertDiffer(""float/double/int distinct"", lDouble, lDouble2);
		 assertDiffer(""float/double/int distinct"", lDouble, lFloat);
		 assertDiffer(""float/double/int distinct"", lDouble, lint);
		 assertDiffer(""float/double/int distinct"", lDouble, linteger);
		 assertDiffer(""float/double/int distinct"", lDouble2, lint);
		 assertDiffer(""float/double/int distinct"", lDouble2, lbyte);
		 assertDiffer(""float/double/int distinct"", lint, lDouble);
		 assertDiffer(""float/double/int distinct"", lbyte, lDouble);
		 assertDiffer(""float/double/int distinct"", lint, lDouble2);
		 assertDiffer(""float/double/int distinct"", lbyte, lDouble2);
		 assertDiffer(""double inequality"", lDouble3, lDouble4);
		 assertDiffer(""double inequality"", lDouble2, lDouble);
		 Literal lDecimal = m.createTypedLiteral(""5.5"", XSDDatatype.XSDdecimal);
		 Literal lDecimal2 = m.createTypedLiteral(""5.6"", XSDDatatype.XSDdecimal);
		 assertDiffer(""decimal inequality"", lDecimal, lDecimal2);
	 }
	 public void testBigNums() {
		 Literal l1 = m.createTypedLiteral(""12345678901234567890"", XSDDatatype.XSDinteger);
		 Literal l2 = m.createTypedLiteral(""12345678901234567891"", XSDDatatype.XSDinteger);
		 assertDiffer(""Big integer equality"", l1, l2);
		 BigInteger bigint1 = new BigInteger(""12345678901234567890"");
		 Literal lb1 = m.createTypedLiteral(bigint1, XSDDatatype.XSDinteger);
		 assertSameValueAs(""big integer creation equality"", l1, lb1);
		 BigDecimal bigdec1 = new BigDecimal(""12345678901234567890.00"");
		 Literal ld1 = m.createTypedLiteral(bigdec1, XSDDatatype.XSDdecimal);
		 BigDecimal bigdec1b = new BigDecimal(""12345678901234567890.0"");
		 Literal ld1b = m.createTypedLiteral(bigdec1b, XSDDatatype.XSDdecimal);
		 BigDecimal bigdec2 = new BigDecimal(""12345678901234567890.1"");
		 Literal ld2 = m.createTypedLiteral(bigdec2, XSDDatatype.XSDdecimal);
		 assertSameValueAs(""big decimal equality check"", ld1, ld1b);
		 assertSameValueAs(""big decimal equality check"", ld1, lb1);
		 assertDiffer(""Decimal equality"", ld1, ld2);
		 BigDecimal bigdecF = new BigDecimal(""12345678901234567890.1"");
		 Literal ldF = m.createTypedLiteral(bigdecF, XSDDatatype.XSDdecimal);
		 BigDecimal bigdecFb = new BigDecimal(""12345678901234567890.10"");
		 Literal ldFb = m.createTypedLiteral(bigdecFb, XSDDatatype.XSDdecimal);
		 BigDecimal bigdecF2 = new BigDecimal(""12345678901234567890.2"");
		 Literal ldF2 = m.createTypedLiteral(bigdecF2, XSDDatatype.XSDdecimal);
		 assertSameValueAs(""big decimal equality check"", ldF, ldFb);
		 assertDiffer(""Decimal equality"", ldF, ldF2);
	 }
	 public void testDecimalFind() {
		 RDFDatatype dt = XSDDatatype.XSDdecimal;
		 Node ns = NodeFactory.createURI(""x"") ;
		 Node np = NodeFactory.createURI(""p"") ;
		 Node nx1 = NodeFactory.createLiteral(""0.50"", dt) ;
		 Node nx2 = NodeFactory.createLiteral(""0.500"", dt) ;
		 Graph graph = GraphMemFactory.createDefaultGraph() ;
		 graph.add(Triple.create(ns, np, nx1)) ;
		 assertTrue( graph.find(Node.ANY, Node.ANY, nx2).hasNext() );
	 }
	 public void testDecimalCanonicalize() {
		 doTestDecimalCanonicalize(""0.500"", ""0.5"", BigDecimal.class);
		 doTestDecimalCanonicalize(""0.50"", ""0.5"", BigDecimal.class);
		 doTestDecimalCanonicalize(""0.5"", ""0.5"", BigDecimal.class);
		 doTestDecimalCanonicalize(""0.0"", ""0"", Integer.class);
		 doTestDecimalCanonicalize(""5.0"", ""5"", Integer.class);
		 doTestDecimalCanonicalize(""500.0"", ""500"", Integer.class);
		 doTestDecimalCanonicalize(""5.00100"", ""5.001"", BigDecimal.class);
	 }
	 private void doTestDecimalCanonicalize(String value, String expected, Class<?> expectedClass) {
		 Object normalized = XSDDatatype.XSDdecimal.cannonicalise( new BigDecimal(value) );
		 assertEquals(expected, normalized.toString());
		 assertEquals(expectedClass, normalized.getClass());
	 }
	 public void testDateTime_1() {
		 Literal l1 = m.createTypedLiteral(""P1Y2M3DT5H6M7.50S"", XSDDatatype.XSDduration);
		 assertEquals(""duration data type"", XSDDatatype.XSDduration, l1.getDatatype());
		 assertEquals(""duration java type"", XSDDuration.class, l1.getValue().getClass());
		 assertEquals(""duration value"", 1, ((XSDDuration)l1.getValue()).getYears());
		 assertEquals(""duration value"", 2, ((XSDDuration)l1.getValue()).getMonths());
		 assertEquals(""duration value"", 3, ((XSDDuration)l1.getValue()).getDays());
		 assertEquals(""duration value"", 5, ((XSDDuration)l1.getValue()).getHours());
		 assertEquals(""duration value"", 6, ((XSDDuration)l1.getValue()).getMinutes());
		 assertEquals(""duration value"", 7, ((XSDDuration)l1.getValue()).getFullSeconds());
		 assertEquals(""duration value"", BigDecimal.valueOf(75,1), ((XSDDuration)l1.getValue()).getBigSeconds());
		 assertFloatEquals(""duration value"", 18367.5, ((XSDDuration)l1.getValue()).getTimePart());
		 assertEquals(""serialization"", ""P1Y2M3DT5H6M7.5S"", l1.getValue().toString());
		 assertTrue(""equality test"", l1.sameValueAs( m.createTypedLiteral(""P1Y2M3DT5H6M7.5S"", XSDDatatype.XSDduration) ) );
		 assertTrue(""inequality test"", l1 != m.createTypedLiteral(""P1Y2M2DT5H6M7.5S"", XSDDatatype.XSDduration));
	 }
	 public void testDateTime_2() {
		 Literal l1 = m.createTypedLiteral(""P1Y2M3DT5H0M"", XSDDatatype.XSDduration);
		 assertEquals(""serialization"", ""P1Y2M3DT5H"", l1.getValue().toString());
	 }
	 public void testDateTime_3() {
		 Literal l1 = m.createTypedLiteral(""P1Y"", XSDDatatype.XSDduration);
		 assertEquals(""duration data type"", XSDDatatype.XSDduration, l1.getDatatype());
		 assertEquals(""duration java type"", XSDDuration.class, l1.getValue().getClass());
		 assertEquals(""duration value"", 1, ((XSDDuration)l1.getValue()).getYears());
		 assertEquals(""serialization"", ""P1Y"", l1.getValue().toString());
		 assertTrue(""equality test"", l1.sameValueAs( m.createTypedLiteral(""P1Y"", XSDDatatype.XSDduration) ) );
		 assertTrue(""inequality test"", l1 != m.createTypedLiteral(""P1Y"", XSDDatatype.XSDduration));
	 }
	 public void testDateTime_4() {
		 Literal l1 = m.createTypedLiteral(""-P120D"", XSDDatatype.XSDduration);
		 Literal l2 = m.createTypedLiteral( l1.getValue() );
		 assertEquals(""-P120D"", l2.getLexicalForm() );
	 }
	 public void testDateTime_5() {
		 Literal d1 = m.createTypedLiteral(""PT1H1M1S"", XSDDatatype.XSDduration);
		 Literal d2 = m.createTypedLiteral(""PT1H1M1.1S"", XSDDatatype.XSDduration);
		 assertTrue(""duration compare"", !d1.sameValueAs(d2));
		 XSDDuration dur1 = (XSDDuration)d1.getValue() ;
		 XSDDuration dur2 = (XSDDuration)d2.getValue() ;
		 assertEquals(""duration compare order"", 1, dur2.compare(dur1)) ;
	 }
	 public void testDateTime_6() {
		 Literal l1 = m.createTypedLiteral(""1999-05-31T02:09:32Z"", XSDDatatype.XSDdateTime);
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime data type"", XSDDatatype.XSDdateTime, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 assertEquals(""dateTime value"", 1999, xdt.getYears());
		 assertEquals(""dateTime value"", 5, xdt.getMonths());
		 assertEquals(""dateTime value"", 31, xdt.getDays());
		 assertEquals(""dateTime value"", 2, xdt.getHours());
		 assertEquals(""dateTime value"", 9, xdt.getMinutes());
		 assertEquals(""dateTime value"", 32, xdt.getFullSeconds());
		 assertEquals(""serialization"", ""1999-05-31T02:09:32Z"", l1.getValue().toString());
		 Calendar cal = xdt.asCalendar();
		 Calendar testCal = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
		 testCal.set(1999, 4, 31, 2, 9, 32);
		 testCal.set(Calendar.MILLISECOND, 0);
		 assertEquals(""calendar value"", cal, testCal);
		 assertEquals(""equality test"", l1, m.createTypedLiteral(""1999-05-31T02:09:32Z"", XSDDatatype.XSDdateTime));
		 assertTrue(""inequality test"", l1 != m.createTypedLiteral(""1999-04-31T02:09:32Z"", XSDDatatype.XSDdateTime));
		 Calendar testCal2 = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
		 testCal2.set(1999, 4, 30, 15, 9, 32);
		 testCal2.set(Calendar.MILLISECOND, 0);
		 Literal lc = m.createTypedLiteral(testCal2);
		 assertEquals(""calendar 24 hour test"", m.createTypedLiteral(""1999-05-30T15:09:32Z"", XSDDatatype.XSDdateTime), lc );
		 assertEquals(""calendar value"", cal, testCal);
		 assertEquals(""equality test"", l1, m.createTypedLiteral(""1999-05-31T02:09:32Z"", XSDDatatype.XSDdateTime));
	 }
	 public void testDateTime_7() {
		 Calendar testCal3 = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
		 testCal3.clear();
		 testCal3.set(1999, Calendar.JANUARY, 30, 15, 9, 32);
		 Literal lc = m.createTypedLiteral(testCal3);
		 assertEquals(""1999-01-30T15:09:32Z"", lc.getLexicalForm());
		 String urib=""rdf: String uri1=urib+""1"";
		 String urip=urib+""prop"";
		 String testN3 = ""<""+uri1+""> <""+urip+""> \""""+lc.getLexicalForm()+""\""^^<""+lc.getDatatypeURI()+""> ."";
		 java.io.StringReader sr = new java.io.StringReader(testN3);
		 m.read(sr, urib, ""N-TRIPLES"");
		 assertTrue(m.contains(m.getResource(uri1),m.getProperty(urip)));
		 Resource r1 = m.getResource(uri1);
		 Property p = m.getProperty(urip);
		 XSDDateTime returnedDateTime = (XSDDateTime) r1.getProperty(p).getLiteral().getValue();
		 assertEquals(""deserialized calendar value"", testCal3, returnedDateTime.asCalendar());
	 }
	 public void testDateTime_8() {
		 Calendar testCal4 = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
		 testCal4.set(1999, 4, 30, 15, 9, 32);
		 testCal4.set(Calendar.MILLISECOND, 25);
		 doDateTimeTest(testCal4, ""1999-05-30T15:09:32.025Z"", 32.025);
		 testCal4.set(Calendar.MILLISECOND, 250);
		 doDateTimeTest(testCal4, ""1999-05-30T15:09:32.25Z"", 32.25);
		 testCal4.set(Calendar.MILLISECOND, 2);
		 doDateTimeTest(testCal4, ""1999-05-30T15:09:32.002Z"", 32.002);
	 }
	 private void doDateTimeTest(Calendar cal, String lex, double time) {
		 Literal lc4 = m.createTypedLiteral(cal);
		 assertEquals(""serialization"", lex, lc4.getValue().toString());
		 assertEquals(""calendar ms test"", m.createTypedLiteral(lex, XSDDatatype.XSDdateTime), lc4 );
		 XSDDateTime dt4 = (XSDDateTime)lc4.getValue();
		 assertTrue(""Fraction time check"", Math.abs(dt4.getSeconds() - time) < 0.0001);
		 assertEquals(dt4.asCalendar(), cal);
	 }
	 public void testDateTime_9() {
		 int[] years = {
		 0, 7, 77, 777 , 7777 }
		 ;
		 for ( int y : years ) {
			 Calendar calM1 = Calendar.getInstance();
			 calM1.set(Calendar.YEAR, y);
			 calM1.set(Calendar.MONTH, 10);
			 calM1.set(Calendar.DATE, 23);
			 XSDDateTime xdtM = new XSDDateTime(calM1);
			 LiteralLabel xdtM_ll = LiteralLabelFactory.createByValue(xdtM, """", XSDDatatype.XSDdateTime);
			 assertTrue(""Pre-1000 calendar value"", xdtM_ll.isWellFormed()) ;
			 assertTrue(""Pre-1000 calendar value"", xdtM_ll.getLexicalForm().matches(""^[0-9]{
			4}
			-.*"")) ;
		 }
		 boolean ok = false;
		 boolean old = JenaParameters.enableEagerLiteralValidation;
		 try {
			 JenaParameters.enableEagerLiteralValidation = true;
			 Literal l1 = m.createTypedLiteral(new Date(12345656l), XSDDatatype.XSDdateTime);
		 }
		 catch (DatatypeFormatException e) {
			 ok = true;
		 }
		 finally {
			 JenaParameters.enableEagerLiteralValidation = old;
		 }
		 assertTrue(""Early detection of invalid literals"", ok);
	 }
	 public void testDateTime_10() {
		 Literal l1 = m.createTypedLiteral(""1999-05-31"", XSDDatatype.XSDdate);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDdate, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 1999, xdt.getYears());
		 assertEquals(""dateTime value"", 5, xdt.getMonths());
		 assertEquals(""dateTime value"", 31, xdt.getDays());
		 try {
			 xdt.getHours();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_11() {
		 Literal l1 = m.createTypedLiteral(""12:56:32"", XSDDatatype.XSDtime);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDtime, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 12, xdt.getHours());
		 assertEquals(""dateTime value"", 56, xdt.getMinutes());
		 assertEquals(""dateTime value"", 32, xdt.getFullSeconds());
		 try {
			 xdt.getDays();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_12() {
		 Literal l1 = m.createTypedLiteral(""1999-05"", XSDDatatype.XSDgYearMonth);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDgYearMonth, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 1999, xdt.getYears());
		 assertEquals(""dateTime value"", 5, xdt.getMonths());
		 try {
			 xdt.getDays();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_13() {
		 Literal l1 = m.createTypedLiteral(""1999"", XSDDatatype.XSDgYear);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDgYear, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 1999, xdt.getYears());
		 try {
			 xdt.getMonths();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_14() {
		 Literal l1 = m.createTypedLiteral(""--05--"", XSDDatatype.XSDgMonth);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDgMonth, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 5, xdt.getMonths());
		 try {
			 xdt.getYears();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_15() {
		 Literal l1 = m.createTypedLiteral(""--05-25"", XSDDatatype.XSDgMonthDay);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDgMonthDay, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 5, xdt.getMonths());
		 assertEquals(""dateTime value"", 25, xdt.getDays());
		 try {
			 xdt.getYears();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_16() {
		 Literal l1 = m.createTypedLiteral(""---25"", XSDDatatype.XSDgDay);
		 assertEquals(""dateTime data type"", XSDDatatype.XSDgDay, l1.getDatatype());
		 assertEquals(""dateTime java type"", XSDDateTime.class, l1.getValue().getClass());
		 XSDDateTime xdt = (XSDDateTime)l1.getValue();
		 assertEquals(""dateTime value"", 25, xdt.getDays());
		 try {
			 xdt.getMonths();
			 assertTrue(""Failed to prevent illegal access"", false);
		 }
		 catch (IllegalDateTimeFieldException e) {
		}
	 }
	 public void testDateTime_17() {
		 Calendar ncal = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
		 ncal.set(2003, 11, 8, 10, 50, 42);
		 ncal.set(Calendar.MILLISECOND, 0);
		 Literal l1 = m.createTypedLiteral(ncal);
		 assertEquals(""DateTime from date"", XSDDatatype.XSDdateTime, l1.getDatatype());
		 assertEquals(""DateTime from date"", XSDDateTime.class, l1.getValue().getClass());
		 assertEquals(""DateTime from date"", ""2003-12-08T10:50:42Z"", l1.getValue().toString());
	 }
	 public void testDateTime_18() {
		 SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ""America/Los_Angeles"");
		 pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
		 pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
		 Calendar ncal = new GregorianCalendar(pdt);
		 ncal.set(2004, 02, 21, 12, 50, 42);
		 ncal.set(Calendar.MILLISECOND, 0);
		 Literal l1 = m.createTypedLiteral(ncal);
		 assertEquals(""DateTime from date"", XSDDatatype.XSDdateTime, l1.getDatatype());
		 assertEquals(""DateTime from date"", XSDDateTime.class, l1.getValue().getClass());
		 assertEquals(""DateTime from date"", ""2004-03-21T20:50:42Z"", l1.getValue().toString());
		 ncal = new GregorianCalendar(pdt);
		 ncal.set(2004, 03, 21, 12, 50, 42);
		 ncal.set(Calendar.MILLISECOND, 0);
		 l1 = m.createTypedLiteral(ncal);
		 assertEquals(""DateTime from date"", XSDDatatype.XSDdateTime, l1.getDatatype());
		 assertEquals(""DateTime from date"", XSDDateTime.class, l1.getValue().getClass());
		 assertEquals(""DateTime from date"", ""2004-04-21T19:50:42Z"", l1.getValue().toString());
	 }
	 public void testTypedContains() {
		 Model model = ModelFactory.createDefaultModel();
		 Property p = model.createProperty(""urn:x-eg/p"");
		 Literal l1 = model.createTypedLiteral(""10"", ""http: Literal l2 = model.createTypedLiteral(""010"", ""http: assertSameValueAs( ""sameas test"", l1, l2 );
		 Resource a = model.createResource(""urn:x-eg/a"");
		 a.addProperty( p, l1 );
		 assertTrue( model.getGraph().contains( a.asNode(), p.asNode(), l1.asNode() ) );
		 assertTrue( model.getGraph().contains( a.asNode(), p.asNode(), l2.asNode() ) );
	 }
	 public void testIsValidLiteral() {
		 Literal l = m.createTypedLiteral(""1000"", XSDDatatype.XSDinteger);
		 LiteralLabel ll = l.asNode().getLiteral();
		 assertTrue(XSDDatatype.XSDlong.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDint.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDshort.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDunsignedInt.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDunsignedLong.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDunsignedShort.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDpositiveInteger.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDdecimal.isValidLiteral(ll));
		 assertTrue( ! XSDDatatype.XSDstring.isValidLiteral(ll));
		 assertTrue( ! XSDDatatype.XSDbyte.isValidLiteral(ll));
		 assertTrue( ! XSDDatatype.XSDnegativeInteger.isValidLiteral(ll));
		 l = m.createTypedLiteral(""-2"", XSDDatatype.XSDinteger);
		 ll = l.asNode().getLiteral();
		 assertTrue(XSDDatatype.XSDlong.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDint.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDshort.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDunsignedInt.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDunsignedLong.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDunsignedShort.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDdecimal.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDpositiveInteger.isValidLiteral(ll));
		 assertTrue( ! XSDDatatype.XSDstring.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDbyte.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDnegativeInteger.isValidLiteral(ll));
		 l = m.createTypedLiteral(""4.5"", XSDDatatype.XSDfloat);
		 ll = l.asNode().getLiteral();
		 assertTrue(! XSDDatatype.XSDdouble.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDdecimal.isValidLiteral(ll));
		 Literal l2 = m.createTypedLiteral(""foo"", XSDDatatype.XSDstring);
		 assertTrue(XSDDatatype.XSDstring.isValidLiteral(l2.asNode().getLiteral()));
		 assertTrue(XSDDatatype.XSDnormalizedString.isValidLiteral(l2.asNode().getLiteral()));
		 assertTrue( ! XSDDatatype.XSDint.isValidLiteral(l2.asNode().getLiteral()));
		 l = m.createTypedLiteral(""foo bar"");
		 ll = l.asNode().getLiteral();
		 assertTrue(XSDDatatype.XSDstring.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDint.isValidLiteral(ll));
		 l = m.createTypedLiteral(""12"");
		 ll = l.asNode().getLiteral();
		 assertTrue(XSDDatatype.XSDstring.isValidLiteral(ll));
		 assertTrue(! XSDDatatype.XSDint.isValidLiteral(ll));
		 assertTrue(XSDDatatype.XSDnonNegativeInteger.isValidValue(Integer.valueOf(10)));
		 assertTrue(XSDDatatype.XSDnonNegativeInteger.isValidValue(Integer.valueOf(10)));
		 assertTrue(!XSDDatatype.XSDnonNegativeInteger.isValidValue(Integer.valueOf(-10)));
		 assertTrue(!XSDDatatype.XSDnonNegativeInteger.isValidValue(""10""));
		 assertTrue(XSDDatatype.XSDfloat.isValidValue(Float.valueOf(""2.3"")));
		 assertTrue(XSDDatatype.XSDdouble.isValidValue(Double.valueOf(""2.3"")));
		 assertTrue( ! XSDDatatype.XSDfloat.isValidValue(Integer.valueOf(""2"")));
		 assertTrue( ! XSDDatatype.XSDfloat.isValidValue(Double.valueOf(""2.3"")));
	 }
	 public void testIsValidLiteral1() {
		 Literal lit = m.createTypedLiteral(""100"", XSDDatatype.XSD+""#anyType"") ;
		 assertFalse(XSDDatatype.XSDinteger.isValidLiteral(lit.asNode().getLiteral()));
	 }
	 public void testIsValidLiteral2() {
		 Literal lit = m.createTypedLiteral(""100"", XSDDatatype.XSD+""#anySimpleType"") ;
		 assertFalse(XSDDatatype.XSDinteger.isValidLiteral(lit.asNode().getLiteral()));
	 }
	 private static byte[] data = new byte[]{
	12, 42, 99}
	;
	 public void testBinary1() {
		 byte[] data = new byte[]{
		12, 42, 99}
		;
		 Literal l = m.createTypedLiteral(data);
		 LiteralLabel ll = l.asNode().getLiteral();
		 assertTrue(""binary test 1"", ll.getDatatype() instanceof XSDbinary);
		 assertTrue(""binary test 1a"", ll.getDatatype() instanceof XSDbase64Binary) ;
		 assertEquals(""binary test 1b"", ""DCpj"", ll.getLexicalForm());
	 }
	 public void testBinary2() {
		 LiteralLabel l2 = m.createTypedLiteral(""DCpj"", XSDDatatype.XSDbase64Binary).asNode().getLiteral();
		 Object data2 = l2.getValue();
		 assertTrue(""binary test 3"", data2 instanceof byte[]);
		 byte[] data2b = (byte[])data2;
		 assertEquals(""binary test 4"", data2b[0], data[0]);
		 assertEquals(""binary test 5"", data2b[1], data[1]);
		 assertEquals(""binary test 6"", data2b[2], data[2]);
	 }
	 public void testBinary3() {
		 Literal l = m.createTypedLiteral(data, XSDDatatype.XSDhexBinary);
		 LiteralLabel ll = l.asNode().getLiteral();
		 assertEquals(""binary test 1b"", ll.getDatatype(), XSDDatatype.XSDhexBinary);
		 assertEquals(""binary test 2b"", Hex.encodeHexString(data, false), ll.getLexicalForm());
		 LiteralLabel l2 = m.createTypedLiteral(ll.getLexicalForm(), XSDDatatype.XSDhexBinary).asNode().getLiteral();
		 Object data2 = l2.getValue();
		 assertTrue(""binary test 3b"", data2 instanceof byte[]);
		 byte[] data2b = ((byte[])data2);
		 assertEquals(""binary test 4b"", data2b[0], data[0]);
		 assertEquals(""binary test 5b"", data2b[1], data[1]);
		 assertEquals(""binary test 6b"", data2b[2], data[2]);
		 assertEquals(l2, ll);
	 }
	 public void testBinary4() {
		 Literal la = m.createTypedLiteral(""GpM7"", XSDDatatype.XSDbase64Binary);
		 Literal lb = m.createTypedLiteral(""GpM7"", XSDDatatype.XSDbase64Binary);
		 assertTrue(""equality test"", la.sameValueAs(lb));
		 data = new byte[] {
		15, (byte)0xB7}
		;
		 Literal l = m.createTypedLiteral(data, XSDDatatype.XSDhexBinary);
		 assertEquals(""hexBinary encoding"", ""0FB7"", l.getLexicalForm());
	 }
	 public void testBinaryIndexing1() {
		 Literal x1 = m.createTypedLiteral("""", XSDDatatype.XSDbase64Binary);
		 Literal x2 = m.createTypedLiteral("""", XSDDatatype.XSDbase64Binary);
		 assertEquals(""base64Binary indexing hashCode"", x1.asNode().getIndexingValue().hashCode(), x2.asNode().getIndexingValue().hashCode());
		 assertEquals(""base64Binary indexing"", x1.asNode().getIndexingValue(), x2.asNode().getIndexingValue());
	 }
	 public void testBinaryIndexing2() {
		 Literal x1 = m.createTypedLiteral(""GpM7"", XSDDatatype.XSDbase64Binary);
		 Literal x2 = m.createTypedLiteral(""GpM7"", XSDDatatype.XSDbase64Binary);
		 assertEquals(""base64Binary indexing hashCode"", x1.asNode().getIndexingValue().hashCode(), x2.asNode().getIndexingValue().hashCode());
		 assertEquals(""base64Binary indexing"", x1.asNode().getIndexingValue(), x2.asNode().getIndexingValue());
	 }
	 public void testBinaryIndexing3() {
		 Literal x1 = m.createTypedLiteral("""", XSDDatatype.XSDhexBinary);
		 Literal x2 = m.createTypedLiteral("""", XSDDatatype.XSDhexBinary);
		 assertEquals(""hexBinary indexing hashCode"", x1.asNode().getIndexingValue().hashCode(), x2.asNode().getIndexingValue().hashCode());
		 assertEquals(""hexBinary indexing"", x1.asNode().getIndexingValue(), x2.asNode().getIndexingValue());
	 }
	 public void testBinaryIndexing4() {
		 Literal x1 = m.createTypedLiteral(""AABB"", XSDDatatype.XSDhexBinary);
		 Literal x2 = m.createTypedLiteral(""AABB"", XSDDatatype.XSDhexBinary);
		 assertEquals(""hexBinary indexing hashCode"", x1.asNode().getIndexingValue().hashCode(), x2.asNode().getIndexingValue().hashCode());
		 assertEquals(""hexBinary indexing"", x1.asNode().getIndexingValue(), x2.asNode().getIndexingValue());
	 }
	 public void testXSDanyURI() {
		 Node node1 = NodeFactory.createLiteral(""http: Node node2 = NodeFactory.createLiteral(""http: assertFalse(node1.sameValueAs(node2)) ;
	 }
	 public void testDateTimeBug3() {
		 final String testLex = ""-0001-02-03T04:05:06"";
		 Node n = createLiteral(testLex, XSDDatatype.XSDdateTime);
		 assertEquals(""Got wrong XSDDateTime representation!"", testLex, n.getLiteralValue().toString());
	 }
	 public void testDateTimeBug() {
		 String XSDDateURI = XSD.date.getURI();
		 TypeMapper typeMapper=TypeMapper.getInstance();
		 RDFDatatype dt = typeMapper.getSafeTypeByName(XSDDateURI);
		 Object obj = dt.parse(""2003-05-21"");
		 Literal literal = m.createTypedLiteral(obj, dt);
		 literal.toString();
		 Object value2 = dt.parse(obj.toString());
		 assertEquals(obj, value2);
		 RDFDatatype dateType = XSDDatatype.XSDdate;
		 m.createTypedLiteral(""2003-05-21"", dateType);
		 checkSerialization(""2003-05-21"", XSDDatatype.XSDdate);
		 checkSerialization(""2003-05-21T12:56:10Z"", XSDDatatype.XSDdateTime);
		 checkSerialization(""2003-05"", XSDDatatype.XSDgYearMonth);
		 checkSerialization(""2003"", XSDDatatype.XSDgYear);
		 checkSerialization(""--05"", XSDDatatype.XSDgMonth);
		 checkSerialization(""--05-12"", XSDDatatype.XSDgMonthDay);
		 checkSerialization(""---12"", XSDDatatype.XSDgDay);
	 }
	 private static Date getDateFromPattern(String ts, String format, String timezoneid) throws Exception {
		 return getDateFromPattern(ts, new String[]{
		format}
		, TimeZone.getTimeZone(timezoneid));
	 }
	 private static Date getDateFromPattern(String ts, String[] formats, TimeZone tz) throws Exception {
		 java.util.Date date = null;
		 java.text.DateFormat sdf = java.text.DateFormat.getInstance();
		 {
			 sdf.setTimeZone(tz == null ? java.util.TimeZone.getDefault() : tz);
			 for (int i=0;
			 date == null && i<formats.length;
			i++){
				 ((java.text.SimpleDateFormat)sdf).applyPattern(formats[i]);
				 try {
					 date = sdf.parse(ts);
				 }
				 catch (java.text.ParseException pe){
				}
			 }
		 }
		 return date;
	 }
	 public void testDateTimeBug2() throws Exception {
		 String[] timezonelist = {
		 ""GMT"", ""America/New_York"", ""America/Chicago"", }
		;
		 for (String timezoneid : timezonelist) {
			 TimeZone tz = TimeZone.getTimeZone(timezoneid);
			 String[] sampletimelist = {
			 ""03/10/2012 01:29"", ""03/11/2012 00:29"", ""03/11/2012 01:29"", ""03/11/2012 02:29"", ""03/11/2012 03:29"", ""03/11/2012 04:29"", ""03/12/2012 01:29"", ""11/03/2012 23:29"", ""11/04/2012 00:29"", ""11/04/2012 01:29"", ""11/04/2012 02:29"", ""11/04/2012 03:29"", }
			;
			 String format = ""MM/dd/yyy HH:mm"";
			 for (String tstr : sampletimelist){
				 Date dt=getDateFromPattern(tstr, format, timezoneid);
				 SimpleDateFormat df = new SimpleDateFormat(""yyyy.MM.dd HH:mm:ss z"");
				 df.setTimeZone(tz);
				 Calendar cal = Calendar.getInstance();
				 cal.setTimeZone(tz);
				 cal.setTime(dt);
				 XSDDateTime xdt = new XSDDateTime(cal);
				 int offset = tz.getOffset(dt.getTime()) /( 60 * 60 * 1000);
				 int xhr = xdt.getHours();
				 int dhr = cal.get(Calendar.HOUR_OF_DAY);
				 int dif = (xhr -dhr + offset) % 24;
				 Assert.assertEquals(""Difference between cal and xdt"", 0, dif) ;
			 }
		 }
	 }
	 public void testFlags() {
		 boolean originalFlag = JenaParameters.enableEagerLiteralValidation;
		 JenaParameters.enableEagerLiteralValidation = true;
		 boolean foundException = false;
		 try {
			 m.createTypedLiteral(""fool"", XSDDatatype.XSDint);
		 }
		 catch (DatatypeFormatException e1) {
			 foundException = true;
		 }
		 JenaParameters.enableEagerLiteralValidation = originalFlag;
		 assertTrue(""Early datatype format exception"", foundException);
		 JenaParameters.enableEagerLiteralValidation = false;
		 foundException = false;
		 Literal l = null;
		 try {
			 l = m.createTypedLiteral(""fool"", XSDDatatype.XSDint);
		 }
		 catch (DatatypeFormatException e1) {
			 JenaParameters.enableEagerLiteralValidation = originalFlag;
			 assertTrue(""Delayed datatype format validation"", false);
		 }
		 try {
			 l.getValue();
		 }
		 catch (DatatypeFormatException e2) {
			 foundException = true;
		 }
		 JenaParameters.enableEagerLiteralValidation = originalFlag;
		 assertTrue(""Early datatype format exception"", foundException);
		 if ( ! JenaRuntime.isRDF11 ) {
			 originalFlag = JenaParameters.enablePlainLiteralSameAsString;
			 Literal l1 = m.createLiteral(""test string"");
			 Literal l2 = m.createTypedLiteral(""test string"", XSDDatatype.XSDstring);
			 JenaParameters.enablePlainLiteralSameAsString = true;
			 boolean ok1 = l1.sameValueAs(l2);
			 JenaParameters.enablePlainLiteralSameAsString = false;
			 boolean ok2 = ! l1.sameValueAs(l2);
			 JenaParameters.enablePlainLiteralSameAsString = originalFlag;
			 assertTrue( ok1 );
			 assertTrue( ok2 );
		 }
	 }
	 public void testLexicalDistinction() {
		 Literal l1 = m.createTypedLiteral(""3.0"", XSDDatatype.XSDdecimal);
		 Literal l2 = m.createTypedLiteral(""3.00"", XSDDatatype.XSDdecimal);
		 Literal l3 = m.createTypedLiteral(""3.0"", XSDDatatype.XSDdecimal);
		 assertSameValueAs(""lexical form does not affect value"", l1, l2);
		 assertSameValueAs(""lexical form does not affect value"", l3, l2);
		 assertTrue(""lexical form affects equality"", ! l1.equals(l2));
		 assertTrue(""lexical form affects equality"", l1.equals(l3));
		 l1 = m.createTypedLiteral(""3"", XSDDatatype.XSDint);
		 l2 = m.createTypedLiteral("" 3 "", XSDDatatype.XSDint);
		 l3 = m.createTypedLiteral(""3"", XSDDatatype.XSDint);
		 assertSameValueAs(""lexical form does not affect value"", l1, l2);
		 assertSameValueAs(""lexical form does not affect value"", l3, l2);
		 assertTrue(""lexical form affects equality"", ! l1.equals(l2));
		 assertTrue(""lexical form affects equality"", l1.equals(l3));
	 }
	 public void testRoundTrip() {
		 doTestRoundTrip(""13:20:00.000"", XSDDatatype.XSDtime, false);
		 doTestRoundTrip(""GpM7"", XSDDatatype.XSDbase64Binary, true);
		 doTestRoundTrip(""0FB7"", XSDDatatype.XSDhexBinary, true);
		 doTestValueRoundTrip(""2005-06-27"", XSDDatatype.XSDdate, true);
		 doTestValueRoundTrip(""2005"", XSDDatatype.XSDgYear, true);
		 doTestValueRoundTrip(""2005-06"", XSDDatatype.XSDgYearMonth, true);
		 doTestValueRoundTrip(""13:20:00.000"", XSDDatatype.XSDtime, true);
	 }
	 public void doTestRoundTrip(String lex, RDFDatatype dt, boolean testeq) {
		 LiteralLabel ll = LiteralLabelFactory.create( lex, dt );
		 String lex2 = dt.unparse(ll.getValue());
		 if (testeq) {
			 assertEquals(lex, lex2);
		 }
		 LiteralLabel ll2 = LiteralLabelFactory.create( lex2, dt );
		 assertTrue( ll2.isWellFormed() );
	 }
	 public void doTestValueRoundTrip(String lex, RDFDatatype dt, boolean testType) {
		 Literal l1 = m.createTypedLiteral(lex, dt);
		 Object o1 = l1.getValue();
		 Literal l2 = m.createTypedLiteral(o1);
		 assertTrue(""value round trip"", l1.sameValueAs(l2));
		 Object o2 = l2.getValue();
		 assertTrue(""value round trip2"", o1.equals(o2));
		 if (testType) {
			 assertEquals(""Datatype round trip"", dt, l2.getDatatype());
		 }
	 }
	 public void testDateOverride() {
		 Calendar date = new GregorianCalendar(2007, 3, 4);
		 date.setTimeZone( TimeZone.getTimeZone(""GMT+0"") );
		 XSDDateTime xsdDate = new XSDDateTime( date );
		 Literal l1 = m.createTypedLiteral(xsdDate, XSDDatatype.XSDdate);
		 assertEquals(XSDDatatype.XSDdate, l1.getDatatype());
		 assertEquals(""2007-04-04Z"", l1.getLexicalForm());
	 }
	 private void assertDiffer( String title, Literal x, Literal y ) {
		 assertTrue( title, !x.sameValueAs( y ) );
	 }
	 private void assertSameValueAs( String title, Literal x, Literal y ) {
		 assertTrue( title, x.sameValueAs( y ) );
	 }
	 private void assertFloatEquals(String title, double x, double y) {
		 assertTrue(title, Math.abs(x - y) < 0.001);
	 }
	 public void checkIllegalLiteral(String lex, RDFDatatype dtype) {
		 try {
			 Literal l = m.createTypedLiteral(lex, dtype);
			 l.getValue();
			 assertTrue(""Failed to catch '"" + lex + ""' as an illegal "" + dtype, false);
		 }
		 catch (DatatypeFormatException e1) {
		 }
	 }
	 public void checkLegalLiteral(String lex, RDFDatatype dtype, Class<?> jtype, Object value) {
		 Literal l = m.createTypedLiteral(lex, dtype);
		 assertEquals(l.getValue().getClass(), jtype);
		 assertEquals(l.getValue(), value);
		 assertEquals(l.getDatatype(), dtype);
	 }
	 public void checkSerialization(String lex, RDFDatatype dtype) {
		 Literal l = m.createTypedLiteral(lex, dtype);
		 assertEquals(l.getValue().toString(), lex);
	 }
	 public void assertIteratorValues( Iterator<String> it, Object[] vals ) {
		 boolean[] found = new boolean[vals.length];
		 for (int i = 0;
		 i < vals.length;
		 i++) found[i] = false;
		 while (it.hasNext()) {
			 Object n = it.next();
			 boolean gotit = false;
			 for (int i = 0;
			 i < vals.length;
			 i++) {
				 if (n.equals(vals[i])) {
					 gotit = true;
					 found[i] = true;
				 }
			 }
			 assertTrue(gotit);
		 }
		 for (int i = 0;
		 i < vals.length;
		 i++) {
			 assertTrue(found[i]);
		 }
	 }
}
class RationalType extends BaseDatatype {
	 public static final String theTypeURI = ""urn:x-hp-dt:rational"";
	 public static final RDFDatatype theRationalType = new RationalType();
	 private RationalType() {
		 super(theTypeURI);
	 }
	 public String unparse(Object value) {
		 Rational r = (Rational) value;
		 return Integer.toString(r.getNumerator()) + ""/"" + r.getDenominator();
	 }
	 public Object parse(String lexicalForm) throws DatatypeFormatException {
		 int index = lexicalForm.indexOf(""/"");
		 if (index == -1) {
			 throw new DatatypeFormatException(lexicalForm, theRationalType, """");
		 }
		 try {
			 int numerator = Integer.parseInt(lexicalForm.substring(0, index));
			 int denominator = Integer.parseInt(lexicalForm.substring(index+1));
			 return new Rational(numerator, denominator);
		 }
		 catch (NumberFormatException e) {
			 throw new DatatypeFormatException(lexicalForm, theRationalType, """");
		 }
	 }
	 public boolean isEqual(LiteralLabel value1, LiteralLabel value2) {
		 return value1.getDatatype() == value2.getDatatype() && value1.getValue().equals(value2.getValue());
	 }
}
class Rational {
	 private int numerator;
	 private int denominator;
	 Rational(int numerator, int denominator) {
		 this.numerator = numerator;
		 this.denominator = denominator;
	 }
	 public int getDenominator() {
		 return denominator;
	 }
	 public int getNumerator() {
		 return numerator;
	 }
	 public void setDenominator(int denominator) {
		 this.denominator = denominator;
	 }
	 public void setNumerator(int numerator) {
		 this.numerator = numerator;
	 }
	 public String toString() {
		 return ""rational["" + numerator + ""/"" + denominator + ""]"";
	 }
	 public boolean equals(Object o) {
		 if (o == null || !(o instanceof Rational)) return false;
		 Rational or = (Rational)o;
		 return (numerator == or.numerator && denominator == or.denominator);
	 }
}",1,0,0,0
"public static class DCSerialField extends DCBlockTag implements SerialFieldTree {
	 public final DCIdentifier name;
	 public final DCReference type;
	 public final List<DCTree> description;
	 DCSerialField(DCIdentifier name, DCReference type, List<DCTree> description) {
		 this.description = description;
		 this.name = name;
		 this.type = type;
	 }
	 public Kind getKind() {
		 return Kind.SERIAL_FIELD;
	 }
	 public <R, D> R accept(DocTreeVisitor<R, D> v, D d) {
		 return v.visitSerialField(this, d);
	 }
	 public List<? extends DocTree> getDescription() {
		 return description;
	 }
	 public IdentifierTree getName() {
		 return name;
	 }
	 public ReferenceTree getType() {
		 return type;
	 }
 }",0,1,0,0
"private static class FalseEquals implements Predicate<Boolean> {
	 private static final long serialVersionUID = 1L;
	 public boolean accept(Boolean anObject) {
		 return Boolean.FALSE.equals(anObject);
	 }
 }",0,0,0,0
"public View(ViewId vid, Vector<Address> members);",0,0,0,0
"protected void drawBottomPen(Graphics2D grx, JRPen leftPen, JRPen bottomPen, JRPen rightPen, JRPrintElement element, int offsetX, int offsetY);",0,0,0,1
"public ResIcon(ByteBuffer in) {
	Size = in.getInt();
	Width = in.getInt();
	Height = in.getInt();
	Planes = in.getShort();
	BitsPerPixel = in.getShort();
	Compression = in.getInt();
	SizeOfBitmap = in.getInt();
	HorzResolution = in.getInt();
	VertResolution = in.getInt();
	ColorsUsed = in.getInt();
	ColorsImportant = in.getInt();
	int cols = (int)ColorsUsed;
	if (cols == 0) cols = 1 << BitsPerPixel;
	Palette = new PaletteElement[(int)cols];
	for (int i=0;
	 i<Palette.length;
	 i++) {
		PaletteElement el = new PaletteElement();
		el.Blue = in.get();
		el.Green = in.get();
		el.Red = in.get();
		el.Reserved = in.get();
		Palette[i] = el;
	 }
	int xorbytes = (((int)Height/2) * (int)Width);
	BitmapXOR = new short[xorbytes];
	for (int i=0;
	 i<BitmapXOR.length;
	 i++) {
		switch(BitsPerPixel) {
			 case 4:{
				 int pix = in.get();
				 BitmapXOR[i] = (short)((pix >> 4) & 0x0F);
				 i++;
				 BitmapXOR[i] = (short)(pix & 0x0F);
			}
			break;
			 case 8:{
				 BitmapXOR[i] = in.get();
			}
			break;
		 }
	 }
	int height = (int)(Height/2);
	int rowsize = (int)Width / 8;
	if ((rowsize%4)>0) {
		rowsize += 4 - (rowsize%4);
	 }
	int andbytes = height * rowsize;
	 BitmapAND = new short[andbytes];
	for (int i=0;
	 i<BitmapAND.length;
	 i++) {
		BitmapAND[i] = in.get();
	 }
 }",0,0,1,0
", ,}
)public class ClusterEntity {
 private Long clusterId;
 private String clusterName;
 private State provisioningState = State.INIT;
 private SecurityType securityType = SecurityType.NONE;
 private String desiredClusterState = """";
 private String clusterInfo = """";
 private StackEntity desiredStack;
 private Collection<ClusterServiceEntity> clusterServiceEntities;
 private ClusterStateEntity clusterStateEntity;
 private Collection<HostEntity> hostEntities;
 private Collection<ClusterConfigEntity> configEntities;
 private Collection<ConfigGroupEntity> configGroupEntities;
 private Collection<RequestScheduleEntity> requestScheduleEntities;
 private Collection<ServiceConfigEntity> serviceConfigEntities;
 private Collection<AlertDefinitionEntity> alertDefinitionEntities;
 private Collection<WidgetEntity> widgetEntities;
 private Collection<WidgetLayoutEntity> widgetLayoutEntities;
 }
) private ResourceEntity resource;
 private Long upgradeId;
 private UpgradeEntity upgradeEntity = null;
 public Long getClusterId() {
 return clusterId;
 }
 public void setClusterId(Long clusterId) {
 this.clusterId = clusterId;
 }
 public String getClusterName() {
 return clusterName;
 }
 public void setClusterName(String clusterName) {
 this.clusterName = clusterName;
 }
 public String getDesiredClusterState() {
 return defaultString(desiredClusterState);
 }
 public void setDesiredClusterState(String desiredClusterState) {
 this.desiredClusterState = desiredClusterState;
 }
 public String getClusterInfo() {
 return defaultString(clusterInfo);
 }
 public void setClusterInfo(String clusterInfo) {
 this.clusterInfo = clusterInfo;
 }
 public StackEntity getDesiredStack() {
 return desiredStack;
 }
 public void setDesiredStack(StackEntity desiredStack) {
 this.desiredStack = desiredStack;
 }
 public State getProvisioningState(){
 return provisioningState;
 }
 public void setProvisioningState(State provisioningState){
 this.provisioningState = provisioningState;
 }
 public SecurityType getSecurityType() {
 return securityType;
 }
 public void setSecurityType(SecurityType securityType) {
 this.securityType = securityType;
 }
 public boolean equals(Object o) {
 if (this == o) {
	 return true;
 }
 if (o == null || getClass() != o.getClass()) {
	 return false;
 }
 ClusterEntity that = (ClusterEntity) o;
 if (!clusterId.equals(that.clusterId)) {
	 return false;
 }
 if (!clusterName.equals(that.clusterName)) {
	 return false;
 }
 return true;
 }
 public int hashCode() {
 int result = null == clusterId ? 0 : clusterId.hashCode();
 result = 31 * result + clusterName.hashCode();
 return result;
 }
 public Collection<ClusterServiceEntity> getClusterServiceEntities() {
 return clusterServiceEntities;
 }
 public void setClusterServiceEntities(Collection<ClusterServiceEntity> clusterServiceEntities) {
 this.clusterServiceEntities = clusterServiceEntities;
 }
 public ClusterStateEntity getClusterStateEntity() {
 return clusterStateEntity;
 }
 public void setClusterStateEntity(ClusterStateEntity clusterStateEntity) {
 this.clusterStateEntity = clusterStateEntity;
 }
 public Collection<HostEntity> getHostEntities() {
 return hostEntities;
 }
 public void setHostEntities(Collection<HostEntity> hostEntities) {
 this.hostEntities = hostEntities;
 }
 public Collection<ClusterConfigEntity> getClusterConfigEntities() {
 return configEntities;
 }
 public void setClusterConfigEntities(Collection<ClusterConfigEntity> entities) {
 configEntities = entities;
 }
 public Collection<ConfigGroupEntity> getConfigGroupEntities() {
 return configGroupEntities;
 }
 public void setConfigGroupEntities(Collection<ConfigGroupEntity> configGroupEntities) {
 this.configGroupEntities = configGroupEntities;
 }
 public Collection<RequestScheduleEntity> getRequestScheduleEntities() {
 return requestScheduleEntities;
 }
 public void setRequestScheduleEntities(Collection<RequestScheduleEntity> requestScheduleEntities) {
 this.requestScheduleEntities = requestScheduleEntities;
 }
 public Collection<ServiceConfigEntity> getServiceConfigEntities() {
 return serviceConfigEntities;
 }
 public void setServiceConfigEntities(Collection<ServiceConfigEntity> serviceConfigEntities) {
 this.serviceConfigEntities = serviceConfigEntities;
 }
 public Collection<AlertDefinitionEntity> getAlertDefinitionEntities() {
 return alertDefinitionEntities;
 }
 public ResourceEntity getResource() {
 return resource;
 }
 public void setResource(ResourceEntity resource) {
 this.resource = resource;
 }
 public UpgradeEntity getUpgradeEntity() {
 return upgradeEntity;
 }
 public void setUpgradeEntity(UpgradeEntity upgradeEntity) {
 this.upgradeEntity = upgradeEntity;
 }
}",1,1,0,0
"public abstract class FuncLongToString extends VectorExpression {
	 private static final long serialVersionUID = 1L;
	 private final int inputColumn;
	 protected byte[] bytes;
	 FuncLongToString(int inputColumn, int outputColumnNum) {
		 super(outputColumnNum);
		 this.inputColumn = inputColumn;
	 }
	 FuncLongToString() {
		 super();
		 inputColumn = -1;
	 }
	 public void transientInit() throws HiveException {
		 super.transientInit();
		 bytes = new byte[64];
	 }
	 public void evaluate(VectorizedRowBatch batch) throws HiveException {
		 if (childExpressions != null) {
			 super.evaluateChildren(batch);
		 }
		 LongColumnVector inputColVector = (LongColumnVector) batch.cols[inputColumn];
		 int[] sel = batch.selected;
		 int n = batch.size;
		 long[] vector = inputColVector.vector;
		 BytesColumnVector outputColVector = (BytesColumnVector) batch.cols[outputColumnNum];
		 outputColVector.initBuffer();
		 boolean[] inputIsNull = inputColVector.isNull;
		 boolean[] outputIsNull = outputColVector.isNull;
		 if (n == 0) {
			 return;
		 }
		 outputColVector.isRepeating = false;
		 if (inputColVector.isRepeating) {
			 if (inputColVector.noNulls || !inputIsNull[0]) {
				 outputIsNull[0] = false;
				 prepareResult(0, vector, outputColVector);
			 }
			 else {
				 outputIsNull[0] = true;
				 outputColVector.noNulls = false;
			 }
			 outputColVector.isRepeating = true;
			 return;
		 }
		 if (inputColVector.noNulls) {
			 if (batch.selectedInUse) {
				 if (!outputColVector.noNulls) {
					 for(int j = 0;
					 j != n;
					 j++) {
						 final int i = sel[j];
						 outputIsNull[i] = false;
						 prepareResult(i, vector, outputColVector);
					 }
				 }
				 else {
					 for(int j = 0;
					 j != n;
					 j++) {
						 final int i = sel[j];
						 prepareResult(i, vector, outputColVector);
					 }
				 }
			 }
			 else {
				 if (!outputColVector.noNulls) {
					 Arrays.fill(outputIsNull, false);
					 outputColVector.noNulls = true;
				 }
				 for(int i = 0;
				 i != n;
				 i++) {
					 prepareResult(i, vector, outputColVector);
				 }
			 }
		 }
		 else {
			 outputColVector.noNulls = false;
			 if (batch.selectedInUse) {
				 for(int j=0;
				 j != n;
				 j++) {
					 int i = sel[j];
					 outputColVector.isNull[i] = inputColVector.isNull[i];
					 if (!inputColVector.isNull[i]) {
						 prepareResult(i, vector, outputColVector);
					 }
				 }
			 }
			 else {
				 for(int i = 0;
				 i != n;
				 i++) {
					 outputColVector.isNull[i] = inputColVector.isNull[i];
					 if (!inputColVector.isNull[i]) {
						 prepareResult(i, vector, outputColVector);
					 }
				 }
			 }
		 }
	 }
	 abstract void prepareResult(int i, long[] vector, BytesColumnVector outputColVector);
	 public String vectorExpressionParameters() {
		 return getColumnParamString(0, inputColumn);
	 }
	 public VectorExpressionDescriptor.Descriptor getDescriptor() {
		 return (new VectorExpressionDescriptor.Builder()).setMode( VectorExpressionDescriptor.Mode.PROJECTION).setNumArguments(1).setInputExpressionTypes( VectorExpressionDescriptor.InputExpressionType.COLUMN).setArgumentTypes( VectorExpressionDescriptor.ArgumentType.INT_FAMILY).build();
	 }
}",1,0,0,0
"public class NativeJavaClass extends NativeJavaObject implements Function{
	 static final long serialVersionUID = -6460763940409461664L;
	 static final String javaClassPropertyName = ""__javaObject__"";
	 public NativeJavaClass() {
	 }
	 public NativeJavaClass(Scriptable scope, Class cl) {
		 this.parent = scope;
		 this.javaObject = cl;
		 initMembers();
	 }
	 protected void initMembers() {
		 Class cl = (Class)javaObject;
		 members = JavaMembers.lookupClass(parent, cl, cl, false);
		 staticFieldAndMethods = members.getFieldAndMethodsObjects(this, cl, true);
	 }
	 public String getClassName() {
		 return ""JavaClass"";
	 }
	 public boolean has(String name, Scriptable start) {
		 return members.has(name, true) || javaClassPropertyName.equals(name);
	 }
	 public Object get(String name, Scriptable start) {
		 if (name.equals(""prototype"")) return null;
		 if (staticFieldAndMethods != null) {
			 Object result = staticFieldAndMethods.get(name);
			 if (result != null) return result;
		 }
		 if (members.has(name, true)) {
			 return members.get(this, name, javaObject, true);
		 }
		 if (javaClassPropertyName.equals(name)) {
			 Context cx = Context.getContext();
			 Scriptable scope = ScriptableObject.getTopLevelScope(start);
			 return cx.getWrapFactory().wrap(cx, scope, javaObject, ScriptRuntime.ClassClass);
		 }
		 Class nestedClass = findNestedClass(getClassObject(), name);
		 if (nestedClass != null) {
			 NativeJavaClass nestedValue = new NativeJavaClass (ScriptableObject.getTopLevelScope(this), nestedClass);
			 nestedValue.setParentScope(this);
			 return nestedValue;
		 }
		 throw members.reportMemberNotFound(name);
	 }
	 public void put(String name, Scriptable start, Object value) {
		 members.put(this, name, javaObject, value, true);
	 }
	 public Object[] getIds() {
		 return members.getIds(true);
	 }
	 public Class getClassObject() {
		 return (Class) super.unwrap();
	 }
	 public Object getDefaultValue(Class hint) {
		 if (hint == null || hint == ScriptRuntime.StringClass) return this.toString();
		 if (hint == ScriptRuntime.BooleanClass) return Boolean.TRUE;
		 if (hint == ScriptRuntime.NumberClass) return ScriptRuntime.NaNobj;
		 return this;
	 }
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
		 if (args.length == 1 && args[0] instanceof Scriptable) {
			 Class c = getClassObject();
			 Scriptable p = (Scriptable) args[0];
			 do {
				 if (p instanceof Wrapper) {
					 Object o = ((Wrapper) p).unwrap();
					 if (c.isInstance(o)) return p;
				 }
				 p = p.getPrototype();
			 }
			 while (p != null);
		 }
		 return construct(cx, scope, args);
	 }
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
		 Class classObject = getClassObject();
		 int modifiers = classObject.getModifiers();
		 if (! (Modifier.isInterface(modifiers) || Modifier.isAbstract(modifiers))) {
			 MemberBox[] ctors = members.ctors;
			 int index = NativeJavaMethod.findFunction(cx, ctors, args);
			 if (index < 0) {
				 String sig = NativeJavaMethod.scriptSignature(args);
				 throw Context.reportRuntimeError2( ""msg.no.java.ctor"", classObject.getName(), sig);
			 }
			 return constructSpecific(cx, scope, args, ctors[index]);
		 }
		 else {
			 Scriptable topLevel = ScriptableObject.getTopLevelScope(this);
			 String msg = """";
			 try {
				 Object v = topLevel.get(""JavaAdapter"", topLevel);
				 if (v != NOT_FOUND) {
					 Function f = (Function) v;
					 Object[] adapterArgs = {
					 this, args[0] }
					;
					 return f.construct(cx, topLevel,adapterArgs);
				 }
			 }
			 catch (Exception ex) {
				 String m = ex.getMessage();
				 if (m != null) msg = m;
			 }
			 throw Context.reportRuntimeError2( ""msg.cant.instantiate"", msg, classObject.getName());
		 }
	 }
	 static Scriptable constructSpecific(Context cx, Scriptable scope, Object[] args, MemberBox ctor) {
		 Scriptable topLevel = ScriptableObject.getTopLevelScope(scope);
		 Class[] argTypes = ctor.argTypes;
		 if (ctor.vararg) {
			 Object[] newArgs = new Object[argTypes.length];
			 for (int i = 0;
			 i < argTypes.length-1;
			 i++) {
				 newArgs[i] = Context.jsToJava(args[i], argTypes[i]);
			 }
			 Object varArgs;
			 if (args.length == argTypes.length && (args[args.length-1] == null || args[args.length-1] instanceof NativeArray || args[args.length-1] instanceof NativeJavaArray)) {
				 varArgs = Context.jsToJava(args[args.length-1], argTypes[argTypes.length - 1]);
			 }
			 else {
				 Class componentType = argTypes[argTypes.length - 1]. getComponentType();
				 varArgs = Array.newInstance(componentType, args.length - argTypes.length + 1);
				 for (int i=0;
				 i < Array.getLength(varArgs);
				 i++) {
					 Object value = Context.jsToJava(args[argTypes.length-1 + i], componentType);
					 Array.set(varArgs, i, value);
				 }
			 }
			 newArgs[argTypes.length-1] = varArgs;
			 args = newArgs;
		 }
		 else {
			 Object[] origArgs = args;
			 for (int i = 0;
			 i < args.length;
			 i++) {
				 Object arg = args[i];
				 Object x = Context.jsToJava(arg, argTypes[i]);
				 if (x != arg) {
					 if (args == origArgs) {
						 args = (Object[])origArgs.clone();
					 }
					 args[i] = x;
				 }
			 }
		 }
		 Object instance = ctor.newInstance(args);
		 return cx.getWrapFactory().wrapNewObject(cx, topLevel, instance);
	 }
	 public String toString() {
		 return ""[JavaClass "" + getClassObject().getName() + ""]"";
	 }
	 public boolean hasInstance(Scriptable value) {
		 if (value instanceof Wrapper && !(value instanceof NativeJavaClass)) {
			 Object instance = ((Wrapper)value).unwrap();
			 return getClassObject().isInstance(instance);
		 }
		 return false;
	 }
	 private static Class findNestedClass(Class parentClass, String name) {
		 String nestedClassName = parentClass.getName() + '$' + name;
		 ClassLoader loader = parentClass.getClassLoader();
		 if (loader == null) {
			 return Kit.classOrNull(nestedClassName);
		 }
		 else {
			 return Kit.classOrNull(loader, nestedClassName);
		 }
	 }
	 private Hashtable staticFieldAndMethods;
}",0,0,0,0
"public class Date implements ResourceSelector {
	 private static final String MILLIS_OR_DATETIME = ""Either the millis or the datetime attribute must be set."";
	 private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
	 private Long millis = null;
	 private String dateTime = null;
	 private String pattern = null;
	 private TimeComparison when = TimeComparison.EQUAL;
	 private long granularity = FILE_UTILS.getFileTimestampGranularity();
	 public synchronized void setMillis(long m) {
		 millis = new Long(m);
	 }
	 public synchronized long getMillis() {
		 return millis == null ? -1L : millis.longValue();
	 }
	 public synchronized void setDateTime(String s) {
		 dateTime = s;
		 millis = null;
	 }
	 public synchronized String getDatetime() {
		 return dateTime;
	 }
	 public synchronized void setGranularity(long g) {
		 granularity = g;
	 }
	 public synchronized long getGranularity() {
		 return granularity;
	 }
	 public synchronized void setPattern(String p) {
		 pattern = p;
	 }
	 public synchronized String getPattern() {
		 return pattern;
	 }
	 public synchronized void setWhen(TimeComparison c) {
		 when = c;
	 }
	 public synchronized TimeComparison getWhen() {
		 return when;
	 }
	 public synchronized boolean isSelected(Resource r) {
		 if (dateTime == null && millis == null) {
			 throw new BuildException(MILLIS_OR_DATETIME);
		 }
		 if (millis == null) {
			 DateFormat df = ((pattern == null) ? DateFormat.getDateTimeInstance( DateFormat.SHORT, DateFormat.SHORT, Locale.US) : new SimpleDateFormat(pattern));
			 try {
				 long m = df.parse(dateTime).getTime();
				 if (m < 0) {
					 throw new BuildException(""Date of "" + dateTime + "" results in negative milliseconds value"" + "" relative to epoch (January 1, 1970, 00:00:00 GMT)."");
				 }
				 setMillis(m);
			 }
			 catch (ParseException pe) {
				 throw new BuildException(""Date of "" + dateTime + "" Cannot be parsed correctly. It should be in"" + (pattern == null ? "" MM/DD/YYYY HH:MM AM_PM"" : pattern) + "" format."");
			 }
		 }
		 return when.evaluate(r.getLastModified(), millis.longValue(), granularity);
	 }
}",0,0,0,0
"public final class CEntryPointUtilityNode extends FixedWithNextNode implements Lowerable {
	 public static final NodeClass<CEntryPointUtilityNode> TYPE = NodeClass.create(CEntryPointUtilityNode.class);
	 public enum UtilityAction {
		 IsAttached(JavaKind.Boolean), FailFatally(JavaKind.Void);
		 final JavaKind resultKind;
		 UtilityAction(JavaKind resultKind) {
			 this.resultKind = resultKind;
		 }
	 }
	 protected final UtilityAction utilityAction;
	 protected ValueNode parameter0;
	 protected ValueNode parameter1;
	 public CEntryPointUtilityNode(UtilityAction utilityAction, ValueNode parameter) {
		 this(utilityAction, parameter, null);
	 }
	 public CEntryPointUtilityNode(UtilityAction utilityAction, ValueNode parameter0, ValueNode parameter1) {
		 super(TYPE, StampFactory.forKind(utilityAction.resultKind));
		 this.utilityAction = utilityAction;
		 this.parameter0 = parameter0;
		 this.parameter1 = parameter1;
	 }
	 public UtilityAction getUtilityAction() {
		 return utilityAction;
	 }
	 public ValueNode getParameter0() {
		 return parameter0;
	 }
	 public ValueNode getParameter1() {
		 return parameter1;
	 }
	 public void lower(LoweringTool tool) {
		 tool.getLowerer().lower(this, tool);
	 }
}",0,0,0,0
"public abstract class AbstractCommitLogExecutorService extends AbstractExecutorService implements ICommitLogExecutorService{
	 protected volatile long completedTaskCount = 0;
	 protected static void registerMBean(Object o) {
		 MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
		 try {
			 mbs.registerMBean(o, new ObjectName(""org.apache.cassandra.db:type=Commitlog""));
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
	 public int getActiveCount() {
		 return 1;
	 }
	 public long getCompletedTasks() {
		 return completedTaskCount;
	 }
	 public boolean isTerminated() {
		 throw new UnsupportedOperationException();
	 }
	 public boolean isShutdown() {
		 throw new UnsupportedOperationException();
	 }
	 public List<Runnable> shutdownNow() {
		 throw new UnsupportedOperationException();
	 }
	 public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
		 throw new UnsupportedOperationException();
	 }
}",0,0,0,0
"public class CAddress implements IAddress {
	 private final long m_address;
	 public CAddress(final BigInteger address) {
		 Preconditions.checkNotNull(address, ""Address argument can not be null"");
		 m_address = address.longValue();
	 }
	 public CAddress(final CAddress address) {
		 Preconditions.checkNotNull(address, ""Address argument can not be null"");
		 m_address = address.m_address;
	 }
	 public CAddress(final IAddress address) {
		 Preconditions.checkNotNull(address, ""Address argument can not be null"");
		 m_address = address.toLong();
	 }
	 public CAddress(final long address) {
		 m_address = address;
	 }
	 public CAddress(final String address, final int base) {
		 Preconditions.checkNotNull(address, ""Address argument can not be null"");
		 Preconditions.checkArgument(base > 0, ""Base must be positive"");
		 m_address = new BigInteger(address, base).longValue();
	 }
	 public static int compare(final long addr1, final long addr2) {
		 final int result = addr1 < addr2 ? -1 : (addr1 > addr2 ? 1 : 0);
		 return (addr1 & 0x8000000000000000L) == (addr2 & 0x8000000000000000L) ? result : -result;
	 }
	 public int compareTo(final CAddress addr) {
		 return compare(m_address, addr.m_address);
	 }
	 public int compareTo(final IAddress addr) {
		 return compare(m_address, addr.toLong());
	 }
	 public int compareTo(final long addr) {
		 return compare(m_address, addr);
	 }
	 public boolean equals(final CAddress address) {
		 return (address != null) && (m_address == address.m_address);
	 }
	 public boolean equals(final IAddress address) {
		 return (address != null) && (m_address == address.toLong());
	 }
	 public boolean equals(final long address) {
		 return m_address == address;
	 }
	 public boolean equals(final Object address) {
		 return (address instanceof IAddress) && (m_address == ((IAddress) address).toLong());
	 }
	 public int hashCode() {
		 return Long.valueOf(m_address).hashCode();
	 }
	 public BigInteger toBigInteger() {
		 if ((m_address & 0x8000000000000000L) == 0) {
			 return BigInteger.valueOf(m_address);
		 }
		 return new BigInteger(Long.toHexString(m_address), 16);
	 }
	 public String toHexString() {
		 return Strings.padStart(Long.toHexString(m_address).toUpperCase(), (m_address & 0x7fffffffffffffffL) < 0x100000000L ? 8 : 16, '0');
	 }
	 public long toLong() {
		 return m_address;
	 }
	 public String toString() {
		 return toHexString();
	 }
}",1,0,0,0
"public abstract void registerUpdater(Updater updater);
 public abstract void unregisterUpdater(Updater updater);
}",0,0,0,0
"public void evaluateExtraParams() {
	super.evaluateExtraParams();
	Object doubleValue = null;
	 if (doubleList != null) {
		 doubleValue = findValue(doubleList);
		 addParameter(""doubleList"", doubleValue);
	 }
	 if (size == null || size.trim().length() <= 0) {
		 addParameter(""size"", ""15"");
	 }
	 if (doubleSize == null || doubleSize.trim().length() <= 0) {
		 addParameter(""doubleSize"", ""15"");
	 }
	 if (multiple == null || multiple.trim().length() <= 0) {
		 addParameter(""multiple"", Boolean.TRUE);
	 }
	 if (doubleMultiple == null || doubleMultiple.trim().length() <= 0) {
		 addParameter(""doubleMultiple"", Boolean.TRUE);
	 }
	 if (buttonCssClass != null && buttonCssClass.trim().length() > 0) {
		 addParameter(""buttonCssClass"", buttonCssClass);
	 }
	 if (buttonCssStyle != null && buttonCssStyle.trim().length() > 0) {
		 addParameter(""buttonCssStyle"", buttonCssStyle);
	 }
	 addParameter(""allowSelectAll"", allowSelectAll != null ? findValue(allowSelectAll, Boolean.class) : Boolean.TRUE);
	addParameter(""allowAddToLeft"", allowAddToLeft != null ? findValue(allowAddToLeft, Boolean.class) : Boolean.TRUE);
	addParameter(""allowAddToRight"",allowAddToRight != null ? findValue(allowAddToRight, Boolean.class) : Boolean.TRUE);
	addParameter(""allowAddAllToLeft"",allowAddAllToLeft != null ? findValue(allowAddAllToLeft, Boolean.class) : Boolean.TRUE);
	addParameter(""allowAddAllToRight"", allowAddAllToRight != null ? findValue(allowAddAllToRight, Boolean.class) : Boolean.TRUE);
	addParameter(""allowUpDownOnLeft"", allowUpDownOnLeft != null ? findValue(allowUpDownOnLeft, Boolean.class) : Boolean.TRUE);
	addParameter(""allowUpDownOnRight"", allowUpDownOnRight != null ? findValue(allowUpDownOnRight, Boolean.class) : Boolean.TRUE);
	if (leftTitle != null) {
		addParameter(""leftTitle"", findValue(leftTitle, String.class));
	}
	if (rightTitle != null) {
		addParameter(""rightTitle"", findValue(rightTitle, String.class));
	}
	addParameter(""addToLeftLabel"", addToLeftLabel != null ? findValue(addToLeftLabel, String.class) : ""<-"" );
	addParameter(""addToRightLabel"", addToRightLabel != null ? findValue(addToRightLabel, String.class) : ""->"");
	addParameter(""addAllToLeftLabel"", addAllToLeftLabel != null ? findValue(addAllToLeftLabel, String.class) : ""<<--"");
	addParameter(""addAllToRightLabel"", addAllToRightLabel != null ? findValue(addAllToRightLabel, String.class) : ""-->>"");
	addParameter(""selectAllLabel"",selectAllLabel != null ? findValue(selectAllLabel, String.class) : ""<*>"");
	addParameter(""leftUpLabel"", leftUpLabel != null ? findValue(leftUpLabel, String.class) : ""^"");
	addParameter(""leftDownLabel"", leftDownlabel != null ? findValue(leftDownlabel, String.class) : ""v"");
	addParameter(""rightUpLabel"", rightUpLabel != null ? findValue(rightUpLabel, String.class) : ""^"");
	addParameter(""rightDownLabel"", rightDownLabel != null ? findValue(rightDownLabel, String.class) : ""v"");
	Form formAncestor = (Form) findAncestor(Form.class);
	if (formAncestor != null) {
		enableAncestorFormCustomOnsubmit();
		Map formOptiontransferselectIds = (Map) formAncestor.getParameters().get(""optiontransferselectIds"");
		Map formOptiontransferselectDoubleIds = (Map) formAncestor.getParameters().get(""optiontransferselectDoubleIds"");
		if (formOptiontransferselectIds == null) {
			formOptiontransferselectIds = new LinkedHashMap();
		}
		if (formOptiontransferselectDoubleIds == null) {
			formOptiontransferselectDoubleIds = new LinkedHashMap();
		}
		String tmpId = (String) getParameters().get(""id"");
		String tmpHeaderKey = (String) getParameters().get(""headerKey"");
		if (tmpId != null && (! formOptiontransferselectIds.containsKey(tmpId))) {
			formOptiontransferselectIds.put(tmpId, tmpHeaderKey);
		}
		String tmpDoubleId = (String) getParameters().get(""doubleId"");
		String tmpDoubleHeaderKey = (String) getParameters().get(""doubleHeaderKey"");
		if (tmpDoubleId != null && (! formOptiontransferselectDoubleIds.containsKey(tmpDoubleId))) {
			formOptiontransferselectDoubleIds.put(tmpDoubleId, tmpDoubleHeaderKey);
		}
		formAncestor.getParameters().put(""optiontransferselectIds"", formOptiontransferselectIds);
		formAncestor.getParameters().put(""optiontransferselectDoubleIds"", formOptiontransferselectDoubleIds);
	}
	else {
		_log.warn(""form enclosing optiontransferselect ""+this+"" not found, auto select upon form submit of optiontransferselect will not work"");
	}
}",0,0,1,0
"public class Roles {
	 private Collection<Role> roles;
	 public Roles() {
	 }
	 public Roles(Collection<Role> roles) {
		 this.roles = roles;
	 }
	 public Collection<Role> getRoles() {
		 return roles;
	 }
	 public void setRoles(Collection<Role> roles) {
		 this.roles = roles;
	 }
}",0,1,0,0
"public class OntClassImpl extends OntResourceImpl implements OntClass{
	 private static final String[] IGNORE_NAMESPACES = new String[] {
	 OWL.NS, RDF.getURI(), RDFS.getURI(), ReasonerVocabulary.RBNamespace }
	;
	 public static Implementation factory = new Implementation() {
		 public EnhNode wrap( Node n, EnhGraph eg ) {
			 if (canWrap( n, eg )) {
				 return new OntClassImpl( n, eg );
			 }
			 else {
				 throw new ConversionException( ""Cannot convert node "" + n.toString() + "" to OntClass: it does not have rdf:type owl:Class or equivalent"");
			 }
		 }
		 public boolean canWrap( Node node, EnhGraph eg ) {
			 Profile profile = (eg instanceof OntModel) ? ((OntModel) eg).getProfile() : null;
			 return (profile != null) && profile.isSupported( node, eg, OntClass.class );
		 }
	 }
	;
	 public OntClassImpl( Node n, EnhGraph g ) {
		 super( n, g );
	 }
	 public void setSuperClass( Resource cls ) {
		 setPropertyValue( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", cls );
	 }
	 public void addSuperClass( Resource cls ) {
		 addPropertyValue( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", cls );
	 }
	 public OntClass getSuperClass() {
		 return objectAs( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", OntClass.class );
	 }
	 public ExtendedIterator<OntClass> listSuperClasses() {
		 return listSuperClasses( false );
	 }
	 public ExtendedIterator<OntClass> listSuperClasses( boolean direct ) {
		 OntClass ontClass = this;
		 return listDirectPropertyValues( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", OntClass.class, getProfile().SUB_CLASS_OF(), direct, false ) .filterDrop( ontClass::equals ).filterKeep( new UniqueFilter<>());
	 }
	 public boolean hasSuperClass( Resource cls ) {
		 return hasSuperClass( cls, false );
	 }
	 public boolean hasSuperClass() {
		 return getSuperClass() != null;
	 }
	 public boolean hasSuperClass( Resource cls, boolean direct ) {
		 if (!direct) {
			 return hasPropertyValue( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", cls );
		 }
		 else {
			 InfGraph ig = null;
			 if (getGraph() instanceof InfGraph) {
				 ig = (InfGraph) getGraph();
			 }
			 else if (getGraph() instanceof OntModel) {
				 OntModel m = (OntModel) getGraph();
				 if (m.getGraph() instanceof InfGraph) {
					 ig = (InfGraph) m.getGraph();
				 }
			 }
			 if (ig != null && ig.getReasoner().supportsProperty( ReasonerVocabulary.directSubClassOf )) {
				 return hasPropertyValue( ReasonerVocabulary.directSubClassOf, ""direct sub-class"", cls );
			 }
			 else {
				 return hasSuperClassDirect(cls);
			 }
		 }
	 }
	 public void removeSuperClass( Resource cls ) {
		 removePropertyValue( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", cls );
	 }
	 public void setSubClass( Resource cls ) {
		 checkProfile( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"" );
		 for (StmtIterator i = getModel().listStatements( null, getProfile().SUB_CLASS_OF(), this );
		 i.hasNext();
		 ) {
			 i.removeNext();
		 }
		 cls.as( OntClass.class ).addSuperClass( this );
	 }
	 public void addSubClass( Resource cls ) {
		 cls.as( OntClass.class ).addSuperClass( this );
	 }
	 public OntClass getSubClass() {
		 checkProfile( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"" );
		 StmtIterator i = getModel().listStatements( null, getProfile().SUB_CLASS_OF(), this );
		 try {
			 if (i.hasNext()) {
				 return i.nextStatement() .getSubject() .as( OntClass.class );
			 }
			 else {
				 return null;
			 }
		 }
		 finally {
			 i.close();
		 }
	 }
	 public ExtendedIterator<OntClass> listSubClasses() {
		 return listSubClasses( false );
	 }
	 public ExtendedIterator<OntClass> listSubClasses( boolean direct ) {
		 OntClass ontClass = this;
		 return listDirectPropertyValues( getProfile().SUB_CLASS_OF(), ""SUB_CLASS_OF"", OntClass.class, getProfile().SUB_CLASS_OF(), direct, true ) .filterDrop( ontClass::equals ).filterKeep( new UniqueFilter<>());
	 }
	 public boolean hasSubClass( Resource cls ) {
		 return hasSubClass( cls, false );
	 }
	 public boolean hasSubClass() {
		 return getSubClass() != null;
	 }
	 public boolean hasSubClass( Resource cls, boolean direct ) {
		 if (getModel() instanceof OntModel && (cls.getModel() == null || !(cls.getModel() instanceof OntModel))) {
			 cls = cls.inModel( getModel() );
		 }
		 return cls.as( OntClass.class ).hasSuperClass( this, direct );
	 }
	 public void removeSubClass( Resource cls ) {
		 (cls.as( OntClass.class)).removeSuperClass( this );
	 }
	 public void setEquivalentClass( Resource cls ) {
		 setPropertyValue( getProfile().EQUIVALENT_CLASS(), ""EQUIVALENT_CLASS"", cls );
	 }
	 public void addEquivalentClass( Resource cls ) {
		 addPropertyValue( getProfile().EQUIVALENT_CLASS(), ""EQUIVALENT_CLASS"", cls );
	 }
	 public OntClass getEquivalentClass() {
		 return objectAs( getProfile().EQUIVALENT_CLASS(), ""EQUIVALENT_CLASS"", OntClass.class );
	 }
	 public ExtendedIterator<OntClass> listEquivalentClasses() {
		 return listAs( getProfile().EQUIVALENT_CLASS(), ""EQUIVALENT_CLASS"", OntClass.class ).filterKeep( new UniqueFilter<OntClass>());
	 }
	 public boolean hasEquivalentClass( Resource cls ) {
		 return hasPropertyValue( getProfile().EQUIVALENT_CLASS(), ""EQUIVALENT_CLASS"", cls );
	 }
	 public void removeEquivalentClass( Resource cls ) {
		 removePropertyValue( getProfile().EQUIVALENT_CLASS(), ""EQUIVALENT_CLASS"", cls );
	 }
	 public void setDisjointWith( Resource cls ) {
		 setPropertyValue( getProfile().DISJOINT_WITH(), ""DISJOINT_WITH"", cls );
	 }
	 public void addDisjointWith( Resource cls ) {
		 addPropertyValue( getProfile().DISJOINT_WITH(), ""DISJOINT_WITH"", cls );
	 }
	 public OntClass getDisjointWith() {
		 return objectAs( getProfile().DISJOINT_WITH(), ""DISJOINT_WITH"", OntClass.class );
	 }
	 public ExtendedIterator<OntClass> listDisjointWith() {
		 return listAs( getProfile().DISJOINT_WITH(), ""DISJOINT_WITH"", OntClass.class ).filterKeep( new UniqueFilter<OntClass>() ) ;
	 }
	 public boolean isDisjointWith( Resource cls ) {
		 return hasPropertyValue( getProfile().DISJOINT_WITH(), ""DISJOINT_WITH"", cls );
	 }
	 public void removeDisjointWith( Resource cls ) {
		 removePropertyValue( getProfile().DISJOINT_WITH(), ""DISJOINT_WITH"", cls );
	 }
	 public ExtendedIterator<OntProperty> listDeclaredProperties() {
		 return listDeclaredProperties( false );
	 }
	 public ExtendedIterator<OntProperty> listDeclaredProperties( boolean direct ) {
		 Set<RDFNode> candSet = new HashSet<>();
		 for (Iterator<Statement> i = listAllProperties();
		 i.hasNext();
		 ) {
			 candSet.add( i.next().getSubject().as( Property.class ) );
		 }
		 List<RDFNode> cands = new ArrayList<>();
		 cands.addAll( candSet );
		 for (int j = cands.size() -1;
		 j >= 0;
		 j--) {
			 Property cand = (Property) cands.get( j );
			 if (!hasDeclaredProperty( cand, direct )) {
				 cands.remove( j );
			 }
		 }
		 return WrappedIterator.create( cands.iterator() ) .mapWith( n -> n.as( OntProperty.class ) );
	 }
	 public boolean hasDeclaredProperty( Property p, boolean direct ) {
		 return testDomain( p, direct );
	 }
	 public ExtendedIterator<Individual> listInstances() {
		 return listInstances( false );
	 }
	 public ExtendedIterator<Individual> listInstances( final boolean direct ) {
		 return getModel() .listStatements( null, RDF.type, this ) .mapWith( s -> s.getSubject().as( Individual.class ) ) .filterKeep( o -> o.hasRDFType( OntClassImpl.this, direct )) .filterKeep( new UniqueFilter<Individual>());
	 }
	 public Individual createIndividual() {
		 return ((OntModel) getModel()).createIndividual( this );
	 }
	 public Individual createIndividual( String uri ) {
		 return ((OntModel) getModel()).createIndividual( uri, this );
	 }
	 public void dropIndividual( Resource individual ) {
		 getModel().remove( individual, RDF.type, this );
	 }
	 public boolean isHierarchyRoot() {
		 if (equals( getProfile().NOTHING() )) {
			 return false;
		 }
		 ExtendedIterator<OntClass> i = listSuperClasses( true );
		 try {
			 while (i.hasNext()) {
				 Resource sup = i.next();
				 if (!(sup.equals( getProfile().THING() ) || sup.equals( RDFS.Resource ) || sup.equals( this ))) {
					 return false;
				 }
			 }
		 }
		 finally {
			 i.close();
		 }
		 return true;
	 }
	 public EnumeratedClass asEnumeratedClass() {
		 return as( EnumeratedClass.class );
	 }
	 public UnionClass asUnionClass() {
		 return as( UnionClass.class );
	 }
	 public IntersectionClass asIntersectionClass() {
		 return as( IntersectionClass.class );
	 }
	 public ComplementClass asComplementClass() {
		 return as( ComplementClass.class );
	 }
	 public Restriction asRestriction() {
		 return as( Restriction.class );
	 }
	 public boolean isEnumeratedClass() {
		 checkProfile( getProfile().ONE_OF(), ""ONE_OF"" );
		 return hasProperty( getProfile().ONE_OF() );
	 }
	 public boolean isUnionClass() {
		 checkProfile( getProfile().UNION_OF(), ""UNION_OF"" );
		 return hasProperty( getProfile().UNION_OF() );
	 }
	 public boolean isIntersectionClass() {
		 checkProfile( getProfile().INTERSECTION_OF(), ""INTERSECTION_OF"" );
		 return hasProperty( getProfile().INTERSECTION_OF() );
	 }
	 public boolean isComplementClass() {
		 checkProfile( getProfile().COMPLEMENT_OF(), ""COMPLEMENT_OF"" );
		 return hasProperty( getProfile().COMPLEMENT_OF() );
	 }
	 public boolean isRestriction() {
		 checkProfile( getProfile().RESTRICTION(), ""RESTRICTION"" );
		 return hasProperty( getProfile().ON_PROPERTY() ) || hasProperty( RDF.type, getProfile().RESTRICTION() );
	 }
	 public EnumeratedClass convertToEnumeratedClass( RDFList individuals ) {
		 setPropertyValue( getProfile().ONE_OF(), ""ONE_OF"", individuals );
		 return as( EnumeratedClass.class );
	 }
	 public IntersectionClass convertToIntersectionClass( RDFList classes ) {
		 setPropertyValue( getProfile().INTERSECTION_OF(), ""INTERSECTION_OF"", classes );
		 return as( IntersectionClass.class );
	 }
	 public UnionClass convertToUnionClass( RDFList classes ) {
		 setPropertyValue( getProfile().UNION_OF(), ""UNION_OF"", classes );
		 return as( UnionClass.class );
	 }
	 public ComplementClass convertToComplementClass( Resource cls ) {
		 setPropertyValue( getProfile().COMPLEMENT_OF(), ""COMPLEMENT_OF"", cls );
		 return as( ComplementClass.class );
	 }
	 public Restriction convertToRestriction( Property prop ) {
		 if (!hasRDFType( getProfile().RESTRICTION(), ""RESTRICTION"", false )) {
			 setRDFType( getProfile().RESTRICTION() );
		 }
		 setPropertyValue( getProfile().ON_PROPERTY(), ""ON_PROPERTY"", prop );
		 return as( Restriction.class );
	 }
	 protected boolean hasSuperClassDirect(Resource cls) {
		 ExtendedIterator<OntClass> i = listDirectPropertyValues( getProfile().SUB_CLASS_OF(), ""subClassOf"", OntClass.class, getProfile().SUB_CLASS_OF(), true, false );
		 try {
			 while (i.hasNext()) {
				 if (cls.equals( i.next() )) {
					 return true;
				 }
			 }
		 }
		 finally {
			 i.close();
		 }
		 return false;
	 }
	 protected boolean testDomain( Property p, boolean direct ) {
		 String namespace = p.getNameSpace();
		 for ( String IGNORE_NAMESPACE : IGNORE_NAMESPACES ) {
			 if ( namespace.equals( IGNORE_NAMESPACE ) ) {
				 return false;
			 }
		 }
		 boolean isGlobal = true;
		 boolean seenDirect = false;
		 for (StmtIterator i = getModel().listStatements( p, getProfile().DOMAIN(), (RDFNode) null );
		 i.hasNext();
		 ) {
			 Resource domain = i.nextStatement().getResource();
			 if (!(domain.equals( getProfile().THING() ) || domain.equals( RDFS.Resource ))) {
				 isGlobal = false;
				 if (domain.equals( this )) {
					 seenDirect = true;
				 }
				 else if (!canProveSuperClass( domain )) {
					 i.close();
					 return false;
				 }
			 }
		 }
		 if (direct) {
			 return seenDirect || (isGlobal && isHierarchyRoot());
		 }
		 else {
			 return true;
		 }
	 }
	 protected ExtendedIterator<Statement> listAllProperties() {
		 OntModel mOnt = (OntModel) getModel();
		 Profile prof = mOnt.getProfile();
		 ExtendedIterator<Statement> pi = mOnt.listStatements( null, RDF.type, getProfile().PROPERTY() );
		 if (mOnt.getReasoner() != null) {
			 Model caps = mOnt.getReasoner().getReasonerCapabilities();
			 if (caps.contains( null, ReasonerVocabulary.supportsP, OWL.ObjectProperty) ) {
				 return pi;
			 }
		 }
		 if (prof.OBJECT_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.OBJECT_PROPERTY() ) );
		 }
		 if (prof.DATATYPE_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.DATATYPE_PROPERTY() ) );
		 }
		 if (prof.FUNCTIONAL_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.FUNCTIONAL_PROPERTY() ) );
		 }
		 if (prof.INVERSE_FUNCTIONAL_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.INVERSE_FUNCTIONAL_PROPERTY() ) );
		 }
		 if (prof.SYMMETRIC_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.SYMMETRIC_PROPERTY() ) );
		 }
		 if (prof.TRANSITIVE_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.TRANSITIVE_PROPERTY() ) );
		 }
		 if (prof.ANNOTATION_PROPERTY() != null) {
			 pi = pi.andThen( mOnt.listStatements( null, RDF.type, prof.ANNOTATION_PROPERTY() ) );
		 }
		 return pi;
	 }
	 protected boolean canProveSuperClass( Resource sup ) {
		 OntModel om = (OntModel) getModel();
		 if (om.getReasoner() != null) {
			 if (om.getReasoner() .getReasonerCapabilities().contains( null, ReasonerVocabulary.supportsP, RDFS.subClassOf )) {
				 return hasSuperClass( sup );
			 }
		 }
		 Set<OntClass> seen = new HashSet<>();
		 List<OntClass> queue = new ArrayList<>();
		 queue.add( this );
		 while (!queue.isEmpty()) {
			 OntClass c = queue.remove( 0 );
			 if (!seen.contains( c )) {
				 seen.add( c );
				 if (c.equals( sup )) {
					 return true;
				 }
				 else {
					 for (Iterator<OntClass> i = c.listSuperClasses();
					 i.hasNext();
					 ) {
						 queue.add( i.next() );
					 }
				 }
			 }
		 }
		 return false;
	 }
}",1,0,0,0
"public class RuleRegistryImpl extends AbstractRegistry<Rule, String, RuleProvider> implements RuleRegistry, RegistryChangeListener<RuleTemplate> {
	 private static final long DEFAULT_REINITIALIZATION_DELAY = 500;
	 private static final String CONFIG_PROPERTY_REINITIALIZATION_DELAY = ""rule.reinitialization.delay"";
	 private static final String SOURCE = RuleRegistryImpl.class.getSimpleName();
	 private final Logger logger = LoggerFactory.getLogger(RuleRegistryImpl.class.getName());
	 private long scheduleReinitializationDelay;
	 private ModuleTypeRegistry moduleTypeRegistry;
	 private RuleTemplateRegistry templateRegistry;
	 private final Map<String, Set<String>> mapTemplateToRules = new HashMap<String, Set<String>>();
	 public RuleRegistryImpl() {
		 super(RuleProvider.class);
	 }
	 protected void activate(BundleContext bundleContext, Map<String, Object> properties) throws Exception {
		 modified(properties);
		 super.activate(bundleContext);
	 }
	 protected void modified(Map<String, Object> config) {
		 Object value = config == null ? null : config.get(CONFIG_PROPERTY_REINITIALIZATION_DELAY);
		 this.scheduleReinitializationDelay = (value != null && value instanceof Number) ? (((Number) value).longValue()) : DEFAULT_REINITIALIZATION_DELAY;
		 if (value != null && !(value instanceof Number)) {
			 logger.warn(""Invalid configuration value: {
			}
			. It MUST be Number."", value);
		 }
	 }
	 protected void deactivate() {
		 super.deactivate();
	 }
	 protected void setEventPublisher(EventPublisher eventPublisher) {
		 super.setEventPublisher(eventPublisher);
	 }
	 protected void unsetEventPublisher(EventPublisher eventPublisher) {
		 super.unsetEventPublisher(eventPublisher);
	 }
	 protected void setManagedProvider(ManagedRuleProvider managedProvider) {
		 super.setManagedProvider(managedProvider);
	 }
	 protected void unsetManagedProvider(ManagedRuleProvider managedProvider) {
		 super.unsetManagedProvider(managedProvider);
	 }
	 protected void setModuleTypeRegistry(ModuleTypeRegistry moduleTypeRegistry) {
		 this.moduleTypeRegistry = moduleTypeRegistry;
	 }
	 protected void unsetModuleTypeRegistry(ModuleTypeRegistry moduleTypeRegistry) {
		 this.moduleTypeRegistry = null;
	 }
	 protected void setTemplateRegistry(TemplateRegistry<RuleTemplate> templateRegistry) {
		 if (templateRegistry instanceof RuleTemplateRegistry) {
			 this.templateRegistry = (RuleTemplateRegistry) templateRegistry;
			 templateRegistry.addRegistryChangeListener(this);
		 }
	 }
	 protected void unsetTemplateRegistry(TemplateRegistry<RuleTemplate> templateRegistry) {
		 if (templateRegistry instanceof RuleTemplateRegistry) {
			 this.templateRegistry = null;
			 templateRegistry.removeRegistryChangeListener(this);
		 }
	 }
	 public Rule add(Rule rule) {
		 super.add(rule);
		 Rule ruleCopy = get(rule.getUID());
		 if (ruleCopy == null) {
			 throw new IllegalStateException();
		 }
		 return ruleCopy;
	 }
	 protected void notifyListenersAboutAddedElement(Rule element) {
		 postRuleAddedEvent(element);
		 postRuleStatusInfoEvent(element.getUID(), new RuleStatusInfo(RuleStatus.UNINITIALIZED));
		 super.notifyListenersAboutAddedElement(element);
	 }
	 protected void notifyListenersAboutUpdatedElement(Rule oldElement, Rule element) {
		 postRuleUpdatedEvent(element, oldElement);
		 super.notifyListenersAboutUpdatedElement(oldElement, element);
	 }
	 protected void postRuleAddedEvent(Rule rule) {
		 postEvent(RuleEventFactory.createRuleAddedEvent(rule, SOURCE));
	 }
	 protected void postRuleRemovedEvent(Rule rule) {
		 postEvent(RuleEventFactory.createRuleRemovedEvent(rule, SOURCE));
	 }
	 protected void postRuleUpdatedEvent(Rule rule, Rule oldRule) {
		 postEvent(RuleEventFactory.createRuleUpdatedEvent(rule, oldRule, SOURCE));
	 }
	 protected void postRuleStatusInfoEvent(String ruleUID, RuleStatusInfo statusInfo) {
		 postEvent(RuleEventFactory.createRuleStatusInfoEvent(statusInfo, ruleUID, SOURCE));
	 }
	 protected void onRemoveElement(Rule rule) {
		 String uid = rule.getUID();
		 String templateUID = rule.getTemplateUID();
		 if (templateUID != null) {
			 updateRuleTemplateMapping(templateUID, uid, true);
		 }
	 }
	 protected void notifyListenersAboutRemovedElement(Rule element) {
		 super.notifyListenersAboutRemovedElement(element);
		 postRuleRemovedEvent(element);
	 }
	 public Collection<Rule> getByTag(String tag) {
		 Collection<Rule> result = new LinkedList<Rule>();
		 if (tag == null) {
			 forEach(result::add);
		 }
		 else {
			 forEach(rule -> {
				 if (rule.getTags().contains(tag)) {
					 result.add(rule);
				 }
			 }
			);
		 }
		 return result;
	 }
	 public Collection<Rule> getByTags(String... tags) {
		 Set<String> tagSet = tags != null ? new HashSet<String>(Arrays.asList(tags)) : null;
		 Collection<Rule> result = new LinkedList<Rule>();
		 if (tagSet == null || tagSet.isEmpty()) {
			 forEach(result::add);
		 }
		 else {
			 forEach(rule -> {
				 if (rule.getTags().containsAll(tagSet)) {
					 result.add(rule);
				 }
			 }
			);
		 }
		 return result;
	 }
	 private Rule resolveRuleByTemplate(Rule rule) {
		 String templateUID = rule.getTemplateUID();
		 if (templateUID == null) {
			 return rule;
		 }
		 RuleTemplate template = templateRegistry.get(templateUID);
		 String uid = rule.getUID();
		 if (template == null) {
			 updateRuleTemplateMapping(templateUID, uid, false);
			 logger.debug(""Rule template {
			}
			 does not exist."", templateUID);
			 return rule;
		 }
		 else {
			 RuleImpl resolvedRule = (RuleImpl) RuleBuilder .create(template, rule.getUID(), rule.getName(), rule.getConfiguration(), rule.getVisibility()) .build();
			 resolveConfigurations(resolvedRule);
			 updateRuleTemplateMapping(templateUID, uid, true);
			 return resolvedRule;
		 }
	 }
	 private void updateRuleTemplateMapping(String templateUID, String ruleUID, boolean resolved) {
		 synchronized (this) {
			 Set<String> ruleUIDs = mapTemplateToRules.get(templateUID);
			 if (ruleUIDs == null) {
				 ruleUIDs = new HashSet<String>();
				 mapTemplateToRules.put(templateUID, ruleUIDs);
			 }
			 if (resolved) {
				 ruleUIDs.remove(ruleUID);
			 }
			 else {
				 ruleUIDs.add(ruleUID);
			 }
		 }
	 }
	 protected void addProvider(Provider<Rule> provider) {
		 super.addProvider(provider);
		 forEach(provider, rule -> {
			 try {
				 Rule resolvedRule = resolveRuleByTemplate(rule);
				 if (rule != resolvedRule && provider instanceof ManagedRuleProvider) {
					 update(resolvedRule);
				 }
			 }
			 catch (IllegalArgumentException e) {
				 logger.error(""Added rule '{
				}
				' is invalid"", rule.getUID(), e);
			 }
		 }
		);
	 }
	 public void added(Provider<Rule> provider, Rule element) {
		 String ruleUID = element.getUID();
		 Rule resolvedRule = element;
		 try {
			 resolvedRule = resolveRuleByTemplate(element);
		 }
		 catch (IllegalArgumentException e) {
			 logger.debug(""Added rule '{
			}
			' is invalid"", ruleUID, e);
		 }
		 super.added(provider, element);
		 if (element != resolvedRule) {
			 if (provider instanceof ManagedRuleProvider) {
				 update(resolvedRule);
			 }
			 else {
				 super.updated(provider, element, resolvedRule);
			 }
		 }
	 }
	 public void updated(Provider<Rule> provider, Rule oldElement, Rule element) {
		 String uid = element.getUID();
		 if (oldElement != null && uid.equals(oldElement.getUID())) {
			 Rule resolvedRule = element;
			 try {
				 resolvedRule = resolveRuleByTemplate(element);
			 }
			 catch (IllegalArgumentException e) {
				 logger.error(""The rule '{
				}
				' is not updated, the new version is invalid"", uid, e);
			 }
			 if (element != resolvedRule && provider instanceof ManagedRuleProvider) {
				 update(resolvedRule);
			 }
			 else {
				 super.updated(provider, oldElement, resolvedRule);
			 }
		 }
		 else {
			 throw new IllegalArgumentException( String.format(""The rule '%s' is not updated, not matching with any existing rule"", uid));
		 }
	 }
	 protected void onAddElement(Rule element) throws IllegalArgumentException {
		 String uid = element.getUID();
		 try {
			 resolveConfigurations(element);
		 }
		 catch (IllegalArgumentException e) {
			 logger.debug(""Added rule '{
			}
			' is invalid"", uid, e);
		 }
	 }
	 protected void onUpdateElement(Rule oldElement, Rule element) throws IllegalArgumentException {
		 String uid = element.getUID();
		 try {
			 resolveConfigurations(element);
		 }
		 catch (IllegalArgumentException e) {
			 logger.debug(""The new version of updated rule '{
			}
			' is invalid"", uid, e);
		 }
	 }
	 private void resolveConfigurations(Rule rule) {
		 List<ConfigDescriptionParameter> configDescriptions = rule.getConfigurationDescriptions();
		 Configuration configuration = rule.getConfiguration();
		 ConfigurationNormalizer.normalizeConfiguration(configuration, ConfigurationNormalizer.getConfigDescriptionMap(configDescriptions));
		 Map<String, Object> configurationProperties = configuration.getProperties();
		 if (rule.getTemplateUID() == null) {
			 String uid = rule.getUID();
			 try {
				 validateConfiguration(configDescriptions, new HashMap<>(configurationProperties));
				 resolveModuleConfigReferences(rule.getModules(), configurationProperties);
				 ConfigurationNormalizer.normalizeModuleConfigurations(rule.getModules(), moduleTypeRegistry);
			 }
			 catch (IllegalArgumentException e) {
				 throw new IllegalArgumentException(String.format(""The rule '%s' has incorrect configurations"", uid), e);
			 }
		 }
	 }
	 private void validateConfiguration(List<ConfigDescriptionParameter> configDescriptions, Map<String, Object> configurations) {
		 if (configurations == null || configurations.isEmpty()) {
			 if (isOptionalConfig(configDescriptions)) {
				 return;
			 }
			 else {
				 StringBuffer statusDescription = new StringBuffer();
				 String msg = "" '%s';
				"";
				 for (ConfigDescriptionParameter configParameter : configDescriptions) {
					 if (configParameter.isRequired()) {
						 String name = configParameter.getName();
						 statusDescription.append(String.format(msg, name));
					 }
				 }
				 throw new IllegalArgumentException( ""Missing required configuration properties: "" + statusDescription.toString());
			 }
		 }
		 else {
			 for (ConfigDescriptionParameter configParameter : configDescriptions) {
				 String configParameterName = configParameter.getName();
				 processValue(configurations.remove(configParameterName), configParameter);
			 }
			 if (!configurations.isEmpty()) {
				 StringBuffer statusDescription = new StringBuffer();
				 String msg = "" '%s';
				"";
				 for (String name : configurations.keySet()) {
					 statusDescription.append(String.format(msg, name));
				 }
				 throw new IllegalArgumentException(""Extra configuration properties: "" + statusDescription.toString());
			 }
		 }
	 }
	 private boolean isOptionalConfig(List<ConfigDescriptionParameter> configDescriptions) {
		 if (configDescriptions != null && !configDescriptions.isEmpty()) {
			 boolean required = false;
			 Iterator<ConfigDescriptionParameter> i = configDescriptions.iterator();
			 while (i.hasNext()) {
				 ConfigDescriptionParameter param = i.next();
				 required = required || param.isRequired();
			 }
			 return !required;
		 }
		 return true;
	 }
	 private void processValue(Object configValue, ConfigDescriptionParameter configParameter) {
		 if (configValue != null) {
			 Type type = configParameter.getType();
			 if (configParameter.isMultiple()) {
				 if (configValue instanceof List) {
					 List lConfigValues = (List) configValue;
					 for (Object value : lConfigValues) {
						 if (!checkType(type, value)) {
							 throw new IllegalArgumentException(""Unexpected value for configuration property \"""" + configParameter.getName() + ""\"". Expected type: "" + type);
						 }
					 }
				 }
				 else {
					 throw new IllegalArgumentException( ""Unexpected value for configuration property \"""" + configParameter.getName() + ""\"". Expected is Array with type for elements : "" + type.toString() + ""!"");
				 }
			 }
			 else if (!checkType(type, configValue)) {
				 throw new IllegalArgumentException(""Unexpected value for configuration property \"""" + configParameter.getName() + ""\"". Expected is "" + type.toString() + ""!"");
			 }
		 }
		 else if (configParameter.isRequired()) {
			 throw new IllegalArgumentException( ""Required configuration property missing: \"""" + configParameter.getName() + ""\""!"");
		 }
	 }
	 private boolean checkType(Type type, Object configValue) {
		 switch (type) {
			 case TEXT: return configValue instanceof String;
			 case BOOLEAN: return configValue instanceof Boolean;
			 case INTEGER: return configValue instanceof BigDecimal || configValue instanceof Integer || configValue instanceof Double && ((Double) configValue).intValue() == (Double) configValue;
			 case DECIMAL: return configValue instanceof BigDecimal || configValue instanceof Double;
		 }
		 return false;
	 }
	 private void resolveModuleConfigReferences(List<? extends Module> modules, Map<String, ?> ruleConfiguration) {
		 if (modules != null) {
			 StringBuffer statusDescription = new StringBuffer();
			 for (Module module : modules) {
				 try {
					 ReferenceResolver.updateConfiguration(module.getConfiguration(), ruleConfiguration, logger);
				 }
				 catch (IllegalArgumentException e) {
					 statusDescription.append("" in module["" + module.getId() + ""]: "" + e.getLocalizedMessage() + "";
					"");
				 }
			 }
			 String statusDescriptionStr = statusDescription.toString();
			 if (!statusDescriptionStr.isEmpty()) {
				 throw new IllegalArgumentException(String.format(""Incorrect configurations: %s"", statusDescriptionStr));
			 }
		 }
	 }
	 public void added(RuleTemplate element) {
		 String templateUID = element.getUID();
		 Set<String> rules = new HashSet<String>();
		 synchronized (this) {
			 Set<String> rulesForResolving = mapTemplateToRules.get(templateUID);
			 if (rulesForResolving != null) {
				 rules.addAll(rulesForResolving);
			 }
		 }
		 for (String rUID : rules) {
			 try {
				 Rule unresolvedRule = get(rUID);
				 Rule resolvedRule = resolveRuleByTemplate(unresolvedRule);
				 Provider<Rule> provider = getProvider(rUID);
				 if (provider instanceof ManagedRuleProvider) {
					 update(resolvedRule);
				 }
				 else {
					 updated(provider, unresolvedRule, unresolvedRule);
				 }
			 }
			 catch (IllegalArgumentException e) {
				 logger.error(""Resolving the rule '{
				}
				' by template '{
				}
				' failed"", rUID, templateUID, e);
			 }
		 }
	 }
	 public void removed(RuleTemplate element) {
	 }
	 public void updated(RuleTemplate oldElement, RuleTemplate element) {
	 }
	 long getScheduleReinitializationDelay() {
		 return scheduleReinitializationDelay;
	 }
}",1,1,0,0
"public class TestPigServer {
	 private static Properties properties;
	 private static MiniGenericCluster cluster;
	 private File tempDir;
	 public void setUp() throws Exception{
		 tempDir = Files.createTempDir();
		 tempDir.deleteOnExit();
		 registerNewResource(tempDir.getAbsolutePath());
	 }
	 public void tearDown() throws Exception{
		 tempDir.delete();
	 }
	 public static void oneTimeSetup() {
		 cluster = MiniGenericCluster.buildCluster();
		 properties = cluster.getProperties();
	 }
	 public static void oneTimeTearDown() throws Exception {
		 cluster.shutDown();
	 }
	 private final static String FILE_SEPARATOR = System.getProperty(""file.separator"");
	 private static void verifyStringContained(List<URL> list, String name, boolean included) {
		 int count = 0;
		 for (URL url : list) {
			 if (url.toString().contains(name)) {
				 if (!included) {
					 fail(""Included is false, but url [""+url+""] contains name [""+name+""]"");
				 }
				 assertEquals(""Too many urls contain name: "" + name, 1, ++count);
			 }
		 }
		 if (included) {
			 assertEquals(""Number of urls that contain name ["" + name + ""] != 1"", 1, count);
		 }
	 }
	 private static void createFakeJarFile(String location, String name) throws IOException {
		 createFakeJarFile(location, name, FileSystem.getLocal(cluster.getConfiguration()).getRaw());
	 }
	 private static void createFakeJarFile(String location, String name, FileSystem fs) throws IOException {
		 System.err. println(""Location: "" + location + "" name: "" + name);
		 Path dir = new Path(location);
		 fs.mkdirs(dir);
		 assertTrue(fs.createNewFile(new Path(dir, name)));
	 }
	 private static void registerNewResource(String file) throws Exception {
		 URL urlToAdd = new File(file).toURI().toURL();
		 ClassLoader sysLoader = ClassLoader.getSystemClassLoader();
		 while (sysLoader.getParent().getParent() != null) {
			 sysLoader = sysLoader.getParent();
		 }
		 if (sysLoader instanceof URLClassLoader) {
			 Method addMethod = URLClassLoader.class. getDeclaredMethod(""addURL"", new Class[]{
			URL.class}
			);
			 addMethod.setAccessible(true);
			 addMethod.invoke(sysLoader, new Object[]{
			urlToAdd}
			);
		 }
		 else {
			 Field parent = ClassLoader.class.getDeclaredField(""parent"");
			 parent.setAccessible(true);
			 ClassLoader urlClassLoader = new URLClassLoader(new URL[]{
			urlToAdd}
			, ClassLoader.getSystemClassLoader().getParent());
			 parent.set(ClassLoader.getSystemClassLoader(), urlClassLoader);
		 }
	 }
	 public void testRegisterJarFileNotPresent() throws Throwable {
		 String jarName = ""BadFileNameTestJarNotPresent.jar"";
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, false);
		 boolean raisedException = false;
		 try {
			 pig.registerJar(jarName);
		 }
		 catch (IOException e) {
			 raisedException = true;
		 }
		 assertTrue(""registerJar on jarName [""+jarName+""] should have raised an exception"", raisedException);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, false);
	 }
	 public void testRegisterJarLocalDir() throws Throwable {
		 String dir1 = ""test1_register_jar_local"";
		 String dir2 = ""test2_register_jar_local"";
		 String jarLocation = dir1 + FILE_SEPARATOR + dir2 + FILE_SEPARATOR;
		 String jarName = ""TestRegisterJarLocal.jar"";
		 createFakeJarFile(jarLocation, jarName);
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, false);
		 pig.registerJar(jarLocation + jarName);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, true);
		 assertTrue((new File(jarLocation + jarName)).delete());
		 (new File(dir1 + FILE_SEPARATOR + dir2)).delete();
		 (new File(dir1)).delete();
	 }
	 public void testRegisterJarFromResources () throws Throwable {
		 String dir = ""test_register_jar_res_dir"";
		 String subDir1 = ""test_register_jar_res_sub_dir1"";
		 String subDir2 = ""test_register_jar_res_sub_dir2"";
		 String jarName = ""TestRegisterJarFromRes.jar"";
		 String jarLocation1 = dir + FILE_SEPARATOR + subDir1 + FILE_SEPARATOR;
		 String jarLocation2 = dir + FILE_SEPARATOR + subDir2 + FILE_SEPARATOR;
		 createFakeJarFile(jarLocation1, jarName);
		 createFakeJarFile(jarLocation2, jarName);
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, false);
		 registerNewResource(jarLocation1);
		 registerNewResource(jarLocation2);
		 pig.registerJar(jarName);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, true);
		 assertTrue((new File(jarLocation1 + jarName)).delete());
		 assertTrue((new File(jarLocation2 + jarName)).delete());
		 (new File(jarLocation1)).delete();
		 (new File(jarLocation2)).delete();
		 (new File(dir)).delete();
	 }
	 public void testRegisterJarResourceInJar() throws Throwable {
		 String dir = ""test_register_jar_res_in_jar"";
		 String subDir = ""sub_dir"";
		 String jarName = ""TestRegisterJarNonEmpty.jar"";
		 String className = ""TestRegisterJar"";
		 String javaSrc = ""package "" + subDir + "";
		 class "" + className + "" {
		 }
		"";
		 (new File(dir + FILE_SEPARATOR + subDir)).mkdirs();
		 FileOutputStream outStream = new FileOutputStream(new File(dir + FILE_SEPARATOR + subDir + FILE_SEPARATOR + className + "".java""));
		 OutputStreamWriter outWriter = new OutputStreamWriter(outStream);
		 outWriter.write(javaSrc);
		 outWriter.close();
		 int status;
		 status = Util.executeJavaCommand(""javac "" + dir + FILE_SEPARATOR + subDir + FILE_SEPARATOR + className + "".java"");
		 assertEquals(0, status);
		 (new File(dir + FILE_SEPARATOR + subDir + FILE_SEPARATOR + className + "".java"")).delete();
		 status = Util.executeJavaCommand(""jar -cf "" + dir + FILE_SEPARATOR + jarName + "" "" + ""-C "" + dir + "" "" + subDir);
		 assertEquals(0, status);
		 (new File(dir + FILE_SEPARATOR + subDir + FILE_SEPARATOR + className + "".class"")).delete();
		 (new File(dir + FILE_SEPARATOR + subDir)).delete();
		 registerNewResource(dir + FILE_SEPARATOR + jarName);
		 boolean exceptionRaised = false;
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 try {
			 pig.registerJar(""sub_dir/TestRegisterJar.class"");
		 }
		 catch (IOException e) {
			 exceptionRaised = true;
		 }
		 assertFalse(exceptionRaised);
		 verifyStringContained(pig.getPigContext().extraJars, jarName, true);
		 (new File(dir + FILE_SEPARATOR + jarName)).delete();
		 (new File(dir)).delete();
	 }
	 public void testRegisterJarGlobbingRelative() throws Throwable {
		 String dir = ""test1_register_jar_globbing_relative"";
		 String jarLocation = dir + FILE_SEPARATOR;
		 String jar1Name = ""TestRegisterJarGlobbing1.jar"";
		 String jar2Name = ""TestRegisterJarGlobbing2.jar"";
		 createFakeJarFile(jarLocation, jar1Name);
		 createFakeJarFile(jarLocation, jar2Name);
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerJar(jarLocation + ""TestRegisterJarGlobbing*.jar"");
		 verifyStringContained(pig.getPigContext().extraJars, jar1Name, true);
		 verifyStringContained(pig.getPigContext().extraJars, jar2Name, true);
		 assertTrue((new File(jarLocation + jar1Name)).delete());
		 assertTrue((new File(jarLocation + jar2Name)).delete());
		 (new File(dir)).delete();
	 }
	 public void testRegisterJarGlobbingAbsolute() throws Throwable {
		 String dir = ""test1_register_jar_globbing_absolute"";
		 String jarLocation = dir + FILE_SEPARATOR;
		 String jar1Name = ""TestRegisterJarGlobbing1.jar"";
		 String jar2Name = ""TestRegisterJarGlobbing2.jar"";
		 createFakeJarFile(jarLocation, jar1Name);
		 createFakeJarFile(jarLocation, jar2Name);
		 String currentDir = System.getProperty(""user.dir"");
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerJar(new File(currentDir, dir) + FILE_SEPARATOR + ""TestRegisterJarGlobbing*.jar"");
		 verifyStringContained(pig.getPigContext().extraJars, jar1Name, true);
		 verifyStringContained(pig.getPigContext().extraJars, jar2Name, true);
		 assertTrue((new File(jarLocation + jar1Name)).delete());
		 assertTrue((new File(jarLocation + jar2Name)).delete());
		 (new File(dir)).delete();
	 }
	 public void testRegisterRemoteGlobbingJar() throws Throwable {
		 String dir = ""test1_register_remote_jar_globbing"";
		 String jarLocation = dir + FILE_SEPARATOR;
		 String jar1Name = ""TestRegisterRemoteJarGlobbing1.jar"";
		 String jar2Name = ""TestRegisterRemoteJarGlobbing2.jar"";
		 FileSystem fs = cluster.getFileSystem();
		 createFakeJarFile(jarLocation, jar1Name, fs);
		 createFakeJarFile(jarLocation, jar2Name, fs);
		 String absPath = fs.getFileStatus(new Path(jarLocation)).getPath().toString();
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerJar(absPath + FILE_SEPARATOR + ""TestRegister{
		Remote}
		Jar*.jar"");
		 verifyStringContained(pig.getPigContext().extraJars, jar1Name, true);
		 verifyStringContained(pig.getPigContext().extraJars, jar2Name, true);
		 assertTrue(fs.delete(new Path(jarLocation), true));
	 }
	 public void testDescribeLoad() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""a"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""field1: int,field2: float,field3: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeFilter() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = filter a by field1 > 10;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""field1: int,field2: float,field3: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeDistinct() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = distinct a ;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""field1: int,field2: float,field3: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeSort() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = order a by * desc;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""field1: int,field2: float,field3: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeLimit() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = limit a 10;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""field1: int,field2: float,field3: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeForeach() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = foreach a generate field1 + 10;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = new Schema(new Schema.FieldSchema(null, DataType.INTEGER));
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeForeachFail() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = foreach a generate field1 + 10;
		"") ;
		 try {
			 pig.dumpSchema(""c"") ;
			 fail(""Error expected"");
		 }
		 catch (Exception e) {
			 assertTrue(e.getMessage().contains(""Unable to describe schema for alias c""));
		 }
	 }
	 public void testDescribeForeachNoSchema() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' ;
		"") ;
		 pig.registerQuery(""b = foreach a generate *;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 assertNull(dumpedSchema);
	 }
	 public void testDescribeCogroup() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = load 'b' as (field4, field5: double, field6: chararray );
		"") ;
		 pig.registerQuery(""c = cogroup a by field1, b by field4;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""c"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""group:int,a:{
		(field1:int,field2:float,field3:chararray)}
		,b:{
		(field4:bytearray,field5:double,field6:chararray)}
		"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeCross() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = load 'b' as (field4, field5: double, field6: chararray );
		"") ;
		 pig.registerQuery(""c = cross a, b;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""c"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""a::field1: int,a::field2: float,a::field3: chararray,b::field4: bytearray,b::field5: double,b::field6: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeJoin() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = load 'b' as (field4, field5: double, field6: chararray );
		"") ;
		 pig.registerQuery(""c = join a by field1, b by field4;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""c"");
		 Schema expectedSchema = Utils.getSchemaFromString(""a::field1: int,a::field2: float,a::field3: chararray,b::field4: bytearray,b::field5: double,b::field6: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeUnion() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: float, field3: chararray );
		"") ;
		 pig.registerQuery(""b = load 'b' as (field4, field5: double, field6: chararray );
		"") ;
		 pig.registerQuery(""c = union a, b;
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""c"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""field1: int,field2: double,field3: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeTuple2Elem() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int, field2: int, field3: int );
		"") ;
		 pig.registerQuery(""b = foreach a generate field1, (field2, field3);
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 assertTrue(dumpedSchema.getField(0).type==DataType.INTEGER);
		 assertTrue(dumpedSchema.getField(1).type==DataType.TUPLE);
	 }
	 public void testDescribeComplex() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (site: chararray, count: int, itemCounts: bag {
		 itemCountsTuple: tuple (type: chararray, typeCount: int, f: float, m: map[]) }
		 ) ;
		"") ;
		 pig.registerQuery(""b = foreach a generate site, count, FLATTEN(itemCounts);
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = Utils.getSchemaFromString( ""site: chararray,count: int,"" + ""itemCounts::type: chararray,itemCounts::typeCount: int,"" + ""itemCounts::f: float,itemCounts::m: map[ ]"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testDescribeAsClause() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (field1: int);
		"");
		 pig.registerQuery(""b = FOREACH a generate field1 as (new_field:chararray);
		"") ;
		 Schema dumpedSchema = pig.dumpSchema(""b"") ;
		 Schema expectedSchema = Utils.getSchemaFromString(""new_field: chararray"");
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 private void registerScalarScript(boolean useScalar, String expectedSchemaStr) throws IOException {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""A = load 'adata' AS (a: int, b: int);
		"");
		 pig.registerQuery(""C = FOREACH A GENERATE *;
		"");
		 String overrideScalar = useScalar ? ""C = FILTER A BY b % 2 == 0;
		 "" : """";
		 pig.registerQuery(""B = FOREACH (GROUP A BY a) {
			 "" + overrideScalar + ""D = FILTER A BY b % 2 == 1;
			"" + ""GENERATE group AS a, A.b AS every, C.b AS even, D.b AS odd;
		"" + ""}
		;
		"");
		 Schema dumpedSchema = pig.dumpSchema(""B"");
		 Schema expectedSchema = Utils.getSchemaFromString( expectedSchemaStr);
		 assertEquals(expectedSchema, dumpedSchema);
	 }
	 public void testScalarPrecedence() throws Throwable {
		 registerScalarScript(true, ""a: int,every: {
		(b: int)}
		,even: {
		(b: int)}
		,odd: {
		(b: int)}
		"");
	 }
	 public void testScalarResolution() throws Throwable {
		 registerScalarScript(false, ""a: int,every: {
		(b: int)}
		,even: int,odd: {
		(b: int)}
		"");
	 }
	 public void testExplainXmlComplex() throws Throwable {
		 String execType = cluster.getExecType().toString().toLowerCase();
		 Assume.assumeTrue(""Skip this test for TEZ"", Util.isMapredExecType(cluster.getExecType()) || Util.isSparkExecType(cluster.getExecType()));
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a' as (site: chararray, count: int, itemCounts: bag {
		 itemCountsTuple: tuple (type: chararray, typeCount: int, f: float, m: map[]) }
		 ) ;
		"") ;
		 pig.registerQuery(""b = foreach a generate site, count, FLATTEN(itemCounts);
		"") ;
		 pig.registerQuery(""c = group b by site;
		"");
		 pig.registerQuery(""d = foreach c generate FLATTEN($1);
		"");
		 pig.registerQuery(""e = group d by $2;
		"");
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 PrintStream ps = new PrintStream(baos);
		 pig.explain(""e"", ""xml"", true, false, ps, ps, null, null);
		 ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
		 DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		 DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		 Document doc = dBuilder.parse(bais);
		 NodeList logicalPlan = doc.getElementsByTagName(""logicalPlan"");
		 assertEquals(1, logicalPlan.getLength());
		 assertTrue(logicalPlan.item(0).getTextContent().contains(""Not Supported""));
		 NodeList physicalPlan = doc.getElementsByTagName(""physicalPlan"");
		 assertEquals(1, physicalPlan.getLength());
		 assertTrue(physicalPlan.item(0).getTextContent().contains(""Not Supported""));
		 if (execType.equals(ExecType.MAPREDUCE.name().toLowerCase())){
			 verifyExplainXmlComplexMR(doc);
		 }
		 else if (execType.equals(MiniGenericCluster.EXECTYPE_SPARK)){
			 verifyExplainXmlComplexSpark(doc);
		 }
	 }
	 private void verifyExplainXmlComplexSpark(Document doc) {
		 NodeList stores = doc.getElementsByTagName(""POStore"");
		 assertEquals(1, stores.getLength());
		 NodeList groups = doc.getElementsByTagName(""POJoinGroupSpark"");
		 assertEquals(2, groups.getLength());
		 Node innerGroup = groups.item(1);
		 NodeList groupChildren = innerGroup.getChildNodes();
		 int foreachCount = 0;
		 int castCount = 0;
		 int loadCount = 0;
		 for (int i = 0;
		 i < groupChildren.getLength();
		 i++) {
			 Node node = groupChildren.item(i);
			 if (node.getNodeName().equals(""POForEach"")){
				 ++foreachCount;
				 NodeList foreachNodes = node.getChildNodes();
				 for (int j = 0;
				 j < foreachNodes.getLength();
				 j++) {
					 Node innerNode = foreachNodes.item(j);
					 if (innerNode.getNodeName().equals(""alias"")){
						 assertEquals(""b"",innerNode.getTextContent());
					 }
					else if (innerNode.getNodeName().equals(""POCast"")){
						 ++castCount;
					 }
					else if (innerNode.getNodeName().equals(""POLoad"")) {
						 ++loadCount;
					 }
				 }
			 }
		 }
		 assertEquals(1,foreachCount);
		 assertEquals(3,castCount);
		 assertEquals(1,loadCount);
	 }
	 private void verifyExplainXmlComplexMR(Document doc) {
		 NodeList loads = doc.getElementsByTagName(""POLoad"");
		 assertEquals(2, loads.getLength());
		 boolean sawTempLoad = false;
		 boolean sawNonTempLoad = false;
		 for (int i = 0;
		 i < loads.getLength();
		 i++) {
			 Boolean isTempLoad = null;
			 boolean hasAlias = false;
			 Node poLoad = loads.item(i);
			 NodeList children = poLoad.getChildNodes();
			 for (int j = 0;
			 j < children.getLength();
			 j++) {
				 Node child = children.item(j);
				 if (child.getNodeName().equals(""alias"")) {
					 hasAlias = true;
				 }
				 if (child.getNodeName().equals(""isTmpLoad"")) {
					 if (child.getTextContent().equals(""false"")) {
						 isTempLoad = false;
					 }
					 else if (child.getTextContent().equals(""true"")) {
						 isTempLoad = true;
					 }
				 }
			 }
			 if (isTempLoad == null) {
				 fail(""POLoad elements should have isTmpLoad child node."");
			 }
			 else if (isTempLoad && hasAlias) {
				 fail(""Temp loads should not have aliases"");
			 }
			 else if (!isTempLoad && !hasAlias) {
				 fail(""Non temporary loads should be associated with alias."");
			 }
			 sawTempLoad = sawTempLoad || isTempLoad;
			 sawNonTempLoad = sawNonTempLoad || !isTempLoad;
		 }
		 assertTrue(sawTempLoad && sawNonTempLoad);
	 }
	 public void testRegisterRemoteScript() throws Throwable {
		 String scriptName = ""script.py"";
		 File scriptFile = File.createTempFile(""tmp"", """");
		 PrintWriter pw = new PrintWriter(new FileWriter(scriptFile));
		 pw.println(""\ndef helloworld():\n return 'Hello, World'"");
		 pw.close();
		 FileSystem fs = cluster.getFileSystem();
		 fs.copyFromLocalFile(new Path(scriptFile.getAbsolutePath()), new Path(scriptName));
		 String absPath = fs.getFileStatus(new Path(scriptName)).getPath().toString();
		 Util.createInputFile(cluster, ""testRegisterRemoteScript_input"", new String[]{
		""1"", ""2""}
		);
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerCode(absPath, ""jython"", ""pig"");
		 pig.registerQuery(""a = load 'testRegisterRemoteScript_input';
		"");
		 pig.registerQuery(""b = foreach a generate pig.helloworld($0);
		"");
		 Iterator<Tuple> iter = pig.openIterator(""b"");
		 assertTrue(iter.hasNext());
		 Tuple t = iter.next();
		 assertTrue(t.size() > 0);
		 assertEquals(""Hello, World"", t.get(0));
		 assertTrue(iter.hasNext());
		 t = iter.next();
		 assertTrue(t.size() > 0);
		 assertEquals(""Hello, World"", t.get(0));
		 assertFalse(iter.hasNext());
	 }
	 public void testPigProperties() throws Throwable {
		 File propertyFile = new File(tempDir, ""pig.properties"");
		 propertyFile.deleteOnExit();
		 TestPigServer.registerNewResource(propertyFile.getAbsolutePath());
		 File cliPropertyFile = new File(""commandLine_pig.properties"");
		 cliPropertyFile.deleteOnExit();
		 TestPigServer.registerNewResource(cliPropertyFile.getAbsolutePath());
		 Properties properties = PropertiesUtil.loadDefaultProperties();
		 assertEquals(""40000000"", properties.getProperty(""pig.spill.gc.activation.size""));
		 assertNull(properties.getProperty(""test123""));
		 PrintWriter out = new PrintWriter(new FileWriter(propertyFile));
		 out.println(""test123=properties"");
		 out.close();
		 properties = PropertiesUtil.loadDefaultProperties();
		 assertEquals(""properties"", properties.getProperty(""test123""));
		 out = new PrintWriter(new FileWriter(cliPropertyFile));
		 out.println(""test123=cli_properties"");
		 out.close();
		 properties = PropertiesUtil.loadDefaultProperties();
		 PropertiesUtil.loadPropertiesFromFile(properties, ""commandLine_pig.properties"");
		 assertEquals(""cli_properties"", properties.getProperty(""test123""));
		 propertyFile.delete();
		 cliPropertyFile.delete();
	 }
	 public void testPigTempDir() throws Throwable {
		 Properties properties = PropertiesUtil.loadDefaultProperties();
		 File pigTempDir = new File(tempDir, FILE_SEPARATOR + ""tmp"" + FILE_SEPARATOR + ""test"");
		 properties.put(""pig.temp.dir"", pigTempDir.getPath());
		 PigContext pigContext=new PigContext(ExecType.LOCAL, properties);
		 pigContext.connect();
		 FileLocalizer.setInitialized(false);
		 String tempPath= FileLocalizer.getTemporaryPath(pigContext).toString();
		 Path path = new Path(tempPath);
		 assertTrue(tempPath.startsWith(pigTempDir.toURI().toString()));
		 FileSystem fs = FileSystem.get(path.toUri(), ConfigurationUtil.toConfiguration(pigContext.getProperties()));
		 FileStatus status = fs.getFileStatus(path.getParent());
		 assertEquals(""rwx------"", status.getPermission().toString());
		 pigTempDir.delete();
		 FileLocalizer.setInitialized(false);
	 }
	 public void testUniquePigTempDir() throws Throwable {
		 Properties properties = PropertiesUtil.loadDefaultProperties();
		 File pigTempDir = new File(tempDir, FILE_SEPARATOR + ""tmp"" + FILE_SEPARATOR + ""test"");
		 properties.put(""pig.temp.dir"", pigTempDir.getPath());
		 PigContext pigContext = new PigContext(ExecType.LOCAL, properties);
		 pigContext.connect();
		 FileLocalizer.setInitialized(false);
		 Random r = new Random(5);
		 FileLocalizer.setR(r);
		 String tempPath1 = FileLocalizer.getTemporaryPath(pigContext).toString();
		 FileLocalizer.setInitialized(false);
		 r = new Random(5);
		 FileLocalizer.setR(r);
		 String tempPath2 = FileLocalizer.getTemporaryPath(pigContext).toString();
		 assertFalse(tempPath1.toString().equals(tempPath2.toString()));
		 pigTempDir.delete();
		 FileLocalizer.setInitialized(false);
	 }
	 public void testDescribeForEachFlatten() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.registerQuery(""a = load 'a';
		"") ;
		 pig.registerQuery(""b = group a by $0;
		"") ;
		 pig.registerQuery(""c = foreach b generate flatten(a);
		"") ;
		 Schema s = pig.dumpSchema(""c"") ;
		 assertNull(s);
	 }
	 public void test1() throws Throwable {
		 PigServer pig = new PigServer(cluster.getExecType(), properties);
		 pig.setValidateEachStatement(true);
		 pig.registerQuery(""A = load 'x' as (u, v);
		"") ;
		 try {
			 pig.registerQuery(""B = foreach A generate $2;
			"") ;
			 fail(""Query is supposed to fail."");
		 }
		 catch(FrontendException ex) {
			 String msg = ""Out of bound access. "" + ""Trying to access non-existent column: 2"";
			 Util.checkMessageInException(ex, msg);
		 }
	 }
	 public void testDefaultPigProperties() throws Throwable {
		 PigServer pigServer = new PigServer(cluster.getExecType());
		 Properties properties = pigServer.getPigContext().getProperties();
		 assertEquals(""999"", properties.getProperty(""pig.exec.reducers.max""));
		 assertEquals(""true"", properties.getProperty(""aggregate.warning""));
		 assertEquals(""true"", properties.getProperty(PigConfiguration.PIG_OPT_MULTIQUERY));
		 assertEquals(""false"", properties.getProperty(""stop.on.failure""));
		 File propertyFile = new File(tempDir, ""pig.properties"");
		 properties = PropertiesUtil.loadDefaultProperties();
		 assertEquals(""999"", properties.getProperty(""pig.exec.reducers.max""));
		 assertEquals(""true"", properties.getProperty(""aggregate.warning""));
		 assertEquals(""true"", properties.getProperty(PigConfiguration.PIG_OPT_MULTIQUERY));
		 assertEquals(""false"", properties.getProperty(""stop.on.failure""));
		 PrintWriter out = new PrintWriter(new FileWriter(propertyFile));
		 out.println(""aggregate.warning=false"");
		 out.println(""opt.multiquery=false"");
		 out.println(""stop.on.failure=true"");
		 out.close();
		 properties = PropertiesUtil.loadDefaultProperties();
		 assertEquals(""false"", properties.getProperty(""aggregate.warning""));
		 assertEquals(""false"", properties.getProperty(PigConfiguration.PIG_OPT_MULTIQUERY));
		 assertEquals(""true"", properties.getProperty(""stop.on.failure""));
		 propertyFile.delete();
	 }
	 public void testRegisterJarRemoteScript() throws Throwable {
		 if (Util.WINDOWS) {
			 properties.setProperty(""pig.jars.relative.to.dfs"", ""true"");
			 String jarName = JarManager.findContainingJar(org.codehaus.jackson.JsonParser.class);
			 PigServer pig = new PigServer(cluster.getExecType(), properties);
			 pig.registerJar(jarName);
		 }
	 }
}",1,0,0,0
"public static final class Builder {
	 protected ResultTypeConfig target;
	 public Builder(String name, String className) {
		 target = new ResultTypeConfig(name, className);
	 }
	 public Builder(ResultTypeConfig orig) {
		 target = new ResultTypeConfig(orig);
	 }
	 public Builder name(String name) {
		 target.name = name;
		 return this;
	 }
	 public Builder className(String name) {
		 target.className = name;
		 return this;
	 }
	 public Builder addParam(String name, String value) {
		 target.params.put(name, value);
		 return this;
	 }
	 public Builder addParams(Map<String,String> params) {
		 target.params.putAll(params);
		 return this;
	 }
	 public Builder defaultResultParam(String defaultResultParam) {
		 target.defaultResultParam = defaultResultParam;
		 return this;
	 }
	 public Builder location(Location loc) {
		 target.location = loc;
		 return this;
	 }
	 public ResultTypeConfig build() {
		 ResultTypeConfig result = target;
		 target = new ResultTypeConfig(target);
		 return result;
	 }
 }",0,0,0,0
"public class PhysicalConstants extends Object {
	public static final PhysicalConstants physicalConstants = new PhysicalConstants();
	public static final double pi = Math.PI;
	 public static final double twopi = 2*pi;
	public static final double halfpi = pi/2;
	public static final double pi2 = pi*pi;
	public static final double Avogadro = 6.0221367e+23/Units.mole;
	public static final double c_light = 2.99792458e+8 * Units.m/Units.s;
	public static final double c_squared = c_light * c_light;
	public static final double h_Planck = 6.6260755e-34 * Units.joule*Units.s;
	public static final double hbar_Planck = h_Planck/twopi;
	public static final double hbarc = hbar_Planck * c_light;
	public static final double hbarc_squared = hbarc * hbarc;
	public static final double electron_charge = - Units.eplus;
	 public static final double e_squared = Units.eplus * Units.eplus;
	public static final double electron_mass_c2 = 0.51099906 * Units.MeV;
	public static final double proton_mass_c2 = 938.27231 * Units.MeV;
	public static final double neutron_mass_c2 = 939.56563 * Units.MeV;
	public static final double amu_c2 = 931.49432 * Units.MeV;
	public static final double amu = amu_c2/c_squared;
	public static final double mu0 = 4*pi*1.e-7 * Units.henry/Units.m;
	public static final double epsilon0 = 1./(c_squared*mu0);
	public static final double elm_coupling = e_squared/(4*pi*epsilon0);
	public static final double fine_structure_const = elm_coupling/hbarc;
	public static final double classic_electr_radius = elm_coupling/electron_mass_c2;
	public static final double electron_Compton_length = hbarc/electron_mass_c2;
	public static final double Bohr_radius = electron_Compton_length/fine_structure_const;
	public static final double alpha_rcl2 = fine_structure_constpublic static final double twopi_mc2_rcl2 = twopi*electron_mass_c2public static final double k_Boltzmann = 8.617385e-11 * Units.MeV/Units.kelvin;
	public static final double STP_Temperature = 273.15*Units.kelvin;
	public static final double STP_Pressure = 1.*Units.atmosphere;
	public static final double kGasThreshold = 10.*Units.mg/Units.cm3;
	public static final double universe_mean_density = 1.e-25*Units.g/Units.cm3;
	protected PhysicalConstants() {
	}
}",0,0,0,0
"public boolean checkLicenseHeader(File file){
	Revision revision = null;
	try{
		String header = extractLicenseHeader(file, 0, 16);
		revision = Diff.diff(getLicenseHeader().split(LINE_ENDING), header.split(LINE_ENDING));
	}
	catch (Exception e){
		Assert.fail(e.getMessage());
	}
	return revision.size() == 0;
}",0,0,0,0
"protected void translateCore(final ITranslationEnvironment environment, final IInstruction instruction, final List<ReilInstruction> instructions) {
	 final IOperandTreeNode registerOperand1 = instruction.getOperands().get(0).getRootNode().getChildren().get(0);
	 final IOperandTreeNode registerOperand2 = instruction.getOperands().get(1).getRootNode().getChildren().get(0);
	 final IOperandTreeNode registerOperand3 = instruction.getOperands().get(2).getRootNode().getChildren().get(0);
	 final IOperandTreeNode registerOperand4 = instruction.getOperands().get(3).getRootNode().getChildren().get(0);
	 final String targetRegister = (registerOperand1.getValue());
	 final String sourceRegister1 = (registerOperand2.getValue());
	 final String sourceRegister2 = (registerOperand3.getValue());
	 final String sourceRegister3 = (registerOperand4.getValue());
	 final OperandSize bt = OperandSize.BYTE;
	 final OperandSize dw = OperandSize.DWORD;
	 final OperandSize wd = OperandSize.WORD;
	 long baseOffset = ReilHelpers.nextReilAddress(instruction, instructions);
	 final String operand2 = environment.getNextVariableString();
	 final String tmpRotate1 = environment.getNextVariableString();
	 final String tmpRotate2 = environment.getNextVariableString();
	 final String diffOfProducts = environment.getNextVariableString();
	 final String operand2from15to0 = environment.getNextVariableString();
	 final String operand2from31to16 = environment.getNextVariableString();
	 final String registerRmfrom15to0 = environment.getNextVariableString();
	 final String registerRmfrom31to16 = environment.getNextVariableString();
	 final String tmpVar1 = environment.getNextVariableString();
	 final String tmpVar2 = environment.getNextVariableString();
	 final String tmpVar3 = environment.getNextVariableString();
	 final String trueDiffOfProducts = environment.getNextVariableString();
	 final String product1 = environment.getNextVariableString();
	 final String product2 = environment.getNextVariableString();
	 if (instruction.getMnemonic().contains(""X"")) {
		 instructions.add(ReilHelpers.createBsh(baseOffset++, dw, sourceRegister2, bt, String.valueOf(-16), dw, tmpRotate1));
		 instructions.add(ReilHelpers.createBsh(baseOffset++, dw, sourceRegister2, bt, String.valueOf(16), dw, tmpRotate2));
		 instructions.add(ReilHelpers.createOr(baseOffset++, dw, tmpRotate1, dw, tmpRotate2, dw, operand2));
		 instructions.add(ReilHelpers.createAnd(baseOffset++, dw, operand2, dw, String.valueOf(0xFFFFFFFFL), dw, operand2));
	 }
	 else {
		 instructions.add(ReilHelpers.createStr(baseOffset++, dw, sourceRegister2, dw, operand2));
	 }
	 instructions.add(ReilHelpers.createAnd(baseOffset++, dw, operand2, dw, String.valueOf(0xFFFFL), dw, operand2from15to0));
	 instructions.add(ReilHelpers.createAnd(baseOffset++, dw, sourceRegister1, dw, String.valueOf(0xFFFFL), dw, registerRmfrom15to0));
	 Helpers.signedMul(baseOffset, environment, instruction, instructions, wd, operand2from15to0, wd, registerRmfrom15to0, dw, product1);
	 baseOffset = ReilHelpers.nextReilAddress(instruction, instructions);
	 instructions.add(ReilHelpers.createBsh(baseOffset++, dw, operand2, dw, String.valueOf(-16L), dw, tmpVar1));
	 instructions.add(ReilHelpers.createAnd(baseOffset++, dw, tmpVar1, dw, String.valueOf(0xFFFFL), dw, operand2from31to16));
	 instructions.add(ReilHelpers.createBsh(baseOffset++, dw, sourceRegister1, dw, String.valueOf(-16L), dw, tmpVar2));
	 instructions.add(ReilHelpers.createAnd(baseOffset++, dw, tmpVar2, dw, String.valueOf(0xFFFFL), dw, registerRmfrom31to16));
	 Helpers.signedMul(baseOffset, environment, instruction, instructions, wd, operand2from31to16, wd, registerRmfrom31to16, dw, product2);
	 baseOffset = ReilHelpers.nextReilAddress(instruction, instructions);
	 Helpers.signedSub(baseOffset, environment, instruction, instructions, product2, product1, diffOfProducts, trueDiffOfProducts);
	 baseOffset = ReilHelpers.nextReilAddress(instruction, instructions);
	 instructions.add(ReilHelpers.createAdd(baseOffset++, dw, sourceRegister3, dw, diffOfProducts, dw, tmpVar3));
	 instructions.add(ReilHelpers.createAnd(baseOffset++, dw, tmpVar3, dw, String.valueOf(0xFFFFFFFFL), dw, targetRegister));
	 Helpers.overflowCondition(baseOffset, environment, instruction, instructions, tmpVar3);
 }",0,0,1,0
"public class OrganizationConfig {
	 private List membershipType ;
	 private List group ;
	 private List user ;
	 public OrganizationConfig() {
		 membershipType = new ArrayList(5) ;
		 group = new ArrayList(5) ;
		 user = new ArrayList(5) ;
	 }
	 public List getGroup() {
		 return group;
	 }
	 public void setGroup(List group) {
		 this.group = group;
	 }
	 public List getMembershipType() {
		 return membershipType;
	 }
	 public void setMembershipType(List membershipType) {
		 this.membershipType = membershipType;
	}
	 public List getUser() {
		 return user;
	 }
	 public void setUser(List user) {
		 this.user = user;
	 }
	 static public class MembershipType {
		 private String type ;
		 private String description ;
		 public String getDescription() {
			 return description;
		 }
		 public void setDescription(String description) {
			 this.description = description;
		 }
		 public String getType() {
			 return type;
		 }
		 public void setType(String type) {
			 this.type = type;
		 }
	 }
	 static public class Group {
		 private String name ;
		 private String type ;
		 private String description ;
		 private String parentId ;
		 public String getDescription() {
			 return description;
		 }
		 public void setDescription(String description) {
			 this.description = description;
		 }
		 public String getName() {
			 return name;
		 }
		 public void setName(String name) {
			 this.name = name;
		 }
		 public String getParentId() {
			 return parentId;
		 }
		 public void setParentId(String parentId) {
			 this.parentId = parentId;
		 }
		 public String getType() {
			 return type;
		 }
		 public void setType(String type) {
			 this.type = type;
		 }
	 }
	 static public class User {
		 private String userName ;
		 private String password ;
		 private String firstName ;
		 private String lastName ;
		 private String email ;
		 private List groups ;
		 public User() {
			 groups = new ArrayList(3) ;
		 }
		 public String getEmail() {
			 return email;
		 }
		 public void setEmail(String email) {
			 this.email = email;
		 }
		 public String getFirstName() {
			 return firstName;
		 }
		 public void setFirstName(String firstName) {
			 this.firstName = firstName;
		 }
		 public String getLastName() {
			 return lastName;
		 }
		 public void setLastName(String lastName) {
			 this.lastName = lastName;
		 }
		 public String getPassword() {
			 return password;
		 }
		 public void setPassword(String password) {
			 this.password = password;
		 }
		 public List getGroups() {
			 return groups;
		 }
		 public void setGroups(List groups) {
			 this.groups = groups;
		 }
		 public String getUserName() {
			 return userName;
		 }
		 public void setUserName(String userName) {
			 this.userName = userName;
		 }
	 }
}",0,1,0,0
"private void writeObject(java.io.ObjectOutputStream s) throws IOException{
	IntKeyWeakReference ref = null;
	while (true){
		Reference temp=queue.poll();
		 ref = (IntKeyWeakReference)temp;
		if (ref==null){
			break;
		}
		directComponentRefs.remove(ref.uid);
	}
	s.defaultWriteObject();
	s.writeInt(directComponentRefs.size());
	Iterator<IntHashMap.Entry<ComponentAndInterface>> it = directComponentRefs.entrySet().iterator();
	while (it.hasNext()){
		IntHashMap.Entry<ComponentAndInterface> entry = it.next();
		s.writeInt(entry.getKey());
		ComponentAndInterface cai = entry.getValue();
		s.writeObject(cai.getComponent());
		s.writeUTF(cai.getInterfaceName());
	}
}",0,0,0,0
"public class XPathParser {
	 private final Map<String, String> prefixes = new HashMap<String, String>();
	 public XPathParser() {
	 }
	 public XPathParser(String prefix, String namespace) {
		 addPrefix(prefix, namespace);
	 }
	 public void addPrefix(String prefix, String namespace) {
		 prefixes.put(prefix, namespace);
	 }
	 public Matcher parse(String xpath) {
		 if (xpath.equals(""/text()"")) {
			 return TextMatcher.INSTANCE;
		 }
		 else if (xpath.equals(""/node()"")) {
			 return NodeMatcher.INSTANCE;
		 }
		 else if (xpath.equals(""/descendant::node()"") || xpath.equals(""/descendant:node()"")) {
			 return new CompositeMatcher( TextMatcher.INSTANCE, new ChildMatcher(new SubtreeMatcher(NodeMatcher.INSTANCE)));
		 }
		 else if (xpath.equals(""/@*"")) {
			 return AttributeMatcher.INSTANCE;
		 }
		 else if (xpath.length() == 0) {
			 return ElementMatcher.INSTANCE;
		 }
		 else if (xpath.startsWith(""/@"")) {
			 String name = xpath.substring(2);
			 String prefix = null;
			 int colon = name.indexOf(':');
			 if (colon != -1) {
				 prefix = name.substring(0, colon);
				 name = name.substring(colon + 1);
			 }
			 if (prefixes.containsKey(prefix)) {
				 return new NamedAttributeMatcher(prefixes.get(prefix), name);
			 }
			 else {
				 return Matcher.FAIL;
			 }
		 }
		 else if (xpath.startsWith(""/*"")) {
			 return new ChildMatcher(parse(xpath.substring(2)));
		 }
		 else if (xpath.startsWith("" return Matcher.FAIL;
	 }
	 else if (xpath.startsWith("" return new SubtreeMatcher(parse(xpath.substring(1)));
 }
 else if (xpath.startsWith(""/"")) {
	 int slash = xpath.indexOf('/', 1);
	 if (slash == -1) {
		 slash = xpath.length();
	 }
	 String name = xpath.substring(1, slash);
	 String prefix = null;
	 int colon = name.indexOf(':');
	 if (colon != -1) {
		 prefix = name.substring(0, colon);
		 name = name.substring(colon + 1);
	 }
	 if (prefixes.containsKey(prefix)) {
		 return new NamedElementMatcher( prefixes.get(prefix), name, parse(xpath.substring(slash)));
	 }
	 else {
		 return Matcher.FAIL;
	 }
 }
 else {
	 return Matcher.FAIL;
 }
 }
}",1,0,0,0
"public class ServiceComponentHostEventWrapper {
	 private ServiceComponentHostEvent event = null;
	 private String eventJson = null;
	 public ServiceComponentHostEventWrapper(ServiceComponentHostEvent event) {
		 this.event = event;
	 }
	 public ServiceComponentHostEventWrapper(String eventJson) {
		 this.eventJson = eventJson;
	 }
	 public ServiceComponentHostEvent getEvent() {
		 if (event != null) {
			 return event;
		 }
		 else if (eventJson != null) {
			 try {
				 event = StageUtils.fromJson(eventJson, ServiceComponentHostEvent.class);
				 return event;
			 }
			 catch (IOException e) {
				 throw new RuntimeException(""Illegal Json for event"", e);
			 }
		 }
		 return null;
	 }
	 public String getEventJson() {
		 if (eventJson != null) {
			 return eventJson;
		 }
		 else if (event != null) {
			 try {
				 eventJson = StageUtils.jaxbToString(event);
				 return eventJson;
			 }
			 catch (JAXBException | IOException e) {
				 throw new RuntimeException(""Couldn't get json"", e);
			 }
		 }
		 else {
			 return null;
		 }
	 }
	 public String toString() {
		 if (event != null) {
			 return event.toString();
		 }
		 else if (eventJson != null) {
			 return eventJson;
		 }
		 return ""null"";
	 }
}",0,0,0,0
"public class _ConfigurationSettingsServiceSoapService extends SOAP11Service implements _ConfigurationSettingsServiceSoap{
	 private static final QName PORT_QNAME = new QName( ""http: ""ConfigurationSettingsServiceSoapService"");
	 private static final String ENDPOINT_PATH = ""/tfs/DefaultCollection/WorkItemTracking/v1.0/ConfigurationSettingsService.asmx"";
	 public _ConfigurationSettingsServiceSoapService( final URI endpoint, final QName port) {
		 super(endpoint, port);
	 }
	 public _ConfigurationSettingsServiceSoapService( final HttpClient client, URI endpoint, QName port) {
		 super(client, endpoint, port);
	 }
	 public static QName getPortQName() {
		 return _ConfigurationSettingsServiceSoapService.PORT_QNAME;
	 }
	 public static String getEndpointPath() {
		 return _ConfigurationSettingsServiceSoapService.ENDPOINT_PATH;
	 }
	 public String getWorkitemTrackingVersion() throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersion requestData = new _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersion();
		 final SOAPRequest request = createSOAPRequest( ""GetWorkitemTrackingVersion"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""GetWorkitemTrackingVersion"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersionResponse responseData = new _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersionResponse();
		 executeSOAPRequest( request, ""GetWorkitemTrackingVersionResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
		 return responseData.getGetWorkitemTrackingVersionResult();
	 }
	 public long getMaxAttachmentSize() throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_GetMaxAttachmentSize requestData = new _ConfigurationSettingsServiceSoap_GetMaxAttachmentSize();
		 final SOAPRequest request = createSOAPRequest( ""GetMaxAttachmentSize"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""GetMaxAttachmentSize"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_GetMaxAttachmentSizeResponse responseData = new _ConfigurationSettingsServiceSoap_GetMaxAttachmentSizeResponse();
		 executeSOAPRequest( request, ""GetMaxAttachmentSizeResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
		 return responseData.getGetMaxAttachmentSizeResult();
	 }
	 public void setMaxAttachmentSize(final long maxSize) throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_SetMaxAttachmentSize requestData = new _ConfigurationSettingsServiceSoap_SetMaxAttachmentSize( maxSize);
		 final SOAPRequest request = createSOAPRequest( ""SetMaxAttachmentSize"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""SetMaxAttachmentSize"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_SetMaxAttachmentSizeResponse responseData = new _ConfigurationSettingsServiceSoap_SetMaxAttachmentSizeResponse();
		 executeSOAPRequest( request, ""SetMaxAttachmentSizeResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
	 }
	 public boolean getInProcBuildCompletionNotificationAvailability() throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailability requestData = new _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailability();
		 final SOAPRequest request = createSOAPRequest( ""GetInProcBuildCompletionNotificationAvailability"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""GetInProcBuildCompletionNotificationAvailability"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailabilityResponse responseData = new _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailabilityResponse();
		 executeSOAPRequest( request, ""GetInProcBuildCompletionNotificationAvailabilityResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
		 return responseData.isGetInProcBuildCompletionNotificationAvailabilityResult();
	 }
	 public void setInProcBuildCompletionNotificationAvailability(final boolean isEnabled) throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailability requestData = new _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailability( isEnabled);
		 final SOAPRequest request = createSOAPRequest( ""SetInProcBuildCompletionNotificationAvailability"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""SetInProcBuildCompletionNotificationAvailability"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailabilityResponse responseData = new _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailabilityResponse();
		 executeSOAPRequest( request, ""SetInProcBuildCompletionNotificationAvailabilityResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
	 }
	 public int getMaxBuildListSize() throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_GetMaxBuildListSize requestData = new _ConfigurationSettingsServiceSoap_GetMaxBuildListSize();
		 final SOAPRequest request = createSOAPRequest( ""GetMaxBuildListSize"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""GetMaxBuildListSize"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_GetMaxBuildListSizeResponse responseData = new _ConfigurationSettingsServiceSoap_GetMaxBuildListSizeResponse();
		 executeSOAPRequest( request, ""GetMaxBuildListSizeResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
		 return responseData.getGetMaxBuildListSizeResult();
	 }
	 public void setMaxBuildListSize(final int maxBuildListSize) throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_SetMaxBuildListSize requestData = new _ConfigurationSettingsServiceSoap_SetMaxBuildListSize( maxBuildListSize);
		 final SOAPRequest request = createSOAPRequest( ""SetMaxBuildListSize"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""SetMaxBuildListSize"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_SetMaxBuildListSizeResponse responseData = new _ConfigurationSettingsServiceSoap_SetMaxBuildListSizeResponse();
		 executeSOAPRequest( request, ""SetMaxBuildListSizeResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
	 }
	 public int getWorkItemQueryTimeout() throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeout requestData = new _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeout();
		 final SOAPRequest request = createSOAPRequest( ""GetWorkItemQueryTimeout"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""GetWorkItemQueryTimeout"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeoutResponse responseData = new _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeoutResponse();
		 executeSOAPRequest( request, ""GetWorkItemQueryTimeoutResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
		 return responseData.getGetWorkItemQueryTimeoutResult();
	 }
	 public void setWorkItemQueryTimeout(final int workItemQueryTimeout) throws TransportException, SOAPFault {
		 final _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeout requestData = new _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeout( workItemQueryTimeout);
		 final SOAPRequest request = createSOAPRequest( ""SetWorkItemQueryTimeout"", new SOAPMethodRequestWriter() {
			 public void writeSOAPRequest( final XMLStreamWriter writer, final OutputStream out) throws XMLStreamException, IOException {
				 requestData.writeAsElement( writer, ""SetWorkItemQueryTimeout"");
			 }
		 }
		);
		 final _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeoutResponse responseData = new _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeoutResponse();
		 executeSOAPRequest( request, ""SetWorkItemQueryTimeoutResponse"", new SOAPMethodResponseReader() {
			 public void readSOAPResponse( final XMLStreamReader reader, final InputStream in) throws XMLStreamException, IOException {
				 responseData.readFromElement(reader);
			 }
		 }
		);
	 }
}",1,1,0,0
"public class DynamicCompositeType extends AbstractCompositeType{
	 private static final Logger logger = LoggerFactory.getLogger(DynamicCompositeType.class);
	 private final Map<Byte, AbstractType<?>> aliases;
	 private static final Map<Map<Byte, AbstractType<?>>, DynamicCompositeType> instances = new HashMap<Map<Byte, AbstractType<?>>, DynamicCompositeType>();
	 public static synchronized DynamicCompositeType getInstance(TypeParser parser) throws ConfigurationException {
		 return getInstance(parser.getAliasParameters());
	 }
	 public static synchronized DynamicCompositeType getInstance(Map<Byte, AbstractType<?>> aliases) {
		 DynamicCompositeType dct = instances.get(aliases);
		 if (dct == null) {
			 dct = new DynamicCompositeType(aliases);
			 instances.put(aliases, dct);
		 }
		 return dct;
	 }
	 private DynamicCompositeType(Map<Byte, AbstractType<?>> aliases) {
		 this.aliases = aliases;
	 }
	 private AbstractType<?> getComparator(ByteBuffer bb) {
		 try {
			 int header = getShortLength(bb);
			 if ((header & 0x8000) == 0) {
				 String name = ByteBufferUtil.string(getBytes(bb, header));
				 return TypeParser.parse(name);
			 }
			 else {
				 return aliases.get((byte)(header & 0xFF));
			 }
		 }
		 catch (CharacterCodingException e) {
			 throw new RuntimeException(e);
		 }
		 catch (ConfigurationException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 protected AbstractType<?> getNextComparator(int i, ByteBuffer bb) {
		 return getComparator(bb);
	 }
	 protected AbstractType<?> getNextComparator(int i, ByteBuffer bb1, ByteBuffer bb2) {
		 AbstractType<?> comp1 = getComparator(bb1);
		 AbstractType<?> comp2 = getComparator(bb2);
		 if (comp1 != comp2) {
			 int cmp = comp1.getClass().getSimpleName().compareTo(comp2.getClass().getSimpleName());
			 if (cmp != 0) return cmp < 0 ? FixedValueComparator.instance : ReversedType.getInstance(FixedValueComparator.instance);
			 cmp = comp1.getClass().getName().compareTo(comp2.getClass().getName());
			 if (cmp != 0) return cmp < 0 ? FixedValueComparator.instance : ReversedType.getInstance(FixedValueComparator.instance);
		 }
		 return comp1;
	 }
	 protected AbstractType<?> getAndAppendNextComparator(int i, ByteBuffer bb, StringBuilder sb) {
		 try {
			 int header = getShortLength(bb);
			 if ((header & 0x8000) == 0) {
				 String name = ByteBufferUtil.string(getBytes(bb, header));
				 sb.append(name).append(""@"");
				 return TypeParser.parse(name);
			 }
			 else {
				 sb.append((char)(header & 0xFF)).append(""@"");
				 return aliases.get((byte)(header & 0xFF));
			 }
		 }
		 catch (CharacterCodingException e) {
			 throw new RuntimeException(e);
		 }
		 catch (ConfigurationException e) {
			 throw new RuntimeException(e);
		 }
	 }
	 protected ParsedComparator parseNextComparator(int i, String part) {
		 return new DynamicParsedComparator(part);
	 }
	 protected AbstractType<?> validateNextComparator(int i, ByteBuffer bb) throws MarshalException {
		 AbstractType<?> comparator = null;
		 if (bb.remaining() < 2) throw new MarshalException(""Not enough bytes to header of the comparator part of component "" + i);
		 int header = getShortLength(bb);
		 if ((header & 0x8000) == 0) {
			 if (bb.remaining() < header) throw new MarshalException(""Not enough bytes to read comparator name of component "" + i);
			 ByteBuffer value = getBytes(bb, header);
			 try {
				 comparator = TypeParser.parse(ByteBufferUtil.string(value));
			 }
			 catch (Exception e) {
			 }
		 }
		 else {
			 comparator = aliases.get((byte)(header & 0xFF));
		 }
		 if (comparator == null) throw new MarshalException(""Cannot find comparator for component "" + i);
		 else return comparator;
	 }
	 public boolean isCompatibleWith(AbstractType<?> previous) {
		 if (this == previous) return true;
		 if (!(previous instanceof DynamicCompositeType)) return false;
		 DynamicCompositeType cp = (DynamicCompositeType)previous;
		 if (aliases.size() < cp.aliases.size()) return false;
		 for (Map.Entry<Byte, AbstractType<?>> entry : cp.aliases.entrySet()) {
			 AbstractType<?> tprev = entry.getValue();
			 AbstractType<?> tnew = aliases.get(entry.getKey());
			 if (tnew == null || tnew != tprev) return false;
		 }
		 return true;
	 }
	 private class DynamicParsedComparator implements ParsedComparator {
		 final AbstractType<?> type;
		 final boolean isAlias;
		 final String comparatorName;
		 final String remainingPart;
		 DynamicParsedComparator(String part) {
			 String[] splits = part.split(""@"");
			 if (splits.length != 2) throw new IllegalArgumentException(""Invalid component representation: "" + part);
			 comparatorName = splits[0];
			 remainingPart = splits[1];
			 try {
				 AbstractType<?> t = null;
				 if (comparatorName.length() == 1) {
					 t = aliases.get((byte)comparatorName.charAt(0));
				 }
				 isAlias = t != null;
				 if (!isAlias) {
					 t = TypeParser.parse(comparatorName);
				 }
				 type = t;
			 }
			 catch (ConfigurationException e) {
				 throw new IllegalArgumentException(e);
			 }
		 }
		 public AbstractType<?> getAbstractType() {
			 return type;
		 }
		 public String getRemainingPart() {
			 return remainingPart;
		 }
		 public int getComparatorSerializedSize() {
			 return isAlias ? 2 : 2 + ByteBufferUtil.bytes(comparatorName).remaining();
		 }
		 public void serializeComparator(ByteBuffer bb) {
			 int header = 0;
			 if (isAlias) header = 0x8000 | (((byte)comparatorName.charAt(0)) & 0xFF);
			 else header = comparatorName.length();
			 putShortLength(bb, header);
			 if (!isAlias) bb.put(ByteBufferUtil.bytes(comparatorName));
		 }
	 }
	 public String toString() {
		 return getClass().getName() + TypeParser.stringifyAliasesParameters(aliases);
	 }
	 private static class FixedValueComparator extends AbstractType<Void> {
		 public static final FixedValueComparator instance = new FixedValueComparator();
		 public int compare(ByteBuffer v1, ByteBuffer v2) {
			 return -1;
		 }
		 public Void compose(ByteBuffer bytes) {
			 throw new UnsupportedOperationException();
		 }
		 public ByteBuffer decompose(Void value) {
			 throw new UnsupportedOperationException();
		 }
		 public String getString(ByteBuffer bytes) {
			 throw new UnsupportedOperationException();
		 }
		 public ByteBuffer fromString(String str) {
			 throw new UnsupportedOperationException();
		 }
		 public void validate(ByteBuffer bytes) {
			 throw new UnsupportedOperationException();
		 }
	 }
}",0,0,0,0
"public String toString() {
	 if (isReference()) {
		 return getCheckedRef().toString();
	 }
	 return String.valueOf(getValue());
 }",0,0,0,0
"public String diagnoseCreationFailure(String componentName, String type) {
	 StringWriter errorText = new StringWriter();
	 PrintWriter out = new PrintWriter(errorText);
	 out.println(""Problem: failed to create "" + type + "" "" + componentName);
	 boolean lowlevel = false;
	 boolean jars = false;
	 boolean definitions = false;
	 boolean antTask;
	 String home = System.getProperty(Launcher.USER_HOMEDIR);
	 File libDir = new File(home, Launcher.USER_LIBDIR);
	 String antHomeLib;
	 boolean probablyIDE = false;
	 String anthome = System.getProperty(MagicNames.ANT_HOME);
	 if (anthome != null) {
		 File antHomeLibDir = new File(anthome, ""lib"");
		 antHomeLib = antHomeLibDir.getAbsolutePath();
	 }
	 else {
		 probablyIDE = true;
		 antHomeLib = ""ANT_HOME"" + File.separatorChar + ""lib"";
	 }
	 StringBuffer dirListingText = new StringBuffer();
	 final String tab = "" -"";
	 dirListingText.append(tab);
	 dirListingText.append(antHomeLib);
	 dirListingText.append('\n');
	 if (probablyIDE) {
		 dirListingText.append(tab);
		 dirListingText.append(""the IDE Ant configuration dialogs"");
	 }
	 else {
		 dirListingText.append(tab);
		 dirListingText.append(libDir);
		 dirListingText.append('\n');
		 dirListingText.append(tab);
		 dirListingText.append( ""a directory added on the command line with the -lib argument"");
	 }
	 String dirListing = dirListingText.toString();
	 AntTypeDefinition def = getDefinition(componentName);
	 if (def == null) {
		 printUnknownDefinition(out, componentName, dirListing);
		 definitions = true;
	 }
	 else {
		 final String classname = def.getClassName();
		 antTask = classname.startsWith(""org.apache.tools.ant."");
		 boolean optional = classname.startsWith(""org.apache.tools.ant.taskdefs.optional"");
		 optional |= classname.startsWith(""org.apache.tools.ant.types.optional"");
		 Class clazz = null;
		 try {
			 clazz = def.innerGetTypeClass();
		 }
		 catch (ClassNotFoundException e) {
			 jars = true;
			 if (!optional) {
				 definitions = true;
			 }
			 printClassNotFound(out, classname, optional, dirListing);
		 }
		 catch (NoClassDefFoundError ncdfe) {
			 jars = true;
			 printNotLoadDependentClass(out, optional, ncdfe, dirListing);
		 }
		 if (clazz != null) {
			 try {
				 def.innerCreateAndSet(clazz, project);
				 out.println(""The component could be instantiated."");
			 }
			 catch (NoSuchMethodException e) {
				 lowlevel = true;
				 out.println(""Cause: The class "" + classname + "" has no compatible constructor."");
			 }
			 catch (InstantiationException e) {
				 lowlevel = true;
				 out.println(""Cause: The class "" + classname + "" is abstract and cannot be instantiated."");
			 }
			 catch (IllegalAccessException e) {
				 lowlevel = true;
				 out.println(""Cause: The constructor for "" + classname + "" is private and cannot be invoked."");
			 }
			 catch (InvocationTargetException ex) {
				 lowlevel = true;
				 Throwable t = ex.getTargetException();
				 out.println(""Cause: The constructor threw the exception"");
				 out.println(t.toString());
				 t.printStackTrace(out);
			 }
			 catch (NoClassDefFoundError ncdfe) {
				 jars = true;
				 out.println(""Cause: A class needed by class "" + classname + "" cannot be found: "");
				 out.println("" "" + ncdfe.getMessage());
				 out.println(""Action: Determine what extra JAR files are"" + "" needed, and place them in:"");
				 out.println(dirListing);
			 }
		 }
		 out.println();
		 out.println(""Do not panic, this is a common problem."");
		 if (definitions) {
			 out.println(""It may just be a typographical error in the build file "" + ""or the task/type declaration."");
		 }
		 if (jars) {
			 out.println(""The commonest cause is a missing JAR."");
		 }
		 if (lowlevel) {
			 out.println(""This is quite a low level problem, which may need "" + ""consultation with the author of the task."");
			 if (antTask) {
				 out.println(""This may be the Ant team. Please file a "" + ""defect or contact the developer team."");
			 }
			 else {
				 out.println(""This does not appear to be a task bundled with Ant."");
				 out.println(""Please take it up with the supplier of the third-party "" + type + ""."");
				 out.println(""If you have written it yourself, you probably have a bug to fix."");
			 }
		 }
		 else {
			 out.println();
			 out.println(""This is not a bug;
			 it is a configuration problem"");
		 }
	 }
	 out.flush();
	 out.close();
	 return errorText.toString();
 }",0,0,1,0
"private SSLContext createSSLContext() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException, KeyManagementException, KeyStoreException {
	 String pkcs11Library = Settings.getProperty(""davmail.ssl.pkcs11Library"");
	 String clientKeystoreType = Settings.getProperty(""davmail.ssl.clientKeystoreType"");
	 if (clientKeystoreType == null || clientKeystoreType.length() == 0) {
		 clientKeystoreType = ""PKCS11"";
	 }
	 if (pkcs11Library != null && pkcs11Library.length() > 0 && ""PKCS11"".equals(clientKeystoreType)) {
		 StringBuilder pkcs11Buffer = new StringBuilder();
		 pkcs11Buffer.append(""name=DavMail\n"");
		 pkcs11Buffer.append(""library="").append(pkcs11Library).append('\n');
		 String pkcs11Config = Settings.getProperty(""davmail.ssl.pkcs11Config"");
		 if (pkcs11Config != null && pkcs11Config.length() > 0) {
			 pkcs11Buffer.append(pkcs11Config).append('\n');
		 }
		 SunPKCS11ProviderHandler.registerProvider(pkcs11Buffer.toString());
	 }
	 String algorithm = KeyManagerFactory.getDefaultAlgorithm();
	 if (""SunX509"".equals(algorithm)) {
		 algorithm = ""NewSunX509"";
	 }
	 else if (""IbmX509"".equals(algorithm)) {
		 algorithm = ""NewIbmX509"";
	 }
	 KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(algorithm);
	 ArrayList<KeyStore.Builder> keyStoreBuilders = new ArrayList<KeyStore.Builder>();
	 KeyStore.Builder scBuilder = KeyStore.Builder.newInstance(""PKCS11"", null, getProtectionParameter(null));
	 keyStoreBuilders.add(scBuilder);
	 String clientKeystoreFile = Settings.getProperty(""davmail.ssl.clientKeystoreFile"");
	 String clientKeystorePass = Settings.getProperty(""davmail.ssl.clientKeystorePass"");
	 if (clientKeystoreFile != null && clientKeystoreFile.length() > 0 && (""PKCS12"".equals(clientKeystoreType) || ""JKS"".equals(clientKeystoreType))) {
		 KeyStore.Builder fsBuilder = KeyStore.Builder.newInstance(clientKeystoreType, null, new File(clientKeystoreFile), getProtectionParameter(clientKeystorePass));
		 keyStoreBuilders.add(fsBuilder);
	 }
	 ManagerFactoryParameters keyStoreBuilderParameters = new KeyStoreBuilderParameters(keyStoreBuilders);
	 keyManagerFactory.init(keyStoreBuilderParameters);
	 KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();
	 for (int i = 0;
	 i < keyManagers.length;
	 i++) {
		 KeyManager keyManager = keyManagers[i];
		 if (keyManager instanceof X509KeyManager) {
			 keyManagers[i] = new DavMailX509KeyManager((X509KeyManager) keyManager);
		 }
	 }
	 SSLContext context = SSLContext.getInstance(""SSL"");
	 context.init(keyManagers, new TrustManager[]{
	new DavGatewayX509TrustManager()}
	, null);
	 return context;
 }",0,0,1,0
"NormalizeResultSetNode(ResultSetNode chldRes, ResultColumnList targetResultColumnList, Properties tableProperties, boolean forUpdate, ContextManager cm) throws StandardException{
	 super(chldRes, tableProperties, cm);
	 this.forUpdate = forUpdate;
	 ResultColumnList rcl = chldRes.getResultColumns();
	 ResultColumnList targetRCL = targetResultColumnList;
	ResultColumnList prRCList = rcl;
	 chldRes.setResultColumns(rcl.copyListAndObjects());
	prRCList.removeGeneratedGroupingColumns();
	 prRCList.removeOrderByColumns();
	 prRCList.genVirtualColumnNodes(chldRes, chldRes.getResultColumns());
	setResultColumns( prRCList );
	 if (chldRes.getReferencedTableMap() != null) {
		setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
	 }
	if (targetResultColumnList != null) {
		 int size = Math.min(targetRCL.size(), getResultColumns().size());
		 for (int index = 0;
		 index < size;
		 index++) {
			 ResultColumn sourceRC = getResultColumns().elementAt(index);
			 ResultColumn resultColumn = targetRCL.elementAt(index);
			 sourceRC.setType(resultColumn.getTypeServices());
		 }
	}
}",0,0,1,0
"public final class DefaultClassResolver implements IClassResolver{
	private final ConcurrentHashMap<String, WeakReference<Class<?>>> classes = new ConcurrentHashMap<String, WeakReference<Class<?>>>();
	public final Class<?> resolveClass(final String classname) throws ClassNotFoundException{
		Class<?> clazz = null;
		WeakReference<Class<?>> ref = classes.get(classname);
		if (ref != null){
			clazz = ref.get();
		}
		if (clazz == null){
			if (classname.equals(""byte"")){
				clazz = byte.class;
			}
			else if (classname.equals(""short"")){
				clazz = short.class;
			}
			else if (classname.equals(""int"")){
				clazz = int.class;
			}
			else if (classname.equals(""long"")){
				clazz = long.class;
			}
			else if (classname.equals(""float"")){
				clazz = float.class;
			}
			else if (classname.equals(""double"")){
				clazz = double.class;
			}
			else if (classname.equals(""boolean"")){
				clazz = boolean.class;
			}
			else if (classname.equals(""char"")){
				clazz = char.class;
			}
			else{
				synchronized (classes){
					ClassLoader loader = Thread.currentThread().getContextClassLoader();
					if (loader == null){
						loader = DefaultClassResolver.class.getClassLoader();
					}
					clazz = Class.forName(classname, false, loader);
				}
				classes.put(classname, new WeakReference<Class<?>>(clazz));
			}
		}
		return clazz;
	}
	public Iterator<URL> getResources(String name){
		HashSet<URL> loadedFiles = new HashSet<URL>();
		try{
			Enumeration<URL> resources = Application.class.getClassLoader().getResources(name);
			loadResources(resources, loadedFiles);
			resources = Application.get().getClass().getClassLoader().getResources(name);
			loadResources(resources, loadedFiles);
			resources = Thread.currentThread().getContextClassLoader().getResources(name);
			loadResources(resources, loadedFiles);
		}
		catch (IOException e){
			throw new WicketRuntimeException(e);
		}
		return loadedFiles.iterator();
	}
	private void loadResources(Enumeration<URL> resources, Set<URL> loadedFiles){
		if (resources != null){
			while (resources.hasMoreElements()){
				final URL url = resources.nextElement();
				if (!loadedFiles.contains(url)){
					loadedFiles.add(url);
				}
			}
		}
	}
}",0,0,0,0
"int offerService() throws Exception {
	 long lastHeartbeat = 0;
	 while (running) {
		 long now = System.currentTimeMillis();
		 long waitTime = HEARTBEAT_INTERVAL - (now - lastHeartbeat);
		 if (waitTime > 0) {
			 try {
				 Thread.sleep(waitTime);
			 }
			 catch (InterruptedException ie) {
			 }
			 continue;
		 }
		 Vector taskReports = new Vector();
		 synchronized (this) {
			 for (Iterator it = runningTasks.keySet().iterator();
			 it.hasNext();
			 ) {
				 String taskid = (String) it.next();
				 TaskInProgress tip = (TaskInProgress) runningTasks.get(taskid);
				 TaskStatus status = tip.createStatus();
				 taskReports.add(status);
				 if (status.getRunState() != TaskStatus.RUNNING) {
					 if (tip.getTask().isMapTask()) {
						 mapTotal--;
					 }
					 else {
						 reduceTotal--;
					 }
					 it.remove();
				 }
			 }
		 }
		 if (justStarted) {
			 this.fs = FileSystem.getNamed(jobClient.getFilesystemName(), this.fConf);
		 }
		 int resultCode = jobClient.emitHeartbeat(new TaskTrackerStatus(taskTrackerName, localHostname, mapOutputPort, taskReports), justStarted);
		 justStarted = false;
		 if (resultCode == InterTrackerProtocol.UNKNOWN_TASKTRACKER) {
			 return STALE_STATE;
		 }
		 if (mapTotal < maxCurrentTasks || reduceTotal < maxCurrentTasks) {
			 Task t = jobClient.pollForNewTask(taskTrackerName);
			 if (t != null) {
				 TaskInProgress tip = new TaskInProgress(t, this.fConf);
				 synchronized (this) {
					 tasks.put(t.getTaskId(), tip);
					 if (t.isMapTask()) {
						 mapTotal++;
					 }
					 else {
						 reduceTotal++;
					 }
					 runningTasks.put(t.getTaskId(), tip);
				 }
				 tip.launchTask();
			 }
		 }
		 synchronized (this) {
			 for (Iterator it = runningTasks.values().iterator();
			 it.hasNext();
			 ) {
				 TaskInProgress tip = (TaskInProgress) it.next();
				 if ((tip.getRunState() == TaskStatus.RUNNING) && (System.currentTimeMillis() - tip.getLastProgressReport() > this.taskTimeout)) {
					 LOG.info(""Task "" + tip.getTask().getTaskId() + "" timed out. Killing."");
					 tip.reportDiagnosticInfo(""Timed out."");
					 tip.killAndCleanup();
				 }
			 }
		 }
		 String toCloseId = jobClient.pollForTaskWithClosedJob(taskTrackerName);
		 if (toCloseId != null) {
			 synchronized (this) {
				 TaskInProgress tip = (TaskInProgress) tasks.get(toCloseId);
				 tip.jobHasFinished();
			 }
		 }
		 lastHeartbeat = now;
	 }
	 return 0;
 }",0,0,1,0
"public boolean hasExpiredTombstones(int gcBefore) {
	 return getLocalDeletionTime() < gcBefore;
 }",0,0,0,0
"static CommitLogHeader readCommitLogHeader(String headerFile) throws IOException {
	 DataInputStream reader = null;
	 try {
		 reader = new DataInputStream(new BufferedInputStream(new FileInputStream(headerFile)));
		 return serializer.deserialize(reader);
	 }
	 finally {
		 FileUtils.closeQuietly(reader);
	 }
 }",0,0,0,0
"public class XNewRmic extends ForkingSunRmic {
	 public static final String COMPILER_NAME = ""xnew"";
	 public XNewRmic() {
	 }
	 protected Commandline setupRmicCommand() {
		 String[] options = new String[] {
		 ""-Xnew"" }
		;
		 Commandline commandline = super.setupRmicCommand(options);
		 return commandline;
	 }
}",0,0,0,0
"public class ThreadTimings {
	 private static ThreadMXBean bean;
	 private static void checkBean() {
		 if (bean == null) {
			 bean = ManagementFactory.getThreadMXBean();
		 }
	 }
	 public static long[] userSysTimeInNanos() {
		 if (!FastRConfig.UseMXBeans) {
			 return null;
		 }
		 checkBean();
		 long userTimeInNanos = bean.getCurrentThreadUserTime();
		 return new long[]{
		userTimeInNanos, bean.getCurrentThreadCpuTime() - userTimeInNanos}
		;
	 }
}",0,0,0,0
"private class IncrementalIndexCursor implements Cursor {
	 private IncrementalIndexRowHolder currEntry;
	 private final ColumnSelectorFactory columnSelectorFactory;
	 private final ValueMatcher filterMatcher;
	 private final int maxRowIndex;
	 private Iterator<IncrementalIndexRow> baseIter;
	 private Iterable<IncrementalIndexRow> cursorIterable;
	 private boolean emptyRange;
	 private final DateTime time;
	 private int numAdvanced;
	 private boolean done;
	 IncrementalIndexCursor( VirtualColumns virtualColumns, boolean descending, Filter filter, Interval interval, Interval actualInterval, Granularity gran ) {
		 currEntry = new IncrementalIndexRowHolder();
		 columnSelectorFactory = new IncrementalIndexColumnSelectorFactory(index, virtualColumns, descending, currEntry);
		 maxRowIndex = index.getLastRowIndex();
		 filterMatcher = filter == null ? BooleanValueMatcher.of(true) : filter.makeMatcher(columnSelectorFactory);
		 numAdvanced = -1;
		 final long timeStart = Math.max(interval.getStartMillis(), actualInterval.getStartMillis());
		 cursorIterable = index.getFacts().timeRangeIterable( descending, timeStart, Math.min(actualInterval.getEndMillis(), gran.increment(interval.getStart()).getMillis()) );
		 emptyRange = !cursorIterable.iterator().hasNext();
		 time = gran.toDateTime(interval.getStartMillis());
		 reset();
	 }
	 public ColumnSelectorFactory getColumnSelectorFactory() {
		 return columnSelectorFactory;
	 }
	 public DateTime getTime() {
		 return time;
	 }
	 public void advance() {
		 if (!baseIter.hasNext()) {
			 done = true;
			 return;
		 }
		 while (baseIter.hasNext()) {
			 BaseQuery.checkInterrupted();
			 IncrementalIndexRow entry = baseIter.next();
			 if (beyondMaxRowIndex(entry.getRowIndex())) {
				 continue;
			 }
			 currEntry.set(entry);
			 if (filterMatcher.matches()) {
				 return;
			 }
		 }
		 done = true;
	 }
	 public void advanceUninterruptibly() {
		 if (!baseIter.hasNext()) {
			 done = true;
			 return;
		 }
		 while (baseIter.hasNext()) {
			 if (Thread.currentThread().isInterrupted()) {
				 return;
			 }
			 IncrementalIndexRow entry = baseIter.next();
			 if (beyondMaxRowIndex(entry.getRowIndex())) {
				 continue;
			 }
			 currEntry.set(entry);
			 if (filterMatcher.matches()) {
				 return;
			 }
		 }
		 done = true;
	 }
	 public void advanceTo(int offset) {
		 int count = 0;
		 while (count < offset && !isDone()) {
			 advance();
			 count++;
		 }
	 }
	 public boolean isDone() {
		 return done;
	 }
	 public boolean isDoneOrInterrupted() {
		 return isDone() || Thread.currentThread().isInterrupted();
	 }
	 public void reset() {
		 baseIter = cursorIterable.iterator();
		 if (numAdvanced == -1) {
			 numAdvanced = 0;
		 }
		 else {
			 Iterators.advance(baseIter, numAdvanced);
		 }
		 BaseQuery.checkInterrupted();
		 boolean foundMatched = false;
		 while (baseIter.hasNext()) {
			 IncrementalIndexRow entry = baseIter.next();
			 if (beyondMaxRowIndex(entry.getRowIndex())) {
				 numAdvanced++;
				 continue;
			 }
			 currEntry.set(entry);
			 if (filterMatcher.matches()) {
				 foundMatched = true;
				 break;
			 }
			 numAdvanced++;
		 }
		 done = !foundMatched && (emptyRange || !baseIter.hasNext());
	 }
	 private boolean beyondMaxRowIndex(int rowIndex) {
		 return rowIndex > maxRowIndex;
	 }
 }",0,0,0,0
"public int getBattleForceStandardWeaponsDamage(int range, int ammoType, boolean ignoreHeat, boolean ignoreSpecialAbility) {
	 double totalDamage = 0;
	 double frontArcWeaponsTotalDamage = 0;
	 double rearArcWeaponsTotalDamage = 0;
	 double totalHeat = 0;
	 boolean hasArtemis = false;
	 boolean hasTC = hasTargComp();
	 double baseDamage = 0;
	 TreeSet<String> weaponsUsed = new TreeSet<String>();
	 ArrayList<Mounted> weaponsList = getWeaponList();
	 if (DEBUGBATTLEFORCE) {
		 battleForceDebugString.append('\n');
		 battleForceDebugString.append(""Weapons Range: "");
		 battleForceDebugString.append(range);
		 battleForceDebugString.append('\n');
	 }
	 for (int pos = 0;
	 pos < weaponList.size();
	 pos++) {
		 double damageModifier = 1;
		 double weaponCount = 1;
		 double minRangeDamageModifier = 1;
		 hasArtemis = false;
		 Mounted mount = weaponsList.get(pos);
		 if ((mount == null) || mount.isRearMounted() || weaponsUsed.contains(mount.getName())) {
			 continue;
		 }
		 WeaponType weapon = (WeaponType) mount.getType();
		 if ((weapon.getLongRange() < range) && !(weapon instanceof ISLAC5) && !(weapon instanceof ATMWeapon) && !(weapon instanceof MMLWeapon)) {
			 continue;
		 }
		 if ((ammoType != AmmoType.T_NA) && (weapon.getAmmoType() != ammoType)) {
			 continue;
		 }
		 if ((weapon.getAmmoType() == AmmoType.T_INARC) || (weapon.getAmmoType() == AmmoType.T_NARC)) {
			 continue;
		 }
		 if ((weapon.getAmmoType() != AmmoType.T_NA) && !weapon.hasFlag(WeaponType.F_ONESHOT)) {
			 weaponsUsed.add(weapon.getName());
			 for (int nextPos = pos + 1;
			 nextPos < weaponList.size();
			 nextPos++) {
				 Mounted nextWeapon = weaponList.get(nextPos);
				 if ((nextWeapon == null) || nextWeapon.isRearMounted()) {
					 continue;
				 }
				 if (nextWeapon.getType().equals(weapon)) {
					 weaponCount++;
				 }
			 }
			 int ammoCount = 0;
			 for (Mounted ammo : getAmmo()) {
				 AmmoType at = (AmmoType) ammo.getType();
				 if ((at.getAmmoType() == weapon.getAmmoType()) && (at.getRackSize() == weapon.getRackSize())) {
					 if (at.getAmmoType() == AmmoType.T_AC_ROTARY) {
						 ammoCount += at.getShots() / 6;
					 }
					 else {
						 ammoCount += at.getShots();
					 }
				 }
			 }
			 if (DEBUGBATTLEFORCE) {
				 battleForceDebugString.append(""Ammo Weapon "");
				 battleForceDebugString.append(weapon.getName());
				 battleForceDebugString.append("" ammo count: "");
				 battleForceDebugString.append(ammoCount);
				 battleForceDebugString.append('\n');
				 battleForceDebugString.append(""Weapon Count: "");
				 battleForceDebugString.append(weaponCount);
				 battleForceDebugString.append('\n');
			 }
			 if (ammoCount / weaponCount < 10) {
				 damageModifier *= .75;
				 if (DEBUGBATTLEFORCE) {
					 battleForceDebugString.append(""Damage Modifier *.75: "");
					 battleForceDebugString.append(damageModifier);
					 battleForceDebugString.append('\n');
				 }
			 }
		 }
		 if (weapon.hasFlag(WeaponType.F_MISSILE)) {
			 baseDamage = Compute.calculateClusterHitTableAmount(7, weapon.getRackSize());
			 baseDamage *= weaponCount;
		 }
		 else {
			 baseDamage = weapon.getDamage() * weaponCount;
		 }
		 if (DEBUGBATTLEFORCE) {
			 battleForceDebugString.append(""Base Damage: "");
			 battleForceDebugString.append(baseDamage);
			 battleForceDebugString.append('\n');
		 }
		 if (range == Entity.BATTLEFORCESHORTRANGE) {
			 int minRange = Math.min(6, Math.max(0, weapon.getMinimumRange()));
			 minRangeDamageModifier *= battleForceMinRangeModifier[minRange];
			 if (DEBUGBATTLEFORCE && (minRange > 0)) {
				 battleForceDebugString.append(""Min range damage modifier: "");
				 battleForceDebugString.append(minRangeDamageModifier);
				 battleForceDebugString.append('\n');
			 }
		 }
		 int toHitMod = weapon.getToHitModifier() + 4;
		 switch (weapon.getAmmoType()) {
			 case AmmoType.T_AC_LBX: case AmmoType.T_AC_LBX_THB: baseDamage = Compute.calculateClusterHitTableAmount(7, weapon.getRackSize()) * weaponCount;
			 toHitMod--;
			 break;
			 case AmmoType.T_MRM: Mounted mLinker = mount.getLinkedBy();
			 if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_APOLLO))) {
				 toHitMod--;
				 baseDamage = Compute.calculateClusterHitTableAmount(6, weapon.getRackSize()) * weaponCount;
			 }
			 break;
			 case AmmoType.T_LRM: mLinker = mount.getLinkedBy();
			 if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_ARTEMIS))) {
				 baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * weaponCount;
				 hasArtemis = true;
			 }
			 else if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_ARTEMIS_V))) {
				 baseDamage = Compute.calculateClusterHitTableAmount(10, weapon.getRackSize()) * weaponCount;
				 hasArtemis = true;
			 }
			 break;
			 case AmmoType.T_SRM: mLinker = mount.getLinkedBy();
			 if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_ARTEMIS))) {
				 baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * 2 * weaponCount;
				 hasArtemis = true;
			 }
			 else if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_ARTEMIS_V))) {
				 baseDamage = Compute.calculateClusterHitTableAmount(10, weapon.getRackSize()) * 2 * weaponCount;
				 hasArtemis = true;
			 }
			 else {
				 baseDamage = Compute.calculateClusterHitTableAmount(7, weapon.getRackSize()) * 2 * weaponCount;
			 }
			 break;
			 case AmmoType.T_ATM: minRangeDamageModifier = 1;
			 switch (range) {
				 case Entity.BATTLEFORCESHORTRANGE: baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * weaponCount * 3;
				 break;
				 case Entity.BATTLEFORCEMEDIUMRANGE: baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * weaponCount * 2;
				 break;
				 case Entity.BATTLEFORCELONGRANGE: baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * weaponCount;
				 break;
			 }
			 break;
			 case AmmoType.T_AC_ULTRA: case AmmoType.T_AC_ULTRA_THB: damageModifier *= 1.5;
			 break;
			 case AmmoType.T_HAG: switch (range) {
				 case Entity.BATTLEFORCESHORTRANGE: baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * weaponCount;
				 break;
				 case Entity.BATTLEFORCELONGRANGE: baseDamage = Compute.calculateClusterHitTableAmount(5, weapon.getRackSize()) * weaponCount;
				 break;
				 case Entity.BATTLEFORCEMEDIUMRANGE: baseDamage = Compute.calculateClusterHitTableAmount(7, weapon.getRackSize()) * weaponCount;
				 break;
			 }
			 break;
			 case AmmoType.T_SRM_STREAK: baseDamage = weapon.getRackSize() * 2 * weaponCount;
			 break;
			 case AmmoType.T_AC_ROTARY: baseDamage = Compute.calculateClusterHitTableAmount(7, weapon.getRackSize()) * weaponCount * 5;
			 break;
		 }
		 if (weapon instanceof ISSnubNosePPC) {
			 switch (range) {
				 case Entity.BATTLEFORCESHORTRANGE: baseDamage = 10;
				 break;
				 case Entity.BATTLEFORCELONGRANGE: baseDamage = 0;
				 break;
				 case Entity.BATTLEFORCEMEDIUMRANGE: baseDamage = 5;
				 break;
			 }
		 }
		 if (weapon instanceof VariableSpeedPulseLaserWeapon) {
			 switch (range) {
				 case Entity.BATTLEFORCESHORTRANGE: toHitMod = 1;
				 break;
				 case Entity.BATTLEFORCEMEDIUMRANGE: toHitMod = 2;
				 break;
				 case Entity.BATTLEFORCELONGRANGE: toHitMod = 3;
				 break;
			 }
		 }
		 damageModifier *= battleForceToHitModifier[toHitMod];
		 if (DEBUGBATTLEFORCE) {
			 battleForceDebugString.append(""Base Damage: "");
			 battleForceDebugString.append(baseDamage);
			 battleForceDebugString.append('\n');
			 battleForceDebugString.append(""To Hit Modifier Damage Modifier: "");
			 battleForceDebugString.append(damageModifier);
			 battleForceDebugString.append('\n');
		 }
		 if (weapon.hasFlag(WeaponType.F_ONESHOT)) {
			 damageModifier *= .1;
			 if (DEBUGBATTLEFORCE) {
				 battleForceDebugString.append(""One Shot Modifier Damage Modifier: "");
				 battleForceDebugString.append(damageModifier);
				 battleForceDebugString.append('\n');
			 }
		 }
		 if (hasTC && weapon.hasFlag(WeaponType.F_DIRECT_FIRE) && (weapon.getAmmoType() != AmmoType.T_AC_LBX) && (weapon.getAmmoType() != AmmoType.T_AC_LBX_THB)) {
			 damageModifier *= 1.10;
			 if (DEBUGBATTLEFORCE) {
				 battleForceDebugString.append(""TC Modifier Damage Modifier: "");
				 battleForceDebugString.append(damageModifier);
				 battleForceDebugString.append('\n');
			 }
		 }
		 if ((weapon.getAmmoType() == AmmoType.T_LRM) || (weapon.getAmmoType() == AmmoType.T_AC) || (weapon.getAmmoType() == AmmoType.T_LAC) || (weapon.getAmmoType() == AmmoType.T_SRM)) {
			 double damage = baseDamage * damageModifier;
			 if (((damage < 10) && !ignoreSpecialAbility) || (ignoreSpecialAbility && !hasArtemis) || (!ignoreSpecialAbility && hasArtemis)) {
				 if (range == Entity.BATTLEFORCESHORTRANGE) {
					 damage *= minRangeDamageModifier;
				 }
				 frontArcWeaponsTotalDamage += damage;
				 if (DEBUGBATTLEFORCE) {
					 battleForceDebugString.append(""LRM/SRM/AC/MML Damage No Special Ability: "");
					 battleForceDebugString.append(damage);
					 battleForceDebugString.append('\n');
				 }
			 }
		 }
		 else if (weapon.hasFlag(WeaponType.F_PPC)) {
			 Mounted mLinker = mount.getLinkedBy();
			 if (range == Entity.BATTLEFORCESHORTRANGE) {
				 baseDamage *= minRangeDamageModifier;
			 }
			 if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_PPC_CAPACITOR))) {
				 frontArcWeaponsTotalDamage += ((baseDamage + 5) * .5) * damageModifier;
				 if (DEBUGBATTLEFORCE) {
					 battleForceDebugString.append(""PPC with Cap Damage: "");
					 battleForceDebugString.append(((baseDamage + 5) * .5) * damageModifier);
					 battleForceDebugString.append('\n');
				 }
			 }
			 else {
				 frontArcWeaponsTotalDamage += baseDamage * damageModifier;
				 if (DEBUGBATTLEFORCE) {
					 battleForceDebugString.append(""PPC Damage: "");
					 battleForceDebugString.append(baseDamage * damageModifier);
					 battleForceDebugString.append('\n');
				 }
			 }
		 }
		 else if (weapon.getAmmoType() == AmmoType.T_MML) {
			 double ammoDamage = 1;
			 Mounted mLinker = mount.getLinkedBy();
			 if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_ARTEMIS))) {
				 baseDamage = Compute.calculateClusterHitTableAmount(9, weapon.getRackSize()) * weaponCount;
				 hasArtemis = true;
			 }
			 else if (((mLinker != null) && (mLinker.getType() instanceof MiscType) && !mLinker.isDestroyed() && !mLinker.isMissing() && !mLinker.isBreached() && mLinker.getType().hasFlag(MiscType.F_ARTEMIS_V))) {
				 baseDamage = Compute.calculateClusterHitTableAmount(10, weapon.getRackSize()) * weaponCount;
				 hasArtemis = true;
			 }
			 switch (range) {
				 case Entity.BATTLEFORCESHORTRANGE: ammoDamage = 2;
				 break;
				 case Entity.BATTLEFORCELONGRANGE: ammoDamage = 1;
				 break;
				 case Entity.BATTLEFORCEMEDIUMRANGE: ammoDamage = 1;
				 baseDamage = Math.round((baseDamage * 3) / 2);
				 break;
			 }
			 double damage = baseDamage * damageModifier;
			 if (((damage < 10) && !ignoreSpecialAbility) || (ignoreSpecialAbility && !hasArtemis && (damage >= 10)) || (!ignoreSpecialAbility && hasArtemis)) {
				 frontArcWeaponsTotalDamage += damage * ammoDamage;
				 if (DEBUGBATTLEFORCE) {
					 battleForceDebugString.append(""MML Damage: "");
					 battleForceDebugString.append(baseDamage * ammoDamage * damageModifier);
					 battleForceDebugString.append('\n');
				 }
			 }
		 }
		 else {
			 if (range == Entity.BATTLEFORCESHORTRANGE) {
				 baseDamage *= minRangeDamageModifier;
			 }
			 frontArcWeaponsTotalDamage += baseDamage * damageModifier;
			 if (DEBUGBATTLEFORCE) {
				 battleForceDebugString.append(weapon.getName());
				 battleForceDebugString.append("" Damage: "");
				 battleForceDebugString.append(baseDamage * damageModifier);
				 battleForceDebugString.append('\n');
			 }
		 }
	 }
	 totalDamage = Math.max(frontArcWeaponsTotalDamage, rearArcWeaponsTotalDamage);
	 if (DEBUGBATTLEFORCE) {
		 battleForceDebugString.append(""Total Damage: "");
		 battleForceDebugString.append(totalDamage);
		 battleForceDebugString.append('\n');
	 }
	 totalHeat = getBattleForceTotalHeatGeneration(false) - 4;
	 if ((totalHeat > getHeatCapacity()) && !ignoreHeat) {
		 if (DEBUGBATTLEFORCE) {
			 battleForceDebugString.append(""Total Heat -4: "");
			 battleForceDebugString.append(totalHeat);
			 battleForceDebugString.append('\n');
			 battleForceDebugString.append(""Total Damage: "");
			 battleForceDebugString.append(totalDamage);
			 battleForceDebugString.append('\n');
			 battleForceDebugString.append(totalDamage);
			 battleForceDebugString.append("" * "");
			 battleForceDebugString.append(getHeatCapacity());
			 battleForceDebugString.append("" / "");
			 battleForceDebugString.append(totalHeat);
			 battleForceDebugString.append("" = "");
			 battleForceDebugString.append((totalDamage * getHeatCapacity()) / totalHeat);
			 battleForceDebugString.append('\n');
		 }
		 totalDamage = Math.ceil((totalDamage * getHeatCapacity()) / totalHeat);
	 }
	 if (ignoreSpecialAbility && (totalDamage < 10)) {
		 totalDamage = 0;
	 }
	 else if ((ammoType != AmmoType.T_NA)) {
		 totalDamage = Math.round(totalDamage / 10);
	 }
	 else {
		 totalDamage = Math.ceil(totalDamage / 10);
	 }
	 return (int) totalDamage;
 }",0,0,1,0
"public interface WindowActionMappingListener {
	 public static class Listeners extends ListenerList<WindowActionMappingListener> implements WindowActionMappingListener {
		 public void actionMappingAdded(Window window) {
			 forEach(listener -> listener.actionMappingAdded(window));
		 }
		 public void actionMappingsRemoved(Window window, int index, Sequence<Window.ActionMapping> removed) {
			 forEach(listener -> listener.actionMappingsRemoved(window, index, removed));
		 }
		 public void keyStrokeChanged(Window.ActionMapping actionMapping, Keyboard.KeyStroke previousKeyStroke) {
			 forEach(listener -> listener.keyStrokeChanged(actionMapping, previousKeyStroke));
		 }
		 public void actionChanged(Window.ActionMapping actionMapping, Action previousAction) {
			 forEach(listener -> listener.actionChanged(actionMapping, previousAction));
		 }
	 }
	 public void actionMappingAdded(Window window);
	 public void actionMappingsRemoved(Window window, int index, Sequence<Window.ActionMapping> removed);
	 public void keyStrokeChanged(Window.ActionMapping actionMapping, Keyboard.KeyStroke previousKeyStroke);
	 public void actionChanged(Window.ActionMapping actionMapping, Action previousAction);
}",0,0,0,0
"public void setSize(long size) {
	 this.size = size;
 }",0,0,0,0
"public void sendPrincipal(CaldavRequest request, String prefix, String principal) throws IOException {
	 String actualPrincipal = principal;
	 if (""users"".equals(prefix) && (principal.equalsIgnoreCase(session.getAlias()) || (principal.equalsIgnoreCase(session.getAliasFromLogin())))) {
		 actualPrincipal = session.getEmail();
	 }
	 CaldavResponse response = new CaldavResponse(HttpStatus.SC_MULTI_STATUS);
	 response.startMultistatus();
	 response.startResponse(encodePath(request, ""/principals/"" + prefix + '/' + principal));
	 response.startPropstat();
	 if (request.hasProperty(""principal-URL"") && request.isIcal5()) {
		 response.appendHrefProperty(""D:principal-URL"", encodePath(request, ""/principals/"" + prefix + '/' + actualPrincipal));
	 }
	 if (request.hasProperty(""calendar-home-set"")) {
		 if (""users"".equals(prefix)) {
			 response.appendHrefProperty(""C:calendar-home-set"", encodePath(request, ""/users/"" + actualPrincipal + ""/calendar/""));
		 }
		 else {
			 response.appendHrefProperty(""C:calendar-home-set"", encodePath(request, '/' + prefix + '/' + actualPrincipal));
		 }
	 }
	 if (request.hasProperty(""calendar-user-address-set"") && ""users"".equals(prefix)) {
		 response.appendHrefProperty(""C:calendar-user-address-set"", ""mailto:"" + actualPrincipal);
	 }
	 if (request.hasProperty(""addressbook-home-set"")) {
		 if (request.isUserAgent(""Address%20Book"") || request.isUserAgent(""Darwin"")) {
			 response.appendHrefProperty(""E:addressbook-home-set"", encodePath(request, '/' + prefix + '/' + actualPrincipal + '/'));
		 }
		 else if (""users"".equals(prefix)) {
			 response.appendHrefProperty(""E:addressbook-home-set"", encodePath(request, ""/users/"" + actualPrincipal + ""/contacts/""));
		 }
		 else {
			 response.appendHrefProperty(""E:addressbook-home-set"", encodePath(request, '/' + prefix + '/' + actualPrincipal + '/'));
		 }
	 }
	 if (""users"".equals(prefix)) {
		 if (request.hasProperty(""schedule-inbox-URL"")) {
			 response.appendHrefProperty(""C:schedule-inbox-URL"", encodePath(request, ""/users/"" + actualPrincipal + ""/inbox/""));
		 }
		 if (request.hasProperty(""schedule-outbox-URL"")) {
			 response.appendHrefProperty(""C:schedule-outbox-URL"", encodePath(request, ""/users/"" + actualPrincipal + ""/outbox/""));
		 }
	 }
	 else {
		 if (request.isLightning() && request.hasProperty(""schedule-inbox-URL"")) {
			 response.appendHrefProperty(""C:schedule-inbox-URL"", ""/"");
		 }
		 if (request.hasProperty(""schedule-outbox-URL"")) {
			 response.appendHrefProperty(""C:schedule-outbox-URL"", encodePath(request, ""/users/"" + session.getEmail() + ""/outbox/""));
		 }
	 }
	 if (request.hasProperty(""displayname"")) {
		 response.appendProperty(""D:displayname"", actualPrincipal);
	 }
	 if (request.hasProperty(""resourcetype"")) {
		 response.appendProperty(""D:resourcetype"", ""<D:collection/><D:principal/>"");
	 }
	 if (request.hasProperty(""supported-report-set"")) {
		 response.appendProperty(""D:supported-report-set"", ""<D:supported-report><D:report><C:calendar-multiget/></D:report></D:supported-report>"");
	 }
	 response.endPropStatOK();
	 response.endResponse();
	 response.endMultistatus();
	 response.close();
 }",0,0,1,0
private int findSmallest( int[] values );,0,0,0,0
"public class ShortArrayFSImpl extends CommonAuxArrayFSImpl implements ShortArrayFS {
	 private static class ShortArrayGenerator implements FSGenerator {
		 public FeatureStructure createFS(int addr, CASImpl cas) {
			 return new ShortArrayFSImpl(addr, cas);
		 }
	 }
	 public ShortArrayFSImpl(int addr, CASImpl cas) {
		 super(cas, addr);
	 }
	 static FSGenerator generator() {
		 return new ShortArrayGenerator();
	 }
	 public short get(int i) {
		 casImpl.checkArrayBounds(addr, i);
		 return casImpl.ll_getShortArrayValue(addr, i);
	 }
	 public void set(int i, short val) {
		 casImpl.checkArrayBounds(addr, i);
		 casImpl.ll_setShortArrayValue(addr, i, val);
	 }
	 public void copyFromArray(short[] src, int srcOffset, int destOffset, int length) {
		 copyFromJavaArray(src, srcOffset, casImpl.getShortHeap().heap, destOffset, length);
	 }
	 public void copyToArray(int srcOffset, short[] dest, int destOffset, int length) {
		 copyToJavaArray(this.casImpl.getShortHeap().heap, srcOffset, dest, destOffset, length);
	 }
	 public short[] toArray() {
		 return (short[]) toArray(this.casImpl.getShortHeap().heap);
	 }
	 public void copyToArray(int srcOffset, String[] dest, int destOffset, int length) {
		 casImpl.checkArrayBounds(addr, srcOffset, length);
		 srcOffset += casImpl.getHeap().heap[casImpl.getArrayStartAddress(addr)];
		 final short[] heap = this.casImpl.getShortHeap().heap;
		 for (int i = 0;
		 i < length;
		 i++) {
			 dest[i + destOffset] = Short.toString(heap[i + srcOffset]);
		 }
	 }
	 public void copyFromArray(String[] src, int srcOffset, int destOffset, int length) throws ArrayIndexOutOfBoundsException {
		 short[] bArray = new short[length];
		 for (int i = 0;
		 i < length;
		 i++) {
			 bArray[i] = Short.parseShort(src[i]);
		 }
		 copyFromArray(bArray, srcOffset, destOffset, length);
	 }
}",0,0,0,0
"public class PigServer extends org.apache.pig.PigServer {
	 public PigServer(ExecType execType, Properties properties) throws ExecException {
		 super(execType, properties);
	 }
	 public PigServer(ExecType execType) throws ExecException {
		 super(execType);
	 }
	 public void registerScript(String fileName, Map<String, String> aliasOverride) throws IOException {
		 try {
			 ScriptState.get().setFileName(fileName);
			 ScriptState.get().setScript(IOUtils.toString(new FileInputStream(fileName)));
			 InputStream compositeStream = Utils.getCompositeStream(new FileInputStream(fileName), pigContext.getProperties());
			 GruntParser grunt = new GruntParser(new InputStreamReader(compositeStream), this, aliasOverride);
			 grunt.setInteractive(false);
			 grunt.parseStopOnError(true);
		 }
		 catch (FileNotFoundException e) {
			 throw new IOException(e);
		 }
		 catch (org.apache.pig.tools.pigscript.parser.ParseException e) {
			 throw new IOException(e);
		 }
	 }
}",1,0,0,0
"public void resume() {
	try {
		stopFlag = false;
		Logger.log(""Resuming"");
		if (!restoreState()) {
			Logger.log(""Starting from beginning"");
			start();
			return;
		}
		Logger.log(""Restore success"");
		this.lastDownloaded = downloaded;
		this.prevTime = System.currentTimeMillis();
		if (allFinished()) {
			assembleAsync();
			return;
		}
		Segment c1 = null;
		for (int i = 0;
		 i < chunks.size();
		 i++) {
			Segment c = chunks.get(i);
			if (c.isFinished() || c.isActive())continue;
			if (c.getTag().equals(""T1"")) {
				c1 = c;
				break;
			}
		}
		Segment c2 = null;
		for (int i = 0;
		 i < chunks.size();
		 i++) {
			Segment c = chunks.get(i);
			if (c.isFinished() || c.isActive())continue;
			if (c.getTag().equals(""T2"")) {
				c2 = c;
				break;
			}
		}
		if (c1 != null) {
			try {
				c1.download(this);
			}
			 catch (IOException e) {
				Logger.log(e);
			}
		}
		if (c2 != null) {
			try {
				c2.download(this);
			}
			 catch (IOException e) {
				Logger.log(e);
			}
		}
		if (c1 == null && c2 == null) {
			Logger.log(""Internal error: no inactive/incomplete chunk found while resuming!"");
		}
	}
	 catch (Exception e) {
		Logger.log(e);
		this.errorCode = XDMConstants.RESUME_FAILED;
		listener.downloadFailed(this.id);
		return;
	}
}",0,0,1,0
"protected final void finish(Thread t) {
	 if (t == null) {
		 return;
	 }
	 try {
		 StreamPumper s = null;
		 if (t instanceof ThreadWithPumper) {
			 s = ((ThreadWithPumper) t).getPumper();
		 }
		 if (s != null && s.isFinished()) {
			 return;
		 }
		 if (!t.isAlive()) {
			 return;
		 }
		 t.join(JOIN_TIMEOUT);
		 if (s != null && !s.isFinished()) {
			 s.stop();
		 }
		 while ((s == null || !s.isFinished()) && t.isAlive()) {
			 t.interrupt();
			 t.join(JOIN_TIMEOUT);
		 }
	 }
	 catch (InterruptedException e) {
	 }
 }",0,0,0,0
"public final void entryRuleCallExpression() throws RecognitionException {
	 int entryRuleCallExpression_StartIndex = input.index();
	 try {
		 if ( state.backtracking>0 && alreadyParsedRule(input, 73) ) {
			 return ;
		 }
		 {
			 if ( state.backtracking==0 ) {
				 before(grammarAccess.getCallExpressionRule());
			 }
			 pushFollow(FollowSets000.FOLLOW_1);
			 ruleCallExpression();
			 state._fsp--;
			 if (state.failed) return ;
			 if ( state.backtracking==0 ) {
				 after(grammarAccess.getCallExpressionRule());
			 }
			 match(input,EOF,FollowSets000.FOLLOW_2);
			 if (state.failed) return ;
		 }
	 }
	 catch (RecognitionException re) {
		 reportError(re);
		 recover(input,re);
	 }
	 finally {
		 if ( state.backtracking>0 ) {
			 memoize(input, 73, entryRuleCallExpression_StartIndex);
		 }
	 }
	 return ;
 }",0,0,1,0
"public class MT940 implements FileFormat {
	 NumberFormat number = NumberFormat.getInstance(Locale.US);
	 Calendar calendar = Calendar.getInstance();
	 DateFormat swiftDateFormat = new SimpleDateFormat( ""yyMMdd"" );
	 NumberFormat swiftNumberFormat = NumberFormat.getInstance(Locale.GERMANY);
	 MainFrame mainFrame;
	 AccountChooser accountChooser;
	 public MT940(MainFrame parent, AccountChooser ac) {
		 mainFrame = parent;
		 accountChooser = ac;
		 number.setMinimumFractionDigits(2);
		 number.setMaximumFractionDigits(2);
	 }
	 public void importFile(Session session, File qifFile) {
		 try {
			 BufferedReader reader = new BufferedReader(new FileReader(qifFile));
			 String header = reader.readLine();
			 int count=0;
			 boolean finished = false;
			 while ( !finished ) {
				 finished = importTransaction( session, reader );
				 count++;
			 }
		 }
		 catch (IOException e) {
			 mainFrame.fileReadError(qifFile);
		 }
	 }
	 private Account accountForTransaction( Session session, String accountNumber ) {
		 if ( accountNumber==null ) {
			 return null;
		 }
		 accountNumber = accountNumber.trim();
		 Account account = session.getAccountByNumber( accountNumber );
		 System.out.println( ""Found account named "" + account + "" for number \"""" + accountNumber +""\"""");
		 if ( account == null ) {
			 String info = Constants.LANGUAGE.getString(""QIF.chooseAccount"") + "" \"""" + accountNumber + ""\""."";
			 int s = accountChooser.showDialog( session.getAccounts(), info, true);
			 switch( s ) {
				 case Constants.OK: account = accountChooser.getSelectedAccount();
				 System.out.println( ""OK, using account "" + account.getName() );
				 break;
				 case Constants.NEW: System.out.println( ""NEW, creating new account"" );
				 String name = accountNumber;
				 account = session.getNewAccount(accountNumber);
				 account.setAccountNumber( accountNumber );
				 break;
			 }
		 }
		 return account;
	 }
	 private boolean importTransaction( Session session, BufferedReader reader ) throws IOException {
		 String format1 = reader.readLine();
		 String format2 = reader.readLine();
		 String format3 = reader.readLine();
		 if ( format1==null || format2==null || format3==null ) return true;
		 if ( ! (format1.equals(""ABNANL2A"") && format2.equals(""940"") && format3.equals(""ABNANL2A"")) ) {
			 return ignoreTransaction( reader );
		 }
		 System.out.println( ""\nStart of statement, format=""+format1 );
		 boolean finished = false;
		 boolean ready = false;
		 Account account = null;
		 Entry entry = null;
		 while( ! ready ) {
			 String line = reader.readLine();
			 if ( line == null ) {
				 finished = true;
				 ready = true;
				 break;
			 }
			 if ( line.startsWith( ""-"" )) {
				 ready = true;
				 break;
			 }
			 if ( ! line.startsWith("":"" )) {
				 return ignoreTransaction( reader );
			 }
			 int colon = line.indexOf( "":"", 1 );
			 if ( colon<0 ) {
				 return ignoreTransaction( reader );
			 }
			 String field = line.substring( 1, colon );
			 String value = line.substring( colon+1 );
			 if ( field.equals( ""25"" )) {
				 account = accountForTransaction( session, value );
				 System.out.println( ""Transaction for account: \"""" + account + ""\"""");
			 }
			 else if ( field.equals( ""61"" ) ) {
				 System.out.println( "":61: line: "" + line );
				 if ( entry != null ) {
					 System.out.println( ""Adding entry"" );
					 account.addEntry( entry );
					 entry = null;
				 }
				 if ( account == null ) {
					 System.err.println( ""Statement line without account"" );
					 return ignoreTransaction( reader );
				 }
				 System.out.println( ""Creating new entry"" );
				 entry = new Entry();
				 if ( value.length() < 11 ) {
					 System.err.println( ""MT940 :61: line too short: "" + line );
					 return ignoreTransaction( reader );
				 }
				 int pos = 0;
				 String dateString = value.substring( 0, 6 );
				 Date date;
				 try {
					 date = swiftDateFormat.parse( dateString );
				 }
				 catch ( ParseException e ) {
					 System.err.println( ""Error parsing value date in line: "" + line );
					 return ignoreTransaction( reader );
				 }
				 entry.setValuta( date );
				 pos += 6;
				 if ( Character.isDigit(value.charAt(pos)) ) {
					 try {
						 String bookingDateString = value.substring( pos, pos+4 );
						 Calendar c = Calendar.getInstance();
						 c.setTime(date);
						 int month = Integer.parseInt( bookingDateString.substring(0,2) )-1;
						 int day = Integer.parseInt( bookingDateString.substring(2,4) );
						 int year = c.get(Calendar.YEAR);
						 if ( month == 11 && c.get(Calendar.MONTH)==0 ) year--;
						 if ( month == 0 && c.get(Calendar.MONTH)==11 ) year++;
						 c.set(year, month, day);
						 entry.setDate(c.getTime());
						 pos += 4;
					 }
					 catch ( NumberFormatException e ) {
						 System.err.println( ""Error parsing booking date in line: "" + line );
						 return ignoreTransaction( reader );
					 }
				 }
				 else {
					 entry.setDate( date );
				 }
				 String creditDebit;
				 if ( Character.isDigit(value.charAt(pos+1)) ) {
					 creditDebit = value.substring( pos, pos+1 );
					 pos++;
				 }
				 else {
					 creditDebit = value.substring( pos, pos+2 );
					 pos += 2;
				 }
				 int bookingCodePos = value.indexOf( ""N"", pos );
				 if ( pos<0 ) {
					 System.err.println( ""Error finding amount and booking code in line: "" + line );
					 return ignoreTransaction( reader );
				 }
				 String amountString = value.substring( pos, bookingCodePos );
				 double amount;
				 try {
					 amount = swiftNumberFormat.parse( amountString ).doubleValue();
				 }
				 catch ( ParseException e ){
					 System.err.println( ""Error parsing amount "" + amountString + "" in line: "" + line );
					 return ignoreTransaction( reader );
				 }
				 if ( creditDebit.equals(""D"") || creditDebit.equals(""RC"")) amount = -amount;
				 entry.setAmount( (long) (amount*100) );
			 }
			 else if ( field.equals( ""86"") ) {
				 System.out.println( "":86: line: "" + line );
				 entry.setDescription( value );
				 StringBuffer buf = new StringBuffer();
				 boolean busy = true;
				 while( busy ) {
					 reader.mark( 1500 );
					 line = reader.readLine();
					 if ( line.startsWith("":"") ) {
						 busy = false;
						 reader.reset();
					 }
					 else {
						 buf.append( "" "" ).append( line );
						 System.out.println( "":86: line: "" + line );
					 }
				 }
				 entry.setMemo( buf.toString() );
			 }
		 }
		 System.out.println( ""Finished parsing transation"" );
		 if ( entry != null ) {
			 System.out.println( ""Adding entry"" );
			 account.addEntry( entry );
			 entry = null;
		 }
		 return finished;
	 }
	 private boolean ignoreTransaction( BufferedReader reader ) throws IOException {
		 while( true ) {
			 String line = reader.readLine();
			 if ( line==null ) return true;
			 if ( line.startsWith(""-"") ) return false;
		 }
	 }
	 public void exportAccount(Session session, Account account, File file) {
	 }
	 public FileFilter fileFilter() {
		 return new MT940FileFilter();
	 }
	 public class CanceledException extends Exception {
		 public CanceledException() {
			 super();
		 }
		 public CanceledException(String s) {
			 super(s);
		 }
	 }
	 public static class MT940FileFilter extends FileFilter {
		 public boolean accept(File f) {
			 if (f == null) return false;
			 if (f.isDirectory()) return true;
			 return f.getName().toLowerCase().endsWith("".sta"");
		 }
		 public String getDescription() {
			 return ""MT940 file (*.sta)"";
		 }
	 }
}",1,0,0,0
"public class VcsPullRequestsController extends TabControllerImpl<VcsPullRequestsModel> {
	 private static final String EVENT_NAME = ""Pull Requests"";
	 public VcsPullRequestsController(final Project project) {
		 super(new TabImpl(new VcsPullRequestsForm(), EVENT_NAME), new VcsPullRequestsModel(project), new ServerEvent[]{
		ServerEvent.PULL_REQUESTS_CHANGED}
		);
	 }
	 protected void performAction(final ActionEvent e) {
		 if (VcsPullRequestsForm.CMD_OPEN_SELECTED_ITEM_IN_BROWSER.equals(e.getActionCommand())) {
			 model.openSelectedItemsLink();
		 }
		 else if (VcsPullRequestsForm.CMD_ABANDON_SELECTED_PR.equals(e.getActionCommand())) {
			 model.abandonSelectedPullRequest();
		 }
		 else {
			 super.performAction(e);
		 }
	 }
}",0,0,0,0
"static ResolvableType forType( Type type, TypeProvider typeProvider, VariableResolver variableResolver) {
	if (type == null && typeProvider != null) {
		type = SerializableTypeWrapper.forTypeProvider(typeProvider);
	}
	if (type == null) {
		return NONE;
	}
	if (type instanceof Class) {
		return new ResolvableType(type, typeProvider, variableResolver, (ResolvableType) null);
	}
	cache.purgeUnreferencedEntries();
	ResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);
	ResolvableType cachedType = cache.get(resultType);
	if (cachedType == null) {
		cachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);
		cache.put(cachedType, cachedType);
	}
	resultType.resolved = cachedType.resolved;
	return resultType;
}",0,0,1,0
"public void setRemove(String remove) {
	 this.remove = remove;
 }",0,0,0,0
"public class GangliaServer implements MonitorService {
	 private static final Logger logger = LoggerFactory.getLogger(GangliaServer.class);
	 public static final int BUFFER_SIZE = 1500;
	 protected byte[] buffer = new byte[BUFFER_SIZE];
	 protected int offset;
	 private final List<SocketAddress> addresses = new ArrayList<SocketAddress>();
	 private DatagramSocket socket = null;
	 private ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
	 private List<HostInfo> hosts;
	 protected final GangliaCollector collectorRunnable;
	 private int pollFrequency = 60;
	 public static final String DEFAULT_UNITS = """";
	 public static final int DEFAULT_TMAX = 60;
	 public static final int DEFAULT_DMAX = 0;
	 public static final int DEFAULT_SLOPE = 3;
	 public static final String GANGLIA_DOUBLE_TYPE = ""double"";
	 private volatile boolean isGanglia3 = false;
	 private String hostname;
	 public final String CONF_POLL_FREQUENCY = ""pollFrequency"";
	 public final int DEFAULT_POLL_FREQUENCY = 60;
	 public final String CONF_HOSTS = ""hosts"";
	 public final String CONF_ISGANGLIA3 = ""isGanglia3"";
	 private static final String GANGLIA_CONTEXT = ""flume."";
	 public GangliaServer() throws FlumeException {
		 collectorRunnable = new GangliaCollector();
	 }
	 protected void xdr_string(String s) {
		 byte[] bytes = s.getBytes();
		 int len = bytes.length;
		 xdr_int(len);
		 System.arraycopy(bytes, 0, buffer, offset, len);
		 offset += len;
		 pad();
	 }
	 private void pad() {
		 int newOffset = ((offset + 3) / 4) * 4;
		 while (offset < newOffset) {
			 buffer[offset++] = 0;
		 }
	 }
	 protected void xdr_int(int i) {
		 buffer[offset++] = (byte) ((i >> 24) & 0xff);
		 buffer[offset++] = (byte) ((i >> 16) & 0xff);
		 buffer[offset++] = (byte) ((i >> 8) & 0xff);
		 buffer[offset++] = (byte) (i & 0xff);
	 }
	 public synchronized void sendToGangliaNodes() {
		 DatagramPacket packet;
		 for (SocketAddress addr : addresses) {
			 try {
				 packet = new DatagramPacket(buffer, offset, addr);
				 socket.send(packet);
			 }
			 catch (Exception ex) {
				 logger.warn(""Could not send metrics to metrics server: "" + addr.toString(), ex);
			 }
		 }
		 offset = 0;
	 }
	 public void start() {
		 try {
			 socket = new DatagramSocket();
			 hostname = InetAddress.getLocalHost().getHostName();
		 }
		 catch (SocketException ex) {
			 logger.error(""Could not create socket for metrics collection."");
			 throw new FlumeException( ""Could not create socket for metrics collection."", ex);
		 }
		 catch (Exception ex2) {
			 logger.warn(""Unknown error occured"", ex2);
		 }
		 for (HostInfo host : hosts) {
			 addresses.add(new InetSocketAddress( host.getHostName(), host.getPortNumber()));
		 }
		 collectorRunnable.server = this;
		 if (service.isShutdown() || service.isTerminated()) {
			 service = Executors.newSingleThreadScheduledExecutor();
		 }
		 service.scheduleWithFixedDelay(collectorRunnable, 0, pollFrequency, TimeUnit.SECONDS);
	 }
	 public void stop() {
		 service.shutdown();
		 while (!service.isTerminated()) {
			 try {
				 logger.warn(""Waiting for ganglia service to stop"");
				 service.awaitTermination(500, TimeUnit.MILLISECONDS);
			 }
			 catch (InterruptedException ex) {
				 logger.warn(""Interrupted while waiting"" + "" for ganglia monitor to shutdown"", ex);
				 service.shutdownNow();
			 }
		 }
		 addresses.clear();
	 }
	 public void setPollFrequency(int pollFrequency) {
		 this.pollFrequency = pollFrequency;
	 }
	 public int getPollFrequency() {
		 return pollFrequency;
	 }
	 public void setIsGanglia3(boolean isGanglia3) {
		 this.isGanglia3 = isGanglia3;
	 }
	 public boolean isGanglia3() {
		 return this.isGanglia3;
	 }
	 protected void createGangliaMessage(String name, String value) {
		 logger.debug(""Sending ganglia3 formatted message."" + name + "": "" + value);
		 name = hostname + ""."" + name;
		 xdr_int(0);
		 String type = ""string"";
		 try {
			 Float.parseFloat(value);
			 type = ""float"";
		 }
		 catch (NumberFormatException ex) {
		 }
		 xdr_string(type);
		 xdr_string(name);
		 xdr_string(value);
		 xdr_string(DEFAULT_UNITS);
		 xdr_int(DEFAULT_SLOPE);
		 xdr_int(DEFAULT_TMAX);
		 xdr_int(DEFAULT_DMAX);
	 }
	 protected void createGangliaMessage31(String name, String value) {
		 logger.debug(""Sending ganglia 3.1 formatted message: "" + name + "": "" + value);
		 xdr_int(128);
		 xdr_string(hostname);
		 xdr_string(name);
		 xdr_int(0);
		 String type = ""string"";
		 try {
			 Float.parseFloat(value);
			 type = ""float"";
		 }
		 catch (NumberFormatException ex) {
		 }
		 xdr_string(type);
		 xdr_string(name);
		 xdr_string(DEFAULT_UNITS);
		 xdr_int(DEFAULT_SLOPE);
		 xdr_int(DEFAULT_TMAX);
		 xdr_int(DEFAULT_DMAX);
		 xdr_int(1);
		 xdr_string(""GROUP"");
		 xdr_string(""flume"");
		 this.sendToGangliaNodes();
		 xdr_int(133);
		 xdr_string(hostname);
		 xdr_string(name);
		 xdr_int(0);
		 xdr_string(""%s"");
		 xdr_string(value);
	 }
	 public void configure(Context context) {
		 this.pollFrequency = context.getInteger(this.CONF_POLL_FREQUENCY, 60);
		 String localHosts = context.getString(this.CONF_HOSTS);
		 if (localHosts == null || localHosts.isEmpty()) {
			 throw new ConfigurationException(""Hosts list cannot be empty."");
		 }
		 this.hosts = this.getHostsFromString(localHosts);
		 this.isGanglia3 = context.getBoolean(this.CONF_ISGANGLIA3, false);
	 }
	 private List<HostInfo> getHostsFromString(String hosts) throws FlumeException {
		 List<HostInfo> hostInfoList = new ArrayList<HostInfo>();
		 String[] hostsAndPorts = hosts.split("","");
		 int i = 0;
		 for (String host : hostsAndPorts) {
			 String[] hostAndPort = host.split("":"");
			 if (hostAndPort.length < 2) {
				 logger.warn(""Invalid ganglia host: "", host);
				 continue;
			 }
			 try {
				 hostInfoList.add(new HostInfo(""ganglia_host-"" + String.valueOf(i), hostAndPort[0], Integer.parseInt(hostAndPort[1])));
			 }
			 catch (Exception e) {
				 logger.warn(""Invalid ganglia host: "" + host, e);
				 continue;
			 }
		 }
		 if (hostInfoList.isEmpty()) {
			 throw new FlumeException(""No valid ganglia hosts defined!"");
		 }
		 return hostInfoList;
	 }
	 protected class GangliaCollector implements Runnable {
		 private GangliaServer server;
		 public void run() {
			 try {
				 Map<String, Map<String, String>> metricsMap = JMXPollUtil.getAllMBeans();
				 for (String component : metricsMap.keySet()) {
					 Map<String, String> attributeMap = metricsMap.get(component);
					 for (String attribute : attributeMap.keySet()) {
						 if (isGanglia3) {
							 server.createGangliaMessage(GANGLIA_CONTEXT + component + ""."" + attribute, attributeMap.get(attribute));
						 }
						 else {
							 server.createGangliaMessage31(GANGLIA_CONTEXT + component + ""."" + attribute, attributeMap.get(attribute));
						 }
						 server.sendToGangliaNodes();
					 }
				 }
			 }
			 catch (Throwable t) {
				 logger.error(""Unexpected error"", t);
			 }
		 }
	 }
}",1,1,0,0
"private HashMap createSessionEJBs(SimpleModel model) {
	 HashMap map = new HashMap();
	 Collection pkList = model.getAllSimpleUmlPackages(model);
	 for (Iterator pkIterator = pkList.iterator();
	 pkIterator.hasNext();
	) {
		 SimpleUmlPackage simpleUmlPackage = (SimpleUmlPackage) pkIterator.next();
		 Collection list = simpleUmlPackage.getSimpleClassifiers();
		 for (Iterator it = list.iterator();
		 it.hasNext();
		) {
			 SimpleModelElement el = (SimpleModelElement) it.next();
			 if ((el instanceof SimpleUmlClass) && model.getStereoType(el) != null && model.getStereoType(el).equals(JagUMLProfile.STEREOTYPE_CLASS_SERVICE)) {
				 ArrayList businessMethods = new ArrayList();
				 SimpleUmlClass suc = (SimpleUmlClass) el;
				 Collection operations = suc.getSimpleOperations();
				 for (Iterator oit = operations.iterator();
				 oit.hasNext();
				) {
					 BusinessMethod bm = new BusinessMethod();
					 SimpleOperation operation = (SimpleOperation) oit.next();
					 log.info(""The operation name is: "" + operation.getName());
					 bm.setMethodName(operation.getName());
					 String desc = model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, operation);
					 if (desc == null) {
						 bm.setDescription("""");
					 }
					 else {
						 bm.setDescription(desc);
					 }
					 ArrayList argList = new ArrayList();
					 log.info(""The number of parameters: "" + operation.getSimpleParameters().size());
					 for (Iterator pit = operation.getSimpleParameters().iterator();
					 pit.hasNext();
					) {
						 SimpleParameter param = (SimpleParameter) pit.next();
						 BusinessArgument arg = new BusinessArgument();
						 String type;
						 log.debug(""Param kind: "" + param.getKind());
						 if (param.getType() != null) {
							 if (param.getType().getName() != null && param.getType().getName().equalsIgnoreCase(""void"")) {
								 type = ""void"";
							 }
							 else {
								 String packageName = param.getType().getOwner().getFullPackageName();
								 if (packageName == null) {
									 packageName = """";
								 }
								 else {
									 packageName = param.getType().getOwner().getFullPackageName() + ""."";
								 }
								 String typeName = param.getType().getName();
								 if (typeName != null) {
									 if (typeName.startsWith(""java::lang::"")) {
										 typeName = typeName.substring(12);
									 }
								 }
								 type = """" + packageName + typeName;
							 }
						 }
						 else {
							 type = ""void"";
						 }
						 if (param.getKind().equalsIgnoreCase(SimpleParameter.RETURN)) {
							 log.info(""Found a return type"");
							 bm.setReturnType(type);
						 }
						 else {
							 log.info(""The param name is: "" + param.getName());
							 arg.setName(param.getName());
							 log.info(""The param type is: "" + type);
							 arg.setType(type);
							 argList.add(arg);
						 }
					 }
					 bm.setArgumentList(argList);
					 businessMethods.add(bm);
				 }
				 String rootPackage = simpleUmlPackage.getFullPackageName();
				 Session session = new Session(rootPackage);
				 session.setName(suc.getName());
				 session.setRootPackage(rootPackage);
				 session.setRefName(suc.getName());
				 session.setDescription(model.getTaggedValue(JagUMLProfile.TAGGED_VALUE_DOCUMENTATION, suc));
				 session.setBusinessMethods(businessMethods);
				 Collection deps = model.getSimpleDependencies();
				 for (Iterator iterator = deps.iterator();
				 iterator.hasNext();
				) {
					 SimpleDependency sd = (SimpleDependency) iterator.next();
					 if (sd.getClient().getName().equals(session.getName().toString())) {
						 String entityRef = sd.getSupplier().getName();
						 session.addRef(entityRef);
					 }
				 }
				 map.put(session.getRefName(), session);
			 }
		 }
	 }
	 return map;
 }",0,0,1,0
"public String getKeySpace() {
	 return keySpace == null ? ""unknown"" : keySpace;
 }",0,0,0,0
"public synchronized Object[] pendingTransfers(DatanodeInfo srcNode, int xmitsInProgress) {
	 synchronized (neededReplications) {
		 Object results[] = null;
		 int scheduledXfers = 0;
		 if (neededReplications.size() > 0) {
			 Vector replicateBlocks = new Vector();
			 Vector replicateTargetSets = new Vector();
			 for (Iterator it = neededReplications.iterator();
			 it.hasNext();
			) {
				 if (scheduledXfers >= this.maxReplicationStreams - xmitsInProgress) {
					 break;
				 }
				 Block block = (Block) it.next();
				 long blockSize = block.getNumBytes();
				 FSDirectory.INode fileINode = dir.getFileByBlock(block);
				 if (fileINode == null) {
					 it.remove();
				 }
				 else {
					 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
					 TreeSet excessBlocks = (TreeSet) excessReplicateMap.get( srcNode.getStorageID() );
					 if (containingNodes.contains(srcNode) && (excessBlocks == null || ! excessBlocks.contains(block))) {
						 DatanodeInfo targets[] = chooseTargets( Math.min( fileINode.getReplication() - containingNodes.size(), this.maxReplicationStreams - xmitsInProgress), containingNodes, null, blockSize);
						 if (targets.length > 0) {
							 replicateBlocks.add(block);
							 replicateTargetSets.add(targets);
							 scheduledXfers += targets.length;
						 }
					 }
				 }
			 }
			 if (replicateBlocks.size() > 0) {
				 int i = 0;
				 for (Iterator it = replicateBlocks.iterator();
				 it.hasNext();
				 i++) {
					 Block block = (Block) it.next();
					 DatanodeInfo targets[] = (DatanodeInfo[]) replicateTargetSets.elementAt(i);
					 TreeSet containingNodes = (TreeSet) blocksMap.get(block);
					 if (containingNodes.size() + targets.length >= dir.getFileByBlock( block).getReplication() ) {
						 neededReplications.remove(block);
						 pendingReplications.add(block);
						 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.pendingTransfer: "" + block.getBlockName() + "" is removed from neededReplications to pendingReplications"");
					 }
					 if (NameNode.stateChangeLog.isInfoEnabled()) {
						 StringBuffer targetList = new StringBuffer(""datanode(s)"");
						 for (int k = 0;
						 k < targets.length;
						 k++) {
							 targetList.append(' ');
							 targetList.append(targets[k].getName());
						 }
						 NameNode.stateChangeLog.info( ""BLOCK* NameSystem.pendingTransfer: "" + ""ask "" + srcNode.getName() + "" to replicate "" + block.getBlockName() + "" to "" + targetList);
					 }
				 }
				 DatanodeInfo targetMatrix[][] = new DatanodeInfo[replicateTargetSets.size()][];
				 for (i = 0;
				 i < targetMatrix.length;
				 i++) {
					 targetMatrix[i] = (DatanodeInfo[]) replicateTargetSets.elementAt(i);
				 }
				 results = new Object[2];
				 results[0] = replicateBlocks.toArray(new Block[replicateBlocks.size()]);
				 results[1] = targetMatrix;
			 }
		 }
		 return results;
	 }
 }",0,0,1,0
"public void setXmlDocument(Document doc) {
	 this.document = doc;
 }",0,0,0,0
"public class RPObjectDAO {
	private static final marauroa.common.Logger logger = Log4J.getLogger(RPObjectDAO.class);
	protected RPObjectFactory factory;
	protected RPObjectDAO(RPObjectFactory factory) {
		this.factory = factory;
	}
	public RPObject loadRPObject(DBTransaction transaction, int objectid) throws SQLException, IOException {
		return loadRPObject(transaction, objectid, true);
	}
	public RPObject loadRPObject(DBTransaction transaction, int objectid, boolean transform) throws SQLException, IOException {
		String query = ""select data, protocol_version from rpobject where object_id=[objectid]"";
		logger.debug(""loadRPObject is executing query "" + query);
		Map<String, Object> params = new HashMap<String, Object>();
		params.put(""objectid"", objectid);
		ResultSet resultSet = transaction.query(query, params);
		if (resultSet.next()) {
			 Blob data = resultSet.getBlob(""data"");
			int protocolVersion = NetConst.FIRST_VERSION_WITH_MULTI_VERSION_SUPPORT - 1;
			Object temp = resultSet.getObject(""protocol_version"");
			if (temp != null) {
				protocolVersion = ((Integer) temp).intValue();
			 }
			RPObject object = readRPObject(objectid, data, protocolVersion, transform);
			 resultSet.close();
			return object;
		}
		 resultSet.close();
		return null;
	}
	public RPObject readRPObject(int objectid, Blob data, int protocolVersion, boolean transform) throws SQLException, IOException {
		 InputStream input = data.getBinaryStream();
		 ByteArrayOutputStream output = new ByteArrayOutputStream();
		 byte[] rb = new byte[1024];
		 int ch = 0;
		 while ((ch = input.read(rb)) != -1) {
			 output.write(rb, 0, ch);
		 }
		 byte[] content = output.toByteArray();
		 input.close();
		 output.close();
		 ByteArrayInputStream inStream = new ByteArrayInputStream(content);
		 InflaterInputStream szlib = new InflaterInputStream(inStream, new Inflater());
		 InputSerializer inputSerializer = new InputSerializer(szlib);
		 inputSerializer.setProtocolVersion(protocolVersion);
		 RPObject object = (RPObject) inputSerializer.readObject(new RPObject());
		 if (transform) {
			 object = factory.transform(object);
		 }
		 object.put(""#db_id"", objectid);
		 return object;
	 }
	public int removeRPObject(DBTransaction transaction, int objectid) throws SQLException {
		String query = ""delete from rpobject where object_id=[objectid]"";
		logger.debug(""removeRPObject is executing query "" + query);
		Map<String, Object> params = new HashMap<String, Object>();
		params.put(""objectid"", objectid);
		transaction.execute(query, params);
		return objectid;
	}
	public boolean hasRPObject(DBTransaction transaction, int objectid) throws SQLException {
		String query = ""select count(*) as amount from rpobject where object_id=[objectid]"";
		Map<String, Object> params = new HashMap<String, Object>();
		params.put(""objectid"", objectid);
		logger.debug(""hasRPObject is executing query "" + query);
		int count = transaction.querySingleCellInt(query, params);
		return count > 0;
	}
	public int storeRPObject(DBTransaction transaction, RPObject object) throws IOException, SQLException {
		ByteArrayOutputStream array = new ByteArrayOutputStream();
		DeflaterOutputStream out_stream = new DeflaterOutputStream(array);
		OutputSerializer serializer = new OutputSerializer(out_stream);
		int protocolVersion = serializer.getProtocolVersion();
		try {
			object.writeObject(serializer, DetailLevel.FULL);
			out_stream.close();
		}
		 catch (IOException e) {
			logger.warn(""Error while serializing rpobject: "" + object, e);
			throw e;
		}
		ByteArrayInputStream inStream = new ByteArrayInputStream(array.toByteArray());
		int object_id = -1;
		if (object.has(""#db_id"")) {
			object_id = object.getInt(""#db_id"");
		}
		String query;
		Map<String, Object> params = new HashMap<String, Object>();
		params.put(""object_id"", object_id);
		params.put(""protocolVersion"", protocolVersion);
		if (object_id != -1 && hasRPObject(transaction, object_id)) {
			query = ""update rpobject set data=?, protocol_version=[protocolVersion] where object_id=[object_id]"";
		}
		 else {
			query = ""insert into rpobject (data, protocol_version) values(?, [protocolVersion])"";
		}
		logger.debug(""storeRPObject is executing query "" + query);
		transaction.execute(query, params, inStream);
		if (object_id == -1) {
			object_id = transaction.getLastInsertId(""rpobject"", ""id"");
			object.put(""#db_id"", object_id);
		}
		 else {
			object_id = object.getInt(""#db_id"");
		}
		return object_id;
	}
	public RPObject loadRPObject(int objectid, boolean transform) throws SQLException, IOException {
		DBTransaction transaction = TransactionPool.get().beginWork();
		try {
			RPObject res = loadRPObject(transaction, objectid, transform);
			return res;
		}
		 finally {
			TransactionPool.get().commit(transaction);
		}
	}
	public RPObject loadRPObject(int objectid) throws SQLException, IOException {
		DBTransaction transaction = TransactionPool.get().beginWork();
		try {
			RPObject res = loadRPObject(transaction, objectid, true);
			return res;
		}
		 finally {
			TransactionPool.get().commit(transaction);
		}
	}
	public int removeRPObject(int objectid) throws SQLException {
		DBTransaction transaction = TransactionPool.get().beginWork();
		try {
			int res = removeRPObject(transaction, objectid);
			return res;
		}
		 finally {
			TransactionPool.get().commit(transaction);
		}
	}
	public boolean hasRPObject(int objectid) throws SQLException {
		DBTransaction transaction = TransactionPool.get().beginWork();
		try {
			boolean res = hasRPObject(transaction, objectid);
			return res;
		}
		 finally {
			TransactionPool.get().commit(transaction);
		}
	}
	public int storeRPObject(RPObject object) throws IOException, SQLException {
		DBTransaction transaction = TransactionPool.get().beginWork();
		try {
			int res = storeRPObject(transaction, object);
			return res;
		}
		 finally {
			TransactionPool.get().commit(transaction);
		}
	}
}",0,0,0,0
"public ClassPath() {
	m_jarLocFileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
	m_jarLocFileChooser.setMultiSelectionEnabled(true);
	GenericFileFilter filter = new GenericFileFilter(""Zip, Jar, or directories"");
	filter.addSuffix(""jar"");
	filter.addSuffix(""zip"");
	m_jarLocFileChooser.addChoosableFileFilter(filter);
	m_fileeditor.setFileChooser(m_jarLocFileChooser);
	m_list.setEditor(m_fileeditor);
	setLayout(new BorderLayout());
	add(BorderLayout.CENTER, m_list);
 }",0,0,0,0
public short getSid();,0,0,0,0
"public String getValue(){
	return value;
}",0,0,0,0
"private static class MigrationLink {
	 int source;
	 int target;
	 Migration[] migrations;
	 public MigrationLink(int source, int target, Migration[] migrations) {
		 this.source = source;
		 this.target = target;
		 this.migrations = migrations;
	 }
 }",0,1,0,0
"static void generate(String templateName, String pathPrefix, String pathSuffix, File input_path, File output_path) throws IOException;",0,0,0,1
"public boolean setSafeMode( SafeModeAction action ) throws IOException {
	 return namenode.setSafeMode( action );
 }",0,0,0,0
"public class RankBean {
	 private int rankID;
	 private int rankMinPosts;
	 private int rankLevel;
	 private String rankTitle;
	 private String rankImage;
	 private int rankType;
	 private int rankOption;
	 public int getRankID() {
		 return rankID;
	 }
	 public void setRankID(int rankID) {
		 this.rankID = rankID;
	 }
	 public int getRankMinPosts() {
		 return rankMinPosts;
	 }
	 public void setRankMinPosts(int rankMinPosts) {
		 this.rankMinPosts = rankMinPosts;
	 }
	 public int getRankLevel() {
		 return rankLevel;
	 }
	 public void setRankLevel(int rankLevel) {
		 this.rankLevel = rankLevel;
	 }
	 public String getRankTitle() {
		 return rankTitle;
	 }
	 public void setRankTitle(String rankTitle) {
		 this.rankTitle = StringUtil.getEmptyStringIfNull(rankTitle);
	 }
	 public String getRankImage() {
		 return rankImage;
	 }
	 public void setRankImage(String rankImage) {
		 this.rankImage = StringUtil.getEmptyStringIfNull(rankImage);
	 }
	 public int getRankType() {
		 return rankType;
	 }
	 public void setRankType(int rankType) {
		 this.rankType = rankType;
	 }
	 public int getRankOption() {
		 return rankOption;
	 }
	 public void setRankOption(int rankOption) {
		 this.rankOption = rankOption;
	 }
}",0,1,0,0
"public void setSystem(boolean value) {
	 addArg(value, ATTR_SYSTEM);
 }",0,0,0,0
"public final class NotificationSenderAdapter implements NotificationSender {
	 ModelMBeanNotificationBroadcaster broadcaster;
	 public NotificationSenderAdapter(ModelMBeanNotificationBroadcaster broadcaster) {
		 this.broadcaster = broadcaster;
	 }
	 public void sendNotification(Notification notification) {
		 try {
			 broadcaster.sendNotification(notification);
		 }
		 catch (Exception e) {
			 throw new RuntimeException(e);
		 }
	 }
}",0,0,0,0
"public class ThymeleafAnnotationValues extends AbstractAnnotationValues {
	 private String[] excludeMethods;
	 private String[] excludeViews;
	 public ThymeleafAnnotationValues(final PhysicalTypeMetadata governorPhysicalTypeMetadata) {
		 super(governorPhysicalTypeMetadata, ROO_THYMELEAF);
		 AutoPopulationUtils.populate(this, annotationMetadata);
	 }
	 public String[] getExcludeMethods() {
		 return excludeMethods;
	 }
	 public String[] getExcludeViews() {
		 return excludeViews;
	 }
}",0,1,0,0
"public abstract class AbstractAccessTask extends org.apache.tools.ant.taskdefs.ExecuteOn {
	 public AbstractAccessTask() {
		 super.setParallel(true);
		 super.setSkipEmptyFilesets(true);
	 }
	 public void setFile(File src) {
		 FileSet fs = new FileSet();
		 fs.setFile(src);
		 addFileset(fs);
	 }
	 public void setCommand(Commandline cmdl) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the command attribute"", getLocation());
	 }
	 public void setSkipEmptyFilesets(boolean skip) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the "" + ""skipemptyfileset attribute"", getLocation());
	 }
	 public void setAddsourcefile(boolean b) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the addsourcefile attribute"", getLocation());
	 }
	 protected boolean isValidOs() {
		 return getOs() == null && getOsFamily() == null ? Os.isFamily(Os.FAMILY_UNIX) : super.isValidOs();
	 }
}",0,0,0,0
"public class ComponentDetachableModel<T> implements IModel<T>, IComponentAssignedModel<T>{
	private static final long serialVersionUID = 1L;
	private transient boolean attached = false;
	public final T getObject(){
		throw new RuntimeException(""get object call not expected on a IComponentAssignedModel"");
	}
	public final void setObject(T object){
		throw new RuntimeException(""set object call not expected on a IComponentAssignedModel"");
	}
	public final boolean isAttached(){
		return attached;
	}
	protected final void setAttached(){
		attached = true;
	}
	public void detach(){
	}
	protected void attach(){
	}
	protected T getObject(Component component){
		return null;
	}
	protected void setObject(Component component, T object){
	}
	public IWrapModel<T> wrapOnAssignment(Component comp){
		return new WrapModel<T>(comp);
	}
	private class WrapModel<P> implements IWrapModel<T>{
		private static final long serialVersionUID = 1L;
		private final Component component;
		public WrapModel(Component comp){
			component = comp;
		}
		public IModel<T> getWrappedModel(){
			return ComponentDetachableModel.this;
		}
		private void attach(){
			if (!attached){
				attached = true;
				ComponentDetachableModel.this.attach();
			}
		}
		public T getObject(){
			attach();
			return ComponentDetachableModel.this.getObject(component);
		}
		public void setObject(T object){
			attach();
			ComponentDetachableModel.this.setObject(component, object);
		}
		public void detach(){
			if (attached){
				attached = false;
				ComponentDetachableModel.this.detach();
			}
		}
	}
}",0,0,0,0
"public class SlaveSynchronize {
	 private static final InternalLogger log = InternalLoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);
	 private final BrokerController brokerController;
	 private volatile String masterAddr = null;
	 public SlaveSynchronize(BrokerController brokerController) {
		 this.brokerController = brokerController;
	 }
	 public String getMasterAddr() {
		 return masterAddr;
	 }
	 public void setMasterAddr(String masterAddr) {
		 this.masterAddr = masterAddr;
	 }
	 public void syncAll() {
		 this.syncTopicConfig();
		 this.syncConsumerOffset();
		 this.syncDelayOffset();
		 this.syncSubscriptionGroupConfig();
	 }
	 private void syncTopicConfig() {
		 String masterAddrBak = this.masterAddr;
		 if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
			 try {
				 TopicConfigSerializeWrapper topicWrapper = this.brokerController.getBrokerOuterAPI().getAllTopicConfig(masterAddrBak);
				 if (!this.brokerController.getTopicConfigManager().getDataVersion() .equals(topicWrapper.getDataVersion())) {
					 this.brokerController.getTopicConfigManager().getDataVersion() .assignNewOne(topicWrapper.getDataVersion());
					 this.brokerController.getTopicConfigManager().getTopicConfigTable().clear();
					 this.brokerController.getTopicConfigManager().getTopicConfigTable() .putAll(topicWrapper.getTopicConfigTable());
					 this.brokerController.getTopicConfigManager().persist();
					 log.info(""Update slave topic config from master, {
					}
					"", masterAddrBak);
				 }
			 }
			 catch (Exception e) {
				 log.error(""SyncTopicConfig Exception, {
				}
				"", masterAddrBak, e);
			 }
		 }
	 }
	 private void syncConsumerOffset() {
		 String masterAddrBak = this.masterAddr;
		 if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
			 try {
				 ConsumerOffsetSerializeWrapper offsetWrapper = this.brokerController.getBrokerOuterAPI().getAllConsumerOffset(masterAddrBak);
				 this.brokerController.getConsumerOffsetManager().getOffsetTable() .putAll(offsetWrapper.getOffsetTable());
				 this.brokerController.getConsumerOffsetManager().persist();
				 log.info(""Update slave consumer offset from master, {
				}
				"", masterAddrBak);
			 }
			 catch (Exception e) {
				 log.error(""SyncConsumerOffset Exception, {
				}
				"", masterAddrBak, e);
			 }
		 }
	 }
	 private void syncDelayOffset() {
		 String masterAddrBak = this.masterAddr;
		 if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
			 try {
				 String delayOffset = this.brokerController.getBrokerOuterAPI().getAllDelayOffset(masterAddrBak);
				 if (delayOffset != null) {
					 String fileName = StorePathConfigHelper.getDelayOffsetStorePath(this.brokerController .getMessageStoreConfig().getStorePathRootDir());
					 try {
						 MixAll.string2File(delayOffset, fileName);
					 }
					 catch (IOException e) {
						 log.error(""Persist file Exception, {
						}
						"", fileName, e);
					 }
				 }
				 log.info(""Update slave delay offset from master, {
				}
				"", masterAddrBak);
			 }
			 catch (Exception e) {
				 log.error(""SyncDelayOffset Exception, {
				}
				"", masterAddrBak, e);
			 }
		 }
	 }
	 private void syncSubscriptionGroupConfig() {
		 String masterAddrBak = this.masterAddr;
		 if (masterAddrBak != null && !masterAddrBak.equals(brokerController.getBrokerAddr())) {
			 try {
				 SubscriptionGroupWrapper subscriptionWrapper = this.brokerController.getBrokerOuterAPI() .getAllSubscriptionGroupConfig(masterAddrBak);
				 if (!this.brokerController.getSubscriptionGroupManager().getDataVersion() .equals(subscriptionWrapper.getDataVersion())) {
					 SubscriptionGroupManager subscriptionGroupManager = this.brokerController.getSubscriptionGroupManager();
					 subscriptionGroupManager.getDataVersion().assignNewOne( subscriptionWrapper.getDataVersion());
					 subscriptionGroupManager.getSubscriptionGroupTable().clear();
					 subscriptionGroupManager.getSubscriptionGroupTable().putAll( subscriptionWrapper.getSubscriptionGroupTable());
					 subscriptionGroupManager.persist();
					 log.info(""Update slave Subscription Group from master, {
					}
					"", masterAddrBak);
				 }
			 }
			 catch (Exception e) {
				 log.error(""SyncSubscriptionGroup Exception, {
				}
				"", masterAddrBak, e);
			 }
		 }
	 }
}",1,1,0,0
"public final class S3ClientFactory {
	 private S3ClientFactory() {
		 throw new RuntimeException(""Do not instantiate a Factory class! Refer to the class "" + ""to learn how to properly use this factory implementation."");
	 }
	 public static S3Client getAWSS3Client(S3Configuration configuration, int maxConnections) {
		 return configuration.isUseIAMCredentials() ? new S3ClientIAMOptimizedImpl(configuration, maxConnections) : new S3ClientStandardImpl(configuration, maxConnections);
	 }
}",0,0,0,0
"public class MessageBean {
	 public final static int MESSAGE_READ_STATUS_DEFAULT = 0;
	 public final static int MESSAGE_READ_STATUS_READ = 1;
	 public final static int MESSAGE_TYPE_DEFAULT = 0;
	 public final static int MESSAGE_TYPE_QUOTE = 1;
	 public final static int MESSAGE_TYPE_PUBLIC = 2;
	 private int messageID;
	 private String folderName;
	 private int memberID;
	 private int messageSenderID;
	 private String messageSenderName;
	 private String messageToList;
	 private String messageCcList;
	 private String messageBccList;
	 private String messageTopic;
	 private String messageBody;
	 private int messageType;
	 private int messageOption;
	 private int messageStatus;
	 private int messageReadStatus;
	 private int messageNotify;
	 private String messageIcon;
	 private int messageAttachCount;
	 private String messageIP;
	 private Timestamp messageCreationDate;
	 public int getMessageID() {
		 return messageID;
	 }
	 public void setMessageID(int messageID) {
		 this.messageID = messageID;
	 }
	 public String getFolderName() {
		 return folderName;
	 }
	 public void setFolderName(String folderName) {
		 this.folderName = folderName;
	 }
	 public int getMemberID() {
		 return memberID;
	 }
	 public void setMemberID(int memberID) {
		 this.memberID = memberID;
	 }
	 public int getMessageSenderID() {
		 return messageSenderID;
	 }
	 public void setMessageSenderID(int messageSenderID) {
		 this.messageSenderID = messageSenderID;
	 }
	 public String getMessageSenderName() {
		 return messageSenderName;
	 }
	 public void setMessageSenderName(String messageSenderName) {
		 this.messageSenderName = messageSenderName;
	 }
	 public String getMessageToList() {
		 return messageToList;
	 }
	 public void setMessageToList(String messageToList) {
		 this.messageToList = StringUtil.getEmptyStringIfNull(messageToList);
	 }
	 public String getMessageCcList() {
		 return messageCcList;
	 }
	 public void setMessageCcList(String messageCcList) {
		 this.messageCcList = StringUtil.getEmptyStringIfNull(messageCcList);
	 }
	 public String getMessageBccList() {
		 return messageBccList;
	 }
	 public void setMessageBccList(String messageBccList) {
		 this.messageBccList = StringUtil.getEmptyStringIfNull(messageBccList);
	 }
	 public String getMessageTopic() {
		 return messageTopic;
	 }
	 public void setMessageTopic(String messageTopic) {
		 this.messageTopic = StringUtil.getEmptyStringIfNull(messageTopic);
	 }
	 public String getMessageBody() {
		 return messageBody;
	 }
	 public void setMessageBody(String messageBody) {
		 this.messageBody = StringUtil.getEmptyStringIfNull(messageBody);
	 }
	 public int getMessageType() {
		 return messageType;
	 }
	 public void setMessageType(int messageType) {
		 this.messageType = messageType;
	 }
	 public int getMessageOption() {
		 return messageOption;
	 }
	 public void setMessageOption(int messageOption) {
		 this.messageOption = messageOption;
	 }
	 public int getMessageStatus() {
		 return messageStatus;
	 }
	 public void setMessageStatus(int messageStatus) {
		 this.messageStatus = messageStatus;
	 }
	 public int getMessageReadStatus() {
		 return messageReadStatus;
	 }
	 public void setMessageReadStatus(int messageReadStatus) {
		 this.messageReadStatus = messageReadStatus;
	 }
	 public int getMessageNotify() {
		 return messageNotify;
	 }
	 public void setMessageNotify(int messageNotify) {
		 this.messageNotify = messageNotify;
	 }
	 public String getMessageIcon() {
		 return messageIcon;
	 }
	 public void setMessageIcon(String messageIcon) {
		 this.messageIcon = StringUtil.getEmptyStringIfNull(messageIcon);
	 }
	 public int getMessageAttachCount() {
		 return messageAttachCount;
	 }
	 public void setMessageAttachCount(int messageAttachCount) {
		 this.messageAttachCount = messageAttachCount;
	 }
	 public String getMessageIP() {
		 return messageIP;
	 }
	 public void setMessageIP(String messageIP) {
		 this.messageIP = messageIP;
	 }
	 public Timestamp getMessageCreationDate() {
		 return messageCreationDate;
	 }
	 public void setMessageCreationDate(Timestamp messageCreationDate) {
		 this.messageCreationDate = messageCreationDate;
	 }
	 private MemberBean memberBean = null;
	 private Collection attachmentBeans = null;
	 public MemberBean getMemberBean() {
		 return memberBean;
	 }
	 public void setMemberBean(MemberBean memberBean) {
		 this.memberBean = memberBean;
	 }
	 public Collection getAttachmentBeans() {
		 return attachmentBeans;
	 }
	 public void setAttachmentBeans(Collection attachmentBeans) {
		 this.attachmentBeans = attachmentBeans;
	 }
}",0,1,0,0
"private void executeGet(Tree statement) throws TException, NotFoundException, InvalidRequestException, UnavailableException, TimedOutException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException {
	 if (!CliMain.isConnected() || !hasKeySpace()) return;
	 Tree columnFamilySpec = statement.getChild(0);
	 String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
	 ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
	 int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
	 CfDef cfDef = getCfDef(columnFamily);
	 boolean isSuper = cfDef.column_type.equals(""Super"");
	 byte[] superColumnName = null;
	 ByteBuffer columnName;
	 Tree typeTree = null;
	 Tree limitTree = null;
	 int limit = 1000000;
	 if (statement.getChildCount() >= 2) {
		 if (statement.getChild(1).getType() == CliParser.CONVERT_TO_TYPE) {
			 typeTree = statement.getChild(1).getChild(0);
			 if (statement.getChildCount() == 3) limitTree = statement.getChild(2).getChild(0);
		 }
		 else {
			 limitTree = statement.getChild(1).getChild(0);
		 }
	 }
	 if (limitTree != null) {
		 limit = Integer.parseInt(limitTree.getText());
		 if (limit == 0) {
			 throw new IllegalArgumentException(""LIMIT should be greater than zero."");
		 }
	 }
	 if (columnSpecCnt == 0) {
		 doSlice(keySpace, key, columnFamily, superColumnName, limit);
		 return;
	 }
	 else if (columnSpecCnt == 1) {
		 columnName = getColumnName(columnFamily, columnFamilySpec.getChild(2));
		 if (isSuper) {
			 superColumnName = columnName.array();
			 doSlice(keySpace, key, columnFamily, superColumnName, limit);
			 return;
		 }
	 }
	 else if (columnSpecCnt == 2) {
		 superColumnName = getColumnName(columnFamily, columnFamilySpec.getChild(2)).array();
		 columnName = getSubColumnName(columnFamily, columnFamilySpec.getChild(3));
	 }
	 else {
		 sessionState.out.println(""Invalid row, super column, or column specification."");
		 return;
	 }
	 AbstractType validator = getValidatorForValue(cfDef, TBaseHelper.byteBufferToByteArray(columnName));
	 ColumnPath path = new ColumnPath(columnFamily);
	 if(superColumnName != null) path.setSuper_column(superColumnName);
	 path.setColumn(columnName);
	 if (isCounterCF(cfDef)) {
		 doGetCounter(key, path);
		 return;
	 }
	 Column column;
	 try {
		 column = thriftClient.get(key, path, consistencyLevel).column;
	 }
	 catch (NotFoundException e) {
		 sessionState.out.println(""Value was not found"");
		 return;
	 }
	 byte[] columnValue = column.getValue();
	 String valueAsString;
	 if (typeTree != null) {
		 String typeName = CliUtils.unescapeSQLString(typeTree.getText());
		 AbstractType valueValidator = getFormatType(typeName);
		 valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));
		 updateColumnMetaData(cfDef, columnName, valueValidator.toString());
	 }
	 else {
		 valueAsString = (validator == null) ? new String(columnValue, Charsets.UTF_8) : validator.getString(ByteBuffer.wrap(columnValue));
	 }
	 String formattedColumnName = isSuper ? formatSubcolumnName(keySpace, columnFamily, column.name) : formatColumnName(keySpace, columnFamily, column.name);
	 sessionState.out.printf(""=> (column=%s, value=%s, timestamp=%d%s)%n"", formattedColumnName, valueAsString, column.timestamp, column.isSetTtl() ? String.format("", ttl=%d"", column.getTtl()) : """");
 }",0,0,1,0
"public class CertificatePolicyMap {
	 private CertificatePolicyId issuerDomain;
	 private CertificatePolicyId subjectDomain;
	 public CertificatePolicyMap(CertificatePolicyId issuer, CertificatePolicyId subject) {
		 this.issuerDomain = issuer;
		 this.subjectDomain = subject;
	 }
	 public CertificatePolicyMap(DerValue val) throws IOException {
		 if (val.tag != DerValue.tag_Sequence) {
			 throw new IOException(""Invalid encoding for CertificatePolicyMap"");
		 }
		 issuerDomain = new CertificatePolicyId(val.data.getDerValue());
		 subjectDomain = new CertificatePolicyId(val.data.getDerValue());
	 }
	 public CertificatePolicyId getIssuerIdentifier() {
		 return (issuerDomain);
	 }
	 public CertificatePolicyId getSubjectIdentifier() {
		 return (subjectDomain);
	 }
	 public String toString() {
		 String s = ""CertificatePolicyMap: [\n"" + ""IssuerDomain:"" + issuerDomain.toString() + ""SubjectDomain:"" + subjectDomain.toString() + ""]\n"";
		 return (s);
	 }
	 public void encode(DerOutputStream out) throws IOException {
		 DerOutputStream tmp = new DerOutputStream();
		 issuerDomain.encode(tmp);
		 subjectDomain.encode(tmp);
		 out.write(DerValue.tag_Sequence,tmp);
	 }
}",0,1,0,0
"public class Customer1762 {
	 private long id;
	private String firstName;
	private String lastName;
	protected Customer1762() {
	}
	public Customer1762(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public String toString() {
		return String.format(""Customer1762[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}
}",0,1,0,0
"protected void runExec(Execute exe) throws BuildException {
	 int totalFiles = 0;
	 int totalDirs = 0;
	 boolean haveExecuted = false;
	 try {
		 Vector fileNames = new Vector();
		 Vector baseDirs = new Vector();
		 final int size = filesets.size();
		 for (int i = 0;
		 i < size;
		 i++) {
			 String currentType = type;
			 AbstractFileSet fs = (AbstractFileSet) filesets.elementAt(i);
			 if (fs instanceof DirSet) {
				 if (!FileDirBoth.DIR.equals(type)) {
					 log(""Found a nested dirset but type is "" + type + "". "" + ""Temporarily switching to type=\""dir\"" on the"" + "" assumption that you really did mean"" + "" <dirset> not <fileset>."", Project.MSG_DEBUG);
					 currentType = FileDirBoth.DIR;
				 }
			 }
			 File base = fs.getDir(getProject());
			 DirectoryScanner ds = fs.getDirectoryScanner(getProject());
			 if (!FileDirBoth.DIR.equals(currentType)) {
				 String[] s = getFiles(base, ds);
				 for (int j = 0;
				 j < s.length;
				 j++) {
					 totalFiles++;
					 fileNames.addElement(s[j]);
					 baseDirs.addElement(base);
				 }
			 }
			 if (!FileDirBoth.FILE.equals(currentType)) {
				 String[] s = getDirs(base, ds);
				 for (int j = 0;
				 j < s.length;
				 j++) {
					 totalDirs++;
					 fileNames.addElement(s[j]);
					 baseDirs.addElement(base);
				 }
			 }
			 if (fileNames.size() == 0 && skipEmpty) {
				 logSkippingFileset(currentType, ds, base);
				 continue;
			 }
			 if (!parallel) {
				 String[] s = new String[fileNames.size()];
				 fileNames.copyInto(s);
				 for (int j = 0;
				 j < s.length;
				 j++) {
					 String[] command = getCommandline(s[j], base);
					 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
					 exe.setCommandline(command);
					 if (redirectorElement != null) {
						 setupRedirector();
						 redirectorElement.configure(redirector, s[j]);
					 }
					 if (redirectorElement != null || haveExecuted) {
						 exe.setStreamHandler(redirector.createHandler());
					 }
					 runExecute(exe);
					 haveExecuted = true;
				 }
				 fileNames.removeAllElements();
				 baseDirs.removeAllElements();
			 }
		 }
		 if (resources != null) {
			 Iterator iter = resources.iterator();
			 while (iter.hasNext()) {
				 Resource res = (Resource) iter.next();
				 if (!res.isExists() && ignoreMissing) {
					 continue;
				 }
				 File base = null;
				 String name = res.getName();
				 FileProvider fp = (FileProvider) res.as(FileProvider.class);
				 if (fp != null) {
					 FileResource fr = ResourceUtils.asFileResource(fp);
					 base = fr.getBaseDir();
					 if (base == null) {
						 name = fr.getFile().getAbsolutePath();
					 }
				 }
				 if (restrict(new String[] {
				name}
				, base).length == 0) {
					 continue;
				 }
				 if ((!res.isDirectory() || !res.isExists()) && !FileDirBoth.DIR.equals(type)) {
					 totalFiles++;
				 }
				 else if (res.isDirectory() && !FileDirBoth.FILE.equals(type)) {
					 totalDirs++;
				 }
				 else {
					 continue;
				 }
				 baseDirs.add(base);
				 fileNames.add(name);
				 if (!parallel) {
					 String[] command = getCommandline(name, base);
					 log(Commandline.describeCommand(command), Project.MSG_VERBOSE);
					 exe.setCommandline(command);
					 if (redirectorElement != null) {
						 setupRedirector();
						 redirectorElement.configure(redirector, name);
					 }
					 if (redirectorElement != null || haveExecuted) {
						 exe.setStreamHandler(redirector.createHandler());
					 }
					 runExecute(exe);
					 haveExecuted = true;
					 fileNames.removeAllElements();
					 baseDirs.removeAllElements();
				 }
			 }
		 }
		 if (parallel && (fileNames.size() > 0 || !skipEmpty)) {
			 runParallel(exe, fileNames, baseDirs);
			 haveExecuted = true;
		 }
		 if (haveExecuted) {
			 log(""Applied "" + cmdl.getExecutable() + "" to "" + totalFiles + "" file"" + (totalFiles != 1 ? ""s"" : """") + "" and "" + totalDirs + "" director"" + (totalDirs != 1 ? ""ies"" : ""y"") + ""."", verbose ? Project.MSG_INFO : Project.MSG_VERBOSE);
		 }
	 }
	 catch (IOException e) {
		 throw new BuildException(""Execute failed: "" + e, e, getLocation());
	 }
	 finally {
		 logFlush();
		 redirector.setAppendProperties(false);
		 redirector.setProperties();
	 }
 }",0,0,1,0
"public class ConstraintBasePanel extends FormComponentPanel{
	 private static final long serialVersionUID = 1L;
	 private static final String CLS_NM = ConstraintPanel.class.getName();
	 private static final Logger log = Logger.getLogger( CLS_NM );
	 protected static final String TIMEOUT = ""timeout"";
	 protected static final String SUNDAY = ""sunday"";
	 protected static final String MONDAY = ""monday"";
	 protected static final String TUESDAY = ""tuesday"";
	 protected static final String WEDNESDAY = ""wednesday"";
	 protected static final String THURSDAY = ""thursday"";
	 protected static final String FRIDAY = ""friday"";
	 protected static final String SATURDAY = ""saturday"";
	 protected static final String BEGIN_TIME = ""beginTime"";
	 protected static final String END_TIME = ""endTime"";
	 protected static final String BEGIN_DATE = ""beginDate"";
	 protected static final String END_DATE = ""endDate"";
	 protected static final String BEGIN_LOCK_DATE = ""beginLockDate"";
	 protected static final String END_LOCK_DATE = ""endLockDate"";
	 protected static final String DAY1 = ""1"";
	 protected static final String DAY2 = ""2"";
	 protected static final String DAY3 = ""3"";
	 protected static final String DAY4 = ""4"";
	 protected static final String DAY5 = ""5"";
	 protected static final String DAY6 = ""6"";
	 protected static final String DAY7 = ""7"";
	 protected Date beginTime;
	 protected Date beginDate;
	 protected Date endTime;
	 protected Date endDate;
	 protected Date beginLockDate;
	 protected Date endLockDate;
	 protected TimePicker beginTimeTP;
	 protected TimePicker endTimeTP;
	 protected DatePicker beginDateDP;
	 protected DatePicker endDateDP;
	 protected DatePicker beginLockDateDP;
	 protected DatePicker endLockDateDP;
	 protected CheckBox sundayCB;
	 protected CheckBox mondayCB;
	 protected CheckBox tuesdayCB;
	 protected CheckBox wednesdayCB;
	 protected CheckBox thursdayCB;
	 protected CheckBox fridayCB;
	 protected CheckBox saturdayCB;
	 protected Boolean sunday = false;
	 protected Boolean monday = false;
	 protected Boolean tuesday = false;
	 protected Boolean wednesday = false;
	 protected Boolean thursday = false;
	 protected Boolean friday = false;
	 protected Boolean saturday = false;
	 public ConstraintBasePanel( String id, final IModel constraint ) {
		 super( id, constraint );
		 final Spinner<Integer> timeout = new Spinner<>( TIMEOUT );
		 timeout.setRequired( false );
		 add( timeout );
		 sundayCB = new CheckBox( SUNDAY, new PropertyModel<Boolean>( this, SUNDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setSunday( isDayOfWeek( constraint, DAY1 ) );
				 }
			 }
		 }
		;
		 add( sundayCB );
		 mondayCB = new CheckBox( ""monday"", new PropertyModel<Boolean>( this, MONDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setMonday( isDayOfWeek( constraint, DAY2 ) );
				 }
			 }
		 }
		;
		 add( mondayCB );
		 tuesdayCB = new CheckBox( TUESDAY, new PropertyModel<Boolean>( this, TUESDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setTuesday( isDayOfWeek( constraint, DAY3 ) );
				 }
			 }
		 }
		;
		 add( tuesdayCB );
		 wednesdayCB = new CheckBox( WEDNESDAY, new PropertyModel<Boolean>( this, WEDNESDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setWednesday( isDayOfWeek( constraint, DAY4 ) );
				 }
			 }
		 }
		;
		 add( wednesdayCB );
		 thursdayCB = new CheckBox( THURSDAY, new PropertyModel<Boolean>( this, THURSDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setThursday( isDayOfWeek( constraint, DAY5 ) );
				 }
			 }
		 }
		;
		 add( thursdayCB );
		 fridayCB = new CheckBox( FRIDAY, new PropertyModel<Boolean>( this, FRIDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setFriday( isDayOfWeek( constraint, DAY6 ) );
				 }
			 }
		 }
		;
		 add( fridayCB );
		 saturdayCB = new CheckBox( SATURDAY, new PropertyModel<Boolean>( this, SATURDAY ) ) {
			 private static final long serialVersionUID = 1L;
			 protected void onBeforeRender() {
				 if ( this.getParent().getDefaultModelObject() != null ) {
					 super.onBeforeRender();
					 Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
					 setSaturday( isDayOfWeek( constraint, DAY7 ) );
				 }
			 }
		 }
		;
		 add( saturdayCB );
	 }
	 public void convertInput() {
		 Constraint constraint = ( Constraint ) getDefaultModelObject();
		 if ( constraint != null ) {
			 constraint.setBeginTime( convertTime( beginTimeTP ) );
			 constraint.setEndTime( convertTime( endTimeTP ) );
			 constraint.setBeginDate( convertDate( beginDateDP ) );
			 constraint.setEndDate( convertDate( endDateDP ) );
			 constraint.setBeginLockDate( convertDate( beginLockDateDP ) );
			 constraint.setEndLockDate( convertDate( endLockDateDP ) );
			 setSunday( sundayCB.getConvertedInput() );
			 setMonday( mondayCB.getConvertedInput() );
			 setTuesday( tuesdayCB.getConvertedInput() );
			 setWednesday( wednesdayCB.getConvertedInput() );
			 setThursday( thursdayCB.getConvertedInput() );
			 setFriday( fridayCB.getConvertedInput() );
			 setSaturday( saturdayCB.getConvertedInput() );
			 String szDayMask = """";
			 if ( sunday ) szDayMask += DAY1;
			 if ( monday ) szDayMask += DAY2;
			 if ( tuesday ) szDayMask += DAY3;
			 if ( wednesday ) szDayMask += DAY4;
			 if ( thursday ) szDayMask += DAY5;
			 if ( friday ) szDayMask += DAY6;
			 if ( saturday ) szDayMask += DAY7;
			 constraint.setDayMask( szDayMask );
			 setConvertedInput( constraint );
		 }
		 else {
			 log.warn( ""constraint was null"" );
		 }
	 }
	 protected boolean isDayOfWeek( Constraint constraint, String szDay ) {
		 boolean isSet = false;
		 if ( constraint != null && constraint.getDayMask() != null && ( constraint.getDayMask().contains( szDay ) || constraint.getDayMask().equals( ""all"" ) ) ) {
			 isSet = true;
		 }
		 return isSet;
	 }
	 protected String convertTime( TimePicker time ) {
		 String szTime = null;
		 if ( time != null ) {
			 Date localDate = time.getConvertedInput();
			 if ( localDate != null ) {
				 Calendar calendar = Calendar.getInstance();
				 calendar.setTime( localDate );
				 log.debug( ""localDate="" + localDate.toString() );
				 if ( calendar.get( Calendar.HOUR_OF_DAY ) < 10 ) szTime = ""0"" + calendar.get( Calendar.HOUR_OF_DAY );
				 else szTime = """" + calendar.get( Calendar.HOUR_OF_DAY );
				 if ( calendar.get( Calendar.MINUTE ) < 10 ) szTime += ""0"" + calendar.get( Calendar.MINUTE );
				 else szTime += """" + calendar.get( Calendar.MINUTE );
			 }
		 }
		 return szTime;
	 }
	 protected String convertDate( DatePicker date ) {
		 String szDate = null;
		 if ( date != null ) {
			 Date localDate = date.getConvertedInput();
			 if ( localDate != null ) {
				 Calendar calendar = Calendar.getInstance();
				 calendar.setTime( localDate );
				 log.debug( ""localDate="" + localDate.toString() );
				 szDate = """" + calendar.get( Calendar.YEAR );
				 if ( ( calendar.get( Calendar.MONTH ) + 1 ) < 10 ) szDate += ""0"" + ( calendar.get( Calendar.MONTH ) + 1 );
				 else szDate += """" + ( calendar.get( Calendar.MONTH ) + 1 );
				 if ( calendar.get( Calendar.DAY_OF_MONTH ) < 10 ) szDate += ""0"" + calendar.get( Calendar.DAY_OF_MONTH );
				 else szDate += """" + calendar.get( Calendar.DAY_OF_MONTH );
			 }
		 }
		 return szDate;
	 }
	 protected Date renderTime( Date date, String szTime ) {
		 if ( szTime != null ) {
			 Calendar calendar = Calendar.getInstance();
			 try {
				 int hours = Integer.valueOf( szTime.substring( 0, 2 ) );
				 int minutes = Integer.valueOf( szTime.substring( 2, 4 ) );
				 if(hours == 0) {
					 hours = 24;
				 }
				 calendar.set( 0, 0, 0, hours, minutes );
				 date = calendar.getTime();
			 }
			 catch ( StringIndexOutOfBoundsException e ) {
				 String warning = CLS_NM + "".renderTime bad time: "" + szTime;
				 log.warn( warning );
			 }
		 }
		 else {
			 date = null;
		 }
		 return date;
	 }
	 protected Date renderDate( Date date, String szDate ) {
		 if ( szDate != null && !szDate.equalsIgnoreCase( ""none"" ) ) {
			 Calendar calendar = Calendar.getInstance();
			 try {
				 int years = Integer.valueOf( szDate.substring( 0, 4 ) );
				 int months = Integer.valueOf( szDate.substring( 4, 6 ) );
				 months = months - 1;
				 int days = Integer.valueOf( szDate.substring( 6, 8 ) );
				 calendar.set( years, months, days, 0, 0 );
				 date = calendar.getTime();
			 }
			 catch ( StringIndexOutOfBoundsException e ) {
				 String warning = CLS_NM + "".renderDate bad date: "" + szDate;
				 log.warn( warning );
			 }
		 }
		 else {
			 date = null;
		 }
		 return date;
	 }
	 protected Boolean getSunday() {
		 return sunday;
	 }
	 protected void setSunday( Boolean sunday ) {
		 this.sunday = sunday;
	 }
	 protected Boolean getMonday() {
		 return monday;
	 }
	 protected void setMonday( Boolean monday ) {
		 this.monday = monday;
	 }
	 protected Boolean getTuesday() {
		 return tuesday;
	 }
	 protected void setTuesday( Boolean tuesday ) {
		 this.tuesday = tuesday;
	 }
	 protected Boolean getWednesday() {
		 return wednesday;
	 }
	 protected void setWednesday( Boolean wednesday ) {
		 this.wednesday = wednesday;
	 }
	 protected Boolean getThursday() {
		 return thursday;
	 }
	 protected void setThursday( Boolean thursday ) {
		 this.thursday = thursday;
	 }
	 protected Boolean getFriday() {
		 return friday;
	 }
	 protected void setFriday( Boolean friday ) {
		 this.friday = friday;
	 }
	 protected Boolean getSaturday() {
		 return saturday;
	 }
	 protected void setSaturday( Boolean saturday ) {
		 this.saturday = saturday;
	 }
}",1,1,0,0
"public class Socket {
	 public static final int SOCK_STREAM = 0;
	 public static final int SOCK_DGRAM = 1;
	 public static final int APR_SO_LINGER = 1;
	 public static final int APR_SO_KEEPALIVE = 2;
	 public static final int APR_SO_DEBUG = 4;
	 public static final int APR_SO_NONBLOCK = 8;
	 public static final int APR_SO_REUSEADDR = 16;
	 public static final int APR_SO_SNDBUF = 64;
	 public static final int APR_SO_RCVBUF = 128;
	 public static final int APR_SO_DISCONNECTED = 256;
	 public static final int APR_TCP_NODELAY = 512;
	 public static final int APR_TCP_NOPUSH = 1024;
	 public static final int APR_RESET_NODELAY = 2048;
	 public static final int APR_INCOMPLETE_READ = 4096;
	 public static final int APR_INCOMPLETE_WRITE = 8192;
	 public static final int APR_IPV6_V6ONLY = 16384;
	 public static final int APR_TCP_DEFER_ACCEPT = 32768;
	 public static final int APR_SHUTDOWN_READ = 0;
	 public static final int APR_SHUTDOWN_WRITE = 1;
	 public static final int APR_SHUTDOWN_READWRITE = 2;
	 public static final int APR_IPV4_ADDR_OK = 0x01;
	 public static final int APR_IPV6_ADDR_OK = 0x02;
	 public static final int APR_UNSPEC = 0;
	 public static final int APR_INET = 1;
	 public static final int APR_INET6 = 2;
	 public static final int APR_PROTO_TCP = 6;
	 public static final int APR_PROTO_UDP = 17;
	 public static final int APR_PROTO_SCTP = 132;
	 public static final int APR_LOCAL = 0;
	 public static final int APR_REMOTE = 1;
	 public static final int SOCKET_GET_POOL = 0;
	 public static final int SOCKET_GET_IMPL = 1;
	 public static final int SOCKET_GET_APRS = 2;
	 public static final int SOCKET_GET_TYPE = 3;
	 public static native long create(int family, int type, int protocol, long cont) throws Exception;
	 public static native int shutdown(long thesocket, int how);
	 public static native int close(long thesocket);
	 public static native void destroy(long thesocket);
	 public static native int bind(long sock, long sa);
	 public static native int listen(long sock, int backlog);
	 public static native long acceptx(long sock, long pool) throws Exception;
	 public static native long accept(long sock) throws Exception;
	 public static native int acceptfilter(long sock, String name, String args);
	 public static native boolean atmark(long sock);
	 public static native int connect(long sock, long sa);
	 public static native int send(long sock, byte[] buf, int offset, int len);
	 public static native int sendb(long sock, ByteBuffer buf, int offset, int len);
	 public static native int sendib(long sock, ByteBuffer buf, int offset, int len);
	 public static native int sendbb(long sock, int offset, int len);
	 public static native int sendibb(long sock, int offset, int len);
	 public static native int sendv(long sock, byte[][] vec);
	 public static native int sendto(long sock, long where, int flags, byte[] buf, int offset, int len);
	 public static native int recv(long sock, byte[] buf, int offset, int nbytes);
	 public static native int recvt(long sock, byte[] buf, int offset, int nbytes, long timeout);
	 public static native int recvb(long sock, ByteBuffer buf, int offset, int nbytes);
	 public static native int recvbb(long sock, int offset, int nbytes);
	 public static native int recvbt(long sock, ByteBuffer buf, int offset, int nbytes, long timeout);
	 public static native int recvbbt(long sock, int offset, int nbytes, long timeout);
	 public static native int recvfrom(long from, long sock, int flags, byte[] buf, int offset, int nbytes);
	 public static native int optSet(long sock, int opt, int on);
	 public static native int optGet(long sock, int opt) throws Exception;
	 public static native int timeoutSet(long sock, long t);
	 public static native long timeoutGet(long sock) throws Exception;
	 public static native long sendfile(long sock, long file, byte [][] headers, byte[][] trailers, long offset, long len, int flags);
	 public static native long sendfilen(long sock, long file, long offset, long len, int flags);
	 public static native long pool(long thesocket) throws Exception;
	 private static native long get(long socket, int what);
	 public static native void setsbb(long sock, ByteBuffer buf);
	 public static native void setrbb(long sock, ByteBuffer buf);
	 public static native int dataSet(long sock, String key, Object data);
	 public static native Object dataGet(long sock, String key);
}",1,1,0,0
"public class Attrib extends ExecuteOn {
	 private static final String ATTR_READONLY = ""R"";
	 private static final String ATTR_ARCHIVE = ""A"";
	 private static final String ATTR_SYSTEM = ""S"";
	 private static final String ATTR_HIDDEN = ""H"";
	 private static final String SET = ""+"";
	 private static final String UNSET = ""-"";
	 private boolean haveAttr = false;
	 public Attrib() {
		 super.setExecutable(""attrib"");
		 super.setParallel(false);
	 }
	 public void setFile(File src) {
		 FileSet fs = new FileSet();
		 fs.setFile(src);
		 addFileset(fs);
	 }
	 public void setReadonly(boolean value) {
		 addArg(value, ATTR_READONLY);
	 }
	 public void setArchive(boolean value) {
		 addArg(value, ATTR_ARCHIVE);
	 }
	 public void setSystem(boolean value) {
		 addArg(value, ATTR_SYSTEM);
	 }
	 public void setHidden(boolean value) {
		 addArg(value, ATTR_HIDDEN);
	 }
	 protected void checkConfiguration() {
		 if (!haveAttr()) {
			 throw new BuildException(""Missing attribute parameter"", getLocation());
		 }
		 super.checkConfiguration();
	 }
	 public void setExecutable(String e) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the executable attribute"", getLocation());
	 }
	 public void setCommand(String e) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the command attribute"", getLocation());
	 }
	 public void setAddsourcefile(boolean b) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the addsourcefile attribute"", getLocation());
	 }
	 public void setSkipEmptyFilesets(boolean skip) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the "" + ""skipemptyfileset attribute"", getLocation());
	 }
	 public void setParallel(boolean parallel) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the parallel attribute"", getLocation());
	 }
	 public void setMaxParallel(int max) {
		 throw new BuildException(getTaskType() + "" doesn\'t support the maxparallel attribute"", getLocation());
	 }
	 protected boolean isValidOs() {
		 return Os.isFamily(""windows"") && super.isValidOs();
	 }
	 private static String getSignString(boolean attr) {
		 return (attr ? SET : UNSET);
	 }
	 private void addArg(boolean sign, String attribute) {
		 createArg().setValue(getSignString(sign) + attribute);
		 haveAttr = true;
	 }
	 private boolean haveAttr() {
		 return haveAttr;
	 }
}",0,0,0,0
"public boolean isQuirkCssBorderCollapseFor0Padding(){
	return quirkCssBorderCollapseFor0Padding;
}",0,0,0,0
"public Bitmap(String filename, boolean isLinear) throws IOException {
	 if (filename.endsWith("".hdr"")) {
		 isHDR = true;
		 FileInputStream f = new FileInputStream(filename);
		 boolean parseWidth = false, parseHeight = false;
		 width = height = 0;
		 int last = 0;
		 while (width == 0 || height == 0 || last != '\n') {
			 int n = f.read();
			 switch (n) {
				 case 'Y': parseHeight = last == '-';
				 parseWidth = false;
				 break;
				 case 'X': parseHeight = false;
				 parseWidth = last == '+';
				 break;
				 case ' ': parseWidth &= width == 0;
				 parseHeight &= height == 0;
				 break;
				 case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': if (parseHeight) height = 10 * height + (n - '0');
				 else if (parseWidth) width = 10 * width + (n - '0');
				 break;
				 default: parseWidth = parseHeight = false;
				 break;
			 }
			 last = n;
		 }
		 pixels = new int[width * height];
		 if ((width < 8) || (width > 0x7fff)) {
			 readFlatRGBE(f, 0, width * height);
			 return;
		 }
		 int rasterPos = 0;
		 int numScanlines = height;
		 int[] scanlineBuffer = new int[4 * width];
		 while (numScanlines > 0) {
			 int r = f.read();
			 int g = f.read();
			 int b = f.read();
			 int e = f.read();
			 if ((r != 2) || (g != 2) || ((b & 0x80) != 0)) {
				 pixels[rasterPos] = (r << 24) | (g << 16) | (b << 8) | e;
				 readFlatRGBE(f, rasterPos + 1, width * numScanlines - 1);
				 return;
			 }
			 if (((b << 8) | e) != width) {
				 System.out.println(""Invalid scanline width"");
				 return;
			 }
			 int p = 0;
			 for (int i = 0;
			 i < 4;
			 i++) {
				 if (p % width != 0) System.out.println(""Unaligned access to scanline data"");
				 int end = (i + 1) * width;
				 while (p < end) {
					 int b0 = f.read();
					 int b1 = f.read();
					 if (b0 > 128) {
						 int count = b0 - 128;
						 if ((count == 0) || (count > (end - p))) {
							 System.out.println(""Bad scanline data - invalid RLE run"");
							 return;
						 }
						 while (count-- > 0) {
							 scanlineBuffer[p] = b1;
							 p++;
						 }
					 }
					 else {
						 int count = b0;
						 if ((count == 0) || (count > (end - p))) {
							 System.out.println(""Bad scanline data - invalid count"");
							 return;
						 }
						 scanlineBuffer[p] = b1;
						 p++;
						 if (--count > 0) {
							 for (int x = 0;
							 x < count;
							 x++) scanlineBuffer[p + x] = f.read();
							 p += count;
						 }
					 }
				 }
			 }
			 for (int i = 0;
			 i < width;
			 i++) {
				 r = scanlineBuffer[i];
				 g = scanlineBuffer[i + width];
				 b = scanlineBuffer[i + 2 * width];
				 e = scanlineBuffer[i + 3 * width];
				 pixels[rasterPos] = (r << 24) | (g << 16) | (b << 8) | e;
				 rasterPos++;
			 }
			 numScanlines--;
		 }
		 for (int y = 0, i = 0, ir = (height - 1) * width;
		 y < height / 2;
		 y++, ir -= width) {
			 for (int x = 0, i2 = ir;
			 x < width;
			 x++, i++, i2++) {
				 int t = pixels[i];
				 pixels[i] = pixels[i2];
				 pixels[i2] = t;
			 }
		 }
	 }
	 else if (filename.endsWith("".tga"")) {
		 isHDR = false;
		 FileInputStream f = new FileInputStream(filename);
		 int pix_ptr = 0, pix = 0, r, j;
		 byte[] read = new byte[4];
		 int idsize = f.read() & 0xFF;
		 f.read();
		 int datatype = f.read() & 0xFF;
		 f.read();
		 f.read();
		 f.read();
		 f.read();
		 f.read();
		 f.read();
		 f.read();
		 f.read();
		 f.read();
		 width = (f.read() & 0xFF);
		 width |= ((f.read() & 0xFF) << 8);
		 height = (f.read() & 0xFF);
		 height |= ((f.read() & 0xFF) << 8);
		 pixels = new int[width * height];
		 int bpp = (f.read() & 0xFF) / 8;
		 int imgdscr = (f.read() & 0xFF);
		 if (idsize != 0) f.skip(idsize);
		 switch (datatype) {
			 case 10: while (pix_ptr < (width * height)) {
				 r = (f.read() & 0xFF);
				 if ((r & 128) == 128) {
					 r &= 127;
					 f.read(read, 0, bpp);
					 pix = (read[2] & 0xFF) << 16;
					 pix |= (read[1] & 0xFF) << 8;
					 pix |= (read[0] & 0xFF);
					 pix = isLinear ? pix : RGBSpace.SRGB.rgbToLinear(pix);
					 for (j = 0;
					 j <= r;
					 j++, pix_ptr++) pixels[pix_ptr] = pix;
				 }
				 else {
					 r &= 127;
					 for (j = 0;
					 j <= r;
					 j++, pix_ptr++) {
						 f.read(read, 0, bpp);
						 pix = ((read[2] & 0xFF) << 16);
						 pix |= ((read[1] & 0xFF) << 8);
						 pix |= ((read[0] & 0xFF));
						 pixels[pix_ptr] = isLinear ? pix : RGBSpace.SRGB.rgbToLinear(pix);
					 }
				 }
			 }
			 break;
			 case 2: for (pix_ptr = 0;
			 pix_ptr < (width * height);
			 pix_ptr++) {
				 f.read(read, 0, bpp);
				 pix = ((read[2] & 0xFF) << 16);
				 pix |= ((read[1] & 0xFF) << 8);
				 pix |= ((read[0] & 0xFF));
				 pixels[pix_ptr] = isLinear ? pix : RGBSpace.SRGB.rgbToLinear(pix);
			 }
			 break;
			 default: UI.printWarning(Module.IMG, ""Unsupported TGA datatype: %s"", datatype);
			 break;
		 }
		 if ((imgdscr & 32) == 32) {
			 pix_ptr = 0;
			 for (int y = 0;
			 y < (height / 2);
			 y++) for (int x = 0;
			 x < width;
			 x++) {
				 int t = pixels[pix_ptr];
				 pixels[pix_ptr] = pixels[(height - y - 1) * width + x];
				 pixels[(height - y - 1) * width + x] = t;
				 pix_ptr++;
			 }
		 }
		 f.close();
	 }
	 else {
		 BufferedImage bi = ImageIO.read(new File(filename));
		 width = bi.getWidth();
		 height = bi.getHeight();
		 isHDR = false;
		 pixels = new int[width * height];
		 for (int y = 0, index = 0;
		 y < height;
		 y++) {
			 for (int x = 0;
			 x < width;
			 x++, index++) {
				 int rgb = bi.getRGB(x, height - 1 - y);
				 pixels[index] = isLinear ? rgb : RGBSpace.SRGB.rgbToLinear(rgb);
			 }
		 }
	 }
 }",0,0,1,0
"public class PayloadSpanCollector implements SpanCollector {
	 private final Collection<byte[]> payloads = new ArrayList<>();
	 public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
		 BytesRef payload = postings.getPayload();
		 if (payload == null) return;
		 final byte[] bytes = new byte[payload.length];
		 System.arraycopy(payload.bytes, payload.offset, bytes, 0, payload.length);
		 payloads.add(bytes);
	 }
	 public void reset() {
		 payloads.clear();
	 }
	 public Collection<byte[]> getPayloads() {
		 return payloads;
	 }
}",0,0,0,0
"public static byte[] getIP() {
	 try {
		 Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();
		 InetAddress ip = null;
		 byte[] internalIP = null;
		 while (allNetInterfaces.hasMoreElements()) {
			 NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();
			 Enumeration addresses = netInterface.getInetAddresses();
			 while (addresses.hasMoreElements()) {
				 ip = (InetAddress) addresses.nextElement();
				 if (ip != null && ip instanceof Inet4Address) {
					 byte[] ipByte = ip.getAddress();
					 if (ipByte.length == 4) {
						 if (ipCheck(ipByte)) {
							 if (!isInternalIP(ipByte)) {
								 return ipByte;
							 }
							 else if (internalIP == null) {
								 internalIP = ipByte;
							 }
						 }
					 }
				 }
			 }
		 }
		 if (internalIP != null) {
			 return internalIP;
		 }
		 else {
			 throw new RuntimeException(""Can not get local ip"");
		 }
	 }
	 catch (Exception e) {
		 throw new RuntimeException(""Can not get local ip"", e);
	 }
 }",0,0,1,0
"private static class MapKeyFunction<K> implements Function<Map.Entry<K, ?>, K> {
	 private static final long serialVersionUID = 1L;
	 public K valueOf(Map.Entry<K, ?> entry) {
		 return entry.getKey();
	 }
 }",0,0,0,0
"protected void adjustArraySize(int newSize) {
	 if (keyStart == null || keyStart.length < newSize) {
		 keyStart = new int[newSize];
		 keyLength = new int[newSize];
		 valueStart = new int[newSize];
		 valueLength = new int[newSize];
		 keyInited = new boolean[newSize];
		 keyIsNull = new boolean[newSize];
		 valueInited = new boolean[newSize];
		 valueIsNull = new boolean[newSize];
		 keyObjects = new LazyBinaryPrimitive<?, ?>[newSize];
		 valueObjects = new LazyBinaryObject[newSize];
	 }
 }",0,0,0,0
public boolean add(AccrualPeriod accrualPeriod);,0,0,0,0
"public abstract class ContextMenuProvider extends MenuManager implementsIMenuListener {
	private EditPartViewer viewer;
	public ContextMenuProvider(EditPartViewer viewer) {
		setViewer(viewer);
		addMenuListener(this);
		setRemoveAllWhenShown(true);
	}
	public abstract void buildContextMenu(IMenuManager menu);
	protected EditPartViewer getViewer() {
		return viewer;
	}
	public void menuAboutToShow(IMenuManager menu) {
		buildContextMenu(menu);
	}
	protected void setViewer(EditPartViewer viewer) {
		this.viewer = viewer;
	}
}",0,1,0,0
"public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2, Color bgColor, ImageObserver imageobserver);",0,0,0,1
"private void spinThreads() throws BuildException {
	 final int numTasks = nestedTasks.size();
	 TaskRunnable[] runnables = new TaskRunnable[numTasks];
	 stillRunning = true;
	 timedOut = false;
	 boolean interrupted = false;
	 int threadNumber = 0;
	 for (Enumeration e = nestedTasks.elements();
	 e.hasMoreElements();
	 threadNumber++) {
		 Task nestedTask = (Task) e.nextElement();
		 runnables[threadNumber] = new TaskRunnable(nestedTask);
	 }
	 final int maxRunning = numTasks < numThreads ? numTasks : numThreads;
	 TaskRunnable[] running = new TaskRunnable[maxRunning];
	 threadNumber = 0;
	 ThreadGroup group = new ThreadGroup(""parallel"");
	 TaskRunnable[] daemons = null;
	 if (daemonTasks != null && daemonTasks.tasks.size() != 0) {
		 daemons = new TaskRunnable[daemonTasks.tasks.size()];
	 }
	 synchronized (semaphore) {
	 }
	 synchronized (semaphore) {
		 if (daemons != null) {
			 for (int i = 0;
			 i < daemons.length;
			 ++i) {
				 daemons[i] = new TaskRunnable((Task) daemonTasks.tasks.get(i));
				 Thread daemonThread = new Thread(group, daemons[i]);
				 daemonThread.setDaemon(true);
				 daemonThread.start();
			 }
		 }
		 for (int i = 0;
		 i < maxRunning;
		 ++i) {
			 running[i] = runnables[threadNumber++];
			 Thread thread = new Thread(group, running[i]);
			 thread.start();
		 }
		 if (timeout != 0) {
			 Thread timeoutThread = new Thread() {
				 public synchronized void run() {
					 try {
						 wait(timeout);
						 synchronized (semaphore) {
							 stillRunning = false;
							 timedOut = true;
							 semaphore.notifyAll();
						 }
					 }
					 catch (InterruptedException e) {
					 }
				 }
			 }
			;
			 timeoutThread.start();
		 }
		 try {
			 outer: while (threadNumber < numTasks && stillRunning) {
				 for (int i = 0;
				 i < maxRunning;
				 i++) {
					 if (running[i] == null || running[i].isFinished()) {
						 running[i] = runnables[threadNumber++];
						 Thread thread = new Thread(group, running[i]);
						 thread.start();
						 continue outer;
					 }
				 }
				 semaphore.wait();
			 }
			 outer2: while (stillRunning) {
				 for (int i = 0;
				 i < maxRunning;
				 ++i) {
					 if (running[i] != null && !running[i].isFinished()) {
						 semaphore.wait();
						 continue outer2;
					 }
				 }
				 stillRunning = false;
			 }
		 }
		 catch (InterruptedException ie) {
			 interrupted = true;
		 }
		 if (!timedOut && !failOnAny) {
			 killAll(running);
		 }
	 }
	 if (interrupted) {
		 throw new BuildException(""Parallel execution interrupted."");
	 }
	 if (timedOut) {
		 throw new BuildException(""Parallel execution timed out"");
	 }
	 exceptionMessage = new StringBuffer();
	 numExceptions = 0;
	 firstException = null;
	 firstLocation = Location.UNKNOWN_LOCATION;
	 processExceptions(daemons);
	 processExceptions(runnables);
	 if (numExceptions == 1) {
		 if (firstException instanceof BuildException) {
			 throw (BuildException) firstException;
		 }
		 else {
			 throw new BuildException(firstException);
		 }
	 }
	 else if (numExceptions > 1) {
		 throw new BuildException(exceptionMessage.toString(), firstLocation);
	 }
 }",0,0,1,0
"public class DotNode {
	 public String name;
	 public Map<String, String> attributes = new HashMap<String, String>();
	 public Set<DotNode> edgeTo = new HashSet<DotNode>();
	 public DotNode(String name) {
		 this.name = name;
	 }
	 public String toString() {
		 StringBuilder sb = new StringBuilder(name);
		 if (attributes.size() > 0) {
			 int index = 0;
			 sb.append("" ["");
			 for (Map.Entry<String, String> attr : attributes.entrySet()) {
				 sb.append(attr.getKey() + ""="" + attr.getValue());
				 if (index < attributes.size() - 1) sb.append("", "");
				 index++;
			 }
			 sb.append(""]"");
		 }
		 return sb.toString();
	 }
	 public String getLabel() {
		 String label = """";
		 for (Map.Entry<String, String> attr : attributes.entrySet()) {
			 if (attr.getKey().equals(""label"")) {
				 label = attr.getValue();
				 break;
			 }
		 }
		 return label;
	 }
	 public boolean isInvisStyle() {
		 for (Map.Entry<String, String> attr : attributes.entrySet()) if (attr.getKey().equals(""style"") && attr.getValue().equals(""invis"")) return true;
		 return false;
	 }
	 public boolean equals(Object other) {
		 if (other instanceof DotNode && !(other instanceof DotGraph)) {
			 DotNode node = (DotNode) other;
			 return name.equals(node.name);
		 }
		 return false;
	 }
	 public int hashCode() {
		 return name.hashCode();
	 }
	 public String getCanonicalName() {
		 StringBuilder sb = new StringBuilder("""");
		 ArrayList<String> canonicalNames = new ArrayList<>();
		 for (DotNode node : edgeTo) if (!node.isInvisStyle()) canonicalNames.add(node.getCanonicalName());
		 Collections.sort(canonicalNames);
		 for (String nodeName : canonicalNames) sb.append(nodeName);
		 sb.insert(0, '0');
		 sb.insert(sb.length(), '1');
		 return sb.toString();
	 }
}",1,0,0,0
"public class FolderArchiveFile implements IArchiveFile{
	private static final String METEDATA = "".metadata"";
	private static Logger logger = Logger.getLogger( FolderArchiveFile.class.getName( ) );
	protected String folderName;
	protected String systemId;
	protected String dependId;
	private HashSet<RAFolderInputStream> inputStreams = new HashSet<RAFolderInputStream>( );
	private HashSet<RAFolderOutputStream> outputStreams = new HashSet<RAFolderOutputStream>( );
	protected Map<String, String> properties = new HashMap<String, String>();
	 public FolderArchiveFile( String name ) throws IOException {
		 if ( name == null || name.length( ) == 0 ) throw new IOException( CoreMessages .getString( ResourceConstants.FOLDER_NAME_IS_NULL ) );
		 File file = new File( name );
		 file.mkdirs( );
		 this.folderName = file.getCanonicalPath( );
		 readMetaData( );
	 }
	 public String getName( ) {
		 return folderName;
	 }
	 private void readMetaData( ) throws IOException {
		 String meta = ArchiveUtil.getFullPath( folderName, METEDATA );
		 File file = new File( meta );
		 if ( file.exists( ) && file.isFile( ) ) {
			 DataInputStream data = new DataInputStream( new FileInputStream( file ) );
			 try {
				 properties = (Map<String, String>) IOUtil.readMap( data );
			 }
			 finally {
				 data.close( );
			 }
		 }
	 }
	 private void saveMetaData( ) throws IOException {
		 String meta = ArchiveUtil.getFullPath( folderName, METEDATA );
		 File file = new File( meta );
		 DataOutputStream data = new DataOutputStream( new FileOutputStream( file ) );
		 try {
			 IOUtil.writeMap( data, this.properties );
		 }
		 finally {
			 data.close( );
		 }
	 }
	 public void close( ) throws IOException {
		 saveMetaData( );
		 IOException exception = null;
		 synchronized ( outputStreams ) {
			 ArrayList<RAFolderOutputStream> outputs = new ArrayList<RAFolderOutputStream>( outputStreams );
			 for ( RAFolderOutputStream output : outputs ) {
				 try {
					 output.close( );
				 }
				 catch ( IOException ex ) {
					 logger.log( Level.SEVERE, ex.getMessage( ), ex );
					 if ( exception != null ) {
						 exception = ex;
					 }
				 }
			 }
			 outputStreams.clear( );
		 }
		 synchronized ( inputStreams ) {
			 ArrayList<RAFolderInputStream> inputs = new ArrayList<RAFolderInputStream>( inputStreams );
			 for ( RAFolderInputStream input : inputs ) {
				 try {
					 input.close( );
				 }
				 catch ( IOException ex ) {
					 logger.log( Level.SEVERE, ex.getMessage( ), ex );
					 if ( exception != null ) {
						 exception = ex;
					 }
				 }
			 }
			 inputStreams.clear( );
		 }
		 if ( exception != null ) {
			 throw exception;
		 }
	 }
	public void flush( ) throws IOException{
		IOException ioex = null;
		synchronized ( outputStreams ){
			for ( RAOutputStream output : outputStreams ){
				try{
					output.flush( );
				}
				catch ( IOException ex ){
					logger.log(Level.SEVERE, ex.getMessage( ), ex);
					if ( ioex != null ){
						ioex = ex;
					}
				}
			}
		}
		if ( ioex != null ){
			throw ioex;
		}
	}
	public void refresh( ) throws IOException{
	}
	public boolean exists( String name ){
		String path = getFilePath( name );
		File fd = new File( path );
		return fd.exists( );
	}
	public void setCacheSize( long cacheSize ){
	}
	public long getUsedCache( ){
		return 0;
	}
	public ArchiveEntry openEntry( String name ) throws IOException{
		 String fullPath = getFilePath( name );
		File fd = new File( fullPath );
		if(fd.exists( )){
			return new FolderArchiveEntry( name, fd, inputStreams, outputStreams );
		}
		throw new FileNotFoundException( fullPath );
	}
	 public List<String> listEntries( String namePattern ) {
		 ArrayList<String> streamList = new ArrayList<String>( );
		 String storagePath = getFolderPath( namePattern );
		 ArrayList<File> files = new ArrayList<File>( );
		 ArchiveUtil.listAllFiles( new File( storagePath ), files );
		 for ( File file : files ) {
			 String relativePath = ArchiveUtil.getRelativePath( folderName, file.getPath( ) );
			 if ( !ArchiveUtil.needSkip( relativePath ) ) {
				 String entryName = ArchiveUtil.getEntryName( folderName, file.getPath( ) );
				 streamList.add( entryName );
			 }
		 }
		 return streamList;
	 }
	public ArchiveEntry createEntry( String name ) throws IOException{
		String path = getFilePath( name );
		File fd = new File( path );
		ArchiveUtil.createParentFolder( fd );
		FolderArchiveEntry out = new FolderArchiveEntry( name, fd, inputStreams, outputStreams );
		return out;
	}
	public boolean removeEntry( String name ) throws IOException{
		 String path = getFilePath( name );
		try{
			File fd = new File( path );
			return ArchiveUtil.removeFileAndFolder( fd );
		}
		finally{
			synchronized ( outputStreams ){
				ArrayList<RAFolderOutputStream> outputs = new ArrayList<RAFolderOutputStream>(outputStreams );
				for ( RAFolderOutputStream output : outputs ){
					try{
						if(name.equals( output.getName( ) )){
							output.close( );
						}
					}
					catch ( IOException ex ){
						logger.log(Level.SEVERE, ex.getMessage( ), ex);
						throw ex;
					}
				}
			}
		}
	}
	public Object lockEntry( String entry ) throws IOException{
		 String path = getFilePath( entry ) + "".lck"";
		IArchiveLockManager lockManager = ArchiveLockManager.getInstance( );
		return lockManager.lock( path );
	}
	public void unlockEntry( Object locker ) throws IOException{
		IArchiveLockManager lockManager = ArchiveLockManager.getInstance( );
		lockManager.unlock( locker );
	}
	public String getSystemId( ){
		if ( properties.containsKey( ArchiveFileV3.PROPERTY_SYSTEM_ID ) ){
			return properties.get( ArchiveFileV3.PROPERTY_SYSTEM_ID ).toString( );
		}
		return null;
	}
	public String getDependId( ){
		if ( properties.containsKey( ArchiveFileV3.PROPERTY_DEPEND_ID ) ){
			return properties.get( ArchiveFileV3.PROPERTY_DEPEND_ID ).toString( );
		}
		return null;
	}
	public void setSystemId(String systemId){
		if(systemId!=null){
			this.properties.put( ArchiveFileV3.PROPERTY_SYSTEM_ID, systemId );
		}
	}
	public void setDependId(String dependId){
		if(dependId!=null){
			this.properties.put( ArchiveFileV3.PROPERTY_DEPEND_ID, dependId );
		}
	}
	public void save( ) throws IOException{
		flush();
	}
	public long getLength( ){
		long result = 0;
		List<String> entries = listEntries( null );
		for( String entry : entries ){
			try{
				result += openEntry( entry ).getLength( );
			}
			catch ( IOException e ){
				e.printStackTrace();
			}
		}
		return result;
	}
	 private String getFilePath( String entryName ) {
		 return ArchiveUtil.getFilePath( folderName, entryName );
	 }
	 private String getFolderPath( String entryName ) {
		 return ArchiveUtil.getFolderPath( folderName, entryName );
	 }
}",1,1,0,0
"public UrlNormalizer getNormalizer() {
	 String urlNormalizer = null;
	 UrlNormalizer normalizer = (UrlNormalizer) this.conf .getObject(UrlNormalizer.class.getName());
	 if (normalizer == null) {
		 try {
			 urlNormalizer = this.conf.get(""urlnormalizer.class"");
			 if (LOG.isInfoEnabled()) {
				 LOG.info(""Using URL normalizer: "" + urlNormalizer);
			 }
			 Class normalizerClass = Class.forName(urlNormalizer);
			 normalizer = (UrlNormalizer) normalizerClass.newInstance();
			 normalizer.setConf(this.conf);
			 this.conf.setObject(UrlNormalizer.class.getName(), normalizer);
		 }
		 catch (Exception e) {
			 throw new RuntimeException(""Couldn't create "" + urlNormalizer, e);
		 }
	 }
	 return normalizer;
 }",0,0,0,0
"public void loadSchemaFromYAML() throws ConfigurationException, IOException {
	 ssProxy.loadSchemaFromYAML();
 }",0,0,0,0
"public void setCurrentPriority(String currentPriority) {
	 this.currentPriority = currentPriority;
 }",0,0,0,0
"protected String decodeValue(String value) {
	 if (value == null || (value.indexOf('\\') < 0 && value.indexOf(',') < 0)) {
		 return value;
	 }
	 else {
		 StringBuilder decodedValue = new StringBuilder();
		 for (int i = 0;
		 i < value.length();
		 i++) {
			 char c = value.charAt(i);
			 if (c == '\\') {
				 i++;
				 if (i == value.length()) {
					 break;
				 }
				 c = value.charAt(i);
				 if (c == 'n' || c == 'N') {
					 c = '\n';
				 }
				 else if (c == 'r') {
					 c = '\r';
				 }
			 }
			 if (c == ',' && (""N"".equals(key) || ""ADR"".equals(key) || ""CATEGORIES"".equals(key) || ""NICKNAME"".equals(key) )) {
				 c = '\n';
			 }
			 decodedValue.append(c);
		 }
		 return decodedValue.toString();
	 }
 }",0,0,0,0
"public class PdfReader implements PdfViewerPreferences {
	public static boolean unethicalreading = false;
	 static final PdfName pageInhCandidates[] = {
	 PdfName.MEDIABOX, PdfName.ROTATE, PdfName.RESOURCES, PdfName.CROPBOX }
	;
	 static final byte endstream[] = PdfEncodings.convertToBytes(""endstream"", null);
	 static final byte endobj[] = PdfEncodings.convertToBytes(""endobj"", null);
	 protected PRTokeniser tokens;
	 protected int xref[];
	 protected HashMap<Integer, IntHashtable> objStmMark;
	 protected IntHashtable objStmToOffset;
	 protected boolean newXrefType;
	 private ArrayList<PdfObject> xrefObj;
	 PdfDictionary rootPages;
	 protected PdfDictionary trailer;
	 protected PdfDictionary catalog;
	 protected PageRefs pageRefs;
	 protected PRAcroForm acroForm = null;
	 protected boolean acroFormParsed = false;
	 protected boolean encrypted = false;
	 protected boolean rebuilt = false;
	 protected int freeXref;
	 protected boolean tampered = false;
	 protected int lastXref;
	 protected int eofPos;
	 protected char pdfVersion;
	 protected PdfEncryption decrypt;
	 protected byte password[] = null;
	 protected Key certificateKey = null;
	 protected Certificate certificate = null;
	 protected String certificateKeyProvider = null;
	 private boolean ownerPasswordUsed;
	 protected ArrayList<PdfString> strings = new ArrayList<PdfString>();
	 protected boolean sharedStreams = true;
	 protected boolean consolidateNamedDestinations = false;
	 protected boolean remoteToLocalNamedDestinations = false;
	 protected int rValue;
	 protected int pValue;
	 private int objNum;
	 private int objGen;
	 private int fileLength;
	 private boolean hybridXref;
	 private int lastXrefPartial = -1;
	 private boolean partial;
	 private PRIndirectReference cryptoRef;
	private PdfViewerPreferencesImp viewerPreferences = new PdfViewerPreferencesImp();
	 private boolean encryptionError;
	 private boolean appendable;
	 protected PdfReader() {
	 }
	 public PdfReader(String filename) throws IOException {
		 this(filename, null);
	 }
	 public PdfReader(String filename, byte ownerPassword[]) throws IOException {
		 password = ownerPassword;
		 tokens = new PRTokeniser(filename);
		 readPdf();
	 }
	 public PdfReader(byte pdfIn[]) throws IOException {
		 this(pdfIn, null);
	 }
	 public PdfReader(byte pdfIn[], byte ownerPassword[]) throws IOException {
		 password = ownerPassword;
		 tokens = new PRTokeniser(pdfIn);
		 readPdf();
	 }
	 public PdfReader(String filename, Certificate certificate, Key certificateKey, String certificateKeyProvider) throws IOException {
		 this.certificate = certificate;
		 this.certificateKey = certificateKey;
		 this.certificateKeyProvider = certificateKeyProvider;
		 tokens = new PRTokeniser(filename);
		 readPdf();
	 }
	 public PdfReader(URL url) throws IOException {
		 this(url, null);
	 }
	 public PdfReader(URL url, byte ownerPassword[]) throws IOException {
		 password = ownerPassword;
		 tokens = new PRTokeniser(new RandomAccessFileOrArray(url));
		 readPdf();
	 }
	 public PdfReader(InputStream is, byte ownerPassword[]) throws IOException {
		 password = ownerPassword;
		 tokens = new PRTokeniser(new RandomAccessFileOrArray(is));
		 readPdf();
	 }
	 public PdfReader(InputStream is) throws IOException {
		 this(is, null);
	 }
	 public PdfReader(RandomAccessFileOrArray raf, byte ownerPassword[]) throws IOException {
		 password = ownerPassword;
		 partial = true;
		 tokens = new PRTokeniser(raf);
		 readPdfPartial();
	 }
	 public PdfReader(PdfReader reader) {
		 this.appendable = reader.appendable;
		 this.consolidateNamedDestinations = reader.consolidateNamedDestinations;
		 this.encrypted = reader.encrypted;
		 this.rebuilt = reader.rebuilt;
		 this.sharedStreams = reader.sharedStreams;
		 this.tampered = reader.tampered;
		 this.password = reader.password;
		 this.pdfVersion = reader.pdfVersion;
		 this.eofPos = reader.eofPos;
		 this.freeXref = reader.freeXref;
		 this.lastXref = reader.lastXref;
		 this.tokens = new PRTokeniser(reader.tokens.getSafeFile());
		 if (reader.decrypt != null) this.decrypt = new PdfEncryption(reader.decrypt);
		 this.pValue = reader.pValue;
		 this.rValue = reader.rValue;
		 this.xrefObj = new ArrayList<PdfObject>(reader.xrefObj);
		 for (int k = 0;
		 k < reader.xrefObj.size();
		 ++k) {
			 this.xrefObj.set(k, duplicatePdfObject(reader.xrefObj.get(k), this));
		 }
		 this.pageRefs = new PageRefs(reader.pageRefs, this);
		 this.trailer = (PdfDictionary)duplicatePdfObject(reader.trailer, this);
		 this.catalog = trailer.getAsDict(PdfName.ROOT);
		 this.rootPages = catalog.getAsDict(PdfName.PAGES);
		 this.fileLength = reader.fileLength;
		 this.partial = reader.partial;
		 this.hybridXref = reader.hybridXref;
		 this.objStmToOffset = reader.objStmToOffset;
		 this.xref = reader.xref;
		 this.cryptoRef = (PRIndirectReference)duplicatePdfObject(reader.cryptoRef, this);
		 this.ownerPasswordUsed = reader.ownerPasswordUsed;
	 }
	 public RandomAccessFileOrArray getSafeFile() {
		 return tokens.getSafeFile();
	 }
	 protected PdfReaderInstance getPdfReaderInstance(PdfWriter writer) {
		 return new PdfReaderInstance(this, writer);
	 }
	 public int getNumberOfPages() {
		 return pageRefs.size();
	 }
	 public PdfDictionary getCatalog() {
		 return catalog;
	 }
	 public PRAcroForm getAcroForm() {
		 if (!acroFormParsed) {
			 acroFormParsed = true;
			 PdfObject form = catalog.get(PdfName.ACROFORM);
			 if (form != null) {
				 try {
					 acroForm = new PRAcroForm(this);
					 acroForm.readAcroForm((PdfDictionary)getPdfObject(form));
				 }
				 catch (Exception e) {
					 acroForm = null;
				 }
			 }
		 }
		 return acroForm;
	 }
	 public int getPageRotation(int index) {
		 return getPageRotation(pageRefs.getPageNRelease(index));
	 }
	 int getPageRotation(PdfDictionary page) {
		 PdfNumber rotate = page.getAsNumber(PdfName.ROTATE);
		 if (rotate == null) return 0;
		 else {
			 int n = rotate.intValue();
			 n %= 360;
			 return n < 0 ? n + 360 : n;
		 }
	 }
	 public Rectangle getPageSizeWithRotation(int index) {
		 return getPageSizeWithRotation(pageRefs.getPageNRelease(index));
	 }
	 public Rectangle getPageSizeWithRotation(PdfDictionary page) {
		 Rectangle rect = getPageSize(page);
		 int rotation = getPageRotation(page);
		 while (rotation > 0) {
			 rect = rect.rotate();
			 rotation -= 90;
		 }
		 return rect;
	 }
	 public Rectangle getPageSize(int index) {
		 return getPageSize(pageRefs.getPageNRelease(index));
	 }
	 public Rectangle getPageSize(PdfDictionary page) {
		 PdfArray mediaBox = page.getAsArray(PdfName.MEDIABOX);
		 return getNormalizedRectangle(mediaBox);
	 }
	 public Rectangle getCropBox(int index) {
		 PdfDictionary page = pageRefs.getPageNRelease(index);
		 PdfArray cropBox = (PdfArray)getPdfObjectRelease(page.get(PdfName.CROPBOX));
		 if (cropBox == null) return getPageSize(page);
		 return getNormalizedRectangle(cropBox);
	 }
	 public Rectangle getBoxSize(int index, String boxName) {
		 PdfDictionary page = pageRefs.getPageNRelease(index);
		 PdfArray box = null;
		 if (boxName.equals(""trim"")) box = (PdfArray)getPdfObjectRelease(page.get(PdfName.TRIMBOX));
		 else if (boxName.equals(""art"")) box = (PdfArray)getPdfObjectRelease(page.get(PdfName.ARTBOX));
		 else if (boxName.equals(""bleed"")) box = (PdfArray)getPdfObjectRelease(page.get(PdfName.BLEEDBOX));
		 else if (boxName.equals(""crop"")) box = (PdfArray)getPdfObjectRelease(page.get(PdfName.CROPBOX));
		 else if (boxName.equals(""media"")) box = (PdfArray)getPdfObjectRelease(page.get(PdfName.MEDIABOX));
		 if (box == null) return null;
		 return getNormalizedRectangle(box);
	 }
	 public HashMap<String, String> getInfo() {
		 HashMap<String, String> map = new HashMap<String, String>();
		 PdfDictionary info = trailer.getAsDict(PdfName.INFO);
		 if (info == null) return map;
		 for (Object element : info.getKeys()) {
			 PdfName key = (PdfName)element;
			 PdfObject obj = getPdfObject(info.get(key));
			 if (obj == null) continue;
			 String value = obj.toString();
			 switch (obj.type()) {
				 case PdfObject.STRING: {
					 value = ((PdfString)obj).toUnicodeString();
					 break;
				 }
				 case PdfObject.NAME: {
					 value = PdfName.decodeName(value);
					 break;
				 }
			 }
			 map.put(PdfName.decodeName(key.toString()), value);
		 }
		 return map;
	 }
	 public static Rectangle getNormalizedRectangle(PdfArray box) {
		 float llx = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(0))).floatValue();
		 float lly = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(1))).floatValue();
		 float urx = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(2))).floatValue();
		 float ury = ((PdfNumber)getPdfObjectRelease(box.getPdfObject(3))).floatValue();
		 return new Rectangle(Math.min(llx, urx), Math.min(lly, ury), Math.max(llx, urx), Math.max(lly, ury));
	 }
	 protected void readPdf() throws IOException {
		 try {
			 fileLength = tokens.getFile().length();
			 pdfVersion = tokens.checkPdfHeader();
			 try {
				 readXref();
			 }
			 catch (Exception e) {
				 try {
					 rebuilt = true;
					 rebuildXref();
					 lastXref = -1;
				 }
				 catch (Exception ne) {
					 throw new InvalidPdfException(MessageLocalization.getComposedMessage(""rebuild.failed.1.original.message.2"", ne.getMessage(), e.getMessage()));
				 }
			 }
			 try {
				 readDocObj();
			 }
			 catch (Exception e) {
				 if (e instanceof BadPasswordException) throw new BadPasswordException(e.getMessage());
				 if (rebuilt || encryptionError) throw new InvalidPdfException(e.getMessage());
				 rebuilt = true;
				 encrypted = false;
				 rebuildXref();
				 lastXref = -1;
				 readDocObj();
			 }
			 strings.clear();
			 readPages();
			 eliminateSharedStreams();
			 removeUnusedObjects();
		 }
		 finally {
			 try {
				 tokens.close();
			 }
			 catch (Exception e) {
			 }
		 }
	 }
	 protected void readPdfPartial() throws IOException {
		 try {
			 fileLength = tokens.getFile().length();
			 pdfVersion = tokens.checkPdfHeader();
			 try {
				 readXref();
			 }
			 catch (Exception e) {
				 try {
					 rebuilt = true;
					 rebuildXref();
					 lastXref = -1;
				 }
				 catch (Exception ne) {
					 throw new InvalidPdfException(MessageLocalization.getComposedMessage(""rebuild.failed.1.original.message.2"", ne.getMessage(), e.getMessage()));
				 }
			 }
			 readDocObjPartial();
			 readPages();
		 }
		 catch (IOException e) {
			 try{
				tokens.close();
			}
			catch(Exception ee){
			}
			 throw e;
		 }
	 }
	 private boolean equalsArray(byte ar1[], byte ar2[], int size) {
		 for (int k = 0;
		 k < size;
		 ++k) {
			 if (ar1[k] != ar2[k]) return false;
		 }
		 return true;
	 }
	 private void readDecryptedDocObj() throws IOException {
		 if (encrypted) return;
		 PdfObject encDic = trailer.get(PdfName.ENCRYPT);
		 if (encDic == null || encDic.toString().equals(""null"")) return;
		 encryptionError = true;
		 byte[] encryptionKey = null;
		 encrypted = true;
		 PdfDictionary enc = (PdfDictionary)getPdfObject(encDic);
		 String s;
		 PdfObject o;
		 PdfArray documentIDs = trailer.getAsArray(PdfName.ID);
		 byte documentID[] = null;
		 if (documentIDs != null) {
			 o = documentIDs.getPdfObject(0);
			 strings.remove(o);
			 s = o.toString();
			 documentID = com.itextpdf.text.DocWriter.getISOBytes(s);
			 if (documentIDs.size() > 1) strings.remove(documentIDs.getPdfObject(1));
		 }
		 if (documentID == null) documentID = new byte[0];
		 byte uValue[] = null;
		 byte oValue[] = null;
		 int cryptoMode = PdfWriter.STANDARD_ENCRYPTION_40;
		 int lengthValue = 0;
		 PdfObject filter = getPdfObjectRelease(enc.get(PdfName.FILTER));
		 if (filter.equals(PdfName.STANDARD)) {
			 s = enc.get(PdfName.U).toString();
			 strings.remove(enc.get(PdfName.U));
			 uValue = com.itextpdf.text.DocWriter.getISOBytes(s);
			 s = enc.get(PdfName.O).toString();
			 strings.remove(enc.get(PdfName.O));
			 oValue = com.itextpdf.text.DocWriter.getISOBytes(s);
			 o = enc.get(PdfName.P);
			 if (!o.isNumber()) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.p.value""));
			 pValue = ((PdfNumber)o).intValue();
			 o = enc.get(PdfName.R);
			 if (!o.isNumber()) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.r.value""));
			 rValue = ((PdfNumber)o).intValue();
			 switch (rValue) {
				 case 2: cryptoMode = PdfWriter.STANDARD_ENCRYPTION_40;
				 break;
				 case 3: o = enc.get(PdfName.LENGTH);
				 if (!o.isNumber()) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.length.value""));
				 lengthValue = ( (PdfNumber) o).intValue();
				 if (lengthValue > 128 || lengthValue < 40 || lengthValue % 8 != 0) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.length.value""));
				 cryptoMode = PdfWriter.STANDARD_ENCRYPTION_128;
				 break;
				 case 4: PdfDictionary dic = (PdfDictionary)enc.get(PdfName.CF);
				 if (dic == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""cf.not.found.encryption""));
				 dic = (PdfDictionary)dic.get(PdfName.STDCF);
				 if (dic == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""stdcf.not.found.encryption""));
				 if (PdfName.V2.equals(dic.get(PdfName.CFM))) cryptoMode = PdfWriter.STANDARD_ENCRYPTION_128;
				 else if (PdfName.AESV2.equals(dic.get(PdfName.CFM))) cryptoMode = PdfWriter.ENCRYPTION_AES_128;
				 else throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""no.compatible.encryption.found""));
				 PdfObject em = enc.get(PdfName.ENCRYPTMETADATA);
				 if (em != null && em.toString().equals(""false"")) cryptoMode |= PdfWriter.DO_NOT_ENCRYPT_METADATA;
				 break;
				 default: throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""unknown.encryption.type.r.eq.1"", rValue));
			 }
		 }
		 else if (filter.equals(PdfName.PUBSEC)) {
			 boolean foundRecipient = false;
			 byte[] envelopedData = null;
			 PdfArray recipients = null;
			 o = enc.get(PdfName.V);
			 if (!o.isNumber()) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.v.value""));
			 int vValue = ((PdfNumber)o).intValue();
			 switch(vValue) {
				 case 1: cryptoMode = PdfWriter.STANDARD_ENCRYPTION_40;
				 lengthValue = 40;
				 recipients = (PdfArray)enc.get(PdfName.RECIPIENTS);
				 break;
				 case 2: o = enc.get(PdfName.LENGTH);
				 if (!o.isNumber()) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.length.value""));
				 lengthValue = ( (PdfNumber) o).intValue();
				 if (lengthValue > 128 || lengthValue < 40 || lengthValue % 8 != 0) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""illegal.length.value""));
				 cryptoMode = PdfWriter.STANDARD_ENCRYPTION_128;
				 recipients = (PdfArray)enc.get(PdfName.RECIPIENTS);
				 break;
				 case 4: PdfDictionary dic = (PdfDictionary)enc.get(PdfName.CF);
				 if (dic == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""cf.not.found.encryption""));
				 dic = (PdfDictionary)dic.get(PdfName.DEFAULTCRYPTFILTER);
				 if (dic == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""defaultcryptfilter.not.found.encryption""));
				 if (PdfName.V2.equals(dic.get(PdfName.CFM))) {
					 cryptoMode = PdfWriter.STANDARD_ENCRYPTION_128;
					 lengthValue = 128;
				 }
				 else if (PdfName.AESV2.equals(dic.get(PdfName.CFM))) {
					 cryptoMode = PdfWriter.ENCRYPTION_AES_128;
					 lengthValue = 128;
				 }
				 else throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""no.compatible.encryption.found""));
				 PdfObject em = dic.get(PdfName.ENCRYPTMETADATA);
				 if (em != null && em.toString().equals(""false"")) cryptoMode |= PdfWriter.DO_NOT_ENCRYPT_METADATA;
				 recipients = (PdfArray)dic.get(PdfName.RECIPIENTS);
				 break;
				 default: throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""unknown.encryption.type.v.eq.1"", rValue));
			 }
			 for (int i = 0;
			 i<recipients.size();
			 i++) {
				 PdfObject recipient = recipients.getPdfObject(i);
				 strings.remove(recipient);
				 CMSEnvelopedData data = null;
				 try {
					 data = new CMSEnvelopedData(recipient.getBytes());
					 Iterator<RecipientInformation> recipientCertificatesIt = data.getRecipientInfos().getRecipients().iterator();
					 while (recipientCertificatesIt.hasNext()) {
						 RecipientInformation recipientInfo = recipientCertificatesIt.next();
						 if (recipientInfo.getRID().match(certificate) && !foundRecipient) {
							 envelopedData = recipientInfo.getContent(certificateKey, certificateKeyProvider);
							 foundRecipient = true;
						 }
					 }
				 }
				 catch (Exception f) {
					 throw new ExceptionConverter(f);
				 }
			 }
			 if(!foundRecipient || envelopedData == null) {
				 throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""bad.certificate.and.key""));
			 }
			 MessageDigest md = null;
			 try {
				 md = MessageDigest.getInstance(""SHA-1"");
				 md.update(envelopedData, 0, 20);
				 for (int i = 0;
				 i<recipients.size();
				 i++) {
					 byte[] encodedRecipient = recipients.getPdfObject(i).getBytes();
					 md.update(encodedRecipient);
				 }
				 if ((cryptoMode & PdfWriter.DO_NOT_ENCRYPT_METADATA) != 0) md.update(new byte[]{
				(byte)255, (byte)255, (byte)255, (byte)255}
				);
				 encryptionKey = md.digest();
			 }
			 catch (Exception f) {
				 throw new ExceptionConverter(f);
			 }
		 }
		 decrypt = new PdfEncryption();
		 decrypt.setCryptoMode(cryptoMode, lengthValue);
		 if (filter.equals(PdfName.STANDARD)) {
			 decrypt.setupByOwnerPassword(documentID, password, uValue, oValue, pValue);
			 if (!equalsArray(uValue, decrypt.userKey, rValue == 3 || rValue == 4 ? 16 : 32)) {
				 decrypt.setupByUserPassword(documentID, password, oValue, pValue);
				 if (!equalsArray(uValue, decrypt.userKey, rValue == 3 || rValue == 4 ? 16 : 32)) {
					 throw new BadPasswordException(MessageLocalization.getComposedMessage(""bad.user.password""));
				 }
			 }
			 else ownerPasswordUsed = true;
		 }
		 else if (filter.equals(PdfName.PUBSEC)) {
			 decrypt.setupByEncryptionKey(encryptionKey, lengthValue);
			 ownerPasswordUsed = true;
		 }
		 for (int k = 0;
		 k < strings.size();
		 ++k) {
			 PdfString str = strings.get(k);
			 str.decrypt(this);
		 }
		 if (encDic.isIndirect()) {
			 cryptoRef = (PRIndirectReference)encDic;
			 xrefObj.set(cryptoRef.getNumber(), null);
		 }
		 encryptionError = false;
	 }
	 public static PdfObject getPdfObjectRelease(PdfObject obj) {
		 PdfObject obj2 = getPdfObject(obj);
		 releaseLastXrefPartial(obj);
		 return obj2;
	 }
	 public static PdfObject getPdfObject(PdfObject obj) {
		 if (obj == null) return null;
		 if (!obj.isIndirect()) return obj;
		 try {
			 PRIndirectReference ref = (PRIndirectReference)obj;
			 int idx = ref.getNumber();
			 boolean appendable = ref.getReader().appendable;
			 obj = ref.getReader().getPdfObject(idx);
			 if (obj == null) {
				 return null;
			 }
			 else {
				 if (appendable) {
					 switch (obj.type()) {
						 case PdfObject.NULL: obj = new PdfNull();
						 break;
						 case PdfObject.BOOLEAN: obj = new PdfBoolean(((PdfBoolean)obj).booleanValue());
						 break;
						 case PdfObject.NAME: obj = new PdfName(obj.getBytes());
						 break;
					 }
					 obj.setIndRef(ref);
				 }
				 return obj;
			 }
		 }
		 catch (Exception e) {
			 throw new ExceptionConverter(e);
		 }
	 }
	 public static PdfObject getPdfObjectRelease(PdfObject obj, PdfObject parent) {
		 PdfObject obj2 = getPdfObject(obj, parent);
		 releaseLastXrefPartial(obj);
		 return obj2;
	 }
	 public static PdfObject getPdfObject(PdfObject obj, PdfObject parent) {
		 if (obj == null) return null;
		 if (!obj.isIndirect()) {
			 PRIndirectReference ref = null;
			 if (parent != null && (ref = parent.getIndRef()) != null && ref.getReader().isAppendable()) {
				 switch (obj.type()) {
					 case PdfObject.NULL: obj = new PdfNull();
					 break;
					 case PdfObject.BOOLEAN: obj = new PdfBoolean(((PdfBoolean)obj).booleanValue());
					 break;
					 case PdfObject.NAME: obj = new PdfName(obj.getBytes());
					 break;
				 }
				 obj.setIndRef(ref);
			 }
			 return obj;
		 }
		 return getPdfObject(obj);
	 }
	 public PdfObject getPdfObjectRelease(int idx) {
		 PdfObject obj = getPdfObject(idx);
		 releaseLastXrefPartial();
		 return obj;
	 }
	 public PdfObject getPdfObject(int idx) {
		 try {
			 lastXrefPartial = -1;
			 if (idx < 0 || idx >= xrefObj.size()) return null;
			 PdfObject obj = xrefObj.get(idx);
			 if (!partial || obj != null) return obj;
			 if (idx * 2 >= xref.length) return null;
			 obj = readSingleObject(idx);
			 lastXrefPartial = -1;
			 if (obj != null) lastXrefPartial = idx;
			 return obj;
		 }
		 catch (Exception e) {
			 throw new ExceptionConverter(e);
		 }
	 }
	 public void resetLastXrefPartial() {
		 lastXrefPartial = -1;
	 }
	 public void releaseLastXrefPartial() {
		 if (partial && lastXrefPartial != -1) {
			 xrefObj.set(lastXrefPartial, null);
			 lastXrefPartial = -1;
		 }
	 }
	 public static void releaseLastXrefPartial(PdfObject obj) {
		 if (obj == null) return;
		 if (!obj.isIndirect()) return;
		 if (!(obj instanceof PRIndirectReference)) return;
		 PRIndirectReference ref = (PRIndirectReference)obj;
		 PdfReader reader = ref.getReader();
		 if (reader.partial && reader.lastXrefPartial != -1 && reader.lastXrefPartial == ref.getNumber()) {
			 reader.xrefObj.set(reader.lastXrefPartial, null);
		 }
		 reader.lastXrefPartial = -1;
	 }
	 private void setXrefPartialObject(int idx, PdfObject obj) {
		 if (!partial || idx < 0) return;
		 xrefObj.set(idx, obj);
	 }
	 public PRIndirectReference addPdfObject(PdfObject obj) {
		 xrefObj.add(obj);
		 return new PRIndirectReference(this, xrefObj.size() - 1);
	 }
	 protected void readPages() throws IOException {
		 catalog = trailer.getAsDict(PdfName.ROOT);
		 rootPages = catalog.getAsDict(PdfName.PAGES);
		 pageRefs = new PageRefs(this);
	 }
	 protected void readDocObjPartial() throws IOException {
		 xrefObj = new ArrayList<PdfObject>(xref.length / 2);
		 xrefObj.addAll(Collections.<PdfObject>nCopies(xref.length / 2, null));
		 readDecryptedDocObj();
		 if (objStmToOffset != null) {
			 int keys[] = objStmToOffset.getKeys();
			 for (int k = 0;
			 k < keys.length;
			 ++k) {
				 int n = keys[k];
				 objStmToOffset.put(n, xref[n * 2]);
				 xref[n * 2] = -1;
			 }
		 }
	 }
	 protected PdfObject readSingleObject(int k) throws IOException {
		 strings.clear();
		 int k2 = k * 2;
		 int pos = xref[k2];
		 if (pos < 0) return null;
		 if (xref[k2 + 1] > 0) pos = objStmToOffset.get(xref[k2 + 1]);
		 if (pos == 0) return null;
		 tokens.seek(pos);
		 tokens.nextValidToken();
		 if (tokens.getTokenType() != TokenType.NUMBER) tokens.throwError(MessageLocalization.getComposedMessage(""invalid.object.number""));
		 objNum = tokens.intValue();
		 tokens.nextValidToken();
		 if (tokens.getTokenType() != TokenType.NUMBER) tokens.throwError(MessageLocalization.getComposedMessage(""invalid.generation.number""));
		 objGen = tokens.intValue();
		 tokens.nextValidToken();
		 if (!tokens.getStringValue().equals(""obj"")) tokens.throwError(MessageLocalization.getComposedMessage(""token.obj.expected""));
		 PdfObject obj;
		 try {
			 obj = readPRObject();
			 for (int j = 0;
			 j < strings.size();
			 ++j) {
				 PdfString str = strings.get(j);
				 str.decrypt(this);
			 }
			 if (obj.isStream()) {
				 checkPRStreamLength((PRStream)obj);
			 }
		 }
		 catch (Exception e) {
			 obj = null;
		 }
		 if (xref[k2 + 1] > 0) {
			 obj = readOneObjStm((PRStream)obj, xref[k2]);
		 }
		 xrefObj.set(k, obj);
		 return obj;
	 }
	 protected PdfObject readOneObjStm(PRStream stream, int idx) throws IOException {
		 int first = stream.getAsNumber(PdfName.FIRST).intValue();
		 byte b[] = getStreamBytes(stream, tokens.getFile());
		 PRTokeniser saveTokens = tokens;
		 tokens = new PRTokeniser(b);
		 try {
			 int address = 0;
			 boolean ok = true;
			 ++idx;
			 for (int k = 0;
			 k < idx;
			 ++k) {
				 ok = tokens.nextToken();
				 if (!ok) break;
				 if (tokens.getTokenType() != TokenType.NUMBER) {
					 ok = false;
					 break;
				 }
				 ok = tokens.nextToken();
				 if (!ok) break;
				 if (tokens.getTokenType() != TokenType.NUMBER) {
					 ok = false;
					 break;
				 }
				 address = tokens.intValue() + first;
			 }
			 if (!ok) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""error.reading.objstm""));
			 tokens.seek(address);
			 tokens.nextToken();
			 PdfObject obj;
			 if (tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
				 obj = new PdfNumber(tokens.getStringValue());
			 }
			 else {
				 tokens.seek(address);
				 obj = readPRObject();
			 }
			 return obj;
		 }
		 finally {
			 tokens = saveTokens;
		 }
	 }
	 public double dumpPerc() {
		 int total = 0;
		 for (int k = 0;
		 k < xrefObj.size();
		 ++k) {
			 if (xrefObj.get(k) != null) ++total;
		 }
		 return total * 100.0 / xrefObj.size();
	 }
	 protected void readDocObj() throws IOException {
		 ArrayList<PRStream> streams = new ArrayList<PRStream>();
		 xrefObj = new ArrayList<PdfObject>(xref.length / 2);
		 xrefObj.addAll(Collections.<PdfObject>nCopies(xref.length / 2, null));
		 for (int k = 2;
		 k < xref.length;
		 k += 2) {
			 int pos = xref[k];
			 if (pos <= 0 || xref[k + 1] > 0) continue;
			 tokens.seek(pos);
			 tokens.nextValidToken();
			 if (tokens.getTokenType() != TokenType.NUMBER) tokens.throwError(MessageLocalization.getComposedMessage(""invalid.object.number""));
			 objNum = tokens.intValue();
			 tokens.nextValidToken();
			 if (tokens.getTokenType() != TokenType.NUMBER) tokens.throwError(MessageLocalization.getComposedMessage(""invalid.generation.number""));
			 objGen = tokens.intValue();
			 tokens.nextValidToken();
			 if (!tokens.getStringValue().equals(""obj"")) tokens.throwError(MessageLocalization.getComposedMessage(""token.obj.expected""));
			 PdfObject obj;
			 try {
				 obj = readPRObject();
				 if (obj.isStream()) {
					 streams.add((PRStream)obj);
				 }
			 }
			 catch (Exception e) {
				 obj = null;
			 }
			 xrefObj.set(k / 2, obj);
		 }
		 for (int k = 0;
		 k < streams.size();
		 ++k) {
			 checkPRStreamLength(streams.get(k));
		 }
		 readDecryptedDocObj();
		 if (objStmMark != null) {
			 for (Map.Entry<Integer, IntHashtable>entry: objStmMark.entrySet()) {
				 int n = entry.getKey().intValue();
				 IntHashtable h = entry.getValue();
				 readObjStm((PRStream)xrefObj.get(n), h);
				 xrefObj.set(n, null);
			 }
			 objStmMark = null;
		 }
		 xref = null;
	 }
	 private void checkPRStreamLength(PRStream stream) throws IOException {
		 int fileLength = tokens.length();
		 int start = stream.getOffset();
		 boolean calc = false;
		 int streamLength = 0;
		 PdfObject obj = getPdfObjectRelease(stream.get(PdfName.LENGTH));
		 if (obj != null && obj.type() == PdfObject.NUMBER) {
			 streamLength = ((PdfNumber)obj).intValue();
			 if (streamLength + start > fileLength - 20) calc = true;
			 else {
				 tokens.seek(start + streamLength);
				 String line = tokens.readString(20);
				 if (!line.startsWith(""\nendstream"") && !line.startsWith(""\r\nendstream"") && !line.startsWith(""\rendstream"") && !line.startsWith(""endstream"")) calc = true;
			 }
		 }
		 else calc = true;
		 if (calc) {
			 byte tline[] = new byte[16];
			 tokens.seek(start);
			 while (true) {
				 int pos = tokens.getFilePointer();
				 if (!tokens.readLineSegment(tline)) break;
				 if (equalsn(tline, endstream)) {
					 streamLength = pos - start;
					 break;
				 }
				 if (equalsn(tline, endobj)) {
					 tokens.seek(pos - 16);
					 String s = tokens.readString(16);
					 int index = s.indexOf(""endstream"");
					 if (index >= 0) pos = pos - 16 + index;
					 streamLength = pos - start;
					 break;
				 }
			 }
		 }
		 stream.setLength(streamLength);
	 }
	 protected void readObjStm(PRStream stream, IntHashtable map) throws IOException {
		 int first = stream.getAsNumber(PdfName.FIRST).intValue();
		 int n = stream.getAsNumber(PdfName.N).intValue();
		 byte b[] = getStreamBytes(stream, tokens.getFile());
		 PRTokeniser saveTokens = tokens;
		 tokens = new PRTokeniser(b);
		 try {
			 int address[] = new int[n];
			 int objNumber[] = new int[n];
			 boolean ok = true;
			 for (int k = 0;
			 k < n;
			 ++k) {
				 ok = tokens.nextToken();
				 if (!ok) break;
				 if (tokens.getTokenType() != TokenType.NUMBER) {
					 ok = false;
					 break;
				 }
				 objNumber[k] = tokens.intValue();
				 ok = tokens.nextToken();
				 if (!ok) break;
				 if (tokens.getTokenType() != TokenType.NUMBER) {
					 ok = false;
					 break;
				 }
				 address[k] = tokens.intValue() + first;
			 }
			 if (!ok) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""error.reading.objstm""));
			 for (int k = 0;
			 k < n;
			 ++k) {
				 if (map.containsKey(k)) {
					 tokens.seek(address[k]);
					 tokens.nextToken();
					 PdfObject obj;
					 if (tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
						 obj = new PdfNumber(tokens.getStringValue());
					 }
					 else {
						 tokens.seek(address[k]);
						 obj = readPRObject();
					 }
					 xrefObj.set(objNumber[k], obj);
				 }
			 }
		 }
		 finally {
			 tokens = saveTokens;
		 }
	 }
	 public static PdfObject killIndirect(PdfObject obj) {
		 if (obj == null || obj.isNull()) return null;
		 PdfObject ret = getPdfObjectRelease(obj);
		 if (obj.isIndirect()) {
			 PRIndirectReference ref = (PRIndirectReference)obj;
			 PdfReader reader = ref.getReader();
			 int n = ref.getNumber();
			 reader.xrefObj.set(n, null);
			 if (reader.partial) reader.xref[n * 2] = -1;
		 }
		 return ret;
	 }
	 private void ensureXrefSize(int size) {
		 if (size == 0) return;
		 if (xref == null) xref = new int[size];
		 else {
			 if (xref.length < size) {
				 int xref2[] = new int[size];
				 System.arraycopy(xref, 0, xref2, 0, xref.length);
				 xref = xref2;
			 }
		 }
	 }
	 protected void readXref() throws IOException {
		 hybridXref = false;
		 newXrefType = false;
		 tokens.seek(tokens.getStartxref());
		 tokens.nextToken();
		 if (!tokens.getStringValue().equals(""startxref"")) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""startxref.not.found""));
		 tokens.nextToken();
		 if (tokens.getTokenType() != TokenType.NUMBER) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""startxref.is.not.followed.by.a.number""));
		 int startxref = tokens.intValue();
		 lastXref = startxref;
		 eofPos = tokens.getFilePointer();
		 try {
			 if (readXRefStream(startxref)) {
				 newXrefType = true;
				 return;
			 }
		 }
		 catch (Exception e) {
		}
		 xref = null;
		 tokens.seek(startxref);
		 trailer = readXrefSection();
		 PdfDictionary trailer2 = trailer;
		 while (true) {
			 PdfNumber prev = (PdfNumber)trailer2.get(PdfName.PREV);
			 if (prev == null) break;
			 tokens.seek(prev.intValue());
			 trailer2 = readXrefSection();
		 }
	 }
	 protected PdfDictionary readXrefSection() throws IOException {
		 tokens.nextValidToken();
		 if (!tokens.getStringValue().equals(""xref"")) tokens.throwError(MessageLocalization.getComposedMessage(""xref.subsection.not.found""));
		 int start = 0;
		 int end = 0;
		 int pos = 0;
		 int gen = 0;
		 while (true) {
			 tokens.nextValidToken();
			 if (tokens.getStringValue().equals(""trailer"")) break;
			 if (tokens.getTokenType() != TokenType.NUMBER) tokens.throwError(MessageLocalization.getComposedMessage(""object.number.of.the.first.object.in.this.xref.subsection.not.found""));
			 start = tokens.intValue();
			 tokens.nextValidToken();
			 if (tokens.getTokenType() != TokenType.NUMBER) tokens.throwError(MessageLocalization.getComposedMessage(""number.of.entries.in.this.xref.subsection.not.found""));
			 end = tokens.intValue() + start;
			 if (start == 1) {
				 int back = tokens.getFilePointer();
				 tokens.nextValidToken();
				 pos = tokens.intValue();
				 tokens.nextValidToken();
				 gen = tokens.intValue();
				 if (pos == 0 && gen == PdfWriter.GENERATION_MAX) {
					 --start;
					 --end;
				 }
				 tokens.seek(back);
			 }
			 ensureXrefSize(end * 2);
			 for (int k = start;
			 k < end;
			 ++k) {
				 tokens.nextValidToken();
				 pos = tokens.intValue();
				 tokens.nextValidToken();
				 gen = tokens.intValue();
				 tokens.nextValidToken();
				 int p = k * 2;
				 if (tokens.getStringValue().equals(""n"")) {
					 if (xref[p] == 0 && xref[p + 1] == 0) {
						 xref[p] = pos;
					 }
				 }
				 else if (tokens.getStringValue().equals(""f"")) {
					 if (xref[p] == 0 && xref[p + 1] == 0) xref[p] = -1;
				 }
				 else tokens.throwError(MessageLocalization.getComposedMessage(""invalid.cross.reference.entry.in.this.xref.subsection""));
			 }
		 }
		 PdfDictionary trailer = (PdfDictionary)readPRObject();
		 PdfNumber xrefSize = (PdfNumber)trailer.get(PdfName.SIZE);
		 ensureXrefSize(xrefSize.intValue() * 2);
		 PdfObject xrs = trailer.get(PdfName.XREFSTM);
		 if (xrs != null && xrs.isNumber()) {
			 int loc = ((PdfNumber)xrs).intValue();
			 try {
				 readXRefStream(loc);
				 newXrefType = true;
				 hybridXref = true;
			 }
			 catch (IOException e) {
				 xref = null;
				 throw e;
			 }
		 }
		 return trailer;
	 }
	 protected boolean readXRefStream(int ptr) throws IOException {
		 tokens.seek(ptr);
		 int thisStream = 0;
		 if (!tokens.nextToken()) return false;
		 if (tokens.getTokenType() != TokenType.NUMBER) return false;
		 thisStream = tokens.intValue();
		 if (!tokens.nextToken() || tokens.getTokenType() != TokenType.NUMBER) return false;
		 if (!tokens.nextToken() || !tokens.getStringValue().equals(""obj"")) return false;
		 PdfObject object = readPRObject();
		 PRStream stm = null;
		 if (object.isStream()) {
			 stm = (PRStream)object;
			 if (!PdfName.XREF.equals(stm.get(PdfName.TYPE))) return false;
		 }
		 else return false;
		 if (trailer == null) {
			 trailer = new PdfDictionary();
			 trailer.putAll(stm);
		 }
		 stm.setLength(((PdfNumber)stm.get(PdfName.LENGTH)).intValue());
		 int size = ((PdfNumber)stm.get(PdfName.SIZE)).intValue();
		 PdfArray index;
		 PdfObject obj = stm.get(PdfName.INDEX);
		 if (obj == null) {
			 index = new PdfArray();
			 index.add(new int[]{
			0, size}
			);
		 }
		 else index = (PdfArray)obj;
		 PdfArray w = (PdfArray)stm.get(PdfName.W);
		 int prev = -1;
		 obj = stm.get(PdfName.PREV);
		 if (obj != null) prev = ((PdfNumber)obj).intValue();
		 ensureXrefSize(size * 2);
		 if (objStmMark == null && !partial) objStmMark = new HashMap<Integer, IntHashtable>();
		 if (objStmToOffset == null && partial) objStmToOffset = new IntHashtable();
		 byte b[] = getStreamBytes(stm, tokens.getFile());
		 int bptr = 0;
		 int wc[] = new int[3];
		 for (int k = 0;
		 k < 3;
		 ++k) wc[k] = w.getAsNumber(k).intValue();
		 for (int idx = 0;
		 idx < index.size();
		 idx += 2) {
			 int start = index.getAsNumber(idx).intValue();
			 int length = index.getAsNumber(idx + 1).intValue();
			 ensureXrefSize((start + length) * 2);
			 while (length-- > 0) {
				 int type = 1;
				 if (wc[0] > 0) {
					 type = 0;
					 for (int k = 0;
					 k < wc[0];
					 ++k) type = (type << 8) + (b[bptr++] & 0xff);
				 }
				 int field2 = 0;
				 for (int k = 0;
				 k < wc[1];
				 ++k) field2 = (field2 << 8) + (b[bptr++] & 0xff);
				 int field3 = 0;
				 for (int k = 0;
				 k < wc[2];
				 ++k) field3 = (field3 << 8) + (b[bptr++] & 0xff);
				 int base = start * 2;
				 if (xref[base] == 0 && xref[base + 1] == 0) {
					 switch (type) {
						 case 0: xref[base] = -1;
						 break;
						 case 1: xref[base] = field2;
						 break;
						 case 2: xref[base] = field3;
						 xref[base + 1] = field2;
						 if (partial) {
							 objStmToOffset.put(field2, 0);
						 }
						 else {
							 Integer on = new Integer(field2);
							 IntHashtable seq = objStmMark.get(on);
							 if (seq == null) {
								 seq = new IntHashtable();
								 seq.put(field3, 1);
								 objStmMark.put(on, seq);
							 }
							 else seq.put(field3, 1);
						 }
						 break;
					 }
				 }
				 ++start;
			 }
		 }
		 thisStream *= 2;
		 if (thisStream < xref.length) xref[thisStream] = -1;
		 if (prev == -1) return true;
		 return readXRefStream(prev);
	 }
	 protected void rebuildXref() throws IOException {
		 hybridXref = false;
		 newXrefType = false;
		 tokens.seek(0);
		 int xr[][] = new int[1024][];
		 int top = 0;
		 trailer = null;
		 byte line[] = new byte[64];
		 for (;
		;
		) {
			 int pos = tokens.getFilePointer();
			 if (!tokens.readLineSegment(line)) break;
			 if (line[0] == 't') {
				 if (!PdfEncodings.convertToString(line, null).startsWith(""trailer"")) continue;
				 tokens.seek(pos);
				 tokens.nextToken();
				 pos = tokens.getFilePointer();
				 try {
					 PdfDictionary dic = (PdfDictionary)readPRObject();
					 if (dic.get(PdfName.ROOT) != null) trailer = dic;
					 else tokens.seek(pos);
				 }
				 catch (Exception e) {
					 tokens.seek(pos);
				 }
			 }
			 else if (line[0] >= '0' && line[0] <= '9') {
				 int obj[] = PRTokeniser.checkObjectStart(line);
				 if (obj == null) continue;
				 int num = obj[0];
				 int gen = obj[1];
				 if (num >= xr.length) {
					 int newLength = num * 2;
					 int xr2[][] = new int[newLength][];
					 System.arraycopy(xr, 0, xr2, 0, top);
					 xr = xr2;
				 }
				 if (num >= top) top = num + 1;
				 if (xr[num] == null || gen >= xr[num][1]) {
					 obj[0] = pos;
					 xr[num] = obj;
				 }
			 }
		 }
		 if (trailer == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage(""trailer.not.found""));
		 xref = new int[top * 2];
		 for (int k = 0;
		 k < top;
		 ++k) {
			 int obj[] = xr[k];
			 if (obj != null) xref[k * 2] = obj[0];
		 }
	 }
	 protected PdfDictionary readDictionary() throws IOException {
		 PdfDictionary dic = new PdfDictionary();
		 while (true) {
			 tokens.nextValidToken();
			 if (tokens.getTokenType() == TokenType.END_DIC) break;
			 if (tokens.getTokenType() != TokenType.NAME) tokens.throwError(MessageLocalization.getComposedMessage(""dictionary.key.is.not.a.name""));
			 PdfName name = new PdfName(tokens.getStringValue(), false);
			 PdfObject obj = readPRObject();
			 int type = obj.type();
			 if (-type == TokenType.END_DIC.ordinal()) tokens.throwError(MessageLocalization.getComposedMessage(""unexpected.gt.gt""));
			 if (-type == TokenType.END_ARRAY.ordinal()) tokens.throwError(MessageLocalization.getComposedMessage(""unexpected.close.bracket""));
			 dic.put(name, obj);
		 }
		 return dic;
	 }
	 protected PdfArray readArray() throws IOException {
		 PdfArray array = new PdfArray();
		 while (true) {
			 PdfObject obj = readPRObject();
			 int type = obj.type();
			 if (-type == TokenType.END_ARRAY.ordinal()) break;
			 if (-type == TokenType.END_DIC.ordinal()) tokens.throwError(MessageLocalization.getComposedMessage(""unexpected.gt.gt""));
			 array.add(obj);
		 }
		 return array;
	 }
	 private int readDepth = 0;
	 protected PdfObject readPRObject() throws IOException {
		 tokens.nextValidToken();
		 TokenType type = tokens.getTokenType();
		 switch (type) {
			 case START_DIC: {
				 ++readDepth;
				 PdfDictionary dic = readDictionary();
				 --readDepth;
				 int pos = tokens.getFilePointer();
				 boolean hasNext;
				 do {
					 hasNext = tokens.nextToken();
				 }
				 while (hasNext && tokens.getTokenType() == TokenType.COMMENT);
				 if (hasNext && tokens.getStringValue().equals(""stream"")) {
					 int ch;
					 do {
						 ch = tokens.read();
					 }
					 while (ch == 32 || ch == 9 || ch == 0 || ch == 12);
					 if (ch != '\n') ch = tokens.read();
					 if (ch != '\n') tokens.backOnePosition(ch);
					 PRStream stream = new PRStream(this, tokens.getFilePointer());
					 stream.putAll(dic);
					 stream.setObjNum(objNum, objGen);
					 return stream;
				 }
				 else {
					 tokens.seek(pos);
					 return dic;
				 }
			 }
			 case START_ARRAY: {
				 ++readDepth;
				 PdfArray arr = readArray();
				 --readDepth;
				 return arr;
			 }
			 case NUMBER: return new PdfNumber(tokens.getStringValue());
			 case STRING: PdfString str = new PdfString(tokens.getStringValue(), null).setHexWriting(tokens.isHexString());
			 str.setObjNum(objNum, objGen);
			 if (strings != null) strings.add(str);
			 return str;
			 case NAME: {
				 PdfName cachedName = PdfName.staticNames.get( tokens.getStringValue() );
				 if (readDepth > 0 && cachedName != null) {
					 return cachedName;
				 }
				 else {
					 return new PdfName(tokens.getStringValue(), false);
				 }
			 }
			 case REF: int num = tokens.getReference();
			 PRIndirectReference ref = new PRIndirectReference(this, num, tokens.getGeneration());
			 return ref;
			 case ENDOFFILE: throw new IOException(MessageLocalization.getComposedMessage(""unexpected.end.of.file""));
			 default: String sv = tokens.getStringValue();
			 if (""null"".equals(sv)) {
				 if (readDepth == 0) {
					 return new PdfNull();
				 }
				 return PdfNull.PDFNULL;
			 }
			 else if (""true"".equals(sv)) {
				 if (readDepth == 0) {
					 return new PdfBoolean( true );
				 }
				 return PdfBoolean.PDFTRUE;
			 }
			 else if (""false"".equals(sv)) {
				 if (readDepth == 0) {
					 return new PdfBoolean( false );
				 }
				 return PdfBoolean.PDFFALSE;
			 }
			 return new PdfLiteral(-type.ordinal(), tokens.getStringValue());
		 }
	 }
	 public static byte[] FlateDecode(byte in[]) {
		 byte b[] = FlateDecode(in, true);
		 if (b == null) return FlateDecode(in, false);
		 return b;
	 }
	 public static byte[] decodePredictor(byte in[], PdfObject dicPar) {
		 if (dicPar == null || !dicPar.isDictionary()) return in;
		 PdfDictionary dic = (PdfDictionary)dicPar;
		 PdfObject obj = getPdfObject(dic.get(PdfName.PREDICTOR));
		 if (obj == null || !obj.isNumber()) return in;
		 int predictor = ((PdfNumber)obj).intValue();
		 if (predictor < 10) return in;
		 int width = 1;
		 obj = getPdfObject(dic.get(PdfName.COLUMNS));
		 if (obj != null && obj.isNumber()) width = ((PdfNumber)obj).intValue();
		 int colors = 1;
		 obj = getPdfObject(dic.get(PdfName.COLORS));
		 if (obj != null && obj.isNumber()) colors = ((PdfNumber)obj).intValue();
		 int bpc = 8;
		 obj = getPdfObject(dic.get(PdfName.BITSPERCOMPONENT));
		 if (obj != null && obj.isNumber()) bpc = ((PdfNumber)obj).intValue();
		 DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(in));
		 ByteArrayOutputStream fout = new ByteArrayOutputStream(in.length);
		 int bytesPerPixel = colors * bpc / 8;
		 int bytesPerRow = (colors*width*bpc + 7)/8;
		 byte[] curr = new byte[bytesPerRow];
		 byte[] prior = new byte[bytesPerRow];
		 while (true) {
			 int filter = 0;
			 try {
				 filter = dataStream.read();
				 if (filter < 0) {
					 return fout.toByteArray();
				 }
				 dataStream.readFully(curr, 0, bytesPerRow);
			 }
			 catch (Exception e) {
				 return fout.toByteArray();
			 }
			 switch (filter) {
				 case 0: break;
				 case 1: for (int i = bytesPerPixel;
				 i < bytesPerRow;
				 i++) {
					 curr[i] += curr[i - bytesPerPixel];
				 }
				 break;
				 case 2: for (int i = 0;
				 i < bytesPerRow;
				 i++) {
					 curr[i] += prior[i];
				 }
				 break;
				 case 3: for (int i = 0;
				 i < bytesPerPixel;
				 i++) {
					 curr[i] += prior[i] / 2;
				 }
				 for (int i = bytesPerPixel;
				 i < bytesPerRow;
				 i++) {
					 curr[i] += ((curr[i - bytesPerPixel] & 0xff) + (prior[i] & 0xff))/2;
				 }
				 break;
				 case 4: for (int i = 0;
				 i < bytesPerPixel;
				 i++) {
					 curr[i] += prior[i];
				 }
				 for (int i = bytesPerPixel;
				 i < bytesPerRow;
				 i++) {
					 int a = curr[i - bytesPerPixel] & 0xff;
					 int b = prior[i] & 0xff;
					 int c = prior[i - bytesPerPixel] & 0xff;
					 int p = a + b - c;
					 int pa = Math.abs(p - a);
					 int pb = Math.abs(p - b);
					 int pc = Math.abs(p - c);
					 int ret;
					 if (pa <= pb && pa <= pc) {
						 ret = a;
					 }
					 else if (pb <= pc) {
						 ret = b;
					 }
					 else {
						 ret = c;
					 }
					 curr[i] += (byte)ret;
				 }
				 break;
				 default: throw new RuntimeException(MessageLocalization.getComposedMessage(""png.filter.unknown""));
			 }
			 try {
				 fout.write(curr);
			 }
			 catch (IOException ioe) {
			 }
			 byte[] tmp = prior;
			 prior = curr;
			 curr = tmp;
		 }
	 }
	 public static byte[] FlateDecode(byte in[], boolean strict) {
		 ByteArrayInputStream stream = new ByteArrayInputStream(in);
		 InflaterInputStream zip = new InflaterInputStream(stream);
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 byte b[] = new byte[strict ? 4092 : 1];
		 try {
			 int n;
			 while ((n = zip.read(b)) >= 0) {
				 out.write(b, 0, n);
			 }
			 zip.close();
			 out.close();
			 return out.toByteArray();
		 }
		 catch (Exception e) {
			 if (strict) return null;
			 return out.toByteArray();
		 }
	 }
	 public static byte[] ASCIIHexDecode(byte in[]) {
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 boolean first = true;
		 int n1 = 0;
		 for (int k = 0;
		 k < in.length;
		 ++k) {
			 int ch = in[k] & 0xff;
			 if (ch == '>') break;
			 if (PRTokeniser.isWhitespace(ch)) continue;
			 int n = PRTokeniser.getHex(ch);
			 if (n == -1) throw new RuntimeException(MessageLocalization.getComposedMessage(""illegal.character.in.asciihexdecode""));
			 if (first) n1 = n;
			 else out.write((byte)((n1 << 4) + n));
			 first = !first;
		 }
		 if (!first) out.write((byte)(n1 << 4));
		 return out.toByteArray();
	 }
	 public static byte[] ASCII85Decode(byte in[]) {
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 int state = 0;
		 int chn[] = new int[5];
		 for (int k = 0;
		 k < in.length;
		 ++k) {
			 int ch = in[k] & 0xff;
			 if (ch == '~') break;
			 if (PRTokeniser.isWhitespace(ch)) continue;
			 if (ch == 'z' && state == 0) {
				 out.write(0);
				 out.write(0);
				 out.write(0);
				 out.write(0);
				 continue;
			 }
			 if (ch < '!' || ch > 'u') throw new RuntimeException(MessageLocalization.getComposedMessage(""illegal.character.in.ascii85decode""));
			 chn[state] = ch - '!';
			 ++state;
			 if (state == 5) {
				 state = 0;
				 int r = 0;
				 for (int j = 0;
				 j < 5;
				 ++j) r = r * 85 + chn[j];
				 out.write((byte)(r >> 24));
				 out.write((byte)(r >> 16));
				 out.write((byte)(r >> 8));
				 out.write((byte)r);
			 }
		 }
		 int r = 0;
		 if (state == 2) {
			 r = chn[0] * 85 * 85 * 85 * 85 + chn[1] * 85 * 85 * 85 + 85 * 85 * 85 + 85 * 85 + 85;
			 out.write((byte)(r >> 24));
		 }
		 else if (state == 3) {
			 r = chn[0] * 85 * 85 * 85 * 85 + chn[1] * 85 * 85 * 85 + chn[2] * 85 * 85 + 85 * 85 + 85;
			 out.write((byte)(r >> 24));
			 out.write((byte)(r >> 16));
		 }
		 else if (state == 4) {
			 r = chn[0] * 85 * 85 * 85 * 85 + chn[1] * 85 * 85 * 85 + chn[2] * 85 * 85 + chn[3] * 85 + 85;
			 out.write((byte)(r >> 24));
			 out.write((byte)(r >> 16));
			 out.write((byte)(r >> 8));
		 }
		 return out.toByteArray();
	 }
	 public static byte[] LZWDecode(byte in[]) {
		 ByteArrayOutputStream out = new ByteArrayOutputStream();
		 LZWDecoder lzw = new LZWDecoder();
		 lzw.decode(in, out);
		 return out.toByteArray();
	 }
	 public boolean isRebuilt() {
		 return this.rebuilt;
	 }
	 public PdfDictionary getPageN(int pageNum) {
		 PdfDictionary dic = pageRefs.getPageN(pageNum);
		 if (dic == null) return null;
		 if (appendable) dic.setIndRef(pageRefs.getPageOrigRef(pageNum));
		 return dic;
	 }
	 public PdfDictionary getPageNRelease(int pageNum) {
		 PdfDictionary dic = getPageN(pageNum);
		 pageRefs.releasePage(pageNum);
		 return dic;
	 }
	 public void releasePage(int pageNum) {
		 pageRefs.releasePage(pageNum);
	 }
	 public void resetReleasePage() {
		 pageRefs.resetReleasePage();
	 }
	 public PRIndirectReference getPageOrigRef(int pageNum) {
		 return pageRefs.getPageOrigRef(pageNum);
	 }
	 public byte[] getPageContent(int pageNum, RandomAccessFileOrArray file) throws IOException{
		 PdfDictionary page = getPageNRelease(pageNum);
		 if (page == null) return null;
		 PdfObject contents = getPdfObjectRelease(page.get(PdfName.CONTENTS));
		 if (contents == null) return new byte[0];
		 ByteArrayOutputStream bout = null;
		 if (contents.isStream()) {
			 return getStreamBytes((PRStream)contents, file);
		 }
		 else if (contents.isArray()) {
			 PdfArray array = (PdfArray)contents;
			 bout = new ByteArrayOutputStream();
			 for (int k = 0;
			 k < array.size();
			 ++k) {
				 PdfObject item = getPdfObjectRelease(array.getPdfObject(k));
				 if (item == null || !item.isStream()) continue;
				 byte[] b = getStreamBytes((PRStream)item, file);
				 bout.write(b);
				 if (k != array.size() - 1) bout.write('\n');
			 }
			 return bout.toByteArray();
		 }
		 else return new byte[0];
	 }
	 public byte[] getPageContent(int pageNum) throws IOException{
		 RandomAccessFileOrArray rf = getSafeFile();
		 try {
			 rf.reOpen();
			 return getPageContent(pageNum, rf);
		 }
		 finally {
			 try{
				rf.close();
			}
			catch(Exception e){
			}
		 }
	 }
	 protected void killXref(PdfObject obj) {
		 if (obj == null) return;
		 if (obj instanceof PdfIndirectReference && !obj.isIndirect()) return;
		 switch (obj.type()) {
			 case PdfObject.INDIRECT: {
				 int xr = ((PRIndirectReference)obj).getNumber();
				 obj = xrefObj.get(xr);
				 xrefObj.set(xr, null);
				 freeXref = xr;
				 killXref(obj);
				 break;
			 }
			 case PdfObject.ARRAY: {
				 PdfArray t = (PdfArray)obj;
				 for (int i = 0;
				 i < t.size();
				 ++i) killXref(t.getPdfObject(i));
				 break;
			 }
			 case PdfObject.STREAM: case PdfObject.DICTIONARY: {
				 PdfDictionary dic = (PdfDictionary)obj;
				 for (Object element : dic.getKeys()) {
					 killXref(dic.get((PdfName)element));
				 }
				 break;
			 }
		 }
	 }
	 public void setPageContent(int pageNum, byte content[]) {
		 setPageContent(pageNum, content, PdfStream.DEFAULT_COMPRESSION);
	 }
	 public void setPageContent(int pageNum, byte content[], int compressionLevel) {
		 PdfDictionary page = getPageN(pageNum);
		 if (page == null) return;
		 PdfObject contents = page.get(PdfName.CONTENTS);
		 freeXref = -1;
		 killXref(contents);
		 if (freeXref == -1) {
			 xrefObj.add(null);
			 freeXref = xrefObj.size() - 1;
		 }
		 page.put(PdfName.CONTENTS, new PRIndirectReference(this, freeXref));
		 xrefObj.set(freeXref, new PRStream(this, content, compressionLevel));
	 }
	 public static byte[] getStreamBytes(PRStream stream, RandomAccessFileOrArray file) throws IOException {
		 PdfObject filter = getPdfObjectRelease(stream.get(PdfName.FILTER));
		 byte[] b = getStreamBytesRaw(stream, file);
		 ArrayList<PdfObject> filters = new ArrayList<PdfObject>();
		 if (filter != null) {
			 if (filter.isName()) filters.add(filter);
			 else if (filter.isArray()) filters = ((PdfArray)filter).getArrayList();
		 }
		 ArrayList<PdfObject> dp = new ArrayList<PdfObject>();
		 PdfObject dpo = getPdfObjectRelease(stream.get(PdfName.DECODEPARMS));
		 if (dpo == null || !dpo.isDictionary() && !dpo.isArray()) dpo = getPdfObjectRelease(stream.get(PdfName.DP));
		 if (dpo != null) {
			 if (dpo.isDictionary()) dp.add(dpo);
			 else if (dpo.isArray()) dp = ((PdfArray)dpo).getArrayList();
		 }
		 PdfName name;
		 for (int j = 0;
		 j < filters.size();
		 ++j) {
			 name = (PdfName)getPdfObjectRelease(filters.get(j));
			 if (PdfName.FLATEDECODE.equals(name) || PdfName.FL.equals(name)) {
				 b = FlateDecode(b);
				 PdfObject dicParam = null;
				 if (j < dp.size()) {
					 dicParam = dp.get(j);
					 b = decodePredictor(b, dicParam);
				 }
			 }
			 else if (PdfName.ASCIIHEXDECODE.equals(name) || PdfName.AHX.equals(name)) b = ASCIIHexDecode(b);
			 else if (PdfName.ASCII85DECODE.equals(name) || PdfName.A85.equals(name)) b = ASCII85Decode(b);
			 else if (PdfName.LZWDECODE.equals(name)) {
				 b = LZWDecode(b);
				 PdfObject dicParam = null;
				 if (j < dp.size()) {
					 dicParam = dp.get(j);
					 b = decodePredictor(b, dicParam);
				 }
			 }
			 else if (PdfName.CCITTFAXDECODE.equals(name)) {
				 PdfNumber wn = (PdfNumber)getPdfObjectRelease(stream.get(PdfName.WIDTH));
				 PdfNumber hn = (PdfNumber)getPdfObjectRelease(stream.get(PdfName.HEIGHT));
				 if (wn == null || hn == null) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""filter.ccittfaxdecode.is.only.supported.for.images""));
				 int width = wn.intValue();
				 int height = hn.intValue();
				 PdfDictionary param = null;
				 if (j < dp.size()) {
					 PdfObject objParam = getPdfObjectRelease((PdfObject)dp.get(j));
					 if (objParam != null && (objParam instanceof PdfDictionary)) param = (PdfDictionary)objParam;
				 }
				 int k = 0;
				 boolean blackIs1 = false;
				 boolean byteAlign = false;
				 if (param != null) {
					 PdfNumber kn = param.getAsNumber(PdfName.K);
					 if (kn != null) k = kn.intValue();
					 PdfBoolean bo = param.getAsBoolean(PdfName.BLACKIS1);
					 if (bo != null) blackIs1 = bo.booleanValue();
					 bo = param.getAsBoolean(PdfName.ENCODEDBYTEALIGN);
					 if (bo != null) byteAlign = bo.booleanValue();
				 }
				 byte[] outBuf = new byte[(width + 7) / 8 * height];
				 TIFFFaxDecompressor decoder = new TIFFFaxDecompressor();
				 if (k == 0 || k > 0) {
					 int tiffT4Options = k > 0 ? TIFFConstants.GROUP3OPT_2DENCODING : 0;
					 tiffT4Options |= byteAlign ? TIFFConstants.GROUP3OPT_FILLBITS : 0;
					 decoder.SetOptions(1, TIFFConstants.COMPRESSION_CCITTFAX3, tiffT4Options, 0);
					 decoder.decodeRaw(outBuf, b, width, height);
					 if (decoder.fails > 0) {
						 byte[] outBuf2 = new byte[(width + 7) / 8 * height];
						 int oldFails = decoder.fails;
						 decoder.SetOptions(1, TIFFConstants.COMPRESSION_CCITTRLE, tiffT4Options, 0);
						 decoder.decodeRaw(outBuf2, b, width, height);
						 if (decoder.fails < oldFails) {
							 outBuf = outBuf2;
						 }
					 }
				 }
				 else {
					 decoder.SetOptions(1, TIFFConstants.COMPRESSION_CCITTFAX4, 0, 0);
					 decoder.decodeRaw(outBuf, b, width, height);
				 }
				 if (!blackIs1) {
					 int len = outBuf.length;
					 for (int t = 0;
					 t < len;
					 ++t) {
						 outBuf[t] ^= 0xff;
					 }
				 }
				 b = outBuf;
			 }
			 else if (PdfName.CRYPT.equals(name)) {
			 }
			 else throw new UnsupportedPdfException(MessageLocalization.getComposedMessage(""the.filter.1.is.not.supported"", name));
		 }
		 return b;
	 }
	 public static byte[] getStreamBytes(PRStream stream) throws IOException {
		 RandomAccessFileOrArray rf = stream.getReader().getSafeFile();
		 try {
			 rf.reOpen();
			 return getStreamBytes(stream, rf);
		 }
		 finally {
			 try{
				rf.close();
			}
			catch(Exception e){
			}
		 }
	 }
	 public static byte[] getStreamBytesRaw(PRStream stream, RandomAccessFileOrArray file) throws IOException {
		 PdfReader reader = stream.getReader();
		 byte b[];
		 if (stream.getOffset() < 0) b = stream.getBytes();
		 else {
			 b = new byte[stream.getLength()];
			 file.seek(stream.getOffset());
			 file.readFully(b);
			 PdfEncryption decrypt = reader.getDecrypt();
			 if (decrypt != null) {
				 PdfObject filter = getPdfObjectRelease(stream.get(PdfName.FILTER));
				 ArrayList<PdfObject> filters = new ArrayList<PdfObject>();
				 if (filter != null) {
					 if (filter.isName()) filters.add(filter);
					 else if (filter.isArray()) filters = ((PdfArray)filter).getArrayList();
				 }
				 boolean skip = false;
				 for (int k = 0;
				 k < filters.size();
				 ++k) {
					 PdfObject obj = getPdfObjectRelease(filters.get(k));
					 if (obj != null && obj.toString().equals(""/Crypt"")) {
						 skip = true;
						 break;
					 }
				 }
				 if (!skip) {
					 decrypt.setHashKey(stream.getObjNum(), stream.getObjGen());
					 b = decrypt.decryptByteArray(b);
				 }
			 }
		 }
		 return b;
	 }
	 public static byte[] getStreamBytesRaw(PRStream stream) throws IOException {
		 RandomAccessFileOrArray rf = stream.getReader().getSafeFile();
		 try {
			 rf.reOpen();
			 return getStreamBytesRaw(stream, rf);
		 }
		 finally {
			 try{
				rf.close();
			}
			catch(Exception e){
			}
		 }
	 }
	 public void eliminateSharedStreams() {
		 if (!sharedStreams) return;
		 sharedStreams = false;
		 if (pageRefs.size() == 1) return;
		 ArrayList<PRIndirectReference> newRefs = new ArrayList<PRIndirectReference>();
		 ArrayList<PRStream> newStreams = new ArrayList<PRStream>();
		 IntHashtable visited = new IntHashtable();
		 for (int k = 1;
		 k <= pageRefs.size();
		 ++k) {
			 PdfDictionary page = pageRefs.getPageN(k);
			 if (page == null) continue;
			 PdfObject contents = getPdfObject(page.get(PdfName.CONTENTS));
			 if (contents == null) continue;
			 if (contents.isStream()) {
				 PRIndirectReference ref = (PRIndirectReference)page.get(PdfName.CONTENTS);
				 if (visited.containsKey(ref.getNumber())) {
					 newRefs.add(ref);
					 newStreams.add(new PRStream((PRStream)contents, null));
				 }
				 else visited.put(ref.getNumber(), 1);
			 }
			 else if (contents.isArray()) {
				 PdfArray array = (PdfArray)contents;
				 for (int j = 0;
				 j < array.size();
				 ++j) {
					 PRIndirectReference ref = (PRIndirectReference)array.getPdfObject(j);
					 if (visited.containsKey(ref.getNumber())) {
						 newRefs.add(ref);
						 newStreams.add(new PRStream((PRStream)getPdfObject(ref), null));
					 }
					 else visited.put(ref.getNumber(), 1);
				 }
			 }
		 }
		 if (newStreams.isEmpty()) return;
		 for (int k = 0;
		 k < newStreams.size();
		 ++k) {
			 xrefObj.add(newStreams.get(k));
			 PRIndirectReference ref = newRefs.get(k);
			 ref.setNumber(xrefObj.size() - 1, 0);
		 }
	 }
	 public boolean isTampered() {
		 return tampered;
	 }
	 public void setTampered(boolean tampered) {
		 this.tampered = tampered;
		 pageRefs.keepPages();
	 }
	 public byte[] getMetadata() throws IOException {
		 PdfObject obj = getPdfObject(catalog.get(PdfName.METADATA));
		 if (!(obj instanceof PRStream)) return null;
		 RandomAccessFileOrArray rf = getSafeFile();
		 byte b[] = null;
		 try {
			 rf.reOpen();
			 b = getStreamBytes((PRStream)obj, rf);
		 }
		 finally {
			 try {
				 rf.close();
			 }
			 catch (Exception e) {
			 }
		 }
		 return b;
	 }
	 public int getLastXref() {
		 return lastXref;
	 }
	 public int getXrefSize() {
		 return xrefObj.size();
	 }
	 public int getEofPos() {
		 return eofPos;
	 }
	 public char getPdfVersion() {
		 return pdfVersion;
	 }
	 public boolean isEncrypted() {
		 return encrypted;
	 }
	 public int getPermissions() {
		 return pValue;
	 }
	 public boolean is128Key() {
		 return rValue == 3;
	 }
	 public PdfDictionary getTrailer() {
		 return trailer;
	 }
	 PdfEncryption getDecrypt() {
		 return decrypt;
	 }
	 static boolean equalsn(byte a1[], byte a2[]) {
		 int length = a2.length;
		 for (int k = 0;
		 k < length;
		 ++k) {
			 if (a1[k] != a2[k]) return false;
		 }
		 return true;
	 }
	 static boolean existsName(PdfDictionary dic, PdfName key, PdfName value) {
		 PdfObject type = getPdfObjectRelease(dic.get(key));
		 if (type == null || !type.isName()) return false;
		 PdfName name = (PdfName)type;
		 return name.equals(value);
	 }
	 static String getFontName(PdfDictionary dic) {
		 if (dic == null) return null;
		 PdfObject type = getPdfObjectRelease(dic.get(PdfName.BASEFONT));
		 if (type == null || !type.isName()) return null;
		 return PdfName.decodeName(type.toString());
	 }
	 static String getSubsetPrefix(PdfDictionary dic) {
		 if (dic == null) return null;
		 String s = getFontName(dic);
		 if (s == null) return null;
		 if (s.length() < 8 || s.charAt(6) != '+') return null;
		 for (int k = 0;
		 k < 6;
		 ++k) {
			 char c = s.charAt(k);
			 if (c < 'A' || c > 'Z') return null;
		 }
		 return s;
	 }
	 public int shuffleSubsetNames() {
		 int total = 0;
		 for (int k = 1;
		 k < xrefObj.size();
		 ++k) {
			 PdfObject obj = getPdfObjectRelease(k);
			 if (obj == null || !obj.isDictionary()) continue;
			 PdfDictionary dic = (PdfDictionary)obj;
			 if (!existsName(dic, PdfName.TYPE, PdfName.FONT)) continue;
			 if (existsName(dic, PdfName.SUBTYPE, PdfName.TYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.MMTYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.TRUETYPE)) {
				 String s = getSubsetPrefix(dic);
				 if (s == null) continue;
				 String ns = BaseFont.createSubsetPrefix() + s.substring(7);
				 PdfName newName = new PdfName(ns);
				 dic.put(PdfName.BASEFONT, newName);
				 setXrefPartialObject(k, dic);
				 ++total;
				 PdfDictionary fd = dic.getAsDict(PdfName.FONTDESCRIPTOR);
				 if (fd == null) continue;
				 fd.put(PdfName.FONTNAME, newName);
			 }
			 else if (existsName(dic, PdfName.SUBTYPE, PdfName.TYPE0)) {
				 String s = getSubsetPrefix(dic);
				 PdfArray arr = dic.getAsArray(PdfName.DESCENDANTFONTS);
				 if (arr == null) continue;
				 if (arr.isEmpty()) continue;
				 PdfDictionary desc = arr.getAsDict(0);
				 String sde = getSubsetPrefix(desc);
				 if (sde == null) continue;
				 String ns = BaseFont.createSubsetPrefix();
				 if (s != null) dic.put(PdfName.BASEFONT, new PdfName(ns + s.substring(7)));
				 setXrefPartialObject(k, dic);
				 PdfName newName = new PdfName(ns + sde.substring(7));
				 desc.put(PdfName.BASEFONT, newName);
				 ++total;
				 PdfDictionary fd = desc.getAsDict(PdfName.FONTDESCRIPTOR);
				 if (fd == null) continue;
				 fd.put(PdfName.FONTNAME, newName);
			 }
		 }
		 return total;
	 }
	 public int createFakeFontSubsets() {
		 int total = 0;
		 for (int k = 1;
		 k < xrefObj.size();
		 ++k) {
			 PdfObject obj = getPdfObjectRelease(k);
			 if (obj == null || !obj.isDictionary()) continue;
			 PdfDictionary dic = (PdfDictionary)obj;
			 if (!existsName(dic, PdfName.TYPE, PdfName.FONT)) continue;
			 if (existsName(dic, PdfName.SUBTYPE, PdfName.TYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.MMTYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.TRUETYPE)) {
				 String s = getSubsetPrefix(dic);
				 if (s != null) continue;
				 s = getFontName(dic);
				 if (s == null) continue;
				 String ns = BaseFont.createSubsetPrefix() + s;
				 PdfDictionary fd = (PdfDictionary)getPdfObjectRelease(dic.get(PdfName.FONTDESCRIPTOR));
				 if (fd == null) continue;
				 if (fd.get(PdfName.FONTFILE) == null && fd.get(PdfName.FONTFILE2) == null && fd.get(PdfName.FONTFILE3) == null) continue;
				 fd = dic.getAsDict(PdfName.FONTDESCRIPTOR);
				 PdfName newName = new PdfName(ns);
				 dic.put(PdfName.BASEFONT, newName);
				 fd.put(PdfName.FONTNAME, newName);
				 setXrefPartialObject(k, dic);
				 ++total;
			 }
		 }
		 return total;
	 }
	 private static PdfArray getNameArray(PdfObject obj) {
		 if (obj == null) return null;
		 obj = getPdfObjectRelease(obj);
		 if (obj == null) return null;
		 if (obj.isArray()) return (PdfArray)obj;
		 else if (obj.isDictionary()) {
			 PdfObject arr2 = getPdfObjectRelease(((PdfDictionary)obj).get(PdfName.D));
			 if (arr2 != null && arr2.isArray()) return (PdfArray)arr2;
		 }
		 return null;
	 }
	 public HashMap<Object, PdfObject> getNamedDestination() {
		 return getNamedDestination(false);
	 }
	 public HashMap<Object, PdfObject> getNamedDestination(boolean keepNames) {
		 HashMap<Object, PdfObject> names = getNamedDestinationFromNames(keepNames);
		 names.putAll(getNamedDestinationFromStrings());
		 return names;
	 }
	 public HashMap<String, PdfObject> getNamedDestinationFromNames() {
		 return new HashMap(getNamedDestinationFromNames(false));
	 }
	 public HashMap<Object, PdfObject> getNamedDestinationFromNames(boolean keepNames) {
		 HashMap<Object, PdfObject> names = new HashMap<Object, PdfObject>();
		 if (catalog.get(PdfName.DESTS) != null) {
			 PdfDictionary dic = (PdfDictionary)getPdfObjectRelease(catalog.get(PdfName.DESTS));
			 if (dic == null) return names;
			 Set<PdfName> keys = dic.getKeys();
			 for (PdfName key : keys) {
				 PdfArray arr = getNameArray(dic.get(key));
				 if (arr == null) continue;
				 if (keepNames) {
					 names.put(key, arr);
				 }
				 else {
					 String name = PdfName.decodeName(key.toString());
					 names.put(name, arr);
				 }
			 }
		 }
		 return names;
	 }
	 public HashMap<String, PdfObject> getNamedDestinationFromStrings() {
		 if (catalog.get(PdfName.NAMES) != null) {
			 PdfDictionary dic = (PdfDictionary)getPdfObjectRelease(catalog.get(PdfName.NAMES));
			 if (dic != null) {
				 dic = (PdfDictionary)getPdfObjectRelease(dic.get(PdfName.DESTS));
				 if (dic != null) {
					 HashMap<String, PdfObject> names = PdfNameTree.readTree(dic);
					 for (Iterator<Map.Entry<String, PdfObject>> it = names.entrySet().iterator();
					 it.hasNext();
					) {
						 Map.Entry<String, PdfObject> entry = it.next();
						 PdfArray arr = getNameArray(entry.getValue());
						 if (arr != null) entry.setValue(arr);
						 else it.remove();
					 }
					 return names;
				 }
			 }
		 }
		 return new HashMap<String, PdfObject>();
	 }
	 public void removeFields() {
		 pageRefs.resetReleasePage();
		 for (int k = 1;
		 k <= pageRefs.size();
		 ++k) {
			 PdfDictionary page = pageRefs.getPageN(k);
			 PdfArray annots = page.getAsArray(PdfName.ANNOTS);
			 if (annots == null) {
				 pageRefs.releasePage(k);
				 continue;
			 }
			 for (int j = 0;
			 j < annots.size();
			 ++j) {
				 PdfObject obj = getPdfObjectRelease(annots.getPdfObject(j));
				 if (obj == null || !obj.isDictionary()) continue;
				 PdfDictionary annot = (PdfDictionary)obj;
				 if (PdfName.WIDGET.equals(annot.get(PdfName.SUBTYPE))) annots.remove(j--);
			 }
			 if (annots.isEmpty()) page.remove(PdfName.ANNOTS);
			 else pageRefs.releasePage(k);
		 }
		 catalog.remove(PdfName.ACROFORM);
		 pageRefs.resetReleasePage();
	 }
	 public void removeAnnotations() {
		 pageRefs.resetReleasePage();
		 for (int k = 1;
		 k <= pageRefs.size();
		 ++k) {
			 PdfDictionary page = pageRefs.getPageN(k);
			 if (page.get(PdfName.ANNOTS) == null) pageRefs.releasePage(k);
			 else page.remove(PdfName.ANNOTS);
		 }
		 catalog.remove(PdfName.ACROFORM);
		 pageRefs.resetReleasePage();
	 }
	 public ArrayList<PdfAnnotation.PdfImportedLink> getLinks(int page) {
		 pageRefs.resetReleasePage();
		 ArrayList<PdfAnnotation.PdfImportedLink> result = new ArrayList<PdfAnnotation.PdfImportedLink>();
		 PdfDictionary pageDic = pageRefs.getPageN(page);
		 if (pageDic.get(PdfName.ANNOTS) != null) {
			 PdfArray annots = pageDic.getAsArray(PdfName.ANNOTS);
			 for (int j = 0;
			 j < annots.size();
			 ++j) {
				 PdfDictionary annot = (PdfDictionary)getPdfObjectRelease(annots.getPdfObject(j));
				 if (PdfName.LINK.equals(annot.get(PdfName.SUBTYPE))) {
					 result.add(new PdfAnnotation.PdfImportedLink(annot));
				 }
			 }
		 }
		 pageRefs.releasePage(page);
		 pageRefs.resetReleasePage();
		 return result;
	 }
	 private void iterateBookmarks(PdfObject outlineRef, HashMap<Object, PdfObject> names) {
		 while (outlineRef != null) {
			 replaceNamedDestination(outlineRef, names);
			 PdfDictionary outline = (PdfDictionary)getPdfObjectRelease(outlineRef);
			 PdfObject first = outline.get(PdfName.FIRST);
			 if (first != null) {
				 iterateBookmarks(first, names);
			 }
			 outlineRef = outline.get(PdfName.NEXT);
		 }
	 }
	 public void makeRemoteNamedDestinationsLocal() {
		 if (remoteToLocalNamedDestinations) return;
		 remoteToLocalNamedDestinations = true;
		 HashMap<Object, PdfObject> names = getNamedDestination(true);
		 if (names.isEmpty()) return;
		 for (int k = 1;
		 k <= pageRefs.size();
		 ++k) {
			 PdfDictionary page = pageRefs.getPageN(k);
			 PdfObject annotsRef;
			 PdfArray annots = (PdfArray)getPdfObject(annotsRef = page.get(PdfName.ANNOTS));
			 int annotIdx = lastXrefPartial;
			 releaseLastXrefPartial();
			 if (annots == null) {
				 pageRefs.releasePage(k);
				 continue;
			 }
			 boolean commitAnnots = false;
			 for (int an = 0;
			 an < annots.size();
			 ++an) {
				 PdfObject objRef = annots.getPdfObject(an);
				 if (convertNamedDestination(objRef, names) && !objRef.isIndirect()) commitAnnots = true;
			 }
			 if (commitAnnots) setXrefPartialObject(annotIdx, annots);
			 if (!commitAnnots || annotsRef.isIndirect()) pageRefs.releasePage(k);
		 }
	 }
	 private boolean convertNamedDestination(PdfObject obj, HashMap<Object, PdfObject> names) {
		 obj = getPdfObject(obj);
		 int objIdx = lastXrefPartial;
		 releaseLastXrefPartial();
		 if (obj != null && obj.isDictionary()) {
			 PdfObject ob2 = getPdfObject(((PdfDictionary)obj).get(PdfName.A));
			 if (ob2 != null) {
				 int obj2Idx = lastXrefPartial;
				 releaseLastXrefPartial();
				 PdfDictionary dic = (PdfDictionary)ob2;
				 PdfName type = (PdfName)getPdfObjectRelease(dic.get(PdfName.S));
				 if (PdfName.GOTOR.equals(type)) {
					 PdfObject ob3 = getPdfObjectRelease(dic.get(PdfName.D));
					 Object name = null;
					 if (ob3 != null) {
						 if (ob3.isName()) name = ob3;
						 else if (ob3.isString()) name = ob3.toString();
						 PdfArray dest = (PdfArray)names.get(name);
						 if (dest != null) {
							 dic.remove(PdfName.F);
							 dic.remove(PdfName.NEWWINDOW);
							 dic.put(PdfName.S, PdfName.GOTO);
							 setXrefPartialObject(obj2Idx, ob2);
							 setXrefPartialObject(objIdx, obj);
							 return true;
						 }
					 }
				 }
			 }
		 }
		 return false;
	 }
	 public void consolidateNamedDestinations() {
		 if (consolidateNamedDestinations) return;
		 consolidateNamedDestinations = true;
		 HashMap<Object, PdfObject> names = getNamedDestination(true);
		 if (names.isEmpty()) return;
		 for (int k = 1;
		 k <= pageRefs.size();
		 ++k) {
			 PdfDictionary page = pageRefs.getPageN(k);
			 PdfObject annotsRef;
			 PdfArray annots = (PdfArray)getPdfObject(annotsRef = page.get(PdfName.ANNOTS));
			 int annotIdx = lastXrefPartial;
			 releaseLastXrefPartial();
			 if (annots == null) {
				 pageRefs.releasePage(k);
				 continue;
			 }
			 boolean commitAnnots = false;
			 for (int an = 0;
			 an < annots.size();
			 ++an) {
				 PdfObject objRef = annots.getPdfObject(an);
				 if (replaceNamedDestination(objRef, names) && !objRef.isIndirect()) commitAnnots = true;
			 }
			 if (commitAnnots) setXrefPartialObject(annotIdx, annots);
			 if (!commitAnnots || annotsRef.isIndirect()) pageRefs.releasePage(k);
		 }
		 PdfDictionary outlines = (PdfDictionary)getPdfObjectRelease(catalog.get(PdfName.OUTLINES));
		 if (outlines == null) return;
		 iterateBookmarks(outlines.get(PdfName.FIRST), names);
	 }
	 private boolean replaceNamedDestination(PdfObject obj, HashMap<Object, PdfObject> names) {
		 obj = getPdfObject(obj);
		 int objIdx = lastXrefPartial;
		 releaseLastXrefPartial();
		 if (obj != null && obj.isDictionary()) {
			 PdfObject ob2 = getPdfObjectRelease(((PdfDictionary)obj).get(PdfName.DEST));
			 Object name = null;
			 if (ob2 != null) {
				 if (ob2.isName()) name = ob2;
				 else if (ob2.isString()) name = ob2.toString();
				 PdfArray dest = (PdfArray)names.get(name);
				 if (dest != null) {
					 ((PdfDictionary)obj).put(PdfName.DEST, dest);
					 setXrefPartialObject(objIdx, obj);
					 return true;
				 }
			 }
			 else if ((ob2 = getPdfObject(((PdfDictionary)obj).get(PdfName.A))) != null) {
				 int obj2Idx = lastXrefPartial;
				 releaseLastXrefPartial();
				 PdfDictionary dic = (PdfDictionary)ob2;
				 PdfName type = (PdfName)getPdfObjectRelease(dic.get(PdfName.S));
				 if (PdfName.GOTO.equals(type)) {
					 PdfObject ob3 = getPdfObjectRelease(dic.get(PdfName.D));
					 if (ob3 != null) {
						 if (ob3.isName()) name = ob3;
						 else if (ob3.isString()) name = ob3.toString();
					 }
					 PdfArray dest = (PdfArray)names.get(name);
					 if (dest != null) {
						 dic.put(PdfName.D, dest);
						 setXrefPartialObject(obj2Idx, ob2);
						 setXrefPartialObject(objIdx, obj);
						 return true;
					 }
				 }
			 }
		 }
		 return false;
	 }
	 protected static PdfDictionary duplicatePdfDictionary(PdfDictionary original, PdfDictionary copy, PdfReader newReader) {
		 if (copy == null) copy = new PdfDictionary();
		 for (Object element : original.getKeys()) {
			 PdfName key = (PdfName)element;
			 copy.put(key, duplicatePdfObject(original.get(key), newReader));
		 }
		 return copy;
	 }
	 protected static PdfObject duplicatePdfObject(PdfObject original, PdfReader newReader) {
		 if (original == null) return null;
		 switch (original.type()) {
			 case PdfObject.DICTIONARY: {
				 return duplicatePdfDictionary((PdfDictionary)original, null, newReader);
			 }
			 case PdfObject.STREAM: {
				 PRStream org = (PRStream)original;
				 PRStream stream = new PRStream(org, null, newReader);
				 duplicatePdfDictionary(org, stream, newReader);
				 return stream;
			 }
			 case PdfObject.ARRAY: {
				 PdfArray arr = new PdfArray();
				 for (Iterator<PdfObject> it = ((PdfArray)original).listIterator();
				 it.hasNext();
				) {
					 arr.add(duplicatePdfObject(it.next(), newReader));
				 }
				 return arr;
			 }
			 case PdfObject.INDIRECT: {
				 PRIndirectReference org = (PRIndirectReference)original;
				 return new PRIndirectReference(newReader, org.getNumber(), org.getGeneration());
			 }
			 default: return original;
		 }
	 }
	 public void close() {
		 if (!partial) return;
		 try {
			 tokens.close();
		 }
		 catch (IOException e) {
			 throw new ExceptionConverter(e);
		 }
	 }
	 protected void removeUnusedNode(PdfObject obj, boolean hits[]) {
		 Stack<Object> state = new Stack<Object>();
		 state.push(obj);
		 while (!state.empty()) {
			 Object current = state.pop();
			 if (current == null) continue;
			 ArrayList<PdfObject> ar = null;
			 PdfDictionary dic = null;
			 PdfName[] keys = null;
			 Object[] objs = null;
			 int idx = 0;
			 if (current instanceof PdfObject) {
				 obj = (PdfObject)current;
				 switch (obj.type()) {
					 case PdfObject.DICTIONARY: case PdfObject.STREAM: dic = (PdfDictionary)obj;
					 keys = new PdfName[dic.size()];
					 dic.getKeys().toArray(keys);
					 break;
					 case PdfObject.ARRAY: ar = ((PdfArray)obj).getArrayList();
					 break;
					 case PdfObject.INDIRECT: PRIndirectReference ref = (PRIndirectReference)obj;
					 int num = ref.getNumber();
					 if (!hits[num]) {
						 hits[num] = true;
						 state.push(getPdfObjectRelease(ref));
					 }
					 continue;
					 default: continue;
				 }
			 }
			 else {
				 objs = (Object[])current;
				 if (objs[0] instanceof ArrayList) {
					 ar = (ArrayList<PdfObject>)objs[0];
					 idx = ((Integer)objs[1]).intValue();
				 }
				 else {
					 keys = (PdfName[])objs[0];
					 dic = (PdfDictionary)objs[1];
					 idx = ((Integer)objs[2]).intValue();
				 }
			 }
			 if (ar != null) {
				 for (int k = idx;
				 k < ar.size();
				 ++k) {
					 PdfObject v = ar.get(k);
					 if (v.isIndirect()) {
						 int num = ((PRIndirectReference)v).getNumber();
						 if (num >= xrefObj.size() || !partial && xrefObj.get(num) == null) {
							 ar.set(k, PdfNull.PDFNULL);
							 continue;
						 }
					 }
					 if (objs == null) state.push(new Object[]{
					ar, new Integer(k + 1)}
					);
					 else {
						 objs[1] = new Integer(k + 1);
						 state.push(objs);
					 }
					 state.push(v);
					 break;
				 }
			 }
			 else {
				 for (int k = idx;
				 k < keys.length;
				 ++k) {
					 PdfName key = keys[k];
					 PdfObject v = dic.get(key);
					 if (v.isIndirect()) {
						 int num = ((PRIndirectReference)v).getNumber();
						 if (num >= xrefObj.size() || !partial && xrefObj.get(num) == null) {
							 dic.put(key, PdfNull.PDFNULL);
							 continue;
						 }
					 }
					 if (objs == null) state.push(new Object[]{
					keys, dic, new Integer(k + 1)}
					);
					 else {
						 objs[2] = new Integer(k + 1);
						 state.push(objs);
					 }
					 state.push(v);
					 break;
				 }
			 }
		 }
	 }
	 public int removeUnusedObjects() {
		 boolean hits[] = new boolean[xrefObj.size()];
		 removeUnusedNode(trailer, hits);
		 int total = 0;
		 if (partial) {
			 for (int k = 1;
			 k < hits.length;
			 ++k) {
				 if (!hits[k]) {
					 xref[k * 2] = -1;
					 xref[k * 2 + 1] = 0;
					 xrefObj.set(k, null);
					 ++total;
				 }
			 }
		 }
		 else {
			 for (int k = 1;
			 k < hits.length;
			 ++k) {
				 if (!hits[k]) {
					 xrefObj.set(k, null);
					 ++total;
				 }
			 }
		 }
		 return total;
	 }
	 public AcroFields getAcroFields() {
		 return new AcroFields(this, null);
	 }
	 public String getJavaScript(RandomAccessFileOrArray file) throws IOException {
		 PdfDictionary names = (PdfDictionary)getPdfObjectRelease(catalog.get(PdfName.NAMES));
		 if (names == null) return null;
		 PdfDictionary js = (PdfDictionary)getPdfObjectRelease(names.get(PdfName.JAVASCRIPT));
		 if (js == null) return null;
		 HashMap<String, PdfObject> jscript = PdfNameTree.readTree(js);
		 String sortedNames[] = new String[jscript.size()];
		 sortedNames = jscript.keySet().toArray(sortedNames);
		 Arrays.sort(sortedNames);
		 StringBuffer buf = new StringBuffer();
		 for (int k = 0;
		 k < sortedNames.length;
		 ++k) {
			 PdfDictionary j = (PdfDictionary)getPdfObjectRelease(jscript.get(sortedNames[k]));
			 if (j == null) continue;
			 PdfObject obj = getPdfObjectRelease(j.get(PdfName.JS));
			 if (obj != null) {
				 if (obj.isString()) buf.append(((PdfString)obj).toUnicodeString()).append('\n');
				 else if (obj.isStream()) {
					 byte bytes[] = getStreamBytes((PRStream)obj, file);
					 if (bytes.length >= 2 && bytes[0] == (byte)254 && bytes[1] == (byte)255) buf.append(PdfEncodings.convertToString(bytes, PdfObject.TEXT_UNICODE));
					 else buf.append(PdfEncodings.convertToString(bytes, PdfObject.TEXT_PDFDOCENCODING));
					 buf.append('\n');
				 }
			 }
		 }
		 return buf.toString();
	 }
	 public String getJavaScript() throws IOException {
		 RandomAccessFileOrArray rf = getSafeFile();
		 try {
			 rf.reOpen();
			 return getJavaScript(rf);
		 }
		 finally {
			 try{
				rf.close();
			}
			catch(Exception e){
			}
		 }
	 }
	 public void selectPages(String ranges) {
		 selectPages(SequenceList.expand(ranges, getNumberOfPages()));
	 }
	 public void selectPages(List<Integer> pagesToKeep) {
		 pageRefs.selectPages(pagesToKeep);
		 removeUnusedObjects();
	 }
	 public void setViewerPreferences(int preferences) {
		 this.viewerPreferences.setViewerPreferences(preferences);
		 setViewerPreferences(this.viewerPreferences);
	 }
	 public void addViewerPreference(PdfName key, PdfObject value) {
		 this.viewerPreferences.addViewerPreference(key, value);
		 setViewerPreferences(this.viewerPreferences);
	 }
	 void setViewerPreferences(PdfViewerPreferencesImp vp) {
		 vp.addToCatalog(catalog);
	 }
	 public int getSimpleViewerPreferences() {
		 return PdfViewerPreferencesImp.getViewerPreferences(catalog).getPageLayoutAndMode();
	 }
	 public boolean isAppendable() {
		 return this.appendable;
	 }
	 public void setAppendable(boolean appendable) {
		 this.appendable = appendable;
		 if (appendable) getPdfObject(trailer.get(PdfName.ROOT));
	 }
	 public boolean isNewXrefType() {
		 return newXrefType;
	 }
	 public int getFileLength() {
		 return fileLength;
	 }
	 public boolean isHybridXref() {
		 return hybridXref;
	 }
	 static class PageRefs {
		 private PdfReader reader;
		 private ArrayList<PRIndirectReference> refsn;
		 private int sizep;
		 private IntHashtable refsp;
		 private int lastPageRead = -1;
		 private ArrayList<PdfDictionary> pageInh;
		 private boolean keepPages;
		 private PageRefs(PdfReader reader) throws IOException {
			 this.reader = reader;
			 if (reader.partial) {
				 refsp = new IntHashtable();
				 PdfNumber npages = (PdfNumber)PdfReader.getPdfObjectRelease(reader.rootPages.get(PdfName.COUNT));
				 sizep = npages.intValue();
			 }
			 else {
				 readPages();
			 }
		 }
		 PageRefs(PageRefs other, PdfReader reader) {
			 this.reader = reader;
			 this.sizep = other.sizep;
			 if (other.refsn != null) {
				 refsn = new ArrayList<PRIndirectReference>(other.refsn);
				 for (int k = 0;
				 k < refsn.size();
				 ++k) {
					 refsn.set(k, (PRIndirectReference)duplicatePdfObject(refsn.get(k), reader));
				 }
			 }
			 else this.refsp = (IntHashtable)other.refsp.clone();
		 }
		 int size() {
			 if (refsn != null) return refsn.size();
			 else return sizep;
		 }
		 void readPages() throws IOException {
			 if (refsn != null) return;
			 refsp = null;
			 refsn = new ArrayList<PRIndirectReference>();
			 pageInh = new ArrayList<PdfDictionary>();
			 iteratePages((PRIndirectReference)reader.catalog.get(PdfName.PAGES));
			 pageInh = null;
			 reader.rootPages.put(PdfName.COUNT, new PdfNumber(refsn.size()));
		 }
		 void reReadPages() throws IOException {
			 refsn = null;
			 readPages();
		 }
		 public PdfDictionary getPageN(int pageNum) {
			 PRIndirectReference ref = getPageOrigRef(pageNum);
			 return (PdfDictionary)PdfReader.getPdfObject(ref);
		 }
		 public PdfDictionary getPageNRelease(int pageNum) {
			 PdfDictionary page = getPageN(pageNum);
			 releasePage(pageNum);
			 return page;
		 }
		 public PRIndirectReference getPageOrigRefRelease(int pageNum) {
			 PRIndirectReference ref = getPageOrigRef(pageNum);
			 releasePage(pageNum);
			 return ref;
		 }
		 public PRIndirectReference getPageOrigRef(int pageNum) {
			 try {
				 --pageNum;
				 if (pageNum < 0 || pageNum >= size()) return null;
				 if (refsn != null) return refsn.get(pageNum);
				 else {
					 int n = refsp.get(pageNum);
					 if (n == 0) {
						 PRIndirectReference ref = getSinglePage(pageNum);
						 if (reader.lastXrefPartial == -1) lastPageRead = -1;
						 else lastPageRead = pageNum;
						 reader.lastXrefPartial = -1;
						 refsp.put(pageNum, ref.getNumber());
						 if (keepPages) lastPageRead = -1;
						 return ref;
					 }
					 else {
						 if (lastPageRead != pageNum) lastPageRead = -1;
						 if (keepPages) lastPageRead = -1;
						 return new PRIndirectReference(reader, n);
					 }
				 }
			 }
			 catch (Exception e) {
				 throw new ExceptionConverter(e);
			 }
		 }
		 void keepPages() {
			 if (refsp == null || keepPages) return;
			 keepPages = true;
			 refsp.clear();
		 }
		 public void releasePage(int pageNum) {
			 if (refsp == null) return;
			 --pageNum;
			 if (pageNum < 0 || pageNum >= size()) return;
			 if (pageNum != lastPageRead) return;
			 lastPageRead = -1;
			 reader.lastXrefPartial = refsp.get(pageNum);
			 reader.releaseLastXrefPartial();
			 refsp.remove(pageNum);
		 }
		 public void resetReleasePage() {
			 if (refsp == null) return;
			 lastPageRead = -1;
		 }
		 void insertPage(int pageNum, PRIndirectReference ref) {
			 --pageNum;
			 if (refsn != null) {
				 if (pageNum >= refsn.size()) refsn.add(ref);
				 else refsn.add(pageNum, ref);
			 }
			 else {
				 ++sizep;
				 lastPageRead = -1;
				 if (pageNum >= size()) {
					 refsp.put(size(), ref.getNumber());
				 }
				 else {
					 IntHashtable refs2 = new IntHashtable((refsp.size() + 1) * 2);
					 for (Iterator<IntHashtable.Entry> it = refsp.getEntryIterator();
					 it.hasNext();
					) {
						 IntHashtable.Entry entry = it.next();
						 int p = entry.getKey();
						 refs2.put(p >= pageNum ? p + 1 : p, entry.getValue());
					 }
					 refs2.put(pageNum, ref.getNumber());
					 refsp = refs2;
				 }
			 }
		 }
		 private void pushPageAttributes(PdfDictionary nodePages) {
			 PdfDictionary dic = new PdfDictionary();
			 if (!pageInh.isEmpty()) {
				 dic.putAll(pageInh.get(pageInh.size() - 1));
			 }
			 for (int k = 0;
			 k < pageInhCandidates.length;
			 ++k) {
				 PdfObject obj = nodePages.get(pageInhCandidates[k]);
				 if (obj != null) dic.put(pageInhCandidates[k], obj);
			 }
			 pageInh.add(dic);
		 }
		 private void popPageAttributes() {
			 pageInh.remove(pageInh.size() - 1);
		 }
		 private void iteratePages(PRIndirectReference rpage) throws IOException {
			 PdfDictionary page = (PdfDictionary)getPdfObject(rpage);
			 PdfArray kidsPR = page.getAsArray(PdfName.KIDS);
			 if (kidsPR == null) {
				 page.put(PdfName.TYPE, PdfName.PAGE);
				 PdfDictionary dic = pageInh.get(pageInh.size() - 1);
				 PdfName key;
				 for (Object element : dic.getKeys()) {
					 key = (PdfName)element;
					 if (page.get(key) == null) page.put(key, dic.get(key));
				 }
				 if (page.get(PdfName.MEDIABOX) == null) {
					 PdfArray arr = new PdfArray(new float[]{
					0,0,PageSize.LETTER.getRight(),PageSize.LETTER.getTop()}
					);
					 page.put(PdfName.MEDIABOX, arr);
				 }
				 refsn.add(rpage);
			 }
			 else {
				 page.put(PdfName.TYPE, PdfName.PAGES);
				 pushPageAttributes(page);
				 for (int k = 0;
				 k < kidsPR.size();
				 ++k){
					 PdfObject obj = kidsPR.getPdfObject(k);
					 if (!obj.isIndirect()) {
						 while (k < kidsPR.size()) kidsPR.remove(k);
						 break;
					 }
					 iteratePages((PRIndirectReference)obj);
				 }
				 popPageAttributes();
			 }
		 }
		 protected PRIndirectReference getSinglePage(int n) {
			 PdfDictionary acc = new PdfDictionary();
			 PdfDictionary top = reader.rootPages;
			 int base = 0;
			 while (true) {
				 for (int k = 0;
				 k < pageInhCandidates.length;
				 ++k) {
					 PdfObject obj = top.get(pageInhCandidates[k]);
					 if (obj != null) acc.put(pageInhCandidates[k], obj);
				 }
				 PdfArray kids = (PdfArray)PdfReader.getPdfObjectRelease(top.get(PdfName.KIDS));
				 for (Iterator<PdfObject> it = kids.listIterator();
				 it.hasNext();
				) {
					 PRIndirectReference ref = (PRIndirectReference)it.next();
					 PdfDictionary dic = (PdfDictionary)getPdfObject(ref);
					 int last = reader.lastXrefPartial;
					 PdfObject count = getPdfObjectRelease(dic.get(PdfName.COUNT));
					 reader.lastXrefPartial = last;
					 int acn = 1;
					 if (count != null && count.type() == PdfObject.NUMBER) acn = ((PdfNumber)count).intValue();
					 if (n < base + acn) {
						 if (count == null) {
							 dic.mergeDifferent(acc);
							 return ref;
						 }
						 reader.releaseLastXrefPartial();
						 top = dic;
						 break;
					 }
					 reader.releaseLastXrefPartial();
					 base += acn;
				 }
			 }
		 }
		 private void selectPages(List<Integer> pagesToKeep) {
			 IntHashtable pg = new IntHashtable();
			 ArrayList<Integer> finalPages = new ArrayList<Integer>();
			 int psize = size();
			 for (Integer pi : pagesToKeep) {
				 int p = pi.intValue();
				 if (p >= 1 && p <= psize && pg.put(p, 1) == 0) finalPages.add(pi);
			 }
			 if (reader.partial) {
				 for (int k = 1;
				 k <= psize;
				 ++k) {
					 getPageOrigRef(k);
					 resetReleasePage();
				 }
			 }
			 PRIndirectReference parent = (PRIndirectReference)reader.catalog.get(PdfName.PAGES);
			 PdfDictionary topPages = (PdfDictionary)PdfReader.getPdfObject(parent);
			 ArrayList<PRIndirectReference> newPageRefs = new ArrayList<PRIndirectReference>(finalPages.size());
			 PdfArray kids = new PdfArray();
			 for (int k = 0;
			 k < finalPages.size();
			 ++k) {
				 int p = finalPages.get(k).intValue();
				 PRIndirectReference pref = getPageOrigRef(p);
				 resetReleasePage();
				 kids.add(pref);
				 newPageRefs.add(pref);
				 getPageN(p).put(PdfName.PARENT, parent);
			 }
			 AcroFields af = reader.getAcroFields();
			 boolean removeFields = af.getFields().size() > 0;
			 for (int k = 1;
			 k <= psize;
			 ++k) {
				 if (!pg.containsKey(k)) {
					 if (removeFields) af.removeFieldsFromPage(k);
					 PRIndirectReference pref = getPageOrigRef(k);
					 int nref = pref.getNumber();
					 reader.xrefObj.set(nref, null);
					 if (reader.partial) {
						 reader.xref[nref * 2] = -1;
						 reader.xref[nref * 2 + 1] = 0;
					 }
				 }
			 }
			 topPages.put(PdfName.COUNT, new PdfNumber(finalPages.size()));
			 topPages.put(PdfName.KIDS, kids);
			 refsp = null;
			 refsn = newPageRefs;
		 }
	 }
	 PdfIndirectReference getCryptoRef() {
		 if (cryptoRef == null) return null;
		 return new PdfIndirectReference(0, cryptoRef.getNumber(), cryptoRef.getGeneration());
	 }
	 public void removeUsageRights() {
		 PdfDictionary perms = catalog.getAsDict(PdfName.PERMS);
		 if (perms == null) return;
		 perms.remove(PdfName.UR);
		 perms.remove(PdfName.UR3);
		 if (perms.size() == 0) catalog.remove(PdfName.PERMS);
	 }
	 public int getCertificationLevel() {
		 PdfDictionary dic = catalog.getAsDict(PdfName.PERMS);
		 if (dic == null) return PdfSignatureAppearance.NOT_CERTIFIED;
		 dic = dic.getAsDict(PdfName.DOCMDP);
		 if (dic == null) return PdfSignatureAppearance.NOT_CERTIFIED;
		 PdfArray arr = dic.getAsArray(PdfName.REFERENCE);
		 if (arr == null || arr.size() == 0) return PdfSignatureAppearance.NOT_CERTIFIED;
		 dic = arr.getAsDict(0);
		 if (dic == null) return PdfSignatureAppearance.NOT_CERTIFIED;
		 dic = dic.getAsDict(PdfName.TRANSFORMPARAMS);
		 if (dic == null) return PdfSignatureAppearance.NOT_CERTIFIED;
		 PdfNumber p = dic.getAsNumber(PdfName.P);
		 if (p == null) return PdfSignatureAppearance.NOT_CERTIFIED;
		 return p.intValue();
	 }
	 public final boolean isOpenedWithFullPermissions() {
		 return !encrypted || ownerPasswordUsed || unethicalreading;
	 }
	 public int getCryptoMode() {
		 if (decrypt == null) return -1;
		 else return decrypt.getCryptoMode();
	 }
	 public boolean isMetadataEncrypted() {
		 if (decrypt == null) return false;
		 else return decrypt.isMetadataEncrypted();
	 }
	 public byte[] computeUserPassword() {
		 if (!encrypted || !ownerPasswordUsed) return null;
		 return decrypt.computeUserPassword(password);
	 }
}",1,0,0,0
"public final long skip(final long n) throws IOException, IllegalArgumentException {
	 if (n < 0L) {
		 throw new IllegalArgumentException(""skip value is negative"");
	 }
	 for (long i = 0;
	 i < n;
	 i++) {
		 if (read() == -1) {
			 return i;
		 }
	 }
	 return n;
 }",0,0,0,0
"public class UpdateErrors implements Message {
	 private static final long serialVersionUID = 0L;
	 private List<KeyCacheObject> failedKeys;
	 private IgniteCheckedException err;
	 private byte[] errBytes;
	 public UpdateErrors() {
	 }
	 public UpdateErrors(IgniteCheckedException err) {
		 assert err != null;
		 this.err = err;
	 }
	 public void onError(IgniteCheckedException err){
		 this.err = err;
	 }
	 public IgniteCheckedException error() {
		 return err;
	 }
	 public Collection<KeyCacheObject> failedKeys() {
		 return failedKeys;
	 }
	 void addFailedKey(KeyCacheObject key, Throwable e) {
		 if (failedKeys == null) failedKeys = new ArrayList<>();
		 failedKeys.add(key);
		 if (err == null) err = new IgniteCheckedException(""Failed to update keys."");
		 err.addSuppressed(e);
	 }
	 void addFailedKeys(Collection<KeyCacheObject> keys, Throwable e) {
		 if (failedKeys == null) failedKeys = new ArrayList<>(keys.size());
		 failedKeys.addAll(keys);
		 if (err == null) err = new IgniteCheckedException(""Failed to update keys on primary node."");
		 err.addSuppressed(e);
	 }
	 void prepareMarshal(GridCacheMessage msg, GridCacheContext cctx) throws IgniteCheckedException {
		 msg.prepareMarshalCacheObjects(failedKeys, cctx);
		 if (errBytes == null) errBytes = U.marshal(cctx.marshaller(), err);
	 }
	 void finishUnmarshal(GridCacheMessage msg, GridCacheContext cctx, ClassLoader ldr) throws IgniteCheckedException {
		 msg.finishUnmarshalCacheObjects(failedKeys, cctx, ldr);
		 if (errBytes != null && err == null) err = U.unmarshal(cctx.marshaller(), errBytes, U.resolveClassLoader(ldr, cctx.gridConfig()));
	 }
	 public boolean writeTo(ByteBuffer buf, MessageWriter writer) {
		 writer.setBuffer(buf);
		 if (!writer.isHeaderWritten()) {
			 if (!writer.writeHeader(directType(), fieldsCount())) return false;
			 writer.onHeaderWritten();
		 }
		 switch (writer.state()) {
			 case 0: if (!writer.writeByteArray(""errBytes"", errBytes)) return false;
			 writer.incrementState();
			 case 1: if (!writer.writeCollection(""failedKeys"", failedKeys, MessageCollectionItemType.MSG)) return false;
			 writer.incrementState();
		 }
		 return true;
	 }
	 public boolean readFrom(ByteBuffer buf, MessageReader reader) {
		 reader.setBuffer(buf);
		 if (!reader.beforeMessageRead()) return false;
		 switch (reader.state()) {
			 case 0: errBytes = reader.readByteArray(""errBytes"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
			 case 1: failedKeys = reader.readCollection(""failedKeys"", MessageCollectionItemType.MSG);
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
		 }
		 return reader.afterMessageRead(UpdateErrors.class);
	 }
	 public short directType() {
		 return -49;
	 }
	 public byte fieldsCount() {
		 return 2;
	 }
	 public void onAckReceived() {
	 }
	 public String toString() {
		 return S.toString(UpdateErrors.class, this);
	 }
}",1,0,0,0
"public static class setBlobMeta<I extends AsyncIface> extends org.apache.storm.thrift.AsyncProcessFunction<I, setBlobMeta_args, Void> {
	 public setBlobMeta() {
		 super(""setBlobMeta"");
	 }
	 public setBlobMeta_args getEmptyArgsInstance() {
		 return new setBlobMeta_args();
	 }
	 public org.apache.storm.thrift.async.AsyncMethodCallback<Void> getResultHandler(final org.apache.storm.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {
		 final org.apache.storm.thrift.AsyncProcessFunction fcall = this;
		 return new org.apache.storm.thrift.async.AsyncMethodCallback<Void>() {
			 public void onComplete(Void o) {
				 setBlobMeta_result result = new setBlobMeta_result();
				 try {
					 fcall.sendResponse(fb, result, org.apache.storm.thrift.protocol.TMessageType.REPLY,seqid);
				 }
				 catch (org.apache.storm.thrift.transport.TTransportException e) {
					 _LOGGER.error(""TTransportException writing to internal frame buffer"", e);
					 fb.close();
				 }
				 catch (java.lang.Exception e) {
					 _LOGGER.error(""Exception writing to internal frame buffer"", e);
					 onError(e);
				 }
			 }
			 public void onError(java.lang.Exception e) {
				 byte msgType = org.apache.storm.thrift.protocol.TMessageType.REPLY;
				 org.apache.storm.thrift.TSerializable msg;
				 setBlobMeta_result result = new setBlobMeta_result();
				 if (e instanceof AuthorizationException) {
					 result.aze = (AuthorizationException) e;
					 result.set_aze_isSet(true);
					 msg = result;
				 }
				 else if (e instanceof KeyNotFoundException) {
					 result.knf = (KeyNotFoundException) e;
					 result.set_knf_isSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.storm.thrift.transport.TTransportException) {
					 _LOGGER.error(""TTransportException inside handler"", e);
					 fb.close();
					 return;
				 }
				 else if (e instanceof org.apache.storm.thrift.TApplicationException) {
					 _LOGGER.error(""TApplicationException inside handler"", e);
					 msgType = org.apache.storm.thrift.protocol.TMessageType.EXCEPTION;
					 msg = (org.apache.storm.thrift.TApplicationException)e;
				 }
				 else {
					 _LOGGER.error(""Exception inside handler"", e);
					 msgType = org.apache.storm.thrift.protocol.TMessageType.EXCEPTION;
					 msg = new org.apache.storm.thrift.TApplicationException(org.apache.storm.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
				 }
				 try {
					 fcall.sendResponse(fb,msg,msgType,seqid);
				 }
				 catch (java.lang.Exception ex) {
					 _LOGGER.error(""Exception writing to internal frame buffer"", ex);
					 fb.close();
				 }
			 }
		 }
		;
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public void start(I iface, setBlobMeta_args args, org.apache.storm.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.storm.thrift.TException {
		 iface.setBlobMeta(args.key, args.meta,resultHandler);
	 }
 }",1,0,0,0
"public long getMaxRowSize() {
	 long max = 0;
	 for (SSTableReader sstable : getSSTables()) {
		 if (sstable.getEstimatedRowSize().max() > max) max = sstable.getEstimatedRowSize().max();
	 }
	 return max;
 }",0,0,0,0
"public class BC_iflt extends JTTTest {
	 public static int test(int a) {
		 int n = 0;
		 if (a < 0) {
			 n += 1;
		 }
		 else {
			 n -= 1;
		 }
		 if (a >= 0) {
			 n -= 1;
		 }
		 else {
			 n += 1;
		 }
		 return n;
	 }
	 public void run0() throws Throwable {
		 runTest(""test"", 0);
	 }
	 public void run1() throws Throwable {
		 runTest(""test"", 1);
	 }
	 public void run2() throws Throwable {
		 runTest(""test"", -1);
	 }
}",0,0,0,0
"public class MemberOfCommand {
	public static final String ACTION_LIST = ""list"";
	public static final String ACTION_UNLINK_FROM_GROUP = ""unlink"";
	private int pageNumber = 0;
	private String selectedPageSize;
	private String actionCmd = null;
	private Long childOid = null;
	public Long getChildOid() {
		return childOid;
	}
	public void setChildOid(Long childOid) {
		this.childOid = childOid;
	}
	public int getPageNumber() {
		return pageNumber;
	}
	public void setPageNumber(int pageNumber) {
		this.pageNumber = pageNumber;
	}
	public String getSelectedPageSize() {
		return selectedPageSize;
	}
	public void setSelectedPageSize(String selectedPageSize) {
		this.selectedPageSize = selectedPageSize;
	}
	public String getActionCmd() {
		return actionCmd;
	}
	public void setActionCmd(String actionCmd) {
		this.actionCmd = actionCmd;
	}
}",0,1,0,0
"class FSDirectory implements FSConstants {
	 class INode {
		 private String name;
		 private INode parent;
		 private TreeMap children = new TreeMap();
		 private Block blocks[];
		 private short blockReplication;
		 INode(String name, Block blocks[], short replication) {
			 this.name = name;
			 this.parent = null;
			 this.blocks = blocks;
			 this.blockReplication = replication;
		 }
		 INode(String name) {
			 this.name = name;
			 this.parent = null;
			 this.blocks = null;
			 this.blockReplication = 0;
		 }
		 synchronized public boolean isDir() {
			 return (blocks == null);
		 }
		 public short getReplication() {
			 return this.blockReplication;
		 }
		 String getLocalName() {
			 return name;
		 }
		 Block[] getBlocks() {
			 return this.blocks;
		 }
		 INode getParent() {
			 return this.parent;
		 }
		 TreeMap getChildren() {
			 return this.children;
		 }
		 INode getNode(String target) {
			 if ( target == null || ! target.startsWith(""/"") || target.length() == 0) {
				 return null;
			 }
			 else if (parent == null && ""/"".equals(target)) {
				 return this;
			 }
			 else {
				 Vector components = new Vector();
				 int start = 0;
				 int slashid = 0;
				 while (start < target.length() && (slashid = target.indexOf('/', start)) >= 0) {
					 components.add(target.substring(start, slashid));
					 start = slashid + 1;
				 }
				 if (start < target.length()) {
					 components.add(target.substring(start));
				 }
				 return getNode(components, 0);
			 }
		 }
		 INode getNode(Vector components, int index) {
			 if (! name.equals((String) components.elementAt(index))) {
				 return null;
			 }
			 if (index == components.size()-1) {
				 return this;
			 }
			 INode child = this.getChild((String)components.elementAt(index+1));
			 if (child == null) {
				 return null;
			 }
			 else {
				 return child.getNode(components, index+1);
			 }
		 }
		 INode getChild( String name) {
			 return (INode) children.get( name );
		 }
		 INode addNode(String path, INode newNode) throws FileNotFoundException {
			 File target = new File( path );
			 Path parent = new Path(path).getParent();
			 if (parent == null) {
				 return null;
			 }
			 INode parentNode = getNode(parent.toString());
			 if (parentNode == null) {
				 throw new FileNotFoundException( ""Parent path does not exist: ""+path);
			 }
			 if (!parentNode.isDir()) {
				 throw new FileNotFoundException( ""Parent path is not a directory: ""+path);
			 }
			 String name = newNode.name = target.getName();
			 if( parentNode.getChild( name ) != null ) {
				 return null;
			 }
			 parentNode.children.put(name, newNode);
			 newNode.parent = parentNode;
			 return newNode;
		 }
		 boolean removeNode() {
			 if (parent == null) {
				 return false;
			 }
			 else {
				 parent.children.remove(name);
				 return true;
			 }
		 }
		 void collectSubtreeBlocks(Vector v) {
			 if (blocks != null) {
				 for (int i = 0;
				 i < blocks.length;
				 i++) {
					 v.add(blocks[i]);
				 }
			 }
			 Metrics.report(metricsRecord, ""files-deleted"", ++numFilesDeleted);
			 for (Iterator it = children.values().iterator();
			 it.hasNext();
			 ) {
				 INode child = (INode) it.next();
				 child.collectSubtreeBlocks(v);
			 }
		 }
		 int numItemsInTree() {
			 int total = 0;
			 for (Iterator it = children.values().iterator();
			 it.hasNext();
			 ) {
				 INode child = (INode) it.next();
				 total += child.numItemsInTree();
			 }
			 return total + 1;
		 }
		 String computeName() {
			 if (parent != null) {
				 return parent.computeName() + ""/"" + name;
			 }
			 else {
				 return name;
			 }
		 }
		 long computeFileLength() {
			 long total = 0;
			 if (blocks != null) {
				 for (int i = 0;
				 i < blocks.length;
				 i++) {
					 total += blocks[i].getNumBytes();
				 }
			 }
			 return total;
		 }
		 long computeContentsLength() {
			 long total = computeFileLength();
			 for (Iterator it = children.values().iterator();
			 it.hasNext();
			 ) {
				 INode child = (INode) it.next();
				 total += child.computeContentsLength();
			 }
			 return total;
		 }
		 public long getBlockSize() {
			 if (blocks == null || blocks.length == 0) {
				 return 0;
			 }
			 else {
				 return blocks[0].getNumBytes();
			 }
		 }
		 void listContents(Vector v) {
			 if (parent != null && blocks != null) {
				 v.add(this);
			 }
			 for (Iterator it = children.values().iterator();
			 it.hasNext();
			 ) {
				 INode child = (INode) it.next();
				 v.add(child);
			 }
		 }
	 }
	 INode rootDir = new INode("""");
	 Map activeBlocks = new HashMap();
	 TreeMap activeLocks = new TreeMap();
	 FSImage fsImage;
	 boolean ready = false;
	 int namespaceID = 0;
	 private MetricsRecord metricsRecord = null;
	 private int numFilesDeleted = 0;
	 public FSDirectory(File[] dirs) throws IOException {
		 this.fsImage = new FSImage( dirs );
	 }
	 void loadFSImage( Configuration conf ) throws IOException {
		 fsImage.loadFSImage( conf );
		 synchronized (this) {
			 this.ready = true;
			 this.notifyAll();
			 fsImage.getEditLog().create();
		 }
		 metricsRecord = Metrics.createRecord(""dfs"", ""namenode"");
	 }
	 public void close() throws IOException {
		 fsImage.getEditLog().close();
	 }
	 void waitForReady() {
		 if (! ready) {
			 synchronized (this) {
				 while (!ready) {
					 try {
						 this.wait(5000);
					 }
					 catch (InterruptedException ie) {
					 }
				 }
			 }
		 }
	 }
	 public boolean addFile(UTF8 path, Block[] blocks, short replication) {
		 waitForReady();
		 String pathString = path.toString();
		 if( ! mkdirs(new Path(pathString).getParent().toString()) ) {
			 return false;
		 }
		 INode newNode = new INode( new File(pathString).getName(), blocks, replication);
		 if( ! unprotectedAddFile(path, newNode) ) {
			 NameNode.stateChangeLog.info(""DIR* FSDirectory.addFile: "" +""failed to add ""+path+"" with "" +blocks.length+"" blocks to the file system"" );
			 return false;
		 }
		 fsImage.getEditLog().logCreateFile( newNode );
		 NameNode.stateChangeLog.debug(""DIR* FSDirectory.addFile: "" +path+"" with ""+blocks.length+"" blocks is added to the file system"" );
		 return true;
	 }
	 boolean unprotectedAddFile(UTF8 path, INode newNode) {
		 synchronized (rootDir) {
			 try {
				 if( rootDir.addNode(path.toString(), newNode ) != null ) {
					 int nrBlocks = (newNode.blocks == null) ? 0 : newNode.blocks.length;
					 for (int i = 0;
					 i < nrBlocks;
					 i++) activeBlocks.put(newNode.blocks[i], newNode);
					 return true;
				 }
				 else {
					 return false;
				 }
			 }
			 catch (FileNotFoundException e ) {
				 return false;
			 }
		 }
	 }
	 boolean unprotectedAddFile(UTF8 path, Block[] blocks, short replication ) {
		 return unprotectedAddFile( path, new INode( path.toString(), blocks, replication ));
	 }
	 public boolean renameTo(UTF8 src, UTF8 dst) {
		 NameNode.stateChangeLog.debug(""DIR* FSDirectory.renameTo: "" +src+"" to ""+dst );
		 waitForReady();
		 if( ! unprotectedRenameTo(src, dst) ) return false;
		 fsImage.getEditLog().logRename(src, dst);
		 return true;
	 }
	 boolean unprotectedRenameTo(UTF8 src, UTF8 dst) {
		 synchronized(rootDir) {
			 String srcStr = src.toString();
			 String dstStr = dst.toString();
			 INode renamedNode = rootDir.getNode(srcStr);
			 if (renamedNode == null) {
				 NameNode.stateChangeLog.warn(""DIR* FSDirectory.unprotectedRenameTo: "" +""failed to rename ""+src+"" to ""+dst+ "" because source does not exist"" );
				 return false;
			 }
			 if (isDir(dst)) {
				 dstStr += ""/"" + new File(srcStr).getName();
			 }
			 if( rootDir.getNode(dstStr.toString()) != null ) {
				 NameNode.stateChangeLog.warn(""DIR* FSDirectory.unprotectedRenameTo: "" +""failed to rename ""+src+"" to ""+dstStr+ "" because destination exists"" );
				 return false;
			 }
			 renamedNode.removeNode();
			 try {
				 if( rootDir.addNode(dstStr, renamedNode ) != null ) {
					 NameNode.stateChangeLog.debug(""DIR* FSDirectory.unprotectedRenameTo: "" +src+"" is renamed to ""+dst );
					 return true;
				 }
			 }
			 catch (FileNotFoundException e ) {
				 NameNode.stateChangeLog.warn(""DIR* FSDirectory.unprotectedRenameTo: "" +""failed to rename ""+src+"" to ""+dst );
				 try {
					 rootDir.addNode(srcStr, renamedNode);
				 }
				catch(FileNotFoundException e2) {
				 }
			 }
			 return false;
		 }
	 }
	 Block[] setReplication( String src, short replication, Vector oldReplication ) throws IOException {
		 waitForReady();
		 Block[] fileBlocks = unprotectedSetReplication(src, replication, oldReplication );
		 if( fileBlocks != null ) fsImage.getEditLog().logSetReplication( src, replication );
		 return fileBlocks;
	 }
	 Block[] unprotectedSetReplication( String src, short replication, Vector oldReplication ) throws IOException {
		 if( oldReplication == null ) oldReplication = new Vector();
		 oldReplication.setSize(1);
		 oldReplication.set( 0, new Integer(-1) );
		 Block[] fileBlocks = null;
		 synchronized(rootDir) {
			 INode fileNode = rootDir.getNode(src);
			 if (fileNode == null) return null;
			 if( fileNode.isDir() ) return null;
			 oldReplication.set( 0, new Integer( fileNode.blockReplication ));
			 fileNode.blockReplication = replication;
			 fileBlocks = fileNode.blocks;
		 }
		 return fileBlocks;
	 }
	 public long getBlockSize(String filename) throws IOException {
		 synchronized (rootDir) {
			 INode fileNode = rootDir.getNode(filename);
			 if (fileNode == null) {
				 throw new IOException(""Unknown file: "" + filename);
			 }
			 if (fileNode.isDir()) {
				 throw new IOException(""Getting block size of a directory: "" + filename);
			 }
			 return fileNode.getBlockSize();
		 }
	 }
	 public Block[] delete(UTF8 src) {
		 NameNode.stateChangeLog.debug(""DIR* FSDirectory.delete: "" +src );
		 waitForReady();
		 Block[] blocks = unprotectedDelete(src);
		 if( blocks != null ) fsImage.getEditLog().logDelete( src );
		 return blocks;
	 }
	 Block[] unprotectedDelete(UTF8 src) {
		 synchronized (rootDir) {
			 INode targetNode = rootDir.getNode(src.toString());
			 if (targetNode == null) {
				 NameNode.stateChangeLog.warn(""DIR* FSDirectory.unprotectedDelete: "" +""failed to remove ""+src+"" because it does not exist"" );
				 return null;
			 }
			 else {
				 if (! targetNode.removeNode()) {
					 NameNode.stateChangeLog.warn(""DIR* FSDirectory.unprotectedDelete: "" +""failed to remove ""+src+"" because it does not have a parent"" );
					 return null;
				 }
				 else {
					 NameNode.stateChangeLog.debug(""DIR* FSDirectory.unprotectedDelete: "" +src+"" is removed"" );
					 Vector v = new Vector();
					 targetNode.collectSubtreeBlocks(v);
					 for (Iterator it = v.iterator();
					 it.hasNext();
					 ) {
						 Block b = (Block) it.next();
						 activeBlocks.remove(b);
					 }
					 return (Block[]) v.toArray(new Block[v.size()]);
				 }
			 }
		 }
	 }
	 public int obtainLock(UTF8 src, UTF8 holder, boolean exclusive) {
		 TreeSet holders = (TreeSet) activeLocks.get(src);
		 if (holders == null) {
			 holders = new TreeSet();
			 activeLocks.put(src, holders);
		 }
		 if (exclusive && holders.size() > 0) {
			 return STILL_WAITING;
		 }
		 else {
			 holders.add(holder);
			 return COMPLETE_SUCCESS;
		 }
	 }
	 public int releaseLock(UTF8 src, UTF8 holder) {
		 TreeSet holders = (TreeSet) activeLocks.get(src);
		 if (holders != null && holders.contains(holder)) {
			 holders.remove(holder);
			 if (holders.size() == 0) {
				 activeLocks.remove(src);
			 }
			 return COMPLETE_SUCCESS;
		 }
		 else {
			 return OPERATION_FAILED;
		 }
	 }
	 public DFSFileInfo[] getListing(UTF8 src) {
		 String srcs = normalizePath(src);
		 synchronized (rootDir) {
			 INode targetNode = rootDir.getNode(srcs);
			 if (targetNode == null) {
				 return null;
			 }
			 else {
				 Vector contents = new Vector();
				 targetNode.listContents(contents);
				 DFSFileInfo listing[] = new DFSFileInfo[contents.size()];
				 int i = 0;
				 for (Iterator it = contents.iterator();
				 it.hasNext();
				 i++) {
					 listing[i] = new DFSFileInfo( (INode) it.next() );
				 }
				 return listing;
			 }
		 }
	 }
	 public Block[] getFile(UTF8 src) {
		 waitForReady();
		 synchronized (rootDir) {
			 INode targetNode = rootDir.getNode(src.toString());
			 if (targetNode == null) {
				 return null;
			 }
			 else {
				 return targetNode.blocks;
			 }
		 }
	 }
	 public boolean isValidToCreate(UTF8 src) {
		 String srcs = normalizePath(src);
		 synchronized (rootDir) {
			 if (srcs.startsWith(""/"") && ! srcs.endsWith(""/"") && rootDir.getNode(srcs) == null) {
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
	 }
	 public boolean isDir(UTF8 src) {
		 synchronized (rootDir) {
			 INode node = rootDir.getNode(normalizePath(src));
			 return node != null && node.isDir();
		 }
	 }
	 boolean mkdirs(String src) {
		 src = normalizePath(new UTF8(src));
		 Vector v = new Vector();
		 v.add(src);
		 Path parent = new Path(src).getParent();
		 while (parent != null) {
			 v.add(parent.toString());
			 parent = parent.getParent();
		 }
		 int numElts = v.size();
		 for (int i = numElts - 1;
		 i >= 0;
		 i--) {
			 String cur = (String) v.elementAt(i);
			 try {
				 INode inserted = unprotectedMkdir(cur);
				 if (inserted != null) {
					 NameNode.stateChangeLog.debug(""DIR* FSDirectory.mkdirs: "" +""created directory ""+cur );
					 fsImage.getEditLog().logMkDir( inserted );
				 }
				 else {
					 if (!isDir(new UTF8(cur))) {
						 NameNode.stateChangeLog.debug(""DIR* FSDirectory.mkdirs: "" +""path "" + cur + "" is not a directory "");
						 return false;
					 }
				 }
			 }
			 catch (FileNotFoundException e ) {
				 NameNode.stateChangeLog.debug(""DIR* FSDirectory.mkdirs: "" +""failed to create directory ""+src);
				 return false;
			 }
		 }
		 return true;
	 }
	 INode unprotectedMkdir(String src) throws FileNotFoundException {
		 synchronized (rootDir) {
			 return rootDir.addNode(src, new INode(new File(src).getName()));
		 }
	 }
	 String normalizePath(UTF8 src) {
		 String srcs = src.toString();
		 if (srcs.length() > 1 && srcs.endsWith(""/"")) {
			 srcs = srcs.substring(0, srcs.length() - 1);
		 }
		 return srcs;
	 }
	 public boolean isValidBlock(Block b) {
		 synchronized (rootDir) {
			 if (activeBlocks.containsKey(b)) {
				 return true;
			 }
			 else {
				 return false;
			 }
		 }
	 }
	 public INode getFileByBlock(Block b) {
		 synchronized (rootDir) {
			 return (INode)activeBlocks.get(b);
		 }
	 }
}",0,0,0,0
"public class GridH2DmlResponse implements Message, GridCacheQueryMarshallable {
	 private static final long serialVersionUID = 0L;
	 private long reqId;
	 private long updCnt;
	 private String err;
	 private Object[] errKeys;
	 private byte[] errKeysBytes;
	 public GridH2DmlResponse() {
	 }
	 public GridH2DmlResponse(long reqId, long updCnt, Object[] errKeys, String error) {
		 this.reqId = reqId;
		 this.updCnt = updCnt;
		 this.errKeys = errKeys;
		 this.err = error;
	 }
	 public long requestId() {
		 return reqId;
	 }
	 public long updateCounter() {
		 return updCnt;
	 }
	 public Object[] errorKeys() {
		 return errKeys;
	 }
	 public String error() {
		 return err;
	 }
	 public void marshall(Marshaller m) {
		 if (errKeysBytes != null || errKeys == null) return;
		 try {
			 errKeysBytes = U.marshal(m, errKeys);
		 }
		 catch (IgniteCheckedException e) {
			 throw new IgniteException(e);
		 }
	 }
	 public void unmarshall(Marshaller m, GridKernalContext ctx) {
		 if (errKeys != null || errKeysBytes == null) return;
		 try {
			 final ClassLoader ldr = U.resolveClassLoader(ctx.config());
			 if (m instanceof BinaryMarshaller) errKeys = ((BinaryMarshaller)m).binaryMarshaller().unmarshal(errKeysBytes, ldr);
			 else errKeys = U.unmarshal(m, errKeysBytes, ldr);
		 }
		 catch (IgniteCheckedException e) {
			 throw new IgniteException(e);
		 }
	 }
	 public String toString() {
		 return S.toString(GridH2DmlResponse.class, this);
	 }
	 public boolean writeTo(ByteBuffer buf, MessageWriter writer) {
		 writer.setBuffer(buf);
		 if (!writer.isHeaderWritten()) {
			 if (!writer.writeHeader(directType(), fieldsCount())) return false;
			 writer.onHeaderWritten();
		 }
		 switch (writer.state()) {
			 case 0: if (!writer.writeString(""err"", err)) return false;
			 writer.incrementState();
			 case 1: if (!writer.writeByteArray(""errKeysBytes"", errKeysBytes)) return false;
			 writer.incrementState();
			 case 2: if (!writer.writeLong(""reqId"", reqId)) return false;
			 writer.incrementState();
			 case 3: if (!writer.writeLong(""updCnt"", updCnt)) return false;
			 writer.incrementState();
		 }
		 return true;
	 }
	 public boolean readFrom(ByteBuffer buf, MessageReader reader) {
		 reader.setBuffer(buf);
		 if (!reader.beforeMessageRead()) return false;
		 switch (reader.state()) {
			 case 0: err = reader.readString(""err"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
			 case 1: errKeysBytes = reader.readByteArray(""errKeysBytes"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
			 case 2: reqId = reader.readLong(""reqId"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
			 case 3: updCnt = reader.readLong(""updCnt"");
			 if (!reader.isLastRead()) return false;
			 reader.incrementState();
		 }
		 return reader.afterMessageRead(GridH2DmlResponse.class);
	 }
	 public short directType() {
		 return -56;
	 }
	 public byte fieldsCount() {
		 return 4;
	 }
	 public void onAckReceived() {
	 }
}",1,1,0,0
"public static RuleSet parse(final Reader configReader, EventLoggerProvider eventLogger) {
	 RuleSetCreator ruleSetCreator = new RuleSetCreator();
	 int line = 0;
	 try(Reader fileReader = configReader) {
		 LOGGER.debug(""About to load ACL file"");
		 StreamTokenizer tokenizer = new StreamTokenizer(new BufferedReader(fileReader));
		 tokenizer.resetSyntax();
		 tokenizer.commentChar(COMMENT);
		 tokenizer.eolIsSignificant(true);
		 tokenizer.ordinaryChar('=');
		 tokenizer.ordinaryChar(CONTINUATION);
		 tokenizer.quoteChar('""');
		 tokenizer.quoteChar('\'');
		 tokenizer.whitespaceChars('\u0000', '\u0020');
		 tokenizer.wordChars('a', 'z');
		 tokenizer.wordChars('A', 'Z');
		 tokenizer.wordChars('0', '9');
		 tokenizer.wordChars('_', '_');
		 tokenizer.wordChars('-', '-');
		 tokenizer.wordChars('.', '.');
		 tokenizer.wordChars('*', '*');
		 tokenizer.wordChars('@', '@');
		 tokenizer.wordChars(':', ':');
		 Stack<String> stack = new Stack<>();
		 int current;
		 do {
			 current = tokenizer.nextToken();
			 line = tokenizer.lineno()-1;
			 switch (current) {
				 case StreamTokenizer.TT_EOF: case StreamTokenizer.TT_EOL: if (stack.isEmpty()) {
					 break;
				 }
				 String first = stack.firstElement();
				 stack.removeElementAt(0);
				 if (stack.isEmpty()) {
					 throw new IllegalConfigurationException(String.format(NOT_ENOUGH_TOKENS_MSG, line));
				 }
				 Integer number = null;
				 if (first != null && first.matches(""\\d+"")) {
					 number = Integer.valueOf(first);
					 first = stack.firstElement();
					 stack.removeElementAt(0);
				 }
				 if (ACL.equalsIgnoreCase(first)) {
					 parseAcl(number, stack, ruleSetCreator, line);
				 }
				 else if (number == null) {
					 if(""GROUP"".equalsIgnoreCase(first)) {
						 throw new IllegalConfigurationException(String.format(""GROUP keyword not supported at "" + ""line %d. Groups should defined "" + ""via a Group Provider, not in "" + ""the ACL file."", line));
					 }
					 else if (CONFIG.equalsIgnoreCase(first)) {
						 parseConfig(stack, ruleSetCreator, line);
					 }
					 else {
						 throw new IllegalConfigurationException(String.format(UNRECOGNISED_INITIAL_MSG, first, line));
					 }
				 }
				 else {
					 throw new IllegalConfigurationException(String.format(NUMBER_NOT_ALLOWED_MSG, first, line));
				 }
				 stack.clear();
				 break;
				 case StreamTokenizer.TT_NUMBER: stack.push(Integer.toString(Double.valueOf(tokenizer.nval).intValue()));
				 break;
				 case StreamTokenizer.TT_WORD: stack.push(tokenizer.sval);
				 break;
				 default: if (tokenizer.ttype == CONTINUATION) {
					 int next = tokenizer.nextToken();
					 line = tokenizer.lineno()-1;
					 if (next == StreamTokenizer.TT_EOL) {
						 break;
					 }
					 throw new IllegalConfigurationException(String.format(PREMATURE_CONTINUATION_MSG, line + 1));
				 }
				 else if (tokenizer.ttype == '\'' || tokenizer.ttype == '""') {
					 stack.push(tokenizer.sval);
				 }
				 else {
					 stack.push(Character.toString((char) tokenizer.ttype));
				 }
			 }
		 }
		 while (current != StreamTokenizer.TT_EOF);
		 if (!stack.isEmpty()) {
			 throw new IllegalConfigurationException(String.format(PREMATURE_EOF_MSG, line));
		 }
	 }
	 catch (IllegalArgumentException iae) {
		 throw new IllegalConfigurationException(String.format(PARSE_TOKEN_FAILED_MSG, line), iae);
	 }
	 catch (IOException ioe) {
		 throw new IllegalConfigurationException(CANNOT_LOAD_MSG, ioe);
	 }
	 return ruleSetCreator.createRuleSet(eventLogger);
 }",0,0,1,0
"protected void setInternalDateFormat(final DateFormat dateFormat) {
	 this.dateFormat = dateFormat;
 }",0,0,0,0
"final ValueEval evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);",0,0,0,0
"public static final class Signature extends com.google.protobuf.GeneratedMessageV3 implements SignatureOrBuilder {
	 private static final long serialVersionUID = 0L;
	 private Signature(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
		 super(builder);
	 }
	 private Signature() {
		 columns_ = java.util.Collections.emptyList();
		 sql_ = """";
		 parameters_ = java.util.Collections.emptyList();
		 statementType_ = 0;
	 }
	 public final com.google.protobuf.UnknownFieldSet getUnknownFields() {
		 return this.unknownFields;
	 }
	 private Signature( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 this();
		 if (extensionRegistry == null) {
			 throw new java.lang.NullPointerException();
		 }
		 int mutable_bitField0_ = 0;
		 com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder();
		 try {
			 boolean done = false;
			 while (!done) {
				 int tag = input.readTag();
				 switch (tag) {
					 case 0: done = true;
					 break;
					 case 10: {
						 if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
							 columns_ = new java.util.ArrayList<org.apache.calcite.avatica.proto.Common.ColumnMetaData>();
							 mutable_bitField0_ |= 0x00000001;
						 }
						 columns_.add( input.readMessage(org.apache.calcite.avatica.proto.Common.ColumnMetaData.parser(), extensionRegistry));
						 break;
					 }
					 case 18: {
						 java.lang.String s = input.readStringRequireUtf8();
						 sql_ = s;
						 break;
					 }
					 case 26: {
						 if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
							 parameters_ = new java.util.ArrayList<org.apache.calcite.avatica.proto.Common.AvaticaParameter>();
							 mutable_bitField0_ |= 0x00000004;
						 }
						 parameters_.add( input.readMessage(org.apache.calcite.avatica.proto.Common.AvaticaParameter.parser(), extensionRegistry));
						 break;
					 }
					 case 34: {
						 org.apache.calcite.avatica.proto.Common.CursorFactory.Builder subBuilder = null;
						 if (cursorFactory_ != null) {
							 subBuilder = cursorFactory_.toBuilder();
						 }
						 cursorFactory_ = input.readMessage(org.apache.calcite.avatica.proto.Common.CursorFactory.parser(), extensionRegistry);
						 if (subBuilder != null) {
							 subBuilder.mergeFrom(cursorFactory_);
							 cursorFactory_ = subBuilder.buildPartial();
						 }
						 break;
					 }
					 case 40: {
						 int rawValue = input.readEnum();
						 statementType_ = rawValue;
						 break;
					 }
					 default: {
						 if (!parseUnknownFieldProto3( input, unknownFields, extensionRegistry, tag)) {
							 done = true;
						 }
						 break;
					 }
				 }
			 }
		 }
		 catch (com.google.protobuf.InvalidProtocolBufferException e) {
			 throw e.setUnfinishedMessage(this);
		 }
		 catch (java.io.IOException e) {
			 throw new com.google.protobuf.InvalidProtocolBufferException( e).setUnfinishedMessage(this);
		 }
		 finally {
			 if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
				 columns_ = java.util.Collections.unmodifiableList(columns_);
			 }
			 if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
				 parameters_ = java.util.Collections.unmodifiableList(parameters_);
			 }
			 this.unknownFields = unknownFields.build();
			 makeExtensionsImmutable();
		 }
	 }
	 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
		 return org.apache.calcite.avatica.proto.Common.internal_static_Signature_descriptor;
	 }
	 protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
		 return org.apache.calcite.avatica.proto.Common.internal_static_Signature_fieldAccessorTable .ensureFieldAccessorsInitialized( org.apache.calcite.avatica.proto.Common.Signature.class, org.apache.calcite.avatica.proto.Common.Signature.Builder.class);
	 }
	 private int bitField0_;
	 public static final int COLUMNS_FIELD_NUMBER = 1;
	 private java.util.List<org.apache.calcite.avatica.proto.Common.ColumnMetaData> columns_;
	 public java.util.List<org.apache.calcite.avatica.proto.Common.ColumnMetaData> getColumnsList() {
		 return columns_;
	 }
	 public java.util.List<? extends org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder> getColumnsOrBuilderList() {
		 return columns_;
	 }
	 public int getColumnsCount() {
		 return columns_.size();
	 }
	 public org.apache.calcite.avatica.proto.Common.ColumnMetaData getColumns(int index) {
		 return columns_.get(index);
	 }
	 public org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder getColumnsOrBuilder( int index) {
		 return columns_.get(index);
	 }
	 public static final int SQL_FIELD_NUMBER = 2;
	 private volatile java.lang.Object sql_;
	 public java.lang.String getSql() {
		 java.lang.Object ref = sql_;
		 if (ref instanceof java.lang.String) {
			 return (java.lang.String) ref;
		 }
		 else {
			 com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
			 java.lang.String s = bs.toStringUtf8();
			 sql_ = s;
			 return s;
		 }
	 }
	 public com.google.protobuf.ByteString getSqlBytes() {
		 java.lang.Object ref = sql_;
		 if (ref instanceof java.lang.String) {
			 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
			 sql_ = b;
			 return b;
		 }
		 else {
			 return (com.google.protobuf.ByteString) ref;
		 }
	 }
	 public static final int PARAMETERS_FIELD_NUMBER = 3;
	 private java.util.List<org.apache.calcite.avatica.proto.Common.AvaticaParameter> parameters_;
	 public java.util.List<org.apache.calcite.avatica.proto.Common.AvaticaParameter> getParametersList() {
		 return parameters_;
	 }
	 public java.util.List<? extends org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder> getParametersOrBuilderList() {
		 return parameters_;
	 }
	 public int getParametersCount() {
		 return parameters_.size();
	 }
	 public org.apache.calcite.avatica.proto.Common.AvaticaParameter getParameters(int index) {
		 return parameters_.get(index);
	 }
	 public org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder getParametersOrBuilder( int index) {
		 return parameters_.get(index);
	 }
	 public static final int CURSOR_FACTORY_FIELD_NUMBER = 4;
	 private org.apache.calcite.avatica.proto.Common.CursorFactory cursorFactory_;
	 public boolean hasCursorFactory() {
		 return cursorFactory_ != null;
	 }
	 public org.apache.calcite.avatica.proto.Common.CursorFactory getCursorFactory() {
		 return cursorFactory_ == null ? org.apache.calcite.avatica.proto.Common.CursorFactory.getDefaultInstance() : cursorFactory_;
	 }
	 public org.apache.calcite.avatica.proto.Common.CursorFactoryOrBuilder getCursorFactoryOrBuilder() {
		 return getCursorFactory();
	 }
	 public static final int STATEMENTTYPE_FIELD_NUMBER = 5;
	 private int statementType_;
	 public int getStatementTypeValue() {
		 return statementType_;
	 }
	 public org.apache.calcite.avatica.proto.Common.StatementType getStatementType() {
		 org.apache.calcite.avatica.proto.Common.StatementType result = org.apache.calcite.avatica.proto.Common.StatementType.valueOf(statementType_);
		 return result == null ? org.apache.calcite.avatica.proto.Common.StatementType.UNRECOGNIZED : result;
	 }
	 private byte memoizedIsInitialized = -1;
	 public final boolean isInitialized() {
		 byte isInitialized = memoizedIsInitialized;
		 if (isInitialized == 1) return true;
		 if (isInitialized == 0) return false;
		 memoizedIsInitialized = 1;
		 return true;
	 }
	 public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
		 for (int i = 0;
		 i < columns_.size();
		 i++) {
			 output.writeMessage(1, columns_.get(i));
		 }
		 if (!getSqlBytes().isEmpty()) {
			 com.google.protobuf.GeneratedMessageV3.writeString(output, 2, sql_);
		 }
		 for (int i = 0;
		 i < parameters_.size();
		 i++) {
			 output.writeMessage(3, parameters_.get(i));
		 }
		 if (cursorFactory_ != null) {
			 output.writeMessage(4, getCursorFactory());
		 }
		 if (statementType_ != org.apache.calcite.avatica.proto.Common.StatementType.SELECT.getNumber()) {
			 output.writeEnum(5, statementType_);
		 }
		 unknownFields.writeTo(output);
	 }
	 public int getSerializedSize() {
		 int size = memoizedSize;
		 if (size != -1) return size;
		 size = 0;
		 for (int i = 0;
		 i < columns_.size();
		 i++) {
			 size += com.google.protobuf.CodedOutputStream .computeMessageSize(1, columns_.get(i));
		 }
		 if (!getSqlBytes().isEmpty()) {
			 size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, sql_);
		 }
		 for (int i = 0;
		 i < parameters_.size();
		 i++) {
			 size += com.google.protobuf.CodedOutputStream .computeMessageSize(3, parameters_.get(i));
		 }
		 if (cursorFactory_ != null) {
			 size += com.google.protobuf.CodedOutputStream .computeMessageSize(4, getCursorFactory());
		 }
		 if (statementType_ != org.apache.calcite.avatica.proto.Common.StatementType.SELECT.getNumber()) {
			 size += com.google.protobuf.CodedOutputStream .computeEnumSize(5, statementType_);
		 }
		 size += unknownFields.getSerializedSize();
		 memoizedSize = size;
		 return size;
	 }
	 public boolean equals(final java.lang.Object obj) {
		 if (obj == this) {
			 return true;
		 }
		 if (!(obj instanceof org.apache.calcite.avatica.proto.Common.Signature)) {
			 return super.equals(obj);
		 }
		 org.apache.calcite.avatica.proto.Common.Signature other = (org.apache.calcite.avatica.proto.Common.Signature) obj;
		 boolean result = true;
		 result = result && getColumnsList() .equals(other.getColumnsList());
		 result = result && getSql() .equals(other.getSql());
		 result = result && getParametersList() .equals(other.getParametersList());
		 result = result && (hasCursorFactory() == other.hasCursorFactory());
		 if (hasCursorFactory()) {
			 result = result && getCursorFactory() .equals(other.getCursorFactory());
		 }
		 result = result && statementType_ == other.statementType_;
		 result = result && unknownFields.equals(other.unknownFields);
		 return result;
	 }
	 public int hashCode() {
		 if (memoizedHashCode != 0) {
			 return memoizedHashCode;
		 }
		 int hash = 41;
		 hash = (19 * hash) + getDescriptor().hashCode();
		 if (getColumnsCount() > 0) {
			 hash = (37 * hash) + COLUMNS_FIELD_NUMBER;
			 hash = (53 * hash) + getColumnsList().hashCode();
		 }
		 hash = (37 * hash) + SQL_FIELD_NUMBER;
		 hash = (53 * hash) + getSql().hashCode();
		 if (getParametersCount() > 0) {
			 hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
			 hash = (53 * hash) + getParametersList().hashCode();
		 }
		 if (hasCursorFactory()) {
			 hash = (37 * hash) + CURSOR_FACTORY_FIELD_NUMBER;
			 hash = (53 * hash) + getCursorFactory().hashCode();
		 }
		 hash = (37 * hash) + STATEMENTTYPE_FIELD_NUMBER;
		 hash = (53 * hash) + statementType_;
		 hash = (29 * hash) + unknownFields.hashCode();
		 memoizedHashCode = hash;
		 return hash;
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data, extensionRegistry);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data, extensionRegistry);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
		 return PARSER.parseFrom(data, extensionRegistry);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom(java.io.InputStream input) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input, extensionRegistry);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseDelimitedWithIOException(PARSER, input);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseDelimitedFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( com.google.protobuf.CodedInputStream input) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input);
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature parseFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
		 return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input, extensionRegistry);
	 }
	 public Builder newBuilderForType() {
		 return newBuilder();
	 }
	 public static Builder newBuilder() {
		 return DEFAULT_INSTANCE.toBuilder();
	 }
	 public static Builder newBuilder(org.apache.calcite.avatica.proto.Common.Signature prototype) {
		 return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
	 }
	 public Builder toBuilder() {
		 return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);
	 }
	 protected Builder newBuilderForType( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
		 Builder builder = new Builder(parent);
		 return builder;
	 }
	 public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements org.apache.calcite.avatica.proto.Common.SignatureOrBuilder {
		 public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
			 return org.apache.calcite.avatica.proto.Common.internal_static_Signature_descriptor;
		 }
		 protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() {
			 return org.apache.calcite.avatica.proto.Common.internal_static_Signature_fieldAccessorTable .ensureFieldAccessorsInitialized( org.apache.calcite.avatica.proto.Common.Signature.class, org.apache.calcite.avatica.proto.Common.Signature.Builder.class);
		 }
		 private Builder() {
			 maybeForceBuilderInitialization();
		 }
		 private Builder( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
			 super(parent);
			 maybeForceBuilderInitialization();
		 }
		 private void maybeForceBuilderInitialization() {
			 if (com.google.protobuf.GeneratedMessageV3 .alwaysUseFieldBuilders) {
				 getColumnsFieldBuilder();
				 getParametersFieldBuilder();
			 }
		 }
		 public Builder clear() {
			 super.clear();
			 if (columnsBuilder_ == null) {
				 columns_ = java.util.Collections.emptyList();
				 bitField0_ = (bitField0_ & ~0x00000001);
			 }
			 else {
				 columnsBuilder_.clear();
			 }
			 sql_ = """";
			 if (parametersBuilder_ == null) {
				 parameters_ = java.util.Collections.emptyList();
				 bitField0_ = (bitField0_ & ~0x00000004);
			 }
			 else {
				 parametersBuilder_.clear();
			 }
			 if (cursorFactoryBuilder_ == null) {
				 cursorFactory_ = null;
			 }
			 else {
				 cursorFactory_ = null;
				 cursorFactoryBuilder_ = null;
			 }
			 statementType_ = 0;
			 return this;
		 }
		 public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
			 return org.apache.calcite.avatica.proto.Common.internal_static_Signature_descriptor;
		 }
		 public org.apache.calcite.avatica.proto.Common.Signature getDefaultInstanceForType() {
			 return org.apache.calcite.avatica.proto.Common.Signature.getDefaultInstance();
		 }
		 public org.apache.calcite.avatica.proto.Common.Signature build() {
			 org.apache.calcite.avatica.proto.Common.Signature result = buildPartial();
			 if (!result.isInitialized()) {
				 throw newUninitializedMessageException(result);
			 }
			 return result;
		 }
		 public org.apache.calcite.avatica.proto.Common.Signature buildPartial() {
			 org.apache.calcite.avatica.proto.Common.Signature result = new org.apache.calcite.avatica.proto.Common.Signature(this);
			 int from_bitField0_ = bitField0_;
			 int to_bitField0_ = 0;
			 if (columnsBuilder_ == null) {
				 if (((bitField0_ & 0x00000001) == 0x00000001)) {
					 columns_ = java.util.Collections.unmodifiableList(columns_);
					 bitField0_ = (bitField0_ & ~0x00000001);
				 }
				 result.columns_ = columns_;
			 }
			 else {
				 result.columns_ = columnsBuilder_.build();
			 }
			 result.sql_ = sql_;
			 if (parametersBuilder_ == null) {
				 if (((bitField0_ & 0x00000004) == 0x00000004)) {
					 parameters_ = java.util.Collections.unmodifiableList(parameters_);
					 bitField0_ = (bitField0_ & ~0x00000004);
				 }
				 result.parameters_ = parameters_;
			 }
			 else {
				 result.parameters_ = parametersBuilder_.build();
			 }
			 if (cursorFactoryBuilder_ == null) {
				 result.cursorFactory_ = cursorFactory_;
			 }
			 else {
				 result.cursorFactory_ = cursorFactoryBuilder_.build();
			 }
			 result.statementType_ = statementType_;
			 result.bitField0_ = to_bitField0_;
			 onBuilt();
			 return result;
		 }
		 public Builder clone() {
			 return (Builder) super.clone();
		 }
		 public Builder setField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
			 return (Builder) super.setField(field, value);
		 }
		 public Builder clearField( com.google.protobuf.Descriptors.FieldDescriptor field) {
			 return (Builder) super.clearField(field);
		 }
		 public Builder clearOneof( com.google.protobuf.Descriptors.OneofDescriptor oneof) {
			 return (Builder) super.clearOneof(oneof);
		 }
		 public Builder setRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) {
			 return (Builder) super.setRepeatedField(field, index, value);
		 }
		 public Builder addRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) {
			 return (Builder) super.addRepeatedField(field, value);
		 }
		 public Builder mergeFrom(com.google.protobuf.Message other) {
			 if (other instanceof org.apache.calcite.avatica.proto.Common.Signature) {
				 return mergeFrom((org.apache.calcite.avatica.proto.Common.Signature)other);
			 }
			 else {
				 super.mergeFrom(other);
				 return this;
			 }
		 }
		 public Builder mergeFrom(org.apache.calcite.avatica.proto.Common.Signature other) {
			 if (other == org.apache.calcite.avatica.proto.Common.Signature.getDefaultInstance()) return this;
			 if (columnsBuilder_ == null) {
				 if (!other.columns_.isEmpty()) {
					 if (columns_.isEmpty()) {
						 columns_ = other.columns_;
						 bitField0_ = (bitField0_ & ~0x00000001);
					 }
					 else {
						 ensureColumnsIsMutable();
						 columns_.addAll(other.columns_);
					 }
					 onChanged();
				 }
			 }
			 else {
				 if (!other.columns_.isEmpty()) {
					 if (columnsBuilder_.isEmpty()) {
						 columnsBuilder_.dispose();
						 columnsBuilder_ = null;
						 columns_ = other.columns_;
						 bitField0_ = (bitField0_ & ~0x00000001);
						 columnsBuilder_ = com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ? getColumnsFieldBuilder() : null;
					 }
					 else {
						 columnsBuilder_.addAllMessages(other.columns_);
					 }
				 }
			 }
			 if (!other.getSql().isEmpty()) {
				 sql_ = other.sql_;
				 onChanged();
			 }
			 if (parametersBuilder_ == null) {
				 if (!other.parameters_.isEmpty()) {
					 if (parameters_.isEmpty()) {
						 parameters_ = other.parameters_;
						 bitField0_ = (bitField0_ & ~0x00000004);
					 }
					 else {
						 ensureParametersIsMutable();
						 parameters_.addAll(other.parameters_);
					 }
					 onChanged();
				 }
			 }
			 else {
				 if (!other.parameters_.isEmpty()) {
					 if (parametersBuilder_.isEmpty()) {
						 parametersBuilder_.dispose();
						 parametersBuilder_ = null;
						 parameters_ = other.parameters_;
						 bitField0_ = (bitField0_ & ~0x00000004);
						 parametersBuilder_ = com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ? getParametersFieldBuilder() : null;
					 }
					 else {
						 parametersBuilder_.addAllMessages(other.parameters_);
					 }
				 }
			 }
			 if (other.hasCursorFactory()) {
				 mergeCursorFactory(other.getCursorFactory());
			 }
			 if (other.statementType_ != 0) {
				 setStatementTypeValue(other.getStatementTypeValue());
			 }
			 this.mergeUnknownFields(other.unknownFields);
			 onChanged();
			 return this;
		 }
		 public final boolean isInitialized() {
			 return true;
		 }
		 public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
			 org.apache.calcite.avatica.proto.Common.Signature parsedMessage = null;
			 try {
				 parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
			 }
			 catch (com.google.protobuf.InvalidProtocolBufferException e) {
				 parsedMessage = (org.apache.calcite.avatica.proto.Common.Signature) e.getUnfinishedMessage();
				 throw e.unwrapIOException();
			 }
			 finally {
				 if (parsedMessage != null) {
					 mergeFrom(parsedMessage);
				 }
			 }
			 return this;
		 }
		 private int bitField0_;
		 private java.util.List<org.apache.calcite.avatica.proto.Common.ColumnMetaData> columns_ = java.util.Collections.emptyList();
		 private void ensureColumnsIsMutable() {
			 if (!((bitField0_ & 0x00000001) == 0x00000001)) {
				 columns_ = new java.util.ArrayList<org.apache.calcite.avatica.proto.Common.ColumnMetaData>(columns_);
				 bitField0_ |= 0x00000001;
			 }
		 }
		 private com.google.protobuf.RepeatedFieldBuilderV3< org.apache.calcite.avatica.proto.Common.ColumnMetaData, org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder, org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder> columnsBuilder_;
		 public java.util.List<org.apache.calcite.avatica.proto.Common.ColumnMetaData> getColumnsList() {
			 if (columnsBuilder_ == null) {
				 return java.util.Collections.unmodifiableList(columns_);
			 }
			 else {
				 return columnsBuilder_.getMessageList();
			 }
		 }
		 public int getColumnsCount() {
			 if (columnsBuilder_ == null) {
				 return columns_.size();
			 }
			 else {
				 return columnsBuilder_.getCount();
			 }
		 }
		 public org.apache.calcite.avatica.proto.Common.ColumnMetaData getColumns(int index) {
			 if (columnsBuilder_ == null) {
				 return columns_.get(index);
			 }
			 else {
				 return columnsBuilder_.getMessage(index);
			 }
		 }
		 public Builder setColumns( int index, org.apache.calcite.avatica.proto.Common.ColumnMetaData value) {
			 if (columnsBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 ensureColumnsIsMutable();
				 columns_.set(index, value);
				 onChanged();
			 }
			 else {
				 columnsBuilder_.setMessage(index, value);
			 }
			 return this;
		 }
		 public Builder setColumns( int index, org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder builderForValue) {
			 if (columnsBuilder_ == null) {
				 ensureColumnsIsMutable();
				 columns_.set(index, builderForValue.build());
				 onChanged();
			 }
			 else {
				 columnsBuilder_.setMessage(index, builderForValue.build());
			 }
			 return this;
		 }
		 public Builder addColumns(org.apache.calcite.avatica.proto.Common.ColumnMetaData value) {
			 if (columnsBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 ensureColumnsIsMutable();
				 columns_.add(value);
				 onChanged();
			 }
			 else {
				 columnsBuilder_.addMessage(value);
			 }
			 return this;
		 }
		 public Builder addColumns( int index, org.apache.calcite.avatica.proto.Common.ColumnMetaData value) {
			 if (columnsBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 ensureColumnsIsMutable();
				 columns_.add(index, value);
				 onChanged();
			 }
			 else {
				 columnsBuilder_.addMessage(index, value);
			 }
			 return this;
		 }
		 public Builder addColumns( org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder builderForValue) {
			 if (columnsBuilder_ == null) {
				 ensureColumnsIsMutable();
				 columns_.add(builderForValue.build());
				 onChanged();
			 }
			 else {
				 columnsBuilder_.addMessage(builderForValue.build());
			 }
			 return this;
		 }
		 public Builder addColumns( int index, org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder builderForValue) {
			 if (columnsBuilder_ == null) {
				 ensureColumnsIsMutable();
				 columns_.add(index, builderForValue.build());
				 onChanged();
			 }
			 else {
				 columnsBuilder_.addMessage(index, builderForValue.build());
			 }
			 return this;
		 }
		 public Builder addAllColumns( java.lang.Iterable<? extends org.apache.calcite.avatica.proto.Common.ColumnMetaData> values) {
			 if (columnsBuilder_ == null) {
				 ensureColumnsIsMutable();
				 com.google.protobuf.AbstractMessageLite.Builder.addAll( values, columns_);
				 onChanged();
			 }
			 else {
				 columnsBuilder_.addAllMessages(values);
			 }
			 return this;
		 }
		 public Builder clearColumns() {
			 if (columnsBuilder_ == null) {
				 columns_ = java.util.Collections.emptyList();
				 bitField0_ = (bitField0_ & ~0x00000001);
				 onChanged();
			 }
			 else {
				 columnsBuilder_.clear();
			 }
			 return this;
		 }
		 public Builder removeColumns(int index) {
			 if (columnsBuilder_ == null) {
				 ensureColumnsIsMutable();
				 columns_.remove(index);
				 onChanged();
			 }
			 else {
				 columnsBuilder_.remove(index);
			 }
			 return this;
		 }
		 public org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder getColumnsBuilder( int index) {
			 return getColumnsFieldBuilder().getBuilder(index);
		 }
		 public org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder getColumnsOrBuilder( int index) {
			 if (columnsBuilder_ == null) {
				 return columns_.get(index);
			 }
			 else {
				 return columnsBuilder_.getMessageOrBuilder(index);
			 }
		 }
		 public java.util.List<? extends org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder> getColumnsOrBuilderList() {
			 if (columnsBuilder_ != null) {
				 return columnsBuilder_.getMessageOrBuilderList();
			 }
			 else {
				 return java.util.Collections.unmodifiableList(columns_);
			 }
		 }
		 public org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder addColumnsBuilder() {
			 return getColumnsFieldBuilder().addBuilder( org.apache.calcite.avatica.proto.Common.ColumnMetaData.getDefaultInstance());
		 }
		 public org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder addColumnsBuilder( int index) {
			 return getColumnsFieldBuilder().addBuilder( index, org.apache.calcite.avatica.proto.Common.ColumnMetaData.getDefaultInstance());
		 }
		 public java.util.List<org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder> getColumnsBuilderList() {
			 return getColumnsFieldBuilder().getBuilderList();
		 }
		 private com.google.protobuf.RepeatedFieldBuilderV3< org.apache.calcite.avatica.proto.Common.ColumnMetaData, org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder, org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder> getColumnsFieldBuilder() {
			 if (columnsBuilder_ == null) {
				 columnsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3< org.apache.calcite.avatica.proto.Common.ColumnMetaData, org.apache.calcite.avatica.proto.Common.ColumnMetaData.Builder, org.apache.calcite.avatica.proto.Common.ColumnMetaDataOrBuilder>( columns_, ((bitField0_ & 0x00000001) == 0x00000001), getParentForChildren(), isClean());
				 columns_ = null;
			 }
			 return columnsBuilder_;
		 }
		 private java.lang.Object sql_ = """";
		 public java.lang.String getSql() {
			 java.lang.Object ref = sql_;
			 if (!(ref instanceof java.lang.String)) {
				 com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;
				 java.lang.String s = bs.toStringUtf8();
				 sql_ = s;
				 return s;
			 }
			 else {
				 return (java.lang.String) ref;
			 }
		 }
		 public com.google.protobuf.ByteString getSqlBytes() {
			 java.lang.Object ref = sql_;
			 if (ref instanceof String) {
				 com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref);
				 sql_ = b;
				 return b;
			 }
			 else {
				 return (com.google.protobuf.ByteString) ref;
			 }
		 }
		 public Builder setSql( java.lang.String value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 sql_ = value;
			 onChanged();
			 return this;
		 }
		 public Builder clearSql() {
			 sql_ = getDefaultInstance().getSql();
			 onChanged();
			 return this;
		 }
		 public Builder setSqlBytes( com.google.protobuf.ByteString value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 checkByteStringIsUtf8(value);
			 sql_ = value;
			 onChanged();
			 return this;
		 }
		 private java.util.List<org.apache.calcite.avatica.proto.Common.AvaticaParameter> parameters_ = java.util.Collections.emptyList();
		 private void ensureParametersIsMutable() {
			 if (!((bitField0_ & 0x00000004) == 0x00000004)) {
				 parameters_ = new java.util.ArrayList<org.apache.calcite.avatica.proto.Common.AvaticaParameter>(parameters_);
				 bitField0_ |= 0x00000004;
			 }
		 }
		 private com.google.protobuf.RepeatedFieldBuilderV3< org.apache.calcite.avatica.proto.Common.AvaticaParameter, org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder, org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder> parametersBuilder_;
		 public java.util.List<org.apache.calcite.avatica.proto.Common.AvaticaParameter> getParametersList() {
			 if (parametersBuilder_ == null) {
				 return java.util.Collections.unmodifiableList(parameters_);
			 }
			 else {
				 return parametersBuilder_.getMessageList();
			 }
		 }
		 public int getParametersCount() {
			 if (parametersBuilder_ == null) {
				 return parameters_.size();
			 }
			 else {
				 return parametersBuilder_.getCount();
			 }
		 }
		 public org.apache.calcite.avatica.proto.Common.AvaticaParameter getParameters(int index) {
			 if (parametersBuilder_ == null) {
				 return parameters_.get(index);
			 }
			 else {
				 return parametersBuilder_.getMessage(index);
			 }
		 }
		 public Builder setParameters( int index, org.apache.calcite.avatica.proto.Common.AvaticaParameter value) {
			 if (parametersBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 ensureParametersIsMutable();
				 parameters_.set(index, value);
				 onChanged();
			 }
			 else {
				 parametersBuilder_.setMessage(index, value);
			 }
			 return this;
		 }
		 public Builder setParameters( int index, org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder builderForValue) {
			 if (parametersBuilder_ == null) {
				 ensureParametersIsMutable();
				 parameters_.set(index, builderForValue.build());
				 onChanged();
			 }
			 else {
				 parametersBuilder_.setMessage(index, builderForValue.build());
			 }
			 return this;
		 }
		 public Builder addParameters(org.apache.calcite.avatica.proto.Common.AvaticaParameter value) {
			 if (parametersBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 ensureParametersIsMutable();
				 parameters_.add(value);
				 onChanged();
			 }
			 else {
				 parametersBuilder_.addMessage(value);
			 }
			 return this;
		 }
		 public Builder addParameters( int index, org.apache.calcite.avatica.proto.Common.AvaticaParameter value) {
			 if (parametersBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 ensureParametersIsMutable();
				 parameters_.add(index, value);
				 onChanged();
			 }
			 else {
				 parametersBuilder_.addMessage(index, value);
			 }
			 return this;
		 }
		 public Builder addParameters( org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder builderForValue) {
			 if (parametersBuilder_ == null) {
				 ensureParametersIsMutable();
				 parameters_.add(builderForValue.build());
				 onChanged();
			 }
			 else {
				 parametersBuilder_.addMessage(builderForValue.build());
			 }
			 return this;
		 }
		 public Builder addParameters( int index, org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder builderForValue) {
			 if (parametersBuilder_ == null) {
				 ensureParametersIsMutable();
				 parameters_.add(index, builderForValue.build());
				 onChanged();
			 }
			 else {
				 parametersBuilder_.addMessage(index, builderForValue.build());
			 }
			 return this;
		 }
		 public Builder addAllParameters( java.lang.Iterable<? extends org.apache.calcite.avatica.proto.Common.AvaticaParameter> values) {
			 if (parametersBuilder_ == null) {
				 ensureParametersIsMutable();
				 com.google.protobuf.AbstractMessageLite.Builder.addAll( values, parameters_);
				 onChanged();
			 }
			 else {
				 parametersBuilder_.addAllMessages(values);
			 }
			 return this;
		 }
		 public Builder clearParameters() {
			 if (parametersBuilder_ == null) {
				 parameters_ = java.util.Collections.emptyList();
				 bitField0_ = (bitField0_ & ~0x00000004);
				 onChanged();
			 }
			 else {
				 parametersBuilder_.clear();
			 }
			 return this;
		 }
		 public Builder removeParameters(int index) {
			 if (parametersBuilder_ == null) {
				 ensureParametersIsMutable();
				 parameters_.remove(index);
				 onChanged();
			 }
			 else {
				 parametersBuilder_.remove(index);
			 }
			 return this;
		 }
		 public org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder getParametersBuilder( int index) {
			 return getParametersFieldBuilder().getBuilder(index);
		 }
		 public org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder getParametersOrBuilder( int index) {
			 if (parametersBuilder_ == null) {
				 return parameters_.get(index);
			 }
			 else {
				 return parametersBuilder_.getMessageOrBuilder(index);
			 }
		 }
		 public java.util.List<? extends org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder> getParametersOrBuilderList() {
			 if (parametersBuilder_ != null) {
				 return parametersBuilder_.getMessageOrBuilderList();
			 }
			 else {
				 return java.util.Collections.unmodifiableList(parameters_);
			 }
		 }
		 public org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder addParametersBuilder() {
			 return getParametersFieldBuilder().addBuilder( org.apache.calcite.avatica.proto.Common.AvaticaParameter.getDefaultInstance());
		 }
		 public org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder addParametersBuilder( int index) {
			 return getParametersFieldBuilder().addBuilder( index, org.apache.calcite.avatica.proto.Common.AvaticaParameter.getDefaultInstance());
		 }
		 public java.util.List<org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder> getParametersBuilderList() {
			 return getParametersFieldBuilder().getBuilderList();
		 }
		 private com.google.protobuf.RepeatedFieldBuilderV3< org.apache.calcite.avatica.proto.Common.AvaticaParameter, org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder, org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder> getParametersFieldBuilder() {
			 if (parametersBuilder_ == null) {
				 parametersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3< org.apache.calcite.avatica.proto.Common.AvaticaParameter, org.apache.calcite.avatica.proto.Common.AvaticaParameter.Builder, org.apache.calcite.avatica.proto.Common.AvaticaParameterOrBuilder>( parameters_, ((bitField0_ & 0x00000004) == 0x00000004), getParentForChildren(), isClean());
				 parameters_ = null;
			 }
			 return parametersBuilder_;
		 }
		 private org.apache.calcite.avatica.proto.Common.CursorFactory cursorFactory_ = null;
		 private com.google.protobuf.SingleFieldBuilderV3< org.apache.calcite.avatica.proto.Common.CursorFactory, org.apache.calcite.avatica.proto.Common.CursorFactory.Builder, org.apache.calcite.avatica.proto.Common.CursorFactoryOrBuilder> cursorFactoryBuilder_;
		 public boolean hasCursorFactory() {
			 return cursorFactoryBuilder_ != null || cursorFactory_ != null;
		 }
		 public org.apache.calcite.avatica.proto.Common.CursorFactory getCursorFactory() {
			 if (cursorFactoryBuilder_ == null) {
				 return cursorFactory_ == null ? org.apache.calcite.avatica.proto.Common.CursorFactory.getDefaultInstance() : cursorFactory_;
			 }
			 else {
				 return cursorFactoryBuilder_.getMessage();
			 }
		 }
		 public Builder setCursorFactory(org.apache.calcite.avatica.proto.Common.CursorFactory value) {
			 if (cursorFactoryBuilder_ == null) {
				 if (value == null) {
					 throw new NullPointerException();
				 }
				 cursorFactory_ = value;
				 onChanged();
			 }
			 else {
				 cursorFactoryBuilder_.setMessage(value);
			 }
			 return this;
		 }
		 public Builder setCursorFactory( org.apache.calcite.avatica.proto.Common.CursorFactory.Builder builderForValue) {
			 if (cursorFactoryBuilder_ == null) {
				 cursorFactory_ = builderForValue.build();
				 onChanged();
			 }
			 else {
				 cursorFactoryBuilder_.setMessage(builderForValue.build());
			 }
			 return this;
		 }
		 public Builder mergeCursorFactory(org.apache.calcite.avatica.proto.Common.CursorFactory value) {
			 if (cursorFactoryBuilder_ == null) {
				 if (cursorFactory_ != null) {
					 cursorFactory_ = org.apache.calcite.avatica.proto.Common.CursorFactory.newBuilder(cursorFactory_).mergeFrom(value).buildPartial();
				 }
				 else {
					 cursorFactory_ = value;
				 }
				 onChanged();
			 }
			 else {
				 cursorFactoryBuilder_.mergeFrom(value);
			 }
			 return this;
		 }
		 public Builder clearCursorFactory() {
			 if (cursorFactoryBuilder_ == null) {
				 cursorFactory_ = null;
				 onChanged();
			 }
			 else {
				 cursorFactory_ = null;
				 cursorFactoryBuilder_ = null;
			 }
			 return this;
		 }
		 public org.apache.calcite.avatica.proto.Common.CursorFactory.Builder getCursorFactoryBuilder() {
			 onChanged();
			 return getCursorFactoryFieldBuilder().getBuilder();
		 }
		 public org.apache.calcite.avatica.proto.Common.CursorFactoryOrBuilder getCursorFactoryOrBuilder() {
			 if (cursorFactoryBuilder_ != null) {
				 return cursorFactoryBuilder_.getMessageOrBuilder();
			 }
			 else {
				 return cursorFactory_ == null ? org.apache.calcite.avatica.proto.Common.CursorFactory.getDefaultInstance() : cursorFactory_;
			 }
		 }
		 private com.google.protobuf.SingleFieldBuilderV3< org.apache.calcite.avatica.proto.Common.CursorFactory, org.apache.calcite.avatica.proto.Common.CursorFactory.Builder, org.apache.calcite.avatica.proto.Common.CursorFactoryOrBuilder> getCursorFactoryFieldBuilder() {
			 if (cursorFactoryBuilder_ == null) {
				 cursorFactoryBuilder_ = new com.google.protobuf.SingleFieldBuilderV3< org.apache.calcite.avatica.proto.Common.CursorFactory, org.apache.calcite.avatica.proto.Common.CursorFactory.Builder, org.apache.calcite.avatica.proto.Common.CursorFactoryOrBuilder>( getCursorFactory(), getParentForChildren(), isClean());
				 cursorFactory_ = null;
			 }
			 return cursorFactoryBuilder_;
		 }
		 private int statementType_ = 0;
		 public int getStatementTypeValue() {
			 return statementType_;
		 }
		 public Builder setStatementTypeValue(int value) {
			 statementType_ = value;
			 onChanged();
			 return this;
		 }
		 public org.apache.calcite.avatica.proto.Common.StatementType getStatementType() {
			 org.apache.calcite.avatica.proto.Common.StatementType result = org.apache.calcite.avatica.proto.Common.StatementType.valueOf(statementType_);
			 return result == null ? org.apache.calcite.avatica.proto.Common.StatementType.UNRECOGNIZED : result;
		 }
		 public Builder setStatementType(org.apache.calcite.avatica.proto.Common.StatementType value) {
			 if (value == null) {
				 throw new NullPointerException();
			 }
			 statementType_ = value.getNumber();
			 onChanged();
			 return this;
		 }
		 public Builder clearStatementType() {
			 statementType_ = 0;
			 onChanged();
			 return this;
		 }
		 public final Builder setUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) {
			 return super.setUnknownFieldsProto3(unknownFields);
		 }
		 public final Builder mergeUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) {
			 return super.mergeUnknownFields(unknownFields);
		 }
	 }
	 private static final org.apache.calcite.avatica.proto.Common.Signature DEFAULT_INSTANCE;
	 static {
		 DEFAULT_INSTANCE = new org.apache.calcite.avatica.proto.Common.Signature();
	 }
	 public static org.apache.calcite.avatica.proto.Common.Signature getDefaultInstance() {
		 return DEFAULT_INSTANCE;
	 }
	 private static final com.google.protobuf.Parser<Signature> PARSER = new com.google.protobuf.AbstractParser<Signature>() {
		 public Signature parsePartialFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException {
			 return new Signature(input, extensionRegistry);
		 }
	 }
	;
	 public static com.google.protobuf.Parser<Signature> parser() {
		 return PARSER;
	 }
	 public com.google.protobuf.Parser<Signature> getParserForType() {
		 return PARSER;
	 }
	 public org.apache.calcite.avatica.proto.Common.Signature getDefaultInstanceForType() {
		 return DEFAULT_INSTANCE;
	 }
 }",0,0,0,0
"public class CharacterRange {
	 private int column;
	 private int line;
	 private char right;
	 private char left;
	 CharacterRange() {
	 }
	 CharacterRange(char l, char r) {
		 if (l > r) JavaCCErrors.semantic_error(this, ""Invalid range : \"""" + (int)l + ""\"" - \"""" + (int)r + ""\"". First character shoud be less than or equal to the second one in a range."");
		 setLeft(l);
		 setRight(r);
	 }
	 void setLine(int line) {
		 this.line = line;
	 }
	 int getLine() {
		 return line;
	 }
	 void setColumn(int column) {
		 this.column = column;
	 }
	 int getColumn() {
		 return column;
	 }
	 public void setLeft(char left) {
		 this.left = left;
	 }
	 public char getLeft() {
		 return left;
	 }
	 public void setRight(char right) {
		 this.right = right;
	 }
	 public char getRight() {
		 return right;
	 }
}",0,1,0,0
"public class InteractionsEditorKit extends StyledEditorKit {
	 public InteractionsEditorKit() {
	 }
	 private static ViewFactory _factory = new ViewFactory() {
		 public View create(Element elem) {
			 String kind = elem.getName();
			 if (kind != null) {
				 if (kind.equals(AbstractDocument.ContentElementName)) {
					 return _createColoringView(elem);
				 }
				 else if (kind.equals(AbstractDocument.ParagraphElementName)) {
					 return new ParagraphView(elem);
				 }
				 else if (kind.equals(AbstractDocument.SectionElementName)) {
					 return new BoxView(elem, View.Y_AXIS);
				 }
				 else if (kind.equals(StyleConstants.ComponentElementName)) {
					 return new ComponentView(elem);
				 }
				 else if (kind.equals(StyleConstants.IconElementName)) {
					 return new IconView(elem);
				 }
			 }
			 return _createColoringView(elem);
		 }
	 }
	;
	 public String getContentType() {
		 return ""text/java"";
	 }
	 public final ViewFactory getViewFactory() {
		 return _factory;
	 }
	 public InteractionsDJDocument createDefaultDocument() {
		 return new InteractionsDJDocument();
	 }
	 private static GlyphView _createColoringView(Element elem) {
		 final GlyphView view = new GlyphView(elem);
		 view.setGlyphPainter(new ColoringGlyphPainter(new Runnable() {
			 public void run() {
				 if (view.getContainer() != null) view.getContainer().repaint();
			 }
		 }
		));
		 return view;
	 }
}",0,0,0,0
"public final class CoderHelpers {
	 private CoderHelpers() {
	}
	 public static <T> byte[] toByteArray(T value, Coder<T> coder) {
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 try {
			 coder.encode(value, baos, new Coder.Context(true));
		 }
		 catch (IOException e) {
			 throw new IllegalStateException(""Error encoding value: "" + value, e);
		 }
		 return baos.toByteArray();
	 }
	 public static <T> List<byte[]> toByteArrays(Iterable<T> values, Coder<T> coder) {
		 List<byte[]> res = new ArrayList<>();
		 for (T value : values) {
			 res.add(toByteArray(value, coder));
		 }
		 return res;
	 }
	 public static <T> T fromByteArray(byte[] serialized, Coder<T> coder) {
		 ByteArrayInputStream bais = new ByteArrayInputStream(serialized);
		 try {
			 return coder.decode(bais, new Coder.Context(true));
		 }
		 catch (IOException e) {
			 throw new IllegalStateException(""Error decoding bytes for coder: "" + coder, e);
		 }
	 }
	 public static <T> Iterable<T> fromByteArrays( Collection<byte[]> serialized, final Coder<T> coder) {
		 return serialized.stream() .map(bytes -> fromByteArray(checkNotNull(bytes, ""Cannot decode null values.""), coder)) .collect(Collectors.toList());
	 }
	 public static <T> Function<T, byte[]> toByteFunction(final Coder<T> coder) {
		 return t -> toByteArray(t, coder);
	 }
	 public static <T> Function<byte[], T> fromByteFunction(final Coder<T> coder) {
		 return bytes -> fromByteArray(bytes, coder);
	 }
	 public static <K, V> PairFunction<Tuple2<K, V>, ByteArray, byte[]> toByteFunction( final Coder<K> keyCoder, final Coder<V> valueCoder) {
		 return kv -> new Tuple2<>( new ByteArray(toByteArray(kv._1(), keyCoder)), toByteArray(kv._2(), valueCoder));
	 }
	 public static <K, V> PairFunction<Tuple2<ByteArray, byte[]>, K, V> fromByteFunction( final Coder<K> keyCoder, final Coder<V> valueCoder) {
		 return tuple -> new Tuple2<>( fromByteArray(tuple._1().getValue(), keyCoder), fromByteArray(tuple._2(), valueCoder));
	 }
	 public static <K, V> PairFunction<Tuple2<ByteArray, Iterable<byte[]>>, K, Iterable<V>> fromByteFunctionIterable( final Coder<K> keyCoder, final Coder<V> valueCoder) {
		 return tuple -> new Tuple2<>( fromByteArray(tuple._1().getValue(), keyCoder), StreamSupport.stream(tuple._2().spliterator(), false) .map(bytes -> fromByteArray(bytes, valueCoder)) .collect(Collectors.toList()));
	 }
}",0,0,0,0
"public class LimitInputStream extends FilterInputStream implements Limit {
	protected int remainingBytes;
	protected boolean limitInPlace;
	public LimitInputStream(InputStream in) {
		super(in);
		clearLimit();
	}
	public int read() throws IOException {
		if (!limitInPlace)return super.read();
		if (remainingBytes == 0)return -1;
		 int value = super.read();
		if (value >= 0)remainingBytes--;
		return value;
	}
	public int read(byte b[], int off, int len) throws IOException {
		if (!limitInPlace)return super.read(b, off, len);
		if (remainingBytes == 0)return -1;
		if (remainingBytes < len) {
			len = remainingBytes;
		 }
		len = super.read(b, off, len);
		if (len > 0)remainingBytes -= len;
		return len;
	}
	public long skip(long count) throws IOException {
		if (!limitInPlace)return super.skip(count);
		if (remainingBytes == 0)return 0;
		 if (remainingBytes < count)count = remainingBytes;
		count = super.skip(count);
		remainingBytes -= count;
		return count;
	}
	public int available() throws IOException {
		if (!limitInPlace)return super.available();
		if (remainingBytes == 0)return 0;
		 int actualLeft = super.available();
		if (remainingBytes < actualLeft)return remainingBytes;
		return actualLeft;
	}
	public void setLimit(int length) {
		remainingBytes = length;
		limitInPlace = true;
	}
	public int clearLimit() {
		int leftOver = remainingBytes;
		limitInPlace = false;
		remainingBytes = -1;
		return leftOver;
	}
	public void setInput(InputStream in) {
		this.in = in;
	}
	 public boolean markSupported() {
		 return false;
	 }
}",0,0,0,0
"public class MacroDef extends AntlibDefinition {
	 private NestedSequential nestedSequential;
	 private String name;
	 private boolean backTrace = true;
	 private List attributes = new ArrayList();
	 private Map elements = new HashMap();
	 private String textName = null;
	 private Text text = null;
	 private boolean hasImplicitElement = false;
	 public void setName(String name) {
		 this.name = name;
	 }
	 public void addConfiguredText(Text text) {
		 if (this.text != null) {
			 throw new BuildException( ""Only one nested text element allowed"");
		 }
		 if (text.getName() == null) {
			 throw new BuildException( ""the text nested element needed a \""name\"" attribute"");
		 }
		 for (Iterator i = attributes.iterator();
		 i.hasNext();
		) {
			 Attribute attribute = (Attribute) i.next();
			 if (text.getName().equals(attribute.getName())) {
				 throw new BuildException( ""the name \"""" + text.getName() + ""\"" is already used as an attribute"");
			 }
		 }
		 this.text = text;
		 this.textName = text.getName();
	 }
	 public Text getText() {
		 return text;
	 }
	 public void setBackTrace(boolean backTrace) {
		 this.backTrace = backTrace;
	 }
	 public boolean getBackTrace() {
		 return backTrace;
	 }
	 public NestedSequential createSequential() {
		 if (this.nestedSequential != null) {
			 throw new BuildException(""Only one sequential allowed"");
		 }
		 this.nestedSequential = new NestedSequential();
		 return this.nestedSequential;
	 }
	 public static class NestedSequential implements TaskContainer {
		 private List nested = new ArrayList();
		 public void addTask(Task task) {
			 nested.add(task);
		 }
		 public List getNested() {
			 return nested;
		 }
		 public boolean similar(NestedSequential other) {
			 final int size = nested.size();
			 if (size != other.nested.size()) {
				 return false;
			 }
			 for (int i = 0;
			 i < size;
			 ++i) {
				 UnknownElement me = (UnknownElement) nested.get(i);
				 UnknownElement o = (UnknownElement) other.nested.get(i);
				 if (!me.similar(o)) {
					 return false;
				 }
			 }
			 return true;
		 }
	 }
	 public UnknownElement getNestedTask() {
		 UnknownElement ret = new UnknownElement(""sequential"");
		 ret.setTaskName(""sequential"");
		 ret.setNamespace("""");
		 ret.setQName(""sequential"");
		 new RuntimeConfigurable(ret, ""sequential"");
		 final int size = nestedSequential.getNested().size();
		 for (int i = 0;
		 i < size;
		 ++i) {
			 UnknownElement e = (UnknownElement) nestedSequential.getNested().get(i);
			 ret.addChild(e);
			 ret.getWrapper().addChild(e.getWrapper());
		 }
		 return ret;
	 }
	 public List getAttributes() {
		 return attributes;
	 }
	 public Map getElements() {
		 return elements;
	 }
	 public static boolean isValidNameCharacter(char c) {
		 return Character.isLetterOrDigit(c) || c == '.' || c == '-';
	 }
	 private static boolean isValidName(String name) {
		 if (name.length() == 0) {
			 return false;
		 }
		 for (int i = 0;
		 i < name.length();
		 ++i) {
			 if (!isValidNameCharacter(name.charAt(i))) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public void addConfiguredAttribute(Attribute attribute) {
		 if (attribute.getName() == null) {
			 throw new BuildException( ""the attribute nested element needed a \""name\"" attribute"");
		 }
		 if (attribute.getName().equals(textName)) {
			 throw new BuildException( ""the name \"""" + attribute.getName() + ""\"" has already been used by the text element"");
		 }
		 final int size = attributes.size();
		 for (int i = 0;
		 i < size;
		 ++i) {
			 Attribute att = (Attribute) attributes.get(i);
			 if (att.getName().equals(attribute.getName())) {
				 throw new BuildException( ""the name \"""" + attribute.getName() + ""\"" has already been used in "" + ""another attribute element"");
			 }
		 }
		 attributes.add(attribute);
	 }
	 public void addConfiguredElement(TemplateElement element) {
		 if (element.getName() == null) {
			 throw new BuildException( ""the element nested element needed a \""name\"" attribute"");
		 }
		 if (elements.get(element.getName()) != null) {
			 throw new BuildException( ""the element "" + element.getName() + "" has already been specified"");
		 }
		 if (hasImplicitElement || (element.isImplicit() && elements.size() != 0)) {
			 throw new BuildException( ""Only one element allowed when using implicit elements"");
		 }
		 hasImplicitElement = element.isImplicit();
		 elements.put(element.getName(), element);
	 }
	 public void execute() {
		 if (nestedSequential == null) {
			 throw new BuildException(""Missing sequential element"");
		 }
		 if (name == null) {
			 throw new BuildException(""Name not specified"");
		 }
		 name = ProjectHelper.genComponentName(getURI(), name);
		 MyAntTypeDefinition def = new MyAntTypeDefinition(this);
		 def.setName(name);
		 def.setClass(MacroInstance.class);
		 ComponentHelper helper = ComponentHelper.getComponentHelper( getProject());
		 helper.addDataTypeDefinition(def);
		 log(""creating macro "" + name, Project.MSG_VERBOSE);
	 }
	 public static class Attribute {
		 private String name;
		 private String defaultValue;
		 private String description;
		 private boolean doubleExpanding = true;
		 public void setName(String name) {
			 if (!isValidName(name)) {
				 throw new BuildException( ""Illegal name ["" + name + ""] for attribute"");
			 }
			 this.name = name.toLowerCase(Locale.ENGLISH);
		 }
		 public String getName() {
			 return name;
		 }
		 public void setDefault(String defaultValue) {
			 this.defaultValue = defaultValue;
		 }
		 public String getDefault() {
			 return defaultValue;
		 }
		 public void setDescription(String desc) {
			 description = desc;
		 }
		 public String getDescription() {
			 return description;
		 }
		 public void setDoubleExpanding(boolean doubleExpanding) {
			 this.doubleExpanding = doubleExpanding;
		 }
		 public boolean isDoubleExpanding() {
			 return doubleExpanding;
		 }
		 public boolean equals(Object obj) {
			 if (obj == null) {
				 return false;
			 }
			 if (obj.getClass() != getClass()) {
				 return false;
			 }
			 Attribute other = (Attribute) obj;
			 if (name == null) {
				 if (other.name != null) {
					 return false;
				 }
			 }
			 else if (!name.equals(other.name)) {
				 return false;
			 }
			 if (defaultValue == null) {
				 if (other.defaultValue != null) {
					 return false;
				 }
			 }
			 else if (!defaultValue.equals(other.defaultValue)) {
				 return false;
			 }
			 return true;
		 }
		 public int hashCode() {
			 return objectHashCode(defaultValue) + objectHashCode(name);
		 }
	 }
	 public static class Text {
		 private String name;
		 private boolean optional;
		 private boolean trim;
		 private String description;
		 private String defaultString;
		 public void setName(String name) {
			 if (!isValidName(name)) {
				 throw new BuildException( ""Illegal name ["" + name + ""] for attribute"");
			 }
			 this.name = name.toLowerCase(Locale.ENGLISH);
		 }
		 public String getName() {
			 return name;
		 }
		 public void setOptional(boolean optional) {
			 this.optional = optional;
		 }
		 public boolean getOptional() {
			 return optional;
		 }
		 public void setTrim(boolean trim) {
			 this.trim = trim;
		 }
		 public boolean getTrim() {
			 return trim;
		 }
		 public void setDescription(String desc) {
			 description = desc;
		 }
		 public String getDescription() {
			 return description;
		 }
		 public void setDefault(String defaultString) {
			 this.defaultString = defaultString;
		 }
		 public String getDefault() {
			 return defaultString;
		 }
		 public boolean equals(Object obj) {
			 if (obj == null) {
				 return false;
			 }
			 if (obj.getClass() != getClass()) {
				 return false;
			 }
			 Text other = (Text) obj;
			 return safeCompare(name, other.name) && optional == other.optional && trim == other.trim && safeCompare(defaultString, other.defaultString);
		 }
		 public int hashCode() {
			 return objectHashCode(name);
		 }
	 }
	 private static boolean safeCompare(Object a, Object b) {
		 return a == null ? b == null : a.equals(b);
	 }
	 public static class TemplateElement {
		 private String name;
		 private String description;
		 private boolean optional = false;
		 private boolean implicit = false;
		 public void setName(String name) {
			 if (!isValidName(name)) {
				 throw new BuildException( ""Illegal name ["" + name + ""] for macro element"");
			 }
			 this.name = name.toLowerCase(Locale.ENGLISH);
		 }
		 public String getName() {
			 return name;
		 }
		 public void setDescription(String desc) {
			 description = desc;
		 }
		 public String getDescription() {
			 return description;
		 }
		 public void setOptional(boolean optional) {
			 this.optional = optional;
		 }
		 public boolean isOptional() {
			 return optional;
		 }
		 public void setImplicit(boolean implicit) {
			 this.implicit = implicit;
		 }
		 public boolean isImplicit() {
			 return implicit;
		 }
		 public boolean equals(Object obj) {
			 if (obj == this) {
				 return true;
			 }
			 if (obj == null || !obj.getClass().equals(getClass())) {
				 return false;
			 }
			 TemplateElement t = (TemplateElement) obj;
			 return (name == null ? t.name == null : name.equals(t.name)) && optional == t.optional && implicit == t.implicit;
		 }
		 public int hashCode() {
			 return objectHashCode(name) + (optional ? 1 : 0) + (implicit ? 1 : 0);
		 }
	 }
	 private boolean sameOrSimilar(Object obj, boolean same) {
		 if (obj == this) {
			 return true;
		 }
		 if (obj == null) {
			 return false;
		 }
		 if (!obj.getClass().equals(getClass())) {
			 return false;
		 }
		 MacroDef other = (MacroDef) obj;
		 if (name == null) {
			 return other.name == null;
		 }
		 if (!name.equals(other.name)) {
			 return false;
		 }
		 if (other.getLocation() != null && other.getLocation().equals(getLocation()) && !same) {
			 return true;
		 }
		 if (text == null) {
			 if (other.text != null) {
				 return false;
			 }
		 }
		 else {
			 if (!text.equals(other.text)) {
				 return false;
			 }
		 }
		 if (getURI() == null || getURI().equals("""") || getURI().equals(ProjectHelper.ANT_CORE_URI)) {
			 if (!(other.getURI() == null || other.getURI().equals("""") || other.getURI().equals(ProjectHelper.ANT_CORE_URI))) {
				 return false;
			 }
		 }
		 else {
			 if (!getURI().equals(other.getURI())) {
				 return false;
			 }
		 }
		 if (!nestedSequential.similar(other.nestedSequential)) {
			 return false;
		 }
		 if (!attributes.equals(other.attributes)) {
			 return false;
		 }
		 if (!elements.equals(other.elements)) {
			 return false;
		 }
		 return true;
	 }
	 public boolean similar(Object obj) {
		 return sameOrSimilar(obj, false);
	 }
	 public boolean sameDefinition(Object obj) {
		 return sameOrSimilar(obj, true);
	 }
	 private static class MyAntTypeDefinition extends AntTypeDefinition {
		 private MacroDef macroDef;
		 public MyAntTypeDefinition(MacroDef macroDef) {
			 this.macroDef = macroDef;
		 }
		 public Object create(Project project) {
			 Object o = super.create(project);
			 if (o == null) {
				 return null;
			 }
			 ((MacroInstance) o).setMacroDef(macroDef);
			 return o;
		 }
		 public boolean sameDefinition(AntTypeDefinition other, Project project) {
			 if (!super.sameDefinition(other, project)) {
				 return false;
			 }
			 MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
			 return macroDef.sameDefinition(otherDef.macroDef);
		 }
		 public boolean similarDefinition( AntTypeDefinition other, Project project) {
			 if (!super.similarDefinition(other, project)) {
				 return false;
			 }
			 MyAntTypeDefinition otherDef = (MyAntTypeDefinition) other;
			 return macroDef.similar(otherDef.macroDef);
		 }
	 }
	 private static int objectHashCode(Object o) {
		 if (o == null) {
			 return 0;
		 }
		 else {
			 return o.hashCode();
		 }
	 }
}",0,0,0,0
"public class Xor extends ConditionBase implements Condition {
	 public boolean eval() throws BuildException {
		 Enumeration e = getConditions();
		 boolean state = false;
		 while (e.hasMoreElements()) {
			 Condition c = (Condition) e.nextElement();
			 state ^= c.eval();
		 }
		 return state;
	 }
}",0,0,0,0
"class FSNamesystem implements FSConstants {
	 public static final Log LOG = LogFactory.getLog(""org.apache.hadoop.fs.FSNamesystem"");
	 FSDirectory dir;
	 Map<Block, SortedSet<DatanodeDescriptor>> blocksMap = new HashMap<Block, SortedSet<DatanodeDescriptor>>();
	 Map<String, DatanodeDescriptor> datanodeMap = new TreeMap<String, DatanodeDescriptor>();
	 private Map<String, Collection<Block>> recentInvalidateSets = new TreeMap<String, Collection<Block>>();
	 private Map<String, Collection<Block>> excessReplicateMap = new TreeMap<String, Collection<Block>>();
	 Map<UTF8, FileUnderConstruction> pendingCreates = new TreeMap<UTF8, FileUnderConstruction>();
	 Collection<Block> pendingCreateBlocks = new TreeSet<Block>();
	 long totalCapacity = 0, totalRemaining = 0;
	 StatusHttpServer infoServer;
	 int infoPort;
	 String infoBindAddress;
	 Date startTime;
	 Random r = new Random();
	 TreeSet<DatanodeDescriptor> heartbeats = new TreeSet<DatanodeDescriptor>( new Comparator<DatanodeDescriptor>() {
		 public int compare(DatanodeDescriptor d1, DatanodeDescriptor d2) {
			 long lu1 = d1.getLastUpdate();
			 long lu2 = d2.getLastUpdate();
			 if (lu1 < lu2) return -1;
			 if (lu1 > lu2) return 1;
			 return d1.getStorageID().compareTo(d2.getStorageID());
		 }
	 }
	 );
	 private Collection<Block> neededReplications = new TreeSet<Block>();
	 private Collection<Block> pendingReplications = new TreeSet<Block>();
	 private Map<UTF8, Lease> leases = new TreeMap<UTF8, Lease>();
	 private SortedSet<Lease> sortedLeases = new TreeSet<Lease>();
	 Daemon hbthread = null;
	 Daemon lmthread = null;
	 Daemon smmthread = null;
	 boolean fsRunning = true;
	 long systemStart = 0;
	 private int maxReplication;
	 private int maxReplicationStreams;
	 private int minReplication;
	 private int heartBeatRecheck;
	 public static FSNamesystem fsNamesystemObject;
	 private String localMachine;
	 private int port;
	 private SafeModeInfo safeMode;
	 public FSNamesystem(File[] dirs, NameNode nn, Configuration conf) throws IOException {
		 fsNamesystemObject = this;
		 InetSocketAddress addr = DataNode.createSocketAddr(conf.get(""fs.default.name"", ""local""));
		 this.maxReplication = conf.getInt(""dfs.replication.max"", 512);
		 this.minReplication = conf.getInt(""dfs.replication.min"", 1);
		 if( minReplication <= 0 ) throw new IOException( ""Unexpected configuration parameters: dfs.replication.min = "" + minReplication + "" must be greater than 0"" );
		 if( maxReplication >= (int)Short.MAX_VALUE ) throw new IOException( ""Unexpected configuration parameters: dfs.replication.max = "" + maxReplication + "" must be less than "" + (Short.MAX_VALUE) );
		 if( maxReplication < minReplication ) throw new IOException( ""Unexpected configuration parameters: dfs.replication.min = "" + minReplication + "" must be less than dfs.replication.max = "" + maxReplication );
		 this.maxReplicationStreams = conf.getInt(""dfs.max-repl-streams"", 2);
		 this.heartBeatRecheck= 1000;
		 this.localMachine = addr.getHostName();
		 this.port = addr.getPort();
		 this.dir = new FSDirectory(dirs);
		 this.dir.loadFSImage( conf );
		 this.safeMode = new SafeModeInfo( conf );
		 setBlockTotal();
		 this.hbthread = new Daemon(new HeartbeatMonitor());
		 this.lmthread = new Daemon(new LeaseMonitor());
		 hbthread.start();
		 lmthread.start();
		 this.systemStart = now();
		 this.startTime = new Date(systemStart);
		 this.infoPort = conf.getInt(""dfs.info.port"", 50070);
		 this.infoBindAddress = conf.get(""dfs.info.bindAddress"", ""0.0.0.0"");
		 this.infoServer = new StatusHttpServer(""dfs"",infoBindAddress, infoPort, false);
		 this.infoServer.setAttribute(""name.system"", this);
		 this.infoServer.setAttribute(""name.node"", nn);
		 this.infoServer.setAttribute(""name.conf"", conf);
		 this.infoServer.addServlet(""fsck"", ""/fsck"", FsckServlet.class);
		 this.infoServer.start();
	 }
	 public static FSNamesystem getFSNamesystem() {
		 return fsNamesystemObject;
	 }
	 public void close() {
		 synchronized (this) {
			 fsRunning = false;
		 }
		 try {
			 infoServer.stop();
			 hbthread.join(3000);
		 }
		 catch (InterruptedException ie) {
		 }
		 finally {
			 try {
				 lmthread.join(3000);
			 }
			 catch (InterruptedException ie) {
			 }
			 finally {
				 try {
					 dir.close();
				 }
				 catch (IOException ex) {
				 }
			 }
		 }
	 }
	 public Object[] open(UTF8 src) {
		 Object results[] = null;
		 Block blocks[] = dir.getFile(src);
		 if (blocks != null) {
			 results = new Object[2];
			 DatanodeDescriptor machineSets[][] = new DatanodeDescriptor[blocks.length][];
			 for (int i = 0;
			 i < blocks.length;
			 i++) {
				 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(blocks[i]);
				 if (containingNodes == null) {
					 machineSets[i] = new DatanodeDescriptor[0];
				 }
				 else {
					 machineSets[i] = new DatanodeDescriptor[containingNodes.size()];
					 int j = 0;
					 for (Iterator<DatanodeDescriptor> it = containingNodes.iterator();
					 it.hasNext();
					 j++) {
						 machineSets[i][j] = it.next();
					 }
				 }
			 }
			 results[0] = blocks;
			 results[1] = machineSets;
		 }
		 return results;
	 }
	 public boolean setReplication(String src, short replication ) throws IOException {
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot set replication for "" + src, safeMode );
		 verifyReplication(src, replication, null );
		 Vector<Integer> oldReplication = new Vector<Integer>();
		 Block[] fileBlocks;
		 fileBlocks = dir.setReplication( src, replication, oldReplication );
		 if( fileBlocks == null ) return false;
		 int oldRepl = oldReplication.elementAt(0).intValue();
		 if( oldRepl == replication ) return true;
		 synchronized( neededReplications ) {
			 if( oldRepl < replication ) {
				 LOG.info(""Increasing replication for file "" + src + "". New replication is "" + replication );
				 for( int idx = 0;
				 idx < fileBlocks.length;
				 idx++ ) neededReplications.add( fileBlocks[idx] );
			 }
			 else {
				 LOG.info(""Reducing replication for file "" + src + "". New replication is "" + replication );
				 for( int idx = 0;
				 idx < fileBlocks.length;
				 idx++ ) proccessOverReplicatedBlock( fileBlocks[idx], replication );
			 }
		 }
		 return true;
	 }
	 public long getBlockSize(String filename) throws IOException {
		 return dir.getBlockSize(filename);
	 }
	 private void verifyReplication( String src, short replication, UTF8 clientName ) throws IOException {
		 String text = ""file "" + src + ((clientName != null) ? "" on client "" + clientName : """") + "".\n"" + ""Requested replication "" + replication;
		 if( replication > maxReplication ) throw new IOException( text + "" exceeds maximum "" + maxReplication );
		 if( replication < minReplication ) throw new IOException( text + "" is less than the required minimum "" + minReplication );
	 }
	 public synchronized Object[] startFile( UTF8 src, UTF8 holder, UTF8 clientMachine, boolean overwrite, short replication, long blockSize ) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.startFile: file "" +src+"" for ""+holder+"" at ""+clientMachine);
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot create file"" + src, safeMode );
		 if (!isValidName(src.toString())) {
			 throw new IOException(""Invalid file name: "" + src);
		 }
		 try {
			 FileUnderConstruction pendingFile = pendingCreates.get(src);
			 if (pendingFile != null) {
				 Lease lease = leases.get(holder);
				 if (lease != null) {
					 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because current leaseholder is trying to recreate file."");
				 }
				 UTF8 oldholder = pendingFile.getClientName();
				 lease = leases.get(oldholder);
				 if (lease == null) {
					 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because pendingCreates is non-null but no leases found."");
				 }
				 if (lease.expiredSoftLimit()) {
					 lease.releaseLocks();
					 leases.remove(lease.holder);
					 LOG.info(""Removing lease "" + lease + "" "");
					 if (!sortedLeases.remove(lease)) {
						 LOG.error(""Unknown failure trying to remove "" + lease + "" from lease set."");
					 }
				 }
				 else {
					 throw new AlreadyBeingCreatedException( ""failed to create file "" + src + "" for "" + holder + "" on client "" + clientMachine + "" because pendingCreates is non-null."");
				 }
			 }
			 try {
				 verifyReplication(src.toString(), replication, clientMachine );
			 }
			 catch( IOException e) {
				 throw new IOException( ""failed to create ""+e.getMessage());
			 }
			 if (!dir.isValidToCreate(src)) {
				 if (overwrite) {
					 delete(src);
				 }
				 else {
					 throw new IOException(""failed to create file "" + src +"" on client "" + clientMachine +"" either because the filename is invalid or the file exists"");
				 }
			 }
			 DatanodeDescriptor targets[] = chooseTargets(replication, null, clientMachine, blockSize);
			 if (targets.length < this.minReplication) {
				 throw new IOException(""failed to create file ""+src +"" on client "" + clientMachine +"" because target-length is "" + targets.length +"", below MIN_REPLICATION ("" + minReplication+ "")"");
			 }
			 pendingCreates.put(src, new FileUnderConstruction(replication, blockSize, holder, clientMachine));
			 NameNode.stateChangeLog.debug( ""DIR* NameSystem.startFile: "" +""add ""+src+"" to pendingCreates for ""+holder );
			 synchronized (leases) {
				 Lease lease = leases.get(holder);
				 if (lease == null) {
					 lease = new Lease(holder);
					 leases.put(holder, lease);
					 sortedLeases.add(lease);
				 }
				 else {
					 sortedLeases.remove(lease);
					 lease.renew();
					 sortedLeases.add(lease);
				 }
				 lease.startedCreate(src);
			 }
			 Object results[] = new Object[2];
			 results[0] = allocateBlock(src);
			 results[1] = targets;
			 return results;
		 }
		 catch (IOException ie) {
			 NameNode.stateChangeLog.warn(""DIR* NameSystem.startFile: "" +ie.getMessage());
			 throw ie;
		 }
	 }
	 public synchronized Object[] getAdditionalBlock(UTF8 src, UTF8 clientName ) throws IOException {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.getAdditionalBlock: file "" +src+"" for ""+clientName);
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot add block to "" + src, safeMode );
		 FileUnderConstruction pendingFile = pendingCreates.get(src);
		 if (pendingFile == null) {
			 throw new LeaseExpiredException(""No lease on "" + src);
		 }
		 if (!pendingFile.getClientName().equals(clientName)) {
			 throw new LeaseExpiredException(""Lease mismatch on "" + src + "" owned by "" + pendingFile.getClientName() + "" and appended by "" + clientName);
		 }
		 if (dir.getFile(src) != null) {
			 throw new IOException(""File "" + src + "" created during write"");
		 }
		 if (!checkFileProgress(src)) {
			 throw new NotReplicatedYetException(""Not replicated yet"");
		 }
		 DatanodeDescriptor targets[] = chooseTargets(pendingFile.getReplication(), null, pendingFile.getClientMachine(), pendingFile.getBlockSize());
		 if (targets.length < this.minReplication) {
			 throw new IOException(""File "" + src + "" could only be replicated to "" + targets.length + "" nodes, instead of "" + minReplication);
		 }
		 return new Object[]{
		allocateBlock(src), targets}
		;
	 }
	 public synchronized boolean abandonBlock(Block b, UTF8 src) {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.abandonBlock: "" +b.getBlockName()+""of file ""+src );
		 FileUnderConstruction pendingFile = pendingCreates.get(src);
		 if (pendingFile != null) {
			 Collection<Block> pendingVector = pendingFile.getBlocks();
			 for (Iterator<Block> it = pendingVector.iterator();
			 it.hasNext();
			 ) {
				 Block cur = it.next();
				 if (cur.compareTo(b) == 0) {
					 pendingCreateBlocks.remove(cur);
					 it.remove();
					 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.abandonBlock: "" +b.getBlockName() +"" is removed from pendingCreateBlock and pendingCreates"");
					 return true;
				 }
			 }
		 }
		 return false;
	 }
	 public synchronized void abandonFileInProgress(UTF8 src, UTF8 holder ) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.abandonFileInProgress:"" + src );
		 synchronized (leases) {
			 Lease lease = leases.get(holder);
			 if (lease != null) {
				 if (lease.completedCreate(src)) {
					 internalReleaseCreate(src, holder);
				 }
				 else {
					 LOG.info(""Attempt by "" + holder.toString() + "" to release someone else's create lock on "" + src.toString());
				 }
			 }
			 else {
				 LOG.info(""Attempt to release a lock from an unknown lease holder "" + holder.toString() + "" for "" + src.toString());
			 }
		 }
	 }
	 public synchronized int completeFile( UTF8 src, UTF8 holder) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.completeFile: "" + src + "" for "" + holder );
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot complete file "" + src, safeMode );
		 if (dir.getFile(src) != null || pendingCreates.get(src) == null) {
			 NameNode.stateChangeLog.warn( ""DIR* NameSystem.completeFile: "" + ""failed to complete "" + src + "" because dir.getFile()=="" + dir.getFile(src) + "" and "" + pendingCreates.get(src));
			 return OPERATION_FAILED;
		 }
		 else if (! checkFileProgress(src)) {
			 return STILL_WAITING;
		 }
		 FileUnderConstruction pendingFile = pendingCreates.get(src);
		 Collection<Block> blocks = pendingFile.getBlocks();
		 int nrBlocks = blocks.size();
		 Block pendingBlocks[] = blocks.toArray(new Block[nrBlocks]);
		 for (int i = 0;
		 i < nrBlocks;
		 i++) {
			 Block b = pendingBlocks[i];
			 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(b);
			 DatanodeDescriptor node = containingNodes.first();
			 for (Iterator<Block> it = node.getBlockIterator();
			 it.hasNext();
			 ) {
				 Block cur = it.next();
				 if (b.getBlockId() == cur.getBlockId()) {
					 b.setNumBytes(cur.getNumBytes());
					 break;
				 }
			 }
		 }
		 if ( ! dir.addFile(src, pendingBlocks, pendingFile.getReplication())) {
			 return OPERATION_FAILED;
		 }
		 pendingCreates.remove(src);
		 NameNode.stateChangeLog.debug( ""DIR* NameSystem.completeFile: "" + src + "" is removed from pendingCreates"");
		 for (int i = 0;
		 i < nrBlocks;
		 i++) {
			 pendingCreateBlocks.remove(pendingBlocks[i]);
		 }
		 synchronized (leases) {
			 Lease lease = leases.get(holder);
			 if (lease != null) {
				 lease.completedCreate(src);
				 if (! lease.hasLocks()) {
					 leases.remove(holder);
					 sortedLeases.remove(lease);
				 }
			 }
		 }
		 for (int i = 0;
		 i < nrBlocks;
		 i++) {
			 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(pendingBlocks[i]);
			 if (containingNodes.size() < pendingFile.getReplication()) {
				 NameNode.stateChangeLog.debug( ""DIR* NameSystem.completeFile:"" + pendingBlocks[i].getBlockName()+"" has only ""+containingNodes.size() +"" replicas so is added to neededReplications"");
				 synchronized (neededReplications) {
					 neededReplications.add(pendingBlocks[i]);
				 }
			 }
		 }
		 return COMPLETE_SUCCESS;
	 }
	 static Random randBlockId = new Random();
	 synchronized Block allocateBlock(UTF8 src) {
		 Block b = null;
		 do {
			 b = new Block(FSNamesystem.randBlockId.nextLong(), 0);
		 }
		 while (dir.isValidBlock(b));
		 FileUnderConstruction v = pendingCreates.get(src);
		 v.getBlocks().add(b);
		 pendingCreateBlocks.add(b);
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.allocateBlock: "" +src+ "". ""+b.getBlockName()+ "" is created and added to pendingCreates and pendingCreateBlocks"" );
		 return b;
	 }
	 synchronized boolean checkFileProgress(UTF8 src) {
		 FileUnderConstruction v = pendingCreates.get(src);
		 for (Iterator<Block> it = v.getBlocks().iterator();
		 it.hasNext();
		 ) {
			 Block b = it.next();
			 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(b);
			 if (containingNodes == null || containingNodes.size() < this.minReplication) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public boolean renameTo(UTF8 src, UTF8 dst) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.renameTo: "" + src + "" to "" + dst );
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot rename "" + src, safeMode );
		 if (!isValidName(dst.toString())) {
			 throw new IOException(""Invalid name: "" + dst);
		 }
		 return dir.renameTo(src, dst);
	 }
	 public synchronized boolean delete(UTF8 src) throws IOException {
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.delete: "" + src );
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot delete "" + src, safeMode );
		 Block deletedBlocks[] = dir.delete(src);
		 if (deletedBlocks != null) {
			 for (int i = 0;
			 i < deletedBlocks.length;
			 i++) {
				 Block b = deletedBlocks[i];
				 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(b);
				 if (containingNodes != null) {
					 for (Iterator<DatanodeDescriptor> it = containingNodes.iterator();
					 it.hasNext();
					 ) {
						 DatanodeDescriptor node = it.next();
						 Collection<Block> invalidateSet = recentInvalidateSets.get(node.getStorageID());
						 if (invalidateSet == null) {
							 invalidateSet = new ArrayList<Block>();
							 recentInvalidateSets.put(node.getStorageID(), invalidateSet);
						 }
						 invalidateSet.add(b);
						 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.delete: "" + b.getBlockName() + "" is added to invalidSet of "" + node.getName() );
					 }
				 }
			 }
		 }
		 return (deletedBlocks != null);
	 }
	 public boolean exists(UTF8 src) {
		 if (dir.getFile(src) != null || dir.isDir(src)) {
			 return true;
		 }
		 else {
			 return false;
		 }
	 }
	 public boolean isDir(UTF8 src) {
		 return dir.isDir(src);
	 }
	 private boolean isValidName(String src) {
		 if (!src.startsWith(Path.SEPARATOR)) {
			 return false;
		 }
		 StringTokenizer tokens = new StringTokenizer(src, Path.SEPARATOR);
		 while( tokens.hasMoreTokens()) {
			 String element = tokens.nextToken();
			 if (element.equals("".."") || element.equals(""."") || (element.indexOf("":"") >= 0) || (element.indexOf(""/"") >= 0)) {
				 return false;
			 }
		 }
		 return true;
	 }
	 public boolean mkdirs( String src ) throws IOException {
		 boolean success;
		 NameNode.stateChangeLog.debug(""DIR* NameSystem.mkdirs: "" + src );
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot create directory "" + src, safeMode );
		 if (!isValidName(src)) {
			 throw new IOException(""Invalid directory name: "" + src);
		 }
		 success = dir.mkdirs(src);
		 if (!success) {
			 throw new IOException(""Invalid directory name: "" + src);
		 }
		 return success;
	 }
	 public String[][] getDatanodeHints(String src, long start, long len) {
		 if (start < 0 || len < 0) {
			 return new String[0][];
		 }
		 int startBlock = -1;
		 int endBlock = -1;
		 Block blocks[] = dir.getFile( new UTF8( src ));
		 if (blocks == null) {
			 return new String[0][];
		 }
		 long startpos = start;
		 long endpos = start + len;
		 for (int i = 0;
		 i < blocks.length;
		 i++) {
			 if (startpos >= 0) {
				 startpos -= blocks[i].getNumBytes();
				 if (startpos <= 0) {
					 startBlock = i;
				 }
			 }
			 if (endpos >= 0) {
				 endpos -= blocks[i].getNumBytes();
				 if (endpos <= 0) {
					 endBlock = i;
					 break;
				 }
			 }
		 }
		 if (startBlock < 0 || endBlock < 0) {
			 return new String[0][];
		 }
		 else {
			 String hosts[][] = new String[(endBlock - startBlock) + 1][];
			 for (int i = startBlock;
			 i <= endBlock;
			 i++) {
				 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(blocks[i]);
				 Collection<String> v = new ArrayList<String>();
				 if (containingNodes != null) {
					 for (Iterator<DatanodeDescriptor> it =containingNodes.iterator();
					 it.hasNext();
					) {
						 v.add( it.next().getHost() );
					 }
				 }
				 hosts[i-startBlock] = v.toArray(new String[v.size()]);
			 }
			 return hosts;
		 }
	 }
	 class Lease implements Comparable<Lease> {
		 public UTF8 holder;
		 public long lastUpdate;
		 private Collection<UTF8> locks = new TreeSet<UTF8>();
		 private Collection<UTF8> creates = new TreeSet<UTF8>();
		 public Lease(UTF8 holder) {
			 this.holder = holder;
			 renew();
		 }
		 public void renew() {
			 this.lastUpdate = now();
		 }
		 public boolean expiredHardLimit() {
			 if (now() - lastUpdate > LEASE_HARDLIMIT_PERIOD) {
				 return true;
			 }
			 return false;
		 }
		 public boolean expiredSoftLimit() {
			 if (now() - lastUpdate > LEASE_SOFTLIMIT_PERIOD) {
				 return true;
			 }
			 return false;
		 }
		 public void obtained(UTF8 src) {
			 locks.add(src);
		 }
		 public void released(UTF8 src) {
			 locks.remove(src);
		 }
		 public void startedCreate(UTF8 src) {
			 creates.add(src);
		 }
		 public boolean completedCreate(UTF8 src) {
			 return creates.remove(src);
		 }
		 public boolean hasLocks() {
			 return (locks.size() + creates.size()) > 0;
		 }
		 public void releaseLocks() {
			 for (Iterator<UTF8> it = locks.iterator();
			 it.hasNext();
			 ) internalReleaseLock(it.next(), holder);
			 locks.clear();
			 for (Iterator<UTF8> it = creates.iterator();
			 it.hasNext();
			 ) internalReleaseCreate(it.next(), holder);
			 creates.clear();
		 }
		 public String toString() {
			 return ""[Lease. Holder: "" + holder.toString() + "", heldlocks: "" + locks.size() + "", pendingcreates: "" + creates.size() + ""]"";
		 }
		 public int compareTo(Lease o) {
			 Lease l1 = this;
			 Lease l2 = o;
			 long lu1 = l1.lastUpdate;
			 long lu2 = l2.lastUpdate;
			 if (lu1 < lu2) {
				 return -1;
			 }
			 else if (lu1 > lu2) {
				 return 1;
			 }
			 else {
				 return l1.holder.compareTo(l2.holder);
			 }
		 }
	 }
	 class LeaseMonitor implements Runnable {
		 public void run() {
			 while (fsRunning) {
				 synchronized (FSNamesystem.this) {
					 synchronized (leases) {
						 Lease top;
						 while ((sortedLeases.size() > 0) && ((top = sortedLeases.first()) != null)) {
							 if (top.expiredHardLimit()) {
								 top.releaseLocks();
								 leases.remove(top.holder);
								 LOG.info(""Removing lease "" + top + "", leases remaining: "" + sortedLeases.size());
								 if (!sortedLeases.remove(top)) {
									 LOG.info(""Unknown failure trying to remove "" + top + "" from lease set."");
								 }
							 }
							 else {
								 break;
							 }
						 }
					 }
				 }
				 try {
					 Thread.sleep(2000);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 public synchronized int obtainLock( UTF8 src, UTF8 holder, boolean exclusive) throws IOException {
		 if( isInSafeMode() ) throw new SafeModeException( ""Cannot lock file "" + src, safeMode );
		 int result = dir.obtainLock(src, holder, exclusive);
		 if (result == COMPLETE_SUCCESS) {
			 synchronized (leases) {
				 Lease lease = leases.get(holder);
				 if (lease == null) {
					 lease = new Lease(holder);
					 leases.put(holder, lease);
					 sortedLeases.add(lease);
				 }
				 else {
					 sortedLeases.remove(lease);
					 lease.renew();
					 sortedLeases.add(lease);
				 }
				 lease.obtained(src);
			 }
		 }
		 return result;
	 }
	 public synchronized int releaseLock(UTF8 src, UTF8 holder) {
		 int result = internalReleaseLock(src, holder);
		 if (result == COMPLETE_SUCCESS) {
			 synchronized (leases) {
				 Lease lease = leases.get(holder);
				 if (lease != null) {
					 lease.released(src);
					 if (! lease.hasLocks()) {
						 leases.remove(holder);
						 sortedLeases.remove(lease);
					 }
				 }
			 }
		 }
		 return result;
	 }
	 private int internalReleaseLock(UTF8 src, UTF8 holder) {
		 return dir.releaseLock(src, holder);
	 }
	 private void internalReleaseCreate(UTF8 src, UTF8 holder) {
		 FileUnderConstruction v = pendingCreates.remove(src);
		 if (v != null) {
			 NameNode.stateChangeLog.debug( ""DIR* NameSystem.internalReleaseCreate: "" + src + "" is removed from pendingCreates for "" + holder + "" (failure)"");
			 for (Iterator<Block> it2 = v.getBlocks().iterator();
			 it2.hasNext();
			 ) {
				 Block b = it2.next();
				 pendingCreateBlocks.remove(b);
			 }
		 }
		 else {
			 NameNode.stateChangeLog.warn(""DIR* NameSystem.internalReleaseCreate: "" + ""attempt to release a create lock on ""+ src.toString() + "" that was not in pedingCreates"");
		 }
	 }
	 public void renewLease(UTF8 holder) throws IOException {
		 synchronized (leases) {
			 if( isInSafeMode() ) throw new SafeModeException( ""Cannot renew lease for "" + holder, safeMode );
			 Lease lease = leases.get(holder);
			 if (lease != null) {
				 sortedLeases.remove(lease);
				 lease.renew();
				 sortedLeases.add(lease);
			 }
		 }
	 }
	 public DFSFileInfo[] getListing(UTF8 src) {
		 return dir.getListing(src);
	 }
	 public synchronized void registerDatanode( DatanodeRegistration nodeReg ) throws IOException {
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""node registration from "" + nodeReg.getName() + "" storage "" + nodeReg.getStorageID() );
		 nodeReg.registrationID = getRegistrationID();
		 DatanodeDescriptor nodeS = datanodeMap.get(nodeReg.getStorageID());
		 DatanodeDescriptor nodeN = getDatanodeByName( nodeReg.getName() );
		 if( nodeN != null && nodeS != null && nodeN == nodeS ) {
			 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""node restarted."" );
			 return;
		 }
		 if( nodeN != null ) {
			 removeDatanode( nodeN );
			 wipeDatanode( nodeN );
			 getEditLog().logRemoveDatanode( nodeN );
			 nodeN = null;
		 }
		 if( nodeS != null ) {
			 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""node "" + nodeS.name + "" is replaced by "" + nodeReg.getName() + ""."" );
			 getEditLog().logRemoveDatanode( nodeS );
			 nodeS.name = nodeReg.getName();
			 getEditLog().logAddDatanode( nodeS );
			 return;
		 }
		 if( nodeReg.getStorageID().equals("""") ) {
			 nodeReg.storageID = newStorageID();
			 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.registerDatanode: "" + ""new storageID "" + nodeReg.getStorageID() + "" assigned."" );
		 }
		 DatanodeDescriptor nodeDescr = new DatanodeDescriptor( nodeReg );
		 unprotectedAddDatanode( nodeDescr );
		 getEditLog().logAddDatanode( nodeDescr );
		 return;
	 }
	 public String getRegistrationID() {
		 return ""NS"" + Integer.toString( dir.namespaceID );
	 }
	 private String newStorageID() {
		 String newID = null;
		 while( newID == null ) {
			 newID = ""DS"" + Integer.toString( r.nextInt() );
			 if( datanodeMap.get( newID ) != null ) newID = null;
		 }
		 return newID;
	 }
	 public synchronized boolean gotHeartbeat( DatanodeID nodeID, long capacity, long remaining, int xceiverCount ) throws IOException {
		 boolean needBlockReport;
		 synchronized (heartbeats) {
			 synchronized (datanodeMap) {
				 DatanodeDescriptor nodeinfo = getDatanode( nodeID );
				 needBlockReport = nodeinfo.isDead();
				 if (nodeinfo == null) throw new UnregisteredDatanodeException( nodeID );
				 removeHeartbeat(nodeinfo);
				 nodeinfo.updateHeartbeat(capacity, remaining, xceiverCount);
				 addHeartbeat(nodeinfo);
			 }
		 }
		 return needBlockReport;
	 }
	 class HeartbeatMonitor implements Runnable {
		 public void run() {
			 while (fsRunning) {
				 heartbeatCheck();
				 try {
					 Thread.sleep(heartBeatRecheck);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
		 }
	 }
	 synchronized public void removeDatanode( DatanodeID nodeID ) throws IOException {
		 DatanodeDescriptor nodeInfo = getDatanode( nodeID );
		 if (nodeInfo != null) {
			 removeDatanode( nodeInfo );
		 }
		 else {
			 NameNode.stateChangeLog.warn(""BLOCK* NameSystem.removeDatanode: "" + nodeInfo.getName() + "" does not exist"");
		 }
	 }
	 private void removeDatanode( DatanodeDescriptor nodeInfo ) {
		 removeHeartbeat(nodeInfo);
		 Block deadblocks[] = nodeInfo.getBlocks();
		 if( deadblocks != null ) for( int i = 0;
		 i < deadblocks.length;
		 i++ ) removeStoredBlock(deadblocks[i], nodeInfo);
		 unprotectedRemoveDatanode(nodeInfo);
	 }
	 void unprotectedRemoveDatanode( DatanodeDescriptor nodeDescr ) {
		 nodeDescr.resetBlocks();
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.unprotectedRemoveDatanode: "" + nodeDescr.getName() + "" is out of service now."");
	 }
	 void unprotectedAddDatanode( DatanodeDescriptor nodeDescr ) {
		 datanodeMap.put( nodeDescr.getStorageID(), nodeDescr );
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.unprotectedAddDatanode: "" + ""node "" + nodeDescr.getName() + "" is added to datanodeMap."" );
	 }
	 private void addHeartbeat( DatanodeDescriptor nodeDescr ) {
		 heartbeats.add(nodeDescr);
		 totalCapacity += nodeDescr.capacity;
		 totalRemaining += nodeDescr.remaining;
	 }
	 private void removeHeartbeat( DatanodeDescriptor nodeDescr ) {
		 totalCapacity -= nodeDescr.getCapacity();
		 totalRemaining -= nodeDescr.getRemaining();
		 heartbeats.remove(nodeDescr);
	 }
	 void wipeDatanode( DatanodeID nodeID ) {
		 datanodeMap.remove(nodeID.getStorageID());
		 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.wipeDatanode: "" + nodeID.getName() + "" storage "" + nodeID.getStorageID() + "" is removed from datanodeMap."");
	 }
	 private FSEditLog getEditLog() {
		 return dir.fsImage.getEditLog();
	 }
	 synchronized void heartbeatCheck() {
		 synchronized (heartbeats) {
			 DatanodeDescriptor nodeInfo = null;
			 while ((heartbeats.size() > 0) && ((nodeInfo = heartbeats.first()) != null) && (nodeInfo.isDead())) {
				 NameNode.stateChangeLog.info(""BLOCK* NameSystem.heartbeatCheck: "" + ""lost heartbeat from "" + nodeInfo.getName());
				 removeDatanode( nodeInfo );
			 }
		 }
	 }
	 public synchronized Block[] processReport(DatanodeID nodeID, Block newReport[] ) throws IOException {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.processReport: "" +""from ""+nodeID.getName()+"" ""+newReport.length+"" blocks"" );
		 DatanodeDescriptor node = getDatanode( nodeID );
		 int oldPos = 0, newPos = 0;
		 Block oldReport[] = node.getBlocks();
		 while (oldReport != null && newReport != null && oldPos < oldReport.length && newPos < newReport.length) {
			 int cmp = oldReport[oldPos].compareTo(newReport[newPos]);
			 if (cmp == 0) {
				 oldPos++;
				 newPos++;
			 }
			 else if (cmp < 0) {
				 removeStoredBlock(oldReport[oldPos], node);
				 oldPos++;
			 }
			 else {
				 addStoredBlock(newReport[newPos], node);
				 newPos++;
			 }
		 }
		 while (oldReport != null && oldPos < oldReport.length) {
			 removeStoredBlock(oldReport[oldPos], node);
			 oldPos++;
		 }
		 while (newReport != null && newPos < newReport.length) {
			 addStoredBlock(newReport[newPos], node);
			 newPos++;
		 }
		 node.updateBlocks(newReport);
		 Collection<Block> obsolete = new ArrayList<Block>();
		 for (Iterator<Block> it = node.getBlockIterator();
		 it.hasNext();
		 ) {
			 Block b = it.next();
			 if (! dir.isValidBlock(b) && ! pendingCreateBlocks.contains(b)) {
				 obsolete.add(b);
				 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.processReport: "" +""ask ""+nodeID.getName()+"" to delete ""+b.getBlockName() );
			 }
		 }
		 return (Block[]) obsolete.toArray(new Block[obsolete.size()]);
	 }
	 synchronized void addStoredBlock(Block block, DatanodeDescriptor node) {
		 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(block);
		 if (containingNodes == null) {
			 containingNodes = new TreeSet<DatanodeDescriptor>();
			 blocksMap.put(block, containingNodes);
		 }
		 if (! containingNodes.contains(node)) {
			 containingNodes.add(node);
			 NameNode.stateChangeLog.trace(""BLOCK* NameSystem.addStoredBlock: "" +""blockMap updated: ""+node.getName()+"" is added to ""+block.getBlockName() );
		 }
		 else {
			 NameNode.stateChangeLog.warn(""BLOCK* NameSystem.addStoredBlock: "" + ""Redundant addStoredBlock request received for "" + block.getBlockName() + "" on "" + node.getName());
		 }
		 synchronized (neededReplications) {
			 FSDirectory.INode fileINode = dir.getFileByBlock(block);
			 if( fileINode == null ) return;
			 incrementSafeBlockCount( containingNodes.size() );
			 short fileReplication = fileINode.getReplication();
			 if (containingNodes.size() >= fileReplication ) {
				 neededReplications.remove(block);
				 pendingReplications.remove(block);
				 NameNode.stateChangeLog.trace(""BLOCK* NameSystem.addStoredBlock: "" +block.getBlockName()+"" has ""+containingNodes.size() +"" replicas so is removed from neededReplications and pendingReplications"" );
			 }
			 else {
				 neededReplications.add(block);
				 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.addStoredBlock: "" +block.getBlockName()+"" has only ""+containingNodes.size() +"" replicas so is added to neededReplications"" );
			 }
			 proccessOverReplicatedBlock( block, fileReplication );
		 }
	 }
	 private void proccessOverReplicatedBlock( Block block, short replication ) {
		 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(block);
		 if( containingNodes == null ) return;
		 Collection<DatanodeDescriptor> nonExcess = new ArrayList<DatanodeDescriptor>();
		 for (Iterator<DatanodeDescriptor> it = containingNodes.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor cur = it.next();
			 Collection<Block> excessBlocks = excessReplicateMap.get(cur.getStorageID());
			 if (excessBlocks == null || ! excessBlocks.contains(block)) {
				 nonExcess.add(cur);
			 }
		 }
		 chooseExcessReplicates(nonExcess, block, replication);
	 }
	 void chooseExcessReplicates(Collection<DatanodeDescriptor> nonExcess, Block b, short replication) {
		 while (nonExcess.size() - replication > 0) {
			 DatanodeInfo cur = null;
			 long minSpace = Long.MAX_VALUE;
			 for (Iterator<DatanodeDescriptor> iter = nonExcess.iterator();
			 iter.hasNext();
			) {
				 DatanodeInfo node = iter.next();
				 long free = node.getRemaining();
				 if(minSpace > free) {
					 minSpace = free;
					 cur = node;
				 }
			 }
			 nonExcess.remove(cur);
			 Collection<Block> excessBlocks = excessReplicateMap.get(cur.getStorageID());
			 if (excessBlocks == null) {
				 excessBlocks = new TreeSet<Block>();
				 excessReplicateMap.put(cur.getStorageID(), excessBlocks);
			 }
			 excessBlocks.add(b);
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.chooseExcessReplicates: "" +""(""+cur.getName()+"", ""+b.getBlockName()+"") is added to excessReplicateMap"" );
			 Collection<Block> invalidateSet = recentInvalidateSets.get(cur.getStorageID());
			 if (invalidateSet == null) {
				 invalidateSet = new ArrayList<Block>();
				 recentInvalidateSets.put(cur.getStorageID(), invalidateSet);
			 }
			 invalidateSet.add(b);
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.chooseExcessReplicates: "" +""(""+cur.getName()+"", ""+b.getBlockName()+"") is added to recentInvalidateSets"" );
		 }
	 }
	 synchronized void removeStoredBlock(Block block, DatanodeDescriptor node) {
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName() + "" from ""+node.getName() );
		 SortedSet<DatanodeDescriptor> containingNodes = blocksMap.get(block);
		 if (containingNodes == null || ! containingNodes.contains(node)) {
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName()+"" has already been removed from node ""+node );
			 return;
		 }
		 containingNodes.remove(node);
		 decrementSafeBlockCount( containingNodes.size() );
		 if( containingNodes.size() == 0 ) blocksMap.remove(block);
		 FSDirectory.INode fileINode = dir.getFileByBlock(block);
		 if( fileINode != null && (containingNodes.size() < fileINode.getReplication())) {
			 synchronized (neededReplications) {
				 neededReplications.add(block);
			 }
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName()+"" has only ""+containingNodes.size() +"" replicas so is added to neededReplications"" );
		 }
		 Collection<Block> excessBlocks = excessReplicateMap.get(node.getStorageID());
		 if (excessBlocks != null) {
			 excessBlocks.remove(block);
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.removeStoredBlock: "" +block.getBlockName()+"" is removed from excessBlocks"" );
			 if (excessBlocks.size() == 0) {
				 excessReplicateMap.remove(node.getStorageID());
			 }
		 }
	 }
	 public synchronized void blockReceived( DatanodeID nodeID, Block block ) throws IOException {
		 DatanodeDescriptor node = getDatanode( nodeID );
		 if (node == null) {
			 NameNode.stateChangeLog.warn(""BLOCK* NameSystem.blockReceived: "" + block.getBlockName() + "" is received from an unrecorded node "" + nodeID.getName() );
			 throw new IllegalArgumentException( ""Unexpected exception. Got blockReceived message from node "" + block.getBlockName() + "", but there is no info for it"");
		 }
		 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.blockReceived: "" +block.getBlockName()+"" is received from "" + nodeID.getName() );
		 addStoredBlock(block, node);
		 node.addBlock(block);
	 }
	 public long totalCapacity() {
		 return totalCapacity;
	 }
	 public long totalRemaining() {
		 return totalRemaining;
	 }
	 public DatanodeInfo[] datanodeReport() {
		 DatanodeInfo results[] = null;
		 synchronized (heartbeats) {
			 synchronized (datanodeMap) {
				 results = new DatanodeInfo[datanodeMap.size()];
				 int i = 0;
				 for(Iterator<DatanodeDescriptor> it = datanodeMap.values().iterator();
				 it.hasNext();
				 ) results[i++] = new DatanodeInfo( it.next() );
			 }
		 }
		 return results;
	 }
	 public void DFSNodesStatus( Vector<DatanodeDescriptor> live, Vector<DatanodeDescriptor> dead) {
		 synchronized (heartbeats) {
			 synchronized (datanodeMap) {
				 for(Iterator<DatanodeDescriptor> it = datanodeMap.values().iterator();
				 it.hasNext();
				 ) {
					 DatanodeDescriptor node = it.next();
					 if( node.isDead() ) dead.add( node );
					 else live.add( node );
				 }
			 }
		 }
	 }
	 public DatanodeInfo getDataNodeInfo(String name) {
		 return datanodeMap.get(name);
	 }
	 public String getDFSNameNodeMachine() {
		 return localMachine;
	 }
	 public int getDFSNameNodePort() {
		 return port;
	 }
	 public Date getStartTime() {
		 return startTime;
	 }
	 public synchronized Block[] blocksToInvalidate( DatanodeID nodeID ) {
		 if( isInSafeMode() ) return null;
		 Collection<Block> invalidateSet = recentInvalidateSets.remove( nodeID.getStorageID() );
		 if (invalidateSet == null ) return null;
		 if(NameNode.stateChangeLog.isInfoEnabled()) {
			 StringBuffer blockList = new StringBuffer();
			 for( Iterator<Block> it = invalidateSet.iterator();
			 it.hasNext();
			 ) {
				 blockList.append(' ');
				 blockList.append(it.next().getBlockName());
			 }
			 NameNode.stateChangeLog.debug(""BLOCK* NameSystem.blockToInvalidate: "" +""ask ""+nodeID.getName()+"" to delete "" + blockList );
		 }
		 return (Block[]) invalidateSet.toArray(new Block[invalidateSet.size()]);
	 }
	 public synchronized Object[] pendingTransfers(DatanodeID srcNode, int xmitsInProgress) {
		 if( isInSafeMode() ) return null;
		 synchronized (neededReplications) {
			 Object results[] = null;
			 int scheduledXfers = 0;
			 if (neededReplications.size() > 0) {
				 List<Block> replicateBlocks = new ArrayList<Block>();
				 List<DatanodeDescriptor[]> replicateTargetSets;
				 replicateTargetSets = new ArrayList<DatanodeDescriptor[]>();
				 for (Iterator<Block> it = neededReplications.iterator();
				 it.hasNext();
				) {
					 if (scheduledXfers >= this.maxReplicationStreams - xmitsInProgress) {
						 break;
					 }
					 Block block = it.next();
					 long blockSize = block.getNumBytes();
					 FSDirectory.INode fileINode = dir.getFileByBlock(block);
					 if (fileINode == null) {
						 it.remove();
					 }
					 else {
						 Collection<DatanodeDescriptor> containingNodes = blocksMap.get(block);
						 Collection<Block> excessBlocks = excessReplicateMap.get( srcNode.getStorageID() );
						 if (containingNodes != null && containingNodes.contains(srcNode) && (excessBlocks == null || ! excessBlocks.contains(block))) {
							 DatanodeDescriptor targets[] = chooseTargets( Math.min( fileINode.getReplication() - containingNodes.size(), this.maxReplicationStreams - xmitsInProgress), containingNodes, null, blockSize);
							 if (targets.length > 0) {
								 replicateBlocks.add(block);
								 replicateTargetSets.add(targets);
								 scheduledXfers += targets.length;
							 }
						 }
					 }
				 }
				 if (replicateBlocks.size() > 0) {
					 int i = 0;
					 for (Iterator<Block> it = replicateBlocks.iterator();
					 it.hasNext();
					 i++) {
						 Block block = it.next();
						 DatanodeDescriptor targets[] = (DatanodeDescriptor[]) replicateTargetSets.get(i);
						 Collection<DatanodeDescriptor> containingNodes = blocksMap.get(block);
						 if (containingNodes.size() + targets.length >= dir.getFileByBlock( block).getReplication() ) {
							 neededReplications.remove(block);
							 pendingReplications.add(block);
							 NameNode.stateChangeLog.debug( ""BLOCK* NameSystem.pendingTransfer: "" + block.getBlockName() + "" is removed from neededReplications to pendingReplications"");
						 }
						 if (NameNode.stateChangeLog.isInfoEnabled()) {
							 StringBuffer targetList = new StringBuffer(""datanode(s)"");
							 for (int k = 0;
							 k < targets.length;
							 k++) {
								 targetList.append(' ');
								 targetList.append(targets[k].getName());
							 }
							 NameNode.stateChangeLog.info( ""BLOCK* NameSystem.pendingTransfer: "" + ""ask "" + srcNode.getName() + "" to replicate "" + block.getBlockName() + "" to "" + targetList);
							 NameNode.stateChangeLog.debug( ""BLOCK* neededReplications = "" + neededReplications.size() + "" pendingReplications = "" + pendingReplications.size() );
						 }
					 }
					 DatanodeDescriptor targetMatrix[][] = new DatanodeDescriptor[replicateTargetSets.size()][];
					 for (i = 0;
					 i < targetMatrix.length;
					 i++) {
						 targetMatrix[i] = replicateTargetSets.get(i);
					 }
					 results = new Object[2];
					 results[0] = replicateBlocks.toArray(new Block[replicateBlocks.size()]);
					 results[1] = targetMatrix;
				 }
			 }
			 return results;
		 }
	 }
	 DatanodeDescriptor[] chooseTargets( int desiredReplicates, Collection<DatanodeDescriptor> forbiddenNodes, UTF8 clientMachine, long blockSize) {
		 if (desiredReplicates > heartbeats.size()) {
			 LOG.warn(""Replication requested of ""+desiredReplicates +"" is larger than cluster size (""+heartbeats.size() +""). Using cluster size."");
			 desiredReplicates = heartbeats.size();
		 }
		 Collection<DatanodeDescriptor> alreadyChosen;
		 alreadyChosen = new TreeSet<DatanodeDescriptor>();
		 Collection<DatanodeDescriptor> targets = new ArrayList<DatanodeDescriptor>();
		 for (int i = 0;
		 i < desiredReplicates;
		 i++) {
			 DatanodeDescriptor target = chooseTarget(forbiddenNodes, alreadyChosen, clientMachine, blockSize);
			 if (target == null) break;
			 targets.add(target);
			 alreadyChosen.add(target);
		 }
		 return (DatanodeDescriptor[]) targets.toArray(new DatanodeDescriptor[targets.size()]);
	 }
	 DatanodeDescriptor chooseTarget(Collection<DatanodeDescriptor> forbidden1, Collection<DatanodeDescriptor> forbidden2, UTF8 clientMachine, long blockSize) {
		 int totalMachines = heartbeats.size();
		 if (totalMachines == 0) {
			 LOG.warn(""While choosing target, totalMachines is "" + totalMachines);
			 return null;
		 }
		 Collection<String> forbiddenMachines = new TreeSet<String>();
		 if (forbidden1 != null) {
			 for (Iterator<DatanodeDescriptor> it = forbidden1.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor cur = it.next();
				 forbiddenMachines.add(cur.getHost());
			 }
		 }
		 if (forbidden2 != null) {
			 for (Iterator<DatanodeDescriptor> it = forbidden2.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor cur = it.next();
				 forbiddenMachines.add(cur.getHost());
			 }
		 }
		 double avgLoad = 0.0;
		 List<DatanodeDescriptor> targetList = new ArrayList<DatanodeDescriptor>();
		 for (Iterator<DatanodeDescriptor> it = heartbeats.iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor node = it.next();
			 if (! forbiddenMachines.contains(node.getHost())) {
				 targetList.add(node);
				 avgLoad += node.getXceiverCount();
			 }
		 }
		 if (targetList.size() > 0) {
			 avgLoad = avgLoad/targetList.size();
		 }
		 Collections.shuffle(targetList);
		 if (targetList.size() > 0) {
			 if (clientMachine != null && clientMachine.getLength() > 0) {
				 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
				 it.hasNext();
				 ) {
					 DatanodeDescriptor node = it.next();
					 if (clientMachine.toString().equals(node.getHost())) {
						 if ((node.getRemaining() >= blockSize * MIN_BLOCKS_FOR_WRITE) && (node.getXceiverCount() <= (2.0 * avgLoad))) {
							 return node;
						 }
					 }
				 }
			 }
			 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor node = it.next();
				 if ((node.getRemaining() >= blockSize * MIN_BLOCKS_FOR_WRITE) && (node.getXceiverCount() <= (2.0 * avgLoad))) {
					 return node;
				 }
			 }
			 if (clientMachine != null && clientMachine.getLength() > 0) {
				 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
				 it.hasNext();
				 ) {
					 DatanodeDescriptor node = it.next();
					 if (clientMachine.toString().equals(node.getHost()) && node.getRemaining() >= blockSize) {
						 return node;
					 }
				 }
			 }
			 for (Iterator<DatanodeDescriptor> it = targetList.iterator();
			 it.hasNext();
			 ) {
				 DatanodeDescriptor node = it.next();
				 if (node.getRemaining() >= blockSize) {
					 return node;
				 }
			 }
			 LOG.warn(""Could not find any nodes with sufficient capacity"");
			 return null;
		 }
		 else {
			 LOG.warn(""Zero targets found, forbidden1.size="" + ( forbidden1 != null ? forbidden1.size() : 0 ) + "" forbidden2.size()="" + ( forbidden2 != null ? forbidden2.size() : 0 ));
			 return null;
		 }
	 }
	 private class FileUnderConstruction {
		 private short blockReplication;
		 private long blockSize;
		 private Collection<Block> blocks;
		 private UTF8 clientName;
		 private UTF8 clientMachine;
		 FileUnderConstruction(short replication, long blockSize, UTF8 clientName, UTF8 clientMachine) throws IOException {
			 this.blockReplication = replication;
			 this.blockSize = blockSize;
			 this.blocks = new ArrayList<Block>();
			 this.clientName = clientName;
			 this.clientMachine = clientMachine;
		 }
		 public short getReplication() {
			 return this.blockReplication;
		 }
		 public long getBlockSize() {
			 return blockSize;
		 }
		 public Collection<Block> getBlocks() {
			 return blocks;
		 }
		 public UTF8 getClientName() {
			 return clientName;
		 }
		 public UTF8 getClientMachine() {
			 return clientMachine;
		 }
	 }
	 public DatanodeDescriptor getDatanode( DatanodeID nodeID ) throws IOException {
		 UnregisteredDatanodeException e = null;
		 DatanodeDescriptor node = datanodeMap.get(nodeID.getStorageID());
		 if (node == null) return null;
		 if (!node.getName().equals(nodeID.getName())) {
			 e = new UnregisteredDatanodeException( nodeID, node );
			 NameNode.stateChangeLog.fatal(""BLOCK* NameSystem.getDatanode: "" + e.getLocalizedMessage() );
			 throw e;
		 }
		 return node;
	 }
	 public DatanodeDescriptor getDatanodeByName( String name ) throws IOException {
		 for (Iterator<DatanodeDescriptor> it = datanodeMap.values().iterator();
		 it.hasNext();
		 ) {
			 DatanodeDescriptor node = it.next();
			 if( node.getName().equals(name) ) return node;
		 }
		 return null;
	 }
	 private DatanodeInfo getDatanodeByIndex( int index ) {
		 int i = 0;
		 for (Iterator<DatanodeDescriptor> it = datanodeMap.values().iterator();
		 it.hasNext();
		 ) {
			 DatanodeInfo node = it.next();
			 if( i == index ) return node;
			 i++;
		 }
		 return null;
	 }
	 public String randomDataNode() {
		 int size = datanodeMap.size();
		 int index = 0;
		 if (size != 0) {
			 index = r.nextInt(size);
			 DatanodeInfo d = getDatanodeByIndex(index);
			 if (d != null) {
				 return d.getHost() + "":"" + d.getInfoPort();
			 }
		 }
		 return null;
	 }
	 public int getNameNodeInfoPort() {
		 return infoPort;
	 }
	 class SafeModeInfo {
		 private double threshold;
		 private int extension;
		 private int safeReplication;
		 private long reached = -1;
		 int blockTotal;
		 private int blockSafe;
		 SafeModeInfo( Configuration conf ) {
			 this.threshold = conf.getFloat( ""dfs.safemode.threshold.pct"", 0.95f );
			 this.extension = conf.getInt( ""dfs.safemode.extension"", 0 );
			 this.safeReplication = conf.getInt( ""dfs.replication.min"", 1 );
			 this.blockTotal = 0;
			 this.blockSafe = 0;
		 }
		 private SafeModeInfo() {
			 this.threshold = 1.5f;
			 this.extension = 0;
			 this.safeReplication = Short.MAX_VALUE + 1;
			 this.blockTotal = -1;
			 this.blockSafe = -1;
			 this.reached = -1;
			 enter();
		 }
		 synchronized boolean isOn() {
			 try {
				 isConsistent();
			 }
			 catch( IOException e ) {
				 System.err.print( StringUtils.stringifyException( e ));
			 }
			 return this.reached >= 0;
		 }
		 void enter() {
			 if( reached != 0 ) NameNode.stateChangeLog.info( ""STATE* SafeModeInfo.enter: "" + ""Safe mode is ON.\n"" + getTurnOffTip() );
			 this.reached = 0;
		 }
		 synchronized void leave() {
			 if( reached >= 0 ) NameNode.stateChangeLog.info( ""STATE* SafeModeInfo.leave: "" + ""Safe mode is OFF."" );
			 reached = -1;
			 safeMode = null;
		 }
		 synchronized boolean canLeave() {
			 if( reached == 0 ) return false;
			 if( now() - reached < extension ) return false;
			 return ! needEnter();
		 }
		 boolean needEnter() {
			 return getSafeBlockRatio() < threshold;
		 }
		 private float getSafeBlockRatio() {
			 return ( blockTotal == 0 ? 1 : (float)blockSafe/blockTotal );
		 }
		 private void checkMode() {
			 if( needEnter() ) {
				 enter();
				 return;
			 }
			 if( ! isOn() || extension <= 0 || threshold <= 0 ) {
				 this.leave();
				 return;
			 }
			 if( reached > 0 ) return;
			 reached = now();
			 smmthread = new Daemon(new SafeModeMonitor());
			 smmthread.start();
		 }
		 synchronized void setBlockTotal( int total) {
			 this.blockTotal = total;
			 checkMode();
		 }
		 synchronized void incrementSafeBlockCount( short replication ) {
			 if( (int)replication == safeReplication ) this.blockSafe++;
			 checkMode();
		 }
		 synchronized void decrementSafeBlockCount( short replication ) {
			 if( replication == safeReplication-1 ) this.blockSafe--;
			 checkMode();
		 }
		 boolean isManual() {
			 return blockTotal == -1;
		 }
		 String getTurnOffTip() {
			 return ( isManual() ? ""Use \""hadoop dfs -safemode leave\"" to turn safe mode off."" : ""Safe mode will be turned off automatically."" );
		 }
		 public String toString() {
			 String resText = ""Current safe block ratio = "" + getSafeBlockRatio() + "". Target threshold = "" + threshold + "". Minimal replication = "" + safeReplication + ""."";
			 if( reached > 0 ) resText += "" Threshold was reached "" + new Date(reached) + ""."";
			 return resText;
		 }
		 void isConsistent() throws IOException {
			 if( blockTotal == -1 && blockSafe == -1 ) {
				 return;
			 }
			 int activeBlocks = dir.activeBlocks.size();
			 if( blockTotal != activeBlocks ) throw new IOException( ""blockTotal "" + blockTotal + "" does not match all blocks count. "" + ""activeBlocks = "" + activeBlocks + "". safeBlocks = "" + blockSafe + "" safeMode is: "" + ((safeMode == null) ? ""null"" : safeMode.toString()) );
			 if( blockSafe < 0 || blockSafe > blockTotal ) throw new IOException( ""blockSafe "" + blockSafe + "" is out of range [0,"" + blockTotal + ""]. "" + ""activeBlocks = "" + activeBlocks + "" safeMode is: "" + ((safeMode == null) ? ""null"" : safeMode.toString()) );
		 }
	 }
	 class SafeModeMonitor implements Runnable {
		 private static final long recheckInterval = 1000;
		 public void run() {
			 while( ! safeMode.canLeave() ) {
				 try {
					 Thread.sleep(recheckInterval);
				 }
				 catch (InterruptedException ie) {
				 }
			 }
			 safeMode.leave();
			 smmthread = null;
		 }
	 }
	 static long now() {
		 return System.currentTimeMillis();
	 }
	 boolean isInSafeMode() {
		 if( safeMode == null ) return false;
		 return safeMode.isOn();
	 }
	 void incrementSafeBlockCount( int replication ) {
		 if( safeMode == null ) return;
		 safeMode.incrementSafeBlockCount( (short)replication );
	 }
	 void decrementSafeBlockCount( int replication ) {
		 if( safeMode == null ) return;
		 safeMode.decrementSafeBlockCount( (short)replication );
	 }
	 void setBlockTotal() {
		 if( safeMode == null ) return;
		 safeMode.setBlockTotal( dir.activeBlocks.size() );
	 }
	 synchronized void enterSafeMode() throws IOException {
		 if( isInSafeMode() ) {
			 NameNode.stateChangeLog.info( ""STATE* FSNamesystem.enterSafeMode: "" + ""Safe mode is already ON."");
			 return;
		 }
		 safeMode = new SafeModeInfo();
	 }
	 synchronized void leaveSafeMode() throws IOException {
		 if( ! isInSafeMode() ) {
			 NameNode.stateChangeLog.info( ""STATE* FSNamesystem.leaveSafeMode: "" + ""Safe mode is already OFF."");
			 return;
		 }
		 safeMode.leave();
	 }
	 String getSafeModeTip() {
		 if( ! isInSafeMode() ) return """";
		 return safeMode.getTurnOffTip();
	 }
	 public static class FsckServlet extends HttpServlet {
		 public void doGet(HttpServletRequest request, HttpServletResponse response ) throws ServletException, IOException {
			 Map<String,String[]> pmap = request.getParameterMap();
			 try {
				 ServletContext context = getServletContext();
				 NameNode nn = (NameNode) context.getAttribute(""name.node"");
				 Configuration conf = (Configuration) context.getAttribute(""name.conf"");
				 NamenodeFsck fscker = new NamenodeFsck(conf, nn, pmap, response);
				 fscker.fsck();
			 }
			 catch (IOException ie) {
				 StringUtils.stringifyException(ie);
				 LOG.warn(ie);
				 String errMsg = ""Fsck on path "" + pmap.get(""path"") + "" failed."";
				 response.sendError(HttpServletResponse.SC_GONE, errMsg);
				 throw ie;
			 }
		 }
	 }
}",0,0,0,0
"public class ElementCommandImpl implements IElementCommand{
	private ReportItemImpl element = null;
	private DesignElementHandle extItemHandle = null;
	private String propName = null;
	private static String commandTag = ""initial"";
	 private static final String EXECUTE_TAG = ""execute"";
	 private static final String REDO_TAG = ""redo"";
	 private static final String UNDO_TAG = ""undo"";
	 private Object oldValue = null;
	private Object newValue = null;
	public ElementCommandImpl( ReportItemImpl propertyOwner, String name,Object value, DesignElementHandle elementHandle ){
		assert propertyOwner != null;
		element = propertyOwner;
		assert name != null;
		assert elementHandle != null;
		extItemHandle = elementHandle;
		propName = name;
		newValue = value;
		oldValue = propertyOwner.getProperty( name );
	}
	protected void perform( boolean undo ){
		Object value = undo ? oldValue : newValue;
		if ( propName.equals( ""company"" ) && value != null ) element.doSetProperty( propName, value.toString( ) + commandTag );
		else if ( propName.equals( ""company"" ) && value == null ) element.doSetProperty( propName, commandTag );
		elseelement.doSetProperty( propName, value );
	}
	public void execute( ){
		commandTag = EXECUTE_TAG;
		perform( false );
	}
	public void undo( ){
		commandTag = UNDO_TAG;
		perform( true );
	}
	public void redo( ){
		commandTag = REDO_TAG;
		perform( false );
	}
	public boolean canUndo( ){
		return true;
	}
	public boolean canRedo( ){
		return true;
	}
	public String getLabel( ){
		return ""Command"";
	 }
	public DesignElementHandle getElementHandle( ){
		return extItemHandle;
	}
}",0,0,0,0
"public static class put<I extends AsyncIface> extends org.apache.thrift.AsyncProcessFunction<I, put_args, Void> {
	 public put() {
		 super(""put"");
	 }
	 public put_args getEmptyArgsInstance() {
		 return new put_args();
	 }
	 public org.apache.thrift.async.AsyncMethodCallback<Void> getResultHandler(final org.apache.thrift.server.AbstractNonblockingServer.AsyncFrameBuffer fb, final int seqid) {
		 final org.apache.thrift.AsyncProcessFunction fcall = this;
		 return new org.apache.thrift.async.AsyncMethodCallback<Void>() {
			 public void onComplete(Void o) {
				 put_result result = new put_result();
				 try {
					 fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY,seqid);
				 }
				 catch (org.apache.thrift.transport.TTransportException e) {
					 _LOGGER.error(""TTransportException writing to internal frame buffer"", e);
					 fb.close();
				 }
				 catch (java.lang.Exception e) {
					 _LOGGER.error(""Exception writing to internal frame buffer"", e);
					 onError(e);
				 }
			 }
			 public void onError(java.lang.Exception e) {
				 byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;
				 org.apache.thrift.TSerializable msg;
				 put_result result = new put_result();
				 if (e instanceof TIOError) {
					 result.io = (TIOError) e;
					 result.setIoIsSet(true);
					 msg = result;
				 }
				 else if (e instanceof org.apache.thrift.transport.TTransportException) {
					 _LOGGER.error(""TTransportException inside handler"", e);
					 fb.close();
					 return;
				 }
				 else if (e instanceof org.apache.thrift.TApplicationException) {
					 _LOGGER.error(""TApplicationException inside handler"", e);
					 msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
					 msg = (org.apache.thrift.TApplicationException)e;
				 }
				 else {
					 _LOGGER.error(""Exception inside handler"", e);
					 msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;
					 msg = new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());
				 }
				 try {
					 fcall.sendResponse(fb,msg,msgType,seqid);
				 }
				 catch (java.lang.Exception ex) {
					 _LOGGER.error(""Exception writing to internal frame buffer"", ex);
					 fb.close();
				 }
			 }
		 }
		;
	 }
	 protected boolean isOneway() {
		 return false;
	 }
	 public void start(I iface, put_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws org.apache.thrift.TException {
		 iface.put(args.table, args.tput,resultHandler);
	 }
 }",0,0,0,0
"public class PipelineOptionsFactory {
	 public static PipelineOptions create() {
		 return new Builder().as(PipelineOptions.class);
	 }
	 public static <T extends PipelineOptions> T as(Class<T> klass) {
		 return new Builder().as(klass);
	 }
	 public static Builder fromArgs(String... args) {
		 return new Builder().fromArgs(args);
	 }
	 public Builder withValidation() {
		 return new Builder().withValidation();
	 }
	 public static class Builder {
		 private final String defaultAppName;
		 private final String[] args;
		 private final boolean validation;
		 private final boolean strictParsing;
		 private final boolean isCli;
		 private Builder() {
			 this(null, false, true, false);
		 }
		 private Builder(String[] args, boolean validation, boolean strictParsing, boolean isCli) {
			 this.defaultAppName = findCallersClassName();
			 this.args = args;
			 this.validation = validation;
			 this.strictParsing = strictParsing;
			 this.isCli = isCli;
		 }
		 public Builder fromArgs(String... args) {
			 checkNotNull(args, ""Arguments should not be null."");
			 return new Builder(args, validation, strictParsing, true);
		 }
		 public Builder withValidation() {
			 return new Builder(args, true, strictParsing, isCli);
		 }
		 public Builder withoutStrictParsing() {
			 return new Builder(args, validation, false, isCli);
		 }
		 public PipelineOptions create() {
			 return as(PipelineOptions.class);
		 }
		 public <T extends PipelineOptions> T as(Class<T> klass) {
			 Map<String, Object> initialOptions = Maps.newHashMap();
			 if (args != null) {
				 ListMultimap<String, String> options = parseCommandLine(args, strictParsing);
				 LOG.debug(""Provided Arguments: {
				}
				"", options);
				 printHelpUsageAndExitIfNeeded(options, System.out, true );
				 initialOptions = parseObjects(klass, options, strictParsing);
			 }
			 ProxyInvocationHandler handler = new ProxyInvocationHandler(initialOptions);
			 T t = handler.as(klass);
			 ApplicationNameOptions appNameOptions = t.as(ApplicationNameOptions.class);
			 if (appNameOptions.getAppName() == null) {
				 appNameOptions.setAppName(defaultAppName);
			 }
			 t.getOptionsId();
			 if (validation) {
				 if (isCli) {
					 PipelineOptionsValidator.validateCli(klass, t);
				 }
				 else {
					 PipelineOptionsValidator.validate(klass, t);
				 }
			 }
			 return t;
		 }
	 }
	 static boolean printHelpUsageAndExitIfNeeded( ListMultimap<String, String> options, PrintStream printStream, boolean exit) {
		 if (options.containsKey(""help"")) {
			 final String helpOption = Iterables.getOnlyElement(options.get(""help""));
			 if (Boolean.TRUE.toString().equals(helpOption)) {
				 printHelp(printStream);
				 if (exit) {
					 System.exit(0);
				 }
				 else {
					 return true;
				 }
			 }
			 try {
				 Class<?> klass = Class.forName(helpOption, true, ReflectHelpers.findClassLoader());
				 if (!PipelineOptions.class.isAssignableFrom(klass)) {
					 throw new ClassNotFoundException(""PipelineOptions of type "" + klass + "" not found."");
				 }
				 printHelp(printStream, (Class<? extends PipelineOptions>) klass);
			 }
			 catch (ClassNotFoundException e) {
				 Iterable<Class<? extends PipelineOptions>> matches = getRegisteredOptions().stream() .filter( input -> {
					 if (helpOption.contains(""."")) {
						 return input.getName().endsWith(helpOption);
					 }
					 else {
						 return input.getSimpleName().equals(helpOption);
					 }
				 }
				) .collect(Collectors.toList());
				 try {
					 printHelp(printStream, Iterables.getOnlyElement(matches));
				 }
				 catch (NoSuchElementException exception) {
					 printStream.format(""Unable to find option %s.%n"", helpOption);
					 printHelp(printStream);
				 }
				 catch (IllegalArgumentException exception) {
					 printStream.format( ""Multiple matches found for %s: %s.%n"", helpOption, StreamSupport.stream(matches.spliterator(), false) .map(ReflectHelpers.CLASS_NAME::apply) .collect(Collectors.toList()));
					 printHelp(printStream);
				 }
			 }
			 if (exit) {
				 System.exit(0);
			 }
			 else {
				 return true;
			 }
		 }
		 return false;
	 }
	 private static String findCallersClassName() {
		 Iterator<StackTraceElement> elements = Iterators.forArray(Thread.currentThread().getStackTrace());
		 while (elements.hasNext()) {
			 StackTraceElement next = elements.next();
			 if (PIPELINE_OPTIONS_FACTORY_CLASSES.contains(next.getClassName())) {
				 break;
			 }
		 }
		 while (elements.hasNext()) {
			 StackTraceElement next = elements.next();
			 if (!PIPELINE_OPTIONS_FACTORY_CLASSES.contains(next.getClassName())) {
				 try {
					 return Class.forName(next.getClassName(), true, ReflectHelpers.findClassLoader()) .getSimpleName();
				 }
				 catch (ClassNotFoundException e) {
					 break;
				 }
			 }
		 }
		 return ""unknown"";
	 }
	 static class Registration<T extends PipelineOptions> {
		 private final Class<T> proxyClass;
		 private final List<PropertyDescriptor> propertyDescriptors;
		 public Registration(Class<T> proxyClass, List<PropertyDescriptor> beanInfo) {
			 this.proxyClass = proxyClass;
			 this.propertyDescriptors = beanInfo;
		 }
		 List<PropertyDescriptor> getPropertyDescriptors() {
			 return propertyDescriptors;
		 }
		 Class<T> getProxyClass() {
			 return proxyClass;
		 }
	 }
	 private static final ImmutableSet<Class<?>> SIMPLE_TYPES = ImmutableSet.<Class<?>>builder() .add(boolean.class) .add(Boolean.class) .add(char.class) .add(Character.class) .add(short.class) .add(Short.class) .add(int.class) .add(Integer.class) .add(long.class) .add(Long.class) .add(float.class) .add(Float.class) .add(double.class) .add(Double.class) .add(String.class) .add(Class.class) .build();
	 private static final Logger LOG = LoggerFactory.getLogger(PipelineOptionsFactory.class);
	 private static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];
	 static final ObjectMapper MAPPER = new ObjectMapper() .registerModules(ObjectMapper.findModules(ReflectHelpers.findClassLoader()));
	 private static final ImmutableSet<String> PIPELINE_OPTIONS_FACTORY_CLASSES = ImmutableSet.of(PipelineOptionsFactory.class.getName(), Builder.class.getName());
	 private static final Set<Method> IGNORED_METHODS;
	 private static final Predicate<Method> NOT_SYNTHETIC_PREDICATE = input -> !input.isSynthetic();
	 private static final Predicate<Method> NOT_STATIC_PREDICATE = input -> !Modifier.isStatic(input.getModifiers());
	 static final AtomicReference<Cache> CACHE = new AtomicReference<>();
	 private static final int TERMINAL_WIDTH = 80;
	 static {
		 try {
			 IGNORED_METHODS = ImmutableSet.<Method>builder() .add(Object.class.getMethod(""getClass"")) .add(Object.class.getMethod(""wait"")) .add(Object.class.getMethod(""wait"", long.class)) .add(Object.class.getMethod(""wait"", long.class, int.class)) .add(Object.class.getMethod(""notify"")) .add(Object.class.getMethod(""notifyAll"")) .add(Proxy.class.getMethod(""getInvocationHandler"", Object.class)) .build();
		 }
		 catch (NoSuchMethodException | SecurityException e) {
			 LOG.error(""Unable to find expected method"", e);
			 throw new ExceptionInInitializerError(e);
		 }
		 resetCache();
	 }
	 public static synchronized void register(Class<? extends PipelineOptions> iface) {
		 CACHE.get().register(iface);
	 }
	 public static synchronized void resetCache() {
		 CACHE.set(new Cache());
	 }
	 public static Set<Class<? extends PipelineOptions>> getRegisteredOptions() {
		 return Collections.unmodifiableSet(CACHE.get().registeredOptions);
	 }
	 public static void printHelp(PrintStream out) {
		 checkNotNull(out);
		 out.println(""The set of registered options are:"");
		 Set<Class<? extends PipelineOptions>> sortedOptions = new TreeSet<>(ClassNameComparator.INSTANCE);
		 sortedOptions.addAll(CACHE.get().registeredOptions);
		 for (Class<? extends PipelineOptions> kls : sortedOptions) {
			 out.format("" %s%n"", kls.getName());
		 }
		 out.format( ""%nUse --help=<OptionsName> for detailed help. For example:%n"" + "" --help=DataflowPipelineOptions <short names valid for registered options>%n"" + "" --help=org.apache.beam.sdk.options.DataflowPipelineOptions%n"");
	 }
	 public static void printHelp(PrintStream out, Class<? extends PipelineOptions> iface) {
		 checkNotNull(out);
		 checkNotNull(iface);
		 CACHE.get().validateWellFormed(iface);
		 Set<PipelineOptionSpec> properties = PipelineOptionsReflector.getOptionSpecs(iface);
		 RowSortedTable<Class<?>, String, Method> ifacePropGetterTable = TreeBasedTable.create(ClassNameComparator.INSTANCE, Ordering.natural());
		 for (PipelineOptionSpec prop : properties) {
			 ifacePropGetterTable.put(prop.getDefiningInterface(), prop.getName(), prop.getGetterMethod());
		 }
		 for (Map.Entry<Class<?>, Map<String, Method>> ifaceToPropertyMap : ifacePropGetterTable.rowMap().entrySet()) {
			 Class<?> currentIface = ifaceToPropertyMap.getKey();
			 Map<String, Method> propertyNamesToGetters = ifaceToPropertyMap.getValue();
			 SortedSetMultimap<String, String> requiredGroupNameToProperties = getRequiredGroupNamesToProperties(propertyNamesToGetters);
			 out.format(""%s:%n"", currentIface.getName());
			 prettyPrintDescription(out, currentIface.getAnnotation(Description.class));
			 out.println();
			 List<String> lists = Lists.newArrayList(propertyNamesToGetters.keySet());
			 lists.sort(String.CASE_INSENSITIVE_ORDER);
			 for (String propertyName : lists) {
				 Method method = propertyNamesToGetters.get(propertyName);
				 String printableType = method.getReturnType().getSimpleName();
				 if (method.getReturnType().isEnum()) {
					 printableType = Joiner.on("" | "").join(method.getReturnType().getEnumConstants());
				 }
				 out.format("" --%s=<%s>%n"", propertyName, printableType);
				 Optional<String> defaultValue = getDefaultValueFromAnnotation(method);
				 if (defaultValue.isPresent()) {
					 out.format("" Default: %s%n"", defaultValue.get());
				 }
				 prettyPrintDescription(out, method.getAnnotation(Description.class));
				 prettyPrintRequiredGroups( out, method.getAnnotation(Validation.Required.class), requiredGroupNameToProperties);
			 }
			 out.println();
		 }
	 }
	 private static final Set<Class<?>> JSON_INTEGER_TYPES = Sets.newHashSet( short.class, Short.class, int.class, Integer.class, long.class, Long.class, BigInteger.class);
	 private static final Set<Class<?>> JSON_NUMBER_TYPES = Sets.newHashSet( float.class, Float.class, double.class, Double.class, java.math.BigDecimal.class);
	 public static List<PipelineOptionDescriptor> describe( Set<Class<? extends PipelineOptions>> ifaces) {
		 checkNotNull(ifaces);
		 List<PipelineOptionDescriptor> result = new ArrayList<>();
		 Set<Method> seenMethods = Sets.newHashSet();
		 for (Class<? extends PipelineOptions> iface : ifaces) {
			 CACHE.get().validateWellFormed(iface);
			 Set<PipelineOptionSpec> properties = PipelineOptionsReflector.getOptionSpecs(iface);
			 RowSortedTable<Class<?>, String, Method> ifacePropGetterTable = TreeBasedTable.create(ClassNameComparator.INSTANCE, Ordering.natural());
			 for (PipelineOptionSpec prop : properties) {
				 ifacePropGetterTable.put( prop.getDefiningInterface(), prop.getName(), prop.getGetterMethod());
			 }
			 for (Map.Entry<Class<?>, Map<String, Method>> ifaceToPropertyMap : ifacePropGetterTable.rowMap().entrySet()) {
				 Class<?> currentIface = ifaceToPropertyMap.getKey();
				 Map<String, Method> propertyNamesToGetters = ifaceToPropertyMap.getValue();
				 List<String> lists = Lists.newArrayList(propertyNamesToGetters.keySet());
				 lists.sort(String.CASE_INSENSITIVE_ORDER);
				 for (String propertyName : lists) {
					 Method method = propertyNamesToGetters.get(propertyName);
					 if (!seenMethods.add(method)) {
						 continue;
					 }
					 Class<?> returnType = method.getReturnType();
					 PipelineOptionType.Enum optionType = PipelineOptionType.Enum.STRING;
					 if (JSON_INTEGER_TYPES.contains(returnType)) {
						 optionType = PipelineOptionType.Enum.INTEGER;
					 }
					 else if (JSON_NUMBER_TYPES.contains(returnType)) {
						 optionType = PipelineOptionType.Enum.NUMBER;
					 }
					 else if (returnType == boolean.class || returnType == Boolean.class) {
						 optionType = PipelineOptionType.Enum.BOOLEAN;
					 }
					 else if (List.class.isAssignableFrom(returnType)) {
						 optionType = PipelineOptionType.Enum.ARRAY;
					 }
					 String optionName = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, propertyName);
					 Description description = method.getAnnotation(Description.class);
					 PipelineOptionDescriptor.Builder builder = PipelineOptionDescriptor.newBuilder() .setName(optionName) .setType(optionType) .setGroup(currentIface.getName());
					 Optional<String> defaultValue = getDefaultValueFromAnnotation(method);
					 if (defaultValue.isPresent()) {
						 builder.setDefaultValue(defaultValue.get());
					 }
					 if (description != null) {
						 builder.setDescription(description.value());
					 }
					 result.add(builder.build());
				 }
			 }
		 }
		 return result;
	 }
	 private static void prettyPrintRequiredGroups( PrintStream out, Required annotation, SortedSetMultimap<String, String> requiredGroupNameToProperties) {
		 if (annotation == null || annotation.groups() == null) {
			 return;
		 }
		 for (String group : annotation.groups()) {
			 SortedSet<String> groupMembers = requiredGroupNameToProperties.get(group);
			 String requirement;
			 if (groupMembers.size() == 1) {
				 requirement = Iterables.getOnlyElement(groupMembers) + "" is required."";
			 }
			 else {
				 requirement = ""At least one of "" + groupMembers + "" is required"";
			 }
			 terminalPrettyPrint(out, requirement.split(""\\s+""));
		 }
	 }
	 private static void prettyPrintDescription(PrintStream out, Description description) {
		 if (description == null || description.value() == null) {
			 return;
		 }
		 String[] words = description.value().split(""\\s+"");
		 terminalPrettyPrint(out, words);
	 }
	 private static void terminalPrettyPrint(PrintStream out, String[] words) {
		 final String spacing = "" "";
		 if (words.length == 0) {
			 return;
		 }
		 out.print(spacing);
		 int lineLength = spacing.length();
		 for (int i = 0;
		 i < words.length;
		 ++i) {
			 out.print("" "");
			 out.print(words[i]);
			 lineLength += 1 + words[i].length();
			 if (i + 1 != words.length && words[i + 1].length() + lineLength + 1 > TERMINAL_WIDTH) {
				 out.println();
				 out.print(spacing);
				 lineLength = spacing.length();
			 }
		 }
		 out.println();
	 }
	 private static Optional<String> getDefaultValueFromAnnotation(Method method) {
		 for (Annotation annotation : method.getAnnotations()) {
			 if (annotation instanceof Default.Class) {
				 return Optional.of(((Default.Class) annotation).value().getSimpleName());
			 }
			 else if (annotation instanceof Default.String) {
				 return Optional.of(((Default.String) annotation).value());
			 }
			 else if (annotation instanceof Default.Boolean) {
				 return Optional.of(Boolean.toString(((Default.Boolean) annotation).value()));
			 }
			 else if (annotation instanceof Default.Character) {
				 return Optional.of(Character.toString(((Default.Character) annotation).value()));
			 }
			 else if (annotation instanceof Default.Byte) {
				 return Optional.of(Byte.toString(((Default.Byte) annotation).value()));
			 }
			 else if (annotation instanceof Default.Short) {
				 return Optional.of(Short.toString(((Default.Short) annotation).value()));
			 }
			 else if (annotation instanceof Default.Integer) {
				 return Optional.of(Integer.toString(((Default.Integer) annotation).value()));
			 }
			 else if (annotation instanceof Default.Long) {
				 return Optional.of(Long.toString(((Default.Long) annotation).value()));
			 }
			 else if (annotation instanceof Default.Float) {
				 return Optional.of(Float.toString(((Default.Float) annotation).value()));
			 }
			 else if (annotation instanceof Default.Double) {
				 return Optional.of(Double.toString(((Default.Double) annotation).value()));
			 }
			 else if (annotation instanceof Default.Enum) {
				 return Optional.of(((Default.Enum) annotation).value());
			 }
			 else if (annotation instanceof Default.InstanceFactory) {
				 return Optional.of(((Default.InstanceFactory) annotation).value().getSimpleName());
			 }
		 }
		 return Optional.absent();
	 }
	 static Map<String, Class<? extends PipelineRunner<?>>> getRegisteredRunners() {
		 return CACHE.get().supportedPipelineRunners;
	 }
	 private static List<PropertyDescriptor> getPropertyDescriptors( Set<Method> methods, Class<? extends PipelineOptions> beanClass) throws IntrospectionException {
		 SortedMap<String, Method> propertyNamesToGetters = new TreeMap<>();
		 for (Map.Entry<String, Method> entry : PipelineOptionsReflector.getPropertyNamesToGetters(methods).entries()) {
			 propertyNamesToGetters.put(entry.getKey(), entry.getValue());
		 }
		 List<PropertyDescriptor> descriptors = Lists.newArrayList();
		 List<TypeMismatch> mismatches = new ArrayList<>();
		 Set<String> usedDescriptors = Sets.newHashSet();
		 for (Method method : methods) {
			 String methodName = method.getName();
			 if (!methodName.startsWith(""set"") || method.getParameterTypes().length != 1 || method.getReturnType() != void.class) {
				 continue;
			 }
			 String propertyName = Introspector.decapitalize(methodName.substring(3));
			 Method getterMethod = propertyNamesToGetters.remove(propertyName);
			 if (getterMethod != null) {
				 Type getterPropertyType = getterMethod.getGenericReturnType();
				 Type setterPropertyType = method.getGenericParameterTypes()[0];
				 if (!getterPropertyType.equals(setterPropertyType)) {
					 TypeMismatch mismatch = new TypeMismatch();
					 mismatch.propertyName = propertyName;
					 mismatch.getterPropertyType = getterPropertyType;
					 mismatch.setterPropertyType = setterPropertyType;
					 mismatches.add(mismatch);
					 continue;
				 }
			 }
			 if (!usedDescriptors.contains(propertyName)) {
				 descriptors.add(new PropertyDescriptor(propertyName, getterMethod, method));
				 usedDescriptors.add(propertyName);
			 }
		 }
		 throwForTypeMismatches(mismatches);
		 for (Map.Entry<String, Method> getterToMethod : propertyNamesToGetters.entrySet()) {
			 descriptors.add( new PropertyDescriptor(getterToMethod.getKey(), getterToMethod.getValue(), null));
		 }
		 return descriptors;
	 }
	 private static class TypeMismatch {
		 private String propertyName;
		 private Type getterPropertyType;
		 private Type setterPropertyType;
	 }
	 private static void throwForTypeMismatches(List<TypeMismatch> mismatches) {
		 if (mismatches.size() == 1) {
			 TypeMismatch mismatch = mismatches.get(0);
			 throw new IllegalArgumentException( String.format( ""Type mismatch between getter and setter methods for property [%s]. "" + ""Getter is of type [%s] whereas setter is of type [%s]."", mismatch.propertyName, mismatch.getterPropertyType, mismatch.setterPropertyType));
		 }
		 else if (mismatches.size() > 1) {
			 StringBuilder builder = new StringBuilder(""Type mismatches between getters and setters detected:"");
			 for (TypeMismatch mismatch : mismatches) {
				 builder.append( String.format( ""%n - Property [%s]: Getter is of type [%s] whereas setter is of type [%s]."", mismatch.propertyName, mismatch.getterPropertyType.toString(), mismatch.setterPropertyType.toString()));
			 }
			 throw new IllegalArgumentException(builder.toString());
		 }
	 }
	 private static SortedSetMultimap<String, String> getRequiredGroupNamesToProperties( Map<String, Method> propertyNamesToGetters) {
		 SortedSetMultimap<String, String> result = TreeMultimap.create();
		 for (Map.Entry<String, Method> propertyEntry : propertyNamesToGetters.entrySet()) {
			 Required requiredAnnotation = propertyEntry.getValue().getAnnotation(Validation.Required.class);
			 if (requiredAnnotation != null) {
				 for (String groupName : requiredAnnotation.groups()) {
					 result.put(groupName, propertyEntry.getKey());
				 }
			 }
		 }
		 return result;
	 }
	 private static List<PropertyDescriptor> validateClass( Class<? extends PipelineOptions> iface, Set<Class<? extends PipelineOptions>> validatedPipelineOptionsInterfaces, Class<? extends PipelineOptions> klass) throws IntrospectionException {
		 if (!Modifier.isPublic(iface.getModifiers())) {
			 LOG.warn( ""Using non-public interface {
			}
			 may fail during runtime. The JVM requires that "" + ""all non-public interfaces to be in the same package;
			 otherwise, it would not be "" + ""possible for the PipelineOptions proxy class to implement all of the interfaces, "" + ""regardless of what package it is defined in. This will become an error in"" + ""a future version of Apache Beam."", iface.getName());
		 }
		 validateReturnType(iface);
		 SortedSet<Method> allInterfaceMethods = FluentIterable.from( ReflectHelpers.getClosureOfMethodsOnInterfaces(validatedPipelineOptionsInterfaces)) .append(ReflectHelpers.getClosureOfMethodsOnInterface(iface)) .filter(NOT_SYNTHETIC_PREDICATE) .filter(NOT_STATIC_PREDICATE) .toSortedSet(MethodComparator.INSTANCE);
		 List<PropertyDescriptor> descriptors = getPropertyDescriptors(allInterfaceMethods, iface);
		 validateMethodAnnotations(allInterfaceMethods, descriptors);
		 validateGettersSetters(iface, descriptors);
		 validateMethodsAreEitherBeanMethodOrKnownMethod(iface, klass, descriptors);
		 return descriptors;
	 }
	 private static void validateReturnType(Class<? extends PipelineOptions> iface) {
		 Iterable<Method> interfaceMethods = FluentIterable.from(ReflectHelpers.getClosureOfMethodsOnInterface(iface)) .filter(NOT_SYNTHETIC_PREDICATE) .toSortedSet(MethodComparator.INSTANCE);
		 SortedSetMultimap<Method, Method> methodNameToMethodMap = TreeMultimap.create(MethodNameComparator.INSTANCE, MethodComparator.INSTANCE);
		 for (Method method : interfaceMethods) {
			 methodNameToMethodMap.put(method, method);
		 }
		 List<MultipleDefinitions> multipleDefinitions = Lists.newArrayList();
		 for (Map.Entry<Method, Collection<Method>> entry : methodNameToMethodMap.asMap().entrySet()) {
			 Set<Class<?>> returnTypes = FluentIterable.from(entry.getValue()) .transform(ReturnTypeFetchingFunction.INSTANCE) .toSet();
			 SortedSet<Method> collidingMethods = FluentIterable.from(entry.getValue()).toSortedSet(MethodComparator.INSTANCE);
			 if (returnTypes.size() > 1) {
				 MultipleDefinitions defs = new MultipleDefinitions();
				 defs.method = entry.getKey();
				 defs.collidingMethods = collidingMethods;
				 multipleDefinitions.add(defs);
			 }
		 }
		 throwForMultipleDefinitions(iface, multipleDefinitions);
	 }
	 private static void validateMethodAnnotations( SortedSet<Method> allInterfaceMethods, List<PropertyDescriptor> descriptors) {
		 SortedSetMultimap<Method, Method> methodNameToAllMethodMap = TreeMultimap.create(MethodNameComparator.INSTANCE, MethodComparator.INSTANCE);
		 for (Method method : allInterfaceMethods) {
			 methodNameToAllMethodMap.put(method, method);
		 }
		 validateGettersHaveConsistentAnnotation( methodNameToAllMethodMap, descriptors, AnnotationPredicates.JSON_IGNORE);
		 validateGettersHaveConsistentAnnotation( methodNameToAllMethodMap, descriptors, AnnotationPredicates.DEFAULT_VALUE);
		 validateSettersDoNotHaveAnnotation( methodNameToAllMethodMap, descriptors, AnnotationPredicates.JSON_IGNORE);
		 validateSettersDoNotHaveAnnotation( methodNameToAllMethodMap, descriptors, AnnotationPredicates.DEFAULT_VALUE);
	 }
	 private static void validateGettersHaveConsistentAnnotation( SortedSetMultimap<Method, Method> methodNameToAllMethodMap, List<PropertyDescriptor> descriptors, final AnnotationPredicates annotationPredicates) {
		 List<InconsistentlyAnnotatedGetters> inconsistentlyAnnotatedGetters = new ArrayList<>();
		 for (final PropertyDescriptor descriptor : descriptors) {
			 if (descriptor.getReadMethod() == null || IGNORED_METHODS.contains(descriptor.getReadMethod())) {
				 continue;
			 }
			 SortedSet<Method> getters = methodNameToAllMethodMap.get(descriptor.getReadMethod());
			 SortedSet<Method> gettersWithTheAnnotation = Sets.filter(getters, annotationPredicates.forMethod);
			 Set<Annotation> distinctAnnotations = Sets.newLinkedHashSet( FluentIterable.from(gettersWithTheAnnotation) .transformAndConcat( new Function<Method, Iterable<? extends Annotation>>() {
				 public Iterable<? extends Annotation> apply( Method method) {
					 return FluentIterable.from(method.getAnnotations());
				 }
			 }
			) .filter(annotationPredicates.forAnnotation));
			 if (distinctAnnotations.size() > 1) {
				 throw new IllegalArgumentException( String.format( ""Property [%s] is marked with contradictory annotations. Found [%s]."", descriptor.getName(), FluentIterable.from(gettersWithTheAnnotation) .transformAndConcat( new Function<Method, Iterable<String>>() {
					 public Iterable<String> apply(final Method method) {
						 return FluentIterable.from(method.getAnnotations()) .filter(annotationPredicates.forAnnotation) .transform( new Function<Annotation, String>() {
							 public String apply( Annotation annotation) {
								 return String.format( ""[%s on %s]"", ReflectHelpers.ANNOTATION_FORMATTER.apply(annotation), ReflectHelpers.CLASS_AND_METHOD_FORMATTER.apply( method));
							 }
						 }
						);
					 }
				 }
				) .join(Joiner.on("", ""))));
			 }
			 Iterable<String> getterClassNames = FluentIterable.from(getters) .transform(MethodToDeclaringClassFunction.INSTANCE) .transform(ReflectHelpers.CLASS_NAME);
			 Iterable<String> gettersWithTheAnnotationClassNames = FluentIterable.from(gettersWithTheAnnotation) .transform(MethodToDeclaringClassFunction.INSTANCE) .transform(ReflectHelpers.CLASS_NAME);
			 if (!(gettersWithTheAnnotation.isEmpty() || getters.size() == gettersWithTheAnnotation.size())) {
				 InconsistentlyAnnotatedGetters err = new InconsistentlyAnnotatedGetters();
				 err.descriptor = descriptor;
				 err.getterClassNames = getterClassNames;
				 err.gettersWithTheAnnotationClassNames = gettersWithTheAnnotationClassNames;
				 inconsistentlyAnnotatedGetters.add(err);
			 }
		 }
		 throwForGettersWithInconsistentAnnotation( inconsistentlyAnnotatedGetters, annotationPredicates.annotationClass);
	 }
	 private static void validateSettersDoNotHaveAnnotation( SortedSetMultimap<Method, Method> methodNameToAllMethodMap, List<PropertyDescriptor> descriptors, AnnotationPredicates annotationPredicates) {
		 List<AnnotatedSetter> annotatedSetters = new ArrayList<>();
		 for (PropertyDescriptor descriptor : descriptors) {
			 if (descriptor.getWriteMethod() == null || IGNORED_METHODS.contains(descriptor.getWriteMethod())) {
				 continue;
			 }
			 SortedSet<Method> settersWithTheAnnotation = Sets.filter( methodNameToAllMethodMap.get(descriptor.getWriteMethod()), annotationPredicates.forMethod);
			 Iterable<String> settersWithTheAnnotationClassNames = FluentIterable.from(settersWithTheAnnotation) .transform(MethodToDeclaringClassFunction.INSTANCE) .transform(ReflectHelpers.CLASS_NAME);
			 if (!settersWithTheAnnotation.isEmpty()) {
				 AnnotatedSetter annotated = new AnnotatedSetter();
				 annotated.descriptor = descriptor;
				 annotated.settersWithTheAnnotationClassNames = settersWithTheAnnotationClassNames;
				 annotatedSetters.add(annotated);
			 }
		 }
		 throwForSettersWithTheAnnotation(annotatedSetters, annotationPredicates.annotationClass);
	 }
	 private static void validateGettersSetters( Class<? extends PipelineOptions> iface, List<PropertyDescriptor> descriptors) {
		 List<MissingBeanMethod> missingBeanMethods = new ArrayList<>();
		 for (PropertyDescriptor propertyDescriptor : descriptors) {
			 if (!(IGNORED_METHODS.contains(propertyDescriptor.getWriteMethod()) || propertyDescriptor.getReadMethod() != null)) {
				 MissingBeanMethod method = new MissingBeanMethod();
				 method.property = propertyDescriptor;
				 method.methodType = ""getter"";
				 missingBeanMethods.add(method);
				 continue;
			 }
			 if (!(IGNORED_METHODS.contains(propertyDescriptor.getReadMethod()) || propertyDescriptor.getWriteMethod() != null)) {
				 MissingBeanMethod method = new MissingBeanMethod();
				 method.property = propertyDescriptor;
				 method.methodType = ""setter"";
				 missingBeanMethods.add(method);
			 }
		 }
		 throwForMissingBeanMethod(iface, missingBeanMethods);
	 }
	 private static void validateMethodsAreEitherBeanMethodOrKnownMethod( Class<? extends PipelineOptions> iface, Class<? extends PipelineOptions> klass, List<PropertyDescriptor> descriptors) {
		 Set<Method> knownMethods = Sets.newHashSet(IGNORED_METHODS);
		 for (Method method : klass.getMethods()) {
			 if (Modifier.isStatic(method.getModifiers()) || method.isSynthetic()) {
				 knownMethods.add(method);
			 }
		 }
		 try {
			 knownMethods.add(iface.getMethod(""as"", Class.class));
			 knownMethods.add(iface.getMethod(""outputRuntimeOptions""));
			 knownMethods.add(iface.getMethod(""populateDisplayData"", DisplayData.Builder.class));
		 }
		 catch (NoSuchMethodException | SecurityException e) {
			 throw new RuntimeException(e);
		 }
		 for (PropertyDescriptor descriptor : descriptors) {
			 knownMethods.add(descriptor.getReadMethod());
			 knownMethods.add(descriptor.getWriteMethod());
		 }
		 final Set<String> knownMethodsNames = Sets.newHashSet();
		 for (Method method : knownMethods) {
			 knownMethodsNames.add(method.getName());
		 }
		 SortedSet<Method> unknownMethods = new TreeSet<>(MethodComparator.INSTANCE);
		 unknownMethods.addAll( Sets.filter( Sets.difference(Sets.newHashSet(iface.getMethods()), knownMethods), Predicates.and( NOT_SYNTHETIC_PREDICATE, input -> !knownMethodsNames.contains(input.getName()), NOT_STATIC_PREDICATE)));
		 checkArgument( unknownMethods.isEmpty(), ""Methods %s on [%s] do not conform to being bean properties."", FluentIterable.from(unknownMethods).transform(ReflectHelpers.METHOD_FORMATTER), iface.getName());
	 }
	 private static void checkInheritedFrom( Class<?> checkClass, Class fromClass, Set<Class<?>> nonPipelineOptions) {
		 if (checkClass.equals(fromClass)) {
			 return;
		 }
		 if (checkClass.getInterfaces().length == 0) {
			 nonPipelineOptions.add(checkClass);
			 return;
		 }
		 for (Class<?> klass : checkClass.getInterfaces()) {
			 checkInheritedFrom(klass, fromClass, nonPipelineOptions);
		 }
	 }
	 private static void throwNonPipelineOptions( Class<?> klass, Set<Class<?>> nonPipelineOptionsClasses) {
		 StringBuilder errorBuilder = new StringBuilder( String.format( ""All inherited interfaces of [%s] should inherit from the PipelineOptions interface. "" + ""The following inherited interfaces do not:"", klass.getName()));
		 for (Class<?> invalidKlass : nonPipelineOptionsClasses) {
			 errorBuilder.append(String.format(""%n - %s"", invalidKlass.getName()));
		 }
		 throw new IllegalArgumentException(errorBuilder.toString());
	 }
	 private static void validateInheritedInterfacesExtendPipelineOptions(Class<?> klass) {
		 Set<Class<?>> nonPipelineOptionsClasses = new LinkedHashSet<>();
		 checkInheritedFrom(klass, PipelineOptions.class, nonPipelineOptionsClasses);
		 if (!nonPipelineOptionsClasses.isEmpty()) {
			 throwNonPipelineOptions(klass, nonPipelineOptionsClasses);
		 }
	 }
	 private static class MultipleDefinitions {
		 private Method method;
		 private SortedSet<Method> collidingMethods;
	 }
	 private static void throwForMultipleDefinitions( Class<? extends PipelineOptions> iface, List<MultipleDefinitions> definitions) {
		 if (definitions.size() == 1) {
			 MultipleDefinitions errDef = definitions.get(0);
			 throw new IllegalArgumentException( String.format( ""Method [%s] has multiple definitions %s with different return types for [%s]."", errDef.method.getName(), errDef.collidingMethods, iface.getName()));
		 }
		 else if (definitions.size() > 1) {
			 StringBuilder errorBuilder = new StringBuilder( String.format( ""Interface [%s] has Methods with multiple definitions with different return types:"", iface.getName()));
			 for (MultipleDefinitions errDef : definitions) {
				 errorBuilder.append( String.format( ""%n - Method [%s] has multiple definitions %s"", errDef.method.getName(), errDef.collidingMethods));
			 }
			 throw new IllegalArgumentException(errorBuilder.toString());
		 }
	 }
	 private static class InconsistentlyAnnotatedGetters {
		 PropertyDescriptor descriptor;
		 Iterable<String> getterClassNames;
		 Iterable<String> gettersWithTheAnnotationClassNames;
	 }
	 private static void throwForGettersWithInconsistentAnnotation( List<InconsistentlyAnnotatedGetters> getters, Class<? extends Annotation> annotationClass) {
		 if (getters.size() == 1) {
			 InconsistentlyAnnotatedGetters getter = getters.get(0);
			 throw new IllegalArgumentException( String.format( ""Expected getter for property [%s] to be marked with @%s on all %s, "" + ""found only on %s"", getter.descriptor.getName(), annotationClass.getSimpleName(), getter.getterClassNames, getter.gettersWithTheAnnotationClassNames));
		 }
		 else if (getters.size() > 1) {
			 StringBuilder errorBuilder = new StringBuilder( String.format( ""Property getters are inconsistently marked with @%s:"", annotationClass.getSimpleName()));
			 for (InconsistentlyAnnotatedGetters getter : getters) {
				 errorBuilder.append( String.format( ""%n - Expected for property [%s] to be marked on all %s, "" + ""found only on %s"", getter.descriptor.getName(), getter.getterClassNames, getter.gettersWithTheAnnotationClassNames));
			 }
			 throw new IllegalArgumentException(errorBuilder.toString());
		 }
	 }
	 private static class AnnotatedSetter {
		 PropertyDescriptor descriptor;
		 Iterable<String> settersWithTheAnnotationClassNames;
	 }
	 private static void throwForSettersWithTheAnnotation( List<AnnotatedSetter> setters, Class<? extends Annotation> annotationClass) {
		 if (setters.size() == 1) {
			 AnnotatedSetter setter = setters.get(0);
			 throw new IllegalArgumentException( String.format( ""Expected setter for property [%s] to not be marked with @%s on %s"", setter.descriptor.getName(), annotationClass.getSimpleName(), setter.settersWithTheAnnotationClassNames));
		 }
		 else if (setters.size() > 1) {
			 StringBuilder builder = new StringBuilder( String.format(""Found setters marked with @%s:"", annotationClass.getSimpleName()));
			 for (AnnotatedSetter setter : setters) {
				 builder.append( String.format( ""%n - Setter for property [%s] should not be marked with @%s on %s"", setter.descriptor.getName(), annotationClass.getSimpleName(), setter.settersWithTheAnnotationClassNames));
			 }
			 throw new IllegalArgumentException(builder.toString());
		 }
	 }
	 private static class MissingBeanMethod {
		 String methodType;
		 PropertyDescriptor property;
	 }
	 private static void throwForMissingBeanMethod( Class<? extends PipelineOptions> iface, List<MissingBeanMethod> missingBeanMethods) {
		 if (missingBeanMethods.size() == 1) {
			 MissingBeanMethod missingBeanMethod = missingBeanMethods.get(0);
			 throw new IllegalArgumentException( String.format( ""Expected %s for property [%s] of type [%s] on [%s]."", missingBeanMethod.methodType, missingBeanMethod.property.getName(), missingBeanMethod.property.getPropertyType().getName(), iface.getName()));
		 }
		 else if (missingBeanMethods.size() > 1) {
			 StringBuilder builder = new StringBuilder( String.format(""Found missing property methods on [%s]:"", iface.getName()));
			 for (MissingBeanMethod method : missingBeanMethods) {
				 builder.append( String.format( ""%n - Expected %s for property [%s] of type [%s]"", method.methodType, method.property.getName(), method.property.getPropertyType().getName()));
			 }
			 throw new IllegalArgumentException(builder.toString());
		 }
	 }
	 private static class ClassNameComparator implements Comparator<Class<?>> {
		 static final ClassNameComparator INSTANCE = new ClassNameComparator();
		 public int compare(Class<?> o1, Class<?> o2) {
			 return o1.getName().compareTo(o2.getName());
		 }
	 }
	 private static class MethodComparator implements Comparator<Method> {
		 static final MethodComparator INSTANCE = new MethodComparator();
		 public int compare(Method o1, Method o2) {
			 return o1.toGenericString().compareTo(o2.toGenericString());
		 }
	 }
	 static class MethodNameComparator implements Comparator<Method> {
		 static final MethodNameComparator INSTANCE = new MethodNameComparator();
		 public int compare(Method o1, Method o2) {
			 return o1.getName().compareTo(o2.getName());
		 }
	 }
	 private static class ReturnTypeFetchingFunction implements Function<Method, Class<?>> {
		 static final ReturnTypeFetchingFunction INSTANCE = new ReturnTypeFetchingFunction();
		 public Class<?> apply(Method input) {
			 return input.getReturnType();
		 }
	 }
	 private static class MethodToDeclaringClassFunction implements Function<Method, Class<?>> {
		 static final MethodToDeclaringClassFunction INSTANCE = new MethodToDeclaringClassFunction();
		 public Class<?> apply(Method input) {
			 return input.getDeclaringClass();
		 }
	 }
	 static class AnnotationPredicates {
		 static final AnnotationPredicates JSON_IGNORE = new AnnotationPredicates( JsonIgnore.class, input -> JsonIgnore.class.equals(input.annotationType()), input -> input.isAnnotationPresent(JsonIgnore.class));
		 private static final Set<Class<?>> DEFAULT_ANNOTATION_CLASSES = Sets.newHashSet( FluentIterable.from(Default.class.getDeclaredClasses()).filter(Class::isAnnotation));
		 static final AnnotationPredicates DEFAULT_VALUE = new AnnotationPredicates( Default.class, input -> DEFAULT_ANNOTATION_CLASSES.contains(input.annotationType()), input -> {
			 for (Annotation annotation : input.getAnnotations()) {
				 if (DEFAULT_ANNOTATION_CLASSES.contains(annotation.annotationType())) {
					 return true;
				 }
			 }
			 return false;
		 }
		);
		 final Class<? extends Annotation> annotationClass;
		 final Predicate<Annotation> forAnnotation;
		 final Predicate<Method> forMethod;
		 AnnotationPredicates( Class<? extends Annotation> annotationClass, Predicate<Annotation> forAnnotation, Predicate<Method> forMethod) {
			 this.annotationClass = annotationClass;
			 this.forAnnotation = forAnnotation;
			 this.forMethod = forMethod;
		 }
	 }
	 private static ListMultimap<String, String> parseCommandLine( String[] args, boolean strictParsing) {
		 ImmutableListMultimap.Builder<String, String> builder = ImmutableListMultimap.builder();
		 for (String arg : args) {
			 if (Strings.isNullOrEmpty(arg)) {
				 continue;
			 }
			 try {
				 checkArgument(arg.startsWith(""--""), ""Argument '%s' does not begin with '--'"", arg);
				 int index = arg.indexOf('=');
				 checkArgument( index != 2, ""Argument '%s' starts with '--=', empty argument name not allowed"", arg);
				 if (index > 0) {
					 builder.put(arg.substring(2, index), arg.substring(index + 1, arg.length()));
				 }
				 else {
					 builder.put(arg.substring(2), ""true"");
				 }
			 }
			 catch (IllegalArgumentException e) {
				 if (strictParsing) {
					 throw e;
				 }
				 else {
					 LOG.warn( ""Strict parsing is disabled, ignoring option '{
					}
					' because {
					}
					"", arg, e.getMessage());
				 }
			 }
		 }
		 return builder.build();
	 }
	 private static <T extends PipelineOptions> Map<String, Object> parseObjects( Class<T> klass, ListMultimap<String, String> options, boolean strictParsing) {
		 Map<String, Method> propertyNamesToGetters = Maps.newHashMap();
		 Cache cache = CACHE.get();
		 cache.validateWellFormed(klass);
		 Iterable<PropertyDescriptor> propertyDescriptors = cache.getPropertyDescriptors( FluentIterable.from(getRegisteredOptions()).append(klass).toSet());
		 for (PropertyDescriptor descriptor : propertyDescriptors) {
			 propertyNamesToGetters.put(descriptor.getName(), descriptor.getReadMethod());
		 }
		 Map<String, Object> convertedOptions = Maps.newHashMap();
		 for (final Map.Entry<String, Collection<String>> entry : options.asMap().entrySet()) {
			 try {
				 if (!propertyNamesToGetters.containsKey(entry.getKey())) {
					 SortedSet<String> closestMatches = new TreeSet<>( Sets.filter( propertyNamesToGetters.keySet(), input -> StringUtils.getLevenshteinDistance(entry.getKey(), input) <= 2));
					 switch (closestMatches.size()) {
						 case 0: throw new IllegalArgumentException( String.format(""Class %s missing a property named '%s'."", klass, entry.getKey()));
						 case 1: throw new IllegalArgumentException( String.format( ""Class %s missing a property named '%s'. Did you mean '%s'?"", klass, entry.getKey(), Iterables.getOnlyElement(closestMatches)));
						 default: throw new IllegalArgumentException( String.format( ""Class %s missing a property named '%s'. Did you mean one of %s?"", klass, entry.getKey(), closestMatches));
					 }
				 }
				 Method method = propertyNamesToGetters.get(entry.getKey());
				 Class<?> returnType = method.getReturnType();
				 JavaType type = MAPPER.getTypeFactory().constructType(method.getGenericReturnType());
				 if (""runner"".equals(entry.getKey())) {
					 String runner = Iterables.getOnlyElement(entry.getValue());
					 final Map<String, Class<? extends PipelineRunner<?>>> pipelineRunners = cache.supportedPipelineRunners;
					 if (pipelineRunners.containsKey(runner.toLowerCase())) {
						 convertedOptions.put(""runner"", pipelineRunners.get(runner.toLowerCase(ROOT)));
					 }
					 else {
						 try {
							 Class<?> runnerClass = Class.forName(runner, true, ReflectHelpers.findClassLoader());
							 if (!PipelineRunner.class.isAssignableFrom(runnerClass)) {
								 throw new IllegalArgumentException( String.format( ""Class '%s' does not implement PipelineRunner. "" + ""Supported pipeline runners %s"", runner, cache.getSupportedRunners()));
							 }
							 convertedOptions.put(""runner"", runnerClass);
						 }
						 catch (ClassNotFoundException e) {
							 String msg = String.format( ""Unknown 'runner' specified '%s', supported pipeline runners %s"", runner, cache.getSupportedRunners());
							 throw new IllegalArgumentException(msg, e);
						 }
					 }
				 }
				 else if (isCollectionOrArrayOfAllowedTypes(returnType, type)) {
					 List<String> values = FluentIterable.from(entry.getValue()) .transformAndConcat(input -> Arrays.asList(input.split("",""))) .toList();
					 if (values.contains("""")) {
						 checkEmptyStringAllowed(returnType, type, method.getGenericReturnType().toString());
					 }
					 convertedOptions.put(entry.getKey(), MAPPER.convertValue(values, type));
				 }
				 else if (isSimpleType(returnType, type)) {
					 String value = Iterables.getOnlyElement(entry.getValue());
					 if (value.isEmpty()) {
						 checkEmptyStringAllowed(returnType, type, method.getGenericReturnType().toString());
					 }
					 convertedOptions.put(entry.getKey(), MAPPER.convertValue(value, type));
				 }
				 else {
					 String value = Iterables.getOnlyElement(entry.getValue());
					 if (value.isEmpty()) {
						 checkEmptyStringAllowed(returnType, type, method.getGenericReturnType().toString());
					 }
					 try {
						 convertedOptions.put(entry.getKey(), MAPPER.readValue(value, type));
					 }
					 catch (IOException e) {
						 throw new IllegalArgumentException(""Unable to parse JSON value "" + value, e);
					 }
				 }
			 }
			 catch (IllegalArgumentException e) {
				 if (strictParsing) {
					 throw e;
				 }
				 else {
					 LOG.warn( ""Strict parsing is disabled, ignoring option '{
					}
					' with value '{
					}
					' because {
					}
					"", entry.getKey(), entry.getValue(), e.getMessage());
				 }
			 }
		 }
		 return convertedOptions;
	 }
	 private static boolean isSimpleType(Class<?> type, JavaType genericType) {
		 Class<?> unwrappedType = type.equals(ValueProvider.class) ? genericType.containedType(0).getRawClass() : type;
		 return SIMPLE_TYPES.contains(unwrappedType) || unwrappedType.isEnum();
	 }
	 private static boolean isCollectionOrArrayOfAllowedTypes(Class<?> type, JavaType genericType) {
		 JavaType containerType = type.equals(ValueProvider.class) ? genericType.containedType(0) : genericType;
		 if (containerType.getRawClass().isArray() && (SIMPLE_TYPES.contains(containerType.getRawClass().getComponentType()) || containerType.getRawClass().getComponentType().isEnum())) {
			 return true;
		 }
		 if (Collection.class.isAssignableFrom(containerType.getRawClass())) {
			 JavaType innerType = containerType.containedType(0);
			 if (innerType == null || SIMPLE_TYPES.contains(innerType.getRawClass()) || innerType.getRawClass().isEnum()) {
				 return true;
			 }
		 }
		 return false;
	 }
	 private static void checkEmptyStringAllowed( Class<?> type, JavaType genericType, String genericTypeName) {
		 JavaType unwrappedType = type.equals(ValueProvider.class) ? genericType.containedType(0) : genericType;
		 Class<?> containedType = unwrappedType.getRawClass();
		 if (unwrappedType.getRawClass().isArray()) {
			 containedType = unwrappedType.getRawClass().getComponentType();
		 }
		 else if (Collection.class.isAssignableFrom(unwrappedType.getRawClass())) {
			 JavaType innerType = unwrappedType.containedType(0);
			 containedType = innerType == null ? String.class : innerType.getRawClass();
		 }
		 if (!containedType.equals(String.class)) {
			 String msg = String.format( ""Empty argument value is only allowed for String, String Array, "" + ""Collections of Strings or any of these types in a parameterized ValueProvider, "" + ""but received: %s"", genericTypeName);
			 throw new IllegalArgumentException(msg);
		 }
	 }
	 static final class Cache {
		 private final Map<String, Class<? extends PipelineRunner<?>>> supportedPipelineRunners;
		 private final Set<Class<? extends PipelineOptions>> registeredOptions = Sets.newConcurrentHashSet();
		 private final Map<Class<? extends PipelineOptions>, Registration<?>> interfaceCache = Maps.newConcurrentMap();
		 private final Map<Set<Class<? extends PipelineOptions>>, Registration<?>> combinedCache = Maps.newConcurrentMap();
		 private Cache() {
			 final ClassLoader loader = ReflectHelpers.findClassLoader();
			 Set<PipelineRunnerRegistrar> pipelineRunnerRegistrars = Sets.newTreeSet(ReflectHelpers.ObjectsClassComparator.INSTANCE);
			 pipelineRunnerRegistrars.addAll( Lists.newArrayList(ServiceLoader.load(PipelineRunnerRegistrar.class, loader)));
			 ImmutableMap.Builder<String, Class<? extends PipelineRunner<?>>> builder = ImmutableMap.builder();
			 for (PipelineRunnerRegistrar registrar : pipelineRunnerRegistrars) {
				 for (Class<? extends PipelineRunner<?>> klass : registrar.getPipelineRunners()) {
					 String runnerName = klass.getSimpleName().toLowerCase();
					 builder.put(runnerName, klass);
					 if (runnerName.endsWith(""runner"")) {
						 builder.put(runnerName.substring(0, runnerName.length() - ""Runner"".length()), klass);
					 }
				 }
			 }
			 supportedPipelineRunners = builder.build();
			 initializeRegistry(loader);
		 }
		 private void initializeRegistry(final ClassLoader loader) {
			 register(PipelineOptions.class);
			 Set<PipelineOptionsRegistrar> pipelineOptionsRegistrars = Sets.newTreeSet(ReflectHelpers.ObjectsClassComparator.INSTANCE);
			 pipelineOptionsRegistrars.addAll( Lists.newArrayList(ServiceLoader.load(PipelineOptionsRegistrar.class, loader)));
			 for (PipelineOptionsRegistrar registrar : pipelineOptionsRegistrars) {
				 for (Class<? extends PipelineOptions> klass : registrar.getPipelineOptions()) {
					 register(klass);
				 }
			 }
		 }
		 private synchronized void register(Class<? extends PipelineOptions> iface) {
			 checkNotNull(iface);
			 checkArgument(iface.isInterface(), ""Only interface types are supported."");
			 if (registeredOptions.contains(iface)) {
				 return;
			 }
			 validateWellFormed(iface);
			 registeredOptions.add(iface);
		 }
		 private <T extends PipelineOptions> Registration<T> validateWellFormed(Class<T> iface) {
			 return validateWellFormed(iface, registeredOptions);
		 }
		 Set<String> getSupportedRunners() {
			 ImmutableSortedSet.Builder<String> supportedRunners = ImmutableSortedSet.naturalOrder();
			 for (Class<? extends PipelineRunner<?>> runner : supportedPipelineRunners.values()) {
				 supportedRunners.add(runner.getSimpleName());
			 }
			 return supportedRunners.build();
		 }
		 Map<String, Class<? extends PipelineRunner<?>>> getSupportedPipelineRunners() {
			 return supportedPipelineRunners;
		 }
		 synchronized <T extends PipelineOptions> Registration<T> validateWellFormed( Class<T> iface, Set<Class<? extends PipelineOptions>> validatedPipelineOptionsInterfaces) {
			 checkArgument(iface.isInterface(), ""Only interface types are supported."");
			 validateInheritedInterfacesExtendPipelineOptions(iface);
			 Set<Class<? extends PipelineOptions>> combinedPipelineOptionsInterfaces = FluentIterable.from(validatedPipelineOptionsInterfaces).append(iface).toSet();
			 if (!combinedCache.containsKey(combinedPipelineOptionsInterfaces)) {
				 final Class<?>[] interfaces = combinedPipelineOptionsInterfaces.toArray(EMPTY_CLASS_ARRAY);
				 Class<T> allProxyClass = (Class<T>) Proxy.getProxyClass(ReflectHelpers.findClassLoader(interfaces), interfaces);
				 try {
					 List<PropertyDescriptor> propertyDescriptors = validateClass(iface, validatedPipelineOptionsInterfaces, allProxyClass);
					 combinedCache.put( combinedPipelineOptionsInterfaces, new Registration<>(allProxyClass, propertyDescriptors));
				 }
				 catch (IntrospectionException e) {
					 throw new RuntimeException(e);
				 }
			 }
			 if (!interfaceCache.containsKey(iface)) {
				 Class<T> proxyClass = (Class<T>) Proxy.getProxyClass(ReflectHelpers.findClassLoader(iface), new Class[] {
				iface}
				);
				 try {
					 List<PropertyDescriptor> propertyDescriptors = validateClass(iface, validatedPipelineOptionsInterfaces, proxyClass);
					 interfaceCache.put(iface, new Registration<>(proxyClass, propertyDescriptors));
				 }
				 catch (IntrospectionException e) {
					 throw new RuntimeException(e);
				 }
			 }
			 Registration<T> result = (Registration<T>) interfaceCache.get(iface);
			 return result;
		 }
		 List<PropertyDescriptor> getPropertyDescriptors( Set<Class<? extends PipelineOptions>> interfaces) {
			 return combinedCache.get(interfaces).getPropertyDescriptors();
		 }
	 }
}",1,0,0,0
"public void main(List<JCCompilationUnit> trees) {
	 timer.startTask(""prepareForTypeChecking"");
	 prepareForTypeChecking(trees);
	 timer.endTask();
	 List<JCCompilationUnit> javaTrees = List.nil();
	 List<JCCompilationUnit> ceylonTrees = List.nil();
	 for(JCCompilationUnit tree : trees){
		 if(tree instanceof CeylonCompilationUnit) ceylonTrees = ceylonTrees.prepend(tree);
		 else javaTrees = javaTrees.prepend(tree);
	 }
	 timer.startTask(""Enter on Java trees"");
	 boolean needsModelReset = isBootstrap;
	 if(!javaTrees.isEmpty()){
		 setupImportedPackagesForJavaTrees(javaTrees);
		 hasJavaAndCeylonSources = true;
		 needsModelReset = true;
	 }
	 if(!compiler.isAddModuleTrees()){
		 setupImportedPackagesForJavaTrees(ceylonTrees);
	 }
	 if(isBootstrap || hasJavaAndCeylonSources){
		 super.main(trees);
	 }
	 List<JCCompilationUnit> packageInfo = completeCeylonTrees(trees);
	 trees = trees.prependList(packageInfo);
	 ceylonTrees = ceylonTrees.prependList(packageInfo);
	 if(compiler.isHadRunTwiceException()){
		 needsModelReset = true;
	 }
	 if(needsModelReset){
		 resetAndRunEnterAgain(trees);
	 }
	else{
		 timer.startTask(""Enter on Ceylon trees"");
		 try {
			 sourceLanguage.push(Language.CEYLON);
			 super.main(ceylonTrees);
		 }
		 finally {
			 sourceLanguage.pop();
		 }
		 timer.endTask();
	 }
 }",0,0,1,0
"public static String shortenDbName(String dbName, int desiredLength) {
	 StringBuilder dbBuf = new StringBuilder(dbName);
	 if (dbBuf.length() > desiredLength) {
		 for (int i = dbBuf.length() - 1;
		 i > 0;
		 i--) {
			 if (dbBuf.charAt(i - 1) == '_') {
				 continue;
			 }
			 char curChar = dbBuf.charAt(i);
			 if (vowelBag.indexOf(curChar) > 0) {
				 dbBuf.deleteCharAt(i);
			 }
		 }
	 }
	 while (dbBuf.indexOf(""__"") > 0) {
		 dbBuf.deleteCharAt(dbBuf.indexOf(""__""));
	 }
	 while (dbBuf.length() > desiredLength) {
		 boolean removedChars = false;
		 int usIndex = dbBuf.lastIndexOf(""_"");
		 while (usIndex > 0 && dbBuf.length() > desiredLength) {
			 int prevUsIndex = dbBuf.lastIndexOf(""_"", usIndex - 1);
			 if (prevUsIndex < 0 && usIndex < 4) {
				 break;
			 }
			 if (prevUsIndex >= 0 && (usIndex - prevUsIndex) <= 4) {
				 usIndex = prevUsIndex;
				 continue;
			 }
			 dbBuf.deleteCharAt(usIndex - 2);
			 removedChars = true;
			 if (usIndex > 2) {
				 usIndex = dbBuf.lastIndexOf(""_"", usIndex - 2);
			 }
			 else {
				 break;
			 }
		 }
		 if (dbBuf.length() > desiredLength) {
			 int removeIndex = dbBuf.length() - 1;
			 int prevRemoveIndex = dbBuf.lastIndexOf(""_"", removeIndex - 1);
			 if (prevRemoveIndex < 0 || (removeIndex - prevRemoveIndex) >= 3) {
				 dbBuf.deleteCharAt(removeIndex - 1);
				 removedChars = true;
			 }
		 }
		 while (dbBuf.indexOf(""__"") > 0) {
			 dbBuf.deleteCharAt(dbBuf.indexOf(""__""));
			 removedChars = true;
		 }
		 if (!removedChars) {
			 break;
		 }
	 }
	 while (dbBuf.indexOf(""__"") > 0) {
		 dbBuf.deleteCharAt(dbBuf.indexOf(""__""));
	 }
	 while (dbBuf.length() > desiredLength) {
		 int firstUs = dbBuf.indexOf(""_"");
		 if (firstUs > 0) {
			 int nextUs = dbBuf.indexOf(""_"", firstUs + 1);
			 if (nextUs > 0) {
				 dbBuf.delete(firstUs, nextUs);
			 }
		 }
	 }
	 return dbBuf.toString();
 }",0,0,1,0
"public class ary {
	 public static void main(String args[]) {
		 int i, j, k, n = Integer.parseInt(args[0]);
		 int x[] = new int[n];
		 int y[] = new int[n];
		 for (i = 0;
		 i < n;
		 i++) x[i] = i + 1;
		 for (k = 0;
		 k < 1000;
		 k++ ) for (j = n-1;
		 j >= 0;
		 j--) y[j] += x[j];
		 System.out.println(y[0] + "" "" + y[n-1]);
	 }
}",0,0,0,0
"public class ByteValueParser extends FieldParser<ByteValue> {
	private ByteValue result;
	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, ByteValue reusable) {
		if (startPos == limit) {
			setErrorState(ParseErrorState.EMPTY_COLUMN);
			return -1;
		}
		int val = 0;
		boolean neg = false;
		this.result = reusable;
		final int delimLimit = limit - delimiter.length + 1;
		if (bytes[startPos] == '-') {
			neg = true;
			startPos++;
			if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
				return -1;
			}
		}
		for (int i = startPos;
		 i < limit;
		 i++) {
			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
				if (i == startPos) {
					setErrorState(ParseErrorState.EMPTY_COLUMN);
					return -1;
				}
				reusable.setValue((byte) (neg ? -val : val));
				return i + delimiter.length;
			}
			if (bytes[i] < 48 || bytes[i] > 57) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_ILLEGAL_CHARACTER);
				return -1;
			}
			val *= 10;
			val += bytes[i] - 48;
			if (val > Byte.MAX_VALUE && (!neg || val > -Byte.MIN_VALUE)) {
				setErrorState(ParseErrorState.NUMERIC_VALUE_OVERFLOW_UNDERFLOW);
				return -1;
			}
		}
		reusable.setValue((byte) (neg ? -val : val));
		return limit;
	}
	public ByteValue createValue() {
		return new ByteValue();
	}
	public ByteValue getLastResult() {
		return this.result;
	}
}",1,1,0,0
"public int run(String[] args) throws Exception {
	 if (args.length < 1) {
		 System.out.println (""Usage: Crawl <urlDir> -solr <solrURL> [-dir d] [-threads n] [-depth i] [-topN N]"");
		 return -1;
	 }
	 Path rootUrlDir = null;
	 Path dir = new Path(""crawl-"" + getDate());
	 int threads = getConf().getInt(""fetcher.threads.fetch"", 10);
	 int depth = 5;
	 long topN = Long.MAX_VALUE;
	 String solrUrl = null;
	 for (int i = 0;
	 i < args.length;
	 i++) {
		 if (""-dir"".equals(args[i])) {
			 dir = new Path(args[i+1]);
			 i++;
		 }
		 else if (""-threads"".equals(args[i])) {
			 threads = Integer.parseInt(args[i+1]);
			 i++;
		 }
		 else if (""-depth"".equals(args[i])) {
			 depth = Integer.parseInt(args[i+1]);
			 i++;
		 }
		 else if (""-topN"".equals(args[i])) {
			 topN = Integer.parseInt(args[i+1]);
			 i++;
		 }
		 else if (""-solr"".equals(args[i])) {
			 solrUrl = StringUtils.lowerCase(args[i + 1]);
			 i++;
		 }
		 else if (args[i] != null) {
			 rootUrlDir = new Path(args[i]);
		 }
	 }
	 JobConf job = new NutchJob(getConf());
	 if (solrUrl == null) {
		 LOG.warn(""solrUrl is not set, indexing will be skipped..."");
	 }
	 FileSystem fs = FileSystem.get(job);
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""crawl started in: "" + dir);
		 LOG.info(""rootUrlDir = "" + rootUrlDir);
		 LOG.info(""threads = "" + threads);
		 LOG.info(""depth = "" + depth);
		 LOG.info(""solrUrl="" + solrUrl);
		 if (topN != Long.MAX_VALUE) LOG.info(""topN = "" + topN);
	 }
	 Path crawlDb = new Path(dir + ""/crawldb"");
	 Path linkDb = new Path(dir + ""/linkdb"");
	 Path segments = new Path(dir + ""/segments"");
	 Path indexes = new Path(dir + ""/indexes"");
	 Path index = new Path(dir + ""/index"");
	 Path tmpDir = job.getLocalPath(""crawl""+Path.SEPARATOR+getDate());
	 Injector injector = new Injector(getConf());
	 Generator generator = new Generator(getConf());
	 Fetcher fetcher = new Fetcher(getConf());
	 ParseSegment parseSegment = new ParseSegment(getConf());
	 CrawlDb crawlDbTool = new CrawlDb(getConf());
	 LinkDb linkDbTool = new LinkDb(getConf());
	 injector.inject(crawlDb, rootUrlDir);
	 int i;
	 for (i = 0;
	 i < depth;
	 i++) {
		 Path[] segs = generator.generate(crawlDb, segments, -1, topN, System .currentTimeMillis());
		 if (segs == null) {
			 LOG.info(""Stopping at depth="" + i + "" - no more URLs to fetch."");
			 break;
		 }
		 fetcher.fetch(segs[0], threads);
		 if (!Fetcher.isParsing(job)) {
			 parseSegment.parse(segs[0]);
		 }
		 crawlDbTool.update(crawlDb, segs, true, true);
	 }
	 if (i > 0) {
		 linkDbTool.invert(linkDb, segments, true, true, false);
		 if (solrUrl != null) {
			 FileStatus[] fstats = fs.listStatus(segments, HadoopFSUtil.getPassDirectoriesFilter(fs));
			 SolrIndexer indexer = new SolrIndexer(getConf());
			 indexer.indexSolr(solrUrl, crawlDb, linkDb, Arrays.asList(HadoopFSUtil.getPaths(fstats)));
			 SolrDeleteDuplicates dedup = new SolrDeleteDuplicates();
			 dedup.setConf(getConf());
			 dedup.dedup(solrUrl);
		 }
	 }
	 else {
		 LOG.warn(""No URLs to fetch - check your seed list and URL filters."");
	 }
	 if (LOG.isInfoEnabled()) {
		 LOG.info(""crawl finished: "" + dir);
	 }
	 return 0;
 }",0,0,0,0
"public boolean forEachIndexFromToInState(int from, int to, boolean state, IntProcedure procedure) {
	if (nbits==0) return true;
	checkRangeFromTo(from, to, nbits);
	final long[] theBits = this.bits;
	 final int bitsPerUnit = QuickBitVector.BITS_PER_UNIT;
	int fromUnit = QuickBitVector.unit(from);
	int toUnit = QuickBitVector.unit(to);
	int i = from;
	 int bitIndex = QuickBitVector.offset(from);
	int partialWidth;
	if (bitIndex>0) {
		 partialWidth = Math.min(to-from+1, bitsPerUnit - bitIndex);
		for (;
		 --partialWidth >= 0;
		 i++) {
			if (QuickBitVector.get(theBits,i)==state) {
				if (!procedure.apply(i)) return false;
			}
		}
		fromUnit++;
	 }
	if (i>to) return true;
	 bitIndex = QuickBitVector.offset(to);
	if (bitIndex < bitsPerUnit-1) {
		toUnit--;
		 partialWidth = bitIndex + 1;
	}
	else {
		partialWidth = 0;
	}
	long comparator;
	if (state) comparator = 0L;
	else comparator = ~0L;
	 for (int unit=fromUnit;
	 unit<=toUnit;
	 unit++) {
		long val = theBits[unit];
		if (val != comparator) {
			 if (state) {
				for (int j=0, k=bitsPerUnit;
				 --k >= 0;
				 i++) {
					 if ((val & (1L << j++)) != 0L) {
						 if (!procedure.apply(i)) return false;
					}
				}
			}
			else {
				for (int j=0, k=bitsPerUnit;
				 --k >= 0;
				 i++) {
					 if ((val & (1L << j++)) == 0L) {
						 if (!procedure.apply(i)) return false;
					}
				}
			}
		}
		else {
			i += bitsPerUnit;
		}
	}
	for (;
	 --partialWidth >= 0;
	 i++) {
		if (QuickBitVector.get(theBits,i)==state) {
			if (!procedure.apply(i)) return false;
		}
	}
	return true;
}",0,0,1,0
"public class ConversionException extends WicketRuntimeException{
	private static final long serialVersionUID = 1L;
	private transient IConverter converter;
	private transient Format format;
	private transient Locale locale;
	private transient Object sourceValue;
	private transient String targetTypeName;
	private transient String resourceKey;
	private transient Map<String, Object> vars;
	public ConversionException(String message){
		super(message);
	}
	public ConversionException(String message, Throwable cause){
		super(message, cause);
	}
	public ConversionException(Throwable cause){
		super(cause);
	}
	public final IConverter getConverter(){
		return converter;
	}
	public final Format getFormat(){
		return format;
	}
	public final Locale getLocale(){
		return locale;
	}
	public final Object getSourceValue(){
		return sourceValue;
	}
	public final Class<?> getTargetType(){
		return Classes.resolveClass(targetTypeName);
	}
	public final ConversionException setConverter(IConverter converter){
		this.converter = converter;
		return this;
	}
	public final ConversionException setFormat(Format format){
		this.format = format;
		return this;
	}
	public final ConversionException setLocale(Locale locale){
		this.locale = locale;
		return this;
	}
	public final ConversionException setSourceValue(Object sourceValue){
		this.sourceValue = sourceValue;
		return this;
	}
	public final ConversionException setTargetType(Class<?> targetType){
		targetTypeName = targetType.getName();
		return this;
	}
	public String getResourceKey(){
		return resourceKey;
	}
	public ConversionException setResourceKey(String resourceKey){
		this.resourceKey = resourceKey;
		return this;
	}
	public ConversionException setVariable(String name, Object value){
		if (name == null || name.trim().length() == 0){
			throw new IllegalArgumentException(""Argument [[name]] cannot be null or an empty string"");
		}
		if (value == null){
			throw new IllegalArgumentException(""Argument [[value]] cannot be null or an empty string"");
		}
		if (vars == null){
			vars = new HashMap<String, Object>(2);
		}
		vars.put(name, value);
		return this;
	}
	public Map<String, Object> getVariables(){
		return vars;
	}
}",0,0,0,0
protected void flushBuffer() throws IOException;,0,0,0,0
"public final boolean isSessionInvalidated(){
	return sessionInvalidated;
}",0,0,0,0
"public class CandidateImpl extends LinkedHashMap implements Candidate {
	 private static final long serialVersionUID = 2617438257089193692L;
}",0,0,0,0
"private final int jjMoveStringLiteralDfa6_0(long old0, long active0){
	 if (((active0 &= old0)) == 0L) return jjStartNfa_0(4, old0);
	 try {
		 curChar = input_stream.readChar();
	 }
	 catch(java.io.IOException e) {
		 jjStopStringLiteralDfa_0(5, active0);
		 return 6;
	 }
	 switch(curChar) {
		 case 67: case 99: return jjMoveStringLiteralDfa7_0(active0, 0x1000L);
		 case 72: case 104: if ((active0 & 0x400L) != 0L) return jjStopAtPos(6, 10);
		 break;
		 case 80: case 112: return jjMoveStringLiteralDfa7_0(active0, 0x4000L);
		 default : break;
	 }
	 return jjStartNfa_0(5, active0);
}",0,0,0,0
"public long getBlockSize() {
	 if (blocks == null || blocks.length == 0) {
		 return 0;
	 }
	 else {
		 return blocks[0].getNumBytes();
	 }
 }
 public long getBlockSize(String filename) throws IOException {
	 synchronized (rootDir) {
		 INode fileNode = rootDir.getNode(filename);
		 if (fileNode == null) {
			 throw new IOException(""Unknown file: "" + filename);
		 }
		 if (fileNode.isDir()) {
			 throw new IOException(""Getting block size of a directory: "" + filename);
		 }
		 return fileNode.getBlockSize();
	 }
 }",0,0,0,0
"private static Object [] interpOneAxis(MeshVertex v[][], float s[], double param[][][], boolean closed, double tol) {
	 boolean refine[], newrefine[];
	 float news[];
	 int numParam = param[0][0].length;
	 double paramTemp[] = new double [numParam], newparam[][][];
	 Vec3 temp;
	 MeshVertex newv[][];
	 int i, j, k, count, p1, p3, p4;
	 double tol2 = tol*tol;
	 if (closed) refine = new boolean [v[0].length];
	 else refine = new boolean [v[0].length-1];
	 for (i = 0;
	 i < refine.length;
	 i++) refine[i] = true;
	 count = refine.length;
	 int iterations = 0;
	 do {
		 newrefine = new boolean [refine.length+count];
		 newv = new MeshVertex [v.length][v[0].length+count];
		 news = new float [v[0].length+count];
		 newparam = new double [v.length][v[0].length+count][numParam];
		 for (i = 0, k = 0;
		 i < refine.length;
		 i++) {
			 for (j = 0;
			 j < v.length;
			 j++) {
				 newv[j][k] = v[j][i];
				 newparam[j][k] = param[j][i];
			 }
			 news[k] = Math.min(s[i]*2.0f, 1.0f);
			 k++;
			 if (refine[i]) {
				 p1 = i-1;
				 if (p1 < 0) {
					 if (closed) p1 = v[0].length-1;
					 else p1 = 0;
				 }
				 p3 = i+1;
				 if (p3 == v[0].length) {
					 if (closed) p3 = 0;
					 else p3 = v[0].length-1;
				 }
				 p4 = i+2;
				 if (p4 >= v[0].length) {
					 if (closed) p4 %= v[0].length;
					 else p4 = v[0].length-1;
				 }
				 for (j = 0;
				 j < v.length;
				 j++) {
					 newv[j][k] = calcInterpPoint(v[j], s, param[j], paramTemp, p1, i, p3, p4);
					 for (int m = 0;
					 m < numParam;
					 m++) newparam[j][k][m] = paramTemp[m];
					 if (v[j][i].r.distance2(newv[j][k].r) > tol2 && v[j][p3].r.distance2(newv[j][k].r) > tol2) {
						 temp = v[j][i].r.plus(v[j][p3].r).times(0.5);
						 if (temp.distance2(newv[j][k].r) > tol2) newrefine[k] = newrefine[(k-1+newrefine.length)%newrefine.length] = true;
					 }
				 }
				 news[k] = 1.0f;
				 k++;
			 }
		 }
		 if (!closed) for (j = 0;
		 j < v.length;
		 j++) {
			 newv[j][k] = v[j][i];
			 newparam[j][k] = param[j][i];
		 }
		 count = 0;
		 for (j = 0;
		 j < newrefine.length;
		 j++) if (newrefine[j]) count++;
		 v = newv;
		 s = news;
		 param = newparam;
		 refine = newrefine;
	 }
	 while (count > 0 && ++iterations < MAX_SUBDIVISIONS);
	 return new Object [] {
	v, s, param}
	;
 }",0,0,1,0
"public interface Function extends Scriptable, Callable{
	 public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args);
	 public Scriptable construct(Context cx, Scriptable scope, Object[] args);
}",0,0,0,0
"public void onTrigger(final ProcessContext context, final ProcessSession session) {
	 List<FlowFile> flowFiles = session.get(context.getProperty(BATCH_SIZE).evaluateAttributeExpressions().asInteger());
	 if (flowFiles == null || flowFiles.size() == 0) {
		 return;
	 }
	 Map<ItemKeys, FlowFile> keysToFlowFileMap = new HashMap<>();
	 final String table = context.getProperty(TABLE).evaluateAttributeExpressions().getValue();
	 final String hashKeyName = context.getProperty(HASH_KEY_NAME).evaluateAttributeExpressions().getValue();
	 final String hashKeyValueType = context.getProperty(HASH_KEY_VALUE_TYPE).getValue();
	 final String rangeKeyName = context.getProperty(RANGE_KEY_NAME).evaluateAttributeExpressions().getValue();
	 final String rangeKeyValueType = context.getProperty(RANGE_KEY_VALUE_TYPE).getValue();
	 final String jsonDocument = context.getProperty(JSON_DOCUMENT).evaluateAttributeExpressions().getValue();
	 final String charset = context.getProperty(DOCUMENT_CHARSET).evaluateAttributeExpressions().getValue();
	 TableWriteItems tableWriteItems = new TableWriteItems(table);
	 for (FlowFile flowFile : flowFiles) {
		 final Object hashKeyValue = getValue(context, HASH_KEY_VALUE_TYPE, HASH_KEY_VALUE, flowFile);
		 final Object rangeKeyValue = getValue(context, RANGE_KEY_VALUE_TYPE, RANGE_KEY_VALUE, flowFile);
		 if (!isHashKeyValueConsistent(hashKeyName, hashKeyValue, session, flowFile)) {
			 continue;
		 }
		 if (!isRangeKeyValueConsistent(rangeKeyName, rangeKeyValue, session, flowFile)) {
			 continue;
		 }
		 if (!isDataValid(flowFile, jsonDocument)) {
			 flowFile = session.putAttribute(flowFile, AWS_DYNAMO_DB_ITEM_SIZE_ERROR, ""Max size of item + attribute should be 400kb but was "" + flowFile.getSize() + jsonDocument.length());
			 session.transfer(flowFile, REL_FAILURE);
			 continue;
		 }
		 ByteArrayOutputStream baos = new ByteArrayOutputStream();
		 session.exportTo(flowFile, baos);
		 try {
			 if (rangeKeyValue == null || StringUtils.isBlank(rangeKeyValue.toString())) {
				 tableWriteItems.addItemToPut(new Item().withKeyComponent(hashKeyName, hashKeyValue) .withJSON(jsonDocument, IOUtils.toString(baos.toByteArray(), charset)));
			 }
			 else {
				 tableWriteItems.addItemToPut(new Item().withKeyComponent(hashKeyName, hashKeyValue) .withKeyComponent(rangeKeyName, rangeKeyValue) .withJSON(jsonDocument, IOUtils.toString(baos.toByteArray(), charset)));
			 }
		 }
		 catch (IOException ioe) {
			 getLogger().error(""IOException while creating put item : "" + ioe.getMessage());
			 flowFile = session.putAttribute(flowFile, DYNAMODB_ITEM_IO_ERROR, ioe.getMessage());
			 session.transfer(flowFile, REL_FAILURE);
		 }
		 keysToFlowFileMap.put(new ItemKeys(hashKeyValue, rangeKeyValue), flowFile);
	 }
	 if (keysToFlowFileMap.isEmpty()) {
		 return;
	 }
	 final DynamoDB dynamoDB = getDynamoDB();
	 try {
		 BatchWriteItemOutcome outcome = dynamoDB.batchWriteItem(tableWriteItems);
		 handleUnprocessedItems(session, keysToFlowFileMap, table, hashKeyName, hashKeyValueType, rangeKeyName, rangeKeyValueType, outcome);
		 for (FlowFile flowFile : keysToFlowFileMap.values()) {
			 getLogger().debug(""Successful posted items to dynamodb : "" + table);
			 session.transfer(flowFile, REL_SUCCESS);
		 }
	 }
	 catch (AmazonServiceException exception) {
		 getLogger().error(""Could not process flowFiles due to service exception : "" + exception.getMessage());
		 List<FlowFile> failedFlowFiles = processServiceException(session, flowFiles, exception);
		 session.transfer(failedFlowFiles, REL_FAILURE);
	 }
	 catch (AmazonClientException exception) {
		 getLogger().error(""Could not process flowFiles due to client exception : "" + exception.getMessage());
		 List<FlowFile> failedFlowFiles = processClientException(session, flowFiles, exception);
		 session.transfer(failedFlowFiles, REL_FAILURE);
	 }
	 catch (Exception exception) {
		 getLogger().error(""Could not process flowFiles due to exception : "" + exception.getMessage());
		 List<FlowFile> failedFlowFiles = processException(session, flowFiles, exception);
		 session.transfer(failedFlowFiles, REL_FAILURE);
	 }
 }",0,0,1,0
"private boolean copyStream1() {
	try {
		while (!stop) {
			chunk.getChunkListener().synchronize();
			long rem = chunk.getLength() - chunk.getDownloaded();
			if (rem == 0) {
				if (this instanceof HttpChannel) {
					if (((HttpChannel) this).isFinished()) {
						close();
					}
				}
				 else {
					close();
				}
				if (chunk.transferComplete()) {
					Logger.log(chunk + "" complete and closing "" + chunk.getDownloaded() + "" "" + chunk.getLength());
					return true;
				}
			}
			if (stop) {
				return false;
			}
			int diff = (int) (rem > buf.length ? buf.length : rem);
			int x = in.read(buf, 0, diff);
			if (stop)return false;
			if (x == -1) {
				throw new Exception(""Unexpected eof"");
			}
			chunk.getOutStream().write(buf, 0, x);
			if (stop)return false;
			chunk.setDownloaded(chunk.getDownloaded() + x);
			chunk.transferring();
		}
		return false;
	}
	 catch (Exception e) {
		Logger.log(e);
		return false;
	}
	 finally {
		close();
	}
}",0,0,1,0
"private static int characterSet(String stmt, int offset, int depth) {
	 if (stmt.length() > offset + 14) {
		 char c1 = stmt.charAt(++offset);
		 char c2 = stmt.charAt(++offset);
		 char c3 = stmt.charAt(++offset);
		 char c4 = stmt.charAt(++offset);
		 char c5 = stmt.charAt(++offset);
		 char c6 = stmt.charAt(++offset);
		 char c7 = stmt.charAt(++offset);
		 char c8 = stmt.charAt(++offset);
		 char c9 = stmt.charAt(++offset);
		 char c10 = stmt.charAt(++offset);
		 char c11 = stmt.charAt(++offset);
		 char c12 = stmt.charAt(++offset);
		 char c13 = stmt.charAt(++offset);
		 char c14 = stmt.charAt(++offset);
		 if ((c1 == 'H' || c1 == 'h') && (c2 == 'A' || c2 == 'a') && (c3 == 'R' || c3 == 'r') && (c4 == 'A' || c4 == 'a') && (c5 == 'C' || c5 == 'c') && (c6 == 'T' || c6 == 't') && (c7 == 'E' || c7 == 'e') && (c8 == 'R' || c8 == 'r') && (c9 == '_') && (c10 == 'S' || c10 == 's') && (c11 == 'E' || c11 == 'e') && (c12 == 'T' || c12 == 't') && (c13 == '_')) {
			 switch (c14) {
				 case 'R': case 'r': return characterSetResults(stmt, offset);
				 case 'C': case 'c': return characterSetC(stmt, offset);
				 default: return OTHER;
			 }
		 }
	 }
	 return OTHER;
 }",0,0,1,0
"final class MachOSymtab {
	 private final ByteBuffer symtabCmd;
	 private int symtabDataSize;
	 private final ArrayList<MachOSymbol> localSymbols = new ArrayList<>();
	 private final ArrayList<MachOSymbol> globalSymbols = new ArrayList<>();
	 private final ArrayList<MachOSymbol> undefSymbols = new ArrayList<>();
	 private int symbolCount;
	 private final StringBuilder strTabContent = new StringBuilder();
	 private int strTabNrOfBytes = 0;
	 MachOSymtab() {
		 symtabCmd = MachOByteBuffer.allocate(symtab_command.totalsize);
		 symtabCmd.putInt(symtab_command.cmd.off, symtab_command.LC_SYMTAB);
		 symtabCmd.putInt(symtab_command.cmdsize.off, symtab_command.totalsize);
		 symbolCount = 0;
	 }
	 static int getAlign() {
		 return (4);
	 }
	 MachOSymbol addSymbolEntry(String name, byte type, byte secHdrIndex, long offset) {
		 int index;
		 MachOSymbol sym;
		 if (name.isEmpty()) {
			 index = 0;
			 strTabContent.append('\0');
			 strTabNrOfBytes += 1;
			 sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);
			 localSymbols.add(sym);
		 }
		 else {
			 index = strTabNrOfBytes;
			 strTabContent.append(""_"").append(name).append('\0');
			 strTabNrOfBytes += (name.getBytes().length + 1 + 1);
			 sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);
			 switch (type) {
				 case nlist_64.N_EXT: undefSymbols.add(sym);
				 break;
				 case nlist_64.N_SECT: case nlist_64.N_UNDF: localSymbols.add(sym);
				 break;
				 case nlist_64.N_SECT | nlist_64.N_EXT: globalSymbols.add(sym);
				 break;
				 default: System.out.println(""Unsupported Symbol type "" + type);
				 break;
			 }
		 }
		 symbolCount++;
		 return (sym);
	 }
	 void setOffset(int symoff) {
		 symtabCmd.putInt(symtab_command.symoff.off, symoff);
	 }
	 void updateIndexes() {
		 int index = 0;
		 for (int i = 0;
		 i < localSymbols.size();
		 i++) {
			 MachOSymbol sym = localSymbols.get(i);
			 sym.setIndex(index++);
		 }
		 for (int i = 0;
		 i < globalSymbols.size();
		 i++) {
			 MachOSymbol sym = globalSymbols.get(i);
			 sym.setIndex(index++);
		 }
		 for (int i = index;
		 i < undefSymbols.size();
		 i++) {
			 MachOSymbol sym = undefSymbols.get(i);
			 sym.setIndex(index++);
		 }
	 }
	 int calcSizes() {
		 int stroff;
		 stroff = symtabCmd.getInt(symtab_command.symoff.off) + (nlist_64.totalsize * symbolCount);
		 symtabCmd.putInt(symtab_command.nsyms.off, symbolCount);
		 symtabCmd.putInt(symtab_command.stroff.off, stroff);
		 symtabCmd.putInt(symtab_command.strsize.off, strTabNrOfBytes);
		 symtabDataSize = (nlist_64.totalsize * symbolCount) + strTabNrOfBytes;
		 return (symtabDataSize);
	 }
	 int getNumLocalSyms() {
		 return localSymbols.size();
	 }
	 int getNumGlobalSyms() {
		 return globalSymbols.size();
	 }
	 int getNumUndefSyms() {
		 return undefSymbols.size();
	 }
	 byte[] getCmdArray() {
		 return symtabCmd.array();
	 }
	 byte[] getDataArray() {
		 ByteBuffer symtabData = MachOByteBuffer.allocate(symtabDataSize);
		 byte[] retarray;
		 for (int i = 0;
		 i < localSymbols.size();
		 i++) {
			 MachOSymbol sym = localSymbols.get(i);
			 byte[] arr = sym.getArray();
			 symtabData.put(arr);
		 }
		 for (int i = 0;
		 i < globalSymbols.size();
		 i++) {
			 MachOSymbol sym = globalSymbols.get(i);
			 byte[] arr = sym.getArray();
			 symtabData.put(arr);
		 }
		 for (int i = 0;
		 i < undefSymbols.size();
		 i++) {
			 MachOSymbol sym = undefSymbols.get(i);
			 byte[] arr = sym.getArray();
			 symtabData.put(arr);
		 }
		 byte[] strs = strTabContent.toString().getBytes();
		 symtabData.put(strs);
		 retarray = symtabData.array();
		 return (retarray);
	 }
}",1,1,0,0
"public class SchedulerStateRecord implements java.io.Serializable {
	 private String schedulerInstanceId;
	 private long checkinTimestamp;
	 private long checkinInterval;
	 public long getCheckinInterval() {
		 return checkinInterval;
	 }
	 public long getCheckinTimestamp() {
		 return checkinTimestamp;
	 }
	 public String getSchedulerInstanceId() {
		 return schedulerInstanceId;
	 }
	 public void setCheckinInterval(long l) {
		 checkinInterval = l;
	 }
	 public void setCheckinTimestamp(long l) {
		 checkinTimestamp = l;
	 }
	 public void setSchedulerInstanceId(String string) {
		 schedulerInstanceId = string;
	 }
}",0,1,0,0
"public class ICEDocCleaner {
	 public static void main(String[] args) throws IOException {
		 System.out.println(""Enter full filepath: "");
		 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 String path = br.readLine();
		 if (path.contains(""exit"")) {
			 return;
		 }
		 File javaFile = new File(path);
		 if (javaFile != null && javaFile.exists() && javaFile.isFile()) {
			 System.out.println(""File found, beginning cleaning..."");
			 FileInputStream inputStream = null;
			 Scanner scanner = null;
			 StringBuilder sb = null;
			 try {
				 inputStream = new FileInputStream(javaFile);
				 scanner = new Scanner(inputStream, ""UTF-8"");
				 String line = """";
				 sb = new StringBuilder();
				 while (scanner.hasNextLine() && (line = scanner.nextLine()) != null) {
					 if (line.matches(""\\s*\\*\\s*<!-- (begin|end)-UML-doc -->\\s*"") || line.matches(""\\s*\\*\\s*<!-- (begin|end)-UML-doc -->\\s*<!-- (begin|end)-UML-doc -->"") || line.matches(""\\s* || line.contains("""") || line.contains(""UML to Java"")) {
						 continue;
					 }
					 else {
						 sb.append(line + ""\n"");
					 }
				 }
				 System.out.println(""Done cleaning."");
				 if (scanner.ioException() != null) {
					 throw scanner.ioException();
				 }
			 }
			 finally {
				 if (inputStream != null) {
					 inputStream.close();
				 }
				 if (scanner != null) {
					 scanner.close();
				 }
			 }
			 int fileExtIndex = javaFile.getPath().lastIndexOf(""."");
			 String bakFilePath = javaFile.getPath().substring(0, fileExtIndex) + ""_bak"" + javaFile.getPath().substring(fileExtIndex);
			 File bakFile = new File(bakFilePath);
			 if (bakFile.exists()) {
				 bakFile.delete();
			 }
			 Files.copy(javaFile.toPath(), bakFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
			 System.out.println(""Creating back-up file... (will delete on successful exit)\n"" + bakFile.getPath());
			 BufferedWriter writer = new BufferedWriter(new FileWriter(javaFile));
			 writer.write(sb.toString());
			 System.out.println(""Overwriting original file..."");
			 if (writer != null) {
				 writer.close();
			 }
			 System.out.println(""Process complete!"");
			 bakFile.deleteOnExit();
		 }
		 else {
			 System.out.println(""Could not find file."");
			 main(args);
		 }
		 return;
	 }
}",1,0,0,0
"public boolean prepare() throws IOException {
	 this.mapOutputFile.removeAll(reduceTask.getTaskId());
	 final int numOutputs = reduceTask.getNumMaps();
	 List neededOutputs = new ArrayList(numOutputs);
	 List knownOutputs = new ArrayList(100);
	 int numInFlight = 0, numCopied = 0;
	 int lowThreshold = numCopiers*2;
	 long bytesTransferred = 0;
	 DecimalFormat mbpsFormat = new DecimalFormat(""0.00"");
	 Random backoff = new Random();
	 final Progress copyPhase = getTask().getProgress().phase();
	 MapCopyLeaseChecker leaseChecker = null;
	 for (int i = 0;
	 i < numOutputs;
	 i++) {
		 neededOutputs.add(new Integer(i));
		 copyPhase.addPhase();
	 }
	 InterTrackerProtocol jobClient = getTracker().getJobClient();
	 copiers = new MapOutputCopier[numCopiers];
	 for (int i=0;
	 i < copiers.length;
	 i++) {
		 copiers[i] = new MapOutputCopier();
		 copiers[i].start();
	 }
	 leaseChecker = new MapCopyLeaseChecker();
	 leaseChecker.start();
	 long startTime = System.currentTimeMillis();
	 long currentTime = startTime;
	 while (!killed && numCopied < numOutputs) {
		 LOG.info(reduceTask.getTaskId() + "" Need "" + (numOutputs-numCopied) + "" map output(s)"");
		 if (!neededOutputs.isEmpty()) {
			 LOG.info(reduceTask.getTaskId() + "" Need "" + neededOutputs.size() + "" map output location(s)"");
			 try {
				 MapOutputLocation[] locs = queryJobTracker(neededOutputs, jobClient);
				 for (int i=0;
				 i < locs.length;
				 i++) {
					 neededOutputs.remove(new Integer(locs[i].getMapId()));
					 knownOutputs.add(locs[i]);
				 }
				 LOG.info(reduceTask.getTaskId() + "" Got "" + (locs == null ? 0 : locs.length) + "" map outputs from jobtracker"");
			 }
			 catch (IOException ie) {
				 LOG.warn(reduceTask.getTaskId() + "" Problem locating map outputs: "" + StringUtils.stringifyException(ie));
			 }
		 }
		 int numKnown = knownOutputs.size(), numScheduled = 0;
		 int numSlow = 0, numDups = 0;
		 LOG.info(reduceTask.getTaskId() + "" Got "" + numKnown + "" known map output location(s);
		 scheduling..."");
		 synchronized (scheduledCopies) {
			 ListIterator locIt = knownOutputs.listIterator();
			 currentTime = System.currentTimeMillis();
			 while (locIt.hasNext()) {
				 MapOutputLocation loc = (MapOutputLocation)locIt.next();
				 Long penaltyEnd = (Long)penaltyBox.get(loc.getHost());
				 boolean penalized = false, duplicate = false;
				 if (penaltyEnd != null && currentTime < penaltyEnd.longValue()) {
					 penalized = true;
					 numSlow++;
				 }
				 if (uniqueHosts.contains(loc.getHost())) {
					 duplicate = true;
					 numDups++;
				 }
				 if (!penalized && !duplicate) {
					 uniqueHosts.add(loc.getHost());
					 scheduledCopies.add(loc);
					 locIt.remove();
					 numInFlight++;
					 numScheduled++;
				 }
			 }
			 scheduledCopies.notifyAll();
		 }
		 LOG.info(reduceTask.getTaskId() + "" Scheduled "" + numScheduled + "" of "" + numKnown + "" known outputs ("" + numSlow + "" slow hosts and "" + numDups + "" dup hosts)"");
		 try {
			 if (numInFlight == 0 && numScheduled == 0) {
				 getTask().reportProgress(getTracker());
				 Thread.sleep(5000);
			 }
		 }
		 catch (InterruptedException e) {
		 }
		 while (!killed && numInFlight > 0) {
			 CopyResult cr = getCopyResult();
			 if (cr != null) {
				 if (cr.getSuccess()) {
					 numCopied++;
					 bytesTransferred += cr.getSize();
					 long secsSinceStart = (System.currentTimeMillis()-startTime)/1000+1;
					 float mbs = ((float)bytesTransferred)/(1024*1024);
					 float transferRate = mbs/secsSinceStart;
					 copyPhase.startNextPhase();
					 copyPhase.setStatus(""copy ("" + numCopied + "" of "" + numOutputs + "" at "" + mbpsFormat.format(transferRate) + "" MB/s)"");
					 getTask().reportProgress(getTracker());
				 }
				 else {
					 neededOutputs.add(new Integer(cr.getMapId()));
					 currentTime = System.currentTimeMillis();
					 long nextContact = currentTime + 60 * 1000 + backoff.nextInt(maxBackoff*1000);
					 penaltyBox.put(cr.getHost(), new Long(nextContact));
					 LOG.warn(reduceTask.getTaskId() + "" adding host "" + cr.getHost() + "" to penalty box, next contact in "" + ((nextContact-currentTime)/1000) + "" seconds"");
					 ListIterator locIt = knownOutputs.listIterator();
					 while (locIt.hasNext()) {
						 MapOutputLocation loc = (MapOutputLocation)locIt.next();
						 if (cr.getHost().equals(loc.getHost())) {
							 locIt.remove();
							 neededOutputs.add(new Integer(loc.getMapId()));
						 }
					 }
				 }
				 uniqueHosts.remove(cr.getHost());
				 numInFlight--;
			 }
			 if (numInFlight < lowThreshold && (numOutputs-numCopied) > PROBE_SAMPLE_SIZE) {
				 break;
			 }
		 }
	 }
	 leaseChecker.interrupt();
	 synchronized (copiers) {
		 synchronized (scheduledCopies) {
			 for (int i=0;
			 i < copiers.length;
			 i++) {
				 copiers[i].interrupt();
				 copiers[i] = null;
			 }
		 }
	 }
	 return numCopied == numOutputs && !killed;
 }",0,0,1,0
"public final IFeedbackMessageFilter getFilter(){
	return filter;
}",0,0,0,0
"protected boolean loadMore() throws XMLStreamException {
	 WstxInputSource input = mInput;
	 do {
		 mCurrInputProcessed += mInputEnd;
		 mCurrInputRowStart -= mInputEnd;
		 int count;
		 try {
			 count = input.readInto(this);
			 if (count > 0) {
				 return true;
			 }
			 input.close();
		 }
		 catch (IOException ioe) {
			 throw constructFromIOE(ioe);
		 }
		 if (input == mRootInput) {
			 return false;
		 }
		 WstxInputSource parent = input.getParent();
		 if (parent == null) {
			 throwNullParent(input);
		 }
		 if (mCurrDepth != input.getScopeId()) {
			 handleIncompleteEntityProblem(input);
		 }
		 mInput = input = parent;
		 input.restoreContext(this);
		 mInputTopDepth = input.getScopeId();
		 if (!mNormalizeLFs) {
			 mNormalizeLFs = !input.fromInternalEntity();
		 }
	 }
	 while (mInputPtr >= mInputEnd);
	 return true;
 }",0,0,1,0
"public class RowReadSupport extends ReadSupport<Row> {
	private TypeInformation<?> returnTypeInfo;
	public ReadContext init(InitContext initContext) {
		checkNotNull(initContext, ""initContext"");
		returnTypeInfo = ParquetSchemaConverter.fromParquetType(initContext.getFileSchema());
		return new ReadContext(initContext.getFileSchema());
	}
	public RecordMaterializer<Row> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData,MessageType fileSchema, ReadContext readContext) {
		return new RowMaterializer(readContext.getRequestedSchema(), returnTypeInfo);
	}
}",0,1,0,0
"public class DigestAlgorithm implements Algorithm {
	 private static final int BYTE_MASK = 0xFF;
	 private static final int BUFFER_SIZE = 8192;
	 private String algorithm = ""MD5"";
	 private String provider = null;
	 private MessageDigest messageDigest = null;
	 private int readBufferSize = BUFFER_SIZE;
	 public void setAlgorithm(String algorithm) {
		 this.algorithm = algorithm != null ? algorithm.toUpperCase(Locale.ENGLISH) : null;
	 }
	 public void setProvider(String provider) {
		 this.provider = provider;
	 }
	 public void initMessageDigest() {
		 if (messageDigest != null) {
			 return;
		 }
		 if ((provider != null) && !"""".equals(provider) && !""null"".equals(provider)) {
			 try {
				 messageDigest = MessageDigest.getInstance(algorithm, provider);
			 }
			 catch (NoSuchAlgorithmException noalgo) {
				 throw new BuildException(noalgo);
			 }
			 catch (NoSuchProviderException noprovider) {
				 throw new BuildException(noprovider);
			 }
		 }
		 else {
			 try {
				 messageDigest = MessageDigest.getInstance(algorithm);
			 }
			 catch (NoSuchAlgorithmException noalgo) {
				 throw new BuildException(noalgo);
			 }
		 }
	 }
	 public boolean isValid() {
		 return ""SHA"".equals(algorithm) || ""MD5"".equals(algorithm);
	 }
	 public String getValue(File file) {
		 initMessageDigest();
		 String checksum = null;
		 try {
			 if (!file.canRead()) {
				 return null;
			 }
			 FileInputStream fis = null;
			 byte[] buf = new byte[readBufferSize];
			 try {
				 messageDigest.reset();
				 fis = new FileInputStream(file);
				 DigestInputStream dis = new DigestInputStream(fis, messageDigest);
				 while (dis.read(buf, 0, readBufferSize) != -1) {
				 }
				 dis.close();
				 fis.close();
				 fis = null;
				 byte[] fileDigest = messageDigest.digest();
				 StringBuffer checksumSb = new StringBuffer();
				 for (int i = 0;
				 i < fileDigest.length;
				 i++) {
					 String hexStr = Integer.toHexString(BYTE_MASK & fileDigest[i]);
					 if (hexStr.length() < 2) {
						 checksumSb.append(""0"");
					 }
					 checksumSb.append(hexStr);
				 }
				 checksum = checksumSb.toString();
			 }
			 catch (Exception e) {
				 return null;
			 }
		 }
		 catch (Exception e) {
			 return null;
		 }
		 return checksum;
	 }
	 public String toString() {
		 StringBuffer buf = new StringBuffer();
		 buf.append(""<DigestAlgorithm:"");
		 buf.append(""algorithm="").append(algorithm);
		 buf.append("";
		provider="").append(provider);
		 buf.append("">"");
		 return buf.toString();
	 }
}",0,0,0,0
"private void checkOptions(Commandline cmd) {
	 if (getComment() != null) {
		 cmd.createArgument().setValue(FLAG_COMMENT);
		 cmd.createArgument().setValue(""\"""" + getComment() + ""\"""");
	 }
	 if (getPlatform() != null) {
		 cmd.createArgument().setValue(FLAG_PLATFORM);
		 cmd.createArgument().setValue(getPlatform());
	 }
	 if (getResolver() != null) {
		 cmd.createArgument().setValue(FLAG_RESOLVER);
		 cmd.createArgument().setValue(getResolver());
	 }
	 if (getSubSystem() != null) {
		 cmd.createArgument().setValue(FLAG_SUBSYSTEM);
		 cmd.createArgument().setValue(""\"""" + getSubSystem() + ""\"""");
	 }
	 if (getRelease() != null) {
		 cmd.createArgument().setValue(FLAG_RELEASE);
		 cmd.createArgument().setValue(getRelease());
	 }
 }",0,0,0,0
"public abstract class FakeMediaClockRenderer extends FakeRenderer implements MediaClock {
	 public FakeMediaClockRenderer(Format... expectedFormats) {
		 super(expectedFormats);
	 }
	 public MediaClock getMediaClock() {
		 return this;
	 }
}",0,0,0,0
"public void parse(Project project, Object source) throws BuildException {
	 throw new BuildException(""ProjectHelper.parse() must be implemented "" + ""in a helper plugin "" + this.getClass().getName());
 }",0,0,0,0
"public Source resolve(String href, String base) throws TransformerException {
	 if (isReference()) {
		 return getRef().resolve(href, base);
	 }
	 dieOnCircularReference();
	 SAXSource source = null;
	 String uri = removeFragment(href);
	 log(""resolve: '"" + uri + ""' with base: '"" + base + ""'"", Project.MSG_DEBUG);
	 source = (SAXSource) getCatalogResolver().resolve(uri, base);
	 if (source == null) {
		 log(""No matching catalog entry found, parser will use: '"" + href + ""'"", Project.MSG_DEBUG);
		 source = new SAXSource();
		 URL baseURL = null;
		 try {
			 if (base == null) {
				 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
			 }
			 else {
				 baseURL = new URL(base);
			 }
			 URL url = (uri.length() == 0 ? baseURL : new URL(baseURL, uri));
			 source.setInputSource(new InputSource(url.toString()));
		 }
		 catch (MalformedURLException ex) {
			 source.setInputSource(new InputSource(uri));
		 }
	 }
	 setEntityResolver(source);
	 return source;
 }
 public Source resolve(String href, String base) throws TransformerException {
	 SAXSource result = null;
	 InputSource source = null;
	 ResourceLocation matchingEntry = findMatchingEntry(href);
	 if (matchingEntry != null) {
		 log(""Matching catalog entry found for uri: '"" + matchingEntry.getPublicId() + ""' location: '"" + matchingEntry.getLocation() + ""'"", Project.MSG_DEBUG);
		 ResourceLocation entryCopy = matchingEntry;
		 if (base != null) {
			 try {
				 URL baseURL = new URL(base);
				 entryCopy = new ResourceLocation();
				 entryCopy.setBase(baseURL);
			 }
			 catch (MalformedURLException ex) {
			 }
		 }
		 entryCopy.setPublicId(matchingEntry.getPublicId());
		 entryCopy.setLocation(matchingEntry.getLocation());
		 source = filesystemLookup(entryCopy);
		 if (source == null) {
			 source = classpathLookup(entryCopy);
		 }
		 if (source == null) {
			 source = urlLookup(entryCopy);
		 }
		 if (source != null) {
			 result = new SAXSource(source);
		 }
	 }
	 return result;
 }
 public Source resolve(String href, String base) throws TransformerException {
	 SAXSource result = null;
	 InputSource source = null;
	 processExternalCatalogs();
	 ResourceLocation matchingEntry = findMatchingEntry(href);
	 if (matchingEntry != null) {
		 log(""Matching catalog entry found for uri: '"" + matchingEntry.getPublicId() + ""' location: '"" + matchingEntry.getLocation() + ""'"", Project.MSG_DEBUG);
		 ResourceLocation entryCopy = matchingEntry;
		 if (base != null) {
			 try {
				 URL baseURL = new URL(base);
				 entryCopy = new ResourceLocation();
				 entryCopy.setBase(baseURL);
			 }
			 catch (MalformedURLException ex) {
			 }
		 }
		 entryCopy.setPublicId(matchingEntry.getPublicId());
		 entryCopy.setLocation(matchingEntry.getLocation());
		 source = filesystemLookup(entryCopy);
		 if (source == null) {
			 source = classpathLookup(entryCopy);
		 }
		 if (source != null) {
			 result = new SAXSource(source);
		 }
		 else {
			 try {
				 result = (SAXSource) resolve.invoke(resolverImpl, new Object[] {
				href, base}
				);
			 }
			 catch (Exception ex) {
				 throw new BuildException(ex);
			 }
		 }
	 }
	 else {
		 try {
			 result = (SAXSource) resolve.invoke(resolverImpl, new Object[] {
			href, base}
			);
		 }
		 catch (Exception ex) {
			 throw new BuildException(ex);
		 }
	 }
	 return result;
 }",0,0,0,0
"public abstract class ZipUtil {
	 static byte[] copy(byte[] from) {
		 if (from != null) {
			 byte[] to = new byte[from.length];
			 System.arraycopy(from, 0, to, 0, to.length);
			 return to;
		 }
		 return null;
	 }
}",0,0,0,0
"public class _ParameterFieldReference extends _ParameterValueOrFieldReference implements ElementSerializable, ElementDeserializable{
	 protected String parameterName;
	 protected String fieldAlias;
	 public _ParameterFieldReference() {
		 super();
	 }
	 public _ParameterFieldReference( final String parameterName, final String fieldAlias) {
		 setParameterName(parameterName);
		 setFieldAlias(fieldAlias);
	 }
	 public String getParameterName() {
		 return this.parameterName;
	 }
	 public void setParameterName(String value) {
		 this.parameterName = value;
	 }
	 public String getFieldAlias() {
		 return this.fieldAlias;
	 }
	 public void setFieldAlias(String value) {
		 this.fieldAlias = value;
	 }
	 public void writeAsElement( final XMLStreamWriter writer, final String name) throws XMLStreamException {
		 writer.writeStartElement(name);
		 writer.writeAttribute( ""xsi"", ""http: ""type"", ""ParameterFieldReference"");
		 XMLStreamWriterHelper.writeElement( writer, ""ParameterName"", this.parameterName);
		 XMLStreamWriterHelper.writeElement( writer, ""FieldAlias"", this.fieldAlias);
		 writer.writeEndElement();
	 }
	 public void readFromElement(final XMLStreamReader reader) throws XMLStreamException {
		 String localName;
		 int event;
		 do {
			 event = reader.next();
			 if (event == XMLStreamConstants.START_ELEMENT) {
				 localName = reader.getLocalName();
				 if (localName.equalsIgnoreCase(""ParameterName"")) {
					 this.parameterName = reader.getElementText();
				 }
				 else if (localName.equalsIgnoreCase(""FieldAlias"")) {
					 this.fieldAlias = reader.getElementText();
				 }
				 else {
					 XMLStreamReaderHelper.readUntilElementEnd(reader);
				 }
			 }
		 }
		 while (event != XMLStreamConstants.END_ELEMENT);
	 }
}",1,1,0,0
"public class TestPigTest {
	 private PigTest test;
	 private static Cluster cluster;
	 private static final String PIG_SCRIPT = ""test/data/pigunit/top_queries.pig"";
	 private static final String PIG_SCRIPT_MACRO = ""test/data/pigunit/top_queries_macro.pig"";
	 private static final Log LOG = LogFactory.getLog(TestPigTest.class);
	 public static void setUpOnce() throws Exception {
		 System.getProperties().setProperty(""pigunit.exectype"", Util.getLocalTestMode().toString());
		 cluster = PigTest.getCluster();
		 cluster.update( new Path(""test/data/pigunit/top_queries_input_data.txt""), new Path(""top_queries_input_data.txt""));
	 }
	 public void testNtoN() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(""queries_limit"", output);
	 }
	 public void testImplicitNtoN() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(output);
	 }
	 public void testTextInput() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] input = {
		 ""yahoo\t10"", ""twitter\t7"", ""facebook\t10"", ""yahoo\t15"", ""facebook\t5"", ""a\t1"", ""b\t2"", ""c\t3"", ""d\t4"", ""e\t5"", }
		;
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(""data"", input, ""queries_limit"", output);
	 }
	 public void testDelimiter() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] input = {
		 ""yahoo,10"", ""twitter,7"", ""facebook,10"", ""yahoo,15"", ""facebook,5"", ""a,1"", ""b,2"", ""c,3"", ""d,4"", ""e,5"", }
		;
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(""data"", input, ""queries_limit"", output, "","");
	 }
	 public void testSubset() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] input = {
		 ""yahoo\t10"", ""twitter\t7"", ""facebook\t10"", ""yahoo\t15"", ""facebook\t5"", ""a\t1"", ""b\t2"", ""c\t3"", ""d\t4"", ""e\t5"", }
		;
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(""data"", input, ""queries_limit"", output);
	 }
	 public void testOverride() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 test.override(""queries_limit"", ""queries_limit = LIMIT queries_ordered 2;
		"");
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", }
		;
		 test.assertOutput(output);
	 }
	 public void testInlinePigScript() throws ParseException, IOException {
		 String[] script = {
			 ""data = LOAD 'top_queries_input_data.txt' AS (query:CHARARRAY, count:INT);
			"", ""queries_group = GROUP data BY query PARALLEL 1;
			"", ""queries_sum = FOREACH queries_group GENERATE group AS query, SUM(data.count) AS count;
			"", ""queries_ordered = ORDER queries_sum BY count DESC PARALLEL 1;
			"", ""queries_limit = LIMIT queries_ordered 3;
			"", ""STORE queries_limit INTO 'top_3_queries';
		"", }
		;
		 test = new PigTest(script);
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(output);
	 }
	 public void testFileOutput() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 test.assertOutput(new File(""test/data/pigunit/top_queries_expected_top_3.txt""));
	 }
	 public void testArgFiles() throws ParseException, IOException {
		 String[] argsFile = {
		 ""test/data/pigunit/top_queries_params.txt"" }
		;
		 test = new PigTest(PIG_SCRIPT, null, argsFile);
		 test.assertOutput(new File(""test/data/pigunit/top_queries_expected_top_3.txt""));
	 }
	 public void testGetLastAlias() throws ParseException, IOException {
		 String[] script = {
			 ""data = LOAD 'top_queries_input_data.txt' AS (query:CHARARRAY, count:INT);
			"", ""queries_group = GROUP data BY query PARALLEL 1;
			"", ""queries_sum = FOREACH queries_group GENERATE group AS query, SUM(data.count) AS count;
			"", ""queries_ordered = ORDER queries_sum BY count DESC PARALLEL 1;
			"", ""queries_limit = LIMIT queries_ordered 3;
			"", ""STORE queries_limit INTO 'top_3_queries';
		"", }
		;
		 test = new PigTest(script);
		 String expected = ""(yahoo,25)\n"" + ""(facebook,15)\n"" + ""(twitter,7)"";
		 assertEquals(expected, StringUtils.join(test.getAlias(""queries_limit""), ""\n""));
	 }
	 public void testWithUdf() throws ParseException, IOException {
		 String[] script = {
			 ""DEFINE TOKENIZE TOKENIZE();
			"", ""data = LOAD 'top_queries_input_data.txt' AS (query:CHARARRAY, count:INT);
			"", ""queries = FOREACH data GENERATE query, TOKENIZE(query) AS query_tokens;
			"", ""queries_ordered = ORDER queries BY query DESC PARALLEL 1;
			"", ""queries_limit = LIMIT queries_ordered 3;
			"", ""STORE queries_limit INTO 'top_3_queries';
		"", }
		;
		 test = new PigTest(script);
		 String[] output = {
			 ""(yahoo,{
			(yahoo)}
			)"", ""(yahoo,{
			(yahoo)}
			)"", ""(twitter,{
			(twitter)}
		)"", }
		;
		 test.assertOutput(output);
	 }
	 public void testStore() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 test.unoverride(""STORE"");
		 test.runScript();
		 assertTrue(cluster.delete(new Path(""top_3_queries"")));
	 }
	 public void testMacro() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT_MACRO, args);
		 test.unoverride(""STORE"");
		 test.runScript();
		 assertTrue(cluster.delete(new Path(""top_3_queries"")));
	 }
	 public void testWithMock() throws ParseException, IOException {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 PigServer mockServer = null;
		 Cluster mockCluster = null;
		 test = new PigTest(PIG_SCRIPT, args, mockServer, mockCluster);
		 test.assertOutput(new File(""data/top_queries_expected_top_3.txt""));
	 }
	 public void testDefaultBootup() throws Exception {
		 Properties pigProps = PropertiesUtil.loadDefaultProperties();
		 String bootupPath = ""/tmp/.temppigbootup"";
		 pigProps.setProperty(""pig.load.default.statements"", bootupPath);
		 File bootupFile = new File(bootupPath);
		 PrintWriter out = new PrintWriter(new FileWriter(bootupFile));
		 out.println(""data = LOAD 'top_queries_input_data.txt' AS (query:CHARARRAY, count:INT);
		"");
		 out.close();
		 String[] script = {
			 ""queries_group = GROUP data BY query PARALLEL 1;
			"", ""queries_sum = FOREACH queries_group GENERATE group AS query, SUM(data.count) AS count;
			"", ""queries_ordered = ORDER queries_sum BY count DESC PARALLEL 1;
			"", ""queries_limit = LIMIT queries_ordered 3;
			"", ""STORE queries_limit INTO 'top_3_queries';
		"", }
		;
		 String scriptPath = ""/tmp/tempScript"";
		 File scriptFile = new File(scriptPath);
		 out = new PrintWriter(new FileWriter(scriptFile));
		 for (String line : script) {
			 out.println(line);
		 }
		 out.close();
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 PigServer pig = null;
		 pig = new PigServer(Util.getLocalTestMode(), pigProps);
		 final Cluster cluster = new Cluster(pig.getPigContext());
		 test = new PigTest(scriptPath, args, pig, cluster);
		 String[] output = {
		 ""(yahoo,25)"", ""(facebook,15)"", ""(twitter,7)"", }
		;
		 test.assertOutput(""queries_limit"", output);
		 scriptFile.delete();
		 bootupFile.delete();
	 }
	 public void testMockedAliasWithDefaultDelimiter() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args, null, null);
		 String[] mockData = {
		 ""Apache\t99"", ""Pig\t42"", ""GitHub\t107"", ""Google\t404"" }
		;
		 test.mockAlias(""queries_ordered"", mockData,""(query: chararray,count: int)"");
		 String[] expectedOutput = {
		 ""(Apache,99)"", ""(Pig,42)"", ""(GitHub,107)"" }
		;
		 test.assertOutput(expectedOutput);
	 }
	 public void testMockedAliasWithDifferentDelimiter() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args, null, null);
		 String[] mockData = {
		 ""Apache,99"", ""Pig,42"", ""GitHub,107"", ""Google,404"" }
		;
		 test.mockAlias(""queries_ordered"", mockData,""(query: chararray,count: int)"", "","");
		 String[] expectedOutput = {
		 ""(Apache,99)"", ""(Pig,42)"", ""(GitHub,107)"" }
		;
		 test.assertOutput(expectedOutput);
	 }
	 public void testAliasSchemaMap() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args, null, null);
		 final Map<String, String> expected = new HashMap<String, String>();
		 expected.put(""data"", ""(query: chararray,count: int)"");
		 expected.put(""queries_group"", ""(group: chararray,data: {
		(query: chararray,count: int)}
		)"");
		 expected.put(""queries_sum"", ""(query: chararray,count: long)"");
		 expected.put(""queries_ordered"", ""(query: chararray,count: long)"");
		 expected.put(""queries_limit"", ""(query: chararray,count: long)"");
		 Map<String, String> map = test.getAliasToSchemaMap();
		 assertEquals(expected, map);
	 }
	 public void testAnyOrderOutput() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] reorderedExpectedOutput = {
		 ""(twitter,7)"", ""(yahoo,25)"", ""(facebook,15)"" }
		;
		 test.assertOutputAnyOrder(reorderedExpectedOutput);
	 }
	 public void testAnyOrderOutputForAlias() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] reorderedExpectedOutput = {
		 ""(twitter,7)"", ""(yahoo,25)"", ""(facebook,15)"" }
		;
		 test.assertOutputAnyOrder(""queries_limit"", reorderedExpectedOutput);
	 }
	 public void testSpecificOrderOutput() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] reorderedExpectedOutput = {
		 ""(twitter,7)"", ""(yahoo,25)"", ""(facebook,15)"" }
		;
		 try {
			 test.assertOutput(reorderedExpectedOutput);
			 fail(""assertOutput should fail when the records are unordered."");
		 }
		 catch(ComparisonFailure e) {
		 }
	 }
	 public void testSpecificOrderOutputForAlias() throws Exception {
		 String[] args = {
		 ""n=3"", ""reducers=1"", ""input=top_queries_input_data.txt"", ""output=top_3_queries"", }
		;
		 test = new PigTest(PIG_SCRIPT, args);
		 String[] reorderedExpectedOutput = {
		 ""(twitter,7)"", ""(yahoo,25)"", ""(facebook,15)"" }
		;
		 try {
			 test.assertOutput(""queries_limit"", reorderedExpectedOutput);
			 fail(""assertOutput should fail when the records are unordered."");
		 }
		 catch(ComparisonFailure e) {
		 }
	 }
}",1,0,0,0
"public final class ConnectionValidator {
	 private final Map<ConnectionType, AbstractProtocolValidator> specMap;
	 private final QueryFilterCriteriaFactory queryFilterCriteriaFactory;
	 private ConnectionValidator(final AbstractProtocolValidator... connectionSpecs) {
		 final Map<ConnectionType, AbstractProtocolValidator> specMap = Arrays.stream(connectionSpecs) .collect(Collectors.toMap(AbstractProtocolValidator::type, Function.identity()));
		 this.specMap = Collections.unmodifiableMap(specMap);
		 final CriteriaFactory criteriaFactory = new CriteriaFactoryImpl();
		 final ThingsFieldExpressionFactory fieldExpressionFactory = new ModelBasedThingsFieldExpressionFactory();
		 queryFilterCriteriaFactory = new QueryFilterCriteriaFactory(criteriaFactory, fieldExpressionFactory);
	 }
	 public static ConnectionValidator of(final AbstractProtocolValidator... connectionSpecs) {
		 return new ConnectionValidator(connectionSpecs);
	 }
	 void validate(final Connection connection, final DittoHeaders dittoHeaders) {
		 final AbstractProtocolValidator spec = specMap.get(connection.getConnectionType());
		 validateSourceAndTargetAddressesAreNonempty(connection, dittoHeaders);
		 validateFormatOfCertificates(connection, dittoHeaders);
		 if (spec != null) {
			 spec.validate(connection, dittoHeaders);
		 }
		 else {
			 throw new IllegalStateException(""Unknown connection type: "" + connection);
		 }
	 }
	 private void validateSourceAndTargetAddressesAreNonempty(final Connection connection, final DittoHeaders dittoHeaders) {
		 connection.getSources().forEach(source -> {
			 if (source.getAddresses().isEmpty() || source.getAddresses().contains("""")) {
				 final String location = String.format(""Source %d of connection <%s>"", source.getIndex(), connection.getId());
				 throw emptyAddressesError(location, dittoHeaders);
			 }
		 }
		);
		 connection.getTargets().forEach(target -> {
			 if (target.getAddress().isEmpty()) {
				 final String location = String.format(""Targets of connection <%s>"", connection.getId());
				 throw emptyAddressesError(location, dittoHeaders);
			 }
			 target.getTopics().forEach(topic -> topic.getFilter().ifPresent(filter -> {
				 queryFilterCriteriaFactory.filterCriteria(filter, dittoHeaders);
			 }
			));
		 }
		);
	 }
	 private static void validateFormatOfCertificates(final Connection connection, final DittoHeaders dittoHeaders) {
		 final Optional<String> trustedCertificates = connection.getTrustedCertificates();
		 final Optional<Credentials> credentials = connection.getCredentials();
		 if (trustedCertificates.isPresent() || credentials.isPresent()) {
			 credentials.orElseGet(ClientCertificateCredentials::empty) .accept(SSLContextCreator.fromConnection(connection, dittoHeaders));
		 }
	 }
	 private static DittoRuntimeException emptyAddressesError(final String location, final DittoHeaders dittoHeaders) {
		 final String message = location + "": addresses may not be empty."";
		 return ConnectionConfigurationInvalidException.newBuilder(message) .dittoHeaders(dittoHeaders) .build();
	 }
}",1,0,0,0
"public class XPathQueryCacheLoader implements CacheLoader<ImmutablePair<String, String>, XPathExecutable> {
	 private static final Logger log = LoggerFactory.getLogger(XPathQueryCacheLoader.class);
	 public XPathExecutable load(ImmutablePair<String, String> key) throws Exception {
		 String xPathQuery = key.left;
		 String namespacesString = key.right;
		 Processor processor = XPathUtil.getProcessor();
		 XPathCompiler xPathCompiler = processor.newXPathCompiler();
		 List<String[]> namespacesList = XPathUtil.namespacesParse(namespacesString);
		 log.debug(""Parsed namespaces:{
		}
		 into list of namespaces:{
		}
		"", namespacesString, namespacesList);
		 for (String[] namespaces : namespacesList) {
			 xPathCompiler.declareNamespace(namespaces[0], namespaces[1]);
		 }
		 log.debug(""Declared namespaces:{
		}
		, now compiling xPathQuery:{
		}
		"", namespacesList, xPathQuery);
		 return xPathCompiler.compile(xPathQuery);
	 }
}",0,0,0,0
"public class ServletEndpointDiscovererextends EndpointDiscoverer<ExposableServletEndpoint, Operation>implements ServletEndpointsSupplier {
	private final List<PathMapper> endpointPathMappers;
	public ServletEndpointDiscoverer(ApplicationContext applicationContext,List<PathMapper> endpointPathMappers,Collection<EndpointFilter<ExposableServletEndpoint>> filters) {
		super(applicationContext, ParameterValueMapper.NONE, Collections.emptyList(),filters);
		this.endpointPathMappers = endpointPathMappers;
	}
	protected boolean isEndpointExposed(Object endpointBean) {
		Class<?> type = ClassUtils.getUserClass(endpointBean.getClass());
		return AnnotatedElementUtils.isAnnotated(type, ServletEndpoint.class);
	}
	protected ExposableServletEndpoint createEndpoint(Object endpointBean, EndpointId id,boolean enabledByDefault, Collection<Operation> operations) {
		String rootPath = PathMapper.getRootPath(this.endpointPathMappers, id);
		return new DiscoveredServletEndpoint(this, endpointBean, id, rootPath,enabledByDefault);
	}
	protected Operation createOperation(EndpointId endpointId,DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
		throw new IllegalStateException(""ServletEndpoints must not declare operations"");
	}
	protected OperationKey createOperationKey(Operation operation) {
		throw new IllegalStateException(""ServletEndpoints must not declare operations"");
	}
}",0,0,0,0
"public class BasicBundleInfo {
	 private String pkgName;
	 private String unique_tag;
	 private String applicationName;
	 private String version;
	 public Boolean getIsMBundle() {
		 return isMBundle;
	 }
	 public void setIsMBundle(boolean mainBundle) {
		 isMBundle = mainBundle;
	 }
	 private Boolean isMBundle = false;
	 private List<String> dependency = Lists.newArrayList();
	 private List<String> activities = Lists.newArrayList();
	 private List<String> services = Lists.newArrayList();
	 private List<String> receivers = Lists.newArrayList();
	 private List<String> contentProviders = Lists.newArrayList();
	 private HashMap<String,String> remoteFragments= new HashMap<String,String>();
	 private HashMap<String,String> remoteViews = new HashMap<String,String>();
	 private HashMap<String,String> remoteTransactors = new HashMap<String,String>();
	 private Boolean isInternal = true;
	 public HashMap<String, String> getRemoteViews() {
		 return remoteViews;
	 }
	 public void setRemoteViews(HashMap<String, String> remoteViews) {
		 this.remoteViews = remoteViews;
	 }
	 public HashMap<String, String> getRemoteTransactors() {
		 return remoteTransactors;
	 }
	 public void setRemoteTransactors(HashMap<String, String> remoteTransactors) {
		 this.remoteTransactors = remoteTransactors;
	 }
	 public HashMap<String, String> getRemoteFragments() {
		 return remoteFragments;
	 }
	 public void setRemoteFragments(HashMap<String, String> remoteFragments) {
		 this.remoteFragments = remoteFragments;
	 }
	 public String getPkgName() {
		 return pkgName;
	 }
	 public void setPkgName(String pkgName) {
		 this.pkgName = pkgName;
	 }
	 public String getApplicationName() {
		 return applicationName;
	 }
	 public void setApplicationName(String applicationName) {
		 this.applicationName = applicationName;
	 }
	 public String getVersion() {
		 return version;
	 }
	 public void setVersion(String version) {
		 this.version = version;
	 }
	 public List<String> getDependency() {
		 return dependency;
	 }
	 public void setDependency(List<String> dependency) {
		 this.dependency = dependency;
	 }
	 public List<String> getActivities() {
		 return activities;
	 }
	 public void setActivities(List<String> activities) {
		 this.activities = activities;
	 }
	 public List<String> getServices() {
		 return services;
	 }
	 public void setServices(List<String> services) {
		 this.services = services;
	 }
	 public List<String> getReceivers() {
		 return receivers;
	 }
	 public void setReceivers(List<String> receivers) {
		 this.receivers = receivers;
	 }
	 public List<String> getContentProviders() {
		 return contentProviders;
	 }
	 public void setContentProviders(List<String> contentProviders) {
		 this.contentProviders = contentProviders;
	 }
	 public boolean getIsInternal() {
		 return isInternal;
	 }
	 public void setIsInternal(boolean internal) {
		 isInternal = internal;
	 }
	 public String getUnique_tag() {
		 return unique_tag;
	 }
	 public void setUnique_tag(String unique_tag) {
		 this.unique_tag = unique_tag;
	 }
}",0,1,0,0
"public boolean checkLicenseHeader(File file){
	String header = extractLicenseHeader(file, 0, 16);
	return getLicenseHeader().equals(header);
}",0,0,0,0
"public class BookKeeper implements org.apache.bookkeeper.client.api.BookKeeper {
	 private static final Logger LOG = LoggerFactory.getLogger(BookKeeper.class);
	 final EventLoopGroup eventLoopGroup;
	 private final ByteBufAllocator allocator;
	 private final StatsLogger statsLogger;
	 private final BookKeeperClientStats clientStats;
	 boolean ownEventLoopGroup = false;
	 final BookieClient bookieClient;
	 final BookieWatcherImpl bookieWatcher;
	 final OrderedExecutor mainWorkerPool;
	 final OrderedScheduler scheduler;
	 final HashedWheelTimer requestTimer;
	 final boolean ownTimer;
	 final FeatureProvider featureProvider;
	 final ScheduledExecutorService bookieInfoScheduler;
	 final MetadataClientDriver metadataDriver;
	 final LedgerManagerFactory ledgerManagerFactory;
	 final LedgerManager ledgerManager;
	 final LedgerIdGenerator ledgerIdGenerator;
	 final EnsemblePlacementPolicy placementPolicy;
	 BookieInfoReader bookieInfoReader;
	 final ClientConfiguration conf;
	 final ClientInternalConf internalConf;
	 boolean closed = false;
	 final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();
	 public static class Builder {
		 final ClientConfiguration conf;
		 ZooKeeper zk = null;
		 EventLoopGroup eventLoopGroup = null;
		 ByteBufAllocator allocator = null;
		 StatsLogger statsLogger = NullStatsLogger.INSTANCE;
		 DNSToSwitchMapping dnsResolver = null;
		 HashedWheelTimer requestTimer = null;
		 FeatureProvider featureProvider = null;
		 Builder(ClientConfiguration conf) {
			 this.conf = conf;
		 }
		 public Builder setEventLoopGroup(EventLoopGroup f) {
			 eventLoopGroup = f;
			 return this;
		 }
		 public Builder setZookeeper(ZooKeeper zk) {
			 this.zk = zk;
			 return this;
		 }
		 public Builder setStatsLogger(StatsLogger statsLogger) {
			 this.statsLogger = statsLogger;
			 return this;
		 }
		 public Builder eventLoopGroup(EventLoopGroup f) {
			 eventLoopGroup = f;
			 return this;
		 }
		 public Builder allocator(ByteBufAllocator allocator) {
			 this.allocator = allocator;
			 return this;
		 }
		 public Builder zk(ZooKeeper zk) {
			 this.zk = zk;
			 return this;
		 }
		 public Builder statsLogger(StatsLogger statsLogger) {
			 this.statsLogger = statsLogger;
			 return this;
		 }
		 public Builder dnsResolver(DNSToSwitchMapping dnsResolver) {
			 this.dnsResolver = dnsResolver;
			 return this;
		 }
		 public Builder requestTimer(HashedWheelTimer requestTimer) {
			 this.requestTimer = requestTimer;
			 return this;
		 }
		 public Builder featureProvider(FeatureProvider featureProvider) {
			 this.featureProvider = featureProvider;
			 return this;
		 }
		 public BookKeeper build() throws IOException, InterruptedException, BKException {
			 checkNotNull(statsLogger, ""No stats logger provided"");
			 return new BookKeeper(conf, zk, eventLoopGroup, allocator, statsLogger, dnsResolver, requestTimer, featureProvider);
		 }
	 }
	 public static Builder forConfig(final ClientConfiguration conf) {
		 return new Builder(conf);
	 }
	 public BookKeeper(String servers) throws IOException, InterruptedException, BKException {
	 this(new ClientConfiguration().setMetadataServiceUri(""zk+null: }
	 public BookKeeper(final ClientConfiguration conf) throws IOException, InterruptedException, BKException {
		 this(conf, null, null, null, NullStatsLogger.INSTANCE, null, null, null);
	 }
	 private static ZooKeeper validateZooKeeper(ZooKeeper zk) throws NullPointerException, IOException {
		 checkNotNull(zk, ""No zookeeper instance provided"");
		 if (!zk.getState().isConnected()) {
			 LOG.error(""Unconnected zookeeper handle passed to bookkeeper"");
			 throw new IOException(KeeperException.create(KeeperException.Code.CONNECTIONLOSS));
		 }
		 return zk;
	 }
	 private static EventLoopGroup validateEventLoopGroup(EventLoopGroup eventLoopGroup) throws NullPointerException {
		 checkNotNull(eventLoopGroup, ""No Event Loop Group provided"");
		 return eventLoopGroup;
	 }
	 public BookKeeper(ClientConfiguration conf, ZooKeeper zk) throws IOException, InterruptedException, BKException {
		 this(conf, validateZooKeeper(zk), null, null, NullStatsLogger.INSTANCE, null, null, null);
	 }
	 public BookKeeper(ClientConfiguration conf, ZooKeeper zk, EventLoopGroup eventLoopGroup) throws IOException, InterruptedException, BKException {
		 this(conf, validateZooKeeper(zk), validateEventLoopGroup(eventLoopGroup), null, NullStatsLogger.INSTANCE, null, null, null);
	 }
	 BookKeeper(ClientConfiguration conf, ZooKeeper zkc, EventLoopGroup eventLoopGroup, ByteBufAllocator byteBufAllocator, StatsLogger rootStatsLogger, DNSToSwitchMapping dnsResolver, HashedWheelTimer requestTimer, FeatureProvider featureProvider) throws IOException, InterruptedException, BKException {
		 this.conf = conf;
		 if (null == featureProvider) {
			 this.featureProvider = SettableFeatureProvider.DISABLE_ALL;
		 }
		 else {
			 this.featureProvider = featureProvider;
		 }
		 this.internalConf = ClientInternalConf.fromConfigAndFeatureProvider(conf, this.featureProvider);
		 this.scheduler = OrderedScheduler.newSchedulerBuilder().numThreads(1).name(""BookKeeperClientScheduler"").build();
		 this.mainWorkerPool = OrderedExecutor.newBuilder() .name(""BookKeeperClientWorker"") .numThreads(conf.getNumWorkerThreads()) .statsLogger(rootStatsLogger) .traceTaskExecution(conf.getEnableTaskExecutionStats()) .preserveMdcForTaskExecution(conf.getPreserveMdcForTaskExecution()) .traceTaskWarnTimeMicroSec(conf.getTaskExecutionWarnTimeMicros()) .enableBusyWait(conf.isBusyWaitEnabled()) .build();
		 this.statsLogger = rootStatsLogger.scope(BookKeeperClientStats.CLIENT_SCOPE);
		 this.clientStats = BookKeeperClientStats.newInstance(this.statsLogger);
		 try {
			 String metadataServiceUriStr = conf.getMetadataServiceUri();
			 if (null != metadataServiceUriStr) {
				 this.metadataDriver = MetadataDrivers.getClientDriver(URI.create(metadataServiceUriStr));
			 }
			 else {
				 checkNotNull(zkc, ""No external zookeeper provided when no metadata service uri is found"");
				 this.metadataDriver = MetadataDrivers.getClientDriver(""zk"");
			 }
			 this.metadataDriver.initialize( conf, scheduler, rootStatsLogger, java.util.Optional.ofNullable(zkc));
		 }
		 catch (ConfigurationException ce) {
			 LOG.error(""Failed to initialize metadata client driver using invalid metadata service uri"", ce);
			 throw new IOException(""Failed to initialize metadata client driver"", ce);
		 }
		 catch (MetadataException me) {
			 LOG.error(""Encountered metadata exceptions on initializing metadata client driver"", me);
			 throw new IOException(""Failed to initialize metadata client driver"", me);
		 }
		 if (null == eventLoopGroup) {
			 this.eventLoopGroup = EventLoopUtil.getClientEventLoopGroup(conf, new DefaultThreadFactory(""bookkeeper-io""));
			 this.ownEventLoopGroup = true;
		 }
		 else {
			 this.eventLoopGroup = eventLoopGroup;
			 this.ownEventLoopGroup = false;
		 }
		 if (byteBufAllocator != null) {
			 this.allocator = byteBufAllocator;
		 }
		 else {
			 this.allocator = ByteBufAllocatorBuilder.create() .poolingPolicy(conf.getAllocatorPoolingPolicy()) .poolingConcurrency(conf.getAllocatorPoolingConcurrency()) .outOfMemoryPolicy(conf.getAllocatorOutOfMemoryPolicy()) .leakDetectionPolicy(conf.getAllocatorLeakDetectionPolicy()) .build();
		 }
		 this.bookieClient = new BookieClientImpl(conf, this.eventLoopGroup, this.allocator, this.mainWorkerPool, scheduler, rootStatsLogger);
		 if (null == requestTimer) {
			 this.requestTimer = new HashedWheelTimer( new ThreadFactoryBuilder().setNameFormat(""BookieClientTimer-%d"").build(), conf.getTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS, conf.getTimeoutTimerNumTicks());
			 this.ownTimer = true;
		 }
		 else {
			 this.requestTimer = requestTimer;
			 this.ownTimer = false;
		 }
		 this.placementPolicy = initializeEnsemblePlacementPolicy(conf, dnsResolver, this.requestTimer, this.featureProvider, this.statsLogger);
		 this.bookieWatcher = new BookieWatcherImpl( conf, this.placementPolicy, metadataDriver.getRegistrationClient(), this.statsLogger.scope(WATCHER_SCOPE));
		 if (conf.getDiskWeightBasedPlacementEnabled()) {
			 LOG.info(""Weighted ledger placement enabled"");
			 ThreadFactoryBuilder tFBuilder = new ThreadFactoryBuilder() .setNameFormat(""BKClientMetaDataPollScheduler-%d"");
			 this.bookieInfoScheduler = Executors.newSingleThreadScheduledExecutor(tFBuilder.build());
			 this.bookieInfoReader = new BookieInfoReader(this, conf, this.bookieInfoScheduler);
			 this.bookieWatcher.initialBlockingBookieRead();
			 this.bookieInfoReader.start();
		 }
		 else {
			 LOG.info(""Weighted ledger placement is not enabled"");
			 this.bookieInfoScheduler = null;
			 this.bookieInfoReader = new BookieInfoReader(this, conf, null);
			 this.bookieWatcher.initialBlockingBookieRead();
		 }
		 try {
			 this.ledgerManagerFactory = this.metadataDriver.getLedgerManagerFactory();
		 }
		 catch (MetadataException e) {
			 throw new IOException(""Failed to initialize ledger manager factory"", e);
		 }
		 this.ledgerManager = new CleanupLedgerManager(ledgerManagerFactory.newLedgerManager());
		 this.ledgerIdGenerator = ledgerManagerFactory.newLedgerIdGenerator();
		 scheduleBookieHealthCheckIfEnabled(conf);
	 }
	 BookKeeper() {
		 conf = new ClientConfiguration();
		 internalConf = ClientInternalConf.fromConfig(conf);
		 statsLogger = NullStatsLogger.INSTANCE;
		 clientStats = BookKeeperClientStats.newInstance(statsLogger);
		 scheduler = null;
		 requestTimer = null;
		 metadataDriver = null;
		 placementPolicy = null;
		 ownTimer = false;
		 mainWorkerPool = null;
		 ledgerManagerFactory = null;
		 ledgerManager = null;
		 ledgerIdGenerator = null;
		 featureProvider = null;
		 eventLoopGroup = null;
		 bookieWatcher = null;
		 bookieInfoScheduler = null;
		 bookieClient = null;
		 allocator = UnpooledByteBufAllocator.DEFAULT;
	 }
	 private EnsemblePlacementPolicy initializeEnsemblePlacementPolicy(ClientConfiguration conf, DNSToSwitchMapping dnsResolver, HashedWheelTimer timer, FeatureProvider featureProvider, StatsLogger statsLogger) throws IOException {
		 try {
			 Class<? extends EnsemblePlacementPolicy> policyCls = conf.getEnsemblePlacementPolicy();
			 return ReflectionUtils.newInstance(policyCls).initialize(conf, java.util.Optional.ofNullable(dnsResolver), timer, featureProvider, statsLogger);
		 }
		 catch (ConfigurationException e) {
			 throw new IOException(""Failed to initialize ensemble placement policy : "", e);
		 }
	 }
	 int getReturnRc(int rc) {
		 return getReturnRc(bookieClient, rc);
	 }
	 static int getReturnRc(BookieClient bookieClient, int rc) {
		 if (BKException.Code.OK == rc) {
			 return rc;
		 }
		 else {
			 if (bookieClient.isClosed()) {
				 return BKException.Code.ClientClosedException;
			 }
			 else {
				 return rc;
			 }
		 }
	 }
	 void scheduleBookieHealthCheckIfEnabled(ClientConfiguration conf) {
		 if (conf.isBookieHealthCheckEnabled()) {
			 scheduler.scheduleAtFixedRate(new SafeRunnable() {
				 public void safeRun() {
					 checkForFaultyBookies();
				 }
			 }
			, conf.getBookieHealthCheckIntervalSeconds(), conf.getBookieHealthCheckIntervalSeconds(), TimeUnit.SECONDS);
		 }
	 }
	 void checkForFaultyBookies() {
		 List<BookieSocketAddress> faultyBookies = bookieClient.getFaultyBookies();
		 for (BookieSocketAddress faultyBookie : faultyBookies) {
			 bookieWatcher.quarantineBookie(faultyBookie);
		 }
	 }
	 public LedgerManager getLedgerManager() {
		 return ledgerManager;
	 }
	 LedgerManager getUnderlyingLedgerManager() {
		 return ((CleanupLedgerManager) ledgerManager).getUnderlying();
	 }
	 LedgerIdGenerator getLedgerIdGenerator() {
		 return ledgerIdGenerator;
	 }
	 ReentrantReadWriteLock getCloseLock() {
		 return closeLock;
	 }
	 boolean isClosed() {
		 return closed;
	 }
	 BookieWatcher getBookieWatcher() {
		 return bookieWatcher;
	 }
	 public OrderedExecutor getMainWorkerPool() {
		 return mainWorkerPool;
	 }
	 OrderedScheduler getScheduler() {
		 return scheduler;
	 }
	 EnsemblePlacementPolicy getPlacementPolicy() {
		 return placementPolicy;
	 }
	 public MetadataClientDriver getMetadataClientDriver() {
		 return metadataDriver;
	 }
	 public enum DigestType {
		 MAC, CRC32, CRC32C, DUMMY;
		 public static DigestType fromApiDigestType(org.apache.bookkeeper.client.api.DigestType digestType) {
			 switch (digestType) {
				 case MAC: return DigestType.MAC;
				 case CRC32: return DigestType.CRC32;
				 case CRC32C: return DigestType.CRC32C;
				 case DUMMY: return DigestType.DUMMY;
				 default: throw new IllegalArgumentException(""Unable to convert digest type "" + digestType);
			 }
		 }
		 public static DataFormats.LedgerMetadataFormat.DigestType toProtoDigestType(DigestType digestType) {
			 switch (digestType) {
				 case MAC: return DataFormats.LedgerMetadataFormat.DigestType.HMAC;
				 case CRC32: return DataFormats.LedgerMetadataFormat.DigestType.CRC32;
				 case CRC32C: return DataFormats.LedgerMetadataFormat.DigestType.CRC32C;
				 case DUMMY: return DataFormats.LedgerMetadataFormat.DigestType.DUMMY;
				 default: throw new IllegalArgumentException(""Unable to convert digest type "" + digestType);
			 }
		 }
		 public org.apache.bookkeeper.client.api.DigestType toApiDigestType() {
			 switch (this) {
				 case MAC: return org.apache.bookkeeper.client.api.DigestType.MAC;
				 case CRC32: return org.apache.bookkeeper.client.api.DigestType.CRC32;
				 case CRC32C: return org.apache.bookkeeper.client.api.DigestType.CRC32C;
				 case DUMMY: return org.apache.bookkeeper.client.api.DigestType.DUMMY;
				 default: throw new IllegalArgumentException(""Unable to convert digest type "" + this);
			 }
		 }
	 }
	 ZooKeeper getZkHandle() {
		 return ((ZKMetadataClientDriver) metadataDriver).getZk();
	 }
	 protected ClientConfiguration getConf() {
		 return conf;
	 }
	 StatsLogger getStatsLogger() {
		 return statsLogger;
	 }
	 BookieClient getBookieClient() {
		 return bookieClient;
	 }
	 public Map<BookieSocketAddress, BookieInfo> getBookieInfo() throws BKException, InterruptedException {
		 return bookieInfoReader.getBookieInfo();
	 }
	 public void asyncCreateLedger(final int ensSize, final int writeQuorumSize, final DigestType digestType, final byte[] passwd, final CreateCallback cb, final Object ctx) {
		 asyncCreateLedger(ensSize, writeQuorumSize, writeQuorumSize, digestType, passwd, cb, ctx, Collections.emptyMap());
	 }
	 public void asyncCreateLedger(final int ensSize, final int writeQuorumSize, final int ackQuorumSize, final DigestType digestType, final byte[] passwd, final CreateCallback cb, final Object ctx, final Map<String, byte[]> customMetadata) {
		 if (writeQuorumSize < ackQuorumSize) {
			 throw new IllegalArgumentException(""Write quorum must be larger than ack quorum"");
		 }
		 closeLock.readLock().lock();
		 try {
			 if (closed) {
				 cb.createComplete(BKException.Code.ClientClosedException, null, ctx);
				 return;
			 }
			 new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, cb, ctx, customMetadata, WriteFlag.NONE, clientStats) .initiate();
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 public LedgerHandle createLedger(DigestType digestType, byte passwd[]) throws BKException, InterruptedException {
		 return createLedger(3, 2, digestType, passwd);
	 }
	 public LedgerHandle createLedger(int ensSize, int qSize, DigestType digestType, byte passwd[]) throws InterruptedException, BKException {
		 return createLedger(ensSize, qSize, qSize, digestType, passwd, Collections.emptyMap());
	 }
	 public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, byte passwd[]) throws InterruptedException, BKException {
		 return createLedger(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, Collections.emptyMap());
	 }
	 public LedgerHandle createLedger(int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, byte passwd[], final Map<String, byte[]> customMetadata) throws InterruptedException, BKException {
		 CompletableFuture<LedgerHandle> future = new CompletableFuture<>();
		 SyncCreateCallback result = new SyncCreateCallback(future);
		 asyncCreateLedger(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, result, null, customMetadata);
		 LedgerHandle lh = SyncCallbackUtils.waitForResult(future);
		 if (lh == null) {
			 LOG.error(""Unexpected condition : no ledger handle returned for a success ledger creation"");
			 throw BKException.create(BKException.Code.UnexpectedConditionException);
		 }
		 return lh;
	 }
	 public LedgerHandle createLedgerAdv(int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, byte passwd[]) throws InterruptedException, BKException {
		 return createLedgerAdv(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, Collections.emptyMap());
	 }
	 public LedgerHandle createLedgerAdv(int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, byte passwd[], final Map<String, byte[]> customMetadata) throws InterruptedException, BKException {
		 CompletableFuture<LedgerHandleAdv> future = new CompletableFuture<>();
		 SyncCreateAdvCallback result = new SyncCreateAdvCallback(future);
		 asyncCreateLedgerAdv(ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, result, null, customMetadata);
		 LedgerHandle lh = SyncCallbackUtils.waitForResult(future);
		 if (lh == null) {
			 LOG.error(""Unexpected condition : no ledger handle returned for a success ledger creation"");
			 throw BKException.create(BKException.Code.UnexpectedConditionException);
		 }
		 return lh;
	 }
	 public void asyncCreateLedgerAdv(final int ensSize, final int writeQuorumSize, final int ackQuorumSize, final DigestType digestType, final byte[] passwd, final CreateCallback cb, final Object ctx, final Map<String, byte[]> customMetadata) {
		 if (writeQuorumSize < ackQuorumSize) {
			 throw new IllegalArgumentException(""Write quorum must be larger than ack quorum"");
		 }
		 closeLock.readLock().lock();
		 try {
			 if (closed) {
				 cb.createComplete(BKException.Code.ClientClosedException, null, ctx);
				 return;
			 }
			 new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, cb, ctx, customMetadata, WriteFlag.NONE, clientStats) .initiateAdv(-1L);
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 public LedgerHandle createLedgerAdv(final long ledgerId, int ensSize, int writeQuorumSize, int ackQuorumSize, DigestType digestType, byte passwd[], final Map<String, byte[]> customMetadata) throws InterruptedException, BKException {
		 CompletableFuture<LedgerHandleAdv> future = new CompletableFuture<>();
		 SyncCreateAdvCallback result = new SyncCreateAdvCallback(future);
		 asyncCreateLedgerAdv(ledgerId, ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, result, null, customMetadata);
		 LedgerHandle lh = SyncCallbackUtils.waitForResult(future);
		 if (lh == null) {
			 LOG.error(""Unexpected condition : no ledger handle returned for a success ledger creation"");
			 throw BKException.create(BKException.Code.UnexpectedConditionException);
		 }
		 else if (ledgerId != lh.getId()) {
			 LOG.error(""Unexpected condition : Expected ledgerId: {
			}
			 but got: {
			}
			"", ledgerId, lh.getId());
			 throw BKException.create(BKException.Code.UnexpectedConditionException);
		 }
		 LOG.info(""Ensemble: {
		}
		 for ledger: {
		}
		"", lh.getLedgerMetadata().getEnsembleAt(0L), lh.getId());
		 return lh;
	 }
	 public void asyncCreateLedgerAdv(final long ledgerId, final int ensSize, final int writeQuorumSize, final int ackQuorumSize, final DigestType digestType, final byte[] passwd, final CreateCallback cb, final Object ctx, final Map<String, byte[]> customMetadata) {
		 if (writeQuorumSize < ackQuorumSize) {
			 throw new IllegalArgumentException(""Write quorum must be larger than ack quorum"");
		 }
		 closeLock.readLock().lock();
		 try {
			 if (closed) {
				 cb.createComplete(BKException.Code.ClientClosedException, null, ctx);
				 return;
			 }
			 new LedgerCreateOp(BookKeeper.this, ensSize, writeQuorumSize, ackQuorumSize, digestType, passwd, cb, ctx, customMetadata, WriteFlag.NONE, clientStats) .initiateAdv(ledgerId);
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 public void asyncOpenLedger(final long lId, final DigestType digestType, final byte passwd[], final OpenCallback cb, final Object ctx) {
		 closeLock.readLock().lock();
		 try {
			 if (closed) {
				 cb.openComplete(BKException.Code.ClientClosedException, null, ctx);
				 return;
			 }
			 new LedgerOpenOp(BookKeeper.this, clientStats, lId, digestType, passwd, cb, ctx).initiate();
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 public void asyncOpenLedgerNoRecovery(final long lId, final DigestType digestType, final byte passwd[], final OpenCallback cb, final Object ctx) {
		 closeLock.readLock().lock();
		 try {
			 if (closed) {
				 cb.openComplete(BKException.Code.ClientClosedException, null, ctx);
				 return;
			 }
			 new LedgerOpenOp(BookKeeper.this, clientStats, lId, digestType, passwd, cb, ctx).initiateWithoutRecovery();
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 public LedgerHandle openLedger(long lId, DigestType digestType, byte passwd[]) throws BKException, InterruptedException {
		 CompletableFuture<LedgerHandle> future = new CompletableFuture<>();
		 SyncOpenCallback result = new SyncOpenCallback(future);
		 asyncOpenLedger(lId, digestType, passwd, result, null);
		 return SyncCallbackUtils.waitForResult(future);
	 }
	 public LedgerHandle openLedgerNoRecovery(long lId, DigestType digestType, byte passwd[]) throws BKException, InterruptedException {
		 CompletableFuture<LedgerHandle> future = new CompletableFuture<>();
		 SyncOpenCallback result = new SyncOpenCallback(future);
		 asyncOpenLedgerNoRecovery(lId, digestType, passwd, result, null);
		 return SyncCallbackUtils.waitForResult(future);
	 }
	 public void asyncDeleteLedger(final long lId, final DeleteCallback cb, final Object ctx) {
		 closeLock.readLock().lock();
		 try {
			 if (closed) {
				 cb.deleteComplete(BKException.Code.ClientClosedException, ctx);
				 return;
			 }
			 new LedgerDeleteOp(BookKeeper.this, clientStats, lId, cb, ctx).initiate();
		 }
		 finally {
			 closeLock.readLock().unlock();
		 }
	 }
	 public void deleteLedger(long lId) throws InterruptedException, BKException {
		 CompletableFuture<Void> future = new CompletableFuture<>();
		 SyncDeleteCallback result = new SyncDeleteCallback(future);
		 asyncDeleteLedger(lId, result, null);
		 SyncCallbackUtils.waitForResult(future);
	 }
	 public void asyncIsClosed(long lId, final IsClosedCallback cb, final Object ctx){
		 ledgerManager.readLedgerMetadata(lId).whenComplete((metadata, exception) -> {
			 if (exception == null) {
				 cb.isClosedComplete(BKException.Code.OK, metadata.getValue().isClosed(), ctx);
			 }
			 else {
				 cb.isClosedComplete(BKException.getExceptionCode(exception), false, ctx);
			 }
		 }
		);
	 }
	 public boolean isClosed(long lId) throws BKException, InterruptedException {
		 final class Result {
			 int rc;
			 boolean isClosed;
			 final CountDownLatch notifier = new CountDownLatch(1);
		 }
		 final Result result = new Result();
		 final IsClosedCallback cb = new IsClosedCallback(){
			 public void isClosedComplete(int rc, boolean isClosed, Object ctx){
				 result.isClosed = isClosed;
				 result.rc = rc;
				 result.notifier.countDown();
			 }
		 }
		;
		 asyncIsClosed(lId, cb, null);
		 result.notifier.await();
		 if (result.rc != BKException.Code.OK) {
			 throw BKException.create(result.rc);
		 }
		 return result.isClosed;
	 }
	 public void close() throws BKException, InterruptedException {
		 closeLock.writeLock().lock();
		 try {
			 if (closed) {
				 return;
			 }
			 closed = true;
		 }
		 finally {
			 closeLock.writeLock().unlock();
		 }
		 bookieClient.close();
		 try {
			 ledgerManager.close();
			 ledgerIdGenerator.close();
		 }
		 catch (IOException ie) {
			 LOG.error(""Failed to close ledger manager : "", ie);
		 }
		 scheduler.shutdown();
		 if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
			 LOG.warn(""The scheduler did not shutdown cleanly"");
		 }
		 mainWorkerPool.shutdown();
		 if (!mainWorkerPool.awaitTermination(10, TimeUnit.SECONDS)) {
			 LOG.warn(""The mainWorkerPool did not shutdown cleanly"");
		 }
		 if (this.bookieInfoScheduler != null) {
			 this.bookieInfoScheduler.shutdown();
			 if (!bookieInfoScheduler.awaitTermination(10, TimeUnit.SECONDS)) {
				 LOG.warn(""The bookieInfoScheduler did not shutdown cleanly"");
			 }
		 }
		 if (ownTimer) {
			 requestTimer.stop();
		 }
		 if (ownEventLoopGroup) {
			 eventLoopGroup.shutdownGracefully();
		 }
		 this.metadataDriver.close();
	 }
	 public CreateBuilder newCreateLedgerOp() {
		 return new LedgerCreateOp.CreateBuilderImpl(this);
	 }
	 public OpenBuilder newOpenLedgerOp() {
		 return new LedgerOpenOp.OpenBuilderImpl(this);
	 }
	 public DeleteBuilder newDeleteLedgerOp() {
		 return new LedgerDeleteOp.DeleteBuilderImpl(this);
	 }
	 private final ClientContext clientCtx = new ClientContext() {
		 public ClientInternalConf getConf() {
			 return internalConf;
		 }
		 public LedgerManager getLedgerManager() {
			 return BookKeeper.this.getLedgerManager();
		 }
		 public BookieWatcher getBookieWatcher() {
			 return BookKeeper.this.getBookieWatcher();
		 }
		 public EnsemblePlacementPolicy getPlacementPolicy() {
			 return BookKeeper.this.getPlacementPolicy();
		 }
		 public BookieClient getBookieClient() {
			 return BookKeeper.this.getBookieClient();
		 }
		 public OrderedExecutor getMainWorkerPool() {
			 return BookKeeper.this.getMainWorkerPool();
		 }
		 public OrderedScheduler getScheduler() {
			 return BookKeeper.this.getScheduler();
		 }
		 public BookKeeperClientStats getClientStats() {
			 return clientStats;
		 }
		 public boolean isClientClosed() {
			 return BookKeeper.this.isClosed();
		 }
		 public ByteBufAllocator getByteBufAllocator() {
			 return allocator;
		 }
	 }
	;
	 ClientContext getClientCtx() {
		 return clientCtx;
	 }
}",1,1,0,0
"public void saveDownloadList(File file) {
	int count = downloads.size();
	BufferedWriter writer = null;
	SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");
	String newLine = System.getProperty(""line.separator"");
	try {
		writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), Charset.forName(""UTF-8"")));
		writer.write(count + """");
		writer.newLine();
		Iterator<String> keyIterator = downloads.keySet().iterator();
		while (keyIterator.hasNext()) {
			String key = keyIterator.next();
			DownloadEntry ent = downloads.get(key);
			int c = 0;
			StringBuffer sb = new StringBuffer();
			sb.append(""id: "" + ent.getId() + newLine);
			c++;
			sb.append(""file: "" + ent.getFile() + newLine);
			c++;
			sb.append(""category: "" + ent.getCategory() + newLine);
			c++;
			sb.append(""state: "" + ent.getState() + newLine);
			c++;
			sb.append(""folder: "" + ent.getFolder() + newLine);
			c++;
			sb.append(""date: "" + dateFormat.format(new Date(ent.getDate())) + newLine);
			c++;
			sb.append(""downloaded: "" + ent.getDownloaded() + newLine);
			c++;
			sb.append(""size: "" + ent.getSize() + newLine);
			c++;
			sb.append(""progress: "" + ent.getProgress() + newLine);
			c++;
			if (ent.getQueueId() != null) {
				sb.append(""queueid: "" + ent.getQueueId() + newLine);
				c++;
			}
			sb.append(""formatIndex: "" + ent.getOutputFormatIndex() + newLine);
			c++;
			writer.write(c + newLine);
			writer.write(sb.toString());
		}
		writer.close();
	}
	 catch (Exception e) {
		Logger.log(e);
		try {
			writer.close();
		}
		 catch (Exception e1) {
		}
	}
}",0,0,1,0
"private void describeKeySpace(String keySpaceName, KsDef metadata) throws TException {
	 NodeProbe probe = sessionState.getNodeProbe();
	 CompactionManagerMBean compactionManagerMBean = (probe == null) ? null : probe.getCompactionManagerProxy();
	 sessionState.out.println(""Keyspace: "" + keySpaceName + "":"");
	 try {
		 KsDef ks_def;
		 ks_def = metadata == null ? thriftClient.describe_keyspace(keySpaceName) : metadata;
		 sessionState.out.println("" Replication Strategy: "" + ks_def.strategy_class);
		 sessionState.out.println("" Durable Writes: "" + ks_def.durable_writes);
		 Map<String, String> options = ks_def.strategy_options;
		 sessionState.out.println("" Options: ["" + ((options == null) ? """" : FBUtilities.toString(options)) + ""]"");
		 sessionState.out.println("" Column Families:"");
		 boolean isSuper;
		 Collections.sort(ks_def.cf_defs, new CfDefNamesComparator());
		 for (CfDef cf_def : ks_def.cf_defs) {
			 ColumnFamilyStoreMBean cfMBean = (probe == null) ? null : probe.getCfsProxy(ks_def.getName(), cf_def.getName());
			 isSuper = cf_def.column_type.equals(""Super"");
			 sessionState.out.printf("" ColumnFamily: %s%s%n"", cf_def.name, isSuper ? "" (Super)"" : """");
			 if (cf_def.comment != null && !cf_def.comment.isEmpty()) {
				 sessionState.out.printf("" \""%s\""%n"", cf_def.comment);
			 }
			 if (cf_def.key_validation_class != null) sessionState.out.printf("" Key Validation Class: %s%n"", cf_def.key_validation_class);
			 if (cf_def.default_validation_class != null) sessionState.out.printf("" Default column value validator: %s%n"", cf_def.default_validation_class);
			 sessionState.out.printf("" Columns sorted by: %s%s%n"", cf_def.comparator_type, cf_def.column_type.equals(""Super"") ? ""/"" + cf_def.subcomparator_type : """");
			 sessionState.out.printf("" Row cache size / save period in seconds: %s/%s%n"", cf_def.row_cache_size, cf_def.row_cache_save_period_in_seconds);
			 sessionState.out.printf("" Key cache size / save period in seconds: %s/%s%n"", cf_def.key_cache_size, cf_def.key_cache_save_period_in_seconds);
			 sessionState.out.printf("" Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n"", cf_def.memtable_operations_in_millions, cf_def.memtable_flush_after_mins, cf_def.memtable_throughput_in_mb);
			 sessionState.out.printf("" GC grace seconds: %s%n"", cf_def.gc_grace_seconds);
			 sessionState.out.printf("" Compaction min/max thresholds: %s/%s%n"", cf_def.min_compaction_threshold, cf_def.max_compaction_threshold);
			 sessionState.out.printf("" Read repair chance: %s%n"", cf_def.read_repair_chance);
			 sessionState.out.printf("" Replicate on write: %s%n"", cf_def.replicate_on_write);
			 if (cfMBean != null) {
				 sessionState.out.printf("" Built indexes: %s%n"", cfMBean.getBuiltIndexes());
			 }
			 if (cf_def.getColumn_metadataSize() != 0) {
				 String leftSpace = "" "";
				 String columnLeftSpace = leftSpace + "" "";
				 String compareWith = isSuper ? cf_def.subcomparator_type : cf_def.comparator_type;
				 AbstractType columnNameValidator = getFormatType(compareWith);
				 sessionState.out.println(leftSpace + ""Column Metadata:"");
				 for (ColumnDef columnDef : cf_def.getColumn_metadata()) {
					 String columnName = columnNameValidator.getString(columnDef.name);
					 if (columnNameValidator instanceof BytesType) {
						 try {
							 String columnString = UTF8Type.instance.getString(columnDef.name);
							 columnName = columnString + "" ("" + columnName + "")"";
						 }
						 catch (MarshalException e) {
						 }
					 }
					 sessionState.out.println(leftSpace + "" Column Name: "" + columnName);
					 sessionState.out.println(columnLeftSpace + ""Validation Class: "" + columnDef.getValidation_class());
					 if (columnDef.isSetIndex_name()) {
						 sessionState.out.println(columnLeftSpace + ""Index Name: "" + columnDef.getIndex_name());
					 }
					 if (columnDef.isSetIndex_type()) {
						 sessionState.out.println(columnLeftSpace + ""Index Type: "" + columnDef.getIndex_type().name());
					 }
				 }
			 }
		 }
		 if (compactionManagerMBean != null) {
			 for (CompactionInfo info : compactionManagerMBean.getCompactions()) {
				 if (info.getTaskType() != CompactionType.INDEX_BUILD) continue;
				 sessionState.out.printf(""%nCurrently building index %s, completed %d of %d bytes.%n"", info.getColumnFamily(), info.getBytesComplete(), info.getTotalBytes());
			 }
		 }
		 if (probe != null) probe.close();
	 }
	 catch (InvalidRequestException e) {
		 sessionState.out.println(""Invalid request: "" + e);
	 }
	 catch (NotFoundException e) {
		 sessionState.out.println(""Keyspace "" + keySpaceName + "" could not be found."");
	 }
	 catch (IOException e) {
		 sessionState.out.println(""Error while closing JMX connection: "" + e.getMessage());
	 }
 }",0,0,1,0
"public final String readString() throws IOException{
	final InputStream in = new FileInputStream(this);
	try{
		return Streams.readString(in);
	}
	finally{
		in.close();
	}
}",0,0,0,0
"protected double getPreviousHeight(TableXYDataset dataset, int series, int index);",0,0,0,0
"private static class FieldMetaData {
	 public final FieldInfo fieldInfo;
	 public final long numTerms;
	 public final long sumTotalTermFreq;
	 public final long sumDocFreq;
	 public final int docCount;
	 public final int longsSize;
	 public final FST<FSTTermOutputs.TermData> dict;
	 public FieldMetaData(FieldInfo fieldInfo, long numTerms, long sumTotalTermFreq, long sumDocFreq, int docCount, int longsSize, FST<FSTTermOutputs.TermData> fst) {
		 this.fieldInfo = fieldInfo;
		 this.numTerms = numTerms;
		 this.sumTotalTermFreq = sumTotalTermFreq;
		 this.sumDocFreq = sumDocFreq;
		 this.docCount = docCount;
		 this.longsSize = longsSize;
		 this.dict = fst;
	 }
 }",0,1,0,0
"public class FlowRegionElement extends PrefixableStylableExtensionElement implements BatikExtConstants {
	 protected FlowRegionElement() {
	 }
	 public FlowRegionElement(String prefix, AbstractDocument owner) {
		 super(prefix, owner);
	 }
	 public String getLocalName() {
		 return BATIK_EXT_FLOW_REGION_TAG;
	 }
	 public String getNamespaceURI() {
		 return BATIK_12_NAMESPACE_URI;
	 }
	 protected Node newNode() {
		 return new FlowRegionElement();
	 }
}",0,0,0,0
"public class ELParserimplements ELParserTreeConstants, ELParserConstants {
	 protected JJTELParserState jjtree = new JJTELParserState();
	public static Node parse(String ref) throws ELException {
		 try {
			 return (new ELParser(new StringReader(ref))).CompositeExpression();
		 }
		 catch (ParseException pe) {
			 throw new ELException(pe.getMessage());
		 }
	 }
	 final public AstCompositeExpression CompositeExpression() throws ParseException {
		 AstCompositeExpression jjtn000 = new AstCompositeExpression(JJTCOMPOSITEEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 label_1: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LITERAL_EXPRESSION: case START_DYNAMIC_EXPRESSION: case START_DEFERRED_EXPRESSION: ;
					 break;
					 default: jj_la1[0] = jj_gen;
					 break label_1;
				 }
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case START_DEFERRED_EXPRESSION: DeferredExpression();
					 break;
					 case START_DYNAMIC_EXPRESSION: DynamicExpression();
					 break;
					 case LITERAL_EXPRESSION: LiteralExpression();
					 break;
					 default: jj_la1[1] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
			 jj_consume_token(0);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 {
				if (true) return jjtn000;
			}
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
		 throw new Error(""Missing return statement in function"");
	 }
	 final public void LiteralExpression() throws ParseException {
		 AstLiteralExpression jjtn000 = new AstLiteralExpression(JJTLITERALEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 try {
			 t = jj_consume_token(LITERAL_EXPRESSION);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtn000.setImage(t.image);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DeferredExpression() throws ParseException {
		 AstDeferredExpression jjtn000 = new AstDeferredExpression(JJTDEFERREDEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(START_DEFERRED_EXPRESSION);
			 Expression();
			 jj_consume_token(END_EXPRESSION);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void DynamicExpression() throws ParseException {
		 AstDynamicExpression jjtn000 = new AstDynamicExpression(JJTDYNAMICEXPRESSION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(START_DYNAMIC_EXPRESSION);
			 Expression();
			 jj_consume_token(END_EXPRESSION);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Expression() throws ParseException {
		 Choice();
	 }
	 final public void Choice() throws ParseException {
		 Or();
		 label_2: while (true) {
			 if (jj_2_1(3)) {
				 ;
			 }
			 else {
				 break label_2;
			 }
			 jj_consume_token(QUESTIONMARK);
			 Choice();
			 jj_consume_token(COLON);
			 AstChoice jjtn001 = new AstChoice(JJTCHOICE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 Choice();
			 }
			 catch (Throwable jjte001) {
				 if (jjtc001) {
					 jjtree.clearNodeScope(jjtn001);
					 jjtc001 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte001 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte001;
					}
				 }
				 if (jjte001 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte001;
					}
				 }
				 {
					if (true) throw (Error)jjte001;
				}
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 3);
				 }
			 }
		 }
	 }
	 final public void Or() throws ParseException {
		 And();
		 label_3: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case OR0: case OR1: ;
				 break;
				 default: jj_la1[2] = jj_gen;
				 break label_3;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case OR0: jj_consume_token(OR0);
				 break;
				 case OR1: jj_consume_token(OR1);
				 break;
				 default: jj_la1[3] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 AstOr jjtn001 = new AstOr(JJTOR);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 And();
			 }
			 catch (Throwable jjte001) {
				 if (jjtc001) {
					 jjtree.clearNodeScope(jjtn001);
					 jjtc001 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte001 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte001;
					}
				 }
				 if (jjte001 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte001;
					}
				 }
				 {
					if (true) throw (Error)jjte001;
				}
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
				 }
			 }
		 }
	 }
	 final public void And() throws ParseException {
		 Equality();
		 label_4: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AND0: case AND1: ;
				 break;
				 default: jj_la1[4] = jj_gen;
				 break label_4;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case AND0: jj_consume_token(AND0);
				 break;
				 case AND1: jj_consume_token(AND1);
				 break;
				 default: jj_la1[5] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 AstAnd jjtn001 = new AstAnd(JJTAND);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 Equality();
			 }
			 catch (Throwable jjte001) {
				 if (jjtc001) {
					 jjtree.clearNodeScope(jjtn001);
					 jjtc001 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte001 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte001;
					}
				 }
				 if (jjte001 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte001;
					}
				 }
				 {
					if (true) throw (Error)jjte001;
				}
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, 2);
				 }
			 }
		 }
	 }
	 final public void Equality() throws ParseException {
		 Compare();
		 label_5: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EQ0: case EQ1: case NE0: case NE1: ;
				 break;
				 default: jj_la1[6] = jj_gen;
				 break label_5;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case EQ0: case EQ1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case EQ0: jj_consume_token(EQ0);
					 break;
					 case EQ1: jj_consume_token(EQ1);
					 break;
					 default: jj_la1[7] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstEqual jjtn001 = new AstEqual(JJTEQUAL);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 Compare();
				 }
				 catch (Throwable jjte001) {
					 if (jjtc001) {
						 jjtree.clearNodeScope(jjtn001);
						 jjtc001 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte001 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte001;
						}
					 }
					 if (jjte001 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte001;
						}
					 }
					 {
						if (true) throw (Error)jjte001;
					}
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
				 break;
				 case NE0: case NE1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case NE0: jj_consume_token(NE0);
					 break;
					 case NE1: jj_consume_token(NE1);
					 break;
					 default: jj_la1[8] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstNotEqual jjtn002 = new AstNotEqual(JJTNOTEQUAL);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 Compare();
				 }
				 catch (Throwable jjte002) {
					 if (jjtc002) {
						 jjtree.clearNodeScope(jjtn002);
						 jjtc002 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte002 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte002;
						}
					 }
					 if (jjte002 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte002;
						}
					 }
					 {
						if (true) throw (Error)jjte002;
					}
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, 2);
					 }
				 }
				 break;
				 default: jj_la1[9] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void Compare() throws ParseException {
		 Math();
		 label_6: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case GT0: case GT1: case LT0: case LT1: case GE0: case GE1: case LE0: case LE1: ;
				 break;
				 default: jj_la1[10] = jj_gen;
				 break label_6;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case LT0: case LT1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LT0: jj_consume_token(LT0);
					 break;
					 case LT1: jj_consume_token(LT1);
					 break;
					 default: jj_la1[11] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstLessThan jjtn001 = new AstLessThan(JJTLESSTHAN);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 Math();
				 }
				 catch (Throwable jjte001) {
					 if (jjtc001) {
						 jjtree.clearNodeScope(jjtn001);
						 jjtc001 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte001 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte001;
						}
					 }
					 if (jjte001 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte001;
						}
					 }
					 {
						if (true) throw (Error)jjte001;
					}
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
				 break;
				 case GT0: case GT1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case GT0: jj_consume_token(GT0);
					 break;
					 case GT1: jj_consume_token(GT1);
					 break;
					 default: jj_la1[12] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstGreaterThan jjtn002 = new AstGreaterThan(JJTGREATERTHAN);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 Math();
				 }
				 catch (Throwable jjte002) {
					 if (jjtc002) {
						 jjtree.clearNodeScope(jjtn002);
						 jjtc002 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte002 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte002;
						}
					 }
					 if (jjte002 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte002;
						}
					 }
					 {
						if (true) throw (Error)jjte002;
					}
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, 2);
					 }
				 }
				 break;
				 case LE0: case LE1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case LE0: jj_consume_token(LE0);
					 break;
					 case LE1: jj_consume_token(LE1);
					 break;
					 default: jj_la1[13] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstLessThanEqual jjtn003 = new AstLessThanEqual(JJTLESSTHANEQUAL);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 Math();
				 }
				 catch (Throwable jjte003) {
					 if (jjtc003) {
						 jjtree.clearNodeScope(jjtn003);
						 jjtc003 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte003 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte003;
						}
					 }
					 if (jjte003 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte003;
						}
					 }
					 {
						if (true) throw (Error)jjte003;
					}
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, 2);
					 }
				 }
				 break;
				 case GE0: case GE1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case GE0: jj_consume_token(GE0);
					 break;
					 case GE1: jj_consume_token(GE1);
					 break;
					 default: jj_la1[14] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstGreaterThanEqual jjtn004 = new AstGreaterThanEqual(JJTGREATERTHANEQUAL);
				 boolean jjtc004 = true;
				 jjtree.openNodeScope(jjtn004);
				 try {
					 Math();
				 }
				 catch (Throwable jjte004) {
					 if (jjtc004) {
						 jjtree.clearNodeScope(jjtn004);
						 jjtc004 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte004 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte004;
						}
					 }
					 if (jjte004 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte004;
						}
					 }
					 {
						if (true) throw (Error)jjte004;
					}
				 }
				 finally {
					 if (jjtc004) {
						 jjtree.closeNodeScope(jjtn004, 2);
					 }
				 }
				 break;
				 default: jj_la1[15] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void Math() throws ParseException {
		 Multiplication();
		 label_7: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PLUS: case MINUS: ;
				 break;
				 default: jj_la1[16] = jj_gen;
				 break label_7;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case PLUS: jj_consume_token(PLUS);
				 AstPlus jjtn001 = new AstPlus(JJTPLUS);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 Multiplication();
				 }
				 catch (Throwable jjte001) {
					 if (jjtc001) {
						 jjtree.clearNodeScope(jjtn001);
						 jjtc001 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte001 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte001;
						}
					 }
					 if (jjte001 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte001;
						}
					 }
					 {
						if (true) throw (Error)jjte001;
					}
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
				 break;
				 case MINUS: jj_consume_token(MINUS);
				 AstMinus jjtn002 = new AstMinus(JJTMINUS);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 Multiplication();
				 }
				 catch (Throwable jjte002) {
					 if (jjtc002) {
						 jjtree.clearNodeScope(jjtn002);
						 jjtc002 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte002 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte002;
						}
					 }
					 if (jjte002 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte002;
						}
					 }
					 {
						if (true) throw (Error)jjte002;
					}
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, 2);
					 }
				 }
				 break;
				 default: jj_la1[17] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void Multiplication() throws ParseException {
		 Unary();
		 label_8: while (true) {
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case MULT: case DIV0: case DIV1: case MOD0: case MOD1: ;
				 break;
				 default: jj_la1[18] = jj_gen;
				 break label_8;
			 }
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case MULT: jj_consume_token(MULT);
				 AstMult jjtn001 = new AstMult(JJTMULT);
				 boolean jjtc001 = true;
				 jjtree.openNodeScope(jjtn001);
				 try {
					 Unary();
				 }
				 catch (Throwable jjte001) {
					 if (jjtc001) {
						 jjtree.clearNodeScope(jjtn001);
						 jjtc001 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte001 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte001;
						}
					 }
					 if (jjte001 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte001;
						}
					 }
					 {
						if (true) throw (Error)jjte001;
					}
				 }
				 finally {
					 if (jjtc001) {
						 jjtree.closeNodeScope(jjtn001, 2);
					 }
				 }
				 break;
				 case DIV0: case DIV1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DIV0: jj_consume_token(DIV0);
					 break;
					 case DIV1: jj_consume_token(DIV1);
					 break;
					 default: jj_la1[19] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstDiv jjtn002 = new AstDiv(JJTDIV);
				 boolean jjtc002 = true;
				 jjtree.openNodeScope(jjtn002);
				 try {
					 Unary();
				 }
				 catch (Throwable jjte002) {
					 if (jjtc002) {
						 jjtree.clearNodeScope(jjtn002);
						 jjtc002 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte002 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte002;
						}
					 }
					 if (jjte002 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte002;
						}
					 }
					 {
						if (true) throw (Error)jjte002;
					}
				 }
				 finally {
					 if (jjtc002) {
						 jjtree.closeNodeScope(jjtn002, 2);
					 }
				 }
				 break;
				 case MOD0: case MOD1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case MOD0: jj_consume_token(MOD0);
					 break;
					 case MOD1: jj_consume_token(MOD1);
					 break;
					 default: jj_la1[20] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
				 AstMod jjtn003 = new AstMod(JJTMOD);
				 boolean jjtc003 = true;
				 jjtree.openNodeScope(jjtn003);
				 try {
					 Unary();
				 }
				 catch (Throwable jjte003) {
					 if (jjtc003) {
						 jjtree.clearNodeScope(jjtn003);
						 jjtc003 = false;
					 }
					 else {
						 jjtree.popNode();
					 }
					 if (jjte003 instanceof RuntimeException) {
						 {
							if (true) throw (RuntimeException)jjte003;
						}
					 }
					 if (jjte003 instanceof ParseException) {
						 {
							if (true) throw (ParseException)jjte003;
						}
					 }
					 {
						if (true) throw (Error)jjte003;
					}
				 }
				 finally {
					 if (jjtc003) {
						 jjtree.closeNodeScope(jjtn003, 2);
					 }
				 }
				 break;
				 default: jj_la1[21] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
		 }
	 }
	 final public void Unary() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case MINUS: jj_consume_token(MINUS);
			 AstNegative jjtn001 = new AstNegative(JJTNEGATIVE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 Unary();
			 }
			 catch (Throwable jjte001) {
				 if (jjtc001) {
					 jjtree.clearNodeScope(jjtn001);
					 jjtc001 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte001 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte001;
					}
				 }
				 if (jjte001 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte001;
					}
				 }
				 {
					if (true) throw (Error)jjte001;
				}
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case NOT0: case NOT1: switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case NOT0: jj_consume_token(NOT0);
				 break;
				 case NOT1: jj_consume_token(NOT1);
				 break;
				 default: jj_la1[22] = jj_gen;
				 jj_consume_token(-1);
				 throw new ParseException();
			 }
			 AstNot jjtn002 = new AstNot(JJTNOT);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 Unary();
			 }
			 catch (Throwable jjte002) {
				 if (jjtc002) {
					 jjtree.clearNodeScope(jjtn002);
					 jjtc002 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte002 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte002;
					}
				 }
				 if (jjte002 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte002;
					}
				 }
				 {
					if (true) throw (Error)jjte002;
				}
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 case EMPTY: jj_consume_token(EMPTY);
			 AstEmpty jjtn003 = new AstEmpty(JJTEMPTY);
			 boolean jjtc003 = true;
			 jjtree.openNodeScope(jjtn003);
			 try {
				 Unary();
			 }
			 catch (Throwable jjte003) {
				 if (jjtc003) {
					 jjtree.clearNodeScope(jjtn003);
					 jjtc003 = false;
				 }
				 else {
					 jjtree.popNode();
				 }
				 if (jjte003 instanceof RuntimeException) {
					 {
						if (true) throw (RuntimeException)jjte003;
					}
				 }
				 if (jjte003 instanceof ParseException) {
					 {
						if (true) throw (ParseException)jjte003;
					}
				 }
				 {
					if (true) throw (Error)jjte003;
				}
			 }
			 finally {
				 if (jjtc003) {
					 jjtree.closeNodeScope(jjtn003, true);
				 }
			 }
			 break;
			 case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case STRING_LITERAL: case TRUE: case FALSE: case NULL: case LPAREN: case IDENTIFIER: Value();
			 break;
			 default: jj_la1[23] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void Value() throws ParseException {
		 AstValue jjtn001 = new AstValue(JJTVALUE);
		 boolean jjtc001 = true;
		 jjtree.openNodeScope(jjtn001);
		 try {
			 ValuePrefix();
			 label_9: while (true) {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case DOT: case LBRACK: ;
					 break;
					 default: jj_la1[24] = jj_gen;
					 break label_9;
				 }
				 ValueSuffix();
			 }
		 }
		 catch (Throwable jjte001) {
			 if (jjtc001) {
				 jjtree.clearNodeScope(jjtn001);
				 jjtc001 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte001 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte001;
				}
			 }
			 if (jjte001 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte001;
				}
			 }
			 {
				if (true) throw (Error)jjte001;
			}
		 }
		 finally {
			 if (jjtc001) {
				 jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
			 }
		 }
	 }
	 final public void ValuePrefix() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case STRING_LITERAL: case TRUE: case FALSE: case NULL: Literal();
			 break;
			 case LPAREN: case IDENTIFIER: NonLiteral();
			 break;
			 default: jj_la1[25] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void ValueSuffix() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case DOT: DotSuffix();
			 break;
			 case LBRACK: BracketSuffix();
			 break;
			 default: jj_la1[26] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case LPAREN: MethodParameters();
			 break;
			 default: jj_la1[27] = jj_gen;
			 ;
		 }
	 }
	 final public void DotSuffix() throws ParseException {
		 AstDotSuffix jjtn000 = new AstDotSuffix(JJTDOTSUFFIX);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 try {
			 jj_consume_token(DOT);
			 t = jj_consume_token(IDENTIFIER);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtn000.setImage(t.image);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void BracketSuffix() throws ParseException {
		 AstBracketSuffix jjtn000 = new AstBracketSuffix(JJTBRACKETSUFFIX);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(LBRACK);
			 Expression();
			 jj_consume_token(RBRACK);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void MethodParameters() throws ParseException {
		 AstMethodParameters jjtn000 = new AstMethodParameters(JJTMETHODPARAMETERS);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(LPAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case STRING_LITERAL: case TRUE: case FALSE: case NULL: case LPAREN: case NOT0: case NOT1: case EMPTY: case MINUS: case IDENTIFIER: Expression();
				 label_10: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case COMMA: ;
						 break;
						 default: jj_la1[28] = jj_gen;
						 break label_10;
					 }
					 jj_consume_token(COMMA);
					 Expression();
				 }
				 break;
				 default: jj_la1[29] = jj_gen;
				 ;
			 }
			 jj_consume_token(RPAREN);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void NonLiteral() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case LPAREN: jj_consume_token(LPAREN);
			 Expression();
			 jj_consume_token(RPAREN);
			 break;
			 default: jj_la1[30] = jj_gen;
			 if (jj_2_2(2147483647)) {
				 Function();
			 }
			 else {
				 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
					 case IDENTIFIER: Identifier();
					 break;
					 default: jj_la1[31] = jj_gen;
					 jj_consume_token(-1);
					 throw new ParseException();
				 }
			 }
		 }
	 }
	 final public void Identifier() throws ParseException {
		 AstIdentifier jjtn000 = new AstIdentifier(JJTIDENTIFIER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 try {
			 t = jj_consume_token(IDENTIFIER);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtn000.setImage(t.image);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Function() throws ParseException {
		 AstFunction jjtn000 = new AstFunction(JJTFUNCTION);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t0 = null;
		 Token t1 = null;
		 try {
			 if (jj_2_3(2)) {
				 t0 = jj_consume_token(IDENTIFIER);
				 jj_consume_token(COLON);
			 }
			 else {
				 ;
			 }
			 t1 = jj_consume_token(IDENTIFIER);
			 if (t0 != null) {
				 jjtn000.setPrefix(t0.image);
				 jjtn000.setLocalName(t1.image);
			 }
			 else {
				 jjtn000.setLocalName(t1.image);
			 }
			 jj_consume_token(LPAREN);
			 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				 case INTEGER_LITERAL: case FLOATING_POINT_LITERAL: case STRING_LITERAL: case TRUE: case FALSE: case NULL: case LPAREN: case NOT0: case NOT1: case EMPTY: case MINUS: case IDENTIFIER: Expression();
				 label_11: while (true) {
					 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						 case COMMA: ;
						 break;
						 default: jj_la1[32] = jj_gen;
						 break label_11;
					 }
					 jj_consume_token(COMMA);
					 Expression();
				 }
				 break;
				 default: jj_la1[33] = jj_gen;
				 ;
			 }
			 jj_consume_token(RPAREN);
		 }
		 catch (Throwable jjte000) {
			 if (jjtc000) {
				 jjtree.clearNodeScope(jjtn000);
				 jjtc000 = false;
			 }
			 else {
				 jjtree.popNode();
			 }
			 if (jjte000 instanceof RuntimeException) {
				 {
					if (true) throw (RuntimeException)jjte000;
				}
			 }
			 if (jjte000 instanceof ParseException) {
				 {
					if (true) throw (ParseException)jjte000;
				}
			 }
			 {
				if (true) throw (Error)jjte000;
			}
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Literal() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case TRUE: case FALSE: Boolean();
			 break;
			 case FLOATING_POINT_LITERAL: FloatingPoint();
			 break;
			 case INTEGER_LITERAL: Integer();
			 break;
			 case STRING_LITERAL: String();
			 break;
			 case NULL: Null();
			 break;
			 default: jj_la1[34] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void Boolean() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			 case TRUE: AstTrue jjtn001 = new AstTrue(JJTTRUE);
			 boolean jjtc001 = true;
			 jjtree.openNodeScope(jjtn001);
			 try {
				 jj_consume_token(TRUE);
			 }
			 finally {
				 if (jjtc001) {
					 jjtree.closeNodeScope(jjtn001, true);
				 }
			 }
			 break;
			 case FALSE: AstFalse jjtn002 = new AstFalse(JJTFALSE);
			 boolean jjtc002 = true;
			 jjtree.openNodeScope(jjtn002);
			 try {
				 jj_consume_token(FALSE);
			 }
			 finally {
				 if (jjtc002) {
					 jjtree.closeNodeScope(jjtn002, true);
				 }
			 }
			 break;
			 default: jj_la1[35] = jj_gen;
			 jj_consume_token(-1);
			 throw new ParseException();
		 }
	 }
	 final public void FloatingPoint() throws ParseException {
		 AstFloatingPoint jjtn000 = new AstFloatingPoint(JJTFLOATINGPOINT);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 try {
			 t = jj_consume_token(FLOATING_POINT_LITERAL);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtn000.setImage(t.image);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Integer() throws ParseException {
		 AstInteger jjtn000 = new AstInteger(JJTINTEGER);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 try {
			 t = jj_consume_token(INTEGER_LITERAL);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtn000.setImage(t.image);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void String() throws ParseException {
		 AstString jjtn000 = new AstString(JJTSTRING);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		Token t = null;
		 try {
			 t = jj_consume_token(STRING_LITERAL);
			 jjtree.closeNodeScope(jjtn000, true);
			 jjtc000 = false;
			 jjtn000.setImage(t.image);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 final public void Null() throws ParseException {
		 AstNull jjtn000 = new AstNull(JJTNULL);
		 boolean jjtc000 = true;
		 jjtree.openNodeScope(jjtn000);
		 try {
			 jj_consume_token(NULL);
		 }
		 finally {
			 if (jjtc000) {
				 jjtree.closeNodeScope(jjtn000, true);
			 }
		 }
	 }
	 private boolean jj_2_1(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_1();
		 }
		 catch(LookaheadSuccess ls) {
			 return true;
		 }
		 finally {
			 jj_save(0, xla);
		 }
	 }
	 private boolean jj_2_2(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_2();
		 }
		 catch(LookaheadSuccess ls) {
			 return true;
		 }
		 finally {
			 jj_save(1, xla);
		 }
	 }
	 private boolean jj_2_3(int xla) {
		 jj_la = xla;
		 jj_lastpos = jj_scanpos = token;
		 try {
			 return !jj_3_3();
		 }
		 catch(LookaheadSuccess ls) {
			 return true;
		 }
		 finally {
			 jj_save(2, xla);
		 }
	 }
	 private boolean jj_3R_13() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(COLON)) return true;
		 return false;
	 }
	 private boolean jj_3_2() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_13()) jj_scanpos = xsp;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 return false;
	 }
	 private boolean jj_3R_69() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 return false;
	 }
	 private boolean jj_3R_25() {
		 if (jj_3R_31()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_32()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_59() {
		 if (jj_3R_69()) return true;
		 return false;
	 }
	 private boolean jj_3R_34() {
		 if (jj_scan_token(MINUS)) return true;
		 return false;
	 }
	 private boolean jj_3R_58() {
		 if (jj_3R_68()) return true;
		 return false;
	 }
	 private boolean jj_3R_26() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_33()) {
			 jj_scanpos = xsp;
			 if (jj_3R_34()) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_33() {
		 if (jj_scan_token(PLUS)) return true;
		 return false;
	 }
	 private boolean jj_3R_57() {
		 if (jj_scan_token(LPAREN)) return true;
		 if (jj_3R_67()) return true;
		 return false;
	 }
	 private boolean jj_3R_49() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_57()) {
			 jj_scanpos = xsp;
			 if (jj_3R_58()) {
				 jj_scanpos = xsp;
				 if (jj_3R_59()) return true;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_66() {
		 if (jj_scan_token(NULL)) return true;
		 return false;
	 }
	 private boolean jj_3R_21() {
		 if (jj_3R_25()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_26()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_30() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(27)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(28)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_65() {
		 if (jj_scan_token(STRING_LITERAL)) return true;
		 return false;
	 }
	 private boolean jj_3R_29() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(29)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(30)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_28() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(23)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(24)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_22() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_27()) {
			 jj_scanpos = xsp;
			 if (jj_3R_28()) {
				 jj_scanpos = xsp;
				 if (jj_3R_29()) {
					 jj_scanpos = xsp;
					 if (jj_3R_30()) return true;
				 }
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_27() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(25)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(26)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_61() {
		 if (jj_scan_token(LBRACK)) return true;
		 return false;
	 }
	 private boolean jj_3R_51() {
		 if (jj_3R_61()) return true;
		 return false;
	 }
	 private boolean jj_3R_64() {
		 if (jj_scan_token(INTEGER_LITERAL)) return true;
		 return false;
	 }
	 private boolean jj_3R_19() {
		 if (jj_3R_21()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_22()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_60() {
		 if (jj_scan_token(DOT)) return true;
		 return false;
	 }
	 private boolean jj_3R_24() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(33)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(34)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_63() {
		 if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
		 return false;
	 }
	 private boolean jj_3R_23() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(31)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(32)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_20() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_23()) {
			 jj_scanpos = xsp;
			 if (jj_3R_24()) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_50() {
		 if (jj_3R_60()) return true;
		 return false;
	 }
	 private boolean jj_3R_18() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(37)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(38)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_47() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_50()) {
			 jj_scanpos = xsp;
			 if (jj_3R_51()) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_71() {
		 if (jj_scan_token(FALSE)) return true;
		 return false;
	 }
	 private boolean jj_3R_17() {
		 if (jj_3R_19()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_20()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_44() {
		 if (jj_3R_47()) return true;
		 return false;
	 }
	 private boolean jj_3R_70() {
		 if (jj_scan_token(TRUE)) return true;
		 return false;
	 }
	 private boolean jj_3R_62() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_70()) {
			 jj_scanpos = xsp;
			 if (jj_3R_71()) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_46() {
		 if (jj_3R_49()) return true;
		 return false;
	 }
	 private boolean jj_3R_45() {
		 if (jj_3R_48()) return true;
		 return false;
	 }
	 private boolean jj_3R_15() {
		 if (jj_3R_17()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_18()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_43() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_45()) {
			 jj_scanpos = xsp;
			 if (jj_3R_46()) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_56() {
		 if (jj_3R_66()) return true;
		 return false;
	 }
	 private boolean jj_3R_16() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(39)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(40)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_55() {
		 if (jj_3R_65()) return true;
		 return false;
	 }
	 private boolean jj_3R_54() {
		 if (jj_3R_64()) return true;
		 return false;
	 }
	 private boolean jj_3R_53() {
		 if (jj_3R_63()) return true;
		 return false;
	 }
	 private boolean jj_3R_52() {
		 if (jj_3R_62()) return true;
		 return false;
	 }
	 private boolean jj_3R_48() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_52()) {
			 jj_scanpos = xsp;
			 if (jj_3R_53()) {
				 jj_scanpos = xsp;
				 if (jj_3R_54()) {
					 jj_scanpos = xsp;
					 if (jj_3R_55()) {
						 jj_scanpos = xsp;
						 if (jj_3R_56()) return true;
					 }
				 }
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_14() {
		 if (jj_3R_15()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_16()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_42() {
		 if (jj_3R_43()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3R_44()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3_1() {
		 if (jj_scan_token(QUESTIONMARK)) return true;
		 if (jj_3R_12()) return true;
		 if (jj_scan_token(COLON)) return true;
		 return false;
	 }
	 private boolean jj_3R_38() {
		 if (jj_3R_42()) return true;
		 return false;
	 }
	 private boolean jj_3R_37() {
		 if (jj_scan_token(EMPTY)) return true;
		 if (jj_3R_31()) return true;
		 return false;
	 }
	 private boolean jj_3R_12() {
		 if (jj_3R_14()) return true;
		 Token xsp;
		 while (true) {
			 xsp = jj_scanpos;
			 if (jj_3_1()) {
				 jj_scanpos = xsp;
				 break;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_36() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(35)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(36)) return true;
		 }
		 if (jj_3R_31()) return true;
		 return false;
	 }
	 private boolean jj_3R_31() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_35()) {
			 jj_scanpos = xsp;
			 if (jj_3R_36()) {
				 jj_scanpos = xsp;
				 if (jj_3R_37()) {
					 jj_scanpos = xsp;
					 if (jj_3R_38()) return true;
				 }
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_35() {
		 if (jj_scan_token(MINUS)) return true;
		 if (jj_3R_31()) return true;
		 return false;
	 }
	 private boolean jj_3_3() {
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(COLON)) return true;
		 return false;
	 }
	 private boolean jj_3R_68() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3_3()) jj_scanpos = xsp;
		 if (jj_scan_token(IDENTIFIER)) return true;
		 if (jj_scan_token(LPAREN)) return true;
		 return false;
	 }
	 private boolean jj_3R_67() {
		 if (jj_3R_12()) return true;
		 return false;
	 }
	 private boolean jj_3R_41() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(49)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(50)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_40() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_scan_token(47)) {
			 jj_scanpos = xsp;
			 if (jj_scan_token(48)) return true;
		 }
		 return false;
	 }
	 private boolean jj_3R_32() {
		 Token xsp;
		 xsp = jj_scanpos;
		 if (jj_3R_39()) {
			 jj_scanpos = xsp;
			 if (jj_3R_40()) {
				 jj_scanpos = xsp;
				 if (jj_3R_41()) return true;
			 }
		 }
		 return false;
	 }
	 private boolean jj_3R_39() {
		 if (jj_scan_token(MULT)) return true;
		 return false;
	 }
	 public ELParserTokenManager token_source;
	 SimpleCharStream jj_input_stream;
	 public Token token;
	 public Token jj_nt;
	 private int jj_ntk;
	 private Token jj_scanpos, jj_lastpos;
	 private int jj_la;
	 private int jj_gen;
	 final private int[] jj_la1 = new int[36];
	 static private int[] jj_la1_0;
	 static private int[] jj_la1_1;
	 static {
		 jj_la1_init_0();
		 jj_la1_init_1();
	 }
	 private static void jj_la1_init_0() {
		 jj_la1_0 = new int[] {
		0xe,0xe,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x80000000,0x7f800000,0x6000000,0x1800000,0x60000000,0x18000000,0x7f800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x27b00,0x90000,0x27b00,0x90000,0x20000,0x400000,0x27b00,0x20000,0x0,0x400000,0x27b00,0x7b00,0x3000,}
		;
	 }
	 private static void jj_la1_init_1() {
		 jj_la1_1 = new int[] {
		0x0,0x0,0x180,0x180,0x60,0x60,0x7,0x1,0x6,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x3000,0x78800,0x18000,0x60000,0x78800,0x18,0x82218,0x0,0x80000,0x0,0x0,0x0,0x82218,0x0,0x80000,0x0,0x82218,0x0,0x0,}
		;
	 }
	 final private JJCalls[] jj_2_rtns = new JJCalls[3];
	 private boolean jj_rescan = false;
	 private int jj_gc = 0;
	 public ELParser(java.io.InputStream stream) {
		 this(stream, null);
	 }
	 public ELParser(java.io.InputStream stream, String encoding) {
		 try {
			 jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		 }
		 catch(java.io.UnsupportedEncodingException e) {
			 throw new RuntimeException(e);
		 }
		 token_source = new ELParserTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 36;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public void ReInit(java.io.InputStream stream) {
		 ReInit(stream, null);
	 }
	 public void ReInit(java.io.InputStream stream, String encoding) {
		 try {
			 jj_input_stream.ReInit(stream, encoding, 1, 1);
		 }
		 catch(java.io.UnsupportedEncodingException e) {
			 throw new RuntimeException(e);
		 }
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 36;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public ELParser(java.io.Reader stream) {
		 jj_input_stream = new SimpleCharStream(stream, 1, 1);
		 token_source = new ELParserTokenManager(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 36;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public void ReInit(java.io.Reader stream) {
		 jj_input_stream.ReInit(stream, 1, 1);
		 token_source.ReInit(jj_input_stream);
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 36;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public ELParser(ELParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jj_gen = 0;
		 for (int i = 0;
		 i < 36;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 public void ReInit(ELParserTokenManager tm) {
		 token_source = tm;
		 token = new Token();
		 jj_ntk = -1;
		 jjtree.reset();
		 jj_gen = 0;
		 for (int i = 0;
		 i < 36;
		 i++) jj_la1[i] = -1;
		 for (int i = 0;
		 i < jj_2_rtns.length;
		 i++) jj_2_rtns[i] = new JJCalls();
	 }
	 private Token jj_consume_token(int kind) throws ParseException {
		 Token oldToken;
		 if ((oldToken = token).next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 if (token.kind == kind) {
			 jj_gen++;
			 if (++jj_gc > 100) {
				 jj_gc = 0;
				 for (int i = 0;
				 i < jj_2_rtns.length;
				 i++) {
					 JJCalls c = jj_2_rtns[i];
					 while (c != null) {
						 if (c.gen < jj_gen) c.first = null;
						 c = c.next;
					 }
				 }
			 }
			 return token;
		 }
		 token = oldToken;
		 jj_kind = kind;
		 throw generateParseException();
	 }
	 static private final class LookaheadSuccess extends java.lang.Error {
	 }
	 final private LookaheadSuccess jj_ls = new LookaheadSuccess();
	 private boolean jj_scan_token(int kind) {
		 if (jj_scanpos == jj_lastpos) {
			 jj_la--;
			 if (jj_scanpos.next == null) {
				 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			 }
			 else {
				 jj_lastpos = jj_scanpos = jj_scanpos.next;
			 }
		 }
		 else {
			 jj_scanpos = jj_scanpos.next;
		 }
		 if (jj_rescan) {
			 int i = 0;
			 Token tok = token;
			 while (tok != null && tok != jj_scanpos) {
				 i++;
				 tok = tok.next;
			 }
			 if (tok != null) jj_add_error_token(kind, i);
		 }
		 if (jj_scanpos.kind != kind) return true;
		 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
		 return false;
	 }
	 final public Token getNextToken() {
		 if (token.next != null) token = token.next;
		 else token = token.next = token_source.getNextToken();
		 jj_ntk = -1;
		 jj_gen++;
		 return token;
	 }
	 final public Token getToken(int index) {
		 Token t = token;
		 for (int i = 0;
		 i < index;
		 i++) {
			 if (t.next != null) t = t.next;
			 else t = t.next = token_source.getNextToken();
		 }
		 return t;
	 }
	 private int jj_ntk() {
		 if ((jj_nt=token.next) == null) return (jj_ntk = (token.next=token_source.getNextToken()).kind);
		 else return (jj_ntk = jj_nt.kind);
	 }
	 private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
	 private int[] jj_expentry;
	 private int jj_kind = -1;
	 private int[] jj_lasttokens = new int[100];
	 private int jj_endpos;
	 private void jj_add_error_token(int kind, int pos) {
		 if (pos >= 100) return;
		 if (pos == jj_endpos + 1) {
			 jj_lasttokens[jj_endpos++] = kind;
		 }
		 else if (jj_endpos != 0) {
			 jj_expentry = new int[jj_endpos];
			 for (int i = 0;
			 i < jj_endpos;
			 i++) {
				 jj_expentry[i] = jj_lasttokens[i];
			 }
			 jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator();
			 it.hasNext();
			) {
				 int[] oldentry = (int[])(it.next());
				 if (oldentry.length == jj_expentry.length) {
					 for (int i = 0;
					 i < jj_expentry.length;
					 i++) {
						 if (oldentry[i] != jj_expentry[i]) {
							 continue jj_entries_loop;
						 }
					 }
					 jj_expentries.add(jj_expentry);
					 break jj_entries_loop;
				 }
			 }
			 if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		 }
	 }
	 public ParseException generateParseException() {
		 jj_expentries.clear();
		 boolean[] la1tokens = new boolean[57];
		 if (jj_kind >= 0) {
			 la1tokens[jj_kind] = true;
			 jj_kind = -1;
		 }
		 for (int i = 0;
		 i < 36;
		 i++) {
			 if (jj_la1[i] == jj_gen) {
				 for (int j = 0;
				 j < 32;
				 j++) {
					 if ((jj_la1_0[i] & (1<<j)) != 0) {
						 la1tokens[j] = true;
					 }
					 if ((jj_la1_1[i] & (1<<j)) != 0) {
						 la1tokens[32+j] = true;
					 }
				 }
			 }
		 }
		 for (int i = 0;
		 i < 57;
		 i++) {
			 if (la1tokens[i]) {
				 jj_expentry = new int[1];
				 jj_expentry[0] = i;
				 jj_expentries.add(jj_expentry);
			 }
		 }
		 jj_endpos = 0;
		 jj_rescan_token();
		 jj_add_error_token(0, 0);
		 int[][] exptokseq = new int[jj_expentries.size()][];
		 for (int i = 0;
		 i < jj_expentries.size();
		 i++) {
			 exptokseq[i] = jj_expentries.get(i);
		 }
		 return new ParseException(token, exptokseq, tokenImage);
	 }
	 final public void enable_tracing() {
	 }
	 final public void disable_tracing() {
	 }
	 private void jj_rescan_token() {
		 jj_rescan = true;
		 for (int i = 0;
		 i < 3;
		 i++) {
			 try {
				 JJCalls p = jj_2_rtns[i];
				 do {
					 if (p.gen > jj_gen) {
						 jj_la = p.arg;
						 jj_lastpos = jj_scanpos = p.first;
						 switch (i) {
							 case 0: jj_3_1();
							 break;
							 case 1: jj_3_2();
							 break;
							 case 2: jj_3_3();
							 break;
						 }
					 }
					 p = p.next;
				 }
				 while (p != null);
			 }
			 catch(LookaheadSuccess ls) {
			 }
		 }
		 jj_rescan = false;
	 }
	 private void jj_save(int index, int xla) {
		 JJCalls p = jj_2_rtns[index];
		 while (p.gen > jj_gen) {
			 if (p.next == null) {
				 p = p.next = new JJCalls();
				 break;
			 }
			 p = p.next;
		 }
		 p.gen = jj_gen + xla - jj_la;
		 p.first = token;
		 p.arg = xla;
	 }
	 static final class JJCalls {
		 int gen;
		 Token first;
		 int arg;
		 JJCalls next;
	 }
}",1,0,0,0
"public class AnnotPage extends ContactsDisplayPage{
	private ContactDao dao;
	protected ContactDataProvider getDataProvider(){
		return new ProxyDataProvider(dao);
	}
}",0,1,0,0
"public void flushLargestMemtables() {
	 ColumnFamilyStore largestByOps = null;
	 ColumnFamilyStore largestByThroughput = null;
	 for (ColumnFamilyStore cfs : ColumnFamilyStore.all()) {
		 if (largestByOps == null || cfs.getMemtableColumnsCount() > largestByOps.getMemtableColumnsCount()) largestByOps = cfs;
		 if (largestByThroughput == null || cfs.getMemtableThroughputInMB() > largestByThroughput.getMemtableThroughputInMB()) largestByThroughput = cfs;
	 }
	 if (largestByOps == null) {
		 logger_.error(""Unable to reduce heap usage since there are no column families defined"");
		 return;
	 }
	 logger_.warn(""Flushing "" + largestByOps + "" to relieve memory pressure"");
	 largestByOps.forceFlush();
	 if (largestByThroughput != largestByOps) {
		 logger_.warn(""Flushing "" + largestByThroughput + "" to relieve memory pressure"");
		 largestByThroughput.forceFlush();
	 }
 }",0,0,0,0
public void getXml(Writer fileout) throws IOException;,0,0,0,0
"public class UploadFileViewImpl extends Window implements UploadFileView {
	 public interface UploadFileViewBinder extends UiBinder<Widget, UploadFileViewImpl> {
	}
	 private final AgentURLModifier agentURLModifier;
	 Button btnCancel;
	 Button btnUpload;
	 FormPanel submitForm;
	 CheckBox overwrite;
	 FlowPanel uploadPanel;
	 FileUpload file;
	 ActionDelegate delegate;
	 public UploadFileViewImpl( UploadFileViewBinder uploadFileViewBinder, CoreLocalizationConstant locale, AgentURLModifier agentURLModifier) {
		 this.setTitle(locale.uploadFileTitle());
		 setWidget(uploadFileViewBinder.createAndBindUi(this));
		 bind();
		 btnCancel = addFooterButton( locale.cancel(), ""file-uploadFile-cancel"", event -> delegate.onCancelClicked());
		 btnUpload = addFooterButton( locale.uploadButton(), ""file-uploadFile-upload"", event -> delegate.onUploadClicked(), true);
		 this.agentURLModifier = agentURLModifier;
	 }
	 private void bind() {
		 submitForm.addSubmitCompleteHandler(event -> delegate.onSubmitComplete(event.getResults()));
	 }
	 public void showDialog() {
		 show();
	 }
	 protected void onShow() {
		 addFile();
	 }
	 public void closeDialog() {
		 hide();
	 }
	 protected void onHide() {
		 btnUpload.setEnabled(false);
		 overwrite.setValue(false);
		 uploadPanel.remove(file);
	 }
	 public void setDelegate(ActionDelegate delegate) {
		 this.delegate = delegate;
	 }
	 public void setEnabledUploadButton(boolean enabled) {
		 btnUpload.setEnabled(enabled);
	 }
	 public void setEncoding( String encodingType) {
		 submitForm.setEncoding(encodingType);
	 }
	 public void setAction( String url) {
		 submitForm.setAction(agentURLModifier.modify(url));
		 submitForm.setMethod(FormPanel.METHOD_POST);
	 }
	 public void submit() {
		 overwrite.setFormValue(overwrite.getValue().toString());
		 submitForm.submit();
		 btnUpload.setEnabled(false);
	 }
	 public String getFileName() {
		 String fileName = file.getFilename();
		 if (fileName.contains(""/"")) {
			 return fileName.substring(fileName.lastIndexOf(""/"") + 1);
		 }
		 if (fileName.contains(""\\"")) {
			 return fileName.substring(fileName.lastIndexOf(""\\"") + 1);
		 }
		 return fileName;
	 }
	 public boolean isOverwriteFileSelected() {
		 return overwrite.getValue();
	 }
	 private void addFile() {
		 file = new FileUpload();
		 file.setHeight(""22px"");
		 file.setWidth(""100%"");
		 file.setName(""file"");
		 file.ensureDebugId(""file-uploadFile-ChooseFile"");
		 file.addChangeHandler(event -> delegate.onFileNameChanged());
		 uploadPanel.insert(file, 0);
	 }
}",1,0,0,0
"public String getKey(){
	return key.get(matcher());
}",0,0,0,0
"public class TargetManagerImpl implements TargetManager {
	private static Log log = LogFactory.getLog(TargetManagerImpl.class);
	private TargetDAO targetDao = null;
	;
	private SiteDAO siteDao = null;
	private AnnotationDAO annotationDAO = null;
	private TargetInstanceDAO targetInstanceDao = null;
	private AuthorityManager authMgr = null;
	private TargetInstanceManager instanceManager = null;
	private InTrayManager intrayManager = null;
	private Auditor auditor;
	private MessageSource messageSource;
	private BusinessObjectFactory businessObjectFactory;
	private WCTTreeSet subGroupParentTypesList = null;
	private boolean sendGroupUpdateNotifications = true;
	private boolean allowMultiplePrimarySeeds = true;
	private String subGroupTypeName = null;
	public boolean getAllowMultiplePrimarySeeds(){
		return allowMultiplePrimarySeeds;
	}
	public void setAllowMultiplePrimarySeeds(boolean allowMultiplePrimarySeeds){
		this.allowMultiplePrimarySeeds = allowMultiplePrimarySeeds;
	}
	public void save(Target aTarget, List<GroupMemberDTO> parents) {
		boolean newSchedulesAddedByNonOwner = false;
		boolean wasHarvestNowSelected = aTarget.isHarvestNow();
		if( aTarget.isDirty() && aTarget.getOriginalState() == Target.STATE_APPROVED &&!authMgr.hasPrivilege(aTarget, Privilege.APPROVE_TARGET)) {
			log.debug(""Target state changed to nominated due to changes"");
			aTarget.changeState(Target.STATE_NOMINATED);
		}
		if( (aTarget.getOriginalState() == Target.STATE_PENDING || aTarget.getOriginalState() == Target.STATE_REINSTATED || aTarget.getOriginalState() == Target.STATE_NOMINATED ) && aTarget.getState() == Target.STATE_APPROVED) {
			aTarget.setSelectionDate(new Date());
		}
		int numActiveTIsPrevious = targetInstanceDao.countActiveTIsForTarget(aTarget.getOid());
		for(Schedule schedule: aTarget.getRemovedSchedules()) {
			targetInstanceDao.deleteScheduledInstances(schedule);
			schedule.setTargetInstances(new HashSet<TargetInstance>());
			targetInstanceDao.save(schedule);
		}
		List<Schedule> newSchedules = new LinkedList<Schedule>();
		for(Schedule schedule: aTarget.getSchedules()) {
			if(schedule.isNew()) {
				newSchedules.add(schedule);
				if(!schedule.getOwningUser().equals(aTarget.getOwningUser())) {
					newSchedulesAddedByNonOwner = true;
				}
			}
		}
		AbstractTargetDTO originalTarget = null;
		if(!aTarget.isNew()) {
			originalTarget = targetDao.loadAbstractTargetDTO(aTarget.getOid());
		}
		Set<AbstractTargetDTO> origParents = Collections.EMPTY_SET;
		if(!aTarget.isNew()) {
			origParents = targetDao.getAncestorDTOs(aTarget.getOid());
		}
		log.debug(""Saving Target"");
		int originalState = aTarget.getOriginalState();
		targetDao.save(aTarget, parents);
		for(Annotation anno : aTarget.getAnnotations()) {
			anno.setObjectOid(aTarget.getOid());
		}
		annotationDAO.saveAnnotations(aTarget.getAnnotations());
		annotationDAO.deleteAnnotations(aTarget.getDeletedAnnotations());
		aTarget = targetDao.reloadTarget(aTarget.getOid());
		log.debug(""End of Save Target"");
		if(originalState != aTarget.getState()) {
			String newState = messageSource.getMessage(""target.state_"" + aTarget.getState(), null, Locale.getDefault());
			auditor.audit(Target.class.getName(), aTarget.getOid(), Auditor.ACTION_TARGET_STATE_CHANGE, ""Target "" + aTarget.getName() + "" has changed into state '"" + newState + ""'"" );
		}
		for(Schedule schedule: newSchedules) {
			auditor.audit(Schedule.class.getName(), schedule.getOid(), Auditor.ACTION_NEW_SCHEDULE, ""New Schedule Created on Target "" + aTarget.getName());
		}
		if(originalTarget != null) {
			 auditor.audit(Target.class.getName(), aTarget.getOid(), Auditor.ACTION_UPDATE_TARGET, ""Target "" + aTarget.getName() + "" has been updated"");
			 if(!originalTarget.getOwnerOid().equals(aTarget.getOwningUser().getOid())) {
				auditor.audit(Target.class.getName(), aTarget.getOid(), Auditor.ACTION_TARGET_CHANGE_OWNER, ""Target "" + aTarget.getName() + "" has been given to "" + aTarget.getOwningUser().getNiceName());
			}
			if(!originalTarget.getProfileOid().equals(aTarget.getProfile().getOid())) {
				auditor.audit(Target.class.getName(), aTarget.getOid(), Auditor.ACTION_TARGET_CHANGE_PROFILE, ""Target "" + aTarget.getName() + "" is now using profile "" + aTarget.getProfile().getName());
			}
		}
		if(originalState != aTarget.getState()) {
			if(aTarget.getState() == Target.STATE_NOMINATED) {
				intrayManager.generateTask(Privilege.APPROVE_TARGET, MessageType.TASK_APPROVE_TARGET, aTarget);
			}
			if(aTarget.getState() == Target.STATE_APPROVED || aTarget.getState() == Target.STATE_REJECTED) {
				intrayManager.deleteTask(aTarget.getOid(), aTarget.getResourceType(), MessageType.TASK_APPROVE_TARGET);
			}
			if(aTarget.getState() == Target.STATE_APPROVED && aTarget.isRunOnApproval()) {
				TargetInstance ti = new TargetInstance();
				 ti.setTarget(aTarget);
				 ti.setSchedule(null);
				 ti.setScheduledTime(new Date());
				 ti.setOwner(aTarget.getOwner());
				 ti.setUseAQA(aTarget.isUseAQA());
				targetInstanceDao.save(ti);
			}
		}
		else {
			if(aTarget.getState() == Target.STATE_APPROVED && wasHarvestNowSelected) {
				TargetInstance ti = new TargetInstance();
				 ti.setTarget(aTarget);
				 ti.setSchedule(null);
				 Calendar cal = Calendar.getInstance();
				 cal.add(Calendar.MINUTE, 5);
				 ti.setScheduledTime(cal.getTime());
				 ti.setOwner(aTarget.getOwner());
				 ti.setUseAQA(aTarget.isUseAQA());
				targetInstanceDao.save(ti);
			}
		}
		 if(originalTarget != null) {
			 if(!originalTarget.getOwnerOid().equals(aTarget.getOwningUser().getOid())) {
				 intrayManager.generateNotification(aTarget.getOwningUser().getOid(), MessageType.CATEGORY_MISC, MessageType.DELEGATE_TARGET, aTarget);
				 if(originalTarget.getOwnerOid() != AuthUtil.getRemoteUserObject().getOid()) {
					 intrayManager.generateNotification(originalTarget.getOwnerOid(), MessageType.CATEGORY_MISC, MessageType.TRANSFER_TARGET, aTarget);
				 }
			 }
		 }
		if(aTarget.isSchedulable()) {
			log.debug(""Staying in Schedulable State - scheduling new schedules"");
			for(Schedule schedule: aTarget.getSchedules()) {
				processSchedule(schedule);
			}
		}
		else {
			unschedule(aTarget);
		}
		 if (numActiveTIsPrevious > 0 && targetInstanceDao.countActiveTIsForTarget(aTarget.getOid()) == 0 && aTarget.getOriginalState() == Target.STATE_APPROVED && aTarget.getState() == Target.STATE_APPROVED) {
			 aTarget.changeState(Target.STATE_COMPLETED);
		 }
		if(newSchedulesAddedByNonOwner) {
			intrayManager.generateNotification(aTarget.getOwningUser().getOid(), MessageType.CATEGORY_MISC, MessageType.TARGET_SCHEDULE_ADDED, aTarget);
		}
		updateTargetGroupStatus(aTarget);
		if(parents != null) {
			for(GroupMemberDTO dto : parents) {
				if(dto.getSaveState() == SAVE_STATE.DELETED) {
					updateTargetGroupStatus(targetDao.loadGroup(dto.getParentOid()));
				}
			}
		}
		if(parents != null) {
			for(GroupMemberDTO dto : parents) {
				switch(dto.getSaveState()) {
					case NEW:TargetGroup grp = targetDao.loadGroup(dto.getParentOid());
					GroupEventPropagator gep = new GroupEventPropagator(this, instanceManager, grp, aTarget);
					gep.runEventChain();
					break;
					case DELETED:TargetGroup grp2 = targetDao.loadGroup(dto.getParentOid());
					MembersRemovedEventPropagator mrep = new MembersRemovedEventPropagator(this, instanceManager, grp2, aTarget);
					mrep.runEventChain();
					break;
				}
			}
		}
		if ( sendGroupUpdateNotifications && AuthUtil.getRemoteUserObject() !=null ) {
			String userName = AuthUtil.getRemoteUserObject().getNiceName();
			Set<AbstractTargetDTO> newParents = targetDao.getAncestorDTOs(aTarget.getOid());
			Set<AbstractTargetDTO> addedParents = new HashSet<AbstractTargetDTO>(newParents);
			addedParents.removeAll(origParents);
			Set<AbstractTargetDTO> removedParents = new HashSet<AbstractTargetDTO>(origParents);
			removedParents.removeAll(newParents);
			HashMap<Long, GroupChangeNotification> changes = new HashMap<Long, GroupChangeNotification>();
			for(AbstractTargetDTO dto : addedParents) {
				GroupChangeNotification gcn = null;
				if(!changes.containsKey(dto.getOwnerOid())) {
					gcn = new GroupChangeNotification();
					gcn.userOid = dto.getOwnerOid();
					changes.put(dto.getOwnerOid(), gcn);
				}
				gcn = changes.get(dto.getOwnerOid());
				gcn.addedTo.add(dto);
			}
			for(AbstractTargetDTO dto : removedParents) {
				GroupChangeNotification gcn = null;
				if(!changes.containsKey(dto.getOwnerOid())) {
					gcn = new GroupChangeNotification();
					gcn.userOid = dto.getOwnerOid();
					changes.put(dto.getOwnerOid(), gcn);
				}
				gcn = changes.get(dto.getOwnerOid());
				gcn.removedFrom.add(dto);
			}
			for(Long userOid: changes.keySet()) {
				GroupChangeNotification gcn = changes.get(userOid);
				StringBuffer buff = new StringBuffer();
				buff.append(""<P>"" + userName + "" has modified the group membership of the Target "" + aTarget.getName() + "".</p>"");
				if(!gcn.addedTo.isEmpty()) {
					buff.append(""<p>"" + aTarget.getName() + "" has been explicitly or implicitly added to the following of your groups:</p>"");
					Iterator<AbstractTargetDTO> it = gcn.addedTo.iterator();
					buff.append(""<ul>"");
					while(it.hasNext()) {
						buff.append(""<li>"" + it.next().getName() + ""</li>"");
					}
					buff.append(""</ul>"");
				}
				if(!gcn.removedFrom.isEmpty()) {
					buff.append(""<p>"" + aTarget.getName() + "" has been explicitly or implicitly removed from the following of your groups:</p>"");
					Iterator<AbstractTargetDTO> it = gcn.removedFrom.iterator();
					buff.append(""<ul>"");
					while(it.hasNext()) {
						buff.append(""<li>"" + it.next().getName() + ""</li>"");
					}
					buff.append(""</ul>"");
				}
				intrayManager.generateNotification(gcn.userOid, MessageType.CATEGORY_MISC, ""Target Group membership updated"", buff.toString());
			}
		}
	}
	private static class GroupChangeNotification {
		 private Long userOid;
		private Set<AbstractTargetDTO> addedTo = new TreeSet<AbstractTargetDTO>(new AbstractTargetDTO.NameComparator());
		private Set<AbstractTargetDTO> removedFrom = new TreeSet<AbstractTargetDTO>(new AbstractTargetDTO.NameComparator());
	}
	public void save(Target aTarget) {
		save(aTarget, null);
	}
	private void unschedule(AbstractTarget aTarget) {
		targetInstanceDao.deleteScheduledInstances(aTarget);
	}
	public void save(TargetGroup aTargetGroup) {
		save(aTargetGroup, null);
	}
	public void save(TargetGroup aTargetGroup, List<GroupMemberDTO> parents) {
		boolean sipTypeChanged = false;
		if(!aTargetGroup.isNew()) {
			Integer sipType = targetDao.loadPersistedGroupSipType(aTargetGroup.getOid());
			if(sipType.intValue() != aTargetGroup.getSipType()) {
				sipTypeChanged = true;
			}
		}
		for(Schedule schedule: aTargetGroup.getRemovedSchedules()) {
			log.debug(""Removing schedule: "" + schedule.getCronPattern());
			targetInstanceDao.deleteScheduledInstances(schedule);
		}
		AbstractTargetDTO originalTargetGroup = null;
		if(!aTargetGroup.isNew()) {
			originalTargetGroup = targetDao.loadAbstractTargetDTO(aTargetGroup.getOid());
		}
		List<GroupMemberDTO> newChildren = aTargetGroup.getNewChildren();
		Set<Long> removedChildren = aTargetGroup.getRemovedChildren();
		Set<AbstractTargetDTO> origParents = Collections.EMPTY_SET;
		if(!aTargetGroup.isNew()) {
			origParents = targetDao.getAncestorDTOs(aTargetGroup.getOid());
		}
		int originalState = aTargetGroup.getOriginalState();
		targetDao.save(aTargetGroup, true, parents);
		TargetGroup reloaded = targetDao.reloadTargetGroup(aTargetGroup.getOid());
		if(sipTypeChanged) {
			unschedule(reloaded);
		}
		updateTargetGroupStatus(reloaded);
		if(parents != null) {
			for(GroupMemberDTO dto : parents) {
				if(dto.getSaveState() == SAVE_STATE.DELETED) {
					updateTargetGroupStatus(targetDao.loadGroup(dto.getParentOid()));
				}
			}
		}
		if(originalState != aTargetGroup.getState()) {
			auditor.audit(TargetGroup.class.getName(), aTargetGroup.getOid(), Auditor.ACTION_TARGET_GROUP_STATE_CHANGE, ""Target Group "" + aTargetGroup.getName() + "" has changed into state '"" + aTargetGroup.getState() + ""'"" );
		}
		if(originalTargetGroup != null) {
			 auditor.audit(TargetGroup.class.getName(), aTargetGroup.getOid(), Auditor.ACTION_UPDATE_TARGET_GROUP, ""Target Group "" + aTargetGroup.getName() + "" has been updated"");
			if(!originalTargetGroup.getOwnerOid().equals(aTargetGroup.getOwningUser().getOid())) {
				auditor.audit(TargetGroup.class.getName(), aTargetGroup.getOid(), Auditor.ACTION_TARGET_GROUP_CHANGE_OWNER, ""Target Group "" + aTargetGroup.getName() + "" has been given to "" + aTargetGroup.getOwningUser().getNiceName());
			}
			if(!originalTargetGroup.getProfileOid().equals(aTargetGroup.getProfile().getOid())) {
				auditor.audit(TargetGroup.class.getName(), aTargetGroup.getOid(), Auditor.ACTION_TARGET_GROUP_CHANGE_PROFILE, ""Target Group "" + aTargetGroup.getName() + "" is now using profile "" + aTargetGroup.getProfile().getName());
			}
		}
		else {
			auditor.audit(TargetGroup.class.getName(), aTargetGroup.getOid(), Auditor.ACTION_NEW_TARGET_GROUP, ""Target Group "" + aTargetGroup.getName() + "" has been created"");
		}
		List<AbstractTarget> newMembers = new LinkedList<AbstractTarget>();
		for(GroupMemberDTO dto: newChildren) {
			if(removedChildren.contains(dto.getChildOid())) {
				removedChildren.remove(dto.getChildOid());
			}
			else {
				newMembers.add(targetDao.loadAbstractTarget(dto.getChildOid()));
			}
		}
		List<AbstractTarget> removedTargets = new LinkedList<AbstractTarget>();
		for(Long childOid: removedChildren) {
			removedTargets.add(loadAbstractTarget(childOid));
		}
		GroupEventPropagator gep = new GroupEventPropagator(this, instanceManager, reloaded, newMembers);
		gep.runEventChain();
		MembersRemovedEventPropagator mrep = new MembersRemovedEventPropagator(this, instanceManager, reloaded, removedTargets);
		mrep.runEventChain();
		if(parents != null) {
			for(GroupMemberDTO dto : parents) {
				switch(dto.getSaveState()) {
					case NEW:TargetGroup grp = targetDao.loadGroup(dto.getParentOid());
					gep = new GroupEventPropagator(this, instanceManager, grp, reloaded);
					gep.runEventChain();
					break;
					case DELETED:TargetGroup grp2 = targetDao.loadGroup(dto.getParentOid());
					mrep = new MembersRemovedEventPropagator(this, instanceManager, grp2, reloaded);
					mrep.runEventChain();
					break;
				}
			}
		}
		for(Annotation anno : aTargetGroup.getAnnotations()) {
			anno.setObjectOid(aTargetGroup.getOid());
		}
		annotationDAO.saveAnnotations(aTargetGroup.getAnnotations());
		annotationDAO.deleteAnnotations(aTargetGroup.getDeletedAnnotations());
		if ( sendGroupUpdateNotifications && AuthUtil.getRemoteUserObject() !=null ) {
			String userName = AuthUtil.getRemoteUserObject().getNiceName();
			Set<AbstractTargetDTO> newParents = targetDao.getAncestorDTOs(reloaded.getOid());
			Set<AbstractTargetDTO> addedParents = new HashSet<AbstractTargetDTO>(newParents);
			addedParents.removeAll(origParents);
			Set<AbstractTargetDTO> removedParents = new HashSet<AbstractTargetDTO>(origParents);
			removedParents.removeAll(newParents);
			HashMap<Long, GroupChangeNotification> changes = new HashMap<Long, GroupChangeNotification>();
			for(AbstractTargetDTO dto : addedParents) {
				GroupChangeNotification gcn = null;
				if(!changes.containsKey(dto.getOwnerOid())) {
					gcn = new GroupChangeNotification();
					gcn.userOid = dto.getOwnerOid();
					changes.put(dto.getOwnerOid(), gcn);
				}
				gcn = changes.get(dto.getOwnerOid());
				gcn.addedTo.add(dto);
			}
			for(AbstractTargetDTO dto : removedParents) {
				GroupChangeNotification gcn = null;
				if(!changes.containsKey(dto.getOwnerOid())) {
					gcn = new GroupChangeNotification();
					gcn.userOid = dto.getOwnerOid();
					changes.put(dto.getOwnerOid(), gcn);
				}
				gcn = changes.get(dto.getOwnerOid());
				gcn.removedFrom.add(dto);
			}
			for(Long userOid: changes.keySet()) {
				GroupChangeNotification gcn = changes.get(userOid);
				StringBuffer buff = new StringBuffer();
				buff.append(""<P>"" + userName + "" has modified the group membership of the TargetGroup "" + reloaded.getName() + "".</p>"");
				if(!gcn.addedTo.isEmpty()) {
					buff.append(""<p>"" + reloaded.getName() + "" has been explicitly or implicitly added to the following of your groups:</p>"");
					Iterator<AbstractTargetDTO> it = gcn.addedTo.iterator();
					buff.append(""<ul>"");
					while(it.hasNext()) {
						buff.append(""<li>"" + it.next().getName() + ""</li>"");
					}
					buff.append(""</ul>"");
				}
				if(!gcn.removedFrom.isEmpty()) {
					buff.append(""<p>"" + reloaded.getName() + "" has been explicitly or implicitly removed from the following of your groups:</p>"");
					Iterator<AbstractTargetDTO> it = gcn.removedFrom.iterator();
					buff.append(""<ul>"");
					while(it.hasNext()) {
						buff.append(""<li>"" + it.next().getName() + ""</li>"");
					}
					buff.append(""</ul>"");
				}
				intrayManager.generateNotification(gcn.userOid, MessageType.CATEGORY_MISC, ""Target Group membership updated"", buff.toString());
			}
		}
		if(sendGroupUpdateNotifications && (removedChildren.size() > 0 || newChildren.size() > 0)) {
			String userName = AuthUtil.getRemoteUserObject().getNiceName();
			StringBuffer buff = new StringBuffer();
			buff.append(""<p>"");
			buff.append(userName);
			buff.append("" has updated the group <i>"");
			buff.append(aTargetGroup.getName());
			buff.append(""</i>.</p>"");
			if(newMembers.size() > 0) {
				buff.append(""<p>The following members have been added:</p><ul>"");
				for(AbstractTarget newMember: newMembers) {
					buff.append(""<li>"");
					buff.append(newMember.getName());
					buff.append(""</li>"");
				}
				buff.append(""</ul>"");
			}
			if(removedTargets.size() > 0) {
				buff.append(""<p>The following members have been removed:</p><ul>"");
				for(AbstractTarget removedMember: removedTargets) {
					buff.append(""<li>"");
					buff.append(removedMember.getName());
					buff.append(""</li>"");
				}
				buff.append(""</ul>"");
			}
			buff.append(""<p>These changes directly or indirectly affect some of your groups as follows:</p>"");
			for(User recipient: gep.getUpdatedGroups().keySet()) {
				StringBuffer message = new StringBuffer(buff.toString());
				message.append(""<ul>"");
				for(TargetGroup group: gep.getUpdatedGroups().get(recipient)) {
					message.append(""<li>"");
					message.append(group.getName());
					message.append(""</li>"");
				}
				message.append(""</ul>"");
				if(!recipient.getOid().equals(AuthUtil.getRemoteUserObject().getOid()) || gep.getUpdatedGroups().get(recipient).size() > 1) {
					intrayManager.generateNotification(recipient.getOid(), MessageType.CATEGORY_MISC, ""Target Group membership updated"", message.toString());
				}
			}
		}
	}
	public void scheduleTargetGroup(TargetGroup aGroup) {
		for(Schedule schedule : aGroup.getSchedules()) {
			processSchedule(schedule);
		}
	}
	 public int[] getNextStates(Target aTarget) {
		 switch(aTarget.getOriginalState()) {
			 case Target.STATE_PENDING: return authMgr.hasPrivilege(aTarget, Privilege.APPROVE_TARGET) ? new int[] {
			 Target.STATE_NOMINATED, Target.STATE_APPROVED, Target.STATE_REJECTED }
			 : new int[] {
			 Target.STATE_NOMINATED }
			;
			 case Target.STATE_REINSTATED: return authMgr.hasPrivilege(aTarget, Privilege.APPROVE_TARGET) ? new int[] {
			 Target.STATE_NOMINATED, Target.STATE_APPROVED, Target.STATE_REJECTED }
			 : new int[] {
			 Target.STATE_NOMINATED }
			;
			 case Target.STATE_NOMINATED: return authMgr.hasPrivilege(aTarget, Privilege.APPROVE_TARGET) ? new int[] {
			 Target.STATE_APPROVED, Target.STATE_REJECTED }
			 : new int[] {
			 }
			;
			 case Target.STATE_REJECTED: return authMgr.hasPrivilege(aTarget, Privilege.REINSTATE_TARGET) ? new int[] {
			 Target.STATE_REINSTATED }
			 : new int[] {
			 }
			;
			 case Target.STATE_APPROVED: return authMgr.hasPrivilege(aTarget, Privilege.CANCEL_TARGET) ? new int[] {
			 Target.STATE_CANCELLED }
			 : new int[] {
			 }
			;
			 case Target.STATE_CANCELLED: return authMgr.hasPrivilege(aTarget, Privilege.REINSTATE_TARGET) ? new int[] {
			 Target.STATE_REINSTATED }
			 : new int[] {
			 }
			;
			 case Target.STATE_COMPLETED: return authMgr.hasPrivilege(aTarget, Privilege.REINSTATE_TARGET) ? new int[] {
			 Target.STATE_REINSTATED }
			 : new int[] {
			 }
			;
			 default: assert false : ""Illegal State"";
			 return new int[] {
			 }
			;
		 }
	 }
	public Target load(Long oid) {
		return load(oid, false);
	}
	public Target load(Long oid, boolean loadFully) {
		return targetDao.load(oid, loadFully);
	}
	public List<Permission> getQuickPickPermissions(Target aTarget) {
		return siteDao.getQuickPickPermissions(aTarget.getOwningUser().getAgency());
	}
	public Pagination findPermissionsBySiteTitle(Target aTarget, String aSiteTitle, int aPageNumber) {
		return siteDao.findPermissionsBySiteTitle(aTarget.getOwningUser().getAgency().getOid(), aSiteTitle, aPageNumber);
	}
	public Pagination findPermissionsByUrl(Target aTarget, String aUrl, int aPageNumber) {
		List<Permission> permissionList = new LinkedList<Permission>();
		permissionList.addAll(PermissionMappingStrategy.getStrategy().getMatchingPermissions(aTarget, aUrl));
		return new Pagination(permissionList, aPageNumber, Constants.GBL_PAGE_SIZE);
	}
	public Permission loadPermission(TargetEditorContext ctx, String identity) {
		Permission p = (Permission) ctx.getObject(Permission.class, identity);
		if(p == null) {
			p = siteDao.loadPermission(Long.parseLong(identity));
			ctx.putObject(p);
		}
		return p;
	}
	public Permission loadPermission(Long oid) {
		return siteDao.loadPermission(oid);
	}
	public boolean isNameOk(AbstractTarget aTarget) {
		return targetDao.isNameOk(aTarget);
	}
	public void setTargetDao(TargetDAO targetDao) {
		this.targetDao = targetDao;
	}
	public void setAuthMgr(AuthorityManager authMgr) {
		this.authMgr = authMgr;
	}
	public void setSiteDao(SiteDAO siteDao) {
		this.siteDao = siteDao;
	}
	public List<Annotation> getAnnotations(AbstractTarget aTarget) {
		List<Annotation> annotations = null;
		if (aTarget.getOid() != null) {
			String className;
			if(aTarget instanceof TargetGroup){
				className = TargetGroup.class.getName();
			}
			else{
				className = aTarget.getClass().getName();
			}
			annotations = annotationDAO.loadAnnotations(className, aTarget.getOid());
		}
		if (annotations == null) {
			annotations = new ArrayList<Annotation>();
		}
		return annotations;
	}
	public void setAnnotationDAO(AnnotationDAO annotationDAO) {
		this.annotationDAO = annotationDAO;
	}
	public boolean isTargetHarvestable(TargetInstance aTargetInstance) {
		boolean harvestable = false;
		boolean foundBadSeed = false;
		AbstractTarget aTarget = aTargetInstance.getTarget();
		if(aTarget.getObjectType() == AbstractTarget.TYPE_GROUP) {
			return getSeeds(aTargetInstance).size() > 0;
		}
		else {
			Target target = targetDao.load(aTarget.getOid(), true);
			Seed seed = null;
			Set<Seed> seeds = target.getSeeds();
			Iterator<Seed> it = seeds.iterator();
			while (it.hasNext()) {
				seed = (Seed) it.next();
				if (!seed.isHarvestable(new Date())) {
					foundBadSeed = true;
					break;
				}
			}
			if (!seeds.isEmpty() && !foundBadSeed) {
				harvestable = true;
			}
			return harvestable;
		}
	}
	public boolean isTargetUsingAQA(Long targetOid) {
		Target target = targetDao.load(targetOid, false);
		return target.isUseAQA();
	}
	public boolean allowStateChange(Target aTarget, int nextState) {
		if(aTarget.getOriginalState() == nextState) {
			 return true;
		}
		else {
			int[] nextStates = getNextStates(aTarget);
			for(int i=0;
			 i<nextStates.length;
			 i++) {
				if(nextStates[i] == nextState) {
					return true;
				}
			}
			return false;
		}
	}
	public TargetGroup loadGroup(Long oid) {
		return targetDao.loadGroup(oid);
	}
	public TargetGroup loadGroup(Long oid, boolean loadFully) {
		return targetDao.loadGroup(oid, loadFully);
	}
	public Pagination getMembers(TargetGroup aTargetGroup, int pageNum, int pageSize) {
		return targetDao.getMembers(aTargetGroup, pageNum, pageSize);
	}
	public Pagination getParents(AbstractTarget aTarget, int pageNum, int pageSize) {
		return targetDao.getParents(aTarget, pageNum, pageSize);
	}
	public Pagination getAbstractTargetDTOs(String name, int pageNumber, int pageSize) {
		return targetDao.getAbstractTargetDTOs(name, pageNumber, pageSize);
	}
	public Pagination getGroupDTOs(String name, int pageNumber, int pageSize) {
		return targetDao.getGroupDTOs(name, pageNumber, pageSize);
	}
	public Pagination getSubGroupParentDTOs(String name, int pageNumber, int pageSize) {
		List<String> types = new ArrayList<String>();
		Iterator<String> it = subGroupParentTypesList.iterator();
		while(it.hasNext()){
			types.add(it.next());
		}
		return targetDao.getSubGroupParentDTOs(name, types, pageNumber, pageSize);
	}
	public Pagination getNonSubGroupDTOs(String name, int pageNumber, int pageSize) {
		return targetDao.getNonSubGroupDTOs(name, subGroupTypeName, pageNumber, pageSize);
	}
	public GroupMemberDTO createGroupMemberDTO(TargetGroup group, Long childOid) {
		AbstractTarget child = targetDao.loadAbstractTarget(childOid);
		return new GroupMemberDTO(group, child);
	}
	public GroupMemberDTO createGroupMemberDTO(Long groupOid, Target child) {
		TargetGroup group = targetDao.loadGroup(groupOid);
		return new GroupMemberDTO(group, child);
	}
	public Pagination searchGroups(int pageNumber, int pageSize, Long searchOid, String name, String owner, String agency, String memberOf, String groupType, boolean nondisplayonly) {
		return targetDao.searchGroups(pageNumber, pageSize, searchOid, name, owner, agency, memberOf, groupType, nondisplayonly);
	}
	public void setTargetInstanceDao(TargetInstanceDAO targetInstanceDao) {
		this.targetInstanceDao = targetInstanceDao;
	}
	public void processSchedulesJob() {
		List<Schedule> schedules = targetDao.getSchedulesToRun();
		System.out.println(""Batch processing "" + schedules.size() + "" schedules."");
		for(Schedule s: schedules) {
			 if (s.getTarget() == null) {
				 System.out.println("" Schedule has null target so skipping processing: "" + s.getOid());
				 log.debug("" Schedule has null target so skipping processing: "" + s.getOid());
				 Calendar cal = Calendar.getInstance();
				 cal.setTime(new Date());
				 s.setLastProcessedDate(cal.getTime());
				 targetDao.save(s);
				 System.out.println("" Saved schedule: "" + s.getOid() + "" - set last processed date to: "" + cal.getTime() );
			 }
			 else {
				 log.debug("" Processing schedule: "" + s.getOid());
				 processBatchSchedule(s);
			 }
		}
	}
	public void processSchedule(Schedule aSchedule) {
		AbstractTarget aTarget = aSchedule.getTarget();
		boolean checkAgency = false;
		if(aTarget.getObjectType() == AbstractTarget.TYPE_GROUP){
			TargetGroup group;
			if(aTarget instanceof TargetGroup){
				group = (TargetGroup)aTarget;
			}
			else{
				group = targetDao.loadGroup(aTarget.getOid());
			}
			if (group.getSipType() == TargetGroup.MANY_SIP){
				checkAgency = true;
			}
		}
		createTargetInstances(aSchedule.getTarget(), aSchedule, checkAgency);
		 int daysToSchedule = EnvironmentFactory.getEnv().getDaysToSchedule();
		 Calendar cal = Calendar.getInstance();
		 cal.setTime(new Date());
		 cal.add(Calendar.DAY_OF_MONTH, daysToSchedule);
		 cal.add(Calendar.SECOND, -1);
		 Date firstAfterPeriod = aSchedule.getNextExecutionDate(cal.getTime());
		 if(firstAfterPeriod != null) {
			 aSchedule.setNextScheduleAfterPeriod(firstAfterPeriod);
			 targetDao.save(aSchedule);
		 }
	}
	public void processBatchSchedule(Schedule aSchedule) {
		AbstractTarget aTarget = aSchedule.getTarget();
		 boolean checkAgency = false;
		TargetGroup group = null;
		Hibernate.initialize(aTarget);
		if(aTarget.getObjectType() == AbstractTarget.TYPE_GROUP){
			 log.debug("" Schedules target is a group."");
			if(aTarget instanceof TargetGroup){
				group = (TargetGroup)aTarget;
			}
			else{
				group = targetDao.loadGroup(aTarget.getOid(), true);
			}
			if (group.getSipType() == TargetGroup.MANY_SIP){
				checkAgency = true;
			}
		}
		 else {
			 log.debug("" Schedules target is a target."");
		}
		createBatchTargetInstances(aTarget, aSchedule, group, checkAgency);
		 int daysToSchedule = EnvironmentFactory.getEnv().getDaysToSchedule();
		 Calendar cal = Calendar.getInstance();
		 cal.setTime(new Date());
		 cal.add(Calendar.DAY_OF_MONTH, daysToSchedule);
		 cal.add(Calendar.SECOND, -1);
		 Calendar cal2 = Calendar.getInstance();
		 cal2.setTime(new Date());
		 Date firstAfterPeriod = aSchedule.getNextExecutionDate(cal.getTime());
		 if(firstAfterPeriod != null) {
			 aSchedule.setNextScheduleAfterPeriod(firstAfterPeriod);
		 }
		aSchedule.setLastProcessedDate(cal2.getTime());
		targetDao.save(aSchedule);
		 log.debug("" Saved schedule: "" + aSchedule.getOid() + "" - set last processed date to: "" + cal2.getTime() );
	}
	public void createBatchTargetInstances(AbstractTarget aTarget, Schedule aSchedule, TargetGroup aGroup, boolean checkAgency) {
		 int objectType = aTarget.getObjectType();
		 if( objectType == AbstractTarget.TYPE_TARGET || ( objectType == AbstractTarget.TYPE_GROUP && aGroup.getSipType() == TargetGroup.ONE_SIP ) ) {
			 if(checkAgency && !aTarget.getOwner().getAgency().equals(aSchedule.getOwningUser().getAgency())) {
				 return;
			 }
			 else if(!aTarget.isSchedulable()) {
				 return;
			 }
			 else {
				 Set<TargetInstance> targetInstances = new HashSet<TargetInstance>();
				 int daysToSchedule = EnvironmentFactory.getEnv().getDaysToSchedule();
				 Calendar cal = Calendar.getInstance();
				 cal.setTime(new Date());
				 cal.add(Calendar.DAY_OF_MONTH, daysToSchedule);
				 Date scheduleTill = aSchedule.getEndDate() == null ? cal.getTime() : DateUtils.earliestDate(aSchedule.getEndDate(), cal.getTime());
				 Date startFrom = targetDao.getLatestScheduledDate(aTarget, aSchedule);
				 if(startFrom == null) {
					 startFrom = new Date();
				 }
				 startFrom = DateUtils.latestDate(startFrom, aSchedule.getStartDate());
				 List<Annotation> targetAnnotations = getAnnotations(aTarget);
				 boolean firstForTarget = false;
				 for(startFrom = aSchedule.getNextExecutionDate(startFrom);
				 startFrom != null && startFrom.before(scheduleTill);
				 startFrom = aSchedule.getNextExecutionDate(startFrom)) {
					 TargetInstance ti = new TargetInstance();
					 ti.setTarget(aTarget);
					 ti.setSchedule(aSchedule);
					 ti.setScheduledTime(startFrom);
					 ti.setOwner(aSchedule.getOwningUser());
					 if ( !firstForTarget && instanceManager.countTargetInstancesByTarget(aTarget.getOid()) == 0 ) {
						 ti.setFirstFromTarget(true);
						 firstForTarget = true;
					 }
					 if( objectType == AbstractTarget.TYPE_TARGET ) {
						 for (Iterator<Annotation> i = targetAnnotations.iterator( );
						 i.hasNext();
						 ) {
							 Annotation toCopy = i.next();
							 if (toCopy.isAlertable()) {
								 Annotation annotation = new Annotation();
								 annotation.setDate(toCopy.getDate());
								 annotation.setNote(toCopy.getNote());
								 annotation.setAlertable(true);
								 annotation.setUser(toCopy.getUser());
								 annotation.setObjectType(TargetInstance.class.getName());
								 ti.addAnnotation(annotation);
							 }
						 }
						 ti.setUseAQA(isTargetUsingAQA(aTarget.getOid()));
					 }
					 targetInstances.add(ti);
				 }
				 for(TargetInstance toSave: targetInstances) {
					 targetInstanceDao.save(toSave);
					 for(Annotation anno : toSave.getAnnotations()) {
						 anno.setObjectOid(toSave.getOid());
					 }
					 annotationDAO.saveAnnotations(toSave.getAnnotations());
					 log.debug("" Saved TI: "" + toSave.getOid());
				 }
				 log.debug("" Created "" + targetInstances.size());
			 }
		 }
		 else if(objectType == AbstractTarget.TYPE_GROUP && aGroup.getSipType() == TargetGroup.MANY_SIP ) {
			 for(GroupMember member: aGroup.getChildren()) {
				 AbstractTarget child = targetDao.load(member.getChild().getOid());
				 if(child.getObjectType() == AbstractTarget.TYPE_GROUP) {
					 continue;
				 }
				 createBatchTargetInstances(child, aSchedule, null, checkAgency);
			 }
			 return;
		 }
		 else {
			 String type = null;
			 if(aTarget instanceof TargetGroup) {
				 type = """" + ((TargetGroup) aTarget).getSipType();
			 }
			 throw new WCTRuntimeException(""Unknown Target Type: "" + aTarget.getClass() + "" ("" + type + "")"");
		 }
	 }
	public void createTargetInstances(AbstractTarget aTarget, Schedule aSchedule, boolean checkAgency) {
		 int objectType = aTarget.getObjectType();
		 if(objectType == AbstractTarget.TYPE_GROUP) {
			 if(!(aTarget instanceof TargetGroup)) {
				 aTarget = targetDao.loadGroup(aTarget.getOid());
			 }
		 }
		 if( objectType == AbstractTarget.TYPE_TARGET || objectType == AbstractTarget.TYPE_GROUP && ((TargetGroup)aTarget).getSipType() == TargetGroup.ONE_SIP ) {
			 if(checkAgency && !aTarget.getOwner().getAgency().equals(aSchedule.getOwningUser().getAgency())) {
				 return;
			 }
			 else if(!aTarget.isSchedulable()) {
				 return;
			 }
			 else {
				 Set<TargetInstance> targetInstances = new HashSet<TargetInstance>();
				 int daysToSchedule = EnvironmentFactory.getEnv().getDaysToSchedule();
				 Calendar cal = Calendar.getInstance();
				 cal.setTime(new Date());
				 cal.add(Calendar.DAY_OF_MONTH, daysToSchedule);
				 Date scheduleTill = aSchedule.getEndDate() == null ? cal.getTime() : DateUtils.earliestDate(aSchedule.getEndDate(), cal.getTime());
				 Date startFrom = targetDao.getLatestScheduledDate(aTarget, aSchedule);
				 if(startFrom == null) {
					 startFrom = new Date();
				 }
				 startFrom = DateUtils.latestDate(startFrom, aSchedule.getStartDate());
				 List<Annotation> targetAnnotations = getAnnotations(aTarget);
				 boolean firstForTarget = false;
				 for(startFrom = aSchedule.getNextExecutionDate(startFrom);
				 startFrom != null && startFrom.before(scheduleTill);
				 startFrom = aSchedule.getNextExecutionDate(startFrom)) {
					 TargetInstance ti = new TargetInstance();
					 ti.setTarget(aTarget);
					 ti.setSchedule(aSchedule);
					 ti.setScheduledTime(startFrom);
					 ti.setOwner(aSchedule.getOwningUser());
					 if ( !firstForTarget && instanceManager.countTargetInstancesByTarget(aTarget.getOid()) == 0 ) {
						 ti.setFirstFromTarget(true);
						 firstForTarget = true;
					 }
					 if( objectType == AbstractTarget.TYPE_TARGET ) {
						 for (Iterator<Annotation> i = targetAnnotations.iterator( );
						 i.hasNext();
						 ) {
							 Annotation toCopy = i.next();
							 if (toCopy.isAlertable()) {
								 Annotation annotation = new Annotation();
								 annotation.setDate(toCopy.getDate());
								 annotation.setNote(toCopy.getNote());
								 annotation.setAlertable(true);
								 annotation.setUser(toCopy.getUser());
								 annotation.setObjectType(TargetInstance.class.getName());
								 ti.addAnnotation(annotation);
							 }
						 }
						 ti.setUseAQA(isTargetUsingAQA(aTarget.getOid()));
					 }
					 targetInstances.add(ti);
				 }
				 for(TargetInstance toSave: targetInstances) {
					 targetInstanceDao.save(toSave);
					 for(Annotation anno : toSave.getAnnotations()) {
						 anno.setObjectOid(toSave.getOid());
					 }
					 annotationDAO.saveAnnotations(toSave.getAnnotations());
					 log.debug("" Saved TI: "" + toSave.getOid());
				 }
				 System.out.println("" Created "" + targetInstances.size());
			 }
		 }
		 else if(objectType == AbstractTarget.TYPE_GROUP && ((TargetGroup)aTarget).getSipType() == TargetGroup.MANY_SIP) {
			 TargetGroup aTargetGroup = (TargetGroup) aTarget;
			 for(GroupMember member: aTargetGroup.getChildren()) {
				 AbstractTarget child = member.getChild();
				 if(child.getObjectType() == AbstractTarget.TYPE_GROUP) {
					 TargetGroup childGroup = targetDao.loadGroup(child.getOid(), false);
					 if(subGroupTypeName.equals(childGroup.getType())) {
						 continue;
					 }
				 }
				 createTargetInstances(child, aSchedule, checkAgency);
			 }
			 return;
		 }
		 else {
			 String type = null;
			 if(aTarget instanceof TargetGroup) {
				 type = """" + ((TargetGroup) aTarget).getSipType();
			 }
			 throw new WCTRuntimeException(""Unknown Target Type: "" + aTarget.getClass() + "" ("" + type + "")"");
		 }
	 }
	 private void updateTargetGroupStatus(Target aTarget) {
		 for(GroupMember parent: aTarget.getParents()) {
			 updateTargetGroupStatus(parent.getParent());
		 }
	 }
	 private void updateTargetGroupStatus(TargetGroup aTargetGroup) {
		 int originalState = aTargetGroup.getState();
		 int newState = originalState;
		 Date now = new Date();
		 if(aTargetGroup.getToDate() != null && aTargetGroup.getToDate().before(now)) {
			 newState = TargetGroup.STATE_INACTIVE;
		 }
		 else {
			 boolean allInactive = true;
			 newState = Target.STATE_PENDING;
			 for(Integer state: targetDao.getSavedMemberStates(aTargetGroup)) {
				 if(state != TargetGroup.STATE_INACTIVE) {
					 allInactive = false;
				 }
				 if( state == Target.STATE_APPROVED || state == Target.STATE_COMPLETED || state == TargetGroup.STATE_ACTIVE) {
					 newState = TargetGroup.STATE_ACTIVE;
				 }
			 }
			 if(allInactive) {
				 newState = TargetGroup.STATE_INACTIVE;
			 }
		 }
		 if( newState == TargetGroup.STATE_ACTIVE) {
			 scheduleTargetGroup(aTargetGroup);
		 }
		 else {
			 log.debug(""About to Unschedule the Group"");
			 unschedule(aTargetGroup);
			 log.debug(""Unscheduled the group"");
		 }
		 if( originalState != newState) {
			 aTargetGroup.changeState(newState);
			 targetDao.save(aTargetGroup, false, null);
			 if(aTargetGroup.getState() == TargetGroup.STATE_ACTIVE) {
				 scheduleTargetGroup(aTargetGroup);
			 }
			 else {
				 unschedule(aTargetGroup);
			 }
			 for(GroupMember parent: aTargetGroup.getParents()) {
				 updateTargetGroupStatus(parent.getParent());
			 }
		 }
	 }
	 public Set<Seed> getSeeds(TargetInstance aTargetInstance) {
		 return getSeeds(aTargetInstance.getTarget(), aTargetInstance.getOwner().getAgency().getOid());
	 }
	 public Set<Seed> getSeeds(AbstractTarget aTarget, Long agencyOid) {
		 int objectType = aTarget.getObjectType();
		 if(objectType == AbstractTarget.TYPE_TARGET) {
			 Target theTarget = null;
			 if(aTarget instanceof Target) {
				 theTarget = (Target)aTarget;
			 }
			 else{
				 theTarget = targetDao.load(aTarget.getOid());
			}
			 return targetDao.getSeeds(theTarget);
		 }
		 else if(objectType == AbstractTarget.TYPE_GROUP) {
			 TargetGroup theTargetGroup = null;
			 if(aTarget instanceof TargetGroup) {
				 theTargetGroup = (TargetGroup)aTarget;
			 }
			 else{
				 theTargetGroup = targetDao.loadGroup(aTarget.getOid());
			}
			 return targetDao.getSeeds(theTargetGroup, agencyOid, subGroupTypeName);
		 }
		 else {
			 throw new WCTRuntimeException(""Unknown Target Type for getSeeds: "" + objectType);
		 }
	 }
	 public int countTargets(User aUser) {
		 return targetDao.countTargets(aUser.getUsername());
	 }
	 public int countTargetGroups(User aUser) {
		 return targetDao.countTargetGroups(aUser.getUsername());
	 }
	public TargetInstanceManager getInstanceManager() {
		return instanceManager;
	}
	public void setInstanceManager(TargetInstanceManager instanceManager) {
		this.instanceManager = instanceManager;
	}
	public InTrayManager getIntrayManager() {
		return intrayManager;
	}
	public void setIntrayManager(InTrayManager intrayManager) {
		this.intrayManager = intrayManager;
	}
	public Set<Long> getAncestorOids(AbstractTarget child) {
		return targetDao.getAncestorOids(child.getOid());
	}
	public boolean isDuplicateMember(TargetGroup group, Long memberOid) {
		for(GroupMemberDTO dto: group.getNewChildren()) {
			if(dto.getChildOid().equals(memberOid)) {
				return true;
			}
		}
		return targetDao.getImmediateChildrenOids(group.getOid()).contains(memberOid);
	}
	 public AbstractTarget loadAbstractTarget(Long oid) {
		 return targetDao.loadAbstractTarget(oid);
	 }
	public boolean isSendGroupUpdateNotifications() {
		return sendGroupUpdateNotifications;
	}
	public void setSendGroupUpdateNotifications(boolean sendGroupUpdateNotifications) {
		this.sendGroupUpdateNotifications = sendGroupUpdateNotifications;
	}
	public void endDateGroups() {
		targetInstanceDao.endDateGroups();
	}
	public int transferSeeds(Permission fromPermission, Permission toPermission) {
		List<Seed> seeds = targetDao.getLinkedSeeds(fromPermission);
		for(Seed s: seeds) {
			s.removePermission(fromPermission);
			s.addPermission(toPermission);
		}
		targetDao.saveAll(seeds);
		return seeds.size();
	}
	public Pagination searchPermissions(PermissionCriteria aPermissionCriteria) {
		return targetDao.searchPermissions(aPermissionCriteria);
	}
	public List<TargetGroup> getActiveParentGroups(TargetInstance aTargetInstance) {
		List<TargetGroup> ancestorList = new LinkedList<TargetGroup>();
		for(GroupMember parents: aTargetInstance.getTarget().getParents()) {
			getActiveParentGroups(parents.getParent(), aTargetInstance.getActualStartTime(), ancestorList);
		}
		return ancestorList;
	}
	public Collection<PermissionSeedDTO> getActivePermissions(TargetInstance aTargetInstance) {
		HashMap<Long, PermissionSeedDTO> permissions = new HashMap<Long, PermissionSeedDTO>();
		 Set<Seed> seeds = getSeeds(aTargetInstance);
		Date now = new Date();
		PermissionSeedDTO psdto = null;
		Set<Permission> ps = null;
		for (Seed seed : seeds) {
			ps = seed.getPermissions();
			for (Permission p : ps) {
				if(p.getStartDate().before(now) && (p.getEndDate() == null || p.getEndDate().after(now))) {
					if (permissions.containsKey(p.getOid())) {
						psdto = (PermissionSeedDTO) permissions.get(p.getOid());
					}
					else {
						psdto = new PermissionSeedDTO(p);
					}
					psdto.getSeeds().add(seed.getSeed());
					permissions.put(psdto.getPermissionOid(), psdto);
				}
			}
		}
		return permissions.values();
	}
	private void getActiveParentGroups(TargetGroup aGroup, Date aDate, List<TargetGroup> destList) {
		if((aGroup.getFromDate() == null || aGroup.getFromDate().before(aDate)) && (aGroup.getToDate() == null || aGroup.getToDate().after(aDate))) {
			destList.add(aGroup);
			for(GroupMember parents : aGroup.getParents()) {
				getActiveParentGroups(parents.getParent(), aDate, destList);
			}
		}
	}
	public void setAuditor(Auditor auditor) {
		this.auditor = auditor;
	}
	public void setMessageSource(MessageSource messageSource) {
		this.messageSource = messageSource;
	}
	public Target copy(Target aTarget) {
		Target copy = businessObjectFactory.newTarget();
		copy.setDescription(aTarget.getDescription());
		copy.setProfile(aTarget.getProfile());
		copy.setOverrides(aTarget.getOverrides().copy());
		for(Seed seed: aTarget.getSeeds()) {
			Seed newSeed = businessObjectFactory.newSeed(copy);
			newSeed.setPrimary(seed.isPrimary());
			newSeed.setSeed(seed.getSeed());
			for(Permission perm: seed.getPermissions()) {
				newSeed.addPermission(perm);
			}
			copy.addSeed(newSeed);
		}
		for(Schedule schedule: aTarget.getSchedules()) {
			Schedule newSchedule = businessObjectFactory.newSchedule(copy);
			newSchedule.setCronPattern(schedule.getCronPattern());
			newSchedule.setStartDate(schedule.getStartDate());
			newSchedule.setEndDate(schedule.getEndDate());
			newSchedule.setScheduleType(schedule.getScheduleType());
			copy.addSchedule(newSchedule);
		}
		return copy;
	}
	private static String trunc(String str, int length) {
		if(str.length() > length) {
			return str.substring(0, length);
		}
		else {
			return str;
		}
	}
	public TargetGroup copy(TargetGroup aTargetGroup) {
		TargetGroup copy = businessObjectFactory.newTargetGroup();
		copy.setName(trunc(""Copy of "" + aTargetGroup.getName(), AbstractTarget.CNST_MAX_NAME_LENGTH));
		copy.setDescription(aTargetGroup.getDescription());
		for(Schedule schedule: aTargetGroup.getSchedules()) {
			Schedule newSchedule = businessObjectFactory.newSchedule(copy);
			newSchedule.setCronPattern(schedule.getCronPattern());
			newSchedule.setStartDate(schedule.getStartDate());
			newSchedule.setEndDate(schedule.getEndDate());
			newSchedule.setScheduleType(schedule.getScheduleType());
			copy.addSchedule(newSchedule);
		}
		copy.setProfile(aTargetGroup.getProfile());
		copy.setOverrides(aTargetGroup.getOverrides().copy());
		for(GroupMember gm : aTargetGroup.getChildren()) {
			copy.getNewChildren().add( new GroupMemberDTO(copy, gm.getChild()));
		}
		return copy;
	}
	public void deleteTarget(Target aTarget) {
		if(authMgr.hasPrivilege(aTarget, Privilege.DELETE_TARGET) && aTarget.getState() == Target.STATE_PENDING) {
			if(aTarget.getParents().size() > 0) {
				for(GroupMember parent: aTarget.getParents()) {
					parent.getParent().getRemovedChildren().add(aTarget.getOid());
					save(parent.getParent());
				}
			}
			targetDao.delete(aTarget);
		}
		else {
			 log.error(""Delete not permitted, no action taken"");
		}
	}
	public boolean deleteTargetGroup(TargetGroup aTargetGroup) {
		if(authMgr.hasPrivilege(aTargetGroup, Privilege.MANAGE_GROUP)) {
			return targetDao.deleteGroup(aTargetGroup);
		}
		else {
			 log.error(""Delete not permitted, no action taken"");
			 throw new WCTRuntimeException(""You do not have the appropriate privileges to delete this group"");
		}
	}
	public List<GroupMemberDTO> getParents(final AbstractTarget aTarget) {
		return targetDao.getParents(aTarget);
	}
	public void setBusinessObjectFactory(BusinessObjectFactory businessObjectFactory) {
		this.businessObjectFactory = businessObjectFactory;
	}
	public void setSubGroupParentTypesList(WCTTreeSet subGroupParentTypesList) {
		this.subGroupParentTypesList = subGroupParentTypesList;
	}
	public void setSubGroupTypeName(String subGroupTypeName) {
		this.subGroupTypeName = subGroupTypeName;
	}
	public void moveTargets(TargetGroup sourceGroup, TargetGroup targetGroup, List<Long> targetsToMove) {
		Iterator<Long> it = targetsToMove.iterator();
		while(it.hasNext()){
			Long targetToMove = it.next();
			GroupMemberDTO dto = createGroupMemberDTO(targetGroup, targetToMove);
			targetGroup.getNewChildren().add(dto);
			sourceGroup.getRemovedChildren().add(targetToMove);
		}
		save(sourceGroup);
		save(targetGroup);
	}
}",1,0,0,0
"public abstract static class CreatePayload {
	 public abstract String name();
	 public abstract Location location();
 }",0,1,0,0
"private void addCrosstabRows(ReportConverter reportConverter,JRCrosstab crosstab, int rowHeadersXOffset, int colHeadersYOffset, List crosstabElements);",0,0,0,1
private String[] getEnumNames();,0,0,0,0
"OrdsSegmentTermsEnumFrame pushFrame(FST.Arc<Output> arc, long fp, int length, long termOrd) throws IOException {
	 final OrdsSegmentTermsEnumFrame f = getFrame(1+currentFrame.ord);
	 f.arc = arc;
	 if (f.fpOrig == fp && f.nextEnt != -1) {
		 if (f.prefix > targetBeforeCurrentLength) {
			 f.rewind();
		 }
		 else {
		 }
		 assert length == f.prefix;
		 assert termOrd == f.termOrdOrig;
	 }
	 else {
		 f.nextEnt = -1;
		 f.prefix = length;
		 f.state.termBlockOrd = 0;
		 f.termOrdOrig = termOrd;
		 f.termOrd = termOrd;
		 f.fpOrig = f.fp = fp;
		 f.lastSubFP = -1;
	 }
	 return f;
 }",0,0,1,0
"public void buildEmail(String hostName) {
	 String mailBoxPath = getMailboxPath();
	 if (mailBoxPath != null && mailBoxPath.indexOf('@') >= 0) {
		 email = mailBoxPath;
		 alias = getAliasFromMailboxDisplayName();
		 if (alias == null) {
			 alias = getAliasFromLogin();
		 }
	 }
	 else {
		 alias = mailBoxPath;
		 email = getEmail(alias);
		 if (email == null) {
			 alias = getAliasFromLogin();
			 email = getEmail(alias);
		 }
		 if (email == null) {
			 alias = getAliasFromMailboxDisplayName();
			 email = getEmail(alias);
		 }
		 if (email == null) {
			 LOGGER.debug(""Unable to get user email with alias "" + mailBoxPath + "" or "" + getAliasFromLogin() + "" or "" + alias );
			 StringBuilder buffer = new StringBuilder();
			 if (mailBoxPath != null) {
				 alias = mailBoxPath;
			 }
			 else {
				 alias = getAliasFromLogin();
			 }
			 buffer.append(alias);
			 if (alias.indexOf('@') < 0) {
				 buffer.append('@');
				 if (hostName == null) {
					 hostName = ""mail.unknown.com"";
				 }
				 int dotIndex = hostName.indexOf('.');
				 if (dotIndex >= 0) {
					 buffer.append(hostName.substring(dotIndex + 1));
				 }
			 }
			 email = buffer.toString();
		 }
	 }
 }",0,0,1,0
"public void writeLong(long l, String tag) throws IOException {
	 Utils.writeLong(out, l);
 }",0,0,0,0
"public BytesWritable createValue() {
	 return (BytesWritable)ReflectionUtils.newInstance(BytesWritable.class, conf);
 }",0,0,0,0
"public class JcrUtils {
	 public static final String REPOSITORY_URI = ""org.apache.jackrabbit.repository.uri"";
	 public static final Value[] NO_VALUES = new Value[0];
	 private JcrUtils() {
	 }
	 public static Repository getRepository() throws RepositoryException {
		 return getRepository((Map<String, String>) null);
	 }
	 public static Repository getRepository(Map<String, String> parameters) throws RepositoryException {
		 String newline = System.getProperty(""line.separator"");
		 StringBuilder log = new StringBuilder(""Unable to access a repository"");
		 if (parameters != null) {
			 log.append("" with the following settings:"");
			 for (Map.Entry<String, String> entry : parameters.entrySet()) {
				 log.append(newline);
				 log.append("" "");
				 log.append(entry.getKey());
				 log.append("": "");
				 log.append(entry.getValue());
			 }
		 }
		 else {
			 log.append("" with the default settings."");
		 }
		 if (parameters != null && parameters.containsKey(JcrUtils.REPOSITORY_URI)) {
			 String uri = parameters.get(JcrUtils.REPOSITORY_URI);
			 try {
				 URI u = new URI(uri);
				 String query = u.getRawQuery();
				 if (query != null) {
					 Map<String, String> copy = new HashMap<String, String>(parameters);
					 for (String entry : query.split(""&"")) {
						 int i = entry.indexOf('=');
						 if (i != -1) {
							 copy.put( decode(entry.substring(0, i), ""UTF-8""), decode(entry.substring(i + 1), ""UTF-8""));
						 }
						 else {
							 copy.put( decode(entry, ""UTF-8""), Boolean.TRUE.toString());
						 }
					 }
					 copy.put( JcrUtils.REPOSITORY_URI, new URI(u.getScheme(), u.getRawAuthority(), u.getRawPath(), null, u.getRawFragment() ).toASCIIString());
					 parameters = copy;
				 }
			 }
			 catch (URISyntaxException e) {
				 log.append(newline);
				 log.append(""Note that the given repository URI was invalid:"");
				 log.append(newline);
				 log.append("" "").append(uri);
				 log.append(newline);
				 log.append("" "").append(e.getMessage());
			 }
			 catch (UnsupportedEncodingException e) {
				 throw new RepositoryException(""UTF-8 is not supported!"", e);
			 }
		 }
		 log.append(newline);
		 log.append(""The following RepositoryFactory classes were consulted:"");
		 Iterator<RepositoryFactory> iterator = ServiceLoader.load(RepositoryFactory.class).iterator();
		 while (iterator.hasNext()) {
			 RepositoryFactory factory = iterator.next();
			 log.append(newline);
			 log.append("" "");
			 log.append(factory.getClass().getName());
			 try {
				 Repository repository = factory.getRepository(parameters);
				 if (repository != null) {
					 return repository;
				 }
				 else {
					 log.append("": declined"");
				 }
			 }
			 catch (Exception e) {
				 log.append("": failed"");
				 try (StringWriter writer = new StringWriter();
				 PrintWriter printWriter = new PrintWriter(writer)) {
					 e.printStackTrace(printWriter);
					 log.append(newline).append(writer.getBuffer());
				 }
				 catch (IOException e1) {
					 log.append(""Could not determine root cause due to "").append(e.getMessage());
				 }
			 }
		 }
		 log.append(newline);
		 log.append( ""Perhaps the repository you are trying"" + "" to access is not available at the moment."");
		 throw new RepositoryException(log.toString());
	 }
	 public static Repository getRepository(String uri) throws RepositoryException {
		 Map<String, String> parameters = new HashMap<String, String>();
		 parameters.put(JcrUtils.REPOSITORY_URI, uri);
		 return getRepository(parameters);
	 }
	 public static Iterable<Node> getSharedSet(final Node node) throws RepositoryException {
		 final NodeIterator iterator = node.getSharedSet();
		 return new Iterable<Node>() {
			 private boolean first = true;
			 public synchronized Iterator<Node> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getSharedSet();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Node> getChildNodes(final Node node) throws RepositoryException {
		 final NodeIterator iterator = node.getNodes();
		 return new Iterable<Node>() {
			 private boolean first = true;
			 public synchronized Iterator<Node> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getNodes();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Node> getChildNodes( final Node node, final String pattern) throws RepositoryException {
		 final NodeIterator iterator = node.getNodes(pattern);
		 return new Iterable<Node>() {
			 private boolean first = true;
			 public synchronized Iterator<Node> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getNodes(pattern);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Node> getChildNodes( final Node node, final String[] globs) throws RepositoryException {
		 final NodeIterator iterator = node.getNodes(globs);
		 return new Iterable<Node>() {
			 private boolean first = true;
			 public synchronized Iterator<Node> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getNodes(globs);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getProperties(final Node node) throws RepositoryException {
		 final PropertyIterator iterator = node.getProperties();
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getProperties();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getProperties( final Node node, final String pattern) throws RepositoryException {
		 final PropertyIterator iterator = node.getProperties(pattern);
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getProperties(pattern);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getProperties( final Node node, final String[] globs) throws RepositoryException {
		 final PropertyIterator iterator = node.getProperties(globs);
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getProperties(globs);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getReferences(final Node node) throws RepositoryException {
		 final PropertyIterator iterator = node.getReferences();
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getReferences();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getReferences( final Node node, final String name) throws RepositoryException {
		 final PropertyIterator iterator = node.getReferences(name);
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getReferences(name);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getWeakReferences(final Node node) throws RepositoryException {
		 final PropertyIterator iterator = node.getWeakReferences();
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getWeakReferences();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Property> getWeakReferences( final Node node, final String name) throws RepositoryException {
		 final PropertyIterator iterator = node.getWeakReferences(name);
		 return new Iterable<Property>() {
			 private boolean first = true;
			 public synchronized Iterator<Property> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return node.getWeakReferences(name);
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Node> getNodes(final QueryResult result) throws RepositoryException {
		 final NodeIterator iterator = result.getNodes();
		 return new Iterable<Node>() {
			 private boolean first = true;
			 public synchronized Iterator<Node> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return result.getNodes();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static Iterable<Row> getRows(final QueryResult result) throws RepositoryException {
		 final RowIterator iterator = result.getRows();
		 return new Iterable<Row>() {
			 private boolean first = true;
			 public synchronized Iterator<Row> iterator() {
				 if (first) {
					 first = false;
					 return iterator;
				 }
				 else {
					 try {
						 return result.getRows();
					 }
					 catch (RepositoryException e) {
						 throw new RuntimeException(e);
					 }
				 }
			 }
		 }
		;
	 }
	 public static <I> Iterable<I> in(final Iterator<I> iterator) {
		 return new Iterable<I>() {
			 private boolean stale = false;
			 public synchronized Iterator<I> iterator() {
				 if (stale) {
					 throw new IllegalStateException(""Cannot reuse Iterable intended for single use"");
				 }
				 stale = true;
				 return iterator;
			 }
		 }
		;
	 }
	 public static Iterable<AccessControlPolicyIterator> in(AccessControlPolicyIterator iterator) {
		 return in((Iterator<AccessControlPolicyIterator>) iterator);
	 }
	 public static Iterable<Event> in(EventIterator iterator) {
		 return in((Iterator<Event>) iterator);
	 }
	 public static Iterable<EventListener> in(EventListenerIterator iterator) {
		 return in((Iterator<EventListener>) iterator);
	 }
	 public static Iterable<Node> in(NodeIterator iterator) {
		 return in((Iterator<Node>) iterator);
	 }
	 public static Iterable<NodeType> in(NodeTypeIterator iterator) {
		 return in((Iterator<NodeType>) iterator);
	 }
	 public static Iterable<Property> in(PropertyIterator iterator) {
		 return in((Iterator<Property>) iterator);
	 }
	 public static Iterable<Row> in(RowIterator iterator) {
		 return in((Iterator<Row>) iterator);
	 }
	 public static Iterable<Version> in(VersionIterator iterator) {
		 return in((Iterator<Version>) iterator);
	 }
	 public static Node getOrAddNode(Node parent, String name) throws RepositoryException {
		 return getOrAddNode(parent, name, null);
	 }
	 public static Node getOrAddNode(Node parent, String name, String type) throws RepositoryException {
		 if (parent.hasNode(name)) {
			 return parent.getNode(name);
		 }
		 else if (type != null) {
			 return parent.addNode(name, type);
		 }
		 else {
			 return parent.addNode(name);
		 }
	 }
	 public static Node getOrAddFolder(Node parent, String name) throws RepositoryException {
		 return getOrAddNode(parent, name, NodeType.NT_FOLDER);
	 }
	 public static Node putFile( Node parent, String name, String mime, InputStream data) throws RepositoryException {
		 return putFile(parent, name, mime, data, Calendar.getInstance());
	 }
	 public static Node putFile( Node parent, String name, String mime, InputStream data, Calendar date) throws RepositoryException {
		 Binary binary = parent.getSession().getValueFactory().createBinary(data);
		 try {
			 Node file = getOrAddNode(parent, name, NodeType.NT_FILE);
			 Node content = getOrAddNode(file, Node.JCR_CONTENT, NodeType.NT_RESOURCE);
			 content.setProperty(Property.JCR_MIMETYPE, mime);
			 String[] parameters = mime.split("";
			"");
			 for (int i = 1;
			 i < parameters.length;
			 i++) {
				 int equals = parameters[i].indexOf('=');
				 if (equals != -1) {
					 String parameter = parameters[i].substring(0, equals);
					 if (""charset"".equalsIgnoreCase(parameter.trim())) {
						 content.setProperty( Property.JCR_ENCODING, parameters[i].substring(equals + 1).trim());
					 }
				 }
			 }
			 content.setProperty(Property.JCR_LAST_MODIFIED, date);
			 content.setProperty(Property.JCR_DATA, binary);
			 return file;
		 }
		 finally {
			 binary.dispose();
		 }
	 }
	 public static InputStream readFile(Node node) throws RepositoryException {
		 if (node.hasProperty(Property.JCR_DATA)) {
			 Property data = node.getProperty(Property.JCR_DATA);
			 final Binary binary = data.getBinary();
			 return new FilterInputStream(binary.getStream()) {
				 public void close() throws IOException {
					 super.close();
					 binary.dispose();
				 }
			 }
			;
		 }
		 else if (node.hasNode(Node.JCR_CONTENT)) {
			 return readFile(node.getNode(Node.JCR_CONTENT));
		 }
		 else {
			 throw new RepositoryException( ""Unable to read file node: "" + node.getPath());
		 }
	 }
	 public static void readFile(Node node, OutputStream output) throws RepositoryException, IOException {
		 InputStream input = readFile(node);
		 try {
			 byte[] buffer = new byte[16 * 1024];
			 int n = input.read(buffer);
			 while (n != -1) {
				 output.write(buffer, 0, n);
				 n = input.read(buffer);
			 }
		 }
		 finally {
			 input.close();
		 }
	 }
	 public static Calendar getLastModified(Node node) throws RepositoryException {
		 if (node.hasProperty(Property.JCR_LAST_MODIFIED)) {
			 return node.getProperty(Property.JCR_LAST_MODIFIED).getDate();
		 }
		 else if (node.hasNode(Node.JCR_CONTENT)) {
			 return getLastModified(node.getNode(Node.JCR_CONTENT));
		 }
		 else {
			 return null;
		 }
	 }
	 public static void setLastModified(Node node, Calendar date) throws RepositoryException {
		 if (node.hasNode(Node.JCR_CONTENT)) {
			 setLastModified(node.getNode(Node.JCR_CONTENT), date);
		 }
		 else {
			 node.setProperty(Property.JCR_LAST_MODIFIED, date);
		 }
	 }
	 public static String toString(Item item) {
		 StringBuilder builder = new StringBuilder();
		 try {
			 if (item.isNode()) {
				 builder.append(item.getPath());
				 builder.append("" ["");
				 builder.append(((Node) item).getPrimaryNodeType().getName());
				 builder.append(""]"");
			 }
			 else {
				 builder.append(""@"");
				 builder.append(item.getName());
				 builder.append("" = "");
				 Property property = (Property) item;
				 if (property.isMultiple()) {
					 builder.append(""[ "");
					 Value[] values = property.getValues();
					 for (int i = 0;
					 i < values.length && i < 3;
					 i++) {
						 if (i > 0) {
							 builder.append("", "");
						 }
						 append(builder, values[i]);
					 }
					 if (values.length >= 3) {
						 builder.append("", ..."");
					 }
					 builder.append("" ]"");
				 }
				 else {
					 append(builder, property.getValue());
				 }
			 }
		 }
		 catch (RepositoryException e) {
			 builder.append(""!!! "");
			 builder.append(e.getMessage());
			 builder.append("" !!!"");
		 }
		 return builder.toString();
	 }
	 private static void append(StringBuilder builder, Value value) throws RepositoryException {
		 if (value.getType() == PropertyType.BINARY) {
			 Binary binary = value.getBinary();
			 try {
				 builder.append(""<"");
				 builder.append(binary.getSize());
				 builder.append("" bytes>"");
			 }
			 finally {
				 binary.dispose();
			 }
		 }
		 else {
			 String string = value.getString();
			 if (string.length() > 40) {
				 builder.append(string.substring(0, 37));
				 builder.append(""..."");
			 }
			 else {
				 builder.append(string);
			 }
		 }
	 }
	 private static final List<String> PROPERTY_TYPES_NAMES = new ArrayList<String>();
	 private static final Map<String, Integer> PROPERTY_TYPES = new HashMap<String, Integer>();
	 static {
		 for (int i = PropertyType.UNDEFINED;
		 i <= PropertyType.DECIMAL;
		 i++) {
			 String typeName = PropertyType.nameFromValue(i);
			 PROPERTY_TYPES_NAMES.add(typeName);
			 PROPERTY_TYPES.put(typeName.toLowerCase(), i);
		 }
	 }
	 public static int getPropertyType(String name) throws IllegalArgumentException {
		 Integer type = PROPERTY_TYPES.get(name.toLowerCase());
		 if (type != null) {
			 return type;
		 }
		 else {
			 throw new IllegalArgumentException(""Unknown property type: "" + name);
		 }
	 }
	 public static String[] getPropertyTypeNames(boolean includeUndefined) {
		 if (includeUndefined) {
			 return PROPERTY_TYPES_NAMES.toArray(new String[PROPERTY_TYPES_NAMES.size()]);
		 }
		 else {
			 String[] typeNames = new String[PROPERTY_TYPES_NAMES.size()-1];
			 int i = 0;
			 for (String name : PROPERTY_TYPES_NAMES) {
				 if (!PropertyType.TYPENAME_UNDEFINED.equals(name)) {
					 typeNames[i++] = name;
				 }
			 }
			 return typeNames;
		 }
	 }
	 public static Node getOrCreateByPath(String absolutePath, String nodeType, Session session) throws RepositoryException {
		 return getOrCreateByPath(absolutePath, false, nodeType, nodeType, session, false);
	 }
	 public static Node getOrCreateByPath(String absolutePath, String intermediateNodeType, String nodeType, Session session, boolean autoSave) throws RepositoryException {
		 return getOrCreateByPath(absolutePath, false, intermediateNodeType, nodeType, session, autoSave);
	 }
	 public static Node getOrCreateUniqueByPath(String pathHint, String nodeType, Session session) throws RepositoryException {
		 return getOrCreateByPath(pathHint, true, nodeType, nodeType, session, false);
	 }
	 public static Node getOrCreateByPath(String absolutePath, boolean createUniqueLeaf, String intermediateNodeType, String nodeType, Session session, boolean autoSave) throws RepositoryException {
		 if (absolutePath == null || absolutePath.length() == 0 || ""/"".equals(absolutePath)) {
			 return session.getRootNode();
		 }
		 else if (!absolutePath.startsWith(""/"")) {
			 throw new IllegalArgumentException(""not an absolute path: "" + absolutePath);
		 }
		 else if (session.nodeExists(absolutePath) && !createUniqueLeaf) {
			 return session.getNode(absolutePath);
		 }
		 else {
			 String path = absolutePath;
			 int currentIndex = path.lastIndexOf('/');
			 String existingPath = null;
			 while (currentIndex > 0 && existingPath == null) {
				 path = path.substring(0, currentIndex);
				 if (session.nodeExists(path)) {
					 existingPath = path;
				 }
				 else {
					 currentIndex = path.lastIndexOf('/');
				 }
			 }
			 return getOrCreateByPath(existingPath == null ? session.getRootNode() : session.getNode(existingPath), absolutePath.substring(currentIndex + 1), createUniqueLeaf, intermediateNodeType, nodeType, autoSave);
		 }
	 }
	 public static Node getOrCreateUniqueByPath(Node parent, String nodeNameHint, String nodeType) throws RepositoryException {
		 return getOrCreateByPath(parent, nodeNameHint, true, nodeType, nodeType, false);
	 }
	 public static Node getOrCreateByPath(Node baseNode, String path, boolean createUniqueLeaf, String intermediateNodeType, String nodeType, boolean autoSave) throws RepositoryException {
		 if (!createUniqueLeaf && baseNode.hasNode(path)) {
			 return baseNode.getNode(path);
		 }
		 String fullPath = baseNode.getPath().equals(""/"") ? ""/"" + path : baseNode.getPath() + ""/"" + path;
		 int currentIndex = fullPath.lastIndexOf('/');
		 String temp = fullPath;
		 String existingPath = null;
		 while (currentIndex > 0) {
			 temp = temp.substring(0, currentIndex);
			 if (baseNode.getSession().itemExists(temp)) {
				 existingPath = temp;
				 break;
			 }
			 currentIndex = temp.lastIndexOf('/');
		 }
		 if (existingPath != null) {
			 baseNode = baseNode.getSession().getNode(existingPath);
			 path = fullPath.substring(existingPath.length() + 1);
		 }
		 Node node = baseNode;
		 int pos = path.lastIndexOf('/');
		 if (pos != -1) {
			 final StringTokenizer st = new StringTokenizer(path.substring(0, pos), ""/"");
			 while (st.hasMoreTokens()) {
				 final String token = st.nextToken();
				 if (!node.hasNode(token)) {
					 try {
						 if (intermediateNodeType != null) {
							 node.addNode(token, intermediateNodeType);
						 }
						 else {
							 node.addNode(token);
						 }
						 if (autoSave) {
							 node.getSession().save();
						 }
					 }
					 catch (RepositoryException e) {
						 node.refresh(false);
					 }
				 }
				 node = node.getNode(token);
			 }
			 path = path.substring(pos + 1);
		 }
		 if (!node.hasNode(path)) {
			 if (nodeType != null) {
				 node.addNode(path, nodeType);
			 }
			 else {
				 node.addNode(path);
			 }
			 if (autoSave) {
				 node.getSession().save();
			 }
		 }
		 else if (createUniqueLeaf) {
			 String leafNodeName;
			 int i = 0;
			 do {
				 leafNodeName = path + String.valueOf(i);
				 i++;
			 }
			 while (node.hasNode(leafNodeName));
			 Node leaf;
			 if (nodeType != null) {
				 leaf = node.addNode(leafNodeName, nodeType);
			 }
			 else {
				 leaf = node.addNode(leafNodeName);
			 }
			 if (autoSave) {
				 node.getSession().save();
			 }
			 return leaf;
		 }
		 return node.getNode(path);
	 }
	 public static Node getNodeIfExists(Node baseNode, String relPath) throws RepositoryException {
		 try {
			 return baseNode.getNode(relPath);
		 }
		 catch (PathNotFoundException e) {
			 return null;
		 }
	 }
	 public static Node getNodeIfExists(String absPath, Session session) throws RepositoryException {
		 try {
			 return session.getNode(absPath);
		 }
		 catch (PathNotFoundException e) {
			 return null;
		 }
	 }
	 public static String getStringProperty(Node baseNode, String relPath, String defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getString();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static long getLongProperty(Node baseNode, String relPath, long defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getLong();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static double getDoubleProperty(Node baseNode, String relPath, double defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getDouble();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static boolean getBooleanProperty(Node baseNode, String relPath, boolean defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getBoolean();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static Calendar getDateProperty(Node baseNode, String relPath, Calendar defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getDate();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static BigDecimal getDecimalProperty(Node baseNode, String relPath, BigDecimal defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getDecimal();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static Binary getBinaryProperty(Node baseNode, String relPath, Binary defaultValue) throws RepositoryException {
		 try {
			 return baseNode.getProperty(relPath).getBinary();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static String getStringProperty(Session session, String absPath, String defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getString();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static long getLongProperty(Session session, String absPath, long defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getLong();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static double getDoubleProperty(Session session, String absPath, double defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getDouble();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static boolean getBooleanProperty(Session session, String absPath, boolean defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getBoolean();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static Calendar getDateProperty(Session session, String absPath, Calendar defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getDate();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static BigDecimal getDecimalProperty(Session session, String absPath, BigDecimal defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getDecimal();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
	 public static Binary getBinaryProperty(Session session, String absPath, Binary defaultValue) throws RepositoryException {
		 try {
			 return session.getProperty(absPath).getBinary();
		 }
		 catch (PathNotFoundException e) {
			 return defaultValue;
		 }
	 }
}",1,0,0,0
"public class Builder {
	public static boolean isForced(Map<?, ?> options) {
		return Boolean.TRUE.equals(options.get(""force""));
	}
	private Properties options = new Properties();
	private BuilderExtension[] extensions = new BuilderExtension[0];
	private Logger logger = new NullLogger();
	private ConfigurationRegistry registry;
	private ConfigObject configObject = null;
	private boolean isIncremental = false;
	private boolean enabledMetadata = false;
	private File sourceDir = null;
	private final Map<File, String[]> buildFilesBySourceDir = new HashMap<>();
	private final Map<File, List<String>> deleteFilesBySourceDir = new HashMap<>();
	private final Map<File, List<String>> buildResourcesBySourceDir = new HashMap<>();
	private int buildFileCount = 0;
	private int deleteFileCount = 0;
	private int builtFileCount = 0;
	private int buildResourcesCount = 0;
	private File outputDir = null;
	private boolean verdict = false;
	private boolean includeIfUnsure = false;
	private boolean isTestsBootPath = false;
	private boolean noWarnIncludeIf = false;
	private boolean noWarnInvalidFlags = false;
	private boolean multipleSources = false;
	private boolean updateAllCopyrights = false;
	public Builder() {
		addExtension(new ExternalMessagesExtension());
		addExtension(new MacroExtension());
		addExtension(new JxeRulesExtension());
		addExtension(new EclipseMetadataExtension());
		addExtension(new JitAttributesExtension());
		addExtension(new TagExtension());
	}
	public void setOptions(Properties options) {
		if (options != null) {
			this.options.putAll(options);
		}
		this.options = options;
	}
	public Properties getOptions() {
		return this.options;
	}
	public void addExtension(BuilderExtension extension) {
		if (extension == null) {
			throw new NullPointerException();
		}
		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1];
		if (extensions.length > 0) {
			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length);
		}
		newExtensions[newExtensions.length - 1] = extension;
		this.extensions = newExtensions;
		extension.setBuilder(this);
	}
	public BuilderExtension[] getExtensions() {
		return extensions;
	}
	public Logger getLogger() {
		return logger;
	}
	public void setLogger(Logger logger) {
		this.logger = logger;
	}
	public void setIncremental(boolean isIncremental) {
		this.isIncremental = isIncremental;
	}
	public boolean isIncremental() {
		return this.isIncremental;
	}
	public void setMetadata(boolean enabledMetadata) {
		this.enabledMetadata = enabledMetadata;
	}
	public boolean isMetadataEnabled() {
		return this.enabledMetadata;
	}
	public void setIncludeIfUnsure(boolean include) {
		this.includeIfUnsure = include;
	}
	public void setIsTestsBoot(boolean isTestsBoot) {
		this.isTestsBootPath = isTestsBoot;
	}
	public void setNoWarnIncludeIf(boolean warning) {
		this.noWarnIncludeIf = warning;
	}
	public void setConfiguration(ConfigObject config) {
		if (config.isSet()) {
			System.err.println(""Warning: Builder is using "" + config + "", a set, not a configuration."");
		}
		this.configObject = config;
		this.registry = config.getRegistry();
		this.outputDir = config.getOutputDir();
	}
	public File getOutputDir() {
		return this.outputDir;
	}
	public void setOutputDir(File outputDir) {
		if (outputDir == null) {
			throw new NullPointerException();
		}
		this.outputDir = outputDir;
	}
	public File getSourceDir() {
		return this.sourceDir;
	}
	public void setSourceDir(File sourceDir) {
		if (sourceDir == null) {
			throw new NullPointerException();
		}
		 else {
			this.sourceDir = sourceDir;
		}
	}
	public void setMultipleSources(boolean multipleSources) {
		this.multipleSources = multipleSources;
	}
	public boolean hasMultipleSources() {
		return multipleSources;
	}
	public boolean build() {
		getOutputDir().mkdirs();
		if (validateOptions()) {
			computeBuildFiles();
			notifyBuildBegin();
			PreprocessorFactory factory = newPreprocessorFactory();
			boolean force = isForced(this.options);
			if (sourceDir != null) {
				File metadataDir = new File(outputDir.getParentFile(), ""jppmd"");
				String[] buildFiles = buildFilesBySourceDir.get(sourceDir);
				getLogger().log(""\nPreprocessing "" + sourceDir.getAbsolutePath(), 1);
				builtFileCount = 0;
				for (String buildFile : buildFiles) {
					File sourceFile = new File(sourceDir, buildFile);
					File outputFile = new File(outputDir, buildFile);
					File metadataFile = new File(metadataDir, buildFile + "".jppmd"");
					notifyBuildFileBegin(sourceFile, outputFile, buildFile);
					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile);
					 OutputStream output = new PhantomOutputStream(outputFile, force)) {
						JavaPreprocessor jpp;
						if (enabledMetadata) {
							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile);
						}
						 else {
							jpp = factory.newPreprocessor(sourceFile, output);
						}
						Calendar cal = new GregorianCalendar();
						if (!updateAllCopyrights) {
							cal.setTime(new Date(sourceFile.lastModified()));
						}
						jpp.setCopyrightYear(cal.get(Calendar.YEAR));
						jpp.addValidFlags(registry.getValidFlags());
						jpp.setTestBootPath(isTestsBootPath);
						notifyConfigurePreprocessor(jpp);
						boolean included = false;
						try {
							included = jpp.preprocess();
							if (included) {
								builtFileCount++;
							}
							handlePreprocessorWarnings(jpp, sourceFile);
						}
						 catch (Throwable t) {
							handlePreprocessorException(t, sourceFile);
						}
						if (!included && outputFile.exists()) {
							outputFile.delete();
						}
						if (!included && metadataFile.exists()) {
							metadataFile.delete();
						}
					}
					 catch (Throwable t) {
						getLogger().log(""Exception occured in file "" + sourceFile.getAbsolutePath() + "", preprocess failed."", 3, t);
						handleBuildException(t);
					}
					 finally {
						notifyBuildFileEnd(sourceFile, outputFile, buildFile);
					}
				}
				logger.log(builtFileCount + "" of "" + buildFileCount + "" file(s) included in preprocess"", 1);
				List<String> deleteFiles = deleteFilesBySourceDir.get(sourceDir);
				if (deleteFiles != null && deleteFiles.size() != 0) {
					int deletedFilesCount = 0;
					for (String file : deleteFiles) {
						File deleteFile = new File(outputDir, file);
						if (deleteFile.exists()) {
							deletedFilesCount++;
							deleteFile.delete();
						}
					}
					getLogger().log(deletedFilesCount + "" of "" + deleteFileCount+ "" file(s) deleted in preprocess from "" + outputDir.getAbsolutePath(), 1);
				}
			}
			List<String> buildResources = buildResourcesBySourceDir.get(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				int copiedResourcesCount = 0;
				int deletedResorucesCount = 0;
				String outputpath;
				if (isTestsBootPath) {
					outputpath = configObject.getBootTestsOutputPath();
				}
				 else {
					outputpath = configObject.getTestsOutputPath();
				}
				for (String file : buildResources) {
					File resource_out = new File(outputpath, file);
					File resource_src = new File(sourceDir, file);
					if (resource_src.exists()) {
						copyResource(resource_src, resource_out);
						copiedResourcesCount++;
					}
					 else {
						resource_out.delete();
						deletedResorucesCount++;
					}
				}
				getLogger().log(""Total Build Resource Count : "" + buildResourcesCount, 1);
				getLogger().log("" - "" + copiedResourcesCount + "" resource"" + (copiedResourcesCount > 1 ? ""s are "" : "" is "") + ""copied to "" + outputpath, 1);
				getLogger().log("" - "" + deletedResorucesCount + "" resource"" + (deletedResorucesCount > 1 ? ""s are "" : "" is "") + ""deleted from "" + outputpath, 1);
			}
			notifyBuildEnd();
		}
		if (logger.getErrorCount() == 0) {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS SUCCESSFUL"", 1);
			}
			return true;
		}
		 else {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS NOT SUCCESSFUL"", 1);
			}
			return false;
		}
	}
	public static void copyResource(File source, File destination) {
		destination.delete();
		try {
			SimpleCopy.copyFile(source, destination);
		}
		 catch (IOException e) {
			System.err.println(""ERROR - Could not copy the file to destination"");
			System.err.println("" Source: "" + source.toString());
			System.err.println("" Destination: "" + destination.toString());
			e.printStackTrace();
		}
	}
	private boolean validateOptions() {
		boolean isValid = true;
		if (configObject == null) {
			configObject = registry.getConfiguration(options.getProperty(""config""));
		}
		this.options.putAll(configObject.getOptions());
		if (options.containsKey(""verdict"")) {
			this.verdict = true;
		}
		if (options.containsKey(""includeifunsure"")) {
			setIncludeIfUnsure(true);
		}
		if (options.containsKey(""nowarnincludeif"")) {
			setNoWarnIncludeIf(true);
		}
		if (options.containsKey(""nowarninvalidflags"")) {
			this.noWarnInvalidFlags = true;
		}
		if (options.containsKey(""updateallcopyrights"")) {
			this.updateAllCopyrights = true;
		}
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				extension.validateOptions(this.options);
			}
		}
		 catch (BuilderConfigurationException e) {
			logger.log(""A configuration exception occured"", Logger.SEVERITY_FATAL, e);
			isValid = false;
		}
		 catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking validateOptions() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
		return isValid;
	}
	private void notifyBuildBegin() {
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildBegin();
				logger.setMessageSource(null);
			}
		}
		 catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}
	private void notifyBuildEnd() {
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildEnd();
				logger.setMessageSource(null);
			}
		}
		 catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}
	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) {
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		}
		 catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}
	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) {
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		}
		 catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}
	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) {
		preprocessor.setIncludeIfUnsure(this.includeIfUnsure);
		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyConfigurePreprocessor(preprocessor);
				logger.setMessageSource(null);
			}
		}
		 catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyConfigurePreprocessor() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}
	private void handleBuildException(Throwable t) {
		if (t instanceof Error) {
			logger.log(""An error occured while building"", Logger.SEVERITY_FATAL, t);
			throw (Error) t;
		}
		 else {
			logger.log(""An exception occured while building"", Logger.SEVERITY_ERROR, t);
		}
	}
	private void handlePreprocessorException(Throwable t, File sourceFile) {
		if (t instanceof Error) {
			logger.log(""An error occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_FATAL, sourceFile, t);
			throw (Error) t;
		}
		 else {
			logger.log(""An exception occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, t);
		}
	}
	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) {
		if (jpp.hasWarnings()) {
			for (PreprocessorWarning warning : jpp.getWarnings()) {
				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING;
				if (warning.getMessage().startsWith(""No INCLUDE-IF"") && sourceFile.getAbsolutePath().endsWith("".java"") && !includeIfUnsure && !isTestsBootPath) {
					severity = Logger.SEVERITY_ERROR;
				}
				if (warning.getMessage().startsWith(""Ignoring copyright"")) {
					severity = Logger.SEVERITY_INFO;
				}
				logger.log(warning.getMessage(), ""preprocessor"", severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}
		if (!noWarnInvalidFlags) {
			for (PreprocessorWarning warning : jpp.getInvalidFlags()) {
				logger.log(warning.getMessage(), ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}
	}
	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) {
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath);
			logger.setMessageSource(null);
			if (!shouldBuild) {
				return false;
			}
		}
		return true;
	}
	private List<String> getDeletedFiles(File sourceDir) {
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getDeleteFiles(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}
		return null;
	}
	private List<String> getBuildResources(File sourceDir) {
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getBuildResources(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}
		return null;
	}
	private PreprocessorFactory newPreprocessorFactory() {
		PreprocessorFactory factory = new PreprocessorFactory();
		factory.setFlags(this.configObject.getFlagsAsArray());
		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet());
		return factory;
	}
	private List<String> getFiles(File rootDirectory) {
		List<String> fileList = new ArrayList<>();
		File[] files = rootDirectory.listFiles();
		if (files == null) {
			StringBuffer msg = new StringBuffer(""Error reading the source directory \"""");
			msg.append(rootDirectory.getAbsolutePath());
			msg.append(""\"" - No Files copied"");
			getLogger().log(msg.toString(), 2);
			verdict = false;
		}
		 else {
			getFiles(files, """", fileList);
		}
		return fileList;
	}
	private static void getFiles(File[] files, String relativePath, List<String> fileList) {
		for (File file : files) {
			if (file.isFile()) {
				fileList.add(relativePath + file.getName());
			}
			 else {
				String childRelativePath = relativePath + file.getName() + File.separator;
				getFiles(file.listFiles(), childRelativePath, fileList);
			}
		}
	}
	private void computeBuildFiles() {
		if (sourceDir.exists()) {
			List<String> allFiles = getFiles(sourceDir);
			List<String> buildFiles = new ArrayList<>(allFiles.size());
			for (int j = 0;
			 j < allFiles.size();
			 j++) {
				String currentFile = allFiles.get(j).toString();
				if (shouldBuild(sourceDir, outputDir, currentFile)) {
					buildFiles.add(currentFile);
				}
			}
			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]);
			buildFilesBySourceDir.put(sourceDir, buildFilesArray);
			buildFileCount += buildFilesArray.length;
			List<String> deleteFiles = getDeletedFiles(sourceDir);
			if (deleteFiles != null && deleteFiles.size() != 0) {
				deleteFileCount = deleteFiles.size();
				deleteFilesBySourceDir.put(sourceDir, deleteFiles);
			}
			List<String> buildResources = getBuildResources(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				buildResourcesCount = buildResources.size();
				buildResourcesBySourceDir.put(sourceDir, buildResources);
			}
		}
		 else {
			logger.log(""Error: Source directory does not exist: "" + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException());
			sourceDir = null;
		}
	}
	public int getBuildFileCount() {
		return buildFileCount;
	}
}",1,1,0,0
"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	if (method.getName().equals(""equals"")) {
		return (proxy == args[0]);
	}
	else if (method.getName().equals(""hashCode"")) {
		return hashCode();
	}
	else if (method.getName().equals(""toString"")) {
		return ""Shared EntityManager proxy for target factory ["" + this.targetFactory + ""]"";
	}
	else if (method.getName().equals(""getEntityManagerFactory"")) {
		return this.targetFactory;
	}
	else if (method.getName().equals(""getCriteriaBuilder"") || method.getName().equals(""getMetamodel"")) {
		try {
			return EntityManagerFactory.class.getMethod(method.getName()).invoke(this.targetFactory);
		}
		catch (InvocationTargetException ex) {
			throw ex.getTargetException();
		}
	}
	else if (method.getName().equals(""unwrap"")) {
		Class<T> targetClass = (Class<T>) args[0];
		if (targetClass != null && targetClass.isInstance(proxy)) {
			return proxy;
		}
	}
	else if (method.getName().equals(""isOpen"")) {
		return true;
	}
	else if (method.getName().equals(""close"")) {
		return null;
	}
	else if (method.getName().equals(""getTransaction"")) {
		throw new IllegalStateException(""Not allowed to create transaction on shared EntityManager - "" +""use Spring transactions or EJB CMT instead"");
	}
	EntityManager target = EntityManagerFactoryUtils.doGetTransactionalEntityManager(this.targetFactory, this.properties, this.synchronizedWithTransaction);
	if (method.getName().equals(""getTargetEntityManager"")) {
		if (target == null) {
			throw new IllegalStateException(""No transactional EntityManager available"");
		}
		return target;
	}
	else if (method.getName().equals(""unwrap"")) {
		Class<T> targetClass = (Class<T>) args[0];
		if (targetClass == null) {
			return (target != null ? target : proxy);
		}
		if (target == null) {
			throw new IllegalStateException(""No transactional EntityManager available"");
		}
	}
	else if (transactionRequiringMethods.contains(method.getName())) {
		if (target == null || (!TransactionSynchronizationManager.isActualTransactionActive() &&!target.getTransaction().isActive())) {
			throw new TransactionRequiredException(""No EntityManager with actual transaction available "" +""for current thread - cannot reliably process '"" + method.getName() + ""' call"");
		}
	}
	boolean isNewEm = false;
	if (target == null) {
		logger.debug(""Creating new EntityManager for shared EntityManager invocation"");
		target = (!CollectionUtils.isEmpty(this.properties) ?this.targetFactory.createEntityManager(this.properties) :this.targetFactory.createEntityManager());
		isNewEm = true;
	}
	try {
		Object result = method.invoke(target, args);
		if (result instanceof Query) {
			Query query = (Query) result;
			if (isNewEm) {
				Class<T>[] ifcs = ClassUtils.getAllInterfacesForClass(query.getClass(), this.proxyClassLoader);
				result = Proxy.newProxyInstance(this.proxyClassLoader, ifcs,new DeferredQueryInvocationHandler(query, target));
				isNewEm = false;
			}
			else {
				EntityManagerFactoryUtils.applyTransactionTimeout(query, this.targetFactory);
			}
		}
		return result;
	}
	catch (InvocationTargetException ex) {
		throw ex.getTargetException();
	}
	finally {
		if (isNewEm) {
			EntityManagerFactoryUtils.closeEntityManager(target);
		}
	}
}",0,0,1,0
"private String formatQueryString(final String projectUri, final String[] args) {
	 final StringBuffer result = new StringBuffer();
	 if (projectUri != null) {
		 if (isCompatibleMode) {
			 result.append(""puri="");
			 result.append(URLEncode.encode(projectUri.toString()));
		 }
		 else {
			 final ArtifactID artifactID = new ArtifactID(projectUri);
			 result.append(""pguid="");
			 result.append(URLEncode.encode(artifactID.getToolSpecificID()));
		 }
	 }
	 else if (!isCompatibleMode) {
		 result.append(""pcguid="");
		 result.append(URLEncode.encode(collectionId.toString()));
	 }
	 for (int i = 0;
	 i < args.length - 1;
	 i += 2) {
		 final String name = args[i];
		 final String value = args[i + 1];
		 if (name != null) {
			 if (result.length() > 0) {
				 result.append('&');
			 }
			 result.append(URLEncode.encode(name));
		 }
		 if (value != null) {
			 if (name != null) {
				 result.append('=');
			 }
			 else if (result.length() > 0) {
				 result.append('&');
			 }
			 result.append(URLEncode.encode(value));
		 }
	 }
	 return result.toString();
 }",0,0,1,0
"public class ResourceReferenceDependencyInjectingHeaderResponse extends DecoratingHeaderResponse{
	private final IResourceReferenceDependencyConfigurationService configurationService;
	public ResourceReferenceDependencyInjectingHeaderResponse(IHeaderResponse decorated){
		this(decorated, null);
	}
	public ResourceReferenceDependencyInjectingHeaderResponse(IHeaderResponse decorated,IResourceReferenceDependencyConfigurationService configurator){
		super(decorated);
		configurationService = configurator;
	}
	public IResourceReferenceDependencyConfigurationService getConfigurationService(){
		if (configurationService == null){
			throw new IllegalStateException(""you must either provide an IResourceReferenceDependencyConfigurationService at construction time or override getConfigurationService()"");
		}
		return configurationService;
	}
	public void renderCSSReference(ResourceReference reference){
		render(get(reference));
	}
	public void renderCSSReference(ResourceReference reference, String media){
		AbstractResourceDependentResourceReference parent = get(reference);
		parent.setMedia(media);
		render(parent);
	}
	public void renderJavascriptReference(ResourceReference reference){
		render(get(reference));
	}
	public void renderJavascriptReference(ResourceReference reference, String id){
		AbstractResourceDependentResourceReference parent = get(reference);
		parent.setUniqueId(id);
		render(parent);
	}
	protected void render(AbstractResourceDependentResourceReference parent){
		for (AbstractResourceDependentResourceReference child : parent.getDependentResourceReferences()){
			render(child);
		}
		boolean css = ResourceType.CSS.equals(parent.getResourceType());
		String string = css ? parent.getMedia() : parent.getUniqueId();
		ResourceUtil.renderTo(getRealResponse(), parent, css, string);
	}
	private AbstractResourceDependentResourceReference get(ResourceReference reference){
		AbstractResourceDependentResourceReference ref = getConfigurationService().configure(reference);
		if (ref == null){
			throw new IllegalStateException(""your IResourceReferenceDependencyConfigurationService can not return null from configure"");
		}
		return ref;
	}
}",0,0,0,0
"public void rethrowAnyBuildException() {
	 BuildException ex = getBuildException();
	 if (ex != null) {
		 throw ex;
	 }
 }",0,0,0,0
"private void initComponents() {
	 java.awt.GridBagConstraints gridBagConstraints;
	 jLabel1 = new javax.swing.JLabel();
	 m_progress = new javax.swing.JProgressBar();
	 jScrollPane1 = new javax.swing.JScrollPane();
	 m_state = new javax.swing.JTextArea(10,60);
	m_state.setLineWrap(true);
	 m_cancelbutton = new javax.swing.JButton();
	 getContentPane().setLayout(new java.awt.GridBagLayout());
	 addWindowListener(new java.awt.event.WindowAdapter() {
		 public void windowClosing(java.awt.event.WindowEvent evt) {
			 closeDialog(evt);
		 }
	 }
	);
	 jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
	 jLabel1.setText(""Progress"");
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 1.0;
	 getContentPane().add(jLabel1, gridBagConstraints);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
	 gridBagConstraints.insets = new java.awt.Insets(5, 20, 5, 20);
	 getContentPane().add(m_progress, gridBagConstraints);
	 m_state.setEditable(false);
	 jScrollPane1.setViewportView(m_state);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
	 gridBagConstraints.weightx = 1.0;
	 gridBagConstraints.weighty = 1.0;
	 gridBagConstraints.insets = new java.awt.Insets(5, 10, 5, 10);
	 getContentPane().add(jScrollPane1, gridBagConstraints);
	 m_cancelbutton.setText(""Cancel"");
	 m_cancelbutton.addActionListener(new java.awt.event.ActionListener() {
		 public void actionPerformed(java.awt.event.ActionEvent evt) {
			 cancelbuttonActionPerformed(evt);
		 }
	 }
	);
	 gridBagConstraints = new java.awt.GridBagConstraints();
	 gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
	 gridBagConstraints.insets = new java.awt.Insets(10, 10, 10, 10);
	 gridBagConstraints.weighty = 0.0001;
	 gridBagConstraints.fill = java.awt.GridBagConstraints.NONE;
	 getContentPane().add(m_cancelbutton, gridBagConstraints);
	 java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
	 setBounds((screenSize.width-319)/2, (screenSize.height-158)/2, 319, 158);
 }",0,0,1,0
